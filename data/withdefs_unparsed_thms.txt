{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {n : with_top ℕ} : cont_mdiff I I' n f ↔ continuous f ∧ ∀ (x : M) (y : M'), cont_diff_on 𝕜 n (⇑(ext_chart_at I' y) ∘ f ∘ ⇑((ext_chart_at I x).symm)) ((ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' (f ⁻¹' (ext_chart_at I' y).source))
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] {σ : Type u_3} [inhabited σ] {n : ℕ} (dec : vector bool n → Γ) : turing.TM1.stmt Γ Λ σ → turing.TM1.stmt bool turing.TM1to1.Λ' σ
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] (f : α → E) (h_mem_ℒp : measure_theory.mem_ℒp f p μ) : ↥(measure_theory.Lp E p μ)
(φ fn : interactive.parse (lean.parser.pexpr std.prec.max)) : tactic unit
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] : is_open_map (tangent_bundle.proj I M)
{𝕜 : Type u_1} {𝕝 : Type u_2} {E : Type u_3} [normed_field 𝕜] [normed_ring 𝕝] [normed_space 𝕜 𝕝] [add_comm_group E] [module 𝕜 E] [smul_with_zero 𝕝 E] [is_scalar_tower 𝕜 𝕝 E] {s : set E} (hs : balanced 𝕝 s) {a : 𝕝} {b : 𝕜} (h : ∥a∥ ≤ ∥b∥) : a • s ⊆ b • s
{α : Type u} {β : Type v} [pseudo_metric_space α] {ι : Type u_1} [topological_space β] {F : ι → β → α} {f : β → α} {p : filter ι} : tendsto_locally_uniformly F f p ↔ ∀ (ε : ℝ), ε > 0 → ∀ (x : β), ∃ (t : set β) (H : t ∈ nhds x), ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → has_dist.dist (f y) (F n y) < ε
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {F : C ⥤ D} {G : D ⥤ C} (η : 𝟭 C ≅ F ⋙ G) (ε : G ⋙ F ≅ 𝟭 D) : 𝟭 C ≅ F ⋙ G
{c : Type u → Type u} (hom : Π ⦃α β : Type u⦄, c α → c β → Type u) [𝒞 : category_theory.bundled_hom hom] : category_theory.concrete_category (category_theory.bundled c)
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (G : C ⥤ D) {W X Y : C} (f : W ⟶ X) (g : W ⟶ Y) [category_theory.limits.preserves_colimit (category_theory.limits.span f g) G] : category_theory.limits.preserves_colimit (category_theory.limits.span g f) G
{α : Type u_1} {E' : Type u_5} {𝕜 : Type u_11} {p : ennreal} [is_R_or_C 𝕜] [inner_product_space 𝕜 E'] [complete_space E'] [normed_space ℝ E'] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) (f g : ↥(measure_theory.Lp E' p μ)) (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ⊤) (hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ) (hg_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑g s μ) (hfg : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = ∫ (x : α) in s, ⇑g x ∂μ) (hf_meas : measure_theory.ae_strongly_measurable' m ⇑f μ) (hg_meas : measure_theory.ae_strongly_measurable' m ⇑g μ) : ⇑f =ᵐ[μ] ⇑g
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {μ : measure_theory.measure ℝ} {X : Type u_5} [topological_space X] [topological_space.first_countable_topology X] {F : X → ℝ → E} {bound : ℝ → ℝ} {a b : ℝ} (hF_meas : ∀ (x : X), measure_theory.ae_strongly_measurable (F x) (μ.restrict (set.interval_oc a b))) (h_bound : ∀ (x : X), ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → ∥F x t∥ ≤ bound t) (bound_integrable : interval_integrable bound μ a b) (h_cont : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → continuous (λ (x : X), F x t)) : continuous (λ (x : X), ∫ (t : ℝ) in a..b, F x t ∂μ)
{R : Type u} {S : Type v} [comm_semiring R] [semiring S] [algebra R S] (a : set R) : submodule.span R (⇑(algebra_map R S) '' a) = submodule.map (algebra.linear_map R S) (submodule.span R a)
{E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (h'f' : ∀ (x : E), x ∈ s → (f' x).det = 0) : ⇑μ (f '' s) = 0
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) {μ : 𝕜} (hμ : module.End.has_eigenvalue T μ) : ⇑(star_ring_end 𝕜) μ = μ
{E : Type u_1} [normed_group E] [normed_space ℂ E] {a b : ℝ} {f g : ℂ → E} (hdf : diff_cont_on_cl ℂ f (complex.im ⁻¹' set.Ioo a b)) (hBf : ∃ (c : ℝ) (H : c < real.pi / (b - a)) (B : ℝ), f =O[filter.comap (has_abs.abs ∘ complex.re) filter.at_top ⊓ filter.principal (complex.im ⁻¹' set.Ioo a b)] λ (z : ℂ), real.exp (B * real.exp (c * |z.re|))) (hdg : diff_cont_on_cl ℂ g (complex.im ⁻¹' set.Ioo a b)) (hBg : ∃ (c : ℝ) (H : c < real.pi / (b - a)) (B : ℝ), g =O[filter.comap (has_abs.abs ∘ complex.re) filter.at_top ⊓ filter.principal (complex.im ⁻¹' set.Ioo a b)] λ (z : ℂ), real.exp (B * real.exp (c * |z.re|))) (ha : ∀ (z : ℂ), z.im = a → f z = g z) (hb : ∀ (z : ℂ), z.im = b → f z = g z) : set.eq_on f g (complex.im ⁻¹' set.Icc a b)
{ι : Type u_4} {π : ι → Type u_1} [fintype ι] [Π (i : ι), semi_normed_ring (π i)] : semi_normed_ring (Π (i : ι), π i)
{α : Type u_1} (s : set α) (r : α → α → Prop) : s.pairwise r → pairwise (λ (x y : ↥s), r ↑x ↑y)
{R : Type u} [comm_ring R] (I : ideal R) [hI : I.is_maximal] : field (R ⧸ I)
{R : Type u} {ι : Type v} [comm_ring R] {L : Type w} [lie_ring L] [lie_algebra R L] (I : ι → lie_ideal R L) : lie_algebra R (direct_sum ι (λ (i : ι), ↥(I i)))
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f (⇑σ i) • g i) = finset.univ.sum (λ (i : ι), f i • g i) ↔ antivary (f ∘ ⇑σ) g
{C : Type u} [category_theory.category C] [category_theory.concrete_category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_multiequalizer I] [category_theory.limits.preserves_limit I.multicospan (category_theory.forget C)] : ↥(category_theory.limits.multiequalizer I) ≃ {x // ∀ (i : I.R), ⇑(I.fst i) (x (I.fst_to i)) = ⇑(I.snd i) (x (I.snd_to i))}
{ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), comm_ring (G i)] {f' : Π (i j : ι), i ≤ j → G i →+* G j} [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f' i j h))] [is_directed ι has_le.le] {i : ι} {x : G i} (hix : ⇑(ring.direct_limit.of G (λ (i j : ι) (h : i ≤ j), ⇑(f' i j h)) i) x = 0) : ∃ (j : ι) (hij : i ≤ j), ⇑(f' i j hij) x = 0
(s : simp_lemmas) (to_unfold : list name := list.nil) (e : expr) (cfg : tactic.simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}) (r : name := name.mk_string "eq" name.anonymous) (discharger : tactic unit := tactic.failed) : tactic (expr × expr × name_set)
(α : Type u_1) (E : Type u_2) [normed_group E] {m : measurable_space α} (μ : measure_theory.measure α) [normed_space ℝ E] : ↥(measure_theory.Lp.simple_func E 1 μ) →L[ℝ] E
{n : ℕ} (i : fin2 n) ⦃α : typevec n⦄ ⦃β : typevec n⦄ (f : α.arrow β) : mvqpf.prj i α → mvqpf.prj i β
{α : Type u_1} {σ : Type u_2} [primcodable α] [primcodable σ] {c : α → nat.partrec.code} (hc : computable c) {z : α → σ} (hz : computable z) {s : α → σ} (hs : computable s) {l : α → σ} (hl : computable l) {r : α → σ} (hr : computable r) {pr : α → nat.partrec.code × nat.partrec.code × σ × σ → σ} (hpr : computable₂ pr) {co : α → nat.partrec.code × nat.partrec.code × σ × σ → σ} (hco : computable₂ co) {pc : α → nat.partrec.code × nat.partrec.code × σ × σ → σ} (hpc : computable₂ pc) {rf : α → nat.partrec.code × σ → σ} (hrf : computable₂ rf) : let PR : α → nat.partrec.code → nat.partrec.code → σ → σ → σ := λ (a : α) (cf cg : nat.partrec.code) (hf hg : σ), pr a (cf, cg, hf, hg), CO : α → nat.partrec.code → nat.partrec.code → σ → σ → σ := λ (a : α) (cf cg : nat.partrec.code) (hf hg : σ), co a (cf, cg, hf, hg), PC : α → nat.partrec.code → nat.partrec.code → σ → σ → σ := λ (a : α) (cf cg : nat.partrec.code) (hf hg : σ), pc a (cf, cg, hf, hg), RF : α → nat.partrec.code → σ → σ := λ (a : α) (cf : nat.partrec.code) (hf : σ), rf a (cf, hf), F : α → nat.partrec.code → σ := λ (a : α) (c : nat.partrec.code), c.rec_on (z a) (s a) (l a) (r a) (PR a) (CO a) (PC a) (RF a) in computable (λ (a : α), F a (c a))
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_multiequalizer I] : category_theory.limits.multifork I
{α : Type u_1} {m : measurable_space α} (μ ν : measure_theory.measure α) : α → ennreal
(attr_name src tgt : name) (p : option bool := option.none) : tactic unit
{α : Type u_1} {β : Type u_2} [measurable_space β] {m : measurable_space α} (f : α → β) (μ : measure_theory.measure α . "volume_tac") : Prop
{α : Type u_1} {σ : α → Type u_5} (s : multiset α) (t : Π (a : α), multiset (σ a)) : multiset (Σ (a : α), σ a)
{ιa : Type u_7} {ιb : Type u_8} [decidable_eq ιa] [decidable_eq ιb] [fintype ιa] [fintype ιb] {R' : Type u_9} {Mᵢ : Type u_10} {N₁ : Type u_11} {N₂ : Type u_12} [comm_semiring R'] [add_comm_group N₁] [module R' N₁] [add_comm_group N₂] [module R' N₂] [add_comm_monoid Mᵢ] [module R' Mᵢ] (a : alternating_map R' Mᵢ N₁ ιa) (b : alternating_map R' Mᵢ N₂ ιb) (σ : equiv.perm.mod_sum_congr ιa ιb) : multilinear_map R' (λ (_x : ιa ⊕ ιb), Mᵢ) (tensor_product R' N₁ N₂)
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G ≃g G') : G →g G'
{α : Type u_1} [measurable_space α] [topological_space α] [opens_measurable_space α] {μ : measure_theory.finite_measure α} {fs : ℕ → bounded_continuous_function α nnreal} {c : nnreal} (fs_le_const : ∀ (n : ℕ) (a : α), ⇑(fs n) a ≤ c) {f : bounded_continuous_function α nnreal} (fs_lim : ∀ (a : α), filter.tendsto (λ (n : ℕ), ⇑(fs n) a) filter.at_top (nhds (⇑f a))) : filter.tendsto (λ (n : ℕ), μ.test_against_nn (fs n)) filter.at_top (nhds (μ.test_against_nn f))
{α : Sort u_1} {d : α} (x : α := d) : α
{ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a : ℝ} {c : E} {l l' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {u v : ι → ℝ} [measure_theory.is_locally_finite_measure μ] [interval_integral.FTC_filter a l l'] (hfm : strongly_measurable_at_filter f l' μ) (hf : filter.tendsto f (l' ⊓ μ.ae) (nhds c)) (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) (huv : u ≤ᶠ[lt] v) : (λ (t : ι), ∫ (x : ℝ) in u t..v t, f x ∂μ - (⇑μ (set.Ioc (u t) (v t))).to_real • c) =o[lt] λ (t : ι), (⇑μ (set.Ioc (u t) (v t))).to_real
{x : pgame} : 0.lf x ↔ ∃ (i : x.left_moves), 0 ≤ x.move_left i
{n : ℕ+} {K : Type u_1} [field K] {L : Type u_2} [field L] {μ : L} (hμ : is_primitive_root μ ↑n) [algebra K L] [is_cyclotomic_extension {n} K L] (h : irreducible (polynomial.cyclotomic ↑n K)) [ne_zero ↑↑n] : L ≃ₐ[K] L
{G : Type u_1} [hG : group G] [hf : fintype G] (e : (Π (p : ↥((fintype.card G).factorization.support)) (P : sylow ↑p G), ↥↑P) ≃* G) : group.is_nilpotent G
{p : ℕ} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] [char_p R p] (x y : witt_vector p R) (i j : ℕ) : (⇑witt_vector.verschiebung^[i] x * ⇑witt_vector.verschiebung^[j] y).coeff (i + j) = x.coeff 0 ^ p ^ j * y.coeff 0 ^ p ^ i
{V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x₁ x₂ y z : V} (hx₁yne : x₁ ≠ y) (hx₁zne : x₁ ≠ z) (hx₂yne : x₂ ≠ y) (hx₂zne : x₂ ≠ z) {r : ℝ} (hx₁ : ∥x₁∥ = r) (hx₂ : ∥x₂∥ = r) (hy : ∥y∥ = r) (hz : ∥z∥ = r) : 2 • o.oangle (y - x₁) (z - x₁) = 2 • o.oangle (y - x₂) (z - x₂)
{elab : bool := bool.tt} : expr elab → option (name × name × binder_info × expr elab)
{α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] (f : α → β) (hf : function.injective f) (hfm : measurable f) (hfi : ∀ (s : set α), measurable_set s → measurable_set (f '' s)) : α ≃ᵐ ↥(set.range f)
{V : Type u_1} [inner_product_space ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : ∥x + y∥ = ∥x∥ + ∥y∥ ↔ inner_product_geometry.angle x y = 0
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {H : Type u_4} [normed_group H] [normed_space 𝕜 H] {F : H → α → E} {F' : α → (H →L[𝕜] E)} {x₀ : H} {bound : α → ℝ} {ε : ℝ} (ε_pos : 0 < ε) (hF_meas : ∀ (x : H), x ∈ metric.ball x₀ ε → measure_theory.ae_strongly_measurable (F x) μ) (hF_int : measure_theory.integrable (F x₀) μ) (hF'_meas : measure_theory.ae_strongly_measurable F' μ) (h_lipsch : ∀ᵐ (a : α) ∂μ, ∀ (x : H), x ∈ metric.ball x₀ ε → ∥F x a - F x₀ a∥ ≤ bound a * ∥x - x₀∥) (bound_integrable : measure_theory.integrable bound μ) (h_diff : ∀ᵐ (a : α) ∂μ, has_fderiv_at (λ (x : H), F x a) (F' a) x₀) : measure_theory.integrable F' μ ∧ has_fderiv_at (λ (x : H), ∫ (a : α), F x a ∂μ) (∫ (a : α), F' a ∂μ) x₀
{R₁ : Type u_3} {A : Type u_5} {B : Type u_6} [comm_semiring R₁] [comm_ring A] [comm_ring B] [algebra R₁ A] [algebra R₁ B] {I : ideal A} (J : ideal B) (f : A →ₐ[R₁] B) (hIJ : I ≤ ideal.comap ↑f J) : A ⧸ I →ₐ[R₁] B ⧸ J
{α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) [measure_theory.sigma_finite (μ.trim hm)] {f g : α → F'} (hf : measure_theory.integrable f μ) (hg_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on g s μ) (hg_eq : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, g x ∂μ = ∫ (x : α) in s, f x ∂μ) (hgm : measure_theory.ae_strongly_measurable' m g μ) : g =ᵐ[μ] measure_theory.condexp m μ f
{α : Type u_1} {E : Type u_4} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} (hp_pos : p ≠ 0) (hp_ne_top : p ≠ ⊤) {P : ↥(measure_theory.Lp.simple_func E p μ) → Prop} (h_ind : ∀ (c : E) {s : set α} (hs : measurable_set s) (hμs : ⇑μ s < ⊤), P (measure_theory.Lp.simple_func.indicator_const p hs _ c)) (h_add : ∀ ⦃f g : measure_theory.simple_func α E⦄ (hf : measure_theory.mem_ℒp ⇑f p μ) (hg : measure_theory.mem_ℒp ⇑g p μ), disjoint (function.support ⇑f) (function.support ⇑g) → P (measure_theory.Lp.simple_func.to_Lp f hf) → P (measure_theory.Lp.simple_func.to_Lp g hg) → P (measure_theory.Lp.simple_func.to_Lp f hf + measure_theory.Lp.simple_func.to_Lp g hg)) (f : ↥(measure_theory.Lp.simple_func E p μ)) : P f
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] (M : turing.TM0.machine Γ Λ) : turing.TM0.cfg Γ Λ → turing.TM1.cfg Γ turing.TM0to1.Λ' unit
{σ : Type u} {m : Type u → Type v} [monad m] [monad_state σ m] (st : σ) : m punit
{α : Type u_1} {E : Type u_2} [normed_group E] {m : measurable_space α} {μ : measure_theory.measure α} [normed_space ℝ E] [complete_space E] : ↥(measure_theory.Lp E 1 μ) →L[ℝ] E
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] [topological_space α] [borel_space α] [second_countable_topology_either α E] [measure_theory.is_finite_measure μ] (f : bounded_continuous_function α E) : ∥⟨continuous_map.to_ae_eq_fun μ f.to_continuous_map, _⟩∥ ≤ ↑(measure_theory.measure_univ_nnreal μ) ^ (p.to_real)⁻¹ * ∥f∥
{E : Type u_1} [normed_group E] [normed_space ℂ E] [complete_space E] {f : ℂ → E} {c : ℂ} {R C : ℝ} (hR : 0 < R) (hc : continuous_on f (metric.sphere c R)) (hf : ∀ (z : ℂ), z ∈ metric.sphere c R → ∥f z∥ ≤ C) (hlt : ∃ (z : ℂ) (H : z ∈ metric.sphere c R), ∥f z∥ < C) : ∥∮ (z : ℂ) in C(c, R), f z∥ < 2 * real.pi * R * C
{α : Type u} [pseudo_metric_space α] (x : α) (ε : ℝ) : set α
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G →g G') (d : G.dart) : G'.dart
(t : tactic unit := tactic.skip) : tactic unit
(R : Type u) (σ : Type u_1) [comm_semiring R] : multiplicative (σ →₀ ℕ) →* mv_polynomial σ R
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {s : set M} {n : with_top ℕ} : cont_mdiff_on I I' n f s ↔ continuous_on f s ∧ ∀ (x : M) (y : M'), cont_diff_on 𝕜 n (⇑(ext_chart_at I' y) ∘ f ∘ ⇑((ext_chart_at I x).symm)) ((ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' (s ∩ f ⁻¹' (ext_chart_at I' y).source))
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : cont_mdiff_map I I' M M' ⊤) (x : M) : point_derivation I x →ₗ[𝕜] point_derivation I' (⇑f x)
{V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 1)) (i : fin (n + 2)) : vector_span ℝ (s.points '' ↑(finset.univ.erase i)) ≤ ((s.altitude i).direction)ᗮ
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (G : C ⥤ D) {W X Y : C} (f : W ⟶ X) (g : W ⟶ Y) [category_theory.limits.preserves_colimit (category_theory.limits.span f g) G] [category_theory.limits.has_pushout f g] : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (G.map category_theory.limits.pushout.inl) (G.map category_theory.limits.pushout.inr) _)
{P : Type u_1} [has_le P] (I : order.ideal P) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {W X Y Z : C} [category_theory.limits.has_binary_biproduct W X] [category_theory.limits.has_binary_biproduct Y Z] (f : W ≅ Y) (g : X ≅ Z) : W ⊞ X ≅ Y ⊞ Z
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] {H' : Type u_5} [topological_space H'] {E' : Type u_6} [normed_group E'] [normed_space 𝕜 E'] (I : model_with_corners 𝕜 E H) (I' : model_with_corners 𝕜 E' H') (G : Type u_8) [topological_space G] [charted_space H G] [monoid G] [has_smooth_mul I G] (G' : Type u_9) [topological_space G'] [charted_space H' G'] [monoid G'] [has_smooth_mul I' G'] : Type (max u_8 u_9)
{R : Type u} [comm_ring R] (I : ideal R) {ι : Type u_1} [fintype ι] {ι' : Type w} (x : ι → R) (hi : ∀ (i : ι), x i ∈ I) (f : (ι → R) →ₗ[R] ι' → R) (i : ι') : ⇑f x i ∈ I
{R : Type u} [ring R] {ι : Type v} [preorder ι] (G : ι → Type v) [Π (i : ι), add_comm_group (G i)] [Π (i : ι), module R (G i)] (f : Π (i j : ι), i ≤ j → (G i →ₗ[R] G j)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] [decidable_eq ι] [nonempty ι] [is_directed ι has_le.le] : category_theory.limits.is_colimit (Module.direct_limit_cocone G f)
{α : Type u} [linear_ordered_ring α] (a : α) : |a| = a ∧ 0 ≤ a ∨ |a| = -a ∧ a < 0
{M : Type u} [mul_one_class M] : reflexive (λ (a b : M), ∃ (c : M), semiconj_by c a b)
{A : Type u_1} [normed_ring A] [normed_algebra ℂ A] [complete_space A] [star_ring A] [cstar_ring A] [star_module ℂ A] [nontrivial A] {a : A} (ha : a ∈ self_adjoint A) : spectrum ℂ a = coe ∘ complex.re '' spectrum ℂ a
{M : Type u_1} [has_mul M] (S : set (con M)) : has_Sup.Sup S = con_gen (λ (x y : M), ∃ (c : con M), c ∈ S ∧ ⇑c x y)
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} [complete_space F] (h : box_integral.integrable I l f vol) {π₁ π₂ : box_integral.prepartition I} (hU : π₁.Union = π₂.Union) : π₁.boxes.sum (λ (J : box_integral.box ι), box_integral.integral J l f vol) = π₂.boxes.sum (λ (J : box_integral.box ι), box_integral.integral J l f vol)
(I : name) : tactic tactic.eliminate.inductive_info
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i * g i) < s.sum (λ (i : ι), f (⇑σ i) * g i) ↔ ¬antivary_on (f ∘ ⇑σ) g ↑s
{η : Type u_5} {f : η → Type u_6} [Π (i : η), add_zero_class (f i)] (I : set η) (s : Π (i : η), add_submonoid (f i)) : add_submonoid (Π (i : η), f i)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {H : Type u_4} [topological_space H] {H' : Type u_5} [topological_space H'] {I : model_with_corners 𝕜 E H} {I' : model_with_corners 𝕜 E' H'} {M : Type u_6} [topological_space M] [charted_space H M] {M' : Type u_7} [topological_space M'] [charted_space H' M'] {E'' : Type u_8} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_9} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_10} [topological_space M''] [charted_space H'' M''] {n : with_top ℕ} (f : cont_mdiff_map I' I'' M' M'' n) (g : cont_mdiff_map I I' M M' n) : cont_mdiff_map I I'' M M'' n
{α : Type u_1} [semi_normed_ring α] [norm_one_class α] (a : α) (n : ℕ) : ∥a ^ n∥ ≤ ∥a∥ ^ n
{I : Type w₀} (C : I → Type u₁) [Π (i : I), category_theory.category (C i)] {J : Type w₁} {K : Type w₂} (f : K → J) (g : J → I) : category_theory.pi.comap C g ⋙ category_theory.pi.comap (C ∘ g) f ≅ category_theory.pi.comap C (g ∘ f)
{σ : Type u_1} {τ : Type u_2} {R : Type u_4} [comm_semiring R] (f : mv_polynomial σ R →ₐ[R] mv_polynomial τ R) : (τ → R) → σ → R
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ℤ] [category_theory.preadditive C] [∀ (n : ℤ), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T ∈ dist_triang C) : T.mor₂ ≫ T.mor₃ = 0
{I : Type w₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {X Y Z : Σ (i : I), C i} : category_theory.sigma.sigma_hom X Y → category_theory.sigma.sigma_hom Y Z → category_theory.sigma.sigma_hom X Z
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ⥤ C} {F : C ⥤ D} [category_theory.reflects_isomorphisms F] (h : Π (c : category_theory.limits.cocone (K ⋙ F)) (t : category_theory.limits.is_colimit c), category_theory.lifts_to_colimit K F c t) : category_theory.creates_colimit K F
{ι : Type u_1} {𝕜 : Type u_2} {𝔸 : Type u_3} [normed_field 𝕜] [normed_group 𝔸] [normed_space 𝕜 𝔸] {l : filter ι} {ε : ι → 𝕜} {f : ι → 𝔸} (hε : filter.tendsto ε l (nhds 0)) (hf : filter.is_bounded_under has_le.le l (has_norm.norm ∘ f)) : filter.tendsto (ε • f) l (nhds 0)
{𝕜 : Type u_1} [is_R_or_C 𝕜] {F : Type u_2} [semi_normed_group F] [normed_space 𝕜 F] [normed_space ℝ F] [is_scalar_tower ℝ 𝕜 F] (fr : F →L[ℝ] ℝ) (x : F) : ∥⇑(fr.to_linear_map.extend_to_𝕜') x∥ ≤ ∥fr∥ * ∥x∥
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (W : submodule R M) : bilin_form R ↥W
{C : Type (max v u)} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] {X : C} {K : Type (max v u)} [category_theory.small_category K] [category_theory.limits.has_limits_of_shape K D] {W : (J.cover X)ᵒᵖ} (F : K ⥤ Cᵒᵖ ⥤ D) (E : category_theory.limits.cone (F ⋙ J.diagram_functor D X ⋙ (category_theory.evaluation (J.cover X)ᵒᵖ D).obj W)) : E.X ⟶ (J.diagram (category_theory.limits.limit F) X).obj W
{a b : ℝ} {f f' : ℝ → ℝ} (hab : a ≤ b) (hf : ∀ (x : ℝ), x ∈ set.Icc a b → has_deriv_within_at f (f' x) (set.Icc a b) x) {m : ℝ} (hma : m < f' a) (hmb : f' b < m) : m ∈ f' '' set.Icc a b
{ι : Type uι} (R : Type uR) (A : ι → Type uA) {B : Type uB} [decidable_eq ι] [comm_semiring R] [Π (i : ι), add_comm_monoid (A i)] [Π (i : ι), module R (A i)] [add_monoid ι] [direct_sum.gsemiring A] [semiring B] [direct_sum.galgebra R A] [algebra R B] ⦃f g : direct_sum ι (λ (i : ι), A i) →ₐ[R] B⦄ (h : ∀ (i : ι), f.to_linear_map.comp (direct_sum.lof R ι A i) = g.to_linear_map.comp (direct_sum.lof R ι A i)) : f = g
{R : Type u_1} [comm_ring R] {f : polynomial R} {I : prime_spectrum (polynomial R)} (H : I ∈ (prime_spectrum.zero_locus {f})ᶜ) : ⇑(prime_spectrum.comap polynomial.C) I ∈ algebraic_geometry.polynomial.image_of_Df f
{β : Type u} {α : Type v} [comm_monoid β] {σ : α → Type u_1} (s : finset α) (t : Π (a : α), finset (σ a)) (f : sigma σ → β) : (s.sigma t).prod (λ (x : Σ (i : α), σ i), f x) = s.prod (λ (a : α), (t a).prod (λ (s : σ a), f ⟨a, s⟩))
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} [topological_space α] [topological_space.second_countable_topology α] (s : set α) (hs : ∀ (x : α), x ∈ s → (∃ (u : set α) (H : u ∈ nhds_within x s), ⇑μ u = 0)) : ⇑μ s = 0
(cs : list name) (e : expr) (cfg : tactic.delta_config := {max_steps := simp.default_max_steps, visit_instances := bool.tt}) : tactic expr
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] {s t : set α} (hs : measurable_set s) (ht : measurable_set t) (hμs : ⇑μ s ≠ ⊤) (hμt : ⇑μ t ≠ ⊤) (hst : s ∩ t = ∅) (c : E) : measure_theory.indicator_const_Lp p _ _ c = measure_theory.indicator_const_Lp p hs hμs c + measure_theory.indicator_const_Lp p ht hμt c
{R : Type u_1} {S : Type u_6} {M : Type u_9} {M₃ : Type u_12} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid M₃] [module R M] [module S M₃] {σ : R →+* S} : has_coe_to_fun (M →ₛₗ[σ] M₃) (λ (_x : M →ₛₗ[σ] M₃), M → M₃)
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {ι : Type u_2} [linear_order ι] [topological_space ι] [order_topology ι] [densely_ordered ι] [topological_space.first_countable_topology ι] {s : ι → set α} {a : ι} (hs : ∀ (r : ι), r > a → measurable_set (s r)) (hm : ∀ (i j : ι), a < i → i ≤ j → s i ⊆ s j) (hf : ∃ (r : ι) (H : r > a), ⇑μ (s r) ≠ ⊤) : filter.tendsto (⇑μ ∘ s) (nhds_within a (set.Ioi a)) (nhds (⇑μ (⋂ (r : ι) (H : r > a), s r)))
{ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a : ℝ} {c : E} {l l' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {u v : ι → ℝ} [measure_theory.is_locally_finite_measure μ] [interval_integral.FTC_filter a l l'] (hfm : strongly_measurable_at_filter f l' μ) (hf : filter.tendsto f (l' ⊓ μ.ae) (nhds c)) (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : (λ (t : ι), ∫ (x : ℝ) in u t..v t, f x ∂μ - ∫ (x : ℝ) in u t..v t, c ∂μ) =o[lt] λ (t : ι), ∫ (x : ℝ) in u t..v t, 1 ∂μ
{α : Type u} {β : Type v} [pseudo_emetric_space α] {ι : Type u_1} {F : ι → β → α} {f : β → α} {p : filter ι} : tendsto_uniformly F f p ↔ ∀ (ε : ennreal), ε > 0 → (∀ᶠ (n : ι) in p, ∀ (x : β), has_edist.edist (f x) (F n x) < ε)
{α : Type u_1} [measurable_space α] [topological_space α] [opens_measurable_space α] {μ : measure_theory.measure α} (s : μ.finite_spanning_sets_in {U : set α | is_open U ∧ (μ.restrict U).outer_regular}) : μ.outer_regular
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [fintype J] {K : Type v} [fintype K] {f : J → C} {g : K → C} [category_theory.limits.has_finite_biproducts C] : (⨁ f ⟶ ⨁ g) ≃ Π (j : J) (k : K), f j ⟶ g k
(V : Type u_1) (W : Type u_2) [semi_normed_group V] [semi_normed_group W] : Type (max u_1 u_2)
{V W : SemiNormedGroup} (f g : V ⟶ W) : category_theory.limits.fork f g
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [measurable_space α] [measurable_space β] {f : ι → α → β} {μ : measure_theory.measure α} (hf : ∀ (i : ι), ae_measurable (f i) μ) (p : α → (ι → β) → Prop) : set α
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : f =o[l] g' → (f =o[l] λ (x : α), ∥g' x∥)
{α : Type u_1} {γ : Type u_3} [topological_space α] [measurable_space α] [opens_measurable_space α] [topological_space γ] [measurable_space γ] [borel_space γ] {f : α → γ} (h : continuous f) {μ : measure_theory.measure α} : ae_measurable f μ
(e : expr) (n : ℕ) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr × expr)
{C : Type u₁} [category_theory.category C] {A : Type u₂} [category_theory.category A] {B : Type u₃} [category_theory.category B] (J : category_theory.grothendieck_topology C) (F : A ⥤ B) [Π (X : C) (S : J.cover X) (P : Cᵒᵖ ⥤ A), category_theory.limits.preserves_limit (S.index P).multicospan F] : category_theory.Sheaf J A ⥤ category_theory.Sheaf J B
{α : Sort u_1} {β : Sort u_2} (φ : α → β → Sort u_3) : (Π (a : α) (b : β), φ a b) ≃ Π (b : β) (a : α), φ a b
{elab : bool} : expr elab → option (name × expr elab)
(ε : ℝ) (l : ℕ) : ℕ
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {f : α → ennreal} (h_mf : measurable f) {g : α → ennreal} : measurable g → ∫⁻ (a : α), g a ∂μ.with_density f = ∫⁻ (a : α), (f * g) a ∂μ
{α : Type u} {C : list α → Sort u_1} (H0 : C list.nil) (H1 : Π (a : α), C [a]) (Hn : Π (a : α) (l : list α) (b : α), C l → C (a :: (l ++ [b]))) (l : list α) : C l
{α : Type u_1} {γ : Type u_3} [measurable_space α] {μ : measure_theory.measure α} [topological_space γ] [monoid γ] [has_continuous_mul γ] : (α →ₘ[μ] γ) →* μ.ae.germ γ
{α : Type u_1} {G : Type u_8} [normed_group G] [normed_space ℝ G] {m m0 : measurable_space α} (hm : m ≤ m0) (μ : measure_theory.measure α) (s : set α) [measure_theory.sigma_finite (μ.trim hm)] (x : G) : ↥(measure_theory.Lp G 1 μ)
{α : Type u_1} {𝕜 : Type u_4} [is_R_or_C 𝕜] [measurable_space α] {μ : measure_theory.measure α} {s : set α} (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) (f : ↥(measure_theory.Lp 𝕜 2 μ)) : has_inner.inner (measure_theory.indicator_const_Lp 2 hs hμs 1) f = ∫ (x : α) in s, ⇑f x ∂μ
(md : tactic.transparency := tactic.transparency.reducible) : list (tactic string)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] (I : model_with_corners 𝕜 E H) {G : Type u_4} [has_add G] [topological_space G] [charted_space H G] [has_smooth_add I G] : has_continuous_add G
{P : Type u_2} [has_le P] (I : set P) : Prop
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {X : C} {S : J.cover X} {T : Π (I : S.arrow), J.cover I.Y} (I : (S.bind T).arrow) : S.arrow
{α : Type u_1} {E : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] {m : measurable_space α} {μ : measure_theory.measure α} {ι : Type u_3} {f : α → E} (hf : measure_theory.integrable f μ) {l : filter ι} {s : ι → set α} (hs : filter.tendsto (⇑μ ∘ s) l (nhds 0)) : filter.tendsto (λ (i : ι), ∫ (x : α) in s i, f x ∂μ) l (nhds 0)
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} (t : category_theory.limits.pushout_cocone f g) {W : C} {k l : t.X ⟶ W} (h₀ : t.inl ≫ k = t.inl ≫ l) (h₁ : t.inr ≫ k = t.inr ≫ l) (j : category_theory.limits.walking_span) : t.ι.app j ≫ k = t.ι.app j ≫ l
{R : Type u_1} {V : Type u_2} {W : Type u_3} {P : Type u_4} {Q : Type u_5} [ring R] [add_comm_group V] [module R V] [topological_space P] [add_torsor V P] [add_comm_group W] [module R W] [topological_space Q] [add_torsor W Q] : has_coe_to_fun (P →A[R] Q) (λ (_x : P →A[R] Q), P → Q)
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} {σ : Type u_3} : turing.TM1.stmt Γ Λ σ → σ → turing.tape Γ → turing.TM1.cfg Γ Λ σ
(e : expr) (check : bool := bool.tt) : tactic unit
{A : Type u} [comm_ring A] [is_domain A] [is_noetherian_ring A] (h_fA : ¬is_field A) {I : ideal A} (h_nzI : I ≠ ⊥) : ∃ (Z : multiset (prime_spectrum A)), (multiset.map coe Z).prod ≤ I ∧ (multiset.map coe Z).prod ≠ ⊥
(X : Topᵒᵖ) {R S : TopCommRing} (φ : R ⟶ S) : Top.continuous_functions X R ⟶ Top.continuous_functions X S
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G ↪g G') (v : V) : ↥(G.neighbor_set v) ↪ ↥(G'.neighbor_set (⇑f v))
{β : Type v} {π : β → Type u_1} [fintype β] [Π (b : β), pseudo_metric_space (π b)] (x : Π (b : β), π b) {r : ℝ} (hr : 0 < r) : metric.ball x r = set.univ.pi (λ (b : β), metric.ball (x b) r)
{F : Type u_3} [inner_product_space ℝ F] {x y : F} (h : has_inner.inner x y = 0) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) (f : α → set (set α)) (s : set α) : Prop
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_monoid M] {S : set (add_monoid_algebra R M)} (hS : algebra.adjoin R S = ⊤) : algebra.adjoin R (add_monoid_algebra.of' R M '' ⋃ (f : add_monoid_algebra R M) (H : f ∈ S), ↑(f.support)) = ⊤
{R : Type u} {S : Type v} [ring R] [ring S] (I : ideal (R × S)) : I.is_prime ↔ (∃ (p : ideal R), p.is_prime ∧ I = p.prod ⊤) ∨ ∃ (p : ideal S), p.is_prime ∧ I = ⊤.prod p
{C : Type u} [category_theory.category C] {P Q : C} {t : category_theory.limits.binary_fan P Q} (I : category_theory.limits.is_limit t) : category_theory.limits.is_limit t.swap
{G : Type u_2} [group G] [topological_space G] [measurable_space G] (μ : measure_theory.measure G) : Prop
{α : Type u_1} [measurable_space α] {s : measure_theory.signed_measure α} {u v w : set α} (hu : measurable_set u) (hv : measurable_set v) (hw : measurable_set w) (hsu : 0.restrict u ≤ measure_theory.vector_measure.restrict s u) (hw₁ : ⇑s w = 0) (hw₂ : w ⊆ u) (hwt : v ⊆ w) : ⇑s v = 0
{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} : uniform_embedding f → ((∀ (ε : ennreal), ε > 0 → (∃ (δ : ennreal) (H : δ > 0), ∀ {a b : α}, has_edist.edist a b < δ → has_edist.edist (f a) (f b) < ε)) ∧ ∀ (δ : ennreal), δ > 0 → (∃ (ε : ennreal) (H : ε > 0), ∀ {a b : α}, has_edist.edist (f a) (f b) < ε → has_edist.edist a b < δ))
{C : Type u} [category_theory.category C] [category_theory.abelian C] (X : C) (I : category_theory.InjectiveResolution X) : homotopy (category_theory.InjectiveResolution.desc (𝟙 X) I I) (𝟙 I.cocomplex)
{M : Type u_1} [comm_monoid M] {ζ : M} {n a b : ℕ} (hn : 0 < n) (h : is_primitive_root ζ n) (hprod : n = a * b) : is_primitive_root (ζ ^ a) b
{𝕜 : Type u} [nondiscrete_normed_field 𝕜] {ι : Type v} [fintype ι] {E : ι → Type w} [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] {H : ι → Type u'} [Π (i : ι), topological_space (H i)] (I : Π (i : ι), model_with_corners 𝕜 (E i) (H i)) : model_with_corners 𝕜 (Π (i : ι), E i) (model_pi H)
{R : Type u_5} [comm_ring R] [is_domain R] {ζ : R} {n : ℕ} (h : is_primitive_root ζ n) : polynomial.nth_roots_finset n R = n.divisors.bUnion (λ (i : ℕ), primitive_roots i R)
{η : Type u_5} {f : η → Type u_6} [Π (i : η), mul_one_class (f i)] (I : set η) (s : Π (i : η), submonoid (f i)) : submonoid (Π (i : η), f i)
{L : first_order.language} {M : Type w} [L.Structure M] {α : Type u'} (φ : L.formula α) (v : α → M) : Prop
{α : Type u_1} (E : Type u_4) [measurable_space α] [normed_group E] (p : ennreal) (μ : measure_theory.measure α) : add_subgroup ↥(measure_theory.Lp E p μ)
{α : Type u} [pseudo_metric_space α] : uniformity (uniform_space.completion α) = ⨅ (ε : {ε // 0 < ε}), filter.principal {p : uniform_space.completion α × uniform_space.completion α | has_dist.dist p.fst p.snd < ε.val}
{α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds a) (hfs : f '' s ∈ nhds (f a)) : continuous_at f a
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) : ∀ᵐ (x : α) ∂μ, ∃ (c : ennreal), filter.tendsto (λ (a : set α), ⇑ρ a / ⇑μ a) (v.filter_at x) (nhds c)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_4} [normed_group F] [normed_space 𝕜 F] {H : Type u_5} [topological_space H] (I : model_with_corners 𝕜 E H) (M : Type u_8) [topological_space M] [charted_space H M] (e : diffeomorph (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 F) E F ⊤) : diffeomorph I (I.trans_diffeomorph e) M M ⊤
{α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : monotone_on f s) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : f '' s ∈ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i • g i) < finset.univ.sum (λ (i : ι), f (⇑σ i) • g i) ↔ ¬antivary (f ∘ ⇑σ) g
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] (s : set α) (t : set β) : ⇑(μ.prod ν) (s ×ˢ t) = ⇑μ s * ⇑ν t
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {ι : Type u_5} (S : ι → set α) (φ : Π (i : ι), C(↥(S i), β)) (hφ : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), ⇑(φ i) ⟨x, hxi⟩ = ⇑(φ j) ⟨x, hxj⟩) (hS : ∀ (x : α), ∃ (i : ι), S i ∈ nhds x) : C(α, β)
{J : Type u₁} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ⥤ C) [category_theory.limits.has_limit F] (W : C) : ulift (W ⟶ category_theory.limits.limit F) ≅ F.cones.obj (opposite.op W)
{ι : Type u_1} {α : ι → Type u_3} [fintype ι] [Π (i : ι), measurable_space (α i)] {μ : Π (i : ι), measure_theory.measure (α i)} [∀ (i : ι), measure_theory.sigma_finite (μ i)] {μ' : measure_theory.measure (Π (i : ι), α i)} (h : ∀ (s : Π (i : ι), set (α i)), (∀ (i : ι), measurable_set (s i)) → ⇑μ' (set.univ.pi s) = finset.univ.prod (λ (i : ι), ⇑(μ i) (s i))) : measure_theory.measure.pi μ = μ'
{σ : Type u_1} {R : Type u_4} [comm_semiring R] (p₁ p₂ : mv_polynomial σ R) : ∃ (s : finset σ) (q₁ q₂ : mv_polynomial ↥s R), p₁ = ⇑(mv_polynomial.rename coe) q₁ ∧ p₂ = ⇑(mv_polynomial.rename coe) q₂
{F : Type u_3} [inner_product_space ℝ F] (x y : F) : has_inner.inner x y ≤ ∥x∥ * ∥y∥
(G : Type u_1) {α : Type u_3} {m : measurable_space α} [group G] [mul_action G α] [measurable_space G] [has_measurable_smul G α] (μ : measure_theory.measure α) : [measure_theory.smul_invariant_measure G α μ, ∀ (c : G) (s : set α), measurable_set s → ⇑μ (has_scalar.smul c ⁻¹' s) = ⇑μ s, ∀ (c : G) (s : set α), measurable_set s → ⇑μ (c • s) = ⇑μ s, ∀ (c : G) (s : set α), ⇑μ (has_scalar.smul c ⁻¹' s) = ⇑μ s, ∀ (c : G) (s : set α), ⇑μ (c • s) = ⇑μ s, ∀ (c : G), measure_theory.measure.map (has_scalar.smul c) μ = μ, ∀ (c : G), measure_theory.measure_preserving (has_scalar.smul c) μ μ].tfae
{α : Type u_1} {s : finset α} {p : Π (t : finset α), t ⊆ s → Prop} [Π (t : finset α) (h : t ⊆ s), decidable (p t h)] : decidable (∀ (t : finset α) (h : t ⊆ s), p t h)
{α : Type u_1} [topological_space α] {m : measurable_space α} [topological_space.second_countable_topology α] [linear_order α] [order_topology α] [borel_space α] (μ ν : measure_theory.measure α) [measure_theory.is_finite_measure μ] (hμν : ⇑μ set.univ = ⇑ν set.univ) (h : ∀ ⦃a b : α⦄, a < b → ⇑μ (set.Ioc a b) = ⇑ν (set.Ioc a b)) : μ = ν
{α : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {m : measurable_space α} (μ : measure_theory.measure α) [complete_space F] (T : set α → (E →L[ℝ] F)) {C : ℝ} (hT : measure_theory.dominated_fin_meas_additive μ T C) (f : α → E) : F
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i • g i) ≤ finset.univ.sum (λ (i : ι), f i • g (⇑σ i))
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} (f g : α → ennreal) : ∫⁻ (a : α), f a ∂μ + ∫⁻ (a : α), g a ∂μ ≤ ∫⁻ (a : α), f a + g a ∂μ
{elab : bool := bool.tt} : expr elab → option ℕ
(h e : expr) (cfg : tactic.rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}) : tactic (expr × expr × list expr)
{R : Type u_1} [semiring R] {M : Type u_2} [topological_space M] [add_comm_monoid M] [module R M] {ι : Type u_4} {φ : ι → Type u_5} [Π (i : ι), topological_space (φ i)] [Π (i : ι), add_comm_monoid (φ i)] [Π (i : ι), module R (φ i)] (f : Π (i : ι), M →L[R] φ i) : M →L[R] Π (i : ι), φ i
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [nonempty J] {s : category_theory.limits.cotrident f} (hs : category_theory.limits.is_colimit s) {W : C} (k : Y ⟶ W) (h : ∀ (j₁ j₂ : J), f j₁ ≫ k = f j₂ ≫ k) : {l // s.π ≫ l = k}
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g (⇑σ i)) < s.sum (λ (i : ι), f i • g i) ↔ ¬monovary_on f (g ∘ ⇑σ) ↑s
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] (μ : measure_theory.measure G) [μ.is_haar_measure] [locally_compact_space G] (E : set G) (hE : measurable_set E) (hEpos : 0 < ⇑μ E) : E / E ∈ nhds 1
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : multilinear_map 𝕜 E G) (C : ℝ) (H : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) : continuous_multilinear_map 𝕜 E G
{α : Type u_1} {E : Type u_4} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} (f : measure_theory.simple_func α E) (hf : measure_theory.mem_ℒp ⇑f p μ) : ↥(measure_theory.Lp.simple_func E p μ)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} {r : ennreal} {r' : nnreal} (hf : has_fpower_series_on_ball f p x r) (h : ↑r' < r) : ∃ (a : ℝ) (H : a ∈ set.Ioo 0 1) (C : ℝ) (H : C > 0), ∀ (y : E), y ∈ metric.ball 0 ↑r' → ∀ (n : ℕ), ∥f (x + y) - p.partial_sum n y∥ ≤ C * (a * (∥y∥ / ↑r')) ^ n
{α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} (h : ν ≤ μ) {C : set (set α)} (S : μ.finite_spanning_sets_in C) : ν.finite_spanning_sets_in C
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {p : ℕ → α → Prop} (hp : ∑' (i : ℕ), ⇑μ {x : α | p i x} ≠ ⊤) : ⇑μ {x : α | ∃ᶠ (n : ℕ) in filter.at_top, p n x} = 0
{ι : Type u_1} {α : Type u_2} {E : Type u_3} [semi_normed_group E] {f : ι → E} (hf : summable (λ (a : ι), ∥f a∥)) {s : α → finset ι} {p : filter α} [p.ne_bot] (hs : filter.tendsto s p filter.at_top) {a : E} (ha : filter.tendsto (λ (b : α), (s b).sum (λ (i : ι), f i)) p (nhds a)) : has_sum f a
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} (j : ι) : (Π (i j : ι), C.X i ⟶ D.X j) →+ (C.X j ⟶ D.X j)
{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] {L : Type u_3} {W : Type u_4} [field L] [add_comm_group W] [module L W] {σ : K →+* L} {τ : L →+* K} [ring_hom_inv_pair σ τ] (f : V →ₛₗ[σ] W) (hf : function.injective ⇑f) : function.injective (projectivization.map f hf)
{β : Type v} {π : β → Type u_1} [fintype β] [Π (b : β), metric_space (π b)] : metric_space (Π (b : β), π b)
{Fq : Type u_1} [fintype Fq] [field Fq] {b : polynomial Fq} (hb : b ≠ 0) {ε : ℝ} (hε : 0 < ε) (A : fin (fintype.card Fq ^ ⌈-real.log ε / real.log ↑(fintype.card Fq)⌉₊).succ → polynomial Fq) : ∃ (i₀ i₁ : fin (fintype.card Fq ^ ⌈-real.log ε / real.log ↑(fintype.card Fq)⌉₊).succ), i₀ ≠ i₁ ∧ ↑(⇑polynomial.card_pow_degree (A i₁ % b - A i₀ % b)) < ⇑polynomial.card_pow_degree b • ε
{α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} (C : set (set α)) (B : ℕ → set α) (hA : m0 = measurable_space.generate_from C) (hC : is_pi_system C) (h1B : (⋃ (i : ℕ), B i) = set.univ) (h2B : ∀ (i : ℕ), B i ∈ C) (hμB : ∀ (i : ℕ), ⇑μ (B i) ≠ ⊤) (h_eq : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s) : μ = ν
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] {R' : Type u_3} {S' : Type u_4} [comm_ring R'] [comm_ring S'] {f : R →+* S} {f' : R' →+* S'} {g : R →+* R'} {g' : S →+* S'} (hfg : f'.comp g = g'.comp f) (I : ideal S') : (I.quotient_map g' le_rfl).comp ((ideal.comap g' I).quotient_map f le_rfl) = (I.quotient_map f' le_rfl).comp ((ideal.comap f' I).quotient_map g _)
{σ : Type u_1} {α : σ → Type u_2} [Π (s : σ), linear_order (α s)] [∀ (s : σ), is_well_order (α s) has_lt.lt] [fintype σ] (S : set (Π (s : σ), α s)) : S.is_pwo
{α : Type u} [pseudo_metric_space α] {s : set α} [discrete_topology ↥s] {x : α} (hx : x ∈ s) : ∃ (ε : ℝ) (H : ε > 0), metric.closed_ball x ε ∩ s = {x}
{α : Type u_1} {s : set (setoid α)} : has_Sup.Sup s = eqv_gen.setoid (has_Sup.Sup (setoid.rel '' s))
{α : Type u} [pseudo_emetric_space α] {f : filter α} : cauchy f ↔ f ≠ ⊥ ∧ ∀ (ε : ennreal), ε > 0 → (∃ (t : set α) (H : t ∈ f), ∀ (x : α), x ∈ t → ∀ (y : α), y ∈ t → has_edist.edist x y < ε)
{G : Type u_1} [measurable_space G] [add_group G] [has_measurable_add G] (μ : measure_theory.measure G) [μ.is_add_left_invariant] (g : G) (A : set G) : ⇑μ ((λ (h : G), g + h) ⁻¹' A) = ⇑μ A
{γ : Type u_1} {P : γ → set γ → Prop} (h : ∀ (t : set γ), t.finite → (∃ (c : γ), P c t)) : ∃ (u : ℕ → γ), ∀ (n : ℕ), P (u n) (u '' set.Iio n)
(bang : interactive.parse (optional (lean.parser.tk "!"))) (trace : interactive.parse (optional (lean.parser.tk "?"))) (cfg : tactic.tidy.cfg := {trace_result := bool.ff, trace_result_prefix := "Try this: ", tactics := tactic.tidy.default_tactics}) : tactic unit
(t s : expr) (md : tactic.transparency := tactic.transparency.semireducible) (approx : bool := bool.ff) : tactic unit
{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} {s : set α} : uniform_continuous_on f s ↔ ∀ (ε : ennreal), ε > 0 → (∃ (δ : ennreal) (H : δ > 0), ∀ {a : α} {H : a ∈ s} {b : α} {H : b ∈ s}, has_edist.edist a b < δ → has_edist.edist (f a) (f b) < ε)
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} [measure_theory.is_finite_measure μ] (hs : strict_convex ℝ s) (hsc : is_closed s) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) : f =ᵐ[μ] function.const α (⨍ (x : α), f x ∂μ) ∨ ⨍ (x : α), f x ∂μ ∈ interior s
(𝕜 : Type v) [is_R_or_C 𝕜] {E : Type u} [normed_group E] [normed_space 𝕜 E] (x : E) {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ (f : normed_space.dual 𝕜 E), ∥⇑f x∥ ≤ M * ∥f∥) : ∥x∥ ≤ M
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} {y : F} : box_integral.has_integral I l f vol y ↔ ∀ (ε : ℝ), ε > 0 → (∃ (r : nnreal → (ι → ℝ) → ↥(set.Ioi 0)), (∀ (c : nnreal), l.r_cond (r c)) ∧ ∀ (c : nnreal) (π : box_integral.tagged_prepartition I), l.mem_base_set I c (r c) π → π.is_partition → has_dist.dist (box_integral.integral_sum f vol π) y ≤ ε)
(p : Prop) [slim_check.testable p] (cfg : slim_check.slim_check_cfg := {num_inst := 100, max_size := 100, trace_discarded := bool.ff, trace_success := bool.ff, trace_shrink := bool.ff, trace_shrink_candidates := bool.ff, random_seed := option.none ℕ, quiet := bool.ff}) : io (slim_check.test_result p)
{ι : Type u_5} {π : ι → Type u_6} [Π (i : ι), topological_space (π i)] [decidable_eq ι] (i : ι) : continuous (λ (f : (Π (j : ι), π j) × π i), function.update f.fst i f.snd)
{α : Type u_1} {E : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] {m : measurable_space α} {μ : measure_theory.measure α} {ι : Type u_3} [encodable ι] {F : ι → α → E} {f : α → E} (bound : ι → α → ℝ) (hF_meas : ∀ (n : ι), measure_theory.ae_strongly_measurable (F n) μ) (h_bound : ∀ (n : ι), ∀ᵐ (a : α) ∂μ, ∥F n a∥ ≤ bound n a) (bound_summable : ∀ᵐ (a : α) ∂μ, summable (λ (n : ι), bound n a)) (bound_integrable : measure_theory.integrable (λ (a : α), ∑' (n : ι), bound n a) μ) (h_lim : ∀ᵐ (a : α) ∂μ, has_sum (λ (n : ι), F n a) (f a)) : has_sum (λ (n : ι), ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ)
(attr_name src tgt : name) (p : option bool := option.none) : tactic unit
{C : Type u₁} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] (f : X ⟶ Y) [I : category_theory.normal_mono f] : category_theory.regular_mono f
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g (⇑σ i)) ≤ s.sum (λ (i : ι), f i • g i)
{M₁ : Type u_1} {M₂ : Type u_2} {α : Type u_3} {R : Type u_4} {S : Type u_5} [topological_space M₂] [t2_space M₂] [semiring R] [semiring S] [add_comm_monoid M₁] [add_comm_monoid M₂] [module R M₁] [module S M₂] [has_continuous_const_smul S M₂] [has_continuous_add M₂] {σ : R →+* S} {l : filter α} (f : M₁ → M₂) (g : α → (M₁ →ₛₗ[σ] M₂)) [l.ne_bot] (h : filter.tendsto (λ (a : α) (x : M₁), ⇑(g a) x) l (nhds f)) : M₁ →ₛₗ[σ] M₂
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) {c d : nnreal} (hcd : c < d) (s : set α) (hc : ∀ (x : α), x ∈ s → (∃ᶠ (a : set α) in v.filter_at x, ⇑ρ a ≤ ↑c * ⇑μ a)) (hd : ∀ (x : α), x ∈ s → (∃ᶠ (a : set α) in v.filter_at x, ↑d * ⇑μ a ≤ ⇑ρ a)) : ⇑μ s = 0
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i • g i) < finset.univ.sum (λ (i : ι), f i • g (⇑σ i)) ↔ ¬antivary f (g ∘ ⇑σ)
{X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra ℝ C(X, ℝ)) (w : A.separates_points) (f : C(X, ℝ)) (ε : ℝ) (pos : 0 < ε) : ∃ (g : ↥A), ∥↑g - f∥ < ε
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_artinian R M] {P : submodule R M → Prop} (hgt : ∀ (I : submodule R M), (∀ (J : submodule R M), J < I → P J) → P I) (I : submodule R M) : P I
{α : Type u_1} {m : measurable_space α} (s : measure_theory.signed_measure α) (i : set α) (hi₁ : measurable_set i) (hi₂ : 0.restrict i ≤ measure_theory.vector_measure.restrict s i) : measure_theory.measure α
{α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {c : ℝ} {f : α → E} {g : α → F} {l : filter α} : asymptotics.is_O_with c l f g → (∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥)
{α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {f : α → β} (hf : measure_theory.mem_ℒp f 1 μ) (hmeas : measure_theory.strongly_measurable f) {ε : ℝ} (hε : 0 < ε) : ∃ (M : ℝ), 0 ≤ M ∧ ∫⁻ (x : α), ↑∥{x : α | M ≤ ↑∥f x∥₊}.indicator f x∥₊ ∂μ ≤ ennreal.of_real ε
{L : first_order.language} {M : Type u_3} [L.Structure M] (S : L.substructure M) (htv : ∀ (n : ℕ) (φ : L.bounded_formula empty (n + 1)) (x : fin n → ↥S) (a : M), φ.realize inhabited.default (fin.snoc (coe ∘ x) a) → (∃ (b : ↥S), φ.realize inhabited.default (fin.snoc (coe ∘ x) ↑b))) : L.elementary_substructure M
{A : Type u_2} [normed_ring A] [normed_algebra ℂ A] [complete_space A] [norm_one_class A] (a : A) : filter.tendsto (λ (n : ℕ), ennreal.of_real (∥a ^ n∥ ^ (1 / ↑n))) filter.at_top (nhds (spectral_radius ℂ a))
(args : list (name × option name × expr)) (md : tactic.transparency := tactic.transparency.semireducible) (unify : bool := bool.tt) : tactic (list expr × list expr)
{ι : Type u} {E : Type v} [fintype ι] [normed_group E] [normed_space ℝ E] (f : measure_theory.simple_func (ι → ℝ) E) (μ : measure_theory.measure (ι → ℝ)) [measure_theory.is_locally_finite_measure μ] (I : box_integral.box ι) (l : box_integral.integration_params) (hl : l.bRiemann = bool.ff) : box_integral.integral I l ⇑f μ.to_box_additive.to_smul = measure_theory.simple_func.integral (μ.restrict ↑I) f
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M →+ N} (h : ∀ (y : ↥S), is_add_unit (⇑f ↑y)) {y : ↥S} {z : N} (H : ⇑f ↑y + z = 0) : ↑-⇑(is_add_unit.lift_right (f.restrict S) h) y = z
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} {σ : Type u_4} [inhabited Λ] [inhabited σ] (M : Λ → turing.TM2.stmt Γ Λ σ) (k : K) (L : list (Γ k)) : part (list (Γ k))
(n : name) (n' : name := n.append_suffix "_apply") : tactic unit
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {C D : set (set α)} (h : μ.finite_spanning_sets_in C) (hC : C ∩ {s : set α | ⇑μ s < ⊤} ⊆ D) : μ.finite_spanning_sets_in D
(M : Type v) (X : Type x) [_inst_1 _inst_3 : uniform_space X] [has_vadd M X] : Prop
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr × expr)
{R : Type u} [comm_ring R] {I : ideal R} : I.jacobson = I ↔ ⊥.jacobson = ⊥
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {s t : set α} (H : s =ᵐ[μ] t) : ⇑μ s = ⇑μ t
{α : Type u} {β : Type v} [semilattice_inf α] [nonempty α] {I : set β} {S : β → set α} (H : I.finite) : bdd_below (⋃ (i : β) (H : i ∈ I), S i) ↔ ∀ (i : β), i ∈ I → bdd_below (S i)
{ι : Type u_2} {π : ι → Type u_1} [fintype ι] [Π (i : ι), semi_normed_group (π i)] {r : ℝ} (hr : 0 ≤ r) {x : Π (i : ι), π i} : ∥x∥ ≤ r ↔ ∀ (i : ι), ∥x i∥ ≤ r
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →ₛₗ[σ₁₂] F) {C : ℝ} (hC : 0 ≤ C) (h : ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_continuous C h∥ ≤ C
{R : Type u_1} [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] (H : algebra.is_integral R S) (P : ideal R) [P.is_prime] (I : ideal S) [I.is_prime] (hIP : ideal.comap (algebra_map R S) I ≤ P) : ∃ (Q : ideal S) (H : Q ≥ I), Q.is_prime ∧ ideal.comap (algebra_map R S) Q = P
{α : Type u_1} {γ : Type u_3} [measurable_space α] {μ : measure_theory.measure α} [topological_space γ] [add_monoid γ] [has_continuous_add γ] : (α →ₘ[μ] γ) →+ μ.ae.germ γ
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {f : α → β → γ} {s : set α} {t : set β} {g : γ → δ} {f' : β' → α → δ} {g' : β → β'} (h_antidistrib : ∀ (a : α) (b : β), g (f a b) = f' (g' b) a) : g '' set.image2 f s t = set.image2 f' (g' '' t) s
(ns : list name) (base : name := name.mk_string "h" name.anonymous) (offset : option ℕ := option.some 1) : tactic unit
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [measurable_space X] [borel_space X] [measurable_space Y] [borel_space Y] {K : nnreal} {f : X → Y} {s : set X} (h : lipschitz_on_with K f s) {d : ℝ} (hd : 0 ≤ d) : ⇑(measure_theory.measure.hausdorff_measure d) (f '' s) ≤ ↑K ^ d * ⇑(measure_theory.measure.hausdorff_measure d) s
{α : Type u_1} {σ : Type u_2} [primcodable α] [primcodable σ] {c : α → nat.partrec.code} (hc : primrec c) {z : α → σ} (hz : primrec z) {s : α → σ} (hs : primrec s) {l : α → σ} (hl : primrec l) {r : α → σ} (hr : primrec r) {pr : α → nat.partrec.code → nat.partrec.code → σ → σ → σ} (hpr : primrec (λ (a : α × nat.partrec.code × nat.partrec.code × σ × σ), pr a.fst a.snd.fst a.snd.snd.fst a.snd.snd.snd.fst a.snd.snd.snd.snd)) {co : α → nat.partrec.code → nat.partrec.code → σ → σ → σ} (hco : primrec (λ (a : α × nat.partrec.code × nat.partrec.code × σ × σ), co a.fst a.snd.fst a.snd.snd.fst a.snd.snd.snd.fst a.snd.snd.snd.snd)) {pc : α → nat.partrec.code → nat.partrec.code → σ → σ → σ} (hpc : primrec (λ (a : α × nat.partrec.code × nat.partrec.code × σ × σ), pc a.fst a.snd.fst a.snd.snd.fst a.snd.snd.snd.fst a.snd.snd.snd.snd)) {rf : α → nat.partrec.code → σ → σ} (hrf : primrec (λ (a : α × nat.partrec.code × σ), rf a.fst a.snd.fst a.snd.snd)) : let F : α → nat.partrec.code → σ := λ (a : α) (c : nat.partrec.code), c.rec_on (z a) (s a) (l a) (r a) (pr a) (co a) (pc a) (rf a) in primrec (λ (a : α), F a (c a))
{G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {μ : measure_theory.measure G} {Γ : add_subgroup G} {𝓕 : set G} (h𝓕 : measure_theory.is_add_fundamental_domain ↥(Γ.opposite) 𝓕 μ) [encodable ↥Γ] [measurable_space (G ⧸ Γ)] [borel_space (G ⧸ Γ)] [t2_space (G ⧸ Γ)] [topological_space.second_countable_topology (G ⧸ Γ)] (K : topological_space.positive_compacts (G ⧸ Γ)) [Γ.normal] [μ.is_add_haar_measure] [μ.is_add_right_invariant] (h𝓕_finite : ⇑μ 𝓕 < ⊤) : measure_theory.measure.map ⇑(quotient_add_group.mk' Γ) (μ.restrict 𝓕) = ⇑μ (𝓕 ∩ ⇑(quotient_add_group.mk' Γ) ⁻¹' ↑K) • measure_theory.measure.add_haar_measure K
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f (⇑σ i) * g i) < finset.univ.sum (λ (i : ι), f i * g i) ↔ ¬monovary (f ∘ ⇑σ) g
{α : Type u_1} [decidable_eq α] [fintype α] {𝒜 : finset (finset α)} {s : finset α} {k : ℕ} : s ∈ finset.up_shadow^[k] 𝒜 ↔ ∃ (t : finset α) (H : t ∈ 𝒜), t ⊆ s ∧ t.card + k = s.card
{a b : ℝ} (n : ℕ) : ∫ (x : ℝ) in set.interval_oc a b, |x - a| ^ n = |b - a| ^ (n + 1) / (↑n + 1)
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ℤ] [category_theory.preadditive C] [∀ (n : ℤ), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T ∈ dist_triang C) : T.mor₃ ≫ (category_theory.shift_equiv C 1).functor.map T.mor₁ = 0
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) ⦃ι : Type v⦄ (U : ι → topological_space.opens ↥X) : category_theory.limits.cone ((category_theory.pairwise.diagram U).op ⋙ F) ⥤ category_theory.limits.cone (Top.presheaf.sheaf_condition_equalizer_products.diagram F U)
{α : Type u_1} {β : Type u_2} [measurable_space α] [topological_space α] [opens_measurable_space α] [topological_space β] [topological_space.pseudo_metrizable_space β] [second_countable_topology_either α β] {f : α → β} {s : set α} {μ : measure_theory.measure α} (hs : is_open s) (hf : continuous_on f s) (x : α) (H : x ∈ s) : strongly_measurable_at_filter f (nhds x) μ
{L : first_order.language} {M : Type u_3} [L.Structure M] (S : L.substructure M) (htv : ∀ (n : ℕ) (φ : L.bounded_formula empty (n + 1)) (x : fin n → ↥S) (a : M), φ.realize inhabited.default (fin.snoc (coe ∘ x) a) → (∃ (b : ↥S), φ.realize inhabited.default (fin.snoc (coe ∘ x) ↑b))) : S.is_elementary
{α : Type u_1} [measurable_space α] [topological_space α] ⦃U : set α⦄ (hU : is_open U) (μ : measure_theory.measure α) [μ.weakly_regular] : ⇑μ U = ⨆ (F : set α) (H : F ⊆ U) (h : is_closed F), ⇑μ F
{α : Type u_1} {E : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [metric_space E] {f : ℕ → α → E} {g : α → E} [measure_theory.is_finite_measure μ] (hf : ∀ (n : ℕ), measure_theory.ae_strongly_measurable (f n) μ) (hfg : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (nhds (g x))) : measure_theory.tendsto_in_measure μ f filter.at_top g
(fn : name) (args : list (option expr)) (md : tactic.transparency := tactic.transparency.semireducible) : tactic expr
{ι : Type u_1} (I J : box_integral.box ι) (h : J ≤ I) : box_integral.prepartition I
{R : Type u} {S₁ : Type v} {σ : Type u_1} [comm_semiring R] [comm_semiring S₁] (f : R →+* S₁) (g : σ → S₁) (p : mv_polynomial σ R) : S₁
{𝕜 : Type u} [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] {H : Type w} [topological_space H] (I : model_with_corners 𝕜 E H) {E' : Type v'} [normed_group E'] [normed_space 𝕜 E'] {H' : Type w'} [topological_space H'] (I' : model_with_corners 𝕜 E' H') : model_with_corners 𝕜 (E × E') (model_prod H H')
{R : Type u} {σ : Type u_1} [comm_semiring R] (m : σ →₀ ℕ) : mv_polynomial σ R →+ R
{α : Type u_1} [measurable_space α] (s1 s2 : set (set α)) (μ : measure_theory.measure α . "volume_tac") : Prop
{ι : Type u_1} {π : ι → Type u_2} [Π (i : ι), topological_space (π i)] {s : Π (i : ι), set (π i)} : (∀ (i : ι), is_compact (s i)) → is_compact {x : Π (i : ι), π i | ∀ (i : ι), x i ∈ s i}
{α : Type u_1} {m : measurable_space α} (s : measure_theory.signed_measure α) (μ : measure_theory.measure α) : α → ℝ
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group β] {p : ennreal} {f : ι → α → β} [measure_theory.is_finite_measure μ] (hp : 1 ≤ p) (hp' : p ≠ ⊤) (hf : ∀ (i : ι), measure_theory.strongly_measurable (f i)) (h : ∀ (ε : ℝ), 0 < ε → (∃ (C : nnreal), ∀ (i : ι), measure_theory.snorm ({x : α | C ≤ ∥f i x∥₊}.indicator (f i)) p μ ≤ ennreal.of_real ε)) : measure_theory.uniform_integrable f p μ
(hs : interactive.parse tactic.simp_arg_list) (ps : interactive.parse (optional (lean.parser.tk "using" *> interactive.types.pexpr_list_or_texpr))) (cfg : auto.auto_config := {use_simp := bool.tt, max_ematch_rounds := 20}) : tactic unit
{F : Type u_3} [inner_product_space ℝ F] (K : submodule ℝ F) {u v : F} (hv : v ∈ K) : (∥u - v∥ = ⨅ (w : ↥↑K), ∥u - ↑w∥) ↔ ∀ (w : F), w ∈ K → has_inner.inner (u - v) w = 0
{Ω : Type u_1} [measure_theory.measure_space Ω] [measure_theory.is_probability_measure measure_theory.measure_space.volume] {X Y : Ω → ℝ} (hX : measure_theory.mem_ℒp X 2 measure_theory.measure_space.volume) (hY : measure_theory.mem_ℒp Y 2 measure_theory.measure_space.volume) (h : probability_theory.indep_fun X Y measure_theory.measure_space.volume) : probability_theory.variance (X + Y) measure_theory.measure_space.volume = probability_theory.variance X measure_theory.measure_space.volume + probability_theory.variance Y measure_theory.measure_space.volume
{c d : Type u → Type u} (F : Π {α : Type u}, d α → c α) : Type
{V : Type u_1} {W : Type u_2} [semi_normed_group V] [semi_normed_group W] (f : V →+ W) (C : nnreal) (hC : ∀ (x : V), ∥⇑f x∥₊ ≤ C * ∥x∥₊) : normed_group_hom V W
(Γ : Type u_1) [inhabited Γ] (Λ : Type u_2) (σ : Type u_3) : Type (max u_1 u_2 u_3)
{α : Type u} {β : Type v} (e : α ≃ β) [has_mul β] : let _inst : has_mul α := e.has_mul in α ≃* β
{R : Type u_1} [semiring R] {φ : power_series R} {n : ℕ} : φ.order = ↑n ↔ ⇑(power_series.coeff R n) φ ≠ 0 ∧ ∀ (i : ℕ), i < n → ⇑(power_series.coeff R i) φ = 0
(input : interactive.parse (optional (linear_combo.as_linear_combo bool.ff list.nilfunctor.map <$> interactive.types.texprinteractive.types.texpr))) (_x : interactive.parse (optional (lean.parser.tk "with"))) (config : linear_combo.linear_combination_config := {normalize := bool.tt, normalization_tactic := has_bind.seq (tactic.save_info {line := 75, column := 41}) (tactic.interactive.ring1 option.none).step}) : tactic unit
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} {g : E → ℝ} [measure_theory.is_probability_measure μ] (hg : concave_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) (hgi : measure_theory.integrable (g ∘ f) μ) : ∫ (x : α), g (f x) ∂μ ≤ g (∫ (x : α), f x ∂μ)
(e t : expr) (unify : bool := bool.tt) : tactic.unsafe.type_context expr
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_multicoequalizer I] (b : I.R) : I.right b ⟶ category_theory.limits.multicoequalizer I
{α : Type u_1} [metric_space α] [topological_space.second_countable_topology α] [measurable_space α] [opens_measurable_space α] [has_besicovitch_covering α] (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] [μ.outer_regular] {ε : ennreal} (hε : ε ≠ 0) (f : α → set ℝ) (s : set α) (hf : ∀ (x : α), x ∈ s → ∀ (δ : ℝ), δ > 0 → (f x ∩ set.Ioo 0 δ).nonempty) : ∃ (t : set α) (r : α → ℝ), t.countable ∧ t ⊆ s ∧ (∀ (x : α), x ∈ t → r x ∈ f x) ∧ (s ⊆ ⋃ (x : α) (H : x ∈ t), metric.closed_ball x (r x)) ∧ ∑' (x : ↥t), ⇑μ (metric.closed_ball ↑x (r ↑x)) ≤ ⇑μ s + ε
{ι : Type u_1} (I : box_integral.box ι) (i : ι) (x : ℝ) : with_bot (box_integral.box ι)
(σ : Type u_1) (R : Type u_2) [comm_semiring R] [fintype σ] (n : ℕ) : mv_polynomial σ R
{α : Type u_1} {E : Type u_3} [measurable_space α] {ι : Type u_5} [normed_group E] [topological_space α] [opens_measurable_space α] [normed_space ℝ E] [complete_space E] [second_countable_topology_either α E] {μ : measure_theory.measure α} [measure_theory.is_locally_finite_measure μ] {a : α} {t : set α} {f : α → E} (hft : continuous_on f t) (ha : a ∈ t) (ht : measurable_set t) {s : ι → set α} {li : filter ι} (hs : filter.tendsto s li (nhds_within a t).small_sets) (m : ι → ℝ := λ (i : ι), (⇑μ (s i)).to_real) (hsμ : (λ (i : ι), (⇑μ (s i)).to_real) =ᶠ[li] m . "refl") : (λ (i : ι), ∫ (x : α) in s i, f x ∂μ - m i • f a) =o[li] m
{α : Type u} {β : Type v} {φ : ultrafilter α} [division_ring β] : division_ring (↑φ.germ β)
{α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} {μ : measure_theory.measure α} [fact (1 ≤ p)] [normed_space ℝ F] (hm : m ≤ m0) (hp_ne_top : p ≠ ⊤) (P : ↥(measure_theory.Lp F p μ) → Prop) (h_ind : ∀ (c : F) {s : set α} (hs : measurable_set s) (hμs : ⇑μ s < ⊤), P ↑(measure_theory.Lp.simple_func.indicator_const p _ _ c)) (h_add : ∀ ⦃f g : α → F⦄ (hf : measure_theory.mem_ℒp f p μ) (hg : measure_theory.mem_ℒp g p μ), measure_theory.strongly_measurable f → measure_theory.strongly_measurable g → disjoint (function.support f) (function.support g) → P (measure_theory.mem_ℒp.to_Lp f hf) → P (measure_theory.mem_ℒp.to_Lp g hg) → P (measure_theory.mem_ℒp.to_Lp f hf + measure_theory.mem_ℒp.to_Lp g hg)) (h_closed : is_closed {f : ↥(measure_theory.Lp_meas F ℝ m p μ) | P ↑f}) (f : ↥(measure_theory.Lp F p μ)) : measure_theory.ae_strongly_measurable' m ⇑f μ → P f
{R : Type u} {M₂ : Type v₂} {M₃ : Type v₃} [semiring R] [add_comm_monoid M₂] [add_comm_monoid M₃] [module R M₂] [module R M₃] {ι₁ : Type u_1} {ι₂ : Type u_2} [decidable_eq ι₁] [decidable_eq ι₂] (σ : ι₁ ≃ ι₂) (f g : multilinear_map R (λ (i : ι₁), M₂) M₃) : multilinear_map.dom_dom_congr σ f = multilinear_map.dom_dom_congr σ g ↔ f = g
{α : Type u_1} [measurable_space α] [topological_space α] (A : set α) (μ : measure_theory.measure α) [μ.outer_regular] : ⇑μ A = ⨅ (U : set α) (h : A ⊆ U) (h2 : is_open U), ⇑μ U
{α : Type u_1} {E : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] {m : measurable_space α} {μ : measure_theory.measure α} {F : ℕ → α → E} {f : α → E} (bound : α → ℝ) (F_measurable : ∀ (n : ℕ), measure_theory.ae_strongly_measurable (F n) μ) (bound_integrable : measure_theory.integrable bound μ) (h_bound : ∀ (n : ℕ), ∀ᵐ (a : α) ∂μ, ∥F n a∥ ≤ bound a) (h_lim : ∀ᵐ (a : α) ∂μ, filter.tendsto (λ (n : ℕ), F n a) filter.at_top (nhds (f a))) : filter.tendsto (λ (n : ℕ), ∫ (a : α), F n a ∂μ) filter.at_top (nhds (∫ (a : α), f a ∂μ))
{V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x₁ x₂ y z : V} (hx₁yne : x₁ ≠ y) (hx₁zne : x₁ ≠ z) (hx₂yne : x₂ ≠ y) (hx₂zne : x₂ ≠ z) {r : ℝ} (hx₁ : ∥x₁∥ = r) (hx₂ : ∥x₂∥ = r) (hy : ∥y∥ = r) (hz : ∥z∥ = r) : 2 • hb.oangle (y - x₁) (z - x₁) = 2 • hb.oangle (y - x₂) (z - x₂)
{α : Type u_1} {E : Type u_3} [measurable_space α] [normed_group E] {f : α → E} {μ : measure_theory.measure α} {l : filter α} [l.is_measurably_generated] (hfm : strongly_measurable_at_filter f l μ) (hμ : μ.finite_at_filter l) {b : E} (hf : filter.tendsto f (l ⊓ μ.ae) (nhds b)) : measure_theory.integrable_at_filter f l μ
{ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), comm_ring (G i)] {f : Π (i j : ι), i ≤ j → G i → G j} [nonempty ι] [is_directed ι has_le.le] (z : ring.direct_limit G f) : ∃ (i : ι) (x : G i), ⇑(ring.direct_limit.of G f i) x = z
{R : Type u_16} {S : Type u_17} [semiring R] [semiring S] (σ : R →+* S) {σ' : S →+* R} [ring_hom_inv_pair σ σ'] [ring_hom_inv_pair σ' σ] (M : Type u_18) (M₂ : Type u_19) [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module S M₂] : Type (max u_18 u_19)
{α : Type u_1} [measurable_space α] (s : measure_theory.signed_measure α) : ∃ (i : set α), measurable_set i ∧ 0.restrict i ≤ measure_theory.vector_measure.restrict s i ∧ measure_theory.vector_measure.restrict s iᶜ ≤ 0.restrict iᶜ
{α : Type u_1} {β : Type u_2} [measurable_space α] (μ : measure_theory.measure α) [topological_space α] [borel_space α] [topological_space β] [second_countable_topology_either α β] [topological_space.pseudo_metrizable_space β] [add_group β] [topological_add_group β] : C(α, β) →+ α →ₘ[μ] β
(R : Type u_1) [semiring R] : is_noetherian_ring R ↔ ∀ (I : ideal R), I.fg
(𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {v : E} (w : E) : ↑(⇑(orthogonal_projection (submodule.span 𝕜 {v})) w) = (has_inner.inner v w / ↑∥v∥ ^ 2) • v
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] {F G : V ⥤ W} [F.additive] [G.additive] (α : F ⟶ G) (c : complex_shape ι) : F.map_homological_complex c ⟶ G.map_homological_complex c
{ι : Type u_1} [fintype ι] (μ : measure_theory.measure (ι → ℝ)) [measure_theory.is_locally_finite_measure μ] : box_integral.box_additive_map ι ℝ ⊤
(I : Type u_1) (R : Type u_2) (A : Type u_3) (m : I → Type u_4) [comm_semiring R] [semiring A] [algebra R A] [Π (i : I), fintype (m i)] [Π (i : I), decidable_eq (m i)] : algebra R (Π (i : I), matrix (m i) (m i) A)
{α : Type u_1} {ι : Type u_5} {m : measurable_space α} (μ : measure_theory.measure α) {s : ι → set α} (hs : ∀ (i : ι), measurable_set (s i)) (H : ⇑μ set.univ < ∑' (i : ι), ⇑μ (s i)) : ∃ (i j : ι) (h : i ≠ j), (s i ∩ s j).nonempty
{C : Type u₁} [category_theory.category C] {C' : Type u₂} [category_theory.category C'] (D : category_theory.glue_data C) (F : C ⥤ C') [H : Π (i j k : D.J), category_theory.limits.preserves_limit (category_theory.limits.cospan (D.f i j) (D.f i k)) F] : D.diagram.multispan ⋙ F ≅ (D.map_glue_data F).diagram.multispan
{E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} : (nhds_within (⇑(ext_chart_at I c) c) (set.range ⇑I)).has_basis (λ (f : smooth_bump_function I c), true) (λ (f : smooth_bump_function I c), euclidean.closed_ball (⇑(ext_chart_at I c) c) f.to_cont_diff_bump.to_cont_diff_bump_of_inner.R ∩ set.range ⇑I)
{C : Type u} [category_theory.category C] (𝒯 : category_theory.limits.limit_cone (category_theory.functor.empty C)) (ℬ : Π (X Y : C), category_theory.limits.limit_cone (category_theory.limits.pair X Y)) : category_theory.symmetric_category (category_theory.monoidal_of_chosen_finite_products.monoidal_of_chosen_finite_products_synonym 𝒯 ℬ)
{R : Type u_1} {S : Type u_6} {M₃ : Type u_12} [semiring R] [semiring S] [add_comm_monoid M₃] [module S M₃] {σ : R →+* S} {f g : R →ₛₗ[σ] M₃} (h : ⇑f 1 = ⇑g 1) : f = g
{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] ⦃f g : zero_hom M N⦄ (h : ⇑f = ⇑g) : f = g
{V : Type u} {G : simple_graph V} {u v : V} (p : G.walk u v) ⦃e : sym2 V⦄ (h : e ∈ p.edges) : e ∈ G.edge_set
{c : Type u → Type u} (hom : Π ⦃α β : Type u⦄, c α → c β → Type u) [𝒞 : category_theory.bundled_hom hom] : category_theory.category (category_theory.bundled c)
{α : Type u_1} [topological_space α] {m : measurable_space α} [topological_space.second_countable_topology α] [linear_order α] [order_topology α] [borel_space α] [no_max_order α] (μ ν : measure_theory.measure α) (hμ : ∀ ⦃a b : α⦄, a < b → ⇑μ (set.Ico a b) ≠ ⊤) (h : ∀ ⦃a b : α⦄, a < b → ⇑μ (set.Ico a b) = ⇑ν (set.Ico a b)) : μ = ν
{G : Type w} [topological_space G] (μ : measure_theory.content G) (U : topological_space.opens G) : ennreal
{R : Type u_5} [comm_ring R] [is_domain R] {ζ : R} {n : ℕ} (h : is_primitive_root ζ n) : (polynomial.nth_roots n 1).nodup
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_multiequalizer I] : C
{ι : Type u_1} {E : Type u_3} [semi_normed_group E] [complete_space E] {f : ι → E} (g : ι → ℝ) (hg : summable g) (h : ∀ᶠ (i : ι) in filter.cofinite, ∥f i∥ ≤ g i) : summable f
{R : Type u} [comm_semiring R] (I : ideal R) : Prop
{α : Type u_1} {β : Type u_2} [semi_normed_group β] {m : measurable_space α} (μ : measure_theory.measure α) (T : set α → β) (C : ℝ) : Prop
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {ι : Type u_3} [decidable_eq ι] {S : finset ι} {p : ι → ideal R} (hp : ↑S.pairwise (λ (i j : ι), p i ⊔ p j = ⊤)) (hM : module.is_torsion_by_set R M (↑⨅ (i : ι) (H : i ∈ S), p i)) : direct_sum.is_internal (λ (i : ↥S), submodule.torsion_by_set R M ↑(p ↑i))
{E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] (I : model_with_corners ℝ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (c : M) [t2_space M] : (nhds c).has_basis (λ (f : smooth_bump_function I c), true) (λ (f : smooth_bump_function I c), tsupport ⇑f)
{α : Type u_1} {β : Type u_2} [linear_ordered_add_comm_group β] [uniform_space β] [uniform_add_group β] [complete_space β] {f : α → β} : summable f → summable (λ (x : α), |f x|)
{α : Type u_1} {β : Type u_2} [add_zero_class α] [add_zero_class β] (f : α →+ β) (I : Type u_3) : (I → α) →+ I → β
{F : Type u_3} [inner_product_space ℝ F] (x : F) (r : ℝ) : has_inner.inner x (r • x) = r * (∥x∥ * ∥x∥)
{ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {c : E} {lb lb' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {u v : ι → ℝ} [interval_integral.FTC_filter b lb lb'] [measure_theory.is_locally_finite_measure μ] (hab : interval_integrable f μ a b) (hmeas : strongly_measurable_at_filter f lb' μ) (hf : filter.tendsto f (lb' ⊓ μ.ae) (nhds c)) (hu : filter.tendsto u lt lb) (hv : filter.tendsto v lt lb) : (λ (t : ι), ∫ (x : ℝ) in a..v t, f x ∂μ - ∫ (x : ℝ) in a..u t, f x ∂μ - ∫ (x : ℝ) in u t..v t, c ∂μ) =o[lt] λ (t : ι), ∫ (x : ℝ) in u t..v t, 1 ∂μ
(σ : Type u_1) (R : Type u_3) [comm_semiring R] (n : ℕ) : submodule R (mv_polynomial σ R)
{R : Type u} {S : Type v} [ring R] [ring S] (I : ideal R) (f : R ≃+* S) : ideal.map ↑f I = ideal.comap ↑(f.symm) I
{𝕜 : Type u} [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] {H : Type w} [topological_space H] (I : model_with_corners 𝕜 E H) [I.boundaryless] {E' : Type v'} [normed_group E'] [normed_space 𝕜 E'] {H' : Type w'} [topological_space H'] (I' : model_with_corners 𝕜 E' H') [I'.boundaryless] : (I.prod I').boundaryless
(name : module_info.module_name) (cur_module : module_info.module_id := "") : module_info
{E : Type u} [normed_group E] [normed_space ℂ E] {F : Type v} [normed_group F] [normed_space ℂ F] [nontrivial E] {f : E → F} {U : set E} (hU : metric.bounded U) (hd : diff_cont_on_cl ℂ f U) {C : ℝ} (hC : ∀ (z : E), z ∈ frontier U → ∥f z∥ ≤ C) {z : E} (hz : z ∈ closure U) : ∥f z∥ ≤ C
{ι : Type u_1} {I : box_integral.box ι} (π₁ π₂ : box_integral.prepartition I) (h : disjoint π₁.Union π₂.Union) : box_integral.prepartition I
{α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [sigma_compact_space α] [μ.regular] : measure_theory.sigma_finite μ
{f f' : ℝ → ℝ} {s : set ℝ} (hs : convex ℝ s) (hf : ∀ (x : ℝ), x ∈ s → has_deriv_at f (f' x) x) : convex ℝ (f' '' s)
{V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] : ∥0∥ = 0
{X : Type u} {Y : Type v} {Z : Type w} [metric_space X] [metric_space Y] (Φ : Z → X) (Ψ : Z → Y) (ε : ℝ) : X ⊕ Y → X ⊕ Y → ℝ
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ⟶ Y} {W : C} (g : W ⟶ X) (h : W ⟶ Y) {c : category_theory.limits.cokernel_cofork h} (i : category_theory.limits.is_colimit c) (hf : f ≫ category_theory.limits.cofork.π c = 0) (hfg : g ≫ f = h) : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_π (category_theory.limits.cofork.π c) hf)
{J : Type v} {C : Type u} [category_theory.category C] {F : category_theory.limits.wide_pullback_shape J ⥤ C} {X : C} (f : X ⟶ F.obj option.none) (π : Π (j : J), X ⟶ F.obj (option.some j)) (w : ∀ (j : J), π j ≫ F.map (category_theory.limits.wide_pullback_shape.hom.term j) = f) : category_theory.limits.cone F
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) {s : set α} (hs : is_open s) : is_open (⇑e '' (e.to_local_equiv.source ∩ s))
{α : Type u_1} [preorder α] {f : α → α} {x : α} (hf : strict_mono f) (hx : x < f x) : strict_mono (λ (n : ℕ), f^[n] x)
{X : Type u} {G : Type u_2} [group G] [mul_action G X] {P : Π ⦃a b : category_theory.action_category G X⦄, (a ⟶ b) → Sort u_1} (hyp : Π (t : X) (g : G), P (category_theory.action_category.hom_of_pair t g)) ⦃a b : category_theory.action_category G X⦄ (f : a ⟶ b) : P f
(no_dflt : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (locat : interactive.parse interactive.types.location) (cfg : tactic.simp_config_ext := {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}, discharger := tactic.field_simp.ne_zero}) : tactic unit
{X : Type u_1} [emetric_space X] [sigma_compact_space X] [measurable_space X] [borel_space X] (μ : measure_theory.measure X) [measure_theory.is_locally_finite_measure μ] : μ.regular
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {f : α → α} {s : set α} (hf : measure_theory.measure_preserving f μ μ) (hs : measurable_set s) {n : ℕ} (hvol : ⇑μ set.univ < ↑n * ⇑μ s) : ∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ set.Ioo 0 n), f^[m] x ∈ s
{R : Type u} [comm_ring R] (I : ideal R) (f : polynomial R) : polynomial (R ⧸ I) ⧸ ideal.span {polynomial.map (ideal.quotient.mk I) f} ≃+* (polynomial R ⧸ ideal.map polynomial.C I) ⧸ ideal.span {⇑(ideal.quotient.mk (ideal.map polynomial.C I)) f}
{α : Type u_1} [measurable_space α] {s : measure_theory.signed_measure α} {u v : set α} (hu : measurable_set u) (hv : measurable_set v) (hsu : measure_theory.vector_measure.restrict s u ≤ 0.restrict u) (hsv : measure_theory.vector_measure.restrict s v ≤ 0.restrict v) (hs : ⇑s (u ∆ v) = 0) : ⇑s (u  v) = 0 ∧ ⇑s (v  u) = 0
(p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] [perfect_ring R p] (S : Type u₂) [comm_semiring S] [char_p S p] (P : Type u₃) [comm_semiring P] [char_p P p] [perfect_ring P p] (π : P →+* S) (m : perfection_map p π) : (R →+* S) ≃ (R →+* P)
{G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {μ : measure_theory.measure G} [group G] [topological_group G] [μ.is_mul_left_invariant] {U : set G} (hU : (interior U).nonempty) (h : ⇑μ U ≠ ⊤) {K : set G} (hK : is_compact K) : ⇑μ K < ⊤
(e : expr) (ids : list name := list.nil) (md dmd : tactic.transparency := tactic.transparency.semireducible) : tactic (list (name × list expr))
{C : ℚ → Sort u} (a : ℚ) (H : Π (n : ℤ) (d : ℕ), 0 < d → n.nat_abs.coprime d → C (rat.mk n ↑d)) : C a
{α : Type u} {C : list α → Sort u_1} (l : list α) (H0 : C list.nil) (H1 : Π (a : α), C [a]) (Hn : Π (a : α) (l : list α) (b : α), C l → C (a :: (l ++ [b]))) : C l
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s : ℕ → set α} (hs : ∑' (i : ℕ), ⇑μ (s i) ≠ ⊤) : ∀ᵐ (x : α) ∂μ, ∀ᶠ (n : ℕ) in filter.at_top, x ∉ s n
{C : Type u₁} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] {W : C} (f : X ⟶ Y) [category_theory.normal_mono f] (k : W ⟶ Y) (h : k ≫ category_theory.normal_mono.g = 0) : {l // l ≫ f = k}
(α : Type u) (β : Type v) [add_group α] [add_action α β] : β ≃ Σ (ω : quotient (add_action.orbit_rel α β)), α ⧸ add_action.stabilizer α ω.out'
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} {t : category_theory.limits.pushout_cocone f g} (ht : category_theory.limits.is_colimit t) {W : C} (h : Y ⟶ W) (k : Z ⟶ W) (w : f ≫ h = g ≫ k) : {l // t.inl ≫ l = h ∧ t.inr ≫ l = k}
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] (M : turing.TM0.machine Γ Λ) (l : list Γ) : part (turing.list_blank Γ)
{n : ℕ} (I : box_integral.box (fin (n + 1))) (i : fin (n + 1)) : box_integral.box (fin n)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {σ τ : Type v} [fintype τ] {S : σ → C} [category_theory.limits.has_biproduct S] {T : τ → C} [category_theory.limits.has_biproduct T] (s : σ) (nz : 𝟙 (S s) ≠ 0) (f : ⨁ S ⟶ ⨁ T) [category_theory.is_iso f] : trunc (Σ' (t : τ), category_theory.limits.biproduct.ι S s ≫ f ≫ category_theory.limits.biproduct.π T t ≠ 0)
{p : ℕ} {g : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R → witt_vector p R} {f : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R} (hg : witt_vector.is_poly₂ p g) (hf : witt_vector.is_poly p f) : witt_vector.is_poly₂ p (λ (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g (f x) y)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {x : M} {n : with_top ℕ} : cont_mdiff_within_at I I' n f s x ↔ continuous_within_at f s x ∧ cont_mdiff_within_at I (model_with_corners_self 𝕜 E') n (⇑(ext_chart_at I' (f x)) ∘ f) (s ∩ f ⁻¹' (ext_chart_at I' (f x)).source) x
{elab : bool} (e : expr elab) (mappings : list (expr × expr)) : expr elab
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} {c : category_theory.limits.cofork f g} (i : category_theory.limits.is_colimit c) {W : C} (h : W ⟶ X) [hm : category_theory.epi h] : category_theory.limits.is_colimit (category_theory.limits.cofork.of_π c.π _)
{ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (fs : smooth_bump_covering ι I M s) [t2_space M] : smooth_partition_of_unity ι I M s
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {σ : Type u_4} [inhabited σ] (k : K) : Type (max u_2 u_4)
{a b : ℝ} {g' g φ : ℝ → ℝ} (hab : a ≤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_within_at g (g' x) (set.Ioi x) x) (φint : measure_theory.integrable_on φ (set.Icc a b) measure_theory.measure_space.volume) (hφg : ∀ (x : ℝ), x ∈ set.Ioo a b → g' x ≤ φ x) : g b - g a ≤ ∫ (y : ℝ) in a..b, φ y
{G : Type u} [group G] {A : Type v} [monoid A] (φ ψ : abelianization G →* A) (h : φ.comp abelianization.of = ψ.comp abelianization.of) : φ = ψ
{E : Type u_1} [normed_group E] [normed_space ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hd : diff_cont_on_cl ℂ f (set.Iio 0 ×ℂ set.Iio 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Iio 0 ×ℂ set.Iio 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : ∀ (x : ℝ), x ≤ 0 → ∥f ↑x∥ ≤ C) (him : ∀ (x : ℝ), x ≤ 0 → ∥f (↑x * complex.I)∥ ≤ C) (hz_re : z.re ≤ 0) (hz_im : z.im ≤ 0) : ∥f z∥ ≤ C
{α : Type u} {s : set α} {σ : equiv.perm α} (hs : {a : α | ⇑σ a ≠ a} ⊆ s) : ⇑σ '' s = s
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) {u v : E} (hv : v ∈ K) : (∥u - v∥ = ⨅ (w : ↥↑K), ∥u - ↑w∥) ↔ ∀ (w : E), w ∈ K → has_inner.inner (u - v) w = 0
{α : Type u_1} {G : Type u_5} [normed_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] {f : α → G} {m0 : measurable_space α} (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] : measure_theory.ae_fin_strongly_measurable f μ ↔ ae_measurable f μ
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.prepartition I) (p : box_integral.box ι → Prop) : box_integral.prepartition I
{C : Type u} [category_theory.category C] [category_theory.abelian C] {X : C} (I : category_theory.InjectiveResolution X) (J : category_theory.InjectiveResolution X) : homotopy_equiv I.cocomplex J.cocomplex
{C : Type u₁} [category_theory.category C] {C' : Type u₂} [category_theory.category C'] (D : category_theory.glue_data C) (F : C ⥤ C') [H : Π (i j k : D.J), category_theory.limits.preserves_limit (category_theory.limits.cospan (D.f i j) (D.f i k)) F] [category_theory.limits.has_multicoequalizer D.diagram] [category_theory.limits.preserves_colimit D.diagram.multispan F] (i j : D.J) [category_theory.limits.reflects_limit (category_theory.limits.cospan (D.ι i) (D.ι j)) F] (hc : category_theory.limits.is_limit ((D.map_glue_data F).V_pullback_cone i j)) : category_theory.limits.is_limit (D.V_pullback_cone i j)
(generate_induction_hyps : bool) (major_premise : expr) (eq_name : option name := option.none) (gm : tactic.eliminate.generalization_mode := tactic.eliminate.generalization_mode.generalize_all_except list.nil) (with_patterns : list tactic.eliminate.with_pattern := list.nil) : tactic unit
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X ⟶ W) (g : Y ⟶ W) (i : W ⟶ Z) [category_theory.mono i] (s : category_theory.limits.pullback_cone f g) (H : category_theory.limits.is_limit s) : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk s.fst s.snd _)
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) {s : set α} (hs : is_open s) (h : s ⊆ e.to_local_equiv.source) : is_open (⇑e '' s)
{C : Type u} [category_theory.category C] {W X Y : C} [category_theory.limits.has_binary_coproduct X Y] (f : X ⟶ W) (g : Y ⟶ W) : {l // category_theory.limits.coprod.inl ≫ l = f ∧ category_theory.limits.coprod.inr ≫ l = g}
{𝕜 : Type u_3} {E : Type u_4} [normed_field 𝕜] [semi_normed_group E] [normed_space 𝕜 E] {r : ℝ} {x : E} (hx : ∥x∥ < r) : absorbent 𝕜 (metric.ball x r)
{G : Type u_1} [measurable_space G] [add_group G] [has_measurable_add₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] [has_measurable_neg G] [μ.is_add_left_invariant] [ν.is_add_left_invariant] (hν : ν ≠ 0) : μ.absolutely_continuous ν
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] (φ : R →+* S) (P : cubic R) : cubic S
{E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (f : E ≃L[ℝ] E) (s : set E) : ⇑μ (⇑f ⁻¹' s) = ennreal.of_real |⇑linear_map.det ↑(f.symm)| * ⇑μ s
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] {W X Y Z : C} (f : W ⟶ Y) (g : X ⟶ Z) [category_theory.is_iso (category_theory.limits.biprod.map f g)] : category_theory.is_iso g
{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {t : set α} (Hf : monotone_on f t) {a : α} (Ha : is_greatest t a) : is_greatest (f '' t) (f a)
{α : Type u_1} {ι : Type u_3} {m : measurable_space α} [preorder ι] (μ : measure_theory.measure α) (f : measure_theory.filtration ι m) : Prop
{V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 1)) (i : fin (n + 2)) : s.altitude i = affine_subspace.mk' (s.points i) ((affine_span ℝ (s.points '' ↑(finset.univ.erase i))).direction)ᗮ ⊓ affine_span ℝ (set.range s.points)
{ι : Type u} {γ : Type w} {β : ι → Type v} [dec : decidable_eq ι] [Π (i : ι), has_zero (β i)] [Π (i : ι) (x : β i), decidable (x ≠ 0)] [comm_monoid γ] (f : Π₀ (i : ι), β i) (g : Π (i : ι), β i → γ) : γ
{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} : uniform_continuous f ↔ ∀ (ε : ennreal), ε > 0 → (∃ (δ : ennreal) (H : δ > 0), ∀ {a b : α}, has_edist.edist a b < δ → has_edist.edist (f a) (f b) < ε)
{I : Type u_1} [decidable_eq I] {Z : I → Type u_2} [Π (i : I), add_comm_monoid (Z i)] [fintype I] (M : Type u_3) [add_comm_monoid M] (g h : (Π (i : I), Z i) →+ M) (H : ∀ (i : I), g.comp (add_monoid_hom.single Z i) = h.comp (add_monoid_hom.single Z i)) : g = h
{n : ℕ} {K : Type u_8} [comm_ring K] {μ : K} (h : is_primitive_root μ n) (hpos : 0 < n) : is_integral ℤ μ
{α : Type u_1} {M : Type u_2} {N : Type u_3} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid N] [module R N] ⦃φ ψ : (α →₀ M) →ₗ[R] N⦄ (h : ∀ (a : α) (b : M), ⇑φ (finsupp.single a b) = ⇑ψ (finsupp.single a b)) : φ = ψ
(G : Type u_1) {α : Type u_2} [has_one G] [has_scalar G α] [measurable_space α] (s : set α) (μ : measure_theory.measure α . "volume_tac") : Prop
{α : Type u_1} {ι : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} {E : Type u_3} [normed_group E] {f : ι → α → E} {g : α → E} {l : filter ι} (hfg : filter.tendsto (λ (n : ι), measure_theory.snorm (f n - g) ⊤ μ) l (nhds 0)) : measure_theory.tendsto_in_measure μ f l g
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) [complete_space ↥K] : ∥orthogonal_projection K∥ ≤ 1
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_monoid M] (f : add_monoid_algebra R M) : f ∈ algebra.adjoin R (add_monoid_algebra.of' R M '' ↑(f.support))
(R : Type u_1) [comm_ring R] (I : ideal R) [is_adic_complete I R] : henselian_ring R I
{α : Type u_2} [measurable_space α] {f : α → α} {s : set α} {μ : measure_theory.measure α} (hf : measure_theory.conservative f μ) (hs : measurable_set s) (h0 : ⇑μ s ≠ 0) : ∃ᶠ (m : ℕ) in filter.at_top, ⇑μ (s ∩ f^[m] ⁻¹' s) ≠ 0
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f (⇑σ i) • g i) < s.sum (λ (i : ι), f i • g i) ↔ ¬monovary_on (f ∘ ⇑σ) g ↑s
{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (W : submodule R M) : module.dual R M →ₗ[R] module.dual R ↥W
{α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (has_Sup.Sup s)) (Mf : monotone f) (hs : s.nonempty) : f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
{R : Type u_1} [semiring R] (φ : power_series R) : φ = power_series.X * power_series.mk (λ (p : ℕ), ⇑(power_series.coeff R (p + 1)) φ) + ⇑(power_series.C R) (⇑(power_series.constant_coeff R) φ)
{R : Type u_1} [semiring R] (φ : power_series R) : φ = power_series.mk (λ (p : ℕ), ⇑(power_series.coeff R (p + 1)) φ) * power_series.X + ⇑(power_series.C R) (⇑(power_series.constant_coeff R) φ)
{ι : Type u} (s : finset ι) (f g : ι → ℝ) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), |f i + g i| ^ p) ^ (1 / p) ≤ s.sum (λ (i : ι), |f i| ^ p) ^ (1 / p) + s.sum (λ (i : ι), |g i| ^ p) ^ (1 / p)
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i * g (⇑σ i)) ≤ s.sum (λ (i : ι), f i * g i)
{N : Type u_2} {α : Type u_3} [preorder α] [preorder N] {f : N → α} {μ : N → N → N} [covariant_class N N (function.swap μ) has_le.le] (hf : antitone f) (m : N) : antitone (λ (n : N), f (μ n m))
{G : Type u_1} [measurable_space G] [has_mul G] (μ : measure_theory.measure G) : Prop
{S : Type u_2} [comm_ring S] [is_domain S] {R : Type u_1} [comm_ring R] [is_domain R] [ideal.is_jacobson R] (Rₘ : Type u_3) (Sₘ : Type u_4) [comm_ring Rₘ] [comm_ring Sₘ] (φ : R →+* S) (hφ : function.injective ⇑φ) (x : R) (hx : x ≠ 0) [algebra R Rₘ] [is_localization.away x Rₘ] [algebra S Sₘ] [is_localization (submonoid.map ↑φ (submonoid.powers x)) Sₘ] (hφ' : (is_localization.map Sₘ φ _).is_integral) : ⊥.jacobson = ⊥
{C : Type u₁} [category_theory.category C] {C' : Type u₂} [category_theory.category C'] (D : category_theory.glue_data C) (F : C ⥤ C') [H : Π (i j k : D.J), category_theory.limits.preserves_limit (category_theory.limits.cospan (D.f i j) (D.f i k)) F] : category_theory.glue_data C'
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : M → M') (x : M) : Prop
{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type v} [add_comm_group M] [module R M] [module.finite R M] (hM : module.is_torsion R M) : ∃ (ι : Type u) [_inst_9 : fintype ι] [_inst_10 : decidable_eq ι] (p : ι → R) [_inst_11 : ∀ (i : ι), irreducible (p i)] (e : ι → ℕ), direct_sum.is_internal (λ (i : ι), submodule.torsion_by R M (p i ^ e i))
{G : Type u_4} [measurable_space G] {μ : measure_theory.measure G} [topological_space G] [add_group G] [topological_add_group G] [borel_space G] [μ.is_add_left_invariant] [μ.regular] (hμ : μ ≠ 0) {f : G → ennreal} (hf : continuous f) : ∫⁻ (x : G), f x ∂μ = 0 ↔ f = 0
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x₀ : E} (hf : has_fderiv_at f f' x₀) {s : set E} (hs : s ∈ nhds x₀) {C : nnreal} (hlip : lipschitz_on_with C f s) : ∥f'∥ ≤ ↑C
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} {W : C} (fst : W ⟶ X) (snd : W ⟶ Y) (eq : fst ≫ f = snd ≫ g) : category_theory.limits.pullback_cone f g
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {I : lie_ideal R L} (k : ℕ) : ↑(lie_module.lower_central_series R ↥I ↥I k) ≤ ↑(lie_module.lower_central_series R L ↥I k)
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} [category_theory.limits.has_pushout f g] {W : C} {k l : category_theory.limits.pushout f g ⟶ W} (h₀ : category_theory.limits.pushout.inl ≫ k = category_theory.limits.pushout.inl ≫ l) (h₁ : category_theory.limits.pushout.inr ≫ k = category_theory.limits.pushout.inr ≫ l) : k = l
{a b : ℝ} {g' g φ : ℝ → ℝ} (hab : a ≤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_within_at g (g' x) (set.Ioi x) x) (φint : measure_theory.integrable_on φ (set.Icc a b) measure_theory.measure_space.volume) (hφg : ∀ (x : ℝ), x ∈ set.Ioo a b → φ x ≤ g' x) : ∫ (y : ℝ) in a..b, φ y ≤ g b - g a
{C : Type u} [category_theory.category C] (I : C) (h : ∀ (A : C) (f : I ⟶ A), category_theory.is_iso f) : category_theory.limits.has_strict_terminal_objects C
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] {σ : Type u_3} [inhabited σ] {n : ℕ} (enc : Γ → vector bool n) (dec : vector bool n → Γ) (M : Λ → turing.TM1.stmt Γ Λ σ) : turing.TM1to1.Λ' → turing.TM1.stmt bool turing.TM1to1.Λ' σ
{𝕜 : Type u_1} {𝕜' : Type u_2} {E : Type u_3} [normed_field 𝕜'] [semi_normed_group E] [I : normed_space 𝕜' E] : normed_space 𝕜' (restrict_scalars 𝕜 𝕜' E)
(𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {v : E} (hv : ∥v∥ = 1) (w : E) : ↑(⇑(orthogonal_projection (submodule.span 𝕜 {v})) w) = has_inner.inner v w • v
{R : Type u} [comm_ring R] (I : ideal R) (f : polynomial R) : adjoin_root f ⧸ ideal.map (adjoin_root.of f) I ≃+* polynomial (R ⧸ I) ⧸ ideal.span {polynomial.map (ideal.quotient.mk I) f}
{α : Type u_1} {ι : Type u_2} (m : ι → measurable_space α) [measurable_space α] (μ : measure_theory.measure α . "volume_tac") : Prop
{F : Type u_3} [inner_product_space ℝ F] (x y : F) : |has_inner.inner x y / (∥x∥ * ∥y∥)| = 1 ↔ x ≠ 0 ∧ ∃ (r : ℝ), r ≠ 0 ∧ y = r • x
{E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (A : E →L[ℝ] E) {m : nnreal} (hm : ↑m < ennreal.of_real |A.det|) : ∀ᶠ (δ : nnreal) in nhds_within 0 (set.Ioi 0), ∀ (s : set E) (f : E → E), approximates_linear_on f A s δ → ↑m * ⇑μ s ≤ ⇑μ (f '' s)
{C : Type (max v u)} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] {K : Type (max v u)} [category_theory.small_category K] [category_theory.limits.has_limits_of_shape K D] (F : K ⥤ category_theory.Sheaf J D) (E : category_theory.limits.cone (F ⋙ category_theory.Sheaf_to_presheaf J D)) (hE : category_theory.limits.is_limit E) (X : C) (W : J.cover X) : category_theory.limits.is_limit (W.multifork E.X)
{A : Type u₁} [category_theory.category A] {B : Type u₂} [category_theory.category B] {C : Type u₃} [category_theory.category C] {D : Type u₄} [category_theory.category D] {F G : A ⥤ B} {H I : C ⥤ D} (α : F ⟶ G) (β : H ⟶ I) : F.prod H ⟶ G.prod I
{β : Type v} {π : β → Type u_1} [fintype β] [Π (b : β), pseudo_emetric_space (π b)] : pseudo_emetric_space (Π (b : β), π b)
{α : Type u_1} [measurable_space α] [topological_space α] (μ : measure_theory.measure α) : Prop
{α : Type u_1} {E : Type u_3} [measurable_space α] {ι : Type u_5} [normed_group E] [topological_space α] [opens_measurable_space α] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} [measure_theory.is_locally_finite_measure μ] {a : α} {t : set α} {f : α → E} (ha : continuous_within_at f t a) (ht : measurable_set t) (hfm : strongly_measurable_at_filter f (nhds_within a t) μ) {s : ι → set α} {li : filter ι} (hs : filter.tendsto s li (nhds_within a t).small_sets) (m : ι → ℝ := λ (i : ι), (⇑μ (s i)).to_real) (hsμ : (λ (i : ι), (⇑μ (s i)).to_real) =ᶠ[li] m . "refl") : (λ (i : ι), ∫ (x : α) in s i, f x ∂μ - m i • f a) =o[li] m
{𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {f' : F} : has_deriv_at f f' x → has_fderiv_at f (1.smul_right f') x
{C : Type u₁} (W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] [category_theory.enriched_category W C] {X Y : C} (f : 𝟙_ W ⟶ category_theory.enriched_category.hom X Y) : category_theory.forget_enrichment.of W X ⟶ category_theory.forget_enrichment.of W Y
{𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space ℝ F] [normed_space 𝕜 F] [complete_space F] [measurable_space G] {μ : measure_theory.measure G} (L : E →L[𝕜] E' →L[𝕜] F) [normed_group G] [borel_space G] [topological_space.second_countable_topology G] [sigma_compact_space G] [measure_theory.sigma_finite μ] [μ.is_add_left_invariant] [normed_space 𝕜 G] [proper_space G] (hcg : has_compact_support g) (hf : measure_theory.locally_integrable f μ) (hg : cont_diff 𝕜 1 g) (x₀ : G) : has_fderiv_at (convolution f g L μ) (convolution f (fderiv 𝕜 g) (continuous_linear_map.precompR G L) μ x₀) x₀
{ι : Type u} {E : Type v} [fintype ι] [normed_group E] [normed_space ℝ E] {l : box_integral.integration_params} {I : box_integral.box ι} {f : (ι → ℝ) → E} {μ : measure_theory.measure (ι → ℝ)} [measure_theory.is_locally_finite_measure μ] (hf : f =ᵐ[μ.restrict ↑I] 0) (hl : l.bRiemann = bool.ff) : box_integral.has_integral I l f μ.to_box_additive.to_smul 0
{α : Type u_1} {ι : Type u_2} {E : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group E] {p : ennreal} {f : ι → α → E} {g : α → E} (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ⊤) (hf : ∀ (n : ι), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) {l : filter ι} (hfg : filter.tendsto (λ (n : ι), measure_theory.snorm (f n - g) p μ) l (nhds 0)) : measure_theory.tendsto_in_measure μ f l g
{α : Type u} [uniform_space α] {f : filter α} (hf : cauchy f) {U : ℕ → set (α × α)} (U_mem : ∀ (n : ℕ), U n ∈ uniformity α) (U_le : ∀ (s : set (α × α)), s ∈ uniformity α → (∃ (n : ℕ), U n ⊆ s)) ⦃a : α⦄ (ha : filter.tendsto (sequentially_complete.seq hf U_mem) filter.at_top (nhds a)) : f ≤ nhds a
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_10} [semi_normed_group E'] [normed_space 𝕜 E'] [ring_hom_isometric σ₁₂] [proper_space F] {s : set (E' →SL[σ₁₂] F)} (hb : metric.bounded s) (hc : is_closed (coe_fn '' s)) : is_compact (coe_fn '' s)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] (s : set M) : Prop
{P : Type u_1} [has_le P] {I : set P} (h : order.is_ideal I) : order.ideal P
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {C : set (set α)} (h : μ.finite_spanning_sets_in C) : measure_theory.sigma_finite μ
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [metric_space β] {μ : measure_theory.measure α} [semilattice_sup ι] [nonempty ι] [encodable ι] {f : ι → α → β} {g : α → β} [measure_theory.is_finite_measure μ] (hf : ∀ (n : ι), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hfg : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ι), f n x) filter.at_top (nhds (g x))) {ε : ℝ} (hε : 0 < ε) : ∃ (t : set α), measurable_set t ∧ ⇑μ t ≤ ennreal.of_real ε ∧ tendsto_uniformly_on f g filter.at_top tᶜ
{α : Type u_1} {E : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [metric_space E] {f : ℕ → α → E} {g : α → E} (hfg : measure_theory.tendsto_in_measure μ f filter.at_top g) : ∃ (ns : ℕ → ℕ), strict_mono ns ∧ ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (i : ℕ), f (ns i) x) filter.at_top (nhds (g x))
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {c : ℝ} {f' : α → E'} {g' : α → F'} {l : filter α} : asymptotics.is_O_with c l (λ (x : α), ∥f' x∥) (λ (x : α), ∥g' x∥) → asymptotics.is_O_with c l f' g'
{α : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {m : measurable_space α} {μ : measure_theory.measure α} [complete_space F] {T : set α → (E →L[ℝ] F)} {C : ℝ} (hT : measure_theory.dominated_fin_meas_additive μ T C) {fs : ℕ → α → E} {f : α → E} (bound : α → ℝ) (fs_measurable : ∀ (n : ℕ), measure_theory.ae_strongly_measurable (fs n) μ) (bound_integrable : measure_theory.integrable bound μ) (h_bound : ∀ (n : ℕ), ∀ᵐ (a : α) ∂μ, ∥fs n a∥ ≤ bound a) (h_lim : ∀ᵐ (a : α) ∂μ, filter.tendsto (λ (n : ℕ), fs n a) filter.at_top (nhds (f a))) : filter.tendsto (λ (n : ℕ), measure_theory.set_to_fun μ T hT (fs n)) filter.at_top (nhds (measure_theory.set_to_fun μ T hT f))
{σ : Type} {α : Type u} (state : σ) (tac : interaction_monad σ α) : interaction_monad σ α
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ' : Type u_6} {δ : Type u_7} {ε : Type u_9} [decidable_eq β'] [decidable_eq γ'] [decidable_eq δ] [decidable_eq ε] {s : finset α} {t : finset β} {γ : Type u_2} {u : finset γ} {f : α → δ → ε} {g : β → γ → δ} {f₁ : α → β → β'} {f₂ : α → γ → γ'} {g' : β' → γ' → ε} (h_distrib : ∀ (a : α) (b : β) (c : γ), f a (g b c) = g' (f₁ a b) (f₂ a c)) : finset.image₂ f s (finset.image₂ g t u) ⊆ finset.image₂ g' (finset.image₂ f₁ s t) (finset.image₂ f₂ s u)
{α : Sort u₁} {β : Sort u₂} {φ : Sort u₃} (f : β → β → φ) (g : α → β) : α → α → φ
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] (c : category_theory.limits.cofork I.fst_sigma_map I.snd_sigma_map) : category_theory.limits.multicofork I
{E : Type u} [normed_group E] [normed_space ℂ E] {F : Type v} [normed_group F] [normed_space ℂ F] {f : E → F} {c : E} (hd : ∀ᶠ (z : E) in nhds c, differentiable_at ℂ f z) (hc : is_local_max (has_norm.norm ∘ f) c) : ∀ᶠ (y : E) in nhds c, ∥f y∥ = ∥f c∥
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h : (λ (n : ℕ), ∥p n∥ * ↑r ^ n) =O[filter.at_top] λ (n : ℕ), 1) : ↑r ≤ p.radius
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {c : ℝ} {f : α → E} {g' : α → F'} {l : filter α} : asymptotics.is_O_with c l f g' → asymptotics.is_O_with c l f (λ (x : α), ∥g' x∥)
(ι : Type uι) {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] (I : model_with_corners ℝ E H) (M : Type uM) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (s : set M := set.univ) : Type (max uM uι)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ⟶ Y} {W : C} (g : Y ⟶ W) (h : X ⟶ W) {c : category_theory.limits.kernel_fork h} (i : category_theory.limits.is_limit c) (hf : category_theory.limits.fork.ι c ≫ f = 0) (hfg : f ≫ g = h) : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_ι (category_theory.limits.fork.ι c) hf)
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i * g i) ≤ s.sum (λ (i : ι), f i * g (⇑σ i))
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] [smooth_manifold_with_corners I M] [smooth_manifold_with_corners I' M'] (f : M → M') (x : M) : tangent_space I x →L[𝕜] tangent_space I' (f x)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {s : set M} {n : with_top ℕ} : cont_mdiff_on I I' n f s ↔ continuous_on f s ∧ ∀ (y : M'), cont_mdiff_on I (model_with_corners_self 𝕜 E') n (⇑(ext_chart_at I' y) ∘ f) (s ∩ f ⁻¹' (ext_chart_at I' y).source)
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (f : module.End K V) (μ : K) {k : ℕ} (hk : finite_dimensional.finrank K V ≤ k) : ⇑(f.generalized_eigenspace μ) k = ⇑(f.generalized_eigenspace μ) (finite_dimensional.finrank K V)
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.prepartition I) (πi : Π (J : box_integral.box ι), box_integral.prepartition J) (J : box_integral.box ι) : box_integral.box ι
{C : Type u} [category_theory.category C] {I : category_theory.limits.multispan_index C} [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] (K : category_theory.limits.multicofork I) : category_theory.limits.cofork I.fst_sigma_map I.snd_sigma_map
{α : Type u_2} {_x : measurable_space α} (μ : measure_theory.measure α) : Prop
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g i) < s.sum (λ (i : ι), f (⇑σ i) • g i) ↔ ¬antivary_on (f ∘ ⇑σ) g ↑s
{I : Type u} {f : I → Type v} {α : Type u_1} [Π (i : I), has_scalar α (f i)] [∀ (i : I), nonempty (f i)] (i : I) [has_faithful_smul α (f i)] : has_faithful_smul α (Π (i : I), f i)
{β : Type v} {π : β → Type u_1} [fintype β] [Π (b : β), emetric_space (π b)] : emetric_space (Π (b : β), π b)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) : cont_diff_groupoid 0 I = continuous_groupoid H
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f (⇑σ i) * g i) = finset.univ.sum (λ (i : ι), f i * g i) ↔ antivary (f ∘ ⇑σ) g
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] (W : subspace K V) : module.dual K ↥W →ₗ[K] module.dual K V
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] ⦃A B : GL n R⦄ (h : ∀ (i j : n), ↑A i j = ↑B i j) : A = B
(s : simp_lemmas) (e : expr) (prove : tactic unit := tactic.failed) (r : name := name.mk_string "eq" name.anonymous) (md : tactic.transparency := tactic.transparency.reducible) : tactic (expr × expr)
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [normed_group E] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite ν] ⦃f : α → β → E⦄ (hf : measure_theory.strongly_measurable (function.uncurry f)) : measure_theory.strongly_measurable (λ (x : α), ∫ (y : β), f x y ∂ν)
{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜] : galois_connection (λ (I : ideal A), projective_spectrum.zero_locus 𝒜 ↑I) (λ (t : (set (projective_spectrum 𝒜))ᵒᵈ), (projective_spectrum.vanishing_ideal t).to_ideal)
(attr_name c_name : name) (persistent : bool := bool.ff) (prio : option ℕ := option.none) : tactic unit
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {E : Type u_5} [normed_group E] [normed_space ℝ E] {f : α → nnreal} (f_meas : measurable f) : ↥(measure_theory.Lp E 1 (μ.with_density (λ (x : α), ↑(f x)))) →ₗᵢ[ℝ] ↥(measure_theory.Lp E 1 μ)
{α : Type u_1} [topological_space α] (dist : α → α → ℝ) (dist_self : ∀ (x : α), dist x x = 0) (dist_comm : ∀ (x y : α), dist x y = dist y x) (dist_triangle : ∀ (x y z : α), dist x z ≤ dist x y + dist y z) (H : ∀ (s : set α), is_open s ↔ ∀ (x : α), x ∈ s → (∃ (ε : ℝ) (H : ε > 0), ∀ (y : α), dist x y < ε → y ∈ s)) : pseudo_metric_space α
{F : Type u_3} [inner_product_space ℝ F] {x y : F} : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ - 2 * has_inner.inner x y + ∥y∥ * ∥y∥
{α : Type u_1} {γ : Type u_3} [measurable_space α] {μ : measure_theory.measure α} [topological_space γ] [linear_order γ] [order_closed_topology γ] [has_zero γ] (f : α →ₘ[μ] γ) : α →ₘ[μ] γ
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_multiequalizer I] [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] : category_theory.limits.multiequalizer I ⟶ ∏ I.left
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} (p : ennreal) (μ : measure_theory.measure α) [normed_group E] [topological_space α] [borel_space α] [second_countable_topology_either α E] [measure_theory.is_finite_measure μ] [fact (1 ≤ p)] : normed_group_hom (bounded_continuous_function α E) ↥(measure_theory.Lp E p μ)
{α : Type u_1} {E : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] {m : measurable_space α} {μ : measure_theory.measure α} {ι : Type u_3} {f : α → E} (hf : measure_theory.has_finite_integral f μ) {l : filter ι} {s : ι → set α} (hs : filter.tendsto (⇑μ ∘ s) l (nhds 0)) : filter.tendsto (λ (i : ι), ∫ (x : α) in s i, f x ∂μ) l (nhds 0)
(e t : expr) (md : tactic.transparency := tactic.transparency.reducible) : tactic bool
{G : Type u_1} [group G] [measurable_space G] [topological_space G] [locally_compact_space G] (μ : measure_theory.measure G) [μ.is_haar_measure] : measure_theory.is_locally_finite_measure μ
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] (f : E →ₛₗ[σ₁₂] F) (hf : continuous ⇑f) : ∃ (C : ℝ), 0 < C ∧ ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥
{α : Type u_1} {E : Type u_4} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} (f : ↥(measure_theory.Lp.simple_func E p μ)) : measure_theory.mem_ℒp ⇑(measure_theory.Lp.simple_func.to_simple_func f) p μ
{α : Type u_1} {m0 : measurable_space α} (μ : measure_theory.measure α) (s : set α) : measure_theory.measure α
{α : Type u_1} {F : Type u_4} [measurable_space α] {𝕜 : Type u_5} [normed_field 𝕜] [normed_group F] [normed_space 𝕜 F] {p : ennreal} {μ : measure_theory.measure α} (c : 𝕜) (f : ↥(measure_theory.Lp F p μ)) (s : set α) : measure_theory.mem_ℒp.to_Lp ⇑(c • f) _ = c • measure_theory.mem_ℒp.to_Lp ⇑f _
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : ℕ → α → ennreal} (h_meas : ∀ (n : ℕ), measurable (f n)) (h_anti : antitone f) (h_fin : ∫⁻ (a : α), f 0 a ∂μ ≠ ⊤) : ∫⁻ (a : α), (⨅ (n : ℕ), f n a) ∂μ = ⨅ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
{α : Type u_1} [measurable_space α] [pseudo_emetric_space α] [opens_measurable_space α] (μ : measure_theory.finite_measure α) {F : set α} (F_closed : is_closed F) {δs : ℕ → ℝ} (δs_pos : ∀ (n : ℕ), 0 < δs n) (δs_lim : filter.tendsto δs filter.at_top (nhds 0)) : filter.tendsto (λ (n : ℕ), ∫⁻ (a : α), ↑(⇑(thickened_indicator _ F) a) ∂↑μ) filter.at_top (nhds (⇑↑μ F))
{α : Type u_1} {β : α → Type u_2} {R : Π (x : α), β x → Prop} [Π (a : α), encodable (β a)] [Π (x : α) (y : β x), decidable (R x y)] (H : ∀ (x : α), ∃ (y : β x), R x y) : ∃ (f : Π (a : α), β a), ∀ (x : α), R x (f x)
{J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {t : category_theory.limits.cocone F} (h : category_theory.limits.is_colimit t) (W : C) : ulift (t.X ⟶ W) ≅ {p // ∀ {j j' : J} (f : j ⟶ j'), F.map f ≫ p j' = p j}
{φ : Sort u_1} (d₁ d₂ : many_one_degree) (f : set ℕ → set ℕ → φ) (h : ∀ (p₁ p₂ q₁ q₂ : ℕ → Prop), many_one_equiv p₁ p₂ → many_one_equiv q₁ q₂ → f p₁ q₁ = f p₂ q₂) : φ
{α : Type u_1} {ι : Type u_2} [measurable_space α] (π : ι → set (set α)) (μ : measure_theory.measure α . "volume_tac") : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ⟶ Y} {c : category_theory.limits.cokernel_cofork f} (i : category_theory.limits.is_colimit c) {W : C} (g : W ⟶ X) [hg : category_theory.epi g] {h : W ⟶ Y} (hh : h = g ≫ f) : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_π (category_theory.limits.cofork.π c) _)
{F : Type u_3} [inner_product_space ℝ F] {x : F} {r : ℝ} (hx : x ≠ 0) (hr : r ≠ 0) : |has_inner.inner x (r • x)| / (∥x∥ * ∥r • x∥) = 1
{α : Type u} {β : Type v} {φ : ultrafilter α} [linear_ordered_comm_ring β] : linear_ordered_comm_ring (↑φ.germ β)
{α : Type u_1} [topological_space α] {m : measurable_space α} [topological_space.second_countable_topology α] [linear_order α] [order_topology α] [borel_space α] [no_min_order α] (μ ν : measure_theory.measure α) (hμ : ∀ ⦃a b : α⦄, a < b → ⇑μ (set.Ioc a b) ≠ ⊤) (h : ∀ ⦃a b : α⦄, a < b → ⇑μ (set.Ioc a b) = ⇑ν (set.Ioc a b)) : μ = ν
{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} (Hf : monotone f) {s : set α} : bdd_above s → bdd_above (f '' s)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} {I : category_theory.InjectiveResolution Y} {J : category_theory.InjectiveResolution Z} (f : I.cocomplex ⟶ J.cocomplex) (n : ℕ) (g : I.cocomplex.X (n + 1) ⟶ J.cocomplex.X n) (g' : I.cocomplex.X (n + 2) ⟶ J.cocomplex.X (n + 1)) (w : f.f (n + 1) = I.cocomplex.d (n + 1) (n + 2) ≫ g' + g ≫ J.cocomplex.d n (n + 1)) : I.cocomplex.X (n + 3) ⟶ J.cocomplex.X (n + 2)
{U : Type u_1} [quiver U] {V : Type u_3} [quiver V] {W : Type u_5} [quiver W] (F : prefunctor U V) (G : prefunctor V W) : prefunctor U W
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] (F : V ⥤ W) [F.additive] (h : homotopy_equiv C D) : homotopy_equiv ((F.map_homological_complex c).obj C) ((F.map_homological_complex c).obj D)
{α : Type u_1} [preorder α] [succ_order α] [is_succ_archimedean α] {P : α → Prop} {m : α} (h0 : P m) (h1 : ∀ (n : α), m ≤ n → P n → P (order.succ n)) ⦃n : α⦄ (hmn : m ≤ n) : P n
{R : Type u} {ι : Type x} [semiring R] {φ : ι → Type i} [Π (i : ι), add_comm_monoid (φ i)] [Π (i : ι), module R (φ i)] [decidable_eq ι] (i j : ι) : φ i →ₗ[R] φ j
{α : Type u} {σ : Type v} (M : ε_NFA α σ) (start : set σ) : list α → set σ
{R : Type u_1} [comm_ring R] (I : ideal R) {M : Type u_2} [add_comm_group M] [module R M] {N : Type u_3} [add_comm_group N] [module R N] [h : is_Hausdorff I N] (f : M →ₗ[R] N) (g : Hausdorffification I M →ₗ[R] N) (hg : g.comp (Hausdorffification.of I M) = f) : g = Hausdorffification.lift I f
{F : Type u_3} [inner_product_space ℝ F] {x : F} {r : ℝ} (hx : x ≠ 0) (hr : r < 0) : has_inner.inner x (r • x) / (∥x∥ * ∥r • x∥) = -1
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {n : with_top ℕ} {E'' : Type u_14} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {t : set M'} {g : M' → M''} (x : M) (hg : cont_mdiff_within_at I' I'' n g t (f x)) (hf : cont_mdiff_within_at I I' n f s x) (st : set.maps_to f s t) : cont_mdiff_within_at I I'' n (g ∘ f) s x
{α : Type u} {β : Type v} [pseudo_metric_space α] [nonempty β] [semilattice_sup β] [no_max_order β] {u : β → α} {a : α} : filter.tendsto u filter.at_top (nhds a) ↔ ∀ (ε : ℝ), ε > 0 → (∃ (N : β), ∀ (n : β), n > N → has_dist.dist (u n) a < ε)
{p : ℕ+} {k : ℕ} {K : Type u} [field K] [char_zero K] {ζ : K} [hp : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ (k + 1)} ℚ K] (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) (hk : p ^ (k + 1) ≠ 2) : algebra.discr ℚ ⇑((is_primitive_root.sub_one_power_basis ℚ hζ).basis) = (-1) ^ ((↑p ^ (k + 1)).totient / 2) * ↑p ^ (↑p ^ k * ((↑p - 1) * (k + 1) - 1))
{α : Type u_1} [metric_space α] [topological_space.second_countable_topology α] [measurable_space α] [opens_measurable_space α] (μ : measure_theory.measure α) [measure_theory.is_finite_measure μ] {N : ℕ} {τ : ℝ} (hτ : 1 < τ) (hN : is_empty (besicovitch.satellite_config α N τ)) (s : set α) (r : α → ℝ) (rpos : ∀ (x : α), x ∈ s → 0 < r x) (rle : ∀ (x : α), x ∈ s → r x ≤ 1) : ∃ (t : finset α), ↑t ⊆ s ∧ ⇑μ (s  ⋃ (x : α) (H : x ∈ t), metric.closed_ball x (r x)) ≤ ↑N / (↑N + 1) * ⇑μ s ∧ ↑t.pairwise_disjoint (λ (x : α), metric.closed_ball x (r x))
(G : Type u_1) {α : Type u_3} {m : measurable_space α} [add_group G] [add_action G α] [measurable_space G] [has_measurable_vadd G α] {μ : measure_theory.measure α} [measure_theory.vadd_invariant_measure G α μ] [topological_space α] [has_continuous_const_vadd G α] [add_action.is_minimal G α] {K U : set α} (hK : is_compact K) (hμK : ⇑μ K ≠ 0) (hU : is_open U) (hne : U.nonempty) : 0 < ⇑μ U
{𝕜 : Type u_1} [normed_field 𝕜] [complete_space 𝕜] {r : 𝕜} (hr : ∥r∥ < 1) : has_sum (λ (n : ℕ), ↑n * r ^ n) (r / (1 - r) ^ 2)
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] [normed_group F] [normed_space ℝ F] [complete_space F] {f : E → F} {φ : E → ℝ} {x₀ : E} {f' : E →L[ℝ] F} {φ' : E →L[ℝ] ℝ} (hextr : is_local_extr_on φ {x : E | f x = f x₀} x₀) (hf' : has_strict_fderiv_at f f' x₀) (hφ' : has_strict_fderiv_at φ φ' x₀) : ∃ (Λ : module.dual ℝ F) (Λ₀ : ℝ), (Λ, Λ₀) ≠ 0 ∧ ∀ (x : E), ⇑Λ (⇑f' x) + Λ₀ • ⇑φ' x = 0
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : ⇑is_R_or_C.re (has_inner.inner x y) = (∥x + y∥ * ∥x + y∥ - ∥x - y∥ * ∥x - y∥) / 4
{f : ℝ → ℝ} (hf' : differentiable ℝ f) (hf'' : ∀ (x : ℝ), deriv^[2] f x < 0) : strict_concave_on ℝ set.univ f
{ι : Type u_1} {E : Type u_3} [normed_group E] {f : ℝ → E} {μ : measure_theory.measure ℝ} {l l' : filter ℝ} (hfm : strongly_measurable_at_filter f l' μ) [filter.tendsto_Ixx_class set.Ioc l l'] [l'.is_measurably_generated] (hμ : μ.finite_at_filter l') {c : E} (hf : filter.tendsto f (l' ⊓ μ.ae) (nhds c)) {u v : ι → ℝ} {lt : filter ι} (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : ∀ᶠ (t : ι) in lt, interval_integrable f μ (u t) (v t)
{α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} : μ.ae ≤ ν.ae → μ.absolutely_continuous ν
{α : Type u} {β : Type v} [pseudo_emetric_space α] {ι : Type u_1} [topological_space β] {F : ι → β → α} {f : β → α} {p : filter ι} : tendsto_locally_uniformly F f p ↔ ∀ (ε : ennreal), ε > 0 → ∀ (x : β), ∃ (t : set β) (H : t ∈ nhds x), ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → has_edist.edist (f y) (F n y) < ε
{J : Type u₁} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ⥤ C) [category_theory.limits.has_colimit F] (W : C) : ulift (category_theory.limits.colimit F ⟶ W) ≅ {p // ∀ {j j' : J} (f : j ⟶ j'), F.map f ≫ p j' = p j}
{R : Type u} [comm_ring R] (I : ideal R) (s : set R) : ⇑(ideal.quotient.mk I) ⁻¹' (⇑(ideal.quotient.mk I) '' s) = ⋃ (x : ↥I), (λ (y : R), x.val + y) '' s
{σ : Type u_1} {R : Type u_2} [ring R] (φ : mv_power_series σ R) (u : Rˣ) : mv_power_series σ R
{c : Type u → Type u} (hom : Π ⦃α β : Type u⦄, c α → c β → Type u) {d : Type u → Type u} (F : Π {α : Type u}, d α → c α) ⦃α β : Type u⦄ (Iα : d α) (Iβ : d β) : Type u
{R : Type u} [comm_ring R] (I : ideal R) (ι : Type v) : ((ι → R) ⧸ I.pi ι) ≃ₗ[R ⧸ I] ι → R ⧸ I
{α : Type u_1} {β : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : α → M} {s : set β} {g : β → α} (hg : set.inj_on g s) : finsum (λ (i : α), finsum (λ (H : i ∈ g '' s), f i)) = finsum (λ (j : β), finsum (λ (H : j ∈ s), f (g j)))
(σ : Type u) (R : Type v) [comm_ring R] : basis (σ →₀ ℕ) R (mv_polynomial σ R)
{c : Type u → Type u} (hom : Π ⦃α β : Type u⦄, c α → c β → Type u) [𝒞 : category_theory.bundled_hom hom] {d : Type u → Type u} (F : Π {α : Type u}, d α → c α) : category_theory.bundled_hom (category_theory.bundled_hom.map_hom hom F)
{P : ℕ → Sort u_1} (h0 : P 0) (hp : Π (p n : ℕ), nat.prime p → P (p ^ n)) (h : Π (a b : ℕ), 1 < a → 1 < b → a.coprime b → P a → P b → P (a * b)) (a : ℕ) : P a
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X ⟶ Y) (g : X ⟶ Z) (h : W ⟶ X) [category_theory.epi h] [category_theory.limits.has_pushout f g] : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk category_theory.limits.pushout.inl category_theory.limits.pushout.inr _)
{σ : Type u_1} {R : Type u_2} [comm_semiring R] : has_coe (mv_polynomial σ R) (mv_power_series σ R)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_4} [normed_group F] [normed_space 𝕜 F] {H : Type u_5} [topological_space H] {G : Type u_7} [topological_space G] {I : model_with_corners 𝕜 E H} {J : model_with_corners 𝕜 F G} {M : Type u_8} [topological_space M] [charted_space H M] {N : Type u_10} [topological_space N] [charted_space G N] {n : with_top ℕ} (h : diffeomorph I J M N n) : M ≃ₜ N
{R : Type u_1} {M : Type u_5} [comm_ring R] [add_comm_group M] [module R M] {B : M →ₗ[R] M →ₗ[R] R} (hB : B.is_refl) {W : submodule R M} (hW : disjoint W (W.orthogonal_bilin B)) : (B.dom_restrict₁₂ W W).nondegenerate
{R : Type u_1} [comm_ring R] (I : ideal R) (n : ℕ) : open_add_subgroup R
{α : Type u} {σ : Type v} (M : ε_NFA α σ) : NFA α σ
⦃J : Type u⦄ (F : J → category_theory.Groupoid) : category_theory.limits.fan F
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} {σ : Type u_4} [inhabited Λ] [inhabited σ] (k : K) (L : list (Γ k)) : turing.TM2.cfg Γ Λ σ
{I : Type w₀} (C : I → Type u₁) [Π (i : I), category_theory.category (C i)] {J : Type w₁} (h : J → I) (j : J) : category_theory.pi.comap C h ⋙ category_theory.pi.eval (C ∘ h) j ≅ category_theory.pi.eval C (h j)
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group β] {p : ennreal} {f : ι → α → β} [fintype ι] (hp_one : 1 ≤ p) (hp_top : p ≠ ⊤) (hf : ∀ (i : ι), measure_theory.strongly_measurable (f i)) (hf' : ∀ (i : ι), measure_theory.mem_ℒp (f i) p μ) : measure_theory.uniform_integrable f p μ
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) ⦃ι : Type v⦄ (U : ι → topological_space.opens ↥X) (c : category_theory.limits.cone ((category_theory.pairwise.diagram U).op ⋙ F)) : (𝟭 (category_theory.limits.cone ((category_theory.pairwise.diagram U).op ⋙ F))).obj c ≅ (Top.presheaf.sheaf_condition_pairwise_intersections.cone_equiv_functor F U ⋙ Top.presheaf.sheaf_condition_pairwise_intersections.cone_equiv_inverse F U).obj c
(reduce_semi only_on : bool) (hyps : list pexpr) (cfg : linarith.linarith_config := {discharger := has_bind.seq (tactic.save_info {line := 312, column := 31}) (tactic.interactive.ring option.none).step, restrict_type := option.none Type, restrict_type_reflect := `(option.none Type), exfalso := bool.tt, transparency := tactic.transparency.reducible, split_hypotheses := bool.tt, split_ne := bool.ff, preprocessors := option.none (list linarith.global_branching_preprocessor), oracle := option.none linarith.certificate_oracle}) : tactic unit
{ι : Type u} {E : Type v} [normed_group E] [normed_space ℝ E] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {g : (ι → ℝ) → ℝ} (hle : ∀ (x : ι → ℝ), x ∈ ⇑box_integral.box.Icc I → ∥f x∥ ≤ g x) (μ : measure_theory.measure (ι → ℝ)) [measure_theory.is_locally_finite_measure μ] (hg : box_integral.integrable I l g μ.to_box_additive.to_smul) : ∥box_integral.integral I l f μ.to_box_additive.to_smul∥ ≤ box_integral.integral I l g μ.to_box_additive.to_smul
(e : expr) (timeout : ℕ := 1000) : tactic expr
{I : Type u} {f : I → Type v₁} [decidable_eq I] [Π (i : I), has_one (f i)] {i i' : I} (h : i ≠ i') (x : f i) : pi.mul_single i x i' = 1
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ⥤ D) [F.initial] {d : D} (Z : Π (X : C), (F.obj X ⟶ d) → Sort u_1) (h₁ : Π (X₁ X₂ : C) (k₁ : F.obj X₁ ⟶ d) (k₂ : F.obj X₂ ⟶ d) (f : X₁ ⟶ X₂), F.map f ≫ k₂ = k₁ → Z X₁ k₁ → Z X₂ k₂) (h₂ : Π (X₁ X₂ : C) (k₁ : F.obj X₁ ⟶ d) (k₂ : F.obj X₂ ⟶ d) (f : X₁ ⟶ X₂), F.map f ≫ k₂ = k₁ → Z X₂ k₂ → Z X₁ k₁) {X₀ : C} {k₀ : F.obj X₀ ⟶ d} (z : Z X₀ k₀) : Z (category_theory.functor.initial.lift F d) (category_theory.functor.initial.hom_to_lift F d)
{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} (Hf : monotone f) {a : α} {s : set α} (Ha : is_greatest s a) : is_greatest (f '' s) (f a)
{R : Type u_1} [comm_ring R] {I J : ideal R} (h : I = J) : R ⧸ I ≃+* R ⧸ J
{α : Type u_1} [metric_space α] {m : measurable_space α} (μ : measure_theory.measure α) : Type u_1
{R₁ : Type u_3} {M₁ : Type u_4} [ring R₁] [add_comm_group M₁] [module R₁ M₁] (B : bilin_form R₁ M₁) (b : B.is_refl) {W : submodule R₁ M₁} (hW : disjoint W (B.orthogonal W)) : (B.restrict W).nondegenerate
{α : Type u_1} [metric_space α] [topological_space.second_countable_topology α] [measurable_space α] [opens_measurable_space α] [has_besicovitch_covering α] (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] (f : α → set ℝ) (s : set α) (hf : ∀ (x : α), x ∈ s → ∀ (δ : ℝ), δ > 0 → (f x ∩ set.Ioo 0 δ).nonempty) (R : α → ℝ) (hR : ∀ (x : α), x ∈ s → 0 < R x) : ∃ (t : set α) (r : α → ℝ), t.countable ∧ t ⊆ s ∧ (∀ (x : α), x ∈ t → r x ∈ f x ∩ set.Ioo 0 (R x)) ∧ ⇑μ (s  ⋃ (x : α) (H : x ∈ t), metric.closed_ball x (r x)) = 0 ∧ t.pairwise_disjoint (λ (x : α), metric.closed_ball x (r x))
(x : ℝ) (h1 : 0 < x) (h2 : x ≤ 1) : |real.log x * x| < 1
{G : Type w} [topological_space G] (μ : measure_theory.content G) ⦃U V : set G⦄ (hU : is_open U) (hV : is_open V) (h2 : U ⊆ V) : μ.inner_content ⟨U, hU⟩ ≤ μ.inner_content ⟨V, hV⟩
{α : Type u} {β : Type v} [group α] [mul_action α β] (U : set β) : quotient.mk ⁻¹' (quotient.mk '' U) = ⋃ (a : α), has_scalar.smul a '' U
{σ : Type u_1} {τ : Type u_2} {R : Type u_3} [comm_semiring R] (f : σ → mv_polynomial τ R) : mv_polynomial σ R →ₐ[R] mv_polynomial τ R
{E : Type u_1} [normed_group E] [normed_space ℂ E] [complete_space E] {f f' : ℂ → E} {c : ℂ} {R : ℝ} (h : ∀ (z : ℂ), z ∈ metric.sphere c |R| → has_deriv_within_at f (f' z) (metric.sphere c |R|) z) : ∮ (z : ℂ) in C(c, R), f' z = 0
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [measurable_space β] (f : β → ennreal) (g : α ≃ᵐ β) : ∫⁻ (a : β), f a ∂measure_theory.measure.map ⇑g μ = ∫⁻ (a : α), f (⇑g a) ∂μ
{α : Type u_1} {β : Type u_2} [conditionally_complete_lattice β] {m : measurable_space α} (f : α → β) (μ : measure_theory.measure α) : β
{I : Type u} {f : I → Type v₁} [decidable_eq I] [Π (i : I), has_zero (f i)] (i : I) (x : f i) (i_1 : I) : f i_1
{f : ℝ → ℝ} (hf : differentiable ℝ f) {C : ℝ} (le_hf' : ∀ (x : ℝ), deriv f x ≤ C) ⦃x y : ℝ⦄ (hxy : x ≤ y) : f y - f x ≤ C * (y - x)
{ι : Type u} {E : Type v} [fintype ι] [normed_group E] [normed_space ℝ E] (l : box_integral.integration_params) (hl : l.bRiemann = bool.ff) {s : set (ι → ℝ)} (hs : measurable_set s) (I : box_integral.box ι) (y : E) (μ : measure_theory.measure (ι → ℝ)) [measure_theory.is_locally_finite_measure μ] : box_integral.has_integral I l (s.indicator (λ (_x : ι → ℝ), y)) μ.to_box_additive.to_smul ((⇑μ (s ∩ ↑I)).to_real • y)
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} [inhabited Λ] {σ : Type u_4} [inhabited σ] {k : K} (q : turing.TM1.stmt turing.TM2to1.Γ' turing.TM2to1.Λ' σ) : turing.TM2to1.st_act k → turing.TM1.stmt turing.TM2to1.Γ' turing.TM2to1.Λ' σ
{C : Type u} [category_theory.category C] {W X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} [category_theory.limits.has_pullback f g] (h : W ⟶ X) (k : W ⟶ Y) (w : h ≫ f = k ≫ g) : W ⟶ category_theory.limits.pullback f g
{I : Type v₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {J : Type v₁} [category_theory.small_category J] {F : J ⥤ Π (i : I), C i} {c : Π (i : I), category_theory.limits.cocone (F ⋙ category_theory.pi.eval C i)} (P : Π (i : I), category_theory.limits.is_colimit (c i)) : category_theory.limits.is_colimit (category_theory.pi.cocone_of_cocone_comp_eval c)
{E : Type u_1} [inner_product_space ℝ E] {c : E} (f : cont_diff_bump_of_inner c) [measurable_space E] (μ : measure_theory.measure E) : E → ℝ
{ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} [t2_space M] {f : smooth_bump_covering ι I M s} {U : M → set M} : f.is_subordinate U → f.to_bump_covering.is_subordinate (λ (i : ι), U (f.c i))
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} {g : E → ℝ} [measure_theory.is_probability_measure μ] (hg : convex_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) (hgi : measure_theory.integrable (g ∘ f) μ) : g (∫ (x : α), f x ∂μ) ≤ ∫ (x : α), g (f x) ∂μ
{E : Type u_3} [normed_group E] {f : ℝ → E} {a b : ℝ} {μ : measure_theory.measure ℝ} (hf : measure_theory.integrable f μ) : interval_integrable f μ a b
{p : ℕ+} {k : ℕ} {K : Type u} [field K] [char_zero K] {ζ : K} [hp : fact (nat.prime ↑p)] [hcycl : is_cyclotomic_extension {p ^ k} ℚ K] (hζ : is_primitive_root ζ ↑(p ^ k)) : is_integral_closure ↥(algebra.adjoin ℤ {ζ}) ℤ K
{α : Type u} [linear_ordered_add_comm_group α] {a b x y : α} (h : set.interval x y ⊆ set.interval a b) : |y - x| ≤ |b - a|
{n : ℕ} {K : Type u_8} [field K] {μ : K} (h : is_primitive_root μ n) [char_zero K] {p : ℕ} [hprime : fact (nat.prime p)] (hdiv : ¬p ∣ n) : minpoly ℤ μ = minpoly ℤ (μ ^ p)
{S : Type u₁} {L : Type u₂} {D : Type u₃} [category_theory.category S] [category_theory.category L] [category_theory.category D] (ι : S ⥤ L) (F : S ⥤ D) [I : ∀ (x : L), category_theory.limits.has_colimit (category_theory.Lan.diagram ι F x)] (G : L ⥤ D) : (category_theory.Lan.loc ι F ⟶ G) ≃ (F ⟶ ((category_theory.whiskering_left S L D).obj ι).obj G)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {x₀ : E} (hf : differentiable_at 𝕜 f x₀) {s : set E} (hs : s ∈ nhds x₀) {C : nnreal} (hlip : lipschitz_on_with C f s) : ∥fderiv 𝕜 f x₀∥ ≤ ↑C
{C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] (f : X ⟶ Y) [category_theory.limits.has_kernel f] {W : C} (h : W ⟶ X) (w : h ≫ f = 0) : W ⟶ ↑(category_theory.limits.kernel_subobject f)
(M : Type u_4) (α : Type u_5) [has_scalar M α] {_x : measurable_space α} (μ : measure_theory.measure α) : Prop
{α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} {S : set (set α)} (hc : S.countable) (hs : ⋃₀S = set.univ) : μ = ν ↔ ∀ (s : set α), s ∈ S → μ.restrict s = ν.restrict s
{ι : Type u_1} {α : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [encodable ι] {s : ι → set α} (hd : pairwise (measure_theory.ae_disjoint μ on s)) : ∃ (t : ι → set α), (∀ (i : ι), measurable_set (t i)) ∧ (∀ (i : ι), ⇑μ (t i) = 0) ∧ pairwise (disjoint on λ (i : ι), s i  t i)
{V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (h : ∥x∥ = ∥y∥) : x = y ↔ o.oangle x y = 0
{α : Sort u_1} {s₁ : setoid α} {φ : quotient s₁ → Sort u_2} [h : ∀ (a : α), subsingleton (φ ⟦a⟧)] (q : quotient s₁) (f : Π (a : α), φ (quotient.mk' a)) : φ q
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {W X Y : C} [category_theory.limits.has_binary_biproduct X Y] (f : W ⟶ X) (g : W ⟶ Y) : W ⟶ X ⊞ Y
{c : Type u → Type u} (hom : Π ⦃α β : Type u⦄, c α → c β → Type u) : Type (u+1)
{G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {μ : measure_theory.measure G} [add_group G] [topological_add_group G] [μ.is_add_left_invariant] [μ.regular] (h₀ : μ ≠ 0) : μ.is_open_pos_measure
{α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {f : α → β} (hf : measure_theory.mem_ℒp f 1 μ) (hmeas : measure_theory.strongly_measurable f) {ε : ℝ} (hε : 0 < ε) : ∃ (M : ℝ), ∫⁻ (x : α), ↑∥{x : α | M ≤ ↑∥f x∥₊}.indicator f x∥₊ ∂μ ≤ ennreal.of_real ε
{n : ℕ} {β : Type u_1} [comm_monoid β] (f : ℕ → β) : n.factorization.prod (λ (p k : ℕ), f p) = n.factors.to_finset.prod (λ (p : ℕ), f p)
{E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y : E} (h : ¬same_ray ℝ x y) : ∥x + y∥ < ∥x∥ + ∥y∥
{ι : Type v} [dec_ι : decidable_eq ι] [preorder ι] {G : ι → Type w} [Π (i : ι), add_comm_group (G i)] {f : Π (i j : ι), i ≤ j → G i →+ G j} [is_directed ι has_le.le] [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] (i : ι) (x : G i) (h : ⇑(add_comm_group.direct_limit.of G f i) x = 0) : ∃ (j : ι) (hij : i ≤ j), ⇑(f i j hij) x = 0
{𝕜 : Type u_1} [is_R_or_C 𝕜] {μ : measure_theory.measure ℝ} {E : Type u_2} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {a b ε : ℝ} {bound : ℝ → ℝ} {F : 𝕜 → ℝ → E} {F' : ℝ → E} {x₀ : 𝕜} (ε_pos : 0 < ε) (hF_meas : ∀ᶠ (x : 𝕜) in nhds x₀, measure_theory.ae_strongly_measurable (F x) (μ.restrict (set.interval_oc a b))) (hF_int : interval_integrable (F x₀) μ a b) (hF'_meas : measure_theory.ae_strongly_measurable F' (μ.restrict (set.interval_oc a b))) (h_lipsch : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → lipschitz_on_with (⇑real.nnabs (bound t)) (λ (x : 𝕜), F x t) (metric.ball x₀ ε)) (bound_integrable : interval_integrable bound μ a b) (h_diff : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → has_deriv_at (λ (x : 𝕜), F x t) (F' t) x₀) : interval_integrable F' μ a b ∧ has_deriv_at (λ (x : 𝕜), ∫ (t : ℝ) in a..b, F x t ∂μ) (∫ (t : ℝ) in a..b, F' t ∂μ) x₀
(cfg : tactic.apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}) : state_t tactic.ext_state tactic unit
{α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} {μ : measure_theory.measure α} [fact (1 ≤ p)] [normed_space ℝ F] (hm : m ≤ m0) (hp_ne_top : p ≠ ⊤) (P : ↥(measure_theory.Lp F p μ) → Prop) (h_ind : ∀ (c : F) {s : set α} (hs : measurable_set s) (hμs : ⇑μ s < ⊤), P ↑(measure_theory.Lp.simple_func.indicator_const p _ _ c)) (h_add : ∀ ⦃f g : α → F⦄ (hf : measure_theory.mem_ℒp f p μ) (hg : measure_theory.mem_ℒp g p μ), measure_theory.ae_strongly_measurable' m f μ → measure_theory.ae_strongly_measurable' m g μ → disjoint (function.support f) (function.support g) → P (measure_theory.mem_ℒp.to_Lp f hf) → P (measure_theory.mem_ℒp.to_Lp g hg) → P (measure_theory.mem_ℒp.to_Lp f hf + measure_theory.mem_ℒp.to_Lp g hg)) (h_closed : is_closed {f : ↥(measure_theory.Lp_meas F ℝ m p μ) | P ↑f}) (f : ↥(measure_theory.Lp F p μ)) : measure_theory.ae_strongly_measurable' m ⇑f μ → P f
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_10} [semi_normed_group E'] [normed_space 𝕜 E'] [ring_hom_isometric σ₁₂] (f₀ : E' →SL[σ₁₂] F) (r : ℝ) ⦃f : E' →SL[σ₁₂] F⦄ (hf : ⇑f ∈ closure (coe_fn '' metric.closed_ball f₀ r)) : f ∈ metric.closed_ball f₀ r
{E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {a b C : ℝ} (hf : differentiable_on ℝ f (set.Icc a b)) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥deriv_within f (set.Icc a b) x∥ ≤ C) (x : ℝ) (H : x ∈ set.Icc a b) : ∥f x - f a∥ ≤ C * (x - a)
{L : first_order.language} {M : Type u_3} {N : Type u_4} [L.Structure M] [L.Structure N] (f : L.embedding M N) (htv : ∀ (n : ℕ) (φ : L.bounded_formula empty (n + 1)) (x : fin n → M) (a : N), φ.realize inhabited.default (fin.snoc (⇑f ∘ x) a) → (∃ (b : M), φ.realize inhabited.default (fin.snoc (⇑f ∘ x) (⇑f b)))) : L.elementary_embedding M N
{ι : Type u_1} {α : ι → Type u_3} [fintype ι] {C : Π (i : ι), set (set (α i))} (hC : ∀ (i : ι), is_countably_spanning (C i)) : is_countably_spanning (set.univ.pi '' set.univ.pi C)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [normed_group E] [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] (f₀ : E →SL[σ₁₂] F) (r : ℝ) : is_closed (coe_fn '' metric.closed_ball f₀ r)
{E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) [t2_space M] [smooth_manifold_with_corners I M] : smooth I (model_with_corners_self ℝ ℝ) ⇑f
{α : Type u} [pseudo_metric_space α] : (uniformity α).has_basis (λ (ε : ℝ), 0 < ε) (λ (ε : ℝ), {p : α × α | has_dist.dist p.fst p.snd ≤ ε})
(P : Π (X : algebraic_geometry.Scheme), topological_space.opens ↥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier) → Prop) (h₁ : ∀ (X : algebraic_geometry.Scheme) (U : topological_space.opens ↥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)), (∀ (x : ↥U), ∃ {V : topological_space.opens ↥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} (h : x.val ∈ V) (i : V ⟶ U), P X V) → P X U) (h₂ : ∀ {X Y : algebraic_geometry.Scheme} (f : X ⟶ Y) [hf : algebraic_geometry.is_open_immersion f], ∃ {U : set ↥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} {V : set ↥(Y.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} (hU : U = ⊤) (hV : V = set.range ⇑(f.val.base)), P X ⟨U, _⟩ → P Y ⟨V, _⟩) (h₃ : ∀ (R : CommRing), P (algebraic_geometry.Scheme.Spec.obj (opposite.op R)) ⊤) (X : algebraic_geometry.Scheme) (U : topological_space.opens ↥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)) : P X U
{R : Type u_1} [semiring R] {S : Type u_2} {F : Type u_3} [semiring S] [add_monoid_hom_class F (polynomial R) (polynomial S)] {φ : F} {p : polynomial R} (k : ℕ) (fu : ℕ → ℕ) (fu0 : ∀ {n : ℕ}, n ≤ k → fu n = 0) (fc : ∀ {n m : ℕ}, k ≤ n → n < m → fu n < fu m) (φ_k : ∀ {f : polynomial R}, f.nat_degree < k → ⇑φ f = 0) (φ_mon_nat : ∀ (n : ℕ) (c : R), c ≠ 0 → (⇑φ (⇑(polynomial.monomial n) c)).nat_degree = fu n) : (⇑φ p).nat_degree = fu p.nat_degree
{I : Type u} {f : I → Type v} [decidable_eq I] [Π (i : I), mul_one_class (f i)] (x : Π (i : I), f i) (i j : I) : commute (pi.mul_single i (x i)) (pi.mul_single j (x j))
{elab : bool := bool.tt} : expr elab → option (name × expr elab × expr elab × expr elab)
{α : Sort u_1} {β : Sort u_2} {f : α → β} [decidable_eq β] (I : function.injective f) : decidable_eq α
{β : Type u} [metric_space β] [measurable_space β] [borel_space β] [sigma_compact_space β] [has_besicovitch_covering β] (μ : measure_theory.measure β) [measure_theory.is_locally_finite_measure μ] {s : set β} (hs : measurable_set s) : ∀ᵐ (x : β) ∂μ, filter.tendsto (λ (r : ℝ), ⇑μ (s ∩ metric.closed_ball x r) / ⇑μ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds (s.indicator 1 x))
{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} (hf : antitone f) {a : α} {s : set α} : is_least s a → is_greatest (f '' s) (f a)
{X : Type u_1} [pseudo_metric_space X] [proper_space X] {s : set X} (hs : metric.bounded s) {x : ℕ → X} (hx : ∀ (n : ℕ), x n ∈ s) : ∃ (a : X) (H : a ∈ closure s) (φ : ℕ → ℕ), strict_mono φ ∧ filter.tendsto (x ∘ φ) filter.at_top (nhds a)
{ι : Type u_1} [decidable_eq ι] {A : ι → Type u_2} {R : Type u_3} [Π (i : ι), add_comm_monoid (A i)] [add_monoid ι] [direct_sum.gsemiring A] [semiring R] ⦃F G : direct_sum ι (λ (i : ι), A i) →+* R⦄ (h : ∀ (i : ι), ↑F.comp (direct_sum.of A i) = ↑G.comp (direct_sum.of A i)) : F = G
(cs : interactive.parse (lean.parser.many lean.parser.ident)) (locat : interactive.parse interactive.types.location) (cfg : tactic.unfold_config := {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}}) : tactic unit
{α : Type u_1} {m0 : measurable_space α} [topological_space α] (μ : measure_theory.measure α) : Prop
{E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] {A : E →L[ℝ] E} {δ : nnreal} (hf : approximates_linear_on f A s δ) (hs : measurable_set s) (f' : E → (E →L[ℝ] E)) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) : ∀ᵐ (x : E) ∂μ.restrict s, ∥f' x - A∥₊ ≤ δ
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring 𝕜] [add_comm_group E] [add_comm_group F] [module 𝕜 E] [module 𝕜 F] {x : E} (f : E →ᵃ[𝕜] F) {s : set E} (hs : star_convex 𝕜 x s) : star_convex 𝕜 (⇑f x) (⇑f '' s)
{E : Type u_1} [normed_group E] [normed_space ℂ E] {a b : ℝ} {f : ℂ → E} (hd : diff_cont_on_cl ℂ f (complex.im ⁻¹' set.Ioo a b)) (hB : ∃ (c : ℝ) (H : c < real.pi / (b - a)) (B : ℝ), f =O[filter.comap (has_abs.abs ∘ complex.re) filter.at_top ⊓ filter.principal (complex.im ⁻¹' set.Ioo a b)] λ (z : ℂ), real.exp (B * real.exp (c * |z.re|))) (ha : ∀ (z : ℂ), z.im = a → f z = 0) (hb : ∀ (z : ℂ), z.im = b → f z = 0) : set.eq_on f 0 (complex.im ⁻¹' set.Icc a b)
{C : Type u} [category_theory.category C] {W X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} [category_theory.limits.has_pushout f g] (h : Y ⟶ W) (k : Z ⟶ W) (w : f ≫ h = g ≫ k) : category_theory.limits.pushout f g ⟶ W
{ι : Type u_1} (I : box_integral.box ι) (i : ι) (x : ℝ) : with_bot (box_integral.box ι)
{C : Type u₁} [category_theory.category C] {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z} (s : category_theory.comm_sq f g h i) : category_theory.limits.pushout_cocone f g
{ι : Type u_1} [decidable_eq ι] {A : ι → Type u_2} {R : Type u_3} [Π (i : ι), add_comm_monoid (A i)] [add_monoid ι] [direct_sum.gsemiring A] [semiring R] ⦃f g : direct_sum ι (λ (i : ι), A i) →+* R⦄ (h : ∀ (i : ι) (x : A i), ⇑f (⇑(direct_sum.of A i) x) = ⇑g (⇑(direct_sum.of A i) x)) : f = g
{α : Type u_1} {E : Type u_2} [normed_group E] {m : measurable_space α} {μ : measure_theory.measure α} [normed_space ℝ E] (f : ↥(measure_theory.Lp.simple_func E 1 μ)) : E
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} {I : category_theory.InjectiveResolution Y} {J : category_theory.InjectiveResolution Z} (f : I.cocomplex ⟶ J.cocomplex) (comm : I.ι ≫ f = 0) : I.cocomplex.X 1 ⟶ J.cocomplex.X 0
(G W : expr) (u : list name) : tactic expr
{E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {f : ℂ → E} {c : ℂ} (hd : ∀ᶠ (z : ℂ) in nhds_within c {c}ᶜ, differentiable_at ℂ f z) (hb : filter.is_bounded_under has_le.le (nhds_within c {c}ᶜ) (λ (z : ℂ), ∥f z - f c∥)) : filter.tendsto f (nhds_within c {c}ᶜ) (nhds (lim (nhds_within c {c}ᶜ) f))
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : continuous_multilinear_map 𝕜 E G) (m₁ m₂ : Π (i : ι), E i) : ∥⇑f m₁ - ⇑f m₂∥ ≤ ∥f∥ * ↑(fintype.card ι) * linear_order.max ∥m₁∥ ∥m₂∥ ^ (fintype.card ι - 1) * ∥m₁ - m₂∥
(α : Type u_1) [measurable_space α] (μ : measure_theory.measure α . "volume_tac") : Type u_1
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} [inhabited Λ] {σ : Type u_4} [inhabited σ] {k : K} : turing.TM2to1.st_act k → turing.TM2.stmt Γ Λ σ → turing.TM2.stmt Γ Λ σ
{ι : Type u_1} {α : ι → Type u_3} {C : Π (i : ι), set (set (α i))} (hC : ∀ (i : ι), is_pi_system (C i)) : is_pi_system (set.univ.pi '' set.univ.pi C)
{ι : Type u_1} (I : box_integral.box ι) (s : set ι) : box_integral.box ι
{α : Type u_1} {ι : Type u_2} {E : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group E] {p : ennreal} {f : ι → α → E} {g : α → E} {l : filter ι} (hp_ne_zero : p ≠ 0) (hf : ∀ (n : ι), measure_theory.ae_strongly_measurable (f n) μ) (hg : measure_theory.ae_strongly_measurable g μ) (hfg : filter.tendsto (λ (n : ι), measure_theory.snorm (f n - g) p μ) l (nhds 0)) : measure_theory.tendsto_in_measure μ f l g
{σ : Type u_1} {R : Type u} [comm_semiring R] (s : set σ) : ↥(mv_polynomial.supported R s) ≃ₐ[R] mv_polynomial ↥s R
{α : Type u_1} [decidable_eq α] [fintype α] {σ : equiv.perm α} (hσ : σ.is_cycle) : ↥↑(subgroup.zpowers σ) ≃ ↥↑(σ.support)
{M : Type u_1} {N : Type u_2} {μ : M → N → N} [preorder N] [covariant_class M N μ has_le.le] (m : M) : monotone (μ m)
(e : expr) (md : tactic.transparency := tactic.transparency.reducible) : tactic ℕ
{C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] (G : D ⥤ C) [category_theory.is_right_adjoint G] [∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_5 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g] [Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_7 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G] [Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_9 : G.is_split_pair f g], category_theory.limits.reflects_colimit (category_theory.limits.parallel_pair f g) G] : category_theory.monadic_right_adjoint G
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {s : set M} {x : M} {n : ℕ} : cont_mdiff_within_at I I' ↑n f s x ↔ ∃ (u : set M) (H_1 : u ∈ nhds_within x (has_insert.insert x s)), cont_mdiff_on I I' ↑n f u
{C : Type u} [category_theory.category C] (all_unique : Π {X Y : C}, unique (X ⟶ Y)) : category_theory.groupoid C
{ι : Type u_1} [decidable_eq ι] {R : Type u_4} [comm_semiring R] {s : ι → Type u_7} [Π (i : ι), add_comm_monoid (s i)] [Π (i : ι), module R (s i)] {E : Type u_9} [add_comm_monoid E] [module R E] (φ : multilinear_map R s E) : pi_tensor_product R (λ (i : ι), s i) →+ E
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] (I : model_with_corners 𝕜 E H) {G : Type u_4} [has_mul G] [topological_space G] [charted_space H G] [has_smooth_mul I G] (g : G) : cont_mdiff_map I I G G ⊤
{α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] {μ : measure_theory.measure α} [μ.weakly_regular] (f : measure_theory.simple_func α nnreal) (int_f : ∫⁻ (x : α), ↑(⇑f x) ∂μ ≠ ⊤) {ε : ennreal} (ε0 : ε ≠ 0) : ∃ (g : α → nnreal), (∀ (x : α), g x ≤ ⇑f x) ∧ upper_semicontinuous g ∧ ∫⁻ (x : α), ↑(⇑f x) ∂μ ≤ ∫⁻ (x : α), ↑(g x) ∂μ + ε
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} {I : category_theory.InjectiveResolution Y} {J : category_theory.InjectiveResolution Z} (f : I.cocomplex ⟶ J.cocomplex) (comm : I.ι ≫ f = 0) : homotopy f 0
(no_dflt : interactive.parse interactive.types.only_flag) (es : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (l : interactive.parse interactive.types.location) (cfg : tactic.dsimp_config := {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}) : tactic unit
{𝕜 : Type u_1} [is_R_or_C 𝕜] {F : Type u_2} [semi_normed_group F] [normed_space 𝕜 F] (p : subspace 𝕜 F) (f : ↥p →L[𝕜] 𝕜) : ∃ (g : F →L[𝕜] 𝕜), (∀ (x : ↥p), ⇑g ↑x = ⇑f x) ∧ ∥g∥ = ∥f∥
{R : Type u_1} [comm_semiring R] (σ : Type u_2) [fintype σ] : finset.univ.prod (λ (i : σ), ⇑polynomial.C (mv_polynomial.X i) + polynomial.X) = (finset.range (fintype.card σ + 1)).sum (λ (j : ℕ), ⇑polynomial.C (mv_polynomial.esymm σ R j) * polynomial.X ^ (fintype.card σ - j))
{p : ℕ} {g : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R → witt_vector p R} {f : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R} (hg : witt_vector.is_poly₂ p g) (hf : witt_vector.is_poly p f) : witt_vector.is_poly₂ p (λ (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g x (f y))
{σ : Type u_1} (R : Type u_2) [semiring R] (n : σ →₀ ℕ) : R →ₗ[R] mv_power_series σ R
{α : Type u} {β : Type v} [pseudo_metric_space α] {I : set β} {s : β → set α} (H : I.finite) : metric.bounded (⋃ (i : β) (H : i ∈ I), s i) ↔ ∀ (i : β), i ∈ I → metric.bounded (s i)
{α : Type u_1} {m0 : measurable_space α} [pseudo_metric_space α] [proper_space α] {μ : measure_theory.measure α} [measure_theory.is_finite_measure_on_compacts μ] ⦃s : set α⦄ (hs : metric.bounded s) : ⇑μ s < ⊤
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [category_theory.limits.has_wide_equalizer f] [nonempty J] {W : C} (k : W ⟶ X) (h : ∀ (j₁ j₂ : J), k ≫ f j₁ = k ≫ f j₂) : {l // l ≫ category_theory.limits.wide_equalizer.ι f = k}
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} (f : Y ⟶ Z) {I : category_theory.InjectiveResolution Y} {J : category_theory.InjectiveResolution Z} (g h : I.cocomplex ⟶ J.cocomplex) (g_comm : I.ι ≫ g = (cochain_complex.single₀ C).map f ≫ J.ι) (h_comm : I.ι ≫ h = (cochain_complex.single₀ C).map f ≫ J.ι) : homotopy g h
{ι : Type v} [dec_ι : decidable_eq ι] {β : ι → Type w} [Π (i : ι), add_comm_monoid (β i)] {γ : Type u_1} [add_monoid γ] ⦃f g : direct_sum ι (λ (i : ι), β i) →+ γ⦄ (H : ∀ (i : ι), f.comp (direct_sum.of (λ (i : ι), β i) i) = g.comp (direct_sum.of β i)) : f = g
{ι : Type u} (β : ι → Type v) [I : nonempty ι] : ∃ (i : ι), nonempty (Π (j : ι), β i ↪ β j)
{E : Type u_1} [normed_group E] [normed_space ℝ E] [complete_space E] {φ : E → ℝ} {x₀ : E} {φ' : E →L[ℝ] ℝ} {ι : Type u_2} [fintype ι] {f : ι → E → ℝ} {f' : ι → (E →L[ℝ] ℝ)} (hextr : is_local_extr_on φ {x : E | ∀ (i : ι), f i x = f i x₀} x₀) (hf' : ∀ (i : ι), has_strict_fderiv_at (f i) (f' i) x₀) (hφ' : has_strict_fderiv_at φ φ' x₀) : ∃ (Λ : ι → ℝ) (Λ₀ : ℝ), (Λ, Λ₀) ≠ 0 ∧ finset.univ.sum (λ (i : ι), Λ i • f' i) + Λ₀ • φ' = 0
{α : Type u_1} {m : measurable_space α} {μ ν s : measure_theory.measure α} {f : α → ennreal} (hf : measurable f) (hs : s.mutually_singular ν) (hadd : μ = s + ν.with_density f) : ν.with_density f = ν.with_density (μ.rn_deriv ν)
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f (⇑σ i) • g i) < finset.univ.sum (λ (i : ι), f i • g i) ↔ ¬monovary (f ∘ ⇑σ) g
{C : Type u} [category_theory.category C] (B : C) [category_theory.limits.has_finite_products C] {I : C} (t : category_theory.limits.is_initial I) [category_theory.cartesian_closed C] : (category_theory.exp I).obj B ≅ ⊤_ C
{ι : Type u_1} {N : Type u_5} [topological_space N] [add_monoid N] [has_continuous_add N] [t2_space N] {f : ι → add_units N} {r₁ r₂ : N} {l : filter ι} [l.ne_bot] (h₁ : filter.tendsto (λ (x : ι), ↑(f x)) l (nhds r₁)) (h₂ : filter.tendsto (λ (x : ι), ↑-f x) l (nhds r₂)) : add_units N
{C : Type u₁} [category_theory.category C] {X Y W : C} (f : X ⟶ Y) [category_theory.regular_mono f] (k : W ⟶ Y) (h : k ≫ category_theory.regular_mono.left = k ≫ category_theory.regular_mono.right) : {l // l ≫ f = k}
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) : orthogonal_family 𝕜 (λ (μ : 𝕜), (module.End.eigenspace T μ).subtypeₗᵢ)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) : local_equiv M E
{ι : Type u_1} {α : ι → Type u_3} [Π (i : ι), measurable_space (α i)] : is_pi_system (set.univ.pi '' set.univ.pi (λ (i : ι), {s : set (α i) | measurable_set s}))
{α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : f '' s ∈ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') (n : with_top ℕ) (f : H → H') (s : set H) (x : H) : Prop
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {s : set 𝕜} [complete_space F] (h : analytic_on 𝕜 f s) (n : ℕ) : analytic_on 𝕜 (deriv^[n] f) s
(n : ℕ) (t : Type u_1) (t' : Type u_2) (v : typevec n) (v' : typevec n) {β : (v ::: t).arrow (v' ::: t') → Sort u_3} (F : Π (f : t → t') (fs : v.arrow v'), β (fs ::: f)) (fs : (v ::: t).arrow (v' ::: t')) : β fs
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) : category_theory.limits.walking_multispan I.fst_from I.snd_from ⥤ C
{V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] (f : V₁ →+ V₂) {C : ℝ} (hC : 0 ≤ C) (h : ∀ (x : V₁), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_normed_group_hom C h∥ ≤ C
(all_goals : interactive.parse (optional (lean.parser.tk "*"))) (no_dflt : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (opt : tactic.solve_by_elim.opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := λ (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (λ (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}) : tactic unit
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space ?? E] {x y : E} (hx : ∥x∥ = 1) (hy : ∥y∥ = 1) : has_inner.inner x y = 1 ↔ x = y
{α : Type u} [pseudo_emetric_space α] {ε : ennreal} (ε0 : 0 < ε) : {p : α × α | has_edist.edist p.fst p.snd < ε} ∈ uniformity α
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (μ : R) : submodule R M
{Ω : Type u_1} [measure_theory.measure_space Ω] [measure_theory.is_probability_measure measure_theory.measure_space.volume] (X : ℕ → Ω → ℝ) (hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume) (hindep : pairwise (λ (i j : ℕ), probability_theory.indep_fun (X i) (X j) measure_theory.measure_space.volume)) (hident : ∀ (i : ℕ), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume) (hnonneg : ∀ (i : ℕ) (ω : Ω), 0 ≤ X i ω) : ∀ᵐ (ω : Ω), filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), X i ω) / ↑n) filter.at_top (nhds (∫ (a : Ω), X 0 a))
{α : Type u_1} {β : α → Type u_4} {γ : Π (a : α), β a → Type u_2} (f : Π (x : α) (y : β x), γ x y) (x : sigma β) : γ x.fst x.snd
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} {v : vitali_family μ} {f : α → set (set α)} {s : set α} (h : v.fine_subfamily_on f s) : α → set α
{α : Type u_1} {F : Type u_3} [normed_group F] [normed_space ℝ F] {m : measurable_space α} {μ : measure_theory.measure α} [decidable_pred (λ (x : F), x ≠ 0)] {f : measure_theory.simple_func α F} {s : finset F} (hs : finset.filter (λ (x : F), x ≠ 0) f.range ⊆ s) : measure_theory.simple_func.integral μ f = s.sum (λ (x : F), (⇑μ (⇑f ⁻¹' {x})).to_real • x)
{R : Type u_1} [comm_semiring R] (S : Type u_2) [comm_semiring S] [algebra R S] (I : ideal R) [hp : I.is_prime] : Prop
{R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] {p q : submodule R E} (h : is_compl p q) (φ : ↥p →ₗ[R] F) (ψ : ↥q →ₗ[R] F) : E →ₗ[R] F
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w₁} [category_theory.category D] {E : Type w₂} [category_theory.category E] (F : D ⥤ E) [∀ (α β : Type (max v u)) (fst snd : β → α), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) D] [∀ (α β : Type (max v u)) (fst snd : β → α), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) E] [Π (X : C) (W : J.cover X) (P : Cᵒᵖ ⥤ D), category_theory.limits.preserves_limit (W.index P).multicospan F] (P : Cᵒᵖ ⥤ D) [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ D] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ E] [Π (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)ᵒᵖ F] : J.plus_obj P ⋙ F ≅ J.plus_obj (P ⋙ F)
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} {σ : Type u_4} (M : Λ → turing.TM2.stmt Γ Λ σ) : turing.TM2.cfg Γ Λ σ → option (turing.TM2.cfg Γ Λ σ)
{G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {μ : measure_theory.measure G} {Γ : add_subgroup G} {𝓕 : set G} (h𝓕 : measure_theory.is_add_fundamental_domain ↥(Γ.opposite) 𝓕 μ) [encodable ↥Γ] [measurable_space (G ⧸ Γ)] [borel_space (G ⧸ Γ)] [μ.is_add_left_invariant] [μ.is_add_right_invariant] : measure_theory.vadd_invariant_measure G (G ⧸ Γ) (measure_theory.measure.map quotient_add_group.mk (μ.restrict 𝓕))
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] [normed_group F] [normed_space ℝ F] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] [complete_space F] (hs : measurable_set s) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) (g : E → F) : ∫ (x : E) in f '' s, g x ∂μ = ∫ (x : E) in s, |(f' x).det| • g (f x) ∂μ
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ⟶ Y) [category_theory.limits.has_cokernel f] {W : C} (k : Y ⟶ W) (h : f ≫ k = 0) : category_theory.limits.cokernel f ⟶ W
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {e : local_homeomorph M M'} (he : local_homeomorph.mdifferentiable I I' e) [smooth_manifold_with_corners I M] [smooth_manifold_with_corners I' M'] {x : M} (hx : x ∈ e.to_local_equiv.source) : tangent_space I x ≃L[𝕜] tangent_space I' (⇑e x)
(B : Type u₁) [quiver B] [Π (a b : B), quiver (a ⟶ b)] (C : Type u₂) [quiver C] [Π (a b : C), quiver (a ⟶ b)] : Type (max u₁ u₂ v₁ v₂ w₁ w₂)
{C : Type u} [category_theory.category C] {W X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} [category_theory.limits.has_pushout f g] (h : Y ⟶ W) (k : Z ⟶ W) (w : f ≫ h = g ≫ k) : {l // category_theory.limits.pushout.inl ≫ l = h ∧ category_theory.limits.pushout.inr ≫ l = k}
{R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {g : R →+* P} {T : submonoid P} {Q : Type u_4} [comm_semiring Q] (hy : M ≤ submonoid.comap ↑g T) [algebra P Q] [is_localization T Q] {A : Type u_5} [comm_semiring A] {U : submonoid A} {W : Type u_6} [comm_semiring W] [algebra A W] [is_localization U W] {l : P →+* A} (hl : T ≤ submonoid.comap ↑l U) (x : S) : ⇑(is_localization.map W l hl) (⇑(is_localization.map Q g hy) x) = ⇑(is_localization.map W (l.comp g) _) x
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) : ⇑μ {x : α | v.lim_ratio_meas hρ x = ⊤} = 0
{R : Type u} [comm_ring R] [is_domain R] {𝓟 : ideal R} {f : polynomial R} (hf : f.is_eisenstein_at 𝓟) (hprime : 𝓟.is_prime) (hu : f.is_primitive) (hfd0 : 0 < f.nat_degree) : irreducible f
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M →+ N} (h : ∀ (y : ↥S), is_add_unit (⇑f ↑y)) {x₁ x₂ : M} {y₁ y₂ : ↥S} : ⇑f x₁ + ↑-⇑(is_add_unit.lift_right (f.restrict S) h) y₁ = ⇑f x₂ + ↑-⇑(is_add_unit.lift_right (f.restrict S) h) y₂ ↔ ⇑f (x₁ + ↑y₂) = ⇑f (x₂ + ↑y₁)
{E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (s : affine_subspace ℝ E) (hs : s ≠ ⊤) : ⇑μ ↑s = 0
{R : Type u} [ring R] {I : ideal R} : I.jacobson = I ↔ ∀ (x : R), x ∉ I → (∃ (M : ideal R), (I ≤ M ∧ M.is_maximal) ∧ x ∉ M)
{V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : real.angle) : o.oangle x y = θ ↔ y = (∥y∥ / ∥x∥) • ⇑(o.rotation θ) x
{B : Type u₁} [category_theory.bicategory B] {C : Type u₂} [category_theory.bicategory C] (obj : B → C) (map : Π {X Y : B}, (X ⟶ Y) → (obj X ⟶ obj Y)) (map₂ : Π {a b : B} {f g : a ⟶ b}, (f ⟶ g) → (map f ⟶ map g)) (map_comp : Π {a b c : B} (f : a ⟶ b) (g : b ⟶ c), map (f ≫ g) ≅ map f ≫ map g) {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) : Prop
{α : Type u_1} {C : free_monoid α → Sort u_2} (xs : free_monoid α) (h0 : C 1) (ih : Π (x : α) (xs : free_monoid α), C xs → C (free_monoid.of x * xs)) : C xs
{Ω : Type u_1} [measure_theory.measure_space Ω] [measure_theory.is_probability_measure measure_theory.measure_space.volume] (X : ℕ → Ω → ℝ) (hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume) (hindep : pairwise (λ (i j : ℕ), probability_theory.indep_fun (X i) (X j) measure_theory.measure_space.volume)) (hident : ∀ (i : ℕ), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume) : ∀ᵐ (ω : Ω), filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), X i ω) / ↑n) filter.at_top (nhds (∫ (a : Ω), X 0 a))
{α : Type u_1} {β : Type u_2} {m0 : measurable_space α} [measurable_space β] {μ : measure_theory.measure α} {f : α → β} (hf : measurable f) {s : set β} (hs : measurable_set s) : (measure_theory.measure.map f μ).restrict s = measure_theory.measure.map f (μ.restrict (f ⁻¹' s))
(p : Prop) [slim_check.testable p] (cfg : slim_check.slim_check_cfg := {num_inst := 100, max_size := 100, trace_discarded := bool.ff, trace_success := bool.ff, trace_shrink := bool.ff, trace_shrink_candidates := bool.ff, random_seed := option.none ℕ, quiet := bool.ff}) : rand (slim_check.test_result p)
{R : Type u_5} {S : Type u_6} [comm_semiring R] [comm_semiring S] (σ : R ≃+* S) (n : ℕ+) : ↥(roots_of_unity n R) ≃* ↥(roots_of_unity n S)
(h : expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic unit
(h : name) (t : option expr := option.none) (pr : expr) : tactic expr
{R : Type u_1} [comm_ring R] [is_domain R] (φ ψ : power_series R) : (φ * ψ).order = φ.order + ψ.order
{R₁ : Type u_5} {R₂ : Type u_6} [semiring R₁] [semiring R₂] [has_norm R₁] [has_norm R₂] (σ : R₁ →+* R₂) : Prop
{𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] [measurable_space G] [has_sub G] (f : G → E) (g : G → E') (x : G) (L : E →L[𝕜] E' →L[𝕜] F) (μ : measure_theory.measure G . "volume_tac") : Prop
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) {s t : set M} (ht : t ∈ nhds_within x s) : ⇑((ext_chart_at I x).symm) ⁻¹' t ∈ nhds_within (⇑(ext_chart_at I x) x) (⇑((ext_chart_at I x).symm) ⁻¹' s ∩ set.range ⇑I)
(k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype ι] (p : ι → P) (s : set ι) : finite_dimensional k ↥(vector_span k (p '' s))
{G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G → E'} [measurable_space G] {μ : measure_theory.measure G} [semi_normed_group G] [borel_space G] [topological_space.second_countable_topology G] [μ.is_add_left_invariant] [measure_theory.sigma_finite μ] [normed_space ℝ E'] [complete_space E'] {ι : Type u_1} {l : filter ι} {φ : ι → G → ℝ} (hnφ : ∀ (i : ι) (x : G), 0 ≤ φ i x) (hiφ : ∀ (i : ι), ∫ (s : G), φ i s ∂μ = 1) (hφ : filter.tendsto (λ (n : ι), function.support (φ n)) l (nhds 0).small_sets) (hmg : measure_theory.ae_strongly_measurable g μ) {x₀ : G} (hcg : continuous_at g x₀) : filter.tendsto (λ (i : ι), convolution (φ i) g (continuous_linear_map.lsmul ℝ ℝ) μ x₀) l (nhds (g x₀))
(lemmas : option (list expr) := option.none) (opt : tactic.apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}) (tac : tactic unit := tactic.interactive.skip) : tactic unit
{E : Type u_1} [normed_group E] [normed_space ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hd : diff_cont_on_cl ℂ f {z : ℂ | 0 < z.re}) (hexp : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : filter.is_bounded_under has_le.le filter.at_top (λ (x : ℝ), ∥f ↑x∥)) (him : ∀ (x : ℝ), ∥f (↑x * complex.I)∥ ≤ C) (hz : 0 ≤ z.re) : ∥f z∥ ≤ C
{E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y : E} {a b r : ℝ} (hx : ∥x∥ ≤ r) (hy : ∥y∥ ≤ r) (hne : x ≠ y) (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : ∥a • x + b • y∥ < r
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (σ : equiv.perm n) : (equiv.to_pequiv σ).to_matrix.det = ↑(⇑equiv.perm.sign σ)
(f : expr) (nargs : option ℕ := option.none) : tactic.unsafe.type_context fun_info
{α : Type u} {β : Type v} {s : set α} {t : set β} {f : α → β} : f '' s ⊆ t ↔ s ⊆ f ⁻¹' t
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] {E : intermediate_field K L} (σ : L ≃ₐ[K] L) [finite_dimensional K ↥E] : finite_dimensional K ↥(E.map σ.to_alg_hom)
{R : Type u_1} [normed_ring R] [complete_space R] (x : Rˣ) : (λ (t : R), ring.inverse (↑x + t) - ↑x⁻¹) =O[nhds 0] λ (t : R), ∥t∥
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w₁} [category_theory.category D] {E : Type w₂} [category_theory.category E] (F : D ⥤ E) [∀ (α β : Type (max v u)) (fst snd : β → α), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) D] [∀ (α β : Type (max v u)) (fst snd : β → α), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) E] [Π (X : C) (W : J.cover X) (P : Cᵒᵖ ⥤ D), category_theory.limits.preserves_limit (W.index P).multicospan F] (P : Cᵒᵖ ⥤ D) (X : C) : J.diagram P X ⋙ F ≅ J.diagram (P ⋙ F) X
{α : Type u_1} [uniform_space α] {s : set (α × α)} (hs : s ∈ uniformity α) (n : ℕ) : ∀ᶠ (t : set (α × α)) in (uniformity α).small_sets, comp_rel t^[n] t ⊆ s
{E : Type u_1} [normed_group E] [measurable_space E] [normed_space ℝ E] [finite_dimensional ℝ E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (r : ℝ) (s : set E) : ⇑μ (r • s) = ennreal.of_real |r ^ finite_dimensional.finrank ℝ E| * ⇑μ s
{C : Type u₁} [category_theory.category C] {I I' : C} (hI : category_theory.limits.is_initial I) (hI' : category_theory.limits.is_initial I') : I ≅ I'
{R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] {e : ι → M} {ε : ι → module.dual R M} [decidable_eq ι] (h : dual_pair e ε) (m : M) : ι →₀ R
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} : ∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * ⇑is_R_or_C.re (has_inner.inner x y) + ∥y∥ ^ 2
{M : Type u_1} {N : Type u_2} {μ : M → N → N} {α : Type u_3} [preorder α] [preorder N] {f : N → α} [covariant_class M N μ has_le.le] (hf : antitone f) (m : M) : antitone (λ (n : N), f (μ m n))
{a b : ℝ} {E : Type u_1} [normed_group E] {f : ℝ → E} {f' : ℝ → ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → ∀ (r : ℝ), f' x < r → (∃ᶠ (z : ℝ) in nhds_within x (set.Ioi x), slope (has_norm.norm ∘ f) x z < r)) {B B' : ℝ → ℝ} (ha : ∥f a∥ ≤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at B (B' x) (set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥f x∥ = B x → f' x < B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → ∥f x∥ ≤ B x
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [topological_space.second_countable_topology X] {r : nnreal} {f : X → Y} (hr : 0 < r) {s : set X} (hf : ∀ (x : X), x ∈ s → (∃ (C : nnreal) (t : set X) (H : t ∈ nhds_within x s), holder_on_with C r f t)) : dimH (f '' s) ≤ dimH s / ↑r
{R : Type u} {σ : Type u_1} [comm_semiring R] {M : mv_polynomial σ R → Prop} (p : mv_polynomial σ R) (h_C : ∀ (a : R), M (⇑mv_polynomial.C a)) (h_add_weak : ∀ (a : σ →₀ ℕ) (b : R) (f : (σ →₀ ℕ) →₀ R), a ∉ f.support → b ≠ 0 → M f → M (⇑(mv_polynomial.monomial a) b) → M (⇑(mv_polynomial.monomial a) b + f)) (h_X : ∀ (p : mv_polynomial σ R) (n : σ), M p → M (p * mv_polynomial.X n)) : M p
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f g : measure_theory.simple_func α ennreal} (h : ⇑f =ᵐ[μ] ⇑g) : f.lintegral μ = g.lintegral μ
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [normed_group E] [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] [proper_space F] (f₀ : E →SL[σ₁₂] F) (r : ℝ) : is_compact (coe_fn '' metric.closed_ball f₀ r)
{I : Type w₀} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {D : I → Type u₁} [Π (i : I), category_theory.category (D i)] (F : Π (i : I), C i ⥤ D i) : (Π (i : I), C i) ⥤ Π (i : I), D i
{α : Type u_1} [measurable_space α] [topological_space α] ⦃U : set α⦄ (hU : is_open U) (μ : measure_theory.measure α) [μ.regular] : ⇑μ U = ⨆ (K : set α) (h : K ⊆ U) (h2 : is_compact K), ⇑μ K
(R : Type u) [semiring R] {ι : Type v} [dec_ι : decidable_eq ι] {M : ι → Type w} [Π (i : ι), add_comm_monoid (M i)] [Π (i : ι), module R (M i)] {N : Type u₁} [add_comm_monoid N] [module R N] (ψ : direct_sum ι (λ (i : ι), M i) →ₗ[R] N) (f : direct_sum ι (λ (i : ι), M i)) : ⇑ψ f = ⇑(direct_sum.to_module R ι N (λ (i : ι), ψ.comp (direct_sum.lof R ι M i))) f
{α : Type u_1} {s : set (setoid α)} : (has_Inf.Inf s).rel = has_Inf.Inf (setoid.rel '' s)
{f : ℝ → ℝ} {a b : ℝ} (hf : continuous_on f (set.Icc a b)) {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at B (B' x) (set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∀ (r : ℝ), B' x < r → (∃ᶠ (z : ℝ) in nhds_within x (set.Ioi x), slope f x z < r)) ⦃x : ℝ⦄ : x ∈ set.Icc a b → f x ≤ B x
{k : Type u₁} {G : Type u₂} [semiring k] (f : add_monoid_algebra k G) : f ∈ submodule.span k (add_monoid_algebra.of' k G '' ↑(f.support))
{ι : Type u} {α : ι → Type u_2} {δ : Π (i : ι), α i → Type v} [Π (i : ι) (j : α i), has_zero (δ i j)] : (Π₀ (i : Σ (i : ι), α i), δ i.fst i.snd) ≃ Π₀ (i : ι) (j : α i), δ i j
{𝕜 : Type u} [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] {F : Type w} [normed_group F] [normed_space 𝕜 F] [complete_space 𝕜] {ι : Type u_1} [fintype ι] (v : basis ι 𝕜 E) : ∃ (C : ℝ) (H : C > 0), ∀ {u : E →L[𝕜] F} {M : ℝ}, 0 ≤ M → (∀ (i : ι), ∥⇑u (⇑v i)∥ ≤ M) → ∥u∥ ≤ C * M
{M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] ⦃f g : M →+ N⦄ (h : ⇑f = ⇑g) : f = g
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} (S : μ.finite_spanning_sets_in {s : set α | measurable_set s}) : μ.finite_spanning_sets_in {s : set α | measurable_set s}
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) {s t : set M} : ⇑((ext_chart_at I x).symm) ⁻¹' (s ∩ t) ∩ set.range ⇑I = ⇑((ext_chart_at I x).symm) ⁻¹' s ∩ set.range ⇑I ∩ ⇑((ext_chart_at I x).symm) ⁻¹' t
{R : Type u_5} [comm_ring R] [is_domain R] {ζ : R} {k : ℕ} (h : is_primitive_root ζ k) : (primitive_roots k R).card = k.totient
{R : Type u} {S : Type v} [ring R] [ring S] (f : R →+* S) (s : set R) : subring.map f (subring.closure s) = subring.closure (⇑f '' s)
{ι : Type u_4} {π : ι → Type u_1} [fintype ι] [Π (i : ι), non_unital_normed_ring (π i)] : non_unital_normed_ring (Π (i : ι), π i)
{C : Type (max v u)} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] {K : Type (max v u)} [category_theory.small_category K] (F : K ⥤ category_theory.Sheaf J D) (E : category_theory.limits.cone (F ⋙ category_theory.Sheaf_to_presheaf J D)) (X : C) (W : J.cover X) (S : category_theory.limits.multifork (W.index E.X)) : category_theory.limits.cone (F ⋙ category_theory.Sheaf_to_presheaf J D ⋙ (category_theory.evaluation Cᵒᵖ D).obj (opposite.op X))
{P : Type u_1} [preorder P] (p : P) {ι : Type u_2} [encodable ι] (𝒟 : ι → order.cofinal P) : ℕ → P
{elab : bool} : expr → expr elab → tactic unit
{α : Type u_1} [measurable_space α] [topological_space α] [opens_measurable_space α] (μ : measure_theory.finite_measure α) {c : nnreal} {E : set α} (E_mble : measurable_set E) (fs : ℕ → bounded_continuous_function α nnreal) (fs_bdd : ∀ (n : ℕ) (a : α), ⇑(fs n) a ≤ c) (fs_lim : filter.tendsto (λ (n : ℕ), ⇑(fs n)) filter.at_top (nhds (E.indicator (λ (x : α), 1)))) : filter.tendsto (λ (n : ℕ), ∫⁻ (a : α), ↑(⇑(fs n) a) ∂↑μ) filter.at_top (nhds (⇑↑μ E))
{α : Type u₁} {β : Type u₂} [topological_space α] [uniform_space β] {K : set α} {V : set (β × β)} (f : C(α, β)) (hK : is_compact K) (hV : V ∈ uniformity β) : ∃ (ι : Type u₁) [_inst_3 : fintype ι] (C : ι → set α) (hC : ∀ (i : ι), is_compact (C i)) (U : ι → set β) (hU : ∀ (i : ι), is_open (U i)), (f ∈ ⋂ (i : ι), continuous_map.compact_open.gen (C i) (U i)) ∧ (⋂ (i : ι), continuous_map.compact_open.gen (C i) (U i)) ⊆ continuous_map.compact_conv_nhd K V f
{C : Type u} [category_theory.category C] {W X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} [category_theory.limits.has_pullback f g] (h : W ⟶ X) (k : W ⟶ Y) (w : h ≫ f = k ≫ g) : {l // l ≫ category_theory.limits.pullback.fst = h ∧ l ≫ category_theory.limits.pullback.snd = k}
{E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] (I : model_with_corners ℝ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} {U : M → set M} [t2_space M] [sigma_compact_space M] (hs : is_closed s) (hU : ∀ (x : M), x ∈ s → U x ∈ nhds x) : ∃ (ι : Type uM) (f : smooth_bump_covering ι I M s), f.is_subordinate U
{σ : Type u_1} {R : Type u_3} [comm_semiring R] (p : ℕ) : mv_polynomial σ R →ₐ[R] mv_polynomial σ R
{δ : Type u_4} {π : δ → Type u_5} [Π (x : δ), measurable_space (π x)] (l : list δ) (μ : Π (i : δ), measure_theory.measure (π i)) : measure_theory.measure (list.tprod π l)
(π α : Type) : Type
{k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {A : Type u₃} [semiring A] [algebra k A] ⦃φ₁ φ₂ : monoid_algebra k G →ₐ[k] A⦄ (h : ↑φ₁.comp (monoid_algebra.of k G) = ↑φ₂.comp (monoid_algebra.of k G)) : φ₁ = φ₂
{K : Type u_1} {σ : Type u_2} [fintype K] [field K] [fintype σ] [decidable_eq K] [decidable_eq σ] (p : ℕ) [char_p K p] {f : mv_polynomial σ K} (h : f.total_degree < fintype.card σ) : p ∣ fintype.card {x // ⇑(mv_polynomial.eval x) f = 0}
{α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} {C : set (set α)} (hA : m0 = measurable_space.generate_from C) (hC : is_pi_system C) (h : μ.finite_spanning_sets_in C) (h_eq : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s) : μ = ν
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} [measurable_space α] {μ : measure_theory.measure α} [topological_space β] [topological_space γ] [topological_space δ] (g : β → γ → δ) (hg : continuous (function.uncurry g)) (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) : α →ₘ[μ] δ
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_multicoequalizer I] [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] : ∐ I.right ⟶ category_theory.limits.multicoequalizer I
{α : Type u_1} [measurable_space α] (μ : measure_theory.measure α) {f : α → ennreal} (hf : measurable f) {s : set α} (hs : measurable_set s) {t : nnreal} (ht : 1 < t) : ⇑μ s = ⇑μ (s ∩ f ⁻¹' {0}) + ⇑μ (s ∩ f ⁻¹' {⊤}) + ∑' (n : ℤ), ⇑μ (s ∩ f ⁻¹' set.Ico (↑t ^ n) (↑t ^ (n + 1)))
(e : expr) (md : tactic.transparency := tactic.transparency.instances) : tactic expr
{V : Type u_1} {W : Type u_2} {V₁ : Type u_3} [semi_normed_group V] [semi_normed_group W] [semi_normed_group V₁] {f g : normed_group_hom V W} : {φ // f.comp φ = g.comp φ} ≃ normed_group_hom V₁ ↥(f.equalizer g)
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] : category_theory.limits.multicofork I ≌ category_theory.limits.cofork I.fst_sigma_map I.snd_sigma_map
{ι : Type u_1} (I : box_integral.box ι) : Type u_1
{J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {t : category_theory.limits.cocone F} (h : category_theory.limits.is_colimit t) (W : C) : ulift (t.X ⟶ W) ≅ F ⟶ (category_theory.functor.const J).obj W
{R : Type u} {M : Type v} [monoid R] [mul_action R M] {p : sub_mul_action R M} (m : ↥p) : coe '' mul_action.orbit R m = mul_action.orbit R ↑m
{K : Type u_1} [field K] {V : Type u_2} [add_comm_group V] [module K V] [finite_dimensional K V] {W : Type u_3} [add_comm_group W] [module K W] [finite_dimensional K W] {A : Type u_4} [ring A] [algebra K A] [module A V] [is_scalar_tower K A V] [module A W] [is_scalar_tower K A W] : finite_dimensional K (V →ₗ[A] W)
{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {t : set α} (Hf : monotone_on f t) {a : α} (Ha : is_least t a) : is_least (f '' t) (f a)
{α : Type u_1} {E : Type u_4} [measurable_space α] [normed_group E] {μ : measure_theory.measure α} (P : (α → E) → Prop) (h_ind : ∀ (c : E) ⦃s : set α⦄, measurable_set s → ⇑μ s < ⊤ → P (s.indicator (λ (_x : α), c))) (h_add : ∀ ⦃f g : α → E⦄, disjoint (function.support f) (function.support g) → measure_theory.integrable f μ → measure_theory.integrable g μ → P f → P g → P (f + g)) (h_closed : is_closed {f : ↥(measure_theory.Lp E 1 μ) | P ⇑f}) (h_ae : ∀ ⦃f g : α → E⦄, f =ᵐ[μ] g → measure_theory.integrable f μ → P f → P g) ⦃f : α → E⦄ (hf : measure_theory.integrable f μ) : P f
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [metric_space β] {μ : measure_theory.measure α} {s : set α} {ε : ℝ} {f : ι → α → β} {g : α → β} [semilattice_sup ι] [nonempty ι] [encodable ι] (hε : 0 < ε) (hf : ∀ (n : ι), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hsm : measurable_set s) (hs : ⇑μ s ≠ ⊤) (hfg : ∀ᵐ (x : α) ∂μ, x ∈ s → filter.tendsto (λ (n : ι), f n x) filter.at_top (nhds (g x))) (n : ℕ) : ι
{α : Type u_1} {E : Type u_2} {m m₂ m0 : measurable_space α} {μ : measure_theory.measure α} [topological_space E] [has_zero E] (hm : m ≤ m0) {s : set α} {f : α → E} (hs_m : measurable_set s) (hs : ∀ (t : set α), measurable_set (s ∩ t) → measurable_set (s ∩ t)) (hf : measure_theory.ae_strongly_measurable' m f μ) (hf_zero : f =ᵐ[μ.restrict sᶜ] 0) : measure_theory.ae_strongly_measurable' m₂ f μ
(n : ℕ := 1) : tactic unit
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) (f : α → ennreal) (h : ∀ (p q : nnreal), p < q → (∃ (u v : set α), measurable_set u ∧ measurable_set v ∧ {x : α | f x < ↑p} ⊆ u ∧ {x : α | ↑q < f x} ⊆ v ∧ ⇑μ (u ∩ v) = 0)) : ae_measurable f μ
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {x : M} {s : set M} [Is : smooth_manifold_with_corners I M] [I's : smooth_manifold_with_corners I' M'] {f' f₁' : tangent_space I x →L[𝕜] tangent_space I' (f x)} (U : unique_mdiff_within_at I s x) (h : has_mfderiv_within_at I I' f s x f') (h₁ : has_mfderiv_within_at I I' f s x f₁') : f' = f₁'
{R : Type u} {σ : Type u_1} [comm_semiring R] (p : mv_polynomial σ R) : ℕ
{C : Type u} [category_theory.category C] {X Y : C} {J : category_theory.grothendieck_topology C} {f : Y ⟶ X} {S : J.cover X} (I : (S.pullback f).relation) : S.relation
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f (⇑σ i) * g i) ≤ finset.univ.sum (λ (i : ι), f i * g i)
{M : Type u_1} [monoid M] {γ : Type u_2} [monoid γ] {f : M → γ} (hf : is_monoid_hom f) {s : set M} (hs : is_submonoid s) : is_submonoid (f '' s)
{K : Type u_1} [field K] {V : Type u_2} [add_comm_group V] [module K V] [finite_dimensional K V] {W : Type u_3} [add_comm_group W] [module K W] [finite_dimensional K W] : finite_dimensional.finrank K (V →ₗ[K] W) = finite_dimensional.finrank K V * finite_dimensional.finrank K W
(R : Type u) [semiring R] {ι : Type v} {α : ι → Type u_1} {δ : Π (i : ι), α i → Type w} [Π (i : ι) (j : α i), add_comm_monoid (δ i j)] [Π (i : ι) (j : α i), module R (δ i j)] : direct_sum (Σ (i : ι), α i) (λ (i : Σ (i : ι), α i), δ i.fst i.snd) →ₗ[R] direct_sum ι (λ (i : ι), direct_sum (α i) (λ (j : α i), δ i j))
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} {σ : Type u_3} [inhabited Λ] (M : Λ → turing.TM1.stmt Γ Λ σ) (S : finset Λ) : Prop
{R : Type u_1} [comm_monoid_with_zero R] (f : nat.arithmetic_function R) (hf : f.is_multiplicative) {n : ℕ} : n ≠ 0 → ⇑f n = n.factorization.prod (λ (p k : ℕ), ⇑f (p ^ k))
{α : Type u} [pseudo_metric_space α] {β : Type u_1} {p : β → Prop} {f : β → ℝ} (hf₀ : ∀ (x : β), p x → 0 < f x) (hf : ∀ (ε : ℝ), 0 < ε → (∃ (x : β) (hx : p x), f x ≤ ε)) : (uniformity α).has_basis p (λ (x : β), {p : α × α | has_dist.dist p.fst p.snd ≤ f x})
(var : string) (β : Prop → Prop) [I : Π (b : bool), slim_check.testable (β ↥b)] : slim_check.testable (slim_check.named_binder var (∀ (p : Prop), β p))
{α : Type u_1} {E' : Type u_6} {E'' : Type u_9} [semi_normed_group E'] [normed_group E''] {f' : α → E'} {l : filter α} {c : E''} (hc : c ≠ 0) : (λ (x : α), c) =O[l] f' ↔ ∃ (b : ℝ), 0 < b ∧ ∀ᶠ (x : α) in l, b ≤ ∥f' x∥
{α : Type u_1} [topological_space α] {m : measurable_space α} [topological_space.second_countable_topology α] [conditionally_complete_linear_order α] [order_topology α] [borel_space α] [no_max_order α] (μ ν : measure_theory.measure α) [measure_theory.is_locally_finite_measure μ] (h : ∀ ⦃a b : α⦄, a < b → ⇑μ (set.Ico a b) = ⇑ν (set.Ico a b)) : μ = ν
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [complete_space F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] [complete_space G] (φ : implicit_function_data 𝕜 E F G) (x : E) : F × G
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.prepartition I) [fintype ι] (x : ι → ℝ) : (finset.filter (λ (J : box_integral.box ι), x ∈ ⇑box_integral.box.Icc J) π.boxes).card ≤ 2 ^ fintype.card ι
{E : Type u_1} [normed_group E] [measurable_space E] [normed_space ℝ E] [finite_dimensional ℝ E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (s : set E) (x : E) (h : filter.tendsto (λ (r : ℝ), ⇑μ (s ∩ metric.closed_ball x r) / ⇑μ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 1)) (t : set E) (ht : measurable_set t) (h't : ⇑μ t ≠ 0) : ∀ᶠ (r : ℝ) in nhds_within 0 (set.Ioi 0), (s ∩ ({x} + r • t)).nonempty
{𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_group G] [normed_space 𝕜 G] {f : 𝕜 → G} {s : set 𝕜} {x y : 𝕜} {C : ℝ} (hf : ∀ (x : 𝕜), x ∈ s → differentiable_at 𝕜 f x) (bound : ∀ (x : 𝕜), x ∈ s → ∥deriv f x∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {H : Type u_4} [topological_space H] {I : model_with_corners 𝕜 E H} {H' : Type u_5} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {N : Type u_6} [topological_space N] [charted_space H N] {R : Type u_7} [comm_ring R] [topological_space R] [charted_space H' R] [smooth_ring I' R] (n : N) : cont_mdiff_map I I' N R ⊤ →+* R
{Γ : Type u_1} [inhabited Γ] {Γ' : Type u_2} [inhabited Γ'] {Λ : Type u_3} [inhabited Λ] {Λ' : Type u_4} [inhabited Λ'] (f : turing.pointed_map Γ Γ') (g : Λ → Λ') : turing.TM0.cfg Γ Λ → turing.TM0.cfg Γ' Λ'
{X : Type u_1} [topological_space X] [sigma_compact_space X] [measurable_space X] (μ : measure_theory.measure X) : μ.inner_regular is_compact is_closed
{α : Type u} {β : Type v} (R : Type u_1) [monoid R] (e : α ≃ β) [add_comm_monoid β] : let _inst : add_comm_monoid α := e.add_comm_monoid in Π [_inst_3 : distrib_mul_action R β], distrib_mul_action R α
{C : Type u} [category_theory.category C] {D : Type u₂} [category_theory.category D] {X Y : C} {f g : X ⟶ Y} {Z : C} {π : Y ⟶ Z} (q : category_theory.is_split_coequalizer f g π) (F : C ⥤ D) : category_theory.is_split_coequalizer (F.map f) (F.map g) (F.map π)
{C : Type u} [category_theory.category C] {X Y : C} (f : X ⟶ Y) {Z : C} (g : Y ⟶ Z) {W : C} (h : Z ⟶ W) [category_theory.limits.has_image (g ≫ h)] [category_theory.limits.has_image (f ≫ g ≫ h)] [category_theory.limits.has_image h] [category_theory.limits.has_image ((f ≫ g) ≫ h)] : category_theory.limits.image.pre_comp f (g ≫ h) ≫ category_theory.limits.image.pre_comp g h = category_theory.limits.image.eq_to_hom _ ≫ category_theory.limits.image.pre_comp (f ≫ g) h
{α : Type u_1} {σ : α → Type u_2} (l₁ : list α) (l₂ : Π (a : α), list (σ a)) : list (Σ (a : α), σ a)
{ι : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [semiring A] [algebra R A] {𝒜 : ι → submodule R A} [decidable_eq ι] [add_monoid ι] [graded_algebra 𝒜] (I : homogeneous_ideal 𝒜) : ideal A
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group β] (f g : ↥(measure_theory.Lp β 1 μ)) : ∥f - g∥ = (∫⁻ (x : α), ↑∥⇑f x - ⇑g x∥₊ ∂μ).to_real
{α : Type u_1} {β : Type u_2} {m : measurable_space α} [measurable_space β] {μ : measure_theory.measure α} (f : α → β) (h : ae_measurable f μ) : α → β
{R : Type u} [comm_ring R] (I J : ideal R) : R →+* (R ⧸ I) ⧸ ideal.map (ideal.quotient.mk I) J
{E : Type u} [normed_group E] [normed_space ℝ E] [complete_space E] {n : ℕ} (I : box_integral.box (fin (n + 1))) (f : (fin (n + 1) → ℝ) → fin (n + 1) → E) (f' : (fin (n + 1) → ℝ) → ((fin (n + 1) → ℝ) →L[ℝ] fin (n + 1) → E)) (s : set (fin (n + 1) → ℝ)) (hs : s.countable) (Hc : continuous_on f (⇑box_integral.box.Icc I)) (Hd : ∀ (x : fin (n + 1) → ℝ), x ∈ ⇑box_integral.box.Ioo I  s → has_fderiv_at f (f' x) x) (Hi : measure_theory.integrable_on (λ (x : fin (n + 1) → ℝ), finset.univ.sum (λ (i : fin (n + 1)), ⇑(f' x) (pi.single i 1) i)) (⇑box_integral.box.Icc I) measure_theory.measure_space.volume) : ∫ (x : fin (n + 1) → ℝ) in ⇑box_integral.box.Icc I, finset.univ.sum (λ (i : fin (n + 1)), ⇑(f' x) (pi.single i 1) i) = finset.univ.sum (λ (i : fin (n + 1)), (∫ (x : fin n → ℝ) in ⇑box_integral.box.Icc (I.face i), f (i.insert_nth (I.upper i) x) i) - ∫ (x : fin n → ℝ) in ⇑box_integral.box.Icc (I.face i), f (i.insert_nth (I.lower i) x) i)
{ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (f : smooth_partition_of_unity ι I M s) (U : ι → set M) : Prop
{g : matrix.special_linear_group (fin 2) ℤ} {z : upper_half_plane} (hz : z ∈ modular_group.fdo) (hg : g • z ∈ modular_group.fdo) : |↑g 1 0| ≤ 1
(R : Type u) [semiring R] {ι : Type v} [dec_ι : decidable_eq ι] {M : ι → Type w} [Π (i : ι), add_comm_monoid (M i)] [Π (i : ι), module R (M i)] {N : Type u₁} [add_comm_monoid N] [module R N] {φ : Π (i : ι), M i →ₗ[R] N} (i : ι) (x : M i) : ⇑(direct_sum.to_module R ι N φ) (⇑(direct_sum.lof R ι M i) x) = ⇑(φ i) x
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {I : ideal R} {N N' : submodule R M} (hN' : N'.fg) (hIJ : I ≤ ⊥.jacobson) (hNN : N ⊔ N' ≤ N ⊔ I • N') : I • N' ≤ N
{E : Type u_3} {F : Type u_4} [semi_normed_group E] [semi_normed_group F] (f : E →+ F) (C : ℝ) (h : ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥) : continuous ⇑f
{I : Type u} (f : I → Type v) [decidable_eq I] [Π (i : I), mul_one_class (f i)] (i : I) : f i →* Π (i : I), f i
{X : Type u_1} [emetric_space X] {ι : Type u_2} {I : finset ι} {s : set X} {t : ι → set X} : (∀ (i : ι), i ∈ I → is_metric_separated s (t i)) → is_metric_separated s (⋃ (i : ι) (H : i ∈ I), t i)
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [category_theory.limits.has_wide_coequalizer f] [nonempty J] {W : C} (k : Y ⟶ W) (h : ∀ (j₁ j₂ : J), f j₁ ≫ k = f j₂ ≫ k) : {l // category_theory.limits.wide_coequalizer.π f ≫ l = k}
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {n : with_top ℕ} {E'' : Type u_14} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {t : set M'} {g : M' → M''} (x : M) (hg : cont_mdiff_within_at I' I'' n g t (f x)) (hf : cont_mdiff_within_at I I' n f s x) : cont_mdiff_within_at I I'' n (g ∘ f) (s ∩ f ⁻¹' t) x
{α : Type u_1} {t : set α} {m0 : measurable_space α} {m : set (measure_theory.measure α)} (hm : m.nonempty) (ht : measurable_set t) : (has_Inf.Inf m).restrict t = has_Inf.Inf ((λ (μ : measure_theory.measure α), μ.restrict t) '' m)
{R : Type u_1} {L : Type u_2} [comm_ring R] [lie_ring L] [lie_algebra R L] {H K : lie_subalgebra R L} (h₁ : H ≤ K) (h₂ : K ≤ H.normalizer) : ∃ (I : lie_ideal R ↥K), ↑I = lie_subalgebra.of_le h₁
{α : Type u_1} [semi_normed_group α] {r C : ℝ} {f : ℕ → α} (hr : r < 1) (hf : ∀ (n : ℕ), ∥f n∥ ≤ C * r ^ n) {a : α} (ha : has_sum f a) (n : ℕ) : ∥(finset.range n).sum (λ (x : ℕ), f x) - a∥ ≤ C * r ^ n / (1 - r)
{α : Type u} {π : α → Type v} (s : set α) (f : Π (a : α), π a) (a : ↥s) : π ↑a
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f (⇑σ i) * g i) = s.sum (λ (i : ι), f i * g i) ↔ antivary_on (f ∘ ⇑σ) g ↑s
{L : first_order.language} {ι : Type u_3} [encodable ι] [preorder ι] [is_directed ι has_le.le] [nonempty ι] {G : ι → Type w} [Π (i : ι), L.Structure (G i)] (f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)) (h : ∀ (i : ι), first_order.language.Structure.cg L (G i)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] : first_order.language.Structure.cg L (first_order.language.direct_limit G f)
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i * g (⇑σ i)) = finset.univ.sum (λ (i : ι), f i * g i) ↔ antivary f (g ∘ ⇑σ)
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) {s : set α} (hs : measurable_set s) {t : nnreal} (ht : 1 < t) : ⇑ρ s ≤ ↑t * ⇑(μ.with_density (v.lim_ratio_meas hρ)) s
{R : Type u_1} [semiring R] {φ ψ : power_series R} (h : ∀ (n : ℕ), ⇑(power_series.coeff R n) φ = ⇑(power_series.coeff R n) ψ) : φ = ψ
{G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure G} {f : G → E} {g : G} [add_group G] [has_measurable_add G] [μ.is_add_left_invariant] (hf' : ∀ (x : G), f (g + x) = -f x) : ∫ (x : G), f x ∂μ = 0
{α : Type u_1} {m0 : measurable_space α} (μ : measure_theory.measure α) (f : filter α) : Prop
{α : Type u} {σ : Type v} (M : ε_NFA α σ) (S : set σ) (a : α) : set σ
{α : Type u_1} {β : Type u_2} [measurable_space α] [topological_space α] [topological_space.pseudo_metrizable_space α] [opens_measurable_space α] [topological_space β] [topological_space.pseudo_metrizable_space β] {f : α → β} {s : set α} {μ : measure_theory.measure α} (hf : continuous_on f s) (hs : measurable_set s) (h's : topological_space.is_separable s) : measure_theory.ae_strongly_measurable f (μ.restrict s)
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} [normed_group E] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] ⦃f : α → β → E⦄ (hf : measure_theory.strongly_measurable (function.uncurry f)) : measure_theory.strongly_measurable (λ (y : β), ∫ (x : α), f x y ∂μ)
{L : first_order.language} {M : Type w} [L.Structure M] ⦃s t : set M⦄ (h : s ⊆ t) : ⇑(first_order.language.substructure.closure L) s ≤ ⇑(first_order.language.substructure.closure L) t
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w₁} [category_theory.category D] {E : Type w₂} [category_theory.category E] [∀ (α β : Type (max v u)) (fst snd : β → α), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) D] [∀ (α β : Type (max v u)) (fst snd : β → α), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) E] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ D] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ E] (P : Cᵒᵖ ⥤ D) [Π (F : D ⥤ E) (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)ᵒᵖ F] [Π (F : D ⥤ E) (X : C) (W : J.cover X) (P : Cᵒᵖ ⥤ D), category_theory.limits.preserves_limit (W.index P).multicospan F] : (category_theory.whiskering_left Cᵒᵖ D E).obj (J.sheafify P) ≅ (category_theory.whiskering_left Cᵒᵖ D E).obj P ⋙ J.sheafification E
{α : Type u} {σ : Type v} (M : DFA α σ) (start : σ) : list α → σ
{k : Type u_1} [field k] {σ : Type u_2} (I : ideal (mv_polynomial σ k)) : set (σ → k)
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (expr × list expr)
{G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {μ : measure_theory.measure G} {Γ : add_subgroup G} {𝓕 : set G} (h𝓕 : measure_theory.is_add_fundamental_domain ↥(Γ.opposite) 𝓕 μ) [encodable ↥Γ] [measurable_space (G ⧸ Γ)] [borel_space (G ⧸ Γ)] [Γ.normal] [μ.is_add_left_invariant] [μ.is_add_right_invariant] : (measure_theory.measure.map ⇑(quotient_add_group.mk' Γ) (μ.restrict 𝓕)).is_add_left_invariant
{α : Sort u_1} {σ : α → Sort u_4} (P : Prop) [decidable P] (f g : Π (a : α), σ a) (a : α) : ite P f g a = ite P (f a) (g a)
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I J : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} [complete_space F] (h : box_integral.integrable I l f vol) (hJ : J ≤ I) : filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I (box_integral.prepartition.single I J hJ)) (nhds (box_integral.integral J l f vol))
{α : Type u_1} {E : Type u_4} {𝕜 : Type u_6} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} [normed_field 𝕜] [normed_space 𝕜 E] : has_scalar 𝕜 ↥(measure_theory.Lp.simple_func E p μ)
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f i * g (⇑σ i)) < finset.univ.sum (λ (i : ι), f i * g i) ↔ ¬monovary f (g ∘ ⇑σ)
{α : Type u_1} [generalized_boolean_algebra α] {f : ℕ → α} {p : α → Sort u_2} (hdiff : Π ⦃t : α⦄ ⦃i : ℕ⦄, p t → p (t  f i)) ⦃n : ℕ⦄ : p (f n) → p (disjointed f n)
{α : Type u} {C : free_add_magma α → Sort l} (x : free_add_magma α) (ih1 : Π (x : α), C (has_pure.pure x)) (ih2 : Π (x y : free_add_magma α), C x → C y → C (x + y)) : C x
{G : Type u_1} [measurable_space G] [has_inv G] (μ : measure_theory.measure G) : measure_theory.measure G
(e : expr) (show_expr : bool := bool.tt) : tactic (list (widget.html empty))
{Ω : Type u_1} [measure_theory.measure_space Ω] [measure_theory.is_probability_measure measure_theory.measure_space.volume] (X : ℕ → Ω → ℝ) (hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume) (hident : ∀ (i : ℕ), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume) (hnonneg : ∀ (i : ℕ) (ω : Ω), 0 ≤ X i ω) : ∀ᵐ (ω : Ω), (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), probability_theory.truncation (X i) ↑i ω) - (finset.range n).sum (λ (i : ℕ), X i ω)) =o[filter.at_top] λ (n : ℕ), ↑n
{α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.weakly_regular] ⦃A : set α⦄ (hA : measurable_set A) (h'A : ⇑μ A ≠ ⊤) {r : ennreal} (hr : r < ⇑μ A) : ∃ (K : set α) (H : K ⊆ A), is_closed K ∧ r < ⇑μ K
{α : Type u_1} {E : Type u_3} [measurable_space α] {ι : Type u_5} [normed_group E] [topological_space α] [opens_measurable_space α] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} [measure_theory.is_locally_finite_measure μ] {a : α} {f : α → E} (ha : continuous_at f a) (hfm : strongly_measurable_at_filter f (nhds a) μ) {s : ι → set α} {li : filter ι} (hs : filter.tendsto s li (nhds a).small_sets) (m : ι → ℝ := λ (i : ι), (⇑μ (s i)).to_real) (hsμ : (λ (i : ι), (⇑μ (s i)).to_real) =ᶠ[li] m . "refl") : (λ (i : ι), ∫ (x : α) in s i, f x ∂μ - m i • f a) =o[li] m
{C : Type u₁} [category_theory.category C] (X Y : C) (p : Π {Z : C}, (Z ⟶ X) → (Z ⟶ Y)) (q : Π {Z : C}, (Z ⟶ Y) → (Z ⟶ X)) (h₁ : ∀ {Z : C} (f : Z ⟶ X), q (p f) = f) (h₂ : ∀ {Z : C} (f : Z ⟶ Y), p (q f) = f) (n : ∀ {Z Z' : C} (f : Z' ⟶ Z) (g : Z ⟶ X), p (f ≫ g) = f ≫ p g) : X ≅ Y
{α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} {f : ℕ → α → β} {g : α → β} [measure_theory.is_finite_measure μ] (hp : 1 ≤ p) (hp' : p ≠ ⊤) (hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ) (hg : measure_theory.mem_ℒp g p μ) : measure_theory.tendsto_in_measure μ f filter.at_top g ∧ measure_theory.unif_integrable f p μ ↔ filter.tendsto (λ (n : ℕ), measure_theory.snorm (f n - g) p μ) filter.at_top (nhds 0)
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {β' : Type u_4} {δ : Type u_7} {ε : Type u_9} [decidable_eq α'] [decidable_eq β'] [decidable_eq δ] [decidable_eq ε] {s : finset α} {t : finset β} {γ : Type u_5} {u : finset γ} {f : δ → γ → ε} {g : α → β → δ} {f₁ : α → γ → α'} {f₂ : β → γ → β'} {g' : α' → β' → ε} (h_distrib : ∀ (a : α) (b : β) (c : γ), f (g a b) c = g' (f₁ a c) (f₂ b c)) : finset.image₂ f (finset.image₂ g s t) u ⊆ finset.image₂ g' (finset.image₂ f₁ s u) (finset.image₂ f₂ t u)
{R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] {e : ι → M} {ε : ι → module.dual R M} [decidable_eq ι] (h : dual_pair e ε) (m : M) : dual_pair.lc e (h.coeffs m) = m
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z} (s : category_theory.comm_sq f g h i) : category_theory.comm_sq (F.map f) (F.map g) (F.map h) (F.map i)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [nontrivial k] {p : ι → P} (ha : affine_independent k p) (i : ι) (s : set ι) : p i ∉ affine_span k (p '' (s  {i}))
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] ⦃f : α → β → ennreal⦄ (hf : ae_measurable (function.uncurry f) (μ.prod ν)) : ∫⁻ (x : α), ∫⁻ (y : β), f x y ∂ν ∂μ = ∫⁻ (z : β × α), f z.snd z.fst ∂ν.prod μ
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p₁ : P} (hp₁ : p₁ ∈ s) : affine_independent k (λ (p : ↥s), ↑p) ↔ linear_independent k (λ (v : ↥((λ (p : P), p -ᵥ p₁) '' (s  {p₁}))), ↑v)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] [topological_space γ] {g : β → γ} {f : α → β} (hg : continuous g) (hf : measure_theory.ae_strongly_measurable f μ) : measure_theory.ae_strongly_measurable (λ (x : α), g (f x)) μ
{ι : Type u_1} {I J Js : box_integral.box ι} {s : finset (ι × ℝ)} (H : ∀ (i : ι), {(i, J.lower i), (i, J.upper i)} ⊆ s) (HJs : Js ∈ box_integral.prepartition.split_many I s) (Hn : ¬disjoint ↑J ↑Js) : Js ≤ J
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {F F' : 𝕜 → α → E} {x₀ : 𝕜} {ε : ℝ} (ε_pos : 0 < ε) (hF_meas : ∀ᶠ (x : 𝕜) in nhds x₀, measure_theory.ae_strongly_measurable (F x) μ) (hF_int : measure_theory.integrable (F x₀) μ) (hF'_meas : measure_theory.ae_strongly_measurable (F' x₀) μ) {bound : α → ℝ} (h_bound : ∀ᵐ (a : α) ∂μ, ∀ (x : 𝕜), x ∈ metric.ball x₀ ε → ∥F' x a∥ ≤ bound a) (bound_integrable : measure_theory.integrable bound μ) (h_diff : ∀ᵐ (a : α) ∂μ, ∀ (x : 𝕜), x ∈ metric.ball x₀ ε → has_deriv_at (λ (x : 𝕜), F x a) (F' x a) x) : measure_theory.integrable (F' x₀) μ ∧ has_deriv_at (λ (n : 𝕜), ∫ (a : α), F n a ∂μ) (∫ (a : α), F' x₀ a ∂μ) x₀
{η : Type u_5} {f : η → Type u_6} [Π (i : η), add_group (f i)] (I : set η) (H : Π (i : η), add_subgroup (f i)) : add_subgroup (Π (i : η), f i)
(R : Type u_1) [comm_ring R] (I : ideal R) : Prop
{M : Type u_1} [add_zero_class M] ⦃s t : set M⦄ (h : s ⊆ t) : add_submonoid.closure s ≤ add_submonoid.closure t
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] (c : category_theory.limits.fork I.fst_pi_map I.snd_pi_map) : category_theory.limits.multifork I
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (f : E → F) (K : set (E →L[𝕜] F)) (r s ε : ℝ) : set E
{α : Type u_1} {E : Type u_3} [semi_normed_group E] {l : filter α} {f : α → E} (h : filter.tendsto (λ (y : α), ∥f y∥) l filter.at_top) (x : E) : ∀ᶠ (y : α) in l, f y ≠ x
(tac : tactic unit := tactic.skip) : tactic unit
{elab : bool := bool.tt} : expr elab → option (name × binder_info × expr elab × expr elab)
{α : Type u} {β : Type v} [topological_space α] [compact_space α] [pseudo_metric_space β] (s : set β) (hs : is_compact s) (A : set (bounded_continuous_function α β)) (closed : is_closed A) (in_s : ∀ (f : bounded_continuous_function α β) (x : α), f ∈ A → ⇑f x ∈ s) (H : ∀ (x : α) (ε : ℝ), ε > 0 → (∃ (U : set α) (H : U ∈ nhds x), ∀ (y : α), y ∈ U → ∀ (z : α), z ∈ U → ∀ (f : bounded_continuous_function α β), f ∈ A → has_dist.dist (⇑f y) (⇑f z) < ε)) : is_compact A
{R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] ⦃j k : S →* P⦄ (h : j.comp ↑(algebra_map R S) = k.comp ↑(algebra_map R S)) : j = k
{G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {μ : measure_theory.measure G} [add_group G] [topological_add_group G] [μ.is_add_left_invariant] (K : set G) (hK : is_compact K) (h : ⇑μ K ≠ 0) : μ.is_open_pos_measure
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {σ : Type u_4} [inhabited σ] {k : K} (v : σ) (l : list (Γ k)) : turing.TM2to1.st_act k → list (Γ k)
{α : Type u} [preorder α] ⦃s t : set α⦄ (h : s ⊆ t) : bdd_above t → bdd_above s
{𝕜 : Type u_1} {G : Type u_2} {F : Type u_6} [normed_group F] {x : G} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 F] [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [has_sub G] {f : G → 𝕜} {g : G → F} : convolution f g (continuous_linear_map.lsmul 𝕜 𝕜) μ x = ∫ (t : G), f t • g (x - t) ∂μ
{C : Type u} [category_theory.category C] {W X Y Z S T : C} (f₁ : W ⟶ S) (f₂ : X ⟶ S) [category_theory.limits.has_pullback f₁ f₂] (g₁ : Y ⟶ T) (g₂ : Z ⟶ T) [category_theory.limits.has_pullback g₁ g₂] (i₁ : W ⟶ Y) (i₂ : X ⟶ Z) (i₃ : S ⟶ T) (eq₁ : f₁ ≫ i₃ = i₁ ≫ g₁) (eq₂ : f₂ ≫ i₃ = i₂ ≫ g₂) : category_theory.limits.pullback f₁ f₂ ⟶ category_theory.limits.pullback g₁ g₂
{F : Type u → Type u} [functor F] [q : qpf F] {G : Type u → Type u} [functor G] {FG_abs : Π {α : Type u}, F α → G α} {FG_repr : Π {α : Type u}, G α → F α} (FG_abs_repr : ∀ {α : Type u} (x : G α), FG_abs (FG_repr x) = x) (FG_abs_map : ∀ {α β : Type u} (f : α → β) (x : F α), FG_abs (ffunctor.map <$> x) = ffunctor.map <$> FG_abs x) : qpf G
{ι : Type v} {α : ι → Type u} {δ : Π (i : ι), α i → Type w} [Π (i : ι) (j : α i), add_comm_monoid (δ i j)] : direct_sum (Σ (i : ι), α i) (λ (i : Σ (i : ι), α i), δ i.fst i.snd) ≃+ direct_sum ι (λ (i : ι), direct_sum (α i) (λ (j : α i), δ i j))
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] {σ : Type u_3} [inhabited σ] [fintype Γ] : turing.TM1.stmt Γ Λ σ → finset turing.TM1to1.Λ'
{ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (fs : smooth_bump_covering ι I M s) [compact_space M] : fintype ι
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} {I : category_theory.InjectiveResolution Y} {J : category_theory.InjectiveResolution Z} (f : I.cocomplex ⟶ J.cocomplex) (comm : I.ι ≫ f = 0) : I.cocomplex.X 2 ⟶ J.cocomplex.X 1
{α : Type u} {β : Type v} {φ : ultrafilter α} [ordered_ring β] : ordered_ring (↑φ.germ β)
{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] {a : set (α × α)} (ha : a ∈ uniformity α) {b : set (β × β)} (hb : b ∈ uniformity β) : (λ (p : α × α), (sum.inl p.fst, sum.inl p.snd)) '' a ∪ (λ (p : β × β), (sum.inr p.fst, sum.inr p.snd)) '' b ∈ uniform_space.core.sum.uniformity
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} {W : C} (inl : Y ⟶ W) (inr : Z ⟶ W) (eq : f ≫ inl = g ≫ inr) : category_theory.limits.pushout_cocone f g
{V : Type u_1} [inner_product_space ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : ∥x - y∥ = ∥x∥ + ∥y∥ ↔ inner_product_geometry.angle x y = real.pi
{M : Type u_1} [monoid M] {A : Type u_2} [monoid A] {f : M → A} (hf : is_monoid_hom f) (s : set M) : f '' monoid.closure s = monoid.closure (f '' s)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] {s : set (weak_dual 𝕜 E)} (hb : metric.bounded (⇑normed_space.dual.to_weak_dual ⁻¹' s)) (hc : is_closed s) : is_closed (coe_fn '' s)
{E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] (I : model_with_corners ℝ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [sigma_compact_space M] {s t : set M} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : ∃ (f : cont_mdiff_map I (model_with_corners_self ℝ ℝ) M ℝ ⊤), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : M), ⇑f x ∈ set.Icc 0 1
(p : pexpr) (e : expr) (m : tactic.transparency := tactic.transparency.reducible) : tactic (list expr)
{α : Type u_1} {m0 : measurable_space α} (μ ν : measure_theory.measure α) : Prop
{α : Type u_1} {m : measurable_space α} (μ ν : measure_theory.measure α) : measure_theory.measure α
{X : Type u_1} [topological_space X] [compact_space X] (f : C(X, ℝ)) : C(X, ↥(set.Icc (-∥f∥) ∥f∥))
{ι : Type u_1} {α : ι → Type u_2} {β : ι → Type u_3} {γ : ι → Type u_4} [decidable_eq ι] (f : Π ⦃i : ι⦄, α i → β i → finset (γ i)) (a : sigma α) (b : sigma β) : finset (sigma γ)
{P : Π (α : Type u) [_inst_1 : fintype α], Prop} (of_equiv : ∀ (α β : Type u) [_inst_2 : fintype β] (e : α ≃ β), P α → P β) (h_empty : P pempty) (h_option : ∀ (α : Type u) [_inst_3 : fintype α], P α → P (option α)) (α : Type u) [fintype α] : P α
{α : Type u_1} {E : Type u_4} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} [fact (1 ≤ p)] (hp_ne_top : p ≠ ⊤) (P : (α → E) → Prop) (h_ind : ∀ (c : E) ⦃s : set α⦄, measurable_set s → ⇑μ s < ⊤ → P (s.indicator (λ (_x : α), c))) (h_add : ∀ ⦃f g : α → E⦄, disjoint (function.support f) (function.support g) → measure_theory.mem_ℒp f p μ → measure_theory.mem_ℒp g p μ → P f → P g → P (f + g)) (h_closed : is_closed {f : ↥(measure_theory.Lp E p μ) | P ⇑f}) (h_ae : ∀ ⦃f g : α → E⦄, f =ᵐ[μ] g → measure_theory.mem_ℒp f p μ → P f → P g) ⦃f : α → E⦄ (hf : measure_theory.mem_ℒp f p μ) : P f
{R : Type u} [comm_ring R] (I J : ideal R) : (double_quot.quot_left_to_quot_sup I J).ker = ideal.map (ideal.quotient.mk I) J
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {n : with_top ℕ} (hf : cont_mdiff I I' n f) (hmn : 1 ≤ n) : continuous (tangent_map I I' f)
{V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (θ : real.angle) : o.oangle x y = θ ↔ x ≠ 0 ∧ y ≠ 0 ∧ y = (∥y∥ / ∥x∥) • ⇑(o.rotation θ) x ∨ θ = 0 ∧ (x = 0 ∨ y = 0)
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : ℕ → α → ennreal} (hf : ∀ (n : ℕ), measurable (f n)) (h_mono : ∀ (n : ℕ), ∀ᵐ (a : α) ∂μ, f n a ≤ f n.succ a) : ∫⁻ (a : α), (⨆ (n : ℕ), f n a) ∂μ = ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
{α : Type u_1} {β : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : α → M} {s : set β} {g : β → α} (hg : set.inj_on g (s ∩ function.support (f ∘ g))) : finsum (λ (i : α), finsum (λ (H : i ∈ g '' s), f i)) = finsum (λ (j : β), finsum (λ (H : j ∈ s), f (g j)))
{𝕜 : Type u_1} {_x : ring 𝕜} {E : Type u_2} [semi_normed_group E] {_x_1 : module 𝕜 E} {s : submodule 𝕜 E} (x : ↥s) : ∥↑x∥ = ∥x∥
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] {W X Y Z : C} (f : X ⟶ Y) (g : Z ⟶ W) : category_theory.limits.biprod.map f g ≫ (category_theory.limits.biprod.braiding Y W).hom = (category_theory.limits.biprod.braiding X Z).hom ≫ category_theory.limits.biprod.map g f
{C : Type u₁} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_coproducts C] {A : C} (s : set (category_theory.subobject A)) : (∐ λ (j : ↥(⇑(equiv_shrink (category_theory.subobject A)) '' s)), ↑(⇑((equiv_shrink (category_theory.subobject A)).symm) ↑j)) ⟶ A
{L : first_order.language} {α : Type u'} (φ ψ : L.formula α) : L.formula α
{L : first_order.language} {ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), L.Structure (G i)] (f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] (i : ι) (x : G i) (h : i ≤ i) : ⇑(f i i h) x = x
{𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [semi_normed_group G] [borel_space G] [topological_space.second_countable_topology G] [μ.is_add_left_invariant] [measure_theory.sigma_finite μ] {x₀ : G} {R ε : ℝ} (hε : 0 ≤ ε) (hif : measure_theory.integrable f μ) (hf : function.support f ⊆ metric.ball 0 R) (hmg : measure_theory.ae_strongly_measurable g μ) (hg : ∀ (x : G), x ∈ metric.ball x₀ R → has_dist.dist (g x) (g x₀) ≤ ε) : has_dist.dist (convolution f g L μ x₀) (∫ (t : G), ⇑(⇑L (f t)) (g x₀) ∂μ) ≤ ∥L∥ * ∫ (x : G), ∥f x∥ ∂μ * ε
{α : Type u_1} {ι : Type u_2} [measurable_space α] (s : ι → set α) (μ : measure_theory.measure α . "volume_tac") : Prop
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} (f : α → ennreal) {g : α → ennreal} (hg : measurable g) : ∫⁻ (a : α), f a + g a ∂μ = ∫⁻ (a : α), f a ∂μ + ∫⁻ (a : α), g a ∂μ
{α : Type u_1} [topological_space α] [measurable_space α] {s : set α} (h : is_compact s) (μ : measure_theory.measure α) [measure_theory.is_locally_finite_measure μ] : ∃ (U : set α) (H : U ⊇ s), is_open U ∧ ⇑μ U < ⊤
{I : Type v₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {J : Type v₁} [category_theory.small_category J] {F : J ⥤ Π (i : I), C i} (c : category_theory.limits.cocone F) (i : I) : category_theory.limits.cocone (F ⋙ category_theory.pi.eval C i)
(limit : option ℕ := option.none) (opt : tactic.suggest.suggest_opt := {to_opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := λ (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (λ (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}, compulsory_hyps := list.nil expr, try_this := bool.tt}) : tactic (list string)
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] {F G : V ⥤ W} [F.additive] [G.additive] (α : F ⟶ G) (c : complex_shape ι) : category_theory.functor.map_homotopy_category c F ⟶ category_theory.functor.map_homotopy_category c G
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} (h : box_integral.integrable I l f vol) (π₀ : box_integral.prepartition I) : cauchy (filter.map (box_integral.integral_sum f vol) (l.to_filter_Union I π₀))
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] [measurable_space β] [measurable_space γ] {μ : measure_theory.measure α} {ν : measure_theory.measure β} {f : α → γ} {g : β → γ} [topological_space γ] [topological_space.metrizable_space γ] [borel_space γ] (h : probability_theory.ident_distrib f g μ ν) (hf : measure_theory.ae_strongly_measurable f μ) : measure_theory.ae_strongly_measurable g ν
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {𝒢 : measure_theory.filtration ℕ m0} [measure_theory.is_finite_measure μ] {f : ℕ → α → ℝ} (hadp : measure_theory.adapted 𝒢 f) (hint : ∀ (i : ℕ), measure_theory.integrable (f i) μ) (hf : ∀ (τ π : α → ℕ), measure_theory.is_stopping_time 𝒢 τ → measure_theory.is_stopping_time 𝒢 π → τ ≤ π → (∃ (N : ℕ), ∀ (x : α), π x ≤ N) → ∫ (x : α), measure_theory.stopped_value f τ x ∂μ ≤ ∫ (x : α), measure_theory.stopped_value f π x ∂μ) : measure_theory.submartingale f 𝒢 μ
{ι : Type u_1} (I : box_integral.box ι) : set ι ↪ box_integral.box ι
{f : C(↥unit_interval, ℝ)} {ε : ℝ} {h : 0 < ε} {n : ℕ} {x : ↥unit_interval} {k : fin (n + 1)} (m : k ∈ (bernstein_approximation.S f ε h n x)ᶜ) : 1 ≤ bernstein_approximation.δ f ε h ^ -2 * (↑x - ↑(bernstein.z k)) ^ 2
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.tagged_prepartition I) (p : box_integral.box ι → Prop) : box_integral.tagged_prepartition I
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {𝕜₃ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [nondiscrete_normed_field 𝕜₃] [normed_space 𝕜 E] [normed_space 𝕜₂ F] [normed_space 𝕜₃ G] {σ₂₃ : 𝕜₂ →+* 𝕜₃} {σ₁₃ : 𝕜 →+* 𝕜₃} [ring_hom_isometric σ₂₃] (f : E →ₛₗ[σ₁₃] F →ₛₗ[σ₂₃] G) (C : ℝ) (hC : ∀ (x : E) (y : F), ∥⇑(⇑f x) y∥ ≤ C * ∥x∥ * ∥y∥) : E →SL[σ₁₃] F →SL[σ₂₃] G
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X ⟶ Y) (g : X ⟶ Z) (g' : Z ⟶ W) [category_theory.limits.has_pushout f g] [category_theory.limits.has_pushout category_theory.limits.pushout.inr g'] [category_theory.limits.has_pushout f (g ≫ g')] : category_theory.limits.pushout category_theory.limits.pushout.inr g' ≅ category_theory.limits.pushout f (g ≫ g')
{𝕜 : Type u_1} {G : Type u_2} {F : Type u_6} [normed_group F] {x : G} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 F] [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [μ.is_add_left_invariant] [μ.is_neg_invariant] {f : G → 𝕜} {g : G → F} : convolution f g (continuous_linear_map.lsmul 𝕜 𝕜) μ x = ∫ (t : G), f (x - t) • g t ∂μ
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i * g i) < s.sum (λ (i : ι), f i * g (⇑σ i)) ↔ ¬antivary_on f (g ∘ ⇑σ) ↑s
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) (μ : 𝕜) : module.End.eigenspace (T.restrict _) μ = ⊥
{α : Type u} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] [no_min_order α] [no_max_order α] {a : α} (ha : 0 < a) : (nhds a).has_basis (λ (ε : α), 0 < ε ∧ ε ≤ a) (λ (ε : α), set.Ioo (a - ε) (a + ε))
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {t : set α} {f : α → E} (hs : convex ℝ s) (h0 : ⇑μ t ≠ 0) (ht : ⇑μ t ≠ ⊤) (hfs : ∀ᵐ (x : α) ∂μ.restrict t, f x ∈ s) (hfi : measure_theory.integrable_on f t μ) : ⨍ (x : α) in t, f x ∂μ ∈ closure s
{X : ℕ → Type u} [Π (n : ℕ), metric_space (X n)] {f : Π (n : ℕ), X n → X (n + 1)} (I : ∀ (n : ℕ), isometry (f n)) (n : ℕ) : isometry (metric.to_inductive_limit I n)
{R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] (abv : absolute_value R ℤ) (I : ↥(non_zero_divisors (ideal S))) : ∃ (b : S) (H : b ∈ ↑I), b ≠ 0 ∧ ∀ (c : S), c ∈ ↑I → ⇑abv (⇑(algebra.norm R) c) < ⇑abv (⇑(algebra.norm R) b) → c = 0
{α : Type u} [lattice α] [comm_group α] [covariant_class α α has_mul.mul has_le.le] (a : α) : ||a|| = |a|
{p : ℕ+} {K : Type u} {L : Type v} [field L] {ζ : L} [field K] [algebra K L] [hne : ne_zero ↑↑p] {k s : ℕ} (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) [hpri : fact (nat.prime ↑p)] [hcycl : is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) (hs : s ≤ k) (hk : 1 ≤ k) : ⇑(algebra.norm K) (ζ ^ ↑p ^ s - 1) = ↑p ^ ↑p ^ s
{α : Type u_1} [measurable_space α] {s : measure_theory.signed_measure α} {u v : set α} (hu : measurable_set u) (hv : measurable_set v) (hsu : 0.restrict u ≤ measure_theory.vector_measure.restrict s u) (hsv : 0.restrict v ≤ measure_theory.vector_measure.restrict s v) (hs : ⇑s (u ∆ v) = 0) : ⇑s (u  v) = 0 ∧ ⇑s (v  u) = 0
(δ K ε x : ℝ) : ℝ
{R : Type u_1} [euclidean_domain R] {abv : absolute_value R ℤ} (n : ℕ) (h : abv.is_admissible) {ε : ℝ} (hε : 0 < ε) {b : R} (hb : b ≠ 0) (A : fin (h.card ε ^ n).succ → fin n → R) : ∃ (i₀ i₁ : fin (h.card ε ^ n).succ), i₀ ≠ i₁ ∧ ∀ (k : fin n), ↑(⇑abv (A i₁ k % b - A i₀ k % b)) < ⇑abv b • ε
{α : Type u} {C : free_magma α → Sort l} (x : free_magma α) (ih1 : Π (x : α), C (has_pure.pure x)) (ih2 : Π (x y : free_magma α), C x → C y → C (x * y)) : C x
(ω ω' : out_param (Type u)) (m m' : Type u → Type v) : Type (max (u+1) v)
 : interactive.parse (list.joinlist.joinfunctor.map <$> lean.parser.many tactic.rintro_patt_parse_hi) → tactic unit
{ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (f : smooth_bump_covering ι I M s) (U : M → set M) : Prop
{α : Type u} {β : Type v} (R : Type u_1) [comm_semiring R] (e : α ≃ β) [semiring β] : let _inst : semiring α := e.semiring in Π [_inst_3 : algebra R β], algebra R α
{β : Type v} [conditionally_complete_linear_order β] [topological_space β] [order_topology β] {α : Type u_1} [linear_order α] [topological_space α] [order_topology α] {f : α → β} (Mf : monotone f) (x : α) : filter.tendsto f (nhds_within x (set.Ioi x)) (nhds (has_Inf.Inf (f '' set.Ioi x)))
{E : Type u_1} [normed_group E] [normed_space ℂ E] {R₁ R₂ : ℝ} {f : ℂ → E} {c : ℂ} (hd : differentiable_on ℂ f (metric.ball c R₁)) (h_maps : set.maps_to f (metric.ball c R₁) (metric.ball (f c) R₂)) (h₀ : 0 < R₁) : ∥deriv f c∥ ≤ R₂ / R₁
(opt : tactic.suggest.suggest_opt := {to_opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := λ (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (λ (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}, compulsory_hyps := list.nil expr, try_this := bool.tt}) : tactic string
{α : Type u_1} [topological_space α] {β : Type u_2} [topological_space β] {s : set α} (hs : measure_theory.analytic_set s) {f : α → β} (hf : continuous_on f s) : measure_theory.analytic_set (f '' s)
{α : Type u_1} [measurable_space α] [topological_space α] [opens_measurable_space α] {γ : Type u_2} {F : filter γ} {μs : γ → measure_theory.probability_measure α} {μ : measure_theory.probability_measure α} : filter.tendsto μs F (nhds μ) ↔ ∀ (f : bounded_continuous_function α nnreal), filter.tendsto (λ (i : γ), ∫⁻ (x : α), ↑(⇑f x) ∂↑(μs i)) F (nhds (∫⁻ (x : α), ↑(⇑f x) ∂↑μ))
(ι : Type uι) {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] (I : model_with_corners ℝ E H) (M : Type uM) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (s : set M := set.univ) : Type (max uM uι)
{α : Type u_1} {E : Type u_2} (𝕜 : Type u_4) [is_R_or_C 𝕜] [measurable_space α] {μ : measure_theory.measure α} [inner_product_space 𝕜 E] {s : set α} [complete_space E] [normed_space ℝ E] (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) (c : E) (f : ↥(measure_theory.Lp E 2 μ)) : has_inner.inner (measure_theory.indicator_const_Lp 2 hs hμs c) f = has_inner.inner c (∫ (x : α) in s, ⇑f x ∂μ)
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {I : ideal R} (hM : module.is_torsion_by_set R M ↑I) : module (R ⧸ I) M
{G : Type u_1} [measurable_space G] [add_group G] [has_measurable_add₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] [ν.is_add_left_invariant] : measure_theory.measure.map (λ (z : G × G), (z.fst, z.fst + z.snd)) (μ.prod ν) = μ.prod ν
{α : Type u_2} [measurable_space α] [topological_space α] [topological_space.second_countable_topology α] [opens_measurable_space α] {f : α → α} {μ : measure_theory.measure α} (h : measure_theory.conservative f μ) : ∀ᵐ (x : α) ∂μ, ∀ (s : set α), s ∈ nhds x → (∃ᶠ (n : ℕ) in filter.at_top, f^[n] x ∈ s)
{α : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {m : measurable_space α} {μ μ' : measure_theory.measure α} (T : set α → (E →L[ℝ] F)) (h_zero : ∀ (s : set α), measurable_set s → ⇑μ s = 0 → T s = 0) (h_add : measure_theory.fin_meas_additive μ T) (hμ : μ.absolutely_continuous μ') (f : ↥(measure_theory.Lp.simple_func E 1 μ)) (f' : ↥(measure_theory.Lp.simple_func E 1 μ')) (h : ⇑f =ᵐ[μ] ⇑f') : measure_theory.L1.simple_func.set_to_L1s T f = measure_theory.L1.simple_func.set_to_L1s T f'
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : α → ennreal} (hf : ae_measurable f μ) {ε : ennreal} (hε : ε ≠ 0) (hε' : ε ≠ ⊤) : ⇑μ {x : α | ε ≤ f x} ≤ ∫⁻ (a : α), f a ∂μ / ε
{I : Type v₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {J : Type v₁} [category_theory.small_category J] {F : J ⥤ Π (i : I), C i} {c : Π (i : I), category_theory.limits.cone (F ⋙ category_theory.pi.eval C i)} (P : Π (i : I), category_theory.limits.is_limit (c i)) : category_theory.limits.is_limit (category_theory.pi.cone_of_cone_comp_eval c)
{E : Type u} [normed_group E] [normed_space ℝ E] {n : ℕ} [complete_space E] (I : box_integral.box (fin (n + 1))) (f : (fin (n + 1) → ℝ) → E) (f' : (fin (n + 1) → ℝ) → ((fin (n + 1) → ℝ) →L[ℝ] E)) (s : set (fin (n + 1) → ℝ)) (hs : s.countable) (Hs : ∀ (x : fin (n + 1) → ℝ), x ∈ s → continuous_within_at f (⇑box_integral.box.Icc I) x) (Hd : ∀ (x : fin (n + 1) → ℝ), x ∈ ⇑box_integral.box.Icc I  s → has_fderiv_within_at f (f' x) (⇑box_integral.box.Icc I) x) (i : fin (n + 1)) : box_integral.has_integral I ⊥ (λ (x : fin (n + 1) → ℝ), ⇑(f' x) (pi.single i 1)) box_integral.box_additive_map.volume (box_integral.integral (I.face i) ⊥ (λ (x : fin n → ℝ), f (i.insert_nth (I.upper i) x)) box_integral.box_additive_map.volume - box_integral.integral (I.face i) ⊥ (λ (x : fin n → ℝ), f (i.insert_nth (I.lower i) x)) box_integral.box_additive_map.volume)
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {p : ℝ} {f g : α → ennreal} (hf : ae_measurable f μ) (hg : ae_measurable g μ) (hp1 : 1 ≤ p) : (∫⁻ (a : α), (f + g) a ^ p ∂μ) ^ (1 / p) ≤ (∫⁻ (a : α), f a ^ p ∂μ) ^ (1 / p) + (∫⁻ (a : α), g a ^ p ∂μ) ^ (1 / p)
(p : pexpr) (m : tactic.transparency := tactic.transparency.reducible) : tactic (expr × list expr)
{c : Type u → Type u} {hom : Π ⦃α β : Type u⦄, c α → c β → Type u} [𝒞 : category_theory.bundled_hom hom] {d : Type u → Type u} {hom_d : Π ⦃α β : Type u⦄, d α → d β → Type u} [category_theory.bundled_hom hom_d] (obj : Π ⦃α : Type u⦄, c α → d α) (map : Π {X Y : category_theory.bundled c}, (X ⟶ Y) → (category_theory.bundled.map obj X ⟶ category_theory.bundled.map obj Y)) (h_map : ∀ {X Y : category_theory.bundled c} (f : X ⟶ Y), ⇑(map f) = ⇑f) : category_theory.has_forget₂ (category_theory.bundled c) (category_theory.bundled d)
{𝕜 : Type u_1} {G : Type u_2} {x : G} [nondiscrete_normed_field 𝕜] [measurable_space G] {μ : measure_theory.measure G} [has_sub G] [normed_space ℝ 𝕜] [complete_space 𝕜] {f g : G → 𝕜} : convolution f g (continuous_linear_map.lmul 𝕜 𝕜) μ x = ∫ (t : G), f t * g (x - t) ∂μ
{α : Type u_1} (F : Type u_6) (𝕜 : Type u_11) (p : ennreal) [is_R_or_C 𝕜] [normed_group F] [normed_space 𝕜 F] {m m0 : measurable_space α} (μ : measure_theory.measure α) (hm : m ≤ m0) (f : ↥(measure_theory.Lp_meas F 𝕜 m p μ)) : ↥(measure_theory.Lp F p (μ.trim hm))
{n : ℕ} {K : Type u_8} [field K] {μ : K} (h : is_primitive_root μ n) [char_zero K] {m : ℕ} (hcop : m.coprime n) : (polynomial.map (int.cast_ring_hom K) (minpoly ℤ μ)).is_root (μ ^ m)
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} [category_theory.limits.has_equalizer f g] {W : C} {k l : W ⟶ category_theory.limits.equalizer f g} (h : k ≫ category_theory.limits.equalizer.ι f g = l ≫ category_theory.limits.equalizer.ι f g) : k = l
{E : Type u_1} [semi_normed_group E] {s : add_subgroup E} (x : ↥s) : ∥↑x∥ = ∥x∥
{α : Type u_1} [pseudo_metric_space α] [measurable_space α] [opens_measurable_space α] {μ : measure_theory.measure α} {s : set α} (hs : ∃ (R : ℝ) (H : R > 0), ⇑μ (metric.cthickening R s) ≠ ⊤) (h's : is_closed s) : filter.tendsto (λ (r : ℝ), ⇑μ (metric.cthickening r s)) (nhds 0) (nhds (⇑μ s))
{α : Type u} {β : Type v} [uniform_space α] [uniform_space β] {f : α → β} {s : set α} (hs : totally_bounded s) (hf : uniform_continuous f) : totally_bounded (f '' s)
{n : ℕ+} (K : Type u_1) [field K] {L : Type u_2} [field L] {μ : L} (hμ : is_primitive_root μ ↑n) [algebra K L] [is_cyclotomic_extension {n} K L] : function.injective ⇑(is_primitive_root.aut_to_pow K hμ)
{α : Type u_1} {m : measurable_space α} (μ ν : measure_theory.measure α) : set ennreal
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.tagged_prepartition I) (πi : Π (J : box_integral.box ι), box_integral.prepartition J) : box_integral.tagged_prepartition I
{α : Type u} [t : topological_space α] {s : set (set α)} (hs : t = topological_space.generate_from s) : topological_space.is_topological_basis ((λ (f : set (set α)), ⋂₀ f) '' {f : set (set α) | f.finite ∧ f ⊆ s ∧ (⋂₀ f).nonempty})
{ι : Type u_1} {R : Type u_2} {M : ι → Type u_4} {N : Type u_5} [dec_ι : decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M i)] [Π (i : ι), module R (M i)] [add_comm_monoid N] [module R N] ⦃φ ψ : (Π₀ (i : ι), M i) →ₗ[R] N⦄ (h : ∀ (i : ι) (x : M i), ⇑φ (dfinsupp.single i x) = ⇑ψ (dfinsupp.single i x)) : φ = ψ
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] {I : ideal R} (h : I.fg) (f : R →+* S) : (ideal.map f I).fg
{β : Type w} {C : Type u} [category_theory.category C] {γ : Type v} (ε : β ≃ γ) (f : γ → C) [category_theory.limits.has_product f] [category_theory.limits.has_product (f ∘ ⇑ε)] : ∏ f ∘ ⇑ε ≅ ∏ f
{elab : bool} : expr elab → expr elab → expr elab
{α : Type u_1} {𝕜 : Type u_2} [linear_ordered_field 𝕜] (G : simple_graph α) [decidable_rel G.adj] (ε : 𝕜) (s t : finset α) : finset α
{α : Type u_1} (l : filter α) (ε : α → Type u_2) : setoid (Π (a : α), ε a)
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] : Type u_2
{F : Type u_1} [normed_group F] [normed_space ℝ F] (f : ℝ → F) (K : set F) (r s ε : ℝ) : set ℝ
(R : Type u) [semiring R] (M : Type v) (ι : Type u_1 := punit) [add_comm_monoid M] [module R M] [unique ι] : direct_sum ι (λ (_x : ι), M) ≃ₗ[R] M
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.prepartition I) (πi : Π (J : box_integral.box ι), box_integral.prepartition J) : box_integral.prepartition I
{ι : Type u_1} {α : ι → Type u_3} [fintype ι] [Π (i : ι), measurable_space (α i)] (μ : Π (i : ι), measure_theory.measure (α i)) : measure_theory.measure (Π (i : ι), α i)
{R : Type u} [non_assoc_semiring R] ⦃s t : set R⦄ (h : s ⊆ t) : subsemiring.closure s ≤ subsemiring.closure t
{f f' : ℝ → ℝ} {a b : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → ∀ (r : ℝ), f' x < r → (∃ᶠ (z : ℝ) in nhds_within x (set.Ioi x), slope f x z < r)) {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : ∀ (x : ℝ), has_deriv_at B (B' x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → f x = B x → f' x < B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → f x ≤ B x
{α : Type u_1} {F : Type u_3} [normed_group F] [normed_space ℝ F] {m : measurable_space α} (μ : measure_theory.measure α) (s : set α) : F →L[ℝ] F
{𝕜 : Type u_1} [is_R_or_C 𝕜] [dec_𝕜 : decidable_eq 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional 𝕜 E] (v : E) (μ : module.End.eigenvalues T) : ⇑(hT.diagonalization) (⇑T v) μ = ↑μ • ⇑(hT.diagonalization) v μ
{α : Type u} {β : Type v} {f g : α → β} {s : set α} (h : ∀ (x : α), f x = g x) : f '' s = g '' s
{α : Type u_1} {C : Π {n : ℕ}, vector3 α n → Sort u} {n : ℕ} (v : vector3 α n) (H0 : C vector3.nil) (Hs : Π {n : ℕ} (a : α) (w : vector3 α n), C w → C (a::w)) : C v
(name : module_info.module_name) (cur_module : string := "") : environment
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} {σ : Type u_4} : turing.TM2.stmt Γ Λ σ → finset (turing.TM2.stmt Γ Λ σ)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {F : Type u_5} [normed_group F] [normed_space 𝕜 F] (Z : basic_smooth_vector_bundle_core I M F) : charted_space (model_prod H F) Z.to_topological_vector_bundle_core.total_space
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) (f' : W ⟶ X) [category_theory.limits.has_pullback f g] [category_theory.limits.has_pullback f' category_theory.limits.pullback.fst] [category_theory.limits.has_pullback (f' ≫ f) g] : category_theory.limits.pullback f' category_theory.limits.pullback.fst ≅ category_theory.limits.pullback (f' ≫ f) g
{α : Type u_1} {m0 : measurable_space α} (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] (x : α) : ℕ
{I : Type w₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {D : Type u₂} [category_theory.category D] (F : Π (i : I), C i ⥤ D) (q : (Σ (i : I), C i) ⥤ D) (h : Π (i : I), category_theory.sigma.incl i ⋙ q ≅ F i) : q ≅ category_theory.sigma.desc F
{I : Type u} (f : I → Type v) [decidable_eq I] [Π (i : I), has_one (f i)] (i : I) : one_hom (f i) (Π (i : I), f i)
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B] (ϕ ψ : A →ₐ[R] B) : subalgebra R A
{τ : Type u_1} [topological_space τ] [add_comm_group τ] [topological_add_group τ] {α : Type u_2} [topological_space α] (f : filter τ) (ϕ : flow τ α) (s : set α) (hf : ∀ (t : τ), filter.tendsto (λ (_x : τ), _x + t) f f) (t : τ) : omega_limit f ⇑ϕ (⇑ϕ t '' s) = omega_limit f ⇑ϕ s
{α : Type u_1} {E : Type u_4} {𝕜 : Type u_6} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} [normed_field 𝕜] [normed_space 𝕜 E] [fact (1 ≤ p)] : normed_space 𝕜 ↥(measure_theory.Lp.simple_func E p μ)
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (I : ideal R) (J : ideal S) (f : R ≃+* S) (hIJ : J = ideal.map ↑f I) : R ⧸ I ≃+* S ⧸ J
{R : Type u} [comm_semiring R] (I : ideal R) : ideal R
{α : Type u_1} {F : Type u_3} [normed_group F] {m : measurable_space α} (f : α → F) (q : ℝ) (μ : measure_theory.measure α) : ennreal
{α : Type u_1} (E : Type u_2) {m0 : measurable_space α} (p : ennreal) (μ : measure_theory.measure α) [normed_group E] [topological_space α] [borel_space α] [second_countable_topology_either α E] : add_subgroup ↥(measure_theory.Lp E p μ)
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic unit
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {r : ℝ} (r_nonneg : 0 ≤ r) {x : E} (hx : x ≠ 0) : ∥(↑r * (↑∥x∥)⁻¹) • x∥ = r
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ⟶ Y) [category_theory.limits.has_kernel f] {W : C} (k : W ⟶ X) (h : k ≫ f = 0) : W ⟶ category_theory.limits.kernel f
(cs : interactive.parse (lean.parser.many lean.parser.ident)) (locat : interactive.parse interactive.types.location) (cfg : tactic.unfold_config := {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.tt, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}}) : tactic unit
(l : interactive.parse interactive.types.location) (cfg : tactic.unfold_proj_config := {to_dsimp_config := {md := tactic.transparency.instances, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}}) : tactic unit
{G : Type u_1} {α : Type u_2} [group G] [mul_action G α] [measurable_space α] {s t : set α} {μ : measure_theory.measure α} [measurable_space G] [has_measurable_smul G α] [measure_theory.smul_invariant_measure G α μ] [encodable G] (hs : measure_theory.is_fundamental_domain G s μ) (ht : measure_theory.is_fundamental_domain G t μ) : ⇑μ s = ⇑μ t
{α : Type u_1} (S : set (setoid α)) : has_Sup.Sup S = eqv_gen.setoid (λ (x y : α), ∃ (r : setoid α), r ∈ S ∧ r.rel x y)
{α : Type u_1} {m : measurable_space α} (s : measure_theory.signed_measure α) (i : set α) (hi : 0.restrict i ≤ measure_theory.vector_measure.restrict s i) (j : set α) (hj : measurable_set j) : ennreal
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] {ι : Type u_3} [topological_space.pseudo_metrizable_space β] (u : filter ι) [u.ne_bot] [u.is_countably_generated] {f : ι → α → β} {g : α → β} (hf : ∀ (i : ι), measure_theory.ae_strongly_measurable (f i) μ) (lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ι), f n x) u (nhds (g x))) : measure_theory.ae_strongly_measurable g μ
{α : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space α} {ℙ : measure_theory.measure α} {μ : measure_theory.measure E} {X : α → E} [measure_theory.has_pdf X «ℙ» μ] : measure_theory.measure.quasi_measure_preserving X «ℙ» μ
{R : Type u_1} [semiring R] (φ : power_series R) (n : enat) (h : ∀ (i : ℕ), ↑i < n → ⇑(power_series.coeff R i) φ = 0) : n ≤ φ.order
{V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {B : bilin_form K V} {W : subspace K V} (b₁ : B.is_refl) (b₂ : (B.restrict W).nondegenerate) : is_compl W (B.orthogonal W)
(ns : list name) (p : name := name.mk_string "interactive" (name.mk_string "tactic" name.anonymous)) : tactic unit
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {H : Type u_4} [topological_space H] {I : model_with_corners 𝕜 E H} {H' : Type u_5} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {N : Type u_6} [topological_space N] [charted_space H N] {R : Type u_7} [comm_ring R] [topological_space R] [charted_space H' R] [smooth_ring I' R] : cont_mdiff_map I I' N R ⊤ →+* N → R
{α : Sort u_1} {σ : α → Sort u_4} (P : Prop) [decidable P] (f : P → Π (a : α), σ a) (g : ¬P → Π (a : α), σ a) (a : α) : dite P f g a = dite P (λ (h : P), f h a) (λ (h : ¬P), g h a)
{α : Type u_1} [emetric_space α] {K : nnreal} {f : α → α} {s : set α} (hsc : is_complete s) (hsf : set.maps_to f s s) (hf : contracting_with K (set.maps_to.restrict f s s hsf)) {x : α} (hxs : x ∈ s) (hx : has_edist.edist x (f x) ≠ ⊤) : ∃ (y : α) (H : y ∈ s), function.is_fixed_pt f y ∧ filter.tendsto (λ (n : ℕ), f^[n] x) filter.at_top (nhds y) ∧ ∀ (n : ℕ), has_edist.edist (f^[n] x) y ≤ has_edist.edist x (f x) * ↑K ^ n / (1 - ↑K)
{σ : Type u_1} {R : Type u_3} [comm_semiring R] : mv_polynomial (mv_polynomial σ R) R →ₐ[R] mv_polynomial σ R
{L : first_order.language} {ι : Type v} [preorder ι] (G : ι → Type w) [Π (i : ι), L.Structure (G i)] (f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)) [is_directed ι has_le.le] [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] [nonempty ι] : L.prestructure (first_order.language.direct_limit.setoid G f)
{α : Type u_1} [metric_space α] {K : nnreal} {f : α → α} (hf : contracting_with K f) [nonempty α] [complete_space α] (x : α) (n : ℕ) : has_dist.dist (f^[n] x) (contracting_with.fixed_point f hf) ≤ has_dist.dist (f^[n] x) (f^[n + 1] x) / (1 - ↑K)
{L : first_order.language} {α : Type u'} {n : ℕ} (φ : L.bounded_formula α n) : L.bounded_formula α n
{α : Type u} {C : free_add_magma α → Sort l} (x : free_add_magma α) (ih1 : Π (x : α), C (free_add_magma.of x)) (ih2 : Π (x y : free_add_magma α), C x → C y → C (x + y)) : C x
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {s t : set α} (h₁ : s ⊆ t) (h₂ : ⇑μ t ≤ ⇑μ s) (hsm : measurable_set s) (ht : ⇑μ t ≠ ⊤) : s =ᵐ[μ] t
{α : Type} (inner : tactic.unsafe.type_context α) (tr : tactic.transparency := tactic.transparency.semireducible) : tactic α
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i * g (⇑σ i)) = s.sum (λ (i : ι), f i * g i) ↔ antivary_on f (g ∘ ⇑σ) ↑s
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {t : set α} {f : α → E} {C : ℝ} [strict_convex_space ℝ E] (ht : ⇑μ t ≠ ⊤) (h_le : ∀ᵐ (x : α) ∂μ.restrict t, ∥f x∥ ≤ C) : f =ᵐ[μ.restrict t] function.const α (⨍ (x : α) in t, f x ∂μ) ∨ ∥∫ (x : α) in t, f x ∂μ∥ < (⇑μ t).to_real * C
{𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] [measurable_space G] [has_sub G] (f : G → E) (g : G → E') (L : E →L[𝕜] E' →L[𝕜] F) (μ : measure_theory.measure G . "volume_tac") : Prop
{ι : Type u} (s : finset ι) (f g : ι → ℝ) {p q : ℝ} (hpq : p.is_conjugate_exponent q) : s.sum (λ (i : ι), f i * g i) ≤ s.sum (λ (i : ι), |f i| ^ p) ^ (1 / p) * s.sum (λ (i : ι), |g i| ^ q) ^ (1 / q)
{α : Type u} {β : Type v} [pseudo_emetric_space α] [nonempty β] [semilattice_sup β] {u : β → α} : cauchy_seq u ↔ ∀ (ε : ennreal), ε > 0 → (∃ (N : β), ∀ (m : β), m ≥ N → ∀ (n : β), n ≥ N → has_edist.edist (u m) (u n) < ε)
{V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (hn : x ≠ y) (h : ∥x∥ = ∥y∥) : hb.oangle y x = ↑real.pi - 2 • hb.oangle (y - x) y
{R : Type u} [semiring R] (I : ideal (polynomial R)) : ideal R
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] : (∀ (a : set (submodule R M)), a.nonempty → (∃ (M' : submodule R M) (H : M' ∈ a), ∀ (I : submodule R M), I ∈ a → I ≤ M' → I = M')) ↔ is_artinian R M
{G : Type u_1} [measurable_space G] [group G] [topological_space G] (μ : measure_theory.measure G) [μ.is_haar_measure] [borel_space G] [topological_group G] {H : Type u_2} [group H] [topological_space H] [measurable_space H] [borel_space H] [t2_space H] [topological_group H] (f : G ≃* H) (hf : continuous ⇑f) (hfsymm : continuous ⇑(f.symm)) : (measure_theory.measure.map ⇑f μ).is_haar_measure
{E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) [t2_space M] [smooth_manifold_with_corners I M] {G : Type u_1} [normed_group G] [normed_space ℝ G] {g : M → G} (hg : smooth_on I (model_with_corners_self ℝ G) g (charted_space.chart_at H c).to_local_equiv.source) : smooth I (model_with_corners_self ℝ G) (λ (x : M), ⇑f x • g x)
{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {s t : set α} {Φ : α → β} (h : isometry Φ) : emetric.Hausdorff_edist (Φ '' s) (Φ '' t) = emetric.Hausdorff_edist s t
{G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure G} [add_group G] [has_measurable_add G] [μ.is_add_left_invariant] (f : G → E) (g : G) : ∫ (x : G), f (g + x) ∂μ = ∫ (x : G), f x ∂μ
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h : ↑r < p.radius) : ∃ (C : ℝ) (H : C > 0), ∀ (n : ℕ), ∥p n∥ * ↑r ^ n ≤ C
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (f : module.End K V) (μ : K) (k : ℕ) : ⇑(f.generalized_eigenspace μ) k ≤ ⇑(f.generalized_eigenspace μ) (finite_dimensional.finrank K V)
{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} (Hf : monotone f) {a : α} {s : set α} (Ha : is_least s a) : is_least (f '' s) (f a)
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] [has_measurable_inv G] [μ.is_mul_left_invariant] : measure_theory.measure.map (λ (z : G × G), (z.snd, (z.snd)⁻¹ * z.fst)) (μ.prod ν) = ν.prod μ
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {ε : Type u_5} (f : α → β → γ → δ → ε) : list α → list β → list γ → list δ → list ε
{p : ℕ+} {k : ℕ} {K : Type u} {L : Type v} {ζ : L} [field K] [field L] [algebra K L] [hcycl : is_cyclotomic_extension {p ^ k} K L] [hp : fact (nat.prime ↑p)] [ne_zero ↑↑p] (hζ : is_primitive_root ζ ↑(p ^ k)) (hirr : irreducible (polynomial.cyclotomic ↑(p ^ k) K)) : algebra.discr K ⇑((is_primitive_root.power_basis K hζ).basis) = (-1) ^ ((↑p ^ k).totient / 2) * ↑p ^ (↑p ^ (k - 1) * ((↑p - 1) * k - 1))
{M : Type u_1} [has_mul M] (c : con M) [d : Π (a b : M), decidable (⇑c a b)] : decidable_eq c.quotient
{k : Type u_1} [field k] {σ : Type u_2} (x : σ → k) : prime_spectrum (mv_polynomial σ k)
{ι : Type u_1} {R : Type u_2} {A : Type u_3} [decidable_eq ι] [add_monoid ι] [comm_semiring R] [semiring A] [algebra R A] (𝒜 : ι → submodule R A) [graded_algebra 𝒜] [Π (i : ι) (x : ↥(𝒜 i)), decidable (x ≠ 0)] (r : A) : finset ι
{σ : Type u_1} (f : σ → option σ) (a : σ) : turing.evals_to_in_time f a ↑a 0
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] (f : α × β → E) (hf : measure_theory.integrable f (μ.prod ν)) : ∫ (z : α × β), f z ∂μ.prod ν = ∫ (x : α), ∫ (y : β), f (x, y) ∂ν ∂μ
{n : ℕ} {α : Type u_1} {β : Type u_2} {C : Π {n : ℕ}, vector α n → vector β n → Sort u_3} (v : vector α n) (w : vector β n) (h_nil : C vector.nil vector.nil) (h_cons : Π {n : ℕ} {a : α} {b : β} {x : vector α n} {y : vector β n}, C x y → C (a::ᵥx) (b::ᵥy)) : C v w
(e : expr) (n : ℕ) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr × expr)
(R : Type u) {ι : Type x} {ι' : Type x'} [semiring R] (φ : ι → Type u_1) [Π (i : ι), add_comm_monoid (φ i)] [Π (i : ι), module R (φ i)] (e : ι ≃ ι') : (Π (i' : ι), φ i') ≃ₗ[R] Π (i : ι'), φ (⇑(e.symm) i)
{α : Type u_1} {ι : Type u_5} {m0 : measurable_space α} {μ ν : measure_theory.measure α} {S : set ι} {s : ι → set α} (hc : S.countable) (hs : (⋃ (i : ι) (H : i ∈ S), s i) = set.univ) : (∀ (i : ι), i ∈ S → μ.restrict (s i) = ν.restrict (s i)) → μ = ν
{𝕆 : Type u_1} {ℙ : Type u_2} {α : Type u_3} [preorder 𝕆] [preorder «ℙ»] [preorder α] [grade_max_order 𝕆 α] (f : 𝕆 → «ℙ») (hf : strict_mono f) (hcovby : ∀ (a b : 𝕆), a ⋖ b → f a ⋖ f b) (hmax : ∀ (a : 𝕆), is_max a → is_max (f a)) : grade_max_order «ℙ» α
(P : Π {R S : Type u} [_inst_7 : comm_ring R] [_inst_8 : comm_ring S], (R →+* S) → Prop) : Prop
{G : Type u} [group G] (N : subgroup G) [nN : N.normal] {H : Type v} [group H] (φ : G →* H) (HN : ∀ (x : G), x ∈ N → ⇑φ x = 1) : G ⧸ N →* H
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} (hp : p ∈ s) : vector_span k s = submodule.span k (has_vsub.vsub p '' s)
{P : Type u_1} [preorder P] {I : order.ideal P} (h : I.is_prime) : order.ideal.prime_pair P
{ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {c : E} {la la' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {u v : ι → ℝ} [interval_integral.FTC_filter a la la'] [measure_theory.is_locally_finite_measure μ] (hab : interval_integrable f μ a b) (hmeas : strongly_measurable_at_filter f la' μ) (hf : filter.tendsto f (la' ⊓ μ.ae) (nhds c)) (hu : filter.tendsto u lt la) (hv : filter.tendsto v lt la) : (λ (t : ι), ∫ (x : ℝ) in v t..b, f x ∂μ - ∫ (x : ℝ) in u t..b, f x ∂μ + ∫ (x : ℝ) in u t..v t, c ∂μ) =o[lt] λ (t : ι), ∫ (x : ℝ) in u t..v t, 1 ∂μ
(R : Type u_1) {ι : Type u_2} [semiring R] (φ : ι → Type u_3) [Π (i : ι), add_comm_monoid (φ i)] [Π (i : ι), module R (φ i)] [decidable_eq ι] (i : ι) : φ i →ₗ[R] Π (i : ι), φ i
{R : Type u} {σ : Type u_1} [comm_semiring R] : mv_polynomial σ R →+* R
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {a b₁ b₂ : ℝ} {μ : measure_theory.measure ℝ} {f : ℝ → E} [measure_theory.has_no_atoms μ] (h_int : interval_integrable f μ b₁ b₂) (ha : a ∈ set.interval b₁ b₂) : continuous_on (λ (b : ℝ), ∫ (x : ℝ) in a..b, f x ∂μ) (set.interval b₁ b₂)
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] [has_zero β] (f : α → β) (hf : measure_theory.ae_fin_strongly_measurable f μ) : α → β
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s t : set α} (ht : measurable_set t) : ⇑(μ.restrict s) t = ⇑μ (t ∩ s)
(σ K : Type u) [fintype K] [comm_ring K] : Type u
{α : Type u_1} {ι : Type u_5} {m0 : measurable_space α} {μ ν : measure_theory.measure α} [encodable ι] {s : ι → set α} (hs : (⋃ (i : ι), s i) = set.univ) : μ = ν ↔ ∀ (i : ι), μ.restrict (s i) = ν.restrict (s i)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} (f : Z ⟶ Y) (I : category_theory.InjectiveResolution Y) (J : category_theory.InjectiveResolution Z) : J.cocomplex ⟶ I.cocomplex
{x : pgame} : 0 ≤ x ↔ ∀ (j : x.right_moves), 0.lf (x.move_right j)
{α : Type u_1} {m : measurable_space α} (c : measure_theory.complex_measure α) (μ : measure_theory.measure α) : Prop
{V : Type u_1} [inner_product_space ℝ V] (x y : V) (h : inner_product_geometry.angle x y = real.pi / 2) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
{α : Type u_1} {m0 : measurable_space α} {μ ν₁ ν₂ : measure_theory.measure α} [measure_theory.is_finite_measure μ] (A2 : μ + ν₁ ≤ μ + ν₂) : ν₁ ≤ ν₂
{C : Type u₂} [category_theory.category C] {I : Type u₁} {F G : category_theory.discrete I ⥤ C} (f : Π (i : category_theory.discrete I), F.obj i ≅ G.obj i) : F ≅ G
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} (g : β → ennreal) (f : measure_theory.simple_func α β) : (measure_theory.simple_func.map g f).lintegral μ = f.range.sum (λ (x : β), g x * ⇑μ (⇑f ⁻¹' {x}))
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic expr
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] (f : E →SL[σ₁₂] F) (x : E) : ∥x∥ ≤ 1 → ∥⇑f x∥ ≤ ∥f∥
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} (t : category_theory.limits.pullback_cone f g) {W : C} {k l : W ⟶ t.X} (h₀ : k ≫ t.fst = l ≫ t.fst) (h₁ : k ≫ t.snd = l ≫ t.snd) (j : category_theory.limits.walking_cospan) : k ≫ t.π.app j = l ≫ t.π.app j
{E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) : M → ℝ
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} (f : Z ⟶ Y) (I : category_theory.InjectiveResolution Y) (J : category_theory.InjectiveResolution Z) : J.ι ≫ category_theory.InjectiveResolution.desc f I J = (cochain_complex.single₀ C).map f ≫ I.ι
(explain : interactive.parse (optional (lean.parser.tk "?"))) (rs : interactive.parse (optional (interactive.types.list_of (tactic.interactive.rw_rule_p (lean.parser.pexpr 0))))) (cfg : tactic.rewrite_search.config := {to_cfg := {to_rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}, try_simp := bool.ff, discharger := tactic.skip, simplifier := λ (e : expr), tactic.failed}, max_iterations := 5000, explain_using_conv := bool.tt}) : tactic unit
(red : tactic.transparency) (mode : tactic.ring.normalize_mode := tactic.ring.normalize_mode.horner) (e : expr) : tactic (expr × expr)
{α : Type u_1} (β : Type u_2) [measurable_space α] [topological_space β] (μ : measure_theory.measure α) : setoid {f // measure_theory.ae_strongly_measurable f μ}
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] : Prop
{α : Type u} {C : free_semigroup α → Sort l} (x : free_semigroup α) (ih1 : Π (x : α), C (has_pure.pure x)) (ih2 : Π (x : α) (y : free_semigroup α), C (has_pure.pure x) → C y → C (has_pure.pure x * y)) : C x
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : ℕ → α → ennreal} (h_meas : ∀ (n : ℕ), measurable (f n)) (h_mono : ∀ (n : ℕ), f n.succ ≤ᵐ[μ] f n) (h_fin : ∫⁻ (a : α), f 0 a ∂μ ≠ ⊤) : ∫⁻ (a : α), (⨅ (n : ℕ), f n a) ∂μ = ⨅ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
{α : Type u} {β : Type v} [pseudo_metric_space α] {ι : Type u_1} {F : ι → β → α} {f : β → α} {p : filter ι} {s : set β} : tendsto_uniformly_on F f p s ↔ ∀ (ε : ℝ), ε > 0 → (∀ᶠ (n : ι) in p, ∀ (x : β), x ∈ s → has_dist.dist (f x) (F n x) < ε)
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [measurable_space X] [borel_space X] [measurable_space Y] [borel_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f) {d : ℝ} (hd : 0 ≤ d) (s : set X) : ⇑(measure_theory.measure.hausdorff_measure d) (f '' s) ≤ ↑K ^ d * ⇑(measure_theory.measure.hausdorff_measure d) s
{ι : Type v} [dec_ι : decidable_eq ι] [preorder ι] (G : ι → Type w) [Π (i : ι), add_comm_group (G i)] (f : Π (i j : ι), i ≤ j → G i →+ G j) (P : Type u₁) [add_comm_group P] (g : Π (i : ι), G i →+ P) (Hg : ∀ (i j : ι) (hij : i ≤ j) (x : G i), ⇑(g j) (⇑(f i j hij) x) = ⇑(g i) x) : add_comm_group.direct_limit G f →ₗ[ℤ] P
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_4} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_6} [topological_space M] [charted_space H M] {n : with_top ℕ} : cont_mdiff_map I I M M n
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : α → ennreal} (hf : measurable f) (ε : ennreal) : ε * ⇑μ {x : α | ε ≤ f x} ≤ ∫⁻ (a : α), f a ∂μ
(α : Type u_1) (E : Type u_2) {F : Type u_3} (𝕜 : Type u_6) [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {m : measurable_space α} (μ : measure_theory.measure α) [normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 F] {T : set α → (E →L[ℝ] F)} {C : ℝ} (hT : measure_theory.dominated_fin_meas_additive μ T C) (h_smul : ∀ (c : 𝕜) (s : set α) (x : E), ⇑(T s) (c • x) = c • ⇑(T s) x) : ↥(measure_theory.Lp.simple_func E 1 μ) →L[𝕜] F
{M : Type u_1} [has_add M] {S : set (add_con M)} : has_Sup.Sup S = add_con_gen (has_Sup.Sup (coe_fn '' S))
{α : Type} (tactics : list (tactic α)) (sort_by : tactic ℕ := tactic.num_goals) : tactic (list (α × ℕ))
{E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) (r : ℝ) (hr : r ∈ set.Ioo 0 f.to_cont_diff_bump.to_cont_diff_bump_of_inner.R) : smooth_bump_function I c
{α : Type u_2} [measurable_space α] {f : α → α} {s : set α} {μ : measure_theory.measure α} (hf : measure_theory.conservative f μ) (hs : measurable_set s) : ∀ᵐ (x : α) ∂μ, ∀ (k : ℕ), f^[k] x ∈ s → (∃ᶠ (n : ℕ) in filter.at_top, f^[n] x ∈ s)
{σ : Type u_1} (f : σ → option σ) : σ → σ → Prop
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) : Type (max u v)
{M : Type u} [add_zero_class M] : reflexive (λ (a b : M), ∃ (c : M), add_semiconj_by c a b)
(nm : name) (cfg : simps_cfg := {attrs := [name.mk_string "simp" name.anonymous], simp_rhs := bool.ff, type_md := tactic.transparency.instances, rhs_md := tactic.transparency.none, fully_applied := bool.tt, not_recursive := [name.mk_string "prod" name.anonymous, name.mk_string "pprod" name.anonymous], trace := bool.ff, add_additive := option.none name}) (todo : list string := list.nil) (trc : bool := bool.ff) : tactic unit
{M : Type u_1} [has_add M] (c d : add_con M) : c ⊔ d = add_con_gen (λ (x y : M), ⇑c x y ∨ ⇑d x y)
{β : Type v} {π : β → Type u_1} [fintype β] [Π (b : β), pseudo_metric_space (π b)] (x : Π (b : β), π b) {r : ℝ} (hr : 0 ≤ r) : metric.closed_ball x r = set.univ.pi (λ (b : β), metric.closed_ball (x b) r)
{α : Type u_1} {m : set (measure_theory.outer_measure α)} {s : set α} (h : s.nonempty) : ⇑(has_Inf.Inf m) s = ⨅ (t : ℕ → set α) (h2 : s ⊆ set.Union t), ∑' (n : ℕ), ⨅ (μ : measure_theory.outer_measure α) (h3 : μ ∈ m), ⇑μ (t n)
{α : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {m : measurable_space α} {μ : measure_theory.measure α} [complete_space F] {T : set α → (E →L[ℝ] F)} {C : ℝ} (hT : measure_theory.dominated_fin_meas_additive μ T C) : ↥(measure_theory.Lp E 1 μ) →L[ℝ] F
{I : Type u} (f : I → Type v) [decidable_eq I] [Π (i : I), mul_zero_class (f i)] (i : I) : f i →ₙ* Π (i : I), f i
{C : Type u₁} [category_theory.category C] {X : C} (S : category_theory.presieve X) (R : Π ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, S f → category_theory.presieve Y) : category_theory.presieve X
{ι : Type u_1} {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [fintype ι] {S : Type u_3} [comm_ring S] [is_domain S] [algebra R S] (b : basis ι R S) (I : ideal S) (hI : I ≠ ⊥) : basis.smith_normal_form (submodule.restrict_scalars R I) ι (fintype.card ι)
{M : Type u_1} [has_add M] (S : set (add_con M)) : ⇑(has_Inf.Inf S) = has_Inf.Inf (coe_fn '' S)
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) : Type (max u v)
{F : Type u_3} [inner_product_space ℝ F] (x y : F) : |has_inner.inner x y / (∥x∥ * ∥y∥)| ≤ 1
{E : Type u_3} [normed_group E] {μ : measure_theory.measure ℝ} [measure_theory.is_locally_finite_measure μ] {u : ℝ → E} (hu : continuous u) (a b : ℝ) : interval_integrable u μ a b
{𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [add_group G] [has_measurable_add₂ G] [has_measurable_neg G] {x₀ : G} {s : set G} (hbg : bdd_above ((λ (i : G), ∥g i∥) '' ((λ (t : G), -t + x₀) ⁻¹' s))) (hs : measurable_set s) (h2s : function.support (λ (t : G), ⇑(⇑L (f t)) (g (x₀ - t))) ⊆ s) (hf : measure_theory.integrable_on f s μ) (hmf : measure_theory.ae_strongly_measurable f μ) (hmg : measure_theory.ae_strongly_measurable g (measure_theory.measure.map (λ (t : G), x₀ - t) μ)) : convolution_exists_at f g x₀ L μ
{E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (hs : measurable_set s) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) : measure_theory.measure.map (s.restrict f) (⇑(measure_theory.measure.comap coe) (μ.with_density (λ (x : E), ennreal.of_real |(f' x).det|))) = μ.restrict (f '' s)
{𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] [measurable_space G] [normed_space ℝ F] [complete_space F] [has_sub G] (f : G → E) (g : G → E') (L : E →L[𝕜] E' →L[𝕜] F) (μ : measure_theory.measure G . "volume_tac") : G → F
{R : Type u_17} {S : Type u_18} [semiring R] [semiring S] (σ : R →+* S) (M : Type u_19) (M₂ : Type u_20) [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module S M₂] : Type (max u_19 u_20)
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] (f : ℝ → E) (a b : ℝ) (μ : measure_theory.measure ℝ) : E
{α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} {f : α → β} (hp_one : 1 ≤ p) (hp_top : p ≠ ⊤) (hf : measure_theory.mem_ℒp f p μ) (hmeas : measure_theory.strongly_measurable f) {ε : ℝ} (hε : 0 < ε) : ∃ (δ : ℝ) (hδ : 0 < δ), ∀ (s : set α), measurable_set s → ⇑μ s ≤ ennreal.of_real δ → measure_theory.snorm (s.indicator f) p μ ≤ ennreal.of_real ε
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {C D : set (set α)} (h : μ.finite_spanning_sets_in C) (hC : C ⊆ D) : μ.finite_spanning_sets_in D
{C : Type u₁} [category_theory.category C] (F : category_theory.discrete pempty ⥤ C) (Y : C) : category_theory.limits.is_limit {X := Y, π := {app := category_theory.limits.is_terminal_equiv_unique._aux_1 F Y, naturality' := _}} ≃ Π (X : C), unique (X ⟶ Y)
{p : ℕ} {h : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R → witt_vector p R} {f g : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R} (hh : witt_vector.is_poly₂ p h) (hf : witt_vector.is_poly p f) (hg : witt_vector.is_poly p g) : witt_vector.is_poly₂ p (λ (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), h (f x) (g y))
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [topological_space.second_countable_topology E] [complete_space E] [normed_group F] {f : ℝ → E} {g : ℝ → F} {a b c : ℝ} (h_deriv : ∀ᶠ (x : ℝ) in nhds_within c {c}ᶜ, differentiable_at ℝ f x) (h_infty : filter.tendsto (λ (x : ℝ), ∥f x∥) (nhds_within c {c}ᶜ) filter.at_top) (hg : deriv f =O[nhds_within c {c}ᶜ] g) (hne : a ≠ b) (hc : c ∈ set.interval a b) : ¬interval_integrable g measure_theory.measure_space.volume a b
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] : topological_space M
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] : category_theory.limits.multicofork I ⥤ category_theory.limits.cofork I.fst_sigma_map I.snd_sigma_map
{α : Type u_1} {ι : Type u_2} {E : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group E] {p : ennreal} {f : ι → α → E} {g : α → E} (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ⊤) (hf : ∀ (n : ι), measure_theory.ae_strongly_measurable (f n) μ) (hg : measure_theory.ae_strongly_measurable g μ) {l : filter ι} (hfg : filter.tendsto (λ (n : ι), measure_theory.snorm (f n - g) p μ) l (nhds 0)) : measure_theory.tendsto_in_measure μ f l g
{α : Type u_1} {m : measurable_space α} (s : measure_theory.signed_measure α) (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] : measure_theory.vector_measure.absolutely_continuous s μ.to_ennreal_vector_measure ↔ μ.with_densityᵥ (s.rn_deriv μ) = s
{α : Type u_1} [measurable_space α] (μ : measure_theory.measure α) (s : set α) : ∃ (t : set α), s ⊆ t ∧ measurable_set t ∧ ⇑μ t = ⇑μ s
{X : Type u_1} [topological_space X] {m : measurable_space X} (μ : measure_theory.measure X) : Prop
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {X : C} {S : J.cover X} {T : Π (I : S.arrow), J.cover I.Y} (I : (S.bind T).arrow) : (T I.from_middle).arrow
{α : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] [normed_group F] {g : E → F} {c : nnreal} (hg : lipschitz_with c g) (g0 : g 0 = 0) (f : ↥(measure_theory.Lp E p μ)) : ↥(measure_theory.Lp F p μ)
(x t : ℝ) (h1 : 0 < x) (h2 : x ≤ 1) (ht : 0 < t) : |real.log x * x ^ t| < 1 / t
{R : Type u} {S : Type v} [comm_ring R] [is_domain R] [comm_ring S] [is_domain S] (φ : R →+* S) (f : polynomial R) (h_mon : f.monic) (h_irr : irreducible (polynomial.map φ f)) : irreducible f
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.tagged_prepartition I) (π' : box_integral.prepartition I) : box_integral.tagged_prepartition I
{M : Type u_1} [monoid M] {ι : Type u_2} [hdec : decidable_eq ι] [fintype ι] {N : ι → Type u_3} [Π (i : ι), monoid (N i)] : {ϕ // pairwise (λ (i j : ι), ∀ (x : N i) (y : N j), commute (⇑(ϕ i) x) (⇑(ϕ j) y))} ≃ ((Π (i : ι), N i) →* M)
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] : category_theory.limits.walking_parallel_pair ⥤ C
{R : Type u_1} {A : Type u_2} [comm_ring R] [ring A] [algebra R A] {c₁ c₂ : R} ⦃q₁ q₂ : quaternion_algebra.basis A c₁ c₂⦄ (hi : q₁.i = q₂.i) (hj : q₁.j = q₂.j) : q₁ = q₂
{E : Type u_1} [normed_group E] [measurable_space E] [normed_space ℝ E] [finite_dimensional ℝ E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (s : set E) (x : E) (h : filter.tendsto (λ (r : ℝ), ⇑μ (s ∩ metric.closed_ball x r) / ⇑μ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 1)) (t : set E) (ht : measurable_set t) (h't : ⇑μ t ≠ 0) (h''t : ⇑μ t ≠ ⊤) : filter.tendsto (λ (r : ℝ), ⇑μ (s ∩ ({x} + r • t)) / ⇑μ ({x} + r • t)) (nhds_within 0 (set.Ioi 0)) (nhds 1)
{α : Type u_1} {β : Type u_2} {ι : Type u_3} [normed_group β] {m : measurable_space α} (f : ι → α → β) (p : ennreal) (μ : measure_theory.measure α) : Prop
{V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hxyne : x ≠ y) (hxzne : x ≠ z) (hxy : ∥x∥ = ∥y∥) (hxz : ∥x∥ = ∥z∥) : hb.oangle y z = 2 • hb.oangle (y - x) (z - x)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] (H : Type u_3) [topological_space H] (I : model_with_corners 𝕜 E H) : tangent_bundle I H ≃ₜ model_prod H E
{G : Type u} [group G] {H : Type v} [group H] (φ : G →* H) (ψ : H → G) (hφ : function.right_inverse ψ ⇑φ) : G ⧸ φ.ker ≃* H
{α : Type u_1} {ι : Type u_2} {I : set ι} (hI : I.nonempty) (m : ι → measure_theory.outer_measure α) (s : set α) : (⇑⨅ (i : ι) (H : i ∈ I), m i) s = ⨅ (t : ℕ → set α) (h2 : s ⊆ set.Union t), ∑' (n : ℕ), ⨅ (i : ι) (H : i ∈ I), ⇑(m i) (t n)
{R : Type u} {σ : Type u_1} [comm_semiring R] {P : mv_polynomial σ R → Prop} (p : mv_polynomial σ R) (h1 : ∀ (u : σ →₀ ℕ) (a : R), P (⇑(mv_polynomial.monomial u) a)) (h2 : ∀ (p q : mv_polynomial σ R), P p → P q → P (p + q)) : P p
{C : ℕ → Sort u_1} {n m : ℕ} : n ≤ m → (Π ⦃k : ℕ⦄, n ≤ k → C k → C (k + 1)) → C n → C m
{α : Type u} {ι : Type u_1} (I : finset ι) {l : filter α} {p : ι → α → Prop} : (∀ᶠ (x : α) in l, ∀ (i : ι), i ∈ I → p i x) ↔ ∀ (i : ι), i ∈ I → (∀ᶠ (x : α) in l, p i x)
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {t : set α} {f : α → E} (hs : convex ℝ s) (hsc : is_closed s) (h0 : ⇑μ t ≠ 0) (ht : ⇑μ t ≠ ⊤) (hfs : ∀ᵐ (x : α) ∂μ.restrict t, f x ∈ s) (hfi : measure_theory.integrable_on f t μ) : ⨍ (x : α) in t, f x ∂μ ∈ s
{E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {C : ℝ} (hf : differentiable_on ℝ f (set.Icc 0 1)) (bound : ∀ (x : ℝ), x ∈ set.Ico 0 1 → ∥deriv_within f (set.Icc 0 1) x∥ ≤ C) : ∥f 1 - f 0∥ ≤ C
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_10} [semi_normed_group E'] [normed_space 𝕜 E'] [ring_hom_isometric σ₁₂] [proper_space F] {s : set (E' →SL[σ₁₂] F)} (hb : metric.bounded s) (hc : ∀ (f : E' →SL[σ₁₂] F), ⇑f ∈ closure (coe_fn '' s) → f ∈ s) : is_compact (coe_fn '' s)
{p : ℕ} {g f : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R} (hg : witt_vector.is_poly p g) (hf : witt_vector.is_poly p f) : witt_vector.is_poly p (λ (R : Type u_1) (_Rcr : comm_ring R), g ∘ f)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ⟶ Y} {P : C} {π π' : Y ⟶ P} {w : f ≫ π = 0} (h : π = π') : category_theory.limits.cokernel_cofork.of_π π w ≅ category_theory.limits.cokernel_cofork.of_π π' _
{V : Type u_1} [inner_product_space ℝ V] (x y : V) : real.cos (inner_product_geometry.angle x y) * (∥x∥ * ∥y∥) = has_inner.inner x y
(xs : list tactic.rcases_patt) (fuel : option ℕ) (cfg : tactic.apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}) (trace : bool := bool.ff) : tactic (list tactic.rcases_patt)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : M → M') (x : M) : Prop
{E : Type u_1} [semi_normed_group E] {s : set E} : metric.bounded s → (∃ (R : ℝ), ∀ (x : E), x ∈ s → ∥x∥ ≤ R)
{α : Type u} [pseudo_metric_space α] {β : Type u_1} {ε : ℝ} (hε : 0 < ε) {f : β → α} (hf : pairwise (λ (x y : β), ε ≤ has_dist.dist (f x) (f y))) : uniform_embedding f
{σ : Type u_1} (f : σ → option σ) : σ → σ → Prop
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : multilinear_map 𝕜 E G) {ε : ι → ℝ} {C : ℝ} (hε : ∀ (i : ι), 0 < ε i) {c : ι → 𝕜} (hc : ∀ (i : ι), 1 < ∥c i∥) (hf : ∀ (m : Π (i : ι), E i), (∀ (i : ι), ε i / ∥c i∥ ≤ ∥m i∥) → (∀ (i : ι), ∥m i∥ < ε i) → ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) (m : Π (i : ι), E i) : ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {p q : tangent_bundle I M} (h : q.fst ∈ (charted_space.chart_at H p.fst).to_local_equiv.source) : tangent_map I I ⇑(charted_space.chart_at H p.fst) q = ⇑((equiv.sigma_equiv_prod H E).symm) (⇑(charted_space.chart_at (model_prod H E) p) q)
{α : Type u} {β : Type v} [topological_space α] [semi_normed_group β] (f : bounded_continuous_function α β) [h : nonempty α] : ∥f∥ = has_Inf.Inf {C : ℝ | ∀ (x : α), ∥⇑f x∥ ≤ C}
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] (ρ : measure_theory.measure α) [measure_theory.is_locally_finite_measure ρ] : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (a : set α), ⇑ρ a / ⇑μ a) (v.filter_at x) (nhds (ρ.rn_deriv μ x))
{G : Type u_1} [normed_group G] [complete_space G] {H : Type u_2} [normed_group H] {f : normed_group_hom G H} {K : Type u_3} [semi_normed_group K] {j : normed_group_hom K H} (hj : ∀ (x : K), ∥⇑j x∥ = ∥x∥) {C ε : ℝ} (hC : 0 < C) (hε : 0 < ε) (hyp : ∀ (k : K), ∃ (g : G), ⇑f g = ⇑j k ∧ ∥g∥ ≤ C * ∥k∥) : f.surjective_on_with j.range.topological_closure (C + ε)
{K : Type u_1} [comm_ring K] [is_domain K] {ζ : K} {n : ℕ} (hpos : 0 < n) (h : is_primitive_root ζ n) : polynomial.cyclotomic' n K = (polynomial.X ^ n - 1) /ₘ n.proper_divisors.prod (λ (i : ℕ), polynomial.cyclotomic' i K)
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : α → ℝ} (hf : measure_theory.integrable f μ) : ∫ (a : α), f a ∂μ = (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real - (∫⁻ (a : α), ennreal.of_real (-f a) ∂μ).to_real
(r e : expr) (cfg : tactic.nth_rewrite.cfg := {to_rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}, try_simp := bool.ff, discharger := tactic.skip, simplifier := λ (e : expr), tactic.failed}) : tactic (expr × expr)
{α : Type u_1} {β : Type u_2} {m0 : measurable_space α} {μ : measure_theory.measure α} {f : α → β} [has_zero β] [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] (hf : measure_theory.fin_strongly_measurable f μ) : measurable f
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {𝒢 : measure_theory.filtration ℕ m0} [measure_theory.is_finite_measure μ] {f : ℕ → α → ℝ} (hadp : measure_theory.adapted 𝒢 f) (hint : ∀ (i : ℕ), measure_theory.integrable (f i) μ) : measure_theory.submartingale f 𝒢 μ ↔ ∀ (τ π : α → ℕ), measure_theory.is_stopping_time 𝒢 τ → measure_theory.is_stopping_time 𝒢 π → τ ≤ π → (∃ (N : ℕ), ∀ (x : α), π x ≤ N) → ∫ (x : α), measure_theory.stopped_value f τ x ∂μ ≤ ∫ (x : α), measure_theory.stopped_value f π x ∂μ
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) (p q : set α → Prop) : Prop
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {H : Type u_5} [topological_space H] {H' : Type u_6} [topological_space H'] {I : model_with_corners 𝕜 E H} {I' : model_with_corners 𝕜 E' H'} {M : Type u_8} [topological_space M] [charted_space H M] {M' : Type u_9} [topological_space M'] [charted_space H' M'] {n : with_top ℕ} : function.injective (λ (h : diffeomorph I I' M M' n) (x : M), ⇑h x)
{α : Type u_1} [decidable_eq α] {𝒜 : finset (finset α)} {s : finset α} {k : ℕ} : s ∈ finset.shadow^[k] 𝒜 ↔ ∃ (t : finset α) (H : t ∈ 𝒜), s ⊆ t ∧ t.card = s.card + k
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {C r : nnreal} {f : X → Y} (h : holder_with C r f) (hr : 0 < r) (s : set X) : dimH (f '' s) ≤ dimH s / ↑r
(h : name) (t : option expr := option.none) (pr : expr) : smt_tactic unit
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {s t : set α} [measure_theory.is_finite_measure μ] (hms : measurable_set s) (hmt : measurable_set t) : ⇑(probability_theory.cond μ s) t = (⇑μ s)⁻¹ * ⇑(probability_theory.cond μ t) s * ⇑μ t
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) (h : 0 < p.radius) : ∃ (C r : ℝ) (hC : 0 < C) (hr : 0 < r), ∀ (n : ℕ), ∥p n∥ ≤ C * r ^ n
(s : simp_lemmas) (e : expr) (symm : bool := decidable.to_bool false) : tactic simp_lemmas
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {μ : R} {k : ℕ} (hk : 0 < k) (hμ : f.has_eigenvalue μ) : f.has_generalized_eigenvalue μ k
{V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] (f g : normed_group_hom V₁ V₂) : ∥f + g∥ ≤ ∥f∥ + ∥g∥
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) : Prop
{C : Type u₂} [category_theory.category C] {I : Type u₁} {D : Type u₃} [category_theory.category D] (F : I → C) (G : C ⥤ D) : category_theory.discrete.functor F ⋙ G ≅ category_theory.discrete.functor (G.obj ∘ F)
{ι : Type u_1} {I : box_integral.box ι} (π₁ π₂ : box_integral.tagged_prepartition I) (h : disjoint π₁.Union π₂.Union) : box_integral.tagged_prepartition I
{R : Type u} {M₂ : Type w} {M₃ : Type y} [semiring R] [add_comm_monoid M₂] [module R M₂] [add_comm_monoid M₃] [module R M₃] (f : M₂ →ₗ[R] M₃) (I : Type u_1) : (I → M₂) →ₗ[R] I → M₃
{G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G → E'} [measurable_space G] {μ : measure_theory.measure G} [semi_normed_group G] [borel_space G] [topological_space.second_countable_topology G] [μ.is_add_left_invariant] [measure_theory.sigma_finite μ] [normed_space ℝ E'] [complete_space E'] {f : G → ℝ} {x₀ : G} {R ε : ℝ} (hε : 0 ≤ ε) (hf : function.support f ⊆ metric.ball 0 R) (hnf : ∀ (x : G), 0 ≤ f x) (hintf : ∫ (x : G), f x ∂μ = 1) (hmg : measure_theory.ae_strongly_measurable g μ) (hg : ∀ (x : G), x ∈ metric.ball x₀ R → has_dist.dist (g x) (g x₀) ≤ ε) : has_dist.dist (convolution f g (continuous_linear_map.lsmul ℝ ℝ) μ x₀) (g x₀) ≤ ε
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : continuous_multilinear_map 𝕜 E G) (m : Π (i : ι), E i) : ∥⇑f m∥ ≤ ∥f∥ * finset.univ.prod (λ (i : ι), ∥m i∥)
{a b : ℝ} {f f' : ℝ → ℝ} (hab : a ≤ b) (hf : ∀ (x : ℝ), x ∈ set.Icc a b → has_deriv_within_at f (f' x) (set.Icc a b) x) {m : ℝ} (hma : f' a < m) (hmb : m < f' b) : m ∈ f' '' set.Icc a b
{ι : Type v} [dec_ι : decidable_eq ι] {β : ι → Type w} [Π (i : ι), add_comm_monoid (β i)] {γ : Type u_1} [add_monoid γ] ⦃f g : direct_sum ι (λ (i : ι), β i) →+ γ⦄ (H : ∀ (i : ι) (y : β i), ⇑f (⇑(direct_sum.of (λ (i : ι), β i) i) y) = ⇑g (⇑(direct_sum.of (λ (i : ι), β i) i) y)) : f = g
{α : Type u_1} {σ : Type u_3} (F : cfilter (set α) σ) : filter α
{V : Type u_1} {W : Type u_2} [semi_normed_group V] [semi_normed_group W] (f g : normed_group_hom V W) : add_subgroup V
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s : set α} [measure_theory.sigma_finite μ] {r : ennreal} (hs : measurable_set s) (h's : r < ⇑μ s) : ∃ (t : set α), measurable_set t ∧ t ⊆ s ∧ r < ⇑μ t ∧ ⇑μ t < ⊤
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} {g : E → ℝ} [measure_theory.is_finite_measure μ] (hg : strict_concave_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) (hgi : measure_theory.integrable (g ∘ f) μ) : f =ᵐ[μ] function.const α (⨍ (x : α), f x ∂μ) ∨ ⨍ (x : α), g (f x) ∂μ < g (⨍ (x : α), f x ∂μ)
{ι : Type u} {E : Type v} [fintype ι] [normed_group E] [normed_space ℝ E] (f : measure_theory.simple_func (ι → ℝ) E) (μ : measure_theory.measure (ι → ℝ)) [measure_theory.is_locally_finite_measure μ] (I : box_integral.box ι) (l : box_integral.integration_params) (hl : l.bRiemann = bool.ff) : box_integral.has_integral I l ⇑f μ.to_box_additive.to_smul (measure_theory.simple_func.integral (μ.restrict ↑I) f)
{α : Type u_2} {β : Type u_3} [measurable_space α] [measurable_space β] (f : α → β) (μ : measure_theory.measure α . "volume_tac") : Prop
{m : Type → Type u} [applicative m] {elab elab' : bool} (f : expr elab → m (expr elab')) : expr elab → m (expr elab')
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] [ν.is_mul_left_invariant] : measure_theory.measure.map (λ (z : G × G), (z.fst, z.fst * z.snd)) (μ.prod ν) = μ.prod ν
{α : Type u_1} {n : Type u_4} [decidable_eq n] [has_zero α] [has_one α] : 1.is_diag
{n : ℕ} {A : Type u} (F : A → typevec n → Type u) [Π (α : A), mvfunctor (F α)] [Π (α : A), mvqpf (F α)] ⦃α : typevec n⦄ : mvqpf.sigma F α → (mvqpf.sigma.P F).obj α
{α : Type u_1} {E : Type u_4} (𝕜 : Type u_11) [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [complete_space E] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) : ↥(measure_theory.Lp E 2 μ) →L[𝕜] ↥(measure_theory.Lp_meas E 𝕜 m 2 μ)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (n : with_top ℕ) (f : M → M') (x : M) : Prop
{G : Type u_1} [measurable_space G] [has_add G] (μ : measure_theory.measure G) : Prop
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [normed_field 𝕜] [normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ : 𝕜 →+* 𝕜₂} (f : E →ₛₗ[σ] F) (h : ∃ (C : ℝ), ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥) : E →SL[σ] F
{α : Type u_1} {ι : Type u_4} {ι' : Type u_5} [normed_ring α] [complete_space α] {f : ι → α} {g : ι' → α} (hf : summable (λ (x : ι), ∥f x∥)) (hg : summable (λ (x : ι'), ∥g x∥)) : (∑' (x : ι), f x) * ∑' (y : ι'), g y = ∑' (z : ι × ι'), f z.fst * g z.snd
{α : Type u_1} (m₀ : measurable_space α) {μ ν : measure_theory.measure α} [measure_theory.is_finite_measure μ] (C : set (set α)) (hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s) {m : measurable_space α} (h : m ≤ m₀) (hA : m = measurable_space.generate_from C) (hC : is_pi_system C) (h_univ : ⇑μ set.univ = ⇑ν set.univ) {s : set α} (hs : measurable_set s) : ⇑μ s = ⇑ν s
{M : Type u} [add_monoid M] (u : add_units M) (x : M) : add_semiconj_by ↑u x (↑u + x + ↑-u)
{α : Type u} {β : Type v} [topological_space α] [semi_normed_group β] (f : bounded_continuous_function α β) (x y : α) : has_dist.dist (⇑f x) (⇑f y) ≤ 2 * ∥f∥
{V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) : x = y ↔ ∥x∥ = ∥y∥ ∧ hb.oangle x y = 0
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : ℕ → α → ennreal} (h_meas : ∀ (n : ℕ), ae_measurable (f n) μ) : ∫⁻ (a : α), filter.at_top.liminf (λ (n : ℕ), f n a) ∂μ ≤ filter.at_top.liminf (λ (n : ℕ), ∫⁻ (a : α), f n a ∂μ)
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (p : submodule R M) (k : ℕ) (μ : R) (hfp : ∀ (x : M), x ∈ p → ⇑f x ∈ p) : ⇑(module.End.generalized_eigenspace (linear_map.restrict f hfp) μ) k = submodule.comap p.subtype (⇑(f.generalized_eigenspace μ) k)
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} {c₁ c₂ : nnreal} {ε₁ ε₂ : ℝ} {π₁ π₂ : box_integral.tagged_prepartition I} (h : box_integral.integrable I l f vol) (hpos₁ : 0 < ε₁) (hpos₂ : 0 < ε₂) (h₁ : l.mem_base_set I c₁ (h.convergence_r ε₁ c₁) π₁) (h₂ : l.mem_base_set I c₂ (h.convergence_r ε₂ c₂) π₂) (HU : π₁.Union = π₂.Union) : has_dist.dist (box_integral.integral_sum f vol π₁) (box_integral.integral_sum f vol π₂) ≤ ε₁ + ε₂
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] {f : α → β} [topological_space α] [opens_measurable_space α] [topological_space.pseudo_metrizable_space β] [second_countable_topology_either α β] (hf : continuous f) : measure_theory.ae_strongly_measurable f μ
(R : Type u_1) [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] {K : Type u_5} {L : Type u_3} [is_domain R] [is_domain S] [field K] [field L] [algebra R K] [algebra R L] [algebra S L] [is_integral_closure S R L] [is_fraction_ring S L] [algebra K L] [is_scalar_tower R S L] [is_scalar_tower R K L] {a : S} {b : set S} (alg : algebra.is_algebraic R L) (inj : function.injective ⇑(algebra_map R L)) (h : ↑(ideal.span {a}) ⊆ ↑(submodule.span R b)) : ↑(ideal.span {⇑(algebra_map S L) a}) ⊆ ↑(submodule.span K (⇑(algebra_map S L) '' b))
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} [measure_theory.sigma_finite μ] {f : α × β → ennreal} (hf : measurable f) : measurable (λ (y : β), ∫⁻ (x : α), f (x, y) ∂μ)
{V : Type u_2} {P : Type u_3} [semi_normed_group V] [pseudo_metric_space P] [normed_add_torsor V P] {W : Type u_4} {Q : Type u_5} [normed_group W] [metric_space Q] [normed_add_torsor W Q] [normed_space ℝ V] [normed_space ℝ W] (f : P → Q) (h : ∀ (x y : P), f (midpoint ℝ x y) = midpoint ℝ (f x) (f y)) (hfc : continuous f) : P →ᵃ[ℝ] Q
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} (p : ennreal) (μ : measure_theory.measure α) [normed_group E] [topological_space α] [borel_space α] [second_countable_topology_either α E] [measure_theory.is_finite_measure μ] (𝕜 : Type u_5) [normed_field 𝕜] [normed_space 𝕜 E] [fact (1 ≤ p)] : bounded_continuous_function α E →L[𝕜] ↥(measure_theory.Lp E p μ)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] [smooth_manifold_with_corners I M] [smooth_manifold_with_corners I' M'] (f : M → M') (s : set M) (x : M) (f' : tangent_space I x →L[𝕜] tangent_space I' (f x)) : Prop
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p ∈ s) : ↑(s.direction) = (λ (_x : P), _x -ᵥ p) '' ↑s
{E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y : E} : ¬same_ray ℝ x y ↔ ∥x + y∥ < ∥x∥ + ∥y∥
{ι : Type u_1} {E : Type u_3} [semi_normed_group E] {f : ι → E} (hf : summable (λ (i : ι), ∥f i∥)) : ∥∑' (i : ι), f i∥ ≤ ∑' (i : ι), ∥f i∥
(R : Type u) [semiring R] {ι : Type v} {α : ι → Type u_1} {δ : Π (i : ι), α i → Type w} [Π (i : ι) (j : α i), add_comm_monoid (δ i j)] [Π (i : ι) (j : α i), module R (δ i j)] : direct_sum (Σ (i : ι), α i) (λ (i : Σ (i : ι), α i), δ i.fst i.snd) ≃ₗ[R] direct_sum ι (λ (i : ι), direct_sum (α i) (λ (j : α i), δ i j))
{G : Type u_1} [measurable_space G] [add_group G] [has_measurable_add₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] {E : set G} [has_measurable_neg G] [μ.is_add_left_invariant] [ν.is_add_left_invariant] (hE : measurable_set E) (h2E : ⇑ν E ≠ 0) (h3E : ⇑ν E ≠ ⊤) : μ = (⇑μ E / ⇑ν E) • ν
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.prepartition I) : Prop
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_10} [semi_normed_group E'] [normed_space 𝕜 E'] [ring_hom_isometric σ₁₂] {s : set (E' →SL[σ₁₂] F)} (hb : metric.bounded s) (hc : ∀ (f : E' →SL[σ₁₂] F), ⇑f ∈ closure (coe_fn '' s) → f ∈ s) : is_closed (coe_fn '' s)
{L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] (φ : L.hom M N) (S : L.substructure N) : L.substructure M
{n : ℕ} (α : typevec n) {β : Type u_1} (p : β → Prop) ⦃i : fin2 (n + 1)⦄ : (α ::: β) i → Prop
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : has_inner.inner x y = (↑∥x + y∥ ^ 2 - ↑∥x - y∥ ^ 2 + (↑∥x - is_R_or_C.I • y∥ ^ 2 - ↑∥x + is_R_or_C.I • y∥ ^ 2) * is_R_or_C.I) / 4
(nondep : bool) : expr → list name → (option (option expr) := option.none) → tactic unit
{R : Type u} {S : Type v} [comm_semiring R] [local_ring R] [comm_semiring S] [local_ring S] (f : R →+* S) : [is_local_ring_hom f, ⇑f '' (local_ring.maximal_ideal R).carrier ⊆ ↑(local_ring.maximal_ideal S), ideal.map f (local_ring.maximal_ideal R) ≤ local_ring.maximal_ideal S, local_ring.maximal_ideal R ≤ ideal.comap f (local_ring.maximal_ideal S), ideal.comap f (local_ring.maximal_ideal S) = local_ring.maximal_ideal R].tfae
{ι : Type u_1} [fintype ι] (s : finset (box_integral.box ι)) : ∀ᶠ (t : finset (ι × ℝ)) in filter.at_top, ∀ (I J : box_integral.box ι), J ∈ s → ∀ (J' : box_integral.box ι), J' ∈ box_integral.prepartition.split_many I t → ¬disjoint ↑J ↑J' → J' ≤ J
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {E : Type u₃} [category_theory.category E] {F G : C ⥤ D} {H I : D ⥤ E} (α : F ⟶ G) (β : H ⟶ I) : F ⋙ H ⟶ G ⋙ I
{α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.regular] ⦃A : set α⦄ (hA : measurable_set A) (h'A : ⇑μ A ≠ ⊤) {r : ennreal} (hr : r < ⇑μ A) : ∃ (K : set α) (H : K ⊆ A), is_compact K ∧ r < ⇑μ K
(hs : interactive.parse tactic.simp_arg_list) (ps : interactive.parse (optional (lean.parser.tk "using" *> interactive.types.pexpr_list_or_texpr))) (cfg : auto.auto_config := {use_simp := bool.tt, max_ematch_rounds := 20}) : tactic unit
(p : pexpr) (e : expr) (m : tactic.transparency := tactic.transparency.reducible) : tactic (list expr)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (n : with_top ℕ) (f : M → M') (s : set M) (x : M) : Prop
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] ⦃f g : α × β → E⦄ (hf : measure_theory.integrable f (μ.prod ν)) (hg : measure_theory.integrable g (μ.prod ν)) : ∫ (x : α), ∫ (y : β), (f - g) (x, y) ∂ν ∂μ = ∫ (x : α), ∫ (y : β), f (x, y) ∂ν ∂μ - ∫ (x : α), ∫ (y : β), g (x, y) ∂ν ∂μ
{α : Type u_1} {ι : Type u_5} {m : measurable_space α} {μ : measure_theory.measure α} [encodable ι] {s : ι → set α} (hd : directed has_subset.subset s) : ⇑μ (⋃ (i : ι), s i) = ⨆ (i : ι), ⇑μ (s i)
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {𝒢 : measure_theory.filtration ℕ m0} [measure_theory.sigma_finite_filtration μ 𝒢] {f : ℕ → α → ℝ} (hf : measure_theory.submartingale f 𝒢 μ) {τ π : α → ℕ} (hτ : measure_theory.is_stopping_time 𝒢 τ) (hπ : measure_theory.is_stopping_time 𝒢 π) (hle : τ ≤ π) {N : ℕ} (hbdd : ∀ (x : α), π x ≤ N) : ∫ (x : α), measure_theory.stopped_value f τ x ∂μ ≤ ∫ (x : α), measure_theory.stopped_value f π x ∂μ
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (p : ι → P) {s : set ι} {i : ι} (hi : i ∈ s) : vector_span k (p '' s) = submodule.span k ((λ (_x : P), _x -ᵥ p i) '' (p '' (s  {i})))
{C : Type u₁} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ℤ] [category_theory.preadditive C] [∀ (n : ℤ), (category_theory.shift_functor C n).additive] {D : Type u₂} [category_theory.category D] [category_theory.limits.has_zero_object D] [category_theory.has_shift D ℤ] [category_theory.preadditive D] [∀ (n : ℤ), (category_theory.shift_functor D n).additive] [category_theory.triangulated.pretriangulated C] [category_theory.triangulated.pretriangulated D] (F : category_theory.triangulated.pretriangulated.triangulated_functor C D) (T : category_theory.triangulated.triangle C) (h : T ∈ dist_triang C) : F.map_triangle.obj T ∈ dist_triang D
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {μ : R} {k : ℕ} (hk : 0 < k) : f.has_generalized_eigenvalue μ k ↔ f.has_eigenvalue μ
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (G : C ⥤ D) {W X Y : C} (f : W ⟶ X) (g : W ⟶ Y) [category_theory.limits.preserves_colimit (category_theory.limits.span f g) G] [category_theory.limits.has_pushout f g] [category_theory.limits.has_pushout (G.map f) (G.map g)] : category_theory.limits.pushout (G.map f) (G.map g) ≅ G.obj (category_theory.limits.pushout f g)
(V W : SemiNormedGroup) : (V ⟶ W) →+ (SemiNormedGroup.Completion.obj V ⟶ SemiNormedGroup.Completion.obj W)
{F : Type u_3} [inner_product_space ℝ F] (x y : F) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ has_inner.inner x y = 0
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] (I : model_with_corners 𝕜 E H) (G : Type u_4) [has_add G] [topological_space G] [charted_space H G] : Prop
{α : Type u_1} {σ : Type u_3} {τ : Type u_4} [partial_order α] (E : σ ≃ τ) : cfilter α σ → cfilter α τ
(n : with_top ℕ) {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) : structure_groupoid H
{G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure G} {f : G → E} {g : G} [add_group G] [has_measurable_add G] [μ.is_add_right_invariant] (hf' : ∀ (x : G), f (x + g) = -f x) : ∫ (x : G), f x ∂μ = 0
{M : Type u_1} {σ : Type u_4} [has_mul M] {N : Type u_2} [has_mul N] [set_like σ M] [mul_mem_class σ M] (f : M →ₙ* N) (S : σ) : ↥S →ₙ* N
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : continuous_multilinear_map 𝕜 E G) : ∥f∥ = 0 ↔ f = 0
{R : Type u_17} {S : Type u_18} [semiring R] [semiring S] {σ : R →+* S} {M : Type u_19} {M₂ : Type u_20} [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module S M₂] (self : M →ₛₗ[σ] M₂) : add_hom M M₂
(red : interactive.parse (optional (lean.parser.tk "!"))) (restr : interactive.parse (optional (lean.parser.tk "only"))) (hyps : interactive.parse (optional interactive.types.pexpr_list)) (cfg : linarith.linarith_config := {discharger := has_bind.seq (tactic.save_info {line := 312, column := 31}) (tactic.interactive.ring option.none).step, restrict_type := option.none Type, restrict_type_reflect := `(option.none Type), exfalso := bool.tt, transparency := tactic.transparency.reducible, split_hypotheses := bool.tt, split_ne := bool.ff, preprocessors := option.none (list linarith.global_branching_preprocessor), oracle := option.none linarith.certificate_oracle}) : tactic unit
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} (μ : measure_theory.measure α) [normed_group E] [topological_space α] [borel_space α] [second_countable_topology_either α E] [compact_space α] [measure_theory.is_finite_measure μ] {𝕜 : Type u_5} [fact (1 ≤ p)] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] : ∥continuous_map.to_Lp p μ 𝕜∥ ≤ ↑(measure_theory.measure_univ_nnreal μ) ^ (p.to_real)⁻¹
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : ∥0∥ = 0
{α : Type u} {β : Type v} (R : Type u_1) [semiring R] (e : α ≃ β) [add_comm_monoid β] : let _inst : add_comm_monoid α := e.add_comm_monoid in Π [_inst_3 : module R β], module R α
(R : Type u) [semiring R] {ι : Type v} {α : ι → Type u_1} {δ : Π (i : ι), α i → Type w} [Π (i : ι) (j : α i), add_comm_monoid (δ i j)] [Π (i : ι) (j : α i), module R (δ i j)] : direct_sum ι (λ (i : ι), direct_sum (α i) (λ (j : α i), δ i j)) →ₗ[R] direct_sum (Σ (i : ι), α i) (λ (i : Σ (i : ι), α i), δ i.fst i.snd)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) (C : ℝ) {r : nnreal} (h : ∀ (n : ℕ), ∥p n∥ * ↑r ^ n ≤ C) : ↑r ≤ p.radius
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] {f : α → β → E} (hf : measure_theory.integrable (function.uncurry f) (μ.prod ν)) : ∫ (x : α), ∫ (y : β), f x y ∂ν ∂μ = ∫ (z : α × β), f z.fst z.snd ∂μ.prod ν
{C : Type u} [category_theory.category C] {D : Type u₂} [category_theory.category D] [category_theory.limits.has_coequalizers C] [category_theory.limits.has_finite_coproducts C] (G : C ⥤ D) [category_theory.limits.preserves_colimits_of_shape category_theory.limits.walking_parallel_pair G] [Π (J : Type v) [_inst_8 : fintype J], category_theory.limits.preserves_colimits_of_shape (category_theory.discrete J) G] : category_theory.limits.preserves_finite_colimits G
{M : Type u} [add_monoid M] {a : M} {x y : add_units M} (h : add_semiconj_by a ↑x ↑y) : add_semiconj_by a (↑-x) (↑-y)
{ι : Type u_1} (I J : box_integral.box ι) (h : I ≤ J) : box_integral.tagged_prepartition I ↪ box_integral.tagged_prepartition J
{α : Type u} [semiring α] (I : ideal α) : Prop
{ι : Type u_1} [fintype ι] {I : box_integral.box ι} (r : (ι → ℝ) → ↥(set.Ioi 0)) (π : box_integral.prepartition I) : ∃ (π' : box_integral.tagged_prepartition I), π'.to_prepartition ≤ π ∧ π'.is_Henstock ∧ π'.is_subordinate r ∧ π'.distortion = π.distortion ∧ π'.Union = π.Union
{α : Type u_1} {m m0 : measurable_space α} {μ : measure_theory.measure α} {s : set α} (hm : m ≤ m0) {f g : α → ℝ} (hf : measure_theory.strongly_measurable f) (hfi : measure_theory.integrable_on f s μ) (hg : measure_theory.strongly_measurable g) (hgi : measure_theory.integrable_on g s μ) (hgf : ∀ (t : set α), measurable_set t → ⇑μ t < ⊤ → ∫ (x : α) in t, g x ∂μ = ∫ (x : α) in t, f x ∂μ) (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) : ∫ (x : α) in s, ∥g x∥ ∂μ ≤ ∫ (x : α) in s, ∥f x∥ ∂μ
{C : Type u_1} [category_theory.category C] (r : hom_rel C) ⦃s t : C⦄ : (s ⟶ t) → (s ⟶ t) → Prop
(σ : out_param (Type u)) (m : Type u → Type v) : Type (max (u+1) v)
{α : Type u} [pseudo_metric_space α] (s : set (uniform_space.completion α × uniform_space.completion α)) : s ∈ uniformity (uniform_space.completion α) ↔ ∃ (ε : ℝ) (H : ε > 0), ∀ {a b : uniform_space.completion α}, has_dist.dist a b < ε → (a, b) ∈ s
{α : Type u_1} {β : Type u_2} (f : α → β) (s : set α) (H : set.inj_on f s) : ↥s ≃ ↥(f '' s)
{𝕜 : Type u_1} {A : Type u_2} [comm_semiring 𝕜] [topological_space 𝕜] [has_continuous_add 𝕜] [has_continuous_const_smul 𝕜 𝕜] [non_unital_non_assoc_semiring A] [topological_space A] [module 𝕜 A] (φ : ↥(weak_dual.character_space 𝕜 A)) : A →L[𝕜] 𝕜
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] {s : set E} {x' : normed_space.dual 𝕜 E} {c : 𝕜} (hc : ∀ (z : E), z ∈ s → ∥⇑x' z∥ ≤ ∥c∥) : c⁻¹ • x' ∈ normed_space.polar 𝕜 s
{C : Type u} [category_theory.category C] {I : category_theory.limits.multicospan_index C} (K : category_theory.limits.multifork I) (a : I.L) : K.X ⟶ I.left a
(I : Type u_1) {R : Type u_2} (A : Type u_3) [comm_semiring R] [ring A] [algebra R A] : algebra R (I → A)
{β : Type v} {π : β → Type u_1} [fintype β] [Π (b : β), pseudo_metric_space (π b)] : pseudo_metric_space (Π (b : β), π b)
{R : Type u_1} {M : Type u_2} [comm_ring R] [comm_monoid M] [nontrivial R] {m : M} {S : set M} (h : ⇑(monoid_algebra.of R M) m ∈ submodule.span R ↑(submonoid.closure (⇑(monoid_algebra.of R M) '' S))) : m ∈ submonoid.closure S
{R : Type u_1} [comm_ring R] [is_domain R] {ζ : R} {n : ℕ} (h : is_primitive_root ζ n) : (polynomial.cyclotomic' n R).degree = ↑(n.totient)
{α : Type u_1} [preorder α] {f : α → α} {x : α} (hf : monotone f) (hx : x ≤ f x) : monotone (λ (n : ℕ), f^[n] x)
{α : Type u_1} {f : α → ennreal} {Mf mα : measurable_space α} {μ : measure_theory.measure α} (hMf : Mf ≤ mα) (c : ennreal) {T : set α} (h_meas_T : measurable_set T) (h_ind : probability_theory.indep_sets {s : set α | measurable_set s} {T} μ) (h_meas_f : measurable f) : ∫⁻ (a : α), f a * T.indicator (λ (_x : α), c) a ∂μ = ∫⁻ (a : α), f a ∂μ * ∫⁻ (a : α), T.indicator (λ (_x : α), c) a ∂μ
(s : simp_lemmas) (id : name) (symm : bool := decidable.to_bool false) : tactic simp_lemmas
{X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra ℝ C(X, ℝ)) (f : ↥A) (g : polynomial ℝ) : (g.to_continuous_map_on (set.Icc (-∥f∥) ∥f∥)).comp ↑f.attach_bound ∈ A
{α : Type u_1} (F : Type u_6) (𝕜 : Type u_11) (p : ennreal) [is_R_or_C 𝕜] [normed_group F] [normed_space 𝕜 F] {m m0 : measurable_space α} (μ : measure_theory.measure α) [hp : fact (1 ≤ p)] : ↥(measure_theory.Lp_meas_subgroup F m p μ) ≃ᵢ ↥(measure_theory.Lp_meas F 𝕜 m p μ)
{α : Type u_1} {β : Type u_2} [measurable_space α] [topological_space β] (f : α → β) (l : filter α) (μ : measure_theory.measure α . "volume_tac") : Prop
{c : Type u → Type u} {hom : Π ⦃α β : Type u⦄, c α → c β → (α → β) → Prop} [𝒞 : category_theory.unbundled_hom hom] {c' : Type u → Type u} {hom' : Π ⦃α β : Type u⦄, c' α → c' β → (α → β) → Prop} [𝒞' : category_theory.unbundled_hom hom'] (obj : Π ⦃α : Type u⦄, c α → c' α) (map : ∀ ⦃α β : Type u⦄ ⦃Iα : c α⦄ ⦃Iβ : c β⦄ ⦃f : α → β⦄, hom Iα Iβ f → hom' (obj Iα) (obj Iβ) f) : category_theory.has_forget₂ (category_theory.bundled c) (category_theory.bundled c')
{V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) (x y : V) : ⇑(hb.rotation (hb.oangle x y)) x = y ↔ ∥x∥ = ∥y∥
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {E'' : Type u_8} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_9} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_10} [topological_space M''] [charted_space H'' M''] {f : M → M'} (x : M) {g : M' → M''} [Is : smooth_manifold_with_corners I M] [I's : smooth_manifold_with_corners I' M'] [I''s : smooth_manifold_with_corners I'' M''] {f' : tangent_space I x →L[𝕜] tangent_space I' (f x)} {g' : tangent_space I' (f x) →L[𝕜] tangent_space I'' (g (f x))} (hg : has_mfderiv_at I' I'' g (f x) g') (hf : has_mfderiv_at I I' f x f') : has_mfderiv_at I I'' (g ∘ f) x (g'.comp f')
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} [inhabited Λ] {σ : Type u_4} [inhabited σ] : turing.TM2.stmt Γ Λ σ → turing.TM1.stmt turing.TM2to1.Γ' turing.TM2to1.Λ' σ
{R : Type u_1} [comm_ring R] (I : ideal R) : topological_space R
{E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : ℝ → ℝ} (ha : ∥f a∥ ≤ B a) (hB : ∀ (x : ℝ), has_deriv_at B (B' x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥f' x∥ ≤ B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → ∥f x∥ ≤ B x
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] {σ : Type u_3} [inhabited σ] {n : ℕ} {enc : Γ → vector bool n} (enc0 : enc inhabited.default = vector.repeat bool.ff n) : turing.TM1.cfg Γ Λ σ → turing.TM1.cfg bool turing.TM1to1.Λ' σ
{R : Type u_1} [comm_ring R] {K : Type u_3} [field K] [algebra R K] [is_fraction_ring R K] {I : fractional_ideal (non_zero_divisors R) K} [nontrivial R] (hI : I ≠ 0) : ∃ (x : R) (H : x ≠ 0), ⇑(algebra_map R K) x ∈ I
{σ : Type u_1} (R : Type u) [comm_semiring R] (s : set σ) : subalgebra R (mv_polynomial σ R)
{V : Type u} [fintype V] [decidable_eq V] {G : simple_graph V} [decidable_rel G.adj] {n k ℓ μ : ℕ} {v w : V} (h : G.is_SRG_with n k ℓ μ) (hne : v ≠ w) (ha : ¬G.adj v w) : (G.neighbor_finset v ∪ G.neighbor_finset w).card = 2 * k - μ
{𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] [topological_space.second_countable_topology G] [locally_compact_space G] [t2_space G] (hcg : has_compact_support g) (hf : measure_theory.locally_integrable f μ) (hg : continuous g) : continuous (convolution f g L μ)
{I : Type u} [decidable_eq I] {β : Type u_1} [has_zero β] (i : I) (x : β) (i' : I) : pi.single i x i' = ite (i' = i) x 0
{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {b : K} (nth_part_denom_eq : (generalized_continued_fraction.of v).partial_denominators.nth n = option.some b) : |v - (generalized_continued_fraction.of v).convergents n| ≤ 1 / (b * (generalized_continued_fraction.of v).denominators n * (generalized_continued_fraction.of v).denominators n)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {F : Type u_8} [normed_group F] [normed_space 𝕜 F] {G : Type u_9} [topological_space G] {J : model_with_corners 𝕜 F G} {N : Type u_10} [topological_space N] [charted_space G N] {F' : Type u_11} [normed_group F'] [normed_space 𝕜 F'] {G' : Type u_12} [topological_space G'] {J' : model_with_corners 𝕜 F' G'} {N' : Type u_13} [topological_space N'] [charted_space G' N'] {f : M → M'} {s : set M} {n : with_top ℕ} {g : N → N'} {r : set N} {p : M × N} (hf : cont_mdiff_within_at I I' n f s p.fst) (hg : cont_mdiff_within_at J J' n g r p.snd) : cont_mdiff_within_at (I.prod J) (I'.prod J') n (prod.map f g) (s ×ˢ r) p
{G : Type u} [group G] {H : Type v} [group H] (φ : G →* H) : G ⧸ φ.ker ≃* ↥(φ.range)
(md : tactic.transparency := tactic.transparency.semireducible) : ℕ → expr → tactic (ℕ × expr)
 : 1.factor_multiset = 0
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] {R : Type u_2} {S : Type u_3} [comm_ring R] [is_domain R] [comm_semiring S] [algebra S (polynomial K)] [algebra S (polynomial R)] (φ : polynomial K →ₐ[S] polynomial R) (hφ : non_zero_divisors (polynomial K) ≤ submonoid.comap ↑φ (non_zero_divisors (polynomial R))) : ratfunc K →ₐ[S] ratfunc R
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) : Prop
{n : ℕ} {A : Type u} (F : A → typevec n → Type u) [Π (α : A), mvfunctor (F α)] [Π (α : A), mvqpf (F α)] ⦃α : typevec n⦄ : mvqpf.pi F α → (mvqpf.pi.P F).obj α
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] (f : α × β → E) (hf : measure_theory.integrable f (μ.prod ν)) : ∫ (z : α × β), f z ∂μ.prod ν = ∫ (y : β), ∫ (x : α), f (x, y) ∂μ ∂ν
{V : Type u} [category_theory.category V] [category_theory.preadditive V] {P Q : chain_complex V ℕ} (e : P ⟶ Q) (zero : P.X 0 ⟶ Q.X 1) (comm_zero : e.f 0 = zero ≫ Q.d 1 0) (one : P.X 1 ⟶ Q.X 2) (comm_one : e.f 1 = P.d 1 0 ≫ zero + one ≫ Q.d 2 1) (succ : Π (n : ℕ) (p : Σ' (f : P.X n ⟶ Q.X (n + 1)) (f' : P.X (n + 1) ⟶ Q.X (n + 2)), e.f (n + 1) = P.d (n + 1) n ≫ f + f' ≫ Q.d (n + 2) (n + 1)), Σ' (f'' : P.X (n + 2) ⟶ Q.X (n + 3)), e.f (n + 2) = P.d (n + 2) (n + 1) ≫ p.snd.fst + f'' ≫ Q.d (n + 3) (n + 2)) [category_theory.limits.has_zero_object V] (n : ℕ) : Σ' (f : homological_complex.X_next P n ⟶ Q.X n) (f' : P.X n ⟶ homological_complex.X_prev Q n), e.f n = homological_complex.d_from P n ≫ f + f' ≫ homological_complex.d_to Q n
{G : Type u_1} [measurable_space G] [has_add G] (μ : measure_theory.measure G) : Prop
{S : Type v} {σ : Type u_1} [comm_ring S] : (mv_polynomial σ ℤ →+* S) ≃ (σ → S)
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : α → F} {f' : α → E'} {l : filter α} : f' =o[l] g → (λ (x : α), ∥f' x∥) =o[l] g
{I : Type w₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {D : Type u₂} [category_theory.category D] (F : Π (i : I), C i ⥤ D) (X Y : Σ (i : I), C i) : (X ⟶ Y) → ((F X.fst).obj X.snd ⟶ (F Y.fst).obj Y.snd)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [nontrivial k] {p : ι → P} (ha : affine_independent k p) {s1 s2 : set ι} {p0 : P} (hp0s1 : p0 ∈ affine_span k (p '' s1)) (hp0s2 : p0 ∈ affine_span k (p '' s2)) : ∃ (i : ι), i ∈ s1 ∩ s2
{R : Type u} [ring R] ⦃s t : set R⦄ (h : s ⊆ t) : subring.closure s ≤ subring.closure t
{V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] (f : V₁ →+ V₂) {C : ℝ} (h : ∀ (x : V₁), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_normed_group_hom C h∥ ≤ linear_order.max C 0
{γ : Type w} [emetric_space γ] : uniformity γ = ⨅ (ε : ennreal) (H : ε > 0), filter.principal {p : γ × γ | has_edist.edist p.fst p.snd < ε}
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] : continuous (tangent_bundle.proj I M)
(slow : bool := bool.tt) (verbose : lint_verbosity := lint_verbosity.medium) (extra : list name := list.nil) (use_only : bool := bool.ff) : tactic (name_set × format)
{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] (I : ideal R) (hp : I.is_prime) (hd : disjoint ↑M ↑I) : (ideal.map (algebra_map R S) I).is_prime
{I : Type w₀} (C : I → Type u₁) [Π (i : I), category_theory.category (C i)] {J : Type w₁} (h : J → I) : (Π (i : I), C i) ⥤ Π (j : J), C (h j)
{E : Type u_1} [normed_group E] [measurable_space E] [normed_space ℝ E] [finite_dimensional ℝ E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (s : set E) (x : E) (h : filter.tendsto (λ (r : ℝ), ⇑μ (s ∩ metric.closed_ball x r) / ⇑μ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 0)) (t : set E) (ht : measurable_set t) (h''t : ⇑μ t ≠ ⊤) : filter.tendsto (λ (r : ℝ), ⇑μ (s ∩ ({x} + r • t)) / ⇑μ ({x} + r • t)) (nhds_within 0 (set.Ioi 0)) (nhds 0)
{α : Type u_1} {ι : Type u_2} [measurable_space α] (μ : measure_theory.measure α) (l : filter ι) (φ : ι → set α) : Prop
{F : Type u_3} [inner_product_space ℝ F] (x y : F) : has_inner.inner (x + y) (x - y) = 0 ↔ ∥x∥ = ∥y∥
{α : Type u_1} {E : Type u_2} (𝕜 : Type u_4) [normed_group E] {m : measurable_space α} {μ : measure_theory.measure α} [normed_space ℝ E] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [smul_comm_class ℝ 𝕜 E] [complete_space E] : ↥(measure_theory.Lp E 1 μ) →L[𝕜] E
{α : Type u_1} {β : Type u_2} (S : set α) (f : α ≃ β) : ⇑f '' S = ⇑(f.symm) ⁻¹' S
(R : Type u) {ι : Type x} [semiring R] (φ : ι → Type i) [Π (i : ι), add_comm_monoid (φ i)] [Π (i : ι), module R (φ i)] {I J : set ι} [decidable_pred (λ (i : ι), i ∈ I)] (hd : disjoint I J) (hu : set.univ ⊆ I ∪ J) : (↥⨅ (i : ι) (H : i ∈ J), (linear_map.proj i).ker) ≃ₗ[R] Π (i : ↥I), φ ↑i
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] {E' : Type u_7} [normed_group E'] [complete_space E'] [normed_space ℝ E'] ⦃f g : α × β → E⦄ (F : E → E') (hf : measure_theory.integrable f (μ.prod ν)) (hg : measure_theory.integrable g (μ.prod ν)) : ∫ (x : α), F (∫ (y : β), f (x, y) + g (x, y) ∂ν) ∂μ = ∫ (x : α), F (∫ (y : β), f (x, y) ∂ν + ∫ (y : β), g (x, y) ∂ν) ∂μ
{M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] ⦃f g : M →* N⦄ (h : ⇑f = ⇑g) : f = g
{C : Type u} [category_theory.category C] {W X Y Z S T : C} (f₁ : S ⟶ W) (f₂ : S ⟶ X) [category_theory.limits.has_pushout f₁ f₂] (g₁ : T ⟶ Y) (g₂ : T ⟶ Z) [category_theory.limits.has_pushout g₁ g₂] (i₁ : W ⟶ Y) (i₂ : X ⟶ Z) (i₃ : S ⟶ T) (eq₁ : f₁ ≫ i₁ = i₃ ≫ g₁) (eq₂ : f₂ ≫ i₂ = i₃ ≫ g₂) : category_theory.limits.pushout f₁ f₂ ⟶ category_theory.limits.pushout g₁ g₂
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M →+ N} (h : ∀ (y : ↥S), is_add_unit (⇑f ↑y)) (y : ↥S) (w z : N) : w + ↑-⇑(is_add_unit.lift_right (f.restrict S) h) y = z ↔ w = ⇑f ↑y + z
{ι₁ : Sort u_1} {ι₂ : Sort u_2} {κ₁ : ι₁ → Sort u_3} {κ₂ : ι₂ → Sort u_4} {φ : Π (i₁ : ι₁), κ₁ i₁ → Π (i₂ : ι₂), κ₂ i₂ → Sort u_5} (f : Π (i₁ : ι₁) (j₁ : κ₁ i₁) (i₂ : ι₂) (j₂ : κ₂ i₂), φ i₁ j₁ i₂ j₂) (i₂ : ι₂) (j₂ : κ₂ i₂) (i₁ : ι₁) (j₁ : κ₁ i₁) : φ i₁ j₁ i₂ j₂
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} {y : F} (a : ℝ) (h : ∀ (ε : ℝ), 0 < ε → (∃ (r : nnreal → (ι → ℝ) → ↥(set.Ioi 0)), (∀ (c : nnreal), l.r_cond (r c)) ∧ ∀ (c : nnreal) (π : box_integral.tagged_prepartition I), l.mem_base_set I c (r c) π → π.is_partition → has_dist.dist (box_integral.integral_sum f vol π) y ≤ a * ε)) : box_integral.has_integral I l f vol y
{σ : Type u_1} {R : Type u_4} [comm_semiring R] (p : mv_polynomial σ R) : ∃ (n : ℕ) (f : fin n → σ) (hf : function.injective f) (q : mv_polynomial (fin n) R), p = ⇑(mv_polynomial.rename f) q
{𝕜 : Type u_1} {n : Type u_3} [is_R_or_C 𝕜] [fintype n] [decidable_eq n] {U : matrix n n 𝕜} (hU : U ∈ matrix.unitary_group n 𝕜) : ∥U∥ ≤ 1
{α : Type u_1} [measurable_space α] [topological_space α] [borel_space α] (μ : measure_theory.measure α) [measure_theory.is_finite_measure μ] (H : μ.inner_regular is_closed is_open) : μ.weakly_regular
{α : Type u_1} {ι : Type u_2} [measurable_space α] {β : ι → Type u_3} (m : Π (x : ι), measurable_space (β x)) (f : Π (x : ι), α → β x) (μ : measure_theory.measure α . "volume_tac") : Prop
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {F : ℕ → α → ennreal} {f : α → ennreal} (bound : α → ennreal) (hF_meas : ∀ (n : ℕ), measurable (F n)) (h_bound : ∀ (n : ℕ), F n ≤ᵐ[μ] bound) (h_fin : ∫⁻ (a : α), bound a ∂μ ≠ ⊤) (h_lim : ∀ᵐ (a : α) ∂μ, filter.tendsto (λ (n : ℕ), F n a) filter.at_top (nhds (f a))) : filter.tendsto (λ (n : ℕ), ∫⁻ (a : α), F n a ∂μ) filter.at_top (nhds (∫⁻ (a : α), f a ∂μ))
{G : Type u} [add_group G] {H : Type v} [add_group H] (φ : G →+ H) (ψ : H → G) (hφ : function.right_inverse ψ ⇑φ) : G ⧸ φ.ker ≃+ H
{C : Type v} {D : Type v'} [category_theory.category C] [category_theory.concrete_category C] [category_theory.category D] [category_theory.concrete_category D] (obj : C → D) (h_obj : ∀ (X : C), (category_theory.forget D).obj (obj X) = (category_theory.forget C).obj X) (map : Π {X Y : C}, (X ⟶ Y) → (obj X ⟶ obj Y)) (h_map : ∀ {X Y : C} {f : X ⟶ Y}, (category_theory.forget D).map (map f) == (category_theory.forget C).map f) : category_theory.has_forget₂ C D
{E : Type u_1} [semi_normed_group E] [normed_space ℝ E] {x y : E} (h : same_ray ℝ x y) : ∥x + y∥ = ∥x∥ + ∥y∥
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {x : M} : algebra (pointed_smooth_map 𝕜 I M ⊤ x) 𝕜
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} (hf : has_fpower_series_at f p x) : (λ (y : E × E), f y.fst - f y.snd - ⇑(p 1) (λ (_x : fin 1), y.fst - y.snd)) =O[nhds (x, x)] λ (y : E × E), ∥y - (x, x)∥ * ∥y.fst - y.snd∥
{G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure G} [add_group G] [has_measurable_add G] [μ.is_add_right_invariant] (f : G → E) (g : G) : ∫ (x : G), f (x + g) ∂μ = ∫ (x : G), f x ∂μ
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) (f : α → ennreal) : ∃ (g : α → ennreal), measurable g ∧ g ≤ f ∧ ∫⁻ (a : α), f a ∂μ = ∫⁻ (a : α), g a ∂μ
{G : Type u} [group G] {H : Type v} [group H] (φ : G →* H) : G ⧸ φ.ker →* ↥(φ.range)
(f : expr) (nargs : option ℕ := option.none) (md : tactic.transparency := tactic.transparency.semireducible) : tactic congr_lemma
{G : Type u} [add_group G] {H : Type v} [add_group H] (φ : G →+ H) : G ⧸ φ.ker ≃+ ↥(φ.range)
{C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] (G : D ⥤ C) [category_theory.is_right_adjoint G] [category_theory.limits.has_reflexive_coequalizers D] [category_theory.reflects_isomorphisms G] [Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_7 : category_theory.is_reflexive_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G] : category_theory.monadic_right_adjoint G
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} {r : ennreal} {r' : nnreal} (hf : has_fpower_series_on_ball f p x r) (h : ↑r' < r) : ∃ (a : ℝ) (H : a ∈ set.Ioo 0 1) (C : ℝ) (H : C > 0), ∀ (y : E), y ∈ metric.ball 0 ↑r' → ∀ (n : ℕ), ∥f (x + y) - p.partial_sum n y∥ ≤ C * a ^ n
{α : Type u} [pseudo_emetric_space α] {δ : ℝ} (ε : ℝ) (hδ : 0 ≤ δ) (s : set α) : metric.thickening ε (metric.cthickening δ s) ⊆ metric.thickening (ε + δ) s
{G : Type u} [group G] [fintype G] (hn : ∀ {p : ℕ} [_inst_3 : fact (nat.prime p)] (P : sylow p G), ↑P.normal) : (Π (p : ↥((fintype.card G).factorization.support)) (P : sylow ↑p G), ↥↑P) ≃* G
{α : Type u_1} [topological_space α] {m : measurable_space α} [topological_space.second_countable_topology α] [linear_order α] [order_topology α] [borel_space α] (μ ν : measure_theory.measure α) [measure_theory.is_finite_measure μ] (hμν : ⇑μ set.univ = ⇑ν set.univ) (h : ∀ ⦃a b : α⦄, a < b → ⇑μ (set.Ico a b) = ⇑ν (set.Ico a b)) : μ = ν
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} {σ : Type u_4} (M : Λ → turing.TM2.stmt Γ Λ σ) : turing.TM2.cfg Γ Λ σ → turing.TM2.cfg Γ Λ σ → Prop
{V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) : ⇑(o.rotation (o.oangle x y)) x = y ↔ ∥x∥ = ∥y∥
{R : Type u_1} [comm_semiring R] (I : ideal R) [hp : I.is_prime] : local_ring (localization I.prime_compl)
{α : Type u} {β : Type v} (e : α ≃ β) [has_add β] [has_mul β] : let _inst : has_add α := e.has_add, _inst_3 : has_mul α := e.has_mul in α ≃+* β
{α : Type u_1} {E : Type u_2} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {f : α → E} : summable (λ (x : α), ∥f x∥) ↔ summable f
{R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_semiring R] [add_comm_monoid M] [module R M] [decidable_eq ι] (e : ι → M) (ε : ι → module.dual R M) : Type (max u_2 u_3)
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} (f : α →ₘ[μ] ennreal) : ennreal
{R : Type u} [ring R] {ι : Type v} [preorder ι] (G : ι → Type v) [Π (i : ι), add_comm_group (G i)] [Π (i : ι), module R (G i)] (f : Π (i j : ι), i ≤ j → (G i →ₗ[R] G j)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] [decidable_eq ι] : category_theory.limits.cocone (Module.direct_limit_diagram G f)
(h : expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic congr_lemma
{n : ℕ} {K : Type u_1} [field K] {μ : K} (h : is_primitive_root μ n) (hpos : 0 < n) [char_zero K] : minpoly ℤ μ ∣ polynomial.cyclotomic n ℤ
{σ : Type u_1} {R : Type u_2} [comm_semiring R] (A : Type u_3) [comm_semiring A] [algebra R A] : mv_polynomial σ R →ₐ[R] mv_power_series σ A
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} (p : ennreal) (μ : measure_theory.measure α) [normed_group E] [topological_space α] [borel_space α] [second_countable_topology_either α E] [compact_space α] [measure_theory.is_finite_measure μ] (𝕜 : Type u_5) [fact (1 ≤ p)] [normed_field 𝕜] [normed_space 𝕜 E] : C(α, E) →L[𝕜] ↥(measure_theory.Lp E p μ)
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (μ : R) (k : ℕ) : Prop
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} {r r' : ennreal} (hf : has_fpower_series_on_ball f p x r) (hr : r' < r) : (λ (y : E × E), f y.fst - f y.snd - ⇑(p 1) (λ (_x : fin 1), y.fst - y.snd)) =O[filter.principal (emetric.ball (x, x) r')] λ (y : E × E), ∥y - (x, x)∥ * ∥y.fst - y.snd∥
{α : Type u_1} {E : Type u_3} [measurable_space α] [normed_group E] (f : α → E) (l : filter α) (μ : measure_theory.measure α . "volume_tac") : Prop
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {F : Type u_5} [normed_group F] [normed_space 𝕜 F] (Z : basic_smooth_vector_bundle_core I M F) : smooth_manifold_with_corners (I.prod (model_with_corners_self 𝕜 F)) Z.to_topological_vector_bundle_core.total_space
{L : first_order.language} {ι : Type v} [preorder ι] (G : ι → Type w) [Π (i : ι), L.Structure (G i)] (f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] [is_directed ι has_le.le] : Type (max v w)
(use_iota_eqn : interactive.parse (optional (lean.parser.tk "!"))) (trace_lemmas : interactive.parse (optional (lean.parser.tk "?"))) (no_dflt : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (locat : interactive.parse interactive.types.location) (cfg : tactic.simp_config_ext := {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}, discharger := tactic.failed unit}) : tactic unit
(σ : Type u_1) (R : Type u_2) (p : ℕ) [comm_semiring R] [invertible ↑p] : invertible ↑p
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {s : set (α × β)} (h : ⇑(μ.prod ν) s = 0) : (λ (x : α), ⇑ν (prod.mk x ⁻¹' s)) =ᵐ[μ] 0
{α : Type u_2} [preorder α] {ι : Type u_6} {π : ι → Type u_7} [Π (i : ι), preorder (π i)] (f : Π (i : ι), α →o π i) : α →o Π (i : ι), π i
{G : Type u_1} [add_group G] [topological_space G] [t2_space G] [topological_add_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] (μ : measure_theory.measure G) [μ.is_add_haar_measure] [locally_compact_space G] (E : set G) (hE : measurable_set E) (hEpos : 0 < ⇑μ E) : E - E ∈ nhds 0
{R : Type u} [comm_ring R] {L : Type v} {M : Type w} [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (I : lie_ideal R L) (N : lie_submodule R L M) : ⁅I,N⁆ = ((lie_module.to_module_hom R L M).comp (tensor_product.lie_module.map_incl I N)).range
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} [subsingleton ι] (hp_one : 1 ≤ p) (hp_top : p ≠ ⊤) {f : ι → α → β} (hf : ∀ (i : ι), measure_theory.mem_ℒp (f i) p μ) : measure_theory.unif_integrable f p μ
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ⟶ Y) [category_theory.limits.has_kernel f] {W : C} (k : W ⟶ X) (h : k ≫ f = 0) : {l // l ≫ category_theory.limits.kernel.ι f = k}
{σ : Type u_1} {R : Type u_2} [semiring R] {φ ψ : mv_power_series σ R} (h : ∀ (n : σ →₀ ℕ), ⇑(mv_power_series.coeff R n) φ = ⇑(mv_power_series.coeff R n) ψ) : φ = ψ
{σ : Type u_1} {R : Type u_3} [comm_semiring R] : mv_polynomial σ (mv_polynomial σ R) →+* mv_polynomial σ R
{M : Type u_1} [add_monoid M] {γ : Type u_2} [add_monoid γ] {f : M → γ} (hf : is_add_monoid_hom f) {s : set M} (hs : is_add_submonoid s) : is_add_submonoid (f '' s)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] (I : model_with_corners 𝕜 E H) (G : Type u_4) [has_mul G] [topological_space G] [charted_space H G] : Prop
(hs : interactive.parse tactic.simp_arg_list) (ps : interactive.parse (optional (lean.parser.tk "using" *> interactive.types.pexpr_list_or_texpr))) (cfg : auto.auto_config := {use_simp := bool.tt, max_ematch_rounds := 20}) : tactic unit
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (P Q : cochain_complex V ℕ) (zero : P.X 0 ⟶ Q.X 0) (one : P.X 1 ⟶ Q.X 1) (one_zero_comm : zero ≫ Q.d 0 1 = P.d 0 1 ≫ one) (succ : Π (n : ℕ) (p : Σ' (f : P.X n ⟶ Q.X n) (f' : P.X (n + 1) ⟶ Q.X (n + 1)), f ≫ Q.d n (n + 1) = P.d n (n + 1) ≫ f'), Σ' (f'' : P.X (n + 2) ⟶ Q.X (n + 2)), p.snd.fst ≫ Q.d (n + 1) (n + 2) = P.d (n + 1) (n + 2) ≫ f'') (n : ℕ) : Σ' (f : P.X n ⟶ Q.X n) (f' : P.X (n + 1) ⟶ Q.X (n + 1)), f ≫ Q.d n (n + 1) = P.d n (n + 1) ≫ f'
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i * g i) ≤ s.sum (λ (i : ι), f (⇑σ i) * g i)
{α : Type u} [pseudo_emetric_space α] (x : α) (ε : ennreal) : set α
(t : tactic unit := tactic.skip) : tactic unit
{α : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space α} (X : α → E) (support : set E) (ℙ : measure_theory.measure α) (μ : measure_theory.measure E . "volume_tac") : Prop
{X : Type u_1} [pseudo_emetric_space X] [measurable_space X] (μ : measure_theory.measure X) : μ.inner_regular is_closed is_open
{E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (hs : measurable_set s) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) : ae_measurable f' (μ.restrict s)
{n : ℕ} (hn : n ≠ 0) : n.totient = n.factorization.prod (λ (p k : ℕ), p ^ (k - 1) * (p - 1))
{R : Type u_1} [comm_ring R] (I : ideal R) : ring_filter_basis R
{α : Type u_1} [preorder α] {f : α → α} {x : α} (hf : strict_mono f) (hx : f x < x) : strict_anti (λ (n : ℕ), f^[n] x)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {s : set M} [smooth_manifold_with_corners I' M'] (hs : unique_mdiff_on I s) {e : local_homeomorph M M'} (he : local_homeomorph.mdifferentiable I I' e) : unique_mdiff_on I' (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s)
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] [has_measurable_inv G] [μ.is_mul_left_invariant] [ν.is_mul_left_invariant] : measure_theory.measure.map (λ (z : G × G), (z.snd * z.fst, (z.fst)⁻¹)) (μ.prod ν) = μ.prod ν
{ι : Type v} [dec_ι : decidable_eq ι] [preorder ι] (G : ι → Type w) [Π (i : ι), add_comm_group (G i)] (f : Π (i j : ι), i ≤ j → G i →+ G j) : Type (max v w)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ⟶ Y} {Z : C} (π : Y ⟶ Z) (w : f ≫ π = 0) : category_theory.limits.cokernel_cofork f
{α : Type u_1} {β : Type u_2} {σ : Type u_3} [primcodable α] [primcodable β] [primcodable σ] (f : α → β → σ) : Prop
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C → D) [I : category_theory.functorial F] : C ⥤ D
{E : Type u_1} [normed_group E] [normed_space ℝ E] [complete_space E] {φ : E → ℝ} {x₀ : E} {φ' : E →L[ℝ] ℝ} {ι : Type u_2} [fintype ι] {f : ι → E → ℝ} {f' : ι → (E →L[ℝ] ℝ)} (hextr : is_local_extr_on φ {x : E | ∀ (i : ι), f i x = f i x₀} x₀) (hf' : ∀ (i : ι), has_strict_fderiv_at (f i) (f' i) x₀) (hφ' : has_strict_fderiv_at φ φ' x₀) : ¬linear_independent ℝ (option.elim φ' f')
{I : Type u} (X : I → Top) : category_theory.limits.cone (category_theory.discrete.functor X ⋙ fundamental_groupoid.fundamental_groupoid_functor) ≌ category_theory.limits.cone (category_theory.discrete.functor (λ (i : I), fundamental_groupoid.fundamental_groupoid_functor.obj (X i)))
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} {y : F} (h : box_integral.has_integral I l f vol y) : filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I ⊤) (nhds y)
{elab : bool := bool.tt} : expr elab → option (expr elab × expr elab)
{α : Type u_1} [normed_ring α] [complete_space α] {f g : ℕ → α} (hf : summable (λ (x : ℕ), ∥f x∥)) (hg : summable (λ (x : ℕ), ∥g x∥)) : (∑' (n : ℕ), f n) * ∑' (n : ℕ), g n = ∑' (n : ℕ), (finset.nat.antidiagonal n).sum (λ (kl : ℕ × ℕ), f kl.fst * g kl.snd)
(α : Type u) (β : Type v) [group α] [mul_action α β] : β ≃ Σ (ω : quotient (mul_action.orbit_rel α β)), α ⧸ mul_action.stabilizer α ω.out'
(e : expr) (md : tactic.transparency := tactic.transparency.reducible) : tactic (list expr)
{σ : Type u_1} (R : Type u_2) {A : Type u_3} [comm_semiring R] [add_comm_monoid A] [module R A] [module (mv_polynomial σ R) A] [is_scalar_tower R (mv_polynomial σ R) A] : (σ → A) ≃ₗ[R] derivation R (mv_polynomial σ R) A
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group β] (f g : ↥(measure_theory.Lp β 1 μ)) : ennreal.of_real ∥f - g∥ = ∫⁻ (x : α), ↑∥⇑f x - ⇑g x∥₊ ∂μ
{p : ℕ} [fact (nat.prime p)] {R : Type u₁} [comm_semiring R] [char_p R p] {P : Type u₃} [comm_semiring P] [char_p P p] [perfect_ring P p] {π : P →+* R} (m : perfection_map p π) : P ≃+* ring.perfection R p
(V : Type u₁) [quiver V] (W : Type u₂) [quiver W] : Sort (max (imax (u₁+1) (u₁+1) v₁ v₂) (u₁+1) (u₂+1))
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} [inhabited Λ] {σ : Type u_4} [inhabited σ] : Type (max u_1 u_2 u_3 u_4)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] {μ : measure_theory.measure α} [topological_space β] [topological_space γ] (f : α →ₘ[μ] β) (g : α →ₘ[μ] γ) : α →ₘ[μ] β × γ
{α : Sort u₁} {β : Sort u₂} {φ : Sort u₃} (f : β → φ) (g : α → β) : α → φ
{α : Type u_1} {ι : Type u_5} {m : measurable_space α} (μ : measure_theory.measure α) {s : finset ι} {t : ι → set α} (h : ∀ (i : ι), i ∈ s → measurable_set (t i)) (H : ⇑μ set.univ < s.sum (λ (i : ι), ⇑μ (t i))) : ∃ (i : ι) (H : i ∈ s) (j : ι) (H : j ∈ s) (h : i ≠ j), (t i ∩ t j).nonempty
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f i • g (⇑σ i)) < finset.univ.sum (λ (i : ι), f i • g i) ↔ ¬monovary f (g ∘ ⇑σ)
{α : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {m : measurable_space α} {μ : measure_theory.measure α} (T : set α → (E →L[ℝ] F)) (f : ↥(measure_theory.Lp.simple_func E 1 μ)) : F
{L : first_order.language} {ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), L.Structure (G i)] (f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] {i j k : ι} (hij : i ≤ j) (hjk : j ≤ k) (x : G i) : ⇑(f j k hjk) (⇑(f i j hij) x) = ⇑(f i k _) x
{X : Type u_1} {R : Type u_9} {ι : Type u_10} {U : ι → set X} [topological_space X] [has_one R] {f : ι → X → R} (hlf : locally_finite (λ (i : ι), function.mul_support (f i))) (hso : ∀ (i : ι), mul_tsupport (f i) ⊆ U i) (ho : ∀ (i : ι), is_open (U i)) (x : X) : ∃ (is : finset ι) {n : set X} (hn₁ : n ∈ nhds x) (hn₂ : n ⊆ ⋂ (i : ι) (H : i ∈ is), U i), ∀ (z : X), z ∈ n → function.mul_support (λ (i : ι), f i z) ⊆ ↑is
{P : Π (G : Type u_1) [_inst_3 : group G] [_inst_4 : group.is_nilpotent G], Prop} (G : Type u_1) [group G] [group.is_nilpotent G] (hbase : ∀ (G : Type u_1) [_inst_6 : group G] [_inst_7 : subsingleton G], P G) (hstep : ∀ (G : Type u_1) [_inst_8 : group G] [_inst_9 : group.is_nilpotent G], P (G ⧸ subgroup.center G) → P G) : P G
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] (F : V ⥤ W) [F.additive] (c : complex_shape ι) : homological_complex V c ⥤ homological_complex W c
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {s : set α} (hms : measurable_set s) (t : set α) : ⇑(probability_theory.cond μ s) t = (⇑μ s)⁻¹ * ⇑μ (s ∩ t)
{R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] (I J : fractional_ideal S P) : fractional_ideal S P
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] {cM : add_con M} {cN : add_con N} {φ : cM.quotient → cN.quotient → Sort u_3} (a : cM.quotient) (b : cN.quotient) (f : Π (x : M) (y : N), φ ↑x ↑y) (h : ∀ (x : M) (y : N) (x' : M) (y' : N), ⇑cM x x' → ⇑cN y y' → f x y == f x' y') : φ a b
{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} : uniform_embedding f ↔ function.injective f ∧ uniform_continuous f ∧ ∀ (δ : ennreal), δ > 0 → (∃ (ε : ennreal) (H : ε > 0), ∀ {a b : α}, has_edist.edist (f a) (f b) < ε → has_edist.edist a b < δ)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : local_homeomorph M M') : Prop
{n : ℕ+} {K : Type u} [field K] [char_zero K] {ζ : K} [is_cyclotomic_extension {n} ℚ K] (hζ : is_primitive_root ζ ↑n) : algebra.discr ℚ ⇑((is_primitive_root.power_basis ℚ hζ).basis) = algebra.discr ℚ ⇑((is_primitive_root.sub_one_power_basis ℚ hζ).basis)
{C : Type u₁} [category_theory.category C] {X Y W : C} (f : X ⟶ Y) [category_theory.regular_epi f] (k : X ⟶ W) (h : category_theory.regular_epi.left ≫ k = category_theory.regular_epi.right ≫ k) : {l // f ≫ l = k}
{V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ℝ P) {i₁ i₂ : fin 3} (h : i₁ ≠ i₂) : has_dist.dist t.orthocenter (⇑(euclidean_geometry.reflection (affine_span ℝ (t.points '' {i₁, i₂}))) (affine.simplex.circumcenter t)) = affine.simplex.circumradius t
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [topological_space.second_countable_topology α] : ∀ᵐ (x : α) ∂μ, ∀ᶠ (a : set α) in v.filter_at x, 0 < ⇑μ a
{α : Sort u₁} {β : α → Sort u₂} {φ : Π {x : α}, β x → Sort u₃} (f : Π {x : α} (y : β x), φ y) (g : Π (x : α), β x) (x : α) : φ (g x)
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) : category_theory.limits.walking_multicospan I.fst_to I.snd_to ⥤ C
{α : Type u} [topological_space α] {ι : Type u_1} {s : ι → set α} (H : ∀ (i : ι), is_preconnected (s i)) (K : ∀ (i j : ι), relation.refl_trans_gen (λ (i j : ι), (s i ∩ s j).nonempty) i j) : is_preconnected (⋃ (n : ι), s n)
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i * g (⇑σ i)) = s.sum (λ (i : ι), f i * g i) ↔ monovary_on f (g ∘ ⇑σ) ↑s
{E : Type u_1} [normed_group E] [normed_space ℂ E] {a b : ℝ} {f g : ℂ → E} (hdf : diff_cont_on_cl ℂ f (complex.re ⁻¹' set.Ioo a b)) (hBf : ∃ (c : ℝ) (H : c < real.pi / (b - a)) (B : ℝ), f =O[filter.comap (has_abs.abs ∘ complex.im) filter.at_top ⊓ filter.principal (complex.re ⁻¹' set.Ioo a b)] λ (z : ℂ), real.exp (B * real.exp (c * |z.im|))) (hdg : diff_cont_on_cl ℂ g (complex.re ⁻¹' set.Ioo a b)) (hBg : ∃ (c : ℝ) (H : c < real.pi / (b - a)) (B : ℝ), g =O[filter.comap (has_abs.abs ∘ complex.im) filter.at_top ⊓ filter.principal (complex.re ⁻¹' set.Ioo a b)] λ (z : ℂ), real.exp (B * real.exp (c * |z.im|))) (ha : ∀ (z : ℂ), z.re = a → f z = g z) (hb : ∀ (z : ℂ), z.re = b → f z = g z) : set.eq_on f g (complex.re ⁻¹' set.Icc a b)
(α : Type u_1) (M : Type u_2) (R : Type u_5) [semiring R] [add_comm_monoid M] [module R M] (v : α → M) (s : set α) : ↥(finsupp.supported R R s) →ₗ[R] ↥(submodule.span R (v '' s))
{α : Type u_1} [topological_space α] {β : Type u_2} [topological_space β] [polish_space β] {s : set β} (hs : is_open s) {f : β → α} (f_cont : continuous f) : measure_theory.analytic_set (f '' s)
{α : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space α} {ℙ : measure_theory.measure α} {μ : measure_theory.measure E} [measure_theory.is_finite_measure «ℙ»] {X : α → E} [measure_theory.has_pdf X «ℙ» μ] {f : E → ℝ} (hf : measurable f) : ∫ (x : E), f x * (measure_theory.pdf X «ℙ» μ x).to_real ∂μ = ∫ (x : α), f (X x) ∂«ℙ»
(p : pexpr) (m : tactic.transparency := tactic.transparency.reducible) : tactic (list expr)
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {F : 𝕜 → α → E} {F' : α → E} {x₀ : 𝕜} {ε : ℝ} (ε_pos : 0 < ε) (hF_meas : ∀ᶠ (x : 𝕜) in nhds x₀, measure_theory.ae_strongly_measurable (F x) μ) (hF_int : measure_theory.integrable (F x₀) μ) (hF'_meas : measure_theory.ae_strongly_measurable F' μ) {bound : α → ℝ} (h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : 𝕜), F x a) (metric.ball x₀ ε)) (bound_integrable : measure_theory.integrable bound μ) (h_diff : ∀ᵐ (a : α) ∂μ, has_deriv_at (λ (x : 𝕜), F x a) (F' a) x₀) : measure_theory.integrable F' μ ∧ has_deriv_at (λ (x : 𝕜), ∫ (a : α), F x a ∂μ) (∫ (a : α), F' a ∂μ) x₀
{V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : real.angle) : hb.oangle x y = θ ↔ y = (∥y∥ / ∥x∥) • ⇑(hb.rotation θ) x
(σ σ' : out_param (Type u)) (m m' : Type u → Type v) : Type (max (u+1) v)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {H : Type u_4} [topological_space H] {I : model_with_corners 𝕜 E H} {H' : Type u_5} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {N : Type u_6} [topological_space N] [charted_space H N] {G : Type u_7} [monoid G] [topological_space G] [charted_space H' G] [has_smooth_mul I' G] : cont_mdiff_map I I' N G ⊤ →* N → G
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {G : ι → Type u_5} [Π (i : ι), inner_product_space 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : orthogonal_family 𝕜 V) [complete_space E] (f : Π (i : ι), G i) : summable (λ (i : ι), ⇑(V i) (f i)) ↔ summable (λ (i : ι), ∥f i∥ ^ 2)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {W X Y Z : C} [category_theory.limits.has_binary_biproduct W X] [category_theory.limits.has_binary_biproduct Y Z] (f : W ⟶ Y) (g : X ⟶ Z) : W ⊞ X ⟶ Y ⊞ Z
{R : Type u} {M₂ : Type w} {ι : Type x} [semiring R] [add_comm_monoid M₂] [module R M₂] {φ : ι → Type i} [Π (i : ι), add_comm_monoid (φ i)] [Π (i : ι), module R (φ i)] (f : Π (i : ι), M₂ →ₗ[R] φ i) : M₂ →ₗ[R] Π (i : ι), φ i
{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {x : α} {t : set α} {Φ : α → β} (hΦ : isometry Φ) : emetric.inf_edist (Φ x) (Φ '' t) = emetric.inf_edist x t
{α : Type u} {β : Type v} [topological_space α] [semi_normed_group β] (b : β) : ∥bounded_continuous_function.const α b∥ ≤ ∥b∥
(V : Type u_1) [semi_normed_group V] (h : ∃ (x : V), ∥x∥ ≠ 0) : ∥normed_group_hom.id V∥ = 1
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ⟶ Y} {s : category_theory.limits.kernel_fork f} (hs : category_theory.limits.is_limit s) {W : C} (k : W ⟶ X) (h : k ≫ f = 0) : {l // l ≫ category_theory.limits.fork.ι s = k}
{M : Type u_1} {N : Type u_2} {σ : Type u_4} [has_add M] [has_add N] [set_like σ N] [add_mem_class σ N] (f : add_hom M N) (S : σ) (h : ∀ (x : M), ⇑f x ∈ S) : add_hom M ↥S
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} {s : category_theory.limits.fork f g} (hs : category_theory.limits.is_limit s) {W : C} (k : W ⟶ X) (h : k ≫ f = k ≫ g) : {l // l ≫ s.ι = k}
(fr : name) (to : list name) : tactic unit
{X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] {f : X → E} {μ : measure_theory.measure X} [opens_measurable_space X] [topological_space.metrizable_space X] [measure_theory.is_locally_finite_measure μ] (hf : continuous f) : measure_theory.locally_integrable f μ
{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] {L : Type u_1} {S : Type u_3} [field L] [comm_semiring S] [algebra S (polynomial K)] [algebra S L] (φ : polynomial K →ₐ[S] L) (hφ : non_zero_divisors (polynomial K) ≤ submonoid.comap ↑φ (non_zero_divisors L)) : ratfunc K →ₐ[S] L
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) (h : has_inner.inner x y = 0) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : ℕ → α → ennreal} (h_meas : ∀ (n : ℕ), measurable (f n)) : ∫⁻ (a : α), filter.at_top.liminf (λ (n : ℕ), f n a) ∂μ ≤ filter.at_top.liminf (λ (n : ℕ), ∫⁻ (a : α), f n a ∂μ)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} {Fₗ : Type u_7} [normed_group E] [normed_group F] [normed_group Fₗ] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] [normed_space 𝕜 Fₗ] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →SL[σ₁₂] F) [complete_space F] (e : E →L[𝕜] Fₗ) (h_dense : dense_range ⇑e) {N : nnreal} (h_e : ∀ (x : E), ∥x∥ ≤ ↑N * ∥⇑e x∥) [ring_hom_isometric σ₁₂] : ∥f.extend e h_dense _∥ ≤ ↑N * ∥f∥
(𝕜 : Type u) {ι : Type v} {ι' : Type v'} (G : Type wG) (G' : Type wG') [decidable_eq ι] [fintype ι] [decidable_eq ι'] [fintype ι'] [nondiscrete_normed_field 𝕜] [normed_group G] [normed_space 𝕜 G] [normed_group G'] [normed_space 𝕜 G'] (σ : ι ≃ ι') : continuous_multilinear_map 𝕜 (λ (_x : ι), G) G' ≃ₗᵢ[𝕜] continuous_multilinear_map 𝕜 (λ (_x : ι'), G) G'
{α : Type u} {β : Type v} [topological_space α] [semi_normed_group β] {f : bounded_continuous_function α β} {C : ℝ} (C0 : 0 ≤ C) : ∥f∥ ≤ C ↔ ∀ (x : α), ∥⇑f x∥ ≤ C
{I : Type v₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {J : Type v₁} [category_theory.small_category J] {F : J ⥤ Π (i : I), C i} [∀ (i : I), category_theory.limits.has_colimit (F ⋙ category_theory.pi.eval C i)] : category_theory.limits.has_colimit F
{X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] (f : X → E) (μ : measure_theory.measure X . "volume_tac") : Prop
{α : Type u_1} [emetric_space α] [cs : complete_space α] {K : nnreal} {f : α → α} (hf : contracting_with K f) (x : α) (hx : has_edist.edist x (f x) ≠ ⊤) : ∃ (y : α), function.is_fixed_pt f y ∧ filter.tendsto (λ (n : ℕ), f^[n] x) filter.at_top (nhds y) ∧ ∀ (n : ℕ), has_edist.edist (f^[n] x) y ≤ has_edist.edist x (f x) * ↑K ^ n / (1 - ↑K)
{α : Type u} [pseudo_emetric_space α] {β : Type u_1} {p : β → Prop} {f : β → ennreal} (hf₀ : ∀ (x : β), p x → 0 < f x) (hf : ∀ (ε : ennreal), 0 < ε → (∃ (x : β) (hx : p x), f x ≤ ε)) : (uniformity α).has_basis p (λ (x : β), {p : α × α | has_edist.edist p.fst p.snd ≤ f x})
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w₁} [category_theory.category D] {E : Type w₂} [category_theory.category E] (F : D ⥤ E) [∀ (α β : Type (max v u)) (fst snd : β → α), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) D] [∀ (α β : Type (max v u)) (fst snd : β → α), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) E] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ D] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ E] [Π (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)ᵒᵖ F] [Π (X : C) (W : J.cover X) (P : Cᵒᵖ ⥤ D), category_theory.limits.preserves_limit (W.index P).multicospan F] (P : Cᵒᵖ ⥤ D) : J.sheafify P ⋙ F ≅ J.sheafify (P ⋙ F)
{G : Type u_1} [measurable_space G] [group G] [topological_space G] [topological_group G] [borel_space G] [t1_space G] [locally_compact_space G] [(nhds_within 1 {1}ᶜ).ne_bot] (μ : measure_theory.measure G) [μ.is_haar_measure] : measure_theory.has_no_atoms μ
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} {σ : Type u_4} (M : Λ → turing.TM2.stmt Γ Λ σ) (S : finset Λ) : finset (option (turing.TM2.stmt Γ Λ σ))
{X : Type u_1} [topological_space X] {U W : set X} (hW : is_path_connected W) (hWU : W ⊆ U) : is_path_connected (coe ⁻¹' W)
{n : ℕ} {α : Type u_1} {β : Type u_2} {γ : Type u_3} {C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort u_4} (u : vector α n) (v : vector β n) (w : vector γ n) (h_nil : C vector.nil vector.nil vector.nil) (h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥx) (b::ᵥy) (c::ᵥz)) : C u v w
{R : Type u_1} [semiring R] {φ : power_series R} : φ.order = ⊤ ↔ φ = 0
{α : Type u_1} {E : Type u_3} [measurable_space α] [normed_group E] {f : α → E} {μ : measure_theory.measure α} {l : filter α} [l.is_measurably_generated] (hfm : strongly_measurable_at_filter f l μ) (hμ : μ.finite_at_filter l) {b : E} (hf : filter.tendsto f l (nhds b)) : measure_theory.integrable_at_filter f l μ
{E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (s : submodule ℝ E) (hs : s ≠ ⊤) : ⇑μ ↑s = 0
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {s t : set α} (H : s ≤ᵐ[μ] t) : ⇑μ s ≤ ⇑μ t
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] (l : list Γ) : turing.TM0.cfg Γ Λ
{E : Type u} [normed_group E] [normed_space ℝ E] {n : ℕ} [complete_space E] (I : box_integral.box (fin (n + 1))) {i : fin (n + 1)} {f : (fin (n + 1) → ℝ) → E} {f' : (fin (n + 1) → ℝ) →L[ℝ] E} (hfc : continuous_on f (⇑box_integral.box.Icc I)) {x : fin (n + 1) → ℝ} (hxI : x ∈ ⇑box_integral.box.Icc I) {a : E} {ε : ℝ} (h0 : 0 < ε) (hε : ∀ (y : fin (n + 1) → ℝ), y ∈ ⇑box_integral.box.Icc I → ∥f y - a - ⇑f' (y - x)∥ ≤ ε * ∥y - x∥) {c : nnreal} (hc : I.distortion ≤ c) : ∥finset.univ.prod (λ (j : fin (n + 1)), I.upper j - I.lower j) • ⇑f' (pi.single i 1) - (box_integral.integral (I.face i) ⊥ (f ∘ i.insert_nth (I.upper i)) box_integral.box_additive_map.volume - box_integral.integral (I.face i) ⊥ (f ∘ i.insert_nth (I.lower i)) box_integral.box_additive_map.volume)∥ ≤ 2 * ε * ↑c * finset.univ.prod (λ (j : fin (n + 1)), I.upper j - I.lower j)
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {σ : Type u_4} [inhabited σ] {k : K} (v : σ) (l : list (Γ k)) : turing.TM2to1.st_act k → σ
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i * g i) < finset.univ.sum (λ (i : ι), f (⇑σ i) * g i) ↔ ¬antivary (f ∘ ⇑σ) g
(aggressive : bool := bool.ff) : tactic unit
{ι : Type u_1} {I J : box_integral.box ι} (π : box_integral.prepartition I) (h : I ≤ J) : (π.restrict J).boxes = π.boxes
(I : Type u) (α : Type u_1) (β : Type u_2) [semiring α] [add_comm_monoid β] [module α β] : module α (I → β)
{E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] (I : model_with_corners ℝ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} [t2_space M] {s : set M} (hs : s ∈ nhds c) : (nhds c).has_basis (λ (f : smooth_bump_function I c), tsupport ⇑f ⊆ s) (λ (f : smooth_bump_function I c), function.support ⇑f)
{G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G → E'} [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ E'] [inner_product_space ℝ G] [complete_space E'] [borel_space G] [measure_theory.is_locally_finite_measure μ] [μ.is_open_pos_measure] [finite_dimensional ℝ G] [μ.is_add_left_invariant] {ι : Type u_1} {φ : ι → cont_diff_bump_of_inner 0} {l : filter ι} (hφ : filter.tendsto (λ (i : ι), (φ i).R) l (nhds 0)) (hmg : measure_theory.ae_strongly_measurable g μ) {x₀ : G} (hcg : continuous_at g x₀) : filter.tendsto (λ (i : ι), convolution (λ (x : G), (φ i).normed μ x) g (continuous_linear_map.lsmul ℝ ℝ) μ x₀) l (nhds (g x₀))
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {s : set E} {f' : E →L[𝕜] F} {x : E} (h : has_fderiv_within_at f f' s x) (hs : unique_diff_within_at 𝕜 s x) (h' : dense_range ⇑f') : unique_diff_within_at 𝕜 (f '' s) (f x)
{ι : Type u_1} {α : ι → Type u_3} [fintype ι] {C : Π (i : ι), set (set (α i))} (hC : ∀ (i : ι), is_countably_spanning (C i)) : measurable_space.pi = measurable_space.generate_from (set.univ.pi '' set.univ.pi C)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} (hf : has_fpower_series_at f p x) (n : ℕ) : (λ (y : E), f (x + y) - p.partial_sum n y) =O[nhds 0] λ (y : E), ∥y∥ ^ n
{α : Type u} [linear_ordered_add_comm_group α] {a b x : α} (h : x ∈ set.interval a b) : |x - a| ≤ |b - a|
{α : Type u_1} {E : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] {m : measurable_space α} (μ : measure_theory.measure α) (f : α → E) : E
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr × expr)
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} [category_theory.limits.has_coequalizer f g] {W : C} (k : Y ⟶ W) (h : f ≫ k = g ≫ k) : category_theory.limits.coequalizer f g ⟶ W
{I : Type u} (f : I → Type v) [decidable_eq I] [Π (i : I), add_zero_class (f i)] (i : I) : f i →+ Π (i : I), f i
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [cs : complete_space E] {f : E → F} {s : set E} {c : nnreal} {f' : E →L[𝕜] F} (hf : approximates_linear_on f f' s c) (f'symm : f'.nonlinear_right_inverse) {ε : ℝ} {b : E} (ε0 : 0 ≤ ε) (hε : metric.closed_ball b ε ⊆ s) : set.surj_on f (metric.closed_ball b ε) (metric.closed_ball (f b) (((↑(f'symm.nnnorm))⁻¹ - ↑c) * ε))
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_10} [semi_normed_group E'] [normed_space 𝕜 E'] [ring_hom_isometric σ₁₂] (f : E' → F) {s : set (E' →SL[σ₁₂] F)} (hs : metric.bounded s) (hf : f ∈ closure (coe_fn '' s)) : E' →SL[σ₁₂] F
(F : Type u_1) (E : Type u_2) [field F] [field E] [algebra F E] [finite_dimensional F E] (K : Type u_3) [field K] [algebra F K] (φ : E →ₐ[F] K) (x : ↥(set.range ⇑(finite_dimensional.fin_basis F E))) : {l // l ∈ (polynomial.map (algebra_map F K) (minpoly F x.val)).roots}
{ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a : ℝ} {c : E} {l l' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {u v : ι → ℝ} [measure_theory.is_locally_finite_measure μ] [interval_integral.FTC_filter a l l'] (hfm : strongly_measurable_at_filter f l' μ) (hf : filter.tendsto f (l' ⊓ μ.ae) (nhds c)) (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) (huv : v ≤ᶠ[lt] u) : (λ (t : ι), ∫ (x : ℝ) in u t..v t, f x ∂μ + (⇑μ (set.Ioc (v t) (u t))).to_real • c) =o[lt] λ (t : ι), (⇑μ (set.Ioc (v t) (u t))).to_real
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] : category_theory.limits.fork I.fst_pi_map I.snd_pi_map ⥤ category_theory.limits.multifork I
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : M → M') : Prop
{α : Type u_1} {β : Type u_2} [normed_group β] {m : measurable_space α} (f : α → β) (μ : measure_theory.measure α . "volume_tac") : Prop
(attr_name c_name : name) (persistent : bool := bool.tt) (prio : option ℕ := option.none) : tactic unit
{ι : Type u_1} {σ : Type u_2} {R : Type u_4} [decidable_eq ι] [has_add ι] [non_unital_non_assoc_semiring R] [set_like σ R] [add_submonoid_class σ R] (A : ι → σ) [set_like.has_graded_mul A] : direct_sum.gnon_unital_non_assoc_semiring (λ (i : ι), ↥(A i))
{α : Type u} [pseudo_metric_space α] {x : α} {ε : ℝ} : emetric.ball x (ennreal.of_real ε) = metric.ball x ε
{α : Type u_1} [metric_space α] [topological_space.second_countable_topology α] [measurable_space α] [opens_measurable_space α] [has_besicovitch_covering α] (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] (f : α → set ℝ) (s : set α) (hf : ∀ (x : α), x ∈ s → ∀ (δ : ℝ), δ > 0 → (f x ∩ set.Ioo 0 δ).nonempty) : ∃ (t : set (α × ℝ)), t.countable ∧ (∀ (p : α × ℝ), p ∈ t → p.fst ∈ s) ∧ (∀ (p : α × ℝ), p ∈ t → p.snd ∈ f p.fst) ∧ ⇑μ (s  ⋃ (p : α × ℝ) (hp : p ∈ t), metric.closed_ball p.fst p.snd) = 0 ∧ t.pairwise_disjoint (λ (p : α × ℝ), metric.closed_ball p.fst p.snd)
{E : Type u_1} [normed_group E] [normed_space ℂ E] {f g : ℂ → E} (hfd : diff_cont_on_cl ℂ f {z : ℂ | 0 < z.re}) (hgd : diff_cont_on_cl ℂ g {z : ℂ | 0 < z.re}) (hfexp : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hgexp : ∃ (c : ℝ) (H : c < 2) (B : ℝ), g =O[filter.comap complex.abs filter.at_top ⊓ filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : asymptotics.superpolynomial_decay filter.at_top real.exp (λ (x : ℝ), ∥f ↑x - g ↑x∥)) (hfim : ∃ (C : ℝ), ∀ (x : ℝ), ∥f (↑x * complex.I)∥ ≤ C) (hgim : ∃ (C : ℝ), ∀ (x : ℝ), ∥g (↑x * complex.I)∥ ≤ C) : set.eq_on f g {z : ℂ | 0 ≤ z.re}
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) (h : W ⟶ Z) [category_theory.mono h] (x : X ⟶ W) (y : Y ⟶ W) (hxh : x ≫ h = f) (hyh : y ≫ h = g) (s : category_theory.limits.pullback_cone f g) (hs : category_theory.limits.is_limit s) : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk s.fst s.snd _)
{M : Type u_1} [has_add M] ⦃s t : set M⦄ (h : s ⊆ t) : add_subsemigroup.closure s ≤ add_subsemigroup.closure t
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} {g : α → β} (hp : 1 ≤ p) (hp_ne_top : p ≠ ⊤) (hg : measure_theory.mem_ℒp g p μ) : measure_theory.unif_integrable (λ (n : ι), g) p μ
{α : Type u} {β : Type v} [pseudo_emetric_space α] [nonempty β] [semilattice_sup β] {u : β → α} : cauchy_seq u ↔ ∀ (ε : ennreal), ε > 0 → (∃ (N : β), ∀ (n : β), n ≥ N → has_edist.edist (u n) (u N) < ε)
{ι : Type u_1} [nontrivial ι] {G : Type u_1} [group G] (a : ι → G) {α : Type u_4} [mul_action G α] (X Y : ι → set α) (hXnonempty : ∀ (i : ι), (X i).nonempty) (hXdisj : pairwise (λ (i j : ι), disjoint (X i) (X j))) (hYdisj : pairwise (λ (i j : ι), disjoint (Y i) (Y j))) (hXYdisj : ∀ (i j : ι), disjoint (X i) (Y j)) (hX : ∀ (i : ι), a i • (Y i)ᶜ ⊆ X i) (hY : ∀ (i : ι), a⁻¹ i • (X i)ᶜ ⊆ Y i) : function.injective ⇑(⇑free_group.lift a)
{α : Type u_1} [semi_normed_ring α] (a : α) {n : ℕ} (h : 0 < n) : ∥a ^ n∥ ≤ ∥a∥ ^ n
{α : Type u} {C : free_add_semigroup α → Sort l} (x : free_add_semigroup α) (ih1 : Π (x : α), C (free_add_semigroup.of x)) (ih2 : Π (x : α) (y : free_add_semigroup α), C (free_add_semigroup.of x) → C y → C (free_add_semigroup.of x + y)) : C x
{V₁ : Type u_3} {V₂ : Type u_4} [semi_normed_group V₁] [semi_normed_group V₂] {W₁ : Type u_6} {W₂ : Type u_7} [semi_normed_group W₁] [semi_normed_group W₂] {f₁ g₁ : normed_group_hom V₁ W₁} {f₂ g₂ : normed_group_hom V₂ W₂} (φ : normed_group_hom V₁ V₂) (ψ : normed_group_hom W₁ W₂) (hf : ψ.comp f₁ = f₂.comp φ) (hg : ψ.comp g₁ = g₂.comp φ) : normed_group_hom ↥(f₁.equalizer g₁) ↥(f₂.equalizer g₂)
{α : Type u_1} [measurable_space α] [topological_space α] [opens_measurable_space α] (μ : measure_theory.finite_measure α) : weak_dual nnreal (bounded_continuous_function α nnreal)
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] ⦃f g : α × β → E⦄ (F : E → ennreal) (hf : measure_theory.integrable f (μ.prod ν)) (hg : measure_theory.integrable g (μ.prod ν)) : ∫⁻ (x : α), F (∫ (y : β), f (x, y) - g (x, y) ∂ν) ∂μ = ∫⁻ (x : α), F (∫ (y : β), f (x, y) ∂ν - ∫ (y : β), g (x, y) ∂ν) ∂μ
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (hS : is_closed ↑S) (m : M) (h : ∥⇑(quotient_add_group.mk' S) m∥ = 0) : m ∈ S
{ω ω' : Type u} {m m' n n' : Type u → Type v} [monad_writer_adapter ω ω' m m'] [monad_functor m m' n n'] : monad_writer_adapter ω ω' n n'
{C : Type u₂} [category_theory.category C] {I : Type u₁} (F : I → C) : category_theory.discrete I ⥤ C
{α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] {μ : measure_theory.measure α} [μ.weakly_regular] (f : α → nnreal) (fint : measure_theory.integrable (λ (x : α), ↑(f x)) μ) {ε : ℝ} (εpos : 0 < ε) : ∃ (g : α → nnreal), (∀ (x : α), g x ≤ f x) ∧ upper_semicontinuous g ∧ measure_theory.integrable (λ (x : α), ↑(g x)) μ ∧ ∫ (x : α), ↑(f x) ∂μ - ε ≤ ∫ (x : α), ↑(g x) ∂μ
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {n : with_top ℕ} : cont_mdiff I I' n f ↔ continuous f ∧ ∀ (y : M'), cont_mdiff_on I (model_with_corners_self 𝕜 E') n (⇑(ext_chart_at I' y) ∘ f) (f ⁻¹' (ext_chart_at I' y).source)
{V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} [nonempty ↥s] [complete_space ↥(s.direction)] {ps : set P} (hps : ps ⊆ ↑s) (p : P) : ps.pairwise (λ (p1 p2 : P), has_dist.dist p1 p = has_dist.dist p2 p) ↔ ps.pairwise (λ (p1 p2 : P), has_dist.dist p1 ↑(⇑(euclidean_geometry.orthogonal_projection s) p) = has_dist.dist p2 ↑(⇑(euclidean_geometry.orthogonal_projection s) p))
(red : interactive.parse (optional (lean.parser.tk "!"))) (restr : interactive.parse (optional (lean.parser.tk "only"))) (hyps : interactive.parse (optional interactive.types.pexpr_list)) (cfg : linarith.linarith_config := {discharger := has_bind.seq (tactic.save_info {line := 312, column := 31}) (tactic.interactive.ring option.none).step, restrict_type := option.none Type, restrict_type_reflect := `(option.none Type), exfalso := bool.tt, transparency := tactic.transparency.reducible, split_hypotheses := bool.tt, split_ne := bool.ff, preprocessors := option.none (list linarith.global_branching_preprocessor), oracle := option.none linarith.certificate_oracle}) : tactic unit
{M : Type u_1} {N : Type u_2} {σ : Type u_4} [has_mul M] [has_mul N] [set_like σ N] [mul_mem_class σ N] (f : M →ₙ* N) (S : σ) (h : ∀ (x : M), ⇑f x ∈ S) : M →ₙ* ↥S
{m n : with_top ℕ} {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (h : m ≤ n) : cont_diff_groupoid n I ≤ cont_diff_groupoid m I
(pp_name : name) (type : expr) (context : option local_context := option.none) : tactic.unsafe.type_context expr
(α : Type u) (β : Type v) [group α] [mul_action α β] {φ : quotient (mul_action.orbit_rel α β) → β} (hφ : function.left_inverse quotient.mk' φ) : β ≃ Σ (ω : quotient (mul_action.orbit_rel α β)), α ⧸ mul_action.stabilizer α (φ ω)
{I : Type w₁} (C : I → Type u₁) [Π (i : I), category_theory.category (C i)] {J : Type w₂} {K : Type w₃} (f : K → J) (g : J → I) : category_theory.sigma.map (C ∘ g) f ⋙ category_theory.sigma.map C g ≅ category_theory.sigma.map C (g ∘ f)
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {s t : set α} [measure_theory.is_finite_measure μ] (hms : measurable_set s) (hmt : measurable_set t) (hci : ⇑μ (s ∩ t) ≠ 0) : probability_theory.cond (probability_theory.cond μ s) t = probability_theory.cond μ (s ∩ t)
{ι : Type u_1} (I : box_integral.box ι) (s : finset (ι × ℝ)) : box_integral.prepartition I
{I : Type w₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] (i : I) : C i ⥤ Σ (i : I), C i
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {f : module.End K V} {k : ℕ} {μ : K} (hx : f.has_eigenvalue μ) (hk : 0 < k) : 0 < finite_dimensional.finrank K ↥(⇑(f.generalized_eigenspace μ) k)
{G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G → E'} [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ E'] [inner_product_space ℝ G] [complete_space E'] {φ : cont_diff_bump_of_inner 0} {x₀ : G} (hg : ∀ (x : G), x ∈ metric.ball x₀ φ.R → g x = g x₀) : convolution ⇑φ g (continuous_linear_map.lsmul ℝ ℝ) μ x₀ = measure_theory.integral μ ⇑φ • g x₀
{ι : Type u_1} {α : ι → Type u_3} [fintype ι] [Π (i : ι), measurable_space (α i)] {μ : Π (i : ι), measure_theory.measure (α i)} {C : Π (i : ι), set (set (α i))} (hC : ∀ (i : ι), measurable_space.generate_from (C i) = _inst_3 i) (h2C : ∀ (i : ι), is_pi_system (C i)) (h3C : Π (i : ι), (μ i).finite_spanning_sets_in (C i)) {μν : measure_theory.measure (Π (i : ι), α i)} (h₁ : ∀ (s : Π (i : ι), set (α i)), (∀ (i : ι), s i ∈ C i) → ⇑μν (set.univ.pi s) = finset.univ.prod (λ (i : ι), ⇑(μ i) (s i))) : measure_theory.measure.pi μ = μν
(n : interactive.parse (optional interactive.types.texpr)) (bounds : interactive.parse (optional (lean.parser.tk "using" *> (prod.mkprod.mkfunctor.map <$> lean.parser.identlean.parser.ident <*> lean.parser.ident)))) (lname : interactive.parse (optional (lean.parser.tk "with" *> lean.parser.ident))) : tactic unit
{α : Sort u_1} (f : Π (x : pgame) (y : pgame), x.numeric → y.numeric → α) (H : ∀ {x₁ : pgame} {y₁ : pgame} {x₂ : pgame} {y₂ : pgame} (ox₁ : x₁.numeric) (oy₁ : y₁.numeric) (ox₂ : x₂.numeric) (oy₂ : y₂.numeric), x₁.equiv x₂ → y₁.equiv y₂ → f x₁ y₁ ox₁ oy₁ = f x₂ y₂ ox₂ oy₂) : surreal → surreal → α
(σ : Type u_1) (R : Type u_2) [semiring R] : mv_power_series σ R →+* R
{α : Type u} [lattice α] [add_comm_group α] [covariant_class α α has_add.add has_le.le] (a : α) : ||a|| = |a|
(proj_folder proj_name : string) (slow : bool := bool.tt) (verbose : lint_verbosity := lint_verbosity.medium) (extra : list name := list.nil) (use_only : bool := bool.ff) : tactic (name_set × format)
(s : option simp_lemmas := option.none) (u : list name := list.nil) (cfg : tactic.dsimp_config := {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}) : conv unit
{α : Type u_1} (F : Type u_6) (p : ennreal) [normed_group F] {m m0 : measurable_space α} (μ : measure_theory.measure α) (hm : m ≤ m0) (f : ↥(measure_theory.Lp F p (μ.trim hm))) : ↥(measure_theory.Lp_meas_subgroup F m p μ)
(R : Type u) [comm_ring R] [is_noetherian_ring R] (I : ideal R) : ∃ (Z : multiset (prime_spectrum R)), (multiset.map coe Z).prod ≤ I
{α : Type u_1} [measurable_space α] {s : measure_theory.signed_measure α} {i : set α} (hi : ⇑s i < 0) : ∃ (j : set α), measurable_set j ∧ j ⊆ i ∧ measure_theory.vector_measure.restrict s j ≤ 0.restrict j ∧ ⇑s j < 0
{ι : Type u_1} {E : Type u_3} [normed_group E] {f : ℝ → E} {μ : measure_theory.measure ℝ} {l l' : filter ℝ} (hfm : strongly_measurable_at_filter f l' μ) [filter.tendsto_Ixx_class set.Ioc l l'] [l'.is_measurably_generated] (hμ : μ.finite_at_filter l') {c : E} (hf : filter.tendsto f l' (nhds c)) {u v : ι → ℝ} {lt : filter ι} (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : ∀ᶠ (t : ι) in lt, interval_integrable f μ (u t) (v t)
{α : Type u_1} {m : measurable_space α} (f : measure_theory.simple_func α ennreal) (μ : measure_theory.measure α) : ennreal
{V : Type u} {W : Type v} (G : simple_graph V) (G' : simple_graph W) : Type (max u v)
{I : Type v₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {J : Type v₁} [category_theory.small_category J] {F : J ⥤ Π (i : I), C i} (c : Π (i : I), category_theory.limits.cone (F ⋙ category_theory.pi.eval C i)) : category_theory.limits.cone F
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] {σ : R →+* S} {σ' : S →+* R} [ring_hom_inv_pair σ σ'] [ring_hom_inv_pair σ' σ] {M : Type u_3} {M₂ : Type u_4} [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module S M₂] (e : M ≃ₛₗ[σ] M₂) : M₂ → M
{α : Type u} {ι : Type u_1} {I : set ι} (hI : I.finite) {l : filter α} {p : ι → α → Prop} : (∀ᶠ (x : α) in l, ∀ (i : ι), i ∈ I → p i x) ↔ ∀ (i : ι), i ∈ I → (∀ᶠ (x : α) in l, p i x)
{α : Type u_1} [topological_space α] [measurable_space α] {μ : measure_theory.measure α} {s : set α} (h : is_compact s) (hμ : ∀ (x : α), x ∈ s → μ.finite_at_filter (nhds x)) : ∃ (U : set α) (H : U ⊇ s), is_open U ∧ ⇑μ U < ⊤
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {γ' : Type u_6} {δ : Type u_7} {ε : Type u_9} {f : filter α} {g : filter β} {h : filter γ} {m : α → δ → ε} {n : β → γ → δ} {m₁ : α → β → β'} {m₂ : α → γ → γ'} {n' : β' → γ' → ε} (h_distrib : ∀ (a : α) (b : β) (c : γ), m a (n b c) = n' (m₁ a b) (m₂ a c)) : filter.map₂ m f (filter.map₂ n g h) ≤ filter.map₂ n' (filter.map₂ m₁ f g) (filter.map₂ m₂ f h)
{R : Type u} [comm_ring R] (I : ideal R) (f : polynomial R) : adjoin_root f ⧸ ideal.map (ideal.quotient.mk (ideal.span {f})) (ideal.map polynomial.C I) ≃+* (polynomial R ⧸ ideal.map polynomial.C I) ⧸ ideal.map (ideal.quotient.mk (ideal.map polynomial.C I)) (ideal.span {f})
{n : ℕ} {α : fin (n + 1) → Type u} {P : (Π (i : fin n.succ), α i) → Sort v} (h : Π (x₀ : α 0) (x : Π (i : fin n), α i.succ), P (fin.cons x₀ x)) (x : Π (i : fin n.succ), α i) : P x
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (μ : R) : ℕ →o submodule R M
{E : Type u_3} [has_norm E] [add_comm_group E] [pseudo_metric_space E] (H1 : ∀ (x : E), ∥x∥ = has_dist.dist x 0) (H2 : ∀ (x y z : E), has_dist.dist x y ≤ has_dist.dist (x + z) (y + z)) : semi_normed_group E
{R₁ : Type u_3} [comm_ring R₁] {K : Type u_4} [field K] [algebra R₁ K] [frac : is_fraction_ring R₁ K] [is_domain R₁] [is_noetherian_ring R₁] (I : fractional_ideal (non_zero_divisors R₁) K) : is_noetherian R₁ ↥I
(Γ : Type u_1) [inhabited Γ] (Λ : Type u_2) [inhabited Λ] : Type (max u_1 u_2)
{ι : Type u} (s : finset ι) (f : ι → ℝ) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), |f i|) ^ p ≤ ↑(s.card) ^ (p - 1) * s.sum (λ (i : ι), |f i| ^ p)
{𝕜 : Type u_1} {E : Type u_4} [semi_normed_group E] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] {𝕜' : Type u_10} [normed_field 𝕜'] [normed_algebra 𝕜 𝕜'] [normed_space 𝕜' E] [is_scalar_tower 𝕜 𝕜' E] : ∥continuous_linear_map.lsmul 𝕜 𝕜'∥ ≤ 1
{α : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space α} (X : α → E) (ℙ : measure_theory.measure α) (μ : measure_theory.measure E . "volume_tac") : Prop
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_4} [topological_space H] {I : model_with_corners 𝕜 E H} {N : Type u_6} [topological_space N] [charted_space H N] {A : Type u_10} [normed_ring A] [normed_algebra 𝕜 A] [smooth_ring (model_with_corners_self 𝕜 A) A] : cont_mdiff_map I (model_with_corners_self 𝕜 A) N A ⊤ →ₐ[𝕜] N → A
{α : Type u} [linear_ordered_add_comm_group α] (a b : α) : |a + b| ≤ |a| + |b|
{I : Type v₁} (C : I → Type u₁) [Π (i : I), category_theory.category (C i)] : category_theory.category (Π (i : I), C i)
{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] (not_terminated_at_n : ¬(generalized_continued_fraction.of v).terminated_at n) : |v - (generalized_continued_fraction.of v).convergents n| ≤ 1 / ((generalized_continued_fraction.of v).denominators n * (generalized_continued_fraction.of v).denominators (n + 1))
{K : Type u} {L : Type v} [field L] {ζ : L} [field K] [algebra K L] (hζ : is_primitive_root ζ 2) : ⇑(algebra.norm K) ζ = (-1) ^ finite_dimensional.finrank K L
{σ α : Type u_1} (cmd : state σ α) (s : σ) : stream α
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] (f : α × β → ennreal) (hf : measurable f) : ∫⁻ (z : α × β), f z ∂μ.prod ν = ∫⁻ (x : α), ∫⁻ (y : β), f (x, y) ∂ν ∂μ
{ι : Type u_1} [fintype ι] (I : box_integral.box ι) : nnreal
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (P Q : cochain_complex V ℕ) (zero : P.X 0 ⟶ Q.X 0) (one : P.X 1 ⟶ Q.X 1) (one_zero_comm : zero ≫ Q.d 0 1 = P.d 0 1 ≫ one) (succ : Π (n : ℕ) (p : Σ' (f : P.X n ⟶ Q.X n) (f' : P.X (n + 1) ⟶ Q.X (n + 1)), f ≫ Q.d n (n + 1) = P.d n (n + 1) ≫ f'), Σ' (f'' : P.X (n + 2) ⟶ Q.X (n + 2)), p.snd.fst ≫ Q.d (n + 1) (n + 2) = P.d (n + 1) (n + 2) ≫ f'') : P ⟶ Q
{R : Type u_1} {M : Type u_5} [comm_semiring R] [add_comm_monoid M] [module R M] {I : R →+* R} (B : M →ₛₗ[I] M →ₗ[R] R) : Prop
{E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {f : E → G} {C : ℝ} {s : set E} {x y : E} (hf : differentiable_on 𝕜 f s) (bound : ∀ (x : E), x ∈ s → ∥fderiv_within 𝕜 f s x∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
(e : expr) (n : ℕ) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr × expr)
{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} (hf : isometry f) (s : set α) : emetric.diam (f '' s) = emetric.diam s
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {f' : α → E'} {g' : α → F'} {l : filter α} : f' =O[l] g' → ((λ (x : α), ∥f' x∥) =O[l] λ (x : α), ∥g' x∥)
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X ℝ) (e : C(X, Y)) (he : closed_embedding ⇑e) : ∃ (g : bounded_continuous_function Y ℝ), ∥g∥ ≤ ∥f∥ / 3 ∧ has_dist.dist (g.comp_continuous e) f ≤ 2 / 3 * ∥f∥
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] {f : α → β} [measurable_space β] [topological_space.pseudo_metrizable_space β] [borel_space β] [topological_space.second_countable_topology β] : measure_theory.ae_strongly_measurable f μ ↔ ae_measurable f μ
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} (i : ι) : (Π (i j : ι), C.X i ⟶ D.X j) →+ (C.X i ⟶ D.X i)
(a b : ℝ) {p q : ℝ} (hpq : p.is_conjugate_exponent q) : a * b ≤ |a| ^ p / p + |b| ^ q / q
{β : Type v} {π : β → Type u_1} [fintype β] [Π (b : β), pseudo_metric_space (π b)] [nonempty β] (x : Π (b : β), π b) (r : ℝ) : metric.ball x r = set.univ.pi (λ (b : β), metric.ball (x b) r)
{α : Type u_1} [measurable_space α] (j : measure_theory.jordan_decomposition α) : ∃ (S : set α), measurable_set S ∧ measure_theory.vector_measure.restrict j.to_signed_measure S ≤ 0.restrict S ∧ 0.restrict Sᶜ ≤ measure_theory.vector_measure.restrict j.to_signed_measure Sᶜ ∧ ⇑(j.pos_part) S = 0 ∧ ⇑(j.neg_part) Sᶜ = 0
{ι : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [comm_ring A] [algebra R A] [linear_ordered_cancel_add_comm_monoid ι] {𝒜 : ι → submodule R A} [graded_algebra 𝒜] (I : homogeneous_ideal 𝒜) : homogeneous_ideal 𝒜
{k : Type u} [comm_ring k] (G : Type u) [group G] {V : Type u} [add_comm_group V] [module k V] [module (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] {W : Type u} [add_comm_group W] [module k W] [module (monoid_algebra k G) W] [is_scalar_tower k (monoid_algebra k G) W] (π : W →ₗ[k] V) [fintype G] [inv : invertible ↑(fintype.card G)] : W →ₗ[monoid_algebra k G] V
{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s t : set α} (Hf : monotone_on f t) (Hst : s ⊆ t) : (upper_bounds s ∩ t).nonempty → bdd_above (f '' s)
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) {R₂ : Type u_3} {M₂ : Type u_4} [ring R₂] [add_comm_group M₂] [module R₂ M₂] {τ₁₂ : R →+* R₂} ⦃f g : M ⧸ p →ₛₗ[τ₁₂] M₂⦄ (h : f.comp p.mkq = g.comp p.mkq) : f = g
{α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} : μ.absolutely_continuous ν → μ.ae ≤ ν.ae
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (M : Type u_4) [topological_space M] [charted_space H M] : Prop
{σ : Type u_1} {R : Type u_2} [comm_ring R] [local_ring R] : local_ring (mv_power_series σ R)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (n : with_top ℕ) (f : M → M') : Prop
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {F : Type u_5} [normed_group F] [normed_space 𝕜 F] (Z : basic_smooth_vector_bundle_core I M F) {e : local_homeomorph M H} (he : e ∈ charted_space.atlas H M) : local_homeomorph Z.to_topological_vector_bundle_core.total_space (model_prod H F)
{M : Type u_1} [comm_monoid M] {S : submonoid M} {p : localization S → Sort u} (f : Π (a : M) (b : ↥S), p (localization.mk a b)) (H : ∀ {a c : M} {b d : ↥S} (h : ⇑(localization.r S) (a, b) (c, d)), eq.rec (f a b) _ = f c d) (x : localization S) : p x
{ε : Type u_1} {p : ε → Prop} [decidable_pred p] (ep : equiv.perm {a // p a}) (en : equiv.perm {a // ¬p a}) : equiv.perm ε
{𝕜 : Type u_1} {G : Type u_2} {x : G} [nondiscrete_normed_field 𝕜] [measurable_space G] {μ : measure_theory.measure G} [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [μ.is_add_left_invariant] [μ.is_neg_invariant] [normed_space ℝ 𝕜] [complete_space 𝕜] {f g : G → 𝕜} : convolution f g (continuous_linear_map.lmul 𝕜 𝕜) μ x = ∫ (t : G), f (x - t) * g t ∂μ
{E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {f : E → G} {C : ℝ} {s : set E} {x y : E} {φ : E →L[𝕜] G} (hf : differentiable_on 𝕜 f s) (bound : ∀ (x : E), x ∈ s → ∥fderiv_within 𝕜 f s x - φ∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x - ⇑φ (y - x)∥ ≤ C * ∥y - x∥
{C : Type u} [category_theory.category C] {W X Y Z : C} [category_theory.limits.has_binary_coproduct W X] [category_theory.limits.has_binary_coproduct Y Z] (f : W ⟶ Y) (g : X ⟶ Z) : W ⨿ X ⟶ Y ⨿ Z
{α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : α → E} {g : α → F} {l : filter α} : f =O[l] g ↔ ∃ (c : ℝ), ∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] : category_theory.limits.cofork I.fst_sigma_map I.snd_sigma_map ⥤ category_theory.limits.multicofork I
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) : ⇑ρ {x : α | v.lim_ratio_meas hρ x = 0} = 0
{X : Type u} [metric_space X] [compact_space X] [nonempty X] {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y] {s : set X} (Φ : ↥s → Y) {ε₁ ε₂ ε₃ : ℝ} (hs : ∀ (x : X), ∃ (y : X) (H : y ∈ s), has_dist.dist x y ≤ ε₁) (hs' : ∀ (x : Y), ∃ (y : ↥s), has_dist.dist x (Φ y) ≤ ε₃) (H : ∀ (x y : ↥s), |has_dist.dist x y - has_dist.dist (Φ x) (Φ y)| ≤ ε₂) : Gromov_Hausdorff.GH_dist X Y ≤ ε₁ + ε₂ / 2 + ε₃
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] : Type (max u_1 u_2)
{α : Type u} {β : Type v} [semilattice_sup α] [nonempty α] {I : set β} {S : β → set α} (H : I.finite) : bdd_above (⋃ (i : β) (H : i ∈ I), S i) ↔ ∀ (i : β), i ∈ I → bdd_above (S i)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E ≃L[𝕜] F} {s : set E} {c : nnreal} (hf : approximates_linear_on f ↑f' s c) (hc : subsingleton E ∨ c < ∥↑(f'.symm)∥₊⁻¹) : continuous_on ⇑((hf.to_local_equiv hc).symm) (f '' s)
{α : Type u} {β : Type v} (R : Type u_1) [semiring R] (e : α ≃ β) [add_comm_monoid β] [module R β] : let _inst : add_comm_monoid α := e.add_comm_monoid, _inst_4 : module R α := equiv.module R e in α ≃ₗ[R] β
{V : Type u} [category_theory.category V] [category_theory.abelian V] {A B C D A' B' C' D' : V} {f : A ⟶ B} {g : B ⟶ C} {h : C ⟶ D} {f' : A' ⟶ B'} {g' : B' ⟶ C'} {h' : C' ⟶ D'} {α : A ⟶ A'} {β : B ⟶ B'} {γ : C ⟶ C'} {δ : D ⟶ D'} (comm₁ : α ≫ f' = f ≫ β) (comm₂ : β ≫ g' = g ≫ γ) (comm₃ : γ ≫ h' = h ≫ δ) {E E' : V} {i : D ⟶ E} {i' : D' ⟶ E'} {ε : E ⟶ E'} (comm₄ : δ ≫ i' = i ≫ ε) (hfg : category_theory.exact f g) (hgh : category_theory.exact g h) (hhi : category_theory.exact h i) (hf'g' : category_theory.exact f' g') (hg'h' : category_theory.exact g' h') (hh'i' : category_theory.exact h' i') [category_theory.is_iso α] [category_theory.is_iso β] [category_theory.is_iso δ] [category_theory.is_iso ε] : category_theory.is_iso γ
{α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} [measure_theory.is_finite_measure μ] (hp : 1 ≤ p) (hp' : p ≠ ⊤) {f : ℕ → α → β} {g : α → β} (hf : ∀ (n : ℕ), measure_theory.ae_strongly_measurable (f n) μ) (hg : measure_theory.mem_ℒp g p μ) (hui : measure_theory.unif_integrable f p μ) (hfg : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (nhds (g x))) : filter.tendsto (λ (n : ℕ), measure_theory.snorm (f n - g) p μ) filter.at_top (nhds 0)
{C : ℕ → Sort u} {n m : ℕ} : n ≤ m → (Π {k : ℕ}, C k → C (k + 1)) → C n → C m
{α : Type u} {β : Type v} [topological_space α] [semi_normed_group β] (f : α → β) (Hf : continuous f) (C : ℝ) (H : ∀ (x : α), ∥f x∥ ≤ C) : bounded_continuous_function α β
{Z : Type u_1} {N : Type u_2} {R : Type u_3} [pseudo_metric_space R] {d : N → ℝ} {j : Z → N → R} {f : R → R} {α : R} {ε M : ℝ} (d0 : ∀ (a : N), 1 ≤ d a) (e0 : 0 < ε) (B : ∀ ⦃y : R⦄, y ∈ metric.closed_ball α ε → has_dist.dist (f α) (f y) ≤ has_dist.dist α y * M) (L : ∀ ⦃z : Z⦄ ⦃a : N⦄, j z a ∈ metric.closed_ball α ε → 1 ≤ d a * has_dist.dist (f α) (f (j z a))) : ∃ (A : ℝ), 0 < A ∧ ∀ (z : Z) (a : N), 1 ≤ d a * (has_dist.dist α (j z a) * A)
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) (f : α → ennreal) : measure_theory.measure α
{α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.outer_regular] (A : set α) (r : ennreal) (hr : ⇑μ A < r) : ∃ (U : set α) (H : U ⊇ A), is_open U ∧ ⇑μ U < r
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {I : lie_ideal R L} (h₁ : I ≤ lie_algebra.center R L) (h₂ : lie_algebra.is_nilpotent R (L ⧸ I)) : lie_algebra.is_nilpotent R L
{R : Type u} [comm_ring R] (I J : ideal R) : R ⧸ I →+* R ⧸ I ⊔ J
{α : Type u_1} {F : Type u_3} [normed_group F] {m : measurable_space α} (f : α → F) (p : ennreal) (μ : measure_theory.measure α) : ennreal
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} (s : category_theory.limits.cofork f g) {W : C} {k l : s.X ⟶ W} (h : s.π ≫ k = s.π ≫ l) (j : category_theory.limits.walking_parallel_pair) : s.ι.app j ≫ k = s.ι.app j ≫ l
{V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (θ : real.angle) : hb.oangle x y = θ ↔ x ≠ 0 ∧ y ≠ 0 ∧ y = (∥y∥ / ∥x∥) • ⇑(hb.rotation θ) x ∨ θ = 0 ∧ (x = 0 ∨ y = 0)
{𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {E'' : Type u_5} {F : Type u_6} {F' : Type u_7} {F'' : Type u_8} [normed_group E] [normed_group E'] [normed_group E''] [normed_group F] {f : G → E} {g : G → E'} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 E''] [normed_space ℝ F] [normed_space 𝕜 F] [complete_space F] [measurable_space G] {μ : measure_theory.measure G} (L : E →L[𝕜] E' →L[𝕜] F) [normed_group F'] [normed_space ℝ F'] [normed_space 𝕜 F'] [complete_space F'] [normed_group F''] [normed_space ℝ F''] [normed_space 𝕜 F''] [complete_space F''] {k : G → E''} (L₂ : F →L[𝕜] E'' →L[𝕜] F') (L₃ : E →L[𝕜] F'' →L[𝕜] F') (L₄ : E' →L[𝕜] E'' →L[𝕜] F'') [add_group G] [has_measurable_add G] [measure_theory.sigma_finite μ] {ν : measure_theory.measure G} [measure_theory.sigma_finite ν] [ν.is_add_right_invariant] (hL : ∀ (x : E) (y : E') (z : E''), ⇑(⇑L₂ (⇑(⇑L x) y)) z = ⇑(⇑L₃ x) (⇑(⇑L₄ y) z)) {x₀ : G} (h₄ : convolution_exists g k L₄ ν) (h₁ : convolution_exists f g L μ) (hi : measure_theory.integrable (function.uncurry (λ (x y : G), ⇑(⇑L₃ (f y)) (⇑(⇑L₄ (g (x - y))) (k (x₀ - x))))) (ν.prod μ)) : convolution (convolution f g L μ) k L₂ ν x₀ = convolution f (convolution g k L₄ ν) L₃ μ x₀
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.prepartition I) [fintype ι] : nnreal
{E : Type u_3} [has_norm E] [add_comm_group E] [metric_space E] (H1 : ∀ (x : E), ∥x∥ = has_dist.dist x 0) (H2 : ∀ (x y z : E), has_dist.dist x y ≤ has_dist.dist (x + z) (y + z)) : normed_group E
{α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {t : set α} {x : α} {Φ : α → β} (hΦ : isometry Φ) : metric.inf_dist (Φ x) (Φ '' t) = metric.inf_dist x t
{α : Type u} [topological_space α] {β : Type u_1} [topological_space β] [totally_disconnected_space β] {f : α → β} (h : continuous f) (a : α) : f '' connected_component a = {f a}
{C : Type u} [category_theory.category C] {X : C} {J : category_theory.grothendieck_topology C} {S : J.cover X} (I : S.relation) : S.arrow
{𝕜 : Type u_1} [normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : subspace 𝕜 E} (hFc : is_closed ↑F) (hF : ∃ (x : E), x ∉ F) {r : ℝ} (hr : r < 1) : ∃ (x₀ : E), x₀ ∉ F ∧ ∀ (y : E), y ∈ F → r * ∥x₀∥ ≤ ∥x₀ - y∥
{α : Type u_1} {β : Type u_2} (f : α → β) (s : set α) (H : function.injective f) : ↥s ≃ ↥(f '' s)
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [I : is_artinian R M] (f : ℕ → submodule R M) (h : ∀ (n : ℕ), disjoint (⇑(partial_sups (⇑order_dual.to_dual ∘ f)) n) (⇑order_dual.to_dual (f (n + 1)))) : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → f m = ⊤
{ι : Type v} [preorder ι] (G : ι → Type w) [Π (i : ι), comm_ring (G i)] (f : Π (i j : ι), i ≤ j → G i → G j) (P : Type u₁) [comm_ring P] (g : Π (i : ι), G i →+* P) (Hg : ∀ (i j : ι) (hij : i ≤ j) (x : G i), ⇑(g j) (f i j hij x) = ⇑(g i) x) : ring.direct_limit G f →+* P
{M : Type u_1} {α : Type u_4} [monoid M] {c : con M} (u : c.quotientˣ) (f : Π (x y : M), ⇑c (x * y) 1 → ⇑c (y * x) 1 → α) (Hf : ∀ (x y : M) (hxy : ⇑c (x * y) 1) (hyx : ⇑c (y * x) 1) (x' y' : M) (hxy' : ⇑c (x' * y') 1) (hyx' : ⇑c (y' * x') 1), ⇑c x x' → ⇑c y y' → f x y hxy hyx = f x' y' hxy' hyx') : α
{R : Type u} [comm_ring R] {I : ideal R} : I.radical = I.jacobson ↔ ⊥.radical = ⊥.jacobson
{K : Type u_4} [normed_field K] {ξ : K} : summable (λ (n : ℕ), ξ ^ n) ↔ ∥ξ∥ < 1
{α : Type u_1} {m0 : measurable_space α} [encodable α] [measurable_singleton_class α] (μ : measure_theory.measure α) : measure_theory.measure.sum (λ (a : α), ⇑μ {a} • measure_theory.measure.dirac a) = μ
{I : Type w₀} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {D : I → Type u₁} [Π (i : I), category_theory.category (D i)] {F G : Π (i : I), C i ⥤ D i} (α : Π (i : I), F i ⟶ G i) : category_theory.functor.pi F ⟶ category_theory.functor.pi G
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} [linear_order α] {a b : α} {P : α → Prop} : (∀ᵐ (x : α) ∂μ, x ∈ set.interval_oc a b → P x) ↔ (∀ᵐ (x : α) ∂μ, x ∈ set.Ioc a b → P x) ∧ ∀ᵐ (x : α) ∂μ, x ∈ set.Ioc b a → P x
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} {G' : Type wG'} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] [normed_group G'] [normed_space 𝕜 G'] (f : G →ₗ[𝕜] multilinear_map 𝕜 E G') (C : ℝ) (H : ∀ (x : G) (m : Π (i : ι), E i), ∥⇑(⇑f x) m∥ ≤ C * ∥x∥ * finset.univ.prod (λ (i : ι), ∥m i∥)) : G →L[𝕜] continuous_multilinear_map 𝕜 E G'
{α : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [add_zero_class N] ⦃f g : (α →₀ M) →+ N⦄ (H : ∀ (x : α) (y : M), ⇑f (finsupp.single x y) = ⇑g (finsupp.single x y)) : f = g
{R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] {σ₁₂ : R →+* R₂} {s : set M} {f g : M →ₛₗ[σ₁₂] M₂} (H : set.eq_on ⇑f ⇑g s) ⦃x : M⦄ (h : x ∈ submodule.span R s) : ⇑f x = ⇑g x
{E : Type u_3} {F : Type u_4} [semi_normed_group E] [semi_normed_group F] (f : E →+ F) (C : ℝ) (h : ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥) : lipschitz_with C.to_nnreal ⇑f
{α : Type u_1} {m : measurable_space α} (μ ν : measure_theory.measure α) [measure_theory.sigma_finite μ] : ∀ᵐ (x : α) ∂ν, μ.rn_deriv ν x < ⊤
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G ≃g G') : G ↪g G'
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R →+* S) (g : S →+* R) (I : ideal R) (h : function.left_inverse ⇑g ⇑f) : ideal.map f I ≤ ideal.comap g I
{α : Type u_1} {m : measurable_space α} (c : measure_theory.complex_measure α) (μ : measure_theory.measure α) : α → ℂ
{C : Type u} [category_theory.category C] [category_theory.concrete_category C] (I : category_theory.limits.multicospan_index C) : ↥((I.multicospan ⋙ category_theory.forget C).sections) ≃ {x // ∀ (i : I.R), ⇑(I.fst i) (x (I.fst_to i)) = ⇑(I.snd i) (x (I.snd_to i))}
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : ∥⇑(quotient_add_group.mk' S) m∥ = 0 ↔ m ∈ closure ↑S
{C : Type u} [category_theory.category C] {X : C} (P : Cᵒᵖ ⥤ Type v) (U : category_theory.sieve X) (B : Π ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, ⇑U f → category_theory.sieve Y) (hU : category_theory.presieve.is_sheaf_for P ⇑U) (hB : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄ (hf : ⇑U f), category_theory.presieve.is_sheaf_for P ⇑(B hf)) (hB' : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄ (h : ⇑U f) ⦃Z : C⦄ (g : Z ⟶ Y), category_theory.presieve.is_separated_for P ⇑(category_theory.sieve.pullback g (B h))) : category_theory.presieve.is_sheaf_for P ⇑(category_theory.sieve.bind ⇑U B)
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {t : set α} {f : α → E} {g : E → ℝ} (hg : concave_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (h0 : ⇑μ t ≠ 0) (ht : ⇑μ t ≠ ⊤) (hfs : ∀ᵐ (x : α) ∂μ.restrict t, f x ∈ s) (hfi : measure_theory.integrable_on f t μ) (hgi : measure_theory.integrable_on (g ∘ f) t μ) : (⨍ (x : α) in t, f x ∂μ, ⨍ (x : α) in t, g (f x) ∂μ) ∈ {p : E × ℝ | p.fst ∈ s ∧ p.snd ≤ g p.fst}
(I : Type u_1) (R : Type u_2) [non_unital_ring R] [topological_space R] [topological_ring R] : topological_ring (I → R)
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : f =O[l] g' → (f =O[l] λ (x : α), ∥g' x∥)
{G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure G} [group G] [has_measurable_mul G] [μ.is_mul_left_invariant] (f : G → E) (g : G) : ∫ (x : G), f (g * x) ∂μ = ∫ (x : G), f x ∂μ
{N : Type u_1} {G : Type u_2} [group N] [group G] {φ : G →* mul_aut N} : N ⋊[φ] G →* G
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [complete_space F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] [complete_space G] (φ : implicit_function_data 𝕜 E F G) : F → G → E
{A : Type u₁} [category_theory.category A] {B : Type u₁} [category_theory.category B] {C : Type u₁} [category_theory.category C] {D : Type u₁} [category_theory.category D] {F G : A ⥤ B} {H I : C ⥤ D} (α : F ⟶ G) (β : H ⟶ I) : F.sum H ⟶ G.sum I
{L : first_order.language} {α : Type u'} (φ : L.formula α) : L.formula α
{Y : Type u_2} [topological_space Y] [normal_space Y] {s : set Y} (f : bounded_continuous_function ↥s ℝ) (hs : is_closed s) : ∃ (g : bounded_continuous_function Y ℝ), ∥g∥ = ∥f∥ ∧ g.restrict s = f
{G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {μ : measure_theory.measure G} {Γ : add_subgroup G} [μ.is_add_right_invariant] : measure_theory.vadd_invariant_measure ↥(Γ.opposite) G μ
{ι : Type u} {α : ι → Type u_2} {δ : Π (i : ι), α i → Type v} [Π (i : ι) (j : α i), has_zero (δ i j)] (f : Π₀ (i : Σ (i : ι), α i), δ i.fst i.snd) : Π₀ (i : ι) (j : α i), δ i j
{α : Type u_1} [measurable_space α] {s : measure_theory.signed_measure α} {u v w : set α} (hu : measurable_set u) (hv : measurable_set v) (hw : measurable_set w) (hsu : measure_theory.vector_measure.restrict s u ≤ 0.restrict u) (hw₁ : ⇑s w = 0) (hw₂ : w ⊆ u) (hwt : v ⊆ w) : ⇑s v = 0
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {s t : set α} (H : s =ᵐ[μ] t) : ⇑μ s = ⇑μ t
{α : Type u_1} {f g : α → ennreal} {Mf Mg mα : measurable_space α} {μ : measure_theory.measure α} (hMf : Mf ≤ mα) (hMg : Mg ≤ mα) (h_ind : probability_theory.indep Mf Mg μ) (h_meas_f : measurable f) (h_meas_g : measurable g) : ∫⁻ (a : α), f a * g a ∂μ = ∫⁻ (a : α), f a ∂μ * ∫⁻ (a : α), g a ∂μ
{ι : Type u_1} {α : ι → Type u_3} [fintype ι] [Π (i : ι), measurable_space (α i)] {μ : Π (i : ι), measure_theory.measure (α i)} [∀ (i : ι), measure_theory.sigma_finite (μ i)] (i : ι) [measure_theory.has_no_atoms (μ i)] : measure_theory.has_no_atoms (measure_theory.measure.pi μ)
{α : Type u_1} {ι : Type u_2} {E : Type u_3} [has_dist E] {m : measurable_space α} (μ : measure_theory.measure α) (f : ι → α → E) (l : filter ι) (g : α → E) : Prop
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] [complete_space E] {T : E →L[𝕜] E} (hT : inner_product_space.is_self_adjoint ↑T) {x₀ : E} (hx₀ : x₀ ≠ 0) (hextr : is_min_on T.re_apply_inner_self (metric.sphere 0 ∥x₀∥) x₀) : module.End.has_eigenvector ↑T (↑⨅ (x : {x // x ≠ 0}), (λ (x : E), T.re_apply_inner_self x / ∥x∥ ^ 2) ↑x) x₀
{α : Type u_1} [measurable_space α] [topological_space α] [opens_measurable_space α] {ι : Type u_2} {L : filter ι} [L.is_countably_generated] (μ : measure_theory.finite_measure α) {fs : ι → bounded_continuous_function α nnreal} {c : nnreal} (fs_le_const : ∀ᶠ (i : ι) in L, ∀ᵐ (a : α) ∂↑μ, ⇑(fs i) a ≤ c) {f : α → nnreal} (fs_lim : ∀ᵐ (a : α) ∂↑μ, filter.tendsto (λ (i : ι), ⇑(fs i) a) L (nhds (f a))) : filter.tendsto (λ (i : ι), ∫⁻ (a : α), ↑(⇑(fs i) a) ∂↑μ) L (nhds (∫⁻ (a : α), ↑(f a) ∂↑μ))
{K : Type u_1} [comm_ring K] [is_domain K] [char_zero K] {ζ : K} {n : ℕ+} (h : is_primitive_root ζ ↑n) : ∃! (P : polynomial ℤ), polynomial.map (int.cast_ring_hom K) P = polynomial.cyclotomic' ↑n K
{α : Type u_1} [topological_space α] (dist : α → α → ℝ) (dist_self : ∀ (x : α), dist x x = 0) (dist_comm : ∀ (x y : α), dist x y = dist y x) (dist_triangle : ∀ (x y z : α), dist x z ≤ dist x y + dist y z) (H : ∀ (s : set α), is_open s ↔ ∀ (x : α), x ∈ s → (∃ (ε : ℝ) (H : ε > 0), ∀ (y : α), dist x y < ε → y ∈ s)) (eq_of_dist_eq_zero : ∀ (x y : α), dist x y = 0 → x = y) : metric_space α
{R : Type u} [comm_semiring R] (I J : ideal R) : I • J = I * J
{ι : Type u_1} [decidable_eq ι] (A : ι → Type u_2) [Π (i : ι), add_comm_monoid (A i)] [add_monoid ι] [direct_sum.gsemiring A] [Π (i : ι) (x : A i), decidable (x ≠ 0)] (a a' : direct_sum ι (λ (i : ι), A i)) : a * a' = ((dfinsupp.support a).product (dfinsupp.support a')).sum (λ (ij : ι × ι), ⇑(direct_sum.of A (ij.fst + ij.snd)) (graded_monoid.ghas_mul.mul (⇑a ij.fst) (⇑a' ij.snd)))
{α : Type u_1} [metric_space α] [topological_space.second_countable_topology α] [measurable_space α] [opens_measurable_space α] [has_besicovitch_covering α] (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] : vitali_family μ
{α : Type u_1} {M : Type u_2} {N : Type u_3} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid N] [module R N] ⦃φ ψ : (α →₀ M) →ₗ[R] N⦄ (h : ∀ (a : α), φ.comp (finsupp.lsingle a) = ψ.comp (finsupp.lsingle a)) : φ = ψ
{α : Type u_1} {m0 : measurable_space α} (μ : measure_theory.measure α) : Prop
{V : Type u_1} [inner_product_space ℝ V] {x y : V} (h : inner_product_geometry.angle x y = 0) : ∥x - y∥ = |∥x∥ - ∥y∥|
(p : Prop) (cfg : slim_check.slim_check_cfg := {num_inst := 100, max_size := 100, trace_discarded := bool.ff, trace_success := bool.ff, trace_shrink := bool.ff, trace_shrink_candidates := bool.ff, random_seed := option.none ℕ, quiet := bool.ff}) (p' : slim_check.tactic.decorations_of p . "mk_decorations") [slim_check.testable p'] : io punit
{α : Type u_1} {β : Type u_2} (f : α → β) (s : set ↥(set.range f)) : ↥(set.range_splitting f '' s) ≃ ↥s
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {W X Y : C} [category_theory.limits.has_binary_biproduct X Y] (f : X ⟶ W) (g : Y ⟶ W) : X ⊞ Y ⟶ W
{n : ℕ+} {K : Type u} {L : Type v} (C : Type w) [field K] [field L] [comm_ring C] [algebra K L] [algebra K C] [is_cyclotomic_extension {n} K L] {ζ : L} (hζ : is_primitive_root ζ ↑n) [is_domain C] [ne_zero ↑↑n] (hirr : irreducible (polynomial.cyclotomic ↑n K)) : (L →ₐ[K] C) ≃ ↥(primitive_roots ↑n C)
{G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {μ : measure_theory.measure G} [add_group G] [topological_add_group G] [μ.is_add_left_invariant] {U : set G} (hU : (interior U).nonempty) (h : ⇑μ U ≠ ⊤) {K : set G} (hK : is_compact K) : ⇑μ K < ⊤
{R : Type u} [semiring R] {f : polynomial R} {I : submodule (polynomial R) (polynomial R)} (cf : ∀ (i : ℕ), f.coeff i ∈ ⇑polynomial.C ⁻¹' I.carrier) : submodule.span (polynomial R) {g : polynomial R | ∃ (i : ℕ), g = ⇑polynomial.C (f.coeff i)} ≤ I
{δ' : Type u_5} {π : δ' → Type u_7} {π' : δ' → Type u_8} [Π (x : δ'), measurable_space (π x)] [Π (x : δ'), measurable_space (π' x)] (e : Π (a : δ'), π a ≃ᵐ π' a) : (Π (a : δ'), π a) ≃ᵐ Π (a : δ'), π' a
{E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {f : E → G} {C : ℝ} {s : set E} {x y : E} {f' : E → (E →L[𝕜] G)} (hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (bound : ∀ (x : E), x ∈ s → ∥f' x∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
{α : Type u_1} {β : Type u_2} {f : α → β} [topological_space β] [has_zero β] {m0 : measurable_space α} (hf : measure_theory.strongly_measurable f) (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] : measure_theory.fin_strongly_measurable f μ
{β : Type v} [conditionally_complete_linear_order β] [topological_space β] [order_topology β] {α : Type u_1} [linear_order α] [topological_space α] [order_topology α] {f : α → β} (Mf : monotone f) (x : α) : filter.tendsto f (nhds_within x (set.Iio x)) (nhds (has_Sup.Sup (f '' set.Iio x)))
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (f : M →ₙ* N) (s : set M) : subsemigroup.map f (subsemigroup.closure s) = subsemigroup.closure (⇑f '' s)
{L : first_order.language} {L' : first_order.language} (φ : L ≃ᴸ L') : L.sentence ≃ L'.sentence
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} (μ : measure_theory.measure α) [normed_group E] {f : α → E} (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ⊤) (hf : measure_theory.ae_strongly_measurable f μ) (ε : ennreal) : ε ^ p.to_real * ⇑μ {x : α | ε ≤ ↑∥f x∥₊} ≤ measure_theory.snorm f p μ ^ p.to_real
{E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] (I : model_with_corners ℝ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (c : M) : Type
{α : Type u_2} [measurable_space α] {f : α → α} {μ : measure_theory.measure α} (hf : measure_theory.conservative f μ) (n : ℕ) : measure_theory.conservative f^[n] μ
{α : Type u} [semiring α] (I : ideal α) : Prop
{α : Type u_1} [measurable_space α] {P : (α → ennreal) → Prop} (h_ind : ∀ (c : ennreal) ⦃s : set α⦄, measurable_set s → P (s.indicator (λ (_x : α), c))) (h_add : ∀ ⦃f g : α → ennreal⦄, disjoint (function.support f) (function.support g) → measurable f → measurable g → P f → P g → P (f + g)) (h_supr : ∀ ⦃f : ℕ → α → ennreal⦄, (∀ (n : ℕ), measurable (f n)) → monotone f → (∀ (n : ℕ), P (f n)) → P (λ (x : α), ⨆ (n : ℕ), f n x)) ⦃f : α → ennreal⦄ (hf : measurable f) : P f
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set V} (hs : ∀ (v : V), v ∈ s → v ≠ 0) (p₁ : P) : linear_independent k (λ (v : ↥s), ↑v) ↔ affine_independent k (λ (p : ↥({p₁} ∪ (λ (v : V), v +ᵥ p₁) '' s)), ↑p)
{R : Type u_1} [euclidean_domain R] {abv : absolute_value R ℤ} {ι : Type u_2} [fintype ι] {ε : ℝ} (hε : 0 < ε) {b : R} (hb : b ≠ 0) (h : abv.is_admissible) (A : fin (h.card ε ^ fintype.card ι).succ → ι → R) : ∃ (i₀ i₁ : fin (h.card ε ^ fintype.card ι).succ), i₀ ≠ i₁ ∧ ∀ (k : ι), ↑(⇑abv (A i₁ k % b - A i₀ k % b)) < ⇑abv b • ε
{α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (s : α → β → Prop) [Π (a : α) (b : β), decidable (s a b)] : Prop
{G : Type w} [topological_space G] (μ : measure_theory.content G) [t2_space G] ⦃U : ℕ → set G⦄ (hU : ∀ (i : ℕ), is_open (U i)) : μ.inner_content ⟨⋃ (i : ℕ), U i, _⟩ ≤ ∑' (i : ℕ), μ.inner_content ⟨U i, _⟩
{α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} (hp_one : 1 ≤ p) (hp_top : p ≠ ⊤) {n : ℕ} {f : fin n → α → β} (hf : ∀ (i : fin n), measure_theory.mem_ℒp (f i) p μ) : measure_theory.unif_integrable f p μ
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_multicoequalizer I] [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] : category_theory.limits.multicoequalizer I ≅ category_theory.limits.coequalizer I.fst_sigma_map I.snd_sigma_map
{A : Type u_2} [comm_ring A] [is_domain A] [is_dedekind_domain A] {I J : ideal A} : I ∣ J ↔ J ≤ I
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {f : α → α} {s : set α} [measure_theory.is_finite_measure μ] (hf : measure_theory.measure_preserving f μ μ) (hs : measurable_set s) (hs' : ⇑μ s ≠ 0) : ∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ≠ 0), f^[m] x ∈ s
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {a b : ℝ} {μ : measure_theory.measure ℝ} [measure_theory.is_finite_measure μ] (c : E) : ∫ (x : ℝ) in a..b, c ∂μ = ((⇑μ (set.Iic b)).to_real - (⇑μ (set.Iic a)).to_real) • c
{α : Type u} [pseudo_emetric_space α] : uniformity α = ⨅ (ε : ennreal) (H : ε > 0), filter.principal {p : α × α | has_edist.edist p.fst p.snd < ε}
{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (W : submodule R M) : submodule R (module.dual R M)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (W : submodule 𝕜 E) (x y : ↥W) : has_inner.inner x y = has_inner.inner ↑x ↑y
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) {p : nnreal} {s : set α} (h : s ⊆ {x : α | v.lim_ratio_meas hρ x < ↑p}) : ⇑ρ s ≤ ↑p * ⇑μ s
{F : Type u_3} [inner_product_space ℝ F] {x y : F} : has_inner.inner x y = ∥x∥ * ∥y∥ ↔ ∥y∥ • x = ∥x∥ • y
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →ₛₗ[σ₁₂] F) {C : ℝ} (h : ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_continuous C h∥ ≤ linear_order.max C 0
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} [inhabited Λ] {σ : Type u_4} [inhabited σ] (M : Λ → turing.TM2.stmt Γ Λ σ) : turing.TM2.cfg Γ Λ σ → turing.TM1.cfg turing.TM2to1.Γ' turing.TM2to1.Λ' σ → Prop
{C : Type u} [category_theory.category C] {W X Y : C} [category_theory.limits.has_binary_product X Y] (f : W ⟶ X) (g : W ⟶ Y) : W ⟶ X ⨯ Y
{R : Type u_1} [normed_ring R] [complete_space R] (x : Rˣ) (t : R) (h : ∥t∥ < ∥↑x⁻¹∥⁻¹) : Rˣ
{β : Type u_2} [uniform_space β] {α : Type u_1} {f : α → β} {s : set (β × β)} (hs : s ∈ uniformity β) (hf : pairwise (λ (x y : α), (f x, f y) ∉ s)) : uniform_embedding f
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] ⦃f g : α × β → E⦄ (hf : measure_theory.integrable f (μ.prod ν)) (hg : measure_theory.integrable g (μ.prod ν)) : ∫ (x : α), ∫ (y : β), f (x, y) - g (x, y) ∂ν ∂μ = ∫ (x : α), ∫ (y : β), f (x, y) ∂ν ∂μ - ∫ (x : α), ∫ (y : β), g (x, y) ∂ν ∂μ
{α : Type u_1} [normed_field α] {E : Type u_5} [semi_normed_group E] [normed_space α E] {c : α} (hc : 1 < ∥c∥) {ε : ℝ} (εpos : 0 < ε) {x : E} (hx : ∥x∥ ≠ 0) : ∃ (d : α), d ≠ 0 ∧ ∥d • x∥ < ε ∧ ε / ∥c∥ ≤ ∥d • x∥ ∧ ∥d∥⁻¹ ≤ ε⁻¹ * ∥c∥ * ∥x∥
{R : Type u} [semiring R] (I : ideal (polynomial R)) (n : ℕ) : ideal R
{X : Type u} {Y : Type v} {Z : Type w} [metric_space X] [metric_space Y] [nonempty Z] (Φ : Z → X) (Ψ : Z → Y) (ε : ℝ) (ε0 : 0 < ε) (H : ∀ (p q : Z), |has_dist.dist (Φ p) (Φ q) - has_dist.dist (Ψ p) (Ψ q)| ≤ 2 * ε) : metric_space (X ⊕ Y)
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {s t u : set α} (ht : measurable_set t) (h's : s ⊆ u) (h't : t ⊆ u) (h : ⇑μ u < ⇑μ s + ⇑μ t) : (s ∩ t).nonempty
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} {σ : Type u_4} : turing.TM2.stmt Γ Λ σ → σ → (Π (k : K), list (Γ k)) → turing.TM2.cfg Γ Λ σ
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] (I : model_with_corners 𝕜 E H) (G : Type u_4) [add_group G] [topological_space G] [charted_space H G] : Prop
{E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (f : E ≃L[ℝ] E) (s : set E) : ⇑μ (⇑f '' s) = ennreal.of_real |⇑linear_map.det ↑f| * ⇑μ s
{R : Type u} [comm_ring R] (I J : ideal R) : R ⧸ I ⊔ J →+* (R ⧸ I) ⧸ ideal.map (ideal.quotient.mk I) J
(σ : Type u_1) (R : Type u_2) [comm_semiring R] [fintype σ] (n : ℕ) : mv_polynomial.esymm σ R n = finset.univ.sum (λ (t : {s // s.card = n}), ↑t.prod (λ (i : σ), mv_polynomial.X i))
{E : Type u_1} [normed_group E] [normed_space ℂ E] {a b C : ℝ} {f : ℂ → E} {z : ℂ} (hfd : diff_cont_on_cl ℂ f (complex.re ⁻¹' set.Ioo a b)) (hB : ∃ (c : ℝ) (H : c < real.pi / (b - a)) (B : ℝ), f =O[filter.comap (has_abs.abs ∘ complex.im) filter.at_top ⊓ filter.principal (complex.re ⁻¹' set.Ioo a b)] λ (z : ℂ), real.exp (B * real.exp (c * |z.im|))) (hle_a : ∀ (z : ℂ), z.re = a → ∥f z∥ ≤ C) (hle_b : ∀ (z : ℂ), z.re = b → ∥f z∥ ≤ C) (hza : a ≤ z.re) (hzb : z.re ≤ b) : ∥f z∥ ≤ C
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) : cont_mdiff_map I (model_with_corners_self 𝕜 𝕜) M 𝕜 ⊤ →ₗ[pointed_smooth_map 𝕜 I M ⊤ x] 𝕜
{f f' : ℝ → ℝ} {a b : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → ∀ (r : ℝ), f' x < r → (∃ᶠ (z : ℝ) in nhds_within x (set.Ioi x), slope f x z < r)) {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at B (B' x) (set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → f x = B x → f' x < B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → f x ≤ B x
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {f : α → β → γ} {s : set α} {t : set β} {g : γ → δ} {f' : α → β' → δ} {g' : β → β'} (h_distrib : ∀ (a : α) (b : β), g (f a b) = f' a (g' b)) : g '' set.image2 f s t = set.image2 f' s (g' '' t)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (G : Type u_4) [topological_space G] [charted_space H G] [monoid G] [has_smooth_mul I G] : Type (max u_1 u_4)
{C : snum → Sort u_1} (z : Π (b : bool), C (snum.zero b)) (s : Π (b : bool) (p : snum), C p → C (b::p)) (p : snum) : C p
{α : Type u} {β : Type v} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [conditionally_complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (has_Inf.Inf s)) (Mf : monotone f) (ne : s.nonempty) (H : bdd_below s) : f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
{p : ℕ} [hp_prime : fact (nat.prime p)] {u : ℚ_[p]} (h : ∥u∥ = 1) : ℤ_[p]ˣ
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] (f : A →ₐ[R] B) (I : Type u_1) : (I → A) →ₐ[R] I → B
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} : convex_independent 𝕜 p ↔ ∀ (i : ι) (s : set ι), p i ∉ ⇑(convex_hull 𝕜) (p '' (s  {i}))
{I : Type w₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {D : I → Type u₁} [Π (i : I), category_theory.category (D i)] (F : Π (i : I), C i ⥤ D i) : (Σ (i : I), C i) ⥤ Σ (i : I), D i
{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (O : finset C) (H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y)) : ∃ (S : C) (T : Π {X : C}, X ∈ O → (S ⟶ X)), ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : X ⟶ Y}, ⟨X, ⟨Y, ⟨mX, ⟨mY, f⟩⟩⟩⟩ ∈ H → T mX ≫ f = T mY
{R : Type u} [comm_ring R] [is_domain R] {M : Type v} [add_comm_group M] [module R M] [is_dedekind_domain R] [module.finite R M] (hM : module.is_torsion R M) : ∃ (P : finset (ideal R)) [_inst_7 : decidable_eq ↥P] [_inst_8 : ∀ (p : ideal R), p ∈ P → prime p] (e : ↥P → ℕ), direct_sum.is_internal (λ (p : ↥P), submodule.torsion_by_set R M ↑(↑p ^ e p))
(c : ℂ) (R : ℝ) : circle_map c R '' set.Ioc 0 (2 * real.pi) = metric.sphere c |R|
{x : ℝ} (h : |x| < 1) : has_sum (λ (n : ℕ), x ^ (n + 1) / (↑n + 1)) (-real.log (1 - x))
{σ : Type u_1} {R : Type u_3} {S : Type u_4} [comm_semiring R] [comm_semiring S] (f : R →+* mv_polynomial σ S) : mv_polynomial σ R →+* mv_polynomial σ S
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {G : Type u_5} [topological_space α] [add_comm_group α] [topological_add_group α] [topological_space β] [add_comm_group β] [topological_add_group β] [topological_space γ] [add_comm_group γ] [topological_add_group γ] [topological_space δ] [add_comm_group δ] [topological_add_group δ] [uniform_space G] [add_comm_group G] [uniform_add_group G] [separated_space G] [complete_space G] {e : β →+ α} (de : dense_inducing ⇑e) {f : δ →+ γ} (df : dense_inducing ⇑f) {φ : β →+ δ →+ G} (hφ : continuous (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd)) : continuous (_.extend (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd))
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {c : ℝ} {f : α → E} {g' : α → F'} {l : filter α} : asymptotics.is_O_with c l f (λ (x : α), ∥g' x∥) → asymptotics.is_O_with c l f g'
{Fq : Type u_1} [fintype Fq] [field Fq] (n : ℕ) {ε : ℝ} (hε : 0 < ε) {b : polynomial Fq} (hb : b ≠ 0) (A : fin n → polynomial Fq) : ∃ (t : fin n → fin (fintype.card Fq ^ ⌈-real.log ε / real.log ↑(fintype.card Fq)⌉₊)), ∀ (i₀ i₁ : fin n), t i₀ = t i₁ → ↑(⇑polynomial.card_pow_degree (A i₁ % b - A i₀ % b)) < ⇑polynomial.card_pow_degree b • ε
{C : Type u} [category_theory.category C] {I : category_theory.limits.multispan_index C} (K : category_theory.limits.multicofork I) (b : I.R) : I.right b ⟶ K.X
{C : Type u} [category_theory.category C] (I J : category_theory.limits.has_zero_morphisms C) : I = J
{R : Type u_1} [semiring R] (φ : power_series R) (n : ℕ) (h : ∀ (i : ℕ), i < n → ⇑(power_series.coeff R i) φ = 0) : ↑n ≤ φ.order
{α : Type u_1} [measurable_space α] {ι : Type u_2} {L : filter ι} [L.is_countably_generated] [topological_space α] [opens_measurable_space α] (μ : measure_theory.finite_measure α) {c : nnreal} {E : set α} (E_mble : measurable_set E) (fs : ι → bounded_continuous_function α nnreal) (fs_bdd : ∀ᶠ (i : ι) in L, ∀ᵐ (a : α) ∂↑μ, ⇑(fs i) a ≤ c) (fs_lim : ∀ᵐ (a : α) ∂↑μ, filter.tendsto (λ (i : ι), ⇑(fs i) a) L (nhds (E.indicator (λ (x : α), 1) a))) : filter.tendsto (λ (n : ι), ∫⁻ (a : α), ↑(⇑(fs n) a) ∂↑μ) L (nhds (⇑↑μ E))
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_multicoequalizer I] : C
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : (∀ (a : set (submodule R M)), a.nonempty → (∃ (M' : submodule R M) (H : M' ∈ a), ∀ (I : submodule R M), I ∈ a → M' ≤ I → I = M')) ↔ is_noetherian R M
{ι : Type u_1} {I : box_integral.box ι} : has_le (box_integral.prepartition I)
{α : Type u_1} [measurable_space α] (μ : measure_theory.measure α) (s : set α) : ⇑μ s = ⨅ (t : {t // s ⊆ t ∧ measurable_set t}), ⇑μ ↑t
{α : Type u_1} [measurable_space α] [topological_space α] [normal_space α] [borel_space α] (E : Type u_2) [normed_group E] [second_countable_topology_either α E] {p : ennreal} [fact (1 ≤ p)] (hp : p ≠ ⊤) (μ : measure_theory.measure α) [normed_space ℝ E] [μ.weakly_regular] : (measure_theory.Lp.bounded_continuous_function E p μ).topological_closure = ⊤
{E : Type u_3} {F : Type u_4} [semi_normed_group E] [semi_normed_group F] {f : E → F} {C : nnreal} : lipschitz_with C f → ∀ (x y : E), ∥f x - f y∥ ≤ ↑C * ∥x - y∥
{α : Type u} {β : Type v} {φ : ultrafilter α} [linear_order β] : linear_order (↑φ.germ β)
{F : Type u_3} [inner_product_space ℝ F] {x y : F} : ∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * has_inner.inner x y + ∥y∥ ^ 2
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {s t : set α} [measure_theory.is_finite_measure μ] (hms : measurable_set s) (hcs : ⇑μ s ≠ 0) (hcs' : ⇑μ sᶜ ≠ 0) : ⇑(probability_theory.cond μ s) t * ⇑μ s + ⇑(probability_theory.cond μ sᶜ) t * ⇑μ sᶜ = ⇑μ t
{α : Type u} [pseudo_emetric_space α] {s : set (α × α)} : s ∈ uniformity α ↔ ∃ (ε : ennreal) (H : ε > 0), ∀ {a b : α}, has_edist.edist a b < ε → (a, b) ∈ s
{β : Type u_2} [normed_group β] {α : Type u_1} {m : measurable_space α} (f : α → β) (μ : measure_theory.measure α . "volume_tac") : Prop
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} (f : Z ⟶ Y) (I : category_theory.InjectiveResolution Y) (J : category_theory.InjectiveResolution Z) : J.cocomplex.X 1 ⟶ I.cocomplex.X 1
{a b : ℝ} (n : ℕ) : ∫ (x : ℝ) in a..b, real.sin x ^ (n + 2) = (real.sin a ^ (n + 1) * real.cos a - real.sin b ^ (n + 1) * real.cos b) / (↑n + 2) + (↑n + 1) / (↑n + 2) * ∫ (x : ℝ) in a..b, real.sin x ^ n
{V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 1)) (i : fin (n + 2)) : (s.altitude i).direction = (vector_span ℝ (s.points '' ↑(finset.univ.erase i)))ᗮ ⊓ vector_span ℝ (set.range s.points)
{β : Type u_1} [comm_monoid β] (f : ℕ → β) (h_mult : ∀ (x y : ℕ), x.coprime y → f (x * y) = f x * f y) (hf : f 1 = 1) {n : ℕ} : n ≠ 0 → f n = n.factorization.prod (λ (p k : ℕ), f (p ^ k))
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} : smooth_manifold_with_corners I H
{E : Type u_3} [normed_group E] (f : ℝ → E) (μ : measure_theory.measure ℝ) (a b : ℝ) : Prop
{α : Type u_1} {m : measurable_space α} (s : measure_theory.signed_measure α) (μ : measure_theory.measure α) : measure_theory.signed_measure α
(semireducible : interactive.parse (optional (lean.parser.tk "!"))) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (use : interactive.parse (lean.parser.tk "using" *> lean.parser.many interactive.types.ident_ <|> return list.nil)) (opt : tactic.suggest.suggest_opt := {to_opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := λ (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (λ (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}, compulsory_hyps := list.nil expr, try_this := bool.tt}) : tactic unit
{ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} {f : smooth_partition_of_unity ι I M s} {U : ι → set M} : f.is_subordinate U → f.to_partition_of_unity.is_subordinate U
{p q : Prop} (h : q → p) : slim_check.test_result p → (psum unit (p → q) := psum.inl ()) → slim_check.test_result q
{α : Type u} {β : Type v} [pseudo_emetric_space α] {ι : Type u_1} {F : ι → β → α} {f : β → α} {p : filter ι} {s : set β} : tendsto_uniformly_on F f p s ↔ ∀ (ε : ennreal), ε > 0 → (∀ᶠ (n : ι) in p, ∀ (x : β), x ∈ s → has_edist.edist (f x) (F n x) < ε)
{S₁ : Type v} {S₂ : Type w} (σ : Type u_1) [comm_semiring S₁] [comm_semiring S₂] (e : S₁ ≃+* S₂) : mv_polynomial σ S₁ ≃+* mv_polynomial σ S₂
{α : Type u_1} [topological_space α] [sigma_compact_space α] {m : measurable_space α} (μ : measure_theory.measure α) [measure_theory.is_locally_finite_measure μ] : μ.finite_spanning_sets_in {K : set α | is_open K}
{R : Type u} [comm_ring R] (I : ideal R) : Prop
{C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] (G : D ⥤ C) [category_theory.is_right_adjoint G] [Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_5 : G.is_split_pair f g], category_theory.creates_colimit (category_theory.limits.parallel_pair f g) G] : category_theory.monadic_right_adjoint G
(fn : name) (args : list expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic expr
{α : Type u_1} [fintype α] [decidable_eq α] (σ : equiv.perm α) : multiset ℕ
{α : Type u} (p : α → Sort u_1) {f : α → α} (h : Π (a : α), p a → p (f a)) {a : α} (ha : p a) (n : ℕ) : p (f^[n] a)
{elab : bool} : expr elab → option pos
{F : Type u_2} [normed_group F] [normed_space ℝ F] {x y : F} (hx : x ≠ 0) (hy : y ≠ 0) : same_ray ℝ x y ↔ ∥x∥⁻¹ • x = ∥y∥⁻¹ • y
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) [hμ : measure_theory.is_finite_measure μ] : measure_theory.signed_measure α
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {f : α → E} {C : ℝ} [strict_convex_space ℝ E] [measure_theory.is_finite_measure μ] (h_le : ∀ᵐ (x : α) ∂μ, ∥f x∥ ≤ C) : f =ᵐ[μ] function.const α (⨍ (x : α), f x ∂μ) ∨ ∥∫ (x : α), f x ∂μ∥ < (⇑μ set.univ).to_real * C
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group β] (f : α → β) (hf : measure_theory.integrable f μ) : ↥(measure_theory.Lp β 1 μ)
{R : Type u} [comm_semiring R] (I : ideal (polynomial R)) (p : polynomial R) (hp : ∀ (n : ℕ), p.coeff n ∈ ideal.comap polynomial.C I) : p ∈ I
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {c : ℝ} {f' : α → E'} {g' : α → F'} {l : filter α} : asymptotics.is_O_with c l f' g' → asymptotics.is_O_with c l (λ (x : α), ∥f' x∥) (λ (x : α), ∥g' x∥)
(renames : name_map name) (strict : bool := bool.tt) (use_unique_names : bool := bool.ff) : tactic unit
{α : Type u} [pseudo_metric_space α] : (uniformity α).has_basis (λ (ε : ennreal), 0 < ε) (λ (ε : ennreal), {p : α × α | has_edist.edist p.fst p.snd < ε})
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {s : set M} (hs : unique_mdiff_on I s) (x : M) (y : M') {f : M → M'} (hf : continuous_on f s) : unique_diff_on 𝕜 ((ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' (s ∩ f ⁻¹' (ext_chart_at I' y).source))
{G : Type u_1} [measurable_space G] [add_comm_group G] {μ : measure_theory.measure G} [μ.is_add_left_invariant] : μ.is_add_right_invariant
{R : Type u_1} [comm_ring R] (I : ideal R) : (nhds 0).has_basis (λ (n : ℕ), true) (λ (n : ℕ), ↑(I ^ n))
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} [measure_theory.sigma_finite μ] (P : α → Prop) (h : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → (∀ᵐ (x : α) ∂μ.restrict s, P x)) : ∀ᵐ (x : α) ∂μ, P x
(P : Π (R : Type u) [_inst_7 : comm_ring R], Prop) : Prop
{a b : ℝ} (ha : a ≤ 0) {z : ℂ} (hz : |z.im| ≤ b) (hb : b ≤ real.pi / 2) : complex.abs (complex.exp (↑a * (complex.exp z + complex.exp (-z)))) ≤ real.exp (a * real.cos b * real.exp |z.re|)
{α : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] [normed_group F] {f : α → E} {g : α → F} (hg : measure_theory.mem_ℒp g p μ) (hf : measure_theory.ae_strongly_measurable f μ) (hfg : ∀ᵐ (x : α) ∂μ, ∥f x∥ ≤ ∥g x∥) : measure_theory.mem_ℒp f p μ
{R : Type u_1} [ring R] (φ : power_series R) : φ - ⇑(power_series.C R) (⇑(power_series.constant_coeff R) φ) = power_series.mk (λ (p : ℕ), ⇑(power_series.coeff R (p + 1)) φ) * power_series.X
{I : Type u_5} {A : Type u_6} {X : I → Type u_7} [topological_space A] [Π (i : I), topological_space (X i)] (f : Π (i : I), C(A, X i)) : C(A, Π (i : I), X i)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {H : Type u_5} [topological_space H] {H' : Type u_6} [topological_space H'] (I : model_with_corners 𝕜 E H) (I' : model_with_corners 𝕜 E' H') (M : Type u_8) [topological_space M] [charted_space H M] (M' : Type u_9) [topological_space M'] [charted_space H' M'] (n : with_top ℕ) : Type (max u_8 u_9)
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] (σ : R →+* S) (M : Type u_3) [topological_space M] [add_comm_monoid M] (M₂ : Type u_4) [topological_space M₂] [add_comm_monoid M₂] [module R M] [module S M₂] : Type (max u_3 u_4)
{E : Type u} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {f' : E} {x r : ℝ} (hf : has_deriv_within_at f f' (set.Ici x) x) (hr : ∥f'∥ < r) : ∃ᶠ (z : ℝ) in nhds_within x (set.Ioi x), ∥z - x∥⁻¹ * ∥f z - f x∥ < r
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {σ₂₁ : 𝕜₂ →+* 𝕜} [ring_hom_inv_pair σ₁₂ σ₂₁] [ring_hom_inv_pair σ₂₁ σ₁₂] (f : E ≃ₛₗ[σ₁₂] F) (a : ℝ) (ha : 0 < a) (hf : ∀ (x : E), ∥⇑f x∥ = a * ∥x∥) : E ≃SL[σ₁₂] F
{α : Type u_1} {E : Type u_4} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} (f : ↥(measure_theory.Lp.simple_func E p μ)) : measure_theory.simple_func α E
{α : Type u_1} {β : Type u_2} [add_monoid β] {m : measurable_space α} (μ : measure_theory.measure α) (T : set α → β) : Prop
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x : E) (S : submodule 𝕜 E) [complete_space E] [complete_space ↥S] : ∥x∥ ^ 2 = ∥⇑(orthogonal_projection S) x∥ ^ 2 + ∥⇑(orthogonal_projection Sᗮ) x∥ ^ 2
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) (h : W ⟶ X) (k : W ⟶ Y) (H₁ : category_theory.limits.is_terminal Z) (H₂ : category_theory.limits.is_limit (category_theory.limits.binary_fan.mk h k)) : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk h k _)
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.tagged_prepartition I) : Prop
(env : environment) (results : list (name × linter × native.rb_map name string)) (decls non_auto_decls : list declaration) (group_by_filename : option ℕ) (where_desc : string) (slow : bool) (verbose : lint_verbosity) (num_linters : ℕ) (emit_workflow_commands : bool := bool.ff) : format
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : α → ennreal} (h : ∫⁻ (x : α), f x ∂μ ≠ ⊤) {ε : ennreal} (hε : ε ≠ 0) : ∃ (δ : ennreal) (H : δ > 0), ∀ (s : set α), ⇑μ s < δ → ∫⁻ (x : α) in s, f x ∂μ < ε
{R : Type u} {ι : Type v} [comm_ring R] {L : Type w} [lie_ring L] [lie_algebra R L] (I : ι → lie_ideal R L) [decidable_eq ι] : Prop
{α : Type u_1} {m0 : measurable_space α} (μ : measure_theory.measure α) (C : set (set α)) : Type u_1
{α : Type u_1} {G : Type u_5} [normed_group G] {m : measurable_space α} {μ μ' : measure_theory.measure α} (c' : ennreal) (hc' : c' ≠ ⊤) (hμ'_le : μ' ≤ c' • μ) : continuous (λ (f : ↥(measure_theory.Lp G 1 μ)), measure_theory.integrable.to_L1 ⇑f _)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x : E} {s : set E} (h : has_fderiv_within_at f f' s x) {α : Type u_4} (l : filter α) {c : α → 𝕜} {d : α → E} {v : E} (dtop : ∀ᶠ (n : α) in l, x + d n ∈ s) (clim : filter.tendsto (λ (n : α), ∥c n∥) l filter.at_top) (cdlim : filter.tendsto (λ (n : α), c n • d n) l (nhds v)) : filter.tendsto (λ (n : α), c n • (f (x + d n) - f x)) l (nhds (⇑f' v))
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_monoid M] [nontrivial R] {m : M} {S : set M} (h : add_monoid_algebra.of' R M m ∈ submodule.span R ↑(submonoid.closure (add_monoid_algebra.of' R M '' S))) : m ∈ add_submonoid.closure S
{α : Type u_1} {β : Type u_2} [measurable_space β] [measurable_space α] (f : α → β) (μ : measure_theory.measure α) : measure_theory.measure β
(bang : interactive.parse (optional (lean.parser.tk "!"))) (trace : interactive.parse (optional (lean.parser.tk "?"))) (cfg : tactic.tidy.cfg := {trace_result := bool.ff, trace_result_prefix := "Try this: ", tactics := tactic.tidy.default_tactics}) : tactic unit
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] [smooth_manifold_with_corners I M] [smooth_manifold_with_corners I' M'] (f : M → M') : tangent_bundle I M → tangent_bundle I' M'
{G : Type u_1} [group G] [topological_space G] [topological_group G] {K V : set G} (hK : is_compact K) (hV : (interior V).nonempty) : ∃ (n : ℕ), n ∈ finset.card '' {t : finset G | K ⊆ ⋃ (g : G) (H : g ∈ t), (λ (h : G), g * h) ⁻¹' V}
(a b : ℝ) (f : ℝ → ℝ) (c : continuous_on f (set.Icc a b)) (ε : ℝ) (pos : 0 < ε) : ∃ (p : polynomial ℝ), ∀ (x : ℝ), x ∈ set.Icc a b → |polynomial.eval x p - f x| < ε
{ι : Type u_10} {R : Type u_11} {R₂ : Type u_12} {M : Type u_13} {M₂ : Type u_14} [semiring R] [semiring R₂] [add_comm_monoid M] [module R M] [add_comm_monoid M₂] [module R₂ M₂] [topological_space M] [topological_space M₂] {σ : R →+* R₂} {σ' : R₂ →+* R} [ring_hom_inv_pair σ σ'] [ring_hom_inv_pair σ' σ] {f : ι → M} (e : M ≃SL[σ] M₂) {y : M₂} : has_sum (λ (b : ι), ⇑e (f b)) y ↔ has_sum f (⇑(e.symm) y)
{a b : ℝ} {g' g φ : ℝ → ℝ} (hab : a ≤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at g (g' x) (set.Ioi x) x) (φint : measure_theory.integrable_on φ (set.Icc a b) measure_theory.measure_space.volume) (hφg : ∀ (x : ℝ), x ∈ set.Ico a b → g' x ≤ φ x) : g b - g a ≤ ∫ (y : ℝ) in a..b, φ y
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (b : B.is_symm) (W : submodule R M) : (B.restrict W).is_symm
{𝕆 : Type u_1} {ℙ : Type u_2} {α : Type u_3} [preorder 𝕆] [preorder «ℙ»] [preorder α] [grade_order 𝕆 α] (f : 𝕆 → «ℙ») (hf : strict_mono f) (hcovby : ∀ (a b : 𝕆), a ⋖ b → f a ⋖ f b) : grade_order «ℙ» α
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] (c : complex_shape ι) (F : V ⥤ W) [F.additive] : homotopy_category V c ⥤ homotopy_category W c
{P : ℕ → Sort u_1} (h0 : P 0) (h1 : P 1) (h : Π (a p n : ℕ), nat.prime p → ¬p ∣ a → 0 < n → P a → P (p ^ n * a)) (a : ℕ) : P a
{V : Type u_1} [inner_product_space ℝ V] (x y : V) : real.sin (inner_product_geometry.angle x y) * (∥x∥ * ∥y∥) = real.sqrt (has_inner.inner x x * has_inner.inner y y - has_inner.inner x y * has_inner.inner x y)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [normed_group E] [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →SL[σ₁₂] F) [ring_hom_isometric σ₁₂] : ∥f∥ = 0 ↔ f = 0
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_multicoequalizer I] : category_theory.limits.multicofork I
{R : Type u_1} [semiring R] {φ ψ : power_series R} : φ = ψ ↔ ∀ (n : ℕ), ⇑(power_series.coeff R n) φ = ⇑(power_series.coeff R n) ψ
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr × expr)
{p : ℕ} {f : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R → witt_vector p R} (hf : witt_vector.is_poly₂ p f) : witt_vector.is_poly p (λ (R : Type u_1) (_Rcr : comm_ring R) (x : witt_vector p R), f x x)
{S : Type u₁} {L : Type u₂} {D : Type u₃} [category_theory.category S] [category_theory.category L] [category_theory.category D] (ι : S ⥤ L) (F : S ⥤ D) [I : ∀ (x : L), category_theory.limits.has_colimit (category_theory.Lan.diagram ι F x)] : L ⥤ D
{V : Type u_1} [inner_product_space ℝ V] {x y : V} (h : inner_product_geometry.angle x y = 0) : has_inner.inner x y = ∥x∥ * ∥y∥
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {G : Type u_4} [topological_space G] [charted_space H G] [monoid G] [has_smooth_mul I G] (g : G) (X : left_invariant_derivation I G) : ⇑(hfdifferential _) (⇑(derivation.eval_at 1) ↑X) = ⇑(derivation.eval_at g) ↑X
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] (f : α → β) (hf : measure_theory.ae_strongly_measurable f μ) : α → β
{α : Type u} {β : Type v} {φ : ultrafilter α} [linear_ordered_ring β] : linear_ordered_ring (↑φ.germ β)
{ι : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [semiring A] [algebra R A] [decidable_eq ι] [add_monoid ι] (𝒜 : ι → submodule R A) [graded_algebra 𝒜] (I : ideal A) : homogeneous_ideal 𝒜
{α : Type u_1} (m : set (measure_theory.outer_measure α)) {s : set α} (hm : m.nonempty) : ⇑(measure_theory.outer_measure.restrict s) (has_Inf.Inf m) = has_Inf.Inf (⇑(measure_theory.outer_measure.restrict s) '' m)
{α : Type u_1} [measurable_space α] (f : α → ennreal) (p : ℝ) (μ : measure_theory.measure α) : α → ennreal
{α : Type u} [topological_space α] (U : set α) : coe ⁻¹' (coe '' U) = ⋃ (x : α) (H : x ∈ U), connected_component x
(p : pos) (pre post : string) (args : list tactic.simp_arg_type) (at_pos : bool := bool.ff) : tactic unit
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {s : set M} {n : with_top ℕ} (hf : cont_mdiff_on I I' n f s) (hmn : 1 ≤ n) (hs : unique_mdiff_on I s) : continuous_on (tangent_map_within I I' f s) (tangent_bundle.proj I M ⁻¹' s)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] (I : model_with_corners 𝕜 E H) {G : Type u_4} [has_mul G] [topological_space G] [charted_space H G] [has_smooth_mul I G] (g : G) : cont_mdiff_map I I G G ⊤
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (𝕜 : Type u_3) [field 𝕜] [is_alg_closed 𝕜] [category_theory.linear 𝕜 C] [category_theory.limits.has_kernels C] (X : C) [category_theory.simple X] [I : finite_dimensional 𝕜 (X ⟶ X)] : finite_dimensional.finrank 𝕜 (X ⟶ X) = 1
{α : Type u_1} {F : Type u_3} [normed_group F] {m : measurable_space α} (f : α → F) (μ : measure_theory.measure α) : ennreal
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (h : ↑(S.topological_closure) = set.univ) : ∥S.normed_mk∥ = 0
{α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (has_Inf.Inf s)) (Mf : monotone f) (hs : s.nonempty) : f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
{N : Type u_1} {G : Type u_2} [group N] [group G] {φ : G →* mul_aut N} {N₁ : Type u_4} {G₁ : Type u_5} [group N₁] [group G₁] {φ₁ : G₁ →* mul_aut N₁} (f₁ : N →* N₁) (f₂ : G →* G₁) (h : ∀ (g : G), f₁.comp (mul_equiv.to_monoid_hom (⇑φ g)) = (mul_equiv.to_monoid_hom (⇑φ₁ (⇑f₂ g))).comp f₁) : N ⋊[φ] G →* N₁ ⋊[φ₁] G₁
{elab : bool} : expr elab → expr elab
{R : Type u} [ring R] {ι : Type v} [preorder ι] (G : ι → Type w) [Π (i : ι), add_comm_group (G i)] [Π (i : ι), module R (G i)] (f : Π (i j : ι), i ≤ j → (G i →ₗ[R] G j)) (i j : ι) : G i →ₗ[R] G j
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (μ : R) : ℕ
{S : Type u} [semigroup S] : transitive (λ (a b : S), ∃ (c : S), semiconj_by c a b)
{X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] {f : X → E} {μ : measure_theory.measure X} {K : set X} (hK : is_compact K) (hf : ∀ (x : X), x ∈ K → measure_theory.integrable_at_filter f (nhds_within x K) μ) : measure_theory.integrable_on f K μ
{C : Type u} [category_theory.category C] {A : C} [category_theory.limits.has_finite_products C] [category_theory.exponentiable A] {I : C} (t : category_theory.limits.is_initial I) : A ⨯ I ≅ I
{ι : Type u_1} {E : ι → Type u_2} [Π (i : ι), topological_space (E i)] {s : Π (i : ι), set (set (E i))} (hs : ∀ (i : ι), topological_space.is_topological_basis (s i)) : topological_space.is_topological_basis (⋃ (i : ι), (λ (u : set (E i)), sigma.mk i '' u) '' s i)
{α : Type u} {σ : Type v} (M : NFA α σ) : language α
{α : Type u_1} {m0 : measurable_space α} (μ : measure_theory.measure α) : nnreal
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} [category_theory.limits.has_equalizer f g] {W : C} (k : W ⟶ X) (h : k ≫ f = k ≫ g) : W ⟶ category_theory.limits.equalizer f g
{E : Type u_1} [normed_group E] [normed_space ℂ E] {f : ℂ → E} (hd : diff_cont_on_cl ℂ f {z : ℂ | 0 < z.re}) (hexp : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : asymptotics.superpolynomial_decay filter.at_top real.exp (λ (x : ℝ), ∥f ↑x∥)) (him : ∃ (C : ℝ), ∀ (x : ℝ), ∥f (↑x * complex.I)∥ ≤ C) : set.eq_on f 0 {z : ℂ | 0 ≤ z.re}
(R : Type u) [comm_ring R] : galois_connection (λ (I : ideal R), prime_spectrum.zero_locus ↑I) (λ (t : (set (prime_spectrum R))ᵒᵈ), prime_spectrum.vanishing_ideal t)
{α : Type u_1} {C : free_add_monoid α → Sort u_2} (xs : free_add_monoid α) (h0 : C 0) (ih : Π (x : α) (xs : free_add_monoid α), C xs → C (free_add_monoid.of x + xs)) : C xs
{α : Type u_1} {m0 : measurable_space α} ⦃s s' : set α⦄ (hs : s ⊆ s') ⦃μ ν : measure_theory.measure α⦄ (hμν : μ ≤ ν) : μ.restrict s ≤ ν.restrict s'
{R : Type u} {ι : Type x} [semiring R] {φ : ι → Type i} [Π (i : ι), add_comm_monoid (φ i)] [Π (i : ι), module R (φ i)] [decidable_eq ι] (i : ι) : φ i →ₗ[R] Π (i : ι), φ i
{R : Type u_1} [comm_semiring R] (I : ideal R) [hp : I.is_prime] : submonoid R
{𝕜 : Type u} [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] {H : Type w} [topological_space H] (I : model_with_corners 𝕜 E H) : model_with_corners 𝕜 (E × E) (model_prod H E)
{𝕜 : Type u_1} {A : Type u_2} [comm_ring 𝕜] [no_zero_divisors 𝕜] [topological_space 𝕜] [has_continuous_add 𝕜] [has_continuous_const_smul 𝕜 𝕜] [topological_space A] [semiring A] [algebra 𝕜 A] (φ : ↥(weak_dual.character_space 𝕜 A)) : A →ₐ[𝕜] 𝕜
{α : Type u_1} {γ : Type u_3} [measurable_space α] (μ : measure_theory.measure α) [topological_space α] [borel_space α] {𝕜 : Type u_5} [semiring 𝕜] [topological_space γ] [topological_space.pseudo_metrizable_space γ] [add_comm_group γ] [module 𝕜 γ] [topological_add_group γ] [has_continuous_const_smul 𝕜 γ] [second_countable_topology_either α γ] : C(α, γ) →ₗ[𝕜] α →ₘ[μ] γ
{V : Type u_1} {W : Type u_2} [semi_normed_group V] [semi_normed_group W] (f : V →+ W) (C : ℝ) (h : ∀ (v : V), ∥⇑f v∥ ≤ C * ∥v∥) : normed_group_hom V W
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (n : with_top ℕ) (f : M → M') (s : set M) : Prop
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group β] {p : ennreal} {g : α → β} (hp : 1 ≤ p) (hp_ne_top : p ≠ ⊤) (hgm : measure_theory.strongly_measurable g) (hg : measure_theory.mem_ℒp g p μ) : measure_theory.uniform_integrable (λ (n : ι), g) p μ
{α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} {μ : measure_theory.measure α} [hp : fact (1 ≤ p)] (hm : m ≤ m0) (f : ↥(measure_theory.Lp_meas_subgroup F m p μ)) : ∥measure_theory.Lp_meas_subgroup_to_Lp_trim F p μ hm f∥ = ∥f∥
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [I : is_noetherian R M] (f : M →ₗ[R] M) : ∃ (n : ℕ), n ≠ 0 ∧ (f ^ n).ker ⊓ (f ^ n).range = ⊥
{α : Type u_1} {𝕜 : Type u_2} [linear_ordered_field 𝕜] (G : simple_graph α) [decidable_rel G.adj] (ε : 𝕜) (s t : finset α) : finset α × finset α
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [measure_theory.is_locally_finite_measure μ] (x : α) : ∀ᶠ (a : set α) in v.filter_at x, ⇑μ a < ⊤
{α : Type u_1} {β : α → Type u_2} {P : Π (x : α), β x → Prop} [c : Π (a : α), encodable (β a)] [d : Π (x : α) (y : β x), decidable (P x y)] : (∀ (x : α), ∃ (y : β x), P x y) ↔ ∃ (f : Π (a : α), β a), ∀ (x : α), P x (f x)
{ι : Type u_1} [fintype ι] [decidable_eq ι] {D : ι → ℝ} (h : (matrix.diagonal D).det ≠ 0) : ennreal.of_real |(matrix.diagonal D).det| • measure_theory.measure.map ⇑(⇑matrix.to_lin' (matrix.diagonal D)) measure_theory.measure_space.volume = measure_theory.measure_space.volume
{C : Type u} [category_theory.category C] [category_theory.limits.has_strict_initial_objects C] {I : C} (X : C) [category_theory.limits.has_binary_product X I] (hI : category_theory.limits.is_initial I) : X ⨯ I ≅ I
{R : Type u} [comm_ring R] (I : ideal R) (h : ∀ (J : ideal R) (hJ : J.is_maximal), is_localization.coe_submodule (localization.at_prime J) I = 0) : I = 0
{R : Type u_1} [semiring R] {φ ψ : power_series R} {n : ℕ} (h : ↑n < ψ.order) : ⇑(power_series.coeff R n) (φ * ψ) = 0
(ι : Type u_1) (X : Type u_2) [topological_space X] (s : set X := set.univ) : Type (max u_1 u_2)
{α : Type u_1} {β : Type u_2} {m0 : measurable_space α} [measurable_space β] [encodable β] [measurable_singleton_class β] (μ : measure_theory.measure α) (f : α → β) (hf : measurable f) : measure_theory.measure.map f μ = measure_theory.measure.sum (λ (b : β), ⇑μ (f ⁻¹' {b}) • measure_theory.measure.dirac b)
{α : Type u_1} [pseudo_metric_space α] [measurable_space α] [opens_measurable_space α] {μ : measure_theory.measure α} {s : set α} (hs : ∃ (R : ℝ) (H : R > 0), ⇑μ (metric.cthickening R s) ≠ ⊤) : filter.tendsto (λ (r : ℝ), ⇑μ (metric.cthickening r s)) (nhds 0) (nhds (⇑μ (closure s)))
{R₁ : Type u_1} {R₂ : Type u_2} [semiring R₁] [semiring R₂] (σ : R₁ →+* R₂) (σ' : out_param (R₂ →+* R₁)) : Prop
{V : Type u} [category_theory.category V] [category_theory.preadditive V] [category_theory.limits.has_zero_object V] {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] [category_theory.limits.has_zero_object W] (F : V ⥤ W) [F.additive] : cochain_complex.single₀ V ⋙ F.map_homological_complex (complex_shape.up ℕ) ≅ F ⋙ cochain_complex.single₀ W
{α : Type u} {σ : Type v} (M : ε_NFA α σ) : language α
{I : Type v₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {J : Type v₁} [category_theory.small_category J] {F : J ⥤ Π (i : I), C i} [∀ (i : I), category_theory.limits.has_limit (F ⋙ category_theory.pi.eval C i)] : category_theory.limits.has_limit F
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {s : set α} {t : set β} {f : α → β' → γ} {g : β → β'} {f' : β → α → δ} {g' : δ → γ} (h_right_anticomm : ∀ (a : α) (b : β), f a (g b) = g' (f' b a)) : set.image2 f s (g '' t) = g' '' set.image2 f' t s
{ιa : Type u_7} {ιb : Type u_8} [decidable_eq ιa] [decidable_eq ιb] [fintype ιa] [fintype ιb] {R' : Type u_9} {Mᵢ : Type u_10} {N₁ : Type u_11} {N₂ : Type u_12} [comm_semiring R'] [add_comm_group N₁] [module R' N₁] [add_comm_group N₂] [module R' N₂] [add_comm_monoid Mᵢ] [module R' Mᵢ] (a : alternating_map R' Mᵢ N₁ ιa) (b : alternating_map R' Mᵢ N₂ ιb) (σ : equiv.perm.mod_sum_congr ιa ιb) {v : ιa ⊕ ιb → Mᵢ} {i j : ιa ⊕ ιb} (hv : v i = v j) (hij : i ≠ j) : ⇑(alternating_map.dom_coprod.summand a b σ) v + ⇑(alternating_map.dom_coprod.summand a b (equiv.swap i j • σ)) v = 0
{G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {μ : measure_theory.measure G} [group G] [topological_group G] [μ.is_mul_left_invariant] (U : set G) (hU : is_open U) (h'U : U.nonempty) (h : ⇑μ U ≠ ⊤) {K : set G} (hK : is_compact K) : ⇑μ K < ⊤
{C : Type u} [category_theory.category C] {X : C} {J : category_theory.grothendieck_topology C} {S T : J.cover X} (I : S.relation) (f : S ⟶ T) : T.relation
{α : Type u_1} {E : Type u_2} [normed_group E] {m : measurable_space α} {μ : measure_theory.measure α} {f : measure_theory.simple_func α E} {g : E → ennreal} (hf : measure_theory.integrable ⇑f μ) (hg0 : g 0 = 0) (ht : ∀ (b : E), g b ≠ ⊤) : measure_theory.simple_func.integral μ (measure_theory.simple_func.map (ennreal.to_real ∘ g) f) = (∫⁻ (a : α), g (⇑f a) ∂μ).to_real
{ι : Type u_1} {M : Type u_2} [add_comm_monoid M] {I₀ : with_top (box_integral.box ι)} {I : box_integral.box ι} [fintype ι] (f : box_integral.box_additive_map ι M I₀) (hI : ↑I ≤ I₀) {π₁ π₂ : box_integral.prepartition I} (h : π₁.Union = π₂.Union) : π₁.boxes.sum (λ (J : box_integral.box ι), ⇑f J) = π₂.boxes.sum (λ (J : box_integral.box ι), ⇑f J)
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} {σ : Type u_3} : turing.TM1.stmt Γ Λ σ → finset (turing.TM1.stmt Γ Λ σ)
{X : Top} {ι : Type v} (U : ι → topological_space.opens ↥X) {V W : category_theory.pairwise ι} : (V ⟶ W) → (Top.presheaf.sheaf_condition.pairwise_to_opens_le_cover_obj U V ⟶ Top.presheaf.sheaf_condition.pairwise_to_opens_le_cover_obj U W)
{I : Type u} (X : I → Top) (i : I) : ↥(fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (Π (i : I), ↥(X i)))) ⥤ ↥(fundamental_groupoid.fundamental_groupoid_functor.obj (X i))
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens ↥X) (R : category_theory.presieve U) (f g : Σ (V : topological_space.opens ↥X), {f // R f}) : (Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters F U R).hom ≫ category_theory.limits.pi.π (λ (p : (Σ (V : topological_space.opens ↥X), {f // R f}) × Σ (V : topological_space.opens ↥X), {f // R f}), F.obj (opposite.op (Top.presheaf.covering_of_presieve U R p.fst ⊓ Top.presheaf.covering_of_presieve U R p.snd))) (f, g) = category_theory.limits.pi.π (λ (fg : (Σ (V : topological_space.opens ↥X), {f // R f}) × Σ (W : topological_space.opens ↥X), {g // R g}), F.obj (opposite.op (category_theory.limits.pullback fg.fst.snd.val fg.snd.snd.val))) (f, g) ≫ F.map (category_theory.eq_to_hom _).op
{x : pgame} : 0.lf x ↔ ∃ (i : x.left_moves), ∀ (j : (x.move_left i).right_moves), 0.lf ((x.move_left i).move_right j)
(I p : name) : tactic (list (list name))
{V : Type u} {W : Type v} (G : simple_graph V) (G' : simple_graph W) : Type (max u v)
{R : Type u} {S : Type v} [ring R] [ring S] (I : ideal R) (J : ideal S) : ideal (R × S)
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] : ∃ (ν : measure_theory.measure α), measure_theory.is_finite_measure ν ∧ μ.absolutely_continuous ν
{α : Type u_1} {p : multiset α → Sort u_2} {n : ℕ} (s : multiset α) : (Π (t₁ : multiset α), (Π {t₂ : multiset α}, ⇑multiset.card t₂ ≤ n → t₁ < t₂ → p t₂) → ⇑multiset.card t₁ ≤ n → p t₁) → ⇑multiset.card s ≤ n → p s
{α : Type u_1} {β : Type u_2} (e : α ≃ β) (s : set α) : ↥s ≃ ↥(⇑e '' s)
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (v : n → R) (A : matrix n n R) : matrix.det (λ (i j : n), v i * A i j) = finset.univ.prod (λ (i : n), v i) * A.det
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} [fintype ι] (hp_one : 1 ≤ p) (hp_top : p ≠ ⊤) {f : ι → α → β} (hf : ∀ (i : ι), measure_theory.mem_ℒp (f i) p μ) : measure_theory.unif_integrable f p μ
(ps : list pexpr) (cfg : auto.auto_config := {use_simp := bool.tt, max_ematch_rounds := 20}) : tactic unit
{P : Type u_1} [preorder P] (p : P) {ι : Type u_2} [encodable ι] (𝒟 : ι → order.cofinal P) (i : ι) : ∃ (x : P), x ∈ 𝒟 i ∧ x ∈ order.ideal_of_cofinals p 𝒟
{R : Type u_1} {S : Type u_6} {M : Type u_7} {M₂ : Type u_9} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid M₂] {module_M : module R M} {module_S_M₂ : module S M₂} {σ : R →+* S} {σ' : S →+* R} {re₁ : ring_hom_inv_pair σ σ'} {re₂ : ring_hom_inv_pair σ' σ} (e : M ≃ₛₗ[σ] M₂) : e.to_linear_map.to_add_monoid_hom = e.to_add_equiv.to_add_monoid_hom
{K : Type u} [field K] ⦃s t : set K⦄ (h : s ⊆ t) : subfield.closure s ≤ subfield.closure t
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h0 : 0 < r) (h : ↑r < p.radius) : ∃ (C : ℝ) (H : C > 0), ∀ (n : ℕ), ∥p n∥ ≤ C / ↑r ^ n
(N : Type u_1) (G : Type u_2) [group N] [group G] (φ : G →* mul_aut N) : Type (max u_1 u_2)
{α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} (h : μ = ν) : μ.absolutely_continuous ν
{R : Type u_1} [ring R] (n : ℕ) : ↑-1 = ↑n - 1
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {f : α → E} {C : ℝ} [strict_convex_space ℝ E] (h_le : ∀ᵐ (x : α) ∂μ, ∥f x∥ ≤ C) : f =ᵐ[μ] function.const α (⨍ (x : α), f x ∂μ) ∨ ∥⨍ (x : α), f x ∂μ∥ < C
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ℤ] [category_theory.preadditive C] [∀ (n : ℤ), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T ∈ dist_triang C) : T.mor₁ ≫ T.mor₂ = 0
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f i • g (⇑σ i)) = finset.univ.sum (λ (i : ι), f i • g i) ↔ monovary f (g ∘ ⇑σ)
{L : first_order.language} {ι : Type v} [preorder ι] (G : ι → Type w) [Π (i : ι), L.Structure (G i)] (f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] [is_directed ι has_le.le] : setoid (Σ (i : ι), G i)
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.prepartition I) (x : ι → ℝ) : set.inj_on (λ (J : box_integral.box ι), {i : ι | J.lower i = x i}) {J : box_integral.box ι | J ∈ π ∧ x ∈ ⇑box_integral.box.Icc J}
{𝕜 : Type u} {A : Type v} [field 𝕜] [ring A] [algebra 𝕜 A] [is_alg_closed 𝕜] [nontrivial A] (a : A) (p : polynomial 𝕜) (hnon : (spectrum 𝕜 a).nonempty) : spectrum 𝕜 (⇑(polynomial.aeval a) p) = (λ (k : 𝕜), polynomial.eval k p) '' spectrum 𝕜 a
{T : ℝ} {g : ℝ → ℝ} (hg : function.periodic g T) (h_int : ∀ (t₁ t₂ : ℝ), interval_integrable g measure_theory.measure_space.volume t₁ t₂) (hT : 0 < T) (t : ℝ) : ∫ (x : ℝ) in 0..t, g x ≤ has_Sup.Sup ((λ (t : ℝ), ∫ (x : ℝ) in 0..t, g x) '' set.Icc 0 T) + ⌊t / T⌋ • ∫ (x : ℝ) in 0..T, g x
{G : Type u_4} [measurable_space G] {μ : measure_theory.measure G} [topological_space G] [group G] [topological_group G] [borel_space G] [μ.is_mul_left_invariant] [μ.regular] (hμ : μ ≠ 0) {f : G → ennreal} (hf : continuous f) : ∫⁻ (x : G), f x ∂μ = 0 ↔ f = 0
{R : Type u_1} [comm_ring R] (I : ideal R) {M : Type u_2} [add_comm_group M] [module R M] {N : Type u_3} [add_comm_group N] [module R N] [h : is_Hausdorff I N] (f : M →ₗ[R] N) : Hausdorffification I M →ₗ[R] N
{F : pfunctor} {r : F.M → Sort w} (x : F.M) (f : Π (a : F.A) (f : F.B a → F.M), r (pfunctor.M.mk ⟨a, f⟩)) : r x
{ι : Type u_5} {π : ι → Type u_6} [fintype ι] [Π (i : ι), topological_space (π i)] [∀ (i : ι), discrete_topology (π i)] : discrete_topology (Π (i : ι), π i)
{α : Type u_1} {𝕜 : Type u_2} [linear_ordered_field 𝕜] [decidable_eq α] {A : finset α} (P : finpartition A) (G : simple_graph α) [decidable_rel G.adj] (ε : 𝕜) : finset (finset α × finset α)
{L : first_order.language} {L' : first_order.language} {α : Type u'} (φ : L ≃ᴸ L') : L.term α ≃ L'.term α
{σ : Type u} : σ ↪ cardinal
{α : Type u} [decidable_eq α] (i j : α) (σ : equiv.perm α) : equiv.swap i j * (equiv.swap i j * σ) = σ
{V : Type (u+1)} [category_theory.large_category V] {W : Type (u+1)} [category_theory.large_category W] (F : V ⥤ W) (G : Mon) : Action V G ⥤ Action W G
(I : Type w₀) (C : I → Type u₁) [Π (i : I), category_theory.category (C i)] : category_theory.pi.comap C id ≅ 𝟭 (Π (i : I), C i)
(P : Π {R S : Type u} [_inst_7 : comm_ring R] [_inst_8 : comm_ring S], (R →+* S) → Prop) : Prop
{α : Type u_1} [non_unital_semi_normed_ring α] (x y : α) : ∥⇑(add_monoid_hom.mul_right x) y∥ ≤ ∥x∥ * ∥y∥
{B : Type u₁} [category_theory.bicategory B] {C : Type u₂} [category_theory.bicategory C] (obj : B → C) (map : Π {X Y : B}, (X ⟶ Y) → (obj X ⟶ obj Y)) (map₂ : Π {a b : B} {f g : a ⟶ b}, (f ⟶ g) → (map f ⟶ map g)) (map_comp : Π {a b c : B} (f : a ⟶ b) (g : b ⟶ c), map (f ≫ g) ⟶ map f ≫ map g) {a b c d : B} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) : Prop
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} [linear_order α] {a b : α} {P : α → Prop} : (∀ᵐ (x : α) ∂μ.restrict (set.interval_oc a b), P x) ↔ (∀ᵐ (x : α) ∂μ.restrict (set.Ioc a b), P x) ∧ ∀ᵐ (x : α) ∂μ.restrict (set.Ioc b a), P x
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} {g : E → ℝ} [measure_theory.is_finite_measure μ] (hg : concave_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hμ : μ ≠ 0) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) (hgi : measure_theory.integrable (g ∘ f) μ) : ⨍ (x : α), g (f x) ∂μ ≤ g (⨍ (x : α), f x ∂μ)
{G : Type u_4} [measurable_space G] {μ : measure_theory.measure G} [add_group G] [has_measurable_add G] [μ.is_add_right_invariant] (f : G → ennreal) (g : G) : ∫⁻ (x : G), f (x + g) ∂μ = ∫⁻ (x : G), f x ∂μ
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] {I : ideal S} {f : R →+* S} : function.injective ⇑(I.quotient_map f le_rfl)
{α : Type u_1} {β : Type u_2} [topological_space β] (m : measurable_space α) {m0 : measurable_space α} (f : α → β) (μ : measure_theory.measure α) : Prop
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {I : ideal R} (hM : module.is_torsion_by_set R M ↑I) : has_scalar (R ⧸ I) M
{α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} {f : α → β} (hp_one : 1 ≤ p) (hp_top : p ≠ ⊤) (hf : measure_theory.mem_ℒp f p μ) (hmeas : measure_theory.strongly_measurable f) {ε : ℝ} (hε : 0 < ε) : ∃ (δ : ℝ) (hδ : 0 < δ), ∀ (s : set α), measurable_set s → ⇑μ s ≤ ennreal.of_real δ → measure_theory.snorm (s.indicator f) p μ ≤ 2 * ennreal.of_real ε
{α : Type u_1} [nonempty α] [semilattice_sup α] [no_max_order α] {β : Type u_2} [semi_normed_group β] {f : α → β} {b : β} : filter.tendsto f filter.at_top (nhds b) ↔ ∀ (ε : ℝ), 0 < ε → (∃ (N : α), ∀ (n : α), N < n → ∥f n - b∥ < ε)
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : (f =O[l] λ (x : α), ∥g' x∥) → f =O[l] g'
{R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] ⦃f g : dual_number R →ₐ[R] A⦄ (h : ⇑f dual_number.eps = ⇑g dual_number.eps) : f = g
{α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [borel_space α] [μ.weakly_regular] (A : set α) (hA : measurable_set A) (h'A : ⇑μ A ≠ ⊤) : (μ.restrict A).weakly_regular
{M : Type u_1} [semi_normed_group M] {S : add_subgroup M} (x : M ⧸ S) {ε : ℝ} (hε : 0 < ε) : ∃ (m : M), ⇑(quotient_add_group.mk' S) m = x ∧ ∥m∥ < ∥x∥ + ε
{X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] {f : X → E} {μ : measure_theory.measure X} [opens_measurable_space X] [topological_space.metrizable_space X] [measure_theory.is_locally_finite_measure μ] {K : set X} (hK : is_compact K) (hf : continuous_on f K) : measure_theory.integrable_on f K μ
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) {s t : set M} {x' : M} (h : x' ∈ (ext_chart_at I x).source) (ht : t ∈ nhds_within x' s) : ⇑((ext_chart_at I x).symm) ⁻¹' t ∈ nhds_within (⇑(ext_chart_at I x) x') (⇑((ext_chart_at I x).symm) ⁻¹' s ∩ set.range ⇑I)
{α : Type u_1} {m0 : measurable_space α} (μ : measure_theory.measure α) [h : measure_theory.sigma_finite μ] : μ.finite_spanning_sets_in {s : set α | measurable_set s}
{R : Type u_1} [semiring R] : 0.order = ⊤
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] (p : tangent_bundle I M) : tangent_map I I.tangent (tangent_bundle.zero_section I M) p = ⟨⟨p.fst, 0⟩, (p.snd, 0)⟩
{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (f : G →+ N) (s : set G) : add_subgroup.map f (add_subgroup.closure s) = add_subgroup.closure (⇑f '' s)
{F : Type u_3} [inner_product_space ℝ F] {x y : F} : ∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * has_inner.inner x y + ∥y∥ ^ 2
{R : Type u_1} [comm_semiring R] {I : ideal R} [hI : I.is_prime] : ideal.map (algebra_map R (localization.at_prime I)) I = local_ring.maximal_ideal (localization I.prime_compl)
{G : Type u_4} [measurable_space G] {μ : measure_theory.measure G} [group G] [has_measurable_mul G] [μ.is_mul_left_invariant] (f : G → ennreal) (g : G) : ∫⁻ (x : G), f (g * x) ∂μ = ∫⁻ (x : G), f x ∂μ
{α : Type u} {β : Type v} [pseudo_metric_space α] [topological_space β] {f : α → β} {s : set α} (hf : continuous_on f s) (hs : topological_space.is_separable s) : topological_space.is_separable (f '' s)
{R : Type u} {ι : Type x} [semiring R] {φ : ι → Type i} [Π (i : ι), add_comm_monoid (φ i)] [Π (i : ι), module R (φ i)] (i : ι) : (Π (i : ι), φ i) →ₗ[R] φ i
{α : Type u_1} [measurable_space α] (s : measure_theory.signed_measure α) : ∃ (i j : set α), measurable_set i ∧ 0.restrict i ≤ measure_theory.vector_measure.restrict s i ∧ measurable_set j ∧ measure_theory.vector_measure.restrict s j ≤ 0.restrict j ∧ is_compl i j
{α : Type u} {β : Type v} [pseudo_emetric_space α] [nonempty β] [semilattice_sup β] {u : β → α} : cauchy_seq u ↔ ∀ (ε : nnreal), 0 < ε → (∃ (N : β), ∀ (n : β), N ≤ n → has_edist.edist (u n) (u N) < ↑ε)
(R₁ : Type u_3) {A : Type u_5} [comm_semiring R₁] [comm_ring A] [algebra R₁ A] (I : ideal A) : ↑(ideal.quotient.mkₐ R₁ I).ker = I
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} (hp : p ∈ s) : vector_span k s = submodule.span k ((λ (_x : P), _x -ᵥ p) '' s)
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (a : set α), ⇑ρ a / ⇑μ a) (v.filter_at x) (nhds (ρ.rn_deriv μ x))
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] {ρ : measure_theory.measure α} (ν : measure_theory.measure α) [measure_theory.is_locally_finite_measure ν] (hρ : ρ.absolutely_continuous μ) (s : set α) (hs : ∀ (x : α), x ∈ s → (∃ᶠ (a : set α) in v.filter_at x, ⇑ρ a ≤ ⇑ν a)) : ⇑ρ s ≤ ⇑ν s
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} [category_theory.limits.has_pullback f g] {W : C} {k l : W ⟶ category_theory.limits.pullback f g} (h₀ : k ≫ category_theory.limits.pullback.fst = l ≫ category_theory.limits.pullback.fst) (h₁ : k ≫ category_theory.limits.pullback.snd = l ≫ category_theory.limits.pullback.snd) : k = l
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {μ : R} {k : ℕ} (h : f.has_generalized_eigenvalue μ k) : k ≠ 0
{f : ℝ → ℝ} (hf : differentiable ℝ f) {C : ℝ} (hf'_ge : ∀ (x : ℝ), C ≤ deriv f x) ⦃x y : ℝ⦄ (hxy : x ≤ y) : C * (y - x) ≤ f y - f x
{R : Type u_1} {V : Type u_2} {W : Type u_3} {P : Type u_4} {Q : Type u_5} [ring R] [add_comm_group V] [module R V] [topological_space P] [add_torsor V P] [add_comm_group W] [module R W] [topological_space Q] [add_torsor W Q] {W₂ : Type u_6} {Q₂ : Type u_7} [add_comm_group W₂] [module R W₂] [topological_space Q₂] [add_torsor W₂ Q₂] (f : Q →A[R] Q₂) (g : P →A[R] Q) : P →A[R] Q₂
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] (W : subspace K V) : (module.dual K V ⧸ submodule.dual_annihilator W) ≃ₗ[K] module.dual K ↥W
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (v : n → R) (A : matrix n n R) : matrix.det (λ (i j : n), v j * A i j) = finset.univ.prod (λ (i : n), v i) * A.det
(E : Type u_1) [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] : ∃ (δ : ℝ), 0 < δ ∧ δ < 1 ∧ ∀ (s : finset E), (∀ (c : E), c ∈ s → ∥c∥ ≤ 2) → (∀ (c : E), c ∈ s → ∀ (d : E), d ∈ s → c ≠ d → 1 - δ ≤ ∥c - d∥) → s.card ≤ besicovitch.multiplicity E
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} [category_theory.limits.has_equalizer f g] {W : C} (k : W ⟶ X) (h : k ≫ f = k ≫ g) : {l // l ≫ category_theory.limits.equalizer.ι f g = k}
{α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {f : α → F'} {s : set α} {m m₂ m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) (hm₂ : m₂ ≤ m0) [measure_theory.sigma_finite (μ.trim hm)] [measure_theory.sigma_finite (μ.trim hm₂)] (hs_m : measurable_set s) (hs : ∀ (t : set α), measurable_set (s ∩ t) ↔ measurable_set (s ∩ t)) : measure_theory.condexp m μ f =ᵐ[μ.restrict s] measure_theory.condexp m₂ μ f
{α : Type u_1} {E : Type u_3} [semi_normed_group E] {f : α → E} {g : α → ℝ} {t₀ : filter α} (h : ∀ (n : α), ∥f n∥ ≤ g n) (h' : filter.tendsto g t₀ (nhds 0)) : filter.tendsto f t₀ (nhds 0)
{ι : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [semiring A] [algebra R A] (𝒜 : ι → submodule R A) [decidable_eq ι] [add_monoid ι] [graded_algebra 𝒜] (I : ideal A) : Prop
{E : Type u} [normed_group E] [normed_space ℝ E] {n : ℕ} [complete_space E] (I : box_integral.box (fin (n + 1))) (f : (fin (n + 1) → ℝ) → fin (n + 1) → E) (f' : (fin (n + 1) → ℝ) → ((fin (n + 1) → ℝ) →L[ℝ] fin (n + 1) → E)) (s : set (fin (n + 1) → ℝ)) (hs : s.countable) (Hs : ∀ (x : fin (n + 1) → ℝ), x ∈ s → continuous_within_at f (⇑box_integral.box.Icc I) x) (Hd : ∀ (x : fin (n + 1) → ℝ), x ∈ ⇑box_integral.box.Icc I  s → has_fderiv_within_at f (f' x) (⇑box_integral.box.Icc I) x) : box_integral.has_integral I ⊥ (λ (x : fin (n + 1) → ℝ), finset.univ.sum (λ (i : fin (n + 1)), ⇑(f' x) (pi.single i 1) i)) box_integral.box_additive_map.volume (finset.univ.sum (λ (i : fin (n + 1)), box_integral.integral (I.face i) ⊥ (λ (x : fin n → ℝ), f (i.insert_nth (I.upper i) x) i) box_integral.box_additive_map.volume - box_integral.integral (I.face i) ⊥ (λ (x : fin n → ℝ), f (i.insert_nth (I.lower i) x) i) box_integral.box_additive_map.volume))
{X : ℕ → Type u} [Π (n : ℕ), metric_space (X n)] {f : Π (n : ℕ), X n → X (n + 1)} (I : ∀ (n : ℕ), isometry (f n)) : metric_space (metric.inductive_limit I)
{ι : Type u_2} {π : ι → Type u_1} [fintype ι] [Π (i : ι), normed_group (π i)] : normed_group (Π (i : ι), π i)
{K : Type u} [division_ring K] (I : ideal K) : I = ⊥ ∨ I = ⊤
{α : Type u_1} {E : α → Type u_2} [Π (i : α), normed_group (E i)] {p q : ennreal} (hpq : p.to_real.is_conjugate_exponent q.to_real) (f : ↥(lp E p)) (g : ↥(lp E q)) : summable (λ (i : α), ∥⇑f i∥ * ∥⇑g i∥) ∧ ∑' (i : α), ∥⇑f i∥ * ∥⇑g i∥ ≤ ∥f∥ * ∥g∥
{E : Type u_2} [normed_group E] [normed_space ℝ E] (h : ∀ (x y : E), ∥x + y∥ = ∥x∥ + ∥y∥ → same_ray ℝ x y) : strict_convex_space ℝ E
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] : ∏ I.left ⟶ ∏ I.right
{E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] {f : E →ₗ[ℝ] E} (hf : ⇑linear_map.det f ≠ 0) (s : set E) : ⇑μ (⇑f ⁻¹' s) = ennreal.of_real |(⇑linear_map.det f)⁻¹| * ⇑μ s
(p : ℕ) [fact (nat.prime p)] {R : Type u₁} [comm_semiring R] [char_p R p] {P : Type u₂} [comm_semiring P] [char_p P p] [perfect_ring P p] (π : P →+* R) : Prop
{ι : Type u} {E : Type v} [fintype ι] [normed_group E] [normed_space ℝ E] [complete_space E] {f : (ι → ℝ) → E} {μ : measure_theory.measure (ι → ℝ)} [measure_theory.is_locally_finite_measure μ] {I : box_integral.box ι} (hf : measure_theory.integrable_on f ↑I μ) (l : box_integral.integration_params) (hl : l.bRiemann = bool.ff) : box_integral.has_integral I l f μ.to_box_additive.to_smul (∫ (x : ι → ℝ) in ↑I, f x ∂μ)
{α : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space α} {ℙ : measure_theory.measure α} {μ : measure_theory.measure E} {F : Type u_3} [measurable_space F] {ν : measure_theory.measure F} {X : α → E} [measure_theory.has_pdf X «ℙ» μ] {g : E → F} (hg : measure_theory.measure.quasi_measure_preserving g μ ν) (hmap : (measure_theory.measure.map g (measure_theory.measure.map X «ℙ»)).have_lebesgue_decomposition ν) : measure_theory.has_pdf (g ∘ X) «ℙ» ν
 : interactive.parse (sum.inlsum.inlfunctor.map <$> (lean.parser.tk ":" *> interactive.types.texpr) <|> sum.inrsum.inrfunctor.map <$> interactive.parse_binders interactive.types.tac_rbp) → tactic unit
{R : Type u_1} [comm_ring R] {I J : ideal R} (hIJ : I ≤ J) {x : R} : ⇑(ideal.quotient.mk I) x ∈ ideal.map (ideal.quotient.mk I) J ↔ x ∈ J
{V : Type u} {W : Type v} {X : Type w} {G : simple_graph V} {G' : simple_graph W} {G'' : simple_graph X} (f' : G' →g G'') (f : G →g G') : G →g G''
(𝕜 : Type u_1) (V : Type u_3) (W : Type u_4) [normed_group V] [normed_group W] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 V] [normed_space 𝕜 W] : (V →A[𝕜] W) ≃ₗᵢ[𝕜] W × (V →L[𝕜] W)
{R : Type u_1} [comm_semiring R] {I : ideal R} [hI : I.is_prime] : ideal.comap (algebra_map R (localization.at_prime I)) (local_ring.maximal_ideal (localization I.prime_compl)) = I
{α : Type u_1} {m0 : measurable_space α} ⦃s s' : set α⦄ ⦃μ ν : measure_theory.measure α⦄ (hs : s ≤ᵐ[μ] s') (hμν : μ ≤ ν) : μ.restrict s ≤ ν.restrict s'
{F : Type u_3} [inner_product_space ℝ F] {K : set F} (ne : K.nonempty) (h₁ : is_complete K) (h₂ : convex ℝ K) (u : F) : ∃ (v : F) (H : v ∈ K), ∥u - v∥ = ⨅ (w : ↥K), ∥u - ↑w∥
{α : Type u_1} {E : Type u_2} {F : Type u_3} (𝕜 : Type u_6) [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {m : measurable_space α} {μ : measure_theory.measure α} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 F] [complete_space F] {T : set α → (E →L[ℝ] F)} {C : ℝ} (hT : measure_theory.dominated_fin_meas_additive μ T C) (h_smul : ∀ (c : 𝕜) (s : set α) (x : E), ⇑(T s) (c • x) = c • ⇑(T s) x) : ↥(measure_theory.Lp E 1 μ) →L[𝕜] F
{F : Type u_3} [inner_product_space ℝ F] (x y : F) : has_inner.inner x y = (∥x + y∥ * ∥x + y∥ - ∥x∥ * ∥x∥ - ∥y∥ * ∥y∥) / 2
{I : Type w₀} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {X Y : Π (i : I), C i} (f : X ≅ Y) (i : I) : X i ≅ Y i
(𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] {s : set E} (s_nhd : s ∈ nhds 0) : is_closed (coe_fn '' normed_space.polar 𝕜 s)
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} [complete_space F] (h : box_integral.integrable I l f vol) : box_integral.box_additive_map ι F ↑I
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr)
{ι : Type u} {β : ι → Type v} [dec : decidable_eq ι] [Π (i : ι), add_zero_class (β i)] {γ : Type w} [add_zero_class γ] ⦃f g : (Π₀ (i : ι), β i) →+ γ⦄ (H : ∀ (x : ι), f.comp (dfinsupp.single_add_hom β x) = g.comp (dfinsupp.single_add_hom β x)) : f = g
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} {W : C} {inl : Y ⟶ W} {inr : Z ⟶ W} (eq : f ≫ inl = g ≫ inr) (desc : Π (s : category_theory.limits.pushout_cocone f g), W ⟶ s.X) (fac_left : ∀ (s : category_theory.limits.pushout_cocone f g), inl ≫ desc s = s.inl) (fac_right : ∀ (s : category_theory.limits.pushout_cocone f g), inr ≫ desc s = s.inr) (uniq : ∀ (s : category_theory.limits.pushout_cocone f g) (m : W ⟶ s.X), inl ≫ m = s.inl → inr ≫ m = s.inr → m = desc s) : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk inl inr eq)
{α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : monotone_on f s) (hs : s ∈ nhds a) (hfs : f '' s ∈ nhds (f a)) : continuous_at f a
{α : Type u_1} (C : lists α → Sort u_2) (D : lists' α bool.tt → Sort u_3) (C0 : Π (a : α), C (lists.atom a)) (C1 : Π (l : lists' α bool.tt), D l → C (lists.of' l)) (D0 : D lists'.nil) (D1 : Π (a : lists α) (l : lists' α bool.tt), C a → D l → D (lists'.cons a l)) : pprod (Π (l : lists α), C l) (Π (l : lists' α bool.tt), D l)
{ι : Type u_1} {β : ι → Type u_2} (r : ι → ι → Prop) (s : Π {i : ι}, β i → β i → Prop) (x y : Π (i : ι), β i) : Prop
{α : Type u_1} [topological_space α] [sigma_compact_space α] {m : measurable_space α} (μ : measure_theory.measure α) [measure_theory.is_locally_finite_measure μ] : μ.finite_spanning_sets_in {K : set α | is_compact K}
{C : Type u} [category_theory.category C] {W X Y : C} {s : category_theory.limits.binary_cofan X Y} (h : category_theory.limits.is_colimit s) (f : X ⟶ W) (g : Y ⟶ W) : {l // s.inl ≫ l = f ∧ s.inr ≫ l = g}
{α : Type u} {β : Type v} [topological_space α] [discrete_topology α] [semi_normed_group β] (f : α → β) (C : ℝ) (H : ∀ (x : α), ∥f x∥ ≤ C) : bounded_continuous_function α β
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} [measurable_space α] {μ : measure_theory.measure α} [topological_space β] [topological_space γ] [topological_space δ] [measurable_space β] [topological_space.pseudo_metrizable_space β] [borel_space β] [topological_space.second_countable_topology β] [measurable_space γ] [topological_space.pseudo_metrizable_space γ] [borel_space γ] [topological_space.second_countable_topology γ] [measurable_space δ] [topological_space.pseudo_metrizable_space δ] [opens_measurable_space δ] [topological_space.second_countable_topology δ] (g : β → γ → δ) (hg : measurable (function.uncurry g)) (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) : α →ₘ[μ] δ
{α : Type u_1} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} (f : ↥(measure_theory.Lp ℝ p μ)) : ↥(measure_theory.Lp ℝ p μ)
{α : Type u_1} {ι : Type u_3} [preorder ι] {m0 : measurable_space α} {μ : measure_theory.measure α} {ℱ : measure_theory.filtration ι m0} [measure_theory.sigma_finite_filtration μ ℱ] {f : ι → α → ℝ} (hf : measure_theory.submartingale f ℱ μ) {i j : ι} (hij : i ≤ j) {s : set α} (hs : measurable_set s) : ∫ (x : α) in s, f i x ∂μ ≤ ∫ (x : α) in s, f j x ∂μ
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : ⇑is_R_or_C.re (has_inner.inner x y) = (∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - ∥x - y∥ * ∥x - y∥) / 2
{α : Type u_1} {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) [measure_theory.sigma_finite (μ.trim hm)] (C : ennreal) {f : α → ennreal} (hf_meas : ae_measurable f μ) (hf : ∀ (s : set α), measurable_set s → ⇑μ s ≠ ⊤ → ∫⁻ (x : α) in s, f x ∂μ ≤ C) : ∫⁻ (x : α), f x ∂μ ≤ C
{E : Type u_2} [add_comm_group E] [module ℝ E] [topological_space E] [topological_add_group E] [has_continuous_smul ℝ E] {s : set E} (hs : convex ℝ s) {x : E} (hx : x ∈ interior s) (t : ℝ) (ht : 1 < t) : closure s ⊆ interior (⇑(affine_map.homothety x t) '' s)
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] {σ : Type u_3} [inhabited σ] (M : Λ → turing.TM1.stmt Γ Λ σ) (s : Γ) : turing.TM1.stmt Γ Λ σ → σ → turing.TM1to0.Λ' M × turing.TM0.stmt Γ
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (I : lie_ideal R L) : lie_subalgebra R L
{σ R : Type u} [comm_semiring R] : cardinal.mk (mv_polynomial σ R) ≤ linear_order.max (linear_order.max (cardinal.mk R) (cardinal.mk σ)) cardinal.aleph_0
{𝕜 : Type u_1} [linear_ordered_field 𝕜] [topological_space 𝕜] [topological_ring 𝕜] (a b : 𝕜) (h : 0 < a) : ⇑(affine_homeomorph a b _) '' set.Icc 0 1 = set.Icc b (a + b)
{R : Type u_1} [semiring R] (φ ψ : power_series R) (h : φ.order ≠ ψ.order) : (φ + ψ).order = φ.order ⊓ ψ.order
{α : Type u_1} {β : Type u_2} [topological_space β] {m0 : measurable_space α} (f : α → β) (μ : measure_theory.measure α) : Prop
{α : Type u_1} {E : Type u_3} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} (f g : ↥(measure_theory.Lp E p μ)) (s : set α) : measure_theory.mem_ℒp.to_Lp ⇑(f + g) _ = measure_theory.mem_ℒp.to_Lp ⇑f _ + measure_theory.mem_ℒp.to_Lp ⇑g _
{α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : monotone_on f s) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : closure (f '' s) ∈ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] [complete_space F] {G : Type u_4} [normed_group G] [normed_space 𝕜 G] [complete_space G] (φ : implicit_function_data 𝕜 E F G) : local_homeomorph E (F × G)
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) (h : W ⟶ X) (k : W ⟶ Y) (H₁ : category_theory.limits.is_initial W) (H₂ : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk f g _)) : category_theory.limits.is_colimit (category_theory.limits.binary_cofan.mk f g)
{α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) : function.right_inverse (measure_theory.Lp_trim_to_Lp_meas_subgroup F p μ hm) (measure_theory.Lp_meas_subgroup_to_Lp_trim F p μ hm)
{α : Type u_1} {m0 : measurable_space α} (μ ν : measure_theory.measure α) : Prop
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [topological_space.second_countable_topology E] [complete_space E] [normed_group F] {f : ℝ → E} {g : ℝ → F} {a b c : ℝ} (hne : a ≠ b) (hc : c ∈ set.interval a b) (h_deriv : ∀ᶠ (x : ℝ) in nhds_within c (set.interval a b  {c}), differentiable_at ℝ f x) (h_infty : filter.tendsto (λ (x : ℝ), ∥f x∥) (nhds_within c (set.interval a b  {c})) filter.at_top) (hg : deriv f =O[nhds_within c (set.interval a b  {c})] g) : ¬interval_integrable g measure_theory.measure_space.volume a b
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h : ↑r < p.radius) : ∃ (a : ℝ) (H : a ∈ set.Ioo 0 1), (λ (n : ℕ), ∥p n∥ * ↑r ^ n) =o[filter.at_top] has_pow.pow a
{𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [semi_normed_group G] {x₀ : G} {R : ℝ} (hf : function.support f ⊆ metric.ball 0 R) (hg : ∀ (x : G), x ∈ metric.ball x₀ R → g x = g x₀) : convolution f g L μ x₀ = ∫ (t : G), ⇑(⇑L (f t)) (g x₀) ∂μ
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (G : C ⥤ D) {W X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} {h : W ⟶ X} {k : W ⟶ Y} (comm : h ≫ f = k ≫ g) [category_theory.limits.reflects_limit (category_theory.limits.cospan f g) G] (l : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk (G.map h) (G.map k) _)) : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk h k comm)
{α : Type u_1} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} (f : ↥(measure_theory.Lp ℝ p μ)) : ↥(measure_theory.Lp ℝ p μ)
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {ε : Type u_9} {f : filter α} {g : filter β} {h : filter γ} {m : δ → γ → ε} {n : α → β → δ} {m₁ : α → γ → α'} {m₂ : β → γ → β'} {n' : α' → β' → ε} (h_distrib : ∀ (a : α) (b : β) (c : γ), m (n a b) c = n' (m₁ a c) (m₂ b c)) : filter.map₂ m (filter.map₂ n f g) h ≤ filter.map₂ n' (filter.map₂ m₁ f h) (filter.map₂ m₂ g h)
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [measurable_space β] {g : α → β} (hg : measurable_embedding g) (f : β → ennreal) : ∫⁻ (a : β), f a ∂measure_theory.measure.map g μ = ∫⁻ (a : α), f (g a) ∂μ
{α : Type u_1} {β : Type u_2} [has_add α] [has_add β] (f : add_hom α β) (I : Type u_3) : add_hom (I → α) (I → β)
{F : Type u_2} [normed_group F] [normed_space ℝ F] {x y : F} : same_ray ℝ x y ↔ x = 0 ∨ y = 0 ∨ ∥x∥⁻¹ • x = ∥y∥⁻¹ • y
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {H : Type u_4} [topological_space H] {I : model_with_corners 𝕜 E H} {H' : Type u_5} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {N : Type u_6} [topological_space N] [charted_space H N] {G : Type u_7} [add_monoid G] [topological_space G] [charted_space H' G] [has_smooth_add I' G] : cont_mdiff_map I I' N G ⊤ →+ N → G
{I : Type w₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {D : Type u₂} [category_theory.category D] (F : Π (i : I), C i ⥤ D) : (Σ (i : I), C i) ⥤ D
{α : Type u} [topological_space α] {ι : Type u_1} {t : set ι} {s : ι → set α} (ht : t.nonempty) (H : ∀ (i : ι), i ∈ t → is_connected (s i)) (K : ∀ (i : ι), i ∈ t → ∀ (j : ι), j ∈ t → relation.refl_trans_gen (λ (i j : ι), (s i ∩ s j).nonempty ∧ i ∈ t) i j) : is_connected (⋃ (n : ι) (H : n ∈ t), s n)
{α : Type u_1} {m : measurable_space α} (f : α → ennreal) (μ : measure_theory.measure α) : ∫⁻ (a : α), f a ∂μ = ⨆ (φ : measure_theory.simple_func α nnreal) (hf : ∀ (x : α), ↑(⇑φ x) ≤ f x), (measure_theory.simple_func.map coe φ).lintegral μ
{M : Type u_1} [add_monoid M] {ι : Type u_2} [hdec : decidable_eq ι] [fintype ι] {N : ι → Type u_3} [Π (i : ι), add_monoid (N i)] : {ϕ // pairwise (λ (i j : ι), ∀ (x : N i) (y : N j), add_commute (⇑(ϕ i) x) (⇑(ϕ j) y))} ≃ ((Π (i : ι), N i) →+ M)
{R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring R₂] {σ₁₂ : R →+* R₂} [add_comm_monoid M₂] [module R₂ M₂] [ring_hom_surjective σ₁₂] (f : M →ₛₗ[σ₁₂] M₂) {x : M} {s : set M} (h : ⇑f x ∉ submodule.span R₂ (⇑f '' s)) : x ∉ submodule.span R s
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p ∈ s) : ↑(s.direction) = has_vsub.vsub p '' ↑s
{α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] {μ : measure_theory.measure α} [μ.weakly_regular] [measure_theory.sigma_finite μ] (f : α → ℝ) (hf : measure_theory.integrable f μ) {ε : ℝ} (εpos : 0 < ε) : ∃ (g : α → ereal), (∀ (x : α), g x < ↑(f x)) ∧ upper_semicontinuous g ∧ measure_theory.integrable (λ (x : α), (g x).to_real) μ ∧ (∀ᵐ (x : α) ∂μ, ⊥ < g x) ∧ ∫ (x : α), f x ∂μ < ∫ (x : α), (g x).to_real ∂μ + ε
{α : Type u_1} [measurable_space α] (μ : measure_theory.measure α) {p q : ℝ} (hpq : p.is_conjugate_exponent q) {f g : α → ennreal} (hf : ae_measurable f μ) (hg : ae_measurable g μ) : ∫⁻ (a : α), (f * g) a ∂μ ≤ (∫⁻ (a : α), f a ^ p ∂μ) ^ (1 / p) * (∫⁻ (a : α), g a ^ q ∂μ) ^ (1 / q)
(n : with_top ℕ) {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {s : set H} (hs : is_open s) : local_homeomorph.of_set s hs ∈ cont_diff_groupoid n I
{X : Type u_2} [emetric_space X] {μ : measure_theory.outer_measure X} (hm : μ.is_metric) : borel X ≤ μ.caratheodory
{V : Type u} [category_theory.category V] [category_theory.preadditive V] {P Q : chain_complex V ℕ} (e : P ⟶ Q) (zero : P.X 0 ⟶ Q.X 1) (comm_zero : e.f 0 = zero ≫ Q.d 1 0) (one : P.X 1 ⟶ Q.X 2) (comm_one : e.f 1 = P.d 1 0 ≫ zero + one ≫ Q.d 2 1) (succ : Π (n : ℕ) (p : Σ' (f : P.X n ⟶ Q.X (n + 1)) (f' : P.X (n + 1) ⟶ Q.X (n + 2)), e.f (n + 1) = P.d (n + 1) n ≫ f + f' ≫ Q.d (n + 2) (n + 1)), Σ' (f'' : P.X (n + 2) ⟶ Q.X (n + 3)), e.f (n + 2) = P.d (n + 2) (n + 1) ≫ p.snd.fst + f'' ≫ Q.d (n + 3) (n + 2)) [category_theory.limits.has_zero_object V] : homotopy e 0
{α : Type u_1} {E : Type u_3} [semi_normed_group E] {f : α → E} {g : α → ℝ} {t₀ : filter α} (h : ∀ᶠ (n : α) in t₀, ∥f n∥ ≤ g n) (h' : filter.tendsto g t₀ (nhds 0)) : filter.tendsto f t₀ (nhds 0)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I : model_with_corners 𝕜 E H} {I' : model_with_corners 𝕜 E' H'} {e : local_homeomorph H H} {e' : local_homeomorph H' H'} (he : e ∈ cont_diff_groupoid ⊤ I) (he' : e' ∈ cont_diff_groupoid ⊤ I') : e.prod e' ∈ cont_diff_groupoid ⊤ (I.prod I')
{α : Type u_1} {m0 : measurable_space α} (μ : measure_theory.measure α) : filter α
{α : Type u_1} {m : measurable_space α} (s : measure_theory.signed_measure α) {i : set α} (hi : 0.restrict i ≤ measure_theory.vector_measure.restrict s i) (hi₁ : measurable_set i) : measure_theory.is_finite_measure (s.to_measure_of_zero_le i hi₁ hi)
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [measurable_space X] [borel_space X] [measurable_space Y] [borel_space Y] {C r : nnreal} {f : X → Y} {s : set X} (h : holder_on_with C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) : ⇑(measure_theory.measure.hausdorff_measure d) (f '' s) ≤ ↑C ^ d * ⇑(measure_theory.measure.hausdorff_measure (↑r * d)) s
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) (s : set α) : measure_theory.measure α
{V : Type u} [category_theory.category V] [category_theory.preadditive V] {P Q : cochain_complex V ℕ} (e : P ⟶ Q) (zero : P.X 1 ⟶ Q.X 0) (comm_zero : e.f 0 = P.d 0 1 ≫ zero) (one : P.X 2 ⟶ Q.X 1) (comm_one : e.f 1 = zero ≫ Q.d 0 1 + P.d 1 2 ≫ one) (succ : Π (n : ℕ) (p : Σ' (f : P.X (n + 1) ⟶ Q.X n) (f' : P.X (n + 2) ⟶ Q.X (n + 1)), e.f (n + 1) = f ≫ Q.d n (n + 1) + P.d (n + 1) (n + 2) ≫ f'), Σ' (f'' : P.X (n + 3) ⟶ Q.X (n + 2)), e.f (n + 2) = p.snd.fst ≫ Q.d (n + 1) (n + 2) + P.d (n + 2) (n + 3) ≫ f'') [category_theory.limits.has_zero_object V] : homotopy e 0
(hyp : name) (cfg : tactic.equiv_rw_cfg) (permissive : bool := bool.ff) : list expr → tactic.interactive.itactic
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : continuous_multilinear_map 𝕜 E G) (m₁ m₂ : Π (i : ι), E i) : ∥⇑f m₁ - ⇑f m₂∥ ≤ ∥f∥ * finset.univ.sum (λ (i : ι), finset.univ.prod (λ (j : ι), ite (j = i) ∥m₁ i - m₂ i∥ (linear_order.max ∥m₁ j∥ ∥m₂ j∥)))
{L : first_order.language} {L' : first_order.language} {α : Type u'} {n : ℕ} (φ : L ≃ᴸ L') : L.bounded_formula α n ≃ L'.bounded_formula α n
(ns : name) (s : tactic.local_cache.internal.cache_scope := tactic.local_cache.cache_scope.block_local) : tactic unit
{L : first_order.language} (M : Type w) [L.Structure M] (φ : L.sentence) : Prop
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f (⇑σ i) * g i) < s.sum (λ (i : ι), f i * g i) ↔ ¬monovary_on (f ∘ ⇑σ) g ↑s
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (x : M) : Type u_2
{f : ℝ → ℝ} (hf : differentiable ℝ f) {C : ℝ} (lt_hf' : ∀ (x : ℝ), deriv f x < C) ⦃x y : ℝ⦄ (hxy : x < y) : f y - f x < C * (y - x)
{R : Type u} {σ : Type u_1} [comm_semiring R] (p : mv_polynomial σ R) : finset (σ →₀ ℕ)
{R : Type u} [comm_semiring R] (f : polynomial R) (𝓟 : ideal R) : Prop
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) (s : measure_theory.signed_measure α) [s.have_lebesgue_decomposition μ] : s.singular_part μ + μ.with_densityᵥ (s.rn_deriv μ) = s
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} {σ : Type u_3} (M : Λ → turing.TM1.stmt Γ Λ σ) : turing.TM1.cfg Γ Λ σ → option (turing.TM1.cfg Γ Λ σ)
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : ℕ → α → ennreal} (hf : ∀ (n : ℕ), ae_measurable (f n) μ) (h_mono : ∀ᵐ (x : α) ∂μ, monotone (λ (n : ℕ), f n x)) : ∫⁻ (a : α), (⨆ (n : ℕ), f n a) ∂μ = ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
{V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (h : ∥x∥ = ∥y∥) : hb.oangle x (x - y) = hb.oangle (y - x) y
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : (f =o[l] λ (x : α), ∥g' x∥) → f =o[l] g'
{α : Type u_1} {β : Type u_2} (f : α → β) (xs : list α) (chunk_size : ℕ := 1024) : list β
{α : Type u_2} [preorder α] {ι : Type u_6} {π : ι → Type u_7} [Π (i : ι), preorder (π i)] : (α →o Π (i : ι), π i) ≃o Π (i : ι), α →o π i
{α : Type u_1} {G : Type u_5} [normed_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] {f : α → G} {m0 : measurable_space α} (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] : measure_theory.fin_strongly_measurable f μ ↔ measurable f
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {W X Y Z : C} [category_theory.limits.has_binary_biproduct W X] [category_theory.limits.has_binary_biproduct Y Z] (f : W ⟶ Y) (g : X ⟶ Z) : W ⊞ X ⟶ Y ⊞ Z
{α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (hf : monotone_on f s) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : closure (f '' s) ∈ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s t : α → Prop} (hst : s =ᵐ[μ] t) {p : α → Prop} : (∀ᵐ (x : α) ∂μ.restrict s, p x) → (∀ᵐ (x : α) ∂μ.restrict t, p x)
{R : Type u_1} [semiring R] {φ : power_series R} (n : ℕ) (h : ⇑(power_series.coeff R n) φ ≠ 0) : φ.order ≤ ↑n
{R : Type u_5} {S : Type u_6} {F : Type u_7} [comm_semiring R] [comm_semiring S] [ring_hom_class F R S] (σ : F) (n : ℕ+) : ↥(roots_of_unity n R) →* ↥(roots_of_unity n S)
{R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] {I I' : R →+* R} [nontrivial R] {B : M →ₛₗ[I] M →ₛₗ[I'] R} {v : basis n R M} (h : B.is_Ortho ⇑v) (hB : B.separating_right) (i : n) : ¬B.is_ortho (⇑v i) (⇑v i)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (hs : unique_mdiff_on I s) (x : M) : unique_diff_on 𝕜 ((ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' s)
{α : Type u_1} {β : Type u_2} {m0 : measurable_space α} [measurable_space β] {μ : measure_theory.measure α} {f : α → β} (hf : ae_measurable f μ) (s : set β) : ⇑μ (f ⁻¹' s) ≤ ⇑(measure_theory.measure.map f μ) s
{α : Type u} [pseudo_emetric_space α] (x : α) (ε : ennreal) : set α
{𝕜 : Type u_1} [is_R_or_C 𝕜] [dec_𝕜 : decidable_eq 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional 𝕜 E] : E ≃ₗᵢ[𝕜] pi_Lp 2 (λ (μ : module.End.eigenvalues T), ↥(module.End.eigenspace T ↑μ))
(𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_3} [linear_order ι] [order_bot ι] [locally_finite_order ι] [is_well_order ι has_lt.lt] (f : ι → E) : pairwise (λ (a b : ι), has_inner.inner (gram_schmidt 𝕜 f a) (gram_schmidt 𝕜 f b) = 0)
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f (⇑σ i) • g i) = finset.univ.sum (λ (i : ι), f i • g i) ↔ monovary (f ∘ ⇑σ) g
(close_goals : bool) (opt : tactic.suggest.suggest_opt := {to_opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := λ (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (λ (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}, compulsory_hyps := list.nil expr, try_this := bool.tt}) (e : expr) : tactic ℕ
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f i • g (⇑σ i)) ≤ finset.univ.sum (λ (i : ι), f i • g i)
{α : Type u_1} {m : measurable_space α} {μ ν : measure_theory.measure α} [measure_theory.is_finite_measure μ] [measure_theory.is_finite_measure ν] : μ.have_lebesgue_decomposition ν
{α : Type u_1} [metric_space α] {K : nnreal} {f : α → α} [nonempty α] [complete_space α] {n : ℕ} (hf : contracting_with K f^[n]) : function.is_fixed_pt f (contracting_with.fixed_point f^[n] hf)
{V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hxyne : x ≠ y) (hxzne : x ≠ z) {r : ℝ} (hx : ∥x∥ = r) (hy : ∥y∥ = r) (hz : ∥z∥ = r) : o.oangle y z = 2 • o.oangle (y - x) (z - x)
{V : Type u} {W : Type v} {X : Type w} {G : simple_graph V} {G' : simple_graph W} {G'' : simple_graph X} (f' : G' ↪g G'') (f : G ↪g G') : G ↪g G''
{R : Type u} [comm_ring R] (I : ideal R) (hqf : is_field (R ⧸ I)) : I.is_maximal
{α : Type u_1} [measurable_space α] (s t : set α) (μ : measure_theory.measure α . "volume_tac") : Prop
{α : Type u} [topological_space α] {ι : Type u_1} {t : set ι} {s : ι → set α} (H : ∀ (i : ι), i ∈ t → is_preconnected (s i)) (K : ∀ (i : ι), i ∈ t → ∀ (j : ι), j ∈ t → relation.refl_trans_gen (λ (i j : ι), (s i ∩ s j).nonempty ∧ i ∈ t) i j) : is_preconnected (⋃ (n : ι) (H : n ∈ t), s n)
{𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] [topological_space.second_countable_topology G] (hbg : bdd_above (set.range (λ (x : G), ∥g x∥))) (hf : measure_theory.integrable f μ) (hg : continuous g) : continuous (convolution f g L μ)
(n : name) (hide_non_prop : bool := bool.tt) : tactic tactic.explode.entries
{α : Type u} {β : Type v} {φ : ultrafilter α} [linear_ordered_field β] : linear_ordered_field (↑φ.germ β)
{R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {g : R →+* P} {T : submonoid P} {Q : Type u_4} [comm_semiring Q] (hy : M ≤ submonoid.comap ↑g T) [algebra P Q] [is_localization T Q] {A : Type u_5} [comm_semiring A] {U : submonoid A} {W : Type u_6} [comm_semiring W] [algebra A W] [is_localization U W] {l : P →+* A} (hl : T ≤ submonoid.comap ↑l U) : (is_localization.map W l hl).comp (is_localization.map Q g hy) = is_localization.map W (l.comp g) _
{α : Type u_1} {β : Type u_2} [measurable_space α] [topological_space α] [topological_space β] [h : second_countable_topology_either α β] [opens_measurable_space α] [topological_space.pseudo_metrizable_space β] {f : α → β} {s : set α} {μ : measure_theory.measure α} (hf : continuous_on f s) (hs : measurable_set s) : measure_theory.ae_strongly_measurable f (μ.restrict s)
{C : Type u} [category_theory.category C] {W X Y : C} [category_theory.limits.has_binary_product X Y] (f : W ⟶ X) (g : W ⟶ Y) : {l // l ≫ category_theory.limits.prod.fst = f ∧ l ≫ category_theory.limits.prod.snd = g}
{P : ℕ → Sort u_1} (h0 : P 0) (h1 : P 1) (hp : Π (p : ℕ), nat.prime p → P p) (h : Π (a b : ℕ), P a → P b → P (a * b)) (a : ℕ) : P a
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {c : ℝ} {g : α → F} {f' : α → E'} {l : filter α} : asymptotics.is_O_with c l (λ (x : α), ∥f' x∥) g → asymptotics.is_O_with c l f' g
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w₁} [category_theory.category D] {E : Type w₂} [category_theory.category E] (F : D ⥤ E) [∀ (α β : Type (max v u)) (fst snd : β → α), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) D] [∀ (α β : Type (max v u)) (fst snd : β → α), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) E] [Π (X : C) (W : J.cover X) (P : Cᵒᵖ ⥤ D), category_theory.limits.preserves_limit (W.index P).multicospan F] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ D] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ E] [Π (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)ᵒᵖ F] : J.plus_functor D ⋙ (category_theory.whiskering_right Cᵒᵖ D E).obj F ≅ (category_theory.whiskering_right Cᵒᵖ D E).obj F ⋙ J.plus_functor E
{C : Type u} [category_theory.category C] (𝒯 : category_theory.limits.limit_cone (category_theory.functor.empty C)) (ℬ : Π (X Y : C), category_theory.limits.limit_cone (category_theory.limits.pair X Y)) : Type u
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] [mβ : measurable_space β] [mγ : measurable_space γ] (f : α → β) (g : α → γ) (μ : measure_theory.measure α . "volume_tac") : Prop
(c : ℂ) (R : ℝ) : set.range (circle_map c R) = metric.sphere c |R|
{G : Type u_1} [measurable_space G] [group G] [topological_space G] [topological_group G] [borel_space G] (μ : measure_theory.measure G) [μ.is_mul_left_invariant] (K : set G) (hK : is_compact K) (h'K : (interior K).nonempty) (h : ⇑μ K ≠ 0) (h' : ⇑μ K ≠ ⊤) : μ.is_haar_measure
{α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] (f : α → β) (s : set α) (hf : function.injective f) (hfm : measurable f) (hfi : ∀ (s : set α), measurable_set s → measurable_set (f '' s)) : ↥s ≃ᵐ ↥(f '' s)
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr × expr)
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : multilinear_map 𝕜 E G) (C : ℝ) (H : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) : continuous ⇑f
{f : ℝ → ℝ} (hf' : differentiable ℝ f) (hf'' : differentiable ℝ (deriv f)) (hf''_nonneg : ∀ (x : ℝ), 0 ≤ deriv^[2] f x) : convex_on ℝ set.univ f
{δ' : Type u_5} (π : δ' → Type u_7) [Π (x : δ'), measurable_space (π x)] (p : δ' → Prop) [decidable_pred p] : (Π (i : δ'), π i) ≃ᵐ (Π (i : subtype p), π ↑i) × Π (i : {i // ¬p i}), π ↑i
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G ↪g G') : G →g G'
{I : Type u_3} {f : I → Type u_4} (i' : I) [inst : ∀ (i : I), nonempty (f i)] [nontrivial (f i')] : nontrivial (Π (i : I), f i)
(opt : tactic.suggest.suggest_opt := {to_opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := λ (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (λ (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}, compulsory_hyps := list.nil expr, try_this := bool.tt}) : tactic.mllist tactic tactic.suggest.application
(R : Type u) [semiring R] (ι : Type v) [dec_ι : decidable_eq ι] {M : ι → Type w} [Π (i : ι), add_comm_monoid (M i)] [Π (i : ι), module R (M i)] (N : Type u₁) [add_comm_monoid N] [module R N] (φ : Π (i : ι), M i →ₗ[R] N) : ⇑(direct_sum.to_module R ι N φ) = ⇑(direct_sum.to_add_monoid (λ (i : ι), (φ i).to_add_monoid_hom))
{α : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) (s t : set α) : Prop
{α : Sort u_1} {s₁ : setoid α} {φ : quotient s₁ → Sort u_2} (qa : quotient s₁) (f : Π (a : α), φ (quotient.mk' a)) (c : ∀ (a₁ a₂ : α), a₁ ≈ a₂ → f a₁ == f a₂) : φ qa
(n : ℕ) {β : typevec (n + 1) → Sort u_2} (f : Π (t : Type u_1) (v : typevec n), β (v ::: t)) (v : typevec (n + 1)) : β v
{σ : Type u_1} (f : σ → option σ) : σ → part σ
{R : Type u} {ι : Type x} [semiring R] {φ : ι → Type u_1} {ψ : ι → Type u_2} [Π (i : ι), add_comm_monoid (φ i)] [Π (i : ι), module R (φ i)] [Π (i : ι), add_comm_monoid (ψ i)] [Π (i : ι), module R (ψ i)] (e : Π (i : ι), φ i ≃ₗ[R] ψ i) : (Π (i : ι), φ i) ≃ₗ[R] Π (i : ι), ψ i
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.tagged_prepartition I) [fintype ι] : nnreal
{M : Type u} [add_monoid M] {a : add_units M} {x y : M} (h : add_semiconj_by ↑a x y) : add_semiconj_by (↑-a) y x
{p : ℕ+} {k : ℕ} {K : Type u} {L : Type v} {ζ : L} [field K] [field L] [algebra K L] [is_cyclotomic_extension {p ^ (k + 1)} K L] [hp : fact (nat.prime ↑p)] [ne_zero ↑↑p] (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) (hk : p ^ (k + 1) ≠ 2) : algebra.discr K ⇑((is_primitive_root.power_basis K hζ).basis) = (-1) ^ (↑p ^ k * (↑p - 1) / 2) * ↑p ^ (↑p ^ k * ((↑p - 1) * (k + 1) - 1))
{𝕜 : Type u_1} {V : Type u_3} {W : Type u_4} [normed_group V] [normed_group W] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 V] [normed_space 𝕜 W] : has_norm (V →A[𝕜] W)
{E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : ℝ → ℝ} (ha : ∥f a∥ ≤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at B (B' x) (set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥f' x∥ ≤ B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → ∥f x∥ ≤ B x
{G : Type u_1} [measurable_space G] [has_add G] [has_measurable_add G] (μ : measure_theory.measure G) : (∀ (g : G) (A : set G), measurable_set A → ⇑μ ((λ (h : G), g + h) ⁻¹' A) = ⇑μ A) ↔ μ.is_add_left_invariant
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {m n : with_top ℕ} {f : H → H'} {s : set H} (hf : cont_mdiff_on I I' n f s) (hmn : m + 1 ≤ n) (hs : unique_mdiff_on I s) : cont_mdiff_on I.tangent I'.tangent m (tangent_map_within I I' f s) (tangent_bundle.proj I H ⁻¹' s)
{α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {δ : Type u_1} [linear_order δ] [topological_space δ] [order_closed_topology δ] {a b : α} (hab : a ≤ b) {f : α → δ} (hf : continuous_on f (set.Icc a b)) : set.Icc (f b) (f a) ⊆ f '' set.Icc a b
{α : Type u_1} {f : filter α} {u : α → ennreal} {a : ennreal} (ha : a ≠ ⊤) : filter.tendsto u f (nhds a) ↔ ∀ (ε : ennreal), ε > 0 → (∀ᶠ (x : α) in f, u x ∈ set.Icc (a - ε) (a + ε))
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [topological_space.second_countable_topology X] {f : X → Y} {s : set X} (hf : ∀ (x : X), x ∈ s → (∃ (C : nnreal) (t : set X) (H : t ∈ nhds_within x s), lipschitz_on_with C f t)) : dimH (f '' s) ≤ dimH s
{δ : Type u_4} {π : δ → Type u_7} [Π (a : δ), measurable_space (π a)] (f : Π (a : δ), π a) {a : δ} [decidable_eq δ] : measurable (function.update f a)
{α : Type u_1} {E : Type u_3} [measurable_space α] [normed_group E] {f : α → E} {μ : measure_theory.measure α} {l : filter α} [l.is_measurably_generated] (hfm : strongly_measurable_at_filter f l μ) (hμ : μ.finite_at_filter l) (hf : filter.is_bounded_under has_le.le l (has_norm.norm ∘ f)) : measure_theory.integrable_at_filter f l μ
{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp : generalized_continued_fraction.int_fract_pair K} (stream_nth_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp) : let g : generalized_continued_fraction K := generalized_continued_fraction.of v, B : K := (g.continuants_aux (n + 1)).b, pB : K := (g.continuants_aux n).b in v - g.convergents n = ite (ifp.fr = 0) 0 ((-1) ^ n / (B * ((ifp.fr)⁻¹ * B + pB)))
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {J : Type w} [category_theory.category J] {K : J ⥤ C} {F : C ⥤ D} [category_theory.reflects_isomorphisms F] (h : Π (c : category_theory.limits.cone (K ⋙ F)) (t : category_theory.limits.is_limit c), category_theory.lifts_to_limit K F c t) : category_theory.creates_limit K F
{ι : Type u} {E : Type v} [fintype ι] [normed_group E] [normed_space ℝ E] {l : box_integral.integration_params} {I : box_integral.box ι} {y : E} {f g : (ι → ℝ) → E} {μ : measure_theory.measure (ι → ℝ)} [measure_theory.is_locally_finite_measure μ] (hf : box_integral.has_integral I l f μ.to_box_additive.to_smul y) (hfg : f =ᵐ[μ.restrict ↑I] g) (hl : l.bRiemann = bool.ff) : box_integral.has_integral I l g μ.to_box_additive.to_smul y
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_multiequalizer I] [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] : category_theory.limits.multiequalizer I ≅ category_theory.limits.equalizer I.fst_pi_map I.snd_pi_map
(rep : interactive.parse tactic.interactive.arity) : interactive.parse (optional tactic.interactive.assert_or_rule) → (tactic.interactive.mono_cfg := {unify := bool.ff}) → tactic unit
{C : Type u₁} [category_theory.category C] {C' : Type u₂} [category_theory.category C'] (D : category_theory.glue_data C) (F : C ⥤ C') [H : Π (i j k : D.J), category_theory.limits.preserves_limit (category_theory.limits.cospan (D.f i j) (D.f i k)) F] [category_theory.limits.has_multicoequalizer D.diagram] [category_theory.limits.preserves_colimit D.diagram.multispan F] : F.obj D.glued ≅ (D.map_glue_data F).glued
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} [complete_space F] (h : box_integral.integrable I l f vol) (π₀ : box_integral.prepartition I) : filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I π₀) (nhds (π₀.boxes.sum (λ (J : box_integral.box ι), box_integral.integral J l f vol)))
{L : first_order.language} {L' : first_order.language} (ϕ : L →ᴸ L') {L'' : first_order.language} (ψ : L'' →ᴸ L') : L.sum L'' →ᴸ L'
{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {N : Type (max u v)} [add_comm_group N] [module R N] [h' : module.finite R N] : ∃ (n : ℕ) (ι : Type u) [_inst_8 : fintype ι] (p : ι → R) [_inst_9 : ∀ (i : ι), irreducible (p i)] (e : ι → ℕ), nonempty (N ≃ₗ[R] (fin n →₀ R) × direct_sum ι (λ (i : ι), R ⧸ submodule.span R {p i ^ e i}))
{α : Type u_1} {m0 : measurable_space α} (μ : measure_theory.measure α) [measure_theory.is_finite_measure μ] : measure_theory.sigma_finite μ
{n : ℕ} {E : Type u_1} [normed_group E] [normed_space ℂ E] [complete_space E] {f : (fin n → ℂ) → E} {c : fin n → ℂ} {R : fin n → ℝ} {C : ℝ} (hf : ∀ (θ : fin n → ℝ), ∥f (torus_map c R θ)∥ ≤ C) : ∥∯ (x : fin n → ℂ) in T(c, R), f x∥ ≤ (2 * real.pi) ^ n * finset.univ.prod (λ (i : fin n), |R i|) * C
{α : Type u_1} {m : measurable_space α} (μ ν : measure_theory.measure α) : set (α → ennreal)
{α : Type u_1} {mα : measurable_space α} {μ : measure_theory.measure α} {f g : α → ennreal} (h_meas_f : measurable f) (h_meas_g : measurable g) (h_indep_fun : probability_theory.indep_fun f g μ) : ∫⁻ (a : α), (f * g) a ∂μ = ∫⁻ (a : α), f a ∂μ * ∫⁻ (a : α), g a ∂μ
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} [inhabited Λ] {σ : Type u_4} [inhabited σ] (M : Λ → turing.TM2.stmt Γ Λ σ) : turing.TM2to1.Λ' → turing.TM1.stmt turing.TM2to1.Γ' turing.TM2to1.Λ' σ
{α : Type u_1} {β : Type u_2} [topological_space β] [has_zero β] {m0 : measurable_space α} (f : α → β) (μ : measure_theory.measure α) : Prop
(σ K : Type u) [fintype K] [comm_ring K] : mv_polynomial.R σ K →ₗ[K] (σ → K) → K
{δ' : Type u_5} {π : δ' → Type u_7} [Π (x : δ'), measurable_space (π x)] [decidable_eq δ'] {l : list δ'} (hnd : l.nodup) (h : ∀ (i : δ'), i ∈ l) : (Π (i : δ'), π i) ≃ᵐ list.tprod π l
{α : Type u_1} {β : Type u_2} (f : α →. β ⊕ α) (b : β) {C : α → Sort u_3} {a : α} (h : b ∈ f.fix a) (hbase : Π (a_final : α), sum.inl b ∈ f a_final → C a_final) (hind : Π (a₀ a₁ : α), b ∈ f.fix a₁ → sum.inr a₁ ∈ f a₀ → C a₁ → C a₀) : C a
{R : Type u} [ring R] {I : ideal R} : I.jacobson = I ↔ ∃ (M : set (ideal R)), (∀ (J : ideal R), J ∈ M → J.is_maximal ∨ J = ⊤) ∧ I = has_Inf.Inf M
(V : Type u_1) (W : Type u_2) : (complete_bipartite_graph V W).coloring bool
{p : ℕ+} {K : Type u} {L : Type v} [field L] {ζ : L} [field K] [algebra K L] [ne_zero ↑↑p] {k : ℕ} (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) [hpri : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) (h : p ≠ 2) : ⇑(algebra.norm K) (ζ - 1) = ↑p
(R : Type u_5) {S : Type u_6} [comm_ring S] [is_domain S] {μ : S} {n : ℕ+} (hμ : is_primitive_root μ ↑n) [comm_ring R] [algebra R S] : (S ≃ₐ[R] S) →* (zmod ↑n)ˣ
{α : Type u_1} {ι : Type u_5} {m0 : measurable_space α} {μ ν : measure_theory.measure α} [encodable ι] {s : ι → set α} (hs : (⋃ (i : ι), s i) = set.univ) : (∀ (i : ι), μ.restrict (s i) = ν.restrict (s i)) → μ = ν
{A : Type u_2} {K : Type u_3} [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] [h : is_dedekind_domain A] (I : ideal A) (hI0 : I ≠ ⊥) : ↑I * (↑I)⁻¹ = 1
{S : Type u_2} {R : Type u_3} {A : Type u_4} {N : Type u_1} [semiring S] [add_comm_monoid R] [add_comm_monoid A] [add_comm_monoid N] [module S R] [module S A] [module S N] ⦃f g : unitization R A →ₗ[S] N⦄ (hl : ∀ (r : R), ⇑f (unitization.inl r) = ⇑g (unitization.inl r)) (hr : ∀ (a : A), ⇑f ↑a = ⇑g ↑a) : f = g
{C : Type u₁} (W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] [category_theory.enriched_category W C] (X : category_theory.forget_enrichment W C) : category_theory.forget_enrichment.hom_to W (𝟙 X) = category_theory.e_id W (category_theory.forget_enrichment.to W X)
{ι : Type u_1} [hnontriv : nontrivial ι] {G : Type u_4} [group G] {H : ι → Type u_5} [Π (i : ι), group (H i)] (f : Π (i : ι), H i →* G) (hcard : 3 ≤ cardinal.mk ι ∨ ∃ (i : ι), 3 ≤ cardinal.mk (H i)) {α : Type u_6} [mul_action G α] (X : ι → set α) (hXnonempty : ∀ (i : ι), (X i).nonempty) (hXdisj : pairwise (λ (i j : ι), disjoint (X i) (X j))) (hpp : pairwise (λ (i j : ι), ∀ (h : H i), h ≠ 1 → ⇑(f i) h • X j ⊆ X i)) : function.injective ⇑(⇑free_product.lift f)
{n : ℕ} {K : Type u_1} [field K] {μ : K} (h : is_primitive_root μ n) (hpos : 0 < n) [char_zero K] : polynomial.cyclotomic n ℤ = minpoly ℤ μ
{R : Type u} {σ : Type u_1} [comm_semiring R] (p : mv_polynomial σ R) : finset σ
{R : Type u} {σ : Type u_1} [comm_semiring R] {M : mv_polynomial σ R → Prop} (p : mv_polynomial σ R) (h_C : ∀ (a : R), M (⇑mv_polynomial.C a)) (h_add_weak : ∀ (a : σ →₀ ℕ) (b : R) (f : (σ →₀ ℕ) →₀ R), a ∉ f.support → b ≠ 0 → M f → M (⇑(mv_polynomial.monomial a) b + f)) : M p
{R : Type u} [comm_ring R] (I : ideal R) (ι : Type v) : module (R ⧸ I) ((ι → R) ⧸ I.pi ι)
{V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle ℝ P) {i₁ i₂ : fin 3} (h : i₁ ≠ i₂) : has_dist.dist t.orthocenter (⇑(euclidean_geometry.reflection (affine_span ℝ (t.points '' ↑{i₁, i₂}))) (affine.simplex.circumcenter t)) = affine.simplex.circumradius t
(𝕜 : Type u_1) {E : Type u_4} [normed_group E] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] (𝕜' : Type u_12) [normed_field 𝕜'] [normed_algebra 𝕜 𝕜'] [normed_space 𝕜' E] [is_scalar_tower 𝕜 𝕜' E] [nontrivial E] : ∥continuous_linear_map.lsmul 𝕜 𝕜'∥ = 1
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (f : E →L[𝕜] F) [complete_space F] (surj : function.surjective ⇑f) : ∃ (C : ℝ) (H : C ≥ 0), ∀ (y : F), ∃ (x : E), has_dist.dist (⇑f x) y ≤ 1 / 2 * ∥y∥ ∧ ∥x∥ ≤ C * ∥y∥
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) {p q : nnreal} (hpq : p < q) : ∃ (a b : set α), measurable_set a ∧ measurable_set b ∧ {x : α | v.lim_ratio ρ x < ↑p} ⊆ a ∧ {x : α | ↑q < v.lim_ratio ρ x} ⊆ b ∧ ⇑μ (a ∩ b) = 0
{α : Type u_1} {M : α → Type u_2} {u : ultrafilter α} {L : first_order.language} [Π (a : α), L.Structure (M a)] [∀ (a : α), nonempty (M a)] (φ : L.sentence) : ↑u.product M ⊨ φ ↔ ∀ᶠ (a : α) in ↑u, M a ⊨ φ
{A : Type u} [category_theory.category A] [category_theory.abelian A] {X Y Z : A} (f : X ⟶ Y) (g : Y ⟶ Z) (w : f ≫ g = 0) {W : A} (e : category_theory.limits.kernel g ⟶ W) (he : category_theory.limits.kernel.lift g f w ≫ e = 0) : homology f g w ⟶ W
{ι : Type u} {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {g : (ι → ℝ) → ℝ} (hg : ∀ (x : ι → ℝ), x ∈ ⇑box_integral.box.Icc I → 0 ≤ g x) (μ : measure_theory.measure (ι → ℝ)) [measure_theory.is_locally_finite_measure μ] : 0 ≤ box_integral.integral I l g μ.to_box_additive.to_smul
{α : Type u_1} {β : Type u_2} [metric_space α] [compact_space α] [metric_space β] (f : C(α, β)) (ε : ℝ) (h : 0 < ε) : ℝ
{p : ℕ} {g : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R} {f : Π ⦃R : Type u_1⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R → witt_vector p R} (hg : witt_vector.is_poly p g) (hf : witt_vector.is_poly₂ p f) : witt_vector.is_poly₂ p (λ (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g (f x y))
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (μ : R) (x : M) : Prop
{α : Type u_1} [metric_space α] [measurable_space α] [opens_measurable_space α] [proper_space α] {μ : measure_theory.measure α} [measure_theory.is_finite_measure_on_compacts μ] {s : set α} (hs : is_compact s) : filter.tendsto (λ (r : ℝ), ⇑μ (metric.cthickening r s)) (nhds 0) (nhds (⇑μ s))
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {x : E} {s : set E} {t : set F} {y : F} (hs : x ∈ closure s) : ⇑(linear_map.inr 𝕜 E F) '' tangent_cone_at 𝕜 t y ⊆ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
{ι : Type u_1} {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [fintype ι] {S : Type u_3} [comm_ring S] [is_domain S] [algebra R S] (b : basis ι R S) (I : ideal S) (hI : I ≠ ⊥) : ∃ (b' : basis ι R S) (a : ι → R) (ab' : basis ι R ↥I), ∀ (i : ι), ↑(⇑ab' i) = a i • ⇑b' i
{α : Type u_1} (E : Type u_2) {m : measurable_space α} [normed_group E] (p : ennreal) (μ : measure_theory.measure α . "volume_tac") : add_subgroup (α →ₘ[μ] E)
{n : ℕ} {F : typevec n → Type v} [mvfunctor F] {α : typevec n} (r : Π {i : fin2 n}, α i → α i → Prop) (x y : F α) : Prop
{C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C ⥤ D} (hu : category_theory.cover_lifting J K G) (ℱ : category_theory.Sheaf J A) {X : A} {U : D} {S : category_theory.sieve U} (hS : S ∈ ⇑K U) {x : category_theory.presieve.family_of_elements ((category_theory.Ran G.op).obj ℱ.val ⋙ category_theory.coyoneda.obj (opposite.op X)) S.arrows} (hx : x.compatible) {V : D} (f : V ⟶ U) (y : X ⟶ ((category_theory.Ran G.op).obj ℱ.val).obj (opposite.op V)) (W : category_theory.structured_arrow (opposite.op V) G.op) (H : ∀ {V' : C} {fV : G.obj V' ⟶ V} (hV : S.arrows (fV ≫ f)), y ≫ ((category_theory.Ran G.op).obj ℱ.val).map fV.op = x (fV ≫ f) hV) : y ≫ category_theory.limits.limit.π (category_theory.Ran.diagram G.op ℱ.val (opposite.op V)) W = (category_theory.Ran_is_sheaf_of_cover_lifting.glued_limit_cone hu ℱ hS hx).π.app ((category_theory.structured_arrow.map f.op).obj W)
{𝕆 : Type u_1} {ℙ : Type u_2} {α : Type u_3} [preorder 𝕆] [preorder «ℙ»] [preorder α] [grade_min_order 𝕆 α] (f : 𝕆 → «ℙ») (hf : strict_mono f) (hcovby : ∀ (a b : 𝕆), a ⋖ b → f a ⋖ f b) (hmin : ∀ (a : 𝕆), is_min a → is_min (f a)) : grade_min_order «ℙ» α
{α : Type u_1} {ι : Type u_5} {m : measurable_space α} {μ : measure_theory.measure α} [semilattice_sup ι] [encodable ι] {s : ι → set α} (hm : monotone s) : filter.tendsto (⇑μ ∘ s) filter.at_top (nhds (⇑μ (⋃ (n : ι), s n)))
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] (M : submodule R A) {C : Π (n : ℕ) (x : A), x ∈ M ^ n → Prop} (hr : ∀ (r : R), C 0 (⇑(algebra_map R A) r) _) (hadd : ∀ (x y : A) (i : ℕ) (hx : x ∈ M ^ i) (hy : y ∈ M ^ i), C i x hx → C i y hy → C i (x + y) _) (hmul : ∀ (i : ℕ) (x : A) (hx : x ∈ M ^ i), C i x hx → ∀ (m : A) (H : m ∈ M), C i.succ (x * m) _) {x : A} {n : ℕ} (hx : x ∈ M ^ n) : C n x hx
{p : ℕ+} {K : Type u} {L : Type v} [field L] {ζ : L} [field K] [algebra K L] [ne_zero ↑↑p] {k s : ℕ} (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) [hpri : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) (hs : s ≤ k) (htwo : p ^ (k - s + 1) ≠ 2) : ⇑(algebra.norm K) (ζ ^ ↑p ^ s - 1) = ↑p ^ ↑p ^ s
{I : Type w₁} (C : I → Type u₁) [Π (i : I), category_theory.category (C i)] {J : Type w₂} (g : J → I) : (Σ (j : J), C (g j)) ⥤ Σ (i : I), C i
(n : with_top ℕ) {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] (e : local_homeomorph M H) : e.symm.trans e ∈ cont_diff_groupoid n I
{β : Π (v : typevec 0) (v' : typevec 0), v.arrow v' → Sort u_3} (f : β fin2.elim0 fin2.elim0 typevec.nil_fun) (v : typevec 0) (v' : typevec 0) (fs : v.arrow v') : β v v' fs
{V : Type u} [fintype V] [decidable_eq V] {μ : ℕ} : ⊤.is_SRG_with (fintype.card V) (fintype.card V - 1) (fintype.card V - 2) μ
{ι : Type u} {γ : Type w} {β : ι → Type v} [dec : decidable_eq ι] [Π (i : ι), add_zero_class (β i)] [add_comm_monoid γ] (φ : Π (i : ι), β i →+ γ) : (Π₀ (i : ι), β i) →+ γ
{α : Type u_2} [measurable_space α] {f : α → α} {s : set α} {μ : measure_theory.measure α} (hf : measure_theory.conservative f μ) (hs : measurable_set s) (h0 : ⇑μ s ≠ 0) : ∃ᵐ (x : α) ∂μ, x ∈ s ∧ ∃ᶠ (n : ℕ) in filter.at_top, f^[n] x ∈ s
{α : Type u_1} {E : Type u_3} [measurable_space α] [normed_group E] (f : α → E) (s : set α) (μ : measure_theory.measure α . "volume_tac") : Prop
{M : Type u_1} [has_mul M] (S : set (con M)) : ⇑(has_Inf.Inf S) = has_Inf.Inf (coe_fn '' S)
{G : Type u_1} [measurable_space G] [add_group G] [topological_space G] (μ : measure_theory.measure G) [μ.is_add_haar_measure] [borel_space G] [topological_add_group G] {H : Type u_2} [add_group H] [topological_space H] [measurable_space H] [borel_space H] [t2_space H] [topological_add_group H] (f : G ≃+ H) (hf : continuous ⇑f) (hfsymm : continuous ⇑(f.symm)) : (measure_theory.measure.map ⇑f μ).is_add_haar_measure
{σ : Type u_1} {R : Type u_2} {S : Type u_3} [comm_ring R] [comm_ring S] (f : R →+* S) [is_local_ring_hom f] : is_local_ring_hom (mv_power_series.map σ f)
{R : Type u_1} {S : Type u_2} [comm_ring R] [strong_rank_condition R] [ring S] [is_domain S] [algebra R S] {n : Type u_3} {m : Type u_4} [fintype n] [fintype m] (b : basis n R S) {I : ideal S} (hI : I ≠ ⊥) (c : basis m R ↥I) : fintype.card m = fintype.card n
{X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra ℝ C(X, ℝ)) (w : A.separates_points) (f : X → ℝ) (c : continuous f) (ε : ℝ) (pos : 0 < ε) : ∃ (g : ↥A), ∀ (x : X), ∥⇑g x - f x∥ < ε
(n : name) (offset : option ℕ := option.none) : tactic expr
{f g : ℝ → ℝ} {a b : ℝ} {μ : measure_theory.measure ℝ} (hab : a ≤ b) (hfi : interval_integrable f μ a b) (hgi : interval_integrable g μ a b) (hle : f ≤ᵐ[μ.restrict (set.Ioc a b)] g) (hlt : ⇑(μ.restrict (set.Ioc a b)) {x : ℝ | f x < g x} ≠ 0) : ∫ (x : ℝ) in a..b, f x ∂μ < ∫ (x : ℝ) in a..b, g x ∂μ
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [nonempty J] (s : category_theory.limits.trident f) {W : C} {k l : W ⟶ s.X} (h : k ≫ s.ι = l ≫ s.ι) (j : category_theory.limits.walking_parallel_family J) : k ≫ s.π.app j = l ≫ s.π.app j
(ι : Type u_1) (X : Type u_2) [topological_space X] (s : set X := set.univ) : Type (max u_1 u_2)
{R : Type u} [ring R] {ι : Type v} [dec_ι : decidable_eq ι] [preorder ι] {G : ι → Type w} [Π (i : ι), add_comm_group (G i)] [Π (i : ι), module R (G i)] {f : Π (i j : ι), i ≤ j → (G i →ₗ[R] G j)} [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] [is_directed ι has_le.le] {i : ι} {x : G i} (H : ⇑(module.direct_limit.of R ι G f i) x = 0) : ∃ (j : ι) (hij : i ≤ j), ⇑(f i j hij) x = 0
{E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (f : E →L[ℝ] E) (s : set E) : ⇑μ (⇑f '' s) = ennreal.of_real |⇑linear_map.det ↑f| * ⇑μ s
{α : Type u_2} {_x : measurable_space α} (μ : measure_theory.measure α) : measure_theory.measure (measure_theory.null_measurable_space α μ)
{V : Type u} [category_theory.category V] [category_theory.preadditive V] {P Q : chain_complex V ℕ} (e : P ⟶ Q) (zero : P.X 0 ⟶ Q.X 1) (comm_zero : e.f 0 = zero ≫ Q.d 1 0) (one : P.X 1 ⟶ Q.X 2) (comm_one : e.f 1 = P.d 1 0 ≫ zero + one ≫ Q.d 2 1) (succ : Π (n : ℕ) (p : Σ' (f : P.X n ⟶ Q.X (n + 1)) (f' : P.X (n + 1) ⟶ Q.X (n + 2)), e.f (n + 1) = P.d (n + 1) n ≫ f + f' ≫ Q.d (n + 2) (n + 1)), Σ' (f'' : P.X (n + 2) ⟶ Q.X (n + 3)), e.f (n + 2) = P.d (n + 2) (n + 1) ≫ p.snd.fst + f'' ≫ Q.d (n + 3) (n + 2)) (n : ℕ) : Σ' (f : P.X n ⟶ Q.X (n + 1)) (f' : P.X (n + 1) ⟶ Q.X (n + 2)), e.f (n + 1) = P.d (n + 1) n ≫ f + f' ≫ Q.d (n + 2) (n + 1)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') (n : with_top ℕ) : (cont_diff_groupoid ⊤ I).local_invariant_prop (cont_diff_groupoid ⊤ I') (cont_diff_within_at_prop I I' n)
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ D] [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [Π (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)ᵒᵖ (category_theory.forget D)] (P : Cᵒᵖ ⥤ D) (hsep : ∀ (X : C) (S : J.cover X) (x y : ↥(P.obj (opposite.op X))), (∀ (I : S.arrow), ⇑(P.map I.f.op) x = ⇑(P.map I.f.op) y) → x = y) (X : C) (S : J.cover X) (s : category_theory.meq (J.plus_obj P) S) (T : Π (I : S.arrow), J.cover I.Y) (t : Π (I : S.arrow), category_theory.meq P (T I)) (ht : ∀ (I : S.arrow), ⇑s I = category_theory.grothendieck_topology.plus.mk (t I)) : category_theory.meq P (S.bind T)
{ι : Type u_10} {R : Type u_11} {R₂ : Type u_12} {M : Type u_13} {M₂ : Type u_14} [semiring R] [semiring R₂] [add_comm_monoid M] [module R M] [add_comm_monoid M₂] [module R₂ M₂] [topological_space M] [topological_space M₂] {σ : R →+* R₂} {f : ι → M} (φ : M →SL[σ] M₂) {x : M} (hf : has_sum f x) : has_sum (λ (b : ι), ⇑φ (f b)) (⇑φ x)
{α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [opens_measurable_space α] [t2_space α] [μ.regular] ⦃A : set α⦄ (hA : measurable_set A) (h'A : ⇑μ A ≠ ⊤) {ε : ennreal} (hε : ε ≠ 0) : ∃ (K : set α) (H : K ⊆ A), is_compact K ∧ ⇑μ (A  K) < ε
{β : Type u_2} [topological_space β] {κ : Type u_5} {f : κ → β} (hf : dense_range f) {s : set β} (hs : is_open s) : s ⊆ closure (f '' (f ⁻¹' s))
{K : Type u_1} {σ : Type u_2} [fintype K] [fintype σ] [comm_ring K] (a : σ → K) : mv_polynomial σ K
{I : Type v₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {J : Type v₁} [category_theory.small_category J] {F : J ⥤ Π (i : I), C i} (c : category_theory.limits.cone F) (i : I) : category_theory.limits.cone (F ⋙ category_theory.pi.eval C i)
{R : Type u_1} (ι : Type u_4) [linear_ordered_field R] [fintype ι] : ⇑(convex_hull R) (set.range (λ (i j : ι), ite (i = j) 1 0)) = std_simplex R ι
{α : Type u_1} {ι : Type u_3} {M : Type u_5} [comm_monoid M] {f : α → M} {I : set ι} {t : ι → set α} (h : I.pairwise_disjoint t) (hI : I.finite) (ht : ∀ (i : ι), i ∈ I → (t i).finite) : finprod (λ (a : α), finprod (λ (H : a ∈ ⋃ (x : ι) (H : x ∈ I), t x), f a)) = finprod (λ (i : ι), finprod (λ (H : i ∈ I), finprod (λ (j : α), finprod (λ (H : j ∈ t i), f j))))
{M : Type u_3} {N : Type u_4} [has_add M] [has_add N] ⦃f g : add_hom M N⦄ (h : ⇑f = ⇑g) : f = g
{G : Type u_4} [measurable_space G] {μ : measure_theory.measure G} [add_group G] [has_measurable_add G] [μ.is_add_left_invariant] (f : G → ennreal) (g : G) : ∫⁻ (x : G), f (g + x) ∂μ = ∫⁻ (x : G), f x ∂μ
{E : Type u_1} [normed_group E] [normed_space ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hd : diff_cont_on_cl ℂ f (set.Ioi 0 ×ℂ set.Ioi 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Ioi 0 ×ℂ set.Ioi 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : ∀ (x : ℝ), 0 ≤ x → ∥f ↑x∥ ≤ C) (him : ∀ (x : ℝ), 0 ≤ x → ∥f (↑x * complex.I)∥ ≤ C) (hz_re : 0 ≤ z.re) (hz_im : 0 ≤ z.im) : ∥f z∥ ≤ C
{Fq : Type u_1} [fintype Fq] [field Fq] (n : ℕ) {ε : ℝ} (hε : 0 < ε) {b : polynomial Fq} (hb : b ≠ 0) (A : fin n → polynomial Fq) : ∃ (t : fin n → fin (fintype.card Fq ^ ⌈-real.log ε / real.log ↑(fintype.card Fq)⌉₊)), ∀ (i₀ i₁ : fin n), t i₀ = t i₁ ↔ ↑(⇑polynomial.card_pow_degree (A i₁ % b - A i₀ % b)) < ⇑polynomial.card_pow_degree b • ε
{R : Type u} {ι : Type v} [comm_ring R] {L : Type w} [lie_ring L] [lie_algebra R L] (I : ι → lie_ideal R L) : lie_ring (direct_sum ι (λ (i : ι), ↥(I i)))
(𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] {s : set E} (s_nhd : s ∈ nhds 0) : is_closed (coe_fn '' weak_dual.polar 𝕜 s)
(σ : Type u_1) (R : Type u_2) [comm_semiring R] : Type (max u_1 u_2)
{α : Type u_1} {G : Type u_8} [normed_group G] [normed_space ℝ G] {m m0 : measurable_space α} (hm : m ≤ m0) (μ : measure_theory.measure α) [measure_theory.sigma_finite (μ.trim hm)] (s : set α) : G →L[ℝ] ↥(measure_theory.Lp G 1 μ)
{R : Type u} [ring R] {ι : Type v} [preorder ι] (G : ι → Type v) [Π (i : ι), add_comm_group (G i)] [Π (i : ι), module R (G i)] (f : Π (i j : ι), i ≤ j → (G i →ₗ[R] G j)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] : ι ⥤ Module R
(p : pexpr) (m : tactic.transparency := tactic.transparency.reducible) : tactic (list expr)
{E : Type u_2} [add_comm_group E] [module ℝ E] [topological_space E] [topological_add_group E] [has_continuous_smul ℝ E] {s : set E} (hs : convex ℝ s) {x : E} (hx : x ∈ interior s) (t : ℝ) (ht : 1 < t) : s ⊆ interior (⇑(affine_map.homothety x t) '' s)
{G : Type w} [topological_space G] (μ : measure_theory.content G) : measure_theory.outer_measure G
{σ : Type u_1} (f : σ → option σ) (m₁ m₂ : ℕ) (a b : σ) (c : option σ) (h₁ : turing.evals_to_in_time f a ↑b m₁) (h₂ : turing.evals_to_in_time f b c m₂) : turing.evals_to_in_time f a c (m₂ + m₁)
{α : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [add_zero_class N] ⦃f g : (α →₀ M) →+ N⦄ (H : ∀ (x : α), f.comp (finsupp.single_add_hom x) = g.comp (finsupp.single_add_hom x)) : f = g
{R : Type u₁} [comm_semiring R] (p : ℕ) [hp : fact (nat.prime p)] [char_p R p] {S : Type u₂} [comm_semiring S] [char_p S p] (φ : R →+* S) : ring.perfection R p →+* ring.perfection S p
{α : Type u_1} [decidable_eq α] [fintype α] (f : equiv.perm α) (comm : (∀ (g : equiv.perm α), g ∈ f.cycle_factors_finset → ∀ (h : equiv.perm α), h ∈ f.cycle_factors_finset → commute (id g) (id h)) := _) : f.cycle_factors_finset.noncomm_prod id comm = f
(t : expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic (list subsingleton_info)
{R : Type u} {L : Type v} {L' : Type w₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] {f : L →ₗ⁅R⁆ L'} {I : lie_ideal R L} : I ≤ lie_ideal.comap f (lie_ideal.map f I)
{F : Type u_3} [inner_product_space ℝ F] (x y : F) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ has_inner.inner x y = 0
{σ : Type u} : σ → σ → Prop
{A : Type u_2} [comm_ring A] [is_domain A] [is_dedekind_domain A] (hNF : ¬is_field A) {I M : ideal A} (hI0 : I ≠ ⊥) (hIM : I ≤ M) [hM : M.is_maximal] : ∃ (Z : multiset (prime_spectrum A)), (M ::ₘ multiset.map prime_spectrum.as_ideal Z).prod ≤ I ∧ ¬(multiset.map prime_spectrum.as_ideal Z).prod ≤ I
(α : Type u_1) (σ : Type u_2) [partial_order α] : Type (max u_1 u_2)
{G : Type u} [add_group G] (N : add_subgroup G) [nN : N.normal] {H : Type v} [add_group H] ⦃f g : G ⧸ N →+ H⦄ (h : f.comp (quotient_add_group.mk' N) = g.comp (quotient_add_group.mk' N)) : f = g
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_4} [normed_group F] [normed_space 𝕜 F] {H : Type u_5} [topological_space H] {G : Type u_7} [topological_space G] {I : model_with_corners 𝕜 E H} {J : model_with_corners 𝕜 F G} {M : Type u_8} [topological_space M] [charted_space H M] {N : Type u_10} [topological_space N] [charted_space G N] {n : with_top ℕ} (h : diffeomorph I J M N n) : diffeomorph J I N M n
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {a b : ℝ} {f f' : ℝ → ℝ} {g : ℝ → E} (hf : continuous_on f (set.interval a b)) (hff' : ∀ (x : ℝ), x ∈ set.Ioo (linear_order.min a b) (linear_order.max a b) → has_deriv_within_at f (f' x) (set.Ioi x) x) (hf' : continuous_on f' (set.interval a b)) (hg : continuous_on g (f '' set.interval a b)) : ∫ (x : ℝ) in a..b, f' x • (g ∘ f) x = ∫ (u : ℝ) in f a..f b, g u
(R : Type u) {M : Type v} {ι : Type x} [semiring R] (φ : ι → Type i) [Π (i : ι), add_comm_monoid (φ i)] [Π (i : ι), module R (φ i)] (S : Type u_1) [add_comm_monoid M] [module R M] [fintype ι] [decidable_eq ι] [semiring S] [module S M] [smul_comm_class R S M] : (Π (i : ι), φ i →ₗ[R] M) ≃ₗ[S] (Π (i : ι), φ i) →ₗ[R] M
{ι : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [semiring A] [algebra R A] (𝒜 : ι → submodule R A) [decidable_eq ι] [add_monoid ι] [graded_algebra 𝒜] (I : ideal A) : homogeneous_ideal 𝒜
{G : Type w} [topological_space G] (μ : measure_theory.content G) [t2_space G] [S : measurable_space G] [borel_space G] [locally_compact_space G] : μ.measure.regular
{M : Type u_3} {N : Type u_4} [has_mul M] [has_mul N] ⦃f g : M →ₙ* N⦄ (h : ⇑f = ⇑g) : f = g
{ι : Type u_1} {σ : Type u_2} {R : Type u_4} [decidable_eq ι] [add_monoid ι] [semiring R] [set_like σ R] [add_submonoid_class σ R] (A : ι → σ) [set_like.graded_monoid A] : direct_sum ι (λ (i : ι), ↥(A i)) →+* R
{α : Type u} {β : Type v} (s : set α) {f : α → β} {g : β → option α} (I : function.is_partial_inv f g) [fintype ↥(f '' s)] : fintype ↥s
{E : Type u} [normed_group E] [normed_space ℝ E] [complete_space E] {n : ℕ} (I : box_integral.box (fin (n + 1))) (f : (fin (n + 1) → ℝ) → fin (n + 1) → E) (f' : (fin (n + 1) → ℝ) → ((fin (n + 1) → ℝ) →L[ℝ] fin (n + 1) → E)) (s : set (fin (n + 1) → ℝ)) (hs : s.countable) (Hc : continuous_on f (⇑box_integral.box.Icc I)) (Hd : ∀ (x : fin (n + 1) → ℝ), x ∈ ⇑box_integral.box.Icc I  s → has_fderiv_within_at f (f' x) (⇑box_integral.box.Icc I) x) (Hi : measure_theory.integrable_on (λ (x : fin (n + 1) → ℝ), finset.univ.sum (λ (i : fin (n + 1)), ⇑(f' x) (pi.single i 1) i)) (⇑box_integral.box.Icc I) measure_theory.measure_space.volume) : ∫ (x : fin (n + 1) → ℝ) in ⇑box_integral.box.Icc I, finset.univ.sum (λ (i : fin (n + 1)), ⇑(f' x) (pi.single i 1) i) = finset.univ.sum (λ (i : fin (n + 1)), (∫ (x : fin n → ℝ) in ⇑box_integral.box.Icc (I.face i), f (i.insert_nth (I.upper i) x) i) - ∫ (x : fin n → ℝ) in ⇑box_integral.box.Icc (I.face i), f (i.insert_nth (I.lower i) x) i)
(ns : name) (s : tactic.local_cache.internal.cache_scope := tactic.local_cache.cache_scope.block_local) : tactic bool
{I : Type u} (f : I → Type v) [decidable_eq I] [Π (i : I), has_zero (f i)] (i : I) : zero_hom (f i) (Π (i : I), f i)
{ι : Type u_1} {I : box_integral.box ι} [fintype ι] (π : box_integral.prepartition I) : ∃ (π' : box_integral.prepartition I), π'.Union = ↑I  π.Union
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.prepartition I) : set (ι → ℝ)
{α : Type u_1} [measurable_space α] {μ : measure_theory.outer_measure α} {s : set α} (hs : measurable_set s) : (⇑(measure_theory.outer_measure.restrict s) μ).trim = ⇑(measure_theory.outer_measure.restrict s) μ.trim
{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (s : set M) : add_subsemigroup.map f (add_subsemigroup.closure s) = add_subsemigroup.closure (⇑f '' s)
{ι : Type u_1} [fintype ι] {f : (ι → ℝ) →ₗ[ℝ] ι → ℝ} (hf : ⇑linear_map.det f ≠ 0) : measure_theory.measure.map ⇑f measure_theory.measure_space.volume = ennreal.of_real |(⇑linear_map.det f)⁻¹| • measure_theory.measure_space.volume
{V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (h : ∥x∥ = ∥y∥) : x = y ↔ hb.oangle x y = 0
{α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} {s t : set α} : μ.restrict (s ∪ t) = ν.restrict (s ∪ t) ↔ μ.restrict s = ν.restrict s ∧ μ.restrict t = ν.restrict t
{α : Type u_1} [topological_space α] [measure_theory.measure_space α] [borel_space α] {𝕜 : Type u_2} [is_R_or_C 𝕜] (μ : measure_theory.measure α) [measure_theory.is_finite_measure μ] (f g : bounded_continuous_function α 𝕜) : has_inner.inner (⇑(bounded_continuous_function.to_Lp 2 μ 𝕜) f) (⇑(bounded_continuous_function.to_Lp 2 μ 𝕜) g) = ∫ (x : α), ⇑(star_ring_end 𝕜) (⇑f x) * ⇑g x ∂μ
{n : ℕ+} {K : Type u} {L : Type v} [field L] {ζ : L} (hζ : is_primitive_root ζ ↑n) [field K] [algebra K L] [ne_zero ↑↑n] (hn : is_prime_pow ↑n) [is_cyclotomic_extension {n} K L] (hirr : irreducible (polynomial.cyclotomic ↑n K)) (h : n ≠ 2) : ⇑(algebra.norm K) (ζ - 1) = ↑(↑n.min_fac)
{I : Type u} {f : I → Type v₁} {g : I → Type v₂} (f' : Π (i : I), f i) (g' : Π (i : I), g i) (i : I) : f i × g i
{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} (hf : antitone f) {a : α} {s : set α} : is_greatest s a → is_least (f '' s) (f a)
{σ : Type u_1} {R : Type u_4} [comm_semiring R] (p : mv_polynomial σ R) : ∃ (s : finset σ) (q : mv_polynomial {x // x ∈ s} R), p = ⇑(mv_polynomial.rename coe) q
{ι : Type u_2} {π : ι → Type u_1} [fintype ι] [Π (i : ι), semi_normed_group (π i)] : semi_normed_group (Π (i : ι), π i)
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} [measure_theory.sigma_finite μ] {s : set (α × β)} (hs : measurable_set s) : measurable (λ (y : β), ⇑μ ((λ (x : α), (x, y)) ⁻¹' s))
{E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (R : ℝ) (hs : s ⊆ metric.closed_ball 0 R) (ε : nnreal) (εpos : 0 < ε) (h'f' : ∀ (x : E), x ∈ s → (f' x).det = 0) : ⇑μ (f '' s) ≤ ↑ε * ⇑μ (metric.closed_ball 0 R)
{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {t : set α} (Hf : antitone_on f t) {a : α} : is_least t a → is_greatest (f '' t) (f a)
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {f : filter α} : μ.finite_at_filter (f ⊓ μ.ae) → μ.finite_at_filter f
{Γ : Type u_1} [inhabited Γ] {Γ' : Type u_2} [inhabited Γ'] {Λ : Type u_3} [inhabited Λ] {Λ' : Type u_4} [inhabited Λ'] (M : turing.TM0.machine Γ Λ) (f₁ : turing.pointed_map Γ Γ') (f₂ : turing.pointed_map Γ' Γ) (g₁ : Λ → Λ') (g₂ : Λ' → Λ) : turing.TM0.machine Γ' Λ'
(q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) (cfg : tactic.rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}) : tactic unit
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R →+* S) (g : S →+* R) (I : ideal S) (h : function.left_inverse ⇑g ⇑f) : ideal.comap f I ≤ ideal.map g I
(R₁ : Type u_3) {A : Type u_5} [comm_semiring R₁] [comm_ring A] [algebra R₁ A] {I : ideal A} : algebra R₁ (A ⧸ I)
{V : Type u_1} [inner_product_space ℝ V] (x y : V) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ inner_product_geometry.angle x y = real.pi / 2
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {H : Type u_4} [normed_group H] [normed_space 𝕜 H] {F : H → α → E} {F' : α → (H →L[𝕜] E)} {x₀ : H} {bound : α → ℝ} {ε : ℝ} (ε_pos : 0 < ε) (hF_meas : ∀ᶠ (x : H) in nhds x₀, measure_theory.ae_strongly_measurable (F x) μ) (hF_int : measure_theory.integrable (F x₀) μ) (hF'_meas : measure_theory.ae_strongly_measurable F' μ) (h_lip : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : H), F x a) (metric.ball x₀ ε)) (bound_integrable : measure_theory.integrable bound μ) (h_diff : ∀ᵐ (a : α) ∂μ, has_fderiv_at (λ (x : H), F x a) (F' a) x₀) : measure_theory.integrable F' μ ∧ has_fderiv_at (λ (x : H), ∫ (a : α), F x a ∂μ) (∫ (a : α), F' a ∂μ) x₀
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (μ : R) (k : ℕ) (x : M) : Prop
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ⟶ Y} {W : C} (g : W ⟶ X) (eq : g ≫ f = 0) (lift : Π {W' : C} (g' : W' ⟶ X), g' ≫ f = 0 → (W' ⟶ W)) (fac : ∀ {W' : C} (g' : W' ⟶ X) (eq' : g' ≫ f = 0), lift g' eq' ≫ g = g') (uniq : ∀ {W' : C} (g' : W' ⟶ X) (eq' : g' ≫ f = 0) (m : W' ⟶ W), m ≫ g = g' → m = lift g' eq') : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_ι g eq)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} (f : Z ⟶ Y) (I : category_theory.InjectiveResolution Y) (J : category_theory.InjectiveResolution Z) : J.cocomplex.X 0 ⟶ I.cocomplex.X 0
(B : Type u₁) [quiver B] [Π (a b : B), quiver (a ⟶ b)] : category_theory.prelax_functor B B
{I : Type u} [decidable_eq I] {β : Type u_1} [has_zero β] (i : I) (x : β) (i' : I) : pi.single i x i' = pi.single i' x i
{C : Type u} [category_theory.category C] {I : category_theory.limits.multicospan_index C} [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] (K : category_theory.limits.multifork I) : category_theory.limits.fork I.fst_pi_map I.snd_pi_map
{R : Type u} {M₂ : Type v₂} {M₃ : Type v₃} [semiring R] [add_comm_monoid M₂] [add_comm_monoid M₃] [module R M₂] [module R M₃] {ι₁ : Type u_1} {ι₂ : Type u_2} [decidable_eq ι₁] [decidable_eq ι₂] (σ : ι₁ ≃ ι₂) (m : multilinear_map R (λ (i : ι₁), M₂) M₃) : multilinear_map R (λ (i : ι₂), M₂) M₃
{I : Type w₁} (C : I → Type u₁) [Π (i : I), category_theory.category (C i)] {J : Type w₂} (g : J → I) (j : J) : category_theory.sigma.incl j ⋙ category_theory.sigma.map C g ≅ category_theory.sigma.incl (g j)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] (I : model_with_corners 𝕜 E H) {G : Type u_4} [has_mul G] [topological_space G] [charted_space H G] [has_smooth_mul I G] : has_continuous_mul G
(p : pos) (w : widget.component tactic_state empty) (text : string := "(widget)") : tactic unit
{α : Type u_1} {E : Type u_2} {ι : Type u_3} [preorder ι] {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] (f : ι → α → E) (ℱ : measure_theory.filtration ι m0) (μ : measure_theory.measure α) : Prop
{α : Type u_3} {f : filter α} {s : ℕ → set α} (hs : f.has_antitone_basis s) {r : ℕ → ℕ → Prop} (hr : ∀ (m : ℕ), ∀ᶠ (n : ℕ) in filter.at_top, r m n) : ∃ (φ : ℕ → ℕ), strict_mono φ ∧ (∀ ⦃m n : ℕ⦄, m < n → r (φ m) (φ n)) ∧ f.has_antitone_basis (s ∘ φ)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : M → M') (s : set M) : Prop
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] {ε : ennreal} (ε0 : ε ≠ 0) : ∃ (g : α → nnreal), (∀ (x : α), 0 < g x) ∧ measurable g ∧ ∫⁻ (x : α), ↑(g x) ∂μ < ε
{σ : Type u_1} (R : Type u_2) {A : Type u_3} [comm_semiring R] [add_comm_monoid A] [module R A] [module (mv_polynomial σ R) A] (f : σ → A) : mv_polynomial σ R →ₗ[R] A
{R : Type u_1} [normed_ring R] [complete_space R] (x : Rˣ) (y : R) (h : ∥y - ↑x∥ < ∥↑x⁻¹∥⁻¹) : Rˣ
{R : Type u} [comm_ring R] (I J : ideal R) : (double_quot.quot_quot_mk I J).ker = I ⊔ J
{ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (i : ι) (s : set M) : smooth_partition_of_unity ι I M s
{𝕜 : Type u_1} [normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {c : 𝕜} (hc : 1 < ∥c∥) {R : ℝ} (hR : ∥c∥ < R) {F : subspace 𝕜 E} (hFc : is_closed ↑F) (hF : ∃ (x : E), x ∉ F) : ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥
{α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) : function.left_inverse (measure_theory.Lp_trim_to_Lp_meas_subgroup F p μ hm) (measure_theory.Lp_meas_subgroup_to_Lp_trim F p μ hm)
{α : Type u_1} {E : Type u_4} {𝕜 : Type u_11} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [complete_space E] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) (f : ↥(measure_theory.Lp E 2 μ)) (c : E) : ⇑(⇑(measure_theory.condexp_L2 𝕜 hm) (measure_theory.mem_ℒp.to_Lp (λ (a : α), has_inner.inner c (⇑f a)) _)) =ᵐ[μ] λ (a : α), has_inner.inner c (⇑(⇑(measure_theory.condexp_L2 𝕜 hm) f) a)
{C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : Top} (f : X ⟶ Y) (ℱ : Top.presheaf C Y) (U : topological_space.opens ↥X) (H : is_open (⇑f '' ↑U)) : (Top.presheaf.pullback_obj f ℱ).obj (opposite.op U) ≅ ℱ.obj (opposite.op ⟨⇑f '' ↑U, H⟩)
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : multilinear_map 𝕜 E G) {C : ℝ} (hC : 0 ≤ C) (H : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) (m₁ m₂ : Π (i : ι), E i) : ∥⇑f m₁ - ⇑f m₂∥ ≤ C * ↑(fintype.card ι) * linear_order.max ∥m₁∥ ∥m₂∥ ^ (fintype.card ι - 1) * ∥m₁ - m₂∥
{N : Type u_2} {α : Type u_3} [preorder α] [preorder N] {f : N → α} {μ : N → N → N} [covariant_class N N (function.swap μ) has_le.le] (hf : monotone f) (m : N) : monotone (λ (n : N), f (μ n m))
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} {P : C} (π : Y ⟶ P) (w : f ≫ π = g ≫ π) : category_theory.limits.cofork f g
{ι : Type u_1} [decidable_eq ι] {R : Type u_4} [comm_semiring R] {s : ι → Type u_7} [Π (i : ι), add_comm_monoid (s i)] [Π (i : ι), module R (s i)] {F : Type u_10} [add_comm_monoid F] (φ : (R × Π (i : ι), s i) → F) (C0 : ∀ (r : R) (f : Π (i : ι), s i) (i : ι), f i = 0 → φ (r, f) = 0) (C0' : ∀ (f : Π (i : ι), s i), φ (0, f) = 0) (C_add : ∀ (r : R) (f : Π (i : ι), s i) (i : ι) (m₁ m₂ : s i), φ (r, function.update f i m₁) + φ (r, function.update f i m₂) = φ (r, function.update f i (m₁ + m₂))) (C_add_scalar : ∀ (r r' : R) (f : Π (i : ι), s i), φ (r, f) + φ (r', f) = φ (r + r', f)) (C_smul : ∀ (r : R) (f : Π (i : ι), s i) (i : ι) (r' : R), φ (r, function.update f i (r' • f i)) = φ (r' * r, f)) : pi_tensor_product R (λ (i : ι), s i) →+ F
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X ⟶ W) (g : Y ⟶ W) (i : W ⟶ Z) [category_theory.mono i] [category_theory.limits.has_pullback f g] : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk category_theory.limits.pullback.fst category_theory.limits.pullback.snd _)
{F : Type u_3} [inner_product_space ℝ F] {x y : F} (hx : ∥x∥ = 1) (hy : ∥y∥ = 1) : has_inner.inner x y < 1 ↔ x ≠ y
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {f : α → E} [measure_theory.is_finite_measure μ] (hfi : measure_theory.integrable f μ) : f =ᵐ[μ] function.const α (⨍ (x : α), f x ∂μ) ∨ ∃ (t : set α), measurable_set t ∧ ⇑μ t ≠ 0 ∧ ⇑μ tᶜ ≠ 0 ∧ ⨍ (x : α) in t, f x ∂μ ≠ ⨍ (x : α) in tᶜ, f x ∂μ
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : cont_mdiff_map I I' M M' ⊤} {x : M} {y : M'} (h : ⇑f x = y) : point_derivation I x →ₗ[𝕜] point_derivation I' y
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] {σ : Type u_3} [inhabited σ] (n : ℕ) : (vector bool n → turing.TM1.stmt bool turing.TM1to1.Λ' σ) → turing.TM1.stmt bool turing.TM1to1.Λ' σ
{G : Type u_1} [measurable_space G] [has_mul G] [has_measurable_mul G] (μ : measure_theory.measure G) : (∀ (g : G) (A : set G), measurable_set A → ⇑μ ((λ (h : G), h * g) ⁻¹' A) = ⇑μ A) ↔ μ.is_mul_right_invariant
{α : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {m : measurable_space α} {μ : measure_theory.measure α} [complete_space F] {T : set α → (E →L[ℝ] F)} {C : ℝ} (hT : measure_theory.dominated_fin_meas_additive μ T C) (f : ↥(measure_theory.Lp E 1 μ)) {ι : Type u_4} (fs : ι → ↥(measure_theory.Lp E 1 μ)) {l : filter ι} (hfs : filter.tendsto fs l (nhds f)) : filter.tendsto (λ (i : ι), ⇑(measure_theory.L1.set_to_L1 hT) (fs i)) l (nhds (⇑(measure_theory.L1.set_to_L1 hT) f))
{α : Type u_1} {E : Type u_4} [measurable_space α] [normed_group E] (p : ennreal) {μ : measure_theory.measure α} {s : set α} (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) (c : E) : ↥(measure_theory.Lp.simple_func E p μ)
{L : first_order.language} {L' : first_order.language} {α : Type u'} (φ : L ≃ᴸ L') : L.formula α ≃ L'.formula α
{𝕜 : Type u_1} {E : Type u_3} {F : Type u_4} [ordered_ring 𝕜] [topological_space E] [topological_space F] [add_comm_group E] [add_comm_group F] [module 𝕜 E] [module 𝕜 F] {s : set E} (hs : strict_convex 𝕜 s) {f : E →ᵃ[𝕜] F} (hf : is_open_map ⇑f) : strict_convex 𝕜 (⇑f '' s)
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {β : Type u_2} [topological_space β] (f : α → β) (hf : measure_theory.ae_strongly_measurable f μ) : α →ₘ[μ] β
{E : Type u_3} [semi_normed_group E] (g h : E) : ∥g + h∥ ≤ ∥g∥ + ∥h∥
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [encodable β] {f : β → α → ennreal} (hf : ∀ (b : β), measurable (f b)) (h_directed : directed has_le.le f) : ∫⁻ (a : α), (⨆ (b : β), f b a) ∂μ = ⨆ (b : β), ∫⁻ (a : α), f b a ∂μ
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] [normed_group G] [normed_space 𝕜 G] {n : ℕ} (q : formal_multilinear_series 𝕜 F G) (p : formal_multilinear_series 𝕜 E F) (c : composition n) : ∥q.comp_along_composition p c∥ ≤ ∥q c.length∥ * finset.univ.prod (λ (i : fin c.length), ∥p (c.blocks_fun i)∥)
(α : Type u) (β : Type v) [group α] [mul_action α β] : β ≃ Σ (ω : quotient (mul_action.orbit_rel α β)), ↥(mul_action.orbit α ω.out')
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_5} [topological_space H] (I : model_with_corners 𝕜 E H) (M : Type u_8) [topological_space M] [charted_space H M] (n : with_top ℕ) : diffeomorph I I M M n
{α : Type u_1} {𝕜 : Type u_14} [normed_field 𝕜] {l : filter α} {u v : α → 𝕜} : u =O[l] v → (∃ (φ : α → 𝕜) (hφ : filter.is_bounded_under has_le.le l (has_norm.norm ∘ φ)), u =ᶠ[l] φ * v)
{α : Type u_1} {m m0 : measurable_space α} {μ : measure_theory.measure α} {s : set α} (hm : m ≤ m0) {f g : α → ℝ} (hf : measure_theory.strongly_measurable f) (hfi : measure_theory.integrable_on f s μ) (hg : measure_theory.strongly_measurable g) (hgi : measure_theory.integrable_on g s μ) (hgf : ∀ (t : set α), measurable_set t → ⇑μ t < ⊤ → ∫ (x : α) in t, g x ∂μ = ∫ (x : α) in t, f x ∂μ) (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) : ∫⁻ (x : α) in s, ↑∥g x∥₊ ∂μ ≤ ∫⁻ (x : α) in s, ↑∥f x∥₊ ∂μ
{α : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space α} (X : α → E) (ℙ : measure_theory.measure α) (μ : measure_theory.measure E . "volume_tac") : E → ennreal
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {v w : E} (h : has_inner.inner v w = 0) : ∥w - v∥ = ∥w + v∥
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {ε : Type u_9} {s : set α} {t : set β} {u : set γ} {f : δ → γ → ε} {g : α → β → δ} {f₁ : α → γ → α'} {f₂ : β → γ → β'} {g' : α' → β' → ε} (h_distrib : ∀ (a : α) (b : β) (c : γ), f (g a b) c = g' (f₁ a c) (f₂ b c)) : set.image2 f (set.image2 g s t) u ⊆ set.image2 g' (set.image2 f₁ s u) (set.image2 f₂ t u)
{I : Type u₁} [category_theory.category I] {B : Type u₂} [category_theory.bicategory B] [category_theory.bicategory.strict B] (F : I ⥤ B) : category_theory.oplax_functor (category_theory.locally_discrete I) B
{R : Type u} [ring R] {ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), add_comm_group (G i)] [Π (i : ι), module R (G i)] (f : Π (i j : ι), i ≤ j → (G i →ₗ[R] G j)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] {i j k : ι} (hij : i ≤ j) (hjk : j ≤ k) (x : G i) : ⇑(f j k hjk) (⇑(f i j hij) x) = ⇑(f i k _) x
{α : Type u_1} {m : measurable_space α} (s : measure_theory.signed_measure α) {i : set α} (hi : measure_theory.vector_measure.restrict s i ≤ 0.restrict i) (hi₁ : measurable_set i) : measure_theory.is_finite_measure (s.to_measure_of_le_zero i hi₁ hi)
{p : ℕ} {R : Type u_1} [comm_ring R] {k : ℕ} (φ : ℕ → mv_polynomial (fin k × ℕ) ℤ) (x : fin k → witt_vector p R) : witt_vector p R
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.tagged_prepartition I) : set (ι → ℝ)
{V : Type u} {W : Type v} {X : Type w} {G : simple_graph V} {G' : simple_graph W} {G'' : simple_graph X} (f' : G' ≃g G'') (f : G ≃g G') : G ≃g G''
{C : Type u₁} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] (f : X ⟶ Y) [I : category_theory.normal_epi f] : category_theory.regular_epi f
(L : first_order.language) (ι : Type v) [preorder ι] (G : ι → Type w) [Π (i : ι), L.Structure (G i)] (f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)) [is_directed ι has_le.le] [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] [nonempty ι] {P : Type u₁} [L.Structure P] (g : Π (i : ι), L.embedding (G i) P) (Hg : ∀ (i j : ι) (hij : i ≤ j) (x : G i), ⇑(g j) (⇑(f i j hij) x) = ⇑(g i) x) : L.embedding (first_order.language.direct_limit G f) P
{J : Type u₁} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ⥤ C) [category_theory.limits.has_colimit F] (W : C) : ulift (category_theory.limits.colimit F ⟶ W) ≅ F.cocones.obj W
{α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] (μ : measure_theory.measure α) [μ.weakly_regular] [measure_theory.sigma_finite μ] (f : α → nnreal) (fmeas : ae_measurable f μ) {ε : ennreal} (ε0 : ε ≠ 0) : ∃ (g : α → ennreal), (∀ (x : α), ↑(f x) < g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), g x ∂μ ≤ ∫⁻ (x : α), ↑(f x) ∂μ + ε
{𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_group G] [normed_space 𝕜 G] {f : 𝕜 → G} {s : set 𝕜} {x y : 𝕜} {C : ℝ} (hf : differentiable_on 𝕜 f s) (bound : ∀ (x : 𝕜), x ∈ s → ∥deriv_within f s x∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
{ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {ca cb : E} {la la' lb lb' : filter ℝ} {lt : filter ι} {a b : ℝ} {ua ub va vb : ι → ℝ} [interval_integral.FTC_filter a la la'] [interval_integral.FTC_filter b lb lb'] (hab : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f la' measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f lb' measure_theory.measure_space.volume) (ha_lim : filter.tendsto f (la' ⊓ measure_theory.measure_space.volume.ae) (nhds ca)) (hb_lim : filter.tendsto f (lb' ⊓ measure_theory.measure_space.volume.ae) (nhds cb)) (hua : filter.tendsto ua lt la) (hva : filter.tendsto va lt la) (hub : filter.tendsto ub lt lb) (hvb : filter.tendsto vb lt lb) : (λ (t : ι), ((∫ (x : ℝ) in va t..vb t, f x) - ∫ (x : ℝ) in ua t..ub t, f x) - ((vb t - ub t) • cb - (va t - ua t) • ca)) =o[lt] λ (t : ι), ∥va t - ua t∥ + ∥vb t - ub t∥
{ι : Type u} {γ : Type w} {β : ι → Type v} [dec : decidable_eq ι] [Π (i : ι), has_zero (β i)] [Π (i : ι) (x : β i), decidable (x ≠ 0)] [add_comm_monoid γ] (f : Π₀ (i : ι), β i) (g : Π (i : ι), β i → γ) : γ
{elab : bool := bool.tt} : expr elab → option (name × binder_info × expr elab × expr elab)
{α : Type u_1} {m : set (measure_theory.outer_measure α)} {s : set α} (h : m.nonempty) : ⇑(has_Inf.Inf m) s = ⨅ (t : ℕ → set α) (h2 : s ⊆ set.Union t), ∑' (n : ℕ), ⨅ (μ : measure_theory.outer_measure α) (h3 : μ ∈ m), ⇑μ (t n)
{G : Type u_1} [measurable_space G] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] (μ : measure_theory.measure G) [μ.is_add_left_invariant] (K : set G) (hK : is_compact K) (h'K : (interior K).nonempty) (h : ⇑μ K ≠ 0) (h' : ⇑μ K ≠ ⊤) : μ.is_add_haar_measure
{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (O : finset C) (H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y)) : ∃ (S : C) (T : Π {X : C}, X ∈ O → (X ⟶ S)), ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : X ⟶ Y}, ⟨X, ⟨Y, ⟨mX, ⟨mY, f⟩⟩⟩⟩ ∈ H → f ≫ T mY = T mX
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g i) ≤ s.sum (λ (i : ι), f i • g (⇑σ i))
{𝕆 : Type u_1} {ℙ : Type u_2} {α : Type u_3} [preorder 𝕆] [preorder «ℙ»] [preorder α] [grade_bounded_order 𝕆 α] (f : 𝕆 → «ℙ») (hf : strict_mono f) (hcovby : ∀ (a b : 𝕆), a ⋖ b → f a ⋖ f b) (hmin : ∀ (a : 𝕆), is_min a → is_min (f a)) (hmax : ∀ (a : 𝕆), is_max a → is_max (f a)) : grade_bounded_order «ℙ» α
{X : Type u_1} {R : Type u_9} {ι : Type u_10} {U : ι → set X} [topological_space X] [has_zero R] {f : ι → X → R} (hlf : locally_finite (λ (i : ι), function.support (f i))) (hso : ∀ (i : ι), tsupport (f i) ⊆ U i) (ho : ∀ (i : ι), is_open (U i)) (x : X) : ∃ (is : finset ι) {n : set X} (hn₁ : n ∈ nhds x) (hn₂ : n ⊆ ⋂ (i : ι) (H : i ∈ is), U i), ∀ (z : X), z ∈ n → function.support (λ (i : ι), f i z) ⊆ ↑is
{Ω : Type u_1} [measure_theory.measure_space Ω] [measure_theory.is_probability_measure measure_theory.measure_space.volume] (X : ℕ → Ω → ℝ) (hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume) (hident : ∀ (i : ℕ), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume) : (λ (n : ℕ), (∫ (a : Ω), (finset.range n).sum (λ (i : ℕ), probability_theory.truncation (X i) ↑i) a) - ↑n * ∫ (a : Ω), X 0 a) =o[filter.at_top] coe
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] : Type (max u_4 u_2)
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : ∥S.normed_mk∥ ≤ 1
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {p q : ℝ} (hpq : p.is_conjugate_exponent q) {f g : α → ennreal} (hf : ae_measurable f μ) (hf_nontop : ∫⁻ (a : α), f a ^ p ∂μ ≠ ⊤) (hg_nontop : ∫⁻ (a : α), g a ^ q ∂μ ≠ ⊤) (hf_nonzero : ∫⁻ (a : α), f a ^ p ∂μ ≠ 0) (hg_nonzero : ∫⁻ (a : α), g a ^ q ∂μ ≠ 0) : ∫⁻ (a : α), (f * g) a ∂μ ≤ (∫⁻ (a : α), f a ^ p ∂μ) ^ (1 / p) * (∫⁻ (a : α), g a ^ q ∂μ) ^ (1 / q)
{M : Type u_1} [has_mul M] (c d : con M) : c ⊔ d = con_gen (λ (x y : M), ⇑c x y ∨ ⇑d x y)
(R : Type u) (σ : Type v) [comm_ring R] [fintype σ] [is_domain R] : is_domain (mv_polynomial σ R)
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] (M : turing.TM0.machine Γ Λ) : turing.TM0to1.Λ' → turing.TM1.stmt Γ turing.TM0to1.Λ' unit
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {F : Type u_4} [normed_group F] [normed_space 𝕜 F] {H : Type u_5} [topological_space H] {H' : Type u_6} [topological_space H'] {G : Type u_7} [topological_space G] {I : model_with_corners 𝕜 E H} {I' : model_with_corners 𝕜 E' H'} {J : model_with_corners 𝕜 F G} {M : Type u_8} [topological_space M] [charted_space H M] {M' : Type u_9} [topological_space M'] [charted_space H' M'] {N : Type u_10} [topological_space N] [charted_space G N] {n : with_top ℕ} (h₁ : diffeomorph I I' M M' n) (h₂ : diffeomorph I' J M' N n) : diffeomorph I J M N n
{α : Type u} {β : Type v} (e : α ≃ β) [has_add β] : let _inst : has_add α := e.has_add in α ≃+ β
{𝕜 : Type u} {A : Type v} [field 𝕜] [ring A] [algebra 𝕜 A] [is_alg_closed 𝕜] (a : A) (p : polynomial 𝕜) (hdeg : 0 < p.degree) : spectrum 𝕜 (⇑(polynomial.aeval a) p) = (λ (k : 𝕜), polynomial.eval k p) '' spectrum 𝕜 a
{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {t : set α} (Hf : antitone_on f t) {a : α} : is_greatest t a → is_least (f '' t) (f a)
{𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] [topological_space.second_countable_topology G] (hcg : has_compact_support g) (hf : measure_theory.integrable f μ) (hg : continuous g) : continuous (convolution f g L μ)
{α : Type u} {σ : Type v} (M : DFA α σ) : language α
{f f' : ℝ → ℝ} {a b : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at B (B' x) (set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → f x = B x → f' x < B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → f x ≤ B x
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} {W : C} {h : Y ⟶ W} {k : Z ⟶ W} {comm : f ≫ h = g ≫ k} (t : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk k h category_theory.limits.pushout_cocone.flip_is_colimit._proof_1)) : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk h k comm)
{K : Type u_1} [comm_ring K] [is_domain K] {ζ : K} {n : ℕ} (hpos : 0 < n) (h : is_primitive_root ζ n) : n.divisors.prod (λ (i : ℕ), polynomial.cyclotomic' i K) = polynomial.X ^ n - 1
{ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {l l' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {u v : ι → ℝ} [l'.is_measurably_generated] [filter.tendsto_Ixx_class set.Ioc l l'] (hfm : strongly_measurable_at_filter f l' μ) (hf : filter.tendsto f (l' ⊓ μ.ae) (nhds c)) (hl : μ.finite_at_filter l') (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) (huv : v ≤ᶠ[lt] u) : (λ (t : ι), ∫ (x : ℝ) in u t..v t, f x ∂μ + (⇑μ (set.Ioc (v t) (u t))).to_real • c) =o[lt] λ (t : ι), (⇑μ (set.Ioc (v t) (u t))).to_real
{α : Type u_1} {𝕜 : Type u_2} [linear_ordered_field 𝕜] (G : simple_graph α) [decidable_rel G.adj] (ε : 𝕜) (s t : finset α) : Prop
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : ∥⇑(quotient_add_group.mk' S) m∥ = has_Inf.Inf ((λ (x : M), ∥m + x∥) '' ↑S)
{α : Type u_1} {E : Type u_3} [measurable_space α] [normed_group E] {f : α → E} {μ : measure_theory.measure α} {l : filter α} : measure_theory.integrable_at_filter f (l ⊓ μ.ae) μ → measure_theory.integrable_at_filter f l μ
{α : Type u_1} {m0 : measurable_space α} [topological_space α] {μ : measure_theory.measure α} [measure_theory.is_finite_measure_on_compacts μ] ⦃K : set α⦄ (hK : is_compact K) : ⇑μ K < ⊤
{ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [fintype ι] {s : set M} (f : smooth_bump_covering ι I M s) : cont_mdiff_map I (model_with_corners_self ℝ (ι → E × ℝ)) M (ι → E × ℝ) ⊤
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] {W X Y Z : C} [category_theory.monoidal_category.lift_obj X] [category_theory.monoidal_category.lift_obj Y] [category_theory.monoidal_category.monoidal_coherence X Y] (f : W ⟶ X) (g : Y ⟶ Z) : W ⟶ Z
{α : Type u_1} {E : Type u_3} [topological_space α] [compact_space α] [normed_group E] (f : C(α, E)) (x y : α) : has_dist.dist (⇑f x) (⇑f y) ≤ 2 * ∥f∥
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [normed_group E] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite ν] ⦃f : α × β → E⦄ (hf : measure_theory.strongly_measurable f) : measure_theory.strongly_measurable (λ (x : α), ∫ (y : β), f (x, y) ∂ν)
{L : first_order.language} {ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), L.Structure (G i)] {f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)} [is_directed ι has_le.le] [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] [nonempty ι] (z : first_order.language.direct_limit G f) : ∃ (i : ι) (x : G i), ⇑(first_order.language.direct_limit.of L ι G f i) x = z
(α : Type u_1) (π : α → Type u_2) [decidable_eq α] [fintype α] [Π (a : α), encodable (π a)] : trunc (encodable (Π (a : α), π a))
{G : Type u_1} [measurable_space G] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] [t1_space G] [locally_compact_space G] [(nhds_within 0 {0}ᶜ).ne_bot] (μ : measure_theory.measure G) [μ.is_add_haar_measure] : measure_theory.has_no_atoms μ
{α : Type u_1} [measurable_space α] {ι : Type u_2} [encodable ι] (μ : ι → measure_theory.outer_measure α) : (⨆ (i : ι), μ i).trim = ⨆ (i : ι), (μ i).trim
{G : Type u_1} [group G] [topological_space G] [nonarchimedean_group G] {K : Type u_3} [group K] [topological_space K] [nonarchimedean_group K] {U : set (G × K)} (hU : U ∈ nhds 1) : ∃ (V : open_subgroup G) (W : open_subgroup K), ↑V ×ˢ ↑W ⊆ U
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [measurable_space β] {f : measure_theory.simple_func α ennreal} {g : measure_theory.simple_func β ennreal} {ν : measure_theory.measure β} (H : ∀ (y : ennreal), ⇑μ (⇑f ⁻¹' {y}) = ⇑ν (⇑g ⁻¹' {y})) : f.lintegral μ = g.lintegral ν
{α : Type u_1} {β : Type u_2} [has_zero β] {m : measurable_space α} (f : measure_theory.simple_func α β) (μ : measure_theory.measure α) : Prop
{α : Type u_1} [metric_space α] [topological_space.second_countable_topology α] [measurable_space α] [opens_measurable_space α] [has_besicovitch_covering α] (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] (x : α) : filter.tendsto (λ (r : ℝ), metric.closed_ball x r) (nhds_within 0 (set.Ioi 0)) ((besicovitch.vitali_family μ).filter_at x)
{R : Type u_1} {V : Type u_2} {W : Type u_3} [ring R] [add_comm_group V] [module R V] [topological_space V] [add_comm_group W] [module R W] [topological_space W] (f : V →L[R] W) : V →A[R] W
{𝕜 : Type u_1} {R : Type u_2} {E : Type u_3} {H : Type u_4} [topological_space R] [topological_space H] [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [charted_space H R] (I : model_with_corners 𝕜 E H) [semiring R] [smooth_ring I R] : topological_semiring R
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x : E} (hf : has_fderiv_at f f' x) (v : E) {α : Type u_4} {c : α → 𝕜} {l : filter α} (hc : filter.tendsto (λ (n : α), ∥c n∥) l filter.at_top) : filter.tendsto (λ (n : α), c n • (f (x + (c n)⁻¹ • v) - f x)) l (nhds (⇑f' v))
{I : Type u} {f : I → Type v₁} [decidable_eq I] [Π (i : I), has_one (f i)] (i : I) (x : f i) (i_1 : I) : f i_1
{E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (hf : differentiable_on ℝ f s) (hs : ⇑μ s = 0) : ⇑μ (f '' s) = 0
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} [measure_theory.is_probability_measure μ] (hs : convex ℝ s) (hsc : is_closed s) (hf : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) : ∫ (x : α), f x ∂μ ∈ s
{ι : Type u_1} {σ : Type u_2} {R : Type u_4} [decidable_eq ι] [add_monoid ι] [semiring R] [set_like σ R] [add_submonoid_class σ R] (A : ι → σ) [set_like.graded_monoid A] : direct_sum.gsemiring (λ (i : ι), ↥(A i))
{f : ℝ → ℝ} (hf : differentiable ℝ f) {C : ℝ} (hf'_gt : ∀ (x : ℝ), C < deriv f x) ⦃x y : ℝ⦄ (hxy : x < y) : C * (y - x) < f y - f x
{𝕜 : Type u_1} {E : Type u_4} {Fₗ : Type u_7} [normed_group E] [normed_group Fₗ] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 Fₗ] {r : ℝ} (r_pos : 0 < r) (c : ℝ) (f : E →ₗ[𝕜] Fₗ) (h : ∀ (z : E), z ∈ metric.ball 0 r → ∥⇑f z∥ ≤ c) : ∃ (C : ℝ), ∀ (z : E), ∥⇑f z∥ ≤ C * ∥z∥
{F : Type u_3} [inner_product_space ℝ F] [finite_dimensional ℝ F] {n : ℕ} (φ : F ≃ₗᵢ[ℝ] F) (hn : finite_dimensional.finrank ℝ ↥((continuous_linear_map.id ℝ F - ↑(φ.to_continuous_linear_equiv)).ker)ᗮ ≤ n) : ∃ (l : list F), l.length ≤ n ∧ φ = (list.map (λ (v : F), reflection (submodule.span ℝ {v})ᗮ) l).prod
{α : Type u_1} {β : Type u_2} {M : Type u_5} [comm_monoid M] {f : α → M} {s : set β} {g : β → α} (hg : set.inj_on g s) : finprod (λ (i : α), finprod (λ (H : i ∈ g '' s), f i)) = finprod (λ (j : β), finprod (λ (H : j ∈ s), f (g j)))
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f) (s : set X) : dimH (f '' s) ≤ dimH s
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i * g i) ≤ finset.univ.sum (λ (i : ι), f i * g (⇑σ i))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} (hp : p ∈ s) : vector_span k s = submodule.span k (has_vsub.vsub p '' (s  {p}))
{J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {t : category_theory.limits.cone F} (h : category_theory.limits.is_limit t) {W : C} {f f' : W ⟶ t.X} (w : ∀ (j : J), f ≫ t.π.app j = f' ≫ t.π.app j) : f = f'
{G : Type u_1} [measurable_space G] [has_mul G] (μ : measure_theory.measure G) : Prop
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.prepartition I) (πi : Π (J : box_integral.box ι), box_integral.tagged_prepartition J) : box_integral.tagged_prepartition I
{α : Type u_1} {E : Type u_2} {ι : Type u_3} [preorder ι] {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] [has_le E] (f : ι → α → E) (ℱ : measure_theory.filtration ι m0) (μ : measure_theory.measure α) : Prop
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g (⇑σ i)) < s.sum (λ (i : ι), f i • g i) ↔ ¬monovary_on f (g ∘ ⇑σ) ↑s
{γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {β : Type u_4} [tβ : topological_space β] [t2_space β] [measurable_space β] [borel_space β] {s : set γ} {f : γ → β} (hs : measurable_set s) (f_cont : continuous_on f s) (f_inj : set.inj_on f s) : measurable_set (f '' s)
(M : Type u_1) (N : Type u_2) (μ : M → N → N) (r : N → N → Prop) : Prop
(s : string := "") (l : list expr) : tactic unit
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] {J : ideal R} {I : ideal S} {f : R →+* S} {H : J ≤ ideal.comap f I} (h : ideal.comap f I ≤ J) : function.injective ⇑(I.quotient_map f H)
{α : Type u_1} {σ : Type u_3} (F : ctop α σ) : topological_space α
(h : name) (t : option expr := option.none) (pr : expr) : smt_tactic unit
{L : first_order.language} {α : Type u'} {n : ℕ} (φ ψ : L.bounded_formula α n) : L.bounded_formula α n
{ι : Type u_6} {π : ι → Type u_7} [Π (i : ι), preorder (π i)] (i : ι) : (Π (j : ι), π j) →o π i
{f f' : ℝ → ℝ} {a b : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at B (B' x) (set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → f' x ≤ B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → f x ≤ B x
{α : Sort u_1} {β : Sort u_2} {s₁ : setoid α} {s₂ : setoid β} {φ : quotient s₁ → quotient s₂ → Sort u_3} [h : ∀ (a : α) (b : β), subsingleton (φ ⟦a⟧ ⟦b⟧)] (q₁ : quotient s₁) (q₂ : quotient s₂) (f : Π (a₁ : α) (a₂ : β), φ (quotient.mk' a₁) (quotient.mk' a₂)) : φ q₁ q₂
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i • g i) < finset.univ.sum (λ (i : ι), f i • g (⇑σ i)) ↔ ¬antivary f (g ∘ ⇑σ)
(lemmas : list expr) (opt : tactic.apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}) (tac : tactic unit := tactic.skip) : tactic unit
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i • g (⇑σ i)) = finset.univ.sum (λ (i : ι), f i • g i) ↔ antivary f (g ∘ ⇑σ)
(h_eqs_names coeffs : list pexpr) (config : linear_combo.linear_combination_config := {normalize := bool.tt, normalization_tactic := has_bind.seq (tactic.save_info {line := 75, column := 41}) (tactic.interactive.ring1 option.none).step}) : tactic unit
{R : Type u_1} [semiring R] {φ : power_series R} {n : enat} : φ.order = n ↔ (∀ (i : ℕ), ↑i = n → ⇑(power_series.coeff R i) φ ≠ 0) ∧ ∀ (i : ℕ), ↑i < n → ⇑(power_series.coeff R i) φ = 0
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {H : Type u_5} [topological_space H] (I : model_with_corners 𝕜 E H) (e : diffeomorph (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') E E' ⊤) : model_with_corners 𝕜 E' H
{a b : ℝ} (n : ℕ) : ∫ (x : ℝ) in a..b, real.cos x ^ (n + 2) = (real.cos b ^ (n + 1) * real.sin b - real.cos a ^ (n + 1) * real.sin a) / (↑n + 2) + (↑n + 1) / (↑n + 2) * ∫ (x : ℝ) in a..b, real.cos x ^ n
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] : basic_smooth_vector_bundle_core I M E
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (N : lie_submodule R L M) ⦃f g : M ⧸ N →ₗ⁅R,L⁆ M⦄ (h : f.comp (lie_submodule.quotient.mk' N) = g.comp (lie_submodule.quotient.mk' N)) : f = g
{n : ℕ} {K : Type u_1} [field K] {μ : K} (h : is_primitive_root μ n) (hpos : 0 < n) [char_zero K] : polynomial.cyclotomic n ℚ = minpoly ℚ μ
{p : ℕ+} {k : ℕ} {K : Type u} {L : Type v} {ζ : L} [field K] [field L] [algebra K L] [is_cyclotomic_extension {p ^ k} K L] [hp : fact (nat.prime ↑p)] [ne_zero ↑↑p] (hζ : is_primitive_root ζ ↑(p ^ k)) (hirr : irreducible (polynomial.cyclotomic ↑(p ^ k) K)) : ∃ (u : ℤˣ) (n : ℕ), algebra.discr K ⇑((is_primitive_root.power_basis K hζ).basis) = ↑u * ↑p ^ n
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} [inhabited Λ] {σ : Type u_4} [inhabited σ] {C : turing.TM2.stmt Γ Λ σ → Sort l} (H₁ : Π (k : K) (s : turing.TM2to1.st_act k) (q : turing.TM2.stmt Γ Λ σ), C q → C (turing.TM2to1.st_run s q)) (H₂ : Π (a : σ → σ) (q : turing.TM2.stmt Γ Λ σ), C q → C (turing.TM2.stmt.load a q)) (H₃ : Π (p : σ → bool) (q₁ q₂ : turing.TM2.stmt Γ Λ σ), C q₁ → C q₂ → C (turing.TM2.stmt.branch p q₁ q₂)) (H₄ : Π (l : σ → Λ), C (turing.TM2.stmt.goto l)) (H₅ : C turing.TM2.stmt.halt) (n : turing.TM2.stmt Γ Λ σ) : C n
(opt : tactic.solve_by_elim.opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := λ (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (λ (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}) : tactic unit
(α : Type u_1) (β : α → Type u_2) (γ : Π (a : α), β a → Type u_3) [Π (x : α) (y : β x), preorder (γ x y)] : (Π (a : α) (b : β a), γ a b) →o Π (x : Σ (a : α), β a), γ x.fst x.snd
(α : Type u) (β : Type v) [add_group α] [add_action α β] {φ : quotient (add_action.orbit_rel α β) → β} (hφ : function.left_inverse quotient.mk' φ) : β ≃ Σ (ω : quotient (add_action.orbit_rel α β)), α ⧸ add_action.stabilizer α (φ ω)
{C : Type u} [category_theory.category C] [category_theory.limits.has_strict_initial_objects C] {I : C} (X : C) [category_theory.limits.has_binary_product I X] (hI : category_theory.limits.is_initial I) : I ⨯ X ≅ I
{k : Type u_1} {G : Type u_2} {V : Type u_3} {W : Type u_4} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] [add_comm_monoid W] [module k W] (ρV : representation k G V) (ρW : representation k G W) : representation k G (V →ₗ[k] W)
{α : Type u_1} {ι : Type u_2} {L : filter ι} [measurable_space α] [pseudo_emetric_space α] [opens_measurable_space α] {μ : measure_theory.finite_measure α} {μs : ι → measure_theory.finite_measure α} (μs_lim : filter.tendsto μs L (nhds μ)) {F : set α} (F_closed : is_closed F) : L.limsup (λ (i : ι), ⇑↑(μs i) F) ≤ ⇑↑μ F
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) ⦃ι : Type v⦄ (U : ι → topological_space.opens ↥X) : category_theory.limits.cone (Top.presheaf.sheaf_condition_equalizer_products.diagram F U) ⥤ category_theory.limits.cone ((category_theory.pairwise.diagram U).op ⋙ F)
{C : Type u_1} {D : Type u_2} [category_theory.category C] [category_theory.category D] [category_theory.monoidal_category C] [category_theory.monoidal_category D] (F : category_theory.monoidal_functor C D) [category_theory.faithful F.to_lax_monoidal_functor.to_functor] [category_theory.braided_category D] (β : Π (X Y : C), X ⊗ Y ≅ Y ⊗ X) (w : ∀ (X Y : C), F.to_lax_monoidal_functor.μ X Y ≫ F.to_lax_monoidal_functor.to_functor.map (β X Y).hom = (β_ (F.to_lax_monoidal_functor.to_functor.obj X) (F.to_lax_monoidal_functor.to_functor.obj Y)).hom ≫ F.to_lax_monoidal_functor.μ Y X) : category_theory.braided_category C
{M : Type u_1} [comm_monoid M] {μ : M} {n : ℕ+} (h : is_primitive_root μ ↑n) : ↥(roots_of_unity n M)
{R : Type u} {M : Type v} {ι : Type x} [semiring R] {φ : ι → Type i} [Π (i : ι), add_comm_monoid (φ i)] [Π (i : ι), module R (φ i)] [fintype ι] [decidable_eq ι] [add_comm_monoid M] [module R M] {f g : (Π (i : ι), φ i) →ₗ[R] M} (h : ∀ (i : ι), f.comp (linear_map.single i) = g.comp (linear_map.single i)) : f = g
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] ⦃f : α × β → E⦄ (h1f : measure_theory.ae_strongly_measurable f (μ.prod ν)) : measure_theory.integrable f (μ.prod ν) ↔ (∀ᵐ (x : α) ∂μ, measure_theory.integrable (λ (y : β), f (x, y)) ν) ∧ measure_theory.integrable (λ (x : α), ∫ (y : β), ∥f (x, y)∥ ∂ν) μ
{ι : Type u_1} {α : ι → Type u_3} [fintype ι] [Π (i : ι), measurable_space (α i)] {μ : Π (i : ι), measure_theory.measure (α i)} {C : Π (i : ι), set (set (α i))} (hμ : Π (i : ι), (μ i).finite_spanning_sets_in (C i)) : (measure_theory.measure.pi μ).finite_spanning_sets_in (set.univ.pi '' set.univ.pi C)
{α : Type u} {β : Type v} [topological_space α] [topological_space β] {s : set α} {f : α → β} (hf : embedding f) : is_compact s ↔ is_compact (f '' s)
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} {W : C} {h : W ⟶ X} {k : W ⟶ Y} {comm : h ≫ f = k ≫ g} (t : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk k h category_theory.limits.pullback_cone.flip_is_limit._proof_1)) : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk h k comm)
{F : Type u_3} [inner_product_space ℝ F] {K : set F} (h : convex ℝ K) {u v : F} (hv : v ∈ K) : (∥u - v∥ = ⨅ (w : ↥K), ∥u - ↑w∥) ↔ ∀ (w : F), w ∈ K → has_inner.inner (u - v) (w - v) ≤ 0
{α : Type u_1} {β : Type u_2} [linear_order α] [linear_order β] [densely_ordered α] [no_min_order α] [no_max_order α] [nonempty α] (b : β) (I : order.ideal (order.partial_iso α β)) : (∃ (f : order.partial_iso α β), f ∈ order.partial_iso.defined_at_right α b ∧ f ∈ I) → {a // ∃ (f : {f // ∀ (p : α × β), p ∈ f → ∀ (q : α × β), q ∈ f → cmp p.fst q.fst = cmp p.snd q.snd}) (H : f ∈ I), (a, b) ∈ f.val}
{E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (hs : measurable_set s) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) : ∫⁻ (x : E) in s, ennreal.of_real |(f' x).det| ∂μ = ⇑μ (f '' s)
{α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] (μ : measure_theory.measure α) [μ.weakly_regular] (f : α → ennreal) (hf : measurable f) {ε : ennreal} (εpos : ε ≠ 0) : ∃ (g : α → ennreal), (∀ (x : α), f x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), g x ∂μ ≤ ∫⁻ (x : α), f x ∂μ + ε
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {ι : Type u_2} {l : filter ι} [l.is_countably_generated] {F : ι → α → ennreal} {f : α → ennreal} (bound : α → ennreal) (hF_meas : ∀ᶠ (n : ι) in l, measurable (F n)) (h_bound : ∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, F n a ≤ bound a) (h_fin : ∫⁻ (a : α), bound a ∂μ ≠ ⊤) (h_lim : ∀ᵐ (a : α) ∂μ, filter.tendsto (λ (n : ι), F n a) l (nhds (f a))) : filter.tendsto (λ (n : ι), ∫⁻ (a : α), F n a ∂μ) l (nhds (∫⁻ (a : α), f a ∂μ))
{ι : Type u_4} {π : ι → Type u_1} [fintype ι] [Π (i : ι), normed_ring (π i)] : normed_ring (Π (i : ι), π i)
{F : Type u_1} {α : Type u_2} {β : Type u_3} [add_zero_class α] [add_zero_class β] [add_monoid_hom_class F α β] (φ : F) : filter α →+ filter β
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) (ρ : measure_theory.measure α) (x : α) : ennreal
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pushouts C] {W X Y Z : C} (f : X ⟶ Y) (g : X ⟶ Z) (g₁ : X ⟶ W) [category_theory.epi g₁] (g₂ : W ⟶ Z) [category_theory.mono g₂] (hg : g₁ ≫ g₂ = g) (f' : W ⟶ Y) (hf : g₁ ≫ f' = f) (t : category_theory.limits.pushout_cocone f g) (ht : category_theory.limits.is_colimit t) : category_theory.mono t.inl
{V : Type u_1} [inner_product_space ℝ V] (x y : V) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - 2 * ∥x∥ * ∥y∥ * real.cos (inner_product_geometry.angle x y)
{R : Type u} [comm_ring R] {S : Type v} [comm_ring S] (I : ideal R) (f : R →+* S) (H : ∀ (a : R), a ∈ I → ⇑f a = 0) : R ⧸ I →+* S
{C : Type u₁} [category_theory.category C] {J : Type u} [category_theory.category J] {j : J} (I : category_theory.limits.is_initial j) (F : J ⥤ C) [category_theory.limits.has_limit F] : category_theory.is_iso (category_theory.limits.limit.π F j)
{L : first_order.language} {L' : first_order.language} {α : Type u'} (φ : L →ᴸ L') : L.term α → L'.term α
{E : Type u_2} [normed_group E] {α : Type u_1} {m : measurable_space α} (f : α → E) (p : ennreal) (μ : measure_theory.measure α . "volume_tac") : Prop
{I : Type w₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] : (Σ (i : I), C i) → (Σ (i : I), C i) → Type (max w₁ v₁ u₁)
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] (M : turing.TM0.machine Γ Λ) : turing.TM0.cfg Γ Λ → option (turing.TM0.cfg Γ Λ)
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : α → ennreal} (hf : measurable f) (g : α → ennreal) : ∫⁻ (a : α), f a + g a ∂μ = ∫⁻ (a : α), f a ∂μ + ∫⁻ (a : α), g a ∂μ
{α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.regular] : μ.inner_regular is_compact (λ (s : set α), measurable_set s ∧ ⇑μ s ≠ ⊤)
{α : Type u_1} {𝕜 : Type u_14} [normed_field 𝕜] {c : ℝ} {l : filter α} {u v : α → 𝕜} (φ : α → 𝕜) (hφ : ∀ᶠ (x : α) in l, ∥φ x∥ ≤ c) (h : u =ᶠ[l] φ * v) : asymptotics.is_O_with c l u v
(a b : ℝ) (f : C(↥(set.Icc a b), ℝ)) (ε : ℝ) (pos : 0 < ε) : ∃ (p : polynomial ℝ), ∥p.to_continuous_map_on (set.Icc a b) - f∥ < ε
(ε : out_param (Type u)) (m : Type v → Type w) : Type (max u (v+1) w)
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] : Prop
{𝕜 : Type u} [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] [complete_space 𝕜] {c : 𝕜} (hc : 1 < ∥c∥) {R : ℝ} (hR : ∥c∥ < R) (h : ¬finite_dimensional 𝕜 E) : ∃ (f : ℕ → E), (∀ (n : ℕ), ∥f n∥ ≤ R) ∧ ∀ (m n : ℕ), m ≠ n → 1 ≤ ∥f m - f n∥
{M : Type u_1} {α : Type u_4} [add_monoid M] {c : add_con M} (u : add_units c.quotient) (f : Π (x y : M), ⇑c (x + y) 0 → ⇑c (y + x) 0 → α) (Hf : ∀ (x y : M) (hxy : ⇑c (x + y) 0) (hyx : ⇑c (y + x) 0) (x' y' : M) (hxy' : ⇑c (x' + y') 0) (hyx' : ⇑c (y' + x') 0), ⇑c x x' → ⇑c y y' → f x y hxy hyx = f x' y' hxy' hyx') : α
{I : Type u} {α : Type u_1} {β : Type u_2} [monoid α] [add_monoid β] [distrib_mul_action α β] [decidable_eq I] (i : I) (r : α) (x : β) : pi.single i (r • x) = r • pi.single i x
(ids : interactive.parse (lean.parser.many interactive.types.ident_)) (no_dflt : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (cfg : tactic.simp_intros_config := {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}, use_hyps := bool.ff}) : tactic unit
{ι : Type v} {α : ι → Type u} {δ : Π (i : ι), α i → Type w} [Π (i : ι) (j : α i), add_comm_monoid (δ i j)] : direct_sum ι (λ (i : ι), direct_sum (α i) (λ (j : α i), δ i j)) →+ direct_sum (Σ (i : ι), α i) (λ (i : Σ (i : ι), α i), δ i.fst i.snd)
{E : Type u} [normed_group E] [normed_space ℂ E] {F : Type v} [normed_group F] [normed_space ℂ F] {f : E → F} {z : E} {r : ℝ} (hd : diff_cont_on_cl ℂ f (metric.ball z r)) (hz : is_max_on (has_norm.norm ∘ f) (metric.ball z r) z) : set.eq_on (has_norm.norm ∘ f) (function.const E ∥f z∥) (metric.closed_ball z r)
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] (f : α × β → ennreal) (hf : ae_measurable f (μ.prod ν)) : ∫⁻ (z : α × β), f z ∂μ.prod ν = ∫⁻ (x : α), ∫⁻ (y : β), f (x, y) ∂ν ∂μ
{G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure G} {f : G → E} {g : G} [group G] [has_measurable_mul G] [μ.is_mul_right_invariant] (hf' : ∀ (x : G), f (x * g) = -f x) : ∫ (x : G), f x ∂μ = 0
{G : Type u_1} {α : Type u_2} [group G] [mul_action G α] [measurable_space α] {s : set α} {μ : measure_theory.measure α} (h_meas : measure_theory.null_measurable_set s μ) (h_exists : ∀ (x : α), ∃! (g : G), g • x ∈ s) : measure_theory.is_fundamental_domain G s μ
{R : Type u_1} [normed_ring R] [complete_space R] (t : R) (h : ∥t∥ < 1) : Rˣ
{α : Type u} {σ : Type v} (M : ε_NFA α σ) (S : set σ) : set σ
{f f' : ℝ → ℝ} {a b : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : ∀ (x : ℝ), has_deriv_at B (B' x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → f x = B x → f' x < B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → f x ≤ B x
{α : Type u} [lattice α] [comm_group α] [covariant_class α α has_mul.mul has_le.le] (a b : α) : |a * b| ≤ |a| * |b|
{M : Type u_1} [has_add M] (S : set (add_con M)) : has_Sup.Sup S = add_con_gen (λ (x y : M), ∃ (c : add_con M), c ∈ S ∧ ⇑c x y)
(q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) (cfg : tactic.rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}) : tactic unit
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X ℝ) {e : X → Y} (he : closed_embedding e) : ∃ (g : bounded_continuous_function Y ℝ), ∥g∥ = ∥f∥ ∧ ⇑g ∘ e = ⇑f
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] [topological_space α] [borel_space α] [second_countable_topology_either α E] {f : ↥(measure_theory.Lp E p μ)} : f ∈ measure_theory.Lp.bounded_continuous_function E p μ ↔ ∃ (f₀ : bounded_continuous_function α E), continuous_map.to_ae_eq_fun μ f₀.to_continuous_map = ↑f
{σ : Type u_1} (R : Type u_2) {A : Type u_3} [comm_semiring R] [add_comm_monoid A] [module R A] [module (mv_polynomial σ R) A] [is_scalar_tower R (mv_polynomial σ R) A] (f : σ → A) : derivation R (mv_polynomial σ R) A
{A : Type u_2} {K : Type u_3} [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] [is_dedekind_domain A] {I : fractional_ideal (non_zero_divisors A) K} (hne : I ≠ 0) : I * I⁻¹ = 1
{α : Type u_1} {𝕜 : Type u_2} [linear_ordered_field 𝕜] [decidable_eq α] {A : finset α} (P : finpartition A) (G : simple_graph α) [decidable_rel G.adj] (ε : 𝕜) : Prop
{C : Type u₁} [category_theory.category C] [category_theory.well_powered C] {A : C} (s : set (category_theory.subobject A)) : category_theory.limits.wide_pullback_shape ↥(⇑(equiv_shrink (category_theory.subobject A)) '' s) ⥤ C
{I : Type w₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {D : Type u₂} [category_theory.category D] {q₁ q₂ : (Σ (i : I), C i) ⥤ D} (h : Π (i : I), category_theory.sigma.incl i ⋙ q₁ ≅ category_theory.sigma.incl i ⋙ q₂) : q₁ ≅ q₂
{α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} {S T : set (set α)} (h_gen : m0 = measurable_space.generate_from S) (h_inter : is_pi_system S) (h_sub : T ⊆ S) (hc : T.countable) (hU : ⋃₀T = set.univ) (htop : ∀ (s : set α), s ∈ T → ⇑μ s ≠ ⊤) (h_eq : ∀ (s : set α), s ∈ S → ⇑μ s = ⇑ν s) : μ = ν
{E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] {s : set E} (hs : convex ℝ s) : ⇑μ (frontier s) = 0
{σ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [add_comm_monoid A] [module R A] [module (mv_polynomial σ R) A] {D₁ D₂ : derivation R (mv_polynomial σ R) A} {s : set σ} (h : set.eq_on (⇑D₁ ∘ mv_polynomial.X) (⇑D₂ ∘ mv_polynomial.X) s) {f : mv_polynomial σ R} (hf : f ∈ mv_polynomial.supported R s) : ⇑D₁ f = ⇑D₂ f
{α : Type u} {β : Type v} [topological_space α] [topological_space β] {s : set α} (H : is_preconnected s) (f : α → β) (hf : continuous_on f s) : is_preconnected (f '' s)
{α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} (f : α ≃ᵐ β) (s : set β) : ⇑(measure_theory.measure.map ⇑f μ) s = ⇑μ (⇑f ⁻¹' s)
(n : name) (msg : string := "") : tactic unit
{𝕜 : Type u_1} [is_R_or_C 𝕜] {μ : measure_theory.measure ℝ} {E : Type u_2} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {H : Type u_3} [normed_group H] [normed_space 𝕜 H] {a b ε : ℝ} {bound : ℝ → ℝ} {F : H → ℝ → E} {F' : H → ℝ → (H →L[𝕜] E)} {x₀ : H} (ε_pos : 0 < ε) (hF_meas : ∀ᶠ (x : H) in nhds x₀, measure_theory.ae_strongly_measurable (F x) (μ.restrict (set.interval_oc a b))) (hF_int : interval_integrable (F x₀) μ a b) (hF'_meas : measure_theory.ae_strongly_measurable (F' x₀) (μ.restrict (set.interval_oc a b))) (h_bound : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → ∀ (x : H), x ∈ metric.ball x₀ ε → ∥F' x t∥ ≤ bound t) (bound_integrable : interval_integrable bound μ a b) (h_diff : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → ∀ (x : H), x ∈ metric.ball x₀ ε → has_fderiv_at (λ (x : H), F x t) (F' x t) x) : has_fderiv_at (λ (x : H), ∫ (t : ℝ) in a..b, F x t ∂μ) (∫ (t : ℝ) in a..b, F' x₀ t ∂μ) x₀
{α : Type u_1} (s : set α) [conditionally_complete_linear_order α] [inhabited ↥s] (h_Sup : ∀ {t : set ↥s}, t.nonempty → bdd_above t → has_Sup.Sup (coe '' t) ∈ s) (h_Inf : ∀ {t : set ↥s}, t.nonempty → bdd_below t → has_Inf.Inf (coe '' t) ∈ s) : conditionally_complete_linear_order ↥s
{E : Type u_1} [normed_group E] [normed_space ℝ E] [complete_space E] {φ : E → ℝ} {x₀ : E} {φ' : E →L[ℝ] ℝ} {f : E → ℝ} {f' : E →L[ℝ] ℝ} (hextr : is_local_extr_on φ {x : E | f x = f x₀} x₀) (hf' : has_strict_fderiv_at f f' x₀) (hφ' : has_strict_fderiv_at φ φ' x₀) : ∃ (a b : ℝ), (a, b) ≠ 0 ∧ a • f' + b • φ' = 0
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] [normed_group F] [normed_space ℝ F] [complete_space F] {f : E → F} {φ : E → ℝ} {x₀ : E} {f' : E →L[ℝ] F} {φ' : E →L[ℝ] ℝ} (hextr : is_local_extr_on φ {x : E | f x = f x₀} x₀) (hf' : has_strict_fderiv_at f f' x₀) (hφ' : has_strict_fderiv_at φ φ' x₀) : (f'.prod φ').range ≠ ⊤
{α : Type u} {σ : Type v} (M : ε_NFA α σ) : list α → set σ
{p : ℕ+} {k : ℕ} {K : Type u} {L : Type v} {ζ : L} [field K] [field L] [algebra K L] [is_cyclotomic_extension {p ^ (k + 1)} K L] [hp : fact (nat.prime ↑p)] [ne_zero ↑↑p] (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) (hk : p ^ (k + 1) ≠ 2) : algebra.discr K ⇑((is_primitive_root.power_basis K hζ).basis) = (-1) ^ ((↑p ^ (k + 1)).totient / 2) * ↑p ^ (↑p ^ k * ((↑p - 1) * (k + 1) - 1))
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} (ν : measure_theory.measure α) [measure_theory.sigma_finite μ] [measure_theory.sigma_finite ν] (P : α → Prop) (h : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ⇑ν s < ⊤ → (∀ᵐ (x : α) ∂μ.restrict s, P x)) : ∀ᵐ (x : α) ∂μ, P x
{M₁ : Type u_1} {M₂ : Type u_2} {R : Type u_4} {S : Type u_5} [topological_space M₂] [t2_space M₂] [semiring R] [semiring S] [add_comm_monoid M₁] [add_comm_monoid M₂] [module R M₁] [module S M₂] [has_continuous_const_smul S M₂] [has_continuous_add M₂] {σ : R →+* S} (f : M₁ → M₂) (hf : f ∈ closure (set.range coe_fn)) : M₁ →ₛₗ[σ] M₂
{G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {μ : measure_theory.measure G} {Γ : subgroup G} {𝓕 : set G} (h𝓕 : measure_theory.is_fundamental_domain ↥(Γ.opposite) 𝓕 μ) [encodable ↥Γ] [measurable_space (G ⧸ Γ)] [borel_space (G ⧸ Γ)] [Γ.normal] [μ.is_mul_left_invariant] [μ.is_mul_right_invariant] : (measure_theory.measure.map ⇑(quotient_group.mk' Γ) (μ.restrict 𝓕)).is_mul_left_invariant
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g (⇑σ i)) = s.sum (λ (i : ι), f i • g i) ↔ monovary_on f (g ∘ ⇑σ) ↑s
{α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {m m0 : measurable_space α} {μ : measure_theory.measure α} {hm : m ≤ m0} [measure_theory.sigma_finite (μ.trim hm)] {s : set α} (f : ↥(measure_theory.Lp F' 1 μ)) (hs : measurable_set s) : ∫ (x : α) in s, ⇑(⇑(measure_theory.condexp_L1_clm hm μ) f) x ∂μ = ∫ (x : α) in s, ⇑f x ∂μ
 : expr → (tactic.transparency := tactic.transparency.semireducible) → (bool := bool.tt) → tactic expr
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] {E : set G} [has_measurable_inv G] [μ.is_mul_left_invariant] [ν.is_mul_left_invariant] (Em : measurable_set E) (f : G → ennreal) (hf : measurable f) : ⇑μ E * ∫⁻ (y : G), f y ∂ν = ∫⁻ (x : G), ⇑ν ((λ (z : G), z * x) ⁻¹' E) * f x⁻¹ ∂μ
{ι : Type u_2} {π : ι → Type u_1} [fintype ι] [Π (i : ι), semi_normed_group (π i)] {r : ℝ} (hr : 0 < r) {x : Π (i : ι), π i} : ∥x∥ < r ↔ ∀ (i : ι), ∥x i∥ < r
{α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} : uniform_embedding f → ((∀ (ε : ℝ), ε > 0 → (∃ (δ : ℝ) (H : δ > 0), ∀ {a b : α}, has_dist.dist a b < δ → has_dist.dist (f a) (f b) < ε)) ∧ ∀ (δ : ℝ), δ > 0 → (∃ (ε : ℝ) (H : ε > 0), ∀ {a b : α}, has_dist.dist (f a) (f b) < ε → has_dist.dist a b < δ))
{X : Type u_1} [pseudo_emetric_space X] [sigma_compact_space X] [measurable_space X] [borel_space X] (μ : measure_theory.measure X) [measure_theory.is_locally_finite_measure μ] : μ.weakly_regular
{n : ℕ} (P : mvpfunctor (n + 1)) {α : typevec n} {C : Type u_2} (g : Π (a : P.A) (f : P.last.B a → P.last.W), typevec.arrow (P.W_path (W_type.mk a f)) α → (P.last.B a → C) → C) (x : P.last.W) (f' : typevec.arrow (P.W_path x) α) : C
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] (I : lie_ideal R L) : lie_algebra.is_solvable R ↥I ↔ I ≤ lie_algebra.radical R L
(α : Type u_1) (F : Type u_4) [measurable_space α] (𝕜 : Type u_5) [normed_field 𝕜] [normed_group F] [normed_space 𝕜 F] (μ : measure_theory.measure α) (p : ennreal) [hp : fact (1 ≤ p)] (s : set α) : ↥(measure_theory.Lp F p μ) →L[𝕜] ↥(measure_theory.Lp F p (μ.restrict s))
{σ : Type u_1} {R : Type u_2} [semiring R] {φ ψ : mv_power_series σ R} : φ = ψ ↔ ∀ (n : σ →₀ ℕ), ⇑(mv_power_series.coeff R n) φ = ⇑(mv_power_series.coeff R n) ψ
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} (x : E) {v : ι → E} (hv : orthonormal 𝕜 v) : ∑' (i : ι), ∥has_inner.inner (v i) x∥ ^ 2 ≤ ∥x∥ ^ 2
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] [h : is_noetherian R M] (f : module.End R M) (μ : R) : f.maximal_generalized_eigenspace μ = ⇑(f.generalized_eigenspace μ) (f.maximal_generalized_eigenspace_index μ)
{η : Type u_5} {f : η → Type u_6} [Π (i : η), group (f i)] (I : set η) (H : Π (i : η), subgroup (f i)) : subgroup (Π (i : η), f i)
{α : Type u_1} (F : Type u_6) (p : ennreal) [normed_group F] {m m0 : measurable_space α} (μ : measure_theory.measure α) [hp : fact (1 ≤ p)] (hm : m ≤ m0) : ↥(measure_theory.Lp_meas_subgroup F m p μ) ≃ᵢ ↥(measure_theory.Lp F p (μ.trim hm))
{V : Type u_1} [inner_product_space ℝ V] (x y : V) (h : inner_product_geometry.angle x y = real.pi / 2) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
{R : Type u_1} [comm_ring R] [is_domain R] {ζ : R} {n : ℕ} (hpos : 0 < n) (h : is_primitive_root ζ n) : polynomial.X ^ n - 1 = (polynomial.nth_roots_finset n R).prod (λ (ζ : R), polynomial.X - ⇑polynomial.C ζ)
{F : Type u_3} [inner_product_space ℝ F] {x y : F} (h : has_inner.inner x y = 0) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
(h : expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic congr_lemma
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {x : M} {n : ℕ} : cont_mdiff_at I I' ↑n f x ↔ ∃ (u : set M) (H_1 : u ∈ nhds x), cont_mdiff_on I I' ↑n f u
{α : Type u} {L : list (α × bool)} {x : α} {b : bool} : free_group.red ((x, b) :: L) list.nil ↔ free_group.red L [(x, !b)]
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] {σ : Type u_3} [inhabited σ] (M : Λ → turing.TM1.stmt Γ Λ σ) : Type (max (max u_1 u_2 u_3) u_3)
{G : Type u_1} [measurable_space G] [has_neg G] (μ : measure_theory.measure G) : Prop
{α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [t2_space α] [μ.regular] : μ.weakly_regular
{α : Type u_1} {mα : measurable_space α} {μ : measure_theory.measure α} {β : Type u_2} [measurable_space β] {X Y : α → β} [normed_division_ring β] [borel_space β] (hXY : probability_theory.indep_fun X Y μ) (hX : measure_theory.integrable X μ) (hY : measure_theory.integrable Y μ) : measure_theory.integrable (X * Y) μ
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] {f : α → β} [has_zero β] [t2_space β] (hf : measure_theory.ae_fin_strongly_measurable f μ) : set α
{X : ℕ → Type u} [Π (n : ℕ), metric_space (X n)] {f : Π (n : ℕ), X n → X (n + 1)} (I : ∀ (n : ℕ), isometry (f n)) : Type u
{α : Type u_1} [measurable_space α] {s : measure_theory.signed_measure α} {i j : set α} (hi : measurable_set i) (hj : measurable_set j) (hi' : 0.restrict i ≤ measure_theory.vector_measure.restrict s i ∧ measure_theory.vector_measure.restrict s iᶜ ≤ 0.restrict iᶜ) (hj' : 0.restrict j ≤ measure_theory.vector_measure.restrict s j ∧ measure_theory.vector_measure.restrict s jᶜ ≤ 0.restrict jᶜ) : ⇑s (i ∆ j) = 0 ∧ ⇑s (iᶜ ∆ jᶜ) = 0
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (x : M) (f : M → M') : E → E'
{X : Type u_2} [emetric_space X] (μ : measure_theory.outer_measure X) : Prop
(R : Type u) {ι : Type u'} (M₁ : ι → Type v₁) (M₂ : Type v₂) [decidable_eq ι] [comm_semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] {ι' : Type u_1} [decidable_eq ι'] (σ : ι ≃ ι') : multilinear_map R M₁ M₂ ≃ₗ[R] multilinear_map R (λ (i : ι'), M₁ (⇑(σ.symm) i)) M₂
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (𝕜 : Type u_3) [field 𝕜] [is_alg_closed 𝕜] [category_theory.linear 𝕜 C] {X : C} (is_iso_iff_nonzero : ∀ (f : X ⟶ X), category_theory.is_iso f ↔ f ≠ 0) [I : finite_dimensional 𝕜 (X ⟶ X)] : finite_dimensional.finrank 𝕜 (X ⟶ X) = 1
{α : Type uu} [monoid α] {l₁ l₂ : list α} (h : l₁ ~ l₂) (hc : list.pairwise (λ (x y : α), x * y = y * x) l₁) : l₁.prod = l₂.prod
{L : first_order.language} {M : Type w} [L.Structure M] {L' : first_order.language} [L'.Structure M] (φ : L →ᴸ L') [φ.is_expansion_on M] : L'.substructure M ↪o L.substructure M
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} (hl : l.bRiemann = bool.ff) (B : box_integral.box_additive_map ι ℝ ↑I) (hB0 : ∀ (J : box_integral.box ι), 0 ≤ ⇑B J) (g : box_integral.box_additive_map ι F ↑I) (s : set (ι → ℝ)) (hs : s.countable) (hlH : s.nonempty → l.bHenstock = bool.tt) (H₁ : ∀ (c : nnreal) (x : ι → ℝ), x ∈ ⇑box_integral.box.Icc I ∩ s → ∀ (ε : ℝ), ε > 0 → (∃ (δ : ℝ) (H : δ > 0), ∀ (J : box_integral.box ι), J ≤ I → ⇑box_integral.box.Icc J ⊆ metric.closed_ball x δ → x ∈ ⇑box_integral.box.Icc J → (↥(l.bDistortion) → J.distortion ≤ c) → has_dist.dist (⇑(⇑vol J) (f x)) (⇑g J) ≤ ε)) (H₂ : ∀ (c : nnreal) (x : ι → ℝ), x ∈ ⇑box_integral.box.Icc I  s → ∀ (ε : ℝ), ε > 0 → (∃ (δ : ℝ) (H : δ > 0), ∀ (J : box_integral.box ι), J ≤ I → ⇑box_integral.box.Icc J ⊆ metric.closed_ball x δ → (↥(l.bHenstock) → x ∈ ⇑box_integral.box.Icc J) → (↥(l.bDistortion) → J.distortion ≤ c) → has_dist.dist (⇑(⇑vol J) (f x)) (⇑g J) ≤ ε * ⇑B J)) : box_integral.has_integral I l f vol (⇑g I)
{ι : Type v} [preorder ι] (G : ι → Type w) (f : Π (i j : ι), i ≤ j → G i → G j) : Prop
{α : Type u_1} {σ : Type u_2} [has_zero α] [linear_order α] [is_well_order α has_lt.lt] [fintype σ] (S : set (σ →₀ α)) : S.is_pwo
{R : Type u_1} {M : Type u_2} {ι : Type u_3} [ring R] [add_comm_group M] [module R M] {φ : ι → Type u_4} (b : Π (i : ι), basis (φ i) R M) : basis (Σ (i : ι), φ i) R (ι →₀ M)
{G : Type u} [add_group G] {H : Type v} [add_group H] (φ : G →+ H) (hφ : function.surjective ⇑φ) : G ⧸ φ.ker ≃+ H
{p : ℕ+} {K : Type u} {L : Type v} [field L] {ζ : L} [field K] [algebra K L] [ne_zero ↑↑p] [hpri : fact (nat.prime ↑p)] [hcyc : is_cyclotomic_extension {p} K L] (hζ : is_primitive_root ζ ↑p) (hirr : irreducible (polynomial.cyclotomic ↑p K)) (h : p ≠ 2) : ⇑(algebra.norm K) (ζ - 1) = ↑p
{α : Type u_1} {β : Type u_2} {ι : Type u_3} [normed_group β] {m : measurable_space α} (f : ι → α → β) (p : ennreal) (μ : measure_theory.measure α) : Prop
{ι : Type u_1} [fintype ι] (l : box_integral.integration_params) (I : box_integral.box ι) (c : nnreal) (π₀ : box_integral.prepartition I) : filter (box_integral.tagged_prepartition I)
(p : ℕ) [fact (nat.prime p)] {R : Type u₁} [comm_semiring R] [char_p R p] {P : Type u₃} [comm_semiring P] [char_p P p] [perfect_ring P p] {S : Type u₂} [comm_semiring S] [char_p S p] {Q : Type u₄} [comm_semiring Q] [char_p Q p] [perfect_ring Q p] {π : P →+* R} (m : perfection_map p π) {σ : Q →+* S} (n : perfection_map p σ) (φ : R →+* S) : P →+* Q
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] [complete_space E] {T : E →L[𝕜] E} (hT : inner_product_space.is_self_adjoint ↑T) {x₀ : E} (hx₀ : x₀ ≠ 0) (hextr : is_max_on T.re_apply_inner_self (metric.sphere 0 ∥x₀∥) x₀) : module.End.has_eigenvector ↑T (↑⨆ (x : {x // x ≠ 0}), (λ (x : E), T.re_apply_inner_self x / ∥x∥ ^ 2) ↑x) x₀
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] {σ : Type u_3} [inhabited σ] (M : Λ → turing.TM1.stmt Γ Λ σ) : turing.TM1.cfg Γ Λ σ → turing.TM0.cfg Γ (turing.TM1to0.Λ' M)
{σ : Type u_1} (f : σ → option σ) (a b : σ) : Prop
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {F : C ⥤ D} {G_obj : D → C} (e : Π (X : C) (Y : D), (F.obj X ⟶ Y) ≃ (X ⟶ G_obj Y)) (he : ∀ (X' X : C) (Y : D) (f : X' ⟶ X) (g : F.obj X ⟶ Y), ⇑(e X' Y) (F.map f ≫ g) = f ≫ ⇑(e X Y) g) : F ⊣ category_theory.adjunction.right_adjoint_of_equiv e he
{c : Type u → Type u} (hom : Π {α β : Type u}, c α → c β → (α → β) → Prop) : Type
{α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] [topological_space β] {f : β → α} {K : set β} (hK : is_compact K) (hf : continuous_on f K) : bdd_above (f '' K)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) (I : category_theory.InjectiveResolution X) (J : category_theory.InjectiveResolution Y) (K : category_theory.InjectiveResolution Z) : homotopy (category_theory.InjectiveResolution.desc (f ≫ g) K I) (category_theory.InjectiveResolution.desc f J I ≫ category_theory.InjectiveResolution.desc g K J)
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ℤ] [category_theory.preadditive C] [∀ (n : ℤ), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T ∈ dist_triang C) : T.inv_rotate ∈ dist_triang C
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {n : with_top ℕ} {E'' : Type u_14} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {g : M' → M''} (hg : cont_mdiff I' I'' n g) (hf : cont_mdiff I I' n f) : cont_mdiff I I'' n (g ∘ f)
{R : Type u} [ring R] {ι : Type v} [dec_ι : decidable_eq ι] [preorder ι] (G : ι → Type w) [Π (i : ι), add_comm_group (G i)] [Π (i : ι), module R (G i)] (f : Π (i j : ι), i ≤ j → (G i →ₗ[R] G j)) : Type (max v w)
{R : Type u_1} [semiring R] (φ ψ : power_series R) : φ.order + ψ.order ≤ (φ * ψ).order
{B : Type u₁} [category_theory.bicategory B] {C : Type u₂} [category_theory.bicategory C] {F G H I : category_theory.oplax_functor B C} (η : F ⟶ G) (θ : G ⟶ H) (ι : H ⟶ I) : (η ≫ θ) ≫ ι ≅ η ≫ θ ≫ ι
{α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {m m0 : measurable_space α} {μ : measure_theory.measure α} {hm : m ≤ m0} [measure_theory.sigma_finite (μ.trim hm)] {f : α → F'} {s : set α} (hf : measure_theory.integrable f μ) (hs : measurable_set s) : ∫ (x : α) in s, ⇑(measure_theory.condexp_L1 hm μ f) x ∂μ = ∫ (x : α) in s, f x ∂μ
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G ≃g G') (v : V) : ↥(G.neighbor_set v) ≃ ↥(G'.neighbor_set (⇑f v))
{V : Type u} [fintype V] [decidable_eq V] {G : simple_graph V} [decidable_rel G.adj] {n k ℓ μ : ℕ} (h : G.is_SRG_with n k ℓ μ) : Gᶜ.is_SRG_with n (n - k - 1) (n - (2 * k - μ) - 2) (n - (2 * k - ℓ))
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] [topological_space.pseudo_metrizable_space β] {f : ℕ → α → β} (hf : ∀ (n : ℕ), measure_theory.ae_strongly_measurable (f n) μ) (h_ae_tendsto : ∀ᵐ (x : α) ∂μ, ∃ (l : β), filter.tendsto (λ (n : ℕ), f n x) filter.at_top (nhds l)) : ∃ (f_lim : α → β) (hf_lim_meas : measure_theory.strongly_measurable f_lim), ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (nhds (f_lim x))
{R : Type u_1} [comm_ring R] (S : Type u_2) [comm_ring S] [algebra R S] (I : ideal R) : submodule R S
{E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {f : E → G} {C : ℝ} {s : set E} {x y : E} (hf : ∀ (x : E), x ∈ s → differentiable_at 𝕜 f x) (bound : ∀ (x : E), x ∈ s → ∥fderiv 𝕜 f x∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
{𝕜 : Type u_1} {A : Type u_2} [normed_field 𝕜] [normed_ring A] [normed_algebra 𝕜 A] [complete_space A] [norm_one_class A] (φ : A →ₐ[𝕜] 𝕜) : A →L[𝕜] 𝕜
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s t u : set α} (hs : measurable_set s) (h : ⇑μ t = ⇑μ u) (htu : t ⊆ u) (ht_ne_top : ⇑μ t ≠ ⊤) : ⇑μ (t ∩ s) = ⇑μ (u ∩ s)
{α : Type u_1} [measurable_space α] [topological_space α] [opens_measurable_space α] {ι : Type u_2} {L : filter ι} [L.is_countably_generated] {μ : measure_theory.finite_measure α} {fs : ι → bounded_continuous_function α nnreal} {c : nnreal} (fs_le_const : ∀ᶠ (i : ι) in L, ∀ᵐ (a : α) ∂↑μ, ⇑(fs i) a ≤ c) {f : bounded_continuous_function α nnreal} (fs_lim : ∀ᵐ (a : α) ∂↑μ, filter.tendsto (λ (i : ι), ⇑(fs i) a) L (nhds (⇑f a))) : filter.tendsto (λ (i : ι), μ.test_against_nn (fs i)) L (nhds (μ.test_against_nn f))
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) ⦃ι : Type v⦄ (U : ι → topological_space.opens ↥X) (Q : category_theory.limits.is_limit (category_theory.functor.map_cone F (category_theory.pairwise.cocone U).op)) : category_theory.limits.is_limit (Top.presheaf.sheaf_condition_equalizer_products.fork F U)
{α : Type u_1} [topological_space α] {m : measurable_space α} [topological_space.second_countable_topology α] [linear_order α] [order_topology α] [borel_space α] (μ ν : measure_theory.measure α) [measure_theory.is_finite_measure μ] (h : ∀ (a : α), ⇑μ (set.Ici a) = ⇑ν (set.Ici a)) : μ = ν
{R : Type u} [semiring R] {M : polynomial R → Sort u_1} (p : polynomial R) : M 0 → (Π (p : polynomial R) (a : R), p.coeff 0 = 0 → a ≠ 0 → M p → M (p + ⇑polynomial.C a)) → (Π (p : polynomial R), p ≠ 0 → M p → M (p * polynomial.X)) → M p
{L : first_order.language} {ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), L.Structure (G i)] (f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)) {α : Type u_3} (x : α → (Σ (i : ι), G i)) (i : ι) (h : i ∈ upper_bounds (set.range (sigma.fst ∘ x))) (a : α) : G i
{M : Type u_3} {N : Type u_4} [mul_zero_one_class M] [mul_zero_one_class N] ⦃f g : M →*₀ N⦄ (h : ⇑f = ⇑g) : f = g
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (G : C ⥤ D) {W X Y Z : C} {h : X ⟶ Z} {k : Y ⟶ Z} {f : W ⟶ X} {g : W ⟶ Y} (comm : f ≫ h = g ≫ k) [category_theory.limits.reflects_colimit (category_theory.limits.span f g) G] (l : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (G.map h) (G.map k) _)) : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk h k comm)
{α : Type u_1} {β : Type u_2} [measurable_space α] {μ : measure_theory.measure α} [topological_space β] (p : β → Prop) (f : α →ₘ[μ] β) : Prop
{𝕜 : Type u_1} {E : Type u_4} [normed_group E] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [nontrivial E] : ∥continuous_linear_map.id 𝕜 E∥ = 1
{W X Y Z S T : Top} (f₁ : W ⟶ S) (f₂ : X ⟶ S) (g₁ : Y ⟶ T) (g₂ : Z ⟶ T) {i₁ : W ⟶ Y} {i₂ : X ⟶ Z} (H₁ : open_embedding ⇑i₁) (H₂ : open_embedding ⇑i₂) (i₃ : S ⟶ T) [H₃ : category_theory.mono i₃] (eq₁ : f₁ ≫ i₃ = i₁ ≫ g₁) (eq₂ : f₂ ≫ i₃ = i₂ ≫ g₂) : open_embedding ⇑(category_theory.limits.pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂)
{I : Type u} (f : I → Type v) [Π (i : I), has_mul (f i)] (i : I) : (Π (i : I), f i) →ₙ* f i
{α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {c : ℝ} {f : α → E} {g : α → F} {l : filter α} : (∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥) → asymptotics.is_O_with c l f g
{E : Type u_1} [normed_group E] [normed_space ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hd : diff_cont_on_cl ℂ f (set.Ioi 0 ×ℂ set.Iio 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Ioi 0 ×ℂ set.Iio 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : ∀ (x : ℝ), 0 ≤ x → ∥f ↑x∥ ≤ C) (him : ∀ (x : ℝ), x ≤ 0 → ∥f (↑x * complex.I)∥ ≤ C) (hz_re : 0 ≤ z.re) (hz_im : z.im ≤ 0) : ∥f z∥ ≤ C
{I : Type u₁} {J : Type u₂} (e : I ≃ J) : category_theory.discrete I ≌ category_theory.discrete J
(e : expr) (cfg : tactic.apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}) : tactic (list (name × expr))
(h : interactive.parse (optional lean.parser.ident)) (pat : interactive.parse (optional (lean.parser.tk ":" *> interactive.types.texpr))) (cases : interactive.parse (optional (lean.parser.tk ":=" *> interactive.types.texpr))) (perms : interactive.parse (optional (lean.parser.tk "using" *> (interactive.types.list_of (lean.parser.many lean.parser.ident) <|> (λ (x : list name), [x])functor.map <$> lean.parser.many lean.parser.ident)))) (discharger : tactic unit := tactic.solve_by_elim <|> tactic.tautology {classical := bool.tt, closer := has_pure.pure ()} <|> (using_smt (smt_tactic.intros >> smt_tactic.solve_goals))) : tactic unit
{σ : Type u} {m : Type u → Type v} [monad m] [monad_state σ m] (f : σ → σ) : m punit
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} [category_theory.limits.has_coequalizer f g] {W : C} (k : Y ⟶ W) (h : f ≫ k = g ≫ k) : {l // category_theory.limits.coequalizer.π f g ≫ l = k}
{α : Type u_1} {β : Type u_2} [measurable_space α] {μ : measure_theory.measure α} [topological_space β] (f : α →ₘ[μ] β) : μ.ae.germ β
{n : ℕ} (i : fin n) {C : Π (n : ℕ), fin n → Sort u_1} (H0 : Π (n : ℕ), C n.succ 0) (Hs : Π (n : ℕ) (i : fin n), C n i → C n.succ i.succ) : C n i
(ω : out_param (Type u)) (m : Type u → Type v) : Type (max (u+1) v)
{n : ℕ} {R : Type u_1} [comm_ring R] [is_domain R] [char_zero R] {μ : R} (hn : 0 < n) : (polynomial.cyclotomic n R).is_root μ ↔ is_primitive_root μ n
{R : Type u} {S₁ : Type v} {σ : Type u_1} [comm_semiring R] [comm_semiring S₁] {f : R →+* S₁} {g : S₁ →+* R} (hf : function.right_inverse ⇑f ⇑g) : function.right_inverse ⇑(mv_polynomial.map f) ⇑(mv_polynomial.map g)
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic unit
{α : Type u_1} [measurable_space α] {ι : Type u_2} [encodable ι] (μ : ι → measure_theory.outer_measure α) (s : set α) : ∃ (t : set α), s ⊆ t ∧ measurable_set t ∧ ∀ (i : ι), ⇑(μ i) t = ⇑((μ i).trim) s
{ι : Type u} {γ : Type w} [dec : decidable_eq ι] [add_comm_monoid γ] (S : ι → add_submonoid γ) [Π (i : ι) (x : ↥(S i)), decidable (x ≠ 0)] (x : γ) : x ∈ supr S ↔ ∃ (f : Π₀ (i : ι), ↥(S i)), f.sum (λ (i : ι) (xi : ↥(S i)), ↑xi) = x
{R : Type u_1} [comm_ring R] [is_domain R] {ζ : R} {n : ℕ} (h : is_primitive_root ζ n) : (polynomial.cyclotomic' n R).nat_degree = n.totient
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {γ' : Type u_6} {δ : Type u_7} {ε : Type u_9} {s : set α} {t : set β} {u : set γ} {f : α → δ → ε} {g : β → γ → δ} {f₁ : α → β → β'} {f₂ : α → γ → γ'} {g' : β' → γ' → ε} (h_distrib : ∀ (a : α) (b : β) (c : γ), f a (g b c) = g' (f₁ a b) (f₂ a c)) : set.image2 f s (set.image2 g t u) ⊆ set.image2 g' (set.image2 f₁ s t) (set.image2 f₂ s u)
{E : Type u_1} [normed_group E] [measurable_space E] [normed_space ℝ E] [finite_dimensional ℝ E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (x : E) {r : ℝ} (hr : 0 ≤ r) : ⇑μ (metric.closed_ball x r) = ennreal.of_real (r ^ finite_dimensional.finrank ℝ E) * ⇑μ (metric.closed_ball 0 1)
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w₁} [category_theory.category D] {E : Type w₂} [category_theory.category E] {F : D ⥤ E} {G : E ⥤ D} [Π (X : C) (S : J.cover X) (P : Cᵒᵖ ⥤ D), category_theory.limits.preserves_limit (S.index P).multicospan F] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ D] [Π (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)ᵒᵖ (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] (adj : G ⊣ F) : category_theory.Sheaf.compose_and_sheafify J G ⊣ category_theory.Sheaf_compose J F
{β : Type u} {α : Type v} [add_comm_monoid β] {σ : α → Type u_1} (s : finset α) (t : Π (a : α), finset (σ a)) (f : sigma σ → β) : (s.sigma t).sum (λ (x : Σ (i : α), σ i), f x) = s.sum (λ (a : α), (t a).sum (λ (s : σ a), f ⟨a, s⟩))
{ι : Type u_4} {π : ι → Type u_1} [fintype ι] [Π (i : ι), non_unital_semi_normed_ring (π i)] : non_unital_semi_normed_ring (Π (i : ι), π i)
{F : Type u_2} [normed_group F] [normed_space ℝ F] {x y : F} (hx : x ≠ 0) (hy : y ≠ 0) : same_ray ℝ x y → ∥x∥⁻¹ • x = ∥y∥⁻¹ • y
{R : Type u} {σ : Type v} [comm_ring R] [is_domain R] : is_domain (mv_polynomial σ R)
{ι : Type u_1} [fintype ι] (l : box_integral.integration_params) (I : box_integral.box ι) (c : nnreal) (r : (ι → ℝ) → ↥(set.Ioi 0)) (π : box_integral.tagged_prepartition I) : Prop
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M →+ N} (h : ∀ (y : ↥S), is_add_unit (⇑f ↑y)) (y : ↥S) (w z : N) : z = w + ↑-⇑(is_add_unit.lift_right (f.restrict S) h) y ↔ z + ⇑f ↑y = w
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {s : measure_theory.signed_measure α} (t : measure_theory.signed_measure α) (f : α → ℝ) (hfi : measure_theory.integrable f μ) (htμ : measure_theory.vector_measure.mutually_singular t μ.to_ennreal_vector_measure) (hadd : s = t + μ.with_densityᵥ f) : f =ᵐ[μ] s.rn_deriv μ
{β : Type u_2} [topological_space β] {ι : Type u_5} {σ : ι → Type u_6} [Π (i : ι), topological_space (σ i)] : (Σ (i : ι), σ i) × β ≃ₜ Σ (i : ι), σ i × β
{E : Type u_4} [normed_group E] [normed_space ℝ E] {b : ℝ} {f : ℕ → ℝ} {z : ℕ → E} (hfa : antitone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) (hzb : ∀ (n : ℕ), ∥(finset.range n).sum (λ (i : ℕ), z i)∥ ≤ b) : cauchy_seq (λ (n : ℕ), (finset.range (n + 1)).sum (λ (i : ℕ), f i • z i))
{n : ℕ} {K : Type u_8} [field K] {μ : K} (h : is_primitive_root μ n) [char_zero K] {p : ℕ} [fact (nat.prime p)] (hdiv : ¬p ∣ n) : (polynomial.map (int.cast_ring_hom (zmod p)) (minpoly ℤ μ)).separable
(s : tactic_state) (target_lhs_only : bool := bool.ff) : format
{𝕜 : Type u_1} [is_R_or_C 𝕜] {μ : measure_theory.measure ℝ} {E : Type u_2} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {H : Type u_3} [normed_group H] [normed_space 𝕜 H] {a b ε : ℝ} {bound : ℝ → ℝ} {F : H → ℝ → E} {F' : ℝ → (H →L[𝕜] E)} {x₀ : H} (ε_pos : 0 < ε) (hF_meas : ∀ᶠ (x : H) in nhds x₀, measure_theory.ae_strongly_measurable (F x) (μ.restrict (set.interval_oc a b))) (hF_int : interval_integrable (F x₀) μ a b) (hF'_meas : measure_theory.ae_strongly_measurable F' (μ.restrict (set.interval_oc a b))) (h_lip : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → lipschitz_on_with (⇑real.nnabs (bound t)) (λ (x : H), F x t) (metric.ball x₀ ε)) (bound_integrable : interval_integrable bound μ a b) (h_diff : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → has_fderiv_at (λ (x : H), F x t) (F' t) x₀) : interval_integrable F' μ a b ∧ has_fderiv_at (λ (x : H), ∫ (t : ℝ) in a..b, F x t ∂μ) (∫ (t : ℝ) in a..b, F' t ∂μ) x₀
{φ : Sort u_1} (d : many_one_degree) (f : set ℕ → φ) (h : ∀ (p q : ℕ → Prop), many_one_equiv p q → f p = f q) : φ
{R : Type u_1} {S : Type u_6} {M : Type u_9} {M₃ : Type u_12} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid M₃] [module R M] [module S M₃] {σ : R →+* S} (f : M →ₛₗ[σ] M₃) : M →+ M₃
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) ⦃ι : Type v⦄ (U : ι → topological_space.opens ↥X) : Top.presheaf.sheaf_condition_pairwise_intersections.cone_equiv_inverse F U ⋙ Top.presheaf.sheaf_condition_pairwise_intersections.cone_equiv_functor F U ≅ 𝟭 (category_theory.limits.cone (Top.presheaf.sheaf_condition_equalizer_products.diagram F U))
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} {C : set (set α)} {D : set (set β)} (hμ : μ.finite_spanning_sets_in C) (hν : ν.finite_spanning_sets_in D) : (μ.prod ν).finite_spanning_sets_in (set.image2 has_set_prod.prod C D)
{P : ℕ → Sort u_1} (hp : Π (p n : ℕ), nat.prime p → 0 < n → P (p ^ n)) (h0 : P 0) (h1 : P 1) (h : Π (a b : ℕ), 1 < a → 1 < b → a.coprime b → P a → P b → P (a * b)) (a : ℕ) : P a
{m : Type u_2} {n : Type u_3} [fintype m] [fintype n] {α : m → n → Type v} [Π (i : m) (j : n), add_monoid (α i j)] {β : m → n → Type w} [Π (i : m) (j : n), add_monoid (β i j)] (f : Π ⦃i : m⦄ ⦃j : n⦄, α i j →+ β i j) : dmatrix m n α →+ dmatrix m n β
{F : Type u_3} [inner_product_space ℝ F] {x : F} {r : ℝ} (hx : x ≠ 0) (hr : 0 < r) : has_inner.inner x (r • x) / (∥x∥ * ∥r • x∥) = 1
{f : ℝ → ℝ} {a b : ℝ} {μ : measure_theory.measure ℝ} (hf : 0 ≤ᵐ[μ.restrict (set.interval_oc a b)] f) (hfi : interval_integrable f μ a b) : 0 < ∫ (x : ℝ) in a..b, f x ∂μ ↔ a < b ∧ 0 < ⇑μ (function.support f ∩ set.Ioc a b)
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} (s : category_theory.limits.fork f g) {W : C} {k l : W ⟶ s.X} (h : k ≫ s.ι = l ≫ s.ι) (j : category_theory.limits.walking_parallel_pair) : k ≫ s.π.app j = l ≫ s.π.app j
{ι : Type u_1} [fintype ι] (I : box_integral.box ι) : box_integral.prepartition I
{α : Type u_1} {ι : Type u_2} [nonempty ι] (s : set α) (f : α → ι) : s.pairwise (λ (x y : α), f x = f y) ↔ ∃ (z : ι), ∀ (x : α), x ∈ s → f x = z
{α : Type u_1} [topological_space α] {m : measurable_space α} [topological_space.second_countable_topology α] [linear_order α] [order_topology α] [borel_space α] (μ ν : measure_theory.measure α) [measure_theory.is_finite_measure μ] (h : ∀ (a : α), ⇑μ (set.Iic a) = ⇑ν (set.Iic a)) : μ = ν
{P : Π (α : Type u_1) [_inst_1 : fintype α], Prop} (α : Type u_1) [fintype α] (hbase : ∀ (α : Type u_1) [_inst_3 : fintype α] [_inst_4 : subsingleton α], P α) (hstep : ∀ (α : Type u_1) [_inst_5 : fintype α] [_inst_6 : nontrivial α], (∀ (β : Type u_1) [_inst_7 : fintype β], fintype.card β < fintype.card α → P β) → P α) : P α
{α : Type u_1} [measurable_space α] {ι : Type u_2} [encodable ι] (μ : ι → measure_theory.measure α) (s : set α) : ∃ (t : set α), s ⊆ t ∧ measurable_set t ∧ ∀ (i : ι), ⇑(μ i) t = ⇑(μ i) s
(𝕜 : Type v) [is_R_or_C 𝕜] {E : Type u} [normed_group E] [normed_space 𝕜 E] (x : E) (h : x ≠ 0) : ∃ (g : E →L[𝕜] 𝕜), ∥g∥ = 1 ∧ ⇑g x = ↑∥x∥
{σ : Type u} {F : Type u → Type u} [applicative F] {α : Type u_1} {β : Type u} (f : α → F β) : σ ⊕ α → F (σ ⊕ β)
(n : with_top ℕ) {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) : closed_under_restriction (cont_diff_groupoid n I)
{n : Type u_4} {α : Type v} [decidable_eq n] [has_zero α] [has_one α] (σ : n ≃ n) (i j : n) : σ.to_pequiv.to_matrix i j = 1 (⇑σ i) j
{L : first_order.language} {T : L.Theory} {L' : first_order.language} (φ : L →ᴸ L') (M : (φ.on_Theory T).Model) : T.Model
{X : algebraic_geometry.Scheme} (𝒰 : X.open_cover) {W : algebraic_geometry.Scheme} (f : W ⟶ X) : W.open_cover
{I : Type u} [decidable_eq I] {β : Type u_1} [has_one β] (i : I) (x : β) (i' : I) : pi.mul_single i x i' = pi.mul_single i' x i
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} : has_inner.inner x y = ↑∥x∥ * ↑∥y∥ ↔ ↑∥y∥ • x = ↑∥x∥ • y
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic unit
{ι : Type u_5} {π : ι → Type u_6} {X : Type u_1} [Π (i : ι), topological_space (π i)] (f : Π (i : ι), X → π i) : inducing (λ (x : X) (i : ι), f i x)
{γ : Type v} [has_repr γ] (var : string) (x : γ) {p q : Prop} (h : q → p) : slim_check.test_result p → (psum unit (p → q) := psum.inl ()) → slim_check.test_result q
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →SL[σ₁₂] F) : isometry ⇑f ↔ ∀ (x : E), ∥⇑f x∥ = ∥x∥
{E : Type u_1} [normed_group E] [normed_space ℂ E] {a b C : ℝ} {f : ℂ → E} {z : ℂ} (hfd : diff_cont_on_cl ℂ f (complex.im ⁻¹' set.Ioo a b)) (hB : ∃ (c : ℝ) (H : c < real.pi / (b - a)) (B : ℝ), f =O[filter.comap (has_abs.abs ∘ complex.re) filter.at_top ⊓ filter.principal (complex.im ⁻¹' set.Ioo a b)] λ (z : ℂ), real.exp (B * real.exp (c * |z.re|))) (hle_a : ∀ (z : ℂ), z.im = a → ∥f z∥ ≤ C) (hle_b : ∀ (z : ℂ), z.im = b → ∥f z∥ ≤ C) (hza : a ≤ z.im) (hzb : z.im ≤ b) : ∥f z∥ ≤ C
(I : Type w₁) (C : I → Type u₁) [Π (i : I), category_theory.category (C i)] : category_theory.sigma.map C id ≅ 𝟭 (Σ (i : I), C i)
{α : Type u_1} {p : multiset α → Sort u_2} {n : ℕ} (H : Π (t₁ : multiset α), (Π {t₂ : multiset α}, ⇑multiset.card t₂ ≤ n → t₁ < t₂ → p t₂) → ⇑multiset.card t₁ ≤ n → p t₁) (s : multiset α) : ⇑multiset.card s ≤ n → p s
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_multiequalizer I] (a : I.L) : category_theory.limits.multiequalizer I ⟶ I.left a
{R : Type u_1} [comm_ring R] [is_domain R] [infinite R] {σ : Type u_2} {p q : mv_polynomial σ R} (h : ∀ (x : σ → R), ⇑(mv_polynomial.eval x) p = ⇑(mv_polynomial.eval x) q) : p = q
{F : Type u_1} [normed_group F] [normed_space ℝ F] (f : ℝ → F) (L : F) (r ε : ℝ) : set ℝ
{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X ℝ) (e : C(X, Y)) (he : closed_embedding ⇑e) : ∃ (g : bounded_continuous_function Y ℝ), ∥g∥ = ∥f∥ ∧ g.comp_continuous e = f
{α : Type u} [pseudo_metric_space α] (x : α) (ε : ℝ) : set α
{C : Type u} [category_theory.category C] {A : C} [category_theory.limits.has_finite_products C] [category_theory.exponentiable A] {I : C} (t : category_theory.limits.is_initial I) (f : A ⟶ I) : category_theory.is_iso f
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R →+* S) (I : ideal S) : ideal R
{C : ℤ → Sort u} (n : ℤ) (h : Π (b : bool) (n : ℤ), C (int.bit b n)) : C n
{α : Type u_1} [conditionally_complete_linear_order α] {s : set α} [hs : s.ord_connected] ⦃t : set ↥s⦄ (ht : t.nonempty) (h_bdd : bdd_below t) : has_Inf.Inf (coe '' t) ∈ s
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] : category_theory.limits.multifork I ⥤ category_theory.limits.fork I.fst_pi_map I.snd_pi_map
{σ : Type u_1} {τ : Type u_2} {R : Type u_4} [comm_semiring R] {f : σ → τ} (hf : function.injective f) : mv_polynomial τ R →ₐ[R] mv_polynomial σ R
(e : expr) (n : ℕ) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic (list expr × expr)
{G : Type u_1} {α : Type u_2} [add_group G] [add_action G α] [measurable_space α] {s : set α} {μ : measure_theory.measure α} (h_meas : measure_theory.null_measurable_set s μ) (h_exists : ∀ (x : α), ∃! (g : G), g +ᵥ x ∈ s) : measure_theory.is_add_fundamental_domain G s μ
(σ : Type u) (R : Type v) [comm_ring R] (m : ℕ) : submodule R (mv_polynomial σ R)
{α : Type u_1} {m : measurable_space α} {ℙ : measure_theory.measure α} [measure_theory.is_finite_measure «ℙ»] {X : α → ℝ} (hX : measurable X) : measure_theory.has_pdf X «ℙ» measure_theory.measure_space.volume ↔ (measure_theory.measure.map X «ℙ»).absolutely_continuous measure_theory.measure_space.volume
{R : Type u} [semiring R] (I : ideal (polynomial R)) : submodule R (polynomial R)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : M → M') : Prop
{E : Type u_1} [normed_group E] [normed_space ℝ E] {f f' : ℝ → E} {C : ℝ} (hf : ∀ (x : ℝ), x ∈ set.Icc 0 1 → has_deriv_within_at f (f' x) (set.Icc 0 1) x) (bound : ∀ (x : ℝ), x ∈ set.Ico 0 1 → ∥f' x∥ ≤ C) : ∥f 1 - f 0∥ ≤ C
{ι : Type u_1} {M : Type u_2} [add_comm_monoid M] [fintype ι] (f : box_integral.box ι → M) (I₀ : with_top (box_integral.box ι)) (hf : ∀ (I : box_integral.box ι), ↑I ≤ I₀ → ∀ {i : ι} {x : ℝ}, x ∈ set.Ioo (I.lower i) (I.upper i) → option.elim 0 f (I.split_lower i x) + option.elim 0 f (I.split_upper i x) = f I) : box_integral.box_additive_map ι M I₀
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {𝕜₃ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [normed_group E] [normed_group F] [normed_group G] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [nondiscrete_normed_field 𝕜₃] [normed_space 𝕜 E] [normed_space 𝕜₂ F] [normed_space 𝕜₃ G] {σ₁₂ : 𝕜 →+* 𝕜₂} {σ₂₃ : 𝕜₂ →+* 𝕜₃} {σ₁₃ : 𝕜 →+* 𝕜₃} [ring_hom_comp_triple σ₁₂ σ₂₃ σ₁₃] [ring_hom_isometric σ₁₂] (f : F →ₛₗᵢ[σ₂₃] G) {g : E →SL[σ₁₂] F} : ∥f.to_continuous_linear_map.comp g∥ = ∥g∥
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [measurable_space α] [measurable_space β] {f : ι → α → β} {μ : measure_theory.measure α} (hf : ∀ (i : ι), ae_measurable (f i) μ) (p : α → (ι → β) → Prop) : ι → α → β
{ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (fs : smooth_bump_covering ι I M s) (x : M) (hx : x ∈ s) : ι
{R : Type u} {σ : Type u_1} [comm_semiring R] {A : Type u_2} [semiring A] {f g : mv_polynomial σ R →+* A} (hC : f.comp mv_polynomial.C = g.comp mv_polynomial.C) (hX : ∀ (i : σ), ⇑f (mv_polynomial.X i) = ⇑g (mv_polynomial.X i)) : f = g
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} {σ : Type u_3} [inhabited Λ] [inhabited σ] (M : Λ → turing.TM1.stmt Γ Λ σ) (l : list Γ) : part (turing.list_blank Γ)
(t : expr) (cfg : tactic.simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}) (discharger : tactic unit := tactic.failed) (no_defaults : bool := bool.ff) (attr_names : list name := list.nil) (hs : list tactic.simp_arg_type := list.nil) : tactic (expr × expr × name_set)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] : tangent_bundle I M → M
{α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : α → E} {g : α → F} {l : filter α} : f =o[l] g → ∀ ⦃c : ℝ⦄, 0 < c → (∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥)
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} {g : E → ℝ} [measure_theory.is_finite_measure μ] (hg : convex_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hμ : μ ≠ 0) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) (hgi : measure_theory.integrable (g ∘ f) μ) : g (⨍ (x : α), f x ∂μ) ≤ ⨍ (x : α), g (f x) ∂μ
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [normed_field 𝕜] [normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ : 𝕜 →+* 𝕜₂} (f : E →ₛₗ[σ] F) (C : ℝ) (h : ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥) : E →SL[σ] F
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) (G : D ⥤ C) (η : 𝟭 C ≅ F ⋙ G) (ε : G ⋙ F ≅ 𝟭 D) : C ≌ D
(M : Type u_1) (N : Type u_2) (μ : M → N → N) (r : N → N → Prop) : Prop
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_monoid M] [nontrivial R] {m : M} {S : set M} : add_monoid_algebra.of' R M m ∈ submodule.span R (add_monoid_algebra.of' R M '' S) ↔ m ∈ S
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) {ε : ℝ} (hε : 0 < ε) : ∃ (s : M) (H : s ∈ S), ∥m + s∥ < ∥⇑(quotient_add_group.mk' S) m∥ + ε
(t : expr) (cfg : tactic.dsimp_config := {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}) (no_defaults : bool := bool.ff) (attr_names : list name := list.nil) (hs : list tactic.simp_arg_type := list.nil) : tactic expr
{α : Type u_1} {β : Type u_2} [non_assoc_semiring α] [non_assoc_semiring β] (f : α →+* β) (I : Type u_3) : (I → α) →+* I → β
{F : Type v} [normed_group F] [normed_space ℂ F] {c : ℂ} {R C : ℝ} {f : ℂ → F} (hR : 0 < R) (hd : diff_cont_on_cl ℂ f (metric.ball c R)) (hC : ∀ (z : ℂ), z ∈ metric.sphere c R → ∥f z∥ ≤ C) : ∥deriv f c∥ ≤ C / R
{α : Type u_1} (F : Type u_6) (p : ennreal) [normed_group F] {m m0 : measurable_space α} (μ : measure_theory.measure α) (hm : m ≤ m0) (f : ↥(measure_theory.Lp_meas_subgroup F m p μ)) : ↥(measure_theory.Lp F p (μ.trim hm))
{n : ℕ} {A : Type u} (F : A → typevec n → Type u) [Π (α : A), mvfunctor (F α)] [Π (α : A), mvqpf (F α)] ⦃α : typevec n⦄ : (mvqpf.sigma.P F).obj α → mvqpf.sigma F α
{K : Type u} {L : Type v} [field L] {ζ : L} [field K] [algebra K L] [ne_zero 2] {k : ℕ} (hζ : is_primitive_root ζ (2 ^ k)) (hk : 2 ≤ k) [H : is_cyclotomic_extension {2 ^ k} K L] (hirr : irreducible (polynomial.cyclotomic (2 ^ k) K)) : ⇑(algebra.norm K) (ζ - 1) = 2
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {μ : R} {k m : ℕ} (hm : k ≤ m) (hk : f.has_generalized_eigenvalue μ k) : f.has_generalized_eigenvalue μ m
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {p : tangent_bundle I M} {q : tangent_bundle I H} (h : q.fst ∈ (charted_space.chart_at H p.fst).to_local_equiv.target) : tangent_map I I ⇑((charted_space.chart_at H p.fst).symm) q = ⇑((charted_space.chart_at (model_prod H E) p).symm) (⇑(equiv.sigma_equiv_prod H E) q)
{α : Type u_1} {n : ℕ} {p : finset α → Sort u_2} (s : finset α) (H : Π (t₁ : finset α), (Π {t₂ : finset α}, t₂.card ≤ n → t₁ ⊂ t₂ → p t₂) → t₁.card ≤ n → p t₁) : s.card ≤ n → p s
{α : Type u_1} {β : Type u_2} [linear_order α] [preorder β] (f : α → β) (s : set α) (hf : strict_mono_on f s) : ↥s ≃o ↥(f '' s)
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] : continuous (λ (f : ↥(measure_theory.Lp E 1 (μ.prod ν))), ∫ (x : α), ∫ (y : β), ⇑f (x, y) ∂ν ∂μ)
(σ : Type u_1) (R : Type u_2) [comm_semiring R] : subalgebra R (mv_polynomial σ R)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] (x : M) : cont_mdiff_map I (model_with_corners_self 𝕜 𝕜) M 𝕜 ⊤ →ₐ[pointed_smooth_map 𝕜 I M ⊤ x] 𝕜
{α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) (f : ↥(measure_theory.Lp F p (μ.trim hm))) : measure_theory.mem_ℒp.to_Lp ⇑f _ ∈ measure_theory.Lp_meas_subgroup F m p μ
{G : Type w} [topological_space G] (μ : measure_theory.content G) [t2_space G] [S : measurable_space G] [borel_space G] : measure_theory.measure G
(f : ↥(measure_theory.Lp ℂ 2 haar_circle)) : ∑' (i : ℤ), ∥⇑(⇑(fourier_series.repr) f) i∥ ^ 2 = ∫ (t : ↥circle), ∥⇑f t∥ ^ 2 ∂haar_circle
{ι : Type u_1} [fintype ι] [decidable_eq ι] {M : matrix ι ι ℝ} (hM : M.det ≠ 0) : measure_theory.measure.map ⇑(⇑matrix.to_lin' M) measure_theory.measure_space.volume = ennreal.of_real |(M.det)⁻¹| • measure_theory.measure_space.volume
{V : Type u_1} {W : Type u_2} [semi_normed_group V] [semi_normed_group W] (f : normed_group_hom V W) : Prop
{n : ℕ} {A : Type u} (F : A → typevec n → Type u) [Π (α : A), mvfunctor (F α)] [Π (α : A), mvqpf (F α)] ⦃α : typevec n⦄ : (mvqpf.pi.P F).obj α → mvqpf.pi F α
(size : ℕ) : string → (list string := list.nil) → list string
{G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {μ : measure_theory.measure G} {Γ : subgroup G} {𝓕 : set G} (h𝓕 : measure_theory.is_fundamental_domain ↥(Γ.opposite) 𝓕 μ) [encodable ↥Γ] [measurable_space (G ⧸ Γ)] [borel_space (G ⧸ Γ)] [μ.is_mul_left_invariant] [μ.is_mul_right_invariant] : measure_theory.smul_invariant_measure G (G ⧸ Γ) (measure_theory.measure.map quotient_group.mk (μ.restrict 𝓕))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (s : finset ι) {ι₂ : Type u_5} (s₂ : finset ι₂) {p : ι → P} (hi : ∀ (i : ι), i ∈ s → ∀ (j : ι), j ∈ s → p i = p j → i = j) {p₂ : ι₂ → P} (hi₂ : ∀ (i : ι₂), i ∈ s₂ → ∀ (j : ι₂), j ∈ s₂ → p₂ i = p₂ j → i = j) (he : p '' ↑s = p₂ '' ↑s₂) : finset.centroid k s p = finset.centroid k s₂ p₂
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {n : with_top ℕ} {E'' : Type u_14} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {t : set M'} {g : M' → M''} (hg : cont_mdiff_on I' I'' n g t) (hf : cont_mdiff_on I I' n f s) : cont_mdiff_on I I'' n (g ∘ f) (s ∩ f ⁻¹' t)
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} [inhabited Λ] {σ : Type u_4} [inhabited σ] : turing.TM2.stmt Γ Λ σ → finset turing.TM2to1.Λ'
{I : Type u} [decidable_eq I] {β : Type u_1} [has_one β] (i : I) (x : β) (i' : I) : pi.mul_single i x i' = ite (i' = i) x 1
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [I : is_noetherian R M] (f : ℕ → submodule R M) (h : ∀ (n : ℕ), disjoint (⇑(partial_sups f) n) (f (n + 1))) : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → f m = ⊥
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : ⇑is_R_or_C.im (has_inner.inner x y) = (∥x - is_R_or_C.I • y∥ * ∥x - is_R_or_C.I • y∥ - ∥x + is_R_or_C.I • y∥ * ∥x + is_R_or_C.I • y∥) / 4
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {μ : R} {k : ℕ} (hμ : f.has_generalized_eigenvalue μ k) : f.has_eigenvalue μ
(t : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic level
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {f g : α → ℝ} {s : set α} [measure_theory.sigma_finite μ] (f_int : measure_theory.integrable_on f s μ) (g_int : measure_theory.integrable_on g s μ) (hs : measurable_set s) (hfg : ∀ (x : α), x ∈ s → f x ≤ g x) : ⇑(μ.prod measure_theory.measure_space.volume) (region_between f g s) = ennreal.of_real (∫ (y : α) in s, (g - f) y ∂μ)
{R : Type u} {S₁ : Type v} {S₂ : Type w} {σ : Type u_1} [comm_semiring R] [comm_semiring S₁] [comm_semiring S₂] [algebra R S₁] [algebra R S₂] (f : S₁ →ₐ[R] S₂) : mv_polynomial σ S₁ →ₐ[R] mv_polynomial σ S₂
{ι : Type u_1} [fintype ι] {p : box_integral.box ι → Prop} (I : box_integral.box ι) (H_ind : ∀ (J : box_integral.box ι), J ≤ I → (∀ (J' : box_integral.box ι), J' ∈ box_integral.prepartition.split_center J → p J') → p J) (H_nhds : ∀ (z : ι → ℝ), z ∈ ⇑box_integral.box.Icc I → (∃ (U : set (ι → ℝ)) (H : U ∈ nhds_within z (⇑box_integral.box.Icc I)), ∀ (J : box_integral.box ι), J ≤ I → ∀ (m : ℕ), z ∈ ⇑box_integral.box.Icc J → ⇑box_integral.box.Icc J ⊆ U → (∀ (i : ι), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) → p J)) : p I
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [I : is_artinian R M] (f : M →ₗ[R] M) : ∃ (n : ℕ), n ≠ 0 ∧ (f ^ n).ker ⊔ (f ^ n).range = ⊤
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {a b : ℝ} {f : ℝ → E} {μ : measure_theory.measure ℝ} {ι : Type u_1} [encodable ι] {F : ι → ℝ → E} (bound : ι → ℝ → ℝ) (hF_meas : ∀ (n : ι), measure_theory.ae_strongly_measurable (F n) (μ.restrict (set.interval_oc a b))) (h_bound : ∀ (n : ι), ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → ∥F n t∥ ≤ bound n t) (bound_summable : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → summable (λ (n : ι), bound n t)) (bound_integrable : interval_integrable (λ (t : ℝ), ∑' (n : ι), bound n t) μ a b) (h_lim : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → has_sum (λ (n : ι), F n t) (f t)) : has_sum (λ (n : ι), ∫ (t : ℝ) in a..b, F n t ∂μ) (∫ (t : ℝ) in a..b, f t ∂μ)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} : ∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * ⇑is_R_or_C.re (has_inner.inner x y) + ∥y∥ ^ 2
{α : Type u_1} (l : filter α) (ε : α → Type u_2) : Type (max u_1 u_2)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x₀ : E} (hf : has_fderiv_at f f' x₀) {C : ℝ} (hC₀ : 0 ≤ C) (hlip : ∀ᶠ (x : E) in nhds x₀, ∥f x - f x₀∥ ≤ C * ∥x - x₀∥) : ∥f'∥ ≤ C
{J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {c c' : category_theory.limits.cone F} (φ : c.X ≅ c'.X) (w : ∀ (j : J), c.π.app j = φ.hom ≫ c'.π.app j) : c ≅ c'
{α : Type u} [preorder α] ⦃s t : set α⦄ (h : s ⊆ t) : bdd_below t → bdd_below s
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} (B : box_integral.box_additive_map ι ℝ ↑I) (hB0 : ∀ (J : box_integral.box ι), 0 ≤ ⇑B J) (g : box_integral.box_additive_map ι F ↑I) (H : nnreal → ∀ (x : ι → ℝ), x ∈ ⇑box_integral.box.Icc I → ∀ (ε : ℝ), ε > 0 → (∃ (δ : ℝ) (H : δ > 0), ∀ (J : box_integral.box ι), J ≤ I → ⇑box_integral.box.Icc J ⊆ metric.closed_ball x δ → has_dist.dist (⇑(⇑vol J) (f x)) (⇑g J) ≤ ε * ⇑B J)) : box_integral.has_integral I box_integral.integration_params.McShane f vol (⇑g I)
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {C r : nnreal} {f : X → Y} {s : set X} (h : holder_on_with C r f s) (hr : 0 < r) : dimH (f '' s) ≤ dimH s / ↑r
{α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} {S : set (set α)} (hc : S.countable) (hs : ⋃₀S = set.univ) : (∀ (s : set α), s ∈ S → μ.restrict s = ν.restrict s) → μ = ν
{R : Type u} [comm_ring R] (I : ideal R) : R →+* R ⧸ I
{α : Type u_1} [decidable_eq α] {s : finset α} {p : Π (t : finset α), t ⊂ s → Prop} [Π (t : finset α) (h : t ⊂ s), decidable (p t h)] : decidable (∀ (t : finset α) (h : t ⊂ s), p t h)
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) (ν : measure_theory.measure α) (hν : ν.absolutely_continuous μ) : vitali_family ν
{p : ℕ+} {K : Type u} {L : Type v} [field L] {ζ : L} [field K] [algebra K L] [ne_zero ↑↑p] {k : ℕ} (hζ : is_primitive_root ζ ↑(p ^ (k + 1))) [hpri : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic ↑(p ^ (k + 1)) K)) {s : ℕ} (hs : s ≤ k) (hodd : p ≠ 2) : ⇑(algebra.norm K) (ζ ^ ↑p ^ s - 1) = ↑p ^ ↑p ^ s
{R : Type u_1} {V : Type u_2} {W : Type u_3} {P : Type u_4} {Q : Type u_5} [ring R] [add_comm_group V] [module R V] [topological_space P] [add_torsor V P] [add_comm_group W] [module R W] [topological_space Q] [add_torsor W Q] (f : P →A[R] Q) : C(P, Q)
{R : Type u} [comm_ring R] (I : ideal R) : I.is_maximal ↔ is_field (R ⧸ I)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {s : set M} {m n : with_top ℕ} (hf : cont_mdiff_on I I' n f s) (hmn : m + 1 ≤ n) (hs : unique_mdiff_on I s) : cont_mdiff_on I.tangent I'.tangent m (tangent_map_within I I' f s) (tangent_bundle.proj I M ⁻¹' s)
(M₂ : Type v₂) (M₃ : Type v₃) [add_comm_monoid M₂] (R' : Type u_1) (A : Type u_2) [semiring R'] [semiring A] [module A M₂] [add_comm_monoid M₃] [module R' M₃] [module A M₃] [smul_comm_class A R' M₃] {ι₁ : Type u_3} {ι₂ : Type u_4} [decidable_eq ι₁] [decidable_eq ι₂] (σ : ι₁ ≃ ι₂) : multilinear_map A (λ (i : ι₁), M₂) M₃ ≃ₗ[R'] multilinear_map A (λ (i : ι₂), M₂) M₃
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] [measurable_space β] [measurable_space γ] {μ : measure_theory.measure α} {ν : measure_theory.measure β} {f : α → γ} {g : β → γ} [topological_space γ] [topological_space.metrizable_space γ] [opens_measurable_space γ] [topological_space.second_countable_topology γ] (h : probability_theory.ident_distrib f g μ ν) : measure_theory.ae_strongly_measurable f μ
{α : Type u_1} (E : Type u_2) {m0 : measurable_space α} (p : ennreal) (μ : measure_theory.measure α) [normed_group E] (𝕜 : Type u_5) [normed_field 𝕜] [normed_space 𝕜 E] : submodule 𝕜 (α →ₘ[μ] E)
{α : Type u} {β : Type v} {φ : ultrafilter α} [field β] : field (↑φ.germ β)
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} [measure_theory.sigma_finite μ] {f : α → β → ennreal} (hf : measurable (function.uncurry f)) : measurable (λ (y : β), ∫⁻ (x : α), f x y ∂μ)
(w : widget.component tactic_state empty) (text : string := "(widget)") : tactic unit
{P : pfunctor} {α : Type u} (F : Π {X : Type u}, (α → X) → α → P.M ⊕ P.obj X) (x : α) : P.M
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] {W X Y Z : C} [category_theory.monoidal_category.lift_obj X] [category_theory.monoidal_category.lift_obj Y] [category_theory.monoidal_category.monoidal_coherence X Y] (f : W ≅ X) (g : Y ≅ Z) : W ≅ Z
{C : Type u₁} [𝒞 : category_theory.enriched_category (Type v) C] {D : Type u₂} [𝒟 : category_theory.enriched_category (Type v) D] : category_theory.enriched_functor (Type v) C D ≃ C ⥤ D
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] (μ : measure_theory.measure G) [measure_theory.sigma_finite μ] [μ.is_mul_left_invariant] (K₀ : topological_space.positive_compacts G) : μ = ⇑μ ↑K₀ • measure_theory.measure.haar_measure K₀
{C : Type u} [category_theory.category C] (L : Π (X Y : C), category_theory.limits.limit_cone (category_theory.limits.pair X Y)) (X Y Z : C) : (L (L X Y).cone.X Z).cone.X ≅ (L X (L Y Z).cone.X).cone.X
(α : Type u) (β : Type v) [add_group α] [add_action α β] [fintype α] [fintype β] [fintype (quotient (add_action.orbit_rel α β))] [Π (b : β), fintype ↥(add_action.stabilizer α b)] {φ : quotient (add_action.orbit_rel α β) → β} (hφ : function.left_inverse quotient.mk' φ) : fintype.card β = finset.univ.sum (λ (ω : quotient (add_action.orbit_rel α β)), fintype.card α / fintype.card ↥(add_action.stabilizer α (φ ω)))
(e : interactive.parse interactive.types.texpr) (cfg : tactic.equiv_rw_cfg := {max_depth := 10}) : tactic.interactive.itactic
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set V} (p : P) (h : submodule.span k (set.range coe) = ⊤) : affine_span k ({p} ∪ (λ (v : V), v +ᵥ p) '' s) = ⊤
{X : ℕ → Type u} [Π (n : ℕ), metric_space (X n)] {f : Π (n : ℕ), X n → X (n + 1)} (I : ∀ (n : ℕ), isometry (f n)) : pseudo_metric_space (Σ (n : ℕ), X n)
(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] [nontrivial M] : ¬0.nondegenerate
{E : Type u_4} {F : Type u_5} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] [normed_group F] [normed_space ℝ F] {f : E → F} {s t : set E} (hf : cont_diff_on ℝ 1 f s) (hc : convex ℝ s) (ht : t ⊆ s) : dimH (f '' t) ≤ dimH t
{R : Type u} [comm_ring R] (I J : ideal R) : (R ⧸ I) ⧸ ideal.map (ideal.quotient.mk I) J →+* R ⧸ I ⊔ J
(h : expr) (ns : list name := list.nil) (rec : option name := option.none) (md : tactic.transparency := tactic.transparency.semireducible) : tactic (list (name × list expr × list (name × expr)))
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} [measure_theory.is_finite_measure μ] {f : α → ℝ} (hfm : measure_theory.strongly_measurable f) (hf : measure_theory.integrable f μ) (hf_zero : ∀ (s : set α), measurable_set s → 0 ≤ ∫ (x : α) in s, f x ∂μ) : 0 ≤ᵐ[μ] f
{𝕜 : Type u_1} {E : Type u_4} [semi_normed_group E] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] : ∥continuous_linear_map.id 𝕜 E∥ ≤ 1
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] (s : set M) (x : M) : Prop
(e : expr) (md : tactic.transparency := tactic.transparency.instances) : tactic expr
{α : Type u} [pseudo_emetric_space α] (E : set α) (s : set ℝ) (hs₀ : s ⊆ set.Ioi 0) (hs : ∀ (ε : ℝ), 0 < ε → (s ∩ set.Ioc 0 ε).nonempty) : closure E = ⋂ (δ : ℝ) (H : δ ∈ s), metric.thickening δ E
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] {E : set G} [has_measurable_inv G] [μ.is_mul_left_invariant] [ν.is_mul_left_invariant] (Em : measurable_set E) (h2E : ⇑ν E ≠ 0) (h3E : ⇑ν E ≠ ⊤) (f : G → ennreal) (hf : measurable f) : ⇑μ E * ∫⁻ (y : G), f y⁻¹ / ⇑ν ((λ (x : G), x * y⁻¹) ⁻¹' E) ∂ν = ∫⁻ (x : G), f x ∂μ
{G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure G} [group G] [has_measurable_mul G] [μ.is_mul_right_invariant] (f : G → E) (g : G) : ∫ (x : G), f (x * g) ∂μ = ∫ (x : G), f x ∂μ
{ι : Type u_10} {R : Type u_11} {R₂ : Type u_12} {M : Type u_13} {M₂ : Type u_14} [semiring R] [semiring R₂] [add_comm_monoid M] [module R M] [add_comm_monoid M₂] [module R₂ M₂] [topological_space M] [topological_space M₂] {σ : R →+* R₂} {f : ι → M} (φ : M →SL[σ] M₂) (hf : summable f) : summable (λ (b : ι), ⇑φ (f b))
{I : Type u} {f : I → Type v} {γ : Type w} [Π (i : I), non_assoc_semiring (f i)] [non_assoc_semiring γ] (g : Π (i : I), γ →+* f i) : γ →+* Π (i : I), f i
{α : Type u} [pseudo_metric_space α] {s : set α} [discrete_topology ↥s] {x : α} (hx : x ∈ s) : ∃ (ε : ℝ) (H : ε > 0), metric.ball x ε ∩ s = {x}
{α : Type u_1} {E : Type u_4} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} [measurable_space E] (f : ↥(measure_theory.Lp.simple_func E p μ)) : measurable ⇑(measure_theory.Lp.simple_func.to_simple_func f)
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} (s : finset β) {f : α → β} (hf : ∀ (y : β), y ∈ s → measurable_set (f ⁻¹' {y})) : s.sum (λ (b : β), ⇑μ (f ⁻¹' {b})) = ⇑μ (f ⁻¹' ↑s)
{α : Type u_2} {m0 : measurable_space α} {μ : measure_theory.measure α} {t : set α} (s : set α) (ht : measure_theory.null_measurable_set t μ) : ⇑μ (s ∩ t) + ⇑μ (s  t) = ⇑μ s
{V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (B : bilin_form K V) (b : B.nondegenerate) (ψ φ : V →ₗ[K] V) : B.is_adjoint_pair B ψ φ ↔ ψ = B.left_adjoint_of_nondegenerate b φ
{α : Type u_1} {s : finset α} {σ : equiv.perm α} (hs : {a : α | ⇑σ a ≠ a} ⊆ ↑s) : finset.map ↑σ s = s
(n : interactive.parse (optional (interactive.with_desc ↑"n" lean.parser.small_nat))) : interactive.parse (optional (lean.parser.tk "with" *> prod.mkprod.mkfunctor.map <$> lean.parser.many tactic.rintro_patt_parse_hi <*> optional (lean.parser.tk ":" *> lean.parser.small_nat))) → tactic unit
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (BR : ring_filter_basis R) (BM : add_group_filter_basis M) (smul : ∀ {U : set M}, U ∈ BM → (∃ (V : set R) (H : V ∈ BR) (W : set M) (H : W ∈ BM), V • W ⊆ U)) (smul_left : ∀ (x₀ : R) {U : set M}, U ∈ BM → (∃ (V : set M) (H : V ∈ BM), V ⊆ (λ (x : M), x₀ • x) ⁻¹' U)) (smul_right : ∀ (m₀ : M) {U : set M}, U ∈ BM → (∃ (V : set R) (H : V ∈ BR), V ⊆ (λ (x : R), x • m₀) ⁻¹' U)) : module_filter_basis R M
{α : Type u₁} {β : Type u₂} {φ : Type u₃} : (α → β → φ) → α × β → φ
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →SL[σ₁₂] F) {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ (x : E), ∥⇑f x∥ ≤ M * ∥x∥) : ∥f∥ ≤ M
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {X : C} {S : J.cover X} {T : Π (I : S.arrow), J.cover I.Y} (I : (S.bind T).arrow) : C
{α : Type u_1} (F : Type u_6) [normed_group F] (m : measurable_space α) [measurable_space α] (p : ennreal) (μ : measure_theory.measure α) : add_subgroup ↥(measure_theory.Lp F p μ)
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G →g G') (e : ↥(G.edge_set)) : ↥(G'.edge_set)
{α : Type u_1} {β : Type u_2} {m0 : measurable_space α} [measurable_space β] {μ : measure_theory.measure α} {f : α → β} (hf : ae_measurable f μ) {s : set β} (hs : measurable_set s) : ⇑(measure_theory.measure.map f μ) s = ⇑μ (f ⁻¹' s)
{E : Type u_3} [has_norm E] [add_comm_group E] [pseudo_metric_space E] (H1 : ∀ (x : E), ∥x∥ = has_dist.dist x 0) (H2 : ∀ (x y z : E), has_dist.dist (x + z) (y + z) ≤ has_dist.dist x y) : semi_normed_group E
{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] {σ : R →+* R} [ring_hom_surjective σ] {ι : Sort u_2} (f : M →ₛₗ[σ] M) {p : ι → submodule R M} (hf : ∀ (i : ι) (v : M), v ∈ p i → ⇑f v ∈ p i) (v : M) (H : v ∈ infi p) : ⇑f v ∈ infi p
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {x : E} {s : set E} {t : set F} {y : F} (ht : y ∈ closure t) : ⇑(linear_map.inl 𝕜 E F) '' tangent_cone_at 𝕜 s x ⊆ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G ≃g G') : ↥(G.edge_set) ≃ ↥(G'.edge_set)
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : ℕ → α → ennreal} {F : α → ennreal} (hf : ∀ (n : ℕ), ae_measurable (f n) μ) (h_mono : ∀ᵐ (x : α) ∂μ, monotone (λ (n : ℕ), f n x)) (h_tendsto : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (nhds (F x))) : filter.tendsto (λ (n : ℕ), ∫⁻ (x : α), f n x ∂μ) filter.at_top (nhds (∫⁻ (x : α), F x ∂μ))
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] {f : E → F} {p : formal_multilinear_series 𝕜 E F} {x : E} {r r' : ennreal} (hf : has_fpower_series_on_ball f p x r) (hr : r' < r) : ∃ (C : ℝ), ∀ (y : E), y ∈ emetric.ball x r' → ∀ (z : E), z ∈ emetric.ball x r' → ∥f y - f z - ⇑(p 1) (λ (_x : fin 1), y - z)∥ ≤ C * linear_order.max ∥y - x∥ ∥z - x∥ * ∥y - z∥
{ι : Type v} [dec_ι : decidable_eq ι] {β : ι → Type w} [Π (i : ι), add_comm_monoid (β i)] {γ : Type u₁} [add_comm_monoid γ] (φ : Π (i : ι), β i →+ γ) : direct_sum ι (λ (i : ι), β i) →+ γ
{I : Type u_1} {A : Type u_2} {X : I → Type u_3} [Π (i : I), topological_space (X i)] [topological_space A] {f g : Π (i : I), C(A, X i)} {S : set A} (homotopies : Π (i : I), (f i).homotopy_rel (g i) S) : (continuous_map.pi f).homotopy_rel (continuous_map.pi g) S
{p x : ℝ} (h : liouville_with p x) : ∃ (C : ℝ) (h₀ : 0 < C), ∃ᶠ (n : ℕ) in filter.at_top, 1 ≤ n ∧ ∃ (m : ℤ), x ≠ ↑m / ↑n ∧ |x - ↑m / ↑n| < C / ↑n ^ p
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] {W X Y Z : C} (f : W ⟶ Y) (g : X ⟶ Z) [category_theory.is_iso (category_theory.limits.biprod.map f g)] : category_theory.is_iso f
{G : Type u} [add_group G] {H : Type v} [add_group H] (φ : G →+ H) : G ⧸ φ.ker →+ H
{K : Type u_1} [field K] {ζ : K} {n : ℕ} (h : is_primitive_root ζ n) : polynomial.splits (ring_hom.id K) (polynomial.X ^ n - ⇑polynomial.C 1)
{σ : Type u_1} {τ : Type u_2} {R : Type u_4} [comm_semiring R] (f : mv_polynomial σ R ≃ₐ[R] mv_polynomial τ R) : (τ → R) ≃ (σ → R)
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] {σ : Type u_3} [inhabited σ] (M : Λ → turing.TM1.stmt Γ Λ σ) [fintype σ] (S : finset Λ) : finset (turing.TM1to0.Λ' M)
(post : expr → tactic (expr × expr)) (e : expr) (cfg : tactic.simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}) : tactic (expr × expr)
{α : Type u_1} {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) [measure_theory.sigma_finite (μ.trim hm)] (C : ennreal) {f : α → ennreal} (hf_meas : measurable f) (hf : ∀ (s : set α), measurable_set s → ⇑μ s ≠ ⊤ → ∫⁻ (x : α) in s, f x ∂μ ≤ C) : ∫⁻ (x : α), f x ∂μ ≤ C
{R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] {e : ι → M} {ε : ι → module.dual R M} [decidable_eq ι] (h : dual_pair e ε) : basis ι R M
{α : Type u} [pseudo_emetric_space α] {ε : ℝ} (hε : 0 ≤ ε) (δ : ℝ) (s : set α) : metric.cthickening ε (metric.thickening δ s) ⊆ metric.cthickening (ε + δ) s
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {f' : α → E'} {g' : α → F'} {l : filter α} : ((λ (x : α), ∥f' x∥) =o[l] λ (x : α), ∥g' x∥) → f' =o[l] g'
(args : list (name × option name × expr)) (md : tactic.transparency := tactic.transparency.semireducible) (unify : bool := bool.tt) : tactic unit
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] [measurable_space β] [measurable_space γ] {μ : measure_theory.measure α} {ν : measure_theory.measure β} {f : α → γ} {g : β → γ} (h : probability_theory.ident_distrib f g μ ν) {s : set γ} (hs : measurable_set s) : ⇑μ (f ⁻¹' s) = ⇑ν (g ⁻¹' s)
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z} [category_theory.limits.preserves_colimit (category_theory.limits.span f g) F] (s : category_theory.is_pushout f g h i) : category_theory.is_pushout (F.map f) (F.map g) (F.map h) (F.map i)
{G : Type u_1} [measurable_space G] [group G] [topological_space G] (μ : measure_theory.measure G) [μ.is_haar_measure] [sigma_compact_space G] : measure_theory.sigma_finite μ
{α : Type u_1} {β : Type u_2} [add_monoid β] [decidable_eq α] {s t : finset α} (h : disjoint s t) (f : α → β) (comm : ∀ (x : α), x ∈ s ∪ t → ∀ (y : α), y ∈ s ∪ t → add_commute (f x) (f y)) (scomm : (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → add_commute (f x) (f y)) := _) (tcomm : (∀ (x : α), x ∈ t → ∀ (y : α), y ∈ t → add_commute (f x) (f y)) := _) : (s ∪ t).noncomm_sum f comm = s.noncomm_sum f scomm + t.noncomm_sum f tcomm
{α : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space α} (p : ennreal) (μ : measure_theory.measure α) [normed_group E] [normed_group F] {𝕜 : Type u_5} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 F] [fact (1 ≤ p)] (L : E →L[𝕜] F) : ↥(measure_theory.Lp E p μ) →L[𝕜] ↥(measure_theory.Lp F p μ)
{α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : monotone_on f s) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : f '' s ∈ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a
{α : Type u_1} [non_unital_semi_normed_ring α] (x y : α) : ∥⇑(add_monoid_hom.mul_left x) y∥ ≤ ∥x∥ * ∥y∥
{R : Type u} [comm_ring R] (I : ideal R) (f : polynomial R) : adjoin_root f ⧸ ideal.map (adjoin_root.of f) I ≃+* adjoin_root f ⧸ ideal.map (ideal.quotient.mk (ideal.span {f})) (ideal.map polynomial.C I)
{E : Type u} [normed_group E] [normed_space ℂ E] [complete_space E] {f : ℂ → E} {s : set ℂ} {c : ℂ} (hc : s ∈ nhds c) (hd : differentiable_on ℂ f (s  {c})) (hb : bdd_above (has_norm.norm ∘ f '' (s  {c}))) : differentiable_on ℂ (function.update f c (lim (nhds_within c {c}ᶜ) f)) s
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) (h : W ⟶ X) (k : W ⟶ Y) (H₁ : category_theory.limits.is_terminal Z) (H₂ : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk h k _)) : category_theory.limits.is_limit (category_theory.limits.binary_fan.mk h k)
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f (⇑σ i) * g i) ≤ s.sum (λ (i : ι), f i * g i)
{E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : ℝ → ℝ} (ha : ∥f a∥ ≤ B a) (hB : ∀ (x : ℝ), has_deriv_at B (B' x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥f x∥ = B x → ∥f' x∥ < B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → ∥f x∥ ≤ B x
{𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [μ.is_add_left_invariant] [μ.is_neg_invariant] [topological_space.second_countable_topology G] (hcf : has_compact_support f) (hf : continuous f) (hg : measure_theory.integrable g μ) : continuous (convolution f g L μ)
{α : Type u_1} [preorder α] {f : α → α} {x : α} (hf : monotone f) (hx : f x ≤ x) : antitone (λ (n : ℕ), f^[n] x)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {n : with_top ℕ} {E'' : Type u_14} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {g : M' → M''} (x : M) (hg : cont_mdiff_at I' I'' n g (f x)) (hf : cont_mdiff_at I I' n f x) : cont_mdiff_at I I'' n (g ∘ f) x
{ι : Type u_1} [fintype ι] (l : box_integral.integration_params) (I : box_integral.box ι) (c : nnreal) : filter (box_integral.tagged_prepartition I)
{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] ⦃f g : one_hom M N⦄ (h : ⇑f = ⇑g) : f = g
{ι : Type u_1} {α : ι → Type u_3} [fintype ι] [h : Π (i : ι), measurable_space (α i)] {C : Π (i : ι), set (set (α i))} (hC : ∀ (i : ι), measurable_space.generate_from (C i) = h i) (h2C : ∀ (i : ι), is_countably_spanning (C i)) : measurable_space.generate_from (set.univ.pi '' set.univ.pi C) = measurable_space.pi
{σ : Type u_1} {R : Type u_2} [ring R] (a : R) (φ : mv_power_series σ R) : mv_power_series σ R
{C : Type u₂} [category_theory.category C] {I : Type u₁} {F G : category_theory.discrete I ⥤ C} (f : Π (i : category_theory.discrete I), F.obj i ⟶ G.obj i) : F ⟶ G
{α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : monotone_on f s) (hs : s ∈ nhds a) (hfs : closure (f '' s) ∈ nhds (f a)) : continuous_at f a
{R : Type u_1} {M : Type u_2} [comm_ring R] [comm_monoid M] [nontrivial R] {m : M} {S : set M} : ⇑(monoid_algebra.of R M) m ∈ submodule.span R (⇑(monoid_algebra.of R M) '' S) ↔ m ∈ S
{R : Type u} {S : Type v} [ring R] [ring S] (I : ideal (R × S)) : I = (ideal.map (ring_hom.fst R S) I).prod (ideal.map (ring_hom.snd R S) I)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {y : E} {α : Type u_3} (l : filter α) {c : α → 𝕜} {d : α → E} (hc : filter.tendsto (λ (n : α), ∥c n∥) l filter.at_top) (hd : filter.tendsto (λ (n : α), c n • d n) l (nhds y)) : filter.tendsto d l (nhds 0)
{L : first_order.language} {ι : Type v} [preorder ι] (G : ι → Type w) [Π (i : ι), L.Structure (G i)] (f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)) [is_directed ι has_le.le] [nonempty ι] : L.Structure (Σ (i : ι), G i)
{ι : Type u_1} {I J : box_integral.box ι} (π : box_integral.prepartition I) {πi : Π (J : box_integral.box ι), box_integral.prepartition J} (hJ : J ∈ π) {J' : box_integral.box ι} (hJ' : J' ∈ πi J) : π.bUnion_index πi J' = J
{C : Type u} [category_theory.category C] {W X Y Z : C} [category_theory.limits.has_binary_coproduct W X] [category_theory.limits.has_binary_coproduct Y Z] (f : W ≅ Y) (g : X ≅ Z) : W ⨿ X ≅ Y ⨿ Z
{R : Type u} {σ : Type u_1} [comm_semiring R] [subsingleton R] : unique (mv_polynomial σ R)
(μ : measure_theory.measure ℝ) [measure_theory.is_locally_finite_measure μ] : μ.finite_spanning_sets_in (⋃ (a b : ℚ) (h : a < b), {set.Ioo ↑a ↑b})
{α : Type u_1} {mα : measurable_space α} {μ : measure_theory.measure α} [measure_theory.is_finite_measure μ] {β : Type u_2} {β' : Type u_3} {mβ : measurable_space β} {mβ' : measurable_space β'} {f : α → β} {g : α → β'} {hfm : measurable f} {hgm : measurable g} : probability_theory.indep_fun f g μ ↔ ∀ {φ : β → ℝ} {ψ : β' → ℝ}, measurable φ → measurable ψ → measure_theory.integrable (φ ∘ f) μ → measure_theory.integrable (ψ ∘ g) μ → measure_theory.integral μ (φ ∘ f * ψ ∘ g) = measure_theory.integral μ (φ ∘ f) * measure_theory.integral μ (ψ ∘ g)
{𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {f' : F} : has_deriv_at f f' x ↔ has_fderiv_at f (1.smul_right f') x
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : multilinear_map 𝕜 E G) {C : ℝ} (hC : 0 ≤ C) (H : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) (m₁ m₂ : Π (i : ι), E i) : ∥⇑f m₁ - ⇑f m₂∥ ≤ C * finset.univ.sum (λ (i : ι), finset.univ.prod (λ (j : ι), ite (j = i) ∥m₁ i - m₂ i∥ (linear_order.max ∥m₁ j∥ ∥m₂ j∥)))
(α : Type u) (β : Type v) [group α] [mul_action α β] [fintype α] [fintype β] [fintype (quotient (mul_action.orbit_rel α β))] [Π (b : β), fintype ↥(mul_action.stabilizer α b)] {φ : quotient (mul_action.orbit_rel α β) → β} (hφ : function.left_inverse quotient.mk' φ) : fintype.card β = finset.univ.sum (λ (ω : quotient (mul_action.orbit_rel α β)), fintype.card α / fintype.card ↥(mul_action.stabilizer α (φ ω)))
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {s : set α} {t : set β} {f : α' → β → γ} {g : α → α'} {f' : β → α → δ} {g' : δ → γ} (h_left_anticomm : ∀ (a : α) (b : β), f (g a) b = g' (f' b a)) : set.image2 f (g '' s) t = g' '' set.image2 f' t s
{α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {δ : Type u_1} [linear_order δ] [topological_space δ] [order_closed_topology δ] {a b : α} {f : α → δ} (hf : continuous_on f (set.interval a b)) : set.interval (f a) (f b) ⊆ f '' set.interval a b
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {G : D ⥤ C} {F_obj : C → D} (e : Π (X : C) (Y : D), (F_obj X ⟶ Y) ≃ (X ⟶ G.obj Y)) (he : ∀ (X : C) (Y Y' : D) (g : Y ⟶ Y') (h : F_obj X ⟶ Y), ⇑(e X Y') (h ≫ g) = ⇑(e X Y) h ≫ G.map g) : C ⥤ D
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [t2_space β] (f : cocompact_map α β) ⦃s : set β⦄ (hs : is_compact s) : is_compact (⇑f ⁻¹' s)
{G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {μ : measure_theory.measure G} [add_group G] [topological_add_group G] [μ.is_add_left_invariant] (U : set G) (hU : is_open U) (h'U : U.nonempty) (h : ⇑μ U ≠ ⊤) {K : set G} (hK : is_compact K) : ⇑μ K < ⊤
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [nonempty J] {P : C} (π : Y ⟶ P) (w : ∀ (j₁ j₂ : J), f j₁ ≫ π = f j₂ ≫ π) : category_theory.limits.cotrident f
{X Y Z : Type u} (f g : X ⟶ Y) (π : Y ⟶ Z) (e : f ≫ π = g ≫ π) (h : category_theory.limits.is_colimit (category_theory.limits.cofork.of_π π e)) (U : set Y) (H : f ⁻¹' U = g ⁻¹' U) : π ⁻¹' (π '' U) = U
{F : Type u_3} [inner_product_space ℝ F] {ι₁ : Type u_1} {s₁ : finset ι₁} {w₁ : ι₁ → ℝ} (v₁ : ι₁ → F) (h₁ : s₁.sum (λ (i : ι₁), w₁ i) = 0) {ι₂ : Type u_2} {s₂ : finset ι₂} {w₂ : ι₂ → ℝ} (v₂ : ι₂ → F) (h₂ : s₂.sum (λ (i : ι₂), w₂ i) = 0) : has_inner.inner (s₁.sum (λ (i₁ : ι₁), w₁ i₁ • v₁ i₁)) (s₂.sum (λ (i₂ : ι₂), w₂ i₂ • v₂ i₂)) = -s₁.sum (λ (i₁ : ι₁), s₂.sum (λ (i₂ : ι₂), w₁ i₁ * w₂ i₂ * (∥v₁ i₁ - v₂ i₂∥ * ∥v₁ i₁ - v₂ i₂∥))) / 2
{E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {f : E → G} {C : ℝ} {s : set E} {x y : E} {φ : E →L[𝕜] G} (hf : ∀ (x : E), x ∈ s → differentiable_at 𝕜 f x) (bound : ∀ (x : E), x ∈ s → ∥fderiv 𝕜 f x - φ∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x - ⇑φ (y - x)∥ ≤ C * ∥y - x∥
{α : Type u_1} {m0 : measurable_space α} (μ : measure_theory.measure α) [measure_theory.sigma_finite μ] (i : ℕ) : set α
{α : Type u_1} {ι : Type u_5} {m : measurable_space α} {μ : measure_theory.measure α} [encodable ι] {s : ι → set α} (h : ∀ (i : ι), measurable_set (s i)) (hd : directed superset s) (hfin : ∃ (i : ι), ⇑μ (s i) ≠ ⊤) : ⇑μ (⋂ (i : ι), s i) = ⨅ (i : ι), ⇑μ (s i)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [nontrivial k] {p : ι → P} (ha : affine_independent k p) {s1 s2 : set ι} (hd : s1 ∩ s2 = ∅) : ↑(affine_span k (p '' s1)) ∩ ↑(affine_span k (p '' s2)) = ∅
(classical : interactive.parse (optional (lean.parser.tk "!"))) : interactive.parse (optional (option.someoption.somefunctor.map <$> interactive.types.pexpr_listinteractive.types.pexpr_list <|> lean.parser.tk "*" *> has_pure.pure option.none)) → tactic unit
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} [topological_space α] [locally_compact_space α] [measure_theory.is_finite_measure_on_compacts μ] : measure_theory.is_locally_finite_measure μ
{α : Sort u_1} {β : Sort u_2} {r : α → α → Prop} {s : β → β → Prop} {φ : quot r → quot s → Sort u_3} [h : ∀ (a : α) (b : β), subsingleton (φ (quot.mk r a) (quot.mk s b))] (q₁ : quot r) (q₂ : quot s) (f : Π (a : α) (b : β), φ (quot.mk r a) (quot.mk s b)) : φ q₁ q₂
{α : Type u_1} [measurable_space α] [topological_space α] (μ : measure_theory.measure α) : Prop
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) ⦃ι : Type v⦄ (U : ι → topological_space.opens ↥X) : category_theory.limits.cone ((category_theory.pairwise.diagram U).op ⋙ F) ≌ category_theory.limits.cone (Top.presheaf.sheaf_condition_equalizer_products.diagram F U)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_4} [topological_space H] {I : model_with_corners 𝕜 E H} {N : Type u_6} [topological_space N] [charted_space H N] {A : Type u_10} [normed_ring A] [normed_algebra 𝕜 A] [smooth_ring (model_with_corners_self 𝕜 A) A] : 𝕜 →+* cont_mdiff_map I (model_with_corners_self 𝕜 A) N A ⊤
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (μ : R) (k : ℕ) : submodule R M
{α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : closure (f '' s) ∈ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a
{C : Type u_1} [category_theory.category C] (r : hom_rel C) ⦃a b c : category_theory.quotient r⦄ : category_theory.quotient.hom r a b → category_theory.quotient.hom r b c → category_theory.quotient.hom r a c
{G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G → E'} [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ E'] [inner_product_space ℝ G] [complete_space E'] {φ : cont_diff_bump_of_inner 0} [borel_space G] [measure_theory.is_locally_finite_measure μ] [μ.is_open_pos_measure] [finite_dimensional ℝ G] {x₀ : G} (hg : ∀ (x : G), x ∈ metric.ball x₀ φ.R → g x = g x₀) : convolution (φ.normed μ) g (continuous_linear_map.lsmul ℝ ℝ) μ x₀ = g x₀
{α : Type u_1} [topological_space α] {m : measurable_space α} [topological_space.second_countable_topology α] [conditionally_complete_linear_order α] [order_topology α] [borel_space α] [no_min_order α] (μ ν : measure_theory.measure α) [measure_theory.is_locally_finite_measure μ] (h : ∀ ⦃a b : α⦄, a < b → ⇑μ (set.Ioc a b) = ⇑ν (set.Ioc a b)) : μ = ν
{α : Type u_2} [measurable_space α] {f : α → α} {s : set α} {μ : measure_theory.measure α} (hf : measure_theory.conservative f μ) (hs : measurable_set s) (h0 : ⇑μ s ≠ 0) (N : ℕ) : ∃ (m : ℕ) (H : m > N), ⇑μ (s ∩ f^[m] ⁻¹' s) ≠ 0
{ι : Type u_1} [fintype ι] {I : box_integral.box ι} {π : box_integral.prepartition I} (h : π.is_partition) : ∃ (s : finset (ι × ℝ)), box_integral.prepartition.split_many I s ≤ π
{ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {ca cb : E} {la la' lb lb' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {ua va ub vb : ι → ℝ} [interval_integral.FTC_filter a la la'] [interval_integral.FTC_filter b lb lb'] [measure_theory.is_locally_finite_measure μ] (hab : interval_integrable f μ a b) (hmeas_a : strongly_measurable_at_filter f la' μ) (hmeas_b : strongly_measurable_at_filter f lb' μ) (ha_lim : filter.tendsto f (la' ⊓ μ.ae) (nhds ca)) (hb_lim : filter.tendsto f (lb' ⊓ μ.ae) (nhds cb)) (hua : filter.tendsto ua lt la) (hva : filter.tendsto va lt la) (hub : filter.tendsto ub lt lb) (hvb : filter.tendsto vb lt lb) : (λ (t : ι), ∫ (x : ℝ) in va t..vb t, f x ∂μ - ∫ (x : ℝ) in ua t..ub t, f x ∂μ - (∫ (x : ℝ) in ub t..vb t, cb ∂μ - ∫ (x : ℝ) in ua t..va t, ca ∂μ)) =o[lt] λ (t : ι), ∥∫ (x : ℝ) in ua t..va t, 1 ∂μ∥ + ∥∫ (x : ℝ) in ub t..vb t, 1 ∂μ∥
{ι : Type u_1} {α : ι → Type u_3} [fintype ι] [Π (i : ι), measurable_space (α i)] : measurable_space.generate_from (set.univ.pi '' set.univ.pi (λ (i : ι), {s : set (α i) | measurable_set s})) = measurable_space.pi
{P : Type u_1} [preorder P] (p : P) {ι : Type u_2} [encodable ι] (𝒟 : ι → order.cofinal P) : order.ideal P
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} {σ : Type u_4} [inhabited Λ] (M : Λ → turing.TM2.stmt Γ Λ σ) (S : finset Λ) : Prop
(𝕜 : Type u_5) (E : Type u_6) [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [nontrivial E] (c : ℝ) : ∃ (x : E), c < ∥x∥
{C : Π (n : ℕ), fin n → Sort u_1} (H0 : Π (n : ℕ), C n.succ 0) (Hs : Π (n : ℕ) (i : fin n), C n i → C n.succ i.succ) {n : ℕ} (i : fin n) : C n i
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] [has_measurable_inv G] [μ.is_mul_left_invariant] [ν.is_mul_left_invariant] (hν : ν ≠ 0) : μ.absolutely_continuous ν
{R : Type u_2} {A : Type u_3} [comm_semiring R] [non_unital_semiring A] [module R A] [smul_comm_class R A A] [is_scalar_tower R A A] {C : Type u_5} [ring C] [algebra R C] {φ ψ : unitization R A →ₐ[R] C} (h : φ.to_non_unital_alg_hom.comp (unitization.coe_non_unital_alg_hom R A) = ψ.to_non_unital_alg_hom.comp (unitization.coe_non_unital_alg_hom R A)) : φ = ψ
{α : Type u_1} {E : Type u_3} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} (s : set α) (f : ↥(measure_theory.Lp E p μ)) : ∥measure_theory.mem_ℒp.to_Lp ⇑f _∥ ≤ ∥f∥
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (G : C ⥤ D) {W X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} {h : W ⟶ X} {k : W ⟶ Y} (comm : h ≫ f = k ≫ g) : category_theory.limits.is_limit (G.map_cone (category_theory.limits.pullback_cone.mk h k comm)) ≃ category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk (G.map h) (G.map k) _)
{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] [is_noetherian R M] {P : submodule R M → Prop} (hgt : ∀ (I : submodule R M), (∀ (J : submodule R M), J > I → P J) → P I) (I : submodule R M) : P I
{α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} {p : set α → Prop} [μ.outer_regular] (H : μ.inner_regular p is_open) (h0 : p ∅) (hd : ∀ ⦃s U : set α⦄, p s → is_open U → p (s  U)) : μ.inner_regular p (λ (s : set α), measurable_set s ∧ ⇑μ s ≠ ⊤)
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : ∥⇑(quotient_add_group.mk' S) m∥ ≤ ∥m∥
(e : environment) (results : native.rb_map name string) (drop_fn_chars : ℕ := 0) (formatter : native.rb_map name string → format) : format
{V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (B : bilin_form K V) (b : B.nondegenerate) (φ : V →ₗ[K] V) : V →ₗ[K] V
(M : Type v) (ι : Type u_1 := punit) [add_comm_monoid M] [unique ι] : direct_sum ι (λ (_x : ι), M) ≃+ M
(α : Type u) (σ : Type v) : Type (max u v)
{α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : closure (f '' s) ∈ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a
{E : Type u} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {f' : E} {s : set ℝ} {x r : ℝ} (hf : has_deriv_within_at f f' s x) (hr : ∥f'∥ < r) : ∀ᶠ (z : ℝ) in nhds_within x s, ∥z - x∥⁻¹ * ∥f z - f x∥ < r
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ D] [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [Π (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)ᵒᵖ (category_theory.forget D)] {X : C} (P : Cᵒᵖ ⥤ D) (S : J.cover X) (x y : ↥((J.plus_obj P).obj (opposite.op X))) (h : ∀ (I : S.arrow), ⇑((J.plus_obj P).map I.f.op) x = ⇑((J.plus_obj P).map I.f.op) y) : x = y
{B : Type u₁} [quiver B] [Π (a b : B), quiver (a ⟶ b)] {C : Type u₂} [quiver C] [Π (a b : C), quiver (a ⟶ b)] (self : category_theory.prelax_functor B C) : prefunctor B C
{V : Type u} [fintype V] [decidable_eq V] (G : simple_graph V) [decidable_rel G.adj] (n k ℓ μ : ℕ) : Prop
(cache_ty param_ty : Type := unit) : Type
{α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.weakly_regular] ⦃U : set α⦄ (hU : is_open U) {r : ennreal} (hr : r < ⇑μ U) : ∃ (F : set α) (H : F ⊆ U), is_closed F ∧ r < ⇑μ F
{α : Type u_1} [metric_space α] [measurable_space α] [opens_measurable_space α] [topological_space.second_countable_topology α] (μ : measure_theory.measure α) [measure_theory.is_locally_finite_measure μ] (C : nnreal) (h : ∀ (x : α) (ε : ℝ), ε > 0 → (∃ (r : ℝ) (H : r ∈ set.Ioc 0 ε), ⇑μ (metric.closed_ball x (6 * r)) ≤ ↑C * ⇑μ (metric.closed_ball x r))) : vitali_family μ
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X ⟶ Y) [category_theory.limits.has_cokernel f] {W : C} (k : Y ⟶ W) (h : f ≫ k = 0) : {l // category_theory.limits.cokernel.π f ≫ l = k}
{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (I : ideal R) (N : submodule R M) (hn : N.fg) (hin : N ≤ I • N) : ∃ (r : R), r - 1 ∈ I ∧ ∀ (n : M), n ∈ N → r • n = 0
{V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] (f : normed_group_hom V₁ V₂) (x : V₁) : ∥⇑f x∥ ≤ ∥f∥ * ∥x∥
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f i * g (⇑σ i)) ≤ finset.univ.sum (λ (i : ι), f i * g i)
{m k p : ℕ} {R : Type u_1} [comm_ring R] [is_domain R] [hp : fact (nat.prime p)] [hchar : char_p R p] {μ : R} [ne_zero ↑m] : (polynomial.cyclotomic (p ^ k * m) R).is_root μ ↔ is_primitive_root μ m
{R : Type u} [comm_ring R] (I : ideal (polynomial R)) (x : ↥(((ideal.quotient.mk I).comp polynomial.C).range)) (hx : ⇑polynomial.C x ∈ ideal.map (polynomial.map_ring_hom ((ideal.quotient.mk I).comp polynomial.C).range_restrict) I) : x = 0
{R : Type u_1} [comm_ring R] : ideal.is_jacobson R ↔ ∀ {I : ideal R}, I.is_prime → (∃ (M : set (ideal R)), (∀ (J : ideal R), J ∈ M → J.is_maximal ∨ J = ⊤) ∧ I = has_Inf.Inf M)
{T : ℝ} {g : ℝ → ℝ} (hg : function.periodic g T) (h_int : ∀ (t₁ t₂ : ℝ), interval_integrable g measure_theory.measure_space.volume t₁ t₂) (hT : 0 < T) (t : ℝ) : has_Inf.Inf ((λ (t : ℝ), ∫ (x : ℝ) in 0..t, g x) '' set.Icc 0 T) + ⌊t / T⌋ • ∫ (x : ℝ) in 0..T, g x ≤ ∫ (x : ℝ) in 0..t, g x
{E : Type u_1} [normed_group E] [normed_space ℝ E] {f f' : ℝ → E} {δ K ε a b : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) (ha : ∥f a∥ ≤ δ) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥f' x∥ ≤ K * ∥f x∥ + ε) (x : ℝ) (H : x ∈ set.Icc a b) : ∥f x∥ ≤ gronwall_bound δ K ε (x - a)
{α : Type} [reflected α] [has_reflect α] (ns : name) (t : tactic α) (s : tactic.local_cache.internal.cache_scope := tactic.local_cache.cache_scope.block_local) : tactic α
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {n : with_top ℕ} {f : H → H'} {s : set H} (hf : cont_mdiff_on I I' n f s) (hn : 1 ≤ n) (hs : unique_mdiff_on I s) : continuous_on (tangent_map_within I I' f s) (tangent_bundle.proj I H ⁻¹' s)
{G : Type w} [topological_space G] (μ : measure_theory.content G) [t2_space G] (U : ℕ → topological_space.opens G) : μ.inner_content (⨆ (i : ℕ), U i) ≤ ∑' (i : ℕ), μ.inner_content (U i)
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {μ : R} {k : ℕ} (hk : 0 < k) : f.eigenspace μ ≤ ⇑(f.generalized_eigenspace μ) k
(h : expr) (base : name := name.mk_string "h" name.anonymous) (offset : option ℕ := option.some 1) : tactic (list expr)
{α : Type u_1} [fintype α] [decidable_eq α] (σ : equiv.perm α) : (fintype.card α).partition
{α : Type u_1} [metric_space α] [measurable_space α] [opens_measurable_space α] [topological_space.second_countable_topology α] (μ : measure_theory.measure α) [measure_theory.is_locally_finite_measure μ] (s : set α) (t : set (set α)) (hf : ∀ (x : α), x ∈ s → ∀ (ε : ℝ), ε > 0 → (∃ (a : set α) (H : a ∈ t), x ∈ a ∧ a ⊆ metric.closed_ball x ε)) (ht : ∀ (a : set α), a ∈ t → (interior a).nonempty) (h't : ∀ (a : set α), a ∈ t → is_closed a) (C : nnreal) (h : ∀ (a : set α), a ∈ t → (∃ (x : α) (H : x ∈ a), ⇑μ (metric.closed_ball x (3 * metric.diam a)) ≤ ↑C * ⇑μ a)) : ∃ (u : set (set α)) (H : u ⊆ t), u.countable ∧ u.pairwise_disjoint id ∧ ⇑μ (s  ⋃ (a : set α) (H : a ∈ u), a) = 0
{G : Type u_1} [measurable_space G] [has_neg G] (μ : measure_theory.measure G) : measure_theory.measure G
{α : Type u_1} {β : Type u_2} [topological_space β] {f : α → β} {m : measurable_space α} {μ : measure_theory.measure α} [measurable_space β] [topological_space.pseudo_metrizable_space β] [topological_space.second_countable_topology β] [opens_measurable_space β] (hf : measurable f) : measure_theory.ae_strongly_measurable f μ
{G : Type u} [add_group G] (N : add_subgroup G) [nN : N.normal] {H : Type v} [add_group H] (φ : G →+ H) (HN : ∀ (x : G), x ∈ N → ⇑φ x = 0) : G ⧸ N →+ H
{α : Type u} {β : Type v} (R : Type u_1) [comm_semiring R] (e : α ≃ β) [semiring β] [algebra R β] : let _inst : semiring α := e.semiring, _inst_4 : algebra R α := equiv.algebra R e in α ≃ₐ[R] β
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (v : F) (h : ∀ (i j : ι) (x : B), x ∈ Z.base_set i ∩ Z.base_set j → Z.coord_change i j x v = v) : continuous (show B → Z.total_space, from λ (x : B), ⟨x, v⟩)
{σ : Type u_1} (R : Type u_2) [comm_semiring R] (n : σ →₀ ℕ) : mv_power_series σ R →+ mv_polynomial σ R
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] [nontrivial E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) : module.End.has_eigenvalue T (↑⨆ (x : {x // x ≠ 0}), ⇑is_R_or_C.re (has_inner.inner (⇑T ↑x) ↑x) / ∥↑x∥ ^ 2)
{G₀ : Type u_1} {R : Type u_3} [comm_group_with_zero G₀] [comm_ring R] (φ : polynomial R →*₀ G₀) (hφ : non_zero_divisors (polynomial R) ≤ submonoid.comap ↑φ (non_zero_divisors G₀)) : ratfunc R →*₀ G₀
{α : Type u_1} {β : Type u_2} [has_mul α] [has_mul β] (f : α →ₙ* β) (I : Type u_3) : (I → α) →ₙ* I → β
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] [smooth_manifold_with_corners I M] [smooth_manifold_with_corners I' M'] (f : M → M') (x : M) (f' : tangent_space I x →L[𝕜] tangent_space I' (f x)) : Prop
{E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : ℝ → ℝ} (ha : ∥f a∥ ≤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at B (B' x) (set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥f x∥ = B x → ∥f' x∥ < B' x) ⦃x : ℝ⦄ : x ∈ set.Icc a b → ∥f x∥ ≤ B x
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {x : E} (hx : x ≠ 0) : ∥(↑∥x∥)⁻¹ • x∥ = 1
(t s : expr) (md : tactic.transparency := tactic.transparency.semireducible) (approx : bool := bool.ff) : tactic unit
{F : Type u_3} [inner_product_space ℝ F] (x : F) (r : ℝ) : has_inner.inner (r • x) x = r * (∥x∥ * ∥x∥)
{β : Type v} {ι : Type u_5} {σ : ι → Type u_6} [Π (i : ι), topological_space (σ i)] [topological_space β] {f : sigma σ → β} (h : ∀ (i : ι), continuous (λ (a : σ i), f ⟨i, a⟩)) : continuous f
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] {f : α → β → E} (hf : measure_theory.integrable (function.uncurry f) (μ.prod ν)) : ∫ (x : α), ∫ (y : β), f x y ∂ν ∂μ = ∫ (z : β × α), f z.snd z.fst ∂ν.prod μ
{α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.weakly_regular] {s : set α} (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) {ε : ennreal} (hε : ε ≠ 0) : ∃ (K : set α) (H : K ⊆ s), is_closed K ∧ ⇑μ s < ⇑μ K + ε
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f g : α → ennreal} (hle : f ≤ᵐ[μ] g) (hg : ae_measurable g μ) (ε : ennreal) : ∫⁻ (a : α), f a ∂μ + ε * ⇑μ {x : α | f x + ε ≤ g x} ≤ ∫⁻ (a : α), g a ∂μ
(name : module_info.module_name) (cur_module : module_info.module_id := "") : module_info.module_id
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_4} [topological_space H] {I : model_with_corners 𝕜 E H} {N : Type u_6} [topological_space N] [charted_space H N] {V : Type u_3} [normed_group V] [normed_space 𝕜 V] : cont_mdiff_map I (model_with_corners_self 𝕜 V) N V ⊤ →ₗ[𝕜] N → V
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {r : ℝ} (r_pos : 0 < r) (c : ℝ) (f : E →ₗ[𝕜] 𝕜) (h : ∀ (z : E), z ∈ metric.closed_ball 0 r → ∥⇑f z∥ ≤ c) (z : E) : ∥⇑f z∥ ≤ c / r * ∥z∥
{α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} {f : α → β} (hf : measure_theory.mem_ℒp f p μ) (hmeas : measure_theory.strongly_measurable f) {ε : ℝ} (hε : 0 < ε) : ∃ (M : ℝ), 0 < M ∧ measure_theory.snorm ({x : α | M ≤ ↑∥f x∥₊}.indicator f) p μ ≤ ennreal.of_real ε
{α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} [measure_theory.is_finite_measure μ] (hp : 1 ≤ p) (hp' : p ≠ ⊤) {f : ℕ → α → β} {g : α → β} (hf : ∀ (n : ℕ), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hg' : measure_theory.mem_ℒp g p μ) (hui : measure_theory.unif_integrable f p μ) (hfg : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (nhds (g x))) : filter.tendsto (λ (n : ℕ), measure_theory.snorm (f n - g) p μ) filter.at_top (nhds 0)
(t : interactive.parse interactive.types.texpr) (m : tactic.transparency := tactic.transparency.reducible) : tactic unit
{V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] (f : V₁ →+ V₂) {C : ℝ} (hC : 0 ≤ C) (h : ∀ (x : V₁), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_normed_group_hom C h∥ ≤ C
{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s t : set α} (Hf : antitone_on f t) (Hst : s ⊆ t) : (lower_bounds s ∩ t).nonempty → bdd_above (f '' s)
{C : Type u} [category_theory.category C] {W X Y : C} [category_theory.limits.has_binary_coproduct X Y] (f : X ⟶ W) (g : Y ⟶ W) : X ⨿ Y ⟶ W
{α : Type u_2} [measurable_space α] {f : α → α} {μ : measure_theory.measure α} [measure_theory.is_finite_measure μ] (h : measure_theory.measure_preserving f μ μ) : measure_theory.conservative f μ
{R : Type u_1} [semiring R] (φ : power_series R) : enat
{E : Type u_1} [normed_group E] [normed_space ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hd : diff_cont_on_cl ℂ f (set.Iio 0 ×ℂ set.Ioi 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal (set.Iio 0 ×ℂ set.Ioi 0)] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : ∀ (x : ℝ), x ≤ 0 → ∥f ↑x∥ ≤ C) (him : ∀ (x : ℝ), 0 ≤ x → ∥f (↑x * complex.I)∥ ≤ C) (hz_re : z.re ≤ 0) (hz_im : 0 ≤ z.im) : ∥f z∥ ≤ C
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_monoid M] [h : algebra.finite_type R (add_monoid_algebra R M)] : ∃ (G : finset M), algebra.adjoin R (add_monoid_algebra.of' R M '' ↑G) = ⊤
{ι : Type u_1} {p : box_integral.box ι → Prop} (I : box_integral.box ι) (H_ind : ∀ (J : box_integral.box ι), J ≤ I → (∀ (s : set ι), p (J.split_center_box s)) → p J) (H_nhds : ∀ (z : ι → ℝ), z ∈ ⇑box_integral.box.Icc I → (∃ (U : set (ι → ℝ)) (H : U ∈ nhds_within z (⇑box_integral.box.Icc I)), ∀ (J : box_integral.box ι), J ≤ I → ∀ (m : ℕ), z ∈ ⇑box_integral.box.Icc J → ⇑box_integral.box.Icc J ⊆ U → (∀ (i : ι), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) → p J)) : p I
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M →+ P} (hg : ∀ (y : ↥S), is_add_unit (⇑g ↑y)) (x : M) (y : ↥S) : ⇑(f.lift hg) (f.mk' x y) = ⇑g x + ↑-⇑(is_add_unit.lift_right (g.restrict S) hg) y
{𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_group G] [normed_space 𝕜 G] {f f' : 𝕜 → G} {s : set 𝕜} {x y : 𝕜} {C : ℝ} (hf : ∀ (x : 𝕜), x ∈ s → has_deriv_within_at f (f' x) s x) (bound : ∀ (x : 𝕜), x ∈ s → ∥f' x∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
{E : Type u_4} [normed_group E] [normed_space ℝ E] {b : ℝ} {f : ℕ → ℝ} {z : ℕ → E} (hfa : monotone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) (hgb : ∀ (n : ℕ), ∥(finset.range n).sum (λ (i : ℕ), z i)∥ ≤ b) : cauchy_seq (λ (n : ℕ), (finset.range (n + 1)).sum (λ (i : ℕ), f i • z i))
{α : Type u} {β : Type v} [pseudo_metric_space α] {ι : Type u_1} {F : ι → β → α} {f : β → α} {p : filter ι} : tendsto_uniformly F f p ↔ ∀ (ε : ℝ), ε > 0 → (∀ᶠ (n : ι) in p, ∀ (x : β), has_dist.dist (f x) (F n x) < ε)
{E : Type u_3} [semi_normed_group E] {f : ℕ → E} (g : ℕ → ℝ) (hg : cauchy_seq (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), g i))) (hf : ∀ (i : ℕ), ∥f i∥ ≤ g i) : cauchy_seq (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), f i))
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) : tactic expr
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {X : C} (S : J.cover X) (T : Π (I : S.arrow), J.cover I.Y) : S.bind T ⟶ S
{V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (h : o.oangle x y = 0) : x = y ↔ ∥x∥ = ∥y∥
{L : Type u_2} {R : Type u_3} [field L] [comm_ring R] (φ : polynomial R →+* L) (hφ : non_zero_divisors (polynomial R) ≤ submonoid.comap ↑φ (non_zero_divisors L)) : ratfunc R →+* L
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {f : E →ₛₗ[σ₁₂] F} (hf : continuous ⇑f) {x : E} (hx : ∥x∥ = 0) : ∥⇑f x∥ = 0
{R : Type u} {σ : Type v} [comm_ring R] (I : ideal (mv_polynomial σ R)) (p : mv_polynomial σ R) (hcoe : ∀ (m : σ →₀ ℕ), mv_polynomial.coeff m p ∈ ideal.comap mv_polynomial.C I) : p ∈ I
{L : first_order.language} {K : set (category_theory.bundled L.Structure)} (hn : K.nonempty) (h : ∀ (M N : category_theory.bundled L.Structure), nonempty (L.equiv ↥M ↥N) → (M ∈ K ↔ N ∈ K)) (hc : (quotient.mk '' K).countable) (fg : ∀ (M : category_theory.bundled L.Structure), M ∈ K → first_order.language.Structure.fg L ↥M) (hp : first_order.language.hereditary K) (jep : first_order.language.joint_embedding K) : ∃ (M : category_theory.bundled L.Structure), first_order.language.Structure.cg L ↥M ∧ L.age ↥M = K
(cfg : slim_check.slim_check_cfg := {num_inst := 100, max_size := 100, trace_discarded := bool.ff, trace_success := bool.ff, trace_shrink := bool.ff, trace_shrink_candidates := bool.ff, random_seed := option.none ℕ, quiet := bool.ff}) : tactic unit
(α : Type u) (σ : Type v) : Type (max u v)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (f : E → F) (L : E →L[𝕜] F) (r ε : ℝ) : set E
{a b : ℝ} {f f' g : ℝ → ℝ} (hf : continuous_on f (set.interval a b)) (hff' : ∀ (x : ℝ), x ∈ set.Ioo (linear_order.min a b) (linear_order.max a b) → has_deriv_within_at f (f' x) (set.Ioi x) x) (hf' : continuous_on f' (set.interval a b)) (hg : continuous_on g (f '' set.interval a b)) : ∫ (x : ℝ) in a..b, (g ∘ f) x * f' x = ∫ (u : ℝ) in f a..f b, g u
{M : Type u_1} [has_mul M] ⦃s t : set M⦄ (h : s ⊆ t) : subsemigroup.closure s ≤ subsemigroup.closure t
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {F : C ⥤ D} (G : D ⥤ C) (η : 𝟭 C ≅ F ⋙ G) (ε : G ⋙ F ≅ 𝟭 D) : category_theory.is_equivalence F
{G : Type u_2} [add_group G] [topological_space G] [measurable_space G] (μ : measure_theory.measure G) : Prop
{f : C(↥unit_interval, ℝ)} {ε : ℝ} {h : 0 < ε} {n : ℕ} {x : ↥unit_interval} {k : fin (n + 1)} (m : k ∈ bernstein_approximation.S f ε h n x) : |⇑f (bernstein.z k) - ⇑f x| < ε / 2
{M : Type u_2} [add_comm_group M] {R : Type u_1} (v : ray_vector R M) : ↑-v = -↑v
{α : Type u_1} {s : finset α} {p : Π (t : finset α), t ⊆ s → Prop} [Π (t : finset α) (h : t ⊆ s), decidable (p t h)] : decidable (∃ (t : finset α) (h : t ⊆ s), p t h)
{R : Type u} [comm_ring R] [is_domain R] {M : Type v} [add_comm_group M] [module R M] [is_dedekind_domain R] {I : ideal R} (hI : I ≠ ⊥) (hM : module.is_torsion_by_set R M ↑I) : ∃ (P : finset (ideal R)) [_inst_6 : decidable_eq ↥P] [_inst_7 : ∀ (p : ideal R), p ∈ P → prime p] (e : ↥P → ℕ), direct_sum.is_internal (λ (p : ↥P), submodule.torsion_by_set R M ↑(↑p ^ e p))
{X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] {f : X → E} {μ : measure_theory.measure X} [opens_measurable_space X] [topological_space.metrizable_space X] [measure_theory.is_locally_finite_measure μ] (hf : continuous f) (hcf : has_compact_support f) : measure_theory.integrable f μ
(M : Type u_4) (α : Type u_5) [has_vadd M α] {_x : measurable_space α} (μ : measure_theory.measure α) : Prop
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : continuous_multilinear_map 𝕜 E G) (m : Π (i : ι), E i) (h : ∥m∥ ≤ 1) : ∥⇑f m∥ ≤ ∥f∥
{α : Type u_1} {β : Type u_2} [topological_space β] [has_zero β] {m0 : measurable_space α} (f : α → β) (μ : measure_theory.measure α) : Prop
{ε : Type u} {m : Type v → Type w} [monad_except ε m] {α : Type v} (t₁ t₂ : m α) (use_first_ex : bool := bool.tt) : m α
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] (x : M) : derivation 𝕜 (cont_mdiff_map I (model_with_corners_self 𝕜 𝕜) M 𝕜 ⊤) (cont_mdiff_map I (model_with_corners_self 𝕜 𝕜) M 𝕜 ⊤) →ₗ[𝕜] point_derivation I x
{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (f : M →+ N) (s : set M) : add_submonoid.map f (add_submonoid.closure s) = add_submonoid.closure (⇑f '' s)
{A : Type u_2} {K : Type u_3} [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] [is_dedekind_domain A] (I J : fractional_ideal (non_zero_divisors A) K) : I / J = I * J⁻¹
{R : Type u_1} [ring R] (φ : power_series R) (u : Rˣ) : power_series R
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} {σ : Type u_3} (S : finset Λ) : turing.TM1.stmt Γ Λ σ → Prop
{n : ℕ+} (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [is_cyclotomic_extension {n} K L] {ζ : L} (hζ : is_primitive_root ζ ↑n) : power_basis K L
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {F : C ⥤ D} {G_obj : D → C} (e : Π (X : C) (Y : D), (F.obj X ⟶ Y) ≃ (X ⟶ G_obj Y)) (he : ∀ (X' X : C) (Y : D) (f : X' ⟶ X) (g : F.obj X ⟶ Y), ⇑(e X' Y) (F.map f ≫ g) = f ≫ ⇑(e X Y) g) : D ⥤ C
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ D] [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [Π (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)ᵒᵖ (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] (P : Cᵒᵖ ⥤ D) (hsep : ∀ (X : C) (S : J.cover X) (x y : ↥(P.obj (opposite.op X))), (∀ (I : S.arrow), ⇑(P.map I.f.op) x = ⇑(P.map I.f.op) y) → x = y) : category_theory.presheaf.is_sheaf J (J.plus_obj P)
{R : Type u_2} {V : Type u_3} {W : Type u_4} {P : Type u_6} {Q : Type u_7} [normed_group V] [metric_space P] [normed_add_torsor V P] [normed_group W] [metric_space Q] [normed_add_torsor W Q] [normed_field R] [normed_space R V] [normed_space R W] (f : P →A[R] Q) : V →L[R] W
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {ι : Type u_2} {f : α → ennreal} (h : ∫⁻ (x : α), f x ∂μ ≠ ⊤) {l : filter ι} {s : ι → set α} (hl : filter.tendsto (⇑μ ∘ s) l (nhds 0)) : filter.tendsto (λ (i : ι), ∫⁻ (x : α) in s i, f x ∂μ) l (nhds 0)
{K : Type u} {L : Type v} [field K] [field L] (f : K →+* L) (s : set K) : subfield.map f (subfield.closure s) = subfield.closure (⇑f '' s)
{V : Type u} [category_theory.category V] [category_theory.limits.has_images V] [category_theory.limits.has_zero_morphisms V] [category_theory.limits.has_kernels V] {W : Type u₂} [category_theory.category W] [category_theory.limits.has_images W] [category_theory.limits.has_zero_morphisms W] [category_theory.limits.has_kernels W] (F : V ⥤ W) : Type
{ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), comm_ring (G i)] (f' : Π (i j : ι), i ≤ j → G i →+* G j) [is_directed ι has_le.le] [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f' i j h))] (hf : ∀ (i j : ι) (hij : i ≤ j), function.injective ⇑(f' i j hij)) (i : ι) : function.injective ⇑(ring.direct_limit.of G (λ (i j : ι) (h : i ≤ j), ⇑(f' i j h)) i)
{n : ℕ+} {K : Type u} {L : Type v} [field L] {ζ : L} (hζ : is_primitive_root ζ ↑n) [field K] [algebra K L] [ne_zero ↑↑n] [is_cyclotomic_extension {n} K L] (hn : n ≠ 2) (hirr : irreducible (polynomial.cyclotomic ↑n K)) : ⇑(algebra.norm K) ζ = 1
{k : Type u_1} [field k] {σ : Type u_2} (V : set (σ → k)) : ideal (mv_polynomial σ k)
(Γ : Type u_1) [inhabited Γ] (Λ : Type u_2) (σ : Type u_3) : Type (max u_1 u_2 u_3)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {𝕜₃ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [nondiscrete_normed_field 𝕜₃] [normed_space 𝕜 E] [normed_space 𝕜₂ F] [normed_space 𝕜₃ G] {σ₁₂ : 𝕜 →+* 𝕜₂} {σ₂₃ : 𝕜₂ →+* 𝕜₃} {σ₁₃ : 𝕜 →+* 𝕜₃} [ring_hom_comp_triple σ₁₂ σ₂₃ σ₁₃] [ring_hom_isometric σ₁₂] [ring_hom_isometric σ₂₃] (h : F →SL[σ₂₃] G) (f : E →SL[σ₁₂] F) : ∥h.comp f∥ ≤ ∥h∥ * ∥f∥
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] {E : set G} [has_measurable_inv G] [μ.is_mul_left_invariant] [ν.is_mul_left_invariant] (hE : measurable_set E) (h2E : ⇑ν E ≠ 0) (h3E : ⇑ν E ≠ ⊤) : μ = (⇑μ E / ⇑ν E) • ν
{ι : Type u_1} {E : Type u_3} [semi_normed_group E] [complete_space E] {f : ι → E} (g : ι → ℝ) (hg : summable g) (h : ∀ (i : ι), ∥f i∥ ≤ g i) : summable f
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : multilinear_map 𝕜 E G) {C : ℝ} (H : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) : ∥f.mk_continuous C H∥ ≤ linear_order.max C 0
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (G : C ⥤ D) {W X Y Z : C} {h : X ⟶ Z} {k : Y ⟶ Z} {f : W ⟶ X} {g : W ⟶ Y} (comm : f ≫ h = g ≫ k) : category_theory.limits.is_colimit (G.map_cocone (category_theory.limits.pushout_cocone.mk h k comm)) ≃ category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (G.map h) (G.map k) _)
{α : Type u} {β : Type v} {γ : Type w} (g : β → γ) (f : α → β) (s : set α) : g '' (f '' s) = (λ (x : α), g (f x)) '' s
{ι : Type u_1} [fintype ι] (I : box_integral.box ι) (r : (ι → ℝ) → ↥(set.Ioi 0)) : ∃ (π : box_integral.tagged_prepartition I), π.is_partition ∧ π.is_Henstock ∧ π.is_subordinate r ∧ (∀ (J : box_integral.box ι), J ∈ π → (∃ (m : ℕ), ∀ (i : ι), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m)) ∧ π.distortion = I.distortion
{R : Type u_1} [semiring R] (φ : power_series R) (h : is_unit φ) : is_unit (⇑(power_series.constant_coeff R) φ)
{ι : Type u_1} (I : box_integral.box ι) : Type u_1
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (P Q : chain_complex V ℕ) (zero : P.X 0 ⟶ Q.X 0) (one : P.X 1 ⟶ Q.X 1) (one_zero_comm : one ≫ Q.d 1 0 = P.d 1 0 ≫ zero) (succ : Π (n : ℕ) (p : Σ' (f : P.X n ⟶ Q.X n) (f' : P.X (n + 1) ⟶ Q.X (n + 1)), f' ≫ Q.d (n + 1) n = P.d (n + 1) n ≫ f), Σ' (f'' : P.X (n + 2) ⟶ Q.X (n + 2)), f'' ≫ Q.d (n + 2) (n + 1) = P.d (n + 2) (n + 1) ≫ p.snd.fst) : P ⟶ Q
{R : Type u_1} [comm_ring R] (M : submonoid R) (S : Type u_2) [comm_ring S] [algebra R S] [is_localization M S] {I : ideal S} [I.is_prime] {J : ideal R} {H : J ≤ ideal.comap (algebra_map R S) I} (hI : (ideal.comap (algebra_map R S) I).is_maximal) : function.surjective ⇑(I.quotient_map (algebra_map R S) H)
{R : Type u} {S : Type v} [ring R] [ring S] (I : ideal R) (f : R ≃+* S) : ideal.map ↑(f.symm) (ideal.map ↑f I) = I
{R₁ : Type u_3} {A : Type u_5} {B : Type u_6} [comm_semiring R₁] [comm_ring A] [comm_ring B] [algebra R₁ A] [algebra R₁ B] (I : ideal A) (J : ideal B) (f : A ≃ₐ[R₁] B) (hIJ : J = ideal.map ↑f I) : (A ⧸ I) ≃ₐ[R₁] B ⧸ J
{α : Type u_1} {β : Type u_2} [linear_order α] [linear_order β] [densely_ordered β] [no_min_order β] [no_max_order β] [nonempty β] (a : α) (I : order.ideal (order.partial_iso α β)) : (∃ (f : order.partial_iso α β), f ∈ order.partial_iso.defined_at_left β a ∧ f ∈ I) → {b // ∃ (f : {f // ∀ (p : α × β), p ∈ f → ∀ (q : α × β), q ∈ f → cmp p.fst q.fst = cmp p.snd q.snd}) (H : f ∈ I), (a, b) ∈ f.val}
{ι : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [semiring A] [algebra R A] (𝒜 : ι → submodule R A) (I : ideal A) : ideal A
{c w : ℂ} {R : ℝ} {n : ℤ} : circle_integrable (λ (z : ℂ), (z - w) ^ n) c R ↔ R = 0 ∨ 0 ≤ n ∨ w ∉ metric.sphere c |R|
{α : Type u} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) (n : ℕ) : function.is_fixed_pt f^[n] x
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} {s : set β} (hs : s.countable) {f : α → β} (hf : ∀ (y : β), y ∈ s → measurable_set (f ⁻¹' {y})) : ∑' (b : ↥s), ⇑μ (f ⁻¹' {↑b}) = ⇑μ (f ⁻¹' s)
{σ : Type u_1} {R : Type u_2} [comm_semiring R] (φ : mv_polynomial σ R) : Prop
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →ₛₗ[σ₁₂] F) (a : ℝ) (hf : ∀ (x : E), ∥⇑f x∥ = a * ∥x∥) : E →SL[σ₁₂] F
(R : Type u) (S : Type v) [ring R] [ring S] : {K // K.is_prime} ≃ {I // I.is_prime} ⊕ {J // J.is_prime}
{C : Type u₁} [category_theory.category C] (all_split_mono : Π {X Y : C} (f : X ⟶ Y), trunc (category_theory.split_mono f)) : category_theory.groupoid C
{α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.regular] ⦃U : set α⦄ (hU : is_open U) {r : ennreal} (hr : r < ⇑μ U) : ∃ (K : set α) (H : K ⊆ U), is_compact K ∧ r < ⇑μ K
{C : Type u} [category_theory.category C] {X Y : C} (I : X ≅ Y) : Y ≅ X
{α : Type u_1} {E' : Type u_5} {𝕜 : Type u_11} [is_R_or_C 𝕜] [inner_product_space 𝕜 E'] [complete_space E'] [normed_space ℝ E'] {m m0 : measurable_space α} {μ : measure_theory.measure α} {s : set α} (hm : m ≤ m0) [measure_theory.sigma_finite (μ.trim hm)] (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) (x : E') : measure_theory.integrable ⇑(⇑(measure_theory.condexp_L2 𝕜 hm) (measure_theory.indicator_const_Lp 2 hs hμs x)) μ
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {n : with_top ℕ} {E'' : Type u_14} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {g : M' → M''} (x : M) (hg : cont_mdiff_at I' I'' n g (f x)) (hf : cont_mdiff_within_at I I' n f s x) : cont_mdiff_within_at I I'' n (g ∘ f) s x
{n : ℕ} {K : Type u_8} [field K] {μ : K} (h : is_primitive_root μ n) [char_zero K] {m : ℕ} (hcop : m.coprime n) : minpoly ℤ μ = minpoly ℤ (μ ^ m)
(α : Type u) (σ : Type v) : Type (max u v)
{ι : Type u_1} {I : box_integral.box ι} {i : ι} {x : ℝ} (h : x ∉ set.Ioo (I.lower i) (I.upper i)) : box_integral.prepartition.split I i x = ⊤
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {H : Type u_4} [topological_space H] {H' : Type u_5} [topological_space H'] {I : model_with_corners 𝕜 E H} {I' : model_with_corners 𝕜 E' H'} {M : Type u_6} [topological_space M] [charted_space H M] {M' : Type u_7} [topological_space M'] [charted_space H' M'] {n : with_top ℕ} (y : M') : cont_mdiff_map I I' M M' n
(h : expr) (ns : list name := list.nil) (md : tactic.transparency := tactic.transparency.semireducible) : tactic (list (name × list expr × list (name × expr)))
{α : Type u} {β : Type v} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [conditionally_complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (has_Sup.Sup s)) (Mf : monotone f) (ne : s.nonempty) (H : bdd_above s) : f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] (G : V ⥤ W) [G.additive] (hom : Π (i j : ι), C.X i ⟶ D.X j) : (G.map_homological_complex c).map (homotopy.null_homotopic_map hom) = homotopy.null_homotopic_map (λ (i j : ι), G.map (hom i j))
{α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {m m0 : measurable_space α} {μ : measure_theory.measure α} {hm : m ≤ m0} [measure_theory.sigma_finite (μ.trim hm)] {s : set α} (f : ↥(measure_theory.Lp F' 1 μ)) (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) : ∫ (x : α) in s, ⇑(⇑(measure_theory.condexp_L1_clm hm μ) f) x ∂μ = ∫ (x : α) in s, ⇑f x ∂μ
{V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) (x y : V) : x = y ↔ ∥x∥ = ∥y∥ ∧ o.oangle x y = 0
{V : Type u_1} [inner_product_space ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : has_inner.inner x y = ∥x∥ * ∥y∥ ↔ inner_product_geometry.angle x y = 0
{V : Type u_1} {W : Type u_2} {V₁ : Type u_3} [semi_normed_group V] [semi_normed_group W] [semi_normed_group V₁] {f g : normed_group_hom V W} (φ : normed_group_hom V₁ V) (h : f.comp φ = g.comp φ) (C : ℝ) (hφ : ∥φ∥ ≤ C) : ∥normed_group_hom.equalizer.lift φ h∥ ≤ C
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] : ∥0∥ = 0
(ι : Type u_1) (π : ι → Type u_2) : (Π (i : ι), π i) ≃ {f // ∀ (i : ι), (f i).fst = i}
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [metric_space β] {μ : measure_theory.measure α} {s : set α} {ε : ℝ} {f : ι → α → β} {g : α → β} [semilattice_sup ι] [nonempty ι] [encodable ι] (hε : 0 < ε) (hf : ∀ (n : ι), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hsm : measurable_set s) (hs : ⇑μ s ≠ ⊤) (hfg : ∀ᵐ (x : α) ∂μ, x ∈ s → filter.tendsto (λ (n : ι), f n x) filter.at_top (nhds (g x))) : set α
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {a b : ℝ} {f : ℝ → E} {μ : measure_theory.measure ℝ} {ι : Type u_1} {l : filter ι} [l.is_countably_generated] {F : ι → ℝ → E} (bound : ℝ → ℝ) (hF_meas : ∀ᶠ (n : ι) in l, measure_theory.ae_strongly_measurable (F n) (μ.restrict (set.interval_oc a b))) (h_bound : ∀ᶠ (n : ι) in l, ∀ᵐ (x : ℝ) ∂μ, x ∈ set.interval_oc a b → ∥F n x∥ ≤ bound x) (bound_integrable : interval_integrable bound μ a b) (h_lim : ∀ᵐ (x : ℝ) ∂μ, x ∈ set.interval_oc a b → filter.tendsto (λ (n : ι), F n x) l (nhds (f x))) : filter.tendsto (λ (n : ι), ∫ (x : ℝ) in a..b, F n x ∂μ) l (nhds (∫ (x : ℝ) in a..b, f x ∂μ))
{α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] {μ : measure_theory.measure α} [μ.weakly_regular] [measure_theory.sigma_finite μ] (f : α → nnreal) (fint : measure_theory.integrable (λ (x : α), ↑(f x)) μ) {ε : ℝ} (εpos : 0 < ε) : ∃ (g : α → ennreal), (∀ (x : α), ↑(f x) < g x) ∧ lower_semicontinuous g ∧ (∀ᵐ (x : α) ∂μ, g x < ⊤) ∧ measure_theory.integrable (λ (x : α), (g x).to_real) μ ∧ ∫ (x : α), (g x).to_real ∂μ < ∫ (x : α), ↑(f x) ∂μ + ε
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (f : module.End K V) (μ : K) : disjoint (f.generalized_eigenrange μ (finite_dimensional.finrank K V)) (⇑(f.generalized_eigenspace μ) (finite_dimensional.finrank K V))
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} {σ : Type u_3} (M : Λ → turing.TM1.stmt Γ Λ σ) (S : finset Λ) : finset (option (turing.TM1.stmt Γ Λ σ))
{C : Type u₂} [category_theory.category C] {I : Type u₁} {F : category_theory.discrete I ⥤ C} : F ≅ category_theory.discrete.functor (F.obj ∘ category_theory.discrete.mk)
{α : Type u_1} {E : Type u_3} [measurable_space α] {ι : Type u_5} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {l : filter α} [l.is_measurably_generated] {f : α → E} {b : E} (h : filter.tendsto f (l ⊓ μ.ae) (nhds b)) (hfm : strongly_measurable_at_filter f l μ) (hμ : μ.finite_at_filter l) {s : ι → set α} {li : filter ι} (hs : filter.tendsto s li l.small_sets) (m : ι → ℝ := λ (i : ι), (⇑μ (s i)).to_real) (hsμ : (λ (i : ι), (⇑μ (s i)).to_real) =ᶠ[li] m . "refl") : (λ (i : ι), ∫ (x : α) in s i, f x ∂μ - m i • b) =o[li] m
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} [measure_theory.sigma_finite μ] {s : set α} (hs : measurable_set s) (t : set α) : ⇑μ (measure_theory.to_measurable μ t ∩ s) = ⇑μ (t ∩ s)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {H : Type u_4} [topological_space H] {I : model_with_corners 𝕜 E H} {H' : Type u_5} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} (M : Type u_6) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (M' : Type u_7) [topological_space M'] [charted_space H' M'] [smooth_manifold_with_corners I' M'] : smooth_manifold_with_corners (I.prod I') (M × M')
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} [category_theory.limits.has_zero_object V] (i : ι) : (Π (i j : ι), C.X i ⟶ D.X j) →+ (C.X_next i ⟶ D.X i)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h : ↑r < p.radius) : ∃ (a : ℝ) (H : a ∈ set.Ioo 0 1) (C : ℝ) (H : C > 0), ∀ (n : ℕ), ∥p n∥ * ↑r ^ n ≤ C * a ^ n
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} (hp : p ∈ s) : vector_span k s = submodule.span k ((λ (_x : P), _x -ᵥ p) '' (s  {p}))
(use_iota_eqn : interactive.parse (optional (lean.parser.tk "!"))) (trace_lemmas : interactive.parse (optional (lean.parser.tk "?"))) (no_dflt : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (tgt : interactive.parse (optional (lean.parser.tk "using" *> interactive.types.texpr))) (cfg : tactic.simp_config_ext := {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}, discharger := tactic.failed unit}) : tactic unit
{α : Type} (t : tactic α) (cfg : tactic.simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.ff, memoize := bool.tt, trace_lemmas := bool.ff}) (discharger : tactic unit := tactic.failed) (no_defaults : bool := bool.ff) (attr_names : list name := list.nil) (hs : list tactic.simp_arg_type := list.nil) : tactic α
{σ : Type u_1} {R : Type u_3} [comm_semiring R] (φ : mv_polynomial σ R) (n : ℕ) : Prop
{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) (σ : L ≃ₐ[K] L) : σ ∈ E.fixing_subgroup ↔ ∀ (x : L), x ∈ E → ⇑σ x = x
(xs : list tactic.rcases_patt) (cfg : tactic.apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}) (trace : bool := bool.ff) : tactic (list tactic.rcases_patt)
{α : Type u_1} {m : measurable_space α} {μ ν : measure_theory.measure α} {s : set α} [measure_theory.is_finite_measure ν] (h₁ : measurable_set s) (h₂ : ν ≤ μ) : ⇑(μ - ν) s = ⇑μ s - ⇑ν s
{R : Type u_1} [comm_ring R] {f : polynomial R} : algebraic_geometry.polynomial.image_of_Df f = ⇑(prime_spectrum.comap polynomial.C) '' (prime_spectrum.zero_locus {f})ᶜ
(e : expr) (r : expr × bool) (cfg : tactic.nth_rewrite.cfg := {to_rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}, try_simp := bool.ff, discharger := tactic.skip, simplifier := λ (e : expr), tactic.failed}) : tactic (list tactic.nth_rewrite.tracked_rewrite)
{α : Type u_1} {ι : Type u_5} {m : measurable_space α} {μ : measure_theory.measure α} [encodable ι] [semilattice_sup ι] {s : ι → set α} (hs : ∀ (n : ι), measurable_set (s n)) (hm : antitone s) (hf : ∃ (i : ι), ⇑μ (s i) ≠ ⊤) : filter.tendsto (⇑μ ∘ s) filter.at_top (nhds (⇑μ (⋂ (n : ι), s n)))
{X : Type u_1} [emetric_space X] {ι : Type u_2} {I : set ι} (hI : I.finite) {s : ι → set X} {t : set X} : (∀ (i : ι), i ∈ I → is_metric_separated (s i) t) → is_metric_separated (⋃ (i : ι) (H : i ∈ I), s i) t
{α : Type u_1} {β : α → Type u_2} (γ : Π (a : α), β a → Type u_3) : (Π (x : Σ (i : α), β i), γ x.fst x.snd) ≃ Π (a : α) (b : β a), γ a b
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] (M : turing.TM0.machine Γ Λ) : turing.TM0.cfg Γ Λ → turing.TM0.cfg Γ Λ → Prop
{β : Type v} {α : Type u_1} [decidable_eq α] (σ : α → equiv.perm β) {l : list α} (hl : l.nodup) (mem_l : ∀ (a : α), a ∈ l) : (list.map (λ (a : α), equiv.perm.prod_extend_right a (σ a)) l).prod = equiv.prod_congr_right σ
{L : first_order.language} {α : Type w} {n : ℕ} (T : L.Theory) (φ ψ : L.bounded_formula α n) : Prop
{L : first_order.language} {L' : first_order.language} (ϕ : L →ᴸ L') {L₁ : first_order.language} {L₂ : first_order.language} (ψ : L₁ →ᴸ L₂) : L.sum L₁ →ᴸ L'.sum L₂
{K : Type u} {L : Type v} [field L] {ζ : L} [field K] [algebra K L] [ne_zero 2] {k : ℕ} (hζ : is_primitive_root ζ (2 ^ (k + 1))) [is_cyclotomic_extension {2 ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic (2 ^ (k + 1)) K)) : ⇑(algebra.norm K) (ζ ^ 2 ^ k - 1) = (-2) ^ 2 ^ k
{α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : α → E} {g : α → F} {l : filter α} : f =o[l] g ↔ ∀ ⦃c : ℝ⦄, 0 < c → (∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥)
{α : Type u_1} {ι : Type u_2} {E : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group E] {p : ennreal} [hp : fact (1 ≤ p)] {f : ι → ↥(measure_theory.Lp E p μ)} {g : ↥(measure_theory.Lp E p μ)} {l : filter ι} (hfg : filter.tendsto f l (nhds g)) : measure_theory.tendsto_in_measure μ (λ (n : ι), ⇑(f n)) l ⇑g
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (G : C ⥤ D) {W X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} {h : W ⟶ X} {k : W ⟶ Y} (comm : h ≫ f = k ≫ g) [category_theory.limits.preserves_limit (category_theory.limits.cospan f g) G] (l : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk h k comm)) : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk (G.map h) (G.map k) _)
(α : Type u) (β : Type v) [add_group α] [add_action α β] : β ≃ Σ (ω : quotient (add_action.orbit_rel α β)), ↥(add_action.orbit α ω.out')
{α : Type u_2} [measurable_space α] (s : set α) (μ : measure_theory.measure α . "volume_tac") : Prop
{β : Type u_2} [uniform_space β] {α : Type u_1} {f : α → β} {s : set (β × β)} (hs : s ∈ uniformity β) (hf : pairwise (λ (x y : α), (f x, f y) ∉ s)) : filter.comap (prod.map f f) (uniformity β) = filter.principal id_rel
{A : Type u} [category_theory.category A] [category_theory.abelian A] {X Y Z : A} (f : X ⟶ Y) (g : Y ⟶ Z) (w : f ≫ g = 0) {W : A} (e : W ⟶ category_theory.limits.cokernel f) (he : e ≫ category_theory.limits.cokernel.desc f g w = 0) : W ⟶ homology f g w
{α : Type u_1} {m m0 : measurable_space α} (μ : measure_theory.measure α) (hm : m ≤ m0) : measure_theory.measure α
{F : Type u_3} [inner_product_space ℝ F] [finite_dimensional ℝ F] (φ : F ≃ₗᵢ[ℝ] F) : ∃ (l : list F), l.length ≤ finite_dimensional.finrank ℝ F ∧ φ = (list.map (λ (v : F), reflection (submodule.span ℝ {v})ᗮ) l).prod
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (M : Type u_4) [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] : M → tangent_bundle I M
{B : Type u₁} [quiver B] [Π (a b : B), quiver (a ⟶ b)] {C : Type u₂} [quiver C] [Π (a b : C), quiver (a ⟶ b)] {D : Type u₃} [quiver D] [Π (a b : D), quiver (a ⟶ b)] (F : category_theory.prelax_functor B C) (G : category_theory.prelax_functor C D) : category_theory.prelax_functor B D
{α : Type u_1} {β : Type u_2} (S : set α) (f : β ≃ α) : ⇑f ⁻¹' S = ⇑(f.symm) '' S
{R : Type u} {σ : Type u_1} [comm_semiring R] (n : σ) (p : mv_polynomial σ R) : ℕ
{E : Type u_1} [add_comm_group E] [module ℝ E] {α : Type u_2} [linear_ordered_field α] [mul_action_with_zero α ℝ] [ordered_smul α ℝ] [module α E] [is_scalar_tower α ℝ (set E)] {s : set E} (symmetric : ∀ (x : E), x ∈ s → -x ∈ s) (r : α) (x : E) : gauge s (r • x) = |r| • gauge s x
{α : Type u_1} {E : Type u_3} [topological_space α] [compact_space α] [normed_group E] (f : C(α, E)) {C : ℝ} (C0 : 0 ≤ C) : ∥f∥ ≤ C ↔ ∀ (x : α), ∥⇑f x∥ ≤ C
{M : Type u_1} [has_add M] (S : set (add_con M)) : (has_Inf.Inf S).to_setoid = has_Inf.Inf (add_con.to_setoid '' S)
(md : tactic.transparency := tactic.transparency.semireducible) : list (tactic string)
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] : M →ₗ[R] ↥(adic_completion I M)
{α : Type u} {β : Type v} [pseudo_emetric_space α] {ι : Type u_1} [topological_space β] {F : ι → β → α} {f : β → α} {p : filter ι} {s : set β} : tendsto_locally_uniformly_on F f p s ↔ ∀ (ε : ennreal), ε > 0 → ∀ (x : β), x ∈ s → (∃ (t : set β) (H : t ∈ nhds_within x s), ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → has_edist.edist (f y) (F n y) < ε)
{C : Type u₁} [category_theory.category C] {I : C} (hI : category_theory.limits.is_initial I) (h : ∀ (X : C), category_theory.mono (hI.to X)) : category_theory.limits.initial_mono_class C
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {f : α → β → γ} {s : set α} {t : set β} {g : γ → δ} {f' : α' → β → δ} {g' : α → α'} (h_distrib : ∀ (a : α) (b : β), g (f a b) = f' (g' a) b) : g '' set.image2 f s t = set.image2 f' (g' '' s) t
(M : Type v) (X : Type x) [_inst_1 _inst_3 : uniform_space X] [has_scalar M X] : Prop
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : ∃ (π : K), ⇑(v.valuation) π = ↑(⇑multiplicative.of_add (-1))
{σ : Type u_1} {R : Type u_2} [semiring R] (φ : mv_power_series σ R) (h : is_unit φ) : is_unit (⇑(mv_power_series.constant_coeff σ R) φ)
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {F : C ⥤ D} {G : D ⥤ C} {E : Type u₃} [ℰ : category_theory.category E] (H : D ⥤ E) (I : E ⥤ D) (adj₁ : F ⊣ G) (adj₂ : H ⊣ I) : F ⋙ H ⊣ I ⋙ G
{J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {c c' : category_theory.limits.cocone F} (φ : c.X ≅ c'.X) (w : ∀ (j : J), c.ι.app j ≫ φ.hom = c'.ι.app j) : c ≅ c'
{α : Type u_1} {mα : measurable_space α} {μ : measure_theory.measure α} {f g : α → ennreal} (h_meas_f : ae_measurable f μ) (h_meas_g : ae_measurable g μ) (h_indep_fun : probability_theory.indep_fun f g μ) : ∫⁻ (a : α), (f * g) a ∂μ = ∫⁻ (a : α), f a ∂μ * ∫⁻ (a : α), g a ∂μ
{G : Type u} [add_group G] {H : Type v} [add_group H] (φ : G →+ H) : G ⧸ φ.ker →+ ↥(φ.range)
{G : Type u_4} [measurable_space G] {μ : measure_theory.measure G} [group G] [has_measurable_mul G] [μ.is_mul_right_invariant] (f : G → ennreal) (g : G) : ∫⁻ (x : G), f (x * g) ∂μ = ∫⁻ (x : G), f x ∂μ
{V : Type u_1} [inner_product_space ℝ V] (x y : V) : ∥x + y∥ = ∥x - y∥ ↔ inner_product_geometry.angle x y = real.pi / 2
{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} (hf : antitone f) {s : set α} : bdd_above s → bdd_below (f '' s)
(n : ℕ) (base : name) (offset : option ℕ := option.none) : tactic (list expr)
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : is_lie_abelian ↥(lie_algebra.radical R L) ↔ ∀ (I : lie_ideal R L), lie_algebra.is_solvable R ↥I → is_lie_abelian ↥I
(𝕜 : Type v) [is_R_or_C 𝕜] {E : Type u} [normed_group E] [normed_space 𝕜 E] [nontrivial E] (x : E) : ∃ (g : E →L[𝕜] 𝕜), ∥g∥ = 1 ∧ ⇑g x = ↑∥x∥
{α : Type u_2} {β : Type u_3} [bornology α] [bornology β] (f : α → β) (h : ∀ ⦃s : set α⦄, bornology.is_bounded s → bornology.is_bounded (f '' s)) : locally_bounded_map α β
{C : Type u₁} [category_theory.category C] {J : category_theory.grothendieck_topology C} {A : Type u₂} [category_theory.category A] {E : A} {X : C} {P : Cᵒᵖ ⥤ A} (hP : category_theory.presheaf.is_sheaf J P) (S : J.cover X) (x : Π (I : S.arrow), E ⟶ P.obj (opposite.op I.Y)) (hx : ∀ (I : S.relation), x I.fst ≫ P.map I.g₁.op = x I.snd ≫ P.map I.g₂.op) : E ⟶ P.obj (opposite.op X)
(n : ℕ := 2) : tactic unit
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {F : ℕ → α → ennreal} {f : α → ennreal} (bound : α → ennreal) (hF_meas : ∀ (n : ℕ), ae_measurable (F n) μ) (h_bound : ∀ (n : ℕ), F n ≤ᵐ[μ] bound) (h_fin : ∫⁻ (a : α), bound a ∂μ ≠ ⊤) (h_lim : ∀ᵐ (a : α) ∂μ, filter.tendsto (λ (n : ℕ), F n a) filter.at_top (nhds (f a))) : filter.tendsto (λ (n : ℕ), ∫⁻ (a : α), F n a ∂μ) filter.at_top (nhds (∫⁻ (a : α), f a ∂μ))
{α : Type u_1} [measurable_space α] (μ : measure_theory.probability_measure α) : measure_theory.finite_measure α
{I : Type u} (f : I → Type v) [Π (i : I), add_zero_class (f i)] (i : I) : (Π (i : I), f i) →+ f i
{G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {μ : measure_theory.measure G} {Γ : subgroup G} [μ.is_mul_right_invariant] : measure_theory.smul_invariant_measure ↥(Γ.opposite) G μ
{E : Type u_1} [inner_product_space ℝ E] {v : E} (hv : ∥v∥ = 1) (w : ↥(submodule.span ℝ {v})ᗮ) : ↥(metric.sphere 0 1)
{α : Type u} {β : Type v} {a b : set α} (f : α → β) (h : a ⊆ b) : f '' a ⊆ f '' b
{α : Type u_1} {E : Type u_2} [normed_group E] {m : measurable_space α} {μ : measure_theory.measure α} [normed_space ℝ E] [complete_space E] (f : ↥(measure_theory.Lp E 1 μ)) : E
{C : Type u₁} [category_theory.category C] {J : Type u} [category_theory.category J] {j : J} (I : category_theory.limits.is_terminal j) (F : J ⥤ C) [category_theory.limits.has_colimit F] : category_theory.is_iso (category_theory.limits.colimit.ι F j)
{I : Type u} (X : I → Top) : (Π (i : I), ↥(fundamental_groupoid.fundamental_groupoid_functor.obj (X i))) ⥤ ↥(fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (Π (i : I), ↥(X i))))
{ι : Type u_1} {M : Type u_2} [add_comm_monoid M] {I₀ : with_top (box_integral.box ι)} (f : box_integral.box_additive_map ι M I₀) (I : with_top (box_integral.box ι)) (hI : I ≤ I₀) : box_integral.box_additive_map ι M I
{R : Type u_1} {M : Type u_2} [comm_semiring R] [monoid M] {S : set (monoid_algebra R M)} (hS : algebra.adjoin R S = ⊤) : algebra.adjoin R (⋃ (f : monoid_algebra R M) (H : f ∈ S), ⇑(monoid_algebra.of R M) '' ↑(f.support)) = ⊤
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) : Type (max u_4 u_1)
{α : Type u_1} (r s : setoid α) : r ⊔ s = eqv_gen.setoid (λ (x y : α), r.rel x y ∨ s.rel x y)
(e t : expr) (md : tactic.transparency := tactic.transparency.reducible) (unify : bool := bool.tt) : tactic expr
{X : Type u_1} [emetric_space X] {ι : Type u_2} {I : finset ι} {s : ι → set X} {t : set X} : (∀ (i : ι), i ∈ I → is_metric_separated (s i) t) → is_metric_separated (⋃ (i : ι) (H : i ∈ I), s i) t
{α : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_group F] [normed_space ℝ F] {m : measurable_space α} {μ : measure_theory.measure α} (f : measure_theory.simple_func α E) (g : E → F) (hf : measure_theory.integrable ⇑f μ) (hg : g 0 = 0) : measure_theory.simple_func.integral μ (measure_theory.simple_func.map g f) = f.range.sum (λ (x : E), (⇑μ (⇑f ⁻¹' {x})).to_real • g x)
{ι : Type u_1} (I J : box_integral.box ι) (hJ : J ≤ I) (x : ι → ℝ) (h : x ∈ ⇑box_integral.box.Icc I) : box_integral.tagged_prepartition I
{α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] (μ : measure_theory.measure α) [μ.weakly_regular] (f : measure_theory.simple_func α nnreal) {ε : ennreal} (ε0 : ε ≠ 0) : ∃ (g : α → nnreal), (∀ (x : α), ⇑f x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f x) ∂μ + ε
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} [normed_group E] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] ⦃f : α × β → E⦄ (hf : measure_theory.strongly_measurable f) : measure_theory.strongly_measurable (λ (y : β), ∫ (x : α), f (x, y) ∂μ)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (I : lie_ideal R L) : lie_ideal R L
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {β : Type u_2} [complete_linear_order β] [densely_ordered β] [topological_space β] [order_topology β] [topological_space.second_countable_topology β] [measurable_space β] [borel_space β] (s : set β) (s_count : s.countable) (s_dense : dense s) (f : α → β) (h : ∀ (p : β), p ∈ s → ∀ (q : β), q ∈ s → p < q → (∃ (u v : set α), measurable_set u ∧ measurable_set v ∧ {x : α | f x < p} ⊆ u ∧ {x : α | q < f x} ⊆ v ∧ ⇑μ (u ∩ v) = 0)) : ae_measurable f μ
{V : Type u_1} [normed_group V] [nontrivial V] : ∥normed_group_hom.id V∥ = 1
{elab : bool := bool.tt} : expr elab → option (name × name × expr elab)
(mod_nam : module_info.module_name) (decl : name) (cur_mod : string := "") : environment
{β : Type u_2} [topological_space β] {α : Type u_1} (p : α → Prop) (e : α → β) (x : {x // p x}) : {x // x ∈ closure (e '' {x : α | p x})}
(h : name) (t : option expr := option.none) (pr : expr) : tactic expr
{k : Type u} [comm_ring k] (G : Type u) [group G] {V : Type u} [add_comm_group V] [module k V] [module (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] {W : Type u} [add_comm_group W] [module k W] [module (monoid_algebra k G) W] [is_scalar_tower k (monoid_algebra k G) W] (π : W →ₗ[k] V) [fintype G] : W →ₗ[k] V
(p : tactic.pattern) (e : expr) (m : tactic.transparency := tactic.transparency.reducible) : tactic (list level × list expr)
(R : Type u) [semiring R] (ι : Type v) [dec_ι : decidable_eq ι] {M : ι → Type w} [Π (i : ι), add_comm_monoid (M i)] [Π (i : ι), module R (M i)] (N : Type u₁) [add_comm_monoid N] [module R N] (φ : Π (i : ι), M i →ₗ[R] N) : direct_sum ι (λ (i : ι), M i) →ₗ[R] N
{k : Type u} [comm_ring k] {G : Type u} [group G] {V : Type u} [add_comm_group V] [module k V] [module (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] {W : Type u} [add_comm_group W] [module k W] [module (monoid_algebra k G) W] [is_scalar_tower k (monoid_algebra k G) W] (π : W →ₗ[k] V) (g : G) : W →ₗ[k] V
(e : expr) (cfg : tactic.apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}) : tactic (list (name × expr))
{C : Type u₁} (W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] [category_theory.enriched_category W C] {X Y : category_theory.forget_enrichment W C} (f : X ⟶ Y) : 𝟙_ W ⟶ category_theory.enriched_category.hom (category_theory.forget_enrichment.to W X) (category_theory.forget_enrichment.to W Y)
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (hf' : dense_range f) (hf : continuous f) {s : set α} (hs : dense s) : dense (f '' s)
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [topological_space.second_countable_topology E] [complete_space E] [normed_group F] {f : ℝ → E} {g : ℝ → F} {a b : ℝ} (l : filter ℝ) [l.ne_bot] [filter.tendsto_Ixx_class set.Icc l l] (hl : set.interval a b ∈ l) (hd : ∀ᶠ (x : ℝ) in l, differentiable_at ℝ f x) (hf : filter.tendsto (λ (x : ℝ), ∥f x∥) l filter.at_top) (hfg : deriv f =O[l] g) : ¬interval_integrable g measure_theory.measure_space.volume a b
{α : Type u_1} (s : set α) (r : α → α → Prop) : pairwise (λ (x y : ↥s), r ↑x ↑y) → s.pairwise r
{R : Type u} {σ : Type u_1} [comm_semiring R] (n : σ) : mv_polynomial σ R
{R : Type u_4} [normed_ring R] [complete_space R] (x : R) (h : ∥x∥ < 1) : ∥∑' (n : ℕ), x ^ n∥ ≤ ∥1∥ - 1 + (1 - ∥x∥)⁻¹
{α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : inducing f) {s : set α} : is_compact (f '' s) ↔ is_compact s
{σ : Type u_1} {k : Type u_3} [field k] (φ : mv_power_series σ k) : mv_power_series σ k
{α : Type u_1} (F : Type u_6) (𝕜 : Type u_11) [is_R_or_C 𝕜] [normed_group F] [normed_space 𝕜 F] (m : measurable_space α) [measurable_space α] (p : ennreal) (μ : measure_theory.measure α) : submodule 𝕜 ↥(measure_theory.Lp F p μ)
{ι : Type u} {γ : Type w} {β : ι → Type v} [dec : decidable_eq ι] [Π (i : ι), add_zero_class (β i)] [Π (i : ι) (x : β i), decidable (x ≠ 0)] [add_comm_monoid γ] (φ : Π (i : ι), β i →+ γ) (f : Π₀ (i : ι), β i) : ⇑(dfinsupp.sum_add_hom φ) f = f.sum (λ (x : ι), ⇑(φ x))
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] (σ : R →+* S) {σ' : S →+* R} [ring_hom_inv_pair σ σ'] [ring_hom_inv_pair σ' σ] (M : Type u_3) [topological_space M] [add_comm_monoid M] (M₂ : Type u_4) [topological_space M₂] [add_comm_monoid M₂] [module R M] [module S M₂] : Type (max u_3 u_4)
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] [category_theory.limits.has_zero_object V] {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] [category_theory.limits.has_zero_object W] (F : V ⥤ W) [F.additive] (c : complex_shape ι) (j : ι) : homological_complex.single V c j ⋙ F.map_homological_complex c ≅ F ⋙ homological_complex.single W c j
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {s : measure_theory.signed_measure α} (t : measure_theory.signed_measure α) (f : α → ℝ) (htμ : measure_theory.vector_measure.mutually_singular t μ.to_ennreal_vector_measure) (hadd : s = t + μ.with_densityᵥ f) : t = s.singular_part μ
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I J : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} [complete_space F] (h : box_integral.integrable I l f vol) (hJ : J ≤ I) : box_integral.integrable J l f vol
(rbp : ℕ := std.prec.max) (pat : bool := bool.ff) : lean.parser pexpr
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D E : homological_complex V c} (f : C ⟶ D) (hom : Π (i j : ι), D.X i ⟶ E.X j) : f ≫ homotopy.null_homotopic_map hom = homotopy.null_homotopic_map (λ (i j : ι), f.f i ≫ hom i j)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {x : M} {n : with_top ℕ} : cont_mdiff_within_at I I' n f s x ↔ continuous_within_at f s x ∧ cont_diff_within_at 𝕜 n (written_in_ext_chart_at I I' x f) (⇑((ext_chart_at I x).symm) ⁻¹' s ∩ set.range ⇑I) (⇑(ext_chart_at I x) x)
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {s t u : set α} (hs : measurable_set s) (h's : s ⊆ u) (h't : t ⊆ u) (h : ⇑μ u < ⇑μ s + ⇑μ t) : (s ∩ t).nonempty
{𝕜₂ : Type u_2} {𝕜₃ : Type u_3} {F : Type u_6} {G : Type u_8} [normed_group F] [normed_group G] [nondiscrete_normed_field 𝕜₂] [nondiscrete_normed_field 𝕜₃] [normed_space 𝕜₂ F] [normed_space 𝕜₃ G] {σ₂₃ : 𝕜₂ →+* 𝕜₃} {𝕜₂' : Type u_10} [nondiscrete_normed_field 𝕜₂'] {F' : Type u_11} [normed_group F'] [normed_space 𝕜₂' F'] {σ₂' : 𝕜₂' →+* 𝕜₂} {σ₂'' : 𝕜₂ →+* 𝕜₂'} {σ₂₃' : 𝕜₂' →+* 𝕜₃} [ring_hom_inv_pair σ₂' σ₂''] [ring_hom_inv_pair σ₂'' σ₂'] [ring_hom_comp_triple σ₂' σ₂₃ σ₂₃'] [ring_hom_comp_triple σ₂'' σ₂₃' σ₂₃] [ring_hom_isometric σ₂₃] [ring_hom_isometric σ₂'] [ring_hom_isometric σ₂''] [ring_hom_isometric σ₂₃'] (f : F →SL[σ₂₃] G) (g : F' ≃ₛₗᵢ[σ₂'] F) : ∥f.comp g.to_linear_isometry.to_continuous_linear_map∥ = ∥f∥
{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (I : ideal R) {ι : Type u_1} (s : set ι) (f : ι → M) (x : M) (hx : x ∈ I • submodule.span R (f '' s)) : ∃ (a : ↥s →₀ R) (ha : ∀ (i : ↥s), ⇑a i ∈ I), a.sum (λ (i : ↥s) (c : R), c • f ↑i) = x
{V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hxyne : x ≠ y) (hxzne : x ≠ z) {r : ℝ} (hx : ∥x∥ = r) (hy : ∥y∥ = r) (hz : ∥z∥ = r) : hb.oangle y z = 2 • hb.oangle (y - x) (z - x)
{α : Type u_1} {β : Type u_2} {m m0 : measurable_space α} {μ : measure_theory.measure α} [topological_space β] (f : α → β) (hfm : measure_theory.ae_strongly_measurable' m f μ) : α → β
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [category_theory.limits.has_wide_coequalizer f] [nonempty J] {W : C} {k l : category_theory.limits.wide_coequalizer f ⟶ W} (h : category_theory.limits.wide_coequalizer.π f ≫ k = category_theory.limits.wide_coequalizer.π f ≫ l) : k = l
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional 𝕜 E] : (⨆ (μ : 𝕜), module.End.eigenspace T μ)ᗮ = ⊥
{R₁ R₂ : ℝ} {c z : ℂ} {f : ℂ → ℂ} (hd : differentiable_on ℂ f (metric.ball c R₁)) (h_maps : set.maps_to f (metric.ball c R₁) (metric.ball (f c) R₂)) (hz : z ∈ metric.ball c R₁) : ∥dslope f c z∥ ≤ R₂ / R₁
{R : Type u_1} {E : Type u_2} [linear_ordered_field R] [add_comm_group E] [module R E] {s : set E} (hs : s.finite) : ⇑(convex_hull R) s = ⇑(finset.univ.sum (λ (x : ↥s), (linear_map.proj x).smul_right x.val)) '' std_simplex R ↥s
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w₁} [category_theory.category D] {E : Type w₂} [category_theory.category E] [∀ (α β : Type (max v u)) (fst snd : β → α), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) D] [∀ (α β : Type (max v u)) (fst snd : β → α), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) E] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ D] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ E] (P : Cᵒᵖ ⥤ D) [Π (F : D ⥤ E) (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)ᵒᵖ F] [Π (F : D ⥤ E) (X : C) (W : J.cover X) (P : Cᵒᵖ ⥤ D), category_theory.limits.preserves_limit (W.index P).multicospan F] : (category_theory.whiskering_left Cᵒᵖ D E).obj (J.plus_obj P) ≅ (category_theory.whiskering_left Cᵒᵖ D E).obj P ⋙ J.plus_functor E
{E : Type u_1} [normed_group E] [normed_space ℂ E] {a b : ℝ} {f : ℂ → E} (hd : diff_cont_on_cl ℂ f (complex.re ⁻¹' set.Ioo a b)) (hB : ∃ (c : ℝ) (H : c < real.pi / (b - a)) (B : ℝ), f =O[filter.comap (has_abs.abs ∘ complex.im) filter.at_top ⊓ filter.principal (complex.re ⁻¹' set.Ioo a b)] λ (z : ℂ), real.exp (B * real.exp (c * |z.im|))) (ha : ∀ (z : ℂ), z.re = a → f z = 0) (hb : ∀ (z : ℂ), z.re = b → f z = 0) : set.eq_on f 0 (complex.re ⁻¹' set.Icc a b)
(F : Type u_17) {R : out_param (Type u_18)} {S : out_param (Type u_19)} [semiring R] [semiring S] (σ : out_param (R →+* S)) (M : out_param (Type u_20)) (M₂ : out_param (Type u_21)) [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module S M₂] : Type (max u_17 u_20 u_21)
{p : ℕ+} {K : Type u} {L : Type v} {ζ : L} [field K] [field L] [algebra K L] [is_cyclotomic_extension {p} K L] [hp : fact (nat.prime ↑p)] [ne_zero ↑↑p] (hζ : is_primitive_root ζ ↑p) (hirr : irreducible (polynomial.cyclotomic ↑p K)) (hodd : p ≠ 2) : algebra.discr K ⇑((is_primitive_root.power_basis K hζ).basis) = (-1) ^ ((↑p - 1) / 2) * ↑p ^ (↑p - 2)
{E : Type u_4} {F : Type u_5} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] [normed_group F] [normed_space ℝ F] [finite_dimensional ℝ F] {f : E → F} {s t : set E} (h : cont_diff_on ℝ 1 f s) (hc : convex ℝ s) (ht : t ⊆ s) (htF : dimH t < ↑(finite_dimensional.finrank ℝ F)) : dense (f '' t)ᶜ
{σ : Type u_1} {R : Type u_2} [semiring R] (s : σ) : mv_power_series σ R
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g i) < s.sum (λ (i : ι), f i • g (⇑σ i)) ↔ ¬antivary_on f (g ∘ ⇑σ) ↑s
{I : Type v₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {J : Type v₁} [category_theory.small_category J] {F : J ⥤ Π (i : I), C i} (c : Π (i : I), category_theory.limits.cocone (F ⋙ category_theory.pi.eval C i)) : category_theory.limits.cocone F
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] [fintype ι] (I : box_integral.box ι) (l : box_integral.integration_params) (f : (ι → ℝ) → E) (vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤) (y : F) : Prop
{R : Type u} [comm_semiring R] {I : ideal R} {f : polynomial R} : f ∈ ideal.map polynomial.C I ↔ ∀ (n : ℕ), f.coeff n ∈ I
{C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] (ε : C ≌ D) : category_theory.is_idempotent_complete C ↔ category_theory.is_idempotent_complete D
{E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [compact_space M] : ∃ (n : ℕ) (e : M → euclidean_space ℝ (fin n)), smooth I (model_with_corners_self ℝ (euclidean_space ℝ (fin n))) e ∧ closed_embedding e ∧ ∀ (x : M), function.injective ⇑(mfderiv I (model_with_corners_self ℝ (euclidean_space ℝ (fin n))) e x)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) : Prop
{I : Type u} {fg : I → Type v} [Π (i : I), add_group (fg i)] {fp : I → Type w} [T : Π (i : I), add_torsor (fg i) (fp i)] : add_torsor (Π (i : I), fg i) (Π (i : I), fp i)
{α : Type u_1} {E : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [metric_space E] {f : ℕ → α → E} {g : α → E} (hfg : measure_theory.tendsto_in_measure μ f filter.at_top g) (n : ℕ) : ℕ
{p : ℕ+} {k : ℕ} {K : Type u} [field K] [char_zero K] {ζ : K} [hp : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ k} ℚ K] (hζ : is_primitive_root ζ ↑(p ^ k)) : algebra.discr ℚ ⇑((is_primitive_root.sub_one_power_basis ℚ hζ).basis) = (-1) ^ ((↑p ^ k).totient / 2) * ↑p ^ (↑p ^ (k - 1) * ((↑p - 1) * k - 1))
(x : string) {p q : Prop} (h : q → p) : slim_check.test_result p → (psum unit (p → q) := psum.inl ()) → slim_check.test_result q
{I : Type u} {f : I → Type v} [decidable_eq I] [Π (i : I), mul_one_class (f i)] : pairwise (λ (i j : I), ∀ (x : f i) (y : f j), commute (pi.mul_single i x) (pi.mul_single j y))
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) : filter α
{N : Type u_1} {G : Type u_2} [group N] [group G] {φ : G →* mul_aut N} : G →* N ⋊[φ] G
{E : Type u_1} {F : Type u_2} {𝕜 : Type u_3} {𝕜₂ : Type u_4} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] {ι : Type u_5} [complete_space E] {g : ι → (E →SL[σ₁₂] F)} (h : ∀ (x : E), ∃ (C : ℝ), ∀ (i : ι), ∥⇑(g i) x∥ ≤ C) : ∃ (C' : ℝ), ∀ (i : ι), ∥g i∥ ≤ C'
{W X Y Z S T : Top} (f₁ : W ⟶ S) (f₂ : X ⟶ S) (g₁ : Y ⟶ T) (g₂ : Z ⟶ T) {i₁ : W ⟶ Y} {i₂ : X ⟶ Z} (H₁ : embedding ⇑i₁) (H₂ : embedding ⇑i₂) (i₃ : S ⟶ T) (eq₁ : f₁ ≫ i₃ = i₁ ≫ g₁) (eq₂ : f₂ ≫ i₃ = i₂ ≫ g₂) : embedding ⇑(category_theory.limits.pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂)
{C : Type u₁} [category_theory.category C] {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z} (s : category_theory.comm_sq f g h i) : category_theory.limits.pullback_cone h i
{M : Type u_1} [comm_monoid M] (ζ : M) (k : ℕ) : Prop
{n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} {β : Type u} (g : Π {X : Type u}, (mvqpf.cofix F α → X) → (β → X) → β → F (α ::: X)) (x : β) : mvqpf.cofix F α
{α : Type u_1} {β : Type u_2} {M : Type u_5} [comm_monoid M] {f : α → M} {s : set β} {g : β → α} (hg : set.inj_on g (s ∩ function.mul_support (f ∘ g))) : finprod (λ (i : α), finprod (λ (H : i ∈ g '' s), f i)) = finprod (λ (j : β), finprod (λ (H : j ∈ s), f (g j)))
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} (x : E) {v : ι → E} {s : finset ι} (hv : orthonormal 𝕜 v) : s.sum (λ (i : ι), ∥has_inner.inner (v i) x∥ ^ 2) ≤ ∥x∥ ^ 2
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.tagged_prepartition I) : Prop
{R : Type u_1} {S : Type u_2} [semiring R] [semiring S] (σ : R →+* S) (M : Type u_3) (M₃ : Type u_4) [add_comm_monoid M] [add_comm_monoid M₃] [module R M] [module S M₃] (f : M →ₛₗ[σ] M₃) : M → M₃
{ι : Type v} [preorder ι] (G : ι → Type w) [Π (i : ι), comm_ring (G i)] (f : Π (i j : ι), i ≤ j → G i → G j) : Type (max v w)
{α : Type u_1} {m : measurable_space α} (s : measure_theory.signed_measure α) (μ : measure_theory.measure α) : Prop
(ε : ℝ) (l : ℕ) : ℕ
{n : ℕ} : ⇑(0.succ_above) = fin.succ
{β : Type u_1} [comm_monoid β] (f : ℕ → β) (h_mult : ∀ (x y : ℕ), x.coprime y → f (x * y) = f x * f y) (hf0 : f 0 = 1) (hf1 : f 1 = 1) {n : ℕ} : f n = n.factorization.prod (λ (p k : ℕ), f (p ^ k))
{n : ℕ} {F : typevec n → Type u} [mvfunctor F] [q : mvqpf F] {G : typevec n → Type u} [mvfunctor G] {FG_abs : Π {α : typevec n}, F α → G α} {FG_repr : Π {α : typevec n}, G α → F α} (FG_abs_repr : ∀ {α : typevec n} (x : G α), FG_abs (FG_repr x) = x) (FG_abs_map : ∀ {α β : typevec n} (f : α.arrow β) (x : F α), FG_abs (mvfunctor.map f x) = mvfunctor.map f (FG_abs x)) : mvqpf G
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.mutually_singular μ) : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (a : set α), ⇑ρ a / ⇑μ a) (v.filter_at x) (nhds 0)
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {f : α → β → γ} {s : set α} {t : set β} {g : γ → δ} {f' : β → α' → δ} {g' : α → α'} (h_antidistrib : ∀ (a : α) (b : β), g (f a b) = f' b (g' a)) : g '' set.image2 f s t = set.image2 f' t (g' '' s)
(α : Type u_1) (β : α → Type u_2) (γ : Π (a : α), β a → Type u_3) [Π (x : α) (y : β x), preorder (γ x y)] : (Π (x : Σ (a : α), β a), γ x.fst x.snd) →o Π (a : α) (b : β a), γ a b
{f : ℝ → ℝ} {a b : ℝ} {μ : measure_theory.measure ℝ} (hf : 0 ≤ᵐ[μ] f) (hfi : interval_integrable f μ a b) : 0 < ∫ (x : ℝ) in a..b, f x ∂μ ↔ a < b ∧ 0 < ⇑μ (function.support f ∩ set.Ioc a b)
{α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds a) (hfs : closure (f '' s) ∈ nhds (f a)) : continuous_at f a
{R : Type u} {σ : Type v} [comm_semiring R] (i : σ) : derivation R (mv_polynomial σ R) (mv_polynomial σ R)
{G : Type u_1} [measurable_space G] [has_mul G] [has_measurable_mul G] (μ : measure_theory.measure G) : (∀ (g : G) (A : set G), measurable_set A → ⇑μ ((λ (h : G), g * h) ⁻¹' A) = ⇑μ A) ↔ μ.is_mul_left_invariant
{I : Type u} (f : I → Type v) [Π (i : I), non_assoc_semiring (f i)] (i : I) : (Π (i : I), f i) →+* f i
{ι : Type u_1} {E : Type u_3} [semi_normed_group E] {f : ι → E} {g : ι → ℝ} {a : ℝ} (hg : has_sum g a) (h : ∀ (i : ι), ∥f i∥ ≤ g i) : ∥∑' (i : ι), f i∥ ≤ a
{α : Type u} {C : free_add_semigroup α → Sort l} (x : free_add_semigroup α) (ih1 : Π (x : α), C (has_pure.pure x)) (ih2 : Π (x : α) (y : free_add_semigroup α), C (has_pure.pure x) → C y → C (has_pure.pure x + y)) : C x
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} {s : set 𝕜} {x : 𝕜} (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) : iterated_deriv_within n f s x = (λ (g : 𝕜 → F), deriv_within g s)^[n] f x
(α : Type u) (β : Type v) [group α] [mul_action α β] {φ : quotient (mul_action.orbit_rel α β) → β} (hφ : function.right_inverse φ quotient.mk') : β ≃ Σ (ω : quotient (mul_action.orbit_rel α β)), ↥(mul_action.orbit α (φ ω))
{E : Type u_1} {F : Type u_2} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] [normed_group F] [normed_space ℝ F] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (hs : measurable_set s) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) (g : E → F) : measure_theory.integrable_on g (f '' s) μ ↔ measure_theory.integrable_on (λ (x : E), |(f' x).det| • g (f x)) s μ
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] [topological_space α] [borel_space α] [second_countable_topology_either α E] [measure_theory.is_finite_measure μ] (f : bounded_continuous_function α E) : continuous_map.to_ae_eq_fun μ f.to_continuous_map ∈ measure_theory.Lp E p μ
{R : Type u_1} {M : Type u_2} [comm_ring R] [comm_monoid M] [h : algebra.finite_type R (monoid_algebra R M)] : ∃ (G : finset M), algebra.adjoin R (⇑(monoid_algebra.of R M) '' ↑G) = ⊤
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] : category_theory.limits.walking_parallel_pair ⥤ C
{X : Top} {T : ↥X → Type v} (P : Top.local_predicate T) (x : ↥X) (w : ∀ (U V : topological_space.open_nhds x) (fU : Π (y : ↥(U.val)), T ↑y), P.to_prelocal_predicate.pred fU → ∀ (fV : Π (y : ↥(V.val)), T ↑y), P.to_prelocal_predicate.pred fV → fU ⟨x, _⟩ = fV ⟨x, _⟩ → (∃ (W : topological_space.open_nhds x) (iU : W ⟶ U) (iV : W ⟶ V), ∀ (w : ↥(W.val)), fU (⇑iU w) = fV (⇑iV w))) : function.injective (Top.stalk_to_fiber P x)
{R : Type u_1} [semiring R] [nontrivial R] : 1.order = 0
{elab : bool := bool.tt} : expr elab → option level
{α : Type u_2} [measurable_space α] {f : α → α} {s : set α} {μ : measure_theory.measure α} (hf : measure_theory.conservative f μ) (hs : measurable_set s) : ∀ᵐ (x : α) ∂μ, x ∈ s → (∃ᶠ (n : ℕ) in filter.at_top, f^[n] x ∈ s)
(e : expr) (include_goal : bool := bool.tt) : tactic expr
{M : Type u_1} {N : Type u_2} {μ : M → N → N} {α : Type u_3} [preorder α] [preorder N] {f : N → α} [covariant_class M N μ has_le.le] (hf : monotone f) (m : M) : monotone (λ (n : N), f (μ m n))
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} {s : category_theory.limits.cofork f g} (hs : category_theory.limits.is_colimit s) {W : C} (k : Y ⟶ W) (h : f ≫ k = g ≫ k) : {l // s.π ≫ l = k}
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) {s : set α} (hs : measurable_set s) {t : nnreal} (ht : 1 < t) : ⇑(μ.with_density (v.lim_ratio_meas hρ)) s ≤ ↑t ^ 2 * ⇑ρ s
{α : Type u} {C : free_magma α → Sort l} (x : free_magma α) (ih1 : Π (x : α), C (free_magma.of x)) (ih2 : Π (x y : free_magma α), C x → C y → C (x * y)) : C x
{C : Type u₁} (W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] [category_theory.enriched_category W C] (X : category_theory.forget_enrichment W C) : C
{n : ℕ} {F : typevec n → Type u} (R : Π ⦃α : typevec n⦄, F α → F α → Prop) [mvfunctor F] (Hfunc : ∀ ⦃α β : typevec n⦄ (a b : F α) (f : α.arrow β), R a b → R (mvfunctor.map f a) (mvfunctor.map f b)) ⦃α β : typevec n⦄ (f : α.arrow β) : mvqpf.quot1 R α → mvqpf.quot1 R β
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (μ : R) : submodule R M
{α : Type u} {β : Type v} [topological_space α] [semi_normed_group β] (f : bounded_continuous_function α β) : ∥f∥ = has_Inf.Inf {C : ℝ | 0 ≤ C ∧ ∀ (x : α), ∥⇑f x∥ ≤ C}
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] (s : set α) : ∀ᵐ (x : α) ∂μ.restrict s, filter.tendsto (λ (a : set α), ⇑μ (s ∩ a) / ⇑μ a) (v.filter_at x) (nhds 1)
{V : Type u₁} [quiver V] {W : Type u₂} [quiver W] (F : prefunctor V W) {a b : V} : quiver.path a b → quiver.path (F.obj a) (F.obj b)
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {f' : α → E'} {g' : α → F'} {l : filter α} : f' =o[l] g' → ((λ (x : α), ∥f' x∥) =o[l] λ (x : α), ∥g' x∥)
{ι : Type u_1} {R : Type u_2} {M : ι → Type u_4} {N : Type u_5} [dec_ι : decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M i)] [Π (i : ι), module R (M i)] [add_comm_monoid N] [module R N] ⦃φ ψ : (Π₀ (i : ι), M i) →ₗ[R] N⦄ (h : ∀ (i : ι), φ.comp (dfinsupp.lsingle i) = ψ.comp (dfinsupp.lsingle i)) : φ = ψ
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {m n : with_top ℕ} (hf : cont_mdiff I I' n f) (hmn : m + 1 ≤ n) : cont_mdiff I.tangent I'.tangent m (tangent_map I I' f)
(step : expr → tactic (expr × expr)) (no_dflt : bool := bool.ff) (hs : list tactic.simp_arg_type := list.nil) (attr_names : list name := list.nil) : expr → tactic (expr × expr)
{𝕜 : Type u} {ι : Type v} {ι' : Type v'} {E : ι → Type wE} {E' : ι' → Type wE'} {G : Type wG} [decidable_eq ι] [fintype ι] [decidable_eq ι'] [fintype ι'] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [Π (i : ι'), normed_group (E' i)] [Π (i : ι'), normed_space 𝕜 (E' i)] [normed_group G] [normed_space 𝕜 G] (f : multilinear_map 𝕜 E (multilinear_map 𝕜 E' G)) (C : ℝ) (H : ∀ (m₁ : Π (i : ι), E i) (m₂ : Π (i : ι'), E' i), ∥⇑(⇑f m₁) m₂∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m₁ i∥) * finset.univ.prod (λ (i : ι'), ∥m₂ i∥)) : continuous_multilinear_map 𝕜 E (continuous_multilinear_map 𝕜 E' G)
{R : Type u} {S₁ : Type v} {σ : Type u_1} [comm_semiring R] [comm_semiring S₁] {f : R →+* S₁} {g : S₁ →+* R} (hf : function.left_inverse ⇑f ⇑g) : function.left_inverse ⇑(mv_polynomial.map f) ⇑(mv_polynomial.map g)
{G : Type u_1} [hG : group G] [hf : fintype G] : [group.is_nilpotent G, normalizer_condition G, ∀ (H : subgroup G), is_coatom H → H.normal, ∀ (p : ℕ), fact (nat.prime p) → ∀ (P : sylow p G), ↑P.normal, nonempty ((Π (p : ↥((fintype.card G).factorization.support)) (P : sylow ↑p G), ↥↑P) ≃* G)].tfae
{α : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {m : measurable_space α} {μ : measure_theory.measure α} [complete_space F] {T : set α → (E →L[ℝ] F)} {C : ℝ} (hT : measure_theory.dominated_fin_meas_additive μ T C) {ι : Type u_4} {l : filter ι} [l.is_countably_generated] {fs : ι → α → E} {f : α → E} (bound : α → ℝ) (hfs_meas : ∀ᶠ (n : ι) in l, measure_theory.ae_strongly_measurable (fs n) μ) (h_bound : ∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, ∥fs n a∥ ≤ bound a) (bound_integrable : measure_theory.integrable bound μ) (h_lim : ∀ᵐ (a : α) ∂μ, filter.tendsto (λ (n : ι), fs n a) l (nhds (f a))) : filter.tendsto (λ (n : ι), measure_theory.set_to_fun μ T hT (fs n)) l (nhds (measure_theory.set_to_fun μ T hT f))
{α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] (m : measurable_space α) {m0 : measurable_space α} (μ : measure_theory.measure α) (f : α → F') : α → F'
{ι : Type v} [preorder ι] (G : ι → Type w) [Π (i : ι), comm_ring (G i)] (f : Π (i j : ι), i ≤ j → G i → G j) (i : ι) : G i →+* ring.direct_limit G f
{C : Type u} [category_theory.category C] (ℬ : Π (X Y : C), category_theory.limits.limit_cone (category_theory.limits.pair X Y)) (X Y : C) : C
{α : Type u} [pseudo_emetric_space α] {β : Type u_1} {p : β → Prop} {f : β → ennreal} (hf₀ : ∀ (x : β), p x → 0 < f x) (hf : ∀ (ε : ennreal), 0 < ε → (∃ (x : β) (hx : p x), f x ≤ ε)) : (uniformity α).has_basis p (λ (x : β), {p : α × α | has_edist.edist p.fst p.snd < f x})
{α : Type u_1} {m0 : measurable_space α} [topological_space α] (μ : measure_theory.measure α) : Prop
{V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P n) {i₁ i₂ : fin (n + 1)} (h : i₁ ≠ i₂) : ⇑(euclidean_geometry.reflection (affine_span ℝ (s.points '' {i₁, i₂}))) s.circumcenter = ⇑(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.reflection_circumcenter_weights_with_circumcenter i₁ i₂)
{elab : bool} : has_coe_to_fun (expr elab) (λ (e : expr elab), expr elab → expr elab)
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {t : set α} {f : α → E} {g : E → ℝ} (hg : convex_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (h0 : ⇑μ t ≠ 0) (ht : ⇑μ t ≠ ⊤) (hfs : ∀ᵐ (x : α) ∂μ.restrict t, f x ∈ s) (hfi : measure_theory.integrable_on f t μ) (hgi : measure_theory.integrable_on (g ∘ f) t μ) : g (⨍ (x : α) in t, f x ∂μ) ≤ ⨍ (x : α) in t, g (f x) ∂μ
{σ : Type u_1} (f : σ → option σ) (a b : σ) (c : option σ) (h₁ : turing.evals_to f a ↑b) (h₂ : turing.evals_to f b c) : turing.evals_to f a c
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : is_R_or_C.abs (has_inner.inner x y / (↑∥x∥ * ↑∥y∥)) = 1 ↔ x ≠ 0 ∧ ∃ (r : 𝕜), r ≠ 0 ∧ y = r • x
{R : Type u_1} {S : Type u_2} (L : Type u_4) [euclidean_domain R] [comm_ring S] [is_domain S] [field L] [algRL : algebra R L] [algebra R S] [algebra S L] [ist : is_scalar_tower R S L] [iic : is_integral_closure S R L] {abv : absolute_value R ℤ} {ι : Type u_5} [decidable_eq ι] [fintype ι] (bS : basis ι R S) (adm : abv.is_admissible) [infinite R] [decidable_eq R] [is_dedekind_domain S] [is_fraction_ring S L] (h : algebra.is_algebraic R L) (I : ↥(non_zero_divisors (ideal S))) : ∃ (J : ↥(non_zero_divisors (ideal S))), ⇑(class_group.mk0 L) I = ⇑(class_group.mk0 L) J ∧ ⇑(algebra_map R S) ((class_group.finset_approx bS adm).prod (λ (m : R), m)) ∈ ↑J
{K : Type u_1} [decidable_eq K] (Γ : K → Type u_2) (Λ : Type u_3) (σ : Type u_4) : Type (max u_1 u_2 u_3 u_4)
(G : Type u_1) {α : Type u_3} {m : measurable_space α} [group G] [mul_action G α] [measurable_space G] [has_measurable_smul G α] {μ : measure_theory.measure α} [measure_theory.smul_invariant_measure G α μ] [topological_space α] [has_continuous_const_smul G α] [mul_action.is_minimal G α] {K U : set α} (hK : is_compact K) (hμK : ⇑μ K ≠ 0) (hU : is_open U) (hne : U.nonempty) : 0 < ⇑μ U
{R : Type u} {L : Type v} {L' : Type w₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] (f : L →ₗ⁅R⁆ L') (I : lie_ideal R L) : lie_ideal R L'
{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] (M : submodule R A) {C : Π (n : ℕ) (x : A), x ∈ M ^ n → Prop} (hr : ∀ (r : R), C 0 (⇑(algebra_map R A) r) _) (hadd : ∀ (x y : A) (i : ℕ) (hx : x ∈ M ^ i) (hy : y ∈ M ^ i), C i x hx → C i y hy → C i (x + y) _) (hmul : ∀ (m : A) (H : m ∈ M) (i : ℕ) (x : A) (hx : x ∈ M ^ i), C i x hx → C i.succ (m * x) _) {x : A} {n : ℕ} (hx : x ∈ M ^ n) : C n x hx
{n : ℕ+} (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [is_cyclotomic_extension {n} K L] {ζ : L} (hζ : is_primitive_root ζ ↑n) : power_basis K L
{M : Type u_1} [comm_monoid M] (ζ : M) {n : ℕ+} (h : ζ ^ ↑n = 1) : ↥(roots_of_unity n M)
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {p q : ℝ} (hpq : p.is_conjugate_exponent q) {f g : α → nnreal} (hf : ae_measurable f μ) (hg : ae_measurable g μ) : ∫⁻ (a : α), ↑((f * g) a) ∂μ ≤ (∫⁻ (a : α), ↑(f a) ^ p ∂μ) ^ (1 / p) * (∫⁻ (a : α), ↑(g a) ^ q ∂μ) ^ (1 / q)
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B] (φ : A →ₐ[R] B) : subalgebra R B
{α : Type u} [pseudo_emetric_space α] (E : set α) (s : set ℝ) (hs : ∀ (ε : ℝ), 0 < ε → (s ∩ set.Ioc 0 ε).nonempty) : closure E = ⋂ (δ : ℝ) (H : δ ∈ s), metric.cthickening δ E
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] (f : α × β → ennreal) (hf : measurable f) : ∫⁻ (z : α × β), f z ∂μ.prod ν = ∫⁻ (y : β), ∫⁻ (x : α), f (x, y) ∂μ ∂ν
{α : Type u} [t : topological_space α] [topological_space.first_countable_topology α] {u : ℕ → α} {x : α} (hx : map_cluster_pt x filter.at_top u) : ∃ (ψ : ℕ → ℕ), strict_mono ψ ∧ filter.tendsto (u ∘ ψ) filter.at_top (nhds x)
{α : Type u_1} [measurable_space α] [topological_space α] (μ : measure_theory.measure α) : Prop
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f (⇑σ i) * g i) = finset.univ.sum (λ (i : ι), f i * g i) ↔ monovary (f ∘ ⇑σ) g
{α : Type u_1} {𝕜 : Type u_2} [linear_ordered_field 𝕜] [decidable_eq α] {A : finset α} (P : finpartition A) (G : simple_graph α) [decidable_rel G.adj] (ε : 𝕜) (s : finset α) : finset (finset α)
{𝕜 : Type u_1} {V : Type u_2} {W : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group V] [normed_space 𝕜 V] [normed_group W] [normed_space 𝕜 W] {n : with_top ℕ} (f : V →A[𝕜] W) : cont_diff 𝕜 n ⇑f
(R : Type u_1) {V : Type u_2} {W : Type u_3} (P : Type u_4) (Q : Type u_5) [ring R] [add_comm_group V] [module R V] [topological_space P] [add_torsor V P] [add_comm_group W] [module R W] [topological_space Q] [add_torsor W Q] : Type (max u_2 u_3 u_4 u_5)
{X : ℕ → Type u} [Π (n : ℕ), metric_space (X n)] {f : Π (n : ℕ), X n → X (n + 1)} (I : ∀ (n : ℕ), isometry (f n)) (n : ℕ) (x : X n) : metric.inductive_limit I
{R : Type u} {ι : Type x} [semiring R] {φ : ι → Type u_1} [Π (i : ι), add_comm_monoid (φ i)] [Π (i : ι), module R (φ i)] (I : set ι) (p : Π (i : ι), submodule R (φ i)) : submodule R (Π (i : ι), φ i)
(R : Type u) [ring R] (ι : Type v) [dec_ι : decidable_eq ι] [preorder ι] (G : ι → Type w) [Π (i : ι), add_comm_group (G i)] [Π (i : ι), module R (G i)] (f : Π (i j : ι), i ≤ j → (G i →ₗ[R] G j)) {P : Type u₁} [add_comm_group P] [module R P] (g : Π (i : ι), G i →ₗ[R] P) (Hg : ∀ (i j : ι) (hij : i ≤ j) (x : G i), ⇑(g j) (⇑(f i j hij) x) = ⇑(g i) x) : module.direct_limit G f →ₗ[R] P
{X : ℕ → Type u} [Π (n : ℕ), metric_space (X n)] {f : Π (n : ℕ), X n → X (n + 1)} (I : ∀ (n : ℕ), isometry (f n)) (x y : Σ (n : ℕ), X n) (m : ℕ) (hx : x.fst ≤ m) (hy : y.fst ≤ m) : metric.inductive_limit_dist f x y = has_dist.dist (nat.le_rec_on hx f x.snd) (nat.le_rec_on hy f y.snd)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) (hx0 : x ≠ 0) (hy0 : y ≠ 0) : is_R_or_C.abs (has_inner.inner x y) = ∥x∥ * ∥y∥ ↔ ∃ (r : 𝕜), r ≠ 0 ∧ y = r • x
{α : Type u} {σ : Type v} (M : DFA α σ) : list α → σ
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {X : C} (S : J.cover X) (T : Π (I : S.arrow), J.cover I.Y) : J.cover X
{σ : Type u_1} {τ : Type u_2} {R : Type u_4} [comm_semiring R] (f : σ → τ) : mv_polynomial σ R →ₐ[R] mv_polynomial τ R
{C : Type u} [category_theory.category C] {W X Y Z : C} [category_theory.limits.has_binary_product W X] [category_theory.limits.has_binary_product Y Z] (f : W ≅ Y) (g : X ≅ Z) : W ⨯ X ≅ Y ⨯ Z
(ε ε' : out_param (Type u)) (m m' : Type u → Type v) : Type (max (u+1) v)
{G : Type u_1} {α : Type u_2} [group G] [mul_action G α] [measurable_space α] {s : set α} {μ : measure_theory.measure α} [measurable_space G] [has_measurable_smul G α] [measure_theory.smul_invariant_measure G α μ] [encodable G] (hs : measure_theory.is_fundamental_domain G s μ) {f : α → ennreal} (hf : ∀ (γ : G) (x : α), f (γ • x) = f x) : ess_sup f (μ.restrict s) = ess_sup f μ
{α : Type u} [pseudo_metric_space α] {x : α} {ε : nnreal} : emetric.closed_ball x ↑ε = metric.closed_ball x ↑ε
{k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {V : Type u_2} [add_comm_monoid V] [module k V] [module (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] (W : submodule k V) (h : ∀ (g : G) (v : V), v ∈ W → ⇑(monoid_algebra.of k G) g • v ∈ W) : submodule (monoid_algebra k G) V
{Ω : Type u_1} [measure_theory.measure_space Ω] [measure_theory.is_probability_measure measure_theory.measure_space.volume] {ι : Type u_2} {X : ι → Ω → ℝ} {s : finset ι} (hs : ∀ (i : ι), i ∈ s → measure_theory.mem_ℒp (X i) 2 measure_theory.measure_space.volume) (h : ↑s.pairwise (λ (i j : ι), probability_theory.indep_fun (X i) (X j) measure_theory.measure_space.volume)) : probability_theory.variance (s.sum (λ (i : ι), X i)) measure_theory.measure_space.volume = s.sum (λ (i : ι), probability_theory.variance (X i) measure_theory.measure_space.volume)
(M : Type u_1) (N : Type u_2) (μ : M → N → N) (r : N → N → Prop) : Prop
{M : Type u_1} [mul_one_class M] (N : submonoid (M × M)) (H : equivalence (λ (x y : M), (x, y) ∈ N)) : con M
{n : ℕ} {K : Type u_8} [field K] {μ : K} (h : is_primitive_root μ n) [char_zero K] : primitive_roots n K ⊆ (polynomial.map (int.cast_ring_hom K) (minpoly ℤ μ)).roots.to_finset
{ι : Type u_1} [fintype ι] (l : box_integral.integration_params) (I : box_integral.box ι) (π₀ : box_integral.prepartition I) : filter (box_integral.tagged_prepartition I)
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] [has_measurable_inv G] [ν.is_mul_left_invariant] : measure_theory.measure.map (λ (z : G × G), (z.fst, (z.fst)⁻¹ * z.snd)) (μ.prod ν) = μ.prod ν
{V : Type u_1} [inner_product_space ℝ V] {P : Type u_2} [metric_space P] [normed_add_torsor V P] {a b p q : P} (hp : ∃ (k : ℝ), k ≠ 1 ∧ b -ᵥ p = k • (a -ᵥ p)) (hq : has_dist.dist a q = has_dist.dist b q) : has_dist.dist a p * has_dist.dist b p = |has_dist.dist b q ^ 2 - has_dist.dist p q ^ 2|
{K : Type u_1} [decidable_eq K] (Γ : K → Type u_2) (Λ : Type u_3) (σ : Type u_4) : Type (max u_1 u_2 u_3 u_4)
{α : Type u} {σ : Type v} (M : NFA α σ) : list α → set σ
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} {π : box_integral.tagged_prepartition I} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} {c : nnreal} {ε : ℝ} [complete_space F] (h : box_integral.integrable I l f vol) (h0 : 0 < ε) (hπ : l.mem_base_set I c (h.convergence_r ε c) π) {π₀ : box_integral.prepartition I} (hU : π.Union = π₀.Union) : has_dist.dist (box_integral.integral_sum f vol π) (π₀.boxes.sum (λ (J : box_integral.box ι), box_integral.integral J l f vol)) ≤ ε
{n : ℕ} (i : fin2 n) ⦃α : typevec n⦄ : mvqpf.prj i α → (mvqpf.prj.P i).obj α
{R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [decidable_eq ι] [semiring R] [Π (i : ι), add_comm_monoid (M₁ i)] [add_comm_monoid M₂] [Π (i : ι), module R (M₁ i)] [module R M₂] {M₁' : ι → Type u_1} [Π (i : ι), add_comm_monoid (M₁' i)] [Π (i : ι), module R (M₁' i)] (f : Π (i : ι), M₁ i →ₗ[R] M₁' i) : 0.comp_linear_map f = 0
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (F : Type u_5) [normed_group F] [normed_space 𝕜 F] : Type (max u_3 u_4 u_5)
{E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y : E} : same_ray ℝ x y ↔ ∥x + y∥ = ∥x∥ + ∥y∥
{R : Type u_1} [comm_ring R] {I J : ideal R} {x : R} : ⇑(ideal.quotient.mk I) x ∈ ideal.map (ideal.quotient.mk I) J ↔ x ∈ J ⊔ I
{M : Type u_1} [has_mul M] {S : set (con M)} : has_Sup.Sup S = con_gen (has_Sup.Sup (coe_fn '' S))
{J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {t : category_theory.limits.cocone F} (h : category_theory.limits.is_colimit t) {W : C} {f f' : t.X ⟶ W} (w : ∀ (j : J), t.ι.app j ≫ f = t.ι.app j ≫ f') : f = f'
{V : Type u_1} [inner_product_space ℝ V] {x y : V} (h : inner_product_geometry.angle x y = 0) : ∥x + y∥ = ∥x∥ + ∥y∥
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w₁} [category_theory.category D] {E : Type w₂} [category_theory.category E] {F : D ⥤ E} {G : E ⥤ D} [Π (X : C) (S : J.cover X) (P : Cᵒᵖ ⥤ D), category_theory.limits.preserves_limit (S.index P).multicospan F] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ D] [Π (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)ᵒᵖ (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] (adj : G ⊣ F) (X : category_theory.Sheaf J E) (Y : category_theory.Sheaf J D) : ((category_theory.Sheaf.compose_and_sheafify J G).obj X ⟶ Y) ≃ (X ⟶ (category_theory.Sheaf_compose J F).obj Y)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {n : with_top ℕ} {e : local_homeomorph M H} (h : e ∈ smooth_manifold_with_corners.maximal_atlas I M) : cont_mdiff_on I I n ⇑e e.to_local_equiv.source
{α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] {μ : measure_theory.measure α} (hf : measure_theory.strongly_measurable f) : ae_measurable f μ
{R : Type u} [comm_ring R] (I J : ideal R) : (R ⧸ I) ⧸ ideal.map (ideal.quotient.mk I) J ≃+* R ⧸ I ⊔ J
{α : Type u_1} {m0 : measurable_space α} (μ : measure_theory.measure α) : Prop
{K : Type u_1} [comm_ring K] [is_domain K] {ζ : K} {n : ℕ} (h : is_primitive_root ζ n) : ∃ (P : polynomial ℤ), polynomial.map (int.cast_ring_hom K) P = polynomial.cyclotomic' n K ∧ P.degree = (polynomial.cyclotomic' n K).degree ∧ P.monic
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {ε : Type u_5} {ζ : Type u_6} (f : α → β) (f' : γ → δ) (g : β → ε) (g' : δ → ζ) (x : α × γ) : prod.map g g' (prod.map f f' x) = prod.map (g ∘ f) (g' ∘ f') x
{C : Type u} [category_theory.category C] {X Y : C} {J : category_theory.grothendieck_topology C} {f : Y ⟶ X} {S : J.cover X} (I : (S.pullback f).arrow) : S.arrow
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] [smooth_manifold_with_corners I M] [smooth_manifold_with_corners I' M'] (f : M → M') (s : set M) (x : M) : tangent_space I x →L[𝕜] tangent_space I' (f x)
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] [fintype ι] (I : box_integral.box ι) (l : box_integral.integration_params) (f : (ι → ℝ) → E) (vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤) : Prop
{F : Type u_3} [inner_product_space ℝ F] (x y : F) : has_inner.inner x y = (∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - ∥x - y∥ * ∥x - y∥) / 2
{n : ℕ} {F : typevec n → Type u} (R : Π ⦃α : typevec n⦄, F α → F α → Prop) [mvfunctor F] [q : mvqpf F] (Hfunc : ∀ ⦃α β : typevec n⦄ (a b : F α) (f : α.arrow β), R a b → R (mvfunctor.map f a) (mvfunctor.map f b)) : mvqpf (mvqpf.quot1 R)
{β : Type w} {C : Type u} [category_theory.category C] {γ : Type v} (ε : β ≃ γ) (f : γ → C) [category_theory.limits.has_coproduct f] [category_theory.limits.has_coproduct (f ∘ ⇑ε)] : ∐ f ∘ ⇑ε ≅ ∐ f
{α : Type u_1} {mα : measurable_space α} {μ : measure_theory.measure α} {X Y : α → ℝ} (hXY : probability_theory.indep_fun X Y μ) (hXp : 0 ≤ X) (hYp : 0 ≤ Y) (hXm : ae_measurable X μ) (hYm : ae_measurable Y μ) : measure_theory.integral μ (X * Y) = measure_theory.integral μ X * measure_theory.integral μ Y
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {t : set α} {f : α → E} {g : E → ℝ} (hg : convex_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (h0 : ⇑μ t ≠ 0) (ht : ⇑μ t ≠ ⊤) (hfs : ∀ᵐ (x : α) ∂μ.restrict t, f x ∈ s) (hfi : measure_theory.integrable_on f t μ) (hgi : measure_theory.integrable_on (g ∘ f) t μ) : (⨍ (x : α) in t, f x ∂μ, ⨍ (x : α) in t, g (f x) ∂μ) ∈ {p : E × ℝ | p.fst ∈ s ∧ g p.fst ≤ p.snd}
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} [measure_theory.sigma_finite μ] (C : ennreal) {f : α → ennreal} (hf_meas : ae_measurable f μ) (hf : ∀ (s : set α), measurable_set s → ⇑μ s ≠ ⊤ → ∫⁻ (x : α) in s, f x ∂μ ≤ C) : ∫⁻ (x : α), f x ∂μ ≤ C
(ι : Type u_3) (M : Type u_4) [add_comm_monoid M] (I : with_top (box_integral.box ι)) : Type (max u_3 u_4)
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (I : lie_ideal R L) {I₁ I₂ : lie_ideal R L} (h₁ : I₁ ≤ I) (h₂ : I₂ ≤ I) : ⁅lie_ideal.comap I.incl I₁,lie_ideal.comap I.incl I₂⁆ = lie_ideal.comap I.incl ⁅I₁,I₂⁆
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (W : subspace K V) : (module.dual K V ⧸ W.dual_lift.range) ≃ₗ[K] ↥(submodule.dual_annihilator W)
{α : Type u_1} {E : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] {m : measurable_space α} {μ : measure_theory.measure α} {ι : Type u_3} {l : filter ι} [l.is_countably_generated] {F : ι → α → E} {f : α → E} (bound : α → ℝ) (hF_meas : ∀ᶠ (n : ι) in l, measure_theory.ae_strongly_measurable (F n) μ) (h_bound : ∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, ∥F n a∥ ≤ bound a) (bound_integrable : measure_theory.integrable bound μ) (h_lim : ∀ᵐ (a : α) ∂μ, filter.tendsto (λ (n : ι), F n a) l (nhds (f a))) : filter.tendsto (λ (n : ι), ∫ (a : α), F n a ∂μ) l (nhds (∫ (a : α), f a ∂μ))
{R : Type u_1} [semiring R] (I : ideal R) : Prop
{α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} (hf : isometry f) (s : set α) : metric.diam (f '' s) = metric.diam s
{σ : Type u_1} (n : ℕ) (φ : mv_polynomial σ ℤ) : ⇑mv_polynomial.C ↑n ∣ φ ↔ ⇑(mv_polynomial.map (int.cast_ring_hom (zmod n))) φ = 0
{α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {δ : Type u_1} [linear_order δ] [topological_space δ] [order_closed_topology δ] {a b : α} (hab : a ≤ b) {f : α → δ} (hf : continuous_on f (set.Icc a b)) : set.Icc (f a) (f b) ⊆ f '' set.Icc a b
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {s : set α} {t : set β} {f : α → β' → γ} {g : β → β'} {f' : α → β → δ} {g' : δ → γ} (h_right_comm : ∀ (a : α) (b : β), f a (g b) = g' (f' a b)) : set.image2 f s (g '' t) = g' '' set.image2 f' s t
{C : nonote → Sort u_1} (o : nonote) (H0 : C 0) (H1 : Π (e : nonote) (n : ℕ+) (a : nonote) (h : a.below e), C e → C a → C (e.oadd n a h)) : C o
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) {p : submodule R M} (hfp : ∀ (x : M), x ∈ p → ⇑f x ∈ p) (μ : R) : submodule.map p.subtype (module.End.eigenspace (linear_map.restrict f hfp) μ) ≤ f.eigenspace μ
{α : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] {f : α → E} {g : α → F} {l : filter α} (hf : filter.tendsto f l (nhds 0)) (hg : filter.is_bounded_under has_le.le l (has_norm.norm ∘ g)) (op : E → F → G) (h_op : ∀ (x : E) (y : F), ∥op x y∥ ≤ ∥x∥ * ∥y∥) : filter.tendsto (λ (x : α), op (f x) (g x)) l (nhds 0)
{E : Type u} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {f' : E} {x r : ℝ} (hf : has_deriv_within_at f f' (set.Ici x) x) (hr : ∥f'∥ < r) : ∃ᶠ (z : ℝ) in nhds_within x (set.Ioi x), (z - x)⁻¹ * (∥f z∥ - ∥f x∥) < r
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (F : Type u_5) [normed_group F] [normed_space 𝕜 F] : basic_smooth_vector_bundle_core I M F
(q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) (cfg : tactic.rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}) : tactic unit
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : α → F} {f' : α → E'} {l : filter α} : (λ (x : α), ∥f' x∥) =O[l] g → f' =O[l] g
{G : Type u_1} [group G] {H : subgroup G} {R S : set G} (hR : R ∈ subgroup.right_transversals ↑H) (hR1 : 1 ∈ R) (hS : subgroup.closure S = ⊤) : subgroup.closure ((λ (g : G), g * (↑(subgroup.mem_right_transversals.to_fun hR g))⁻¹) '' (R * S)) = H
{α : Type u} [pseudo_metric_space α] (H : ∀ (ε : ℝ), ε > 0 → (∃ (s : set α), s.countable ∧ ∀ (x : α), ∃ (y : α) (H : y ∈ s), has_dist.dist x y ≤ ε)) : topological_space.second_countable_topology α
(generate_ihs : bool) (major_premise : expr) (gm : tactic.eliminate.generalization_mode := tactic.eliminate.generalization_mode.generalize_all_except list.nil) (with_patterns : list tactic.eliminate.with_pattern := list.nil) : tactic unit
{α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {m m0 : measurable_space α} (hm : m ≤ m0) (μ : measure_theory.measure α) [measure_theory.sigma_finite (μ.trim hm)] : ↥(measure_theory.Lp F' 1 μ) →L[ℝ] ↥(measure_theory.Lp F' 1 μ)
{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : α ≃ₜ β) (s : set α) : ↥s ≃ₜ ↥(⇑e '' s)
{σ : Type u_1} {R : Type u_3} [comm_semiring R] : set_like.graded_monoid (mv_polynomial.homogeneous_submodule σ R)
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {t : set α} {f : α → E} [measure_theory.is_finite_measure μ] (hs : convex ℝ s) (h0 : ⇑μ t ≠ 0) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) (ht : ⨍ (x : α) in t, f x ∂μ ∈ interior s) : ⨍ (x : α), f x ∂μ ∈ interior s
{ιa : Type u_7} {ιb : Type u_8} [decidable_eq ιa] [decidable_eq ιb] [fintype ιa] [fintype ιb] {R' : Type u_9} {Mᵢ : Type u_10} {N₁ : Type u_11} {N₂ : Type u_12} [comm_semiring R'] [add_comm_group N₁] [module R' N₁] [add_comm_group N₂] [module R' N₂] [add_comm_monoid Mᵢ] [module R' Mᵢ] (a : alternating_map R' Mᵢ N₁ ιa) (b : alternating_map R' Mᵢ N₂ ιb) (σ : equiv.perm.mod_sum_congr ιa ιb) {v : ιa ⊕ ιb → Mᵢ} {i j : ιa ⊕ ιb} (hv : v i = v j) (hij : i ≠ j) : equiv.swap i j • σ = σ → ⇑(alternating_map.dom_coprod.summand a b σ) v = 0
{I : Type u_1} {A : Type u_2} {X : I → Type u_3} [Π (i : I), topological_space (X i)] [topological_space A] {f g : Π (i : I), C(A, X i)} (homotopies : Π (i : I), (f i).homotopy (g i)) : (continuous_map.pi f).homotopy (continuous_map.pi g)
{n : ℕ} {C : typevec (n + 1) → Sort u} (H : Π (α : typevec n) (β : Type u_1), C (α ::: β)) (γ : typevec (n + 1)) : C γ
{𝕜 : Type u_1} {E : Type u_3} [linear_ordered_field 𝕜] [topological_space E] [add_comm_group E] [module 𝕜 E] {s : set E} : strict_convex 𝕜 s ↔ s.pairwise (λ (x y : E), ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → (a / (a + b)) • x + (b / (a + b)) • y ∈ interior s)
{K : Type u_1} [comm_ring K] [is_domain K] {ζ : K} {n : ℕ} (hz : is_primitive_root ζ n) : polynomial.cyclotomic n K = (primitive_roots n K).prod (λ (μ : K), polynomial.X - ⇑polynomial.C μ)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (p : ι → P) {s : set ι} {i : ι} (hi : i ∈ s) : vector_span k (p '' s) = submodule.span k (has_vsub.vsub (p i) '' (p '' (s  {i})))
{A : Type u_1} [normed_ring A] [normed_algebra ℂ A] [complete_space A] [star_ring A] [cstar_ring A] [star_module ℂ A] [nontrivial A] (a : ↥(self_adjoint A)) : spectrum ℂ ↑a = coe ∘ complex.re '' spectrum ℂ ↑a
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_monoid M] {S : set (add_monoid_algebra R M)} (hS : algebra.adjoin R S = ⊤) : algebra.adjoin R (⋃ (f : add_monoid_algebra R M) (H : f ∈ S), add_monoid_algebra.of' R M '' ↑(f.support)) = ⊤
{R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] ⦃j k : S →+* P⦄ (h : j.comp (algebra_map R S) = k.comp (algebra_map R S)) : j = k
{R : Type u_1} {n : ℕ} [comm_ring R] [is_domain R] (hpos : 0 < n) {μ : R} (h : is_primitive_root μ n) : (polynomial.cyclotomic n R).is_root μ
{α : Type u_1} {m : measurable_space α} {μ ν s : measure_theory.measure α} {f : α → ennreal} (hf : measurable f) (hs : s.mutually_singular ν) (hadd : μ = s + ν.with_density f) : s = μ.singular_part ν
{r : ℝ} (hr : |r| < 1) : filter.tendsto (λ (n : ℕ), ↑n * r ^ n) filter.at_top (nhds 0)
{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] {L : Type u_3} {W : Type u_4} [field L] [add_comm_group W] [module L W] {σ : K →+* L} (f : V →ₛₗ[σ] W) (hf : function.injective ⇑f) : ℙ K V → ℙ L W
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {s : set α} {t : set β} {f : α' → β → γ} {g : α → α'} {f' : α → β → δ} {g' : δ → γ} (h_left_comm : ∀ (a : α) (b : β), f (g a) b = g' (f' a b)) : set.image2 f (g '' s) t = g' '' set.image2 f' s t
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X ⟶ Y) (g : X ⟶ Z) (h : X ⟶ W) [category_theory.epi h] (x : W ⟶ Y) (y : W ⟶ Z) (hhx : h ≫ x = f) (hhy : h ≫ y = g) (s : category_theory.limits.pushout_cocone f g) (hs : category_theory.limits.is_colimit s) : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk s.inl s.inr _)
{R : Type u} {S₁ : Type v} {σ : Type u_1} [comm_semiring R] [comm_semiring S₁] (f : R →+* S₁) : mv_polynomial σ R →+* mv_polynomial σ S₁
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_multiequalizer I] (W : C) (k : Π (a : I.L), W ⟶ I.left a) (h : ∀ (b : I.R), k (I.fst_to b) ≫ I.fst b = k (I.snd_to b) ≫ I.snd b) : W ⟶ category_theory.limits.multiequalizer I
 : ⇑(linear_map.to_matrix complex.basis_one_I complex.basis_one_I) complex.conj_ae.to_linear_map = ![![1, 0], ![0, -1]]
{n : ℕ+} {L : Type v} [field L] {ζ : L} (hζ : is_primitive_root ζ ↑n) {K : Type u_1} [linear_ordered_field K] [algebra K L] (hodd : odd ↑n) : ⇑(algebra.norm K) ζ = 1
{elab : bool} : expr elab → expr elab → expr elab
{ι : Type u_2} {π : ι → Type u_1} [fintype ι] [Π (i : ι), semi_normed_group (π i)] (x : Π (i : ι), π i) : finset.univ.sum (λ (i : ι), ∥x i∥₊) ≤ fintype.card ι • ∥x∥₊
{α : Type u_1} {β : Type u_2} {m0 : measurable_space α} {μ : measure_theory.measure α} {f : α → β} [has_zero β] [topological_space β] (hf : measure_theory.fin_strongly_measurable f μ) : ℕ → measure_theory.simple_func α β
(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (s : finset ι) {p : ι → P} (hi : ∀ (i : ι), i ∈ s → ∀ (j : ι), j ∈ s → p i = p j → i = j) {ps : set P} [fintype ↥ps] (hps : ps = p '' ↑s) : finset.centroid k s p = finset.centroid k finset.univ (λ (x : ↥ps), ↑x)
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) ⦃ι : Type v⦄ (U : ι → topological_space.opens ↥X) (P : category_theory.limits.is_limit (Top.presheaf.sheaf_condition_equalizer_products.fork F U)) : category_theory.limits.is_limit (category_theory.functor.map_cone F (category_theory.pairwise.cocone U).op)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] (I : model_with_corners 𝕜 E H) {G : Type u_5} [topological_space G] [charted_space H G] [add_group G] [lie_add_group I G] : topological_add_group G
{α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.regular] ⦃A : set α⦄ (hA : measurable_set A) (h'A : ⇑μ A ≠ ⊤) : ⇑μ A = ⨆ (K : set α) (H : K ⊆ A) (h : is_compact K), ⇑μ K
(σ : Type u_1) (R : Type u_3) [comm_semiring R] (n : ℕ) : mv_polynomial.homogeneous_submodule σ R n = finsupp.supported R R {d : σ →₀ ℕ | d.support.sum (λ (i : σ), ⇑d i) = n}
(V : Type u_2) {P : Type u_3} [semi_normed_group V] [pseudo_metric_space P] [normed_add_torsor V P] (x y : P) : has_dist.dist x y = ∥x -ᵥ y∥
{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} (hf : antitone f) {s : set α} : bdd_below s → bdd_above (f '' s)
{R : Type u} {σ : Type u_1} [comm_semiring R] (f : σ → R) : mv_polynomial σ R →+* R
{R : Type u} [ring R] (hR : is_field R) (I : ideal (polynomial R)) [hI : I.is_maximal] (x : R) (hx : ⇑polynomial.C x ∈ I) : x = 0
{σ : Type u_1} {R : Type u_2} [comm_semiring R] (n : σ →₀ ℕ) (φ : mv_power_series σ R) : mv_polynomial σ R
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (I : ideal R) (N : submodule R M) (hN : N.fg) (hIN : N ≤ I • N) (hIjac : I ≤ ⊥.jacobson) : N = ⊥
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] ⦃f : α → β → ennreal⦄ (hf : ae_measurable (function.uncurry f) (μ.prod ν)) : ∫⁻ (x : α), ∫⁻ (y : β), f x y ∂ν ∂μ = ∫⁻ (z : α × β), f z.fst z.snd ∂μ.prod ν
(α : Type u) [fintype α] (κ : Type v) [fintype κ] : ∃ (ι : Type) [_inst_3 : fintype ι], ∀ (C : (ι → α) → κ), ∃ (l : combinatorics.line α ι), combinatorics.line.is_mono C l
{C : Type u₁} (W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] [category_theory.enriched_category W C] {X Y Z : category_theory.forget_enrichment W C} (f : X ⟶ Y) (g : Y ⟶ Z) : category_theory.forget_enrichment.hom_to W (f ≫ g) = ((λ_ (𝟙_ W)).inv ≫ (category_theory.forget_enrichment.hom_to W f ⊗ category_theory.forget_enrichment.hom_to W g)) ≫ category_theory.e_comp W (category_theory.forget_enrichment.to W X) (category_theory.forget_enrichment.to W Y) (category_theory.forget_enrichment.to W Z)
(R : Type u_1) (S : Type u_2) (M : Type u_3) [semiring S] [add_comm_monoid M] [I : module S M] : module S (restrict_scalars R S M)
{α : Type u} [pseudo_metric_space α] {ε : ℝ} (ε0 : 0 < ε) : {p : α × α | has_dist.dist p.fst p.snd < ε} ∈ uniformity α
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (W : subspace K V) : (V ⧸ W) ≃ₗ[K] ↥(submodule.dual_annihilator W)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] (I : model_with_corners 𝕜 E H) (G : Type u_4) [group G] [topological_space G] [charted_space H G] : Prop
(e old new : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unify : bool := bool.tt) : tactic expr
{R : Type u} {σ : Type u_1} [comm_semiring R] {ι : Type u_2} {s : finset ι} (f : ι → mv_polynomial σ R) : (s.prod (λ (i : ι), f i)).vars ⊆ s.bUnion (λ (i : ι), (f i).vars)
{I : Type u} {f : I → Type v} [decidable_eq I] [Π (i : I), add_zero_class (f i)] (x : Π (i : I), f i) (i j : I) : add_commute (pi.single i (x i)) (pi.single j (x j))
{V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {n : ℕ} (s : affine.simplex ℝ P (n + 1)) (i : fin (n + 2)) (p : P) : affine_span ℝ {p, s.points i} = s.altitude i ↔ p ≠ s.points i ∧ p ∈ affine_span ℝ (set.range s.points) ∧ p -ᵥ s.points i ∈ ((affine_span ℝ (s.points '' ↑(finset.univ.erase i))).direction)ᗮ
{C : Type u} [category_theory.category C] {W X Y : C} {s : category_theory.limits.binary_fan X Y} (h : category_theory.limits.is_limit s) (f : W ⟶ X) (g : W ⟶ Y) : {l // l ≫ s.fst = f ∧ l ≫ s.snd = g}
 : pexpr → (list pexpr := list.nil) → pexpr × list pexpr
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {n : ℕ} (hn : 2 ≤ n + 1) (p : formal_multilinear_series 𝕜 E F) (i : E ≃L[𝕜] F) {r a C : ℝ} (hr : 0 ≤ r) (ha : 0 ≤ a) (hC : 0 ≤ C) (hp : ∀ (n : ℕ), ∥p n∥ ≤ C * r ^ n) : (finset.Ico 1 (n + 1)).sum (λ (k : ℕ), a ^ k * ∥p.right_inv i k∥) ≤ ∥↑(i.symm)∥ * a + ∥↑(i.symm)∥ * C * (finset.Ico 2 (n + 1)).sum (λ (k : ℕ), (r * (finset.Ico 1 n).sum (λ (j : ℕ), a ^ j * ∥p.right_inv i j∥)) ^ k)
{α : Type u_1} (F : Type u_6) (𝕜 : Type u_11) (p : ennreal) [is_R_or_C 𝕜] [normed_group F] [normed_space 𝕜 F] {m m0 : measurable_space α} (μ : measure_theory.measure α) [hp : fact (1 ≤ p)] (hm : m ≤ m0) : ↥(measure_theory.Lp_meas F 𝕜 m p μ) ≃ₗᵢ[𝕜] ↥(measure_theory.Lp F p (μ.trim hm))
{C : ℚ → Sort u} (a : ℚ) (H : Π (n : ℤ) (d : ℕ), d ≠ 0 → C (rat.mk n ↑d)) : C a
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] (f : α × β → E) {s : set α} {t : set β} (hf : measure_theory.integrable_on f (s ×ˢ t) (μ.prod ν)) : ∫ (z : α × β) in s ×ˢ t, f z ∂μ.prod ν = ∫ (x : α) in s, ∫ (y : β) in t, f (x, y) ∂ν ∂μ
(md : tactic.transparency := tactic.transparency.semireducible) : tactic unit
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] [measurable_space β] [measurable_space γ] (f : α → γ) (g : β → γ) (μ : measure_theory.measure α . "volume_tac") (ν : measure_theory.measure β . "volume_tac") : Prop
{α : Type u_1} {m : measurable_space α} {ℙ : measure_theory.measure α} [measure_theory.is_finite_measure «ℙ»] {X : α → ℝ} [measure_theory.has_pdf X «ℙ» measure_theory.measure_space.volume] : ∫ (x : ℝ), x * (measure_theory.pdf X «ℙ» measure_theory.measure_space.volume x).to_real = ∫ (x : α), X x ∂«ℙ»
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] ⦃f : α → β → ennreal⦄ (hf : ae_measurable (function.uncurry f) (μ.prod ν)) : ∫⁻ (x : α), ∫⁻ (y : β), f x y ∂ν ∂μ = ∫⁻ (y : β), ∫⁻ (x : α), f x y ∂μ ∂ν
{R : Type u_1} {S : Type u_6} {M : Type u_9} {M₃ : Type u_12} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid M₃] [module R M] [module S M₃] {σ : R →+* S} {f g : M →ₛₗ[σ] M₃} (h : f = g) (x : M) : ⇑f x = ⇑g x
(σ : Type u_1) (R : Type u_2) [semiring R] : R →+* mv_power_series σ R
{α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) (f : ↥(measure_theory.Lp F p μ)) (hf_meas : f ∈ measure_theory.Lp_meas_subgroup F m p μ) : measure_theory.mem_ℒp (Exists.some _) p (μ.trim hm)
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {I J : ideal R} {N N' : submodule R M} (hN' : N'.fg) (hIJ : I ≤ J.jacobson) (hNN : N ⊔ N' ≤ N ⊔ I • N') : N ⊔ I • N' = N ⊔ J • N'
{α : Type u} [semiring α] (I : ideal α) (ι : Type v) : ideal (ι → α)
(f : ℕ → ℝ) (R : ℝ) : [∃ (a : ℝ) (H : a ∈ set.Ioo (-R) R), f =o[filter.at_top] has_pow.pow a, ∃ (a : ℝ) (H : a ∈ set.Ioo 0 R), f =o[filter.at_top] has_pow.pow a, ∃ (a : ℝ) (H : a ∈ set.Ioo (-R) R), f =O[filter.at_top] has_pow.pow a, ∃ (a : ℝ) (H : a ∈ set.Ioo 0 R), f =O[filter.at_top] has_pow.pow a, ∃ (a : ℝ) (H : a < R) (C : ℝ) (h₀ : 0 < C ∨ 0 < R), ∀ (n : ℕ), |f n| ≤ C * a ^ n, ∃ (a : ℝ) (H : a ∈ set.Ioo 0 R) (C : ℝ) (H : C > 0), ∀ (n : ℕ), |f n| ≤ C * a ^ n, ∃ (a : ℝ) (H : a < R), ∀ᶠ (n : ℕ) in filter.at_top, |f n| ≤ a ^ n, ∃ (a : ℝ) (H : a ∈ set.Ioo 0 R), ∀ᶠ (n : ℕ) in filter.at_top, |f n| ≤ a ^ n].tfae
{C : Type u} [category_theory.category C] {W X Y Z : C} {f : W ⟶ X} [category_theory.limits.has_image f] {g : Y ⟶ Z} [category_theory.limits.has_image g] (sq : category_theory.arrow.mk f ⟶ category_theory.arrow.mk g) [category_theory.limits.has_image_map sq] : ↑(category_theory.limits.image_subobject f) ⟶ ↑(category_theory.limits.image_subobject g)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ - 2 * ⇑is_R_or_C.re (has_inner.inner x y) + ∥y∥ * ∥y∥
{α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} {f : ℕ → α → β} {g : α → β} [measure_theory.is_finite_measure μ] (hp : 1 ≤ p) (hp' : p ≠ ⊤) (hf : ∀ (n : ℕ), measure_theory.ae_strongly_measurable (f n) μ) (hg : measure_theory.mem_ℒp g p μ) (hui : measure_theory.unif_integrable f p μ) (hfg : measure_theory.tendsto_in_measure μ f filter.at_top g) : filter.tendsto (λ (n : ℕ), measure_theory.snorm (f n - g) p μ) filter.at_top (nhds 0)
{elab : bool := bool.tt} : expr elab → option (name × list level)
{α : Type u_1} [normed_field α] {E : Type u_5} [normed_group E] [normed_space α E] {c : α} (hc : 1 < ∥c∥) {ε : ℝ} (εpos : 0 < ε) {x : E} (hx : x ≠ 0) : ∃ (d : α), d ≠ 0 ∧ ∥d • x∥ < ε ∧ ε / ∥c∥ ≤ ∥d • x∥ ∧ ∥d∥⁻¹ ≤ ε⁻¹ * ∥c∥ * ∥x∥
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} (hc : convex_independent 𝕜 p) (s : set ι) (i : ι) : p i ∈ ⇑(convex_hull 𝕜) (p '' s) ↔ i ∈ s
{α : Type u_1} {ι : Type u_3} {M : Type u_5} [add_comm_monoid M] {f : α → M} {I : set ι} {t : ι → set α} (h : I.pairwise_disjoint t) (hI : I.finite) (ht : ∀ (i : ι), i ∈ I → (t i).finite) : finsum (λ (a : α), finsum (λ (H : a ∈ ⋃ (x : ι) (H : x ∈ I), t x), f a)) = finsum (λ (i : ι), finsum (λ (H : i ∈ I), finsum (λ (j : α), finsum (λ (H : j ∈ t i), f j))))
{R : Type u_1} [semiring R] {φ : power_series R} (n : ℕ) (h : ↑n < φ.order) : ⇑(power_series.coeff R n) φ = 0
(cs : interactive.parse (lean.parser.many lean.parser.ident)) (l : interactive.parse interactive.types.location) (cfg : tactic.dunfold_config := {to_dsimp_config := {md := tactic.transparency.instances, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}}) : tactic unit
(q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) (cfg : tactic.rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}) : tactic unit
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {a b : ℝ} {f f' : ℝ → ℝ} {g : ℝ → E} (h : ∀ (x : ℝ), x ∈ set.interval a b → has_deriv_at f (f' x) x) (h' : continuous_on f' (set.interval a b)) (hg : continuous_on g (f '' set.interval a b)) : ∫ (x : ℝ) in a..b, f' x • (g ∘ f) x = ∫ (x : ℝ) in f a..f b, g x
{I : Type u} (X : I → Top) : category_theory.limits.fan.mk (fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (Π (i : I), ↥(X i)))) (fundamental_groupoid_functor.proj X) ⟶ category_theory.Groupoid.pi_limit_fan (λ (i : I), fundamental_groupoid.fundamental_groupoid_functor.obj (X i))
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] ⦃f : α × β → E⦄ (h1f : measure_theory.ae_strongly_measurable f (μ.prod ν)) : measure_theory.integrable f (μ.prod ν) ↔ (∀ᵐ (y : β) ∂ν, measure_theory.integrable (λ (x : α), f (x, y)) μ) ∧ measure_theory.integrable (λ (y : β), ∫ (x : α), ∥f (x, y)∥ ∂μ) ν
{L : first_order.language} (M : Type w) [L.Structure M] (h : set.univ.countable) : (quotient.mk '' L.age M).countable
{ι : Type u_1} {I : box_integral.box ι} {π : box_integral.tagged_prepartition I} [fintype ι] (h : π.is_Henstock) (x : ι → ℝ) : (finset.filter (λ (J : box_integral.box ι), π.tag J = x) π.to_prepartition.boxes).card ≤ 2 ^ fintype.card ι
{C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] (G : D ⥤ C) [category_theory.is_right_adjoint G] [category_theory.reflects_isomorphisms G] [∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g] [Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G] : category_theory.monadic_right_adjoint G
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {s : set (α × β)} (hs : measurable_set s) : ⇑(μ.prod ν) s = 0 ↔ (λ (x : α), ⇑ν (prod.mk x ⁻¹' s)) =ᵐ[μ] 0
{R : Type u_1} [normed_ring R] {x : R} (h : ∥x∥ < 1) : filter.tendsto (λ (n : ℕ), x ^ n) filter.at_top (nhds 0)
{R : Type u_1} [comm_semiring R] {P : Type u_3} [comm_semiring P] (I : ideal R) [hI : I.is_prime] (J : ideal P) [hJ : J.is_prime] (f : R →+* P) (hIJ : I = ideal.comap f J) : localization.at_prime I →+* localization.at_prime J
(cls : name) (tac : tactic unit) (univ_poly : bool := bool.tt) (modify_target : name → list expr → expr → tactic expr := λ (_x : name) (_x : list expr), has_pure.pure) : derive_handler
{α : Type u_1} {m : measurable_space α} {μ ν : measure_theory.measure α} [μ.have_lebesgue_decomposition ν] : μ.absolutely_continuous ν ↔ ν.with_density (μ.rn_deriv ν) = μ
{σ : Type u_1} {R : Type u_3} [comm_semiring R] (n : ℕ) : mv_polynomial σ R →ₗ[R] mv_polynomial σ R
{I : Type u} (X : I → Top) (i : I) (x₀ x₁ : ↥(fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (Π (i : I), ↥(X i))))) (p : x₀ ⟶ x₁) : (fundamental_groupoid_functor.proj X i).map p = path.homotopic.proj i p
(n : interactive.parse lean.parser.ident) (p : interactive.parse (lean.parser.tk ":" *> interactive.types.texpr)) (m : tactic.transparency := tactic.transparency.reducible) : tactic (list expr)
{W : Type (v+1)} [category_theory.category W] [category_theory.monoidal_category W] {C : Type u₁} {D : Type u₂} [category_theory.enriched_category W C] [category_theory.enriched_category W D] (F : category_theory.enriched_functor W C D) : category_theory.forget_enrichment W C ⥤ category_theory.forget_enrichment W D
{α : Type u} [setoid α] [topological_space α] {s : set α} (H : dense s) : dense (quotient.mk '' s)
{R : Type u_1} (I : Type u_2) (A : Type u_3) [comm_semiring R] [semiring A] [algebra R A] : algebra R (I → A)
(R : Type u) (σ : Type u_1) [comm_semiring R] [he : is_empty σ] : mv_polynomial σ R ≃+* R
(G : Type u_1) {α : Type u_3} {m : measurable_space α} [add_group G] [add_action G α] [measurable_space G] [has_measurable_vadd G α] (μ : measure_theory.measure α) : [measure_theory.vadd_invariant_measure G α μ, ∀ (c : G) (s : set α), measurable_set s → ⇑μ (has_vadd.vadd c ⁻¹' s) = ⇑μ s, ∀ (c : G) (s : set α), measurable_set s → ⇑μ (c +ᵥ s) = ⇑μ s, ∀ (c : G) (s : set α), ⇑μ (has_vadd.vadd c ⁻¹' s) = ⇑μ s, ∀ (c : G) (s : set α), ⇑μ (c +ᵥ s) = ⇑μ s, ∀ (c : G), measure_theory.measure.map (has_vadd.vadd c) μ = μ, ∀ (c : G), measure_theory.measure_preserving (has_vadd.vadd c) μ μ].tfae
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] {I : C} (B : C) (t : category_theory.limits.is_initial I) [category_theory.cartesian_closed C] : category_theory.mono (t.to B)
{α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} (C : set (set α)) (hA : m0 = measurable_space.generate_from C) (hC : is_pi_system C) [measure_theory.is_finite_measure μ] (hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s) (h_univ : ⇑μ set.univ = ⇑ν set.univ) : μ = ν
{α : Type u_1} (F : Type u_6) (𝕜 : Type u_11) (p : ennreal) [is_R_or_C 𝕜] [normed_group F] [normed_space 𝕜 F] {m m0 : measurable_space α} (μ : measure_theory.measure α) (hm : m ≤ m0) (f : ↥(measure_theory.Lp F p (μ.trim hm))) : ↥(measure_theory.Lp_meas F 𝕜 m p μ)
{α : Sort u} {β : Sort v} {r : α → α → Prop} (e : α ≃ β) : quot r ≃ quot (λ (b b' : β), r (⇑(e.symm) b) (⇑(e.symm) b'))
{α : Type u_1} {β : Type u_2} [measurable_space α] [topological_space α] [opens_measurable_space α] [topological_space β] [topological_space.pseudo_metrizable_space β] [second_countable_topology_either α β] {f : α → β} {s : set α} {μ : measure_theory.measure α} (hf : continuous_on f s) (hs : measurable_set s) (x : α) : strongly_measurable_at_filter f (nhds_within x s) μ
{L : first_order.language} (α : Type w) {L' : first_order.language} (φ : L →ᴸ L') : L.with_constants α →ᴸ L'.with_constants α
{k : Type u₁} {G : Type u₂} [semiring k] [mul_one_class G] (f : monoid_algebra k G) : f ∈ submodule.span k (⇑(monoid_algebra.of k G) '' ↑(f.support))
{L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] (φ : L.hom M N) (S : L.substructure M) : L.substructure N
(G : Type u_1) {α : Type u_2} [has_zero G] [has_vadd G α] [measurable_space α] (s : set α) (μ : measure_theory.measure α . "volume_tac") : Prop
{α : Type u_1} {β : Type u_2} (r : α → β → Prop) {s : finset α} {t : finset β} {m n : ℕ} [Π (a : α) (b : β), decidable (r a b)] (hm : ∀ (a : α), a ∈ s → m ≤ (finset.bipartite_above r t a).card) (hn : ∀ (b : β), b ∈ t → (finset.bipartite_below r s b).card ≤ n) : s.card * m ≤ t.card * n
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} (hom : Π (i j : ι), C.X i ⟶ D.X j) : C ⟶ D
{R : Type u} {σ : Type u_1} [comm_semiring R] {S : Type u_2} {A : Type u_3} [comm_semiring S] [comm_semiring A] [algebra S R] [algebra S A] (f : R →ₐ[S] A) (x : σ → A) : mv_polynomial σ R →ₐ[S] A
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {μ : measure_theory.measure α} [normed_group E] {s : set α} (p : ennreal) (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) (c : E) : ↥(measure_theory.Lp E p μ)
{α : Type u} {β : Type v} {m : α → β} {s : set α} {g : ultrafilter β} (h : m '' s ∈ g) : ultrafilter α
{α : Type u} {C : list α → Sort u_1} (l : list α) (H0 : C list.nil) (H1 : Π (l : list α) (a : α), C l → C (l ++ [a])) : C l
{R : Type u_1} [semiring R] (φ ψ : power_series R) : linear_order.min φ.order ψ.order ≤ (φ + ψ).order
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : 0 ≤ ∥⇑(quotient_add_group.mk' S) m∥
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + 2 * ⇑is_R_or_C.re (has_inner.inner x y) + ∥y∥ * ∥y∥
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {s : set α} (hs : measurable_set s) : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (a : set α), ⇑μ (s ∩ a) / ⇑μ a) (v.filter_at x) (nhds (s.indicator 1 x))
{α : Type u_1} {β : Type u_2} {m0 : measurable_space α} [measurable_space β] {μ : measure_theory.measure α} {f : α → β} (hf : ae_measurable f μ) {s : set β} (hs : ⇑(measure_theory.measure.map f μ) s = 0) : ⇑μ (f ⁻¹' s) = 0
(e : expr) (md : tactic.transparency := tactic.transparency.semireducible) (unfold_ginductive : bool := bool.tt) : tactic name
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] [normed_group G] [normed_space 𝕜 G] {n : ℕ} (p : formal_multilinear_series 𝕜 E F) (c : composition n) (f : continuous_multilinear_map 𝕜 (λ (i : fin c.length), F) G) (v : fin n → E) : ∥⇑(continuous_multilinear_map.comp_along_composition p c f) v∥ ≤ ∥f∥ * finset.univ.prod (λ (i : fin c.length), ∥p (c.blocks_fun i)∥) * finset.univ.prod (λ (i : fin n), ∥v i∥)
{M : Type u_1} [mul_one_class M] ⦃s t : set M⦄ (h : s ⊆ t) : submonoid.closure s ≤ submonoid.closure t
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) (f : α → ennreal) : ennreal
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x : E} : ∥⇑innerSL x∥ = ∥x∥
{α : Type u_1} {E : Type u_3} [normed_group E] [normed_space ℝ E] [complete_space E] {m : measurable_space α} (μ : measure_theory.measure α) (f : α → E) : measure_theory.vector_measure α E
{R : Type u} {σ : Type u_1} [comm_semiring R] : R →+* mv_polynomial σ R
{R : Type u_1} {L : Type u_2} [comm_ring R] [lie_ring L] [lie_algebra R L] (I : lie_ideal R L) (M : Type u_3) [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (k : ℕ) : lie_submodule R L M
{R : Type u} [comm_semiring R] (h : ∃! (I : ideal R), I.is_maximal) : local_ring R
(f : expr) (nargs : option ℕ := option.none) (md : tactic.transparency := tactic.transparency.semireducible) : tactic fun_info
{C : Type u₁} [category_theory.category C] {X : C} (S : category_theory.presieve X) (R : Π ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, S f → category_theory.sieve Y) : category_theory.sieve X
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [metric_space β] {μ : measure_theory.measure α} [semilattice_sup ι] [nonempty ι] [encodable ι] {f : ι → α → β} {g : α → β} {s : set α} (hf : ∀ (n : ι), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hsm : measurable_set s) (hs : ⇑μ s ≠ ⊤) (hfg : ∀ᵐ (x : α) ∂μ, x ∈ s → filter.tendsto (λ (n : ι), f n x) filter.at_top (nhds (g x))) {ε : ℝ} (hε : 0 < ε) : ∃ (t : set α) (H : t ⊆ s), measurable_set t ∧ ⇑μ t ≤ ennreal.of_real ε ∧ tendsto_uniformly_on f g filter.at_top (s  t)
{L : first_order.language} (T : L.Theory) {α : Type w} {n : ℕ} (φ : L.bounded_formula α n) : Prop
{V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {B : bilin_form K V} {W : subspace K V} (b₁ : B.is_refl) : (B.restrict W).nondegenerate ↔ is_compl W (B.orthogonal W)
{R : Type u_1} [comm_semiring R] (σ : Type u_2) [fintype σ] (r : σ → R) : finset.univ.prod (λ (i : σ), ⇑polynomial.C (r i) + polynomial.X) = (finset.range (fintype.card σ + 1)).sum (λ (i : ℕ), (finset.powerset_len i finset.univ).sum (λ (t : finset σ), t.prod (λ (i : σ), ⇑polynomial.C (r i))) * polynomial.X ^ (fintype.card σ - i))
{E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} {C : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → has_deriv_within_at f (f' x) (set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥f' x∥ ≤ C) (x : ℝ) (H : x ∈ set.Icc a b) : ∥f x - f a∥ ≤ C * (x - a)
{G : Type u_1} [group G] ⦃h k : set G⦄ (h' : h ⊆ k) : subgroup.closure h ≤ subgroup.closure k
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {E : Type u₃} [category_theory.category E] {F G : C ⥤ D} {H I : D ⥤ E} (α : F ≅ G) (β : H ≅ I) : F ⋙ H ≅ G ⋙ I
{R : Type u_1} [normed_ring R] (k : ℕ) {r₁ : R} {r₂ : ℝ} (h : ∥r₁∥ < r₂) : (λ (n : ℕ), ↑n ^ k * r₁ ^ n) =o[filter.at_top] λ (n : ℕ), r₂ ^ n
{L : first_order.language} {ι : Type w} [preorder ι] [is_directed ι has_le.le] [nonempty ι] (G : ι → Type (max w w')) [Π (i : ι), L.Structure (G i)] (f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] : L.age (first_order.language.direct_limit G f) = ⋃ (i : ι), L.age (G i)
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) : ∃ (π : R), v.int_valuation_def π = ↑(⇑multiplicative.of_add (-1))
{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (f : M →* N) (s : set M) : submonoid.map f (submonoid.closure s) = submonoid.closure (⇑f '' s)
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : multilinear_map 𝕜 E G) (hf : continuous ⇑f) : ∃ (C : ℝ), 0 < C ∧ ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : ⇑is_R_or_C.re (has_inner.inner x y) = (∥x + y∥ * ∥x + y∥ - ∥x∥ * ∥x∥ - ∥y∥ * ∥y∥) / 2
(R : Type u) [ring R] (ι : Type v) [dec_ι : decidable_eq ι] [preorder ι] (G : ι → Type w) [Π (i : ι), add_comm_group (G i)] [Π (i : ι), module R (G i)] (f : Π (i j : ι), i ≤ j → (G i →ₗ[R] G j)) (i : ι) : G i →ₗ[R] module.direct_limit G f
{α : Type u_1} {E : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [metric_space E] {f : ℕ → α → E} {g : α → E} [measure_theory.is_finite_measure μ] (hf : ∀ (n : ℕ), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hfg : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (nhds (g x))) : measure_theory.tendsto_in_measure μ f filter.at_top g
(α : Type u_1) (E : Type u_2) {F : Type u_3} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {m : measurable_space α} (μ : measure_theory.measure α) {T : set α → (E →L[ℝ] F)} {C : ℝ} (hT : measure_theory.dominated_fin_meas_additive μ T C) : ↥(measure_theory.Lp.simple_func E 1 μ) →L[ℝ] F
{α : Type u} {β : Type v} [pseudo_metric_space α] [nonempty β] [semilattice_sup β] {u : β → α} : cauchy_seq u ↔ ∀ (ε : ℝ), ε > 0 → (∃ (N : β), ∀ (n : β), n ≥ N → has_dist.dist (u n) (u N) < ε)
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f (⇑σ i) • g i) ≤ s.sum (λ (i : ι), f i • g i)
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {E : Type u_3} [normed_group E] [normed_space ℝ E] [complete_space E] {f g : α → E} (hf : measure_theory.integrable f μ) (hg : measure_theory.integrable g μ) (hfg : μ.with_densityᵥ f = μ.with_densityᵥ g) : f =ᵐ[μ] g
(K : Type u_4) {L : Type u_5} [field K] [field L] [algebra K L] (E : Type u_7) [field E] [algebra K E] [finite_dimensional K L] [is_separable K L] [is_alg_closed E] {x : L} : ⇑(algebra_map K E) (⇑(algebra.norm K) x) = finset.univ.prod (λ (σ : L →ₐ[K] E), ⇑σ x)
{Ω : Type u_1} [measure_theory.measure_space Ω] [measure_theory.is_probability_measure measure_theory.measure_space.volume] {X : Ω → ℝ} (hX : measure_theory.mem_ℒp X 2 measure_theory.measure_space.volume) {c : ℝ} (hc : 0 < c) : ⇑measure_theory.measure_space.volume {ω : Ω | c ≤ |X ω - ∫ (a : Ω), X a|} ≤ ennreal.of_real (probability_theory.variance X measure_theory.measure_space.volume / c ^ 2)
{E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (hs : measurable_set s) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) : measurable_set (f '' s)
{α : Type u_1} {mα : measurable_space α} {μ : measure_theory.measure α} {X Y : α → ℝ} (hXY : probability_theory.indep_fun X Y μ) (hX : measure_theory.integrable X μ) (hY : measure_theory.integrable Y μ) : measure_theory.integral μ (X * Y) = measure_theory.integral μ X * measure_theory.integral μ Y
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] {f : α → β} [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] : measure_theory.ae_strongly_measurable f μ ↔ ae_measurable f μ ∧ ∃ (t : set β), topological_space.is_separable t ∧ ∀ᵐ (x : α) ∂μ, f x ∈ t
{G : Type u} [group G] (N : subgroup G) [nN : N.normal] {H : Type v} [group H] ⦃f g : G ⧸ N →* H⦄ (h : f.comp (quotient_group.mk' N) = g.comp (quotient_group.mk' N)) : f = g
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {ε : Type u_5} {ζ : Type u_6} (f : α → β → γ → δ → ε → ζ) : list α → list β → list γ → list δ → list ε → list ζ
{X : Type u_1} [pseudo_emetric_space X] [measurable_space X] [borel_space X] (μ : measure_theory.measure X) [measure_theory.is_finite_measure μ] : μ.weakly_regular
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s t : set α} (hs : measurable_set s) (ht : ⇑μ t ≠ ⊤) : ⇑μ (measure_theory.to_measurable μ t ∩ s) = ⇑μ (t ∩ s)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {n : with_top ℕ} {E'' : Type u_14} [normed_group E''] [normed_space 𝕜 E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners 𝕜 E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {t : set M'} {g : M' → M''} (hg : cont_mdiff_on I' I'' n g t) (hf : cont_mdiff_on I I' n f s) (st : s ⊆ f ⁻¹' t) : cont_mdiff_on I I'' n (g ∘ f) s
{α : Type u_1} [conditionally_complete_linear_order α] {s : set α} [hs : s.ord_connected] ⦃t : set ↥s⦄ (ht : t.nonempty) (h_bdd : bdd_above t) : has_Sup.Sup (coe '' t) ∈ s
{V : Type u_1} [inner_product_space ℝ V] (x y : V) : real.cos (inner_product_geometry.angle x y) = has_inner.inner x y / (∥x∥ * ∥y∥)
{V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (P Q : chain_complex V ℕ) (zero : P.X 0 ⟶ Q.X 0) (one : P.X 1 ⟶ Q.X 1) (one_zero_comm : one ≫ Q.d 1 0 = P.d 1 0 ≫ zero) (succ : Π (n : ℕ) (p : Σ' (f : P.X n ⟶ Q.X n) (f' : P.X (n + 1) ⟶ Q.X (n + 1)), f' ≫ Q.d (n + 1) n = P.d (n + 1) n ≫ f), Σ' (f'' : P.X (n + 2) ⟶ Q.X (n + 2)), f'' ≫ Q.d (n + 2) (n + 1) = P.d (n + 2) (n + 1) ≫ p.snd.fst) (n : ℕ) : Σ' (f : P.X n ⟶ Q.X n) (f' : P.X (n + 1) ⟶ Q.X (n + 1)), f' ≫ Q.d (n + 1) n = P.d (n + 1) n ≫ f
{α : Type u_2} [measurable_space α] (μ : measure_theory.measure α) : measure_theory.conservative id μ
{X : Type u_1} {Y : Type u_2} [topological_space X] {m : measurable_space X} [topological_space Y] [t2_space Y] {μ : measure_theory.measure X} [μ.is_open_pos_measure] {f g : X → Y} (h : f =ᵐ[μ] g) (hf : continuous f) (hg : continuous g) : f = g
{α : Type u_1} {m0 : measurable_space α} (μ : measure_theory.measure α) : Prop
{ι : Type u_1} {I : box_integral.box ι} (π : box_integral.prepartition I) (J : box_integral.box ι) : box_integral.prepartition J
{α : Type u} [pseudo_metric_space α] (x : α) (ε : ℝ) : set α
{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] {I : ideal A} (h : I.fg) (hfp : algebra.finite_presentation R A) : algebra.finite_presentation R (A ⧸ I)
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {p : α × β → Prop} (h : ∀ᵐ (z : α × β) ∂μ.prod ν, p z) : ∀ᵐ (x : α) ∂μ, ∀ᵐ (y : β) ∂ν, p (x, y)
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ⟶ Y} {s : category_theory.limits.cokernel_cofork f} (hs : category_theory.limits.is_colimit s) {W : C} (k : Y ⟶ W) (h : f ≫ k = 0) : {l // category_theory.limits.cofork.π s ≫ l = k}
{α : Type u_1} {E : Type u_3} [normed_group E] [topological_space α] {f : α → E} : has_compact_support f → has_compact_support (λ (x : α), ∥f x∥)
{R : Type u} {σ : Type v} [comm_ring R] (I : ideal R) : mv_polynomial σ (R ⧸ I) ≃ₐ[R] mv_polynomial σ R ⧸ ideal.map mv_polynomial.C I
{β : Type v} {γ : Type w} [emetric_space γ] [emetric_space β] {f : γ → β} : uniform_embedding f ↔ (∀ (ε : ennreal), ε > 0 → (∃ (δ : ennreal) (H : δ > 0), ∀ {a b : γ}, has_edist.edist a b < δ → has_edist.edist (f a) (f b) < ε)) ∧ ∀ (δ : ennreal), δ > 0 → (∃ (ε : ennreal) (H : ε > 0), ∀ {a b : γ}, has_edist.edist (f a) (f b) < ε → has_edist.edist a b < δ)
{E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] (s : finset E) (hs : ∀ (c : E), c ∈ s → ∥c∥ ≤ 2) (h : ∀ (c : E), c ∈ s → ∀ (d : E), d ∈ s → c ≠ d → 1 ≤ ∥c - d∥) : s.card ≤ 5 ^ finite_dimensional.finrank ℝ E
(n : name) (n' : name := n.append_suffix "_assoc") : tactic unit
{R : Type u_1} {S : Type u_6} {M : Type u_7} {M₂ : Type u_9} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid M₂] {module_M : module R M} {module_S_M₂ : module S M₂} {σ : R →+* S} {σ' : S →+* R} {re₁ : ring_hom_inv_pair σ σ'} {re₂ : ring_hom_inv_pair σ' σ} (e : M ≃ₛₗ[σ] M₂) : M₂ ≃ₛₗ[σ'] M
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h : ↑r < p.radius) : (λ (n : ℕ), ∥p n∥ * ↑r ^ n) =o[filter.at_top] λ (_x : ℕ), 1
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : α → ℝ} (hf : measure_theory.integrable f μ) : filter.tendsto (λ (A : ℝ), ∫ (x : α), probability_theory.truncation f A x ∂μ) filter.at_top (nhds (∫ (x : α), f x ∂μ))
{α : Type u_1} {β : Type u_2} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} {f : ℕ → α → β} {g : α → β} (hp : 1 ≤ p) (hp' : p ≠ ⊤) (hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ) (hg : measure_theory.mem_ℒp g p μ) (hfg : filter.tendsto (λ (n : ℕ), measure_theory.snorm (f n - g) p μ) filter.at_top (nhds 0)) : measure_theory.unif_integrable f p μ
{α : Type u_1} {β : Type u_2} [conditionally_complete_lattice β] {m : measurable_space α} (f : α → β) (μ : measure_theory.measure α) : β
{σ : Type u_1} (f : σ → option σ) (a : σ) (b : option σ) : Type
{E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] {s : set E} (u : ℕ → E) (sb : metric.bounded s) (hu : metric.bounded (set.range u)) (hs : pairwise (disjoint on λ (n : ℕ), {u n} + s)) (h's : measurable_set s) : ⇑μ s = 0
{α : Type u_1} {β : Type u_2} [measurable_space α] [topological_space α] [opens_measurable_space α] [measurable_space β] [topological_space β] [borel_space β] {f : α → β} {s : set α} {μ : measure_theory.measure α} (hf : continuous_on f s) (hs : measurable_set s) : ae_measurable f (μ.restrict s)
{E : Type u_3} [semi_normed_group E] (u v : E) : ∥v∥ ≤ ∥u∥ + ∥u - v∥
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] ⦃f g : α × β → E⦄ (hf : measure_theory.integrable f (μ.prod ν)) (hg : measure_theory.integrable g (μ.prod ν)) : ∫ (x : α), ∫ (y : β), (f + g) (x, y) ∂ν ∂μ = ∫ (x : α), ∫ (y : β), f (x, y) ∂ν ∂μ + ∫ (x : α), ∫ (y : β), g (x, y) ∂ν ∂μ
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g i) ≤ s.sum (λ (i : ι), f (⇑σ i) • g i)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {f' : E ≃L[𝕜] F} {s : set E} {c : nnreal} (hf : approximates_linear_on f ↑f' s c) (hc : subsingleton E ∨ c < ∥↑(f'.symm)∥₊⁻¹) : approximates_linear_on ⇑((hf.to_local_equiv hc).symm) ↑(f'.symm) (f '' s) (∥↑(f'.symm)∥₊ * (∥↑(f'.symm)∥₊⁻¹ - c)⁻¹ * c)
{n : ℕ} {K : Type u_8} [field K] {μ : K} (h : is_primitive_root μ n) [char_zero K] {p : ℕ} [fact (nat.prime p)] (hdiv : ¬p ∣ n) : squarefree (polynomial.map (int.cast_ring_hom (zmod p)) (minpoly ℤ μ))
{S : Type u} [add_semigroup S] : transitive (λ (a b : S), ∃ (c : S), add_semiconj_by c a b)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) : local_equiv E H
(V : Type u_1) (W : Type u_2) : simple_graph (V ⊕ W)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {H : Type u_4} [topological_space H] {H' : Type u_5} [topological_space H'] (I : model_with_corners 𝕜 E H) (I' : model_with_corners 𝕜 E' H') (M : Type u_6) [topological_space M] [charted_space H M] (M' : Type u_7) [topological_space M'] [charted_space H' M'] (n : with_top ℕ) : Type (max u_6 u_7)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring 𝕜] [add_comm_group E] [add_comm_group F] [module 𝕜 E] [module 𝕜 F] {s : set E} (f : E →ᵃ[𝕜] F) (hs : convex 𝕜 s) : convex 𝕜 (⇑f '' s)
{α : Type u_1} [measurable_space α] (p : ennreal) (μ : measure_theory.measure α) (G : Type u_7) [normed_lattice_add_comm_group G] : {g // 0 ≤ g} → {g // 0 ≤ g}
{G : Type u} [group G] (X : Type u) (of : X → G) (lift : Π {H : Type u} [_inst_5 : group H], (X → H) ≃ (G →* H)) (lift_of : ∀ {H : Type u} [_inst_6 : group H] (f : X → H) (a : X), ⇑(⇑lift f) (of a) = f a) : is_free_group G
{X : ℕ → Type u} [Π (n : ℕ), metric_space (X n)] {f : Π (n : ℕ), X n → X (n + 1)} (I : ∀ (n : ℕ), isometry (f n)) (n : ℕ) : metric.to_inductive_limit I n.succ ∘ f n = metric.to_inductive_limit I n
(lemmas : list (tactic expr)) (opt : tactic.apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}) (tac : tactic unit := tactic.skip) (on_success : expr → tactic unit := λ (_x : expr), tactic.skip) (on_failure : tactic unit := tactic.skip) : tactic unit
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_10} [semi_normed_group E'] [normed_space 𝕜 E'] [ring_hom_isometric σ₁₂] [proper_space F] {s : set (E' →SL[σ₁₂] F)} (hb : metric.bounded s) : is_compact (closure (coe_fn '' s))
{E : Type u_3} [normed_group E] {f : ℝ → E} {a b : ℝ} {μ : measure_theory.measure ℝ} : interval_integrable f μ a b ↔ measure_theory.integrable_on f (set.interval_oc a b) μ
(s : ℕ := 0) : std_gen
{α : Type u} [decidable_eq α] (i j : α) (σ : equiv.perm α) : σ * equiv.swap i j * equiv.swap i j = σ
(n : ℕ) : 3 ∣ n ↔ 3 ∣ (10.digits n).sum
{n : ℤ} {c w : ℂ} {R : ℝ} (hn : n < 0) (hw : w ∈ metric.sphere c |R|) : ∮ (z : ℂ) in C(c, R), (z - w) ^ n = 0
{I : Type u} (f : I → Type v) [Π (i : I), mul_one_class (f i)] (i : I) : (Π (i : I), f i) →* f i
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [nonempty J] (s : category_theory.limits.cotrident f) {W : C} {k l : s.X ⟶ W} (h : s.π ≫ k = s.π ≫ l) (j : category_theory.limits.walking_parallel_family J) : s.ι.app j ≫ k = s.ι.app j ≫ l
{I : Type w₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {D : Type u₂} [category_theory.category D] (F : Π (i : I), C i ⥤ D) (i : I) : category_theory.sigma.incl i ⋙ category_theory.sigma.desc F ≅ F i
{N : Type u_1} {G : Type u_2} {H : Type u_3} [group N] [group G] [group H] {φ : G →* mul_aut N} (f₁ : N →* H) (f₂ : G →* H) (h : ∀ (g : G), f₁.comp (mul_equiv.to_monoid_hom (⇑φ g)) = (mul_equiv.to_monoid_hom (⇑mul_aut.conj (⇑f₂ g))).comp f₁) : N ⋊[φ] G →* H
{G : Type u} [group G] {H : Type v} [group H] (φ : G →* H) (hφ : function.surjective ⇑φ) : G ⧸ φ.ker ≃* H
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] : submodule R (Π (n : ℕ), M ⧸ I ^ n • ⊤)
{N : Type u_1} {G : Type u_2} [group N] [group G] {φ : G →* mul_aut N} : N →* N ⋊[φ] G
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} [nontrivial k] {p : ι → P} (ha : affine_independent k p) (i : ι) (s : set ι) : p i ∈ affine_span k (p '' s) ↔ i ∈ s
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {σ₂₁ : 𝕜₂ →+* 𝕜} [ring_hom_inv_pair σ₁₂ σ₂₁] [ring_hom_inv_pair σ₂₁ σ₁₂] (e : E ≃ₛₗ[σ₁₂] F) (C_to C_inv : ℝ) (h_to : ∀ (x : E), ∥⇑e x∥ ≤ C_to * ∥x∥) (h_inv : ∀ (x : F), ∥⇑(e.symm) x∥ ≤ C_inv * ∥x∥) : E ≃SL[σ₁₂] F
{𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} : has_strict_deriv_at f f' x → has_strict_fderiv_at f (1.smul_right f') x
{σ : Type u_1} (R : Type u_2) [semiring R] (n : σ →₀ ℕ) : mv_power_series σ R →ₗ[R] R
(use_iota_eqn : interactive.parse (optional (lean.parser.tk "!"))) (no_dflt : interactive.parse interactive.types.only_flag) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (cfg : tactic.simp_config_ext := {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt, trace_lemmas := bool.ff}, discharger := tactic.failed unit}) : smt_tactic unit
(x : name) (e : expr) (cfg : tactic.equiv_rw_cfg := {max_depth := 10}) : tactic unit
{α : Type u_1} {E : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [metric_space E] {f : ℕ → α → E} {g : α → E} (hfg : measure_theory.tendsto_in_measure μ f filter.at_top g) : ℕ → ℕ
{R : Type u_1} [comm_ring R] [is_domain R] {s : multiset (ideal R)} : s.prod = ⊥ ↔ ∃ (I : ideal R) (H : I ∈ s), I = ⊥
{α : Type u_1} {m : measurable_space α} (μ ν : measure_theory.measure α) [measure_theory.is_finite_measure μ] [measure_theory.is_finite_measure ν] (h : ¬μ.mutually_singular ν) : ∃ (ε : nnreal), 0 < ε ∧ ∃ (E : set α), measurable_set E ∧ 0 < ⇑ν E ∧ 0.restrict E ≤ (μ.to_signed_measure - (ε • ν).to_signed_measure).restrict E
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] [complete_space E] {T : E →L[𝕜] E} (hT : inner_product_space.is_self_adjoint ↑T) {x₀ : E} (hx₀ : x₀ ≠ 0) (hextr : is_local_extr_on T.re_apply_inner_self (metric.sphere 0 ∥x₀∥) x₀) : module.End.has_eigenvector ↑T ↑((λ (x : E), T.re_apply_inner_self x / ∥x∥ ^ 2) x₀) x₀
{K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] (W : subspace K V) : module.dual K ↥W ≃ₗ[K] ↥(W.dual_lift.range)
{R : Type u_3} {S : Type u_4} {F : Type u_5} [comm_ring R] [comm_ring S] [ring_hom_class F (polynomial R) (polynomial S)] (φ : F) (hφ : non_zero_divisors (polynomial R) ≤ submonoid.comap ↑φ (non_zero_divisors (polynomial S))) : ratfunc R →+* ratfunc S
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} {W : C} {fst : W ⟶ X} {snd : W ⟶ Y} (eq : fst ≫ f = snd ≫ g) (lift : Π (s : category_theory.limits.pullback_cone f g), s.X ⟶ W) (fac_left : ∀ (s : category_theory.limits.pullback_cone f g), lift s ≫ fst = s.fst) (fac_right : ∀ (s : category_theory.limits.pullback_cone f g), lift s ≫ snd = s.snd) (uniq : ∀ (s : category_theory.limits.pullback_cone f g) (m : s.X ⟶ W), m ≫ fst = s.fst → m ≫ snd = s.snd → m = lift s) : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk fst snd eq)
{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {p : submodule R M} (hfp : ∀ (x : M), x ∈ p → ⇑f x ∈ p) {μ : R} (hμp : disjoint (f.eigenspace μ) p) : module.End.eigenspace (linear_map.restrict f hfp) μ = ⊥
{R : Type u} {σ : Type v} [comm_ring R] [fintype σ] [is_noetherian_ring R] : is_noetherian_ring (mv_polynomial σ R)
{I : Type w₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {D : I → Type u₁} [Π (i : I), category_theory.category (D i)] {F G : Π (i : I), C i ⥤ D i} (α : Π (i : I), F i ⟶ G i) : category_theory.sigma.functor.sigma F ⟶ category_theory.sigma.functor.sigma G
{α : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] [normed_group F] {𝕜 : Type u_5} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 F] (L : E →L[𝕜] F) (f : ↥(measure_theory.Lp E p μ)) : ↥(measure_theory.Lp F p μ)
{R : Type u} [comm_ring R] (I : ideal R) : polynomial (R ⧸ I) ≃+* polynomial R ⧸ ideal.map polynomial.C I
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] {E' : Type u_7} [normed_group E'] [complete_space E'] [normed_space ℝ E'] ⦃f g : α × β → E⦄ (F : E → E') (hf : measure_theory.integrable f (μ.prod ν)) (hg : measure_theory.integrable g (μ.prod ν)) : ∫ (x : α), F (∫ (y : β), f (x, y) - g (x, y) ∂ν) ∂μ = ∫ (x : α), F (∫ (y : β), f (x, y) ∂ν - ∫ (y : β), g (x, y) ∂ν) ∂μ
(h : expr) (nargs : option ℕ := option.none) (md : tactic.transparency := tactic.transparency.semireducible) : tactic congr_lemma
{α : Sort u_1} {β : Sort u_2} [sa : setoid α] [sb : setoid β] {φ : quotient sa → quotient sb → Sort u_3} (qa : quotient sa) (qb : quotient sb) (f : Π (a : α) (b : β), φ ⟦a⟧ ⟦b⟧) (c : ∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ == f a₂ b₂) : φ qa qb
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C ℤ] [category_theory.preadditive C] [∀ (n : ℤ), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T ∈ dist_triang C) : T.rotate ∈ dist_triang C
{E : Type u_3} [normed_group E] {f : ℝ → E} {a b : ℝ} {μ : measure_theory.measure ℝ} (h : interval_integrable f μ a b) : measure_theory.integrable_on f (set.interval_oc a b) μ
{ι : Type u} (s : finset ι) (f : ι → nnreal) {p q : ℝ} (hpq : p.is_conjugate_exponent q) : is_greatest ((λ (g : ι → nnreal), s.sum (λ (i : ι), f i * g i)) '' {g : ι → nnreal | s.sum (λ (i : ι), g i ^ q) ≤ 1}) (s.sum (λ (i : ι), f i ^ p) ^ (1 / p))
{α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.weakly_regular] ⦃A : set α⦄ (hA : measurable_set A) (h'A : ⇑μ A ≠ ⊤) : ⇑μ A = ⨆ (K : set α) (H : K ⊆ A) (h : is_closed K), ⇑μ K
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} (h : Π (i j : ι), c.rel j i → (C.X i ⟶ D.X j)) : C ⟶ D
{𝕜 : Type u} {A : Type v} [field 𝕜] [ring A] [algebra 𝕜 A] (a : A) (p : polynomial 𝕜) : (λ (k : 𝕜), polynomial.eval k p) '' spectrum 𝕜 a ⊆ spectrum 𝕜 (⇑(polynomial.aeval a) p)
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {μ : measure_theory.measure ℝ} {X : Type u_5} [topological_space X] [topological_space.first_countable_topology X] {F : X → ℝ → E} {x₀ : X} {bound : ℝ → ℝ} {a b : ℝ} {s : set X} (hF_meas : ∀ᶠ (x : X) in nhds_within x₀ s, measure_theory.ae_strongly_measurable (F x) (μ.restrict (set.interval_oc a b))) (h_bound : ∀ᶠ (x : X) in nhds_within x₀ s, ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → ∥F x t∥ ≤ bound t) (bound_integrable : interval_integrable bound μ a b) (h_cont : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → continuous_within_at (λ (x : X), F x t) s x₀) : continuous_within_at (λ (x : X), ∫ (t : ℝ) in a..b, F x t ∂μ) s x₀
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) {t : set M} (ht : t ∈ nhds x) : ⇑((ext_chart_at I x).symm) ⁻¹' t ∈ nhds (⇑(ext_chart_at I x) x)
{𝕜 : Type u_1} {_x : ring 𝕜} {E : Type u_2} [semi_normed_group E] {_x_1 : module 𝕜 E} {s : submodule 𝕜 E} (x : ↥s) : ∥x∥ = ∥↑x∥
{X : Type u_1} [pseudo_metric_space X] [proper_space X] {s : set X} (hs : metric.bounded s) {x : ℕ → X} (hx : ∃ᶠ (n : ℕ) in filter.at_top, x n ∈ s) : ∃ (a : X) (H : a ∈ closure s) (φ : ℕ → ℕ), strict_mono φ ∧ filter.tendsto (x ∘ φ) filter.at_top (nhds a)
{ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {l l' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {u v : ι → ℝ} [l'.is_measurably_generated] [filter.tendsto_Ixx_class set.Ioc l l'] (hfm : strongly_measurable_at_filter f l' μ) (hf : filter.tendsto f (l' ⊓ μ.ae) (nhds c)) (hl : μ.finite_at_filter l') (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) (huv : u ≤ᶠ[lt] v) : (λ (t : ι), ∫ (x : ℝ) in u t..v t, f x ∂μ - (⇑μ (set.Ioc (u t) (v t))).to_real • c) =o[lt] λ (t : ι), (⇑μ (set.Ioc (u t) (v t))).to_real
{R : Type u} {S : Type v} [ring R] [ring S] (I : ideal R) (f : R ≃+* S) : ideal.comap ↑f (ideal.comap ↑(f.symm) I) = I
{α : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space α} (p : ennreal) (μ : measure_theory.measure α) [normed_group E] [normed_group F] {𝕜 : Type u_5} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 F] (L : E →L[𝕜] F) : ↥(measure_theory.Lp E p μ) →ₗ[𝕜] ↥(measure_theory.Lp F p μ)
{α : Type u_1} {E : Type u_3} {F'' : Type u_10} [has_norm E] [normed_group F''] {f : α → E} {g'' : α → F''} (h : f =O[filter.cofinite] g'') : ∃ (C : ℝ) (H : C > 0), ∀ ⦃x : α⦄, g'' x ≠ 0 → ∥f x∥ ≤ C * ∥g'' x∥
{R : Type u_1} [normed_ring R] [complete_space R] (x : Rˣ) : (λ (t : R), ring.inverse (↑x + t) - ↑x⁻¹ + ↑x⁻¹ * t * ↑x⁻¹) =O[nhds 0] λ (t : R), ∥t∥ ^ 2
{R : Type u_1} {M : Type u_2} [comm_semiring R] [monoid M] (f : monoid_algebra R M) : f ∈ algebra.adjoin R (⇑(monoid_algebra.of R M) '' ↑(f.support))
(R : Type u_1) {V : Type u_2} {W : Type u_3} (P : Type u_4) {Q : Type u_5} [ring R] [add_comm_group V] [module R V] [topological_space P] [add_torsor V P] [add_comm_group W] [module R W] [topological_space Q] [add_torsor W Q] (q : Q) : P →A[R] Q
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} (h : box_integral.integrable I l f vol) : filter.tendsto (λ (π : box_integral.tagged_prepartition I × box_integral.tagged_prepartition I), (box_integral.integral_sum f vol π.fst, box_integral.integral_sum f vol π.snd)) ((l.to_filter I).prod (l.to_filter I) ⊓ filter.principal {π : box_integral.tagged_prepartition I × box_integral.tagged_prepartition I | π.fst.Union = π.snd.Union}) (uniformity F)
{R : Type u_1} [comm_semiring R] (n : ℕ) (φ : power_series R) : polynomial R
{L : first_order.language} {α : Type u'} {n : ℕ} (φ : L.bounded_formula α (n + 1)) : L.bounded_formula α n
{G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G → E'} [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ E'] [inner_product_space ℝ G] [complete_space E'] {φ : cont_diff_bump_of_inner 0} [borel_space G] [measure_theory.is_locally_finite_measure μ] [μ.is_open_pos_measure] [finite_dimensional ℝ G] [μ.is_add_left_invariant] {x₀ : G} {ε : ℝ} (hmg : measure_theory.ae_strongly_measurable g μ) (hg : ∀ (x : G), x ∈ metric.ball x₀ φ.R → has_dist.dist (g x) (g x₀) ≤ ε) : has_dist.dist (convolution (φ.normed μ) g (continuous_linear_map.lsmul ℝ ℝ) μ x₀) (g x₀) ≤ ε
{R : Type u} (σ : Type u_1) [comm_semiring R] {A₁ : Type u_2} {A₂ : Type u_3} [comm_semiring A₁] [comm_semiring A₂] [algebra R A₁] [algebra R A₂] (e : A₁ ≃ₐ[R] A₂) : mv_polynomial σ A₁ ≃ₐ[R] mv_polynomial σ A₂
{R : Type u_2} [semiring R] {σ : Type u_1} [fintype σ] : hahn_series (σ →₀ ℕ) R ≃+* mv_power_series σ R
{α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (has_Sup.Sup s)) (Mf : monotone f) (fbot : f ⊥ = ⊥) : f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
{L : first_order.language} {M : Type u_3} {N : Type u_4} [L.Structure M] [L.Structure N] (f : L.embedding M N) (htv : ∀ (n : ℕ) (φ : L.bounded_formula empty (n + 1)) (x : fin n → M) (a : N), φ.realize inhabited.default (fin.snoc (⇑f ∘ x) a) → (∃ (b : M), φ.realize inhabited.default (fin.snoc (⇑f ∘ x) (⇑f b)))) {n : ℕ} (φ : L.formula (fin n)) (x : fin n → M) : φ.realize (⇑f ∘ x) ↔ φ.realize x
{E : Type u_1} [normed_group E] [normed_space ℂ E] {R₁ R₂ : ℝ} {f : ℂ → E} {c z : ℂ} (hd : differentiable_on ℂ f (metric.ball c R₁)) (h_maps : set.maps_to f (metric.ball c R₁) (metric.ball (f c) R₂)) (hz : z ∈ metric.ball c R₁) : ∥dslope f c z∥ ≤ R₂ / R₁
{R : Type u_1} [euclidean_domain R] {abv : absolute_value R ℤ} {ι : Type u_2} [fintype ι] {ε : ℝ} (hε : 0 < ε) {b : R} (hb : b ≠ 0) (A : ι → R) (h : abv.is_admissible) : ∃ (t : ι → fin (h.card ε)), ∀ (i₀ i₁ : ι), t i₀ = t i₁ → ↑(⇑abv (A i₁ % b - A i₀ % b)) < ⇑abv b • ε
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] (U : set (L ≃ₐ[K] L)) : U ∈ gal_basis K L ↔ U ∈ subgroup.carrier '' fixed_by_finite K L
{C : Type u₁} [category_theory.category C] {W X Y Z : C} (f : W ⟶ X) (g : Y ⟶ Z) (h : W = Y) (h' : X = Z) : f = category_theory.eq_to_hom h ≫ g ≫ category_theory.eq_to_hom _ ↔ f == g
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {s : finset ι} {σ : equiv.perm ι} {f g : ι → α} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f (⇑σ i) * g i) = s.sum (λ (i : ι), f i * g i) ↔ monovary_on (f ∘ ⇑σ) g ↑s
(α : Type u_1) {β : Type u_2} [measurable_space α] {μ : measure_theory.measure α} [topological_space β] (b : β) : α →ₘ[μ] β
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : α → ennreal} (hf : ae_measurable f μ) {g : α → ennreal} (hg : ae_measurable g (μ.with_density f)) : ∫⁻ (a : α), g a ∂μ.with_density f = ∫⁻ (a : α), (f * g) a ∂μ
{k : Type u₁} {G : Type u₂} [semiring k] [add_zero_class G] (f : add_monoid_algebra k G) : f ∈ submodule.span k (⇑(add_monoid_algebra.of k G) '' ↑(f.support))
{k : Type u₁} {G : Type u₂} [monoid G] [comm_semiring k] {V W : Type u₃} [add_comm_monoid V] [module k V] [module (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] [add_comm_monoid W] [module k W] [module (monoid_algebra k G) W] [is_scalar_tower k (monoid_algebra k G) W] (f : V →ₗ[k] W) (h : ∀ (g : G) (v : V), ⇑f (finsupp.single g 1 • v) = finsupp.single g 1 • ⇑f v) : V →ₗ[monoid_algebra k G] W
{R : Type u} [comm_ring R] (I J : ideal R) : (R ⧸ I) ⧸ ideal.map (ideal.quotient.mk I) J ≃+* (R ⧸ J) ⧸ ideal.map (ideal.quotient.mk J) I
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] (f g : E →SL[σ₁₂] F) : ∥f + g∥ ≤ ∥f∥ + ∥g∥
{R : Type u} {σ : Type u_1} [comm_semiring R] (p : mv_polynomial σ R) : multiset σ
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] ⦃f : α × β → E⦄ (hf : measure_theory.ae_strongly_measurable f (μ.prod ν)) : measure_theory.ae_strongly_measurable (λ (x : α), ∫ (y : β), f (x, y) ∂ν) μ
(n : ℕ) {ε : ℝ} (hε : 0 < ε) {b : ℤ} (hb : b ≠ 0) (A : fin n → ℤ) : ∃ (t : fin n → fin ⌈1 / ε⌉₊), ∀ (i₀ i₁ : fin n), t i₀ = t i₁ → ↑|A i₁ % b - A i₀ % b| < |b| • ε
{E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] {f : E →L[ℝ] E} (hf : ⇑linear_map.det ↑f ≠ 0) (s : set E) : ⇑μ (⇑f ⁻¹' s) = ennreal.of_real |(⇑linear_map.det ↑f)⁻¹| * ⇑μ s
(c : interactive.parse (optional (lean.parser.tk "!"))) (cfg : tactic.tauto_cfg := {classical := bool.ff, closer := has_pure.pure ()}) : tactic unit
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] [normed_group F] [normed_space 𝕜 F] (p : formal_multilinear_series 𝕜 E F) {r : nnreal} (h₀ : r ≠ 0) {a : ℝ} (ha : a ∈ set.Ioo (-1) 1) (hp : (λ (n : ℕ), ∥p n∥ * ↑r ^ n) =O[filter.at_top] has_pow.pow a) : ↑r < p.radius
{R : Type u_1} [comm_ring R] (p : ℕ) [char_p R p] (I : ideal R) (h : ∀ (x : ℕ), ↑x ∈ I → ↑x = 0) : char_p (R ⧸ I) p
{α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {m m0 : measurable_space α} {μ : measure_theory.measure α} {f : α → F'} {s : set α} (hm : m ≤ m0) (hs : measurable_set s) (hf : f =ᵐ[μ.restrict sᶜ] 0) : measure_theory.condexp m μ (s.indicator f) =ᵐ[μ] s.indicator (measure_theory.condexp m μ f)
{α : Type u_1} {C : multiset α → Sort u_4} (m : multiset α) (C_0 : C 0) (C_cons : Π (a : α) (m : multiset α), C m → C (a ::ₘ m)) (C_cons_heq : ∀ (a a' : α) (m : multiset α) (b : C m), C_cons a (a' ::ₘ m) (C_cons a' m b) == C_cons a' (a ::ₘ m) (C_cons a m b)) : C m
{α : Type} [monoid α] [add_monoid α] (d j : ℕ) : holor α [d]
{M : Type u_1} [has_add M] (c : add_con M) [d : Π (a b : M), decidable (⇑c a b)] : decidable_eq c.quotient
(c : name) (cfg : tactic.apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}) : tactic unit
{α : Type u_1} [fintype α] [decidable_eq α] (σ : equiv.perm α) : Prop
{E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (f : E ≃ₗ[ℝ] E) (s : set E) : ⇑μ (⇑f ⁻¹' s) = ennreal.of_real |⇑linear_map.det ↑(f.symm)| * ⇑μ s
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) {s : set α} [measure_theory.is_finite_measure μ] (hcs : ⇑μ s ≠ 0) : measure_theory.is_probability_measure (probability_theory.cond μ s)
{V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] (f : normed_group_hom V₁ V₂) {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ (x : V₁), ∥⇑f x∥ ≤ M * ∥x∥) : ∥f∥ ≤ M
{α : Type u} (s : set α) : (λ (x : α), x) '' s = s
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s t : set α} (hs : measurable_set s) : ⇑(μ.restrict s) t = ⇑μ (t ∩ s)
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : α → E} {g' : α → F'} {l : filter α} : f =O[l] g' ↔ ∀ᶠ (c : ℝ) in filter.at_top, ∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g' x∥
{α : Type u_1} {E : Type u_4} {𝕜 : Type u_6} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} [normed_field 𝕜] [normed_space 𝕜 E] : module 𝕜 ↥(measure_theory.Lp.simple_func E p μ)
{ι : Type u_1} {X : Type u_2} [emetric_space X] {μ : measure_theory.outer_measure X} (hm : μ.is_metric) {I : finset ι} {s : ι → set X} (hI : ∀ (i : ι), i ∈ I → ∀ (j : ι), j ∈ I → i ≠ j → is_metric_separated (s i) (s j)) : ⇑μ (⋃ (i : ι) (H : i ∈ I), s i) = I.sum (λ (i : ι), ⇑μ (s i))
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) (h : W ⟶ X) (k : W ⟶ Y) (H₁ : category_theory.limits.is_initial W) (H₂ : category_theory.limits.is_colimit (category_theory.limits.binary_cofan.mk f g)) : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk f g _)
(k : ℕ) {r : ℝ} (hr : |r| < 1) : filter.tendsto (λ (n : ℕ), ↑n ^ k * r ^ n) filter.at_top (nhds 0)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} : ∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * ⇑is_R_or_C.re (has_inner.inner x y) + ∥y∥ ^ 2
{F : Type u_3} [inner_product_space ℝ F] (x y : F) : has_inner.inner x y / (∥x∥ * ∥y∥) = 1 ↔ x ≠ 0 ∧ ∃ (r : ℝ), 0 < r ∧ y = r • x
{C : Type u} [category_theory.category C] {W X Y Z : C} [category_theory.limits.has_binary_product W X] [category_theory.limits.has_binary_product Y Z] (f : W ⟶ Y) (g : X ⟶ Z) : W ⨯ X ⟶ Y ⨯ Z
{I : Type u} (f : I → Type v) [Π (i : I), has_add (f i)] (i : I) : add_hom (Π (i : I), f i) (f i)
{E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {s : set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (hs : measurable_set s) (hf' : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) (h'f : measurable f) : measure_theory.measure.map f ((μ.restrict s).with_density (λ (x : E), ennreal.of_real |(f' x).det|)) = μ.restrict (f '' s)
{ι : Type v} [dec_ι : decidable_eq ι] [preorder ι] (G : ι → Type w) [Π (i : ι), add_comm_group (G i)] (f : Π (i j : ι), i ≤ j → G i →+ G j) (i : ι) : G i →ₗ[ℤ] add_comm_group.direct_limit G f
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : M → M') (s : set M) (x : M) : Prop
{M : Type u_1} [has_mul M] (S : set (con M)) : (has_Inf.Inf S).to_setoid = has_Inf.Inf (con.to_setoid '' S)
{α : Type u_1} [normed_ring α] [complete_space α] {f g : ℕ → α} (hf : summable (λ (x : ℕ), ∥f x∥)) (hg : summable (λ (x : ℕ), ∥g x∥)) : (∑' (n : ℕ), f n) * ∑' (n : ℕ), g n = ∑' (n : ℕ), (finset.range (n + 1)).sum (λ (k : ℕ), f k * g (n - k))
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] {σ : Type u_3} [inhabited σ] (M : Λ → turing.TM1.stmt Γ Λ σ) [fintype Γ] (S : finset Λ) : finset turing.TM1to1.Λ'
(p : ℕ) (f : Π ⦃R : Type u_3⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R) : Prop
(args : interactive.parse interactive.types.opt_pexpr_list) (attrs : interactive.parse interactive.types.with_ident_list) (n : ℕ := 50) (opt : tactic.apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}) : tactic unit
{E : Type u_1} [normed_group E] [normed_space ℝ E] [complete_space E] {v : ℝ → E → E} {t_min t₀ t_max : ℝ} (ht₀ : t₀ ∈ set.Icc t_min t_max) (x₀ : E) {C R : ℝ} (hR : 0 ≤ R) {L : nnreal} (Hlip : ∀ (t : ℝ), t ∈ set.Icc t_min t_max → lipschitz_on_with L (v t) (metric.closed_ball x₀ R)) (Hcont : ∀ (x : E), x ∈ metric.closed_ball x₀ R → continuous_on (λ (t : ℝ), v t x) (set.Icc t_min t_max)) (Hnorm : ∀ (t : ℝ), t ∈ set.Icc t_min t_max → ∀ (x : E), x ∈ metric.closed_ball x₀ R → ∥v t x∥ ≤ C) (Hmul_le : C * linear_order.max (t_max - t₀) (t₀ - t_min) ≤ R) : ∃ (f : ℝ → E), f t₀ = x₀ ∧ ∀ (t : ℝ), t ∈ set.Icc t_min t_max → has_deriv_within_at f (v t (f t)) (set.Icc t_min t_max) t
{R : Type u_5} [comm_ring R] [is_domain R] {ζ : R} {n : ℕ} (h : is_primitive_root ζ n) : ⇑multiset.card (polynomial.nth_roots n 1) = n
{V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (hp1p2 : p1 ≠ p2) (hp3p2 : p3 ≠ p2) : has_dist.dist p1 p3 = |has_dist.dist p1 p2 - has_dist.dist p3 p2| ↔ euclidean_geometry.angle p1 p2 p3 = 0
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] (M : turing.TM0.machine Γ Λ) (S : set Λ) : Prop
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i • g i) ≤ finset.univ.sum (λ (i : ι), f (⇑σ i) • g i)
{α : Type u_1} {β : Type u_2} [mul_one_class α] [mul_one_class β] (f : α →* β) (I : Type u_3) : (I → α) →* I → β
{α : Sort u_1} {φ : Sort u_4} {s₁ : setoid α} (q : quotient s₁) (f : α → φ) (h : ∀ (a b : α), setoid.r a b → f a = f b) : φ
{M : Type u_1} [add_monoid M] {A : Type u_2} [add_monoid A] {f : M → A} (hf : is_add_monoid_hom f) (s : set M) : f '' add_monoid.closure s = add_monoid.closure (f '' s)
{C : snum → Sort u_1} (z : Π (b : bool), C (snum.zero b)) (s : Π (b : bool) (p : snum), C p → C (b::p)) (p : nzsnum) : C ↑p
(α : Type u) (β : Type v) [group α] [mul_action α β] [fintype α] [fintype β] [fintype (quotient (mul_action.orbit_rel α β))] [Π (b : β), fintype ↥(mul_action.stabilizer α b)] : fintype.card β = finset.univ.sum (λ (ω : quotient (mul_action.orbit_rel α β)), fintype.card α / fintype.card ↥(mul_action.stabilizer α ω.out'))
{α : Type u_1} {m : measurable_space α} (s : measure_theory.signed_measure α) (i : set α) (hi₁ : measurable_set i) (hi₂ : measure_theory.vector_measure.restrict s i ≤ 0.restrict i) : measure_theory.measure α
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} (hl : l ≤ box_integral.integration_params.Henstock) (B : box_integral.box_additive_map ι ℝ ↑I) (hB0 : ∀ (J : box_integral.box ι), 0 ≤ ⇑B J) (g : box_integral.box_additive_map ι F ↑I) (s : set (ι → ℝ)) (hs : s.countable) (H₁ : ∀ (c : nnreal) (x : ι → ℝ), x ∈ ⇑box_integral.box.Icc I ∩ s → ∀ (ε : ℝ), ε > 0 → (∃ (δ : ℝ) (H : δ > 0), ∀ (J : box_integral.box ι), J ≤ I → ⇑box_integral.box.Icc J ⊆ metric.closed_ball x δ → x ∈ ⇑box_integral.box.Icc J → (↥(l.bDistortion) → J.distortion ≤ c) → has_dist.dist (⇑(⇑vol J) (f x)) (⇑g J) ≤ ε)) (H₂ : ∀ (c : nnreal) (x : ι → ℝ), x ∈ ⇑box_integral.box.Icc I  s → ∀ (ε : ℝ), ε > 0 → (∃ (δ : ℝ) (H : δ > 0), ∀ (J : box_integral.box ι), J ≤ I → ⇑box_integral.box.Icc J ⊆ metric.closed_ball x δ → x ∈ ⇑box_integral.box.Icc J → (↥(l.bDistortion) → J.distortion ≤ c) → has_dist.dist (⇑(⇑vol J) (f x)) (⇑g J) ≤ ε * ⇑B J)) : box_integral.has_integral I l f vol (⇑g I)
(s : ℝ) (hs : 1 < s) : measure_theory.integrable_on (λ (x : ℝ), ∥real.exp (-x) * real.log x * x ^ (s - 1)∥) (set.Ioi 0) measure_theory.measure_space.volume
{M : Type u_1} {σ : Type u_4} [has_add M] {N : Type u_2} [has_add N] [set_like σ M] [add_mem_class σ M] (f : add_hom M N) (S : σ) : add_hom ↥S N
(e : expr) (cfg : tactic.equiv_rw_cfg := {max_depth := 10}) : tactic unit
{C : Type u₁} [category_theory.category C] (D : category_theory.glue_data C) [category_theory.limits.has_multicoequalizer D.diagram] (F : C ⥤ Type v) [category_theory.limits.preserves_colimit D.diagram.multispan F] [Π (i j k : D.J), category_theory.limits.preserves_limit (category_theory.limits.cospan (D.f i j) (D.f i k)) F] (x : F.obj D.glued) : ∃ (i : D.J) (y : F.obj (D.U i)), F.map (D.ι i) y = x
{ι : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f : ℝ → E} {c : E} {l l' : filter ℝ} {lt : filter ι} {μ : measure_theory.measure ℝ} {u v : ι → ℝ} [l'.is_measurably_generated] [filter.tendsto_Ixx_class set.Ioc l l'] (hfm : strongly_measurable_at_filter f l' μ) (hf : filter.tendsto f (l' ⊓ μ.ae) (nhds c)) (hl : μ.finite_at_filter l') (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : (λ (t : ι), ∫ (x : ℝ) in u t..v t, f x ∂μ - ∫ (x : ℝ) in u t..v t, c ∂μ) =o[lt] λ (t : ι), ∫ (x : ℝ) in u t..v t, 1 ∂μ
{𝕜 : Type u_1} [normed_field 𝕜] [complete_space 𝕜] {r : 𝕜} (hr : ∥r∥ < 1) : ∑' (n : ℕ), ↑n * r ^ n = r / (1 - r) ^ 2
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {c : ℝ} {g : α → F} {f' : α → E'} {l : filter α} : asymptotics.is_O_with c l f' g → asymptotics.is_O_with c l (λ (x : α), ∥f' x∥) g
(𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_3} [linear_order ι] [order_bot ι] [locally_finite_order ι] [is_well_order ι has_lt.lt] [succ_order ι] [is_succ_archimedean ι] (f : ι → E) (c : ι) : submodule.span 𝕜 (gram_schmidt 𝕜 f '' set.Iio c) = submodule.span 𝕜 (f '' set.Iio c)
{C : Type u} [category_theory.category C] {X : C} {J : category_theory.grothendieck_topology C} {S : J.cover X} (I : S.relation) : S.arrow
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {β γ : Type v} [fintype β] [decidable_eq β] [decidable_eq γ] (ε : β ≃ γ) (f : γ → C) [category_theory.limits.has_biproduct f] [category_theory.limits.has_biproduct (f ∘ ⇑ε)] : ⨁ f ∘ ⇑ε ≅ ⨁ f
⦃J : Type u⦄ (F : J → category_theory.Groupoid) : category_theory.limits.is_limit (category_theory.Groupoid.pi_limit_fan F)
{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) {R₂ : Type u_3} {M₂ : Type u_4} [ring R₂] [add_comm_group M₂] [module R₂ M₂] {τ₁₂ : R →+* R₂} {R₃ : Type u_5} {M₃ : Type u_6} [ring R₃] [add_comm_group M₃] [module R₃ M₃] (p₂ : submodule R₂ M₂) (p₃ : submodule R₃ M₃) {τ₂₃ : R₂ →+* R₃} {τ₁₃ : R →+* R₃} [ring_hom_comp_triple τ₁₂ τ₂₃ τ₁₃] (f : M →ₛₗ[τ₁₂] M₂) (g : M₂ →ₛₗ[τ₂₃] M₃) (hf : p ≤ submodule.comap f p₂) (hg : p₂ ≤ submodule.comap g p₃) (h : p ≤ submodule.comap f (submodule.comap g p₃) := _) : p.mapq p₃ (g.comp f) h = (p₂.mapq p₃ g hg).comp (p.mapq p₂ f hf)
{M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {p : add_localization S → Sort u} (f : Π (a : M) (b : ↥S), p (add_localization.mk a b)) (H : ∀ {a c : M} {b d : ↥S} (h : ⇑(add_localization.r S) (a, b) (c, d)), eq.rec (f a b) _ = f c d) (x : add_localization S) : p x
{α : Type u_1} [measurable_space α] (μ : measure_theory.measure α) (s : set α) : set α
(rev : interactive.parse (optional (lean.parser.tk "!"))) (h : interactive.parse (optional interactive.types.ident_)) (_x : interactive.parse (lean.parser.tk ":")) (arg : interactive.parse h_generalize_arg_p) (eqs_h : interactive.parse (lean.parser.tk "with" *> has_pure.purehas_pure.purefunctor.map <$> interactive.types.ident_interactive.types.ident_ <|> has_pure.pure list.nil)) : tactic unit
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s t : α → Prop} (hst : s =ᵐ[μ] t) {p : α → Prop} : (∀ᵐ (x : α) ∂μ.restrict s, p x) ↔ ∀ᵐ (x : α) ∂μ.restrict t, p x
(md : tactic.transparency := tactic.transparency.semireducible) : tactic unit
{V : Type u_1} [inner_product_space ℝ V] {x y : V} (h : inner_product_geometry.angle x y = real.pi) : ∥x - y∥ = ∥x∥ + ∥y∥
{α : Sort u} {β : Sort v} {W : α → Sort w} {Z : β → Sort z} (h₁ : α ≃ β) (h₂ : Π (b : β), W (⇑(h₁.symm) b) ≃ Z b) : (Π (a : α), W a) ≃ Π (b : β), Z b
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {X : C} {S : J.cover X} {T : Π (I : S.arrow), J.cover I.Y} (I : (S.bind T).arrow) : I.Y ⟶ I.middle
(M : Type u_1) (N : Type u_2) (μ : M → N → N) (r : N → N → Prop) : Prop
{V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] (f : normed_group_hom V₁ V₂) : lipschitz_with ⟨∥f∥, _⟩ ⇑f
{α : Type u} [linear_ordered_add_comm_group α] {a b x : α} (h : x ∈ set.interval a b) : |b - x| ≤ |b - a|
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f (⇑σ i) • g i) = s.sum (λ (i : ι), f i • g i) ↔ antivary_on (f ∘ ⇑σ) g ↑s
(R : Type u_1) [semiring R] {ι : Type u_4} (φ : ι → Type u_5) [Π (i : ι), topological_space (φ i)] [Π (i : ι), add_comm_monoid (φ i)] [Π (i : ι), module R (φ i)] {I J : set ι} [decidable_pred (λ (i : ι), i ∈ I)] (hd : disjoint I J) (hu : set.univ ⊆ I ∪ J) : (↥⨅ (i : ι) (H : i ∈ J), (continuous_linear_map.proj i).ker) ≃L[R] Π (i : ↥I), φ ↑i
{N : Type u_1} {G : Type u_2} {H : Type u_3} [group N] [group G] [group H] {φ : G →* mul_aut N} {f g : N ⋊[φ] G →* H} (hl : f.comp semidirect_product.inl = g.comp semidirect_product.inl) (hr : f.comp semidirect_product.inr = g.comp semidirect_product.inr) : f = g
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {G : Type u_4} [topological_space G] [charted_space H G] [monoid G] [has_smooth_mul I G] (g : G) : left_invariant_derivation I G →ₗ[𝕜] point_derivation I g
{ι : Type u_1} {I : box_integral.box ι} [fintype ι] (π : box_integral.prepartition I) : box_integral.prepartition I
{α : Type u_1} {G : Type u_8} [normed_group G] {m m0 : measurable_space α} {μ : measure_theory.measure α} {s : set α} [normed_space ℝ G] (hm : m ≤ m0) [measure_theory.sigma_finite (μ.trim hm)] (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) (x : G) : ↥(measure_theory.Lp G 1 μ)
{α : Type u_2} [measurable_space α] (f : α → α) (μ : measure_theory.measure α . "volume_tac") : Prop
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} (hom : Π (i j : ι), C.X i ⟶ D.X j) (zero' : ∀ (i j : ι), ¬c.rel j i → hom i j = 0) : homotopy (homotopy.null_homotopic_map hom) 0
{α : Type u_1} {m : measurable_space α} {μ ν : measure_theory.measure α} {f g : measure_theory.simple_func α ennreal} (hfg : f ≤ g) (hμν : μ ≤ ν) : f.lintegral μ ≤ g.lintegral ν
{ι : Type u_2} {π : ι → Type u_1} [fintype ι] [Π (i : ι), semi_normed_group (π i)] (x : Π (i : ι), π i) : finset.univ.sum (λ (i : ι), ∥x i∥) ≤ fintype.card ι • ∥x∥
{α : Type u_1} {C : multiset α → Sort u_4} (C_0 : C 0) (C_cons : Π (a : α) (m : multiset α), C m → C (a ::ₘ m)) (C_cons_heq : ∀ (a a' : α) (m : multiset α) (b : C m), C_cons a (a' ::ₘ m) (C_cons a' m b) == C_cons a' (a ::ₘ m) (C_cons a m b)) (m : multiset α) : C m
{α : Type u_1} {ι : Type u_2} {E : Type u_3} [measurable_space α] {μ : measure_theory.measure α} {l : filter ι} [normed_group E] [normed_space ℝ E] [complete_space E] [l.ne_bot] [l.is_countably_generated] {φ : ι → set α} (hφ : measure_theory.ae_cover μ l φ) {f : α → E} (I : E) (hfi : measure_theory.integrable f μ) (h : filter.tendsto (λ (n : ι), ∫ (x : α) in φ n, f x ∂μ) l (nhds I)) : ∫ (x : α), f x ∂μ = I
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {F : Type u_5} [normed_group F] [normed_space 𝕜 F] (Z : basic_smooth_vector_bundle_core I M F) : topological_vector_bundle_core 𝕜 M F ↥(charted_space.atlas H M)
{ι : Type u_1} {π : ι → Type u_2} [Π (i : ι), topological_space (π i)] {s : Π (i : ι), set (π i)} (h : ∀ (i : ι), is_compact (s i)) : is_compact (set.univ.pi s)
{E : Type u_1} [semi_normed_group E] {s : add_subgroup E} (x : ↥s) : ∥x∥ = ∥↑x∥
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G ↪g G') : ↥(G.edge_set) ↪ ↥(G'.edge_set)
{E : Type u_1} [semi_normed_group E] [normed_space ℝ E] (p : subspace ℝ E) (f : ↥p →L[ℝ] ℝ) : ∃ (g : E →L[ℝ] ℝ), (∀ (x : ↥p), ⇑g ↑x = ⇑f x) ∧ ∥g∥ = ∥f∥
{R : Type u} {S₁ : Type v} {σ : Type u_1} [comm_semiring R] [comm_semiring S₁] (f : R →+* S₁) (g : σ → S₁) : mv_polynomial σ R →+* S₁
(α : Type u_1) (E : Type u_4) (𝕜 : Type u_6) [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} [fact (1 ≤ p)] [normed_field 𝕜] [normed_space 𝕜 E] : ↥(measure_theory.Lp.simple_func E p μ) →L[𝕜] ↥(measure_theory.Lp E p μ)
{V₁ : Type u_1} {V₂ : Type u_2} [normed_group V₁] [normed_group V₂] {f : normed_group_hom V₁ V₂} : ∥f∥ = 0 ↔ f = 0
{t : ℂ} {s1 s2 x : ℝ} (ht1 : s1 ≤ t.re) (ht2 : t.re ≤ s2) (hx : 0 < x) : ∥dGamma_integrand t x∥ ≤ dGamma_integrand_real s1 x + dGamma_integrand_real s2 x
{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] {μ : measure_theory.measure G} [measure_theory.sigma_finite μ] [μ.is_mul_left_invariant] {K : set G} (hK : is_compact K) (h2K : (interior K).nonempty) (hμK : ⇑μ K ≠ ⊤) : μ.regular
{ι : Type u_1} [fintype ι] {I : box_integral.box ι} (π₁ : box_integral.tagged_prepartition I) (π₂ : box_integral.prepartition I) (hU : π₂.Union = ↑I  π₁.Union) (r : (ι → ℝ) → ↥(set.Ioi 0)) : box_integral.tagged_prepartition I
(limit : option ℕ := option.none) (opt : tactic.suggest.suggest_opt := {to_opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := λ (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (λ (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}, compulsory_hyps := list.nil expr, try_this := bool.tt}) : tactic (list tactic.suggest.application)
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [nonempty J] {s : category_theory.limits.trident f} (hs : category_theory.limits.is_limit s) {W : C} (k : W ⟶ X) (h : ∀ (j₁ j₂ : J), k ≫ f j₁ = k ≫ f j₂) : {l // l ≫ s.ι = k}
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] (f : E →L[𝕜] F) [complete_space F] [complete_space E] (surj : function.surjective ⇑f) : ∃ (C : ℝ) (H : C > 0), ∀ (y : F), ∃ (x : E), ⇑f x = y ∧ ∥x∥ ≤ C * ∥y∥
{G : Type u_1} {α : Type u_2} [add_group G] [add_action G α] [measurable_space α] {s t : set α} {μ : measure_theory.measure α} [measurable_space G] [has_measurable_vadd G α] [measure_theory.vadd_invariant_measure G α μ] [encodable G] (hs : measure_theory.is_add_fundamental_domain G s μ) (ht : measure_theory.is_add_fundamental_domain G t μ) : ⇑μ s = ⇑μ t
{G : Type u} [group G] {H : Type v} [group H] (φ : G →* H) : G ⧸ φ.ker →* H
{γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {β : Type u_4} [tβ : topological_space β] [t2_space β] [measurable_space β] [borel_space β] {s : set γ} {f : γ → β} [topological_space.second_countable_topology β] (hs : measurable_set s) (f_meas : measurable f) (f_inj : set.inj_on f s) : measurable_set (f '' s)
{α : Type u_1} [decidable_eq α] {s : finset α} {p : Π (t : finset α), t ⊂ s → Prop} [Π (t : finset α) (h : t ⊂ s), decidable (p t h)] : decidable (∃ (t : finset α) (h : t ⊂ s), p t h)
{V : Type u_1} {W : Type u_2} {V₁ : Type u_3} [semi_normed_group V] [semi_normed_group W] [semi_normed_group V₁] {f g : normed_group_hom V W} (φ : normed_group_hom V₁ V) (h : f.comp φ = g.comp φ) : normed_group_hom V₁ ↥(f.equalizer g)
{E : Type u_1} [inner_product_space ℝ E] {v : E} [complete_space E] (hv : ∥v∥ = 1) : local_homeomorph ↥(metric.sphere 0 1) ↥(submodule.span ℝ {v})ᗮ
{n : ℕ} {a : fin (n + 2)} {b : fin (n + 1)} (ha : a ≠ 0) (hb : b ≠ 0) (hk : ⇑(a.succ_above) b ≠ 0 := _) : ⇑((a.pred ha).succ_above) (b.pred hb) = (⇑(a.succ_above) b).pred hk
{ι : Type u} {E : Type v} [normed_group E] [normed_space ℝ E] [fintype ι] (l : box_integral.integration_params) [complete_space E] {I : box_integral.box ι} {f : (ι → ℝ) → E} (hc : continuous_on f (⇑box_integral.box.Icc I)) (μ : measure_theory.measure (ι → ℝ)) [measure_theory.is_locally_finite_measure μ] : box_integral.integrable I l f μ.to_box_additive.to_smul
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} (h : Π (i j : ι), c.rel j i → (C.X i ⟶ D.X j)) : homotopy (homotopy.null_homotopic_map' h) 0
{G : Type u_1} [measurable_space G] [has_add G] [has_measurable_add G] (μ : measure_theory.measure G) : (∀ (g : G) (A : set G), measurable_set A → ⇑μ ((λ (h : G), h + g) ⁻¹' A) = ⇑μ A) ↔ μ.is_add_right_invariant
{E : Type u_1} [normed_group E] [normed_space ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hd : diff_cont_on_cl ℂ f {z : ℂ | 0 < z.re}) (hexp : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[filter.comap complex.abs filter.at_top ⊓ filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), real.exp (B * complex.abs z ^ c)) (hre : filter.tendsto (λ (x : ℝ), f ↑x) filter.at_top (nhds 0)) (him : ∀ (x : ℝ), ∥f (↑x * complex.I)∥ ≤ C) (hz : 0 ≤ z.re) : ∥f z∥ ≤ C
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {n : with_top ℕ} (h : ∀ (x : M), x ∈ s → (∃ (u : set M), is_open u ∧ x ∈ u ∧ cont_mdiff_on I I' n f (s ∩ u))) : cont_mdiff_on I I' n f s
{R : Type u} {S : Type v} {σ : Type u_1} [comm_semiring R] [comm_semiring S] {f₁ f₂ : mv_polynomial σ R →+* S} {p₁ p₂ : mv_polynomial σ R} (hC : f₁.comp mv_polynomial.C = f₂.comp mv_polynomial.C) (hv : ∀ (i : σ), i ∈ p₁.vars → i ∈ p₂.vars → ⇑f₁ (mv_polynomial.X i) = ⇑f₂ (mv_polynomial.X i)) (hp : p₁ = p₂) : ⇑f₁ p₁ = ⇑f₂ p₂
{R : Type u} [semiring R] (I : ideal (polynomial R)) (n : with_bot ℕ) : submodule R (polynomial R)
{R : Type u_4} [normed_ring R] [complete_space R] (x : R) (h : ∥x∥ < 1) : summable (λ (n : ℕ), x ^ n)
{α : Type u} [pseudo_metric_space α] {s : set α} (H : ∀ (ε : ℝ), ε > 0 → (∃ (β : Type u) (_x : fintype β) (F : ↥s → β), ∀ (x y : ↥s), F x = F y → has_dist.dist ↑x ↑y < ε)) : totally_bounded s
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {ε : Type u_5} {ζ : Type u_6} (f : α → β) (f' : γ → δ) (g : β → ε) (g' : δ → ζ) : prod.map g g' ∘ prod.map f f' = prod.map (g ∘ f) (g' ∘ f')
(cfg : tactic.interactive.mono_cfg := {unify := bool.ff}) : tactic unit
(α : Type u_1) (E : Type u_2) (𝕜 : Type u_4) [normed_group E] {m : measurable_space α} (μ : measure_theory.measure α) [normed_field 𝕜] [normed_space 𝕜 E] [normed_space ℝ E] [smul_comm_class ℝ 𝕜 E] : ↥(measure_theory.Lp.simple_func E 1 μ) →L[𝕜] E
{F : Type u_1} {α : Type u_2} {β : Type u_3} [mul_one_class α] [mul_one_class β] [monoid_hom_class F α β] (φ : F) : filter α →* filter β
{τ : Type u_1} {α : Type u_2} {β : Type u_3} [topological_space β] (f : filter τ) (ϕ : τ → α → β) (s : set α) (y : β) : y ∈ omega_limit f ϕ s ↔ ∀ (n : set β), n ∈ nhds y → (∃ᶠ (t : τ) in f, (ϕ t '' s ∩ n).nonempty)
{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s t : set α} (Hf : monotone_on f t) (Hst : s ⊆ t) : (lower_bounds s ∩ t).nonempty → bdd_below (f '' s)
{E : Type u_1} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] [measurable_space E] [borel_space E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (A : E →L[ℝ] E) {m : nnreal} (hm : ennreal.of_real |A.det| < ↑m) : ∀ᶠ (δ : nnreal) in nhds_within 0 (set.Ioi 0), ∀ (s : set E) (f : E → E), approximates_linear_on f A s δ → ⇑μ (f '' s) ≤ ↑m * ⇑μ s
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} {σ : Type u_4} (S : finset Λ) : turing.TM2.stmt Γ Λ σ → Prop
{𝕜 : Type u_1} {A : Type u_2} [comm_semiring 𝕜] [topological_space 𝕜] [has_continuous_add 𝕜] [has_continuous_const_smul 𝕜 𝕜] [non_unital_non_assoc_semiring A] [topological_space A] [module 𝕜 A] (φ : ↥(weak_dual.character_space 𝕜 A)) : A →ₙₐ[𝕜] 𝕜
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (x y : M ⧸ S) : ∥x + y∥ ≤ ∥x∥ + ∥y∥
{α : Type u} [decidable_eq α] {β : α → Type v} (hash_fn : α → ℕ) (nbuckets : ℕ := 8) : hash_map α β
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {E : Type u₃} [category_theory.category E] (F : C ⥤ E) (G : D ⥤ E) [category_theory.faithful G] (obj : C → D) (h_obj : ∀ (X : C), G.obj (obj X) = F.obj X) (map : Π {X Y : C}, (X ⟶ Y) → (obj X ⟶ obj Y)) (h_map : ∀ {X Y : C} {f : X ⟶ Y}, G.map (map f) == F.map f) : C ⥤ D
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [ideal.is_jacobson R] (I : ideal R) (hI : I.is_maximal) (hy : y ∉ I) : (ideal.map (algebra_map R S) I).is_maximal
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] (I : model_with_corners 𝕜 E H) {G : Type u_5} [topological_space G] [charted_space H G] [group G] [lie_group I G] : topological_group G
 : ℕ → list name → (name := name.mk_string "_" name.anonymous) → (option ℕ := option.none) → tactic (list expr × list name)
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D E : homological_complex V c} (hom : Π (i j : ι), C.X i ⟶ D.X j) (g : D ⟶ E) : homotopy.null_homotopic_map hom ≫ g = homotopy.null_homotopic_map (λ (i j : ι), hom i j ≫ g.f j)
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [fintype J] {K : Type v} [fintype K] {f : J → C} {g : K → C} [category_theory.limits.has_finite_biproducts C] (m : Π (j : J) (k : K), f j ⟶ g k) : ⨁ f ⟶ ⨁ g
{α : Type u} [metric_space α] (H : ∀ (ε : ℝ), ε > 0 → (∃ (β : Type u_1) (_x : encodable β) (F : α → β), ∀ (x y : α), F x = F y → has_dist.dist x y ≤ ε)) : topological_space.second_countable_topology α
{k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] ⦃φ₁ φ₂ : add_monoid_algebra k G →ₐ[k] A⦄ (h : ↑φ₁.comp (add_monoid_algebra.of k G) = ↑φ₂.comp (add_monoid_algebra.of k G)) : φ₁ = φ₂
(h new_type eq_pr : expr) (tag : name := name.mk_string "star" (name.mk_string "unit" name.anonymous)) : tactic expr
{M : Type u_1} [semi_normed_group M] {S : add_subgroup M} (x : M ⧸ S) : ∥-x∥ = ∥x∥
{J : Type u₁} [category_theory.category J] [category_theory.is_preconnected J] (Z : J → Sort u_1) (h₁ : Π {j₁ j₂ : J}, (j₁ ⟶ j₂) → Z j₁ → Z j₂) (h₂ : Π {j₁ j₂ : J}, (j₁ ⟶ j₂) → Z j₂ → Z j₁) {j₀ : J} (x : Z j₀) (j : J) : nonempty (Z j)
{α : Type u_1} {β : Type u_2} [measurable_space α] (μ : measure_theory.measure α) [topological_space α] [borel_space α] [topological_space β] [second_countable_topology_either α β] [topological_space.pseudo_metrizable_space β] (f : C(α, β)) : α →ₘ[μ] β
{E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] {s : set E} (u : ℕ → E) (hu : metric.bounded (set.range u)) (hs : pairwise (disjoint on λ (n : ℕ), {u n} + s)) (h's : measurable_set s) : ⇑μ s = 0
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : is_R_or_C.abs (has_inner.inner x y) ≤ ∥x∥ * ∥y∥
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] {σ : Type u_3} [inhabited σ] {n : ℕ} (d : turing.dir) (q : turing.TM1.stmt bool turing.TM1to1.Λ' σ) : turing.TM1.stmt bool turing.TM1to1.Λ' σ
{α : Type u_1} {ι : Type u_2} (I : set ι) (m : ι → measure_theory.outer_measure α) {s : set α} (hs : s.nonempty) : (⇑⨅ (i : ι) (H : i ∈ I), m i) s = ⨅ (t : ℕ → set α) (h2 : s ⊆ set.Union t), ∑' (n : ℕ), ⨅ (i : ι) (H : i ∈ I), ⇑(m i) (t n)
{R : Type u_1} [comm_ring R] {k : ℕ} (φ : mv_polynomial (fin k × ℕ) ℤ) (x : fin k → ℕ → R) : R
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E} : ∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * ⇑is_R_or_C.re (has_inner.inner x y) + ∥y∥ ^ 2
{G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure G} {f : G → E} {g : G} [group G] [has_measurable_mul G] [μ.is_mul_left_invariant] (hf' : ∀ (x : G), f (g * x) = -f x) : ∫ (x : G), f x ∂μ = 0
{π α : Type} [decidable_eq π] (β σ : Type) (init : π → tactic σ) (update : π → σ → β → tactic (σ × option α)) (view : π → σ → tactic (list (widget.html β))) : widget.tc π α
{α : Type u_1} {m : measurable_space α} (c : measure_theory.complex_measure α) (μ : measure_theory.measure α) : measure_theory.complex_measure α
{C : Type u} [category_theory.category C] {X Y : C} (f g : X ⟶ Y) {Z : C} (π : Y ⟶ Z) : Type v
{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} (Hf : monotone f) {s : set α} : bdd_below s → bdd_below (f '' s)
{α : Type u_1} {m0 : measurable_space α} {μ : measure_theory.measure α} {s : set α} (h : measurable_set s) : (μ.restrict s).to_outer_measure = ⇑(measure_theory.outer_measure.restrict s) μ.to_outer_measure
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} (h : box_integral.integrable I l f vol) (ε : ℝ) : nnreal → (ι → ℝ) → ↥(set.Ioi 0)
{F : Type u_3} [inner_product_space ℝ F] {x y : F} : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + 2 * has_inner.inner x y + ∥y∥ * ∥y∥
{C : Type u₁} [category_theory.category C] {I T : C} (hI : category_theory.limits.is_initial I) (hT : category_theory.limits.is_terminal T) (f : category_theory.mono (hI.to T)) : category_theory.limits.initial_mono_class C
(s : simp_lemmas × list name) (ps : list pexpr) (cfg : auto.auto_config := {use_simp := bool.tt, max_ematch_rounds := 20}) : tactic unit
{α : Type u} {β : Type v} [pseudo_metric_space α] {ι : Type u_1} [topological_space β] {F : ι → β → α} {f : β → α} {p : filter ι} {s : set β} : tendsto_locally_uniformly_on F f p s ↔ ∀ (ε : ℝ), ε > 0 → ∀ (x : β), x ∈ s → (∃ (t : set β) (H : t ∈ nhds_within x s), ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → has_dist.dist (f y) (F n y) < ε)
{α : Type u_1} {E : α → Type u_2} {p : ennreal} [Π (i : α), normed_group (E i)] {ι : Type u_3} {l : filter ι} [l.ne_bot] [fact (1 ≤ p)] {C : ℝ} {F : ι → ↥(lp E p)} (hCF : ∀ᶠ (k : ι) in l, ∥F k∥ ≤ C) {f : ↥(lp E p)} (hf : filter.tendsto (id (λ (i : ι), ⇑(F i))) l (nhds ⇑f)) : ∥f∥ ≤ C
{α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {s t : set α} {Φ : α → β} (h : isometry Φ) : metric.Hausdorff_dist (Φ '' s) (Φ '' t) = metric.Hausdorff_dist s t
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [is_alg_closed K] [finite_dimensional K V] (f : module.End K V) : (⨆ (μ : K) (k : ℕ), ⇑(f.generalized_eigenspace μ) k) = ⊤
{α : Type u_1} [nonempty α] [semilattice_sup α] {β : Type u_2} [semi_normed_group β] {f : α → β} {b : β} : filter.tendsto f filter.at_top (nhds b) ↔ ∀ (ε : ℝ), 0 < ε → (∃ (N : α), ∀ (n : α), N ≤ n → ∥f n - b∥ < ε)
{G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {μ : measure_theory.measure G} [group G] [topological_group G] [μ.is_mul_left_invariant] [μ.regular] (h₀ : μ ≠ 0) : μ.is_open_pos_measure
{G : Type u_1} [measurable_space G] [has_inv G] (μ : measure_theory.measure G) : Prop
{G : Type u_1} [normed_group G] [complete_space G] {H : Type u_2} [normed_group H] {f : normed_group_hom G H} {K : add_subgroup H} {C ε : ℝ} (hC : 0 < C) (hε : 0 < ε) (hyp : f.surjective_on_with K C) : f.surjective_on_with K.topological_closure (C + ε)
(atoms : tactic.ref (buffer expr)) (red : tactic.transparency) (mode : tactic.ring.normalize_mode := tactic.ring.normalize_mode.horner) (e : expr) : tactic (expr × expr)
{G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {μ : measure_theory.measure G} {Γ : subgroup G} {𝓕 : set G} (h𝓕 : measure_theory.is_fundamental_domain ↥(Γ.opposite) 𝓕 μ) [encodable ↥Γ] [measurable_space (G ⧸ Γ)] [borel_space (G ⧸ Γ)] [t2_space (G ⧸ Γ)] [topological_space.second_countable_topology (G ⧸ Γ)] (K : topological_space.positive_compacts (G ⧸ Γ)) [Γ.normal] [μ.is_haar_measure] [μ.is_mul_right_invariant] (h𝓕_finite : ⇑μ 𝓕 < ⊤) : measure_theory.measure.map ⇑(quotient_group.mk' Γ) (μ.restrict 𝓕) = ⇑μ (𝓕 ∩ ⇑(quotient_group.mk' Γ) ⁻¹' ↑K) • measure_theory.measure.haar_measure K
{α : Type u_1} {E : Type u_3} [measurable_space α] [normed_group E] {f : α → E} {s : set α} {μ : measure_theory.measure α} [complete_space E] [normed_space ℝ E] (hs : measurable_set s) : ∫ (x : α), s.indicator f x ∂μ = ∫ (x : α) in s, f x ∂μ
{F : Type u_3} [inner_product_space ℝ F] (x y : F) : |has_inner.inner x y| ≤ ∥x∥ * ∥y∥
(f : Type u → Type v) (hf : Π (α β : Type u), α ≃ β → f α ≃ f β) : cardinal → cardinal
(P : Π {R S : Type u} [_inst_7 : comm_ring R] [_inst_8 : comm_ring S], (R →+* S) → Prop) : Prop
{C : Type u} [category_theory.category C] {W X Y Z : C} (f : X ⟶ Y) (g : X ⟶ Z) (h : W ⟶ X) [category_theory.epi h] (s : category_theory.limits.pushout_cocone f g) (H : category_theory.limits.is_colimit s) : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk s.inl s.inr _)
{elab : bool := bool.tt} : expr elab → option (macro_def × list (expr elab))
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] {G : D ⥤ C} {F_obj : C → D} (e : Π (X : C) (Y : D), (F_obj X ⟶ Y) ≃ (X ⟶ G.obj Y)) (he : ∀ (X : C) (Y Y' : D) (g : Y ⟶ Y') (h : F_obj X ⟶ Y), ⇑(e X Y') (h ≫ g) = ⇑(e X Y) h ≫ G.map g) : category_theory.adjunction.left_adjoint_of_equiv e he ⊣ G
{E : Type u} [normed_group E] [normed_space ℂ E] {F : Type v} [normed_group F] [normed_space ℂ F] {f : E → F} {s : set E} {z w : E} (hd : diff_cont_on_cl ℂ f s) (hz : is_max_on (has_norm.norm ∘ f) s z) (hsub : metric.ball z (has_dist.dist w z) ⊆ s) : ∥f w∥ = ∥f z∥
{V : Type u} [category_theory.category V] [category_theory.preadditive V] [category_theory.limits.has_zero_object V] {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] [category_theory.limits.has_zero_object W] (F : V ⥤ W) [F.additive] : chain_complex.single₀ V ⋙ F.map_homological_complex (complex_shape.down ℕ) ≅ F ⋙ chain_complex.single₀ W
{G : Type u_1} [measurable_space G] [comm_group G] {μ : measure_theory.measure G} [μ.is_mul_left_invariant] : μ.is_mul_right_invariant
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] (Z : basic_smooth_vector_bundle_core I M E') (v : E') (h : ∀ (i j : ↥(charted_space.atlas H M)) (x : M), x ∈ i.val.to_local_equiv.source ∩ j.val.to_local_equiv.source → ⇑(Z.coord_change i j (⇑(i.val) x)) v = v) : smooth I (I.prod (model_with_corners_self 𝕜 E')) (show M → Z.to_topological_vector_bundle_core.total_space, from λ (x : M), ⟨x, v⟩)
(p : ℕ) (f : Π ⦃R : Type u_3⦄ [_inst_3 : comm_ring R], witt_vector p R → witt_vector p R → witt_vector p R) : Prop
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G →g G') (v : V) (w : ↥(G.neighbor_set v)) : ↥(G'.neighbor_set (⇑f v))
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ⥤ D) [F.final] (I : Π (d : D), category_theory.limits.colimit (F ⋙ category_theory.coyoneda.obj (opposite.op d)) ≅ punit) : F.final
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) (P : C) (π : Π (b : I.R), I.right b ⟶ P) (w : ∀ (a : I.L), I.fst a ≫ π (I.fst_from a) = I.snd a ≫ π (I.snd_from a)) : category_theory.limits.multicofork I
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] (f : α × β → ennreal) (hf : ae_measurable f (μ.prod ν)) : ∫⁻ (z : α × β), f z ∂μ.prod ν = ∫⁻ (y : β), ∫⁻ (x : α), f (x, y) ∂μ ∂ν
(timeout : ℕ := 200000) (d : declaration) : tactic (option string)
{n : Type u_1} {R : Type u₂} [decidable_eq n] [comm_ring R] (i j : n) [fintype n] (c : R) : 1.update_row i (1 i + c • 1 j) = matrix.transvection i j c
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] {σ : Type u_3} [inhabited σ] (M : Λ → turing.TM1.stmt Γ Λ σ) : turing.TM0.machine Γ (turing.TM1to0.Λ' M)
(o : ordinal) : {a : cardinal | ∃ {ι : Type u} (f : ι → ordinal), ordinal.lsub f = o ∧ cardinal.mk ι = a}.nonempty
{α : Type u_1} {m : measurable_space α} {μ ν : measure_theory.measure α} [measure_theory.sigma_finite ν] {s : measure_theory.measure α} {f : α → ennreal} (hf : measurable f) (hs : s.mutually_singular ν) (hadd : μ = s + ν.with_density f) : f =ᵐ[ν] μ.rn_deriv ν
{V : Type u} {W : Type v} (G : simple_graph V) (G' : simple_graph W) : Type (max u v)
{α : Type u} {β : Type v} (f : α → β) (s : set α) : ↥s → ↥(f '' s)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M → M'} {s : set M} {x : M} {n : with_top ℕ} : cont_mdiff_within_at I I' n f s x ↔ continuous_within_at f s x ∧ cont_diff_within_at 𝕜 n (⇑(ext_chart_at I' (f x)) ∘ f ∘ ⇑((ext_chart_at I x).symm)) ((ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' (s ∩ f ⁻¹' (ext_chart_at I' (f x)).source)) (⇑(ext_chart_at I x) x)
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) (μ : 𝕜) (v : E) (hv : v ∈ (module.End.eigenspace T μ)ᗮ) : ⇑T v ∈ (module.End.eigenspace T μ)ᗮ
{R : Type u_1} [comm_semiring R] (I : ideal R) [hp : I.is_prime] : Type u_1
{I : Type w₀} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {A : Type u₁} [category_theory.category A] (f : Π (i : I), A ⥤ C i) : A ⥤ Π (i : I), C i
{𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [μ.is_add_left_invariant] [μ.is_neg_invariant] : convolution g f L.flip μ = convolution f g L μ
{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (𝕜 : Type u_3) [field 𝕜] [is_alg_closed 𝕜] [category_theory.linear 𝕜 C] [category_theory.limits.has_kernels C] (X : C) [category_theory.simple X] [I : finite_dimensional 𝕜 (X ⟶ X)] : field (category_theory.End X)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} (I : category_theory.InjectiveResolution Y) (J : category_theory.InjectiveResolution Z) (n : ℕ) (g : J.cocomplex.X n ⟶ I.cocomplex.X n) (g' : J.cocomplex.X (n + 1) ⟶ I.cocomplex.X (n + 1)) (w : J.cocomplex.d n (n + 1) ≫ g' = g ≫ I.cocomplex.d n (n + 1)) : Σ' (g'' : J.cocomplex.X (n + 2) ⟶ I.cocomplex.X (n + 2)), J.cocomplex.d (n + 1) (n + 2) ≫ g'' = g' ≫ I.cocomplex.d (n + 1) (n + 2)
{α : Type u_1} {E' : Type u_5} {𝕜 : Type u_11} [is_R_or_C 𝕜] [inner_product_space 𝕜 E'] [complete_space E'] [normed_space ℝ E'] {m m0 : measurable_space α} {μ : measure_theory.measure α} {s : set α} (hm : m ≤ m0) (f : ↥(measure_theory.Lp E' 2 μ)) (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) : ∫ (x : α) in s, ⇑(⇑(measure_theory.condexp_L2 𝕜 hm) f) x ∂μ = ∫ (x : α) in s, ⇑f x ∂μ
{a b : ℝ} {f f' g : ℝ → ℝ} (h : ∀ (x : ℝ), x ∈ set.interval a b → has_deriv_at f (f' x) x) (h' : continuous_on f' (set.interval a b)) (hg : continuous_on g (f '' set.interval a b)) : ∫ (x : ℝ) in a..b, (g ∘ f) x * f' x = ∫ (x : ℝ) in f a..f b, g x
{I : Type u} (R : Type u_1) (f : I → Type v) {r : comm_semiring R} [Π (i : I), semiring (f i)] [Π (i : I), algebra R (f i)] (i : I) : (Π (i : I), f i) →ₐ[R] f i
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} (f : (ι → ℝ) → E) (vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤) (π : box_integral.tagged_prepartition I) : F
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} : iterated_deriv n f = deriv^[n] f
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] (φ : A →ₐ[R] B) : A →ₗ[R] B
{α : Type u_1} {β : Type u_2} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_on f s) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : f '' s ∈ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a
{𝕜 : Type u_1} {E : Type u_4} [semi_normed_group E] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] (h : ∃ (x : E), ∥x∥ ≠ 0) : ∥continuous_linear_map.id 𝕜 E∥ = 1
{α : Type u_1} (m₁ m₂ : measurable_space α) [measurable_space α] (μ : measure_theory.measure α . "volume_tac") : Prop
{α : Type u_1} {G : Type u_8} [normed_group G] {m m0 : measurable_space α} {μ : measure_theory.measure α} {s : set α} [normed_space ℝ G] (hm : m ≤ m0) (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) (x : G) : ↥(measure_theory.Lp G 2 μ)
{β : Type v} {π : β → Type u_1} [fintype β] [Π (b : β), pseudo_metric_space (π b)] [nonempty β] (x : Π (b : β), π b) (r : ℝ) : metric.closed_ball x r = set.univ.pi (λ (b : β), metric.closed_ball (x b) r)
{α : Type u_1} {ι : Type u_5} {m0 : measurable_space α} {μ ν : measure_theory.measure α} {S : set ι} {s : ι → set α} (hc : S.countable) (hs : (⋃ (i : ι) (H : i ∈ S), s i) = set.univ) : μ = ν ↔ ∀ (i : ι), i ∈ S → μ.restrict (s i) = ν.restrict (s i)
{α : Type u_1} {F : Type u_6} {𝕜 : Type u_11} {p : ennreal} [is_R_or_C 𝕜] [normed_group F] [normed_space 𝕜 F] {m m0 : measurable_space α} {μ : measure_theory.measure α} (hm : m ≤ m0) (f : ↥(measure_theory.Lp_meas F 𝕜 m p μ)) (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ⊤) : ∃ (g : α → F), measure_theory.fin_strongly_measurable g (μ.trim hm) ∧ ⇑f =ᵐ[μ] g
{R : Type u} {S : Type v} [semiring R] [semiring S] (f : R →+* S) (I : ideal R) : ideal S
{I : Type w₀} (C : I → Type u₁) [Π (i : I), category_theory.category (C i)] {J : Type w₀} {D : J → Type u₁} [Π (j : J), category_theory.category (D j)] : (Π (i : I), C i) ⥤ (Π (j : J), D j) ⥤ Π (s : I ⊕ J), sum.elim C D s
{C : Type u} [category_theory.category C] {D : Type u₂} [category_theory.category D] [category_theory.limits.has_equalizers C] [category_theory.limits.has_finite_products C] (G : C ⥤ D) [category_theory.limits.preserves_limits_of_shape category_theory.limits.walking_parallel_pair G] [Π (J : Type v) [_inst_8 : fintype J], category_theory.limits.preserves_limits_of_shape (category_theory.discrete J) G] : category_theory.limits.preserves_finite_limits G
{R : Type u} {M₂ : Type v₂} {M₃ : Type v₃} [semiring R] [add_comm_monoid M₂] [add_comm_monoid M₃] [module R M₂] [module R M₃] {ι₁ : Type u_1} {ι₂ : Type u_2} [decidable_eq ι₁] [decidable_eq ι₂] (σ : ι₁ ≃ ι₂) : multilinear_map R (λ (i : ι₁), M₂) M₃ ≃+ multilinear_map R (λ (i : ι₂), M₂) M₃
{n : ℕ} {K : Type u_8} [field K] {μ : K} (h : is_primitive_root μ n) [char_zero K] : minpoly ℤ μ ∣ polynomial.X ^ n - 1
{R : Type u_1} {M : Type u_7} [semiring R] [add_comm_monoid M] {σ σ' : R →+* R} [ring_hom_inv_pair σ σ'] [ring_hom_inv_pair σ' σ] {module_M : module R M} (f : M →ₛₗ[σ] M) (hf : function.involutive ⇑f) : M ≃ₛₗ[σ] M
{R : Type u_5} {k : ℕ} [comm_ring R] {ζ : Rˣ} (h : is_primitive_root ζ k) : zmod k ≃+ additive ↥(subgroup.zpowers ζ)
{A : Type u_3} [semiring A] [algebra ℝ A] ⦃f g : ℂ →ₐ[ℝ] A⦄ (h : ⇑f complex.I = ⇑g complex.I) : f = g
{𝕜 : Type u} {G : Type wG} {G' : Type wG'} [nondiscrete_normed_field 𝕜] [normed_group G] [normed_space 𝕜 G] [normed_group G'] [normed_space 𝕜 G'] {k n : ℕ} (f : multilinear_map 𝕜 (λ (i : fin n), G) G') (s : finset (fin n)) (hk : s.card = k) (z : G) {C : ℝ} (H : ∀ (m : fin n → G), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : fin n), ∥m i∥)) (v : fin k → G) : ∥⇑(f.restr s hk z) v∥ ≤ C * ∥z∥ ^ (n - k) * finset.univ.prod (λ (i : fin k), ∥v i∥)
{α : Type u_1} {n : ℕ} {C : vector3 α n.succ → Sort u} (H : Π (a : α) (t : vector3 α n), C (a::t)) (v : vector3 α n.succ) : C v
{V : Type u} [category_theory.category V] [category_theory.preadditive V] {P Q : cochain_complex V ℕ} (e : P ⟶ Q) (zero : P.X 1 ⟶ Q.X 0) (comm_zero : e.f 0 = P.d 0 1 ≫ zero) (one : P.X 2 ⟶ Q.X 1) (comm_one : e.f 1 = zero ≫ Q.d 0 1 + P.d 1 2 ≫ one) (succ : Π (n : ℕ) (p : Σ' (f : P.X (n + 1) ⟶ Q.X n) (f' : P.X (n + 2) ⟶ Q.X (n + 1)), e.f (n + 1) = f ≫ Q.d n (n + 1) + P.d (n + 1) (n + 2) ≫ f'), Σ' (f'' : P.X (n + 3) ⟶ Q.X (n + 2)), e.f (n + 2) = p.snd.fst ≫ Q.d (n + 1) (n + 2) + P.d (n + 2) (n + 3) ≫ f'') [category_theory.limits.has_zero_object V] (n : ℕ) : Σ' (f : P.X n ⟶ homological_complex.X_prev Q n) (f' : homological_complex.X_next P n ⟶ Q.X n), e.f n = f ≫ homological_complex.d_to Q n + homological_complex.d_from P n ≫ f'
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : α → F} {f' : α → E'} {l : filter α} : (λ (x : α), ∥f' x∥) =o[l] g → f' =o[l] g
{ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (f : smooth_partition_of_unity ι I M s) : partition_of_unity ι M s
(c : conv unit) (lhs : expr) (rel : name := name.mk_string "eq" name.anonymous) : tactic (expr × expr)
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] (F : V ⥤ W) [F.additive] {f g : C ⟶ D} (h : homotopy f g) : homotopy ((F.map_homological_complex c).map f) ((F.map_homological_complex c).map g)
(R₁ : Type u_3) {A : Type u_5} [comm_semiring R₁] [comm_ring A] [algebra R₁ A] (I : ideal A) : function.surjective ⇑(ideal.quotient.mkₐ R₁ I)
{α : Type u} {σ : Type v} (M : NFA α σ) (S : set σ) (a : α) : set σ
{R : Type u_1} {S : Type u_6} {M : Type u_9} {M₂ : Type u_11} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module S M₂] {σ : R →+* S} {σ' : S →+* R} [ring_hom_inv_pair σ σ'] (f : M →ₛₗ[σ] M₂) (g : M₂ → M) (h₁ : function.left_inverse g ⇑f) (h₂ : function.right_inverse g ⇑f) : M₂ →ₛₗ[σ'] M
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] [fintype ι] (I : box_integral.box ι) (l : box_integral.integration_params) (f : (ι → ℝ) → E) (vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤) : F
{R : Type u} {σ : Type u_1} [comm_semiring R] {M : mv_polynomial σ R → Prop} (p : mv_polynomial σ R) (h_C : ∀ (a : R), M (⇑mv_polynomial.C a)) (h_add : ∀ (p q : mv_polynomial σ R), M p → M q → M (p + q)) (h_X : ∀ (p : mv_polynomial σ R) (n : σ), M p → M (p * mv_polynomial.X n)) : M p
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] {f : module.End K V} {μ : K} {n : ℕ} : submodule.map f (f.generalized_eigenrange μ n) ≤ f.generalized_eigenrange μ n
{ι : Type u} {α : ι → Type u_2} {δ : Π (i : ι), α i → Type v} [Π (i : ι) (j : α i), has_zero (δ i j)] (f : Π₀ (i : ι) (j : α i), δ i j) : Π₀ (i : Σ (i : ι), α i), δ i.fst i.snd
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {μ : measure_theory.measure ℝ} {X : Type u_5} [topological_space X] [topological_space.first_countable_topology X] {F : X → ℝ → E} {x₀ : X} {bound : ℝ → ℝ} {a b : ℝ} (hF_meas : ∀ᶠ (x : X) in nhds x₀, measure_theory.ae_strongly_measurable (F x) (μ.restrict (set.interval_oc a b))) (h_bound : ∀ᶠ (x : X) in nhds x₀, ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → ∥F x t∥ ≤ bound t) (bound_integrable : interval_integrable bound μ a b) (h_cont : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → continuous_at (λ (x : X), F x t) x₀) : continuous_at (λ (x : X), ∫ (t : ℝ) in a..b, F x t ∂μ) x₀
(W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] (C : Type u₁) [category_theory.enriched_category W C] : Type u₁
{ι : Type u} {β : ι → Type v} [dec : decidable_eq ι] [Π (i : ι), add_zero_class (β i)] {γ : Type w} [add_zero_class γ] ⦃f g : (Π₀ (i : ι), β i) →+ γ⦄ (H : ∀ (i : ι) (y : β i), ⇑f (dfinsupp.single i y) = ⇑g (dfinsupp.single i y)) : f = g
{α : Type u} [pseudo_emetric_space α] {δ ε : ℝ} (hε : 0 ≤ ε) (hδ : 0 ≤ δ) (s : set α) : metric.cthickening ε (metric.cthickening δ s) ⊆ metric.cthickening (ε + δ) s
{I : Type w₀} (C : I → Type u₁) [Π (i : I), category_theory.category (C i)] : category_theory.category (Π (i : I), C i)
(s : simp_lemmas × list name) (ps : list pexpr) (cfg : auto.auto_config := {use_simp := bool.tt, max_ematch_rounds := 20}) : tactic unit
{L : first_order.language} {ι : Type v} [preorder ι] (G : ι → Type w) [Π (i : ι), L.Structure (G i)] (f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)) [is_directed ι has_le.le] [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] [nonempty ι] : L.Structure (first_order.language.direct_limit G f)
{G : Type u_1} {α : Type u_2} [add_group G] [add_action G α] [measurable_space α] {s : set α} {μ : measure_theory.measure α} [measurable_space G] [has_measurable_vadd G α] [measure_theory.vadd_invariant_measure G α μ] [encodable G] (hs : measure_theory.is_add_fundamental_domain G s μ) {f : α → ennreal} (hf : ∀ (γ : G) (x : α), f (γ +ᵥ x) = f x) : ess_sup f (μ.restrict s) = ess_sup f μ
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} [category_theory.limits.has_zero_object V] (j : ι) : (Π (i j : ι), C.X i ⟶ D.X j) →+ (C.X j ⟶ D.X_prev j)
{G : Type u_1} [group G] {N : Type u_3} [group N] (f : G →* N) (s : set G) : subgroup.map f (subgroup.closure s) = subgroup.closure (⇑f '' s)
{ι : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis ι R M) {R₁ : Type u_9} [semiring R₁] {σ : R →+* R₁} {M₁ : Type u_10} [add_comm_monoid M₁] [module R₁ M₁] {f₁ f₂ : M →ₛₗ[σ] M₁} (h : ∀ (i : ι), ⇑f₁ (⇑b i) = ⇑f₂ (⇑b i)) : f₁ = f₂
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {I : lie_ideal R L} (k : ℕ) : ↑(lie_module.lower_central_series R L (L ⧸ I) k) = ↑(lie_module.lower_central_series R (L ⧸ I) (L ⧸ I) k)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M → M'} {s : set M} {x : M} {n : with_top ℕ} {x' : M} {y : M'} (hx : x' ∈ (charted_space.chart_at H x).to_local_equiv.source) (hy : f x' ∈ (charted_space.chart_at H' y).to_local_equiv.source) : cont_mdiff_within_at I I' n f s x' ↔ continuous_within_at f s x' ∧ cont_diff_within_at 𝕜 n (⇑(ext_chart_at I' y) ∘ f ∘ ⇑((ext_chart_at I x).symm)) ((ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' (s ∩ f ⁻¹' (ext_chart_at I' y).source)) (⇑(ext_chart_at I x) x')
{V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hxyne : x ≠ y) (hxzne : x ≠ z) (hxy : ∥x∥ = ∥y∥) (hxz : ∥x∥ = ∥z∥) : o.oangle y z = 2 • o.oangle (y - x) (z - x)
{n : ℕ+} {K : Type u} {L : Type v} [field L] {ζ : L} (hζ : is_primitive_root ζ ↑n) [field K] [algebra K L] [ne_zero ↑↑n] [is_cyclotomic_extension {n} K L] (h : 2 < ↑n) (hirr : irreducible (polynomial.cyclotomic ↑n K)) : ⇑(algebra.norm K) (ζ - 1) = ↑(polynomial.eval 1 (polynomial.cyclotomic ↑n ℤ))
{σ : Type u_1} {R : Type u_2} [comm_semiring R] : mv_polynomial σ R →+* mv_power_series σ R
{α : Type u_2} [measurable_space α] {f : α → α} {s : set α} {μ : measure_theory.measure α} (hf : measure_theory.conservative f μ) (hs : measurable_set s) (n : ℕ) : ⇑μ {x ∈ s | ∀ (m : ℕ), m ≥ n → f^[m] x ∉ s} = 0
{α : Type u_1} [preorder α] [pred_order α] [is_pred_archimedean α] {P : α → Prop} {m : α} (h0 : P m) (h1 : ∀ (n : α), n ≤ m → P n → P (order.pred n)) ⦃n : α⦄ (hmn : n ≤ m) : P n
(K : Type u_1) (σ : Type u_2) [comm_semiring K] : mv_polynomial σ K →ₗ[K] (σ → K) → K
{σ : Type} (state : σ) : interaction_monad σ unit
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : continuous_multilinear_map 𝕜 E G) {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ M * finset.univ.prod (λ (i : ι), ∥m i∥)) : ∥f∥ ≤ M
(P : Π (R : Type u) [_inst_7 : comm_ring R], Prop) : Prop
{G : Type u_1} [comm_group G] [topological_space G] [topological_group G] [t2_space G] [measurable_space G] [borel_space G] [locally_compact_space G] [topological_space.second_countable_topology G] (μ : measure_theory.measure G) [μ.is_haar_measure] : measure_theory.measure.map has_inv.inv μ = μ
{Ω : Type u_1} {m : measurable_space Ω} (f : Ω → ℝ) (μ : measure_theory.measure Ω) : ℝ
{α : Type} [has_mul α] [add_monoid α] : ℕ → Π {ds : list ℕ}, holor α ds → Prop
(n : ℕ) {β : Π (v : typevec (n + 1)) (v' : typevec (n + 1)), v.arrow v' → Sort u_3} (F : Π (t : Type u_1) (t' : Type u_2) (f : t → t') (v : typevec n) (v' : typevec n) (fs : v.arrow v'), β (v ::: t) (v' ::: t') (fs ::: f)) (v : typevec (n + 1)) (v' : typevec (n + 1)) (fs : v.arrow v') : β v v' fs
{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w₁} [category_theory.category D] {E : Type w₂} [category_theory.category E] (F : D ⥤ E) [∀ (α β : Type (max v u)) (fst snd : β → α), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) D] [∀ (α β : Type (max v u)) (fst snd : β → α), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) E] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ D] [∀ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)ᵒᵖ E] [Π (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)ᵒᵖ F] [Π (X : C) (W : J.cover X) (P : Cᵒᵖ ⥤ D), category_theory.limits.preserves_limit (W.index P).multicospan F] : J.sheafification D ⋙ (category_theory.whiskering_right Cᵒᵖ D E).obj F ≅ (category_theory.whiskering_right Cᵒᵖ D E).obj F ⋙ J.sheafification E
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} {σ : Type u_3} [inhabited Λ] [inhabited σ] (l : list Γ) : turing.TM1.cfg Γ Λ σ
{C : Type u} [category_theory.category C] {A : C} [category_theory.limits.has_finite_products C] [category_theory.exponentiable A] {I : C} (t : category_theory.limits.is_initial I) : I ⨯ A ≅ I
{α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] [topological_space β] {f : β → α} {K : set β} (hK : is_compact K) (hf : continuous_on f K) : bdd_below (f '' K)
{I : Type u} {f : I → Type v} [decidable_eq I] [Π (i : I), add_zero_class (f i)] : pairwise (λ (i j : I), ∀ (x : f i) (y : f j), add_commute (pi.single i x) (pi.single j y))
(𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (M : Type u_4) [topological_space M] [charted_space H M] (n : with_top ℕ) (x : M) : Type (max u_4 u_1)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] (ι : Type u_2) [fintype ι] (E : ι → Type u_3) [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] (s : Π (i : ι), set (E i)) (I : set ι) (h : ∀ (i : ι), i ∈ I → unique_diff_on 𝕜 (s i)) : unique_diff_on 𝕜 (I.pi s)
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] (G : V ⥤ W) [G.additive] (hom : Π (i j : ι), c.rel j i → (C.X i ⟶ D.X j)) : (G.map_homological_complex c).map (homotopy.null_homotopic_map' hom) = homotopy.null_homotopic_map' (λ (i j : ι) (hij : c.rel j i), G.map (hom i j hij))
{C : Type u} [category_theory.category C] {X : C} {J : category_theory.grothendieck_topology C} {S T : J.cover X} (I : S.arrow) (f : S ⟶ T) : T.arrow
{E : Type u_1} [inner_product_space ℝ E] {F : Type u_2} [normed_group F] [normed_space ℝ F] {H : Type u_3} [topological_space H] {I : model_with_corners ℝ F H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {n : ℕ} [fact (finite_dimensional.finrank ℝ E = n + 1)] {m : with_top ℕ} {f : M → E} (hf : cont_mdiff I (model_with_corners_self ℝ E) m f) (hf' : ∀ (x : M), f x ∈ metric.sphere 0 1) : cont_mdiff I (model_with_corners_self ℝ (euclidean_space ℝ (fin n))) m (set.cod_restrict (λ (x : M), f x) (metric.sphere 0 1) hf')
{V : Type u_1} {W : Type u_2} [semi_normed_group V] [semi_normed_group W] (f g : normed_group_hom V W) : normed_group_hom ↥(f.equalizer g) V
{ι : Type u_1} {R : Type u_2} [comm_semiring R] {t : finset ι} (h : t.nonempty) (I : ι → ideal R) : (⨆ (i : ι) (H : i ∈ t), ⨅ (j : ι) (hj : j ∈ t) (ij : j ≠ i), I j) = ⊤ ↔ ↑t.pairwise (λ (i j : ι), I i ⊔ I j = ⊤)
{C : Type u} [category_theory.category C] (ℬ : Π (X Y : C), category_theory.limits.limit_cone (category_theory.limits.pair X Y)) {W X Y Z : C} (f : W ⟶ X) (g : Y ⟶ Z) : category_theory.monoidal_of_chosen_finite_products.tensor_obj ℬ W Y ⟶ category_theory.monoidal_of_chosen_finite_products.tensor_obj ℬ X Z
{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] {W X Y Z : C} [category_theory.monoidal_category.lift_obj W] [category_theory.monoidal_category.lift_obj X] [category_theory.monoidal_category.lift_obj Y] (f : W ⟶ X) (g : X ⟶ Y) (h : Y ⟶ Z) [category_theory.monoidal_category.lift_hom f] [category_theory.monoidal_category.lift_hom g] : f ≫ g ≫ h = (f ≫ g) ≫ h
{G : Type u_1} [add_group G] ⦃h k : set G⦄ (h' : h ⊆ k) : add_subgroup.closure h ≤ add_subgroup.closure k
{k : Type u} [comm_ring k] (G : Type u) [group G] {V : Type u} [add_comm_group V] [module k V] [module (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] {W : Type u} [add_comm_group W] [module k W] [module (monoid_algebra k G) W] [is_scalar_tower k (monoid_algebra k G) W] (π : W →ₗ[k] V) [fintype G] : W →ₗ[monoid_algebra k G] V
{β : Type u} [metric_space β] [measurable_space β] [borel_space β] [sigma_compact_space β] [has_besicovitch_covering β] (ρ μ : measure_theory.measure β) [measure_theory.is_locally_finite_measure μ] [measure_theory.is_locally_finite_measure ρ] : ∀ᵐ (x : β) ∂μ, filter.tendsto (λ (r : ℝ), ⇑ρ (metric.closed_ball x r) / ⇑μ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds (ρ.rn_deriv μ x))
{R : Type u} [ring R] (I : ideal R) : ideal R
{α : Type u} {β : Type v} [topological_space α] [compact_space α] [pseudo_metric_space β] [t2_space β] (s : set β) (hs : is_compact s) (A : set (bounded_continuous_function α β)) (in_s : ∀ (f : bounded_continuous_function α β) (x : α), f ∈ A → ⇑f x ∈ s) (H : ∀ (x : α) (ε : ℝ), ε > 0 → (∃ (U : set α) (H : U ∈ nhds x), ∀ (y : α), y ∈ U → ∀ (z : α), z ∈ U → ∀ (f : bounded_continuous_function α β), f ∈ A → has_dist.dist (⇑f y) (⇑f z) < ε)) : is_compact (closure A)
{E : Type u} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {f' : E} {s : set ℝ} {x r : ℝ} (hf : has_deriv_within_at f f' s x) (hr : ∥f'∥ < r) : ∀ᶠ (z : ℝ) in nhds_within x s, ∥z - x∥⁻¹ * (∥f z∥ - ∥f x∥) < r
{p q x : ℝ} (h : liouville_with p x) (hlt : q < p) : ∃ᶠ (n : ℕ) in filter.at_top, ∃ (m : ℤ), x ≠ ↑m / ↑n ∧ |x - ↑m / ↑n| < ↑n ^ -q
{x : ℝ} (h : |x| < 1) (n : ℕ) : |(finset.range n).sum (λ (i : ℕ), x ^ (i + 1) / (↑i + 1)) + real.log (1 - x)| ≤ |x| ^ (n + 1) / (1 - |x|)
{C : Type (max v u)} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] {X : C} {K : Type (max v u)} [category_theory.small_category K] {F : K ⥤ Cᵒᵖ ⥤ D} {W : J.cover X} (i : W.arrow) (E : category_theory.limits.cone (F ⋙ J.diagram_functor D X ⋙ (category_theory.evaluation (J.cover X)ᵒᵖ D).obj (opposite.op W))) : category_theory.limits.cone (F ⋙ (category_theory.evaluation Cᵒᵖ D).obj (opposite.op i.Y))
{I : Type u_3} {f : I → Type u_4} [inhabited I] [inst : ∀ (i : I), nonempty (f i)] [nontrivial (f inhabited.default)] : nontrivial (Π (i : I), f i)
{ι : Type u_1} [fintype ι] {I : box_integral.box ι} (π : box_integral.prepartition I) (r : (ι → ℝ) → ↥(set.Ioi 0)) : box_integral.tagged_prepartition I
{R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (N : lie_submodule R L M) (I : lie_ideal R L) : ↑⁅I,N⁆ = submodule.span R {m : M | ∃ (x : ↥I) (n : ↥N), ⁅↑x,↑n⁆ = m}
{m : Type u → Type v} [functor m] {σ α : Type u} (cmd : state_t σ m α) (s : σ) : m α
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] : M →ₗ[R] Hausdorffification I M
{α : Type} (t : tactic α) (cfg : tactic.dsimp_config := {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.ff, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}) (no_defaults : bool := bool.ff) (attr_names : list name := list.nil) (hs : list tactic.simp_arg_type := list.nil) : tactic α
{ι : Sort u_1} (I : nonempty ι) (f : ι → ordinal) : ordinal
{E : Type u_2} [add_comm_group E] [module ℝ E] [topological_space E] [topological_add_group E] [has_continuous_smul ℝ E] {s : set E} (hs : convex ℝ s) {x : E} (hx : x ∈ interior s) (t : ℝ) (ht : 1 < t) : closure s ⊆ ⇑(affine_map.homothety x t) '' interior s
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} (f : ↥(measure_theory.Lp.simple_func ℝ 1 μ)) : ↥(measure_theory.Lp.simple_func ℝ 1 μ)
{C : Type u} [category_theory.category C] {I : category_theory.limits.multispan_index C} (K : category_theory.limits.multicofork I) (desc : Π (E : category_theory.limits.multicofork I), K.X ⟶ E.X) (fac : ∀ (E : category_theory.limits.multicofork I) (i : I.R), K.π i ≫ desc E = E.π i) (uniq : ∀ (E : category_theory.limits.multicofork I) (m : K.X ⟶ E.X), (∀ (i : I.R), K.π i ≫ m = E.π i) → m = desc E) : category_theory.limits.is_colimit K
{E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] (f : E →ₗ[ℝ] E) (s : set E) : ⇑μ (⇑f '' s) = ennreal.of_real |⇑linear_map.det f| * ⇑μ s
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (x : M ⧸ S) : 0 ≤ ∥x∥
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} {F : Type u_8} [normed_group F] [normed_space 𝕜 F] (Z : basic_smooth_vector_bundle_core I M F) (hs : unique_mdiff_on I s) : unique_mdiff_on (I.prod (model_with_corners_self 𝕜 F)) (Z.to_topological_vector_bundle_core.proj ⁻¹' s)
{C : Type u₁} {D : Type u₂} [category_theory.category C] [category_theory.category D] (G : D ⥤ C) [category_theory.monadic_right_adjoint G] ⦃A B : D⦄ (f g : A ⟶ B) [G.is_split_pair f g] : category_theory.creates_colimit (category_theory.limits.parallel_pair f g) G
{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] {m : α → β} {s : set α} (hm : uniform_inducing m) : is_complete (m '' s) ↔ is_complete s
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (G : Type u_4) [topological_space G] [charted_space H G] [monoid G] [has_smooth_mul I G] : left_invariant_derivation I G →+ cont_mdiff_map I (model_with_corners_self 𝕜 𝕜) G 𝕜 ⊤ → cont_mdiff_map I (model_with_corners_self 𝕜 𝕜) G 𝕜 ⊤
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (W : submodule 𝕜 E) : inner_product_space 𝕜 ↥W
{k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {A : Type u₃} [semiring A] [algebra k A] ⦃φ₁ φ₂ : monoid_algebra k G →ₐ[k] A⦄ (h : ∀ (x : G), ⇑φ₁ (finsupp.single x 1) = ⇑φ₂ (finsupp.single x 1)) : φ₁ = φ₂
{α : Type u} {β : Type u_1} [topological_space α] [topological_space β] {s : set (set α)} (hs : topological_space.is_topological_basis s) {t : set (set β)} (ht : topological_space.is_topological_basis t) : topological_space.is_topological_basis ((λ (u : set α), sum.inl '' u) '' s ∪ (λ (u : set β), sum.inr '' u) '' t)
{G : Type u_1} [group G] {H : subgroup G} {R S : set G} (hR : R ∈ subgroup.right_transversals ↑H) (hR1 : 1 ∈ R) (hS : subgroup.closure S = ⊤) : subgroup.closure ((λ (g : G), ⟨g * (↑(subgroup.mem_right_transversals.to_fun hR g))⁻¹, _⟩) '' (R * S)) = ⊤
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : ℕ → α → ennreal} (hf : ∀ (n : ℕ), measurable (f n)) (h_mono : monotone f) : ∫⁻ (a : α), (⨆ (n : ℕ), f n a) ∂μ = ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
{E : Type u_1} [normed_group E] [normed_space ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} {C : ℝ} (hf : ∀ (x : ℝ), x ∈ set.Icc a b → has_deriv_within_at f (f' x) (set.Icc a b) x) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → ∥f' x∥ ≤ C) (x : ℝ) (H : x ∈ set.Icc a b) : ∥f x - f a∥ ≤ C * (x - a)
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f g : continuous_multilinear_map 𝕜 E G) : ∥f + g∥ ≤ ∥f∥ + ∥g∥
{V : Type u_1} [inner_product_space ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : ∥x - y∥ = |∥x∥ - ∥y∥| ↔ inner_product_geometry.angle x y = 0
(α : Type u) (β : Type v) [add_group α] [add_action α β] [fintype α] [fintype β] [fintype (quotient (add_action.orbit_rel α β))] [Π (b : β), fintype ↥(add_action.stabilizer α b)] : fintype.card β = finset.univ.sum (λ (ω : quotient (add_action.orbit_rel α β)), fintype.card α / fintype.card ↥(add_action.stabilizer α ω.out'))
(σ : Type u_1) (R : Type u_2) [comm_semiring R] [fintype σ] (n : ℕ) : mv_polynomial.esymm σ R n = (finset.powerset_len n finset.univ).sum (λ (t : finset σ), ⇑(mv_polynomial.monomial (t.sum (λ (i : σ), finsupp.single i 1))) 1)
{V : Type u_1} {W : Type u_2} {V₁ : Type u_3} [semi_normed_group V] [semi_normed_group W] [semi_normed_group V₁] {f g : normed_group_hom V W} (φ : normed_group_hom V₁ V) (h : f.comp φ = g.comp φ) (hφ : φ.norm_noninc) : (normed_group_hom.equalizer.lift φ h).norm_noninc
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group β] {p : ennreal} {f : ι → α → β} [subsingleton ι] (hp_one : 1 ≤ p) (hp_top : p ≠ ⊤) (hf : ∀ (i : ι), measure_theory.strongly_measurable (f i)) (hf' : ∀ (i : ι), measure_theory.mem_ℒp (f i) p μ) : measure_theory.uniform_integrable f p μ
{R : Type u} {σ : Type v} [comm_ring R] {I : ideal R} {f : mv_polynomial σ R} : f ∈ ideal.map mv_polynomial.C I ↔ ∀ (m : σ →₀ ℕ), mv_polynomial.coeff m f ∈ I
{ι : Type u_10} {R : Type u_11} {R₂ : Type u_12} {M : Type u_13} {M₂ : Type u_14} [semiring R] [semiring R₂] [add_comm_monoid M] [module R M] [add_comm_monoid M₂] [module R₂ M₂] [topological_space M] [topological_space M₂] {σ : R →+* R₂} {f : ι → M} (φ : M →SL[σ] M₂) {x : M} (hf : has_sum f x) : has_sum (λ (b : ι), ⇑φ (f b)) (⇑φ x)
{V : Type u} [category_theory.category V] [category_theory.preadditive V] {P Q : cochain_complex V ℕ} (e : P ⟶ Q) (zero : P.X 1 ⟶ Q.X 0) (comm_zero : e.f 0 = P.d 0 1 ≫ zero) (one : P.X 2 ⟶ Q.X 1) (comm_one : e.f 1 = zero ≫ Q.d 0 1 + P.d 1 2 ≫ one) (succ : Π (n : ℕ) (p : Σ' (f : P.X (n + 1) ⟶ Q.X n) (f' : P.X (n + 2) ⟶ Q.X (n + 1)), e.f (n + 1) = f ≫ Q.d n (n + 1) + P.d (n + 1) (n + 2) ≫ f'), Σ' (f'' : P.X (n + 3) ⟶ Q.X (n + 2)), e.f (n + 2) = p.snd.fst ≫ Q.d (n + 1) (n + 2) + P.d (n + 2) (n + 3) ≫ f'') (n : ℕ) : Σ' (f : P.X (n + 1) ⟶ Q.X n) (f' : P.X (n + 2) ⟶ Q.X (n + 1)), e.f (n + 1) = f ≫ Q.d n (n + 1) + P.d (n + 1) (n + 2) ≫ f'
{R : Type u} [comm_semiring R] (f : polynomial R) (𝓟 : ideal R) : Prop
{V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y : V} (h : hb.oangle x y = 0) : x = y ↔ ∥x∥ = ∥y∥
{α : Type u_1} {β : Type u_2} {f : α → β} (hf : function.injective f) (s : set α) (hs : (f '' s).subsingleton) : s.subsingleton
{β : Type u_2} {V W : set (β × β)} {x y z : β} (h : y ∈ uniform_space.ball x V) (h' : z ∈ uniform_space.ball y W) : z ∈ uniform_space.ball x (comp_rel V W)
(σ : Type u) (R : Type v) [comm_ring R] (m : ℕ) : submodule R (mv_polynomial σ R)
{σ : Type} : interaction_monad σ σ
{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {I J : ideal R} {N : submodule R M} (hN : N.fg) (hIN : N ≤ I • N) (hIjac : I ≤ J.jacobson) : N = J • N
{α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {c : ℝ} {f : α → E} {g : α → F} {l : filter α} : asymptotics.is_O_with c l f g ↔ ∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥
{𝕜 : Type u_1} [is_R_or_C 𝕜] [dec_𝕜 : decidable_eq 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional 𝕜 E] : direct_sum.is_internal (λ (μ : module.End.eigenvalues T), module.End.eigenspace T ↑μ)
(n : interactive.parse (optional (interactive.with_desc ↑"n" lean.parser.small_nat))) (hs : interactive.parse tactic.simp_arg_list) (attr_names : interactive.parse interactive.types.with_ident_list) (use : interactive.parse (lean.parser.tk "using" *> lean.parser.many interactive.types.ident_ <|> return list.nil)) (opt : tactic.suggest.suggest_opt := {to_opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := λ (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (λ (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}, compulsory_hyps := list.nil expr, try_this := bool.tt}) : tactic unit
{ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (f : bump_covering ι M s) (hf : ∀ (i : ι), smooth I (model_with_corners_self ℝ ℝ) ⇑(⇑f i)) : smooth_partition_of_unity ι I M s
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [topological_space β] {f : α → β} [measurable_space β] [topological_space.pseudo_metrizable_space β] [opens_measurable_space β] [topological_space.second_countable_topology β] (hf : ae_measurable f μ) : measure_theory.ae_strongly_measurable f μ
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x : E} {r : 𝕜} (hx : x ≠ 0) (hr : r ≠ 0) : is_R_or_C.abs (has_inner.inner x (r • x)) / (∥x∥ * ∥r • x∥) = 1
{α : Type u_1} {E : Type u_2} [normed_group E] [normed_space ℝ E] [complete_space E] {m : measurable_space α} {μ : measure_theory.measure α} {ι : Type u_3} (f : α → E) (hfi : measure_theory.integrable f μ) {F : ι → α → E} {l : filter ι} (hFi : ∀ᶠ (i : ι) in l, measure_theory.integrable (F i) μ) (hF : filter.tendsto (λ (i : ι), ∫⁻ (x : α), ↑∥F i x - f x∥₊ ∂μ) l (nhds 0)) : filter.tendsto (λ (i : ι), ∫ (x : α), F i x ∂μ) l (nhds (∫ (x : α), f x ∂μ))
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] {I : model_with_corners 𝕜 E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {n : with_top ℕ} {e : local_homeomorph M H} (h : e ∈ smooth_manifold_with_corners.maximal_atlas I M) : cont_mdiff_on I I n ⇑(e.symm) e.to_local_equiv.target
{α : Type u_1} {m : measurable_space α} (μ : measure_theory.measure α) : measure_theory.vector_measure α ennreal
(md : tactic.transparency := tactic.transparency.semireducible) : tactic unit
{R : Type u} [ring R] {ι : Type v} [preorder ι] {G : ι → Type w} [Π (i : ι), add_comm_group (G i)] [Π (i : ι), module R (G i)] (f : Π (i j : ι), i ≤ j → (G i →ₗ[R] G j)) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] (i : ι) (x : G i) (h : i ≤ i) : ⇑(f i i h) x = x
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} {f : X ⟶ Y} {Z : C} (g : Y ⟶ Z) (eq : f ≫ g = 0) (desc : Π {Z' : C} (g' : Y ⟶ Z'), f ≫ g' = 0 → (Z ⟶ Z')) (fac : ∀ {Z' : C} (g' : Y ⟶ Z') (eq' : f ≫ g' = 0), g ≫ desc g' eq' = g') (uniq : ∀ {Z' : C} (g' : Y ⟶ Z') (eq' : f ≫ g' = 0) (m : Z ⟶ Z'), g ≫ m = g' → m = desc g' eq') : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_π g eq)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field 𝕜] [nondiscrete_normed_field 𝕜₂] [normed_space 𝕜 E] [normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [ring_hom_isometric σ₁₂] (f : E →SL[σ₁₂] F) (x : E) : ∥⇑f x∥ ≤ ∥f∥ * ∥x∥
{ι : Type u_1} {I : box_integral.box ι} [fintype ι] (π : box_integral.tagged_prepartition I) (r : (ι → ℝ) → ↥(set.Ioi 0)) : Prop
{n : ℕ} {α : Type u_1} {C : Π {n : ℕ}, vector α n → Sort u_2} (v : vector α n) (h_nil : C vector.nil) (h_cons : Π {n : ℕ} {x : α} {w : vector α n}, C w → C (x::ᵥw)) : C v
{I : Type w₀} (C : I → Type u₁) [Π (i : I), category_theory.category (C i)] (i : I) : (Π (i : I), C i) ⥤ C i
{α : Type u₁} {β : Type u₂} {φ : Type u₃} : (α × β → φ) → α → β → φ
{R : Type u_3} {S : Type u_4} {F : Type u_5} [comm_ring R] [comm_ring S] [monoid_hom_class F (polynomial R) (polynomial S)] (φ : F) (hφ : non_zero_divisors (polynomial R) ≤ submonoid.comap ↑φ (non_zero_divisors (polynomial S))) : ratfunc R →* ratfunc S
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z} [category_theory.limits.preserves_limit (category_theory.limits.cospan h i) F] (s : category_theory.is_pullback f g h i) : category_theory.is_pullback (F.map f) (F.map g) (F.map h) (F.map i)
{α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} : x ∈ closure s ↔ ∀ (ε : ennreal), ε > 0 → (∃ (y : α) (H : y ∈ s), has_edist.edist x y < ε)
{I : Type u} {f : I → Type v₁} [decidable_eq I] [Π (i : I), has_zero (f i)] {i i' : I} (h : i ≠ i') (x : f i) : pi.single i x i' = 0
{R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B] [fintype A] [decidable_eq B] (φ : A →ₐ[R] B) : fintype ↥(φ.range)
{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} [inhabited Λ] {σ : Type u_4} [inhabited σ] (M : Λ → turing.TM2.stmt Γ Λ σ) (S : finset Λ) : finset turing.TM2to1.Λ'
(R₁ : Type u_3) {A : Type u_5} [comm_semiring R₁] [comm_ring A] [algebra R₁ A] (I : ideal A) : A →ₐ[R₁] A ⧸ I
(n : name := name.mk_string "_x" name.anonymous) (i : option ℕ := option.none) : tactic name
{α : Type u} {β : Type v} [pseudo_metric_space α] [nonempty β] [semilattice_sup β] {γ : Type u_1} {F : β → γ → α} {s : set γ} : uniform_cauchy_seq_on F filter.at_top s ↔ ∀ (ε : ℝ), ε > 0 → (∃ (N : β), ∀ (m : β), m ≥ N → ∀ (n : β), n ≥ N → ∀ (x : γ), x ∈ s → has_dist.dist (F m x) (F n x) < ε)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} (x : E) {v : ι → E} (hv : orthonormal 𝕜 v) : summable (λ (i : ι), ∥has_inner.inner (v i) x∥ ^ 2)
{α : Type u_1} [measurable_space α] (μ : measure_theory.finite_measure α) : nnreal
{L : Type u_1} [linear_ordered_field L] {W : Type v} [add_comm_group W] [module L W] [finite_dimensional L W] {t : finset W} (h : finite_dimensional.finrank L W + 1 < t.card) : ∃ (f : W → L), t.sum (λ (e : W), f e • e) = 0 ∧ t.sum (λ (e : W), f e) = 0 ∧ ∃ (x : W) (H : x ∈ t), 0 < f x
{V : Type u_1} [inner_product_space ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : has_inner.inner x y = -(∥x∥ * ∥y∥) ↔ inner_product_geometry.angle x y = real.pi
{β : Type v} {γ : Type w} [metric_space γ] [metric_space β] {f : γ → β} : uniform_embedding f ↔ (∀ (ε : ℝ), ε > 0 → (∃ (δ : ℝ) (H : δ > 0), ∀ {a b : γ}, has_dist.dist a b < δ → has_dist.dist (f a) (f b) < ε)) ∧ ∀ (δ : ℝ), δ > 0 → (∃ (ε : ℝ) (H : ε > 0), ∀ {a b : γ}, has_dist.dist (f a) (f b) < ε → has_dist.dist a b < δ)
{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) (μs : set K) (xs : ↥μs → V) (h_eigenvec : ∀ (μ : ↥μs), f.has_eigenvector ↑μ (xs μ)) : linear_independent K xs
{α : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] {f : α → E} {g : α → F} {l : filter α} (hf : filter.tendsto f l (nhds 0)) (hg : filter.is_bounded_under has_le.le l (has_norm.norm ∘ g)) (op : E → F → G) (h_op : ∃ (A : ℝ), ∀ (x : E) (y : F), ∥op x y∥ ≤ A * ∥x∥ * ∥y∥) : filter.tendsto (λ (x : α), op (f x) (g x)) l (nhds 0)
{σ : Type u_1} (f : σ → option σ) (a : σ) (b : option σ) (m : ℕ) : Type
{V : Type u_1} [inner_product_space ℝ V] {x y : V} (h : ∥x∥ = ∥y∥) : inner_product_geometry.angle x (x - y) = inner_product_geometry.angle y (y - x)
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) ⦃v : E⦄ (hv : v ∈ (⨆ (μ : 𝕜), module.End.eigenspace T μ)ᗮ) : ⇑T v ∈ (⨆ (μ : 𝕜), module.End.eigenspace T μ)ᗮ
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) : α → ennreal
{C : Type u₁} [category_theory.category C] {W X Y Z : C} (f : W ⟶ X) (g : W ⟶ Y) (h : X ⟶ Z) (i : Y ⟶ Z) : Prop
{α : Type u_1} [metric_space α] [topological_space.second_countable_topology α] [measurable_space α] [opens_measurable_space α] [has_besicovitch_covering α] (μ : measure_theory.measure α) [measure_theory.is_finite_measure μ] (f : α → set ℝ) (s : set α) (hf : ∀ (x : α), x ∈ s → ∀ (δ : ℝ), δ > 0 → (f x ∩ set.Ioo 0 δ).nonempty) : ∃ (t : set (α × ℝ)), t.countable ∧ (∀ (p : α × ℝ), p ∈ t → p.fst ∈ s) ∧ (∀ (p : α × ℝ), p ∈ t → p.snd ∈ f p.fst) ∧ ⇑μ (s  ⋃ (p : α × ℝ) (hp : p ∈ t), metric.closed_ball p.fst p.snd) = 0 ∧ t.pairwise_disjoint (λ (p : α × ℝ), metric.closed_ball p.fst p.snd)
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] : ∏ I.left ⟶ ∏ I.right
(q : pexpr) (allow_mvars subgoals : bool := bool.tt) : tactic expr
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] ⦃f : α → β → E⦄ (hf : measure_theory.integrable (function.uncurry f) (μ.prod ν)) : ∫ (x : α), ∫ (y : β), f x y ∂ν ∂μ = ∫ (y : β), ∫ (x : α), f x y ∂μ ∂ν
{𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [add_comm_group G] [has_measurable_add₂ G] [has_measurable_neg G] [μ.is_add_left_invariant] [measure_theory.sigma_finite μ] {x₀ : G} {s : set G} (hbg : bdd_above ((λ (i : G), ∥g i∥) '' ((λ (t : G), x₀ - t) ⁻¹' s))) (hs : measurable_set s) (h2s : function.support (λ (t : G), ⇑(⇑L (f t)) (g (x₀ - t))) ⊆ s) (hf : measure_theory.integrable_on f s μ) (hmf : measure_theory.ae_strongly_measurable f μ) (hmg : measure_theory.ae_strongly_measurable g μ) : convolution_exists_at f g x₀ L μ
{α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (has_Inf.Inf s)) (Mf : monotone f) (ftop : f ⊤ = ⊤) : f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
{E : Type u_1} [normed_group E] [normed_space ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [normed_space 𝕜 E] [normed_group G] [normed_space 𝕜 G] {f : E → G} {C : ℝ} {s : set E} {x y : E} {f' : E → (E →L[𝕜] G)} {φ : E →L[𝕜] G} (hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) (bound : ∀ (x : E), x ∈ s → ∥f' x - φ∥ ≤ C) (hs : convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x - ⇑φ (y - x)∥ ≤ C * ∥y - x∥
(V : Type u_1) [semi_normed_group V] : ∥normed_group_hom.id V∥ ≤ 1
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {t : set α} {f : α → E} {g : E → ℝ} (hg : concave_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (h0 : ⇑μ t ≠ 0) (ht : ⇑μ t ≠ ⊤) (hfs : ∀ᵐ (x : α) ∂μ.restrict t, f x ∈ s) (hfi : measure_theory.integrable_on f t μ) (hgi : measure_theory.integrable_on (g ∘ f) t μ) : ⨍ (x : α) in t, g (f x) ∂μ ≤ g (⨍ (x : α) in t, f x ∂μ)
{f : ℝ → ℝ} (hf' : differentiable ℝ f) (hf'' : ∀ (x : ℝ), 0 < deriv^[2] f x) : strict_convex_on ℝ set.univ f
(I : name) (T : expr) : tactic (option ℕ)
{σ : Type u_1} (f : σ → option σ) (a : σ) : turing.evals_to f a ↑a
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_multicoequalizer I] (W : C) (k : Π (b : I.R), I.right b ⟶ W) (h : ∀ (a : I.L), I.fst a ≫ k (I.fst_from a) = I.snd a ≫ k (I.snd_from a)) : category_theory.limits.multicoequalizer I ⟶ W
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] : ∐ I.left ⟶ ∐ I.right
(K : Type u_3) [field K] {R₁ : Type u_4} [comm_ring R₁] [is_domain R₁] [algebra R₁ K] [is_fraction_ring R₁ K] (I J : fractional_ideal (non_zero_divisors R₁) K) (h : I * J = 1) : J = I⁻¹
{α : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] [normed_group F] {𝕜 : Type u_5} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 F] [fact (1 ≤ p)] {𝕜' : Type u_4} [normed_field 𝕜'] [normed_space 𝕜' F] [smul_comm_class 𝕜 𝕜' F] (c : 𝕜') (L : E →L[𝕜] F) (f : ↥(measure_theory.Lp E p μ)) : ⇑(continuous_linear_map.comp_LpL p μ (c • L)) f = c • ⇑(continuous_linear_map.comp_LpL p μ L) f
{ι : Type u_5} {σ : ι → Type u_6} [Π (i : ι), topological_space (σ i)] {τ : ι → Type u_1} [Π (i : ι), topological_space (τ i)] {f : Π (i : ι), σ i → τ i} (hf : ∀ (i : ι), embedding (f i)) : embedding (sigma.map id f)
{α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] {μ : measure_theory.measure α} [μ.weakly_regular] [measure_theory.sigma_finite μ] (f : α → ℝ) (hf : measure_theory.integrable f μ) {ε : ℝ} (εpos : 0 < ε) : ∃ (g : α → ereal), (∀ (x : α), ↑(f x) < g x) ∧ lower_semicontinuous g ∧ measure_theory.integrable (λ (x : α), (g x).to_real) μ ∧ (∀ᵐ (x : α) ∂μ, g x < ⊤) ∧ ∫ (x : α), (g x).to_real ∂μ < ∫ (x : α), f x ∂μ + ε
{β : Type u} [metric_space β] [measurable_space β] [borel_space β] [sigma_compact_space β] [has_besicovitch_covering β] (μ : measure_theory.measure β) [measure_theory.is_locally_finite_measure μ] (s : set β) : ∀ᵐ (x : β) ∂μ.restrict s, filter.tendsto (λ (r : ℝ), ⇑μ (s ∩ metric.closed_ball x r) / ⇑μ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 1)
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} {C : set (set α)} {D : set (set β)} (hC : measurable_space.generate_from C = _inst_1) (hD : measurable_space.generate_from D = _inst_3) (h2C : is_pi_system C) (h2D : is_pi_system D) (h3C : μ.finite_spanning_sets_in C) (h3D : ν.finite_spanning_sets_in D) {μν : measure_theory.measure (α × β)} (h₁ : ∀ (s : set α), s ∈ C → ∀ (t : set β), t ∈ D → ⇑μν (s ×ˢ t) = ⇑μ s * ⇑ν t) : μ.prod ν = μν
(c : interactive.parse (optional (lean.parser.tk "!"))) (cfg : tactic.tauto_cfg := {classical := bool.ff, closer := has_pure.pure ()}) : tactic unit
{α : Type u_1} {C : list α → list α → Sort v} (H0 : Π (is : list α), C list.nil is) (H1 : Π (t : α) (ts is : list α), C ts (t :: is) → C is list.nil → C (t :: ts) is) (l₁ l₂ : list α) : C l₁ l₂
{α : Type u} [add_monoid α] (u : add_units α) (val : α) (hv : val = ↑u) (inv : α) (hi : inv = ↑-u) : add_units α
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) [sigma_compact_space α] [borel_space α] [measure_theory.is_locally_finite_measure μ] {ρ : measure_theory.measure α} [measure_theory.is_locally_finite_measure ρ] (hρ : ρ.absolutely_continuous μ) {q : nnreal} {s : set α} (h : s ⊆ {x : α | ↑q < v.lim_ratio_meas hρ x}) : ↑q * ⇑μ s ≤ ⇑ρ s
{n : ℕ} {F : typevec n → Type u} (R : Π ⦃α : typevec n⦄, F α → F α → Prop) (α : typevec n) : Type u
{α : Type u_1} {m : measurable_space α} {ℙ : measure_theory.measure α} [measure_theory.is_finite_measure «ℙ»] {X : α → ℝ} {s : set ℝ} (hms : measurable_set s) (hns : ⇑measure_theory.measure_space.volume s ≠ 0) (hnt : ⇑measure_theory.measure_space.volume s ≠ ⊤) (huX : measure_theory.pdf.is_uniform X s «ℙ» measure_theory.measure_space.volume) : ∫ (x : α), X x ∂«ℙ» = (⇑measure_theory.measure_space.volume s)⁻¹.to_real * ∫ (x : ℝ) in s, x
(s : simp_lemmas) (u : list name := list.nil) (e : expr) (cfg : tactic.dsimp_config := {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}) : tactic expr
{M : Type u_1} [add_zero_class M] (N : add_submonoid (M × M)) (H : equivalence (λ (x y : M), (x, y) ∈ N)) : add_con M
{C : Type u} [category_theory.category C] {X Y : C} {f g : X ⟶ Y} [category_theory.limits.has_coequalizer f g] {W : C} {k l : category_theory.limits.coequalizer f g ⟶ W} (h : category_theory.limits.coequalizer.π f g ≫ k = category_theory.limits.coequalizer.π f g ≫ l) : k = l
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} {v : vitali_family μ} {f : α → set (set α)} {s : set α} (h : v.fine_subfamily_on f s) : set α
(k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype ι] (p : ι → P) (s : set ι) : finite_dimensional k ↥((affine_span k (p '' s)).direction)
{R : Type u} {S₁ : Type v} {σ : Type u_1} [comm_semiring R] [comm_semiring S₁] [algebra R S₁] (f : σ → S₁) : mv_polynomial σ R →ₐ[R] S₁
{α : Type u_1} [topological_space α] [measure_theory.measure_space α] [borel_space α] {𝕜 : Type u_2} [is_R_or_C 𝕜] (μ : measure_theory.measure α) [measure_theory.is_finite_measure μ] [compact_space α] (f g : C(α, 𝕜)) : has_inner.inner (⇑(continuous_map.to_Lp 2 μ 𝕜) f) (⇑(continuous_map.to_Lp 2 μ 𝕜) g) = ∫ (x : α), ⇑(star_ring_end 𝕜) (⇑f x) * ⇑g x ∂μ
{V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (hn : x ≠ y) (h : ∥x∥ = ∥y∥) : o.oangle y x = ↑real.pi - 2 • o.oangle (y - x) y
{α : Type u} {β : Type v} [linear_order β] {U : filter (α × α)} (z : β) (D : α → α → β) (H : ∀ (s : set (α × α)), s ∈ U ↔ ∃ (ε : β) (H : ε > z), ∀ {a b : α}, D a b < ε → (a, b) ∈ s) : U = ⨅ (ε : β) (H : ε > z), filter.principal {p : α × α | D p.fst p.snd < ε}
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {σ : equiv.perm ι} {f : ι → α} {g : ι → β} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f (⇑σ i) • g i) ≤ finset.univ.sum (λ (i : ι), f i • g i)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {E' : Type u_3} [normed_group E'] [normed_space 𝕜 E'] {H : Type u_4} [topological_space H] {H' : Type u_5} [topological_space H'] (I : model_with_corners 𝕜 E H) (I' : model_with_corners 𝕜 E' H') (M : Type u_6) [topological_space M] [charted_space H M] (M' : Type u_7) [topological_space M'] [charted_space H' M'] : Type (max u_6 u_7)
{α : Type u_1} {m : measurable_space α} (μ ν : measure_theory.measure α) [measure_theory.sigma_finite μ] [measure_theory.sigma_finite ν] : μ.have_lebesgue_decomposition ν
{f : ℝ → ℝ} (hf' : differentiable ℝ f) (hf'' : differentiable ℝ (deriv f)) (hf''_nonpos : ∀ (x : ℝ), deriv^[2] f x ≤ 0) : concave_on ℝ set.univ f
{α : Type u_1} {σ : Type u_3} {τ : Type u_4} (E : σ ≃ τ) : ctop α σ → ctop α τ
{α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} {μ : measure_theory.measure α} [fact (1 ≤ p)] [normed_space ℝ F] (hm : m ≤ m0) (hp_ne_top : p ≠ ⊤) (P : (α → F) → Prop) (h_ind : ∀ (c : F) ⦃s : set α⦄, measurable_set s → ⇑μ s < ⊤ → P (s.indicator (λ (_x : α), c))) (h_add : ∀ ⦃f g : α → F⦄, disjoint (function.support f) (function.support g) → measure_theory.mem_ℒp f p μ → measure_theory.mem_ℒp g p μ → measure_theory.strongly_measurable f → measure_theory.strongly_measurable g → P f → P g → P (f + g)) (h_closed : is_closed {f : ↥(measure_theory.Lp_meas F ℝ m p μ) | P ⇑f}) (h_ae : ∀ ⦃f g : α → F⦄, f =ᵐ[μ] g → measure_theory.mem_ℒp f p μ → P f → P g) ⦃f : α → F⦄ (hf : measure_theory.mem_ℒp f p μ) (hfm : measure_theory.ae_strongly_measurable' m f μ) : P f
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (p : tangent_bundle I H) : (charted_space.chart_at (model_prod H E) p).to_local_equiv = (equiv.sigma_equiv_prod H E).to_local_equiv
(σ : Type u_1) (R : Type u_2) : Type (max u_1 u_2)
{α : Type u_1} {n : Type u_4} [has_zero α] : 0.is_diag
{E : Type u_1} [normed_group E] {a : ℝ} {f g : ℂ → E} {l : filter ℂ} {u : ℂ → ℝ} (hBf : ∃ (c : ℝ) (H : c < a) (B : ℝ), f =O[l] λ (z : ℂ), real.exp (B * real.exp (c * |u z|))) (hBg : ∃ (c : ℝ) (H : c < a) (B : ℝ), g =O[l] λ (z : ℂ), real.exp (B * real.exp (c * |u z|))) : ∃ (c : ℝ) (H : c < a) (B : ℝ), (f - g) =O[l] λ (z : ℂ), real.exp (B * real.exp (c * |u z|))
{α : Type u} {β : Type v} [topological_space α] [compact_space α] [pseudo_metric_space β] [compact_space β] (A : set (bounded_continuous_function α β)) (closed : is_closed A) (H : ∀ (x : α) (ε : ℝ), ε > 0 → (∃ (U : set α) (H : U ∈ nhds x), ∀ (y : α), y ∈ U → ∀ (z : α), z ∈ U → ∀ (f : bounded_continuous_function α β), f ∈ A → has_dist.dist (⇑f y) (⇑f z) < ε)) : is_compact A
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} (A B C : homological_complex V c) (φ : A.hom B) (ψ : B.hom C) : A.hom C
{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pullbacks C] {W X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) (g₁ : Y ⟶ W) [category_theory.epi g₁] (g₂ : W ⟶ Z) [category_theory.mono g₂] (hg : g₁ ≫ g₂ = g) (f' : X ⟶ W) (hf : f' ≫ g₂ = f) (t : category_theory.limits.pullback_cone f g) (ht : category_theory.limits.is_limit t) : category_theory.epi t.fst
(α : Type u_1) (σ : Type u_2) : Type (max u_1 u_2)
{α : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space α} [one_le_p : fact (1 ≤ p)] [normed_space ℝ F] {hm : m ≤ m0} {s : set α} {μ : measure_theory.measure α} (hs : measurable_set s) (hμs : ⇑(μ.trim hm) s ≠ ⊤) (c : F) : ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F ℝ p μ hm).symm) (measure_theory.indicator_const_Lp p hs hμs c)) = measure_theory.indicator_const_Lp p _ _ c
{E : Type u_2} [normed_group E] [normed_space ℝ E] {a b : ℝ} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) (h : ∀ (x y : E), ∥x∥ ≤ 1 → ∥y∥ ≤ 1 → x ≠ y → ∥a • x + b • y∥ < 1) : strict_convex_space ℝ E
{n : ℕ} {F : typevec n → Type u} (R : Π ⦃α : typevec n⦄, F α → F α → Prop) [mvfunctor F] (Hfunc : ∀ ⦃α β : typevec n⦄ (a b : F α) (f : α.arrow β), R a b → R (mvfunctor.map f a) (mvfunctor.map f b)) : mvfunctor (mvqpf.quot1 R)
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D E : homological_complex V c} (f : C ⟶ D) (hom : Π (i j : ι), c.rel j i → (D.X i ⟶ E.X j)) : f ≫ homotopy.null_homotopic_map' hom = homotopy.null_homotopic_map' (λ (i j : ι) (hij : c.rel j i), f.f i ≫ hom i j hij)
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] {W X Y Z : C} (f : X ⟶ Y) (g : Z ⟶ W) : category_theory.limits.prod.map f g ≫ (category_theory.limits.prod.braiding Y W).hom = (category_theory.limits.prod.braiding X Z).hom ≫ category_theory.limits.prod.map g f
{α : Type u} [pseudo_emetric_space α] (s : set α) (hs : ∀ (ε : ennreal), ε > 0 → (∃ (t : set α), t.countable ∧ s ⊆ ⋃ (x : α) (H : x ∈ t), emetric.closed_ball x ε)) : ∃ (t : set α) (H : t ⊆ s), t.countable ∧ s ⊆ closure t
{α : Type u} [semiring α] (I : ideal α) (hI : I ≠ ⊤) : ∃ (M : ideal α), M.is_maximal ∧ I ≤ M
{ι : Type u_1} {I : box_integral.box ι} (boxes : finset (with_bot (box_integral.box ι))) (le_of_mem : ∀ (J : with_bot (box_integral.box ι)), J ∈ boxes → J ≤ ↑I) (pairwise_disjoint : ↑boxes.pairwise disjoint) : box_integral.prepartition I
{C : Type u} [category_theory.category C] (𝒯 : category_theory.limits.limit_cone (category_theory.functor.empty C)) (ℬ : Π (X Y : C), category_theory.limits.limit_cone (category_theory.limits.pair X Y)) : category_theory.monoidal_category C
(e : environment) (str : name) (trace_if_exists : bool := bool.ff) (rules : list projection_rule := list.nil) (trc : bool := bool.ff) : tactic (list name × list projection_data)
{α : Type u_1} {p : finset α → Sort u_2} {n : ℕ} (H : Π (t₁ : finset α), (Π {t₂ : finset α}, t₂.card ≤ n → t₁ ⊂ t₂ → p t₂) → t₁.card ≤ n → p t₁) (s : finset α) : s.card ≤ n → p s
{α : Type u_1} [measurable_space α] {μ ν : measure_theory.measure α} [measure_theory.is_finite_measure μ] [measure_theory.is_finite_measure ν] : ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : monovary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f (⇑σ i) • g i) = s.sum (λ (i : ι), f i • g i) ↔ monovary_on (f ∘ ⇑σ) g ↑s
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] {σ : Type u_3} [inhabited σ] : Type (max u_1 u_2 u_3)
(s : simp_lemmas × list name) (ps : list pexpr) (cfg : auto.auto_config := {use_simp := bool.tt, max_ematch_rounds := 20}) : tactic unit
{C : Type u₁} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] {W : C} (f : X ⟶ Y) [category_theory.normal_epi f] (k : X ⟶ W) (h : category_theory.normal_epi.g ≫ k = 0) : {l // f ≫ l = k}
(n : name) (r : tactic.decl_reducibility) (persistent : bool := bool.ff) : tactic unit
{I : Type u} (X : I → Top) : category_theory.limits.preserves_limit (category_theory.discrete.functor X) fundamental_groupoid.fundamental_groupoid_functor
(q : interactive.parse tactic.interactive.rw_rules) (l : interactive.parse interactive.types.location) (cfg : tactic.rewrite_cfg := {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all}) : tactic unit
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) ⦃ι : Type v⦄ (U : ι → topological_space.opens ↥X) : 𝟭 (category_theory.limits.cone ((category_theory.pairwise.diagram U).op ⋙ F)) ≅ Top.presheaf.sheaf_condition_pairwise_intersections.cone_equiv_functor F U ⋙ Top.presheaf.sheaf_condition_pairwise_intersections.cone_equiv_inverse F U
{M : Type w} {A : set M} {L : first_order.language} [L.Structure M] {α : Type u_1} {β : Type u_2} {s : set (β → M)} (h : A.definable L s) (f : α → β) [fintype α] [fintype β] : A.definable L ((λ (g : β → M), g ∘ f) '' s)
{α : Type u_1} {F : Type u_3} [normed_group F] [normed_space ℝ F] {m : measurable_space α} (μ : measure_theory.measure α) (f : measure_theory.simple_func α F) : F
(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (I : lie_ideal R L) : ℕ
{V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y : V} (h : ∥x∥ = ∥y∥) : o.oangle x (x - y) = o.oangle (y - x) y
{C : Type u} [category_theory.category C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} {t : category_theory.limits.pullback_cone f g} (ht : category_theory.limits.is_limit t) {W : C} (h : W ⟶ X) (k : W ⟶ Y) (w : h ≫ f = k ≫ g) : {l // l ≫ t.fst = h ∧ l ≫ t.snd = k}
{α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} (h : μ ≤ ν) : μ.absolutely_continuous ν
{ι : Type u} {β : ι → Type v} [dec : decidable_eq ι] [Π (i : ι), has_zero (β i)] [Π (i : ι) (x : β i), decidable (x ≠ 0)] (f : Π₀ (i : ι), β i) : finset ι
{R : Type u_1} [semiring R] {φ : power_series R} (h : φ.order.dom) : ⇑(power_series.coeff R (φ.order.get h)) φ ≠ 0
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {I : ideal R} (hI : I ≠ ⊥) : R ⧸ I ≃+* Π (P : ↥((unique_factorization_monoid.factors I).to_finset)), R ⧸ ↑P ^ multiset.count ↑P (unique_factorization_monoid.factors I)
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (h : ↑(S.topological_closure) ≠ set.univ) : ∥S.normed_mk∥ = 1
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [category_theory.limits.has_wide_equalizer f] [nonempty J] {W : C} (k : W ⟶ X) (h : ∀ (j₁ j₂ : J), k ≫ f j₁ = k ≫ f j₂) : W ⟶ category_theory.limits.wide_equalizer f
{α : Type u} [pseudo_metric_space α] {x y : α} {ε : ℝ} (h : x ∈ metric.ball y ε) : ∃ (ε' : ℝ) (H : ε' < ε), x ∈ metric.ball y ε'
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [decidable_eq ι] [fintype ι] [nondiscrete_normed_field 𝕜] [Π (i : ι), normed_group (E i)] [Π (i : ι), normed_space 𝕜 (E i)] [normed_group G] [normed_space 𝕜 G] (f : multilinear_map 𝕜 E G) {C : ℝ} (hC : 0 ≤ C) (H : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) : ∥f.mk_continuous C H∥ ≤ C
{α : Type u} [pseudo_metric_space α] {s : set α} {a : α} : a ∈ closure s ↔ ∀ (ε : ℝ), ε > 0 → (∃ (b : α) (H : b ∈ s), has_dist.dist a b < ε)
(slow : bool := bool.tt) (verbose : lint_verbosity := lint_verbosity.medium) (extra : list name := list.nil) (use_only : bool := bool.ff) : tactic (name_set × format)
{α : Type u} {β : Type v} [pseudo_metric_space α] [nonempty β] [semilattice_sup β] {u : β → α} : cauchy_seq u ↔ ∀ (ε : ℝ), ε > 0 → (∃ (N : β), ∀ (m : β), m ≥ N → ∀ (n : β), n ≥ N → has_dist.dist (u m) (u n) < ε)
{R : Type u} {σ : Type u_1} [comm_semiring R] (s : σ →₀ ℕ) : R →ₗ[R] mv_polynomial σ R
{β : Type v} {π : β → Type u_1} [fintype β] [Π (b : β), pseudo_metric_space (π b)] [h : ∀ (b : β), proper_space (π b)] : proper_space (Π (b : β), π b)
{V : Type u_1} [inner_product_space ℝ V] (x y : V) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ inner_product_geometry.angle x y = real.pi / 2
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {f g : α → ℝ} {s : set α} [measure_theory.sigma_finite μ] (hf : ae_measurable f (μ.restrict s)) (hg : ae_measurable g (μ.restrict s)) (hs : measurable_set s) : ⇑(μ.prod measure_theory.measure_space.volume) (region_between f g s) = ∫⁻ (y : α) in s, ennreal.of_real ((g - f) y) ∂μ
{α : Type u} {C : free_semigroup α → Sort l} (x : free_semigroup α) (ih1 : Π (x : α), C (free_semigroup.of x)) (ih2 : Π (x : α) (y : free_semigroup α), C (free_semigroup.of x) → C y → C (free_semigroup.of x * y)) : C x
{J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {t : category_theory.limits.cone F} (h : category_theory.limits.is_limit t) (W : C) : ulift (W ⟶ t.X) ≅ (category_theory.functor.const J).obj W ⟶ F
{V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G ≃g G') : G' ≃g G
(𝕜 : Type u_1) (E : Type u_4) [semi_normed_group E] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] {v : E} (hv : ∥v∥ = 1) : 𝕜 →ₗᵢ[𝕜] E
{𝕜 : Type u} [nondiscrete_normed_field 𝕜] {F : Type v} [normed_group F] [normed_space 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {s : set 𝕜} {f' : F} : has_deriv_within_at f f' s x ↔ has_fderiv_within_at f (1.smul_right f') s x
{ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [fintype ι] (f : (smooth_bump_covering ι I M)) : ∃ (n : ℕ) (e : M → euclidean_space ℝ (fin n)), smooth I (model_with_corners_self ℝ (euclidean_space ℝ (fin n))) e ∧ function.injective e ∧ ∀ (x : M), function.injective ⇑(mfderiv I (model_with_corners_self ℝ (euclidean_space ℝ (fin n))) e x)
{ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [sigma_compact_space M] {s : set M} (hs : is_closed s) (U : ι → set M) (ho : ∀ (i : ι), is_open (U i)) (hU : s ⊆ ⋃ (i : ι), U i) : ∃ (f : smooth_partition_of_unity ι I M s), f.is_subordinate U
{P : Type u → Sort v} (of_equiv : Π {α β : Type u}, α ≃ β → P α → P β) (h_empty : P pempty) (h_option : Π {α : Type u} [_inst_1 : fintype α] [_inst_2 : decidable_eq α], P α → P (option α)) (α : Type u) [fintype α] [decidable_eq α] : trunc (P α)
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [category_theory.limits.has_wide_coequalizer f] [nonempty J] {W : C} (k : Y ⟶ W) (h : ∀ (j₁ j₂ : J), f j₁ ≫ k = f j₂ ≫ k) : category_theory.limits.wide_coequalizer f ⟶ W
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) (M : Type u_4) [topological_space M] [charted_space H M] : set (local_homeomorph M H)
{n : ℕ} (α : typevec n) {β γ : Type u_1} (r : β → γ → Prop) ⦃i : fin2 (n + 1)⦄ : (α ::: β) i → (α ::: γ) i → Prop
{α : Type u_1} {E : Type u_2} {ι : Type u_3} [preorder ι] {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] [has_le E] (f : ι → α → E) (ℱ : measure_theory.filtration ι m0) (μ : measure_theory.measure α) : Prop
{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] {cM : con M} {cN : con N} {φ : cM.quotient → cN.quotient → Sort u_3} (a : cM.quotient) (b : cN.quotient) (f : Π (x : M) (y : N), φ ↑x ↑y) (h : ∀ (x : M) (y : N) (x' : M) (y' : N), ⇑cM x x' → ⇑cN y y' → f x y == f x' y') : φ a b
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group β] {p : ennreal} {f : ι → α → β} [measure_theory.is_finite_measure μ] (hp : 1 ≤ p) (hp' : p ≠ ⊤) : measure_theory.uniform_integrable f p μ ↔ (∀ (i : ι), measure_theory.strongly_measurable (f i)) ∧ ∀ (ε : ℝ), 0 < ε → (∃ (C : nnreal), ∀ (i : ι), measure_theory.snorm ({x : α | C ≤ ∥f i x∥₊}.indicator (f i)) p μ ≤ ennreal.of_real ε)
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] : Prop
{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (f : R →+* S) (s : set R) : subsemiring.map f (subsemiring.closure s) = subsemiring.closure (⇑f '' s)
(𝕜 : Type v) [is_R_or_C 𝕜] {E : Type u} [normed_group E] [normed_space 𝕜 E] (x : E) : ∃ (g : E →L[𝕜] 𝕜), ∥g∥ ≤ 1 ∧ ⇑g x = ↑∥x∥
{M : Type w} {A : set M} {L : first_order.language} [L.Structure M] {α : Type u_1} {β : Type u_2} {s : set (β → M)} (h : A.definable L s) (f : α ↪ β) [fintype β] : A.definable L ((λ (g : β → M), g ∘ ⇑f) '' s)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] {μ : measure_theory.measure α} [topological_space β] [topological_space γ] [measurable_space β] [topological_space.pseudo_metrizable_space β] [borel_space β] [measurable_space γ] [topological_space.pseudo_metrizable_space γ] [opens_measurable_space γ] [topological_space.second_countable_topology γ] (g : β → γ) (hg : measurable g) (f : α →ₘ[μ] β) : α →ₘ[μ] γ
{C : Type u₁} (W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] [category_theory.enriched_category W C] (X : C) : category_theory.forget_enrichment W C
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] (μ : measure_theory.measure α) (f : α → E) : E
{X : Type u_1} {Y : Type u_2} [topological_space X] {m : measurable_space X} [topological_space Y] [t2_space Y] {μ : measure_theory.measure X} [μ.is_open_pos_measure] {U : set X} {f g : X → Y} (h : f =ᵐ[μ.restrict U] g) (hU : is_open U) (hf : continuous_on f U) (hg : continuous_on g U) : set.eq_on f g U
{p : ℕ+} {k : ℕ} {K : Type u} [field K] [char_zero K] {ζ : K} [hp : fact (nat.prime ↑p)] [is_cyclotomic_extension {p ^ k} ℚ K] (hζ : is_primitive_root ζ ↑(p ^ k)) : ∃ (u : ℤˣ) (n : ℕ), algebra.discr ℚ ⇑((is_primitive_root.sub_one_power_basis ℚ hζ).basis) = ↑u * ↑p ^ n
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : antivary f g) : finset.univ.sum (λ (i : ι), f i * g i) ≤ finset.univ.sum (λ (i : ι), f (⇑σ i) * g i)
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} (f : ↥(measure_theory.Lp.simple_func ℝ 1 μ)) : ↥(measure_theory.Lp.simple_func ℝ 1 μ)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] (I : model_with_corners 𝕜 E H) (R : Type u_4) [semiring R] [topological_space R] [charted_space H R] : Prop
{𝕜 : Type u_1} [is_R_or_C 𝕜] {μ : measure_theory.measure ℝ} {E : Type u_2} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {a b ε : ℝ} {bound : ℝ → ℝ} {F F' : 𝕜 → ℝ → E} {x₀ : 𝕜} (ε_pos : 0 < ε) (hF_meas : ∀ᶠ (x : 𝕜) in nhds x₀, measure_theory.ae_strongly_measurable (F x) (μ.restrict (set.interval_oc a b))) (hF_int : interval_integrable (F x₀) μ a b) (hF'_meas : measure_theory.ae_strongly_measurable (F' x₀) (μ.restrict (set.interval_oc a b))) (h_bound : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → ∀ (x : 𝕜), x ∈ metric.ball x₀ ε → ∥F' x t∥ ≤ bound t) (bound_integrable : interval_integrable bound μ a b) (h_diff : ∀ᵐ (t : ℝ) ∂μ, t ∈ set.interval_oc a b → ∀ (x : 𝕜), x ∈ metric.ball x₀ ε → has_deriv_at (λ (x : 𝕜), F x t) (F' x t) x) : interval_integrable (F' x₀) μ a b ∧ has_deriv_at (λ (x : 𝕜), ∫ (t : ℝ) in a..b, F x t ∂μ) (∫ (t : ℝ) in a..b, F' x₀ t ∂μ) x₀
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [normed_group E] [normed_space ℝ E] [normed_space 𝕜 E] [complete_space E] {H : Type u_4} [normed_group H] [normed_space 𝕜 H] {F : H → α → E} {F' : H → α → (H →L[𝕜] E)} {x₀ : H} {bound : α → ℝ} {ε : ℝ} (ε_pos : 0 < ε) (hF_meas : ∀ᶠ (x : H) in nhds x₀, measure_theory.ae_strongly_measurable (F x) μ) (hF_int : measure_theory.integrable (F x₀) μ) (hF'_meas : measure_theory.ae_strongly_measurable (F' x₀) μ) (h_bound : ∀ᵐ (a : α) ∂μ, ∀ (x : H), x ∈ metric.ball x₀ ε → ∥F' x a∥ ≤ bound a) (bound_integrable : measure_theory.integrable bound μ) (h_diff : ∀ᵐ (a : α) ∂μ, ∀ (x : H), x ∈ metric.ball x₀ ε → has_fderiv_at (λ (x : H), F x a) (F' x a) x) : has_fderiv_at (λ (x : H), ∫ (a : α), F x a ∂μ) (∫ (a : α), F' x₀ a ∂μ) x₀
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] {μ : measure_theory.measure α} [topological_space β] [topological_space γ] (g : β → γ) (hg : continuous g) (f : α →ₘ[μ] β) : α →ₘ[μ] γ
{α : Type u_1} {m0 : measurable_space α} {μ ν : measure_theory.measure α} : μ.absolutely_continuous ν → μ.ae ≤ ν.ae
{n : ℕ} (i : fin2 n) ⦃α : typevec n⦄ : (mvqpf.prj.P i).obj α → mvqpf.prj i α
(elaborated : bool := bool.tt) : Type
{F : Type u_3} [inner_product_space ℝ F] {x y : F} : ∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * has_inner.inner x y + ∥y∥ ^ 2
{R : Type u} [comm_semiring R] {I J : ideal R} : I ∣ J → J ≤ I
{R : Type u_1} [semiring R] {ι : Type u_4} {φ : ι → Type u_5} [Π (i : ι), topological_space (φ i)] [Π (i : ι), add_comm_monoid (φ i)] [Π (i : ι), module R (φ i)] (i : ι) : (Π (i : ι), φ i) →L[R] φ i
{J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J → (X ⟶ Y)} [category_theory.limits.has_wide_equalizer f] [nonempty J] {W : C} {k l : W ⟶ category_theory.limits.wide_equalizer f} (h : k ≫ category_theory.limits.wide_equalizer.ι f = l ≫ category_theory.limits.wide_equalizer.ι f) : k = l
{k : Type u_1} {G : Type u_2} {V : Type u_3} {W : Type u_4} [comm_semiring k] [monoid G] [add_comm_monoid V] [module k V] [add_comm_monoid W] [module k W] (ρV : representation k G V) (ρW : representation k G W) : representation k G (tensor_product k V W)
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mul₂ G] (μ ν : measure_theory.measure G) [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] [μ.is_mul_left_invariant] : measure_theory.measure.map (λ (z : G × G), (z.snd, z.snd * z.fst)) (μ.prod ν) = ν.prod μ
{G : Type u_1} [measurable_space G] [add_group G] [topological_space G] (μ : measure_theory.measure G) [μ.is_add_haar_measure] [sigma_compact_space G] : measure_theory.sigma_finite μ
{c d : Type u → Type v} (f : Π {α : Type u}, c α → d α) (b : category_theory.bundled c) : category_theory.bundled d
{J : Type u₁} [category_theory.category J] {C : Type u₃} [category_theory.category C] {F : J ⥤ C} {t : category_theory.limits.cone F} (h : category_theory.limits.is_limit t) (W : C) : ulift (W ⟶ t.X) ≅ {p // ∀ {j j' : J} (f : j ⟶ j'), p j ≫ F.map f = p j'}
{V W : SemiNormedGroup} [complete_space ↥W] [separated_space ↥W] (f : V ⟶ W) : SemiNormedGroup.Completion.obj V ⟶ W
(f : Type u → Type v → Type w) (hf : Π (α β : Type u) (γ δ : Type v), α ≃ β → γ ≃ δ → f α γ ≃ f β δ) : cardinal → cardinal → cardinal
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} {g : E → ℝ} [measure_theory.is_finite_measure μ] (hg : strict_convex_on ℝ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) (hgi : measure_theory.integrable (g ∘ f) μ) : f =ᵐ[μ] function.const α (⨍ (x : α), f x ∂μ) ∨ g (⨍ (x : α), f x ∂μ) < ⨍ (x : α), g (f x) ∂μ
{α : Type u_1} [measurable_space α] [topological_space α] [opens_measurable_space α] (μ : measure_theory.finite_measure α) {fs : ℕ → bounded_continuous_function α nnreal} {c : nnreal} (fs_le_const : ∀ (n : ℕ) (a : α), ⇑(fs n) a ≤ c) {f : α → nnreal} (fs_lim : ∀ (a : α), filter.tendsto (λ (n : ℕ), ⇑(fs n) a) filter.at_top (nhds (f a))) : filter.tendsto (λ (n : ℕ), ∫⁻ (a : α), ↑(⇑(fs n) a) ∂↑μ) filter.at_top (nhds (∫⁻ (a : α), ↑(f a) ∂↑μ))
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] [smooth_manifold_with_corners I M] [smooth_manifold_with_corners I' M'] (f : M → M') (s : set M) : tangent_bundle I M → tangent_bundle I' M'
(s : simp_lemmas) (e : expr) (md : tactic.transparency := tactic.transparency.reducible) : tactic expr
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} {μ : measure_theory.measure α} [normed_group E] (f : ↥(measure_theory.Lp E p μ)) (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ⊤) (ε : ennreal) : ε ^ p.to_real * ⇑μ {x : α | ε ≤ ↑∥⇑f x∥₊} ≤ ennreal.of_real ∥f∥ ^ p.to_real
{σ : Type u_1} {f : σ → option σ} {b : σ} {C : σ → Sort u_2} {a : σ} (h : b ∈ turing.eval f a) (H : Π (a : σ), b ∈ turing.eval f a → (Π (a' : σ), f a = option.some a' → C a') → C a) : C a
{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s t : set α} (Hf : antitone_on f t) (Hst : s ⊆ t) : (upper_bounds s ∩ t).nonempty → bdd_below (f '' s)
(ns : name) (α : Type) [reflected α] [has_reflect α] (s : tactic.local_cache.internal.cache_scope := tactic.local_cache.cache_scope.block_local) : tactic (option α)
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] {I : ideal R} (J : ideal S) (f : R →+* S) (hIJ : I ≤ ideal.comap f J) : R ⧸ I →+* S ⧸ J
{α : Sort u_1} {β : Sort u_2} {ra : α → α → Prop} {rb : β → β → Prop} {φ : quot ra → quot rb → Sort u_3} (qa : quot ra) (qb : quot rb) (f : Π (a : α) (b : β), φ (quot.mk ra a) (quot.mk rb b)) (ca : ∀ {b : β} {a₁ a₂ : α}, ra a₁ a₂ → f a₁ b == f a₂ b) (cb : ∀ {a : α} {b₁ b₂ : β}, rb b₁ b₂ → f a b₁ == f a b₂) : φ qa qb
{P : Type u_1} [preorder P] (I : order.ideal P) : Prop
{α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] {μ : measure_theory.measure α} [μ.weakly_regular] (f : α → nnreal) (int_f : ∫⁻ (x : α), ↑(f x) ∂μ ≠ ⊤) {ε : ennreal} (ε0 : ε ≠ 0) : ∃ (g : α → nnreal), (∀ (x : α), g x ≤ f x) ∧ upper_semicontinuous g ∧ ∫⁻ (x : α), ↑(f x) ∂μ ≤ ∫⁻ (x : α), ↑(g x) ∂μ + ε
(α : Type u_1) (β : Type u_2) [measurable_space α] [topological_space β] (μ : measure_theory.measure α) : Type (max u_1 u_2)
{R : Type u_1} {R₂ : Type u_2} {E : Type u_5} {E₂ : Type u_6} [semiring R] [semiring R₂] {σ₁₂ : R →+* R₂} {σ₂₁ : R₂ →+* R} [ring_hom_inv_pair σ₁₂ σ₂₁] [ring_hom_inv_pair σ₂₁ σ₁₂] [semi_normed_group E] [semi_normed_group E₂] [module R E] [module R₂ E₂] (e : E ≃ₛₗ[σ₁₂] E₂) (h₁ : ∀ (x : E), ∥⇑e x∥ ≤ ∥x∥) (h₂ : ∀ (y : E₂), ∥⇑(e.symm) y∥ ≤ ∥y∥) : E ≃ₛₗᵢ[σ₁₂] E₂
{α : Type u_1} {m : measurable_space α} (μ ν : measure_theory.measure α) : Prop
(𝕜 : Type u) {A : Type v} [field 𝕜] [ring A] [algebra 𝕜 A] [is_alg_closed 𝕜] [nontrivial A] [I : finite_dimensional 𝕜 A] (a : A) : ∃ (k : 𝕜), k ∈ spectrum 𝕜 a
{σ : Type u} {m : Type u → Type v} [monad m] [monad_state σ m] : m σ
{α : Type u_1} (f : α → α) (x : α) : function.periodic_orbit f x = ↑(list.map (λ (n : ℕ), f^[n] x) (list.range (function.minimal_period f x)))
{α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {m m0 : measurable_space α} {μ : measure_theory.measure α} {f : α → F'} {s : set α} (hm : m ≤ m0) [measure_theory.sigma_finite (μ.trim hm)] (hf : measure_theory.integrable f μ) (hs : measurable_set s) : ∫ (x : α) in s, measure_theory.condexp m μ f x ∂μ = ∫ (x : α) in s, f x ∂μ
{ι : Type u_1} {α : Type u_2} {β : Type u_3} [linear_ordered_ring α] [linear_ordered_add_comm_group β] [module α β] [ordered_smul α β] {s : finset ι} {σ : equiv.perm ι} {f : ι → α} {g : ι → β} (hfg : antivary_on f g ↑s) (hσ : {x : ι | ⇑σ x ≠ x} ⊆ ↑s) : s.sum (λ (i : ι), f i • g (⇑σ i)) = s.sum (λ (i : ι), f i • g i) ↔ antivary_on f (g ∘ ⇑σ) ↑s
{n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} {β : Type u} (g : Π {X : Type u}, (β → X) → F (α ::: X)) (x : β) : mvqpf.cofix F α
{L : first_order.language} {α : Type u'} {β : Type v'} [decidable_eq α] {n : ℕ} (φ : L.bounded_formula α n) (f : ↥(φ.free_var_finset) → β) : L.bounded_formula β n
{α : Sort u} {β : Sort v} {W : α → Sort w} {Z : β → Sort z} (h₁ : α ≃ β) (h₂ : Π (a : α), W a ≃ Z (⇑h₁ a)) : (Π (a : α), W a) ≃ Π (b : β), Z b
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : α → ennreal} (hf : ae_measurable f μ) (ε : ennreal) : ε * ⇑μ {x : α | ε ≤ f x} ≤ ∫⁻ (a : α), f a ∂μ
{ι : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis ι R M) {R₁ : Type u_9} [semiring R₁] {σ : R →+* R₁} {σ' : R₁ →+* R} [ring_hom_inv_pair σ σ'] [ring_hom_inv_pair σ' σ] {M₁ : Type u_10} [add_comm_monoid M₁] [module R₁ M₁] {f₁ f₂ : M ≃ₛₗ[σ] M₁} (h : ∀ (i : ι), ⇑f₁ (⇑b i) = ⇑f₂ (⇑b i)) : f₁ = f₂
{α : Type u_1} {E : Type u_4} [measurable_space α] [normed_group E] {p : ennreal} {μ : measure_theory.measure α} [fact (1 ≤ p)] (hp_ne_top : p ≠ ⊤) (P : ↥(measure_theory.Lp E p μ) → Prop) (h_ind : ∀ (c : E) {s : set α} (hs : measurable_set s) (hμs : ⇑μ s < ⊤), P ↑(measure_theory.Lp.simple_func.indicator_const p hs _ c)) (h_add : ∀ ⦃f g : α → E⦄ (hf : measure_theory.mem_ℒp f p μ) (hg : measure_theory.mem_ℒp g p μ), disjoint (function.support f) (function.support g) → P (measure_theory.mem_ℒp.to_Lp f hf) → P (measure_theory.mem_ℒp.to_Lp g hg) → P (measure_theory.mem_ℒp.to_Lp f hf + measure_theory.mem_ℒp.to_Lp g hg)) (h_closed : is_closed {f : ↥(measure_theory.Lp E p μ) | P f}) (f : ↥(measure_theory.Lp E p μ)) : P f
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} [complete_space F] : box_integral.integrable I l f vol ↔ ∀ (ε : ℝ), ε > 0 → (∃ (r : nnreal → (ι → ℝ) → ↥(set.Ioi 0)), (∀ (c : nnreal), l.r_cond (r c)) ∧ ∀ (c₁ c₂ : nnreal) (π₁ π₂ : box_integral.tagged_prepartition I), l.mem_base_set I c₁ (r c₁) π₁ → π₁.is_partition → l.mem_base_set I c₂ (r c₂) π₂ → π₂.is_partition → has_dist.dist (box_integral.integral_sum f vol π₁) (box_integral.integral_sum f vol π₂) ≤ ε)
(I : Type u_1) (A : Type u_2) (m : I → Type u_3) [ring A] [topological_space A] [topological_ring A] [Π (i : I), fintype (m i)] : topological_ring (Π (i : I), matrix (m i) (m i) A)
{ι : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {I : box_integral.box ι} {π : box_integral.tagged_prepartition I} [fintype ι] {l : box_integral.integration_params} {f : (ι → ℝ) → E} {vol : box_integral.box_additive_map ι (E →L[ℝ] F) ⊤} {c : nnreal} {ε : ℝ} [complete_space F] (h : box_integral.integrable I l f vol) (h0 : 0 < ε) (hπ : l.mem_base_set I c (h.convergence_r ε c) π) : has_dist.dist (box_integral.integral_sum f vol π) (π.to_prepartition.boxes.sum (λ (J : box_integral.box ι), box_integral.integral J l f vol)) ≤ ε
(R : Type u) {ι : Type x} {ι' : Type x'} [semiring R] (φ : ι → Type u_1) [Π (i : ι), add_comm_monoid (φ i)] [Π (i : ι), module R (φ i)] (e : ι' ≃ ι) : (Π (i' : ι'), φ (⇑e i')) ≃ₗ[R] Π (i : ι), φ i
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) [category_theory.limits.has_product I.left] [category_theory.limits.has_product I.right] : category_theory.limits.multifork I ≌ category_theory.limits.fork I.fst_pi_map I.snd_pi_map
{α : Type u_1} [topological_space α] [t2_space α] {f : α → α} {x y : α} (hy : filter.tendsto (λ (n : ℕ), f^[n] x) filter.at_top (nhds y)) (hf : continuous_at f y) : function.is_fixed_pt f y
{R : Type u_1} [comm_ring R] (S : submonoid R) {P : Type u_2} [comm_ring P] [algebra R P] (I : submodule R P) : Prop
{α : Type u_1} {β : Type u_2} {M : Type u_5} [has_zero M] (f : α → β) (hif : set.inj_on f (f ⁻¹' ↑(0.support)) := _) : finsupp.comap_domain f 0 hif = 0
{E : Type u_1} [normed_group E] [normed_space ℝ E] [measurable_space E] [borel_space E] [finite_dimensional ℝ E] (μ : measure_theory.measure E) [μ.is_add_haar_measure] {s : set E} (hs : convex ℝ s) : measure_theory.null_measurable_set s μ
{R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] {I I' : R →+* R} [nontrivial R] {B : M →ₛₗ[I] M →ₛₗ[I'] R} {v : basis n R M} (h : B.is_Ortho ⇑v) (hB : B.separating_left) (i : n) : ¬B.is_ortho (⇑v i) (⇑v i)
{J : Type u₁} [category_theory.category J] {C : Type u} [category_theory.category C] (F : J ⥤ C) [category_theory.limits.has_limit F] (W : C) : ulift (W ⟶ category_theory.limits.limit F) ≅ {p // ∀ {j j' : J} (f : j ⟶ j'), p j ≫ F.map f = p j'}
{α : Type u_1} {β : Type u_2} [measurable_space α] {μ : measure_theory.measure α} [topological_space β] : has_coe_to_fun (α →ₘ[μ] β) (λ (_x : α →ₘ[μ] β), α → β)
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) ⦃ι : Type v⦄ (U : ι → topological_space.opens ↥X) (c : category_theory.limits.cone ((category_theory.pairwise.diagram U).op ⋙ F)) : category_theory.limits.cone (Top.presheaf.sheaf_condition_equalizer_products.diagram F U)
(z : upper_half_plane) {cd : fin 2 → ℤ} (hcd : is_coprime (cd 0) (cd 1)) : ∃ (g : matrix.special_linear_group (fin 2) ℤ), ↑g 1 = cd ∧ ∀ (g' : matrix.special_linear_group (fin 2) ℤ), ↑g 1 = ↑g' 1 → |(g • z).re| ≤ |(g' • z).re|
{ι : Type u_1} {α : Type u_2} {m0 : measurable_space α} {μ : measure_theory.measure α} [encodable ι] {s : ι → set α} (h : ∀ (i : ι), measure_theory.null_measurable_set (s i) μ) (hd : pairwise (measure_theory.ae_disjoint μ on s)) : ∃ (t : ι → set α), (∀ (i : ι), t i ⊆ s i) ∧ (∀ (i : ι), s i =ᵐ[μ] t i) ∧ (∀ (i : ι), measurable_set (t i)) ∧ pairwise (disjoint on t)
(R : Type u) [semiring R] {ι : Type v} [dec_ι : decidable_eq ι] {M : ι → Type w} [Π (i : ι), add_comm_monoid (M i)] [Π (i : ι), module R (M i)] {N : Type u₁} [add_comm_monoid N] [module R N] ⦃ψ ψ' : direct_sum ι (λ (i : ι), M i) →ₗ[R] N⦄ (H : ∀ (i : ι), ψ.comp (direct_sum.lof R ι M i) = ψ'.comp (direct_sum.lof R ι M i)) : ψ = ψ'
{α : Type u_1} (f : α → α) (x : α) : function.periodic_orbit f x = cycle.map (λ (n : ℕ), f^[n] x) ↑(list.range (function.minimal_period f x))
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {s : set E} {f' : E →L[𝕜] F} {x : E} (h : has_fderiv_within_at f f' s x) : set.maps_to ⇑f' (tangent_cone_at 𝕜 s x) (tangent_cone_at 𝕜 (f '' s) (f x))
{M : Type w} {A : set M} {L : first_order.language} [L.Structure M] {α : Type u_1} (m : ℕ) {s : set (α ⊕ fin m → M)} (h : A.definable L s) : A.definable L ((λ (g : α ⊕ fin m → M), g ∘ sum.inl) '' s)
{α : Type u} [pseudo_metric_space α] {x : α} {ε : nnreal} : emetric.ball x ↑ε = metric.ball x ↑ε
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {f' : α → E'} {g' : α → F'} {l : filter α} : ((λ (x : α), ∥f' x∥) =O[l] λ (x : α), ∥g' x∥) → f' =O[l] g'
{𝕜 : Type u_1} {E : Type u_4} {Fₗ : Type u_7} [normed_group E] [normed_group Fₗ] [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 Fₗ] (c : E →L[𝕜] 𝕜) (f : Fₗ) : ∥c.smul_right f∥ = ∥c∥ * ∥f∥
{P : Type u_1} [has_le P] (I : order.ideal P) : Prop
{α : Sort u_1} {β : Sort u_2} {s₁ : setoid α} {s₂ : setoid β} {φ : quotient s₁ → quotient s₂ → Sort u_3} (qa : quotient s₁) (qb : quotient s₂) (f : Π (a : α) (b : β), φ (quotient.mk' a) (quotient.mk' b)) (c : ∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ == f a₂ b₂) : φ qa qb
{α : Type u_1} {𝕜 : Type u_14} [normed_field 𝕜] {l : filter α} {u v : α → 𝕜} : u =o[l] v → (∃ (φ : α → 𝕜) (hφ : filter.tendsto φ l (nhds 0)), u =ᶠ[l] φ * v)
{γ : Type w} [emetric_space γ] {x y : γ} (h : ∀ (ε : ennreal), ε > 0 → has_edist.edist x y ≤ ε) : x = y
(f : C(↥unit_interval, ℝ)) (ε : ℝ) (h : 0 < ε) (n : ℕ) (x : ↥unit_interval) : finset (fin (n + 1))
{E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) {s : set M} (hsc : is_closed s) (hs : s ⊆ function.support ⇑f) : ∃ (r : ℝ) (hr : r ∈ set.Ioo 0 f.to_cont_diff_bump.to_cont_diff_bump_of_inner.R), s ⊆ (charted_space.chart_at H c).to_local_equiv.source ∩ ⇑(ext_chart_at I c) ⁻¹' euclidean.ball (⇑(ext_chart_at I c) c) r
 : 0.prod = 1
{G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {μ : measure_theory.measure G} [group G] [topological_group G] [μ.is_mul_left_invariant] (K : set G) (hK : is_compact K) (h : ⇑μ K ≠ 0) : μ.is_open_pos_measure
{𝕜 : Type u} [nondiscrete_normed_field 𝕜] {E : Type v} [normed_group E] [normed_space 𝕜 E] [complete_space 𝕜] {c : 𝕜} (hc : 1 < ∥c∥) {R : ℝ} (hR : ∥c∥ < R) (h : ¬finite_dimensional 𝕜 E) (s : finset E) : ∃ (x : E), ∥x∥ ≤ R ∧ ∀ (y : E), y ∈ s → 1 ≤ ∥y - x∥
{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D E : homological_complex V c} (hom : Π (i j : ι), c.rel j i → (C.X i ⟶ D.X j)) (g : D ⟶ E) : homotopy.null_homotopic_map' hom ≫ g = homotopy.null_homotopic_map' (λ (i j : ι) (hij : c.rel j i), hom i j hij ≫ g.f j)
(R : Type u) (σ : Type u_1) [comm_semiring R] [he : is_empty σ] : mv_polynomial σ R ≃ₐ[R] R
{ι : Type v} [preorder ι] (G : ι → Type w) [nonempty ι] [is_directed ι has_le.le] [Π (i : ι), field (G i)] (f : Π (i j : ι), i ≤ j → G i → G j) (p : ring.direct_limit G f) : ring.direct_limit G f
{C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {X : C} {S : J.cover X} {T : Π (I : S.arrow), J.cover I.Y} (I : (S.bind T).arrow) : I.middle ⟶ X
(cfg : tactic.apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}) : state_t tactic.ext_state tactic unit
{I : Type w₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] (X : Σ (i : I), C i) : category_theory.sigma.sigma_hom X X
(α : Type u) (β : Type v) [add_group α] [add_action α β] {φ : quotient (add_action.orbit_rel α β) → β} (hφ : function.right_inverse φ quotient.mk') : β ≃ Σ (ω : quotient (add_action.orbit_rel α β)), ↥(add_action.orbit α (φ ω))
{ι : Type u_1} {α : Type u_2} [linear_ordered_ring α] {σ : equiv.perm ι} {f g : ι → α} [fintype ι] (hfg : monovary f g) : finset.univ.sum (λ (i : ι), f i * g (⇑σ i)) = finset.univ.sum (λ (i : ι), f i * g i) ↔ monovary f (g ∘ ⇑σ)
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] [nontrivial E] {T : E →ₗ[𝕜] E} (hT : inner_product_space.is_self_adjoint T) : module.End.has_eigenvalue T (↑⨅ (x : {x // x ≠ 0}), ⇑is_R_or_C.re (has_inner.inner (⇑T ↑x) ↑x) / ∥↑x∥ ^ 2)
{α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {m m0 : measurable_space α} {μ : measure_theory.measure α} {f : α → F'} {s : set α} (hf_int : measure_theory.integrable f μ) (hs : measurable_set s) : measure_theory.condexp m μ (s.indicator f) =ᵐ[μ] s.indicator (measure_theory.condexp m μ f)
{α : Type u_1} {β : Type u_2} [measurable_space β] {m0 : measurable_space α} (f : measure_theory.outer_measure α →ₗ[ennreal] measure_theory.outer_measure β) (hf : ∀ (μ : measure_theory.measure α), _inst_1 ≤ (⇑f μ.to_outer_measure).caratheodory) : measure_theory.measure α →ₗ[ennreal] measure_theory.measure β
{ι : Type v} {α : ι → Type u} {δ : Π (i : ι), α i → Type w} [Π (i : ι) (j : α i), add_comm_monoid (δ i j)] : direct_sum (Σ (i : ι), α i) (λ (i : Σ (i : ι), α i), δ i.fst i.snd) →+ direct_sum ι (λ (i : ι), direct_sum (α i) (λ (j : α i), δ i j))
{α : Type u_1} {G : Type u_8} [normed_group G] {m m0 : measurable_space α} {μ : measure_theory.measure α} {s : set α} [normed_space ℝ G] (hm : m ≤ m0) [measure_theory.sigma_finite (μ.trim hm)] (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) (x : G) : measure_theory.integrable ⇑(measure_theory.condexp_ind_smul hm hs hμs x) μ
(L : first_order.language) (ι : Type v) [preorder ι] (G : ι → Type w) [Π (i : ι), L.Structure (G i)] (f : Π (i j : ι), i ≤ j → L.embedding (G i) (G j)) [is_directed ι has_le.le] [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f i j h))] [nonempty ι] (i : ι) : L.embedding (G i) (first_order.language.direct_limit G f)
{α : Type u_1} {E : Type u_2} {m0 : measurable_space α} [normed_group E] [normed_space ℝ E] [complete_space E] {μ : measure_theory.measure α} {s : set E} {f : α → E} [measure_theory.is_finite_measure μ] (hs : convex ℝ s) (hsc : is_closed s) (hμ : μ ≠ 0) (hfs : ∀ᵐ (x : α) ∂μ, f x ∈ s) (hfi : measure_theory.integrable f μ) : ⨍ (x : α), f x ∂μ ∈ s
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : M → M') (s : set M) : Prop
{R : Type u} [ring R] {ι : Type v} [dec_ι : decidable_eq ι] [preorder ι] {G : ι → Type w} [Π (i : ι), add_comm_group (G i)] [Π (i : ι), module R (G i)] {f : Π (i j : ι), i ≤ j → (G i →ₗ[R] G j)} [nonempty ι] [is_directed ι has_le.le] (z : module.direct_limit G f) : ∃ (i : ι) (x : G i), ⇑(module.direct_limit.of R ι G f i) x = z
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space 𝕜 E] {H' : Type u_5} [topological_space H'] {E' : Type u_6} [normed_group E'] [normed_space 𝕜 E'] (I : model_with_corners 𝕜 E H) (I' : model_with_corners 𝕜 E' H') (G : Type u_8) [topological_space G] [charted_space H G] [add_monoid G] [has_smooth_add I G] (G' : Type u_9) [topological_space G'] [charted_space H' G'] [add_monoid G'] [has_smooth_add I' G'] : Type (max u_8 u_9)
(trace : interactive.parse (optional (lean.parser.tk "?"))) (cfg : tactic.tidy.cfg := {trace_result := bool.ff, trace_result_prefix := "Try this: ", tactics := tactic.tidy.default_tactics}) : tactic unit
{α : Type u_1} {E : Type u_2} (𝕜 : Type u_4) [is_R_or_C 𝕜] [measurable_space α] {μ : measure_theory.measure α} [inner_product_space 𝕜 E] {s : set α} (f : ↥(measure_theory.Lp E 2 μ)) (hs : measurable_set s) (c : E) (hμs : ⇑μ s ≠ ⊤) : has_inner.inner (measure_theory.indicator_const_Lp 2 hs hμs c) f = ∫ (x : α) in s, has_inner.inner c (⇑f x) ∂μ
{V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = 0) : has_dist.dist p1 p3 = |has_dist.dist p1 p2 - has_dist.dist p3 p2|
(σ : Type u_1) {R : Type u_2} {S : Type u_3} [semiring R] [semiring S] (f : R →+* S) : mv_power_series σ R →+* mv_power_series σ S
{α : Type u} {σ : Type v} (M : NFA α σ) : DFA α (set σ)
{F : Type u_3} [inner_product_space ℝ F] (x y : F) : has_inner.inner x y / (∥x∥ * ∥y∥) = -1 ↔ x ≠ 0 ∧ ∃ (r : ℝ), r < 0 ∧ y = r • x
{𝕜 : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G → E} {g : G → E'} {x : G} [nondiscrete_normed_field 𝕜] [normed_space 𝕜 E] [normed_space 𝕜 E'] [normed_space 𝕜 F] (L : E →L[𝕜] E' →L[𝕜] F) [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ F] [complete_space F] [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [μ.is_add_left_invariant] [μ.is_neg_invariant] : convolution f g L μ x = ∫ (t : G), ⇑(⇑L (f (x - t))) (g t) ∂μ
{α : Type u} (r : α → α → Prop) [is_strict_total_order' α r] [Π (x y : α), decidable (¬r x y)] : linear_order α
{ι : Type u_1} {R : Type u} [comm_ring R] {s : finset ι} {f : ι → ideal R} (a b : ι) (hp : ∀ (i : ι), i ∈ s → i ≠ a → i ≠ b → (f i).is_prime) {I : ideal R} : (↑I ⊆ ⋃ (i : ι) (H : i ∈ ↑s), ↑(f i)) ↔ ∃ (i : ι) (H : i ∈ s), I ≤ f i
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {ε : Type u_5} (f : γ → δ → ε) (g : α → γ) (h : β → δ) (a : α) (b : β) : ε
{X : Type u} {α : Type v} [topological_space X] [linear_order α] [topological_space α] [order_closed_topology α] {s : set X} (hs : is_preconnected s) {a b : X} (ha : a ∈ s) (hb : b ∈ s) {f : X → α} (hf : continuous_on f s) : set.Icc (f a) (f b) ⊆ f '' s
{σ : Type u_1} {τ : Type u_2} (R : Type u_4) [comm_semiring R] (f : σ ≃ τ) : mv_polynomial σ R ≃ₐ[R] mv_polynomial τ R
{ι : Type u_1} {α : ι → Type u_3} [fintype ι] [Π (i : ι), measurable_space (α i)] (μ : Π (i : ι), measure_theory.measure (α i)) [encodable ι] : measure_theory.measure (Π (i : ι), α i)
{K : Type u_1} [linear_ordered_field K] {f : polynomial ℤ} {a b : ℤ} (b0 : 0 < b) (fab : polynomial.eval (↑a / ↑b) (polynomial.map (algebra_map ℤ K) f) ≠ 0) : 1 ≤ ↑b ^ f.nat_degree * |polynomial.eval (↑a / ↑b) (polynomial.map (algebra_map ℤ K) f)|
{α : Type u} [ring α] (u : αˣ) : ↑-u = -↑u
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {s : ℕ → set α} (hs : ∑' (i : ℕ), ⇑μ (s i) ≠ ⊤) : ⇑μ (filter.at_top.limsup s) = 0
{α : Type u} [pseudo_metric_space α] {x : α} {ε : ℝ} (h : 0 ≤ ε) : emetric.closed_ball x (ennreal.of_real ε) = metric.closed_ball x ε
{R : Type u_5} [comm_ring R] [is_domain R] {ζ : R} {n : ℕ+} (h : is_primitive_root ζ ↑n) : polynomial.nth_roots_finset ↑n R = ↑n.divisors.bUnion (λ (i : ℕ), primitive_roots i R)
{α : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} {s t : set α} (h : measure_theory.ae_disjoint μ s t) : ∃ (u : set α), measurable_set u ∧ ⇑μ u = 0 ∧ disjoint (s  u) t
(close_goals : bool) (opt : tactic.suggest.suggest_opt := {to_opt := {to_basic_opt := {to_apply_any_opt := {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, use_symmetry := bool.tt, use_exfalso := bool.tt}, accept := λ (_x : list expr), tactic.skip, pre_apply := tactic.skip, discharger := tactic.failed unit, max_depth := 3}, backtrack_all_goals := bool.ff, lemmas := option.none (list expr), lemma_thunks := option.map (λ (l : list expr), list.map return l) option.none, ctx_thunk := tactic.local_context}, compulsory_hyps := list.nil expr, try_this := bool.tt}) (d : tactic.suggest.decl_data) : tactic ℕ
{ι : Type u_1} {R : Type u_2} {N : Type u_5} [dec_ι : decidable_eq ι] [semiring R] [add_comm_monoid N] [module R N] (p : ι → submodule R N) [Π (i : ι) (x : ↥(p i)), decidable (x ≠ 0)] (x : N) : x ∈ supr p ↔ ∃ (f : Π₀ (i : ι), ↥(p i)), f.sum (λ (i : ι) (xi : ↥(p i)), ↑xi) = x
{R : Type u} {σ : Type u_1} [comm_semiring R] (m : σ →₀ ℕ) (p : mv_polynomial σ R) : R
{I : Type w₀} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {A : Type u₁} [category_theory.category A] (f f' : A ⥤ Π (i : I), C i) (h : ∀ (i : I), f ⋙ category_theory.pi.eval C i = f' ⋙ category_theory.pi.eval C i) : f = f'
(pp_name : name) (type : expr) (bi : binder_info := binder_info.default) : tactic.unsafe.type_context expr
{m : Type u_2} {n : Type u_3} [fintype m] [fintype n] {α : m → n → Type v} (M : dmatrix m n α) {β : m → n → Type w} (f : Π ⦃i : m⦄ ⦃j : n⦄, α i j → β i j) : dmatrix m n β
{V : Type u_1} [inner_product_space ℝ V] {x y : V} (h : inner_product_geometry.angle x (x - y) = inner_product_geometry.angle y (y - x)) (hpi : inner_product_geometry.angle x y ≠ real.pi) : ∥x∥ = ∥y∥
{α : Type u_1} [metric_space α] {m0 : measurable_space α} {μ : measure_theory.measure α} (v : vitali_family μ) (x : α) : filter (set α)
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] {μν : measure_theory.measure (α × β)} (h : ∀ (s : set α) (t : set β), measurable_set s → measurable_set t → ⇑μν (s ×ˢ t) = ⇑μ s * ⇑ν t) : μ.prod ν = μν
(f : C(↥unit_interval, ℝ)) (ε : ℝ) (h : 0 < ε) : ℝ
(l : interactive.parse interactive.types.pexpr_list_or_texpr) (locat : interactive.parse interactive.types.location) (cfg : tactic.equiv_rw_cfg := {max_depth := 10}) : tactic.interactive.itactic
{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (I : lie_ideal R L) : ↥I →ₗ⁅R⁆ L
{α : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space ℝ F'] [complete_space F'] {m m0 : measurable_space α} (hm : m ≤ m0) (μ : measure_theory.measure α) [measure_theory.sigma_finite (μ.trim hm)] (f : α → F') : ↥(measure_theory.Lp F' 1 μ)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : ℕ} (s : affine.simplex k P n) {fs : finset (fin (n + 1))} {m : ℕ} (h : fs.card = m + 1) : set.range (s.face h).points = s.points '' ↑fs
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} {s : set X} (h : lipschitz_on_with K f s) : dimH (f '' s) ≤ dimH s
{R : Type u_1} {S : Type u_6} {M : Type u_9} {M₃ : Type u_12} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid M₃] [module R M] [module S M₃] {σ : R →+* S} (f : M →ₛₗ[σ] M₃) (f' : M → M₃) (h : f' = ⇑f) : M →ₛₗ[σ] M₃
{α : Type u_1} {β : Type u_2} [measurable_space α] (μ : measure_theory.measure α) [topological_space α] [borel_space α] [topological_space β] [second_countable_topology_either α β] [topological_space.pseudo_metrizable_space β] [group β] [topological_group β] : C(α, β) →* α →ₘ[μ] β
{n : ℕ} {K : Type u_8} [field K] {μ : K} (h : is_primitive_root μ n) [char_zero K] : n.totient ≤ (minpoly ℤ μ).nat_degree
{α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure_theory.measure α} [normed_group β] (f : α →ₘ[μ] β) : Prop
{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {N : Type (max u v)} [add_comm_group N] [module R N] [h' : module.finite R N] (hN : module.is_torsion R N) : ∃ (ι : Type u) [_inst_8 : fintype ι] (p : ι → R) [_inst_9 : ∀ (i : ι), irreducible (p i)] (e : ι → ℕ), nonempty (N ≃ₗ[R] direct_sum ι (λ (i : ι), R ⧸ submodule.span R {p i ^ e i}))
{C : Type u} [category_theory.category C] (I : category_theory.limits.multispan_index C) [category_theory.limits.has_coproduct I.left] [category_theory.limits.has_coproduct I.right] : ∐ I.left ⟶ ∐ I.right
{ι : Type u_1} [fintype ι] (l : box_integral.integration_params) (I : box_integral.box ι) : filter (box_integral.tagged_prepartition I)
{W X Y Z S T : Top} (f₁ : W ⟶ S) (f₂ : X ⟶ S) (g₁ : Y ⟶ T) (g₂ : Z ⟶ T) (i₁ : W ⟶ Y) (i₂ : X ⟶ Z) (i₃ : S ⟶ T) [H₃ : category_theory.mono i₃] (eq₁ : f₁ ≫ i₃ = i₁ ≫ g₁) (eq₂ : f₂ ≫ i₃ = i₂ ≫ g₂) : set.range ⇑(category_theory.limits.pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂) = ⇑category_theory.limits.pullback.fst ⁻¹' set.range ⇑i₁ ∩ ⇑category_theory.limits.pullback.snd ⁻¹' set.range ⇑i₂
{f f' : ℝ → ℝ} {δ K ε a b : ℝ} (hf : continuous_on f (set.Icc a b)) (hf' : ∀ (x : ℝ), x ∈ set.Ico a b → ∀ (r : ℝ), f' x < r → (∃ᶠ (z : ℝ) in nhds_within x (set.Ioi x), (z - x)⁻¹ * (f z - f x) < r)) (ha : f a ≤ δ) (bound : ∀ (x : ℝ), x ∈ set.Ico a b → f' x ≤ K * f x + ε) (x : ℝ) (H : x ∈ set.Icc a b) : f x ≤ gronwall_bound δ K ε (x - a)
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : α → F} {f' : α → E'} {l : filter α} : f' =O[l] g → (λ (x : α), ∥f' x∥) =O[l] g
{V₁ : Type u_2} {V₂ : Type u_3} [semi_normed_group V₁] [semi_normed_group V₂] (f : V₁ →+ V₂) {C : ℝ} (h : ∀ (x : V₁), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_normed_group_hom C h∥ ≤ linear_order.max C 0
{α : Type u_1} [semi_normed_group α] {r C : ℝ} {f : ℕ → α} (hr : r < 1) (hf : ∀ (n : ℕ), ∥f n∥ ≤ C * r ^ n) : cauchy_seq (λ (s : finset ℕ), s.sum (λ (x : ℕ), f x))
{F : Type u_3} [inner_product_space ℝ F] {x y : F} : ∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * has_inner.inner x y + ∥y∥ ^ 2
{α : Type u} {σ : Type v} (M : NFA α σ) : ε_NFA α σ
{α : Type u} {β : Type v} {φ : ultrafilter α} [linear_ordered_add_comm_group β] : linear_ordered_add_comm_group (↑φ.germ β)
{R : Type u_1} [comm_ring R] (I : ideal R) (M : Type u_2) [add_comm_group M] [module R M] (n : ℕ) : ↥(adic_completion I M) →ₗ[R] M ⧸ I ^ n • ⊤
{R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring R₂] {σ₁₂ : R →+* R₂} [add_comm_monoid M₂] [module R₂ M₂] [ring_hom_surjective σ₁₂] (f : M →ₛₗ[σ₁₂] M₂) (s : set M) : submodule.map f (submodule.span R s) = submodule.span R₂ (⇑f '' s)
{C : Type u} [category_theory.category C] (I : category_theory.limits.multicospan_index C) (P : C) (ι : Π (a : I.L), P ⟶ I.left a) (w : ∀ (b : I.R), ι (I.fst_to b) ≫ I.fst b = ι (I.snd_to b) ≫ I.snd b) : category_theory.limits.multifork I
{𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] [c : inner_product_space.core 𝕜 F] (x y : F) : is_R_or_C.abs (has_inner.inner x y) ≤ ∥x∥ * ∥y∥
{ι : Type v} [preorder ι] (G : ι → Type w) [nonempty ι] [is_directed ι has_le.le] [Π (i : ι), field (G i)] (f' : Π (i j : ι), i ≤ j → G i →+* G j) [directed_system G (λ (i j : ι) (h : i ≤ j), ⇑(f' i j h))] : field (ring.direct_limit G (λ (i j : ι) (h : i ≤ j), ⇑(f' i j h)))
{G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [locally_compact_space G] (μ : measure_theory.measure G) [μ.is_add_haar_measure] : measure_theory.is_locally_finite_measure μ
{α : Type u_1} {β : Type u_2} {m0 : measurable_space α} [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} {f : α → β} {t : set β} (ht : measure_theory.null_measurable_set t ν) (hf : measure_theory.measure.quasi_measure_preserving f μ ν) : measure_theory.null_measurable_set (f ⁻¹' t) μ
{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {ι : Type u_2} [fintype ι] (I : ideal R) (P : ι → ideal R) (e : ι → ℕ) (prime : ∀ (i : ι), _root_.prime (P i)) (coprime : ∀ (i j : ι), i ≠ j → P i ≠ P j) (prod_eq : finset.univ.prod (λ (i : ι), P i ^ e i) = I) : R ⧸ I ≃+* Π (i : ι), R ⧸ P i ^ e i
{α : Type u_1} {ι : Type u_2} {s : set α} (hs : s.nonempty) {f : α → ι} : s.pairwise (λ (x y : α), f x = f y) ↔ ∃ (z : ι), ∀ (x : α), x ∈ s → f x = z
{C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C ⥤ D) [F.final] {d : D} (Z : Π (X : C), (d ⟶ F.obj X) → Sort u_1) (h₁ : Π (X₁ X₂ : C) (k₁ : d ⟶ F.obj X₁) (k₂ : d ⟶ F.obj X₂) (f : X₁ ⟶ X₂), k₁ ≫ F.map f = k₂ → Z X₁ k₁ → Z X₂ k₂) (h₂ : Π (X₁ X₂ : C) (k₁ : d ⟶ F.obj X₁) (k₂ : d ⟶ F.obj X₂) (f : X₁ ⟶ X₂), k₁ ≫ F.map f = k₂ → Z X₂ k₂ → Z X₁ k₁) {X₀ : C} {k₀ : d ⟶ F.obj X₀} (z : Z X₀ k₀) : Z (category_theory.functor.final.lift F d) (category_theory.functor.final.hom_to_lift F d)
{G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G → E'} [measurable_space G] {μ : measure_theory.measure G} [normed_space ℝ E'] [inner_product_space ℝ G] [complete_space E'] [borel_space G] [measure_theory.is_locally_finite_measure μ] [μ.is_open_pos_measure] [finite_dimensional ℝ G] [μ.is_add_left_invariant] {ι : Type u_1} {φ : ι → cont_diff_bump_of_inner 0} {l : filter ι} (hφ : filter.tendsto (λ (i : ι), (φ i).R) l (nhds 0)) (hg : continuous g) (x₀ : G) : filter.tendsto (λ (i : ι), convolution (λ (x : G), (φ i).normed μ x) g (continuous_linear_map.lsmul ℝ ℝ) μ x₀) l (nhds (g x₀))
{K : Type u_1} {σ : Type u_2} [fintype K] [field K] [fintype σ] [decidable_eq K] [decidable_eq σ] (p : ℕ) [char_p K p] {ι : Type u_3} {s : finset ι} {f : ι → mv_polynomial σ K} (h : s.sum (λ (i : ι), (f i).total_degree) < fintype.card σ) : p ∣ fintype.card {x // ∀ (i : ι), i ∈ s → ⇑(mv_polynomial.eval x) (f i) = 0}
{C : Type u} [category_theory.category C] {I : category_theory.limits.multicospan_index C} (K : category_theory.limits.multifork I) (lift : Π (E : category_theory.limits.multifork I), E.X ⟶ K.X) (fac : ∀ (E : category_theory.limits.multifork I) (i : I.L), lift E ≫ K.ι i = E.ι i) (uniq : ∀ (E : category_theory.limits.multifork I) (m : E.X ⟶ K.X), (∀ (i : I.L), m ≫ K.ι i = E.ι i) → m = lift E) : category_theory.limits.is_limit K
{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (e : α ≃ᵤ β) (s : set α) : ↥s ≃ᵤ ↥(⇑e '' s)
{α : Type u_1} {m0 : measurable_space α} (μ : measure_theory.measure α) : Prop
{α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] (μ : measure_theory.measure α) [μ.weakly_regular] [measure_theory.sigma_finite μ] (f : α → nnreal) (fmeas : measurable f) {ε : ennreal} (ε0 : ε ≠ 0) : ∃ (g : α → ennreal), (∀ (x : α), ↑(f x) < g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), g x ∂μ ≤ ∫⁻ (x : α), ↑(f x) ∂μ + ε
{α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : α → E} {g : α → F} {l : filter α} : (∀ ⦃c : ℝ⦄, 0 < c → (∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥)) → f =o[l] g
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] {μ : measure_theory.measure α} [topological_space β] [topological_space γ] (r : β → γ → Prop) (f : α →ₘ[μ] β) (g : α →ₘ[μ] γ) : Prop
{ι : Type u_1} {I : box_integral.box ι} [fintype ι] {π₁ π₂ : box_integral.prepartition I} (h : π₁.Union = π₂.Union) : π₁.compl = π₂.compl
{α : Type u} {σ : Type v} (M : NFA α σ) (start : set σ) : list α → set σ
{α : Type u} [pseudo_emetric_space α] (ε δ : ℝ) (s : set α) : metric.thickening ε (metric.thickening δ s) ⊆ metric.thickening (ε + δ) s
{E : Type u_3} [normed_group E] [complete_space E] [normed_space ℝ E] {f g : ℝ → E} {μ : measure_theory.measure ℝ} {a b : ℝ} (h : set.eq_on f g (set.interval a b)) : ∫ (x : ℝ) in a..b, f x ∂μ = ∫ (x : ℝ) in a..b, g x ∂μ
{x : ℝ} (hx : liouville x) (n : ℕ) : ∃ᶠ (b : ℕ) in filter.at_top, ∃ (a : ℤ), x ≠ ↑a / ↑b ∧ |x - ↑a / ↑b| < 1 / ↑b ^ n
{X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) ⦃ι : Type v⦄ (U : ι → topological_space.opens ↥X) (c : category_theory.limits.cone (Top.presheaf.sheaf_condition_equalizer_products.diagram F U)) : category_theory.limits.cone ((category_theory.pairwise.diagram U).op ⋙ F)
{α : Type u_1} {β : Type u_2} [linear_ordered_add_comm_group β] [uniform_space β] [uniform_add_group β] [complete_space β] {f : α → β} : summable (λ (x : α), |f x|) → summable f
{I : Type u} (X : I → Top) : category_theory.Groupoid.of (Π (i : I), ↥(fundamental_groupoid.fundamental_groupoid_functor.obj (X i))) ≅ fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (Π (i : I), ↥(X i)))
{R₁ : Type u_1} {R₂ : Type u_2} [semiring R₁] [semiring R₂] (σ : R₁ →+* R₂) : Prop
{R : Type u_1} [normed_ring R] [complete_space R] (x : Rˣ) (n : ℕ) : (λ (t : R), ring.inverse (↑x + t) - (finset.range n).sum (λ (i : ℕ), (-↑x⁻¹ * t) ^ i) * ↑x⁻¹) =O[nhds 0] λ (t : R), ∥t∥ ^ n
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) (h : is_complete ↑K) (u : E) : ∃ (v : E) (H : v ∈ K), ∥u - v∥ = ⨅ (w : ↥↑K), ∥u - ↑w∥
{α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measure_theory.sigma_finite ν] [normed_space ℝ E] [complete_space E] [measure_theory.sigma_finite μ] ⦃f g : α × β → E⦄ (hf : measure_theory.integrable f (μ.prod ν)) (hg : measure_theory.integrable g (μ.prod ν)) : ∫ (x : α), ∫ (y : β), f (x, y) + g (x, y) ∂ν ∂μ = ∫ (x : α), ∫ (y : β), f (x, y) ∂ν ∂μ + ∫ (x : α), ∫ (y : β), g (x, y) ∂ν ∂μ
{k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] ⦃φ₁ φ₂ : add_monoid_algebra k G →ₐ[k] A⦄ (h : ∀ (x : G), ⇑φ₁ (finsupp.single x 1) = ⇑φ₂ (finsupp.single x 1)) : φ₁ = φ₂
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} (μ : measure_theory.measure α) [normed_group β] {p : ennreal} (hp : 1 ≤ p) (hp' : p ≠ ⊤) {f : ι → α → β} (hf : ∀ (i : ι), measure_theory.strongly_measurable (f i)) (h : ∀ (ε : ℝ), 0 < ε → (∃ (C : nnreal), 0 < C ∧ ∀ (i : ι), measure_theory.snorm ({x : α | C ≤ ∥f i x∥₊}.indicator (f i)) p μ ≤ ennreal.of_real ε)) : measure_theory.unif_integrable f p μ
{I : Type w₁} {C : I → Type u₁} [Π (i : I), category_theory.category (C i)] {D : Type u₂} [category_theory.category D] {F G : (Σ (i : I), C i) ⥤ D} (h : Π (i : I), category_theory.sigma.incl i ⋙ F ⟶ category_theory.sigma.incl i ⋙ G) : F ⟶ G
{S : Type u_2} {R : Type u} {M : Type v} {N : Type u_1} [semiring S] [add_comm_monoid R] [add_comm_monoid M] [add_comm_monoid N] [module S R] [module S M] [module S N] ⦃f g : triv_sq_zero_ext R M →ₗ[S] N⦄ (hl : ∀ (r : R), ⇑f (triv_sq_zero_ext.inl r) = ⇑g (triv_sq_zero_ext.inl r)) (hr : ∀ (m : M), ⇑f (triv_sq_zero_ext.inr m) = ⇑g (triv_sq_zero_ext.inr m)) : f = g
{V : Type u_1} [inner_product_space ℝ V] {x y : V} (h : inner_product_geometry.angle x y = real.pi) : has_inner.inner x y = -(∥x∥ * ∥y∥)
{ι : Type uι} {E : Type uE} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E] {H : Type uH} [topological_space H] {I : model_with_corners ℝ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (fs : smooth_bump_covering ι I M s) [t2_space M] : bump_covering ι M s
(Γ : Type u_1) [inhabited Γ] (Λ : Type u_2) [inhabited Λ] : Type (max u_2 u_1)
{G : Type w} [topological_space G] (μ : measure_theory.content G) [t2_space G] [S : measurable_space G] [borel_space G] : S ≤ μ.outer_measure.caratheodory
{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] (μ : measure_theory.measure α) (ν : measure_theory.measure β) : measure_theory.measure (α × β)
{C : Type u} [category_theory.category C] {X Y : C} (f : X ⟶ Y) [I : category_theory.is_iso f] : Y ⟶ X
{k : Type u_1} [field k] {σ : Type u_2} [is_alg_closed k] [fintype σ] (I : ideal (mv_polynomial σ k)) : mv_polynomial.vanishing_ideal (mv_polynomial.zero_locus I) = I.radical
{α : Type u_1} [measurable_space α] [topological_space α] (μ : measure_theory.finite_measure α) (f : bounded_continuous_function α nnreal) : nnreal
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] {σ : Type u_3} [inhabited σ] {n : ℕ} (dec : vector bool n → Γ) (f : Γ → turing.TM1.stmt bool turing.TM1to1.Λ' σ) : turing.TM1.stmt bool turing.TM1to1.Λ' σ
{G : Type u_1} [measurable_space G] [group G] [has_measurable_mul G] (μ : measure_theory.measure G) [μ.is_mul_left_invariant] (g : G) (A : set G) : ⇑μ ((λ (h : G), g * h) ⁻¹' A) = ⇑μ A
{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (G : C ⥤ D) {W X Y Z : C} {h : X ⟶ Z} {k : Y ⟶ Z} {f : W ⟶ X} {g : W ⟶ Y} (comm : f ≫ h = g ≫ k) [category_theory.limits.preserves_colimit (category_theory.limits.span f g) G] (l : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk h k comm)) : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (G.map h) (G.map k) _)
{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {H : Type u_3} [topological_space H] (I : model_with_corners 𝕜 E H) {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space 𝕜 E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners 𝕜 E' H') {M' : Type u_7} [topological_space M'] [charted_space H' M'] (f : M → M') (s : set M) (x : M) : Prop
(h : expr) (nargs : option ℕ := option.none) (md : tactic.transparency := tactic.transparency.semireducible) : tactic congr_lemma
{R : Type u_1} [comm_semiring R] (σ : Type u_2) [fintype σ] (r : σ → R) (k : ℕ) (h : k ≤ fintype.card σ) : (finset.univ.prod (λ (i : σ), ⇑polynomial.C (r i) + polynomial.X)).coeff k = (finset.powerset_len (fintype.card σ - k) finset.univ).sum (λ (t : finset σ), t.prod (λ (i : σ), r i))
{ι : Type u_1} {σ : Type u_2} {R : Type u_4} [decidable_eq ι] [add_comm_monoid ι] [comm_semiring R] [set_like σ R] [add_submonoid_class σ R] (A : ι → σ) [set_like.graded_monoid A] : direct_sum.gcomm_semiring (λ (i : ι), ↥(A i))
{ε : ℝ} (hε : 0 < ε) (ι : Type u_1) [encodable ι] : {ε' // (∀ (i : ι), 0 < ε' i) ∧ ∃ (c : ℝ), has_sum ε' c ∧ c ≤ ε}
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (σ : equiv.perm n) (M : matrix n n R) : matrix.det (λ (i : n), M (⇑σ i)) = ↑(⇑equiv.perm.sign σ) * M.det
{V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace ℝ P} {p1 p2 : P} (hp1 : p1 ∈ s) (hp2 : p2 ∈ s) (r1 r2 : ℝ) {v : V} (hv : v ∈ (s.direction)ᗮ) : has_dist.dist (r1 • v +ᵥ p1) (r2 • v +ᵥ p2) * has_dist.dist (r1 • v +ᵥ p1) (r2 • v +ᵥ p2) = has_dist.dist p1 p2 * has_dist.dist p1 p2 + (r1 - r2) * (r1 - r2) * (∥v∥ * ∥v∥)
{α : Type u} [pseudo_metric_space α] {β : Type u_1} {p : β → Prop} {f : β → ℝ} (hf₀ : ∀ (i : β), p i → 0 < f i) (hf : ∀ ⦃ε : ℝ⦄, 0 < ε → (∃ (i : β) (hi : p i), f i ≤ ε)) : (uniformity α).has_basis p (λ (i : β), {p : α × α | has_dist.dist p.fst p.snd < f i})
{Γ : Type u_1} [inhabited Γ] {Λ : Type u_2} [inhabited Λ] {σ : Type u_3} [inhabited σ] : list bool → turing.TM1.stmt bool turing.TM1to1.Λ' σ → turing.TM1.stmt bool turing.TM1to1.Λ' σ
{α : Type u_1} [measurable_space α] {μ : measure_theory.measure α} {s t : set α} (H : s ≤ᵐ[μ] t) : ⇑μ s ≤ ⇑μ t
{ι : Type u_1} (I : box_integral.box ι) (i : ι) (x : ℝ) : box_integral.prepartition I
{α : Type u_1} {m : measurable_space α} {μ : measure_theory.measure α} {f : measure_theory.simple_func α ℝ} (hf : measure_theory.integrable ⇑f μ) (h_pos : 0 ≤ᵐ[μ] ⇑f) : measure_theory.simple_func.integral μ f = (∫⁻ (a : α), ennreal.of_real (⇑f a) ∂μ).to_real
{R : Type u_1} {M : Type u_2} [comm_semiring R] [monoid M] {S : set (monoid_algebra R M)} (hS : algebra.adjoin R S = ⊤) : algebra.adjoin R (⇑(monoid_algebra.of R M) '' ⋃ (f : monoid_algebra R M) (H : f ∈ S), ↑(f.support)) = ⊤
(e : expr) (n : name := name.mk_string "_x" name.anonymous) (md : tactic.transparency := tactic.transparency.semireducible) : tactic unit
{α : Type u_1} [measurable_space α] [topological_space α] {μ : measure_theory.measure α} [μ.regular] ⦃A : set α⦄ (hA : measurable_set A) (h'A : ⇑μ A ≠ ⊤) {ε : ennreal} (hε : ε ≠ 0) : ∃ (K : set α) (H : K ⊆ A), is_compact K ∧ ⇑μ A < ⇑μ K + ε
{M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : ∥↑m∥ ≤ ∥m∥
{V : Type v} [category_theory.category V] [category_theory.monoidal_category V] {W : Type v} [category_theory.category W] [category_theory.monoidal_category W] (F : category_theory.lax_monoidal_functor V W) (C : Type u₁) : Type u₁
