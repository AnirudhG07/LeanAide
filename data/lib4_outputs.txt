{α : Type u} [PseudoMetricSpace α] (x y z : α) : HasNndist.nndist x z ≤ HasNndist.nndist x y + HasNndist.nndist y z
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] : IsNoetherian K v ↔ module.rank K v < Cardinal.aleph0
{α : Type u_2} [DecidableEq α] {S : Finset α} {B : Finset (Finset α)} {n : ℕ} (h : ∀ (A : α), A ∈ S → (Finset.Filter (HasMem.Mem A) B).Card ≤ n) : B.Sum (λ (t : Finset α), (S ∩ t).Card) ≤ S.Card * n
{R : Type u_1} {n : ℕ} {m : Fin n → Type u_3} {m₂ : Type u_4} [CommSemiring R] [AddCommMonoid m₂] [Π (i : Fin n), AddCommMonoid (m i)] [Π (i : Fin n), module R (m i)] [module R m₂] {F g : MultilinearMap R m m₂} {ι₁ : Fin n → Type u_2} (e : Π (i : Fin n), Basis (ι₁ i) R (m i)) (h : ∀ (v : Π (i : Fin n), ι₁ i), ⇑F (λ (i : Fin n), ⇑(e i) (v i)) = ⇑g (λ (i : Fin n), ⇑(e i) (v i))) : F = g
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {x : top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.Forget C)] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.Forget C)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget C)] (F : top.sheaf C x) (U : TopologicalSpace.Opens ↥x) (S t : ↥(F.val.obj (Opposite.Op U))) (h : ∀ (x : ↥U), ⇑(F.val.germ x) S = ⇑(F.val.germ x) t) : S = t
{G : Type u_7} [AddGroup G] (L : List G) (i : ℕ) (P : i < L.length) : (List.Drop (i + 1) L).Sum = -L.nth_LE i P + (List.Drop i L).Sum
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B : α} : A - B < 0 ↔ A < B
{𝕜 : Type u_1} {𝕝 : Type u_2} {E : Type u_3} [NormedField 𝕜] [NormedRing 𝕝] [NormedSpace 𝕜 𝕝] [AddCommGroup E] [module 𝕜 E] [SmulWithZero 𝕝 E] [IsScalarTower 𝕜 𝕝 E] {S : set E} (hs : Balanced 𝕝 S) {A : 𝕝} {B : 𝕜} (h : ∥A∥ ≤ ∥B∥) : A • S ⊆ B • S
{C : Type u} [CategoryTheory.Category C] (i P : CategoryTheory.Arrow C) (h : CategoryTheory.Limits.IsInitial i.Left) : CategoryTheory.HasLiftingProperty i P ↔ ∀ {e : i.Right ⟶ P.Right}, ∃ (l : i.Right ⟶ P.Left), l ≫ P.hom = e
{α : Type u} {A B : α} [MulOneClass α] [has_Zero α] [Preorder α] [ZeroLt.PosMulMono α] (ha : A ≤ 1) (hb : B ≤ 1) (A0 : 0 < A) : A * B ≤ 1
(R : Type u_1) [CommRing R] {n m : ℕ} (hpos : 0 < n) (hm : m ∣ n) (hdiff : m ≠ n) : Polynomial.x ^ m - 1 ∣ n.proper_divisors.Prod (λ (i : ℕ), Polynomial.cyclotomic i R)
{m : Type u_6} {N : Type u_7} [has_Mul m] [has_Mul N] (e : m ≃* N) (y : N) : ⇑e (⇑(e.Symm) y) = y
(P : ℕ) : WittVector.IsPoly P (λ (R : Type u_1) (_Rcr : CommRing R), witt_Vector.verschiebung_fun)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {F : E → F} (g : F →L[𝕜] G) (hF : ContDiff 𝕜 n F) : ContDiff 𝕜 n (λ (x : E), ⇑g (F x))
{R : Type u_1} [AddMonoid R] (A : AddUnits R) : IsAddRegular ↑A
{α : Type u_1} [TopologicalSpace α] (S : set (set α)) (hS : ∀ (S : ↥S), IsOpen ↑S) [hS' : ∀ (S : ↥S), QuasiSober ↥S] (hS'' : ⋃₀S = ⊤) : QuasiSober α
{α : Type u_1} {n : Type u_4} [has_Zero α] [Subsingleton n] (A : Matrix n n α) : A.IsDiag
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {C : E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set ℝ} [IntervalIntegral.FTC_Filter B (nhds_within B S) (nhds_within B t)] (hmeas : StronglyMeasurableAtFilter F (nhds_within B t) MeasureTheory.MeasureSpace.Volume) (hb : Filter.Tendsto F (nhds_within B t ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) (hs : UniqueDiffWithinAt ℝ S B . "UniqueDiffWithinAt_ici_Iic_Univ") : deriv_within (λ (u : ℝ), ∫ (x : ℝ) in A..u, F x) S B = C
{C : Type u₁} [CategoryTheory.Category C] {x : C} {S : CategoryTheory.Sieve x} : ⇑S (𝟙 x) ↔ S = ⊤
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 P3 : P) : HasDist.dist P1 P3 * HasDist.dist P1 P3 = HasDist.dist P1 P2 * HasDist.dist P1 P2 + HasDist.dist P3 P2 * HasDist.dist P3 P2 ↔ EuclideanGeometry.angle P1 P2 P3 = Real.Pi / 2
{m : Type u_2} [AddCommGroup m] {𝕜 : Type u_1} [Field 𝕜] [module 𝕜 m] {F : m →ₗ[𝕜] m} (hF : ⇑LinearMap.det F = 0) : ⊥ < F.Ker
{m : Type u_2} {n : Type u_3} {R : Type u_7} [Fintype n] [Fintype m] [NonUnitalSemiring R] (v : m → R) (A : Matrix m n R) (W : n → R) : Matrix.dot_Product v (A.Mul_vec W) = Matrix.dot_Product (Matrix.vec_Mul v A) W
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {D : Type u₂} [CategoryTheory.Category D] [CategoryTheory.Abelian D] (F : C ⥤ D) (G : D ⥤ C) [G.preserves_Zero_morphisms] (i : F ⋙ G ≅ 𝟭 C) [CategoryTheory.Limits.PreservesFiniteLimits G] : CategoryTheory.Limits.HasKernels C
{v : Type u} (G : SimpleGraph v) {v W : v} : G.Adj v W ↔ v ≠ W ∧ ∃ (e : Sym2 v) (h : e ∈ G.edge_set), v ∈ e ∧ W ∈ e
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [module 𝕜 E] {S : set E} : S.Nonempty → (⇑(Convex_hull 𝕜) S).Nonempty
{G : Type u_1} [AddGroup G] [Fintype G] (P : ℕ) [hp : Fact (Nat.Prime P)] (hdvd : P ∣ Fintype.Card G) : ∃ (x : G), Add_order_of x = P
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {A B C : α} [IsTrans α HasSubset.Subset] (h₁ : A ⊂ B) (h₂ : B ⊆ C) : A ⊂ C
{R : Type u} {S : Type v} [CommRing R] [CommRing S] (F : R →+* S) : Function.Injective ⇑(F.Ker_Lift)
{G : Type u_1} [AddCommGroup G] (F : ℕ → G) (n : ℕ) : (Finset.Range n).Sum (λ (i : ℕ), F (i + 1) - F i) = F n - F 0
{m : Type u_2} [AddCommGroup m] {ι : Type u_4} [DecidableEq ι] [Fintype ι] {A : Type u_5} [CommRing A] [module A m] (B : Basis ι A m) (F : m →ₗ[A] m) : ⇑(LinearMap.det_aux (Trunc.Mk B)) F = (⇑(Linear_Map.to_Matrix B B) F).det
{α : Type u_1} {l l' : List α} : l <+ l' ↔ ∃ (F : ℕ ↪o ℕ), ∀ (ix : ℕ), l.nth ix = l'.nth (⇑F ix)
{C : Type u} [CategoryTheory.Category C] {x Y Z : C} {i : CategoryTheory.Arrow C} {F : x ⟶ Y} {g : Y ⟶ Z} (hF : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.Mk F)) (hg : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.Mk g)) : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.Mk (F ≫ g))
{α : Type u_1} [has_LT α] {A B : αᵒᵈ} : B < A → ⇑order_dual.of_dual A < ⇑order_dual.of_dual B
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e e' : LocalHomeomorph α β} (h : e ≈ e') : e.to_local_Equiv.Target = e'.to_local_Equiv.Target
{α : Type u} [TopologicalSpace α] [SigmaCompactSpace α] {F : α → set α} {S : set α} (hs : IsClosed S) (hF : ∀ (x : α), x ∈ S → F x ∈ nhds_within x S) : ∃ (t : set α) (h : t ⊆ S), t.countable ∧ S ⊆ ⋃ (x : α) (h : x ∈ t), F x
{R : Type u_1} {G : Type u_2} [CommRing R] [IsDomain R] [Group G] [Fintype G] (F : G →* R) [Decidable (F = 1)] : Finset.Univ.Sum (λ (g : G), ⇑F g) = Ite (F = 1) ↑(Fintype.Card G) 0
{J K : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.SmallCategory K] {C : Type u} [CategoryTheory.Category C] (F : J × K ⥤ C) [CategoryTheory.Limits.HasLimits_of_shape J C] [CategoryTheory.Limits.HasColimits_of_shape K C] (j : J) (k : K) : CategoryTheory.Limits.Colimitι (CategoryTheory.Curry.obj (CategoryTheory.Prod.Swap K J ⋙ F) ⋙ CategoryTheory.Limits.lim) k ≫ CategoryTheory.Limits.Colimit_Limit_to_Limit_Colimit F ≫ CategoryTheory.Limits.Limitπ (CategoryTheory.Curry.obj F ⋙ CategoryTheory.Limits.colim) j = CategoryTheory.Limits.Limitπ ((CategoryTheory.Curry.obj (CategoryTheory.Prod.Swap K J ⋙ F)).obj k) j ≫ CategoryTheory.Limits.Colimitι ((CategoryTheory.Curry.obj F).obj j) k
{B : ℝ} (A x : ℝ) (h2 : 0 < B) : ∫ (x : ℝ) in A..x, Real.Exp (-B * x) ≤ Real.Exp (-B * A) / B
{F : Type u_1} {K : Type u_2} {L : Type u_3} [Field F] [Field K] [Field L] [Algebra F K] [Algebra F L] (S : Finset K) : (∀ (x : K), x ∈ S → IsIntegral F x ∧ Polynomial.Splits (Algebra_Map F L) (minpoly F x)) → Nonempty (↥(Algebra.Adjoin F ↑S) →ₐ[F] L)
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B C : α} : A - C < B → A < B + C
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} {S t : set α} (hst : S ⊆ t) (ht : (t ∩ Function.MulSupport F).Finite) : finprod (λ (i : α), finprod (λ (h : i ∈ S), F i)) * finprod (λ (i : α), finprod (λ (h : i ∈ t  S), F i)) = finprod (λ (i : α), finprod (λ (h : i ∈ t), F i))
{R : Type u_1} [Semiring R] (x y : DualNumber R) : (x * y).Snd = TrivSqZeroExt.fst x * TrivSqZeroExt.Snd y + TrivSqZeroExt.fst y * TrivSqZeroExt.Snd x
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {A u' : α} {S : set α} (hu' : A < u') : S ∈ nhds_within A (set.ioi A) ↔ ∃ (u : α) (h : u ∈ set.ioi A), set.Ioo A u ⊆ S
{β : Type u_4} [LinearOrder β] [NoMaxOrder β] {u : ℕ → β} (hu : Filter.Tendsto u Filter.at_top Filter.at_top) : ∃ᶠ (n : ℕ) in Filter.at_top, ∀ (k : ℕ), k < n → u k < u n
{Γ₀ : Type u_1} [Linear_ordered_comm_Group_with_Zero Γ₀] (γ : Γ₀ˣ) : {x : Γ₀ | x < ↑γ} ∈ nhds 0
{β : Type u_2} {F g : β → Nnreal} {r : Nnreal} (hgf : ∀ (B : β), g B ≤ F B) (hfr : has_Sum F r) : ∃ (P : Nnreal) (h : P ≤ r), has_Sum g P
(C : Turing.ToPartrec.Code) (k k' : Turing.ToPartrec.Cont) (v : List ℕ) : Turing.ToPartrec.step_Normal C (k.then k') v = (Turing.ToPartrec.step_Normal C k v).then k'
{C : Type u₁} [CategoryTheory.Category C] {t : CategoryTheory.Monad C} {J : Type u} [CategoryTheory.Category J] [CategoryTheory.Limits.PreservesColimitsOfShape J ↑t] (D : J ⥤ t.Algebra) [CategoryTheory.Limits.HasColimit (D ⋙ t.Forget)] : CategoryTheory.Limits.HasColimit D
{R : Type u_1} {ι : Type u_4} [Linear_ordered_Field R] [Fintype ι] {F : ι → R} (hF : F ∈ StdSimplex R ι) (x : ι) : F x ∈ set.icc 0 1
{R₁ : Type u_1} {R₂ : Type u_2} [Semiring R₁] [Semiring R₂] (σ₁₂ : R₁ →+* R₂) (σ₂₁ : R₂ →+* R₁) [RingHomInvPair σ₁₂ σ₂₁] : RingHomInvPair σ₂₁ σ₁₂
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x ⟶ Y} [CategoryTheory.Limits.HasEqualizer F g] [CategoryTheory.Epi (CategoryTheory.Limits.Equalizerι F g)] : F = g
{α : Type u} [PseudoMetricSpace α] (x : α) : Emetric.Ball x ⊤ = set.Univ
{α : Type u_1} (P : Pmf α) {S t : set α} (h : S ∩ P.Support ⊆ t) : ⇑(P.to_OuterMeasure) S ≤ ⇑(P.to_OuterMeasure) t
{K : Type u_1} {v : K} {n : ℕ} [Linear_ordered_Field K] [FloorRing K] : 0 ≤ (GeneralizedContinuedFraction.of v).denominators n
{n : WithTop ℕ} {𝕂 : Type u_6} [_R_or_C 𝕂] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {F : 𝕂 → F'} {x : 𝕂} (hF : ContDiff 𝕂 n F) (hn : 1 ≤ n) : HasStrictDerivAt F (deriv F x) x
{P q x : ℝ} (h : LiouvilleWith P x) (hle : q ≤ P) : LiouvilleWith q x
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) (S : set P) : P ∈ S → P ∈ SpanPoints k S
{α : Type u_1} [CompleteLattice α] [IsCompactlyGenerated α] {A : α} {S : set α} : A ⊓ HasSup.Sup S = ⨆ (t : Finset α) (h : ↑t ⊆ S), A ⊓ t.Sup Id
{C : Type u_1} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) : CategoryTheory.CoverLifting J J (𝟭 C)
{ι : Type u_1} {x : ι → Type u_2} [Π (i : ι), TopologicalSpace (x i)] {as bs : Π (i : ι), x i} (i : ι) (Paths : Π (i : ι), Path.Homotopic.Quotient (as i) (bs i)) : Path.Homotopic.Proj i (Path.Homotopic.Pi Paths) = Paths i
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (t : Affine.Triangle ℝ P) : t.orthocenter = 3 • (Finset.centroid ℝ Finset.Univ t.points -ᵥ Affine.Simplex.circumcenter t) +ᵥ Affine.Simplex.circumcenter t
{α : Type u_1} [has_LT α] {A B : α} (h : A < B) : ¬A ⋖ B → (∃ (C : α), A < C ∧ C < B)
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {F : α → γ} (hF : Continuous F) : Continuous (λ (x : α × β), F x.fst)
{α : Type u_2} {β : Type u_3} {γ : Type u_4} [rα : non_unital_non_assoc_Semiring α] [rβ : non_unital_non_assoc_Semiring β] {rγ : non_unital_non_assoc_Semiring γ} {δ : Type u_1} {rδ : non_unital_non_assoc_Semiring δ} (F : α →ₙ+* β) (g : β →ₙ+* γ) (h : γ →ₙ+* δ) : (h.Comp g).Comp F = h.Comp (g.Comp F)
(Γ₀ : Type u_1) [Linear_ordered_comm_Group_with_Zero Γ₀] : Directed Ge (λ (γ₀ : Γ₀ˣ), Filter.principal {γ : Γ₀ | γ < ↑γ₀})
(n : ℕ) {A : ℝ} (h : Real.sqrt_two_Add_series (↑0 / ↑1) n ≤ 2 - (A / 2 ^ (n + 1)) ^ 2) : A < Real.Pi
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x : C} (P : x ⟶ x) (hp : P ≫ P = P) : (𝟙 x - P) ≫ (𝟙 x - P) = 𝟙 x - P
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} {S t : set α} (hst : S ⊆ t) (ht : t.Finite) : finsum (λ (i : α), finsum (λ (h : i ∈ S), F i)) + finsum (λ (i : α), finsum (λ (h : i ∈ t  S), F i)) = finsum (λ (i : α), finsum (λ (h : i ∈ t), F i))
{α : Type u_1} {β : Type u_4} [PartialOrder α] [PartialOrder β] {u : β → α} (l : LowerAdjoint u) : l.IsClosed = set.Range (u ∘ ⇑l)
{G : Type u} [Group G] [Fintype G] {P n : ℕ} [hp : Fact (Nat.Prime P)] (hdvd : P ^ (n + 1) ∣ Fintype.Card G) {h : Subgroup G} (hH : Fintype.Card ↥h = P ^ n) : P ^ (n + 1) ∣ Fintype.Card ↥(h.Normalizer)
{E : Type u_1} {β : Type u_2} [AddCommGroup E] [TopologicalSpace E] [module ℝ E] [topological_AddGroup E] [has_Continuous_Smul ℝ E] [ordered_AddCommGroup β] [module ℝ β] [OrderedSmul ℝ β] {S : set E} {F : E → β} {A : E} (A_in_S : A ∈ S) (h_localmax : IsLocalMaxOn F S A) (h_conc : ConcaveOn ℝ S F) : IsMaxOn F S A
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {x : E} {n : ℕ} : iterated_fderiv 𝕜 (n + 1) F x = (⇑(Continuous_multilinear_Curry_Right_Equiv' 𝕜 n E F) ∘ iterated_fderiv 𝕜 n (λ (y : E), fderiv 𝕜 F y)) x
{ι : Type u_1} {R : Type u_2} [CommRing R] [LinearOrder ι] (S : Finset ι) (F g : ι → R) : S.Prod (λ (i : ι), F i - g i) = S.Prod (λ (i : ι), F i) - S.Sum (λ (i : ι), g i * (Finset.Filter (λ (_x : ι), _x < i) S).Prod (λ (j : ι), F j - g j) * (Finset.Filter (λ (j : ι), i < j) S).Prod (λ (j : ι), F j))
(P : ℕ) [Fact (Nat.Prime P)] (A : ℤ) : Zmod.legendre_Sym P A = 0 ↔ ↑A = 0
(i j : ℕ) (h : j + 1 = i) : AlgebraicTopology.DoldKan.C.Rel i j
{α : Type u_1} [MetricSpace α] {K : Nnreal} {F : α → α} (hF : ContractingWith K F) [Nonempty α] [CompleteSpace α] : Function.IsFixedPt F (ContractingWith.fixed_point F hF)
{α : Type u_1} [has_Mul α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LT.LT] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LE.LE] {A B C D : α} (h₁ : A < B) (h₂ : C < D) : A * C < B * D
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F g : α → m} (hF : (Function.MulSupport F).Finite) (hg : (Function.MulSupport g).Finite) : finprod (λ (i : α), F i * g i) = finprod (λ (i : α), F i) * finprod (λ (i : α), g i)
{α : Type u} [PseudoMetricSpace α] {S t : set α} : 0 ≤ metric.Hausdorff_dist S t
{K : Type u} [Field K] (S : Subfield K) {l : List K} : (∀ (x : K), x ∈ l → x ∈ S) → l.Sum ∈ S
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (u : E) {v : E} (hv : v ∈ (Submodule.Span 𝕜 {u})ᗮ) : HasInner.inner u v = 0
{R : Type u_1} {A : R} [CancelMonoidWithZero R] [Nontrivial R] : IsRegular A ↔ A ≠ 0
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {A : α} {S : set α} (F : α → m) (h : A ∉ S) (hs : (S ∩ Function.Support F).Finite) : finsum (λ (i : α), finsum (λ (h : i ∈ HasInsert.Insert A S), F i)) = F A + finsum (λ (i : α), finsum (λ (h : i ∈ S), F i))
{α : Type u_1} {n : Type u_4} [has_Zero α] [DecidableEq n] {A : Matrix n n α} (h : A.IsDiag) : Matrix.Diagonal A.diag = A
{R : Type u_1} [CommRing R] [IsDomain R] {F : Polynomial R} {P : Ideal R} (hP : P.Prime) (hfl : F.leading_Coeff ∉ P) (hfP : ∀ (n : ℕ), ↑n < F.degree → F.Coeff n ∈ P) (hfd0 : 0 < F.degree) (h0 : F.Coeff 0 ∉ P ^ 2) (hu : F._primitive) : Irreducible F
{α : Type u} [PseudoMetricSpace α] {S : set α} {x : α} (h : S.Nonempty) : Emetric.Inf_edist x S ≠ ⊤
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x₁ x₂ y z : v} (hx₁yne : x₁ ≠ y) (hx₁zne : x₁ ≠ z) (hx₂yne : x₂ ≠ y) (hx₂zne : x₂ ≠ z) {r : ℝ} (hx₁ : ∥x₁∥ = r) (hx₂ : ∥x₂∥ = r) (hy : ∥y∥ = r) (hz : ∥z∥ = r) : 2 • o.oangle (y - x₁) (z - x₁) = 2 • o.oangle (y - x₂) (z - x₂)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : EuclideanGeometry.angle P1 P2 P3 = Real.Pi) : HasDist.dist P3 P2 ≠ 0
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommMonoid β] [module 𝕜 E] [module 𝕜 β] [LinearOrder E] {S : set E} {F : E → β} (hs : Convex 𝕜 S) (hF : ∀ ⦃x y : E⦄, x ∈ S → y ∈ S → x < y → ∀ ⦃A B : 𝕜⦄, 0 < A → 0 < B → A + B = 1 → A • F x + B • F y < F (A • x + B • y)) : strict_ConcaveOn 𝕜 S F
{m : Type u_1} [AddZeroClass m] {P : m → Prop} (x : m) {S : set m} (hs : AddSubmonoid.Closure S = ⊤) (Hs : ∀ (x : m), x ∈ S → P x) (h1 : P 0) (HMul : ∀ (x y : m), P x → P y → P (x + y)) : P x
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) : ∥x + y∥ = ∥x∥ + ∥y∥ ↔ InnerProductGeometry.angle x y = 0
{D : set ℝ} (hD : Convex ℝ D) (hD₂ : IsOpen D) {F : ℝ → ℝ} (hF' : DifferentiableOn ℝ F D) (hF'' : ∀ (x : ℝ), x ∈ D → 0 < deriv^[2] F x) : strict_Convex_on ℝ D F
{r P : Nnreal} : ↑(r - P) = ↑r - ↑P
{G : Type u_1} [Group G] (h : ℕ → Subgroup G) (hH : IsDescendingCentralSeries h) (n : ℕ) : lower_central_series G n ≤ h n
(P : ℕ) [P_Prime : Fact (Nat.Prime P)] (q : ℚ) : padic_val_rat P q⁻¹ = -padic_val_rat P q
{k : Type u_1} {v : Type u_2} [Ring k] [AddCommGroup v] [module k v] {ι : Type u_4} (S : Finset ι) (P : ι → v) (W : ι → k) (hw : S.Sum (λ (i : ι), W i) = 1) : ⇑(S.affine_combination P) W = S.Sum (λ (i : ι), W i • P i)
{α : Type u} [Preorder α] {F : ℤ → α} (hF : Antitone F) (n : ℤ) {x : α} (h1 : F (n + 1) < x) (h2 : x < F n) (A : ℤ) : F A ≠ x
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {F : ℂ → E} {C : ℂ} {R C : ℝ} (hR : 0 < R) (hc : Continuous_on F (Metric.Sphere C R)) (hF : ∀ (z : ℂ), z ∈ Metric.Sphere C R → ∥F z∥ ≤ C) (hlt : ∃ (z : ℂ) (h : z ∈ Metric.Sphere C R), ∥F z∥ < C) : ∥∮ (z : ℂ) in C(C, R), F z∥ < 2 * Real.Pi * R * C
{α : Type u_1} [MeasurableSpace α] {F : ℕ → α → Ennreal} {g : α → Ennreal} (hF : ∀ (i : ℕ), Measurable (F i)) (lim : Filter.Tendsto F Filter.at_top (nhds g)) : Measurable g
{ι : Type u} {F g : ι → Nnreal} {A B : Nnreal} {P q : ℝ} (hpq : P.IsConjugateExponent q) (hF : has_Sum (λ (i : ι), F i ^ P) (A ^ P)) (hg : has_Sum (λ (i : ι), g i ^ q) (B ^ q)) : ∃ (C : Nnreal), C ≤ A * B ∧ has_Sum (λ (i : ι), F i * g i) C
{α : Type u_1} {β : Type u_2} {la : Filter α} {lb : Filter β} {F : α → set β} : Filter.Tendsto F la lb.Small_sets ↔ ∀ (t : set β), t ∈ lb → (∀ᶠ (x : α) in la, F x ⊆ t)
(R : Type u_1) [CommRing R] [local_Ring R] (q : ℕ) [Char_R_q : Char_P R q] : q = 0 ∨ Prime_Pow q
(x y : Pgame) : x < y ∨ x.Equiv y ∨ y < x ∨ x.Fuzzy y
{m : Type u_1} [MulOneClass m] (S : Submonoid m) : S = ⊥ ∨ Nontrivial ↥S
{R : Type u_1} {A : R} [Monoid R] (n : ℕ) (rla : IsLeftRegular A) : IsLeftRegular (A ^ n)
{G : Type u_1} [Group G] (h : Subgroup G) {x : G} : x ∈ h → x⁻¹ ∈ h
(𝕜 : Type u_1) (E : Type u_2) [OrderedSemiring 𝕜] [ordered_AddCommGroup E] [module 𝕜 E] [OrderedSmul 𝕜 E] : (Convex_cone.PositiveCone 𝕜 E).salient
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S u : set E} {F : E → F} {x : E} {n : ℕ} (hu : u ∈ nhds_within x S) (hs : UniqueDiffOn 𝕜 S) (xs : x ∈ S) : iterated_fderiv_within 𝕜 n F (S ∩ u) x = iterated_fderiv_within 𝕜 n F S x
{C : Type u₁} [CategoryTheory.Category C] (P : Cᵒᵖ ⥤ Type (max v₁ u₁)) {x : C} (S : CategoryTheory.Sieve x) : CategoryTheory.Presieve.IsSheafFor P ⇑S ↔ Nonempty (CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fork.ofι (CategoryTheory.Equalizer.fork_Map P ⇑S) _))
{x : Type u} {Y : Type v} [Preorder x] [Preorder Y] (F : x ⥤ Y) : Monotone F.obj
{R₁ : Type u_1} {R₂ : Type u_2} [Semiring R₁] [Semiring R₂] {σ₁₂ : R₁ →+* R₂} {m₁ : Type u_4} [TopologicalSpace m₁] [AddCommMonoid m₁] {m₂ : Type u_6} [TopologicalSpace m₂] [AddCommMonoid m₂] [module R₁ m₁] [module R₂ m₂] [Ring_hom_surjective σ₁₂] [TopologicalSpace R₁] [TopologicalSpace R₂] [has_Continuous_Smul R₁ m₁] [has_Continuous_Add m₁] [has_Continuous_Smul R₂ m₂] [has_Continuous_Add m₂] {F : m₁ →sl[σ₁₂] m₂} (hF' : DenseRange ⇑F) {S : Submodule R₁ m₁} (hs : S.topological_Closure = ⊤) : (Submodule.Map ↑F S).topological_Closure = ⊤
{α : Type u_1} {ι : sort u_4} {ι' : sort u_5} {S : ι → ι' → set α} : (⋃ (j : ι'), ⋂ (i : ι), S i j) ⊆ ⋂ (i : ι), ⋃ (j : ι'), S i j
{α : Type u_1} {β : Type u_2} {m : Type u_5} [CommMonoid m] {g : β → m} (e : α → β) (hE₀ : Function.Bijective e) : finprod (λ (i : α), g (e i)) = finprod (λ (j : β), g j)
 : Real.cos (Real.Pi / 6) ^ 2 = 3 / 4
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {F : β → γ} {x : α × β} (hF : Continuous_at F x.Snd) : Continuous_at (λ (x : α × β), F x.Snd) x
{S : Type u_2} [CommRing S] {R : Type u_3} [CommRing R] [Algebra R S] {A : Type u_4} [CommRing A] [Algebra R A] [Algebra S A] [IsScalarTower R S A] {B : power_Basis S A} (hB : IsIntegral R B.gen) [IsDomain S] (hmin : minpoly S B.gen = Polynomial.Map (Algebra_Map R S) (minpoly R B.gen)) (n : ℕ) (i : Fin B.dim) : IsIntegral R (⇑(⇑(B.Basis.repr) (B.gen ^ n)) i)
{α : Type u_1} {β : Type u_2} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] [Nonempty β] [has_One α] {F : β → α} (hF : Continuous F) (h : HasCompactMulSupport F) : ∃ (x : β), ∀ (y : β), F y ≤ F x
{m : Type u_1} {κ : Type u_2} [AddCommMonoid m] (S : Finset m) [Fintype κ] (C : m → κ) : ∃ (A : ℕ) (h : A > 0) (B : m) (C : κ), ∀ (S : m), S ∈ S → C (A • S + B) = C
{R : Type u_1} {A : R} [Monoid R] {n : ℕ} (n0 : 0 < n) : IsRightRegular (A ^ n) ↔ IsRightRegular A
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : LocalHomeomorph α β) {B : β} (hb : B ∈ e.to_local_Equiv.Target) {F : β → E} {g : β → F} : F =O[nhds B] g ↔ (F ∘ ⇑e) =O[nhds (⇑(e.Symm) B)] (g ∘ ⇑e)
(A : Type u_2) (K : Type u_3) [CommRing A] [Field K] [IsDomain A] [Algebra A K] [_fraction_Ring A K] (L : Type u_4) [Field L] [Algebra K L] [Finite_dimensional K L] [Algebra A L] [IsScalarTower A K L] : ∃ (S : Finset L) (B : Basis ↥S K L), ∀ (x : ↥S), IsIntegral A (⇑B x)
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {F : m →* P} (x : m) : ⇑(Con.Ker_Lift F) ↑x = ⇑F x
{α : Type u_1} {S : set (set α)} (hs : IsPiSystem S) : MeasurableSpace.generate_from S = (MeasurableSpace.DynkinSystem.generate S).to_MeasurableSpace _
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} {v₂ : Type u_5} {P₂ : Type u_6} [AddCommGroup v₂] [module k v₂] [AddTorsor v₂ P₂] {P : ι → P} (e : P ≃ᵃ[k] P₂) : AffineIndependent k (⇑e ∘ P) ↔ AffineIndependent k P
{α : Type u_1} {β : Type u_2} [conditionally_CompleteLattice α] [SemilatticeSup β] {F g : β → α} (h : Antitone (λ (n : β), set.icc (F n) (g n))) (h' : ∀ (n : β), F n ≤ g n) : (⨆ (n : β), F n) ∈ ⋂ (n : β), set.icc (F n) (g n)
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) : S.normed_Mk._Quotient
{C : Type u} [CategoryTheory.Category C] {A B R : C} {F g : R ⟶ A} {q : A ⟶ B} (h : CategoryTheory.IsKernelPair q F g) : CategoryTheory.IsReflexivePair F g
{α : Type u} [PseudoEmetricSpace α] (F : ℕ → α) {m n : ℕ} (h : m ≤ n) : HasEdist.edist (F m) (F n) ≤ (Finset.Ico m n).Sum (λ (i : ℕ), HasEdist.edist (F i) (F (i + 1)))
{α : sort u_1} {β : sort u_2} {γ : sort u_3} {F : α → β → γ} (hF : Function.Injective2 F) (B : β) : Function.Injective (λ (A : α), F A B)
{α : Type u_1} (F : α → α) (x : α) : Function.IsPeriodicPt F 0 x
{α : Type u_3} {β : Type u_4} [Linear_ordered_Field α] {l : Filter β} {F : β → α} {r : α} (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_top) : Filter.Tendsto (λ (x : β), F x / r) l Filter.at_top
{R : Type u_2} {Γ₀ : Type u_3} {Γ'₀ : Type u_4} [Linear_ordered_AddCommMonoid_WithTop Γ₀] [Linear_ordered_AddCommMonoid_WithTop Γ'₀] [Ring R] {v₁ : AddValuation R Γ₀} {v₂ : AddValuation R Γ'₀} {S : Type u_1} [Ring S] (F : S →+* R) (h : v₁._Equiv v₂) : (AddValuation.comap F v₁)._Equiv (AddValuation.comap F v₂)
{G : Type u_4} [NormedGroup G] [NormedSpace ℝ G] {S : set G} (conv : Convex ℝ S) (hs : (Interior S).Nonempty) : UniqueDiffOn ℝ S
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {J : Type v} [Fintype J] {F : J → C} [CategoryTheory.Limits.HasBiproduct F] : Finset.Univ.Sum (λ (j : J), CategoryTheory.Limits.biproductπ F j ≫ CategoryTheory.Limits.biproductι F j) = 𝟙 (⨁ F)
{α : Type u_1} [Preorder α] [OrderTop α] {A : α} : IsCoatom A → IsAtom (⇑order_dual.to_dual A)
{α : Type u} {β : Type v} [PseudoMetricSpace α] [PseudoMetricSpace β] {F : α → β} : Isometry F ↔ ∀ (x y : α), HasDist.dist (F x) (F y) = HasDist.dist x y
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {E' : Type u_7} [InnerProductSpace 𝕜 E'] {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 ⇑v) (F : E ≃ₗᵢ[𝕜] E') : Orthonormal 𝕜 ⇑(v.Map F.to_Linear_Equiv)
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m →* P} (hg : ∀ (y : ↥S), IsUnit (⇑g ↑y)) {x y : m} (h : ⇑(F.to_Map) x = ⇑(F.to_Map) y) : ⇑g x = ⇑g y
{α : Type u_1} {β : Type u_2} [Nontrivial α] {F : α → β} (hF : Function.Injective F) (y : β) : ∃ (x : α), F x ≠ y
{α : Type u_1} [semi_NormedRing α] [NormOneClass α] (A : α) (n : ℕ) : ∥A ^ n∥ ≤ ∥A∥ ^ n
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMaxOrder α] {A : α} {S : set α} : S ∈ nhds_within A (set.ici A) ↔ ∃ (u : α) (h : u ∈ set.ioi A), set.Ico A u ⊆ S
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {F : E → ℝ} {S : set E} {x y : E} {F' : E → (E →L[ℝ] ℝ)} (hF : ∀ (x : E), x ∈ S → HasFderivWithinAt F (F' x) S x) (hs : Convex ℝ S) (xs : x ∈ S) (ys : y ∈ S) : ∃ (z : E) (h : z ∈ Segment ℝ x y), F y - F x = ⇑(F' z) (y - x)
(P : ℕ) [hp : Fact (Nat.Prime P)] {q r : ℚ} : padic_norm P (q + r) ≤ LinearOrder.max (padic_norm P q) (padic_norm P r)
{R : Type u_1} [CommRing R] : IsOpen_Map ⇑(Prime_Spectrum.comap Polynomial.C)
{α : Type u} {G : Type u_1} [Group G] (F g : free_Group α →* G) (h : ∀ (A : α), ⇑F (free_Group.of A) = ⇑g (free_Group.of A)) : F = g
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] {F : Filter α} {A : α} (hl : Filter._bounded has_LE.LE F) (hg : Filter._bounded Ge F) (hs : F.limsup = A) (hi : F.liminf = A) : F ≤ nhds A
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {S : set E} {F : E → F} {n : WithTop ℕ} (hF : ContDiff_on 𝕜 n F S) (g : G →L[𝕜] E) : ContDiff_on 𝕜 n (F ∘ ⇑g) (⇑g ⁻¹' S)
{m : Type u_1} [AddMonoid m] (x : m) : _Add_Submonoid (Multiples x)
{A B C : ℝ} : IntervalIntegrable (λ (x : ℝ), (x - C)⁻¹) MeasureTheory.MeasureSpace.Volume A B ↔ A = B ∨ C ∉ set.Interval A B
{α : Type u_1} {m : set α → Ennreal} {S t : set α} (h : ∀ (u : set α), (S ∩ u).Nonempty → (t ∩ u).Nonempty → m u = ⊤) : ⇑(MeasureTheory.OuterMeasure.bounded_by m) (S ∪ t) = ⇑(MeasureTheory.OuterMeasure.bounded_by m) S + ⇑(MeasureTheory.OuterMeasure.bounded_by m) t
{D : set ℝ} (hD : Convex ℝ D) {F : ℝ → ℝ} (hF : Continuous_on F D) (hF' : ∀ (x : ℝ), x ∈ Interior D → deriv F x < 0) : StrictAntiOn F D
{α : Type u} {β : Type v} [TopologicalSpace α] {F : Filter β} {g : β → α} (h : ∃ (A : α), Filter.Tendsto g F (nhds A)) : Filter.Tendsto g F (nhds (lim F g))
{ι : Type u_1} {R : Type u_2} {N : Type u_5} [Ring R] [AddCommGroup N] [module R N] [NoZeroSmulDivisors R N] (P : ι → Submodule R N) (hp : CompleteLattice.Independent P) {v : ι → N} (hv : ∀ (i : ι), v i ∈ P i) (hv' : ∀ (i : ι), v i ≠ 0) : LinearIndependent R v
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {n : WithTop ℕ} {S : set E} {F g : E → 𝕜} (hF : ContDiff_on 𝕜 n F S) (hg : ContDiff_on 𝕜 n g S) : ContDiff_on 𝕜 n (λ (x : E), F x * g x) S
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {F : α → β} (IsOpenMap : IsOpen_Map F) (Cont : Continuous F) (surj : Function.Surjective F) : QuotientMap F
{m : Type u_1} [has_Mul m] (S : Subsemigroup m) {x y : m} : x ∈ S → y ∈ S → x * y ∈ S
{R : Type u_1} [CommRing R] {S : Type u_2} [CommRing S] [Algebra R S] [IsDomain S] (h : Algebra.IsIntegral R S) (P : Ideal R) [P.Prime] (hP : (Algebra_Map R S).Ker ≤ P) : ∃ (q : Ideal S), q.Prime ∧ Ideal.comap (Algebra_Map R S) q = P
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) [CategoryTheory.Limits.HasLimits C] (i : D.to_GlueData.J) (U : TopologicalSpace.Opens ↥((D.to_GlueData.U i).carrier)) : D.Diagram_over_IsOpen_π U i ≫ D.ι_Inv_App_π_Eq_Map U ≫ D.ι_Inv_App U = 𝟙 (CategoryTheory.Limits.Limit(D.Diagram_over_IsOpen U))
{𝕜 : Type u_1} [_R_or_C 𝕜] {F : Type u_2} [semi_NormedGroup F] [NormedSpace 𝕜 F] [NormedSpace ℝ F] [IsScalarTower ℝ 𝕜 F] (fr : F →L[ℝ] ℝ) (x : F) : ∥⇑(fr.to_Linear_Map.extend_to𝕜') x∥ ≤ ∥fr∥ * ∥x∥
{ι : Type u} {x : Type v} [TopologicalSpace x] {S : set x} [NormalSpace x] (hs : IsClosed S) (U : ι → set x) (ho : ∀ (i : ι), IsOpen (U i)) (hF : locally_Finite U) (hU : S ⊆ ⋃ (i : ι), U i) : ∃ (F : BumpCovering ι x S), F._subordinate U
{α : Type u_1} {n : Type u_4} {m : Type u_5} [has_Zero α] {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α} {D : Matrix n n α} : (Matrix.from_blocks A B C D).IsDiag ↔ A.IsDiag ∧ B = 0 ∧ C = 0 ∧ D.IsDiag
 : set.Unbounded has_LT.LT {B : Ordinal | B.Card.Ord = B ∧ Ordinal.omega ≤ B}
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : E → ℝ} {A : E} (h : IsLocalExtr F A) : fderiv ℝ F A = 0
{α : Type u} [TopologicalSpace α] {S : set (α × α)} {x : α} (hx : S ∈ nhds (x, x)) : ∃ (U : set α), IsOpen U ∧ x ∈ U ∧ U ×ˢ U ⊆ S
{C : Type u} [CategoryTheory.Category C] {D : Type u_1} [CategoryTheory.Category D] [CategoryTheory.Abelian C] [CategoryTheory.HasInjectiveResolutions C] [CategoryTheory.Abelian D] {F G : C ⥤ D} [F.Additive] [G.Additive] (α : F ⟶ G) (n : ℕ) {x : C} (P : CategoryTheory.InjectiveResolution x) : (CategoryTheory.Nat_Trans.Right_derived α n).App x = (F.Right_derived_obj_iso n P).hom ≫ (homology_Functor D (ComplexShape.Up ℕ) n).Map ((CategoryTheory.Nat_Trans.Map_homological_Complex α (ComplexShape.Up ℕ)).App P.cocomplex) ≫ (G.Right_derived_obj_iso n P).Inv
{h : Type u_1} {m : Type u_2} [TopologicalSpace h] [TopologicalSpace m] [ChartedSpace h m] {h' : Type u_3} {m' : Type u_4} [TopologicalSpace h'] [TopologicalSpace m'] [ChartedSpace h' m'] {G : StructureGroupoid h} {G' : StructureGroupoid h'} {e e' : LocalHomeomorph m h} {F F' : LocalHomeomorph m' h'} {P : (h → h') → set h → h → Prop} {g : m → m'} {S : set m} {x : m} (hG : G.LocalInvariantProp G' P) (hE : e ∈ StructureGroupoid.MaximalAtlas m G) (xe : x ∈ e.to_local_Equiv.Source) (hE' : e' ∈ StructureGroupoid.MaximalAtlas m G) (xe' : x ∈ e'.to_local_Equiv.Source) (hF : F ∈ StructureGroupoid.MaximalAtlas m' G') (xf : g x ∈ F.to_local_Equiv.Source) (hF' : F' ∈ StructureGroupoid.MaximalAtlas m' G') (xf' : g x ∈ F'.to_local_Equiv.Source) (hgs : Continuous_within_at g S x) (h : P (⇑F ∘ g ∘ ⇑(e.Symm)) (e.to_local_Equiv.Target ∩ ⇑(e.Symm) ⁻¹' (S ∩ g ⁻¹' F.to_local_Equiv.Source)) (⇑e x)) : P (⇑F' ∘ g ∘ ⇑(e'.Symm)) (e'.to_local_Equiv.Target ∩ ⇑(e'.Symm) ⁻¹' (S ∩ g ⁻¹' F'.to_local_Equiv.Source)) (⇑e' x)
{P : ℕ} (hp : Nat.Prime P) {R : Type u_1} [CommRing R] [IsDomain R] {n : ℕ} (hn : n ≠ 0) (h : Irreducible (Polynomial.cyclotomic (P ^ n) R)) : Irreducible (Polynomial.cyclotomic P R)
{β : Type u} {α : Type v} {S : Finset α} [CommMonoid β] (F : α → β) {P : α → Prop} [Decidable_Pred P] (h : ∀ (x : α), x ∈ S → P x) : (Finset.Subtype P S).Prod (λ (x : Subtype P), F ↑x) = S.Prod (λ (x : α), F x)
{α : Type u_3} {β : Type u_4} [Linear_ordered_Field α] {l : Filter β} {F : β → α} {r : α} (hr : r < 0) (hF : Filter.Tendsto F l Filter.at_top) : Filter.Tendsto (λ (x : β), F x * r) l Filter.at_IsBot
{m : Type u_3} {N : Type u_4} [has_Zero m] [has_Zero N] {F g : ZeroHom m N} (h : F = g) (x : m) : ⇑F x = ⇑g x
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace ↥K] : Function.involutive ⇑(reflection K)
{R : Type u_1} [CommRing R] (m : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] (N : Submonoid S) (t : Type u_4) [CommRing t] [Algebra R t] [Algebra S t] [IsScalarTower R S t] [IsLocalization m S] [IsLocalization N t] : IsLocalization (IsLocalization.Localization_Localization_Submodule m N) t
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_3} [DecidableEq ι] [Fintype ι] (e : Basis ι R m) (x : Orientation R m ι) : x ≠ e.Orientation ↔ x = -e.Orientation
{B : ℕ} {l : List ℕ} (hl : ∀ (x : ℕ), x ∈ l → x < B + 2) : Nat.of_digits (B + 2) l < (B + 2) ^ l.length
{C : Type u₁} [CategoryTheory.Category C] {x Y : C} (t : CategoryTheory.Limits.IsTerminal x) (F : x ⟶ Y) : CategoryTheory.Mono F
{G : Type u} [Group G] [Fintype G] (P : ℕ) {n : ℕ} [Fact (Nat.Prime P)] (hdvd : P ^ n ∣ Fintype.Card G) : ∃ (K : Subgroup G), Fintype.Card ↥K = P ^ n
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m →* P} {t : Submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ t) {q : Type u_4} [CommMonoid q] {k : t.Localization_Map q} (z : N) : ⇑(F.Map hy k) z * ⇑(k.to_Map) (⇑g ↑((F.sec z).Snd)) = ⇑(k.to_Map) (⇑g (F.sec z).fst)
{α : Type u_1} [cancel_CommMonoid_with_Zero α] [dec_irr : Π (P : Associates α), Decidable (Irreducible P)] [Unique_factorization_Monoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {P A : Associates α} (hp : Irreducible P) {n : ℕ} (h : A ∣ P ^ n) : A = P ^ P.count A.Factors
{n : ℕ} (P : Fin (n + 1)) (i : Fin n) : P < ⇑(P.Succ_above) i ↔ P ≤ ⇑Fin.cast_Succ i
{α : Type u_1} [AddCommMonoid α] (m m N : ℕ) (F : (Σ (n : ℕ), Fin n → ℕ) → α) (g : (Σ (n : ℕ), Composition n) → α) (h : ∀ (e : Σ (n : ℕ), Fin n → ℕ) (hE : e ∈ FormalMultilinearSeries.Comp_partial_Sum_Source m m N), F e = g (FormalMultilinearSeries.Comp_change_of_variables m m N e hE)) : (FormalMultilinearSeries.Comp_partial_Sum_Source m m N).Sum (λ (e : Σ (n : ℕ), Fin n → ℕ), F e) = (FormalMultilinearSeries.Comp_partial_Sum_Target m m N).Sum (λ (e : Σ (n : ℕ), Composition n), g e)
{K : Type u} [Field K] (S : Subfield K) {x : K} : x ∈ S → -x ∈ S
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m →+ P} {t : Add_Submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ t) {q : Type u_4} [AddCommMonoid q] {k : t.Localization_Map q} {A : Type u_5} [AddCommMonoid A] {U : Add_Submonoid A} {R : Type u_6} [AddCommMonoid R] (j : U.Localization_Map R) {l : P →+ A} (hl : ∀ (W : ↥t), ⇑l ↑W ∈ U) (x : N) : ⇑(k.Map hl j) (⇑(F.Map hy k) x) = ⇑(F.Map _ j) x
{α : Type u_1} {δ : Type u_5} [TopologicalSpace α] [MeasurableSpace α] [BorelSpace α] [MeasurableSpace δ] [complete_LinearOrder α] [OrderTopology α] [TopologicalSpace.SecondCountableTopology α] {ι : Type u_2} {ι' : Type u_3} {F : ι → δ → α} {u : Filter ι} (hF : ∀ (i : ι), Measurable (F i)) {P : ι' → Prop} {S : ι' → set ι} (hu : u.has_countable_Basis P S) (hs : ∀ (i : ι'), (S i).countable) : Measurable (λ (x : δ), u.liminf (λ (i : ι), F i x))
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) : hb.oangle (-x) y + hb.oangle (-y) x = 0
{α : Type u} [PseudoEmetricSpace α] (δ : ℝ) (E : set α) : Closure E ⊆ Metric.Cthickening δ E
(R : Type u_1) [Ring R] : Algebra_Map ℤ R = Int.cast_Ring_hom R
{ι : Type u} {x : Type v} [TopologicalSpace x] {S : set x} [NormalSpace x] (hs : IsClosed S) (U : ι → set x) (ho : ∀ (i : ι), IsOpen (U i)) (hF : locally_Finite U) (hU : S ⊆ ⋃ (i : ι), U i) : ∃ (F : PartitionOfUnity ι x S), F._subordinate U
{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3
{G₀ : Type u_2} [Group_with_Zero G₀] (A : G₀) : A * A⁻¹ * A = A
(𝕜 : Type u_1) (E : Type u_2) [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] : GaloisConnection Submodule.Orthogonal Submodule.Orthogonal
{m : Type u_1} [has_Add m] {S : set m} : S ⊆ ↑(Add_Subsemigroup.Closure S)
 : Dense {x : ℝ | Liouville x}
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] {S : Finset α} {t : Finset β} {F : α → β} {B : m} [Linear_ordered_CommRing m] (ht : t.Nonempty) (hb : ↑(S.Card) ≤ t.Card • B) : ∃ (y : β) (h : y ∈ t), ↑((Finset.Filter (λ (x : α), F x = y) S).Card) ≤ B
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] (h : ∀ (x : E), module.rank F ↥F⟮x⟯ = 1) : ⊥ = ⊤
{α : Type u_1} {r : Setoid α} {x y : α} : Quotient.Mk' x = Quotient.Mk' y ↔ r.Rel x y
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : α → E} {g' : α → F'} {l : Filter α} : F =o[l] g' → (F =o[l] λ (x : α), ∥g' x∥)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {u : ℕ → E} {l : E} (h : Filter.Tendsto u Filter.at_top (nhds l)) : Filter.Tendsto (λ (n : ℕ), (↑n)⁻¹ • (Finset.Range n).Sum (λ (i : ℕ), u i)) Filter.at_top (nhds l)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {A u' : α} {S : set α} (hu' : A < u') : S ∈ nhds_within A (set.ici A) ↔ ∃ (u : α) (h : u ∈ set.ioi A), set.Ico A u ⊆ S
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y z : v} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x y + hb.oangle y z + hb.oangle z x = 0
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 P3 : P) : EuclideanGeometry.angle P1 P2 P3 = EuclideanGeometry.angle P3 P2 P1
{R : Type u_1} {S : Type u_2} [CommRing R] [CommRing S] (y : R) [Algebra R S] [IsLocalization.Away y S] [h : Ideal._jacobson R] : Ideal._jacobson S
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} [CharZero k] {S : Finset ι} (P : ι → P) (h : S.Nonempty) : Finset.centroid k S P ∈ affine_Span k (set.Range P)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P : ι → P) (h : S.Sum (λ (i : ι), W i) = 0) (B₁ B₂ : P) : ⇑(S.weighted_vsub_of_point P B₁) W = ⇑(S.weighted_vsub_of_point P B₂) W
(R : Type u_1) [CommRing R] (m : Type u_2) [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] [Nontrivial R] : ⇑(LinearMap.trace R m) 1 = ↑(Finite_dimensional.finrank R m)
{α : Type u_1} {β : Type u_2} [MulOneClass α] [comm_Group β] {F : α → β} (hF : _Monoid_hom F) : _Monoid_hom (λ (A : α), (F A)⁻¹)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] (P : FormalMultilinearSeries 𝕜 E F) {x y : E} (h : ↑∥x∥₊ + ↑∥y∥₊ < P.radius) : (P.change_origin x).Sum y = P.Sum (x + y)
{G : Type u} [CategoryTheory.groupoid G] [IsFreeGroupoid G] {A B : G} : Nonempty (A ⟶ B) → Nonempty (Quiver.Path (symgen A) (symgen B))
{K : Type u_4} {v : Type u} {v' : Type u_8} [Field K] [AddCommGroup v] [AddCommGroup v'] [module K v] [module K v'] {P : Submodule K v} (F : ↥P →ₗ[K] v') : ∃ (g : v →ₗ[K] v'), g.Comp P.Subtype = F
(R : Type u) [Semiring R] (q : ℕ) [hp : Char_P R 0] [hq : ExpChar R q] : q = 1
{α : Type u_3} {β : Type u_4} [Linear_ordered_Field α] {l : Filter β} {F : β → α} {r : α} (hr : r < 0) (hF : Filter.Tendsto F l Filter.at_IsBot) : Filter.Tendsto (λ (x : β), r * F x) l Filter.at_top
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {S : set α} {P : Filter ι} [UniformSpace γ] {g : β → γ} (h : TendstoUniformlyOn F F P S) (hg : uniform_Continuous g) : TendstoUniformlyOn (λ (i : ι), g ∘ F i) (g ∘ F) P S
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} {S : set E} {x : E} {F' : TangentSpace (model_with_corners_self 𝕜 E) x →L[𝕜] TangentSpace (model_with_corners_self 𝕜 E') (F x)} : HasMfderivWithinAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F S x F' → HasFderivWithinAt F F' S x
{n : ℕ} {i j : Fin (n + 1)} (h : i ≤ j) : SimplexCategoryσ (⇑Fin.cast_Succ i) ≫ SimplexCategoryσ j = SimplexCategoryσ j.Succ ≫ SimplexCategoryσ i
{R : Type u_1} {S : Type u_4} [CommRing R] [CommRing S] (F : R →+* S) (P : Polynomial R) (x : S) (h : Polynomial.Eval₂ F x P = 0) : F.IsIntegral_elem (⇑F P.leading_Coeff * x)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {F' : E ≃L[𝕜] F} {g : F → E} {A : F} (hg : Continuous_at g A) (hF : HasFderivAt F ↑F' (g A)) (hfg : ∀ᶠ (y : F) in nhds A, F (g y) = y) : HasFderivAt g ↑(F'.Symm) A
{α : Type u_1} [Linear_ordered_Field α] {A B C D : α} (hc : C ≠ 0) (hD : D ≠ 0) : A / C ≤ B / D → (A * D - B * C) / (C * D) ≤ 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S1 S2 : AffineSubspace k P) : ¬S1 ≤ S2 ↔ ∃ (P : P) (h : P ∈ S1), P ∉ S2
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) : v.Int_Valuation_def 1 = 1
{α : Type u_1} [CommMonoid α] {A B : α} {u : αˣ} : ↑u * A ∣ B ↔ A ∣ B
{m : Type u_1} {R : Type u_4} [non_unital_non_assoc_Semiring R] [set_like m R] [MulMemClass m R] {S : m} {A B : R} (ha : A ∈ AddSubmonoid.Closure ↑S) (hb : B ∈ S) : A * B ∈ AddSubmonoid.Closure ↑S
(z : ℂ) : ↑(z.re) = (z + ⇑(Star_Ring_end ℂ) z) / 2
{m : Type u_2} {n : Type u_3} {R : Type u_7} {α : Type v} [HasStar R] [HasStar α] [HasScalar R α] [Star_module R α] (C : R) (m : Matrix m n α) : (C • m).Conj_transpose = HasStar.Star C • m.Conj_transpose
{n : ℕ} {i : Fin (n + 2)} {j : Fin (n + 1)} (h : i ≤ ⇑Fin.cast_Succ j) : SimplexCategoryδ (⇑Fin.cast_Succ i) ≫ SimplexCategoryσ j.Succ = SimplexCategoryσ j ≫ SimplexCategoryδ i
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {J : Type v} [Fintype J] (F : J → C) [CategoryTheory.Limits.HasProduct F] : CategoryTheory.Limits.HasBiproduct F
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] [CompleteSpace E] (g : E →ₗ[𝕜] F) (hg : IsClosed ↑(g.graph)) : Continuous ⇑g
{𝕜 : Type u_1} {E : Type u_2} [NormedField 𝕜] [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [has_Continuous_Smul 𝕜 E] : ⋃₀set_of (Bornology._vonN_bounded 𝕜) = set.Univ
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} {A : α} : finprod (λ (i : α), finprod (λ (h : i ∈ {A}), F i)) = F A
{R : Type u_1} [NormedRing R] [CompleteSpace R] : IsOpen {x : R | IsUnit x}
{m : Type u_1} {N : Type u_2} [MulOneClass m] [MulOneClass N] {F g : m →* N} {S : set m} (h : set.Eq_on ⇑F ⇑g S) : set.Eq_on ⇑F ⇑g ↑(Submonoid.Closure S)
{𝕂 : Type u_1} {𝔸 : Type u_2} [_R_or_C 𝕂] [NormedRing 𝔸] [normed_Algebra 𝕂 𝔸] [CompleteSpace 𝔸] {x y : 𝔸} (hxy : Commute x y) : Exp 𝕂 (x + y) = Exp 𝕂 x * Exp 𝕂 y
{m : Type u_3} {N : Type u_4} [MulZeroOneClass m] [MulZeroOneClass N] {F g : m →*₀ N} (h : F = g) (x : m) : ⇑F x = ⇑g x
{R : Type u_1} {K : Type u_2} [CommRing R] [Field K] [Algebra R K] [_fraction_Ring R K] [IsDomain R] [IsDedekindDomain R] [Fintype (class_Group R K)] : Fintype.Card (class_Group R K) = 1 ↔ _principal_Ideal_Ring R
{α : Type u} [Group α] [has_LT α] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LT.LT] {A : α} : 1 < A⁻¹ ↔ A < 1
{α : Type u} [Ring α] {A B : α} : A ∣ A + B ↔ A ∣ B
{ι : Type W} {R : Type u} [Ring R] [RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {J : set m} (v : Basis ι R m) (hJ : Submodule.Span R J = ⊤) : Cardinal.Mk ↥(set.Range ⇑v) ≤ Cardinal.Mk ↥J
{R : Type u} [Ring R] {S : set R} {P : R → Prop} {x : R} (h : x ∈ Subring.Closure S) (Hs : ∀ (x : R), x ∈ S → P x) (h0 : P 0) (h1 : P 1) (HAdd : ∀ (x y : R), P x → P y → P (x + y)) (Hneg : ∀ (x : R), P x → P (-x)) (HMul : ∀ (x y : R), P x → P y → P (x * y)) : P x
{P : Prop} (A : Erased P) : P
{α : Type u_1} {ι : Type u_4} [LinearOrder α] [DecidableEq ι] (F : ι → α) {P : Finset ι → Prop} (S : Finset ι) (h0 : P ∅) (step : ∀ (A : ι) (S : Finset ι), A ∉ S → (∀ (x : ι), x ∈ S → F A ≤ F x) → P S → P (HasInsert.Insert A S)) : P S
{m : Type u_1} [AddMonoid m] {ι : Type u_2} [hι : Nonempty ι] {S : ι → set m} (hs : ∀ (i : ι), _Add_Submonoid (S i)) (Directed : ∀ (i j : ι), ∃ (k : ι), S i ⊆ S k ∧ S j ⊆ S k) : _Add_Submonoid (⋃ (i : ι), S i)
{α : Type u_1} {ι : Type u_2} {ι' : Type u_3} [Lattice α] [OrderBot α] {S : set ι'} {g : ι' → Finset ι} {F : ι → α} (hs : S.Pairwise_Disjoint (λ (i' : ι'), (g i').Sup F)) (hg : ∀ (i : ι'), i ∈ S → ↑(g i).Pairwise_Disjoint F) : (⋃ (i : ι') (h : i ∈ S), ↑(g i)).Pairwise_Disjoint F
{G : Type u_1} [div_Inv_Monoid G] (A B : G) : A / B = A * B⁻¹
(x : ℤ) : ↑(x.Nat_Abs) ^ 2 = x ^ 2
(R : Type u) (m : Type v) [CommRing R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] (N : Type v) [AddCommGroup N] [module R N] [module.free R N] : module.rank R (TensorProduct R m N) = module.rank R m * module.rank R N
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} (h : HasInner.inner x y = 0) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y : m} {r : R} (h : SameRay R x y) (hr : 0 < r) : SameRay R (r • x) y
{C : Type u} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) {A A' B B' : C} [CategoryTheory.Limits.HasBinaryCoproduct A B] [CategoryTheory.Limits.HasBinaryCoproduct A' B'] [CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)] [CategoryTheory.Limits.HasBinaryCoproduct (F.obj A') (F.obj B')] (F : A ⟶ A') (g : B ⟶ B') [CategoryTheory.IsIso (CategoryTheory.Limits.Coprod_comparison F A B)] [CategoryTheory.IsIso (CategoryTheory.Limits.Coprod_comparison F A' B')] : CategoryTheory.Inv (CategoryTheory.Limits.Coprod_comparison F A B) ≫ CategoryTheory.Limits.Coprod.Map (F.Map F) (F.Map g) = F.Map (CategoryTheory.Limits.Coprod.Map F g) ≫ CategoryTheory.Inv (CategoryTheory.Limits.Coprod_comparison F A' B')
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.NormalMonoCategory C] {x Y Z : C} (A : x ⟶ Z) (B : Y ⟶ Z) [CategoryTheory.Mono A] [CategoryTheory.Mono B] : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan A B)
{α : Type u} {β : Type v} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] {F : Filter β} {u : β → α} {A : α} (hinf : A ≤ F.liminf u) (hsup : F.limsup u ≤ A) (h : Filter._bounded_under has_LE.LE F u . "_bounded_Default") (h' : Filter._bounded_under Ge F u . "_bounded_Default") : Filter.Tendsto u F (nhds A)
{C : Type u₁} [CategoryTheory.Category C] {x Y : C} (t : CategoryTheory.Limits.IsInitial x) (F g : x ⟶ Y) : F = g
{m : Type u_5} [AddCommMonoid m] (h : module ℕ m) (n : ℕ) (x : m) : n • x = n • x
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {x : 𝕜} {S : set 𝕜} (hx : x ∈ S) : Star_Convex 𝕜 x S → S.Ord_connected
{𝕜 : Type u_1} {E : Type u_2} [semi_NormedRing 𝕜] [AddCommGroup E] [module 𝕜 E] {t t' : TopologicalSpace E} (h : t ≤ t') {S : set E} (hs : Bornology._vonN_bounded 𝕜 S) : Bornology._vonN_bounded 𝕜 S
{α : Type u} {β : Type v} [PseudoMetricSpace α] [PseudoMetricSpace β] {F : α → β} (hF : Isometry F) (x y : α) : HasDist.dist (F x) (F y) = HasDist.dist x y
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (F : E →L[𝕜] F) [CompleteSpace F] [CompleteSpace E] (surj : Function.Surjective ⇑F) : IsOpen_Map ⇑F
 : Real.sin (Real.Pi / 6) = 1 / 2
{C : Type u₁} [CategoryTheory.Category C] {x : C} {S : CategoryTheory.Sieve x} {P : Cᵒᵖ ⥤ Type v₁} (h : CategoryTheory.Presieve.IsSheafFor P ⇑S) (F : S.Functor ⟶ P) : S.Functor_inclusion ≫ h.extend F = F
(q : ℚ) : (GeneralizedContinuedFraction.of q).terminates
{R : Type v} [CommRing R] {n : ℕ} {A B : Matrix (Fin (n + 1)) (Fin (n + 1)) R} (C : Fin n → R) (A_Zero : ∀ (j : Fin (n + 1)), A 0 j = B 0 j) (A_Succ : ∀ (i : Fin n) (j : Fin (n + 1)), A i.Succ j = B i.Succ j + C i * A (⇑Fin.cast_Succ i) j) : A.det = B.det
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] (F g : ℝ × ℝ → E) (F' g' : ℝ × ℝ → (ℝ × ℝ →L[ℝ] E)) (A B : ℝ × ℝ) (hle : A ≤ B) (S : set (ℝ × ℝ)) (hs : S.countable) (Hcf : Continuous_on F (set.icc A B)) (Hcg : Continuous_on g (set.icc A B)) (Hdf : ∀ (x : ℝ × ℝ), x ∈ set.Ioo A.fst B.fst ×ˢ set.Ioo A.Snd B.Snd  S → HasFderivAt F (F' x) x) (Hdg : ∀ (x : ℝ × ℝ), x ∈ set.Ioo A.fst B.fst ×ˢ set.Ioo A.Snd B.Snd  S → HasFderivAt g (g' x) x) (Hi : MeasureTheory.IntegrableOn (λ (x : ℝ × ℝ), ⇑(F' x) (1, 0) + ⇑(g' x) (0, 1)) (set.icc A B) MeasureTheory.MeasureSpace.Volume) : ∫ (x : ℝ × ℝ) in set.icc A B, ⇑(F' x) (1, 0) + ⇑(g' x) (0, 1) = (((∫ (x : ℝ) in A.fst..B.fst, g (x, B.Snd)) - ∫ (x : ℝ) in A.fst..B.fst, g (x, A.Snd)) + ∫ (y : ℝ) in A.Snd..B.Snd, F (B.fst, y)) - ∫ (y : ℝ) in A.Snd..B.Snd, F (A.fst, y)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {E' : Type u_6} [NormedGroup E'] [NormedSpace 𝕜 E'] {F' : Type u_7} [NormedGroup F'] [NormedSpace 𝕜 F'] {F : E → F} {g : E' → F'} {P : E × E'} (hF : ContDiff_at 𝕜 n F P.fst) (hg : ContDiff_at 𝕜 n g P.Snd) : ContDiff_at 𝕜 n (Prod.Map F g) P
{E : Type u_2} {𝕜 : Type u_3} [Linear_ordered_Field 𝕜] [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul 𝕜 E] {S : set E} (hs : Convex 𝕜 S) {x y : E} (hx : x ∈ Closure S) (hy : x + y ∈ Interior S) {t : 𝕜} (ht : t ∈ set.ioc 0 1) : x + t • y ∈ Interior S
{α : Type u} {S : set α} : S.countable ↔ ∃ (F : α → ℕ), set.inj_on F S
{α : Type u_1} {γ : Type u_3} [TopologicalSpace α] [MeasurableSpace α] [Opens_MeasurableSpace α] [TopologicalSpace γ] [MeasurableSpace γ] [BorelSpace γ] {F : α → γ} (hF : Continuous F) : Measurable F
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (q n m : ℕ) (hnm : AlgebraicTopology.DoldKan.C.Rel m n) {x Y : CategoryTheory.SimplicialObject C} (F : x ⟶ Y) : F.App (Opposite.Op (SimplexCategory.Mk n)) ≫ AlgebraicTopology.DoldKan.hσ' q n m hnm = AlgebraicTopology.DoldKan.hσ' q n m hnm ≫ F.App (Opposite.Op (SimplexCategory.Mk m))
(R L : Type u) [CommRing R] [CommRing L] [IsDomain L] [Algebra R L] [NoZeroSmulDivisors R L] (halg : Algebra.IsAlgebraic R L) : Cardinal.Mk L ≤ LinearOrder.max (Cardinal.Mk R) Cardinal.aleph0
{α : Type u} {β : Type v} (F : α → β) (g : β → α) : set.maps_to F (Function.FixedPoints (g ∘ F)) (Function.FixedPoints (F ∘ g))
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_biproducts C] : CategoryTheory.Limits.HasBinaryBiproducts C
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S₁ S₂ : AffineSubspace ℝ P} [Nonempty ↥S₁] [CompleteSpace ↥(S₁.direction)] (hle : S₁ ≤ S₂) {P : P} (hp : P ∈ S₂) : ⇑(EuclideanGeometry.reflection S₁) P ∈ S₂
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] {A B C : α} : B < -A + C → A + B < C
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {n : WithTop ℕ} (h : ContDiff 𝕜 n F) (hn : 1 ≤ n) : Continuous (λ (P : E × E), ⇑(fderiv 𝕜 F P.fst) P.Snd)
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] [DiscreteTopology α] {F : α → β → γ} (hF : ∀ (A : α), Continuous (F A)) : Continuous (Function.uncurry F)
(m : Type u_1) (α : Type u_2) [Monoid m] [MulAction m α] {ι : sort u_3} {P : ι → Submonoid m} : MulAction.FixedPoints ↥(supr P) α = ⋂ (i : ι), MulAction.FixedPoints ↥(P i) α
{K : Type u_1} {n : ℕ} {S : Seq (GeneralizedContinuedFraction.Pair K)} [DivisionRing K] {m : ℕ} (m_LT_n : m < n) : (GeneralizedContinuedFraction.squash_Seq S n).nth m = S.nth m
{𝕜 : Type u_1} {E : Type u_2} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {P₁ P₂ : FormalMultilinearSeries 𝕜 𝕜 E} {F : 𝕜 → E} {x : 𝕜} (h₁ : HasFpowerSeriesAt F P₁ x) (h₂ : HasFpowerSeriesAt F P₂ x) : P₁ = P₂
(P q r : ℕ+) : 1 < ADE_inequality.Sum_Inv {P, q, r} ↔ ADE_inequality.Admissible {P, q, r}
{α : Type u_3} {β : Type u_4} [Preorder α] [Preorder β] {F : α → β} (hF : Monotone F) (h : ∀ (B : β), ∃ (A : α), F A ≤ B) : Filter.Tendsto F Filter.at_IsBot Filter.at_IsBot
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {F : F → G} {x : E} {y : F} (hF : ContDiff_at 𝕜 n F y) : ContDiff_at 𝕜 n (λ (x : E × F), F x.Snd) (x, y)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) : hb.oangle x (⇑(hb.rotation θ) y) = hb.oangle x y + θ
{J : Type v} {C : Type u} [CategoryTheory.Category C] {x Y : C} {F : J → (x ⟶ Y)} [Nonempty J] {C : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.parallel_family F)} (i : CategoryTheory.Limits.IsColimit C) : CategoryTheory.Epi (C.ι.App CategoryTheory.Limits.WalkingParallelFamily.One)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P (n + 1)) (i : Fin (n + 2)) : Finite_dimensional.finrank ℝ ↥((S.altitude i).direction) = 1
(x y : Pgame) : (x * y).Equiv (y * x)
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {δ : Type u_1} [LinearOrder δ] [TopologicalSpace δ] [order_IsClosed_topology δ] {F : α → δ} {S : set α} [S.Ord_connected] (hs : S.Nonempty) (hF : Continuous_on F S) (hbot : Filter.Tendsto (λ (x : ↥S), F ↑x) Filter.at_IsBot Filter.at_IsBot) (htop : Filter.Tendsto (λ (x : ↥S), F ↑x) Filter.at_top Filter.at_top) : set.surj_on F S set.Univ
{E : Type u_1} [InnerProductSpace ℝ E] {n : ℕ} [Fact (Finite_dimensional.finrank ℝ E = n + 1)] : Cont_mdiff (model_with_corners_self ℝ (EuclideanSpace ℝ (Fin n))) (model_with_corners_self ℝ E) ⊤ Coe
(P : ℝ × ℝ) (hp : 0 < P.fst) : HasStrictFderivAt (λ (x : ℝ × ℝ), x.fst ^ x.Snd) ((P.Snd * P.fst ^ (P.Snd - 1)) • Continuous_Linear_Map.fst ℝ ℝ ℝ + (P.fst ^ P.Snd * Real.log P.fst) • Continuous_Linear_Map.Snd ℝ ℝ ℝ) P
{α : Type u_1} [normed_DivisionRing α] {A : α} (ha : A ≠ 0) : Filter.Tendsto (has_Mul.Mul A) (Filter.comap HasNorm.norm Filter.at_top) (Filter.comap HasNorm.norm Filter.at_top)
{α : Type u_1} [has_Mul α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] {B C : α} (bc : B < C) (A : α) : A * B < A * C
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y z : v} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x z - hb.oangle y z = hb.oangle x y
(A : Type u_4) [CommRing A] [IsDomain A] {L : Type u_6} [Field L] [Algebra A L] (C : Type u_7) [CommRing C] [IsDomain C] [Algebra C L] [IsIntegral_Closure C A L] [Algebra A C] [IsScalarTower A C L] (alg : Algebra.IsAlgebraic A L) (inj : ∀ (x : A), ⇑(Algebra_Map A L) x = 0 → x = 0) : _fraction_Ring C L
{α : Type u} [Preorder α] (A : α) : A ≤ A
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : HasInner.inner x y ≤ ∥x∥ * ∥y∥
{E : Type u_1} {PE : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [MetricSpace PE] [NormedAddTorsor E PE] {F : Type u_3} {PF : Type u_4} [NormedGroup F] [NormedSpace ℝ F] [MetricSpace PF] [NormedAddTorsor F PF] (F : PE ≃ᵢ PF) (x y : PE) : ⇑F (midpoint ℝ x y) = midpoint ℝ (⇑F x) (⇑F y)
{E : Type u_1} (R : Type u_2) (S : Type u_3) [AddCommGroup E] [DivisionRing R] [DivisionRing S] [module R E] [module S E] (n : ℕ) (x : E) : (↑n)⁻¹ • x = (↑n)⁻¹ • x
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A B : α} (ha : A < 1) (hb : B < 1) : A * B < 1
(k : Type u_1) (G : Type u_2) [CommSemiring k] [Group G] [Fintype G] [Invertible ↑(Fintype.Card G)] (g : G) : Finsupp.single g 1 * Group_Algebra.average k G = Group_Algebra.average k G
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Zero_object C] (x : C) : CategoryTheory.Simple x ↔ IsSimpleOrder (CategoryTheory.Subobject x)
{α : Type u_1} [semi_NormedRing α] (A : α) {n : ℕ} : 0 < n → ∥A ^ n∥₊ ≤ ∥A∥₊ ^ n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x Y : C} (F g : x ⟶ Y) [CategoryTheory.Limits.HasBinaryBiproduct x x] : F + g = CategoryTheory.Limits.biprod.Lift (𝟙 x) (𝟙 x) ≫ CategoryTheory.Limits.biprod.Desc F g
{α : Type u_1} {β : Type u_2} (F : α → β) : Function.Injective F ↔ Setoid.Ker F = ⊥
{α : Type u_1} {G : Type u_4} {S : set α} [division_CommMonoid G] (F g : α → G) (hs : S.Finite) : finprod (λ (i : α), finprod (λ (h : i ∈ S), F i / g i)) = finprod (λ (i : α), finprod (λ (h : i ∈ S), F i)) / finprod (λ (i : α), finprod (λ (h : i ∈ S), g i))
{α : Type u_1} [PseudoMetricSpace α] (x y : α) : HasEdist.edist x y < ⊤
{R : Type u} [Semiring R] {S : Type v} [Semiring S] (F : R →+* S) (r : R) : ⇑Polynomial.C (⇑F r) ∈ Polynomial.lifts F
{α : Type u_1} {β : Type u_2} {F : α → β} : Monotone (set.image F)
{k : Type u_1} {K : Type u_2} [Field k] [_alg_IsClosed k] [Field K] {F : K →+* k} (P : Polynomial K) : Polynomial.Splits F P
{α : Type u_1} {ι : Type u_3} [CompleteLattice α] [Fintype ι] {F : ι → α} : Finset.Univ.Sup_indep F → CompleteLattice.Independent F
{α : Type u_1} {l₁ l₂ : List α} : l₁ <+: l₂ → l₁.reverse <:+ l₂.reverse
 : Filter.Tendsto (λ (x : ℝ), Real.Exp (-x)) Filter.at_top (nhds 0)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι →₀ 𝕜) (i : ι) : HasInner.inner (⇑(Finsupp.Total ι E 𝕜 v) l) (v i) = ⇑(Star_Ring_end 𝕜) (⇑l i)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {P : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} {r' : Nnreal} (hF : HasFpowerSeriesOnBall F P x r) (h : ↑r' < r) : ∃ (A : ℝ) (h : A ∈ set.Ioo 0 1) (C : ℝ) (h : C > 0), ∀ (y : E), y ∈ Metric.Ball 0 ↑r' → ∀ (n : ℕ), ∥F (x + y) - P.partial_Sum n y∥ ≤ C * (A * (∥y∥ / ↑r')) ^ n
{R : Type u_1} [NormedRing R] [CompleteSpace R] : IsOpen_Map Coe
{𝕂 : Type u_1} [_R_or_C 𝕂] {x : 𝕂} : HasStrictDerivAt (Exp 𝕂) (Exp 𝕂 x) x
{n : ℕ} {l : List ℕ} (h₁ : l.Prod = n) (h₂ : ∀ (P : ℕ), P ∈ l → Nat.Prime P) : l ~ n.Factors
{α : Type u} [Preorder α] {x y : α} (h : x = y) : y ≤ x
 : ¬set.Univ.countable
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {n : WithTop ℕ} (h : ContDiff 𝕜 n F) (hn : 1 ≤ n) : Differentiable 𝕜 F
{S : Type u} [Semigroup S] {A B x y z : S} (ha : SemiconjBy A y z) (hb : SemiconjBy B x y) : SemiconjBy (A * B) x z
{𝕜 : Type u_1} {E : Type u_2} [semi_NormedRing 𝕜] [HasScalar 𝕜 E] [has_Zero E] [TopologicalSpace E] {S₁ S₂ : set E} (hs₁ : Bornology._vonN_bounded 𝕜 S₁) (hs₂ : Bornology._vonN_bounded 𝕜 S₂) : Bornology._vonN_bounded 𝕜 (S₁ ∪ S₂)
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] [Nontrivial E] {F g : E → F} {U : set E} (hU : Metric.Bounded U) (hF : Diff_Cont_on_cl ℂ F U) (hg : Diff_Cont_on_cl ℂ g U) (hfg : set.Eq_on F g (Frontier U)) : set.Eq_on F g (Closure U)
{R : Type u} [Semiring R] (r : R) (n : ℕ) : Polynomial.x ^ n * ⇑Polynomial.C r = ⇑Polynomial.C r * Polynomial.x ^ n
{𝕜 : Type u_1} {E : Type u_3} [NormedField 𝕜] [AddCommGroup E] [module 𝕜 E] {A : set E} (hA : Balanced 𝕜 A) : Absorbs 𝕜 A A
{v : Type u_9} {K : Type u_10} [Field K] [AddCommGroup v] [module K v] (B : BilinForm K v) (B₁ : B.nondegenerate) (B₂ : B.IsRefl) {x : v} (hx : ¬B.IsOrtho x x) : (B.Restrict (B.Orthogonal (Submodule.Span K {x}))).nondegenerate
{α : sort u_1} {β : sort u_2} {F : α → β} (hF : Function.Bijective F) (B : β) : ∃! (A : α), F A = B
{α : Type u} [Preorder α] {A B : α} : A = B → A ≤ B
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : HasDist.dist P1 P2 = HasDist.dist P1 P3) : EuclideanGeometry.angle P1 P2 P3 = EuclideanGeometry.angle P1 P3 P2
{x y z : ℤ} (h : PythagoreanTriple x y z) (k : ℤ) : PythagoreanTriple (k * x) (k * y) (k * z)
{α : Type u_1} {ι : sort u_3} [conditionally_CompleteLattice α] {F : ι → α} (h : BddAbove (set.Range F)) (C : ι) : F C ≤ supr F
{C : Type u} [CategoryTheory.Category_struct C] {x Y : CategoryTheory.LocallyDiscrete C} {F g : x ⟶ Y} (η : F ⟶ g) : F = g
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {F : Type u_2} [NormedGroup F] [NormedSpace ℝ F] {F : E → F} {S : set E} {x : E} {F' : E →L[ℝ] F} (F_Diff : DifferentiableOn ℝ F S) (S_conv : Convex ℝ S) (S_IsOpen : IsOpen S) (F_Cont : ∀ (y : E), y ∈ Closure S → Continuous_within_at F S y) (h : Filter.Tendsto (λ (y : E), fderiv ℝ F y) (nhds_within x S) (nhds F')) : HasFderivWithinAt F F' (Closure S) x
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {ι : Type u_3} [hne : Nonempty ι] [Fintype ι] {P : ι → P} (ha : AffineIndependent ℝ P) : ∃! (cccr : P × ℝ), cccr.fst ∈ affine_Span ℝ (set.Range P) ∧ ∀ (i : ι), HasDist.dist (P i) cccr.fst = cccr.Snd
{α : Type u_1} [PartialOrder α] [SuccOrder α] {A : α} : IsMax A → Order.Succ A = A
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} (P : ι → P) (i1 : ι) : AffineIndependent k P ↔ LinearIndependent k (λ (i : {x // x ≠ i1}), P ↑i -ᵥ P i1)
{ι : Type u_1} {α : Type u_2} {E : Type u_3} [semi_NormedGroup E] {F : ι → E} (hF : Summable (λ (A : ι), ∥F A∥)) {S : α → Finset ι} {P : Filter α} [P.Ne_IsBot] (hs : Filter.Tendsto S P Filter.at_top) {A : E} (ha : Filter.Tendsto (λ (B : α), (S B).Sum (λ (i : ι), F i)) P (nhds A)) : has_Sum F A
{α : Type u_1} {m : Type u_5} [has_Zero m] {F g : α →₀ m} (h : F = g) (A : α) : ⇑F A = ⇑g A
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {x : α} {P : Filter ι} {g : ι → α} [TopologicalSpace α] (h : TendstoUniformly F F P) (hF : Continuous_at F x) (hg : Filter.Tendsto g P (nhds x)) : Filter.Tendsto (λ (n : ι), F n (g n)) P (nhds (F x))
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₂} [CategoryTheory.Category C] [CategoryTheory.IsPreconnected J] {x Y : C} (α : (CategoryTheory.Functor.Const J).obj x ⟶ (CategoryTheory.Functor.Const J).obj Y) (j j' : J) : α.App j = α.App j'
{β α : Type u} (F : β → α) (θ : Cardinal) (hθ : θ ≤ Cardinal.Mk β) (h₁ : Cardinal.aleph0 ≤ θ) (h₂ : Cardinal.Mk α < θ.Ord.cof) : ∃ (A : α), θ ≤ Cardinal.Mk ↥(F ⁻¹' {A})
{F : Type u_1} [Field F] (P q : Polynomial F) : Function.Injective ⇑(Polynomial.Gal.Restrict_Prod P q)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} [DecidableEq ι] [Finite_dimensional 𝕜 E] {v : ι → Submodule 𝕜 E} (hV : OrthogonalFamily 𝕜 (λ (i : ι), (v i).Subtypeₗᵢ)) : direct_Sum._internal v ↔ (supr v)ᗮ = ⊥
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type W} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace 𝕜] {ι : Type u_1} [Fintype ι] (v : Basis ι 𝕜 E) : ∃ (C : Nnreal) (h : C > 0), ∀ {u : E →L[𝕜] F} (m : Nnreal), (∀ (i : ι), ∥⇑u (⇑v i)∥₊ ≤ m) → ∥u∥₊ ≤ C * m
{x : Type u} [Lattice x] [jordan_holder_Lattice x] (S : Composition_series x) (x : x) (hm : jordan_holder_Lattice.IsMaximal x S.top) (hb : S.IsBot ≤ x) : ∃ (t : Composition_series x), t.IsBot = S.IsBot ∧ t.length + 1 = S.length ∧ ∃ (htx : t.top = x), S.Equivalent (t.snoc S.top _)
(F : Type u) (K : Type v) (A : Type W) [Field F] [Field K] [AddCommGroup A] [Algebra F K] [module K A] [module F A] [IsScalarTower F K A] [Finite_dimensional F K] : Finite_dimensional.finrank F K * Finite_dimensional.finrank K A = Finite_dimensional.finrank F A
{𝕂 : Type u_1} {𝔸 : Type u_2} [nondiscrete_NormedField 𝕂] [NormedRing 𝔸] [normed_Algebra 𝕂 𝔸] [CompleteSpace 𝔸] (h : 0 < (Exp_series 𝕂 𝔸).radius) : HasFderivAt (Exp 𝕂) 1 0
{K : Type u_1} {v : K} {n : ℕ} [Linear_ordered_Field K] [FloorRing K] {B : K} (nth_Part_denom_Eq : (GeneralizedContinuedFraction.of v).partial_denominators.nth n = Option.Some B) : B * (GeneralizedContinuedFraction.of v).denominators n ≤ (GeneralizedContinuedFraction.of v).denominators (n + 1)
{G : Type u} [Group G] [Fintype G] {P n : ℕ} [hp : Fact (Nat.Prime P)] (hdvd : P ^ (n + 1) ∣ Fintype.Card G) {h : Subgroup G} (hH : Fintype.Card ↥h = P ^ n) : P ∣ Fintype.Card (↥(h.Normalizer) ⧸ Subgroup.comap h.Normalizer.Subtype h)
{F : Type u_3} [Field F] [Fintype F] (hF : Ring_Char F ≠ 2) {A : F} (ha : A ≠ 0) : IsSquare A ↔ A ^ (Fintype.Card F / 2) = 1
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (S : Finset ι) : Finset.centroid_weights k S = Function.Const ι (↑(S.Card))⁻¹
{x y : SimplexCategory {F : x ⟶ y} : CategoryTheory.Mono F → x.len ≤ y.len
(n : ℕ) : (1 + n).Pred = n
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder β] [SuccOrder β] [IsSuccArchimedean β] {S : β → set α} (h : ∀ (n : β), IsPreconnected (S n)) (K : ∀ (n : β), (S n ∩ S (Order.Succ n)).Nonempty) : IsPreconnected (⋃ (n : β), S n)
(P n : ℕ) : witt_Polynomial P (Zmod (P ^ (n + 1))) (n + 1) = ⇑(mv_Polynomial.expand P) (witt_Polynomial P (Zmod (P ^ (n + 1))) n)
{α : Type u} [PseudoMetricSpace α] {S : ℕ → α} : Cauchy_Seq S ↔ ∃ (B : ℕ → ℝ), (∀ (n : ℕ), 0 ≤ B n) ∧ (∀ (n m N : ℕ), N ≤ n → N ≤ m → HasDist.dist (S n) (S m) ≤ B N) ∧ Filter.Tendsto B Filter.at_top (nhds 0)
{J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ Mon_) [CategoryTheory.IsFiltered J] {x y y' : Σ (j : J), ↥(F.obj j)} (hyy' : CategoryTheory.Limits.types.filtered_Colimit.Rel (F ⋙ CategoryTheory.Forget Mon_) y y') : Mon_.FilteredColimits.Colimit_Mul_aux F x y = Mon_.FilteredColimits.Colimit_Mul_aux F x y'
{α : Type u} [PseudoMetricSpace α] {S : set α} [t2_Space α] [ProperSpace α] : IsCompact S ↔ IsClosed S ∧ Metric.Bounded S
(x : ℂ) : HasDerivAt Complex.sin (Complex.cos x) x
{P : ℂ × ℂ} (h₁ : 0 ≤ P.fst.re ∨ P.fst.im ≠ 0) (h₂ : 0 < P.Snd.re) : Continuous_at (λ (x : ℂ × ℂ), x.fst ^ x.Snd) P
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F ≠ 2) : Char.quadratic_Char F (-1) = ⇑Zmod.χ₄ ↑(Fintype.Card F)
{n : ℕ} {α : Fin (n + 1) → Type u} (x : α 0) (P : Π (i : Fin n), α i.Succ) (i : Fin n) (y : α i.Succ) : Fin.Cons x (Function.update P i y) = Function.update (Fin.Cons x P) i.Succ y
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {J : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.Fin_Category J] (F : J ⥤ C) : Nonempty (CategoryTheory.Limits.Cocone F)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P : C} (A : CategoryTheory.Over P) : ↑A = 0 ↔ A.hom = 0
{R : Type u} [CommRing R] {P : Ideal R} (h : P.Prime) : (Ideal.Map Polynomial.C P).Prime
{α : Type u_1} {β : Type u_2} [AddGroup α] [AddCommGroup β] {F g : α → β} (hF : _AddGroup_hom F) (hg : _AddGroup_hom g) : _AddGroup_hom (λ (A : α), F A - g A)
{A B C : Prop} : A ∧ (B ∨ C) ↔ A ∧ B ∨ A ∧ C
{R : ℝ} {C W : ℂ} {S : set ℂ} (hs : S.countable) (hw : W ∈ Metric.Ball C R) {F : ℂ → ℂ} (hc : Continuous_on F (metric.IsClosed_ball C R)) (hD : ∀ (z : ℂ), z ∈ Metric.Ball C R  S → Differentiable_at ℂ F z) : ∮ (z : ℂ) in C(C, R), F z / (z - W) = 2 * ↑Real.Pi * Complex.i * F W
{α : Type u_1} {P : α → Prop} : Antitone (λ (S : set α), ∀ (x : α), x ∈ S → P x)
{α : Type u} [Preorder α] {A B C : α} : B < C → A < B → A < C
{α : Type u} [TopologicalSpace α] (x : α) (C : set (set α)) (h1 : ∀ (S : set α), S ∈ C → x ∈ S) (h2 : ∀ (S : set α), S ∈ C → IsPreconnected S) : IsPreconnected (⋃₀C)
{m : Type u_1} [MulOneClass m] (S : Submonoid m) : Submonoid.Closure ↑S = S
(𝕜 : Type v) [_R_or_C 𝕜] {E : Type u} [NormedGroup E] [NormedSpace 𝕜 E] (x : E) {m : ℝ} (hMp : 0 ≤ m) (hM : ∀ (F : NormedSpace.dual 𝕜 E), ∥⇑F x∥ ≤ m * ∥F∥) : ∥x∥ ≤ m
{A B C : Prop} : (A ∨ B) ∧ C ↔ A ∧ C ∨ B ∧ C
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] : (Filter.cocompact α).Coprod (Filter.cocompact β) = Filter.cocompact (α × β)
{G : Type u_1} {S : set G} [Group G] : _Normal_Subgroup (Group.Normal_Closure S)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {n : WithTop ℕ} : ContDiff 𝕜 n Id
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B C : α} : A < B + C → A - C < B
{α : Type u} [PseudoMetricSpace α] (F : ℕ → α) (n : ℕ) : HasDist.dist (F 0) (F n) ≤ (Finset.Range n).Sum (λ (i : ℕ), HasDist.dist (F i) (F (i + 1)))
{α : Type u} [Preorder α] {A B C : α} : A ≤ B → B ≤ C → A ≤ C
{C : Type u₁} [CategoryTheory.Category C] {x Y : C} (F : x ⟶ Y) [CategoryTheory.Mono F] [CategoryTheory.SplitEpi F] : CategoryTheory.IsIso F
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] [LocallyCompactSpace (α × β)] : Continuous Continuous_Map.Curry
{x y z : ℤ} (h : PythagoreanTriple x y z) (h_IsCoprime : x.Gcd y = 1) (h_parity : x % 2 = 1) (h_Pos : 0 < z) : ∃ (m n : ℤ), x = m ^ 2 - n ^ 2 ∧ y = 2 * m * n ∧ z = m ^ 2 + n ^ 2 ∧ m.Gcd n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0) ∧ 0 ≤ m
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] : K ⊔ Kᗮ = ⊤
{R : Type u_1} [CommRing R] (S : Type u_2) [CommRing S] [Algebra R S] (m N : Submonoid R) [IsLocalization m S] (h : m ≤ N) (h' : ∀ (x : ↥N), ∃ (m : R), m * ↑x ∈ m) : IsLocalization N S
{R : Type u} {n : ℕ} {m : Fin n.Succ → Type v} {m₂ : Type v₂} [Semiring R] [Π (i : Fin n.Succ), AddCommMonoid (m i)] [AddCommMonoid m₂] [Π (i : Fin n.Succ), module R (m i)] [module R m₂] (F : MultilinearMap R m m₂) (m : Π (i : Fin n), m (⇑Fin.cast_Succ i)) (x y : m (Fin.Last n)) : ⇑F (Fin.snoc m (x + y)) = ⇑F (Fin.snoc m x) + ⇑F (Fin.snoc m y)
{α : Type u} {A B : α} [MulZeroOneClass α] [PartialOrder α] [Zero_LT.Mul_Pos_Mono α] (ha : A ≤ 1) (hb : B ≤ 1) (B0 : 0 < B) : A * B ≤ 1
(A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) {P : Polynomial A} (pmonic : P.monic) (hp : ⇑(Polynomial.aeval x) P = 0) : (minpoly A x).degree ≤ P.degree
{P : ℕ} [Fact (Nat.Prime P)] {F : padic_Seq P} (hF : ¬F ≈ 0) (v2 v3 : ℕ) : padic_norm P (⇑F (padic_Seq.stationary_point hF)) = padic_norm P (⇑F (LinearOrder.max (padic_Seq.stationary_point hF) (LinearOrder.max v2 v3)))
{m : Type u_3} {N : Type u_4} [MulZeroOneClass m] [MulZeroOneClass N] (F : m →*₀ N) {x y : m} (h : x = y) : ⇑F x = ⇑F y
{k : Type u_1} {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {n : ℕ} {S₁ S₂ : Affine.Simplex k P n} (h : set.Range S₁.points = set.Range S₂.points) : Finset.centroid k Finset.Univ S₁.points = Finset.centroid k Finset.Univ S₂.points
{α : Type u_1} {β : Type u_2} (F : α → β) (P : RegularExpression α) : (RegularExpression.Map F P).Matches = ⇑(Language.Map F) P.Matches
(S : set ℝ) (hS : ∀ (x : ℝ), x ∈ S → 0 ≤ x) : 0 ≤ HasInf.Inf S
(α : Type u) [MetricSpace α] [TopologicalSpace.IsSeparable_Space α] : ∃ (F : α → ↥(Lp (λ (n : ℕ), ℝ) ⊤)), Isometry F
{L : FirstOrder.Language} {m : Type W} [L.structure m] (S : set m) {P : Π (x : m), x ∈ ⇑(FirstOrder.Language.Substructure.Closure L) S → Prop} (Hs : ∀ (x : m) (h : x ∈ S), P x _) (Hfun : ∀ {n : ℕ} (F : L.Functions n), FirstOrder.Language.IsClosed_under F {x : m | ∃ (hx : x ∈ ⇑(FirstOrder.Language.Substructure.Closure L) S), P x hx}) {x : m} (hx : x ∈ ⇑(FirstOrder.Language.Substructure.Closure L) S) : P x hx
{α : Type u_1} {β : Type u_2} [CompleteLattice α] {F : Filter β} {u : β → α} : F.liminf u = ⨆ (S : set β) (h : S ∈ F), ⨅ (A : β) (h : A ∈ S), u A
{α : Type u_1} {m : Type u_5} {N : Type u_7} {P : Type u_8} [has_Zero m] [CommMonoid N] [CommMonoid P] (h : N ≃* P) (F : α →₀ m) (g : α → m → N) : ⇑h (F.Prod g) = F.Prod (λ (A : α) (B : m), ⇑h (g A B))
{α : Type u} [Preorder α] {S t : set α} (h : BddAbove t) : BddAbove (S ∩ t)
{G : Type u_1} [Group G] {k : set G} {P : G → Prop} {x : G} (h : x ∈ Subgroup.Closure k) (Hk : ∀ (x : G), x ∈ k → P x) (Hk_Inv : ∀ (x : G), x ∈ k → P x⁻¹) (h1 : P 1) (HMul : ∀ (x y : G), P x → P y → P (x * y)) : P x
{Y : Type u_2} [TopologicalSpace Y] [NormalSpace Y] {S : set Y} (F : bounded_Continuous_Function ↥S ℝ) (hs : IsClosed S) {t : set ℝ} [t.Ord_connected] (hF : ∀ (x : ↥S), ⇑F x ∈ t) (hne : t.Nonempty) : ∃ (g : bounded_Continuous_Function Y ℝ), (∀ (y : Y), ⇑g y ∈ t) ∧ g.Restrict S = F
{n : ℕ} {α : Type u_1} [Preorder α] {F g : Fin n ↪o α} (h : set.Range ⇑F = set.Range ⇑g) : F = g
{α : Type u} [TopologicalSpace α] {S : set α} (h : IsPreconnected S) : IsPreconnected (Closure S)
(A B : Finset ℕ) : A.Sum (λ (i : ℕ), 2 ^ i) < B.Sum (λ (i : ℕ), 2 ^ i) ↔ A.to_colex < B.to_colex
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [Finite_dimensional 𝕜 E] (t : E →ₗ[𝕜] E) : InnerProductSpace.IsSelfAdjoint (⇑LinearMap.Adjoint t * t)
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [Linear_ordered_AddCommMonoid β] [HasScalar 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F : E → β} (hF : strict_ConcaveOn 𝕜 S F) {x y : E} (hx : x ∈ S) (hy : y ∈ S) (hxy : x ≠ y) {A B : 𝕜} (ha : 0 < A) (hb : 0 < B) (hab : A + B = 1) : LinearOrder.min (F x) (F y) < F (A • x + B • y)
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {C : ℝ} {F : α → E} {g : α → F} {l : Filter α} : Asymptotics._O_with C l F g → (∀ᶠ (x : α) in l, ∥F x∥ ≤ C * ∥g x∥)
{R : Type u_1} {S : Type u_2} [conditionally_complete_LinearOrder R] (S : Finset S) (F : S → Tropical (WithTop R)) : Tropical.untrop (S.Sum (λ (i : S), F i)) = ⨅ (i : ↥S), Tropical.untrop (F ↑i)
{ι : Type u_1} {𝕜 : Type u_3} [_R_or_C 𝕜] {E : Type u_4} [InnerProductSpace 𝕜 E] {E' : Type u_5} [InnerProductSpace 𝕜 E'] [Fintype ι] (v : Basis ι 𝕜 E) (hv : Orthonormal 𝕜 ⇑v) (F : E ≃ₗᵢ[𝕜] E') : ((v.Map F.to_Linear_Equiv).to_Orthonormal_Basis _).repr = F.Symm.Trans (v.to_Orthonormal_Basis hv).repr
{α : Type u_1} {m : Type u_5} {N : Type u_7} {R : Type u_11} [Monoid R] [AddMonoid m] [AddCommMonoid N] [Distrib_MulAction R m] {g : α →₀ m} {B : R} {h : α → m →+ N} : (B • g).Sum (λ (A : α), ⇑(h A)) = g.Sum (λ (i : α) (C : m), ⇑(h i) (B • C))
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : set P} {P₀ : P} (h : P₀ ∈ S) : Collinear k S ↔ ∃ (v : v), ∀ (P : P), P ∈ S → (∃ (r : k), P = r • v +ᵥ P₀)
{R : Type u} [Field R] (P : Polynomial R) : (Multiset.Map (λ (A : R), Polynomial.x - ⇑Polynomial.C A) P.roots).Prod ∣ P
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {A B : α} {S : set α} (hs : IsClosed (S ∩ set.icc A B)) (ha : A ∈ S) (hgt : ∀ (x : α), x ∈ S ∩ set.Ico A B → S ∈ nhds_within x (set.ioi x)) : set.icc A B ⊆ S
{A : Type u_2} [NormedRing A] [normed_Algebra ℂ A] [CompleteSpace A] [NormOneClass A] (A : A) : Filter.Tendsto (λ (n : ℕ), Ennreal.of_Real (∥A ^ n∥ ^ (1 / ↑n))) Filter.at_top (nhds (spectral_radius ℂ A))
{P : ℕ+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [Ne_Zero ↑↑P] {k : ℕ} [hpri : Fact (Nat.Prime ↑P)] [IsCyclotomicExtension {P ^ (k + 1)} K L] (hirr : Irreducible (Polynomial.cyclotomic ↑(P ^ (k + 1)) K)) (h : P ≠ 2) : ⇑(Algebra.norm K) (IsCyclotomicExtension.zeta (P ^ (k + 1)) K L - 1) = ↑P
{F : Type u} [Field F] {n : ℕ} : (Polynomial.x ^ n - 1).IsSeparable ↔ ↑n ≠ 0
{x y : Pgame} (ox : x.Numeric) (oy : y.Numeric) : x < y ↔ (∃ (i : y.Left_moves), x ≤ y.move_Left i) ∨ ∃ (j : x.Right_moves), x.move_Right j ≤ y
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {F' : F} [LinearOrder 𝕜] [order_IsClosed_topology 𝕜] {x y : 𝕜} (h : x < y) : HasDerivWithinAt F F' (set.ioi x) x → HasDerivWithinAt F F' (set.Ioo x y) x
{α : Type u} [PartialOrder α] {A B : α} : A ≤ B → B ≤ A → A = B
(F F' : ℝ → ℝ) {A B : ℝ} (hab : A < B) (g g' : ℝ → ℝ) {lfa lga lfb lgb : ℝ} (hff' : ∀ (x : ℝ), x ∈ set.Ioo A B → HasDerivAt F (F' x) x) (hgg' : ∀ (x : ℝ), x ∈ set.Ioo A B → HasDerivAt g (g' x) x) (hfa : Filter.Tendsto F (nhds_within A (set.ioi A)) (nhds lfa)) (hga : Filter.Tendsto g (nhds_within A (set.ioi A)) (nhds lga)) (hfb : Filter.Tendsto F (nhds_within B (set.Iio B)) (nhds lfb)) (hgb : Filter.Tendsto g (nhds_within B (set.Iio B)) (nhds lgb)) : ∃ (C : ℝ) (h : C ∈ set.Ioo A B), (lgb - lga) * F' C = (lfb - lfa) * g' C
{α : Type u} [TopologicalSpace α] {S : set α} : Dense S → ∀ (U : set α), IsOpen U → U.Nonempty → (U ∩ S).Nonempty
{v : Type u_1} [CategoryTheory.Category v] {A₁ B₁ C₁ A₂ B₂ C₂ A₃ B₃ C₃ : v} {F₁ : A₁ ⟶ B₁} {g₁ : B₁ ⟶ C₁} {F₂ : A₂ ⟶ B₂} {g₂ : B₂ ⟶ C₂} {F₃ : A₃ ⟶ B₃} {g₃ : B₃ ⟶ C₃} {α₁ : CategoryTheory.Arrow.Mk F₁ ⟶ CategoryTheory.Arrow.Mk F₂} {β₁ : CategoryTheory.Arrow.Mk g₁ ⟶ CategoryTheory.Arrow.Mk g₂} {α₂ : CategoryTheory.Arrow.Mk F₂ ⟶ CategoryTheory.Arrow.Mk F₃} {β₂ : CategoryTheory.Arrow.Mk g₂ ⟶ CategoryTheory.Arrow.Mk g₃} (P₁ : α₁.Right = β₁.Left) (P₂ : α₂.Right = β₂.Left) : (α₁ ≫ α₂).Right = (β₁ ≫ β₂).Left
{x : Pgame} : 0 ≤ x ↔ ∀ (j : x.Right_moves), ∃ (i : (x.move_Right j).Left_moves), 0 ≤ (x.move_Right j).move_Left i
{α : Type u_3} {β : Type u_4} {γ : Type u_5} [CommMonoid α] {F : β → α} {g : γ → α} (h_Eq : ∀ (u : Finset γ), ∃ (v : Finset β), ∀ (v' : Finset β), v ⊆ v' → (∃ (u' : Finset γ), u ⊆ u' ∧ u'.Prod (λ (x : γ), g x) = v'.Prod (λ (B : β), F B))) : Filter.Map (λ (S : Finset β), S.Prod (λ (B : β), F B)) Filter.at_top ≤ Filter.Map (λ (S : Finset γ), S.Prod (λ (x : γ), g x)) Filter.at_top
{R : Type u_1} {m : Type u_2} [OrderedSemiring R] [ordered_AddCommMonoid m] [SmulWithZero R m] [OrderedSmul R m] {A : m} {C : R} (hc : 0 < C) : 0 < A → 0 < C • A
{S : set Ordinal} (hS : set.Unbounded has_LT.LT S) (A : Ordinal) : (S ∩ set.ici A).Nonempty
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [Finite_dimensional R m] (x₁ x₂ : Orientation R m ι) (h : Fintype.Card ι = Finite_dimensional.finrank R m) : x₁ ≠ x₂ ↔ x₁ = -x₂
{S : Type u} [Add_Semigroup S] {A B x y z : S} (ha : Add_SemiconjBy A y z) (hb : Add_SemiconjBy B x y) : Add_SemiconjBy (A + B) x z
{α : Type u} : Dense_Embedding has_pure.pure
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (F : E →L[𝕜] F) : IsBoundedLinearMap 𝕜 ⇑F
{k : Type u_1} [DivisionRing k] {ι : Type u_4} (S : Finset ι) (h : ↑(S.Card) ≠ 0) : S.Sum (λ (i : ι), Finset.centroid_weights k S i) = 1
{P : ℕ} (hp : Nat.Prime P) : P.factorization = Finsupp.single P 1
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S1 S2 : AffineSubspace k P} (hD : S1.direction = S2.direction) (hn : (↑S1 ∩ ↑S2).Nonempty) : S1 = S2
{G : Type u_7} [AddCommGroup G] (L : List G) : -L.Sum = (List.Map (λ (x : G), -x) L).Sum
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) : o.oangle (-x) y = o.oangle x (-y)
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) (B : n → α) (h : IsUnit A.det) : A.det • A⁻¹.Mul_vec B = ⇑(A.cramer) B
{ι : Type u_1} {E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {C : E} {l l' : Filter ℝ} {LT : Filter ι} {A : ℝ} [IntervalIntegral.FTC_Filter A l l'] (hfm : StronglyMeasurableAtFilter F l' MeasureTheory.MeasureSpace.Volume) (hF : Filter.Tendsto F (l' ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) {u v : ι → ℝ} (hu : Filter.Tendsto u LT l) (hv : Filter.Tendsto v LT l) : (λ (t : ι), (∫ (x : ℝ) in u t..v t, F x) - (v t - u t) • C) =o[LT] (v - u)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (F : E →ₛₗ[σ₁₂] F) {C : ℝ} (hC : 0 ≤ C) (h : ∀ (x : E), ∥⇑F x∥ ≤ C * ∥x∥) : ∥F.Mk_Continuous C h∥ ≤ C
{m : Type u_1} [has_Add m] (S : Add_Subsemigroup m) : Add_Subsemigroup.Closure ↑S = S
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [OrderedSemiring 𝕜] [AddCommGroup E] [module 𝕜 E] {P : ι → E} (hi : Function.Injective P) : Convex_Independent 𝕜 (λ (x : ↥(set.Range P)), ↑x) ↔ Convex_Independent 𝕜 P
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {S : set E} (hscomp : IsCompact S) (hsnemp : S.Nonempty) : (set.ExtremePoints ℝ S).Nonempty
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (A B C : P) : HasDist.dist A B ^ 2 + HasDist.dist A C ^ 2 = 2 * (HasDist.dist A (midpoint ℝ B C) ^ 2 + (HasDist.dist B C / 2) ^ 2)
{m : Type u_1} {N : Type u_2} [MulOneClass m] [MulOneClass N] {C : Con m} {F : N →* m} : Con.comap ⇑F _ C = Con.Ker (C.Mk'.Comp F)
(R : Type u_1) {S : Type u_2} {m : Type u_3} [CommRing R] [Ring S] [AddCommGroup m] [Algebra R S] [module S m] [module R m] [IsScalarTower R S m] (h : IsArtinian R m) : IsArtinian S m
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] : ContDiff 𝕜 ⊤ ⇑((Equiv.Prod_assoc E F G).Symm)
{R : Type u_1} [CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] : Disjoint (tensor_Algebra.ι R).Range 1
(P : ℝ × ℝ) (hp : P.fst ≠ 0) {n : WithTop ℕ} : ContDiff_at ℝ n (λ (P : ℝ × ℝ), P.fst ^ P.Snd) P
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (F : C(α, β)) : Continuous ⇑F
{α : Type u} [Preorder α] {A B : α} (h : A < B) : ¬B ≤ A
{m : Type u_1} [AddMonoid m] (u : AddUnits m) (A : m) : IsAddUnit (↑u + A) ↔ IsAddUnit A
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B : α} (ha : A < 0) (hb : B ≤ 0) : A + B < 0
{α : Type u} [PseudoEmetricSpace α] (δ : ℝ) : Metric.Thickening δ ∅ = ∅
{α : Type u} {F : Filter α} {β : Type v} {S : β → set α} ( : Finset β) : (⋂ (i : β) (h : i ∈ ), S i) ∈ F ↔ ∀ (i : β), i ∈  → S i ∈ F
{C : Type u₁} [CategoryTheory.Category C] {x Y Z : C} (P : x ⟶ Y) (q : Z = Y) : _.mpr P = P ≫ CategoryTheory.Eq_to_hom _
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) : hb.oangle (⇑(hb.rotation (hb.oangle x y)) x) y = 0
{m : Type u_1} [AddMonoid m] {S : set m} : S ⊆ AddMonoid.Closure S
{α : Type u} {β : Type v} [Preorder α] [Preorder β] (oi : α ≃o β) : GaloisConnection ⇑oi ⇑(oi.Symm)
{R : Type u_1} {m : Type u_2} [Ring R] [TopologicalSpace R] [TopologicalSpace m] [AddCommGroup m] [has_Continuous_Add m] [module R m] [has_Continuous_Smul R m] [(nhds_within 0 {x : R | IsUnit x}).Ne_IsBot] (S : Submodule R m) (hs : (Interior ↑S).Nonempty) : S = ⊤
{t : ℝ} {g : ℝ → ℝ} (hg : Function.Periodic g t) (h_Int : ∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.MeasureSpace.Volume t₁ t₂) (h₀ : ∀ (x : ℝ), 0 < g x) (hT : 0 < t) : Filter.Tendsto (λ (t : ℝ), ∫ (x : ℝ) in 0..t, g x) Filter.at_IsBot Filter.at_IsBot
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommGroup β] [HasScalar 𝕜 E] [module 𝕜 β] {S : set E} {F : E → β} : Convex_on 𝕜 S F → ConcaveOn 𝕜 S (-F)
{α : Type u} [TopologicalSpace α] (Z : ℕ → set α) (hZd : ∀ (i : ℕ), Z (i + 1) ⊆ Z i) (hZn : ∀ (i : ℕ), (Z i).Nonempty) (hZ0 : IsCompact (Z 0)) (hZcl : ∀ (i : ℕ), IsClosed (Z i)) : (⋂ (i : ℕ), Z i).Nonempty
{R : Type u_1} [CommSemiring R] (m : Submonoid R) {S : Type u_2} [CommSemiring S] [Algebra R S] [IsLocalization m S] (z : S) : ⇑(Algebra_Map R S) (IsLocalization.sec m z).fst = ⇑(Algebra_Map R S) ↑((IsLocalization.sec m z).Snd) * z
{R : Type u_1} {A B : R} [comm_Semigroup R] : IsRegular (A * B) ↔ IsRegular A ∧ IsRegular B
{η : Type u_5} {F : η → Type u_6} [Π (i : η), Group (F i)] [DecidableEq η] [Fintype η] {h : Π (i : η), Subgroup (F i)} {J : Subgroup (Π (i : η), F i)} : Subgroup.Pi set.Univ h ≤ J ↔ ∀ (i : η), Subgroup.Map (Monoid_hom.single F i) (h i) ≤ J
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} {S : set α} (hF : set.Eq_on F 1 S) : finprod (λ (i : α), finprod (λ (h : i ∈ S), F i)) = 1
(k : Type u_1) {v : Type u_2} (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) (S : AffineSubspace k P) : P ∈ ↑S ↔ P ∈ S
{Γ₀ : Type u_1} [Linear_ordered_comm_Group_with_Zero Γ₀] (γ : Γ₀ˣ) : {↑γ} ∈ nhds ↑γ
{α : Type u} [PseudoMetricSpace α] {S t : set α} {r : ℝ} (hr : 0 ≤ r) (h1 : ∀ (x : α), x ∈ S → metric.Inf_dist x t ≤ r) (h2 : ∀ (x : α), x ∈ t → metric.Inf_dist x S ≤ r) : metric.Hausdorff_dist S t ≤ r
{R : Type u_1} {R₁ : Type u_2} {R₂ : Type u_3} {m₁ : Type u_6} {m₂ : Type u_7} [CommSemiring R] [CommSemiring R₁] [AddCommMonoid m₁] [module R₁ m₁] [CommSemiring R₂] [AddCommMonoid m₂] [module R₂ m₂] {i₁ : R₁ →+* R} {i₂ : R₂ →+* R} {B : m₁ →ₛₗ[i₁] m₂ →ₛₗ[i₂] R} : B.separating_Left ↔ B.Ker = ⊥
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {ps : set P} {n : ℕ} [Finite_dimensional ℝ v] (hD : Finite_dimensional.finrank ℝ v = n) (hc : EuclideanGeometry.Cospherical ps) {sx₁ sx₂ : Affine.Simplex ℝ P n} (hsx₁ : set.Range sx₁.points ⊆ ps) (hsx₂ : set.Range sx₂.points ⊆ ps) : sx₁.circumcenter = sx₂.circumcenter
{α : Type u_1} {P : Prop} {q : α → Prop} : P → ∀ (x : α), q x ↔ ∀ (x : α), P → q x
{m : Type u_1} [AddMonoid m] (C : Add_Con m) (n : ℕ) {W x : m} : ⇑C W x → ⇑C (n • W) (n • x)
{R : Type u} {N : Type z} [Semiring R] [AddCommMonoid N] [module R N] {P : Type v} [AddCommMonoid P] [module R P] (h : module.free R P) (e : P ≃ₗ[R] N) : module.free R N
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] {A B : α} (hab : A ≠ B) : Closure (set.Ico A B) = set.icc A B
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] (O : Finset C) (h : Finset (Σ' (x Y : C) (mX : x ∈ O) (mY : Y ∈ O), x ⟶ Y)) {x Y : C} (mX : x ∈ O) (mY : Y ∈ O) {F : x ⟶ Y} (mf : ⟨x, ⟨Y, ⟨mX, ⟨mY, F⟩⟩⟩⟩ ∈ h) : CategoryTheory.IsCofiltered.Inf_to O h mX ≫ F = CategoryTheory.IsCofiltered.Inf_to O h mY
{α : Type u_1} {β : Type u_2} [AddCommGroup α] [UniformSpace α] [uniform_AddGroup α] [t1_Space α] (F : β → α) : Filter.Tendsto (λ (S : Finset β), ∑' (B : {x // x ∉ S}), F ↑B) Filter.at_top (nhds 0)
{R : Type u_1} {A : Type u_2} [CommSemiring R] [Semiring A] [Algebra R A] (h : Function.Injective ⇑(Algebra_Map R A)) (P : ℕ) [Char_P R P] : Char_P A P
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] {P1 P2 : P} (h : P1 -ᵥ P2 = 0) : P1 = P2
{G : Type u_1} [AddGroup G] [hN : Nontrivial G] : AddMonoid._torsion G → ¬AddMonoid._torsion_free G
{α : Type u} {β : Type v} {γ : Type W} [TopologicalSpace α] [PseudoMetricSpace β] [PseudoMetricSpace γ] {G : β → γ} {C : Nnreal} (h : LipschitzWith C G) : uniform_Continuous (bounded_Continuous_Function.Comp G h)
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {q : QuadraticForm R m} (A B : m) : ⇑(clifford_Algebra.ι q) A * ⇑(clifford_Algebra.ι q) B + ⇑(clifford_Algebra.ι q) B * ⇑(clifford_Algebra.ι q) A = ⇑(Algebra_Map R (clifford_Algebra q)) (QuadraticForm.polar ⇑q A B)
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] (F : m →* P) : Function.Injective ⇑(Con.Ker_Lift F)
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] {S t : intermediate_Field K L} (h : ∀ (x : L), x ∈ S ↔ x ∈ t) : S = t
{R : Type u} {L : Type v} {L' : Type W₂} [CommRing R] [lie_Ring L] [lie_Algebra R L] [lie_Ring L'] [lie_Algebra R L'] (F : L →ₗ⁅R⁆ L') {i₁ i₂ : lie_Ideal R L} : lie_Ideal.Map F ⁅i₁,i₂⁆ ≤ ⁅lie_Ideal.Map F i₁,lie_Ideal.Map F i₂⁆
{α : Type u} [TopologicalSpace α] {S : set α} : IsClosed (Frontier S)
{G : Type u_1} [Group G] (h : Subgroup G) : h = ⊥ ∨ ∃ (x : G) (h : x ∈ h), x ≠ 1
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {F : E × F → G} (h : IsBoundedBilinearMap 𝕜 F) : Continuous F
{α : Type u} [PseudoMetricSpace α] {F : ℕ → α} {m n : ℕ} (hmn : m ≤ n) {D : ℕ → ℝ} (hD : ∀ {k : ℕ}, m ≤ k → k < n → HasDist.dist (F k) (F (k + 1)) ≤ D k) : HasDist.dist (F m) (F n) ≤ (Finset.Ico m n).Sum (λ (i : ℕ), D i)
{A : Type u_4} [CommRing A] [IsDomain A] {L : Type u_6} [Field L] [Algebra A L] (alg : Algebra.IsAlgebraic A L) (inj : ∀ (x : A), ⇑(Algebra_Map A L) x = 0 → x = 0) : _fraction_Ring ↥(integral_Closure A L) L
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] (q : FormalMultilinearSeries 𝕜 F G) (P : FormalMultilinearSeries 𝕜 E F) (N : ℕ) (z : E) : q.partial_Sum N ((Finset.Ico 1 N).Sum (λ (i : ℕ), ⇑(P i) (λ (j : Fin i), z))) = (FormalMultilinearSeries.Comp_partial_Sum_Target 0 N N).Sum (λ (i : Σ (n : ℕ), Composition n), ⇑(q.Comp_along_Composition P i.Snd) (λ (j : Fin i.fst), z))
{α : sort u_1} (P : Prop) [Decidable P] (A B : α) : dite P (λ (h : P), A) (λ (h : ¬P), B) = Ite P A B
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {P : Filter ι} (h : TendstoUniformly F F P) (g : γ → α) : TendstoUniformly (λ (n : ι), F n ∘ g) (F ∘ g) P
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F : x ⟶ Y} {F F' : CategoryTheory.Limits.MonoFactorisation F} (hI : F.i = F'.i) (hm : F.m = CategoryTheory.Eq_to_hom hI ≫ F'.m) : F = F'
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (S : Affine.Simplex ℝ P 0) (i : Fin 1) : S.circumcenter = S.points i
{m : Type u_1} [Nonempty m] [Semigroup m] [TopologicalSpace m] [CompactSpace m] [t2_Space m] (Continuous_Mul_Left : ∀ (r : m), Continuous (λ (_x : m), _x * r)) : ∃ (m : m), m * m = m
{R : Type u_1} (m : Type u_3) [Monoid R] [MulAction R m] (A : Rˣ) : IsSmulRegular m ↑A
{cb : CharBuffer} {n n' val : ℕ} (h : Parser.Nat cb n = ParseResult.done n' val) (hn : n' < Buffer.size cb) : '0' ≤ Buffer.read cb ⟨n', hn⟩ → '9' < Buffer.read cb ⟨n', hn⟩
{α : Type u} {F g : α → α} (h : Function.Commute F g) : set.bij_on F (Function.FixedPoints (F ∘ g)) (Function.FixedPoints (F ∘ g))
{F : Type u_3} [InnerProductSpace ℝ F] (K : Submodule ℝ F) {u v : F} (hv : v ∈ K) : (∥u - v∥ = ⨅ (W : ↥↑K), ∥u - ↑W∥) ↔ ∀ (W : F), W ∈ K → HasInner.inner (u - v) W = 0
{α : Type u} {β : Type v} [Preorder β] {F : α → β} {l : Filter α} {A : α} : IsMax_Filter (⇑order_dual.to_dual ∘ F) l A → IsMin_Filter F l A
{m : Type u_1} {n : Type u_2} [Fintype m] [Fintype n] {R : Type v} [Field R] : Finite_dimensional.finrank R (Matrix m n R) = Fintype.Card m * Fintype.Card n
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {F' : E →L[𝕜] F} {x : E} (hF : HasStrictFderivAt F F' x) (K : Nnreal) (hK : ∥F'∥₊ < K) : ∃ (S : set E) (h : S ∈ nhds x), LipschitzOnWith K F S
(n : ℕ+) : n.factor_Multiset.Prod = n
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A B : α} (ha : A < 1) (hb : B < 1) : A * B < 1
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasZeroMorphisms C] (x : C) : CategoryTheory.IsPullback 0 0 0 (𝟙 x)
{m : Type u_1} [Monoid m] (C : Con m) (n : ℕ) {W x : m} : ⇑C W x → ⇑C (W ^ n) (x ^ n)
{α : Type u_1} {m : Type u_5} [has_Zero m] {B : m} (h : B ≠ 0) : Function.Injective (λ (A : α), Finsupp.single A B)
{C : Type u₁} [CategoryTheory.Category C] {x Y : C} {F : x ⟶ Y} [CategoryTheory.SplitMono F] [CategoryTheory.Mono (CategoryTheory.retraction F)] : CategoryTheory.IsIso F
{ι : Type u} {β : ι → Type v} [dec : DecidableEq ι] [Π (i : ι), has_Zero (β i)] {i j : ι} {xi : β i} {xj : β j} (h : ⟨i, xi⟩ = ⟨j, xj⟩) : Dfinsupp.single i xi = Dfinsupp.single j xj
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] {m : Matrix n n R} {i j : n} (i_Ne_j : i ≠ j) (hij : m i = m j) : m.det = 0
(r : Ennreal) : ∑' (n : ℕ), r ^ n = (1 - r)⁻¹
{P : ℕ} [Fact (Nat.Prime P)] : WittVector.IsPoly₂ P (λ (_x : Type u_1) (_x_1 : CommRing _x), has_Mul.Mul)
{R : Type u_2} {Γ₀ : Type u_3} [Ring R] [Linear_ordered_CommMonoid_with_Zero Γ₀] {v₁ v₂ : Valuation R Γ₀} : v₁ = v₂ ↔ ∀ (r : R), ⇑v₁ r = ⇑v₂ r
(R : Type u) (L : Type v) [CommRing R] [lie_Ring L] [lie_Algebra R L] (h : LieSubalgebra R L) [lie_Algebra.IsNilpotent R ↥h] (h : lie_Algebra.Zero_root_Subalgebra R L h = h) : h._cartan_Subalgebra
{α : Type u_1} {𝒜 : Finset (Finset α)} {r : ℕ} : 𝒜.Slice r ⊆ 𝒜
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LE.LE] {A B : α} (ha : A ≤ 0) (hb : B ≤ 0) : A + B ≤ 0
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x : v} (hx : x ≠ 0) (θ : Real.Angle) : o.oangle (⇑(o.rotation θ) x) x = -θ
{G : Type u_3} [AddGroup G] : AddGroup.fg G ↔ ∃ (S : set G), Add_Subgroup.Closure S = ⊤ ∧ S.Finite
(A B C : ℝ) (hb : 0 ≠ B) : Filter.Tendsto (λ (x : ℝ), x ^ (A / (B * x + C))) Filter.at_top (nhds 1)
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {x y : m} : SameRay R (-x) (-y) → SameRay R x y
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {C₁ C₂ P₁ P₂ : P} (hc₁ : HasDist.dist P₁ C₁ = HasDist.dist P₂ C₁) (hc₂ : HasDist.dist P₁ C₂ = HasDist.dist P₂ C₂) : HasInner.inner (C₂ -ᵥ C₁) (P₂ -ᵥ P₁) = 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {P : ι → P} (hi : AffineIndependent k P) {S : Finset ι} {sp : AffineSubspace k P} [Finite_dimensional k ↥(sp.direction)] (hle : affine_Span k ↑(Finset.image P S) ≤ sp) (hc : S.Card = Finite_dimensional.finrank k ↥(sp.direction) + 1) : affine_Span k ↑(Finset.image P S) = sp
{α : Type u_1} {β : Type u_2} [AddCommGroup α] [UniformSpace α] [CompleteSpace α] {F : β → α} : Summable F ↔ Cauchy_Seq (λ (S : Finset β), S.Sum (λ (B : β), F B))
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} {v : v} {S : set ι} {P : ι → P} : (∃ (fs : Finset ι) (hfs : ↑fs ⊆ S) (W : ι → k) (hw : fs.Sum (λ (i : ι), W i) = 0), v = ⇑(fs.weighted_vsub P) W) ↔ ∃ (fs : Finset ↥S) (W : ↥S → k) (hw : fs.Sum (λ (i : ↥S), W i) = 0), v = ⇑(fs.weighted_vsub (λ (i : ↥S), P ↑i)) W
{α : Type u} {β : Type v} {S : set β} (hs : S.Subsingleton) {F : α → β} (hF : Function.Injective F) : (F ⁻¹' S).Subsingleton
{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] : IsNoetherian R m ↔ ∀ (S : Submodule R m), S.fg
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] {S : set α} (hs : IsConnected S) (hb : BddBelow S) (ha : BddAbove S) : set.Ioo (HasInf.Inf S) (HasSup.Sup S) ⊆ S
{ι : Type u_1} {R : Type u_3} {A : Type u_5} {x : ι → A} [CommRing R] [CommRing A] [Algebra R A] {K : Type u_2} [CommRing K] [Algebra R K] [Algebra K A] [IsScalarTower R K A] (hinj : Function.Injective ⇑(Algebra_Map R K)) (ai : AlgebraicIndependent K x) : AlgebraicIndependent R x
{n : WithTop ℕ} {𝕂 : Type u_6} [_R_or_C 𝕂] {E' : Type u_7} [NormedGroup E'] [NormedSpace 𝕂 E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {F : E' → F'} {x : E'} (hF : ContDiff_at 𝕂 n F x) (hn : 1 ≤ n) : HasStrictFderivAt F (fderiv 𝕂 F x) x
{A B C : Prop} : A ∨ B ∧ C ↔ (A ∨ B) ∧ (A ∨ C)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_5} [NormedGroup E'] [NormedSpace 𝕜 E'] {n : WithTop ℕ} {F : E → E'} {S : set E} : Cont_mdiff_on (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n F S → ContDiff_on 𝕜 n F S
{α : Type u_1} {β : Type u_2} {m : Type u_3} [Fintype α] [Fintype β] [CommMonoid m] (e : α ≃ β) (F : α → m) (g : β → m) (h : ∀ (x : α), F x = g (⇑e x)) : Finset.Univ.Prod (λ (x : α), F x) = Finset.Univ.Prod (λ (x : β), g x)
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A B : α} (ha : A < 1) (hb : B < 1) : A * B < 1
{α : Type uu} [DecidableEq α] {l₁ l₂ : List α} : l₁ <+~ l₂ ↔ ∀ (x : α), x ∈ l₁ → List.count x l₁ ≤ List.count x l₂
{ι : Type u_1} {m : Type u_4} [ordered_AddCommMonoid m] {S : Finset ι} {F : ι → WithTop m} : S.Sum (λ (i : ι), F i) < ⊤ ↔ ∀ (i : ι), i ∈ S → F i < ⊤
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x₁ x₂ y z : v} (hx₁yne : x₁ ≠ y) (hx₁zne : x₁ ≠ z) (hx₂yne : x₂ ≠ y) (hx₂zne : x₂ ≠ z) {r : ℝ} (hx₁ : ∥x₁∥ = r) (hx₂ : ∥x₂∥ = r) (hy : ∥y∥ = r) (hz : ∥z∥ = r) : 2 • hb.oangle (y - x₁) (z - x₁) = 2 • hb.oangle (y - x₂) (z - x₂)
{A : Type u_1} (B : Type u_2) [Ring A] [Ring B] [IsDomain B] (e : A ≃+* B) : IsDomain A
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {S : set E} {F : E → 𝕜} {g : E → F} (hF : ContDiff_on 𝕜 n F S) (hg : ContDiff_on 𝕜 n g S) : ContDiff_on 𝕜 n (λ (x : E), F x • g x) S
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : AffineSubspace k P) : S.direction = Vector_Span k ↑S
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] (F : ℂ → E) (F' : ℂ → (ℂ →L[ℝ] E)) (z W : ℂ) (Hc : Continuous_on F (set.Interval z.re W.re ×ℂ set.Interval z.im W.im)) (hD : ∀ (x : ℂ), x ∈ set.Ioo (LinearOrder.min z.re W.re) (LinearOrder.max z.re W.re) ×ℂ set.Ioo (LinearOrder.min z.im W.im) (LinearOrder.max z.im W.im) → HasFderivAt F (F' x) x) (Hi : MeasureTheory.IntegrableOn (λ (z : ℂ), Complex.i • ⇑(F' z) 1 - ⇑(F' z) Complex.i) (set.Interval z.re W.re ×ℂ set.Interval z.im W.im) MeasureTheory.MeasureSpace.Volume) : (((∫ (x : ℝ) in z.re..W.re, F (↑x + ↑(z.im) * Complex.i)) - ∫ (x : ℝ) in z.re..W.re, F (↑x + ↑(W.im) * Complex.i)) + Complex.i • ∫ (y : ℝ) in z.im..W.im, F (↑(W.re) + ↑y * Complex.i)) - Complex.i • ∫ (y : ℝ) in z.im..W.im, F (↑(z.re) + ↑y * Complex.i) = ∫ (x : ℝ) in z.re..W.re, ∫ (y : ℝ) in z.im..W.im, Complex.i • ⇑(F' (↑x + ↑y * Complex.i)) 1 - ⇑(F' (↑x + ↑y * Complex.i)) Complex.i
{K : Type u_1} {v : K} {n : ℕ} [Linear_ordered_Field K] [FloorRing K] {A : K} (nth_Part_Num_Eq : (GeneralizedContinuedFraction.of v).partial_numerators.nth n = Option.Some A) : A = 1
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] [Fintype α] [Fintype β] (F : α → β) {B : m} [Linear_ordered_CommRing m] (hb : ↑(Fintype.Card α) < Fintype.Card β • B) : ∃ (y : β), ↑((Finset.Filter (λ (x : α), F x = y) Finset.Univ).Card) < B
{α : Type u} [Preorder α] {A B : α} (h : A < B) : ¬B < A
{α : Type u_1} {E : α → Type u_2} {P : Ennreal} [Π (i : α), NormedGroup (E i)] [DecidableEq α] [Fact (1 ≤ P)] (hp : P ≠ ⊤) (F : ↥(Lp E P)) : has_Sum (λ (i : α), Lp.single P i (⇑F i)) F
{G : Type u} {y : G} [AddMonoid G] {x : G} (h : Add_Commute x y) (hx : _of_Fin_Add_order x) (hy : _of_Fin_Add_order y) : _of_Fin_Add_order (x + y)
(θ : ℂ) (n : ℕ) : Polynomial.Eval (Complex.cos θ) (Polynomial.Chebyshev.t ℂ n) = Complex.cos (↑n * θ)
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_3} [DecidableEq ι] [Fintype ι] (e : Basis ι R m) (F : m ≃ₗ[R] m) : (e.Map F).Orientation = e.Orientation ↔ 0 < ⇑LinearMap.det ↑F
{A : Type u_1} [CommRing A] [Algebra ℚ A] (t : A) : PowerSeries.Mk (λ (n : ℕ), ⇑(Polynomial.aeval t) ((1 / ↑(n.factorial)) • Polynomial.bernoulli n)) * (PowerSeries.Exp A - 1) = PowerSeries.x * ⇑(PowerSeries.rescale t) (PowerSeries.Exp A)
{P : ℕ+} {k : ℕ} [hp : Fact (Nat.Prime ↑P)] : IsIntegral_Closure (cyclotomic_Ring (P ^ k) ℤ ℚ) ℤ (cyclotomic_Field (P ^ k) ℚ)
{α : Type u_1} [DecidableEq α] (A : α) : Derangements.Equiv.RemoveNone.fiber (Option.Some A) = {F : Equiv.perm α | Function.FixedPoints ⇑F ⊆ {A}}
{m : Type u_1} [has_Add m] {S t : Add_Subsemigroup m} (h : ∀ (x : m), x ∈ S ↔ x ∈ t) : S = t
{m : Type u} [Monoid m] {x y : m} (hxy : x ∣ y) {n : ℕ} (hn : n ≠ 0) : x ∣ y ^ n
{α : Type u_1} {β : Type u_2} [PseudoMetricSpace α] [PseudoMetricSpace β] {K : Nnreal} {F : α → β} : AntilipschitzWith K F → ∀ (x y : α), HasDist.dist x y ≤ ↑K * HasDist.dist (F x) (F y)
{α : Type u} {ι : Type v} [MetricSpace α] [ProperSpace α] {C : ι → α} {r : ι → ℝ} (hr : ∀ (i : ι), 0 < r i) (uf : ∀ (x : α), {i : ι | x ∈ Metric.Ball (C i) (r i)}.Finite) (uU : (⋃ (i : ι), Metric.Ball (C i) (r i)) = set.Univ) : ∃ (r' : ι → ℝ), (⋃ (i : ι), Metric.Ball (C i) (r' i)) = set.Univ ∧ ∀ (i : ι), r' i ∈ set.Ioo 0 (r i)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} {x : E} {F' : TangentSpace (model_with_corners_self 𝕜 E) x →L[𝕜] TangentSpace (model_with_corners_self 𝕜 E') (F x)} : HasMfderivAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F x F' → HasFderivAt F F' x
{G : Type u_1} [AddGroup G] (tG : AddMonoid._torsion_free G) (h : Add_Subgroup G) : AddMonoid._torsion_free ↥h
{α : Type u} [PseudoMetricSpace α] {S : set α} {x y : α} : metric.Inf_dist x S ≤ metric.Inf_dist y S + HasDist.dist x y
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m →+ P} {t : Add_Submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ t) {q : Type u_4} [AddCommMonoid q] {k : t.Localization_Map q} {A : Type u_5} [AddCommMonoid A] {U : Add_Submonoid A} {R : Type u_6} [AddCommMonoid R] (j : U.Localization_Map R) {l : P →+ A} (hl : ∀ (W : ↥t), ⇑l ↑W ∈ U) : (k.Map hl j).Comp (F.Map hy k) = F.Map _ j
{α : Type u_1} [Preorder α] [BoundedOrder α] [IsSimpleOrder α] {A B : α} (h : A < B) : B = ⊤
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k → E} {A B r : k} (hab : A < B) (h₀ : 0 < r) (h₁ : r < 1) : F (⇑(affine_Map.line_Map A B) r) < ⇑(affine_Map.line_Map (F A) (F B)) r ↔ slope F A (⇑(affine_Map.line_Map A B) r) < slope F (⇑(affine_Map.line_Map A B) r) B
{A : Type u_1} {R : Type u_2} (K : Type u_3) [CommRing A] [IsDomain A] [normalized_Gcd_Monoid A] [Field K] [CommRing R] [IsDomain R] [Algebra A K] [_fraction_Ring A K] [Algebra K R] [Algebra A R] [IsScalarTower A K R] {x : R} (hx : IsIntegral A x) : minpoly K x = Polynomial.Map (Algebra_Map A K) (minpoly A x)
{R : Type u_1} {m : Type u_3} {A B : R} [Monoid R] [MulAction R m] (h : A * B = 1) : IsSmulRegular m B
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {F : E → G} {x : E} {y : F} (hF : ContDiff_at 𝕜 n F x) : ContDiff_at 𝕜 n (λ (x : E × F), F x.fst) (x, y)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {F g : E → F} (hF : ContDiff 𝕜 n F) (hg : ContDiff 𝕜 n g) : ContDiff 𝕜 n (λ (x : E), F x - g x)
{α : Type u} [PseudoMetricSpace α] {S : set α} {C : ℝ} (h₀ : 0 ≤ C) (h : ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → HasDist.dist x y ≤ C) : Metric.diam S ≤ C
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {x : E} {n : WithTop ℕ} {F : E → F} {g : E → G} (hF : ContDiff_at 𝕜 n F x) (hg : ContDiff_at 𝕜 n g x) : ContDiff_at 𝕜 n (λ (x : E), (F x, g x)) x
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] : IsNoetherian K v ↔ module.Finite K v
(R : Type u) [Ring R] [strong_RankCondition R] (m n : Type u) [Fintype m] [Fintype n] : module.rank R (Matrix m n R) = Cardinal.Mk m * Cardinal.Mk n
{α : Type u} [PartialOrder α] {A B : α} : A ≤ B → A ≠ B → A < B
{m₀ : Type u_1} [Mul_Zero_class m₀] [no_Zero_divisors m₀] {A B : m₀} : A * B ≠ 0 ↔ B * A ≠ 0
{α : Type u_1} [PartialOrder α] [SuccOrder α] [IsSuccArchimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ set.Ico n m → r i (Order.Succ i)) (hnm : n < m) : Relation.TransGen r n m
{A : Type u_1} {K : Type u_2} [CommRing A] [IsDomain A] [Unique_factorization_Monoid A] [Field K] [Algebra A K] [_fraction_Ring A K] {P : Polynomial A} (hp : P.monic) {r : K} (hr : ⇑(Polynomial.aeval r) P = 0) : IsLocalization._integer A r
(𝕜 : Type u_1) {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {v : E} (W : E) : ↑(⇑(Orthogonal_projection (Submodule.Span 𝕜 {v})) W) = (HasInner.inner v W / ↑∥v∥ ^ 2) • v
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] [DenselyOrdered β] {F : α → β} (h_Mono : Monotone F) (h_surj : Function.Surjective F) : Continuous F
{α : Type u} {S : set α} : S.Finite ∨ S.Infinite
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace 𝕜] (S : Submodule 𝕜 E) [Finite_dimensional 𝕜 ↥S] : IsComplete ↑S
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B : α} (ha : 0 ≤ A) (hb : 0 < B) : 0 < A + B
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [Nontrivial E] {x : E} {r : ℝ} : (Metric.Sphere x r).Nonempty ↔ 0 ≤ r
{ι : Type u_1} {N : Type u_5} [ordered_AddCommMonoid N] {F g : ι → N} {S : Finset ι} (h : ∀ (i : ι), i ∈ S → F i ≤ g i) : S.Sum (λ (i : ι), F i) ≤ S.Sum (λ (i : ι), g i)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) (l₁ l₂ : ι → 𝕜) (S : Finset ι) : HasInner.inner (S.Sum (λ (i : ι), l₁ i • v i)) (S.Sum (λ (i : ι), l₂ i • v i)) = S.Sum (λ (i : ι), ⇑(Star_Ring_end 𝕜) (l₁ i) * l₂ i)
{G : Type u_1} [AddGroup G] (g1 g2 : G) : g1 -ᵥ g2 = g1 - g2
{P : Type u_2} [MetricSpace P] (ps : set P) : EuclideanGeometry.Cospherical ps ↔ ∃ (Center : P) (radius : ℝ), ∀ (P : P), P ∈ ps → HasDist.dist P Center = radius
{α : Type u_1} [TopologicalSpace α] {S : set α} {γ : Type u_4} [Linear_ordered_AddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] [has_Continuous_Add γ] {F g : α → γ} (hF : LowerSemicontinuousOn F S) (hg : LowerSemicontinuousOn g S) : LowerSemicontinuousOn (λ (z : α), F z + g z) S
(A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {P : Polynomial A} (pnz : P ≠ 0) (hp : ⇑(Polynomial.aeval x) P = 0) : (minpoly A x).degree ≤ P.degree
{α : Type u} {β : Type v} [PseudoEmetricSpace α] [PseudoEmetricSpace β] {F : α → β} (hF : Isometry F) : Continuous F
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Finite_dimensional k v] {S : set P} (hi : AffineIndependent k Coe) : S.Finite
{ι : Type u_1} {E : Type u_3} [semi_NormedGroup E] [CompleteSpace E] {F : ι → E} (g : ι → ℝ) (hg : Summable g) (h : ∀ᶠ (i : ι) in Filter.cofinite, ∥F i∥ ≤ g i) : Summable F
{α : Type u} [AddCommGroup α] [has_LE α] [CovariantClass α α has_Add.Add has_LE.LE] {A B C : α} : A - B ≤ C → A ≤ B + C
{α : Type u} [PseudoMetricSpace α] {S : set α} : metric.Hausdorff_dist S S = 0
{K : Type u} [Field K] {S : set K} : S ⊆ ↑(Subfield.Closure S)
{ι : Type u_1} {R : Type u_4} [DecidableEq ι] [AddMonoid ι] [Semiring R] (A : ι → Add_Submonoid R) [set_like.graded_Monoid A] (i : ι) (x : ↥(A i)) : ⇑(direct_Sum.Coe_Ring_hom A) (⇑(direct_Sum.of (λ (i : ι), ↥(A i)) i) x) = ↑x
{α β : Type u} (r : α → α → Prop) [wo : IsWellOrder α r] (S : β → set α) (h₁ : set.Unbounded r (⋃ (x : β), S x)) (h₂ : Cardinal.Mk β < StrictOrder.cof r) : ∃ (x : β), set.Unbounded r (S x)
{J : Type u₁} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {F G : J ⥤ C} [CategoryTheory.Limits.HasLimit F] (α : F ≅ G) : CategoryTheory.Limits.HasLimit G
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace ℝ P) [Nonempty ↥S] [CompleteSpace ↥(S.direction)] (P : P) : ⇑(EuclideanGeometry.reflection S) P = ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P) -ᵥ P +ᵥ ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P)
{n : ℕ} (P : Fin (n + 1)) (i : Fin n) (h : ⇑Fin.cast_Succ i < P) : ⇑(P.Succ_above) i = ⇑Fin.cast_Succ i
{G : Type u_1} [AddGroup G] (h N : Add_Subgroup G) [N.Normal] : ↑(h ⊔ N) = ↑h + ↑N
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} {t : set (set α)} (h : t.Pairwise_Disjoint Id) (ht₀ : t.Finite) (ht₁ : ∀ (x : set α), x ∈ t → x.Finite) : finsum (λ (A : α), finsum (λ (h : A ∈ ⋃₀t), F A)) = finsum (λ (S : set α), finsum (λ (h : S ∈ t), finsum (λ (A : α), finsum (λ (h : A ∈ S), F A))))
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (θ₁ θ₂ : Real.Angle) : (o.rotation θ₁).Trans (o.rotation θ₂) = o.rotation (θ₂ + θ₁)
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : α → E} {g' : α → F'} {l : Filter α} : F =O[l] g' ↔ ∀ᶠ (C : ℝ) in Filter.at_top, Asymptotics._O_with C l F g'
{α : Type u_1} [LinearOrder α] {S : set α} : ¬BddAbove S ↔ ∀ (x : α), ∃ (y : α) (h : y ∈ S), x < y
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] {A B : Matrix n n α} (h : A.Mul B = 1) : A⁻¹ = B
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.ConcreteCategory.Forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.ConcreteCategory.Forget C)] {x : top} (F : top.sheaf C x) {ι : Type v} (U : ι → TopologicalSpace.Opens ↥x) (v : TopologicalSpace.Opens ↥x) (iUV : Π (i : ι), U i ⟶ v) (hcover : v ≤ supr U) (sf : Π (i : ι), ↥(F.val.obj (Opposite.Op (U i)))) (h : F.val._compatible U sf) : ∃! (S : ↥(F.val.obj (Opposite.Op v))), ∀ (i : ι), ⇑(F.val.Map (iUV i).Op) S = sf i
(n k : ℕ) : n.factorial * n.asc_factorial k = (n + k).factorial
{α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β] (e : α ≃ᵐ β) : Measurable_Embedding ⇑e
{F : Type u_3} [InnerProductSpace ℝ F] (x : F) (r : ℝ) : HasInner.inner x (r • x) = r * (∥x∥ * ∥x∥)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) : hb.oangle (⇑(hb.rotation θ) x) y = hb.oangle x y - θ
 : CategoryTheory.EssSurj Compactum_to_CompHaus
{D : set ℝ} (hD : Convex ℝ D) (hD₂ : IsOpen D) {F : ℝ → ℝ} (hF' : DifferentiableOn ℝ F D) (hF'' : DifferentiableOn ℝ (deriv F) D) (hF''_nonpos : ∀ (x : ℝ), x ∈ D → deriv^[2] F x ≤ 0) : ConcaveOn ℝ D F
{k : Type u_1} {K : Type u_2} [Field k] [_alg_IsClosed k] [Field K] {F : k →+* K} (P : Polynomial k) : Polynomial.Splits F P
{k : Type u_1} {v : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Finite_dimensional k v] [Fintype ι] {P : ι → P} (hi : AffineIndependent k P) (hc : Fintype.Card ι = Finite_dimensional.finrank k v + 1) : Vector_Span k (set.Range P) = ⊤
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P : C} (q : C) (A : ↥P) : ⇑0 A = 0
{E : Type u_1} {F : Type u_2} {𝕜 : Type u_3} {𝕜₂ : Type u_4} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [Ring_hom_isometric σ₁₂] {ι : Type u_5} [CompleteSpace E] {g : ι → (E →sl[σ₁₂] F)} (h : ∀ (x : E), (⨆ (i : ι), ↑∥⇑(g i) x∥₊) < ⊤) : (⨆ (i : ι), ↑∥g i∥₊) < ⊤
{G : Type u_1} [AddGroup G] {x y : G} : y ∈ Add_Subgroup.Closure {x} ↔ ∃ (n : ℤ), n • x = y
{G : Type u_1} [AddGroup G] (h : Add_Subgroup G) {x y : G} : x ∈ h → y ∈ h → x + y ∈ h
{m : Type u_1} [MulOneClass m] {C : Con m} : ↑1 = 1
{R : Type u_1} [Mul_Zero_class R] (h : IsRegular 0) : Subsingleton R
{C : Type u} [CategoryTheory.Category C] {J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ C) [CategoryTheory.Limits.HasLimit (CategoryTheory.Discrete.Functor F.obj)] [CategoryTheory.Limits.HasLimit (CategoryTheory.Discrete.Functor (λ (F : Σ (P : J × J), P.fst ⟶ P.Snd), F.obj F.fst.Snd))] [CategoryTheory.Limits.HasEqualizers C] : CategoryTheory.Limits.HasLimit F
{η : Type u_2} [Fintype η] {Gs : η → Type u_3} [Π (i : η), Group (Gs i)] [∀ (i : η), Group.IsNilpotent (Gs i)] : Group.nilpotency_class (Π (i : η), Gs i) = Finset.Univ.Sup (λ (i : η), Group.nilpotency_class (Gs i))
{α : Type u} [Group α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A : α} : A⁻¹ < 1 ↔ 1 < A
{P : ℕ} (hp : Nat.Prime P) (n : ℕ) : (P ^ (n + 1)).Totient = P ^ n * (P - 1)
{α : Type u} [PseudoEmetricSpace α] {F : ℕ → α} {m n : ℕ} (hmn : m ≤ n) {D : ℕ → Ennreal} (hD : ∀ {k : ℕ}, m ≤ k → k < n → HasEdist.edist (F k) (F (k + 1)) ≤ D k) : HasEdist.edist (F m) (F n) ≤ (Finset.Ico m n).Sum (λ (i : ℕ), D i)
{R : Type u_4} {S : Type u_5} [non_assoc_Semiring R] [non_assoc_Semiring S] (F : R ≃+* S) : ⇑F 1 = 1
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {ps : set P} {n : ℕ} [Finite_dimensional ℝ v] (hD : Finite_dimensional.finrank ℝ v = n) (hc : EuclideanGeometry.Cospherical ps) {sx₁ sx₂ : Affine.Simplex ℝ P n} (hsx₁ : set.Range sx₁.points ⊆ ps) (hsx₂ : set.Range sx₂.points ⊆ ps) : sx₁.circumradius = sx₂.circumradius
 : List.Nat.antidiagonal 0 = [(0, 0)]
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A B : α} (ha : A < 1) (hb : B ≤ 1) : A * B < 1
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D ⥤ C} [CategoryTheory.Reflective i] (x : C) : (CategoryTheory.adjunction.of_Right_Adjoint i).Unit.App (i.obj ((CategoryTheory.IsLeftAdjoint i).obj x)) = i.Map ((CategoryTheory.IsLeftAdjoint i).Map ((CategoryTheory.adjunction.of_Right_Adjoint i).Unit.App x))
 : Multiset.Nat.antidiagonal 0 = {(0, 0)}
{α : Type u} [TopologicalSpace α] [t2_Space α] {K U v : set α} (hK : IsCompact K) (hU : IsOpen U) (hV : IsOpen v) (h2K : K ⊆ U ∪ v) : ∃ (K₁ K₂ : set α), IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ v ∧ K = K₁ ∪ K₂
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra A B] [Algebra R B] [Algebra R A] [IsScalarTower R A B] (A_Int : Algebra.IsIntegral R A) (x : B) (hx : IsIntegral A x) : IsIntegral R x
{x y : Pgame} (ox : x.Numeric) (oy : y.Numeric) : x < y ↔ (∃ (i : y.Left_moves), (∀ (i' : x.Left_moves), x.move_Left i' < y.move_Left i) ∧ ∀ (j : (y.move_Left i).Right_moves), x < (y.move_Left i).move_Right j) ∨ ∃ (j : x.Right_moves), (∀ (i : (x.move_Right j).Left_moves), (x.move_Right j).move_Left i < y) ∧ ∀ (j' : y.Right_moves), x.move_Right j < y.move_Right j'
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [Add_cancel_CommMonoid E] [ordered_AddCommMonoid β] [module 𝕜 E] [HasScalar 𝕜 β] {S : set E} {F : E → β} (hF : strict_ConcaveOn 𝕜 S F) (C : E) : strict_ConcaveOn 𝕜 ((λ (z : E), C + z) ⁻¹' S) (F ∘ λ (z : E), C + z)
{α : Type u_1} {β : Type u_2} [UniformSpace α] [Group α] [uniform_Group α] {hom : Type u_3} [UniformSpace β] [DiscreteTopology β] [Group β] [uniform_Group β] [Monoid_hom_class hom α β] {F : hom} : uniform_Continuous ⇑F ↔ IsOpen ↑(↑F.Ker)
{α : sort u_1} {S₁ : Setoid α} {P : Quotient S₁ → Prop} (h : ∀ (A : α), P (Quotient.Mk' A)) (q : Quotient S₁) : P q
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] [Nontrivial E] {F : E → F} {U : set E} (hU : Metric.Bounded U) (hD : Diff_Cont_on_cl ℂ F U) {C : ℝ} (hC : ∀ (z : E), z ∈ Frontier U → ∥F z∥ ≤ C) {z : E} (hz : z ∈ Closure U) : ∥F z∥ ≤ C
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) [CategoryTheory.IsEquivalence F] : CategoryTheory.EssSurj F
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] (v : E) : v - ↑(⇑(Orthogonal_projection K) v) ∈ Kᗮ
{α : Type u_1} {ι' : sort u_5} {F : Filter α} [h : F._countably_generated] {P : ι' → Prop} {S : ι' → set α} (hs : F.has_Basis P S) : ∃ (x : ℕ → ι'), (∀ (i : ℕ), P (x i)) ∧ F.has_Antitone_Basis (λ (i : ℕ), S (x i))
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommMonoid β] [module 𝕜 E] [HasScalar 𝕜 β] {S : set E} {F : E → β} (hF : Convex_on 𝕜 S F) (C : E) : Convex_on 𝕜 ((λ (z : E), C + z) ⁻¹' S) (F ∘ λ (z : E), z + C)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {S : set E} {x : E} : UniqueDiffWithinAt 𝕜 S x → UniqueMdiffWithinAt (model_with_corners_self 𝕜 E) S x
{C : Type u} [CategoryTheory.Category C] {x Y : C} (J : CategoryTheory.GrothendieckTopology C) (F : Y ⟶ x) (S R : CategoryTheory.Sieve x) (h : J.Covers S F) : (∀ {Z : C} (g : Z ⟶ x), ⇑S g → J.Covers R g) → J.Covers R F
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type W} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace 𝕜] {x : Type u_1} [TopologicalSpace x] [Finite_dimensional 𝕜 E] {F : x → (E →L[𝕜] F)} {S : set x} : Continuous_on F S ↔ ∀ (y : E), Continuous_on (λ (x : x), ⇑(F x) y) S
{α : Type u} [PseudoMetricSpace α] {x : α} {r : ℝ} : Metric.Bounded (metric.IsClosed_ball x r)
{A : ℕ} (A1 : 1 < A) {x y : ℕ} (hp : x * x - D A1 * y * y = 1) : ∃ (n : ℕ), x = Pell.xn A1 n ∧ y = Pell.yn A1 n
{α : Type u_1} {r : α → α → Prop} (hr : WellFounded r) : WellFounded (Relation.CutExpand r)
{v₁ : Type u_2} {v₂ : Type u_3} [semi_NormedGroup v₁] [semi_NormedGroup v₂] : ∥0∥ = 0
{α : Type u} {β : Type v} [Group α] [Group β] {F : α → β} (hF : _Group_hom F) : Function.Injective F ↔ ∀ (A : α), F A = 1 → A = 1
{m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (A : Matrix m m R) (B : Matrix m n R) (D : Matrix n n R) : (Matrix.from_blocks A B 0 D).det = A.det * D.det
{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), Group (Gs i)] (h K : Π (i : η), Subgroup (Gs i)) : ⁅Subgroup.Pi set.Univ h,Subgroup.Pi set.Univ K⁆ ≤ Subgroup.Pi set.Univ (λ (i : η), ⁅h i,K i⁆)
{α : Type u_1} {r : Setoid α} (A : α) : ∃! (B : set α) (h : B ∈ r.Classes), A ∈ B
{R : Type u} [CommRing R] [IsDomain R] (A : R) (n : ℕ) : Polynomial.root_multiplicity A ((Polynomial.x - ⇑Polynomial.C A) ^ n) = n
{𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] {F : ?? → G} (hF : Differentiable 𝕜 F) (hF' : ∀ (x : 𝕜), deriv F x = 0) (x y : 𝕜) : F x = F y
{α : Type u} [PseudoMetricSpace α] {S : set α} : metric.Hausdorff_dist S ∅ = 0
{α : Type u_1} {β : Type u_2} [CompleteLattice α] {F : Filter β} {u : β → α} : F.limsup u = ⨅ (S : set β) (h : S ∈ F), ⨆ (A : β) (h : A ∈ S), u A
{cb : CharBuffer} {n n' val : ℕ} (h : Parser.Nat cb n = ParseResult.done n' val) : val = Nat.of_digits 10 (List.Map (λ (C : Char), C.ToNat - '0'.ToNat) (List.take (n' - n) (List.Drop n (Buffer.to_List cb))).reverse)
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {x : 𝕜} {S : set 𝕜} {F' : 𝕜 →L[𝕜] F} : HasFderivWithinAt F F' S x ↔ HasDerivWithinAt F (⇑F' 1) S x
{α : Type u} [TopologicalSpace α] {S : set α} {ι : Type v} (hs : IsCompact S) (Z : ι → set α) (hZc : ∀ (i : ι), IsClosed (Z i)) (hsZ : ∀ (t : Finset ι), (S ∩ ⋂ (i : ι) (h : i ∈ t), Z i).Nonempty) : (S ∩ ⋂ (i : ι), Z i).Nonempty
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) (v : E) : v ∈ Kᗮ ↔ ∀ (u : E), u ∈ K → HasInner.inner v u = 0
{R : Type u_1} [CommRing R] [Ideal._jacobson R] (P : Ideal (Polynomial R)) [hP : P.IsMaximal] : ((Ideal.Quotient.Mk P).Comp Polynomial.C).IsIntegral
{A B : ℝ} {g' g : ℝ → ℝ} (hab : A ≤ B) (hcont : Continuous_on g (set.icc A B)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo A B → HasDerivWithinAt g (g' x) (set.ioi x) x) (g'Pos : ∀ (x : ℝ), x ∈ set.Ioo A B → 0 ≤ g' x) : MeasureTheory.IntegrableOn g' (set.ioc A B) MeasureTheory.MeasureSpace.Volume
{k : Type u_1} {v1 : Type u_2} {P1 : Type u_3} {v2 : Type u_4} {P2 : Type u_5} {v3 : Type u_6} {P3 : Type u_7} [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] [AddCommGroup v2] [module k v2] [AddTorsor v2 P2] [AddCommGroup v3] [module k v3] [AddTorsor v3 P3] (F : P2 →ᵃ[k] P3) (g : P1 →ᵃ[k] P2) : ⇑(F.Comp g) = ⇑F ∘ ⇑g
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {S t : set E} (hs₁ : Convex ℝ S) (hs₂ : IsClosed S) (ht₁ : Convex ℝ t) (ht₂ : IsCompact t) (disj : Disjoint S t) : ∃ (F : E →L[ℝ] ℝ) (u v : ℝ), (∀ (A : E), A ∈ S → ⇑F A < u) ∧ u < v ∧ ∀ (B : E), B ∈ t → v < ⇑F B
{α : Type u_3} {β : Type u_4} [Preorder β] {F : β → Finset α} (h : Monotone F) (h' : ∀ (x : α), ∃ (n : β), x ∈ F n) : Filter.Tendsto F Filter.at_top Filter.at_top
{α : Type u_1} [Linear_ordered_Field α] {A B : α} (ha : 0 < A) (hb : 0 < B) : 1 / A ≤ 1 / B ↔ B ≤ A
{α : Type u_1} (L : List (List α)) (i : ℕ) : List.Drop (List.take i (List.Map List.length L)).Sum L.Join = (List.Drop i L).Join
{R : Type u} [non_assoc_Semiring R] {S : set R} {P : R → R → Prop} {x y : R} (hx : x ∈ Subsemiring.Closure S) (hy : y ∈ Subsemiring.Closure S) (Hs : ∀ (x : R), x ∈ S → ∀ (y : R), y ∈ S → P x y) (h0_Left : ∀ (x : R), P 0 x) (h0_Right : ∀ (x : R), P x 0) (h1_Left : ∀ (x : R), P 1 x) (h1_Right : ∀ (x : R), P x 1) (HAdd_Left : ∀ (x₁ x₂ y : R), P x₁ y → P x₂ y → P (x₁ + x₂) y) (HAdd_Right : ∀ (x y₁ y₂ : R), P x y₁ → P x y₂ → P x (y₁ + y₂)) (HMul_Left : ∀ (x₁ x₂ y : R), P x₁ y → P x₂ y → P (x₁ * x₂) y) (HMul_Right : ∀ (x y₁ y₂ : R), P x y₁ → P x y₂ → P x (y₁ * y₂)) : P x y
{α : Type u} (S : set α) : IsClosed {u : Ultrafilter α | S ∈ u}
{α : Type u} [TopologicalSpace α] [SigmaCompactSpace α] {ι : Type u_1} {F : ι → set α} (hF : locally_Finite F) (hne : ∀ (i : ι), (F i).Nonempty) : set.Univ.countable
{F : Type u_3} [Field F] [Fintype F] (hF : Ring_Char F = 2) (A : F) : IsSquare A
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} {P1 : P} {P : ι → P} (h : P1 ∈ affine_Span k (set.Range P)) : ∃ (S : Finset ι) (W : ι → k) (hw : S.Sum (λ (i : ι), W i) = 1), P1 = ⇑(S.affine_combination P) W
{n : Type u_3} [Fintype n] {A : Type u_1} [DecidableEq n] [CommRing A] [IsDomain A] {m : Matrix n n A} : m.nondegenerate → m.det ≠ 0
 : ⇑MeasureTheory.MeasureSpace.Volume {x : ℝ | Liouville x} = 0
(k : Type u₁) {G : Type u₂} [Semiring k] [has_Mul G] {A : Type u₃} [non_unital_non_assoc_Semiring A] [Distrib_MulAction k A] {φ₁ φ₂ : Monoid_Algebra k G →ₙₐ[k] A} (h : ∀ (x : G), ⇑φ₁ (Finsupp.single x 1) = ⇑φ₂ (Finsupp.single x 1)) : φ₁ = φ₂
{m : Type u_1} [MulOneClass m] {S : set m} {P : m → Prop} {x : m} (h : x ∈ Submonoid.Closure S) (Hs : ∀ (x : m), x ∈ S → P x) (h1 : P 1) (HMul : ∀ (x y : m), P x → P y → P (x * y)) : P x
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (m : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (hM : m (Sum.inr_ ()) (Sum.inr_ ()) ≠ 0) : ∃ (L L' : List (Matrix.TransvectionStruct (Fin r ⊕ Unit) 𝕜)), (((List.Map Matrix.TransvectionStruct.to_Matrix L).Prod.Mul m).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L').Prod)._two_block_Diagonal
{m : Type u_1} [Monoid m] {S t : set m} (ht : _Submonoid t) (h : S ⊆ t) : Monoid.Closure S ⊆ t
(A : ℤ) : ↑(A.Nat_Abs) ≤ A ^ 2
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {S : set (E × F)} : ContDiff_on 𝕜 n Prod.fst S
{α : Type u_1} [LinearOrder α] [SuccOrder α] [IsSuccArchimedean α] (r : α → α → Prop) {n m : α} (h1 : ∀ (i : α), i ∈ set.Ico n m → r i (Order.Succ i)) (h2 : ∀ (i : α), i ∈ set.Ico m n → r (Order.Succ i) i) : Relation.refl_Trans_gen r n m
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [normed_CommRing 𝕜] [AddCommMonoid E] [AddCommMonoid F] [module 𝕜 E] [module 𝕜 F] (B : E →ₗ[𝕜] F →ₗ[𝕜] 𝕜) : GaloisConnection (⇑order_dual.to_dual ∘ B.polar) (B.Flip.polar ∘ ⇑order_dual.of_dual)
{α : Type u_2} [Bornology α] {S : set α} : Bornology._bounded Sᶜ → Bornology._cobounded S
{n : Type u_3} {α : Type v} [Fintype n] [NonUnitalSemiring α] [Star_Ring α] (m N : Matrix n n α) : HasStar.Star (m.Mul N) = (HasStar.Star N).Mul (HasStar.Star m)
(C : Type u) [CategoryTheory.Category C] [∀ {J : Type v} {x Y : C} {F : J → (x ⟶ Y)}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallel_family F)] : CategoryTheory.Limits.HasWideEqualizers C
{α : Type u} {β : Type v} [Ring α] [Ring β] [IsDomain β] (e : α ≃+* β) : IsDomain α
{m : ℤ} (hm₀ : m ≠ 0) (hm₁ : m ≠ 1) : strict_Convex_on ℝ (set.ioi 0) (λ (x : ℝ), x ^ m)
{l : Filter ℝ} {F g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in Filter.at_top, Differentiable_at ℝ F x) (hg' : ∀ᶠ (x : ℝ) in Filter.at_top, deriv g x ≠ 0) (hftop : Filter.Tendsto F Filter.at_top (nhds 0)) (hgtop : Filter.Tendsto g Filter.at_top (nhds 0)) (HDiv : Filter.Tendsto (λ (x : ℝ), deriv F x / deriv g x) Filter.at_top l) : Filter.Tendsto (λ (x : ℝ), F x / g x) Filter.at_top l
(m : Type u_1) (α : Type u_2) [Monoid m] [MulAction m α] {S t : set α} : fixing_Submonoid m (S ∪ t) = fixing_Submonoid m S ⊓ fixing_Submonoid m t
{R : Type u_1} {m : Type u_2} [Linear_OrderedSemiring R] [ordered_AddCommMonoid m] [MulAction_with_Zero R m] (hR : ∀ {C : R}, C ≠ 0 → IsUnit C) (hlt : ∀ ⦃A B : m⦄ ⦃C : R⦄, A < B → 0 < C → C • A ≤ C • B) : OrderedSmul R m
{α : Type u} [HasSsubset α] [IsIrrefl α HasSsubset.Ssubset] {A : α} : ¬A ⊂ A
{x : Type u} [MetricSpace x] [CompactSpace x] [Nonempty x] {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] {γ : Type W} [MetricSpace γ] {Φ : x → γ} {Ψ : Y → γ} (ha : Isometry Φ) (hb : Isometry Ψ) : GromovHausdorff.GH_dist x Y ≤ metric.Hausdorff_dist (set.Range Φ) (set.Range Ψ)
{α : Type u} [PseudoMetricSpace α] {x : α} {u : set α} (hu : u ∈ nhds x) : ∀ᶠ (r : ℝ) in nhds 0, metric.IsClosed_ball x r ⊆ u
{m : Type u_3} [Monoid m] [Preorder m] (L : List m) (h : 1 < L.Prod) : 0 < L.length
{G : Type u_7} [Group G] (L : List G) (i : ℕ) (P : i < L.length) : (List.Drop (i + 1) L).Prod = (L.nth_LE i P)⁻¹ * (List.Drop i L).Prod
{α : Type u_1} {β : Type u_2} {F : α → β} {mα : MeasurableSpace α} [MeasurableSpace β] [TopologicalSpace β] [TopologicalSpace.metrizable_Space β] [BorelSpace β] [TopologicalSpace.SecondCountableTopology β] : MeasureTheory.strongly_Measurable F ↔ Measurable F
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k → E} {A B r : k} (h : 0 < r * (B - A)) : ⇑(affine_Map.line_Map (F A) (F B)) r ≤ F (⇑(affine_Map.line_Map A B) r) ↔ slope F A B ≤ slope F A (⇑(affine_Map.line_Map A B) r)
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A B : α} (ha : A ≤ 1) (hb : B < 1) : A * B < 1
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} {S : set E} {x : E} : Differentiable_within_at 𝕜 F S x → MdifferentiableWithinAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F S x
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y : v} (θ : Real.Angle) : o.oangle x y = θ ↔ (x ≠ 0 ∧ y ≠ 0 ∧ ∃ (r : ℝ), 0 < r ∧ y = r • ⇑(o.rotation θ) x) ∨ θ = 0 ∧ (x = 0 ∨ y = 0)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] {F : E → F} {P : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} (g : F →L[𝕜] G) (h : HasFpowerSeriesOnBall F P x r) : HasFpowerSeriesOnBall (⇑g ∘ F) (g.Comp_FormalMultilinearSeries P) x r
{α : Type u} [TopologicalSpace α] {F : Filter α} {A : α} {S : set α} (h : A ∈ S) (o : IsOpen S) (sf : Filter.principal S ≤ F) : nhds A ≤ F
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] {F : E → F} {F' : E →L[𝕜] F} {A : E} (hF : HasStrictFderivAt F F' A) (hF' : F'.Range = ⊤) (hker : F'.Ker.IsClosed_complemented) : ∀ᶠ (x : E) in nhds A, HasStrictFderivAt.implicit_Function_of_complemented F F' hF hF' hker (F x) (⇑(HasStrictFderivAt.implicit_to_LocalHomeomorph_of_complemented F F' hF hF' hker) x).Snd = x
{n : ℕ} {E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {F : (Fin (n + 1) → ℂ) → E} {C : Fin (n + 1) → ℂ} {R : Fin (n + 1) → ℝ} (hF : TorusIntegrable F C R) : ∯ (x : Fin (n + 1) → ℂ) in t(C, R), F x = ∮ (x : ℂ) in C(C 0, R 0), ∯ (y : Fin n → ℂ) in t(C ∘ Fin.Succ, R ∘ Fin.Succ), F (Fin.Cons x y)
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {C : ℝ} {F : ℂ → E} {z : ℂ} (hD : Diff_Cont_on_cl ℂ F (set.Iio 0 ×ℂ set.Iio 0)) (hB : ∃ (C : ℝ) (h : C < 2) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal (set.Iio 0 ×ℂ set.Iio 0)] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hre : ∀ (x : ℝ), x ≤ 0 → ∥F ↑x∥ ≤ C) (him : ∀ (x : ℝ), x ≤ 0 → ∥F (↑x * Complex.i)∥ ≤ C) (hz_re : z.re ≤ 0) (hz_im : z.im ≤ 0) : ∥F z∥ ≤ C
{α : Type u_1} {l₁ l₂ : List α} : l₁ <:+: l₂ → l₁.reverse <:+: l₂.reverse
{α : Type u} [non_unital_Ring α] {A B C : α} (h : A ∣ B) : A ∣ B + C ↔ A ∣ C
{x : Type u_1} [TopologicalSpace x] [NormalSpace x] {S t : set x} (hs : IsClosed S) (ht : IsClosed t) (hD : Disjoint S t) : ∃ (F : C(x, ℝ)), set.Eq_on ⇑F 0 S ∧ set.Eq_on ⇑F 1 t ∧ ∀ (x : x), ⇑F x ∈ set.icc 0 1
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : (SpanPoints k S).Nonempty ↔ S.Nonempty
{α : Type u} {l : List α} : l.sublists'.Nodup → l.Nodup
{R : Type u_1} [Ring R] (S : Subring R) (m : Multiset R) : (∀ (A : R), A ∈ m → A ∈ S) → m.Sum ∈ S
{C : Type v} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] {x Y : C} (F : x ⟶ Y) (S : Function.Surjective ⇑F) : CategoryTheory.Epi F
{𝕜 : Type u_1} {E : Type u_3} [NormedField 𝕜] [AddCommGroup E] [module 𝕜 E] {A : set E} [TopologicalSpace E] [has_Continuous_Smul 𝕜 E] (hA : Balanced 𝕜 A) : Balanced 𝕜 (0 ∪ Interior A)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [NormedSpace ℝ E] : IsBoundedBilinearMap ℝ (λ (P : E × E), HasInner.inner P.fst P.Snd)
{α : Type u} [Lattice α] [AddCommGroup α] (A : α) (h : 0 ≤ A) : A⁺ = A
{α : Type u} [PseudoEmetricSpace α] {x y : α} : Emetric.Inf_edist x {y} = HasEdist.edist x y
(n : ℕ) {R : Type u_1} {S : Type u_2} [Ring R] [Ring S] (F : R →+* S) : Polynomial.Map F (Polynomial.cyclotomic n R) = Polynomial.cyclotomic n S
{ι : Type u_1} {R : Type u_8} [ordered_CommSemiring R] {F g : ι → R} {S : Finset ι} (h0 : ∀ (i : ι), i ∈ S → 0 ≤ F i) (h1 : ∀ (i : ι), i ∈ S → F i ≤ g i) : S.Prod (λ (i : ι), F i) ≤ S.Prod (λ (i : ι), g i)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x Y : C} (F g : x ⟶ Y) [CategoryTheory.Limits.HasCokernel (F - g)] : CategoryTheory.Limits.HasCoequalizer F g
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) {u v : E} (hv : v ∈ K) : (∥u - v∥ = ⨅ (W : ↥↑K), ∥u - ↑W∥) ↔ ∀ (W : E), W ∈ K → HasInner.inner (u - v) W = 0
{α : Type u} {β : Type v} [MulOneClass α] [Group β] {F : α → β} (hF : _Mul_hom F) : _Monoid_hom F
{α : Type u} [TopologicalSpace α] {ι : Type u_1} {F : ι → set α} (hF : locally_Finite F) {S : set α} (hs : IsCompact S) : {i : ι | (F i ∩ S).Nonempty}.Finite
{S : set ℝ} (h : Metric.Bounded S) : Emetric.diam S = Ennreal.of_Real (HasSup.Sup S - HasInf.Inf S)
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] {A B C : α} : A < B + C → -B + A < C
(α : Type u) [t : TopologicalSpace α] [TopologicalSpace.IsSeparable_Space α] [Nonempty α] : DenseRange (TopologicalSpace.Dense_Seq α)
{α : Type u} [PseudoMetricSpace α] (S : set α) : LipschitzWith 1 (λ (x : α), metric.Inf_nndist x S)
{C : Type u₁} [CategoryTheory.Category C] (P : Cᵒᵖ ⥤ Type (max v₁ u₁)) {x : C} (R : CategoryTheory.Presieve x) [CategoryTheory.Limits.HasPullbacks C] (x : CategoryTheory.Equalizer.FirstObj P R) : ((CategoryTheory.Equalizer.FirstObj_Eq_family P R).hom x).compatible ↔ CategoryTheory.Equalizer.Presieve.first_Map P R x = CategoryTheory.Equalizer.Presieve.second_Map P R x
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] {P1 : P} (P2 : P) (hp1 : P1 ∈ S) : ↑(⟨P1, hp1⟩ -ᵥ ⇑(EuclideanGeometry.Orthogonal_projection S) P2) ∈ S.direction
{R : Type u_1} [Ring R] {F g : ℕ → R} : (∀ (n : ℕ), 0 < n → n.divisors.Sum (λ (i : ℕ), F i) = g n) ↔ ∀ (n : ℕ), 0 < n → n.divisors_antidiagonal.Sum (λ (x : ℕ × ℕ), ↑(⇑Nat.ArithmeticFunction.moebius x.fst) * g x.Snd) = F n
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_NormedField R] [NormedGroup F] [NormedSpace R F] [TopologicalSpace B] {ι : Type u_6} (Z : TopologicalVectorBundleCore R B F ι) : IsOpen_Map Z.Proj
{R : Type u_1} {S : Type u_2} {m : Type u_3} {A : R} [HasScalar R m] [HasScalar R S] [HasScalar S m] [IsScalarTower R S m] (B : S) (ha : IsSmulRegular m A) : IsSmulRegular m (A • B) ↔ IsSmulRegular m B
{β : Type u_2} [CommMonoid β] {n : ℕ} (F : Fin (n + 1) → β) : Finset.Univ.Prod (λ (i : Fin (n + 1)), F i) = F 0 * Finset.Univ.Prod (λ (i : Fin n), F i.Succ)
{G : Type u_1} [AddCommMonoid G] : AddMonoid._torsion ↥(AddCommMonoid.Add_torsion G)
(𝕜 : Type u_1) [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (F : E → F) [MeasurableSpace E] [Opens_MeasurableSpace E] [CompleteSpace F] : Measurable_set {x : E | Differentiable_at 𝕜 F x}
{𝕜 : Type u_3} {E : Type u_4} [NormedField 𝕜] [semi_NormedGroup E] [NormedSpace 𝕜 E] {r : ℝ} {x : E} (hx : ∥x∥ < r) : Absorbent 𝕜 (Metric.Ball x r)
{α : Type u} [TopologicalSpace α] : TotallyDisconnectedSpace α ↔ ∀ (x : α), (ConnectedComponent x).Subsingleton
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (m : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (i : Fin r ⊕ Unit) : (Matrix.Pivot.List_transvec_col m).Prod.Mul m (Sum.inr_ ()) i = m (Sum.inr_ ()) i
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} {S : set α} (h : finprod (λ (i : α), finprod (λ (h : i ∈ S), F i)) ≠ 1) : S.Nonempty
{ι : Type u_1} {x : ℕ} {S : ι → ℕ} {t : Finset ι} : (∀ (i : ι), i ∈ t → (S i).IsCoprime x) → (t.Prod (λ (i : ι), S i)).IsCoprime x
 : ¬set.Univ.countable
{α : Type u_1} {β : Type u_2} {m : Type u_3} [Fintype α] [Fintype β] [AddCommMonoid m] (e : α ≃ β) (F : α → m) (g : β → m) (h : ∀ (x : α), F x = g (⇑e x)) : Finset.Univ.Sum (λ (x : α), F x) = Finset.Univ.Sum (λ (x : β), g x)
{m : Type u_3} [Monoid m] (L : List m) (h : L.Prod ≠ 1) : 0 < L.length
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) {r : ℝ} (hr : 0 < r) : InnerProductGeometry.angle x (r • y) = InnerProductGeometry.angle x y
{α : Type u_1} {𝒜 : Finset (Finset α)} {A₁ A₂ : Finset α} {r₁ r₂ : ℕ} (h₁ : A₁ ∈ 𝒜.Slice r₁) (h₂ : A₂ ∈ 𝒜.Slice r₂) : r₁ ≠ r₂ → A₁ ≠ A₂
{𝕜 : Type u_1} {E : Type u_2} [normed_Linear_ordered_Field 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {A B : set E} (hAB : IsExposed 𝕜 A B) : ∃ (l : E →L[𝕜] 𝕜) (A : 𝕜), B = {x ∈ A | A ≤ ⇑l x}
(K : Type u_1) [Field K] [Fintype K] [Fintype Kˣ] (i : ℕ) : Finset.Univ.Sum (λ (x : Kˣ), ↑x ^ i) = Ite (Fintype.Card K - 1 ∣ i) (-1) 0
{β : Type u} {α : Type v} [AddCommMonoid β] {P : α → Prop} {S : Finset {x // P x}} {F : {x // P x} → β} {g : α → β} (h : ∀ (x : {x // P x}), x ∈ S → g ↑x = F x) : (Finset.Map (Function.Embedding.Subtype (λ (x : α), P x)) S).Sum (λ (x : α), g x) = S.Sum (λ (x : {x // P x}), F x)
{G : Type u_1} [Group G] (K : Subgroup G) : Subgroup.Closure ↑K = K
{α : Type u} [TopologicalSpace α] [t2_Space α] [CompactSpace α] : TotallyDisconnectedSpace α ↔ TotallySeparatedSpace α
{F : ℝ → ℝ} {F' A : ℝ} (h : IsLocalMax F A) (hF : HasDerivAt F F' A) : F' = 0
{F : Type u_1} [NormedGroup F] [NormedSpace ℝ F] (F : ℝ → F) [CompleteSpace F] : Measurable_set {x : ℝ | Differentiable_within_at ℝ F (set.ioi x) x}
{β : Type u_2} {F g : β → Nnreal} (hgf : ∀ (B : β), g B ≤ F B) : Summable F → Summable g
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {S : set E} (S_conv : Convex ℝ S) {F : E → F} {F' : E → (E →L[ℝ] F)} {F'' : E →L[ℝ] E →L[ℝ] F} (hF : ∀ (x : E), x ∈ Interior S → HasFderivAt F (F' x) x) {x : E} (xs : x ∈ S) (hx : HasFderivWithinAt F' F'' (Interior S) x) {v W : E} (h4v : x + 4 • v ∈ Interior S) (h4W : x + 4 • W ∈ Interior S) : ⇑(⇑F'' W) v = ⇑(⇑F'' v) W
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] (P : Polynomial 𝕜) (x : 𝕜) : HasDerivAt (λ (x : 𝕜), Polynomial.Eval x P) (Polynomial.Eval x (⇑Polynomial.derivative P)) x
{α : Type u_1} [PartialOrder α] (C : Closure_operator α) (x : α) : x ≤ ⇑C x
{R : Type u_2} {Γ₀ : Type u_3} {Γ'₀ : Type u_4} [Ring R] [Linear_ordered_CommMonoid_with_Zero Γ₀] [Linear_ordered_CommMonoid_with_Zero Γ'₀] {v₁ : Valuation R Γ₀} {v₂ : Valuation R Γ'₀} {S : Type u_1} [Ring S] (F : S →+* R) (h : v₁._Equiv v₂) : (Valuation.comap F v₁)._Equiv (Valuation.comap F v₂)
(n : ℕ+) (S : set ℕ+) (K : Type W) (L : Type z) [Field K] [Field L] [Algebra K L] [Ne_Zero ↑↑n] [h : IsCyclotomicExtension S K L] (hS : n ∈ S) : Polynomial.Splits (Algebra_Map K L) (Polynomial.x ^ ↑n - 1)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P : P) (h : S.Sum (λ (i : ι), W i) = 0) : ⇑(S.weighted_vsub (λ (_x : ι), P)) W = 0
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder α] [order_IsClosed_topology α] [Nonempty α] [TopologicalSpace β] [has_One α] {F : β → α} (hF : Continuous F) (h : HasCompactMulSupport F) : BddBelow (set.Range F)
{α : Type u} {β : Type v} {F : α → β} (h : Function.Injective F) (S : set α) : set.inj_on F S
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] (m : Matrix n n R) : m.transpose.det = m.det
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] (F : S.Localization_Map N) : F.of_Mul_Equiv_of_Dom _ = F
{k : Type u₁} {G : Type u₂} {R : Type u_1} [Semiring k] [MulOneClass G] [Semiring R] {F g : Monoid_Algebra k G →+* R} (h₁ : F.Comp Monoid_Algebra.single_One_Ring_hom = g.Comp Monoid_Algebra.single_One_Ring_hom) (h_of : ↑F.Comp (Monoid_Algebra.of k G) = ↑g.Comp (Monoid_Algebra.of k G)) : F = g
(α : Type u) [UniformSpace α] [(Uniformity α)._countably_generated] [TopologicalSpace.IsSeparable_Space α] : TopologicalSpace.SecondCountableTopology α
(R : Type u_1) [CommRing R] (m : Type u_2) [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] [Nontrivial R] : ⇑(LinearMap.trace R m) LinearMap.Id = ↑(Finite_dimensional.finrank R m)
{α : Type u_1} [Linear_ordered_Field α] {A B : α} (ha : 0 < A) (hb : 0 < B) : A⁻¹ < B⁻¹ ↔ B < A
{α : Type u_1} {r S : α → α → Prop} (h : ∀ (x y : α), r x y → S x y) : EqvGen.Setoid r ≤ EqvGen.Setoid S
{P : ℕ} [Fact (Nat.Prime P)] {F : padic_Seq P} (hF : ¬F ≈ 0) (v1 v2 : ℕ) : padic_norm P (⇑F (padic_Seq.stationary_point hF)) = padic_norm P (⇑F (LinearOrder.max v1 (LinearOrder.max v2 (padic_Seq.stationary_point hF))))
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LT.LT] {A B : α} (ha : A < 1) (hb : B ≤ 1) : A * B < 1
{α : Type u_1} [has_LE α] {S : set α} : _upper_set S → _lower_set (⇑order_dual.of_dual ⁻¹' S)
{β : Type u} {α : Type v} [AddCommMonoid β] [DecidableEq α] (S : Finset α) (F : α → β) {A : α} (h : A ∈ S) : F A + (S.erase A).Sum (λ (x : α), F x) = S.Sum (λ (x : α), F x)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {A : Type u₃} [CategoryTheory.Category A] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {G : C ⥤ D} (hG₁ : CategoryTheory.CompatiblePreserving K G) (hG₂ : CategoryTheory.CoverPreserving J K G) (ℱ : CategoryTheory.sheaf K A) : CategoryTheory.Presheaf.IsSheaf J (G.Op ⋙ ℱ.val)
{α : Type u_1} [TopologicalSpace α] {γ : Type u_4} [Linear_ordered_AddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] {F g : α → γ} (hF : UpperSemicontinuous F) (hg : UpperSemicontinuous g) (hcont : ∀ (x : α), Continuous_at (λ (P : γ × γ), P.fst + P.Snd) (F x, g x)) : UpperSemicontinuous (λ (z : α), F z + g z)
{α : Type u_1} {n : Type u_2} {m : Type u_3} [has_Mul α] [AddCommMonoid α] (A : Matrix m n α) [Fintype m] : A.transpose.has_Orthogonal_rows ↔ A.has_Orthogonal_cols
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x ⟶ Y} (t : CategoryTheory.Limits.Fork F g) [CategoryTheory.Epi t.ι] : F = g
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {F : E → F} {P : E → FormalMultilinearSeries ℝ E F} {S : set E} {x : E} (hF : HasFtaylorSeriesUpToOn 1 F P (HasInsert.Insert x S)) (hs : Convex ℝ S) (K : Nnreal) (hK : ∥P x 1∥₊ < K) : ∃ (t : set E) (h : t ∈ nhds_within x S), LipschitzOnWith K F t
(A B : ℕ) {C : ℕ} (hc : 0 < C) : C * A / (C * B) = A / B
{S : set ℕ} (hs : S.Infinite) {k : ℕ} (hk : 0 < k) : ∃ (m : ℕ) (h : m ∈ S) (n : ℕ) (h : n ∈ S), m < n ∧ m ≡ n [Mod k]
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {x x' Y Y' Z Z' : C} [CategoryTheory.ExactPairing Y Y'] (F : x ⟶ Y ⊗ Z) (g : x' ⟶ Z') : ⇑((CategoryTheory.tensor_Left_hom_Equiv (x ⊗ x') Y Y' (Z ⊗ Z')).Symm) ((F ⊗ g) ≫ (α_ Y Z Z').hom) = (α_ Y' x x').Inv ≫ (⇑((CategoryTheory.tensor_Left_hom_Equiv x Y Y' Z).Symm) F ⊗ g)
{C : Type u₁} [CategoryTheory.Category C] {x : C} {S : CategoryTheory.Sieve x} {P : Cᵒᵖ ⥤ Type v₁} : CategoryTheory.Presieve.IsSheafFor P ⇑S ↔ CategoryTheory.Presieve.YonedaSheafCondition P S
(P : ℕ) [hp : Fact (Nat.Prime P)] {q r : ℚ} : padic_norm P (q - r) ≤ LinearOrder.max (padic_norm P q) (padic_norm P r)
(α : Type u) (β : Type v) [AddGroup α] [AddAction α β] [Fintype α] [Π (A : α), Fintype ↥(AddAction.FixedBy α β A)] [Fintype (Quotient (AddAction.Orbit_Rel α β))] : Finset.Univ.Sum (λ (A : α), Fintype.Card ↥(AddAction.FixedBy α β A)) = Fintype.Card (Quotient (AddAction.Orbit_Rel α β)) * Fintype.Card α
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S1 S2 : AffineSubspace k P) : S1 < S2 ↔ ↑S1 ⊂ ↑S2
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace ↥K] : ∥Orthogonal_projection K∥ ≤ 1
{ι : Type u_1} {R : Type u_8} [ordered_CommSemiring R] {S : Finset ι} {i : ι} {F g h : ι → R} (hi : i ∈ S) (h2i : g i + h i ≤ F i) (hgf : ∀ (j : ι), j ∈ S → j ≠ i → g j ≤ F j) (hhf : ∀ (j : ι), j ∈ S → j ≠ i → h j ≤ F j) (hg : ∀ (i : ι), i ∈ S → 0 ≤ g i) (hH : ∀ (i : ι), i ∈ S → 0 ≤ h i) : S.Prod (λ (i : ι), g i) + S.Prod (λ (i : ι), h i) ≤ S.Prod (λ (i : ι), F i)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (r : ℝ) (v : v) (P₁ P₂ : P) : HasDist.dist (r • v +ᵥ P₁) P₂ * HasDist.dist (r • v +ᵥ P₁) P₂ = HasInner.inner v v * r * r + 2 * HasInner.inner v (P₁ -ᵥ P₂) * r + HasInner.inner (P₁ -ᵥ P₂) (P₁ -ᵥ P₂)
{m : Type u_1} [Nonempty m] [Add_Semigroup m] [TopologicalSpace m] [CompactSpace m] [t2_Space m] (Continuous_Mul_Left : ∀ (r : m), Continuous (λ (_x : m), _x + r)) : ∃ (m : m), m + m = m
 : IsTrivialTopologicalFiberBundle ℝ Complex.re
{k : ℕ} (n : ℕ) (hpos : 0 < k) : ∃ (P : ℕ), Nat.Prime P ∧ n ≤ P ∧ P ≡ 1 [Mod k]
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) {P1 : P} (P2 : P) (r : ℝ) (hp : P1 ∈ affine_Span ℝ (set.Range S.points)) : ⇑(S.Orthogonal_projection_Span) (r • (P2 -ᵥ ↑(⇑(S.Orthogonal_projection_Span) P2)) +ᵥ P1) = ⟨P1, hp⟩
 : IsTrivialTopologicalFiberBundle ℝ Complex.im
{m : Type u_1} [has_Mul m] {C D : Con m} (h : C.to_Setoid = D.to_Setoid) : C = D
{R : Type u} {L : Type v} [CommRing R] [lie_Ring L] [lie_Algebra R L] (m : Type W) [AddCommGroup m] [module R m] [lie_Ring_module L m] [lie_module R L m] [Nontrivial m] [lie_Algebra.IsNilpotent R L] [lie_module.IsNilpotent R L m] : lie_module._weight ⊤ m 0
{B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] : IsTopologicalFiberBundle F Prod.fst
{x : Type u} {Y : Type v} [Preorder x] [Preorder Y] {L : x ⥤ Y} {R : Y ⥤ x} (Adj : L ⊣ R) : GaloisConnection L.obj R.obj
{α : Type u_1} [TopologicalSpace α] [BaireSpace α] {S : set (set α)} (hc : ∀ (S : set α), S ∈ S → IsClosed S) (hS : S.countable) (hU : ⋃₀S = set.Univ) : Dense (⋃ (S : set α) (h : S ∈ S), Interior S)
{S : Type u} [Semigroup S] {A x y x' y' : S} (h : SemiconjBy A x y) (h' : SemiconjBy A x' y') : SemiconjBy A (x * x') (y * y')
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) : 2 • o.oangle x (-y) = 2 • o.oangle x y
{ι : Type u_1} {𝕜 : Type u_2} [_R_or_C 𝕜] {E : Type u_3} [InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {G : ι → Type u_4} [Π (i : ι), InnerProductSpace 𝕜 (G i)] {v : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 v) [∀ (i : ι), CompleteSpace (G i)] (hV' : (⨆ (i : ι), (v i).to_LinearMap.Range).topological_Closure = ⊤) (W : ↥(Lp G 2)) : has_Sum (λ (i : ι), ⇑(v i) (⇑W i)) (⇑((hV.Linear_Isometry_Equiv hV').Symm) W)
{R : Type u_1} [Semiring R] {m : laurent_Polynomial R → Prop} (P : laurent_Polynomial R) (h_Add : ∀ (P q : laurent_Polynomial R), m P → m q → m (P + q)) (h_C_Mul_t : ∀ (n : ℤ) (A : R), m (⇑laurent_Polynomial.C A * laurent_Polynomial.t n)) : m P
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι → 𝕜) {S : Finset ι} {i : ι} (hi : i ∈ S) : HasInner.inner (S.Sum (λ (i : ι), l i • v i)) (v i) = ⇑(Star_Ring_end 𝕜) (l i)
{R : Type u} [Ring R] {ι : sort u_1} [hι : Nonempty ι] {S : ι → Subring R} (hS : Directed has_LE.LE S) {x : R} : (x ∈ ⨆ (i : ι), S i) ↔ ∃ (i : ι), x ∈ S i
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (hp1P2 : P1 ≠ P2) (hp3P2 : P3 ≠ P2) : HasDist.dist P1 P3 = HasDist.dist P1 P2 + HasDist.dist P3 P2 ↔ EuclideanGeometry.angle P1 P2 P3 = Real.Pi
(R : Type u_1) (m : Type u_2) [Semiring R] [Nontrivial m] [AddCommMonoid m] [module R m] : Nontrivial R
{α : Type u} {β : Type v} [Preorder α] [LinearOrder β] {F g : α → β} (hF : Antitone F) (hg : Antitone g) : Antitone (λ (x : α), LinearOrder.max (F x) (g x))
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (h : P 1 = ⇑((Continuous_multilinear_Curry_Fin1 𝕜 E F).Symm) ↑i) : P.Left_Inv i = P.Right_Inv i
{α : Type u} {β : Type v} {F : α → β} {g : β → α} (hF : Function.Injective F) (hg : Function.Injective g) : ∃ (h : α → β), Function.Bijective h
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LE.LE] {A B : α} (ha : A ≤ 1) (hb : B ≤ 1) : A * B ≤ 1
{K : Type u} {v : Type v} [Field K] [AddCommGroup v] [module K v] (S t : Submodule K v) [Finite_dimensional K ↥S] [Finite_dimensional K ↥t] : Finite_dimensional.finrank K ↥(S ⊔ t) + Finite_dimensional.finrank K ↥(S ⊓ t) = Finite_dimensional.finrank K ↥S + Finite_dimensional.finrank K ↥t
{R : Type u_1} [cancel_CommMonoid_with_Zero R] {α : Type u_2} [DecidableEq α] {x y A : R} {S : Finset α} {P : α → R} (hp : ∀ (i : α), i ∈ S → Prime (P i)) (hx : x * y = A * S.Prod (λ (i : α), P i)) : ∃ (t u : Finset α) (B C : R), t ∪ u = S ∧ Disjoint t u ∧ A = B * C ∧ x = B * t.Prod (λ (i : α), P i) ∧ y = C * u.Prod (λ (i : α), P i)
{G : Type W} [TopologicalSpace G] [AddGroup G] [topological_AddGroup G] {K v : set G} (hK : IsCompact K) (hV : (Interior v).Nonempty) : ∃ (t : Finset G), K ⊆ ⋃ (g : G) (h : g ∈ t), (λ (h : G), g + h) ⁻¹' v
{P n k B : ℕ} (hp : Nat.Prime P) (hkn : k ≤ n) (hnb : Nat.log P n < B) : multiplicity P (n.choose k) = ↑((Finset.Filter (λ (i : ℕ), P ^ i ≤ k % P ^ i + (n - k) % P ^ i) (Finset.Ico 1 B)).Card)
{m : Type u_1} [has_Mul m] {S : set m} {S : Subsemigroup m} : Subsemigroup.Closure S ≤ S ↔ S ⊆ ↑S
{β : Type u} {α : Type v} {S : Finset α} {F : α → β} [CommMonoid β] (R : Setoid α) [Decidable_Rel Setoid.r] (h : ∀ (x : α), x ∈ S → (Finset.Filter (λ (y : α), y ≈ x) S).Prod (λ (A : α), F A) = 1) : S.Prod (λ (x : α), F x) = 1
{α : Type u_1} {r : Setoid α} {x : α} {B : set α} (hc : B ∈ r.Classes) (hb : x ∈ B) {B' : set α} (hc' : B' ∈ r.Classes) (hb' : x ∈ B') : B = B'
{α : sort u_1} {A A' : α} {β : sort u_2} (y : β) (h : A = A') : Eq.rec y h = y
{α : Type u} {L₁ L₂ : List (α × Bool)} : free_Group.red.step L₁ L₂ → L₂.length + 2 = L₁.length
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommMonoid β] [module 𝕜 E] [HasScalar 𝕜 β] {S : set E} {F : E → β} (hF : ConcaveOn 𝕜 S F) (C : E) : ConcaveOn 𝕜 ((λ (z : E), C + z) ⁻¹' S) (F ∘ λ (z : E), C + z)
{𝕜 : Type u_1} {E : Type u_3} {F : Type u_4} [ordered_Ring 𝕜] [TopologicalSpace E] [TopologicalSpace F] [AddCommGroup E] [AddCommGroup F] [module 𝕜 E] [module 𝕜 F] {S : set F} (hs : strict_Convex 𝕜 S) {F : E →ᵃ[𝕜] F} (hF : Continuous ⇑F) (hfinj : Function.Injective ⇑F) : strict_Convex 𝕜 (⇑F ⁻¹' S)
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {A : F} (ha : A ≠ 0) : Char.quadratic_Char F A = 1 ∨ Char.quadratic_Char F A = -1
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] : Orthogonal_projection ⊥ = 0
{R : Type u_1} {A : R} [Semigroup R] (B : R) (ha : IsLeftRegular A) : IsLeftRegular (A * B) ↔ IsLeftRegular B
{α : Type u} [Group α] [has_LE α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A B C : α} : A * B ≤ C → B ≤ A⁻¹ * C
(x y : ℕ) : ↑(x.Gcd y) = ↑x * x.Gcd_A y + ↑y * x.Gcd_B y
(𝕜 : Type u_1) {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} [LinearOrder ι] [OrderBot ι] [locally_Finite_order ι] [IsWellOrder ι has_LT.LT] (F : ι → E) {A B : ι} (h₀ : A ≠ B) : HasInner.inner (gram_schmidt 𝕜 F A) (gram_schmidt 𝕜 F B) = 0
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S₁ S₂ : set P} (h : S₁ ⊆ S₂) : Vector_Span k S₁ ≤ Vector_Span k S₂
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m →* P} (hg : ∀ (y : ↥S), IsUnit (⇑g ↑y)) (z : N) : ⇑(F.Lift hg) z * ⇑g ↑((F.sec z).Snd) = ⇑g (F.sec z).fst
{A B : Ereal} (h : -A ≤ B) : -B ≤ A
{x : Type u_1} [TopologicalSpace x] [SequentialSpace x] {S : set x} : _Seq_IsClosed S ↔ IsClosed S
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {F' : E →L[𝕜] F} {x₀ : E} (hF : HasFderivAt F F' x₀) {S : set E} (hs : S ∈ nhds x₀) {C : Nnreal} (hlip : LipschitzOnWith C F S) : ∥F'∥ ≤ ↑C
{R : Type u_1} [CommRing R] {A B : R} : A ^ 4 + 4 * B ^ 4 = ((A - B) ^ 2 + B ^ 2) * ((A + B) ^ 2 + B ^ 2)
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) [Invertible A] : (⅟ A).Mul A = 1
{K : Type u} [Field K] (S : Subfield K) {ι : Type u_1} {t : Finset ι} {F : ι → K} (h : ∀ (C : ι), C ∈ t → F C ∈ S) : t.Prod (λ (i : ι), F i) ∈ S
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (F : C(α, β)) {x y : α} (h : x = y) : ⇑F x = ⇑F y
{α : Type u} {A B : α} [MulOneClass α] [has_Zero α] [Preorder α] [Zero_LT.Pos_Mul_StrictMono α] (ha : 1 ≤ A) (hb : 1 < B) (A0 : 0 < A) : 1 < A * B
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [CompleteSpace E] [CompleteSpace F] (A : E →L[𝕜] F) (x : E) (y : F) : HasInner.inner (⇑(⇑Continuous_LinearMap.Adjoint A) y) x = HasInner.inner y (⇑A x)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {ι : Type W} {B : Finset ι} (h : Basis ↥B K v) : Finite_dimensional.finrank K v = B.Card
{n n' : ℕ} (m : ℕ) (i : Fin n') (h : n' = n) : ⇑(Fin.Nat_Add m) (⇑(Fin.cast h) i) = ⇑(Fin.cast _) (⇑(Fin.Nat_Add m) i)
{m : Type u_3} {N : Type u_4} [MulOneClass m] [MulOneClass N] (F : m →* N) {x y : m} (h : x = y) : ⇑F x = ⇑F y
{α : Type u_1} [MeasurableSpace α] {F : ℕ → α → Nnreal} {g : α → Nnreal} (hF : ∀ (i : ℕ), Measurable (F i)) (lim : Filter.Tendsto F Filter.at_top (nhds g)) : Measurable g
{x : Pgame} : x.lf 0 ↔ ∃ (j : x.Right_moves), x.move_Right j ≤ 0
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {g : α → F} {F' : α → E'} {l : Filter α} : F' =O[l] g → (λ (x : α), -F' x) =O[l] g
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {F : α → β} : Monotone F → Antitone (F ∘ ⇑order_dual.of_dual)
(𝕂 : Type u_1) (𝔸 : Type u_2) [_R_or_C 𝕂] [NormedRing 𝔸] [normed_Algebra 𝕂 𝔸] : (Exp_series 𝕂 𝔸).radius = ⊤
{K : Type u} {L : Type v} [Field K] [Field L] {F g : K →+* L} {S : set K} (h : set.Eq_on ⇑F ⇑g S) : set.Eq_on ⇑F ⇑g ↑(Subfield.Closure S)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S₁ S₂ : AffineSubspace k P} {P : P} (h₁ : P ∈ S₁) (h₂ : P ∈ S₂) : S₁ = S₂ ↔ S₁.direction = S₂.direction
{R : Type u_2} [cancel_CommMonoid_with_Zero R] [Unique_factorization_Monoid R] {A B C : R} (ha : A ≠ 0) (no_Factors : ∀ {D : R}, D ∣ A → D ∣ B → ¬Prime D) : A ∣ B * C → A ∣ C
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S : set P} [Nontrivial P] : affine_Span k S = ⊤ ↔ Vector_Span k S = ⊤
{C : Type u} [CategoryTheory.Category C] {J : CategoryTheory.GrothendieckTopology C} (hJ : CategoryTheory.sheaf.Subcanonical J) (P : Cᵒᵖ ⥤ Type v) [P.representable] : CategoryTheory.Presieve._sheaf J P
{α : Type u} [TopologicalSpace α] {S : set α} : Dense S ↔ ∀ (U : set α), IsOpen U → U.Nonempty → (U ∩ S).Nonempty
{α : Type u_2} {β : Type u_3} [DecidableEq β] [HasVadd α β] {u : Finset β} {S : set α} {t : set β} : ↑u ⊆ S +ᵥ t → (∃ (S' : Finset α) (t' : Finset β), ↑S' ⊆ S ∧ ↑t' ⊆ t ∧ u ⊆ S' +ᵥ t')
(𝕜 : Type u_1) {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {v : E} (hv : ∥v∥ = 1) (W : E) : ↑(⇑(Orthogonal_projection (Submodule.Span 𝕜 {v})) W) = HasInner.inner v W • v
{α : Type u} {A B : α} [MulOneClass α] [has_Zero α] [Preorder α] [ZeroLt.PosMulMono α] (ha : 1 < A) (hb : 1 ≤ B) (A0 : 0 < A) : 1 < A * B
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} {S t : set α} (hst : S ⊆ t) (ht : (t ∩ Function.Support F).Finite) : finsum (λ (i : α), finsum (λ (h : i ∈ S), F i)) + finsum (λ (i : α), finsum (λ (h : i ∈ t  S), F i)) = finsum (λ (i : α), finsum (λ (h : i ∈ t), F i))
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {v : set E} [Finite_dimensional 𝕜 E] (hv : Orthonormal 𝕜 Coe) : ∃ (u : set E) (h : u ⊇ v) (B : Basis ↥u 𝕜 E), Orthonormal 𝕜 ⇑B ∧ ⇑B = Coe
(S : set ℝ) (hS : ∀ (x : ℝ), x ∈ S → x ≤ 0) : HasInf.Inf S ≤ 0
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K₁ K₂ : Submodule 𝕜 E} (h : K₁ ≤ K₂) [CompleteSpace ↥K₁] : K₁ ⊔ K₁ᗮ ⊓ K₂ = K₂
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} {ps : set P} (h : ps ⊆ ↑S) [Nonempty ↥S] {n : ℕ} [Finite_dimensional ℝ ↥(S.direction)] (hD : Finite_dimensional.finrank ℝ ↥(S.direction) = n) (hc : EuclideanGeometry.Cospherical ps) {sx₁ sx₂ : Affine.Simplex ℝ P n} (hsx₁ : set.Range sx₁.points ⊆ ps) (hsx₂ : set.Range sx₂.points ⊆ ps) : sx₁.circumradius = sx₂.circumradius
{α : sort u} {β : sort v} {γ : sort W} {g : β → γ} (hg : Function.Surjective g) : Function.Surjective (Function.Comp g)
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {F' : F} {x : 𝕜} [PartialOrder 𝕜] : HasDerivWithinAt F F' (set.ici x) x → HasDerivWithinAt F F' (set.ioi x) x
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] : EuclideanGeometry.Cospherical ∅
{α : Type v} [LinearOrder α] {x₁ x₂ y₁ y₂ : α} (h : Disjoint (set.Ico x₁ x₂) (set.Ico y₁ y₂)) (hx : x₁ < x₂) (h2 : x₂ ∈ set.Ico y₁ y₂) : y₁ = x₂
{R : Type u_1} [CommRing R] [IsDomain R] : (Ideal.Span {PowerSeries.x}).Prime
{F : Type u_1} [Field F] (P : Polynomial F) (E : Type u_2) [Field E] [Algebra F E] [Fact (Polynomial.Splits (Algebra_Map F E) P)] : Function.Injective ⇑(Polynomial.Gal.Gal_action_hom P E)
{α : Type u_1} [MeasurableSpace α] (S : MeasureTheory.SignedMeasure α) : S.to_JordanDecomposition.to_SignedMeasure = S
(C : Type u) [CategoryTheory.Category C] [∀ {x Y : C} {F g : x ⟶ Y}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.ParallelPair F g)] : CategoryTheory.Limits.HasCoequalizers C
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {P : P} (hp : P ∈ S) (P2 : P) : P2 -ᵥ P ∈ S.direction ↔ P2 ∈ S
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (m : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (hM : m (Sum.inr_ ()) (Sum.inr_ ()) ≠ 0) (i : Fin r) : (Matrix.Pivot.List_transvec_col m).Prod.Mul m (Sum.inl_ i) (Sum.inr_ ()) = 0
{P n : ℕ} (h : 2 * n < P) : ⇑(n.central_binom.factorization) P = 0
{G : Type u} [Group G] (A x : G) : SemiconjBy A x (A * x * A⁻¹)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {S : set ℝ} {e : E} {A : ℝ} {F : ℝ → E} (F_Diff : DifferentiableOn ℝ F S) (F_lim : Continuous_within_at F S A) (hs : S ∈ nhds_within A (set.Iio A)) (F_lim' : Filter.Tendsto (λ (x : ℝ), deriv F x) (nhds_within A (set.Iio A)) (nhds e)) : HasDerivWithinAt F e (set.Iic A) A
{R : Type u_1} [Semiring R] (F : laurent_Polynomial R) {q : laurent_Polynomial R → Prop} (is_qf : ∀ (F : Polynomial R), q (⇑Polynomial.to_laurent F)) (QT : ∀ (F : laurent_Polynomial R), q (F * laurent_Polynomial.t 1) → q F) : q F
{k : Type u_1} {G : Type u_2} {v : Type u_3} [CommSemiring k] [Group G] [AddCommMonoid v] [module k v] (ρ : Representation k G v) [Fintype G] [Invertible ↑(Fintype.Card G)] (v : v) (hv : v ∈ ρ.invariants) : ⇑(ρ.average_Map) v = v
{G : Type u_3} [Group G] (P : Subgroup G) : P.fg ↔ P.to_Submonoid.fg
{𝕜 : Type u_1} {E : Type u_2} [ordered_Ring 𝕜] [AddCommGroup E] [module 𝕜 E] {K : Geometry.SimplicialComplex 𝕜 E} {S t : Finset E} (hs : S ∈ K.Faces) (ht : t ∈ K.Faces) : ⇑(Convex_hull 𝕜) ↑S ⊆ ⇑(Convex_hull 𝕜) ↑t ↔ S ⊆ t
{J : Type u₁} [CategoryTheory.Category J] [CategoryTheory.IsPreconnected J] {α : Type u₁} (F : J ⥤ CategoryTheory.Discrete α) (j j' : J) : F.obj j = F.obj j'
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {δ : Type u_1} [LinearOrder δ] [TopologicalSpace δ] [order_IsClosed_topology δ] {S : set α} [hs : S.Ord_connected] {F : α → δ} (hF : Continuous_on F S) {A B : α} (ha : A ∈ S) (hb : B ∈ S) : set.surj_on F S (set.icc (F A) (F B))
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {x Y Z : C} [CategoryTheory.HasLeftDual x] [CategoryTheory.HasLeftDual Y] [CategoryTheory.HasLeftDual Z] {F : x ⟶ Y} {g : Y ⟶ Z} : ᘁ(F ≫ g) = ᘁg ≫ ᘁF
{γ : Type W} [SemilatticeSup γ] {A B : γ} {S t : set γ} (hs : IsLub S A) (ht : IsLub t B) : IsLub (S ∪ t) (A ⊔ B)
{K : Type u} [hfield : Field K] (P : Polynomial K) {q : Polynomial K} (hq : q ≠ 0) : ⇑Polynomial.C ((q / Gcd_Monoid.Gcd P q).leading_Coeff)⁻¹ * (P / Gcd_Monoid.Gcd P q) ∣ P
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} (P : ι → P) : AffineIndependent k P ↔ ∀ (S1 S2 : Finset ι) (W1 W2 : ι → k), S1.Sum (λ (i : ι), W1 i) = 1 → S2.Sum (λ (i : ι), W2 i) = 1 → ⇑(S1.affine_combination P) W1 = ⇑(S2.affine_combination P) W2 → ↑S1.indicator W1 = ↑S2.indicator W2
{R : Type u_1} {m : Type u_2} {N : Type u_3} {P : Type u_4} [Ring R] [AddCommGroup m] [module R m] [AddCommGroup N] [module R N] [AddCommGroup P] [module R P] (F : m →ₗ[R] N) (g : N →ₗ[R] P) (hF1 : F.Ker.fg) (hF2 : g.Ker.fg) (hsur : Function.Surjective ⇑F) : (g.Comp F).Ker.fg
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) : o.oangle (⇑(o.rotation θ) x) y = o.oangle x y - θ
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {C : F} : ContDiff 𝕜 n (λ (x : E), C)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] [Nontrivial α] {S : set α} [TopologicalSpace.IsSeparable_Space ↥S] (hs : Dense S) : ∃ (t : set α) (h : t ⊆ S), t.countable ∧ Dense t ∧ (∀ (x : α), _IsBot x → x ∉ t) ∧ ∀ (x : α), _top x → x ∉ t
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [CommRing 𝕜] [AddCommGroup E] [AddCommGroup F] [module 𝕜 E] [module 𝕜 F] [TopologicalSpace E] [TopologicalSpace F] [topological_AddGroup E] [has_Continuous_Const_Smul 𝕜 E] [topological_AddGroup F] [has_Continuous_Const_Smul 𝕜 F] (q : FormalMultilinearSeries 𝕜 E F) (P : FormalMultilinearSeries 𝕜 E E) : q.Comp P 0 = q 0
{m₀ : Type u_1} [Mul_Zero_class m₀] [no_Zero_divisors m₀] {A B : m₀} : A * B ≠ 0 ↔ A ≠ 0 ∧ B ≠ 0
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [dec_E : DecidableEq E] {S : set E} : Orthonormal 𝕜 Coe ↔ ∀ (v : E), v ∈ S → ∀ (W : E), W ∈ S → HasInner.inner v W = Ite (v = W) 1 0
{m : Type u_1} [has_Add m] {S : set m} {P : m → Prop} {x : m} (h : x ∈ Add_Subsemigroup.Closure S) (Hs : ∀ (x : m), x ∈ S → P x) (HMul : ∀ (x y : m), P x → P y → P (x + y)) : P x
{α : Type u_1} {β : Type u_2} [AddGroup α] [subtraction_Monoid β] (F : α →+ β) (g : α) (n : ℤ) : ⇑F (n • g) = n • ⇑F g
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A B : α} (ha : A < 1) (hb : B < 1) : A * B < 1
{α : Type u_1} {β : Type u_2} {α₂ : Type u_3} [Semiring β] [has_Add α] [has_Add α₂] {F : Type u_4} [Add_hom_class F α α₂] (F : F) (x y : AddMonoid_Algebra β α) : Finsupp.Map_IsDomain ⇑F (x * y) = Finsupp.Map_IsDomain ⇑F x * Finsupp.Map_IsDomain ⇑F y
{α : Type u_2} [DecidableEq α] [has_Mul α] {u : Finset α} {S t : set α} : ↑u ⊆ S * t → (∃ (S' t' : Finset α), ↑S' ⊆ S ∧ ↑t' ⊆ t ∧ u ⊆ S' * t')
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} [Fintype ι] (P : ι → P) : AffineIndependent k P ↔ ∀ (W1 W2 : ι → k), Finset.Univ.Sum (λ (i : ι), W1 i) = 1 → Finset.Univ.Sum (λ (i : ι), W2 i) = 1 → ⇑(Finset.Univ.affine_combination P) W1 = ⇑(Finset.Univ.affine_combination P) W2 → W1 = W2
{ι : Type u} {γ : Type W} {β : ι → Type v} [dec : DecidableEq ι] {δ : Type u_1} [Π (i : ι), AddZeroClass (β i)] [AddCommMonoid γ] [AddCommMonoid δ] (g : γ →+ δ) (F : Π (i : ι), β i →+ γ) : g.Comp (⇑Dfinsupp.Lift_Add_hom F) = ⇑Dfinsupp.Lift_Add_hom (λ (A : ι), g.Comp (F A))
{𝕜 : Type u_1} {E : Type u_2} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {F : 𝕜 → E} {r : Ennreal} {x : 𝕜} {P : FormalMultilinearSeries 𝕜 𝕜 E} (h : HasFpowerSeriesOnBall F P x r) (h' : ∀ (r' : Nnreal), 0 < r' → (∃ (P' : FormalMultilinearSeries 𝕜 𝕜 E), HasFpowerSeriesOnBall F P' x ↑r')) : HasFpowerSeriesOnBall F P x ⊤
(R : Type u_1) [CommSemiring R] (x : Type u_2) {C : free_Algebra R x → Prop} (h_grade0 : ∀ (r : R), C (⇑(Algebra_Map R (free_Algebra R x)) r)) (h_grade1 : ∀ (x : x), C (free_Algebra.ι R x)) (h_Mul : ∀ (A B : free_Algebra R x), C A → C B → C (A * B)) (h_Add : ∀ (A B : free_Algebra R x), C A → C B → C (A + B)) (A : free_Algebra R x) : C A
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_NormedGroup E'] [semi_NormedGroup F'] {C : ℝ} {F' : α → E'} {g' : α → F'} {l : Filter α} : Asymptotics._O_with C l (λ (x : α), ∥F' x∥) (λ (x : α), ∥g' x∥) → Asymptotics._O_with C l F' g'
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z → B} [TopologicalSpace Z] {B' : Type u_5} [TopologicalSpace B'] (h : IsTopologicalFiberBundle F Proj) {F : B' → B} (hF : Continuous F) : IsTopologicalFiberBundle F (λ (x : ↥{P : B' × Z | F P.fst = Proj P.Snd}), ↑x.fst)
{α : Type u} [PseudoMetricSpace α] {F : ℕ → α} (n : ℕ) {D : ℕ → ℝ} (hD : ∀ {k : ℕ}, k < n → HasDist.dist (F k) (F (k + 1)) ≤ D k) : HasDist.dist (F 0) (F n) ≤ (Finset.Range n).Sum (λ (i : ℕ), D i)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {x : E} {n : WithTop ℕ} {F g : E → 𝕜} (hF : ContDiff_at 𝕜 n F x) (hg : ContDiff_at 𝕜 n g x) : ContDiff_at 𝕜 n (λ (x : E), F x * g x) x
{α : Type u_1} [LinearOrder α] [DenselyOrdered α] [NoMinOrder α] [NoMaxOrder α] [nonem : Nonempty α] (lo hi : Finset α) (lo_LT_hi : ∀ (x : α), x ∈ lo → ∀ (y : α), y ∈ hi → x < y) : ∃ (m : α), (∀ (x : α), x ∈ lo → x < m) ∧ ∀ (y : α), y ∈ hi → m < y
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (m : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (hM : m (Sum.inr_ ()) (Sum.inr_ ()) ≠ 0) (i : Fin r) : ((Matrix.Pivot.List_transvec_col m).Prod.Mul m).Mul (Matrix.Pivot.List_transvec_row m).Prod (Sum.inr_ ()) (Sum.inl_ i) = 0
{K : Type u_1} [Field K] [Invertible 2] {A B C : K} (ha : A ≠ 0) (h : ∃ (S : K), discrim A B C = S * S) : ∃ (x : K), A * x * x + B * x + C = 0
{R : Type v} [CommRing R] {n : ℕ} (A : Matrix (Fin n.Succ) (Fin n.Succ) R) (j : Fin n.Succ) : A.det = Finset.Univ.Sum (λ (i : Fin n.Succ), (-1) ^ (↑i + ↑j) * A i j * (A.minor ⇑(i.Succ_above) ⇑(j.Succ_above)).det)
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} {A B : α} (h : A ≠ B) : finprod (λ (i : α), finprod (λ (h : i ∈ {A, B}), F i)) = F A * F B
{ι : Type u_1} {R : Type u_3} {m : Type u_5} [Ring R] [AddCommGroup m] [module R m] [Nontrivial R] (B : Basis ι R m) : _.Maximal
{R : Type u_1} {A B : R} [Semigroup R] (Ab : IsLeftRegular (A * B)) : IsLeftRegular B
{E : Type u_1} [AddCommGroup E] [module ℝ E] {S : set E} {x : E} (Absorbs : Absorbent ℝ S) : {r : ℝ | 0 < r ∧ x ∈ r • S}.Nonempty
{α : Type u} {A B : α} [MulOneClass α] [has_Zero α] [Preorder α] [Zero_LT.Mul_Pos_StrictMono α] (ha : A < 1) (hb : B < 1) (B0 : 0 < B) : A * B < 1
{R : Type u_1} {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] [IsNoetherian R m] (F : m →ₗ[R] m) (S : Function.Surjective ⇑F) : Function.Bijective ⇑F
{n : ℕ} {A B : Fin n} {x : Fin (n + 1)} : ⇑(x.Succ_above) A = ⇑(x.Succ_above) B ↔ A = B
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {F : E → F} {F' : E →L[𝕜] F} (x : E) {g : F → G} {g' : F →L[𝕜] G} (hg : HasStrictFderivAt g g' (F x)) (hF : HasStrictFderivAt F F' x) : HasStrictFderivAt (λ (x : E), g (F x)) (g'.Comp F') x
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] {F : E → F} {C : E} (hD : ∀ᶠ (z : E) in nhds C, Differentiable_at ℂ F z) (hc : IsLocalMax (HasNorm.norm ∘ F) C) : ∀ᶠ (y : E) in nhds C, ∥F y∥ = ∥F C∥
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) {r : Nnreal} (h : (λ (n : ℕ), ∥P n∥ * ↑r ^ n) =O[Filter.at_top] λ (n : ℕ), 1) : ↑r ≤ P.radius
{R : Type u} [Ring R] {S : set R} {P : R → R → Prop} {A B : R} (ha : A ∈ Subring.Closure S) (hb : B ∈ Subring.Closure S) (Hs : ∀ (x : R), x ∈ S → ∀ (y : R), y ∈ S → P x y) (h0_Left : ∀ (x : R), P 0 x) (h0_Right : ∀ (x : R), P x 0) (h1_Left : ∀ (x : R), P 1 x) (h1_Right : ∀ (x : R), P x 1) (Hneg_Left : ∀ (x y : R), P x y → P (-x) y) (Hneg_Right : ∀ (x y : R), P x y → P x (-y)) (HAdd_Left : ∀ (x₁ x₂ y : R), P x₁ y → P x₂ y → P (x₁ + x₂) y) (HAdd_Right : ∀ (x y₁ y₂ : R), P x y₁ → P x y₂ → P x (y₁ + y₂)) (HMul_Left : ∀ (x₁ x₂ y : R), P x₁ y → P x₂ y → P (x₁ * x₂) y) (HMul_Right : ∀ (x y₁ y₂ : R), P x y₁ → P x y₂ → P x (y₁ * y₂)) : P A B
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {F' : F} {x : 𝕜} [PartialOrder 𝕜] : HasDerivWithinAt F F' (set.Iio x) x → HasDerivWithinAt F F' (set.Iic x) x
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {C : ℝ} {F : α → E} {g' : α → F'} {l : Filter α} : Asymptotics._O_with C l F g' → Asymptotics._O_with C l F (λ (x : α), ∥g' x∥)
{R : Type u} [Ring R] {m : Type v} [AddCommGroup m] [module R m] [Nontrivial R] {ι : Type W} (B : Basis ι R m) [Infinite ι] {κ : Type W'} (v : κ → m) (i : LinearIndependent R v) (m : i.Maximal) : (Cardinal.Mk ι).Lift ≤ (Cardinal.Mk κ).Lift
{m : Type u_1} [Add_Semigroup m] [TopologicalSpace m] [t2_Space m] (Continuous_Mul_Left : ∀ (r : m), Continuous (λ (_x : m), _x + r)) (S : set m) (snemp : S.Nonempty) (S_IsCompact : IsCompact S) (S_Add : ∀ (x : m), x ∈ S → ∀ (y : m), y ∈ S → x + y ∈ S) : ∃ (m : m) (h : m ∈ S), m + m = m
{R : Type u_1} [CommRing R] {S : Submonoid R} {P : Type u_2} [CommRing P] [Algebra R P] : ↑1 = IsLocalization.Coe_Submodule P ⊤
{α : Type v} [LinearOrder α] [TopologicalSpace α] [order_IsClosed_topology α] {S : set α} (hs : IsPreconnected S) (hb : ¬BddBelow S) (ha : ¬BddAbove S) : S = set.Univ
{α : Type u} [PseudoMetricSpace α] (S : set α) : LipschitzWith 1 (λ (x : α), metric.Inf_dist x S)
{G : Type u_1} [Group G] [Fintype G] : Monoid._torsion G
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {S : set E} (hs : Orthonormal 𝕜 Coe) : ∃ (W : set E) (h : W ⊇ S), Orthonormal 𝕜 Coe ∧ ∀ (u : set E), u ⊇ W → Orthonormal 𝕜 Coe → u = W
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {x : E} {n : WithTop ℕ} {P : E → FormalMultilinearSeries 𝕜 E F} (h : HasFtaylorSeriesUpToOn n F P S) (hn : 1 ≤ n) (hx : x ∈ S) : HasFderivWithinAt F (⇑(Continuous_multilinear_Curry_Fin1 𝕜 E F) (P x 1)) S x
{α : Type u_2} {ι : Type u_5} [AddCommMonoid α] (t : Finset ι) (F : ι → set α) (A : α) : A ∈ t.Sum (λ (i : ι), F i) ↔ ∃ (g : ι → α) (hg : ∀ {i : ι}, i ∈ t → g i ∈ F i), t.Sum (λ (i : ι), g i) = A
{α : Type u} [Infinite α] : Nonempty (Field α)
(n A : ℕ) : Finset.image (λ (_x : ℕ), _x % A) (Finset.Ico n (n + A)) = Finset.Range A
{n : ℕ} {A B : Fin n} : A ⋖ B → ↑A ⋖ ↑B
{x : Type u} {m₁ m₂ : x → x → x} {e₁ e₂ : x} (h₁ : EckmannHilton.IsUnital m₁ e₁) (h₂ : EckmannHilton.IsUnital m₂ e₂) (Distrib : ∀ (A B C D : x), m₁ (m₂ A B) (m₂ C D) = m₂ (m₁ A C) (m₁ B D)) : m₁ = m₂
{G : Type u_1} [Group G] : Group.IsNilpotent G ↔ ∃ (n : ℕ), lower_central_series G n = ⊥
{α : Type u} [Group α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A : α} : A⁻¹ < 1 ↔ 1 < A
(t : Type u) [TopologicalSpace t] : CategoryTheory.Pretopology.of_grothendieck (TopologicalSpace.Opens t) (Opens.GrothendieckTopology t) = Opens.pretopology t
{α : Type u_1} [LinearOrder α] [SuccOrder α] [IsSuccArchimedean α] (r : α → α → Prop) {n m : α} (hr : Reflexive r) (h1 : ∀ (i : α), i ∈ set.Ico n m → r i (Order.Succ i)) (h2 : ∀ (i : α), i ∈ set.Ico m n → r (Order.Succ i) i) : Relation.TransGen r n m
{n : Type u} [DecidableEq n] [Fintype n] {α : Type v} [CommRing α] (A : Matrix n n α) (B : n → α) : A.Mul_vec (⇑(A.cramer) B) = A.det • B
{𝕜 : Type u_3} {E : Type u_4} [semi_NormedRing 𝕜] [AddCommGroup E] [module 𝕜 E] (P : Seminorm 𝕜 E) (r : ℝ) : Balanced 𝕜 (P.ball 0 r)
{α : Type u} [PseudoMetricSpace α] {S t : set α} : metric.Hausdorff_dist (Closure S) (Closure t) = metric.Hausdorff_dist S t
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {C : ℝ} {g : α → F} {F' : α → E'} {l : Filter α} : Asymptotics._O_with C l (λ (x : α), -F' x) g → Asymptotics._O_with C l F' g
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {F : α → β} {S : set α} : Monotone_on F S → Antitone_on (F ∘ ⇑order_dual.of_dual) S
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B : α} (ha : 0 < A) (hb : 0 ≤ B) : 0 < A + B
(z : ℂ) : ↑(z.im) = (z - ⇑(Star_Ring_end ℂ) z) / (2 * Complex.i)
{ι : Type u} (S : Finset ι) (W z : ι → ℝ) (hw : ∀ (i : ι), i ∈ S → 0 ≤ W i) (hw' : S.Sum (λ (i : ι), W i) = 1) (hz : ∀ (i : ι), i ∈ S → 0 ≤ z i) : S.Prod (λ (i : ι), z i ^ W i) ≤ S.Sum (λ (i : ι), W i * z i)
{α : Type u_1} {P : Finset α → Prop} [DecidableEq α] (S : Finset α) (h₁ : P ∅) (h₂ : ∀ {A : α} {S : Finset α}, A ∈ S → S ⊆ S → A ∉ S → P S → P (HasInsert.Insert A S)) : P S
{α : Type u} [Preorder α] {A B C : α} : B < C → A = B → A < C
(n : ℕ) (P : ℕ → ℝ) (hp : ∀ (k : ℕ), 0 ≤ P k) {r A : ℝ} (hr : 0 ≤ r) (ha : 0 ≤ A) : (Finset.Ico 2 (n + 1)).Sum (λ (k : ℕ), A ^ k * {C : Composition k | 1 < C.length}.to_Finset.Sum (λ (C : Composition k), r ^ C.length * Finset.Univ.Prod (λ (j : Fin C.length), P (C.blocks_fun j)))) ≤ (Finset.Ico 2 (n + 1)).Sum (λ (j : ℕ), r ^ j * (Finset.Ico 1 n).Sum (λ (k : ℕ), A ^ k * P k) ^ j)
(l : List ℕ) (n : ℕ) : List.Sorted has_LT.LT (Denumerable.raise' l n)
{J : Type u₁} [CategoryTheory.Category J] {K : Type u₂} [CategoryTheory.Category K] {C : Type u} [CategoryTheory.Category C] {F : J ⥤ C} (e : K ≌ J) [CategoryTheory.Limits.HasLimit (e.Functor ⋙ F)] : CategoryTheory.Limits.HasLimit F
{α : Type u} {β : Type v} [Fintype β] (r : α → β → Prop) [Π (A : α), Decidable_Pred (r A)] : (∀ (A : Finset α), A.Card ≤ (Finset.Filter (λ (B : β), ∃ (A : α) (h : A ∈ A), r A B) Finset.Univ).Card) ↔ ∃ (F : α → β), Function.Injective F ∧ ∀ (x : α), r x (F x)
{α : Type u} {F : α → α} {x : α} (hF : Function.IsFixedPt F x) : F x = x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] [CategoryTheory.Limits.HasPullbacks C] {P q R : C} {F : P ⟶ R} {g : q ⟶ R} {P : ↥P} {q : ↥q} : ⇑F P = ⇑g q → (∃ (S : ↥(CategoryTheory.Limits.pullback F g)), ⇑CategoryTheory.Limits.pullback.fst S = P ∧ ⇑CategoryTheory.Limits.pullback.Snd S = q)
{α : Type u} {l : List α} : l.sublists.Nodup → l.Nodup
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (v : m) {r : R} (h : 0 ≤ r) : SameRay R (r • v) v
{α : Type u_1} {β : Type u_2} {m : Type u_5} [CommMonoid m] {F : α → m} {g : β → m} (e : α → β) (hE₀ : Function.Bijective e) (hE₁ : ∀ (x : α), F x = g (e x)) : finprod (λ (i : α), F i) = finprod (λ (j : β), g j)
{K : Type u} {v v₁ : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [AddCommGroup v₁] [module K v₁] (Cond : module.rank K v = module.rank K v₁) : Nonempty (v ≃ₗ[K] v₁)
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : Rˣ) : ∀ᶠ (t : R) in nhds 0, Ring.Inverse (↑x + t) = Ring.Inverse (1 + ↑x⁻¹ * t) * ↑x⁻¹
{E : Type u_2} [semi_NormedGroup E] [NormedSpace ℝ E] : Convex_on ℝ set.Univ HasNorm.norm
 : GoldenRatio⁻¹ = -golden_Conj
{α : Type u_3} {β : Type u_4} [Preorder β] {F : β → Finset α} (h : Monotone F) (h' : ∀ (x : α), ∃ (n : β), x ∈ F n) : Filter.Tendsto F Filter.at_top Filter.at_top
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] (F : ℂ → E) (z W : ℂ) (Hc : Continuous_on F (set.Interval z.re W.re ×ℂ set.Interval z.im W.im)) (hD : DifferentiableOn ℂ F (set.Ioo (LinearOrder.min z.re W.re) (LinearOrder.max z.re W.re) ×ℂ set.Ioo (LinearOrder.min z.im W.im) (LinearOrder.max z.im W.im))) : (((∫ (x : ℝ) in z.re..W.re, F (↑x + ↑(z.im) * Complex.i)) - ∫ (x : ℝ) in z.re..W.re, F (↑x + ↑(W.im) * Complex.i)) + Complex.i • ∫ (y : ℝ) in z.im..W.im, F (↑(W.re) + ↑y * Complex.i)) - Complex.i • ∫ (y : ℝ) in z.im..W.im, F (↑(z.re) + ↑y * Complex.i) = 0
{α : Type u_1} {β : Type u_2} [LinearOrder α] {A B : α} {h : A ≤ B} [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] {F : ↥(set.icc A B) → β} (hF : Continuous F) : Continuous (set.icc_extend h F)
{α : Type u_1} [conditionally_CompleteLattice α] {S : set α} {A : α} (h : IsLeast S A) : HasInf.Inf S = A
{R : Type u_1} {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] [IsNoetherian R m] (F : m →ₗ[R] m) (S : Function.Surjective ⇑F) : Function.Injective ⇑F
{R : Type u} {m : Type v} [CommRing R] [Nontrivial R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] (F : m →ₗ[R] m) {ι : Type W} [Fintype ι] (B : Basis ι R m) : (⇑(Linear_Map.to_Matrix B B) F).charpoly = F.charpoly
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {F : R →+* S} {S : S} (n : ℕ) (h : S ∈ set.Range ⇑F) : ⇑(Polynomial.monomial n) S ∈ Polynomial.lifts F
{G₀ : Type u_2} [Group_with_Zero G₀] (A : G₀) : A * A / A = A
{𝕜 : Type u_1} {E : Type u_3} [NormedField 𝕜] [AddCommGroup E] [module 𝕜 E] {A : set E} [TopologicalSpace E] [has_Continuous_Smul 𝕜 E] (hA : Balanced 𝕜 A) (h : 0 ∈ Interior A) : Balanced 𝕜 (Interior A)
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ - 2 * HasInner.inner x y + ∥y∥ * ∥y∥
{m : Type u_3} [AddMonoid m] [Inhabited m] (l : List m) (h : l ≠ List.Nil) : l.head + l.tail.Sum = l.Sum
{P k : ℕ} (hp : Nat.Prime P) : (P ^ k).factorization = Finsupp.single P k
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {t₁ t₂ : Affine.Triangle ℝ P} {i₁ i₂ i₃ j₁ j₂ j₃ : Fin 3} (hi₁₂ : i₁ ≠ i₂) (hi₁₃ : i₁ ≠ i₃) (hi₂₃ : i₂ ≠ i₃) (hj₁₂ : j₁ ≠ j₂) (hj₁₃ : j₁ ≠ j₃) (hj₂₃ : j₂ ≠ j₃) (h₁ : t₂.points j₁ = t₁.orthocenter) (h₂ : t₂.points j₂ = t₁.points i₂) (h₃ : t₂.points j₃ = t₁.points i₃) : t₂.orthocenter = t₁.points i₁
{ι : Type u} {F g : ι → Nnreal} {P : ℝ} (hp : 1 ≤ P) (hF : Summable (λ (i : ι), F i ^ P)) (hg : Summable (λ (i : ι), g i ^ P)) : Summable (λ (i : ι), (F i + g i) ^ P) ∧ (∑' (i : ι), (F i + g i) ^ P) ^ (1 / P) ≤ (∑' (i : ι), F i ^ P) ^ (1 / P) + (∑' (i : ι), g i ^ P) ^ (1 / P)
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {x : α} {P : Filter ι} {g : ι → α} [TopologicalSpace α] (h : Continuous_at F x) (hg : Filter.Tendsto g P (nhds x)) (hunif : ∀ (u : set (β × β)), u ∈ Uniformity β → (∃ (t : set α) (h : t ∈ nhds x), ∀ᶠ (n : ι) in P, ∀ (y : α), y ∈ t → (F y, F n y) ∈ u)) : Filter.Tendsto (λ (n : ι), F n (g n)) P (nhds (F x))
{R : Type u_1} {m : Type u_3} {A B : R} [comm_Semigroup R] [HasScalar R m] [IsScalarTower R R m] : IsSmulRegular m (A * B) ↔ IsSmulRegular m A ∧ IsSmulRegular m B
{α : Type u_1} [Monoid α] {P q : α} (hp : Irreducible P) (hq : Irreducible q) : P ∣ q → q ∣ P
{R : Type u_1} {S : Type u_2} [CommRing R] [Nontrivial R] [CommRing S] [IsDomain S] [Algebra R S] (h : Algebra.IsIntegral R S) (hRS : Function.Injective ⇑(Algebra_Map R S)) (hS : _Field S) : _Field R
{α : Type u_1} {ι : Type u_4} [CompleteLattice α] (S : ι → α) : (⨅ (i : ι), S i) = ⨅ (t : Finset ι) (i : ι) (h : i ∈ t), S i
{R : Type u} [Ring R] (S : Subring R) {x y : R} (hx : x ∈ S) (hy : y ∈ S) : x - y ∈ S
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [HasScalar 𝕜 E] {S t : Convex_cone 𝕜 E} (h : ∀ (x : E), x ∈ S ↔ x ∈ t) : S = t
{P n k : ℕ} (P_Large : n < P ^ 2) : ⇑((n.choose k).factorization) P ≤ 1
{R : Type u} [Ring R] {L m N : module R} (F : L ⟶ m) [CategoryTheory.Limits.HasImage F] (g : ↑(CategoryTheory.Limits.image_Subobject F) ⟶ N) [CategoryTheory.Limits.HasCokernel g] {x y : ↥N} (l : ↥L) (W : x = y + ⇑g (⇑(CategoryTheory.Limits.FactorThruImage_Subobject F) l)) : ⇑(CategoryTheory.Limits.Cokernelπ g) x = ⇑(CategoryTheory.Limits.Cokernelπ g) y
{α : Type u} [PseudoEmetricSpace α] (F : ℕ → α) (n : ℕ) : HasEdist.edist (F 0) (F n) ≤ (Finset.Range n).Sum (λ (i : ℕ), HasEdist.edist (F i) (F (i + 1)))
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {n : WithTop ℕ} {S : set E} {F g : E → F} (hF : ContDiff_within_at 𝕜 n F S x) (hg : ContDiff_within_at 𝕜 n g S x) : ContDiff_within_at 𝕜 n (λ (x : E), F x - g x) S x
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (h_Int : Algebra.IsIntegral K L) : t2_Space (L ≃ₐ[K] L)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [Ring_hom_isometric σ₁₂] (F : E →ₛₗ[σ₁₂] F) (hF : Continuous ⇑F) : ∃ (C : ℝ), 0 < C ∧ ∀ (x : E), ∥⇑F x∥ ≤ C * ∥x∥
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (e : LocalHomeomorph α β) (h : e.to_local_Equiv.Source = set.Univ) : IsOpen_Embedding ⇑e
 : ∃ (α β : Type) (iα : TopologicalSpace α) (iβ : TopologicalSpace β), CompactSpace α ∧ t1_Space β ∧ ∃ (F : α ≃ β), Continuous ⇑F ∧ ¬Continuous ⇑(F.Symm)
{G : Type u_1} {h : Type u_2} [Group G] [Group h] {F : G →* h} (hF : Function.Surjective ⇑F) (tG : Monoid._torsion G) : Monoid._torsion h
{G : Type u_1} {h : Type u_2} [AddGroup G] [AddGroup h] {F : G →+ h} (hF : Function.Surjective ⇑F) (tG : AddMonoid._torsion G) : AddMonoid._torsion h
{α : Type u} [Group α] [Fintype α] {P : ℕ} [hp : Fact (Nat.Prime P)] (h : Fintype.Card α = P) : IsCyclic α
{m : Type u_1} [AddZeroClass m] {S t : Add_Submonoid m} (h : ∀ (x : m), x ∈ S ↔ x ∈ t) : S = t
{α : Type u} [TopologicalSpace α] {S U : set α} (hS : IsPreirreducible S) (hU : IsOpen U) (h : (S ∩ U).Nonempty) : S ⊆ Closure (S ∩ U)
{l : Type u_1} {m : Type u_2} {α : Type v} [has_Zero α] [DecidableEq m] [DecidableEq l] (D : m → α) (e : l → m) (hE : Function.Injective e) : (Matrix.Diagonal D).minor e e = Matrix.Diagonal (D ∘ e)
{m₀ : Type u_1} [CancelMonoidWithZero m₀] {A B : m₀} (h₁ : B ≠ 1) (h₂ : A * B = A) : A = 0
{A B : Cardinal} (ha : Cardinal.aleph0 ≤ A) (hb : Cardinal.aleph0 ≤ B) : A * B = LinearOrder.max A B
{E : Type u_1} {β : Type u_2} [AddCommGroup E] [TopologicalSpace E] [module ℝ E] [topological_AddGroup E] [has_Continuous_Smul ℝ E] [ordered_AddCommGroup β] [module ℝ β] [OrderedSmul ℝ β] {F : E → β} {A : E} (h_IsLocalMax : IsLocalMax F A) (h_conc : ConcaveOn ℝ set.Univ F) (x : E) : F x ≤ F A
(S : ℝ) {B : ℝ} (hb : 0 < B) : (λ (x : ℝ), x ^ S) =o[Filter.at_top] λ (x : ℝ), Real.Exp (B * x)
{C : Type u} [CategoryTheory.Category C] {x Y : C} (F : x ⟶ Y) [CategoryTheory.Limits.HasImage F] : (CategoryTheory.Limits.image.Mono_factorisation F).e = CategoryTheory.Limits.FactorThruImage F
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] : ⊥.fixing_Subgroup = ⊤
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {F G : C ⥤ D} (h_obj : ∀ (x : C), F.obj x = G.obj x) (h_Map : ∀ (x Y : C) (F : x ⟶ Y), F.Map F == G.Map F) : F = G
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [NormalSpace Y] (F : bounded_Continuous_Function x ℝ) {t : set ℝ} {e : x → Y} [hs : t.Ord_connected] (hF : ∀ (x : x), ⇑F x ∈ t) (hne : t.Nonempty) (hE : IsClosed_Embedding e) : ∃ (g : bounded_Continuous_Function Y ℝ), (∀ (y : Y), ⇑g y ∈ t) ∧ ⇑g ∘ e = ⇑F
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q R : C} (F : P ⟶ q) (g : q ⟶ R) : ⇑g ∘ ⇑F = ⇑(F ≫ g)
{R : Type u₁} [CommRing R] (A B : R) : (A - B) ^ 2 = A ^ 2 - 2 * A * B + B ^ 2
{ι : Type u_1} {x : ι → Type u_2} [Π (i : ι), TopologicalSpace (x i)] {as bs cs : Π (i : ι), x i} (γ₀ : Π (i : ι), Path.Homotopic.Quotient (as i) (bs i)) (γ₁ : Π (i : ι), Path.Homotopic.Quotient (bs i) (cs i)) : (Path.Homotopic.Pi γ₀).Comp (Path.Homotopic.Pi γ₁) = Path.Homotopic.Pi (λ (i : ι), (γ₀ i).Comp (γ₁ i))
{P : ℕ} {G : Type u_1} [Group G] (hG : _P_Group P G) [hp : Fact (Nat.Prime P)] (α : Type u_2) [MulAction G α] [Fintype α] [Fintype ↥(MulAction.FixedPoints G α)] (hpα : ¬P ∣ Fintype.Card α) : (MulAction.FixedPoints G α).Nonempty
{𝕜 : Type u_1} {E : Type u_2} [ordered_Ring 𝕜] [AddCommGroup E] [module 𝕜 E] (q : AffineSubspace 𝕜 E) : Convex 𝕜 ↑q
{R : Type u_1} [CommRing R] (m : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization m S] (A : S) : ∃ (B : ↥m), IsLocalization._integer R (↑B • A)
{A B C : ℕ} (h : A % C = B % C) : (A - B) % C = 0
 : Fact (Finite_dimensional.finrank ℝ ℂ = 2)
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (E : intermediate_Field K L) [Finite_dimensional K ↥E] : IsOpen ↑(E.fixing_Subgroup)
{m : Type u_1} [AddCommMonoid m] (F : ℕ → ℕ → m) (n : ℕ) : (Finset.Nat.antidiagonal n).Sum (λ (ij : ℕ × ℕ), F ij.fst ij.Snd) = (Finset.Range n.Succ).Sum (λ (k : ℕ), F k (n - k))
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] [Nonempty v] (k : ℕ) (h : ∀ (v : v), k ≤ G.degree v) : k ≤ G.min_degree
{J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ AddMon) [CategoryTheory.IsFiltered J] {x y y' : Σ (j : J), ↥(F.obj j)} (hyy' : CategoryTheory.Limits.types.filtered_Colimit.Rel (F ⋙ CategoryTheory.Forget AddMon) y y') : AddMon.FilteredColimits.Colimit_Add_aux F x y = AddMon.FilteredColimits.Colimit_Add_aux F x y'
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] (F : ℂ → E) (z W : ℂ) (h : DifferentiableOn ℂ F (set.Interval z.re W.re ×ℂ set.Interval z.im W.im)) : (((∫ (x : ℝ) in z.re..W.re, F (↑x + ↑(z.im) * Complex.i)) - ∫ (x : ℝ) in z.re..W.re, F (↑x + ↑(W.im) * Complex.i)) + Complex.i • ∫ (y : ℝ) in z.im..W.im, F (↑(W.re) + ↑y * Complex.i)) - Complex.i • ∫ (y : ℝ) in z.im..W.im, F (↑(z.re) + ↑y * Complex.i) = 0
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q R : C} (F : P ⟶ q) (g : q ⟶ R) (A : ↥P) : ⇑(F ≫ g) A = ⇑g (⇑F A)
{n : ℕ} {α : Type u_1} {v W : Vector α n} (h : ∀ (m : Fin n), v.nth m = W.nth m) : v = W
{R : Type u} [Field R] [Star_Ring R] (x y : R) : HasStar.Star (x / y) = HasStar.Star x / HasStar.Star y
{G : Type u} [AddMonoid G] {h : Type v} [AddMonoid h] (F : G →+ h) {x : G} (h : _of_Fin_Add_order x) : _of_Fin_Add_order (⇑F x)
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (S : Finset ι) : Finset.centroid_weights_indicator k S = ↑S.indicator (Finset.centroid_weights k S)
{α : Type u_1} [CompleteLattice α] {A : α} {S : set α} : A ⊔ HasInf.Inf S ≤ ⨅ (B : α) (h : B ∈ S), A ⊔ B
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : ℝ} {C W : ℂ} {F : ℂ → E} (hD : DifferentiableOn ℂ F (metric.IsClosed_ball C R)) (hw : W ∈ Metric.Ball C R) : ∮ (z : ℂ) in C(C, R), (z - W)⁻¹ • F z = (2 * ↑Real.Pi * Complex.i) • F W
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.ConcreteCategory.Forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.ConcreteCategory.Forget C)] {x : top} (F : top.sheaf C x) {ι : Type v} (U : ι → TopologicalSpace.Opens ↥x) (sf : Π (i : ι), ↥(F.val.obj (Opposite.Op (U i)))) (h : F.val._compatible U sf) : ∃! (S : ↥(F.val.obj (Opposite.Op (supr U)))), F.val._gluing U sf S
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {F : β → γ} {x : α} {y : β} (hF : Continuous_at F y) : Continuous_at (λ (x : α × β), F x.Snd) (x, y)
{α : Type u_1} {l : Filter α} {P : α → Prop} : (∀ᶠ (S : set α) in l.Small_sets, ∀ (x : α), x ∈ S → P x) → (∀ᶠ (x : α) in l, P x)
{k : Type u_1} {v : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {P : ι → P} (hi : AffineIndependent k P) {S : Finset ι} {sm : Submodule k v} [Finite_dimensional k ↥sm] (hle : Vector_Span k ↑(Finset.image P S) ≤ sm) (hc : S.Card = Finite_dimensional.finrank k ↥sm + 1) : Vector_Span k ↑(Finset.image P S) = sm
{α : Type u} [PseudoMetricSpace α] {S : set α} : Metric.Bounded S ↔ Emetric.diam S ≠ ⊤
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} {x : E} : MdifferentiableAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F x ↔ Differentiable_at 𝕜 F x
{α : Type u_1} {l l' : List α} (F : ℕ ↪o ℕ) (hF : ∀ (ix : ℕ), l.nth ix = l'.nth (⇑F ix)) : l <+ l'
{x : Type u_1} [TopologicalSpace x] [CompactSpace x] (A : Subalgebra ℝ C(x, ℝ)) (W : A.separates_points) : A.topological_Closure = ⊤
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y z : v} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x z - o.oangle x y = o.oangle y z
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] : affine_Span k set.Univ = ⊤
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {S : set 𝕜} {F : 𝕜 → 𝕜} (hF : Convex_on 𝕜 S F) {x y z : 𝕜} (hx : x ∈ S) (hz : z ∈ S) (hxy : x < y) (hyz : y < z) : (F y - F x) / (y - x) ≤ (F z - F y) / (z - y)
(A B : ℝ) : (Polynomial_Functions (set.icc A B)).topological_Closure = ⊤
(A B : ℝ) (F : C(↥(set.icc A B), ℝ)) : F ∈ (Polynomial_Functions (set.icc A B)).topological_Closure
{R : Type u_1} {E : Type u_2} [Linear_ordered_Field R] [AddCommGroup E] [module R E] {ι : Type u_3} (B : affine_Basis ι R E) : ⇑(Convex_hull R) (set.Range B.points) = {x : E | ∀ (i : ι), 0 ≤ ⇑(B.coord i) x}
{α : Type u} {P : α → Prop} {A : α} (h : A ∈ {x : α | P x}) : P A
{n : ℕ} {α : Fin (n + 1) → Type u} (q : Π (i : Fin (n + 1)), α i) (z : α 0) : Fin.tail (Function.update q 0 z) = Fin.tail q
{α : Type u_1} [DecidableEq α] : Monotone Finset.shadow
(R : Type u_1) (A : Type u_2) [CommSemiring R] : Pi.Const_Ring_hom A R = Algebra_Map R (A → R)
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type W} {x : C} {R : CategoryTheory.Presieve x} : CategoryTheory.Presieve.IsSheafFor P R → CategoryTheory.Presieve.IsSeparated_for P R
{G : Type u_6} {h : Type u_7} {F : Type u_8} [AddGroup G] [subtraction_Monoid h] [AddMonoid_hom_class F G h] (F : F) (n : ℤ) (g : G) : ⇑F (n • g) = n • ⇑F g
(n : ℕ) : ↑(n.Totient) = ↑n * n.Factors.to_Finset.Prod (λ (P : ℕ), 1 - (↑P)⁻¹)
{E : Type u_1} [AddCommGroup E] [module ℝ E] (P : Seminorm ℝ E) : gauge (P.ball 0 1) = ⇑P
{F : Type u_3} [InnerProductSpace ℝ F] {x : F} {r : ℝ} (hx : x ≠ 0) (hr : r < 0) : HasInner.inner x (r • x) / (∥x∥ * ∥r • x∥) = -1
{R : Type u_1} {α : Type u_2} (G : SimpleGraph α) [has_Zero R] [has_One R] [DecidableEq α] [Decidable_Rel G.Adj] {A : α} {e : Sym2 α} : SimpleGraph.inc_Matrix R G A e = Ite (e ∈ G.incidence_set A) 1 0
{m : Type u} {n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) (B : Matrix n m α) [Invertible A] : (⅟ A).Mul (A.Mul B) = B
(P : ℕ) [hp : Fact (Nat.Prime P)] {q : ℚ} (h : padic_norm P q = 0) : q = 0
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) : o.oangle (-x) (-y) = o.oangle x y
{α : Type u} [Preorder α] [NoMaxOrder α] (A : α) : ∃ (F : ℕ → α), StrictMono F ∧ F 0 = A
{α : Type u_1} [conditionally_CompleteLattice α] {S : set α} {B : α} (hs : S.Nonempty) (h : ∀ (A : α), A ∈ S → A ≤ B) (h' : ∀ (W : α), W < B → (∃ (A : α) (h : A ∈ S), W < A)) : HasSup.Sup S = B
(P : Polynomial ℚ) : (P.root_set ℂ).to_Finset.Card = (P.root_set ℝ).to_Finset.Card + (⇑(Polynomial.Gal.Gal_action_hom P ℂ) (⇑(Polynomial.Gal.Restrict P ℂ) (alg_Equiv.Restrict_scalars ℚ Complex.Conj_ae))).Support.Card
(z : UpperHalfPlane) : Filter.Tendsto (λ (P : Fin 2 → ℤ), ⇑Complex.norm_sq (↑(P 0) * ↑z + ↑(P 1))) Filter.cofinite Filter.at_top
{P : ℕ} [hp : Fact (Nat.Prime P)] : WittVector.IsPoly P (λ (R : Type u_1) (_Rcr : CommRing R), ⇑witt_Vector.verschiebung)
{ι : Type u} {x : Type v} [TopologicalSpace x] {S : set x} [NormalSpace x] [ParacompactSpace x] (hs : IsClosed S) (U : ι → set x) (ho : ∀ (i : ι), IsOpen (U i)) (hU : S ⊆ ⋃ (i : ι), U i) : ∃ (F : BumpCovering ι x S), F._subordinate U
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasPullbacks C] {x Y : C} (g : Y ⟶ x) [CategoryTheory.Mono g] (F₁ F₂ : CategoryTheory.Subobject Y) : (CategoryTheory.Subobject.Map g).obj (F₁ ⊓ F₂) = (CategoryTheory.Subobject.Map g).obj F₁ ⊓ (CategoryTheory.Subobject.Map g).obj F₂
{J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ AddMon) [CategoryTheory.IsFiltered J] (j : J) : 0 = AddMon.FilteredColimits.m.Mk F ⟨j, 0⟩
{α : Type u} [PseudoMetricSpace α] {S : set α} {x : α} (h : IsClosed S) (hs : S.Nonempty) : x ∈ S ↔ metric.Inf_dist x S = 0
{𝕜 : Type u_1} {x : Type u_2} [_R_or_C 𝕜] [TopologicalSpace x] {A : Subalgebra 𝕜 C(x, 𝕜)} (hA : A.separates_points) (hA' : Continuous_Map.Conj_invariant_Subalgebra (Subalgebra.Restrict_scalars ℝ A)) : ((Subalgebra.Restrict_scalars ℝ A).comap' (AlgHom.Comp_Left_Continuous ℝ _R_or_C.of_Real_am _R_or_C.Continuous_of_Real)).separates_points
{x : Type u} {Y : Type v} [MetricSpace x] [MetricSpace Y] : Isometry Sum.inl_
(S B : ℝ) (hb : 0 < B) : Filter.Tendsto (λ (x : ℝ), x ^ S * Real.Exp (-B * x)) Filter.at_top (nhds 0)
{α : Type u} [PseudoMetricSpace α] {S : set α} [ProperSpace α] (h : Metric.Bounded S) : IsCompact (Closure S)
{𝕜 : Type u_1} [NormedField 𝕜] [CompleteSpace 𝕜] {r : 𝕜} (hr : ∥r∥ < 1) : has_Sum (λ (n : ℕ), ↑n * r ^ n) (r / (1 - r) ^ 2)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) : ⇑_R_or_C.re (HasInner.inner x y) = (∥x + y∥ * ∥x + y∥ - ∥x - y∥ * ∥x - y∥) / 4
{α : Type u} [PartialOrder α] {A B : α} (hab : A ≤ B) (hba : ¬A < B) : A = B
{α : Type u} {β : Type v} {S : set α} {F : α → β} : set.inj_on F S → Function.Injective (S.Restrict F)
{α : Type u} {β : Type v} [Preorder α] [LinearOrder β] {F g : α → β} (hF : Monotone F) (hg : Monotone g) : Monotone (λ (x : α), LinearOrder.max (F x) (g x))
{A : Type u_1} {B : Type u_2} [i : set_like A B] {P q : A} (h : ∀ (x : B), x ∈ P ↔ x ∈ q) : P = q
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x : v) : 2 • o.oangle (-x) x = 0
{R : Type u} [Semiring R] {S : Type v} [Semiring S] (F : R →+* S) : Polynomial.x ∈ Polynomial.lifts F
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [Linear_ordered_Field 𝕜] [AddCommGroup E] [Linear_ordered_AddCommGroup β] [module 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F : E → β} (hF : Convex_on 𝕜 (⇑(Convex_hull 𝕜) S) F) {x : E} (hx : x ∈ ⇑(Convex_hull 𝕜) S) : ∃ (y : E) (h : y ∈ S), F x ≤ F y
{α : Type u} {β : Type v} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] {F : Filter β} {u : β → α} {A : α} [F.Ne_IsBot] (h : Filter.Tendsto u F (nhds A)) : F.limsup u = A
{R : Type u_1} [Semiring R] {q : laurent_Polynomial R → Prop} (F : laurent_Polynomial R) (is_qf : ∀ {F : Polynomial R} {n : ℕ}, q (⇑Polynomial.to_laurent F * laurent_Polynomial.t (-↑n))) : q F
{α : Type u} [PseudoMetricSpace α] {x : α} {r : ℝ} (h : 0 ≤ r) : Metric.diam (metric.IsClosed_ball x r) ≤ 2 * r
(α : Type u_1) (β : Type u_2) [LinearOrder α] [LinearOrder β] [Encodable α] [DenselyOrdered α] [NoMinOrder α] [NoMaxOrder α] [Nonempty α] [Encodable β] [DenselyOrdered β] [NoMinOrder β] [NoMaxOrder β] [Nonempty β] : Nonempty (α ≃o β)
{α : Type u_2} {β : Type u_3} {rα : non_assoc_Semiring α} {rβ : non_assoc_Semiring β} (F : α →+* β) (A : α) : ⇑F (bit1 A) = bit1 (⇑F A)
{α : Type u_1} {F g : Poly α} : (∀ (x : α → ℕ), ⇑F x = ⇑g x) → F = g
{α : Type u_2} {β : Type u_3} [non_assoc_Ring α] [non_assoc_Ring β] (F : α →+* β) (x y : α) : ⇑F (x - y) = ⇑F x - ⇑F y
{R : Type u} {ι : Type v} {m₁ : ι → Type W₁} {m₂ : Type W₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (m₁ i)] [AddCommMonoid m₂] [Π (i : ι), module R (m₁ i)] [module R m₂] [Π (i : ι), TopologicalSpace (m₁ i)] [TopologicalSpace m₂] (F : Continuous_MultilinearMap R m₁ m₂) {α : ι → Type u_1} [Fintype ι] (g : Π (i : ι), α i → m₁ i) (A : Π (i : ι), Finset (α i)) : ⇑F (λ (i : ι), (A i).Sum (λ (j : α i), g i j)) = (Fintype.Pi_Finset A).Sum (λ (r : Π (A : ι), α A), ⇑F (λ (i : ι), g i (r i)))
{α : Type u_1} (F : α → α → α) [IsAssociative α F] (x y : α) : ((λ (z : α), F z x) ∘ λ (z : α), F z y) = λ (z : α), F z (F y x)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x Y : C} (F g : x ⟶ Y) [CategoryTheory.Limits.HasKernel (F - g)] : CategoryTheory.Limits.HasEqualizer F g
{x : Type u_1} [TopologicalSpace x] {S : set x} (h : ∀ (x : ℕ → x) (A : x), (∀ (n : ℕ), x n ∈ S) → Filter.Tendsto x Filter.at_top (nhds A) → A ∈ S) : _Seq_IsClosed S
{m n : ℕ} : m ∣ m + n ↔ m ∣ n
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {β : Type u_4} [Linear_ordered_Field 𝕜] [AddCommGroup E] [AddCommGroup F] [ordered_AddCommMonoid β] [module 𝕜 E] [module 𝕜 F] [HasScalar 𝕜 β] {F : F → β} (g : E →ᵃ[𝕜] F) {S : set F} (hF : Convex_on 𝕜 S F) : Convex_on 𝕜 (⇑g ⁻¹' S) (F ∘ ⇑g)
{α : Type u_1} {β : Type u_2} {α₂ : Type u_3} [Semiring β] [has_Zero α] [has_Zero α₂] {F : Type u_4} [ZeroHom_class F α α₂] (F : F) : Finsupp.Map_IsDomain ⇑F 1 = 1
{C : Type u} [CategoryTheory.Category C] {D : Type u_1} [CategoryTheory.Category D] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasEqualizers C] [CategoryTheory.Limits.HasImages C] [CategoryTheory.HasProjectiveResolutions C] [CategoryTheory.Preadditive D] [CategoryTheory.Limits.has_Zero_object D] [CategoryTheory.Limits.HasEqualizers D] [CategoryTheory.Limits.HasCokernels D] [CategoryTheory.Limits.HasImages D] [CategoryTheory.Limits.HasImage_maps D] {F G : C ⥤ D} [F.Additive] [G.Additive] (α : F ⟶ G) (n : ℕ) {x : C} (P : CategoryTheory.ProjectiveResolution x) : (CategoryTheory.Nat_Trans.Left_derived α n).App x = (F.Left_derived_obj_iso n P).hom ≫ (homology_Functor D (ComplexShape.down ℕ) n).Map ((CategoryTheory.Nat_Trans.Map_homological_Complex α (ComplexShape.down ℕ)).App P.Complex) ≫ (G.Left_derived_obj_iso n P).Inv
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) : InnerProductGeometry.angle x y ≤ Real.Pi
{α : Type u_1} [DecidableEq α] [Fintype α] {𝒜 : Finset (Finset α)} {r : ℕ} (h𝒜 : set.sized r ↑𝒜) : set.sized (r + 1) ↑(𝒜.Up_shadow)
{h : Type u} {m : Type u_2} [TopologicalSpace h] [TopologicalSpace m] [ChartedSpace h m] (G : StructureGroupoid h) [HasGroupoid m G] {e : LocalHomeomorph m h} (hE : e ∈ ChartedSpace.Atlas h m) : e ∈ StructureGroupoid.MaximalAtlas m G
{R : Type u_1} {A B : R} [Monoid R] (h : B * A = 1) : IsLeftRegular A
{K : Type v} [Field K] {P : Polynomial K} (hmo : P.monic) (hP : Polynomial.Splits (Ring_hom.Id K) P) : P.Coeff 0 = (-1) ^ P.Nat_degree * P.roots.Prod
{R : Type u} (L : Type v) [CommRing R] [lie_Ring L] [lie_Algebra R L] (m₁ : Type W₁) (m₂ : Type W₂) (m₃ : Type W₃) [AddCommGroup m₁] [module R m₁] [lie_Ring_module L m₁] [lie_module R L m₁] [AddCommGroup m₂] [module R m₂] [lie_Ring_module L m₂] [lie_module R L m₂] [AddCommGroup m₃] [module R m₃] [lie_Ring_module L m₃] [lie_module R L m₃] (g : TensorProduct R m₁ m₂ →ₗ⁅R,L⁆ m₃) (χ₁ χ₂ : L → R) : (↑g.Comp (TensorProduct.Map_incl (lie_module.pre_weight_Space m₁ χ₁) (lie_module.pre_weight_Space m₂ χ₂))).Range ≤ lie_module.pre_weight_Space m₃ (χ₁ + χ₂)
(P : ℕ) [Fact (Nat.Prime P)] : ↑((P - 1).factorial) = -1
{α : Type u} {β : Type v} [Preorder β] {F : α → β} {S : set α} {A : α} : IsMinOn (⇑order_dual.to_dual ∘ F) S A → IsMaxOn F S A
{α : Type u_1} [normed_DivisionRing α] {A : α} (ha : A ≠ 0) : Filter.Tendsto (λ (x : α), x * A) (Filter.comap HasNorm.norm Filter.at_top) (Filter.comap HasNorm.norm Filter.at_top)
{R : Type u_1} {A : R} [Monoid R] (ua : IsUnit A) : IsRegular A
{A : ℝ} {l : Filter ℝ} {F g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in nhds_within A (set.Univ  {A}), Differentiable_at ℝ F x) (hg' : ∀ᶠ (x : ℝ) in nhds_within A (set.Univ  {A}), deriv g x ≠ 0) (hfa : Filter.Tendsto F (nhds_within A (set.Univ  {A})) (nhds 0)) (hga : Filter.Tendsto g (nhds_within A (set.Univ  {A})) (nhds 0)) (HDiv : Filter.Tendsto (λ (x : ℝ), deriv F x / deriv g x) (nhds_within A (set.Univ  {A})) l) : Filter.Tendsto (λ (x : ℝ), F x / g x) (nhds_within A (set.Univ  {A})) l
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] (F : S.Localization_Map N) (z : N) : F.Mk' (F.sec z).fst (F.sec z).Snd = z
{α : Type u_1} {β : Type u_2} [LinearOrder α] [PredOrder α] [Preorder β] {F : α → β} (hF : Antitone F) : Pairwise (Disjoint on λ (n : α), set.ioc (F n) (F (Order.Pred n)))
{ι : Type u} {β : ι → Type v} [dec : DecidableEq ι] [Π (i : ι), has_Zero (β i)] (i j : ι) (xi : β i) (xj : β j) : Dfinsupp.single i xi = Dfinsupp.single j xj ↔ i = j ∧ xi == xj ∨ xi = 0 ∧ xj = 0
{α : Type u_1} {β : Type u_2} [Semigroup α] [comm_Semigroup β] {F g : α → β} (hF : _Mul_hom F) (hg : _Mul_hom g) : _Mul_hom (λ (A : α), F A * g A)
{α : Type u_1} {β : Type u_2} [UniformSpace β] {F : α → β} {S : set α} [TopologicalSpace α] (L : ∀ (u : set (β × β)), u ∈ Uniformity β → (∃ (F : α → β), Continuous_on F S ∧ ∀ (y : α), y ∈ S → (F y, F y) ∈ u)) : Continuous_on F S
{x : Type u_2} {Y : Type u_3} [TopologicalSpace x] [TopologicalSpace Y] [TopologicalSpace.pseudo_metrizable_Space Y] {F : x → Y} (hF : Inducing F) : TopologicalSpace.pseudo_metrizable_Space x
 : Function.RightInverse Coe ⇑Cardinal.ToNat
{R : Type u_1} [CommRing R] {A B : Quaternion R} (h : Commute A B) : Commute (⇑Quaternion.Conj A) (⇑Quaternion.Conj B)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (x Y : C) [CategoryTheory.Limits.HasBinaryBiproduct x Y] {B : CategoryTheory.Limits.BinaryBicone x Y} (hb : B._bilimit) : (hb._Limit.cone_point_Unique_Up_to_iso (CategoryTheory.Limits.BinaryBiproduct._Limit x Y)).hom = CategoryTheory.Limits.biprod.Lift B.fst B.Snd
{m : Type u_1} {N : Type u_2} [AddZeroClass m] [AddZeroClass N] (h : m ≃+ N) : ⇑h 0 = 0
{R : Type u_1} {R₂ : Type u_2} {m : Type u_4} {m₂ : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] [Semiring R₂] [AddCommMonoid m₂] [module R₂ m₂] {σ₁₂ : R →+* R₂} {ι : Type u_3} {v : ι → m} {F g : m →ₛₗ[σ₁₂] m₂} (hv : Submodule.Span R (set.Range v) = ⊤) (h : ∀ (i : ι), ⇑F (v i) = ⇑g (v i)) : F = g
{G : Type u_1} [Group G] [hN : Nontrivial G] : Monoid._torsion G → ¬Monoid._torsion_free G
{α : Type u_1} [has_LT α] {A B : α} {o : Ordering} : o.Swap.compares A B → o.compares B A
{α : Type u_1} : Sym2.Map (λ (x : α), x) = Id
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {x y : E} (hxy : x ≠ y) : ∃ (F : E →L[ℝ] ℝ), ⇑F x < ⇑F y
{A : Ennreal} (h : A < ⊤) : Add_LE_cancellable A
{x y : SimplexCategory {F : x ⟶ y} : CategoryTheory.Epi F → y.len ≤ x.len
{R : Type u_1} [Mul_Zero_class R] : IsLeftRegular 0 ↔ Subsingleton R
{α : Type u_1} [LinearOrder α] {r S : α} : {r}.to_colex ≤ {S}.to_colex ↔ r ≤ S
{α : Type u} {β : Type v} [AddGroup α] [AddGroup β] {F : α → β} (hF : _AddGroup_hom F) (A : α) : F (-A) = -F A
{α : Type u} {S : set α} (hc : S.countable) (hs : S.Nonempty) : ∃ (F : ℕ → α), S = set.Range F
{α : Type u_1} (o : Part α) : {Dom := o.Dom, get := λ (h : o.Dom), o.get h} = o
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {F' F₁' : E →L[𝕜] F} {x : E} {S : set E} (h : UniqueDiffWithinAt 𝕜 S x) (hF : HasFderivWithinAt F F' S x) (hg : HasFderivWithinAt F F₁' S x) : F' = F₁'
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.CosimplicialObject C) {n : ℕ} {i : Fin (n + 2)} {j : Fin (n + 1)} (h : ⇑Fin.cast_Succ j < i) : x.δ i.Succ ≫ x.σ (⇑Fin.cast_Succ j) = x.σ j ≫ x.δ i
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] {u v : E} (hvm : v ∈ K) (hvo : ∀ (W : E), W ∈ K → HasInner.inner (u - v) W = 0) : Orthogonal_projection_fn K u = v
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] {F : E → F} {F' : E →L[𝕜] F} {A : E} (hF : HasStrictFderivAt F F' A) (hF' : F'.Range = ⊤) (hker : F'.Ker.IsClosed_complemented) : ∀ᶠ (P : F × ↥(F'.Ker)) in nhds (F A, 0), F (HasStrictFderivAt.implicit_Function_of_complemented F F' hF hF' hker P.fst P.Snd) = P.fst
{k : Type u_1} {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {n : ℕ} (S : Affine.Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ℕ} (h : fs.Card = m + 1) : Finset.centroid k Finset.Univ (S.face h).points = Finset.centroid k fs S.points
{α : Type u_1} {ι : Type u_3} [Lattice α] [OrderBot α] {S : Finset ι} {F : ι → α} [DecidableEq ι] : S.Sup_indep F ↔ ∀ (i : ι), i ∈ S → Disjoint (F i) ((S.erase i).Sup F)
(x : ℂ) : HasDerivAt Complex.cos (-Complex.sin x) x
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {F' : F} {x : 𝕜} {L : Filter 𝕜} : HasDerivAt_Filter F F' x L ↔ Filter.Tendsto (slope F x) (L ⊓ Filter.principal {x}ᶜ) (nhds F')
{L : FirstOrder.Language} {m : Type W} {N : Type W'} [L.structure m] [L.structure N] {P : Type u_1} [L.structure P] {q : Type u_2} [L.structure q] (F : L.hom m N) (g : L.hom N P) (h : L.hom P q) : (h.Comp g).Comp F = h.Comp (g.Comp F)
{E : Type u_2} [semi_NormedGroup E] [NormedSpace ℝ E] {S : set E} : Metric.Bounded (⇑(Convex_hull ℝ) S) ↔ Metric.Bounded S
{α : Type u_1} [Preorder α] [Add_comm_Semigroup α] [HasSub α] [HasOrderedSub α] {A B : α} : A + B - A ≤ B
{α : Type u} [Group α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A : α} : 1 < A⁻¹ ↔ A < 1
 : AbsoluteValue.Abs._euclidean
{R : Type u} {n : ℕ} {m : Fin n.Succ → Type v} {m₂ : Type v₂} [Semiring R] [Π (i : Fin n.Succ), AddCommMonoid (m i)] [AddCommMonoid m₂] [Π (i : Fin n.Succ), module R (m i)] [module R m₂] (F : MultilinearMap R m m₂) (m : Π (i : Fin n), m i.Succ) (x y : m 0) : ⇑F (Fin.Cons (x + y) m) = ⇑F (Fin.Cons x m) + ⇑F (Fin.Cons y m)
{α : Type u_1} (G : SimpleGraph α) [Fintype α] [DecidableEq α] [Decidable_Rel G.Adj] {n : ℕ} : G.CliqueFree n → G.clique_Finset n = ∅
 : Ring_hom.Localization_preserves Ring_hom.Finite
{α : Type u} {L₁ L₂ : List (α × Bool)} [DecidableEq α] (h : free_Group.red L₁ L₂) : free_Group.red L₂ (free_Group.reduce L₁)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {P : P} (hp : P ∈ S) (v : v) : v ∈ S.direction ↔ ∃ (P2 : P) (h : P2 ∈ S), v = P -ᵥ P2
{C : Type u} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type W} [CategoryTheory.Category D] [∀ (P : Cᵒᵖ ⥤ D) (x : C) (S : J.cover x), CategoryTheory.Limits.HasMultiequalizer (S.Index P)] (P : Cᵒᵖ ⥤ D) [∀ (x : C), CategoryTheory.Limits.HasColimits_of_shape (J.cover x)ᵒᵖ D] : J.plus_Map (J.to_plus P) = J.to_plus (J.plus_obj P)
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] {S : Finset α} {t : Finset β} {F : α → β} {W : α → m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (hF : ∀ (A : α), A ∈ S → F A ∈ t) (hb : t.Card • B < S.Sum (λ (x : α), W x)) : ∃ (y : β) (h : y ∈ t), B < (Finset.Filter (λ (x : α), F x = y) S).Sum (λ (x : α), W x)
{α : Type u} {β : Type v} {m₁ m₂ : α → β} {F : Filter α} (h : m₁ =ᶠ[F] m₂) : Filter.Map m₁ F = Filter.Map m₂ F
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {F : 𝕜 → F} {S : set 𝕜} : iterated_fderiv_within 𝕜 n F S = ⇑(Continuous_MultilinearMap.Pi_Field_Equiv 𝕜 (Fin n) F) ∘ iterated_deriv_within n F S
{G : Type u} [CategoryTheory.groupoid G] [IsFreeGroupoid G] (t : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))) [Quiver.Arborescence ↥t] {A : G} (P : Quiver.Path (Quiver.root ↥t) A) : IsFreeGroupoid.spanning_Tree.Tree_hom t A = IsFreeGroupoid.spanning_Tree.hom_of_Path t P
{α : Type u_1} [LinearOrder α] {A B : Finset α} (h : A ⊂ B) : A.to_colex < B.to_colex
{α : Type u_1} [has_Add α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] {B C : α} (bc : B < C) (A : α) : A + B < A + C
{x : Type u_2} {Y : Type u_3} [EmetricSpace x] [EmetricSpace Y] {K : Nnreal} {F : x → Y} (h : LipschitzWith K F) : dimH (set.Range F) ≤ dimH set.Univ
{D : set ℝ} (hD : Convex ℝ D) {F : ℝ → ℝ} (hF : Continuous_on F D) (hF' : DifferentiableOn ℝ F (Interior D)) {C : ℝ} (hF'_Gt : ∀ (x : ℝ), x ∈ Interior D → C < deriv F x) (x : ℝ) (h : x ∈ D) (y : ℝ) (h_1 : y ∈ D) : x < y → C * (y - x) < F y - F x
{α : Type u_1} [Add_Semigroup α] (x y : α) : ((λ (_x : α), _x + x) ∘ λ (_x : α), _x + y) = λ (_x : α), _x + (y + x)
{β : Type u} (F : β → Type u) {P : Type u} (S : Π (B : β), P ⟶ F B) (B : β) (x : P) : CategoryTheory.Limits.Pi.π F B (CategoryTheory.Limits.Pi.Lift S x) = S B x
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [cs : CompleteSpace E] {F : E → F} {F' : E ≃L[𝕜] F} {A : E} (hF : HasStrictFderivAt F ↑F' A) : HasStrictFderivAt (HasStrictFderivAt.local_Inverse F F' A hF) ↑(F'.Symm) (F A)
{α : Type u} [TopologicalSpace α] [t2_Space α] (S : Finset α) : ∃ (F : α → set α), ↑S.Pairwise_Disjoint F ∧ ∀ (x : α), x ∈ S → x ∈ F x ∧ IsOpen (F x)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {x₀ : E} (hF : Differentiable_at 𝕜 F x₀) {S : set E} (hs : S ∈ nhds x₀) {C : Nnreal} (hlip : LipschitzOnWith C F S) : ∥fderiv 𝕜 F x₀∥ ≤ ↑C
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {x₀ : α} {K : set β} (hK : IsCompact K) {P : α → β → Prop} (hP : ∀ (y : β), y ∈ K → (∀ᶠ (z : α × β) in nhds (x₀, y), P z.fst z.Snd)) : ∀ᶠ (x : α) in nhds x₀, ∀ (y : β), y ∈ K → P x y
{α : Type u} {S : set (set α)} (hs : Cardinal.Mk ↥S ≤ Cardinal.Continuum) : Cardinal.Mk ↥{t : set α | MeasurableSpace.generate_Measurable S t} ≤ Cardinal.Continuum
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {S : set E} {F : E → F} {n : WithTop ℕ} (g : F →L[𝕜] G) (hF : ContDiff_on 𝕜 n F S) : ContDiff_on 𝕜 n (⇑g ∘ F) S
{G : Type u_1} [TopologicalSpace G] [AddGroup G] [topological_AddGroup G] (N : Add_Subgroup G) [N.Normal] : N.topological_Closure.Normal
{𝕜 : Type u_1} {α : Type u_2} [Linear_ordered_Field 𝕜] [DecidableEq α] {k : ℕ} {𝒜 : Finset (Finset α)} [Fintype α] (hk : k ≤ Fintype.Card α) (h𝒜 : IsAntichain HasSubset.Subset ↑𝒜) : (Finset.Range (k + 1)).Sum (λ (r : ℕ), ↑((𝒜.Slice (Fintype.Card α - r)).Card) / ↑((Fintype.Card α).choose (Fintype.Card α - r))) ≤ ↑((Finset.falling (Fintype.Card α - k) 𝒜).Card) / ↑((Fintype.Card α).choose (Fintype.Card α - k))
{η : Type u_1} [Fintype η] {Gs : η → Type u_2} [Π (i : η), Group (Gs i)] (h K : Π (i : η), Subgroup (Gs i)) : ⁅Subgroup.Pi set.Univ h,Subgroup.Pi set.Univ K⁆ = Subgroup.Pi set.Univ (λ (i : η), ⁅h i,K i⁆)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} [CompleteSpace E] (e : E ≃L[𝕜] F) : ContDiff_at 𝕜 n Continuous_Linear_Map.Inverse ↑e
(n P : ℕ) : (Finset.Filter (λ (e : ℕ), P ∣ e + 1) (Finset.Range n)).Card = n / P
{B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] : IsTrivialTopologicalFiberBundle F Prod.fst
{R : Type u} {S : Type v} [Semiring R] [AddCommMonoid S] (P : Polynomial R) {F : ℕ → R → S} (h : ∀ (n : ℕ), F n 0 = 0) : P.Sum F = (Finset.Range (P.Nat_degree + 1)).Sum (λ (A : ℕ), F A (P.Coeff A))
{J K : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.SmallCategory K] (F : J × K ⥤ Type v) [CategoryTheory.IsFiltered K] [CategoryTheory.Fin_Category J] : Function.Surjective (CategoryTheory.Limits.Colimit_Limit_to_Limit_Colimit F)
{α : Type u} [PseudoEmetricSpace α] {S t : set α} : Emetric.Hausdorff_edist (Closure S) t = Emetric.Hausdorff_edist S t
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y : v} (h : ∥x∥ = ∥y∥) : x = y ↔ o.oangle x y = 0
{α : Type u_1} [TopologicalSpace α] {x : α} {γ : Type u_4} [Linear_ordered_AddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] [has_Continuous_Add γ] {F g : α → γ} (hF : UpperSemicontinuous_at F x) (hg : UpperSemicontinuous_at g x) : UpperSemicontinuous_at (λ (z : α), F z + g z) x
(K : Type u_1) (L : Type u_2) [Field K] [Field L] [Algebra K L] [Finite_dimensional K L] : Algebra.IsIntegral K L
{β : Type u} {α : Type v} {S : Finset α} {F : α → β} [AddCommMonoid β] (R : Setoid α) [Decidable_Rel Setoid.r] : S.Sum (λ (x : α), F x) = (Finset.image Quotient.Mk S).Sum (λ (xbar : Quotient R), (Finset.Filter (λ (y : α), ⟦y⟧ = xbar) S).Sum (λ (y : α), F y))
{C D E : CategoryTheory.groupoid} (F : C ⟶ D) (g : D ⟶ E) : F ≫ g = F ⋙ g
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {n : WithTop ℕ} {S : set E} {F : E → F} (hF : ContDiff_within_at 𝕜 n F S x) : ContDiff_within_at 𝕜 n (λ (x : E), -F x) S x
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {F g : C(α, β)} (h : F = g) (x : α) : ⇑F x = ⇑g x
{G : Type W} [TopologicalSpace G] [AddGroup G] [topological_AddGroup G] {K U : set G} (hK : IsCompact K) (hU : IsOpen U) (hKU : K ⊆ U) : ∃ (v : set G) (h : v ∈ nhds 0), v + K ⊆ U
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (x : module.Ray R m) : x.Some_Vector ≠ 0
(k : Type u_1) {v1 : Type u_2} {P1 : Type u_3} [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] (P : P1) : ⇑(AffineMap.Id k P1) P = P
{n : ℕ} {F : Typevec (n + 1) → Type u} [Mvfunctor F] [q : Mvqpf F] {α : Typevec n} (r : Mvqpf.Cofix F α → Mvqpf.Cofix F α → Prop) (h : ∀ (x y : Mvqpf.Cofix F α), r x y → Mvfunctor.Liftr (α.Rel_Last r) x.dest y.dest) (x y : Mvqpf.Cofix F α) : r x y → x = y
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P (n + 1)) (i : Fin (n + 2)) : S.points i ∈ S.altitude i
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] : {S : set α | IsPreconnected S} = set.Range (Function.uncurry set.icc) ∪ set.Range (Function.uncurry set.Ico) ∪ set.Range (Function.uncurry set.ioc) ∪ set.Range (Function.uncurry set.Ioo) ∪ (set.Range set.ici ∪ set.Range set.ioi ∪ set.Range set.Iic ∪ set.Range set.Iio ∪ {set.Univ, ∅})
{α : Type u} [PseudoMetricSpace α] (R : ℝ) (h : ∀ (x : α) (r : ℝ), R ≤ r → IsCompact (metric.IsClosed_ball x r)) : ProperSpace α
{α : sort u_1} {β : sort u_2} {γ : sort u_3} {F : α → β → γ} (hF : Function.Injective2 F) [Nonempty α] : Function.Injective (λ (B : β) (A : α), F A B)
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [strict_Convex_Space ℝ E] {x y : E} (h : ¬SameRay ℝ x y) : ∥x + y∥ < ∥x∥ + ∥y∥
{G : Type u_1} [Group G] {G₂ : Type u_2} [Group G₂] (P₁ P₂ : ℕ) [hp₁ : Fact (Nat.Prime P₁)] [hp₂ : Fact (Nat.Prime P₂)] (hne : P₁ ≠ P₂) (h₁ : Subgroup G) (h₂ : Subgroup G₂) [Fintype ↥h₁] [Fintype ↥h₂] (hH₁ : _P_Group P₁ ↥h₁) (hH₂ : _P_Group P₂ ↥h₂) : (Fintype.Card ↥h₁).IsCoprime (Fintype.Card ↥h₂)
{α : Type u} [SemilatticeSup α] [OrderBot α] (x y : α) : (x ⨿ y) = x ⊔ y
(R : Type u) [CommRing R] : GaloisConnection (λ (S : set R), Prime_Spectrum.Zero_locus S) (λ (t : (set (Prime_Spectrum R))ᵒᵈ), ↑(Prime_Spectrum.vanishing_Ideal t))
{C : Type u₁} [CategoryTheory.Category C] {x₁₁ x₁₂ x₂₁ x₂₂ x₃₁ x₃₂ : C} {h₁₁ : x₁₁ ⟶ x₁₂} {h₂₁ : x₂₁ ⟶ x₂₂} {h₃₁ : x₃₁ ⟶ x₃₂} {v₁₁ : x₁₁ ⟶ x₂₁} {v₁₂ : x₁₂ ⟶ x₂₂} {v₂₁ : x₂₁ ⟶ x₃₁} {v₂₂ : x₂₂ ⟶ x₃₂} (S : CategoryTheory.IsPushout h₁₁ v₁₁ v₁₂ h₂₁) (t : CategoryTheory.IsPushout h₂₁ v₂₁ v₂₂ h₃₁) : CategoryTheory.IsPushout h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁
{G : Type u_1} [Group G] {N : Type u_3} [Group N] (h : Subgroup G) {F : G →* N} (hF : Function.Bijective ⇑F) : Subgroup.Map F h.Normalizer = (Subgroup.Map F h).Normalizer
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {F : ℝ → E} {A B C : ℝ} (hF : DifferentiableOn ℝ F (set.icc A B)) (bound : ∀ (x : ℝ), x ∈ set.Ico A B → ∥deriv_within F (set.icc A B) x∥ ≤ C) (x : ℝ) (h : x ∈ set.icc A B) : ∥F x - F A∥ ≤ C * (x - A)
{C : Type u} [CategoryTheory.Category C] {J K : Type u₁} [CategoryTheory.Category J] [CategoryTheory.Category K] (F : J ⥤ C) (G : K ⥤ C) (h : F.cones ≅ G.cones) [CategoryTheory.Limits.HasLimit F] : CategoryTheory.Limits.HasLimit G
{ι : Type u_1} {R : Type u_3} {m : Type u_5} {v : ι → m} [Semiring R] [AddCommMonoid m] [module R m] {S : set ι} : ¬LinearIndependent R (v ∘ Coe) ↔ ∃ (F : ι →₀ R), F ∈ Finsupp.supported R R S ∧ F.Support.Sum (λ (i : ι), ⇑F i • v i) = 0 ∧ F ≠ 0
{C : Type u₁} [CategoryTheory.Category C] {x Y : C} {P : CategoryTheory.Subobject Y} {F g : x ⟶ ↑P} (h : F ≫ P.arrow = g ≫ P.arrow) : F = g
{ι : Type u_1} [Fintype ι] [DecidableEq ι] {R : Type u_2} [Semiring R] (x : ι → R) : x = Finset.Univ.Sum (λ (i : ι), x i • λ (j : ι), Ite (i = j) 1 0)
{v : Type u} [Fintype v] [DecidableEq v] {ℓ : ℕ} : ⊥._SRG_with (Fintype.Card v) 0 ℓ 0
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] {F : C(α, β)} {ι : Type u₃} {P : Filter ι} {F : ι → C(α, β)} [CompactSpace α] : Filter.Tendsto F P (nhds F) ↔ TendstoUniformly (λ (i : ι) (A : α), ⇑(F i) A) ⇑F P
{E : Type u_1} {β : Type u_2} [AddCommGroup E] [TopologicalSpace E] [module ℝ E] [topological_AddGroup E] [has_Continuous_Smul ℝ E] [ordered_AddCommGroup β] [module ℝ β] [OrderedSmul ℝ β] {S : set E} {F : E → β} {A : E} (A_in_S : A ∈ S) (h_localmin : IsLocalMinOn F S A) (h_conv : Convex_on ℝ S F) : IsMinOn F S A
{ι : Type u_6} [DecidableEq ι] {K : Type u_1} [Ring K] {m : Type u_2} [AddCommGroup m] [module K m] {N : Type u_3} [AddCommGroup N] [module K N] [NoZeroSmulDivisors K N] (F : AlternatingMap K m N ι) (v : ι → m) (h : ¬LinearIndependent K v) : ⇑F v = 0
{α : Type u_1} {S : Multiset α} : S.powerset.Nodup → S.Nodup
{ι : Type u_1} {R : Type u_3} {m : Type u_5} [Ring R] [Nontrivial R] [AddCommGroup m] [module R m] [NoZeroSmulDivisors R m] (v : ι → m) [Unique ι] : v Inhabited.Default ≠ 0 → LinearIndependent R v
{𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] {F : 𝕜 → G} {S : set 𝕜} {C : Nnreal} (hs : Convex ℝ S) (hF : DifferentiableOn 𝕜 F S) (bound : ∀ (x : 𝕜), x ∈ S → ∥deriv_within F S x∥₊ ≤ C) : LipschitzOnWith C F S
(R : Type u_1) [Rack R] (G : Type u_2) [Group G] (F : ShelfHom R (Quandle.Conj G)) : (Quandle.Conj.Map (⇑Rack.to_envel_Group.Map F)).Comp (Rack.to_envel_Group R) = F
{α : Type u} {l₁ l₂ : List α} (i : ℕ) : List.Drop (l₁.length + i) (l₁ ++ l₂) = List.Drop i l₂
{α : Type u} (r : α → α → Prop) [IsAntisymm α r] {A B : α} : r A B → r B A → B = A
{F : ℕ → Nnreal} {r : Nnreal} : has_Sum F r ↔ Filter.Tendsto (λ (n : ℕ), (Finset.Range n).Sum (λ (i : ℕ), F i)) Filter.at_top (nhds r)
{x : Type u_1} {Y : Type u_2} [PseudoEmetricSpace x] [PseudoEmetricSpace Y] {C r : Nnreal} {F : x → Y} (hF : HolderWith C r F) (h0 : 0 < r) : uniform_Continuous F
{A B : ℝ} (h : A < B) : Cardinal.Mk ↥(set.icc A B) = Cardinal.Continuum
{ι₁ : Type u_1} {ι₂ : Type u_2} {R : Type u_3} {R₂ : Type u_4} {S : Type u_5} {S₂ : Type u_6} {m : Type u_7} {N : Type u_8} {P : Type u_9} [CommRing R] [CommRing S] [CommRing R₂] [CommRing S₂] [AddCommGroup m] [AddCommGroup N] [AddCommGroup P] [module R m] [module S N] [module R₂ P] [module S₂ P] [SmulCommClass S₂ R₂ P] {ρ₁₂ : R →+* R₂} {σ₁₂ : S →+* S₂} (B₁ : Basis ι₁ R m) (B₂ : Basis ι₂ S N) {B : m →ₛₗ[ρ₁₂] N →ₛₗ[σ₁₂] P} (x : m) (y : N) : (⇑(B₁.repr) x).Sum (λ (i : ι₁) (xi : R), (⇑(B₂.repr) y).Sum (λ (j : ι₂) (yj : S), ⇑ρ₁₂ xi • ⇑σ₁₂ yj • ⇑(⇑B (⇑B₁ i)) (⇑B₂ j))) = ⇑(⇑B x) y
{x y : ℝ} (h : x < y) : ∃ (r : ℝ), Irrational r ∧ x < r ∧ r < y
{α : Type u} [CommSemiring α] {P P' : α} {ps ps' : ℕ} : P = P' → ps = ps' → P ^ ps = P' ^ ps'
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] [Finite_dimensional F E] : [IsGalois F E, intermediate_Field.fixed_Field ⊤ = ⊥, Fintype.Card (E ≃ₐ[F] E) = Finite_dimensional.finrank F E, ∃ (P : Polynomial F), P.IsSeparable ∧ Polynomial._splitting_Field F E P].tfae
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {F : E → F} {S : set E} {x : E} (hF : ContDiff_within_at ℝ 1 F S x) (hs : Convex ℝ S) : ∃ (K : Nnreal) (t : set E) (h : t ∈ nhds_within x S), LipschitzOnWith K F t
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [BaireSpace α] [Encodable β] {F : β → set α} (ho : ∀ (S : β), _Gδ (F S)) (hD : ∀ (S : β), Dense (F S)) : Dense (⋂ (S : β), F S)
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] [Nonempty v] : ∃ (v : v), G.max_degree = G.degree v
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F F' : x ⟶ Y} [CategoryTheory.Limits.HasImage F] [CategoryTheory.Limits.HasImage F'] [CategoryTheory.Limits.HasEqualizers C] (h : F = F') : CategoryTheory.Limits.imageι F = (CategoryTheory.Limits.image.Eq_to_iso h).hom ≫ CategoryTheory.Limits.imageι F'
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {n : WithTop ℕ} (h : ContDiff_on 𝕜 n F S) (hn : 1 ≤ n) : DifferentiableOn 𝕜 F S
(P : ℕ) [Fact (Nat.Prime P)] (hp : P ≠ 2) (A : ℤ) : ↑({x : Zmod P | x ^ 2 = ↑A}.to_Finset.Card) = Zmod.legendre_Sym P A + 1
{C : Type u₁} [CategoryTheory.Category C] {B : C} {x Y : CategoryTheory.Subobject B} (F : ↑x ≅ ↑Y) (W : F.hom ≫ Y.arrow = x.arrow) : x = Y
{α : Type u_1} [cancel_CommMonoid_with_Zero α] [Unique_factorization_Monoid α] [normalization_Monoid α] [DecidableEq α] {A B : α} (ha : A ≠ 0) (hb : B ≠ 0) : factorization (A * B) = factorization A + factorization B
{α : Type u} [Preorder α] {A : α} : A ≤ A
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] [TopologicalSpace δ] {e₁ : α → β} {e₂ : γ → δ} (de₁ : Dense_Embedding e₁) (de₂ : Dense_Embedding e₂) : Dense_Embedding (λ (P : α × γ), (e₁ P.fst, e₂ P.Snd))
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {A B : α} (h : A < B) (S : set α) : [S ∈ nhds_within B (set.Iic B), S ∈ nhds_within B (set.icc A B), S ∈ nhds_within B (set.ioc A B), ∃ (l : α) (h : l ∈ set.Ico A B), set.ioc l B ⊆ S, ∃ (l : α) (h : l ∈ set.Iio B), set.ioc l B ⊆ S].tfae
{α : Type u_1} {S : Finset α} {F : α → Ennreal} (hF : ∀ (A : α), A ∈ S → F A ≠ ⊤) : (S.Sum (λ (A : α), F A)).to_Real = S.Sum (λ (A : α), (F A).to_Real)
{α : Type u} {β : Type v} [TopologicalSpace α] [PseudoMetricSpace β] {F g : bounded_Continuous_Function α β} {C : ℝ} (C0 : 0 ≤ C) : HasDist.dist F g ≤ C ↔ ∀ (x : α), HasDist.dist (⇑F x) (⇑g x) ≤ C
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : ↑(affine_Span k S).Nonempty ↔ S.Nonempty
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (g : C(β, γ)) : Continuous g.Comp
(P L : Type u) [HasMem P L] [Configuration.HasPoints P L] [Fintype P] [Fintype L] : Fintype.Card L ≤ Fintype.Card P
{R : Type u_1} {A : R} [Monoid R] {n : ℕ} (n0 : 0 < n) : IsLeftRegular (A ^ n) ↔ IsLeftRegular A
{K : Type u_1} {n : ℕ} {S : Seq (GeneralizedContinuedFraction.Pair K)} [DivisionRing K] : (GeneralizedContinuedFraction.squash_Seq S (n + 1)).tail = GeneralizedContinuedFraction.squash_Seq S.tail n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.NonPreadditiveAbelian C] {x Y : C} (F : x ⟶ Y) : CategoryTheory.NonPreadditiveAbelian.σ ≫ F = CategoryTheory.Limits.Prod.Map F F ≫ CategoryTheory.NonPreadditiveAbelian.σ
{R : Type u_1} {m : Type u_2} [AddZeroClass R] [AddZeroClass m] {P : triv_sq_Zero_ext R m → Prop} (h : ∀ (r : R) (m : m), P (triv_sq_Zero_ext.inl_ r + triv_sq_Zero_ext.inr_ m)) (x : triv_sq_Zero_ext R m) : P x
{ι : Type u_1} {R : Type u_2} [CommRing R] [IsDomain R] [_principal_Ideal_Ring R] [Fintype ι] {O : Type u_3} [AddCommGroup O] [module R O] (m N : Submodule R O) (B'm : Basis ι R ↥m) (N_IsBot : N ≠ ⊥) (N_LE_m : N ≤ m) : ∃ (y : O) (h : y ∈ m) (A : R) (hay : A • y ∈ N) (m' : Submodule R O) (h : m' ≤ m) (N' : Submodule R O) (h : N' ≤ N) (N'_LE_m' : N' ≤ m') (y_IsOrtho_m' : ∀ (C : R) (z : O), z ∈ m' → C • y + z = 0 → C = 0) (ay_IsOrtho_N' : ∀ (C : R) (z : O), z ∈ N' → C • A • y + z = 0 → C = 0), ∀ (n' : ℕ) (bN' : Basis (Fin n') R ↥N'), ∃ (bN : Basis (Fin (n' + 1)) R ↥N), ∀ (m' : ℕ) (hn'm' : n' ≤ m') (bM' : Basis (Fin m') R ↥m'), ∃ (hnm : n' + 1 ≤ m' + 1) (bM : Basis (Fin (m' + 1)) R ↥m), ∀ (as : Fin n' → R), (∀ (i : Fin n'), ↑(⇑bN' i) = as i • ↑(⇑bM' (⇑(Fin.cast_LE hn'm') i))) → (∃ (as' : Fin (n' + 1) → R), ∀ (i : Fin (n' + 1)), ↑(⇑bN i) = as' i • ↑(⇑bM (⇑(Fin.cast_LE hnm) i)))
{G : Type u_1} [AddGroup G] (K : Add_Subgroup G) : Add_Subgroup.Closure ↑K = K
{E : ℕ → Type u_1} [Π (n : ℕ), TopologicalSpace (E n)] [∀ (n : ℕ), DiscreteTopology (E n)] {S : set (Π (n : ℕ), E n)} (hs : IsClosed S) (hne : S.Nonempty) : ∃ (F : (Π (n : ℕ), E n) → Π (n : ℕ), E n), (∀ (x : Π (n : ℕ), E n), x ∈ S → F x = x) ∧ set.Range F = S ∧ LipschitzWith 1 F
{α : Type u} {β : Type v} (e : α ≃ β) [Nontrivial β] : Nontrivial α
{α : Type u_1} [MeasurableSpace α] {m₁ m₂ m₃ : MeasureTheory.OuterMeasure α} {Op : Ennreal → Ennreal → Ennreal} (h : ∀ (S : set α), ⇑m₁ S = Op (⇑m₂ S) (⇑m₃ S)) (S : set α) : ⇑(m₁.trim) S = Op (⇑(m₂.trim) S) (⇑(m₃.trim) S)
{α : Type u} [AddCommGroup α] [has_LE α] [CovariantClass α α has_Add.Add has_LE.LE] {A B C : α} : A ≤ B + C → A - B ≤ C
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [Finite_dimensional 𝕜 E] [Finite_dimensional 𝕜 F] {ι₁ : Type u_4} {ι₂ : Type u_5} (B₁ : Basis ι₁ 𝕜 E) (B₂ : Basis ι₂ 𝕜 F) (A : E →ₗ[𝕜] F) (B : F →ₗ[𝕜] E) : A = ⇑LinearMap.Adjoint B ↔ ∀ (i₁ : ι₁) (i₂ : ι₂), HasInner.inner (⇑A (⇑B₁ i₁)) (⇑B₂ i₂) = HasInner.inner (⇑B₁ i₁) (⇑B (⇑B₂ i₂))
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {ι : Type u_3} {t : Finset ι} {F : ι → L} (h : ∀ (C : ι), C ∈ t → F C ∈ S) : t.Prod (λ (i : ι), F i) ∈ S
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {F : ℂ → E} {C : ℂ} (hD : ∀ᶠ (z : ℂ) in nhds_within C {C}ᶜ, Differentiable_at ℂ F z) (hb : Filter._bounded_under has_LE.LE (nhds_within C {C}ᶜ) (λ (z : ℂ), ∥F z - F C∥)) : Filter.Tendsto F (nhds_within C {C}ᶜ) (nhds (lim (nhds_within C {C}ᶜ) F))
{R : Type u_1} [CommSemiring R] {A : Type u} [TopologicalSpace A] [Semiring A] [Algebra R A] [topological_Semiring A] (S : Subalgebra R A) {B : Type u_2} [TopologicalSpace B] [Ring B] [topological_Ring B] [Algebra R B] (F : B →ₐ[R] A) (F' : B ≃ₜ A) (W : ⇑F = ⇑F') : S.topological_Closure.comap' F = (S.comap' F).topological_Closure
{α : Type u_1} {C : Cycle α → Prop} (S : Cycle α) (h0 : C Cycle.Nil) (HI : ∀ (A : α) (l : List α), C ↑l → C ↑(A :: l)) : C S
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x : v} (hx : x ≠ 0) (θ : Real.Angle) : ⇑(hb.rotation θ) x = x ↔ θ = 0
{x y : ℝ} : Irrational (x + y) → Irrational x ∨ Irrational y
{x : Type u_2} [EmetricSpace x] [TopologicalSpace.SecondCountableTopology x] {S : set x} {r : Ennreal} (h : r < dimH S) : ∃ (x : x) (h : x ∈ S), ∀ (t : set x), t ∈ nhds_within x S → r < dimH t
{A : Type u_1} [CommRing A] [Algebra ℚ A] (n : ℕ) : (Finset.Range n).Sum (λ (k : ℕ), PowerSeries.Exp A ^ k) = PowerSeries.Mk (λ (P : ℕ), (Finset.Range n).Sum (λ (k : ℕ), ↑k ^ P * ⇑(Algebra_Map ℚ A) (↑(P.factorial))⁻¹))
{G : Type u_1} [CommMonoid G] : Monoid._torsion ↥(CommMonoid.torsion G)
{α : Type u} [PseudoEmetricSpace α] {x : α} {S : set α} {r : Ennreal} : Emetric.Inf_edist x S < r ↔ ∃ (y : α) (h : y ∈ S), HasEdist.edist x y < r
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [nondiscrete_NormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (F : Continuous_MultilinearMap 𝕜 E G) (m₁ m₂ : Π (i : ι), E i) : ∥⇑F m₁ - ⇑F m₂∥ ≤ ∥F∥ * ↑(Fintype.Card ι) * LinearOrder.max ∥m₁∥ ∥m₂∥ ^ (Fintype.Card ι - 1) * ∥m₁ - m₂∥
{F₁ F₂ : Circle_deg1_Lift} (h₁ : Function.Bijective ⇑F₁) (h₂ : Function.Bijective ⇑F₂) (h : F₁.TranslationNumber = F₂.TranslationNumber) : ∃ (F : Circle_deg1_Lift), Function.Semiconj ⇑F ⇑F₁ ⇑F₂
{x : Type u} [Lattice x] [jordan_holder_Lattice x] (S₁ S₂ : Composition_series x) (hb : S₁.IsBot = S₂.IsBot) (ht : S₁.top = S₂.top) : S₁.Equivalent S₂
{α : Type u_1} [CompleteLattice α] {S : set α} {B : α} (_x : ∀ (A : α), A ∈ S → A ≤ B) (h : ∀ (W : α), W < B → (∃ (A : α) (h : A ∈ S), W < A)) : HasSup.Sup S = B
{K : Type u_1} [Field K] [Fintype K] (i : ℕ) (h : i < Fintype.Card K - 1) : Finset.Univ.Sum (λ (x : K), x ^ i) = 0
{R : Type u_1} {m : Type u_2} {m₂ : Type u_3} [Ring R] [AddCommGroup m] [AddCommGroup m₂] [module R m] [module R m₂] (F : m ≃ₗ[R] m₂) : Finite_dimensional.finrank R m = Finite_dimensional.finrank R m₂
{R : Type u} {S : Type v} [Semiring R] [AddCommMonoid S] (P : Polynomial R) {F : ℕ → R → S} (h : ∀ (n : ℕ), F n 0 = 0) (n : ℕ) (W : P.Nat_degree < n) : P.Sum F = (Finset.Range n).Sum (λ (A : ℕ), F A (P.Coeff A))
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] {K : Type u_2} [Field K] [Algebra R K] [_fraction_Ring R K] (v : IsDedekindDomain.height_One_Spectrum R) {r : R} {S : ↥(non_Zero_divisors R)} : ⇑(v.Valuation) (IsLocalization.Mk' K r S) = ⇑(v.Int_Valuation) r / ⇑(v.Int_Valuation) ↑S
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) (C : Nnreal) {r : Nnreal} (h : ∀ (n : ℕ), ∥P n∥₊ * r ^ n ≤ C) : ↑r ≤ P.radius
{α : Type u_1} [Linear_ordered_Field α] [Archimedean α] {x y : α} (hx : 0 < x) (hy : 1 < y) : ∃ (n : ℤ), x ∈ set.ioc (y ^ n) (y ^ (n + 1))
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {F : m →* N} (h : ∀ (y : ↥S), IsUnit (⇑F ↑y)) (y : ↥S) (W z : N) : z = W * ↑(⇑(IsUnit.Lift_Right (F.Restrict S) h) y)⁻¹ ↔ z * ⇑F ↑y = W
{α : Type u} {β : Type v} [AddZeroClass α] [AddZeroClass β] {F : α → β} (hF : _AddMonoid_hom F) {γ : Type u_1} [AddZeroClass γ] {g : β → γ} (hg : _AddMonoid_hom g) : _AddMonoid_hom (g ∘ F)
(α : Type u_1) [CompleteLattice α] : CompleteLattice._Sup_Finite_IsCompact α → WellFounded Gt
{R : Type u_1} [Mul_Zero_class R] [nR : Nontrivial R] : ¬IsRightRegular 0
{α : Type u} [TopologicalSpace α] {S : set α} (hs : IsCompact S) {P : set α → Prop} (hE : P ∅) (hmono : ∀ ⦃S t : set α⦄, S ⊆ t → P t → P S) (hunion : ∀ ⦃S t : set α⦄, P S → P t → P (S ∪ t)) (hnhds : ∀ (x : α), x ∈ S → (∃ (t : set α) (h : t ∈ nhds_within x S), P t)) : P S
{α : Type u} {β : Type v} [Group α] [Group β] {F : α → β} (hF : _Group_hom F) (A : α) : F A⁻¹ = (F A)⁻¹
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P ⟶ q) (A B : CategoryTheory.Over P) : A ≈ B → CategoryTheory.Abelian.App F A ≈ CategoryTheory.Abelian.App F B
{α : Type u_1} {β : Type u_3} [MeasurableSpace α] [MeasurableSpace β] : MeasurableSpace.generate_from (set.image2 has_set_Prod.Prod {S : set α | Measurable_set S} {t : set β | Measurable_set t}) = Prod.MeasurableSpace
{𝕜 : Type u_1} {E : Type u_2} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {P₁ P₂ : FormalMultilinearSeries 𝕜 𝕜 E} {F : 𝕜 → E} {r₁ r₂ : Ennreal} {x : 𝕜} (h₁ : HasFpowerSeriesOnBall F P₁ x r₁) (h₂ : HasFpowerSeriesOnBall F P₂ x r₂) : HasFpowerSeriesOnBall F P₁ x r₂
{R : Type u} [Semiring R] {P : Polynomial R} {n : ℕ} : P.Nat_degree ≤ n → P.degree ≤ ↑n
{α : Type u} {β : Type v} [DecidableEq β] [Fintype α] [Fintype β] (F : α → β) {n : ℕ} [Nonempty β] (hn : Fintype.Card α ≤ Fintype.Card β * n) : ∃ (y : β), (Finset.Filter (λ (x : α), F x = y) Finset.Univ).Card ≤ n
{x : top} {t : ↥x → Type v} (P : top.LocalPredicate t) : (top.subpresheaf_to_Types P.to_prelocal_predicate)._sheaf
{𝕜 : Type u_2} [_R_or_C 𝕜] {E : Type u_3} [InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {S : set E} (hs : Orthonormal 𝕜 Coe) : ∃ (W : set E) (B : hilbert_Basis ↥W 𝕜 E), S ⊆ W ∧ ⇑B = Coe
{𝕜 : Type u_1} [_R_or_C 𝕜] {F : Type u_2} [semi_NormedGroup F] [NormedSpace 𝕜 F] (P : Subspace 𝕜 F) (F : ↥P →L[𝕜] 𝕜) : ∃ (g : F →L[𝕜] 𝕜), (∀ (x : ↥P), ⇑g ↑x = ⇑F x) ∧ ∥g∥ = ∥F∥
{C : Type u₁} [CategoryTheory.Category C] {x₁₁ x₁₂ x₁₃ x₂₁ x₂₂ x₂₃ : C} {h₁₁ : x₁₁ ⟶ x₁₂} {h₁₂ : x₁₂ ⟶ x₁₃} {h₂₁ : x₂₁ ⟶ x₂₂} {h₂₂ : x₂₂ ⟶ x₂₃} {v₁₁ : x₁₁ ⟶ x₂₁} {v₁₂ : x₁₂ ⟶ x₂₂} {v₁₃ : x₁₃ ⟶ x₂₃} (S : CategoryTheory.IsPushout h₁₁ v₁₁ v₁₂ h₂₁) (t : CategoryTheory.IsPushout h₁₂ v₁₂ v₁₃ h₂₂) : CategoryTheory.IsPushout (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {F : α → β → γ} {tas : set (TopologicalSpace α)} {tbs : set (TopologicalSpace β)} {ta : TopologicalSpace α} {tb : TopologicalSpace β} {Tc : TopologicalSpace γ} (ha : ta ∈ tas) (hb : tb ∈ tbs) (hF : Continuous (λ (P : α × β), F P.fst P.Snd)) : Continuous (λ (P : α × β), F P.fst P.Snd)
{m : Type u_1} [MulOneClass m] {ι : sort u_2} (S : ι → Submonoid m) {C : m → Prop} {x : m} (hx : x ∈ ⨆ (i : ι), S i) (hp : ∀ (i : ι) (x : m), x ∈ S i → C x) (h1 : C 1) (HMul : ∀ (x y : m), C x → C y → C (x * y)) : C x
{G : Type u} [Group G] [Fintype G] {P : ℕ} [hp : Fact (Nat.Prime P)] (P : Sylow P G) : Fintype.Card ↥P = P ^ ⇑((Fintype.Card G).factorization) P
(n : ℕ) : HasDerivAt (Exp_Neg_Inv_glue.F_aux n) 0 0
{α : Type u} [non_unital_non_assoc_Ring α] {A B C D e : α} : A * e + C = B * e + D ↔ (A - B) * e + C = D
{F : Ordinal → Ordinal} (h : Ordinal._Normal F) : set.Unbounded has_LT.LT (Function.FixedPoints F)
{α : Type u_1} [MeasurableSpace α] {ι : Type u_2} {F : ι → α → Nnreal} {g : α → Nnreal} (u : Filter ι) [u.Ne_IsBot] [u._countably_generated] (hF : ∀ (i : ι), Measurable (F i)) (lim : Filter.Tendsto F u (nhds g)) : Measurable g
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] {F : α → β} {S : set α} {A : α} (h_Mono : StrictMono_on F S) (hs : S ∈ nhds A) (hfs_l : ∀ (B : β), B < F A → (∃ (C : α) (h : C ∈ S), F C ∈ set.Ico B (F A))) (hfs_r : ∀ (B : β), B > F A → (∃ (C : α) (h : C ∈ S), F C ∈ set.ioc (F A) B)) : Continuous_at F A
{x y : Pgame} (h : x < y) : x.lf y
{α : Type u_1} {r : α → α → Prop} (h : ∀ (C : set α), IsChain r C → (∃ (ub : α), ∀ (A : α), A ∈ C → r A ub)) (Trans : ∀ {A B C : α}, r A B → r B C → r A C) : ∃ (m : α), ∀ (A : α), r m A → r A m
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] [t2_Space α] {S : set β} {F g : β → α} (h : set.Eq_on F g S) (hF : Continuous F) (hg : Continuous g) : set.Eq_on F g (Closure S)
{α : Type u} [PseudoEmetricSpace α] {x y : α} {S : set α} : Emetric.Inf_edist x S ≤ Emetric.Inf_edist y S + HasEdist.edist x y
{m : Type u_1} [AddGroup m] (C : Add_Con m) {W x : m} : ⇑C W x → ⇑C (-W) (-x)
{R : Type u_1} {A : R} [Monoid R] (n : ℕ) (rra : IsRightRegular A) : IsRightRegular (A ^ n)
{E : Type u_2} {𝕜 : Type u_3} [Linear_ordered_Field 𝕜] [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul 𝕜 E] {S : set E} (hs : Convex 𝕜 S) : Convex 𝕜 (Interior S)
{β : Type v} [PseudoEmetricSpace β] {α : Type u} [EmetricSpace α] {F : α → β} (h : Isometry F) : Function.Injective F
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) : hb.oangle (-x) y = hb.oangle x (-y)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {S : set (E × F)} : ContDiff_on 𝕜 n Prod.Snd S
{α : Type u} [TopologicalSpace α] {S : set α} {x : α} : x ∈ Closure S ↔ ∃ (u : Ultrafilter α), S ∈ u ∧ ↑u ≤ nhds x
 : Filter.Tendsto (λ (k : ℕ), (Finset.Range k).Sum (λ (i : ℕ), (-1) ^ i / (2 * ↑i + 1))) Filter.at_top (nhds (Real.Pi / 4))
{h : Type u_1} [TopologicalSpace h] {x : h} : ChartedSpace.chart_at h x = LocalHomeomorph.refl h
{R : Type u_1} [CommRing R] {x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : R} : (x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2) * (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2) = (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄) ^ 2 + (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃) ^ 2 + (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂) ^ 2 + (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁) ^ 2
{R : Type u_1} {A B : R} [AddMonoid R] (h : B + A = 0) : _Add_Left_regular A
{G : Type u_1} [AddGroup G] (tG : AddMonoid._torsion G) (bounded : (set.Range (λ (g : G), Add_order_of g)).Finite) : AddMonoid.exponent_exists G
{α : Type u} [Preorder α] {S : set α} {A : α} (h : IsLeast S A) : BddBelow S
(P : ℕ) [Fact (Nat.Prime P)] (R : Type u₁) [CommSemiring R] [Char_P R P] : PerfectionMap P (Perfection.Coeff R P 0)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Zero_object C] {x : C} (Y : CategoryTheory.Subobject x) : CategoryTheory.Simple ↑Y ↔ IsAtom Y
{ι : Type u_1} {E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {C : E} {lb lb' : Filter ℝ} {LT : Filter ι} {A B : ℝ} {u v : ι → ℝ} [IntervalIntegral.FTC_Filter B lb lb'] (hab : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F lb' MeasureTheory.MeasureSpace.Volume) (hF : Filter.Tendsto F (lb' ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) (hu : Filter.Tendsto u LT lb) (hv : Filter.Tendsto v LT lb) : (λ (t : ι), ((∫ (x : ℝ) in A..v t, F x) - ∫ (x : ℝ) in A..u t, F x) - (v t - u t) • C) =o[LT] (v - u)
{α : Type u} [canonically_ordered_CommSemiring α] [Nontrivial α] : 0 < 1
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace 𝕜] (S : Submodule 𝕜 E) [Finite_dimensional 𝕜 ↥S] : IsClosed ↑S
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (θ : Real.Angle) : (hb.rotation θ).Symm = hb.rotation (-θ)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : set P} (ho : EuclideanGeometry.OrthocentricSystem S) {P : Fin 3 → P} (hps : set.Range P ⊆ S) (hpi : Function.Injective P) : affine_Span ℝ (set.Range P) = affine_Span ℝ S
{G : Type u_2} [AddGroup G] {A B : G} : A = B → A - B = 0
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v W : ι → E} (hv : Orthonormal 𝕜 v) (hw : ∀ (i : ι), W i = v i ∨ W i = -v i) : Orthonormal 𝕜 W
 : Function.Bijective Real.sinh
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {A B : α} [IsAntisymm α HasSubset.Subset] (h₁ : A ≠ B) (h₂ : A ⊆ B) : A ⊂ B
(P : ℕ) [Fact (Nat.Prime P)] {A : Zmod P} (ha : A ≠ 0) : IsSquare A ↔ A ^ (P / 2) = 1
{γ : Type W} [SemilatticeSup γ] (A : γ) {S : set γ} : BddAbove (HasInsert.Insert A S) ↔ BddAbove S
{α : Type u_2} [DecidableEq α] {S : Finset α} {B : Finset (Finset α)} {n : ℕ} (h : ∀ (A : α), A ∈ S → n ≤ (Finset.Filter (HasMem.Mem A) B).Card) : S.Card * n ≤ B.Sum (λ (t : Finset α), (S ∩ t).Card)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] {P : P} (hp : P ∈ S) {v : v} (hv : v ∈ (S.direction)ᗮ) : ⇑(EuclideanGeometry.reflection S) (v +ᵥ P) = -v +ᵥ P
{R : Type u_1} {K : Type u_2} [Ring R] [Field K] (F : R →+* K) (hF : Function.Surjective ⇑F) : F.Ker.IsMaximal
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {v₂ : Type v'} [AddCommGroup v₂] [module K v₂] [h : Finite_dimensional K v] (F : v →ₗ[K] v₂) (hF : F.Range = ⊤) : Finite_dimensional K v₂
{v₁ : Type u_2} {v₂ : Type u_3} [semi_NormedGroup v₁] [semi_NormedGroup v₂] (F : v₁ →+ v₂) {C : ℝ} (hC : 0 ≤ C) (h : ∀ (x : v₁), ∥⇑F x∥ ≤ C * ∥x∥) : ∥F.Mk_NormedGroup_hom C h∥ ≤ C
{𝕜 : Type u_3} {E : Type u_4} [NormedField 𝕜] [AddCommGroup E] [module 𝕜 E] (P : Seminorm 𝕜 E) {r : ℝ} (hr : 0 < r) : Absorbent 𝕜 (P.ball 0 r)
{R : Type u₁} [Monoid R] [has_Distrib_Neg R] : (-1) ^ 2 = 1
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} (hx : ∥x∥ = 1) (hy : ∥y∥ = 1) : HasInner.inner x y = 1 ↔ x = y
{α : Type u} [Preorder α] {A B C : α} : B ≤ C → A < B → A < C
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) {r : ℝ} (hr : 0 < r) : hb.oangle x (r • y) = hb.oangle x y
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {k : S.Localization_Map P} (z : N) : ⇑(k.Lift _) (⇑(F.Lift _) z) = z
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} [TopologicalSpace β] [Preorder ι] {u : ι → α → β} {F : MeasureTheory.Filtration ι m} [TopologicalSpace ι] [TopologicalSpace.metrizable_Space ι] [MeasurableSpace ι] [TopologicalSpace.SecondCountableTopology ι] [Opens_MeasurableSpace ι] [TopologicalSpace.metrizable_Space β] (h : MeasureTheory.Adapted F u) (hu_Cont : ∀ (x : α), Continuous (λ (i : ι), u i x)) : MeasureTheory.prog_Measurable F u
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace ℝ P) [Nonempty ↥S] [CompleteSpace ↥(S.direction)] (P : P) : ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P) ∈ AffineSubspace.Mk' P (S.direction)ᗮ
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : LocalHomeomorph α β) {B : β} (hb : B ∈ e.to_local_Equiv.Target) {F : β → E} {g : β → F} {C : ℝ} : Asymptotics._O_with C (nhds B) F g ↔ Asymptotics._O_with C (nhds (⇑(e.Symm) B)) (F ∘ ⇑e) (g ∘ ⇑e)
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y : m} {r : R} (h : SameRay R x y) (hr : 0 ≤ r) : SameRay R x (r • y)
{G : Type u_1} [AddGroup G] {k : set G} {P : G → Prop} {x : G} (h : x ∈ Add_Subgroup.Closure k) (Hk : ∀ (x : G), x ∈ k → P x) (Hk_Inv : ∀ (x : G), x ∈ k → P (-x)) (h1 : P 0) (HMul : ∀ (x y : G), P x → P y → P (x + y)) : P x
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) (m : Multiset L) : (∀ (A : L), A ∈ m → A ∈ S) → m.Sum ∈ S
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {S : set 𝕜} {F : 𝕜 → 𝕜} : Convex_on 𝕜 S F ↔ Convex 𝕜 S ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ S → z ∈ S → x < y → y < z → (F y - F x) / (y - x) ≤ (F z - F y) / (z - y)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x : v} (hx : x ≠ 0) (θ : Real.Angle) : hb.oangle x (⇑(hb.rotation θ) x) = θ
{α : Type u} [TopologicalSpace α] {S t : set α} (hs : IsPreconnected S) (ht : IsClopen t) : Disjoint S t ∨ S ⊆ t
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {S : set E} {F : E → F} {n : WithTop ℕ} {P : E → FormalMultilinearSeries 𝕜 E F} (hF : HasFtaylorSeriesUpToOn n F P S) (g : G →L[𝕜] E) : HasFtaylorSeriesUpToOn n (F ∘ ⇑g) (λ (x : G) (k : ℕ), (P (⇑g x) k).Comp_Continuous_Linear_Map (λ (_x : Fin k), g)) (⇑g ⁻¹' S)
{R : Type u_1} [CommRing R] {m : Submonoid R} {S : Type u_2} [CommRing S] [Algebra R S] (Rₘ : Type u_4) (Sₘ : Type u_5) [CommRing Rₘ] [CommRing Sₘ] [Algebra R Rₘ] [IsLocalization m Rₘ] [Algebra S Sₘ] [IsLocalization (Algebra.Algebra_Map_Submonoid S m) Sₘ] (hRS : Function.Injective ⇑(Algebra_Map R S)) (hM : Algebra.Algebra_Map_Submonoid S m ≤ non_Zero_divisors S) : Function.Injective ⇑(Algebra_Map Rₘ Sₘ)
{R : Type u_1} {m : Type u_2} [CommSemiring R] [AddCommMonoid m] [module R m] (S : Type u_3) [CommMonoid S] [Distrib_MulAction S m] [SmulCommClass S R m] : module._torsion' ↥(Submodule.torsion' R m S) S
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : E → ℝ} {A : E} {F' : E →L[ℝ] ℝ} {S : set E} (h : IsLocalMaxOn F S A) (hF : HasFderivWithinAt F F' S A) {y : E} (hy : y ∈ Pos_TangentConeAt S A) (hy' : -y ∈ Pos_TangentConeAt S A) : ⇑F' y = 0
{β : Type u} {α : Type v} {S : Finset α} {F : α → β} [CommMonoid β] (R : Setoid α) [Decidable_Rel Setoid.r] : S.Prod (λ (x : α), F x) = (Finset.image Quotient.Mk S).Prod (λ (xbar : Quotient R), (Finset.Filter (λ (y : α), ⟦y⟧ = xbar) S).Prod (λ (y : α), F y))
{m : Type u_1} [has_Mul m] {N : Type u_2} [has_Mul N] (F : m →ₙ* N) (hF : Function.Surjective ⇑F) : F.srange = ⊤
(F : ℝ → ℝ) {A B : ℝ} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hfI : F A = F B) : ∃ (C : ℝ) (h : C ∈ set.Ioo A B), deriv F C = 0
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Limits.HasBinaryProducts C
(n : ℕ) (R : Type u_1) [CommRing R] [IsDomain R] : Polynomial.cyclotomic' n R ≠ 0
{α : Type u} [Preorder α] {S t : set α} (h : BddAbove S) : BddAbove (S ∩ t)
{α : Type u_1} [UniformSpace α] (x : α) : nhds (x, x) ≤ Uniformity α
{α : Type u_2} {ι : Type u_5} [CommMonoid α] (t : Finset ι) (F : ι → set α) (A : α) : A ∈ t.Prod (λ (i : ι), F i) ↔ ∃ (g : ι → α) (hg : ∀ {i : ι}, i ∈ t → g i ∈ F i), t.Prod (λ (i : ι), g i) = A
{𝕜 : Type u_1} {A : Type u_2} [_R_or_C 𝕜] [NormedRing A] [normed_Algebra 𝕜 A] [CompleteSpace A] (A : A) {z : 𝕜} (hz : z ∈ Spectrum 𝕜 A) : Exp 𝕜 z ∈ Spectrum 𝕜 (Exp 𝕜 A)
(n : ℕ) : ↑n.Numeric
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {P : E → FormalMultilinearSeries 𝕜 E F} {n : ℕ} : HasFtaylorSeriesUpToOn (↑n + 1) F P S ↔ HasFtaylorSeriesUpToOn ↑n F P S ∧ (∀ (x : E), x ∈ S → HasFderivWithinAt (λ (y : E), P y n) (P x n.Succ).Curry_Left S x) ∧ Continuous_on (λ (x : E), P x (n + 1)) S
{n : WithTop ℕ} : ContDiff ℝ n Exp_Neg_Inv_glue
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) : o.oangle x y = θ ↔ y = (∥y∥ / ∥x∥) • ⇑(o.rotation θ) x
{α : Type u_1} {β : Type u_2} {F : α → β} {x y : α} : (Setoid.Ker F).Rel x y ↔ x ∈ F ⁻¹' {F y}
{P : ℕ} : padic_val_Int P 1 = 0
{S : Type u_2} [CommRing S] {K : Type u_4} {F : Type u_6} [Field K] [Field F] [Algebra K F] [Algebra K S] (pB : power_Basis K S) (hF : Polynomial.Splits (Algebra_Map K F) (minpoly K pB.gen)) : ⇑(Algebra_Map K F) (⇑(Algebra.norm K) pB.gen) = (Polynomial.Map (Algebra_Map K F) (minpoly K pB.gen)).roots.Prod
{A B : Ordinal} : {o : Ordinal | A ≤ B + o}.Nonempty
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {r : ℝ} (hr : 0 ≤ r) : r • metric.IsClosed_ball 0 1 = metric.IsClosed_ball 0 r
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] {P1 : P} (P2 : P) (r : ℝ) (hp : P1 ∈ S) : ⇑(EuclideanGeometry.Orthogonal_projection S) (r • (P2 -ᵥ ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P2)) +ᵥ P1) = ⟨P1, hp⟩
(k : Type u_1) {v1 : Type u_2} (P1 : Type u_3) [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] : ⇑(AffineMap.Id k P1) = Id
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] (k : ℕ) (h : ∀ (v : v), G.degree v ≤ k) : G.max_degree ≤ k
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e e' : LocalHomeomorph α β} (h : e ≈ e') : e.Symm ≈ e'.Symm
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (E1 E2 : intermediate_Field K L) (h1 : Finite_dimensional K ↥E1) (h2 : Finite_dimensional K ↥E2) : Finite_dimensional K ↥(E1 ⊔ E2)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (u : E) {v : E} (hv : v ∈ (Submodule.Span 𝕜 {u})ᗮ) : HasInner.inner v u = 0
(R : Type u_1) [Ring R] : Polynomial.cyclotomic 2 R = Polynomial.x + 1
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A B : α} (ha : A < 1) (hb : B ≤ 1) : A * B < 1
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommGroup β] [HasScalar 𝕜 E] [module 𝕜 β] {S : set E} {F : E → β} : ConcaveOn 𝕜 S (-F) ↔ Convex_on 𝕜 S F
(G : Type u_1) [AddCommGroup G] : AddCommMonoid.Add_torsion G = (Add_torsion G).to_Add_Submonoid
{α : Type u} [PseudoMetricSpace α] : Isometry Coe
{γ : Type u_3} [tγ : TopologicalSpace γ] [PolishSpace γ] [MeasurableSpace γ] [BorelSpace γ] {β : Type u_4} [tβ : TopologicalSpace β] [t2_Space β] [MeasurableSpace β] [BorelSpace β] {F : γ → β} (F_Cont : Continuous F) (F_inj : Function.Injective F) : Measurable_Embedding F
{R : Type u_1} [CommSemiring R] (m : Submonoid R) {S : Type u_2} [CommSemiring S] [Algebra R S] {P : Type u_3} [CommSemiring P] [IsLocalization m S] (j k : S → P) (hj1 : j 1 = 1) (hk1 : k 1 = 1) (hjm : ∀ (A B : S), j (A * B) = j A * j B) (hkm : ∀ (A B : S), k (A * B) = k A * k B) (h : ∀ (A : R), j (⇑(Algebra_Map R S) A) = k (⇑(Algebra_Map R S) A)) : j = k
{α : Type u} [TopologicalSpace α] {S : set (set α)} (K : Directed_on HasSubset.Subset S) (h : ∀ (S : set α), S ∈ S → IsPreconnected S) : IsPreconnected (⋃₀S)
{α : Type u_1} [Lattice α] [_modular_Lattice α] {β : Type u_2} {γ : Type u_3} [PartialOrder β] [Preorder γ] (h₁ : WellFounded has_LT.LT) (h₂ : WellFounded has_LT.LT) (K : α) (F₁ : β → α) (F₂ : α → β) (g₁ : γ → α) (g₂ : α → γ) (gci : GaloisCoinsertion F₁ F₂) (gi : GaloisInsertion g₂ g₁) (hF : ∀ (A : α), F₁ (F₂ A) = A ⊓ K) (hg : ∀ (A : α), g₁ (g₂ A) = A ⊔ K) : WellFounded has_LT.LT
{α : Type u_1} [PartialOrder α] [PredOrder α] {A : α} : IsMin A → Order.Pred A = A
{R : Type u} [CommSemiring R] (t : Multiset (Polynomial R)) : t.Prod.degree ≤ (Multiset.Map Polynomial.degree t).Sum
{m : Type u_1} [has_Add m] {C D : Add_Con m} : (∀ (x y : m), ⇑C x y ↔ ⇑D x y) ↔ C = D
(F : Type u) (K A : Type v) [Field F] [Field K] [AddCommGroup A] [Algebra F K] [module K A] [module F A] [IsScalarTower F K A] : module.rank F K * module.rank K A = module.rank F A
{m : Type u_1} [CommMonoid m] (F S : ℕ → m) (h0 : S 0 = 1) (h : ∀ (n : ℕ), S (n + 1) = S n * F n) (n : ℕ) : (Finset.Range n).Prod (λ (k : ℕ), F k) = S n
{α : Type u} {L₁ L₂ : List (α × Bool)} [DecidableEq α] (h : free_Group.Mk L₁ = free_Group.Mk L₂) : free_Group.reduce L₁ = free_Group.reduce L₂
{α : Type u} [PseudoEmetricSpace α] {P : α → Prop} (x y : Subtype P) : HasEdist.edist x y = HasEdist.edist ↑x ↑y
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] {A B : α} (hab : A ≠ B) : Closure (set.ioc A B) = set.icc A B
{n : ℕ} {P : Fin n → Prop} [Decidable_Pred P] : Fin.Find P = Option.None ↔ ∀ (i : Fin n), ¬P i
{A : Type u_2} {K : Type u_3} [CommRing A] [Field K] [IsDomain A] [IsDedekindDomain A] [Algebra A K] [_fraction_Ring A K] {J : Ideal A} (hJ : J ≠ ⊤) {ι : Type u_1} (S : Finset ι) (F : ι → K) {j : ι} (hjs : j ∈ S) (hjf : F j ≠ 0) : ∃ (A : K), (∀ (i : ι), i ∈ S → IsLocalization._integer A (A * F i)) ∧ ∃ (i : ι) (h : i ∈ S), A * F i ∉ ↑J
{α : Type u} {A B : α} [MulOneClass α] [has_Zero α] [Preorder α] [Zero_LT.Mul_Pos_Mono α] (ha : 1 ≤ A) (hb : 1 < B) (B0 : 0 < B) : 1 < A * B
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x : v} (hx : x ≠ 0) : o.oangle x (-x) = ↑Real.Pi
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_5} [NormedGroup E'] [NormedSpace 𝕜 E'] {n : WithTop ℕ} {F : E → E'} {x : E} : ContDiff_at 𝕜 n F x → Cont_mdiff_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n F x
{K : Type u_1} {n : ℕ} {g : GeneralizedContinuedFraction K} [DivisionRing K] (TerminatedAt_n : g.TerminatedAt n) : g.squash_gcf n = g
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} (P : ι → P) (i : ι) : Finset.centroid k {i} P = P i
{ι : Type u_1} {m : Type u_4} {N : Type u_5} [CommMonoid m] [ordered_CommMonoid N] (F : m → N) (h_One : F 1 = 1) (h_Mul : ∀ (x y : m), F (x * y) ≤ F x * F y) (S : Finset ι) (g : ι → m) : F (S.Prod (λ (i : ι), g i)) ≤ S.Prod (λ (i : ι), F (g i))
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type W} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace 𝕜] {F : E →ₗ[𝕜] F} (hF : F.Ker = ⊥) [Finite_dimensional 𝕜 E] : IsClosed_Embedding ⇑F
{α : Type u_1} {β : Type u_2} [LinearOrder α] [SuccOrder α] [Preorder β] {F : α → β} (hF : Monotone F) : Pairwise (Disjoint on λ (n : α), set.ioc (F n) (F (Order.Succ n)))
{n : ℕ} (P i : Fin n) : P.Pred_above (⇑((⇑Fin.cast_Succ P).Succ_above) i) = i
{F : Type u_8} {G : Type u_1} {h : Type u_2} [AddGroup G] [AddZeroClass h] [AddMonoid_hom_class F G h] (F : F) : Function.Injective ⇑F ↔ ∀ (A : G), ⇑F A = 0 ↔ A = 0
{α : Type u_1} {C : set (set α)} (h : ∀ (A : α), ∃! (B : set α) (h : B ∈ C), A ∈ B) {y : α} : {x : α | (Setoid.Mk_Classes C h).Rel x y} ∈ C
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] (Z : TopologicalFiberBundleCore ι B F) (i j : ι) : (Z.local_triv_as_local_Equiv i).Symm.Trans (Z.local_triv_as_local_Equiv j) ≈ (Z.triv_change i j).to_local_Equiv
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {C : ℝ} {F : ℂ → E} {z : ℂ} (hD : Diff_Cont_on_cl ℂ F {z : ℂ | 0 < z.re}) (hexp : ∃ (C : ℝ) (h : C < 2) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hre : Filter._bounded_under has_LE.LE Filter.at_top (λ (x : ℝ), ∥F ↑x∥)) (him : ∀ (x : ℝ), ∥F (↑x * Complex.i)∥ ≤ C) (hz : 0 ≤ z.re) : ∥F z∥ ≤ C
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [strict_Convex_Space ℝ E] {x y : E} {A B r : ℝ} (hx : ∥x∥ ≤ r) (hy : ∥y∥ ≤ r) (hne : x ≠ y) (ha : 0 < A) (hb : 0 < B) (hab : A + B = 1) : ∥A • x + B • y∥ < r
{m : Type u_1} [Monoid m] {x y : m} : y ∈ Submonoid.Closure {x} ↔ ∃ (n : ℕ), x ^ n = y
{α : Type u} [PseudoMetricSpace α] {S : set α} : 0 ≤ Metric.diam S
{G : Type u_1} [AddGroup G] [TopologicalSpace G] [topological_AddGroup G] {h : Add_Subgroup G} (h_1_Int : 0 ∈ Interior ↑h) : IsOpen ↑h
{α : Type u_1} [Bornology α] {S : set α} : Bornology._bounded S → BoundedSpace ↥S
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {P : P} {ps : set P} (h : P ∈ affine_Span k ps) : affine_Span k (HasInsert.Insert P ps) = affine_Span k ps
{R : Type u} [comm_Group R] [Star_Semigroup R] (x y : R) : HasStar.Star (x / y) = HasStar.Star x / HasStar.Star y
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] [NoZeroSmulDivisors R m] {v : m} (hv : v ≠ 0) {r : R} (hr : r ≠ 0) : SameRay R (r • v) v ↔ 0 < r
{R : Type u_1} {m : Type u_3} [Monoid_with_Zero R] [has_Zero m] [MulAction_with_Zero R m] [sM : Subsingleton m] : IsSmulRegular m 0
{F : Type} [CommSemiring F] {q : ℕ} {F g : Polynomial F} (hF : Polynomial._IsSeparable_contraction q F g) : ∃ (m : ℕ), g.Nat_degree * q ^ m = F.Nat_degree
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) {x : C} (S : CategoryTheory.Sieve x) : J₁.IsClosed S ↔ J₁.close S = S
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {x Y Z : C} (F : x ⟶ Y) (g : Y ⟶ Z) : CategoryTheory.Exact F g ↔ CategoryTheory.Limits.image_Subobject F = CategoryTheory.Limits.Kernel_Subobject g
{ι : Type u_2} {R : Type u_3} [DecidableEq ι] [AddMonoid ι] [CommSemiring R] : direct_Sum._internal (AddMonoid_Algebra.grade R)
{G : Type u_1} [AddGroup G] {N : Type u_3} [AddGroup N] (h : Add_Subgroup G) {F : G →+ N} (hF : Function.Bijective ⇑F) : Add_Subgroup.Map F h.Normalizer = (Add_Subgroup.Map F h).Normalizer
{α : Type u_2} [DecidableEq α] [has_Add α] {u : Finset α} {S t : set α} : ↑u ⊆ S + t → (∃ (S' t' : Finset α), ↑S' ⊆ S ∧ ↑t' ⊆ t ∧ u ⊆ S' + t')
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.NormalMonoCategory C] {x Y : C} (F : x ⟶ Y) (Z : C) (l : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.Cokernel_cofork.ofπ 0 _)) : CategoryTheory.Epi F
{B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] : IsTrivialTopologicalFiberBundle F Prod.Snd
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {A : α} {S : set α} (F : α → m) (h : A ∉ S) (hs : S.Finite) : finsum (λ (i : α), finsum (λ (h : i ∈ HasInsert.Insert A S), F i)) = F A + finsum (λ (i : α), finsum (λ (h : i ∈ S), F i))
(R : Type u) [Semiring R] [Nontrivial R] (P : ℕ) [hp : Char_P R P] [hq : ExpChar R 1] : P = 0
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : Rˣ) : (λ (t : R), Ring.Inverse (↑x + t) - ↑x⁻¹) =O[nhds 0] λ (t : R), ∥t∥
{m : Type u_1} [Monoid m] {x : m} : 1 ∈ Powers x
{α : Type u_3} {β : Type u_4} {γ : Type u_5} [AddCommMonoid α] {g : γ → β} (hg : Function.Injective g) {F : β → α} (hF : ∀ (x : β), x ∉ set.Range g → F x = 0) : Filter.Map (λ (S : Finset γ), S.Sum (λ (i : γ), F (g i))) Filter.at_top = Filter.Map (λ (S : Finset β), S.Sum (λ (i : β), F i)) Filter.at_top
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : HasDist.dist P3 P1 = HasDist.dist P3 P2) : EuclideanGeometry.angle P3 (midpoint ℝ P1 P2) P1 = Real.Pi / 2
{R : Type u_1} {E : Type u_2} {ι : Type u_4} [Linear_ordered_Field R] [AddCommGroup E] [module R E] {S : set E} {t : Finset ι} {W : ι → R} {z : ι → E} (hs : Convex R S) : (∀ (i : ι), i ∈ t → 0 ≤ W i) → 0 < t.Sum (λ (i : ι), W i) → (∀ (i : ι), i ∈ t → z i ∈ S) → t.Center_mass W z ∈ S
{R : Type u} {ι : Type u'} {m₁ : ι → Type v₁} {m₂ : Type v₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (m₁ i)] [AddCommMonoid m₂] [Π (i : ι), module R (m₁ i)] [module R m₂] {m₁' : ι → Type u_1} [Π (i : ι), AddCommMonoid (m₁' i)] [Π (i : ι), module R (m₁' i)] (F : Π (i : ι), m₁ i →ₗ[R] m₁' i) (hF : ∀ (i : ι), Function.Surjective ⇑(F i)) : Function.Injective (λ (g : MultilinearMap R m₁' m₂), g.Comp_Linear_Map F)
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] : ⊥.direction = ⊥
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : ∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * ⇑_R_or_C.re (HasInner.inner x y) + ∥y∥ ^ 2
(α : Type u) [PseudoEmetricSpace α] [SigmaCompactSpace α] : TopologicalSpace.SecondCountableTopology α
{𝕂 : Type u_1} [_R_or_C 𝕂] {x : 𝕂} : HasDerivAt (Exp 𝕂) (Exp 𝕂 x) x
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (ha : Continuous_at F A) : HasDerivAt (λ (u : ℝ), ∫ (x : ℝ) in u..B, F x) (-F A) A
(R : Type u) (L : Type v) (m : Type W) [CommRing R] [lie_Ring L] [lie_Algebra R L] [AddCommGroup m] [module R m] [lie_Ring_module L m] [lie_module R L m] {N : lie_Submodule R L m} (h₁ : N ≤ lie_module.max_triv_Submodule R L m) (h₂ : lie_module.IsNilpotent R L (m ⧸ N)) : lie_module.IsNilpotent R L m
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x : v} (hx : x ≠ 0) (θ : Real.Angle) : x = ⇑(hb.rotation θ) x ↔ θ = 0
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [AddCommMonoid α] [TopologicalSpace α] [has_Continuous_Add α] [RegularSpace α] {F : β × γ → α} {g : β → α} {A : α} (ha : has_Sum F A) (hF : ∀ (B : β), has_Sum (λ (C : γ), F (B, C)) (g B)) : has_Sum g A
{α : Type u} [Preorder α] {A B C : α} : B ≤ C → A ≤ B → A ≤ C
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] : CategoryTheory.Preadditive_coyoneda ⋙ (CategoryTheory.whiskering_Right C AddCommGroup (Type v)).obj (CategoryTheory.Forget AddCommGroup) = CategoryTheory.coyoneda
{α : Type u_1} (F : Poly α) : _Poly ⇑F
{α : Type u} {β : α → Type u} {κ : Cardinal} (hκ : Cardinal.Sum (λ (A : α), κ ^ Cardinal.Mk (β A)) ≤ κ) : Cardinal.Mk (W_Type β) ≤ κ
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasInitial C] : CategoryTheory.Limits.has_Zero_object C
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {F g : E → F} (hF : ContDiff 𝕜 n F) (hg : ContDiff 𝕜 n g) : ContDiff 𝕜 n (λ (x : E), F x + g x)
(P : ℕ) [hp : Fact (Nat.Prime P)] (A : Zmod P) (hap : A ≠ 0) : Multiset.Map (λ (x : ℕ), (A * ↑x).val_min_Abs.Nat_Abs) (Finset.Ico 1 (P / 2).Succ).val = Multiset.Map (λ (A : ℕ), A) (Finset.Ico 1 (P / 2).Succ).val
{α : Type u_1} [TopologicalSpace α] {𝕜 : Type u_5} [TopologicalSpace 𝕜] [Field 𝕜] [topological_Ring 𝕜] {S : Subalgebra 𝕜 C(α, 𝕜)} (h : S.separates_points) : ↑S.SeparatesPointsStrongly
{R : Type u_1} [CommRing R] (m : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] (N : Submonoid S) (t : Type u_4) [CommRing t] [Algebra R t] [Algebra S t] [IsScalarTower R S t] [IsLocalization m S] [IsLocalization N t] (h : ∀ (x : S), IsUnit x → x ∈ N) : IsLocalization (Submonoid.comap (Algebra_Map R S).to_Monoid_hom N) t
{τ : Type u_1} {α : Type u_2} [canonically_ordered_AddMonoid τ] {ϕ : τ → α → α} {S : set α} : IsFwInvariant ϕ S ↔ IsInvariant ϕ S
{α : Type u} [PseudoEmetricSpace α] {S : set α} : Emetric.Hausdorff_edist S S = 0
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [Finite_dimensional 𝕜 E] [Finite_dimensional 𝕜 F] (A : E →ₗ[𝕜] F) (B : F →ₗ[𝕜] E) : A = ⇑LinearMap.Adjoint B ↔ ∀ (x : E) (y : F), HasInner.inner (⇑A x) y = HasInner.inner x (⇑B y)
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] [Fintype α] [Fintype β] (F : α → β) {W : α → m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (hb : Finset.Univ.Sum (λ (x : α), W x) < Fintype.Card β • B) : ∃ (y : β), (Finset.Filter (λ (x : α), F x = y) Finset.Univ).Sum (λ (x : α), W x) < B
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y z : v} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = ↑Real.Pi
{R : Type u_4} {S : Type u_5} [has_Mul R] [has_Add R] [has_Mul S] [has_Add S] (e : R ≃+* S) (x y : R) : ⇑e (x + y) = ⇑e x + ⇑e y
{m : Type u_3} {F : Type u_8} {G : Type u_1} [AddGroup G] [AddMonoid m] [AddMonoid_hom_class F G m] {F g : F} {x : G} (h : ⇑F x = ⇑g x) : ⇑F (-x) = ⇑g (-x)
{α : Type u_1} {β : Type u_2} [UniformSpace α] {l : Filter β} {F₁ F₂ F₃ : β → α} (h₁₂ : Filter.Tendsto (λ (x : β), (F₁ x, F₂ x)) l (Uniformity α)) (h₂₃ : Filter.Tendsto (λ (x : β), (F₂ x, F₃ x)) l (Uniformity α)) : Filter.Tendsto (λ (x : β), (F₁ x, F₃ x)) l (Uniformity α)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x Y : C} [CategoryTheory.Limits.HasBinaryBiproduct x Y] : CategoryTheory.Limits.biprod.fst ≫ CategoryTheory.Limits.biprod.inl_ + CategoryTheory.Limits.biprod.Snd ≫ CategoryTheory.Limits.biprod.inr_ = 𝟙 (x ⊞ Y)
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] [Finite_dimensional F E] (h : ∀ (x : E), Finite_dimensional.finrank F ↥F⟮x⟯ ≤ 1) : ⊥ = ⊤
(n : ℕ) : ∃ (P : ℕ), n ≤ P ∧ Nat.Prime P
{α : Type u} [Mul_Zero_class α] [has_Distrib_Neg α] : -0 = 0
{R : Type u} {A : Type W} [CommSemiring R] [Semiring A] [Algebra R A] (r : R) (x : A) : ⇑(Algebra_Map R A) r * x = x * ⇑(Algebra_Map R A) r
{α : Type u_1} {C : set (set α)} (hc : Setoid._Partition C) {S : set α} (h : S ∈ C) : S.Nonempty
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type W} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace 𝕜] {ι : Type u_1} [Fintype ι] (v : Basis ι 𝕜 E) : ∃ (C : ℝ) (h : C > 0), ∀ {u : E →L[𝕜] F} {m : ℝ}, 0 ≤ m → (∀ (i : ι), ∥⇑u (⇑v i)∥ ≤ m) → ∥u∥ ≤ C * m
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] [Nonempty v] : G.max_degree < Fintype.Card v
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {F : J ⥤ C} {x : C} (h : CategoryTheory.yoneda.obj x ⋙ CategoryTheory.ulift_Functor ≅ F.cones) {Y : C} (F : Y ⟶ x) : CategoryTheory.Limits.IsLimit.of_Nat_iso.cone_of_hom h F = (CategoryTheory.Limits.IsLimit.of_Nat_iso.Limit_cone h).extend F
{α : Type u_1} {β : Type u_2} [UniformSpace α] [UniformSpace β] [SeparatedSpace α] {S : set α} {F : α → β} (hs : IsCompact S) (hF : Continuous_on F S) : uniform_Continuous_on F S
{A B C : ℤ} (h : fermat_42 A B C) : ∃ (A0 B0 C0 : ℤ), fermat_42.Minimal A0 B0 C0
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m →+ P} {t : Add_Submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ t) {q : Type u_4} [AddCommMonoid q] {k : t.Localization_Map q} (z : N) : ⇑(k.to_Map) (⇑g ↑((F.sec z).Snd)) + ⇑(F.Map hy k) z = ⇑(k.to_Map) (⇑g (F.sec z).fst)
{β : Type u_2} [CommMonoid β] {n : ℕ} (F : Fin (n + 1) → β) (x : Fin (n + 1)) : Finset.Univ.Prod (λ (i : Fin (n + 1)), F i) = F x * Finset.Univ.Prod (λ (i : Fin n), F (⇑(x.Succ_above) i))
{n : ℕ} {A : Cardinal} : n • A < Cardinal.aleph0 ↔ n = 0 ∨ A < Cardinal.aleph0
{α : Type u} {ι : sort x} {F : ι → Filter α} [hn : Nonempty α] (hD : Directed Ge F) (hb : ∀ (i : ι), (F i).Ne_IsBot) : (infi F).Ne_IsBot
{α : Type u_3} {β : Type u_4} [Linear_ordered_Field α] {l : Filter β} {F : β → α} {r : α} (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_IsBot) : Filter.Tendsto (λ (x : β), r * F x) l Filter.at_IsBot
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (v : m) {r : R} (h : 0 < r) : SameRay R v (r • v)
{α : Type u} {β : Type v} {F : α → β} {A : Filter α} {B₁ B₂ : Filter β} (hF : Filter.Tendsto F A B₁) [A.Ne_IsBot] (hb : Disjoint B₁ B₂) : ¬Filter.Tendsto F A B₂
{S : Type u_1} [has_Add S] (A : S) : Add_Commute A A
{A : Type u_2} [CommRing A] [IsDomain A] [IsDedekindDomain A] {P : Ideal A} (hP : P ≠ ⊥) : Prime P ↔ P.Prime
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] {S : Finset α} {t : Finset β} {F : α → β} {B : m} [Linear_ordered_CommRing m] (hF : ∀ (A : α), A ∈ S → F A ∈ t) (ht : t.Card • B < ↑(S.Card)) : ∃ (y : β) (h : y ∈ t), B < ↑((Finset.Filter (λ (x : α), F x = y) S).Card)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (θ : Real.Angle) : ⇑LinearMap.det ↑((hb.rotation θ).to_Linear_Equiv) = 1
(P : ℕ) [Fact (Nat.Prime P)] (A : (Zmod P)ˣ) : A ^ (P - 1) = 1
{α : Type u} {l : List α} : l.Nodup → l.sublists.Nodup
(R : CommRing) (m : Submonoid ↥R) (x : Prime_Spectrum (Localization m)) : CategoryTheory.IsIso (AlgebraicGeometry.PresheafedSpace.stalk_Map (AlgebraicGeometry.spec.to_PresheafedSpace.Map (CommRing.of_hom (Algebra_Map ↥R (Localization m))).Op) x)
 : Filter.Tendsto Real.Exp (nhds 0) (nhds 1)
{m : Type u_1} [Monoid m] {γ : Type u_2} [Monoid γ] {F : m → γ} (hF : _Monoid_hom F) : _Submonoid (set.Range F)
{α : Type u} [AddGroup α] [has_LE α] [CovariantClass α α has_Add.Add has_LE.LE] {A B C : α} : B ≤ -A + C → A + B ≤ C
{F : Nat.Partrec.Code → Nat.Partrec.Code} (hF : Computable F) : ∃ (C : Nat.Partrec.Code), (F C).Eval = C.Eval
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {F : E → 𝕜} {g : E → F} (hF : ContDiff 𝕜 n F) (hg : ContDiff 𝕜 n g) : ContDiff 𝕜 n (λ (x : E), F x • g x)
{α : Type u_1} [conditionally_CompleteLattice α] {S t : set α} (sne : S.Nonempty) (tne : t.Nonempty) (hst : ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ t → x ≤ y) : (UpperBounds S ∩ LowerBounds t).Nonempty
{r : Nnreal} : ⊤ - ↑r = ⊤
{R : Type u_1} {m : Type u_3} [Monoid_with_Zero R] [has_Zero m] [MulAction_with_Zero R m] [nM : Nontrivial m] : ¬IsSmulRegular m 0
{α : Type u_1} [generalized_boolean_Algebra α] [Decidable_Rel Disjoint] [Decidable_Rel has_LE.LE] {S : Finset α} {u v A : α} (ha : A ∈ Uv.Compression u v S) (hva : v ≤ A) (hua : Disjoint u A) : (A ⊔ u)  v ∈ S
{α : Type u} [HasSubset α] {A B : α} [IsAntisymm α HasSubset.Subset] (h : A ⊆ B) (h' : B ⊆ A) : A = B
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {P1 P2 : P} (hp1 : P1 ∈ S) (hp2 : P2 ∈ S) : P1 -ᵥ P2 ∈ S.direction
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) : o.oangle y x = -o.oangle x y
{J : Type u₁} [CategoryTheory.Category J] [Nonempty J] (h : ∀ (j₁ j₂ : J), CategoryTheory.Zigzag j₁ j₂) : CategoryTheory.IsConnected J
{P : ℕ} {G : Type u_1} [Group G] (hG : _P_Group P G) [hp : Fact (Nat.Prime P)] (α : Type u_2) [MulAction G α] [Fintype α] [Fintype ↥(MulAction.FixedPoints G α)] (hpα : P ∣ Fintype.Card α) {A : α} (ha : A ∈ MulAction.FixedPoints G α) : ∃ (B : α), B ∈ MulAction.FixedPoints G α ∧ A ≠ B
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) : o.oangle (-x) y = o.oangle x y + ↑Real.Pi
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} {P : ι → P} (ha : AffineIndependent k (λ (x : ↥(set.Range P)), ↑x)) (hi : Function.Injective P) : AffineIndependent k P
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {x Y Z x' Y' Z' : C} (F : x ⟶ Y) [CategoryTheory.Limits.HasCokernel F] (g : Y ⟶ Z) (W : F ≫ g = 0) (F' : x' ⟶ Y') [CategoryTheory.Limits.HasCokernel F'] (g' : Y' ⟶ Z') (W' : F' ≫ g' = 0) (P : x ⟶ x') (q : Y ⟶ Y') (r : Z ⟶ Z') (h₁ : F ≫ q = P ≫ F') (h₂ : g ≫ r = q ≫ g') : CategoryTheory.Limits.Cokernel.Map F F' P q h₁ ≫ CategoryTheory.Limits.Cokernel.Desc F' g' W' = CategoryTheory.Limits.Cokernel.Desc F g W ≫ r
{α : Type u_2} [AddMonoid α] (m : α) : Even m → (∃ (C : α), m = 2 • C)
(R : Type u) [non_assoc_Ring R] (P : ℕ) [hc : Char_P R P] [Fintype R] : P ≠ 0
(R : Type u) [Ring R] [strong_RankCondition R] {ι : Type v} (m : ι → Type W) [Π (i : ι), AddCommGroup (m i)] [Π (i : ι), module R (m i)] [∀ (i : ι), module.free R (m i)] : module.rank R (direct_Sum ι (λ (i : ι), m i)) = Cardinal.Sum (λ (i : ι), module.rank R (m i))
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : Finset P} {P : P} (hp : P ∈ S) : Vector_Span k ↑S = Submodule.Span k ↑(Finset.image (λ (_x : P), _x -ᵥ P) (S.erase P))
(R : Type u) (m : Type v) [Ring R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] (N : Type v) [AddCommGroup N] [module R N] [module.free R N] : module.rank R (m × N) = module.rank R m + module.rank R N
{R : Type u_1} [Monoid_with_Zero R] {F : Nat.ArithmeticFunction R} : F.Multiplicative ↔ ⇑F 1 = 1 ∧ ∀ {m n : ℕ}, m ≠ 0 → n ≠ 0 → m.IsCoprime n → ⇑F (m * n) = ⇑F m * ⇑F n
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] (C : Con m) (F : m →* P) (h : C ≤ Con.Ker F) (h : Function.Injective ⇑(C.Lift F h)) : Con.Ker F = C
{n : ℕ} {E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {F : (Fin (n + 1) → ℂ) → E} {C : Fin (n + 1) → ℂ} {R : Fin (n + 1) → ℝ} (hF : TorusIntegrable F C R) (i : Fin (n + 1)) : ∯ (x : Fin (n + 1) → ℂ) in t(C, R), F x = ∮ (x : ℂ) in C(C i, R i), ∯ (y : Fin n → ℂ) in t(C ∘ ⇑(i.Succ_above), R ∘ ⇑(i.Succ_above)), F (i.Insert_nth x y)
{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), n ≤ m → P n → P (n - 1)) (n : ℤ) : n ≤ m → P n
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {A B : α} (h : A ⊂ B) : ¬B ⊆ A
(S : ℝ) : (λ (x : ℝ), x ^ S) =o[Filter.at_top] Real.Exp
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {P : Filter ι} {S : set α} : TendstoUniformlyOn F F P S ↔ Filter.Tendsto (λ (q : ι × α), (F q.Snd, F q.fst q.Snd)) (P.Prod (Filter.principal S)) (Uniformity β)
{R : Type u_1} [CommSemiring R] (m : Submonoid R) {S : Type u_2} [CommSemiring S] [Algebra R S] [IsLocalization m S] (z : S) : z * ⇑(Algebra_Map R S) ↑((IsLocalization.sec m z).Snd) = ⇑(Algebra_Map R S) (IsLocalization.sec m z).fst
{x : Type u_2} [EmetricSpace x] [TopologicalSpace.SecondCountableTopology x] (S : set x) : (⨆ (x : x) (h : x ∈ S), (nhds_within x S).Small_sets.limsup dimH) = dimH S
{R : Type u} {A : R} [Semiring R] {P : Polynomial R} (h : A * P.leading_Coeff ≠ 0) : (⇑Polynomial.C A * P).Nat_degree = P.Nat_degree
{α : Type u_1} [DecidableEq α] [Fintype α] (F : Equiv.perm α) {x : α} : (F.Cycle_of x)._Cycle ↔ ⇑F x ≠ x
{α : Type u} {β : Type v} [TopologicalSpace α] [Linear_ordered_AddCommGroup α] [OrderTopology α] {l : Filter β} {F g : β → α} {C : α} (hF : Filter.Tendsto F l Filter.at_IsBot) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (λ (x : β), F x + g x) l Filter.at_IsBot
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [Linear_ordered_AddCommMonoid β] [HasScalar 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F : E → β} (hF : ConcaveOn 𝕜 S F) {x y : E} (hx : x ∈ S) (hy : y ∈ S) {A B : 𝕜} (ha : 0 ≤ A) (hb : 0 ≤ B) (hab : A + B = 1) : LinearOrder.min (F x) (F y) ≤ F (A • x + B • y)
(R : Type u_1) [Rack R] (G : Type u_2) [Group G] (F : ShelfHom R (Quandle.Conj G)) (g : Rack.envel_Group R →* G) (h : F = (Quandle.Conj.Map g).Comp (Rack.to_envel_Group R)) : g = ⇑Rack.to_envel_Group.Map F
{K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [Ne_Zero 2] {k : ℕ} (hk : 2 ≤ k) [IsCyclotomicExtension {2 ^ k} K L] (hirr : Irreducible (Polynomial.cyclotomic (2 ^ k) K)) : ⇑(Algebra.norm K) (IsCyclotomicExtension.zeta (2 ^ k) K L - 1) = 2
{α : Type u} {β : Type v} [AddGroup α] [AddGroup β] {F : α → β} (hF : ∀ (x y : α), F (x + y) = F x + F y) : _AddGroup_hom F
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {g : F → G} {F : E → F} (hg : ContDiff 𝕜 n g) (hF : ContDiff 𝕜 n F) : ContDiff 𝕜 n (g ∘ F)
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k → E} {A B r : k} (hab : A < B) (h₀ : 0 < r) (h₁ : r < 1) : ⇑(affine_Map.line_Map (F A) (F B)) r ≤ F (⇑(affine_Map.line_Map A B) r) ↔ slope F (⇑(affine_Map.line_Map A B) r) B ≤ slope F A (⇑(affine_Map.line_Map A B) r)
{x : top} (F : top.Presheaf (Type v) x) (Fsh : F._sheaf_Unique_gluing) : F._sheaf
{𝕜 : Type u_3} [_R_or_C 𝕜] {n m : ℕ} (A B : Matrix (Fin n) (Fin m) 𝕜) (i j : Fin n) : HasInner.inner (A i) (B j) = B.Mul A.Conj_transpose j i
{m : Type u_1} [AddZeroClass m] {S : set m} {P : m → m → Prop} {x y : m} (hx : x ∈ AddSubmonoid.Closure S) (hy : y ∈ AddSubmonoid.Closure S) (Hs : ∀ (x : m), x ∈ S → ∀ (y : m), y ∈ S → P x y) (h1_Left : ∀ (x : m), P 0 x) (h1_Right : ∀ (x : m), P x 0) (HMul_Left : ∀ (x y z : m), P x z → P y z → P (x + y) z) (HMul_Right : ∀ (x y z : m), P z x → P z y → P z (x + y)) : P x y
{α : Type u} [TopologicalSpace α] {S : set α} {ι : Type v} [hι : Nonempty ι] (hs : IsCompact S) (U : ι → set α) (hUo : ∀ (i : ι), IsOpen (U i)) (hsU : S ⊆ ⋃ (i : ι), U i) (hdU : Directed HasSubset.Subset U) : ∃ (i : ι), S ⊆ U i
{α : Type u_1} [UniformSpace α] : (Uniformity α).has_Basis (λ (S : set (α × α)), S ∈ Uniformity α ∧ symmetric_Rel S) Id
{𝕜 : Type u_1} {E : Type u_3} [OrderedSemiring 𝕜] [TopologicalSpace E] [AddCommGroup E] [module 𝕜 E] [has_Continuous_Add E] {S : set E} (hs : strict_Convex 𝕜 S) (x : E) : strict_Convex 𝕜 (x +ᵥ S)
{v : Type u_1} [InnerProductSpace ℝ v] {P : Type u_2} [MetricSpace P] [NormedAddTorsor v P] {A B C D P : P} (h : EuclideanGeometry.Cospherical {A, B, C, D}) (hapc : EuclideanGeometry.angle A P C = Real.Pi) (hbpd : EuclideanGeometry.angle B P D = Real.Pi) : HasDist.dist A B * HasDist.dist C D + HasDist.dist B C * HasDist.dist D A = HasDist.dist A C * HasDist.dist B D
{R : Type u_1} [Linear_ordered_Field R] [FloorRing R] {B : ℕ} (hb : 1 < B) {x : ℤ} {r : R} (hr : 0 < r) : r < ↑B ^ x ↔ Int.log B r < x
{α : Type u_1} [TopologicalSpace α] [PolishSpace α] [MeasurableSpace α] [BorelSpace α] {S : set α} (hs : Measurable_set S) : PolishSpace._clopenable S
{ι : Type u_1} {R : Type u_3} {m : Type u_5} {v : ι → m} [Ring R] [AddCommGroup m] [module R m] {hli : LinearIndependent R v} {hsp : Submodule.Span R (set.Range v) = ⊤} {i j : ι} : ⇑((Basis.Mk hli hsp).coord i) (v j) = Ite (j = i) 1 0
{P n : ℕ} (h_Pos : 0 < ⇑(n.central_binom.factorization) P) : P ≤ 2 * n
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : ℝ} {C W : ℂ} {F : ℂ → E} {S : set ℂ} (hs : S.countable) (hw : W ∈ Metric.Ball C R) (hc : Continuous_on F (metric.IsClosed_ball C R)) (hD : ∀ (x : ℂ), x ∈ Metric.Ball C R  S → Differentiable_at ℂ F x) : (2 * ↑Real.Pi * Complex.i)⁻¹ • ∮ (z : ℂ) in C(C, R), (z - W)⁻¹ • F z = F W
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder β] [SuccOrder β] [IsSuccArchimedean β] {S : β → set α} {t : set β} (hnt : t.Nonempty) (ht : t.Ord_connected) (h : ∀ (n : β), n ∈ t → IsConnected (S n)) (K : ∀ (n : β), n ∈ t → Order.Succ n ∈ t → (S n ∩ S (Order.Succ n)).Nonempty) : IsConnected (⋃ (n : β) (h : n ∈ t), S n)
{R : Type v} [CommRing R] (A : Matrix (Fin 2) (Fin 2) R) : A.det = A 0 0 * A 1 1 - A 0 1 * A 1 0
(R : Type u_3) (m : Type u_4) [AddCommMonoid m] [Semiring R] [module R m] (tr : AddMonoid._torsion R) : AddMonoid._torsion m
{α : Type u} [TopologicalSpace α] {P : α → Prop} {A : α} (h : ∀ᶠ (y : α) in nhds A, P y) : P A
{G : Type u_1} [Group G] (h : Group.IsNilpotent (G ⧸ Subgroup.Center G)) : Group.IsNilpotent G
{G : Type u_1} [hG : Group G] [hF : Fintype G] {P : ℕ} [hp : Fact (Nat.Prime P)] (h : _P_Group P G) : Group.IsNilpotent G
{P : Type u_2} [MetricSpace P] (P : P) : EuclideanGeometry.Cospherical {P}
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] (v : K) : (GeneralizedContinuedFraction.of v).terminates ↔ ∃ (q : ℚ), v = ↑q
{E : Type u_1} {PE : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [MetricSpace PE] [NormedAddTorsor E PE] {x y : PE} (e : PE ≃ᵢ PE) : ⇑e x = x → ⇑e y = y → ⇑e (midpoint ℝ x y) = midpoint ℝ x y
(S t : set ℕ+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension t A B] (hS : S ⊆ t) : IsCyclotomicExtension S A ↥(Algebra.Adjoin A {B : B | ∃ (A : ℕ+), A ∈ S ∧ B ^ ↑A = 1})
{R : Type u_1} (m : Type u_3) {A : R} [Monoid R] [MulAction R m] (ua : IsUnit A) : IsSmulRegular m A
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {t : Affine.Triangle ℝ P} (ho : t.orthocenter ∉ set.Range t.points) {P : Fin 3 → P} (hps : set.Range P ⊆ HasInsert.Insert t.orthocenter (set.Range t.points)) (hpi : Function.Injective P) : (∃ (i₁ i₂ i₃ j₂ j₃ : Fin 3), i₁ ≠ i₂ ∧ i₁ ≠ i₃ ∧ i₂ ≠ i₃ ∧ (∀ (i : Fin 3), i = i₁ ∨ i = i₂ ∨ i = i₃) ∧ P i₁ = t.orthocenter ∧ j₂ ≠ j₃ ∧ t.points j₂ = P i₂ ∧ t.points j₃ = P i₃) ∨ set.Range P = set.Range t.points
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] (S : set m) (h : S.Finite) : CompleteLattice.IsCompact_element (Submodule.Span R S)
{α : Type u_1} {r : α → α → Prop} (h : WellFounded r) (S : set α) : S.Nonempty → (∃ (A : α) (h : A ∈ S), ∀ (x : α), x ∈ S → ¬r x A)
{E : Type u_1} [InnerProductSpace ℝ E] {ι : Type u_2} [Fintype ι] [DecidableEq ι] [Nonempty ι] {e : Basis ι ℝ E} (h : Orthonormal ℝ ⇑e) (x : Orientation ℝ E ι) : Orthonormal ℝ ⇑(e.adjust_to_Orientation x)
{α : Type u_1} {E' : Type u_6} {E'' : Type u_9} [semi_NormedGroup E'] [NormedGroup E''] {F' : α → E'} {l : Filter α} {C : E''} (hc : C ≠ 0) : (λ (x : α), C) =O[l] F' ↔ ∃ (B : ℝ), 0 < B ∧ ∀ᶠ (x : α) in l, B ≤ ∥F' x∥
{G : Type u} {n : ℕ} [Fintype G] [Add_Left_cancel_Monoid G] (x : G) : Add_order_of (n • x) = Add_order_of x / (Add_order_of x).Gcd n
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] [CompleteSpace 𝕜] {F F' : 𝕜 → 𝕜} (hF : ∀ (x : 𝕜), HasStrictDerivAt F (F' x) x) (h0 : ∀ (x : 𝕜), F' x ≠ 0) : IsOpen_Map F
{R : Type u_1} [CommRing R] {S : Type u_2} [CommRing S] {P : Ideal R} {P : Ideal S} [Algebra R S] [Algebra (R ⧸ P) (S ⧸ P)] [IsScalarTower R (R ⧸ P) (S ⧸ P)] (h : Function.Injective ⇑(Algebra_Map (R ⧸ P) (S ⧸ P))) : Ideal.comap (Algebra_Map R S) P = P
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {k : S.Localization_Map P} (z : N) : ⇑(k.Lift _) (⇑(F.Lift _) z) = z
{α : Type u} {β : Type v} [PseudoMetricSpace α] [PseudoMetricSpace β] {F : α → β} {x : α} {r : ℝ} (hr : 0 < r) (K : ℝ) (h : ∀ (y : α), HasDist.dist y x < r → HasDist.dist (F y) (F x) ≤ K * HasDist.dist y x) : Continuous_at F x
{α : Type u_1} {β : Type u_2} (F : α → β) : Function.Injective (Quotient.Lift F _)
{𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] {F : 𝕜 → G} {S : set 𝕜} {x y : 𝕜} {C : ℝ} (hF : ∀ (x : 𝕜), x ∈ S → Differentiable_at 𝕜 F x) (bound : ∀ (x : 𝕜), x ∈ S → ∥deriv F x∥ ≤ C) (hs : Convex ℝ S) (xs : x ∈ S) (ys : y ∈ S) : ∥F y - F x∥ ≤ C * ∥y - x∥
{m : Type u_2} [AddCommGroup m] {𝕜 : Type u_1} [Field 𝕜] [module 𝕜 m] {F : m →ₗ[𝕜] m} (hF : ⇑LinearMap.det F = 0) : F.Range < ⊤
{α : Type u_1} {β : Type u_2} [PseudoEmetricSpace α] [Nonempty β] [SemilatticeSup β] {S : β → α} : Cauchy_Seq S ↔ ∃ (B : β → Ennreal), (∀ (n m N : β), N ≤ n → N ≤ m → HasEdist.edist (S n) (S m) ≤ B N) ∧ Filter.Tendsto B Filter.at_top (nhds 0)
{α : Type u_1} {β : Type u_2} [UniformSpace α] (F : β → α) (l : Filter β) : Filter.Tendsto (λ (x : β), (F x, F x)) l (Uniformity α)
{δ : Type u_1} [Fintype δ] {κ : δ → Type u_2} {t : Π (D : δ), set (κ D)} (ht : ∀ (D : δ), (t D).Finite) : (set.Univ.Pi t).Finite
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] (F : m →* P) {x y : m} : ⇑(Con.Ker F) x y ↔ ⇑F x = ⇑F y
{C : Type u} [CategoryTheory.Category C] {J₁ J₂ : CategoryTheory.GrothendieckTopology C} (h : CategoryTheory.Presieve._sheaf J₁ (CategoryTheory.Functor.IsClosed_sieves J₂)) : J₁ ≤ J₂
(E : Type u_1) [AddCommGroup E] : Subsingleton (module ℚ E)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x : v) (θ : Real.Angle) : x = ⇑(hb.rotation θ) x ↔ x = 0 ∨ θ = 0
{α : Type u} [TopologicalSpace α] {S : set α} : IsConnected S ↔ ∀ (U : Finset (set α)), (∀ (u v : set α), u ∈ U → v ∈ U → (S ∩ (u ∩ v)).Nonempty → u = v) → (∀ (u : set α), u ∈ U → IsOpen u) → S ⊆ ⋃₀↑U → (∃ (u : set α) (h : u ∈ U), S ⊆ u)
{G : Type u_1} [AddCommGroup G] (K : Add_Subgroup G) {ι : Type u_2} {t : Finset ι} {F : ι → G} (h : ∀ (C : ι), C ∈ t → F C ∈ K) : t.Sum (λ (C : ι), F C) ∈ K
(𝕜 : Type u_1) {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} [LinearOrder ι] [OrderBot ι] [locally_Finite_order ι] [IsWellOrder ι has_LT.LT] (F : ι → E) (n : ι) : gram_schmidt 𝕜 F n = F n - (Finset.Iio n).Sum (λ (i : ι), ↑(⇑(Orthogonal_projection (Submodule.Span 𝕜 {gram_schmidt 𝕜 F i})) (F n)))
(n : ℕ) : (List.Nat.antidiagonal n).Nodup
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {P : FormalMultilinearSeries 𝕜 E F} [CompleteSpace F] : Continuous_on P.Sum (Emetric.Ball 0 P.radius)
{α J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.Fin_Category J] [SemilatticeInf α] [OrderTop α] (F : J ⥤ α) : CategoryTheory.Limits.Limit F = Finset.Univ.Inf F.obj
{α : Type u_1} [semi_NormedRing α] [NormOneClass α] (A : α) (n : ℕ) : ∥A ^ n∥₊ ≤ ∥A∥₊ ^ n
{G : Type u_1} [CategoryTheory.groupoid G] [IsFreeGroupoid G] {x : Type v} [Group x] (F g : G ⥤ CategoryTheory.SingleObj x) (h : ∀ (A B : IsFreeGroupoid.Generators G) (e : A ⟶ B), F.Map (IsFreeGroupoid.of e) = g.Map (IsFreeGroupoid.of e)) : F = g
(n : ℕ) {R : Type u_1} [Linear_ordered_CommRing R] {x : R} (hx : 1 ≤ x) : 0 ≤ Polynomial.Eval x (Polynomial.cyclotomic n R)
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (l : List (Matrix n n α)) : (l.Prod)⁻¹ = (List.Map has_Inv.Inv l.reverse).Prod
{R : Type u} [Semiring R] {P : Ideal R} (hmax : ∀ (m : Ideal R), P < m → ¬m.IsMaximal) (J : Ideal R) (hPJ : P < J) : J = ⊤
{C : Type u₁} [CategoryTheory.Category C] {A : Type u₂} [CategoryTheory.Category A] (P : Cᵒᵖ ⥤ A) [CategoryTheory.Limits.HasPullbacks C] (K : CategoryTheory.Pretopology C) : CategoryTheory.Presheaf.IsSheaf (CategoryTheory.Pretopology.to_grothendieck C K) P ↔ ∀ ⦃x : C⦄ (R : CategoryTheory.Presieve x), R ∈ ⇑K x → Nonempty (CategoryTheory.Limits.IsLimit (P.Map_cone (CategoryTheory.Sieve.generate R).Arrows.Cocone.Op))
{β : Type u} {α : Type v} [AddCommMonoid β] {S : Finset α} {F : α → β} {A : α} (hp : S.Sum (λ (x : α), F x) = 0) (h1 : ∀ (x : α), x ∈ S → x ≠ A → F x = 0) (x : α) (h : x ∈ S) : F x = 0
{E : Type u_1} (R : Type u_2) (S : Type u_3) [AddCommGroup E] [DivisionRing R] [DivisionRing S] [module R E] [module S E] (n : ℤ) (x : E) : (↑n)⁻¹ • x = (↑n)⁻¹ • x
{E : Type u_3} {F : Type u_4} [semi_NormedGroup E] [semi_NormedGroup F] (F : E →+ F) (C : ℝ) (h : ∀ (x : E), ∥⇑F x∥ ≤ C * ∥x∥) : Continuous ⇑F
{α : Type u} [PseudoEmetricSpace α] {δ₁ δ₂ : ℝ} (δ₂_Pos : 0 < δ₂) (hlt : δ₁ < δ₂) (E : set α) : Metric.Cthickening δ₁ E ⊆ Metric.Thickening δ₂ E
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (F : α → C(β, γ)) (h : Continuous (Function.uncurry (λ (x : α) (y : β), ⇑(F x) y))) : Continuous F
{α : Type u} [TopologicalSpace α] [LocallyCompactSpace α] [RegularSpace α] {K U : set α} (hK : IsCompact K) (hU : IsOpen U) (hKU : K ⊆ U) : ∃ (K' : set α), IsCompact K' ∧ K ⊆ Interior K' ∧ K' ⊆ U
(n : ℕ+) (x : ℂˣ) : x ∈ roots_of_unity n ℂ ↔ ∃ (i : ℕ) (h : i < ↑n), Complex.Exp (2 * ↑Real.Pi * Complex.i * (↑i / ↑n)) = ↑x
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : Fin 3 → P) : Collinear k (set.Range P) ↔ ¬AffineIndependent k P
{α : Type u_1} {β : Type u_2} {t₁ t₂ : TopologicalSpace α} {t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₁) {S : set α} {F : α → β} (h₂ : Continuous_on F S) : Continuous_on F S
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] {F : α → β} {S : set α} {A : α} (h_Mono : StrictMono_on F S) (hs : S ∈ nhds_within A (set.ici A)) (hfs : ∀ (B : β), B > F A → (∃ (C : α) (h : C ∈ S), F C ∈ set.ioc (F A) B)) : Continuous_within_at F (set.ici A) A
{C : Type u} [CategoryTheory.Category C] {x Y Z : AlgebraicGeometry.PresheafedSpace C} (α : x ⟶ Y) (β : Y ⟶ Z) (U : (TopologicalSpace.Opens ↥(Z.carrier))ᵒᵖ) : (α ≫ β).C.App U = β.C.App U ≫ α.C.App (Opposite.Op ((TopologicalSpace.Opens.Map β.Base).obj (Opposite.Unop U)))
{n k : ℕ} : k ≤ n → (n - k).factorial * n.Desc_factorial k = n.factorial
{A B : ℝ} (h : A < B) : Cardinal.Mk ↥(set.Ioo A B) = Cardinal.Continuum
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {F : α → γ} {x : α} {y : β} (hF : Continuous_at F x) : Continuous_at (λ (x : α × β), F x.fst) (x, y)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {F : 𝕜 → F} {S : set 𝕜} {x : 𝕜} (hxs : UniqueDiffWithinAt 𝕜 S x) : iterated_deriv_within (n + 1) F S x = deriv_within (iterated_deriv_within n F S) S x
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [Finite_dimensional 𝕜 E] {n : ℕ} (hn : Finite_dimensional.finrank 𝕜 E = n) {ι : Type u_4} [Fintype ι] [DecidableEq ι] {v : ι → Submodule 𝕜 E} (hV : direct_Sum._internal v) (hV' : OrthogonalFamily 𝕜 (λ (i : ι), (v i).Subtypeₗᵢ)) : Orthonormal 𝕜 ⇑(direct_Sum._internal.subordinate_Orthonormal_Basis hn hV)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {P : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall F P x r) : TendstoLocallyUniformlyOn (λ (n : ℕ) (y : E), P.partial_Sum n y) (λ (y : E), F (x + y)) Filter.at_top (Emetric.Ball 0 r)
{α : Type u} [EmetricSpace α] : Continuous (λ (P : α × TopologicalSpace.Closeds α), Emetric.Inf_edist P.fst ↑(P.Snd))
(R : Type u) [Semiring R] {ι : Type v} [decι : DecidableEq ι] {m : ι → Type W} [Π (i : ι), AddCommMonoid (m i)] [Π (i : ι), module R (m i)] (S : Finset ι) (C : R) (x : Π (i : ↥↑S), m i.val) : ⇑(direct_Sum.Mk m S) (C • x) = C • ⇑(direct_Sum.Mk m S) x
{α : Type u_1} [PseudoEmetricSpace α] (r C : Ennreal) {F : ℕ → α} (hu : ∀ (n : ℕ), HasEdist.edist (F n) (F (n + 1)) ≤ C * r ^ n) {A : α} (ha : Filter.Tendsto F Filter.at_top (nhds A)) (n : ℕ) : HasEdist.edist (F n) A ≤ C * r ^ n / (1 - r)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] (P₁ P₂ : P) : Collinear k {P₁, P₂}
{α : Type u_1} [DecidableEq α] : ∅.shadow = ∅
{R : Type u_1} {S : Type u_2} {m : Type u_3} {S : S} [HasScalar R m] [HasScalar R S] [HasScalar S m] [IsScalarTower R S m] (A : R) (Ab : IsSmulRegular m (A • S)) : IsSmulRegular m S
{α : Type u_1} [semi_NormedGroup α] {r C : ℝ} {F : ℕ → α} (hr : r < 1) (hF : ∀ (n : ℕ), ∥F n∥ ≤ C * r ^ n) {A : α} (ha : has_Sum F A) (n : ℕ) : ∥(Finset.Range n).Sum (λ (x : ℕ), F x) - A∥ ≤ C * r ^ n / (1 - r)
{J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ AddMon) [CategoryTheory.IsFiltered J] {x x' y : Σ (j : J), ↥(F.obj j)} (hxx' : CategoryTheory.Limits.types.filtered_Colimit.Rel (F ⋙ CategoryTheory.Forget AddMon) x x') : AddMon.FilteredColimits.Colimit_Add_aux F x y = AddMon.FilteredColimits.Colimit_Add_aux F x' y
{m : Type u_3} [Monoid m] [Preorder m] (L : List m) (h : L.Prod < 1) : 0 < L.length
{α : Type u_1} [TopologicalSpace α] {S t : set α} (hs : _Gδ S) (ht : _Gδ t) : _Gδ (S ∪ t)
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x : v) : o.oangle 0 x = 0
(n : ℕ) : n.Totient = n / n.Factors.to_Finset.Prod (λ (P : ℕ), P) * n.Factors.to_Finset.Prod (λ (P : ℕ), P - 1)
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x : v) {r : ℝ} (hr : 0 ≤ r) : o.oangle x (r • x) = 0
{C : Type u} [CategoryTheory.Category C] {A B : C} {F g : A ⟶ B} [CategoryTheory.IsCoreflexivePair F g] : CategoryTheory.IsCoreflexivePair g F
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] (G : set A) (hG : ∀ (x : A), x ∈ G → IsIntegral R x) (x : A) (h : x ∈ Subring.Closure G) : IsIntegral R x
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) [CategoryTheory.Limits.HasLimits_of_size D] [CategoryTheory.CreatesLimitsOfSize F] : CategoryTheory.Limits.HasLimits_of_size C
 : ¬Summable (λ (n : ℕ), 1 / ↑n)
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.NormalMonoCategory C] [CategoryTheory.Limits.has_Zero_object C] {x Y : C} (F : x ⟶ Y) (hF : ∀ (Z : C) (g : Y ⟶ Z), F ≫ g = 0 → g = 0) : CategoryTheory.Epi F
{R₁ : Type u_1} {R₂ : Type u_2} [Semiring R₁] [Semiring R₂] {σ₁₂ : R₁ →+* R₂} {m₁ : Type u_4} [TopologicalSpace m₁] [AddCommMonoid m₁] {m₂ : Type u_6} [TopologicalSpace m₂] [AddCommMonoid m₂] [module R₁ m₁] [module R₂ m₂] [Ring_hom_surjective σ₁₂] [TopologicalSpace R₁] [TopologicalSpace R₂] [has_Continuous_Smul R₁ m₁] [has_Continuous_Add m₁] [has_Continuous_Smul R₂ m₂] [has_Continuous_Add m₂] (F : m₁ →sl[σ₁₂] m₂) (S : Submodule R₁ m₁) : Submodule.Map ↑F S.topological_Closure ≤ (Submodule.Map ↑F S).topological_Closure
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [HasScalar 𝕜 E] {S : set E} : Convex 𝕜 S ↔ ∀ ⦃A B : 𝕜⦄, 0 ≤ A → 0 ≤ B → A + B = 1 → A • S + B • S ⊆ S
{m : Type u_1} [has_Add m] {N : Type u_2} [has_Add N] (F : Add_hom m N) (hF : Function.Surjective ⇑F) : F.srange = ⊤
{ι : Type u_1} {E : ι → Type u_2} [Π (i : ι), MetricSpace (E i)] (i : ι) : Isometry (Sigma.Mk i)
(x : ℝ) : Real.cosh x = (Real.Exp x + Real.Exp (-x)) / 2
{α : Type u} [AddGroup α] [has_LE α] [CovariantClass α α has_Add.Add has_LE.LE] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B : α} : A ≤ -B → B ≤ -A
{α : Type u} [PartialOrder α] {A B : α} (h : A ≤ B) : B = A ∨ A < B
(n : ℕ) : ↑(Nat.fib n) = (GoldenRatio ^ n - golden_Conj ^ n) / Real.sqrt 5
{S : set ℕ} (hb : 0 ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) (n : ℕ) : n ∈ S
{E : Type u_1} [InnerProductSpace ℝ E] {C : E} (F : ContDiff_bump_of_inner C) (x : E) : 0 ≤ ⇑F x
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] {A : set x} {F : x → Y} {x : x} (h : ∃ (y : Y), Filter.Tendsto F (nhds_within x A) (nhds y)) : Filter.Tendsto F (nhds_within x A) (nhds (extend_from A F x))
(R : Type u) (m : Type v) [Ring R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] : Finite_dimensional.finrank R m = Fintype.Card (module.free.choose_Basis_Index R m)
{α : Type u} [AddGroup α] [has_LE α] [CovariantClass α α has_Add.Add has_LE.LE] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B : α} : -A ≤ -B → B ≤ A
(A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {P : Polynomial A} (pmonic : P.monic) (hp : ⇑(Polynomial.aeval x) P = 0) (pmin : ∀ (q : Polynomial A), q.monic → ⇑(Polynomial.aeval x) q = 0 → P.degree ≤ q.degree) : P = minpoly A x
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (m : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (i : Fin r ⊕ Unit) {k : ℕ} (hk : k ≤ r) : (List.Drop k (Matrix.Pivot.List_transvec_col m)).Prod.Mul m (Sum.inr_ ()) i = m (Sum.inr_ ()) i
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F₂ : 𝕜 → F} {S₂ : set 𝕜} (hs : IsOpen S₂) : ContDiff_on 𝕜 ⊤ F₂ S₂ ↔ DifferentiableOn 𝕜 F₂ S₂ ∧ ContDiff_on 𝕜 ⊤ (deriv F₂) S₂
{β : Type u} {α : Type v} [CommMonoid β] [DecidableEq α] (S : Finset α) {F : α → β} {A : α} (h : F A = 1) : (S.erase A).Prod (λ (x : α), F x) = S.Prod (λ (x : α), F x)
{G : Type u_1} [Group G] {S : set G} {x C : G} : x ∈ Group.conjugates_of_set S → C * x * C⁻¹ ∈ Group.conjugates_of_set S
{α : Type u} [Group α] [has_LE α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A B C : α} : A ≤ B * C → B⁻¹ * A ≤ C
{R : Type u_1} [non_assoc_Ring R] [Nontrivial R] [no_Zero_divisors R] (hR : Ring_Char R ≠ 2) {A : R} : -A = A ↔ A = 0
{G : Type u_1} [AddGroup G] {ι : sort u_2} (S : ι → Add_Subgroup G) {C : G → Prop} {x : G} (hx : x ∈ ⨆ (i : ι), S i) (hp : ∀ (i : ι) (x : G), x ∈ S i → C x) (h1 : C 0) (HMul : ∀ (x y : G), C x → C y → C (x + y)) : C x
{n : Type u_1} {𝕜 : Type u_3} [Field 𝕜] [DecidableEq n] [Fintype n] (P : Matrix n n 𝕜 → Prop) (m : Matrix n n 𝕜) (hMdet : m.det ≠ 0) (hdiag : ∀ (D : n → 𝕜), (Matrix.Diagonal D).det ≠ 0 → P (Matrix.Diagonal D)) (htransvec : ∀ (t : Matrix.TransvectionStruct n 𝕜), P t.to_Matrix) (HMul : ∀ (A B : Matrix n n 𝕜), A.det ≠ 0 → B.det ≠ 0 → P A → P B → P (A.Mul B)) : P m
{S : Type u_2} [CommRing S] {R : Type u_3} [CommRing R] [Algebra R S] {A : Type u_4} [CommRing A] [Algebra R A] [Algebra S A] [IsScalarTower R S A] {B : power_Basis S A} (hB : IsIntegral R B.gen) [IsDomain S] {x : A} (hx : ∀ (i : Fin B.dim), IsIntegral R (⇑(⇑(B.Basis.repr) x) i)) (hmin : minpoly S B.gen = Polynomial.Map (Algebra_Map R S) (minpoly R B.gen)) (n : ℕ) (i : Fin B.dim) : IsIntegral R (⇑(⇑(B.Basis.repr) (x ^ n)) i)
{R : Type u} {ι : Type v} {m₁ : ι → Type W₁} {m₂ : Type W₂} [DecidableEq ι] [CommSemiring R] [Π (i : ι), AddCommMonoid (m₁ i)] [AddCommMonoid m₂] [Π (i : ι), module R (m₁ i)] [module R m₂] [Π (i : ι), TopologicalSpace (m₁ i)] [TopologicalSpace m₂] (F : Continuous_MultilinearMap R m₁ m₂) [Fintype ι] (C : ι → R) (m : Π (i : ι), m₁ i) : ⇑F (λ (i : ι), C i • m i) = Finset.Univ.Prod (λ (i : ι), C i) • ⇑F m
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {A : F} (ha : A ≠ 0) : Char.quadratic_Char F (A ^ 2) = 1
{α : Type u} [TopologicalSpace α] {S : set α} [DiscreteTopology ↥S] {x : α} (hx : x ∈ S) : nhds_within x S = has_pure.pure x
{α : Type u_1} [canonically_Linear_ordered_AddMonoid α] [HasSub α] [HasOrderedSub α] {A B C : α} (ha : Add_LE_cancellable A) (hb : Add_LE_cancellable B) (h : B ≤ A) : A - B < A - C ↔ C < B
{A : Type u_4} [CommRing A] [IsDomain A] {K : Type u_5} [Field K] {L : Type u_7} [Field L] [Algebra A K] [_fraction_Ring A K] {g : A →+* L} (hg : Function.Injective ⇑g) (x : A) : ⇑(_fraction_Ring.Lift hg) (⇑(Algebra_Map A K) x) = ⇑g x
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) : o.oangle x y + o.oangle y x = 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S₁ S₂ : AffineSubspace k P} (hD : S₁.direction = S₂.direction) (hn : ↑S₁.Nonempty) (hle : S₁ ≤ S₂) : S₁ = S₂
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.ConcreteCategory.Forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.ConcreteCategory.Forget C)] {x : top} (F : top.sheaf C x) {ι : Type v} (U : ι → TopologicalSpace.Opens ↥x) (v : TopologicalSpace.Opens ↥x) (iUV : Π (i : ι), U i ⟶ v) (hcover : v ≤ supr U) (S t : ↥(F.val.obj (Opposite.Op v))) (h : ∀ (i : ι), ⇑(F.val.Map (iUV i).Op) S = ⇑(F.val.Map (iUV i).Op) t) : S = t
{α : Type u_1} {o P : Part α} (h1 : o.Dom ↔ P.Dom) (h2 : ∀ (h₁ : o.Dom) (h₂ : P.Dom), o.get h₁ = P.get h₂) : o = P
{α : Type u_1} {β : Type u_2} (F : β → α → β) (B : β) : Vector.scanl F B Vector.Nil = B::ᵥVector.Nil
{α : Type u_1} {β : Type u_2} [LinearOrder α] [LinearOrder β] {F : α → β} (h₁ : StrictMono F) (A B : Finset α) : (Finset.image F A).to_colex ≤ (Finset.image F B).to_colex ↔ A.to_colex ≤ B.to_colex
{α : Type u} [PseudoEmetricSpace α] {S : set α} : Continuous (λ (x : α), Emetric.Inf_edist x S)
{α : Type u_1} [Linear_ordered_Field α] {A B C D : α} (hc : C ≠ 0) (hD : D ≠ 0) : (A * D - B * C) / (C * D) ≤ 0 → A / C ≤ B / D
{α : Type u_1} [TopologicalSpace α] {U : set α} {hU : IsOpen U} : ↑⟨U, hU⟩ = U
{α : Type u_1} {β : Type u_2} [UniformSpace β] {F : α → β} {x : α} [TopologicalSpace α] (L : ∀ (u : set (β × β)), u ∈ Uniformity β → (∃ (t : set α) (h : t ∈ nhds x) (F : α → β), Continuous_at F x ∧ ∀ (y : α), y ∈ t → (F y, F y) ∈ u)) : Continuous_at F x
{x : Type u_1} [TopologicalSpace x] [Infinite x] [DiscreteTopology x] : ¬Continuous ⇑(CofiniteTopology.of.Symm)
{𝕜 : Type u_3} [_R_or_C 𝕜] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {F F' : 𝕜 → G} {x : 𝕜} (hder : ∀ᶠ (y : 𝕜) in nhds x, HasDerivAt F (F' y) y) (hcont : Continuous_at F' x) : HasStrictDerivAt F (F' x) x
{n : ℕ} (A : Fin (n + 1)) : ↑(A.val) = A
{g : Equiv.perm (Fin 5)} (ha : g ∈ alternating_Group (Fin 5)) (h1 : g ≠ 1) (h2 : ∀ (n : ℕ), n ∈ g.Cycle_Type → n = 2) : IsConj (Equiv.Swap 0 4 * Equiv.Swap 1 3) g
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] (Z : TopologicalFiberBundleCore ι B F) : IsOpen_Map Z.Proj
{α : Type u} {β : Type v} [PseudoMetricSpace α] [PseudoMetricSpace β] {K : Nnreal} {S : set α} {F : α → β} : LipschitzOnWith K F S → ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → HasDist.dist (F x) (F y) ≤ ↑K * HasDist.dist x y
{m : Type u_1} [has_Mul m] {β : sort u_2} (C : Con m) (F : m → β) (h : ∀ (A B : m), ⇑C A B → F A = F B) (x : m) : Con.Lift_on ↑x F h = F x
{R : Type u_1} [CommRing R] {C₁ C₂ : R} (q : Quaternion_Algebra R C₁ C₂) : ⇑clifford_Algebra_Quaternion.of_Quaternion (⇑Quaternion_Algebra.Conj q) = ⇑clifford_Algebra.involute (⇑clifford_Algebra.reverse (⇑clifford_Algebra_Quaternion.of_Quaternion q))
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {S : set 𝕜} {F : 𝕜 → 𝕜} (hs : Convex 𝕜 S) (hF : ∀ {x y z : 𝕜}, x ∈ S → z ∈ S → x < y → y < z → (F z - F y) / (z - y) < (F y - F x) / (y - x)) : strict_ConcaveOn 𝕜 S F
{α : Type u_1} {ι : sort u_4} {l : Filter α} {P : ι → Prop} {S : ι → set α} {t : set α} (hl : l.has_Basis P S) : t ∈ l ↔ ∃ (i : ι) (hi : P i), S i ⊆ t
{α : Type u_1} {β : α → Type u_2} {γ : Type u_3} [Π (A : α), AddCommMonoid (β A)] (S : Finset γ) (g : γ → Π (A : α), β A) : S.Sum (λ (C : γ), g C) = λ (A : α), S.Sum (λ (C : γ), g C A)
{n : ℕ} {α : Fin (n + 1) → Type u} (x : α (Fin.Last n)) (P : Π (i : Fin n), α (⇑Fin.cast_Succ i)) (i : Fin n) (y : α (⇑Fin.cast_Succ i)) : Fin.snoc (Function.update P i y) x = Function.update (Fin.snoc P x) (⇑Fin.cast_Succ i) y
{x : Type u} [MetricSpace x] [CompactSpace x] [Nonempty x] {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : metric.Hausdorff_dist (set.Range (GromovHausdorff.optimal_GH_injl x Y)) (set.Range (GromovHausdorff.optimal_GH_injr x Y)) = GromovHausdorff.GH_dist x Y
{α : Type u} [OrderedSemiring α] {A B C D : α} [has_exists_Add_of_LE α] (hba : B ≤ A) (hdc : D ≤ C) : A • D + B • C ≤ A • C + B • D
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x : v) : o.oangle x 0 = 0
{α : Type u} [PseudoEmetricSpace α] (δ : ℝ) (E : set α) : Metric.Thickening δ E = (λ (x : α), Emetric.Inf_edist x E) ⁻¹' set.Iio (Ennreal.of_Real δ)
{m : Type u_3} {S : Type u_4} [div_Inv_Monoid m] [set_like S m] [hSM : Subgroup_class S m] {h : S} {x y : m} (hx : x ∈ h) (hy : y ∈ h) : x / y ∈ h
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {S : set 𝕜} {F : 𝕜 → 𝕜} (hF : strict_Convex_on 𝕜 S F) {x y z : 𝕜} (hx : x ∈ S) (hz : z ∈ S) (hxy : x < y) (hyz : y < z) : (F y - F x) / (y - x) < (F z - F y) / (z - y)
{R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] [Nontrivial R] (x : R) : IsAlgebraic R (⇑(Algebra_Map R A) x)
{G : Type u} [Group G] {x : G} (hx : _of_Fin_order x) : _of_Fin_order x⁻¹
{α : Type u} [LinearOrder α] {x y : α} : x < y ∨ y < x ↔ x ≠ y
(n : ℕ) : ∃ (A B C D : ℕ), A ^ 2 + B ^ 2 + C ^ 2 + D ^ 2 = n
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace ↥K] : reflection K * reflection K = 1
(K : Type u) {L : Type v} (E : Type z) [Field K] [Field L] [Field E] [Algebra K L] [Algebra K E] [module.Finite K L] [_alg_IsClosed E] (pB : power_Basis K L) (e : Fin pB.dim ≃ (L →ₐ[K] E)) [_IsSeparable K L] : ⇑(Algebra_Map K E) (Algebra.discr K ⇑(pB.Basis)) = Finset.Univ.Prod (λ (i : Fin pB.dim), (Finset.Filter (λ (j : Fin pB.dim), i < j) Finset.Univ).Prod (λ (j : Fin pB.dim), (⇑(⇑e j) pB.gen - ⇑(⇑e i) pB.gen) ^ 2))
{A B : Cardinal} (ha : Cardinal.aleph0 ≤ A) : A + B = LinearOrder.max A B
{S : Type u_2} [CommRing S] {R : Type u_3} [CommRing R] [Algebra R S] {A : Type u_4} [CommRing A] [Algebra R A] [Algebra S A] [IsScalarTower R S A] {B : power_Basis S A} (hB : IsIntegral R B.gen) [IsDomain S] {x y : A} (hx : ∀ (i : Fin B.dim), IsIntegral R (⇑(⇑(B.Basis.repr) x) i)) (hy : ∀ (i : Fin B.dim), IsIntegral R (⇑(⇑(B.Basis.repr) y) i)) (hmin : minpoly S B.gen = Polynomial.Map (Algebra_Map R S) (minpoly R B.gen)) (i : Fin B.dim) : IsIntegral R (⇑(⇑(B.Basis.repr) (x * y)) i)
{R : Type u} {ι : Type u'} {m₂ : Type v₂} [DecidableEq ι] [Semiring R] [AddCommMonoid m₂] [module R m₂] {m₁' : ι → Type u_1} [Π (i : ι), AddCommMonoid (m₁' i)] [Π (i : ι), module R (m₁' i)] (g : MultilinearMap R m₁' m₂) : g.Comp_Linear_Map (λ (i : ι), LinearMap.Id) = g
{A : Ennreal} (h : A ≠ ⊤) : Add_LE_cancellable A
{α : Type u_1} {β : Type u_2} [UniformSpace α] [UniformSpace β] [CompactSpace α] [SeparatedSpace α] {F : α → β} (h : Continuous F) : uniform_Continuous F
(α : Type u_1) (β : Type u_2) [LinearOrder α] [LinearOrder β] [Encodable α] [DenselyOrdered β] [Nontrivial β] : Nonempty (α ↪o β)
{α : Type u} [non_unital_Ring α] {A B C : α} (h : A ∣ C) : A ∣ B + C ↔ A ∣ B
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type W} {x : C} {R : CategoryTheory.Presieve x} {x₁ x₂ : CategoryTheory.Presieve.FamilyOfElements P ⇑(CategoryTheory.Sieve.generate R)} (t₁ : x₁.compatible) (t₂ : x₂.compatible) : CategoryTheory.Presieve.FamilyOfElements.Restrict _ x₁ = CategoryTheory.Presieve.FamilyOfElements.Restrict _ x₂ → x₁ = x₂
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {S : set E} {F : E → F} (hF : ContDiff_on 𝕜 n F S) : ContDiff_on 𝕜 n (λ (x : E), -F x) S
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {A B : α} (h : A < B) (S : set α) : [S ∈ nhds_within B (set.Iio B), S ∈ nhds_within B (set.Ico A B), S ∈ nhds_within B (set.Ioo A B), ∃ (l : α) (h : l ∈ set.Ico A B), set.Ioo l B ⊆ S, ∃ (l : α) (h : l ∈ set.Iio B), set.Ioo l B ⊆ S].tfae
{α : Type u_2} {β : Type u_3} {F : α → β} (hF : Function.Injective F) : Filter.Tendsto F Filter.cofinite Filter.cofinite
{α : Type u} {β : Type v} [TopologicalSpace α] [PseudoMetricSpace β] {x : α} : Continuous (λ (F : bounded_Continuous_Function α β), ⇑F x)
{γ : Type W} [MetricSpace γ] {x y : γ} : HasNndist.nndist x y = 0 → x = y
{R : Type u_1} {m : Type u_2} [AddCommMonoid m] [CommRing R] [Nontrivial R] [h : Algebra.Finite_Type R (AddMonoid_Algebra R m)] : AddMonoid.fg m
{α : Type u} [TopologicalSpace α] (x : α) [(nhds_within x {x}ᶜ).Ne_IsBot] : Interior {x} = ∅
{m : Type u_1} {n : Type u_2} {R : Type u_3} {S : Type u_4} [CommSemiring R] [CommSemiring S] (F : R →+* S) (A : Matrix m n S) : (Matrix.mv_Polynomial.x m n R).Map (mv_Polynomial.Eval₂ F (λ (P : m × n), A P.fst P.Snd)) = A
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m →* P} (hg : ∀ (y : ↥S), IsUnit (⇑g ↑y)) (x : m) (y : ↥S) : ⇑(F.Lift hg) (F.Mk' x y) = ⇑g x * ↑(⇑(IsUnit.Lift_Right (g.Restrict S) hg) y)⁻¹
{α : Type uu} [DecidableEq α] {l₁ l₂ : List α} (h : ∀ (x : α), x ∈ l₁ → List.count x l₁ ≤ List.count x l₂) : l₁ ++ l₂.Diff l₁ ~ l₂
{α : Type u} {F g : α → α} (h : Function.Commute F g) : set.Inv_on F g (Function.FixedPoints (F ∘ g)) (Function.FixedPoints (F ∘ g))
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 : P) : EuclideanGeometry.angle P1 P2 P2 = Real.Pi / 2
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) : 2 • hb.oangle x (-y) = 2 • hb.oangle x y
{α : Type u_1} {E : Type u_3} [semi_NormedGroup E] {l : Filter α} {F : α → E} (h : Filter.Tendsto (λ (y : α), ∥F y∥) l Filter.at_top) (x : E) : ∀ᶠ (y : α) in l, F y ≠ x
{α : Type u_1} [Preorder α] {A B : α} (h : A ≤ B) : set.Iio A ⊆ set.Iic B
{R : Type u_1} {A : R} [Monoid R] (n : ℕ) (ra : IsRegular A) : IsRegular (A ^ n)
{α : Type u_2} {β : Type u_3} [Ring α] [IsDomain α] [Ring β] (F : β →+* α) (hF : Function.Injective ⇑F) : IsDomain β
{α : Type u} {β : Type v} {γ : Type W} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [conditionally_complete_LinearOrder β] [TopologicalSpace β] [OrderTopology β] [Nonempty γ] {F : α → β} {g : γ → α} (Cf : Continuous_at F (⨅ (i : γ), g i)) (Mf : Monotone F) (h : BddBelow (set.Range g)) : F (⨅ (i : γ), g i) = ⨅ (i : γ), F (g i)
{α : Type u_1} {β : Type u_2} [Fintype α] [Fintype β] (F : α → β) (h : Fintype.Card β < Fintype.Card α) : ∃ (x y : α), x ≠ y ∧ F x = F y
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {n : ℕ} (hn : Finite_dimensional.finrank K v = n.Succ) : Nontrivial v
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (hb : Continuous_at F B) : deriv (λ (u : ℝ), ∫ (x : ℝ) in A..u, F x) B = F B
{R : Type u} [Semiring R] (P q : Polynomial R) (n : ℕ) : (P * q).Coeff n = (Finset.Nat.antidiagonal n).Sum (λ (x : ℕ × ℕ), P.Coeff x.fst * q.Coeff x.Snd)
{C : Type u₁} [CategoryTheory.Category C] {x Y : top} (F : x ⟶ Y) [CategoryTheory.Limits.HasProducts C] {F : top.Presheaf C x} (h : F._sheaf) : (F _* F)._sheaf
(n : ℕ) : Filter.Tendsto (λ (x : ℝ), x ^ n * Real.Exp (-x)) Filter.at_top (nhds 0)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P : P) (h : S.Sum (λ (i : ι), W i) = 1) : ⇑(S.affine_combination (λ (_x : ι), P)) W = P
{α : Type u} [TopologicalSpace α] [LinearOrder α] [order_IsClosed_topology α] [Nonempty α] {S : set α} (hs : IsCompact S) : BddBelow S
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z → B} [TopologicalSpace Z] (h : IsTopologicalFiberBundle F Proj) : Continuous Proj
{α : Type u_1} [TopologicalSpace α] [non_assoc_Ring α] [has_Continuous_Mul α] : has_Continuous_Neg α
{α : Type u} [PseudoEmetricSpace α] {δ : ℝ} (E : set α) : E ⊆ Metric.Cthickening δ E
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {P : P} {S : set P} (hp : P ∈ S) : P ∈ affine_Span k S
{R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] (S : Subalgebra R A) : S.IsAlgebraic ↔ Algebra.IsAlgebraic R ↥S
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasInitial C] [CategoryTheory.Limits.HasPushouts C] : CategoryTheory.Limits.HasBinaryCoproducts C
{R : Type u_1} [CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {C : tensor_Algebra R m → Prop} (h_grade0 : ∀ (r : R), C (⇑(Algebra_Map R (tensor_Algebra R m)) r)) (h_grade1 : ∀ (x : m), C (⇑(tensor_Algebra.ι R) x)) (h_Mul : ∀ (A B : tensor_Algebra R m), C A → C B → C (A * B)) (h_Add : ∀ (A B : tensor_Algebra R m), C A → C B → C (A + B)) (A : tensor_Algebra R m) : C A
{α : Type u} {β : Type v} [TopologicalSpace α] [Preorder α] [t : order_IsClosed_topology α] {F g : β → α} {B : Filter β} {A₁ A₂ : α} [B.Ne_IsBot] (hF : Filter.Tendsto F B (nhds A₁)) (hg : Filter.Tendsto g B (nhds A₂)) (h : F ≤ᶠ[B] g) : A₁ ≤ A₂
{α : Type u_1} [LinearOrder α] [DecidableEq α] {P : Finset α → Prop} (S : Finset α) (h0 : P ∅) (step : ∀ (A : α) (S : Finset α), (∀ (x : α), x ∈ S → x < A) → P S → P (HasInsert.Insert A S)) : P S
{R : Type u_1} [CommRing R] (g : Matrix.special_Linear_Group (Fin 2) R) : _IsCoprime (↑g 1 0) (↑g 1 1)
(α : Type u) [Preorder α] [Nonempty α] [NoMinOrder α] [NoMaxOrder α] : ∃ (F : ℤ → α), StrictAnti F
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [UniformSpace α] [UniformSpace β] [SeparatedSpace α] [LocallyCompactSpace α] [CompactSpace β] [SeparatedSpace β] [UniformSpace γ] (F : α → β → γ) (h : Continuous ↿F) (x : α) : TendstoUniformly F (F x) (nhds x)
{K : Type u_1} [Field K] [number_Field K] : number_Field.ClassNumber K = 1 ↔ _principal_Ideal_Ring ↥(number_Field.Ring_of_integers K)
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) : ∥x - y∥ = ∥x∥ + ∥y∥ ↔ InnerProductGeometry.angle x y = Real.Pi
{𝕜 : Type u} [hnorm : nondiscrete_NormedField 𝕜] {E : Type v} [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Smul 𝕜 E] [CompleteSpace 𝕜] [t2_Space E] {ι : Type u_1} [Fintype ι] (ξ : Basis ι 𝕜 E) : Continuous ⇑(ξ.Equiv_fun)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_6} [NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_10} [semi_NormedGroup E'] [NormedSpace 𝕜 E'] [Ring_hom_isometric σ₁₂] {F : ℕ → (E' →sl[σ₁₂] F)} {g : E' →sl[σ₁₂] F} (hg : Filter.Tendsto (λ (n : ℕ) (x : E'), ⇑(F n) x) Filter.at_top (nhds ⇑g)) (hF : Cauchy_Seq F) : Filter.Tendsto F Filter.at_top (nhds g)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set ℝ} [IntervalIntegral.FTC_Filter A (nhds_within A S) (nhds_within A t)] (hmeas : StronglyMeasurableAtFilter F (nhds_within A t) MeasureTheory.MeasureSpace.Volume) (ha : Continuous_within_at F t A) : HasDerivWithinAt (λ (u : ℝ), ∫ (x : ℝ) in u..B, F x) (-F A) S A
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x : v) (θ : Real.Angle) : ⇑(o.rotation θ) x = x ↔ x = 0 ∨ θ = 0
{R : Type u} [non_assoc_Semiring R] (S : set R) : ↑(Subsemiring.Closure S) = ↑(AddSubmonoid.Closure ↑(Submonoid.Closure S))
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {S : Finset ι} {v : ι → E} (hv : Orthonormal 𝕜 v) {A : ι → ι → 𝕜} : S.Sum (λ (i : ι), S.Sum (λ (j : ι), A i j • HasInner.inner (v j) (v i))) = S.Sum (λ (k : ι), A k k)
{K : Type u} {v v₁ : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [AddCommGroup v₁] [module K v₁] : Nonempty (v ≃ₗ[K] v₁) ↔ module.rank K v = module.rank K v₁
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e e' : LocalHomeomorph α β} (h : e ≈ e') : set.Eq_on ⇑e ⇑e' e.to_local_Equiv.Source
{α : Type u_1} [Linear_ordered_Field α] [floor_Semiring α] (m n : ℕ) : ⌊↑m / ↑n⌋₊ = m / n
{K L : Type} [Field K] [Field L] [_alg_IsClosed K] [_alg_IsClosed L] (P : ℕ) [Char_P K P] [Char_P L P] (hK : Cardinal.aleph0 < Cardinal.Mk K) (hKL : Cardinal.Mk K = Cardinal.Mk L) : K ≃+* L
{α : Type u_1} [hα : UniformSpace α] (h : Uniformity α = Filter.principal Id_Rel) : DiscreteTopology α
{B m D : ℕ} (hb : 2 ≤ B) (hD : D ∈ B.digits m) : D < B
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) : o.oangle x (⇑(o.rotation θ) y) = o.oangle x y + θ
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : α ≃ₜ β) {B : β} {F : β → E} {g : β → F} : F =O[nhds B] g ↔ (F ∘ ⇑e) =O[nhds (⇑(e.Symm) B)] (g ∘ ⇑e)
(G : Add_Subgroup ℝ) : Dense ↑G ∨ ∃ (A : ℝ), G = Add_Subgroup.Closure {A}
{n : ℕ} {α : Type u_1} [Preorder α] {F : Fin (n + 1) → α} : StrictMono F ↔ ∀ (i : Fin n), F (⇑Fin.cast_Succ i) < F i.Succ
{R : Type u_1} [CommRing R] {m : Submonoid R} {S : Type u_2} [CommRing S] [Algebra R S] {Rₘ : Type u_4} {Sₘ : Type u_5} [CommRing Rₘ] [CommRing Sₘ] [Algebra R Rₘ] [IsLocalization m Rₘ] [Algebra S Sₘ] [IsLocalization (Algebra.Algebra_Map_Submonoid S m) Sₘ] (h : Algebra.IsIntegral R S) : (IsLocalization.Map Sₘ (Algebra_Map R S) _).IsIntegral
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasWideEqualizers C] {t : C} (hT : ∀ (x : C), Nonempty (t ⟶ x)) : CategoryTheory.Limits.HasInitial C
{x y : Pgame} : x.lf y ↔ (∃ (i : y.Left_moves), x ≤ y.move_Left i) ∨ ∃ (j : x.Right_moves), x.move_Right j ≤ y
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x : v} (hx : x ≠ 0) (θ : Real.Angle) : o.oangle x (⇑(o.rotation θ) x) = θ
{G : Type u_1} {h : Type u_2} [Group G] {N : Subgroup G} [Group h] {F : G →* h} (hN : N = F.Ker) (tH : Monoid._torsion h) (tN : Monoid._torsion ↥N) : Monoid._torsion G
{α : Type u_1} {β : Type u_2} (e : local_Equiv α β) : e.Symm.Trans e ≈ local_Equiv.of_set e.Target
{α : Type u_1} {β : Type u_2} [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β} (h : Function.Semiconj g ⇑fa ⇑fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') : Function.Semiconj g' ⇑fb ⇑fa
{v : Type u_1} (α : Type u_2) (G : SimpleGraph v) [Decidable_Rel G.Adj] [MulZeroOneClass α] [Nontrivial α] : _.to_graph = G
{α : Type u_1} {β : Type u_2} {e e' : local_Equiv α β} (h : e ≈ e') : set.Eq_on ⇑(e.Symm) ⇑(e'.Symm) e.Target
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryProducts C] [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Limits.HasEqualizers C
{R : Type u_1} {m : Type u_2} [CommSemiring R] [AddCommMonoid m] [module R m] (S : Type u_3) [CommMonoid S] [Distrib_MulAction S m] [SmulCommClass S R m] : module._torsion' m S ↔ Submodule.torsion' R m S = ⊤
(ι : Type u_1) [Fintype ι] : IsClosed (StdSimplex ℝ ι)
{α : Type u_1} [Preorder α] [SuccOrder α] {A B : α} [NoMaxOrder α] : A < B → Order.Succ A < Order.Succ B
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} (z : v) (h : InnerProductGeometry.angle x y = Real.Pi) : InnerProductGeometry.angle x z + InnerProductGeometry.angle y z = Real.Pi
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y : v} (θ : Real.Angle) : o.oangle x y = θ ↔ x ≠ 0 ∧ y ≠ 0 ∧ y = (∥y∥ / ∥x∥) • ⇑(o.rotation θ) x ∨ θ = 0 ∧ (x = 0 ∨ y = 0)
{β : Type u} {α : Type v} {S : Finset α} {A : α} {F : α → β} [AddCommMonoid β] [DecidableEq α] (h : A ∉ S → F A = 0) : (HasInsert.Insert A S).Sum (λ (x : α), F x) = S.Sum (λ (x : α), F x)
{α : Type u_1} {ι : sort u_4} [CompleteLattice α] (F : ι → α) : (⨅ (i : {i // F i ≠ ⊤}), F ↑i) = ⨅ (i : ι), F i
{α : Type u} [PseudoMetricSpace α] {S : set α} : metric.Hausdorff_dist S (Closure S) = 0
{𝕜 : Type u_1} {_x : Ring 𝕜} {E : Type u_2} [semi_NormedGroup E] {_x_1 : module 𝕜 E} {S : Submodule 𝕜 E} (x : ↥S) : ∥↑x∥ = ∥x∥
{n : ℕ} {F : Typevec (n + 1) → Type u} [Mvfunctor F] [q : Mvqpf F] {α : Typevec n} (r : Mvqpf.Cofix F α → Mvqpf.Cofix F α → Prop) (h : ∀ (x y : Mvqpf.Cofix F α), r x y → Mvfunctor.Liftr' (α.Rel_Last' r) x.dest y.dest) (x y : Mvqpf.Cofix F α) : r x y → x = y
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] {S : Finset α} {t : Finset β} {F : α → β} {W : α → m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (hF : ∀ (A : α), A ∈ S → F A ∈ t) (hb : S.Sum (λ (x : α), W x) < t.Card • B) : ∃ (y : β) (h : y ∈ t), (Finset.Filter (λ (x : α), F x = y) S).Sum (λ (x : α), W x) < B
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] {F : Filter α} {A : α} [F.Ne_IsBot] : F ≤ nhds A → F.limsup = A
{S : Type u} [has_Mul S] {A x y : S} (h : SemiconjBy A x y) : A * x = y * A
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] {K : set α} (F : C(α, β)) (hK : IsCompact K) {U : set β} (hU : IsOpen U) (hF : F ∈ Continuous_Map.IsCompact_IsOpen.gen K U) : ∃ (v : set (β × β)) (h : v ∈ Uniformity β), IsOpen v ∧ Continuous_Map.IsCompact_conv_nhd K v F ⊆ Continuous_Map.IsCompact_IsOpen.gen K U
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.SimplicialObject C) {n : ℕ} {i : Fin (n + 1)} : x.σ i ≫ x.δ (⇑Fin.cast_Succ i) = 𝟙 (x.obj (Opposite.Op (SimplexCategory.Mk n)))
{n : ℕ} {α : Fin (n + 1) → Type u} (q : Π (i : Fin (n + 1)), α i) : Fin.Cons (q 0) (Fin.tail q) = q
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (S : Submodule K v) : module.rank K ↥S ≤ 1 ↔ ∃ (v₀ : v) (h : v₀ ∈ S), S ≤ Submodule.Span K {v₀}
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] (v W : E) (h : W ∈ K) : HasInner.inner (v - Orthogonal_projection_fn K v) W = 0
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {A B : α} (hab : A < B) (S : set α) : [S ∈ nhds_within A (set.ici A), S ∈ nhds_within A (set.icc A B), S ∈ nhds_within A (set.Ico A B), ∃ (u : α) (h : u ∈ set.ioc A B), set.Ico A u ⊆ S, ∃ (u : α) (h : u ∈ set.ioi A), set.Ico A u ⊆ S].tfae
{C : Type u} [CategoryTheory.Category C] {P q R : C} (F : P ⟶ q) (g : q ⟶ R) [CategoryTheory.StrongEpi F] [CategoryTheory.StrongEpi g] : CategoryTheory.StrongEpi (F ≫ g)
{R : Type u_1} [Semiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {N : Type u_3} [AddCommMonoid N] [module R N] {ι : Type u_6} [DecidableEq ι] {m₂ : Type u_7} [AddCommMonoid m₂] [module R m₂] {m₃ : Type u_8} [AddCommMonoid m₃] [module R m₃] (F : AlternatingMap R m N ι) (g₁ : m₂ →ₗ[R] m) (g₂ : m₃ →ₗ[R] m₂) : (F.Comp_Linear_Map g₁).Comp_Linear_Map g₂ = F.Comp_Linear_Map (g₁.Comp g₂)
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A B : α} (ha : 1 < A) (hb : 1 < B) : 1 < A * B
{R : Type u_1} [CommSemiring R] (S : Subsemiring R) (m : Multiset R) : (∀ (A : R), A ∈ m → A ∈ S) → m.Prod ∈ S
{n n' : ℕ} (m : ℕ) (i : Fin n') (h : n' = n) : ⇑(Fin.cast_Add m) (⇑(Fin.cast h) i) = ⇑(Fin.cast _) (⇑(Fin.cast_Add m) i)
{F : Type} [Field F] (q : ℕ) [hq : Fact (Nat.Prime q)] [hF : Char_P F q] (g g' : Polynomial F) (m m' : ℕ) (h_expand : ⇑(Polynomial.expand F (q ^ m)) g = ⇑(Polynomial.expand F (q ^ m')) g') (h : m < m') (hg : g.IsSeparable) : g.Nat_degree = g'.Nat_degree
{α : Type u_1} {n : Type u_4} [comm_Semigroup α] [AddCommMonoid α] [Fintype n] [AddCommGroup n] (v W : n → α) : (Matrix.circulant v).Mul (Matrix.circulant W) = (Matrix.circulant W).Mul (Matrix.circulant v)
{α : Type u} [PseudoMetricSpace α] (x y : α) : HasNndist.nndist x y = (HasDist.dist x y).to_Nnreal
(α : Type u_1) [PartialOrder α] : WellFounded Gt ↔ ∀ (A : ℕ →o α), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑A n = ⇑A m
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : HasInner.inner (x + y) (x + y) = HasInner.inner x x + 2 * HasInner.inner x y + HasInner.inner y y
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {n : ℕ} [Fact (Finite_dimensional.finrank 𝕜 E = n + 1)] {v : E} (hv : v ≠ 0) : Finite_dimensional.finrank 𝕜 ↥(Submodule.Span 𝕜 {v})ᗮ = n
{v : Type u_4} [InnerProductSpace ℂ v] (t : v →ₗ[ℂ] v) (x y : v) : HasInner.inner (⇑t y) x = (HasInner.inner (⇑t (x + y)) (x + y) - HasInner.inner (⇑t (x - y)) (x - y) + Complex.i * HasInner.inner (⇑t (x + Complex.i • y)) (x + Complex.i • y) - Complex.i * HasInner.inner (⇑t (x - Complex.i • y)) (x - Complex.i • y)) / 4
{ι₁ : Type u_1} {ι₂ : Type u_2} {R : Type u_3} {R₂ : Type u_4} {S : Type u_5} {S₂ : Type u_6} {m : Type u_7} {N : Type u_8} {P : Type u_9} [CommRing R] [CommRing S] [CommRing R₂] [CommRing S₂] [AddCommGroup m] [AddCommGroup N] [AddCommGroup P] [module R m] [module S N] [module R₂ P] [module S₂ P] [SmulCommClass S₂ R₂ P] {ρ₁₂ : R →+* R₂} {σ₁₂ : S →+* S₂} (B₁ : Basis ι₁ R m) (B₂ : Basis ι₂ S N) {B B' : m →ₛₗ[ρ₁₂] N →ₛₗ[σ₁₂] P} (h : ∀ (i : ι₁) (j : ι₂), ⇑(⇑B (⇑B₁ i)) (⇑B₂ j) = ⇑(⇑B' (⇑B₁ i)) (⇑B₂ j)) : B = B'
{P : ℕ} : Summable (λ (n : ℕ), (↑n ^ P)⁻¹) ↔ 1 < P
{α : Type u_1} {β : Type u_2} [CompleteLattice α] {F : Filter β} : F.liminf (λ (x : β), ⊤) = ⊤
{α : Type u} [MetricSpace α] (x : ℕ → α) (A B : α) : HasDist.dist (Kuratowski_Embedding.Embedding_of_Subset x A) (Kuratowski_Embedding.Embedding_of_Subset x B) ≤ HasDist.dist A B
{α : Type u_1} {β : Type u_2} [Fintype α] [CompleteLattice β] (F : α → β) : Finset.Univ.Sup F = supr F
{α : Type u_1} [generalized_boolean_Algebra α] [Decidable_Rel Disjoint] [Decidable_Rel has_LE.LE] (u v : α) (S : Finset α) : (Uv.Compression u v S).Card = S.Card
{R : Type u} {ι : Type W} (S : Finset ι) [CommSemiring R] [no_Zero_divisors R] (F : ι → Polynomial R) [Nontrivial R] : (S.Prod (λ (i : ι), F i)).degree = S.Sum (λ (i : ι), (F i).degree)
 : ⇑LinearMap.det Complex.Conj_ae.to_Linear_Map = -1
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {v₁ v₂ : m} (h : SameRay R v₁ v₂) : ∃ (A B : R), 0 ≤ A ∧ 0 ≤ B ∧ A + B = 1 ∧ v₁ = A • (v₁ + v₂) ∧ v₂ = B • (v₁ + v₂)
{α : Type u} [PseudoEmetricSpace α] {S : set α} (hs : IsCompact S) : ∃ (t : set α) (h : t ⊆ S), t.countable ∧ S ⊆ Closure t
{S : Type v} [CommRing S] {R : Type u} (C : ℤ →+* S) (F : mv_Polynomial R ℤ →+* S) (x : mv_Polynomial R ℤ) : mv_Polynomial.Eval₂ C (⇑F ∘ mv_Polynomial.x) x = ⇑F x
{α : Type u_1} [Add_Semigroup α] (x y : α) : has_Add.Add x ∘ has_Add.Add y = has_Add.Add (x + y)
{A : Type u} {B : Type v} {ι : Type W} [CommRing A] [CommRing B] [Algebra A B] [Fintype ι] [DecidableEq ι] (B : ι → B) (P : Matrix ι ι A) : Algebra.discr A (Matrix.vec_Mul B (P.Map ⇑(Algebra_Map A B))) = P.det ^ 2 * Algebra.discr A B
{B : ℕ} {S : set ℕ} (hb : B ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) {n : ℕ} (hbn : B ≤ n) : n ∈ S
{G : Type u} [AddGroup G] (h : Add_Subgroup G) (h : Subsingleton (G ⧸ h)) : h = ⊤
{α : Type u_1} {m : Type u_5} [has_Zero m] {F g : α →₀ m} : ⇑F = ⇑g ↔ F = g
{R : Type u} [Ring R] : CategoryTheory.Limits.HasCokernels (module R)
{α : Type u_1} {β : Type u_2} (t : α) (ts ys : List α) (F : List α → β) : List.Map F (List.PermutationsAux2 t ts List.Nil ys Id).Snd = (List.PermutationsAux2 t ts List.Nil ys F).Snd
{F : ℝ → ℝ} (hF : Differentiable ℝ F) (hF'_anti : StrictAnti (deriv F)) : strict_ConcaveOn ℝ set.Univ F
{α : Type u} [PseudoMetricSpace α] {x : α} : Metric.diam {x} = 0
{n : ℕ} : 0 < n → 0 < SzemerediRegularity.step_bound n
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [module 𝕜 E] {S : set E} (hs : Convex 𝕜 S) (z : E) : Convex 𝕜 ((λ (x : E), z + x) ⁻¹' S)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : LocalHomeomorph α β} {S : set α} {t : set β} : e._image S t → e.to_local_Equiv.Target ∩ ⇑(e.Symm) ⁻¹' S = e.to_local_Equiv.Target ∩ t
{α : Type u_1} (r : α → α → Prop) [IsTrans α r] (F : ℕ → α) : ∃ (g : ℕ ↪o ℕ), (∀ (m n : ℕ), m < n → r (F (⇑g m)) (F (⇑g n))) ∨ ∀ (m n : ℕ), m < n → ¬r (F (⇑g m)) (F (⇑g n))
{m : Type u_1} [AddMonoid m] {x : m} : x ∈ Multiples x
 : Filter.Tendsto Complex.Exp (Filter.comap Complex.re Filter.at_top) (Filter.comap Complex.Abs Filter.at_top)
{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {S : β → β → Prop} : Function.Injective Coe_fn
{R S : Type u} [CommRing R] [CommRing S] (m : Submonoid R) (R' : Type u) [CommRing R'] [Algebra R R'] [Algebra R' S] [Algebra R S] [IsScalarTower R R' S] [IsLocalization m R'] (S : set S) (x : S) (hx : x ∈ Algebra.Adjoin R' S) : ∃ (t : ↥m), t • x ∈ Algebra.Adjoin R S
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Finite_coproducts C] [CategoryTheory.Limits.HasCoequalizers C] : CategoryTheory.Limits.has_Finite_colimits C
{G : Type u_1} [Group G] {k : set G} {P : G → Prop} {x : G} (h : x ∈ Subgroup.Closure k) (Hk : ∀ (x : G), x ∈ k → P x) (h1 : P 1) (HMul : ∀ (x y : G), P x → P y → P (x * y)) (Hinv : ∀ (x : G), P x → P x⁻¹) : P x
{α : Type u_1} {β : Type u_2} [LinearOrder α] [SuccOrder α] [Preorder β] {F : α → β} (hF : Antitone F) : Pairwise (Disjoint on λ (n : α), set.ioc (F (Order.Succ n)) (F n))
{G : Type u} {x : G} [AddMonoid G] : 0 < Add_order_of x ↔ _of_Fin_Add_order x
{R : Type u} [CommSemiring R] [Star_Ring R] {x : R} : ⇑(Star_Ring_end R) x = HasStar.Star x
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (v : v) (nz : v ≠ 0) : Finite_dimensional.finrank K v = 1 ↔ ∀ (W : v), ∃ (C : K), C • v = W
{G : Type W} [TopologicalSpace G] [has_Inv G] [has_Mul G] [has_Continuous_Mul G] [has_Continuous_Inv G] : Continuous (λ (g : G × G), g.fst * g.Snd * (g.fst)⁻¹)
{E : Type u_3} [semi_NormedGroup E] (u v : E) : ∥v∥₊ ≤ ∥u∥₊ + ∥u - v∥₊
{α : Type u_1} {β : Type u_2} [AddCommMonoid α] [TopologicalSpace α] : has_Sum (λ (B : β), 0) 0
{α : Type u_1} {m : Type u_5} {N : Type u_6} [CommMonoid m] [CommMonoid N] {S : set α} {F : α → m} (g : m →* N) (h₀ : (S ∩ Function.MulSupport F).Finite) : ⇑g (finprod (λ (j : α), finprod (λ (h : j ∈ S), F j))) = finprod (λ (i : α), finprod (λ (h : i ∈ S), ⇑g (F i)))
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra A B] [Algebra R B] [Algebra R A] [IsScalarTower R A B] {x : B} (h : IsIntegral R x) : IsIntegral A x
{α : Type u_1} [TopologicalSpace α] [t2_Space α] [MeasurableSpace α] [BorelSpace α] {F g : (ℕ → ℕ) → α} (hF : Continuous F) (hg : Continuous g) (h : Disjoint (set.Range F) (set.Range g)) : MeasureTheory.measurably_IsSeparable (set.Range F) (set.Range g)
{n : ℕ+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [Ne_Zero ↑↑n] (hn : Prime_Pow ↑n) [IsCyclotomicExtension {n} K L] (hirr : Irreducible (Polynomial.cyclotomic ↑n K)) (h : n ≠ 2) : ⇑(Algebra.norm K) (IsCyclotomicExtension.zeta n K L - 1) = ↑(↑n.min_fac)
{α : Type u_1} {β : Type u_2} [Group α] [comm_Group β] {F g : α → β} (hF : _Group_hom F) (hg : _Group_hom g) : _Group_hom (λ (A : α), F A * g A)
{R : Type u} {n : ℕ} {m : Fin n.Succ → Type W} {m₂ : Type W₂} [Semiring R] [Π (i : Fin n.Succ), AddCommMonoid (m i)] [AddCommMonoid m₂] [Π (i : Fin n.Succ), module R (m i)] [module R m₂] [Π (i : Fin n.Succ), TopologicalSpace (m i)] [TopologicalSpace m₂] (F : Continuous_MultilinearMap R m m₂) (m : Π (i : Fin n), m i.Succ) (C : R) (x : m 0) : ⇑F (Fin.Cons (C • x) m) = C • ⇑F (Fin.Cons x m)
{G : Type u} {n : ℕ} [Fintype G] [Left_cancel_Monoid G] (x : G) : order_of (x ^ n) = order_of x / (order_of x).Gcd n
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] [PolishSpace β] {F : α → β} (hF : IsClosed_Embedding F) : PolishSpace α
{Γ : Type u_1} [Inhabited Γ] (l : Turing.List_blank Γ) : ∃ (A : Γ) (l' : Turing.List_blank Γ), l = Turing.List_blank.Cons A l'
{E : Type u_2} [semi_NormedGroup E] [NormedSpace ℝ E] {S : set E} (hs₀ : 0 ∈ S) (hs₁ : Convex ℝ S) (hs₂ : IsOpen S) {x₀ : E} (hx₀ : x₀ ∉ S) : ∃ (F : E →L[ℝ] ℝ), ⇑F x₀ = 1 ∧ ∀ (x : E), x ∈ S → ⇑F x < 1
{B m D : ℕ} : D ∈ (B + 2).digits m → D < B + 2
{α : sort u_1} {P : α → Prop} (P : ∃ (A : α), P A) : P P.Some
{α : Type u} [PseudoEmetricSpace α] {δ : ℝ} {S : set α} {x : α} : Emetric.Inf_edist x S ≤ Emetric.Inf_edist x (Metric.Cthickening δ S) + Ennreal.of_Real δ
{m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (A : Matrix m m R) (C : Matrix n m R) (D : Matrix n n R) : (Matrix.from_blocks A 0 C D).det = A.det * D.det
{α : Type u_1} [canonically_ordered_AddMonoid α] [HasSub α] [HasOrderedSub α] {A B C : α} [ContravariantClass α α has_Add.Add has_LE.LE] (h : C ≤ B) : A < B - C ↔ A + C < B
{R : Type u_4} [Linear_ordered_CommRing R] (A B : R) : 2 * A * B ≤ A ^ 2 + B ^ 2
(A : Type u_2) [CommRing A] [IsDomain A] (K : Type u_1) [Field K] [Algebra A K] [_fraction_Ring A K] : IsDedekindDomain A ↔ IsNoetherian_Ring A ∧ Ring.dimension_LE_One A ∧ ∀ {x : K}, IsIntegral A x → (∃ (y : A), ⇑(Algebra_Map A K) y = x)
{A B C m : ℕ} (hmc : m.Gcd C = 1) (h : C * A ≡ C * B [Mod m]) : A ≡ B [Mod m]
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x ⟶ Y} {t : CategoryTheory.Limits.Cofork F g} {Z Z' : C} (q : Z ⟶ Z') (ht : CategoryTheory.Limits.IsColimit t) (k : t.x ⟶ Z) : ↑(⇑(CategoryTheory.Limits.Cofork._Colimit.hom_is_iso ht Z') (k ≫ q)) = ↑(⇑(CategoryTheory.Limits.Cofork._Colimit.hom_is_iso ht Z) k) ≫ q
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMinOrder α] [DenselyOrdered α] {A : α} {S : set α} : S ∈ nhds_within A (set.Iio A) ↔ ∃ (l : α) (h : l ∈ set.Iio A), set.Ico l A ⊆ S
{R : Type u_1} {m : Type u_2} [CommRing R] [AddCommGroup m] [module R m] {ι : Type u_3} [DecidableEq ι] {S : Finset ι} {q : ι → R} (hq : ↑S.Pairwise (_IsCoprime on q)) (hM : module._IsTorsionBy R m (S.Prod (λ (i : ι), q i))) : direct_Sum._internal (λ (i : ↥S), Submodule.IsTorsionBy R m (q ↑i))
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : Vector_Span k S = Submodule.Span k (S -ᵥ S)
(F : Type u) (K : Type v) (A : Type W) [Field F] [Field K] [AddCommGroup A] [Algebra F K] [module K A] [module F A] [IsScalarTower F K A] : (module.rank F K).Lift * (module.rank K A).Lift = (module.rank F A).Lift
{α : Type u_1} [generalized_boolean_Algebra α] [Decidable_Rel Disjoint] [Decidable_Rel has_LE.LE] (u v A : α) : Uv.compress u v (Uv.compress u v A) = Uv.compress u v A
{α : Type u_1} {r : α → α → Prop} (h : Reflexive r) {x y : α} : x ≠ y → r x y ↔ r x y
{α : Type u} [PseudoMetricSpace α] {S : set α} {F : α → ℝ} (K : Nnreal) (h : ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → F x ≤ F y + ↑K * HasDist.dist x y) : LipschitzOnWith K F S
{𝕜 : Type u_1} [_R_or_C 𝕜] {E : Type u_2} {E' : Type u_3} [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 E'] (F : E ≃ₗᵢ[𝕜] E') (P : Submodule 𝕜 E) [CompleteSpace ↥P] (x : E') : ↑(⇑(Orthogonal_projection (Submodule.Map ↑(F.to_Linear_Equiv) P)) x) = ⇑F ↑(⇑(Orthogonal_projection P) (⇑(F.Symm) x))
{α : Type u} {β : Type v} (F : α → β) (l₁ : Filter α) (l₂ : Filter β) : Filter.Tendsto F l₁ l₂ ↔ ∀ (g : Ultrafilter α), ↑g ≤ l₁ → Filter.Tendsto F ↑g l₂
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {C : ℂ} {r R : ℝ} (h0 : 0 < r) (hle : r ≤ R) {F : ℂ → E} {S : set ℂ} (hs : S.countable) (hc : Continuous_on F (metric.IsClosed_ball C R  Metric.Ball C r)) (hD : ∀ (z : ℂ), z ∈ Metric.Ball C R  metric.IsClosed_ball C r  S → Differentiable_at ℂ F z) : ∮ (z : ℂ) in C(C, R), F z = ∮ (z : ℂ) in C(C, r), F z
{A : Type u_4} [CommRing A] [IsDomain A] {K : Type u_5} [Field K] {L : Type u_7} [Field L] [Algebra A K] [_fraction_Ring A K] {g : A →+* L} (hg : Function.Injective ⇑g) (x : A) (y : ↥(non_Zero_divisors A)) : ⇑(_fraction_Ring.Lift hg) (IsLocalization.Mk' K x y) = ⇑g x / ⇑g ↑y
{v : ℕ → ℝ} {C : ℝ} (h₀ : 0 < v 0) (hc : 1 < C) (hu : ∀ (n : ℕ), C * v n ≤ v (n + 1)) : Filter.Tendsto v Filter.at_top Filter.at_top
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : set P} {P1 P2 : P} (hp1 : P1 ∈ SpanPoints k S) (hp2 : P2 ∈ SpanPoints k S) : P1 -ᵥ P2 ∈ Vector_Span k S
(G : Type u_1) [Group G] : IsAscendingCentralSeries (upper_central_series G)
{G : Type u_1} [Group G] [hH : Group.IsNilpotent G] [Nontrivial G] : Group.nilpotency_class G = Group.nilpotency_class (G ⧸ Subgroup.Center G) + 1
(A B : Nnreal) {P q : ℝ} (hpq : P.IsConjugateExponent q) : A * B ≤ A ^ P / P.to_Nnreal + B ^ q / q.to_Nnreal
{P : ℕ} [Fact (Nat.Prime P)] : P % 2 = 1 ↔ P ≠ 2
 : ⇑fourier_series = fourier_Lp 2
{α : Type u} {β : Type v} {γ : Type W} (g : β → γ) (F : α → β) : List.Map g ∘ List.Map F = List.Map (g ∘ F)
{R : Type u_1} {S : Type u_2} [EuclideanDomain R] [CommRing S] [IsDomain S] [Algebra R S] (abv : AbsoluteValue R ℤ) {ι : Type u_5} [DecidableEq ι] [Fintype ι] (bS : Basis ι R S) (A : S) {y : ℤ} (hy : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) A) k) ≤ y) : ⇑abv (⇑(Algebra.norm R) A) ≤ class_Group.norm_bound abv bS * y ^ Fintype.Card ι
{R : Type u_1} [Mul_Zero_class R] : ¬IsRightRegular 0 ↔ Nontrivial R
(x y : ℤ) : ↑(x.Gcd y) = x * x.Gcd_A y + y * x.Gcd_B y
{𝕂 : Type u_1} {𝔸 : Type u_2} [_R_or_C 𝕂] [normed_CommRing 𝔸] [normed_Algebra 𝕂 𝔸] [CompleteSpace 𝔸] {x : 𝔸} : HasStrictFderivAt (Exp 𝕂) (Exp 𝕂 x • 1) x
{ι : Type u₁} {k : Type u₂} {v : Type u₃} {P : Type u₄} [AddCommGroup v] [AddTorsor v P] [Ring k] [module k v] (B : affine_Basis ι k P) [Fintype ι] (B₂ : affine_Basis ι k P) (x : P) : Matrix.vec_Mul (⇑(B₂.coords) x) (B.to_Matrix B₂.points) = ⇑(B.coords) x
{K : Type u_1} [_R_or_C K] : ⇑_R_or_C.re _R_or_C.i = 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {n : ℕ} (S1 S2 : Affine.Simplex k P n) : S1 = S2 ↔ ∀ (i : Fin (n + 1)), S1.points i = S2.points i
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x Y : C} (F g : x ⟶ Y) [CategoryTheory.Limits.HasBinaryBiproduct Y Y] : F + g = CategoryTheory.Limits.biprod.Lift F g ≫ CategoryTheory.Limits.biprod.Desc (𝟙 Y) (𝟙 Y)
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {R₁ R₂ : ℝ} {F : ℂ → E} {C : ℂ} (hD : DifferentiableOn ℂ F (Metric.Ball C R₁)) (h_maps : set.maps_to F (Metric.Ball C R₁) (Metric.Ball (F C) R₂)) (h₀ : 0 < R₁) : ∥deriv F C∥ ≤ R₂ / R₁
{α : Type u} [PseudoMetricSpace α] {S : set α} {x y : α} (h : y ∈ S) : metric.Inf_dist x S ≤ HasDist.dist x y
{m : Type u_1} [has_Add m] (C : Add_Con m) : Add_Con_gen ⇑C = C
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [module 𝕜 E] {x z : E} {S : set E} (hs : Star_Convex 𝕜 (z + x) S) : Star_Convex 𝕜 x ((λ (x : E), z + x) ⁻¹' S)
{α : Type u_1} [IsEmpty α] (S : Finset α) : S = ∅
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [CompleteSpace E] (v : E) : ⇑(reflection (Submodule.Span 𝕜 {v})ᗮ) v = -v
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} [DecidableEq β'] [DecidableEq γ] [DecidableEq δ] {S : Finset α} {t : Finset β} {F : α → β' → γ} {g : β → β'} {F' : β → α → δ} {g' : δ → γ} (h_Right_anticomm : ∀ (A : α) (B : β), F A (g B) = g' (F' B A)) : Finset.image₂ F S (Finset.image g t) = Finset.image g' (Finset.image₂ F' t S)
{ι : Type u_1} {N : Type u_5} [ordered_CommMonoid N] {F g : ι → N} {S : Finset ι} (h : ∀ (i : ι), i ∈ S → F i ≤ g i) : S.Prod (λ (i : ι), F i) ≤ S.Prod (λ (i : ι), g i)
{α : Type u_2} {β : Type u_3} [has_Zero α] [has_Zero β] [SmulWithZero α β] {S : set β} (h : S.Nonempty) : 0 • S = 0
{R : Type u_1} [Ring R] [TopologicalSpace R] [nonarchimedean_Ring R] (U : IsOpen_Add_Subgroup R) : ∃ (v : IsOpen_Add_Subgroup R), ↑v * ↑v ⊆ ↑U
{α : Type u} {β : Type v} [Linear_ordered_Field α] [TopologicalSpace α] [OrderTopology α] {l : Filter β} {F g : β → α} {C : α} (hC : C < 0) (hF : Filter.Tendsto F l Filter.at_top) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (λ (x : β), F x * g x) l Filter.at_IsBot
{α : Type u_1} [has_LE α] {A : α} : _IsBot A → _top (⇑order_dual.to_dual A)
{𝕜 : Type u_2} {E : Type u_5} {F : Type u_6} [TopologicalSpace 𝕜] [CommSemiring 𝕜] [AddCommMonoid E] [module 𝕜 E] [AddCommMonoid F] [module 𝕜 F] {B : E →ₗ[𝕜] F →ₗ[𝕜] 𝕜} (hB : Function.Injective ⇑B) : Embedding (λ (x : WeakBilin B) (y : F), ⇑(⇑B x) y)
 : {P : ℕ | Nat.Prime P}.Infinite
(α : Type u) (β : Type v) : Nonempty (α ↪ β) ∨ Nonempty (β ↪ α)
{n : ℕ} {i j : Fin (n + 2)} (h : i ≤ j) : SimplexCategoryδ i ≫ SimplexCategoryδ j.Succ = SimplexCategoryδ j ≫ SimplexCategoryδ (⇑Fin.cast_Succ i)
(P : ℕ) [hp : Fact (Nat.Prime P)] : WittVector.IsPoly P (λ (R : Type u_1) (_Rcr : CommRing R), witt_Vector.frobenius_fun)
{m : Type u_6} {N : Type u_7} [has_Add m] [has_Add N] (F : m ≃+ N) (x y : m) : ⇑F (x + y) = ⇑F x + ⇑F y
{ι : Type u} {x : Type v} [TopologicalSpace x] [ParacompactSpace x] {S : set x} (hs : IsClosed S) (u : ι → set x) (uo : ∀ (i : ι), IsOpen (u i)) (us : S ⊆ ⋃ (i : ι), u i) : ∃ (v : ι → set x), (∀ (i : ι), IsOpen (v i)) ∧ (S ⊆ ⋃ (i : ι), v i) ∧ locally_Finite v ∧ ∀ (i : ι), v i ⊆ u i
{ι : Type u_1} {v : Type u} [CategoryTheory.Category v] [CategoryTheory.Limits.HasZeroMorphisms v] {C : Complex_shape ι} (C : homological_Complex v C) {i j j' : ι} (rij : C.Rel i j) (rij' : C.Rel i j') : C.D i j' ≫ CategoryTheory.Eq_to_hom _ = C.D i j
{α : Type u} [Preorder α] {S : set α} {A : α} (h : IsLub S A) : BddAbove S
{α : sort u_1} {β : sort u_2} {γ : sort u_3} {F : α → β → γ} (hF : Function.Injective2 F) [Nonempty β] : Function.Injective F
{R : Type u} [CommRing R] [IsDomain R] [_principal_Ideal_Ring R] {N : Type (max u v)} [AddCommGroup N] [module R N] {P : R} (hp : Irreducible P) (hN : module._torsion' N ↥(Submonoid.Powers P)) [h' : module.Finite R N] : ∃ (D : ℕ) (k : Fin D → ℕ), Nonempty (N ≃ₗ[R] direct_Sum (Fin D) (λ (i : Fin D), R ⧸ Submodule.Span R {P ^ k i}))
(S : set ℕ+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [IsDomain B] [IsNoetherian_Ring A] [Fintype ↥S] [IsCyclotomicExtension S A B] : Algebra.IsIntegral A B
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {α β γ : ↥(IsSolvableByRad F E)} (hγ : γ ∈ F⟮α, β⟯) (hα : IsSolvableByRad.P α) (hβ : IsSolvableByRad.P β) : IsSolvableByRad.P γ
{k k' : Turing.ToPartrec.Cont} {v : List ℕ} : Turing.ToPartrec.step_ret (k.then k') v = (Turing.ToPartrec.step_ret k v).then k'
{α : Type u_1} [LinearOrder α] [TopologicalSpace α] [IsCompact_icc_Space α] {A B : α} : IsCompact (set.Interval A B)
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (S : Finset ι) [Fintype ι] : Finset.Univ.Sum (λ (i : ι), Finset.centroid_weights_indicator k S i) = S.Sum (λ (i : ι), Finset.centroid_weights k S i)
{A B : ℕ} (hab : A.IsCoprime B) : (A * B).Factors ~ A.Factors ++ B.Factors
{m : Type u_1} [has_Mul m] {C D : Con m} : C ≤ D ↔ ∀ {x y : m}, ⇑C x y → ⇑D x y
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMinOrder α] {A : α} {S : set α} : S ∈ nhds_within A (set.Iio A) ↔ ∃ (l : α) (h : l ∈ set.Iio A), set.Ioo l A ⊆ S
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {n : WithTop ℕ} {S : set E} {F : E → 𝕜} {g : E → F} (hF : ContDiff_within_at 𝕜 n F S x) (hg : ContDiff_within_at 𝕜 n g S x) : ContDiff_within_at 𝕜 n (λ (x : E), F x • g x) S x
{R : Type u} [ordered_Ring R] [Star_ordered_Ring R] [Algebra ℝ R] [OrderedSmul ℝ R] [Star_module ℝ R] (A₀ A₁ B₀ B₁ : R) (t : _CHSH_tuple A₀ A₁ B₀ B₁) : A₀ * B₀ + A₀ * B₁ + A₁ * B₀ - A₁ * B₁ ≤ Real.sqrt 2 ^ 3 • 1
{α : sort u_1} {β : sort u_2} (F : α → β) (P : Prop) [Decidable P] (x : P → α) (y : ¬P → α) : F (dite P x y) = dite P (λ (h : P), F (x h)) (λ (h : ¬P), F (y h))
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {x : α} {P : Filter ι} {g : ι → α} [TopologicalSpace α] (h : TendstoLocallyUniformly F F P) (hF : Continuous_at F x) (hg : Filter.Tendsto g P (nhds x)) : Filter.Tendsto (λ (n : ι), F n (g n)) P (nhds (F x))
{α : Type u_1} [MetricSpace α] {β : Type u} {N : ℕ} {τ : ℝ} (hτ : 1 < τ) (hN : IsEmpty (Besicovitch.SatelliteConfig α N τ)) (q : Besicovitch.BallPackage β α) : ∃ (S : Fin N → set β), (∀ (i : Fin N), (S i).Pairwise_Disjoint (λ (j : β), metric.IsClosed_ball (q.C j) (q.r j))) ∧ set.Range q.C ⊆ ⋃ (i : Fin N) (j : β) (h : j ∈ S i), Metric.Ball (q.C j) (q.r j)
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} {A : α} : finsum (λ (i : α), finsum (λ (h : i ∈ {A}), F i)) = F A
{α : Type u_1} {m : Type u_4} {N : Type u_5} [CommMonoid m] [has_One N] (F : α → N) (g : α → N → m) {S t : Finset α} (h : S ⊆ t) (hg : ∀ (A : α), g A 1 = 1) : S.Prod (λ (i : α), g i (F i)) = t.Prod (λ (i : α), g i (↑S.Mul_indicator F i))
{E : Type u_1} [semi_NormedGroup E] {S : Add_Subgroup E} (x : ↥S) : ∥↑x∥ = ∥x∥
{ι : Type u} (S : Finset ι) (W z : ι → Nnreal) (hw' : S.Sum (λ (i : ι), W i) = 1) {P : ℝ} (hp : 1 ≤ P) : S.Sum (λ (i : ι), W i * z i) ^ P ≤ S.Sum (λ (i : ι), W i * z i ^ P)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : LocalHomeomorph α β} {S : set α} {t : set β} : e.to_local_Equiv.Target ∩ ⇑(e.Symm) ⁻¹' (e.to_local_Equiv.Source ∩ S) = e.to_local_Equiv.Target ∩ t → e._image S t
{o : Ordinal} : Ordinal.principal has_Add.Add o ↔ o = 0 ∨ ∃ (A : Ordinal), o = Ordinal.omega ^ A
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {l : α → β} {u : β → α} (gc : GaloisConnection l u) {x y z : α} (hxy : x ≤ u (l y)) (hyz : y ≤ u (l z)) : x ≤ u (l z)
{G : Type u_1} [Group G] {h : Subgroup G} {N : Type u_3} [Group N] (F : G →* N) : Subgroup.Map F h.Normalizer ≤ (Subgroup.Map F h).Normalizer
{α : Type u} [Group α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LT.LT] {A B : α} : A⁻¹ < B → B⁻¹ < A
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {J : Type v} [Fintype J] {F : J → C} (B : CategoryTheory.Limits.Bicone F) (Total : Finset.Univ.Sum (λ (j : J), B.π j ≫ B.ι j) = 𝟙 B.x) : CategoryTheory.Limits.HasBiproduct F
{R : Type u_1} (C₁ C₂ : R) : Cardinal.Mk ↥set.Univ = Cardinal.Mk R ^ 4
{n : ℕ} (P : Fin (n + 1)) (i : Fin n) : ⇑Fin.cast_Succ i < P ∨ P < i.Succ
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {v : ℝ → E → E} {K : Nnreal} (hv : ∀ (t : ℝ), LipschitzWith K (v t)) {F g F' g' : ℝ → E} {A B εF εg δ : ℝ} (hF : Continuous_on F (set.icc A B)) (hF' : ∀ (t : ℝ), t ∈ set.Ico A B → HasDerivWithinAt F (F' t) (set.ici t) t) (F_bound : ∀ (t : ℝ), t ∈ set.Ico A B → HasDist.dist (F' t) (v t (F t)) ≤ εF) (hg : Continuous_on g (set.icc A B)) (hg' : ∀ (t : ℝ), t ∈ set.Ico A B → HasDerivWithinAt g (g' t) (set.ici t) t) (g_bound : ∀ (t : ℝ), t ∈ set.Ico A B → HasDist.dist (g' t) (v t (g t)) ≤ εg) (ha : HasDist.dist (F A) (g A) ≤ δ) (t : ℝ) (h : t ∈ set.icc A B) : HasDist.dist (F t) (g t) ≤ gronwall_bound δ ↑K (εF + εg) (t - A)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {F' : E →L[𝕜] F} {x : E} (hF : HasStrictFderivAt F F' x) : ∃ (K : Nnreal) (S : set E) (h : S ∈ nhds x), LipschitzOnWith K F S
{α : Type u_1} {β : Type u_2} {C : set (set α)} {D : set (set β)} (hC : IsCountablySpanning C) (hD : IsCountablySpanning D) : Prod.MeasurableSpace = MeasurableSpace.generate_from (set.image2 has_set_Prod.Prod C D)
{α : Type u_1} [generalized_boolean_Algebra α] [Decidable_Rel Disjoint] [Decidable_Rel has_LE.LE] (u v : α) (S : Finset α) : Uv.Compression u v (Uv.Compression u v S) = Uv.Compression u v S
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : LocalHomeomorph α β} {S : set α} {t : set β} : e.to_local_Equiv.Target ∩ ⇑(e.Symm) ⁻¹' S = e.to_local_Equiv.Target ∩ t → e._image S t
{n A B : ℕ} (h : A ≤ B) : A ≡ B [Mod n] ↔ n ∣ B - A
{K : Type u_1} {v : K} {n : ℕ} [Linear_ordered_Field K] [FloorRing K] {ifp_n : GeneralizedContinuedFraction.Int_fract_pair K} (nth_Stream_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.Some ifp_n) : ifp_n.fr < 1
(R : Type u_1) {K : Type u_2} {t : Type u_3} {U : Type u_4} [CommRing R] [Field K] [CommRing t] [Algebra R K] [Algebra K t] [Algebra R t] [IsScalarTower R K t] [CommSemiring U] [Algebra K U] [Algebra R U] [IsScalarTower R K U] (x : t) (y : U) (hy : ⇑(Polynomial.aeval y) (minpoly K x) = 0) : ⇑(Polynomial.aeval y) (minpoly R x) = 0
{n : ℕ} (P : Mvpfunctor (n + 1)) {α : Typevec n} {C : P.W α → Prop} (ih : ∀ (A : P.A) (F' : (P.Drop.B A).arrow α) (F : P.Last.B A → P.W α), (∀ (i : P.Last.B A), C (F i)) → C (P.W_Mk A F' F)) (x : P.W α) : C x
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P : ι → P) (h : S.Sum (λ (i : ι), W i) = 0) (B : P) : ⇑(S.weighted_vsub P) W = ⇑(S.weighted_vsub_of_point P B) W
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) : K ≤ Kᗮᗮ
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} {x : E} : MdifferentiableAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F x → Differentiable_at 𝕜 F x
{G : Type u_1} [AddGroup G] (N h : Add_Subgroup G) [N.Normal] : ↑(N ⊔ h) = ↑N + ↑h
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {x : E} {n : WithTop ℕ} {S : set E} {F g : E → 𝕜} (hF : ContDiff_within_at 𝕜 n F S x) (hg : ContDiff_within_at 𝕜 n g S x) : ContDiff_within_at 𝕜 n (λ (x : E), F x * g x) S x
{α : Type u} {L L' : List α} (h : L = L') {i : ℕ} (hi : i < L.length) : L.nth_LE i hi = L'.nth_LE i _
{α : Type u_1} [has_LE α] {S : set α} : _lower_set S → _upper_set (⇑order_dual.of_dual ⁻¹' S)
{m : Type u} [Monoid m] (A : m) : A ^ 2 = A * A
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) : hb.oangle x (-y) = hb.oangle x y + ↑Real.Pi
{m : Type u_1} [has_Mul m] (S : Subsemigroup m) : Subsemigroup.Closure ↑S = S
{α : Type u_1} [Preorder α] {F g : α → α} (hg : Monotone g) (h : F ≤ g) (n : ℕ) : F^[n] ≤ (g^[n])
{R : Type v} [CommRing R] {n : ℕ} (A : Matrix (Fin n.Succ) (Fin n.Succ) R) (i : Fin n.Succ) : A.det = Finset.Univ.Sum (λ (j : Fin n.Succ), (-1) ^ (↑i + ↑j) * A i j * (A.minor ⇑(i.Succ_above) ⇑(j.Succ_above)).det)
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m →* P} {t : Submonoid P} {q : Type u_4} [CommMonoid q] (hg : ∀ (y : ↥S), ⇑g ↑y ∈ t) (k : t.Localization_Map q) {x y : m} (h : ⇑(F.to_Map) x = ⇑(F.to_Map) y) : ⇑(k.to_Map) (⇑g x) = ⇑(k.to_Map) (⇑g y)
{α : Type u_1} (F : Filter α) [F._countably_generated] : ∃ (x : ℕ → set α), F.has_Antitone_Basis x
(K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [module.Finite K L] (pB : power_Basis K L) [_IsSeparable K L] : Algebra.discr K ⇑(pB.Basis) = (-1) ^ (Finite_dimensional.finrank K L * (Finite_dimensional.finrank K L - 1) / 2) * ⇑(Algebra.norm K) (⇑(Polynomial.aeval pB.gen) (⇑Polynomial.derivative (minpoly K pB.gen)))
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {C : Add_Con m} (F g : C.Quotient →+ P) (h : ∀ (A : m), ⇑F ↑A = ⇑g ↑A) : F = g
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (S : Finset ι) [CharZero k] (h : S.Card ≠ 0) : S.Sum (λ (i : ι), Finset.centroid_weights k S i) = 1
{α : Type u_1} {S : Finset α} {F : α → Ennreal} (h : ∀ (A : α), A ∈ S → F A ≠ ⊤) : S.Sum (λ (A : α), F A) < ⊤
{R : Type u_1} [CommRing R] [Fintype R] (P : ℕ) [Fact (Nat.Prime P)] (hp : P ∣ Fintype.Card R) : ¬IsUnit ↑P
{m : Type u} {α : Type v} [CommRing α] [Fintype m] [DecidableEq m] {m : Matrix m m α} (h : IsUnit m) (N : Matrix m m α) : ((m⁻¹.Mul N).Mul m).det = N.det
{α : Type u_1} [TopologicalSpace α] {x : α} {S : set α} {γ : Type u_4} [Linear_ordered_AddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] [has_Continuous_Add γ] {F g : α → γ} (hF : UpperSemicontinuous_within_at F S x) (hg : UpperSemicontinuous_within_at g S x) : UpperSemicontinuous_within_at (λ (z : α), F z + g z) S x
{u : ℕ → ℝ} {l : ℝ} (h : Filter.Tendsto u Filter.at_top (nhds l)) : Filter.Tendsto (λ (n : ℕ), (↑n)⁻¹ * (Finset.Range n).Sum (λ (i : ℕ), u i)) Filter.at_top (nhds l)
{k : Type u_1} {v : Type u_2} [Ring k] [AddCommGroup v] [module k v] {ι : Type u_3} {P : ι → v} : AffineIndependent k P ↔ ∀ (S : Finset ι) (W : ι → k), S.Sum W = 0 → S.Sum (λ (e : ι), W e • P e) = 0 → ∀ (e : ι), e ∈ S → W e = 0
{F : Type u_1} [Field F] {P : Polynomial F} (hp : P.IsSeparable) : Fintype.Card P.Gal = Finite_dimensional.finrank F P.splitting_Field
(S t : set ℕ+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension (S ∪ t) A B] : IsCyclotomicExtension t ↥(Algebra.Adjoin A {B : B | ∃ (A : ℕ+), A ∈ S ∧ B ^ ↑A = 1}) B
{α : Type u} [AddGroup α] [has_LE α] [CovariantClass α α has_Add.Add has_LE.LE] {A : α} : -A ≤ 0 ↔ 0 ≤ A
{R : Type u_1} [CommRing R] (P : Ideal (Polynomial R)) : Function.Injective ⇑((Ideal.Map (Polynomial.Map_Ring_hom (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P))) P).QuotientMap (Polynomial.Map_Ring_hom (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P))) Ideal.LE_comap_Map)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {F' : E →L[𝕜] F} {S : set E} {C : Nnreal} : LipschitzOnWith C (F - ⇑F') S → ApproximatesLinearOn F F' S C
{n P k : ℕ} (hn : n ≠ 0) (h : n.factorization = Finsupp.single P k) : n = P ^ k
(P q : ℕ) [hp : Fact (Nat.Prime P)] (hq0 : ↑q ≠ 0) : (Finset.Ico 1 (P / 2).Succ).Sum (λ (A : ℕ), A * q / P) + (Finset.Ico 1 (q / 2).Succ).Sum (λ (A : ℕ), A * P / q) = P / 2 * (q / 2)
{α : Type u} {β : Type v} [Semiring α] [Semiring β] {F : α → β} (hF : _Semiring_hom F) : _AddMonoid_hom F
{C W : ℂ} {R : ℝ} (hw : W ∈ Metric.Ball C R) : ∮ (z : ℂ) in C(C, R), (z - W)⁻¹ = 2 * ↑Real.Pi * Complex.i
{α : Type u_1} {β : Type u_2} [CompleteLattice α] (A : α) (F : β → α) : (⨆ (o : Option β), Option.elim A F o) = A ⊔ ⨆ (B : β), F B
{α : Type u} [PseudoEmetricSpace α] {x : α} {S t : set α} (h : S ⊆ t) : Emetric.Inf_edist x t ≤ Emetric.Inf_edist x S
{α : Type u_1} {β : Type u_2} [PseudoMetricSpace α] [PseudoMetricSpace β] {K : Nnreal} {F : α → β} : (∀ (x y : α), HasDist.dist x y ≤ ↑K * HasDist.dist (F x) (F y)) → AntilipschitzWith K F
{R : Type u} [Semiring R] {P : Type (max u v)} [AddCommMonoid P] [module R P] (huniv : ∀ {m : Type (max v u)} {N : Type (max u v)} [_inst_8 : AddCommMonoid m] [_inst_9 : AddCommMonoid N] [_inst_10 : module R m] [_inst_11 : module R N] (F : m →ₗ[R] N) (g : P →ₗ[R] N), Function.Surjective ⇑F → (∃ (h : P →ₗ[R] m), F.Comp h = g)) : module.projective R P
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (e : C ≌ D) : CategoryTheory.WellPowered C ↔ CategoryTheory.WellPowered D
{α : Type u_1} [CommRing α] (E : LinearRecurrence α) (q : α) : E._solution (λ (n : ℕ), q ^ n) ↔ E.Char_Poly._root q
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : ℝ} (h0 : 0 < R) {F : ℂ → E} {C : ℂ} {S : set ℂ} (hs : S.countable) (hc : Continuous_on F (metric.IsClosed_ball C R)) (hD : ∀ (z : ℂ), z ∈ Metric.Ball C R  S → Differentiable_at ℂ F z) : ∮ (z : ℂ) in C(C, R), (z - C)⁻¹ • F z = (2 * ↑Real.Pi * Complex.i) • F C
{α : Type u_1} {m : Type u_4} [CommMonoid m] (F : α → m) {S t : Finset α} (h : S ⊆ t) : S.Prod (λ (i : α), F i) = t.Prod (λ (i : α), ↑S.Mul_indicator F i)
{A B : ℝ} (h : A < B) : Cardinal.Mk ↥(set.ioc A B) = Cardinal.Continuum
{q : ℕ+} : Fintype.Card (LucasLehmer.x q) = ↑q ^ 2
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (hb : Continuous_at F B) : HasStrictDerivAt (λ (u : ℝ), ∫ (x : ℝ) in A..u, F x) (F B) B
{α : Type u_1} [Preorder α] [locally_Finite_order α] {A B : α} : ¬A ≤ B → Finset.icc A B = ∅
 : WellFounded Nat.LT
{α : Type u} {β : Type v} [PseudoMetricSpace α] [PseudoMetricSpace β] {K : Nnreal} {F : α → β} : (∀ (x y : α), HasDist.dist (F x) (F y) ≤ ↑K * HasDist.dist x y) → LipschitzWith K F
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] {x : B} (hx : IsIntegral A x) : (minpoly A x).monic
{α : Type u_1} {β : Type u_2} [conditionally_CompleteLattice α] [SemilatticeSup β] {F g : β → α} (hF : Monotone F) (hg : Antitone g) (h : F ≤ g) : (⨆ (n : β), F n) ∈ ⋂ (n : β), set.icc (F n) (g n)
{m : Type u_3} [AddMonoid m] (L : List m) (h : L.Sum ≠ 0) : 0 < L.length
{ι : Type u_1} {m : Type u_4} [ordered_AddCommMonoid m] {S : Finset ι} {F : ι → WithTop m} : S.Sum (λ (i : ι), F i) = ⊤ ↔ ∃ (i : ι) (h : i ∈ S), F i = ⊤
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A B : α} (ha : 1 < A) (hb : 1 < B) : 1 < A * B
{R : Type u_1} [CommRing R] {P n : ℕ} (hp : Nat.Prime P) : Polynomial.cyclotomic (P ^ (n + 1)) R = (Finset.Range P).Sum (λ (i : ℕ), (Polynomial.x ^ P ^ n) ^ i)
{cb : CharBuffer} {n n' val : ℕ} : Parser.Nat cb n = ParseResult.done n' val ↔ ∃ (hn : n < n'), val = Nat.of_digits 10 (List.Map (λ (C : Char), C.ToNat - '0'.ToNat) (List.take (n' - n) (List.Drop n (Buffer.to_List cb))).reverse) ∧ (∀ (hn' : n' < Buffer.size cb), '0' ≤ Buffer.read cb ⟨n', hn'⟩ → '9' < Buffer.read cb ⟨n', hn'⟩) ∧ ∃ (hn'' : n' ≤ Buffer.size cb), ∀ (k : ℕ) (hk : k < n'), n ≤ k → '0' ≤ Buffer.read cb ⟨k, _⟩ ∧ Buffer.read cb ⟨k, _⟩ ≤ '9'
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] (v : v) : G.min_degree ≤ G.degree v
{𝕜 : Type u_1} [_R_or_C 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {r : ℝ} (r_nonneg : 0 ≤ r) {x : E} (hx : x ≠ 0) : ∥(↑r * (↑∥x∥)⁻¹) • x∥ = r
{α : Type u_1} {G₀ : Type u_3} [Group_with_Zero G₀] [TopologicalSpace G₀] [has_Continuous_Inv₀ G₀] [has_Continuous_Mul G₀] {F g : α → G₀} [TopologicalSpace α] {A : α} (hF : Continuous_at F A) (hg : Continuous_at g A) (h₀ : g A ≠ 0) : Continuous_at (F / g) A
{R : Type u_2} {Γ₀ : Type u_3} [Linear_ordered_AddCommMonoid_WithTop Γ₀] [CommRing R] (v : AddValuation R Γ₀) {J : Ideal R} (hJ : J ≤ v.supp) : (v.on_quot hJ).supp = Ideal.Map (Ideal.Quotient.Mk J) v.supp
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {ι : Type W} [Fintype ι] (h : Basis ι K v) : Finite_dimensional.finrank K v = Fintype.Card ι
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] {P1 : P} (P2 : P) (hp1 : P1 ∈ S) : HasDist.dist P1 P2 * HasDist.dist P1 P2 = HasDist.dist P1 ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P2) * HasDist.dist P1 ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P2) + HasDist.dist P2 ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P2) * HasDist.dist P2 ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P2)
{α : Type u} [PseudoEmetricSpace α] {S : set α} : Emetric.Hausdorff_edist S (Closure S) = 0
{α : Type u_1} [PartialOrder α] [SuccOrder α] [IsSuccArchimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ set.Ico n m → r i (Order.Succ i)) (hnm : n ≤ m) : Relation.refl_Trans_gen r n m
{F : ℝ → ℝ} {A : ℝ} (h : IsLocalMax F A) : deriv F A = 0
{R : Type u} {ι : Type W} (S : Finset ι) [CommSemiring R] (F : ι → Polynomial R) (h : S.Prod (λ (i : ι), (F i).leading_Coeff) ≠ 0) : (S.Prod (λ (i : ι), F i)).Nat_degree = S.Sum (λ (i : ι), (F i).Nat_degree)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) (i : Fin 1) : (Affine.Simplex.Mk_of_point k P).points i = P
{k : Type u} [Linear_ordered_Field k] {A : k} (ha : 0 < A) : (set.Ioo 0 A)⁻¹ = set.ioi A⁻¹
{α : Type u_1} {β : Type u_2} (e e' : local_Equiv α β) (h : e ≈ e') (S : e.Source = set.Univ) (t : e.Target = set.Univ) : e = e'
{𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] {F : 𝕜 → G} {C : Nnreal} (hF : Differentiable 𝕜 F) (bound : ∀ (x : 𝕜), ∥deriv F x∥₊ ≤ C) : LipschitzWith C F
{α : Type u_1} {β : Type u_2} [LinearOrder α] [Preorder β] {A : α} {F : α → β} (h₁ : StrictAntiOn F (set.Iic A)) (h₂ : StrictAntiOn F (set.ici A)) : StrictAnti F
{R : Type u_1} {F : Type u_3} [AddCommGroup F] [TopologicalSpace F] [topological_AddGroup F] [Ring R] [module R F] [TopologicalSpace R] [has_Continuous_Smul R F] {P v : F} : Continuous ⇑(affine_Map.line_Map P v)
{α : Type u_1} {S t : set α} : S = t → S ⊆ t
{m : Type u_3} {N : Type u_4} [has_Mul m] [has_Mul N] (F : m →ₙ* N) {x y : m} (h : x = y) : ⇑F x = ⇑F y
{m n : ℕ} (cop : m.IsCoprime n) (hm : 1 < m) (hn : 1 < n) : IsFrobeniusNumber (m * n - m - n) {m, n}
{γ : Type W} [EmetricSpace γ] {x y : γ} : HasEdist.edist x y = 0 ↔ x = y
{P : ℕ} [hp_Prime : Fact (Nat.Prime P)] {R : Type u_1} [non_assoc_Semiring R] {F : Π (k : ℕ), R →+* Zmod (P ^ k)} (F_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), (Zmod.cast_hom _ (Zmod (P ^ k1))).Comp (F k2) = F k1) (g : R →+* ℤ_[P]) (hg : ∀ (n : ℕ), (padic_Int.to_Zmod_Pow n).Comp g = F n) : padic_Int.Lift F_compat = g
{α : Type u_1} [DecidableEq α] (S : Multiset α) : S - 0 = S
{P n : ℕ} (hp : Nat.Prime P) (HDiv : ¬P ∣ n) (R : Type u_1) [CommRing R] : ⇑(Polynomial.expand R P) (Polynomial.cyclotomic n R) = Polynomial.cyclotomic (n * P) R * Polynomial.cyclotomic n R
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [HasScalar 𝕜 E] {S : set E} : Convex 𝕜 S → ∀ ⦃A B : 𝕜⦄, 0 ≤ A → 0 ≤ B → A + B = 1 → A • S + B • S ⊆ S
(R : Type u) [Field R] : _Field R
{m : Type u_1} [CommMonoid m] (F : ℕ → ℕ → m) (n : ℕ) : (Finset.Nat.antidiagonal n).Prod (λ (ij : ℕ × ℕ), F ij.fst ij.Snd) = (Finset.Range n.Succ).Prod (λ (k : ℕ), F k (n - k))
{m : Type u_1} [has_Add m] (C : Add_Con m) {x y : m} : ⇑C x y → ⇑C y x
{ι : Type u₁} {k : Type u₂} {v : Type u₃} [AddCommGroup v] [Ring k] [module k v] [Fintype ι] (B : affine_Basis ι k v) (v : v) : Finset.Univ.Sum (λ (i : ι), ⇑(B.coord i) v • B.points i) = v
{ι : Type u_1} {v : Type u} [CategoryTheory.Category v] [CategoryTheory.Preadditive v] {C : Complex_shape ι} {C D : homological_Complex v C} {F g : C ⟶ D} [CategoryTheory.Limits.HasEqualizers v] [CategoryTheory.Limits.HasCokernels v] [CategoryTheory.Limits.HasImages v] [CategoryTheory.Limits.HasImage_maps v] [CategoryTheory.Limits.has_Zero_object v] (h : Homotopy F g) (i : ι) : (homology_Functor v C i).Map F = (homology_Functor v C i).Map g
{ι : Type u_1} {m : Type u_4} {N : Type u_5} [AddCommMonoid m] [ordered_AddCommMonoid N] (F : m → N) (h_One : F 0 = 0) (h_Mul : ∀ (x y : m), F (x + y) ≤ F x + F y) (S : Finset ι) (g : ι → m) : F (S.Sum (λ (i : ι), g i)) ≤ S.Sum (λ (i : ι), F (g i))
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {E' : Type u_7} [InnerProductSpace 𝕜 E'] (F : E ≃ₗᵢ[𝕜] E') (x y : E) : HasInner.inner (⇑F x) (⇑F y) = HasInner.inner x y
{α : Type u_1} {β : Type u_2} [Fintype α] (F : α → β) [Fintype β] [Decidable_Pred (λ (y : β), y ∈ set.Range F)] [DecidableEq β] : Finset.Filter (λ (y : β), y ∈ set.Range F) Finset.Univ = Finset.image F Finset.Univ
{ι : Type u} {F : ι → Ordinal → Ordinal} (h : ∀ (i : ι), Ordinal._Normal (F i)) : set.Unbounded has_LT.LT (⋂ (i : ι), Function.FixedPoints (F i))
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) : A⁻¹ = Ring.Inverse A
{K : Type u} {v v₁ : Type v} [Field K] [AddCommGroup v] [module K v] [AddCommGroup v₁] [module K v₁] (F : v →ₗ[K] v₁) : module.rank K ↥(F.Range) + module.rank K ↥(F.Ker) = module.rank K v
{x : Type u_2} [EmetricSpace x] {S : set x} (hs : S.countable) : dimH S = 0
{α : Type u_1} {β : Type u_4} [Preorder α] [Preorder β] {u : β → α} (l : LowerAdjoint u) (x : α) : x ≤ u (⇑l x)
{m₀ : Type u_1} [Monoid_with_Zero m₀] (x : m₀) (h : ¬IsUnit x) : Ring.Inverse x = 0
{α : Type u_1} {m : Type u_5} {N : Type u_7} [has_Zero m] [CommMonoid N] (F : α →₀ m) (y : α) (g : α → m → N) (hyf : y ∈ F.Support) : g y (⇑F y) * (Finsupp.erase y F).Prod g = F.Prod g
(x y z : Pgame) : ((x + y) * z).Equiv (x * z + y * z)
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {A B : α} (h : A ⊆ B) : ¬B ⊂ A
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [OrderedSemiring 𝕜] [AddCommGroup E] [module 𝕜 E] [Subsingleton ι] (P : ι → E) : Convex_Independent 𝕜 P
{α : sort u_1} (hH : α) {β : Prop} (x : Tactic.CalculatedProp β hH . "derive_reassoc_proof") : β
{F : Type u_1} [NormedGroup F] [NormedSpace ℝ F] (F : ℝ → F) [CompleteSpace F] : Measurable_set {x : ℝ | Differentiable_within_at ℝ F (set.ici x) x}
(m : Type u_1) (α : Type u_2) [Group m] [MulAction m α] {P q : Subgroup m} : MulAction.FixedPoints ↥(P ⊔ q) α = MulAction.FixedPoints ↥P α ∩ MulAction.FixedPoints ↥q α
{m : Type u_1} [MulOneClass m] {P : m → Prop} (x : m) {S : set m} (hs : Submonoid.Closure S = ⊤) (Hs : ∀ (x : m), x ∈ S → P x) (h1 : P 1) (HMul : ∀ (x y : m), P x → P y → P (x * y)) : P x
{α : Type u_2} [Monoid α] (m : α) : (∃ (C : α), m = C ^ 2) → IsSquare m
{R : Type u_1} [CommRing R] (m : Submonoid R) (S : Type u_2) [CommRing S] [Algebra R S] {P : Type u_3} [CommRing P] [IsLocalization m S] (q : Type u_5) [CommRing q] {g : R →+* P} [Algebra P q] (hg : Function.Injective ⇑g) [IsLocalization (Submonoid.Map ↑g m) q] (hM : Submonoid.Map ↑g m ≤ non_Zero_divisors P) : Function.Injective ⇑(IsLocalization.Map q g _)
{α : Type u_1} {β : Type u_2} {m : Type u_5} {N : Type u_7} [AddCommMonoid m] [AddCommMonoid N] (F : α → β) (v : α →₀ m) (g : m → N) (h0 : g 0 = 0) (HAdd : ∀ (x y : m), g (x + y) = g x + g y) : Finsupp.Map_IsDomain F (Finsupp.Map_Range g h0 v) = Finsupp.Map_Range g h0 (Finsupp.Map_IsDomain F v)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {J : Type v} [Fintype J] (F : J → C) [CategoryTheory.Limits.HasCoproduct F] : CategoryTheory.Limits.HasBiproduct F
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] [Fintype α] [Fintype β] (F : α → β) {W : α → m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] [Nonempty β] (hb : Fintype.Card β • B ≤ Finset.Univ.Sum (λ (x : α), W x)) : ∃ (y : β), B ≤ (Finset.Filter (λ (x : α), F x = y) Finset.Univ).Sum (λ (x : α), W x)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (P₁ P₂ : P) : EuclideanGeometry.Cospherical {P₁, P₂}
 : golden_Conj⁻¹ = -GoldenRatio
{α : Type u} [TopologicalSpace α] (A : α) : (nhds A).has_Basis (λ (S : set α), S ∈ nhds A ∧ IsOpen S) (λ (x : set α), x)
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] (S : set x) : dimH S = ⨆ (D : Nnreal) (hD : ⇑(MeasureTheory.Measure.hausdorff_measure ↑D) S = ⊤), ↑D
{m : Type u_1} [AddMonoid m] {S t : set m} (ht : _Add_Submonoid t) (h : S ⊆ t) : AddMonoid.Closure S ⊆ t
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {G : C ⥤ D} {K : CategoryTheory.GrothendieckTopology D} [CategoryTheory.Full G] [CategoryTheory.Faithful G] (Hld : CategoryTheory.locally_cover_Dense K G) : CategoryTheory.CoverLifting Hld.induced_topology K G
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [Finite_dimensional R m] (x₁ x₂ : Orientation R m ι) (h : Fintype.Card ι = Finite_dimensional.finrank R m) : x₁ = x₂ ∨ x₁ = -x₂
{α : Type u_1} {β : Type u_2} {S : set α} {t : α → set β} {x : α} (xs : x ∈ S) : (⋂ (x : α) (h : x ∈ S), t x) ⊆ t x
{α : Type u_1} {S t : set α} : (S ∩ t).Nonempty → ¬Disjoint S t
{R : Type u_1} {S : Type u_2} [CommRing R] [IsDomain R] [_principal_Ideal_Ring R] [Semiring S] (F : R →+* S) (S : Submonoid S) (A : R) (ha : A ≠ 0) (h : ∀ (B : R), B ∈ principal_Ideal_Ring.Factors A → ⇑F B ∈ S) (hF : ∀ (C : Rˣ), ⇑F ↑C ∈ S) : ⇑F A ∈ S
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {S : set E} {x : E} {F' : E → (E →L[𝕜] G)} (hs : Convex ℝ S) {F : E → G} (hder : ∀ᶠ (y : E) in nhds_within x S, HasFderivWithinAt F (F' y) S y) (hcont : Continuous_within_at F' S x) (K : Nnreal) (hK : ∥F' x∥₊ < K) : ∃ (t : set E) (h : t ∈ nhds_within x S), LipschitzOnWith K F t
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] {F : ℝ → E} {t : ℝ} (hF : Function.Periodic F t) (n : ℤ) (t : ℝ) (h_Int : ∀ (t₁ t₂ : ℝ), IntervalIntegrable F MeasureTheory.MeasureSpace.Volume t₁ t₂) : ∫ (x : ℝ) in t..t + n • t, F x = n • ∫ (x : ℝ) in t..t + t, F x
{α : Type u} [Preorder α] [NoMinOrder α] (A : α) : ∃ (F : ℕ → α), StrictAnti F ∧ F 0 = A
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] {A : α} : 0 < -A ↔ A < 0
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {F : v ≃ₗᵢ[ℝ] v} (hD : 0 < ⇑LinearMap.det ↑(F.to_Linear_Equiv)) : ∃ (θ : Real.Angle), F = hb.rotation θ
{C : Type u₁} [CategoryTheory.Category C] {A : C} (hA : CategoryTheory.IsSubterminal A) {t : C} (hT : CategoryTheory.Limits.IsTerminal t) : CategoryTheory.Mono (hT.from A)
{α : Type u_1} {ι : Type u_2} (m : MeasureTheory.OuterMeasure α) {S : ι → set α} (l : Filter ι) [l.Ne_IsBot] (h0 : Filter.Tendsto (λ (k : ι), ⇑m ((⋃ (n : ι), S n)  S k)) l (nhds 0)) : ⇑m (⋃ (n : ι), S n) = ⨆ (n : ι), ⇑m (S n)
{m : Type u_1} [MulOneClass m] {ι : sort u_2} (S : ι → Submonoid m) {C : Π (x : m), (x ∈ ⨆ (i : ι), S i) → Prop} (hp : ∀ (i : ι) (x : m) (h : x ∈ S i), C x _) (h1 : C 1 _) (HMul : ∀ (x y : m) (hx : x ∈ ⨆ (i : ι), S i) (hy : y ∈ ⨆ (i : ι), S i), C x hx → C y hy → C (x * y) _) {x : m} (hx : x ∈ ⨆ (i : ι), S i) : C x hx
{m : Type u_1} [Monoid m] (S : Submonoid m) {l : List m} (hl : ∀ (x : m), x ∈ l → x ∈ S) : l.Prod ∈ S
{α : Type u_1} {S : Finset α} : S.Nonempty → ↑S.Nonempty
(x y z : Pgame) : (x * y * z).Equiv (x * (y * z))
{α : sort u_1} {β : sort u_2} {γ : sort u_3} {δ : out_param (sort u_4)} [has_Coe α β] [has_Coe_t_aux β γ] [has_Coe_ToFun γ (λ (_x : γ), δ)] (x : α) : ⇑x = ⇑↑x
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y : v} (hn : x ≠ y) (h : ∥x∥ = ∥y∥) : hb.oangle y x = ↑Real.Pi - 2 • hb.oangle (y - x) y
(R : Type u) (m : Type v) (N : Type W) [CommRing R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] [AddCommGroup N] [module R N] [module.free R N] [module.Finite R N] : Finite_dimensional.finrank R (m →ₗ[R] N) = Finite_dimensional.finrank R m * Finite_dimensional.finrank R N
{h : Type u} [TopologicalSpace h] (G : StructureGroupoid h) : IsClosed_under_restriction G ↔ Id_restr_groupoid ≤ G
{R : Type u_1} {m : Type u_2} {R₂ : Type u_3} {m₂ : Type u_4} [Ring R] [Ring R₂] [AddCommMonoid m] [AddCommGroup m₂] [module R m] [module R₂ m₂] {τ₁₂ : R →+* R₂} [Ring_hom_surjective τ₁₂] {F : m →ₛₗ[τ₁₂] m₂} (h : ∀ (u v : m₂ →ₗ[R₂] m₂ ⧸ F.Range), u.Comp F = v.Comp F → u = v) : F.Range = ⊤
{m : Type u_1} [AddCommGroup m] [module ℂ m] [Finite_dimensional ℂ m] (q₁ q₂ : QuadraticForm ℂ m) (hQ₁ : (⇑QuadraticForm.Associated q₁).nondegenerate) (hQ₂ : (⇑QuadraticForm.Associated q₂).nondegenerate) : q₁.Equivalent q₂
{J : Type u} [CategoryTheory.SmallCategory J] (F : J ⥤ top) [CategoryTheory.IsCofiltered J] [∀ (j : J), Nonempty ↥(F.obj j)] [∀ (j : J), CompactSpace ↥(F.obj j)] [∀ (j : J), t2_Space ↥(F.obj j)] : Nonempty ↥((top.Limit_cone F).x)
{R : Type u_1} {A B : R} [Add_Semigroup R] (Ab : _Add_Right_regular (B + A)) : _Add_Right_regular B
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {S : set α} {t : set β} (hs : Dense S) (ht : Dense t) : Dense (S ×ˢ t)
{R : Type u_1} [CommRing R] [IsDomain R] [normalized_Gcd_Monoid R] {K : Type u_2} [Field K] [Algebra R K] [_fraction_Ring R K] {P : Polynomial R} (hp : P._primitive) : Irreducible P ↔ Irreducible (Polynomial.Map (Algebra_Map R K) P)
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] (Z : TopologicalFiberBundleCore ι B F) (B : B) : Continuous (Bundle.Total_Space_Mk B)
{α : Type u} [PseudoMetricSpace α] {S : set α} (hs : IsCompact S) {e : ℝ} (hE : 0 < e) : ∃ (t : set α) (h : t ⊆ S), t.Finite ∧ S ⊆ ⋃ (x : α) (h : x ∈ t), Metric.Ball x e
{R : Type u} [CommSemiring R] {A : Type v} [Semiring A] [Algebra R A] (m : Submodule R A) {C : A → Prop} (hr : ∀ (r : R), C (⇑(Algebra_Map R A) r)) (HAdd : ∀ (x y : A), C x → C y → C (x + y)) (HMul : ∀ (x : A), C x → ∀ (m : A), m ∈ m → C (x * m)) {x : A} {n : ℕ} (hx : x ∈ m ^ n) : C x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {x : top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.Forget C)] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.Forget C)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget C)] {F G : top.sheaf C x} (F : F ⟶ G) (U : TopologicalSpace.Opens ↥x) (hinj : ∀ (x : ↥U), Function.Injective ⇑((top.Presheaf.stalk_Functor C x.val).Map F)) (hsurj : ∀ (t : ↥(G.val.obj (Opposite.Op U))) (x : ↥U), ∃ (v : TopologicalSpace.Opens ↥x) (m : x.val ∈ v) (iVU : v ⟶ U) (S : ↥(F.val.obj (Opposite.Op v))), ⇑(F.App (Opposite.Op v)) S = ⇑(G.val.Map iVU.Op) t) : Function.Surjective ⇑(F.App (Opposite.Op U))
{R : Type u_1} [CommSemiring R] {x : Type u_2} {A : Type u_3} [Semiring A] [Algebra R A] {F g : free_Algebra R x →ₐ[R] A} (W : ⇑F ∘ free_Algebra.ι R = ⇑g ∘ free_Algebra.ι R) : F = g
(α : Type u) [Preorder α] [Nonempty α] [NoMinOrder α] [NoMaxOrder α] : ∃ (F : ℤ → α), StrictMono F
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {q : QuadraticForm R m} : Function.Commute ⇑clifford_Algebra.reverse ⇑clifford_Algebra.involute
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_4} [DecidableEq ι] [Fintype ι] (e : Basis ι R m) {W : ι → R} (hw : ∀ (i : ι), IsUnit (W i)) : ⇑(e.det) ⇑(e.IsUnit_Smul hw) = Finset.Univ.Prod (λ (i : ι), W i)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) {r : Nnreal} (h : ↑r < P.radius) : ∃ (C : ℝ) (h : C > 0), ∀ (n : ℕ), ∥P n∥ * ↑r ^ n ≤ C
{α : Type u_1} {β : Type u_2} [Group α] [division_Monoid β] (F : α →* β) (g h : α) : ⇑F (g / h) = ⇑F g / ⇑F h
{α : sort u_1} {β : sort u_2} (F : α → β) : Nonempty α → Nonempty β
{J : Type u₁} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {J' : Type u₂} [CategoryTheory.Category J'] (e : J ≌ J') [CategoryTheory.Limits.HasColimits_of_shape J C] : CategoryTheory.Limits.HasColimits_of_shape J' C
{C : ℝ} (h1 : 0 < C) (h2 : C < 1 / 2) {n : ℕ} {F g : ℕ → Bool} (hn : ∀ (k : ℕ), k < n → F k = g k) (fn : F n = Bool.ff) (gn : g n = Bool.tt) : Cardinal.cantor_Function C F < Cardinal.cantor_Function C g
{F : Type u_1} [NormedGroup F] [NormedSpace ℝ F] {F : ℝ → F} {K : set F} (hK : IsComplete K) : Right_deriv_Measurable_aux.D F K ⊆ {x : ℝ | Differentiable_within_at ℝ F (set.ici x) x ∧ deriv_within F (set.ici x) x ∈ K}
{B : ℕ} {l : List ℕ} (hb : 2 ≤ B) (hl : ∀ (x : ℕ), x ∈ l → x < B) : Nat.of_digits B l < B ^ l.length
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {x : E} {F : E → F} {F' : E → (E →L[ℝ] F)} {F'' : E →L[ℝ] E →L[ℝ] F} (hF : ∀ᶠ (y : E) in nhds x, HasFderivAt F (F' y) y) (hx : HasFderivAt F' F'' x) (v W : E) : ⇑(⇑F'' v) W = ⇑(⇑F'' W) v
{α : Type u} {β : Type v} [Group α] [Group β] {F : α → β} (hF : ∀ (x y : α), F (x * y) = F x * F y) : _Group_hom F
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.CosimplicialObject C) {n : ℕ} {i j : Fin (n + 2)} (h : i ≤ j) : x.δ i ≫ x.δ j.Succ = x.δ j ≫ x.δ (⇑Fin.cast_Succ i)
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k → E} {A B r : k} (h : 0 < r * (B - A)) : F (⇑(affine_Map.line_Map A B) r) ≤ ⇑(affine_Map.line_Map (F A) (F B)) r ↔ slope F A (⇑(affine_Map.line_Map A B) r) ≤ slope F A B
{F : ℝ → ℝ} (hF' : ∀ (x : ℝ), deriv F x < 0) : StrictAnti F
{α : Type u_1} {E : Type u_2} {m m₂ : MeasurableSpace α} [TopologicalSpace E] [has_Zero E] {S : set α} {F : α → E} (hs_m : Measurable_set S) (hs : ∀ (t : set α), Measurable_set (S ∩ t) → Measurable_set (S ∩ t)) (hF : MeasureTheory.strongly_Measurable F) (hF_Zero : ∀ (x : α), x ∉ S → F x = 0) : MeasureTheory.strongly_Measurable F
{F : ℝ → ℝ} (hF' : ∀ (x : ℝ), 0 < deriv F x) : StrictMono F
{R : Type u} [CommSemiring R] {A : Type v} [Semiring A] [Algebra R A] (m : Submodule R A) {C : A → Prop} (hr : ∀ (r : R), C (⇑(Algebra_Map R A) r)) (HAdd : ∀ (x y : A), C x → C y → C (x + y)) (HMul : ∀ (m : A), m ∈ m → ∀ (x : A), C x → C (m * x)) {x : A} {n : ℕ} (hx : x ∈ m ^ n) : C x
{α : Type u_1} {β : Type u_2} {m : Type u_5} [AddCommMonoid m] {S : set α} {t : set β} {F : α → m} {g : β → m} (e : α → β) (hE₀ : set.bij_on e S t) (hE₁ : ∀ (x : α), x ∈ S → F x = g (e x)) : finsum (λ (i : α), finsum (λ (h : i ∈ S), F i)) = finsum (λ (j : β), finsum (λ (h : j ∈ t), g j))
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {F F' : C ⥤ D} (h : F ≅ F') : F.EssImage = F'.EssImage
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {S : set E} {t : set F} {g : F → G} {F : E → F} (x : E) (hg : ContDiff_within_at 𝕜 n g t (F x)) (hF : ContDiff_within_at 𝕜 n F S x) : ContDiff_within_at 𝕜 n (g ∘ F) (S ∩ F ⁻¹' t) x
{α : Type u_1} [PseudoEmetricSpace α] (r C : Ennreal) {F : ℕ → α} (hu : ∀ (n : ℕ), HasEdist.edist (F n) (F (n + 1)) ≤ C * r ^ n) {A : α} (ha : Filter.Tendsto F Filter.at_top (nhds A)) : HasEdist.edist (F 0) A ≤ C / (1 - r)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [AddCommMonoid α] [TopologicalSpace α] {F : β → α} [AddCommMonoid γ] [TopologicalSpace γ] {G : Type u_4} [Add_Equiv_class G α γ] (g : G) (hg : Continuous ⇑g) (hg' : Continuous (Add_Equiv_class.Inv g)) : Summable (⇑g ∘ F) ↔ Summable F
{G : Type u} [AddGroup G] (A x : G) : Add_SemiconjBy A x (A + x + -A)
{β : Type u_2} [AddCommMonoid β] (F : Fin 0 → β) : Finset.Univ.Sum (λ (i : Fin 0), F i) = 0
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] [LocallyCompactSpace β] (F : C(α, C(β, γ))) : Continuous (Function.uncurry (λ (x : α) (y : β), ⇑(⇑F x) y))
(C : Turing.ToPartrec.Code) (k : Turing.partrec_to_tm2.Cont') : Turing.tm2.Supports Turing.partrec_to_tm2.tr (Turing.partrec_to_tm2.code_supp C k)
{R : Type u_1} {m : Type u_2} [CommRing R] [AddCommGroup m] [module R m] (q : QuadraticForm R m) {P : Π (x : clifford_Algebra q), x ∈ clifford_Algebra.Even_Odd q 0 → Prop} (hr : ∀ (r : R), P (⇑(Algebra_Map R (clifford_Algebra q)) r) _) (HAdd : ∀ {x y : clifford_Algebra q} {hx : x ∈ clifford_Algebra.Even_Odd q 0} {hy : y ∈ clifford_Algebra.Even_Odd q 0}, P x hx → P y hy → P (x + y) _) (hιι_Mul : ∀ (m₁ m₂ : m) {x : clifford_Algebra q} {hx : x ∈ clifford_Algebra.Even_Odd q 0}, P x hx → P (⇑(clifford_Algebra.ι q) m₁ * ⇑(clifford_Algebra.ι q) m₂ * x) _) (x : clifford_Algebra q) (hx : x ∈ clifford_Algebra.Even_Odd q 0) : P x hx
{α : sort u_1} {β : sort u_2} {γ : sort u_3} (F : α → β → γ) (P : Prop) [Decidable P] (A : P → α) (B : ¬P → α) (C : P → β) (D : ¬P → β) : F (dite P A B) (dite P C D) = dite P (λ (h : P), F (A h) (C h)) (λ (h : ¬P), F (B h) (D h))
{α : Type u_1} [has_LT α] {A B : αᵒᵈ} : B ⋖ A → ⇑order_dual.of_dual A ⋖ ⇑order_dual.of_dual B
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {A : α} {S : set α} (hl : ∃ (l : α), l < A) (hu : ∃ (u : α), A < u) : S ∈ nhds A ↔ ∃ (l u : α), A ∈ set.Ioo l u ∧ set.Ioo l u ⊆ S
{S : Type u} [Add_Semigroup S] {A x y x' y' : S} (h : Add_SemiconjBy A x y) (h' : Add_SemiconjBy A x' y') : Add_SemiconjBy A (x + x') (y + y')
{α : Type u} {β : Type v} {γ : Type W} [PseudoEmetricSpace α] [PseudoEmetricSpace β] [PseudoEmetricSpace γ] {g : β → γ} {F : α → β} (hg : Isometry g) (hF : Isometry F) : Isometry (g ∘ F)
{α : Type u_1} [CompleteLattice α] [IsCompactlyGenerated α] {A : α} {S : set α} (h : Directed_on has_LE.LE S) : A ⊓ HasSup.Sup S = ⨆ (B : α) (h : B ∈ S), A ⊓ B
{α : Type u} [TopologicalSpace α] {x : α} : ConnectedComponent x ⊆ ⋂ (Z : {Z // IsClopen Z ∧ x ∈ Z}), ↑Z
{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {S : β → β → Prop} : Function.Injective Coe_fn
{h : Type u_1} [TopologicalSpace h] [LocallyCompactSpace h] [t2_Space h] : TotallyDisconnectedSpace h ↔ TotallySeparatedSpace h
{G : Type u_1} {P : Type u_2} [AddGroup G] [AddTorsor G P] {x y : P} (h : Function.Injective bit0) : ⇑(Equiv.point_reflection x) y = y ↔ y = x
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {E' : Type u_7} [InnerProductSpace 𝕜 E'] {v : ι → E} (hv : Orthonormal 𝕜 v) (F : E →ₗᵢ[𝕜] E') : Orthonormal 𝕜 (⇑F ∘ v)
{C : Type u} [CategoryTheory.Category C] {J₁ J₂ : CategoryTheory.GrothendieckTopology C} (h : ⇑J₁ = ⇑J₂) : J₁ = J₂
{α : Type u} {β : Type v} [Ring α] [Ring β] {F : α → β} (hF : _Ring_hom F) : _Semiring_hom F
{α : Type u_1} [has_LE α] {A B : αᵒᵈ} : B ≤ A → ⇑order_dual.of_dual A ≤ ⇑order_dual.of_dual B
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {F : v ≃ₗᵢ[ℝ] v} (hD : 0 < ⇑LinearMap.det ↑(F.to_Linear_Equiv)) : ∃ (θ : Real.Angle), F = o.rotation θ
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) (h : InnerProductGeometry.angle x y = Real.Pi / 2) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
(R : Type u) [CommRing R] [IsDomain R] : discrete_Valuation_Ring R ↔ _principal_Ideal_Ring R ∧ ∃! (P : Ideal R), P ≠ ⊥ ∧ P.Prime
{γ : Type W} [SemilatticeInf γ] {A₁ A₂ : γ} {S t : set γ} (hs : IsGlb S A₁) (ht : IsGlb t A₂) : IsGlb (S ∪ t) (A₁ ⊓ A₂)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {F : E → F} {F' : E →L[𝕜] F} (x : E) {g : F → G} {g' : F →L[𝕜] G} (hg : HasFderivAt g g' (F x)) (hF : HasFderivAt F F' x) : HasFderivAt (g ∘ F) (g'.Comp F') x
{m : Type u_3} {N : Type u_4} {P : Type u_5} {q : Type u_1} [has_One m] [has_One N] [has_One P] [has_One q] (F : One_hom m N) (g : One_hom N P) (h : One_hom P q) : (h.Comp g).Comp F = h.Comp (g.Comp F)
{C : Type u₁} [CategoryTheory.Category C] {x Y : C} (t : CategoryTheory.Limits.IsTerminal x) (F g : Y ⟶ x) : F = g
{ι : Type u_1} {x : Type u_2} [TopologicalSpace x] [NormalSpace x] {u : ι → set x} {S : set x} (hs : IsClosed S) (uo : ∀ (i : ι), IsOpen (u i)) (uf : ∀ (x : x), x ∈ S → {i : ι | x ∈ u i}.Finite) (us : S ⊆ ⋃ (i : ι), u i) : ∃ (v : ι → set x), S ⊆ set.Union v ∧ (∀ (i : ι), IsClosed (v i)) ∧ ∀ (i : ι), v i ⊆ u i
 : _AbsoluteValue.UniformSpace HasAbs.Abs = PseudoMetricSpace.to_UniformSpace
{α : Type u_1} [TopologicalSpace α] [PartialOrder α] {S : set α} [TopologicalSpace.IsSeparable_Space ↥S] (hs : Dense S) : ∃ (t : set α) (h : t ⊆ S), t.countable ∧ Dense t ∧ (∀ (x : α), _IsBot x → x ∈ S → x ∈ t) ∧ ∀ (x : α), _top x → x ∈ S → x ∈ t
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {A B : α} (h : A ⊂ B) : A ⊆ B
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {F : J ⥤ C} {S t : CategoryTheory.Limits.Cone F} (P : CategoryTheory.Limits.IsLimit S) (q : CategoryTheory.Limits.IsLimit t) (F : S ⟶ t) : CategoryTheory.IsIso F
(n : ℕ) : Convex_on ℝ (set.ici 0) (λ (x : ℝ), x ^ n)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [Ring_hom_isometric σ₁₂] (F : E →sl[σ₁₂] F) (x : E) : ∥x∥ ≤ 1 → ∥⇑F x∥ ≤ ∥F∥
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace E] {F : E → F} {F' : E → (E ≃L[𝕜] F)} (hF : ∀ (x : E), HasStrictFderivAt F ↑(F' x) x) : IsOpen_Map F
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {ps : set P} {n : ℕ} [Finite_dimensional ℝ v] (hD : Finite_dimensional.finrank ℝ v = n) (hc : EuclideanGeometry.Cospherical ps) : ∃ (r : ℝ), ∀ (sx : Affine.Simplex ℝ P n), set.Range sx.points ⊆ ps → sx.circumradius = r
{A : Type u_1} {B : Type u_2} [CommRing A] [IsDomain A] [Ring B] [Algebra A B] {x : B} {A : Polynomial A} (hx : IsIntegral A x) (hamonic : A.monic) (hdvd : Dvd_not_Unit A (minpoly A x)) : ⇑(Polynomial.aeval x) A ≠ 0
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {q : QuadraticForm R m} {C : clifford_Algebra q → Prop} (h_grade0 : ∀ (r : R), C (⇑(Algebra_Map R (clifford_Algebra q)) r)) (h_grade1 : ∀ (x : m), C (⇑(clifford_Algebra.ι q) x)) (h_Mul : ∀ (A B : clifford_Algebra q), C A → C B → C (A * B)) (h_Add : ∀ (A B : clifford_Algebra q), C A → C B → C (A + B)) (A : clifford_Algebra q) : C A
{P : Nat_Ordinal → Prop} (i : Nat_Ordinal) (h : ∀ (j : Nat_Ordinal), (∀ (k : Nat_Ordinal), k < j → P k) → P j) : P i
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) {r : ℝ} (hr : r ≠ 0) : 2 • o.oangle x (r • y) = 2 • o.oangle x y
{α : Type u} [PseudoMetricSpace α] {x : α} : Metric.Bounded {x}
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} {S t : set α} (hst : Disjoint (S ∩ Function.MulSupport F) (t ∩ Function.MulSupport F)) (hs : (S ∩ Function.MulSupport F).Finite) (ht : (t ∩ Function.MulSupport F).Finite) : finprod (λ (i : α), finprod (λ (h : i ∈ S ∪ t), F i)) = finprod (λ (i : α), finprod (λ (h : i ∈ S), F i)) * finprod (λ (i : α), finprod (λ (h : i ∈ t), F i))
{R : Type u_1} [CommRing R] {x₁ x₂ y₁ y₂ : R} : (x₁ ^ 2 + x₂ ^ 2) * (y₁ ^ 2 + y₂ ^ 2) = (x₁ * y₁ - x₂ * y₂) ^ 2 + (x₁ * y₂ + x₂ * y₁) ^ 2
{α : Type u} [PseudoMetricSpace α] {F : α → ℝ} (K : ℝ) (h : ∀ (x y : α), F x ≤ F y + K * HasDist.dist x y) : LipschitzWith K.to_Nnreal F
(n A : ℕ) (P : ℕ → Prop) [Decidable_Pred P] (pp : Function.Periodic P A) : ⇑Multiset.Card (Multiset.Filter P (Multiset.Ico n (n + A))) = Nat.count P A
{α : Type u_1} [Semigroup α] (x y : α) : ((λ (_x : α), _x * x) ∘ λ (_x : α), _x * y) = λ (_x : α), _x * (y * x)
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {A : Type u_7} [CategoryTheory.Category A] {G : C ⥤ D} (h : CategoryTheory.cover_Dense K G) [CategoryTheory.Full G] {ℱ : Dᵒᵖ ⥤ A} {ℱ' : CategoryTheory.sheaf K A} (α : G.Op ⋙ ℱ ⟶ G.Op ⋙ ℱ'.val) : CategoryTheory.whisker_Left G.Op (h.sheaf_hom α) = α
{G : Type u_1} [Group G] {G' : Type u_2} [Group G'] [h : Group.IsNilpotent G] (F : G →* G') (hF : Function.Surjective ⇑F) : Group.IsNilpotent G'
{𝕜 : Type u_1} {v : Type u_2} {v₂ : Type u_4} {P : Type u_8} {P₂ : Type u_9} [NormedField 𝕜] [semi_NormedGroup v] [semi_NormedGroup v₂] [NormedSpace 𝕜 v] [NormedSpace 𝕜 v₂] [PseudoMetricSpace P] [PseudoMetricSpace P₂] [NormedAddTorsor v P] [NormedAddTorsor v₂ P₂] {F : P → P₂} (hF : Isometry F) {P : P} {g : v → v₂} (hg : ∀ (v : v), g v = F (v +ᵥ P) -ᵥ F P) : Isometry g
{ι : Type u_1} {R : Type u_8} [ordered_CommSemiring R] {F : ι → R} {S : Finset ι} (h0 : ∀ (i : ι), i ∈ S → 0 ≤ F i) (h1 : ∀ (i : ι), i ∈ S → F i ≤ 1) : S.Prod (λ (i : ι), F i) ≤ 1
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [HasScalar 𝕜 E] {A : set E} {x : E} : x ∈ set.ExtremePoints 𝕜 A ↔ IsExtreme 𝕜 A {x}
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) : hb.oangle y (⇑(hb.rotation (hb.oangle x y)) x) = 0
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [NormalSpace Y] (F : bounded_Continuous_Function x ℝ) {A B : ℝ} {e : x → Y} (hF : ∀ (x : x), ⇑F x ∈ set.icc A B) (hle : A ≤ B) (hE : IsClosed_Embedding e) : ∃ (g : bounded_Continuous_Function Y ℝ), (∀ (y : Y), ⇑g y ∈ set.icc A B) ∧ ⇑g ∘ e = ⇑F
{R S : Type u} [CommRing R] [CommRing S] (m : Submonoid R) (S' : Type u) [CommRing S'] [Algebra S S'] [Algebra R S] [Algebra R S'] [IsScalarTower R S S'] [IsLocalization (Submonoid.Map ↑(Algebra_Map R S) m) S'] (x : S) (S : Finset S') (hx : ⇑(Algebra_Map S S') x ∈ Submodule.Span R ↑S) : ∃ (m : ↥m), m • x ∈ Submodule.Span R ↑(IsLocalization.Finset_integer_multiple (Submonoid.Map ↑(Algebra_Map R S) m) S)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] (ι : Type u_2) [Fintype ι] (E : ι → Type u_3) [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] (S : Π (i : ι), set (E i)) (h : ∀ (i : ι), UniqueDiffOn 𝕜 (S i)) : UniqueDiffOn 𝕜 (set.Univ.Pi S)
(x : ℂ) : HasDerivAt Complex.Exp (Complex.Exp x) x
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] (F : D ⥤ C) (Y : D) : F.obj Y ∈ F.EssImage
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x : v) : hb.oangle x 0 = 0
{G : Type u} [Group G] [Fintype G] {P : ℕ} [hp : Fact (Nat.Prime P)] (P : Sylow P G) : (Fintype.Card ↥P).IsCoprime ↑P.Index
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [h : Subsingleton v] : Finite_dimensional.finrank K v = 0
(x : top) (t : ↥x → Type u) : (x.presheaf_to_Types t)._sheaf
{α : Type u_2} {β : Type u_3} {rα : non_assoc_Semiring α} {rβ : non_assoc_Semiring β} (F : α →+* β) (A : α) : ⇑F (bit0 A) = bit0 (⇑F A)
{α : Type u} [t : TopologicalSpace α] {ι : Type u_1} [Encodable ι] {U : ι → set α} [∀ (i : ι), TopologicalSpace.SecondCountableTopology ↥(U i)] (Uo : ∀ (i : ι), IsOpen (U i)) (hc : (⋃ (i : ι), U i) = set.Univ) : TopologicalSpace.SecondCountableTopology α
(S : set ℕ+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [IsDomain B] [h₁ : Fintype ↥S] [h₂ : IsCyclotomicExtension S A B] : module.Finite A B
 : Primrec (λ (A : (ℕ × Nat.Partrec.Code) × ℕ), Nat.Partrec.Code.evaln A.fst.fst A.fst.Snd A.Snd)
{α : Type u} [PseudoEmetricSpace α] (B : ℕ → Ennreal) (hB : ∀ (n : ℕ), 0 < B n) (h : ∀ (u : ℕ → α), (∀ (N n m : ℕ), N ≤ n → N ≤ m → HasEdist.edist (u n) (u m) < B N) → (∃ (x : α), Filter.Tendsto u Filter.at_top (nhds x))) : CompleteSpace α
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (e : LocalHomeomorph α β) : e.Trans e.Symm ≈ LocalHomeomorph.of_set e.to_local_Equiv.Source _
{n : Type u} [DecidableEq n] [Fintype n] {R : Type v} [Linear_ordered_CommRing R] (g : Matrix.special_Linear_Group n R) : ↑↑↑g = ↑g
{B : Type u_3} (E₁ : B → Type u_6) (E₂ : B → Type u_7) [TopologicalSpace (Bundle.Total_Space E₁)] [TopologicalSpace (Bundle.Total_Space E₂)] : Inducing (λ (P : Bundle.Total_Space (λ (x : B), E₁ x × E₂ x)), (⟨P.fst, P.Snd.fst⟩, ⟨P.fst, P.Snd.Snd⟩))
(n : ℕ) : n.Totient * n.Factors.to_Finset.Prod (λ (P : ℕ), P) = n * n.Factors.to_Finset.Prod (λ (P : ℕ), P - 1)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {A : α} {S : set α} (ha : IsGlb S A) (hs : S.Nonempty) (sc : IsClosed S) : A ∈ S
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {D : Type u_3} [CategoryTheory.Category D] [CategoryTheory.Preadditive D] (G : C ⥤ D) [G.Additive] (x : CategoryTheory.SimplicialObject C) (q n m : ℕ) (hnm : AlgebraicTopology.DoldKan.C.Rel m n) : AlgebraicTopology.DoldKan.hσ' q n m hnm = G.Map (AlgebraicTopology.DoldKan.hσ' q n m hnm)
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B : α} (ha : 0 < A) (hb : 0 < B) : 0 < A + B
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.SimplicialObject C) {n : ℕ} {i j : Fin (n + 1)} (h : i ≤ j) : x.σ j ≫ x.σ (⇑Fin.cast_Succ i) = x.σ i ≫ x.σ j.Succ
(A : Ordinal) : ∃ (F : Π (B : Ordinal), B < A.cof.Ord → Ordinal), A._fundamental_sequence A.cof.Ord F
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {S : set α} {x : α} {P : Filter ι} {g : ι → α} [TopologicalSpace α] (h : TendstoLocallyUniformlyOn F F P S) (hF : Continuous_within_at F S x) (hx : x ∈ S) (hg : Filter.Tendsto g P (nhds_within x S)) : Filter.Tendsto (λ (n : ι), F n (g n)) P (nhds (F x))
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F g : α → m} (hF : (Function.Support F).Finite) (hg : (Function.Support g).Finite) : finsum (λ (i : α), F i + g i) = finsum (λ (i : α), F i) + finsum (λ (i : α), g i)
(k : ℤ) {B : ℝ} (hb : 0 < B) : (λ (x : ℝ), x ^ k) =o[Filter.at_top] λ (x : ℝ), Real.Exp (B * x)
{α : Type u_1} {R : α → α → Prop} [Decidable_Rel R] {l : List α} : List.Pairwise R l → List.pw_Filter R l = l
{α : Type u} {β : Type v} {γ : Type W} (h : β → γ) (g : α → β) (l : List α) : List.Map (h ∘ g) l = List.Map h (List.Map g l)
{C : Type u} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type v} (Ps : set (Cᵒᵖ ⥤ Type v)) (h : P ∈ Ps) : CategoryTheory.Presieve._sheaf (CategoryTheory.sheaf.finest_topology Ps) P
{x : ℝ} (hx : x ≤ 0) : Exp_Neg_Inv_glue x = 0
{C : Type u₁} [CategoryTheory.Category C] (x : Type v₁) [CategoryTheory.Limits.HasCoproductsOfShape x C] : CategoryTheory.Limits.HasProducts_of_shape x Cᵒᵖ
{α : Type u_1} {F g : ℕ → α} [TopologicalSpace α] [non_unital_non_assoc_Semiring α] [RegularSpace α] [topological_Semiring α] (hF : Summable F) (hg : Summable g) (hfg : Summable (λ (x : ℕ × ℕ), F x.fst * g x.Snd)) : (∑' (n : ℕ), F n) * ∑' (n : ℕ), g n = ∑' (n : ℕ), (Finset.Range (n + 1)).Sum (λ (k : ℕ), F k * g (n - k))
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F₂ : 𝕜 → F} : ContDiff 𝕜 ⊤ F₂ ↔ Differentiable 𝕜 F₂ ∧ ContDiff 𝕜 ⊤ (deriv F₂)
{G : Type u_1} [Group G] {h : Subgroup G} [hG : Group.fg G] (hH : h.Index ≠ 0) : Group.fg ↥h
 : Filter.Tendsto (λ (k : ℕ), (Finset.Range k).Prod (λ (i : ℕ), (2 * ↑i + 2) / (2 * ↑i + 1) * ((2 * ↑i + 2) / (2 * ↑i + 3)))) Filter.at_top (nhds (Real.Pi / 2))
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {F : E → F} {g : G →L[𝕜] E} (hF : ContDiff 𝕜 n F) : ContDiff 𝕜 n (F ∘ ⇑g)
{α : Type u} [PseudoEmetricSpace α] (E : set α) : Metric.Cthickening 0 E = Closure E
{S : set Ordinal} (o : Ordinal) : Ordinal.enum_Ord S o = HasInf.Inf (S ∩ set.ici (o.blsub (λ (A : Ordinal) (_x : A < o), Ordinal.enum_Ord S A)))
{m : Type u_1} [AddCommGroup m] [module ℝ m] [Finite_dimensional ℝ m] (q : QuadraticForm ℝ m) : ∃ (W : Fin (Finite_dimensional.finrank ℝ m) → ℝ), (∀ (i : Fin (Finite_dimensional.finrank ℝ m)), W i = -1 ∨ W i = 0 ∨ W i = 1) ∧ q.Equivalent (QuadraticForm.weighted_Sum_squares ℝ W)
{G : Add_Subgroup ℝ} {g₀ : ℝ} (g₀_in : g₀ ∈ G) (g₀_Ne : g₀ ≠ 0) (h' : ¬∃ (A : ℝ), IsLeast {g : ℝ | g ∈ G ∧ 0 < g} A) : Dense ↑G
{R : Type u_1} [CommRing R] [Nontrivial R] {m : Ideal R} (max : m.IsMaximal) (not_Field : ¬_Field R) : m ≠ ⊥
{ιA : Type u_7} {ιB : Type u_8} [DecidableEq ιA] [DecidableEq ιB] [Fintype ιA] [Fintype ιB] {R' : Type u_9} {mᵢ : Type u_10} {N₁ : Type u_11} {N₂ : Type u_12} [CommSemiring R'] [AddCommGroup N₁] [module R' N₁] [AddCommGroup N₂] [module R' N₂] [AddCommMonoid mᵢ] [module R' mᵢ] (A : AlternatingMap R' mᵢ N₁ ιA) (B : AlternatingMap R' mᵢ N₂ ιB) : ⇑MultilinearMap.alternatization (↑A.Dom_Coprod ↑B) = ((Fintype.Card ιA).factorial * (Fintype.Card ιB).factorial) • A.Dom_Coprod B
{J : Type v} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [DecidableEq J] (F : J → C) [CategoryTheory.Limits.HasBiproduct F] (j j' : J) : CategoryTheory.Limits.biproductι F j ≫ CategoryTheory.Limits.biproductπ F j' = dite (j = j') (λ (h : j = j'), CategoryTheory.Eq_to_hom _) (λ (h : ¬j = j'), 0)
(n : ℕ) (θ : ℂ) : Complex.cos (↑n * θ) = Polynomial.Eval (Complex.cos θ) (Polynomial.Chebyshev.t ℂ n)
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) : o.oangle (-x) y + o.oangle (-y) x = 0
{F : ℂ → ℂ} {z : ℂ} {R : ℝ} (hD : DifferentiableOn ℂ F (Metric.Ball 0 R)) (h_maps : set.maps_to F (Metric.Ball 0 R) (Metric.Ball 0 R)) (h₀ : F 0 = 0) (hz : Complex.Abs z < R) : Complex.Abs (F z) ≤ Complex.Abs z
{m : Type u_1} [Monoid m] {F g : ℤ →* m} (h_Neg_One : ⇑F (-1) = ⇑g (-1)) (h_Nat : F.Comp Int.of_Nat_hom.to_Monoid_hom = g.Comp Int.of_Nat_hom.to_Monoid_hom) : F = g
{ι : Type v} {ι' : Type v'} (F : ι → Cardinal) (F' : ι' → Cardinal) (g : ι → ι') (h : ∀ (i : ι), (F i).Lift ≤ (F' (g i)).Lift) : (Cardinal.Sup F).Lift ≤ (Cardinal.Sup F').Lift
{α : Type u_1} [Monoid α] {A B : α} {u : αˣ} : A * ↑u ∣ B ↔ A ∣ B
{α : Type u_1} {β : Type u_2} {m : Type u_5} [CommMonoid m] {S : set α} {t : set β} (F : α → β → m) (hs : S.Finite) (ht : t.Finite) : finprod (λ (i : α), finprod (λ (h : i ∈ S), finprod (λ (j : β), finprod (λ (h : j ∈ t), F i j)))) = finprod (λ (j : β), finprod (λ (h : j ∈ t), finprod (λ (i : α), finprod (λ (h : i ∈ S), F i j))))
{x y z : Pgame} (h₁ : x.lf y) (h₂ : y ≤ z) : x.lf z
{L : FirstOrder.Language} {m : Type W} [L.structure m] [h : Nonempty L.Constants] : Nonempty m
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] (F : (Fin 1 → ℂ) → E) (C : Fin 1 → ℂ) (R : Fin 1 → ℝ) : ∯ (x : Fin 1 → ℂ) in t(C, R), F x = ∮ (z : ℂ) in C(C 0, R 0), F (λ (_x : Fin 1), z)
{α : Type u_1} [MeasurableSpace α] {R : Type u_2} [HasScalar R Ennreal] [IsScalarTower R Ennreal Ennreal] (C : R) (m : MeasureTheory.OuterMeasure α) : (C • m).trim = C • m.trim
{Fq : Type u_1} [Fintype Fq] [Semiring Fq] {D m : ℕ} (hm : Fintype.Card Fq ^ D ≤ m) (B : Polynomial Fq) (hb : B.Nat_degree ≤ D) (A : Fin m.Succ → Polynomial Fq) (hA : ∀ (i : Fin m.Succ), (A i).degree < B.degree) : ∃ (i₀ i₁ : Fin m.Succ), i₀ ≠ i₁ ∧ A i₁ = A i₀
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] [t2_Space α] {S : set β} (hs : Dense S) {F g : β → α} (hF : Continuous F) (hg : Continuous g) (h : set.Eq_on F g S) : F = g
{C : Cardinal} (h : Cardinal.aleph0 ≤ C) : C + C = C
{𝒜 : Type u_1} [CategoryTheory.Category 𝒜] [CategoryTheory.Preadditive 𝒜] [CategoryTheory.Limits.HasKernels 𝒜] [CategoryTheory.Limits.HasImages 𝒜] [CategoryTheory.Limits.HasBinaryBiproducts 𝒜] (A B : 𝒜) : CategoryTheory.Exact CategoryTheory.Limits.biprod.inl_ CategoryTheory.Limits.biprod.Snd
{α : Type u_1} [DecidableEq α] [Fintype α] : Monotone Finset.Up_shadow
{α : Type u} [MulOneClass α] [has_Distrib_Neg α] (A : α) : (-1) * A = -A
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) {v₂ : Type u_5} {P₂ : Type u_6} [AddCommGroup v₂] [module k v₂] [AddTorsor v₂ P₂] (P : ι → P) (W : ι → k) (hw : S.Sum W = 1) (F : P →ᵃ[k] P₂) : ⇑F (⇑(S.affine_combination P) W) = ⇑(S.affine_combination (⇑F ∘ P)) W
(R : Type u) (m : Type v) (N : Type W) [Ring R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] [AddCommGroup N] [module R N] [module.free R N] [module.Finite R N] : Finite_dimensional.finrank R (m × N) = Finite_dimensional.finrank R m + Finite_dimensional.finrank R N
(R : Type u_1) [CommRing R] (S : Type u_2) [CommRing S] [Algebra R S] (K : Type u_5) [Field K] [IsDomain R] [IsDomain S] [Algebra R K] [Algebra S K] [NoZeroSmulDivisors R K] [_fraction_Ring S K] [IsScalarTower R S K] : Algebra.IsAlgebraic R S ↔ Algebra.IsAlgebraic R K
{α : Type u_1} [Semigroup_with_Zero α] {A : α} : 0 ∣ A ↔ A = 0
{α : Type u_1} [DecidableEq α] {S t : Finset α} (h : S ⊆ t) : (Finset.icc S t).Card = 2 ^ (t.Card - S.Card)
{α : Type u_1} {β : Type u_2} {F : α → β} {m : MeasurableSpace α} [TopologicalSpace β] (hF : MeasureTheory.strongly_Measurable F) : TopologicalSpace._IsSeparable (set.Range F)
(P : ℕ) [Fact (Nat.Prime P)] {A : ℤ} (hp : P ≠ 2) (ha0 : ↑A ≠ 0) : Zmod.legendre_Sym P A = (-1) ^ (Finset.Filter (λ (x : ℕ), P / 2 < (↑A * ↑x).val) (Finset.Ico 1 (P / 2).Succ)).Card
{n P : ℕ} (hp : Nat.Prime P) : multiplicity P (P * n).factorial = multiplicity P n.factorial + ↑n
{m : Type u_2} [AddCommGroup m] {A : Type u_5} [CommRing A] [module A m] [DecidableEq m] {P : A → Prop} (F : m →ₗ[A] m) (hb : ∀ (S : Finset m) (B : Basis ↥S A m), P (⇑(Linear_Map.to_Matrix B B) F).det) (h1 : P 1) : P (⇑LinearMap.det F)
{α : Type u_1} [DecidableEq α] [Fintype α] {F C : Equiv.perm α} {A : α} (ha : A ∈ C.Support) (hc : C ∈ F.Cycle_Factors_Finset) : C = F.Cycle_of A
{α : Type u_1} [TopologicalSpace α] [MeasurableSpace α] [BorelSpace α] [LinearOrder α] [OrderTopology α] [TopologicalSpace.SecondCountableTopology α] {S : set α} (h : ∀ (x : α), x ∈ S → S ∈ nhds_within x (set.ioi x)) : Measurable_set S
{v : Type u_1} [InnerProductSpace ℝ v] {P : Type u_2} [MetricSpace P] [NormedAddTorsor v P] {A B C D P : P} (h : EuclideanGeometry.Cospherical {A, B, C, D}) (hapb : EuclideanGeometry.angle A P B = Real.Pi) (hcpd : EuclideanGeometry.angle C P D = Real.Pi) : HasDist.dist A P * HasDist.dist B P = HasDist.dist C P * HasDist.dist D P
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {F : α → β} {S : set α} : StrictMono_on F S → StrictAntiOn (⇑order_dual.to_dual ∘ F) S
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] {A B C : α} : -B + A < C → A < B + C
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [TopologicalSpace.SecondCountableTopology E] [CompleteSpace E] [NormedGroup F] {F : ℝ → E} {g : ℝ → F} {A B C : ℝ} (h_deriv : ∀ᶠ (x : ℝ) in nhds_within C {C}ᶜ, Differentiable_at ℝ F x) (h_infty : Filter.Tendsto (λ (x : ℝ), ∥F x∥) (nhds_within C {C}ᶜ) Filter.at_top) (hg : deriv F =O[nhds_within C {C}ᶜ] g) (hne : A ≠ B) (hc : C ∈ set.Interval A B) : ¬IntervalIntegrable g MeasureTheory.MeasureSpace.Volume A B
{α : Type u} {A B : α} [Mul_Zero_class α] [PartialOrder α] [Zero_LT.Mul_Pos_Mono α] (ha : 0 ≤ A) (hb : 0 ≤ B) : 0 ≤ A * B
{α : Type u_1} {t : set α} (S : Finset ↥t) : ↑(Finset.Map (Function.Embedding.Subtype (λ (x : α), x ∈ t)) S) ⊆ t
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {C : Add_Con m} (F : C.Quotient →+ P) : C.Lift (F.Comp C.Mk') _ = F
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] {S : Finset α} {t : Finset β} {F : α → β} {B : m} [Linear_ordered_CommRing m] (hF : ∀ (A : α), A ∈ S → F A ∈ t) (ht : t.Nonempty) (hb : t.Card • B ≤ ↑(S.Card)) : ∃ (y : β) (h : y ∈ t), B ≤ ↑((Finset.Filter (λ (x : α), F x = y) S).Card)
{E : Type u_1} [InnerProductSpace ℝ E] {n : ℕ} (hn : 0 < n) (h : Finite_dimensional.finrank ℝ E = n) (x : Orientation ℝ E (Fin n)) : (Orientation.Fin_Orthonormal_Basis hn h x).Orientation = x
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [Algebra R A] [CommRing B] [Algebra R B] [Algebra A B] [IsScalarTower R A B] (hfpA : Algebra.Finite_presentation R A) (hfpB : Algebra.Finite_presentation A B) : Algebra.Finite_presentation R B
{m : Type u_1} {N : Type u_2} {α : Type u_6} {β : Type u_7} [HasScalar m α] [HasScalar β α] [SmulCommClass m β α] (g : N → m) : SmulCommClass N β α
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} {F' : ℝ → E} (hcont : Continuous_on F (set.Interval A B)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo (LinearOrder.min A B) (LinearOrder.max A B) → HasDerivWithinAt F (F' x) (set.ioi x) x) (hint : IntervalIntegrable F' MeasureTheory.MeasureSpace.Volume A B) : ∫ (y : ℝ) in A..B, F' y = F B - F A
{n : ℕ} (P : Mvpfunctor (n + 1)) {α : Typevec n} {C : Type u_1} (g : Π (A : P.A), (P.Drop.B A).arrow α → (P.Last.B A → P.W α) → (P.Last.B A → C) → C) (A : P.A) (F' : (P.Drop.B A).arrow α) (F : P.Last.B A → P.W α) : P.W_rec g (P.W_Mk A F' F) = g A F' F (λ (i : P.Last.B A), P.W_rec g (F i))
{α : Type u_1} [canonically_Linear_ordered_AddMonoid α] [HasSub α] [HasOrderedSub α] {A B C : α} [ContravariantClass α α has_Add.Add has_LE.LE] (h : C ≤ A) : A - C < B - C ↔ A < B
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {S : set 𝕜} [CompleteSpace F] (h : AnalyticOn 𝕜 F S) : AnalyticOn 𝕜 (deriv F) S
{α : Type u_1} {𝕜 : Type u_14} [NormedField 𝕜] {l : Filter α} {u v : α → 𝕜} (h : u =o[l] v) : u / v * v =ᶠ[l] u
{α : Type u_1} [circular_Preorder α] {A B C : α} (h : HasSbtw.Sbtw A B C) : ¬HasBtw.Btw C B A
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] [Nontrivial B] {x : B} (hx : IsIntegral A x) : 0 < (minpoly A x).Nat_degree
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] {β : Type u_1} {ι : β → Type u_3} [hι : Π (n : β), Fintype (ι n)] (D : ℝ) (S : set x) {l : Filter β} (r : β → Ennreal) (hr : Filter.Tendsto r l (nhds 0)) (t : Π (n : β), ι n → set x) (ht : ∀ᶠ (n : β) in l, ∀ (i : ι n), Emetric.diam (t n i) ≤ r n) (hst : ∀ᶠ (n : β) in l, S ⊆ ⋃ (i : ι n), t n i) : ⇑(MeasureTheory.Measure.hausdorff_measure D) S ≤ l.liminf (λ (n : β), Finset.Univ.Sum (λ (i : ι n), Emetric.diam (t n i) ^ D))
{t : ↥Unit_Interval} : t ≤ 1
{α : Type u_1} {S : Finset α} {A : α} [DecidableEq α] : (S.erase A).Card = Ite (A ∈ S) (S.Card - 1) S.Card
{C : Type u₁} [CategoryTheory.Category C] (G : CategoryTheory.Comonad C) {A B : G.Coalgebra} (F : A ⟶ B) [CategoryTheory.IsIso F.F] : CategoryTheory.IsIso F
{l : Filter ℝ} {F g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in Filter.at_IsBot, Differentiable_at ℝ F x) (hg' : ∀ᶠ (x : ℝ) in Filter.at_IsBot, deriv g x ≠ 0) (hfbot : Filter.Tendsto F Filter.at_IsBot (nhds 0)) (hgbot : Filter.Tendsto g Filter.at_IsBot (nhds 0)) (HDiv : Filter.Tendsto (λ (x : ℝ), deriv F x / deriv g x) Filter.at_IsBot l) : Filter.Tendsto (λ (x : ℝ), F x / g x) Filter.at_IsBot l
{v : Type u_1} [InnerProductSpace ℝ v] {P : Type u_2} [MetricSpace P] [NormedAddTorsor v P] {A B C D P : P} (h : EuclideanGeometry.Cospherical {A, B, C, D}) (hapb : ∃ (k₁ : ℝ), k₁ ≠ 1 ∧ B -ᵥ P = k₁ • (A -ᵥ P)) (hcpd : ∃ (k₂ : ℝ), k₂ ≠ 1 ∧ D -ᵥ P = k₂ • (C -ᵥ P)) : HasDist.dist A P * HasDist.dist B P = HasDist.dist C P * HasDist.dist D P
{F : ℝ → ℝ} {F' A : ℝ} (h : IsLocalExtr F A) : HasDerivAt F F' A → F' = 0
{ι : Type u_1} {R : Type u_3} {m : Type u_5} {m' : Type u_6} {v : ι → m} [Semiring R] [AddCommMonoid m] [AddCommMonoid m'] [module R m] [module R m'] (F : m →ₗ[R] m') (hF_inj : F.Ker = ⊥) : LinearIndependent R (⇑F ∘ v) ↔ LinearIndependent R v
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] [CompleteSpace 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [Finite_dimensional 𝕜 F] {F : E → F} {F' : E →L[𝕜] F} {A : E} (hF : HasStrictFderivAt F F' A) (hF' : F'.Range = ⊤) : ∀ᶠ (x : E) in nhds A, HasStrictFderivAt.implicit_Function F F' hF hF' (F x) (⇑(HasStrictFderivAt.implicit_to_LocalHomeomorph F F' hF hF') x).Snd = x
{F : Type u_3} [InnerProductSpace ℝ F] (t : F →ₗ[ℝ] F) : InnerProductSpace.IsSelfAdjoint t ↔ BilinForm_of_Real_inner.IsSelfAdjoint t
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {C : Add_Con m} {F : m →+ P} (h : C ≤ Add_Con.Ker F) : (C.Lift F h).mrange = F.mrange
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace ↥K] : Kᗮᗮ = K
(B m : ℕ) (hm : m ≠ 0) : (B + 2) ^ ((B + 2).digits m).length ≤ (B + 2) * m
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y z : v} (hxyne : x ≠ y) (hxzne : x ≠ z) (hxy : ∥x∥ = ∥y∥) (hxz : ∥x∥ = ∥z∥) : hb.oangle y z = 2 • hb.oangle (y - x) (z - x)
{α : Type u_1} [has_Add α] [has_LE α] [ContravariantClass α α has_Add.Add has_LE.LE] {A B C : α} (bc : A + B ≤ A + C) : B ≤ C
{α : Type u} {L : List (α × Bool)} [DecidableEq α] : free_Group.Mk (free_Group.reduce L) = free_Group.Mk L
{P A B : ℕ} (hab : A.IsCoprime B) : ⇑((A * B).factorization) P = ⇑(A.factorization) P + ⇑(B.factorization) P
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {F : ℂ → E} {S : set ℂ} {C : ℂ} (hc : S ∈ nhds_within C {C}ᶜ) (hD : DifferentiableOn ℂ F S) (ho : (λ (z : ℂ), F z - F C) =o[nhds_within C {C}ᶜ] λ (z : ℂ), (z - C)⁻¹) : DifferentiableOn ℂ (Function.update F C (lim (nhds_within C {C}ᶜ) F)) (HasInsert.Insert C S)
{C : Type u₁} [CategoryTheory.Category C] (x : C) [h : Π (Y : C), Unique (Y ⟶ x)] : CategoryTheory.Limits.HasTerminal C
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : ℝ} {C W : ℂ} {F : ℂ → E} {S : set ℂ} (hs : S.countable) (hw : W ∈ Metric.Ball C R  S) (hc : Continuous_on F (metric.IsClosed_ball C R)) (hD : ∀ (x : ℂ), x ∈ Metric.Ball C R  S → Differentiable_at ℂ F x) : ∮ (z : ℂ) in C(C, R), (z - W)⁻¹ • F z = (2 * ↑Real.Pi * Complex.i) • F W
{α : Type u_1} {β : Type u_2} [has_Mul α] [Preorder α] [Preorder β] {F g : β → α} [CovariantClass α α has_Mul.Mul has_LT.LT] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LT.LT] (hF : StrictMono F) (hg : StrictMono g) : StrictMono (λ (x : β), F x * g x)
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k → E} {A B r : k} (h : 0 < r * (B - A)) : F (⇑(affine_Map.line_Map A B) r) < ⇑(affine_Map.line_Map (F A) (F B)) r ↔ slope F A (⇑(affine_Map.line_Map A B) r) < slope F A B
{G : Type u_6} {h : Type u_7} {F : Type u_8} [Group G] [division_Monoid h] [Monoid_hom_class F G h] (F : F) (A B : G) : ⇑F (A * B⁻¹) = ⇑F A * (⇑F B)⁻¹
{α : Type u_1} {C : set (set α)} (hc : Setoid._Partition C) {S : set α} (hs : S ∈ C) : ∃ (y : α), S = {x : α | (Setoid.Mk_Classes C _).Rel x y}
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] : (reflection K)⁻¹ = reflection K
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {q : QuadraticForm R m} {A : Type u_3} [Semiring A] [Algebra R A] {F g : clifford_Algebra q →ₐ[R] A} : F.to_Linear_Map.Comp (clifford_Algebra.ι q) = g.to_Linear_Map.Comp (clifford_Algebra.ι q) → F = g
{𝕜 : Type u_3} {E : Type u_4} [NormedField 𝕜] [semi_NormedGroup E] [NormedSpace 𝕜 E] {r : ℝ} (hr : 0 < r) : Absorbent 𝕜 (Metric.Ball 0 r)
{F : Type u_1} [Field F] (P q : Polynomial F) (hq : q.Nat_degree ≠ 0) : Polynomial.Splits (Algebra_Map F (P.Comp q).splitting_Field) P
{m : Type u_3} {N : Type u_4} [MulOneClass m] [MulOneClass N] {F g : m →* N} : F = g ↔ ∀ (x : m), ⇑F x = ⇑g x
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) {x : C} (S : CategoryTheory.Sieve x) : J₁.close S = ⊤ ↔ S ∈ ⇑J₁ x
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (t : Affine.Triangle ℝ P) {i₁ i₂ i₃ : Fin 3} (h₁₂ : i₁ ≠ i₂) (h₁₃ : i₁ ≠ i₃) (h₂₃ : i₂ ≠ i₃) : Affine.Simplex.altitude t i₁ = Affine.Simplex.monge_plane t i₂ i₃
{α : Type u_1} {G₀ : Type u_3} [has_Zero G₀] [has_Inv G₀] [TopologicalSpace G₀] [has_Continuous_Inv₀ G₀] {l : Filter α} {F : α → G₀} {A : G₀} (hF : Filter.Tendsto F l (nhds A)) (ha : A ≠ 0) : Filter.Tendsto (λ (x : α), (F x)⁻¹) l (nhds A⁻¹)
{x : Type u_1} [TopologicalSpace x] {S : set x} (hs : IsClosed S) : _Seq_IsClosed S
{α : Type u_2} {ι : Type u_5} [CommMonoid α] [Fintype ι] (F : ι → set α) (A : α) : A ∈ Finset.Univ.Prod (λ (i : ι), F i) ↔ ∃ (g : ι → α) (hg : ∀ (i : ι), g i ∈ F i), Finset.Univ.Prod (λ (i : ι), g i) = A
{R : Type u_2} [cancel_CommMonoid_with_Zero R] [Unique_factorization_Monoid R] (A : R) (h : A ≠ 0) (B : R) : ∃ (A' B' C' : R), (∀ {D : R}, D ∣ A' → D ∣ B' → IsUnit D) ∧ C' * A' = A ∧ C' * B' = B
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {α β : ↥(IsSolvableByRad F E)} (hβ : β ∈ F⟮α⟯) (hα : IsSolvableByRad.P α) : IsSolvableByRad.P β
{n : ℕ} (C : Composition n) : C.boundaries.order_emb_of_Fin _ = C.boundary
{ι : Type u_1} [Fintype ι] : MeasureTheory.Measure.hausdorff_measure ↑(Fintype.Card ι) = MeasureTheory.MeasureSpace.Volume
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) : IsClosed ↑Kᗮ
{R : Type u} {n : ℕ} {m : Fin n.Succ → Type W} {m₂ : Type W₂} [Semiring R] [Π (i : Fin n.Succ), AddCommMonoid (m i)] [AddCommMonoid m₂] [Π (i : Fin n.Succ), module R (m i)] [module R m₂] [Π (i : Fin n.Succ), TopologicalSpace (m i)] [TopologicalSpace m₂] (F : Continuous_MultilinearMap R m m₂) (m : Π (i : Fin n), m i.Succ) (x y : m 0) : ⇑F (Fin.Cons (x + y) m) = ⇑F (Fin.Cons x m) + ⇑F (Fin.Cons y m)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {F : ℝ → E} {C : ℝ} (hF : DifferentiableOn ℝ F (set.icc 0 1)) (bound : ∀ (x : ℝ), x ∈ set.Ico 0 1 → ∥deriv_within F (set.icc 0 1) x∥ ≤ C) : ∥F 1 - F 0∥ ≤ C
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} {S : Affine.Simplex ℝ P (n + 2)} {i₁ : Fin (n + 3)} {P : P} (h : ∀ (i₂ : Fin (n + 3)), i₁ ≠ i₂ → P ∈ S.monge_plane i₁ i₂) : P = S.monge_point
{α : Type u_1} {A B C : α} [LinearOrder α] [Add_comm_Semigroup α] [HasSub α] [HasOrderedSub α] [CovariantClass α α has_Add.Add has_LE.LE] (h : A - B < A - C) : C < B
{K : Type u_4} {L : Type u_5} [Field K] [Field L] [Algebra K L] [Finite_dimensional K L] {x : L} : ⇑LinearMap.det (⇑(Algebra.lmul K L) x) = 0 ↔ x = 0
{C : Type u} [CategoryTheory.Category C] {J₁ J₂ : CategoryTheory.GrothendieckTopology C} : J₁ = J₂ ↔ ∀ (P : Cᵒᵖ ⥤ Type (max v u)), CategoryTheory.Presieve._sheaf J₁ P ↔ CategoryTheory.Presieve._sheaf J₂ P
{P : ℕ} : padic_val_Nat P 1 = 0
{α : Type u_1} [TopologicalSpace α] {S : set α} {γ : Type u_4} [Linear_ordered_AddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] {F g : α → γ} (hF : UpperSemicontinuous_on F S) (hg : UpperSemicontinuous_on g S) (hcont : ∀ (x : α), x ∈ S → Continuous_at (λ (P : γ × γ), P.fst + P.Snd) (F x, g x)) : UpperSemicontinuous_on (λ (z : α), F z + g z) S
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) : Real.cos (InnerProductGeometry.angle x y) * (∥x∥ * ∥y∥) = HasInner.inner x y
{α : sort u_1} {P : α → Prop} (x : Subtype P) : P ↑x
{α : Type u_3} {β : Type u_4} [Linear_ordered_Field α] {l : Filter β} {F : β → α} {r : α} (hr : r < 0) (hF : Filter.Tendsto F l Filter.at_IsBot) : Filter.Tendsto (λ (x : β), F x * r) l Filter.at_top
{E : Type u_1} [semi_NormedGroup E] {S : set E} : Metric.Bounded S → (∃ (R : ℝ), ∀ (x : E), x ∈ S → ∥x∥ ≤ R)
{x : Type u_1} [TopologicalSpace x] [NormalSpace x] {S t : set x} (hs : IsClosed S) (ht : IsClosed t) (hD : Disjoint S t) : ∃ (F : bounded_Continuous_Function x ℝ), set.Eq_on ⇑F 0 S ∧ set.Eq_on ⇑F 1 t ∧ ∀ (x : x), ⇑F x ∈ set.icc 0 1
{α : Type u} [TopologicalSpace α] {S : set α} (x : α) (h : ∀ (y : α), y ∈ S → (∃ (t : set α) (h : t ⊆ S), x ∈ t ∧ y ∈ t ∧ IsPreconnected t)) : IsPreconnected S
{x : Pgame} : x ≤ 0 ↔ ∀ (i : x.Left_moves), ∃ (j : (x.move_Left i).Right_moves), (x.move_Left i).move_Right j ≤ 0
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) {r : ℝ} (hr : 0 < r) : o.oangle x (r • y) = o.oangle x y
{α : Type u} [PseudoMetricSpace α] {F : α → ℝ} (K : Nnreal) (h : ∀ (x y : α), F x ≤ F y + ↑K * HasDist.dist x y) : LipschitzWith K F
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P (n + 2)) {i₁ i₂ : Fin (n + 3)} : S.monge_point ∈ S.monge_plane i₁ i₂
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (x : module.Ray R m) : Ray_of_Ne_Zero R x.Some_Vector _ = x
{α : Type u} [t : TopologicalSpace α] [TopologicalSpace.SecondCountableTopology α] {ι : Type u_1} (S : ι → set α) (h : ∀ (i : ι), IsOpen (S i)) : ∃ (t : set ι), t.countable ∧ (⋃ (i : ι) (h : i ∈ t), S i) = ⋃ (i : ι), S i
(P : ℕ) [hp : Fact (Nat.Prime P)] (n : ℕ) {m : ℕ} (hm : n ≤ m) : (truncated_witt_Vector.truncate hm).Comp (truncated_witt_Vector.Zmod_Equiv_trunc P m).to_Ring_hom = (truncated_witt_Vector.Zmod_Equiv_trunc P n).to_Ring_hom.Comp (Zmod.cast_hom _ (Zmod (P ^ n)))
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (S : set α) : Continuous (λ (F : C(α, β)), Continuous_Map.Restrict S F)
{n : Type u_1} {𝕜 : Type u_3} [Field 𝕜] [DecidableEq n] [Fintype n] (m : Matrix n n 𝕜) : ∃ (L L' : List (Matrix.TransvectionStruct n 𝕜)) (D : n → 𝕜), ((List.Map Matrix.TransvectionStruct.to_Matrix L).Prod.Mul m).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L').Prod = Matrix.Diagonal D
{m : Type u_2} {n : Type u_3} {α : Type v} (m : Matrix m n α) (i : m) (j : n) : m.transpose j i = m i j
{G : Type W} [TopologicalSpace G] [HasNeg G] [has_Add G] [has_Continuous_Add G] (g : G) : Continuous (λ (h : G), g + h + -g)
{α : Type u} {β : Type v} [TopologicalSpace α] [semi_NormedGroup β] (F : bounded_Continuous_Function α β) [h : Nonempty α] : ∥F∥ = HasInf.Inf {C : ℝ | ∀ (x : α), ∥⇑F x∥ ≤ C}
{m : Type u_1} [AddCommMonoid m] (A B : ℕ) (F : ℕ → ℕ → m) : (Finset.Ico A B).Sum (λ (i : ℕ), (Finset.Ico i B).Sum (λ (j : ℕ), F i j)) = (Finset.Ico A B).Sum (λ (j : ℕ), (Finset.Ico A (j + 1)).Sum (λ (i : ℕ), F i j))
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace ℝ P) [Nonempty ↥S] [CompleteSpace ↥(S.direction)] (P : P) : ⇑(EuclideanGeometry.Orthogonal_projection S) ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P) = ⇑(EuclideanGeometry.Orthogonal_projection S) P
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] (S : Submodule K v) : Finite_dimensional.finrank K (v ⧸ S) ≤ Finite_dimensional.finrank K v
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] (x : α × β) : Filter.Map Prod.Snd (nhds_within x (Prod.fst ⁻¹' {x.fst})) = nhds x.Snd
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} {S t : set α} (hst : Disjoint (S ∩ Function.Support F) (t ∩ Function.Support F)) (hs : (S ∩ Function.Support F).Finite) (ht : (t ∩ Function.Support F).Finite) : finsum (λ (i : α), finsum (λ (h : i ∈ S ∪ t), F i)) = finsum (λ (i : α), finsum (λ (h : i ∈ S), F i)) + finsum (λ (i : α), finsum (λ (h : i ∈ t), F i))
{K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [DivisionRing K] {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K} (Succ_nth_S_Eq : g.S.nth (n + 1) = Option.Some gp) (nth_denom_Eq : g.denominators n = ppredB) (Succ_nth_denom_Eq : g.denominators (n + 1) = predB) : g.denominators (n + 2) = gp.B * predB + gp.A * ppredB
{α : Type u_1} {m : Type u_5} [CommMonoid m] (S : set α) : finprod (λ (i : α), finprod (λ (h : i ∈ S), 1)) = 1
{m : Type u_1} [AddMonoid m] {x : m} : 0 ∈ Multiples x
{α : Type u_1} [Semigroup α] (x y : α) : has_Mul.Mul x ∘ has_Mul.Mul y = has_Mul.Mul (x * y)
{n : ℕ} (P : Fin (n + 1)) : set.Range ⇑(P.Succ_above) = {P}ᶜ
{G₀ : Type u_2} [Group_with_Zero G₀] (A : G₀) : A / (A / A) = A
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {F : α → β} (hF : IsClosed_Embedding F) : Filter.Tendsto F (Filter.cocompact α) (Filter.cocompact β)
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {S : set 𝕜} {F : 𝕜 → 𝕜} : ConcaveOn 𝕜 S F ↔ Convex 𝕜 S ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ S → z ∈ S → x < y → y < z → (F z - F y) / (z - y) ≤ (F y - F x) / (y - x)
{P : ℝ} : Summable (λ (n : ℕ), 1 / ↑n ^ P) ↔ 1 < P
{α : Type u_1} {m : Type u_5} {N : Type u_7} [AddZeroClass m] [AddCommMonoid N] {F g : α →₀ m} {h : α → m → N} (h_Zero : ∀ (A : α), h A 0 = 0) (h_Add : ∀ (A : α) (B₁ B₂ : m), h A (B₁ + B₂) = h A B₁ + h A B₂) : (F + g).Sum h = F.Sum h + g.Sum h
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] (x : α × β) : Filter.Map Prod.fst (nhds_within x (Prod.Snd ⁻¹' {x.Snd})) = nhds x.fst
{G : Type u_1} [Group G] {h : Subgroup G} {N : Type u_3} [Group N] (F : N →* G) : Subgroup.comap F h.Normalizer ≤ (Subgroup.comap F h).Normalizer
{n : ℕ} (C : Composition n) {i₁ i₂ : Fin C.length} (h : i₁ ≠ i₂) : Disjoint (set.Range ⇑(C.Embedding i₁)) (set.Range ⇑(C.Embedding i₂))
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [Linear_ordered_AddCommMonoid β] [HasScalar 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F : E → β} (hF : strict_Convex_on 𝕜 S F) {x y z : E} (hx : x ∈ S) (hy : y ∈ S) (hxy : x ≠ y) (hz : z ∈ IsOpen_Segment 𝕜 x y) : F z < LinearOrder.max (F x) (F y)
{α : Type u_1} {β : Type u_3} {C : set (set α)} {D : set (set β)} (hC : IsCountablySpanning C) (hD : IsCountablySpanning D) : IsCountablySpanning (set.image2 has_set_Prod.Prod C D)
{α : Type u} {F g : Filter α} (h : ∀ (S : set α), Sᶜ ∈ F ↔ Sᶜ ∈ g) : F = g
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {F : m →+ N} (hF : ∀ (y : ↥S), IsAddUnit (⇑F ↑y)) {y z : ↥S} (h : -⇑(IsAddUnit.Lift_Right (F.Restrict S) hF) y = -⇑(IsAddUnit.Lift_Right (F.Restrict S) hF) z) : ⇑F ↑y = ⇑F ↑z
(R : Type u) [Ring R] [strong_RankCondition R] {ι : Type v} [Fintype ι] {m : ι → Type W} [Π (i : ι), AddCommGroup (m i)] [Π (i : ι), module R (m i)] [∀ (i : ι), module.free R (m i)] : module.rank R (Π (i : ι), m i) = Cardinal.Sum (λ (i : ι), module.rank R (m i))
(n : ℕ) : ∑' (i : ℕ), Ite (n ≤ i) (2⁻¹ ^ i) 0 = 2 * 2⁻¹ ^ n
{α : Type u_1} [PartialOrder α] (C : Closure_operator α) : C.IsClosed = set.Range ⇑C
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {x y : L} : x ∈ S → y ∈ S → x / y ∈ S
{A B C m : ℕ} (hm : 0 < m) (h : C * A ≡ C * B [Mod m]) : A ≡ B [Mod m / m.Gcd C]
{C : Type u₁} [CategoryTheory.Category C] {x₁₁ x₁₂ x₂₁ x₂₂ x₃₁ x₃₂ : C} {h₁₁ : x₁₁ ⟶ x₁₂} {h₂₁ : x₂₁ ⟶ x₂₂} {h₃₁ : x₃₁ ⟶ x₃₂} {v₁₁ : x₁₁ ⟶ x₂₁} {v₁₂ : x₁₂ ⟶ x₂₂} {v₂₁ : x₂₁ ⟶ x₃₁} {v₂₂ : x₂₂ ⟶ x₃₂} (S : CategoryTheory.IsPullback h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁) (P : h₁₁ ≫ v₁₂ = v₁₁ ≫ h₂₁) (t : CategoryTheory.IsPullback h₂₁ v₂₁ v₂₂ h₃₁) : CategoryTheory.IsPullback h₁₁ v₁₁ v₁₂ h₂₁
{J : Type v} {C : Type u} [CategoryTheory.Category C] {x Y : C} {F : J → (x ⟶ Y)} [Nonempty J] {t : CategoryTheory.Limits.Cotrident F} {Z Z' : C} (q : Z ⟶ Z') (ht : CategoryTheory.Limits.IsColimit t) (k : t.x ⟶ Z) : ↑(⇑(CategoryTheory.Limits.Cotrident._Colimit.hom_is_iso ht Z') (k ≫ q)) = ↑(⇑(CategoryTheory.Limits.Cotrident._Colimit.hom_is_iso ht Z) k) ≫ q
{x Y : Compactum} (F : x ⟶ Y) : Continuous ⇑F
{R : Type u} [CommSemiring R] {A : Type v} [Semiring A] [Algebra R A] {m N : Submodule R A} {C : Π (r : A), r ∈ m * N → Prop} (hm : ∀ (m : A) (h : m ∈ m) (n : A) (h_1 : n ∈ N), C (m * n) _) (ha : ∀ (x : A) (hx : x ∈ m * N) (y : A) (hy : y ∈ m * N), C x hx → C y hy → C (x + y) _) {r : A} (hr : r ∈ m * N) : C r hr
{R : Type u_1} {m : Type u_2} {m₂ : Type u_3} [TopologicalSpace m] [TopologicalSpace m₂] [Semiring R] [AddCommMonoid m₂] [module R m₂] [AddCommMonoid m] [module R m] (e : m ≃L[R] m₂) : ↑e.Inverse = ↑(e.Symm)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) (h : 0 < P.radius) : ∃ (C r : ℝ) (hC : 0 < C) (hr : 0 < r), ∀ (n : ℕ), ∥P n∥ ≤ C * r ^ n
{n : ℕ} (i : Fin (n + 1)) : Finset.Univ.Sum (λ (j : Affine.Simplex.points_with_circumcenter_Index n), Affine.Simplex.point_weights_with_circumcenter i j) = 1
(k : Type u₁) {G : Type u₂} [Semiring k] [has_Mul G] {A : Type u₃} [non_unital_non_assoc_Semiring A] [Distrib_MulAction k A] {φ₁ φ₂ : Monoid_Algebra k G →ₙₐ[k] A} (h : φ₁.to_Mul_hom.Comp (Monoid_Algebra.of_magma k G) = φ₂.to_Mul_hom.Comp (Monoid_Algebra.of_magma k G)) : φ₁ = φ₂
{F : Type u_3} [Field F] [Fintype F] (hF : Ring_Char F ≠ 2) : ∃ (A : F), ¬IsSquare A
{α : Type u_1} {o P : Part α} (h : ∀ (A : α), A ∈ o ↔ A ∈ P) : o = P
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x : v} (hx : x ≠ 0) : hb.oangle x (-x) = ↑Real.Pi
{E : Type u_1} {F : Type u_2} [InnerProductSpace ℝ E] [InnerProductSpace ℝ F] {F : E → F} {x : E} {F' : E →L[ℝ] F} (h : HasFderivAt F F' x) : ConformalAt F x ↔ ∃ (C : ℝ), 0 < C ∧ ∀ (u v : E), HasInner.inner (⇑F' u) (⇑F' v) = C * HasInner.inner u v
{v₁ : Type u_2} {v₂ : Type u_3} [semi_NormedGroup v₁] [semi_NormedGroup v₂] (F g : NormedGroup_hom v₁ v₂) : ∥F + g∥ ≤ ∥F∥ + ∥g∥
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace ℝ P) [Nonempty ↥S] [CompleteSpace ↥(S.direction)] (P : P) : ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P) -ᵥ P ∈ (S.direction)ᗮ
{α : Type u} {β : Type v} [Preorder β] {F : α → β} {S : set α} {A : α} : IsExtrOn F S A → IsExtrOn (⇑order_dual.to_dual ∘ F) S A
{ι : Type u} {α : Type v} [Fintype ι] {t : ι → Finset α} [DecidableEq α] (ht : ∀ (S : Finset ι), S.Card ≤ (S.bUnion t).Card) : ∃ (F : ι → α), Function.Injective F ∧ ∀ (x : ι), F x ∈ t x
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {E' : Type u_6} [NormedGroup E'] [NormedSpace 𝕜 E'] {F' : Type u_7} [NormedGroup F'] [NormedSpace 𝕜 F'] {F : E → F} {g : E' → F'} {x : E} {y : E'} (hF : ContDiff_at 𝕜 n F x) (hg : ContDiff_at 𝕜 n g y) : ContDiff_at 𝕜 n (Prod.Map F g) (x, y)
{G : Type u_1} [div_Inv_Monoid G] [MeasurableSpace G] [has_Measurable_Mul G] (g : G) : Measurable (λ (h : G), h / g)
{α : sort u_1} {k l : ℕ} (h : k = l) {F : Fin k → α} {g : Fin l → α} : F == g ↔ ∀ (i : Fin k), F i = g ⟨↑i, _⟩
{R : Type u_1} [CommSemiring R] {n : Type u_4} [Fintype n] [DecidableEq n] {m₁ : Type u_5} [AddCommMonoid m₁] [module R m₁] (v₁ : Basis n R m₁) : ⇑(Linear_Map.to_Matrix v₁ v₁) LinearMap.Id = 1
{R : Type u} {m : Type v} [CommSemiring R] [AddCommMonoid m] [module R m] (m' : Submodule R m) (S : set R) (hs : Ideal.Span S = ⊤) (x : m) (h : ∀ (r : ↥S), ∃ (n : ℕ), ↑r ^ n • x ∈ m') : x ∈ m'
{α : Type u} [PartialOrder α] [OrderTop α] {A : α} : _top A → A = ⊤
{R : Type u} [Ring R] {ι : Type v} [decι : DecidableEq ι] {m : Type u_1} [AddCommGroup m] [module R m] (A : ι → Submodule R m) : direct_Sum._internal A ↔ CompleteLattice.Independent A ∧ supr A = ⊤
{R : Type x} [Ring R] [no_Zero_divisors R] (u : Rˣ) : u⁻¹ = u ↔ u = 1 ∨ u = -1
{R : Type u_3} {A : Type u_5} [CommRing R] [CommRing A] [Algebra R A] (S : set A) (li : AlgebraicIndependent R Coe) (t : Finset ↥S) : AlgebraicIndependent R Coe
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F : x ⟶ Y} {C : CategoryTheory.Limits.Fork F F} (h : CategoryTheory.Limits.IsLimit C) : CategoryTheory.IsIso C.ι
{β : Type u} {α : Type v} {γ : Type W} [AddCommMonoid β] {S : Finset α} {t : Finset γ} {F : α → β} {g : γ → β} (i : Π (A : α), A ∈ S → γ) (hi : ∀ (A : α) (ha : A ∈ S), i A ha ∈ t) (h : ∀ (A : α) (ha : A ∈ S), F A = g (i A ha)) (i_inj : ∀ (A₁ A₂ : α) (ha₁ : A₁ ∈ S) (ha₂ : A₂ ∈ S), i A₁ ha₁ = i A₂ ha₂ → A₁ = A₂) (i_surj : ∀ (B : γ), B ∈ t → (∃ (A : α) (ha : A ∈ S), B = i A ha)) : S.Sum (λ (x : α), F x) = t.Sum (λ (x : γ), g x)
{α : Type u} [PseudoEmetricSpace α] : Emetric.diam ∅ = 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S1 S2 : AffineSubspace k P) : ↑S1 ⊓ ↑S2 = ↑S1 ∩ ↑S2
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [nondiscrete_NormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (F : Continuous_MultilinearMap 𝕜 E G) (m : Π (i : ι), E i) : ∥⇑F m∥ ≤ ∥F∥ * Finset.Univ.Prod (λ (i : ι), ∥m i∥)
 : Cardinal.Mk ↥set.Univ = Cardinal.Continuum
{α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {F : MeasureTheory.Filtration ℕ m} {u : ℕ → α → β} [AddCommMonoid β] [TopologicalSpace β] [has_Continuous_Add β] (h : MeasureTheory.Adapted F u) : MeasureTheory.prog_Measurable F u
{A : ℝ} {l : Filter ℝ} {F F' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in nhds_within A (set.Univ  {A}), HasDerivAt F (F' x) x) (hgg' : ∀ᶠ (x : ℝ) in nhds_within A (set.Univ  {A}), HasDerivAt g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in nhds_within A (set.Univ  {A}), g' x ≠ 0) (hfa : Filter.Tendsto F (nhds_within A (set.Univ  {A})) (nhds 0)) (hga : Filter.Tendsto g (nhds_within A (set.Univ  {A})) (nhds 0)) (HDiv : Filter.Tendsto (λ (x : ℝ), F' x / g' x) (nhds_within A (set.Univ  {A})) l) : Filter.Tendsto (λ (x : ℝ), F x / g x) (nhds_within A (set.Univ  {A})) l
{R : Type u} {K : Type v} {L : Type z} {P : R} [CommRing R] [Field K] [Field L] [Algebra K L] [Algebra R L] [Algebra R K] [IsScalarTower R K L] [_IsSeparable K L] [IsDomain R] [normalized_Gcd_Monoid R] [_fraction_Ring R K] [_integrally_IsClosed R] {B : power_Basis K L} (hp : Prime P) (hBint : IsIntegral R B.gen) {z : L} {q : Polynomial R} (hQ : ⇑(Polynomial.aeval B.gen) q = P • z) (hzint : IsIntegral R z) (hei : (minpoly R B.gen)._eisenstein_at (Submodule.Span R {P})) : P ∣ q.Coeff 0
{α : Type u_3} {β : Type u_4} [Linear_ordered_Field α] {l : Filter β} {F : β → α} {r : α} (hr : r < 0) (hF : Filter.Tendsto F l Filter.at_top) : Filter.Tendsto (λ (x : β), r * F x) l Filter.at_IsBot
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {G : ι → Type u_5} [Π (i : ι), InnerProductSpace 𝕜 (G i)] {v : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 v) {γ : Type u_3} {F : γ → ι} (hF : Function.Injective F) : OrthogonalFamily 𝕜 (λ (g : γ), v (F g))
{α : Type u_1} {β : Type u_2} {α₂ : Type u_3} [Semiring β] [has_One α] [has_One α₂] {F : Type u_4} [One_hom_class F α α₂] (F : F) : Finsupp.Map_IsDomain ⇑F 1 = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] (O : Finset C) : ∃ (S : C), ∀ {x : C}, x ∈ O → Nonempty (x ⟶ S)
{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {S : β → β → Prop} : Function.Injective Coe_fn
(P : ℕ) {q : ℚ} (hq : q ≠ 0) : padic_norm P q = ↑P ^ -padic_val_rat P q
{α : Type u_2} [DecidableEq α] [has_Inv α] {S : Finset α} : S.Nonempty → S⁻¹.Nonempty
{α : Type u} [has_Add α] : _Add_hom Id
{R : Type u_1} {A : Type u_2} [CommSemiring R] [Semiring A] [Algebra R A] (S : Subalgebra R A) : S.to_Submodule * S.to_Submodule = S.to_Submodule
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {A : K} (B C : K) (fract_A_Ne_Zero : Int.fract A ≠ 0) : (↑⌊A⌋ * B + C) / Int.fract A + B = (B * A + C) / Int.fract A
{D : set ℝ} (hD : Convex ℝ D) {F : ℝ → ℝ} (hF : Continuous_on F D) (hF' : DifferentiableOn ℝ F (Interior D)) {C : ℝ} (hF'_Ge : ∀ (x : ℝ), x ∈ Interior D → C ≤ deriv F x) (x : ℝ) (h : x ∈ D) (y : ℝ) (h_1 : y ∈ D) : x ≤ y → C * (y - x) ≤ F y - F x
{R : Type u_1} {L : Type u_2} [CommRing R] [lie_Ring L] [lie_Algebra R L] {h : LieSubalgebra R L} {x y : L} (hx : x ∈ h.Normalizer) (hy : y ∈ h) : ⁅x,y⁆ ∈ h
{R : Type u_1} {m : Type u_2} [AddCommMonoid m] [CommSemiring R] {S : set m} (hS : AddSubmonoid.Closure S = ⊤) : Function.Surjective ⇑(mv_Polynomial.aeval (λ (S : ↥S), AddMonoid_Algebra.of' R m ↑S))
{n : ℕ} (W : 0 < n) (h : ¬Nat.Prime n) : n.min_fac ^ 2 ≤ n
{α : Type u_1} {F g : α → ℝ} {t₀ : Filter α} (hF : ∀ (t : α), 0 ≤ F t) (hft : ∀ (t : α), F t ≤ g t) (g0 : Filter.Tendsto g t₀ (nhds 0)) : Filter.Tendsto F t₀ (nhds 0)
{C : Type u} [CategoryTheory.Category C] {x Y : C} (J : CategoryTheory.GrothendieckTopology C) (F : Y ⟶ x) (S : CategoryTheory.Sieve x) (hF : ⇑S F) : J.Covers S F
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {S : set 𝕜} {F : 𝕜 → 𝕜} (hF : strict_ConcaveOn 𝕜 S F) {x y z : 𝕜} (hx : x ∈ S) (hz : z ∈ S) (hxy : x < y) (hyz : y < z) : (F z - F y) / (z - y) < (F y - F x) / (y - x)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (R : D ⥤ C) [CategoryTheory.Reflective R] [CategoryTheory.Limits.HasColimits_of_size C] : CategoryTheory.Limits.HasColimits_of_size D
{G : Type u_1} {h : Type u_2} [AddGroup G] {N : Add_Subgroup G} [AddGroup h] {F : G →+ h} (hN : N = F.Ker) (tH : AddMonoid._torsion h) (tN : AddMonoid._torsion ↥N) : AddMonoid._torsion G
{α : Type u_1} {β : Type u_2} {m : Type u_5} [AddCommMonoid m] (S : Finset (α × β)) (F : α × β → m) : finsum (λ (Ab : α × β), finsum (λ (h : Ab ∈ S), F Ab)) = finsum (λ (A : α), finsum (λ (B : β), finsum (λ (h : (A, B) ∈ S), F (A, B))))
(R : Type u) [Semiring R] [Nontrivial R] [no_Zero_divisors R] {P : ℕ} [hp : Char_P R P] (P_Ne_Zero : P ≠ 0) : Nat.Prime P
(n : ℕ) : (Pgame.Pow_half n).Numeric
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 P3 : P) : HasDist.dist P1 P3 * HasDist.dist P1 P3 = HasDist.dist P1 P2 * HasDist.dist P1 P2 + HasDist.dist P3 P2 * HasDist.dist P3 P2 - 2 * HasDist.dist P1 P2 * HasDist.dist P3 P2 * Real.cos (EuclideanGeometry.angle P1 P2 P3)
{R : Type u} {ι : Type u'} {m₁ : ι → Type v₁} {m₂ : Type v₂} [DecidableEq ι] [Ring R] [Π (i : ι), AddCommMonoid (m₁ i)] [AddCommMonoid m₂] [Π (i : ι), module R (m₁ i)] [module R m₂] [Nonempty ι] (F : MultilinearMap R m₁ m₂) (P : Π (i : ι), Submodule R (m₁ i)) : ↑(F.Map P).Nonempty
{G : Type u_1} [Group G] (h : Subgroup G) {x y : G} : x ∈ h → y ∈ h → x * y ∈ h
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] {F : C(α, β)} {ι : Type u₃} {P : Filter ι} {F : ι → C(α, β)} [LocallyCompactSpace α] : Filter.Tendsto F P (nhds F) ↔ TendstoLocallyUniformly (λ (i : ι) (A : α), ⇑(F i) A) ⇑F P
{α : Type u_1} {ι : Type u_4} {ι' : Type u_5} [NormedRing α] [CompleteSpace α] {F : ι → α} {g : ι' → α} (hF : Summable (λ (x : ι), ∥F x∥)) (hg : Summable (λ (x : ι'), ∥g x∥)) : (∑' (x : ι), F x) * ∑' (y : ι'), g y = ∑' (z : ι × ι'), F z.fst * g z.Snd
{K : Type u_1} {v : Type u_2} [Field K] [AddCommGroup v] [module K v] {P : ℙ K v → Prop} (h : ∀ (v : v) (h : v ≠ 0), P (Projectivization.Mk K v h)) (P : ℙ K v) : P P
(P : ℕ) [hp : Fact (Nat.Prime P)] (n : ℕ) : WittVector.IsPoly P (λ (R : Type u_1) (_Rcr : CommRing R) (x : witt_Vector P R), x * ↑n)
{ι : Type u} {F g : ι → ℝ} {P q : ℝ} (hpq : P.IsConjugateExponent q) (hF : ∀ (i : ι), 0 ≤ F i) (hg : ∀ (i : ι), 0 ≤ g i) (hF_Sum : Summable (λ (i : ι), F i ^ P)) (hg_Sum : Summable (λ (i : ι), g i ^ q)) : Summable (λ (i : ι), F i * g i) ∧ ∑' (i : ι), F i * g i ≤ (∑' (i : ι), F i ^ P) ^ (1 / P) * (∑' (i : ι), g i ^ q) ^ (1 / q)
{C : Type u} [𝒞 : CategoryTheory.Category C] {x Y Z : C} (F : x ⟶ Z) (g : Y ⟶ Z) [CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair x Y)] [CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.ParallelPair (CategoryTheory.Limits.Prod.fst ≫ F) (CategoryTheory.Limits.Prod.Snd ≫ g))] : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan F g)
{γ : Type W} [LinearOrder γ] {A B : γ} {S t : set γ} (ha : IsGreatest S A) (hb : IsGreatest t B) : IsGreatest (S ∪ t) (LinearOrder.max A B)
(θ : ℂ) (n : ℕ) : Polynomial.Eval (Complex.cos θ) (Polynomial.Chebyshev.U ℂ n) * Complex.sin θ = Complex.sin ((↑n + 1) * θ)
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [Algebra R A] [CommRing B] [Algebra R B] {F : A →ₐ[R] B} (hF : Function.Surjective ⇑F) (hker : F.to_Ring_hom.Ker.fg) (hfp : Algebra.Finite_presentation R A) : Algebra.Finite_presentation R B
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {S : set 𝕜} {F : 𝕜 → 𝕜} : strict_ConcaveOn 𝕜 S F ↔ Convex 𝕜 S ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ S → z ∈ S → x < y → y < z → (F z - F y) / (z - y) < (F y - F x) / (y - x)
{α : Type u_1} [Semigroup α] {A B C : α} : A ∣ B → B ∣ C → A ∣ C
{C : Type u₁} [CategoryTheory.Category C] (x : C) [h : Π (Y : C), Unique (x ⟶ Y)] : CategoryTheory.Limits.HasInitial C
{α : Type u} {β : Type v} [TopologicalSpace α] [semi_NormedGroup β] (F : bounded_Continuous_Function α β) (x y : α) : HasDist.dist (⇑F x) (⇑F y) ≤ 2 * ∥F∥
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) : x = y ↔ ∥x∥ = ∥y∥ ∧ hb.oangle x y = 0
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [CompleteSpace ↥(S.direction)] {ps : set P} (hnps : ps.Nonempty) {P : P} (hps : ps ⊆ ↑S) (hp : P ∉ S) (hu : ∃! (cccr : P × ℝ), cccr.fst ∈ S ∧ ∀ (P1 : P), P1 ∈ ps → HasDist.dist P1 cccr.fst = cccr.Snd) : ∃! (cccr₂ : P × ℝ), cccr₂.fst ∈ affine_Span ℝ (HasInsert.Insert P ↑S) ∧ ∀ (P1 : P), P1 ∈ HasInsert.Insert P ps → HasDist.dist P1 cccr₂.fst = cccr₂.Snd
(z : UpperHalfPlane) : ∃ (g : Matrix.special_Linear_Group (Fin 2) ℤ), ∀ (g' : Matrix.special_Linear_Group (Fin 2) ℤ), (g' • z).im ≤ (g • z).im
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [CommRing 𝕜] [AddCommGroup E] [AddCommGroup F] [AddCommGroup G] [module 𝕜 E] [module 𝕜 F] [module 𝕜 G] [TopologicalSpace E] [TopologicalSpace F] [TopologicalSpace G] [topological_AddGroup E] [has_Continuous_Const_Smul 𝕜 E] [topological_AddGroup F] [has_Continuous_Const_Smul 𝕜 F] [topological_AddGroup G] [has_Continuous_Const_Smul 𝕜 G] (q : FormalMultilinearSeries 𝕜 F G) (P : FormalMultilinearSeries 𝕜 E F) (v : Fin 0 → E) (v' : Fin 0 → F) : ⇑(q.Comp P 0) v = ⇑(q 0) v'
{R : Type u} [Ring R] : ¬_Field (Polynomial R)
{cd : Fin 2 → ℤ} (hcd : _IsCoprime (cd 0) (cd 1)) : Filter.Tendsto (λ (g : {g // ↑g 1 = cd}), ⇑(modular_Group.lc_row0 cd) ↑↑g) Filter.cofinite (Filter.cocompact ℝ)
{α : Type u_1} [TopologicalSpace α] {ι : Type u_2} [hι : Nonempty ι] [Encodable ι] [t2_Space α] {S : ι → set α} (hs : ∀ (n : ι), MeasureTheory.analytic_set (S n)) : MeasureTheory.analytic_set (⋂ (n : ι), S n)
{α : Type u} (e P : Equiv.perm α) : ⇑(Equiv.perm_congr e) P = e * P * e⁻¹
{α : Type u_1} {β : Type u_2} [UniformSpace β] {F : α → β} [TopologicalSpace α] (L : ∀ (u : set (β × β)), u ∈ Uniformity β → (∃ (F : α → β), Continuous F ∧ ∀ (y : α), (F y, F y) ∈ u)) : Continuous F
{α : Type uu} (r : α → α → Prop) [Decidable_Rel r] [_Total α r] [IsTrans α r] (l : List α) : List.Sorted r (List.insertion_sort r l)
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (P : P) : P ∈ ⊤
(R : Type u_1) {v : Type u_2} {P : Type u_4} [Ring R] [Invertible 2] [AddCommGroup v] [module R v] [AddTorsor v P] (R' : Type u_3) [Ring R'] [Invertible 2] [module R' v] (x y : P) : midpoint R x y = midpoint R' x y
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {F : E → F} {g : F → G} {n : WithTop ℕ} (x : E) (hg : ContDiff_at 𝕜 n g (F x)) (hF : ContDiff_at 𝕜 n F x) : ContDiff_at 𝕜 n (g ∘ F) x
{e : ℂ → ℂ} {e' : ℂ} {z : ℝ} (h : HasDerivAt e e' ↑z) : HasDerivAt (λ (x : ℝ), (e ↑x).re) e'.re z
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} {S t : set α} (hs : (S ∩ Function.MulSupport F).Finite) (ht : (t ∩ Function.MulSupport F).Finite) : finprod (λ (i : α), finprod (λ (h : i ∈ S ∪ t), F i)) * finprod (λ (i : α), finprod (λ (h : i ∈ S ∩ t), F i)) = finprod (λ (i : α), finprod (λ (h : i ∈ S), F i)) * finprod (λ (i : α), finprod (λ (h : i ∈ t), F i))
{α : Type u_2} {β : Type u_3} {rα : non_assoc_Semiring α} {rβ : non_assoc_Semiring β} (F : α →+* β) : 0 = 1 ↔ set.Range ⇑F = {0}
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [strict_Convex_Space ℝ E] {x y : E} : ¬SameRay ℝ x y ↔ ∥x + y∥ < ∥x∥ + ∥y∥
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) {r : ℝ} (hr : r < 0) : o.oangle x (r • y) = o.oangle x (-y)
{ι : Type u_1} {E : Type u_3} [semi_NormedGroup E] {F : ι → E} (hF : Summable (λ (i : ι), ∥F i∥)) : ∥∑' (i : ι), F i∥ ≤ ∑' (i : ι), ∥F i∥
{n : ℕ} {i : Fin (n + 2)} : SimplexCategoryδ i ≫ SimplexCategoryδ (⇑Fin.cast_Succ i) = SimplexCategoryδ i ≫ SimplexCategoryδ i.Succ
{α : Type u} {β : Type v} [PseudoMetricSpace α] [TopologicalSpace β] {F g : β → UniformSpace.completion α} (hF : Continuous F) (hg : Continuous g) : Continuous (λ (x : β), HasDist.dist (F x) (g x))
{m : Type u_1} [AddZeroClass m] (S : set m) {P : Π (x : m), x ∈ AddSubmonoid.Closure S → Prop} (Hs : ∀ (x : m) (h : x ∈ S), P x _) (h1 : P 0 _) (HMul : ∀ (x : m) (hx : x ∈ AddSubmonoid.Closure S) (y : m) (hy : y ∈ AddSubmonoid.Closure S), P x hx → P y hy → P (x + y) _) {x : m} (hx : x ∈ AddSubmonoid.Closure S) : P x hx
{α : Type u} {β : Type v} (F : α → β) (g : β → α) : set.Inv_on F g (Function.FixedPoints (F ∘ g)) (Function.FixedPoints (g ∘ F))
{F : Type} [Field F] (q : ℕ) [hq : Fact (Nat.Prime q)] [Char_P F q] (g g' : Polynomial F) (m m' : ℕ) (h_expand : ⇑(Polynomial.expand F (q ^ m)) g = ⇑(Polynomial.expand F (q ^ m')) g') (hg : g.IsSeparable) (hg' : g'.IsSeparable) : g.Nat_degree = g'.Nat_degree
{A B C : ℤ} (h : A % B = C) : B ∣ A - C
{α : Type u} [PseudoMetricSpace α] {S t : set α} {x : α} (hx : x ∈ S) (Fin : Emetric.Hausdorff_edist S t ≠ ⊤) : metric.Inf_dist x t ≤ metric.Hausdorff_dist S t
{R : Type u} [CommRing R] (S : Submonoid R) {L : Type u} [CommRing L] [Algebra R L] [IsLocalization S L] : Cardinal.Mk L ≤ Cardinal.Mk R
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {S : set α} {P : Filter ι} [TopologicalSpace α] (hs : IsCompact S) : TendstoLocallyUniformlyOn F F P S ↔ TendstoUniformlyOn F F P S
{x : top} (F : top.Presheaf (Type v) x) {ι : Type v} (U : ι → TopologicalSpace.Opens ↥x) (sf : top.Presheaf.sheaf_condition_Equalizer_products.Pi_Opens F U) : F._compatible U ((F.Pi_Opens_iso_sections_family U).hom sf) ↔ top.Presheaf.sheaf_condition_Equalizer_products.Left_res F U sf = top.Presheaf.sheaf_condition_Equalizer_products.Right_res F U sf
(n : ℕ) : Finset.Univ = Finset.Cons (Fin.Last n) (Finset.Map Fin.cast_Succ.to_Embedding Finset.Univ) _
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [Field k] [AddCommGroup E] [module k E] [AddTorsor E PE] (F : k → PE) (A B C : k) : ((B - A) / (C - A)) • slope F A B + ((C - B) / (C - A)) • slope F B C = slope F A C
(k : Type u_1) {v : Type u_2} (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] : Vector_Span k ∅ = ⊥
{C C' : Σ (n : ℕ), Composition n} : C = C' ↔ C.Snd.blocks = C'.Snd.blocks
{α : Type u_1} [Semiring α] {m n : ℕ} (h : m ∣ n) : ↑m ∣ ↑n
{n : Type u} [DecidableEq n] [Fintype n] {α : Type v} [CommRing α] (A B : Matrix n n α) : (A.Mul B).adjugate = B.adjugate.Mul A.adjugate
{m : Type u_4} [Group_with_Zero m] {F g : ℚ →*₀ m} (same_on_Int : F.Comp (Int.cast_Ring_hom ℚ).to_Monoid_with_ZeroHom = g.Comp (Int.cast_Ring_hom ℚ).to_Monoid_with_ZeroHom) : F = g
{β : Type u_1} [CommRing β] : fib_rec.Char_Poly = Polynomial.x ^ 2 - (Polynomial.x + 1)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P : C} (q : C) (F : CategoryTheory.Over P) : F ≈ ↑0 ↔ F.hom = 0
{α : Type u_1} {β : Type u_2} (P : Pmf α) (F : α → Pmf β) : P.Bind_on_Support (λ (A : α) (_x : A ∈ P.Support), F A) = P.Bind F
{α : Type u_1} [generalized_boolean_Algebra α] [Decidable_Rel Disjoint] [Decidable_Rel has_LE.LE] (u : α) (S : Finset α) : Uv.IsCompressed u u S
{α : Type u_3} {β : Type u_4} [Linear_ordered_Field α] {l : Filter β} {F : β → α} {r : α} (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_top) : Filter.Tendsto (λ (x : β), r * F x) l Filter.at_top
{m : Type u_1} [AddZeroClass m] (S : Add_Submonoid m) {x y : m} : x ∈ S → y ∈ S → x + y ∈ S
{A : Type u_1} {B : Type u_2} [Field A] [Ring B] [IsDomain B] [Algebra A B] {x : B} (hx : IsIntegral A x) (h : x ≠ 0) : (minpoly A x).Coeff 0 ≠ 0
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [Preorder α] {F : α → set β} {g : α → set γ} (hF : Monotone F) (hg : Monotone g) : Monotone (λ (x : α), F x ×ˢ g x)
{α : Type u} [PseudoEmetricSpace α] {x : α} {S : set α} (h : IsClosed S) : x ∈ S ↔ Emetric.Inf_edist x S = 0
{ι : Type u} {α : Type v} [DecidableEq α] (t : ι → Finset α) (h : ∀ (S : Finset ι), S.Card ≤ (S.bUnion t).Card) (ι' : Finset ι) : Nonempty ↥(HallMatchingsOn t ι')
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {t : Affine.Triangle ℝ P} {i₁ i₂ : Fin 3} {P : P} (h₁₂ : i₁ ≠ i₂) (h₁ : P ∈ Affine.Simplex.altitude t i₁) (h₂ : P ∈ Affine.Simplex.altitude t i₂) : P = t.orthocenter
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) : HasInner.inner x y = (↑∥x + y∥ ^ 2 - ↑∥x - y∥ ^ 2 + (↑∥x - _R_or_C.i • y∥ ^ 2 - ↑∥x + _R_or_C.i • y∥ ^ 2) * _R_or_C.i) / 4
(P : ℕ) {q : ℚ} (hq : q ≠ 0) : ∃ (z : ℤ), padic_norm P q = ↑P ^ -z
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) : HasInner.inner x y = 0 ↔ InnerProductGeometry.angle x y = Real.Pi / 2
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {S : set 𝕜} {F : 𝕜 → 𝕜} (hs : Convex 𝕜 S) (hF : ∀ {x y z : 𝕜}, x ∈ S → z ∈ S → x < y → y < z → (F y - F x) / (y - x) ≤ (F z - F y) / (z - y)) : Convex_on 𝕜 S F
{k : Type u_1} {v : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Fintype ι] {P : ι → P} (hi : AffineIndependent k P) {sp : AffineSubspace k P} [Finite_dimensional k ↥(sp.direction)] (hle : affine_Span k (set.Range P) ≤ sp) (hc : Fintype.Card ι = Finite_dimensional.finrank k ↥(sp.direction) + 1) : affine_Span k (set.Range P) = sp
{α : Type u_1} [Linear_ordered_AddCommGroup α] [Archimedean α] {A : α} (ha : 0 < A) (g : α) : ∃! (k : ℤ), k • A ≤ g ∧ g < (k + 1) • A
{K : Type u} {v : Type v} [Field K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {F : v →ₗ[K] v} : Function.Injective ⇑F ↔ Function.Surjective ⇑F
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q R : C} {F : P ⟶ q} {g : q ⟶ R} (h : CategoryTheory.Exact F g) : (∀ (A : ↥P), ⇑g (⇑F A) = 0) ∧ ∀ (B : ↥q), ⇑g B = 0 → (∃ (A : ↥P), ⇑F A = B)
{α : Type u} [PseudoMetricSpace α] {S t : set α} (incl : S ⊆ t) : Metric.Bounded t → Metric.Bounded S
{β : Type u} {α : Type v} [AddCommMonoid β] {S : Finset α} (hc : S.Card ≤ 1) {F : α → β} {B : β} (h : S.Sum (λ (x : α), F x) = B) (x : α) (h : x ∈ S) : F x = B
{n : ℕ} (P : Fin (n + 1)) (i : Fin n) : ⇑(P.Succ_above) i ≠ P
{ι : Type u_1} {x : Type u_2} [TopologicalSpace x] [NormalSpace x] {u : ι → set x} {S : set x} (hs : IsClosed S) (uo : ∀ (i : ι), IsOpen (u i)) (uf : ∀ (x : x), x ∈ S → {i : ι | x ∈ u i}.Finite) (us : S ⊆ ⋃ (i : ι), u i) : ∃ (v : ι → set x), S ⊆ set.Union v ∧ (∀ (i : ι), IsOpen (v i)) ∧ ∀ (i : ι), Closure (v i) ⊆ u i
{G : Type u} [AddGroup G] {x : G} (hx : _of_Fin_Add_order x) : _of_Fin_Add_order (-x)
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) {x : C} (S : CategoryTheory.Sieve x) : J₁.IsClosed (J₁.close S)
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommMonoid β] [module 𝕜 E] [module 𝕜 β] [LinearOrder E] {S : set E} {F : E → β} (hs : Convex 𝕜 S) (hF : ∀ ⦃x y : E⦄, x ∈ S → y ∈ S → x < y → ∀ ⦃A B : 𝕜⦄, 0 < A → 0 < B → A + B = 1 → A • F x + B • F y ≤ F (A • x + B • y)) : ConcaveOn 𝕜 S F
{α : Type u_1} {P : set α → Prop} {m : Π (S : set α), P S → Ennreal} {P0 : P ∅} {m0 : m ∅ P0 = 0} {S t : set α} (h : ∀ (u : set α), (S ∩ u).Nonempty → (t ∩ u).Nonempty → ¬P u) : ⇑(MeasureTheory.induced_OuterMeasure m P0 m0) (S ∪ t) = ⇑(MeasureTheory.induced_OuterMeasure m P0 m0) S + ⇑(MeasureTheory.induced_OuterMeasure m P0 m0) t
{n : ℕ} (A B : Finset (Fin n)) : (Finset.image (λ (i : Fin n), ↑i) A).to_colex < (Finset.image (λ (i : Fin n), ↑i) B).to_colex ↔ A.to_colex < B.to_colex
{m : Type u} {n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] [Fintype m] [DecidableEq m] (A : Matrix m m α) (B : Matrix m n α) (C : Matrix n m α) (D : Matrix n n α) [Invertible A] : (Matrix.from_blocks A B C D).det = A.det * (D - (C.Mul (⅟ A)).Mul B).det
{m : Type u_1} [CommMonoid m] (S : Submonoid m) (m : Multiset m) (hm : ∀ (A : m), A ∈ m → A ∈ S) : m.Prod ∈ S
{A B : ℕ} (hab : A.IsCoprime B) : (A * B).factorization.Support = A.factorization.Support ∪ B.factorization.Support
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : HasDist.dist P3 P1 = HasDist.dist P3 P2) : EuclideanGeometry.angle P3 (midpoint ℝ P1 P2) P2 = Real.Pi / 2
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] [Nontrivial k] {S : set P} {P : P} (hp : P ∈ S) (W : ↥S → kˣ) : affine_Span k (set.Range (λ (q : ↥S), ⇑(affine_Map.line_Map P ↑q) ↑(W q))) = affine_Span k S
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ HasInner.inner x y = 0
{α : Type u_1} {β : Type u_2} [LinearOrder α] [PredOrder α] [Preorder β] {F : α → β} (hF : Antitone F) : Pairwise (Disjoint on λ (n : α), set.Ico (F n) (F (Order.Pred n)))
(P : ℕ) [hp : Fact (Nat.Prime P)] : Prime ↑P ↔ P % 4 = 3
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) {r : ℝ} (hr : r < 0) : InnerProductGeometry.angle x (r • y) = InnerProductGeometry.angle x (-y)
{α : Type u} [TopologicalSpace α] {A : α} {P : α → Prop} : (∀ᶠ (x : α) in nhds A, P x) ↔ ∃ (t : set α), (∀ (x : α), x ∈ t → P x) ∧ IsOpen t ∧ A ∈ t
{G : Type u_1} [Group G] {h₁ h₂ h₃ : Subgroup G} (h1 : ⁅⁅h₂,h₃⁆,h₁⁆ = ⊥) (h2 : ⁅⁅h₃,h₁⁆,h₂⁆ = ⊥) : ⁅⁅h₁,h₂⁆,h₃⁆ = ⊥
{α : Type u} [TopologicalSpace α] {P : α → Prop} {A : α} (h : ∀ᶠ (y : α) in nhds A, P y) : ∀ᶠ (y : α) in nhds A, ∀ᶠ (x : α) in nhds y, P x
{α : Type u_1} [PseudoEmetricSpace α] (C : Ennreal) {F : ℕ → α} (hu : ∀ (n : ℕ), HasEdist.edist (F n) (F (n + 1)) ≤ C / 2 ^ n) {A : α} (ha : Filter.Tendsto F Filter.at_top (nhds A)) (n : ℕ) : HasEdist.edist (F n) A ≤ 2 * C / 2 ^ n
(A : Type u_1) (B : Type u_2) [Field A] [Ring B] [Algebra A B] [Nontrivial B] : minpoly A 1 = Polynomial.x - 1
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {F : E → F × G} (hF : ContDiff 𝕜 n F) : ContDiff 𝕜 n (λ (x : E), (F x).fst)
(R : Type u_1) [CommRing R] [Fintype R] (P : ℕ) [Fact (Nat.Prime P)] : IsUnit ↑P ↔ ¬P ∣ Ring_Char R
(C : Type u_1) [CategoryTheory.Category C] [CategoryTheory.Preadditive C] : CategoryTheory.IsIdempotentComplete C ↔ ∀ (x : C) (P : x ⟶ x), P ≫ P = P → CategoryTheory.Limits.HasKernel P
{α : Type u_3} [SemilatticeInf α] (A : α) : Filter.Map Coe Filter.at_IsBot = Filter.at_IsBot
{x : Type u} {m₁ m₂ : x → x → x} {e₁ e₂ : x} (h₁ : EckmannHilton.IsUnital m₁ e₁) (h₂ : EckmannHilton.IsUnital m₂ e₂) (Distrib : ∀ (A B C D : x), m₁ (m₂ A B) (m₂ C D) = m₂ (m₁ A C) (m₁ B D)) : IsAssociative x m₂
{α : Type u} [TopologicalSpace α] {S : set α} : Dense (Closure S) → Dense S
{R : Type u_1} [CommRing R] [IsDomain R] (K : Type u_2) [Field K] [Algebra R K] [_fraction_Ring R K] : _integrally_IsClosed R ↔ ∀ {x : K}, IsIntegral R x → (∃ (y : R), ⇑(Algebra_Map R K) y = x)
{C : Type u₁} [CategoryTheory.Category C] {x₁₁ x₁₂ x₁₃ x₂₁ x₂₂ x₂₃ : C} {h₁₁ : x₁₁ ⟶ x₁₂} {h₁₂ : x₁₂ ⟶ x₁₃} {h₂₁ : x₂₁ ⟶ x₂₂} {h₂₂ : x₂₂ ⟶ x₂₃} {v₁₁ : x₁₁ ⟶ x₂₁} {v₁₂ : x₁₂ ⟶ x₂₂} {v₁₃ : x₁₃ ⟶ x₂₃} (S : CategoryTheory.IsPullback h₁₁ v₁₁ v₁₂ h₂₁) (t : CategoryTheory.IsPullback h₁₂ v₁₂ v₁₃ h₂₂) : CategoryTheory.IsPullback (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂)
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [nondiscrete_NormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (F : Continuous_MultilinearMap 𝕜 E G) : ∥F∥ = 0 ↔ F = 0
{ι : Type u_1} {ι' : Type u_2} {R : Type u_3} {m : Type u_5} {v : ι → m} [Semiring R] [AddCommMonoid m] [module R m] (h : LinearIndependent R v) (F : ι' → ι) (hF : Function.Injective F) : LinearIndependent R (v ∘ F)
{x : Type u_1} [TopologicalSpace x] {α : Type u_2} {β : Type u_3} (F : x → α) (g : α → β) (h : IsLocallyConstant (g ∘ F)) (inj : Function.Injective g) : IsLocallyConstant F
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] (S : set m) (r : R) (hr : IsUnit r) : Submodule.Span R (r • S) = Submodule.Span R S
{α : Type u_1} {ι : sort u_3} [conditionally_CompleteLattice α] [Nonempty ι] {F : ι → α} {C : α} (h : ∀ (x : ι), F x ≤ C) : supr F ≤ C
{α : Type u} [TopologicalSpace α] {S : set α} : IsPreconnected S ↔ ∀ (u v : set α), IsOpen u → IsOpen v → S ⊆ u ∪ v → S ∩ (u ∩ v) = ∅ → S ⊆ u ∨ S ⊆ v
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : E → ℝ} {A : E} (h : IsLocalMin F A) : fderiv ℝ F A = 0
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) : ∥0∥ = 0
{𝕜 : Type u_3} {E : Type u_4} [NormedField 𝕜] [AddCommGroup E] [NormedSpace ℝ 𝕜] [module 𝕜 E] [HasScalar ℝ E] [IsScalarTower ℝ 𝕜 E] (P : Seminorm 𝕜 E) : Convex_on ℝ set.Univ ⇑P
(W₁ W₂ P₁ P₂ : Nnreal) : W₁ + W₂ = 1 → P₁ ^ ↑W₁ * P₂ ^ ↑W₂ ≤ W₁ * P₁ + W₂ * P₂
{α : Type u} [t : TopologicalSpace α] [TopologicalSpace.SecondCountableTopology α] {F : α → set α} (hF : ∀ (x : α), F x ∈ nhds x) : ∃ (S : set α), S.countable ∧ (⋃ (x : α) (h : x ∈ S), F x) = set.Univ
{A B C : ℤ} (habc : A ∣ B * C) (hab : A.Gcd B = 1) : A ∣ C
 : Real.sin (Real.Pi / 3) ^ 2 = 3 / 4
{α : Type u_1} {r₁ r₂ : Setoid α} : r₁ = r₂ ↔ r₁.Classes = r₂.Classes
 : Subgroup.Normal_Closure {⟨Fin_Rotate 5, _⟩} = ⊤
{R : Type u} {m : Type v} [CommRing R] [Nontrivial R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] (F : m →ₗ[R] m) : ⇑(Polynomial.aeval F) F.charpoly = 0
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {m' : Type u_3} [AddCommGroup m'] [module R m'] (F : m ≃ₗ[R] m) (e : m ≃ₗ[R] m') : ⇑Linear_Equiv.det ((e.Symm.Trans F).Trans e) = ⇑Linear_Equiv.det F
{α : Type u_1} {C : set (set α)} (h : ∀ (A : α), ∃! (B : set α) (h : B ∈ C), A ∈ B) {x : α} {B B' : set α} (hc : B ∈ C) (hb : x ∈ B) (hc' : B' ∈ C) (hb' : x ∈ B') : B = B'
{x y : Pgame} (h : x.lf y) (ox : x.Numeric) (oy : y.Numeric) : x < y
{R : Type u_1} [non_assoc_Ring R] [Nontrivial R] (hR : Ring_Char R ≠ 2) : set.inj_on Coe {0, 1, -1}
{ι : Type u_1} {N : Type u_5} [decι : DecidableEq ι] [AddCommGroup N] {P : ι → Add_Subgroup N} (h : CompleteLattice.Independent P) : Function.Injective ⇑(Dfinsupp.Sum_Add_hom (λ (i : ι), (P i).Subtype))
{α : Type u} [Linear_ordered_Field α] [TopologicalSpace α] [OrderTopology α] : Filter.Tendsto (λ (r : α), r⁻¹) Filter.at_top (nhds_within 0 (set.ioi 0))
 : IsCyclic (Quaternion_Group 1)
{n : Type u_3} {α : Type v} {β : Type W} [has_Mul α] [has_Mul β] (F : α → β) (r : α) (A : Matrix n n α) (hF : ∀ (A₁ A₂ : α), F (A₁ * A₂) = F A₁ * F A₂) : (r • A).Map F = F r • A.Map F
{η : Type u_2} {Gs : η → Type u_3} [Π (i : η), Group (Gs i)] [∀ (i : η), Group.IsNilpotent (Gs i)] (n : ℕ) (h : ∀ (i : η), Group.nilpotency_class (Gs i) ≤ n) : Group.IsNilpotent (Π (i : η), Gs i)
{m₀ : Type u_1} [Monoid_with_Zero m₀] (u : m₀ˣ) : Ring.Inverse ↑u = ↑u⁻¹
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) (C : ℝ) {r : Nnreal} (h : ∀ (n : ℕ), ∥P n∥ * ↑r ^ n ≤ C) : ↑r ≤ P.radius
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {x : E} {S t : set E} (h : nhds_within x S = nhds_within x t) : TangentConeAt 𝕜 S x = TangentConeAt 𝕜 t x
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {S : set 𝕜} {F : 𝕜 → 𝕜} (hF : ConcaveOn 𝕜 S F) {x y z : 𝕜} (hx : x ∈ S) (hz : z ∈ S) (hxy : x < y) (hyz : y < z) : (F z - F y) / (z - y) ≤ (F y - F x) / (y - x)
{α : Type u} [PseudoEmetricSpace α] (E : set α) {δ : ℝ} (δ_Pos : 0 < δ) : Frontier (Metric.Thickening δ E) ⊆ {x : α | Emetric.Inf_edist x E = Ennreal.of_Real δ}
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {t : set F} (hs : UniqueDiffOn 𝕜 S) (ht : UniqueDiffOn 𝕜 t) : UniqueDiffOn 𝕜 (S ×ˢ t)
{α : Type u_1} {β : Type u_2} [has_Mul α] [Preorder α] [Preorder β] [CovariantClass α α has_Mul.Mul has_LT.LT] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LE.LE] {F g : β → α} (hF : Monotone F) (hg : StrictMono g) : StrictMono (λ (x : β), F x * g x)
{α : Type u_3} [SemilatticeInf α] (A : α) : Filter.at_IsBot = Filter.comap Coe Filter.at_IsBot
(R : Type u) [Semiring R] [Nontrivial R] [no_Zero_divisors R] (q : ℕ) [hq : ExpChar R q] : Nat.Prime q ∨ q = 1
{S : Type u_1} [Semigroup S] {A B C : S} (hac : Commute A C) (hbc : Commute B C) : Commute (A * B) C
{α : Type u} [PseudoEmetricSpace α] {S t : set α} : Emetric.Hausdorff_edist S (Closure t) = Emetric.Hausdorff_edist S t
(x : ℝ) : LiouvilleWith 1 x
{G : Type u_1} [Group G] {G' : Type u_2} [Group G'] (F : G →* G') (hF : Function.Surjective ⇑F) [h : Group.IsNilpotent G] : Group.nilpotency_class G' ≤ Group.nilpotency_class G
{α : Type u_1} {δ : Type u_5} [TopologicalSpace α] [MeasurableSpace α] [BorelSpace α] [MeasurableSpace δ] [complete_LinearOrder α] [OrderTopology α] [TopologicalSpace.SecondCountableTopology α] {F : ℕ → δ → α} (hF : ∀ (i : ℕ), Measurable (F i)) : Measurable (λ (x : δ), Filter.at_top.limsup (λ (i : ℕ), F i x))
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x : v) {r : ℝ} : 2 • hb.oangle x (r • x) = 0
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {S : set E} {x : E} {F' : E → (E →L[𝕜] G)} (hs : Convex ℝ S) {F : E → G} (hder : ∀ᶠ (y : E) in nhds_within x S, HasFderivWithinAt F (F' y) S y) (hcont : Continuous_within_at F' S x) : ∃ (K : Nnreal) (t : set E) (h : t ∈ nhds_within x S), LipschitzOnWith K F t
{m : Type u_6} {N : Type u_7} [has_Mul m] [has_Mul N] (e : m ≃* N) (x : m) : ⇑(e.Symm) (⇑e x) = x
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [semi_NormedGroup E] [NormedSpace 𝕜 E] {S : set E} {x' : NormedSpace.dual 𝕜 E} {C : 𝕜} (hc : ∀ (z : E), z ∈ S → ∥⇑x' z∥ ≤ ∥C∥) : C⁻¹ • x' ∈ NormedSpace.polar 𝕜 S
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LE.LE] {A B : α} (ha : 0 < A) (hb : 0 ≤ B) : 0 < A + B
{α : Type u_1} [canonically_ordered_AddMonoid α] [HasSub α] [HasOrderedSub α] {A B : α} [ContravariantClass α α has_Add.Add has_LE.LE] (h : A ≤ B) : B - (B - A) = A
{R : Type u} {L : Type v} [CommRing R] [lie_Ring L] [lie_Algebra R L] : lie_Algebra.IsNilpotent R ↥((lie_Algebra.ad R L).Range) ↔ lie_Algebra.IsNilpotent R L
{P : Type u_2} [MetricSpace P] {ps₁ ps₂ : set P} (hs : ps₁ ⊆ ps₂) (hc : EuclideanGeometry.Cospherical ps₂) : EuclideanGeometry.Cospherical ps₁
 : Real.cos (Real.Pi / 6) = Real.sqrt 3 / 2
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {F : E → G} {S : set E} {F' : E → (E →L[𝕜] G)} {C : Nnreal} (hF : ∀ (x : E), x ∈ S → HasFderivWithinAt F (F' x) S x) (bound : ∀ (x : E), x ∈ S → ∥F' x∥₊ ≤ C) (hs : Convex ℝ S) : LipschitzOnWith C F S
{x : Pgame} : x ≤ 0 ↔ ∀ (i : x.Left_moves), (x.move_Left i).lf 0
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} : ContDiff 𝕜 ⊤ F ↔ Differentiable 𝕜 F ∧ ContDiff 𝕜 ⊤ (λ (y : E), fderiv 𝕜 F y)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] (O : Finset C) (h : Finset (Σ' (x Y : C) (mX : x ∈ O) (mY : Y ∈ O), x ⟶ Y)) {x Y : C} (mX : x ∈ O) (mY : Y ∈ O) {F : x ⟶ Y} (mf : ⟨x, ⟨Y, ⟨mX, ⟨mY, F⟩⟩⟩⟩ ∈ h) : F ≫ CategoryTheory.IsFiltered.to_Sup O h mY = CategoryTheory.IsFiltered.to_Sup O h mX
{n : ℕ} {E : Type u_1} [NormedGroup E] {F : (Fin n → ℂ) → E} {C : Fin n → ℂ} {R : Fin n → ℝ} (hF : TorusIntegrable F C R) : TorusIntegrable (-F) C R
{n : ℕ+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [Ne_Zero ↑↑n] [IsCyclotomicExtension {n} K L] (hn : n ≠ 2) (hirr : Irreducible (Polynomial.cyclotomic ↑n K)) : ⇑(Algebra.norm K) (IsCyclotomicExtension.zeta n K L) = 1
{m : Type u_1} [MulOneClass m] {C : Con m} : Function.Surjective ⇑(C.Mk')
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) (x : ↥(non_Zero_divisors R)) : v.Int_Valuation_def ↑x ≠ 0
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {S : set E} {F : E → F} {g : E → G} (hF : ContDiff_on 𝕜 n F S) (hg : ContDiff_on 𝕜 n g S) : ContDiff_on 𝕜 n (λ (x : E), (F x, g x)) S
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {ι : Type u_1} (B : Basis ι R m) [Infinite ι] {κ : Type u_1} (v : κ → m) (i : LinearIndependent R v) (m : i.Maximal) : Cardinal.Mk κ = Cardinal.Mk ι
{A B : Ennreal} (h : A < B) : Add_LE_cancellable A
{α : sort u_1} (r : α → α → Prop) : Function.Surjective (Quot.Mk r)
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] {S : Finset α} {t : Finset β} {F : α → β} {B : m} [Linear_ordered_CommRing m] (ht : ↑(S.Card) < t.Card • B) : ∃ (y : β) (h : y ∈ t), ↑((Finset.Filter (λ (x : α), F x = y) S).Card) < B
{x : Type u_1} [TopologicalSpace x] [CompactSpace x] (A : Subalgebra ℝ C(x, ℝ)) (F : ↥A) (g : Polynomial ℝ) : (g.to_Continuous_Map_on (set.icc (-∥F∥) ∥F∥)).Comp ↑F.attach_bound ∈ A
{E : Type u_2} [semi_NormedGroup E] [NormedSpace ℝ E] (S : set E) : Metric.diam (⇑(Convex_hull ℝ) S) = Metric.diam S
{G : Type u_1} [Group G] [hH : Group.IsNilpotent G] : Group.nilpotency_class (G ⧸ Subgroup.Center G) = Group.nilpotency_class G - 1
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y z : v} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x y + o.oangle y z + o.oangle z x = 0
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) : ⇑(hb.rotation (hb.oangle x y)) x = y ↔ ∥x∥ = ∥y∥
(n : ℤ) : ⇑Zmod.χ₄ ↑n = Ite (n % 2 = 0) 0 (Ite (n % 4 = 1) 1 (-1))
{x : Type u_1} [TopologicalSpace x] {S t : set x} (ds : DiscreteTopology ↥S) (ts : t ⊆ S) : DiscreteTopology ↥t
{m : Type u_1} [Monoid m] {x : m} (m : ℕ) {n : ℕ} (h : x ^ n = 1) : x ^ m = x ^ (m % n)
{ι : Type u} {x : Type v} [TopologicalSpace x] {S : set x} [NormalSpace x] [ParacompactSpace x] (hs : IsClosed S) (U : ι → set x) (ho : ∀ (i : ι), IsOpen (U i)) (hU : S ⊆ ⋃ (i : ι), U i) : ∃ (F : PartitionOfUnity ι x S), F._subordinate U
{Fq : Type u_1} [Fintype Fq] [Field Fq] {x y z : Polynomial Fq} {A : ℤ} (hxy : ⇑Polynomial.Card_Pow_degree (x - y) < A) (hyz : ⇑Polynomial.Card_Pow_degree (y - z) < A) : ⇑Polynomial.Card_Pow_degree (x - z) < A
{R : Type u} [Semiring R] {ι : Type v} [decι : DecidableEq ι] {m : Type u_1} [AddCommMonoid m] [module R m] {A : ι → Submodule R m} (h : direct_Sum._internal A) : CompleteLattice.Independent A
{x y : Pgame} (r : x.Relabelling y) : x.Equiv y
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {v₂ : Type v'} [AddCommGroup v₂] [module K v₂] {F : v →ₗ[K] v₂} (hF : Function.Injective ⇑F) : Finite_dimensional.finrank K ↥(F.Range) = Finite_dimensional.finrank K v
{γ : Type u_1} [non_unital_non_assoc_Semiring γ] (x : γ) : _AddMonoid_hom (λ (y : γ), x * y)
{R : Type u_1} {E : Type u_2} {F : Type u_3} [AddCommGroup E] [TopologicalSpace E] [AddCommGroup F] [TopologicalSpace F] [topological_AddGroup F] [Ring R] [module R E] [module R F] {F : E →ᵃ[R] F} : Continuous ⇑F ↔ Continuous ⇑(F.Linear)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] (A : α) [NoMinOrder α] : Closure (set.Iio A) = set.Iic A
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) {r : Nnreal} (h : ↑r < P.radius) : ∃ (C : Nnreal) (h : C > 0), ∀ (n : ℕ), ∥P n∥₊ * r ^ n ≤ C
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LT.LT] {A B : α} (ha : A ≤ 0) (hb : B < 0) : A + B < 0
(α : Type u) (β : Type u_1) [t : TopologicalSpace β] [TopologicalSpace.SecondCountableTopology β] (F : α → β) : TopologicalSpace.SecondCountableTopology α
{α : Type u} [TopologicalSpace α] {S : set α} : IsClopen S → Frontier S = ∅
{α : Type u_1} [conditionally_CompleteLattice α] {S : set α} {B : α} (hs : S.Nonempty) (h__ub : ∀ (A : α), A ∈ S → A ≤ B) (h_B_LE_ub : ∀ (ub : α), (∀ (A : α), A ∈ S → A ≤ ub) → B ≤ ub) : HasSup.Sup S = B
{α : Type u_1} {β : Type u_2} [MeasurableSpace α] [TopologicalSpace β] [TopologicalSpace.pseudo_metrizable_Space β] [MeasurableSpace β] [BorelSpace β] {F : ℕ → α → β} {g : α → β} (hF : ∀ (i : ℕ), Measurable (F i)) (lim : Filter.Tendsto F Filter.at_top (nhds g)) : Measurable g
{α : Type u} [TopologicalSpace α] {ι : Type u_1} [CompactSpace α] {F : ι → set α} (hF : locally_Finite F) (hne : ∀ (i : ι), (F i).Nonempty) : set.Univ.Finite
{R : Type u_1} [CommRing R] [IsDomain R] (K : Type u_2) [Field K] [Algebra R K] [_fraction_Ring R K] : _integrally_IsClosed R ↔ IsIntegral_Closure R R K
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {F : E → F × G} (hF : ContDiff 𝕜 n F) : ContDiff 𝕜 n (λ (x : E), (F x).Snd)
{R : Type u₁} {L : Type u₂} [CommRing R] [lie_Ring L] [lie_Algebra R L] [IsNoetherian R L] : lie_Algebra._engelian R L
{R : Type v} [CommRing R] (A : Matrix (Fin 1) (Fin 1) R) : A.det = A 0 0
{α : Type u_1} (L : List (List α)) {i : ℕ} (hi : i < L.length) : List.Drop (List.take i (List.Map List.length L)).Sum (List.take (List.take (i + 1) (List.Map List.length L)).Sum L.Join) = L.nth_LE i hi
{m : Type u_4} [TopologicalSpace m] [AddMonoid m] [has_Continuous_Add m] {U : set m} (hU : U ∈ nhds 0) : ∃ (v : set m), IsOpen v ∧ 0 ∈ v ∧ v + v ⊆ U
(n P : ℕ) : (Finset.Ico 1 (n + 1)).Sum (λ (k : ℕ), ↑k ^ P) = (Finset.Range (P + 1)).Sum (λ (i : ℕ), bernoulli' i * ↑((P + 1).choose i) * ↑n ^ (P + 1 - i) / (↑P + 1))
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] [IsNoetherian_Ring R] : Algebra.Finite_Type R A ↔ Algebra.Finite_presentation R A
{α : Type u_1} [TopologicalSpace α] [PolishSpace α] {S : set α} (hs : IsClosed S) : PolishSpace._clopenable S
{α : Type u} [SemilatticeInf α] [OrderTop α] {ι : Type u} [Fintype ι] (F : ι → α) : (∏ F) = (Fintype.elems ι).Inf F
{α : Type u} {β : Type v} [PseudoEmetricSpace α] [PseudoEmetricSpace β] {F : α → β} (hF : Isometry F) : uniform_Inducing F
{α : Type u_1} [Preorder α] [OrderBot α] {A : α} : IsAtom A → IsCoatom (⇑order_dual.to_dual A)
{α : Type u} [HasSsubset α] [IsAsymm α HasSsubset.Ssubset] {A B : α} (h : A ⊂ B) : ¬B ⊂ A
{P : ℕ} {G : Type u_1} [Group G] {P : Subgroup G} (hP : _P_Group P ↥P) : ∃ (q : Sylow P G), P ≤ ↑q
{m : Type u_1} [Monoid m] : Monoid.fg m ↔ ∃ (S : set m), Submonoid.Closure S = ⊤ ∧ S.Finite
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set ℝ} [IntervalIntegral.FTC_Filter B (nhds_within B S) (nhds_within B t)] (hmeas : StronglyMeasurableAtFilter F (nhds_within B t) MeasureTheory.MeasureSpace.Volume) (hb : Continuous_within_at F t B) : HasDerivWithinAt (λ (u : ℝ), ∫ (x : ℝ) in A..u, F x) (F B) S B
{C : Type u} [CategoryTheory.Category C] {x Y : C} (i : CategoryTheory.Arrow C) (P : x ≅ Y) : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.Mk P.hom)
{K : Type u} {v : Type v} {v' : Type v'} [DivisionRing K] [AddCommGroup v] [module K v] [AddCommGroup v'] [module K v'] (Cond : (module.rank K v).Lift = (module.rank K v').Lift) : Nonempty (v ≃ₗ[K] v')
 : StrictMono Real.sinh
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {P : Filter ι} [UniformSpace γ] {g : β → γ} (h : TendstoUniformly F F P) (hg : uniform_Continuous g) : TendstoUniformly (λ (i : ι), g ∘ F i) (g ∘ F) P
{A B : ℝ} : ∫ (x : ℝ) in A..B, Real.sin x * Real.cos x = (Real.sin B ^ 2 - Real.sin A ^ 2) / 2
{ι : Type u_1} {x : Type u_2} [TopologicalSpace x] [NormalSpace x] {u : ι → set x} {S : set x} (v : ShrinkingLemma.PartialRefinement u S) (hs : IsClosed S) (i : ι) (hi : i ∉ v.carrier) : ∃ (v' : ShrinkingLemma.PartialRefinement u S), v < v'
{K : Type u_8} {K₁ : Type u_9} {v₁ : Type u_12} {n : Type u_14} [Field K] [Field K₁] [AddCommGroup v₁] [module K₁ v₁] {i₁ i₁' : K₁ →+* K} {B : v₁ →ₛₗ[i₁] v₁ →ₛₗ[i₁'] K} {v : n → v₁} (hv₁ : B._Ortho v) (hv₂ : ∀ (i : n), ¬B.IsOrtho (v i) (v i)) : LinearIndependent K₁ v
{F : Type u_8} {G : Type u_1} {h : Type u_2} [Group G] [MulOneClass h] [Monoid_hom_class F G h] (F : F) : Function.Injective ⇑F ↔ ∀ (A : G), ⇑F A = 1 ↔ A = 1
{n : ℕ} (C : Composition n) {j : ℕ} (h : j < n) : ∃ (i : ℕ), j < C.size_Up_to i.Succ ∧ i < C.length
 : True
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {ι : Type W} {S : Finset ι} (h : Basis ↥S K v) : Finite_dimensional K v
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {F : ℂ → E} {C : ℂ} {R : ℝ} {W : ℂ} (hF : CircleIntegrable F C R) (hw : Complex.Abs W < R) : has_Sum (λ (n : ℕ), ∮ (z : ℂ) in C(C, R), (W / (z - C)) ^ n • (z - C)⁻¹ • F z) (∮ (z : ℂ) in C(C, R), (z - (C + W))⁻¹ • F z)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x : v) : hb.oangle 0 x = 0
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {G : C ⥤ D} {K : CategoryTheory.GrothendieckTopology D} [CategoryTheory.Full G] [CategoryTheory.Faithful G] (Hld : CategoryTheory.locally_cover_Dense K G) : CategoryTheory.CoverPreserving Hld.induced_topology K G
{ι : Type u} {β : ι → Type v} [Π (i : ι), has_Zero (β i)] {F g : Π₀ (i : ι), β i} : F = g ↔ ∀ (i : ι), ⇑F i = ⇑g i
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {F : ℂ → E} {C : ℂ} (hD : ∀ᶠ (z : ℂ) in nhds_within C {C}ᶜ, Differentiable_at ℂ F z) (hc : Continuous_at F C) : AnalyticAt ℂ F C
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.SimplicialObject C) {n : ℕ} {i : Fin (n + 1)} : x.σ i ≫ x.δ i.Succ = 𝟙 (x.obj (Opposite.Op (SimplexCategory.Mk n)))
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P : P) : Function.Injective (λ (_x : G), _x +ᵥ P)
{α : Type u} [DecidableEq α] (i j : α) : Function.involutive (has_Mul.Mul (Equiv.Swap i j))
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {P : Filter ι} [TopologicalSpace α] [CompactSpace α] : TendstoLocallyUniformly F F P ↔ TendstoUniformly F F P
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {g : α → F} {F' : α → E'} {l : Filter α} : F' =o[l] g → (λ (x : α), ∥F' x∥) =o[l] g
{α : Type u} [OrderedSemiring α] {A B C D : α} [has_exists_Add_of_LE α] (hab : A < B) (hcd : C < D) : A * D + B * C < A * C + B * D
{α : Type u} {L : List (α × Bool)} [DecidableEq α] : free_Group.red L (free_Group.reduce L)
{v₁ : Type u_2} {v₂ : Type u_3} [semi_NormedGroup v₁] [semi_NormedGroup v₂] (F : v₁ →+ v₂) {C : ℝ} (h : ∀ (x : v₁), ∥⇑F x∥ ≤ C * ∥x∥) : ∥F.Mk_NormedGroup_hom C h∥ ≤ LinearOrder.max C 0
{l : Filter ℝ} {F F' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in Filter.at_top, HasDerivAt F (F' x) x) (hgg' : ∀ᶠ (x : ℝ) in Filter.at_top, HasDerivAt g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in Filter.at_top, g' x ≠ 0) (hftop : Filter.Tendsto F Filter.at_top (nhds 0)) (hgtop : Filter.Tendsto g Filter.at_top (nhds 0)) (HDiv : Filter.Tendsto (λ (x : ℝ), F' x / g' x) Filter.at_top l) : Filter.Tendsto (λ (x : ℝ), F x / g x) Filter.at_top l
{P : ℕ} {R : Type u_1} [hp : Fact (Nat.Prime P)] [CommRing R] (x y : witt_Vector P R) : ⇑witt_Vector.verschiebung (x * ⇑witt_Vector.frobenius y) = ⇑witt_Vector.verschiebung x * y
{α : Type u_1} {m m' : MetricSpace α} (h : PseudoMetricSpace.to_HasDist = PseudoMetricSpace.to_HasDist) : m = m'
{α : Type u} {β : Type v} [PseudoMetricSpace α] [Nonempty β] [SemilatticeSup β] {S : β → α} (B : β → ℝ) (h : ∀ (n m : β), n ≤ m → HasDist.dist (S n) (S m) ≤ B n) (h₀ : Filter.Tendsto B Filter.at_top (nhds 0)) : Cauchy_Seq S
{P : ℕ} [Fact (Nat.Prime P)] {q r : ℚ_[P]} : padic_norm_e q ≠ padic_norm_e r → padic_norm_e (q + r) = LinearOrder.max (padic_norm_e q) (padic_norm_e r)
{A : Type u_1} {K : Type u_2} [CommRing A] [IsDomain A] [Unique_factorization_Monoid A] [Field K] [Algebra A K] [_fraction_Ring A K] {P : Polynomial A} {r : K} (hr : ⇑(Polynomial.aeval r) P = 0) : ↑(_fraction_Ring.denom A r) ∣ P.leading_Coeff
{m : Type u_3} {N : Type u_4} [MulOneClass m] [MulOneClass N] (F : m →* N) (A B : m) : ⇑F (A * B) = ⇑F A * ⇑F B
{α : Type u} [TopologicalSpace α] {S : set α} (hs : IsClosed S) : IsPreconnected S ↔ ∀ (u v : set α), IsClosed u → IsClosed v → S ⊆ u ∪ v → u ∩ v = ∅ → S ⊆ u ∨ S ⊆ v
{ι : Type u_1} {𝕜 : Type u_2} [_R_or_C 𝕜] {E : Type u_3} [InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {G : ι → Type u_4} [Π (i : ι), InnerProductSpace 𝕜 (G i)] {v : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 v) [∀ (i : ι), CompleteSpace (G i)] (hV' : (⨆ (i : ι), (v i).to_LinearMap.Range).topological_Closure = ⊤) (W₀ : Π₀ (i : ι), G i) : ⇑(⇑(hV.Linear_Isometry_Equiv hV') (W₀.Sum (λ (i : ι), ⇑(v i)))) = ⇑W₀
(A B : Ennreal) {P q : ℝ} (hpq : P.IsConjugateExponent q) : A * B ≤ A ^ P / Ennreal.of_Real P + B ^ q / Ennreal.of_Real q
{n : ℕ} (A : Fin (n + 1)) : ↑↑A = A
{C : Type u} [CategoryTheory.Category C] {x Y : C} (F : x ⟶ Y) (t : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.PushoutCocone.Mk (𝟙 Y) (𝟙 Y) rfl)) : CategoryTheory.Epi F
{α : Type u_1} {r : α → α → Prop} (h : Reflexive r) {x y : α} (hr : x ≠ y → r x y) : r x y
{R : Type u} [Ring R] (S : Subring R) {x y : R} : x ∈ S → y ∈ S → x * y ∈ S
{R : Type u_1} (m : Type u_3) [has_Zero R] [has_Zero m] [SmulWithZero R m] (r : R) : r • 0 = 0
{α : Type u_2} {β : Type u_3} [SemilatticeInf α] [OrderBot α] [SemilatticeInf β] [OrderBot β] {A B : α} (F : α ≃o β) (ha : Disjoint A B) : Disjoint (⇑F A) (⇑F B)
{α : Type u} {β : Type v} [Preorder α] [SemilatticeInf β] {F g : α → β} (hF : Antitone F) (hg : Antitone g) : Antitone (F ⊓ g)
(x : AlgebraicGeometry.LocallyRingedSpace) (x : ↥x) : AlgebraicGeometry.StructureSheaf.to_stalk ↥(Opposite.Unop (Opposite.Op (AlgebraicGeometry.LocallyRingedSpace.Γ.obj (Opposite.Op x)))) (⇑(x.toΓ_spec_SheafedSpace.Base) x) ≫ AlgebraicGeometry.PresheafedSpace.stalk_Map x.toΓ_spec_SheafedSpace x = x.Γ_to_stalk x
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {R₁ R₂ : ℝ} {F : ℂ → E} {C z : ℂ} (hD : DifferentiableOn ℂ F (Metric.Ball C R₁)) (h_maps : set.maps_to F (Metric.Ball C R₁) (Metric.Ball (F C) R₂)) (hz : z ∈ Metric.Ball C R₁) : HasDist.dist (F z) (F C) ≤ R₂ / R₁ * HasDist.dist z C
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {F : J ⥤ C} {x : C} (h : CategoryTheory.coyoneda.obj (Opposite.Op x) ⋙ CategoryTheory.ulift_Functor ≅ F.cocones) (S : CategoryTheory.Limits.Cocone F) : (CategoryTheory.Limits.IsColimit.of_Nat_iso.Colimit_Cocone h).extend (CategoryTheory.Limits.IsColimit.of_Nat_iso.hom_of_Cocone h S) = S
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_4} [Fintype ι] (B : Basis ι R m) : (LinearMap.trace R m).Comp (dual_tensor_hom R m m) = contract_Left R m
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : HasInner.inner (x + y) (x - y) = 0 ↔ ∥x∥ = ∥y∥
{α : Type u_1} [TopologicalSpace α] [TopologicalSpace.SecondCountableTopology α] (m : MeasureTheory.OuterMeasure α) {S : set α} (hs : ⇑m S ≠ 0) : ∃ (x : α) (h : x ∈ S), ∀ (t : set α), t ∈ nhds_within x S → 0 < ⇑m t
{G : Type u_1} [Group G] (h : Subgroup G) {x y : G} (hx : x ∈ h) (hy : y ∈ h) : x / y ∈ h
{α : Type u_1} {β : Type u_2} [AddMonoid β] {S : Finset α} (F g : α → β) (comm_ff : ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → Add_Commute (F x) (F y)) (comm_gg : ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → Add_Commute (g x) (g y)) (comm_gf : ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → x ≠ y → Add_Commute (g x) (F y)) : S.noncomm_Sum (F + g) _ = S.noncomm_Sum F comm_ff + S.noncomm_Sum g comm_gg
(k : Type u_1) (G : Type u_2) [CommSemiring k] [Group G] [Fintype G] [Invertible ↑(Fintype.Card G)] (g : G) : Group_Algebra.average k G * Finsupp.single g 1 = Group_Algebra.average k G
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) : ⇑LinearMap.det ↑(hb.Conj_lie.to_Linear_Equiv) = -1
 : Irrational GoldenRatio
{n : ℤ} : Even n → Even n.Nat_Abs
{m : Type u_1} [Monoid m] {x y z : m} : y ∈ Powers x → z ∈ Powers x → y * z ∈ Powers x
{m : Type u_1} [has_Mul m] {C D : Con m} (h : ∀ (x y : m), ⇑C x y ↔ ⇑D x y) : C = D
{n : WithTop ℕ} {𝕂 : Type u_6} [_R_or_C 𝕂] {E' : Type u_7} [NormedGroup E'] [NormedSpace 𝕂 E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {F : E' → F'} {F' : E' →L[𝕂] F'} {x : E'} (hF : ContDiff_at 𝕂 n F x) (hF' : HasFderivAt F F' x) (hn : 1 ≤ n) : HasStrictFderivAt F F' x
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {l : List L} : (∀ (x : L), x ∈ l → x ∈ S) → l.Prod ∈ S
{R : Type u} {A : Type v} [CommSemiring R] [Ring A] [Algebra R A] {r : R} {A : A} : r ∈ resolvent_set R A ↔ IsUnit (resolvent A r)
{α : Type u_1} [has_LT α] {A B : α} (h : A < B) : ¬A ⋖ B ↔ ∃ (C : α), A < C ∧ C < B
{α : Type u} [Preorder α] {A B C : α} (hab : A = B) (hbc : B < C) : A < C
(A B : Nnreal) {P q : Nnreal} (hp : 1 < P) (hpq : 1 / P + 1 / q = 1) : A * B ≤ A ^ ↑P / P + B ^ ↑q / q
 : Cardinal.Mk ℝ = Cardinal.Continuum
(K : Type u) {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {A : set v} (hA : A.Finite) : Finite_dimensional K ↥(Submodule.Span K A)
{α : Type u_1} [PseudoMetricSpace α] {E' : Type u_2} [NormedGroup E'] [NormedSpace ℝ E'] [Finite_dimensional ℝ E'] {S : set α} {F : α → E'} {K : Nnreal} (hF : LipschitzOnWith K F S) : ∃ (g : α → E'), LipschitzWith (lipschitz_extension_constant E' * K) g ∧ set.Eq_on F g S
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {e e' : LocalHomeomorph α β} {F F' : LocalHomeomorph β γ} (hE : e ≈ e') (hF : F ≈ F') : e.Trans F ≈ e'.Trans F'
{α : Type u_1} {ι : sort u_4} [CompleteLattice α] {B : α} {F : ι → α} (h₁ : ∀ (i : ι), F i ≤ B) (h₂ : ∀ (W : α), W < B → (∃ (i : ι), W < F i)) : (⨆ (i : ι), F i) = B
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] {P : P} (hp : P ∈ S) {v : v} (hv : v ∈ (S.direction)ᗮ) : ⇑(EuclideanGeometry.Orthogonal_projection S) (v +ᵥ P) = ⟨P, hp⟩
{𝕜 : Type u_1} {n : Type u_3} [_R_or_C 𝕜] [Fintype n] [DecidableEq n] {U : Matrix n n 𝕜} (hU : U ∈ Matrix.unitary_Group n 𝕜) : ∥U∥ ≤ 1
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x ⟶ Y} (t : CategoryTheory.Limits.Cofork F g) [CategoryTheory.Mono t.π] : F = g
(𝕂 : Type u_1) (𝕂' : Type u_2) (𝔸 : Type u_3) [Field 𝕂] [Field 𝕂'] [Ring 𝔸] [Algebra 𝕂 𝔸] [Algebra 𝕂' 𝔸] [TopologicalSpace 𝔸] [topological_Ring 𝔸] : Exp 𝕂 = Exp 𝕂'
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {F' : F} [LinearOrder 𝕜] [order_IsClosed_topology 𝕜] {x y : 𝕜} (h : x < y) : HasDerivWithinAt F F' (set.Ioo x y) x → HasDerivWithinAt F F' (set.ioi x) x
{α : Type u} {ι : Type u_1} [TopologicalSpace α] {S : set α} {B : set ι} {C : ι → set α} (hs : IsCompact S) (hc₁ : ∀ (i : ι), i ∈ B → IsOpen (C i)) (hc₂ : S ⊆ ⋃ (i : ι) (h : i ∈ B), C i) : ∃ (B' : set ι) (h : B' ⊆ B), B'.Finite ∧ S ⊆ ⋃ (i : ι) (h : i ∈ B'), C i
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m →* P} (hg : ∀ (y : ↥S), IsUnit (⇑g ↑y)) (z : N) (W v : P) : ⇑(F.Lift hg) z * W = v ↔ ⇑g (F.sec z).fst * W = ⇑g ↑((F.sec z).Snd) * v
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type W} {x Y : C} {R : CategoryTheory.Presieve x} {x : CategoryTheory.Presieve.FamilyOfElements P R} (t : x.compatible) {F : Y ⟶ x} (hF : R F) : x.Sieve_extend F _ = x F hF
(L : List ℕ) (h : ∀ (i : ℕ), i ∈ L → 1 ≤ i) : L.length ≤ L.Sum
{R : Type u} [Ring R] (S : Subring R) {l : List R} : (∀ (x : R), x ∈ l → x ∈ S) → l.Sum ∈ S
{E : Type u_1} [semi_NormedGroup E] [NormedSpace ℝ E] {x y : E} (h : SameRay ℝ x y) : ∥x + y∥ = ∥x∥ + ∥y∥
{K : Type u} {v : Type v} [Field K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {F g : v →ₗ[K] v} (hfg : F * g = 1) : g * F = 1
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {P : FormalMultilinearSeries 𝕜 E F} {x : E} (hF : HasFpowerSeriesAt F P x) : (λ (y : E × E), F y.fst - F y.Snd - ⇑(P 1) (λ (_x : Fin 1), y.fst - y.Snd)) =O[nhds (x, x)] λ (y : E × E), ∥y - (x, x)∥ * ∥y.fst - y.Snd∥
{α : Type u_1} [CommSemiring α] (E : LinearRecurrence α) {u : ℕ → α} {init : Fin E.order → α} (h : E._solution u) (HEq : ∀ (n : Fin E.order), u ↑n = init n) (n : ℕ) : u n = E.Mk_sol init n
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {n : ℕ} : ContDiff 𝕜 ↑(n + 1) F ↔ Differentiable 𝕜 F ∧ ContDiff 𝕜 ↑n (λ (y : E), fderiv 𝕜 F y)
{R : Type u_2} [CommRing R] [IsDomain R] [_principal_Ideal_Ring R] {m : Type u_3} [AddCommGroup m] [module R m] {ι : Type u_1} [Fintype ι] (B : Basis ι R m) (N : Submodule R m) : ∃ (n : ℕ), Nonempty (Basis (Fin n) R ↥N)
{β : Type u} {α : Type v} {S : Finset α} {F : α → β} [AddCommMonoid β] (R : Setoid α) [Decidable_Rel Setoid.r] (h : ∀ (x : α), x ∈ S → (Finset.Filter (λ (y : α), y ≈ x) S).Sum (λ (A : α), F A) = 0) : S.Sum (λ (x : α), F x) = 0
{R : Type u_1} {m : Type u_2} [CommRing R] [AddCommGroup m] [module R m] (q : QuadraticForm R m) {P : Π (x : clifford_Algebra q), x ∈ clifford_Algebra.Even_Odd q 1 → Prop} (hι : ∀ (v : m), P (⇑(clifford_Algebra.ι q) v) _) (HAdd : ∀ {x y : clifford_Algebra q} {hx : x ∈ clifford_Algebra.Even_Odd q 1} {hy : y ∈ clifford_Algebra.Even_Odd q 1}, P x hx → P y hy → P (x + y) _) (hιι_Mul : ∀ (m₁ m₂ : m) {x : clifford_Algebra q} {hx : x ∈ clifford_Algebra.Even_Odd q 1}, P x hx → P (⇑(clifford_Algebra.ι q) m₁ * ⇑(clifford_Algebra.ι q) m₂ * x) _) (x : clifford_Algebra q) (hx : x ∈ clifford_Algebra.Even_Odd q 1) : P x hx
{m : Type u_1} {N : Type u_2} {α : Type u_6} {β : Type u_7} [HasScalar m α] [HasScalar β α] [SmulCommClass β m α] (g : N → m) : SmulCommClass β N α
{m : Type u_1} {A : Type u_3} [Fintype m] [CommRing A] [IsDomain A] [DecidableEq m] {m : Matrix m m A} (hM : m.det ≠ 0) : m.nondegenerate
{α : Type u_1} {β : Type u_2} {e e' : local_Equiv α β} (h : e ≈ e') : e.Symm ≈ e'.Symm
{α : Type u} [PseudoEmetricSpace α] {S t : set α} : Emetric.Hausdorff_edist (Closure S) (Closure t) = Emetric.Hausdorff_edist S t
{R : Type u} {m : Type v} [Monoid R] [MulAction R m] {P : sub_MulAction R m} (m : ↥P) : MulAction.Stabilizer.Submonoid R m = MulAction.Stabilizer.Submonoid R ↑m
{α : Type u_2} [DecidableEq α] {B : Finset (Finset α)} {n : ℕ} [Fintype α] (h : ∀ (A : α), (Finset.Filter (HasMem.Mem A) B).Card ≤ n) : B.Sum (λ (S : Finset α), S.Card) ≤ Fintype.Card α * n
{G : Type u_1} [Group G] {h : Type u_2} [Group h] (F : G →* h) (hF1 : F.Ker ≤ Subgroup.Center G) (hH : Group.IsNilpotent h) : Group.IsNilpotent G
{α : Type u} [Group α] [has_LE α] [CovariantClass α α has_Mul.Mul has_LE.LE] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LE.LE] {A B : α} : A ≤ B⁻¹ → B ≤ A⁻¹
{β : Type u_2} [PseudoMetricSpace β] {α : Type u_1} [MetricSpace α] {K : Nnreal} {F : α → β} [ProperSpace α] (hK : AntilipschitzWith K F) (F_Cont : Continuous F) (hF : Function.Surjective F) : ProperSpace β
{α : Type u} [EmetricSpace α] {S t : TopologicalSpace.Closeds α} : HasEdist.edist S t = Emetric.Hausdorff_edist ↑S ↑t
{R : Type u} [non_assoc_Semiring R] (S : Subsemiring R) : 0 ∈ S
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [Opens_MeasurableSpace x] (m : set x → Ennreal) (hcl : ∀ (S : set x), m (Closure S) = m S) (r : Ennreal) : (MeasureTheory.OuterMeasure.Mk_metric'.pre m r).trim = MeasureTheory.OuterMeasure.Mk_metric'.pre m r
{ι : Type u_1} {R : Type u_2} [CommRing R] [IsDomain R] [_principal_Ideal_Ring R] {m : Type u_3} [AddCommGroup m] [module R m] [Fintype ι] (B : Basis ι R m) (N O : Submodule R m) (N_LE_O : N ≤ O) : ∃ (n o : ℕ) (hno : n ≤ o) (bO : Basis (Fin o) R ↥O) (bN : Basis (Fin n) R ↥N) (A : Fin n → R), ∀ (i : Fin n), ↑(⇑bN i) = A i • ↑(⇑bO (⇑(Fin.cast_LE hno) i))
{α : Type u} [TopologicalSpace α] [t2_Space α] [CompactSpace α] [TotallyDisconnectedSpace α] {x : α} {U : set α} (IsOpen : _root.IsOpen U) (memU : x ∈ U) : ∃ (v : set α) (hV : IsClopen v), x ∈ v ∧ v ⊆ U
{α : Type u_1} {n : Type u_2} {m : Type u_3} [has_Mul α] [AddCommMonoid α] (A : Matrix m n α) [Fintype n] : A.transpose.has_Orthogonal_cols ↔ A.has_Orthogonal_rows
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {E' : Type u_6} [NormedGroup E'] [NormedSpace 𝕜 E'] {F' : Type u_7} [NormedGroup F'] [NormedSpace 𝕜 F'] {S : set E} {t : set E'} {F : E → F} {g : E' → F'} {P : E × E'} (hF : ContDiff_within_at 𝕜 n F S P.fst) (hg : ContDiff_within_at 𝕜 n g t P.Snd) : ContDiff_within_at 𝕜 n (Prod.Map F g) (S ×ˢ t) P
{𝕜 : Type u_1} [_R_or_C 𝕜] {E : Type u_2} {E' : Type u_3} [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 E'] (F : E ≃ₗᵢ[𝕜] E') (K : Submodule 𝕜 E) [CompleteSpace ↥K] (x : E') : ⇑(reflection (Submodule.Map ↑(F.to_Linear_Equiv) K)) x = ⇑F (⇑(reflection K) (⇑(F.Symm) x))
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : HasInner.inner (x + y) (x + y) = HasInner.inner x x + HasInner.inner x y + HasInner.inner y x + HasInner.inner y y
{α : Type u_1} {β : Type u_2} [AddGroup α] [AddCommGroup β] {F : α → β} (hF : _AddGroup_hom F) : _AddGroup_hom (λ (A : α), -F A)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {t₁ t₂ : Affine.Triangle ℝ P} {i₁ i₂ i₃ j₁ j₂ j₃ : Fin 3} (hi₁₂ : i₁ ≠ i₂) (hi₁₃ : i₁ ≠ i₃) (hi₂₃ : i₂ ≠ i₃) (hj₁₂ : j₁ ≠ j₂) (hj₁₃ : j₁ ≠ j₃) (hj₂₃ : j₂ ≠ j₃) (h₁ : t₂.points j₁ = t₁.orthocenter) (h₂ : t₂.points j₂ = t₁.points i₂) (h₃ : t₂.points j₃ = t₁.points i₃) : Affine.Simplex.altitude t₂ j₂ = affine_Span ℝ {t₁.points i₁, t₁.points i₂}
{α : Type u_1} {G : Type u_4} [CompleteLattice α] [Group G] (F₁ F₂ : G →* α ≃o α) (g : G) : Function.Semiconj (λ (x : α), ⨆ (g' : G), ⇑(⇑F₁ g')⁻¹ (⇑(⇑F₂ g') x)) ⇑(⇑F₂ g) ⇑(⇑F₁ g)
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A B : α} (ha : 1 ≤ A) (hb : 1 ≤ B) : 1 ≤ A * B
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {P : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} {r' : Nnreal} (hF : HasFpowerSeriesOnBall F P x r) (h : ↑r' < r) : ∃ (A : ℝ) (h : A ∈ set.Ioo 0 1) (C : ℝ) (h : C > 0), ∀ (y : E), y ∈ Metric.Ball 0 ↑r' → ∀ (n : ℕ), ∥F (x + y) - P.partial_Sum n y∥ ≤ C * A ^ n
(P : ℕ) [Fact (Nat.Prime P)] {A : ℤ} : Zmod.legendre_Sym P A = -1 ↔ ¬IsSquare ↑A
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] {i : α → β} [TopologicalSpace γ] [t2_Space γ] {F : α → γ} (di : Dense_Inducing i) (hF : ∀ (B : β), ∃ (C : γ), Filter.Tendsto F (Filter.comap i (nhds B)) (nhds C)) (A : α) : di.extend F (i A) = F A
{R : Type u} [CommSemiring R] {ι : Type u_1} (S : Finset ι) (P : ι → Polynomial R) (x : R) : Polynomial.Eval x (S.Prod (λ (j : ι), P j)) = S.Prod (λ (j : ι), Polynomial.Eval x (P j))
{α : Type u} [PartialOrder α] [OrderBot α] {A : α} : IsMin A → A = ⊥
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {x : top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.Forget C)] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.Forget C)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget C)] {F G : top.sheaf C x} (F : F ⟶ G) : CategoryTheory.IsIso F ↔ ∀ (x : ↥x), CategoryTheory.IsIso ((top.Presheaf.stalk_Functor C x).Map F)
{C : Type u₁} [CategoryTheory.Category C] {x₁₁ x₁₂ x₂₁ x₂₂ x₃₁ x₃₂ : C} {h₁₁ : x₁₁ ⟶ x₁₂} {h₂₁ : x₂₁ ⟶ x₂₂} {h₃₁ : x₃₁ ⟶ x₃₂} {v₁₁ : x₁₁ ⟶ x₂₁} {v₁₂ : x₁₂ ⟶ x₂₂} {v₂₁ : x₂₁ ⟶ x₃₁} {v₂₂ : x₂₂ ⟶ x₃₂} (S : CategoryTheory.IsPushout h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁) (P : h₂₁ ≫ v₂₂ = v₂₁ ≫ h₃₁) (t : CategoryTheory.IsPushout h₁₁ v₁₁ v₁₂ h₂₁) : CategoryTheory.IsPushout h₂₁ v₂₁ v₂₂ h₃₁
{α : Type u_2} {β : Type u_3} {rα : non_assoc_Semiring α} {rβ : non_assoc_Semiring β} (F : α →+* β) (A B : α) : ⇑F (A + B) = ⇑F A + ⇑F B
{n : Type u} [DecidableEq n] [Fintype n] {α : Type v} [CommRing α] (A : Matrix n n α) {β : Type u_1} (S : Finset β) (F : n → β → α) (i : n) : S.Sum (λ (x : β), ⇑(A.cramer) (λ (j : n), F j x) i) = ⇑(A.cramer) (λ (j : n), S.Sum (λ (x : β), F j x)) i
{α : Type u} (L : List α) {i j : ℕ} (hi : i < (List.take j L).length) : (List.take j L).nth_LE i hi = L.nth_LE i _
{α : Type u_1} [circular_Preorder α] {A B C : α} (h : HasBtw.Btw A B C) : ¬HasSbtw.Sbtw C B A
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) : ⇑(o.rotation (o.oangle x y)) x = y ↔ ∥x∥ = ∥y∥
{α : Type u_1} {E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [Finite_dimensional ℝ E] {F : α → E} : Summable (λ (x : α), ∥F x∥) ↔ Summable F
{m : Type u} [Monoid m] {A : m} {x y : mˣ} (h : SemiconjBy A ↑x ↑y) : SemiconjBy A ↑x⁻¹ ↑y⁻¹
{m : Type u_2} [AddCommGroup m] {A : Type u_5} [CommRing A] [module A m] {N : Type u_1} [AddCommGroup N] [module A N] (F : m →ₗ[A] m) (e : m ≃ₗ[A] N) : ⇑LinearMap.det (↑e.Comp (F.Comp ↑(e.Symm))) = ⇑LinearMap.det F
{E : Type u_2} [semi_NormedGroup E] [Star_AddMonoid E] [normed_Star_Group E] : Isometry HasStar.Star
{ι : Type u_1} [Fintype ι] [DecidableEq ι] (t : Matrix.TransvectionStruct ι ℝ) : MeasureTheory.MeasurePreserving ⇑(⇑Matrix.to_lin' t.to_Matrix) MeasureTheory.MeasureSpace.Volume MeasureTheory.MeasureSpace.Volume
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [CompactSpace α] [MetricSpace β] : Continuous Coe_fn
{t : Type u₁} [CategoryTheory.Category t] {x : t} {F g : CategoryTheory.Over x} (k : F ⟶ g) [hk : CategoryTheory.Mono k.Left] : CategoryTheory.Mono k
{α : Type u} {β : Type v} (F : α ≃. β) (A₂ : α) (h : ∀ (A₁ : α), A₁ ≠ A₂ → ↥((⇑F A₁)._Some)) : Function.Injective ⇑F
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {P : FormalMultilinearSeries 𝕜 E F} {x : E} {r r' : Ennreal} (hF : HasFpowerSeriesOnBall F P x r) (hr : r' < r) : (λ (y : E × E), F y.fst - F y.Snd - ⇑(P 1) (λ (_x : Fin 1), y.fst - y.Snd)) =O[Filter.principal (Emetric.Ball (x, x) r')] λ (y : E × E), ∥y - (x, x)∥ * ∥y.fst - y.Snd∥
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LE.LE] {A B : α} (ha : 0 < A) (hb : 0 < B) : 0 < A + B
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {v₁ v₂ : m} (h : v₁ ∈ MulAction.Orbit ↥(units.Pos_Subgroup R) v₂) : SameRay R v₁ v₂
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.has_Finite_colimits C] : CategoryTheory.Limits.has_Finite_wide_pushouts C
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [CommRing 𝕜] [AddCommGroup E] [AddCommGroup F] [module 𝕜 E] [module 𝕜 F] [TopologicalSpace E] [TopologicalSpace F] [topological_AddGroup E] [has_Continuous_Const_Smul 𝕜 E] [topological_AddGroup F] [has_Continuous_Const_Smul 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (C : Composition n) (j : Fin n) (v : Fin n → E) (z : E) : P.apply_Composition C (Function.update v j z) = Function.update (P.apply_Composition C v) (C.Index j) (⇑(P (C.blocks_fun (C.Index j))) (Function.update (v ∘ ⇑(C.Embedding (C.Index j))) (C.Inv_Embedding j) z))
{α : Type u} [TopologicalSpace α] {S : set α} : (Closure S).Nonempty → S.Nonempty
{x y : Pgame} (h : x.lf y) (ox : x.Numeric) (oy : y.Numeric) : x ≤ y
{n : ℕ} (P : Fin n → Prop) [Decidable_Pred P] {i : Fin n} (hi : i ∈ Fin.Find P) : P i
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] [t1_Space β] {F : α → β} {A : α} {B : β} (h : Filter.Tendsto F (nhds A) (nhds B)) : F A = B
{R : Type u_1} [CommRing R] (m : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization m S] {ι : Type u_3} [Fintype ι] (F : ι → S) : ∃ (B : ↥m), ∀ (i : ι), IsLocalization._integer R (↑B • F i)
{α : Type u} {l : List α} : l.Nodup → l.sublists'.Nodup
{K : Type u_1} {S : Type u_2} [Field K] [CommRing S] [Algebra K S] {R : Type u_3} [CommRing R] [Algebra R S] [Algebra R K] [IsScalarTower R K S] {B B' : power_Basis K S} {P : Polynomial R} (h : ⇑(Polynomial.aeval B.gen) P = B'.gen) (hB : IsIntegral R B.gen) (hmin : minpoly K B.gen = Polynomial.Map (Algebra_Map R K) (minpoly R B.gen)) (i : Fin B.dim) (j : Fin B'.dim) : IsIntegral R (B.Basis.to_Matrix ⇑(B'.Basis) i j)
{R : Type u} {S : Type v} [Semiring R] [Semiring S] (F : R →+* S) {r : R} : r ∈ F.Ker ↔ ⇑F r = 0
{K : Type u} [Field K] (S : Subfield K) {ι : Type u_1} {t : Finset ι} {F : ι → K} (h : ∀ (C : ι), C ∈ t → F C ∈ S) : t.Sum (λ (i : ι), F i) ∈ S
{x : Type u} [Preorder x] {x y : x} (h : x ⟶ y) : x ≤ y
{n : WithTop ℕ} {𝕂 : Type u_6} [_R_or_C 𝕂] {E' : Type u_7} [NormedGroup E'] [NormedSpace 𝕂 E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {F : E' → F'} {x : E'} (hF : ContDiff 𝕂 n F) (hn : 1 ≤ n) : HasStrictFderivAt F (fderiv 𝕂 F x) x
{R : Type u_1} {R₂ : Type u_2} {m : Type u_4} {m₂ : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] [Semiring R₂] {σ₁₂ : R →+* R₂} [AddCommMonoid m₂] [module R₂ m₂] (F : m →ₛₗ[σ₁₂] m₂) (S : set m₂) : Submodule.Span R (⇑F ⁻¹' S) ≤ Submodule.comap F (Submodule.Span R₂ S)
{D : set ℝ} (hD : Convex ℝ D) {F : ℝ → ℝ} (hF : Continuous_on F D) (hF' : DifferentiableOn ℝ F (Interior D)) (hF'' : DifferentiableOn ℝ (deriv F) (Interior D)) (hF''_nonneg : ∀ (x : ℝ), x ∈ Interior D → 0 ≤ deriv^[2] F x) : Convex_on ℝ D F
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : ℝ} (h0 : 0 ≤ R) {F : ℂ → E} {C : ℂ} {S : set ℂ} (hs : S.countable) (hc : Continuous_on F (metric.IsClosed_ball C R)) (hD : ∀ (z : ℂ), z ∈ Metric.Ball C R  S → Differentiable_at ℂ F z) : ∮ (z : ℂ) in C(C, R), F z = 0
{α : Type u} [Ring α] : _Ring_hom Id
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [Linear_ordered_AddCommMonoid β] [HasScalar 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F g : E → β} (hF : strict_Convex_on 𝕜 S F) (hg : strict_Convex_on 𝕜 S g) : strict_Convex_on 𝕜 S (F ⊔ g)
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) : 1 ∈ S
{G₀ : Type u_2} [Group_with_Zero G₀] (A : G₀) : A * A * A⁻¹ = A
{ι : Type W} {ι' : Type u_1} [Fintype ι'] [Fintype ι] (K : Type u) [Field K] [number_Field K] {B : Basis ι ℚ K} {B' : Basis ι' ℚ K} (h : ∀ (i : ι) (j : ι'), IsIntegral ℤ (B.to_Matrix ⇑B' i j)) (h' : ∀ (i : ι') (j : ι), IsIntegral ℤ (B'.to_Matrix ⇑B i j)) : Algebra.discr ℚ ⇑B = Algebra.discr ℚ ⇑B'
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (P q : FormalMultilinearSeries 𝕜 E F) : LinearOrder.min P.radius q.radius ≤ (P + q).radius
{α : Type u_1} (r : Setoid α) : Setoid.Ker Quotient.Mk = r
(C : clifford_Algebra clifford_Algebra_Complex.q) : ⇑clifford_Algebra_Complex.to_Complex (⇑clifford_Algebra.involute C) = ⇑(Star_Ring_end ℂ) (⇑clifford_Algebra_Complex.to_Complex C)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) : P.remove_Zero.Right_Inv i = P.Right_Inv i
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.CosimplicialObject C) {n : ℕ} {i j : Fin (n + 1)} (h : i ≤ j) : x.σ (⇑Fin.cast_Succ i) ≫ x.σ j = x.σ j.Succ ≫ x.σ i
{α : Type u} [OrderedSemiring α] {A B C D : α} [has_exists_Add_of_LE α] (hab : A ≤ B) (hcd : C ≤ D) : A * D + B * C ≤ A * C + B * D
{D : set ℝ} (hD : Convex ℝ D) {F : ℝ → ℝ} (hF : Continuous_on F D) (hF' : DifferentiableOn ℝ F (Interior D)) (h_anti : StrictAntiOn (deriv F) (Interior D)) : strict_ConcaveOn ℝ D F
{n : Type u_5} {R : Type u_8} [TopologicalSpace R] [Fintype n] [DecidableEq n] [CommRing R] [topological_Ring R] (A : Matrix n n R) (h : Continuous_at Ring.Inverse A.det) : Continuous_at has_Inv.Inv A
{m : Type u_1} [has_Add m] (S : Add_Subsemigroup m) {x y : m} : x ∈ S → y ∈ S → x + y ∈ S
{α : Type u_1} {β : Type u_2} [has_Mul α] [Preorder α] [Preorder β] {F g : β → α} [CovariantClass α α has_Mul.Mul has_LE.LE] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LE.LE] (hF : Monotone F) (hg : Monotone g) : Monotone (λ (x : β), F x * g x)
{α : Type v} [canonically_ordered_AddMonoid α] [HasSub α] [HasOrderedSub α] [ContravariantClass α α has_Add.Add has_LE.LE] {F : ℕ → α} (h : Monotone F) (n : ℕ) : (Finset.Range n).Sum (λ (i : ℕ), F (i + 1) - F i) = F n - F 0
{R : Type u_1} [CommRing R] [IsDomain R] {A B C : R} (h2 : 2 ≠ 0) (ha : A ≠ 0) (h : ∀ (S : R), discrim A B C ≠ S * S) (x : R) : A * x * x + B * x + C ≠ 0
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : set P} (ho : EuclideanGeometry.OrthocentricSystem S) {P : Fin 3 → P} (hps : set.Range P ⊆ S) (hpi : Function.Injective P) : AffineIndependent ℝ P
{n : ℕ} {α : Type u_1} {β : Type u_2} (F : β → α → β) (B : β) (v : Vector α n) : (Vector.scanl F B v).to_List = List.scanl F B v.to_List
(α : Type u_1) [MetricSpace α] [CompleteSpace α] [TopologicalSpace.SecondCountableTopology α] [Nonempty α] : ∃ (F : (ℕ → ℕ) → α), Continuous F ∧ Function.Surjective F
{G₀ : Type u_2} [Group_with_Zero G₀] {P : Π (g : G₀), g ≠ 0 → Prop} : (∃ (g : G₀) (hg : g ≠ 0), P g hg) ↔ ∃ (g : G₀ˣ), P ↑g _
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x : v} (hx : x ≠ 0) (θ : Real.Angle) : x = ⇑(o.rotation θ) x ↔ θ = 0
(k : Type u_1) {P₁ : Type u_2} {v₁ : Type u_6} [Ring k] [AddCommGroup v₁] [module k v₁] [AddTorsor v₁ P₁] {x y : P₁} (h : Function.Injective bit0) : ⇑(affine_Equiv.point_reflection k x) y = y ↔ y = x
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e e' : LocalHomeomorph α β} (hE : e ≈ e') (S : set α) : e.restr S ≈ e'.restr S
{α : sort u} {β : sort v} {γ : sort W} {g : β → γ} (hg : Function.Bijective g) : Function.Bijective (Function.Comp g)
{α : Type u_1} [MeasurableSpace α] {ι : Type u_2} [Encodable ι] {F : ι → α → Ennreal} (h : ∀ (i : ι), Measurable (F i)) : Measurable (λ (x : α), ∑' (i : ι), F i x)
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] (u : Rˣ) (hu : ↑u < 0) (v : module.Ray R m) : u • v = -v
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {v : K} {q : ℚ} (v_Eq_q : v = ↑q) : {h := ↑((GeneralizedContinuedFraction.of q).h), S := Seq.Map (GeneralizedContinuedFraction.Pair.Map Coe) (GeneralizedContinuedFraction.of q).S} = GeneralizedContinuedFraction.of v
{m : Type u_1} {α : Type u_6} [Monoid m] [MulAction m α] [has_Mul α] (r S : m) (x y : α) [IsScalarTower m α α] [SmulCommClass m α α] : r • x * S • y = (r * S) • (x * y)
{R : Type u} [Semiring R] : AddSubmonoid.Closure {P : Polynomial R | ∃ (n : ℕ) (A : R), P = ⇑(Polynomial.monomial n) A} = ⊤
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) (r : R) (n : ℕ) : v.Int_Valuation_def r ≤ ↑(⇑Multiplicative.of_Add (-↑n)) ↔ v.as_Ideal ^ n ∣ Ideal.Span {r}
{n : ℕ} {α : Type u_1} {β : Type u_2} (F : β → α → β) (B : β) {v : Vector α n} : (Vector.scanl F B v).val = List.scanl F B v.val
{J : Type u₁} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {J' : Type u₂} [CategoryTheory.Category J'] (e : J ≌ J') [CategoryTheory.Limits.HasLimits_of_shape J C] : CategoryTheory.Limits.HasLimits_of_shape J' C
{B : Type u} [CategoryTheory.Bicategory B] {A B : B} {F g h i : A ⟶ B} [CategoryTheory.Bicategory.Lift_hom F] [CategoryTheory.Bicategory.Lift_hom g] [CategoryTheory.Bicategory.Lift_hom h] (η : F ⟶ g) (θ : g ⟶ h) (ι : h ⟶ i) [CategoryTheory.Bicategory.Lift_hom₂ η] [CategoryTheory.Bicategory.Lift_hom₂ θ] : η ≫ θ ≫ ι = (η ≫ θ) ≫ ι
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : LocalHomeomorph α β} {S : set α} {t : set β} : e._image S t → e.to_local_Equiv.Source ∩ ⇑e ⁻¹' t = e.to_local_Equiv.Source ∩ S
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {F' : E →L[𝕜] F} {x : E} {S : set E} (h : x ∉ Closure S) : HasFderivWithinAt F F' S x
{m : Type u_1} [has_Mul m] {r : m → m → Prop} {C : Con m} (h : ∀ (x y : m), r x y → Setoid.r x y) : Con_gen r ≤ C
{C D : Type u} [CategoryTheory.Category C] [CategoryTheory.Category D] {A : Type W} [CategoryTheory.Category A] [CategoryTheory.Limits.HasLimits A] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {G : C ⥤ D} (hu : CategoryTheory.CoverLifting J K G) (ℱ : CategoryTheory.sheaf J A) {x : A} {U : D} {S : CategoryTheory.Sieve U} (hS : S ∈ ⇑K U) {x : CategoryTheory.Presieve.FamilyOfElements ((CategoryTheory.ran G.Op).obj ℱ.val ⋙ CategoryTheory.coyoneda.obj (Opposite.Op x)) S.Arrows} (hx : x.compatible) (y : ((CategoryTheory.ran G.Op).obj ℱ.val ⋙ CategoryTheory.coyoneda.obj (Opposite.Op x)).obj (Opposite.Op U)) (hy : x._amalgamation y) : y = CategoryTheory.ran__sheaf_of_CoverLifting.glued_section hu ℱ hS hx
(B : ℤ) : B ≤ B ^ 2
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {A : α} {S : set α} (ha : IsLub S A) (hs : S.Nonempty) (sc : IsClosed S) : A ∈ S
{z : UpperHalfPlane} (hz : z ∈ modular_Group.Fdo) (n : ℤ) : 1 < ⇑Complex.norm_sq ↑(modular_Group.t ^ n • z)
{α : Type u_1} [NormedRing α] [CompleteSpace α] {F g : ℕ → α} (hF : Summable (λ (x : ℕ), ∥F x∥)) (hg : Summable (λ (x : ℕ), ∥g x∥)) : (∑' (n : ℕ), F n) * ∑' (n : ℕ), g n = ∑' (n : ℕ), (Finset.Nat.antidiagonal n).Sum (λ (kl : ℕ × ℕ), F kl.fst * g kl.Snd)
{m : Type u_1} {R : Type u_2} [Monoid m] [non_unital_non_assoc_Ring R] [Distrib_MulAction m R] (k : m) (h : ∀ (x : R), k • x = 0 → x = 0) {A B : R} (h' : k • A = k • B) : A = B
{g : Equiv.perm (Fin 5)} (h : 3 ∈ g.Cycle_Type) : (g * g)._three_Cycle
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.coproducts_Disjoint C] : CategoryTheory.Limits.InitialMonoClass C
{S : Type u_2} [CommRing S] (A : Type u_6) [CommRing A] [IsDomain A] [Algebra A S] {m : Submonoid A} [IsLocalization m S] (hM : m ≤ non_Zero_divisors A) : IsDomain S
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {B₂ : Basis (Fin 2) ℝ v} (hb₂ : Orthonormal ℝ ⇑B₂) (ho : B.Orientation = -B₂.Orientation) : ∃ (θ : Real.Angle), B₂ = B.Map (hb.Conj_lie.Trans (hb.rotation θ)).to_Linear_Equiv
(n : ℕ) {R : Type u_1} [Linear_ordered_CommRing R] {x : R} (hx : 1 < x) : 0 < Polynomial.Eval x (Polynomial.cyclotomic n R)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {F g : ℝ → E} {x : ℝ} (F_Diff : ∀ (y : ℝ), y ≠ x → HasDerivAt F (g y) y) (hF : Continuous_at F x) (hg : Continuous_at g x) (y : ℝ) : HasDerivAt F (g y) y
{α : Type u_1} [LinearOrder α] {A B : Finset α} (t : α) (h₁ : A.to_colex < B.to_colex) (h₂ : ∀ (x : α), x ∈ B → x < t) (x : α) (h : x ∈ A) : x < t
{R : Type u} [Ring R] {S : Type v} [Ring S] (F : R →+* S) (P : Polynomial S) : P ∈ Polynomial.lifts F ↔ P ∈ Polynomial.lifts_Ring F
{α : Type u_1} [canonically_ordered_AddMonoid α] [HasSub α] [HasOrderedSub α] {A B C : α} [ContravariantClass α α has_Add.Add has_LE.LE] (h : A + C < B) : A < B - C
{β : Type u} {α : Type v} {γ : Type W} {S : Finset α} [CommMonoid β] [DecidableEq γ] (F : γ → β) (g : α → γ) : S.Prod (λ (A : α), F (g A)) = (Finset.image g S).Prod (λ (B : γ), F B ^ (Finset.Filter (λ (A : α), g A = B) S).Card)
{K : Type u} [Field K] {S : set K} {t : Subfield K} : Subfield.Closure S ≤ t ↔ S ⊆ ↑t
{α : Type u} {β : Type v} [Linear_ordered_Field α] [TopologicalSpace α] [OrderTopology α] {l : Filter β} {F g : β → α} {C : α} (hC : 0 < C) (hF : Filter.Tendsto F l Filter.at_IsBot) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (λ (x : β), F x * g x) l Filter.at_IsBot
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (S : Affine.Simplex ℝ P 1) : S.circumcenter = Finset.centroid ℝ Finset.Univ S.points
{β : Type u_2} {F g : β → ℝ} (hg : ∀ (B : β), 0 ≤ g B) (hgf : ∀ (B : β), g B ≤ F B) (hF : Summable F) : Summable g
{α : Type u} [MetricSpace α] [ProperSpace α] {S : set α} (hs : IsClosed S) {R : α → ℝ} (hR : ∀ (x : α), x ∈ S → 0 < R x) : ∃ (ι : Type u) (C : ι → α) (r r' : ι → ℝ), (∀ (i : ι), C i ∈ S ∧ 0 < r i ∧ r i < r' i ∧ r' i < R (C i)) ∧ locally_Finite (λ (i : ι), Metric.Ball (C i) (r' i)) ∧ S ⊆ ⋃ (i : ι), Metric.Ball (C i) (r i)
{m : Type u_1} [Monoid m] {S t : set m} (h : S ⊆ t) : Monoid.Closure S ⊆ Monoid.Closure t
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k → E} {A B r : k} (hab : A < B) (h₀ : 0 < r) (h₁ : r < 1) : ⇑(affine_Map.line_Map (F A) (F B)) r < F (⇑(affine_Map.line_Map A B) r) ↔ slope F (⇑(affine_Map.line_Map A B) r) B < slope F A (⇑(affine_Map.line_Map A B) r)
{𝕜 : Type u_1} {E : Type u_2} [NormedField 𝕜] [HasNorm E] {A : 𝕜} {F : 𝕜 → E} (h : Filter._bounded_under has_LE.LE (nhds_within A {A}ᶜ) (HasNorm.norm ∘ F)) : F =o[nhds_within A {A}ᶜ] λ (x : 𝕜), (x - A)⁻¹
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasCokernels C] : CategoryTheory.Limits.HasCoequalizers C
{m : Type u_3} {N : Type u_4} [AddZeroClass m] [AddZeroClass N] (F : m →+ N) (A B : m) : ⇑F (A + B) = ⇑F A + ⇑F B
{J : Type v} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (F : J → C) [CategoryTheory.Limits.HasBiproduct F] {B : CategoryTheory.Limits.Bicone F} (hb : B._bilimit) : (hb._Limit.cone_point_Unique_Up_to_iso (CategoryTheory.Limits.biproduct._Limit F)).Inv = CategoryTheory.Limits.biproduct.Desc B.ι
{R : Type u_2} [CommRing R] [IsDomain R] [DecidableEq R] [Fintype R] {P : Polynomial R} (hp : 0 < P.degree) : Fintype.Card R ≤ P.Nat_degree * (Finset.image (λ (x : R), Polynomial.Eval x P) Finset.Univ).Card
{K : Type u_1} [Linear_ordered_Field K] {A B C : K} (ha : A ≠ 0) (h : ∀ (x : K), 0 < A * x * x + B * x + C) : discrim A B C < 0
{α : Type u} {ι : Type u_1} {S : set ι} (hs : S.Finite) {t : Π (i : ι), i ∈ S → set α} (ht : ∀ (i : ι) (h : i ∈ S), (t i h).Finite) : (⋃ (i : ι) (h : i ∈ S), t i h).Finite
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type W} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace 𝕜] [Finite_dimensional 𝕜 E] [Finite_dimensional 𝕜 F] (Cond : Finite_dimensional.finrank 𝕜 E = Finite_dimensional.finrank 𝕜 F) : Nonempty (E ≃L[𝕜] F)
{α : Type u} {β : Type v} [MulOneClass α] [MulOneClass β] {F : α → β} (hF : _Monoid_hom F) (x y : α) : F (x * y) = F x * F y
{P A B : ℕ} (hpb : P ∈ B.Factors) (ha : A ≠ 0) : P ∈ (A * B).Factors
{α : Type u_1} [has_LE α] {A : αᵒᵈ} : IsMax A → IsMin (⇑order_dual.of_dual A)
{J : Type u} [CategoryTheory.Category J] [CategoryTheory.IsCofiltered J] (F : J ⥤ Type v) [Π (j : J), Fintype (F.obj j)] [∀ (j : J), Nonempty (F.obj j)] : F.sections.Nonempty
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} [DecidableEq β'] [DecidableEq γ] [DecidableEq δ] {F : α → β → γ} {S : Finset α} {t : Finset β} {g : γ → δ} {F' : β' → α → δ} {g' : β → β'} (h_antidistrib : ∀ (A : α) (B : β), g (F A B) = F' (g' B) A) : Finset.image g (Finset.image₂ F S t) = Finset.image₂ F' (Finset.image g' t) S
{α : Type u_2} {β : Type u_3} {rα : non_assoc_Semiring α} {rβ : non_assoc_Semiring β} (F : α →+* β) [Nontrivial β] : ⇑F 1 ≠ 0
{R : Type u_1} {G : Type u_2} [AddCommGroup G] [CommRing R] [Nontrivial R] : Algebra.Finite_Type R (AddMonoid_Algebra R G) ↔ AddGroup.fg G
{E : Type u_2} {𝕜 : Type u_3} [Linear_ordered_Field 𝕜] [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul 𝕜 E] {S : set E} (hs : Convex 𝕜 S) {x y : E} (hx : x ∈ S) (hy : x + y ∈ Interior S) {t : 𝕜} (ht : t ∈ set.ioc 0 1) : x + t • y ∈ Interior S
(x : ℂ) : HasDerivAt Complex.sinh (Complex.cosh x) x
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} (h : ↑S.Nonempty) : AffineSubspace.direction_of_Nonempty h = S.direction
{ι : Type u_1} {α : ι → Type u_2} [DecidableEq ι] [Π (i : ι), has_Zero (α i)] {S : Finset ι} {F : Π₀ (i : ι), α i} [Π (i : ι), DecidableEq (α i)] {t : Π₀ (i : ι), Finset (α i)} (ht : t.Support ⊆ S) : F ∈ S.Dfinsupp ⇑t ↔ ∀ (i : ι), ⇑F i ∈ ⇑t i
(P : ℕ) [hp : Fact (Nat.Prime P)] (q r : ℚ) : padic_norm P (q * r) = padic_norm P q * padic_norm P r
{α : Type u_1} [Fintype α] : Nonempty (Field α) ↔ Prime_Pow (Fintype.Card α)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace E] {v : E} (hv : v ∈ K) : ⇑(reflection Kᗮ) v = -v
{γ : Type W} [Preorder γ] [OrderTop γ] (S : set γ) : BddAbove S
{α : Type u} [PseudoEmetricSpace α] {S t : set α} : Emetric.Hausdorff_edist S t = Emetric.Hausdorff_edist t S
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] (v W : E) (h : W ∈ K) : HasInner.inner (v - ↑(⇑(Orthogonal_projection K) v)) W = 0
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} [TopologicalSpace α] [TopologicalSpace β] {i : α → β} [TopologicalSpace δ] {F : γ → α} {g : γ → δ} {h : δ → β} {D : δ} {A : α} (di : Dense_Inducing i) (h : Filter.Tendsto h (nhds D) (nhds (i A))) (comm : h ∘ g = i ∘ F) : Filter.Tendsto F (Filter.comap g (nhds D)) (nhds A)
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {A B : α} [IsAntisymm α HasSubset.Subset] (h₁ : A ⊆ B) (h₂ : A ≠ B) : A ⊂ B
{ι : Type u_1} {x : Type u_2} [TopologicalSpace x] [NormalSpace x] {u : ι → set x} {S : set x} {C : set (ShrinkingLemma.PartialRefinement u S)} (hc : IsChain has_LE.LE C) (Ne : C.Nonempty) (hfin : ∀ (x : x), x ∈ S → {i : ι | x ∈ u i}.Finite) (hU : S ⊆ ⋃ (i : ι), u i) {v : ShrinkingLemma.PartialRefinement u S} (hv : v ∈ C) : v ≤ ShrinkingLemma.PartialRefinement.chain_Sup C hc Ne hfin hU
{n : Type u_3} [Fintype n] {A : Type u_1} [DecidableEq n] [CommRing A] [IsDomain A] {m : Matrix n n A} : m.det ≠ 0 → m.nondegenerate
{A : ℝ} {l : Filter ℝ} {F g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in nhds_within A (set.Iio A), Differentiable_at ℝ F x) (hg' : ∀ᶠ (x : ℝ) in nhds_within A (set.Iio A), deriv g x ≠ 0) (hfa : Filter.Tendsto F (nhds_within A (set.Iio A)) (nhds 0)) (hga : Filter.Tendsto g (nhds_within A (set.Iio A)) (nhds 0)) (HDiv : Filter.Tendsto (λ (x : ℝ), deriv F x / deriv g x) (nhds_within A (set.Iio A)) l) : Filter.Tendsto (λ (x : ℝ), F x / g x) (nhds_within A (set.Iio A)) l
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] {x y : x} {γ : Y → Path x y} {F : Y → ℝ} (hγ : Continuous ↿γ) (hF : Continuous F) : Continuous (λ (t : Y), (γ t).extend (F t))
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A B : α} (ha : 1 ≤ A) (hb : 1 ≤ B) : 1 ≤ A * B
{𝕜 : Type u_1} [_R_or_C 𝕜] [dec𝕜 : DecidableEq 𝕜] {E : Type u_2} [InnerProductSpace 𝕜 E] {t : E →ₗ[𝕜] E} (hT : InnerProductSpace.IsSelfAdjoint t) [Finite_dimensional 𝕜 E] {n : ℕ} (hn : Finite_dimensional.finrank 𝕜 E = n) (v : E) (i : Fin n) : ⇑(hT.diagonalization_Basis hn) (⇑t v) i = ↑(hT.Eigenvalues hn i) * ⇑(hT.diagonalization_Basis hn) v i
{α : Type u_1} {r : α → α → Prop} {S t : set α} (ht : IsAntichain r t) (h : Maximals r S ⊆ t) (hs : ∀ ⦃A : α⦄, A ∈ t → (∃ (B : α) (h : B ∈ Maximals r S), r B A)) : Maximals r S = t
{α : Type u} [PseudoMetricSpace α] {S t : set α} (hs : IsClosed S) (ht : IsClosed t) (Fin : Emetric.Hausdorff_edist S t ≠ ⊤) : metric.Hausdorff_dist S t = 0 ↔ S = t
{n : ℕ} {α : Fin (n + 1) → Type u} (q : Π (i : Fin (n + 1)), α i) (z : α (Fin.Last n)) : Fin.init (Function.update q (Fin.Last n) z) = Fin.init q
{α : Type u} [t : TopologicalSpace α] {B : set (set α)} (hb : TopologicalSpace._topological_Basis B) {S : set α} : Dense S ↔ ∀ (o : set α), o ∈ B → o.Nonempty → (o ∩ S).Nonempty
{G : Type u_1} [Group G] {h K : Subgroup G} (h : ∀ (x : G), x ∈ h ↔ x ∈ K) : h = K
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] {E1 E2 : intermediate_Field K L} (h12 : E1 ≤ E2) : E2.fixing_Subgroup ≤ E1.fixing_Subgroup
{α : Type u} [Preorder α] {A B : α} (h : A < B) : A ≠ B
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LE.LE] {A B : α} (ha : A ≤ 1) (hb : B < 1) : A * B < 1
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace ℝ P) [Nonempty ↥S] [CompleteSpace ↥(S.direction)] (P : P) : P -ᵥ ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P) ∈ (S.direction)ᗮ
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y z : v} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x (-y) + hb.oangle y (-z) + hb.oangle z (-x) = ↑Real.Pi
(R : Type u_1) (S : Type u_2) [Ring R] [Ring S] [IsDomain (R × S)] [Nontrivial R] [Nontrivial S] : False
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x ⟶ Y} {C : CategoryTheory.Limits.Cofork F g} (i : CategoryTheory.Limits.IsColimit C) : CategoryTheory.Epi C.π
{ι : Type u_1} {ι' : Type u_2} {R : Type u_5} {m : Type u_6} [CommSemiring R] [AddCommMonoid m] [module R m] (B : Basis ι R m) (B' : Basis ι' R m) [Fintype ι'] [Fintype ι] [DecidableEq ι] : ⇑(Linear_Map.to_Matrix B B') LinearMap.Id = B'.to_Matrix ⇑B
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMaxOrder α] [DenselyOrdered α] {A : α} {S : set α} : S ∈ nhds_within A (set.ici A) ↔ ∃ (u : α) (h : u ∈ set.ioi A), set.icc A u ⊆ S
{G : Type u_1} {m : Type u_3} [Group G] [Monoid m] [MulAction G m] [SmulCommClass G m m] [IsScalarTower G m m] (g : G) (m : mˣ) : (g • m)⁻¹ = g⁻¹ • m⁻¹
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (E : intermediate_Field K L) : E.Map (AlgHom.Id K L) = E
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {F : m →+ P} : (Add_Con.Ker_Lift F).mrange = F.mrange
{ι : Type u} (F : ι → Cardinal) : BddAbove (set.Range F)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) : hb.oangle x y = θ ↔ y = (∥y∥ / ∥x∥) • ⇑(hb.rotation θ) x
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x : v) : o.oangle x x = 0
{K : Type u} {v : Type v} {v' : Type v'} [DivisionRing K] [AddCommGroup v] [module K v] [AddCommGroup v'] [module K v'] : Nonempty (v ≃ₗ[K] v') ↔ (module.rank K v).Lift = (module.rank K v').Lift
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMaxOrder α] [NoMinOrder α] {A : α} {S : set α} : S ∈ nhds A ↔ ∃ (l u : α), A ∈ set.Ioo l u ∧ set.Ioo l u ⊆ S
{ι : Type u_1} {mᵢ : ι → Type u_7} [Π (i : ι), AddCommGroup (mᵢ i)] [Fintype ι] {R : Type u_2} [ordered_Ring R] [Π (i : ι), module R (mᵢ i)] {q : Π (i : ι), QuadraticForm R (mᵢ i)} (h : (QuadraticForm.Pi q).anisotropic) (i : ι) : (q i).anisotropic
{S : Type u} [has_Add S] {A x y : S} (h : Add_SemiconjBy A x y) : A + x = y + A
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {x Y : C} (F : x ⟶ Y) [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasCokernel F] [CategoryTheory.Epi F] : CategoryTheory.Limits.Cokernelπ F = 0
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y z : v} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x z - hb.oangle x y = hb.oangle y z
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {G : ι → Type u_5} [Π (i : ι), InnerProductSpace 𝕜 (G i)] {v : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 v) [CompleteSpace E] (F : Π (i : ι), G i) : Summable (λ (i : ι), ⇑(v i) (F i)) ↔ Summable (λ (i : ι), ∥F i∥ ^ 2)
{A : ℕ} : Real.sqrt ↑A ≤ ↑(Nat.sqrt A) + 1
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S1 S2 : AffineSubspace k P} (h : S1 < S2) (hn : ↑S1.Nonempty) : S1.direction < S2.direction
{n : ℕ} {E : Type u_1} [NormedGroup E] {F : (Fin n → ℂ) → E} {C : Fin n → ℂ} {R : Fin n → ℝ} [NormedSpace ℂ E] (hF : TorusIntegrable F C R) : MeasureTheory.IntegrableOn (λ (θ : Fin n → ℝ), Finset.Univ.Prod (λ (i : Fin n), ↑(R i) * Complex.Exp (↑(θ i) * Complex.i) * Complex.i) • F (torus_Map C R θ)) (set.icc 0 (λ (_x : Fin n), 2 * Real.Pi)) MeasureTheory.MeasureSpace.Volume
{K : Type u_4} {v : Type u} [Field K] [AddCommGroup v] [module K v] (P : Submodule K v) (hp : P < ⊤) : ∃ (F : v →ₗ[K] K) (h : F ≠ 0), P ≤ F.Ker
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {S : set E} {F : E → F} {n : WithTop ℕ} {x : G} (g : G →L[𝕜] E) (hF : ContDiff_within_at 𝕜 n F S (⇑g x)) : ContDiff_within_at 𝕜 n (F ∘ ⇑g) (⇑g ⁻¹' S) x
{R : Type u_1} [Semiring R] (P : Polynomial R → Prop) (N : ℕ) (P_0 : P 0) (P_C_Mul_Pow : ∀ (n : ℕ) (r : R), r ≠ 0 → n ≤ N → P (⇑Polynomial.C r * Polynomial.x ^ n)) (P_C_Add : ∀ (F g : Polynomial R), F.Nat_degree < g.Nat_degree → g.Nat_degree ≤ N → P F → P g → P (F + g)) (F : Polynomial R) : F.Nat_degree ≤ N → P F
{α : Type u_1} {r S : Setoid α} : (r ⊓ S).Rel = r.Rel ⊓ S.Rel
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder β] [SuccOrder β] [IsSuccArchimedean β] [Nonempty β] {S : β → set α} (h : ∀ (n : β), IsConnected (S n)) (K : ∀ (n : β), (S n ∩ S (Order.Succ n)).Nonempty) : IsConnected (⋃ (n : β), S n)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] {F : E → F} {P : FormalMultilinearSeries 𝕜 E F} {x y : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall F P x r) (h : ↑∥y∥₊ < r) : HasFpowerSeriesOnBall F (P.change_origin y) (x + y) (r - ↑∥y∥₊)
{α : Type u} {u : Ultrafilter (Ultrafilter α)} {x : Ultrafilter α} : ↑u ≤ nhds x ↔ x = mjoin u
{Γ : Type u_4} [Group Γ] {t : Type u_5} [TopologicalSpace t] [MulAction Γ t] [has_Continuous_Const_Smul Γ t] : IsOpen_Map Quotient.Mk
{n : ℕ} {α : Fin (n + 1) → Type u} (q : Π (i : Fin (n + 1)), α i) (i : Fin n) (y : α (⇑Fin.cast_Succ i)) : Fin.init (Function.update q (⇑Fin.cast_Succ i) y) = Function.update (Fin.init q) i y
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y : m} (h : SameRay R x y) (hx : x ≠ 0) (hy : y ≠ 0) : ∃ (r₁ r₂ : R), 0 < r₁ ∧ 0 < r₂ ∧ r₁ • x = r₂ • y
{α : Type u_1} [TopologicalSpace α] [t2_Space α] [MeasurableSpace α] [BorelSpace α] {S t : set α} (hs : MeasureTheory.analytic_set S) (ht : MeasureTheory.analytic_set t) (h : Disjoint S t) : MeasureTheory.measurably_IsSeparable S t
{P : ℕ} {R : Type u_1} {S : Type u_2} [hp : Fact (Nat.Prime P)] [CommRing R] [CommRing S] (F : R →+* S) (x : witt_Vector P R) : ⇑(witt_Vector.Map F) (⇑witt_Vector.verschiebung x) = ⇑witt_Vector.verschiebung (⇑(witt_Vector.Map F) x)
{x y z : ℤ} (k : ℤ) (hk : k ≠ 0) : PythagoreanTriple (k * x) (k * y) (k * z) ↔ PythagoreanTriple x y z
{α : Type u_2} {ι : Type u_5} [CommMonoid α] (t : Finset ι) (F : ι → set α) (g : ι → α) (hg : ∀ (i : ι), i ∈ t → g i ∈ F i) : t.Prod (λ (i : ι), g i) ∈ t.Prod (λ (i : ι), F i)
{α : Type u} {β : Type v} [Preorder α] [LinearOrder β] {F g : α → β} (hF : Monotone F) (hg : Monotone g) : Monotone (λ (x : α), LinearOrder.min (F x) (g x))
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K₁ K₂ : Submodule 𝕜 E} [Finite_dimensional 𝕜 ↥K₂] (h : K₁ ≤ K₂) {n : ℕ} (h_dim : Finite_dimensional.finrank 𝕜 ↥K₁ + n = Finite_dimensional.finrank 𝕜 ↥K₂) : Finite_dimensional.finrank 𝕜 ↥(K₁ᗮ ⊓ K₂) = n
{R : Type u} [Ring R] {P : Type (max u v)} [AddCommGroup P] [module R P] (huniv : ∀ {m : Type (max v u)} {N : Type (max u v)} [_inst_4 : AddCommGroup m] [_inst_5 : AddCommGroup N] [_inst_6 : module R m] [_inst_7 : module R N] (F : m →ₗ[R] N) (g : P →ₗ[R] N), Function.Surjective ⇑F → (∃ (h : P →ₗ[R] m), F.Comp h = g)) : module.projective R P
{α : Type u} {β : Type v} [TopologicalSpace α] [semi_NormedGroup β] (B : β) : ∥bounded_Continuous_Function.Const α B∥ ≤ ∥B∥
{n A : ℕ} (h : A < n + 1) : ↑A.val = A
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [Linear_ordered_Field 𝕜] [AddCommGroup E] [ordered_AddCommGroup β] [module 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F : E → β} {t : Finset ι} {W : ι → 𝕜} {P : ι → E} (hF : ConcaveOn 𝕜 S F) (h₀ : ∀ (i : ι), i ∈ t → 0 ≤ W i) (h₁ : t.Sum (λ (i : ι), W i) = 1) (hmem : ∀ (i : ι), i ∈ t → P i ∈ S) : t.Sum (λ (i : ι), W i • F (P i)) ≤ F (t.Sum (λ (i : ι), W i • P i))
{α : Type u} [PseudoEmetricSpace α] {S t : set α} (hs : S.Nonempty) (ht : t.Nonempty) : Emetric.Hausdorff_edist S t ≤ Emetric.diam (S ∪ t)
(v : Type u_1) [semi_NormedGroup v] (h : ∃ (x : v), ∥x∥ ≠ 0) : ∥NormedGroup_hom.Id v∥ = 1
{α : Type u} [PseudoEmetricSpace α] {x : α} {S t : set α} (h : x ∈ S) : Emetric.Inf_edist x t ≤ Emetric.Hausdorff_edist S t
{C : Type u₁} [CategoryTheory.Category C] {J : Type u₂} [CategoryTheory.Category J] (F : J ⥤ Cᵒᵖ) [CategoryTheory.Limits.HasColimit F.Left_Op] : CategoryTheory.Limits.HasLimit F
{B m : ℕ} (hb : 2 ≤ B) : m < B ^ (B.digits m).length
 : Cardinal.Ord ∘ Cardinal.aleph = Ordinal.enum_Ord {B : Ordinal | B.Card.Ord = B ∧ Ordinal.omega ≤ B}
{R : Type u} [Ring R] {P : Polynomial R} (r : R) : Polynomial.Eval r (P * (Polynomial.x - ⇑Polynomial.C r)) = 0
{α : Type u} [SemilatticeSup α] [OrderBot α] {ι : Type u} [Fintype ι] (F : ι → α) : (∐ F) = (Fintype.elems ι).Sup F
{m : Type u_1} [has_Add m] (S : set m) {P : Π (x : m), x ∈ Add_Subsemigroup.Closure S → Prop} (Hs : ∀ (x : m) (h : x ∈ S), P x _) (HMul : ∀ (x : m) (hx : x ∈ Add_Subsemigroup.Closure S) (y : m) (hy : y ∈ Add_Subsemigroup.Closure S), P x hx → P y hy → P (x + y) _) {x : m} (hx : x ∈ Add_Subsemigroup.Closure S) : P x hx
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [Finite_dimensional R m] [Nonempty ι] (x : Orientation R m ι) (h : Fintype.Card ι = Finite_dimensional.finrank R m) : (x.Some_Basis h).Orientation = x
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_5} [NormedGroup E'] [NormedSpace 𝕜 E'] {n : WithTop ℕ} {F : E → E'} {S : set E} {x : E} : Cont_mdiff_within_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n F S x → ContDiff_within_at 𝕜 n F S x
{α : Type u} {β : Type v} {F : α ≃. β} (h : ∀ (A : α), ↥((⇑F A)._Some)) : Function.Injective ⇑F
(x : ℝ) : Real.sinh x = (Real.Exp x - Real.Exp (-x)) / 2
{R : Type u_1} [CommSemiring R] (S : Subsemiring R) {ι : Type u_2} {t : Finset ι} {F : ι → R} (h : ∀ (C : ι), C ∈ t → F C ∈ S) : t.Prod (λ (i : ι), F i) ∈ S
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_Ring 𝕜] [AddCommGroup E] [AddCommGroup F] [module 𝕜 E] [module 𝕜 F] (F : E →ᵃ[𝕜] F) {S : set F} (hs : Convex 𝕜 S) : Convex 𝕜 (⇑F ⁻¹' S)
{α : Type u_1} {m : Type u_5} {N : Type u_7} [has_Zero m] [CommMonoid N] {S : Finset α} {F : α → m} {g : α → m → N} (hF : ∀ (A : α), F A ≠ 0 → A ∈ S) (hg : ∀ (A : α), g A 0 = 1) : (Finsupp.on_Finset S F hF).Prod g = S.Prod (λ (A : α), g A (F A))
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.has_Finite_coproducts C] : CategoryTheory.Limits.has_Finite_biproducts C
{α' : sort W} [DecidableEq α'] {α : sort u_1} {β : sort u_2} (g : α' → β) {F : α → α'} {i : α'} (A : β) (h : ∀ (x : α), F x ≠ i) : Function.update g i A ∘ F = g ∘ F
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {P : E × F} : ContDiff_at 𝕜 n Prod.fst P
{R : Type u} {ι : Type u'} {m₁ : ι → Type v₁} {m₂ : Type v₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (m₁ i)] [AddCommMonoid m₂] [Π (i : ι), module R (m₁ i)] [module R m₂] (F : MultilinearMap R m₁ m₂) {α : ι → Type u_1} (g : Π (i : ι), α i → m₁ i) [Fintype ι] [Π (i : ι), Fintype (α i)] : ⇑F (λ (i : ι), Finset.Univ.Sum (λ (j : α i), g i j)) = Finset.Univ.Sum (λ (r : Π (i : ι), α i), ⇑F (λ (i : ι), g i (r i)))
{α : sort u_1} {β : sort u_2} {S₁ : Setoid α} {S₂ : Setoid β} {P : Quotient S₁ → Quotient S₂ → Prop} (h : ∀ (A₁ : α) (A₂ : β), P (Quotient.Mk' A₁) (Quotient.Mk' A₂)) (q₁ : Quotient S₁) (q₂ : Quotient S₂) : P q₁ q₂
{α : Type u_1} (F : α → Nnreal) : Filter.Tendsto (λ (S : Finset α), ∑' (B : {x // x ∉ S}), F ↑B) Filter.at_top (nhds 0)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {F : α → β} {x : α} {S : set α} : Continuous_within_at F S x → Continuous_within_at F (HasInsert.Insert x S) x
(A : ↥Circle) : ⇑Linear_Equiv.det (⇑rotation A).to_Linear_Equiv = 1
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommGroup E] [HasScalar 𝕜 E] {S : Convex_cone 𝕜 E} (hS : S.flat) : S.Pointed
(K : Type u_1) (L : Type u_2) {A : Type u_5} [Field K] [Field L] [CommRing A] [Algebra K L] [Algebra L A] [Algebra K A] [IsScalarTower K L A] (A_alg : Algebra.IsAlgebraic K A) : Algebra.IsAlgebraic L A
{α : Type u_1} [TopologicalSpace α] [PolishSpace α] {S : set α} (hs : IsClosed S) : PolishSpace ↥S
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P ⟶ q) : Function.Surjective ⇑F → CategoryTheory.Epi F
{n : ℕ} (A : Zmod n) : ↑↑A = A
{E : ℕ → Type u_1} {α : Type u_2} [PseudoMetricSpace α] {F : (Π (n : ℕ), E n) → α} : (∀ (x y : Π (n : ℕ), E n), HasDist.dist (F x) (F y) ≤ HasDist.dist x y) ↔ ∀ (x y : Π (n : ℕ), E n) (n : ℕ), y ∈ Pi_Nat.Cylinder x n → HasDist.dist (F x) (F y) ≤ (1 / 2) ^ n
{ι : Type u_1} {E : Type u_3} [semi_NormedGroup E] {F : ι → E} {g : ι → Nnreal} {A : Nnreal} (hg : has_Sum g A) (h : ∀ (i : ι), ∥F i∥₊ ≤ g i) : ∥∑' (i : ι), F i∥₊ ≤ A
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) (h : HasInner.inner x y = 0) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
{α : Type u_1} [Linear_ordered_Field α] {A B C D : α} (hc : C ≠ 0) (hD : D ≠ 0) : A / C < B / D → (A * D - B * C) / (C * D) < 0
{E : Type u_2} [AddCommGroup E] [module ℝ E] (F : LinearPmap ℝ E ℝ) (N : E → ℝ) (N_hom : ∀ (C : ℝ), 0 < C → ∀ (x : E), N (C • x) = C * N x) (N_Add : ∀ (x y : E), N (x + y) ≤ N x + N y) (hF : ∀ (x : ↥(F.IsDomain)), ⇑F x ≤ N ↑x) : ∃ (g : E →ₗ[ℝ] ℝ), (∀ (x : ↥(F.IsDomain)), ⇑g ↑x = ⇑F x) ∧ ∀ (x : E), ⇑g x ≤ N x
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {P : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall F P x r) : TendstoLocallyUniformlyOn (λ (n : ℕ) (y : E), P.partial_Sum n (y - x)) F Filter.at_top (Emetric.Ball x r)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} {Fₗ : Type u_7} [NormedGroup E] [NormedGroup F] [NormedGroup Fₗ] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] [NormedSpace 𝕜 Fₗ] {σ₁₂ : 𝕜 →+* 𝕜₂} (F : E →sl[σ₁₂] F) [CompleteSpace F] (e : E →L[𝕜] Fₗ) (h_Dense : DenseRange ⇑e) {N : Nnreal} (h_e : ∀ (x : E), ∥x∥ ≤ ↑N * ∥⇑e x∥) [Ring_hom_isometric σ₁₂] : ∥F.extend e h_Dense _∥ ≤ ↑N * ∥F∥
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A : ℝ} {S : set ℝ} (hintg : ∀ (x : ℝ), x ∈ S → IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A x) (hcont : Continuous F) : DifferentiableOn ℝ (λ (u : ℝ), ∫ (x : ℝ) in A..u, F x) S
{R : Type u_1} {A : R} [Mul_Zero_class R] [Nontrivial R] (la : IsRegular A) : A ≠ 0
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] {K : Type u_2} [Field K] [Algebra R K] [_fraction_Ring R K] (v : IsDedekindDomain.height_One_Spectrum R) (r : R) : ⇑(v.Valuation) (⇑(Algebra_Map R K) r) = ⇑(v.Int_Valuation) r
{α : Type u} {β : Type v} [TopologicalSpace α] [semi_NormedGroup β] {F : bounded_Continuous_Function α β} {C : ℝ} (C0 : 0 ≤ C) : ∥F∥ ≤ C ↔ ∀ (x : α), ∥⇑F x∥ ≤ C
{m : Type u_1} [CommMonoid m] {S t : set m} {x : m} : x ∈ Monoid.Closure (S ∪ t) ↔ ∃ (y : m) (h : y ∈ Monoid.Closure S) (z : m) (h : z ∈ Monoid.Closure t), y * z = x
{α : Type u} [NormedField α] {u : ℕ → α} : _cau_Seq HasNorm.norm u ↔ Cauchy_Seq u
{m : Type u_1} {R : Type u_3} [Fintype m] [DecidableEq m] [CommSemiring R] (A : Matrix m m R) : ⇑((mv_Polynomial.Eval (λ (P : m × m), A P.fst P.Snd)).Map_Matrix) (Matrix.mv_Polynomial.x m m R) = A
(R : Type u) [Ring R] (hF : _Field R) (x : R) : x ≠ 0 → (∃! (y : R), x * y = 1)
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {F : J ⥤ C} {t : CategoryTheory.Limits.Cone F} (h : CategoryTheory.Limits.IsLimit t) (S : CategoryTheory.Limits.Cone F) : ∃! (l : S.x ⟶ t.x), ∀ (j : J), l ≫ t.π.App j = S.π.App j
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (S : set (Submodule 𝕜 E)) : (⨅ (K : Submodule 𝕜 E) (h : K ∈ S), Kᗮ) = (HasSup.Sup S)ᗮ
{G : Type W} [TopologicalSpace G] [HasNeg G] [has_Add G] [has_Continuous_Add G] [has_Continuous_Neg G] (h : G) : Continuous (λ (g : G), g + h + -g)
{R₁ : Type u_1} {R₂ : Type u_2} [Semiring R₁] [Semiring R₂] (e : R₁ ≃+* R₂) : RingHomInvPair ↑e ↑(e.Symm)
{α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β] {F : β → α} (hF : ∀ (x y : β), F x = F y) : Measurable F
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {B₂ : Basis (Fin 2) ℝ v} (hb₂ : Orthonormal ℝ ⇑B₂) (ho : B.Orientation = B₂.Orientation) : ∃ (θ : Real.Angle), B₂ = B.Map (hb.rotation θ).to_Linear_Equiv
{G₀ : Type u_2} [Group_with_Zero G₀] {P : G₀ˣ → Prop} : (∃ (g : G₀ˣ), P g) ↔ ∃ (g : G₀) (hg : g ≠ 0), P (Units.Mk0 g hg)
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] : IsOpen_Map Prod.fst
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} {v : v} {x : k} {S : set ι} {P : ι → P} {B : P} : (∃ (fs : Finset ι) (hfs : ↑fs ⊆ S) (W : ι → k) (hw : fs.Sum (λ (i : ι), W i) = x), v = ⇑(fs.weighted_vsub_of_point P B) W) ↔ ∃ (fs : Finset ↥S) (W : ↥S → k) (hw : fs.Sum (λ (i : ↥S), W i) = x), v = ⇑(fs.weighted_vsub_of_point (λ (i : ↥S), P ↑i) B) W
{x : Type u_1} [TopologicalSpace x] [SequentialSpace x] {S : set x} : _Seq_IsClosed S → IsClosed S
(K : Type u_1) (L : Type u_2) {A : Type u_5} [Field K] [Field L] [CommRing A] [Algebra K L] [Algebra L A] [Algebra K A] [IsScalarTower K L A] {x : A} (A_alg : IsAlgebraic K x) : IsAlgebraic L x
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (S : Finset ι) [CharZero k] {n : ℕ} (h : S.Card = n + 1) : S.Sum (λ (i : ι), Finset.centroid_weights k S i) = 1
{α : Type u_1} {m : Type u_4} {N : Type u_5} [AddCommMonoid m] [has_Zero N] (F : α → N) (g : α → N → m) {S t : Finset α} (h : S ⊆ t) (hg : ∀ (A : α), g A 0 = 0) : S.Sum (λ (i : α), g i (F i)) = t.Sum (λ (i : α), g i (↑S.indicator F i))
{α : Type u_3} [Linear_ordered_AddCommGroup α] : Filter.Tendsto HasAbs.Abs Filter.at_IsBot Filter.at_top
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {F : Filter α} {g : Filter β} {m : α' → β → γ} {n : α → α'} {m' : α → β → δ} {n' : δ → γ} (h_Left_comm : ∀ (A : α) (B : β), m (n A) B = n' (m' A B)) : Filter.Map₂ m (Filter.Map n F) g = Filter.Map n' (Filter.Map₂ m' F g)
{R : Type u_1} [CommSemiring R] {l : Type u_2} {m : Type u_3} {n : Type u_4} [Fintype n] [DecidableEq n] [Fintype m] [DecidableEq m] (m : Matrix l m R) (N : Matrix m n R) (x : n → R) : ⇑(⇑Matrix.to_lin' (m.Mul N)) x = ⇑(⇑Matrix.to_lin' m) (⇑(⇑Matrix.to_lin' N) x)
{R : Type u_1} [CommRing R] {n : ℕ} (hpos : 0 < n) : Polynomial.cyclotomic n R = (Polynomial.x ^ n - 1) /ₘ n.proper_divisors.Prod (λ (i : ℕ), Polynomial.cyclotomic i R)
{x : Type u_2} {Y : Type u_3} [EmetricSpace x] [EmetricSpace Y] [TopologicalSpace.SecondCountableTopology x] {r : Nnreal} {F : x → Y} (hr : 0 < r) (hF : ∀ (x : x), ∃ (C : Nnreal) (S : set x) (h : S ∈ nhds x), HolderOnWith C r F S) : dimH (set.Range F) ≤ dimH set.Univ / ↑r
{β : Type u} {α : Type v} [CommMonoid β] {S : Finset α} {F : α → β} {A : α} (hp : S.Prod (λ (x : α), F x) = 1) (h1 : ∀ (x : α), x ∈ S → x ≠ A → F x = 1) (x : α) (h : x ∈ S) : F x = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasKernels C] : CategoryTheory.Limits.HasEqualizers C
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {F : α → β} {S : set α} : Antitone_on F S → Monotone_on (⇑order_dual.to_dual ∘ F) S
{β : Type u} {α : Type v} {S : Finset α} [AddCommMonoid β] (F : α → β) {P : α → Prop} [Decidable_Pred P] (h : ∀ (x : α), x ∈ S → P x) : (Finset.Subtype P S).Sum (λ (x : Subtype P), F ↑x) = S.Sum (λ (x : α), F x)
{R : Type u_1} [cancel_Monoid R] (g : R) : IsRegular g
{α : Type u_3} {β : Type u_4} {F : α → β} {k : Filter α} {l : Filter β} [k._countably_generated] : Filter.Tendsto F k l ↔ ∀ (x : ℕ → α), Filter.Tendsto x Filter.at_top k → Filter.Tendsto (F ∘ x) Filter.at_top l
{F : Type} [CommSemiring F] {F : Polynomial F} (hF : Polynomial.has_IsSeparable_contraction 1 F) : hF.degree = F.Nat_degree
{α : Type u_1} {β : Type u_2} [AddZeroClass α] [AddCommGroup β] {F : α → β} (hF : _AddMonoid_hom F) : _AddMonoid_hom (λ (A : α), -F A)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {i : α → β} (di : Dense_Inducing i) [TopologicalSpace.IsSeparable_Space α] : TopologicalSpace.IsSeparable_Space β
{α : Type u_1} (L : List α) {i : ℕ} (hi : i < L.length) : List.Drop i (List.take (i + 1) L) = [L.nth_LE i hi]
{m : Type u_3} {N : Type u_4} [has_Zero m] [has_Zero N] {F g : ZeroHom m N} : F = g ↔ ∀ (x : m), ⇑F x = ⇑g x
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) : o.oangle y (⇑(o.rotation (o.oangle x y)) x) = 0
{α : Type u_1} {β : Type u_2} [LinearOrder α] [SuccOrder α] [Preorder β] {F : α → β} (hF : Monotone F) : Pairwise (Disjoint on λ (n : α), set.Ioo (F n) (F (Order.Succ n)))
 : Disjoint (residual ℝ) MeasureTheory.MeasureSpace.Volume.ae
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P₁ : ι → P) (P₂ : P) (h : S.Sum (λ (i : ι), W i) = 0) : S.Sum (λ (i : ι), W i • (P₁ i -ᵥ P₂)) = ⇑(S.weighted_vsub P₁) W
{A B : ℕ} (ha : A ≠ 0) (hb : B ≠ 0) : (A * B).factorization = A.factorization + B.factorization
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : α → E} {g' : α → F'} {l : Filter α} : (F =o[l] λ (x : α), -g' x) → F =o[l] g'
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasKernels C] {x Y : C} [CategoryTheory.Simple x] [CategoryTheory.Simple Y] (F : x ⟶ Y) : CategoryTheory.IsIso F ↔ F ≠ 0
{R : Type u_1} [CommRing R] (m : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization m S] (S : Finset S) : ∃ (B : ↥m), ∀ (A : S), A ∈ S → IsLocalization._integer R (↑B • A)
{α : Type u_1} {ι : Type u_3} [CompleteLattice α] {S : Finset ι} {F : ι → α} : CompleteLattice.Independent (F ∘ Coe) → S.Sup_indep F
 : Filter.Tendsto ⇑Complex.norm_sq (Filter.cocompact ℂ) Filter.at_top
{α : Type u} {β : Type v} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] {F : Filter β} {u : β → α} {A : α} [F.Ne_IsBot] (h : Filter.Tendsto u F (nhds A)) : F.liminf u = A
{α : sort u} {β : α → sort v} {F₁ F₂ : Π (x : α), β x} (h : ∀ (x : α), F₁ x = F₂ x) : F₁ = F₂
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {P : FormalMultilinearSeries 𝕜 E F} {x : E} (hF : HasFpowerSeriesAt F P x) (n : ℕ) : (λ (y : E), F (x + y) - P.partial_Sum n y) =O[nhds 0] λ (y : E), ∥y∥ ^ n
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_3} [DecidableEq ι] [Fintype ι] (e : Basis ι R m) (F : m ≃ₗ[R] m) : (e.Map F).Orientation = -e.Orientation ↔ ⇑LinearMap.det ↑F < 0
{α : Type u} [TopologicalSpace α] : t2_Space α ↔ ∀ {x y : α}, (nhds x ⊓ nhds y).Ne_IsBot → x = y
{m : Type u_1} [Monoid m] (P : Submonoid m) : P.fg ↔ ∃ (S : set m), Submonoid.Closure S = P ∧ S.Finite
{K : Type u_1} [Linear_ordered_Field K] {v : K} {n : ℕ} [FloorRing K] (TerminatedAt_n : (GeneralizedContinuedFraction.of v).TerminatedAt n) : v = (GeneralizedContinuedFraction.of v).convergents n
{α : Type u_1} {β : Type u_2} {m : Type u_5} [AddCommMonoid m] {F : α → m} {g : β → m} (e : α → β) (hE₀ : Function.Bijective e) (hE₁ : ∀ (x : α), F x = g (e x)) : finsum (λ (i : α), F i) = finsum (λ (j : β), g j)
{R : Type u} [Rack R] {A B : Rack.pre_envel_Group R} : Rack.pre_envel_Group_Rel' R A B → Rack.pre_envel_Group_Rel R A B
(P : ℕ) (A : ℤ) [hp : Fact (Nat.Prime P)] : ↑(Zmod.legendre_Sym P A) = ↑A ^ (P / 2)
{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (m : Matrix n n R) (P : Polynomial R) : ⇑(Polynomial.aeval m) P = ⇑(Polynomial.aeval m) (P %ₘ m.charpoly)
{α : Type u_1} [AddCommMonoid α] {n : ℕ} (F : Affine.Simplex.points_with_circumcenter_Index n → α) : Finset.Univ.Sum (λ (i : Affine.Simplex.points_with_circumcenter_Index n), F i) = Finset.Univ.Sum (λ (i : Fin (n + 1)), F (Affine.Simplex.points_with_circumcenter_Index.point_Index i)) + F Affine.Simplex.points_with_circumcenter_Index.circumcenter_Index
{α : Type u_1} {β : Type u_2} [UniformSpace α] [Group α] [uniform_Group α] {hom : Type u_3} [UniformSpace β] [Group β] [uniform_Group β] [Monoid_hom_class hom α β] (F : hom) (hF : Continuous_at ⇑F 1) : uniform_Continuous ⇑F
{C : Type u} [CategoryTheory.Category C] {S : Type W} [CategoryTheory.SmallCategory S] (e : C ≌ S) : CategoryTheory.EssentiallySmall C
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LT.LT] {A B : α} (ha : 1 < A) (hb : 1 ≤ B) : 1 < A * B
{α : Type u} [AddGroup α] [Preorder α] [CovariantClass α α has_Add.Add has_LE.LE] {A : α} (h : 0 ≤ A) : -A ≤ A
{α : Type u} [TopologicalSpace α] {S : set α} (h : ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → (∃ (t : set α) (h : t ⊆ S), x ∈ t ∧ y ∈ t ∧ IsPreconnected t)) : IsPreconnected S
{F : ℂ → ℂ} {z : ℂ} : ConformalAt F z ↔ (Differentiable_at ℂ F z ∨ Differentiable_at ℂ (F ∘ ⇑(Star_Ring_end ℂ)) (⇑(Star_Ring_end ℂ) z)) ∧ fderiv ℝ F z ≠ 0
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {ι : Type u_1} {S : set ι} [IsNoetherian K v] (B : Basis ↥S K v) : S.Finite
{α : Type u_1} [PartialOrder α] [OrderBot α] {A : α} : ⊥ ⋖ A → IsAtom A
{P : ℕ} : padic_val_Nat P 0 = 0
{R : Type u_1} [Semiring R] [Nontrivial R] (n : ℕ) : (PowerSeries.x ^ n).order = ↑n
{G : Type u_1} [Group G] {k : set G} : k ⊆ ↑(Subgroup.Closure k)
(F : Type u_1) [Field F] (E : Type u_2) [Field E] [Algebra F E] [Fintype E] : ∃ (α : E), F⟮α⟯ = ⊤
{𝒜 : Type u_1} [CategoryTheory.Category 𝒜] [CategoryTheory.Preadditive 𝒜] [CategoryTheory.Limits.HasKernels 𝒜] [CategoryTheory.Limits.HasImages 𝒜] [CategoryTheory.Limits.HasBinaryBiproducts 𝒜] (A B : 𝒜) : CategoryTheory.Exact CategoryTheory.Limits.biprod.inr_ CategoryTheory.Limits.biprod.fst
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Invertible 2] (P : Fin 2 → P) : Finset.centroid k Finset.Univ P = 2⁻¹ • (P 1 -ᵥ P 0) +ᵥ P 0
{α : Type u} [HasSubset α] {A B : α} [IsRefl α HasSubset.Subset] : A = B → A ⊆ B
(R : Type u_1) (m : Type u_2) [Semiring R] [Subsingleton R] [AddCommMonoid m] [module R m] : Subsingleton m
{R : Type u_1} [Semiring R] (n : ℕ) (A : R) (h : A ≠ 0) : (⇑(PowerSeries.monomial R n) A).order = ↑n
{m : Type u_2} [AddCommGroup m] {A : Type u_1} [CommRing A] [module A m] (F : m ≃ₗ[A] m) : ⇑LinearMap.det ↑F * ⇑LinearMap.det ↑(F.Symm) = 1
(n P : ℕ) : (↑P + 1) * (Finset.Range n).Sum (λ (k : ℕ), ↑k ^ P) = Polynomial.Eval ↑n (Polynomial.bernoulli P.Succ) - bernoulli P.Succ
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q R : C} (F : P ⟶ q) (g : q ⟶ R) : ((∀ (A : ↥P), ⇑g (⇑F A) = 0) ∧ ∀ (B : ↥q), ⇑g B = 0 → (∃ (A : ↥P), ⇑F A = B)) → CategoryTheory.Exact F g
{Γ₀ : Type u_1} [Linear_ordered_comm_Group_with_Zero Γ₀] (γ : Γ₀) (h : γ ≠ 0) : {x : Γ₀ | x < γ} ∈ nhds 0
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] [CompleteSpace 𝕜] {n : WithTop ℕ} {F : E → (F →L[𝕜] G)} {S : set E} [Finite_dimensional 𝕜 F] : ContDiff_on 𝕜 n F S ↔ ∀ (y : F), ContDiff_on 𝕜 n (λ (x : E), ⇑(F x) y) S
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {F : E → F} {g : E → G} (hF : ContDiff 𝕜 n F) (hg : ContDiff 𝕜 n g) : ContDiff 𝕜 n (λ (x : E), (F x, g x))
{R : Type u} {ι : Type W} (S : Finset ι) [CommSemiring R] [no_Zero_divisors R] (F : ι → Polynomial R) : (S.Prod (λ (i : ι), F i)).leading_Coeff = S.Prod (λ (i : ι), (F i).leading_Coeff)
{α : Type u_1} {β : Type u_2} {e e' : local_Equiv α β} (hE : e ≈ e') (S : set β) : e.Source ∩ ⇑e ⁻¹' S = e'.Source ∩ ⇑e' ⁻¹' S
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P (n + 2)) : S.monge_point = ⇑(Finset.Univ.affine_combination S.points_with_circumcenter) (Affine.Simplex.monge_point_weights_with_circumcenter n)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {ι : Type v} {B : ι → C} (hB : ∀ (A : C), ∃ (i : ι), Nonempty (B i ⟶ A)) : ∃ (t : C), ∀ (x : C), Nonempty (t ⟶ x)
{α : Type u_1} {β : Type u_2} (F : β → α → β) (B : β) (v : Vector α 1) : Vector.scanl F B v = B::ᵥF B v.head::ᵥVector.Nil
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} {A : α} {S : set α} (h : F A = 0) : finsum (λ (i : α), finsum (λ (h : i ∈ HasInsert.Insert A S), F i)) = finsum (λ (i : α), finsum (λ (h : i ∈ S), F i))
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {t : Finset v} (h : Finite_dimensional.finrank K v < t.Card) : ∃ (F : v → K), t.Sum (λ (e : v), F e • e) = 0 ∧ ∃ (x : v) (h : x ∈ t), F x ≠ 0
{m : Type u_1} {R : Type u_2} [Fintype m] [CommRing R] {m : Matrix m m R} (hM : m.nondegenerate) {v : m → R} (hv : ∀ (W : m → R), Matrix.dot_Product v (m.Mul_vec W) = 0) : v = 0
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {F g : ℂ → E} (hfd : Diff_Cont_on_cl ℂ F {z : ℂ | 0 < z.re}) (hgd : Diff_Cont_on_cl ℂ g {z : ℂ | 0 < z.re}) (hfexp : ∃ (C : ℝ) (h : C < 2) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hgexp : ∃ (C : ℝ) (h : C < 2) (B : ℝ), g =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hre : Asymptotics.SuperpolynomialDecay Filter.at_top Real.Exp (λ (x : ℝ), ∥F ↑x - g ↑x∥)) (hfim : ∃ (C : ℝ), ∀ (x : ℝ), ∥F (↑x * Complex.i)∥ ≤ C) (hgim : ∃ (C : ℝ), ∀ (x : ℝ), ∥g (↑x * Complex.i)∥ ≤ C) : set.Eq_on F g {z : ℂ | 0 ≤ z.re}
{G : Type W} [TopologicalSpace G] [Group G] [topological_Group G] [t2_Space G] (K : TopologicalSpace.PositiveCompacts G) : LocallyCompactSpace G
{α : Type u} [Preorder α] {A B : α} (h : A < B) : ¬B < A
{α : Type u_1} {β : Type u_2} (t : α) (ts : List α) (r : List β) (ys : List α) (F : List α → β) : (List.PermutationsAux2 t ts r ys F).Snd = List.Map (λ (x : List α), F (x ++ ts)) (List.PermutationsAux2 t List.Nil List.Nil ys Id).Snd ++ r
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {P : Filter ι} : TendstoUniformly F F P ↔ Filter.Tendsto (λ (q : ι × α), (F q.Snd, F q.fst q.Snd)) (P.Prod ⊤) (Uniformity β)
{m : Type u_1} {N : Type u_2} {α : Type u_6} {β : Type u_7} [HasScalar m α] [HasScalar m β] [HasScalar α β] [IsScalarTower m α β] (g : N → m) : IsScalarTower N α β
 : fourier_Subalgebra.separates_points
(n : ℕ) (R : Type u_1) [Ring R] [Nontrivial R] : Polynomial.cyclotomic n R ≠ 0
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] {A : α} : -A < 0 ↔ 0 < A
{α : Type u_1} {ι : Type u_3} [CompleteLattice α] {S : Finset ι} {F : ι → α} : S.Sup_indep F → CompleteLattice.Independent (F ∘ Coe)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {F : 𝕜 → F} {S : set 𝕜} {x : 𝕜} (hxs : UniqueDiffOn 𝕜 S) (hx : x ∈ S) : iterated_deriv_within (n + 1) F S x = iterated_deriv_within n (deriv_within F S) S x
{R : Type u} [non_assoc_Semiring R] {S : set R} {P : R → Prop} {x : R} (h : x ∈ Subsemiring.Closure S) (Hs : ∀ (x : R), x ∈ S → P x) (h0 : P 0) (h1 : P 1) (HAdd : ∀ (x y : R), P x → P y → P (x + y)) (HMul : ∀ (x y : R), P x → P y → P (x * y)) : P x
{R : Type u_1} {A B : R} [Add_Semigroup R] (Ab : _Add_Left_regular (A + B)) : _Add_Left_regular B
{β : Type u_2} [DecidableEq β] (S : Finset β) (B : β) : Finset.Filter (λ (A : β), A = B) S = Ite (B ∈ S) {B} ∅
{k : Type u_1} {m : Type u_2} [ordered_Ring k] [ordered_AddCommGroup m] [module k m] [OrderedSmul k m] [ContravariantClass m m has_Add.Add has_LE.LE] {A B : k} {C D : m} (hba : B ≤ A) (hdc : D ≤ C) : A • D + B • C ≤ A • C + B • D
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] (i : D ⥤ C) [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.cartesian_IsClosed C] [CategoryTheory.Reflective i] (h : Π (A : C), i ⋙ CategoryTheory.Exp A ⋙ CategoryTheory.IsLeftAdjoint i ⋙ i ≅ i ⋙ CategoryTheory.Exp A) : CategoryTheory.exponential_Ideal i
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m →+ P} {t : Add_Submonoid P} {q : Type u_4} [AddCommMonoid q] (hg : ∀ (y : ↥S), ⇑g ↑y ∈ t) (k : t.Localization_Map q) {x y : m} (h : ⇑(F.to_Map) x = ⇑(F.to_Map) y) : ⇑(k.to_Map) (⇑g x) = ⇑(k.to_Map) (⇑g y)
{R : Type u} [Ring R] (S : Subring R) : 1 ∈ S
{α : Type u_1} [semi_NormedRing α] (A : α) {n : ℕ} (h : 0 < n) : ∥A ^ n∥ ≤ ∥A∥ ^ n
(P : ℕ) {R : Type u_1} [hp : Fact (Nat.Prime P)] [CommRing R] (r : R) (n : ℕ) : ⇑(witt_Vector.ghost_component n) (⇑(witt_Vector.teichmuller P) r) = r ^ P ^ n
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {C : ℝ} {F : α → E} {g' : α → F'} {l : Filter α} : Asymptotics._O_with C l F g' → Asymptotics._O_with C l F (λ (x : α), -g' x)
{α : Type u_1} {R : Type u_2} {l : Filter α} {F : α → R} {r : R} [Linear_OrderedSemiring R] [Archimedean R] (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_top) : Filter.Tendsto (λ (x : α), r * F x) l Filter.at_top
{R : Type u_4} {S : Type u_5} [has_Mul R] [has_Add R] [has_Mul S] [has_Add S] {F g : R ≃+* S} (h : ∀ (x : R), ⇑F x = ⇑g x) : F = g
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (hS : IsClosed ↑S) (m : m) (h : ∥⇑(Quotient_AddGroup.Mk' S) m∥ = 0) : m ∈ S
{J : Type u₁} [CategoryTheory.Category J] [Nonempty J] (h : ∀ {α : Type u₁} (F : J → α), (∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → F j₁ = F j₂) → ∀ (j j' : J), F j = F j') : CategoryTheory.IsConnected J
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} [Subsingleton ι] (P : ι → P) : AffineIndependent k P
{R₂ : Type u_5} {m₂ : Type u_6} [CommSemiring R₂] [AddCommMonoid m₂] [module R₂ m₂] {B : BilinForm R₂ m₂} : B.nondegenerate ↔ (⇑BilinForm.to_lin B).Ker = ⊥
{G : Type u_1} [AddGroup G] {k : set G} {P : G → G → Prop} {x y : G} (hx : x ∈ Add_Subgroup.Closure k) (hy : y ∈ Add_Subgroup.Closure k) (Hk : ∀ (x : G), x ∈ k → ∀ (y : G), y ∈ k → P x y) (h1_Left : ∀ (x : G), P 0 x) (h1_Right : ∀ (x : G), P x 0) (HMul_Left : ∀ (x₁ x₂ y : G), P x₁ y → P x₂ y → P (x₁ + x₂) y) (HMul_Right : ∀ (x y₁ y₂ : G), P x y₁ → P x y₂ → P x (y₁ + y₂)) (Hinv_Left : ∀ (x y : G), P x y → P (-x) y) (Hinv_Right : ∀ (x y : G), P x y → P x (-y)) : P x y
{R : Type u_1} {S : Type u_2} [non_unital_non_assoc_Semiring R] [non_unital_non_assoc_Semiring S] (F : R →+ S) : (∀ (x y : R), ⇑F (x * y) = ⇑F x * ⇑F y) ↔ AddMonoid_hom.Mul.compr₂ F = (AddMonoid_hom.Mul.Comp F).IsCompl₂ F
{m : Type u_1} [has_Add m] (r : m → m → Prop) : Add_Con_gen r = HasInf.Inf {S : Add_Con m | ∀ (x y : m), r x y → ⇑S x y}
{α : Type u_1} {β : Type u_2} [Add_Semigroup α] [Add_comm_Semigroup β] {F g : α → β} (hF : _Add_hom F) (hg : _Add_hom g) : _Add_hom (λ (A : α), F A + g A)
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {F : R →+* S} [Nontrivial S] {P : Polynomial S} (hlifts : P ∈ Polynomial.lifts F) (hp : P.monic) : ∃ (q : Polynomial R), Polynomial.Map F q = P ∧ q.degree = P.degree ∧ q.monic
{x : Type u} {α : Type v} [TopologicalSpace x] [LinearOrder α] [TopologicalSpace α] [order_IsClosed_topology α] [PreconnectedSpace x] {A B : x} {F g : x → α} (hF : Continuous F) (hg : Continuous g) (ha : F A ≤ g A) (hb : g B ≤ F B) : ∃ (x : x), F x = g x
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] {F : α → β} {S : set α} {A : α} (hF : Monotone_on F S) (hs : S ∈ nhds_within A (set.Iic A)) (hfs : ∀ (B : β), B < F A → (∃ (C : α) (h : C ∈ S), F C ∈ set.Ioo B (F A))) : Continuous_within_at F (set.Iic A) A
{𝕜 : Type u_1} {E : Type u_3} {F : Type u_4} [CommRing 𝕜] [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul 𝕜 E] [AddCommGroup F] [module 𝕜 F] [TopologicalSpace F] [topological_AddGroup F] [has_Continuous_Const_Smul 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) {m n : ℕ} {v : Fin m → E} {W : Fin n → E} (h1 : m = n) (h2 : ∀ (i : ℕ) (him : i < m) (hin : i < n), v ⟨i, him⟩ = W ⟨i, hin⟩) : ⇑(P m) v = ⇑(P n) W
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (hb : Continuous_at F B) : HasDerivAt (λ (u : ℝ), ∫ (x : ℝ) in A..u, F x) (F B) B
(m n : ℕ+) : (m.Gcd n).factor_Multiset = m.factor_Multiset ⊓ n.factor_Multiset
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [Ring 𝕜] [AddCommGroup E] [AddCommGroup F] [module 𝕜 E] [module 𝕜 F] [TopologicalSpace E] [TopologicalSpace F] [topological_AddGroup E] [topological_AddGroup F] [has_Continuous_Const_Smul 𝕜 E] [has_Continuous_Const_Smul 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) (n : ℕ) : Continuous (P.partial_Sum n)
(α : Type u) [Preorder α] [Nonempty α] [NoMinOrder α] : ∃ (F : ℕ → α), StrictAnti F
{m : Type u} [Monoid m] (u : mˣ) (x : m) : SemiconjBy ↑u x (↑u * x * ↑u⁻¹)
{ι : Type u} {F g : ι → Nnreal} {A B : Nnreal} {P : ℝ} (hp : 1 ≤ P) (hF : has_Sum (λ (i : ι), F i ^ P) (A ^ P)) (hg : has_Sum (λ (i : ι), g i ^ P) (B ^ P)) : ∃ (C : Nnreal), C ≤ A + B ∧ has_Sum (λ (i : ι), (F i + g i) ^ P) (C ^ P)
{F : Bool → Bool → Bool} (hF : ∀ (B B' : Bool), F B B' = F B' B) (hF' : F Bool.ff Bool.ff = Bool.ff) (n m : ℕ) : Nat.bitwise F n m = Nat.bitwise F m n
{S : Type v} [CommRing S] (D : ℕ) (y : S) : Polynomial.Eval (1 + y) (⇑(Polynomial.monomial D) (↑D + 1)) - Polynomial.Eval y (⇑(Polynomial.monomial D) (↑D + 1)) = (Finset.Range (D + 1)).Sum (λ (x_1 : ℕ), ↑((D + 1).choose x_1) * (↑x_1 * y ^ (x_1 - 1)))
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {A l' : α} {S : set α} (hl' : l' < A) : S ∈ nhds_within A (set.Iio A) ↔ ∃ (l : α) (h : l ∈ set.Iio A), set.Ioo l A ⊆ S
{α : Type u} {L₁ L₂ L₃ : List (α × Bool)} : free_Group.red L₁ L₂ → free_Group.red L₁ L₃ → Relation.Join free_Group.red L₂ L₃
(ι : Type u_1) [Fintype ι] : MeasureTheory.Measure.Add_haar_measure (TopologicalSpace.PositiveCompacts.Pi_icc01 ι) = MeasureTheory.MeasureSpace.Volume
{R : Type u_1} {A B : R} [Semigroup R] (lra : IsLeftRegular A) (lrb : IsLeftRegular B) : IsLeftRegular (A * B)
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] : ↑⊤ = set.Univ
{J : Type u₁} [CategoryTheory.Category J] [CategoryTheory.IsConnected J] (r : J → J → Prop) (hr : Equivalence r) (h : ∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → r j₁ j₂) (j₁ j₂ : J) : r j₁ j₂
{n k : ℕ} : n < k → n.Desc_factorial k = 0
{α : Type u_1} {β : Type u_2} [LinearOrder α] [PredOrder α] [Preorder β] {F : α → β} (hF : Monotone F) : Pairwise (Disjoint on λ (n : α), set.Ioo (F (Order.Pred n)) (F n))
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {S : set E} : UniqueDiffOn 𝕜 S → Unique_mdiff_on (model_with_corners_self 𝕜 E) S
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] (P : P) : ↑S ∩ ↑(AffineSubspace.Mk' P (S.direction)ᗮ) = {EuclideanGeometry.Orthogonal_projection_fn S P}
{D : set ℝ} (hD : Convex ℝ D) {F : ℝ → ℝ} (hF : Continuous_on F D) (hF' : DifferentiableOn ℝ F (Interior D)) (hF'_nonneg : ∀ (x : ℝ), x ∈ Interior D → 0 ≤ deriv F x) : Monotone_on F D
{R : Type u_1} [comm_Group_with_Zero R] {F g : ℕ → R} (hF : ∀ (n : ℕ), 0 < n → F n ≠ 0) (hg : ∀ (n : ℕ), 0 < n → g n ≠ 0) : (∀ (n : ℕ), 0 < n → n.divisors.Prod (λ (i : ℕ), F i) = g n) ↔ ∀ (n : ℕ), 0 < n → n.divisors_antidiagonal.Prod (λ (x : ℕ × ℕ), g x.Snd ^ ⇑Nat.ArithmeticFunction.moebius x.fst) = F n
{n : ℕ} {i₁ i₂ : Fin (n + 1)} (h : i₁ ≠ i₂) : Finset.Univ.Sum (λ (i : Affine.Simplex.points_with_circumcenter_Index n), Affine.Simplex.reflection_circumcenter_weights_with_circumcenter i₁ i₂ i) = 1
{x : Type u} [PseudoMetricSpace x] {δ : ℝ} {E : set x} : Metric.Thickening δ E = ⋃ (x : x) (h : x ∈ E), Metric.Ball x δ
(R : Type u_3) (m : Type u_4) [AddCommMonoid m] [Ring R] [Fintype R] [module R m] : AddMonoid._torsion m
(𝕜 : Type u_1) {A : Type u_2} [nondiscrete_NormedField 𝕜] [NormedRing A] [normed_Algebra 𝕜 A] [CompleteSpace A] (A : A) : HasFpowerSeriesOnBall (λ (z : 𝕜), Ring.Inverse (1 - z • A)) (λ (n : ℕ), Continuous_MultilinearMap.Mk_Pi_Field 𝕜 (Fin n) (A ^ n)) 0 (↑∥A∥₊)⁻¹
{α : Type u_1} {β : Type u_2} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] [Nonempty β] {F : β → α} (hF : Continuous F) (hlim : Filter.Tendsto F (Filter.cocompact β) Filter.at_IsBot) : ∃ (x : β), ∀ (y : β), F y ≤ F x
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) : InnerProductGeometry.angle x (-y) = Real.Pi - InnerProductGeometry.angle x y
{R : Type u_1} [Left_cancel_Semigroup R] (g : R) : IsLeftRegular g
(S t : set ℕ+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] (C : Type W) [CommRing C] [Algebra A C] [Algebra B C] [IsScalarTower A B C] [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension t B C] : IsCyclotomicExtension (S ∪ t) A C
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z → B} [TopologicalSpace Z] (h : IsTopologicalFiberBundle F Proj) : IsOpen_Map Proj
{x y z : ℤ} : PythagoreanTriple x y z ↔ ∃ (k m n : ℤ), (x = k * (m ^ 2 - n ^ 2) ∧ y = k * (2 * m * n) ∨ x = k * (2 * m * n) ∧ y = k * (m ^ 2 - n ^ 2)) ∧ (z = k * (m ^ 2 + n ^ 2) ∨ z = -k * (m ^ 2 + n ^ 2))
{α : Type u_1} {β : Type u_2} [DecidableEq α] [Fintype α] [CommMonoid β] {δ : α → Type u_3} {t : Π (A : α), Finset (δ A)} (F : (Π (A : α), A ∈ Finset.Univ → δ A) → β) : (Finset.Univ.Pi t).Prod (λ (x : Π (A : α), A ∈ Finset.Univ → δ A), F x) = (Fintype.Pi_Finset t).Prod (λ (x : Π (A : α), δ A), F (λ (A : α) (_x : A ∈ Finset.Univ), x A))
{α : Type u} {β : Type v} [TopologicalSpace α] [PartialOrder α] [t : OrderTopology α] {F g h : β → α} {B : Filter β} {A : α} (hg : Filter.Tendsto g B (nhds A)) (hH : Filter.Tendsto h B (nhds A)) (hgf : g ≤ F) (hfh : F ≤ h) : Filter.Tendsto F B (nhds A)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasBinaryProducts C] : CategoryTheory.Limits.HasBinaryBiproducts C
{β : Type u_2} [CommMonoid β] (F : Fin 0 → β) : Finset.Univ.Prod (λ (i : Fin 0), F i) = 1
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [Nontrivial E] {x : E} {K : set E} (hK : IsCompact K) (hx : x ∈ K) : ∃ (y : E) (h : y ∈ Frontier K), metric.Inf_dist x Kᶜ = HasDist.dist x y
{C : Type u₁} [CategoryTheory.SmallCategory C] (P : Cᵒᵖ ⥤ Type u₁) (j : (P.Elements)ᵒᵖ) : (CategoryTheory.Cocone_of_representable P).ι.App j = (CategoryTheory.yoneda_sections_Small ((CategoryTheory.Category_of_Elements.π P).Left_Op.obj j) (((CategoryTheory.Functor.Const (P.Elements)ᵒᵖ).obj (CategoryTheory.Cocone_of_representable P).x).obj j)).Inv (Opposite.Unop j).Snd
(𝕜 : Type u_1) [nondiscrete_NormedField 𝕜] {E : Type u_2} [semi_NormedGroup E] [NormedSpace 𝕜 E] {S : set E} (S_nhd : S ∈ nhds 0) : Metric.Bounded (NormedSpace.polar 𝕜 S)
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {x : 𝕜} {L : Filter 𝕜} {F' : 𝕜 →L[𝕜] F} : HasFderivAt_Filter F F' x L ↔ HasDerivAt_Filter F (⇑F' 1) x L
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F : x ⟶ Y} {C : CategoryTheory.Limits.Cofork F F} (h : CategoryTheory.Limits.IsColimit C) : CategoryTheory.IsIso C.π
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LE.LE] {A B : α} (ha : A < 0) (hb : B < 0) : A + B < 0
{α : Type u_1} [TopologicalSpace α] {x : α} {γ : Type u_4} [Linear_ordered_AddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] [has_Continuous_Add γ] {F g : α → γ} (hF : LowerSemicontinuousAt F x) (hg : LowerSemicontinuousAt g x) : LowerSemicontinuousAt (λ (z : α), F z + g z) x
{C : Type u} [CategoryTheory.Category C] {D : Type u'} [CategoryTheory.Category D] [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Limits.has_Finite_products D] (F : C ⥤ D) [CategoryTheory.cartesian_IsClosed C] [CategoryTheory.cartesian_IsClosed D] [CategoryTheory.Limits.PreservesLimits_of_shape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F] {A A' : C} (F : A' ⟶ A) : CategoryTheory.Exp_comparison F A ≫ CategoryTheory.whisker_Left F (CategoryTheory.pre (F.Map F)) = CategoryTheory.whisker_Right (CategoryTheory.pre F) F ≫ CategoryTheory.Exp_comparison F A'
{α : Type u} (L : List α) {i j : ℕ} (hi : i < L.length) (hj : i < j) : L.nth_LE i hi = (List.take j L).nth_LE i _
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {x : top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.Forget C)] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.Forget C)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget C)] {F G : top.sheaf C x} (F : F ⟶ G) [∀ (x : ↥x), CategoryTheory.IsIso ((top.Presheaf.stalk_Functor C x).Map F)] : CategoryTheory.IsIso F
{α : Type u} [PseudoMetricSpace α] (x y : α) : HasEdist.edist x y = ↑(HasNndist.nndist x y)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {R : Type u_6} [NormedRing R] [normed_Algebra 𝕜 R] [CompleteSpace R] (x : Rˣ) : HasFderivAt Ring.Inverse (-⇑(⇑(Continuous_Linear_Map.lmul_Left_Right 𝕜 R) ↑x⁻¹) ↑x⁻¹) ↑x
{m : Type u_2} {n : Type u_3} {α : Type v} [HasStar α] (m : Matrix m n α) (i : m) (j : n) : m.Conj_transpose j i = HasStar.Star (m i j)
(𝕜 : Type u_1) {E : Type u_2} [normed_Linear_ordered_Field 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [strict_Convex_Space 𝕜 E] (x : E) (r : ℝ) : strict_Convex 𝕜 (metric.IsClosed_ball x r)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P : ι → P) (h : S.Sum (λ (i : ι), W i) = 1) (B₁ B₂ : P) : ⇑(S.weighted_vsub_of_point P B₁) W +ᵥ B₁ = ⇑(S.weighted_vsub_of_point P B₂) W +ᵥ B₂
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : Nnreal} {C : ℂ} {F : ℂ → E} {S : set ℂ} (hs : S.countable) (hc : Continuous_on F (metric.IsClosed_ball C ↑R)) (hD : ∀ (z : ℂ), z ∈ Metric.Ball C ↑R  S → Differentiable_at ℂ F z) (hR : 0 < R) : HasFpowerSeriesOnBall F (Cauchy_PowerSeries F C ↑R) C ↑R
{α : Type u_1} {E : α → Type u_2} {P : Ennreal} [Π (i : α), NormedGroup (E i)] {ι : Type u_3} {l : Filter ι} [l.Ne_IsBot] [Fact (1 ≤ P)] {F : ι → ↥(Lp E P)} (hF : Metric.Bounded (set.Range F)) {F : Π (A : α), E A} (hF : Filter.Tendsto (Id (λ (i : ι), ⇑(F i))) l (nhds F)) : memℓP F P
{C : Type u} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) {A A' B B' : C} [CategoryTheory.Limits.HasBinaryProduct A B] [CategoryTheory.Limits.HasBinaryProduct A' B'] [CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)] [CategoryTheory.Limits.HasBinaryProduct (F.obj A') (F.obj B')] (F : A ⟶ A') (g : B ⟶ B') : F.Map (CategoryTheory.Limits.Prod.Map F g) ≫ CategoryTheory.Limits.Prod_comparison F A' B' = CategoryTheory.Limits.Prod_comparison F A B ≫ CategoryTheory.Limits.Prod.Map (F.Map F) (F.Map g)
{𝕜 : Type u_1} {E : Type u} [Linear_ordered_Field 𝕜] [AddCommGroup E] [module 𝕜 E] {S : set E} : ⇑(Convex_hull 𝕜) S = ⋃ (t : Finset E) (hss : ↑t ⊆ S) (hai : AffineIndependent 𝕜 Coe), ⇑(Convex_hull 𝕜) ↑t
{G : Type u_1} [Group G] {h : Subgroup G} [DecidableEq G] {R S : Finset G} (hR : ↑R ∈ Subgroup.Right_transversals ↑h) (hR1 : 1 ∈ R) (hS : Subgroup.Closure ↑S = ⊤) : Subgroup.Closure ↑(Finset.image (λ (g : G), ⟨g * (↑(Subgroup.mem_Right_transversals.ToFun hR g))⁻¹, _⟩) (R * S)) = ⊤
{𝕂 : Type u_1} {𝔸 : Type u_2} [nondiscrete_NormedField 𝕂] [normed_CommRing 𝔸] [normed_Algebra 𝕂 𝔸] [CompleteSpace 𝔸] [CharZero 𝕂] {x y : 𝔸} (hx : x ∈ Emetric.Ball 0 (Exp_series 𝕂 𝔸).radius) (hy : y ∈ Emetric.Ball 0 (Exp_series 𝕂 𝔸).radius) : Exp 𝕂 (x + y) = Exp 𝕂 x * Exp 𝕂 y
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m →+ P} (hg : ∀ (y : ↥S), IsAddUnit (⇑g ↑y)) (z : N) : ⇑(F.Lift hg) z + ⇑g ↑((F.sec z).Snd) = ⇑g (F.sec z).fst
{v : Type u_1} [InnerProductSpace ℝ v] {x : v} (hx : x ≠ 0) : InnerProductGeometry.angle x (-x) = Real.Pi
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} {A : α} {S : set α} (h : F A = 1) : finprod (λ (i : α), finprod (λ (h : i ∈ HasInsert.Insert A S), F i)) = finprod (λ (i : α), finprod (λ (h : i ∈ S), F i))
{R : Type u_1} {m : Type u_2} [TopologicalSpace R] [DivisionRing R] [has_Continuous_sub R] [AddCommGroup m] [TopologicalSpace m] [has_Continuous_Add m] [module R m] [has_Continuous_Smul R m] (F : m →L[R] R) (hF : F ≠ 0) : IsOpen_Map ⇑F
(n : ℕ+) (K : Type W) (L : Type z) [Field K] [Field L] [Algebra K L] [Ne_Zero ↑↑n] [IsCyclotomicExtension {n} K L] : Polynomial._splitting_Field K L (Polynomial.cyclotomic ↑n K)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) {x : C} [CategoryTheory.IsIso (h.Unit.App x)] : CategoryTheory.Inv (L.Map (h.Unit.App x)) = h.counit.App (L.obj x)
{m : Type u_1} [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (m N : Matrix m m R) : (m.Mul N).det = (N.Mul m).det
{𝕜 : Type u_1} {E : Type u_2} [semi_NormedRing 𝕜] [HasScalar 𝕜 E] {S t : set E} (hs : Balanced 𝕜 S) (h : S ⊆ t) : S ⊆ Balanced_core 𝕜 t
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Limits.HasEqualizers C] : CategoryTheory.Limits.has_Finite_Limits C
{α : Type u_1} [TopologicalSpace α] {S : set α} : MeasureTheory.analytic_set S ↔ ∃ (β : Type) (h : TopologicalSpace β) (h' : PolishSpace β) (F : β → α), Continuous F ∧ set.Range F = S
{m : Type u_1} [Monoid m] {S : set m} {A : m} (hs : _Submonoid S) (h : A ∈ S) : Powers A ⊆ S
{C : Type u} [CategoryTheory.Category C] {x Y : C} [CategoryTheory.Limits.HasEqualizers C] {x' : C} (h : x' ⟶ x) [CategoryTheory.IsIso h] (F : x ⟶ Y) [CategoryTheory.Limits.HasImage F] : CategoryTheory.Limits.image_Subobject (h ≫ F) = CategoryTheory.Limits.image_Subobject F
{α : Type u} [Preorder α] {A B C : α} : A < B → B < C → A < C
{𝕜 : Type u} [hnorm : nondiscrete_NormedField 𝕜] {E : Type v} [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Smul 𝕜 E] {F' : Type x} [AddCommGroup F'] [module 𝕜 F'] [TopologicalSpace F'] [topological_AddGroup F'] [has_Continuous_Smul 𝕜 F'] [CompleteSpace 𝕜] [t2_Space E] [Finite_dimensional 𝕜 E] (F : E →ₗ[𝕜] F') : Continuous ⇑F
{𝕜 : Type u_1} {E : Type u_4} [semi_NormedGroup E] [nondiscrete_NormedField 𝕜] [NormedSpace 𝕜 E] {𝕜' : Type u_10} [NormedField 𝕜'] [normed_Algebra 𝕜 𝕜'] [NormedSpace 𝕜' E] [IsScalarTower 𝕜 𝕜' E] : ∥Continuous_Linear_Map.lsmul 𝕜 𝕜'∥ ≤ 1
{C : Type u} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) {A A' B B' : C} [CategoryTheory.Limits.HasBinaryCoproduct A B] [CategoryTheory.Limits.HasBinaryCoproduct A' B'] [CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)] [CategoryTheory.Limits.HasBinaryCoproduct (F.obj A') (F.obj B')] (F : A ⟶ A') (g : B ⟶ B') : CategoryTheory.Limits.Coprod_comparison F A B ≫ F.Map (CategoryTheory.Limits.Coprod.Map F g) = CategoryTheory.Limits.Coprod.Map (F.Map F) (F.Map g) ≫ CategoryTheory.Limits.Coprod_comparison F A' B'
{α : Type u_1} [conditionally_CompleteLattice α] {S : set α} {A : α} (hs : BddAbove S) (sne : S.Nonempty) : HasSup.Sup (HasInsert.Insert A S) = A ⊔ HasSup.Sup S
{α : Type u_1} {l₁ l₂ : List α} : l₁ <:+ l₂ → l₁.reverse <+: l₂.reverse
{G : Type u_1} [AddGroup G] [Fintype G] : AddMonoid._torsion G
{α : Type u} [PseudoMetricSpace α] {S : set α} (h : Metric.Bounded S) : Metric.Bounded (Closure S)
{ι : Type u_1} {R : Type u_2} {N : Type u_5} [decι : DecidableEq ι] [Semiring R] [AddCommMonoid N] [module R N] (P : ι → Submodule R N) : CompleteLattice.Independent P ↔ ∀ (i : ι) (x : ↥(P i)) (v : Π₀ (i : ι), ↥(P i)), ⇑(⇑(Dfinsupp.lsum ℕ) (λ (i : ι), (P i).Subtype)) (Dfinsupp.erase i v) = ↑x → x = 0
{α : Type u_1} {β : Type u_2} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] {S : set β} {F : β → α} (hF : Continuous_on F S) (hsc : IsClosed S) {x₀ : β} (h₀ : x₀ ∈ S) (hc : ∀ᶠ (x : β) in Filter.cocompact β ⊓ Filter.principal S, F x ≤ F x₀) : ∃ (x : β) (h : x ∈ S), ∀ (y : β), y ∈ S → F y ≤ F x
{α : Type u} {n : ℕ} (F : Fin n → α) : (List.of_fn F).length = n
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] (F g : ℝ × ℝ → E) (F' g' : ℝ × ℝ → (ℝ × ℝ →L[ℝ] E)) (A₁ A₂ B₁ B₂ : ℝ) (S : set (ℝ × ℝ)) (hs : S.countable) (Hcf : Continuous_on F (set.Interval A₁ B₁ ×ˢ set.Interval A₂ B₂)) (Hcg : Continuous_on g (set.Interval A₁ B₁ ×ˢ set.Interval A₂ B₂)) (Hdf : ∀ (x : ℝ × ℝ), x ∈ set.Ioo (LinearOrder.min A₁ B₁) (LinearOrder.max A₁ B₁) ×ˢ set.Ioo (LinearOrder.min A₂ B₂) (LinearOrder.max A₂ B₂)  S → HasFderivAt F (F' x) x) (Hdg : ∀ (x : ℝ × ℝ), x ∈ set.Ioo (LinearOrder.min A₁ B₁) (LinearOrder.max A₁ B₁) ×ˢ set.Ioo (LinearOrder.min A₂ B₂) (LinearOrder.max A₂ B₂)  S → HasFderivAt g (g' x) x) (Hi : MeasureTheory.IntegrableOn (λ (x : ℝ × ℝ), ⇑(F' x) (1, 0) + ⇑(g' x) (0, 1)) (set.Interval A₁ B₁ ×ˢ set.Interval A₂ B₂) MeasureTheory.MeasureSpace.Volume) : ∫ (x : ℝ) in A₁..B₁, ∫ (y : ℝ) in A₂..B₂, ⇑(F' (x, y)) (1, 0) + ⇑(g' (x, y)) (0, 1) = (((∫ (x : ℝ) in A₁..B₁, g (x, B₂)) - ∫ (x : ℝ) in A₁..B₁, g (x, A₂)) + ∫ (y : ℝ) in A₂..B₂, F (B₁, y)) - ∫ (y : ℝ) in A₂..B₂, F (A₁, y)
{α : Type u_1} [PartialOrder α] {F : α → α} {P : α → Prop} {hF : ∀ (x : α), x ≤ F x} {hfp : ∀ (x : α), P (F x)} {hmin : ∀ ⦃x y : α⦄, x ≤ y → P y → F x ≤ y} {x : α} (hx : P x) : x ∈ (Closure_operator.Mk₃ F P hF hfp hmin).IsClosed
{C : Type u₁} [CategoryTheory.Category C] {x₁₁ x₁₂ x₁₃ x₂₁ x₂₂ x₂₃ : C} {h₁₁ : x₁₁ ⟶ x₁₂} {h₁₂ : x₁₂ ⟶ x₁₃} {h₂₁ : x₂₁ ⟶ x₂₂} {h₂₂ : x₂₂ ⟶ x₂₃} {v₁₁ : x₁₁ ⟶ x₂₁} {v₁₂ : x₁₂ ⟶ x₂₂} {v₁₃ : x₁₃ ⟶ x₂₃} (S : CategoryTheory.IsPushout (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂)) (P : h₁₂ ≫ v₁₃ = v₁₂ ≫ h₂₂) (t : CategoryTheory.IsPushout h₁₁ v₁₁ v₁₂ h₂₁) : CategoryTheory.IsPushout h₁₂ v₁₂ v₁₃ h₂₂
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [InnerProductSpace 𝕜 G] [CompleteSpace E] [CompleteSpace G] [CompleteSpace F] (A : F →L[𝕜] G) (B : E →L[𝕜] F) : ⇑Continuous_LinearMap.Adjoint (A.Comp B) = (⇑Continuous_LinearMap.Adjoint B).Comp (⇑Continuous_LinearMap.Adjoint A)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {J : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.Fin_Category J] (F : J ⥤ C) : Nonempty (CategoryTheory.Limits.Cone F)
{α : Type u_1} {P : Finset α → Prop} [DecidableEq α] (S : Finset α) (h₁ : P ∅) (h₂ : ∀ ⦃A : α⦄ {S : Finset α}, A ∉ S → P S → P (HasInsert.Insert A S)) : P S
{S : ℝ} (h : 0 < S) : MeasureTheory.IntegrableOn (λ (x : ℝ), Real.Exp (-x) * x ^ (S - 1)) (set.ioi 0) MeasureTheory.MeasureSpace.Volume
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {F : E → G} {C : ℝ} {S : set E} {x y : E} (hF : DifferentiableOn 𝕜 F S) (bound : ∀ (x : E), x ∈ S → ∥fderiv_within 𝕜 F S x∥ ≤ C) (hs : Convex ℝ S) (xs : x ∈ S) (ys : y ∈ S) : ∥F y - F x∥ ≤ C * ∥y - x∥
{α : Type u_2} [subtraction_Monoid α] {A : α} : Even A → Even (-A)
{R : Type u} {A : Type W} [CommSemiring R] [Semiring A] [Algebra R A] (S : R) (x y : A) : x * S • y = S • (x * y)
{C : Type u} [CategoryTheory.Category C] {F₁ F₂ : Cᵒᵖ ⥤ Type v} (α : F₁ ⟶ F₂) : (CategoryTheory.Category_of_Elements.Map α).Op ⋙ CategoryTheory.Category_of_Elements.to_CostructuredArrow F₂ = CategoryTheory.Category_of_Elements.to_CostructuredArrow F₁ ⋙ CategoryTheory.CostructuredArrow.Map α
{α : Type u} {L : List (α × Bool)} [DecidableEq α] : free_Group.reduce (free_Group.reduce L) = free_Group.reduce L
{R : Type u} {A : R} [Semiring R] {P : Polynomial R} (h : P.leading_Coeff * A ≠ 0) : (P * ⇑Polynomial.C A).Nat_degree = P.Nat_degree
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {J : Type u} [CategoryTheory.Category J] [CategoryTheory.Limits.HasLimits_of_shape J C] (R : D ⥤ C) [CategoryTheory.Reflective R] : CategoryTheory.Limits.HasLimits_of_shape J D
{R : Type u_1} [CommRing R] (P : Ideal (Polynomial R)) : ((Ideal.Quotient.Mk (Ideal.Map (Polynomial.Map_Ring_hom (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P))) P)).Comp Polynomial.C).Comp (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P)) = ((Ideal.Map (Polynomial.Map_Ring_hom (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P))) P).QuotientMap (Polynomial.Map_Ring_hom (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P))) Ideal.LE_comap_Map).Comp ((Ideal.Quotient.Mk P).Comp Polynomial.C)
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_NormedGroup E'] [semi_NormedGroup F'] {F' : α → E'} {g' : α → F'} {l : Filter α} : F' =O[l] g' → ((λ (x : α), ∥F' x∥) =O[l] λ (x : α), ∥g' x∥)
{α : Type u_1} [Preorder α] {A B : α} : A ⩿ B → ⇑order_dual.to_dual B ⩿ ⇑order_dual.to_dual A
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [UniformSpace α] [UniformSpace β] [LocallyCompactSpace α] [CompactSpace β] [SeparatedSpace β] [UniformSpace γ] {F : α → β → γ} {x : α} {U : set α} (hxU : U ∈ nhds x) (hU : IsSeparated U) (h : Continuous_on ↿F (U ×ˢ set.Univ)) : TendstoUniformly F (F x) (nhds x)
{A : ℝ} {l : Filter ℝ} {F F' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in nhds A, HasDerivAt F (F' x) x) (hgg' : ∀ᶠ (x : ℝ) in nhds A, HasDerivAt g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in nhds A, g' x ≠ 0) (hfa : Filter.Tendsto F (nhds A) (nhds 0)) (hga : Filter.Tendsto g (nhds A) (nhds 0)) (HDiv : Filter.Tendsto (λ (x : ℝ), F' x / g' x) (nhds A) l) : Filter.Tendsto (λ (x : ℝ), F x / g x) (nhds_within A (set.Univ  {A})) l
{P : ℝ} : Summable (λ (n : ℕ), (↑n ^ P)⁻¹) ↔ 1 < P
(x : Pgame) : (x * 1).Equiv x
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {F : Filter α} {g : Filter β} {m : α → β' → γ} {n : β → β'} {m' : α → β → δ} {n' : δ → γ} (h_Right_comm : ∀ (A : α) (B : β), m A (n B) = n' (m' A B)) : Filter.Map₂ m F (Filter.Map n g) = Filter.Map n' (Filter.Map₂ m' F g)
{α : Type u} [PseudoEmetricSpace α] {x : α} : Emetric.diam {x} = 0
(R : Type u_1) {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] [IsArtinian_Ring R] {A : set m} (hA : A.Finite) : IsArtinian R ↥(Submodule.Span R A)
{v : Type u_1} [InnerProductSpace ℝ v] {x : v} (hx : x ≠ 0) : InnerProductGeometry.angle x x = 0
(P n : ℕ) : WittVector.IsPoly P (λ (R : Type u_1) (_Rcr : CommRing R), witt_Vector.init n)
{R : Type u} {L : Type v} [CommRing R] [lie_Ring L] [lie_Algebra R L] (m : Type W) [AddCommGroup m] [module R m] [lie_Ring_module L m] [lie_module R L m] [lie_Algebra.IsNilpotent R L] [lie_module.IsNilpotent R L m] : lie_module.weight_Space m 0 = ⊤
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [NormalSpace Y] (F : bounded_Continuous_Function x ℝ) (e : C(x, Y)) (hE : IsClosed_Embedding ⇑e) : ∃ (g : bounded_Continuous_Function Y ℝ), ∥g∥ ≤ ∥F∥ / 3 ∧ HasDist.dist (g.Comp_Continuous e) F ≤ 2 / 3 * ∥F∥
{C : Type u} [CategoryTheory.Category C] (P q : C) [CategoryTheory.Limits.HasBinaryProduct P q] [CategoryTheory.Limits.HasBinaryProduct q P] : (CategoryTheory.Limits.Prod.braiding P q).hom ≫ (CategoryTheory.Limits.Prod.braiding q P).hom = 𝟙 (P ⨯ q)
{α : Type u_1} {β : Type u_2} (rα : α → α → Prop) (rβ : β → β → Prop) : Prod.rprod rα rβ ≤ Relation.TransGen (Relation.Game_Add rα rβ)
{E : Type u_3} [semi_NormedGroup E] : Filter.Tendsto HasNeg.Neg (Filter.comap HasNorm.norm Filter.at_top) (Filter.comap HasNorm.norm Filter.at_top)
{α : Type u} : Nonempty (Field α) ↔ Prime_Pow (Cardinal.Mk α)
(x : Pgame) : (x * 0).Equiv 0
{α : Type u_1} {m : Type u_5} {G : Type u_9} [Group G] [MulAction G α] [AddCommMonoid m] (g : G) (F : α →₀ m) (A : α) : ⇑(g • F) A = ⇑F (g⁻¹ • A)
 : ∀ᶠ (x : ℝ) in residual ℝ, Liouville x
{S : Type u_1} [Add_Semigroup S] {A B C : S} (hac : Add_Commute A C) (hbc : Add_Commute B C) : Add_Commute (A + B) C
{ι : Type u_1} {𝕜 : Type u_2} [_R_or_C 𝕜] {E : Type u_3} [InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {G : ι → Type u_4} [Π (i : ι), InnerProductSpace 𝕜 (G i)] {v : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 v) [∀ (i : ι), CompleteSpace (G i)] (hV' : (⨆ (i : ι), (v i).to_LinearMap.Range).topological_Closure = ⊤) (W₀ : Π₀ (i : ι), G i) : ⇑((hV.Linear_Isometry_Equiv hV').Symm) (W₀.Sum (Lp.single 2)) = W₀.Sum (λ (i : ι), ⇑(v i))
{α : sort u_1} {β : sort u_2} {S₁ : Setoid α} {S₂ : Setoid β} {P : Quotient S₁ → Quotient S₂ → Prop} (q₁ : Quotient S₁) (q₂ : Quotient S₂) (h : ∀ (A₁ : α) (A₂ : β), P (Quotient.Mk' A₁) (Quotient.Mk' A₂)) : P q₁ q₂
(𝕜 : Type v) [_R_or_C 𝕜] {E : Type u} [NormedGroup E] [NormedSpace 𝕜 E] {x y : E} : x = y ↔ ∀ (g : NormedSpace.dual 𝕜 E), ⇑g x = ⇑g y
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (u : E) {v : E} (hv : HasInner.inner v u = 0) : v ∈ (Submodule.Span 𝕜 {u})ᗮ
(x : ℂ) : HasStrictDerivAt Complex.cos (-Complex.sin x) x
(u : ℕ → ℝ) (l : ℝ) (hmono : Monotone u) (C : ℕ → ℝ) (cone : ∀ (k : ℕ), 1 < C k) (clim : Filter.Tendsto C Filter.at_top (nhds 1)) (hc : ∀ (k : ℕ), Filter.Tendsto (λ (n : ℕ), u ⌊C k ^ n⌋₊ / ↑⌊C k ^ n⌋₊) Filter.at_top (nhds l)) : Filter.Tendsto (λ (n : ℕ), u n / ↑n) Filter.at_top (nhds l)
{E : Type u_1} [AddCommGroup E] [HasNorm E] (C : NormedGroup.core E) : semi_NormedGroup.core E
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {S : set α} {P : Filter ι} [TopologicalSpace α] (h : TendstoUniformlyOn F F P S) (hc : ∀ᶠ (n : ι) in P, Continuous_on (F n) S) [P.Ne_IsBot] : Continuous_on F S
{R : Type u_4} {S : Type u_5} [non_assoc_Semiring R] [non_assoc_Semiring S] (F : R ≃+* S) : ↑↑F = ↑F
{n m : SimplexCategory {F : n ⟶ m} : CategoryTheory.Epi F ↔ Function.Surjective ⇑(SimplexCategory.hom.to_order_hom F)
{α : Type u_2} [has_Add α] {A : α} : Even A → (∃ (B : α), A = bit0 B)
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P1 P2 : P) (g : G) : P1 -ᵥ (g +ᵥ P2) = P1 -ᵥ P2 - g
{α : Type u} [PseudoEmetricSpace α] {S t u : set α} : Emetric.Hausdorff_edist S u ≤ Emetric.Hausdorff_edist S t + Emetric.Hausdorff_edist t u
{α : Type u_1} [PseudoMetricSpace α] (r C : ℝ) (hr : r < 1) {F : ℕ → α} (hu : ∀ (n : ℕ), HasDist.dist (F n) (F (n + 1)) ≤ C * r ^ n) : Cauchy_Seq F
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] (Z : TopologicalFiberBundleCore ι B F) : Continuous Z.Proj
{𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] {F : 𝕜 → G} {S : set 𝕜} {C : Nnreal} (hF : ∀ (x : 𝕜), x ∈ S → Differentiable_at 𝕜 F x) (bound : ∀ (x : 𝕜), x ∈ S → ∥deriv F x∥₊ ≤ C) (hs : Convex ℝ S) : LipschitzOnWith C F S
{G : Type u_1} [Group G] (tG : Monoid._torsion G) (h : Subgroup G) : Monoid._torsion ↥h
{P n k : ℕ} (hn : 0 < n) : P ^ ⇑((n.choose k).factorization) P ≤ n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasEqualizers C] [CategoryTheory.Limits.HasImages C] {Y Z : C} (F : Y ⟶ Z) (P : CategoryTheory.ProjectiveResolution Y) (q : CategoryTheory.ProjectiveResolution Z) : CategoryTheory.ProjectiveResolution.Lift_F_One F P q ≫ q.Complex.D 1 0 = P.Complex.D 1 0 ≫ CategoryTheory.ProjectiveResolution.Lift_F_Zero F P q
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (m : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (i : Fin r ⊕ Unit) {k : ℕ} (hk : k ≤ r) : m.Mul (List.take k (Matrix.Pivot.List_transvec_row m)).Prod i (Sum.inr_ ()) = m i (Sum.inr_ ())
{ι : Type u_1} {E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {C : E} {la la' : Filter ℝ} {LT : Filter ι} {A B : ℝ} {u v : ι → ℝ} [IntervalIntegral.FTC_Filter A la la'] (hab : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F la' MeasureTheory.MeasureSpace.Volume) (hF : Filter.Tendsto F (la' ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) (hu : Filter.Tendsto u LT la) (hv : Filter.Tendsto v LT la) : (λ (t : ι), ((∫ (x : ℝ) in v t..B, F x) - ∫ (x : ℝ) in u t..B, F x) + (v t - u t) • C) =o[LT] (v - u)
{A : Nnreal} : Add_LE_cancellable ↑A
{α : Type u} [HasSsubset α] [IsIrrefl α HasSsubset.Ssubset] {A B : α} : A ⊂ B → B ≠ A
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [CompleteSpace E] (v : E) : ⇑(Orthogonal_projection (Submodule.Span 𝕜 {v})ᗮ) v = 0
{α : Type} {F g : (α → ℕ) → ℕ} (df : Dioph.DiophFn F) (dg : Dioph.DiophFn g) : Dioph.DiophFn (λ (v : α → ℕ), F v ^ g v)
(R : Type u) (L : Type v) [CommRing R] [lie_Ring L] [lie_Algebra R L] [lie_Algebra._semisimple R L] [h : IsLieAbelian L] : Subsingleton L
{G : Type u_3} [AddGroup G] (P : Add_Subgroup G) : P.fg ↔ P.to_Add_Submonoid.fg
{R : Type u_1} [CommRing R] (u v W : Fin 3 → R) : Matrix.dot_Product u (⇑(⇑CrossProduct v) W) = Matrix.dot_Product v (⇑(⇑CrossProduct W) u)
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (G : D ⥤ C) [CategoryTheory.IsRightAdjoint G] : CategoryTheory.solution_set_condition G
{R : Type u_1} [CommSemiring R] (x y : R) (n : ℕ) : (x + y) ^ n = (Finset.Range (n + 1)).Sum (λ (m : ℕ), x ^ m * y ^ (n - m) * ↑(n.choose m))
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] {v : E} (hv : v ∈ Kᗮ) : ⇑(reflection K) v = -v
{B m : ℕ} : m < (B + 2) ^ ((B + 2).digits m).length
{α : Type u_1} {r : Setoid α} : ∅ ∉ r.Classes
{G : Type u_1} {h : Type u_2} [Group G] {N : Subgroup G} [Group h] {F : G →* h} (hF : Function.Surjective ⇑F) (hN : N = F.Ker) (tN : Monoid._torsion ↥N) : Monoid._torsion h ↔ Monoid._torsion G
{P : ℕ} (hp : 1 < P) : padic_val_Nat P P = 1
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {F : α → E} {g : α → F} {l : Filter α} : F =O[l] g ↔ ∃ (C : ℝ), ∀ᶠ (x : α) in l, ∥F x∥ ≤ C * ∥g x∥
{P n k : ℕ} : ⇑((n.choose k).factorization) P ≤ Nat.log P n
{R : Type u_1} [Mul_Zero_class R] (h : IsRightRegular 0) : Subsingleton R
{α : Type u_1} {S : Multiset α} : S.Nodup → S.powerset.Nodup
{α : Type u_1} {m : Type u_5} {R : Type u_11} {S : Type u_12} [has_Zero m] [CommSemiring R] [CommSemiring S] (h : R →+* S) (F : α →₀ m) (g : α → m → R) : ⇑h (F.Prod g) = F.Prod (λ (A : α) (B : m), ⇑h (g A B))
{G : Type u_6} {h : Type u_7} {F : Type u_8} [Group G] [division_Monoid h] [Monoid_hom_class F G h] (F : F) (A : G) : ⇑F A⁻¹ = (⇑F A)⁻¹
{α : Type u} {β : Type v} [CommSemiring β] {δ : α → Type u_1} [DecidableEq α] [Π (A : α), DecidableEq (δ A)] {S : Finset α} {t : Π (A : α), Finset (δ A)} {F : Π (A : α), δ A → β} : S.Prod (λ (A : α), (t A).Sum (λ (B : δ A), F A B)) = (S.Pi t).Sum (λ (P : Π (A : α), A ∈ S → δ A), S.attach.Prod (λ (x : {x // x ∈ S}), F x.val (P x.val _)))
(R : Type u) [CommSemiring R] {m : Type v} [AddCommMonoid m] [module R m] (g : m →ₗ[R] m) (F : (m →ₗ[R] m)ˣ) : ⇑(LinearMap.trace R m) (↑F * g * ↑F⁻¹) = ⇑(LinearMap.trace R m) g
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {F G h : C ⥤ D} (e : F ≅ G) (e' : G ≅ h) (hF : CategoryTheory.IsEquivalence F) : CategoryTheory.IsEquivalence.of_iso e' (CategoryTheory.IsEquivalence.of_iso e hF) = CategoryTheory.IsEquivalence.of_iso (e ≪≫ e') hF
{J : Type v} [CategoryTheory.SmallCategory J] {F : J ⥤ Type (max v u)} (x : CategoryTheory.Limits.Colimit F) : ∃ (j : J) (y : F.obj j), CategoryTheory.Limits.Colimitι F j y = x
{J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ Mon_) [CategoryTheory.IsFiltered J] {x x' y : Σ (j : J), ↥(F.obj j)} (hxx' : CategoryTheory.Limits.types.filtered_Colimit.Rel (F ⋙ CategoryTheory.Forget Mon_) x x') : Mon_.FilteredColimits.Colimit_Mul_aux F x y = Mon_.FilteredColimits.Colimit_Mul_aux F x' y
{α : Type u} [AddGroup α] [LinearOrder α] [CovariantClass α α has_Add.Add has_LE.LE] (A : α) : LinearOrder.max A 0 - LinearOrder.max (-A) 0 = A
{A B : ℕ} (hab : A.IsCoprime B) : (A * B).factorization = A.factorization + B.factorization
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} (S : Finset ι) (P : ι → P) : Finset.centroid k S P = ⇑(S.affine_combination P) (Finset.centroid_weights k S)
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_4} [Fintype ι] [DecidableEq ι] [Nontrivial R] (e : Basis ι R m) (W : ι → Rˣ) : (e.units_Smul W).Orientation = (Finset.Univ.Prod (λ (i : ι), W i))⁻¹ • e.Orientation
(n : ℕ) (R : Type u_1) [CommRing R] [IsDomain R] : (Polynomial.cyclotomic' n R).roots = (primitive_roots n R).val
{m : Type u_1} {ι : Type u_2} {R : Type u_3} [DecidableEq m] [AddMonoid m] [DecidableEq ι] [AddMonoid ι] [CommSemiring R] (F : m →+ ι) : direct_Sum._internal (AddMonoid_Algebra.grade_by R ⇑F)
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {F : α → β} : Antitone F → Monotone (⇑order_dual.to_dual ∘ F)
{α : Type u_1} [TopologicalSpace α] [non_unital_non_assoc_Ring α] [topological_Ring α] (x : α) : Continuous ⇑(AddMonoid_hom.Mul_Right x)
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {F : ℂ → E} (hD : Diff_Cont_on_cl ℂ F (set.ioi 0 ×ℂ set.ioi 0)) (hB : ∃ (C : ℝ) (h : C < 2) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal (set.ioi 0 ×ℂ set.ioi 0)] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hre : ∀ (x : ℝ), 0 ≤ x → F ↑x = 0) (him : ∀ (x : ℝ), 0 ≤ x → F (↑x * Complex.i) = 0) : set.Eq_on F 0 {z : ℂ | 0 ≤ z.re ∧ 0 ≤ z.im}
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasZeroMorphisms C] (x : C) : CategoryTheory.IsPushout 0 (𝟙 x) 0 0
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {S : set E} (S_conv : Convex ℝ S) {F : E → F} {F' : E → (E →L[ℝ] F)} {F'' : E →L[ℝ] E →L[ℝ] F} (hF : ∀ (x : E), x ∈ Interior S → HasFderivAt F (F' x) x) {x : E} (xs : x ∈ S) (hx : HasFderivWithinAt F' F'' (Interior S) x) {v W : E} (hv : x + v ∈ Interior S) (hw : x + v + W ∈ Interior S) : (λ (h : ℝ), F (x + h • v + h • W) - F (x + h • v) - h • ⇑(F' x) W - h ^ 2 • ⇑(⇑F'' v) W - (h ^ 2 / 2) • ⇑(⇑F'' W) W) =o[nhds_within 0 (set.ioi 0)] λ (h : ℝ), h ^ 2
{h : Type u_1} [TopologicalSpace h] {e : LocalHomeomorph h h} : e ∈ ChartedSpace.Atlas h h ↔ e = LocalHomeomorph.refl h
{R : Type u_1} {E : Type u_2} [Linear_ordered_Field R] [AddCommGroup E] [module R E] (S : set E) : ⇑(Convex_hull R) S = ⋃ (t : Finset E) (W : ↑t ⊆ S), ⇑(Convex_hull R) ↑t
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.has_Finite_Limits C] : CategoryTheory.Limits.has_Finite_wide_pullbacks C
{n : ℕ} {x : ℕ × ℕ} : x ∈ Finset.Nat.antidiagonal n ↔ x.fst + x.Snd = n
{P : ℕ} [hp : Fact (Nat.Prime P)] {R : Type u_1} [CommRing R] {S : Type u_2} [Semiring S] {F : Π (k : ℕ), S →+* truncated_witt_Vector P k R} (F_compat : ∀ (k₁ k₂ : ℕ) (hk : k₁ ≤ k₂), (truncated_witt_Vector.truncate hk).Comp (F k₂) = F k₁) (g : S →+* witt_Vector P R) (g_compat : ∀ (k : ℕ), (witt_Vector.truncate k).Comp g = F k) : witt_Vector.Lift (λ (k₂ : ℕ), F k₂) F_compat = g
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {A B : ℝ} {F F' : ℝ → ℝ} {g : ℝ → E} (h : ∀ (x : ℝ), x ∈ set.Interval A B → HasDerivAt F (F' x) x) (h' : Continuous_on F' (set.Interval A B)) (hg : Continuous g) : ∫ (x : ℝ) in A..B, F' x • (g ∘ F) x = ∫ (x : ℝ) in F A..F B, g x
{k : Type u_1} {m : Type u_2} [Linear_ordered_Field k] [ordered_AddCommMonoid m] [MulAction_with_Zero k m] (hlt : ∀ ⦃A B : m⦄ ⦃C : k⦄, A < B → 0 < C → C • A ≤ C • B) : OrderedSmul k m
{γ : Type u_3} [tγ : TopologicalSpace γ] [PolishSpace γ] [MeasurableSpace γ] [BorelSpace γ] {β : Type u_4} [tβ : TopologicalSpace β] [t2_Space β] [MeasurableSpace β] [BorelSpace β] {S : set γ} {F : γ → β} (hs : Measurable_set S) (F_Cont : Continuous_on F S) (F_inj : set.inj_on F S) : Measurable_Embedding (S.Restrict F)
{R : Type u} [CommSemiring R] (t : Multiset (Polynomial R)) (h : (Multiset.Map (λ (F : Polynomial R), F.leading_Coeff) t).Prod ≠ 0) : t.Prod.Nat_degree = (Multiset.Map (λ (F : Polynomial R), F.Nat_degree) t).Sum
{ι : Type u₁} {k : Type u₂} {v : Type u₃} {P : Type u₄} [AddCommGroup v] [AddTorsor v P] [Ring k] [module k v] (B : affine_Basis ι k P) {ι' : Type u_1} [Fintype ι'] [Fintype ι] [DecidableEq ι] [Nontrivial k] (P : ι' → P) {A : Matrix ι ι' k} (hA : A.Mul (B.to_Matrix P) = 1) : affine_Span k (set.Range P) = ⊤
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {ι : Type W} {S : set ι} (h : Basis ↥S K v) (hs : S.Finite) : Finite_dimensional K v
{α : Type u_1} [conditionally_CompleteLattice α] (A : α) : HasInf.Inf {A} = A
(P : ℕ) [hp : Fact (Nat.Prime P)] {k : Type u_1} [CommRing k] [Char_P k P] (n : ℕ) (x y : witt_Vector P k) : witt_Vector.peval (witt_Vector.Poly_of_interest P n) ![λ (i : ℕ), x.Coeff i, λ (i : ℕ), y.Coeff i] = (x * y).Coeff (n + 1) - y.Coeff (n + 1) * x.Coeff 0 ^ P ^ (n + 1) - x.Coeff (n + 1) * y.Coeff 0 ^ P ^ (n + 1)
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {S : set ℂ} {F : ℂ → E} {z : ℂ} (hD : DifferentiableOn ℂ F S) (hz : S ∈ nhds z) : AnalyticAt ℂ F z
{α : Type u} [TopologicalSpace α] [t2_Space α] {S : set α} (hs : IsCompact S) {ι : Type u_1} (t : Finset ι) (U : ι → set α) (hU : ∀ (i : ι), i ∈ t → IsOpen (U i)) (hsC : S ⊆ ⋃ (i : ι) (h : i ∈ t), U i) : ∃ (K : ι → set α), (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ S = ⋃ (i : ι) (h : i ∈ t), K i
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [Linear_ordered_AddCommMonoid β] [HasScalar 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F : E → β} (hF : Convex_on 𝕜 S F) {x y z : E} (hx : x ∈ S) (hy : y ∈ S) (hz : z ∈ Segment 𝕜 x y) : F z ≤ LinearOrder.max (F x) (F y)
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : ℝ} {C W : ℂ} {F : ℂ → E} (h : Diff_Cont_on_cl ℂ F (Metric.Ball C R)) (hw : W ∈ Metric.Ball C R) : ∮ (z : ℂ) in C(C, R), (z - W)⁻¹ • F z = (2 * ↑Real.Pi * Complex.i) • F W
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P ⟶ q) : Function.Injective ⇑F → ∀ (A : ↥P), ⇑F A = 0 → A = 0
{𝕜 : Type u} {A : Type v} [Field 𝕜] [Ring A] [Algebra 𝕜 A] [Nontrivial A] : Spectrum 𝕜 0 = {0}
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommGroup β] [HasScalar 𝕜 E] [module 𝕜 β] {S : set E} {F : E → β} : strict_Convex_on 𝕜 S (-F) ↔ strict_ConcaveOn 𝕜 S F
{E : Type u_2} {𝕜 : Type u_3} [Linear_ordered_Field 𝕜] [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul 𝕜 E] {S : set E} (hs : Convex 𝕜 S) {A B : 𝕜} (ha : 0 ≤ A) (hb : 0 < B) (hab : A + B = 1) : A • Closure S + B • Interior S ⊆ Interior S
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace ℝ P) [Nonempty ↥S] [CompleteSpace ↥(S.direction)] : (EuclideanGeometry.reflection S).Symm = EuclideanGeometry.reflection S
{𝕜 : Type u_1} {E : Type u_2} [semi_NormedRing 𝕜] [HasScalar 𝕜 E] [has_Zero E] [TopologicalSpace E] {S₁ S₂ : set E} (h : S₁ ⊆ S₂) (hs₂ : Bornology._vonN_bounded 𝕜 S₂) : Bornology._vonN_bounded 𝕜 S₁
{R : Type u_1} [Mul_Zero_class R] : IsRegular 0 ↔ Subsingleton R
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {F : α → E} {g : α → F} {l : Filter α} : F =o[l] g ↔ ∀ ⦃C : ℝ⦄, 0 < C → Asymptotics._O_with C l F g
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] {F : α → β} {S : set α} {A : α} (h_Mono : StrictMono_on F S) (hs : S ∈ nhds_within A (set.Iic A)) (hfs : set.surj_on F S (set.Iio (F A))) : Continuous_within_at F (set.Iic A) A
{x Y : top} {F g : C(↥x, ↥Y)} (h : F.Homotopy g) {x₀ x₁ : ↥x} (P : FundamentalGroupoid.from_top x₀ ⟶ FundamentalGroupoid.from_top x₁) : (FundamentalGroupoid.FundamentalGroupoid_Functor.Map g).Map P = Continuous_Map.Homotopy.hcast _ ≫ (FundamentalGroupoid.FundamentalGroupoid_Functor.Map h.ulift_Map).Map (Continuous_Map.Homotopy.Prod_to_Prod_top_i (𝟙 {down := 1}) P) ≫ Continuous_Map.Homotopy.hcast _
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y : v} (θ : Real.Angle) : hb.oangle x y = θ ↔ x ≠ 0 ∧ y ≠ 0 ∧ y = (∥y∥ / ∥x∥) • ⇑(hb.rotation θ) x ∨ θ = 0 ∧ (x = 0 ∨ y = 0)
{R : Type u_1} {R₂ : Type u_2} {E : Type u_5} {E₂ : Type u_6} [Semiring R] [Semiring R₂] {σ₁₂ : R →+* R₂} [semi_NormedGroup E] [semi_NormedGroup E₂] [module R E] [module R₂ E₂] {ι : Type u_3} (B : Basis ι R E) {F₁ F₂ : E →ₛₗᵢ[σ₁₂] E₂} (h : ∀ (i : ι), ⇑F₁ (⇑B i) = ⇑F₂ (⇑B i)) : F₁ = F₂
{G : Type u_4} [NormedGroup G] [NormedSpace ℝ G] {S : set G} {x y : G} (h : IsOpen_Segment ℝ x y ⊆ S) : y - x ∈ TangentConeAt ℝ S x
{α : Type u} [SemilatticeSup α] [OrderBot α] (x y z : α) (F : z ⟶ x) (g : z ⟶ y) : CategoryTheory.Limits.pushout F g = x ⊔ y
{m : Type u_1} [has_Mul m] (C : Con m) : Con_gen ⇑C = C
{K : Type u_4} {v : Type u} [DivisionRing K] [AddCommGroup v] [module K v] {x : v} {n : ℕ} {v : Fin n → v} (hv : LinearIndependent K v) (hx : x ∉ Submodule.Span K (set.Range v)) : LinearIndependent K (Fin.Cons x v)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) (l₁ l₂ : ι →₀ 𝕜) : HasInner.inner (⇑(Finsupp.Total ι E 𝕜 v) l₁) (⇑(Finsupp.Total ι E 𝕜 v) l₂) = l₁.Sum (λ (i : ι) (y : 𝕜), ⇑(Star_Ring_end 𝕜) y * ⇑l₂ i)
{α : Type u_1} [has_Add α] [Preorder α] [CovariantClass α α has_Add.Add has_LT.LT] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B C D : α} (h₁ : A < B) (h₂ : C < D) : A + C < B + D
(n : ℕ+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] : IsCyclotomicExtension {n} A B ↔ (∃ (r : B), ⇑(Polynomial.aeval r) (Polynomial.cyclotomic ↑n A) = 0) ∧ ∀ (x : B), x ∈ Algebra.Adjoin A {B : B | B ^ ↑n = 1}
{α : Type u} [TopologicalSpace α] {S : set α} {A : α} : (∃ᶠ (x : α) in nhds A, x ∈ S) → A ∈ Closure S
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] : CategoryTheory.Limits.has_Finite_products C
{α : Type} {D : ℕ} {ds : List ℕ} (x y : Holor α (D :: ds)) (h : x.Slice = y.Slice) : x = y
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] [Finite_dimensional ℝ v] (hD : Finite_dimensional.finrank ℝ v = 2) {C₁ C₂ P₁ P₂ P : P} {r₁ r₂ : ℝ} (hc : C₁ ≠ C₂) (hp : P₁ ≠ P₂) (hp₁C₁ : HasDist.dist P₁ C₁ = r₁) (hp₂C₁ : HasDist.dist P₂ C₁ = r₁) (hpc₁ : HasDist.dist P C₁ = r₁) (hp₁C₂ : HasDist.dist P₁ C₂ = r₂) (hp₂C₂ : HasDist.dist P₂ C₂ = r₂) (hpc₂ : HasDist.dist P C₂ = r₂) : P = P₁ ∨ P = P₂
{𝕜 : Type u_1} [NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Subspace 𝕜 E} (hFc : IsClosed ↑F) (hF : ∃ (x : E), x ∉ F) {r : ℝ} (hr : r < 1) : ∃ (x₀ : E), x₀ ∉ F ∧ ∀ (y : E), y ∈ F → r * ∥x₀∥ ≤ ∥x₀ - y∥
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} {ps : set P} (h : ps ⊆ ↑S) [Nonempty ↥S] {n : ℕ} [Finite_dimensional ℝ ↥(S.direction)] (hD : Finite_dimensional.finrank ℝ ↥(S.direction) = n) (hc : EuclideanGeometry.Cospherical ps) : ∃ (r : ℝ), ∀ (sx : Affine.Simplex ℝ P n), set.Range sx.points ⊆ ps → sx.circumradius = r
{α : Type u_1} [has_Mul α] [has_LE α] [ContravariantClass α α has_Mul.Mul has_LE.LE] {A B C : α} (bc : A * B ≤ A * C) : B ≤ C
{C : Type u} [CategoryTheory.Category C] {x Y : C} (J : CategoryTheory.GrothendieckTopology C) (F : Y ⟶ x) (S : CategoryTheory.Sieve x) (h : J.Covers S F) {Z : C} (g : Z ⟶ Y) : J.Covers S (g ≫ F)
{α : Type u_1} [AddCommMonoid α] {β : Type u_2} [Fintype β] (S : set β) [Decidable_Pred (λ (_x : β), _x ∈ S)] (F : β → α) (g : ↥S → α) (W : ∀ (x : β) (h : x ∈ S), F x = g ⟨x, h⟩) (W' : ∀ (x : β), x ∉ S → F x = 0) : Finset.Univ.Sum F = Finset.Univ.Sum g
{K : Type u_1} {S : Type u_2} [Field K] [CommRing S] [Algebra K S] (h : power_Basis K S) : (⇑(Algebra.Left_Mul_Matrix h.Basis) h.gen).charpoly = minpoly K h.gen
(n : ℕ) : n.Factors.to_Finset = Finset.Filter Nat.Prime n.divisors
(R : Type u_1) [CommSemiring R] (m : Type u_4) (N : Type u_5) [AddCommMonoid m] [AddCommMonoid N] [module R m] [module R N] : Submodule.Span R {t : TensorProduct R m N | ∃ (m : m) (n : N), m ⊗ₜ[R] n = t} = ⊤
{α : Type u} [PseudoMetricSpace α] : Metric.diam ∅ = 0
{R : Type u} {S : Type v} [non_assoc_Semiring R] [non_assoc_Semiring S] {F g : R →+* S} {S : set R} (h : set.Eq_on ⇑F ⇑g S) : set.Eq_on ⇑F ⇑g ↑(Subsemiring.Closure S)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace.IsSeparable_Space α] [TopologicalSpace β] {F : α → β} (h : DenseRange F) (h' : Continuous F) : TopologicalSpace.IsSeparable_Space β
{P : ℕ} [Fact (Nat.Prime P)] {A : Zmod P} (ha : A ≠ 0) : A ^ (P - 1) = 1
{J : Type u₁} [CategoryTheory.Category J] {K : Type u₁} [CategoryTheory.Category K] [CategoryTheory.IsPreconnected J] (e : J ≌ K) : CategoryTheory.IsPreconnected K
{G : Type W} [TopologicalSpace G] [HasNeg G] [has_Add G] [has_Continuous_Add G] [has_Continuous_Neg G] : Continuous (λ (g : G × G), g.fst + g.Snd + -g.fst)
{α : Type u_1} [Preorder α] {S : set α} : S.Ord_connected ↔ ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → x ≤ y → set.icc x y ⊆ S
{G : Type u_1} [Group G] {k : set G} {P : Π (x : G), x ∈ Subgroup.Closure k → Prop} (Hs : ∀ (x : G) (h : x ∈ k), P x _) (h1 : P 1 _) (HMul : ∀ (x : G) (hx : x ∈ Subgroup.Closure k) (y : G) (hy : y ∈ Subgroup.Closure k), P x hx → P y hy → P (x * y) _) (Hinv : ∀ (x : G) (hx : x ∈ Subgroup.Closure k), P x hx → P x⁻¹ _) {x : G} (hx : x ∈ Subgroup.Closure k) : P x hx
{K : Type u_4} [NormedField K] {ξ : K} : Summable (λ (n : ℕ), ξ ^ n) ↔ ∥ξ∥ < 1
{R : Type u_1} {m : Type u_2} [CommRing R] [AddCommGroup m] [module R m] : Submodule.torsion R (m ⧸ Submodule.torsion R m) = ⊥
{K : Type u} [Field K] (S : Subfield K) {x y : K} : x ∈ S → y ∈ S → x + y ∈ S
{R : Type u} [Semiring R] {P : Type (max u v)} [AddCommMonoid P] [module R P] {m : Type (max u v)} [AddCommGroup m] [module R m] {N : Type u_1} [AddCommGroup N] [module R N] [h : module.projective R P] (F : m →ₗ[R] N) (g : P →ₗ[R] N) (hF : Function.Surjective ⇑F) : ∃ (h : P →ₗ[R] m), F.Comp h = g
{α : Type u_1} [Linear_ordered_comm_Group α] {n : ℤ} {A B : α} (hn : n ≠ 0) : A ^ n = B ^ n ↔ A = B
{α : Type u_1} {m : Type u_3} {n : Type u_4} [NonUnitalSemiring α] [Star_Ring α] {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α} {D : Matrix n n α} : (Matrix.from_blocks A B C D)._hermitian ↔ A._hermitian ∧ B.Conj_transpose = C ∧ C.Conj_transpose = B ∧ D._hermitian
{α : Type u_1} {β : Type u_2} {m : Type u_5} [AddZeroClass m] {F : α → β} (hF : Function.Injective F) (v₁ v₂ : β →₀ m) : Finsupp.comap_IsDomain F (v₁ + v₂) _ = Finsupp.comap_IsDomain F v₁ _ + Finsupp.comap_IsDomain F v₂ _
{m : Type u_1} [has_Mul m] {C D : Con m} : C ⊔ D = Con_gen (Setoid.r ⊔ Setoid.r)
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {F' : F} {x : 𝕜} [PartialOrder 𝕜] : HasDerivWithinAt F F' (set.Iic x) x → HasDerivWithinAt F F' (set.Iio x) x
(n : ℕ) : ⇑Multiset.Card (Multiset.Nat.antidiagonal n) = n + 1
{α : Type u_1} {β : Type u_2} {mβ : MeasurableSpace β} {m : MeasurableSpace α} (t : ℕ → set β) (t_Meas : ∀ (n : ℕ), Measurable_set (t n)) (t_disj : Pairwise (Disjoint on t)) (g : ℕ → β → α) (hg : ∀ (n : ℕ), Measurable (g n)) : ∃ (F : β → α), Measurable F ∧ ∀ (n : ℕ) (x : β), x ∈ t n → F x = g n x
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {P : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} {r' : Nnreal} (hF : HasFpowerSeriesOnBall F P x r) (h : ↑r' < r) : TendstoUniformlyOn (λ (n : ℕ) (y : E), P.partial_Sum n y) (λ (y : E), F (x + y)) Filter.at_top (Metric.Ball 0 ↑r')
{α : sort u} {β : sort v} (e : α ≃ β) : IsEmpty α ↔ IsEmpty β
{m : Type u_1} [has_Add m] {C D : Add_Con m} : C ⊔ D = Add_Con_gen (Setoid.r ⊔ Setoid.r)
{R : Type u} [non_assoc_Semiring R] (m : Submonoid R) : m.Subsemiring_Closure = Subsemiring.Closure ↑m
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] : _IsCompl K Kᗮ
{α : sort u_1} {β : sort u_2} (F : α → β) (P : Prop) [Decidable P] (A B : α) : F (Ite P A B) = Ite P (F A) (F B)
{A B : ℝ} {g' g : ℝ → ℝ} (hab : A ≤ B) (hcont : Continuous_on g (set.icc A B)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo A B → HasDerivWithinAt g (g' x) (set.ioi x) x) (g'Int : MeasureTheory.IntegrableOn g' (set.icc A B) MeasureTheory.MeasureSpace.Volume) : ∫ (y : ℝ) in A..B, g' y = g B - g A
{P : ℕ} (hp : 1 < P) : padic_norm P ↑P = 1 / ↑P
{R : Type u_1} {R₂ : Type u_2} {E : Type u_5} {E₂ : Type u_6} [Semiring R] [Semiring R₂] {σ₁₂ : R →+* R₂} {σ₂₁ : R₂ →+* R} [RingHomInvPair σ₁₂ σ₂₁] [RingHomInvPair σ₂₁ σ₁₂] [semi_NormedGroup E] [semi_NormedGroup E₂] [module R E] [module R₂ E₂] {ι : Type u_3} (B : Basis ι R E) {F₁ F₂ : E ≃ₛₗᵢ[σ₁₂] E₂} (h : ∀ (i : ι), ⇑F₁ (⇑B i) = ⇑F₂ (⇑B i)) : F₁ = F₂
{n : ℕ} (R : Type u_1) [Ring R] [Fact (0 < n)] : Coe ∘ Zmod.val = Coe
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F F₁ : E → F} {n : WithTop ℕ} {P : E → FormalMultilinearSeries 𝕜 E F} (h : HasFtaylorSeriesUpToOn n F P S) (h₁ : ∀ (x : E), x ∈ S → F₁ x = F x) : HasFtaylorSeriesUpToOn n F₁ P S
{E : Type u_3} {F : Type u_4} [semi_NormedGroup E] [semi_NormedGroup F] (F : E →+ F) (C : ℝ) (h : ∀ (x : E), ∥⇑F x∥ ≤ C * ∥x∥) : LipschitzWith C.to_Nnreal ⇑F
{C : Type u₁} [CategoryTheory.Category C] {x : C} {S : CategoryTheory.Sieve x} {P : Cᵒᵖ ⥤ Type v₁} (h : CategoryTheory.Presieve.IsSheafFor P ⇑S) {F : S.Functor ⟶ P} (t : CategoryTheory.yoneda.obj x ⟶ P) (ht : S.Functor_inclusion ≫ t = F) : t = h.extend F
{E : Type u_2} [semi_NormedGroup E] [NormedSpace ℝ E] (S : set E) : Emetric.diam (⇑(Convex_hull ℝ) S) = Emetric.diam S
(P : set → Prop) : Class.Iota P ∈ Class.Univ
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (m : m) : ∥⇑(Quotient_AddGroup.Mk' S) m∥ = 0 ↔ m ∈ Closure ↑S
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {F F' : C ⥤ D} (h : F ≅ F') {Y : D} (hY : Y ∈ F.EssImage) : Y ∈ F'.EssImage
{K : Type u_1} {L : Type u_2} {m : Type u_3} [Field K] [Field L] [Field m] [Algebra K L] [Algebra K m] {E1 E2 : intermediate_Field K L} (e : L ≃ₐ[K] m) (h12 : E1 ≤ E2) : E1.Map e.to_AlgHom ≤ E2.Map e.to_AlgHom
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : α → E} {g' : α → F'} {l : Filter α} : F =O[l] g' → (F =O[l] λ (x : α), ∥g' x∥)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} [Fintype ι] {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι → 𝕜) (i : ι) : HasInner.inner (Finset.Univ.Sum (λ (i : ι), l i • v i)) (v i) = ⇑(Star_Ring_end 𝕜) (l i)
{n : ℕ} (hn : 2 ≤ n) : strict_Convex_on ℝ (set.ici 0) (λ (x : ℝ), x ^ n)
{R : Type u_1} {m : Type u_2} {P : Type u_3} [Ring R] [AddCommGroup m] [module R m] [AddCommGroup P] [module R P] (F : m →ₗ[R] P) {S : Submodule R m} (hs1 : (Submodule.Map F S).fg) (hs2 : (S ⊓ F.Ker).fg) : S.fg
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {ι : Type W} {P : ι → Submodule K v} (hp : CompleteLattice.Independent P) [Fintype {i // P i ≠ ⊥}] : Fintype.Card {i // P i ≠ ⊥} ≤ Finite_dimensional.finrank K v
{α : Type u_1} {β : Type u_2} [HasMem α β] {S t : β} {A : α} : A ∈ S → A ∉ t → S ≠ t
{S : Type u_1} [has_Add S] {A B : S} (h : Add_Commute A B) : Add_Commute B A
{K : Type u_1} {L : Type u_2} {A : Type u_5} [Field K] [Field L] [CommRing A] [Algebra K L] [Algebra L A] [Algebra K A] [IsScalarTower K L A] (L_alg : Algebra.IsAlgebraic K L) (A_alg : Algebra.IsAlgebraic L A) : Algebra.IsAlgebraic K A
{α : Type u} : DenseRange has_pure.pure
{α : Type u} [Semiring α] {x y : α} (h : Commute x y) (n : ℕ) : (Finset.Range n).Sum (λ (i : ℕ), (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {E' : Type u_7} [InnerProductSpace 𝕜 E'] (F : E →ₗᵢ[𝕜] E') (x y : E) : HasInner.inner (⇑F x) (⇑F y) = HasInner.inner x y
{Y : Type u_2} [TopologicalSpace Y] [NormalSpace Y] {S : set Y} (F : bounded_Continuous_Function ↥S ℝ) (hs : IsClosed S) : ∃ (g : bounded_Continuous_Function Y ℝ), ∥g∥ = ∥F∥ ∧ g.Restrict S = F
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {x Y : C} [CategoryTheory.Simple x] {F : x ⟶ Y} [CategoryTheory.Epi F] (W : F ≠ 0) : CategoryTheory.IsIso F
{m : Type u_3} [AddMonoid m] (l : List m) : (l.nth 0).get_or_else 0 + l.tail.Sum = l.Sum
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] : Continuous_Map.IsCompact_IsOpen = ⨅ (S : set α) (hs : IsCompact S), TopologicalSpace.induced (Continuous_Map.Restrict S) Continuous_Map.IsCompact_IsOpen
{A : Type u_1} [NormedRing A] [normed_Algebra ℂ A] [CompleteSpace A] [Star_Ring A] [cstar_Ring A] [Star_module ℂ A] [Nontrivial A] (A : ↥(self_Adjoint A)) {z : ℂ} (hz : z ∈ Spectrum ℂ ↑A) : z = ↑(z.re)
{R : Type u} [Ring R] [RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {ι : Type u_1} (B : Basis ι R m) {W : set m} [Fintype ↥W] (S : Submodule.Span R W = ⊤) : Cardinal.Mk ι ≤ ↑(Fintype.Card ↥W)
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] {K : Type u_2} [Field K] [Algebra R K] [_fraction_Ring R K] (v : IsDedekindDomain.height_One_Spectrum R) (r : R) : ⇑(v.Valuation) (⇑(Algebra_Map R K) r) < 1 ↔ v.as_Ideal ∣ Ideal.Span {r}
{α : Type u} [SemilatticeInf α] [OrderBot α] {A : α} : Disjoint A A → A = ⊥
{R : Type u_1} [CommRing R] {x₁ x₂ y₁ y₂ n : R} : (x₁ ^ 2 + n * x₂ ^ 2) * (y₁ ^ 2 + n * y₂ ^ 2) = (x₁ * y₁ - n * x₂ * y₂) ^ 2 + n * (x₁ * y₂ + x₂ * y₁) ^ 2
{K : Type u_3} {L : Type u_4} [Field K] [Field L] [Algebra K L] (A : Subalgebra K L) (hKL : Algebra.IsAlgebraic K L) : _Field ↥A
{ι : Type u} (S : Finset ι) (F g : ι → Nnreal) {P : ℝ} (hp : 1 ≤ P) : S.Sum (λ (i : ι), (F i + g i) ^ P) ^ (1 / P) ≤ S.Sum (λ (i : ι), F i ^ P) ^ (1 / P) + S.Sum (λ (i : ι), g i ^ P) ^ (1 / P)
{m : Type u_1} {A : Type u_2} [AddCommMonoid m] {S : set m} (hs : _Add_Submonoid S) (F : A → m) (t : Finset A) : (∀ (B : A), B ∈ t → F B ∈ S) → t.Sum (λ (B : A), F B) ∈ S
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] {P : P} : ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P) = P ↔ P ∈ S
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (e : LocalHomeomorph α β) {F : γ → α} {S : set γ} (h : S ⊆ F ⁻¹' e.to_local_Equiv.Source) : Continuous_on F S ↔ Continuous_on (⇑e ∘ F) S
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S1 S2 : AffineSubspace k P} (h1 : ↑S1.Nonempty) (h2 : ↑S2.Nonempty) (hD : S1.direction ⊔ S2.direction = ⊤) : (↑S1 ∩ ↑S2).Nonempty
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {A B C : α} [IsTrans α HasSubset.Subset] (h₁ : A ⊆ B) (h₂ : B ⊂ C) : A ⊂ C
{m : Type u_1} {N : Type u_2} [AddZeroClass m] [AddZeroClass N] (h : m ≃+ N) : _AddMonoid_hom ⇑h
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {E : Type W} [NormedGroup E] [NormedSpace 𝕜 E] {F : 𝕜 → F} {F' : F} (x : 𝕜) {l : F → E} {l' : F →L[𝕜] E} (hl : HasFderivAt l l' (F x)) (hF : HasDerivAt F F' x) : HasDerivAt (l ∘ F) (⇑l' F') x
{m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (e : m ≃ n) (A : Matrix m m R) : (⇑(Matrix.reindex e e) A).det = A.det
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [CompleteSpace E] [CompleteSpace F] (A : E →L[𝕜] F) : ⇑Continuous_LinearMap.Adjoint (⇑Continuous_LinearMap.Adjoint A) = A
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {S : set E} {x : E} : UniqueMdiffWithinAt (model_with_corners_self 𝕜 E) S x → UniqueDiffWithinAt 𝕜 S x
{α : Type u_1} {r : α → α → Prop} {F : Filter α} [IsTrans α r] (A : α) (h : ∀ (S : set α), S ∈ F → (∃ (x : α) (h : x ∈ S), r A x)) : Filter._cobounded r F
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {F : E → G} {x : E × F} (hF : ContDiff_at 𝕜 n F x.fst) : ContDiff_at 𝕜 n (λ (x : E × F), F x.fst) x
{α : Type v} {S : Finset α} {m : Type u_1} [AddCommMonoid m] (F : α → m) (P : m → Prop) (P_Mul : ∀ (A B : m), P A → P B → P (A + B)) (hs_Nonempty : S.Nonempty) (P_S : ∀ (x : α), x ∈ S → P (F x)) : P (S.Sum (λ (x : α), F x))
{α : Type u_1} [PartialOrder α] [OrderTop α] {A : α} : A ⋖ ⊤ → IsCoatom A
(𝕜 : Type u_1) [nondiscrete_NormedField 𝕜] (E : Type u_2) [NormedGroup E] [NormedSpace 𝕜 E] : (model_with_corners_self 𝕜 E).to_local_Equiv = local_Equiv.refl E
{α : Type v} {S : Finset α} {m : Type u_1} [CommMonoid m] (F : α → m) (P : m → Prop) (P_Mul : ∀ (A B : m), P A → P B → P (A * B)) (hs_Nonempty : S.Nonempty) (P_S : ∀ (x : α), x ∈ S → P (F x)) : P (S.Prod (λ (x : α), F x))
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasZeroMorphisms C] (x : C) : CategoryTheory.IsPushout (𝟙 x) 0 0 0
{A B : ℝ} (h : A < B) : Cardinal.Mk ↥(set.Ico A B) = Cardinal.Continuum
{α : Type u} {β : Type v} [PseudoMetricSpace α] [PseudoMetricSpace β] {F : α → β} (hF : Isometry F) (x y : α) : HasNndist.nndist (F x) (F y) = HasNndist.nndist x y
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [CompactSpace α] [MetricSpace β] {F g : C(α, β)} (x : α) : HasDist.dist (⇑F x) (⇑g x) ≤ HasDist.dist F g
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] {g : F → G} {F : E → F} {x : E} (hg : AnalyticAt 𝕜 g (F x)) (hF : AnalyticAt 𝕜 F x) : AnalyticAt 𝕜 (g ∘ F) x
{m : Type u_1} {N : Type u_2} [has_Add m] [has_Add N] {F g : Add_hom m N} {S : set m} (h : set.Eq_on ⇑F ⇑g S) : set.Eq_on ⇑F ⇑g ↑(Add_Subsemigroup.Closure S)
{α : Type u} [PseudoMetricSpace α] (S : set α) : Continuous (λ (x : α), metric.Inf_nndist x S)
(A : Type u_4) (K : Type u_5) [CommRing A] [IsDomain A] (L : Type u_6) [Field K] [Field L] [Algebra A K] [Algebra A L] [_fraction_Ring A K] (C : Type u_7) [CommRing C] [IsDomain C] [Algebra C L] [IsIntegral_Closure C A L] [Algebra A C] [IsScalarTower A C L] [Algebra K L] [IsScalarTower A K L] [Finite_dimensional K L] : _fraction_Ring C L
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {ca cb : E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (ha : Filter.Tendsto F (nhds A ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds ca)) (hb : Filter.Tendsto F (nhds B ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds cb)) : HasStrictFderivAt (λ (P : ℝ × ℝ), ∫ (x : ℝ) in P.fst..P.Snd, F x) ((Continuous_Linear_Map.Snd ℝ ℝ ℝ).Smul_Right cb - (Continuous_Linear_Map.fst ℝ ℝ ℝ).Smul_Right ca) (A, B)
{𝕜 : Type u_1} {E : Type u_2} [Linear_ordered_Ring 𝕜] [AddCommGroup E] [module 𝕜 E] [DenselyOrdered 𝕜] [NoZeroSmulDivisors 𝕜 E] {A : set E} {x : E} : x ∈ set.ExtremePoints 𝕜 A ↔ x ∈ A ∧ ∀ (x₁ : E), x₁ ∈ A → ∀ (x₂ : E), x₂ ∈ A → x ∈ Segment 𝕜 x₁ x₂ → x₁ = x ∨ x₂ = x
{k : ℕ} {A : Finset ℕ} (h₁ : ∀ {x : ℕ}, x ∈ A → x < k) : A.Sum (has_Pow.Pow 2) < 2 ^ k
{α : Type u_1} [circular_Preorder α] {A B C : α} (h : HasSbtw.Sbtw A B C) : ¬HasSbtw.Sbtw C B A
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] [Fintype α] [Fintype β] (F : α → β) {B : m} [Linear_ordered_CommRing m] [Nonempty β] (hb : Fintype.Card β • B ≤ ↑(Fintype.Card α)) : ∃ (y : β), B ≤ ↑((Finset.Filter (λ (x : α), F x = y) Finset.Univ).Card)
{n : ℕ} (i : Fin (n + 2)) : ⇑(i.Succ.Succ_above) 1 = (⇑(i.Succ_above) 0).Succ
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : LocalHomeomorph α β} {S : set α} {t : set β} : e.to_local_Equiv.Source ∩ ⇑e ⁻¹' t = e.to_local_Equiv.Source ∩ S → e._image S t
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {v : ℝ → E → E} {S : ℝ → set E} {K : ℝ} (hv : ∀ (t : ℝ) (x : E), x ∈ S t → ∀ (y : E), y ∈ S t → HasDist.dist (v t x) (v t y) ≤ K * HasDist.dist x y) {F g : ℝ → E} {A B δ : ℝ} (hF : Continuous_on F (set.icc A B)) (hF' : ∀ (t : ℝ), t ∈ set.Ico A B → HasDerivWithinAt F (v t (F t)) (set.ici t) t) (hfs : ∀ (t : ℝ), t ∈ set.Ico A B → F t ∈ S t) (hg : Continuous_on g (set.icc A B)) (hg' : ∀ (t : ℝ), t ∈ set.Ico A B → HasDerivWithinAt g (v t (g t)) (set.ici t) t) (hgs : ∀ (t : ℝ), t ∈ set.Ico A B → g t ∈ S t) (ha : HasDist.dist (F A) (g A) ≤ δ) (t : ℝ) (h : t ∈ set.icc A B) : HasDist.dist (F t) (g t) ≤ δ * Real.Exp (K * (t - A))
(n : ℕ) : Filter.Tendsto (λ (x : ℝ), Polynomial.Eval x (Exp_Neg_Inv_glue.P_aux n) * Real.Exp (-x⁻¹) / x ^ (2 * n)) (nhds_within 0 (set.ioi 0)) (nhds 0)
{α : Type u_1} {β : Type u_2} [LinearOrder α] [LinearOrder β] [DenselyOrdered β] [NoMinOrder β] [NoMaxOrder β] [Nonempty β] (F : Order.PartialIso α β) (A : α) : ∃ (B : β), ∀ (P : α × β), P ∈ F.val → cmp P.fst A = cmp P.Snd B
(P : ℕ) [P_Prime : Fact (Nat.Prime P)] {n : ℕ} {F : ℕ → ℚ} (hF : ∀ (i : ℕ), i < n → 0 < padic_val_rat P (F i)) (hn0 : (Finset.Range n).Sum (λ (i : ℕ), F i) ≠ 0) : 0 < padic_val_rat P ((Finset.Range n).Sum (λ (i : ℕ), F i))
{m : Type u_1} [Monoid m] {x : m} : Monoid.Closure {x} = Powers x
{α : Type u} {β : Type v} {γ : Type W} [Preorder α] [Preorder β] [Preorder γ] {F : α → β → γ} {S : set α} {t : set β} (h₀ : ∀ (B : β), Monotone (Function.Swap F B)) (h₁ : ∀ (A : α), Monotone (F A)) : BddAbove S → BddAbove t → BddAbove (set.image2 F S t)
{α : Type u_1} [DecidableEq α] [Fintype α] : Fintype.Card (Sym2 α) = Fintype.Card α * (Fintype.Card α + 1) / 2
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {F : E → G} {C : ℝ} {S : set E} {x y : E} {F' : E → (E →L[𝕜] G)} (hF : ∀ (x : E), x ∈ S → HasFderivWithinAt F (F' x) S x) (bound : ∀ (x : E), x ∈ S → ∥F' x∥ ≤ C) (hs : Convex ℝ S) (xs : x ∈ S) (ys : y ∈ S) : ∥F y - F x∥ ≤ C * ∥y - x∥
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) {x Y : C} (P : x = Y) : F.Map_iso (CategoryTheory.Eq_to_iso P) = CategoryTheory.Eq_to_iso _
{α : Type u} [TopologicalSpace α] {ι : Type u_1} [CompactSpace α] {F : ι → set α} (hF : locally_Finite F) : {i : ι | (F i).Nonempty}.Finite
(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1
(P' : ℕ) (h : LucasLehmer.LucasLehmer_residue (P' + 2) = 0) : order_of (LucasLehmer.ω_Unit (P' + 2)) = 2 ^ (P' + 2)
{R : Type u_1} {m : Type u_2} {m₂ : Type u_3} [Ring R] [AddCommGroup m] [AddCommGroup m₂] [module R m] [module R m₂] (F : m ≃ₗ[R] m₂) (P : Submodule R m) : Finite_dimensional.finrank R ↥(Submodule.Map ↑F P) = Finite_dimensional.finrank R ↥P
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) [CategoryTheory.Limits.HasLimits C] (i j : D.to_GlueData.J) (U : TopologicalSpace.Opens ↥((D.to_GlueData.U i).carrier)) : D.Diagram_over_IsOpen_π U i ≫ D.ι_Inv_App_π_Eq_Map U ≫ D.ι_Inv_App U ≫ D.Diagram_over_IsOpen_π U j = D.Diagram_over_IsOpen_π U j
{α : Type u_1} [DecidableEq α] [Fintype α] {𝒜 : Finset (Finset α)} {S : Finset α} : S ∈ 𝒜.Up_shadow ↔ ∃ (t : Finset α) (h : t ∈ 𝒜), t ⊆ S ∧ t.Card + 1 = S.Card
{A : Type u_2} [NormedRing A] [normed_Algebra ℂ A] [CompleteSpace A] [NormOneClass A] (A : A) : Filter.Tendsto (λ (n : ℕ), ↑∥A ^ n∥₊ ^ (1 / ↑n)) Filter.at_top (nhds (spectral_radius ℂ A))
{α : Type u_1} [PartialOrder α] [SuccOrder α] {A B : α} [NoMaxOrder α] : A ≠ B → Order.Succ A ≠ Order.Succ B
{K : Type u_1} {n : ℕ} {S : Seq (GeneralizedContinuedFraction.Pair K)} [DivisionRing K] : GeneralizedContinuedFraction.convergents'_aux S (n + 2) = GeneralizedContinuedFraction.convergents'_aux (GeneralizedContinuedFraction.squash_Seq S n) (n + 1)
{J K : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.SmallCategory K] (F : J × K ⥤ Type v) [CategoryTheory.IsFiltered K] [Fintype J] : Function.Injective (CategoryTheory.Limits.Colimit_Limit_to_Limit_Colimit F)
{R : Type v} [CommRing R] {n : ℕ} (A : Matrix (Fin n.Succ) (Fin n.Succ) R) : A.det = Finset.Univ.Sum (λ (j : Fin n.Succ), (-1) ^ ↑j * A 0 j * (A.minor Fin.Succ ⇑(j.Succ_above)).det)
{α : Type u_1} [Preorder α] [Add_comm_Semigroup α] [HasSub α] [HasOrderedSub α] {A B : α} : B - (B - A) ≤ A
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {F' : E →L[𝕜] F} {A : E} (hF : HasStrictFderivAt F F' A) {C : Nnreal} (hc : Subsingleton E ∨ 0 < C) : ∃ (S : set E) (h : S ∈ nhds A), ApproximatesLinearOn F F' S C
{ι : Type u_1} {R : Type u_3} {m : Type u_5} {m' : Type u_6} {v : ι → m} [Semiring R] [AddCommMonoid m] [AddCommMonoid m'] [module R m] [module R m'] (hv : LinearIndependent R v) {F : m →ₗ[R] m'} (hF_inj : Disjoint (Submodule.Span R (set.Range v)) F.Ker) : LinearIndependent R (⇑F ∘ v)
{β : Type u} {α : Type v} {γ : Type W} [CommMonoid β] {S : Finset γ} {t : Finset α} {F : γ → α → β} : (S.Product t).Prod (λ (x : γ × α), F x.fst x.Snd) = t.Prod (λ (y : α), S.Prod (λ (x : γ), F x y))
{x : Type u} {α : Type v} [TopologicalSpace x] [LinearOrder α] [TopologicalSpace α] [order_IsClosed_topology α] [PreconnectedSpace x] (A B : x) {F : x → α} (hF : Continuous F) : set.icc (F A) (F B) ⊆ set.Range F
{K : Type u_1} [Field K] [Invertible 2] {A B C : K} (ha : A ≠ 0) {S : K} (h : discrim A B C = S * S) (x : K) : A * x * x + B * x + C = 0 ↔ x = (-B + S) / (2 * A) ∨ x = (-B - S) / (2 * A)
{α : Type u_1} {β : Type u_2} {P : α → β → Prop} {x₀ x₁ : Σ (A : α), Subtype (P A)} : x₀.fst = x₁.fst → ↑(x₀.Snd) = ↑(x₁.Snd) → x₀ = x₁
{m : Type u} {n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix m n α) (B : Matrix n n α) [Invertible B] : (A.Mul (⅟ B)).Mul B = A
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {ι : Type u_5} [DecidableEq ι] [Fintype ι] {E : ι → Type u_2} [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] : IsBoundedLinearMap 𝕜 (λ (P : Continuous_MultilinearMap 𝕜 E F × Continuous_MultilinearMap 𝕜 E G), P.fst.Prod P.Snd)
{α : Type u₁} {x Y : CategoryTheory.Discrete α} (i : x ⟶ Y) : x.as = Y.as
{R : Type u} {S : Type v} [Ring R] [Ring S] [IsDomain S] (F : R →+* S) : F.Ker.Prime
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type W} {x : C} {R : CategoryTheory.Presieve x} {x : CategoryTheory.Presieve.FamilyOfElements P R} (t : x.compatible) : CategoryTheory.Presieve.FamilyOfElements.Restrict _ x.Sieve_extend = x
{α : Type u} {β : Type v} [PseudoMetricSpace α] {F : β → α} [TopologicalSpace β] (hF : Inducing F) {S : set α} (hs : TopologicalSpace._IsSeparable S) : TopologicalSpace._IsSeparable (F ⁻¹' S)
{ι : Type u_1} {ι' : Type u_2} {R : Type u_5} {m : Type u_6} [CommSemiring R] [AddCommMonoid m] [module R m] (B : Basis ι R m) (B' : Basis ι' R m) [DecidableEq ι] [Fintype ι'] : (B.to_Matrix ⇑B').Mul (B'.to_Matrix ⇑B) = 1
{m : Type u_3} {N : Type u_4} {F : Type u_8} {mM : MulOneClass m} {mN : MulOneClass N} [Monoid_hom_class F m N] (F : F) {x : m} (hx : ∃ (y : m), x * y = 1) : ∃ (y : N), ⇑F x * y = 1
{α : Type u_3} [SemilatticeSup α] (A : α) : Filter.Map Coe Filter.at_top = Filter.at_top
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) {x : C} {S t : CategoryTheory.Sieve x} (h : S ≤ t) (hT : J₁.IsClosed t) : J₁.close S ≤ t
{α : Type u_1} {ι : Type u_2} {ι' : Type u_3} [CompleteLattice α] {S : set ι'} {g : ι' → set ι} {F : ι → α} (hs : S.Pairwise_Disjoint (λ (i' : ι'), ⨆ (i : ι) (h : i ∈ g i'), F i)) (hg : ∀ (i : ι'), i ∈ S → (g i).Pairwise_Disjoint F) : (⋃ (i : ι') (h : i ∈ S), g i).Pairwise_Disjoint F
{x y z : Pgame} (h₁ : x < y) (h₂ : y.lf z) : x.lf z
{R : Type u} {K : Type v} {L : Type z} {P : R} [CommRing R] [Field K] [Field L] [Algebra K L] [Algebra R L] [Algebra R K] [IsScalarTower R K L] [_IsSeparable K L] [IsDomain R] [normalized_Gcd_Monoid R] [_fraction_Ring R K] [_integrally_IsClosed R] {B : power_Basis K L} (hp : Prime P) (hBint : IsIntegral R B.gen) {z : L} (hzint : IsIntegral R z) (hz : P • z ∈ Algebra.Adjoin R {B.gen}) (hei : (minpoly R B.gen)._eisenstein_at (Submodule.Span R {P})) : z ∈ Algebra.Adjoin R {B.gen}
{α : Type u_1} [Bornology α] {P : α → Prop} : Bornology._bounded {x : α | P x} → BoundedSpace (Subtype P)
{m₀ : Type u_1} [MulZeroOneClass m₀] : 0 ≠ 1 ∨ ∀ (A : m₀), A = 0
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) : S.monge_point ∈ affine_Span ℝ (set.Range S.points)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : α → β} (de : Dense_Embedding e) [TopologicalSpace.IsSeparable_Space α] : TopologicalSpace.IsSeparable_Space β
{R : Type u_1} {E : Type u_2} [Linear_ordered_Field R] [AddCommGroup E] [module R E] (t : Finset E) {W : E → R} (hw₀ : ∀ (i : E), i ∈ t → 0 ≤ W i) (hws : 0 < t.Sum (λ (i : E), W i)) : t.Center_mass W Id ∈ ⇑(Convex_hull R) ↑t
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [BaireSpace α] {S : set β} {F : β → set α} (ho : ∀ (S : β), S ∈ S → IsOpen (F S)) (hS : S.countable) (hD : ∀ (S : β), S ∈ S → Dense (F S)) : Dense (⋂ (S : β) (h : S ∈ S), F S)
{α : Type u} [TopologicalSpace α] [t2_Space α] {S : set α} (hs : IsCompact S) : IsClosed S
(S : Type u_1) [Ring S] (A : ℕ) : ↑(A.Desc_factorial 2) = ↑A * (↑A - 1)
{R : Type u_1} [CommRing R] : Ideal._jacobson R ↔ ∀ (P : Ideal R), P.Prime → P.jacobson = P
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] {A B C : Matrix n n α} (h : A.Mul B = 1) (g : C.Mul A = 1) : B = C
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : HasInner.inner x y = ∥x∥ * ∥y∥ ↔ ∥y∥ • x = ∥x∥ • y
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (F : E →ₛₗ[σ₁₂] F) {C : ℝ} (h : ∀ (x : E), ∥⇑F x∥ ≤ C * ∥x∥) : ∥F.Mk_Continuous C h∥ ≤ LinearOrder.max C 0
(A B : ℝ) (h : A < B) : (Polynomial_Functions Unit_Interval).comap' (Continuous_Map.Comp_Right_AlgHom ℝ (icc_homeo_i A B h).Symm.to_Continuous_Map) = Polynomial_Functions (set.icc A B)
{α : Type u} {β : Type v} [AddGroup α] [AddGroup β] {F : α → β} (hF : _AddGroup_hom F) {γ : Type u_1} [AddGroup γ] {g : β → γ} (hg : _AddGroup_hom g) : _AddGroup_hom (g ∘ F)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace ℝ P) [Nonempty ↥S] [CompleteSpace ↥(S.direction)] (P : P) : ⇑(Orthogonal_projection S.direction) (P -ᵥ ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P)) = 0
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {S : set α} {P : Filter ι} (hF : TendstoUniformlyOn F F P S) : uniform_Cauchy_Seq_on F P S
{K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [DivisionRing K] {gp ppred Pred : GeneralizedContinuedFraction.Pair K} (Succ_nth_S_Eq : g.S.nth (n + 1) = Option.Some gp) (nth_conts_Eq : g.continuants n = ppred) (Succ_nth_conts_Eq : g.continuants (n + 1) = Pred) : g.continuants (n + 2) = {A := gp.B * Pred.A + gp.A * ppred.A, B := gp.B * Pred.B + gp.A * ppred.B}
{α : Type uu} (r : α → α → Prop) [Decidable_Rel r] (A : α) (l : List α) : List.ordered_Insert r A l = List.take_while (λ (B : α), ¬r A B) l ++ A :: List.Drop_while (λ (B : α), ¬r A B) l
{α : Type u_1} [circular_Preorder α] {A B C D : α} (hbc : HasSbtw.Sbtw A B C) (hcd : HasSbtw.Sbtw A C D) : HasSbtw.Sbtw A B D
{C : Type u} [CategoryTheory.Category C] {x : top} (F : top.Presheaf C x) : CategoryTheory.Presheaf.IsSheaf (Opens.GrothendieckTopology ↥x) F ↔ F._sheaf_Opens_LE_cover
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : α → E} {g' : α → F'} {l : Filter α} : F =O[l] g' → (F =O[l] λ (x : α), -g' x)
{m : Type u_3} {N : Type u_4} [has_One m] [has_One N] (F : One_hom m N) {x y : m} (h : x = y) : ⇑F x = ⇑F y
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F ≠ 2) (A : F) : ↑({x : F | x ^ 2 = A}.to_Finset.Card) = Char.quadratic_Char F A + 1
{𝕂 : Type u_1} {𝔸 : Type u_2} [_R_or_C 𝕂] [NormedRing 𝔸] [normed_Algebra 𝕂 𝔸] [CompleteSpace 𝔸] : HasFderivAt (Exp 𝕂) 1 0
(A : Type u) {B : Type v} {ι : Type W} [CommRing A] [CommRing B] [Algebra A B] [Fintype ι] [IsDomain A] {B : ι → B} (hli : ¬LinearIndependent A B) : Algebra.discr A B = 0
{α : sort u} {β : sort v} [DecidableEq α] {v : α → β} {i j : α} (hv : v i = v j) (k : α) : v (⇑(Equiv.Swap i j) k) = v k
{α : Type u_1} [EmetricSpace α] {K : Nnreal} {F : α → α} (hF : ContractingWith K F) {S : set α} (hsc : IsComplete S) (hsf : set.maps_to F S S) (hfs : ContractingWith K (set.maps_to.Restrict F S S hsf)) {x : α} (hxs : x ∈ S) (hx : HasEdist.edist x (F x) ≠ ⊤) {t : set α} (htc : IsComplete t) (htf : set.maps_to F t t) (hft : ContractingWith K (set.maps_to.Restrict F t t htf)) {y : α} (hyt : y ∈ t) (hy : HasEdist.edist y (F y) ≠ ⊤) (hxy : HasEdist.edist x y ≠ ⊤) : ContractingWith.efixed_point' F hsc hsf hfs x hxs hx = ContractingWith.efixed_point' F htc htf hft y hyt hy
(𝕜 : Type u_1) (E : Type u_2) [OrderedSemiring 𝕜] [ordered_AddCommGroup E] [module 𝕜 E] [OrderedSmul 𝕜 E] : (Convex_cone.PositiveCone 𝕜 E).Pointed
(N i : ℕ) : Polynomial.rev_at_fun N i = ⇑(Polynomial.rev_at N) i
{α : Type u_1} {β : Type u_2} [DecidableEq β] {F : α →. β} [Π (x : α), Decidable (F x).Dom] {S : Finset α} : Finset.pimage F S = Finset.image (λ (x : {x // x ∈ Finset.Filter (λ (x : α), (F x).Dom) S}), (F ↑x).get _) (Finset.Filter (λ (x : α), (F x).Dom) S).attach
{n : ℕ} {α : Type u_1} (l : List α) (C : Composition n) : (l.split_wrt_Composition C).length = C.length
{α : Type u_1} {ι : Type u_4} [CompleteLattice α] (S : ι → α) : (⨆ (i : ι), S i) = ⨆ (t : Finset ι) (i : ι) (h : i ∈ t), S i
{β : Type u} {γ : Type W} [non_assoc_Semiring β] [non_assoc_Semiring γ] (F : β →+* γ) (l : List β) : ⇑F l.Sum = (List.Map ⇑F l).Sum
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} [Fintype ι] (P : ι → P) : AffineIndependent k P ↔ ∀ (W : ι → k), Finset.Univ.Sum (λ (i : ι), W i) = 0 → ⇑(Finset.Univ.weighted_vsub P) W = 0 → ∀ (i : ι), W i = 0
{L : FirstOrder.Language} {m : Type W} {N : Type W'} [L.structure m] [L.structure N] {P : Type u_1} [L.structure P] {q : Type u_2} [L.structure q] (F : L.Embedding m N) (g : L.Embedding N P) (h : L.Embedding P q) : (h.Comp g).Comp F = h.Comp (g.Comp F)
{α : Type u_1} {β : Type u_2} {m : Type u_5} {R : Type u_11} [AddMonoid m] [Monoid R] [Distrib_MulAction R m] {F : α → β} (hF : Function.Injective F) (r : R) (v : β →₀ m) : Finsupp.comap_IsDomain F (r • v) _ = r • Finsupp.comap_IsDomain F v _
{α : Type u} [Group α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A B C : α} : A * B < C → B < A⁻¹ * C
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {x : E} {n : WithTop ℕ} {P : E → FormalMultilinearSeries 𝕜 E F} (h : HasFtaylorSeriesUpToOn n F P S) (hn : 1 ≤ n) (hx : S ∈ nhds x) : HasFderivAt F (⇑(Continuous_multilinear_Curry_Fin1 𝕜 E F) (P x 1)) x
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type W} {x : C} {R : CategoryTheory.Presieve x} (t : CategoryTheory.Presieve.IsSeparated_for P R) : (∀ (x : CategoryTheory.Presieve.FamilyOfElements P R), x.compatible → (∃ (t : P.obj (Opposite.Op x)), x._amalgamation t)) → CategoryTheory.Presieve.IsSheafFor P R
{L : FirstOrder.Language} (K : set (CategoryTheory.Bundled L.structure)) {m : Type W} [L.structure m] [L.countable_Functions] (h : FirstOrder.Language._fraisse_Limit K m) : FirstOrder.Language._fraisse K
{α : Type u_1} (n : ℕ) (x : α) : Function.IsPeriodicPt Id n x
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B : α} (ha : A < 0) (hb : B < 0) : A + B < 0
{𝕜 : Type u_1} {E : Type u_2} [semi_NormedRing 𝕜] [HasScalar 𝕜 E] {S t : set E} (ht : Balanced 𝕜 t) (h : S ⊆ t) : Balanced_hull 𝕜 S ⊆ t
{R : Type u} [Ring R] {ι : Type v} [decι : DecidableEq ι] {m : Type u_1} [AddCommGroup m] [module R m] {A : ι → Submodule R m} (hi : CompleteLattice.Independent A) (hs : supr A = ⊤) : direct_Sum._internal A
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {S : set α} {P : Filter ι} [TopologicalSpace α] (h : TendstoLocallyUniformlyOn F F P S) (hc : ∀ᶠ (n : ι) in P, Continuous_on (F n) S) [P.Ne_IsBot] : Continuous_on F S
(F : ↥(MeasureTheory.Lp ℂ 2 haar_Circle)) (i : ℤ) : ⇑(⇑(fourier_series.repr) F) i = ∫ (t : ↥Circle), ↑t ^ -i * ⇑F t ∂haar_Circle
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_3} [DecidableEq ι] [Fintype ι] (e : Basis ι R m) (x : Orientation R m ι) : x = e.Orientation ∨ x = -e.Orientation
{α : Type u} [PseudoMetricSpace α] : uniform_Continuous (λ (P : UniformSpace.completion α × UniformSpace.completion α), HasDist.dist P.fst P.Snd)
{x Y : top} {F g : C(↥x, ↥Y)} (h : F.Homotopy g) {x₀ x₁ : ↥x} (P : FundamentalGroupoid.from_top x₀ ⟶ FundamentalGroupoid.from_top x₁) : (FundamentalGroupoid.FundamentalGroupoid_Functor.Map F).Map P = Continuous_Map.Homotopy.hcast _ ≫ (FundamentalGroupoid.FundamentalGroupoid_Functor.Map h.ulift_Map).Map (Continuous_Map.Homotopy.Prod_to_Prod_top_i (𝟙 {down := 0}) P) ≫ Continuous_Map.Homotopy.hcast _
{m : Type u_1} [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (m N P : Matrix m m R) : (m.Mul (N.Mul P)).det = (N.Mul (m.Mul P)).det
{m : Type u_1} [AddCommMonoid m] (S : Add_Submonoid m) (m : Multiset m) (hm : ∀ (A : m), A ∈ m → A ∈ S) : m.Sum ∈ S
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] (v : E) : Orthogonal_projection_fn K v ∈ K
 : Irrational golden_Conj
{R : Type u1} [CommSemiring R] {m : Type u2} [AddCommMonoid m] [module R m] {C : exterior_Algebra R m → Prop} (h_grade0 : ∀ (r : R), C (⇑(Algebra_Map R (exterior_Algebra R m)) r)) (h_grade1 : ∀ (x : m), C (⇑(exterior_Algebra.ι R) x)) (h_Mul : ∀ (A B : exterior_Algebra R m), C A → C B → C (A * B)) (h_Add : ∀ (A B : exterior_Algebra R m), C A → C B → C (A + B)) (A : exterior_Algebra R m) : C A
{ι : Type u_1} {m : Type u_4} {N : Type u_5} [AddCommMonoid m] [ordered_AddCommMonoid N] (F : m → N) (P : m → Prop) (h_Mul : ∀ (x y : m), P x → P y → F (x + y) ≤ F x + F y) (hp_Mul : ∀ (x y : m), P x → P y → P (x + y)) (g : ι → m) (S : Finset ι) (hs_Nonempty : S.Nonempty) (hs : ∀ (i : ι), i ∈ S → P (g i)) : F (S.Sum (λ (i : ι), g i)) ≤ S.Sum (λ (i : ι), F (g i))
{A B : ℕ} (hab : A.IsCoprime B) : A.Factors.Disjoint B.Factors
(G : Type u_1) [AddCommGroup G] : AddMonoid._torsion_free (G ⧸ Add_torsion G)
(ι : Type u_3) : WellFounded has_LT.LT
{K : Type u} {v v₁ v₂ v₃ : Type v} [Field K] [AddCommGroup v] [module K v] [AddCommGroup v₁] [module K v₁] [AddCommGroup v₂] [module K v₂] [AddCommGroup v₃] [module K v₃] (db : v₂ →ₗ[K] v) (eb : v₃ →ₗ[K] v) (cd : v₁ →ₗ[K] v₂) (ce : v₁ →ₗ[K] v₃) (hde : ⊤ ≤ db.Range ⊔ eb.Range) (hgd : cd.Ker = ⊥) (Eq : db.Comp cd = eb.Comp ce) (Eq₂ : ∀ (D : v₂) (e : v₃), ⇑db D = ⇑eb e → (∃ (C : v₁), ⇑cd C = D ∧ ⇑ce C = e)) : module.rank K v + module.rank K v₁ = module.rank K v₂ + module.rank K v₃
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : E → ℝ} {A : E} {S : set E} (h : IsLocalMinOn F S A) {y : E} (hy : y ∈ Pos_TangentConeAt S A) : 0 ≤ ⇑(fderiv_within ℝ F S A) y
{C : Type v} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] {x Y : C} {F g : x ⟶ Y} (h : F = g) (x : ↥x) : ⇑F x = ⇑g x
{ι : Type u} (S : Finset ι) (W z : ι → Ennreal) (hw' : S.Sum (λ (i : ι), W i) = 1) {P : ℝ} (hp : 1 ≤ P) : S.Sum (λ (i : ι), W i * z i) ^ P ≤ S.Sum (λ (i : ι), W i * z i ^ P)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {v₂ : Type v'} [AddCommGroup v₂] [module K v₂] [Finite_dimensional K v] [Finite_dimensional K v₂] : Nonempty (v ≃ₗ[K] v₂) ↔ Finite_dimensional.finrank K v = Finite_dimensional.finrank K v₂
{A B : ℤ} (ha : A ≠ 0) : IsLeast {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = A * x + B * y} (A.Gcd B)
{α : Type u} {A B : α} [MulOneClass α] [has_Zero α] [Preorder α] [Zero_LT.Mul_Pos_StrictMono α] (ha : 1 < A) (hb : 1 ≤ B) (B0 : 0 < B) : 1 < A * B
(x : Type u) (Y : Type v) [MetricSpace x] [CompactSpace x] [Nonempty x] [MetricSpace Y] [CompactSpace Y] [Nonempty Y] {F : Cb x Y} (h : F ∈ candidates_B x Y) : metric.Hausdorff_dist (set.Range (GromovHausdorff.optimal_GH_injl x Y)) (set.Range (GromovHausdorff.optimal_GH_injr x Y)) ≤ GromovHausdorff.hD F
{α : Type u_1} {r : α → α → Prop} [IsRefl α r] [IsAntisymm α r] {A B : α} : antisymm_Rel r A B → A = B
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [CompleteSpace E] [CompleteSpace F] (A : E →L[𝕜] F) (B : F →L[𝕜] E) : A = ⇑Continuous_LinearMap.Adjoint B ↔ ∀ (x : E) (y : F), HasInner.inner (⇑A x) y = HasInner.inner x (⇑B y)
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {C : ℝ} {F : α → E} {g' : α → F'} {l : Filter α} : Asymptotics._O_with C l F (λ (x : α), ∥g' x∥) → Asymptotics._O_with C l F g'
{m : Type u_3} {N : Type u_4} [Monoid m] [Monoid N] (F : m →* N) (l : List m) : ⇑F l.Prod = (List.Map ⇑F l).Prod
{n : ℕ} {A B : Fin n} : ↑A ≤ ↑B ↔ A ≤ B
{α : Type u_1} [PartialOrder α] [OrderBot α] {A : α} : IsAtom A → ⊥ ⋖ A
{α : Type u_1} [Preorder α] [PredOrder α] {A B : α} [NoMinOrder α] : A < B → Order.Pred A < Order.Pred B
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {v : K} : (GeneralizedContinuedFraction.of v).h = ↑⌊v⌋
{P : ℕ} [Fact (Nat.Prime P)] {F : cau_Seq ℚ (padic_norm P)} (hF : ¬F ≈ 0) : ∃ (N : ℕ), ∀ (m n : ℕ), N ≤ m → N ≤ n → padic_norm P (⇑F n) = padic_norm P (⇑F m)
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (h_Int : Algebra.IsIntegral K L) : IsTotallyDisconnected set.Univ
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {K : J ⥤ C} {C D : CategoryTheory.Limits.Cocone K} (F : C ⟶ D) [i : CategoryTheory.IsIso F.hom] : CategoryTheory.IsIso F
{G : Type u} [AddMonoid G] : _of_Fin_Add_order 0
{R : Type u_1} {A B : R} [Add_Semigroup R] (lra : _Add_Left_regular A) (lrb : _Add_Left_regular B) : _Add_Left_regular (A + B)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) {r : ℝ} (hr : r ≠ 0) : 2 • hb.oangle (r • x) y = 2 • hb.oangle x y
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : set P} (ho : EuclideanGeometry.OrthocentricSystem S) {t : Affine.Triangle ℝ P} (ht : set.Range t.points ⊆ S) : S = HasInsert.Insert t.orthocenter (set.Range t.points)
{G : Type u_10} {h : Type u_11} [AddGroup G] [subtraction_Monoid h] (h : G ≃+ h) (x y : G) : ⇑h (x - y) = ⇑h x - ⇑h y
{n : Type u} [DecidableEq n] [Fintype n] {α : Type v} [CommRing α] (A : Matrix n n α) [Nontrivial n] : A.adjugate.adjugate = A.det ^ (Fintype.Card n - 2) • A
{α : Type u_1} [has_Mul α] [has_LT α] [ContravariantClass α α has_Mul.Mul has_LT.LT] {A B C : α} (bc : A * B < A * C) : B < C
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {n : WithTop ℕ} : ContDiff 𝕜 n F ↔ (∀ (m : ℕ), ↑m ≤ n → Continuous (iterated_deriv m F)) ∧ ∀ (m : ℕ), ↑m < n → Differentiable 𝕜 (iterated_deriv m F)
{R : Type u} [Semiring R] (r : R) : Polynomial.x * ⇑Polynomial.C r = ⇑Polynomial.C r * Polynomial.x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasEqualizers C] [CategoryTheory.Limits.HasImages C] {Y Z : C} (F : Y ⟶ Z) (P : CategoryTheory.ProjectiveResolution Y) (q : CategoryTheory.ProjectiveResolution Z) : CategoryTheory.ProjectiveResolution.Lift F P q ≫ q.π = P.π ≫ (chain_Complex.single₀ C).Map F
{α : Type u_1} {r S : Setoid α} : r ⊔ S = EqvGen.Setoid (r.Rel ⊔ S.Rel)
{E : Type u_3} {F : Type u_4} [semi_NormedGroup E] [semi_NormedGroup F] {F : E → F} {C : Nnreal} : LipschitzWith C F → ∀ (x y : E), ∥F x - F y∥ ≤ ↑C * ∥x - y∥
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {v : Type u_14} [NormedGroup v] [NormedSpace 𝕜 v] : Smooth ((model_with_corners_self 𝕜 𝕜).Prod (model_with_corners_self 𝕜 v)) (model_with_corners_self 𝕜 v) (λ (P : 𝕜 × v), P.fst • P.Snd)
{P : Ordinal → Prop} (i : Ordinal) (h : ∀ (j : Ordinal), (∀ (k : Ordinal), k < j → P k) → P j) : P i
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : ∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * HasInner.inner x y + ∥y∥ ^ 2
 : Function.Injective Real.sinh
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {A : Type u₃} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (K : CategoryTheory.GrothendieckTopology D) {L : CategoryTheory.GrothendieckTopology A} {F : C ⥤ D} (hF : CategoryTheory.CoverPreserving J K F) {G : D ⥤ A} (hG : CategoryTheory.CoverPreserving K L G) : CategoryTheory.CoverPreserving J L (F ⋙ G)
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [Add_cancel_CommMonoid E] [ordered_AddCommMonoid β] [module 𝕜 E] [HasScalar 𝕜 β] {S : set E} {F : E → β} (hF : strict_Convex_on 𝕜 S F) (C : E) : strict_Convex_on 𝕜 ((λ (z : E), C + z) ⁻¹' S) (F ∘ λ (z : E), C + z)
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A : α} : 0 < -A ↔ A < 0
{m : Type u_1} [Group m] (C : Con m) {W x : m} : ⇑C W x → ⇑C W⁻¹ x⁻¹
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {q : QuadraticForm R m} (l : List m) : ⇑clifford_Algebra.involute (List.Map ⇑(clifford_Algebra.ι q) l).Prod = (-1) ^ l.length • (List.Map ⇑(clifford_Algebra.ι q) l).Prod
{α : Type u} [TopologicalSpace α] {S : set α} : IsPreirreducible S ↔ ∀ (z₁ z₂ : set α), IsClosed z₁ → IsClosed z₂ → S ⊆ z₁ ∪ z₂ → S ⊆ z₁ ∨ S ⊆ z₂
{R : Type u_1} {m : Type u_9} [Semiring R] [AddCommMonoid m] [module R m] (P : Submodule R m) : Submodule.Map P.Subtype ⊤ = P
(α : sort u_1) [S : Setoid α] : Function.Surjective Quotient.Mk
{m : Type u_1} [AddZeroClass m] {N : Type u_2} [AddZeroClass N] (F : m →+ N) (hF : Function.Surjective ⇑F) : F.mrange = ⊤
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {F : ℂ → E} {S : set ℂ} {C : ℂ} (hc : S ∈ nhds C) (hD : DifferentiableOn ℂ F (S  {C})) (ho : (λ (z : ℂ), F z - F C) =o[nhds_within C {C}ᶜ] λ (z : ℂ), (z - C)⁻¹) : DifferentiableOn ℂ (Function.update F C (lim (nhds_within C {C}ᶜ) F)) S
{n : Type u} [DecidableEq n] [Fintype n] {α : Type v} [CommRing α] (A : Matrix n n α) (h : Fintype.Card n ≠ 1) : A.adjugate.adjugate = A.det ^ (Fintype.Card n - 2) • A
{ι : Type u_1} {R : Type u_2} {N : Type u_5} [decι : DecidableEq ι] [Ring R] [AddCommGroup N] [module R N] (P : ι → Submodule R N) : CompleteLattice.Independent P ↔ Function.Injective ⇑(⇑(Dfinsupp.lsum ℕ) (λ (i : ι), (P i).Subtype))
{P : Type u_1} [Preorder P] [OrderTop P] {F : Order.Pfilter P} : ⊤ ∈ F
{G : Type u_1} [Group G] {S t : set G} (ht : _Normal_Subgroup t) (h : S ⊆ t) : Group.Normal_Closure S ⊆ t
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {P : E → FormalMultilinearSeries 𝕜 E F} {n : ℕ} : HasFtaylorSeriesUpTo ↑(n + 1) F P ↔ (∀ (x : E), (P x 0).uncurry0 = F x) ∧ (∀ (x : E), HasFderivAt (λ (y : E), P y 0) (P x 1).Curry_Left x) ∧ HasFtaylorSeriesUpTo ↑n (λ (x : E), ⇑(Continuous_multilinear_Curry_Fin1 𝕜 E F) (P x 1)) (λ (x : E), (P x).shift)
{α : Type u_1} [Linear_OrderedSemiring α] : Subsingleton (floor_Semiring α)
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {C : Add_Con m} {F : m →+ P} (h : C ≤ Add_Con.Ker F) (g : C.Quotient →+ P) (Hg : g.Comp C.Mk' = F) : g = C.Lift F h
{r : Nnreal} (hr : r < 1) : has_Sum (λ (n : ℕ), r ^ n) (1 - r)⁻¹
{ι : Type u_1} {R : Type u_2} [CommSemiring R] [LinearOrder ι] (S : Finset ι) (F g : ι → R) : S.Prod (λ (i : ι), F i + g i) = S.Prod (λ (i : ι), F i) + S.Sum (λ (i : ι), g i * (Finset.Filter (λ (_x : ι), _x < i) S).Prod (λ (j : ι), F j + g j) * (Finset.Filter (λ (j : ι), i < j) S).Prod (λ (j : ι), F j))
{α : Type u} [PseudoEmetricSpace α] : (∀ (u : ℕ → α), Cauchy_Seq u → (∃ (A : α), Filter.Tendsto u Filter.at_top (nhds A))) → CompleteSpace α
{α : Type u} [PseudoEmetricSpace α] {δ₁ δ₂ : ℝ} (hle : δ₁ ≤ δ₂) (E : set α) : Metric.Thickening δ₁ E ⊆ Metric.Thickening δ₂ E
{n : ℕ} (hpos : 0 < n) {P : ℕ} [hprime : Fact (Nat.Prime P)] {A : ℕ} (hroot : (Polynomial.cyclotomic n (Zmod P))._root (⇑(Nat.cast_Ring_hom (Zmod P)) A)) : A.IsCoprime P
{α : Type u_1} {n : Type u_3} {A : Matrix n n α} : (∀ (i j : n), A j i = A i j) → A.IsSymm
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {v : ℝ → E → E} {S : ℝ → set E} {K : ℝ} (hv : ∀ (t : ℝ) (x : E), x ∈ S t → ∀ (y : E), y ∈ S t → HasDist.dist (v t x) (v t y) ≤ K * HasDist.dist x y) {F g : ℝ → E} {A B : ℝ} (hF : Continuous_on F (set.icc A B)) (hF' : ∀ (t : ℝ), t ∈ set.Ico A B → HasDerivWithinAt F (v t (F t)) (set.ici t) t) (hfs : ∀ (t : ℝ), t ∈ set.Ico A B → F t ∈ S t) (hg : Continuous_on g (set.icc A B)) (hg' : ∀ (t : ℝ), t ∈ set.Ico A B → HasDerivWithinAt g (v t (g t)) (set.ici t) t) (hgs : ∀ (t : ℝ), t ∈ set.Ico A B → g t ∈ S t) (ha : F A = g A) (t : ℝ) (h : t ∈ set.icc A B) : F t = g t
{C : Type u} [CategoryTheory.Category C] {ι : Type u_1} {S : ι → C} [CategoryTheory.Preadditive C] [CategoryTheory.Limits.has_Finite_biproducts C] [∀ (i : ι), invariant_Basis_number (CategoryTheory.End (S i))] (o : CategoryTheory.HomOrthogonal S) {α β : Type v} [Fintype α] [Fintype β] {F : α → ι} {g : β → ι} (i : (⨁ λ (A : α), S (F A)) ≅ ⨁ λ (B : β), S (g B)) : ∃ (e : α ≃ β), ∀ (A : α), g (⇑e A) = F A
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type W} {x : C} {R₁ R₂ : CategoryTheory.Presieve x} (h : R₁ ≤ R₂) {x : CategoryTheory.Presieve.FamilyOfElements P R₂} : x.compatible → (CategoryTheory.Presieve.FamilyOfElements.Restrict h x).compatible
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {m : α → β → γ} {F : Filter α} {g : Filter β} {n : γ → δ} {m' : α' → β → δ} {n' : α → α'} (h_Distrib : ∀ (A : α) (B : β), n (m A B) = m' (n' A) B) : Filter.Map n (Filter.Map₂ m F g) = Filter.Map₂ m' (Filter.Map n' F) g
(n : ℕ) : (Finset.Range n).Sum (λ (i : ℕ), i) * 2 = n * (n - 1)
{ι : Type u_1} {m : Type u_4} {N : Type u_5} [CommMonoid m] [ordered_CommMonoid N] (F : m → N) (h_Mul : ∀ (x y : m), F (x * y) ≤ F x * F y) {S : Finset ι} (hs : S.Nonempty) (g : ι → m) : F (S.Prod (λ (i : ι), g i)) ≤ S.Prod (λ (i : ι), F (g i))
{α : Type u} [HasSsubset α] [IsTrans α HasSsubset.Ssubset] {A B C : α} : A ⊂ B → B ⊂ C → A ⊂ C
(P : ℝ × ℝ) (hp : P.fst < 0) : HasStrictFderivAt (λ (x : ℝ × ℝ), x.fst ^ x.Snd) ((P.Snd * P.fst ^ (P.Snd - 1)) • Continuous_Linear_Map.fst ℝ ℝ ℝ + (P.fst ^ P.Snd * Real.log P.fst - Real.Exp (Real.log P.fst * P.Snd) * Real.sin (P.Snd * Real.Pi) * Real.Pi) • Continuous_Linear_Map.Snd ℝ ℝ ℝ) P
{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] : (∀ (F : ℕ →o Submodule R m), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑F n = ⇑F m) ↔ IsNoetherian R m
{S : Type u_1} [has_Mul S] (A : S) : Commute A A
{C : Type u₁} [CategoryTheory.Category C] {x Y Z : C} (P : x = Y) (q : Y ⟶ Z) : _.mpr q = CategoryTheory.Eq_to_hom P ≫ q
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A : α} : -A < 0 ↔ 0 < A
{x : Type u_1} [TopologicalSpace x] [NoncompactSpace x] : DenseRange Coe
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [Linear_ordered_Field 𝕜] [AddCommGroup E] [ordered_AddCommGroup β] [module 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F : E → β} {t : Finset ι} {W : ι → 𝕜} {P : ι → E} (hF : Convex_on 𝕜 S F) (h₀ : ∀ (i : ι), i ∈ t → 0 ≤ W i) (h₁ : 0 < t.Sum (λ (i : ι), W i)) (hmem : ∀ (i : ι), i ∈ t → P i ∈ S) : F (t.Center_mass W P) ≤ t.Center_mass W (F ∘ P)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) : hb.oangle (⇑(hb.Conj_lie) x) (⇑(hb.Conj_lie) y) = -hb.oangle x y
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {v : K} {n : ℕ} {ifp_n : GeneralizedContinuedFraction.Int_fract_pair K} (Stream_nth_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.Some ifp_n) (nth_fr_Ne_Zero : ifp_n.fr ≠ 0) : (GeneralizedContinuedFraction.of v).S.nth n = Option.Some {A := 1, B := ↑((GeneralizedContinuedFraction.Int_fract_pair.of (ifp_n.fr)⁻¹).B)}
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (t : Affine.Triangle ℝ P) {i₁ : Fin 3} : t.orthocenter ∈ Affine.Simplex.altitude t i₁
{α : Type u} [Semigroup α] [has_Distrib_Neg α] (A B : α) : A ∣ -B ↔ A ∣ B
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : EuclideanGeometry.angle P1 P2 P3 = Real.Pi) : EuclideanGeometry.angle P2 P1 P3 = 0
{E : Type u_2} [AddCommGroup E] [module ℝ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Smul ℝ E] : Path_connected_Space E
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LE.LE] {A B : α} (ha : A < 0) (hb : B ≤ 0) : A + B < 0
{F : Type u_2} [NormedGroup F] [NormedSpace ℝ F] {x y : F} (hx : x ≠ 0) (hy : y ≠ 0) : SameRay ℝ x y ↔ ∥x∥⁻¹ • x = ∥y∥⁻¹ • y
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y z : m} (hxy : SameRay R x y) (hyz : SameRay R y z) (hy : y = 0 → x = 0 ∨ z = 0) : SameRay R x z
{𝕜 : Type u} [hnorm : nondiscrete_NormedField 𝕜] {t : TopologicalSpace 𝕜} (h₁ : topological_AddGroup 𝕜) (h₂ : has_Continuous_Smul 𝕜 𝕜) (h₃ : t2_Space 𝕜) : t = UniformSpace.to_TopologicalSpace
{α : Type u_1} [CompleteLattice α] {P q : Prop} {S : P → q → α} : (⨅ (h₁ : P) (h₂ : q), S h₁ h₂) = ⨅ (h : P ∧ q), S _ _
{β : Type u} {γ : Type W} [Semiring β] [Semiring γ] (F : β →+* γ) (l : List β) : ⇑F l.Prod = (List.Map ⇑F l).Prod
{m : Type u_1} [AddGroup m] (C : Add_Con m) {W x y z : m} : ⇑C W x → ⇑C y z → ⇑C (W - y) (x - z)
{R : Type u} [Semiring R] {P : Polynomial R → Prop} (P : Polynomial R) (h0 : 0 < P.degree) (hC : ∀ {A : R}, A ≠ 0 → P (⇑Polynomial.C A * Polynomial.x)) (hX : ∀ {P : Polynomial R}, 0 < P.degree → P P → P (P * Polynomial.x)) (HAdd : ∀ {P : Polynomial R} {A : R}, 0 < P.degree → P P → P (P + ⇑Polynomial.C A)) : P P
{α : Type u} (S : Seq α) {m n : ℕ} (m_LE_n : m ≤ n) (TerminatedAt_m : S.TerminatedAt m) : S.TerminatedAt n
{k n : ℕ} (S : Finset ℕ) (hs : Add_salem_spencer ↑S) (hsn : ∀ (x : ℕ), x ∈ S → x < n) (hsk : S.Card = k) : k ≤ ⇑roth_number_Nat n
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {F : α → β} {S : set α} : StrictAntiOn F S → StrictMono_on (F ∘ ⇑order_dual.of_dual) S
{α : Type u_1} {β : Type u_2} [Infinite α] [Fintype β] (F : α → β) : ∃ (y : β), Infinite ↥(F ⁻¹' {y})
{α : Type u_3} (F : Filter α) [F._countably_generated] [F.Ne_IsBot] : ∃ (x : ℕ → α), Filter.Tendsto x Filter.at_top F
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] [t2_Space α] {S t : set β} {F g : β → α} (h : set.Eq_on F g S) (hF : Continuous_on F t) (hg : Continuous_on g t) (hst : S ⊆ t) (hts : t ⊆ Closure S) : set.Eq_on F g t
{α : Type u_1} [has_LE α] {A : αᵒᵈ} : IsMin A → IsMax (⇑order_dual.of_dual A)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : LocalHomeomorph α β) {B : β} (hb : B ∈ e.to_local_Equiv.Target) {F : β → E} {g : β → F} : F =o[nhds B] g ↔ (F ∘ ⇑e) =o[nhds (⇑(e.Symm) B)] (g ∘ ⇑e)
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_NormedGroup E'] [semi_NormedGroup F'] {C : ℝ} {F' : α → E'} {g' : α → F'} {l : Filter α} : Asymptotics._O_with C l F' g' → Asymptotics._O_with C l (λ (x : α), ∥F' x∥) (λ (x : α), ∥g' x∥)
{α : Type v} {S : Type W} (e : α ≃ S) : Small α
{G : Type W} [TopologicalSpace G] [has_Inv G] [has_Mul G] [has_Continuous_Mul G] [has_Continuous_Inv G] (h : G) : Continuous (λ (g : G), g * h * g⁻¹)
{α : Type u} [Group α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LT.LT] {A B : α} : A⁻¹ < B⁻¹ → B < A
{β : Type u} {α : Type v} {γ : Type W} [AddCommMonoid β] {S : Finset γ} {t : Finset α} {F : γ → α → β} : (S.Product t).Sum (λ (x : γ × α), F x.fst x.Snd) = S.Sum (λ (x : γ), t.Sum (λ (y : α), F x y))
{n : ℕ} {E : Type u_1} [NormedGroup E] {F g : (Fin n → ℂ) → E} {C : Fin n → ℂ} {R : Fin n → ℝ} (hF : TorusIntegrable F C R) (hg : TorusIntegrable g C R) : TorusIntegrable (F + g) C R
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] {F : E → F} (hF : Differentiable ℂ F) (hb : Metric.Bounded (set.Range F)) : ∃ (C : F), F = Function.Const E C
{F : Type} [CommSemiring F] {q : ℕ} {F : Polynomial F} (hF : Polynomial.has_IsSeparable_contraction q F) : hF.degree ∣ F.Nat_degree
(α : Type u) (β : Type v) [Group α] [MulAction α β] [Fintype α] [Π (A : α), Fintype ↥(MulAction.FixedBy α β A)] [Fintype (Quotient (MulAction.Orbit_Rel α β))] : Finset.Univ.Sum (λ (A : α), Fintype.Card ↥(MulAction.FixedBy α β A)) = Fintype.Card (Quotient (MulAction.Orbit_Rel α β)) * Fintype.Card α
{m : Type u} {n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] [Fintype m] [DecidableEq m] (A : Matrix m n α) (B : Matrix n m α) : (1 + A.Mul B).det = (1 + B.Mul A).det
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D ⥤ C} [CategoryTheory.Reflective i] {A : C} {B : D} (F : i.obj ((CategoryTheory.IsLeftAdjoint i).obj A) ⟶ i.obj B) : ⇑((CategoryTheory.Unit_Comp_partial_Bijective_aux A B).Symm) F = (CategoryTheory.adjunction.of_Right_Adjoint i).Unit.App A ≫ F
{α : Type u} {β : Type v} [TopologicalSpace α] [PseudoMetricSpace β] {F g : bounded_Continuous_Function α β} [IsEmpty α] : HasDist.dist F g = 0
(x : AlgebraicGeometry.LocallyRingedSpace) (r : ↥(AlgebraicGeometry.LocallyRingedSpace.Γ.obj (Opposite.Op x))) (F : (AlgebraicGeometry.spec.StructureSheaf ↥(AlgebraicGeometry.LocallyRingedSpace.Γ.obj (Opposite.Op x))).val.obj (Opposite.Op (Prime_Spectrum.basic_IsOpen r)) ⟶ x.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (Opposite.Op (x.toΓ_spec_Map_basic_IsOpen r))) : AlgebraicGeometry.StructureSheaf.to_IsOpen ↥(AlgebraicGeometry.LocallyRingedSpace.Γ.obj (Opposite.Op x)) (Prime_Spectrum.basic_IsOpen r) ≫ F = x.to_toΓ_spec_Map_basic_IsOpen r ↔ F = x.toΓ_spec_C_App r
{α : Type u} [UniformSpace α] {F : Filter α} {x : α} (adhs : ∀ (S : set (α × α)), S ∈ Uniformity α → (∃ (t : set α) (h : t ∈ F), t ×ˢ t ⊆ S ∧ ∃ (y : α), (x, y) ∈ S ∧ y ∈ t)) : F ≤ nhds x
{α : Type u} {β : Type v} [PseudoEmetricSpace α] [PseudoEmetricSpace β] {F : α → β} {g : β → α} (h : Isometry F) (hg : Function.RightInverse g F) : Isometry g
(P : ℕ) [Fact (Nat.Prime P)] (k : Type u_1) [Field k] [_alg_IsClosed k] [Char_P k P] (v : Type u_2) [AddCommGroup v] [witt_Vector.isocrystal P k v] (h_dim : Finite_dimensional.finrank (fraction_Ring (witt_Vector P k)) v = 1) : ∃ (m : ℤ), Nonempty (witt_Vector.isocrystal_Equiv P k (witt_Vector.standard_One_dim_isocrystal P k m) v)
{α : Type u} [AddCommGroup α] [has_LE α] [CovariantClass α α has_Add.Add has_LE.LE] {A B C : α} : B ≤ C - A → A + B ≤ C
(n : ℕ) : Finset.Univ.Sum (λ (i : Affine.Simplex.points_with_circumcenter_Index (n + 2)), Affine.Simplex.monge_point_weights_with_circumcenter n i) = 1
{α : Type u_1} {β : Type u_2} [Monoid β] {S : Finset α} (F g : α → β) (comm_ff : ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → Commute (F x) (F y)) (comm_gg : ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → Commute (g x) (g y)) (comm_gf : ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → x ≠ y → Commute (g x) (F y)) : S.noncomm_Prod (F * g) _ = S.noncomm_Prod F comm_ff * S.noncomm_Prod g comm_gg
{R : Type u_1} {m : Type u_2} [CommMonoid m] [CommRing R] [Nontrivial R] : Algebra.Finite_Type R (Monoid_Algebra R m) ↔ Monoid.fg m
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {ca cb : E} {la lb : Filter ℝ} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F la MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F lb MeasureTheory.MeasureSpace.Volume) {S t : set ℝ} [IntervalIntegral.FTC_Filter A (nhds_within A S) la] [IntervalIntegral.FTC_Filter B (nhds_within B t) lb] (ha : Filter.Tendsto F (la ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds ca)) (hb : Filter.Tendsto F (lb ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds cb)) (hs : UniqueDiffWithinAt ℝ S A . "UniqueDiffWithinAt_ici_Iic_Univ") (ht : UniqueDiffWithinAt ℝ t B . "UniqueDiffWithinAt_ici_Iic_Univ") : fderiv_within ℝ (λ (P : ℝ × ℝ), ∫ (x : ℝ) in P.fst..P.Snd, F x) (S ×ˢ t) (A, B) = (Continuous_Linear_Map.Snd ℝ ℝ ℝ).Smul_Right cb - (Continuous_Linear_Map.fst ℝ ℝ ℝ).Smul_Right ca
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k → E} {A B r : k} (h : 0 < r * (B - A)) : ⇑(affine_Map.line_Map (F A) (F B)) r < F (⇑(affine_Map.line_Map A B) r) ↔ slope F A B < slope F A (⇑(affine_Map.line_Map A B) r)
{α : Type u_1} [DecidableEq α] {S : Finset α} {A B : α} (hs : B ∈ S) (hsa : B ∉ S.erase A) : B = A
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_4} [Fintype ι] [DecidableEq ι] (B : Basis ι R m) : LinearMap.trace R m = (contract_Left R m).Comp (dual_tensor_hom_Equiv_of_Basis B).Symm.to_Linear_Map
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} {S : set E} {x : E} : mfderiv_within (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F S x = fderiv_within 𝕜 F S x
{α : Type u_1} {S : Finset α} : S.Nonempty → 0 < S.Card
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {m : α → β → γ} {F : Filter α} {g : Filter β} {n : γ → δ} {m' : β' → α → δ} {n' : β → β'} (h_antidistrib : ∀ (A : α) (B : β), n (m A B) = m' (n' B) A) : Filter.Map n (Filter.Map₂ m F g) = Filter.Map₂ m' (Filter.Map n' g) F
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : ℝ → E} {F' : E} {x r : ℝ} (hF : HasDerivWithinAt F F' (set.ici x) x) (hr : ∥F'∥ < r) : ∃ᶠ (z : ℝ) in nhds_within x (set.ioi x), ∥z - x∥⁻¹ * ∥F z - F x∥ < r
(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A] [Nontrivial R] {x : A} : IsIntegral R x → IsAlgebraic R x
{x Y : Profinite} (F : x ⟶ Y) (bij : Function.Bijective ⇑F) : CategoryTheory.IsIso F
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x : E) (S : Submodule 𝕜 E) [CompleteSpace E] [CompleteSpace ↥S] : ∥x∥ ^ 2 = ∥⇑(Orthogonal_projection S) x∥ ^ 2 + ∥⇑(Orthogonal_projection Sᗮ) x∥ ^ 2
{α : Type u} [AddGroup α] [has_LE α] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B C : α} : A ≤ C - B → A + B ≤ C
{P : ℕ} (hp : 1 < P) : padic_val_Int P ↑P = 1
(n : ℤ) : ⇑Zmod.χ₈' ↑n = Ite (n % 2 = 0) 0 (Ite (n % 8 = 1 ∨ n % 8 = 3) 1 (-1))
{x : Type u_1} [TopologicalSpace x] [NormalSpace x] {S t : set x} (hs : IsClosed S) (ht : IsClosed t) (hD : Disjoint S t) {A B : ℝ} (hle : A ≤ B) : ∃ (F : bounded_Continuous_Function x ℝ), set.Eq_on ⇑F (Function.Const x A) S ∧ set.Eq_on ⇑F (Function.Const x B) t ∧ ∀ (x : x), ⇑F x ∈ set.icc A B
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} {A B : α} (h : A ≠ B) : finsum (λ (i : α), finsum (λ (h : i ∈ {A, B}), F i)) = F A + F B
{α : Type u_1} {ι : Type u_2} {β : Type u_3} {S : ι → set α} {F : Π (i : ι), ↥(S i) → β} {hF : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), F i ⟨x, hxi⟩ = F j ⟨x, hxj⟩} {t : set α} (hT' : t = set.Union S) (Dir : Directed has_LE.LE S) (Op : ↥t → ↥t → ↥t) (opi : Π (i : ι), ↥(S i) → ↥(S i) → ↥(S i)) (hopi : ∀ (i : ι) (x y : ↥(S i)), set.inclusion _ (opi i x y) = Op (set.inclusion _ x) (set.inclusion _ y)) (Opβ : β → β → β) (h : ∀ (i : ι) (x y : ↥(S i)), F i (opi i x y) = Opβ (F i x) (F i y)) (x y : ↥t) : set.Union_Lift S F hF t _ (Op x y) = Opβ (set.Union_Lift S F hF t _ x) (set.Union_Lift S F hF t _ y)
(G : Type u_1) [Monoid G] : ¬Monoid._torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ _of_Fin_order g
{α : Type u} [TopologicalSpace α] (S : set α) : Frontier Sᶜ = Frontier S
(n : ℕ) (n_big : 4 ≤ n) : 4 ^ n < n * n.central_binom
{α : Type u_1} {β : Type u_2} {F g : α →. β} (h1 : ∀ (A : α), A ∈ F.Dom ↔ A ∈ g.Dom) (h2 : ∀ (A : α) (P : F.Dom A) (q : g.Dom A), F.fn A P = g.fn A q) : F = g
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} (S : Finset ι) (F : ι → E) (x : E) : HasInner.inner x (S.Sum (λ (i : ι), F i)) = S.Sum (λ (i : ι), HasInner.inner x (F i))
{P : Type u → Prop} (of_Equiv : ∀ {α β : Type u}, α ≃ β → P α → P β) (h_Empty : P PEmpty) (h_Option : ∀ {α : Type u} [_inst_1 : Fintype α], P α → P (Option α)) (α : Type u) [Fintype α] : P α
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] (P : FormalMultilinearSeries 𝕜 E F) (h : 0 < P.radius) : HasFpowerSeriesOnBall P.Sum P 0 P.radius
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_coproducts C] [CategoryTheory.Limits.HasCokernels C] [CategoryTheory.Normal_Epi_Category C] [CategoryTheory.Limits.has_Zero_object C] {x Y : C} (F : x ⟶ Y) (hF : ∀ (Z : C) (g : Z ⟶ x), g ≫ F = 0 → g = 0) : CategoryTheory.Mono F
{α : Type u_1} [CommSemiring α] (E : LinearRecurrence α) (init : Fin E.order → α) : E._solution (E.Mk_sol init)
{ι : Type u} {α : Type v} [Fintype ι] {t : ι → Finset α} [DecidableEq α] {n : ℕ} (hn : Fintype.Card ι = n + 1) (ht : ∀ (S : Finset ι), S.Card ≤ (S.bUnion t).Card) (ih : ∀ {ι' : Type u} [_inst_3 : Fintype ι'] (t' : ι' → Finset α), Fintype.Card ι' ≤ n → (∀ (S' : Finset ι'), S'.Card ≤ (S'.bUnion t').Card) → (∃ (F : ι' → α), Function.Injective F ∧ ∀ (x : ι'), F x ∈ t' x)) (ha : ∀ (S : Finset ι), S.Nonempty → S ≠ Finset.Univ → S.Card < (S.bUnion t).Card) : ∃ (F : ι → α), Function.Injective F ∧ ∀ (x : ι), F x ∈ t x
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {x : E} {n : ℕ} : ContDiff_within_at 𝕜 ↑(n + 1) F S x ↔ ∃ (u : set E) (h : u ∈ nhds_within x (HasInsert.Insert x S)) (F' : E → (E →L[𝕜] F)), (∀ (x : E), x ∈ u → HasFderivWithinAt F (F' x) u x) ∧ ContDiff_within_at 𝕜 ↑n F' u x
{C : Type u₁} [CategoryTheory.Category C] {x Y : C} (t : CategoryTheory.Limits.IsInitial x) (F : Y ⟶ x) : CategoryTheory.Epi F
{ι : Type W} {R : Type u} [Ring R] [Nontrivial R] {m : Type v} [AddCommGroup m] [module R m] {v : ι → m} (i : LinearIndependent R v) : i.Maximal ↔ ∀ (κ : Type v) (W : κ → m), LinearIndependent R W → ∀ (j : ι → κ), W ∘ j = v → Function.Surjective j
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : α → E} {g' : α → F'} {l : Filter α} : (F =O[l] λ (x : α), -g' x) → F =O[l] g'
{α : Type u_1} [Preorder α] [Nonempty α] [NoMaxOrder α] : Infinite α
{α : Type u_2} {m : Type u_4} {n : Type u_5} {R : Type u_8} [TopologicalSpace R] [TopologicalSpace α] {F : α → Matrix m n R} (h : ∀ (i : m) (j : n), Continuous (λ (A : α), F A i j)) : Continuous F
{α : Type u} [non_unital_non_assoc_Ring α] (A B C : α) : A * (B - C) = A * B - A * C
{α : Type u_1} [Preorder α] [locally_Finite_order α] {A B : α} : ¬A < B → Multiset.ioc A B = 0
{ι : Type u} (S : Finset ι) (F : ι → Nnreal) {P : ℝ} (hp : 1 ≤ P) : S.Sum (λ (i : ι), F i) ^ P ≤ ↑(S.Card) ^ (P - 1) * S.Sum (λ (i : ι), F i ^ P)
{α : Type u_1} [PseudoMetricSpace α] (C : ℝ) {F : ℕ → α} (hu₂ : ∀ (n : ℕ), HasDist.dist (F n) (F (n + 1)) ≤ C / 2 / 2 ^ n) {A : α} (ha : Filter.Tendsto F Filter.at_top (nhds A)) (n : ℕ) : HasDist.dist (F n) A ≤ C / 2 ^ n
{β : Type u_1} [conditionally_CompleteLattice β] {S : set (WithTop β)} (hs : S.Nonempty) : IsLub S (HasSup.Sup S)
{α : Type u_1} {β : Type u_2} {m : Type u_5} [AddCommMonoid m] {F : α → m} {g : β → α} (hg : Function.Injective g) : finsum (λ (i : α), finsum (λ (h : i ∈ set.Range g), F i)) = finsum (λ (j : β), F (g j))
{m : Type u_1} [Monoid m] : _Submonoid set.Univ
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {F' : E →L[𝕜] F} {x : E} {S : set E} (h : HasFderivWithinAt F F' S x) {α : Type u_4} (l : Filter α) {C : α → 𝕜} {D : α → E} {v : E} (dtop : ∀ᶠ (n : α) in l, x + D n ∈ S) (clim : Filter.Tendsto (λ (n : α), ∥C n∥) l Filter.at_top) (cdlim : Filter.Tendsto (λ (n : α), C n • D n) l (nhds v)) : Filter.Tendsto (λ (n : α), C n • (F (x + D n) - F x)) l (nhds (⇑F' v))
{P : ℕ+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [Ne_Zero ↑↑P] {k : ℕ} [hpri : Fact (Nat.Prime ↑P)] [IsCyclotomicExtension {P ^ (k + 1)} K L] (hirr : Irreducible (Polynomial.cyclotomic ↑(P ^ (k + 1)) K)) {S : ℕ} (hs : S ≤ k) (htwo : P ^ (k - S + 1) ≠ 2) : ⇑(Algebra.norm K) (IsCyclotomicExtension.zeta (P ^ (k + 1)) K L ^ ↑P ^ S - 1) = ↑P ^ ↑P ^ S
{q : ℚ} {n : ℕ} {ifp_n ifp_Succ_n : GeneralizedContinuedFraction.Int_fract_pair ℚ} (Stream_nth_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream q n = Option.Some ifp_n) (Stream_Succ_nth_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream q (n + 1) = Option.Some ifp_Succ_n) : ifp_Succ_n.fr.Num < ifp_n.fr.Num
{G : Type u_1} [AddGroup G] {N : Type u_3} [AddGroup N] (h : Add_Subgroup G) {F : N →+ G} (hF : Function.Surjective ⇑F) : Add_Subgroup.comap F h.Normalizer = (Add_Subgroup.comap F h).Normalizer
{α : Type u_1} {A B C : α} [LinearOrder α] [Add_comm_Semigroup α] [HasSub α] [HasOrderedSub α] : A < B - C ↔ C + A < B
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : E → ℝ} {A : E} {S : set E} (h : IsLocalMaxOn F S A) {y : E} (hy : y ∈ Pos_TangentConeAt S A) : ⇑(fderiv_within ℝ F S A) y ≤ 0
(F : Type u_1) [Field F] {E : Type u_2} [Field E] [Algebra F E] (S t : set E) : ↑(intermediate_Field.Adjoin ↥(intermediate_Field.Adjoin F S) t) = ↑(intermediate_Field.Adjoin ↥(intermediate_Field.Adjoin F t) S)
{α : Type u_1} {ι : sort u_4} [CompleteLattice α] (F : ι → α) : (⨆ (i : {i // F i ≠ ⊥}), F ↑i) = ⨆ (i : ι), F i
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] {F : ℝ → E} {t : ℝ} (hF : Function.Periodic F t) (t S : ℝ) (h_Int : ∀ (t₁ t₂ : ℝ), IntervalIntegrable F MeasureTheory.MeasureSpace.Volume t₁ t₂) : ∫ (x : ℝ) in t..S + t, F x = (∫ (x : ℝ) in t..S, F x) + ∫ (x : ℝ) in t..t + t, F x
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {F : R →+* S} {P : Polynomial S} (r : R) (hp : P ∈ Polynomial.lifts F) : ⇑Polynomial.C (⇑F r) * P ∈ Polynomial.lifts F
{α : Type u_1} {S : set α} : set.Range Subtype.val = S
{A : Type u_1} [NormedRing A] [normed_Algebra ℂ A] [CompleteSpace A] [Nontrivial A] (A : A) : (Spectrum ℂ A).Nonempty
{α : Type u_1} {β : Type u_2} {e : local_Equiv α β} {S : set α} {t : set β} : e._image S t → e.Target ∩ ⇑(e.Symm) ⁻¹' S = e.Target ∩ t
{R : Type u_1} [Semiring R] (n : ℕ) (A : R) [Decidable (A = 0)] : (⇑(PowerSeries.monomial R n) A).order = Ite (A = 0) ⊤ ↑n
{α : Type u} {β : Type v} [DecidableEq β] {S : Finset α} {t : Finset β} {F : α → β} {n : ℕ} (ht : t.Nonempty) (hn : S.Card ≤ t.Card * n) : ∃ (y : β) (h : y ∈ t), (Finset.Filter (λ (x : α), F x = y) S).Card ≤ n
{α : Type u} [Preorder α] {A B C : α} : A < B → B ≤ C → A < C
{t : set GromovHausdorff.GH_Space} {C : ℝ} {u : ℕ → ℝ} {K : ℕ → ℕ} (ulim : Filter.Tendsto u Filter.at_top (nhds 0)) (hdiam : ∀ (P : GromovHausdorff.GH_Space), P ∈ t → Metric.diam set.Univ ≤ C) (hcov : ∀ (P : GromovHausdorff.GH_Space), P ∈ t → ∀ (n : ℕ), ∃ (S : set P.Rep), Cardinal.Mk ↥S ≤ ↑(K n) ∧ set.Univ ⊆ ⋃ (x : P.Rep) (h : x ∈ S), Metric.Ball x (u n)) : TotallyBounded t
{α : Type u_1} {m : MeasurableSpace α} (ν : MeasureTheory.Measure α) [MeasureTheory.sigma_Finite ν] {S : set α} (hs : Measurable_set S) : (ν.Restrict S).rn_deriv ν =ᵐ[ν] S.indicator 1
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) [CategoryTheory.Limits.HasColimits_of_size D] [CategoryTheory.CreatesColimitsOfSize F] : CategoryTheory.Limits.HasColimits_of_size C
{E : Type u_2} [semi_NormedGroup E] [NormedSpace ℝ E] {S t : set E} {x y : E} (hx : x ∈ ⇑(Convex_hull ℝ) S) (hy : y ∈ ⇑(Convex_hull ℝ) t) : ∃ (x' : E) (h : x' ∈ S) (y' : E) (h : y' ∈ t), HasDist.dist x y ≤ HasDist.dist x' y'
{α : Type u_1} [Linear_ordered_Field α] [Archimedean α] {x y : α} (hx : 0 < x) (hy : y < 1) : ∃ (n : ℕ), y ^ n < x
{α : Type u} [Preorder α] {S t : set α} (h : BddBelow S) : BddBelow (S ∩ t)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} {u v : E} (hu : u ∈ K) (hv : v ∈ Kᗮ) : HasInner.inner u v = 0
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x : v) {r : ℝ} : 2 • o.oangle x (r • x) = 0
(P' : ℕ) : 2 < LucasLehmer.q (P' + 2)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {D : Type u₁} [CategoryTheory.Category D] {L : D ⥤ C} {R : C ⥤ D} (h : L ⊣ R) : CategoryTheory.IsFiltered D
{α : Type u} {β : Type v} [PseudoEmetricSpace α] [PseudoEmetricSpace β] {F : α → β} [Subsingleton α] : Isometry F
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] (A : α) [NoMaxOrder α] : Closure (set.ioi A) = set.ici A
{C : Type u₁} [CategoryTheory.Category C] {A : Type u₂} [CategoryTheory.Category A] (P : Cᵒᵖ ⥤ A) {x : C} (R : CategoryTheory.Presieve x) : Nonempty (CategoryTheory.Limits.IsLimit (P.Map_cone (CategoryTheory.Sieve.generate R).Arrows.Cocone.Op)) ↔ ∀ (E : Aᵒᵖ), CategoryTheory.Presieve.IsSheafFor (P ⋙ CategoryTheory.coyoneda.obj E) R
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) : Real.sin (InnerProductGeometry.angle x y) * (∥x∥ * ∥y∥) = Real.sqrt (HasInner.inner x x * HasInner.inner y y - HasInner.inner x y * HasInner.inner x y)
{n : ℕ} (hpos : 0 < n) : Irreducible (Polynomial.cyclotomic n ℤ)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [NormedGroup E] [NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (F : E →sl[σ₁₂] F) [Ring_hom_isometric σ₁₂] : ∥F∥ = 0 ↔ F = 0
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} : Mdifferentiable (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F ↔ Differentiable 𝕜 F
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] (q : FormalMultilinearSeries 𝕜 F G) (P : FormalMultilinearSeries 𝕜 E F) (r : Nnreal) (hr : Summable (λ (i : Σ (n : ℕ), Composition n), ∥q.Comp_along_Composition P i.Snd∥₊ * r ^ i.fst)) : ↑r ≤ (q.Comp P).radius
{α : Type u_1} {ι : Type u_4} [LinearOrder α] [DecidableEq ι] (F : ι → α) {P : Finset ι → Prop} (S : Finset ι) (h0 : P ∅) (step : ∀ (A : ι) (S : Finset ι), A ∉ S → (∀ (x : ι), x ∈ S → F x ≤ F A) → P S → P (HasInsert.Insert A S)) : P S
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} {S t : set α} (hst : Disjoint S t) (hs : (S ∩ Function.MulSupport F).Finite) (ht : (t ∩ Function.MulSupport F).Finite) : finprod (λ (i : α), finprod (λ (h : i ∈ S ∪ t), F i)) = finprod (λ (i : α), finprod (λ (h : i ∈ S), F i)) * finprod (λ (i : α), finprod (λ (h : i ∈ t), F i))
{α : Type u_1} {β : Type u_2} {F : α → β} {C : α} [Linear_ordered_AddCommGroup α] [Archimedean α] (h : Function.Periodic F C) (hc : 0 < C) (x : α) : ∃ (y : α) (h : y ∈ set.Ico 0 C), F x = F y
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [OrderedSemiring 𝕜] [AddCommGroup E] [module 𝕜 E] {P : ι → E} (hc : Convex_Independent 𝕜 P) (S : set ι) : Convex_Independent 𝕜 (λ (i : ↥S), P ↑i)
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} (h : InnerProductGeometry.angle x y = 0) : HasInner.inner x y = ∥x∥ * ∥y∥
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] [TopologicalSpace 𝕜] [OrderTopology 𝕜] [Archimedean 𝕜] : DenseRange Coe
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {x y : m} (h : SameRay R x y) (hy : y ≠ 0) : ∃ (r : R), 0 ≤ r ∧ x = r • y
{α : Type u} [PseudoMetricSpace α] {S t : set α} : metric.Hausdorff_dist (Closure S) t = metric.Hausdorff_dist S t
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 : P) : HasDist.dist P1 (midpoint ℝ P1 P2) = HasDist.dist P2 (midpoint ℝ P1 P2)
{Γ₀ : Type u_3} [Linear_ordered_CommMonoid_with_Zero Γ₀] [Nontrivial Γ₀] {K : Type u_1} [DivisionRing K] (v : Valuation K Γ₀) {x : K} : ⇑v x = 0 ↔ x = 0
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] [NoZeroSmulDivisors R m] (x : module.Ray R m) : x ≠ -x
(A : Zmod 8) : ⇑Zmod.χ₈' A = 0 ∨ ⇑Zmod.χ₈' A = 1 ∨ ⇑Zmod.χ₈' A = -1
{α : Type u_2} {β : Type u_3} [Linear_ordered_Field α] [Linear_ordered_Field β] [Archimedean β] : Subsingleton (α ≃+*o β)
{α : Type u} (L : List α) {i j : ℕ} (h : j < (List.Drop i L).length) : (List.Drop i L).nth_LE j h = L.nth_LE (i + j) _
{α : Type u_1} [LinearOrder α] (A : α) : {A}.min' _ = A
{x : ℝ} (n : ℕ) (m : ℤ) (hxr : x ^ n = ↑m) (hv : ¬∃ (y : ℤ), x = ↑y) (hnpos : 0 < n) : Irrational x
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} (P : ι → P) (i0 : ι) : Vector_Span k (set.Range P) = Submodule.Span k (set.Range (λ (i : ι), P i0 -ᵥ P i))
{x Y : Type u} (F : x ⟶ Y) : CategoryTheory.IsIso F ↔ Function.Bijective F
{x : Type u_1} {Y : Type u_2} [NormedGroup x] [NormedGroup Y] [NormedSpace ℝ x] [NormedSpace ℝ Y] {F : x → Y} {x : x} : ConformalAt F x ↔ IsConformalMap (fderiv ℝ F x)
(F : ℝ → ℝ) {A B : ℝ} (hab : A < B) (g : ℝ → ℝ) {lfa lga lfb lgb : ℝ} (hdf : DifferentiableOn ℝ F (set.Ioo A B)) (hdg : DifferentiableOn ℝ g (set.Ioo A B)) (hfa : Filter.Tendsto F (nhds_within A (set.ioi A)) (nhds lfa)) (hga : Filter.Tendsto g (nhds_within A (set.ioi A)) (nhds lga)) (hfb : Filter.Tendsto F (nhds_within B (set.Iio B)) (nhds lfb)) (hgb : Filter.Tendsto g (nhds_within B (set.Iio B)) (nhds lgb)) : ∃ (C : ℝ) (h : C ∈ set.Ioo A B), (lgb - lga) * deriv F C = (lfb - lfa) * deriv g C
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [Linear_ordered_Field 𝕜] [AddCommGroup E] [module 𝕜 E] {P : ι → E} : Convex_Independent 𝕜 P ↔ ∀ (S : Finset ι) (x : ι), P x ∈ ⇑(Convex_hull 𝕜) ↑(Finset.image P S) → x ∈ S
 : Filter.Tendsto Coe Filter.cofinite (Filter.cocompact ℝ)
{η : Type u_5} {F : η → Type u_6} [Π (i : η), AddGroup (F i)] [DecidableEq η] [Fintype η] {h : Π (i : η), Add_Subgroup (F i)} {J : Add_Subgroup (Π (i : η), F i)} : Add_Subgroup.Pi set.Univ h ≤ J ↔ ∀ (i : η), Add_Subgroup.Map (AddMonoid_hom.single F i) (h i) ≤ J
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_5} [NormedGroup E'] [NormedSpace 𝕜 E'] {n : WithTop ℕ} {F : E → E'} : ContDiff 𝕜 n F → Cont_mdiff (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n F
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {S : set 𝕜} {n : WithTop ℕ} {m : ℕ} (h : ContDiff_on 𝕜 n F S) (hmn : ↑m ≤ n) (hs : UniqueDiffOn 𝕜 S) : Continuous_on (iterated_deriv_within m F S) S
{γ : Type W} [EmetricSpace γ] {S : set γ} (hs : IsCompact S) : ∃ (t : set γ) (h : t ⊆ S), t.countable ∧ S = Closure t
{m : Type u_1} [MulOneClass m] {S t : Submonoid m} (h : ∀ (x : m), x ∈ S ↔ x ∈ t) : S = t
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [Nontrivial R] [Nonempty ι] (e : Basis ι R m) (x : Orientation R m ι) (i : ι) : ⇑(e.adjust_to_Orientation x) i = ⇑e i ∨ ⇑(e.adjust_to_Orientation x) i = -⇑e i
{m : Type u_3} [AddMonoid m] [Preorder m] (L : List m) (h : L.Sum < 0) : 0 < L.length
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (h : ↑(S.topological_Closure) = set.Univ) : ∥S.normed_Mk∥ = 0
{C : Type u} [CategoryTheory.Category C] {x Y : C} (F : x ⟶ Y) (t : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.PullbackCone.Mk (𝟙 x) (𝟙 x) rfl)) : CategoryTheory.Mono F
{α : Type u} {β : Type v} [PseudoMetricSpace α] [Nonempty β] [SemilatticeSup β] {S : β → α} (B : β → ℝ) (h : ∀ (n m N : β), N ≤ n → N ≤ m → HasDist.dist (S n) (S m) ≤ B N) (h₀ : Filter.Tendsto B Filter.at_top (nhds 0)) : Cauchy_Seq S
{x : ℝ} (hx : 0 ≤ x) (y z : ℝ) : x ^ y * x ^ z ≤ x ^ (y + z)
{ι : Type u_1} {m : Type u_4} {N : Type u_5} [AddCommMonoid m] [ordered_AddCommMonoid N] (F : m → N) (h_Mul : ∀ (x y : m), F (x + y) ≤ F x + F y) {S : Finset ι} (hs : S.Nonempty) (g : ι → m) : F (S.Sum (λ (i : ι), g i)) ≤ S.Sum (λ (i : ι), F (g i))
(n : ℕ) : (n + 2).Factors = (n + 2).min_fac :: ((n + 2) / (n + 2).min_fac).Factors
{α : Type u} [Preorder α] {S : set α} {A : α} (h : IsGreatest S A) : BddAbove S
{α : Type u} {β : Type v} [DecidableEq β] [Fintype α] [Fintype β] (F : α → β) {n : ℕ} (hn : Fintype.Card β * n < Fintype.Card α) : ∃ (y : β), n < (Finset.Filter (λ (x : α), F x = y) Finset.Univ).Card
{n m : ℕ} (e : Fin n ≃o Fin m) (i : Fin n) : ↑(⇑e i) = ↑i
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LT.LT] {A B : α} (ha : 0 < A) (hb : 0 < B) : 0 < A + B
{α : Type u_1} {ι : sort u_2} (m : ι → MeasureTheory.OuterMeasure α) {S : set α} (hs : S.Nonempty) : (⇑⨅ (i : ι), m i) S = ⨅ (t : ℕ → set α) (h2 : S ⊆ set.Union t), ∑' (n : ℕ), ⨅ (i : ι), ⇑(m i) (t n)
{m : Type u_1} [AddMonoid m] : _Add_Submonoid set.Univ
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : set P} (h : S.Finite) : Finite_dimensional k ↥((affine_Span k S).direction)
{α : Type u_1} {β : Type u_2} {F : α → β} (hF : Function.Injective F) : Function.Injective (Option.Map F)
(S : ℝ) : Filter.Tendsto (λ (x : ℝ), Real.Exp x / x ^ S) Filter.at_top Filter.at_top
{G : Type u_2} [Group G] : MulAction.FixedPoints (ConjAct G) G = ↑(Subgroup.Center G)
{α : Type u_1} [conditionally_CompleteLattice α] {S t : set α} (hs : BddAbove S) (sne : S.Nonempty) (ht : BddAbove t) (tne : t.Nonempty) : HasSup.Sup (S ∪ t) = HasSup.Sup S ⊔ HasSup.Sup t
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] (P : P) : EuclideanGeometry.Orthogonal_projection_fn S P -ᵥ P ∈ (S.direction)ᗮ
{β : Type u} {α : Type v} [AddCommMonoid β] {S : Finset α} (F : α → β) : Mul_Opposite.Op (S.Sum (λ (x : α), F x)) = S.Sum (λ (x : α), Mul_Opposite.Op (F x))
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {F : α → β} {S : set α} {x : α} (h : Continuous_within_at F S x) : Filter.Tendsto F (nhds_within x S) (nhds (F x))
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [DecidableEq γ] (S : Finset α) (t : Finset β) (F : α × β → Finset γ) : (S.Product t).bUnion F = S.bUnion (λ (A : α), t.bUnion (λ (B : β), F (A, B)))
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {F : α → β} : StrictMono F → StrictAnti (⇑order_dual.to_dual ∘ F)
{α : Type u} [Preorder α] {A B C : α} : B ≤ C → A = B → A ≤ C
{α : Type u} {β : Type v} [AddCommMonoid β] (S : Finset α) (F : Finset α → β) : S.powerset.Sum (λ (t : Finset α), F t) = (Finset.Range (S.Card + 1)).Sum (λ (j : ℕ), (Finset.powerset_len j S).Sum (λ (t : Finset α), F t))
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] [CompleteSpace 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [Finite_dimensional 𝕜 F] {F : E → F} {F' : E →L[𝕜] F} {A : E} (hF : HasStrictFderivAt F F' A) (hF' : F'.Range = ⊤) {α : Type u_4} {l : Filter α} {g₁ : α → F} {g₂ : α → ↥(F'.Ker)} (h₁ : Filter.Tendsto g₁ l (nhds (F A))) (h₂ : Filter.Tendsto g₂ l (nhds 0)) : Filter.Tendsto (λ (t : α), HasStrictFderivAt.implicit_Function F F' hF hF' (g₁ t) (g₂ t)) l (nhds A)
{α : Type u_3} {β : Type u_4} [Nonempty α] [SemilatticeSup α] [Preorder β] {F : α → β} (hF : Monotone F) : Filter.Tendsto F Filter.at_top Filter.at_top ↔ ∀ (B : β), ∃ (A : α), B ≤ F A
{R : Type u₁} [Linear_ordered_Ring R] {A : R} (h : -2 ≤ A) (n : ℕ) : 1 + ↑n * A ≤ (1 + A) ^ n
{α : Type u} [Group α] [has_LE α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A : α} : 1 ≤ A⁻¹ → A ≤ 1
{α : Type u_1} {m : Type u_4} [has_Zero m] {S : set α} {F : α → m} {A : α} (h : S.indicator F A ≠ 0) : A ∈ S
{R : Type u_1} [CommMonoid_with_Zero R] (F : Nat.ArithmeticFunction R) (hF : F.Multiplicative) (g : Nat.ArithmeticFunction R) (hg : g.Multiplicative) : F = g ↔ ∀ (P i : ℕ), Nat.Prime P → ⇑F (P ^ i) = ⇑g (P ^ i)
{ι : Type u} {γ : Type W} {β : ι → Type v} [dec : DecidableEq ι] [Π (i : ι), AddZeroClass (β i)] [AddCommMonoid γ] (F : Π (i : ι), β i →+ γ) (i : ι) : (⇑Dfinsupp.Lift_Add_hom F).Comp (Dfinsupp.single_Add_hom β i) = F i
{α : Type u_1} {R : Type u_2} {l : Filter α} {F : α → R} {r : R} [Linear_ordered_Ring R] [Archimedean R] (hr : r < 0) (hF : Filter.Tendsto F l Filter.at_IsBot) : Filter.Tendsto (λ (x : α), F x * r) l Filter.at_top
{K : Type u_1} {n : ℕ} {g : GeneralizedContinuedFraction K} [Field K] (nth_Part_denom_Ne_Zero : ∀ {B : K}, g.partial_denominators.nth n = Option.Some B → B ≠ 0) : g.convergents (n + 1) = (g.squash_gcf n).convergents n
{R : Type u_1} [CommRing R] [IsDomain R] {A B C : R} (h2 : 2 ≠ 0) (ha : A ≠ 0) (x : R) : A * x * x + B * x + C = 0 ↔ discrim A B C = (2 * A * x + B) ^ 2
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {v : K} {n : ℕ} : GeneralizedContinuedFraction.Int_fract_pair.Stream v (n + 1) = Option.None ↔ GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.None ∨ ∃ (ifp : GeneralizedContinuedFraction.Int_fract_pair K), GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.Some ifp ∧ ifp.fr = 0
{α : Type u_1} (F : α → α → α) [IsAssociative α F] (x y : α) : F x ∘ F y = F (F x y)
{m₀ : Type u_1} [Mul_Zero_class m₀] : (λ (_x : m₀), _x * 0) = Function.Const m₀ 0
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {F : ℂ → E} (hD : Diff_Cont_on_cl ℂ F {z : ℂ | 0 < z.re}) (hexp : ∃ (C : ℝ) (h : C < 2) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hre : Asymptotics.SuperpolynomialDecay Filter.at_top Real.Exp (λ (x : ℝ), ∥F ↑x∥)) (him : ∃ (C : ℝ), ∀ (x : ℝ), ∥F (↑x * Complex.i)∥ ≤ C) : set.Eq_on F 0 {z : ℂ | 0 ≤ z.re}
{E : Type u_1} [AddCommGroup E] [module ℝ E] [TopologicalSpace E] [has_Continuous_Smul ℝ E] {F : Type u_2} [AddCommGroup F] [module ℝ F] [TopologicalSpace F] [has_Continuous_Smul ℝ F] [t2_Space F] (F : E →+ F) (hF : Continuous ⇑F) (C : ℝ) (x : E) : ⇑F (C • x) = C • ⇑F x
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {J : Type W} [CategoryTheory.Category J] (K : J ⥤ C) (F : C ⥤ D) [CategoryTheory.Limits.HasLimit (K ⋙ F)] [CategoryTheory.CreatesLimit K F] : CategoryTheory.Limits.HasLimit K
(n : ℕ) (R : Type u_1) [Ring R] : (Polynomial.cyclotomic n R).monic
{A B : Prop} : ¬(A ∧ B) ↔ ¬A ∨ ¬B
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} {A : α} {S : set α} (h : A ∉ S → F A = 0) : finsum (λ (i : α), finsum (λ (h : i ∈ HasInsert.Insert A S), F i)) = finsum (λ (i : α), finsum (λ (h : i ∈ S), F i))
{α : Type u_1} {β : Type u_2} [PseudoMetricSpace α] [PseudoMetricSpace β] {K : Nnreal} {F : α → β} : AntilipschitzWith K F → ∀ (x y : α), HasNndist.nndist x y ≤ K * HasNndist.nndist (F x) (F y)
(x : ℂ) : HasStrictDerivAt Complex.cosh (Complex.sinh x) x
{m : Type u_1} [Monoid m] (u : mˣ) (A : m) : IsUnit (↑u * A) ↔ IsUnit A
{R : Type u_1} [CommRing R] : set.surj_on (λ (g : Matrix.special_Linear_Group (Fin 2) R), ↑g 1) set.Univ {cd : Fin 2 → R | _IsCoprime (cd 0) (cd 1)}
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A B : α} (ha : 1 < A) (hb : 1 < B) : 1 < A * B
{α : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} [LinearOrder ι] {F : MeasureTheory.Filtration ι m} {τ : α → ι} [TopologicalSpace ι] [OrderTopology ι] [TopologicalSpace.first_countable_topology ι] (hτ : MeasureTheory.IsStoppingTime F τ) (i : ι) (h_IsLub : IsLub (set.Iio i) i) : Measurable_set {x : α | τ x < i}
{α : Type u} {β : Type v} [Semiring α] [Semiring β] {F : α → β} (hF : _Semiring_hom F) {γ : Type u_1} [Semiring γ] {g : β → γ} (hg : _Semiring_hom g) : _Semiring_hom (g ∘ F)
{α : Type u_1} {ι : Type u_3} [CompleteLattice α] [Fintype ι] {F : ι → α} : CompleteLattice.Independent F → Finset.Univ.Sup_indep F
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (ha : Continuous_at F A) (hb : Continuous_at F B) : HasFderivAt (λ (P : ℝ × ℝ), ∫ (x : ℝ) in P.fst..P.Snd, F x) ((Continuous_Linear_Map.Snd ℝ ℝ ℝ).Smul_Right (F B) - (Continuous_Linear_Map.fst ℝ ℝ ℝ).Smul_Right (F A)) (A, B)
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.CosimplicialObject C) {n : ℕ} {i : Fin (n + 2)} : x.δ i ≫ x.δ (⇑Fin.cast_Succ i) = x.δ i ≫ x.δ i.Succ
{m : Type u_1} [has_Add m] {r S : m → m → Prop} (h : ∀ (x y : m), r x y → S x y) : Add_Con_gen r ≤ Add_Con_gen S
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (𝕜 : Type u_3) [DivisionRing 𝕜] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.Linear 𝕜 C] {x Y : C} [CategoryTheory.Simple x] [CategoryTheory.Simple Y] (h : (x ≅ Y) → False) : Finite_dimensional.finrank 𝕜 (x ⟶ Y) = 0
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) (B : n → α) (h : IsUnit A.det) : A.det • Matrix.vec_Mul B A⁻¹ = ⇑(A.transpose.cramer) B
{α : Type u_1} [LinearOrder α] {S : set α} : ¬BddBelow S ↔ ∀ (x : α), ∃ (y : α) (h : y ∈ S), y < x
{k : ℕ} : Fact (Even (Fintype.Card (Fin (bit0 k))))
{n : ℕ} (hn : n % 2 = 1) : ⇑Zmod.χ₄ ↑n = (-1) ^ (n / 2)
{ι : Type u_1} {R₂ : Type u_7} {m₂ : Type u_8} [CommRing R₂] [AddCommGroup m₂] [module R₂ m₂] [DecidableEq ι] (e : Basis ι R₂ m₂) (W : ι → R₂ˣ) : e.to_Matrix ⇑(e.units_Smul W) = Matrix.Diagonal (Coe ∘ W)
{α : Type u} [TopologicalSpace α] {S : set α} {ι : Type v} (hs : IsCompact S) (Z : ι → set α) (hZc : ∀ (i : ι), IsClosed (Z i)) (hsZ : (S ∩ ⋂ (i : ι), Z i) = ∅) : ∃ (t : Finset ι), (S ∩ ⋂ (i : ι) (h : i ∈ t), Z i) = ∅
(l : List ℕ) (n : ℕ) : List.Sorted has_LE.LE (Denumerable.raise l n)
{J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ Mon_) [CategoryTheory.IsFiltered J] (j : J) : 1 = Mon_.FilteredColimits.m.Mk F ⟨j, 1⟩
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {v : K} {n : ℕ} {ifp_Succ_n : GeneralizedContinuedFraction.Int_fract_pair K} (Stream_Succ_nth_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream v (n + 1) = Option.Some ifp_Succ_n) : (GeneralizedContinuedFraction.of v).S.nth n = Option.Some {A := 1, B := ↑(ifp_Succ_n.B)}
(𝕜 : Type u_1) {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} [LinearOrder ι] [OrderBot ι] [locally_Finite_order ι] [IsWellOrder ι has_LT.LT] [SuccOrder ι] [IsSuccArchimedean ι] (F : ι → E) (h₀ : LinearIndependent 𝕜 F) : Orthonormal 𝕜 (gram_schmidt_normed 𝕜 F)
{G : Type u_1} [Group G] {N : Type u_2} [Group N] (F : G →* N) (hF : Function.Surjective ⇑F) : F.Range = ⊤
{R : Type u_1} {A : R} [Mul_Zero_class R] [Nontrivial R] (ra : IsRightRegular A) : A ≠ 0
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {n : WithTop ℕ} {F : E → F} (hF : ContDiff_at 𝕜 n F x) : ContDiff_at 𝕜 n (λ (x : E), -F x) x
{α : Type u_1} {β : sort u_2} {γ : sort u_3} {S : set α} (e : β ≃ ↥S) (v : β → γ) (W : α → γ) (j : β) (x : γ) [DecidableEq β] [DecidableEq α] [Π (j : α), Decidable (j ∈ S)] : (λ (i : α), dite (i ∈ S) (λ (h : i ∈ S), Function.update v j x (⇑(e.Symm) ⟨i, h⟩)) (λ (h : i ∉ S), W i)) = Function.update (λ (i : α), dite (i ∈ S) (λ (h : i ∈ S), v (⇑(e.Symm) ⟨i, h⟩)) (λ (h : i ∉ S), W i)) ↑(⇑e j) x
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {C : Con m} {F : m →* P} (h : C ≤ Con.Ker F) (x : m) : ⇑(C.Lift F h) ↑x = ⇑F x
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x : v) {r : ℝ} : 2 • o.oangle (r • x) x = 0
{G : Type u_6} {h : Type u_7} {F : Type u_8} [AddGroup G] [subtraction_Monoid h] [AddMonoid_hom_class F G h] (F : F) (A B : G) : ⇑F (A + -B) = ⇑F A + -⇑F B
{α : Type u} [TopologicalSpace α] [t2_Space α] (h : TopologicalSpace._topological_Basis {S : set α | IsClopen S}) : TotallySeparatedSpace α
{α : Type uu} (A : α) {l₁ l₂ : List α} : A :: l₁ <+~ A :: l₂ → l₁ <+~ l₂
{m : Type u_3} {F : Type u_8} {G : Type u_1} [Group G] [Monoid m] [Monoid_hom_class F G m] {F g : F} {x : G} (h : ⇑F x = ⇑g x) : ⇑F x⁻¹ = ⇑g x⁻¹
{α : Type u} [PseudoMetricSpace α] {S : set α} [CompactSpace α] : Metric.Bounded S
{x : Type u_2} [EmetricSpace x] {m₁ m₂ : Ennreal → Ennreal} (hle : m₁ ≤ᶠ[nhds_within 0 (set.ici 0)] m₂) : MeasureTheory.OuterMeasure.Mk_metric m₁ ≤ MeasureTheory.OuterMeasure.Mk_metric m₂
{v : Type u} [CategoryTheory.Category v] [CategoryTheory.Limits.HasZeroMorphisms v] {A B C : v} {F : A ⟶ B} [CategoryTheory.Limits.HasImage F] {g : B ⟶ C} [CategoryTheory.Limits.HasKernel g] (W : F ≫ g = 0) {A' B' C' : v} {F' : A' ⟶ B'} [CategoryTheory.Limits.HasImage F'] {g' : B' ⟶ C'} [CategoryTheory.Limits.HasKernel g'] (W' : F' ≫ g' = 0) (α : CategoryTheory.Arrow.Mk F ⟶ CategoryTheory.Arrow.Mk F') [CategoryTheory.Limits.HasImage_Map α] (β : CategoryTheory.Arrow.Mk g ⟶ CategoryTheory.Arrow.Mk g') (P : α.Right = β.Left) : image_to_Kernel F g W ≫ CategoryTheory.Limits.Kernel_Subobject_Map β = CategoryTheory.Limits.image_Subobject_Map α ≫ image_to_Kernel F' g' W'
{k : Type u_1} {v1 : Type u_2} {P1 : Type u_3} {v2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] [AddCommGroup v2] [module k v2] [AddTorsor v2 P2] {F g : P1 →ᵃ[k] P2} (h : ∀ (P : P1), ⇑F P = ⇑g P) : F = g
{α : Type u_1} [Preorder α] [locally_Finite_order α] {A B : α} : ¬A < B → Finset.ioc A B = ∅
{E : Type u_1} [NormedGroup E] {F : ℂ → E} {C : ℂ} {R : ℝ} [NormedSpace ℂ E] (hF : CircleIntegrable F C R) : IntervalIntegrable (λ (θ : ℝ), deriv (Circle_Map C R) θ • F (Circle_Map C R θ)) MeasureTheory.MeasureSpace.Volume 0 (2 * Real.Pi)
{α : Type u_1} (C : set (set α)) (hc : Setoid._Partition C) : (Setoid.Mk_Classes C _).Classes = C
{α : Type u} [Group α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A B C : α} : B < A⁻¹ * C → A * B < C
{α : Type u_1} {S t : set α} : Disjoint S t → Disjoint (Filter.principal S) (Filter.principal t)
{α : Type u_1} {l : List α} : l <+: List.Nil → l = List.Nil
{α : Type u_1} {m : Type u_5} {N : Type u_7} [AddZeroClass m] [AddCommMonoid N] {F g : α →₀ m} {h : α → m → N} (h_Zero : ∀ (A : α), A ∈ F.Support ∪ g.Support → h A 0 = 0) (h_Add : ∀ (A : α), A ∈ F.Support ∪ g.Support → ∀ (B₁ B₂ : m), h A (B₁ + B₂) = h A B₁ + h A B₂) : (F + g).Sum h = F.Sum h + g.Sum h
(α : Type u) [Semiring α] [Nontrivial α] : ∃ (m : Ideal α), m.IsMaximal
{α : Type u_1} {ι : sort u_4} [CompleteLattice α] {B : α} {F : ι → α} (h₁ : ∀ (i : ι), B ≤ F i) (h₂ : ∀ (W : α), B < W → (∃ (i : ι), F i < W)) : (⨅ (i : ι), F i) = B
(x : ℝ) : 0 < Real.cosh x
{n P : ℕ} (hp : Nat.Prime P) : multiplicity P (P * (n + 1)).factorial = multiplicity P (P * n).factorial + multiplicity P (n + 1) + 1
{𝕂 : Type u_1} [nondiscrete_NormedField 𝕂] [CompleteSpace 𝕂] [CharZero 𝕂] {x : 𝕂} (hx : x ∈ Emetric.Ball 0 (Exp_series 𝕂 𝕂).radius) : HasDerivAt (Exp 𝕂) (Exp 𝕂 x) x
{R : Type u_1} [MulOneClass R] : IsRegular 1
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} [Nontrivial k] {P : ι → P} (ha : AffineIndependent k P) : Function.Injective P
{A B C : ℤ} (h : fermat_42 A B C) : ∃ (A0 B0 C0 : ℤ), fermat_42.Minimal A0 B0 C0 ∧ A0 % 2 = 1 ∧ 0 < C0
{α : Type u_1} {β : Type u_2} [has_Add α] [Preorder α] [Preorder β] [CovariantClass α α has_Add.Add has_LT.LT] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {F g : β → α} (hF : Monotone F) (hg : StrictMono g) : StrictMono (λ (x : β), F x + g x)
(P : ℕ) [hp : Fact (Nat.Prime P)] {n i j : ℕ} (hi : i < n) (hj : j < P ^ (n - i)) : j - pnat_multiplicity P ⟨j + 1, _⟩ + n = i + j + (n - i - pnat_multiplicity P ⟨j + 1, _⟩)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {n : ℕ} (S : Affine.Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ℕ} (h : fs.Card = m + 1) (i : Fin (m + 1)) : (S.face h).points i = S.points (⇑(fs.order_emb_of_Fin h) i)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (P : ι → P) : (S.affine_combination P).Linear = S.weighted_vsub P
{α : Type u} (ls : List (List α)) [DecidableEq α] (x : α) (hx : ∀ (l : List α), l ∈ ls → x ∉ l) (hls : ls ≠ List.Nil) : List.split_on x ([x].intercalate ls) = ls
{β : Type u} {α : Type v} {γ : Type W} [AddCommMonoid β] [AddCommMonoid γ] (g : β →+ γ) (F : α → β) (S : Finset α) : ⇑g (S.Sum (λ (x : α), F x)) = S.Sum (λ (x : α), ⇑g (F x))
{C : Type u₁} [CategoryTheory.Category C] {x₁₁ x₁₂ x₂₁ x₂₂ x₃₁ x₃₂ : C} {h₁₁ : x₁₁ ⟶ x₁₂} {h₂₁ : x₂₁ ⟶ x₂₂} {h₃₁ : x₃₁ ⟶ x₃₂} {v₁₁ : x₁₁ ⟶ x₂₁} {v₁₂ : x₁₂ ⟶ x₂₂} {v₂₁ : x₂₁ ⟶ x₃₁} {v₂₂ : x₂₂ ⟶ x₃₂} (S : CategoryTheory.IsPullback h₁₁ v₁₁ v₁₂ h₂₁) (t : CategoryTheory.IsPullback h₂₁ v₂₁ v₂₂ h₃₁) : CategoryTheory.IsPullback h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁
{m₀ : Type u_1} [Monoid_with_Zero m₀] [Nontrivial m₀] (u : m₀ˣ) : ↑u ≠ 0
{C : Type u} [CategoryTheory.Category C] (P q : C) [CategoryTheory.Limits.HasBinaryProduct P q] : CategoryTheory.Limits.HasBinaryProduct q P
 : (Polynomial_Functions Unit_Interval).topological_Closure = ⊤
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (F : C ⥤ D) {x Y Z : C} {F : x ⟶ Y} {g : Y ⟶ Z} [CategoryTheory.Abelian C] [CategoryTheory.Abelian D] [F.Additive] [CategoryTheory.Limits.preserves_Finite_colimits F] [CategoryTheory.Epi g] (ex : CategoryTheory.Exact F g) : CategoryTheory.Exact (F.Map F) (F.Map g)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) {P : P} (hr : ∃ (r : ℝ), ∀ (i : Fin (n + 1)), HasDist.dist (S.points i) P = r) : ↑(⇑(S.Orthogonal_projection_Span) P) = S.circumcenter
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k → E} {A B r : k} (h : 0 < (1 - r) * (B - A)) : F (⇑(affine_Map.line_Map A B) r) < ⇑(affine_Map.line_Map (F A) (F B)) r ↔ slope F A B < slope F (⇑(affine_Map.line_Map A B) r) B
{α : Type u} {β : Type v} : (α ↪ β) → (β ↪ α) → Nonempty (α ≃ β)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h2 : P2 ≠ P1) (h3 : P3 ≠ P1) : EuclideanGeometry.angle P1 P2 P3 + EuclideanGeometry.angle P2 P3 P1 + EuclideanGeometry.angle P3 P1 P2 = Real.Pi
{G : Type u_6} {h : Type u_7} {F : Type u_8} [Group G] [division_Monoid h] [Monoid_hom_class F G h] (F : F) (g : G) (n : ℤ) : ⇑F (g ^ n) = ⇑F g ^ n
{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] {n : Type W} [Nontrivial R] [no_Zero_divisors R] (B : BilinForm R m) (v : Basis n R m) (hO : B._Ortho ⇑v) : B.nondegenerate ↔ ∀ (i : n), ¬B.IsOrtho (⇑v i) (⇑v i)
{x : Type u_1} [TopologicalSpace x] [CompactSpace x] {Y : Type u_2} [TopologicalSpace Y] : IsClosed_Map Prod.Snd
{n : ℕ} : Prime_Pow n ↔ ∃! (P : ℕ), Nat.Prime P ∧ P ∣ n
{α : Type u} (x : α) : Function.IsFixedPt Id x
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {n : WithTop ℕ} : ContDiff 𝕜 n F ↔ HasFtaylorSeriesUpTo n F (ftaylor_series 𝕜 F)
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] (q : QuadraticForm R m) (m : m) : ⇑(clifford_Algebra.ι q) m * ⇑(clifford_Algebra.ι q) m = ⇑(Algebra_Map R (clifford_Algebra q)) (⇑q m)
(𝕜 : Type u_5) (E : Type u_6) [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [Nontrivial E] : NoncompactSpace E
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [nondiscrete_NormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] : Continuous (λ (P : Continuous_MultilinearMap 𝕜 E G × Π (i : ι), E i), ⇑(P.fst) P.Snd)
{G : Type u_1} [AddCommMonoid G] (tG : AddMonoid._torsion G) : AddCommMonoid.Add_torsion G = ⊤
{m : Type u_1} [has_Add m] {C D : Add_Con m} (h : ∀ (x y : m), ⇑C x y ↔ ⇑D x y) : C = D
{K : Type u_4} {L : Type u_5} [Field K] [Field L] [Algebra K L] [Finite_dimensional K L] {x : L} : ⇑(Algebra.norm K) x = 0 ↔ x = 0
{x : ℝ} (h : 0 < x) (h' : x ≤ 1) : x - x ^ 3 / 4 < Real.sin x
{γ : Type W} [MetricSpace γ] {x y : γ} : HasNndist.nndist x y = 0 ↔ x = y
{K : Type u} [Field K] (S : Subfield K) (m : Multiset K) : (∀ (A : K), A ∈ m → A ∈ S) → m.Prod ∈ S
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (G : C ⥤ D) [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.Empty C) G] : CategoryTheory.Limits.HasTerminal D
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B : α} : 0 < A - B → B < A
(P : ℕ) [Fact (Nat.Prime P)] (A : ℤ) (ha : ↑A ≠ 0) : Zmod.legendre_Sym P (A ^ 2) = 1
{α : Type u} (S t : set α) : Cardinal.Mk ↥(S ∪ t) ≤ Cardinal.Mk ↥S + Cardinal.Mk ↥t
{ι : Type u} (S : Finset ι) (F g : ι → Nnreal) {P q : ℝ} (hpq : P.IsConjugateExponent q) : S.Sum (λ (i : ι), F i * g i) ≤ S.Sum (λ (i : ι), F i ^ P) ^ (1 / P) * S.Sum (λ (i : ι), g i ^ q) ^ (1 / q)
{R : Type u} [CommRing R] {P : Ideal R} (h : P.Prime) : IsDomain (Polynomial R ⧸ Ideal.Map Polynomial.C P)
(G : Type u_1) [Monoid G] (L : Type u_2) [CommRing L] [no_Zero_divisors L] : LinearIndependent L (λ (F : G →* L), ⇑F)
{α : Type u} {S : set α} : S.countable → {t : set α | t.Finite ∧ t ⊆ S}.countable
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {ι : Type u_1} (B : Basis ι R m) {κ : Type u_1} (v : κ → m) (i : LinearIndependent R v) : Cardinal.Mk κ ≤ Cardinal.Mk ι
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) [Invertible A] : ⅟ A = A⁻¹
{C D : Type u} [CategoryTheory.Category C] [CategoryTheory.Category D] {A : Type W} [CategoryTheory.Category A] [CategoryTheory.Limits.HasLimits A] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {G : C ⥤ D} (hu : CategoryTheory.CoverLifting J K G) (ℱ : CategoryTheory.sheaf J A) {x : A} {U : D} {S : CategoryTheory.Sieve U} (hS : S ∈ ⇑K U) {x : CategoryTheory.Presieve.FamilyOfElements ((CategoryTheory.ran G.Op).obj ℱ.val ⋙ CategoryTheory.coyoneda.obj (Opposite.Op x)) S.Arrows} (hx : x.compatible) : x._amalgamation (CategoryTheory.ran__sheaf_of_CoverLifting.glued_section hu ℱ hS hx)
(R : Type u_1) [CommRing R] (m : Type u_2) [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] [Nontrivial R] : LinearMap.trace R m = (contract_Left R m).Comp (dual_tensor_hom_Equiv R m m).Symm.to_Linear_Map
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) {r : Nnreal} (h0 : 0 < r) (h : ↑r < P.radius) : ∃ (C : ℝ) (h : C > 0), ∀ (n : ℕ), ∥P n∥ ≤ C / ↑r ^ n
{𝒪 : Type u} {K : Type v} {Γ : Type W} [CommRing 𝒪] [IsDomain 𝒪] [Field K] [Algebra 𝒪 K] [Linear_ordered_comm_Group_with_Zero Γ] (v : Valuation K Γ) (hH : v.integers 𝒪) : Valuation_Ring 𝒪
{β : Type u} {α : Type v} [AddCommMonoid β] [DecidableEq α] (S : Finset α) (F : α → β) {A : α} (h : A ∈ S) : (S.erase A).Sum (λ (x : α), F x) + F A = S.Sum (λ (x : α), F x)
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} : finprod (λ (i : α), finprod (λ (h : i ∈ ∅), F i)) = 1
{α : Type u_1} {n : Type u_3} [DecidableEq n] [has_Zero α] (v : n → α) : (Matrix.Diagonal v).IsSymm
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {S : set E} {F : E → F} {n : WithTop ℕ} (e : G ≃L[𝕜] E) : ContDiff_on 𝕜 n (F ∘ ⇑e) (⇑e ⁻¹' S) ↔ ContDiff_on 𝕜 n F S
{α : Type u_1} {ι : sort u_4} {l : Filter α} {P : ι → Prop} {S : ι → set α} (h : l.has_Basis P S) {v : set α} (hV : v ∈ l) : l.has_Basis (λ (i : ι), P i ∧ S i ⊆ v) S
{α : Type u} [TopologicalSpace α] {S : set α} : IsCompact S ↔ ∀ {ι : Type u} (Z : ι → set α), (∀ (i : ι), IsClosed (Z i)) → (S ∩ ⋂ (i : ι), Z i) = ∅ → (∃ (t : Finset ι), (S ∩ ⋂ (i : ι) (h : i ∈ t), Z i) = ∅)
{α : Type u} [Linear_ordered_Field α] [TopologicalSpace α] [OrderTopology α] : Filter.Tendsto (λ (x : α), x⁻¹) (nhds_within 0 (set.ioi 0)) Filter.at_top
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (t : Affine.Triangle ℝ P) : t.orthocenter = Affine.Simplex.monge_point t
{α : sort u_1} {β : sort u_2} {γ : sort u_3} {g : β → γ} (hg : Function.Injective g) : Function.Injective (Function.Comp g)
(o : Ordinal) : o.to_Pgame.Numeric
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {S : set α} {x : α} {P : Filter ι} {g : ι → α} [TopologicalSpace α] (h : TendstoUniformlyOn F F P S) (hF : Continuous_within_at F S x) (hg : Filter.Tendsto g P (nhds_within x S)) : Filter.Tendsto (λ (n : ι), F n (g n)) P (nhds (F x))
{A B : ℝ} {g' g : ℝ → ℝ} (hab : A ≤ B) (hcont : Continuous_on g (set.icc A B)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo A B → HasDerivAt g (g' x) x) (g'Pos : ∀ (x : ℝ), x ∈ set.Ioo A B → 0 ≤ g' x) : MeasureTheory.IntegrableOn g' (set.ioc A B) MeasureTheory.MeasureSpace.Volume
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) : (S.circumcenter_circumradius.fst ∈ affine_Span ℝ (set.Range S.points) ∧ ∀ (i : Fin (n + 1)), HasDist.dist (S.points i) S.circumcenter_circumradius.fst = S.circumcenter_circumradius.Snd) ∧ ∀ (cccr : P × ℝ), (cccr.fst ∈ affine_Span ℝ (set.Range S.points) ∧ ∀ (i : Fin (n + 1)), HasDist.dist (S.points i) cccr.fst = cccr.Snd) → cccr = S.circumcenter_circumradius
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] {F : α → β} {S : set α} {A : α} (h_Mono : StrictMono_on F S) (hs : S ∈ nhds_within A (set.Iic A)) (hfs : ∀ (B : β), B < F A → (∃ (C : α) (h : C ∈ S), F C ∈ set.Ico B (F A))) : Continuous_within_at F (set.Iic A) A
(A : Type u_1) (B : Type u_2) [Field A] [Ring B] [Algebra A B] [Nontrivial B] : minpoly A 0 = Polynomial.x
{G : Type u_1} [Group G] {ι : sort u_2} (S : ι → Subgroup G) {C : Π (x : G), (x ∈ ⨆ (i : ι), S i) → Prop} (hp : ∀ (i : ι) (x : G) (h : x ∈ S i), C x _) (h1 : C 1 _) (HMul : ∀ (x y : G) (hx : x ∈ ⨆ (i : ι), S i) (hy : y ∈ ⨆ (i : ι), S i), C x hx → C y hy → C (x * y) _) {x : G} (hx : x ∈ ⨆ (i : ι), S i) : C x hx
(x : ℝ) : Real.arsinh (Real.sinh x) = x
(n : ℕ) {A : ℝ} (h : 2 - ((A - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ Real.sqrt_two_Add_series (↑0 / ↑1) n) (h₂ : 1 / 4 ^ n ≤ A) : Real.Pi < A
{α : sort u} {β : sort v} {F : α → β} (hF : Function.Injective F) [Subsingleton β] : Subsingleton α
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] {P : P} (hp : P ∉ S) : HasDist.dist P ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P) ≠ 0
(P : ℕ → ℕ → Prop) (ha : ∀ (A : ℕ), P (A + 1) (A + 1)) (hb : ∀ (B : ℕ), P 0 (B + 1)) (hD : ∀ (A B : ℕ), A < B → P (A + 1) B → P A (B + 1) → P (A + 1) (B + 1)) (A B : ℕ) : A < B → P A B
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P : P) : Function.Injective (λ (_x : P), _x -ᵥ P)
{G : Type u_1} [Group G] [hG : Group.IsNilpotent G] : Nat.Find _ = Group.nilpotency_class G
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} {P : ι → P} (ha : AffineIndependent k P) : AffineIndependent k (λ (x : ↥(set.Range P)), ↑x)
{α : Type u_1} [Preorder α] {A B : α} (h : A < B) : ¬IsMax A
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} {g : ℝ → E} (fdiff : DifferentiableOn ℝ F (set.icc A B)) (gdiff : DifferentiableOn ℝ g (set.icc A B)) (hderiv : set.Eq_on (deriv_within F (set.icc A B)) (deriv_within g (set.icc A B)) (set.Ico A B)) (hi : F A = g A) (y : ℝ) (h : y ∈ set.icc A B) : F y = g y
{G : Type u_7} [Group G] (L : List G) : (L.Prod)⁻¹ = (List.Map (λ (x : G), x⁻¹) L).reverse.Prod
{α : Type u_1} {β : Type u_2} {F : α → β} {m : MeasurableSpace α} [TopologicalSpace β] [TopologicalSpace.pseudo_metrizable_Space β] [MeasurableSpace β] [BorelSpace β] : MeasureTheory.strongly_Measurable F ↔ Measurable F ∧ TopologicalSpace._IsSeparable (set.Range F)
{n : ℕ} : order_of (Quaternion_Group.A 1) = 2 * n
{α : Type u_1} [TopologicalSpace α] {x : α} {γ : Type u_4} [Linear_ordered_AddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] {F g : α → γ} (hF : UpperSemicontinuous_at F x) (hg : UpperSemicontinuous_at g x) (hcont : Continuous_at (λ (P : γ × γ), P.fst + P.Snd) (F x, g x)) : UpperSemicontinuous_at (λ (z : α), F z + g z) x
{R : Type u_1} [CommSemiring R] {m : Submonoid R} {S : Type u_2} [CommSemiring S] [Algebra R S] {P : Type u_3} [CommSemiring P] [IsLocalization m S] {g : R →+* P} (hg : ∀ (y : ↥m), IsUnit (⇑g ↑y)) (x : R) (y : ↥m) : ⇑(IsLocalization.Lift hg) (IsLocalization.Mk' S x y) = ⇑g x * ↑(⇑(IsUnit.Lift_Right (g.to_Monoid_hom.Restrict m) hg) y)⁻¹
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {F : ℂ → E} (hD : Diff_Cont_on_cl ℂ F (set.Iio 0 ×ℂ set.Iio 0)) (hB : ∃ (C : ℝ) (h : C < 2) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal (set.Iio 0 ×ℂ set.Iio 0)] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hre : ∀ (x : ℝ), x ≤ 0 → F ↑x = 0) (him : ∀ (x : ℝ), x ≤ 0 → F (↑x * Complex.i) = 0) : set.Eq_on F 0 {z : ℂ | z.re ≤ 0 ∧ z.im ≤ 0}
{α : Type u_1} {G : Type u_4} [conditionally_CompleteLattice α] [Group G] (F₁ F₂ : G →* α ≃o α) (hbdd : ∀ (x : α), BddAbove (set.Range (λ (g : G), ⇑(⇑F₁ g)⁻¹ (⇑(⇑F₂ g) x)))) (g : G) : Function.Semiconj (λ (x : α), ⨆ (g' : G), ⇑(⇑F₁ g')⁻¹ (⇑(⇑F₂ g') x)) ⇑(⇑F₂ g) ⇑(⇑F₁ g)
{R : Type u_1} {A : Type u_2} {m : Type u_3} {N : Type u_4} {P : Type u_5} [CommSemiring R] [Semiring A] [Algebra R A] [AddCommMonoid m] [module R m] [module A m] [IsScalarTower R A m] [AddCommMonoid N] [module R N] [AddCommMonoid P] [module R P] [module A P] [IsScalarTower R A P] : Function.Injective TensorProduct.Algebra_tensor_module.Curry
{C : Type u} [CategoryTheory.Category C] {x : C} (i : CategoryTheory.Arrow C) : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.Mk (𝟙 x))
{α : Type u} [SemilatticeSup α] [Nonempty α] (S : Finset α) : BddAbove ↑S
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : (Matrix n n α)ˣ) : ↑A⁻¹ = (↑A)⁻¹
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommGroup β] [HasScalar 𝕜 E] [module 𝕜 β] {S : set E} {F : E → β} : Convex_on 𝕜 S (-F) ↔ ConcaveOn 𝕜 S F
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] {m₁ m₂ : Ennreal → Ennreal} (hle : m₁ ≤ᶠ[nhds_within 0 (set.ici 0)] m₂) : MeasureTheory.Measure.Mk_metric m₁ ≤ MeasureTheory.Measure.Mk_metric m₂
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S : AffineSubspace k P} (h : ↑S.Nonempty) : S.direction = ⊤ ↔ S = ⊤
{G : Type u_1} [AddGroup G] {k : set G} : k ⊆ ↑(Add_Subgroup.Closure k)
{C : Type u} [CategoryTheory.Category C] {A B : C} {F g : A ⟶ B} [CategoryTheory.IsReflexivePair F g] : CategoryTheory.IsReflexivePair g F
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {C : Con m} {F : m →* P} (h : C ≤ Con.Ker F) : (C.Lift F h).Comp C.Mk' = F
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) : S.normed_Mk.Ker = S
{α : Type u_1} [non_unital_semi_NormedRing α] (x y : α) : ∥⇑(AddMonoid_hom.Mul_Right x) y∥ ≤ ∥x∥ * ∥y∥
{R : Type u} [CommRing R] {n : ℕ} (u : Rˣ) (hn : IsUnit ↑n) : (Polynomial.x ^ n - ⇑Polynomial.C ↑u).IsSeparable
{α : sort u_1} (x : α) (h : ∀ (y : α), y = x) : Subsingleton α
{α : Type u_1} (L : List (List α)) (i : ℕ) : List.take (List.take i (List.Map List.length L)).Sum L.Join = (List.take i L).Join
{K : Type u_1} {Kₘ : Type u_2} [Field K] [CommRing Kₘ] {m : Submonoid K} (hM : 0 ∉ m) [Algebra K Kₘ] [IsLocalization m Kₘ] : Function.Bijective ⇑(Algebra_Map K Kₘ)
{R₁ : Type u_1} {R₂ : Type u_2} [Semiring R₁] [Semiring R₂] {σ₁₂ : R₁ →+* R₂} {m₁ : Type u_4} [TopologicalSpace m₁] [AddCommMonoid m₁] {m₂ : Type u_6} [TopologicalSpace m₂] [AddCommMonoid m₂] [module R₁ m₁] [module R₂ m₂] [t2_Space m₂] {S : set m₁} (hs : Dense ↑(Submodule.Span R₁ S)) {F g : m₁ →sl[σ₁₂] m₂} (h : set.Eq_on ⇑F ⇑g S) : F = g
{m : Type u_1} [AddMonoid m] {S : set m} {A : m} (hs : _Add_Submonoid S) (h : A ∈ S) {n : ℕ} : n • A ∈ S
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {x : L} : x ∈ S → x⁻¹ ∈ S
{x : Type u_1} [UniformSpace x] {S : set x} [(Uniformity x)._countably_generated] : IsCompact S ↔ _Seq_IsCompact S
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (x : module.Ray R m) : ⟦x.Some_Ray_Vector⟧ = x
{α : Type u_1} [TopologicalSpace α] {γ : Type u_4} [Linear_ordered_AddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] [has_Continuous_Add γ] {F g : α → γ} (hF : LowerSemicontinuous F) (hg : LowerSemicontinuous g) : LowerSemicontinuous (λ (z : α), F z + g z)
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A B : α} (ha : 1 < A) (hb : 1 ≤ B) : 1 < A * B
{α : Type u_1} {β : Type u_2} {F g : α → β} {m : MeasurableSpace α} {mβ : MeasurableSpace β} {P : α → Prop} {_x : Decidable_Pred P} (hp : Measurable_set {A : α | P A}) (hF : Measurable F) (hg : Measurable g) : Measurable (λ (x : α), Ite (P x) (F x) (g x))
{α : Type u} [TopologicalSpace α] (A : α) : (nhds A).has_Basis (λ (S : set α), A ∈ S ∧ IsOpen S) (λ (S : set α), S)
{α : Type u_1} {β : Type u_2} {F : α → β} {C : α} [Linear_ordered_AddCommGroup α] [Archimedean α] (h : Function.Periodic F C) (hc : 0 < C) (x A : α) : ∃ (y : α) (h : y ∈ set.Ico A (A + C)), F x = F y
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {v₂ : Type u_5} {P₂ : Type u_6} [AddCommGroup v₂] [module k v₂] [AddTorsor v₂ P₂] {S : set P} (e : P ≃ᵃ[k] P₂) : AffineIndependent k Coe ↔ AffineIndependent k Coe
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (x : CategoryTheory.SimplicialObject C) (n : ℕ) : AlgebraicTopology.alternating_face_Map_Complex.obj_D x (n + 1) ≫ AlgebraicTopology.alternating_face_Map_Complex.obj_D x n = 0
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] {v : E} : ↑(⇑(Orthogonal_projection K) v) = v ↔ v ∈ K
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : α → E} {g' : α → F'} {l : Filter α} : (F =O[l] λ (x : α), ∥g' x∥) → F =O[l] g'
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] (x : C) (h : ∀ {Z : C} (F : x ⟶ Z) [_inst_3 : CategoryTheory.Epi F], CategoryTheory.IsIso F ↔ F ≠ 0) : CategoryTheory.Simple x
{R : Type u_1} {S : Type u_2} [EuclideanDomain R] [CommRing S] [IsDomain S] [Algebra R S] (abv : AbsoluteValue R ℤ) {ι : Type u_5} [DecidableEq ι] [Fintype ι] (bS : Basis ι R S) {t : Type u_3} [Linear_ordered_Ring t] (A : S) {y : t} (hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) A) k)) < y) : ↑(⇑abv (⇑(Algebra.norm R) A)) < ↑(class_Group.norm_bound abv bS) * y ^ Fintype.Card ι
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (S : Finset ι) [CharZero k] [Fintype ι] {n : ℕ} (h : S.Card = n + 1) : Finset.Univ.Sum (λ (i : ι), Finset.centroid_weights_indicator k S i) = 1
{m : Type u_1} [AddMonoid m] {S₁ S₂ : set m} (₁ : _Add_Submonoid S₁) (₂ : _Add_Submonoid S₂) : _Add_Submonoid (S₁ ∩ S₂)
{m : Type u_1} [has_Mul m] {C D : Con m} : Setoid.r = Setoid.r ↔ C = D
{α : Type u_1} {β : Type u_2} {α₂ : Type u_3} [Semiring β] [has_Mul α] [has_Mul α₂] {F : Type u_4} [Mul_hom_class F α α₂] (F : F) (x y : Monoid_Algebra β α) : Finsupp.Map_IsDomain ⇑F (x * y) = Finsupp.Map_IsDomain ⇑F x * Finsupp.Map_IsDomain ⇑F y
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {x y : m} : SameRay R (-x) (-y) ↔ SameRay R x y
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {D : Type u₁} [CategoryTheory.Category D] (h : C ≌ D) : CategoryTheory.IsFiltered D
{P : Polynomial ℚ} (P_irr : Irreducible P) (P_deg : Nat.Prime P.Nat_degree) (P_roots1 : Fintype.Card ↥(P.root_set ℝ) + 1 ≤ Fintype.Card ↥(P.root_set ℂ)) (P_roots2 : Fintype.Card ↥(P.root_set ℂ) ≤ Fintype.Card ↥(P.root_set ℝ) + 3) : Function.Bijective ⇑(Polynomial.Gal.Gal_action_hom P ℂ)
{G : Type u_1} [Linear_ordered_AddCommGroup G] [Archimedean G] {h : Add_Subgroup G} {A : G} (ha : IsLeast {g : G | g ∈ h ∧ 0 < g} A) : h = Add_Subgroup.Closure {A}
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LT.LT] {A B : α} (ha : A < 0) (hb : B < 0) : A + B < 0
{m : ℕ} (hm : 0 < m) (k : ℕ) : ∃ (P : ℕ), Liouville.Liouville_number_initial_terms ↑m k = ↑P / ↑m ^ k.factorial
{α : Type u_1} [has_LE α] {A : αᵒᵈ} : _IsBot A → _top (⇑order_dual.of_dual A)
{J : Type v} {C : Type u} [CategoryTheory.Category C] {x Y : C} {F : J → (x ⟶ Y)} [Nonempty J] {t : CategoryTheory.Limits.Trident F} (ht : CategoryTheory.Limits.IsLimit t) {Z Z' : C} (q : Z' ⟶ Z) (k : Z ⟶ t.x) : ↑(⇑(CategoryTheory.Limits.Trident._Limit.hom_is_iso ht Z') (q ≫ k)) = q ≫ ↑(⇑(CategoryTheory.Limits.Trident._Limit.hom_is_iso ht Z) k)
{α : Type u_1} {β : Type u_2} [LinearOrder α] [PredOrder α] [Preorder β] {F : α → β} (hF : Monotone F) : Pairwise (Disjoint on λ (n : α), set.Ico (F (Order.Pred n)) (F n))
{β : Type u} {γ : Type W} [CommSemiring β] [CommSemiring γ] (F : β →+* γ) (S : Multiset β) : ⇑F S.Prod = (Multiset.Map ⇑F S).Prod
{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), Monoid (Gs i)] {x : Π (i : η), Gs i} (h : _of_Fin_order x) (i : η) : _of_Fin_order (x i)
{α : Type u_3} {β : Type u_4} [Linear_ordered_Field α] {l : Filter β} {F : β → α} {r : α} (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_IsBot) : Filter.Tendsto (λ (x : β), F x / r) l Filter.at_IsBot
{α : Type u} {β : Type v} [AddZeroClass α] [AddZeroClass β] {F : α → β} (hF : _AddMonoid_hom F) (x y : α) : F (x + y) = F x + F y
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : ∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * HasInner.inner x y + ∥y∥ ^ 2
{E : Type u_2} {𝕜 : Type u_3} [Linear_ordered_Field 𝕜] [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul 𝕜 E] {S : set E} (hs : Convex 𝕜 S) {x y : E} (hx : x ∈ S) (hy : y ∈ Interior S) {t : 𝕜} (ht : t ∈ set.ioc 0 1) : x + t • (y - x) ∈ Interior S
(𝕜 : Type u_1) [nondiscrete_NormedField 𝕜] {n : WithTop ℕ} {R : Type u_6} [NormedRing R] [normed_Algebra 𝕜 R] [CompleteSpace R] (x : Rˣ) : ContDiff_at 𝕜 n Ring.Inverse ↑x
{K : Type u} [Field K] (S : Subfield K) {x : K} : x ∈ S → x⁻¹ ∈ S
{K : Type u_1} [Field K] (F : Polynomial K) (A : K) (hF' : Polynomial.Eval A (⇑Polynomial.derivative F) ≠ 0) : _IsCoprime (Polynomial.x - ⇑Polynomial.C A) (F /ₘ (Polynomial.x - ⇑Polynomial.C A))
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.Forget C)] {x : top} (F : top.Presheaf C x) : F._sheaf ↔ F._sheaf_Unique_gluing
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y : m} {r : R} (h : SameRay R x y) (hr : 0 < r) : SameRay R x (r • y)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {t : E →ₗ[𝕜] E} (hT : InnerProductSpace.IsSelfAdjoint t) {v : Submodule 𝕜 E} (hV : ∀ (v : E), v ∈ v → ⇑t v ∈ v) : InnerProductSpace.IsSelfAdjoint (t.Restrict hV)
{α : Type u} [t : TopologicalSpace α] {A : α} {S : set α} {B : set (set α)} (hb : TopologicalSpace._topological_Basis B) : S ∈ nhds A ↔ ∃ (t : set α) (h : t ∈ B), A ∈ t ∧ t ⊆ S
{n : ℕ} {i : Fin (n + 1)} : SimplexCategoryδ i.Succ ≫ SimplexCategoryσ i = 𝟙 (SimplexCategory.Mk n)
{G : Type u_1} [Group G] (h : Subgroup G) [h.Normal] : upper_central_series_step h = Subgroup.comap (Quotient_Group.Mk' h) (Subgroup.Center (G ⧸ h))
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) [Finite_dimensional k ↥(Vector_Span k S)] : Collinear k S ↔ Finite_dimensional.finrank k ↥(Vector_Span k S) ≤ 1
{R : Type u_4} [Linear_ordered_Ring R] (A : R) (h : A ≠ 0) : 0 < A ^ 2
{n : ℕ} {α : Type u_1} {v : Vector α n} : v.reverse.to_List = v.to_List.reverse
{R : Type u_1} [Ring R] {m : Type u_2} [AddCommGroup m] [module R m] {N : Type u_3} [AddCommGroup N] [module R N] [_simple_module R m] [_simple_module R N] (F : m →ₗ[R] N) : Function.Bijective ⇑F ∨ F = 0
{r : ℝ} (hr : 0 ≤ r) (h'r : r < 1) : Filter.Tendsto (λ (n : ℕ), ↑n * r ^ n) Filter.at_top (nhds 0)
(K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [module.Finite K L] {R : Type z} [CommRing R] [Algebra R K] [Algebra R L] [IsScalarTower R K L] [IsDomain R] [_IsSeparable K L] [_integrally_IsClosed R] [_fraction_Ring R K] {B : power_Basis K L} (hint : IsIntegral R B.gen) {z : L} (hz : IsIntegral R z) : Algebra.discr K ⇑(B.Basis) • z ∈ Algebra.Adjoin R {B.gen}
{ι : Type u_1} {E : ι → Type u_2} [Π (i : ι), MetricSpace (E i)] [∀ (i : ι), CompleteSpace (E i)] : CompleteSpace (Σ (i : ι), E i)
{F : Type u_8} {G : Type u_1} {h : Type u_2} [Group G] [MulOneClass h] [Monoid_hom_class F G h] (F : F) : Function.Injective ⇑F ↔ ∀ (A : G), ⇑F A = 1 → A = 1
{α : Type u_1} {𝕜 : Type u_14} [NormedField 𝕜] {l : Filter α} {F g : α → 𝕜} (hgf : ∀ (x : α), g x = 0 → F x = 0) : Filter.Tendsto (λ (x : α), F x / g x) l (nhds 0) → F =o[l] g
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {F : ℂ → E} (hD : Diff_Cont_on_cl ℂ F (set.ioi 0 ×ℂ set.Iio 0)) (hB : ∃ (C : ℝ) (h : C < 2) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal (set.ioi 0 ×ℂ set.Iio 0)] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hre : ∀ (x : ℝ), 0 ≤ x → F ↑x = 0) (him : ∀ (x : ℝ), x ≤ 0 → F (↑x * Complex.i) = 0) : set.Eq_on F 0 {z : ℂ | 0 ≤ z.re ∧ z.im ≤ 0}
{x : Type u_1} [TopologicalSpace x] {x y : x} {F : set x} (h : JoinedIn F x y) : Joined ⟨x, _⟩ ⟨y, _⟩
{α : Type u_1} {β : Type u_2} {m₁ : MeasurableSpace α} {m₂ : MeasurableSpace β} {F : α → β} : Measurable F → MeasurableSpace.comap F m₂ ≤ m₁
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {S : set E} [CompleteSpace F] (h : AnalyticOn 𝕜 F S) : AnalyticOn 𝕜 (fderiv 𝕜 F) S
(k : Type u_1) {v : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Fintype ι] (P : ι → P) {n : ℕ} (hc : Fintype.Card ι = n + 1) : AffineIndependent k P ↔ Finite_dimensional.finrank k ↥(Vector_Span k (set.Range P)) = n
{α : Type u} [AddCommGroup α] [has_LE α] [CovariantClass α α has_Add.Add has_LE.LE] {A B C : α} : A + B ≤ C → B ≤ C - A
{R : Type u} [Ring R] {S : set R} : S ⊆ ↑(Subring.Closure S)
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {F g : ℂ → E} (hdf : Diff_Cont_on_cl ℂ F (set.ioi 0 ×ℂ set.ioi 0)) (hBf : ∃ (C : ℝ) (h : C < 2) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal (set.ioi 0 ×ℂ set.ioi 0)] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hdg : Diff_Cont_on_cl ℂ g (set.ioi 0 ×ℂ set.ioi 0)) (hBg : ∃ (C : ℝ) (h : C < 2) (B : ℝ), g =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal (set.ioi 0 ×ℂ set.ioi 0)] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hre : ∀ (x : ℝ), 0 ≤ x → F ↑x = g ↑x) (him : ∀ (x : ℝ), 0 ≤ x → F (↑x * Complex.i) = g (↑x * Complex.i)) : set.Eq_on F g {z : ℂ | 0 ≤ z.re ∧ 0 ≤ z.im}
{K : Type u_1} {v : K} {n : ℕ} [Linear_ordered_Field K] [FloorRing K] {B : K} (nth_Part_denom_Eq : (GeneralizedContinuedFraction.of v).partial_denominators.nth n = Option.Some B) : ∃ (z : ℤ), B = ↑z
(R : Type u_1) [CommRing R] (m k : ℕ) : 2 * Polynomial.Chebyshev.t R m * Polynomial.Chebyshev.t R (m + k) = Polynomial.Chebyshev.t R (2 * m + k) + Polynomial.Chebyshev.t R k
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {D : Type u_3} [CategoryTheory.Category D] [CategoryTheory.Preadditive D] (G : C ⥤ D) [G.Additive] (x : CategoryTheory.SimplicialObject C) (q n : ℕ) : (AlgebraicTopology.DoldKan.hσ q).F n = G.Map ((AlgebraicTopology.DoldKan.hσ q).F n)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {D : Type u₁} [CategoryTheory.Category D] {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) : CategoryTheory.IsCofiltered D
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {C : Con m} {F : m →* P} (h : C ≤ Con.Ker F) (g : C.Quotient →* P) (Hg : g.Comp C.Mk' = F) : g = C.Lift F h
(G : Type u_1) [Group G] (n : ℕ) (x : G) : x ∈ upper_central_series G (n + 1) ↔ ∀ (y : G), x * y * x⁻¹ * y⁻¹ ∈ upper_central_series G n
(P : ℕ) [Fact (Nat.Prime P)] (A B : ℤ) : Zmod.legendre_Sym P (A * B) = Zmod.legendre_Sym P A * Zmod.legendre_Sym P B
{v : Type u_9} {K : Type u_10} [Field K] [AddCommGroup v] [module K v] {B : BilinForm K v} {x : v} (hx : ¬B.IsOrtho x x) : _IsCompl (Submodule.Span K {x}) (B.Orthogonal (Submodule.Span K {x}))
{R : Type u_1} {A B : R} [Semigroup R] (rra : IsRightRegular A) (rrb : IsRightRegular B) : IsRightRegular (A * B)
(α : Type u) [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] [TopologicalSpace.IsSeparable_Space α] [Nontrivial α] : ∃ (S : set α), S.countable ∧ Dense S ∧ (∀ (x : α), _IsBot x → x ∉ S) ∧ ∀ (x : α), _top x → x ∉ S
{C : Type u₁} [CategoryTheory.Category C] {B A : C} {x : CategoryTheory.Subobject B} (F : A ⟶ B) [CategoryTheory.Mono F] (i : ↑x ≅ A) (W : i.hom ≫ F = x.arrow) : x = CategoryTheory.Subobject.Mk F
{C : Type u₁} [CategoryTheory.Category C] {J : Type u₂} [CategoryTheory.Category J] (F : J ⥤ Cᵒᵖ) [CategoryTheory.Limits.HasLimit F.Left_Op] : CategoryTheory.Limits.HasColimit F
(E : Type u_1) [NormedGroup E] [NormedSpace ℝ E] [Finite_dimensional ℝ E] : ∃ (δ : ℝ), 0 < δ ∧ δ < 1 ∧ ∀ (S : Finset E), (∀ (C : E), C ∈ S → ∥C∥ ≤ 2) → (∀ (C : E), C ∈ S → ∀ (D : E), D ∈ S → C ≠ D → 1 - δ ≤ ∥C - D∥) → S.Card ≤ Besicovitch.multiplicity E
{P k : ℕ} (hk : k ≠ 0) (hp : Nat.Prime P) : (P ^ k).Factors.to_Finset = {P}
{α : Type u} [PseudoEmetricSpace α] {x y : α} {S : set α} (hx : x ∈ S) (hy : y ∈ S) : HasEdist.edist x y ≤ Emetric.diam S
{C : Type u₁} [CategoryTheory.Category C] {x₁₁ x₁₂ x₁₃ x₂₁ x₂₂ x₂₃ : C} {h₁₁ : x₁₁ ⟶ x₁₂} {h₁₂ : x₁₂ ⟶ x₁₃} {h₂₁ : x₂₁ ⟶ x₂₂} {h₂₂ : x₂₂ ⟶ x₂₃} {v₁₁ : x₁₁ ⟶ x₂₁} {v₁₂ : x₁₂ ⟶ x₂₂} {v₁₃ : x₁₃ ⟶ x₂₃} (S : CategoryTheory.IsPullback (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂)) (P : h₁₁ ≫ v₁₂ = v₁₁ ≫ h₂₁) (t : CategoryTheory.IsPullback h₁₂ v₁₂ v₁₃ h₂₂) : CategoryTheory.IsPullback h₁₁ v₁₁ v₁₂ h₂₁
{α : Type u_1} {C : set (set α)} (h : ∀ (A : α), ∃! (B : set α) (h : B ∈ C), A ∈ B) : C.Pairwise_Disjoint Id
{x : ℝ} (hx : 0 < x) : 0 < Exp_Neg_Inv_glue x
{P : ℕ} [hp : Fact (Nat.Prime P)] {k : Type u_1} [Field k] [Char_P k P] [perfect_Ring k P] : discrete_Valuation_Ring (witt_Vector P k)
(k : Type u₁) {G : Type u₂} [Semiring k] [has_Add G] {A : Type u₃} [non_unital_non_assoc_Semiring A] [Distrib_MulAction k A] {φ₁ φ₂ : AddMonoid_Algebra k G →ₙₐ[k] A} (h : φ₁.to_Mul_hom.Comp (AddMonoid_Algebra.of_magma k G) = φ₂.to_Mul_hom.Comp (AddMonoid_Algebra.of_magma k G)) : φ₁ = φ₂
{α : Type u_1} {P : α → Prop} [Decidable_Pred P] {S : Finset α} (h : ∀ (x : α), x ∈ S → P x) : Finset.Filter P S = S
{A B : Cardinal} : Cardinal.aleph0 ≤ A * B ↔ A ≠ 0 ∧ B ≠ 0 ∧ (Cardinal.aleph0 ≤ A ∨ Cardinal.aleph0 ≤ B)
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {x x' Y Y' Z Z' : C} [CategoryTheory.ExactPairing Y Y'] (F : x ⟶ Z ⊗ Y') (g : x' ⟶ Z') : ⇑((CategoryTheory.tensor_Right_hom_Equiv (x' ⊗ x) Y Y' (Z' ⊗ Z)).Symm) ((g ⊗ F) ≫ (α_ Z' Z Y').Inv) = (α_ x' x Y).hom ≫ (g ⊗ ⇑((CategoryTheory.tensor_Right_hom_Equiv x Y Y' Z).Symm) F)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [BaireSpace α] [Encodable β] {F : β → set α} (hc : ∀ (S : β), IsClosed (F S)) (hU : (⋃ (S : β), F S) = set.Univ) : Dense (⋃ (S : β), Interior (F S))
{α : Type u_1} {E : Type u_3} [semi_NormedGroup E] {F : α → E} {g : α → ℝ} {t₀ : Filter α} (h : ∀ (n : α), ∥F n∥ ≤ g n) (h' : Filter.Tendsto g t₀ (nhds 0)) : Filter.Tendsto F t₀ (nhds 0)
(F : ℕ → Nnreal) : Filter.Tendsto (λ (i : ℕ), ∑' (k : ℕ), F (k + i)) Filter.at_top (nhds 0)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x Y : C} (B : CategoryTheory.Limits.BinaryBicone x Y) (Total : B.fst ≫ B.inl_ + B.Snd ≫ B.inr_ = 𝟙 B.x) : CategoryTheory.Limits.HasBinaryBiproduct x Y
{α : Type u} [TopologicalSpace α] {S : set α} [DiscreteTopology ↥S] {x : α} (hx : x ∈ S) : ∃ (U : set α) (h : U ∈ nhds x), U ∩ S = {x}
{α : Type u} {β : Type v} [complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [complete_LinearOrder β] [TopologicalSpace β] [OrderTopology β] {ι : sort u_1} {F : α → β} {g : ι → α} (Cf : Continuous_at F (infi g)) (Mf : Monotone F) (ftop : F ⊤ = ⊤) : F (infi g) = infi (F ∘ g)
{α : Type u_1} {β : Type u_2} [UniformSpace α] [AddGroup α] [uniform_AddGroup α] {hom : Type u_3} [UniformSpace β] [DiscreteTopology β] [AddGroup β] [uniform_AddGroup β] [AddMonoid_hom_class hom α β] {F : hom} : uniform_Continuous ⇑F ↔ IsOpen ↑(↑F.Ker)
{α : Type u} [TopologicalSpace α] {Z A B : set α} (h : IsClopen Z) (cover : Z ⊆ A ∪ B) (ha : IsOpen A) (hb : IsOpen B) (hab : A ∩ B = ∅) : IsClopen (Z ∩ A)
{ι : Type u_1} {α : Type u_2} [has_Zero α] {S : Finset ι} {F : ι →₀ α} {t : ι →₀ Finset α} (ht : t.Support ⊆ S) : F ∈ S.Finsupp ⇑t ↔ ∀ (i : ι), ⇑F i ∈ ⇑t i
(x : Type u) (Y : Type v) [MetricSpace x] [CompactSpace x] [Nonempty x] [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : Isometry (GromovHausdorff.optimal_GH_injr x Y)
{α : Type u_1} {E : α → Type u_2} [Π (i : α), NormedGroup (E i)] {P q : Ennreal} (hpq : P.to_Real.IsConjugateExponent q.to_Real) (F : ↥(Lp E P)) (g : ↥(Lp E q)) : Summable (λ (i : α), ∥⇑F i∥ * ∥⇑g i∥) ∧ ∑' (i : α), ∥⇑F i∥ * ∥⇑g i∥ ≤ ∥F∥ * ∥g∥
{R : Type u_1} [Add_Left_cancel_Semigroup R] (g : R) : _Add_Left_regular g
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] (h : ∀ (x y : E), ∥x + y∥ = ∥x∥ + ∥y∥ → SameRay ℝ x y) : strict_Convex_Space ℝ E
{S : ℂ} (hs : 0 < S.re) {x : ℝ} (hX : 0 ≤ x) : (S + 1).partial_gamma x = S * S.partial_gamma x - ↑(Real.Exp (-x)) * ↑x ^ S
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {P : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall F P x r) (y : E) : HasFpowerSeriesOnBall (λ (z : E), F (z - y)) P (x + y) r
{α : Type u_1} [canonically_ordered_AddMonoid α] [HasSub α] [HasOrderedSub α] {B C : α} [ContravariantClass α α has_Add.Add has_LE.LE] (h : C ≤ B) (A : α) : A + B - C = A + (B - C)
(n : ℕ) (x : ℝ) (hx : 0 < x) : HasDerivAt (Exp_Neg_Inv_glue.F_aux n) (Polynomial.Eval x (Exp_Neg_Inv_glue.P_aux (n + 1)) * Real.Exp (-x⁻¹) / x ^ (2 * (n + 1))) x
{C : Type u} [CategoryTheory.Category C] (F G : CategoryTheory.Discrete PEmpty ⥤ C) : F = G
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] (q : QuadraticForm R m) (P q : Submodule R (clifford_Algebra q)) : Submodule.Map clifford_Algebra.reverse (P * q) = Submodule.Map clifford_Algebra.reverse q * Submodule.Map clifford_Algebra.reverse P
{ι : Type u_1} [Fintype ι] : StdSimplex ℝ ι ⊆ metric.IsClosed_ball 0 1
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] : reflection ⊥ = Linear_Isometry_Equiv.Neg 𝕜
{E : Type u_1} [AddCommGroup E] [module ℝ E] {S : set E} {x : E} : gauge S x = HasInf.Inf {r ∈ set.ioi 0 | r⁻¹ • x ∈ S}
{R : Type u_1} [CommSemiring R] {A : Type u_2} [CommSemiring A] [Algebra R A] {m : Type u_3} [AddCommMonoid m] [module A m] [module R m] {D1 D2 : Derivation R A m} (S : set A) (hs : Algebra.Adjoin R S = ⊤) (h : set.Eq_on ⇑D1 ⇑D2 S) : D1 = D2
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] (D : ℝ) (S : set x) : ⇑(MeasureTheory.Measure.hausdorff_measure D) S = ⨆ (r : Ennreal) (hr : 0 < r), ⨅ (t : ℕ → set x) (hts : S ⊆ ⋃ (n : ℕ), t n) (ht : ∀ (n : ℕ), Emetric.diam (t n) ≤ r), ∑' (n : ℕ), ⨆ (h : (t n).Nonempty), Emetric.diam (t n) ^ D
{x y z : Pgame} (h₁ : x ≤ y) (h₂ : y.lf z) : x.lf z
{α : Type u} [LinearOrder α] {A B C : α} : set.Interval A C ⊆ set.Interval A B ∪ set.Interval B C
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [Finite_dimensional R m] (x : Orientation R m ι) (F : m ≃ₗ[R] m) (h : Fintype.Card ι = Finite_dimensional.finrank R m) : ⇑(Orientation.Map ι F) x = (⇑Linear_Equiv.det F)⁻¹ • x
{h : Type u_1} [TopologicalSpace h] (G : StructureGroupoid h) {m : Type u_2} [TopologicalSpace m] [ChartedSpace h m] [HasGroupoid m G] {e e' : LocalHomeomorph m h} (hE : e ∈ ChartedSpace.Atlas h m) (hE' : e' ∈ ChartedSpace.Atlas h m) : e.Symm.Trans e' ∈ G
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LT.LT] {A B : α} (ha : A < 0) (hb : B < 0) : A + B < 0
{α : Type u_1} [Fintype α] [Field α] : Prime_Pow (Fintype.Card α)
{𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] {F F' : 𝕜 → G} {S : set 𝕜} {C : Nnreal} (hs : Convex ℝ S) (hF : ∀ (x : 𝕜), x ∈ S → HasDerivWithinAt F (F' x) S x) (bound : ∀ (x : 𝕜), x ∈ S → ∥F' x∥₊ ≤ C) : LipschitzOnWith C F S
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) : (-o).oangle x y = -o.oangle x y
{α : Type u_3} {β : Type u_4} {γ : Type u_5} [AddCommMonoid α] {F : β → α} {g : γ → α} (h_Eq : ∀ (u : Finset γ), ∃ (v : Finset β), ∀ (v' : Finset β), v ⊆ v' → (∃ (u' : Finset γ), u ⊆ u' ∧ u'.Sum (λ (x : γ), g x) = v'.Sum (λ (B : β), F B))) : Filter.Map (λ (S : Finset β), S.Sum (λ (B : β), F B)) Filter.at_top ≤ Filter.Map (λ (S : Finset γ), S.Sum (λ (x : γ), g x)) Filter.at_top
{G : Type u_3} [Group G] : Group.fg G ↔ Monoid.fg G
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P ⟶ q) (x y : ↥P) : ⇑F x = ⇑F y → (∃ (z : ↥P), ⇑F z = 0 ∧ ∀ (R : C) (g : P ⟶ R), ⇑g y = 0 → ⇑g z = ⇑g x)
(P : ℕ) [P_Prime : Fact (Nat.Prime P)] {q : ℚ} (hq : q ≠ 0) {k : ℕ} : padic_val_rat P (q ^ k) = ↑k * padic_val_rat P q
 : fourier_Subalgebra.topological_Closure = ⊤
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] (x : 𝕜) {𝕜' : Type u_1} [nondiscrete_NormedField 𝕜'] [normed_Algebra 𝕜 𝕜'] [NormedSpace 𝕜' F] [IsScalarTower 𝕜 𝕜' F] {h : 𝕜 → 𝕜'} {h' : 𝕜'} {g₁ : 𝕜' → F} {g₁' : F} (hg : HasDerivAt g₁ g₁' (h x)) (hH : HasDerivAt h h' x) : HasDerivAt (g₁ ∘ h) (h' • g₁') x
{F : ℝ → ℝ} (hF : Differentiable ℝ F) (hF'_Mono : StrictMono (deriv F)) : strict_Convex_on ℝ set.Univ F
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {F : ℂ → E} {C : ℂ} (hD : ∀ᶠ (z : ℂ) in nhds_within C {C}ᶜ, Differentiable_at ℂ F z) (ho : (λ (z : ℂ), F z - F C) =o[nhds_within C {C}ᶜ] λ (z : ℂ), (z - C)⁻¹) : Filter.Tendsto F (nhds_within C {C}ᶜ) (nhds (lim (nhds_within C {C}ᶜ) F))
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] {A : α} : 0 < -A → A < 0
{E : ℕ → Type u_1} [Π (n : ℕ), TopologicalSpace (E n)] [∀ (n : ℕ), DiscreteTopology (E n)] {S : set (Π (n : ℕ), E n)} (hs : IsClosed S) (hne : S.Nonempty) : ∃ (F : (Π (n : ℕ), E n) → Π (n : ℕ), E n), (∀ (x : Π (n : ℕ), E n), x ∈ S → F x = x) ∧ set.Range F = S ∧ Continuous F
{S : Type u_2} [CommRing S] {K : Type u_4} [Field K] [Algebra K S] (pB : power_Basis K S) : ⇑(Algebra.norm K) pB.gen = (-1) ^ pB.dim * (minpoly K pB.gen).Coeff 0
{m : Type u_2} {α : sort u_4} [CommMonoid m] {F : α → m} (P : m → Prop) (hp₀ : P 1) (hp₁ : ∀ (x y : m), P x → P y → P (x * y)) (hp₂ : ∀ (i : α), P (F i)) : P (finprod (λ (i : α), F i))
{F : Type u_3} [InnerProductSpace ℝ F] {K : set F} (Ne : K.Nonempty) (h₁ : IsComplete K) (h₂ : Convex ℝ K) (u : F) : ∃ (v : F) (h : v ∈ K), ∥u - v∥ = ⨅ (W : ↥K), ∥u - ↑W∥
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : HasInner.inner x y = (∥x + y∥ * ∥x + y∥ - ∥x∥ * ∥x∥ - ∥y∥ * ∥y∥) / 2
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [Finite_dimensional ℝ E] [NormedGroup F] [NormedSpace ℝ F] [MeasurableSpace E] [BorelSpace E] [TopologicalSpace.SecondCountableTopology F] (F : E → F) (S : set E) (F' : E → (E →L[ℝ] F)) (hF' : ∀ (x : E), x ∈ S → HasFderivWithinAt F (F' x) S x) (r : (E →L[ℝ] F) → Nnreal) (rpos : ∀ (A : E →L[ℝ] F), r A ≠ 0) : ∃ (t : ℕ → set E) (A : ℕ → (E →L[ℝ] F)), Pairwise (Disjoint on t) ∧ (∀ (n : ℕ), Measurable_set (t n)) ∧ (S ⊆ ⋃ (n : ℕ), t n) ∧ (∀ (n : ℕ), ApproximatesLinearOn F (A n) (S ∩ t n) (r (A n))) ∧ (S.Nonempty → ∀ (n : ℕ), ∃ (y : E) (h : y ∈ S), A n = F' y)
{B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] : IsTopologicalFiberBundle F Prod.Snd
{P : ℕ} (hp : Nat.Prime P) {n : ℕ} (hn : 0 < n) : (P ^ n).Totient = P ^ (n - 1) * (P - 1)
(x : top) (t : Type u) : (x.presheaf_to_Type t)._sheaf
 : Filter.Tendsto (λ (x : ℝ), x ^ (1 / x)) Filter.at_top (nhds 1)
(K : Type u) [Field K] (v : Type v) [AddCommGroup v] [module K v] [Finite_dimensional K v] : (LinearMap.rtensor (module.dual K v) (contract_Left K v)).Comp ((TensorProduct.assoc K (module.dual K v) v (module.dual K v)).Symm.to_Linear_Map.Comp (LinearMap.ltensor (module.dual K v) (coevaluation K v))) = (TensorProduct.lid K (module.dual K v)).Symm.to_Linear_Map.Comp (TensorProduct.rid K (module.dual K v)).to_Linear_Map
{α : Type u} {β : Type v} (F : α → Finset β) (h : (set.Range F).Finite) : (⋃ (A : α), ↑(F A)).Finite
{α : Type u_1} {β : Type u_3} [MeasurableSpace α] [MeasurableSpace β] {ν : MeasureTheory.Measure β} [MeasureTheory.sigma_Finite ν] {F : α × β → Ennreal} (hF : Measurable F) : Measurable (λ (x : α), ∫⁻ (y : β), F (x, y) ∂ν)
{α : Type u_1} [DecidableEq α] {S t : Finset α} (h : S ⊆ t) : (Finset.Ico S t).Card = 2 ^ (t.Card - S.Card) - 1
{A : Type u_1} {B : Type u_2} [Field A] [Ring B] [IsDomain B] [Algebra A B] {x : B} (hx : IsIntegral A x) : (minpoly A x).Coeff 0 = 0 ↔ x = 0
{ι : Type u} {F g : ι → ℝ} {P : ℝ} (hp : 1 ≤ P) (hF : ∀ (i : ι), 0 ≤ F i) (hg : ∀ (i : ι), 0 ≤ g i) {A B : ℝ} (hA : 0 ≤ A) (hB : 0 ≤ B) (hfA : has_Sum (λ (i : ι), F i ^ P) (A ^ P)) (hgB : has_Sum (λ (i : ι), g i ^ P) (B ^ P)) : ∃ (C : ℝ), 0 ≤ C ∧ C ≤ A + B ∧ has_Sum (λ (i : ι), (F i + g i) ^ P) (C ^ P)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {F : E → G} {S : set E} {x y : E} (hs : Convex ℝ S) (hF : DifferentiableOn 𝕜 F S) (hF' : ∀ (x : E), x ∈ S → fderiv_within 𝕜 F S x = 0) (hx : x ∈ S) (hy : y ∈ S) : F x = F y
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} (P : ι → P) (i₀ : ι) : Vector_Span k (set.Range P) = Submodule.Span k (set.Range (λ (i : {x // x ≠ i₀}), P ↑i -ᵥ P i₀))
{C : Type u₁} [CategoryTheory.Category C] {Z x Y : C} {C : CategoryTheory.Limits.BinaryCofan x Y} (h : CategoryTheory.Limits.IsColimit C) (t : CategoryTheory.Limits.IsInitial Z) : CategoryTheory.IsPushout (t.to ((CategoryTheory.Limits.pair x Y).obj {as := CategoryTheory.Limits.WalkingPair.Left})) (t.to ((CategoryTheory.Limits.pair x Y).obj {as := CategoryTheory.Limits.WalkingPair.Right})) C.inl_ C.inr_
{R : Type u} [Ring R] {m : Type v} [AddCommGroup m] [module R m] [Nontrivial R] {ι : Type W} (B : Basis ι R m) {κ : Type W'} (v : κ → m) (i : LinearIndependent R v) (m : i.Maximal) : (⋃ (k : κ), ↑((⇑(B.repr) (v k)).Support)) = set.Univ
(C : Type (u+1)) [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] (D : Type (u+1)) [CategoryTheory.Category D] [CategoryTheory.ConcreteCategory D] [CategoryTheory.has_Forget₂ C D] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget C)] : CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget₂ C D)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] {F : E → F} {S : set E} (g : F →L[𝕜] G) (h : AnalyticOn 𝕜 F S) : AnalyticOn 𝕜 (⇑g ∘ F) S
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] [TopologicalSpace 𝕜] [OrderTopology 𝕜] {S : set 𝕜} : strict_Convex 𝕜 S ↔ Convex 𝕜 S
{m : Type u_1} [Monoid_with_Zero m] {φ₁ φ₂ : ℤ →*₀ m} (h_Neg_One : ⇑φ₁ (-1) = ⇑φ₂ (-1)) (h_Pos : ∀ (n : ℕ), 0 < n → ⇑φ₁ ↑n = ⇑φ₂ ↑n) : φ₁ = φ₂
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryProducts C] [CategoryTheory.Limits.HasTerminal C] : CategoryTheory.Limits.has_Finite_products C
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Pretopology.to_grothendieck C ⊥ = ⊥
{ι : Type u} (S : Finset ι) {F g : ι → ℝ} {P : ℝ} (hp : 1 ≤ P) (hF : ∀ (i : ι), i ∈ S → 0 ≤ F i) (hg : ∀ (i : ι), i ∈ S → 0 ≤ g i) : S.Sum (λ (i : ι), (F i + g i) ^ P) ^ (1 / P) ≤ S.Sum (λ (i : ι), F i ^ P) ^ (1 / P) + S.Sum (λ (i : ι), g i ^ P) ^ (1 / P)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S1 S2 : AffineSubspace k P) : S1 < S2 ↔ S1 ≤ S2 ∧ ∃ (P : P) (h : P ∈ S2), P ∉ S1
{α : Type u_1} {β : Type u_2} {F g : α → β} {m : MeasurableSpace α} [TopologicalSpace β] {P : α → Prop} {_x : Decidable_Pred P} (hp : Measurable_set {A : α | P A}) (hF : MeasureTheory.strongly_Measurable F) (hg : MeasureTheory.strongly_Measurable g) : MeasureTheory.strongly_Measurable (λ (x : α), Ite (P x) (F x) (g x))
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S : AffineSubspace k P) : affine_Span k ↑S = S
{α : Type u_1} {n : Type u_4} {m : Type u_5} [has_Zero α] {A : Matrix m m α} {D : Matrix n n α} (ha : A.IsDiag) (hD : D.IsDiag) : (Matrix.from_blocks A 0 0 D).IsDiag
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] [Fintype α] [Fintype β] (F : α → β) {B : m} [Linear_ordered_CommRing m] (hb : Fintype.Card β • B < ↑(Fintype.Card α)) : ∃ (y : β), B < ↑((Finset.Filter (λ (x : α), F x = y) Finset.Univ).Card)
{G : Type u_10} [AddGroup G] (A : G) : ⇑(Equiv.Symm (Equiv.Add_Right A)) = λ (x : G), x + -A
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} {ι₂ : Type u_5} (S₂ : Finset ι₂) (e : ι₂ ↪ ι) (W : ι → k) (P : ι → P) : ⇑((Finset.Map e S₂).affine_combination P) W = ⇑(S₂.affine_combination (P ∘ ⇑e)) (W ∘ ⇑e)
{α : Type u} {β : Type v} [complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [complete_LinearOrder β] [TopologicalSpace β] [OrderTopology β] {ι : sort u_1} [Nonempty ι] {F : α → β} {g : ι → α} (Cf : Continuous_at F (infi g)) (Mf : Monotone F) : F (⨅ (i : ι), g i) = ⨅ (i : ι), F (g i)
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {F : α → β × γ} (hF : Continuous F) : Continuous (λ (A : α), (F A).fst)
{α : Type u} [Preorder α] {A B : α} : A ≤ B → ¬B ≤ A → A < B
{v : Type u} [CategoryTheory.Category v] [CategoryTheory.Abelian v] {A B C D A' B' C' D' : v} {F : A ⟶ B} {g : B ⟶ C} {h : C ⟶ D} {F' : A' ⟶ B'} {g' : B' ⟶ C'} {h' : C' ⟶ D'} {α : A ⟶ A'} {β : B ⟶ B'} {γ : C ⟶ C'} {δ : D ⟶ D'} (comm₁ : α ≫ F' = F ≫ β) (comm₂ : β ≫ g' = g ≫ γ) (comm₃ : γ ≫ h' = h ≫ δ) (hfg : CategoryTheory.Exact F g) (hgh : CategoryTheory.Exact g h) (hF'g' : CategoryTheory.Exact F' g') (hα : CategoryTheory.Epi α) (hβ : CategoryTheory.Mono β) (hδ : CategoryTheory.Mono δ) : CategoryTheory.Mono γ
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [Finite_dimensional R m] (x : Orientation R m ι) (F : m ≃ₗ[R] m) (h : Fintype.Card ι = Finite_dimensional.finrank R m) : ⇑(Orientation.Map ι F) x = x ↔ 0 < ⇑LinearMap.det ↑F
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : ι → set P) : affine_Span k (⋃ (i : ι), S i) = ⨆ (i : ι), affine_Span k (S i)
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (u : Rˣ) (hu : 0 < ↑u) (v : module.Ray R m) : u • v = v
{α : Type u} [PseudoMetricSpace α] {S t : set α} {x : α} (Fin : Emetric.Hausdorff_edist S t ≠ ⊤) : metric.Inf_dist x t ≤ metric.Inf_dist x S + metric.Hausdorff_dist S t
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {n : ℕ} (S : Affine.Simplex k P n) (i : Fin (n + 1)) : S.face _ = Affine.Simplex.Mk_of_point k (S.points i)
{α : Type u} {β : Type v} {γ : Type W} [PseudoEmetricSpace α] [TopologicalSpace β] [PseudoEmetricSpace γ] (F : α × β → γ) {S : set α} {t : set β} (K : Nnreal) (ha : ∀ (A : α), A ∈ S → Continuous_on (λ (y : β), F (A, y)) t) (hb : ∀ (B : β), B ∈ t → LipschitzOnWith K (λ (x : α), F (x, B)) S) : Continuous_on F (S ×ˢ t)
{α : Type u} [DecidableEq α] (i j : α) : Function.involutive (λ (_x : Equiv.perm α), _x * Equiv.Swap i j)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (F : C(α, β)) (x : α) : Continuous_at ⇑F x
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} {S : set α} (h : finsum (λ (i : α), finsum (λ (h : i ∈ S), F i)) ≠ 0) : S.Nonempty
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) : ⇑_R_or_C.re (HasInner.inner x y) = (∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - ∥x - y∥ * ∥x - y∥) / 2
{ι : Type u_1} {α : Type u_3} [Preorder ι] [LinearOrder α] {u : ι → α} (h : Monotone u) (h : ¬BddBelow (set.Range u)) : Filter.Tendsto u Filter.at_IsBot Filter.at_IsBot
{C : Type u₁} [CategoryTheory.Category C] {x Y : Cᵒᵖ} (F : x ⟶ Y) [CategoryTheory.IsIso (CategoryTheory.coyoneda.Map F)] : CategoryTheory.IsIso F
{m : Type u_3} [AddMonoid m] [Preorder m] [CovariantClass m m (Function.Swap has_Add.Add) has_LE.LE] [CovariantClass m m has_Add.Add has_LE.LE] {l₁ l₂ : List m} (h : l₁ <+ l₂) (h₁ : ∀ (A : m), A ∈ l₂ → 0 ≤ A) : l₁.Sum ≤ l₂.Sum
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m →+ P} {t : Add_Submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ t) {q : Type u_4} [AddCommMonoid q] {k : t.Localization_Map q} (z : N) (u : q) : ⇑(F.Map hy k) z = u ↔ ⇑(k.to_Map) (⇑g (F.sec z).fst) = ⇑(k.to_Map) (⇑g ↑((F.sec z).Snd)) + u
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {n : WithTop ℕ} (h : ContDiff_on 𝕜 n F S) (hs : UniqueDiffOn 𝕜 S) (hn : 1 ≤ n) : Continuous_on (λ (P : E × E), ⇑(fderiv_within 𝕜 F S P.fst) P.Snd) (S ×ˢ set.Univ)
{α : Type u_1} {ι : Type u_4} [TopologicalSpace α] {S : set ι} (hs : S.Finite) {F : ι → set α} (h : ∀ (i : ι), i ∈ S → _Gδ (F i)) : _Gδ (⋃ (i : ι) (h : i ∈ S), F i)
{α : Type u} [non_unital_non_assoc_Ring α] (k : α) (h : ∀ (x : α), x * k = 0 → x = 0) : IsRightRegular k
{C : Type u₁} [CategoryTheory.Category C] (P : Cᵒᵖ ⥤ Type (max v₁ u₁)) {x : C} (R : CategoryTheory.Presieve x) [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Presieve.IsSheafFor P R ↔ Nonempty (CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fork.ofι (CategoryTheory.Equalizer.fork_Map P R) _))
{α : Type u_1} [circular_Preorder α] {A B C : α} (h : HasBtw.Btw A B C) : HasBtw.Btw C A B
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x : v) {r₁ r₂ : ℝ} : 2 • o.oangle (r₁ • x) (r₂ • x) = 0
{α : Type u_1} {A B C : α} [LinearOrder α] [Add_comm_Semigroup α] [HasSub α] [HasOrderedSub α] (h : A - C < B - C) : A < B
{α : Type u} [LinearOrder α] (A B : α) : LinearOrder.min A B = A ∧ A ≤ B ∨ LinearOrder.min A B = B ∧ B < A
{x y : Pgame} : x ≤ y ↔ (∀ (i : x.Left_moves), (∃ (i' : y.Left_moves), x.move_Left i ≤ y.move_Left i') ∨ ∃ (j : (x.move_Left i).Right_moves), (x.move_Left i).move_Right j ≤ y) ∧ ∀ (j : y.Right_moves), (∃ (i : (y.move_Right j).Left_moves), x ≤ (y.move_Right j).move_Left i) ∨ ∃ (j' : x.Right_moves), x.move_Right j' ≤ y.move_Right j
{R : Type u_1} {E : Type u_2} {ι : Type u_4} [Linear_ordered_Field R] [AddCommGroup E] [module R E] (S : Finset ι) (W₁ W₂ : ι → R) (z : ι → E) (hw₁ : S.Sum (λ (i : ι), W₁ i) = 1) (hw₂ : S.Sum (λ (i : ι), W₂ i) = 1) (A B : R) (hab : A + B = 1) : A • S.Center_mass W₁ z + B • S.Center_mass W₂ z = S.Center_mass (λ (i : ι), A * W₁ i + B * W₂ i) z
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {S : set 𝕜} {F : 𝕜 → 𝕜} : strict_Convex_on 𝕜 S F ↔ Convex 𝕜 S ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ S → z ∈ S → x < y → y < z → (F y - F x) / (y - x) < (F z - F y) / (z - y)
{α : Type u} [PseudoEmetricSpace α] {S t : set α} : Emetric.Hausdorff_edist S t = 0 ↔ Closure S = Closure t
{α : Type u} [TopologicalSpace α] [LocallyCompactSpace α] [t2_Space α] (x : α) : ∃ (U : set α), IsOpen U ∧ x ∈ U ∧ IsCompact (Closure U)
{α : Type u_1} [PartialOrder α] {F : α → α} {P : α → Prop} {hF : ∀ (x : α), x ≤ F x} {hfp : ∀ (x : α), P (F x)} {hmin : ∀ ⦃x y : α⦄, x ≤ y → P y → F x ≤ y} {x y : α} (hxy : x ≤ y) (hy : P y) : ⇑(Closure_operator.Mk₃ F P hF hfp hmin) x ≤ y
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {F : m →* N} (hF : ∀ (y : ↥S), IsUnit (⇑F ↑y)) {y z : ↥S} (h : (⇑(IsUnit.Lift_Right (F.Restrict S) hF) y)⁻¹ = (⇑(IsUnit.Lift_Right (F.Restrict S) hF) z)⁻¹) : ⇑F ↑y = ⇑F ↑z
{α : Type u_1} {β : Type u_2} [Group α] [division_Monoid β] (F : α →* β) (g : α) (n : ℤ) : ⇑F (g ^ n) = ⇑F g ^ n
{α : Type u} [TopologicalSpace α] {F : Filter α} (h : ∃ (A : α), F ≤ nhds A) : F ≤ nhds (lim F)
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [module 𝕜 E] {S : set E} (hs : Convex 𝕜 S) (z : E) : Convex 𝕜 ((λ (x : E), x + z) ⁻¹' S)
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder β] [SuccOrder β] [IsSuccArchimedean β] {S : β → set α} {t : set β} (ht : t.Ord_connected) (h : ∀ (n : β), n ∈ t → IsPreconnected (S n)) (K : ∀ (n : β), n ∈ t → Order.Succ n ∈ t → (S n ∩ S (Order.Succ n)).Nonempty) : IsPreconnected (⋃ (n : β) (h : n ∈ t), S n)
(R : Type u) (L : Type v) [CommRing R] [lie_Ring L] [lie_Algebra R L] [lie_Algebra.IsNilpotent R L] : (⨅ (x : L), (⇑(lie_Algebra.ad R L) x).Maximal_generalized_eigenspace 0) = ⊤
{α : Type u} {n : ℕ} (A : Array n α) : A.to_List = List.of_fn A.read
 : Filter.Tendsto Real.log Filter.at_top Filter.at_top
{α : Type u} [PseudoMetricSpace α] {u : ℕ → α} (hu : Cauchy_Seq u) : ∃ (R : ℝ) (h : R > 0), ∀ (m n : ℕ), HasDist.dist (u m) (u n) < R
{R : Type u_1} [CommRing R] (hR : discrete_Valuation_Ring.has_Unit_Mul_Pow_Irreducible_factorization R) [IsDomain R] : Unique_factorization_Monoid R
{α : Type u} {β : Type v} [DecidableEq β] (r : α → β → Prop) [Π (A : α), Fintype ↥(Rel.image r {A})] : (∀ (A : Finset α), A.Card ≤ Fintype.Card ↥(Rel.image r ↑A)) ↔ ∃ (F : α → β), Function.Injective F ∧ ∀ (x : α), r x (F x)
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] (v : K) : (GeneralizedContinuedFraction.Int_fract_pair.Stream v)._Seq
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [TopologicalSpace.SecondCountableTopology E] [CompleteSpace E] [NormedGroup F] {F : ℝ → E} {g : ℝ → F} {A B C : ℝ} (hne : A ≠ B) (hc : C ∈ set.Interval A B) (h_deriv : ∀ᶠ (x : ℝ) in nhds_within C (set.Interval A B  {C}), Differentiable_at ℝ F x) (h_infty : Filter.Tendsto (λ (x : ℝ), ∥F x∥) (nhds_within C (set.Interval A B  {C})) Filter.at_top) (hg : deriv F =O[nhds_within C (set.Interval A B  {C})] g) : ¬IntervalIntegrable g MeasureTheory.MeasureSpace.Volume A B
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommMonoid β] [module 𝕜 E] [module 𝕜 β] (F : E →ₗ[𝕜] β) {S : set E} (hs : Convex 𝕜 S) : Convex_on 𝕜 S ⇑F
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) {r : Nnreal} (h : ↑r < P.radius) : ∃ (A : ℝ) (h : A ∈ set.Ioo 0 1), (λ (n : ℕ), ∥P n∥ * ↑r ^ n) =o[Filter.at_top] has_Pow.Pow A
{α : Type u_1} {P : α → Prop} (S : Finset {x // P x}) {A : α} (h : ¬P A) : A ∉ Finset.Map (Function.Embedding.Subtype (λ (x : α), P x)) S
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {j j' : C} (F F' : j ⟶ j') : F ≫ CategoryTheory.IsFiltered.coeq_hom F F' = F' ≫ CategoryTheory.IsFiltered.coeq_hom F F'
{P : ℕ} [P_Prime : Fact (Nat.Prime P)] {B : ℕ} (Dvd : P ∣ B) : padic_val_Nat P (B / P) = padic_val_Nat P B - 1
{F : Type u_2} [NormedGroup F] [NormedSpace ℝ F] {x y : F} : SameRay ℝ x y ↔ x = 0 ∨ y = 0 ∨ ∥x∥⁻¹ • x = ∥y∥⁻¹ • y
{α : Type u_1} {β : Type u_2} {F : α → β} {C : α} [Semiring α] [AddGroup β] (h : Function.Antiperiodic F C) : Function.Periodic F (2 * C)
{R : Type u_2} {m : Type u_3} [AddCommGroup m] [Ring R] [module R m] {B : BilinForm R m} (hB : B.to_QuadraticForm.anisotropic) : B.nondegenerate
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) {P : P} (hp : P ∈ affine_Span ℝ (set.Range S.points)) {r : ℝ} (hr : ∀ (i : Fin (n + 1)), HasDist.dist (S.points i) P = r) : r = S.circumradius
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K₁ K₂ : Submodule 𝕜 E} [Finite_dimensional 𝕜 ↥K₂] (h : K₁ ≤ K₂) : Finite_dimensional.finrank 𝕜 ↥K₁ + Finite_dimensional.finrank 𝕜 ↥(K₁ᗮ ⊓ K₂) = Finite_dimensional.finrank 𝕜 ↥K₂
{m : Type u_1} [Monoid m] {ι : sort u_2} {S : ι → set m} (h : ∀ (y : ι), _Submonoid (S y)) : _Submonoid (set.Inter S)
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m →+ P} (hg : ∀ (y : ↥S), IsAddUnit (⇑g ↑y)) {x y : m} (h : ⇑(F.to_Map) x = ⇑(F.to_Map) y) : ⇑g x = ⇑g y
{R : Type u} [non_assoc_Semiring R] (S : Subsemiring R) : Subsemiring.Closure ↑S = S
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (x : m) : SameRay R x x
{α : Type u_1} {m : Type u_5} {R : Type u_11} {S : Type u_12} [has_Zero m] [Semiring R] [Semiring S] (h : R →+* S) (F : α →₀ m) (g : α → m → R) : ⇑h (F.Sum g) = F.Sum (λ (A : α) (B : m), ⇑h (g A B))
{ι : Type u_1} {α : Type u_2} {S : ι → set α} (hs : IndexedPartition S) (x : α) : ⇑(hs.out) (hs.Proj x) = hs.Some (hs.Index x)
{α : Type u} {β : Type v} [Preorder α] [SemilatticeSup β] {F g : α → β} (hF : Monotone F) (hg : Monotone g) : Monotone (F ⊔ g)
{α : Type u_1} : Subsingleton (Option α) ↔ IsEmpty α
{ι : Type u_1} (F g : ι → Cardinal) (h : ∀ (i : ι), F i < g i) : Cardinal.Sum F < Cardinal.Prod g
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) : 2 • o.oangle (-x) y = 2 • o.oangle x y
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {F : J ⥤ C} {t : CategoryTheory.Limits.Cocone F} (h : CategoryTheory.Limits.IsColimit t) (S : CategoryTheory.Limits.Cocone F) : ∃! (D : t.x ⟶ S.x), ∀ (j : J), t.ι.App j ≫ D = S.ι.App j
{α : Type u_1} {β : Type u_2} {F : α → β} {C : α} [Linear_ordered_AddCommGroup α] [Archimedean α] (h : Function.Periodic F C) (hc : 0 < C) (x A : α) : ∃ (y : α) (h : y ∈ set.ioc A (A + C)), F x = F y
{R : Type u_1} [CommSemiring R] {R' : Type u_2} [Monoid R'] {m : Type u_4} {N : Type u_5} [AddCommMonoid m] [AddCommMonoid N] [module R m] [module R N] [Distrib_MulAction R' m] [Distrib_MulAction R' N] [TensorProduct.CompatibleSmul R R' m N] (r : R') (m : m) (n : N) : (r • m) ⊗ₜ[R] n = m ⊗ₜ[R] (r • n)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {K : set (E →L[𝕜] F)} (hK : IsComplete K) : fderiv_Measurable_aux.D F K ⊆ {x : E | Differentiable_at 𝕜 F x ∧ fderiv 𝕜 F x ∈ K}
{α : Type u} [PseudoEmetricSpace α] {S : set α} (hs : S.Subsingleton) : Emetric.diam S = 0
{K : Type u} [Field K] {ι : sort u_1} [hι : Nonempty ι] {S : ι → Subfield K} (hS : Directed has_LE.LE S) {x : K} : (x ∈ ⨆ (i : ι), S i) ↔ ∃ (i : ι), x ∈ S i
{α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {F : MeasureTheory.Filtration ℕ m} {u : ℕ → α → β} {τ : α → ℕ} [AddCommMonoid β] [TopologicalSpace β] [has_Continuous_Add β] (hu : MeasureTheory.Adapted F u) (hτ : MeasureTheory.IsStoppingTime F τ) : MeasureTheory.Adapted F (MeasureTheory.stopped_process u τ)
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LE.LE] {A B : α} (ha : 0 < A) (hb : 0 < B) : 0 < A + B
{v : Type u_4} [InnerProductSpace ℂ v] (t : v →ₗ[ℂ] v) : (∀ (x : v), HasInner.inner (⇑t x) x = 0) ↔ t = 0
{α : Type u_1} {β : Type u_2} [t : TopologicalSpace α] [PolishSpace α] [MeasurableSpace α] [BorelSpace α] [tβ : TopologicalSpace β] [TopologicalSpace.SecondCountableTopology β] [MeasurableSpace β] [BorelSpace β] {F : α → β} (hF : Measurable F) : ∃ (t' : TopologicalSpace α), t' ≤ t ∧ Continuous F ∧ PolishSpace α
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {P : Filter ι} [TopologicalSpace α] (h : TendstoUniformly F F P) (hc : ∀ᶠ (n : ι) in P, Continuous (F n)) [P.Ne_IsBot] : Continuous F
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] (q : FormalMultilinearSeries 𝕜 F G) (P : FormalMultilinearSeries 𝕜 E F) (hq : 0 < q.radius) (hp : 0 < P.radius) : ∃ (r : Nnreal) (h : r > 0), Summable (λ (i : Σ (n : ℕ), Composition n), ∥q.Comp_along_Composition P i.Snd∥₊ * r ^ i.fst)
{R : Type u_1} [Rack R] {x y z : R} : Shelf.act x (Shelf.act y z) = Shelf.act (Shelf.act x y) z ↔ Shelf.act x z = z
{α : Type u_2} {β : Type u_3} {rα : non_assoc_Semiring α} {rβ : non_assoc_Semiring β} (F : α →+* β) : ⇑F 0 = 0
{α : Type u_2} {β : Type u_3} {rα : non_assoc_Semiring α} {rβ : non_assoc_Semiring β} (F : α →+* β) : 0 = 1 ↔ ⇑F 1 = 0
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) {r : ℝ} (hr : r ≠ 0) : 2 • o.oangle (r • x) y = 2 • o.oangle x y
(z W : ℂ) : Complex.Abs (z + W) ≤ Complex.Abs z + Complex.Abs W
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] (A : α) {B : α} : 0 < B → A - B < A
{A : ℝ} {l : Filter ℝ} {F F' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in nhds_within A (set.Iio A), HasDerivAt F (F' x) x) (hgg' : ∀ᶠ (x : ℝ) in nhds_within A (set.Iio A), HasDerivAt g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in nhds_within A (set.Iio A), g' x ≠ 0) (hfa : Filter.Tendsto F (nhds_within A (set.Iio A)) (nhds 0)) (hga : Filter.Tendsto g (nhds_within A (set.Iio A)) (nhds 0)) (HDiv : Filter.Tendsto (λ (x : ℝ), F' x / g' x) (nhds_within A (set.Iio A)) l) : Filter.Tendsto (λ (x : ℝ), F x / g x) (nhds_within A (set.Iio A)) l
{G : Type u_1} [Group G] (tG : Monoid._torsion G) (bounded : (set.Range (λ (g : G), order_of g)).Finite) : Monoid.exponent_exists G
(𝕜 : Type u_1) [nondiscrete_NormedField 𝕜] {E : Type u_2} [semi_NormedGroup E] [NormedSpace 𝕜 E] [ProperSpace 𝕜] (x' : NormedSpace.dual 𝕜 E) (r : ℝ) : IsCompact (⇑WeakDual.to_normed_dual ⁻¹' metric.IsClosed_ball x' r)
{ι : Type u_1} {R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] [Fintype ι] (B : Basis ι R m) (x : ι → R) : ⇑(B.Equiv_fun.Symm) x = Finset.Univ.Sum (λ (i : ι), x i • ⇑B i)
{α : Type u} [PseudoEmetricSpace α] {S : set α} (Ne : S.Nonempty) : Emetric.Hausdorff_edist S ∅ = ⊤
{A : Prop} : ¬¬A ↔ A
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x : v) {r : ℝ} : 2 • hb.oangle (r • x) x = 0
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {F : α → β} : StrictAnti F → StrictMono (F ∘ ⇑order_dual.of_dual)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e e' : LocalHomeomorph α β} (h : e ≈ e') : e.to_local_Equiv.Source = e'.to_local_Equiv.Source
{J : Type u₁} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {F G : J ⥤ C} [CategoryTheory.Limits.HasColimit F] (α : G ≅ F) : CategoryTheory.Limits.HasColimit G
(α : Type u) [t : TopologicalSpace α] [TopologicalSpace.IsSeparable_Space α] [Nonempty α] : ∃ (u : ℕ → α), DenseRange u
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [Finite_dimensional 𝕜 E] (K : Submodule 𝕜 E) : Finite_dimensional.finrank 𝕜 ↥K + Finite_dimensional.finrank 𝕜 ↥Kᗮ = Finite_dimensional.finrank 𝕜 E
{α : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} [Preorder ι] {𝒢 : MeasureTheory.Filtration ι m} {τ η : α → ι} {i : ι} {S : set α} [Decidable_Pred (λ (_x : α), _x ∈ S)] (hτ_st : MeasureTheory.IsStoppingTime 𝒢 τ) (hη_st : MeasureTheory.IsStoppingTime 𝒢 η) (hτ : ∀ (x : α), i ≤ τ x) (hη : ∀ (x : α), i ≤ η x) (hs : Measurable_set S) : MeasureTheory.IsStoppingTime 𝒢 (S.piecewise τ η)
{v : Type u_1} {P : Type u_2} [NormedGroup v] [NormedSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S u : set P} (hu : IsOpen u) (hsu : S ⊆ u) (hne : S.Nonempty) (h : AffineIndependent ℝ Coe) : ∃ (t : set P), S ⊆ t ∧ t ⊆ u ∧ AffineIndependent ℝ Coe ∧ affine_Span ℝ t = ⊤
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (v : m) {r : R} (h : 0 ≤ r) : SameRay R v (r • v)
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) [CategoryTheory.Limits.HasLimits C] (i j k : D.to_GlueData.J) (U : TopologicalSpace.Opens ↥((D.to_GlueData.U i).carrier)) : D.Opens_image_preimage_Map i j U ≫ (D.to_GlueData.F j k).C.App (Opposite.Op ((TopologicalSpace.Opens.Map (D.to_GlueData.ι j).Base).obj (_.Functor.obj U))) = (CategoryTheory.Limits.pullback.fst ≫ D.to_GlueData.t j i ≫ D.to_GlueData.F i j).C.App (Opposite.Op U) ≫ _.Inv_App (Opposite.Unop ((TopologicalSpace.Opens.Map (CategoryTheory.Limits.pullback.fst ≫ D.to_GlueData.t j i ≫ D.to_GlueData.F i j).Base).Op.obj (Opposite.Op U))) ≫ (D.to_GlueData.v (j, k)).presheaf.Map (CategoryTheory.Eq_to_hom _)
{α : Type u_1} {E : Type u_3} [semi_NormedGroup E] {F : α → E} {g : α → ℝ} {t₀ : Filter α} (h : ∀ᶠ (n : α) in t₀, ∥F n∥ ≤ g n) (h' : Filter.Tendsto g t₀ (nhds 0)) : Filter.Tendsto F t₀ (nhds 0)
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {F : α → β} : StrictMono F → StrictAnti (F ∘ ⇑order_dual.of_dual)
(G : Type u_1) [comm_Group G] : Monoid._torsion_free (G ⧸ torsion G)
{β : Type u} {α : Type v} {γ : Type W} [AddCommMonoid β] [AddCommMonoid γ] (g : β ≃+ γ) (F : α → β) (S : Finset α) : ⇑g (S.Sum (λ (x : α), F x)) = S.Sum (λ (x : α), ⇑g (F x))
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : EuclideanGeometry.angle P1 P2 P3 = Real.Pi) : HasDist.dist P1 P2 ≠ 0
{G : Type u} [Group G] {x : G} : _of_Fin_order x⁻¹ ↔ _of_Fin_order x
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [nondiscrete_NormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (F : Continuous_MultilinearMap 𝕜 E G) (m₁ m₂ : Π (i : ι), E i) : ∥⇑F m₁ - ⇑F m₂∥ ≤ ∥F∥ * Finset.Univ.Sum (λ (i : ι), Finset.Univ.Prod (λ (j : ι), Ite (j = i) ∥m₁ i - m₂ i∥ (LinearOrder.max ∥m₁ j∥ ∥m₂ j∥)))
{F : ℂ → ℂ} {C z : ℂ} {R : ℝ} (hD : DifferentiableOn ℂ F (Metric.Ball C R)) (h_maps : set.maps_to F (Metric.Ball C R) (Metric.Ball C R)) (hc : F C = C) (hz : z ∈ Metric.Ball C R) : HasDist.dist (F z) C ≤ HasDist.dist z C
(A : Type W) (B : Type u₁) (C : Type u_1) [CommRing A] [CommRing B] [CommRing C] [Algebra A B] [Algebra B C] [Algebra A C] [IsScalarTower A B C] [IsNoetherian_Ring A] (hAC : ⊤.fg) (hBC : ⊤.fg) (hBCi : Function.Injective ⇑(Algebra_Map B C)) : ⊤.fg
{α : Type u_1} {m : Type u_5} [has_Zero m] (A : α) : Function.Injective (Finsupp.single A)
{α : Type u_1} {β : Type u_2} [AddGroup α] [subtraction_Monoid β] (F : α →+ β) (A : α) : ⇑F (-A) = -⇑F A
(R : Type u) (L : Type v) (m : Type W) [CommRing R] [lie_Ring L] [lie_Algebra R L] [AddCommGroup m] [module R m] [lie_Ring_module L m] [lie_module R L m] : lie_module.IsNilpotent R L m ↔ ∃ (k : ℕ), lie_module.lower_central_series R L m k = ⊥
{E : Type u_2} [semi_NormedGroup E] [NormedSpace ℝ E] {S t : set E} (disj : Disjoint S t) (hs₁ : Convex ℝ S) (hs₂ : IsCompact S) (ht₁ : Convex ℝ t) (ht₂ : IsClosed t) : ∃ (u v : set E), IsOpen u ∧ IsOpen v ∧ Convex ℝ u ∧ Convex ℝ v ∧ S ⊆ u ∧ t ⊆ v ∧ Disjoint u v
{R : Type u} {m : Type v} [CommRing R] [Nontrivial R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] (F : m →ₗ[R] m) (k : ℕ) : F ^ k = ⇑(Polynomial.aeval F) (Polynomial.x ^ k %ₘ F.charpoly)
{m : Type u} {n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix m n α) (B : Matrix n n α) [Invertible B] : (A.Mul B).Mul (⅟ B) = A
{α : Type u} [PseudoEmetricSpace α] {x : α} {S : set α} : x ∈ Closure S ↔ Emetric.Inf_edist x S = 0
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {δ : Type u_1} [LinearOrder δ] [TopologicalSpace δ] [order_IsClosed_topology δ] {F : α → δ} (hF : Continuous F) (h_top : Filter.Tendsto F Filter.at_IsBot Filter.at_top) (h_IsBot : Filter.Tendsto F Filter.at_top Filter.at_IsBot) : Function.Surjective F
{α : Type u} [TopologicalSpace α] {S U : set α} (h : U ∈ ⨆ (x : α) (h : x ∈ S), nhds x) : ∃ (v : set α), S ⊆ v ∧ IsOpen v ∧ v ⊆ U
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [Add_cancel_CommMonoid E] [ordered_AddCommMonoid β] [module 𝕜 E] [HasScalar 𝕜 β] {S : set E} {F : E → β} (hF : strict_ConcaveOn 𝕜 S F) (C : E) : strict_ConcaveOn 𝕜 ((λ (z : E), C + z) ⁻¹' S) (F ∘ λ (z : E), z + C)
{K : Type u_4} {L : Type u_5} [Field K] [Field L] [Algebra K L] (x : K) : ⇑(Algebra.trace K L) (⇑(Algebra_Map K L) x) = Finite_dimensional.finrank K L • x
{n : ℕ} (hpos : 0 < n) : Irreducible (Polynomial.cyclotomic n ℚ)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y : v} (h : ∥x∥ = ∥y∥) : hb.oangle x (x - y) = hb.oangle (y - x) y
{α : Type u_1} {β : Type u_3} {C : set (set α)} {D : set (set β)} (hC : IsPiSystem C) (hD : IsPiSystem D) : IsPiSystem (set.image2 has_set_Prod.Prod C D)
{𝕂 : Type u_1} [nondiscrete_NormedField 𝕂] [CompleteSpace 𝕂] (h : 0 < (Exp_series 𝕂 𝕂).radius) : HasStrictDerivAt (Exp 𝕂) 1 0
{𝕜 : Type u_1} {A : Type u_2} [nondiscrete_NormedField 𝕜] [NormedRing A] [normed_Algebra 𝕜 A] [CompleteSpace A] {A : A} {r : Nnreal} (hr : ↑r < (spectral_radius 𝕜 A)⁻¹) : DifferentiableOn 𝕜 (λ (z : 𝕜), Ring.Inverse (1 - z • A)) (metric.IsClosed_ball 0 ↑r)
{α : Type u_1} {β : Type u_2} {t : α} {ts ys : List α} {r : List β} (F : List α → β) : (List.PermutationsAux2 t List.Nil r ys (λ (x : List α), F (x ++ ts))).Snd = (List.PermutationsAux2 t ts r ys F).Snd
{α : Type u_1} (r : α → α → Prop) : Relation.Fibration (Relation.Game_Add (Relation.CutExpand r) (Relation.CutExpand r)) (Relation.CutExpand r) (λ (S : Multiset α × Multiset α), S.fst + S.Snd)
{n P : ℕ} : List.count P n.Factors = ⇑(n.factorization) P
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {x y : L} : x ∈ S → y ∈ S → x * y ∈ S
{α : Type u} {β : Type v} [Preorder α] [LinearOrder β] {F g : α → β} (hF : Antitone F) (hg : Antitone g) : Antitone (λ (x : α), LinearOrder.min (F x) (g x))
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : α → E} {g' : α → F'} {l : Filter α} : (F =o[l] λ (x : α), ∥g' x∥) → F =o[l] g'
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {S : set 𝕜} {n : WithTop ℕ} (Hcont : ∀ (m : ℕ), ↑m ≤ n → Continuous_on (λ (x : 𝕜), iterated_deriv_within m F S x) S) (Hdiff : ∀ (m : ℕ), ↑m < n → DifferentiableOn 𝕜 (λ (x : 𝕜), iterated_deriv_within m F S x) S) : ContDiff_on 𝕜 n F S
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (P1 : P) {P2 P3 P4 : P} (h : EuclideanGeometry.angle P2 P3 P4 = Real.Pi) : EuclideanGeometry.angle P1 P2 P3 = EuclideanGeometry.angle P1 P2 P4
{α : Type u_1} {μ₁ μ₂ : MeasureTheory.OuterMeasure α} (h : ∀ (S : set α), S.Nonempty → ⇑μ₁ S = ⇑μ₂ S) : μ₁ = μ₂
{β : Type u} {α : Type v} {γ : Type W} [CommMonoid β] {S : Finset γ} {t : Finset α} {F : γ → α → β} : (S.Product t).Prod (λ (x : γ × α), F x.fst x.Snd) = S.Prod (λ (x : γ), t.Prod (λ (y : α), F x y))
{x : top} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] (F : top.Presheaf C x) : F._sheaf ↔ F._sheaf_preserves_Limit_Pairwise_intersections
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) {r : ℝ} (hr : r < 0) : InnerProductGeometry.angle (r • x) y = InnerProductGeometry.angle (-x) y
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {J : Type u} [CategoryTheory.Category J] (E : D ⥤ C) [CategoryTheory.IsEquivalence E] [CategoryTheory.Limits.HasLimits_of_shape J C] : CategoryTheory.Limits.HasLimits_of_shape J D
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {F : α → β} : Antitone F → Monotone (F ∘ ⇑order_dual.of_dual)
{α : Type u} [MetricSpace α] [ProperSpace α] {R : α → ℝ} (hR : ∀ (x : α), 0 < R x) : ∃ (ι : Type u) (C : ι → α) (r r' : ι → ℝ), (∀ (i : ι), 0 < r i ∧ r i < r' i ∧ r' i < R (C i)) ∧ locally_Finite (λ (i : ι), Metric.Ball (C i) (r' i)) ∧ (⋃ (i : ι), Metric.Ball (C i) (r i)) = set.Univ
{G : Type u} [Group G] [Fintype G] {P n : ℕ} [hp : Fact (Nat.Prime P)] {h : Subgroup G} (hH : Fintype.Card ↥h = P ^ n) : Fintype.Card (↥(h.Normalizer) ⧸ Subgroup.comap h.Normalizer.Subtype h) ≡ Fintype.Card (G ⧸ h) [Mod P]
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} {S : set E} {x : E} : MdifferentiableWithinAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F S x → Differentiable_within_at 𝕜 F S x
{z : ℂ} (hz : 0 < z.re) : Continuous_at (λ (x : ℂ × ℂ), x.fst ^ x.Snd) (0, z)
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m →+ P} (hg : ∀ (y : ↥S), IsAddUnit (⇑g ↑y)) (z : N) : ⇑g ↑((F.sec z).Snd) + ⇑(F.Lift hg) z = ⇑g (F.sec z).fst
{F : ℕ →₀ ℕ} (hF : ∀ (P : ℕ), P ∈ F.Support → Nat.Prime P) : (F.Prod has_Pow.Pow).factorization = F
(ι : Type u_1) [Fintype ι] : IsCompact (StdSimplex ℝ ι)
{x : Type u} {Y : Type v} [MetricSpace x] [CompactSpace x] [Nonempty x] [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : GromovHausdorff.hD (GromovHausdorff.candidates_B_dist x Y) ≤ Metric.diam set.Univ + 1 + Metric.diam set.Univ
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.Limits.HasCokernels C] {P q : C} (F : P ⟶ q) : CategoryTheory.Abelian.FactorThruImage F ≫ CategoryTheory.Abelian.image.ι F = F
{α : Type u} [Preorder α] {S : set α} : ¬BddAbove S ↔ ∀ (x : α), ∃ (y : α) (h : y ∈ S), ¬y ≤ x
{x y z : ℤ} : PythagoreanTriple x y z ↔ PythagoreanTriple y x z
{x : Type u_2} [EmetricSpace x] {S : set x} (hs : S.Finite) : dimH S = 0
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] {ι : Type u_2} (S : Finset ι) (F : ι → Ideal R) (e : ι → ℕ) (Prime : ∀ (i : ι), i ∈ S → _root.Prime (F i)) (IsCoprime : ∀ (i : ι), i ∈ S → ∀ (j : ι), j ∈ S → i ≠ j → F i ≠ F j) : S.Inf (λ (i : ι), F i ^ e i) = S.Prod (λ (i : ι), F i ^ e i)
{R : Type u_1} [Linear_ordered_Field R] [FloorRing R] {B : ℕ} (hb : 1 < B) {x : ℤ} {r : R} (hr : 0 < r) : r ≤ ↑B ^ x ↔ Int.clog B r ≤ x
{C : Type u₁} [CategoryTheory.Category C] {A : Type u₂} [CategoryTheory.Category A] (P : Cᵒᵖ ⥤ A) {x : C} (S : CategoryTheory.Sieve x) : Nonempty (CategoryTheory.Limits.IsLimit (P.Map_cone S.Arrows.Cocone.Op)) ↔ ∀ (E : Aᵒᵖ), CategoryTheory.Presieve.IsSheafFor (P ⋙ CategoryTheory.coyoneda.obj E) ⇑S
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {x y : 𝕜} (h : x ≤ y) {z : 𝕜} : z ∈ set.icc x y ↔ ∃ (A B : 𝕜), 0 ≤ A ∧ 0 ≤ B ∧ A + B = 1 ∧ A * x + B * y = z
{v : Type u} [CategoryTheory.Category v] [CategoryTheory.Limits.HasZeroMorphisms v] {A B C : v} (F : A ⟶ B) [CategoryTheory.Limits.HasImage F] (g : B ⟶ C) [CategoryTheory.Limits.HasKernel g] (W : F ≫ g = 0) [CategoryTheory.Limits.HasCokernel (image_to_Kernel F g W)] {D : v} {k k' : homology F g W ⟶ D} (P : homologyπ F g W ≫ k = homologyπ F g W ≫ k') : k = k'
{G : Type u_1} {h : Type u_2} [AddGroup G] {N : Add_Subgroup G} [AddGroup h] {F : G →+ h} (hF : Function.Surjective ⇑F) (hN : N = F.Ker) (tN : AddMonoid._torsion ↥N) : AddMonoid._torsion h ↔ AddMonoid._torsion G
{P : ℕ → Prop} {m : ℕ} (h0 : P m) (h1 : ∀ (n : ℕ), m ≤ n → P n → P (n + 1)) (n : ℕ) : m ≤ n → P n
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] {P : P} : HasDist.dist P ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P) = 0 ↔ P ∈ S
{α : Type u_2} {β : Type u_3} [DecidableEq α] [HasVsub α β] {u : Finset α} {S t : set β} : ↑u ⊆ S -ᵥ t → (∃ (S' t' : Finset β), ↑S' ⊆ S ∧ ↑t' ⊆ t ∧ u ⊆ S' -ᵥ t')
{α : Type u_1} (P : α → Prop) (r : α → α → Prop) (h : ∀ (S : Finset α), (∀ (x : α), x ∈ S → P x) → (∃ (y : α), P y ∧ ∀ (x : α), x ∈ S → r x y)) : ∃ (F : ℕ → α), (∀ (n : ℕ), P (F n)) ∧ ∀ (m n : ℕ), m < n → r (F m) (F n)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [BaireSpace α] [Encodable β] {F : β → set α} (ho : ∀ (S : β), IsOpen (F S)) (hD : ∀ (S : β), Dense (F S)) : Dense (⋂ (S : β), F S)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {B₂ : Basis (Fin 2) ℝ v} (hb₂ : Orthonormal ℝ ⇑B₂) (ho : B.Orientation = B₂.Orientation) (θ : Real.Angle) : hb.rotation θ = hb₂.rotation θ
{G : Type u} [AddGroup G] {x : G} : _of_Fin_Add_order (-x) ↔ _of_Fin_Add_order x
{K : Type u_1} {v : K} {n : ℕ} [Linear_ordered_Field K] [FloorRing K] {B : K} (nth_Part_denom_Eq : (GeneralizedContinuedFraction.of v).partial_denominators.nth n = Option.Some B) : 1 ≤ B
{α : Type u} [PseudoMetricSpace α] (S : set α) : Continuous (λ (x : α), metric.Inf_dist x S)
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y z : v} (hxyne : x ≠ y) (hxzne : x ≠ z) {r : ℝ} (hx : ∥x∥ = r) (hy : ∥y∥ = r) (hz : ∥z∥ = r) : o.oangle y z = 2 • o.oangle (y - x) (z - x)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x : v) : 2 • hb.oangle (-x) x = 0
{α : Type u_1} {β : Type u_2} {m₁ : MeasurableSpace α} {m₂ : MeasurableSpace β} {F : α → β} : MeasurableSpace.comap F m₂ ≤ m₁ → Measurable F
{α : Type u_1} [MetricSpace α] {β : Type u} [Nonempty β] (P : Besicovitch.TauPackage β α) (x : β) : P.to_BallPackage.C x ∈ P.Union_Up_to P.Last_step
{R : Type u} {S : Type v} [Semiring R] [Semiring S] [Nontrivial S] (F : R →+* S) : 1 ∉ F.Ker
{β : Type u} {α : Type v} {S : Finset α} [CommMonoid β] (F : α → β) {P : α → Prop} [Decidable_Pred P] : (Finset.Subtype P S).Prod (λ (x : Subtype P), F ↑x) = (Finset.Filter P S).Prod (λ (x : α), F x)
{α : Type u} {A B : α} [Mul_Zero_class α] [PartialOrder α] [ZeroLt.PosMulMono α] (ha : 0 ≤ A) (hb : 0 ≤ B) : 0 ≤ A * B
{x Y S : top} {F : x ⟶ S} {g : Y ⟶ S} (h₁ : IsOpen_Embedding ⇑F) (h₂ : IsOpen_Embedding ⇑g) : IsOpen_Embedding ⇑(CategoryTheory.Limits.Limitπ (CategoryTheory.Limits.cospan F g) CategoryTheory.Limits.WalkingCospan.One)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S1 S2 : AffineSubspace k P) : S1.direction ⊔ S2.direction ≤ (S1 ⊔ S2).direction
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {F : ℂ → E} (hF : Differentiable ℂ F) (z : ℂ) : AnalyticAt ℂ F z
(m : Type u_1) (N : Type u_2) (α : Type u_3) [HasScalar m α] [HasScalar N α] [SmulCommClass m N α] : SmulCommClass N m α
(m : Type u_1) (α : Type u_2) [Monoid m] [MulAction m α] {ι : sort u_3} {S : ι → set α} : fixing_Submonoid m (⋃ (i : ι), S i) = ⨅ (i : ι), fixing_Submonoid m (S i)
(E : Type u_1) [NormedGroup E] [NormedSpace ℝ E] [Finite_dimensional ℝ E] : IsEmpty (Besicovitch.SatelliteConfig E (Besicovitch.multiplicity E) (Besicovitch.good_τ E))
 : Filter.Tendsto (λ (N : ℕ), FormalMultilinearSeries.Comp_partial_Sum_Target 0 N N) Filter.at_top Filter.at_top
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {x : E} {n : ℕ} : ContDiff_at 𝕜 ↑(n + 1) F x ↔ ∃ (F' : E → (E →L[𝕜] F)), (∃ (u : set E) (h : u ∈ nhds x), ∀ (x : E), x ∈ u → HasFderivAt F (F' x) x) ∧ ContDiff_at 𝕜 ↑n F' x
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.Finite_presentation R A → Algebra.Finite_Type R A
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (P : ι → P) (j : ι) (W₁ W₂ : ι → k) (hw : ∀ (i : ι), i ≠ j → W₁ i = W₂ i) : ⇑(S.weighted_vsub_of_point P (P j)) W₁ = ⇑(S.weighted_vsub_of_point P (P j)) W₂
{n : ℕ} {A B : Fin n} : ↑A < ↑B ↔ A < B
{G : Type u_1} [Group G] (K : Subgroup G) {k : set G} : Subgroup.Closure k ≤ K ↔ k ⊆ ↑K
{α : Type u_1} [Linear_ordered_AddCommGroup α] {n : ℤ} {A B : α} (hn : n ≠ 0) : n • A = n • B ↔ A = B
(P : ℕ) [hp : Fact (Nat.Prime P)] (q r : ℚ) : padic_norm P (q / r) = padic_norm P q / padic_norm P r
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {C : E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (hb : Filter.Tendsto F (nhds A ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) : deriv (λ (u : ℝ), ∫ (x : ℝ) in u..B, F x) A = -C
{γ : Type u_1} [non_unital_non_assoc_Semiring γ] (x : γ) : _AddMonoid_hom (λ (y : γ), y * x)
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) {x Y : C} (F : Y ⟶ x) (S : CategoryTheory.Sieve x) : J₁.IsClosed S → J₁.IsClosed (CategoryTheory.Sieve.pullback F S)
{R : Type u_1} {R₂ : Type u_2} {m : Type u_4} {m₂ : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] [Semiring R₂] {σ₁₂ : R →+* R₂} [AddCommMonoid m₂] [module R₂ m₂] [Ring_hom_surjective σ₁₂] (F : m →ₛₗ[σ₁₂] m₂) (S : set m) (N : Submodule R₂ m₂) : Submodule.Map F (Submodule.Span R S) ≤ N ↔ ∀ (m : m), m ∈ S → ⇑F m ∈ N
{m : Type u_1} [MulOneClass m] {S : set m} {P : m → m → Prop} {x y : m} (hx : x ∈ Submonoid.Closure S) (hy : y ∈ Submonoid.Closure S) (Hs : ∀ (x : m), x ∈ S → ∀ (y : m), y ∈ S → P x y) (h1_Left : ∀ (x : m), P 1 x) (h1_Right : ∀ (x : m), P x 1) (HMul_Left : ∀ (x y z : m), P x z → P y z → P (x * y) z) (HMul_Right : ∀ (x y z : m), P z x → P z y → P z (x * y)) : P x y
(m : Type u_1) {α : Type u_6} [Monoid m] [MulAction m α] (A₁ A₂ : m) : HasScalar.Smul A₁ ∘ HasScalar.Smul A₂ = HasScalar.Smul (A₁ * A₂)
{R : Type u} [Ring R] (S : Subring R) {x : R} : x ∈ S → -x ∈ S
{α : Type u} [PartialOrder α] {A B : α} : A ≤ B → A < B ∨ A = B
 : UniqueDiffOn ℝ (set.icc 0 1)
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [Linear_ordered_AddCommMonoid β] [HasScalar 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F g : E → β} (hF : strict_ConcaveOn 𝕜 S F) (hg : strict_ConcaveOn 𝕜 S g) : strict_ConcaveOn 𝕜 S (F ⊓ g)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {P : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} {r' : Nnreal} (hF : HasFpowerSeriesOnBall F P x r) (h : ↑r' < r) : TendstoUniformlyOn (λ (n : ℕ) (y : E), P.partial_Sum n (y - x)) F Filter.at_top (Metric.Ball x ↑r')
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {ι : Type u_1} (B : Basis ι R m) [Infinite ι] {κ : Type u_1} (v : κ → m) (i : LinearIndependent R v) : Cardinal.Mk κ ≤ Cardinal.Mk ι
(F : ℝ → ℝ) {A B : ℝ} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hfI : F A = F B) : ∃ (C : ℝ) (h : C ∈ set.Ioo A B), IsExtrOn F (set.icc A B) C
{𝕂 : Type u_1} {𝔸 : Type u_2} [nondiscrete_NormedField 𝕂] [normed_CommRing 𝔸] [normed_Algebra 𝕂 𝔸] [CompleteSpace 𝔸] [CharZero 𝕂] {x : 𝔸} (hx : x ∈ Emetric.Ball 0 (Exp_series 𝕂 𝔸).radius) : HasFderivAt (Exp 𝕂) (Exp 𝕂 x • 1) x
{k : Type u_1} {m : Type u_2} [ordered_Ring k] [ordered_AddCommGroup m] [module k m] [OrderedSmul k m] [CovariantClass m m has_Add.Add has_LT.LT] [ContravariantClass m m has_Add.Add has_LT.LT] {A B : k} {C D : m} (hba : B < A) (hdc : D < C) : A • D + B • C < A • C + B • D
{x : Type u} {m₁ m₂ : x → x → x} {e₁ e₂ : x} (h₁ : EckmannHilton.IsUnital m₁ e₁) (h₂ : EckmannHilton.IsUnital m₂ e₂) (Distrib : ∀ (A B C D : x), m₁ (m₂ A B) (m₂ C D) = m₂ (m₁ A C) (m₁ B D)) : IsCommutative x m₂
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {C : ℝ} {g : α → F} {F' : α → E'} {l : Filter α} : Asymptotics._O_with C l (λ (x : α), ∥F' x∥) g → Asymptotics._O_with C l F' g
{R : Type u} [Semiring R] {m : Polynomial R → Prop} (P : Polynomial R) (h_Add : ∀ (P q : Polynomial R), m P → m q → m (P + q)) (h_monomial : ∀ (n : ℕ) (A : R), m (⇑(Polynomial.monomial n) A)) : m P
{A x : ℝ} (ha : A < 0) : HasStrictDerivAt (λ (x : ℝ), A ^ x) (A ^ x * Real.log A - Real.Exp (Real.log A * x) * Real.sin (x * Real.Pi) * Real.Pi) x
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] [LocallyCompactSpace α] (A : α) : Continuous (λ (F : C(α, β)), ⇑F A)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [TopologicalSpace.SecondCountableTopology α] : {x : α | ∃ (y : α), y < x ∧ set.Ioo y x = ∅}.countable
{R : Type u} {ι : Type u'} {m₁ : ι → Type v₁} {m₂ : Type v₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (m₁ i)] [AddCommMonoid m₂] [Π (i : ι), module R (m₁ i)] [module R m₂] (F : MultilinearMap R m₁ m₂) [Fintype ι] (m m' : Π (i : ι), m₁ i) : ⇑F (m + m') = Finset.Univ.Sum (λ (S : Finset ι), ⇑F (S.piecewise m m'))
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} {F' : ℝ → E} (hab : A ≤ B) (hcont : Continuous_on F (set.icc A B)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo A B → HasDerivWithinAt F (F' x) (set.ioi x) x) (F'Int : IntervalIntegrable F' MeasureTheory.MeasureSpace.Volume A B) : ∫ (y : ℝ) in A..B, F' y = F B - F A
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [AddCommMonoid α] [TopologicalSpace α] [t2_Space α] [Encodable γ] (m : set β → α) (m0 : m ∅ = 0) (S : γ → set β) : ∑' (i : ℕ), m (⋃ (B : γ) (h : B ∈ Encodable.decode₂ γ i), S B) = ∑' (B : γ), m (S B)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {v₂ : Type v'} [AddCommGroup v₂] [module K v₂] (F : v →ₗ[K] v₂) (W : Function.Injective ⇑F) [Finite_dimensional K v₂] : Finite_dimensional K v
{α : Type u_1} {ι : Type u_3} {m : Type u_5} [AddCommMonoid m] {F : α → m} [Fintype ι] {t : ι → set α} (h : Pairwise (Disjoint on t)) (ht : ∀ (i : ι), (t i).Finite) : finsum (λ (A : α), finsum (λ (h : A ∈ ⋃ (i : ι), t i), F A)) = finsum (λ (i : ι), finsum (λ (A : α), finsum (λ (h : A ∈ t i), F A)))
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {S : set 𝕜} {F : 𝕜 → 𝕜} (hs : Convex 𝕜 S) (hF : ∀ {x y z : 𝕜}, x ∈ S → z ∈ S → x < y → y < z → (F z - F y) / (z - y) ≤ (F y - F x) / (y - x)) : ConcaveOn 𝕜 S F
{α : Type u_1} [TopologicalSpace α] [MeasurableSpace α] [Opens_MeasurableSpace α] {S : set α} (hs : Measurable_set S) (A : α) : (nhds_within A S)._measurably_generated
{G : Type u_10} [AddGroup G] (A : G) : ⇑(Equiv.Symm (Equiv.Add_Left A)) = has_Add.Add (-A)
{J : Type v} {C : Type u} [CategoryTheory.Category C] {x Y : C} {F : J → (x ⟶ Y)} [Nonempty J] {C : CategoryTheory.Limits.Cone (CategoryTheory.Limits.parallel_family F)} (i : CategoryTheory.Limits.IsLimit C) : CategoryTheory.Mono (CategoryTheory.Limits.Trident.ι C)
(R : Type u) [Semiring R] {ι : Type v} [decι : DecidableEq ι] {m : ι → Type W} [Π (i : ι), AddCommMonoid (m i)] [Π (i : ι), module R (m i)] (i : ι) (C : R) (x : m i) : ⇑(direct_Sum.of m i) (C • x) = C • ⇑(direct_Sum.of m i) x
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [nondiscrete_NormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (F : MultilinearMap 𝕜 E G) (C : ℝ) (h : ∀ (m : Π (i : ι), E i), ∥⇑F m∥ ≤ C * Finset.Univ.Prod (λ (i : ι), ∥m i∥)) : Continuous ⇑F
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) [CategoryTheory.Full F] [CategoryTheory.Faithful F] {x Y : C} (F : x ⟶ Y) [CategoryTheory.IsIso (F.Map F)] : CategoryTheory.IsIso F
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] (F F' : ℝ → E) {A B : ℝ} {S : set ℝ} (hs : S.countable) (Hc : Continuous_on F (set.Interval A B)) (hD : ∀ (x : ℝ), x ∈ set.Ioo (LinearOrder.min A B) (LinearOrder.max A B)  S → HasDerivAt F (F' x) x) (Hi : IntervalIntegrable F' MeasureTheory.MeasureSpace.Volume A B) : ∫ (x : ℝ) in A..B, F' x = F B - F A
{α : Type u_1} (l : List α) (C : Composition l.length) : (l.split_wrt_Composition C).Join = l
{α : Type u_1} {β : Type u_2} [Linear_ordered_Ring α] [FloorRing α] [TopologicalSpace α] [OrderTopology α] [topological_AddGroup α] [TopologicalSpace β] {F : α → β} (h : Continuous_on F (set.icc 0 1)) (hF : F 0 = F 1) : Continuous (F ∘ Int.fract)
{D : set ℝ} (hD : Convex ℝ D) {F : ℝ → ℝ} (hF : Continuous_on F D) (hF' : DifferentiableOn ℝ F (Interior D)) (hF'' : ∀ (x : ℝ), x ∈ Interior D → 0 < deriv^[2] F x) : strict_Convex_on ℝ D F
{α : Type u_1} [Preorder α] [PredOrder α] {A B : α} [NoMinOrder α] : Order.Pred A < Order.Pred B → A < B
{α : Type u_1} [CancelMonoidWithZero α] {A B C : α} (ha : A ≠ 0) : A * B ∣ A * C ↔ B ∣ C
{K : Type u_1} {S : Type u_2} {t : Type u_3} [Field K] [CommRing S] [CommRing t] [Algebra K S] [Algebra K t] [Algebra S t] [IsScalarTower K S t] (hST : Function.Injective ⇑(Algebra_Map S t)) {x : S} {y : t} (hx : IsIntegral K x) (h : y = ⇑(Algebra_Map S t) x) : minpoly K x = minpoly K y
(m : Type u_1) (N : Type u_2) (α : Type u_3) [HasVadd m α] [HasVadd N α] [VaddCommClass m N α] : VaddCommClass N m α
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : α ≃ₜ β) {B : β} {F : β → E} {g : β → F} {C : ℝ} : Asymptotics._O_with C (nhds B) F g ↔ Asymptotics._O_with C (nhds (⇑(e.Symm) B)) (F ∘ ⇑e) (g ∘ ⇑e)
(F : Type u_1) (E : Type u_2) [Field F] [Field E] [Algebra F E] [Finite_dimensional F E] [_IsSeparable F E] : ∃ (α : E), F⟮α⟯ = ⊤
{Γ₀ : Type u_1} [Linear_ordered_comm_Group_with_Zero Γ₀] (γ : Γ₀ˣ) : nhds ↑γ = has_pure.pure ↑γ
{α : Type u_1} {P : α → Prop} (S : Finset {x // P x}) {A : α} (h : A ∈ Finset.Map (Function.Embedding.Subtype (λ (x : α), P x)) S) : P A
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {F G : C ⥤ D} (h_obj : ∀ (x : C), F.obj x = G.obj x) (h_Map : ∀ (x Y : C) (F : x ⟶ Y), F.Map F = CategoryTheory.Eq_to_hom _ ≫ G.Map F ≫ CategoryTheory.Eq_to_hom _) : F = G
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {S : set α} {t : set β} {F : α → β} (h : set.maps_to F S t) (hc : Continuous F) : set.maps_to F (Closure S) (Closure t)
(𝕜 : Type u_1) {E : Type u_2} [NormedField 𝕜] [NormedSpace ℝ 𝕜] [semi_NormedGroup E] [NormedSpace 𝕜 E] [module ℝ E] [IsScalarTower ℝ 𝕜 E] : locally_Convex_Space ℝ E
{α : Type u} [PseudoMetricSpace α] [ProperSpace α] {x : α} {r : ℝ} {S : set α} (hs : IsClosed S) (h : S ⊆ Metric.Ball x r) : ∃ (r' : ℝ) (h : r' < r), S ⊆ Metric.Ball x r'
{x : Type u} {Y : Type v} [TopologicalSpace x] [TopologicalSpace Y] {F₀ F₁ : C(x, Y)} (F : F₀.Homotopy F₁) : Continuous ⇑F
{α : Type u} [TopologicalSpace α] {ι : Type u_1} [Nonempty ι] {v : ι → set α} (hV : Directed Superset v) (hV_cpct : ∀ (i : ι), IsCompact (v i)) (hV_IsClosed : ∀ (i : ι), IsClosed (v i)) {U : set α} (hU : ∀ (x : α), (x ∈ ⋂ (i : ι), v i) → U ∈ nhds x) : ∃ (i : ι), v i ⊆ U
(x : Type u_2) [TopologicalSpace x] [RegularSpace x] [TopologicalSpace.SecondCountableTopology x] : TopologicalSpace.metrizable_Space x
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) (x y : R) : v.Int_Valuation_def (x + y) ≤ LinearOrder.max (v.Int_Valuation_def x) (v.Int_Valuation_def y)
{m : Type u_1} [has_Mul m] {S t : Subsemigroup m} (h : ∀ (x : m), x ∈ S ↔ x ∈ t) : S = t
{α : Type u} [t : TopologicalSpace α] [TopologicalSpace.IsSeparable_Space α] {ι : Type u_1} {S : ι → set α} {A : set ι} (h : A.Pairwise_Disjoint S) (ha : ∀ (i : ι), i ∈ A → IsOpen (S i)) (h'A : ∀ (i : ι), i ∈ A → (S i).Nonempty) : A.countable
{C : Type u₁} [CategoryTheory.Category C] {x Y Z : C} (F : x ⟶ Z) (g : Y ⟶ Z) [CategoryTheory.Limits.HasPullback F g] : CategoryTheory.IsPullback CategoryTheory.Limits.pullback.fst CategoryTheory.Limits.pullback.Snd F g
{α : Type u_1} {F : α → α} {x y : α} {m n : ℕ} (hx : Function.IsPeriodicPt F m x) (hy : Function.IsPeriodicPt F n y) (hm : 0 < m) (hn : 0 < n) (h : F x = F y) : x = y
{α : Type u_1} [CommMonoid α] (A B u : α) (hu : IsUnit u) : A ∣ u * B ↔ A ∣ B
{α : Type u} {A B : α} [MulOneClass α] [has_Zero α] [Preorder α] [ZeroLt.PosMulMono α] (ha : 1 ≤ A) (hb : 1 ≤ B) (A0 : 0 < A) : 1 ≤ A * B
{K : Type u_1} {v : K} {n : ℕ} [Linear_ordered_Field K] [FloorRing K] {ifp_n ifp_Succ_n : GeneralizedContinuedFraction.Int_fract_pair K} (nth_Stream_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.Some ifp_n) (Succ_nth_Stream_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream v (n + 1) = Option.Some ifp_Succ_n) : ↑(ifp_Succ_n.B) ≤ (ifp_n.fr)⁻¹
{P : ℕ} (z : ℤ) (hp : P ≠ 1) (hz : z ≠ 0) : padic_val_rat P ↑z = ↑((multiplicity ↑P z).get _)
{α : Type u_1} {β : Type u_2} (rα : α → α → Prop) (rβ : β → β → Prop) : Relation.Game_Add rα rβ ≤ Prod.lex rα rβ
{α : Type u} [TopologicalSpace α] {S t : set α} (hs : Dense S) (ht : Dense t) (hso : IsOpen S) : Dense (S ∩ t)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {t₁ t₂ : Affine.Triangle ℝ P} (h : set.Range t₁.points = set.Range t₂.points) : t₁.orthocenter = t₂.orthocenter
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {B₂ : Basis (Fin 2) ℝ v} (hb₂ : Orthonormal ℝ ⇑B₂) (ho : B.Orientation = B₂.Orientation) (x y : v) : hb.oangle x y = hb₂.oangle x y
{R : Type u_1} {m : Type u_3} {A : R} [Monoid R] [MulAction R m] {n : ℕ} (n0 : 0 < n) : IsSmulRegular m (A ^ n) ↔ IsSmulRegular m A
{α : Type u_1} [PseudoMetricSpace α] (r C : ℝ) (hr : r < 1) {F : ℕ → α} (hu : ∀ (n : ℕ), HasDist.dist (F n) (F (n + 1)) ≤ C * r ^ n) {A : α} (ha : Filter.Tendsto F Filter.at_top (nhds A)) (n : ℕ) : HasDist.dist (F n) A ≤ C * r ^ n / (1 - r)
{R : Type u_1} [CommRing R] (F : Polynomial R) (r : R) : (⇑(Polynomial.taylor r) F).Sum (λ (i : ℕ) (A : R), ⇑Polynomial.C A * (Polynomial.x - ⇑Polynomial.C r) ^ i) = F
{α : Type u_1} {ι' : sort u_5} [CompleteLattice α] (S : ι' → α) : (⨆ (i : ι'), S i) = ⨆ (t : Finset (plift ι')) (i : plift ι') (h : i ∈ t), S i.down
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [TopologicalSpace.SecondCountableTopology α] {y : α → α} {S : set α} (h : S.Pairwise_Disjoint (λ (x : α), set.Ioo x (y x))) (h' : ∀ (x : α), x ∈ S → x < y x) : S.countable
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommGroup β] [HasScalar 𝕜 E] [module 𝕜 β] {S : set E} {F : E → β} : strict_ConcaveOn 𝕜 S F → strict_Convex_on 𝕜 S (-F)
{x : Type u} {Y : Type v} [MetricSpace x] [MetricSpace Y] : Isometry Sum.inr_
{m : Type u} [AddZeroClass m] (A : m) : Add_SemiconjBy A 0 0
{x : Type u} [Lattice x] [jordan_holder_Lattice x] {S₁ S₂ : Composition_series x} (hl : S₁.length = S₂.length) (h : ∀ (i : Fin (S₁.length + 1)), ⇑S₁ i = ⇑S₂ (⇑(Fin.cast _) i)) : S₁ = S₂
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {E : Type u₃} [CategoryTheory.Category E] {F : C ⥤ D} {G : D ⥤ E} {h : C ⥤ E} [ℋ : CategoryTheory.Faithful h] (h : F ⋙ G ≅ h) : CategoryTheory.Faithful F
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] {u v : E} (hvm : v ∈ K) (hvo : ∀ (W : E), W ∈ K → HasInner.inner (u - v) W = 0) : ↑(⇑(Orthogonal_projection K) u) = v
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (e e' : LocalHomeomorph α β) (h : ∀ (x : α), ⇑e x = ⇑e' x) (hinv : ∀ (x : β), ⇑(e.Symm) x = ⇑(e'.Symm) x) (hs : e.to_local_Equiv.Source = e'.to_local_Equiv.Source) : e = e'
{R : Type u} [Ring R] {P : Type (max u v)} [AddCommGroup P] [module R P] {ι : Type u_1} (B : Basis ι R P) : module.projective R P
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {F : 𝕜 → F} : iterated_deriv (n + 1) F = iterated_deriv n (deriv F)
(A B : Finset ℕ) : A.Sum (λ (i : ℕ), 2 ^ i) ≤ B.Sum (λ (i : ℕ), 2 ^ i) ↔ A.to_colex ≤ B.to_colex
{α : Type u} {A B : α} [MulZeroOneClass α] [PartialOrder α] [ZeroLt.PosMulMono α] (ha : 1 ≤ A) (hb : 1 ≤ B) (A0 : 0 ≤ A) : 1 ≤ A * B
(x : ℝ) (h1 : 0 < x) (h2 : x < Real.Pi / 2) : x < Real.tan x
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B : α} (ha : 0 ≤ A) (hb : 0 ≤ B) : 0 ≤ A + B
{G : Type u} [Group G] [Fintype G] {P n : ℕ} [hp : Fact (Nat.Prime P)] (hdvd : P ^ (n + 1) ∣ Fintype.Card G) {h : Subgroup G} (hH : Fintype.Card ↥h = P ^ n) : ∃ (K : Subgroup G), Fintype.Card ↥K = P ^ (n + 1) ∧ h ≤ K
{R : Type u_1} [CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {A : Type u_3} [Semiring A] [Algebra R A] {F g : tensor_Algebra R m →ₐ[R] A} (W : F.to_Linear_Map.Comp (tensor_Algebra.ι R) = g.to_Linear_Map.Comp (tensor_Algebra.ι R)) : F = g
{α : Type u_2} {β : Type u_3} [Linear_ordered_Field α] [Archimedean α] [Linear_ordered_Field β] : Subsingleton (α ≃+*o β)
{R : Type u_1} [CommRing R] (S : Type u_2) [CommRing S] [Algebra R S] (t : Type u_4) [CommRing t] [Algebra R t] (m N : Submonoid R) (h : m ≤ N) [IsLocalization m S] [IsLocalization N t] [Algebra S t] [IsScalarTower R S t] : IsLocalization (Submonoid.Map (Algebra_Map R S).to_Monoid_hom N) t
{α : Type u_1} {ι : Type u_2} [Encodable ι] [t : TopologicalSpace α] [P : PolishSpace α] (m : ι → TopologicalSpace α) (hm : ∀ (n : ι), m n ≤ t) (h'm : ∀ (n : ι), PolishSpace α) : ∃ (t' : TopologicalSpace α), (∀ (n : ι), t' ≤ m n) ∧ t' ≤ t ∧ PolishSpace α
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m →* P} (hg : ∀ (y : ↥S), IsUnit (⇑g ↑y)) (z : N) : ⇑g ↑((F.sec z).Snd) * ⇑(F.Lift hg) z = ⇑g (F.sec z).fst
{m : Type u_1} [has_Mul m] (r : m → m → Prop) : Con_gen r = HasInf.Inf {S : Con m | ∀ (x y : m), r x y → ⇑S x y}
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommMonoid β] [module 𝕜 E] [module 𝕜 β] (F : E →ₗ[𝕜] β) {S : set E} (hs : Convex 𝕜 S) : ConcaveOn 𝕜 S ⇑F
{R₁ : Type u_1} [Semiring R₁] {m₁ : Type u_4} [TopologicalSpace m₁] [AddCommMonoid m₁] [module R₁ m₁] [TopologicalSpace R₁] {F g : R₁ ≃L[R₁] m₁} (h : ⇑F 1 = ⇑g 1) : F = g
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : E → ℝ} {A : E} {F' : E →L[ℝ] ℝ} (h : IsLocalExtr F A) : HasFderivAt F F' A → F' = 0
{m : Type u_3} {N : Type u_4} [has_Mul m] [has_Mul N] {F g : m →ₙ* N} (h : F = g) (x : m) : ⇑F x = ⇑g x
(x : AlgebraicGeometry.RingedSpace) {U : TopologicalSpace.Opens ↥x} (F : ↥(x.to_PresheafedSpace.presheaf.obj (Opposite.Op U))) : IsUnit (⇑(x.to_PresheafedSpace.presheaf.Map (CategoryTheory.hom_of_LE _).Op) F)
{ι : sort u_1} [Nonempty ι] {F : ι → Ennreal} {x : Ennreal} (h : x ≠ ⊤) : infi F * x = ⨅ (i : ι), F i * x
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {E' : Type u_7} [InnerProductSpace 𝕜 E'] {v : ι → E} (hv : Orthonormal 𝕜 v) (F : E ≃ₗᵢ[𝕜] E') : Orthonormal 𝕜 (⇑F ∘ v)
{A B : Cardinal} : Cardinal.aleph0 ≤ A * B ↔ A ≠ 0 ∧ Cardinal.aleph0 ≤ B ∨ Cardinal.aleph0 ≤ A ∧ B ≠ 0
{m : Type u_1} [MulOneClass m] (S : Submonoid m) : 1 ∈ S
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {ι : Type W} [Fintype ι] (h : Basis ι R m) : module.rank R m = ↑(Fintype.Card ι)
{α : Type u_1} [CommSemiring α] (t : Tree α) (r₁ r₂ : tactic_.Ring2.CsringExpr) (h : tactic_.Ring2.HornerExpr.of_csexpr r₁ = tactic_.Ring2.HornerExpr.of_csexpr r₂) : tactic_.Ring2.CsringExpr.Eval t r₁ = tactic_.Ring2.CsringExpr.Eval t r₂
{k : Type u_1} {m : Type u_2} [ordered_Ring k] [ordered_AddCommGroup m] [module k m] [OrderedSmul k m] {A : m} {C : k} (hc : C < 0) : 0 < A → C • A < 0
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) : hb.oangle x y + hb.oangle y x = 0
(A : Type u_2) (K : Type u_3) [CommRing A] [Field K] [IsDomain A] [Algebra A K] [_fraction_Ring A K] {L : Type u_4} [Field L] [Algebra K L] [Finite_dimensional K L] [Algebra A L] [IsScalarTower A K L] (S : Finset L) : ∃ (y : A) (h : y ≠ 0), ∀ (x : L), x ∈ S → IsIntegral A (y • x)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e e' : LocalHomeomorph α β} (h : e ≈ e') : set.Eq_on ⇑(e.Symm) ⇑(e'.Symm) e.to_local_Equiv.Target
{α : Type u} [PseudoMetricSpace α] (P : α → Prop) (x : α) (h : ∃ᶠ (R : ℝ) in Filter.at_top, ∀ (y : α), y ∈ metric.IsClosed_ball x R → P y) (y : α) : P y
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x Y : C} (F g : x ⟶ Y) [CategoryTheory.Limits.HasCoequalizer F g] : CategoryTheory.Limits.HasCokernel (F - g)
{x : ℝ} (n : ℕ) {m : ℤ} (hm : m ≠ 0) (P : ℕ) [hp : Fact (Nat.Prime P)] (hxr : x ^ n = ↑m) (hv : (multiplicity ↑P m).get _ % n ≠ 0) : Irrational x
{k : Type u_1} {m : Type u_2} [ordered_Ring k] [ordered_AddCommGroup m] [module k m] [OrderedSmul k m] [ContravariantClass m m has_Add.Add has_LE.LE] {A B : k} {C D : m} (hab : A ≤ B) (hcd : C ≤ D) : A • D + B • C ≤ A • C + B • D
{R : Type u} [CommRing R] [IsDomain R] (hR : discrete_Valuation_Ring.has_Unit_Mul_Pow_Irreducible_factorization R) : discrete_Valuation_Ring R
(𝕜 : Type u_2) [_R_or_C 𝕜] (E : Type u_3) [InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] : ∃ (W : set E) (B : hilbert_Basis ↥W 𝕜 E), ⇑B = Coe
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {S : set (E × F)} {P : E × F} : ContDiff_within_at 𝕜 n Prod.Snd S P
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {ι' : Type u_3} {v : ι → E} (hv : Orthonormal 𝕜 v) (F : ι' → ι) (hF : Function.Injective F) : Orthonormal 𝕜 (v ∘ F)
(R : Type u) (L : Type v) (m : Type W) [CommRing R] [lie_Ring L] [lie_Algebra R L] [AddCommGroup m] [module R m] [lie_Ring_module L m] [lie_module R L m] [lie_module.IsNilpotent R L m] : (⨅ (x : L), (⇑(lie_module.to_endomorphism R L m) x).Maximal_generalized_eigenspace 0) = ⊤
{R : Type u_1} [non_assoc_Semiring R] [Nontrivial R] (hR : Ring_Char R ≠ 2) : 2 ≠ 0
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [nondiscrete_NormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (F : Continuous_MultilinearMap 𝕜 E G) (m : Π (i : ι), E i) : ∥⇑F m∥₊ ≤ ∥F∥₊ * Finset.Univ.Prod (λ (i : ι), ∥m i∥₊)
{K : Type u} {v : Type v} [Field K] [AddCommGroup v] [module K v] {v₂ : Type v'} [AddCommGroup v₂] [module K v₂] [Finite_dimensional K v] (F : v →ₗ[K] v₂) : Finite_dimensional.finrank K ↥(F.Range) + Finite_dimensional.finrank K ↥(F.Ker) = Finite_dimensional.finrank K v
{m : Type u_2} {α : sort u_4} [AddCommMonoid m] {F : α → m} (P : m → Prop) (hp₀ : P 0) (hp₁ : ∀ (x y : m), P x → P y → P (x + y)) (hp₂ : ∀ (i : α), P (F i)) : P (finsum (λ (i : α), F i))
{α : Type u_1} [TopologicalSpace α] [BaireSpace α] {F : ℕ → set α} (ho : ∀ (n : ℕ), IsOpen (F n)) (hD : ∀ (n : ℕ), Dense (F n)) : Dense (⋂ (n : ℕ), F n)
{α : Type u_1} {β : Type u_2} {ι : Type u_3} (A : α) (B : β) (i : ι) : (Filter.Map (λ (_x : α), B) (Filter.principal {A})).Coprod (Filter.Map Id (Filter.principal {i})) = Filter.principal ({B} ×ˢ set.Univ ∪ set.Univ ×ˢ {i})
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (θ₁ θ₂ : Real.Angle) : (hb.rotation θ₁).Trans (hb.rotation θ₂) = hb.rotation (θ₂ + θ₁)
{C : Type u₁} [CategoryTheory.Category C] {Z x Y : C} (F : Z ⟶ x) (g : Z ⟶ Y) [CategoryTheory.Limits.HasPushout F g] : CategoryTheory.IsPushout F g CategoryTheory.Limits.pushout.inl_ CategoryTheory.Limits.pushout.inr_
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.Finite_Type R A ↔ ∃ (S : Finset A) (F : mv_Polynomial {x // x ∈ S} R →ₐ[R] A), Function.Surjective ⇑F
{x Y : CompHaus} (F : x ⟶ Y) (bij : Function.Bijective ⇑F) : CategoryTheory.IsIso F
{α : Type u} [PseudoMetricSpace α] {S : set α} (h : S.Finite) : Metric.Bounded S
{α : Type u_3} {β : Type u_4} [Linear_ordered_Field α] {l : Filter β} {F : β → α} {r : α} (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_top) : Filter.Tendsto (λ (x : β), F x * r) l Filter.at_top
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P₁ : ι → P) (P₂ : P) (h : S.Sum (λ (i : ι), W i) = 1) : S.Sum (λ (i : ι), W i • (P₁ i -ᵥ P₂)) = ⇑(S.affine_combination P₁) W -ᵥ P₂
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) : ⇑Linear_Equiv.det hb.Conj_lie.to_Linear_Equiv = -1
{𝕜 : Type u_1} {v : Type u_2} {v₂ : Type u_4} {P : Type u_8} {P₂ : Type u_9} [NormedField 𝕜] [semi_NormedGroup v] [semi_NormedGroup v₂] [NormedSpace 𝕜 v] [NormedSpace 𝕜 v₂] [PseudoMetricSpace P] [PseudoMetricSpace P₂] [NormedAddTorsor v P] [NormedAddTorsor v₂ P₂] {F : P →ᵃ[𝕜] P₂} : Continuous ⇑(F.Linear) ↔ Continuous ⇑F
(k : ℕ) {r : ℝ} (hr : 0 ≤ r) (h'r : r < 1) : Filter.Tendsto (λ (n : ℕ), ↑n ^ k * r ^ n) Filter.at_top (nhds 0)
{β : Type u} {γ : Type W} [non_assoc_Semiring β] [non_assoc_Semiring γ] (F : β →+* γ) (S : Multiset β) : ⇑F S.Sum = (Multiset.Map ⇑F S).Sum
{α : Type u} {β : Type v} [TopologicalSpace α] [Preorder α] [t : order_IsClosed_topology α] [TopologicalSpace β] {F g : β → α} {S : set β} (hs : IsClosed S) (hF : Continuous_on F S) (hg : Continuous_on g S) : IsClosed {x ∈ S | F x ≤ g x}
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {C : E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (ha : Filter.Tendsto F (nhds A ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) : HasStrictDerivAt (λ (u : ℝ), ∫ (x : ℝ) in u..B, F x) (-C) A
{α : Type u} (F : Fin 0 → α) : List.of_fn F = List.Nil
{K : Type u_1} [Linear_ordered_Field K] {v : K} [FloorRing K] (terminates : (GeneralizedContinuedFraction.of v).terminates) : ∃ (n : ℕ), v = (GeneralizedContinuedFraction.of v).convergents n
{α β : Type u_1} (e : α ≃ β) : e.Option_congr = Equiv_Functor.Map_Equiv Option e
{α : Type u_1} [CommMonoid α] (A B u : α) (hu : IsUnit u) : u * A ∣ B ↔ A ∣ B
(𝕜 : Type u_1) {E : Type u_4} [NormedGroup E] [nondiscrete_NormedField 𝕜] [NormedSpace 𝕜 E] (𝕜' : Type u_12) [NormedField 𝕜'] [normed_Algebra 𝕜 𝕜'] [NormedSpace 𝕜' E] [IsScalarTower 𝕜 𝕜' E] [Nontrivial E] : ∥Continuous_Linear_Map.lsmul 𝕜 𝕜'∥ = 1
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (F : E →L[𝕜] F) [CompleteSpace F] (surj : Function.Surjective ⇑F) : ∃ (C : ℝ) (h : C ≥ 0), ∀ (y : F), ∃ (x : E), HasDist.dist (⇑F x) y ≤ 1 / 2 * ∥y∥ ∧ ∥x∥ ≤ C * ∥y∥
{q : ℕ+} (W : 1 < q) : Fintype.Card (LucasLehmer.x q)ˣ < ↑q ^ 2
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} [DecidableEq α'] [DecidableEq γ] [DecidableEq δ] {F : α → β → γ} {S : Finset α} {t : Finset β} {g : γ → δ} {F' : α' → β → δ} {g' : α → α'} (h_Distrib : ∀ (A : α) (B : β), g (F A B) = F' (g' A) B) : Finset.image g (Finset.image₂ F S t) = Finset.image₂ F' (Finset.image g' S) t
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F₂ : 𝕜 → F} {S₂ : set 𝕜} {n : ℕ} (hs : UniqueDiffOn 𝕜 S₂) : ContDiff_on 𝕜 ↑(n + 1) F₂ S₂ ↔ DifferentiableOn 𝕜 F₂ S₂ ∧ ContDiff_on 𝕜 ↑n (deriv_within F₂ S₂) S₂
{G : Type u_1} [AddGroup G] {h K : Add_Subgroup G} (h : ∀ (x : G), x ∈ h ↔ x ∈ K) : h = K
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F : x ⟶ Y} (F : CategoryTheory.Limits.StrongEpiMonoFactorisation F) {F' : CategoryTheory.Limits.MonoFactorisation F} (hF' : CategoryTheory.Limits.IsImage F') : CategoryTheory.StrongEpi F'.e
{α : Type u} [PseudoMetricSpace α] (x y : α) : HasEdist.edist x y ≠ ⊤
{ι : Type u_1} {R : Type u_3} {m : Type u_5} {m' : Type u_6} {v : ι → m} [Semiring R] [AddCommMonoid m] [AddCommMonoid m'] [module R m] [module R m'] (F : m →ₗ[R] m') (hfv : LinearIndependent R (⇑F ∘ v)) : LinearIndependent R v
 : ¬Summable (λ (n : ℕ), (↑n)⁻¹)
(R : Type u) [Semiring R] (P q : ℕ) [hp : Char_P R P] [hq : ExpChar R q] : P = q ↔ Nat.Prime P
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Zero_object C] (x : C) [IsSimpleOrder (CategoryTheory.Subobject x)] : CategoryTheory.Simple x
{G : Type u_1} [Group G] (h₁ h₂ : Subgroup G) (hH₁ : h₁.Normal) (hH₂ : h₂.Normal) (hdis : Disjoint h₁ h₂) (x y : G) (hx : x ∈ h₁) (hy : y ∈ h₂) : Commute x y
{R : Type u} [CommSemiring R] {n : ℕ} (m : Fin n →₀ ℕ) (F : mv_Polynomial (Fin (n + 1)) R) (i : ℕ) : mv_Polynomial.Coeff m ((⇑(mv_Polynomial.Fin_Succ_Equiv R n) F).Coeff i) = mv_Polynomial.Coeff (Finsupp.Cons i m) F
(t : ℝ) : Filter.Tendsto (λ (x : ℕ), (1 + t / ↑x) ^ x) Filter.at_top (nhds (Real.Exp t))
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [AddCommMonoid F] [ordered_AddCommMonoid β] [module 𝕜 E] [module 𝕜 F] [HasScalar 𝕜 β] {F : F → β} {S : set F} (hF : Convex_on 𝕜 S F) (g : E →ₗ[𝕜] F) : Convex_on 𝕜 (⇑g ⁻¹' S) (F ∘ ⇑g)
{α : Type u_1} {N : Type u_6} [CommMonoid N] {F : α → N} (A : α) (hF : (Function.MulSupport F).Finite) : F A ∣ finprod F
{C : Type u} [CategoryTheory.Category C] (F G : C ⥤ CategoryTheory.Discrete PUnit) : F = G
{P : ℕ} [hp : Fact (Nat.Prime P)] : WittVector.IsPoly P (λ (R : Type u_1) (_x : CommRing R), HasNeg.Neg)
{α : Type u_1} {β : Type u_2} [t : TopologicalSpace β] [PolishSpace β] (F : α ≃ β) : PolishSpace α
{R : Type u} {n : ℕ} {m : Fin n.Succ → Type v} {m₂ : Type v₂} [Semiring R] [Π (i : Fin n.Succ), AddCommMonoid (m i)] [AddCommMonoid m₂] [Π (i : Fin n.Succ), module R (m i)] [module R m₂] (F : MultilinearMap R m m₂) (m : Π (i : Fin n), m (⇑Fin.cast_Succ i)) (C : R) (x : m (Fin.Last n)) : ⇑F (Fin.snoc m (C • x)) = C • ⇑F (Fin.snoc m x)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {v₂ : Type v'} [AddCommGroup v₂] [module K v₂] (F : v ≃ₗ[K] v₂) [Finite_dimensional K v] : Finite_dimensional K v₂
(C : Type u) [𝒞 : CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryCoproducts C] [CategoryTheory.Limits.HasCoequalizers C] : CategoryTheory.Limits.HasPushouts C
{α : Type u_1} {β : Type u_2} [Group α] [comm_Group β] {F : α → β} (hF : _Group_hom F) : _Group_hom (λ (A : α), (F A)⁻¹)
(R : Type u_1) [CommRing R] [IsDomain R] (P : ℕ) [Char_P R P] (hp : P ≠ 2) : Polynomial.cyclotomic' 2 R = Polynomial.x + 1
{R : Type u_8} [OrderedSemiring R] [Nontrivial R] (l : List R) (h : ∀ (A : R), A ∈ l → 0 < A) : 0 < l.Prod
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) {P : P} (hp : P ∈ affine_Span ℝ (set.Range S.points)) {r : ℝ} (hr : ∀ (i : Fin (n + 1)), HasDist.dist (S.points i) P = r) : P = S.circumcenter
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type W} [CategoryTheory.Limits.HasPullbacks C] (K : CategoryTheory.Pretopology C) : CategoryTheory.Presieve._sheaf (CategoryTheory.Pretopology.to_grothendieck C K) P ↔ ∀ {x : C} (R : CategoryTheory.Presieve x), R ∈ ⇑K x → CategoryTheory.Presieve.IsSheafFor P R
{α : Type u_3} [SemilatticeSup α] [NoMaxOrder α] (A : α) : Filter.Map Coe Filter.at_top = Filter.at_top
{α : Type u_1} (r : α → α → Prop) [IsRefl α r] : {C : Cardinal | ∃ (S : set α), (∀ (A : α), ∃ (B : α) (h : B ∈ S), r A B) ∧ Cardinal.Mk ↥S = C}.Nonempty
{x y : Game} : ¬x ≤ y ↔ y.lf x
{C : Type u₁} [CategoryTheory.Category C] {Z x Y : C} {F : Z ⟶ x} {g : Z ⟶ Y} {C : CategoryTheory.Limits.pushout_Cocone F g} (h : CategoryTheory.Limits.IsColimit C) : CategoryTheory.IsPushout F g C.inl_ C.inr_
{m : Type u_1} [CommMonoid m] (S : Submonoid m) : Localization.r S = Localization.r' S
{G : Type u_1} [Group G] [TopologicalSpace G] [topological_Group G] {h : Subgroup G} (h_1_Int : 1 ∈ Interior ↑h) : IsOpen ↑h
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) {r : ℝ} (hr : 0 < r) : o.oangle (r • x) y = o.oangle x y
{R : Type u_1} [CommRing R] (v W : Fin 3 → R) : Matrix.dot_Product v (⇑(⇑CrossProduct v) W) = 0
{G : Type u} [Group G] {N : Subgroup G} [N.Normal] (hN : (Nat.Card ↥N).IsCoprime N.Index) : ∃ (h : Subgroup G), h.Complement' N
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P (n + 1)) : 0 < S.circumradius
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set ℝ} [IntervalIntegral.FTC_Filter B (nhds_within B S) (nhds_within B t)] (hmeas : StronglyMeasurableAtFilter F (nhds_within B t) MeasureTheory.MeasureSpace.Volume) (hb : Continuous_within_at F t B) (hs : UniqueDiffWithinAt ℝ S B . "UniqueDiffWithinAt_ici_Iic_Univ") : deriv_within (λ (u : ℝ), ∫ (x : ℝ) in A..u, F x) S B = F B
{α : Type u_1} (v : Vector α 1) : v.to_List = [v.head]
{α : Type u} {β : Type v} {γ : Type W} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [conditionally_complete_LinearOrder β] [TopologicalSpace β] [OrderTopology β] [Nonempty γ] {F : α → β} {g : γ → α} (Cf : Continuous_at F (⨆ (i : γ), g i)) (Mf : Monotone F) (h : BddAbove (set.Range g)) : F (⨆ (i : γ), g i) = ⨆ (i : γ), F (g i)
{k : Type u₁} {G : Type u₂} {R : Type u_1} [Semiring k] [AddMonoid G] [Semiring R] {F g : AddMonoid_Algebra k G →+* R} (h₀ : ∀ (B : k), ⇑F (Finsupp.single 0 B) = ⇑g (Finsupp.single 0 B)) (h_of : ∀ (A : G), ⇑F (Finsupp.single A 1) = ⇑g (Finsupp.single A 1)) : F = g
(A : Zmod 8) : ⇑Zmod.χ₈ A = 0 ∨ ⇑Zmod.χ₈ A = 1 ∨ ⇑Zmod.χ₈ A = -1
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] : Finite_dimensional.finrank K v = 1 ↔ ∃ (v : v) (n : v ≠ 0), ∀ (W : v), ∃ (C : K), C • v = W
{P : ℝ} : P ≤ 0 → Ennreal.of_Real P = 0
(P : ℕ → Prop) [Decidable_Pred P] (i : Infinite ↥(set_of P)) (n : ℕ) : Nat.nth P n = ↑(⇑(Nat.Subtype.order_iso_of_Nat (set_of P)) n)
{x : Pgame} (h : 0 ≤ x) (j : x.Right_moves) : 0 ≤ (x.move_Right j).move_Left (Pgame.Left_response h j)
{α : Type u} [TopologicalSpace α] {S : set α} : IsCompact S → ∀ (F : Ultrafilter α), ↑F ≤ Filter.principal S → (∃ (A : α) (h : A ∈ S), ↑F ≤ nhds A)
{α : Type u} (F : α → Type (max u v)) : ¬Function.Surjective F
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {S : set ℝ} {e : E} {A : ℝ} {F : ℝ → E} (F_Diff : DifferentiableOn ℝ F S) (F_lim : Continuous_within_at F S A) (hs : S ∈ nhds_within A (set.ioi A)) (F_lim' : Filter.Tendsto (λ (x : ℝ), deriv F x) (nhds_within A (set.ioi A)) (nhds e)) : HasDerivWithinAt F e (set.ici A) A
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [CompactSpace α] [MetricSpace β] : Continuous (λ (P : C(α, β) × α), ⇑(P.fst) P.Snd)
{α : Type u_1} {ι : Type u_2} {β : Type u_3} {S : ι → set α} {F : Π (i : ι), ↥(S i) → β} {hF : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), F i ⟨x, hxi⟩ = F j ⟨x, hxj⟩} {t : set α} (hT' : t = set.Union S) (u : ↥t → ↥t) (ui : Π (i : ι), ↥(S i) → ↥(S i)) (hui : ∀ (i : ι) (x : ↥(S i)), u (set.inclusion _ x) = set.inclusion _ (ui i x)) (uβ : β → β) (h : ∀ (i : ι) (x : ↥(S i)), F i (ui i x) = uβ (F i x)) (x : ↥t) : set.Union_Lift S F hF t _ (u x) = uβ (set.Union_Lift S F hF t _ x)
{A B P q : ℝ} (ha : 0 ≤ A) (hb : 0 ≤ B) (hpq : P.IsConjugateExponent q) : A * B ≤ A ^ P / P + B ^ q / q
{α : Type u_1} [conditionally_CompleteLattice α] {S : set α} {A : α} (hs : BddBelow S) (sne : S.Nonempty) : HasInf.Inf (HasInsert.Insert A S) = A ⊓ HasInf.Inf S
{m : Type u_1} {N : Type u_2} [MulOneClass m] [MulOneClass N] (h : m ≃* N) : _Monoid_hom ⇑h
{α : Type u} [TopologicalSpace α] {S : set α} (hs : IsCompact S) {F : Filter α} (hF : ∀ (A : α), A ∈ S → (∃ (t : set α) (h : t ∈ nhds_within A S), tᶜ ∈ F)) : Sᶜ ∈ F
(P : ℕ) [hp : Fact (Nat.Prime P)] (n j : ℕ) (hj : j < P ^ n) : P ^ (n - pnat_multiplicity P ⟨j + 1, _⟩) ∣ (P ^ n).choose (j + 1)
(B C : ℝ) (n : ℕ) (hb : 0 < B) : Filter.Tendsto (λ (x : ℝ), (B * Real.Exp x + C) / x ^ n) Filter.at_top Filter.at_top
{α : Type u_1} {β : Type u_2} [has_Mul α] [comm_Group β] {F : α → β} (hF : _Mul_hom F) : _Mul_hom (λ (A : α), (F A)⁻¹)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (h : P 1 = ⇑((Continuous_multilinear_Curry_Fin1 𝕜 E F).Symm) ↑i) : (P.Left_Inv i).Comp P = FormalMultilinearSeries.Id 𝕜 E
{x y : Pgame} : x ≤ y ↔ (∀ (i : x.Left_moves), (x.move_Left i).lf y) ∧ ∀ (j : y.Right_moves), x.lf (y.move_Right j)
{m : Type u_1} [Monoid m] (x : m) : _Submonoid (Powers x)
{m : Type u} [AddZeroClass m] (x : m) : Add_SemiconjBy 0 x x
{R : Type u_1} [Linear_ordered_Field R] [FloorRing R] {B : ℕ} (hb : 1 < B) {x : ℤ} {r : R} (hr : 0 < r) : ↑B ^ x < r ↔ x < Int.clog B r
{α : Type u} {β : Type v} [Ring α] [Ring β] {F : α → β} (hF : _Ring_hom F) {γ : Type u_1} [Ring γ] {g : β → γ} (hg : _Ring_hom g) : _Ring_hom (g ∘ F)
(K : Type u) [Field K] (v : Type v) [AddCommGroup v] [module K v] [Finite_dimensional K v] : (LinearMap.ltensor v (contract_Left K v)).Comp ((TensorProduct.assoc K v (module.dual K v) v).to_Linear_Map.Comp (LinearMap.rtensor v (coevaluation K v))) = (TensorProduct.rid K v).Symm.to_Linear_Map.Comp (TensorProduct.lid K v).to_Linear_Map
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} [Nontrivial k] {S : Finset ι} {W : ι → k} (h : S.Sum (λ (i : ι), W i) = 1) (P : ι → P) : ⇑(S.affine_combination P) W ∈ affine_Span k (set.Range P)
{α : Type u_1} [DecidableEq α] [Fintype α] {F g : Equiv.perm α} (hF : F._Cycle) (hg : g._Cycle) (h : F.Support ⊆ g.Support) (h' : ∀ (x : α), x ∈ F.Support → ⇑F x = ⇑g x) : F = g
{α : Type u} [Preorder α] {S t : set α} (h : BddBelow t) : BddBelow (S ∩ t)
{α : Type u_1} [DecidableEq α] {S t : Finset α} (h : S ⊆ t) : (Finset.ioc S t).Card = 2 ^ (t.Card - S.Card) - 1
(C : Type u) [CategoryTheory.Category C] : Nonempty (C ≌ CategoryTheory.Discrete PUnit) ↔ Nonempty C ∧ ∀ (x y : C), Nonempty (Unique (x ⟶ y))
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} : InnerProductGeometry.angle x y = 0 ↔ x ≠ 0 ∧ ∃ (r : ℝ), 0 < r ∧ y = r • x
{C : Type u₁} [CategoryTheory.Category C] {A : C} [CategoryTheory.Limits.HasTerminal C] (hA : CategoryTheory.IsSubterminal A) : CategoryTheory.Mono (CategoryTheory.Limits.terminal.from A)
{n : ℤ} : IsUnit n → n.Nat_Abs = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {D : Type u₁} [CategoryTheory.Category D] (L : C ⥤ D) [CategoryTheory.IsLeftAdjoint L] : CategoryTheory.IsCofiltered D
(𝕂 : Type u_1) {𝔸 : Type u_2} {𝔹 : Type u_3} [_R_or_C 𝕂] [NormedRing 𝔸] [normed_Algebra 𝕂 𝔸] [NormedRing 𝔹] [normed_Algebra 𝕂 𝔹] [CompleteSpace 𝔸] {F : Type u_4} [Ring_hom_class F 𝔸 𝔹] (F : F) (hF : Continuous ⇑F) (x : 𝔸) : ⇑F (Exp 𝕂 x) = Exp 𝕂 (⇑F x)
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y z : m} (hx : SameRay R x z) (hy : SameRay R y z) : SameRay R (x + y) z
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [MetricSpace β] {F : α → β} (h : Embedding F) : Isometry F
{α : Type u} {β : Type v} [PseudoEmetricSpace α] [PseudoEmetricSpace β] {F : α → β} (hF : Isometry F) (x y : α) : HasEdist.edist (F x) (F y) = HasEdist.edist x y
{R : Type u} [Semiring R] {P : Polynomial R} {n : ℕ} (r : R) : P * Polynomial.x ^ n * ⇑Polynomial.C r = P * ⇑Polynomial.C r * Polynomial.x ^ n
(P : ℕ → Prop) [Decidable_Pred P] (n : ℕ) : Nat.count P n = Fintype.Card {k // k < n ∧ P k}
{ι : Type u_1} {R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] (B : Basis ι R m) {x y : m} (h : ∀ (i : ι), ⇑(⇑(B.repr) x) i = ⇑(⇑(B.repr) y) i) : x = y
{𝕜 : Type u_1} {E : Type u_2} [Linear_ordered_Field 𝕜] [ordered_AddCommGroup E] [module 𝕜 E] (S : Convex_cone 𝕜 E) (h : ∀ (x y : E), x ≤ y ↔ y - x ∈ S) : OrderedSmul 𝕜 E
{G : Type u_4} [NormedGroup G] [NormedSpace ℝ G] {S : set G} {x y : G} (h : Segment ℝ x y ⊆ S) : y - x ∈ TangentConeAt ℝ S x
{α : Type u} [PseudoEmetricSpace α] {S t : set α} (hs : S.Nonempty) (Fin : Emetric.Hausdorff_edist S t ≠ ⊤) : t.Nonempty
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) [CategoryTheory.IsIso h.counit] : CategoryTheory.Faithful R
{m : Type u_1} [AddCommMonoid m] (S : Add_Submonoid m) : Add_Localization.r S = Add_Localization.r' S
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} {t : set (set α)} (h : t.Pairwise_Disjoint Id) (ht₀ : t.Finite) (ht₁ : ∀ (x : set α), x ∈ t → x.Finite) : finprod (λ (A : α), finprod (λ (h : A ∈ ⋃₀t), F A)) = finprod (λ (S : set α), finprod (λ (h : S ∈ t), finprod (λ (A : α), finprod (λ (h : A ∈ S), F A))))
{R₂ : Type u_5} {m₂ : Type u_6} [CommSemiring R₂] [AddCommMonoid m₂] [module R₂ m₂] {B₂ : BilinForm R₂ m₂} {ι : Type u_13} (B : Basis ι R₂ m₂) (x y : m₂) : (⇑(B.repr) x).Sum (λ (i : ι) (xi : R₂), (⇑(B.repr) y).Sum (λ (j : ι) (yj : R₂), xi • yj • ⇑B₂ (⇑B i) (⇑B j))) = ⇑B₂ x y
{C : Type u} [CategoryTheory.Category C] {x Y : AlgebraicGeometry.PresheafedSpace C} (F : x ⟶ Y) [h : AlgebraicGeometry.PresheafedSpace.IsOpen_immersion F] [h' : CategoryTheory.Epi F.Base] : CategoryTheory.IsIso F
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [Linear_ordered_Field 𝕜] [AddCommGroup E] [ordered_AddCommGroup β] [module 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F : E → β} {t : Finset ι} {W : ι → 𝕜} {P : ι → E} (hF : Convex_on 𝕜 S F) (h₀ : ∀ (i : ι), i ∈ t → 0 ≤ W i) (h₁ : t.Sum (λ (i : ι), W i) = 1) (hmem : ∀ (i : ι), i ∈ t → P i ∈ S) : F (t.Sum (λ (i : ι), W i • P i)) ≤ t.Sum (λ (i : ι), W i • F (P i))
{β : Type u_2} [CommMonoid β] {n : ℕ} (F : Fin (n + 1) → β) : Finset.Univ.Prod (λ (i : Fin (n + 1)), F i) = Finset.Univ.Prod (λ (i : Fin n), F (⇑Fin.cast_Succ i)) * F (Fin.Last n)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {la lb : Filter ℝ} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F la MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F lb MeasureTheory.MeasureSpace.Volume) {S t : set ℝ} [IntervalIntegral.FTC_Filter A (nhds_within A S) la] [IntervalIntegral.FTC_Filter B (nhds_within B t) lb] (ha : Filter.Tendsto F la (nhds (F A))) (hb : Filter.Tendsto F lb (nhds (F B))) : HasFderivWithinAt (λ (P : ℝ × ℝ), ∫ (x : ℝ) in P.fst..P.Snd, F x) ((Continuous_Linear_Map.Snd ℝ ℝ ℝ).Smul_Right (F B) - (Continuous_Linear_Map.fst ℝ ℝ ℝ).Smul_Right (F A)) (S ×ˢ t) (A, B)
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (g : G) (P : P) : g +ᵥ P -ᵥ P = g
{n : WithTop ℕ} {𝕂 : Type u_6} [_R_or_C 𝕂] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {F : 𝕂 → F'} {x : 𝕂} (hF : ContDiff_at 𝕂 n F x) (hn : 1 ≤ n) : HasStrictDerivAt F (deriv F x) x
{𝕜 : Type u_1} [_R_or_C 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {r : ℝ} (hr : 0 < r) : NormedSpace.polar 𝕜 (metric.IsClosed_ball 0 r) = metric.IsClosed_ball 0 r⁻¹
{R : Type u_1} {Rₘ : Type u_2} [CommRing R] [CommRing Rₘ] {m : Submonoid R} (hM : 0 ∉ m) (hR : _Field R) [Algebra R Rₘ] [IsLocalization m Rₘ] : Function.Bijective ⇑(Algebra_Map R Rₘ)
(P : ℕ) (q : ℚ) : 0 ≤ padic_norm P q
{α : Type u_1} {β : Type u_2} [SemilatticeInf α] [OrderTop α] {P : α → Prop} {Ptop : P ⊤} {Pinf : ∀ ⦃x y : α⦄, P x → P y → P (x ⊓ y)} (t : Finset β) (F : β → {x // P x}) : ↑(t.Inf F) = t.Inf (λ (x : β), ↑(F x))
{α : Type u_1} {F g : ℕ → α} [TopologicalSpace α] [non_unital_non_assoc_Semiring α] [RegularSpace α] [topological_Semiring α] (hF : Summable F) (hg : Summable g) (hfg : Summable (λ (x : ℕ × ℕ), F x.fst * g x.Snd)) : (∑' (n : ℕ), F n) * ∑' (n : ℕ), g n = ∑' (n : ℕ), (Finset.Nat.antidiagonal n).Sum (λ (kl : ℕ × ℕ), F kl.fst * g kl.Snd)
{m : Type u_1} [AddMonoid m] {γ : Type u_2} [AddMonoid γ] {F : m → γ} (hF : _AddMonoid_hom F) : _Add_Submonoid (set.Range F)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} {F' : ℝ → E} (hderiv : ∀ (x : ℝ), x ∈ set.Interval A B → HasDerivAt F (F' x) x) (hint : IntervalIntegrable F' MeasureTheory.MeasureSpace.Volume A B) : ∫ (y : ℝ) in A..B, F' y = F B - F A
{α : Type u} {β : Type v} [AddGroup α] [AddAction α β] (g : α) (x : β) : AddAction.Stabilizer α (g +ᵥ x) = Add_Subgroup.Map (Add_Equiv.to_AddMonoid_hom (⇑Add_aut.Conj g)) (AddAction.Stabilizer α x)
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {m : α → β → γ} {F : Filter α} {g : Filter β} {n : γ → δ} {m' : α → β' → δ} {n' : β → β'} (h_Distrib : ∀ (A : α) (B : β), n (m A B) = m' A (n' B)) : Filter.Map n (Filter.Map₂ m F g) = Filter.Map₂ m' F (Filter.Map n' g)
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type W} {x : C} (R : CategoryTheory.Presieve x) : CategoryTheory.Presieve.IsSheafFor P R ↔ CategoryTheory.Presieve.IsSheafFor P ⇑(CategoryTheory.Sieve.generate R)
{α : Type u_1} {β : Type u_2} {rα : α → α → Prop} {rβ : β → β → Prop} (F : α → β) (fib : Relation.Fibration rα rβ F) {A : α} (ha : Acc rα A) : Acc rβ (F A)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) {fs : Finset (Fin (n + 1))} {m : ℕ} (h : fs.Card = m + 1) : ↑(⇑((S.face h).Orthogonal_projection_Span) S.circumcenter) = (S.face h).circumcenter
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k → E} {A B r : k} (hab : A < B) (h₀ : 0 < r) (h₁ : r < 1) : F (⇑(affine_Map.line_Map A B) r) ≤ ⇑(affine_Map.line_Map (F A) (F B)) r ↔ slope F A (⇑(affine_Map.line_Map A B) r) ≤ slope F (⇑(affine_Map.line_Map A B) r) B
{S : Type u_1} [has_Mul S] {A B : S} (h : Commute A B) : A * B = B * A
(W₁ W₂ z₁ z₂ : Nnreal) (hw' : W₁ + W₂ = 1) {P : ℝ} (hp : 1 ≤ P) : (W₁ * z₁ + W₂ * z₂) ^ P ≤ W₁ * z₁ ^ P + W₂ * z₂ ^ P
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {ι₁ : Type u_3} {S₁ : Finset ι₁} {W₁ : ι₁ → ℝ} (P₁ : ι₁ → P) (h₁ : S₁.Sum (λ (i : ι₁), W₁ i) = 0) {ι₂ : Type u_4} {S₂ : Finset ι₂} {W₂ : ι₂ → ℝ} (P₂ : ι₂ → P) (h₂ : S₂.Sum (λ (i : ι₂), W₂ i) = 0) : HasInner.inner (⇑(S₁.weighted_vsub P₁) W₁) (⇑(S₂.weighted_vsub P₂) W₂) = -S₁.Sum (λ (i₁ : ι₁), S₂.Sum (λ (i₂ : ι₂), W₁ i₁ * W₂ i₂ * (HasDist.dist (P₁ i₁) (P₂ i₂) * HasDist.dist (P₁ i₁) (P₂ i₂)))) / 2
{P : ℕ} [Fact (Nat.Prime P)] (q r : ℚ_[P]) : padic_norm_e (q + r) ≤ LinearOrder.max (padic_norm_e q) (padic_norm_e r)
 : ⇑LinearMap.det ↑(Complex.Conj_lie.to_Linear_Equiv) = -1
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace ℝ P) [Nonempty ↥S] [CompleteSpace ↥(S.direction)] {P₁ : P} (hp₁ : P₁ ∈ S) (P₂ : P) : HasDist.dist P₁ (⇑(EuclideanGeometry.reflection S) P₂) = HasDist.dist P₁ P₂
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {C : ℝ} {F : ℂ → E} {z : ℂ} (hD : Diff_Cont_on_cl ℂ F (set.ioi 0 ×ℂ set.ioi 0)) (hB : ∃ (C : ℝ) (h : C < 2) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal (set.ioi 0 ×ℂ set.ioi 0)] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hre : ∀ (x : ℝ), 0 ≤ x → ∥F ↑x∥ ≤ C) (him : ∀ (x : ℝ), 0 ≤ x → ∥F (↑x * Complex.i)∥ ≤ C) (hz_re : 0 ≤ z.re) (hz_im : 0 ≤ z.im) : ∥F z∥ ≤ C
{m : Type u_1} {N : Type u_2} [has_Add m] [has_Add N] {C : Add_Con m} {F : m → N} (h : ∀ (x y : m), F (x + y) = F x + F y) (h : Add_Con.Add_Ker F h ≤ C) (hF : Function.Surjective F) : C.Map_gen F = C.Map_of_surjective F h h hF
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {F : R →+* S} {P : Polynomial S} (hlifts : P ∈ Polynomial.lifts F) : ∃ (q : Polynomial R), Polynomial.Map F q = P ∧ q.degree = P.degree
 : Function.Injective has_Dvd.Dvd
{α : Type u_1} (S : Multiset α) (P : α → Prop) [Decidable_Pred P] : Multiset.count True (Multiset.Map P S) = ⇑Multiset.Card (Multiset.Filter P S)
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] [TopologicalSpace 𝕜] [OrderTopology 𝕜] {S : set 𝕜} : strict_Convex 𝕜 S → S.Ord_connected
{R : Type u_1} [Rack R] (x y : R) : Rack.act (Shelf.act x y) = Rack.act x * Rack.act y * (Rack.act x)⁻¹
{α : Type u} {β : Type v} [complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [complete_LinearOrder β] [TopologicalSpace β] [OrderTopology β] {ι : sort u_1} [Nonempty ι] {F : α → β} {g : ι → α} (Cf : Continuous_at F (supr g)) (Mf : Monotone F) : F (⨆ (i : ι), g i) = ⨆ (i : ι), F (g i)
{α : Type u_1} {l : List α} : l <:+ List.Nil → l = List.Nil
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (e : m ≃ₗ[R] m) (v : module.Ray R m) : e • v = ⇑(module.Ray.Map e) v
{x : Type u_1} [TopologicalSpace x] (S : set x) : Seq_Closure S ⊆ Closure S
{m : Type u_1} [AddMonoid m] : AddMonoid.fg m ↔ ∃ (S : set m), AddSubmonoid.Closure S = ⊤ ∧ S.Finite
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {D : Type u₁} [CategoryTheory.Category D] (R : C ⥤ D) [CategoryTheory.IsRightAdjoint R] : CategoryTheory.IsFiltered D
{α : Type u} {β : Type v} [Setoid α] [TopologicalSpace α] {F : β → α} (hF : DenseRange F) : DenseRange (Quotient.Mk ∘ F)
{α : Type u} [MetricSpace α] (x : ℕ → α) (h : DenseRange x) : Isometry (Kuratowski_Embedding.Embedding_of_Subset x)
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LT.LT] {A B : α} (ha : 0 ≤ A) (hb : 0 < B) : 0 < A + B
{α : Type u} [OrderedSemiring α] {A B C D : α} [has_exists_Add_of_LE α] (hba : B < A) (hdc : D < C) : A • D + B • C < A • C + B • D
{α : Type u} [SemilatticeInf α] [Nonempty α] {S : set α} (hs : S.Finite) : BddBelow S
{α : Type u_1} {r : α → α → Prop} : IsMax_chain r (MaxChain r)
{P : Polynomial ℤ} (hp : P._primitive) : Irreducible P ↔ Irreducible (Polynomial.Map (Int.cast_Ring_hom ℚ) P)
{α : Type u} {r : α → α → Prop} {A B : α} (P : α → Prop) (l : List α) (h : List.chain r A l) (hb : (A :: l).Last _ = B) (carries : ∀ ⦃x y : α⦄, r x y → P y → P x) (final : P B) : P A
{D : set ℝ} (hD : Convex ℝ D) (hD₂ : IsOpen D) {F : ℝ → ℝ} (hF' : DifferentiableOn ℝ F D) (hF'' : ∀ (x : ℝ), x ∈ D → deriv^[2] F x < 0) : strict_ConcaveOn ℝ D F
{α : Type u} [TopologicalSpace α] {S : set α} {ι : Type v} (hs : IsCompact S) (U : ι → set α) (hUo : ∀ (i : ι), IsOpen (U i)) (hsU : S ⊆ ⋃ (i : ι), U i) : ∃ (t : Finset ι), S ⊆ ⋃ (i : ι) (h : i ∈ t), U i
{α : Type u_1} {r : α → α → Prop} {A B C : α} (h : ∀ (A B C : α), r A B → r A C → (∃ (D : α), Relation.ReflGen r B D ∧ Relation.refl_Trans_gen r C D)) (hab : Relation.refl_Trans_gen r A B) (hac : Relation.refl_Trans_gen r A C) : Relation.Join (Relation.refl_Trans_gen r) B C
{α : Type u} [PseudoMetricSpace α] {S : set α} {x y : α} (h : Metric.Bounded S) (hx : x ∈ S) (hy : y ∈ S) : HasDist.dist x y ≤ Metric.diam S
{R : Type u} {ι : Type u'} {m₁ : ι → Type v₁} {m₂ : Type v₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (m₁ i)] [AddCommMonoid m₂] [Π (i : ι), module R (m₁ i)] [module R m₂] {m₁' : ι → Type u_1} [Π (i : ι), AddCommMonoid (m₁' i)] [Π (i : ι), module R (m₁' i)] (g : MultilinearMap R m₁' m₂) (F : Π (i : ι), m₁ i ≃ₗ[R] m₁' i) : g.Comp_Linear_Map (λ (i : ι), ↑(F i)) = 0 ↔ g = 0
{C : Type u} [CategoryTheory.Category C] {x : top} (F : top.Presheaf C x) : F._sheaf_Opens_LE_cover ↔ F._sheaf_Pairwise_intersections
{ι : Type u} {x : Type v} [TopologicalSpace x] {S : set x} [NormalSpace x] (P : (x → ℝ) → Prop) (h01 : ∀ (S t : set x), IsClosed S → IsClosed t → Disjoint S t → (∃ (F : C(x, ℝ)), P ⇑F ∧ set.Eq_on ⇑F 0 S ∧ set.Eq_on ⇑F 1 t ∧ ∀ (x : x), ⇑F x ∈ set.icc 0 1)) (hs : IsClosed S) (U : ι → set x) (ho : ∀ (i : ι), IsOpen (U i)) (hF : locally_Finite U) (hU : S ⊆ ⋃ (i : ι), U i) : ∃ (F : BumpCovering ι x S), (∀ (i : ι), P ⇑(⇑F i)) ∧ F._subordinate U
{α : Type u} [PseudoMetricSpace α] [CompleteSpace α] {S : ℕ → set α} (hs : ∀ (n : ℕ), IsClosed (S n)) (h'S : ∀ (n : ℕ), Metric.Bounded (S n)) (h : ∀ (N : ℕ), (⋂ (n : ℕ) (h : n ≤ N), S n).Nonempty) (h' : Filter.Tendsto (λ (n : ℕ), Metric.diam (S n)) Filter.at_top (nhds 0)) : (⋂ (n : ℕ), S n).Nonempty
{R : Type x} [has_Mul R] [has_Add R] [Right_Distrib_class R] (A B C : R) : (A + B) * C = A * C + B * C
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ HasInner.inner x y = 0
{α : Type u} {A B : α} [MulOneClass α] [has_Zero α] [Preorder α] [ZeroLt.PosMulMono α] (ha : A < 1) (hb : B ≤ 1) (A0 : 0 < A) : A * B < 1
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {A B : α} (h₁ : A ⊆ B) (h₂ : ¬B ⊆ A) : A ⊂ B
{α : Type u_1} {β : Type u_2} {m : Type u_5} [CommMonoid m] {S : set α} {t : set β} {F : α → m} {g : β → m} (e : α → β) (hE₀ : set.bij_on e S t) (hE₁ : ∀ (x : α), x ∈ S → F x = g (e x)) : finprod (λ (i : α), finprod (λ (h : i ∈ S), F i)) = finprod (λ (j : β), finprod (λ (h : j ∈ t), g j))
(P : ℕ) [hp : Fact (Nat.Prime P)] : WittVector.IsPoly P (λ (R : Type u_1) (_Rcr : CommRing R), ⇑witt_Vector.frobenius)
(P : ℕ) [P_Prime : Fact (Nat.Prime P)] {q r : ℚ} (hqr : q + r ≠ 0) (h : padic_val_rat P q ≤ padic_val_rat P r) : padic_val_rat P q ≤ padic_val_rat P (q + r)
{α : Type u_1} [has_LE α] {A : αᵒᵈ} : _top A → _IsBot (⇑order_dual.of_dual A)
{m : Type u_4} [CommMonoid m] {ι : Type u_1} [Subsingleton ι] {S : Finset ι} {F : ι → m} {B : m} (h : S.Prod (λ (i : ι), F i) = B) (i : ι) (h : i ∈ S) : F i = B
{x : ℝ} (hx : 0 ≤ x) (hx' : x ≤ Real.Pi / 2) : 2 / Real.Pi * x ≤ Real.sin x
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] (v : ↥K) : ⇑(Orthogonal_projection K) ↑v = v
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} {P : ι → P} (ha : AffineIndependent k P) (S : set ι) : AffineIndependent k (λ (i : ↥S), P ↑i)
{δ : ℝ} {x : Type u} [PseudoMetricSpace x] {E : set x} {x : x} : x ∈ Metric.Thickening δ E ↔ ∃ (z : x) (h : z ∈ E), HasDist.dist x z < δ
{R : Type v} [Ring R] {L m N K : module R} {F : L ⟶ m} {g : m ⟶ N} (W : F ≫ g = 0) {h k : homology F g W ⟶ K} (W_1 : ∀ (x : ↥(LinearMap.Ker g)), ⇑h (⇑(CategoryTheory.Limits.Cokernelπ (image_to_Kernel F g W)) (⇑module.to_Kernel_Subobject x)) = ⇑k (⇑(CategoryTheory.Limits.Cokernelπ (image_to_Kernel F g W)) (⇑module.to_Kernel_Subobject x))) : h = k
{P n : ℕ} : padic_val_rat P ↑n = ↑(padic_val_Nat P n)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) : hb.rotation ↑Real.Pi = Linear_Isometry_Equiv.Neg ℝ
{C : Type u₁} [CategoryTheory.Category C] {J : Type u₂} [CategoryTheory.Category J] [CategoryTheory.Limits.HasColimits_of_shape Jᵒᵖ C] : CategoryTheory.Limits.HasLimits_of_shape J Cᵒᵖ
{A : Type u_1} {B : Type u_2} [Field A] [Ring B] [IsDomain B] [Algebra A B] {x : B} (hx : IsIntegral A x) {y : A} (h : (minpoly A x)._root y) : ⇑(Algebra_Map A B) y = x
{h : Type u} {m : Type u_2} [TopologicalSpace h] [TopologicalSpace m] [ChartedSpace h m] {G : StructureGroupoid h} {e e' : LocalHomeomorph m h} (hE : e ∈ StructureGroupoid.MaximalAtlas m G) (hE' : e' ∈ StructureGroupoid.MaximalAtlas m G) : e.Symm.Trans e' ∈ G
{α : Type u_1} [has_LE α] {A : α} : IsMax A → IsMin (⇑order_dual.to_dual A)
{C : Type v} [CategoryTheory.SmallCategory C] {D : Type v} [CategoryTheory.SmallCategory D] (F : C ⥤ D) [F.initial] {E : Type u} [CategoryTheory.Category E] {G : D ⥤ E} [CategoryTheory.Limits.HasLimit (F ⋙ G)] : CategoryTheory.Limits.HasLimit G
{α : Type u_1} [TopologicalSpace α] [TopologicalSpace.SecondCountableTopology α] (m : MeasureTheory.OuterMeasure α) (S : set α) (hs : ∀ (x : α), x ∈ S → (∃ (u : set α) (h : u ∈ nhds_within x S), ⇑m u = 0)) : ⇑m S = 0
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {F : α → E} {g : α → F} {l : Filter α} : (∀ ⦃C : ℝ⦄, 0 < C → Asymptotics._O_with C l F g) → F =o[l] g
{α : Type u_1} {ι : sort u_3} [conditionally_complete_LinearOrder α] {B : α} [Nonempty ι] {F : ι → α} (h : B < supr F) : ∃ (i : ι), B < F i
(𝕜 : Type u_1) {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] (F : E → F) : IsOpen {x : E | AnalyticAt 𝕜 F x}
{α : Type u} [DecidableEq α] [Fintype α] {P : Equiv.perm α → Prop} (F : Equiv.perm α) : P 1 → (∀ (F : Equiv.perm α) (x y : α), x ≠ y → P F → P (Equiv.Swap x y * F)) → P F
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {A B : α} : IsPreconnected (set.icc A B)
(F : ℝ → ℝ) {A B : ℝ} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hfI : F A = F B) : ∃ (C : ℝ) (h : C ∈ set.Ioo A B), IsLocalExtr F C
{G : Type u_1} [Group G] (h : Subgroup G) (hnc : NormalizerCondition G) (hmax : IsCoatom h) : h.Normal
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m →* P} {t : Submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ t) {q : Type u_4} [CommMonoid q] {k : t.Localization_Map q} {A : Type u_5} [CommMonoid A] {U : Submonoid A} {R : Type u_6} [CommMonoid R] (j : U.Localization_Map R) {l : P →* A} (hl : ∀ (W : ↥t), ⇑l ↑W ∈ U) (x : N) : ⇑(k.Map hl j) (⇑(F.Map hy k) x) = ⇑(F.Map _ j) x
{P : Type u_1} [Preorder P] (S t : Order.Pfilter P) (h : ↑S = ↑t) : S = t
{α : Type u_1} [Linear_ordered_Field α] {A B : α} (ha : 0 < A) (hb : 0 < B) : A⁻¹ ≤ B ↔ B⁻¹ ≤ A
{R : Type u} {m : Type v} {ι : Type W} [Semiring R] [AddCommMonoid m] {module_m : module R m} (P : Submodule R m) (x : ι → ↥P) (S : Finset ι) : ↑(S.Sum (λ (i : ι), x i)) = S.Sum (λ (i : ι), ↑(x i))
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] : (reflection K).Symm = reflection K
{m : Type u_1} {R : Type u_4} [non_unital_non_assoc_Semiring R] [set_like m R] [MulMemClass m R] {S : m} {A B : R} (ha : A ∈ S) (hb : B ∈ AddSubmonoid.Closure ↑S) : A * B ∈ AddSubmonoid.Closure ↑S
{α : Type u} {β : Type v} [PartialOrder α] [Preorder β] {l : α → β} {u : β → α} (gc : GaloisConnection l u) (A : α) : (∃ (B : β), A = u B) ↔ A = u (l A)
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] {ι : sort u_2} (P : ι → Submodule R m) {C : Π (x : m), (x ∈ ⨆ (i : ι), P i) → Prop} (hp : ∀ (i : ι) (x : m) (h : x ∈ P i), C x _) (h0 : C 0 _) (HAdd : ∀ (x y : m) (hx : x ∈ ⨆ (i : ι), P i) (hy : y ∈ ⨆ (i : ι), P i), C x hx → C y hy → C (x + y) _) {x : m} (hx : x ∈ ⨆ (i : ι), P i) : C x hx
{α : sort u_1} {β : sort u_2} {γ : sort u_3} (F : α → β → γ) (P : Prop) [Decidable P] (A B : α) (C D : β) : F (Ite P A B) (Ite P C D) = Ite P (F A C) (F B D)
{x : Type u_1} [TopologicalSpace x] {x y : x} (γ : Path x y) : Continuous γ.extend
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [Linear_ordered_AddCommMonoid β] [HasScalar 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F : E → β} (hF : strict_ConcaveOn 𝕜 S F) {x y z : E} (hx : x ∈ S) (hy : y ∈ S) (hxy : x ≠ y) (hz : z ∈ IsOpen_Segment 𝕜 x y) : LinearOrder.min (F x) (F y) < F z
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] (i : D ⥤ C) [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.cartesian_IsClosed C] (h : ∀ (B : D) (A : C), (CategoryTheory.Exp A).obj (i.obj B) ∈ i.EssImage) : CategoryTheory.exponential_Ideal i
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LE.LE] {A B : α} (ha : 0 ≤ A) (hb : 0 ≤ B) : 0 ≤ A + B
{α : Type u} {ι : sort x} {F : ι → α} [h : Unique ι] : set.Range F = {F Inhabited.Default}
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] : 0 < Finite_dimensional.finrank K v ↔ Nontrivial v
{n : ℕ} {x : ℕ × ℕ} : x ∈ Multiset.Nat.antidiagonal n ↔ x.fst + x.Snd = n
{α : Type u_1} {m : Type u_5} {N : Type u_6} [CommMonoid m] [CommMonoid N] {S : set α} (F : α → m) (g : m →* N) (hs : S.Finite) : ⇑g (finprod (λ (j : α), finprod (λ (h : j ∈ S), F j))) = finprod (λ (i : α), finprod (λ (h : i ∈ S), ⇑g (F i)))
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y : v} (h : ∥x∥ = ∥y∥) : x = y ↔ hb.oangle x y = 0
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (θ : Real.Angle) : ⇑Linear_Equiv.det (hb.rotation θ).to_Linear_Equiv = 1
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P1 P2 P3 : P) : P1 -ᵥ P2 + (P2 -ᵥ P3) = P1 -ᵥ P3
{α : Type u_1} {m : Type u_5} {N : Type u_7} [AddZeroClass m] [CommMonoid N] {F g : α →₀ m} {h : α → m → N} (h_Zero : ∀ (A : α), A ∈ F.Support ∪ g.Support → h A 0 = 1) (h_Add : ∀ (A : α), A ∈ F.Support ∪ g.Support → ∀ (B₁ B₂ : m), h A (B₁ + B₂) = h A B₁ * h A B₂) : (F + g).Prod h = F.Prod h * g.Prod h
{ι : Type u} (F : ι → Ordinal) : BddAbove (set.Range F)
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P1 P2 : P) : -(P1 -ᵥ P2) = P2 -ᵥ P1
{α : Type u_1} {m : Type u_4} [has_One m] {S : set α} {F : α → m} {A : α} (h : S.Mul_indicator F A ≠ 1) : A ∈ S
 : Cardinal.Ord ∘ Cardinal.aleph' = Ordinal.enum_Ord {B : Ordinal | B.Card.Ord = B}
{α : Type u} {β : Type v} [Preorder β] {F : α → β} {l : Filter α} {A : α} : _extr_Filter (⇑order_dual.to_dual ∘ F) l A → _extr_Filter F l A
{n D : ℕ} (hnd : D ∣ n) : (n / D).Totient = (Finset.Filter (λ (k : ℕ), n.Gcd k = D) (Finset.Range n)).Card
{α : Type u_1} [cancel_CommMonoid_with_Zero α] {A B C : α} (hc : C ≠ 0) : A * C ∣ B * C ↔ A ∣ B
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} [DecidableEq β'] [DecidableEq γ] [DecidableEq δ] {F : α → β → γ} {S : Finset α} {t : Finset β} {g : γ → δ} {F' : α → β' → δ} {g' : β → β'} (h_Distrib : ∀ (A : α) (B : β), g (F A B) = F' A (g' B)) : Finset.image g (Finset.image₂ F S t) = Finset.image₂ F' S (Finset.image g' t)
{α : Type u} (r : α → α → Prop) [_PartialOrder α r] : ∃ (S : α → α → Prop) (_x : _LinearOrder α S), r ≤ S
{S : Type u_1} [Semigroup S] {A B C : S} (hab : Commute A B) (hac : Commute A C) : Commute A (B * C)
(F : Circle_deg1_Lift) (hF : Continuous ⇑F) : ∃ (x : ℝ), ⇑F x = x + F.TranslationNumber
{α : Type u_1} [conditionally_CompleteLattice α] {S : set α} {A : α} (h : IsGreatest S A) : HasSup.Sup S = A
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) : Collinear k {P}
 : Cardinal.Mk ℂ = Cardinal.Continuum
{K : Type u} [Field K] {S : set K} {P : K → Prop} {x : K} (h : x ∈ Subfield.Closure S) (Hs : ∀ (x : K), x ∈ S → P x) (h1 : P 1) (HAdd : ∀ (x y : K), P x → P y → P (x + y)) (Hneg : ∀ (x : K), P x → P (-x)) (Hinv : ∀ (x : K), P x → P x⁻¹) (HMul : ∀ (x y : K), P x → P y → P (x * y)) : P x
{α : Type u_1} [LinearOrder α] {S : Finset α} {k : ℕ} (h : S.Card = k) {F : Fin k → α} (hfs : ∀ (x : Fin k), F x ∈ S) (hmono : StrictMono F) : F = ⇑(S.order_emb_of_Fin h)
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} : finsum (λ (i : α), finsum (λ (h : i ∈ ∅), F i)) = 0
{v : Type u_1} {α : Type u_2} [MulZeroOneClass α] [Nontrivial α] {A : Matrix v v α} (h : A._Adj_Matrix) [DecidableEq α] : SimpleGraph.Adj_Matrix α h.to_graph = A
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [Finite_dimensional 𝕜 E] {K : Submodule 𝕜 E} {n : ℕ} (h_dim : Finite_dimensional.finrank 𝕜 ↥K + n = Finite_dimensional.finrank 𝕜 E) : Finite_dimensional.finrank 𝕜 ↥Kᗮ = n
 : PythagoreanTriple 0 0 0
{D : set ℝ} (hD : Convex ℝ D) {F : ℝ → ℝ} (hF : Continuous_on F D) (hF' : DifferentiableOn ℝ F (Interior D)) (hF'_Mono : StrictMono_on (deriv F) (Interior D)) : strict_Convex_on ℝ D F
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.SimplicialObject C) {n : ℕ} {i : Fin (n + 2)} {j : Fin (n + 1)} (h : i ≤ ⇑Fin.cast_Succ j) : x.σ j.Succ ≫ x.δ (⇑Fin.cast_Succ i) = x.δ i ≫ x.σ j
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] (A B : α) : Filter.comap Coe (nhds_within B (set.Iio B)) = Filter.at_top
{R : Type u} [CommSemiring R] [Nontrivial R] {P : Fin 2 → R} (h : _IsCoprime (P 0) (P 1)) : P ≠ 0
{A B : ℝ} (m n : ℕ) : ∫ (x : ℝ) in A..B, Real.sin x ^ m * Real.cos x ^ (2 * n + 1) = ∫ (u : ℝ) in Real.sin A..Real.sin B, u ^ m * (1 - u ^ 2) ^ n
{n : Type u} [DecidableEq n] [Fintype n] {α : Type v} [CommRing α] (A : Matrix n n α) (B : n → α) : ⇑(A.cramer) B = A.adjugate.Mul_vec B
(n : ℕ) : (n + 1) * (n + 1).central_binom = 2 * (2 * n + 1) * n.central_binom
{ι : Type u_1} {R : Type u_2} {α : Type u_3} {S : Type u_4} [set_like S R] [Monoid R] [AddMonoid ι] (A : ι → S) [set_like.graded_Monoid A] (Fι : α → ι) (fA : Π (A : α), ↥(A (Fι A))) (l : List α) : ↑(l.dprod Fι fA) = (List.Map (λ (A : α), ↑(fA A)) l).Prod
{C : Type u} [𝒞 : CategoryTheory.Category C] {x Y Z : C} (F : x ⟶ Y) (g : x ⟶ Z) [CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair Y Z)] [CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.ParallelPair (F ≫ CategoryTheory.Limits.Coprod.inl_) (g ≫ CategoryTheory.Limits.Coprod.inr_))] : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.Span F g)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x : v} (hx : x ≠ 0) (θ : Real.Angle) : hb.oangle (⇑(hb.rotation θ) x) x = -θ
{β : Type v} {γ : Type u_1} [TopologicalSpace β] [TopologicalSpace γ] {ι : Type u_2} {κ : Type u_3} {F : ι → β} {g : κ → γ} (hF : DenseRange F) (hg : DenseRange g) : DenseRange (Prod.Map F g)
{γ : Type W} [SemilatticeInf γ] (A : γ) {S : set γ} : BddBelow (HasInsert.Insert A S) ↔ BddBelow S
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ InnerProductGeometry.angle x y = Real.Pi / 2
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {ι : Type u_1} (v : ι → m) (i : LinearIndependent R v) (W : set m) [Fintype ↥W] (S : set.Range v ≤ ↑(Submodule.Span R W)) : Cardinal.Mk ι ≤ ↑(Fintype.Card ↥W)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] : CategoryTheory.Preadditive_yoneda ⋙ (CategoryTheory.whiskering_Right Cᵒᵖ AddCommGroup (Type v)).obj (CategoryTheory.Forget AddCommGroup) = CategoryTheory.yoneda
{α : Type u} [PseudoEmetricSpace α] {δ : ℝ} {S : set α} {x : α} : Emetric.Inf_edist x S ≤ Emetric.Inf_edist x (Metric.Thickening δ S) + Ennreal.of_Real δ
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {ι : Type u_3} {t : Finset ι} {F : ι → L} (h : ∀ (C : ι), C ∈ t → F C ∈ S) : t.Sum (λ (i : ι), F i) ∈ S
{ι : Type u_1} {E : Type u_3} [semi_NormedGroup E] {F : ι → E} (hF : Summable (λ (i : ι), ∥F i∥₊)) : ∥∑' (i : ι), F i∥₊ ≤ ∑' (i : ι), ∥F i∥₊
{A B : Ordinal} (h : B ≠ 0) : {o : Ordinal | A < B * Order.Succ o}.Nonempty
{α : Type u_1} [DecidableEq α] (P : Finset α → Finset α → Prop) (Symm : ∀ {A B : Finset α}, P A B → P B A) (Empty_Right : ∀ {A : Finset α}, P A ∅) (singletons : ∀ {A B : α}, P {A} {B}) (union_of : ∀ {A B C : Finset α}, P A C → P B C → P (A ∪ B) C) (A B : Finset α) : P A B
{α : Type u_1} {β : Type u_2} {F : α ↪ β} {S : Finset α} : S.Nonempty → (Finset.Map F S).Nonempty
{C : Type u} [CategoryTheory.Category C] (Ps : set (Cᵒᵖ ⥤ Type v)) (J : CategoryTheory.GrothendieckTopology C) (hJ : ∀ (P : Cᵒᵖ ⥤ Type v), P ∈ Ps → CategoryTheory.Presieve._sheaf J P) : J ≤ CategoryTheory.sheaf.finest_topology Ps
{R : Type u_3} {A : Type u_5} [CommRing R] [CommRing A] [Algebra R A] {ι : Type u_1} {F : ι → A} (hF : Function.Injective F) : AlgebraicIndependent R Coe → AlgebraicIndependent R F
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (u : E) {v : E} (hv : HasInner.inner u v = 0) : v ∈ (Submodule.Span 𝕜 {u})ᗮ
(n : ℕ) : (Nat.fib n).IsCoprime (Nat.fib (n + 1))
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (S : Finset ι) [CharZero k] (h : S.Nonempty) : S.Sum (λ (i : ι), Finset.centroid_weights k S i) = 1
{m : Type u_3} [Monoid m] [Preorder m] [CovariantClass m m (Function.Swap has_Mul.Mul) has_LE.LE] [CovariantClass m m has_Mul.Mul has_LE.LE] {l₁ l₂ : List m} (h : l₁ <+ l₂) (h₁ : ∀ (A : m), A ∈ l₂ → 1 ≤ A) : l₁.Prod ≤ l₂.Prod
{α : Type u} [Group α] [Fintype α] {P : ℕ} [hp : Fact (Nat.Prime P)] (h : Fintype.Card α = P) : _simple_Group α
(F : Bool → Bool) (x : Bool) : F (F (F x)) = F x
{α : Type u} [PartialOrder α] {A B : α} : A ≤ B → B ≤ A → B = A
{G : Type u_1} [Group G] : NormalizerCondition G ↔ ∀ (h : Subgroup G), h.Normalizer = h → h = ⊤
{C : Type u} [CategoryTheory.Category C] (F : Cᵒᵖ ⥤ Type v) : (CategoryTheory.Category_of_Elements.to_CostructuredArrow F).Right_Op ⋙ CategoryTheory.Category_of_Elements.from_CostructuredArrow F = 𝟭 F.Elements
{α : Type u} [PseudoMetricSpace α] {S : set α} (C : α) : Metric.Bounded S ↔ ∃ (r : ℝ), S ⊆ metric.IsClosed_ball C r
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [normed_CommRing 𝕜] [AddCommMonoid E] [AddCommMonoid F] [module 𝕜 E] [module 𝕜 F] (B : E →ₗ[𝕜] F →ₗ[𝕜] 𝕜) (S : set E) : IsClosed (B.polar S)
{α : Type u} [PseudoEmetricSpace α] {δ : ℝ} (δ_Pos : 0 < δ) (E : set α) : E ⊆ Metric.Thickening δ E
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) {r : ℝ} (hr : 0 < r) : InnerProductGeometry.angle (r • x) y = InnerProductGeometry.angle x y
{x Y : Type u} (F : x ⟶ Y) : CategoryTheory.Mono F ↔ Function.Injective F
{α : Type u_1} {β : Type u_2} [has_Add α] [Preorder α] [Preorder β] {F g : β → α} [CovariantClass α α has_Add.Add has_LT.LT] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] (hF : StrictMono F) (hg : StrictMono g) : StrictMono (λ (x : β), F x + g x)
{G : Type u} {x : G} {n : ℕ} [Fintype G] [Group G] : x ^ n = 1 ↔ x ^ n.Gcd (Fintype.Card G) = 1
{C : Type u₁} [CategoryTheory.Category C] {A : Type u₂} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (P : Cᵒᵖ ⥤ A) : (∀ (E : A), CategoryTheory.Presieve.IsSeparated J (P ⋙ CategoryTheory.coyoneda.obj (Opposite.Op E))) ↔ ∀ ⦃x : C⦄ (S : CategoryTheory.Sieve x), S ∈ ⇑J x → ∀ (C : CategoryTheory.Limits.Cone (S.Arrows.Diagram.Op ⋙ P)), Subsingleton (C ⟶ P.Map_cone S.Arrows.Cocone.Op)
{R : Type u_1} [CommSemiring R] {x : R} : HasStar.Star x = x
{α : Type u_1} [PseudoEmetricSpace α] (C : Ennreal) (hC : C ≠ ⊤) {F : ℕ → α} (hu : ∀ (n : ℕ), HasEdist.edist (F n) (F (n + 1)) ≤ C / 2 ^ n) : Cauchy_Seq F
{R : Type u_1} [Ring R] [TopologicalSpace R] [nonarchimedean_Ring R] (U : IsOpen_Add_Subgroup R) (r : R) : ∃ (v : IsOpen_Add_Subgroup R), r • ↑v ⊆ ↑U
{F : ℝ → ℝ} (hF : Differentiable ℝ F) (hF' : ∀ (x : ℝ), deriv F x ≤ 0) : Antitone F
{G : Type u_1} {h : Type u_2} [AddGroup G] [AddGroup h] [_Add_cyclic h] (F : G →+ h) (hF : F.Ker ≤ Add_Subgroup.Center G) (A B : G) : A + B = B + A
{m : Type u_1} [has_Add m] {r : m → m → Prop} {C : Add_Con m} (h : ∀ (x y : m), r x y → Setoid.r x y) : Add_Con_gen r ≤ C
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (W : ι → k) (P : ι → P) {S₁ S₂ : Finset ι} (h : S₁ ⊆ S₂) : ⇑(S₁.weighted_vsub P) W = ⇑(S₂.weighted_vsub P) (↑S₁.indicator W)
{α : Type u} [PseudoMetricSpace α] {F : α → ℝ} {S : set α} {K : Nnreal} (hF : LipschitzOnWith K F S) : ∃ (g : α → ℝ), LipschitzWith K g ∧ set.Eq_on F g S
{𝕜 : Type u_1} [NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {C : 𝕜} (hc : 1 < ∥C∥) {R : ℝ} (hR : ∥C∥ < R) {F : Subspace 𝕜 E} (hFc : IsClosed ↑F) (hF : ∃ (x : E), x ∉ F) : ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥
{P n : ℕ} (hp : Nat.Prime P) (HDiv : P ∣ n) (R : Type u_1) [CommRing R] : ⇑(Polynomial.expand R P) (Polynomial.cyclotomic n R) = Polynomial.cyclotomic (n * P) R
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y z : m} (hy : SameRay R x y) (hz : SameRay R x z) : SameRay R x (y + z)
{K : Type u_1} {n : ℕ} {g : GeneralizedContinuedFraction K} [DivisionRing K] {m : ℕ} (m_LT_n : m < n) : (g.squash_gcf (n + 1)).S.nth m = g.S.nth m
{P : ℕ} [hp : Fact (Nat.Prime P)] {n : ℕ} (hn : 0 < n) : padic_val_Nat P n = (multiplicity P n).get _
{α : sort u_1} {S₁ : Setoid α} : Function.Surjective Quotient.Mk'
{R : Type u_1} {m : Type u_3} [Monoid_with_Zero R] [has_Zero m] [MulAction_with_Zero R m] (h : IsSmulRegular m 0) : Subsingleton m
{m : Type u_1} [Semigroup m] (A : Stream m) (S : set (set m)) (sfin : S.Finite) (scov : Hindman.FP A ⊆ ⋃₀S) : ∃ (C : set m) (h : C ∈ S) (B : Stream m), Hindman.FP B ⊆ C
(α : Type u_1) [CompleteLattice α] (k : α) : CompleteLattice.IsCompact_element k ↔ ∀ (S : set α), S.Nonempty → Directed_on has_LE.LE S → k ≤ HasSup.Sup S → (∃ (x : α), x ∈ S ∧ k ≤ x)
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_coproducts C] [CategoryTheory.Limits.HasCokernels C] [CategoryTheory.Normal_Epi_Category C] {x Y : C} (F : x ⟶ Y) (Z : C) (l : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι 0 _)) : CategoryTheory.Mono F
{α : Type u_1} [LinearOrder α] [PredOrder α] [_Pred_Archimedean α] (r : α → α → Prop) {n m : α} (h1 : ∀ (i : α), i ∈ set.ioc m n → r i (Order.Pred i)) (h2 : ∀ (i : α), i ∈ set.ioc n m → r (Order.Pred i) i) (hnm : n ≠ m) : Relation.TransGen r n m
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] {g : F → G} {F : E → F} {q : FormalMultilinearSeries 𝕜 F G} {P : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFpowerSeriesAt g q (F x)) (hF : HasFpowerSeriesAt F P x) : HasFpowerSeriesAt (g ∘ F) (q.Comp P) x
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : EuclideanGeometry.angle P1 P2 P3 = EuclideanGeometry.angle P1 P3 P2) (hpi : EuclideanGeometry.angle P2 P1 P3 ≠ Real.Pi) : HasDist.dist P1 P2 = HasDist.dist P1 P3
{P : ℕ} [Fact (Nat.Prime P)] {R : Type u₁} [CommSemiring R] [Char_P R P] {P : Type u₃} [CommSemiring P] [Char_P P P] [perfect_Ring P P] {F : P →+* R} (g : P ≃+* Ring.perfection R P) (hfg : ⇑(Perfection.Lift P P R) F = ↑g) : PerfectionMap P F
{α : Type u_1} {β : Type u_2} [UniformSpace β] {F : α → β} [TopologicalSpace α] (L : ∀ (x : α) (u : set (β × β)), u ∈ Uniformity β → (∃ (t : set α) (h : t ∈ nhds x) (F : α → β), Continuous_at F x ∧ ∀ (y : α), y ∈ t → (F y, F y) ∈ u)) : Continuous F
{q : ℕ+} (i : ℕ) : ↑(LucasLehmer.S i) = LucasLehmer.x.ω ^ 2 ^ i + LucasLehmer.x.ωB ^ 2 ^ i
{α : Type u} [PseudoMetricSpace α] (F : ℕ → α) {m n : ℕ} (h : m ≤ n) : HasDist.dist (F m) (F n) ≤ (Finset.Ico m n).Sum (λ (i : ℕ), HasDist.dist (F i) (F (i + 1)))
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {n : WithTop ℕ} {S : set E} {F g : E → F} (hF : ContDiff_within_at 𝕜 n F S x) (hg : ContDiff_within_at 𝕜 n g S x) : ContDiff_within_at 𝕜 n (λ (x : E), F x + g x) S x
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} [DecidableEq α'] [DecidableEq γ] [DecidableEq δ] {S : Finset α} {t : Finset β} {F : α' → β → γ} {g : α → α'} {F' : α → β → δ} {g' : δ → γ} (h_Left_comm : ∀ (A : α) (B : β), F (g A) B = g' (F' A B)) : Finset.image₂ F (Finset.image g S) t = Finset.image g' (Finset.image₂ F' S t)
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type W} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace 𝕜] [Finite_dimensional 𝕜 E] [Finite_dimensional 𝕜 F] : Nonempty (E ≃L[𝕜] F) ↔ Finite_dimensional.finrank 𝕜 E = Finite_dimensional.finrank 𝕜 F
{𝕜 : Type u_1} {E : Type u} [Linear_ordered_Field 𝕜] [AddCommGroup E] [module 𝕜 E] {S : set E} {x : E} (hx : x ∈ ⇑(Convex_hull 𝕜) S) : ∃ (ι : Type u) (_x : Fintype ι) (z : ι → E) (W : ι → 𝕜) (hss : set.Range z ⊆ S) (hai : AffineIndependent 𝕜 z) (hw : ∀ (i : ι), 0 < W i), Finset.Univ.Sum (λ (i : ι), W i) = 1 ∧ Finset.Univ.Sum (λ (i : ι), W i • z i) = x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {x Y : C} [CategoryTheory.Simple Y] {F : x ⟶ Y} [CategoryTheory.Mono F] (W : F ≠ 0) : CategoryTheory.IsIso F
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (ι : Type u_1) [Unique ι] : Finite_dimensional.finrank K v = 1 ↔ Nonempty (Basis ι K v)
(x : Pgame) : (0 + x).Equiv x
{α : Type u} [PseudoEmetricSpace α] (δ : ℝ) {E₁ E₂ : set α} (h : E₁ ⊆ E₂) : Metric.Cthickening δ E₁ ⊆ Metric.Cthickening δ E₂
{ι : Type u_1} {α : ι → Type u_2} [Fintype ι] [DecidableEq ι] [Π (i : ι), DecidableEq (α i)] [Π (i : ι), LinearOrder (α i)] {P : (Π (i : ι), Finset (α i)) → Prop} (F : Π (i : ι), Finset (α i)) (h0 : P (λ (_x : ι), ∅)) (step : ∀ (g : Π (i : ι), Finset (α i)) (i : ι) (x : α i), (∀ (y : α i), y ∈ g i → y < x) → P g → P (Function.update g i (HasInsert.Insert x (g i)))) : P F
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [nondiscrete_NormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (F : MultilinearMap 𝕜 E G) {C : ℝ} (hC : 0 ≤ C) (h : ∀ (m : Π (i : ι), E i), ∥⇑F m∥ ≤ C * Finset.Univ.Prod (λ (i : ι), ∥m i∥)) (m₁ m₂ : Π (i : ι), E i) : ∥⇑F m₁ - ⇑F m₂∥ ≤ C * ↑(Fintype.Card ι) * LinearOrder.max ∥m₁∥ ∥m₂∥ ^ (Fintype.Card ι - 1) * ∥m₁ - m₂∥
{G : Type u} {x y : G} [CommMonoid G] (hx : _of_Fin_order x) (hy : _of_Fin_order y) : _of_Fin_order (x * y)
{α : Type u_1} [DecidableEq α] {𝒜 : Finset (Finset α)} {S : Finset α} (hs : S ∈ 𝒜.shadow) : ∃ (t : Finset α) (h : t ∈ 𝒜), S ⊆ t
{n : ℕ} {α : Type u_1} {β : Type u_2} (F : β → α → β) (B : β) (v : Vector α n) (x : α) : Vector.scanl F B (x::ᵥv) = B::ᵥVector.scanl F (F B x) v
{𝕜 : Type u_1} [Field 𝕜] {m : Type u_2} [AddCommGroup m] [module 𝕜 m] (C : 𝕜) (F : m →ₗ[𝕜] m) : ⇑LinearMap.det (C • F) = C ^ Finite_dimensional.finrank 𝕜 m * ⇑LinearMap.det F
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} (hx : ∥x∥ = 1) (hy : ∥y∥ = 1) : HasInner.inner x y < 1 ↔ x ≠ y
(P : ℕ) [hp : Fact (Nat.Prime P)] (z : ℤ) : padic_norm P ↑z ≤ 1
{A : Type u_6} [CommRing A] [IsDomain A] {m : Submonoid A} (hM : m ≤ non_Zero_divisors A) : IsDomain (Localization m)
{α : Type u} [non_unital_non_assoc_Ring α] (A B C : α) : (A - B) * C = A * C - B * C
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {F : Filter α} {g : Filter β} {m : α → β' → γ} {n : β → β'} {m' : β → α → δ} {n' : δ → γ} (h_Right_anticomm : ∀ (A : α) (B : β), m A (n B) = n' (m' B A)) : Filter.Map₂ m F (Filter.Map n g) = Filter.Map n' (Filter.Map₂ m' g F)
{α : Type u} {β : Type v} [Ring α] [Ring β] {F : α → β} (h : _Semiring_hom F) : _Ring_hom F
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_4} [DecidableEq ι] [Fintype ι] (e : Basis ι R m) [Nontrivial R] : e.det ≠ 0
{α : Type u_1} [Preorder α] [AddCommMonoid α] [HasSub α] [HasOrderedSub α] {A B : α} : A ≤ B → A - B ≤ 0
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (x Y : C) [CategoryTheory.Limits.HasBinaryProduct x Y] : CategoryTheory.Limits.HasBinaryBiproduct x Y
{ι : Type u_1} {α : Type u_3} [Preorder ι] [Preorder α] {l : Filter ι} {u : ι → α} (h : Monotone u) [l.Ne_IsBot] (hu : Filter.Tendsto u l Filter.at_top) : Filter.Tendsto u Filter.at_top Filter.at_top
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) (x : R) (hx : x ≠ 0) : v.Int_Valuation_def x ≠ 0
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] [h : Nontrivial v] : 0 < Finite_dimensional.finrank K v
{𝕜 : Type u_3} [_R_or_C 𝕜] {n m : ℕ} (A B : Matrix (Fin n) (Fin m) 𝕜) (i j : Fin m) : HasInner.inner (A.transpose i) (B.transpose j) = A.Conj_transpose.Mul B i j
{F : Type u_8} {G : Type u_1} {h : Type u_2} [AddGroup G] [AddZeroClass h] [AddMonoid_hom_class F G h] (F : F) : Function.Injective ⇑F ↔ ∀ (A : G), ⇑F A = 0 → A = 0
{G : Type u_6} {h : Type u_7} {F : Type u_8} [Group G] [division_Monoid h] [Monoid_hom_class F G h] (F : F) (A B : G) : ⇑F (A / B) = ⇑F A / ⇑F B
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m →* P} {t : Submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ t) {q : Type u_4} [CommMonoid q] {k : t.Localization_Map q} {A : Type u_5} [CommMonoid A] {U : Submonoid A} {R : Type u_6} [CommMonoid R] (j : U.Localization_Map R) {l : P →* A} (hl : ∀ (W : ↥t), ⇑l ↑W ∈ U) : (k.Map hl j).Comp (F.Map hy k) = F.Map _ j
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {r : ℝ} (hr : 0 < r) (x : E) : x +ᵥ r • Metric.Ball 0 1 = Metric.Ball x r
{α : Type u_1} {G : Type u_4} {S : set α} [subtraction_CommMonoid G] (F g : α → G) (hs : S.Finite) : finsum (λ (i : α), finsum (λ (h : i ∈ S), F i - g i)) = finsum (λ (i : α), finsum (λ (h : i ∈ S), F i)) - finsum (λ (i : α), finsum (λ (h : i ∈ S), g i))
{δ : Type u_1} {κ : δ → Type u_2} [Π (D : δ), TopologicalSpace (κ D)] : Filter.Coprod (λ (D : δ), Filter.cocompact (κ D)) = Filter.cocompact (Π (D : δ), κ D)
{R : Type u_1} [NormedRing R] [CompleteSpace R] : IsOpen_Embedding Coe
(v : Prime_Multiset) : v.Prod.factor_Multiset = v
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] : IsOpen_Map Prod.Snd
{α : Type u_1} {γ : Type u_3} {ι : Type u_2} {P : ι → Prop} {S : ι → set α} {F : Filter α} (hF : F.has_Basis P S) {β : ι → Type u_4} {pg : Π (i : ι), β i → Prop} {sg : Π (i : ι), β i → set γ} {g : set α → Filter γ} (hg : ∀ (i : ι), (g (S i)).has_Basis (pg i) (sg i)) (gm : Monotone g) : (F.Lift g).has_Basis (λ (i : Σ (i : ι), β i), P i.fst ∧ pg i.fst i.Snd) (λ (i : Σ (i : ι), β i), sg i.fst i.Snd)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x : v) {r : ℝ} (hr : 0 ≤ r) : hb.oangle (r • x) x = 0
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : Collinear k S ↔ ∃ (P₀ : P) (v : v), ∀ (P : P), P ∈ S → (∃ (r : k), P = r • v +ᵥ P₀)
{α : Type u_1} {S : Finset α} {g : α → ℕ} (hS : ∀ (x : α), x ∈ S → g x ≠ 0) : (S.Prod g).factorization = S.Sum (λ (x : α), (g x).factorization)
{m : Type u_1} [has_Add m] (r : m → m → Prop) : Add_Con_gen ⇑(Add_Con_gen r) = Add_Con_gen r
{E : Type u_3} [semi_NormedGroup E] (g h : E) : ∥g + h∥ ≤ ∥g∥ + ∥h∥
{R : Type u1} [CommSemiring R] {m : Type u2} [AddCommMonoid m] [module R m] (m : m) : ⇑(exterior_Algebra.ι R) m * ⇑(exterior_Algebra.ι R) m = 0
{F : Type u_1} [NormedGroup F] [NormedSpace ℝ F] {F : ℝ → F} (K : set F) : {x : ℝ | Differentiable_within_at ℝ F (set.ici x) x ∧ deriv_within F (set.ici x) x ∈ K} ⊆ Right_deriv_Measurable_aux.D F K
(m n k : ℕ) : (m + n).choose k = (Finset.Nat.antidiagonal k).Sum (λ (ij : ℕ × ℕ), m.choose ij.fst * n.choose ij.Snd)
{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), Group (Gs i)] (tfGs : ∀ (i : η), Monoid._torsion_free (Gs i)) : Monoid._torsion_free (Π (i : η), Gs i)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace ↥K] : (reflection K).Trans (reflection K) = Linear_Isometry_Equiv.refl 𝕜 E
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] {n : ℕ} (q : FormalMultilinearSeries 𝕜 F G) (P : FormalMultilinearSeries 𝕜 E F) (C : Composition n) : ∥q.Comp_along_Composition P C∥ ≤ ∥q C.length∥ * Finset.Univ.Prod (λ (i : Fin C.length), ∥P (C.blocks_fun i)∥)
{ι : Type u_1} {R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] (B : Basis ι R m) (F : m → ι → R) (HAdd : ∀ (x y : m), F (x + y) = F x + F y) (hsmul : ∀ (C : R) (x : m), F (C • x) = C • F x) (F_Eq : ∀ (i : ι), F (⇑B i) = ⇑(Finsupp.single i 1)) (x : m) (i : ι) : ⇑(⇑(B.repr) x) i = F x i
{K : Type u_1} [Linear_ordered_Field K] {C : ContinuedFraction K} : ↑C.convergents = ↑C.convergents'
{R : Type u_1} [Semiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {N : Type u_3} [AddCommMonoid N] [module R N] {ι : Type u_6} [DecidableEq ι] {m₂ : Type u_7} [AddCommMonoid m₂] [module R m₂] (F : AlternatingMap R m N ι) (g : m₂ ≃ₗ[R] m) : F.Comp_Linear_Map ↑g = 0 ↔ F = 0
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {v : v} (P₁ P₂ : P) (hv : v ≠ 0) (r : ℝ) : HasDist.dist (r • v +ᵥ P₁) P₂ = HasDist.dist P₁ P₂ ↔ r = 0 ∨ r = (-2) * HasInner.inner v (P₁ -ᵥ P₂) / HasInner.inner v v
{α : Type u} [Group α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A : α} : A < 1 → 1 < A⁻¹
(R : Type u_1) [CommRing R] {n : ℕ} (hn : 2 ≤ n) : (Polynomial.cyclotomic n R).Coeff 0 = 1
{α : Type u} [EmetricSpace α] : uniform_Embedding TopologicalSpace.Nonempty_Compacts.to_Closeds
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] {K : Type u_2} [Field K] [Algebra R K] [_fraction_Ring R K] (v : IsDedekindDomain.height_One_Spectrum R) (r : R) : ⇑(v.Valuation) (⇑(Algebra_Map R K) r) ≤ 1
{x : top} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] (F : top.Presheaf C x) : F._sheaf ↔ F._sheaf_Pairwise_intersections
{α : Type u_1} (m : MeasureTheory.OuterMeasure α) {S : ℕ → set α} (h_Mono : ∀ (n : ℕ), S n ⊆ S (n + 1)) (h0 : ∑' (k : ℕ), ⇑m (S (k + 1)  S k) ≠ ⊤) : ⇑m (⋃ (n : ℕ), S n) = ⨆ (n : ℕ), ⇑m (S n)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {v W : E} (h : HasInner.inner v W = 0) : ∥W - v∥ = ∥W + v∥
{α : Type u_1} [CompleteLattice α] {P q : Prop} {S : P → q → α} : (⨆ (h₁ : P) (h₂ : q), S h₁ h₂) = ⨆ (h : P ∧ q), S _ _
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y z : v} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle y z + hb.oangle x y = hb.oangle x z
{α : Type u_1} {β : Type u_2} [AddGroup α] [subtraction_Monoid β] (F : α →+ β) (g h : α) : ⇑F (g - h) = ⇑F g - ⇑F h
{R : Type u_1} {E : Type u_2} {ι : Type u_4} {ι' : Type u_5} [Linear_ordered_Field R] [AddCommGroup E] [module R E] (S : Finset ι) (t : Finset ι') (ws : ι → R) (zs : ι → E) (wt : ι' → R) (zt : ι' → E) (hws : S.Sum (λ (i : ι), ws i) = 1) (hwt : t.Sum (λ (i : ι'), wt i) = 1) (A B : R) (hab : A + B = 1) : A • S.Center_mass ws zs + B • t.Center_mass wt zt = (Finset.Map Function.Embedding.inl_ S ∪ Finset.Map Function.Embedding.inr_ t).Center_mass (Sum.elim (λ (i : ι), A * ws i) (λ (j : ι'), B * wt j)) (Sum.elim zs zt)
{R : Type u_1} [non_assoc_Semiring R] (F : ℕ →+* R) : F = Nat.cast_Ring_hom R
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) {r : ℝ} (hr : r < 0) : hb.oangle (r • x) y = hb.oangle (-x) y
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} (hderiv : ∀ (x : ℝ), x ∈ set.Interval A B → Differentiable_at ℝ F x) (hint : IntervalIntegrable (deriv F) MeasureTheory.MeasureSpace.Volume A B) : ∫ (y : ℝ) in A..B, deriv F y = F B - F A
{α : Type u_1} {r : α → α → Prop} [Nonempty α] (h : ∀ (C : set α), IsChain r C → C.Nonempty → (∃ (ub : α), ∀ (A : α), A ∈ C → r A ub)) (Trans : ∀ {A B C : α}, r A B → r B C → r A C) : ∃ (m : α), ∀ (A : α), r m A → r A m
{α : Type u_1} (A : α) (S : set α) [MeasurableSpace α] (hs : Measurable_set S) : ⇑((Pmf.pure A).to_measure) S = Ite (A ∈ S) 1 0
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {S₁ S₂ : Submodule K v} [Finite_dimensional K ↥S₂] (hle : S₁ ≤ S₂) (hD : Finite_dimensional.finrank K ↥S₁ = Finite_dimensional.finrank K ↥S₂) : S₁ = S₂
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [Linear_ordered_AddCommMonoid β] [HasScalar 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F : E → β} (hF : ConcaveOn 𝕜 S F) {x y z : E} (hx : x ∈ S) (hy : y ∈ S) (hz : z ∈ Segment 𝕜 x y) : LinearOrder.min (F x) (F y) ≤ F z
{α : Type u} [PseudoMetricSpace α] {S t : set α} (hs : Metric.Bounded S) (ht : Metric.Bounded t) : Metric.Bounded (S ∪ t)
{α : Type u} {β : Type v} {F : Type u_1} [non_assoc_Semiring α] [non_assoc_Semiring β] [Add_hom_class F α β] (F : F) (A : α) : ⇑F (bit0 A) = bit0 (⇑F A)
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {F' : F} {x : 𝕜} {S t u : set 𝕜} (hu : u ∈ nhds x) (h : S ∩ u = t ∩ u) : HasDerivWithinAt F F' S x → HasDerivWithinAt F F' t x
{α : Type u_1} [PseudoMetricSpace α] {F : ℕ → α} (D : ℕ → ℝ) (hF : ∀ (n : ℕ), HasDist.dist (F n) (F n.Succ) ≤ D n) (hD : Summable D) : Cauchy_Seq F
 : ¬BddAbove {P : ℕ | Nat.Prime P}
{C : Type (max v u)} [CategoryTheory.Category C] {J : CategoryTheory.GrothendieckTopology C} {D : Type W} [CategoryTheory.Category D] {K : Type (max v u)} [CategoryTheory.SmallCategory K] [CategoryTheory.Limits.HasLimits_of_shape K D] (F : K ⥤ CategoryTheory.sheaf J D) (E : CategoryTheory.Limits.Cone (F ⋙ CategoryTheory.sheaf_to_presheaf J D)) (hE : CategoryTheory.Limits.IsLimit E) : CategoryTheory.Presheaf.IsSheaf J E.x
{R : Type u_1} {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] (F : ℕ → R) (g : ℕ → m) (n : ℕ) : (Finset.Range n).Sum (λ (i : ℕ), F i • g i) = F (n - 1) • (Finset.Range n).Sum (λ (i : ℕ), g i) - (Finset.Range (n - 1)).Sum (λ (i : ℕ), (F (i + 1) - F i) • (Finset.Range (i + 1)).Sum (λ (i : ℕ), g i))
{B : Type u_3} {S : B} {m : Type u_1} [AddCommMonoid m] [set_like B m] [Add_Submonoid_class B m] (m : Multiset m) (hm : ∀ (A : m), A ∈ m → A ∈ S) : m.Sum ∈ S
{𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] {F : 𝕜 → G} {S : set 𝕜} {x y : 𝕜} {C : ℝ} (hF : DifferentiableOn 𝕜 F S) (bound : ∀ (x : 𝕜), x ∈ S → ∥deriv_within F S x∥ ≤ C) (hs : Convex ℝ S) (xs : x ∈ S) (ys : y ∈ S) : ∥F y - F x∥ ≤ C * ∥y - x∥
{ι : Type u_1} {E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {ca cb : E} {la la' lb lb' : Filter ℝ} {LT : Filter ι} {A B : ℝ} {ua ub va vb : ι → ℝ} [IntervalIntegral.FTC_Filter A la la'] [IntervalIntegral.FTC_Filter B lb lb'] (hab : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F la' MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F lb' MeasureTheory.MeasureSpace.Volume) (ha_lim : Filter.Tendsto F (la' ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds ca)) (hb_lim : Filter.Tendsto F (lb' ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds cb)) (hua : Filter.Tendsto ua LT la) (hva : Filter.Tendsto va LT la) (hub : Filter.Tendsto ub LT lb) (hvb : Filter.Tendsto vb LT lb) : (λ (t : ι), ((∫ (x : ℝ) in va t..vb t, F x) - ∫ (x : ℝ) in ua t..ub t, F x) - ((vb t - ub t) • cb - (va t - ua t) • ca)) =o[LT] λ (t : ι), ∥va t - ua t∥ + ∥vb t - ub t∥
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] (F : C(α, β)) {ι : Type u₃} {P : Filter ι} {F : ι → C(α, β)} : Filter.Tendsto F P (nhds F) ↔ ∀ (K : set α), IsCompact K → TendstoUniformlyOn (λ (i : ι) (A : α), ⇑(F i) A) ⇑F P K
{C : Type u₁} [CategoryTheory.Category C] {x Y : C} (F₁ F₂ : CategoryTheory.Mono_over x ⥤ CategoryTheory.Mono_over Y) (h : F₁ ≅ F₂) : CategoryTheory.Subobject.lower F₁ = CategoryTheory.Subobject.lower F₂
{𝕂 : Type u_1} {𝔸 : Type u_2} [_R_or_C 𝕂] [NormedRing 𝔸] [normed_Algebra 𝕂 𝔸] [CompleteSpace 𝔸] : HasStrictFderivAt (Exp 𝕂) 1 0
{α : Type u_1} [TopologicalSpace α] [t1_Space α] (x : α) [hx : (nhds_within x {x}ᶜ).Ne_IsBot] {S : set α} (hs : S ∈ nhds x) : S.Infinite
{ι : Type u_1} {R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] {B₁ B₂ : Basis ι R m} (h : ∀ (i : ι), ⇑B₁ i = ⇑B₂ i) : B₁ = B₂
{J : Type u₁} [CategoryTheory.Category J] {K : Type u₁} [CategoryTheory.Category K] (e : J ≌ K) [CategoryTheory.IsConnected J] : CategoryTheory.IsConnected K
{E : Type u_2} {𝕜 : Type u_3} [Linear_ordered_Field 𝕜] [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul 𝕜 E] {S : set E} (hs : Convex 𝕜 S) {A B : 𝕜} (ha : 0 ≤ A) (hb : 0 < B) (hab : A + B = 1) : A • S + B • Interior S ⊆ Interior S
{α : Type u} [Group α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A : α} : A⁻¹ < 1 → 1 < A
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] (F : ℂ → E) (z W : ℂ) (S : set ℂ) (hs : S.countable) (Hc : Continuous_on F (set.Interval z.re W.re ×ℂ set.Interval z.im W.im)) (hD : ∀ (x : ℂ), x ∈ set.Ioo (LinearOrder.min z.re W.re) (LinearOrder.max z.re W.re) ×ℂ set.Ioo (LinearOrder.min z.im W.im) (LinearOrder.max z.im W.im)  S → Differentiable_at ℂ F x) : (((∫ (x : ℝ) in z.re..W.re, F (↑x + ↑(z.im) * Complex.i)) - ∫ (x : ℝ) in z.re..W.re, F (↑x + ↑(W.im) * Complex.i)) + Complex.i • ∫ (y : ℝ) in z.im..W.im, F (↑(W.re) + ↑y * Complex.i)) - Complex.i • ∫ (y : ℝ) in z.im..W.im, F (↑(z.re) + ↑y * Complex.i) = 0
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type W} : CategoryTheory.Presieve._sheaf ⊥ P
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {F₁ F₂ : D ⥤ C} [∀ (x Y : C), Subsingleton (x ⟶ Y)] (hC : CategoryTheory.Skeletal C) (hF : F₁ ≅ F₂) : F₁ = F₂
{α : Type u} {β : Type v} [Preorder β] {F : α → β} {S : set α} {A : α} : IsExtrOn (⇑order_dual.to_dual ∘ F) S A → IsExtrOn F S A
{P : ℕ} [Fact (Nat.Prime P)] : padic_norm_e 1 = 1
{ι : Type u} (S : Finset ι) (W z : ι → Nnreal) (hw' : S.Sum (λ (i : ι), W i) = 1) {P : ℝ} (hp : 1 ≤ P) : S.Sum (λ (i : ι), W i * z i) ≤ S.Sum (λ (i : ι), W i * z i ^ P) ^ (1 / P)
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {F : α → β} {S : set α} : StrictMono_on F S → StrictAntiOn (F ∘ ⇑order_dual.of_dual) S
{τ : Type u_1} {α : Type u_2} {β : Type u_3} [TopologicalSpace β] (F : Filter τ) (ϕ : τ → α → β) (S : set α) {C : set β} (hc₁ : IsCompact C) (hc₂ : ∃ (v : set τ) (h : v ∈ F), Closure (set.image2 ϕ v S) ⊆ C) {n : set β} (hn₁ : IsOpen n) (hn₂ : OmegaLimit F ϕ S ⊆ n) : ∃ (u : set τ) (h : u ∈ F), Closure (set.image2 ϕ u S) ⊆ n
{G : Type u_1} [Group G] [hG : Group.IsNilpotent G] : Nat.Find _ = Group.nilpotency_class G
{α : Type u} [PseudoEmetricSpace α] {x : α} {S t : set α} {r : Ennreal} (h : x ∈ S) (h : Emetric.Hausdorff_edist S t < r) : ∃ (y : α) (h : y ∈ t), HasEdist.edist x y < r
{α : Type u} (r : α → α → Prop) [IsSymm α r] {A B : α} : r A B ↔ r B A
{α : Type u} [TopologicalSpace α] [t2_Space α] {ι : Type u_1} [Nonempty ι] {v : ι → set α} (hV : Directed Superset v) (hV_cpct : ∀ (i : ι), IsCompact (v i)) {U : set α} (hU : ∀ (x : α), (x ∈ ⋂ (i : ι), v i) → U ∈ nhds x) : ∃ (i : ι), v i ⊆ U
{α : Type u} [Infinite α] {S : set α} (hF : S.Finite) : Sᶜ ∈ Filter.hyperfilter α
{R : Type u_1} {R₂ : Type u_3} {m : Type u_9} {m₂ : Type u_12} [Semiring R] [Semiring R₂] [AddCommMonoid m] [AddCommMonoid m₂] [module R m] [module R₂ m₂] {τ₁₂ : R →+* R₂} {F : m →ₛₗ[τ₁₂] m₂} (h : ∀ (u v : ↥(F.Ker) →ₗ[R] m), F.Comp u = F.Comp v → u = v) : F.Ker = ⊥
{R : Type u_1} {S : Type u_2} {m : Type u_3} {A : R} {S : S} [Monoid S] [HasScalar R m] [HasScalar R S] [MulAction S m] [IsScalarTower R S m] (h : A • S = 1) : IsSmulRegular m S
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] {S : Finset α} {t : Finset β} {F : α → β} {W : α → m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (hF : ∀ (A : α), A ∈ S → F A ∈ t) (ht : t.Nonempty) (hb : t.Card • B ≤ S.Sum (λ (x : α), W x)) : ∃ (y : β) (h : y ∈ t), B ≤ (Finset.Filter (λ (x : α), F x = y) S).Sum (λ (x : α), W x)
{α : Type u} [PartialOrder α] [OrderBot α] {A : α} : _IsBot A → A = ⊥
 : Filter.cofinite = Filter.at_top
{α : Type u_1} [Linear_ordered_AddCommGroup α] {x dx y dy : α} (h : dy < dx) (hx : 0 < dx) : Nonempty ↥(set.Ico x (x + dx)  set.Ico y (y + dy))
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {A : F} (ha : A ≠ 0) : Char.quadratic_Char F A = -1 ↔ ¬Char.quadratic_Char F A = 1
{α : Type u_1} {β : Type u_2} [DecidableEq α] [Fintype α] [AddCommMonoid β] {δ : α → Type u_3} {t : Π (A : α), Finset (δ A)} (F : (Π (A : α), A ∈ Finset.Univ → δ A) → β) : (Finset.Univ.Pi t).Sum (λ (x : Π (A : α), A ∈ Finset.Univ → δ A), F x) = (Fintype.Pi_Finset t).Sum (λ (x : Π (A : α), δ A), F (λ (A : α) (_x : A ∈ Finset.Univ), x A))
{α : Type u_1} {β : Type u_2} {ι : Type u_3} (A : α) (B : β) (i : ι) : Filter.Map (Prod.Map (λ (_x : α), B) Id) ((Filter.principal {A}).Coprod (Filter.principal {i})) = Filter.principal ({B} ×ˢ set.Univ)
{m : ℝ} (hm : 1 < m) (k : ℕ) : Liouville.Liouville_number m = Liouville.Liouville_number_initial_terms m k + Liouville.Liouville_number_tail m k
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) : ∥S.normed_Mk∥ ≤ 1
{k : Type u_1} {m : Type u_2} [OrderedSemiring k] [ordered_AddCommGroup m] [module k m] [OrderedSmul k m] {A : m} {C : k} (hc : 0 < C) : A < 0 → C • A < 0
{α : Type u_2} [Monoid α] (m : α) : IsSquare m → (∃ (C : α), m = C ^ 2)
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A B : α} (ha : 1 ≤ A) (hb : 1 < B) : 1 < A * B
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) (x : R) : v.Int_Valuation_def x ≤ 1
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] : CategoryTheory.Limits.HasLimits Cᵒᵖ
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} {ι₂ : Type u_5} (S₂ : Finset ι₂) (e : ι₂ ↪ ι) (W : ι → k) (P : ι → P) (B : P) : ⇑((Finset.Map e S₂).weighted_vsub_of_point P B) W = ⇑(S₂.weighted_vsub_of_point (P ∘ ⇑e) B) (W ∘ ⇑e)
{ι : Type u_1} {α : ι → Type u_2} [Fintype ι] [DecidableEq ι] [Π (i : ι), DecidableEq (α i)] [Π (i : ι), LinearOrder (α i)] {P : (Π (i : ι), Finset (α i)) → Prop} (F : Π (i : ι), Finset (α i)) (h0 : P (λ (_x : ι), ∅)) (step : ∀ (g : Π (i : ι), Finset (α i)) (i : ι) (x : α i), (∀ (y : α i), y ∈ g i → x < y) → P g → P (Function.update g i (HasInsert.Insert x (g i)))) : P F
{α : Type u_1} {β : α → Type u_2} {γ : Type u_3} [Π (A : α), CommMonoid (β A)] (S : Finset γ) (g : γ → Π (A : α), β A) : S.Prod (λ (C : γ), g C) = λ (A : α), S.Prod (λ (C : γ), g C A)
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {v₁ v₂ : m} (hv₁ : v₁ ≠ 0) (hv₂ : v₂ ≠ 0) : Ray_of_Ne_Zero R v₁ hv₁ = Ray_of_Ne_Zero R v₂ hv₂ ↔ SameRay R v₁ v₂
{β : Type u} {α : Type v} [AddCommMonoid β] [DecidableEq α] (S : Finset α) (A : α) (B : α → β) : S.Sum (λ (x : α), Ite (x = A) (B x) 0) = Ite (A ∈ S) (B A) 0
{R : Type u_1} {m : Type u_2} {ι : Type u_5} [CommRing R] [AddCommGroup m] [module R m] [Fintype ι] (B : Basis ι R m) (F : ι →₀ R) (i : ι) : ⇑(⇑(Finsupp.Total ι (module.dual R m) R B.coord) F) (⇑B i) = ⇑F i
{R : Type u_1} (C₁ C₂ : R) : Cardinal.Mk (Quaternion_Algebra R C₁ C₂) = Cardinal.Mk R ^ 4
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {S : set E} {F g : E → F} (hF : ContDiff_on 𝕜 n F S) (hg : ContDiff_on 𝕜 n g S) : ContDiff_on 𝕜 n (λ (x : E), F x - g x) S
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] {F : α → β} {S : set α} {A : α} (h_Mono : Monotone_on F S) (hs : S ∈ nhds A) (hfs_l : ∀ (B : β), B < F A → (∃ (C : α) (h : C ∈ S), F C ∈ set.Ioo B (F A))) (hfs_r : ∀ (B : β), B > F A → (∃ (C : α) (h : C ∈ S), F C ∈ set.Ioo (F A) B)) : Continuous_at F A
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_4} [DecidableEq ι] [Fintype ι] (e : Basis ι R m) {v : ι → m} (hli : LinearIndependent R v) (hsp : Submodule.Span R (set.Range v) = ⊤) (i : ι) : ⇑(e.det) v • (Basis.Mk hli hsp).coord i = e.det.to_MultilinearMap.to_Linear_Map v i
{α : Type u_1} [DecidableEq α] [Fintype α] {𝒜 : Finset (Finset α)} {S : Finset α} (hs : S ∈ 𝒜.Up_shadow) : ∃ (t : Finset α) (h : t ∈ 𝒜), t ⊆ S
{β : Type u} {F g : β → Type u} (α : Π (j : β), F j ⟶ g j) (B : β) (x : ∏ λ (j : β), F j) : CategoryTheory.Limits.Pi.π g B (CategoryTheory.Limits.Pi.Map α x) = α B (CategoryTheory.Limits.Pi.π F B x)
{α : Type u_1} {β : Type u_2} {F : α → β} {m : MeasurableSpace α} [TopologicalSpace β] [TopologicalSpace.pseudo_metrizable_Space β] [MeasurableSpace β] [BorelSpace β] (hF : MeasureTheory.strongly_Measurable F) : Measurable F
{α : Type u_1} {S : Multiset α} {x : Multiset α × Multiset α} : x ∈ S.antidiagonal ↔ x.fst + x.Snd = S
{R : Type u} [Semiring R] {m : Polynomial R → Prop} {F : Polynomial R} (F0 : F.Nat_degree ≠ 0) (h_C_Add : ∀ {A : R} {P : Polynomial R}, m P → m (⇑Polynomial.C A + P)) (h_Add : ∀ {P q : Polynomial R}, m P → m q → m (P + q)) (h_monomial : ∀ {n : ℕ} {A : R}, A ≠ 0 → n ≠ 0 → m (⇑(Polynomial.monomial n) A)) : m F
{R : Type u_1} {m : Type u_2} [AddCommMonoid m] [CommRing R] [Nontrivial R] : Algebra.Finite_Type R (AddMonoid_Algebra R m) ↔ AddMonoid.fg m
{α : Type u_1} {β : Type u_2} [SemilatticeSup α] [OrderBot α] {P : α → Prop} {Pbot : P ⊥} {Psup : ∀ ⦃x y : α⦄, P x → P y → P (x ⊔ y)} (t : Finset β) (F : β → {x // P x}) : ↑(t.Sup F) = t.Sup (λ (x : β), ↑(F x))
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {v₂ : Type v'} [AddCommGroup v₂] [module K v₂] [Finite_dimensional K v] [Finite_dimensional K v₂] (Cond : Finite_dimensional.finrank K v = Finite_dimensional.finrank K v₂) : Nonempty (v ≃ₗ[K] v₂)
{F : ℕ → Nnreal} (hF : ∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → F n ≤ F m) : Summable (λ (k : ℕ), 2 ^ k * F (2 ^ k)) ↔ Summable F
{F : Type u} [Field F] {n : ℕ} (A : F) (hn : ↑n ≠ 0) (ha : A ≠ 0) : (Polynomial.x ^ n - ⇑Polynomial.C A).IsSeparable
{α : Type u_1} [Preorder α] {A B : α} (h : A ≤ B) : set.Iio A ⊆ set.Iio B
{P : ℕ} (hp : Nat.Prime P) (n k : ℕ) : multiplicity P n ≤ multiplicity P (n.choose k) + multiplicity P k
{m : Type u_1} [has_Add m] {C : Add_Con m} {C : C.Quotient → Prop} (q : C.Quotient) (h : ∀ (x : m), C ↑x) : C q
{α : Type u} {β : Type v} [TopologicalSpace α] [semi_NormedGroup β] (F : bounded_Continuous_Function α β) (C : Nnreal) : ∥F∥₊ ≤ C ↔ ∀ (x : α), ∥⇑F x∥₊ ≤ C
{α : Type u} [AddGroup α] [Preorder α] [CovariantClass α α has_Add.Add has_LT.LT] {A : α} (h : 0 < A) : -A < A
{m : Type u_1} [MulOneClass m] (S : Submonoid m) {x y : m} : x ∈ S → y ∈ S → x * y ∈ S
{m : Type u_3} [AddCommGroup m] {R₁ : Type u_4} [CommRing R₁] [module R₁ m] {ι : Type u_6} [Fintype ι] [Invertible 2] (q : QuadraticForm R₁ m) (v : Basis ι R₁ m) (hv₂ : (⇑QuadraticForm.Associated q)._Ortho ⇑v) : q.Basis_repr v = QuadraticForm.weighted_Sum_squares R₁ (λ (i : ι), ⇑q (⇑v i))
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {F : α → E} {g : α → F} {l : Filter α} : F =o[l] g → ∀ ⦃C : ℝ⦄, 0 < C → Asymptotics._O_with C l F g
{m : Type u_1} [has_Add m] {S : set m} {P : m → m → Prop} {x y : m} (hx : x ∈ Add_Subsemigroup.Closure S) (hy : y ∈ Add_Subsemigroup.Closure S) (Hs : ∀ (x : m), x ∈ S → ∀ (y : m), y ∈ S → P x y) (HMul_Left : ∀ (x y z : m), P x z → P y z → P (x + y) z) (HMul_Right : ∀ (x y z : m), P z x → P z y → P z (x + y)) : P x y
{x y : Pgame} (ox : x.Numeric) (oy : y.Numeric) : x ≤ y ↔ (∀ (i : x.Left_moves), x.move_Left i < y) ∧ ∀ (j : y.Right_moves), x < y.move_Right j
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P : P) : Function.Injective (HasVsub.vsub P)
{R : Type u_1} {m : Type u_2} {N : Type u_3} [has_Zero R] [has_Zero m] [has_Zero N] [HasScalar R m] [HasScalar R N] [NoZeroSmulDivisors R N] (F : m → N) (hF : Function.Injective F) (h0 : F 0 = 0) (hs : ∀ (C : R) (x : m), F (C • x) = C • F x) : NoZeroSmulDivisors R m
(F F' : ℝ → ℝ) {A B : ℝ} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hff' : ∀ (x : ℝ), x ∈ set.Ioo A B → HasDerivAt F (F' x) x) : ∃ (C : ℝ) (h : C ∈ set.Ioo A B), F' C = (F B - F A) / (B - A)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) (direction : Submodule k v) : ↑(AffineSubspace.Mk' P direction).Nonempty
{α : Type u_1} [PartialOrder α] [PredOrder α] [_Pred_Archimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ set.ioc n m → r (Order.Pred i) i) (hmn : n < m) : Relation.TransGen r n m
(P : ℕ) [hp : Fact (Nat.Prime P)] (n : ℕ) {m : ℕ} (hm : n ≤ m) : (truncated_witt_Vector.Zmod_Equiv_trunc P n).Symm.to_Ring_hom.Comp (truncated_witt_Vector.truncate hm) = (Zmod.cast_hom _ (Zmod (P ^ n))).Comp (truncated_witt_Vector.Zmod_Equiv_trunc P m).Symm.to_Ring_hom
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (e : LocalHomeomorph α β) {F : γ → α} (h : F ⁻¹' e.to_local_Equiv.Source = set.Univ) : Continuous F ↔ Continuous (⇑e ∘ F)
{n : ℕ} : Nat.fib (n + 2) = Nat.fib n + Nat.fib (n + 1)
{α : Type u_1} {E : Type u_3} [TopologicalSpace α] [CompactSpace α] [NormedGroup E] (F : C(α, E)) (x y : α) : HasDist.dist (⇑F x) (⇑F y) ≤ 2 * ∥F∥
{α : Type u} {β : Type v} [Semiring α] [Semiring β] {F : α → β} (hF : _Semiring_hom F) : _Monoid_hom F
{v : Type u_4} [InnerProductSpace ℂ v] (t : v →ₗ[ℂ] v) : InnerProductSpace.IsSelfAdjoint t ↔ ∀ (v : v), ⇑(Star_Ring_end ℂ) (HasInner.inner (⇑t v) v) = HasInner.inner (⇑t v) v
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S₁ S₂ : AffineSubspace k P} {P : P} (h : P ∈ S₁ ⊓ S₂) : (S₁ ⊓ S₂).direction = S₁.direction ⊓ S₂.direction
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} (h : ↑S.Nonempty) : ↑(S.direction) = ↑S -ᵥ ↑S
{α : sort u_1} {P : α → Prop} (hp : ∀ (A : α), ¬P A) : IsEmpty (Subtype P)
{F : Type} [Field F] (q : ℕ) [hF : ExpChar F q] (F : Polynomial F) [irred : Irreducible F] : Polynomial.has_IsSeparable_contraction q F
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {S : set E} {t : set F} {g : F → G} {F : E → F} (x : E) (hg : ContDiff_within_at 𝕜 n g t (F x)) (hF : ContDiff_within_at 𝕜 n F S x) (st : S ⊆ F ⁻¹' t) : ContDiff_within_at 𝕜 n (g ∘ F) S x
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {S : set 𝕜} : Convex 𝕜 S → S.Ord_connected
(R : Type u) (m : Type v) (N : Type W) [Ring R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] [AddCommGroup N] [module R N] [module.free R N] : module.rank R (m × N) = (module.rank R m).Lift + (module.rank R N).Lift
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x : v) (θ : Real.Angle) : ⇑(hb.rotation θ) x = x ↔ x = 0 ∨ θ = 0
{A : Type u_2} [NormedRing A] [normed_Algebra ℂ A] [CompleteSpace A] (A : A) : Filter.at_top.limsup (λ (n : ℕ), ↑∥A ^ n∥₊ ^ (1 / ↑n)) ≤ spectral_radius ℂ A
{R : Type u_1} [CommSemiring R] {A : Type u_2} [Semiring A] (P q : Algebra R A) (W : ∀ (r : R), ⇑(Algebra_Map R A) r = ⇑(Algebra_Map R A) r) : P = q
{G : Type u_1} [Group G] (h : Monoid.exponent_exists G) : Monoid._torsion G
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {C : ℝ} {g : α → F} {F' : α → E'} {l : Filter α} : Asymptotics._O_with C l F' g → Asymptotics._O_with C l (λ (x : α), -F' x) g
{m : Type u_1} [AddZeroClass m] (S : Add_Submonoid m) : 0 ∈ S
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder α] [order_IsClosed_topology α] [Nonempty α] [TopologicalSpace β] [has_Zero α] {F : β → α} (hF : Continuous F) (h : has_IsCompact_Support F) : BddAbove (set.Range F)
{α : Type u_1} {S : set α} : ⊥._clique S → S.Subsingleton
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {F' : E →L[𝕜] F} {x : E} (hF : HasFderivAt F F' x) (v : E) {α : Type u_4} {C : α → 𝕜} {l : Filter α} (hc : Filter.Tendsto (λ (n : α), ∥C n∥) l Filter.at_top) : Filter.Tendsto (λ (n : α), C n • (F (x + (C n)⁻¹ • v) - F x)) l (nhds (⇑F' v))
{α : Type u_1} [MeasurableSpace α] {m₁ m₂ : MeasureTheory.OuterMeasure α} {Op : Ennreal → Ennreal} (h : ∀ (S : set α), ⇑m₁ S = Op (⇑m₂ S)) (S : set α) : ⇑(m₁.trim) S = Op (⇑(m₂.trim) S)
{R : Type u_2} {m : Type u_3} [AddCommGroup m] [Ring R] [module R m] [Invertible 2] (q : QuadraticForm R m) (hB : q.anisotropic) : (⇑QuadraticForm.Associated' q).nondegenerate
{m : Type u_2} [AddCommGroup m] {𝕜 : Type u_1} [Field 𝕜] [module 𝕜 m] (F : m ≃ₗ[𝕜] m) : ⇑LinearMap.det ↑(F.Symm) = (⇑LinearMap.det ↑F)⁻¹
{α : Type u_1} [PseudoEmetricSpace α] {δSeq : ℕ → ℝ} (δSeq_lim : Filter.Tendsto δSeq Filter.at_top (nhds 0)) (E : set α) : Filter.Tendsto (λ (n : ℕ), thickened_indicator_aux (δSeq n) E) Filter.at_top (nhds ((Closure E).indicator (λ (x : α), 1)))
{α : Type u} [TopologicalSpace α] [t2_Space α] {x y : α} (h : x ≠ y) : ∃ (u v : set α), IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ u ∩ v = ∅
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.Finite_Type R A ↔ ∃ (n : ℕ) (F : mv_Polynomial (Fin n) R →ₐ[R] A), Function.Surjective ⇑F
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] {P1 P2 P : P} (h : P -ᵥ P1 = P -ᵥ P2) : P1 = P2
{α : Type u} [CommSemiring α] {P P' ps ps' : α} : P = P' → ps = ps' → P + ps = P' + ps'
{α : Type u_1} {β : Type u_2} {m : Type u_5} {N : Type u_7} [AddCommMonoid m] [AddCommMonoid N] {F : α → β} {S : α →₀ m} (h : β → m →+ N) : (Finsupp.Map_IsDomain F S).Sum (λ (B : β) (m : m), ⇑(h B) m) = S.Sum (λ (A : α) (m : m), ⇑(h (F A)) m)
{A B k : ℕ} (h_Ab_IsCoprime : A.IsCoprime B) (hka : k ∣ A) (hkb : k ∣ B) : k = 1
{α : Type u_1} [PseudoMetricSpace α] {δ : ℝ} {E : set α} (hE : IsCompact E) (hδ : 0 ≤ δ) : Metric.Cthickening δ E = ⋃ (x : α) (h : x ∈ E), metric.IsClosed_ball x δ
{α : Type u_1} {𝒜 : Finset (Finset α)} {A : Finset α} {r : ℕ} : A ∈ 𝒜.Slice r ↔ A ∈ 𝒜 ∧ A.Card = r
{k : Type u_1} {v : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Fintype ι] {P : ι → P} (hi : AffineIndependent k P) {sm : Submodule k v} [Finite_dimensional k ↥sm] (hle : Vector_Span k (set.Range P) ≤ sm) (hc : Fintype.Card ι = Finite_dimensional.finrank k ↥sm + 1) : Vector_Span k (set.Range P) = sm
{K : Type u_1} [Linear_ordered_Field K] {v : K} {n : ℕ} [FloorRing K] {ifp_n : GeneralizedContinuedFraction.Int_fract_pair K} : GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.Some ifp_n → v = GeneralizedContinuedFraction.Comp_exact_value ((GeneralizedContinuedFraction.of v).continuants_aux n) ((GeneralizedContinuedFraction.of v).continuants_aux (n + 1)) ifp_n.fr
{C : Type u} [CategoryTheory.Category C] {x Y : C} [CategoryTheory.Limits.HasZeroMorphisms C] (F : x ⟶ Y) [CategoryTheory.Limits.HasKernel F] {Z : C} (h : Y ⟶ Z) [CategoryTheory.Mono h] : CategoryTheory.Limits.Kernel_Subobject (F ≫ h) = CategoryTheory.Limits.Kernel_Subobject F
{m : Type u_1} [AddZeroClass m] {C D : Add_Con m} (h : C ≤ D) (x : C.Quotient) : ⇑(C.Map D h) x = ⇑(C.Lift D.Mk' _) x
{G : Type u_3} [Group G] (P : Subgroup G) : P.fg ↔ ∃ (S : set G), Subgroup.Closure S = P ∧ S.Finite
{α : Type u_1} {β : Type u_3} {γ : Type u_5} [DecidableEq γ] {F F' : α → β → γ} {S : Finset α} {t : Finset β} (h : ∀ (A : α) (B : β), F A B = F' A B) : Finset.image₂ F S t = Finset.image₂ F' S t
{α : Type u_1} {β : Type u_2} {e : local_Equiv α β} {S : set α} {t : set β} : e._image S t → e.Source ∩ ⇑e ⁻¹' t = e.Source ∩ S
{𝕜 : Type u_1} {E : Type u_4} {Fₗ : Type u_7} [NormedGroup E] [NormedGroup Fₗ] [nondiscrete_NormedField 𝕜] [NormedSpace 𝕜 E] [NormedSpace 𝕜 Fₗ] {r : ℝ} (r_Pos : 0 < r) (C : ℝ) (F : E →ₗ[𝕜] Fₗ) (h : ∀ (z : E), z ∈ Metric.Ball 0 r → ∥⇑F z∥ ≤ C) : ∃ (C : ℝ), ∀ (z : E), ∥⇑F z∥ ≤ C * ∥z∥
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [LinearOrder α] [TopologicalSpace γ] {A B : α} {h : A ≤ B} [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] {F : γ → ↥(set.icc A B) → β} {g : γ → α} (hF : Continuous ↿F) (hg : Continuous g) : Continuous (λ (A_1 : γ), set.icc_extend h (F A_1) (g A_1))
{G : Type u_1} [Group G] (h : Subgroup G) : h = ⊥ ∨ Nontrivial ↥h
{R : Type u_1} {G : Type u_4} [Group G] [MulAction G R] (g : G) : IsSmulRegular R g
{α : Type u} {β : Type v} [has_Add α] [has_Add β] {γ : Type u_1} [has_Add γ] {F : α → β} {g : β → γ} (hF : _Add_hom F) (hg : _Add_hom g) : _Add_hom (g ∘ F)
{x : Type u_1} {Y : Type u_2} [PseudoEmetricSpace x] [PseudoEmetricSpace Y] {C : Nnreal} {F : x → Y} : LipschitzWith C F → HolderWith C 1 F
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (m : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (hM : m (Sum.inr_ ()) (Sum.inr_ ()) ≠ 0) (i : Fin r) : ((Matrix.Pivot.List_transvec_col m).Prod.Mul m).Mul (Matrix.Pivot.List_transvec_row m).Prod (Sum.inl_ i) (Sum.inr_ ()) = 0
{α : Type u_1} [PartialOrder α] [PredOrder α] [_Pred_Archimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ set.ioc n m → r (Order.Pred i) i) (hmn : n ≤ m) : Relation.refl_Trans_gen r n m
{β : Type u} {α : Type v} {γ : Type W} [AddCommMonoid β] {S : Finset γ} {t : γ → Finset α} {t' : Finset α} {S' : α → Finset γ} (h : ∀ (x : γ) (y : α), x ∈ S ∧ y ∈ t x ↔ x ∈ S' y ∧ y ∈ t') {F : γ → α → β} : S.Sum (λ (x : γ), (t x).Sum (λ (y : α), F x y)) = t'.Sum (λ (y : α), (S' y).Sum (λ (x : γ), F x y))
(C : Type u) [CategoryTheory.Category C] [∀ {J : Type v} {x Y : C} {F : J → (x ⟶ Y)}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallel_family F)] : CategoryTheory.Limits.HasWideCoequalizers C
{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {F : Filter β} {u : β → α} : (∃ (B : α), ∀ (x : β), r (u x) B) → Filter._bounded_under r F u
{α : Type u_1} [Field α] (E : LinearRecurrence α) : module.rank α ↥(E.sol_Space) = ↑(E.order)
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A B : α} (ha : A ≤ 1) (hb : B ≤ 1) : A * B ≤ 1
{R : Type u} {ι : Type u'} {m₁ : ι → Type v₁} {m₂ : Type v₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (m₁ i)] [AddCommMonoid m₂] [Π (i : ι), module R (m₁ i)] [module R m₂] {m₁' : ι → Type u_1} [Π (i : ι), AddCommMonoid (m₁' i)] [Π (i : ι), module R (m₁' i)] {m₁'' : ι → Type u_2} [Π (i : ι), AddCommMonoid (m₁'' i)] [Π (i : ι), module R (m₁'' i)] (g : MultilinearMap R m₁'' m₂) (F₁ : Π (i : ι), m₁' i →ₗ[R] m₁'' i) (F₂ : Π (i : ι), m₁ i →ₗ[R] m₁' i) : (g.Comp_Linear_Map F₁).Comp_Linear_Map F₂ = g.Comp_Linear_Map (λ (i : ι), (F₁ i).Comp (F₂ i))
(R : Type u_1) {K : Type u_2} [CommRing R] [Field K] [Algebra R K] [_fraction_Ring R K] (P : ℕ) [Char_P R P] : Char_P K P
(n : ℕ) : iterated_deriv n (Exp_Neg_Inv_glue.F_aux 0) = Exp_Neg_Inv_glue.F_aux n
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (ha : Continuous_at F A) : HasStrictDerivAt (λ (u : ℝ), ∫ (x : ℝ) in u..B, F x) (-F A) A
{α : Type u} (P : α → Prop) [Decidable_Pred P] (xs : List α) (h : ∀ (x : α), x ∈ xs → ¬P x) : List.split_on_P P xs = [xs]
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace E] [CompleteSpace ↥K] (u v : E) : HasInner.inner ↑(⇑(Orthogonal_projection K) u) v = HasInner.inner u ↑(⇑(Orthogonal_projection K) v)
{x : Type v} [TopologicalSpace x] [LocallyCompactSpace x] [SigmaCompactSpace x] [t2_Space x] {ι : x → Type u} {P : Π (x : x), ι x → Prop} {B : Π (x : x), ι x → set x} (hB : ∀ (x : x), (nhds x).has_Basis (P x) (B x)) : ∃ (α : Type v) (C : α → x) (r : Π (A : α), ι (C A)), (∀ (A : α), P (C A) (r A)) ∧ (⋃ (A : α), B (C A) (r A)) = set.Univ ∧ locally_Finite (λ (A : α), B (C A) (r A))
{G : Type u_1} [Group G] {ι : sort u_2} (S : ι → Subgroup G) {C : G → Prop} {x : G} (hx : x ∈ ⨆ (i : ι), S i) (hp : ∀ (i : ι) (x : G), x ∈ S i → C x) (h1 : C 1) (HMul : ∀ (x y : G), C x → C y → C (x * y)) : C x
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : HasInner.inner x y * HasInner.inner x y ≤ HasInner.inner x x * HasInner.inner y y
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} {S t : set α} (hs : (S ∩ Function.Support F).Finite) (ht : (t ∩ Function.Support F).Finite) : finsum (λ (i : α), finsum (λ (h : i ∈ S ∪ t), F i)) + finsum (λ (i : α), finsum (λ (h : i ∈ S ∩ t), F i)) = finsum (λ (i : α), finsum (λ (h : i ∈ S), F i)) + finsum (λ (i : α), finsum (λ (h : i ∈ t), F i))
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] (F : ℂ → E) (F' : ℂ → (ℂ →L[ℝ] E)) (z W : ℂ) (S : set ℂ) (hs : S.countable) (Hc : Continuous_on F (set.Interval z.re W.re ×ℂ set.Interval z.im W.im)) (hD : ∀ (x : ℂ), x ∈ set.Ioo (LinearOrder.min z.re W.re) (LinearOrder.max z.re W.re) ×ℂ set.Ioo (LinearOrder.min z.im W.im) (LinearOrder.max z.im W.im)  S → HasFderivAt F (F' x) x) (Hi : MeasureTheory.IntegrableOn (λ (z : ℂ), Complex.i • ⇑(F' z) 1 - ⇑(F' z) Complex.i) (set.Interval z.re W.re ×ℂ set.Interval z.im W.im) MeasureTheory.MeasureSpace.Volume) : (((∫ (x : ℝ) in z.re..W.re, F (↑x + ↑(z.im) * Complex.i)) - ∫ (x : ℝ) in z.re..W.re, F (↑x + ↑(W.im) * Complex.i)) + Complex.i • ∫ (y : ℝ) in z.im..W.im, F (↑(W.re) + ↑y * Complex.i)) - Complex.i • ∫ (y : ℝ) in z.im..W.im, F (↑(z.re) + ↑y * Complex.i) = ∫ (x : ℝ) in z.re..W.re, ∫ (y : ℝ) in z.im..W.im, Complex.i • ⇑(F' (↑x + ↑y * Complex.i)) 1 - ⇑(F' (↑x + ↑y * Complex.i)) Complex.i
{α : Type u} [Group α] [has_LE α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A : α} : A⁻¹ ≤ 1 ↔ 1 ≤ A
{R : Type u_2} {m : Type u_3} [AddCommGroup m] [Ring R] [module R m] [Invertible 2] {q : QuadraticForm R m} (hB₁ : ⇑QuadraticForm.Associated' q ≠ 0) : ∃ (x : m), ⇑q x ≠ 0
{α : Type u} [PseudoEmetricSpace α] {x y : α} {S t : set α} (xs : x ∈ S) (yt : y ∈ t) : Emetric.diam (S ∪ t) ≤ Emetric.diam S + HasEdist.edist x y + Emetric.diam t
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [Ring_hom_isometric σ₁₂] (F : E →sl[σ₁₂] F) (m : Nnreal) (hM : ∀ (x : E), ∥⇑F x∥₊ ≤ m * ∥x∥₊) : ∥F∥₊ ≤ m
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {F g : ℂ → E} (hdf : Diff_Cont_on_cl ℂ F (set.ioi 0 ×ℂ set.Iio 0)) (hBf : ∃ (C : ℝ) (h : C < 2) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal (set.ioi 0 ×ℂ set.Iio 0)] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hdg : Diff_Cont_on_cl ℂ g (set.ioi 0 ×ℂ set.Iio 0)) (hBg : ∃ (C : ℝ) (h : C < 2) (B : ℝ), g =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal (set.ioi 0 ×ℂ set.Iio 0)] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hre : ∀ (x : ℝ), 0 ≤ x → F ↑x = g ↑x) (him : ∀ (x : ℝ), x ≤ 0 → F (↑x * Complex.i) = g (↑x * Complex.i)) : set.Eq_on F g {z : ℂ | 0 ≤ z.re ∧ z.im ≤ 0}
{m : Type u_4} [Group_with_Zero m] {F g : ℚ →*₀ m} (same_on_Neg_One : ⇑F (-1) = ⇑g (-1)) (same_on_pnat : ∀ (n : ℕ), 0 < n → ⇑F ↑n = ⇑g ↑n) : F = g
{α : Type u_1} {β : Type u_2} (e : local_Equiv α β) : e.Trans e.Symm ≈ local_Equiv.of_set e.Source
(A : Type u_4) [CommRing A] [IsDomain A] {K : Type u_5} [CommRing K] [Algebra A K] [_fraction_Ring A K] : IsDomain K
{R : Type u_1} [CommRing R] (u v W x : Fin 3 → R) : Matrix.dot_Product (⇑(⇑CrossProduct u) v) (⇑(⇑CrossProduct W) x) = Matrix.dot_Product u W * Matrix.dot_Product v x - Matrix.dot_Product u x * Matrix.dot_Product v W
{ι : Type u} (S : Finset ι) (F : ι → Ennreal) {P : ℝ} (hp : 1 ≤ P) : S.Sum (λ (i : ι), F i) ^ P ≤ ↑(S.Card) ^ (P - 1) * S.Sum (λ (i : ι), F i ^ P)
{R : Type u} {m : Type v} [Group R] [MulAction R m] {P : sub_MulAction R m} (m : ↥P) : MulAction.Stabilizer R m = MulAction.Stabilizer R ↑m
{R : Type u_1} {m : Type u_2} {ι : Type u_3} [CommRing R] [AddCommGroup m] [module R m] [Fintype ι] (B : Basis ι R m) : module.Finite R m
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P ⟶ q) : (∀ (A : ↥P), ⇑F A = 0) → F = 0
{v : Type u} [CategoryTheory.Category v] [CategoryTheory.Abelian v] {A B C D A' B' C' D' : v} {F : A ⟶ B} {g : B ⟶ C} {h : C ⟶ D} {F' : A' ⟶ B'} {g' : B' ⟶ C'} {h' : C' ⟶ D'} {α : A ⟶ A'} {β : B ⟶ B'} {γ : C ⟶ C'} {δ : D ⟶ D'} (comm₁ : α ≫ F' = F ≫ β) (comm₂ : β ≫ g' = g ≫ γ) (comm₃ : γ ≫ h' = h ≫ δ) (hgh : CategoryTheory.Exact g h) (hF'g' : CategoryTheory.Exact F' g') (hg'h' : CategoryTheory.Exact g' h') (hα : CategoryTheory.Epi α) (hγ : CategoryTheory.Epi γ) (hδ : CategoryTheory.Mono δ) : CategoryTheory.Epi β
{R : Type u_1} {A B : R} [Semigroup R] (Ab : IsRightRegular (B * A)) : IsRightRegular B
{m : Type u_6} {N : Type u_7} [has_Add m] [has_Add N] {F g : m ≃+ N} (h : ∀ (x : m), ⇑F x = ⇑g x) : F = g
{B : ℕ} (hb : 1 < B) {x y : ℕ} (hy : 0 < y) : B ^ x ≤ y ↔ x ≤ Nat.log B y
{α : Type u_1} [UniformSpace α] [CompactSpace α] [SeparatedSpace α] : Uniformity α = ⨆ (x : α), nhds (x, x)
{G : Type u_1} [Group G] (P₁ P₂ : ℕ) [hp₁ : Fact (Nat.Prime P₁)] [hp₂ : Fact (Nat.Prime P₂)] (hne : P₁ ≠ P₂) (h₁ h₂ : Subgroup G) (hH₁ : _P_Group P₁ ↥h₁) (hH₂ : _P_Group P₂ ↥h₂) : Disjoint h₁ h₂
{α : Type u_2} [DecidableEq α] [HasSub α] {u : Finset α} {S t : set α} : ↑u ⊆ S - t → (∃ (S' t' : Finset α), ↑S' ⊆ S ∧ ↑t' ⊆ t ∧ u ⊆ S' - t')
{R : Type u_1} {K : Type u_2} [Semiring R] [CommSemiring K] {B : R} {bi : K} (i : R →+* K) (F : Polynomial R) (A : R) (bu : bi * ⇑i B = 1) : DenomsClearable A B F.Nat_degree F i
(h : Add_Subgroup ℤ) : ∃ (A : ℤ), h = Add_Subgroup.Closure {A}
{R : Type u} [Semiring R] {P : Polynomial R} : Polynomial.x * P = P * Polynomial.x
{α : Type u_1} {n : Type u_4} {m : Type u_5} [has_Zero α] {A : Matrix m m α} {C : Matrix n m α} {D : Matrix n n α} (h : (Matrix.from_blocks A 0 C D).IsSymm) (ha : A.IsDiag) (hD : D.IsDiag) : (Matrix.from_blocks A 0 C D).IsDiag
{R : Type u_1} [CommRing R] (u v W : Fin 3 → R) : ⇑(⇑CrossProduct u) (⇑(⇑CrossProduct v) W) + ⇑(⇑CrossProduct v) (⇑(⇑CrossProduct W) u) + ⇑(⇑CrossProduct W) (⇑(⇑CrossProduct u) v) = 0
{ι : Type u_1} {x : Type u_2} [TopologicalSpace x] [NormalSpace x] {u : ι → set x} {S : set x} {C : set (ShrinkingLemma.PartialRefinement u S)} (hc : IsChain has_LE.LE C) {v₁ v₂ : ShrinkingLemma.PartialRefinement u S} (h₁ : v₁ ∈ C) (h₂ : v₂ ∈ C) {i : ι} (hi₁ : i ∈ v₁.carrier) (hi₂ : i ∈ v₂.carrier) : ⇑v₁ i = ⇑v₂ i
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} {ps : set P} (h : ps ⊆ ↑S) [Nonempty ↥S] {n : ℕ} [Finite_dimensional ℝ ↥(S.direction)] (hD : Finite_dimensional.finrank ℝ ↥(S.direction) = n) (hc : EuclideanGeometry.Cospherical ps) : ∃ (C : P), ∀ (sx : Affine.Simplex ℝ P n), set.Range sx.points ⊆ ps → sx.circumcenter = C
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {F : 𝕜 → F} : iterated_fderiv 𝕜 n F = ⇑(Continuous_MultilinearMap.Pi_Field_Equiv 𝕜 (Fin n) F) ∘ iterated_deriv n F
{𝕂 : Type u_6} [_R_or_C 𝕂] {E' : Type u_7} [NormedGroup E'] [NormedSpace 𝕂 E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {F : E' → F'} {x : E'} (hF : ContDiff_at 𝕂 1 F x) (K : Nnreal) (hK : ∥fderiv 𝕂 F x∥₊ < K) : ∃ (t : set E') (h : t ∈ nhds x), LipschitzOnWith K F t
{α : Type u} {A B C D : α} [Preorder α] (hca : C ≤ A) (hbd : B ≤ D) : A ≤ B → C ≤ D
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} [DecidableEq ι] {v : ι → Submodule 𝕜 E} (hV : OrthogonalFamily 𝕜 (λ (i : ι), (v i).Subtypeₗᵢ)) (hc : IsComplete ↑(supr v)) : direct_Sum._internal v ↔ (supr v)ᗮ = ⊥
{α : Type u_1} {l : List α} {x : α} : List.Duplicate x l ↔ [x, x] <+ l
{β : Type u} {α : Type v} [CommMonoid β] {S : Finset α} (hc : S.Card ≤ 1) {F : α → β} {B : β} (h : S.Prod (λ (x : α), F x) = B) (x : α) (h : x ∈ S) : F x = B
{α : Type u_1} {m : MeasurableSpace α} (ν : MeasureTheory.Measure α) [MeasureTheory.sigma_Finite ν] {F : α → Ennreal} (hF : Measurable F) : (ν.with_density F).rn_deriv ν =ᵐ[ν] F
{t : ↥Unit_Interval} : 0 ≤ t
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {v : v} (hv : v ∈ S.direction) {P : P} (hp : P ∈ S) : v +ᵥ P ∈ S
(A : ↥Circle) : ⇑LinearMap.det ↑((⇑rotation A).to_Linear_Equiv) = 1
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {F : α → β} (hF : Continuous F) : Filter.comap F (Filter.cocompact β) ≤ Filter.cocompact α
(Fq F : Type) [Field Fq] [Field F] (Fqt : Type u_1) [Field Fqt] [Algebra (Polynomial Fq) Fqt] [_fraction_Ring (Polynomial Fq) Fqt] [Algebra (Ratfunc Fq) F] [Algebra Fqt F] [Algebra (Polynomial Fq) F] [IsScalarTower (Polynomial Fq) Fqt F] [IsScalarTower (Polynomial Fq) (Ratfunc Fq) F] : Function_Field Fq F ↔ Finite_dimensional Fqt F
{α : Type u} {β : Type v} [Preorder β] {F : α → β} {S : set α} {A : α} : IsMaxOn (⇑order_dual.to_dual ∘ F) S A → IsMinOn F S A
{α : Type u} {r : α → α → Prop} {A B : α} (l : List α) (hl₁ : List.chain r A l) (hl₂ : (A :: l).Last _ = B) : Relation.refl_Trans_gen r A B
{α : Type u_1} [circular_Preorder α] {A B C : α} (habc : HasBtw.Btw A B C) (hcba : ¬HasBtw.Btw C B A) : HasSbtw.Sbtw A B C
{n : WithTop ℕ} {𝕂 : Type u_6} [_R_or_C 𝕂] {E' : Type u_7} [NormedGroup E'] [NormedSpace 𝕂 E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {S : set E'} {F : E' → F'} {x : E'} {P : E' → FormalMultilinearSeries 𝕂 E' F'} (hF : HasFtaylorSeriesUpToOn n F P S) (hn : 1 ≤ n) (hs : S ∈ nhds x) : HasStrictFderivAt F (⇑(Continuous_multilinear_Curry_Fin1 𝕂 E' F') (P x 1)) x
{α : Type u_1} [DecidableEq α] (S : set α) [Fintype ↥S] {A : α} (h : A ∈ S) : A ∈ tactic_.Interval_cases.set_elems S
{α : Type u_1} {β : Type u_2} [DecidableEq α] [Fintype α] [CommSemiring β] {δ : α → Type u_1} [Π (A : α), DecidableEq (δ A)] {t : Π (A : α), Finset (δ A)} {F : Π (A : α), δ A → β} : Finset.Univ.Prod (λ (A : α), (t A).Sum (λ (B : δ A), F A B)) = (Fintype.Pi_Finset t).Sum (λ (P : Π (A : α), δ A), Finset.Univ.Prod (λ (x : α), F x (P x)))
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} : ContDiff 𝕜 n Prod.fst
(R : Type u_1) {P m : ℕ} [Fact (Nat.Prime P)] [Ring R] [Char_P R P] (hm : ¬P ∣ m) {k : ℕ} : 0 < k → Polynomial.cyclotomic (P ^ k * m) R = Polynomial.cyclotomic m R ^ (P ^ k - P ^ (k - 1))
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {F G : C ⥤ D} (α : F ⟶ G) [∀ (x : C), CategoryTheory.Epi (α.App x)] : CategoryTheory.Epi α
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {F : v →ₗ[K] v} (hinj : Function.Injective ⇑F) : Function.Surjective ⇑F
{α : Type u} {A B : α} [MulOneClass α] [has_Zero α] [Preorder α] [Zero_LT.Mul_Pos_Mono α] (ha : 1 ≤ A) (hb : 1 ≤ B) (B0 : 0 < B) : 1 ≤ A * B
{α : Type v} [LinearOrder α] [TopologicalSpace α] [order_IsClosed_topology α] {S : set α} (hs : IsPreconnected S) {A B : α} (ha : A ∈ S) (hb : B ∈ S) : set.icc A B ⊆ S
{R : Type u_1} [CommRing R] (S : Type u_2) [CommRing S] [Algebra R S] (t : Type u_4) [CommRing t] [Algebra R t] (m N : Submonoid R) (h : m ≤ N) [IsLocalization m S] [IsLocalization N t] : IsScalarTower R S t
{α : Type u_1} {S : Finset α} {P : α → Prop} [Decidable_Pred P] (h : ∀ (x : α), x ∈ S → P x) : Finset.Map (Function.Embedding.Subtype P) (Finset.Subtype P S) = S
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) : hb.oangle (-x) (-y) = hb.oangle x y
{ι : Type u_1} {R : Type u_2} {α : Type u_3} {S : Type u_4} [set_like S R] [Monoid R] [AddMonoid ι] (A : ι → S) [set_like.graded_Monoid A] (Fι : α → ι) (fA : Π (A : α), ↥(A (Fι A))) (l : List α) : l.dprod Fι fA = ⟨(List.Map (λ (A : α), ↑(fA A)) l).Prod, _⟩
{α : Type u_1} [AddCommMonoid α] [TopologicalSpace α] {A : α} {F : ℕ → α} (h : has_Sum F A) : Filter.Tendsto (λ (n : ℕ), (Finset.Range n).Sum (λ (i : ℕ), F i)) Filter.at_top (nhds A)
{α : Type u_1} [MeasurableSpace α] {S : set α} : Measurable_set S → (Filter.principal S)._measurably_generated
(P : ℕ) [Fact (Nat.Prime P)] (A : ℤ) (ha : ↑A ≠ 0) : Zmod.legendre_Sym P A = 1 ∨ Zmod.legendre_Sym P A = -1
{β : Type u_2} {γ : Type u_3} [TopologicalSpace β] [TopologicalSpace γ] {κ : Type u_5} {g : β → γ} {F : κ → β} (hg : DenseRange g) (hF : DenseRange F) (cg : Continuous g) : DenseRange (g ∘ F)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x Y : C} (F g : x ⟶ Y) [CategoryTheory.Limits.HasEqualizer F g] : CategoryTheory.Limits.HasKernel (F - g)
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {x y : 𝕜} (h : x < y) {z : 𝕜} : z ∈ set.ioc x y ↔ ∃ (A B : 𝕜), 0 ≤ A ∧ 0 < B ∧ A + B = 1 ∧ A * x + B * y = z
{m : Type u_3} {N : Type u_4} {F : Type u_8} {mM : AddZeroClass m} {mN : AddZeroClass N} [AddMonoid_hom_class F m N] (F : F) {x : m} (hx : ∃ (y : m), x + y = 0) : ∃ (y : N), ⇑F x + y = 0
{R : Type u1} [CommSemiring R] {m : Type u2} [AddCommMonoid m] [module R m] : Disjoint (exterior_Algebra.ι R).Range 1
{F : Type u_3} [InnerProductSpace ℝ F] {K : set F} (h : Convex ℝ K) {u v : F} (hv : v ∈ K) : (∥u - v∥ = ⨅ (W : ↥K), ∥u - ↑W∥) ↔ ∀ (W : F), W ∈ K → HasInner.inner (u - v) (W - v) ≤ 0
{R : Type u_1} [cancel_CommMonoid_with_Zero R] {x y A P : R} {n : ℕ} (hp : Prime P) (hx : x * y = A * P ^ n) : ∃ (i j : ℕ) (B C : R), i + j = n ∧ A = B * C ∧ x = B * P ^ i ∧ y = C * P ^ j
(A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension ∅ A B] : ⊥ = ⊤
{α : Type u_1} [has_LE α] {A : α} : _top A → _IsBot (⇑order_dual.to_dual A)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [Finite_dimensional ℝ E] {x : E} {S : set E} (hx : x ∈ S) (hs : S ≠ set.Univ) : ∃ (y : E) (h : y ∈ Frontier S), metric.Inf_dist x Sᶜ = HasDist.dist x y
{α : Type u_1} [PseudoEmetricSpace α] (C : Ennreal) {F : ℕ → α} (hu : ∀ (n : ℕ), HasEdist.edist (F n) (F (n + 1)) ≤ C / 2 ^ n) {A : α} (ha : Filter.Tendsto F Filter.at_top (nhds A)) : HasEdist.edist (F 0) A ≤ 2 * C
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {x : top} (F : top.Presheaf C x) (U : TopologicalSpace.Opens ↥x) (R : CategoryTheory.Presieve U) (hR : CategoryTheory.Sieve.generate R ∈ ⇑(Opens.GrothendieckTopology ↥x) U) : CategoryTheory.presheaf.fork_Map R F ≫ (top.Presheaf.covering_of_Presieve.FirstObj_iso_Pi_Opens F U R).hom = F.Map (CategoryTheory.Eq_to_hom _).Op ≫ top.Presheaf.sheaf_condition_Equalizer_products.res F (top.Presheaf.covering_of_Presieve U R)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] (P : P) : EuclideanGeometry.Orthogonal_projection_fn S P ∈ AffineSubspace.Mk' P (S.direction)ᗮ
{α : Type u_1} {G : Type u_4} [subtraction_CommMonoid G] {F g : α → G} (hF : (Function.Support F).Finite) (hg : (Function.Support g).Finite) : finsum (λ (i : α), F i - g i) = finsum (λ (i : α), F i) - finsum (λ (i : α), g i)
{α : Type u_2} [Semiring α] {A : α} : Odd A → (∃ (B : α), A = bit1 B)
(P : ℕ) [P_Prime : Fact (Nat.Prime P)] {q r : ℕ} (hq : q ≠ 0) (hr : r ≠ 0) : padic_val_Nat P (q * r) = padic_val_Nat P q + padic_val_Nat P r
(F : Circle_deg1_Lift) {x : ℝ} {n : ℕ} {m : ℤ} (h : ⇑(F ^ n) x = x + ↑m) (hn : 0 < n) : F.TranslationNumber = ↑m / ↑n
{G : Type u_1} [AddGroup G] {ι : Type u_2} (S : Finset ι) (F : ι → G) (comm : ∀ (x : ι), x ∈ S → ∀ (y : ι), y ∈ S → Add_Commute (F x) (F y)) (K : ι → Add_Subgroup G) (hind : CompleteLattice.Independent K) (hmem : ∀ (x : ι), x ∈ S → F x ∈ K x) (HEq1 : S.noncomm_Sum F comm = 0) (i : ι) (h : i ∈ S) : F i = 0
{α : Type u_1} {m : Type u_5} [CommMonoid m] {A : α} {S : set α} (F : α → m) (h : A ∉ S) (hs : S.Finite) : finprod (λ (i : α), finprod (λ (h : i ∈ HasInsert.Insert A S), F i)) = F A * finprod (λ (i : α), finprod (λ (h : i ∈ S), F i))
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - 2 * ∥x∥ * ∥y∥ * Real.cos (InnerProductGeometry.angle x y)
{G₀ : Type u_2} [Group_with_Zero G₀] (A : G₀) : A / A * A = A
{m : Type u_3} {N : Type u_4} [has_Add m] [has_Add N] {F g : Add_hom m N} (h : F = g) (x : m) : ⇑F x = ⇑g x
{α : Type u_1} {β : Type u_2} {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃) {S : set α} {F : α → β} (h₂ : Continuous_on F S) : Continuous_on F S
(A : ℝ) : Cardinal.Mk ↥(set.ioi A) = Cardinal.Continuum
{G : Type u_1} [AddGroup G] (h : Add_Subgroup G) {x : G} : x ∈ h → -x ∈ h
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasInitial C] (h : ∀ (x : C), CategoryTheory.Mono (CategoryTheory.Limits.initial.to x)) : CategoryTheory.Limits.InitialMonoClass C
{α : Type u_2} {ι : Type u_5} [CommMonoid α] (t : Finset ι) (F₁ F₂ : ι → set α) (hF : ∀ {i : ι}, i ∈ t → F₁ i ⊆ F₂ i) : t.Prod (λ (i : ι), F₁ i) ⊆ t.Prod (λ (i : ι), F₂ i)
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (K : Type u_2) [Field K] [Algebra R K] [_fraction_Ring R K] (v : IsDedekindDomain.height_One_Spectrum R) : Classical.Some _ ≠ 0
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] {m₁ m₂ : Ennreal → Ennreal} {C : Ennreal} (hc : C ≠ ⊤) (h0 : C ≠ 0) (hle : m₁ ≤ᶠ[nhds_within 0 (set.ici 0)] C • m₂) : MeasureTheory.Measure.Mk_metric m₁ ≤ C • MeasureTheory.Measure.Mk_metric m₂
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace E] {v : E} (hv : v ∈ K) : ⇑(Orthogonal_projection Kᗮ) v = 0
{h : Type u} [TopologicalSpace h] (G : StructureGroupoid h) : LocalHomeomorph.refl h ∈ StructureGroupoid.MaximalAtlas h G
{m : Type u_1} {N : Type u_2} [MulOneClass m] [MulOneClass N] (h : m ≃* N) : _Mul_hom ⇑h
(W₁ W₂ z₁ z₂ : Ennreal) (hw' : W₁ + W₂ = 1) {P : ℝ} (hp : 1 ≤ P) : (W₁ * z₁ + W₂ * z₂) ^ P ≤ W₁ * z₁ ^ P + W₂ * z₂ ^ P
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {F : m →* P} : (Con.Ker_Lift F).mrange = F.mrange
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] (i : D ⥤ C) [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Reflective i] [CategoryTheory.cartesian_IsClosed C] [CategoryTheory.exponential_Ideal i] (A B : C) : CategoryTheory.IsIso (CategoryTheory.Limits.Prod_comparison (CategoryTheory.IsLeftAdjoint i) A B)
{C : Type u₁} [CategoryTheory.Category C] {x : C} (P : Cᵒᵖ ⥤ Type W) {S : CategoryTheory.Sieve x} {R : CategoryTheory.Presieve x} (h : ⇑S ≤ R) (Trans : ∀ ⦃Y : C⦄ (F : Y ⟶ x), CategoryTheory.Presieve.IsSheafFor P ⇑(CategoryTheory.Sieve.pullback F S)) : CategoryTheory.Presieve.IsSheafFor P R
{m : Type u_1} [has_Mul m] (C : Con m) {A B : m} : ↑A = ↑B ↔ ⇑C A B
{R : Type u} [non_assoc_Semiring R] (S : Subsemiring R) {l : List R} : (∀ (x : R), x ∈ l → x ∈ S) → l.Sum ∈ S
(C : Type u) [CategoryTheory.Category C] [∀ {x Y Z : C} {F : x ⟶ Y} {g : x ⟶ Z}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.Span F g)] : CategoryTheory.Limits.HasPushouts C
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [BaireSpace α] [Nonempty α] [Encodable β] {F : β → set α} (hc : ∀ (S : β), IsClosed (F S)) (hU : (⋃ (S : β), F S) = set.Univ) : ∃ (S : β), (Interior (F S)).Nonempty
{ι : Type u_1} {𝕜 : Type u_2} [_R_or_C 𝕜] {E : Type u_3} [InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {G : ι → Type u_4} [Π (i : ι), InnerProductSpace 𝕜 (G i)] {v : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 v) [∀ (i : ι), CompleteSpace (G i)] (hV' : (⨆ (i : ι), (v i).to_LinearMap.Range).topological_Closure = ⊤) (W : ↥(Lp G 2)) : ⇑((hV.Linear_Isometry_Equiv hV').Symm) W = ∑' (i : ι), ⇑(v i) (⇑W i)
{α : Type u_1} {F : α → α} {x : α} (hF : Function.IsFixedPt F x) (n : ℕ) : Function.IsPeriodicPt F n x
(n : ℕ) : (Finset.Range (n + 1)).Sum (λ (m : ℕ), n.choose m) = 2 ^ n
{α : Type u_1} {β : Type u_3} [MeasurableSpace α] [MeasurableSpace β] {ν : MeasureTheory.Measure β} [MeasureTheory._Finite_measure ν] {S : set (α × β)} (hs : Measurable_set S) : Measurable (λ (x : α), ⇑ν (Prod.Mk x ⁻¹' S))
{G : Type u} [Group G] [Fintype G] {P n : ℕ} [hp : Fact (Nat.Prime P)] {h : Subgroup G} (hH : Fintype.Card ↥h = P ^ n) : Fintype.Card ↥(h.Normalizer) ≡ Fintype.Card G [Mod P ^ (n + 1)]
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] {A B : α} {S : set α} (hs : IsClosed (S ∩ set.icc A B)) (ha : A ∈ S) (hgt : ∀ (x : α), x ∈ S ∩ set.Ico A B → ∀ (y : α), y ∈ set.ioi x → (S ∩ set.ioc x y).Nonempty) : set.icc A B ⊆ S
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace 𝕜] {C : 𝕜} (hc : 1 < ∥C∥) {R : ℝ} (hR : ∥C∥ < R) (h : ¬Finite_dimensional 𝕜 E) : ∃ (F : ℕ → E), (∀ (n : ℕ), ∥F n∥ ≤ R) ∧ ∀ (m n : ℕ), m ≠ n → 1 ≤ ∥F m - F n∥
{α : Type u_1} [conditionally_CompleteLattice α] {S t : set α} : BddBelow S → BddBelow t → (S ∩ t).Nonempty → HasInf.Inf S ⊔ HasInf.Inf t ≤ HasInf.Inf (S ∩ t)
{α : Type u} [Group α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A : α} : A⁻¹ < 1 ↔ 1 < A
{n : ℕ} (R : Type u_1) [Ring R] : Coe ∘ Coe = Coe
(r n : ℕ) : (2 * n).choose r ≤ n.central_binom
{α : Type u_1} {β : Type u_2} {P : Pmf α} (F : Π (A : α), A ∈ P.Support → Pmf β) (S : set β) [MeasurableSpace β] (hs : Measurable_set S) : ⇑((P.Bind_on_Support F).to_measure) S = ∑' (A : α), ↑(⇑P A) * dite (⇑P A = 0) (λ (h : ⇑P A = 0), 0) (λ (h : ¬⇑P A = 0), ⇑((F A h).to_measure) S)
{α : Type u_1} [TopologicalSpace α] [BaireSpace α] {S : set (set α)} (ho : ∀ (S : set α), S ∈ S → IsOpen S) (hS : S.countable) (hD : ∀ (S : set α), S ∈ S → Dense S) : Dense (⋂₀ S)
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] {F : E → F} {z : E} {r : ℝ} (hD : Diff_Cont_on_cl ℂ F (Metric.Ball z r)) (hz : IsMaxOn (HasNorm.norm ∘ F) (Metric.Ball z r) z) : set.Eq_on (HasNorm.norm ∘ F) (Function.Const E ∥F z∥) (metric.IsClosed_ball z r)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {F' F₁' : E →L[𝕜] F} {x : E} {S : set E} (hF : HasFderivWithinAt F F' S x) (hg : HasFderivWithinAt F F₁' S x) : set.Eq_on ⇑F' ⇑F₁' (TangentConeAt 𝕜 S x)
{α : Type u_1} {P : α → Prop} : set.Range Coe = {x : α | P x}
{R : Type u_1} {A B : R} [Add_Semigroup R] : IsAddRegular (A + B) ∧ IsAddRegular (B + A) ↔ IsAddRegular A ∧ IsAddRegular B
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] {A B C : α} : -B + A < C → A < B + C
{R : Type u₁} [CommRing R] (A B : R) : A ^ 2 - B ^ 2 = (A + B) * (A - B)
{α : Type u_1} [DecidableEq α] (S : Finset α) : S.Sym2.Card = S.Card * (S.Card + 1) / 2
{α : Type u_3} {β : Type u_4} {γ : Type u_5} [CommMonoid α] {g : γ → β} (hg : Function.Injective g) {F : β → α} (hF : ∀ (x : β), x ∉ set.Range g → F x = 1) : Filter.Map (λ (S : Finset γ), S.Prod (λ (i : γ), F (g i))) Filter.at_top = Filter.Map (λ (S : Finset β), S.Prod (λ (i : β), F i)) Filter.at_top
{α : Type u} [t : TopologicalSpace α] {B : set (set α)} (hb : TopologicalSpace._topological_Basis B) {S : set α} {A : α} : A ∈ Closure S ↔ ∀ (o : set α), o ∈ B → A ∈ o → (o ∩ S).Nonempty
(n : ℕ) : (Multiset.Nat.antidiagonal n).Nodup
(α : Type u) {β : Type v} [AddGroup α] [AddAction α β] (B : β) [Fintype α] [Fintype ↥(AddAction.Orbit α B)] [Fintype ↥(AddAction.Stabilizer α B)] : Fintype.Card ↥(AddAction.Orbit α B) * Fintype.Card ↥(AddAction.Stabilizer α B) = Fintype.Card α
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {v₁ v₂ : Ray_Vector R m} : -v₁ ≈ -v₂ ↔ v₁ ≈ v₂
{α : Type u} [TopologicalSpace α] [LinearOrder α] [order_IsClosed_topology α] [Nonempty α] {S : set α} (hs : IsCompact S) : BddAbove S
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {F : α → E} {g : α → F} {l : Filter α} : F =O[l] g ↔ ∃ (C : ℝ), Asymptotics._O_with C l F g
{F : Type u → Type u} [Functor F] [q : Qpf F] {α : Type u} (u : F α → α) (x y : (Qpf.P F).W) : Qpf.Wequiv x y → Qpf.recF u x = Qpf.recF u y
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) (i : Fin (n + 1)) : HasDist.dist (S.points i) S.circumcenter = S.circumradius
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) : S.circumcenter ∈ affine_Span ℝ (set.Range S.points)
{α : Type u_1} {β : Type u_2} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] [Nonempty β] {F : β → α} (hF : Continuous F) (hlim : Filter.Tendsto F (Filter.cocompact β) Filter.at_top) : ∃ (x : β), ∀ (y : β), F x ≤ F y
{S : Type u_2} [CommRing S] {K : Type u_6} [Field K] [Algebra K S] {x : S} (hx : IsIntegral K x) : LinearIndependent K (λ (i : Fin (minpoly K x).Nat_degree), x ^ ↑i)
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} {S t : set α} (hst : Disjoint S t) (hs : S.Finite) (ht : t.Finite) : finprod (λ (i : α), finprod (λ (h : i ∈ S ∪ t), F i)) = finprod (λ (i : α), finprod (λ (h : i ∈ S), F i)) * finprod (λ (i : α), finprod (λ (h : i ∈ t), F i))
{A B : ℕ} (hab : A.IsCoprime B) : Disjoint A.factorization.Support B.factorization.Support
{K : Type u} [Field K] (S : Subfield K) : Subfield.Closure ↑S = S
{α : Type u} {β : Type v} [Preorder β] {F : α → β} {l : Filter α} {A : α} : IsMin_Filter (⇑order_dual.to_dual ∘ F) l A → IsMax_Filter F l A
{R : Type u} [CommRing R] [IsDomain R] [discrete_Valuation_Ring R] (ϖ : R) : Irreducible ϖ ↔ local_Ring.Maximal_Ideal R = Ideal.Span {ϖ}
{α : Type u} [PartialOrder α] {A B : α} (hab : A ≤ B) (hba : ¬A < B) : B = A
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [NormalSpace Y] (F : bounded_Continuous_Function x ℝ) {e : x → Y} (hE : IsClosed_Embedding e) : ∃ (g : bounded_Continuous_Function Y ℝ), ∥g∥ = ∥F∥ ∧ ⇑g ∘ e = ⇑F
{G : Type u_1} [AddCommGroup G] (K : Add_Subgroup G) (g : Multiset G) : (∀ (A : G), A ∈ g → A ∈ K) → g.Sum ∈ K
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} (S : Finset ι) [Fintype ι] (P : ι → P) : Finset.centroid k S P = ⇑(Finset.Univ.affine_combination P) (Finset.centroid_weights_indicator k S)
(n : ℕ) : Filter.Tendsto (λ (x : ℝ), Real.Exp x / x ^ n) Filter.at_top Filter.at_top
(m n : ℕ) : Nat.fib (m + n + 1) = Nat.fib m * Nat.fib n + Nat.fib (m + 1) * Nat.fib (n + 1)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {P1 : P} (hp1 : P1 ∈ S) (P2 P : P) : P ∈ affine_Span k (HasInsert.Insert P2 ↑S) ↔ ∃ (r : k) (P0 : P) (hp0 : P0 ∈ S), P = r • (P2 -ᵥ P1) +ᵥ P0
{α : Type u_1} {P : Π (S : Finset α), S.Nonempty → Prop} (h₀ : ∀ (A : α), P {A} _) (h₁ : ∀ ⦃A : α⦄ (S : Finset α) (h : A ∉ S) (hs : S.Nonempty), P S hs → P (Finset.Cons A S h) _) {S : Finset α} (hs : S.Nonempty) : P S hs
{G : Type u_1} [sub_Neg_Monoid G] [MeasurableSpace G] [has_Measurable_Add G] (g : G) : Measurable (λ (h : G), h - g)
{m : Type u_1} [has_Mul m] {C D : Con m} (h : Setoid.r = Setoid.r) : C = D
{R : Type u_1} {A : Type u_2} [CommSemiring R] [CommRing A] [Algebra R A] (𝒜 : ℕ → Submodule R A) [graded_Algebra 𝒜] : GaloisConnection (λ (S : set A), projective_Spectrum.Zero_locus 𝒜 S) (λ (t : (set (projective_Spectrum 𝒜))ᵒᵈ), ↑(projective_Spectrum.vanishing_Ideal t))
{α : Type u_3} {β : Type u_4} [Nonempty α] [SemilatticeInf α] [Preorder β] {F : α → β} (hF : Monotone F) : Filter.Tendsto F Filter.at_IsBot Filter.at_IsBot ↔ ∀ (B : β), ∃ (A : α), F A ≤ B
{R : Type v} [CommRing R] {n : ℕ} (A : Matrix (Fin n.Succ) (Fin n.Succ) R) : A.det = Finset.Univ.Sum (λ (i : Fin n.Succ), (-1) ^ ↑i * A i 0 * (A.minor ⇑(i.Succ_above) Fin.Succ).det)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {J : Type W} [CategoryTheory.Category J] (F : C ⥤ D) [CategoryTheory.Limits.HasColimits_of_shape J D] [CategoryTheory.CreatesColimitsOfShape J F] : CategoryTheory.Limits.HasColimits_of_shape J C
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : ℝ} {C W : ℂ} {F : ℂ → E} {S : set ℂ} (hs : S.countable) (hw : W ∈ Metric.Ball C R) (hc : Continuous_on F (metric.IsClosed_ball C R)) (hD : ∀ (x : ℂ), x ∈ Metric.Ball C R  S → Differentiable_at ℂ F x) : ∮ (z : ℂ) in C(C, R), (z - W)⁻¹ • F z = (2 * ↑Real.Pi * Complex.i) • F W
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] {A B : α} {S : set α} (hs : IsClosed (S ∩ set.icc A B)) (ha : A ∈ S) (hab : A ≤ B) (hgt : ∀ (x : α), x ∈ S ∩ set.Ico A B → (S ∩ set.ioc x B).Nonempty) : B ∈ S
{R : Type u_4} [Linear_ordered_Ring R] (A : R) : 0 ≤ A ^ 2
{K : Type u_1} {v : K} {n : ℕ} [Linear_ordered_Field K] [FloorRing K] {ifp_Succ_n : GeneralizedContinuedFraction.Int_fract_pair K} (Succ_nth_Stream_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream v (n + 1) = Option.Some ifp_Succ_n) : 1 ≤ ifp_Succ_n.B
(R : Type u) [CommSemiring R] {m : Type v} [AddCommMonoid m] [module R m] {S : Finset m} (B : Basis ↥S R m) (F : m →ₗ[R] m) : ⇑(LinearMap.trace R m) F = (⇑(Linear_Map.to_Matrix B B) F).trace
{R : Type u_1} [CommRing R] {S : Type u_2} [CommRing S] [Algebra R S] [IsDomain S] (h : Algebra.IsIntegral R S) (P : Ideal R) [P_max : P.IsMaximal] (hP : (Algebra_Map R S).Ker ≤ P) : ∃ (q : Ideal S), q.IsMaximal ∧ Ideal.comap (Algebra_Map R S) q = P
(m : Type u_1) (α : Type u_2) [Monoid m] [MulAction m α] : GaloisConnection (⇑order_dual.to_dual ∘ fixing_Submonoid m) ((λ (P : Submonoid m), MulAction.FixedPoints ↥P α) ∘ ⇑order_dual.of_dual)
{α : Type u_1} {β : Type u_3} {γ : Type u_5} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ] {δ : Type u_7} [MeasurableSpace δ] {μA : MeasureTheory.Measure α} {μB : MeasureTheory.Measure β} {μC : MeasureTheory.Measure γ} {μD : MeasureTheory.Measure δ} [MeasureTheory.sigma_Finite μB] [MeasureTheory.sigma_Finite μD] {F : α → β} {g : γ → δ} (hF : MeasureTheory.MeasurePreserving F μA μB) (hg : MeasureTheory.MeasurePreserving g μC μD) : MeasureTheory.MeasurePreserving (Prod.Map F g) (μA.Prod μC) (μB.Prod μD)
 : Filter.Tendsto Complex.Abs (Filter.cocompact ℂ) Filter.at_top
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {C : Add_Con m} {F : m →+ P} (h : C ≤ Add_Con.Ker F) (x : m) : ⇑(C.Lift F h) ↑x = ⇑F x
{n : ℕ} (i j : Σ (A : Composition n), Composition A.length) : i = j ↔ i.fst.blocks = j.fst.blocks ∧ i.Snd.blocks = j.Snd.blocks
{K : Type u_1} [Linear_ordered_Field K] {A B C : K} (h : ∀ (x : K), 0 ≤ A * x * x + B * x + C) : discrim A B C ≤ 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) (direction : Submodule k v) : P ∈ AffineSubspace.Mk' P direction
{m : Type u_1} [has_Mul m] {C : Con m} {C : C.Quotient → Prop} (q : C.Quotient) (h : ∀ (x : m), C ↑x) : C q
{ι : Type u} {γ : Type W} [dec : DecidableEq ι] [AddCommMonoid γ] (S : ι → Add_Submonoid γ) : supr S = (Dfinsupp.Sum_Add_hom (λ (i : ι), (S i).Subtype)).mrange
(P : ℕ) [hp : Fact (Nat.Prime P)] {q : ℚ} (hq : q ≠ 0) : padic_norm P q ≠ 0
{R : Type u} [Ring R] {P : Type (max u v)} [AddCommGroup P] [module R P] : module.projective R P ↔ CategoryTheory.Projective (module.of R P)
{R : Type u} [Ring R] : CategoryTheory.Limits.HasKernels (module R)
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : Rˣ) : Continuous_at Ring.Inverse ↑x
{R : Type u} [non_assoc_Semiring R] (S : Subsemiring R) {x y : R} : x ∈ S → y ∈ S → x + y ∈ S
{x : Type u_2} {Y : Type u_3} [EmetricSpace x] [EmetricSpace Y] {C r : Nnreal} {F : x → Y} (h : HolderWith C r F) (hr : 0 < r) : dimH (set.Range F) ≤ dimH set.Univ / ↑r
{α : Type u_1} [conditionally_CompleteLattice α] {S t : set α} (hs : BddAbove S) (ht : BddAbove t) (hst : (S ∩ t).Nonempty) : HasSup.Sup (S ∩ t) ≤ HasSup.Sup S ⊓ HasSup.Sup t
{P L : Type u} [HasMem P L] [Configuration.Nondegenerate P L] [Fintype P] [Fintype L] (h : Fintype.Card L ≤ Fintype.Card P) : ∃ (F : L → P), Function.Injective F ∧ ∀ (l : L), F l ∉ l
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] {m : Matrix n n R} {i j : n} (i_Ne_j : i ≠ j) (hij : ∀ (k : n), m k i = m k j) : m.det = 0
{G : Type u} {x : G} {n : ℕ} [Monoid G] (hn : 0 < n) (hx : x ^ n = 1) (hD : ∀ (P : ℕ), Nat.Prime P → P ∣ n → x ^ (n / P) ≠ 1) : order_of x = n
{m : Type u_1} [AddMonoid m] {x : m} : AddMonoid.Closure {x} = Multiples x
{α : Type u} [PseudoMetricSpace α] {x : α} {r : ℝ} : Metric.Bounded (Metric.Sphere x r)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) : 2 • hb.oangle (-x) y = 2 • hb.oangle x y
{α : Type u_1} [UniformSpace α] {S : set (α × α)} (hs : S ∈ Uniformity α) : ∀ᶠ (t : set (α × α)) in (Uniformity α).Small_sets, Comp_Rel t t ⊆ S
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) : hb.rotation 0 = Linear_Isometry_Equiv.refl ℝ v
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasStrictTerminalObjects C] {J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ C) [CategoryTheory.Limits.HasLimit F] (i : J) (h : Π (j : J), j ≠ i → CategoryTheory.Limits.IsTerminal (F.obj j)) [Subsingleton (i ⟶ i)] : CategoryTheory.IsIso (CategoryTheory.Limits.Limitπ F i)
{G : Type u_1} [Group G] : IsDescendingCentralSeries (lower_central_series G)
{x : Pgame} (h : x ≤ 0) (i : x.Left_moves) : (x.move_Left i).move_Right (Pgame.Right_response h i) ≤ 0
{G : Type u} [Group G] [Fintype G] {N : Subgroup G} [N.Normal] (h1 : (Fintype.Card ↥N).IsCoprime N.Index) (h2 : ∀ (G' : Type u) [_inst_4 : Group G'] [_inst_5 : Fintype G'], Fintype.Card G' < Fintype.Card G → ∀ {N' : Subgroup G'} [_inst_6 : N'.Normal], (Fintype.Card ↥N').IsCoprime N'.Index → (∃ (h' : Subgroup G'), N'.Complement' h')) (h3 : ∀ (h : Subgroup G), ¬N.Complement' h) : N.IsCommutative
(𝕜 : Type u_1) [nondiscrete_NormedField 𝕜] {E : Type u_2} [semi_NormedGroup E] [NormedSpace 𝕜 E] (S : set E) : IsClosed (WeakDual.Polar 𝕜 S)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {v : ℝ → E → E} {K : Nnreal} (hv : ∀ (t : ℝ), LipschitzWith K (v t)) {F g : ℝ → E} {A B : ℝ} (hF : Continuous_on F (set.icc A B)) (hF' : ∀ (t : ℝ), t ∈ set.Ico A B → HasDerivWithinAt F (v t (F t)) (set.ici t) t) (hg : Continuous_on g (set.icc A B)) (hg' : ∀ (t : ℝ), t ∈ set.Ico A B → HasDerivWithinAt g (v t (g t)) (set.ici t) t) (ha : F A = g A) (t : ℝ) (h : t ∈ set.icc A B) : F t = g t
(R : Type u) [Ring R] [strong_RankCondition R] {ι : Type v} : module.rank R (ι →₀ R) = (Cardinal.Mk ι).Lift
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F₂ : 𝕜 → F} {n : ℕ} : ContDiff 𝕜 ↑(n + 1) F₂ ↔ Differentiable 𝕜 F₂ ∧ ContDiff 𝕜 ↑n (deriv F₂)
(n : ℕ) (R : Type u_1) [CommRing R] : (Polynomial.cyclotomic n R)._primitive
{α : Type u} [TopologicalSpace α] {S t : set α} (hs : IsCompact S) (ht : IsOpen t) : IsCompact (S  t)
(n : ℤ) : ⇑Zmod.χ₈ ↑n = Ite (n % 2 = 0) 0 (Ite (n % 8 = 1 ∨ n % 8 = 7) 1 (-1))
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {F : ℂ → E} {C : ℂ} {R : Nnreal} (hF : CircleIntegrable F C ↑R) (hR : 0 < R) : HasFpowerSeriesOnBall (λ (W : ℂ), (2 * ↑Real.Pi * Complex.i)⁻¹ • ∮ (z : ℂ) in C(C, ↑R), (z - W)⁻¹ • F z) (Cauchy_PowerSeries F C ↑R) C ↑R
{α : Type u_1} {S : set α} (P : ↥S) : ↑P ∈ S
{L : FirstOrder.Language} {m : Type W} [L.structure m] {S t : L.Substructure m} (h : ∀ (x : m), x ∈ S ↔ x ∈ t) : S = t
{α : Type u_1} [circular_Preorder α] {A B C : α} : HasSbtw.Sbtw A B C ↔ HasSbtw.Sbtw C A B
{n : ℕ} {i₁ i₂ : Fin (n + 3)} (h : i₁ ≠ i₂) : Finset.Univ.Sum (λ (i : Affine.Simplex.points_with_circumcenter_Index (n + 2)), Affine.Simplex.monge_point_vsub_face_centroid_weights_with_circumcenter i₁ i₂ i) = 0
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) : CategoryTheory.topology_of_Closure_operator J₁.Closure_operator _ = J₁
(R : Type u_1) [CommRing R] [IsDomain R] : Polynomial.cyclotomic' 1 R = Polynomial.x - 1
{J : Type u₁} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {F : J ⥤ C} [CategoryTheory.Limits.HasColimit F] (C : CategoryTheory.Limits.Cocone F) (j : J) : CategoryTheory.Limits.Colimitι F j ≫ CategoryTheory.Limits.Colimit.Desc F C = C.ι.App j
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) : P.radius = Filter.at_top.liminf (λ (n : ℕ), 1 / ↑(∥P n∥₊ ^ (1 / ↑n)))
{R : Type u_1} [CommRing R] (S : Subring R) {ι : Type u_2} {t : Finset ι} {F : ι → R} (h : ∀ (C : ι), C ∈ t → F C ∈ S) : t.Prod (λ (i : ι), F i) ∈ S
{n : Type u_3} [Fintype n] {K : Type u_1} [DecidableEq n] [Field K] {m : Matrix n n K} : (∃ (v : n → K) (h : v ≠ 0), m.Mul_vec v = 0) ↔ m.det = 0
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} {S t : set α} (hs : S.Finite) (ht : t.Finite) : finsum (λ (i : α), finsum (λ (h : i ∈ S ∪ t), F i)) + finsum (λ (i : α), finsum (λ (h : i ∈ S ∩ t), F i)) = finsum (λ (i : α), finsum (λ (h : i ∈ S), F i)) + finsum (λ (i : α), finsum (λ (h : i ∈ t), F i))
{α : Type u} [PseudoMetricSpace α] {S : set α} {x y : α} (h : Emetric.diam S ≠ ⊤) (hx : x ∈ S) (hy : y ∈ S) : HasDist.dist x y ≤ Metric.diam S
{R : Type u_1} [CommRing R] [CharZero R] : Function.Injective (λ (n : ℕ), Polynomial.cyclotomic n R)
{R : Type u} [Semiring R] {ι : Type v} [decι : DecidableEq ι] {m : Type u_1} [AddCommMonoid m] [module R m] {A : ι → Submodule R m} (h : direct_Sum._internal A) : supr A = ⊤
{α : Type u_1} {m : Type u_5} {N : Type u_7} [has_Zero m] [CommMonoid N] [DecidableEq α] (F : α →₀ m) (A : α) (B : α → m → N) : F.Prod (λ (x : α) (v : m), Ite (x = A) (B x v) 1) = Ite (A ∈ F.Support) (B A (⇑F A)) 1
 : Subgroup.Normal_Closure {⟨Equiv.Swap 0 4 * Equiv.Swap 1 3, _⟩} = ⊤
{α : Type u_1} [conditionally_CompleteLattice α] {S : set α} {B : α} : S.Nonempty → (∀ (A : α), A ∈ S → B ≤ A) → (∀ (W : α), B < W → (∃ (A : α) (h : A ∈ S), A < W)) → HasInf.Inf S = B
{α : Type u_1} [DecidableEq α] [Fintype α] : ∅.Up_shadow = ∅
{α : Type u} [TopologicalSpace α] {S t : set α} (hs : IsCompact S) (ht : IsClosed t) : IsCompact (S ∩ t)
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] {n : ℕ} {F : Type u_1} [NormedGroup F] [NormedSpace ℝ F] [PartialOrder F] [MeasureTheory.Measure_Space F] [BorelSpace F] (eL : F ≃L[ℝ] Fin (n + 1) → ℝ) (hE_Ord : ∀ (x y : F), ⇑eL x ≤ ⇑eL y ↔ x ≤ y) (hE_vol : MeasureTheory.MeasurePreserving ⇑eL MeasureTheory.MeasureSpace.Volume MeasureTheory.MeasureSpace.Volume) (F : Fin (n + 1) → F → E) (F' : Fin (n + 1) → F → (F →L[ℝ] E)) (S : set F) (hs : S.countable) (A B : F) (hle : A ≤ B) (Hc : ∀ (i : Fin (n + 1)), Continuous_on (F i) (set.icc A B)) (hD : ∀ (x : F), x ∈ Interior (set.icc A B)  S → ∀ (i : Fin (n + 1)), HasFderivAt (F i) (F' i x) x) (DF : F → E) (hDF : ∀ (x : F), DF x = Finset.Univ.Sum (λ (i : Fin (n + 1)), ⇑(F' i x) (⇑(eL.Symm) (Pi.single i 1)))) (Hi : MeasureTheory.IntegrableOn DF (set.icc A B) MeasureTheory.MeasureSpace.Volume) : ∫ (x : F) in set.icc A B, DF x = Finset.Univ.Sum (λ (i : Fin (n + 1)), (∫ (x : Fin n → ℝ) in set.icc (⇑eL A ∘ ⇑(i.Succ_above)) (⇑eL B ∘ ⇑(i.Succ_above)), F i (⇑(eL.Symm) (i.Insert_nth (⇑eL B i) x))) - ∫ (x : Fin n → ℝ) in set.icc (⇑eL A ∘ ⇑(i.Succ_above)) (⇑eL B ∘ ⇑(i.Succ_above)), F i (⇑(eL.Symm) (i.Insert_nth (⇑eL A i) x)))
{α : Type u_1} [TopologicalSpace α] [BaireSpace α] {S t : set α} (hs : _Gδ S) (ht : _Gδ t) (hsc : Dense S) (htc : Dense t) : Dense (S ∩ t)
{A B : ℝ} (m n : ℕ) : ∫ (x : ℝ) in A..B, Real.sin x ^ (2 * m) * Real.cos x ^ (2 * n) = ∫ (x : ℝ) in A..B, ((1 - Real.cos (2 * x)) / 2) ^ m * ((1 + Real.cos (2 * x)) / 2) ^ n
{R : Type u_1} [Semiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {N' : Type u_5} [AddCommGroup N'] [module R N'] {ι : Type u_6} [DecidableEq ι] [Fintype ι] (A : AlternatingMap R m N' ι) : ⇑MultilinearMap.alternatization ↑A = (Fintype.Card ι).factorial • A
{P : ℕ} : padic_val_Int P 0 = 0
{m : Type u_1} [AddZeroClass m] {C : Add_Con m} : ↑0 = 0
{α : Type u} [PseudoMetricSpace α] {S : set α} {x y : α} {t : set α} (xs : x ∈ S) (yt : y ∈ t) : Metric.diam (S ∪ t) ≤ Metric.diam S + HasDist.dist x y + Metric.diam t
{α : Type u} {β : Type v} [SemilatticeSup α] {F : α → β} {r : β → β → Prop} (h : ∀ ⦃i j : α⦄, i ≤ j → r (F i) (F j)) : Directed r F
{R : Type u} {ι : Type v} {m₁ : ι → Type W₁} {m₂ : Type W₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (m₁ i)] [AddCommMonoid m₂] [Π (i : ι), module R (m₁ i)] [module R m₂] [Π (i : ι), TopologicalSpace (m₁ i)] [TopologicalSpace m₂] (F : Continuous_MultilinearMap R m₁ m₂) {α : ι → Type u_1} [Fintype ι] (g : Π (i : ι), α i → m₁ i) [Π (i : ι), Fintype (α i)] : ⇑F (λ (i : ι), Finset.Univ.Sum (λ (j : α i), g i j)) = Finset.Univ.Sum (λ (r : Π (i : ι), α i), ⇑F (λ (i : ι), g i (r i)))
{α : Type u_1} {β : Type u_2} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] [Nonempty β] [has_One α] {F : β → α} (hF : Continuous F) (h : HasCompactMulSupport F) : ∃ (x : β), ∀ (y : β), F x ≤ F y
{A B C : ℤ} (habc : A ∣ B * C) (hab : A.Gcd C = 1) : A ∣ B
{α : Type u} [PseudoMetricSpace α] (A : α) : HasNndist.nndist A A = 0
{α : Type u_1} {β : Type u_3} {γ : Type u_5} {F : α → β → γ} {S S' : set α} {t t' : set β} (hs : S ⊆ S') (ht : t ⊆ t') : set.image2 F S t ⊆ set.image2 F S' t'
{β : Type u} {α : Type v} [CommMonoid β] [DecidableEq α] (S : Finset α) (F : α → β) {A : α} (h : A ∈ S) : (S.erase A).Prod (λ (x : α), F x) * F A = S.Prod (λ (x : α), F x)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} (x : E) {v : ι → E} (hv : Orthonormal 𝕜 v) : ∑' (i : ι), ∥HasInner.inner (v i) x∥ ^ 2 ≤ ∥x∥ ^ 2
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {S : set E} (hs₁ : Convex ℝ S) (hs₂ : IsClosed S) : (⋂ (l : E →L[ℝ] ℝ), {x : E | ∃ (y : E) (h : y ∈ S), ⇑l x ≤ ⇑l y}) = S
{m : Type u_3} {N : Type u_4} [AddZeroClass m] [AddZeroClass N] (F : m →+ N) {x y : m} (h : x = y) : ⇑F x = ⇑F y
{D : set ℝ} (hD : Convex ℝ D) (hD₂ : IsOpen D) {F : ℝ → ℝ} (hF' : DifferentiableOn ℝ F D) (hF'' : DifferentiableOn ℝ (deriv F) D) (hF''_nonneg : ∀ (x : ℝ), x ∈ D → 0 ≤ deriv^[2] F x) : Convex_on ℝ D F
(α : Type u_1) [TopologicalSpace α] [TopologicalSpace.IsSeparable_Space α] [PartialOrder α] : ∃ (S : set α), S.countable ∧ Dense S ∧ (∀ (x : α), _IsBot x → x ∈ S) ∧ ∀ (x : α), _top x → x ∈ S
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [Add_cancel_CommMonoid E] [ordered_AddCommMonoid β] [module 𝕜 E] [HasScalar 𝕜 β] {S : set E} {F : E → β} (hF : strict_Convex_on 𝕜 S F) (C : E) : strict_Convex_on 𝕜 ((λ (z : E), C + z) ⁻¹' S) (F ∘ λ (z : E), z + C)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) (F : v ≃ₗᵢ[ℝ] v) : _.oangle x y = hb.oangle (⇑(F.Symm) x) (⇑(F.Symm) y)
{J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.IsCofiltered J] {F : J ⥤ Profinite} (C : CategoryTheory.Limits.Cone F) (hC : CategoryTheory.Limits.IsLimit C) {α : Type u_1} (F : LocallyConstant ↥(C.x) α) : ∃ (j : J) (g : LocallyConstant ↥(F.obj j) α), F = LocallyConstant.comap ⇑(C.π.App j) g
{R : Type u_1} [CommRing R] (u v W : Fin 3 → R) : Matrix.dot_Product u (⇑(⇑CrossProduct v) W) = Matrix.det ![u, v, W]
{t : ℝ} {g : ℝ → ℝ} (hg : Function.Periodic g t) (h_Int : ∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.MeasureSpace.Volume t₁ t₂) (h₀ : 0 < ∫ (x : ℝ) in 0..t, g x) (hT : 0 < t) : Filter.Tendsto (λ (t : ℝ), ∫ (x : ℝ) in 0..t, g x) Filter.at_IsBot Filter.at_IsBot
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) (h : InnerProductGeometry.angle x y = Real.Pi / 2) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [Ring_hom_isometric σ₁₂] (x : E) : LipschitzWith ∥x∥₊ (λ (F : E →sl[σ₁₂] F), ⇑F x)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (S : Submodule K v) : module.rank K ↥S ≤ 1 ↔ ∃ (v₀ : v), S ≤ Submodule.Span K {v₀}
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {q : QuadraticForm R m} (l : List m) : ⇑clifford_Algebra.reverse (List.Map ⇑(clifford_Algebra.ι q) l).Prod = (List.Map ⇑(clifford_Algebra.ι q) l).reverse.Prod
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] {P1 : P} (P2 : P) (hp1 : P1 ∈ S) : ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P2 -ᵥ ⟨P1, hp1⟩) ∈ S.direction
{m₀ : Type u_1} [MulZeroOneClass m₀] (h : 0 = 1) (A : m₀) : A = 0
{𝕂 : Type u_6} [_R_or_C 𝕂] {E' : Type u_7} [NormedGroup E'] [NormedSpace 𝕂 E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {F : E' → F'} {x : E'} (hF : ContDiff_at 𝕂 1 F x) : ∃ (K : Nnreal) (t : set E') (h : t ∈ nhds x), LipschitzOnWith K F t
{h : Type u} [TopologicalSpace h] {α : Type u_5} [TopologicalSpace α] (e : LocalHomeomorph α h) (h : e.to_local_Equiv.Source = set.Univ) (G : StructureGroupoid h) [IsClosed_under_restriction G] : HasGroupoid α G
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {A l' : α} {S : set α} (hl' : l' < A) : S ∈ nhds_within A (set.Iic A) ↔ ∃ (l : α) (h : l ∈ set.Iio A), set.ioc l A ⊆ S
 : Filter.Tendsto Complex.Exp (Filter.comap Complex.re Filter.at_IsBot) (nhds 0)
(n : ℕ) (x : ℝ) (hx : x ≠ 0) : HasDerivAt (λ (x : ℝ), Polynomial.Eval x (Exp_Neg_Inv_glue.P_aux n) * Real.Exp (-x⁻¹) / x ^ (2 * n)) (Polynomial.Eval x (Exp_Neg_Inv_glue.P_aux (n + 1)) * Real.Exp (-x⁻¹) / x ^ (2 * (n + 1))) x
{α : Type u} [PseudoEmetricSpace α] {δ : ℝ} (δ_Pos : 0 < δ) (E : set α) : Closure E ⊆ Metric.Thickening δ E
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} (h : HasInner.inner x y = 0) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
(L : List ℕ) : L.tail.Sum = L.Sum - L.head
{α : Type u_1} {γ : Type u_2} [MeasurableSpace α] [AddMonoid γ] {P : MeasureTheory.SimpleFunc α γ → Prop} (h_ind : ∀ (C : γ) {S : set α} (hs : Measurable_set S), P (MeasureTheory.SimpleFunc.piecewise S hs (MeasureTheory.SimpleFunc.Const α C) (MeasureTheory.SimpleFunc.Const α 0))) (h_Add : ∀ ⦃F g : MeasureTheory.SimpleFunc α γ⦄, Disjoint (Function.Support ⇑F) (Function.Support ⇑g) → P F → P g → P (F + g)) (F : MeasureTheory.SimpleFunc α γ) : P F
{α : Type u_1} [CommMonoid α] {β : Type u_2} [Fintype β] (S : set β) [Decidable_Pred (λ (_x : β), _x ∈ S)] (F : β → α) (g : ↥S → α) (W : ∀ (x : β) (h : x ∈ S), F x = g ⟨x, h⟩) (W' : ∀ (x : β), x ∉ S → F x = 1) : Finset.Univ.Prod F = Finset.Univ.Prod g
{α : Type u_1} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {g g' : α → β → γ → δ} {S : set α} {t : set β} {u : set γ} (h : ∀ (A : α) (B : β) (C : γ), g A B C = g' A B C) : set.image3 g S t u = set.image3 g' S t u
{α : Type u} {L : List (α × Bool)} {x : α} {B : Bool} : free_Group.red ((x, B) :: L) List.Nil ↔ free_Group.red L [(x, !B)]
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (e : LocalHomeomorph α β) {x : β} (h : x ∈ e.to_local_Equiv.Target) : Continuous_at ⇑(e.Symm) x
{α : Type u_1} {β : Type u_2} [has_Add α] [Preorder α] [Preorder β] {F g : β → α} [CovariantClass α α has_Add.Add has_LE.LE] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] (hF : Monotone F) (hg : Monotone g) : Monotone (λ (x : β), F x + g x)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) {r : ℝ} (hr : r ≠ 0) : 2 • hb.oangle x (r • y) = 2 • hb.oangle x y
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {F : β → γ} (hF : Continuous F) : Continuous (λ (x : α × β), F x.Snd)
{α : Type u_1} {β : Type u_2} [UniformSpace α] [UniformSpace β] {S : set α} {F : α → β} (hs : IsCompact S) (hs' : IsSeparated S) (hF : Continuous_on F S) : uniform_Continuous_on F S
 : CategoryTheory.Faithful Compactum_to_CompHaus
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [strict_Convex_Space ℝ E] {x y z : E} {r : ℝ} (hx : x ∈ metric.IsClosed_ball z r) (hy : y ∈ metric.IsClosed_ball z r) (hne : x ≠ y) : IsOpen_Segment ℝ x y ⊆ Metric.Ball z r
{n m : SimplexCategory {F : n ⟶ m} : CategoryTheory.Mono F ↔ Function.Injective ⇑(SimplexCategory.hom.to_order_hom F)
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {F : R →+* S} {P : Polynomial S} (n : ℕ) (h : P ∈ Polynomial.lifts F) : Polynomial.erase n P ∈ Polynomial.lifts F
{A B C : Prop} : A ∧ B ∨ C ↔ (A ∨ C) ∧ (B ∨ C)
{α : Type u_2} {β : Type u_3} {rα : non_assoc_Semiring α} {rβ : non_assoc_Semiring β} (F : α →+* β) : 0 = 1 ↔ ∀ (x : α), ⇑F x = 0
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F₂ : 𝕜 → F} {S₂ : set 𝕜} (hs : UniqueDiffOn 𝕜 S₂) : ContDiff_on 𝕜 ⊤ F₂ S₂ ↔ DifferentiableOn 𝕜 F₂ S₂ ∧ ContDiff_on 𝕜 ⊤ (deriv_within F₂ S₂) S₂
{β : Type u} {α : Type v} [AddCommMonoid β] [DecidableEq α] (S : Finset α) {F : α → β} {A : α} (h : F A = 0) : (S.erase A).Sum (λ (x : α), F x) = S.Sum (λ (x : α), F x)
{n : ℕ} {E : Type u_1} [NormedGroup E] {F g : (Fin n → ℂ) → E} {C : Fin n → ℂ} {R : Fin n → ℝ} (hF : TorusIntegrable F C R) (hg : TorusIntegrable g C R) : TorusIntegrable (F - g) C R
{R : Type u_1} {A : Type u_2} [AddZeroClass R] [AddZeroClass A] {P : Unitization R A → Prop} (h : ∀ (r : R) (A : A), P (Unitization.inl_ r + ↑A)) (x : Unitization R A) : P x
{R : Type u_3} {S : Type u_4} {A : Type u_5} [CommRing R] [CommRing S] [CommRing A] [Algebra R S] [Algebra S A] [Algebra R A] [IsScalarTower R S A] (hinj : Function.Injective ⇑(Algebra_Map R S)) (A_alg : Algebra.IsAlgebraic R A) : Algebra.IsAlgebraic S A
{R : Type u} [CommRing R] (S : Submonoid R) (L : Type u) [CommRing L] [Algebra R L] [IsLocalization S L] (hS : S ≤ non_Zero_divisors R) : Cardinal.Mk R = Cardinal.Mk L
{α : Type u} [UniformSpace α] {S : set α} {C : set (set α)} (hs : IsCompact S) (hc₁ : ∀ (t : set α), t ∈ C → IsOpen t) (hc₂ : S ⊆ ⋃₀C) : ∃ (n : set (α × α)) (h : n ∈ Uniformity α), ∀ (x : α), x ∈ S → (∃ (t : set α) (h : t ∈ C), ∀ (y : α), (x, y) ∈ n → y ∈ t)
{α : Type u} [Group α] [has_LE α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A B C : α} : B ≤ A⁻¹ * C → A * B ≤ C
{R : Type u_1} [CommRing R] {P : Ideal (Polynomial R)} (pB : P ≠ ⊥) (hP : ∀ (x : R), ⇑Polynomial.C x ∈ P → x = 0) : ∃ (P : Polynomial R), P ∈ P ∧ Polynomial.Map (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P)) P ≠ 0
{m : Type u_1} [Monoid m] {x : m} : x ∈ Powers x
{m : Type u_1} [AddCommGroup m] [module ℝ m] [Finite_dimensional ℝ m] (q : QuadraticForm ℝ m) (hQ : (⇑QuadraticForm.Associated q).nondegenerate) : ∃ (W : Fin (Finite_dimensional.finrank ℝ m) → ℝ), (∀ (i : Fin (Finite_dimensional.finrank ℝ m)), W i = -1 ∨ W i = 1) ∧ q.Equivalent (QuadraticForm.weighted_Sum_squares ℝ W)
{R : Type v} [CommRing R] {A : Matrix (Fin 0) (Fin 0) R} : A.det = 1
{C D : Type u} [CategoryTheory.Category C] [CategoryTheory.Category D] {A : Type W} [CategoryTheory.Category A] [CategoryTheory.Limits.HasLimits A] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {G : C ⥤ D} (hG : CategoryTheory.CoverLifting J K G) (ℱ : CategoryTheory.sheaf J A) : CategoryTheory.Presheaf.IsSheaf K ((CategoryTheory.ran G.Op).obj ℱ.val)
 : (λ (N : ℕ), ↑(⇑roth_number_Nat N)) =O[Filter.at_top] λ (N : ℕ), ↑N
(z : UpperHalfPlane) : ∃ (g : Matrix.special_Linear_Group (Fin 2) ℤ), g • z ∈ modular_Group.Fd
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {C : E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set ℝ} [IntervalIntegral.FTC_Filter B (nhds_within B S) (nhds_within B t)] (hmeas : StronglyMeasurableAtFilter F (nhds_within B t) MeasureTheory.MeasureSpace.Volume) (hb : Filter.Tendsto F (nhds_within B t ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) : HasDerivWithinAt (λ (u : ℝ), ∫ (x : ℝ) in A..u, F x) C S B
{R : Type u_1} {G : Type u_2} [CommRing R] [IsDomain R] [Group G] [Fintype G] (F : G →* R) (hF : F ≠ 1) : Finset.Univ.Sum (λ (g : G), ⇑F g) = 0
{α : Type u_1} [MeasurableSpace α] [TopologicalSpace α] [Opens_MeasurableSpace α] {β : Type u_2} [TopologicalSpace β] [TopologicalSpace.pseudo_metrizable_Space β] [h : SecondCountableTopologyEither α β] {F : α → β} (hF : Continuous F) : MeasureTheory.strongly_Measurable F
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A B : α} (ha : A ≤ 1) (hb : B < 1) : A * B < 1
{α : Type u_1} [cancel_CommMonoid_with_Zero α] [Unique_factorization_Monoid α] [normalization_Monoid α] [DecidableEq α] {x : α} {n : ℕ} : factorization (x ^ n) = n • factorization x
{A B : Ereal} : -A ≤ B ↔ -B ≤ A
{R : Type u} [Ring R] {m : Type v} [AddCommGroup m] [module R m] {m₁ : Type v} [AddCommGroup m₁] [module R m₁] (F : m ≃ₗ[R] m₁) (P : Submodule R m) : module.rank R ↥(Submodule.Map ↑F P) = module.rank R ↥P
{K : Type u} [hring : CommRing K] [hdomain : IsDomain K] {P : Ratfunc K → Prop} (x : Ratfunc K) (F : ∀ (P q : Polynomial K), q ≠ 0 → P (⇑(Algebra_Map (Polynomial K) (Ratfunc K)) P / ⇑(Algebra_Map (Polynomial K) (Ratfunc K)) q)) : P x
{G : Type W} [TopologicalSpace G] [Group G] [topological_Group G] {K v : set G} (hK : IsCompact K) (hV : (Interior v).Nonempty) : ∃ (t : Finset G), K ⊆ ⋃ (g : G) (h : g ∈ t), (λ (h : G), g * h) ⁻¹' v
{τ : Type u_1} {α : Type u_2} {β : Type u_3} [TopologicalSpace β] (F : Filter τ) (ϕ : τ → α → β) (S : set α) [F.Ne_IsBot] {C : set β} (hc₁ : IsCompact C) (hc₂ : ∃ (v : set τ) (h : v ∈ F), Closure (set.image2 ϕ v S) ⊆ C) (hs : S.Nonempty) : (OmegaLimit F ϕ S).Nonempty
{α : Type u} {ι : Type x} [PseudoEmetricSpace α] (F : ι → Function.End α) (K : ι → Nnreal) (h : ∀ (i : ι), LipschitzWith (K i) (F i)) (l : List ι) : LipschitzWith (List.Map K l).Prod (List.Map F l).Prod
{m : Type u_1} [AddMonoid m] (A : m) (u : AddUnits m) : IsAddUnit (A + ↑u) ↔ IsAddUnit A
{α : Type u_1} [CompleteLattice α] {k : α} (hk : CompleteLattice.IsCompact_element k) {S : set α} (hemp : S.Nonempty) (hdir : Directed_on has_LE.LE S) (hbelow : ∀ (x : α), x ∈ S → x < k) : HasSup.Sup S < k
{C : Type v} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] {x Y : C} (F g : x ⟶ Y) (W : ∀ (x : ↥x), ⇑F x = ⇑g x) : F = g
{α : Type u_1} {m : Type u_4} [AddCommMonoid m] (F : α → m) {S t : Finset α} (h : S ⊆ t) : S.Sum (λ (i : α), F i) = t.Sum (λ (i : α), ↑S.indicator F i)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P : ι → P) (i : ι) : ⇑((S.erase i).weighted_vsub_of_point P (P i)) W = ⇑(S.weighted_vsub_of_point P (P i)) W
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) : InnerProductGeometry.angle x y = InnerProductGeometry.angle y x
{α : Type u_1} {β : Type u_2} {r : Setoid α} {F : α → β} (h : Setoid.Ker F ≤ r) (hF : Function.Surjective F) : r.Map F = r.Map_of_surjective F h hF
(A : Cardinal) : A < 2 ^ A
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] {β : Type u_1} {ι : β → Type u_3} [Π (n : β), Encodable (ι n)] (S : set x) {l : Filter β} (r : β → Ennreal) (hr : Filter.Tendsto r l (nhds 0)) (t : Π (n : β), ι n → set x) (ht : ∀ᶠ (n : β) in l, ∀ (i : ι n), Emetric.diam (t n i) ≤ r n) (hst : ∀ᶠ (n : β) in l, S ⊆ ⋃ (i : ι n), t n i) (m : Ennreal → Ennreal) : ⇑(MeasureTheory.Measure.Mk_metric m) S ≤ l.liminf (λ (n : β), ∑' (i : ι n), m (Emetric.diam (t n i)))
{g : Matrix.special_Linear_Group (Fin 2) ℤ} {z : UpperHalfPlane} (hz : z ∈ modular_Group.Fdo) (hg : g • z ∈ modular_Group.Fdo) : ↑g 1 0 = 0
{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), AddMonoid (Gs i)] {x : Π (i : η), Gs i} (h : _of_Fin_Add_order x) (i : η) : _of_Fin_Add_order (x i)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} {v₂ : Type u_5} {P₂ : Type u_6} [AddCommGroup v₂] [module k v₂] [AddTorsor v₂ P₂] {P : ι → P} (hai : AffineIndependent k P) (F : P →ᵃ[k] P₂) (hF : Function.Injective ⇑F) : AffineIndependent k (⇑F ∘ P)
{R : Type u_1} [CommRing R] (v W : Fin 3 → R) : Matrix.dot_Product W (⇑(⇑CrossProduct v) W) = 0
{m : Type u_1} [has_Add m] {β : sort u_2} (C : Add_Con m) (F : m → β) (h : ∀ (A B : m), ⇑C A B → F A = F B) (x : m) : Add_Con.Lift_on ↑x F h = F x
 : strict_Convex_on ℝ set.Univ Real.Exp
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] (x : set (C(α, β) × C(α, β))) : x ∈ Continuous_Map.IsCompact_convergence_Uniformity ↔ ∃ (K : set α) (v : set (β × β)) (hK : IsCompact K) (hV : v ∈ Uniformity β), {fg : C(α, β) × C(α, β) | ∀ (x : α), x ∈ K → (⇑(fg.fst) x, ⇑(fg.Snd) x) ∈ v} ⊆ x
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K₁ K₂ : Submodule 𝕜 E} (h : K₁ ≤ K₂) : K₁ᗮᗮ ≤ K₂ᗮᗮ
{ι : Type u_1} {α : Type u_3} [Preorder ι] [LinearOrder α] {u : ι → α} (h : Monotone u) (h : ¬BddAbove (set.Range u)) : Filter.Tendsto u Filter.at_top Filter.at_top
(P : ℕ) (G : Type u_1) [Group G] [Fact (Nat.Prime P)] [Fintype (Sylow P G)] : Fintype.Card (Sylow P G) ≡ 1 [Mod P]
{m : Type u_1} [has_Mul m] (C : Con m) {W x y z : m} : ⇑C W x → ⇑C y z → ⇑C (W * y) (x * z)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S₁ S₂ : AffineSubspace k P} {P : P} (h₁ : P ∈ S₁) (h₂ : P ∈ S₂) : (S₁ ⊓ S₂).direction = S₁.direction ⊓ S₂.direction
{α : Type u} [AddCommGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] {A B C : α} : A < B + C → A - B < C
{α : Type u_1} {β : Type u_2} [DecidableEq α] [DecidableEq β] (F : α → β) (S : Multiset α) (hF : set.inj_on F {x : α | x ∈ S}) (x : α) (h : x ∈ S) : Multiset.count (F x) (Multiset.Map F S) = Multiset.count x S
 : ⇑Linear_Equiv.det Complex.Conj_lie.to_Linear_Equiv = -1
{C : Type u} [CategoryTheory.Category C] {x Y Z : C} (F : x ⟶ Z) (g : Y ⟶ Z) [CategoryTheory.Limits.HasPullback F g] : CategoryTheory.Limits.HasPullback g F
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x : v} (hx : x ≠ 0) (θ : Real.Angle) : ⇑(o.rotation θ) x = x ↔ θ = 0
{P n : ℕ} : padic_val_Int P ↑n = padic_val_Nat P n
{R : Type u} [Ring R] {m : Type v} [AddCommGroup m] [module R m] {m' : Type v'} [AddCommGroup m'] [module R m'] (F : m ≃ₗ[R] m') : (module.rank R m).Lift = (module.rank R m').Lift
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {j₁ j₂ k₁ k₂ : C} (F₁ : j₁ ⟶ k₁) (g₁ : j₁ ⟶ k₂) (F₂ : j₂ ⟶ k₁) (g₂ : j₂ ⟶ k₂) : ∃ (S : C) (α : k₁ ⟶ S) (β : k₂ ⟶ S), F₁ ≫ α = g₁ ≫ β ∧ F₂ ≫ α = g₂ ≫ β
{α : Type u_1} [Linear_ordered_Field α] {A B : α} (ha : 0 < A) (hb : 0 < B) : A⁻¹ ≤ B⁻¹ ↔ B ≤ A
{C : CategoryTheory.groupoid} : 𝟭 ↥C = 𝟙 C
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) (x : ↥(non_Zero_divisors R)) : 0 < v.Int_Valuation_def ↑x
{m : Type u_1} [MulOneClass m] (S : Submonoid m) : S = ⊥ ∨ ∃ (x : m) (h : x ∈ S), x ≠ 1
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} {S : set α} (h : finprod (λ (i : α), finprod (λ (h : i ∈ S), F i)) ≠ 1) : ∃ (x : α) (h : x ∈ S), F x ≠ 1
{ι : Type u_1} {α : Type u_2} {S : ι → set α} (hs : IndexedPartition S) (x : hs.Quotient) : hs.Proj (⇑(hs.out) x) = x
{α : Type u} [comm_Group α] : _Group_hom has_Inv.Inv
{α : Type u} [UniformSpace α] {S : set α} (h : TotallyBounded S) : TotallyBounded (Closure S)
 : Filter.Tendsto (λ (x : ℝ), x ^ ((-1) / x)) Filter.at_top (nhds 1)
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [NormalSpace Y] [Nonempty x] (F : bounded_Continuous_Function x ℝ) {e : x → Y} (hE : IsClosed_Embedding e) : ∃ (g : bounded_Continuous_Function Y ℝ), (∀ (y : Y), ∃ (x₁ x₂ : x), ⇑g y ∈ set.icc (⇑F x₁) (⇑F x₂)) ∧ ⇑g ∘ e = ⇑F
(S : ℝ) : (λ (x : ℝ), Real.Exp (-x) * x ^ S) =o[Filter.at_top] λ (x : ℝ), Real.Exp (-(1 / 2) * x)
{α : Type u} [TopologicalSpace α] {F : Filter α} : IsClosed {x : α | ClusterPt x F}
{α : Type u} [Preorder α] {A B : α} (h : A ≤ B) : ¬B < A
{F : ℕ → ℝ} (hfa : Monotone F) (hF0 : Filter.Tendsto F Filter.at_top (nhds 0)) : ∃ (l : ℝ), Filter.Tendsto (λ (n : ℕ), (Finset.Range (n + 1)).Sum (λ (i : ℕ), (-1) ^ i * F i)) Filter.at_top (nhds l)
{β : Type u} {α : Type v} {S : Finset α} {A : α} {F : α → β} [AddCommMonoid β] [DecidableEq α] (h : F A = 0) : (HasInsert.Insert A S).Sum (λ (x : α), F x) = S.Sum (λ (x : α), F x)
{α : Type u} [Preorder α] {A : α} {S t P : set α} (hs : IsGlb S A) (hp : IsGlb P A) (hst : S ⊆ t) (htp : t ⊆ P) : IsGlb t A
{α : Type u_1} {δ : Type u_5} [TopologicalSpace α] [MeasurableSpace α] [BorelSpace α] [MeasurableSpace δ] [complete_LinearOrder α] [OrderTopology α] [TopologicalSpace.SecondCountableTopology α] {F : ℕ → δ → α} (hF : ∀ (i : ℕ), Measurable (F i)) : Measurable (λ (x : δ), Filter.at_top.liminf (λ (i : ℕ), F i x))
{α : Type u} {F g : α → α} {x : α} (hF : Function.IsFixedPt F x) (hg : Function.IsFixedPt g x) : Function.IsFixedPt (F ∘ g) x
(B m : ℕ) (hb : 2 ≤ B) : m ≠ 0 → B ^ (B.digits m).length ≤ B * m
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {F : E → G} {C : ℝ} {S : set E} {x y : E} (hF : ∀ (x : E), x ∈ S → Differentiable_at 𝕜 F x) (bound : ∀ (x : E), x ∈ S → ∥fderiv 𝕜 F x∥ ≤ C) (hs : Convex ℝ S) (xs : x ∈ S) (ys : y ∈ S) : ∥F y - F x∥ ≤ C * ∥y - x∥
{F : ℝ → ℝ} {A : ℝ} (h : IsLocalExtr F A) : deriv F A = 0
{G : Type u_1} {h : Type u_2} [Group G] [Group h] [IsCyclic h] (F : G →* h) (hF : F.Ker ≤ Subgroup.Center G) (A B : G) : A * B = B * A
{α : Type u} [PseudoEmetricSpace α] (δ : ℝ) {E₁ E₂ : set α} (h : E₁ ⊆ E₂) : Metric.Thickening δ E₁ ⊆ Metric.Thickening δ E₂
{R : Type u₁} {L : Type u₂} {m : Type u₄} [CommRing R] [lie_Ring L] [lie_Algebra R L] [AddCommGroup m] [module R m] [lie_Ring_module L m] [lie_module R L m] [IsNoetherian R L] : lie_module.IsNilpotent R L m ↔ ∀ (x : L), IsNilpotent (⇑(lie_module.to_endomorphism R L m) x)
{ι : Type u} {x : Type v} [TopologicalSpace x] [ParacompactSpace x] (u : ι → set x) (uo : ∀ (A : ι), IsOpen (u A)) (uc : (⋃ (i : ι), u i) = set.Univ) : ∃ (v : ι → set x), (∀ (A : ι), IsOpen (v A)) ∧ (⋃ (i : ι), v i) = set.Univ ∧ locally_Finite v ∧ ∀ (A : ι), v A ⊆ u A
(n : ℕ) : LinearIndependent ℚ (λ (ν : Fin (n + 1)), bernstein_Polynomial ℚ n ↑ν)
{m : Type u_1} [AddMonoid m] {ι : sort u_2} {S : ι → set m} (h : ∀ (y : ι), _Add_Submonoid (S y)) : _Add_Submonoid (set.Inter S)
{α : Type u_1} [CompleteLattice α] {A : α} {S : set α} : HasInf.Inf S ⊔ A ≤ ⨅ (B : α) (h : B ∈ S), B ⊔ A
{m : Type u_3} {N : Type u_4} [has_One m] [has_One N] {F g : One_hom m N} : F = g ↔ ∀ (x : m), ⇑F x = ⇑g x
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace ℝ P) [Nonempty ↥S] [CompleteSpace ↥(S.direction)] (P₁ P₂ : P) : HasDist.dist P₁ (⇑(EuclideanGeometry.reflection S) P₂) = HasDist.dist (⇑(EuclideanGeometry.reflection S) P₁) P₂
{ι : sort u_1} {ι' : sort u_2} {α : Type u_3} [CompleteLattice α] {S : ι → α} (hs : CompleteLattice.Independent S) (F : ι' → ι) (hF : Function.Injective F) : CompleteLattice.Independent (S ∘ F)
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [Linear_ordered_Field 𝕜] [AddCommGroup E] [Linear_ordered_AddCommGroup β] [module 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F : E → β} (hF : ConcaveOn 𝕜 (⇑(Convex_hull 𝕜) S) F) {x : E} (hx : x ∈ ⇑(Convex_hull 𝕜) S) : ∃ (y : E) (h : y ∈ S), F y ≤ F x
 : set.Unbounded has_LT.LT {B : Ordinal | B.Card.Ord = B}
{α : Type u_1} {R : Type u_2} {l : Filter α} {F : α → R} {r : R} [Linear_ordered_Ring R] [Archimedean R] (hr : r < 0) (hF : Filter.Tendsto F l Filter.at_top) : Filter.Tendsto (λ (x : α), F x * r) l Filter.at_IsBot
{z : UpperHalfPlane} (h : ⇑Complex.norm_sq ↑z < 1) : z.im < (modular_Group.S • z).im
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [OrderedSemiring 𝕜] [AddCommGroup E] [module 𝕜 E] {ι' : Type u_4} (F : ι' ↪ ι) {P : ι → E} (hc : Convex_Independent 𝕜 P) : Convex_Independent 𝕜 (P ∘ ⇑F)
{R : Type u_1} {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] (F : ℕ → R) (g : ℕ → m) {m n : ℕ} (hmn : m < n) : (Finset.Ico m n).Sum (λ (i : ℕ), F i • g i) = F (n - 1) • (Finset.Range n).Sum (λ (i : ℕ), g i) - F m • (Finset.Range m).Sum (λ (i : ℕ), g i) - (Finset.Ico m (n - 1)).Sum (λ (i : ℕ), (F (i + 1) - F i) • (Finset.Range (i + 1)).Sum (λ (i : ℕ), g i))
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {S t : set E} (hs₁ : Convex ℝ S) (hs₂ : IsCompact S) (ht₁ : Convex ℝ t) (ht₂ : IsClosed t) (disj : Disjoint S t) : ∃ (F : E →L[ℝ] ℝ) (u v : ℝ), (∀ (A : E), A ∈ S → ⇑F A < u) ∧ u < v ∧ ∀ (B : E), B ∈ t → v < ⇑F B
{α : Type u} [Group α] [has_LT α] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LT.LT] {A : α} : A⁻¹ < 1 ↔ 1 < A
{α : Type u} [TopologicalSpace α] {S : set α} : Dense (Closure S) ↔ Dense S
{m : Type u_1} {F : Type u_2} [Monoid F] (C : F → m → m) (h1 : C 1 = Id) (HMul : ∀ (F g : F), C (F * g) = C F ∘ C g) (F : F) (n : ℕ) : C (F ^ n) = (C F^[n])
{α : Type u_1} {β : Type u_2} {e e' : local_Equiv α β} (h : ∀ (x : α), ⇑e x = ⇑e' x) (hsymm : ∀ (x : β), ⇑(e.Symm) x = ⇑(e'.Symm) x) (hs : e.Source = e'.Source) : e = e'
{𝕜 : Type u_1} {E : Type u_4} [NormedGroup E] [nondiscrete_NormedField 𝕜] [NormedSpace 𝕜 E] [Nontrivial E] : ∥Continuous_LinearMap.Id 𝕜 E∥ = 1
{F : ℝ → ℝ} (hF : Differentiable ℝ F) (hF'_Mono : Monotone (deriv F)) : Convex_on ℝ set.Univ F
{α : Type u_1} {β : Type u_2} {G₀ : Type u_3} [Group_with_Zero G₀] [TopologicalSpace G₀] [has_Continuous_Inv₀ G₀] [has_Continuous_Mul G₀] [TopologicalSpace α] [TopologicalSpace β] {F g : α → G₀} (h : α → G₀ → β) (hF : Continuous F) (hg : Continuous g) (hH : ∀ (A : α), g A ≠ 0 → Continuous_at ↿h (A, F A / g A)) (h2h : ∀ (A : α), g A = 0 → Filter.Tendsto ↿h ((nhds A).Prod ⊤) (nhds (h A 0))) : Continuous (λ (x : α), h x (F x / g x))
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] {A : α} : A < 0 → 0 < -A
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {C : ℝ} {F : α → E} {g : α → F} {l : Filter α} : (∀ᶠ (x : α) in l, ∥F x∥ ≤ C * ∥g x∥) → Asymptotics._O_with C l F g
(P : ℕ) [Fact (Nat.Prime P)] {A : ℤ} (ha0 : ↑A ≠ 0) : Zmod.legendre_Sym P A = 1 ↔ IsSquare ↑A
(𝕜 : Type u_1) [nondiscrete_NormedField 𝕜] {E : Type u_2} [semi_NormedGroup E] [NormedSpace 𝕜 E] [ProperSpace 𝕜] {S : set E} (S_nhd : S ∈ nhds 0) : IsCompact (WeakDual.Polar 𝕜 S)
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] {F : x → Y} [SequentialSpace x] : Continuous F ↔ Seq_Continuous F
{α : Type u} [Preorder α] {A B C : α} (hab : A = B) (hbc : B ≤ C) : A ≤ C
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {C : ℝ} {F : ℂ → E} {z : ℂ} (hD : Diff_Cont_on_cl ℂ F (set.ioi 0 ×ℂ set.Iio 0)) (hB : ∃ (C : ℝ) (h : C < 2) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal (set.ioi 0 ×ℂ set.Iio 0)] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hre : ∀ (x : ℝ), 0 ≤ x → ∥F ↑x∥ ≤ C) (him : ∀ (x : ℝ), x ≤ 0 → ∥F (↑x * Complex.i)∥ ≤ C) (hz_re : 0 ≤ z.re) (hz_im : z.im ≤ 0) : ∥F z∥ ≤ C
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (θ : Real.Angle) : (-o).rotation θ = o.rotation (-θ)
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] : omega_complete_PartialOrder.Continuous' Coe
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {P : Filter ι} {C : β} : Filter.Tendsto ↿F (P.Prod ⊤) (nhds C) ↔ TendstoUniformly F (λ (_x : α), C) P
{α : Type u_1} {r : α → α → Prop} (hi : Irreflexive r) {S : Multiset α} : (∀ (A : α), A ∈ S → Acc (Relation.CutExpand r) {A}) → Acc (Relation.CutExpand r) S
{S : set Ordinal} (o : Ordinal) : Ordinal.enum_Ord S o = HasInf.Inf (S ∩ {B : Ordinal | ∀ (C : Ordinal), C < o → Ordinal.enum_Ord S C < B})
(n : ℕ) : Finset.Univ.Sum (λ (i : Affine.Simplex.points_with_circumcenter_Index n), Affine.Simplex.circumcenter_weights_with_circumcenter n i) = 1
{α : Type u} [PseudoEmetricSpace α] (E : set α) {δ : ℝ} : Frontier (Metric.Cthickening δ E) ⊆ {x : α | Emetric.Inf_edist x E = Ennreal.of_Real δ}
(F F' : ℝ → ℝ) {A B : ℝ} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hfI : F A = F B) (hff' : ∀ (x : ℝ), x ∈ set.Ioo A B → HasDerivAt F (F' x) x) : ∃ (C : ℝ) (h : C ∈ set.Ioo A B), F' C = 0
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : E → ℝ} {A : E} {F' : E →L[ℝ] ℝ} (h : IsLocalMax F A) (hF : HasFderivAt F F' A) : F' = 0
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] {K : set α} {v : set (β × β)} (F : C(α, β)) (hV : v ∈ Uniformity β) : ∃ (v' : set (β × β)) (h : v' ∈ Uniformity β), v' ⊆ v ∧ ∀ (g : C(α, β)), g ∈ Continuous_Map.IsCompact_conv_nhd K v' F → Continuous_Map.IsCompact_conv_nhd K v' g ⊆ Continuous_Map.IsCompact_conv_nhd K v F
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) {x : C} {S : CategoryTheory.Sieve x} (h : J₁.IsClosed S) {Y : C} (F : Y ⟶ x) : J₁.Covers S F ↔ ⇑S F
 : Real.sin (Real.Pi / 3) = Real.sqrt 3 / 2
{x : Compactum} (F : Ultrafilter ↥x) : F.lim = x.str F
(P : ℕ) (q : ℚ) : padic_norm P (-q) = padic_norm P q
{𝕜 : Type u_1} {E : Type u_3} [OrderedSemiring 𝕜] [TopologicalSpace E] [Add_cancel_CommMonoid E] [has_Continuous_Add E] [module 𝕜 E] {S : set E} (hs : strict_Convex 𝕜 S) (z : E) : strict_Convex 𝕜 ((λ (x : E), z + x) ⁻¹' S)
{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), m ≤ n → P n → P (n + 1)) (n : ℤ) : m ≤ n → P n
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.Finite_presentation R A ↔ ∃ (ι : Type u_2) (_x : Fintype ι) (F : mv_Polynomial ι R →ₐ[R] A), Function.Surjective ⇑F ∧ F.to_Ring_hom.Ker.fg
{n : ℕ} [Fact (0 < n)] (x : (Zmod n)ˣ) : x ^ n.Totient = 1
{γ : Type W} [LinearOrder γ] {A B : γ} {S t : set γ} (ha : IsLeast S A) (hb : IsLeast t B) : IsLeast (S ∪ t) (LinearOrder.min A B)
{R : Type u_1} {m : Type u_3} [Monoid_with_Zero R] [has_Zero m] [MulAction_with_Zero R m] : ¬IsSmulRegular m 0 ↔ Nontrivial m
{R : Type u_4} [Linear_ordered_CommRing R] (A B : R) : 2 * A * B ≤ A ^ 2 + B ^ 2
{α : Type u} [TopologicalSpace α] : TotallyDisconnectedSpace α ↔ ∀ (x : α), ConnectedComponent x = {x}
{E : Type u_4} {F : Type u_5} [NormedGroup E] [NormedSpace ℝ E] [Finite_dimensional ℝ E] [NormedGroup F] [NormedSpace ℝ F] [Finite_dimensional ℝ F] {F : E → F} (h : ContDiff ℝ 1 F) (hEF : Finite_dimensional.finrank ℝ E < Finite_dimensional.finrank ℝ F) : Dense (set.Range F)ᶜ
{F : Type u_2} [NormedGroup F] [NormedSpace ℝ F] {x y : F} (hx : x ≠ 0) (hy : y ≠ 0) : SameRay ℝ x y → ∥x∥⁻¹ • x = ∥y∥⁻¹ • y
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (P : P) : P ∉ ⊥
{m : Type u} {n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] [Fintype m] [DecidableEq m] (A : Matrix m n α) (B : Matrix n m α) : (A.Mul B + 1).det = (B.Mul A + 1).det
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) : K ⊓ Kᗮ = ⊥
{α : Type u} {β : Type v} [AddGroup α] [AddGroup β] {F : α → β} (hF : _AddGroup_hom F) : F 0 = 0
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {F : α → β} (hF' : DenseRange F) (hF : Continuous F) {S : set α} (hs : Dense S) {t : set β} (ht : set.maps_to F S t) : Dense t
(m N : ℕ) : ⇑roth_number_Nat (m + N) ≤ ⇑roth_number_Nat m + ⇑roth_number_Nat N
{E : Type u_4} [NormedGroup E] [NormedSpace ℝ E] {B : ℝ} {F : ℕ → ℝ} {z : ℕ → E} (hfa : Antitone F) (hF0 : Filter.Tendsto F Filter.at_top (nhds 0)) (hzb : ∀ (n : ℕ), ∥(Finset.Range n).Sum (λ (i : ℕ), z i)∥ ≤ B) : Cauchy_Seq (λ (n : ℕ), (Finset.Range (n + 1)).Sum (λ (i : ℕ), F i • z i))
{α : Type u} [PseudoEmetricSpace α] {S t : set α} (h : S ⊆ t) : Emetric.diam S ≤ Emetric.diam t
(m : ℤ) : Convex_on ℝ (set.ioi 0) (λ (x : ℝ), x ^ m)
{α : Type u_1} [Add_Semigroup α] [PartialOrder α] [CovariantClass α α has_Add.Add has_LT.LT] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] [ContravariantClass α α has_Add.Add has_LE.LE] [ContravariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B C D : α} (hac : A ≤ C) (hbd : B ≤ D) : A + B = C + D ↔ A = C ∧ B = D
{α : Type u} [PseudoMetricSpace α] {S t : set α} (h : (S ∩ t).Nonempty) : Metric.diam (S ∪ t) ≤ Metric.diam S + Metric.diam t
{α : Type u_1} [CommMonoid α] (F : ℕ → α) (n : ℕ) : Finset.Univ.Prod (λ (i : Fin n), F ↑i) = (Finset.Range n).Prod (λ (i : ℕ), F i)
(K : Type u_1) (L : Type u_2) [Field K] [Field L] [Algebra K L] [Finite : Finite_dimensional K L] : Algebra.IsAlgebraic K L
(α : Type u_1) [Fintype α] {R : Type u_2} [CommSemiring R] (A B : R) : Finset.Univ.Sum (λ (S : Finset α), A ^ S.Card * B ^ (Fintype.Card α - S.Card)) = (A + B) ^ Fintype.Card α
(n k : ℕ) : (n ^ k).factorization = k • n.factorization
{α : Type u} {L₁ L₂ : List (α × Bool)} [DecidableEq α] (h : free_Group.reduce L₁ = free_Group.reduce L₂) : free_Group.Mk L₁ = free_Group.Mk L₂
{m : Type u_3} [Monoid m] [Inhabited m] (l : List m) (h : l ≠ List.Nil) : l.head * l.tail.Prod = l.Prod
{α : Type u} [Preorder α] {F : ℕ → α} (hF : Monotone F) (n : ℕ) {x : α} (h1 : F n < x) (h2 : x < F (n + 1)) (A : ℕ) : F A ≠ x
{m : Type u_1} {N : Type u_2} [MulOneClass m] [MulOneClass N] (h : m ≃* N) : ⇑h 1 = 1
(R : Type u_1) [CommRing R] [IsDomain R] : Polynomial.cyclotomic' 0 R = 1
{α : Type u} {l : List α} (hn : l.Nodup) : l.cyclic_permutations.Nodup
{𝕂 : Type u_1} [_R_or_C 𝕂] : HasStrictDerivAt (Exp 𝕂) 1 0
{α : Type u_1} {S : Finset α} {F : α → Ennreal} : S.Sum (λ (A : α), F A) < ⊤ ↔ ∀ (A : α), A ∈ S → F A < ⊤
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} {v₂ : Type u_5} {P₂ : Type u_6} [AddCommGroup v₂] [module k v₂] [AddTorsor v₂ P₂] {P : ι → P} (F : P →ᵃ[k] P₂) (hF : Function.Injective ⇑F) : AffineIndependent k (⇑F ∘ P) ↔ AffineIndependent k P
{x : ℝ} (hx : Liouville x) (P : ℝ) : LiouvilleWith P x
{n : Type u_1} {𝕜 : Type u_3} [Field 𝕜] [DecidableEq n] [Fintype n] (m : Matrix n n 𝕜) : ∃ (L L' : List (Matrix.TransvectionStruct n 𝕜)) (D : n → 𝕜), m = ((List.Map Matrix.TransvectionStruct.to_Matrix L).Prod.Mul (Matrix.Diagonal D)).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L').Prod
(K : Type u) (v : Type v) [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] : ↑(Finite_dimensional.finrank K v) = module.rank K v
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LT.LT] {A B : α} (ha : 0 < A) (hb : 0 < B) : 0 < A + B
{α : Type u_1} {β : Type u_2} {F : α → β} {r : Setoid β} : Setoid.comap F r = Setoid.Ker (Quotient.Mk ∘ F)
(x : ℝ) : Summable (λ (n : ℕ), x ^ n / ↑(n.factorial))
{α : Type u} [PseudoMetricSpace α] (S : set α) : uniform_Continuous (λ (x : α), metric.Inf_nndist x S)
{R : Type u_1} {m : Type u_2} [CommSemiring R] [AddCommMonoid m] [module R m] : Submodule.torsion R ↥(Submodule.torsion R m) = ⊤
{ι : Type u} {α : Type v} [DecidableEq α] (t : ι → Finset α) : (∀ (S : Finset ι), S.Card ≤ (S.bUnion t).Card) ↔ ∃ (F : ι → α), Function.Injective F ∧ ∀ (x : ι), F x ∈ t x
{n : ℕ} (A B : Finset (Fin n)) : (Finset.image (λ (i : Fin n), ↑i) A).to_colex ≤ (Finset.image (λ (i : Fin n), ↑i) B).to_colex ↔ A.to_colex ≤ B.to_colex
{F : Type u_3} [Field F] [Fintype F] (hF : Ring_Char F ≠ 2) (A : Fˣ) : IsSquare A ↔ A ^ (Fintype.Card F / 2) = 1
{G : Type u} {y : G} [Monoid G] {x : G} (h : Commute x y) (hx : _of_Fin_order x) (hy : _of_Fin_order y) : _of_Fin_order (x * y)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {C : E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (hb : Filter.Tendsto F (nhds B ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) : HasDerivAt (λ (u : ℝ), ∫ (x : ℝ) in A..u, F x) C B
{m : Type u} [div_Inv_Monoid m] (x : m) (z : ℤ) : Mul_Opposite.Op (x ^ z) = Mul_Opposite.Op x ^ z
{x Y : Type u} (F : x ⟶ Y) : CategoryTheory.Epi F ↔ Function.Surjective F
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} (n : ℕ) (hs : IsOpen S) : set.Eq_on (iterated_fderiv_within 𝕜 n F S) (iterated_fderiv 𝕜 n F) S
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) [CategoryTheory.Limits.HasLimits C] {i : D.to_GlueData.J} (U : TopologicalSpace.Opens ↥((D.to_GlueData.U i).carrier)) : ∃ (Eq_1 : Opposite.Op U = Opposite.Op ((TopologicalSpace.Opens.Map (CategoryTheory.Limits.Colimitι D.to_GlueData.Diagram.multispan (Opposite.Unop (Opposite.Op (CategoryTheory.Limits.WalkingMultispan.Right i)))).Base).obj (_.Functor.obj U))), D.ι_Inv_App U ≫ D.Diagram_over_IsOpen_π U i = (D.to_GlueData.U i).presheaf.Map (CategoryTheory.Eq_to_hom Eq_1)
{α : Type u} {β : Type v} [Preorder β] {F : α → β} {S : set α} {A : α} : IsMinOn F S A → IsMaxOn (⇑order_dual.to_dual ∘ F) S A
{L : FirstOrder.Language} {m : Type W} {N : Type W'} [L.structure m] [L.structure N] {P : Type u_1} [L.structure P] {q : Type u_2} [L.structure q] (F : L.Equiv m N) (g : L.Equiv N P) (h : L.Equiv P q) : (h.Comp g).Comp F = h.Comp (g.Comp F)
{F : ℂ → ℂ} {C : ℂ} {R₁ R₂ : ℝ} (hD : DifferentiableOn ℂ F (Metric.Ball C R₁)) (h_maps : set.maps_to F (Metric.Ball C R₁) (Metric.Ball (F C) R₂)) (h₀ : 0 < R₁) : Complex.Abs (deriv F C) ≤ R₂ / R₁
(n : ℕ+) (K : Type W) (L : Type z) [Field K] [Field L] [Algebra K L] [Ne_Zero ↑↑n] [IsCyclotomicExtension {n} K L] : Polynomial._splitting_Field K L (Polynomial.x ^ ↑n - 1)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {n : WithTop ℕ} {P : E → FormalMultilinearSeries 𝕜 E F} (h : HasFtaylorSeriesUpTo n F P) (hn : 1 ≤ n) (x : E) : HasFderivAt F (⇑(Continuous_multilinear_Curry_Fin1 𝕜 E F) (P x 1)) x
{n : ℕ} : n.factorization.Support = n.Factors.to_Finset
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (𝕜 : Type u_3) [Field 𝕜] [_alg_IsClosed 𝕜] [CategoryTheory.Linear 𝕜 C] [CategoryTheory.Limits.HasKernels C] (x Y : C) [Finite_dimensional 𝕜 (x ⟶ x)] [CategoryTheory.Simple x] [CategoryTheory.Simple Y] : Finite_dimensional.finrank 𝕜 (x ⟶ Y) ≤ 1
(A : Zmod 4) : ⇑Zmod.χ₄ A = 0 ∨ ⇑Zmod.χ₄ A = 1 ∨ ⇑Zmod.χ₄ A = -1
{α : Type u} (r : α → α → Prop) [IsAntisymm α r] {A B : α} : r A B → r B A → A = B
{R : Type u₁} [CommSemiring R] (A B : R) : (A + B) ^ 2 = A ^ 2 + 2 * A * B + B ^ 2
(n : ℕ) (R : Type u_1) [CommRing R] [IsDomain R] : (Polynomial.cyclotomic' n R).monic
(R : Type u_1) {m : Type u_4} (S : Type u_7) [Semiring R] [AddCommMonoid m] [module R m] (S : set m) [Semiring S] [HasScalar R S] [module S m] [IsScalarTower R S m] : Submodule.Span S ↑(Submodule.Span R S) = Submodule.Span S S
{K : Type u_8} {v : Type u_11} [Field K] [AddCommGroup v] [module K v] {B : v →ₗ[K] v →ₗ[K] K} {x : v} (hx : ¬B.IsOrtho x x) : _IsCompl (Submodule.Span K {x}) ((Submodule.Span K {x}).Orthogonal_bilin B)
{R : Type u_1} {m : Type u_2} {m₂ : Type u_3} [TopologicalSpace m] [TopologicalSpace m₂] [Semiring R] [AddCommMonoid m₂] [module R m₂] [AddCommMonoid m] [module R m] (F : m →L[R] m₂) (h : ¬∃ (e' : m ≃L[R] m₂), ↑e' = F) : F.Inverse = 0
(P : ℕ) [Fact (Nat.Prime P)] (A : ℤ) : Zmod.legendre_Sym P A = Zmod.legendre_Sym P (A % ↑P)
(R : Type u₁) {L : Type u₂} [CommRing R] [lie_Ring L] [lie_Algebra R L] {A : Type u₃} [Ring A] [Algebra R A] {g₁ g₂ : universal_enveloping_Algebra R L →ₐ[R] A} (h : ↑g₁.Comp (universal_enveloping_Algebra.ι R) = ↑g₂.Comp (universal_enveloping_Algebra.ι R)) : g₁ = g₂
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {F g : 𝕜 → 𝕜} {F' A : 𝕜} (hg : Continuous_at g A) (hF : HasStrictDerivAt F F' (g A)) (hF' : F' ≠ 0) (hfg : ∀ᶠ (y : 𝕜) in nhds A, F (g y) = y) : HasStrictDerivAt g F'⁻¹ A
(K : Type u) [DivisionRing K] : Finite_dimensional.finrank K K = 1
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] {D₁ D₂ : ℝ} (h : D₁ < D₂) (S : set x) : ⇑(MeasureTheory.Measure.hausdorff_measure D₂) S = 0 ∨ ⇑(MeasureTheory.Measure.hausdorff_measure D₁) S = ⊤
{F : Type u_3} [InnerProductSpace ℝ F] {x : F} {r : ℝ} (hx : x ≠ 0) (hr : 0 < r) : HasInner.inner x (r • x) / (∥x∥ * ∥r • x∥) = 1
{R : Type u₁} [Linear_ordered_Ring R] {A : R} (h : -1 ≤ A) (n : ℕ) : 1 + ↑n * (A - 1) ≤ A ^ n
{α : Type u} {β : Type v} [AddZeroClass α] [AddGroup β] {F : α → β} (hF : _Add_hom F) : _AddMonoid_hom F
{α : Type u_1} {β : Type u_2} [HasMem α β] {S : β} {A B : α} : A ∈ S → B ∉ S → A ≠ B
{α : Type u} [Preorder α] {F : ℕ → α} (hF : Antitone F) (n : ℕ) {x : α} (h1 : F (n + 1) < x) (h2 : x < F n) (A : ℕ) : F A ≠ x
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) : CategoryTheory.Presieve._sheaf J₁ (CategoryTheory.Functor.IsClosed_sieves J₁)
(P : ℕ) {R : Type u_1} {S : Type u_2} [hp : Fact (Nat.Prime P)] [CommRing R] [CommRing S] (F : R →+* S) (r : R) : ⇑(witt_Vector.Map F) (⇑(witt_Vector.teichmuller P) r) = ⇑(witt_Vector.teichmuller P) (⇑F r)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P₂ : ι → P) (P₁ : P) (h : S.Sum (λ (i : ι), W i) = 1) : S.Sum (λ (i : ι), W i • (P₁ -ᵥ P₂ i)) = P₁ -ᵥ ⇑(S.affine_combination P₂) W
{r n : ℕ} (h : r < n / 2) : n.choose r ≤ n.choose (r + 1)
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} [Nontrivial k] {P1 : P} {P : ι → P} : P1 ∈ affine_Span k (set.Range P) ↔ ∃ (S : Finset ι) (W : ι → k) (hw : S.Sum (λ (i : ι), W i) = 1), P1 = ⇑(S.affine_combination P) W
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {F : E → F} {x : E} {n : WithTop ℕ} (g : F →L[𝕜] G) (hF : ContDiff_at 𝕜 n F x) : ContDiff_at 𝕜 n (⇑g ∘ F) x
{α : Type u_1} [DecidableEq α] {S t : Finset α} (h : S ⊆ t) : (Finset.Ioo S t).Card = 2 ^ (t.Card - S.Card) - 2
{R : Type u} [Ring R] [RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {ι : Type u_1} [Fintype ι] (B : Basis ι R m) {W : set m} [Fintype ↥W] (S : Submodule.Span R W = ⊤) : Fintype.Card ι ≤ Fintype.Card ↥W
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {F : E → G} (hF : ContDiff 𝕜 n F) : ContDiff 𝕜 n (λ (x : E × F), F x.fst)
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {v : K} : (GeneralizedContinuedFraction.Int_fract_pair.Seq1 v).fst = GeneralizedContinuedFraction.Int_fract_pair.of v
{α : Type u_1} [DecidableEq α] (S : Finset α) : (Finset.image Quotient.Mk S.diag).Card = S.Card
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {n : ℕ} : iterated_fderiv_within 𝕜 (n + 1) F S = ⇑(Continuous_multilinear_Curry_Left_Equiv 𝕜 (λ (i : Fin (n + 1)), E) F) ∘ fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n F S) S
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B C : α} : A < C - B → A + B < C
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {S : Submodule K v} (h : Finite_dimensional.finrank K ↥S = Finite_dimensional.finrank K v) : S = ⊤
{C : Type u₁} [CategoryTheory.Category C] {x : C} (P : Cᵒᵖ ⥤ Type W) : CategoryTheory.Presieve.IsSheafFor P ⇑⊤
{α : Type uu} (A : α) {l₁ l₂ : List α} : l₁ <+~ l₂ → A :: l₁ <+~ A :: l₂
{α : Type u_1} {ι : sort u_3} [conditionally_CompleteLattice α] [Nonempty ι] {F : ι → α} {C : α} (h : ∀ (x : ι), C ≤ F x) : C ≤ infi F
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) (hF : CategoryTheory.IsEquivalence F) : CategoryTheory.IsEquivalence.of_iso (CategoryTheory.Iso.refl F) hF = hF
{α : Type u_1} : HasStar.Star 1 = 1
(𝕜 : Type v) [_R_or_C 𝕜] {E : Type u} [NormedGroup E] [NormedSpace 𝕜 E] (x : E) (h : x ≠ 0) : ∃ (g : E →L[𝕜] 𝕜), ∥g∥ = 1 ∧ ⇑g x = ↑∥x∥
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {j j' : C} (F F' : j ⟶ j') : CategoryTheory.IsCofiltered.Eq_hom F F' ≫ F = CategoryTheory.IsCofiltered.Eq_hom F F' ≫ F'
{P x : ℝ} {r : ℚ} (hr : r ≠ 0) : LiouvilleWith P (x * ↑r) ↔ LiouvilleWith P x
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (W : ι → k) (P : ι → P) {S₁ S₂ : Finset ι} (h : S₁ ⊆ S₂) : ⇑(S₁.affine_combination P) W = ⇑(S₂.affine_combination P) (↑S₁.indicator W)
{R₁ : Type u_3} {A : Type u_5} {B : Type u_6} [CommSemiring R₁] [CommRing A] [CommRing B] [Algebra R₁ A] [Algebra R₁ B] (F : A →ₐ[R₁] B) : Function.Injective ⇑(Ideal.Ker_Lift_alg F)
{L : FirstOrder.Language} {m : Type u_3} [L.structure m] : FirstOrder.Language.structure.fg L m ↔ ∃ (S : set m), S.Finite ∧ ⇑(FirstOrder.Language.Substructure.Closure L) S = ⊤
{α : Type u_1} [CommSemiring α] (E : LinearRecurrence α) (u v : ℕ → α) (hu : E._solution u) (hv : E._solution v) : u = v ↔ set.Eq_on u v ↑(Finset.Range E.order)
 : Filter.Tendsto Real.Exp Filter.at_top Filter.at_top
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F F₁ : E → F} {x : E} {n : ℕ} (hs : UniqueDiffOn 𝕜 S) (hL : ∀ (y : E), y ∈ S → F₁ y = F y) (hx : x ∈ S) : iterated_fderiv_within 𝕜 n F₁ S x = iterated_fderiv_within 𝕜 n F S x
{α : Type u_1} [TopologicalSpace α] {S : set α} {γ : Type u_4} [Linear_ordered_AddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] [has_Continuous_Add γ] {F g : α → γ} (hF : UpperSemicontinuous_on F S) (hg : UpperSemicontinuous_on g S) : UpperSemicontinuous_on (λ (z : α), F z + g z) S
{α : Type u_1} {r : α → α → Prop} (hi : Irreflexive r) {A : α} (hacc : Acc r A) : Acc (Relation.CutExpand r) {A}
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {P : P} (hp : P ∈ S) : AffineSubspace.Mk' P S.direction = S
{ι : Type u_1} {v : Type u} [CategoryTheory.Category v] [CategoryTheory.Limits.HasZeroMorphisms v] {C : Complex_shape ι} [CategoryTheory.Limits.has_Zero_object v] [CategoryTheory.Limits.HasKernels v] [CategoryTheory.Limits.HasImages v] (C : homological_Complex v C) (i : ι) (h : C.boundaries i ≤ C.cycles i) : (C.boundaries i).of_LE (C.cycles i) h = C.boundaries_to_cycles i
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : HasInner.inner x y = ↑∥x∥ * ↑∥y∥ ↔ ↑∥y∥ • x = ↑∥x∥ • y
{α : Type u} {R : α → α → Prop} {l₁ l₂ l₃ : List α} (h₁ : List.chain' R (l₁ ++ l₂)) (h₂ : List.chain' R (l₂ ++ l₃)) (hn : l₂ ≠ List.Nil) : List.chain' R (l₁ ++ l₂ ++ l₃)
{m : Type u_1} [AddCommGroup m] [module ℂ m] [Finite_dimensional ℂ m] (q : QuadraticForm ℂ m) (hQ : (⇑QuadraticForm.Associated q).nondegenerate) : q.Equivalent (QuadraticForm.weighted_Sum_squares ℂ 1)
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] (F : S.Localization_Map N) (x : m) (y : ↥S) : ∃ (C : ↥S), x + ↑((F.sec (F.Mk' x y)).Snd) + ↑C = (F.sec (F.Mk' x y)).fst + ↑y + ↑C
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) (i : Fin (n + 1)) : S.points i = ⇑(Finset.Univ.affine_combination S.points_with_circumcenter) (Affine.Simplex.point_weights_with_circumcenter i)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (v : v) (h : ∀ (W : v), ∃ (C : K), C • v = W) : Finite_dimensional.finrank K v ≤ 1
{β : Type u} {α : Type v} {S : Finset α} {A : α} {F : α → β} [CommMonoid β] [DecidableEq α] (h : A ∉ S → F A = 1) : (HasInsert.Insert A S).Prod (λ (x : α), F x) = S.Prod (λ (x : α), F x)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (F : E →sl[σ₁₂] F) : Isometry ⇑F ↔ ∀ (x : E), ∥⇑F x∥ = ∥x∥
(ι : Type u_1) {R : Type u_2} {α : Type u_3} [AddMonoid ι] [Monoid R] (l : List α) (Fι : α → ι) (fA : α → R) : l.dprod Fι fA = (List.Map fA l).Prod
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.Finite_Type R A ↔ ∃ (ι : Type u_2) (_x : Fintype ι) (F : mv_Polynomial ι R →ₐ[R] A), Function.Surjective ⇑F
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {F : α → β} (hF : IsClosed_Embedding F) {K : set β} (hK : IsCompact K) : IsCompact (F ⁻¹' K)
{m₀ : Type u_1} {m₀' : Type u_3} [MulZeroOneClass m₀] [Nontrivial m₀] [has_Zero m₀'] [has_One m₀'] (F : m₀' → m₀) (Zero : F 0 = 0) (One : F 1 = 1) : Nontrivial m₀'
{α : Type u_2} {G₀ : Type u_4} [TopologicalSpace α] [Group_with_Zero G₀] [MulAction G₀ α] [has_Continuous_Const_Smul G₀ α] {C : G₀} (hc : C ≠ 0) : IsClosed_Map (λ (x : α), C • x)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} {S : Affine.Simplex ℝ P n} {P P₁ P₂ : P} {r : ℝ} (hp₁ : P₁ ∈ affine_Span ℝ (HasInsert.Insert P (set.Range S.points))) (hp₂ : P₂ ∈ affine_Span ℝ (HasInsert.Insert P (set.Range S.points))) (h₁ : ∀ (i : Fin (n + 1)), HasDist.dist (S.points i) P₁ = r) (h₂ : ∀ (i : Fin (n + 1)), HasDist.dist (S.points i) P₂ = r) : P₁ = P₂ ∨ P₁ = ⇑(EuclideanGeometry.reflection (affine_Span ℝ (set.Range S.points))) P₂
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {ι : Type u_2} {E : ι → Type u_5} [DecidableEq ι] [Fintype ι] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] : IsBoundedBilinearMap 𝕜 (λ (P : (F →L[𝕜] G) × Continuous_MultilinearMap 𝕜 E F), P.fst.Comp_Continuous_MultilinearMap P.Snd)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} {ps : set P} (h : ps ⊆ ↑S) [Nonempty ↥S] [Finite_dimensional ℝ ↥(S.direction)] : EuclideanGeometry.Cospherical ps ↔ ∃ (Center : P) (h : Center ∈ S) (radius : ℝ), ∀ (P : P), P ∈ ps → HasDist.dist P Center = radius
{𝕂 : Type u_1} {𝔸 : Type u_2} [_R_or_C 𝕂] [normed_CommRing 𝔸] [normed_Algebra 𝕂 𝔸] [CompleteSpace 𝔸] {x : 𝔸} : HasFderivAt (Exp 𝕂) (Exp 𝕂 x • 1) x
{β : Type u_4} [LinearOrder β] [NoMinOrder β] {u : ℕ → β} (hu : Filter.Tendsto u Filter.at_top Filter.at_IsBot) : ∃ᶠ (n : ℕ) in Filter.at_top, ∀ (k : ℕ), k < n → u n < u k
{m : Type u} {α : Type v} [CommRing α] [Fintype m] [DecidableEq m] {m : Matrix m m α} (h : IsUnit m) (N : Matrix m m α) : ((m.Mul N).Mul m⁻¹).det = N.det
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [NormalSpace Y] (F : bounded_Continuous_Function x ℝ) (e : C(x, Y)) (hE : IsClosed_Embedding ⇑e) : ∃ (g : bounded_Continuous_Function Y ℝ), ∥g∥ = ∥F∥ ∧ g.Comp_Continuous e = F
{α : Type u_1} [Semigroup α] [PartialOrder α] [CovariantClass α α has_Mul.Mul has_LT.LT] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LE.LE] [ContravariantClass α α has_Mul.Mul has_LE.LE] [ContravariantClass α α (Function.Swap has_Mul.Mul) has_LE.LE] {A B C D : α} (hac : A ≤ C) (hbd : B ≤ D) : A * B = C * D ↔ A = C ∧ B = D
{m : Type u_1} [has_Mul m] {C D : Con m} : Setoid.r = Setoid.r ⊓ Setoid.r
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {n : ℕ} : ContDiff_on 𝕜 ↑(n + 1) F S ↔ ∀ (x : E), x ∈ S → (∃ (u : set E) (h : u ∈ nhds_within x (HasInsert.Insert x S)) (F' : E → (E →L[𝕜] F)), (∀ (x : E), x ∈ u → HasFderivWithinAt F (F' x) u x) ∧ ContDiff_on 𝕜 ↑n F' u)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} {S : set E} : Mdifferentiable_on (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F S → DifferentiableOn 𝕜 F S
{α : Type u} (P : α → Prop) [Decidable_Pred P] (xs : List α) (h : ∀ (x : α), x ∈ xs → ¬P x) (Sep : α) (hsep : P Sep) (as : List α) : List.split_on_P P (xs ++ Sep :: as) = xs :: List.split_on_P P as
{α : Type u_1} [CommMonoid α] {A B : α} {u : αˣ} : A ∣ ↑u * B ↔ A ∣ B
{α : Type u_1} [circular_Preorder α] {A B C : α} (h : HasSbtw.Sbtw A B C) : HasBtw.Btw A B C
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) : S.circumcenter = ⇑(Finset.Univ.affine_combination S.points_with_circumcenter) (Affine.Simplex.circumcenter_weights_with_circumcenter n)
(R : Type u_1) {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] [IsNoetherian_Ring R] {A : set m} (hA : A.Finite) : IsNoetherian R ↥(Submodule.Span R A)
{α : Type u_1} [Preorder α] {A B : α} (h : A ≤ B) : set.ioi B ⊆ set.ici A
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] (S : set α) : finsum (λ (i : α), finsum (λ (h : i ∈ S), 0)) = 0
{𝕂 : Type u_1} {𝔸 : Type u_2} [nondiscrete_NormedField 𝕂] [NormedRing 𝔸] [normed_Algebra 𝕂 𝔸] [CompleteSpace 𝔸] (h : 0 < (Exp_series 𝕂 𝔸).radius) : HasStrictFderivAt (Exp 𝕂) 1 0
{β : Type u} {α : Type v} {γ : Type W} [CommMonoid β] {S : Finset α} {t : Finset γ} {F : α → β} {g : γ → β} (i : Π (A : α), A ∈ S → γ) (hi : ∀ (A : α) (ha : A ∈ S), i A ha ∈ t) (h : ∀ (A : α) (ha : A ∈ S), F A = g (i A ha)) (i_inj : ∀ (A₁ A₂ : α) (ha₁ : A₁ ∈ S) (ha₂ : A₂ ∈ S), i A₁ ha₁ = i A₂ ha₂ → A₁ = A₂) (i_surj : ∀ (B : γ), B ∈ t → (∃ (A : α) (ha : A ∈ S), B = i A ha)) : S.Prod (λ (x : α), F x) = t.Prod (λ (x : γ), g x)
(x : AlgebraicGeometry.LocallyRingedSpace) (r : ↥(AlgebraicGeometry.LocallyRingedSpace.Γ.obj (Opposite.Op x))) : IsUnit (⇑(x.to_toΓ_spec_Map_basic_IsOpen r) r)
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {F : m →+ P} (x : m) : ⇑(Add_Con.Ker_Lift F) ↑x = ⇑F x
{n : Type u_1} {P : Type u_2} {𝕜 : Type u_3} [Field 𝕜] [DecidableEq n] [DecidableEq P] [Fintype n] [Fintype P] (m : Matrix P P 𝕜) (e : P ≃ n) (h : ∃ (L L' : List (Matrix.TransvectionStruct n 𝕜)) (D : n → 𝕜), ((List.Map Matrix.TransvectionStruct.to_Matrix L).Prod.Mul (⇑(Matrix.reindex_alg_Equiv 𝕜 e) m)).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L').Prod = Matrix.Diagonal D) : ∃ (L L' : List (Matrix.TransvectionStruct P 𝕜)) (D : P → 𝕜), ((List.Map Matrix.TransvectionStruct.to_Matrix L).Prod.Mul m).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L').Prod = Matrix.Diagonal D
{C : Type u} [CategoryTheory.Category C] {x Y : AlgebraicGeometry.PresheafedSpace C} (F : x ⟶ Y) [CategoryTheory.IsIso F.Base] [CategoryTheory.IsIso F.C] : CategoryTheory.IsIso F
(F : StieltjesFunction) {A B : ℝ} {C D : ℕ → ℝ} (ss : set.icc A B ⊆ ⋃ (i : ℕ), set.Ioo (C i) (D i)) : Ennreal.of_Real (⇑F B - ⇑F A) ≤ ∑' (i : ℕ), Ennreal.of_Real (⇑F (D i) - ⇑F (C i))
(F : Type u_1) [Field F] [Fintype F] {A : F} (ha : A ≠ 0) : ∃ (B : F), ⇑(Algebra.trace (Zmod (Ring_Char F)) F) (A * B) ≠ 0
{R : Type u} [ordered_CommRing R] [Star_ordered_Ring R] [Algebra ℝ R] [OrderedSmul ℝ R] (A₀ A₁ B₀ B₁ : R) (t : _CHSH_tuple A₀ A₁ B₀ B₁) : A₀ * B₀ + A₀ * B₁ + A₁ * B₀ - A₁ * B₁ ≤ 2
{α : Type u} [TopologicalSpace α] {S : set α} : _Irreducible S ↔ ∀ (U : Finset (set α)), (∀ (u : set α), u ∈ U → IsOpen u) → (∀ (u : set α), u ∈ U → (S ∩ u).Nonempty) → (S ∩ ⋂₀ ↑U).Nonempty
{G : Type u} {x : G} [Fintype G] [Group G] [DecidableEq G] : Finset.image (λ (i : ℕ), x ^ i) (Finset.Range (order_of x)) = ↑(Subgroup.zpowers x).to_Finset
{m : Type u_1} [AddZeroClass m] {S : set m} {P : m → Prop} {x : m} (h : x ∈ AddSubmonoid.Closure S) (Hs : ∀ (x : m), x ∈ S → P x) (h1 : P 0) (HMul : ∀ (x y : m), P x → P y → P (x + y)) : P x
{α : Type u_1} {F : α → α} {x y : α} {n : ℕ} (hx : Function.IsPeriodicPt F n x) (hy : Function.IsPeriodicPt F n y) (hn : 0 < n) (h : F x = F y) : x = y
(G : Type u_1) [comm_Group G] : CommMonoid.torsion G = (torsion G).to_Submonoid
(α : Type u_1) [CompleteLattice α] : CompleteLattice._Sup_IsClosed_IsCompact α → CompleteLattice._Sup_Finite_IsCompact α
{α : Type u} {β : Type v} [CommMonoid β] (S : Finset α) (F : Finset α → β) : S.powerset.Prod (λ (t : Finset α), F t) = (Finset.Range (S.Card + 1)).Prod (λ (j : ℕ), (Finset.powerset_len j S).Prod (λ (t : Finset α), F t))
{α : Type u} {L₁ L₂ : List (α × Bool)} [DecidableEq α] (h : free_Group.red (free_Group.reduce L₁) L₂) : free_Group.reduce L₁ = L₂
{Y : Type u_2} [TopologicalSpace Y] [NormalSpace Y] {S : set Y} (F : C(↥S, ℝ)) (hs : IsClosed S) : ∃ (g : C(Y, ℝ)), Continuous_Map.Restrict S g = F
{α : Type u_1} {m : Type u_5} {N : Type u_7} [has_Zero m] [AddCommMonoid N] (F : α →₀ m) (y : α) (g : α → m → N) (hyf : y ∈ F.Support) : g y (⇑F y) + (Finsupp.erase y F).Sum g = F.Sum g
(cf cg : Nat.Partrec.Code) (A : ℕ) : (cf.prec cg).Eval (Nat.mkpair A 0) = cf.Eval A
{α : Type u_2} {β : Type u_3} [non_assoc_Ring α] [non_assoc_Ring β] (F : α →+* β) (x : α) : ⇑F (-x) = -⇑F x
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {J : Type W} [CategoryTheory.Category J] (K : J ⥤ C) (F : C ⥤ D) [CategoryTheory.Limits.HasColimit (K ⋙ F)] [CategoryTheory.CreatesColimit K F] : CategoryTheory.Limits.HasColimit K
{A B : ℝ} : ∫ (x : ℝ) in A..B, Real.sin x * Real.cos x = (Real.cos A ^ 2 - Real.cos B ^ 2) / 2
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] (F : LocalHomeomorph 𝕜 𝕜) {A F' : 𝕜} (ha : A ∈ F.to_local_Equiv.Target) (hF' : F' ≠ 0) (htff' : HasStrictDerivAt ⇑F F' (⇑(F.Symm) A)) : HasStrictDerivAt ⇑(F.Symm) F'⁻¹ A
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] [CompleteSpace E] (e : E ≃ₗ[𝕜] F) (h : Continuous ⇑e) : Continuous ⇑(e.Symm)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {F F' : ℝ → E} {C : ℝ} (hF : ∀ (x : ℝ), x ∈ set.icc 0 1 → HasDerivWithinAt F (F' x) (set.icc 0 1) x) (bound : ∀ (x : ℝ), x ∈ set.Ico 0 1 → ∥F' x∥ ≤ C) : ∥F 1 - F 0∥ ≤ C
{n : ℕ} [Fact (0 < n)] : Fintype.Card (Quaternion_Group n) = 4 * n
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : S ⊆ ↑(affine_Span k S)
{n : WithTop ℕ} {𝕂 : Type u_6} [_R_or_C 𝕂] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {F : 𝕂 → F'} {F' : F'} {x : 𝕂} (hF : ContDiff_at 𝕂 n F x) (hF' : HasDerivAt F F' x) (hn : 1 ≤ n) : HasStrictDerivAt F F' x
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y z : v} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x y + o.oangle y z = o.oangle x z
{k : Type u_1} {v1 : Type u_2} {P1 : Type u_3} {v2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] [AddCommGroup v2] [module k v2] [AddTorsor v2 P2] (F : P1 → P2) (Linear : v1 →ₗ[k] v2) (Add : ∀ (P : P1) (v : v1), F (v +ᵥ P) = ⇑Linear v +ᵥ F P) : ⇑{ToFun := F, Linear := Linear, Map_vadd' := Add} = F
{α : Type u} [PseudoEmetricSpace α] {x y : α} {S : set α} (h : y ∈ S) : Emetric.Inf_edist x S ≤ HasEdist.edist x y
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {𝕜₃ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [NormedGroup E] [NormedGroup F] [NormedGroup G] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [nondiscrete_NormedField 𝕜₃] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] [NormedSpace 𝕜₃ G] {σ₁₂ : 𝕜 →+* 𝕜₂} {σ₂₃ : 𝕜₂ →+* 𝕜₃} {σ₁₃ : 𝕜 →+* 𝕜₃} [Ring_hom_Comp_triple σ₁₂ σ₂₃ σ₁₃] [Ring_hom_isometric σ₁₂] (F : F →ₛₗᵢ[σ₂₃] G) {g : E →sl[σ₁₂] F} : ∥F.to_Continuous_Linear_Map.Comp g∥ = ∥g∥
{P : ℕ} [hp_Prime : Fact (Nat.Prime P)] (z : ℤ_[P]) : z - ↑(⇑padic_Int.to_Zmod z) ∈ local_Ring.Maximal_Ideal ℤ_[P]
{R : Type u_2} {m : Type u_3} [AddCommGroup m] [Ring R] [module R m] [htwo : Invertible 2] {B : BilinForm R m} (hB₁ : B ≠ 0) (hB₂ : B.IsSymm) : ∃ (x : m), ¬B.IsOrtho x x
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [Finite_dimensional 𝕜 E] {n : ℕ} (hn : Finite_dimensional.finrank 𝕜 E = n) {ι : Type u_4} [Fintype ι] [DecidableEq ι] {v : ι → Submodule 𝕜 E} (hV : direct_Sum._internal v) (A : Fin n) : ⇑(direct_Sum._internal.subordinate_Orthonormal_Basis hn hV) A ∈ v (direct_Sum._internal.subordinate_Orthonormal_Basis_Index hn hV A)
{α : Type u_1} [CompleteLattice α] [_modular_Lattice α] [IsCompactlyGenerated α] [IsAtomistic α] : IsComplemented α
{α : Type u} {β : Type v} [EmetricSpace α] [CompleteSpace α] [EmetricSpace β] {F : α → β} (hF : Isometry F) : IsClosed_Embedding F
{C : Type u} [CategoryTheory.Category C] (B : C) : CategoryTheory.Limits.HasTerminal (CategoryTheory.Over B)
{α : Type u_1} {β : Type u_2} {F : α →. β ⊕ α} (A : α) {B : β} (hb : Sum.inl_ B ∈ F A) : B ∈ F.fix A
(m : Type u_1) {α : Type u_6} [Monoid m] [MulAction m α] : HasScalar.Smul 1 = Id
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Zero_object C] {x : C} (h : ¬CategoryTheory.Limits._Zero x) : Nontrivial (CategoryTheory.Subobject x)
{α : Type u} {β : Type v} [Linear_ordered_Field α] [TopologicalSpace α] [OrderTopology α] {l : Filter β} {F g : β → α} {C : α} (hC : 0 < C) (hF : Filter.Tendsto F l (nhds C)) (hg : Filter.Tendsto g l Filter.at_top) : Filter.Tendsto (λ (x : β), F x * g x) l Filter.at_top
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] (F : x → Y) (h : ∀ (x : x), ∃ (e : LocalHomeomorph x Y), x ∈ e.to_local_Equiv.Source ∧ ∀ (x : x), x ∈ e.to_local_Equiv.Source → F x = ⇑e x) : IsLocallyHomeomorph F
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] (m : Ennreal → Ennreal) (S : set x) : ⇑(MeasureTheory.Measure.Mk_metric m) S = ⨆ (r : Ennreal) (hr : 0 < r), ⨅ (t : ℕ → set x) (h : S ⊆ set.Union t) (h' : ∀ (n : ℕ), Emetric.diam (t n) ≤ r), ∑' (n : ℕ), ⨆ (h : (t n).Nonempty), m (Emetric.diam (t n))
{G : Type u_1} [CommMonoid G] (tG : Monoid._torsion G) : CommMonoid.torsion G = ⊤
(x : Type u_2) [TopologicalSpace x] [RegularSpace x] [TopologicalSpace.SecondCountableTopology x] : ∃ (F : x → bounded_Continuous_Function ℕ ℝ), Embedding F
{t : Type u₁} [CategoryTheory.Category t] {x : t} {F g : CategoryTheory.Over x} (k : F ⟶ g) [hk : CategoryTheory.Epi k.Left] : CategoryTheory.Epi k
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) {r : ℝ} (hr : 0 < r) : hb.oangle (r • x) y = hb.oangle x y
{P : ℤ → Prop} (Hbdd : ∃ (B : ℤ), ∀ (z : ℤ), P z → z ≤ B) (Hinh : ∃ (z : ℤ), P z) : ∃ (ub : ℤ), P ub ∧ ∀ (z : ℤ), P z → z ≤ ub
(R : Type u_1) [Ring R] : Polynomial.cyclotomic 0 R = 1
{α : Type u_1} (r : α → α → Prop) : EqvGen.Setoid (EqvGen.Setoid r).Rel = EqvGen.Setoid r
{K : Type u} [Field K] (S : Subfield K) {x y : K} : x ∈ S → y ∈ S → x / y ∈ S
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 P3 : P) : HasDist.dist P1 P3 * HasDist.dist P1 P3 = HasDist.dist P1 P2 * HasDist.dist P1 P2 + HasDist.dist P3 P2 * HasDist.dist P3 P2 - 2 * HasDist.dist P1 P2 * HasDist.dist P3 P2 * Real.cos (EuclideanGeometry.angle P1 P2 P3)
{α : Type u_2} {β : Type u_3} [DecidableEq β] [HasScalar α β] {u : Finset β} {S : set α} {t : set β} : ↑u ⊆ S • t → (∃ (S' : Finset α) (t' : Finset β), ↑S' ⊆ S ∧ ↑t' ⊆ t ∧ u ⊆ S' • t')
{α : Type u} [TopologicalSpace α] {S : set α} : _Irreducible S ↔ ∀ (Z : Finset (set α)), (∀ (z : set α), z ∈ Z → IsClosed z) → S ⊆ ⋃₀↑Z → (∃ (z : set α) (h : z ∈ Z), S ⊆ z)
{G : Type u_1} [div_Inv_Monoid G] (A B : G) : A / B = A * B⁻¹
{α : Type u_1} {S t : Multiset α} : S ≤ t → S ⊆ t
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] {F : Filter α} {A : α} [F.Ne_IsBot] (h : F ≤ nhds A) : F.liminf = A
{α : Type u} [TopologicalSpace α] {F : ℝ → α} {C : ℝ} (hp : Function.Periodic F C) (hc : C ≠ 0) (hF : Continuous F) : IsCompact (set.Range F)
(R : Type u_1) [CommRing R] (m n : ℕ) : Polynomial.Chebyshev.t R (m * n) = (Polynomial.Chebyshev.t R m).Comp (Polynomial.Chebyshev.t R n)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasTerminal C] : CategoryTheory.Limits.has_Zero_object C
{α : Type u} [Linear_ordered_Field α] [TopologicalSpace α] [OrderTopology α] {n : ℕ} (hn : 1 ≤ n) : Filter.Tendsto (λ (x : α), x ^ -↑n) Filter.at_top (nhds 0)
{α : Type u_1} {n : Type u_3} {m : Type u_4} {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α} {D : Matrix n n α} : (Matrix.from_blocks A B C D).IsSymm ↔ A.IsSymm ∧ B.transpose = C ∧ C.transpose = B ∧ D.IsSymm
{F : Type u_3} [Field F] [Fintype F] (hF : Ring_Char F ≠ 2) {A : F} (ha : A ≠ 0) : A ^ (Fintype.Card F / 2) = 1 ∨ A ^ (Fintype.Card F / 2) = -1
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} {v : ι → E} (hz : ∀ (i : ι), v i ≠ 0) (ho : ∀ (i j : ι), i ≠ j → HasInner.inner (v i) (v j) = 0) : LinearIndependent 𝕜 v
{R : Type u_1} [Mul_Zero_class R] [nR : Nontrivial R] : ¬IsLeftRegular 0
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (G : C ⥤ D) [CategoryTheory.ReflectsIsomorphisms G] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.HasLimits D] [CategoryTheory.Limits.PreservesLimits G] {x : top} (F : top.Presheaf C x) : F._sheaf ↔ top.Presheaf._sheaf (F ⋙ G)
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {F : α → E} {g : α → F} {l : Filter α} : F =o[l] g → ∀ ⦃C : ℝ⦄, 0 < C → (∀ᶠ (x : α) in l, ∥F x∥ ≤ C * ∥g x∥)
{R : Type u} {S : Type u_1} [Ring R] [Ring S] [_principal_Ideal_Ring R] (F : R →+* S) (hF : Function.Surjective ⇑F) : _principal_Ideal_Ring S
{C : Type u₁} [CategoryTheory.Category C] {x Y : C} (F : x ⟶ Y) [CategoryTheory.SplitMono F] [CategoryTheory.Epi F] : CategoryTheory.IsIso F
{G : Type u_10} [Group G] (A : G) : ⇑(Equiv.Symm (Equiv.Mul_Right A)) = λ (x : G), x * A⁻¹
(α : Type u) [TopologicalSpace α] [TopologicalSpace.SecondCountableTopology α] [RegularSpace α] : NormalSpace α
{α : Type u} [PseudoMetricSpace α] {S t : set α} {r : ℝ} (hr : 0 ≤ r) (h1 : ∀ (x : α), x ∈ S → (∃ (y : α) (h : y ∈ t), HasDist.dist x y ≤ r)) (h2 : ∀ (x : α), x ∈ t → (∃ (y : α) (h : y ∈ S), HasDist.dist x y ≤ r)) : metric.Hausdorff_dist S t ≤ r
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : set P} (ho : EuclideanGeometry.OrthocentricSystem S) : ∃ (r : ℝ), ∀ (t : Affine.Triangle ℝ P), set.Range t.points ⊆ S → Affine.Simplex.circumradius t = r
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMinOrder α] {A : α} {S : set α} : S ∈ nhds_within A (set.Iic A) ↔ ∃ (l : α) (h : l ∈ set.Iio A), set.ioc l A ⊆ S
{R : Type u} {L : Type v} [CommRing R] [lie_Ring L] [lie_Algebra R L] : Subsingleton (lie_Ideal R ↥⊥)
{L : FirstOrder.Language} {m : Type W} [L.structure m] {S : L.Substructure m} {S : set m} : ⇑(FirstOrder.Language.Substructure.Closure L) S ≤ S ↔ S ⊆ ↑S
{G : Type u_1} [comm_Group G] (K : Subgroup G) (g : Multiset G) : (∀ (A : G), A ∈ g → A ∈ K) → g.Prod ∈ K
(G : Type u_1) [AddMonoid G] : ¬AddMonoid._torsion G ↔ ∃ (g : G), ¬_of_Fin_Add_order g
{n : ℕ} {α : Type u_1} [Preorder α] {F : Fin (n + 1) → α} : Monotone F ↔ ∀ (i : Fin n), F (⇑Fin.cast_Succ i) ≤ F i.Succ
{k : Type u_1} {v : Type u_2} [Ring k] [AddCommGroup v] [module k v] {ι : Type u_3} (S : Finset ι) {W : ι → k} {P : ι → v} (hw : S.Sum W = 0) : ⇑(S.weighted_vsub P) W = S.Sum (λ (i : ι), W i • P i)
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} [Nontrivial k] (P : ι → P) (j : ι) (q : P) : q ∈ affine_Span k (set.Range P) ↔ ∃ (S : Finset ι) (W : ι → k), q = ⇑(S.weighted_vsub_of_point P (P j)) W +ᵥ P j
{α : Type u} [TopologicalSpace α] {Z : set α} (h : IsClopen Z) : (⋃ (x : α) (h : x ∈ Z), ConnectedComponent x) = Z
{K : Type u_1} [Field K] [Invertible 2] {A B C : K} (ha : A ≠ 0) (h : discrim A B C = 0) (x : K) : A * x * x + B * x + C = 0 ↔ x = -B / (2 * A)
{F : Type v} [NormedGroup F] [NormedSpace ℂ F] {C : ℂ} {R C : ℝ} {F : ℂ → F} (hR : 0 < R) (hD : Diff_Cont_on_cl ℂ F (Metric.Ball C R)) (hC : ∀ (z : ℂ), z ∈ Metric.Sphere C R → ∥F z∥ ≤ C) : ∥deriv F C∥ ≤ C / R
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) (i : Fin (n + 1)) : HasDist.dist S.circumcenter (S.points i) = S.circumradius
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (g : G) (P1 P2 : P) : g +ᵥ P1 -ᵥ P2 = g + (P1 -ᵥ P2)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (h : P 1 = ⇑((Continuous_multilinear_Curry_Fin1 𝕜 E F).Symm) ↑i) (h0 : P 0 = 0) : P.Comp (P.Right_Inv i) = FormalMultilinearSeries.Id 𝕜 F
 : ⇑Linear_Equiv.det Complex.Conj_ae.to_Linear_Equiv = -1
(P q n : ℕ) [Fact (Nat.Prime P)] (hq : q ≠ 0) : padic_val_Nat P (q ^ n) = n * padic_val_Nat P q
{m : Type u} {n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) (B : Matrix n m α) [Invertible A] : A.Mul ((⅟ A).Mul B) = B
{α : Type u} [Lattice α] [comm_Group α] (A : α) (h : 1 ≤ A) : A⁺ = A
{K : Type u_1} [Linear_ordered_Field K] {v : K} [FloorRing K] (terminates : (GeneralizedContinuedFraction.of v).terminates) : ∀ᶠ (n : ℕ) in Filter.at_top, v = (GeneralizedContinuedFraction.of v).convergents n
{G : Type u_10} [Group G] (A : G) : ⇑(Equiv.Symm (Equiv.Mul_Left A)) = has_Mul.Mul A⁻¹
{B : Type u_3} {S : B} {m : Type u_1} [CommMonoid m] [set_like B m] [Submonoid_class B m] (m : Multiset m) (hm : ∀ (A : m), A ∈ m → A ∈ S) : m.Prod ∈ S
{Γ₀ : Type u_1} [Linear_ordered_comm_Group_with_Zero Γ₀] : (nhds 0).has_Basis (λ (_x : Γ₀ˣ), True) (λ (γ₀ : Γ₀ˣ), {γ : Γ₀ | γ < ↑γ₀})
(x : ℂ) : HasStrictDerivAt Complex.sinh (Complex.cosh x) x
{K : Type u} {v : Type v} [Field K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {F g : v →ₗ[K] v} : F.Comp g = LinearMap.Id ↔ g.Comp F = LinearMap.Id
{n : ℕ} (R : Type u_1) [CommRing R] [IsDomain R] : ⇑(Algebra_Map (Polynomial R) (Ratfunc R)) (Polynomial.cyclotomic n R) = n.divisors_antidiagonal.Prod (λ (i : ℕ × ℕ), ⇑(Algebra_Map (Polynomial R) (Ratfunc R)) (Polynomial.x ^ i.Snd - 1) ^ ⇑Nat.ArithmeticFunction.moebius i.fst)
{C : Type u} [CategoryTheory.Category C] {P q : C} (F : P ⟶ q) [CategoryTheory.Epi F] [CategoryTheory.StrongMono F] : CategoryTheory.IsIso F
{P : Type u_1} [SemilatticeSup P] {x y : P} {S : order.Ideal P} (hx : x ∈ S) (hy : y ∈ S) : x ⊔ y ∈ S
{α : Type u_1} [LinearOrder α] {r : α} {S : Finset α} : S.to_colex < {r}.to_colex ↔ ∀ (x : α), x ∈ S → x < r
{α : Type u_1} {β : Type u_2} {e : local_Equiv α β} {S : set α} {t : set β} : e.Source ∩ ⇑e ⁻¹' t = e.Source ∩ S → e._image S t
{α : Type u} [PseudoMetricSpace α] {S t : set α} : metric.Hausdorff_dist S t = metric.Hausdorff_dist t S
{C : Type u} [CategoryTheory.Category C] (x : C) : CategoryTheory.Presieve._sheaf (CategoryTheory.sheaf.canonical_topology C) (CategoryTheory.yoneda.obj x)
{α : Type u_1} {β : Type u_2} [AddGroup α] [subtraction_Monoid β] (F : α →+ β) (g h : α) : ⇑F (g + -h) = ⇑F g + -⇑F h
{G : Type u} [CategoryTheory.groupoid G] [IsFreeGroupoid G] (t : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))) [Quiver.Arborescence ↥t] {A B : IsFreeGroupoid.Generators G} (e : A ⟶ B) (h : e ∈ Quiver.WideSubquiver_Symmetrify t A B) : IsFreeGroupoid.spanning_Tree.loop_of_hom t (IsFreeGroupoid.of e) = 𝟙 (root' t)
{α : Type u} {ι : Type x} [PseudoMetricSpace α] [Fintype ι] {F : α → ι → ℝ} {S : set α} {K : Nnreal} (hF : LipschitzOnWith K F S) : ∃ (g : α → ι → ℝ), LipschitzWith K g ∧ set.Eq_on F g S
(F : ↥(MeasureTheory.Lp ℂ 2 haar_Circle)) : ∑' (i : ℤ), ∥⇑(⇑(fourier_series.repr) F) i∥ ^ 2 = ∫ (t : ↥Circle), ∥⇑F t∥ ^ 2 ∂haar_Circle
{m : Type u_1} [has_Mul m] (C : Con m) : Con.Mul_Ker Coe _ = C
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] {F : C(α, β)} {ι : Type u₃} {P : Filter ι} {F : ι → C(α, β)} (h : TendstoLocallyUniformly (λ (i : ι) (A : α), ⇑(F i) A) ⇑F P) : Filter.Tendsto F P (nhds F)
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : Rˣ) : (λ (t : R), Ring.Inverse (↑x + t)) =O[nhds 0] λ (t : R), 1
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] (v : m) {r : R} (h : 0 < r) : SameRay R (r • v) v
(C : Type u₁) [CategoryTheory.Category C] (D : Type u₂) [CategoryTheory.Category D] (x : C) (Y : D) : 𝟙 (x, Y) = (𝟙 x, 𝟙 Y)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} (l : ι →₀ 𝕜) (v : ι → E) (x : E) : HasInner.inner (l.Sum (λ (i : ι) (A : 𝕜), A • v i)) x = l.Sum (λ (i : ι) (A : 𝕜), ⇑(Star_Ring_end 𝕜) A • HasInner.inner (v i) x)
(n : ℕ) : Ring_Char (Zmod n) = n
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] {S : set α} (hs : IsPreconnected S) : S ∈ {set.icc (HasInf.Inf S) (HasSup.Sup S), set.Ico (HasInf.Inf S) (HasSup.Sup S), set.ioc (HasInf.Inf S) (HasSup.Sup S), set.Ioo (HasInf.Inf S) (HasSup.Sup S), set.ici (HasInf.Inf S), set.ioi (HasInf.Inf S), set.Iic (HasSup.Sup S), set.Iio (HasSup.Sup S), set.Univ, ∅}
{α : Type u_1} {S : Finset α} {F : α → Ennreal} (hF : ∀ (A : α), A ∈ S → F A ≠ ⊤) : (S.Sum (λ (A : α), F A)).to_Nnreal = S.Sum (λ (A : α), (F A).to_Nnreal)
{α : Type u_1} [TopologicalSpace α] [BaireSpace α] {P : α → Prop} : (∀ᶠ (x : α) in residual α, P x) ↔ ∃ (t : set α), _Gδ t ∧ Dense t ∧ ∀ (x : α), x ∈ t → P x
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.SimplicialObject C) {n : ℕ} {i j : Fin (n + 2)} (h : i ≤ j) : x.δ j.Succ ≫ x.δ i = x.δ (⇑Fin.cast_Succ i) ≫ x.δ j
{G : Type u_1} [Group G] (N h : Subgroup G) [N.Normal] : ↑(N ⊔ h) = ↑N * ↑h
{α : Type u} {β : Type v} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {F : Filter β} {u : β → α} {S : set α} (hs : Dense S) (h : ∀ (A : α), A ∈ S → ∀ (B : α), B ∈ S → A < B → ¬((∃ᶠ (n : β) in F, u n < A) ∧ ∃ᶠ (n : β) in F, B < u n)) (h : Filter._bounded_under has_LE.LE F u . "_bounded_Default") (h' : Filter._bounded_under Ge F u . "_bounded_Default") : ∃ (C : α), Filter.Tendsto u F (nhds C)
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {F : α → β} {S : set α} : StrictAntiOn F S → StrictMono_on (⇑order_dual.to_dual ∘ F) S
{R : Type u_1} [Ring R] (S : Subring R) {ι : Type u_2} {t : Finset ι} {F : ι → R} (h : ∀ (C : ι), C ∈ t → F C ∈ S) : t.Sum (λ (i : ι), F i) ∈ S
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {m : MeasurableSpace α} [TopologicalSpace β] [TopologicalSpace.pseudo_metrizable_Space β] [TopologicalSpace γ] [TopologicalSpace.pseudo_metrizable_Space γ] {g : β → γ} {F : α → β} (hg : Embedding g) : MeasureTheory.strongly_Measurable (λ (x : α), g (F x)) ↔ MeasureTheory.strongly_Measurable F
{K : Type u_4} {L : Type u_5} [Field K] [Field L] [Algebra K L] (x : K) : ⇑(Algebra.norm K) (⇑(Algebra_Map K L) x) = x ^ Finite_dimensional.finrank K L
{n m : ℕ} (h : Fin n = Fin m) : cast h = ⇑(Fin.cast _)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) : ⇑_R_or_C.im (HasInner.inner x y) = (∥x - _R_or_C.i • y∥ * ∥x - _R_or_C.i • y∥ - ∥x + _R_or_C.i • y∥ * ∥x + _R_or_C.i • y∥) / 4
(n B : ℕ) : (n + 1) / (B + 2) < n + 1
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {F : α → β} (connected_fibers : ∀ (t : β), IsConnected (F ⁻¹' {t})) (hcl : ∀ (t : set β), IsClosed t ↔ IsClosed (F ⁻¹' t)) (t : β) : IsConnected (F ⁻¹' ConnectedComponent t)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} [CharZero k] {S : Finset ι} (P : ι → P) (h : S.Card ≠ 0) : Finset.centroid k S P ∈ affine_Span k (set.Range P)
{R : Type u_1} {m : Type u_4} {S : Type u_7} [Semiring R] [AddCommMonoid m] [module R m] (P : Submodule R m) [Semiring S] [HasScalar S R] [module S m] [IsScalarTower S R m] : Submodule.Span S ↑P = Submodule.Restrict_scalars S P
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {l : List L} : (∀ (x : L), x ∈ l → x ∈ S) → l.Sum ∈ S
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) : InnerProductGeometry.angle (-x) (-y) = InnerProductGeometry.angle x y
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type W} {x : C} {R : CategoryTheory.Presieve x} : (CategoryTheory.Presieve.IsSeparated_for P R ∧ ∀ (x : CategoryTheory.Presieve.FamilyOfElements P R), x.compatible → (∃ (t : P.obj (Opposite.Op x)), x._amalgamation t)) ↔ CategoryTheory.Presieve.IsSheafFor P R
{β : Type u_2} [DecidableEq β] (S : Finset β) (B : β) : Finset.Filter (Eq B) S = Ite (B ∈ S) {B} ∅
{G : Type u_1} [AddCommGroup G] (B : AddGroup_Filter_Basis G) : uniform_AddGroup G
{F g : ℝ → ℝ} {A B : ℝ} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hgc : Continuous_on g (set.icc A B)) (hle : ∀ (x : ℝ), x ∈ set.ioc A B → F x ≤ g x) (hlt : ∃ (C : ℝ) (h : C ∈ set.icc A B), F C < g C) : ∫ (x : ℝ) in A..B, F x < ∫ (x : ℝ) in A..B, g x
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {C : Con m} (F g : C.Quotient →* P) (h : ∀ (A : m), ⇑F ↑A = ⇑g ↑A) : F = g
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] (P : P) : ↑S ∩ ↑(AffineSubspace.Mk' P (S.direction)ᗮ) = {↑(⇑(EuclideanGeometry.Orthogonal_projection S) P)}
{α : Type u_1} {β : Type u_2} [EmetricSpace α] [PseudoEmetricSpace β] {F : α → β} (h : AntilipschitzWith 0 F) : Subsingleton α
{R : Type u_1} {A : R} [Semigroup R] (B : R) (ha : IsRightRegular A) : IsRightRegular (B * A) ↔ IsRightRegular B
{α : Type u} [UniformSpace α] {S : set α} {ι : sort u_1} {C : ι → set α} (hs : IsCompact S) (hc₁ : ∀ (i : ι), IsOpen (C i)) (hc₂ : S ⊆ ⋃ (i : ι), C i) : ∃ (n : set (α × α)) (h : n ∈ Uniformity α), ∀ (x : α), x ∈ S → (∃ (i : ι), {y : α | (x, y) ∈ n} ⊆ C i)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y : v} (θ : Real.Angle) : hb.oangle x y = θ ↔ (x ≠ 0 ∧ y ≠ 0 ∧ ∃ (r : ℝ), 0 < r ∧ y = r • ⇑(hb.rotation θ) x) ∨ θ = 0 ∧ (x = 0 ∨ y = 0)
(n : ℕ) [Fact (0 < n)] [Fintype (Zmod n)ˣ] : Fintype.Card (Zmod n)ˣ = n.Totient
(K : Type u_1) (L : Type u_2) [Field K] [Field L] [Algebra K L] : Finite_dimensional K ↥⊥
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : ∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * ⇑_R_or_C.re (HasInner.inner x y) + ∥y∥ ^ 2
{α : Type u_1} [generalized_boolean_Algebra α] (u v : α) : set.inj_on (λ (x : α), (x ⊔ u)  v) {x : α | Disjoint u x ∧ v ≤ x}
{β : Type u_4} [LinearOrder β] [NoMaxOrder β] {u : ℕ → β} (hu : Filter.Tendsto u Filter.at_top Filter.at_top) (N : ℕ) : ∃ (n : ℕ) (h : n ≥ N), ∀ (k : ℕ), k < n → u k < u n
{R : Type u_1} [CommRing R] [top : TopologicalSpace R] [topological_Ring R] {J : Ideal R} : IsAdic J ↔ (∀ (n : ℕ), IsOpen ↑(J ^ n)) ∧ ∀ (S : set R), S ∈ nhds 0 → (∃ (n : ℕ), ↑(J ^ n) ⊆ S)
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] {D₁ D₂ : ℝ} (h : D₁ ≤ D₂) (S : set x) : ⇑(MeasureTheory.Measure.hausdorff_measure D₂) S ≤ ⇑(MeasureTheory.Measure.hausdorff_measure D₁) S
{R : Type x} [non_unital_non_assoc_Ring R] {A B : R} (h : Commute A B) : A * A - B * B = (A + B) * (A - B)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {F' : E →L[𝕜] F} {x₀ : E} (hF : HasFderivAt F F' x₀) {C : ℝ} (hC₀ : 0 ≤ C) (hlip : ∀ᶠ (x : E) in nhds x₀, ∥F x - F x₀∥ ≤ C * ∥x - x₀∥) : ∥F'∥ ≤ C
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} (P : ι → P) (i₀ : ι) : Vector_Span k (set.Range P) = Submodule.Span k (set.Range (λ (i : {x // x ≠ i₀}), P i₀ -ᵥ P ↑i))
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x : v} (hx : x ≠ 0) : o.oangle (-x) x = ↑Real.Pi
{G : Type u} [Group G] {N : Subgroup G} [N.Normal] (hN : (Nat.Card ↥N).IsCoprime N.Index) : ∃ (h : Subgroup G), N.Complement' h
 : fourier_Subalgebra.to_Submodule = Submodule.Span ℂ (set.Range fourier)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P (n + 2)) (i₁ i₂ : Fin (n + 3)) : S.monge_plane i₁ i₂ = S.monge_plane i₂ i₁
{α : Type u_1} [Preorder α] [PredOrder α] {A : α} : ¬IsMin A → Order.Pred A < A
{G : Type u_1} [Group G] {N : Type u_3} [Group N] (h : Subgroup G) (F : G ≃* N) : Subgroup.Map F.to_Monoid_hom h.Normalizer = (Subgroup.Map F.to_Monoid_hom h).Normalizer
{R : Type u_1} [CommRing R] {A B : R} : A ^ 4 + 4 * B ^ 4 = (A ^ 2 - 2 * A * B + 2 * B ^ 2) * (A ^ 2 + 2 * A * B + 2 * B ^ 2)
{α : Type u_1} [Preorder α] {A B : α} (h1 : A ≤ B) (h2 : B ≤ A) : A ⩿ B
{n : Type u_1} {𝕜 : Type u_3} [Field 𝕜] [DecidableEq n] [Fintype n] (P : Matrix n n 𝕜 → Prop) (m : Matrix n n 𝕜) (hdiag : ∀ (D : n → 𝕜), (Matrix.Diagonal D).det = m.det → P (Matrix.Diagonal D)) (htransvec : ∀ (t : Matrix.TransvectionStruct n 𝕜), P t.to_Matrix) (HMul : ∀ (A B : Matrix n n 𝕜), P A → P B → P (A.Mul B)) : P m
{α : Type u_1} {β : Type u_2} [MeasurableSpace α] [TopologicalSpace β] [TopologicalSpace.pseudo_metrizable_Space β] [MeasurableSpace β] [BorelSpace β] {ι : Type u_3} {F : ι → α → β} {g : α → β} (u : Filter ι) [u.Ne_IsBot] [u._countably_generated] (hF : ∀ (i : ι), Measurable (F i)) (lim : Filter.Tendsto F u (nhds g)) : Measurable g
{α : Type u} [PseudoEmetricSpace α] {x : α} {S : set α} (h : x ∈ S) : Emetric.Inf_edist x S = 0
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] : Finite_dimensional.finrank K v ≤ 1 ↔ ∃ (v : v), ∀ (W : v), ∃ (C : K), C • v = W
{A : ℝ} {l : Filter ℝ} {F g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in nhds A, Differentiable_at ℝ F x) (hg' : ∀ᶠ (x : ℝ) in nhds A, deriv g x ≠ 0) (hfa : Filter.Tendsto F (nhds A) (nhds 0)) (hga : Filter.Tendsto g (nhds A) (nhds 0)) (HDiv : Filter.Tendsto (λ (x : ℝ), deriv F x / deriv g x) (nhds A) l) : Filter.Tendsto (λ (x : ℝ), F x / g x) (nhds_within A (set.Univ  {A})) l
{R : Type u_1} {m : Type u_3} [Monoid_with_Zero R] [has_Zero m] [MulAction_with_Zero R m] : IsSmulRegular m 0 ↔ Subsingleton m
{ι : Type u₁} {k : Type u₂} {v : Type u₃} {P : Type u₄} [AddCommGroup v] [AddTorsor v P] [Ring k] [module k v] (B : affine_Basis ι k P) {ι' : Type u_1} [Fintype ι'] [Fintype ι] [DecidableEq ι'] (P : ι' → P) {A : Matrix ι ι' k} (hA : (B.to_Matrix P).Mul A = 1) : AffineIndependent k P
{x : Type u} {α : Type v} [TopologicalSpace x] [LinearOrder α] [TopologicalSpace α] [order_IsClosed_topology α] [PreconnectedSpace x] {C : α} {F : x → α} (hF : Continuous F) (h₁ : ∃ (A : x), F A ≤ C) (h₂ : ∃ (B : x), C ≤ F B) : C ∈ set.Range F
{α : Type u_1} [PseudoMetricSpace α] (C : ℝ) {F : ℕ → α} (hu₂ : ∀ (n : ℕ), HasDist.dist (F n) (F (n + 1)) ≤ C / 2 / 2 ^ n) : Cauchy_Seq F
{xl xr : Type u_1} {xL : xl → Pgame} {xR : xr → Pgame} {yl yr : Type u_1} {yL : yl → Pgame} {yR : yr → Pgame} : (Pgame.Mk xl xr xL xR).lf (Pgame.Mk yl yr yL yR) ↔ (∃ (i : yl), Pgame.Mk xl xr xL xR ≤ yL i) ∨ ∃ (j : xr), xR j ≤ Pgame.Mk yl yr yL yR
{G : Type u} {x : G} [Monoid G] : 0 < order_of x ↔ _of_Fin_order x
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [HasScalar 𝕜 E] {S t : Convex_cone 𝕜 E} (h : ↑S = ↑t) : S = t
{α : Type u} (S : set (set α)) : Cardinal.Mk ↥{t : set α | MeasurableSpace.generate_Measurable S t} ≤ LinearOrder.max (Cardinal.Mk ↥S) 2 ^ Cardinal.aleph0
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P1 P2 P3 : P) : P1 -ᵥ P3 - (P2 -ᵥ P3) = P1 -ᵥ P2
(P : ℕ) [Fact (Nat.Prime P)] (A : ℤ) (ha : ↑A ≠ 0) : Zmod.legendre_Sym P A ^ 2 = 1
{R : Type u_4} {S : Type u_5} [non_assoc_Semiring R] [non_assoc_Semiring S] (F : R ≃+* S) : ↑F.to_Equiv = ↑F.to_Equiv
(S : set ℕ+) (K : Type W) [Field K] (C : Type z) [Fintype ↥S] [CommRing C] [Algebra K C] [IsDomain C] [IsCyclotomicExtension S K C] : Finite_dimensional K C
{v : Type u_9} {K : Type u_10} [Field K] [AddCommGroup v] [module K v] {n : Type W} {B : BilinForm K v} {v : n → v} (hv₁ : B._Ortho v) (hv₂ : ∀ (i : n), ¬B.IsOrtho (v i) (v i)) : LinearIndependent K v
{α : Type u} [Preorder α] {A B C : α} : B < C → A ≤ B → A < C
{R : Type u_1} [Mul_Zero_class R] (h : IsLeftRegular 0) : Subsingleton R
{R : Type u_1} {G : Type u_2} [comm_Group G] [CommRing R] [Nontrivial R] : Algebra.Finite_Type R (Monoid_Algebra R G) ↔ Group.fg G
{α : Type u} [TopologicalSpace α] [SigmaCompactSpace α] {F : α → set α} (hF : ∀ (x : α), F x ∈ nhds x) : ∃ (S : set α), S.countable ∧ (⋃ (x : α) (h : x ∈ S), F x) = set.Univ
{A : Type u_1} [AddCommMonoid A] (A B C : A) : C ∈ AddSubmonoid.Closure {A, B} ↔ ∃ (m n : ℕ), m • A + n • B = C
{R : Type u} [Ring R] {m : Type v} [AddCommGroup m] [module R m] [Nontrivial R] {ι : Type W} (B : Basis ι R m) [Infinite ι] {κ : Type W} (v : κ → m) (i : LinearIndependent R v) (m : i.Maximal) : Cardinal.Mk ι ≤ Cardinal.Mk κ
{α : Type u_1} [canonically_ordered_AddMonoid α] [HasSub α] [HasOrderedSub α] {A B : α} (h : A ≤ B) : A - B = 0
(P : ℕ) [Fact (Nat.Prime P)] : padic_norm P ↑P < 1
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {S₁ S₂ : Submodule K v} [Finite_dimensional K ↥S₂] (h : S₁ ≤ S₂) : Finite_dimensional K ↥S₁
{Γ₀ : Type u_3} [Linear_ordered_AddCommMonoid_WithTop Γ₀] [Nontrivial Γ₀] {K : Type u_1} [DivisionRing K] (v : AddValuation K Γ₀) {x : K} : ⇑v x = ⊤ ↔ x = 0
{α : Type u_3} {β : Type u_4} {γ : Type u_5} [Preorder β] [Preorder γ] {F : α → β} {e : β → γ} {l : Filter α} (hm : ∀ (B₁ B₂ : β), e B₁ ≤ e B₂ ↔ B₁ ≤ B₂) (hu : ∀ (C : γ), ∃ (B : β), e B ≤ C) : Filter.Tendsto (e ∘ F) l Filter.at_IsBot ↔ Filter.Tendsto F l Filter.at_IsBot
{α : Type u_1} [DecidableEq α] [Fintype α] {𝒜 : Finset (Finset α)} {S : Finset α} : S ∈ 𝒜.Up_shadow ↔ ∃ (A : α) (h : A ∈ S), S.erase A ∈ 𝒜
{α : Type u_1} [cancel_CommMonoid_with_Zero α] {A : α} {F : Multiset α} (ha : Irreducible A) (pfa : (∀ (B : α), B ∈ F → Prime B) ∧ Associated F.Prod A) : ∃ (P : α), Associated A P ∧ F = {P}
{α : Type u} [PseudoEmetricSpace α] {δ₁ δ₂ : ℝ} (hle : δ₁ ≤ δ₂) (E : set α) : Metric.Cthickening δ₁ E ⊆ Metric.Cthickening δ₂ E
{K : Type v} [Field K] {P : Polynomial K} : Polynomial.Splits (Ring_hom.Id K) P ↔ ⇑Multiset.Card P.roots = P.Nat_degree
{R : Type u_1} [CommSemiring R] {n : Type u_4} [Fintype n] [DecidableEq n] : Linear_Map.to_Matrix (Pi.Basis_fun R n) (Pi.Basis_fun R n) = Linear_Map.to_Matrix'
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} : Mdifferentiable (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F → Differentiable 𝕜 F
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {S : set E} {t : set F} {y : F} (hs : UniqueDiffWithinAt 𝕜 S x) (ht : UniqueDiffWithinAt 𝕜 t y) : UniqueDiffWithinAt 𝕜 (S ×ˢ t) (x, y)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {J : Type u} [CategoryTheory.Category J] (R : D ⥤ C) [CategoryTheory.Reflective R] [CategoryTheory.Limits.HasColimits_of_shape J C] : CategoryTheory.Limits.HasColimits_of_shape J D
{m : Type u_1} [AddMonoid m] {N : Type u_2} [AddMonoid N] {F : m → N} (hF : _AddMonoid_hom F) {S : set N} (hs : _Add_Submonoid S) : _Add_Submonoid (F ⁻¹' S)
{α : Type u_1} [canonically_ordered_AddMonoid α] [HasSub α] [HasOrderedSub α] {A B C : α} [ContravariantClass α α has_Add.Add has_LE.LE] [ContravariantClass α α has_Add.Add has_LT.LT] (hca : C ≤ A) (h : A - B < A - C) : C < B
{G : Type u_7} [AddGroup G] (L : List G) : -L.Sum = (List.Map (λ (x : G), -x) L).reverse.Sum
{α : Type u_1} [CompleteLattice α] {S : set α} (hs : CompleteLattice.set_Independent S) : S.Pairwise_Disjoint Id
{R : Type u} [Ring R] {ι : Type v} [decι : DecidableEq ι] {m : Type u_1} [AddCommGroup m] [module R m] (A : ι → Submodule R m) {i j : ι} (hij : i ≠ j) (h : set.Univ = {i, j}) : direct_Sum._internal A ↔ _IsCompl (A i) (A j)
{α : Type u_1} [MetricSpace α] {K : Nnreal} {F : α → α} (hF : ContractingWith K F) (g : α → α) {x y : α} (hx : Function.IsFixedPt F x) (hy : Function.IsFixedPt g y) {C : ℝ} (hfg : ∀ (z : α), HasDist.dist (F z) (g z) ≤ C) : HasDist.dist x y ≤ C / (1 - ↑K)
(x : AlgebraicGeometry.LocallyRingedSpace) : Continuous x.toΓ_spec_fun
{G : Type u_10} {h : Type u_11} [AddGroup G] [subtraction_Monoid h] (h : G ≃+ h) (x : G) : ⇑h (-x) = -⇑h x
{m : Type u_1} {B : Type u_3} [Monoid m] [set_like B m] [Submonoid_class B m] {S : B} {l : List m} (hl : ∀ (x : m), x ∈ l → x ∈ S) : l.Prod ∈ S
(G : Type u_1) [Monoid G] : ¬Monoid._torsion G ↔ ∃ (g : G), ¬_of_Fin_order g
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k → E} {A B r : k} (h : 0 < (1 - r) * (B - A)) : ⇑(affine_Map.line_Map (F A) (F B)) r ≤ F (⇑(affine_Map.line_Map A B) r) ↔ slope F (⇑(affine_Map.line_Map A B) r) B ≤ slope F A B
{m : Type u_1} [MulOneClass m] {C D : Con m} (h : C ≤ D) (x : C.Quotient) : ⇑(C.Map D h) x = ⇑(C.Lift D.Mk' _) x
{α : Type u} [UniformSpace α] [(Uniformity α)._countably_generated] (U : ℕ → set (α × α)) (U_mem : ∀ (n : ℕ), U n ∈ Uniformity α) (HU : ∀ (u : ℕ → α), (∀ (N m n : ℕ), N ≤ m → N ≤ n → (u m, u n) ∈ U N) → (∃ (A : α), Filter.Tendsto u Filter.at_top (nhds A))) : CompleteSpace α
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryCoproducts C] [CategoryTheory.Limits.HasInitial C] : CategoryTheory.Limits.has_Finite_coproducts C
{α : Type u} [PartialOrder α] {A B : α} : A ≤ B → B ≠ A → A < B
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommGroup β] [HasScalar 𝕜 E] [module 𝕜 β] {S : set E} {F : E → β} : ConcaveOn 𝕜 S F → Convex_on 𝕜 S (-F)
(R : Type u) (m : Type v) (N : Type W) [CommRing R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] [AddCommGroup N] [module R N] [module.free R N] : module.rank R (TensorProduct R m N) = (module.rank R m).Lift * (module.rank R N).Lift
{α : Type v} [LinearOrder α] [TopologicalSpace α] [order_IsClosed_topology α] {S : set α} (hs : IsConnected S) {A B : α} (ha : A ∈ S) (hb : B ∈ S) : set.icc A B ⊆ S
{𝕜 : Type u_1} {E : Type u_4} [semi_NormedGroup E] [nondiscrete_NormedField 𝕜] [NormedSpace 𝕜 E] : ∥Continuous_LinearMap.Id 𝕜 E∥ ≤ 1
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k → E} {A B r : k} (h : 0 < (1 - r) * (B - A)) : F (⇑(affine_Map.line_Map A B) r) ≤ ⇑(affine_Map.line_Map (F A) (F B)) r ↔ slope F A B ≤ slope F (⇑(affine_Map.line_Map A B) r) B
{k : Type u_1} {m : Type u_2} [ordered_Ring k] [ordered_AddCommGroup m] [module k m] [OrderedSmul k m] {A : m} {C : k} (hc : C < 0) : A < 0 → 0 < C • A
{n A : ℕ} (h : A < n + 1) : ↑↑A = A
{R : Type u} {A : Type W} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) (r : R) (y : A) : x * ⇑(Algebra_Map R A) r * y = x * y * ⇑(Algebra_Map R A) r
{C : Type u₁} [CategoryTheory.Category C] {x Y : C} [CategoryTheory.Limits.HasImages C] (F : x ⟶ Y) [CategoryTheory.Mono F] : CategoryTheory.Subobject.exists F = CategoryTheory.Subobject.Map F
{A B : Ereal} (h : A ≤ -B) : B ≤ -A
{G : Type u_3} [AddGroup G] (P : Add_Subgroup G) : P.fg ↔ ∃ (S : set G), Add_Subgroup.Closure S = P ∧ S.Finite
{R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] : Algebra.IsAlgebraic R A ↔ ⊤.IsAlgebraic
{α : Type u_1} [DecidableEq α] {S : Multiset α} : S.Nodup → S.dedup = S
{h : Type u_1} [TopologicalSpace h] (G : StructureGroupoid h) [IsClosed_under_restriction G] : G.LocalInvariantProp G G._local_structomorph_within_at
{x : Type u} {m₁ m₂ : x → x → x} {e₁ e₂ : x} (h₁ : EckmannHilton.IsUnital m₁ e₁) (h₂ : EckmannHilton.IsUnital m₂ e₂) (Distrib : ∀ (A B C D : x), m₁ (m₂ A B) (m₂ C D) = m₂ (m₁ A C) (m₁ B D)) : e₁ = e₂
(S : set ℝ) (hS : ∀ (x : ℝ), x ∈ S → 0 ≤ x) : 0 ≤ HasSup.Sup S
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {S : set E} {F : E → F} {n : WithTop ℕ} {P : E → FormalMultilinearSeries 𝕜 E F} (g : F →L[𝕜] G) (hF : HasFtaylorSeriesUpToOn n F P S) : HasFtaylorSeriesUpToOn n (⇑g ∘ F) (λ (x : E) (k : ℕ), g.Comp_Continuous_MultilinearMap (P x k)) S
{α : Type u_1} [Linear_ordered_Field α] [Archimedean α] {x y : α} (hx : 0 < x) (hy : 1 < y) : ∃ (n : ℤ), x ∈ set.Ico (y ^ n) (y ^ (n + 1))
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {α : E} {q : Polynomial F} (q_irred : Irreducible q) (q_aeval : ⇑(Polynomial.aeval α) q = 0) (hα : _IsSolvableByRad F α) : IsSolvable q.Gal
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (e : LocalHomeomorph α β) {F : β → γ} {S : set β} (h : S ⊆ e.to_local_Equiv.Target) : Continuous_on F S ↔ Continuous_on (F ∘ ⇑e) (e.to_local_Equiv.Source ∩ ⇑e ⁻¹' S)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) : Disjoint K Kᗮ
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {x : 𝕜} {F' : 𝕜 →L[𝕜] F} : HasFderivAt F F' x ↔ HasDerivAt F (⇑F' 1) x
{L : FirstOrder.Language} {m : Type W} [L.structure m] {S : set m} {P : m → Prop} {x : m} (h : x ∈ ⇑(FirstOrder.Language.Substructure.Closure L) S) (Hs : ∀ (x : m), x ∈ S → P x) (Hfun : ∀ {n : ℕ} (F : L.Functions n), FirstOrder.Language.IsClosed_under F (set_of P)) : P x
{B : Type u} [CategoryTheory.Bicategory B] {A B C : B} (F : A ⟶ B) (g : B ⟶ C) : CategoryTheory.Bicategory.whisker_Right (CategoryTheory.Bicategory.Left_unitor F).hom g = (CategoryTheory.Bicategory.associator (𝟙 A) F g).hom ≫ (CategoryTheory.Bicategory.Left_unitor (F ≫ g)).hom
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P₁ P₂ : ι → P) : S.Sum (λ (i : ι), W i • (P₁ i -ᵥ P₂ i)) = ⇑(S.affine_combination P₁) W -ᵥ ⇑(S.affine_combination P₂) W
{α : Type u_1} [Preorder α] [PredOrder α] {A B : α} [NoMinOrder α] : Order.Pred A ≤ Order.Pred B → A ≤ B
{α : Type u} [TopologicalSpace α] {S : set α} : IsPreconnected S ↔ ∀ (u v : set α), IsClosed u → IsClosed v → S ⊆ u ∪ v → S ∩ (u ∩ v) = ∅ → S ⊆ u ∨ S ⊆ v
{n : ℕ} {α : Fin (n + 1) → Type u} (q : Π (i : Fin (n + 1)), α i) (i : Fin n) (y : α i.Succ) : Fin.tail (Function.update q i.Succ y) = Function.update (Fin.tail q) i y
{C : Type u} [CategoryTheory.Category C] {x Y : AlgebraicGeometry.PresheafedSpace C} {F : x ⟶ Y} (h : AlgebraicGeometry.PresheafedSpace.IsOpen_immersion F) (U : TopologicalSpace.Opens ↥Y) (hU : ↑U ⊆ set.Range ⇑(F.Base)) : F.C.App (Opposite.Op U) ≫ h.Inv_App ((TopologicalSpace.Opens.Map F.Base).obj U) = Y.presheaf.Map (CategoryTheory.Eq_to_hom _).Op
{n : ℕ} (P : Fin (n + 1)) (i : Fin n) : ⇑(P.Succ_above) i < P ↔ ⇑Fin.cast_Succ i < P
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) : hb.oangle x (-y) + hb.oangle y (-x) = 0
{α : Type u_3} [SemilatticeSup α] (A : α) : Filter.at_top = Filter.comap Coe Filter.at_top
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {C : ℝ} {F : α → E} {g' : α → F'} {l : Filter α} : Asymptotics._O_with C l F (λ (x : α), -g' x) → Asymptotics._O_with C l F g'
(k : Type u_1) {v : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Fintype ι] (P : ι → P) {n : ℕ} (hc : Fintype.Card ι = n + 1) : Finite_dimensional.finrank k ↥(Vector_Span k (set.Range P)) ≤ n
{n : ℕ} {P : Fin n → Prop} [Decidable_Pred P] : ↥((Fin.Find P)._Some) ↔ ∃ (i : Fin n), P i
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : ↑(affine_Span k S) = SpanPoints k S
{k : Type u₁} {G : Type u₂} [CommSemiring k] [AddMonoid G] {A : Type u₃} [Semiring A] [Algebra k A] (F : AddMonoid_Algebra k G →ₐ[k] A) (F : Monoid_Algebra k G) : ⇑F F = Finsupp.Sum F (λ (A : G) (B : k), B • ⇑F (Finsupp.single A 1))
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {n : WithTop ℕ} {F g : E → 𝕜} (hF : ContDiff 𝕜 n F) (hg : ContDiff 𝕜 n g) : ContDiff 𝕜 n (λ (x : E), F x * g x)
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) {x : C} (S : CategoryTheory.Sieve x) : S ≤ J₁.close S
(n : ℕ) : (Finset.Range n).Sum (λ (i : ℕ), i) = n * (n - 1) / 2
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (F : E →sl[σ₁₂] F) {m : ℝ} (hMp : 0 ≤ m) (hM : ∀ (x : E), ∥⇑F x∥ ≤ m * ∥x∥) : ∥F∥ ≤ m
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {x : E} {n : WithTop ℕ} {P : E → FormalMultilinearSeries 𝕜 E F} (h : HasFtaylorSeriesUpToOn n F P S) (hn : 1 ≤ n) (hx : S ∈ nhds x) : ∀ᶠ (y : E) in nhds x, HasFderivAt F (⇑(Continuous_multilinear_Curry_Fin1 𝕜 E F) (P y 1)) y
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B : α} : A < -B → B < -A
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [CommRing 𝕜] [AddCommGroup E] [AddCommGroup F] [AddCommGroup G] [module 𝕜 E] [module 𝕜 F] [module 𝕜 G] [TopologicalSpace E] [TopologicalSpace F] [TopologicalSpace G] [topological_AddGroup E] [has_Continuous_Const_Smul 𝕜 E] [topological_AddGroup F] [has_Continuous_Const_Smul 𝕜 F] [topological_AddGroup G] [has_Continuous_Const_Smul 𝕜 G] (q : FormalMultilinearSeries 𝕜 F G) (P : FormalMultilinearSeries 𝕜 E F) (v : Fin 1 → E) : ⇑(q.Comp P 1) v = ⇑(q 1) (λ (i : Fin 1), ⇑(P 1) v)
{α : Type u_1} [TopologicalSpace α] [non_assoc_Ring α] (h : topological_Semiring α) : topological_Ring α
{α : Type u} [PartialOrder α] {A B : α} (h : A ≤ B) : A = B ∨ A < B
{R₁ : Type u_1} {R₂ : Type u_2} [Semiring R₁] [Semiring R₂] {σ₁₂ : R₁ →+* R₂} {m₁ : Type u_4} [TopologicalSpace m₁] [AddCommMonoid m₁] {m₂ : Type u_6} [TopologicalSpace m₂] [AddCommMonoid m₂] [module R₁ m₁] [module R₂ m₂] [t2_Space m₂] {S : set m₁} {F g : m₁ →sl[σ₁₂] m₂} (h : set.Eq_on ⇑F ⇑g S) : set.Eq_on ⇑F ⇑g (Closure ↑(Submodule.Span R₁ S))
{F₁ F₂ : Circle_deg1_Lift} (h₁ : IsUnit F₁) (h₂ : IsUnit F₂) (h : F₁.TranslationNumber = F₂.TranslationNumber) : ∃ (F : Circle_deg1_Lift), Function.Semiconj ⇑F ⇑F₁ ⇑F₂
(α : Type u) [MetricSpace α] [TopologicalSpace.IsSeparable_Space α] : Isometry (Kuratowski_Embedding α)
{𝕜 : Type u_1} {F : Type u_3} [_R_or_C 𝕜] [AddCommGroup F] [module 𝕜 F] [C : InnerProductSpace.core 𝕜 F] {x y : F} : HasInner.inner (x + y) (x + y) = HasInner.inner x x + HasInner.inner x y + HasInner.inner y x + HasInner.inner y y
{α : Type u} {β : Type v} [TopologicalSpace α] [MetricSpace β] [has_Zero β] {ι : Type u_1} {F : ι → Zero_at_infty_Continuous_Map α β} {F : Zero_at_infty_Continuous_Map α β} {l : Filter ι} : Filter.Tendsto F l (nhds F) ↔ TendstoUniformly (λ (i : ι), ⇑(F i)) ⇑F l
{α : Type u_1} [MeasurableSpace α] : Function.Injective MeasureTheory.JordanDecomposition.to_SignedMeasure
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {S : set E} {F : E → F} {n : WithTop ℕ} (e : F ≃L[𝕜] G) : ContDiff_on 𝕜 n (⇑e ∘ F) S ↔ ContDiff_on 𝕜 n F S
{m : Type u_1} [AddMonoid m] {S : set m} {A : m} (hs : _Add_Submonoid S) (h : A ∈ S) : Multiples A ⊆ S
{α : Type u} [PseudoMetricSpace α] {S : set α} [ProperSpace α] (hc : IsClosed S) (hb : Metric.Bounded S) : IsCompact S
{n : ℕ} {α : Type u_1} (l : List α) (C : Composition n) {i : ℕ} (hi : i < (l.split_wrt_Composition C).length) : (l.split_wrt_Composition C).nth_LE i hi = List.Drop (C.size_Up_to i) (List.take (C.size_Up_to (i + 1)) l)
{S : ℂ} (hs : 0 < S.re) : MeasureTheory.IntegrableOn (λ (x : ℝ), ↑(Real.Exp (-x)) * ↑x ^ (S - 1)) (set.ioi 0) MeasureTheory.MeasureSpace.Volume
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_Ring 𝕜] [AddCommGroup E] [AddCommGroup F] [module 𝕜 E] [module 𝕜 F] {A B : 𝕜} {x y : E} {F : E →ᵃ[𝕜] F} (h : A + B = 1) : ⇑F (A • x + B • y) = A • ⇑F x + B • ⇑F y
{m : Type u_1} [Monoid m] {S : set m} {A : m} (h : A ∈ Monoid.Closure S) : ∃ (l : List m), (∀ (x : m), x ∈ l → x ∈ S) ∧ l.Prod = A
{α : Type u} [Preorder α] {A B C : α} (hab : A < B) (hbc : B = C) : A < C
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} [Fintype ι] {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι → 𝕜) (i : ι) : HasInner.inner (v i) (Finset.Univ.Sum (λ (i : ι), l i • v i)) = l i
{α : Type u_1} [CommMonoid α] [Decidable_Rel has_Dvd.Dvd] {A B : α} : A ∣ B → 0 < multiplicity A B
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {P : FormalMultilinearSeries 𝕜 E F} {x : E} {r r' : Ennreal} (hF : HasFpowerSeriesOnBall F P x r) (hr : r' < r) : ∃ (C : ℝ), ∀ (y : E), y ∈ Emetric.Ball x r' → ∀ (z : E), z ∈ Emetric.Ball x r' → ∥F y - F z - ⇑(P 1) (λ (_x : Fin 1), y - z)∥ ≤ C * LinearOrder.max ∥y - x∥ ∥z - x∥ * ∥y - z∥
{α : Type u_1} [TopologicalSpace α] {γ : Type u_4} [Linear_ordered_AddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] [has_Continuous_Add γ] {F g : α → γ} (hF : UpperSemicontinuous F) (hg : UpperSemicontinuous g) : UpperSemicontinuous (λ (z : α), F z + g z)
{α : Type u_1} {β : Type u_2} {m : Type u_5} [CommMonoid m] {F : α → m} {g : β → α} (hg : Function.Injective g) : finprod (λ (i : α), finprod (λ (h : i ∈ set.Range g), F i)) = finprod (λ (j : β), F (g j))
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {ι : Type u_1} {S : set ι} (B : Basis ↥S R m) (h : module.rank R m < Cardinal.aleph0) : S.Finite
{P : Real.Angle → Prop} (θ : Real.Angle) (h : ∀ (x : ℝ), P ↑x) : P θ
{α : Type u_1} {ι : sort u_3} [conditionally_CompleteLattice α] {F : ι → α} (h : BddBelow (set.Range F)) (C : ι) : infi F ≤ F C
{A : Type u_1} [CommRing A] [Algebra ℚ A] : PowerSeries.Exp A * ⇑PowerSeries.Eval_Neg_hom (PowerSeries.Exp A) = 1
{K : Type u_1} {n : ℕ} {g : GeneralizedContinuedFraction K} [DivisionRing K] {m : ℕ} : m ≤ n → g.continuants_aux m = (g.squash_gcf n).continuants_aux m
{n : ℕ} {P : Fin n → Prop} [Decidable_Pred P] {i : Fin n} (hi : i ∈ Fin.Find P) {j : Fin n} (hj : j < i) : ¬P j
{ιA : Type u_7} {ιB : Type u_8} [DecidableEq ιA] [DecidableEq ιB] [Fintype ιA] [Fintype ιB] {R' : Type u_9} {mᵢ : Type u_10} {N₁ : Type u_11} {N₂ : Type u_12} [CommSemiring R'] [AddCommGroup N₁] [module R' N₁] [AddCommGroup N₂] [module R' N₂] [AddCommMonoid mᵢ] [module R' mᵢ] (A : MultilinearMap R' (λ (_x : ιA), mᵢ) N₁) (B : MultilinearMap R' (λ (_x : ιB), mᵢ) N₂) : ↑(⇑MultilinearMap.alternatization A).Dom_Coprod ↑(⇑MultilinearMap.alternatization B) = Finset.Univ.Sum (λ (σA : Equiv.perm ιA), Finset.Univ.Sum (λ (σB : Equiv.perm ιB), ⇑Equiv.perm.sign σA • ⇑Equiv.perm.sign σB • (MultilinearMap.Dom_Dom_congr σA A).Dom_Coprod (MultilinearMap.Dom_Dom_congr σB B)))
{α : Type u} {l₁ l₂ : List α} (i : ℕ) : List.take (l₁.length + i) (l₁ ++ l₂) = l₁ ++ List.take i l₂
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x ⟶ Y} [CategoryTheory.Limits.HasCoequalizer F g] [CategoryTheory.Mono (CategoryTheory.Limits.coequalizerπ F g)] : F = g
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.EnoughProjectives C] [CategoryTheory.Abelian C] {x Y : C} (F : x ⟶ Y) : CategoryTheory.Exact (CategoryTheory.Projective.D F) F
{α : Type u} [AddGroup α] [has_LE α] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B C : α} : A + B ≤ C → A ≤ C - B
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {P : E × F} : ContDiff_at 𝕜 n Prod.Snd P
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LT.LT] {A B : α} (ha : A < 1) (hb : B < 1) : A * B < 1
{α : Type u} [CommSemiring α] (x y : α) (n : ℕ) : (Finset.Range n).Sum (λ (i : ℕ), (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n
{α : Type u_2} [DecidableEq α] {𝒜 : Finset (Finset α)} {m n : ℕ} (h𝒜 : IsAntichain HasSubset.Subset ↑𝒜) : Disjoint (𝒜.Slice m) (Finset.falling n 𝒜).shadow
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {t : Affine.Triangle ℝ P} (ho : t.orthocenter ∉ set.Range t.points) {P : Fin 3 → P} (hps : set.Range P ⊆ HasInsert.Insert t.orthocenter (set.Range t.points)) (hpi : Function.Injective P) : ∃ (C : P) (h : C ∈ affine_Span ℝ (set.Range t.points)), ∀ (P₁ : P), P₁ ∈ set.Range P → HasDist.dist P₁ C = Affine.Simplex.circumradius t
{R : Type u} [non_assoc_Semiring R] (S : Subsemiring R) : 1 ∈ S
(n P : ℕ) : Polynomial.Eval ↑n (Polynomial.bernoulli P.Succ) = bernoulli P.Succ + (↑P + 1) * (Finset.Range n).Sum (λ (k : ℕ), ↑k ^ P)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] {v : E} (hv : v ∈ Kᗮ) : ⇑(Orthogonal_projection K) v = 0
(R : Type u_1) [CommRing R] (n : ℕ) : (Finset.Range (n + 1)).Sum (λ (ν : ℕ), (n • Polynomial.x - ↑ν) ^ 2 * bernstein_Polynomial R n ν) = n • Polynomial.x * (1 - Polynomial.x)
{R : Type u} [EuclideanDomain R] [DecidableEq R] (A B : R) : EuclideanDomain.Gcd A B = A * EuclideanDomain.Gcd_A A B + B * EuclideanDomain.Gcd_B A B
{α : Type u} [has_Mul α] : _Mul_hom Id
{P x : ℝ} {r : ℚ} (h : LiouvilleWith P x) (hr : r ≠ 0) : LiouvilleWith P (x * ↑r)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (E : D ⥤ C) [CategoryTheory.IsEquivalence E] [CategoryTheory.Limits.HasLimits_of_size C] : CategoryTheory.Limits.HasLimits_of_size D
(k : Type u_1) {v : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Fintype ι] (P : ι → P) {n : ℕ} (hc : Fintype.Card ι = n + 2) : Finite_dimensional.finrank k ↥(Vector_Span k (set.Range P)) ≤ n ↔ ¬AffineIndependent k P
{α : Type u_1} [PseudoEmetricSpace α] {F : ℕ → α} (D : ℕ → Nnreal) (hF : ∀ (n : ℕ), HasEdist.edist (F n) (F n.Succ) ≤ ↑(D n)) (hD : Summable D) : Cauchy_Seq F
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.SimplicialObject C) {n : ℕ} {i : Fin (n + 2)} : x.δ (⇑Fin.cast_Succ i) ≫ x.δ i = x.δ i.Succ ≫ x.δ i
{α : Type u} [Semiring α] : _Semiring_hom Id
{ι : sort u_1} {F : ι → Ennreal} {x : Ennreal} (h0 : x ≠ 0) (h : x ≠ ⊤) : infi F * x = ⨅ (i : ι), F i * x
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {C : E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set ℝ} [IntervalIntegral.FTC_Filter A (nhds_within A S) (nhds_within A t)] (hmeas : StronglyMeasurableAtFilter F (nhds_within A t) MeasureTheory.MeasureSpace.Volume) (ha : Filter.Tendsto F (nhds_within A t ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) (hs : UniqueDiffWithinAt ℝ S A . "UniqueDiffWithinAt_ici_Iic_Univ") : deriv_within (λ (u : ℝ), ∫ (x : ℝ) in u..B, F x) S A = -C
{k : Type u₁} {G : Type u₂} [CommSemiring k] [Monoid G] {A : Type u₃} [Semiring A] [Algebra k A] (F : Monoid_Algebra k G →ₐ[k] A) (F : Monoid_Algebra k G) : ⇑F F = Finsupp.Sum F (λ (A : G) (B : k), B • ⇑F (Finsupp.single A 1))
{α : Type u_1} [CommSemiring α] : fib_rec._solution (λ (x : ℕ), ↑(Nat.fib x))
{v : Type u} [CategoryTheory.Category v] [CategoryTheory.Limits.HasImages v] [CategoryTheory.Limits.has_Zero_object v] [CategoryTheory.Preadditive v] [CategoryTheory.Limits.HasKernels v] [CategoryTheory.Limits.HasCokernels v] {A₁ B₁ C₁ A₂ B₂ C₂ : v} (F₁ : A₁ ⟶ B₁) (g₁ : B₁ ⟶ C₁) (F₂ : A₂ ⟶ B₂) (g₂ : B₂ ⟶ C₂) (α : A₁ ≅ A₂) (β : B₁ ≅ B₂) (γ : C₁ ≅ C₂) (hsq₁ : α.hom ≫ F₂ = F₁ ≫ β.hom) (hsq₂ : β.hom ≫ g₂ = g₁ ≫ γ.hom) (h : CategoryTheory.Exact F₁ g₁) : CategoryTheory.Exact F₂ g₂
{R : Type u_1} {m : Type u_2} [CommSemiring R] [AddCommMonoid m] [module R m] : module._torsion R ↥(Submodule.torsion R m)
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {S : set α} (hs : IsCompact S) {t : set β} (ht : IsCompact t) {n : set (α × β)} (hn : IsOpen n) (hp : S ×ˢ t ⊆ n) : ∃ (u : set α) (v : set β), IsOpen u ∧ IsOpen v ∧ S ⊆ u ∧ t ⊆ v ∧ u ×ˢ v ⊆ n
{α : Type u_1} [LinearOrder α] [SuccOrder α] [IsSuccArchimedean α] (r : α → α → Prop) {n m : α} (h1 : ∀ (i : α), i ∈ set.Ico n m → r i (Order.Succ i)) (h2 : ∀ (i : α), i ∈ set.Ico m n → r (Order.Succ i) i) (hnm : n ≠ m) : Relation.TransGen r n m
(B C : ℝ) (n : ℕ) (hb : 0 ≠ B) : Filter.Tendsto (λ (x : ℝ), x ^ n / (B * Real.Exp x + C)) Filter.at_top (nhds 0)
{α : Type u_1} {β : Type u_2} [Fintype α] [Fintype β] (h : Fintype.Card β < Fintype.Card α) : IsEmpty (α ↪ β)
(A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) [Nontrivial B] : minpoly A x ≠ 1
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_NormedGroup E'] [semi_NormedGroup F'] {F' : α → E'} {g' : α → F'} {l : Filter α} : ((λ (x : α), ∥F' x∥) =o[l] λ (x : α), ∥g' x∥) → F' =o[l] g'
{R : Type u} {m : Type v} {m₂ : Type W} {m₃ : Type y} [Ring R] [AddCommGroup m] [AddCommGroup m₂] [AddCommGroup m₃] [module R m] [module R m₂] [module R m₃] {F : m →ₗ[R] m₂} {g : m →ₗ[R] m₃} (h : F.Ker ⊔ g.Ker = ⊤) : (F.Prod g).Range = F.Range.Prod g.Range
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {C : E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set ℝ} [IntervalIntegral.FTC_Filter A (nhds_within A S) (nhds_within A t)] (hmeas : StronglyMeasurableAtFilter F (nhds_within A t) MeasureTheory.MeasureSpace.Volume) (ha : Filter.Tendsto F (nhds_within A t ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) : HasDerivWithinAt (λ (u : ℝ), ∫ (x : ℝ) in u..B, F x) (-C) S A
{𝕂 : Type u_6} [_R_or_C 𝕂] {E' : Type u_7} [NormedGroup E'] [NormedSpace 𝕂 E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] [CompleteSpace E'] {F : E' → F'} {F' : E' ≃L[𝕂] F'} {A : E'} {n : WithTop ℕ} (hF : ContDiff_at 𝕂 n F A) (hF' : HasFderivAt F ↑F' A) (hn : 1 ≤ n) : ContDiff_at 𝕂 n (hF.local_Inverse hF' hn) (F A)
{β : Type u_2} [TopologicalSpace β] {κ : Type u_5} {F : κ → β} (hF : Function.Surjective F) : DenseRange F
{C : Type u} [CategoryTheory.Category C] {D : Type u_1} [CategoryTheory.Category D] [CategoryTheory.Abelian C] [CategoryTheory.HasInjectiveResolutions C] [CategoryTheory.Abelian D] (F : C ⥤ D) [F.Additive] (n : ℕ) {x Y : C} (F : Y ⟶ x) {P : CategoryTheory.InjectiveResolution x} {q : CategoryTheory.InjectiveResolution Y} (g : q.cocomplex ⟶ P.cocomplex) (W : q.ι ≫ g = (cochain_Complex.single₀ C).Map F ≫ P.ι) : (F.Right_derived n).Map F = (F.Right_derived_obj_iso n q).hom ≫ (homology_Functor D (ComplexShape.Up ℕ) n).Map ((F.Map_homological_Complex (ComplexShape.Up ℕ)).Map g) ≫ (F.Right_derived_obj_iso n P).Inv
{R : Type u_1} [Ring R] [strong_RankCondition R] (n : ℕ) {m : ℕ} (v : Fin m → Fin n → R) : LinearIndependent R v → m ≤ n
{α : Type u_1} [AddCommGroup α] [TopologicalSpace α] [topological_AddGroup α] [t2_Space α] (F : ℕ → α) : Filter.Tendsto (λ (i : ℕ), ∑' (k : ℕ), F (k + i)) Filter.at_top (nhds 0)
{α : Type u_1} [TopologicalSpace α] {x : α} {S : set α} {γ : Type u_4} [Linear_ordered_AddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] {F g : α → γ} (hF : UpperSemicontinuous_within_at F S x) (hg : UpperSemicontinuous_within_at g S x) (hcont : Continuous_at (λ (P : γ × γ), P.fst + P.Snd) (F x, g x)) : UpperSemicontinuous_within_at (λ (z : α), F z + g z) S x
{R : Type u_3} {A : Type u_5} [CommRing R] [CommRing A] [Algebra R A] {n : ℕ} (h : ∀ (S : Finset A), AlgebraicIndependent R (λ (i : ↥S), ↑i) → S.Card ≤ n) (S : set A) : AlgebraicIndependent R Coe → Cardinal.Mk ↥S ≤ ↑n
{α : Type u} [UniformSpace α] [(Uniformity α)._countably_generated] (h' : ∀ (u : ℕ → α), Cauchy_Seq u → (∃ (A : α), Filter.Tendsto u Filter.at_top (nhds A))) : CompleteSpace α
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace ℝ P) [Nonempty ↥S] [CompleteSpace ↥(S.direction)] (P : P) : ⇑(EuclideanGeometry.reflection S) (⇑(EuclideanGeometry.reflection S) P) = P
(n : ℕ) : ↑(n.Succ) • Polynomial.bernoulli n = ⇑(Polynomial.monomial n) ↑(n.Succ) - (Finset.Range n).Sum (λ (k : ℕ), ↑((n + 1).choose k) • Polynomial.bernoulli k)
{R : Type u_1} {m : Type u_5} {n : Type u_14} [CommRing R] [AddCommGroup m] [module R m] [no_Zero_divisors R] {B : m →ₗ[R] m →ₗ[R] R} (v : Basis n R m) (hO : B._Ortho ⇑v) (h : ∀ (i : n), ¬B.IsOrtho (⇑v i) (⇑v i)) : B.separating_Left
(R : Type u) [Ring R] [strong_RankCondition R] (m n : Type v) [Fintype m] [Fintype n] : module.rank R (Matrix m n R) = (Cardinal.Mk m * Cardinal.Mk n).Lift
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LE.LE] {A B : α} (ha : 0 ≤ A) (hb : 0 ≤ B) : 0 ≤ A + B
{m : Type u_1} [Semigroup m] [TopologicalSpace m] [t2_Space m] (Continuous_Mul_Left : ∀ (r : m), Continuous (λ (_x : m), _x * r)) (S : set m) (snemp : S.Nonempty) (S_IsCompact : IsCompact S) (S_Add : ∀ (x : m), x ∈ S → ∀ (y : m), y ∈ S → x * y ∈ S) : ∃ (m : m) (h : m ∈ S), m * m = m
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [Finite_dimensional R m] (x : Orientation R m ι) (F : m ≃ₗ[R] m) (h : Fintype.Card ι = Finite_dimensional.finrank R m) : ⇑(Orientation.Map ι F) x = -x ↔ ⇑LinearMap.det ↑F < 0
{α : Type u_1} [non_unital_semi_NormedRing α] (x y : α) : ∥⇑(AddMonoid_hom.Mul_Left x) y∥ ≤ ∥x∥ * ∥y∥
{α : Type u_1} [LinearOrder α] {r S : α} : {r}.to_colex < {S}.to_colex ↔ r < S
{x : top} (F : top.Presheaf (CategoryTheory.Discrete PUnit) x) : F._sheaf
{α : Type u} [TopologicalSpace α] {S t : set α} (ht : IsCompact t) (hs : IsClosed S) : IsCompact (S ∩ t)
{n : ℕ} [Fact (0 < n)] : Fintype.Card (dihedral_Group n) = 2 * n
{α : Type u} [TopologicalSpace α] [LocallyCompactSpace α] {K : set α} (hK : IsCompact K) : ∃ (K' : set α), IsCompact K' ∧ K ⊆ Interior K'
{α : Type u_1} {G : Type u_4} [division_CommMonoid G] {F g : α → G} (hF : (Function.MulSupport F).Finite) (hg : (Function.MulSupport g).Finite) : finprod (λ (i : α), F i / g i) = finprod (λ (i : α), F i) / finprod (λ (i : α), g i)
{β : Type u} {α : Type v} {S : Finset α} [AddCommMonoid β] (F : α → β) {P : α → Prop} [Decidable_Pred P] : (Finset.Subtype P S).Sum (λ (x : Subtype P), F ↑x) = (Finset.Filter P S).Sum (λ (x : α), F x)
{α : Type u_3} {β : Type u_4} [SemilatticeSup α] [SemilatticeSup β] {F : α → β} (g : β → α) (B' : β) (hF : Monotone F) (gc : ∀ (A : α) (B : β), B ≥ B' → (F A ≤ B ↔ A ≤ g B)) (hgi : ∀ (B : β), B ≥ B' → B ≤ F (g B)) : Filter.Map F Filter.at_top = Filter.at_top
{α : Type u} [Linear_ordered_Ring α] (A B C : α) : 0 ≤ A * B ∨ 0 ≤ B * C ∨ 0 ≤ C * A
{R : Type u_1} {S : Type u_2} (L : Type u_4) [EuclideanDomain R] [CommRing S] [IsDomain S] [Field L] [algRL : Algebra R L] [Algebra R S] [Algebra S L] [ist : IsScalarTower R S L] [Iic : IsIntegral_Closure S R L] {abv : AbsoluteValue R ℤ} {ι : Type u_5} [DecidableEq ι] [Fintype ι] (bS : Basis ι R S) (adm : abv._Admissible) [Infinite R] [DecidableEq R] (h : Algebra.IsAlgebraic R L) (A : S) {B : S} (hb : B ≠ 0) : ∃ (q : S) (r : R) (h : r ∈ class_Group.Finset_approx bS adm), ⇑abv (⇑(Algebra.norm R) (r • A - q * B)) < ⇑abv (⇑(Algebra.norm R) B)
{γ : Type W} [SemilatticeSup γ] {S t : set γ} : BddAbove S → BddAbove t → BddAbove (S ∪ t)
{γ : Type W} [SemilatticeInf γ] {S t : set γ} : BddBelow (S ∪ t) ↔ BddBelow S ∧ BddBelow t
{t : Type u} [CategoryTheory.Category t] {x Y : t} (i : x ≅ Y) (P : CategoryTheory.Arrow t) (sq : CategoryTheory.Arrow.Mk i.hom ⟶ P) : i.Inv ≫ sq.Left ≫ P.hom = sq.Right
{α : Type u} [Monoid_with_Zero α] (x : α) [Invertible x] : Ring.Inverse x = ⅟ x
(n : ℕ+) (A : Type W) (B : Type z) [CommRing A] [CommRing B] [Algebra A B] [IsCyclotomicExtension {n} A B] [IsDomain B] [Ne_Zero ↑↑n] : IsPrimitiveRoot (IsCyclotomicExtension.zeta n A B) ↑n
{α : Type u_1} [TopologicalSpace α] {x : α} {γ : Type u_4} [Linear_ordered_AddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] {F g : α → γ} (hF : LowerSemicontinuousAt F x) (hg : LowerSemicontinuousAt g x) (hcont : Continuous_at (λ (P : γ × γ), P.fst + P.Snd) (F x, g x)) : LowerSemicontinuousAt (λ (z : α), F z + g z) x
(R : Type u) [Ring R] [strong_RankCondition R] {ι : Type v} [Fintype ι] : Finite_dimensional.finrank R (ι → R) = Fintype.Card ι
{α : Type u} {β : Type v} [DecidableEq β] {S : Finset α} {t : Finset β} {F : α → β} {n : ℕ} (hn : S.Card < t.Card * n) : ∃ (y : β) (h : y ∈ t), (Finset.Filter (λ (x : α), F x = y) S).Card < n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] [CategoryTheory.Limits.HasEqualizers C] : CategoryTheory.Limits.HasLimits C
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P₂ : ι → P) (P₁ : P) (h : S.Sum (λ (i : ι), W i) = 0) : S.Sum (λ (i : ι), W i • (P₁ -ᵥ P₂ i)) = -⇑(S.weighted_vsub P₂) W
(m : Type u_1) (α : Type u_2) [Group m] [MulAction m α] {S t : set α} : fixing_Subgroup m (S ∪ t) = fixing_Subgroup m S ⊓ fixing_Subgroup m t
(C : Type u) [CategoryTheory.Category C] [∀ {x Y : C}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair x Y)] : CategoryTheory.Limits.HasBinaryProducts C
{x : Type u_1} [tX : TopologicalSpace x] {S t : set x} (ts : t ⊆ S) : Subtype.TopologicalSpace = TopologicalSpace.induced (set.inclusion ts) Subtype.TopologicalSpace
{P : ℕ} (q : ℚ) : padic_val_rat P (-q) = padic_val_rat P q
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S1 S2 : AffineSubspace k P} (h1 : ↑S1.Nonempty) (h2 : ↑S2.Nonempty) (hD : _IsCompl S1.direction S2.direction) : ∃ (P : P), ↑S1 ∩ ↑S2 = {P}
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_Ring 𝕜] [AddCommGroup E] [AddCommGroup F] [module 𝕜 E] [module 𝕜 F] {x : E} (F : E →ᵃ[𝕜] F) {S : set F} (hs : Star_Convex 𝕜 (⇑F x) S) : Star_Convex 𝕜 x (⇑F ⁻¹' S)
{F : ℕ → ℝ} (hfa : Antitone F) (hF0 : Filter.Tendsto F Filter.at_top (nhds 0)) : ∃ (l : ℝ), Filter.Tendsto (λ (n : ℕ), (Finset.Range (n + 1)).Sum (λ (i : ℕ), (-1) ^ i * F i)) Filter.at_top (nhds l)
{ι : Type u} {γ : Type W} [dec : DecidableEq ι] (P : ι → Prop) [Decidable_Pred P] [AddCommMonoid γ] (S : ι → Add_Submonoid γ) : (⨆ (i : ι) (h : P i), S i) = ((Dfinsupp.Sum_Add_hom (λ (i : ι), (S i).Subtype)).Comp (Dfinsupp.Filter_AddMonoid_hom (λ (i : ι), ↥(S i)) P)).mrange
{α : Type u_1} {P : α → Prop} [Decidable_Pred P] {S : Finset α} (h : ∀ (x : α), x ∈ S → ¬P x) : Finset.Filter P S = ∅
{A B : ℕ} (W : A ∣ B) (h : B < A) : B = 0
{K : Type u_1} {v : K} {n : ℕ} [Linear_ordered_Field K] [FloorRing K] : (GeneralizedContinuedFraction.of v).denominators n ≤ (GeneralizedContinuedFraction.of v).denominators (n + 1)
{S : Type u_1} [has_Add S] {A B : S} (h : Add_Commute A B) : A + B = B + A
{P : Ennreal} [Fact (1 ≤ P)] (hp : P ≠ ⊤) : (Submodule.Span ℂ (set.Range (fourier_Lp P))).topological_Closure = ⊤
{α : Type u_1} [has_LE α] {S : set αᵒᵈ} : _lower_set S → _upper_set (⇑order_dual.to_dual ⁻¹' S)
{α : Type u} {γ : Type u_1} [TopologicalSpace γ] [t2_Space γ] [CompactSpace γ] {F : α → γ} {B : Ultrafilter α} {C : γ} : Ultrafilter.extend F B = C ↔ ↑(Ultrafilter.Map F B) ≤ nhds C
{n : ℕ} (hpos : 0 < n) {P : ℕ} [Fact (Nat.Prime P)] {A : ℕ} (hroot : (Polynomial.cyclotomic n (Zmod P))._root (⇑(Nat.cast_Ring_hom (Zmod P)) A)) : order_of (Zmod.Unit_of_IsCoprime A _) ∣ n
 : fib_rec._solution (has_Pow.Pow GoldenRatio)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {y : E} {α : Type u_3} (l : Filter α) {C : α → 𝕜} {D : α → E} (hc : Filter.Tendsto (λ (n : α), ∥C n∥) l Filter.at_top) (hD : Filter.Tendsto (λ (n : α), C n • D n) l (nhds y)) : Filter.Tendsto D l (nhds 0)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {x : top} (F : top.Presheaf C x) (U : TopologicalSpace.Opens ↥x) (R : CategoryTheory.Presieve U) : CategoryTheory.presheaf.second_Map R F ≫ (top.Presheaf.covering_of_Presieve.second_obj_iso_Pi_inters F U R).hom = (top.Presheaf.covering_of_Presieve.FirstObj_iso_Pi_Opens F U R).hom ≫ top.Presheaf.sheaf_condition_Equalizer_products.Right_res F (top.Presheaf.covering_of_Presieve U R)
{α : Type u} [PseudoMetricSpace α] {S : set α} (hs : S.Nonempty) {C : ℝ} (h : ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → HasDist.dist x y ≤ C) : Metric.diam S ≤ C
{m : ℝ} {F : ℕ → ℕ} (hm : 1 < m) (fi : ∀ (i : ℕ), i ≤ F i) : Summable (λ (i : ℕ), 1 / m ^ F i)
{α : Type u} {β : Type v} {S : set α} {t : set β} {F : α → β} {F' : β → α} (h : set.Inv_on F' F S t) (hF : set.maps_to F S t) (hF' : set.maps_to F' t S) : set.bij_on F S t
{α : Type u_1} {ι : Type u_3} {ι' : Type u_4} [Distrib_Lattice α] [OrderBot α] [DecidableEq ι] {S : Finset ι'} {g : ι' → Finset ι} {F : ι → α} (hs : S.Sup_indep (λ (i : ι'), (g i).Sup F)) (hg : ∀ (i' : ι'), i' ∈ S → (g i').Sup_indep F) : (S.Sup g).Sup_indep F
{𝕂 : Type u_1} {𝔸 : Type u_2} [nondiscrete_NormedField 𝕂] [NormedRing 𝔸] [normed_Algebra 𝕂 𝔸] [CompleteSpace 𝔸] [CharZero 𝕂] {x y : 𝔸} (hxy : Commute x y) (hx : x ∈ Emetric.Ball 0 (Exp_series 𝕂 𝔸).radius) (hy : y ∈ Emetric.Ball 0 (Exp_series 𝕂 𝔸).radius) : Exp 𝕂 (x + y) = Exp 𝕂 x * Exp 𝕂 y
(n A : ℕ) (P : ℕ → Prop) [Decidable_Pred P] (pp : Function.Periodic P A) : (Finset.Filter P (Finset.Ico n (n + A))).Card = Nat.count P A
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : LocalHomeomorph α β} {S : set α} {t : set β} : e._image S t → e.to_local_Equiv.Target ∩ ⇑(e.Symm) ⁻¹' (e.to_local_Equiv.Source ∩ S) = e.to_local_Equiv.Target ∩ t
{K : Type v} [Field K] {P : Polynomial K} (hmo : P.monic) (hP : Polynomial.Splits (Ring_hom.Id K) P) : P.next_Coeff = -P.roots.Sum
{α : Type u} [PseudoMetricSpace α] {x : α} {r : ℝ} : Metric.Bounded (Metric.Ball x r)
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [nondiscrete_NormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (F : MultilinearMap 𝕜 E G) {C : ℝ} (hC : 0 ≤ C) (h : ∀ (m : Π (i : ι), E i), ∥⇑F m∥ ≤ C * Finset.Univ.Prod (λ (i : ι), ∥m i∥)) (m₁ m₂ : Π (i : ι), E i) : ∥⇑F m₁ - ⇑F m₂∥ ≤ C * Finset.Univ.Sum (λ (i : ι), Finset.Univ.Prod (λ (j : ι), Ite (j = i) ∥m₁ i - m₂ i∥ (LinearOrder.max ∥m₁ j∥ ∥m₂ j∥)))
{α : Type u_1} {β : Type u_2} {e : local_Equiv α β} {S : set α} {t : set β} : e.Target ∩ ⇑(e.Symm) ⁻¹' S = e.Target ∩ t → e._image S t
(R : Type u_1) [CommRing R] (m : Type u_2) [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] [Nontrivial R] : (LinearMap.trace R m).Comp (dual_tensor_hom R m m) = contract_Left R m
{α : Type u_1} [DecidableEq α] [Fintype α] {𝒜 : Finset (Finset α)} {S : Finset α} : S ∈ 𝒜.Up_shadow ↔ ∃ (t : Finset α) (h : t ∈ 𝒜) (A : α) (h : A ∉ t), HasInsert.Insert A t = S
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (F : α ≃ₜ β) (K : TopologicalSpace.Compacts α) : (⇑(TopologicalSpace.Compacts.Equiv F) K).carrier = ⇑(F.Symm) ⁻¹' K.carrier
{α : sort u_1} {β : sort u_2} {γ : out_param (sort u_3)} [has_Coe α β] [has_Coe_ToFun β (λ (_x : β), γ)] (x : α) : ⇑x = ⇑↑x
{A B : ℕ} (ha : A ≠ 0) (hb : B ≠ 0) : (A * B).Factors.to_Finset = A.Factors.to_Finset ∪ B.Factors.to_Finset
{α : Type u_1} [Preorder α] {A B : α} (h : A ≤ B) : set.ioi B ⊆ set.ioi A
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommMonoid β] [module 𝕜 E] [module 𝕜 β] [LinearOrder E] {S : set E} {F : E → β} (hs : Convex 𝕜 S) (hF : ∀ ⦃x y : E⦄, x ∈ S → y ∈ S → x < y → ∀ ⦃A B : 𝕜⦄, 0 < A → 0 < B → A + B = 1 → F (A • x + B • y) < A • F x + B • F y) : strict_Convex_on 𝕜 S F
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {F : α → β} {S : set α} : Antitone_on F S → Monotone_on (F ∘ ⇑order_dual.of_dual) S
{α : Type u_1} [circular_Preorder α] {A B C : α} (h : HasSbtw.Sbtw A B C) : HasSbtw.Sbtw B C A
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {C : E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (ha : Filter.Tendsto F (nhds A ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) : HasDerivAt (λ (u : ℝ), ∫ (x : ℝ) in u..B, F x) (-C) A
{α : Type u_1} {R : Type u_2} {l : Filter α} {F : α → R} {r : R} [Linear_ordered_Ring R] [Archimedean R] (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_IsBot) : Filter.Tendsto (λ (x : α), F x * r) l Filter.at_IsBot
{n : ℕ+} (h1 : n ≠ 1) : ∃ (k : ℕ+), n = k + 1
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} {S : set E} : DifferentiableOn 𝕜 F S → Mdifferentiable_on (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F S
{K : Type u} {v : Type v} [Field K] [AddCommGroup v] [module K v] [Finite_dimensional K v] (S : Submodule K v) : Finite_dimensional.finrank K (v ⧸ S) + Finite_dimensional.finrank K ↥S = Finite_dimensional.finrank K v
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (e : LocalHomeomorph α β) {F : β → γ} {S : set β} {x : β} (h : x ∈ e.to_local_Equiv.Target) : Continuous_within_at F S x ↔ Continuous_within_at (F ∘ ⇑e) (⇑e ⁻¹' S) (⇑(e.Symm) x)
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] {x : B} [Nontrivial A] (hx : IsIntegral A x) : minpoly A x ≠ 0
{α : Type u_1} {β : Type u_2} {S : set α} {t : α → set β} {x : α} {y : β} (xs : x ∈ S) (ytx : y ∈ t x) : y ∈ ⋃ (x : α) (h : x ∈ S), t x
(P : ℕ) {Idx : Type u_2} [hp : Fact (Nat.Prime P)] (Φ : mv_Polynomial Idx ℚ) (n : ℕ) : witt_structure_rat P Φ n = ⇑mv_Polynomial.C (1 / ↑P ^ n) * (⇑(mv_Polynomial.Bind₁ (λ (B : Idx), ⇑(mv_Polynomial.Rename (λ (i : ℕ), (B, i))) (witt_Polynomial P ℚ n))) Φ - (Finset.Range n).Sum (λ (i : ℕ), ⇑mv_Polynomial.C (↑P ^ i) * witt_structure_rat P Φ i ^ P ^ (n - i)))
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [strict_Convex_Space ℝ E] {x y z : E} {A B r : ℝ} (hx : x ∈ metric.IsClosed_ball z r) (hy : y ∈ metric.IsClosed_ball z r) (hne : x ≠ y) (ha : 0 < A) (hb : 0 < B) (hab : A + B = 1) : A • x + B • y ∈ Metric.Ball z r
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {F : α → β × γ} {x : α} (hF : Continuous_at F x) : Continuous_at (λ (A : α), (F A).Snd) x
{k : Type u_1} {v1 : Type u_2} {P1 : Type u_3} {v2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] [AddCommGroup v2] [module k v2] [AddTorsor v2 P2] (F : P1 →ᵃ[k] P2) (P : P1) (v : v1) : ⇑F (v +ᵥ P) = ⇑(F.Linear) v +ᵥ ⇑F P
{R : Type u_1} {R₁ : Type u_2} {R₂ : Type u_3} {m₁ : Type u_6} {m₂ : Type u_7} [CommSemiring R] [CommSemiring R₁] [AddCommMonoid m₁] [module R₁ m₁] [CommSemiring R₂] [AddCommMonoid m₂] [module R₂ m₂] {i₁ : R₁ →+* R} {i₂ : R₂ →+* R} {B : m₁ →ₛₗ[i₁] m₂ →ₛₗ[i₂] R} : B.separating_Right ↔ B.Flip.Ker = ⊥
{C : Type u₁} [CategoryTheory.Category C] {x Y : C} (F : x ⟶ Y) [CategoryTheory.RegularMono F] [e : CategoryTheory.Epi F] : CategoryTheory.IsIso F
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [InnerProductSpace 𝕜 G] [Finite_dimensional 𝕜 E] [Finite_dimensional 𝕜 F] [Finite_dimensional 𝕜 G] (A : F →ₗ[𝕜] G) (B : E →ₗ[𝕜] F) : ⇑LinearMap.Adjoint (A.Comp B) = (⇑LinearMap.Adjoint B).Comp (⇑LinearMap.Adjoint A)
{G : Type u_1} [comm_Group G] : Group.nilpotency_class G ≤ 1
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B : α} : -A < B → -B < A
{F : Type u_3} [InnerProductSpace ℝ F] {ι₁ : Type u_1} {S₁ : Finset ι₁} {W₁ : ι₁ → ℝ} (v₁ : ι₁ → F) (h₁ : S₁.Sum (λ (i : ι₁), W₁ i) = 0) {ι₂ : Type u_2} {S₂ : Finset ι₂} {W₂ : ι₂ → ℝ} (v₂ : ι₂ → F) (h₂ : S₂.Sum (λ (i : ι₂), W₂ i) = 0) : HasInner.inner (S₁.Sum (λ (i₁ : ι₁), W₁ i₁ • v₁ i₁)) (S₂.Sum (λ (i₂ : ι₂), W₂ i₂ • v₂ i₂)) = -S₁.Sum (λ (i₁ : ι₁), S₂.Sum (λ (i₂ : ι₂), W₁ i₁ * W₂ i₂ * (∥v₁ i₁ - v₂ i₂∥ * ∥v₁ i₁ - v₂ i₂∥))) / 2
{E : Type u_2} [semi_NormedGroup E] [NormedSpace ℝ E] {S : set E} (hs : Convex ℝ S) : Convex_on ℝ S HasNorm.norm
{α : Type u_1} [has_LT α] {A B : α} : A ⋖ B → ⇑order_dual.to_dual B ⋖ ⇑order_dual.to_dual A
{R S : Type u} [CommRing R] [CommRing S] (m : Submonoid R) (S' : Type u) [CommRing S'] [Algebra S S'] [Algebra R S] [Algebra R S'] [IsScalarTower R S S'] [IsLocalization (Submonoid.Map ↑(Algebra_Map R S) m) S'] (x : S) (S : Finset S') (hx : ⇑(Algebra_Map S S') x ∈ Algebra.Adjoin R ↑S) : ∃ (m : ↥m), m • x ∈ Algebra.Adjoin R ↑(IsLocalization.Finset_integer_multiple (Submonoid.Map ↑(Algebra_Map R S) m) S)
{ι : Type u_1} {m : Type u_4} {N : Type u_5} [AddCommMonoid m] [ordered_AddCommMonoid N] (F : m → N) (P : m → Prop) (h_One : F 0 = 0) (h_Mul : ∀ (x y : m), P x → P y → F (x + y) ≤ F x + F y) (hp_Mul : ∀ (x y : m), P x → P y → P (x + y)) (g : ι → m) {S : Finset ι} (hs : ∀ (i : ι), i ∈ S → P (g i)) : F (S.Sum (λ (i : ι), g i)) ≤ S.Sum (λ (i : ι), F (g i))
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] (F : S.Localization_Map N) : F.of_Add_Equiv_of_Dom _ = F
(n : ℕ) (R : Type u_1) (hpos : 0 < n) [Ring R] [Nontrivial R] : 0 < (Polynomial.cyclotomic n R).degree
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} {S t : set α} (hst : Disjoint S t) (hs : (S ∩ Function.Support F).Finite) (ht : (t ∩ Function.Support F).Finite) : finsum (λ (i : α), finsum (λ (h : i ∈ S ∪ t), F i)) = finsum (λ (i : α), finsum (λ (h : i ∈ S), F i)) + finsum (λ (i : α), finsum (λ (h : i ∈ t), F i))
{𝕜 : Type u_3} {E : Type u_4} [NormedField 𝕜] [AddCommGroup E] [NormedSpace ℝ 𝕜] [module 𝕜 E] [module ℝ E] [IsScalarTower ℝ 𝕜 E] (P : Seminorm 𝕜 E) (x : E) (r : ℝ) : Convex ℝ (P.ball x r)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : HasInner.inner (x + y) (x + y) + HasInner.inner (x - y) (x - y) = 2 * (HasInner.inner x x + HasInner.inner y y)
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) {x Y : C} (F : Y ⟶ x) (S : CategoryTheory.Sieve x) : J₁.close (CategoryTheory.Sieve.pullback F S) = CategoryTheory.Sieve.pullback F (J₁.close S)
{α : Type u_2} [Bornology α] {S : set α} : Bornology._cobounded Sᶜ → Bornology._bounded S
{P : ℕ} [hp : Fact (Nat.Prime P)] (x : witt_Vector P (Zmod P)) : ⇑witt_Vector.verschiebung x = x * ↑P
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} {S₁ S₂ : Affine.Simplex ℝ P n} (h : set.Range S₁.points = set.Range S₂.points) : S₁.circumcenter = S₂.circumcenter
{𝕂 : Type u_1} {𝔸 : Type u_2} [_R_or_C 𝕂] [normed_CommRing 𝔸] [normed_Algebra 𝕂 𝔸] [CompleteSpace 𝔸] {x y : 𝔸} : Exp 𝕂 (x + y) = Exp 𝕂 x * Exp 𝕂 y
{n : ℕ} {α : Fin (n + 1) → Type u} (x : α 0) (P : Π (i : Fin n), α i.Succ) (z : α 0) : Function.update (Fin.Cons x P) 0 z = Fin.Cons z P
{ι : Type u_1} {α : ι → Type u_2} [Fintype ι] [DecidableEq ι] [Π (i : ι), DecidableEq (α i)] {P : (Π (i : ι), Finset (α i)) → Prop} (F : Π (i : ι), Finset (α i)) (h0 : P (λ (_x : ι), ∅)) (step : ∀ (g : Π (i : ι), Finset (α i)) (i : ι) (x : α i), x ∉ g i → P g → P (Function.update g i (HasInsert.Insert x (g i)))) : P F
{α : Type u_1} {β : Type u_2} [DecidableEq α] [DecidableEq β] (F : α → β) (S : Multiset α) (hF : Function.Injective F) (x : α) : Multiset.count (F x) (Multiset.Map F S) = Multiset.count x S
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K₁ K₂ : Submodule 𝕜 E} (h : K₁ ≤ K₂) : K₂ᗮ ≤ K₁ᗮ
{G : Type u_7} [comm_Group G] (L : List G) (n : ℕ) (A : G) : (L.update_nth n A).Prod = L.Prod * dite (n < L.length) (λ (hn : n < L.length), (L.nth_LE n hn)⁻¹ * A) (λ (hn : ¬n < L.length), 1)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} {P : ι → P} (hp : AffineIndependent k P) (j : ι) (W : ι → kˣ) : AffineIndependent k (λ (i : ι), ⇑(affine_Map.line_Map (P j) (P i)) ↑(W i))
{α : Type u_2} [DecidableEq α] [has_Inv α] {S : Finset α} : S⁻¹.Nonempty → S.Nonempty
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {E : Type W} [NormedGroup E] [NormedSpace 𝕜 E] {F : 𝕜 → F} {F' : F} (x : 𝕜) {S : set 𝕜} {l : F → E} {l' : F →L[𝕜] E} {t : set F} (hl : HasFderivWithinAt l l' t (F x)) (hF : HasDerivWithinAt F F' S x) (hst : set.maps_to F S t) : HasDerivWithinAt (l ∘ F) (⇑l' F') S x
{α : Type u} [PseudoMetricSpace α] (x y : α) : HasNndist.nndist x y = (HasEdist.edist x y).to_Nnreal
{m : Type u_1} (R : Type u_3) {S : Type u_4} [Fintype m] [DecidableEq m] [CommSemiring R] [CommSemiring S] [Algebra R S] (A : Matrix m m S) : ⇑((mv_Polynomial.aeval (λ (P : m × m), A P.fst P.Snd)).Map_Matrix) (Matrix.mv_Polynomial.x m m R) = A
{m₀ : Type u_1} [MulZeroOneClass m₀] : 0 = 1 ↔ Subsingleton m₀
{C : Cardinal} (h : Cardinal.aleph0 ≤ C) : C * C = C
{E : Type u_1} [NormedGroup E] {A : ℝ} {F g : ℂ → E} {l : Filter ℂ} (hBf : ∃ (C : ℝ) (h : C < A) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ l] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hBg : ∃ (C : ℝ) (h : C < A) (B : ℝ), g =O[Filter.comap Complex.Abs Filter.at_top ⊓ l] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) : ∃ (C : ℝ) (h : C < A) (B : ℝ), (F - g) =O[Filter.comap Complex.Abs Filter.at_top ⊓ l] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)
{α : Type u} {S t : set α} {l : Filter α} : (∀ᶠ (x : α) in l, x ∈ S ↔ x ∈ t) → S =ᶠ[l] t
{x Y : CompHaus} (F : x ⟶ Y) : IsClosed_Map ⇑F
{G : Type u_10} {h : Type u_11} [Group G] [division_Monoid h] (h : G ≃* h) (x y : G) : ⇑h (x / y) = ⇑h x / ⇑h y
{α : Type u_1} {β : Type u_2} {e e' : local_Equiv α β} (h : e ≈ e') : e.Source = e'.Source
{x : Type u} {α : Type v} [TopologicalSpace x] [LinearOrder α] [TopologicalSpace α] [order_IsClosed_topology α] {S : set x} (hs : IsPreconnected S) {A B : x} (ha : A ∈ S) (hb : B ∈ S) {F g : x → α} (hF : Continuous_on F S) (hg : Continuous_on g S) (ha' : F A ≤ g A) (hb' : g B ≤ F B) : ∃ (x : x) (h : x ∈ S), F x = g x
{z W : ℂ} (hz : 0 ≤ z.re ∨ z.im ≠ 0) (hw : 0 < W.re) : Continuous_at (λ (x : ℂ), x ^ W) z
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} {F' : ℝ → E} (hab : A ≤ B) (hcont : Continuous_on F (set.icc A B)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo A B → HasDerivAt F (F' x) x) (hint : IntervalIntegrable F' MeasureTheory.MeasureSpace.Volume A B) : ∫ (y : ℝ) in A..B, F' y = F B - F A
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {F : α → β → γ} {ta1 ta2 : TopologicalSpace α} {tb1 tb2 : TopologicalSpace β} {Tc1 : TopologicalSpace γ} (h : Continuous (λ (P : α × β), F P.fst P.Snd)) : Continuous (λ (P : α × β), F P.fst P.Snd)
{C : Type u₁} [CategoryTheory.SmallCategory C] {P₁ P₂ : Cᵒᵖ ⥤ Type u₁} (α : P₁ ⟶ P₂) (j : (P₁.Elements)ᵒᵖ) : (CategoryTheory.Cocone_of_representable P₁).ι.App j ≫ α = (CategoryTheory.Cocone_of_representable P₂).ι.App ((CategoryTheory.Category_of_Elements.Map α).Op.obj j)
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [NormalSpace Y] (F : C(x, ℝ)) (e : x → Y) (hE : IsClosed_Embedding e) : ∃ (g : C(Y, ℝ)), ⇑g ∘ e = ⇑F
{P : ℕ} (hp : Nat.Prime P) {n B : ℕ} : Nat.log P n < B → multiplicity P n.factorial = ↑((Finset.Ico 1 B).Sum (λ (i : ℕ), n / P ^ i))
(G : Type u_1) [Group G] : Group.IsNilpotent G ↔ ∃ (n : ℕ) (h : ℕ → Subgroup G), IsAscendingCentralSeries h ∧ h n = ⊤
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F g : α → m} {S : set α} (hs : S.Finite) : finprod (λ (i : α), finprod (λ (h : i ∈ S), F i * g i)) = finprod (λ (i : α), finprod (λ (h : i ∈ S), F i)) * finprod (λ (i : α), finprod (λ (h : i ∈ S), g i))
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [Finite_dimensional 𝕜 E] (t : E →ₗ[𝕜] E) (x : E) : 0 ≤ ⇑_R_or_C.re (HasInner.inner x (⇑(⇑LinearMap.Adjoint t * t) x))
(𝕜 : Type u_5) (E : Type u_6) [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [Nontrivial E] (C : ℝ) : ∃ (x : E), C < ∥x∥
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {S : set 𝕜} {n : WithTop ℕ} (hs : UniqueDiffOn 𝕜 S) : ContDiff_on 𝕜 n F S ↔ (∀ (m : ℕ), ↑m ≤ n → Continuous_on (iterated_deriv_within m F S) S) ∧ ∀ (m : ℕ), ↑m < n → DifferentiableOn 𝕜 (iterated_deriv_within m F S) S
{α : Type u} {β : Type v} [Preorder β] {F : α → β} {l : Filter α} {A : α} : IsMin_Filter F l A → IsMax_Filter (⇑order_dual.to_dual ∘ F) l A
{B : Type u_3} {S : B} {m : Type u_1} [AddCommMonoid m] [set_like B m] [Add_Submonoid_class B m] {ι : Type u_2} {t : Finset ι} {F : ι → m} (h : ∀ (C : ι), C ∈ t → F C ∈ S) : t.Sum (λ (C : ι), F C) ∈ S
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] [Nontrivial E] [Finite_dimensional ℂ E] {F : E → F} {U : set E} (hb : Metric.Bounded U) (hne : U.Nonempty) (hD : Diff_Cont_on_cl ℂ F U) : ∃ (z : E) (h : z ∈ Frontier U), IsMaxOn (HasNorm.norm ∘ F) (Closure U) z
{α : Type u_1} [CompleteLattice α] {A : α} {S : set α} : (⨆ (B : α) (h : B ∈ S), B ⊓ A) ≤ HasSup.Sup S ⊓ A
{α : Type u_3} [Linear_ordered_AddCommGroup α] : Filter.Tendsto HasAbs.Abs Filter.at_top Filter.at_top
{α : Type u_1} {β : Type u_2} [UniformSpace α] [AddGroup α] [uniform_AddGroup α] {hom : Type u_3} [UniformSpace β] [AddGroup β] [uniform_AddGroup β] [AddMonoid_hom_class hom α β] (F : hom) (hF : Continuous_at ⇑F 0) : uniform_Continuous ⇑F
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (P : P) (S1 S2 : AffineSubspace k P) : P ∈ S1 ⊓ S2 ↔ P ∈ S1 ∧ P ∈ S2
(n : ℕ) {m : ℝ} (m1 : 1 < m) : ∑' (i : ℕ), 1 / m ^ (i + (n + 1)).factorial < (1 - 1 / m)⁻¹ * (1 / m ^ (n + 1).factorial)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {v : ℝ → E → E} {K : Nnreal} (hv : ∀ (t : ℝ), LipschitzWith K (v t)) {F g : ℝ → E} {A B δ : ℝ} (hF : Continuous_on F (set.icc A B)) (hF' : ∀ (t : ℝ), t ∈ set.Ico A B → HasDerivWithinAt F (v t (F t)) (set.ici t) t) (hg : Continuous_on g (set.icc A B)) (hg' : ∀ (t : ℝ), t ∈ set.Ico A B → HasDerivWithinAt g (v t (g t)) (set.ici t) t) (ha : HasDist.dist (F A) (g A) ≤ δ) (t : ℝ) (h : t ∈ set.icc A B) : HasDist.dist (F t) (g t) ≤ δ * Real.Exp (↑K * (t - A))
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (W : ι → k) (P : ι → P) (B : P) {S₁ S₂ : Finset ι} (h : S₁ ⊆ S₂) : ⇑(S₁.weighted_vsub_of_point P B) W = ⇑(S₂.weighted_vsub_of_point P B) (↑S₁.indicator W)
{𝕜 : Type u_1} [_R_or_C 𝕜] {E : Type u_2} {E' : Type u_3} [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 E'] (F : E ≃ₗᵢ[𝕜] E') (K : Submodule 𝕜 E) [CompleteSpace ↥K] : reflection (Submodule.Map ↑(F.to_Linear_Equiv) K) = F.Symm.Trans ((reflection K).Trans F)
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] {β : Type u_1} {ι : β → Type u_3} [hι : Π (n : β), Encodable (ι n)] (D : ℝ) (S : set x) {l : Filter β} (r : β → Ennreal) (hr : Filter.Tendsto r l (nhds 0)) (t : Π (n : β), ι n → set x) (ht : ∀ᶠ (n : β) in l, ∀ (i : ι n), Emetric.diam (t n i) ≤ r n) (hst : ∀ᶠ (n : β) in l, S ⊆ ⋃ (i : ι n), t n i) : ⇑(MeasureTheory.Measure.hausdorff_measure D) S ≤ l.liminf (λ (n : β), ∑' (i : ι n), Emetric.diam (t n i) ^ D)
(R : Type u) [CommRing R] [IsDomain R] [discrete_Valuation_Ring R] : ∃ (ϖ : R), Prime ϖ
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (m : m) : ∥⇑(Quotient_AddGroup.Mk' S) m∥ ≤ ∥m∥
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P ⟶ q) [CategoryTheory.Mono F] : Function.Injective ⇑F
{L : FirstOrder.Language} {m : Type W} [L.structure m] (S : L.Substructure m) : ⇑(FirstOrder.Language.Substructure.Closure L) ↑S = S
{J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.IsCofiltered J] {F : J ⥤ Profinite} (C : CategoryTheory.Limits.Cone F) (hC : CategoryTheory.Limits.IsLimit C) {U : set ↥(C.x)} (hU : IsClopen U) : ∃ (j : J) (v : set ↥(F.obj j)) (hV : IsClopen v), U = ⇑(C.π.App j) ⁻¹' v
{m : Type u_2} [AddCommGroup m] {A : Type u_1} [CommRing A] [module A m] (F : m ≃ₗ[A] m) : IsUnit (⇑LinearMap.det ↑F)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : S -ᵥ S ⊆ ↑(Vector_Span k S)
{m : Type u_1} {R : Type u_4} [non_unital_non_assoc_Semiring R] [set_like m R] [MulMemClass m R] {S : m} {A B : R} (ha : A ∈ AddSubmonoid.Closure ↑S) (hb : B ∈ AddSubmonoid.Closure ↑S) : A * B ∈ AddSubmonoid.Closure ↑S
{α : Type u_1} [DecidableEq α] {𝒜 : Finset (Finset α)} {S : Finset α} : S ∈ 𝒜.shadow ↔ ∃ (t : Finset α) (h : t ∈ 𝒜), S ⊆ t ∧ t.Card = S.Card + 1
{R : Type u_2} [cancel_CommMonoid_with_Zero R] [Unique_factorization_Monoid R] [Nontrivial R] [normalization_Monoid R] [DecidableEq R] [dec_Dvd : Decidable_Rel has_Dvd.Dvd] {A B : R} (ha : Irreducible A) (hb : B ≠ 0) : multiplicity A B = ↑(Multiset.count (⇑normalize A) (Unique_factorization_Monoid.normalized_Factors B))
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] {ps : set P} (hps : ps ⊆ ↑S) (P : P) : (∃ (r : ℝ), ∀ (P1 : P), P1 ∈ ps → HasDist.dist P1 P = r) ↔ ∃ (r : ℝ), ∀ (P1 : P), P1 ∈ ps → HasDist.dist P1 ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P) = r
{𝕂 : Type u_1} {𝔸 : Type u_2} [_R_or_C 𝕂] [normed_CommRing 𝔸] [normed_Algebra 𝕂 𝔸] [CompleteSpace 𝔸] {ι : Type u_3} (S : Finset ι) (F : ι → 𝔸) : Exp 𝕂 (S.Sum (λ (i : ι), F i)) = S.Prod (λ (i : ι), Exp 𝕂 (F i))
{α : Type u} [PseudoEmetricSpace α] {x : α} {S t : set α} : Emetric.Inf_edist x (S ∪ t) = Emetric.Inf_edist x S ⊓ Emetric.Inf_edist x t
(x : ℝ) (h : Real.cos x ≠ 0) : deriv (λ (y : ℝ), Real.tan y - y) x = 1 / Real.cos x ^ 2 - 1
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {S : set E} {t : set F} {g : F → G} {F : E → F} (hg : ContDiff_on 𝕜 n g t) (hF : ContDiff_on 𝕜 n F S) (st : S ⊆ F ⁻¹' t) : ContDiff_on 𝕜 n (g ∘ F) S
{ι : Type u_1} {ι' : Type u_2} {R : Type u_5} {m : Type u_6} [CommSemiring R] [AddCommMonoid m] [module R m] [Fintype ι'] [Fintype ι] [DecidableEq ι] [DecidableEq ι'] (B : Basis ι R m) (v : ι' → m) (e : ι ≃ ι') : (B.reindex e).to_Matrix v = ⇑(Matrix.reindex_alg_Equiv R e) (B.to_Matrix (v ∘ ⇑e))
{x : Type u_2} [EmetricSpace x] (S : Finset x) : dimH ↑S = 0
{α : Type u} {F g : α → α} {x : α} (hF : Function.IsFixedPt F x) (h : Function.LeftInverse g F) : Function.IsFixedPt g x
{R : Type u} [CommRing R] [IsDomain R] [_principal_Ideal_Ring R] [Gcd_Monoid R] (A B : R) : ∃ (x y : R), Gcd_Monoid.Gcd A B = A * x + B * y
(R : Type u_1) [CommRing R] (ι : Type u_2) [Fintype ι] : Algebra.Finite_presentation R (mv_Polynomial ι R)
{n : ℕ} {α : Type u_1} [Preorder α] {F : Fin (n + 1) → α} : StrictAnti F ↔ ∀ (i : Fin n), F i.Succ < F (⇑Fin.cast_Succ i)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {B₂ : Basis (Fin 2) ℝ v} (hb₂ : Orthonormal ℝ ⇑B₂) (ho : B.Orientation = -B₂.Orientation) (x y : v) : hb.oangle x y = -hb₂.oangle x y
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : ℝ → E} {F' : E} {S : set ℝ} {x r : ℝ} (hF : HasDerivWithinAt F F' S x) (hr : ∥F'∥ < r) : ∀ᶠ (z : ℝ) in nhds_within x S, ∥z - x∥⁻¹ * ∥F z - F x∥ < r
{α : Type u_1} {r : α → α → Prop} {S : Setoid α} (h : ∀ (x y : α), r x y → S.Rel x y) : EqvGen.Setoid r ≤ S
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] {F : E → F} {P : FormalMultilinearSeries 𝕜 E F} {x y : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall F P x r) (h : y ∈ Emetric.Ball x r) : AnalyticAt 𝕜 F y
{x : Pgame} : x.lf 0 ↔ ∃ (j : x.Right_moves), ∀ (i : (x.move_Right j).Left_moves), ((x.move_Right j).move_Left i).lf 0
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) {r : ℝ} (hr : r < 0) : o.oangle (r • x) y = o.oangle (-x) y
{ι : Type u_1} {𝕜 : Type u_2} [_R_or_C 𝕜] {E : Type u_3} [InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {G : ι → Type u_4} [Π (i : ι), InnerProductSpace 𝕜 (G i)] {v : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 v) [∀ (i : ι), CompleteSpace (G i)] : hV.Linear_Isometry.to_LinearMap.Range = (⨆ (i : ι), (v i).to_LinearMap.Range).topological_Closure
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (θ : Real.Angle) : ⇑Linear_Equiv.det (o.rotation θ).to_Linear_Equiv = 1
{α : sort u_1} {P : α → Prop} {q : Π (x : α), P x → Prop} : (∀ (x : α) (h : P x), q x h) ↔ ∀ (x : {A // P A}), q ↑x _
{G : Type u} [Monoid G] : _of_Fin_order 1
{n : ℤ} (hn : n ≠ -1) (C W : ℂ) (R : ℝ) : ∮ (z : ℂ) in C(C, R), (z - W) ^ n = 0
{m : Type u_3} {N : Type u_4} [has_Mul m] [has_Mul N] {F g : m →ₙ* N} : F = g ↔ ∀ (x : m), ⇑F x = ⇑g x
{α : Type u} (S : set (set α)) : Cardinal.Mk ↥{t : set α | Measurable_set t} ≤ LinearOrder.max (Cardinal.Mk ↥S) 2 ^ Cardinal.aleph0
{v₁ : Type u_2} {v₂ : Type u_3} [semi_NormedGroup v₁] [semi_NormedGroup v₂] (F : NormedGroup_hom v₁ v₂) (x : v₁) : ∥⇑F x∥ ≤ ∥F∥ * ∥x∥
{α : Type u_1} [Monoid α] {A B : α} {u : αˣ} : A ∣ B * ↑u ↔ A ∣ B
 : Orthonormal ℂ (fourier_Lp 2)
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] {A B : Matrix n n α} (h : B.Mul A = 1) : A⁻¹ = B
{m₀ : Type u_1} [Mul_Zero_class m₀] : has_Mul.Mul 0 = Function.Const m₀ 0
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] [NoZeroSmulDivisors R m] {v : m} (hv : v ≠ 0) {r : R} (hr : r ≠ 0) : SameRay R v (r • v) ↔ 0 < r
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {F : E × F → G} (h : IsBoundedBilinearMap 𝕜 F) : IsBoundedLinearMap 𝕜 (λ (P : E × F), h.deriv P)
{R : Type u_1} {m : Type u_5} {n : Type u_14} [CommRing R] [AddCommGroup m] [module R m] [no_Zero_divisors R] {B : m →ₗ[R] m →ₗ[R] R} (v : Basis n R m) (hO : B._Ortho ⇑v) (h : ∀ (i : n), ¬B.IsOrtho (⇑v i) (⇑v i)) : B.separating_Right
{P x : ℝ} {r : ℚ} (hr : r ≠ 0) : LiouvilleWith P (↑r * x) ↔ LiouvilleWith P x
{α : Type u_1} [HasSup α] [HasInf α] (Sup_comm : ∀ (A B : α), A ⊔ B = B ⊔ A) (Sup_assoc : ∀ (A B C : α), A ⊔ B ⊔ C = A ⊔ (B ⊔ C)) (Sup_idem : ∀ (A : α), A ⊔ A = A) (Inf_comm : ∀ (A B : α), A ⊓ B = B ⊓ A) (Inf_assoc : ∀ (A B C : α), A ⊓ B ⊓ C = A ⊓ (B ⊓ C)) (Inf_idem : ∀ (A : α), A ⊓ A = A) (Sup_Inf_self : ∀ (A B : α), A ⊔ A ⊓ B = A) (Inf_Sup_self : ∀ (A B : α), A ⊓ (A ⊔ B) = A) : SemilatticeSup.to_PartialOrder α = SemilatticeInf.to_PartialOrder α
{α : Type u} (S : set α) : IsOpen {u : Ultrafilter α | S ∈ u}
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {v : v} (P : P) {direction : Submodule k v} (hv : v ∈ direction) : v +ᵥ P ∈ AffineSubspace.Mk' P direction
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {g : α → F} {F' : α → E'} {l : Filter α} : F' =o[l] g → (λ (x : α), -F' x) =o[l] g
{α : Type u} [OrderedSemiring α] [Nontrivial α] : 0 < 1
{α : Type u_1} {β : Type u_2} [Group α] [division_Monoid β] (F : α →* β) (g h : α) : ⇑F (g * h⁻¹) = ⇑F g * (⇑F h)⁻¹
{m : Type u_1} [MulOneClass m] {S : set m} : S ⊆ ↑(Submonoid.Closure S)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {S : set 𝕜} {n : WithTop ℕ} (h : ∀ (m : ℕ), ↑m ≤ n → DifferentiableOn 𝕜 (iterated_deriv_within m F S) S) : ContDiff_on 𝕜 n F S
{α : Type u_1} {β : Type u_2} {F g : α → β} {m : MeasurableSpace α} {mβ : MeasurableSpace β} [Measurable_Singleton_class α] (hF : Measurable F) (h : {x : α | F x ≠ g x}.countable) : Measurable g
{α : Type u} {β : Type v} [has_Mul α] [has_Mul β] {γ : Type u_1} [has_Mul γ] {F : α → β} {g : β → γ} (hF : _Mul_hom F) (hg : _Mul_hom g) : _Mul_hom (g ∘ F)
{α : Type u} {β : Type v} [MulOneClass α] [MulOneClass β] {F : α → β} (hF : _Monoid_hom F) {γ : Type u_1} [MulOneClass γ] {g : β → γ} (hg : _Monoid_hom g) : _Monoid_hom (g ∘ F)
{m : Type u_1} [has_Add m] {S : set m} {S : Add_Subsemigroup m} : Add_Subsemigroup.Closure S ≤ S ↔ S ⊆ ↑S
{m : Type u_1} [MulOneClass m] {N : Type u_2} [MulOneClass N] (F : m →* N) (hF : Function.Surjective ⇑F) : F.mrange = ⊤
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {α : ↥(IsSolvableByRad F E)} {n : ℕ} (hn : n ≠ 0) (hα : IsSolvableByRad.P (α ^ n)) : IsSolvableByRad.P α
{α : Type u_1} [generalized_boolean_Algebra α] {F D : ℕ → α} (hdisj : Pairwise (Disjoint on D)) (hsups : partial_sups D = partial_sups F) : D = disjointed F
{x : Type u_1} {m : Type u_4} {n : Type u_5} {P : Type u_6} {R : Type u_8} [TopologicalSpace x] [TopologicalSpace R] [Fintype n] [has_Mul R] [AddCommMonoid R] [has_Continuous_Add R] [has_Continuous_Mul R] {A : x → Matrix m n R} {B : x → Matrix n P R} (hA : Continuous A) (hB : Continuous B) : Continuous (λ (x : x), (A x).Mul (B x))
 : Finset.Nat.antidiagonal 0 = {(0, 0)}
{β : Type u} {α : Type v} {γ : Type W} [non_assoc_Semiring β] [non_assoc_Semiring γ] (g : β →+* γ) (F : α → β) (S : Finset α) : ⇑g (S.Sum (λ (x : α), F x)) = S.Sum (λ (x : α), ⇑g (F x))
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) : o.rotation 0 = Linear_Isometry_Equiv.refl ℝ v
{α : Type u_3} [SemilatticeInf α] (A : α) : Filter.at_IsBot = Filter.comap Coe Filter.at_IsBot
{α : Type u} {L : List (α × Bool)} : free_Group.red List.Nil L ↔ L = List.Nil
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) : 0 ∈ S
{α : Type u} [CompleteLattice α] {J : Type u} [CategoryTheory.SmallCategory J] (F : J ⥤ α) : CategoryTheory.Limits.Limit F = infi F.obj
{m : Type u_3} {N : Type u_4} [has_Zero m] [has_Zero N] (F : ZeroHom m N) {x y : m} (h : x = y) : ⇑F x = ⇑F y
{α : Type u} [Group α] [has_LE α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A : α} : 1 ≤ A⁻¹ ↔ A ≤ 1
{m : Type u_3} {S : Type u_4} [sub_Neg_Monoid m] [set_like S m] [hSM : Add_Subgroup_class S m] {h : S} {x y : m} (hx : x ∈ h) (hy : y ∈ h) : x - y ∈ h
{α : Type u_1} [MeasurableSpace α] {F g : α → ℝ} {S : set α} (hF : Measurable F) (hg : Measurable g) (hs : Measurable_set S) : Measurable_set (RegionBetween F g S)
{𝕜 : Type u_1} [_R_or_C 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {x : E} (hx : x ≠ 0) : ∥(↑∥x∥)⁻¹ • x∥ = 1
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] {A : α} : -A < 0 ↔ 0 < A
{n m : ℕ} (h : n = m) : ⇑(Fin.cast h) = cast _
{m : Type u_2} {n : Type u_3} (R : Type u_11) [CommRing R] [Fintype m] [DecidableEq m] [Fintype n] [DecidableEq n] (e : m ≃ n) (A : Matrix m m R) : (⇑(Matrix.reindex_alg_Equiv R e) A).det = A.det
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [CompactSpace α] [MetricSpace β] (x : α) : Continuous (λ (F : C(α, β)), ⇑F x)
{α : sort u_1} {γ : sort u_4} {r : α → α → Prop} (F : α → γ) (h : ∀ (A₁ A₂ : α), r A₁ A₂ → F A₁ = F A₂) (A : α) : Quot.Lift F h (Quot.Mk r A) = F A
{α : Type u} [non_unital_non_assoc_Ring α] (k : α) (h : ∀ (x : α), k * x = 0 → x = 0) : IsLeftRegular k
{α : Type u} {β : Type v} [Group α] [MulAction α β] [HasFaithfulSmul α β] : Function.Injective MulAction.to_perm
(R : Type u_1) {m : Type u_4} (S : Type u_7) [Semiring R] [AddCommMonoid m] [module R m] (S : set m) [Semiring S] [HasScalar R S] [module S m] [IsScalarTower R S m] : ↑(Submodule.Span R S) ⊆ ↑(Submodule.Span S S)
{F : Type u_3} [InnerProductSpace ℝ F] (x : F) (r : ℝ) : HasInner.inner (r • x) x = r * (∥x∥ * ∥x∥)
{α : Type u} {β : Type v} {F : α → β} {l₁ : Filter α} {l₂ : Filter β} : Filter.Tendsto F l₁ l₂ → l₁ ≤ Filter.comap F l₂
{A B : ℝ} {F F' g : ℝ → ℝ} (h : ∀ (x : ℝ), x ∈ set.Interval A B → HasDerivAt F (F' x) x) (h' : Continuous_on F' (set.Interval A B)) (hg : Continuous g) : ∫ (x : ℝ) in A..B, (g ∘ F) x * F' x = ∫ (x : ℝ) in F A..F B, g x
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (S : Finset ι) [CharZero k] [Fintype ι] (h : S.Nonempty) : Finset.Univ.Sum (λ (i : ι), Finset.centroid_weights_indicator k S i) = 1
{m : Type u_3} {N : Type u_4} {F : Type u_8} {mM : AddZeroClass m} {mN : AddZeroClass N} [AddMonoid_hom_class F m N] (F : F) {x : m} (hx : ∃ (y : m), y + x = 0) : ∃ (y : N), y + ⇑F x = 0
{E : Type u_2} {𝕜 : Type u_3} [Linear_ordered_Field 𝕜] [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul 𝕜 E] {S : set E} (hs : Convex 𝕜 S) {A B : 𝕜} (ha : 0 < A) (hb : 0 ≤ B) (hab : A + B = 1) : A • Interior S + B • S ⊆ Interior S
{α : Type u_1} [Preorder α] {A B : α} (h : A ≤ B) : ¬A ⩿ B ↔ ∃ (C : α), A < C ∧ C < B
{G : Type u_1} [Group G] {N : Type u_3} [Group N] (F : G →* N) {h K : Subgroup G} (hH : F.Ker ≤ h) (hK : F.Ker ≤ K) (hF : Subgroup.Map F h = Subgroup.Map F K) : h = K
{α : Type u} [Group α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A B C : α} : A < B * C → B⁻¹ * A < C
(K : Type u) [DivisionRing K] {ι : Type v} [Fintype ι] : Finite_dimensional.finrank K (ι → K) = Fintype.Card ι
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] (S : Submodule K v) : Finite_dimensional.finrank K ↥S ≤ Finite_dimensional.finrank K v
{α : Type u} [PseudoEmetricSpace α] {x : α} {S t : set α} : Emetric.Inf_edist x t ≤ Emetric.Inf_edist x S + Emetric.Hausdorff_edist S t
{P : ℕ} {R : Type u_1} [hp : Fact (Nat.Prime P)] [CommRing R] (x : witt_Vector P R) : ⇑witt_Vector.frobenius (⇑witt_Vector.verschiebung x) = x * ↑P
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_5} [NormedGroup E'] [NormedSpace 𝕜 E'] {n : WithTop ℕ} {F : E → E'} {S : set E} {x : E} : ContDiff_within_at 𝕜 n F S x → Cont_mdiff_within_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n F S x
{K : Type u_1} {v : K} {n : ℕ} [Linear_ordered_Field K] [FloorRing K] {ifp_n : GeneralizedContinuedFraction.Int_fract_pair K} (nth_Stream_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.Some ifp_n) : 0 ≤ ifp_n.fr
{G : Type u_1} [Group G] (K : Subgroup G) {l : List G} : (∀ (x : G), x ∈ l → x ∈ K) → l.Prod ∈ K
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {δ : Type u_1} [LinearOrder δ] [TopologicalSpace δ] [order_IsClosed_topology δ] {F : α → δ} {S : set α} [S.Ord_connected] (hs : S.Nonempty) (hF : Continuous_on F S) (hbot : Filter.Tendsto (λ (x : ↥S), F ↑x) Filter.at_IsBot Filter.at_top) (htop : Filter.Tendsto (λ (x : ↥S), F ↑x) Filter.at_top Filter.at_IsBot) : set.surj_on F S set.Univ
{A : ℕ} : ↑(Nat.sqrt A) ≤ Real.sqrt ↑A
{C : Type u₁} [CategoryTheory.Category C] {x : C} {S : CategoryTheory.Sieve x} {P : Cᵒᵖ ⥤ Type v₁} (h : CategoryTheory.Presieve.IsSheafFor P ⇑S) (t₁ t₂ : CategoryTheory.yoneda.obj x ⟶ P) (ht : S.Functor_inclusion ≫ t₁ = S.Functor_inclusion ≫ t₂) : t₁ = t₂
{α : Type u} [TopologicalSpace α] {x : α} : Dense {x}ᶜ ↔ ¬IsOpen {x}
{G : Type u_7} [Group G] (L : List G) : L.reverse.Prod = ((List.Map (λ (x : G), x⁻¹) L).Prod)⁻¹
{m : Type u_1} [has_Mul m] {C D : Con m} {x y : m} : ⇑(C ⊓ D) x y ↔ ⇑C x y ∧ ⇑D x y
{𝕜 : Type u} {A : Type v} [Field 𝕜] [Ring A] [Algebra 𝕜 A] [Nontrivial A] (k : 𝕜) (A : A) (ha : (Spectrum 𝕜 A).Nonempty) : Spectrum 𝕜 (k • A) = k • Spectrum 𝕜 A
{F : ℕ → ℝ} (hfa : Monotone F) (hF0 : Filter.Tendsto F Filter.at_top (nhds 0)) : Cauchy_Seq (λ (n : ℕ), (Finset.Range (n + 1)).Sum (λ (i : ℕ), (-1) ^ i * F i))
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommGroup E] [HasScalar 𝕜 E] {S : Convex_cone 𝕜 E} : S.Blunt → S.salient
{α : Type u_1} {β : Type u_2} {m : Type u_5} [AddCommMonoid m] {F : α → m} {g : β → α} (hg : set.inj_on g (Function.Support (F ∘ g))) : finsum (λ (i : α), finsum (λ (h : i ∈ set.Range g), F i)) = finsum (λ (j : β), F (g j))
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {n : WithTop ℕ} (h : ∀ (m : ℕ), ↑m ≤ n → Differentiable 𝕜 (iterated_deriv m F)) : ContDiff 𝕜 n F
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) : S.monge_point = (↑(n + 1) / ↑(n - 1)) • (Finset.centroid ℝ Finset.Univ S.points -ᵥ S.circumcenter) +ᵥ S.circumcenter
(R : Type u) [CommRing R] [strong_RankCondition R] (m : Type v) (N : Type W) [AddCommGroup m] [module R m] [module.free R m] [AddCommGroup N] [module R N] [module.free R N] : Finite_dimensional.finrank R (TensorProduct R m N) = Finite_dimensional.finrank R m * Finite_dimensional.finrank R N
{R : Type u} [CommRing R] [IsDomain R] {P : Polynomial R} {A : R} {n : ℕ} (hzero : P ≠ 0) (h : (Polynomial.x - ⇑Polynomial.C A) ^ n ∣ P) : n ≤ Polynomial.root_multiplicity A P
{ι : Type u_1} {α : Type u_2} [Fintype ι] [DecidableEq α] (t : ι → Finset α) : (∀ (S : Finset ι), S.Card ≤ (S.bUnion t).Card) ↔ ∃ (F : ι → α), Function.Injective F ∧ ∀ (x : ι), F x ∈ t x
{α : Type u_1} {β : Type u_2} {e e' : local_Equiv α β} (h : e ≈ e') : set.Eq_on ⇑e ⇑e' e.Source
{𝕜 : Type u_1} [_R_or_C 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {r : ℝ} (r_Pos : 0 < r) (C : ℝ) (F : E →ₗ[𝕜] 𝕜) (h : ∀ (z : E), z ∈ metric.IsClosed_ball 0 r → ∥⇑F z∥ ≤ C) (z : E) : ∥⇑F z∥ ≤ C / r * ∥z∥
{α : Type u} [EmetricSpace α] {S : set α} (hs : IsClosed S) : IsClosed {t : TopologicalSpace.Closeds α | ↑t ⊆ S}
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {F : α → β} (hF : Continuous F) (x : α) (y : β) (h : F x = y) : Filter.Tendsto F (nhds x) (nhds y)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {n : WithTop ℕ} (h : ∀ (x : E), x ∈ S → (∃ (u : set E), IsOpen u ∧ x ∈ u ∧ ContDiff_on 𝕜 n F (S ∩ u))) : ContDiff_on 𝕜 n F S
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x ⟶ Y} {t : CategoryTheory.Limits.Fork F g} (ht : CategoryTheory.Limits.IsLimit t) {Z Z' : C} (q : Z' ⟶ Z) (k : Z ⟶ t.x) : ↑(⇑(CategoryTheory.Limits.Fork._Limit.hom_is_iso ht Z') (q ≫ k)) = q ≫ ↑(⇑(CategoryTheory.Limits.Fork._Limit.hom_is_iso ht Z) k)
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] (F : LocalHomeomorph 𝕜 𝕜) {A F' : 𝕜} (ha : A ∈ F.to_local_Equiv.Target) (hF' : F' ≠ 0) (htff' : HasDerivAt ⇑F F' (⇑(F.Symm) A)) : HasDerivAt ⇑(F.Symm) F'⁻¹ A
{α : Type u} [TopologicalSpace α] [t1_Space α] {S : set α} (hs : Dense S) (x : α) [(nhds_within x {x}ᶜ).Ne_IsBot] : Dense (S  {x})
{α : Type u_1} [PartialOrder α] [OrderTop α] {A : α} : IsCoatom A → A ⋖ ⊤
{α : Type u} {β : Type v} [TopologicalSpace α] [PartialOrder α] [t : OrderTopology α] {F g h : β → α} {B : Filter β} {A : α} (hg : Filter.Tendsto g B (nhds A)) (hH : Filter.Tendsto h B (nhds A)) (hgf : ∀ᶠ (B : β) in B, g B ≤ F B) (hfh : ∀ᶠ (B : β) in B, F B ≤ h B) : Filter.Tendsto F B (nhds A)
{R : Type u_1} {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] : (∀ (F : ℕ →o (Submodule R m)ᵒᵈ), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑F n = ⇑F m) ↔ IsArtinian R m
{R : Type u_1} [CommSemiring R] {m : Submonoid R} {S : Type u_2} [CommSemiring S] [Algebra R S] {P : Type u_3} [CommSemiring P] [IsLocalization m S] {g : R →+* P} (hg : ∀ (y : ↥m), IsUnit (⇑g ↑y)) {x y : R} (h : ⇑(Algebra_Map R S) x = ⇑(Algebra_Map R S) y) : ⇑g x = ⇑g y
{R : Type u_1} {A : R} [CancelMonoidWithZero R] (A0 : A ≠ 0) : IsRegular A
{m n : ℕ} : (∀ (A : ℕ), m ∣ A ↔ n ∣ A) ↔ m = n
{A : Type u_1} {B : Type u_2} [CommRing A] [IsDomain A] [Ring B] [Algebra A B] {x : B} [IsDomain B] (hx : IsIntegral A x) : Irreducible (minpoly A x)
{v₁ : Type u_2} {v₂ : Type u_3} [semi_NormedGroup v₁] [semi_NormedGroup v₂] (F : v₁ →+ v₂) {C : ℝ} (hC : 0 ≤ C) (h : ∀ (x : v₁), ∥⇑F x∥ ≤ C * ∥x∥) : ∥F.Mk_NormedGroup_hom C h∥ ≤ C
{ι : Type u_1} {α : Type u_2} {A : ι → Type u_3} [AddMonoid ι] [graded_Monoid.Gmonoid A] (l : List α) (F : α → graded_Monoid A) : (List.Map F l).Prod = graded_Monoid.Mk (l.dprod_Index (λ (i : α), (F i).fst)) (l.dprod (λ (i : α), (F i).fst) (λ (i : α), (F i).Snd))
{α : Type u_1} {R : Type u_2} {l : Filter α} {F : α → R} {r : R} [Linear_OrderedSemiring R] [Archimedean R] (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_top) : Filter.Tendsto (λ (x : α), F x * r) l Filter.at_top
{α : Type u} [HasSubset α] {A B : α} [IsRefl α HasSubset.Subset] : A = B → B ⊆ A
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMinOrder α] [DenselyOrdered α] {A : α} {S : set α} : S ∈ nhds_within A (set.Iic A) ↔ ∃ (l : α) (h : l ∈ set.Iio A), set.icc l A ⊆ S
(A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {P : Polynomial A} (hp : ⇑(Polynomial.aeval x) P = 0) : minpoly A x ∣ P
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} [DecidableEq α'] [DecidableEq γ] [DecidableEq δ] {F : α → β → γ} {S : Finset α} {t : Finset β} {g : γ → δ} {F' : β → α' → δ} {g' : α → α'} (h_antidistrib : ∀ (A : α) (B : β), g (F A B) = F' B (g' A)) : Finset.image g (Finset.image₂ F S t) = Finset.image₂ F' t (Finset.image g' S)
{α : Type u} [Group α] : _Group_hom Id
{α : Type u_1} {β : Type u_2} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] {F : β → α} (hF : Continuous F) (x₀ : β) (h : ∀ᶠ (x : β) in Filter.cocompact β, F x ≤ F x₀) : ∃ (x : β), ∀ (y : β), F y ≤ F x
{α : Type u_1} {β : Type u_2} {S : set α} {t : α → set β} {y : β} (h : ∀ (x : α), x ∈ S → y ∈ t x) : y ∈ ⋂ (x : α) (h : x ∈ S), t x
(F : Circle_deg1_Lift) (P : ℝ → Prop) (h : ∀ (x : ℝ), x ∈ set.icc 0 1 → P (⇑F x - x)) (x : ℝ) : P (⇑F x - x)
(k : Type u_1) {v : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : ι → P) (S : Finset ι) {n : ℕ} (hc : S.Card = n + 1) : Finite_dimensional.finrank k ↥(Vector_Span k ↑(Finset.image P S)) ≤ n
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (e : LocalHomeomorph α β) {F : γ → α} {S : set γ} {x : γ} (hx : F x ∈ e.to_local_Equiv.Source) (h : F ⁻¹' e.to_local_Equiv.Source ∈ nhds_within x S) : Continuous_within_at F S x ↔ Continuous_within_at (⇑e ∘ F) S x
{α : Type u_1} {ι : Type u_2} {F : ι → α} : Function.Injective F → Pairwise (Ne on F)
{α : Type u_1} {n : ℕ} (S : Sym α n) : Sym.Map (λ (x : α), x) S = S
{k : Type u_1} {G : Type u_2} {v : Type u_3} [CommRing k] [Group G] [AddCommGroup v] [module k v] (ρ : Representation k G v) [Nontrivial k] [module.free k v] [module.Finite k v] : ρ.character 1 = ↑(Finite_dimensional.finrank k v)
{k : Type u_1} {v1 : Type u_2} {v2 : Type u_4} [Ring k] [AddCommGroup v1] [module k v1] [AddCommGroup v2] [module k v2] (F : v1 →ᵃ[k] v2) : ⇑F = ⇑(F.Linear) + λ (z : v1), ⇑F 0
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {C : ℝ} {F : ℂ → E} {z : ℂ} (hD : Diff_Cont_on_cl ℂ F (set.Iio 0 ×ℂ set.ioi 0)) (hB : ∃ (C : ℝ) (h : C < 2) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal (set.Iio 0 ×ℂ set.ioi 0)] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hre : ∀ (x : ℝ), x ≤ 0 → ∥F ↑x∥ ≤ C) (him : ∀ (x : ℝ), 0 ≤ x → ∥F (↑x * Complex.i)∥ ≤ C) (hz_re : z.re ≤ 0) (hz_im : 0 ≤ z.im) : ∥F z∥ ≤ C
{L : FirstOrder.Language} {m : Type W} [L.structure m] {P : m → Prop} (x : m) {S : set m} (hs : ⇑(FirstOrder.Language.Substructure.Closure L) S = ⊤) (Hs : ∀ (x : m), x ∈ S → P x) (Hfun : ∀ {n : ℕ} (F : L.Functions n), FirstOrder.Language.IsClosed_under F (set_of P)) : P x
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {S : set E} [CompleteSpace F] (h : AnalyticOn 𝕜 F S) (n : ℕ) : AnalyticOn 𝕜 (iterated_fderiv 𝕜 n F) S
{α : Type u_1} [Fintype α] (P q : α → Prop) [Fintype {x // P x}] [Fintype {x // ¬P x}] [Fintype {x // q x}] [Fintype {x // ¬q x}] (h : Fintype.Card {x // P x} = Fintype.Card {x // q x}) : Fintype.Card {x // ¬P x} = Fintype.Card {x // ¬q x}
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type W} {x : C} {R : CategoryTheory.Presieve x} {P' : Cᵒᵖ ⥤ Type W} (i : P ≅ P') : CategoryTheory.Presieve.IsSheafFor P R → CategoryTheory.Presieve.IsSheafFor P' R
{𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] {F F' : 𝕜 → G} {S : set 𝕜} {x y : 𝕜} {C : ℝ} (hF : ∀ (x : 𝕜), x ∈ S → HasDerivWithinAt F (F' x) S x) (bound : ∀ (x : 𝕜), x ∈ S → ∥F' x∥ ≤ C) (hs : Convex ℝ S) (xs : x ∈ S) (ys : y ∈ S) : ∥F y - F x∥ ≤ C * ∥y - x∥
{α : Type u_1} {m : Type u_5} [CommMonoid m] {A : α} {S : set α} (F : α → m) (h : A ∉ S) (hs : (S ∩ Function.MulSupport F).Finite) : finprod (λ (i : α), finprod (λ (h : i ∈ HasInsert.Insert A S), F i)) = F A * finprod (λ (i : α), finprod (λ (h : i ∈ S), F i))
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : E → ℝ} {A : E} {F' : E →L[ℝ] ℝ} {S : set E} (h : IsLocalMinOn F S A) (hF : HasFderivWithinAt F F' S A) {y : E} (hy : y ∈ Pos_TangentConeAt S A) : 0 ≤ ⇑F' y
{J : Type u} [Preorder J] [_Directed J has_LE.LE] (F : Jᵒᵖ ⥤ Type v) [Π (j : Jᵒᵖ), Fintype (F.obj j)] [∀ (j : Jᵒᵖ), Nonempty (F.obj j)] : F.sections.Nonempty
{m : Type u_1} [Semigroup m] [Nonempty m] (S : set (set m)) (sfin : S.Finite) (scov : ⊤ ⊆ ⋃₀S) : ∃ (C : set m) (h : C ∈ S) (A : Stream m), Hindman.FP A ⊆ C
{E : Type u_4} [NormedGroup E] [NormedSpace ℝ E] {B : ℝ} {F : ℕ → ℝ} {z : ℕ → E} (hfa : Monotone F) (hF0 : Filter.Tendsto F Filter.at_top (nhds 0)) (hgb : ∀ (n : ℕ), ∥(Finset.Range n).Sum (λ (i : ℕ), z i)∥ ≤ B) : Cauchy_Seq (λ (n : ℕ), (Finset.Range (n + 1)).Sum (λ (i : ℕ), F i • z i))
{α : Type u} [Semigroup α] [has_Distrib_Neg α] (A B : α) : -A ∣ B ↔ A ∣ B
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_4} [Fintype ι] [DecidableEq ι] (e : Basis ι R m) (x : Orientation R m ι) (F : m ≃ₗ[R] m) : ⇑(Orientation.Map ι F) x = (⇑Linear_Equiv.det F)⁻¹ • x
{α : Type u_1} [DecidableEq α] [Fintype α] : Finset.Univ = Finset.Map Equiv.perm.decompose_Option.Symm.to_Embedding Finset.Univ
{E : Type u_3} [semi_NormedGroup E] {F : ℕ → E} (g : ℕ → ℝ) (hg : Cauchy_Seq (λ (n : ℕ), (Finset.Range n).Sum (λ (i : ℕ), g i))) (hF : ∀ (i : ℕ), ∥F i∥ ≤ g i) : Cauchy_Seq (λ (n : ℕ), (Finset.Range n).Sum (λ (i : ℕ), F i))
{E : Type u_2} [AddCommGroup E] [module ℝ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Smul ℝ E] [t2_Space E] {S : set E} (hs : S.Finite) : IsClosed (⇑(Convex_hull ℝ) S)
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (m : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (hM : m (Sum.inr_ ()) (Sum.inr_ ()) ≠ 0) : (((Matrix.Pivot.List_transvec_col m).Prod.Mul m).Mul (Matrix.Pivot.List_transvec_row m).Prod)._two_block_Diagonal
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) (direction : Submodule k v) : (AffineSubspace.Mk' P direction).direction = direction
{α : Type u} [Preorder α] {A B C : α} : B = C → A ≤ B → A ≤ C
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y : v} (h : o.oangle x y = 0) : x = y ↔ ∥x∥ = ∥y∥
{α : Type u} (xs : List α) (x : α) [DecidableEq α] : [x].intercalate (List.split_on x xs) = xs
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {F : E →ₛₗ[σ₁₂] F} (hF : Continuous ⇑F) {x : E} (hx : ∥x∥ = 0) : ∥⇑F x∥ = 0
{α : Type u} {r : α → α → Prop} {A B : α} (h : Relation.refl_Trans_gen r A B) : ∃ (l : List α), List.chain r A l ∧ (A :: l).Last _ = B
{K : Type u} [Field K] (S : Subfield K) : 0 ∈ S
{A : Type u_1} [CommMonoid A] (A B C : A) : C ∈ Submonoid.Closure {A, B} ↔ ∃ (m n : ℕ), A ^ m * B ^ n = C
{α : Type u_2} {ι : Type u_5} [AddCommMonoid α] (t : Finset ι) (F₁ F₂ : ι → set α) (hF : ∀ {i : ι}, i ∈ t → F₁ i ⊆ F₂ i) : t.Sum (λ (i : ι), F₁ i) ⊆ t.Sum (λ (i : ι), F₂ i)
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z → B} [TopologicalSpace Z] (e : TopologicalFiberBundle.Trivialization F Proj) {x : Z} (ex : x ∈ e.to_LocalHomeomorph.to_local_Equiv.Source) : Continuous_at Proj x
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] {v : n → α} : IsUnit (Matrix.Diagonal v) ↔ IsUnit v
(r : ℝ) (h : r ≠ 0) : r.sign = -1 ∨ r.sign = 1
{A B C : ℤ} (h : fermat_42.Minimal A B C) : _IsCoprime A B
{α : Type u_1} [has_Add α] [has_LT α] [ContravariantClass α α has_Add.Add has_LT.LT] {A B C : α} (bc : A + B < A + C) : B < C
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {A B : α} [IsAntisymm α HasSubset.Subset] (h : A ⊆ B) : A = B ∨ A ⊂ B
{x y : Pgame} : x.lf y ↔ (∃ (i : y.Left_moves), (∀ (i' : x.Left_moves), (x.move_Left i').lf (y.move_Left i)) ∧ ∀ (j : (y.move_Left i).Right_moves), x.lf ((y.move_Left i).move_Right j)) ∨ ∃ (j : x.Right_moves), (∀ (i : (x.move_Right j).Left_moves), ((x.move_Right j).move_Left i).lf y) ∧ ∀ (j' : y.Right_moves), (x.move_Right j).lf (y.move_Right j')
(R : Type u_1) {m : Type u_4} (S : Type u_7) [Semiring R] [AddCommMonoid m] [module R m] (S : set m) [Semiring S] [HasScalar R S] [module S m] [IsScalarTower R S m] : Submodule.Span R S ≤ Submodule.Restrict_scalars R (Submodule.Span S S)
{α : Type u} {L₁ : List (α × Bool)} {x : α × Bool} : free_Group.red [x] L₁ ↔ L₁ = [x]
{α : Type u_1} [Lattice α] [_modular_Lattice α] {β : Type u_2} {γ : Type u_3} [Preorder β] [PartialOrder γ] (h₁ : WellFounded Gt) (h₂ : WellFounded Gt) (K : α) (F₁ : β → α) (F₂ : α → β) (g₁ : γ → α) (g₂ : α → γ) (gci : GaloisCoinsertion F₁ F₂) (gi : GaloisInsertion g₂ g₁) (hF : ∀ (A : α), F₁ (F₂ A) = A ⊓ K) (hg : ∀ (A : α), g₁ (g₂ A) = A ⊔ K) : WellFounded Gt
(x : ℂ) : HasStrictDerivAt Complex.sin (Complex.cos x) x
{α : Type u_1} {ι : Type u_3} [CompleteLattice α] {t : ι → α} (ht : CompleteLattice.Independent t) : Pairwise (Disjoint on t)
{R : Type u} {ι : Type u'} {m₁ : ι → Type v₁} {m₂ : Type v₂} [DecidableEq ι] [CommSemiring R] [Π (i : ι), AddCommMonoid (m₁ i)] [AddCommMonoid m₂] [Π (i : ι), module R (m₁ i)] [module R m₂] (F : MultilinearMap R m₁ m₂) [Fintype ι] (C : ι → R) (m : Π (i : ι), m₁ i) : ⇑F (λ (i : ι), C i • m i) = Finset.Univ.Prod (λ (i : ι), C i) • ⇑F m
{m n B : ℕ} (hm : m ≠ 1) (hn : 0 < n) (hb : Nat.log m n < B) : multiplicity m n = ↑((Finset.Filter (λ (i : ℕ), m ^ i ∣ n) (Finset.Ico 1 B)).Card)
{β α : Type u_1} (F : β → α) (W : Cardinal.Mk α < Cardinal.Mk β) (W' : Infinite α) : ∃ (A : α), Infinite ↥(F ⁻¹' {A})
{α : Type u} {β : Type v} [AddCommGroup β] (g h : free_abelian_Group α →+ β) (h : ∀ (x : α), ⇑g (free_abelian_Group.of x) = ⇑h (free_abelian_Group.of x)) : g = h
{ι : Type u_1} {ι' : Type u_2} {R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] (B : Basis ι R m) (e : ι ≃ ι') : set.Range (⇑B ∘ ⇑(e.Symm)) = set.Range ⇑B
{K : Type u_1} [Linear_ordered_Field K] {v : K} {n : ℕ} [FloorRing K] (nth_Stream_Eq_None : GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.None) : v = (GeneralizedContinuedFraction.of v).convergents (n - 1)
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [nondiscrete_NormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (F : Continuous_MultilinearMap 𝕜 E G) (m : Π (i : ι), E i) (h : ∥m∥ ≤ 1) : ∥⇑F m∥ ≤ ∥F∥
{α : Type u_1} {m : MeasurableSpace α} (S : set α) : Nonempty {t // S ⊆ t ∧ Measurable_set t}
{α : Type u_2} {β : Type u_3} : Filter.cofinite.Coprod Filter.cofinite = Filter.cofinite
{α : Type u_1} [UniformSpace α] : (Uniformity α).has_Basis (λ (v : set (α × α)), v ∈ Uniformity α ∧ IsOpen v ∧ symmetric_Rel v) Id
{α : Type u} [Ring α] {A B : α} : A ∣ B + A ↔ A ∣ B
{α : Type u_1} {β : Type u_2} [LinearOrder α] [Preorder β] {A : α} {F : α → β} (h₁ : StrictMono_on F (set.Iic A)) (h₂ : StrictMono_on F (set.ici A)) : StrictMono F
{α : Type u_1} [Fintype α] [DecidableEq α] (h5 : 5 ≤ Fintype.Card α) {F : Equiv.perm α} (hF : F._three_Cycle) : Subgroup.Normal_Closure {⟨F, _⟩} = ⊤
{α : Type u} {β : Type v} [TopologicalSpace α] [Linear_ordered_AddCommGroup α] [OrderTopology α] {l : Filter β} {F g : β → α} {C : α} (hF : Filter.Tendsto F l (nhds C)) (hg : Filter.Tendsto g l Filter.at_top) : Filter.Tendsto (λ (x : β), F x + g x) l Filter.at_top
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F ≠ 2) : Finset.Univ.Sum (λ (A : F), Char.quadratic_Char F A) = 0
{α : Type u_2} {β : Type u_3} {rα : non_assoc_Semiring α} {rβ : non_assoc_Semiring β} (F : α →+* β) : ⇑F 1 = 1
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : Collinear k S ↔ module.rank k ↥(Vector_Span k S) ≤ 1
{α : Type u} [TopologicalSpace α] {S t : set α} (hs : Dense S) (ht : Dense t) (hto : IsOpen t) : Dense (S ∩ t)
{R : Type u_1} {ι₁ : Type u_2} {ι₂ : Type u_3} {ι₃ : Type u_4} {ι₄ : Type u_5} [CommSemiring R] [DecidableEq ι₁] [DecidableEq ι₂] [DecidableEq ι₃] [DecidableEq ι₄] {N₁ : Type u_6} [AddCommMonoid N₁] [module R N₁] {N₂ : Type u_7} [AddCommMonoid N₂] [module R N₂] {N : Type u_8} [AddCommMonoid N] [module R N] (A : MultilinearMap R (λ (_x : ι₁), N) N₁) (B : MultilinearMap R (λ (_x : ι₂), N) N₂) (σA : ι₁ ≃ ι₃) (σB : ι₂ ≃ ι₄) : MultilinearMap.Dom_Dom_congr (σA.Sum_congr σB) (A.Dom_Coprod B) = (MultilinearMap.Dom_Dom_congr σA A).Dom_Coprod (MultilinearMap.Dom_Dom_congr σB B)
{α : Type u} [PseudoMetricSpace α] {S : set α} {x : α} (h : S.Nonempty) : x ∈ Closure S ↔ metric.Inf_dist x S = 0
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LE.LE] {A B : α} (ha : A ≤ 0) (hb : B ≤ 0) : A + B ≤ 0
{τ : Type u_1} {α : Type u_2} [canonically_ordered_AddMonoid τ] {ϕ : τ → α → α} {S : set α} (h : IsFwInvariant ϕ S) : IsInvariant ϕ S
{m : Type u_1} [MulOneClass m] {S : set m} {S : Submonoid m} : Submonoid.Closure S ≤ S ↔ S ⊆ ↑S
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {F : m →* N} (h : ∀ (y : ↥S), IsUnit (⇑F ↑y)) {y : ↥S} {z : N} (h : ⇑F ↑y * z = 1) : ↑(⇑(IsUnit.Lift_Right (F.Restrict S) h) y)⁻¹ = z
{α : Type u_1} [LinearOrder α] {S : Finset α} {k : ℕ} (h : S.Card = k) (hz : 0 < k) : ⇑(S.order_emb_of_Fin h) ⟨k - 1, _⟩ = S.max' _
{m : Type u} [Monoid m] {A : mˣ} {x y : m} (h : SemiconjBy ↑A x y) : SemiconjBy ↑A⁻¹ y x
(x : AlgebraicGeometry.LocallyRingedSpace) : AlgebraicGeometry.to_spec_Γ (AlgebraicGeometry.LocallyRingedSpace.Γ.obj (Opposite.Op x)) ≫ x.toΓ_spec.val.C.App (Opposite.Op ⊤) = 𝟙 (AlgebraicGeometry.LocallyRingedSpace.Γ.obj (Opposite.Op x))
{R : Type u_1} [NormedRing R] {r : ℝ} (hr : 1 < r) : Coe =o[Filter.at_top] λ (n : ℕ), r ^ n
{α : Type u_1} {β : Type u_3} [MeasurableSpace α] [MeasurableSpace β] {ν : MeasureTheory.Measure β} [MeasureTheory.sigma_Finite ν] {S : set (α × β)} (hs : Measurable_set S) : Measurable (λ (x : α), ⇑ν (Prod.Mk x ⁻¹' S))
{α : Type u} [PseudoMetricSpace α] {ι : Type u_1} {F₁ F₂ : ι → α} {P : Filter ι} {A : α} (h₁ : Filter.Tendsto F₁ P (nhds A)) (h : Filter.Tendsto (λ (x : ι), HasDist.dist (F₁ x) (F₂ x)) P (nhds 0)) : Filter.Tendsto F₂ P (nhds A)
{α : Type u_1} (F : α → set α) : ¬Function.Surjective F
{E : Type u_1} {x : Type u_2} [InnerProductSpace ℝ E] [NormedGroup x] [NormedSpace ℝ x] {n : WithTop ℕ} {C g : x → E} {F : Π (x : x), ContDiff_bump_of_inner (C x)} {x : x} (hc : ContDiff_at ℝ n C x) (hr : ContDiff_at ℝ n (λ (x : x), (F x).r) x) (hR : ContDiff_at ℝ n (λ (x : x), (F x).R) x) (hg : ContDiff_at ℝ n g x) : ContDiff_at ℝ n (λ (x : x), ⇑(F x) (g x)) x
{α : Type u_1} [Linear_ordered_Field α] [Archimedean α] {x y : α} (xpos : 0 < x) (hx : x ≤ 1) (ypos : 0 < y) (hy : y < 1) : ∃ (n : ℕ), y ^ (n + 1) < x ∧ x ≤ y ^ n
{R : Type u} [Ring R] (S : Subring R) {l : List R} : (∀ (x : R), x ∈ l → x ∈ S) → l.Prod ∈ S
(K : Type u_1) [_R_or_C K] (E : Type u_2) [NormedGroup E] [NormedSpace K E] [Finite_dimensional K E] : ProperSpace E
{ι : Type u_1} {x : Type u_2} [TopologicalSpace x] [NormalSpace x] {u : ι → set x} (uo : ∀ (i : ι), IsOpen (u i)) (uf : ∀ (x : x), {i : ι | x ∈ u i}.Finite) (uU : (⋃ (i : ι), u i) = set.Univ) : ∃ (v : ι → set x), set.Union v = set.Univ ∧ (∀ (i : ι), IsOpen (v i)) ∧ ∀ (i : ι), Closure (v i) ⊆ u i
{α : Type u} [PseudoEmetricSpace α] {S : set α} {D : Ennreal} (h : ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → HasEdist.edist x y ≤ D) : Emetric.diam S ≤ D
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) (F : v ≃ₗᵢ[ℝ] v) : (⇑(Orientation.Map (Fin 2) F.to_Linear_Equiv) o).oangle x y = o.oangle (⇑(F.Symm) x) (⇑(F.Symm) y)
{α : Type u} {S : set (set α)} : Cardinal.Mk ↥S ≤ Cardinal.Continuum → Cardinal.Mk ↥{t : set α | Measurable_set t} ≤ Cardinal.Continuum
{α : Type u_1} [TopologicalSpace α] {S : set α} (h : IsOpen S) : _Gδ S
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {𝕜₃ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [semi_NormedGroup E] [semi_NormedGroup F] [semi_NormedGroup G] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [nondiscrete_NormedField 𝕜₃] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] [NormedSpace 𝕜₃ G] {σ₁₂ : 𝕜 →+* 𝕜₂} {σ₂₃ : 𝕜₂ →+* 𝕜₃} {σ₁₃ : 𝕜 →+* 𝕜₃} [Ring_hom_Comp_triple σ₁₂ σ₂₃ σ₁₃] [Ring_hom_isometric σ₁₂] [Ring_hom_isometric σ₂₃] (h : F →sl[σ₂₃] G) (F : E →sl[σ₁₂] F) : ∥h.Comp F∥ ≤ ∥h∥ * ∥F∥
{ι : Type u_1} {E : Type u_3} [semi_NormedGroup E] [CompleteSpace E] {F : ι → E} (g : ι → ℝ) (hg : Summable g) (h : ∀ (i : ι), ∥F i∥ ≤ g i) : Summable F
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S t : set P} (ha : AffineIndependent k (λ (x : ↥t), ↑x)) (hs : S ⊆ t) : AffineIndependent k (λ (x : ↥S), ↑x)
{x : top} {ι : Type v} (U : ι → TopologicalSpace.Opens ↥x) : CategoryTheory.Sieve.generate (top.Presheaf.Presieve_of_covering U) ∈ ⇑(Opens.GrothendieckTopology ↥x) (supr U)
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [nondiscrete_NormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (F : MultilinearMap 𝕜 E G) {C : ℝ} (h : ∀ (m : Π (i : ι), E i), ∥⇑F m∥ ≤ C * Finset.Univ.Prod (λ (i : ι), ∥m i∥)) : ∥F.Mk_Continuous C h∥ ≤ LinearOrder.max C 0
{α : Type u} {β : Type v} {F : α → β} {B : β} {l : List α} : B ∈ List.Map F l → (∃ (A : α), A ∈ l ∧ F A = B)
{α : Type u_1} {ι : Type u_3} [CompleteLattice α] [Fintype ι] {F : ι → α} : CompleteLattice.Independent F ↔ Finset.Univ.Sup_indep F
{R : Type u_1} {A B : R} [Add_Semigroup R] (rra : _Add_Right_regular A) (rrb : _Add_Right_regular B) : _Add_Right_regular (A + B)
{α : Type u_1} [UniformSpace α] {K U : set α} (hK : IsCompact K) (hU : IsOpen U) (hKU : K ⊆ U) : ∃ (v : set (α × α)) (h : v ∈ Uniformity α), IsOpen v ∧ ∀ (x : α), x ∈ K → UniformSpace.ball x v ⊆ U
{α : Type u_2} [Group α] {S t : set α} : Disjoint S t → 1 ∉ S / t
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {P : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall F P x r) : Continuous_on F (Emetric.Ball x r)
{n : ℕ} (P : Fin (n + 1)) (i : Fin n) (h : P ≤ ⇑Fin.cast_Succ i) : ⇑(P.Succ_above) i = i.Succ
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [UniformSpace β] [(Uniformity β)._countably_generated] (F : α → β) : _Gδ {x : α | Continuous_at F x}
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} {v : v} {P : ι → P} : v ∈ Vector_Span k (set.Range P) ↔ ∃ (S : Finset ι) (W : ι → k) (h : S.Sum (λ (i : ι), W i) = 0), v = ⇑(S.weighted_vsub P) W
{α : Type u_1} {β : Type u_2} {l : Filter α} {F : α → β} {lb : Filter β} : Filter.Tendsto F l lb → ↑F.tendsto lb
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} {P0 : P} {S : set ι} {P : ι → P} : (∃ (fs : Finset ι) (hfs : ↑fs ⊆ S) (W : ι → k) (hw : fs.Sum (λ (i : ι), W i) = 1), P0 = ⇑(fs.affine_combination P) W) ↔ ∃ (fs : Finset ↥S) (W : ↥S → k) (hw : fs.Sum (λ (i : ↥S), W i) = 1), P0 = ⇑(fs.affine_combination (λ (i : ↥S), P ↑i)) W
{A : Ennreal} : Add_LE_cancellable A ↔ A ≠ ⊤
{R : Type u} [CommRing R] [IsDomain R] {P q : Polynomial R} (A : R) (hzero : P + q ≠ 0) : LinearOrder.min (Polynomial.root_multiplicity A P) (Polynomial.root_multiplicity A q) ≤ Polynomial.root_multiplicity A (P + q)
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [strict_Convex_Space ℝ E] {x y z : E} : HasDist.dist x y + HasDist.dist y z = HasDist.dist x z ↔ y ∈ Segment ℝ x z
{𝕜 : Type u_1} {E : Type u_2} [normed_Linear_ordered_Field 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {A : set E} {x : E} : x ∈ set.ExposedPoints 𝕜 A ↔ IsExposed 𝕜 A {x}
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (IH : ∀ (m : Matrix (Fin r) (Fin r) 𝕜), ∃ (L₀ L₀' : List (Matrix.TransvectionStruct (Fin r) 𝕜)) (D₀ : Fin r → 𝕜), ((List.Map Matrix.TransvectionStruct.to_Matrix L₀).Prod.Mul m).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L₀').Prod = Matrix.Diagonal D₀) (m : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) : ∃ (L L' : List (Matrix.TransvectionStruct (Fin r ⊕ Unit) 𝕜)) (D : Fin r ⊕ Unit → 𝕜), ((List.Map Matrix.TransvectionStruct.to_Matrix L).Prod.Mul m).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L').Prod = Matrix.Diagonal D
{α : Type u_1} [Preorder α] [has_Add α] [HasSub α] [HasOrderedSub α] {A B : α} : A + B - B ≤ A
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {F : ℂ → E} (h : Differentiable ℂ F) (z : ℂ) {R : Nnreal} (hR : 0 < R) : HasFpowerSeriesOnBall F (Cauchy_PowerSeries F z ↑R) z ⊤
{α : Type u} {β : Type v} [TopologicalSpace α] [has_LE β] {F g : α → β} {A : α} (h : F ≤ᶠ[nhds A] g) : ∀ᶠ (y : α) in nhds A, F ≤ᶠ[nhds y] g
{α : Type u} [MetricSpace α] {x y : TopologicalSpace.Nonempty_Compacts α} : HasDist.dist x y = metric.Hausdorff_dist ↑x ↑y
{α : sort u} {F : α → α} (h : Function.involutive F) (P : Prop) [Decidable P] (x : α) : F (Ite P x (F x)) = Ite (¬P) x (F x)
{α : Type u_1} {β : Type u_2} {F : α → β} {mα : MeasurableSpace α} [MeasurableSpace β] [TopologicalSpace β] [TopologicalSpace.pseudo_metrizable_Space β] [TopologicalSpace.SecondCountableTopology β] [Opens_MeasurableSpace β] (hF : Measurable F) : MeasureTheory.strongly_Measurable F
{R : Type u_1} [CommRing R] [IsDomain R] : Prime PowerSeries.x
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {J : Type W} [CategoryTheory.Category J] (F : C ⥤ D) [CategoryTheory.Limits.HasLimits_of_shape J D] [CategoryTheory.CreatesLimitsOfShape J F] : CategoryTheory.Limits.HasLimits_of_shape J C
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} : ContDiff 𝕜 n Prod.Snd
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] (x : E) : ⇑(reflection K) x = x ↔ x ∈ K
{n n' m : ℕ} (i : Fin n') (h : n' = n) : ⇑(Fin.Add_Nat m) (⇑(Fin.cast h) i) = ⇑(Fin.cast _) (⇑(Fin.Add_Nat m) i)
(x : ℝ) : 0 ≤ Exp_Neg_Inv_glue x
{α : Type u_1} [canonically_Linear_ordered_AddMonoid α] [HasSub α] [HasOrderedSub α] {A B C : α} [ContravariantClass α α has_Add.Add has_LE.LE] (h : B ≤ A) : A - B < A - C ↔ C < B
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasLimits C] : CategoryTheory.Limits.HasColimits Cᵒᵖ
{m : Type u_1} [has_Mul m] {P : m → Prop} (x : m) {S : set m} (hs : Subsemigroup.Closure S = ⊤) (Hs : ∀ (x : m), x ∈ S → P x) (HMul : ∀ (x y : m), P x → P y → P (x * y)) : P x
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F1 F2 : α →₀ m} (hD : Disjoint F1.Support F2.Support) {β : Type u_2} [CommMonoid β] (g : α → m → β) : (F1 + F2).Prod g = F1.Prod g * F2.Prod g
{n : ℕ} {F : Typevec (n + 1) → Type u} [Mvfunctor F] [q : Mvqpf F] {α : Typevec n} (r : Mvqpf.Cofix F α → Mvqpf.Cofix F α → Prop) (h : ∀ (x y : Mvqpf.Cofix F α), r x y → Mvfunctor.Map (Typevec.Id ::: Quot.Mk r) x.dest = Mvfunctor.Map (Typevec.Id ::: Quot.Mk r) y.dest) (x y : Mvqpf.Cofix F α) : r x y → x = y
(x : Prime_Spectrum PUnit) : False
{G : Type u_1} [Group G] [Fintype G] (P : ℕ) [hp : Fact (Nat.Prime P)] (hdvd : P ∣ Fintype.Card G) : ∃ (x : G), order_of x = P
{𝕜 : Type u_1} {E : Type u_4} {Fₗ : Type u_7} [NormedGroup E] [NormedGroup Fₗ] [nondiscrete_NormedField 𝕜] [NormedSpace 𝕜 E] [NormedSpace 𝕜 Fₗ] (F : E →L[𝕜] Fₗ) (hF : uniform_Embedding ⇑F) : ∃ (K : Nnreal), AntilipschitzWith K ⇑F
{α : Type u} (S : set α) : Cardinal.Mk (↥𝒫S) = 2 ^ Cardinal.Mk ↥S
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommMonoid β] [module 𝕜 E] [module 𝕜 β] [LinearOrder E] {S : set E} {F : E → β} (hs : Convex 𝕜 S) (hF : ∀ ⦃x y : E⦄, x ∈ S → y ∈ S → x < y → ∀ ⦃A B : 𝕜⦄, 0 < A → 0 < B → A + B = 1 → F (A • x + B • y) ≤ A • F x + B • F y) : Convex_on 𝕜 S F
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] : Even (Finset.Filter (λ (v : v), Odd (G.degree v)) Finset.Univ).Card
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (e : LocalHomeomorph α β) {F : β → γ} {x : β} (h : x ∈ e.to_local_Equiv.Target) : Continuous_at F x ↔ Continuous_at (F ∘ ⇑e) (⇑(e.Symm) x)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace E] [CompleteSpace ↥K] : Continuous_LinearMap.Id 𝕜 E = K.subtypeL.Comp (Orthogonal_projection K) + Kᗮ.subtypeL.Comp (Orthogonal_projection Kᗮ)
{m : Type u_1} [AddCommMonoid m] (F S : ℕ → m) (h0 : S 0 = 0) (h : ∀ (n : ℕ), S (n + 1) = S n + F n) (n : ℕ) : (Finset.Range n).Sum (λ (k : ℕ), F k) = S n
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} {ι₂ : Type u_5} (S₂ : Finset ι₂) (e : ι₂ ↪ ι) (W : ι → k) (P : ι → P) : ⇑((Finset.Map e S₂).weighted_vsub P) W = ⇑(S₂.weighted_vsub (P ∘ ⇑e)) (W ∘ ⇑e)
{A B : ℕ} : A ⋖ B → ↑A ⋖ ↑B
{R : Type u} [Ring R] {m : module R} {ι : Type u_1} (B : Basis ι R ↥m) : CategoryTheory.Projective m
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B C : α} : A + B < C → A < C - B
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F₂ : 𝕜 → F} {S₂ : set 𝕜} {n : ℕ} (hs : IsOpen S₂) : ContDiff_on 𝕜 ↑(n + 1) F₂ S₂ ↔ DifferentiableOn 𝕜 F₂ S₂ ∧ ContDiff_on 𝕜 ↑n (deriv F₂) S₂
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] (F : C ⥤ D) {x Y : C} (F : x ⟶ Y) [CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.Span F F) F] [CategoryTheory.Epi (F.Map F)] : CategoryTheory.Epi F
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} (hs : IsOpen S) : ContDiff_on 𝕜 ⊤ F S ↔ DifferentiableOn 𝕜 F S ∧ ContDiff_on 𝕜 ⊤ (λ (y : E), fderiv 𝕜 F y) S
(v W : ℕ → ℕ) (t : omega.Nat.Preterm) : (∀ (x : ℕ), x < t.fresh_Index → v x = W x) → omega.Nat.Preterm.val v t = omega.Nat.Preterm.val W t
{α : Type u} [PseudoMetricSpace α] (x y : α) : HasDist.dist x y = (HasEdist.edist x y).to_Real
(L : FirstOrder.Language) {m : Type W} [Nonempty m] [L.structure m] (S : set m) (κ : Cardinal) (h1 : Cardinal.aleph0 ≤ κ) (h2 : (Cardinal.Mk ↥S).Lift ≤ κ.Lift) (h3 : L.Card.Lift ≤ κ.Lift) (h4 : κ.Lift ≤ (Cardinal.Mk m).Lift) : ∃ (S : L.elementary_Substructure m), S ⊆ ↑S ∧ (Cardinal.Mk ↥S).Lift = κ.Lift
{S : set Ordinal} (F : Ordinal → Ordinal) (hS : set.Unbounded has_LT.LT S) : StrictMono F ∧ set.Range F = S ↔ F = Ordinal.enum_Ord S
(Ee : List Omega.Ee) (C : Omega.Clause) : (omega.Eq_elim Ee C).Unsat → C.Unsat
{G : Type u_1} [AddGroup G] {N : Type u_2} [AddGroup N] (F : G →+ N) (hF : Function.Surjective ⇑F) : F.Range = ⊤
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (P : P) : ↑(affine_Span k {P}) = {P}
{n : ℕ} (A : Composition n) (B : Composition A.length) {i j : ℕ} (hi : i < B.length) (hj : j < B.blocks_fun ⟨i, hi⟩) : A.size_Up_to (B.size_Up_to i + j) = (A.gather B).size_Up_to i + (A.sigma_Composition_aux B ⟨i, _⟩).size_Up_to j
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] {A₁ A₂ A₃ : x} {B₁ B₂ B₃ : Y} (γ₁ : Path A₁ A₂) (δ₁ : Path A₂ A₃) (γ₂ : Path B₁ B₂) (δ₂ : Path B₂ B₃) : (γ₁.Prod γ₂).Trans (δ₁.Prod δ₂) = (γ₁.Trans δ₁).Prod (γ₂.Trans δ₂)
(x : AlgebraicGeometry.RingedSpace) (U : TopologicalSpace.Opens ↥x) (F : ↥(x.to_PresheafedSpace.presheaf.obj (Opposite.Op U))) (h : ∀ (x : ↥U), IsUnit (⇑(x.to_PresheafedSpace.presheaf.germ x) F)) : IsUnit F
{R : Type u_1} {A B : R} [Semigroup R] : IsRegular (A * B) ∧ IsRegular (B * A) ↔ IsRegular A ∧ IsRegular B
{α : Type u} {β : Type v} [UniformSpace α] [SemilatticeSup β] {K : set α} (h₁ : IsComplete K) {u : β → α} (h₂ : ∀ (n : β), u n ∈ K) (h₃ : Cauchy_Seq u) : ∃ (v : α) (h : v ∈ K), Filter.Tendsto u Filter.at_top (nhds v)
{α : Type u} [t : TopologicalSpace α] {S : set (set α)} (h_IsOpen : ∀ (u : set α), u ∈ S → IsOpen u) (h_nhds : ∀ (A : α) (u : set α), A ∈ u → IsOpen u → (∃ (v : set α) (h : v ∈ S), A ∈ v ∧ v ⊆ u)) : TopologicalSpace._topological_Basis S
{P q : ℕ} [P_Prime : Fact (Nat.Prime P)] [q_Prime : Fact (Nat.Prime q)] (neq : P ≠ q) : padic_norm P ↑q = 1
{α : Type u} [Group α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A B C : α} : B⁻¹ * A < C → A < B * C
{m : Type u_1} [has_Add m] (C : Add_Con m) : Add_Con.Add_Ker Coe _ = C
{α : Type u_1} {ι : Type u_3} {m : Type u_5} [CommMonoid m] {F : α → m} [Fintype ι] {t : ι → set α} (h : Pairwise (Disjoint on t)) (ht : ∀ (i : ι), (t i).Finite) : finprod (λ (A : α), finprod (λ (h : A ∈ ⋃ (i : ι), t i), F A)) = finprod (λ (i : ι), finprod (λ (A : α), finprod (λ (h : A ∈ t i), F A)))
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {E' : Type u_6} [NormedGroup E'] [NormedSpace 𝕜 E'] {F' : Type u_7} [NormedGroup F'] [NormedSpace 𝕜 F'] {F : E → F} {g : E' → F'} (hF : ContDiff 𝕜 n F) (hg : ContDiff 𝕜 n g) : ContDiff 𝕜 n (Prod.Map F g)
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D ⥤ C} [CategoryTheory.Reflective i] {A : C} [CategoryTheory.SplitMono ((CategoryTheory.adjunction.of_Right_Adjoint i).Unit.App A)] : A ∈ i.EssImage
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {S : set α} {x : α} {P : Filter ι} {g : ι → α} [TopologicalSpace α] (h : Continuous_within_at F S x) (hg : Filter.Tendsto g P (nhds_within x S)) (hunif : ∀ (u : set (β × β)), u ∈ Uniformity β → (∃ (t : set α) (h : t ∈ nhds_within x S), ∀ᶠ (n : ι) in P, ∀ (y : α), y ∈ t → (F y, F n y) ∈ u)) : Filter.Tendsto (λ (n : ι), F n (g n)) P (nhds (F x))
{α : Type u_1} {S : set α} [MeasurableSpace α] (hs : S.Infinite) : ⇑MeasureTheory.Measure.count S = ⊤
{C : Type u₁} [CategoryTheory.Category C] {x : C} {S : CategoryTheory.Sieve x} {P : Cᵒᵖ ⥤ Type v₁} (x : S.Functor ⟶ P) (g : CategoryTheory.yoneda.obj x ⟶ P) : S.Functor_inclusion ≫ g = x ↔ (⇑CategoryTheory.Presieve.Nat_Trans_Equiv_compatible_family x).val._amalgamation (⇑CategoryTheory.yoneda_Equiv g)
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F g : α → m} {S : set α} (hF : (S ∩ Function.MulSupport F).Finite) (hg : (S ∩ Function.MulSupport g).Finite) : finprod (λ (i : α), finprod (λ (h : i ∈ S), F i * g i)) = finprod (λ (i : α), finprod (λ (h : i ∈ S), F i)) * finprod (λ (i : α), finprod (λ (h : i ∈ S), g i))
{α : Type u_1} {E : Type u_2} (R : Type u_3) [AddCommGroup E] [DivisionRing R] [Monoid α] [module R E] [Distrib_MulAction α E] (n : ℤ) (S : α) (x : E) : (↑n)⁻¹ • S • x = S • (↑n)⁻¹ • x
(R : Type u_1) [has_One R] [HasNeg R] : Cardinal.Mk ↥set.Univ = Cardinal.Mk R ^ 4
{α : Type u_1} [LinearOrder α] (S : Finset α) (h₂ : 1 < S.Card) : S.min' _ < S.max' _
{x : Type u_1} [TopologicalSpace x] (hX : ∀ {x y : x}, x ≠ y → (∃ (U : set x) (h_IsClopen : IsClopen U), x ∈ U ∧ y ∉ U)) : IsTotallyDisconnected set.Univ
{A : Type u_1} {F : Type u_2} [MulZeroOneClass A] [Monoid_with_ZeroHom_class F ℕ A] (F g : F) (h_Pos : ∀ {n : ℕ}, 0 < n → ⇑F n = ⇑g n) : F = g
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) : x = y ↔ ∥x∥ = ∥y∥ ∧ o.oangle x y = 0
{n : ℕ} (P : Fin (n + 1)) (i : Fin n) : ⇑Fin.cast_Succ i < P ∨ P ≤ ⇑Fin.cast_Succ i
{n : ℕ} {i : Fin (n + 1)} (h : 0 < i) : 0 < ⇑Fin.cast_Succ i
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) : HasInner.inner x y = ∥x∥ * ∥y∥ ↔ InnerProductGeometry.angle x y = 0
{m : Type u_1} [CommMonoid_with_Zero m] {P : m} {L : List m} (pp : Prime P) : P ∣ L.Prod ↔ ∃ (A : m) (h : A ∈ L), P ∣ A
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [Ring_hom_isometric σ₁₂] : ∥0∥ = 0
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LE.LE] {A B : α} (ha : 1 ≤ A) (hb : 1 < B) : 1 < A * B
(x : AlgebraicGeometry.RingedSpace) (U : TopologicalSpace.Opens ↥x) (F : ↥(x.to_PresheafedSpace.presheaf.obj (Opposite.Op U))) (x : ↥U) (h : IsUnit (⇑(x.to_PresheafedSpace.presheaf.germ x) F)) : ∃ (v : TopologicalSpace.Opens ↥x) (i : v ⟶ U) (hxV : x.val ∈ v), IsUnit (⇑(x.to_PresheafedSpace.presheaf.Map i.Op) F)
{J : Type u₁} [CategoryTheory.Category J] {K : Type u₂} [CategoryTheory.Category K] {C : Type u} [CategoryTheory.Category C] {F : J ⥤ C} (e : K ≌ J) [CategoryTheory.Limits.HasColimit (e.Functor ⋙ F)] : CategoryTheory.Limits.HasColimit F
{α : Type u} [PseudoMetricSpace α] {S t : set α} (hs : S.Nonempty) (ht : t.Nonempty) (bs : Metric.Bounded S) (bt : Metric.Bounded t) : Emetric.Hausdorff_edist S t ≠ ⊤
{D : set ℝ} (hD : Convex ℝ D) {F : ℝ → ℝ} (hF : Continuous_on F D) (hF' : DifferentiableOn ℝ F (Interior D)) {C : ℝ} (LT_hF' : ∀ (x : ℝ), x ∈ Interior D → deriv F x < C) (x : ℝ) (h : x ∈ D) (y : ℝ) (h_1 : y ∈ D) : x < y → F y - F x < C * (y - x)
{x : Type u_1} [TopologicalSpace x] {S : set x} (hs : _Seq_IsClosed S) {x : ℕ → x} (hmem : ∀ (n : ℕ), x n ∈ S) {A : x} (ha : Filter.Tendsto x Filter.at_top (nhds A)) : A ∈ S
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {F : C ⥤ D} {Y Y' : D} (h : Y ≅ Y') (hY : Y ∈ F.EssImage) : Y' ∈ F.EssImage
{m : Type u_1} [has_Add m] {P : m → Prop} (x : m) {S : set m} (hs : Add_Subsemigroup.Closure S = ⊤) (Hs : ∀ (x : m), x ∈ S → P x) (HMul : ∀ (x y : m), P x → P y → P (x + y)) : P x
{m : Type u_3} {N : Type u_4} [MulOneClass m] [MulOneClass N] {F g : m →* N} (h : F = g) (x : m) : ⇑F x = ⇑g x
{A : Type u} {B : Type v} {ι : Type W} [CommRing A] [CommRing B] [Algebra A B] [Fintype ι] [DecidableEq ι] (B : ι → B) (P : Matrix ι ι A) : Algebra.discr A ((P.Map ⇑(Algebra_Map A B)).Mul_vec B) = P.det ^ 2 * Algebra.discr A B
{α : sort u} [DecidableEq α] {β : sort u_1} (F : α → β) (A' : α) (B : β) (A : α) : Function.update F A' B A = Ite (A = A') B (F A)
{α : Type u_1} {l : Filter α} {P : α → Prop} : (∀ᶠ (x : α) in l, P x) → (∀ᶠ (S : set α) in l.Small_sets, ∀ (x : α), x ∈ S → P x)
{n n' : ℕ} (i : Fin n) (h : n.Succ = n'.Succ) : ⇑(Fin.cast h) i.Succ = (⇑(Fin.cast _) i).Succ
{ι : Type v} {ι' : Type v'} (F : ι → Cardinal) (F' : ι' → Cardinal) (g : ι → ι') (h : ∀ (i : ι), (F i).Lift ≤ (F' (g i)).Lift) : (Cardinal.Sup F).Lift ≤ (Cardinal.Sup F').Lift
(R : Type u_5) [Semiring R] (m : Type u_1) [AddCommMonoid m] [module R m] : Function.Surjective ⇑(Finsupp.Total m m R Id)
{x : Type u_1} [TopologicalSpace x] [CompactSpace x] (A : Subalgebra ℝ C(x, ℝ)) (W : A.separates_points) (F : C(x, ℝ)) : F ∈ A.topological_Closure
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] [DecidableEq v] : Finset.Univ.Sum (λ (v : v), G.degree v) = 2 * G.edge_Finset.Card
{C : Type u₁} [CategoryTheory.Category C] (P : Cᵒᵖ ⥤ Type (max v₁ u₁)) {x : C} (S : CategoryTheory.Sieve x) (x : CategoryTheory.Equalizer.FirstObj P ⇑S) : ((CategoryTheory.Equalizer.FirstObj_Eq_family P ⇑S).hom x).compatible ↔ CategoryTheory.Equalizer.Sieve.first_Map P S x = CategoryTheory.Equalizer.Sieve.second_Map P S x
(Fq F : Type) [Field Fq] [Fintype Fq] [Field F] [Algebra (Polynomial Fq) F] [Algebra (Ratfunc Fq) F] [IsScalarTower (Polynomial Fq) (Ratfunc Fq) F] [Function_Field Fq F] [_IsSeparable (Ratfunc Fq) F] : Function_Field.ClassNumber Fq F = 1 ↔ _principal_Ideal_Ring ↥(Function_Field.Ring_of_integers Fq F)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] {A : α} (h : (set.Iio A).Nonempty) : Closure (set.Iio A) = set.Iic A
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : Fin 3 → P) : AffineIndependent k P ↔ ¬Collinear k (set.Range P)
{F : Type u_3} [Field F] [Fintype F] : Ring_Char F = 2 ↔ Fintype.Card F % 2 = 0
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] {F : E → F} (hF : Differentiable ℂ F) (hb : Metric.Bounded (set.Range F)) (z W : E) : F z = F W
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x ⟶ Y} [CategoryTheory.Limits.HasEqualizer F g] (h : F = g) : CategoryTheory.IsIso (CategoryTheory.Limits.Equalizerι F g)
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {δ : Type u_1} [LinearOrder δ] [TopologicalSpace δ] [order_IsClosed_topology δ] {S : set α} [hs : S.Ord_connected] {F : α → δ} (hF : Continuous_on F S) {A B : α} (ha : A ∈ S) (hb : B ∈ S) : set.surj_on F S (set.Interval (F A) (F B))
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {A : F} : Char.quadratic_Char F A = -1 ↔ ¬IsSquare A
{α : Type u_1} [TopologicalSpace α] [non_unital_non_assoc_Ring α] [topological_Ring α] (x : α) : Continuous ⇑(AddMonoid_hom.Mul_Left x)
(P : Prop) [Decidable P] : P ∨ ¬P
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) {r : Nnreal} (h : ↑r < P.radius) : ∃ (A : ℝ) (h : A ∈ set.Ioo 0 1) (C : ℝ) (h : C > 0), ∀ (n : ℕ), ∥P n∥ * ↑r ^ n ≤ C * A ^ n
{J : Type u₁} [CategoryTheory.Category J] [Nonempty J] {j₀ : J} (h : ∀ (P : set J), j₀ ∈ P → (∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → (j₁ ∈ P ↔ j₂ ∈ P)) → ∀ (j : J), j ∈ P) : CategoryTheory.IsConnected J
{m : Type u_1} [AddMonoid m] (S : Add_Submonoid m) {l : List m} (hl : ∀ (x : m), x ∈ l → x ∈ S) : l.Sum ∈ S
{α : Type u_1} {β : Type u_2} (P : Pmf α) (F : α → Pmf β) (S : set β) [MeasurableSpace β] (hs : Measurable_set S) : ⇑((P.Bind F).to_measure) S = ∑' (A : α), ↑(⇑P A) * ⇑((F A).to_measure) S
{G : Type u_1} [Group G] (h : Subgroup G) : 1 ∈ h
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {D : Type u₁} [CategoryTheory.Category D] (h : C ≌ D) : CategoryTheory.IsCofiltered D
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) : _R_or_C.Abs (HasInner.inner x y) * _R_or_C.Abs (HasInner.inner y x) ≤ ⇑_R_or_C.re (HasInner.inner x x) * ⇑_R_or_C.re (HasInner.inner y y)
{A B C m : ℕ} (hmc : m.Gcd C = 1) (h : A * C ≡ B * C [Mod m]) : A ≡ B [Mod m]
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] {x : m} {S : set m} {P : m → Prop} (h : x ∈ Submodule.Span R S) (Hs : ∀ (x : m), x ∈ S → P x) (h0 : P 0) (h1 : ∀ (x y : m), P x → P y → P (x + y)) (h2 : ∀ (A : R) (x : m), P x → P (A • x)) : P x
{α : Type u_1} {ι : sort u_3} [conditionally_complete_LinearOrder α] {A : α} [Nonempty ι] {F : ι → α} (h : infi F < A) : ∃ (i : ι), F i < A
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {S : set E} {F : E → F} {x : E} {n : WithTop ℕ} (e : G ≃L[𝕜] E) : ContDiff_within_at 𝕜 n (F ∘ ⇑e) (⇑e ⁻¹' S) (⇑(e.Symm) x) ↔ ContDiff_within_at 𝕜 n F S x
{m : Type u_6} {N : Type u_7} [has_Mul m] [has_Mul N] {F g : m ≃* N} (h : ∀ (x : m), ⇑F x = ⇑g x) : F = g
{C : Type v} [CategoryTheory.SmallCategory C] {D : Type v} [CategoryTheory.SmallCategory D] {L : C ⥤ D} {R : D ⥤ C} (Adj : L ⊣ R) : R.final
(S B : ℝ) (hb : 0 < B) : Filter.Tendsto (λ (x : ℝ), Real.Exp (B * x) / x ^ S) Filter.at_top Filter.at_top
{R : Type u} {ι : Type W} (S : Finset ι) [CommSemiring R] (F : ι → Polynomial R) (h : S.Prod (λ (i : ι), (F i).leading_Coeff) ≠ 0) : (S.Prod (λ (i : ι), F i)).leading_Coeff = S.Prod (λ (i : ι), (F i).leading_Coeff)
{x : top} {Y : TopologicalSpace.Opens ↥x} (R : CategoryTheory.Presieve Y) : top.Presheaf.Presieve_of_covering_aux (top.Presheaf.covering_of_Presieve Y R) Y = R
{α : Type u_1} {β : Type u_2} {m : Type u_3} [Fintype α] [Fintype β] [AddCommMonoid m] (e : α → β) (hE : Function.Bijective e) (F : α → m) (g : β → m) (h : ∀ (x : α), F x = g (e x)) : Finset.Univ.Sum (λ (x : α), F x) = Finset.Univ.Sum (λ (x : β), g x)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {S : set E} {F : E → F} {x : E} {n : WithTop ℕ} (g : F →L[𝕜] G) (hF : ContDiff_within_at 𝕜 n F S x) : ContDiff_within_at 𝕜 n (⇑g ∘ F) S x
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] {g1 g2 : G} (P : P) (h : g1 +ᵥ P = g2 +ᵥ P) : g1 = g2
{α : Type u_1} {β : Type u_2} (r : α → α → Prop) (S : β → β → Prop) [IsTrichotomous α r] [IsIrrefl β S] (F : α → β) (hF : ∀ {x y : α}, r x y → S (F x) (F y)) : Function.Injective F
{α : Type u_1} {β : Type u_3} {γ : Type u_5} {F F' : α → β → γ} {S : set α} {t : set β} (h : ∀ (A : α) (B : β), F A B = F' A B) : set.image2 F S t = set.image2 F' S t
{m : Type u_1} [has_Add m] {C D : Add_Con m} (h : C.to_Setoid = D.to_Setoid) : C = D
{C : Type u} [CategoryTheory.Category C] {x Y : C} [CategoryTheory.Limits.HasZeroMorphisms C] (F : x ⟶ Y) [CategoryTheory.Limits.HasKernel F] {Z : C} (h : Y ⟶ Z) [CategoryTheory.Limits.HasKernel (F ≫ h)] : CategoryTheory.Limits.Kernel_Subobject F ≤ CategoryTheory.Limits.Kernel_Subobject (F ≫ h)
{K : Type u} {v : Type v} [Field K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {F g : v →ₗ[K] v} : F * g = 1 ↔ g * F = 1
{v : Type u_1} [InnerProductSpace ℝ v] {x : v} (hx : x ≠ 0) : InnerProductGeometry.angle (-x) x = Real.Pi
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] {P1 P2 : P} (P3 : P) (hp1 : P1 ∈ S) (hp2 : P2 ∈ S) : HasDist.dist P1 P3 = HasDist.dist P2 P3 ↔ HasDist.dist P1 ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P3) = HasDist.dist P2 ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P3)
{m : Type u_1} [AddCommMonoid m] (S : Add_Submonoid m) {ι : Type u_2} {t : Finset ι} {F : ι → m} (h : ∀ (C : ι), C ∈ t → F C ∈ S) : t.Sum (λ (C : ι), F C) ∈ S
{J : Type u₁} [CategoryTheory.Category J] [CategoryTheory.IsPreconnected J] {α : Type u₁} (F : J → α) (h : ∀ (j₁ j₂ : J), (j₁ ⟶ j₂) → F j₁ = F j₂) (j j' : J) : F j = F j'
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) {x : E} : P.radius - ↑∥x∥₊ ≤ (P.change_origin x).radius
{R : Type u_1} [CommMonoid_with_Zero R] (n : R) : Prime_Pow n ↔ ∃ (P : R) (k : ℕ), Prime P ∧ P ^ (k + 1) = n
(C : ℂ) (R : ℝ) : Function.Periodic (Circle_Map C R) (2 * Real.Pi)
{α : Type u} [PseudoEmetricSpace α] (x y z : α) : HasEdist.edist x y ≤ HasEdist.edist z x + HasEdist.edist z y
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (S₁ S₂ : AffineSubspace ℝ P) [Nonempty ↥S₁] [Nonempty ↥S₂] [CompleteSpace ↥(S₁.direction)] [CompleteSpace ↥(S₂.direction)] (P : P) : ⇑(EuclideanGeometry.reflection S₁) P = ⇑(EuclideanGeometry.reflection S₂) P ↔ ↑(⇑(EuclideanGeometry.Orthogonal_projection S₁) P) = ↑(⇑(EuclideanGeometry.Orthogonal_projection S₂) P)
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] {n : ℕ} (A B : Fin (n + 1) → ℝ) (hle : A ≤ B) (F : (Fin (n + 1) → ℝ) → Fin (n + 1) → E) (F' : (Fin (n + 1) → ℝ) → ((Fin (n + 1) → ℝ) →L[ℝ] Fin (n + 1) → E)) (S : set (Fin (n + 1) → ℝ)) (hs : S.countable) (Hc : Continuous_on F (set.icc A B)) (hD : ∀ (x : Fin (n + 1) → ℝ), x ∈ set.Univ.Pi (λ (i : Fin (n + 1)), set.Ioo (A i) (B i))  S → HasFderivAt F (F' x) x) (Hi : MeasureTheory.IntegrableOn (λ (x : Fin (n + 1) → ℝ), Finset.Univ.Sum (λ (i : Fin (n + 1)), ⇑(F' x) (Pi.single i 1) i)) (set.icc A B) MeasureTheory.MeasureSpace.Volume) : ∫ (x : Fin (n + 1) → ℝ) in set.icc A B, Finset.Univ.Sum (λ (i : Fin (n + 1)), ⇑(F' x) (Pi.single i 1) i) = Finset.Univ.Sum (λ (i : Fin (n + 1)), (∫ (x : Fin n → ℝ) in set.icc (A ∘ ⇑(i.Succ_above)) (B ∘ ⇑(i.Succ_above)), F (i.Insert_nth (B i) x) i) - ∫ (x : Fin n → ℝ) in set.icc (A ∘ ⇑(i.Succ_above)) (B ∘ ⇑(i.Succ_above)), F (i.Insert_nth (A i) x) i)
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {F : α → E} {g : α → F} {l : Filter α} : F =o[l] g ↔ ∀ ⦃C : ℝ⦄, 0 < C → (∀ᶠ (x : α) in l, ∥F x∥ ≤ C * ∥g x∥)
{α : Type u_1} [has_Add α] [Preorder α] [CovariantClass α α has_Add.Add has_LT.LT] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B C D : α} (h₁ : A < B) (h₂ : C < D) : A + C < B + D
{α : Type u_1} [CommSemiring α] (E : LinearRecurrence α) (init : Fin E.order → α) (n : Fin E.order) : E.Mk_sol init ↑n = init n
{C : Type u₁} [CategoryTheory.Category C] {A : Type u₂} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (P : Cᵒᵖ ⥤ A) [CategoryTheory.Limits.HasProducts A] [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Presheaf.IsSheaf J P ↔ CategoryTheory.Presheaf.IsSheaf' J P
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} {ps : set P} (h : ps ⊆ ↑S) [Nonempty ↥S] {n : ℕ} [Finite_dimensional ℝ ↥(S.direction)] (hD : Finite_dimensional.finrank ℝ ↥(S.direction) = n) (hc : EuclideanGeometry.Cospherical ps) {sx₁ sx₂ : Affine.Simplex ℝ P n} (hsx₁ : set.Range sx₁.points ⊆ ps) (hsx₂ : set.Range sx₂.points ⊆ ps) : sx₁.circumcenter = sx₂.circumcenter
{α : Type u_1} {β : Type u_2} [CompleteLattice α] (A : α) (F : β → α) : (⨅ (o : Option β), Option.elim A F o) = A ⊓ ⨅ (B : β), F B
{m : Type u_6} {N : Type u_7} [has_Add m] [has_Add N] (e : m ≃+ N) (y : N) : ⇑e (⇑(e.Symm) y) = y
{β : Type u_4} [LinearOrder β] [NoMinOrder β] {u : ℕ → β} (hu : Filter.Tendsto u Filter.at_top Filter.at_IsBot) (N : ℕ) : ∃ (n : ℕ) (h : n ≥ N), ∀ (k : ℕ), k < n → u n < u k
{α : Type u_1} {m : Type u_5} {N : Type u_7} [has_Zero m] [CommMonoid N] (F : α →₀ m) (y : α) (g : α → m → N) (hg : ∀ (i : α), g i 0 = 1) : g y (⇑F y) * (Finsupp.erase y F).Prod g = F.Prod g
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] {P1 P2 P : P} : P1 -ᵥ P = P2 -ᵥ P ↔ P1 = P2
{α : Type u} [Linear_ordered_Ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B : α} (ha : A < 0) (hb : B < 0) : A + B < 0
{α : Type u_1} [Subsingleton α] (S : Finset α) : S.Card ≤ 1
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasKernels C] {x Y : C} [CategoryTheory.Simple x] [CategoryTheory.Simple Y] {F : x ⟶ Y} (W : F ≠ 0) : CategoryTheory.IsIso F
{P : ℕ} {G : Type u_1} [Group G] (hG : _P_Group P G) [hp : Fact (Nat.Prime P)] (α : Type u_2) [MulAction G α] [Fintype α] [Fintype ↥(MulAction.FixedPoints G α)] : Fintype.Card α ≡ Fintype.Card ↥(MulAction.FixedPoints G α) [Mod P]
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Simple 0] : False
{R : Type u_1} {A B : R} [AddMonoid R] (h : A + B = 0) : _Add_Right_regular A
{α : Type u_1} {β : Type u_2} [AddGroup α] [AddCommGroup β] {F g : α → β} (hF : _AddGroup_hom F) (hg : _AddGroup_hom g) : _AddGroup_hom (λ (A : α), F A + g A)
{G : Type u_1} [Group G] [hN : Nontrivial G] : Monoid._torsion_free G → ¬Monoid._torsion G
{ι : Type u_1} {R : Type u_2} (S : Type u_3) {m : ι → Type u_4} {N : Type u_5} [decι : DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (m i)] [Π (i : ι), module R (m i)] [AddCommMonoid N] [module R N] [Semiring S] [module S N] [SmulCommClass R S N] (F : Π (i : ι), m i →ₗ[R] N) (i : ι) (x : m i) : ⇑(⇑(Dfinsupp.lsum S) F) (Dfinsupp.single i x) = ⇑(F i) x
{α : Type u_1} {g g' : GeneralizedContinuedFraction α} : g = g' ↔ g.h = g'.h ∧ g.S = g'.S
{A : ℝ} {l : Filter ℝ} {F F' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in nhds_within A (set.ioi A), HasDerivAt F (F' x) x) (hgg' : ∀ᶠ (x : ℝ) in nhds_within A (set.ioi A), HasDerivAt g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in nhds_within A (set.ioi A), g' x ≠ 0) (hfa : Filter.Tendsto F (nhds_within A (set.ioi A)) (nhds 0)) (hga : Filter.Tendsto g (nhds_within A (set.ioi A)) (nhds 0)) (HDiv : Filter.Tendsto (λ (x : ℝ), F' x / g' x) (nhds_within A (set.ioi A)) l) : Filter.Tendsto (λ (x : ℝ), F x / g x) (nhds_within A (set.ioi A)) l
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {P : Filter ι} [TopologicalSpace α] (h : TendstoLocallyUniformly F F P) (hc : ∀ᶠ (n : ι) in P, Continuous (F n)) [P.Ne_IsBot] : Continuous F
{R : Type u_1} [CommRing R] (m : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization m S] {ι : Type u_3} (S : Finset ι) (F : ι → S) : ∃ (B : ↥m), ∀ (i : ι), i ∈ S → IsLocalization._integer R (↑B • F i)
(𝕜 : Type u_1) (E : Type u_2) [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] (v : Fin 1 → E) : ⇑(FormalMultilinearSeries.Id 𝕜 E 1) v = v 0
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {x Y : AlgebraicGeometry.PresheafedSpace C} (α β : x ⟶ Y) (h₁ : α = β) (x x' : ↥x) (h₂ : x = x') : AlgebraicGeometry.PresheafedSpace.stalk_Map α x ≫ CategoryTheory.Eq_to_hom _ = CategoryTheory.Eq_to_hom _ ≫ AlgebraicGeometry.PresheafedSpace.stalk_Map β x'
{α : Type u_1} {β : Type u_2} [has_Add α] [Preorder α] [Preorder β] {F g : β → α} [CovariantClass α α has_Add.Add has_LE.LE] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] (hF : StrictMono F) (hg : Monotone g) : StrictMono (λ (x : β), F x + g x)
{α : Type u_1} [CompleteLattice α] {S : set α} {B : α} : (∀ (A : α), A ∈ S → B ≤ A) → (∀ (W : α), B < W → (∃ (A : α) (h : A ∈ S), A < W)) → HasInf.Inf S = B
{α : Type u_1} {E : Type u_3} [TopologicalSpace α] [CompactSpace α] [NormedGroup E] (F : C(α, E)) {C : ℝ} (C0 : 0 ≤ C) : ∥F∥ ≤ C ↔ ∀ (x : α), ∥⇑F x∥ ≤ C
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] [DenselyOrdered β] {F : α → β} (h_Mono : Monotone F) (h_Dense : DenseRange F) : Continuous F
{α : Type u} [PseudoMetricSpace α] {S t : set α} (h : S ⊆ t) (ht : Metric.Bounded t) : Metric.diam S ≤ Metric.diam t
{ι : sort u_1} {F : ι → Ennreal} {x : Ennreal} (h0 : x ≠ 0) (h : x ≠ ⊤) : x * infi F = ⨅ (i : ι), x * F i
{m : Type u_1} {N : Type u_2} [AddZeroClass m] [AddZeroClass N] (h : m ≃+ N) : _Add_hom ⇑h
{m : Type u_1} [has_Add m] (C : Add_Con m) {W x y z : m} : ⇑C W x → ⇑C y z → ⇑C (W + y) (x + z)
{α : Type u} [PseudoMetricSpace α] {S : set α} (hs : TopologicalSpace._IsSeparable S) : TopologicalSpace.IsSeparable_Space ↥S
{R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] {n : ℕ} (h : ∀ (S : Finset m), LinearIndependent R (λ (i : ↥S), ↑i) → S.Card ≤ n) (S : set m) : LinearIndependent R Coe → Cardinal.Mk ↥S ≤ ↑n
{R : Type u} [Ring R] {S t : Subring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ t) : S = t
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {x y : L} : x ∈ S → y ∈ S → x + y ∈ S
{α : sort u} : WellFounded Empty_Relation
{α : Type u} {G : Type W} [TopologicalSpace G] [has_Inv G] [has_Continuous_Inv G] {F : α → G} {l : Filter α} {y : G} (h : Filter.Tendsto F l (nhds y)) : Filter.Tendsto (λ (x : α), (F x)⁻¹) l (nhds y⁻¹)
{α : Type u_1} {ι : Type u_2} {x : ι → α} {F : Filter α} {l : Filter ι} [l._countably_generated] (hxy : ∀ (ns : ℕ → ι), Filter.Tendsto ns Filter.at_top l → (∃ (ms : ℕ → ℕ), Filter.Tendsto (λ (n : ℕ), x (ns (ms n))) Filter.at_top F)) : Filter.Tendsto x l F
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F g : α → m} {S : set α} (hF : (S ∩ Function.Support F).Finite) (hg : (S ∩ Function.Support g).Finite) : finsum (λ (i : α), finsum (λ (h : i ∈ S), F i + g i)) = finsum (λ (i : α), finsum (λ (h : i ∈ S), F i)) + finsum (λ (i : α), finsum (λ (h : i ∈ S), g i))
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (m : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (i : Fin r ⊕ Unit) : m.Mul (Matrix.Pivot.List_transvec_row m).Prod i (Sum.inr_ ()) = m i (Sum.inr_ ())
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {z : ℂ} {F : ℂ → E} (h : Differentiable_at ℂ F z) (hF' : deriv F z ≠ 0) : ConformalAt F z
{R : Type u_1} {m : Type u_2} [CommSemiring R] [AddCommMonoid m] [module R m] (A : R) : module._IsTorsionBy R m A ↔ Submodule.IsTorsionBy R m A = ⊤
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_3} [DecidableEq ι] [Fintype ι] (e₁ e₂ : Basis ι R m) : e₁.Orientation = e₂.Orientation ↔ 0 < ⇑(e₁.det) ⇑e₂
{α : Type u} {l : List α} : l.attach.Nodup → l.Nodup
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : E → ℝ} {A : E} {S : set E} (h : IsLocalMaxOn F S A) {y : E} (hy : y ∈ Pos_TangentConeAt S A) (hy' : -y ∈ Pos_TangentConeAt S A) : ⇑(fderiv_within ℝ F S A) y = 0
{A : Type u_1} {K : Type u_2} [CommRing A] [IsDomain A] [Unique_factorization_Monoid A] [Field K] [Algebra A K] [_fraction_Ring A K] {P : Polynomial A} {r : K} (hr : ⇑(Polynomial.aeval r) P = 0) : _fraction_Ring.Num A r ∣ P.Coeff 0
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] (S : Subalgebra R A) (HS : S.to_Submodule.fg) (x : A) (hx : x ∈ S) : IsIntegral R x
{R : Type u} [CommRing R] (U v : TopologicalSpace.Opens ↥(AlgebraicGeometry.Prime_Spectrum.top R)) (iVU : v ⟶ U) : AlgebraicGeometry.StructureSheaf.comap (Ring_hom.Id R) U v _ = (AlgebraicGeometry.spec.StructureSheaf R).val.Map iVU.Op
{m : Type u_1} [AddCommMonoid m] {S t : set m} {x : m} : x ∈ AddMonoid.Closure (S ∪ t) ↔ ∃ (y : m) (h : y ∈ AddMonoid.Closure S) (z : m) (h : z ∈ AddMonoid.Closure t), y + z = x
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) : ∥x + y∥ = ∥x - y∥ ↔ InnerProductGeometry.angle x y = Real.Pi / 2
{α : Type u} [PseudoEmetricSpace α] {δ : ℝ} {E : set α} : IsOpen (Metric.Thickening δ E)
(u : pnat.xgcd_Type) (hr : u.r ≠ 0) : u.step.v = u.v.Swap
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : S ⊆ SpanPoints k S
{α : Type u_1} [Preorder α] [SuccOrder α] {A B : α} [NoMaxOrder α] : Order.Succ A < Order.Succ B → A < B
{α : Type u_1} [generalized_boolean_Algebra α] [Decidable_Rel Disjoint] [Decidable_Rel has_LE.LE] {S : Finset α} {u v A : α} (ha : A ∈ Uv.Compression u v S) (hva : v ≤ A) (hvu : v = ⊥ → u = ⊥) : A ∈ S
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {F : ℂ → E} (hD : Diff_Cont_on_cl ℂ F (set.Iio 0 ×ℂ set.ioi 0)) (hB : ∃ (C : ℝ) (h : C < 2) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal (set.Iio 0 ×ℂ set.ioi 0)] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hre : ∀ (x : ℝ), x ≤ 0 → F ↑x = 0) (him : ∀ (x : ℝ), 0 ≤ x → F (↑x * Complex.i) = 0) : set.Eq_on F 0 {z : ℂ | z.re ≤ 0 ∧ 0 ≤ z.im}
{α : Type u_3} {β : Type u_4} [Preorder α] [Preorder β] {F : α → β} (hF : Monotone F) (h : ∀ (B : β), ∃ (A : α), B ≤ F A) : Filter.Tendsto F Filter.at_top Filter.at_top
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} : Differentiable 𝕜 F → Mdifferentiable (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F
{α : Type u_1} [Linear_ordered_Field α] {A : α} (A2 : 2 ≤ A) : (1 - 1 / A)⁻¹ ≤ 2
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (R : D ⥤ C) [CategoryTheory.Limits.HasLimits_of_size C] [CategoryTheory.Reflective R] : CategoryTheory.Limits.HasLimits_of_size D
(𝕜 : Type v) [_R_or_C 𝕜] {E : Type u} [NormedGroup E] [NormedSpace 𝕜 E] [Nontrivial E] (x : E) : ∃ (g : E →L[𝕜] 𝕜), ∥g∥ = 1 ∧ ⇑g x = ↑∥x∥
{R : Type u_1} {S : Type u_2} {m : Type u_3} {A : R} {S : S} [HasScalar R m] [HasScalar R S] [HasScalar S m] [IsScalarTower R S m] (ra : IsSmulRegular m A) (rs : IsSmulRegular m S) : IsSmulRegular m (A • S)
{G : Type u} [Group G] (h : Subgroup G) (h : Subsingleton (G ⧸ h)) : h = ⊤
{α : Type u_1} {n : Type u_3} {m : Type u_4} {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α} {D : Matrix n n α} (hA : A.IsSymm) (hBC : B.transpose = C) (hD : D.IsSymm) : (Matrix.from_blocks A B C D).IsSymm
{m : Type u_1} [Semigroup m] {A : Stream m} {m : m} (hm : m ∈ Hindman.FP A) : ∃ (n : ℕ), ∀ (m' : m), m' ∈ Hindman.FP (Stream.Drop n A) → m * m' ∈ Hindman.FP A
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) : hb.oangle x y = θ ↔ ∃ (r : ℝ), 0 < r ∧ y = r • ⇑(hb.rotation θ) x
{𝕜 : Type u_1} {E : Type u_2} [Linear_ordered_Field 𝕜] [ordered_AddCommGroup E] [module 𝕜 E] {S : set E} (hs : Convex 𝕜 S) : IsLeast {t : Convex_cone 𝕜 E | S ⊆ ↑t} (Convex.to_cone S hs)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {F : 𝕜 → F} {S : set 𝕜} {x : 𝕜} {m : Fin n → 𝕜} : ⇑(iterated_fderiv_within 𝕜 n F S x) m = Finset.Univ.Prod (λ (i : Fin n), m i) • iterated_deriv_within n F S x
(C : ℂ) : ⇑clifford_Algebra_Complex.of_Complex (⇑(Star_Ring_end ℂ) C) = ⇑clifford_Algebra.involute (⇑clifford_Algebra_Complex.of_Complex C)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (F : v ≃ₗᵢ[ℝ] v) : ∃ (θ : Real.Angle), F = hb.rotation θ ∨ F = hb.Conj_lie.Trans (hb.rotation θ)
{ι : Type u} (S : Finset ι) (W z : ι → Nnreal) (hw' : S.Sum (λ (i : ι), W i) = 1) : S.Prod (λ (i : ι), z i ^ ↑(W i)) ≤ S.Sum (λ (i : ι), W i * z i)
{x : ℝ} (lx : Liouville x) : Transcendental ℤ x
{F : ℝ → ℝ} {A B : ℝ} (hfi : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (h : ∀ (x : ℝ), 0 < F x) (hab : A < B) : 0 < ∫ (x : ℝ) in A..B, F x
{A B C D B' D' : SemiNormedGroup} {fab : A ⟶ B} {fbd : B ⟶ D} {fac : A ⟶ C} {fcd : C ⟶ D} {h : fab ≫ fbd = fac ≫ fcd} {fbb' : B ⟶ B'} {fdd' : D ⟶ D'} {condb : fab ≫ fbb' = 0} {condd : fcd ≫ fdd' = 0} {g : B' ⟶ D'} (h' : fbb' ≫ g = fbd ≫ fdd') : SemiNormedGroup.explicit_Cokernel_Desc condb ≫ g = SemiNormedGroup.explicit_Cokernel.Map h ≫ SemiNormedGroup.explicit_Cokernel_Desc condd
{R : Type u_1} [Semiring R] (P : Polynomial R) : ⇑Polynomial.to_laurent P = Finsupp.Map_IsDomain Coe P.to_Finsupp
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {F : E → F} {P : E → FormalMultilinearSeries ℝ E F} {S : set E} {x : E} (hF : HasFtaylorSeriesUpToOn 1 F P (HasInsert.Insert x S)) (hs : Convex ℝ S) : ∃ (K : Nnreal) (t : set E) (h : t ∈ nhds_within x S), LipschitzOnWith K F t
{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] {m : m} {S : set m} : m ∈ Submodule.Span R S ↔ ∃ (C : m →₀ R), ↑(C.Support) ⊆ S ∧ C.Sum (λ (mi : m) (r : R), r • mi) = m
{x : Type u_1} {Y : Type u_2} {F : x → Y} (hF : Function.Injective F) : TopologicalSpace.induced F ⊥ = ⊥
{α : Type u_1} {F : α → Ennreal} (hF : ∑' (x : α), F x ≠ ⊤) : Filter.Tendsto (λ (S : Finset α), ∑' (B : {x // x ∉ S}), F ↑B) Filter.at_top (nhds 0)
(𝕜 : Type u_1) (E : Type u_2) [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {n : ℕ} (h : n ≠ 1) : FormalMultilinearSeries.Id 𝕜 E n = 0
{α : Type u} {β : Type v} {γ : Type W} [TopologicalSpace α] [PseudoMetricSpace β] [PseudoMetricSpace γ] {G : β → γ} {C : Nnreal} (h : LipschitzWith C G) : LipschitzWith C (bounded_Continuous_Function.Comp G h)
{Γ : Type u_1} [Inhabited Γ] (l : Turing.List_blank Γ) : Turing.List_blank.Cons l.head l.tail = l
{G : Type u_1} [AddGroup G] {h : Add_Subgroup G} {N : Type u_3} [AddGroup N] (F : N →+ G) : Add_Subgroup.comap F h.Normalizer ≤ (Add_Subgroup.comap F h).Normalizer
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {v : ℝ → E → E} {S : ℝ → set E} {K : ℝ} (hv : ∀ (t : ℝ) (x : E), x ∈ S t → ∀ (y : E), y ∈ S t → HasDist.dist (v t x) (v t y) ≤ K * HasDist.dist x y) {F g F' g' : ℝ → E} {A B εF εg δ : ℝ} (hF : Continuous_on F (set.icc A B)) (hF' : ∀ (t : ℝ), t ∈ set.Ico A B → HasDerivWithinAt F (F' t) (set.ici t) t) (F_bound : ∀ (t : ℝ), t ∈ set.Ico A B → HasDist.dist (F' t) (v t (F t)) ≤ εF) (hfs : ∀ (t : ℝ), t ∈ set.Ico A B → F t ∈ S t) (hg : Continuous_on g (set.icc A B)) (hg' : ∀ (t : ℝ), t ∈ set.Ico A B → HasDerivWithinAt g (g' t) (set.ici t) t) (g_bound : ∀ (t : ℝ), t ∈ set.Ico A B → HasDist.dist (g' t) (v t (g t)) ≤ εg) (hgs : ∀ (t : ℝ), t ∈ set.Ico A B → g t ∈ S t) (ha : HasDist.dist (F A) (g A) ≤ δ) (t : ℝ) (h : t ∈ set.icc A B) : HasDist.dist (F t) (g t) ≤ gronwall_bound δ K (εF + εg) (t - A)
{m : Type u_1} [has_Add m] {C D : Add_Con m} {x y : m} : ⇑(C ⊓ D) x y ↔ ⇑C x y ∧ ⇑D x y
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [Algebra R A] [CommRing B] [Algebra R B] (hfp : Algebra.Finite_presentation R A) (e : A ≃ₐ[R] B) : Algebra.Finite_presentation R B
{ι : Type u_1} {m : ι → Type u_2} [Π (i : ι), Monoid (m i)] (W : FreeProduct.Word m) (h : W ≠ FreeProduct.Word.Empty) : ∃ (i j : ι) (W' : FreeProduct.Neword m i j), W'.to_Word = W
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.CosimplicialObject C) {n : ℕ} {i : Fin (n + 2)} {j : Fin (n + 1)} (h : i ≤ ⇑Fin.cast_Succ j) : x.δ (⇑Fin.cast_Succ i) ≫ x.σ j.Succ = x.σ j ≫ x.δ i
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {n : WithTop ℕ} (hF : IsBoundedLinearMap 𝕜 F) : ContDiff 𝕜 n F
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] {S : Finset α} {t : Finset β} {F : α → β} {W : α → m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (ht : ∀ (y : β), y ∉ t → 0 ≤ (Finset.Filter (λ (x : α), F x = y) S).Sum (λ (x : α), W x)) (hb : S.Sum (λ (x : α), W x) < t.Card • B) : ∃ (y : β) (h : y ∈ t), (Finset.Filter (λ (x : α), F x = y) S).Sum (λ (x : α), W x) < B
{A : Type u_1} [CommRing A] [Algebra ℚ A] (k : ℕ) : PowerSeries.Exp A ^ k = ⇑(PowerSeries.rescale ↑k) (PowerSeries.Exp A)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {F' : E ≃L[𝕜] F} {g : F → E} {A : F} (hg : Continuous_at g A) (hF : HasStrictFderivAt F ↑F' (g A)) (hfg : ∀ᶠ (y : F) in nhds A, F (g y) = y) : HasStrictFderivAt g ↑(F'.Symm) A
(x : Type u) [MetricSpace x] [CompactSpace x] [Nonempty x] (Y : Type v) [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : ∃ (Φ : x → ↥(Lp (λ (n : ℕ), ℝ) ⊤)) (Ψ : Y → ↥(Lp (λ (n : ℕ), ℝ) ⊤)), Isometry Φ ∧ Isometry Ψ ∧ GromovHausdorff.GH_dist x Y = metric.Hausdorff_dist (set.Range Φ) (set.Range Ψ)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {v₂ : Type v'} [AddCommGroup v₂] [module K v₂] (F : v →ₗ[K] v₂) (W : Function.Surjective ⇑F) [Finite_dimensional K v] : Finite_dimensional K v₂
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {x : E} {F : E → F} {F' : E → (E →L[ℝ] F)} {F'' : E →L[ℝ] E →L[ℝ] F} (hF : ∀ (y : E), HasFderivAt F (F' y) y) (hx : HasFderivAt F' F'' x) (v W : E) : ⇑(⇑F'' v) W = ⇑(⇑F'' W) v
{α : Type u_1} {ι' : sort u_5} [CompleteLattice α] (S : ι' → α) : (⨅ (i : ι'), S i) = ⨅ (t : Finset (plift ι')) (i : plift ι') (h : i ∈ t), S i.down
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {F : v ≃ₗᵢ[ℝ] v} (hD : ⇑LinearMap.det ↑(F.to_Linear_Equiv) < 0) : ∃ (θ : Real.Angle), F = hb.Conj_lie.Trans (hb.rotation θ)
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.NormalMonoCategory C] {x Y : C} (F g : x ⟶ Y) : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.ParallelPair F g)
{α : Type u_1} {m : Type u_5} {N : Type u_7} [AddZeroClass m] [CommMonoid N] {F g : α →₀ m} {h : α → m → N} (h_Zero : ∀ (A : α), h A 0 = 1) (h_Add : ∀ (A : α) (B₁ B₂ : m), h A (B₁ + B₂) = h A B₁ * h A B₂) : (F + g).Prod h = F.Prod h * g.Prod h
{R : Type u_1} {R₂ : Type u_2} {m : Type u_4} {m₂ : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] [Semiring R₂] [AddCommMonoid m₂] [module R₂ m₂] {σ₁₂ : R →+* R₂} {S : set m} {F g : m →ₛₗ[σ₁₂] m₂} (h : set.Eq_on ⇑F ⇑g S) : set.Eq_on ⇑F ⇑g ↑(Submodule.Span R S)
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] {P1 P2 P : P} (h : P1 -ᵥ P = P2 -ᵥ P) : P1 = P2
{α : Type u_1} [CommSemiring α] (E : LinearRecurrence α) {u : ℕ → α} {init : Fin E.order → α} (h : E._solution u) (HEq : ∀ (n : Fin E.order), u ↑n = init n) : u = E.Mk_sol init
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : EuclideanGeometry.angle P1 P2 P3 = Real.Pi) : HasDist.dist P1 P3 = HasDist.dist P1 P2 + HasDist.dist P3 P2
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} {S : set E} {x : E} : MdifferentiableWithinAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F S x ↔ Differentiable_within_at 𝕜 F S x
{m : Type u} [Monoid m] (x : m) (n : ℕ) : Mul_Opposite.Op (x ^ n) = Mul_Opposite.Op x ^ n
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} {S : set α} (h : finsum (λ (i : α), finsum (λ (h : i ∈ S), F i)) ≠ 0) : ∃ (x : α) (h : x ∈ S), F x ≠ 0
{B x C : Ordinal} (B1 : 1 < B) (x0 : 0 < x) : B ^ C ≤ x ↔ C ≤ Ordinal.log B x
(G : Type u_1) [Group G] : Group.IsNilpotent G ↔ ∃ (n : ℕ) (h : ℕ → Subgroup G), IsDescendingCentralSeries h ∧ h n = ⊥
{β : Type u} {α : Type v} {S : Finset α} {A : α} {F : α → β} [CommMonoid β] [DecidableEq α] (h : F A = 1) : (HasInsert.Insert A S).Prod (λ (x : α), F x) = S.Prod (λ (x : α), F x)
 : Function.Injective Fin
{R : Type u} [comm_Semigroup R] [Star_Semigroup R] (x y : R) : HasStar.Star (x * y) = HasStar.Star x * HasStar.Star y
{α : Type u} {β : Type v} [TopologicalSpace α] {F : β → α} {l : Filter β} {S : set β} {A : α} (h : ∀ (x : β), x ∉ S → F x = A) : Filter.Tendsto F (l ⊓ Filter.principal S) (nhds A) ↔ Filter.Tendsto F l (nhds A)
{R : Type u_1} {m : Type u_2} [CommSemiring R] [AddCommMonoid m] [module R m] (S : set R) : Submodule.IsTorsionBy_set R m S = Submodule.IsTorsionBy_set R m ↑(Ideal.Span S)
{v : Type u_1} [NormedGroup v] [Nontrivial v] : ∥NormedGroup_hom.Id v∥ = 1
{R K : Type u} [CommRing R] [Field K] [Algebra R K] [_alg_IsClosed K] {ι : Type u} (v : ι → K) [Nontrivial R] (hv : _transcendence_Basis R v) (hR : Cardinal.Mk R ≤ Cardinal.aleph0) (hK : Cardinal.aleph0 < Cardinal.Mk K) : Cardinal.Mk K = Cardinal.Mk ι
{m : Type u_1} [MulOneClass m] (C : Con m) : Con.Ker C.Mk' = C
{k : Type u_1} {m : Type u_2} [ordered_Ring k] [ordered_AddCommGroup m] [module k m] [OrderedSmul k m] [CovariantClass m m has_Add.Add has_LT.LT] [ContravariantClass m m has_Add.Add has_LT.LT] {A B : k} {C D : m} (hab : A < B) (hcd : C < D) : A • D + B • C < A • C + B • D
{α : Type u_1} [UniformSpace α] : (⨆ (x : α), nhds (x, x)) ≤ Uniformity α
{x : Type u_2} [EmetricSpace x] (m : set x → Ennreal) : (MeasureTheory.OuterMeasure.Mk_metric' m)._metric
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {F : m →* N} (h : ∀ (y : ↥S), IsUnit (⇑F ↑y)) {x₁ x₂ : m} {y₁ y₂ : ↥S} : ⇑F x₁ * ↑(⇑(IsUnit.Lift_Right (F.Restrict S) h) y₁)⁻¹ = ⇑F x₂ * ↑(⇑(IsUnit.Lift_Right (F.Restrict S) h) y₂)⁻¹ ↔ ⇑F (x₁ * ↑y₂) = ⇑F (x₂ * ↑y₁)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {F : E → F} (hF : ContDiff 𝕜 n F) : ContDiff 𝕜 n (λ (x : E), -F x)
{A : Type u_1} {R : Type u_2} (K : Type u_3) [CommRing A] [IsDomain A] [normalized_Gcd_Monoid A] [Field K] [CommRing R] [IsDomain R] [Algebra A K] [_fraction_Ring A K] [Algebra K R] [Algebra A R] [IsScalarTower A K R] {x : R} (hx : IsIntegral A x) {P : Polynomial A} (hprim : P._primitive) (hroot : ⇑(Polynomial.aeval x) P = 0) : minpoly A x ∣ P
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Finite_dimensional ℝ ↥(S.direction)] (hD : Finite_dimensional.finrank ℝ ↥(S.direction) = 2) {C₁ C₂ P₁ P₂ P : P} (hc₁S : C₁ ∈ S) (hc₂S : C₂ ∈ S) (hp₁S : P₁ ∈ S) (hp₂S : P₂ ∈ S) (hps : P ∈ S) {r₁ r₂ : ℝ} (hc : C₁ ≠ C₂) (hp : P₁ ≠ P₂) (hp₁C₁ : HasDist.dist P₁ C₁ = r₁) (hp₂C₁ : HasDist.dist P₂ C₁ = r₁) (hpc₁ : HasDist.dist P C₁ = r₁) (hp₁C₂ : HasDist.dist P₁ C₂ = r₂) (hp₂C₂ : HasDist.dist P₂ C₂ = r₂) (hpc₂ : HasDist.dist P C₂ = r₂) : P = P₁ ∨ P = P₂
{R : Type u_1} [Semiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {N : Type u_3} [AddCommMonoid N] [module R N] {ι : Type u_6} [DecidableEq ι] (F : AlternatingMap R m N ι) : F.Comp_Linear_Map LinearMap.Id = F
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {S : set E} {g : F → G} {F : E → F} (hg : ContDiff 𝕜 n g) (hF : ContDiff_on 𝕜 n F S) : ContDiff_on 𝕜 n (g ∘ F) S
{n : ℕ} (u v : Σ (C : Composition n), Π (i : Fin C.length), Composition (C.blocks_fun i)) : u = v ↔ List.of_fn (λ (i : Fin u.fst.length), (u.Snd i).blocks) = List.of_fn (λ (i : Fin v.fst.length), (v.Snd i).blocks)
{n : ℕ} {x : ℕ × ℕ} : x ∈ List.Nat.antidiagonal n ↔ x.fst + x.Snd = n
{A B : ℝ} : IntervalIntegrable (λ (x : ℝ), x⁻¹) MeasureTheory.MeasureSpace.Volume A B ↔ A = B ∨ 0 ∉ set.Interval A B
(𝕜 : Type u_1) [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] (x : E) : ext_chart_at (model_with_corners_self 𝕜 E) x = local_Equiv.refl E
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [TopologicalSpace.SecondCountableTopology E] [CompleteSpace E] [NormedGroup F] {F : ℝ → E} {g : ℝ → F} {A B : ℝ} (l : Filter ℝ) [l.Ne_IsBot] [Filter.Tendsto_Ixx_class set.icc l l] (hl : set.Interval A B ∈ l) (hD : ∀ᶠ (x : ℝ) in l, Differentiable_at ℝ F x) (hF : Filter.Tendsto (λ (x : ℝ), ∥F x∥) l Filter.at_top) (hfg : deriv F =O[l] g) : ¬IntervalIntegrable g MeasureTheory.MeasureSpace.Volume A B
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} [CompleteSpace E] (F : LocalHomeomorph E F) {F₀' : E ≃L[𝕜] F} {A : F} (ha : A ∈ F.to_local_Equiv.Target) (hF₀' : HasFderivAt ⇑F ↑F₀' (⇑(F.Symm) A)) (hF : ContDiff_at 𝕜 n ⇑F (⇑(F.Symm) A)) : ContDiff_at 𝕜 n ⇑(F.Symm) A
(α : Type u_1) [has_Zero α] [has_One α] (n : ℕ) : Matrix.circulant (λ (i : Fin n), Ite (↑i = 0) 1 0) = 1
{m : Type u_1} {R : Type u_2} [Fintype m] [CommRing R] {m : Matrix m m R} (hM : m.nondegenerate) {v : m → R} (hv : v ≠ 0) : ∃ (W : m → R), Matrix.dot_Product v (m.Mul_vec W) ≠ 0
{R : Type u_4} [NormedRing R] [CompleteSpace R] (x : R) (h : ∥x∥ < 1) : ∥∑' (n : ℕ), x ^ n∥ ≤ ∥1∥ - 1 + (1 - ∥x∥)⁻¹
{α : Type u_2} {β : Type u_3} {γ : Type u_4} [rα : non_assoc_Semiring α] [rβ : non_assoc_Semiring β] {rγ : non_assoc_Semiring γ} {δ : Type u_1} {rδ : non_assoc_Semiring δ} (F : α →+* β) (g : β →+* γ) (h : γ →+* δ) : (h.Comp g).Comp F = h.Comp (g.Comp F)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S₁ S₂ : set P} (h : S₁ ⊆ S₂) : affine_Span k S₁ ≤ affine_Span k S₂
{R : Type u_1} {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] [IsArtinian R m] (F : m →ₗ[R] m) (S : Function.Injective ⇑F) : Function.Bijective ⇑F
{m : Type u} [Monoid m] (A : m) : A ^ 2 = A * A
{α : Type u_1} {E : Type u_2} (R : Type u_3) [AddCommGroup E] [DivisionRing R] [Monoid α] [module R E] [Distrib_MulAction α E] (n : ℕ) (S : α) (x : E) : (↑n)⁻¹ • S • x = S • (↑n)⁻¹ • x
{R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] {ι : Type u_1} {F : ι → m} (hF : Function.Injective F) : LinearIndependent R Coe → LinearIndependent R F
(k : Type u_1) {v : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Fintype ι] (P : ι → P) {n : ℕ} (hc : Fintype.Card ι = n + 2) : AffineIndependent k P ↔ ¬Finite_dimensional.finrank k ↥(Vector_Span k (set.Range P)) ≤ n
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [RegularSpace Y] {F : x → Y} {A B : set x} (hB : B ⊆ Closure A) (hF : ∀ (x : x), x ∈ B → (∃ (y : Y), Filter.Tendsto F (nhds_within x A) (nhds y))) : Continuous_on (extend_from A F) B
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] {S : set m} {P : Π (x : m), x ∈ Submodule.Span R S → Prop} (Hs : ∀ (x : m) (h : x ∈ S), P x _) (h0 : P 0 _) (h1 : ∀ (x : m) (hx : x ∈ Submodule.Span R S) (y : m) (hy : y ∈ Submodule.Span R S), P x hx → P y hy → P (x + y) _) (h2 : ∀ (A : R) (x : m) (hx : x ∈ Submodule.Span R S), P x hx → P (A • x) _) {x : m} (hx : x ∈ Submodule.Span R S) : P x hx
{𝕜 : Type u_1} {E : Type u_3} [NormedField 𝕜] [AddCommGroup E] [module 𝕜 E] {A : set E} [TopologicalSpace E] [has_Continuous_Smul 𝕜 E] (hA : A ∈ nhds 0) : Absorbent 𝕜 A
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {B : E × F → G} {n : WithTop ℕ} (hb : IsBoundedBilinearMap 𝕜 B) : ContDiff 𝕜 n B
{m : Type u_1} [has_Add m] {C D : Add_Con m} (h : Setoid.r = Setoid.r) : C = D
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits_of_size C] : CategoryTheory.Limits.HasColimits_of_size C
(n : ℕ) (x : ℝ) : HasDerivAt (Exp_Neg_Inv_glue.F_aux n) (Exp_Neg_Inv_glue.F_aux (n + 1) x) x
(R : Type u_1) {P n : ℕ} [hp : Fact (Nat.Prime P)] [Ring R] [Char_P R P] (hn : ¬P ∣ n) : Polynomial.cyclotomic (n * P) R = Polynomial.cyclotomic n R ^ (P - 1)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (hb : Continuous_at F A) : deriv (λ (u : ℝ), ∫ (x : ℝ) in u..B, F x) A = -F A
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {n : WithTop ℕ} {F g : E → F} (hF : ContDiff_at 𝕜 n F x) (hg : ContDiff_at 𝕜 n g x) : ContDiff_at 𝕜 n (λ (x : E), F x - g x) x
{A B : ℝ} (m n : ℕ) : ∫ (x : ℝ) in A..B, Real.sin x ^ (2 * m + 1) * Real.cos x ^ n = ∫ (u : ℝ) in Real.cos B..Real.cos A, u ^ n * (1 - u ^ 2) ^ m
{ι : Type u} {α : Type v} [Fintype ι] {t : ι → Finset α} [DecidableEq α] {n : ℕ} (hn : Fintype.Card ι = n + 1) (ht : ∀ (S : Finset ι), S.Card ≤ (S.bUnion t).Card) (ih : ∀ {ι' : Type u} [_inst_3 : Fintype ι'] (t' : ι' → Finset α), Fintype.Card ι' ≤ n → (∀ (S' : Finset ι'), S'.Card ≤ (S'.bUnion t').Card) → (∃ (F : ι' → α), Function.Injective F ∧ ∀ (x : ι'), F x ∈ t' x)) (S : Finset ι) (hs : S.Nonempty) (hns : S ≠ Finset.Univ) (hus : S.Card = (S.bUnion t).Card) : ∃ (F : ι → α), Function.Injective F ∧ ∀ (x : ι), F x ∈ t x
{α : Type u} [AddGroup α] [has_LE α] [CovariantClass α α has_Add.Add has_LE.LE] {A : α} : 0 ≤ -A → A ≤ 0
{𝕜₂ : Type u_2} {𝕜₃ : Type u_3} {F : Type u_6} {G : Type u_8} [NormedGroup F] [NormedGroup G] [nondiscrete_NormedField 𝕜₂] [nondiscrete_NormedField 𝕜₃] [NormedSpace 𝕜₂ F] [NormedSpace 𝕜₃ G] {σ₂₃ : 𝕜₂ →+* 𝕜₃} {𝕜₂' : Type u_10} [nondiscrete_NormedField 𝕜₂'] {F' : Type u_11} [NormedGroup F'] [NormedSpace 𝕜₂' F'] {σ₂' : 𝕜₂' →+* 𝕜₂} {σ₂'' : 𝕜₂ →+* 𝕜₂'} {σ₂₃' : 𝕜₂' →+* 𝕜₃} [RingHomInvPair σ₂' σ₂''] [RingHomInvPair σ₂'' σ₂'] [Ring_hom_Comp_triple σ₂' σ₂₃ σ₂₃'] [Ring_hom_Comp_triple σ₂'' σ₂₃' σ₂₃] [Ring_hom_isometric σ₂₃] [Ring_hom_isometric σ₂'] [Ring_hom_isometric σ₂''] [Ring_hom_isometric σ₂₃'] (F : F →sl[σ₂₃] G) (g : F' ≃ₛₗᵢ[σ₂'] F) : ∥F.Comp g.to_Linear_Isometry.to_Continuous_Linear_Map∥ = ∥F∥
{n m : ℕ} (h : n = m) (i : Fin n) : ↑(⇑(Fin.cast h) i) = ↑i
{ι : Type u} {γ : Type W} {β : ι → Type v} [dec : DecidableEq ι] [Π (i : ι), AddZeroClass (β i)] [AddCommMonoid γ] (F : Π (i : ι), β i →+ γ) (i : ι) (x : β i) : ⇑(⇑Dfinsupp.Lift_Add_hom F) (Dfinsupp.single i x) = ⇑(F i) x
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] {F : α → β} {S : set α} {A : α} (h_Mono : StrictMono_on F S) (hs : S ∈ nhds_within A (set.ici A)) (hfs : set.surj_on F S (set.ioi (F A))) : Continuous_within_at F (set.ici A) A
{R : Type u} [Ring R] (S : Subring R) : 0 ∈ S
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y z : v} (hxyne : x ≠ y) (hxzne : x ≠ z) {r : ℝ} (hx : ∥x∥ = r) (hy : ∥y∥ = r) (hz : ∥z∥ = r) : hb.oangle y z = 2 • hb.oangle (y - x) (z - x)
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] : ↑⊥ = ∅
{α : Type u_1} [comm_Semigroup α] {A B : α} (C : α) (h : C * A = B) : A ∣ B
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra A B] [Algebra R B] [Algebra R A] [IsScalarTower R A B] (h : Function.Injective ⇑(Algebra_Map A B)) {x : A} (h : IsIntegral R (⇑(Algebra_Map A B) x)) : IsIntegral R x
{m : Type u} [MulOneClass m] (x : m) : SemiconjBy 1 x x
{R : Type u_1} {A : Type u_2} [CommSemiring R] [Semiring A] [Algebra R A] (h : Function.Injective ⇑(Algebra_Map R A)) [CharZero R] : CharZero A
{α : Type u_1} {β : Type u_2} [AddCommMonoid α] [TopologicalSpace α] [t2_Space α] [CompleteLattice β] (m : β → α) (m0 : m ⊥ = 0) (R : α → α → Prop) (m_supr : ∀ (S : ℕ → β), R (m (⨆ (i : ℕ), S i)) (∑' (i : ℕ), m (S i))) (S₁ S₂ : β) : R (m (S₁ ⊔ S₂)) (m S₁ + m S₂)
{C : Type u} [CategoryTheory.Category C] {x Y x' : C} (h : x' ⟶ x) (F : x ⟶ Y) [CategoryTheory.Limits.HasImage F] [CategoryTheory.Limits.HasImage (h ≫ F)] : CategoryTheory.Limits.image_Subobject (h ≫ F) ≤ CategoryTheory.Limits.image_Subobject F
{R₁ R₂ : ℝ} {C z : ℂ} {F : ℂ → ℂ} (hD : DifferentiableOn ℂ F (Metric.Ball C R₁)) (h_maps : set.maps_to F (Metric.Ball C R₁) (Metric.Ball (F C) R₂)) (hz : z ∈ Metric.Ball C R₁) : ∥dslope F C z∥ ≤ R₂ / R₁
{α : Type u} {A B : α} [MulOneClass α] [has_Zero α] [Preorder α] [Zero_LT.Mul_Pos_Mono α] (ha : A ≤ 1) (hb : B < 1) (B0 : 0 < B) : A * B < 1
{R : Type u} [CommSemiring R] (P q : Polynomial R) : ⇑Polynomial.derivative (Polynomial.Eval₂ Polynomial.C q P) = Polynomial.Eval₂ Polynomial.C q (⇑Polynomial.derivative P) * ⇑Polynomial.derivative q
{R : Type u} [Ring R] {Γ₀ : Type v} [Linear_ordered_comm_Group_with_Zero Γ₀] (v : Valuation R Γ₀) : Ring_subgroups_Basis (λ (γ : Γ₀ˣ), v.LT_Add_Subgroup γ)
{x : Type u_1} [TopologicalSpace x] {x y : x} : Inseparable x y → nhds x = nhds y
{R : Type u_1} [CommSemiring R] {l : Type u_2} {m : Type u_3} {n : Type u_4} [Fintype n] [Fintype m] [DecidableEq n] {m₁ : Type u_5} {m₂ : Type u_6} [AddCommMonoid m₁] [AddCommMonoid m₂] [module R m₁] [module R m₂] (v₁ : Basis n R m₁) (v₂ : Basis m R m₂) {m₃ : Type u_7} [AddCommMonoid m₃] [module R m₃] (v₃ : Basis l R m₃) [Fintype l] [DecidableEq m] (A : Matrix l m R) (B : Matrix m n R) (x : m₁) : ⇑(⇑(Matrix.to_lin v₁ v₃) (A.Mul B)) x = ⇑(⇑(Matrix.to_lin v₂ v₃) A) (⇑(⇑(Matrix.to_lin v₁ v₂) B) x)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P₁ P₂ : ι → P) : S.Sum (λ (i : ι), W i • (P₁ i -ᵥ P₂ i)) = ⇑(S.weighted_vsub P₁) W - ⇑(S.weighted_vsub P₂) W
(A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension {1} A B] : ⊥ = ⊤
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} {S : set α} (P : m → Prop) (hp₀ : P 1) (hp₁ : ∀ (x y : m), P x → P y → P (x * y)) (hp₂ : ∀ (x : α), x ∈ S → P (F x)) : P (finprod (λ (i : α), finprod (λ (h : i ∈ S), F i)))
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set ℝ} [IntervalIntegral.FTC_Filter A (nhds_within A S) (nhds_within A t)] (hmeas : StronglyMeasurableAtFilter F (nhds_within A t) MeasureTheory.MeasureSpace.Volume) (ha : Continuous_within_at F t A) (hs : UniqueDiffWithinAt ℝ S A . "UniqueDiffWithinAt_ici_Iic_Univ") : deriv_within (λ (u : ℝ), ∫ (x : ℝ) in u..B, F x) S A = -F A
{α : Type u_1} [TopologicalSpace α] {x : α} {S : set α} {γ : Type u_4} [Linear_ordered_AddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] {F g : α → γ} (hF : LowerSemicontinuous_within_at F S x) (hg : LowerSemicontinuous_within_at g S x) (hcont : Continuous_at (λ (P : γ × γ), P.fst + P.Snd) (F x, g x)) : LowerSemicontinuous_within_at (λ (z : α), F z + g z) S x
(S : set Cardinal) : BddAbove S ↔ Small ↥S
{R : Type u_1} [Semiring R] {m : Type u_2} [AddCommMonoid m] (P q : module R m) (W : ∀ (r : R) (m : m), r • m = r • m) : P = q
{α : Type u} [PartialOrder α] [Decidable_Rel has_LE.LE] {A B : α} (hab : A ≤ B) : A = B ∨ A < B
{A : Type u_2} [AddMonoid A] {x y : A} : y ∈ AddSubmonoid.Closure {x} ↔ ∃ (n : ℕ), n • x = y
{α : Type u} {A B : α} [Mul_Zero_class α] [Preorder α] [Zero_LT.Pos_Mul_StrictMono α] (ha : 0 < A) (hb : 0 < B) : 0 < A * B
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) : LinearIndependent 𝕜 v
{α : Type u_1} {β : Type u_2} {G₀ : Type u_3} [Group_with_Zero G₀] [TopologicalSpace G₀] [has_Continuous_Inv₀ G₀] [has_Continuous_Mul G₀] [TopologicalSpace α] [TopologicalSpace β] {A : α} {F g : α → G₀} (h : α → G₀ → β) (hF : Continuous_at F A) (hg : Continuous_at g A) (hH : g A ≠ 0 → Continuous_at ↿h (A, F A / g A)) (h2h : g A = 0 → Filter.Tendsto ↿h ((nhds A).Prod ⊤) (nhds (h A 0))) : Continuous_at (λ (x : α), h x (F x / g x)) A
{ι : sort u_1} {α : Type u_2} {β : Type u_3} [CompleteLattice α] [CompleteLattice β] (F : α ≃o β) {A : ι → α} (ha : CompleteLattice.Independent A) : CompleteLattice.Independent (⇑F ∘ A)
{C : Type u} [CategoryTheory.Category C] {F : C ⥤ C} {A : CategoryTheory.Endofunctor.Algebra F} (h : CategoryTheory.Limits.IsInitial A) : CategoryTheory.IsIso A.str
{R : Type u_1} {S : Type u_2} [CommRing R] [CommRing S] [Algebra R S] {ι : Type W} [Fintype ι] (B : Basis ι R S) (x : R) : ⇑(Algebra.trace R S) (⇑(Algebra_Map R S) x) = Fintype.Card ι • x
{R : Type u_1} {m : Type u_2} [CommMonoid m] [CommSemiring R] {S : set m} (hS : Submonoid.Closure S = ⊤) : Function.Surjective ⇑(mv_Polynomial.aeval (λ (S : ↥S), ⇑(Monoid_Algebra.of R m) ↑S))
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [Finite_dimensional 𝕜 E] [Finite_dimensional 𝕜 F] (A : E →ₗ[𝕜] F) (x : E) (y : F) : HasInner.inner (⇑(⇑LinearMap.Adjoint A) y) x = HasInner.inner y (⇑A x)
{G₁ : Type u_2} {G₂ : Type u_3} [Group G₁] [Group G₂] [Group.IsNilpotent G₁] [Group.IsNilpotent G₂] : Group.nilpotency_class (G₁ × G₂) = LinearOrder.max (Group.nilpotency_class G₁) (Group.nilpotency_class G₂)
{ι : Type u} (S : Finset ι) (F g : ι → Ennreal) {P : ℝ} (hp : 1 ≤ P) : S.Sum (λ (i : ι), (F i + g i) ^ P) ^ (1 / P) ≤ S.Sum (λ (i : ι), F i ^ P) ^ (1 / P) + S.Sum (λ (i : ι), g i ^ P) ^ (1 / P)
{α : Type u} [PseudoMetricSpace α] (x y : α) : HasDist.dist x y = ↑(HasNndist.nndist x y)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [TopologicalSpace.SecondCountableTopology α] : {x : α | ∃ (y : α), x < y ∧ set.Ioo x y = ∅}.countable
{R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] {m : ℕ} (x : m) (v : Fin m → m) (hli : LinearIndependent R v) (x_IsOrtho : ∀ (C : R) (y : ↥(Submodule.Span R (set.Range v))), C • x + ↑y = 0 → C = 0) : LinearIndependent R (Fin.Cons x v)
{m : Type u_1} [AddZeroClass m] {S : set m} : S ⊆ ↑(AddSubmonoid.Closure S)
{α : Type u} [Monoid α] (F : ℕ → α) (n : ℕ) : (List.Map F (List.Range n.Succ)).Prod = F 0 * (List.Map (λ (i : ℕ), F i.Succ) (List.Range n)).Prod
(𝕜 : Type u_1) [nondiscrete_NormedField 𝕜] (𝕜' : Type u_2) [NormedRing 𝕜'] [normed_Algebra 𝕜 𝕜'] : IsBoundedBilinearMap 𝕜 (λ (P : 𝕜' × 𝕜'), ⇑(⇑(Continuous_Linear_Map.lmul_Left_Right 𝕜 𝕜') P.fst) P.Snd)
{E : Type u_2} {𝕜 : Type u_3} [Linear_ordered_Field 𝕜] [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul 𝕜 E] {S : set E} (hs : Convex 𝕜 S) {A B : 𝕜} (ha : 0 < A) (hb : 0 ≤ B) (hab : A + B = 1) : A • Interior S + B • Closure S ⊆ Interior S
{S : ℂ} (hs : 0 < S.re) : (S + 1).gamma_integral = S * S.gamma_integral
{α : Type u} [OrderedSemiring α] [Nontrivial α] : 0 < 2
{α : Type u} {l : List α} : l.Nodup → l.attach.Nodup
{x Y Z : Type u} (F : x ⟶ Y) {g h : Y ⟶ Z} (W : F ≫ g = F ≫ h) (t : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fork.ofι F W)) (y : Y) (hy : g y = h y) : ∃! (x : x), F x = y
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {n : ℕ} : iterated_fderiv 𝕜 (n + 1) F = ⇑(Continuous_multilinear_Curry_Left_Equiv 𝕜 (λ (i : Fin (n + 1)), E) F) ∘ fderiv 𝕜 (iterated_fderiv 𝕜 n F)
{α : Type u_1} {ι : Type u_4} [TopologicalSpace α] [Encodable ι] {S : ι → set α} (hs : ∀ (i : ι), _Gδ (S i)) : _Gδ (⋂ (i : ι), S i)
(m : Type u_1) (R : Type u_3) [DecidableEq m] [Fintype m] [CommRing R] [Nontrivial R] : (Matrix.mv_Polynomial.x m m R).det ≠ 0
{α : Type u_1} [DecidableEq α] (S : Finset α) : (Finset.image Quotient.Mk S.off_diag).Card = S.Card.choose 2
{C : Type u} [CategoryTheory.Category C] {J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ C) [CategoryTheory.Limits.HasColimit (CategoryTheory.Discrete.Functor F.obj)] [CategoryTheory.Limits.HasColimit (CategoryTheory.Discrete.Functor (λ (F : Σ (P : J × J), P.fst ⟶ P.Snd), F.obj F.fst.fst))] [CategoryTheory.Limits.HasCoequalizers C] : CategoryTheory.Limits.HasColimit F
{𝕜 : Type u_1} {E : Type u_2} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {P : FormalMultilinearSeries 𝕜 𝕜 E} {x : 𝕜} (h : HasFpowerSeriesAt 0 P x) : P = 0
{m : Type u_1} [Monoid m] {S₁ S₂ : set m} (₁ : _Submonoid S₁) (₂ : _Submonoid S₂) : _Submonoid (S₁ ∩ S₂)
(A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : ⇑(Polynomial.aeval x) (minpoly A x) = 0
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} {S t : set α} (hst : S ⊆ t) (ht : t.Finite) : finprod (λ (i : α), finprod (λ (h : i ∈ S), F i)) * finprod (λ (i : α), finprod (λ (h : i ∈ t  S), F i)) = finprod (λ (i : α), finprod (λ (h : i ∈ t), F i))
{m₀ : Type u_1} [CancelMonoidWithZero m₀] {A B : m₀} (h₁ : B ≠ 1) (h₂ : B * A = A) : A = 0
{α : Type u} [Group α] [has_LE α] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LE.LE] {A : α} : A⁻¹ ≤ 1 ↔ 1 ≤ A
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] : Finite_dimensional.finrank K v = 0 ↔ Subsingleton v
{R : Type u_1} {m : Type u_2} [CommMonoid m] [CommRing R] [Nontrivial R] [h : Algebra.Finite_Type R (Monoid_Algebra R m)] : Monoid.fg m
{m : Type u_1} {N : Type u_2} [has_Mul m] [has_Mul N] {C : Con m} {D : Con N} {C : C.Quotient → D.Quotient → Prop} (P : C.Quotient) (q : D.Quotient) (h : ∀ (x : m) (y : N), C ↑x ↑y) : C P q
{α : Type u_1} [PseudoMetricSpace α] {x : α} {E : set α} (hx : x ∈ E) (δ : ℝ) : metric.IsClosed_ball x δ ⊆ Metric.Cthickening δ E
{v : Type u₁} [Quiver v] {C : Type u_1} [CategoryTheory.Category C] {F G : CategoryTheory.Paths v ⥤ C} (h_obj : F.obj = G.obj) (h : ∀ (A B : v) (e : A ⟶ B), F.Map e.to_Path = CategoryTheory.Eq_to_hom _ ≫ G.Map e.to_Path ≫ CategoryTheory.Eq_to_hom _) : F = G
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {S : set E} (S_conv : Convex ℝ S) {F : E → F} {F' : E → (E →L[ℝ] F)} {F'' : E →L[ℝ] E →L[ℝ] F} (hF : ∀ (x : E), x ∈ Interior S → HasFderivAt F (F' x) x) {x : E} (xs : x ∈ S) (hx : HasFderivWithinAt F' F'' (Interior S) x) {v W : E} (h4v : x + 4 • v ∈ Interior S) (h4W : x + 4 • W ∈ Interior S) : (λ (h : ℝ), F (x + h • (2 • v + 2 • W)) + F (x + h • (v + W)) - F (x + h • (2 • v + W)) - F (x + h • (v + 2 • W)) - h ^ 2 • ⇑(⇑F'' v) W) =o[nhds_within 0 (set.ioi 0)] λ (h : ℝ), h ^ 2
{𝕜 : Type u_1} {E : Type u_4} {Fₗ : Type u_7} [NormedGroup E] [NormedGroup Fₗ] [nondiscrete_NormedField 𝕜] [NormedSpace 𝕜 E] [NormedSpace 𝕜 Fₗ] (C : E →L[𝕜] 𝕜) (F : Fₗ) : ∥C.Smul_Right F∥₊ = ∥C∥₊ * ∥F∥₊
{α : Type u_6} {β : Type u_7} [has_Mul β] [HasScalar α β] [IsScalarTower α β β] (r : α) (x y : β) : r • x * y = r • (x * y)
{C : Type u₁} [CategoryTheory.Category C] {x Y Z : C} {F : x ⟶ Z} {g : Y ⟶ Z} {C : CategoryTheory.Limits.PullbackCone F g} (h : CategoryTheory.Limits.IsLimit C) : CategoryTheory.IsPullback C.fst C.Snd F g
{α : Type u_1} {β : Type u_2} {m : Type u_5} [AddCommMonoid m] {S : set α} {t : set β} (F : α → β → m) (hs : S.Finite) (ht : t.Finite) : finsum (λ (i : α), finsum (λ (h : i ∈ S), finsum (λ (j : β), finsum (λ (h : j ∈ t), F i j)))) = finsum (λ (j : β), finsum (λ (h : j ∈ t), finsum (λ (i : α), finsum (λ (h : i ∈ S), F i j))))
{E : Type u_1} {F : Type u_2} {𝕜 : Type u_3} {𝕜₂ : Type u_4} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [Ring_hom_isometric σ₁₂] {ι : Type u_5} [CompleteSpace E] {g : ι → (E →sl[σ₁₂] F)} (h : ∀ (x : E), ∃ (C : ℝ), ∀ (i : ι), ∥⇑(g i) x∥ ≤ C) : ∃ (C' : ℝ), ∀ (i : ι), ∥g i∥ ≤ C'
{B : Type u} [Quiver B] {A B C : B} (P : Quiver.Path A B) {F g : CategoryTheory.FreeBicategory.Hom B C} (η : F ⟶ g) : CategoryTheory.Bicategory.whisker_Left ((CategoryTheory.FreeBicategory.preinclusion B).Map {as := P}) η ≫ (CategoryTheory.FreeBicategory.normalize_iso P g).hom = (CategoryTheory.FreeBicategory.normalize_iso P F).hom ≫ (CategoryTheory.FreeBicategory.preinclusion B).Map₂ (CategoryTheory.Eq_to_hom _)
{R : Type u} [CommRing R] (U v : TopologicalSpace.Opens ↥(AlgebraicGeometry.Prime_Spectrum.top R)) (hUV : U = v) : AlgebraicGeometry.StructureSheaf.comap (Ring_hom.Id R) U v _ = CategoryTheory.Eq_to_hom _
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B : α} (ha : 0 < A) (hb : 0 < B) : 0 < A + B
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (S : Submodule K v) : S.fg ↔ Finite_dimensional K ↥S
{α : Type u_1} [DecidableEq α] {𝒜 : Finset (Finset α)} {S : Finset α} : S ∈ 𝒜.shadow ↔ ∃ (t : Finset α) (h : t ∈ 𝒜) (A : α) (h : A ∈ t), t.erase A = S
{α : Type u} [PseudoMetricSpace α] {S : set α} {x : α} (h : x ∈ S) : metric.Inf_dist x S = 0
{C : Type u} [CategoryTheory.Category C] {F : C ⥤ C} {A₀ A₁ : CategoryTheory.Endofunctor.Algebra F} (F : A₀ ⟶ A₁) [CategoryTheory.IsIso F.F] : CategoryTheory.IsIso F
{G : Type u_1} [Group G] {k : set G} {P : G → G → Prop} {x y : G} (hx : x ∈ Subgroup.Closure k) (hy : y ∈ Subgroup.Closure k) (Hk : ∀ (x : G), x ∈ k → ∀ (y : G), y ∈ k → P x y) (h1_Left : ∀ (x : G), P 1 x) (h1_Right : ∀ (x : G), P x 1) (HMul_Left : ∀ (x₁ x₂ y : G), P x₁ y → P x₂ y → P (x₁ * x₂) y) (HMul_Right : ∀ (x y₁ y₂ : G), P x y₁ → P x y₂ → P x (y₁ * y₂)) (Hinv_Left : ∀ (x y : G), P x y → P x⁻¹ y) (Hinv_Right : ∀ (x y : G), P x y → P x y⁻¹) : P x y
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) (i j k : D.to_GlueData.J) (U : TopologicalSpace.Opens ↥((CategoryTheory.Limits.pullback (D.to_GlueData.F i j) (D.to_GlueData.F i k)).carrier)) : ∃ (Eq_1 : (TopologicalSpace.Opens.Map (D.to_GlueData.t k i).Base).Op.obj (Opposite.Op (_.IsOpen_Functor.obj U)) = Opposite.Op (_.IsOpen_Functor.obj (Opposite.Unop ((TopologicalSpace.Opens.Map (D.to_GlueData.t' k i j).Base).Op.obj (Opposite.Op U))))), _.Inv_App U ≫ (D.to_GlueData.t k i).C.App (Opposite.Op (_.IsOpen_Functor.obj U)) ≫ (D.to_GlueData.v (k, i)).presheaf.Map (CategoryTheory.Eq_to_hom Eq_1) = (D.to_GlueData.t' k i j).C.App (Opposite.Op U) ≫ _.Inv_App (Opposite.Unop ((TopologicalSpace.Opens.Map (D.to_GlueData.t' k i j).Base).Op.obj (Opposite.Op U)))
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [RegularSpace Y] {F : x → Y} {A : set x} (hA : Dense A) (hF : ∀ (x : x), ∃ (y : Y), Filter.Tendsto F (nhds_within x A) (nhds y)) : Continuous (extend_from A F)
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) (i j k : D.to_GlueData.J) (U : TopologicalSpace.Opens ↥((CategoryTheory.Limits.pullback (D.to_GlueData.F i j) (D.to_GlueData.F i k)).carrier)) : _.Inv_App U ≫ (D.to_GlueData.t k i).C.App (Opposite.Op (_.IsOpen_Functor.obj U)) = (D.to_GlueData.t' k i j).C.App (Opposite.Op U) ≫ _.Inv_App (Opposite.Unop ((TopologicalSpace.Opens.Map (D.to_GlueData.t' k i j).Base).Op.obj (Opposite.Op U))) ≫ (D.to_GlueData.v (k, i)).presheaf.Map (CategoryTheory.Eq_to_hom _)
{C : Type u₁} [CategoryTheory.Category C] {x : C} (P : Cᵒᵖ ⥤ Type W) {S : CategoryTheory.Sieve x} {R : CategoryTheory.Presieve x} (h : ⇑S ≤ R) (hS : CategoryTheory.Presieve.IsSheafFor P ⇑S) (Trans : ∀ ⦃Y : C⦄ ⦃F : Y ⟶ x⦄, R F → CategoryTheory.Presieve.IsSeparated_for P ⇑(CategoryTheory.Sieve.pullback F S)) : CategoryTheory.Presieve.IsSheafFor P R
{R : Type u_1} {A B : R} [Add_Semigroup R] (Ab : IsAddRegular (A + B)) (ba : IsAddRegular (B + A)) : IsAddRegular A ∧ IsAddRegular B
(S : set ℕ+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] : IsCyclotomicExtension S A B ↔ (∀ (A : ℕ+), A ∈ S → (∃ (r : B), ⇑(Polynomial.aeval r) (Polynomial.cyclotomic ↑A A) = 0)) ∧ Algebra.Adjoin A {B : B | ∃ (A : ℕ+), A ∈ S ∧ B ^ ↑A = 1} = ⊤
{x : Type u_1} {Y : Type u_2} [PseudoEmetricSpace x] [PseudoEmetricSpace Y] {C r : Nnreal} {F : x → Y} {S : set x} (hF : HolderOnWith C r F S) (h0 : 0 < r) : uniform_Continuous_on F S
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B : α} : -A < -B → B < A
{α : Type u_1} : WellFounded has_LT.LT
{m : Type u_1} [has_Add m] (C : Add_Con m) {x y z : m} : ⇑C x y → ⇑C y z → ⇑C x z
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} (x : E) {v : ι → E} {S : Finset ι} (hv : Orthonormal 𝕜 v) : S.Sum (λ (i : ι), ∥HasInner.inner (v i) x∥ ^ 2) ≤ ∥x∥ ^ 2
{R : Type u} [CommSemiring R] (r : R) : ⇑Polynomial.C r = ⇑(Algebra_Map R (Polynomial R)) r
{α : Type u_2} {β : Type u_3} [Linear_ordered_Field α] [Linear_ordered_Field β] [Archimedean β] : Subsingleton (α →+*o β)
{x n : ℕ} (h : x.IsCoprime n) : x ^ n.Totient ≡ 1 [Mod n]
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] {F : ℝ → E} {t : ℝ} (hF : Function.Periodic F t) (t S : ℝ) : ∫ (x : ℝ) in t..t + t, F x = ∫ (x : ℝ) in S..S + t, F x
{α : Type u} [Preorder α] {S : set α} : ¬BddBelow S ↔ ∀ (x : α), ∃ (y : α) (h : y ∈ S), ¬x ≤ y
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (A B C P : P) (h : EuclideanGeometry.angle B P C = Real.Pi) : HasDist.dist A B ^ 2 * HasDist.dist C P + HasDist.dist A C ^ 2 * HasDist.dist B P = HasDist.dist B C * (HasDist.dist A P ^ 2 + HasDist.dist B P * HasDist.dist C P)
{α : Type u_1} {β : Type u_2} [CompleteLattice α] {F : Filter β} : F.limsup (λ (x : β), ⊥) = ⊥
{m : Type u_1} [has_Mul m] {C : Con m} (x y : m) : ↑(x * y) = ↑x * ↑y
{α : Type u} {β : Type v} [CommSemiring β] (F g : α → β) (S : Finset α) : S.Prod (λ (A : α), F A + g A) = S.powerset.Sum (λ (t : Finset α), t.Prod (λ (A : α), F A) * (S  t).Prod (λ (A : α), g A))
{n : ℕ} (h_Odd : Odd n) (hlt : 1 < n) : bernoulli' n = 0
{n : ℕ} {x : Fin (n + 1)} : Function.Injective ⇑(x.Succ_above)
{L : FirstOrder.Language} {t : L.Theory} : t._satisfiable ↔ t._finitely_satisfiable
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] {n : ℕ} (A B : Fin (n + 1) → ℝ) (hle : A ≤ B) (F : Fin (n + 1) → (Fin (n + 1) → ℝ) → E) (F' : Fin (n + 1) → (Fin (n + 1) → ℝ) → ((Fin (n + 1) → ℝ) →L[ℝ] E)) (S : set (Fin (n + 1) → ℝ)) (hs : S.countable) (Hc : ∀ (i : Fin (n + 1)), Continuous_on (F i) (set.icc A B)) (hD : ∀ (x : Fin (n + 1) → ℝ), x ∈ set.Univ.Pi (λ (i : Fin (n + 1)), set.Ioo (A i) (B i))  S → ∀ (i : Fin (n + 1)), HasFderivAt (F i) (F' i x) x) (Hi : MeasureTheory.IntegrableOn (λ (x : Fin (n + 1) → ℝ), Finset.Univ.Sum (λ (i : Fin (n + 1)), ⇑(F' i x) (Pi.single i 1))) (set.icc A B) MeasureTheory.MeasureSpace.Volume) : ∫ (x : Fin (n + 1) → ℝ) in set.icc A B, Finset.Univ.Sum (λ (i : Fin (n + 1)), ⇑(F' i x) (Pi.single i 1)) = Finset.Univ.Sum (λ (i : Fin (n + 1)), (∫ (x : Fin n → ℝ) in set.icc (A ∘ ⇑(i.Succ_above)) (B ∘ ⇑(i.Succ_above)), F i (i.Insert_nth (B i) x)) - ∫ (x : Fin n → ℝ) in set.icc (A ∘ ⇑(i.Succ_above)) (B ∘ ⇑(i.Succ_above)), F i (i.Insert_nth (A i) x))
{v : Type u} {K : Type v} [Field K] [AddCommGroup v] [module K v] [Finite_dimensional K v] [hK : Invertible 2] {B : BilinForm K v} (hB₂ : B.IsSymm) : ∃ (v : Basis (Fin (Finite_dimensional.finrank K v)) K v), B._Ortho ⇑v
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 P3 : P) : EuclideanGeometry.angle P1 P2 P3 ≤ Real.Pi
{α : Type u_1} [Preorder α] [Add_comm_Semigroup α] [HasSub α] [HasOrderedSub α] {A B C : α} [CovariantClass α α has_Add.Add has_LE.LE] : A + B - C ≤ A + (B - C)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) : hb.oangle (-x) y = hb.oangle x y + ↑Real.Pi
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B : α} : B < A → 0 < A - B
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {S : set E} {t : set F} {g : F → G} {F : E → F} (hg : ContDiff_on 𝕜 n g t) (hF : ContDiff_on 𝕜 n F S) : ContDiff_on 𝕜 n (g ∘ F) (S ∩ F ⁻¹' t)
{α : Type u} [PseudoMetricSpace α] {S : set α} {x : α} : 0 ≤ metric.Inf_dist x S
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z → B} [TopologicalSpace Z] [conditionally_complete_LinearOrder B] [OrderTopology B] (h : IsTopologicalFiberBundle F Proj) (A B : B) : ∃ (e : TopologicalFiberBundle.Trivialization F Proj), set.icc A B ⊆ e.Base_set
{m : Type u_1} [cancel_CommMonoid_with_Zero m] {q : Associates m} {n : ℕ} (hn : n ≠ 0) {C : Fin (n + 1) → Associates m} (h₁ : StrictMono C) (h₂ : ∀ {r : Associates m}, r ≤ q ↔ ∃ (i : Fin (n + 1)), r = C i) (hq : q ≠ 0) : Irreducible (C 1)
{α : Type u_1} {β : Type u_2} [has_Mul α] [Preorder α] [Preorder β] {F g : β → α} [CovariantClass α α has_Mul.Mul has_LE.LE] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LT.LT] (hF : StrictMono F) (hg : Monotone g) : StrictMono (λ (x : β), F x * g x)
(α : Type u_1) [TopologicalSpace α] [PolishSpace α] [Nonempty α] : ∃ (F : (ℕ → ℕ) → α), Continuous F ∧ Function.Surjective F
{R : Type u} [Semiring R] {P q : Polynomial R} : P * q = P.Support.Sum (λ (i : ℕ), q.Sum (λ (j : ℕ) (A : R), ⇑(Polynomial.monomial (i + j)) (P.Coeff i * A)))
{R : Type u_1} [CommSemiring R] {m : Type u_4} {N : Type u_5} {P : Type u_6} [AddCommMonoid m] [AddCommMonoid N] [AddCommMonoid P] [module R m] [module R N] [module R P] {g h : TensorProduct R m N →ₗ[R] P} (h : (TensorProduct.Mk R m N).compr₂ g = (TensorProduct.Mk R m N).compr₂ h) : g = h
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S u : set E} {F : E → F} {x : E} {n : ℕ} (hu : IsOpen u) (hs : UniqueDiffOn 𝕜 (S ∩ u)) (hx : x ∈ S ∩ u) : iterated_fderiv_within 𝕜 n F (S ∩ u) x = iterated_fderiv_within 𝕜 n F S x
{α : Type u} {β : Type v} [PseudoMetricSpace α] [PseudoMetricSpace β] {K : Nnreal} {S : set α} {F : α → β} : (∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → HasDist.dist (F x) (F y) ≤ ↑K * HasDist.dist x y) → LipschitzOnWith K F S
 : ¬_Field ℤ
{ι : Type u_1} {m : Type u_4} {N : Type u_5} [CommMonoid m] [ordered_CommMonoid N] (F : m → N) (P : m → Prop) (h_One : F 1 = 1) (h_Mul : ∀ (x y : m), P x → P y → F (x * y) ≤ F x * F y) (hp_Mul : ∀ (x y : m), P x → P y → P (x * y)) (g : ι → m) {S : Finset ι} (hs : ∀ (i : ι), i ∈ S → P (g i)) : F (S.Prod (λ (i : ι), g i)) ≤ S.Prod (λ (i : ι), F (g i))
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : E → ℝ} {A : E} (h : IsLocalMax F A) : fderiv ℝ F A = 0
{α : Type u_1} [Preorder α] [BoundedOrder α] [IsSimpleOrder α] {A B : α} (h : A < B) : A = ⊥
{α : Type u} {L₁ L₂ : List (α × Bool)} {x1 : α} {B1 : Bool} {x2 : α} {B2 : Bool} (h1 : (x1, B1) ≠ (x2, B2)) (h2 : free_Group.red ((x1, B1) :: L₁) ((x2, B2) :: L₂)) : free_Group.red L₁ ((x1, !B1) :: (x2, B2) :: L₂)
{α : Type u_1} {ι : sort u_4} {l : Filter α} {P : ι → Prop} {S : ι → set α} (h : l.has_Basis P S) {q : ι → Prop} (hq : ∀ (i : ι), P i → (∃ (j : ι), P j ∧ q j ∧ S j ⊆ S i)) : l.has_Basis (λ (i : ι), P i ∧ q i) S
{C : Type u₁} [CategoryTheory.Category C] {A : Type u₂} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (P : Cᵒᵖ ⥤ A) [CategoryTheory.Limits.HasPullbacks C] (S : A ⥤ Type (max v₁ u₁)) [CategoryTheory.Limits.HasLimits A] [CategoryTheory.Limits.PreservesLimits S] [CategoryTheory.ReflectsIsomorphisms S] : CategoryTheory.Presheaf.IsSheaf J P ↔ CategoryTheory.Presheaf.IsSheaf J (P ⋙ S)
{α : Type u_1} {β : Type u_2} [LinearOrder α] [SuccOrder α] [Preorder β] {F : α → β} (hF : Antitone F) : Pairwise (Disjoint on λ (n : α), set.Ico (F (Order.Succ n)) (F n))
{C : Type u₁} [CategoryTheory.Category C] {A t : C} (hT : CategoryTheory.Limits.IsTerminal t) [CategoryTheory.Mono (hT.from A)] : CategoryTheory.IsSubterminal A
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] : module.rank K v ≤ 1 ↔ ∃ (v₀ : v), ∀ (v : v), ∃ (r : K), r • v₀ = v
{ι : Type u_1} {E : Type u_3} [semi_NormedGroup E] {F : ι → E} {g : ι → ℝ} {A : ℝ} (hg : has_Sum g A) (h : ∀ (i : ι), ∥F i∥ ≤ g i) : ∥∑' (i : ι), F i∥ ≤ A
{α : Type u} [TopologicalSpace α] [LocallyCompactSpace α] (x : α) : ∃ (K : set α), IsCompact K ∧ K ∈ nhds x
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {F : E → G} {S : set E} {C : Nnreal} (hF : ∀ (x : E), x ∈ S → Differentiable_at 𝕜 F x) (bound : ∀ (x : E), x ∈ S → ∥fderiv 𝕜 F x∥₊ ≤ C) (hs : Convex ℝ S) : LipschitzOnWith C F S
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {n : WithTop ℕ} {F g : E → F} (hF : ContDiff_at 𝕜 n F x) (hg : ContDiff_at 𝕜 n g x) : ContDiff_at 𝕜 n (λ (x : E), F x + g x) x
{F : ℝ → ℝ} {A B l : ℝ} (hab : A < B) (hfa : Filter.Tendsto F (nhds_within A (set.ioi A)) (nhds l)) (hfb : Filter.Tendsto F (nhds_within B (set.Iio B)) (nhds l)) : ∃ (C : ℝ) (h : C ∈ set.Ioo A B), deriv F C = 0
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (S : Finset ι) [CharZero k] [Fintype ι] (h : S.Card ≠ 0) : Finset.Univ.Sum (λ (i : ι), Finset.centroid_weights_indicator k S i) = 1
{x : Type u} [Lattice x] [jordan_holder_Lattice x] {S₁ S₂ : Composition_series x} (h : ∀ (x : x), x ∈ S₁ ↔ x ∈ S₂) : S₁ = S₂
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) {S : set ι} {i : ι} (hi : i ∉ S) {l : ι →₀ 𝕜} (hl : l ∈ Finsupp.supported 𝕜 𝕜 S) : HasInner.inner (⇑(Finsupp.Total ι E 𝕜 v) l) (v i) = 0
{m : Type u_3} [Monoid m] (l : List m) : (l.nth 0).get_or_else 1 * l.tail.Prod = l.Prod
{α : Type u} {β : Type v} [EmetricSpace α] [PseudoEmetricSpace β] {F : α → β} (hF : Isometry F) : uniform_Embedding F
{K : Type u} [hfield : Field K] {L : Type u_1} [Field L] (F : K →+* L) (A : L) {x y : Ratfunc K} (hx : Polynomial.Eval₂ F A x.denom ≠ 0) (hy : Polynomial.Eval₂ F A y.denom ≠ 0) : Ratfunc.Eval F A (x * y) = Ratfunc.Eval F A x * Ratfunc.Eval F A y
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A B : α} (ha : 1 < A) (hb : 1 ≤ B) : 1 < A * B
{C : Type u_1} [CategoryTheory.Category C] (P : CategoryTheory.Idempotents.Karoubi C) : 𝟙 P = P.decomp_Id_i ≫ P.decomp_Id_P
{n : ℕ} {α : Type u_1} {v : Vector α (n + 1)} : v.Last = v.nth (Fin.Last n)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] [TopologicalSpace δ] {e₁ : α → β} {e₂ : γ → δ} (de₁ : Dense_Inducing e₁) (de₂ : Dense_Inducing e₂) : Dense_Inducing (λ (P : α × γ), (e₁ P.fst, e₂ P.Snd))
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] : IsBoundedBilinearMap 𝕜 (λ (P : (E →L[𝕜] 𝕜) × F), P.fst.Smul_Right P.Snd)
{x : Type v} [TopologicalSpace x] [LocallyCompactSpace x] [SigmaCompactSpace x] [t2_Space x] {ι : x → Type u} {P : Π (x : x), ι x → Prop} {B : Π (x : x), ι x → set x} {S : set x} (hs : IsClosed S) (hB : ∀ (x : x), x ∈ S → (nhds x).has_Basis (P x) (B x)) : ∃ (α : Type v) (C : α → x) (r : Π (A : α), ι (C A)), (∀ (A : α), C A ∈ S ∧ P (C A) (r A)) ∧ (S ⊆ ⋃ (A : α), B (C A) (r A)) ∧ locally_Finite (λ (A : α), B (C A) (r A))
{α : Type u_1} {β : Type u_2} [Infinite β] (F : α → Finset β) (W : (⋃ (A : α), ↑(F A)) = ⊤) : Cardinal.Mk β ≤ Cardinal.Mk ↥(set.Range F)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [Finite_dimensional 𝕜 E] [Finite_dimensional 𝕜 F] (A : E →ₗ[𝕜] F) : ⇑LinearMap.Adjoint (⇑LinearMap.Adjoint A) = A
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} {S : set E} : Mdifferentiable_on (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F S ↔ DifferentiableOn 𝕜 F S
(n A B : ℕ) : n < A ∨ B ≤ n ∨ n ∈ List.Ico A B
{α : Type u_1} {m m' : PseudoMetricSpace α} (h : PseudoMetricSpace.to_HasDist = PseudoMetricSpace.to_HasDist) : m = m'
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {F : E → F × G} {x : E} (hF : ContDiff_at 𝕜 n F x) : ContDiff_at 𝕜 n (λ (x : E), (F x).Snd) x
{F : ℕ → ℝ} (h_nonneg : ∀ (n : ℕ), 0 ≤ F n) (h_Mono : ∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → F n ≤ F m) : Summable (λ (k : ℕ), 2 ^ k * F (2 ^ k)) ↔ Summable F
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 P4 P5 : P} (hapc : EuclideanGeometry.angle P1 P5 P3 = Real.Pi) (hbpd : EuclideanGeometry.angle P2 P5 P4 = Real.Pi) : EuclideanGeometry.angle P1 P5 P2 = EuclideanGeometry.angle P3 P5 P4
{E : Type u_2} [AddCommGroup E] [module ℝ E] (S : Convex_cone ℝ E) (F : LinearPmap ℝ E ℝ) (nonneg : ∀ (x : ↥(F.IsDomain)), ↑x ∈ S → 0 ≤ ⇑F x) (Dense : ∀ (y : E), ∃ (x : ↥(F.IsDomain)), ↑x + y ∈ S) (hdom : F.IsDomain ≠ ⊤) : ∃ (g : LinearPmap ℝ E ℝ), F < g ∧ ∀ (x : ↥(g.IsDomain)), ↑x ∈ S → 0 ≤ ⇑g x
{R : Type u_4} {S : Type u_5} [non_assoc_Semiring R] [non_assoc_Semiring S] (F : R ≃+* S) : ↑F.to_Monoid_hom = ↑F.to_Monoid_hom
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Finite_wide_pullbacks C] {B : C} : CategoryTheory.Limits.has_Finite_products (CategoryTheory.Over B)
{α : Type u} {β : Type v} [TopologicalSpace α] [semi_NormedGroup β] (F : bounded_Continuous_Function α β) : ∥F∥ = HasInf.Inf {C : ℝ | 0 ≤ C ∧ ∀ (x : α), ∥⇑F x∥ ≤ C}
{α : Type u_1} [PseudoMetricSpace α] (C : ℝ) {F : ℕ → α} (hu₂ : ∀ (n : ℕ), HasDist.dist (F n) (F (n + 1)) ≤ C / 2 / 2 ^ n) {A : α} (ha : Filter.Tendsto F Filter.at_top (nhds A)) : HasDist.dist (F 0) A ≤ C
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {x : E} {S t : set E} (ht : t ∈ nhds x) : TangentConeAt 𝕜 (S ∩ t) x = TangentConeAt 𝕜 S x
{α : Type u} [PseudoMetricSpace α] {S t : set α} {y : α} {r : ℝ} (h : y ∈ t) (h : metric.Hausdorff_dist S t < r) (Fin : Emetric.Hausdorff_edist S t ≠ ⊤) : ∃ (x : α) (h : x ∈ S), HasDist.dist x y < r
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasEqualizers C] {x Y : C} [CategoryTheory.Simple Y] {F : x ⟶ Y} [CategoryTheory.Limits.HasImage F] (W : F ≠ 0) : CategoryTheory.Epi F
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_NormedGroup E'] [semi_NormedGroup F'] {F' : α → E'} {g' : α → F'} {l : Filter α} : F' =o[l] g' → ((λ (x : α), ∥F' x∥) =o[l] λ (x : α), ∥g' x∥)
{n : ℕ} [Fact (0 < n)] (i : Zmod (2 * n)) : order_of (Quaternion_Group.A i) = 2 * n / (2 * n).Gcd i.val
{n : ℕ} {fs : Finset (Fin (n + 1))} (h : fs.Nonempty) : Finset.Univ.Sum (λ (i : Affine.Simplex.points_with_circumcenter_Index n), Affine.Simplex.centroid_weights_with_circumcenter fs i) = 1
{m : Type u_1} [has_Add m] {C D : Add_Con m} : C ≤ D ↔ ∀ {x y : m}, ⇑C x y → ⇑D x y
{α : Type u} [MulOneClass α] : _Monoid_hom Id
(𝕜 : Type u) [nondiscrete_NormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace 𝕜] {r : ℝ} (rpos : 0 < r) (h : IsCompact (metric.IsClosed_ball 0 r)) : Finite_dimensional 𝕜 E
{α : Type u_1} [conditionally_CompleteLattice α] {S : set α} {A B : α} (hs : BddAbove S) (ha : A ∈ S) (h : B < A) : B < HasSup.Sup S
{ιA : Type u_7} {ιB : Type u_8} [DecidableEq ιA] [DecidableEq ιB] [Fintype ιA] [Fintype ιB] {R' : Type u_9} {mᵢ : Type u_10} {N₁ : Type u_11} {N₂ : Type u_12} [CommSemiring R'] [AddCommGroup N₁] [module R' N₁] [AddCommGroup N₂] [module R' N₂] [AddCommMonoid mᵢ] [module R' mᵢ] (A : MultilinearMap R' (λ (_x : ιA), mᵢ) N₁) (B : MultilinearMap R' (λ (_x : ιB), mᵢ) N₂) : ⇑MultilinearMap.alternatization (A.Dom_Coprod B) = (⇑MultilinearMap.alternatization A).Dom_Coprod (⇑MultilinearMap.alternatization B)
(x : Pgame) : (x + 0).Equiv x
(R : Type u) [Semiring R] : strong_RankCondition R ↔ ∀ (n : ℕ) (F : (Fin (n + 1) → R) →ₗ[R] Fin n → R), ¬Function.Injective ⇑F
(P : ℕ) [Fact (Nat.Prime P)] : padic_norm P ↑P = 1 / ↑P
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) [Invertible A] : A.Mul (⅟ A) = 1
{α : Type u_1} [DecidableEq α] {U v : Finset α} (hUV : U.Card = v.Card) (A : Finset α) : (Uv.compress U v A).Card = A.Card
{R : Type u_1} [CommSemiring R] (r : R) : ⇑laurent_Polynomial.C r = ⇑(Algebra_Map R (laurent_Polynomial R)) r
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P1 : P) (g : G) (P2 : P) : P1 = g +ᵥ P2 ↔ P1 -ᵥ P2 = g
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra A B] [Algebra R B] [Algebra R A] [IsScalarTower R A B] (hA : Algebra.IsIntegral R A) (hB : Algebra.IsIntegral A B) : Algebra.IsIntegral R B
{ι : Type u_1} {ι' : Type u_2} {α : Type u_3} [Fintype ι] [Preorder ι'] [_Directed ι' has_LE.LE] [Nonempty ι'] {S : ι → ι' → set α} (hs : ∀ (i : ι), Monotone (S i)) : (⋃ (j : ι'), ⋂ (i : ι), S i j) = ⋂ (i : ι), ⋃ (j : ι'), S i j
{J : Type u₁} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {K : Type u₁} [CategoryTheory.Category K] (F : J ⥤ C) (G : K ⥤ C) (h : F.cocones ≅ G.cocones) [CategoryTheory.Limits.HasColimit F] : CategoryTheory.Limits.HasColimit G
{α : Type u} [Infinite α] {S : set α} (hF : S.Finite) : S ∉ Filter.hyperfilter α
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A B : α} (ha : A ≤ 1) (hb : B ≤ 1) : A * B ≤ 1
{G : Type u} [Monoid G] {h : Type v} [Monoid h] (F : G →* h) {x : G} (h : _of_Fin_order x) : _of_Fin_order (⇑F x)
{α : Type u_1} {β : Type u_2} [UniformSpace α] {l : Filter β} {F : β → α × α} (h : Filter.Tendsto F l (Uniformity α)) : Filter.Tendsto (λ (x : β), ((F x).Snd, (F x).fst)) l (Uniformity α)
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {F : Filter α} {g : Filter β} {m : α' → β → γ} {n : α → α'} {m' : β → α → δ} {n' : δ → γ} (h_Left_anticomm : ∀ (A : α) (B : β), m (n A) B = n' (m' B A)) : Filter.Map₂ m (Filter.Map n F) g = Filter.Map n' (Filter.Map₂ m' g F)
(u : ℤˣ) : u ^ 2 = 1
{G : Type W} [TopologicalSpace G] [AddGroup G] [topological_AddGroup G] {K U : set G} (hK : IsCompact K) (hU : IsOpen U) (hKU : K ⊆ U) : ∃ (v : set G) (h : v ∈ nhds 0), K + v ⊆ U
{B x : Ordinal} (h : 1 < B) : {o : Ordinal | x < B ^ o}.Nonempty
{P : ℕ} [Fact (Nat.Prime P)] (hp : P % 4 = 1) : ∃ (A B : ℕ), A ^ 2 + B ^ 2 = P
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {δ : Type u_1} [LinearOrder δ] [TopologicalSpace δ] [order_IsClosed_topology δ] {F : α → δ} (hF : Continuous F) (h_top : Filter.Tendsto F Filter.at_top Filter.at_top) (h_IsBot : Filter.Tendsto F Filter.at_IsBot Filter.at_IsBot) : Function.Surjective F
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {F g : ℂ → E} (hdf : Diff_Cont_on_cl ℂ F (set.Iio 0 ×ℂ set.ioi 0)) (hBf : ∃ (C : ℝ) (h : C < 2) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal (set.Iio 0 ×ℂ set.ioi 0)] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hdg : Diff_Cont_on_cl ℂ g (set.Iio 0 ×ℂ set.ioi 0)) (hBg : ∃ (C : ℝ) (h : C < 2) (B : ℝ), g =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal (set.Iio 0 ×ℂ set.ioi 0)] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hre : ∀ (x : ℝ), x ≤ 0 → F ↑x = g ↑x) (him : ∀ (x : ℝ), 0 ≤ x → F (↑x * Complex.i) = g (↑x * Complex.i)) : set.Eq_on F g {z : ℂ | z.re ≤ 0 ∧ 0 ≤ z.im}
{R : Type u} [CommSemiring R] {S : Type v} [Semiring S] [Algebra R S] (P : Polynomial R) : ⇑(Polynomial.Map_alg R S) P = Polynomial.Map (Algebra_Map R S) P
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P₂ : ι → P) (P₁ B : P) : S.Sum (λ (i : ι), W i • (P₁ -ᵥ P₂ i)) = S.Sum (λ (i : ι), W i) • (P₁ -ᵥ B) - ⇑(S.weighted_vsub_of_point P₂ B) W
{S : Type u_1} [has_Mul S] {A B : S} (h : Commute A B) : Commute B A
{R : Type u} [CommSemiring R] (t : Multiset (Polynomial R)) (h : (Multiset.Map Polynomial.leading_Coeff t).Prod ≠ 0) : t.Prod.leading_Coeff = (Multiset.Map Polynomial.leading_Coeff t).Prod
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [HasScalar 𝕜 E] {S t : Convex_cone 𝕜 E} : ↑S = ↑t ↔ S = t
{x y z : Pgame} (h₁ : x.lf y) (h₂ : y < z) : x.lf z
{C : Type u₁} [CategoryTheory.Category C] {x Y : C} (F : x ⟶ Y) [CategoryTheory.RegularEpi F] [m : CategoryTheory.Mono F] : CategoryTheory.IsIso F
{γ : Type u_3} [tγ : TopologicalSpace γ] [PolishSpace γ] [MeasurableSpace γ] [BorelSpace γ] {S : set γ} : PolishSpace._clopenable S ↔ Measurable_set S
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] (A B : α) : Filter.comap Coe (nhds_within A (set.ioi A)) = Filter.at_IsBot
(n : ℕ+) (S : set ℕ+) (K : Type W) (L : Type z) [Field K] [Field L] [Algebra K L] [Ne_Zero ↑↑n] [IsCyclotomicExtension S K L] (hS : n ∈ S) : Polynomial.Splits (Algebra_Map K L) (Polynomial.cyclotomic ↑n K)
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) (x y : R) : v.Int_Valuation_def (x * y) = v.Int_Valuation_def x * v.Int_Valuation_def y
{τ : Type u_1} {α : Type u_2} {β : Type u_3} [TopologicalSpace β] (F : Filter τ) (ϕ : τ → α → β) (S : set α) (y : β) : y ∈ OmegaLimit F ϕ S ↔ ∀ (n : set β), n ∈ nhds y → (∃ᶠ (t : τ) in F, (S ∩ ϕ t ⁻¹' n).Nonempty)
{α : Type u_1} [TopologicalSpace α] {x : α} {S : set α} {γ : Type u_4} [Linear_ordered_AddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] [has_Continuous_Add γ] {F g : α → γ} (hF : LowerSemicontinuous_within_at F S x) (hg : LowerSemicontinuous_within_at g S x) : LowerSemicontinuous_within_at (λ (z : α), F z + g z) S x
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {F : ℂ → E} {C : ℂ} {R : ℝ} {W : ℂ} (hF : CircleIntegrable F C R) (hw : Complex.Abs W < R) : has_Sum (λ (n : ℕ), ⇑(Cauchy_PowerSeries F C R n) (λ (_x : Fin n), W)) ((2 * ↑Real.Pi * Complex.i)⁻¹ • ∮ (z : ℂ) in C(C, R), (z - (C + W))⁻¹ • F z)
{α : Type u_1} {r : α → α → Prop} {S : set α} [IsRefl α r] : S.Pairwise r → ∀ ⦃A : α⦄, A ∈ S → ∀ ⦃B : α⦄, B ∈ S → r A B
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) : _R_or_C.Abs (HasInner.inner x y / (↑∥x∥ * ↑∥y∥)) = 1 ↔ x ≠ 0 ∧ ∃ (r : 𝕜), r ≠ 0 ∧ y = r • x
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] {A : α} : -A < 0 → 0 < A
{m : Type u_1} [Monoid m] {S : set m} : S ⊆ Monoid.Closure S
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasCoproducts C] [CategoryTheory.Limits.HasCoequalizers C] : CategoryTheory.Limits.HasColimits C
{G : Type u_7} [AddCommGroup G] (L : List G) (n : ℕ) (A : G) : (L.update_nth n A).Sum = L.Sum + dite (n < L.length) (λ (hn : n < L.length), -L.nth_LE n hn + A) (λ (hn : ¬n < L.length), 0)
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {S : set 𝕜} {F : 𝕜 → 𝕜} (hs : Convex 𝕜 S) (hF : ∀ {x y z : 𝕜}, x ∈ S → z ∈ S → x < y → y < z → (F y - F x) / (y - x) < (F z - F y) / (z - y)) : strict_Convex_on 𝕜 S F
{m : Type u_1} {N : Type u_2} [has_Mul m] [has_Mul N] {C : Con m} {F : m → N} (h : ∀ (x y : m), F (x * y) = F x * F y) (h : Con.Mul_Ker F h ≤ C) (hF : Function.Surjective F) : C.Map_gen F = C.Map_of_surjective F h h hF
(m : Type u_1) (α : Type u_2) [Group m] [MulAction m α] {ι : sort u_3} {S : ι → set α} : fixing_Subgroup m (⋃ (i : ι), S i) = ⨅ (i : ι), fixing_Subgroup m (S i)
{G : Type u_1} [Group G] [TopologicalSpace G] [topological_Group G] [t2_Space G] {K₀ : TopologicalSpace.PositiveCompacts G} : ⇑(MeasureTheory.Measure.haar.haar_content K₀) K₀.to_Compacts = 1
{γ : Type W} [SemilatticeSup γ] {S t : set γ} : BddAbove (S ∪ t) ↔ BddAbove S ∧ BddAbove t
{α : Type u} [Group α] [has_LE α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A : α} : A⁻¹ ≤ 1 → 1 ≤ A
(n P : ℕ) : (Finset.Range n).Sum (λ (k : ℕ), ↑k ^ P) = (Finset.Range (P + 1)).Sum (λ (i : ℕ), bernoulli i * ↑((P + 1).choose i) * ↑n ^ (P + 1 - i) / (↑P + 1))
{A : Type u_3} [Semiring A] [Algebra ℝ A] (F : ℂ →ₐ[ℝ] A) (x : ℝ) : ⇑F ↑x = ⇑(Algebra_Map ℝ A) x
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] : ⊤ ∈ FixedBy_Finite K L
{R : Type u} [non_assoc_Semiring R] (S : Subsemiring R) {ι : Type u_1} {t : Finset ι} {F : ι → R} (h : ∀ (C : ι), C ∈ t → F C ∈ S) : t.Sum (λ (i : ι), F i) ∈ S
{α : Type u_1} {m : Type u_5} [has_Zero m] {F g : α →₀ m} : F = g ↔ ∀ (A : α), ⇑F A = ⇑g A
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {i : α → β} [t2_Space β] (di : Dense_Inducing i) (hD : Dense (set.Range i)ᶜ) {S : set α} (hs : IsCompact S) : Interior S = ∅
{C : Type u} [CategoryTheory.Category C] {x : top} [CategoryTheory.Limits.HasProducts C] (F : top.Presheaf C x) : F._sheaf ↔ F._sheaf_Opens_LE_cover
{α : Type u_1} (L L' : List (List α)) : L = L' ↔ L.Join = L'.Join ∧ List.Map List.length L = List.Map List.length L'
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {x : E} {n : WithTop ℕ} (h : ContDiff_at 𝕜 n F x) (hn : 1 ≤ n) : Differentiable_at 𝕜 F x
{α : Type u} [PseudoEmetricSpace α] (δ : ℝ) : Metric.Cthickening δ ∅ = ∅
{C : Type v} [CategoryTheory.SmallCategory C] {D : Type v} [CategoryTheory.SmallCategory D] (F : C ⥤ D) [F.final] {E : Type u} [CategoryTheory.Category E] {G : D ⥤ E} [CategoryTheory.Limits.HasColimit (F ⋙ G)] : CategoryTheory.Limits.HasColimit G
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] (P : E) : ⇑(reflection K) P = bit0 ↑(⇑(Orthogonal_projection K) P) - P
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {ca cb : E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (ha : Filter.Tendsto F (nhds A ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds ca)) (hb : Filter.Tendsto F (nhds B ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds cb)) : HasFderivAt (λ (P : ℝ × ℝ), ∫ (x : ℝ) in P.fst..P.Snd, F x) ((Continuous_Linear_Map.Snd ℝ ℝ ℝ).Smul_Right cb - (Continuous_Linear_Map.fst ℝ ℝ ℝ).Smul_Right ca) (A, B)
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : E → ℝ} {A : E} {F' : E →L[ℝ] ℝ} (h : IsLocalMin F A) (hF : HasFderivAt F F' A) : F' = 0
{α : Type u} {β : Type v} [Preorder β] {F : α → β} {S : set α} {A : α} : IsMaxOn F S A → IsMinOn (⇑order_dual.to_dual ∘ F) S A
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) : Kᗮ = ⨅ (v : ↥K), (⇑innerSL ↑v).Ker
{C : Type u} {A : Type u_1} [CategoryTheory.Category C] [AddCommMonoid A] [CategoryTheory.HasShift C A] {x Y : C} (F : x ⟶ Y) (i j : A) : (CategoryTheory.shift_Functor C j).Map ((CategoryTheory.shift_Functor C i).Map F) = (CategoryTheory.shift_comm x i j).hom ≫ (CategoryTheory.shift_Functor C i).Map ((CategoryTheory.shift_Functor C j).Map F) ≫ (CategoryTheory.shift_comm Y j i).hom
{α : Type u_1} [LinearOrder α] [PredOrder α] [_Pred_Archimedean α] (r : α → α → Prop) {n m : α} (h1 : ∀ (i : α), i ∈ set.ioc m n → r i (Order.Pred i)) (h2 : ∀ (i : α), i ∈ set.ioc n m → r (Order.Pred i) i) : Relation.refl_Trans_gen r n m
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [Ring_hom_isometric σ₁₂] (F : E →sl[σ₁₂] F) : LipschitzWith ∥F∥₊ ⇑F
{α : Type u_1} (r : Setoid α) : EqvGen.Setoid Setoid.r = r
{α : Type u} [PseudoEmetricSpace α] (δ : ℝ) (E : set α) : Metric.Thickening δ E ⊆ Metric.Cthickening δ E
{α : Type u} {β : Type v} [TopologicalSpace α] [semi_NormedGroup β] [Star_AddMonoid β] [normed_Star_Group β] (F : bounded_Continuous_Function α β) : ⇑(HasStar.Star F) = HasStar.Star ⇑F
(x : clifford_Algebra clifford_Algebra_Complex.q) : ⇑clifford_Algebra.reverse x = x
{D : set ℝ} (hD : Convex ℝ D) {F : ℝ → ℝ} (hF : Continuous_on F D) (hF' : ∀ (x : ℝ), x ∈ Interior D → 0 < deriv F x) : StrictMono_on F D
{J : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.IsCofiltered J] (F : J ⥤ top) (C : CategoryTheory.Limits.Cone F) (hC : CategoryTheory.Limits.IsLimit C) (t : Π (j : J), set (set ↥(F.obj j))) (hT : ∀ (j : J), TopologicalSpace._topological_Basis (t j)) (Univ : ∀ (i : J), set.Univ ∈ t i) (Inter : ∀ (i : J) (U1 U2 : set ↥(F.obj i)), U1 ∈ t i → U2 ∈ t i → U1 ∩ U2 ∈ t i) (compat : ∀ (i j : J) (F : i ⟶ j) (v : set ↥(F.obj j)), v ∈ t j → ⇑(F.Map F) ⁻¹' v ∈ t i) : TopologicalSpace._topological_Basis {U : set ↥(C.x) | ∃ (j : J) (v : set ↥(F.obj j)), v ∈ t j ∧ U = ⇑(C.π.App j) ⁻¹' v}
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {v : set E} [Finite_dimensional 𝕜 E] (hv : Orthonormal 𝕜 Coe) : (∀ (u : set E), u ⊇ v → Orthonormal 𝕜 Coe → u = v) ↔ ∃ (B : Basis ↥v 𝕜 E), ⇑B = Coe
{Γ₀ : Type u_1} [Linear_ordered_comm_Group_with_Zero Γ₀] (γ : Γ₀) (h : γ ≠ 0) : nhds γ = has_pure.pure γ
{ι : Type u_1} {R : Type u_2} [CommRing R] [LinearOrder ι] (S : Finset ι) (F : ι → R) : S.Prod (λ (i : ι), 1 - F i) = 1 - S.Sum (λ (i : ι), F i * (Finset.Filter (λ (_x : ι), _x < i) S).Prod (λ (j : ι), 1 - F j))
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) {x : D} [CategoryTheory.IsIso (h.counit.App x)] : CategoryTheory.Inv (R.Map (h.counit.App x)) = h.Unit.App (R.obj x)
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {F F' : ℂ → E} {C : ℂ} {R : ℝ} (hR : 0 ≤ R) (h : ∀ (z : ℂ), z ∈ Metric.Sphere C R → HasDerivWithinAt F (F' z) (Metric.Sphere C R) z) : ∮ (z : ℂ) in C(C, R), F' z = 0
(C : Type u) [CategoryTheory.Category C] [∀ {x Y Z : C} {F : x ⟶ Z} {g : Y ⟶ Z}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan F g)] : CategoryTheory.Limits.HasPullbacks C
{n k : ℕ} (h : k ≤ n) : n.Desc_factorial k = n.factorial / (n - k).factorial
{α : Type u} {β : Type v} [DecidableEq α] [AddCommMonoid β] {S : Finset α} {x : α} (h : x ∉ S) (F : Finset α → β) : (HasInsert.Insert x S).powerset.Sum (λ (A : Finset α), F A) = S.powerset.Sum (λ (A : Finset α), F A) + S.powerset.Sum (λ (t : Finset α), F (HasInsert.Insert x t))
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) (hx0 : x ≠ 0) (hy0 : y ≠ 0) : _R_or_C.Abs (HasInner.inner x y) = ∥x∥ * ∥y∥ ↔ ∃ (r : 𝕜), r ≠ 0 ∧ y = r • x
{α : Type u_1} [DecidableEq α] {𝒜 : Finset (Finset α)} {S : Finset α} : S ∈ 𝒜.shadow ↔ ∃ (A : α) (h : A ∉ S), HasInsert.Insert A S ∈ 𝒜
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P ⟶ q) : ⇑F 0 = 0
{α : Type u} {β : Type v} [Group α] [Group β] {F : α → β} (hF : _Group_hom F) {γ : Type u_1} [Group γ] {g : β → γ} (hg : _Group_hom g) : _Group_hom (g ∘ F)
{R : Type u} {ι : Type u'} {m₁ : ι → Type v₁} {m₂ : Type v₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (m₁ i)] [AddCommMonoid m₂] [Π (i : ι), module R (m₁ i)] [module R m₂] (F : MultilinearMap R m₁ m₂) {α : ι → Type u_1} (g : Π (i : ι), α i → m₁ i) (A : Π (i : ι), Finset (α i)) [Fintype ι] : ⇑F (λ (i : ι), (A i).Sum (λ (j : α i), g i j)) = (Fintype.Pi_Finset A).Sum (λ (r : Π (A : ι), α A), ⇑F (λ (i : ι), g i (r i)))
(Γ₀ : Type u_1) [Linear_ordered_comm_Group_with_Zero Γ₀] (x : Γ₀) {S : set Γ₀} (S_in : S ∈ Linear_ordered_comm_Group_with_Zero.nhds_fun Γ₀ x) : ∃ (t : set Γ₀) (h : t ∈ Linear_ordered_comm_Group_with_Zero.nhds_fun Γ₀ x), t ⊆ S ∧ ∀ (y : Γ₀), y ∈ t → S ∈ Linear_ordered_comm_Group_with_Zero.nhds_fun Γ₀ y
{E : Type u_2} {𝕜 : Type u_3} [Linear_ordered_Field 𝕜] [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul 𝕜 E] {S : set E} (hs : Convex 𝕜 S) {x y : E} (hx : x ∈ Closure S) (hy : y ∈ Interior S) {t : 𝕜} (ht : t ∈ set.ioc 0 1) : x + t • (y - x) ∈ Interior S
{A : Type u_4} {K : Type u_5} {C : Type u_6} [CommRing A] [IsDomain A] [Field K] [Algebra A K] [_fraction_Ring A K] [CommRing C] [Algebra A C] [Algebra K C] [IsScalarTower A K C] : Algebra.IsAlgebraic A C ↔ Algebra.IsAlgebraic K C
{K : Type u_1} [CommRing K] [IsDomain K] {P : Polynomial K} (hroots : ⇑Multiset.Card P.roots = P.Nat_degree) : ⇑Polynomial.C P.leading_Coeff * (Multiset.Map (λ (A : K), Polynomial.x - ⇑Polynomial.C A) P.roots).Prod = P
{α : Type u} {β : Type v} [Preorder α] [SemilatticeInf β] {F g : α → β} (hF : Monotone F) (hg : Monotone g) : Monotone (F ⊓ g)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [AddCommMonoid α] [TopologicalSpace α] [t2_Space α] [Encodable γ] [CompleteLattice β] (m : β → α) (m0 : m ⊥ = 0) (R : α → α → Prop) (m_supr : ∀ (S : ℕ → β), R (m (⨆ (i : ℕ), S i)) (∑' (i : ℕ), m (S i))) (S : γ → β) : R (m (⨆ (B : γ), S B)) (∑' (B : γ), m (S B))
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {F : J ⥤ C} {S t : CategoryTheory.Limits.Cocone F} (P : CategoryTheory.Limits.IsColimit S) (q : CategoryTheory.Limits.IsColimit t) (F : S ⟶ t) : CategoryTheory.IsIso F
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S : set P) : affine_Span k S = HasInf.Inf {S' : AffineSubspace k P | S ⊆ ↑S'}
{α : Type u_1} {n : Type u_4} [_R_or_C α] [Fintype n] [DecidableEq n] {A : Matrix n n α} : A._hermitian ↔ InnerProductSpace.IsSelfAdjoint (⇑((Pi_Lp.Linear_Equiv α (λ (_x : n), α)).Symm.Conj) (⇑Matrix.to_lin' A))
{α : Type u} [PseudoMetricSpace α] (x y : α) : HasDist.dist ↑x ↑y = HasDist.dist x y
{α : Type u_1} {β : Type u_2} {rα : α → α → Prop} {rβ : β → β → Prop} (hα : WellFounded rα) (hβ : WellFounded rβ) : WellFounded (Relation.Game_Add rα rβ)
{R : Type u_1} {S : Type u_4} [CommRing R] [CommRing S] (P : Polynomial R) (x : S) [Algebra R S] (h : ⇑(Polynomial.aeval x) P = 0) : IsIntegral R (P.leading_Coeff • x)
{n : ℕ} (hpos : 0 < n) (R : Type u_1) [CommRing R] : n.divisors.Prod (λ (i : ℕ), Polynomial.cyclotomic i R) = Polynomial.x ^ n - 1
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (m : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) : ∃ (L L' : List (Matrix.TransvectionStruct (Fin r ⊕ Unit) 𝕜)), (((List.Map Matrix.TransvectionStruct.to_Matrix L).Prod.Mul m).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L').Prod)._two_block_Diagonal
{k : Type u_1} {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} {S : Finset ι} (P : ι → P) (h : ↑(S.Card) ≠ 0) : Finset.centroid k S P ∈ affine_Span k (set.Range P)
{α : Type u_1} (F : Finpartition set.Univ) : Setoid._Partition ↑(F.Parts)
{n : ℕ} {β : Type u_1} (q : Fin (n + 2) → β) : Fin.tail (Fin.init q) = Fin.init (Fin.tail q)
(F : Circle_deg1_Lift) {x : ℝ} {m : ℤ} (h : ⇑F x = x + ↑m) : F.TranslationNumber = ↑m
{𝕂 : Type u_1} [_R_or_C 𝕂] : HasDerivAt (Exp 𝕂) 1 0
{α : Type u} {β : Type v} [UniformSpace α] [SemilatticeSup β] [CompleteSpace α] {u : β → α} (h : Cauchy_Seq u) : ∃ (x : α), Filter.Tendsto u Filter.at_top (nhds x)
{A B r : ℝ} (h : -1 < r) : IntervalIntegrable (λ (x : ℝ), x ^ r) MeasureTheory.MeasureSpace.Volume A B
{𝕜 : Type u_1} [_R_or_C 𝕜] [DecidableEq 𝕜] {n : Type u_2} [Fintype n] [DecidableEq n] {A : Matrix n n 𝕜} (hA : A._hermitian) : hA.eigenvector_Matrix_Inv.Mul A = (Matrix.Diagonal (Coe ∘ hA.Eigenvalues)).Mul hA.eigenvector_Matrix_Inv
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] [Nonempty v] : ∃ (v : v), G.min_degree = G.degree v
{S : Type u_1} [Add_Semigroup S] {A B C : S} (hab : Add_Commute A B) (hac : Add_Commute A C) : Add_Commute A (B + C)
{α : Type u_1} {l l' : List α} : l <+ l' ↔ ∃ (F : Fin l.length ↪o Fin l'.length), ∀ (ix : Fin l.length), l.nth_LE ↑ix _ = l'.nth_LE ↑(⇑F ix) _
{R S : CommRing} (F : R ⟶ S) (P : Prime_Spectrum ↥S) : (AlgebraicGeometry.StructureSheaf.stalk_iso ↥R (⇑(Prime_Spectrum.comap F) P)).hom ≫ Localization.local_Ring_hom (⇑(Prime_Spectrum.comap F) P).as_Ideal P.as_Ideal F rfl ≫ (AlgebraicGeometry.StructureSheaf.stalk_iso ↥S P).Inv = AlgebraicGeometry.PresheafedSpace.stalk_Map (AlgebraicGeometry.spec.SheafedSpace_Map F) P
{R : Type u} [CommSemiring R] {S : Type v} [Semiring S] [Algebra R S] {P : Polynomial S} (r : R) (hp : P ∈ Polynomial.lifts (Algebra_Map R S)) : r • P ∈ Polynomial.lifts (Algebra_Map R S)
{m : Type u_1} {B : Type u_3} [AddMonoid m] [set_like B m] [Add_Submonoid_class B m] {S : B} {l : List m} (hl : ∀ (x : m), x ∈ l → x ∈ S) : l.Sum ∈ S
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B → Type u_5} [Semiring R] [Π (x : B), AddCommMonoid (E x)] [Π (x : B), module R (E x)] [TopologicalSpace F] [AddCommMonoid F] [module R F] [TopologicalSpace B] [TopologicalSpace (Bundle.Total_Space E)] (e e' : topological_Vector_Bundle.trivialization R F E) {B : B} (hb : B ∈ e.to_fiber_Bundle_trivialization.Base_set ∩ e'.to_fiber_Bundle_trivialization.Base_set) (y : F) : ⇑(e.coord_change e' B) y = (⇑e' (⇑(e.to_fiber_Bundle_trivialization.to_LocalHomeomorph.Symm) (B, y))).Snd
 : Function.Surjective Real.sinh
{α : Type u_1} [TopologicalSpace α] [BaireSpace α] {S : set α} : S ∈ residual α ↔ ∃ (t : set α) (h : t ⊆ S), _Gδ t ∧ Dense t
{α : Type u} [TopologicalSpace α] {F : Filter α} {A : α} : F ≤ nhds A ↔ ∀ (S : set α), A ∈ S → IsOpen S → S ∈ F
{R : Type u} [CommSemiring R] {n : ℕ} (hn : 0 < n) : Function.Injective ⇑(Polynomial.expand R n)
{α : Type u} [CommSemiring α] {P P' ps ps' : α} : P = P' → ps = ps' → P * ps = P' * ps'
{α : Type u_1} {n : Type u_4} [AddGroup n] {v : n → α} : (Matrix.circulant v).IsSymm ↔ ∀ (i : n), v (-i) = v i
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {F : 𝕜 → F} {x : 𝕜} {m : Fin n → 𝕜} : ⇑(iterated_fderiv 𝕜 n F x) m = Finset.Univ.Prod (λ (i : Fin n), m i) • iterated_deriv n F x
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [strict_Convex_Space ℝ E] {x y : E} : SameRay ℝ x y ↔ ∥x + y∥ = ∥x∥ + ∥y∥
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (x Y : C) [CategoryTheory.Limits.HasBinaryBiproduct x Y] {B : CategoryTheory.Limits.BinaryBicone x Y} (hb : B._bilimit) : (hb._Limit.cone_point_Unique_Up_to_iso (CategoryTheory.Limits.BinaryBiproduct._Limit x Y)).Inv = CategoryTheory.Limits.biprod.Desc B.inl_ B.inr_
{m : Type u_1} [has_Add m] {C D : Add_Con m} : Setoid.r = Setoid.r ↔ C = D
{R : Type u} {n : ℕ} {m : Fin n.Succ → Type v} {m₂ : Type v₂} [Semiring R] [Π (i : Fin n.Succ), AddCommMonoid (m i)] [AddCommMonoid m₂] [Π (i : Fin n.Succ), module R (m i)] [module R m₂] (F : MultilinearMap R m m₂) (m : Π (i : Fin n), m i.Succ) (C : R) (x : m 0) : ⇑F (Fin.Cons (C • x) m) = C • ⇑F (Fin.Cons x m)
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} (h : InnerProductGeometry.angle x y = 0) : ∥x + y∥ = ∥x∥ + ∥y∥
{ι : Type u_1} {x : ℕ} {S : ι → ℕ} {t : Finset ι} : (∀ (i : ι), i ∈ t → x.IsCoprime (S i)) → x.IsCoprime (t.Prod (λ (i : ι), S i))
{K : Type u_1} [Linear_ordered_Field K] {A : K} (h : 1 < A) (n : ℕ) : ↑n ≤ (A ^ n - 1) / (A - 1)
{α : Type u} {β : Type v} [omega_complete_PartialOrder α] [omega_complete_PartialOrder β] (C₀ : omega_complete_PartialOrder.chain (α →𝒄 β)) (C₁ : omega_complete_PartialOrder.chain α) (z : β) : (∀ (i j : ℕ), ⇑(⇑C₀ i) (⇑C₁ j) ≤ z) ↔ ∀ (i : ℕ), ⇑(⇑C₀ i) (⇑C₁ i) ≤ z
{α : Type u_1} [Preorder α] {F : α → α} (h : Id ≤ F) (n : ℕ) : Id ≤ (F^[n])
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [Linear_ordered_Field 𝕜] [AddCommGroup E] [Linear_ordered_AddCommGroup β] [module 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F : E → β} {t : Finset ι} {W : ι → 𝕜} {P : ι → E} (h : ConcaveOn 𝕜 S F) (hw₀ : ∀ (i : ι), i ∈ t → 0 ≤ W i) (hw₁ : 0 < t.Sum (λ (i : ι), W i)) (hp : ∀ (i : ι), i ∈ t → P i ∈ S) : ∃ (i : ι) (h : i ∈ t), F (P i) ≤ F (t.Center_mass W P)
{α : Type u} [AddGroup α] [has_LE α] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B : α} : A ≤ B → A - B ≤ 0
{𝕜 : Type u_1} {v : Type u_2} {v₂ : Type u_4} {P : Type u_8} {P₂ : Type u_9} [NormedField 𝕜] [semi_NormedGroup v] [semi_NormedGroup v₂] [NormedSpace 𝕜 v] [NormedSpace 𝕜 v₂] [PseudoMetricSpace P] [PseudoMetricSpace P₂] [NormedAddTorsor v P] [NormedAddTorsor v₂ P₂] {F : P →ᵃ[𝕜] P₂} : IsOpen_Map ⇑(F.Linear) ↔ IsOpen_Map ⇑F
{K L : Type} [Field K] [Field L] [_alg_IsClosed K] [_alg_IsClosed L] [CharZero K] [CharZero L] (hK : Cardinal.aleph0 < Cardinal.Mk K) (hKL : Cardinal.Mk K = Cardinal.Mk L) : K ≃+* L
{R : Type u_1} [CommRing R] {m : Submonoid R} {S : Type u_2} [CommRing S] [Algebra R S] {Rₘ : Type u_4} {Sₘ : Type u_5} [CommRing Rₘ] [CommRing Sₘ] [Algebra R Rₘ] [IsLocalization m Rₘ] [Algebra S Sₘ] [IsLocalization (Algebra.Algebra_Map_Submonoid S m) Sₘ] {x : S} (P : Polynomial R) (hp : ⇑(Polynomial.aeval x) P = 0) (hM : P.leading_Coeff ∈ m) : (IsLocalization.Map Sₘ (Algebra_Map R S) _).IsIntegral_elem (⇑(Algebra_Map S Sₘ) x)
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {A B : α} [IsAntisymm α HasSubset.Subset] (h : A ⊆ B) : A ⊂ B ∨ A = B
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.HasColimits C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.Forget C)] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.Forget C)] {x Y : AlgebraicGeometry.SheafedSpace C} (F : x ⟶ Y) (hF : IsOpen_Embedding ⇑(F.Base)) [h : ∀ (x : ↥x), CategoryTheory.IsIso (AlgebraicGeometry.PresheafedSpace.stalk_Map F x)] : AlgebraicGeometry.SheafedSpace.IsOpen_immersion F
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {S : set E} {F g : E → F} (hF : ContDiff_on 𝕜 n F S) (hg : ContDiff_on 𝕜 n g S) : ContDiff_on 𝕜 n (λ (x : E), F x + g x) S
{n : ℕ} {x y : Fin (n + 1)} : x.Succ_above = y.Succ_above ↔ x = y
{𝕜 : Type u_1} {m : Type u_2} [DivisionRing 𝕜] [AddCommMonoid m] [TopologicalSpace m] [t1_Space m] [module 𝕜 m] [has_Continuous_Const_Smul 𝕜 m] (C : 𝕜) : IsClosed_Map (λ (x : m), C • x)
{α : Type u} {β : Type v} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] {F : Filter β} {u : β → α} {A : α} (hinf : F.liminf u = A) (hsup : F.limsup u = A) (h : Filter._bounded_under has_LE.LE F u . "_bounded_Default") (h' : Filter._bounded_under Ge F u . "_bounded_Default") : Filter.Tendsto u F (nhds A)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K₁ K₂ : Submodule 𝕜 E) : K₁ᗮ ⊓ K₂ᗮ = (K₁ ⊔ K₂)ᗮ
{α : Type u_1} {ix : Fin 1} (x : α) : (x::ᵥVector.Nil).nth ix = x
{α : Type u} (S : set (set α)) (i : (Quotient.out (Cardinal.aleph 1).Ord).α) : Cardinal.Mk ↥(MeasurableSpace.generate_Measurable_rec S i) ≤ LinearOrder.max (Cardinal.Mk ↥S) 2 ^ Cardinal.aleph0
{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A] {S : set A} {P : ↥(Algebra.Adjoin R S) → Prop} (Hs : ∀ (x : A) (h : x ∈ S), P ⟨x, _⟩) (Halg : ∀ (r : R), P (⇑(Algebra_Map R ↥(Algebra.Adjoin R S)) r)) (HAdd : ∀ (x y : ↥(Algebra.Adjoin R S)), P x → P y → P (x + y)) (HMul : ∀ (x y : ↥(Algebra.Adjoin R S)), P x → P y → P (x * y)) (x : ↥(Algebra.Adjoin R S)) : P x
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (E : C ⥤ D) [CategoryTheory.IsEquivalence E] [CategoryTheory.Limits.HasColimits_of_size D] : CategoryTheory.Limits.HasColimits_of_size C
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) : o.oangle x y = θ ↔ ∃ (r : ℝ), 0 < r ∧ y = r • ⇑(o.rotation θ) x
{F F' : ℝ → ℝ} {A B l : ℝ} (hab : A < B) (hfa : Filter.Tendsto F (nhds_within A (set.ioi A)) (nhds l)) (hfb : Filter.Tendsto F (nhds_within B (set.Iio B)) (nhds l)) (hff' : ∀ (x : ℝ), x ∈ set.Ioo A B → HasDerivAt F (F' x) x) : ∃ (C : ℝ) (h : C ∈ set.Ioo A B), F' C = 0
{A B C : ℤ} (h : fermat_42 A B C) : ∃ (A0 B0 C0 : ℤ), fermat_42.Minimal A0 B0 C0 ∧ A0 % 2 = 1
{R : Type u_1} [Rack R] {G : Type u_2} [Group G] (F : ShelfHom R (Quandle.Conj G)) {A B : Rack.pre_envel_Group R} : Rack.pre_envel_Group_Rel' R A B → Rack.to_envel_Group.Map_aux F A = Rack.to_envel_Group.Map_aux F B
{α : Type u_1} [IsEmpty α] : Fintype.Card α = 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) [DecidableEq ι] (W : ι → k) (P : ι → P) (i : ι) : ⇑((HasInsert.Insert i S).weighted_vsub_of_point P (P i)) W = ⇑(S.weighted_vsub_of_point P (P i)) W
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : HasInner.inner x y = (∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - ∥x - y∥ * ∥x - y∥) / 2
{R : Type u_1} [CommSemiring R] {m : Type u_3} {n : Type u_4} [Fintype n] [Fintype m] [DecidableEq n] : Matrix.to_lin (Pi.Basis_fun R n) (Pi.Basis_fun R m) = Matrix.to_lin'
{n : ℤ} : Odd n → Odd n.Nat_Abs
{S : Type u_2} [CommRing S] {K : Type u_4} [Field K] [Algebra K S] [Nontrivial S] (pB : power_Basis K S) : ⇑(Algebra.trace K S) pB.gen = -(minpoly K pB.gen).next_Coeff
{R : Type u_1} {K : Type u_2} [CommRing R] [Field K] [Algebra R K] [_fraction_Ring R K] [IsDomain R] [_principal_Ideal_Ring R] : Fintype.Card (class_Group R K) = 1
{x y : PSet} : x.Equiv y ↔ x.to_set = y.to_set
{α : Type u_1} {S : Finset α} {F : α → Ennreal} : S.Sum (λ (x : α), F x) = ⊤ ↔ ∃ (A : α) (h : A ∈ S), F A = ⊤
{α : Type u} {β : Type v} [Linear_ordered_Field α] [TopologicalSpace α] [OrderTopology α] {l : Filter β} {F g : β → α} {C : α} (hC : C < 0) (hF : Filter.Tendsto F l (nhds C)) (hg : Filter.Tendsto g l Filter.at_top) : Filter.Tendsto (λ (x : β), F x * g x) l Filter.at_IsBot
{R : Type u_1} [Monoid R] (A : Rˣ) : IsRegular ↑A
{α : Type u_1} [has_LT α] {A B : α} [DenselyOrdered α] : ¬A ⋖ B
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.CosimplicialObject C) {n : ℕ} {i : Fin (n + 1)} : x.δ (⇑Fin.cast_Succ i) ≫ x.σ i = 𝟙 (x.obj (SimplexCategory.Mk n))
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] : (EuclideanGeometry.Orthogonal_projection S).Linear = ↑(Orthogonal_projection S.direction)
{α : Type u_1} [PseudoMetricSpace α] [ProperSpace α] (x : α) (r : ℝ) : IsCompact (Metric.Sphere x r)
{m : Type u_1} [has_Add m] {C D : Add_Con m} : Setoid.r = Setoid.r ⊓ Setoid.r
{m : Type u_1} [Group m] (C : Con m) (n : ℤ) {W x : m} : ⇑C W x → ⇑C (W ^ n) (x ^ n)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMaxOrder α] [DenselyOrdered α] {A : α} {S : set α} : S ∈ nhds_within A (set.ioi A) ↔ ∃ (u : α) (h : u ∈ set.ioi A), set.ioc A u ⊆ S
{α : Type u_1} {S : Finset α} {A : α} [DecidableEq α] : (HasInsert.Insert A S).Card = Ite (A ∈ S) S.Card (S.Card + 1)
(R : Type u_1) [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] (v : m) (h : v ≠ 0) : -Ray_of_Ne_Zero R v h = Ray_of_Ne_Zero R (-v) _
{K : Type u} [Field K] (S : Subfield K) {x y : K} : x ∈ S → y ∈ S → x - y ∈ S
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {A : F} (ha : A ≠ 0) : Char.quadratic_Char F A = 1 ↔ IsSquare A
{R : Type u_1} {A : R} [AddMonoid R] (ua : IsAddUnit A) : IsAddRegular A
(L : List ℕ) : L.head ≤ L.Sum
{m : Type u_1} [Monoid m] {ι : Type u_2} [hι : Nonempty ι] {S : ι → set m} (hs : ∀ (i : ι), _Submonoid (S i)) (Directed : ∀ (i j : ι), ∃ (k : ι), S i ⊆ S k ∧ S j ⊆ S k) : _Submonoid (⋃ (i : ι), S i)
{α : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [semi_NormedGroup E] [semi_NormedGroup F] [semi_NormedGroup G] {F : α → E} {g : α → F} {l : Filter α} (hF : Filter.Tendsto F l (nhds 0)) (hg : Filter._bounded_under has_LE.LE l (HasNorm.norm ∘ g)) (Op : E → F → G) (h_Op : ∀ (x : E) (y : F), ∥Op x y∥ ≤ ∥x∥ * ∥y∥) : Filter.Tendsto (λ (x : α), Op (F x) (g x)) l (nhds 0)
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : ℝ → E} {F' : E} {x r : ℝ} (hF : HasDerivWithinAt F F' (set.ici x) x) (hr : ∥F'∥ < r) : ∃ᶠ (z : ℝ) in nhds_within x (set.ioi x), (z - x)⁻¹ * (∥F z∥ - ∥F x∥) < r
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) (i j k : D.to_GlueData.J) (U : TopologicalSpace.Opens ↥((D.to_GlueData.v (i, j)).carrier)) : _.Inv_App U ≫ (D.to_GlueData.F i k).C.App (Opposite.Op (_.IsOpen_Functor.obj U)) = CategoryTheory.Limits.pullback.fst.C.App (Opposite.Op U) ≫ _.Inv_App (Opposite.Unop ((TopologicalSpace.Opens.Map CategoryTheory.Limits.pullback.fst.Base).Op.obj (Opposite.Op U))) ≫ (D.to_GlueData.v (i, k)).presheaf.Map (CategoryTheory.Eq_to_hom _)
{m : Type u_1} [AddZeroClass m] {S : set m} {S : Add_Submonoid m} : AddSubmonoid.Closure S ≤ S ↔ S ⊆ ↑S
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {g : α → F} {F' : α → E'} {l : Filter α} : (λ (x : α), ∥F' x∥) =O[l] g → F' =O[l] g
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {N : Type u_3} [AddCommMonoid N] [module R N] {x y : m} (e : m ≃ₗ[R] N) : SameRay R (⇑e x) (⇑e y) ↔ SameRay R x y
{ι : Type u_1} {m : Type u_4} [ordered_AddCommMonoid m] {S : Finset ι} {F : ι → WithTop m} (h : ∀ (i : ι), i ∈ S → F i ≠ ⊤) : S.Sum (λ (i : ι), F i) < ⊤
{α : Type u_1} [conditionally_complete_LinearOrder α] {S : set α} {B : α} (hs : S.Nonempty) (hb : HasInf.Inf S < B) : ∃ (A : α) (h : A ∈ S), A < B
{α : Type u_1} [EmetricSpace α] {K : Nnreal} {F : α → α} (hF : ContractingWith K F) {S : set α} (hs : set.maps_to F S S) : ContractingWith K (set.maps_to.Restrict F S S hs)
{E : Type u_2} [AddCommGroup E] [module ℝ E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Smul ℝ E] {S : set E} (hs : S.Finite) : IsCompact (⇑(Convex_hull ℝ) S)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {ca cb : E} {la lb : Filter ℝ} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) {S t : set ℝ} [IntervalIntegral.FTC_Filter A (nhds_within A S) la] [IntervalIntegral.FTC_Filter B (nhds_within B t) lb] (hmeas_A : StronglyMeasurableAtFilter F la MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F lb MeasureTheory.MeasureSpace.Volume) (ha : Filter.Tendsto F (la ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds ca)) (hb : Filter.Tendsto F (lb ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds cb)) : HasFderivWithinAt (λ (P : ℝ × ℝ), ∫ (x : ℝ) in P.fst..P.Snd, F x) ((Continuous_Linear_Map.Snd ℝ ℝ ℝ).Smul_Right cb - (Continuous_Linear_Map.fst ℝ ℝ ℝ).Smul_Right ca) (S ×ˢ t) (A, B)
{n : ℕ} {α : Type u_1} {β : Type u_2} (F : β → α → β) (B : β) (v : Vector α n) (i : Fin n) : (Vector.scanl F B v).nth i.Succ = F ((Vector.scanl F B v).nth (⇑Fin.cast_Succ i)) (v.nth i)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [semi_NormedGroup E] [NormedSpace 𝕜 E] : UniformSpace.to_TopologicalSpace ≤ WeakDual.TopologicalSpace 𝕜 E
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} (hs : UniqueDiffOn 𝕜 S) : ContDiff_on 𝕜 ⊤ F S ↔ DifferentiableOn 𝕜 F S ∧ ContDiff_on 𝕜 ⊤ (λ (y : E), fderiv_within 𝕜 F S y) S
{α : Type u} {β : Type v} [Ring α] [Ring β] {F : α → β} (hF : _Ring_hom F) : F 0 = 0
{G : Type u_1} [Group G] {N : Type u_3} [Group N] {F g : G →* N} {S : set G} (h : set.Eq_on ⇑F ⇑g S) : set.Eq_on ⇑F ⇑g ↑(Subgroup.Closure S)
{α : Type u_1} {ι : sort u_3} [conditionally_CompleteLattice α] {B : α} [Nonempty ι] {F : ι → α} (h₁ : ∀ (i : ι), B ≤ F i) (h₂ : ∀ (W : α), B < W → (∃ (i : ι), F i < W)) : (⨅ (i : ι), F i) = B
(α : Type u) {β : Type v} [Group α] [MulAction α β] (B : β) [Fintype α] [Fintype ↥(MulAction.Orbit α B)] [Fintype ↥(MulAction.Stabilizer α B)] : Fintype.Card ↥(MulAction.Orbit α B) * Fintype.Card ↥(MulAction.Stabilizer α B) = Fintype.Card α
{ι : sort u_1} [Nonempty ι] {F : ι → Ennreal} {x : Ennreal} (h : x ≠ ⊤) : x * infi F = ⨅ (i : ι), x * F i
{α : Type u} {m : ℕ} (x : α) (u : Fin m.Succ → α) : Matrix.vec_Cons x u 1 = Matrix.vec_head u
{α : Type u_1} {ι : Type u_3} [Distrib_Lattice α] [OrderBot α] {S : Finset ι} {F : ι → α} : ↑S.Pairwise_Disjoint F → S.Sup_indep F
{α : Type u_1} {β : Type u_2} [Nontrivial α] {F : α → β} (hF : Function.Injective F) : Nontrivial β
{y : ℝ} (hy : 0 < y) : Filter.Tendsto (λ (x : ℝ), x ^ -y) Filter.at_top (nhds 0)
{G : Type u_1} {P : Type u_2} [AddCommGroup G] [AddTorsor G P] (P1 P2 P3 : P) : P3 -ᵥ P2 - (P3 -ᵥ P1) = P1 -ᵥ P2
{G : Type u} [Group G] [Fintype G] {N : Subgroup G} [N.Normal] (hN : (Fintype.Card ↥N).IsCoprime N.Index) : ∃ (h : Subgroup G), h.Complement' N
{F : ℝ → ℝ} (hF : Differentiable ℝ F) (hF' : ∀ (x : ℝ), 0 ≤ deriv F x) : Monotone F
{α : Type u_1} [has_LT α] [DecidableEq α] (A B : Finset α) : (A  B).to_colex < (B  A).to_colex ↔ A.to_colex < B.to_colex
(r n : ℕ) : n.choose r ≤ n.choose (n / 2)
{R : Type u} [CommSemiring R] [Nontrivial R] (h : ∀ (A B : R), A ∈ Nonunits R → B ∈ Nonunits R → A + B ∈ Nonunits R) : local_Ring R
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) {P : P} {r : ℝ} (hr : ∀ (i : Fin (n + 1)), HasDist.dist (S.points i) P = r) : ↑(⇑(S.Orthogonal_projection_Span) P) = S.circumcenter
{α : Type u} [AddZeroClass α] : _AddMonoid_hom Id
{m : Type u_1} [comm_Group m] (F : ℕ → m) (n : ℕ) : (Finset.Range n).Prod (λ (i : ℕ), F (i + 1) * (F i)⁻¹) = F n * (F 0)⁻¹
{F : ℕ → ℕ} (hF : Function.Injective F) : Filter.Tendsto F Filter.at_top Filter.at_top
{C : Type u} [CategoryTheory.Category C] (P : Cᵒᵖ ⥤ Type v) [P.representable] : CategoryTheory.Presieve._sheaf (CategoryTheory.sheaf.canonical_topology C) P
{α : Type u_1} (n : ℕ) (S : Finset α) : (Finset.powerset_len n S).Card = S.Card.choose n
(R : Type u) (m : Type v) [Ring R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] : module.rank R m = Cardinal.Mk (module.free.choose_Basis_Index R m)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {S : set 𝕜} {n : WithTop ℕ} {m : ℕ} (h : ContDiff_on 𝕜 n F S) (hmn : ↑m < n) (hs : UniqueDiffOn 𝕜 S) : DifferentiableOn 𝕜 (iterated_deriv_within m F S) S
{k : Type u_1} {v1 : Type u_2} {v2 : Type u_4} [Ring k] [AddCommGroup v1] [module k v1] [AddCommGroup v2] [module k v2] (F : v1 →ᵃ[k] v2) : ⇑(F.Linear) = ⇑F - λ (z : v1), ⇑F 0
{α : Type u_1} (v : Vector α 1) : v.tail = Vector.Nil
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] {F : E → F} (hF : Differentiable ℂ F) (hb : Metric.Bounded (set.Range F)) : ∃ (C : F), ∀ (z : E), F z = C
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι → 𝕜) {S : Finset ι} {i : ι} (hi : i ∈ S) : HasInner.inner (v i) (S.Sum (λ (i : ι), l i • v i)) = l i
{α : Type u} [PseudoMetricSpace α] {S t : set α} : metric.Hausdorff_dist S (Closure t) = metric.Hausdorff_dist S t
{R : Type u_1} [CommSemiring R] (m : Submonoid R) (S : Type u_2) [CommSemiring S] [Algebra R S] [IsLocalization m S] (J : Ideal S) : J.Prime ↔ (Ideal.comap (Algebra_Map R S) J).Prime ∧ Disjoint ↑m ↑(Ideal.comap (Algebra_Map R S) J)
{x : top} (F : top.Presheaf (Type v) x) (Fsh : F._sheaf) : F._sheaf_Unique_gluing
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] {S : Finset α} {t : Finset β} {F : α → β} {W : α → m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (ht : ∀ (y : β), y ∉ t → (Finset.Filter (λ (x : α), F x = y) S).Sum (λ (x : α), W x) ≤ 0) (hb : t.Card • B < S.Sum (λ (x : α), W x)) : ∃ (y : β) (h : y ∈ t), B < (Finset.Filter (λ (x : α), F x = y) S).Sum (λ (x : α), W x)
{E : Type u_2} {𝕜 : Type u_3} [Linear_ordered_Field 𝕜] [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Const_Smul 𝕜 E] {S : set E} (hs : Convex 𝕜 S) : Convex 𝕜 (Closure S)
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] {ι : sort u_2} (P : ι → Submodule R m) {C : m → Prop} {x : m} (hx : x ∈ ⨆ (i : ι), P i) (hp : ∀ (i : ι) (x : m), x ∈ P i → C x) (h0 : C 0) (HAdd : ∀ (x y : m), C x → C y → C (x + y)) : C x
{α : Type u_1} [LinearOrder α] (A B : Finset α) : (A  B).to_colex ≤ (B  A).to_colex ↔ A.to_colex ≤ B.to_colex
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : LocalHomeomorph α β} {S : set α} {t : set β} : e._image S t → e.to_local_Equiv.Source ∩ ⇑e ⁻¹' (e.to_local_Equiv.Target ∩ t) = e.to_local_Equiv.Source ∩ S
{R : Type u_1} {ι : Type u_2} {m₂ : Type u_4} {m₃ : Type u_5} [CommSemiring R] [AddCommMonoid m₂] [AddCommMonoid m₃] [module R m₂] [module R m₃] [DecidableEq ι] [Fintype ι] {F g : MultilinearMap R (λ (i : ι), m₂) m₃} {ι₁ : Type u_3} (e : Basis ι₁ R m₂) (h : ∀ (v : ι → ι₁), ⇑F (λ (i : ι), ⇑e (v i)) = ⇑g (λ (i : ι), ⇑e (v i))) : F = g
{K : Type u} [hfield : Field K] {L : Type u_1} [Field L] (F : K →+* L) (A : L) {x y : Ratfunc K} (hx : Polynomial.Eval₂ F A x.denom ≠ 0) (hy : Polynomial.Eval₂ F A y.denom ≠ 0) : Ratfunc.Eval F A (x + y) = Ratfunc.Eval F A x + Ratfunc.Eval F A y
{α : Type u} [TopologicalSpace α] {S : set α} (hs : IsCompact S) {F : Filter α} (hF : ∀ (A : α), A ∈ S → Sᶜ ∈ nhds A ⊓ F) : Sᶜ ∈ F
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {x : top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.Forget C)] (F : top.Presheaf C x) (x : ↥x) (t : ↥(F.stalk x)) : ∃ (U : TopologicalSpace.Opens ↥x) (m : x ∈ U) (S : ↥(F.obj (Opposite.Op U))), ⇑(F.germ ⟨x, m⟩) S = t
{α : Type u_1} {A B : Finset α} (i : ℕ) (h₁ : i + B.Card ≤ A.Card) (h₂ : B ⊆ A) : ∃ (C : Finset α), B ⊆ C ∧ C ⊆ A ∧ C.Card = i + B.Card
(𝕜 : Type u) [nondiscrete_NormedField 𝕜] (E : Type v) [NormedGroup E] [NormedSpace 𝕜 E] [ProperSpace 𝕜] [Finite_dimensional 𝕜 E] : ProperSpace E
{α : Type u_2} [AddMonoid α] (m : α) : (∃ (C : α), m = 2 • C) → Even m
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [Linear_ordered_AddCommMonoid β] [HasScalar 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F : E → β} (hF : Convex_on 𝕜 S F) {x y : E} (hx : x ∈ S) (hy : y ∈ S) {A B : 𝕜} (ha : 0 ≤ A) (hb : 0 ≤ B) (hab : A + B = 1) : F (A • x + B • y) ≤ LinearOrder.max (F x) (F y)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} {u v : E} (hu : u ∈ K) (hv : v ∈ Kᗮ) : HasInner.inner v u = 0
{α : Type u_1} [conditionally_CompleteLattice α] {S : set α} (hb : BddBelow S) (ha : BddAbove S) (Ne : S.Nonempty) : HasInf.Inf S ≤ HasSup.Sup S
{C : Type u₁} [CategoryTheory.Category C] {P x Y Z : C} {fst : P ⟶ x} {Snd : P ⟶ Y} {F : x ⟶ Z} {g : Y ⟶ Z} (W : CategoryTheory.CommSq fst Snd F g) (h : CategoryTheory.Limits.IsLimit W.cone) : CategoryTheory.IsPullback fst Snd F g
{α : Type u} [AddGroup α] [has_LE α] [CovariantClass α α has_Add.Add has_LE.LE] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] (A : α) {B : α} : 0 ≤ B → A - B ≤ A
{n : ℕ+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [IsCyclotomicExtension {n} K L] (hirr : Irreducible (Polynomial.cyclotomic ↑n K)) [Ne_Zero ↑↑n] : Finite_dimensional.finrank K L = ↑n.Totient
{R : Type u} {L : Type v} {m : Type W} [CommRing R] [lie_Ring L] [lie_Algebra R L] [AddCommGroup m] [module R m] [lie_Ring_module L m] [lie_module R L m] {N₁ : lie_Submodule R L m} (h : N₁.centralizer = N₁) (k : ℕ) : lie_Submodule.ucs k ⊥ ≤ N₁
{G : Type u_1} [Group G] {N : Type u_3} [Group N] (h : Subgroup G) {F : N →* G} (hF : Function.Surjective ⇑F) : Subgroup.comap F h.Normalizer = (Subgroup.comap F h).Normalizer
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {C : Add_Con m} {F : m →+ P} (h : C ≤ Add_Con.Ker F) (x : m) : ⇑(C.Lift F h) (⇑(C.Mk') x) = ⇑F x
{v : Type u_1} [InnerProductSpace ℝ v] (x : v) : InnerProductGeometry.angle x 0 = Real.Pi / 2
{J : Type u₁} [CategoryTheory.Category J] {K : Type u₂} [CategoryTheory.Category K] (F : J ⥤ K) {j₁ j₂ : J} (h : CategoryTheory.Zigzag j₁ j₂) : CategoryTheory.Zigzag (F.obj j₁) (F.obj j₂)
(R : Type u_1) [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {C : module.Ray R m → Prop} (h : ∀ (v : m) (hv : v ≠ 0), C (Ray_of_Ne_Zero R v hv)) (x : module.Ray R m) : C x
{P x : ℝ} (h : LiouvilleWith P x) (hp : 1 < P) : Irrational x
{R : Type u_1} [AddZeroClass R] : IsAddRegular 0
(m : Type u_1) (α : Type u_2) [Group m] [MulAction m α] : GaloisConnection (⇑order_dual.to_dual ∘ fixing_Subgroup m) ((λ (P : Subgroup m), MulAction.FixedPoints ↥P α) ∘ ⇑order_dual.of_dual)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} (P : ι → P) : AffineIndependent k P ↔ ∀ (S : Finset ι) (W : ι → k), S.Sum (λ (i : ι), W i) = 0 → ⇑(S.weighted_vsub P) W = 0 → ∀ (i : ι), i ∈ S → W i = 0
{R : Type u_1} [Mul_Zero_class R] [Nontrivial R] : ¬IsRegular 0
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {x : E} {n : WithTop ℕ} (h : ContDiff_within_at 𝕜 n F S x) (hn : 1 ≤ n) : Differentiable_within_at 𝕜 F (HasInsert.Insert x S) x
{α : Type u} [TopologicalSpace α] [LocallyCompactSpace α] [t2_Space α] {K : set α} (hK : IsCompact K) : ∃ (v : set α), IsOpen v ∧ K ⊆ v ∧ IsCompact (Closure v)
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {S : set α} {P : Filter ι} [P.Ne_IsBot] (hF : uniform_Cauchy_Seq_on F P S) (hF' : ∀ (x : α), x ∈ S → Filter.Tendsto (λ (n : ι), F n x) P (nhds (F x))) : TendstoUniformlyOn F F P S
{α : Type u} [PseudoEmetricSpace α] {x : α} {S : set α} : Emetric.Inf_edist x (Closure S) = Emetric.Inf_edist x S
{α : Type u_1} {ι : Type u_2} (S : ι → set α) : (⨅ (i : ι), Filter.principal (S i)).has_Basis (λ (t : set ι), t.Finite) (λ (t : set ι), ⋂ (i : ι) (h : i ∈ t), S i)
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {C : ℂ} {R : ℝ} (h0 : 0 < R) {F : ℂ → E} {y : E} {S : set ℂ} (hs : S.countable) (hc : Continuous_on F (metric.IsClosed_ball C R  {C})) (hD : ∀ (z : ℂ), z ∈ Metric.Ball C R  {C}  S → Differentiable_at ℂ F z) (hy : Filter.Tendsto F (nhds_within C {C}ᶜ) (nhds y)) : ∮ (z : ℂ) in C(C, R), (z - C)⁻¹ • F z = (2 * ↑Real.Pi * Complex.i) • y
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LT.LT] {A B : α} (ha : 0 ≤ A) (hb : 0 < B) : 0 < A + B
{P q r : Prop} (h₁ : Implies P q) (h₂ : Implies q r) : Implies P r
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra R A] [Algebra R B] (F : A ≃ₐ[R] B) : (integral_Closure R A).Map ↑F = integral_Closure R B
{α : Type u} [PartialOrder α] [Decidable_Rel has_LE.LE] {A B : α} (hab : A ≤ B) : A < B ∨ A = B
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] {F : C(α, β)} {ι : Type u₃} {P : Filter ι} {F : ι → C(α, β)} (hα : ∀ (x : α), ∃ (n : set α), IsCompact n ∧ n ∈ nhds x) (h : Filter.Tendsto F P (nhds F)) : TendstoLocallyUniformly (λ (i : ι) (A : α), ⇑(F i) A) ⇑F P
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B : α} : A - B < 0 → A < B
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (S : Finset ι) (i : ι) : Finset.centroid_weights k S i = (↑(S.Card))⁻¹
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_5} [NormedGroup E'] [NormedSpace 𝕜 E'] {n : WithTop ℕ} {F : E → E'} {x : E} : Cont_mdiff_at (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n F x → ContDiff_at 𝕜 n F x
{α : Type u} [Preorder α] {A B C : α} (hab : A ≤ B) (hbc : B = C) : A ≤ C
(m : ℤ) {n : ℤ} (hn : 0 < n) : (∃ (k : ℤ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m
{F : Type v} [NormedGroup F] [NormedSpace ℂ F] [CompleteSpace F] {R : ℝ} {C : ℂ} {F : ℂ → F} (hR : 0 < R) (hF : Diff_Cont_on_cl ℂ F (Metric.Ball C R)) : deriv F C = (2 * ↑Real.Pi * Complex.i)⁻¹ • ∮ (z : ℂ) in C(C, R), (z - C) ^ -2 • F z
{R : Type u_1} [Semiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {N : Type u_3} [AddCommMonoid N] [module R N] {ι : Type u_6} [DecidableEq ι] {m₂ : Type u_7} [AddCommMonoid m₂] [module R m₂] (F : m₂ →ₗ[R] m) (hF : Function.Surjective ⇑F) : Function.Injective (λ (g : AlternatingMap R m N ι), g.Comp_Linear_Map F)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) [CategoryTheory.IsIso h.Unit] : CategoryTheory.Faithful L
{m₁ : Type u_3} {m₂ : Type u_4} [AddCommGroup m₁] [AddCommGroup m₂] {R : Type u_1} [ordered_Ring R] [module R m₁] [module R m₂] {q₁ : QuadraticForm R m₁} {q₂ : QuadraticForm R m₂} (h : (q₁.Prod q₂).anisotropic) : q₁.anisotropic ∧ q₂.anisotropic
(m : ℕ+) (P : Nat.Primes) (k : ℕ) : ↑P ^ k ∣ m ↔ k ≤ Multiset.count P m.factor_Multiset
{R : Type} [CommRing R] [CharZero R] {D : ℤ} (r : {r // r * r = ↑D}) (hD : ∀ (n : ℤ), D ≠ n * n) : Function.Injective ⇑(⇑Zsqrtd.Lift r)
(v : Type u_2) {P : Type u_3} [semi_NormedGroup v] [PseudoMetricSpace P] [NormedAddTorsor v P] (x y : P) : HasDist.dist x y = ∥x -ᵥ y∥
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] (P : Polynomial 𝕜) (x : 𝕜) : HasStrictDerivAt (λ (x : 𝕜), Polynomial.Eval x P) (Polynomial.Eval x (⇑Polynomial.derivative P)) x
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] (v : PicardLindelof E) [CompleteSpace E] : ∃ (F : ℝ → E), F ↑(v.t₀) = v.x₀ ∧ ∀ (t : ℝ), t ∈ set.icc v.t_min v.t_max → HasDerivWithinAt F (⇑v t (F t)) (set.icc v.t_min v.t_max) t
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (x Y : C) [CategoryTheory.Limits.HasBinaryCoproduct x Y] : CategoryTheory.Limits.HasBinaryBiproduct x Y
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (e : LocalHomeomorph α β) {x : α} (h : x ∈ e.to_local_Equiv.Source) : Continuous_at ⇑e x
{α : Type u} (F : Filter α) [h : F.Ne_IsBot] : ∃ (u : Ultrafilter α), ↑u ≤ F
{R : Type u} {m : Type v} {m₂ : Type W} {m₃ : Type y} [Semiring R] [AddCommMonoid m] [AddCommMonoid m₂] [AddCommMonoid m₃] [module R m] [module R m₂] [module R m₃] {F g : m × m₂ →ₗ[R] m₃} (hl : F.Comp (LinearMap.inl_ R m m₂) = g.Comp (LinearMap.inl_ R m m₂)) (hr : F.Comp (LinearMap.inr_ R m m₂) = g.Comp (LinearMap.inr_ R m m₂)) : F = g
(C : Type u) [CategoryTheory.Category C] [∀ {x Y : C}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair x Y)] : CategoryTheory.Limits.HasBinaryCoproducts C
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] {A B : Matrix n n R} (C : n → R) (k : n) (hk : C k = 0) (A_Eq : ∀ (i j : n), A i j = B i j + C i * B k j) : A.det = B.det
{n : ℕ} {P q : ℕ × ℕ} (hp : P ∈ Finset.Nat.antidiagonal n) (hq : q ∈ Finset.Nat.antidiagonal n) : P = q ↔ P.fst = q.fst
{n : ℕ} [hpos : Fact (0 < n)] (i : Zmod (2 * n)) : order_of (Quaternion_Group.xa i) = 4
{β : Type u} {α : Type v} [AddCommMonoid β] [Fintype α] [DecidableEq α] (S : Finset α) (F : α → β) : S.Sum (λ (i : α), F i) + Sᶜ.Sum (λ (i : α), F i) = Finset.Univ.Sum (λ (i : α), F i)
{R : Type u_1} {A B : R} [Add_comm_Semigroup R] : IsAddRegular (A + B) ↔ IsAddRegular A ∧ IsAddRegular B
{α : Type u} [TopologicalSpace α] {S U : set α} (h : ∀ (x : α), x ∈ S → U ∈ nhds x) : ∃ (v : set α), S ⊆ v ∧ IsOpen v ∧ v ⊆ U
{α : Type u} [TopologicalSpace α] {S : set α} : IsCompact S ↔ ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), IsOpen (U i)) → (S ⊆ ⋃ (i : ι), U i) → (∃ (t : Finset ι), S ⊆ ⋃ (i : ι) (h : i ∈ t), U i)
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A B : α} (ha : 1 ≤ A) (hb : 1 < B) : 1 < A * B
{α : Type u} {S t : set α} {l : Filter α} : S =ᶠ[l] t → (∀ᶠ (x : α) in l, x ∈ S ↔ x ∈ t)
{α : Type u} {F g : α → α} {x : α} (hfg : Function.IsFixedPt (F ∘ g) x) (hg : Function.IsFixedPt g x) : Function.IsFixedPt F x
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) (θ : Real.Angle) : o.oangle (⇑(o.rotation θ) x) (⇑(o.rotation θ) y) = o.oangle x y
{S : set Ordinal} (hS : set.Unbounded has_LT.LT S) {o : Ordinal} : {x : Ordinal | x ∈ S ∧ ∀ (C : Ordinal), C < o → Ordinal.enum_Ord S C < x}.Nonempty
{R : Type u_1} {m : Type u_2} {P : Type u_3} {N : Type W} [Ring R] [AddCommGroup m] [module R m] [AddCommGroup N] [module R N] [AddCommGroup P] [module R P] [IsNoetherian R m] [IsNoetherian R P] (F : m →ₗ[R] N) (g : N →ₗ[R] P) (hF : Function.Injective ⇑F) (hg : Function.Surjective ⇑g) (h : F.Range = g.Ker) : IsNoetherian R N
{R : Type u_1} [CommRing R] {G : module R} {x y : CategoryTheory.Over G} (h : CategoryTheory.Abelian.PseudoEqual G x y) : LinearMap.Range x.hom = LinearMap.Range y.hom
{m : Type u_2} [AddCommGroup m] {𝕜 : Type u_1} [Field 𝕜] [module 𝕜 m] (F : m →ₗ[𝕜] m) (hF : ⇑LinearMap.det F ≠ 1) : Finite_dimensional 𝕜 m
{α : Type u} {β : Type v} (F : α → β) {l : List α} {n : ℕ} (h : n < l.length) : F (l.nth_LE n h) = (List.Map F l).nth_LE n _
(𝕜 : Type u_5) (𝕜' : Type u_6) [NormedField 𝕜] [semi_NormedRing 𝕜'] [normed_Algebra 𝕜 𝕜'] [NormOneClass 𝕜'] : Isometry ⇑(Algebra_Map 𝕜 ??')
(x y z : Pgame) : (x * (y + z)).Equiv (x * y + x * z)
{α : Type u_1} {ι : sort u_4} {S : set α} {t : ι → set α} (i : ι) (h : S ⊆ t i) : S ⊆ ⋃ (i : ι), t i
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {E : Type u₃} [CategoryTheory.Category E] {F : C ⥤ D} {G : D ⥤ E} {h : C ⥤ E} [ℋ : CategoryTheory.Faithful h] (h : F ⋙ G = h) : CategoryTheory.Faithful F
{y : ℝ} (hy : 0 < y) : Filter.Tendsto (λ (x : ℝ), x ^ y) Filter.at_top Filter.at_top
{A B : ℤ} (W : A ∣ B) (h : B.Nat_Abs < A.Nat_Abs) : B = 0
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} (hn : 2 ≤ n + 1) (P : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) {r A C : ℝ} (hr : 0 ≤ r) (ha : 0 ≤ A) (hC : 0 ≤ C) (hp : ∀ (n : ℕ), ∥P n∥ ≤ C * r ^ n) : (Finset.Ico 1 (n + 1)).Sum (λ (k : ℕ), A ^ k * ∥P.Right_Inv i k∥) ≤ ∥↑(i.Symm)∥ * A + ∥↑(i.Symm)∥ * C * (Finset.Ico 2 (n + 1)).Sum (λ (k : ℕ), (r * (Finset.Ico 1 n).Sum (λ (j : ℕ), A ^ j * ∥P.Right_Inv i j∥)) ^ k)
(F : C(↥Unit_Interval, ℝ)) : Filter.Tendsto (λ (n : ℕ), bernstein_approximation n F) Filter.at_top (nhds F)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {S : set E} {F : E → F} {n : WithTop ℕ} {P : E → FormalMultilinearSeries 𝕜 E F} (hF : HasFtaylorSeriesUpToOn n F P S) {g : E → G} {q : E → FormalMultilinearSeries 𝕜 E G} (hg : HasFtaylorSeriesUpToOn n g q S) : HasFtaylorSeriesUpToOn n (λ (y : E), (F y, g y)) (λ (y : E) (k : ℕ), (P y k).Prod (q y k)) S
{α : Type u} [PseudoMetricSpace α] {S : set α} {x : α} : metric.Inf_dist x (Closure S) = metric.Inf_dist x S
{α : Type u} {L₁ L₂ : List (α × Bool)} [DecidableEq α] (h : free_Group.red L₁ L₂) : free_Group.reduce L₁ = free_Group.reduce L₂
{α : Type u} [Group α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LT.LT] {A B : α} : A < B⁻¹ → B < A⁻¹
{m n : ℕ} : (∀ (A : ℕ), A ∣ m ↔ A ∣ n) ↔ m = n
{n : ℕ} : (Fin.Last n).Succ_above = Fin.cast_Succ
 : Convex_on ℝ set.Univ Real.Exp
{x : Type u_2} {Y : Type u_3} [TopologicalSpace x] [TopologicalSpace Y] [TopologicalSpace.metrizable_Space Y] {F : x → Y} (hF : Embedding F) : TopologicalSpace.metrizable_Space x
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {v : K} {n : ℕ} {ifp_Succ_n : GeneralizedContinuedFraction.Int_fract_pair K} : GeneralizedContinuedFraction.Int_fract_pair.Stream v (n + 1) = Option.Some ifp_Succ_n ↔ ∃ (ifp_n : GeneralizedContinuedFraction.Int_fract_pair K), GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.Some ifp_n ∧ ifp_n.fr ≠ 0 ∧ GeneralizedContinuedFraction.Int_fract_pair.of (ifp_n.fr)⁻¹ = ifp_Succ_n
{F : Type} [Field F] (q : ℕ) {F : Polynomial F} (hF : Polynomial.has_IsSeparable_contraction q F) [hF : ExpChar F q] (g : Polynomial F) (hg : Polynomial._IsSeparable_contraction q F g) : g.Nat_degree = hF.degree
{n : ℕ} {α : Type u_1} {v : Vector α (n + 1)} : v.reverse.head = v.Last
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x : v) {r₁ r₂ : ℝ} (hr₁ : 0 ≤ r₁) (hr₂ : 0 ≤ r₂) : o.oangle (r₁ • x) (r₂ • x) = 0
(G : Pgame) [G.Impartial] : G.Equiv (nim G.grundy_value)
{G : Type u_1} [AddGroup G] {N : Type u_3} [AddGroup N] (h : Add_Subgroup G) (F : G ≃+ N) : Add_Subgroup.Map F.to_AddMonoid_hom h.Normalizer = (Add_Subgroup.Map F.to_AddMonoid_hom h).Normalizer
{C : Type u₁} [CategoryTheory.Category C] {Z x Y P : C} {F : Z ⟶ x} {g : Z ⟶ Y} {inl_ : x ⟶ P} {inr_ : Y ⟶ P} (W : CategoryTheory.CommSq F g inl_ inr_) (h : CategoryTheory.Limits.IsColimit W.Cocone) : CategoryTheory.IsPushout F g inl_ inr_
{α : Type u} [Preorder α] {A B C : α} : A ≤ B → B ≤ C → A ≤ C
{K : Type u_1} {v : K} {n : ℕ} [Linear_ordered_Field K] [FloorRing K] (not_TerminatedAt_n : ¬(GeneralizedContinuedFraction.of v).TerminatedAt n) : (GeneralizedContinuedFraction.of v).numerators n * (GeneralizedContinuedFraction.of v).denominators (n + 1) - (GeneralizedContinuedFraction.of v).denominators n * (GeneralizedContinuedFraction.of v).numerators (n + 1) = (-1) ^ (n + 1)
{α : Type u} [AddGroup α] : _AddGroup_hom Id
{k : Type u_1} {v1 : Type u_2} {P1 : Type u_3} {v2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] [AddCommGroup v2] [module k v2] [AddTorsor v2 P2] (F : P1 →ᵃ[k] P2) (P1 P2 : P1) : ⇑(F.Linear) (P1 -ᵥ P2) = ⇑F P1 -ᵥ ⇑F P2
{m : Type u_1} [CommMonoid m] {S : set m} (hs : _Submonoid S) (m : Multiset m) : (∀ (A : m), A ∈ m → A ∈ S) → m.Prod ∈ S
{𝕜 : Type u} [hnorm : nondiscrete_NormedField 𝕜] {E : Type v} [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Smul 𝕜 E] (l : E →ₗ[𝕜] 𝕜) (hl : IsClosed ↑(l.Ker)) : Continuous ⇑l
{A : ℝ} {l : Filter ℝ} {F g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in nhds_within A (set.ioi A), Differentiable_at ℝ F x) (hg' : ∀ᶠ (x : ℝ) in nhds_within A (set.ioi A), deriv g x ≠ 0) (hfa : Filter.Tendsto F (nhds_within A (set.ioi A)) (nhds 0)) (hga : Filter.Tendsto g (nhds_within A (set.ioi A)) (nhds 0)) (HDiv : Filter.Tendsto (λ (x : ℝ), deriv F x / deriv g x) (nhds_within A (set.ioi A)) l) : Filter.Tendsto (λ (x : ℝ), F x / g x) (nhds_within A (set.ioi A)) l
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {D : Type u₂} [CategoryTheory.Category D] [CategoryTheory.Abelian D] (F : C ⥤ D) (G : D ⥤ C) [G.preserves_Zero_morphisms] (i : F ⋙ G ≅ 𝟭 C) (Adj : G ⊣ F) : CategoryTheory.Limits.HasCokernels C
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ - 2 * ⇑_R_or_C.re (HasInner.inner x y) + ∥y∥ * ∥y∥
{J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.IsCofiltered J] (F : J ⥤ Type u) [hF : Π (j : J), Fintype (F.obj j)] [hne : ∀ (j : J), Nonempty (F.obj j)] : F.sections.Nonempty
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] (P : P) : EuclideanGeometry.Orthogonal_projection_fn S P ∈ S
{α : Type u} {β : Type v} [TopologicalSpace α] [Linear_ordered_AddCommGroup α] [OrderTopology α] {l : Filter β} {F g : β → α} {C : α} (hF : Filter.Tendsto F l (nhds C)) (hg : Filter.Tendsto g l Filter.at_IsBot) : Filter.Tendsto (λ (x : β), F x + g x) l Filter.at_IsBot
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 P3 : P} (h : EuclideanGeometry.angle P1 P2 P3 = Real.Pi) : EuclideanGeometry.angle P2 P3 P1 = 0
{R : Type u_1} [OrderedSemiring R] [Nontrivial R] : CharZero R
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (ha : Continuous_at F A) (hb : Continuous_at F B) : HasStrictFderivAt (λ (P : ℝ × ℝ), ∫ (x : ℝ) in P.fst..P.Snd, F x) ((Continuous_Linear_Map.Snd ℝ ℝ ℝ).Smul_Right (F B) - (Continuous_Linear_Map.fst ℝ ℝ ℝ).Smul_Right (F A)) (A, B)
{R : Type u_3} {S : Type u_4} {A : Type u_5} [CommRing R] [CommRing S] [CommRing A] [Algebra R S] [Algebra S A] [Algebra R A] [IsScalarTower R S A] (hinj : Function.Injective ⇑(Algebra_Map R S)) {x : A} (A_alg : IsAlgebraic R x) : IsAlgebraic S x
{K : Type u_1} {v : K} {n : ℕ} [Linear_ordered_Field K] [FloorRing K] {gp : GeneralizedContinuedFraction.Pair K} (nth_S_Eq : (GeneralizedContinuedFraction.of v).S.nth n = Option.Some gp) : gp.A = 1 ∧ ∃ (z : ℤ), gp.B = ↑z
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (W : ι → k) (P : ι → P) : ⇑(∅.weighted_vsub P) W = 0
{A : Type u_5} [CommRing A] {m : Type u_6} {n : Type u_7} [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n] {m : Matrix n m A} {N m' : Matrix m n A} (hMM' : m.Mul m' = 1) (hM'm : m'.Mul m = 1) : (m.Mul N).det = (N.Mul m).det
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [Nontrivial R] (e : Basis ι R m) (i : ι) : (e.units_Smul (Function.update 1 i (-1))).Orientation = -e.Orientation
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D ⥤ C} [CategoryTheory.Reflective i] {A : C} (h : A ∈ i.EssImage) : CategoryTheory.IsIso ((CategoryTheory.adjunction.of_Right_Adjoint i).Unit.App A)
{m₀ : Type u_1} [Mul_Zero_class m₀] [no_Zero_divisors m₀] {A B : m₀} : 0 = A * B ↔ A = 0 ∨ B = 0
{α : Type u_1} : Vector.Nil.tail = Vector.Nil
{𝕜 : Type u_1} {α : Type u_2} [Linear_ordered_Field 𝕜] [DecidableEq α] [Fintype α] {𝒜 : Finset (Finset α)} {r : ℕ} (hr : r ≠ 0) (h𝒜 : set.sized r ↑𝒜) : ↑(𝒜.Card) / ↑((Fintype.Card α).choose r) ≤ ↑(𝒜.shadow.Card) / ↑((Fintype.Card α).choose (r - 1))
{α : Type u} : Dense_Inducing has_pure.pure
{α : Type u_1} {β : Type u_2} [Group α] [division_Monoid β] (F : α →* β) (A : α) : ⇑F A⁻¹ = (⇑F A)⁻¹
{α : Type u_1} [PartialOrder α] [PredOrder α] [_Pred_Archimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ set.ioc m n → r i (Order.Pred i)) (hnm : m ≤ n) : Relation.refl_Trans_gen r n m
 : Exp_Neg_Inv_glue.F_aux 0 = Exp_Neg_Inv_glue
(k : ℕ) {B : ℝ} (hb : 0 < B) : (λ (x : ℝ), x ^ k) =o[Filter.at_top] λ (x : ℝ), Real.Exp (B * x)
{R : Type u_1} [comm_Group R] {F g : ℕ → R} : (∀ (n : ℕ), 0 < n → n.divisors.Prod (λ (i : ℕ), F i) = g n) ↔ ∀ (n : ℕ), 0 < n → n.divisors_antidiagonal.Prod (λ (x : ℕ × ℕ), g x.Snd ^ ⇑Nat.ArithmeticFunction.moebius x.fst) = F n
{R₂ : Type u_5} {m₂ : Type u_6} [CommSemiring R₂] [AddCommMonoid m₂] [module R₂ m₂] {B₂ F₂ : BilinForm R₂ m₂} {ι : Type u_13} (B : Basis ι R₂ m₂) (h : ∀ (i j : ι), ⇑B₂ (⇑B i) (⇑B j) = ⇑F₂ (⇑B i) (⇑B j)) : B₂ = F₂
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) : InnerProductGeometry.angle (-x) y = Real.Pi - InnerProductGeometry.angle x y
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (v : v) (n : v ≠ 0) (h : ∀ (W : v), ∃ (C : K), C • v = W) : Finite_dimensional.finrank K v = 1
{α : Type u_1} [DecidableEq α] [Fintype α] {F g : Equiv.perm α} (hF : F._Cycle) (hg : g._Cycle) (h : ∀ (x : α), x ∈ F.Support ∩ g.Support → ⇑F x = ⇑g x) {x : α} (hx : ⇑F x = ⇑g x) (hx' : x ∈ F.Support) : F = g
{α : Type u} {β : Type v} [Ring α] [Ring β] {F : α → β} {x : α} (hF : _Ring_hom F) : F (-x) = -F x
(F : Type u_1) [Field F] (E : Type u_2) [Field E] [Algebra F E] [Fintype F] [Finite_dimensional F E] : ∃ (α : E), F⟮α⟯ = ⊤
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 : P) : EuclideanGeometry.angle P1 P1 P2 = Real.Pi / 2
{α : Type u_1} {A B : set (Finset α)} {r : ℕ} : set.sized r A ∧ set.sized r B → set.sized r (A ∪ B)
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {F : m →+ P} (x : m) : ⇑(Add_Con.Ker F) x = ⇑F ⁻¹' {⇑F x}
{n : ℕ} (i : Zmod n) : order_of (dihedral_Group.sr i) = 2
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommMonoid β] [module 𝕜 E] [HasScalar 𝕜 β] {S : set E} {F : E → β} (hF : Convex_on 𝕜 S F) (C : E) : Convex_on 𝕜 ((λ (z : E), C + z) ⁻¹' S) (F ∘ λ (z : E), C + z)
{α : Type u} (S : set (set α)) : {t : set α | MeasurableSpace.generate_Measurable S t} = ⋃ (i : (Quotient.out (Cardinal.aleph 1).Ord).α), MeasurableSpace.generate_Measurable_rec S i
{x : ℝ} : (∀ (P : ℝ), LiouvilleWith P x) ↔ Liouville x
{m : Type u_1} {A : Type u_2} [CommMonoid m] {S : set m} (hs : _Submonoid S) (F : A → m) (t : Finset A) : (∀ (B : A), B ∈ t → F B ∈ S) → t.Prod (λ (B : A), F B) ∈ S
{α : sort u} {β : sort v} : Function.Injective Coe_fn
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y z : v} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x z - o.oangle y z = o.oangle x y
{α : Type u} [t : TopologicalSpace α] {B : set (set α)} (hB : TopologicalSpace._topological_Basis B) {u : set α} (ou : IsOpen u) : u = ⋃₀{S ∈ B | S ⊆ u}
{α : Type u_1} [Preorder α] [SuccOrder α] {A B : α} [NoMaxOrder α] : Order.Succ A ≤ Order.Succ B → A ≤ B
{R : Type u} {A : Type v} {B : Type W} [CommSemiring R] [Semiring A] [Algebra R A] [Semiring B] [Algebra R B] [Subsingleton (Subalgebra R A)] : Subsingleton (A →ₐ[R] B)
{m n : ℕ} : m ∣ n + m ↔ m ∣ n
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {t : Finset v} (h : Finite_dimensional.finrank K v + 1 < t.Card) : ∃ (F : v → K), t.Sum (λ (e : v), F e • e) = 0 ∧ t.Sum (λ (e : v), F e) = 0 ∧ ∃ (x : v) (h : x ∈ t), F x ≠ 0
{ι : Type W} {ι' : Type W'} {R : Type u} [Ring R] [invariant_Basis_number R] {m : Type v} [AddCommGroup m] [module R m] (v : Basis ι R m) (v' : Basis ι' R m) : (Cardinal.Mk ι).Lift = (Cardinal.Mk ι').Lift
{R : Type u_1} [NormedRing R] {x : R} (h : ∥x∥ < 1) : Filter.Tendsto (λ (n : ℕ), x ^ n) Filter.at_top (nhds 0)
{A : Type u_1} {B : Type u_2} [Field A] [Ring B] [IsDomain B] [Algebra A B] {x : B} (hx : IsIntegral A x) : Prime (minpoly A x)
{L : FirstOrder.Language} {m : Type W} {N : Type u_1} [L.structure m] [L.structure N] {F g : L.hom m N} {S : set m} (h : set.Eq_on ⇑F ⇑g S) : set.Eq_on ⇑F ⇑g ↑(⇑(FirstOrder.Language.Substructure.Closure L) S)
{α : Type u_1} [UniformSpace α] : (Uniformity α).has_Basis (λ (v : set (α × α)), v ∈ Uniformity α ∧ IsOpen v) Id
{α : Type u} [AddGroup α] [has_LE α] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B : α} : 0 ≤ A - B → B ≤ A
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m →* P} {t : Submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ t) {q : Type u_4} [CommMonoid q] {k : t.Localization_Map q} (z : N) (u : q) : ⇑(F.Map hy k) z = u ↔ ⇑(k.to_Map) (⇑g (F.sec z).fst) = ⇑(k.to_Map) (⇑g ↑((F.sec z).Snd)) * u
{P : ℕ → Prop} [Decidable_Pred P] {n : ℕ} : P n → Nat.count P (n + 1) = Nat.count P n + 1
{α : Type u_1} [Preorder α] {A B : αᵒᵈ} : B ⩿ A → ⇑order_dual.of_dual A ⩿ ⇑order_dual.of_dual B
{m : Type u_1} [AddMonoid m] {S t : set m} (h : S ⊆ t) : AddMonoid.Closure S ⊆ AddMonoid.Closure t
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace β] [TopologicalSpace γ] [t2_Space γ] {F : α → β} (hfd : DenseRange F) {g h : β → γ} (hg : Continuous g) (hH : Continuous h) (h : g ∘ F = h ∘ F) : g = h
(K : Type u_1) [Field K] [number_Field K] : ¬_Field ↥(number_Field.Ring_of_integers K)
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : Nnreal} {C : ℂ} {F : ℂ → E} (hF : Diff_Cont_on_cl ℂ F (Metric.Ball C ↑R)) (hR : 0 < R) : HasFpowerSeriesOnBall F (Cauchy_PowerSeries F C ↑R) C ↑R
(A B : ℕ) : A - B.Succ = A - B - 1
{x : Type u_1} {Y : Type u_2} [tY : TopologicalSpace Y] [DiscreteTopology Y] {F : x → Y} (hF : Function.Injective F) : DiscreteTopology x
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (m : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (hM : m (Sum.inr_ ()) (Sum.inr_ ()) ≠ 0) (i : Fin r) : m.Mul (Matrix.Pivot.List_transvec_row m).Prod (Sum.inr_ ()) (Sum.inl_ i) = 0
{α : Type u_1} {r : α → α → Prop} {F : Filter α} [IsTrans α r] [F.Ne_IsBot] : Filter._bounded r F → Filter._cobounded (Flip r) F
{C : ℝ} (h1 : 0 < C) (h2 : C < 1 / 2) : Function.Injective (Cardinal.cantor_Function C)
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) : o.rotation ↑Real.Pi = Linear_Isometry_Equiv.Neg ℝ
(R : Type u_1) [CommRing R] (m n : ℕ) : Polynomial.dickson 1 1 (m * n) = (Polynomial.dickson 1 1 m).Comp (Polynomial.dickson 1 1 n)
{α : Type u} [LinearOrder α] (A B : α) : LinearOrder.max A B = A ∧ B ≤ A ∨ LinearOrder.max A B = B ∧ A < B
{β : Type u} {α : Type v} {γ : Type W} [CommMonoid β] {S : Finset γ} {t : γ → Finset α} {t' : Finset α} {S' : α → Finset γ} (h : ∀ (x : γ) (y : α), x ∈ S ∧ y ∈ t x ↔ x ∈ S' y ∧ y ∈ t') {F : γ → α → β} : S.Prod (λ (x : γ), (t x).Prod (λ (y : α), F x y)) = t'.Prod (λ (y : α), (S' y).Prod (λ (x : γ), F x y))
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S1 S2 : AffineSubspace k P) : S1 ≤ S2 ↔ ∀ (P : P), P ∈ S1 → P ∈ S2
{G : Type u_1} [Group G] {P : ℕ} [Fact (Nat.Prime P)] {N : Subgroup G} [N.Normal] [Fintype (Sylow P ↥N)] (P : Sylow P ↥N) : (Subgroup.Map N.Subtype ↑P).Normalizer ⊔ N = ⊤
{ι : Type u_1} {R : Type u_2} {N : Type u_5} [decι : DecidableEq ι] [Semiring R] [AddCommMonoid N] [module R N] [Π (m : R), Decidable (m ≠ 0)] (P : ι → Submodule R N) {v : ι → N} (hv : ∀ (i : ι), v i ∈ P i) : (⇑(Dfinsupp.lsum ℕ) (λ (i : ι), (P i).Subtype)).Comp ((Dfinsupp.Map_Range.Linear_Map (λ (i : ι), Linear_Map.to_Span_Singleton R ↥(P i) ⟨v i, _⟩)).Comp (Finsupp_lequiv_Dfinsupp R).to_Linear_Map) = Finsupp.Total ι N R v
{α : Type u_1} [PseudoEmetricSpace α] (r C : Ennreal) (hr : r < 1) (hC : C ≠ ⊤) {F : ℕ → α} (hu : ∀ (n : ℕ), HasEdist.edist (F n) (F (n + 1)) ≤ C * r ^ n) : Cauchy_Seq F
{R : Type u} [Ring R] {S : set R} {t : Subring R} : Subring.Closure S ≤ t ↔ S ⊆ ↑t
{α : Type u} [PseudoMetricSpace α] [ProperSpace α] {x : α} {r : ℝ} {S : set α} (hr : 0 < r) (hs : IsClosed S) (h : S ⊆ Metric.Ball x r) : ∃ (r' : ℝ) (h : r' ∈ set.Ioo 0 r), S ⊆ Metric.Ball x r'
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [Finite_dimensional 𝕜 E] [Finite_dimensional 𝕜 F] (A : E →ₗ[𝕜] F) (x : E) (y : F) : HasInner.inner x (⇑(⇑LinearMap.Adjoint A) y) = HasInner.inner (⇑A x) y
(𝕜 : Type u_1) {E : Type u_2} [normed_Linear_ordered_Field 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedSpace ℝ E] [LinearMap.CompatibleSmul E E 𝕜 ℝ] (h : strict_Convex 𝕜 (metric.IsClosed_ball 0 1)) : strict_Convex_Space 𝕜 E
{R : Type u_2} {m : Type u_3} [AddCommGroup m] [Ring R] [module R m] {q : QuadraticForm R m} : q.ToFun = ⇑q
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasEqualizers C] {x Y : C} {F : x ⟶ Y} (h : F = 0) [CategoryTheory.Limits.HasImage F] : CategoryTheory.Limits.imageι F = 0
{G : Type u_1} [Group G] (h N : Subgroup G) [N.Normal] : ↑(h ⊔ N) = ↑h * ↑N
{K : Type u_1} {n : ℕ} {S : Seq (GeneralizedContinuedFraction.Pair K)} [DivisionRing K] (TerminatedAt_Succ_n : S.TerminatedAt (n + 1)) : GeneralizedContinuedFraction.squash_Seq S n = S
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P : ι → P) (h : S.Sum (λ (i : ι), W i) = 1) (B : P) : ⇑(S.affine_combination P) W = ⇑(S.weighted_vsub_of_point P B) W +ᵥ B
{α : Type u_1} {β : Type u_2} {rα : α → α → Prop} {rβ : β → β → Prop} {A : α} {B : β} (ha : Acc rα A) (hb : Acc rβ B) : Acc (Relation.Game_Add rα rβ) (A, B)
{ι : Type u_1} {x : Type u_2} [TopologicalSpace x] [NormalSpace x] {u : ι → set x} (uo : ∀ (i : ι), IsOpen (u i)) (uf : ∀ (x : x), {i : ι | x ∈ u i}.Finite) (uU : (⋃ (i : ι), u i) = set.Univ) : ∃ (v : ι → set x), set.Union v = set.Univ ∧ (∀ (i : ι), IsClosed (v i)) ∧ ∀ (i : ι), v i ⊆ u i
{C : Type u₁} [CategoryTheory.Category C] {t : CategoryTheory.Monad C} {J : Type u} [CategoryTheory.Category J] (D : J ⥤ t.Algebra) [CategoryTheory.Limits.HasLimit (D ⋙ t.Forget)] : CategoryTheory.Limits.HasLimit D
(t : ℝ) : Filter.Tendsto (λ (x : ℝ), (1 + t / x) ^ x) Filter.at_top (nhds (Real.Exp t))
{D : set ℝ} (hD : Convex ℝ D) {F : ℝ → ℝ} (hF : Continuous_on F D) (hF' : DifferentiableOn ℝ F (Interior D)) (hF'_nonpos : ∀ (x : ℝ), x ∈ Interior D → deriv F x ≤ 0) : Antitone_on F D
{α : sort u} {F : α → α} (h : Function.involutive F) {x y : α} : F x = y ↔ x = F y
{n : ℕ} [Fact (0 < n)] (A : Zmod n) : ↑(A.val) = A
{n : ℕ} (h : n ≠ 0) (D : ℕ) : ∃ᶠ (m : ℕ) in Filter.at_top, m ≡ D [Mod n]
{ι : Type u_1} {R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] {B₁ B₂ : Basis ι R m} (h : ∀ (x : m) (i : ι), ⇑(⇑(B₁.repr) x) i = ⇑(⇑(B₂.repr) x) i) : B₁ = B₂
{F : ℝ → ℝ} {F' A : ℝ} (h : IsLocalMin F A) (hF : HasDerivAt F F' A) : F' = 0
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {S : set E} [CompleteSpace F] (h : AnalyticOn 𝕜 F S) {n : WithTop ℕ} : ContDiff_on 𝕜 n F S
{C : Type v} [CategoryTheory.SmallCategory C] {D : Type v} [CategoryTheory.SmallCategory D] {L : C ⥤ D} {R : D ⥤ C} (Adj : L ⊣ R) : L.initial
{m₀ : Type u_6} [Monoid_with_Zero m₀] [Nontrivial m₀] [no_Zero_divisors m₀] {L : List m₀} : L.Prod = 0 ↔ 0 ∈ L
{G : Type u_1} [AddGroup G] (tG : AddMonoid._torsion G) (h : Add_Subgroup G) : AddMonoid._torsion ↥h
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LE.LE] {A B : α} (ha : 1 < A) (hb : 1 < B) : 1 < A * B
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {x y : 𝕜} (h : x < y) {z : 𝕜} : z ∈ set.Ioo x y ↔ ∃ (A B : 𝕜), 0 < A ∧ 0 < B ∧ A + B = 1 ∧ A * x + B * y = z
{K : Type u_1} {g : GeneralizedContinuedFraction K} {n m : ℕ} (n_LE_m : n ≤ m) (TerminatedAt_n : g.TerminatedAt n) : g.TerminatedAt m
{m : Type u_1} [Monoid m] {S : set m} {A : m} (hs : _Submonoid S) (h : A ∈ S) {n : ℕ} : A ^ n ∈ S
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} {S : set E} {x : E} {F' : TangentSpace (model_with_corners_self 𝕜 E) x →L[𝕜] TangentSpace (model_with_corners_self 𝕜 E') (F x)} : HasFderivWithinAt F F' S x → HasMfderivWithinAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F S x F'
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : set P} {S1 : AffineSubspace k P} (h : S ⊆ ↑S1) : SpanPoints k S ⊆ ↑S1
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] [Fintype α] [Fintype β] (F : α → β) {W : α → m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (hb : Fintype.Card β • B < Finset.Univ.Sum (λ (x : α), W x)) : ∃ (y : β), B < (Finset.Filter (λ (x : α), F x = y) Finset.Univ).Sum (λ (x : α), W x)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [CompactSpace α] [MetricSpace β] {F g : C(α, β)} {C : ℝ} (C0 : 0 ≤ C) : HasDist.dist F g ≤ C ↔ ∀ (x : α), HasDist.dist (⇑F x) (⇑g x) ≤ C
{R : Type u_1} [CommRing R] (u v W : Fin 3 → R) : ⇑(⇑CrossProduct u) (⇑(⇑CrossProduct v) W) = ⇑(⇑CrossProduct (⇑(⇑CrossProduct u) v)) W + ⇑(⇑CrossProduct v) (⇑(⇑CrossProduct u) W)
{α : Type u} [PseudoMetricSpace α] (P : α → Prop) (x : α) (h : ∃ᶠ (R : ℝ) in Filter.at_top, ∀ (y : α), y ∈ Metric.Ball x R → P y) (y : α) : P y
{α : Type u_1} [has_LE α] {S : set αᵒᵈ} : _upper_set S → _lower_set (⇑order_dual.to_dual ⁻¹' S)
{R : Type u} {A : Type W} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) (r : R) (y : A) : x * (⇑(Algebra_Map R A) r * y) = ⇑(Algebra_Map R A) r * (x * y)
{R : Type u_5} [CommRing R] [IsDomain R] {k l : ℕ} (h : k ≠ l) : Disjoint (primitive_roots k R) (primitive_roots l R)
{R : Type u_1} [Right_cancel_Semigroup R] (g : R) : IsRightRegular g
{α : Type u} [PseudoMetricSpace α] {S : set α} (hs : IsCompact S) {e : ℝ} (hE : 0 < e) : ∃ (t : set α) (h : t ⊆ S), t.Finite ∧ S ⊆ ⋃ (x : α) (h : x ∈ t), Metric.Ball x e
{ι : Type u_1} {α : ι → Type u_2} [DecidableEq ι] [Π (i : ι), LinearOrder (α i)] (x y x' y' : Π (i : ι), α i) : set.icc x y  set.Univ.Pi (λ (i : ι), set.Ioo (x' i) (y' i)) ⊆ (⋃ (i : ι), set.icc x (Function.update y i (x' i))) ∪ ⋃ (i : ι), set.icc (Function.update x i (y' i)) y
{α : Type u} [UniformSpace α] {F : Filter α} {x : α} (hF : Cauchy F) (adhs : ClusterPt x F) : F ≤ nhds x
{α : Type u_1} [DecidableEq α] [Fintype α] : Function.Injective Equiv.perm.Cycle_Factors_Finset
{α : Type u_1} [Monoid α] {A : α} {u : αˣ} : ↑u ∣ A
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] [Fintype α] [Fintype β] (F : α → β) {B : m} [Linear_ordered_CommRing m] [Nonempty β] (hb : ↑(Fintype.Card α) ≤ Fintype.Card β • B) : ∃ (y : β), ↑((Finset.Filter (λ (x : α), F x = y) Finset.Univ).Card) ≤ B
{α : Type u_2} [DecidableEq α] {S : Finset α} {B : Finset (Finset α)} {n : ℕ} (h : ∀ (A : α), A ∈ S → (Finset.Filter (HasMem.Mem A) B).Card = n) : B.Sum (λ (t : Finset α), (S ∩ t).Card) = S.Card * n
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] {S : Finset α} {t : Finset β} {F : α → β} {W : α → m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (hF : ∀ (y : β), y ∉ t → (Finset.Filter (λ (x : α), F x = y) S).Sum (λ (x : α), W x) ≤ 0) (ht : t.Nonempty) (hb : t.Card • B ≤ S.Sum (λ (x : α), W x)) : ∃ (y : β) (h : y ∈ t), B ≤ (Finset.Filter (λ (x : α), F x = y) S).Sum (λ (x : α), W x)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace ↥K] (P : E) : ⇑(reflection K) (⇑(reflection K) P) = P
{P : ℕ} : Summable (λ (n : ℕ), 1 / ↑n ^ P) ↔ 1 < P
{α : Type u} [TopologicalSpace α] {S : set α} (h : ∀ {ι : Type u} (Z : ι → set α), (∀ (i : ι), IsClosed (Z i)) → (S ∩ ⋂ (i : ι), Z i) = ∅ → (∃ (t : Finset ι), (S ∩ ⋂ (i : ι) (h : i ∈ t), Z i) = ∅)) : IsCompact S
{G : Type W} [TopologicalSpace G] [Group G] [topological_Group G] {K U : set G} (hK : IsCompact K) (hU : IsOpen U) (hKU : K ⊆ U) : ∃ (v : set G) (h : v ∈ nhds 1), v * K ⊆ U
{α : Type u_1} [Preorder α] [Nonempty α] [NoMinOrder α] : Infinite α
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace 𝕜] [Finite_dimensional 𝕜 E] {n : ℕ} {F : E → F} : ContDiff 𝕜 ↑(n + 1) F ↔ Differentiable 𝕜 F ∧ ∀ (y : E), ContDiff 𝕜 ↑n (λ (x : E), ⇑(fderiv 𝕜 F x) y)
{m : Type u} {n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] [Fintype m] [DecidableEq m] (A : Matrix m m α) (B : Matrix m n α) (C : Matrix n m α) (D : Matrix n n α) [Invertible D] : (Matrix.from_blocks A B C D).det = D.det * (A - (B.Mul (⅟ D)).Mul C).det
{R : Type u} {m : Type v} [CommRing R] [Nontrivial R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] (F : m →ₗ[R] m) (P : Polynomial R) : ⇑(Polynomial.aeval F) P = ⇑(Polynomial.aeval F) (P %ₘ F.charpoly)
{x : top} (F : top.Presheaf (Type v) x) {ι : Type v} (U : ι → TopologicalSpace.Opens ↥x) (sf : top.Presheaf.sheaf_condition_Equalizer_products.Pi_Opens F U) (S : F.obj (Opposite.Op (supr U))) : F._gluing U ((F.Pi_Opens_iso_sections_family U).hom sf) S ↔ top.Presheaf.sheaf_condition_Equalizer_products.res F U S = sf
{D : set ℝ} (hD : Convex ℝ D) {F : ℝ → ℝ} (hF : Continuous_on F D) (hF' : DifferentiableOn ℝ F (Interior D)) (hF'_Mono : Monotone_on (deriv F) (Interior D)) : Convex_on ℝ D F
{F : ℕ → ℝ} (hfa : Antitone F) (hF0 : Filter.Tendsto F Filter.at_top (nhds 0)) : Cauchy_Seq (λ (n : ℕ), (Finset.Range (n + 1)).Sum (λ (i : ℕ), (-1) ^ i * F i))
{α : Type u} [non_unital_CommRing α] {B C x : α} (h : x * x - B * x + C = 0) : ∃ (y : α), y * y - B * y + C = 0 ∧ x + y = B ∧ x * y = C
{β : Type u_2} [ordered_AddCommGroup β] [module ℝ β] [OrderedSmul ℝ β] {F : ℝ → β} {A B : ℝ} (A_LT_B : A < B) (h_IsLocalMin : IsLocalMinOn F (set.icc A B) A) (h_conv : Convex_on ℝ (set.icc A B) F) : IsMinOn F (set.icc A B) A
{ι : Type u_1} {m : ι → Type u_2} [Π (i : ι), Monoid (m i)] {N : Type u_3} [Monoid N] (F g : FreeProduct m →* N) (h : ∀ (i : ι), F.Comp FreeProduct.of = g.Comp FreeProduct.of) : F = g
{m : Type u_1} [has_Mul m] {C D : Con m} : (∀ (x y : m), ⇑C x y ↔ ⇑D x y) ↔ C = D
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} (l : ι →₀ 𝕜) (v : ι → E) (x : E) : HasInner.inner x (l.Sum (λ (i : ι) (A : 𝕜), A • v i)) = l.Sum (λ (i : ι) (A : 𝕜), A • HasInner.inner x (v i))
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (m : m) : 0 ≤ ∥⇑(Quotient_AddGroup.Mk' S) m∥
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + 2 * ⇑_R_or_C.re (HasInner.inner x y) + ∥y∥ * ∥y∥
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (F : LocalHomeomorph E F) {F' : E ≃L[𝕜] F} {A : F} (ha : A ∈ F.to_local_Equiv.Target) (htff' : HasFderivAt ⇑F ↑F' (⇑(F.Symm) A)) : HasFderivAt ⇑(F.Symm) ↑(F'.Symm) A
{α : Type u_1} (r : Setoid α) : Setoid.Mk_Classes r.Classes Setoid.Classes_eqv_Classes = r
{α : Type u_1} {β : Type u_3} [MeasurableSpace α] [MeasurableSpace β] {C : set (set α)} {D : set (set β)} (hC : MeasurableSpace.generate_from C = _inst_1) (hD : MeasurableSpace.generate_from D = _inst_3) (h2C : IsCountablySpanning C) (h2D : IsCountablySpanning D) : MeasurableSpace.generate_from (set.image2 has_set_Prod.Prod C D) = Prod.MeasurableSpace
(A : ℝ) : Cardinal.Mk ↥(set.ici A) = Cardinal.Continuum
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y : m} (h : SameRay R x y) : SameRay R y x
{P : Polynomial ℚ} (P_irr : Irreducible P) (P_deg : Nat.Prime P.Nat_degree) (P_roots : Fintype.Card ↥(P.root_set ℂ) = Fintype.Card ↥(P.root_set ℝ) + 2) : Function.Bijective ⇑(Polynomial.Gal.Gal_action_hom P ℂ)
{m : Type u_6} {N : Type u_7} [has_Add m] [has_Add N] (e : m ≃+ N) (x : m) : ⇑(e.Symm) (⇑e x) = x
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] {n : ℕ} (P : FormalMultilinearSeries 𝕜 E F) (C : Composition n) (F : Continuous_MultilinearMap 𝕜 (λ (i : Fin C.length), F) G) (v : Fin n → E) : ∥⇑(Continuous_MultilinearMap.Comp_along_Composition P C F) v∥ ≤ ∥F∥ * Finset.Univ.Prod (λ (i : Fin C.length), ∥P (C.blocks_fun i)∥) * Finset.Univ.Prod (λ (i : Fin n), ∥v i∥)
{α : Type u_1} [Linear_ordered_Field α] {A B : α} (ha : 0 < A) (hb : 0 < B) : 1 / A < 1 / B ↔ B < A
{𝕜 : Type u_1} {E : Type u_2} [Linear_ordered_Field 𝕜] [AddCommGroup E] [module 𝕜 E] {S : set E} : Convex 𝕜 S ↔ ∀ ⦃x y : E⦄, x ∈ S → y ∈ S → ∀ ⦃A B : 𝕜⦄, 0 ≤ A → 0 ≤ B → 0 < A + B → (A / (A + B)) • x + (B / (A + B)) • y ∈ S
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x : E} : ∥⇑innerSL x∥ = ∥x∥
{α : Type u_2} [Preorder α] [NoMaxOrder α] : Filter.at_top ≤ Filter.cofinite
{P : ℕ} [hp_Prime : Fact (Nat.Prime P)] {R : Type u_1} [non_assoc_Semiring R] {F : Π (k : ℕ), R →+* Zmod (P ^ k)} (F_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), (Zmod.cast_hom _ (Zmod (P ^ k1))).Comp (F k2) = F k1) (n : ℕ) : (padic_Int.to_Zmod_Pow n).Comp (padic_Int.Lift F_compat) = F n
{β : Type u} {α : Type v} [CommMonoid β] {P : α → Prop} {S : Finset {x // P x}} {F : {x // P x} → β} {g : α → β} (h : ∀ (x : {x // P x}), x ∈ S → g ↑x = F x) : (Finset.Map (Function.Embedding.Subtype (λ (x : α), P x)) S).Prod (λ (x : α), g x) = S.Prod (λ (x : {x // P x}), F x)
{α : Type u_2} {ι : Type u_5} [AddCommMonoid α] [Fintype ι] (F : ι → set α) (A : α) : A ∈ Finset.Univ.Sum (λ (i : ι), F i) ↔ ∃ (g : ι → α) (hg : ∀ (i : ι), g i ∈ F i), Finset.Univ.Sum (λ (i : ι), g i) = A
{R : Type u_1} [Semiring R] (r : R) (F : Polynomial R) (n : ℕ) : (⇑(Polynomial.taylor r) F).Coeff n = Polynomial.Eval r (⇑(Polynomial.hasse_deriv n) F)
{P : ℕ → Prop} : (∃ (x : ℕ), P x) → WellFounded (Nat.Upto.Gt P)
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [Finite_dimensional ℝ E] [NormedGroup F] [NormedSpace ℝ F] [TopologicalSpace.SecondCountableTopology F] (F : E → F) (S : set E) (F' : E → (E →L[ℝ] F)) (hF' : ∀ (x : E), x ∈ S → HasFderivWithinAt F (F' x) S x) (r : (E →L[ℝ] F) → Nnreal) (rpos : ∀ (A : E →L[ℝ] F), r A ≠ 0) : ∃ (t : ℕ → set E) (A : ℕ → (E →L[ℝ] F)), (∀ (n : ℕ), IsClosed (t n)) ∧ (S ⊆ ⋃ (n : ℕ), t n) ∧ (∀ (n : ℕ), ApproximatesLinearOn F (A n) (S ∩ t n) (r (A n))) ∧ (S.Nonempty → ∀ (n : ℕ), ∃ (y : E) (h : y ∈ S), A n = F' y)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {G : C ⥤ D} (hG : CategoryTheory.CompatiblePreserving K G) (ℱ : CategoryTheory.SheafOfTypes K) {Z : C} {t : CategoryTheory.Presieve Z} {x : CategoryTheory.Presieve.FamilyOfElements (G.Op ⋙ ℱ.val) t} (h : x.compatible) : (CategoryTheory.Presieve.FamilyOfElements.Functor_pushforward G x).compatible
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} {F' : ℝ → E} {C : ℝ} (hF : Continuous_on F (set.icc A B)) (hF' : ∀ (x : ℝ), x ∈ set.Ico A B → HasDerivWithinAt F (F' x) (set.ici x) x) (bound : ∀ (x : ℝ), x ∈ set.Ico A B → ∥F' x∥ ≤ C) (x : ℝ) (h : x ∈ set.icc A B) : ∥F x - F A∥ ≤ C * (x - A)
{α : Type u} [Preorder α] [OrderTop α] {A B : α} (h : A < B) : A ≠ ⊤
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {C : Con m} {F : m →* P} (h : C ≤ Con.Ker F) (hF : Function.Surjective ⇑F) : Function.Surjective ⇑(C.Lift F h)
{α : Type u_1} {F g : α → ℝ} {t₀ : Filter α} (hF : ∀ᶠ (t : α) in t₀, 0 ≤ F t) (hft : ∀ᶠ (t : α) in t₀, F t ≤ g t) (g0 : Filter.Tendsto g t₀ (nhds 0)) : Filter.Tendsto F t₀ (nhds 0)
{ι : Type u} {F g : ι → Nnreal} {P q : ℝ} (hpq : P.IsConjugateExponent q) (hF : Summable (λ (i : ι), F i ^ P)) (hg : Summable (λ (i : ι), g i ^ q)) : Summable (λ (i : ι), F i * g i) ∧ ∑' (i : ι), F i * g i ≤ (∑' (i : ι), F i ^ P) ^ (1 / P) * (∑' (i : ι), g i ^ q) ^ (1 / q)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {ι : Type W} [Fintype ι] (h : Basis ι K v) : Finite_dimensional K v
{α : Type u_1} {S : set α} : S.Pairwise ⊥ → S.Subsingleton
{R : Type u_1} [NormedRing R] (k : ℕ) {r₁ : R} {r₂ : ℝ} (h : ∥r₁∥ < r₂) : (λ (n : ℕ), ↑n ^ k * r₁ ^ n) =o[Filter.at_top] λ (n : ℕ), r₂ ^ n
{α : Type u} {l₁ l₂ : List α} {n : ℕ} : List.Drop n (l₁ ++ l₂) = List.Drop n l₁ ++ List.Drop (n - l₁.length) l₂
{ι : Type u_1} {R : Type u_3} {m : Type u_5} {v : ι → m} [Semiring R] [AddCommMonoid m] [module R m] [Fintype ι] : LinearIndependent R v ↔ (⇑(LinearMap.lsum R (λ (i : ι), R) ℕ) (λ (i : ι), LinearMap.Id.Smul_Right (v i))).Ker = ⊥
{C : Type u} [CategoryTheory.Category C] {x : C} {S R : CategoryTheory.Sieve x} (J : CategoryTheory.GrothendieckTopology C) (rj : R ∈ ⇑J x) (sj : S ∈ ⇑J x) : R ⊓ S ∈ ⇑J x
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasInitial C] [CategoryTheory.Limits.HasTerminal C] (h : CategoryTheory.Mono (CategoryTheory.Limits.initial.to (⊤_ C))) : CategoryTheory.Limits.InitialMonoClass C
{P : ℕ} [Fact (Nat.Prime P)] : WittVector.IsPoly₂ P (λ (_x : Type u_1) (_x_1 : CommRing _x), has_Add.Add)
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} {A : α} {S : set α} (h : A ∉ S → F A = 1) : finprod (λ (i : α), finprod (λ (h : i ∈ HasInsert.Insert A S), F i)) = finprod (λ (i : α), finprod (λ (h : i ∈ S), F i))
{α : Type u} {β : Type v} [Preorder β] {F : α → β} {l : Filter α} {A : α} : _extr_Filter F l A → _extr_Filter (⇑order_dual.to_dual ∘ F) l A
{R : Type u_1} [Semiring R] {x y : R} (h : Commute x y) (n : ℕ) : (x + y) ^ n = (Finset.Range (n + 1)).Sum (λ (m : ℕ), x ^ m * y ^ (n - m) * ↑(n.choose m))
{α : Type u_1} [PartialOrder α] [PredOrder α] [_Pred_Archimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ set.ioc m n → r i (Order.Pred i)) (hnm : m < n) : Relation.TransGen r n m
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] (F : S.Localization_Map N) (x : m) (y : ↥S) : ∃ (C : ↥S), x * ↑((F.sec (F.Mk' x y)).Snd) * ↑C = (F.sec (F.Mk' x y)).fst * ↑y * ↑C
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {v : set E} (hv : Orthonormal 𝕜 Coe) : (∀ (u : set E), u ⊇ v → Orthonormal 𝕜 Coe → u = v) ↔ (Submodule.Span 𝕜 v)ᗮ = ⊥
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [nondiscrete_NormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (F : MultilinearMap 𝕜 E G) (hF : Continuous ⇑F) : ∃ (C : ℝ), 0 < C ∧ ∀ (m : Π (i : ι), E i), ∥⇑F m∥ ≤ C * Finset.Univ.Prod (λ (i : ι), ∥m i∥)
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F ≠ 2) : ∃ (A : F), Char.quadratic_Char F A = -1
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) : ⇑_R_or_C.re (HasInner.inner x y) = (∥x + y∥ * ∥x + y∥ - ∥x∥ * ∥x∥ - ∥y∥ * ∥y∥) / 2
{G : Type u_1} [AddGroup G] (h : Add_Subgroup G) : 0 ∈ h
{α : Type u_1} (A : Finset α) (i : ℕ) (h₁ : i ≤ A.Card) : ∃ (B : Finset α), B ⊆ A ∧ B.Card = i
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (F : C ⥤ D) [CategoryTheory.Abelian C] [CategoryTheory.Abelian D] [F.Additive] [CategoryTheory.EnoughProjectives C] {x Y : C} (F : x ⟶ Y) (P : CategoryTheory.ProjectiveResolution x) (q : CategoryTheory.ProjectiveResolution Y) : (F.Left_derived 0).Map F ≫ CategoryTheory.Abelian.Functor.Left_derived_Zero_to_self_App F q = CategoryTheory.Abelian.Functor.Left_derived_Zero_to_self_App F P ≫ F.Map F
{α : Type u} {β : Type v} {γ : Type W} [TopologicalSpace α] [PseudoMetricSpace β] [PseudoMetricSpace γ] {G : β → γ} {C : Nnreal} (h : LipschitzWith C G) : Continuous (bounded_Continuous_Function.Comp G h)
{m : Type u_1} {N : Type u_2} [Preorder m] [has_Add m] [HasSub m] [HasOrderedSub m] [PartialOrder N] [has_Add N] [HasSub N] [HasOrderedSub N] (e : m ≃o N) (h_Add : ∀ (A B : m), ⇑e (A + B) = ⇑e A + ⇑e B) (A B : m) : ⇑e (A - B) = ⇑e A - ⇑e B
{x : top} (U : TopologicalSpace.Opens ↥x) (R : CategoryTheory.Presieve U) (hR : CategoryTheory.Sieve.generate R ∈ ⇑(Opens.GrothendieckTopology ↥x) U) : supr (top.Presheaf.covering_of_Presieve U R) = U
{α β : Type u} (e : α ≃ β) : Cardinal.Mk α = Cardinal.Mk β
(u : ℕ → ℝ) (l : ℝ) (hmono : Monotone u) (hlim : ∀ (A : ℝ), 1 < A → (∃ (C : ℕ → ℕ), (∀ᶠ (n : ℕ) in Filter.at_top, ↑(C (n + 1)) ≤ A * ↑(C n)) ∧ Filter.Tendsto C Filter.at_top Filter.at_top ∧ Filter.Tendsto (λ (n : ℕ), u (C n) / ↑(C n)) Filter.at_top (nhds l))) : Filter.Tendsto (λ (n : ℕ), u n / ↑n) Filter.at_top (nhds l)
{𝕜 : Type u_1} {E : Type u_3} [OrderedSemiring 𝕜] [TopologicalSpace E] [Add_cancel_CommMonoid E] [has_Continuous_Add E] [module 𝕜 E] {S : set E} (hs : strict_Convex 𝕜 S) (z : E) : strict_Convex 𝕜 ((λ (x : E), x + z) ⁻¹' S)
{α : Type u} [TopologicalSpace α] : DenseRange stone_cech_Unit
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : set P} {P1 P2 : P} (hp1 : P1 ∈ S) (hp2 : P2 ∈ S) : P1 -ᵥ P2 ∈ Vector_Span k S
{x y : Pgame} (h : x.Fuzzy y) : x.lf y
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] (P : P) : ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P) ∈ S
{G : Type u_1} [Group G] [_free_Group G] {h : Type u_2} [Group h] (F : _free_Group.Generators G → h) : ∃! (F : G →* h), ∀ (A : _free_Group.Generators G), ⇑F (_free_Group.of A) = F A
{α : Type u_1} {ι : Type u_3} {ι' : Type u_4} [Distrib_Lattice α] [OrderBot α] [DecidableEq ι] {S : Finset ι'} {g : ι' → Finset ι} {F : ι → α} (hs : S.Sup_indep (λ (i : ι'), (g i).Sup F)) (hg : ∀ (i' : ι'), i' ∈ S → (g i').Sup_indep F) : (S.bUnion g).Sup_indep F
{α : Type u_1} [canonically_ordered_AddMonoid α] [HasSub α] [HasOrderedSub α] {A B C : α} [ContravariantClass α α has_Add.Add has_LE.LE] [ContravariantClass α α has_Add.Add has_LT.LT] (h₁ : B ≤ A) (h₂ : C ≤ A) : A - B < A - C ↔ C < B
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {t : E →L[𝕜] E} (hT : InnerProductSpace.IsSelfAdjoint ↑t) (x : E) : ↑(t.re_apply_inner_self x) = HasInner.inner (⇑t x) x
{α : Type u_1} {β : Type u_2} {e e' : local_Equiv α β} (h : e ≈ e') : e.Target = e'.Target
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m →* P} (hg : ∀ (y : ↥S), IsUnit (⇑g ↑y)) (z : N) (v : P) : ⇑(F.Lift hg) z = v ↔ ⇑g (F.sec z).fst = ⇑g ↑((F.sec z).Snd) * v
(ι : Type u_1) [Fintype ι] : Metric.Bounded (StdSimplex ℝ ι)
{α : Type u_1} {m : Type u_5} [CommMonoid m] {F : α → m} {S t : set α} (hs : S.Finite) (ht : t.Finite) : finprod (λ (i : α), finprod (λ (h : i ∈ S ∪ t), F i)) * finprod (λ (i : α), finprod (λ (h : i ∈ S ∩ t), F i)) = finprod (λ (i : α), finprod (λ (h : i ∈ S), F i)) * finprod (λ (i : α), finprod (λ (h : i ∈ t), F i))
(F : Type u_1) [Field F] {E : Type u_2} [Field E] [Algebra F E] (S : set E) {K : Subfield E} (hF : set.Range ⇑(Algebra_Map F E) ⊆ ↑K) (HS : S ⊆ ↑K) : (intermediate_Field.Adjoin F S).to_Subfield ≤ K
{α : Type u_1} [CommSemiring α] (E : LinearRecurrence α) (u : ℕ → α) : E._solution u ↔ u ∈ E.sol_Space
(R : Type u) [CommRing R] [IsDomain R] (n : ℕ) : IsDomain (mv_Polynomial (Fin n) R)
{α : Type u_1} [UniformSpace α] {S : set (α × α)} (hs : S ∈ Uniformity α) : ∃ (t : set (α × α)) (h : t ∈ Uniformity α), symmetric_Rel t ∧ Comp_Rel t t ⊆ S
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P : ι → P) : ⇑(S.affine_combination P) W = ⇑(S.weighted_vsub_of_point P (Classical.choice AddTorsor.Nonempty)) W +ᵥ Classical.choice AddTorsor.Nonempty
{n m : ℕ} (h : n = m) : (Fin.cast h).to_Equiv = Equiv.cast _
{α : Type u} [PseudoMetricSpace α] {S : set α} {C : ℝ} (h : ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → HasDist.dist x y ≤ C) : Emetric.diam S ≤ Ennreal.of_Real C
{J : Type u₁} [CategoryTheory.Category J] [CategoryTheory.IsConnected J] (j₁ j₂ : J) : CategoryTheory.Zigzag j₁ j₂
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) : Real.cos (InnerProductGeometry.angle x y) = HasInner.inner x y / (∥x∥ * ∥y∥)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : α ≃ₜ β) {B : β} {F : β → E} {g : β → F} : F =o[nhds B] g ↔ (F ∘ ⇑e) =o[nhds (⇑(e.Symm) B)] (g ∘ ⇑e)
{α : Type u} [PseudoMetricSpace α] {S : set α} (h : TotallyBounded S) : Metric.Bounded S
{α : Type u_1} {β : Type u_2} {mβ : MeasurableSpace β} {m : MeasurableSpace α} {F : ℕ → α → β} {P : ℕ → α → Prop} [Π (n : ℕ), Decidable_Pred (P n)] (hF : ∀ (n : ℕ), Measurable (F n)) (hp : ∀ (n : ℕ), Measurable_set {x : α | P n x}) (h : ∀ (x : α), ∃ (n : ℕ), P n x) : Measurable (λ (x : α), F (Nat.Find _) x)
{E : Type u_1} {β : Type u_2} [AddCommGroup E] [TopologicalSpace E] [module ℝ E] [topological_AddGroup E] [has_Continuous_Smul ℝ E] [ordered_AddCommGroup β] [module ℝ β] [OrderedSmul ℝ β] {F : E → β} {A : E} (h_IsLocalMin : IsLocalMin F A) (h_conv : Convex_on ℝ set.Univ F) (x : E) : F A ≤ F x
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {F G : C ⥤ D} (α : F ⟶ G) [∀ (x : C), CategoryTheory.IsIso (α.App x)] : CategoryTheory.IsIso α
{α : Type u} [Group α] [has_LE α] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LE.LE] {A : α} : 1 ≤ A⁻¹ ↔ A ≤ 1
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x : v) : 2 • hb.oangle x (-x) = 0
{α : Type u_1} [Linear_ordered_Ring α] : Subsingleton (FloorRing α)
(N : ℕ) {j : ℝ} (hj : 0 < j) {C : ℝ} (hc : 1 < C) : (Finset.Filter (λ (i : ℕ), j < C ^ i) (Finset.Range N)).Sum (λ (i : ℕ), 1 / (C ^ i) ^ 2) ≤ C ^ 3 * (C - 1)⁻¹ / j ^ 2
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) (l₁ l₂ : ι →₀ 𝕜) : HasInner.inner (⇑(Finsupp.Total ι E 𝕜 v) l₁) (⇑(Finsupp.Total ι E 𝕜 v) l₂) = l₂.Sum (λ (i : ι) (y : 𝕜), ⇑(Star_Ring_end 𝕜) (⇑l₁ i) * y)
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_coproducts C] [CategoryTheory.Limits.HasCokernels C] [CategoryTheory.Normal_Epi_Category C] {x Y Z : C} (A : x ⟶ Y) (B : x ⟶ Z) [CategoryTheory.Epi A] [CategoryTheory.Epi B] : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.Span A B)
{n m : ℕ} (h : ∀ (i : ℕ), n.test_bit i = m.test_bit i) : n = m
{α : Type u} {β : Type v} [UniformSpace α] [SemilatticeSup β] {u : β → α} (hu : Cauchy_Seq u) {ι : Type u_1} {F : ι → β} {P : Filter ι} [P.Ne_IsBot] (hF : Filter.Tendsto F P Filter.at_top) {A : α} (ha : Filter.Tendsto (u ∘ F) P (nhds A)) : Filter.Tendsto u Filter.at_top (nhds A)
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) (h : IsUnit A.det) : A.Mul A⁻¹ = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasInitial C] (h : ∀ (A : C) (F : A ⟶ ⊥_ C), CategoryTheory.IsIso F) : CategoryTheory.Limits.HasStrictInitialObjects C
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {P : P} (hp : P ∈ S) (v : v) : v ∈ S.direction ↔ ∃ (P2 : P) (h : P2 ∈ S), v = P2 -ᵥ P
{F : ℕ → ℝ} (hF : ∀ (i : ℕ), 0 ≤ F i) (r : ℝ) : has_Sum F r ↔ Filter.Tendsto (λ (n : ℕ), (Finset.Range n).Sum (λ (i : ℕ), F i)) Filter.at_top (nhds r)
{α : Type u} {β : Type v} [Linear_ordered_Field α] [TopologicalSpace α] [OrderTopology α] {l : Filter β} {F g : β → α} {C : α} (hC : C < 0) (hF : Filter.Tendsto F l Filter.at_IsBot) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (λ (x : β), F x * g x) l Filter.at_top
{ι : Type u_1} {α : Type u_2} [CompleteLattice α] {t : ι → α} (ht : CompleteLattice.Independent t) {x : ι} {y : set ι} (hx : x ∉ y) : Disjoint (t x) (⨆ (i : ι) (h : i ∈ y), t i)
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] (S : Finset m) : CompleteLattice.IsCompact_element (Submodule.Span R ↑S)
{α : Type u} {A B : α} [MulOneClass α] [has_Zero α] [Preorder α] [Zero_LT.Pos_Mul_StrictMono α] (ha : A < 1) (hb : B < 1) (A0 : 0 < A) : A * B < 1
{α : Type u_1} [LinearOrder α] (A : α) (i : Fin 1) : ⇑({A}.order_emb_of_Fin _) i = A
{α : Type u} [Preorder α] {S : set α} {A : α} (h : IsGlb S A) : BddBelow S
{α : Type u_1} {r : α → α → Prop} {F : Filter α} : Filter._bounded r F ↔ ∃ (S : set α) (h : S ∈ F.sets) (B : α), S ⊆ {x : α | r x B}
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] [Nontrivial E] {F g : E → F} {U : set E} (hU : Metric.Bounded U) (hF : Diff_Cont_on_cl ℂ F U) (hg : Diff_Cont_on_cl ℂ g U) (hfg : set.Eq_on F g (Frontier U)) : set.Eq_on F g U
{α : Type u_1} {E : Type u_3} [NormedGroup E] [TopologicalSpace α] {F : α → E} : has_IsCompact_Support F → has_IsCompact_Support (λ (x : α), ∥F x∥)
(P : ℕ) : padic_norm P 1 = 1
{G : Type u_1} [sub_Neg_Monoid G] (A B : G) : A - B = A + -B
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] (q : QuadraticForm R m) (P : Submodule R (clifford_Algebra q)) (n : ℕ) : Submodule.Map clifford_Algebra.reverse (P ^ n) = Submodule.Map clifford_Algebra.reverse P ^ n
{α : sort u_1} {β : sort u_2} {P : α → β → Prop} {x₀ x₁ : Σ' (A : α), Subtype (P A)} : x₀.fst = x₁.fst → ↑(x₀.Snd) = ↑(x₁.Snd) → x₀ = x₁
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasPullbacks C] {B : C} : CategoryTheory.Limits.HasBinaryProducts (CategoryTheory.Over B)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [Finite_dimensional ℝ E] (S : Finset E) (hs : ∀ (C : E), C ∈ S → ∥C∥ ≤ 2) (h : ∀ (C : E), C ∈ S → ∀ (D : E), D ∈ S → C ≠ D → 1 ≤ ∥C - D∥) : S.Card ≤ 5 ^ Finite_dimensional.finrank ℝ E
{A B C : ℤ} : fermat_42.Minimal A B C → fermat_42.Minimal A B (-C)
{R : Type u_1} [CommRing R] (S : Submonoid R) {P : Type u_2} [CommRing P] [Algebra R P] [loc : IsLocalization S P] (x : P) (hx : IsIntegral R x) : IsFractional S (Algebra.Adjoin R {x}).to_Submodule
{k : Type u_1} {v1 : Type u_2} {P1 : Type u_3} {v2 : Type u_4} {P2 : Type u_5} {v3 : Type u_6} {P3 : Type u_7} [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] [AddCommGroup v2] [module k v2] [AddTorsor v2 P2] [AddCommGroup v3] [module k v3] [AddTorsor v3 P3] (F : P2 →ᵃ[k] P3) (g : P1 →ᵃ[k] P2) (P : P1) : ⇑(F.Comp g) P = ⇑F (⇑g P)
{α : Type u_1} [LinearOrder α] {r : α} {S : Finset α} : {r}.to_colex ≤ S.to_colex ↔ ∃ (x : α) (h : x ∈ S), r ≤ x
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) {r : Nnreal} (h : ↑r < P.radius) : (λ (n : ℕ), ∥P n∥ * ↑r ^ n) =o[Filter.at_top] λ (_x : ℕ), 1
{k : Type u_1} {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : set P} (h : AffineIndependent k (λ (P : ↥S), ↑P)) : ∃ (t : set P), S ⊆ t ∧ AffineIndependent k (λ (P : ↥t), ↑P) ∧ affine_Span k t = ⊤
{α : Type u_1} [CompleteLattice α] {S : set α} (hs : CompleteLattice.set_Independent S) {x : α} {y : set α} (hx : x ∈ S) (hy : y ⊆ S) (hxy : x ∉ y) : Disjoint x (HasSup.Sup y)
{α : Type u} [Group α] (g : Group_topology α) : Continuous has_Inv.Inv
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [AddCommMonoid F] [ordered_AddCommMonoid β] [module 𝕜 E] [module 𝕜 F] [HasScalar 𝕜 β] {F : F → β} {S : set F} (hF : ConcaveOn 𝕜 S F) (g : E →ₗ[𝕜] F) : ConcaveOn 𝕜 (⇑g ⁻¹' S) (F ∘ ⇑g)
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LE.LE] {A B : α} (ha : 0 < A) (hb : 0 ≤ B) : 0 < A + B
(R : Type u_1) {P n : ℕ} [hp : Fact (Nat.Prime P)] [Ring R] [Char_P R P] (hn : P ∣ n) : Polynomial.cyclotomic (n * P) R = Polynomial.cyclotomic n R ^ P
{R : Type u_1} [CommRing R] {Rₘ : Type u_3} {Sₘ : Type u_4} [CommRing Rₘ] [CommRing Sₘ] (P : Ideal (Polynomial R)) (pX : Polynomial R) (hpX : pX ∈ P) [Algebra (R ⧸ Ideal.comap Polynomial.C P) Rₘ] [IsLocalization.Away (Polynomial.Map (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P)) pX).leading_Coeff Rₘ] [Algebra (Polynomial R ⧸ P) Sₘ] [IsLocalization (Submonoid.Map ↑(P.QuotientMap Polynomial.C LE_rfl) (Submonoid.Powers (Polynomial.Map (Ideal.Quotient.Mk (Ideal.comap Polynomial.C P)) pX).leading_Coeff)) Sₘ] : (IsLocalization.Map Sₘ (P.QuotientMap Polynomial.C LE_rfl) _).IsIntegral
{C : Type u} [CategoryTheory.Category C] {x Y Z : C} {F g : x ⟶ Y} (W : F = g) (h : Y ⟶ Z) : F ≫ h = g ≫ h
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {F : 𝕜 → F} {F' : F} {x : 𝕜} [PartialOrder 𝕜] : HasDerivWithinAt F F' (set.ioi x) x → HasDerivWithinAt F F' (set.ici x) x
{α : Type u_1} {E : α → Type u_2} {P : Ennreal} [Π (i : α), NormedGroup (E i)] [Fact (1 ≤ P)] {F : ℕ → ↥(Lp E P)} (hF : Cauchy_Seq F) {F : ↥(Lp E P)} (hF : Filter.Tendsto (Id (λ (i : ℕ), ⇑(F i))) Filter.at_top (nhds ⇑F)) : Filter.Tendsto F Filter.at_top (nhds F)
{E : Type u_3} [semi_NormedGroup E] (u v : E) : ∥v∥ ≤ ∥u∥ + ∥u - v∥
{D : set ℝ} (hD : Convex ℝ D) {F : ℝ → ℝ} (hF : Continuous_on F D) (hF' : DifferentiableOn ℝ F (Interior D)) (hF'' : DifferentiableOn ℝ (deriv F) (Interior D)) (hF''_nonpos : ∀ (x : ℝ), x ∈ Interior D → deriv^[2] F x ≤ 0) : ConcaveOn ℝ D F
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {C : Con m} {F : m →* P} (h : C ≤ Con.Ker F) (x : m) : ⇑(C.Lift F h) (⇑(C.Mk') x) = ⇑F x
{α : Type u_1} {β : Type u_2} {γ : Type u_3} (F : α → β → γ) (S : set α) (t : set β) : set.image2 F S t = ⋃ (i : α) (h : i ∈ S) (j : β) (h : j ∈ t), {F i j}
{α : Type u_1} [LinearOrder α] (S : set α) (h : ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → ∀ (z : α), z ∈ S → x ≤ y → y ≤ z → x = y ∨ y = z) : S.Finite
{P : ℕ} [Fact (Nat.Prime P)] {F : padic_Seq P} (hF : ¬F ≈ 0) (v1 v3 : ℕ) : padic_norm P (⇑F (padic_Seq.stationary_point hF)) = padic_norm P (⇑F (LinearOrder.max v1 (LinearOrder.max (padic_Seq.stationary_point hF) v3)))
{F F' : ℝ → ℝ} {S : set ℝ} (hs : Convex ℝ S) (hF : ∀ (x : ℝ), x ∈ S → HasDerivAt F (F' x) x) {m : ℝ} (hF' : ∀ (x : ℝ), x ∈ S → F' x ≠ m) : (∀ (x : ℝ), x ∈ S → F' x < m) ∨ ∀ (x : ℝ), x ∈ S → m < F' x
{G : Type u_1} [Group G] (tG : Monoid._torsion_free G) (h : Subgroup G) : Monoid._torsion_free ↥h
{n : ℕ} : Finset.Univ = Finset.Map Equiv.perm.decompose_Fin.Symm.to_Embedding Finset.Univ
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [Linear_ordered_Field 𝕜] [AddCommGroup E] [Linear_ordered_AddCommGroup β] [module 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F : E → β} {t : Finset ι} {W : ι → 𝕜} {P : ι → E} (h : Convex_on 𝕜 S F) (hw₀ : ∀ (i : ι), i ∈ t → 0 ≤ W i) (hw₁ : 0 < t.Sum (λ (i : ι), W i)) (hp : ∀ (i : ι), i ∈ t → P i ∈ S) : ∃ (i : ι) (h : i ∈ t), F (t.Center_mass W P) ≤ F (P i)
{A P k : ℕ} (pp : Nat.Prime P) (h₁ : ¬A ∣ P ^ k) (h₂ : A ∣ P ^ (k + 1)) : A = P ^ (k + 1)
{G : Type u_1} [Group G] (h : Subgroup G) [hG : Group.IsNilpotent G] : Group.nilpotency_class ↥h ≤ Group.nilpotency_class G
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {L₁ L₂ : C ⥤ D} {R₁ R₂ : D ⥤ C} (Adj₁ : L₁ ⊣ R₁) (Adj₂ : L₂ ⊣ R₂) (F : L₂ ⟶ L₁) [CategoryTheory.IsIso (⇑(CategoryTheory.transfer_Nat_Trans_self Adj₁ Adj₂) F)] : CategoryTheory.IsIso F
{C : Type u₁} [CategoryTheory.Category C] {B A : C} {x : CategoryTheory.Subobject B} (F : A ⟶ B) [CategoryTheory.Mono F] (i : A ≅ ↑x) (W : i.hom ≫ x.arrow = F) : CategoryTheory.Subobject.Mk F = x
(R : CommRing) : AlgebraicGeometry.identity_toΓ_spec.App (AlgebraicGeometry.spec.to_LocallyRingedSpace.obj (Opposite.Op R)) ≫ AlgebraicGeometry.spec.to_LocallyRingedSpace.Map (AlgebraicGeometry.spec_Γ_identity.Inv.App R).Op = 𝟙 ((𝟭 AlgebraicGeometry.LocallyRingedSpace).obj (AlgebraicGeometry.spec.to_LocallyRingedSpace.obj (Opposite.Op R)))
{C : Type u₁} [CategoryTheory.Category C] {x : C} (P : Cᵒᵖ ⥤ Type W) : CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Presieve.Singleton (𝟙 x))
(x : ℂ) : HasDerivAt Complex.cosh (Complex.sinh x) x
{m : Type u_3} {N : Type u_4} [has_One m] [has_One N] {F g : One_hom m N} (h : F = g) (x : m) : ⇑F x = ⇑g x
{α : Type u} [TopologicalSpace α] {x : α} : Coe ⁻¹' {↑x} = ConnectedComponent x
{α : Type u_1} (r : α → α → Prop) [wo : IsWellOrder α r] {S : set (set α)} (h₁ : set.Unbounded r (⋃₀S)) (h₂ : Cardinal.Mk ↥S < StrictOrder.cof r) : ∃ (x : set α) (h : x ∈ S), set.Unbounded r x
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x ⟶ Y} {C : CategoryTheory.Limits.Fork F g} (h : CategoryTheory.Limits.IsLimit C) [CategoryTheory.Epi C.ι] : CategoryTheory.IsIso C.ι
(P : ℕ) [P_Prime : Fact (Nat.Prime P)] {q r : ℚ} (hq : q ≠ 0) (hr : r ≠ 0) : padic_val_rat P (q / r) = padic_val_rat P q - padic_val_rat P r
{𝕜 : Type u} [hnorm : nondiscrete_NormedField 𝕜] {E : Type v} [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [topological_AddGroup E] [has_Continuous_Smul 𝕜 E] (l : E →ₗ[𝕜] 𝕜) : Continuous ⇑l ↔ IsClosed ↑(l.Ker)
{R : Type v} [CommRing R] (A : Matrix (Fin 3) (Fin 3) R) : A.det = A 0 0 * A 1 1 * A 2 2 - A 0 0 * A 1 2 * A 2 1 - A 0 1 * A 1 0 * A 2 2 + A 0 1 * A 1 2 * A 2 0 + A 0 2 * A 1 0 * A 2 1 - A 0 2 * A 1 1 * A 2 0
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] (F : C ⥤ D) {x Y : C} (F : x ⟶ Y) [CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.cospan F F) F] [CategoryTheory.Mono (F.Map F)] : CategoryTheory.Mono F
{m₀ : Type u_1} [MulZeroOneClass m₀] [Nontrivial m₀] : 0 ≠ 1
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type W} {x : C} {R : CategoryTheory.Presieve x} {x : CategoryTheory.Presieve.FamilyOfElements P ⇑(CategoryTheory.Sieve.generate R)} (t : x.compatible) : (CategoryTheory.Presieve.FamilyOfElements.Restrict _ x).Sieve_extend = x
{C : Type u} [CategoryTheory.Category C] {P q R : C} (F : P ⟶ q) (g : q ⟶ R) [CategoryTheory.StrongMono (F ≫ g)] : CategoryTheory.StrongMono F
{E : Type u_1} (R : Type u_2) (S : Type u_3) [AddCommGroup E] [DivisionRing R] [DivisionRing S] [module R E] [module S E] (r : ℚ) (x : E) : ↑r • x = ↑r • x
(n : ℕ) (R : Type u_1) [Ring R] [Nontrivial R] : (Polynomial.cyclotomic n R).degree = ↑(n.Totient)
{A B : ℝ} {g' g : ℝ → ℝ} (hcont : Continuous_on g (set.Interval A B)) (hderiv : ∀ (x : ℝ), x ∈ set.Ioo (LinearOrder.min A B) (LinearOrder.max A B) → HasDerivAt g (g' x) x) (hpos : ∀ (x : ℝ), x ∈ set.Ioo (LinearOrder.min A B) (LinearOrder.max A B) → 0 ≤ g' x) : IntervalIntegrable g' MeasureTheory.MeasureSpace.Volume A B
(𝕜 : Type u_1) [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (F : E → F) [MeasurableSpace E] [Opens_MeasurableSpace E] {K : set (E →L[𝕜] F)} (hK : IsComplete K) : Measurable_set {x : E | Differentiable_at 𝕜 F x ∧ fderiv 𝕜 F x ∈ K}
{R : Type u} [CommSemiring R] [no_Zero_divisors R] (t : Multiset (Polynomial R)) : t.Prod.leading_Coeff = (Multiset.Map (λ (F : Polynomial R), F.leading_Coeff) t).Prod
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasZeroMorphisms C] (x : C) : CategoryTheory.IsPullback 0 0 (𝟙 x) 0
{P n r B : ℕ} (hp : Nat.Prime P) (hbn : Nat.log P n < B) : P ^ r ∣ n.factorial ↔ r ≤ (Finset.Ico 1 B).Sum (λ (i : ℕ), n / P ^ i)
(n : ℕ) : (List.Nat.antidiagonal n).length = n + 1
{α : Type u_1} [Preorder α] {F g : α → α} (hF : Monotone F) (h : F ≤ g) (n : ℕ) : F^[n] ≤ (g^[n])
{α : Type u} {β : Type v} [TopologicalSpace α] [Linear_ordered_AddCommGroup α] [OrderTopology α] {l : Filter β} {F g : β → α} {C : α} (hF : Filter.Tendsto F l Filter.at_top) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (λ (x : β), F x + g x) l Filter.at_top
{α : Type u_1} {S : Finset α} (P : α → Prop) [Decidable_Pred P] : Finset.Map (Function.Embedding.Subtype P) (Finset.Subtype P S) = Finset.Filter P S
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {C : Add_Con m} {F : m →+ P} (h : C ≤ Add_Con.Ker F) (hF : Function.Surjective ⇑F) : Function.Surjective ⇑(C.Lift F h)
{α : Type u_1} {β : Type u_3} [MeasurableSpace α] [MeasurableSpace β] : IsPiSystem (set.image2 has_set_Prod.Prod {S : set α | Measurable_set S} {t : set β | Measurable_set t})
{E : Type u_1} [InnerProductSpace ℝ E] {n : ℕ} (hn : 0 < n) (h : Finite_dimensional.finrank ℝ E = n) (x : Orientation ℝ E (Fin n)) : Orthonormal ℝ ⇑(Orientation.Fin_Orthonormal_Basis hn h x)
(C : Type u) [CategoryTheory.Category C] [∀ {x Y : C} {F g : x ⟶ Y}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.ParallelPair F g)] : CategoryTheory.Limits.HasEqualizers C
{m : Type u_1} [AddZeroClass m] {ι : sort u_2} (S : ι → Add_Submonoid m) {C : m → Prop} {x : m} (hx : x ∈ ⨆ (i : ι), S i) (hp : ∀ (i : ι) (x : m), x ∈ S i → C x) (h1 : C 0) (HMul : ∀ (x y : m), C x → C y → C (x + y)) : C x
{n : ℤ} (hn : n ≠ 0) (z : ↥Circle) : ⇑(fourier n) (⇑Exp_Map_Circle ((↑n)⁻¹ * Real.Pi) * z) = -⇑(fourier n) z
{β : Type u_1} [conditionally_CompleteLattice β] {S : set (WithTop β)} (hs : BddBelow S) : IsGlb S (HasInf.Inf S)
{n : ℕ} (P : Fin (n + 2)) (i : Fin (n + 1)) (h : 0 < i) : 0 < ⇑(P.Succ_above) i
{C : Type u} [CategoryTheory.Category C] {x Y Z : C} (F : x ⟶ Y) {g h : Y ⟶ Z} (W : g = h) : F ≫ g = F ≫ h
{α : Type u} {β : Type v} [SemilatticeInf α] {r : β → β → Prop} {F : α → β} (hF : ∀ (A₁ A₂ : α), A₁ ≤ A₂ → r (F A₂) (F A₁)) : Directed r F
(R : Type u) [Ring R] [strong_RankCondition R] (m : Type v) (n : Type W) [Fintype m] [Fintype n] : module.rank R (Matrix m n R) = (Cardinal.Mk m).Lift * (Cardinal.Mk n).Lift
{n : Type u_3} {α : Type v} {β : Type W} [has_Mul α] [has_Mul β] (F : α → β) (r : α) (A : Matrix n n α) (hF : ∀ (A₁ A₂ : α), F (A₁ * A₂) = F A₁ * F A₂) : (Mul_Opposite.Op r • A).Map F = Mul_Opposite.Op (F r) • A.Map F
{B : ℕ} (hb : 1 < B) {x y : ℕ} : x ≤ B ^ y ↔ Nat.clog B x ≤ y
{m : Type u_3} {N : Type u_4} {F : Type u_8} {mM : MulOneClass m} {mN : MulOneClass N} [Monoid_hom_class F m N] (F : F) {x : m} (hx : ∃ (y : m), y * x = 1) : ∃ (y : N), y * ⇑F x = 1
{α : Type u} [PseudoEmetricSpace α] {δ : ℝ} {E : set α} : IsClosed (Metric.Cthickening δ E)
{x : Type u_1} [TopologicalSpace x] : DiscreteTopology x ↔ nhds = has_pure.pure
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] {v : K} (terminates : (GeneralizedContinuedFraction.of v).terminates) : ∃ (q : ℚ), v = ↑q
(x : AlgebraicGeometry.LocallyRingedSpace) (r : ↥(AlgebraicGeometry.LocallyRingedSpace.Γ.obj (Opposite.Op x))) : x.toΓ_spec_fun ⁻¹' (Prime_Spectrum.basic_IsOpen r).val = (x.to_RingedSpace.basic_IsOpen r).val
{ι : Type W} [Fintype ι] (K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [module.Finite K L] [_IsSeparable K L] (B : Basis ι K L) : Algebra.discr K ⇑B ≠ 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P₁ P₂ : ι → P) (B : P) : S.Sum (λ (i : ι), W i • (P₁ i -ᵥ P₂ i)) = ⇑(S.weighted_vsub_of_point P₁ B) W - ⇑(S.weighted_vsub_of_point P₂ B) W
{G : Type u_6} {h : Type u_7} {F : Type u_8} [AddGroup G] [subtraction_Monoid h] [AddMonoid_hom_class F G h] (F : F) (A : G) : ⇑F (-A) = -⇑F A
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] (x : 𝕜) {𝕜' : Type u_1} [nondiscrete_NormedField 𝕜'] [normed_Algebra 𝕜 𝕜'] {h : 𝕜 → 𝕜'} {h₂ : 𝕜' → 𝕜'} {h' h₂' : 𝕜'} (hH₂ : HasDerivAt h₂ h₂' (h x)) (hH : HasDerivAt h h' x) : HasDerivAt (h₂ ∘ h) (h₂' * h') x
{m : Type u_1} [CommMonoid m] (S : Submonoid m) {ι : Type u_2} {t : Finset ι} {F : ι → m} (h : ∀ (C : ι), C ∈ t → F C ∈ S) : t.Prod (λ (C : ι), F C) ∈ S
{J : Type v} {C : Type u} [CategoryTheory.Category C] {B : C} (F : CategoryTheory.Discrete J ⥤ CategoryTheory.Over B) [CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.wide_pullback_Diagram_of_Diagram_over B F)] : CategoryTheory.Limits.HasLimit F
{α : Type u_1} {β : Type u_2} [UniformSpace α] [UniformSpace β] [SeparatedSpace α] {F : α → β} (hF : uniform_Inducing F) : uniform_Embedding F
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [RegularSpace α] [non_unital_non_assoc_Semiring α] [topological_Semiring α] {F : β → α} {g : γ → α} (hF : Summable F) (hg : Summable g) (hfg : Summable (λ (x : β × γ), F x.fst * g x.Snd)) : (∑' (x : β), F x) * ∑' (y : γ), g y = ∑' (z : β × γ), F z.fst * g z.Snd
{γ : Type u_3} [tγ : TopologicalSpace γ] [PolishSpace γ] {β : Type u_1} [TopologicalSpace β] [t2_Space β] [MeasurableSpace β] [BorelSpace β] {F : γ → β} (F_Cont : Continuous F) (F_inj : Function.Injective F) : Measurable_set (set.Range F)
{𝕜 : Type u_1} [_R_or_C 𝕜] {E : Type u_2} [InnerProductSpace 𝕜 E] [CompleteSpace E] {t : E →L[𝕜] E} (hT : InnerProductSpace.IsSelfAdjoint ↑t) {x₀ : E} (hx₀ : x₀ ≠ 0) (hextr : IsLocalExtr_on t.re_apply_inner_self (Metric.Sphere 0 ∥x₀∥) x₀) : module.End.HasEigenvector ↑t ↑((λ (x : E), t.re_apply_inner_self x / ∥x∥ ^ 2) x₀) x₀
(P : ℕ) [hp : Fact (Nat.Prime P)] (q r : ℚ) : padic_norm P (q + r) ≤ padic_norm P q + padic_norm P r
{α : Type u} {β : Type v} [Preorder β] {F : α → β} {l : Filter α} {A : α} : IsMax_Filter F l A → IsMin_Filter (⇑order_dual.to_dual ∘ F) l A
{F : ℝ → ℝ} {A B : ℝ} (h0 : 0 < B) (h1 : Continuous_on F (set.ici A)) (h2 : F =O[Filter.at_top] λ (x : ℝ), Real.Exp (-B * x)) : MeasureTheory.IntegrableOn F (set.ioi A) MeasureTheory.MeasureSpace.Volume
 : MeasureTheory.Measure.Add_haar_measure TopologicalSpace.PositiveCompacts.icc01 = MeasureTheory.MeasureSpace.Volume
(R : Type u_1) [CommRing R] : Algebra.Finite_presentation R R
{α : Type u_1} {β : Type u_2} [LinearOrder α] [PredOrder α] [Preorder β] {F : α → β} (hF : Antitone F) : Pairwise (Disjoint on λ (n : α), set.Ioo (F n) (F (Order.Pred n)))
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} {S : set α} (hF : set.Eq_on F 0 S) : finsum (λ (i : α), finsum (λ (h : i ∈ S), F i)) = 0
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] (F : S.Localization_Map N) (z : N) : F.Mk' (F.sec z).fst (F.sec z).Snd = z
(α : Type u) [Preorder α] [Nonempty α] [NoMaxOrder α] : ∃ (F : ℕ → α), StrictMono F
{α : Type u} [Preorder α] [OrderBot α] {A B : α} (h : A < B) : B ≠ ⊥
{α : Type u_1} {β : Type u_2} {l : Filter α} {F g : α → β} : F =ᶠ[l] g → ↑F = ↑g
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) : o.oangle x (-y) = o.oangle x y + ↑Real.Pi
{R : Type u} [CommRing R] (S : Submonoid R) {L : Type u} [CommRing L] [Algebra R L] [IsLocalization S L] [Fintype R] : Function.Surjective ⇑(Algebra_Map R L)
{β : Type u} {α : Type v} {γ : Type W} [AddCommMonoid β] {S : Finset α} {t : Finset γ} {F : α → β} {g : γ → β} (i : Π (A : α), A ∈ S → γ) (hi : ∀ (A : α) (ha : A ∈ S), i A ha ∈ t) (h : ∀ (A : α) (ha : A ∈ S), F A = g (i A ha)) (j : Π (A : γ), A ∈ t → α) (hj : ∀ (A : γ) (ha : A ∈ t), j A ha ∈ S) (Left_Inv : ∀ (A : α) (ha : A ∈ S), j (i A ha) _ = A) (Right_Inv : ∀ (A : γ) (ha : A ∈ t), i (j A ha) _ = A) : S.Sum (λ (x : α), F x) = t.Sum (λ (x : γ), g x)
{α : sort u} {C : α → sort v} {r : α → α → Prop} (hwf : WellFounded r) (F : Π (x : α), (Π (y : α), r y x → C y) → C x) (x : α) : hwf.fix F x = F x (λ (y : α) (h : r y x), hwf.fix F y)
(A : ↥Circle) : ⇑(Linear_Map.to_Matrix Complex.Basis_One_i Complex.Basis_One_i) ↑((⇑rotation A).to_Linear_Equiv) = ⇑(Matrix.plane_conformal_Matrix ↑A.re ↑A.im _)
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) (r : R) : v.Int_Valuation_def r < 1 ↔ v.as_Ideal ∣ Ideal.Span {r}
{G : Type u} [Group G] [Fintype G] {N : Subgroup G} [N.Normal] (hN : (Fintype.Card ↥N).IsCoprime N.Index) : ∃ (h : Subgroup G), N.Complement' h
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] [Nontrivial B] (A : A) (hF : Function.Injective ⇑(Algebra_Map A B)) : minpoly A (⇑(Algebra_Map A B) A) = Polynomial.x - ⇑Polynomial.C A
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {n : ℕ} (S : Affine.Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ℕ} (h : fs.Card = m + 1) : (S.face h).points = S.points ∘ ⇑(fs.order_emb_of_Fin h)
{α : Type u_2} [division_Monoid α] {A : α} : IsSquare A → IsSquare A⁻¹
{𝕂 : Type u_1} {𝔸 : Type u_2} [_R_or_C 𝕂] [NormedRing 𝔸] [normed_Algebra 𝕂 𝔸] [CompleteSpace 𝔸] {ι : Type u_3} (S : Finset ι) (F : ι → 𝔸) (h : ∀ (i : ι), i ∈ S → ∀ (j : ι), j ∈ S → Commute (F i) (F j)) : Exp 𝕂 (S.Sum (λ (i : ι), F i)) = S.noncomm_Prod (λ (i : ι), Exp 𝕂 (F i)) _
{α : Type u_1} {𝒜 : Finset (Finset α)} {r : ℕ} : set.sized r ↑(𝒜.Slice r)
{α : Type u_1} {S : Finset α} {F : α → Ennreal} (h : ∀ (A : α), A ∈ S → F A ≠ ⊤) : S.Prod (λ (A : α), F A) < ⊤
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [Field k] [AddCommGroup E] [module k E] [AddTorsor E PE] (F : k → PE) (A B C : k) (h : A ≠ C) : ⇑(affine_Map.line_Map (slope F A B) (slope F B C)) ((C - B) / (C - A)) = slope F A C
{R : Type u_1} [Ring R] {E : Type u_2} [AddCommGroup E] [module R E] {F : Type u_3} [AddCommGroup F] [module R F] (F g : LinearPmap R E F) (h : Disjoint F.IsDomain g.IsDomain) (x : ↥(F.IsDomain)) (y : ↥(g.IsDomain)) (hxy : ↑x = ↑y) : ⇑F x = ⇑g y
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} [CharZero k] {S : Finset ι} (P : ι → P) {n : ℕ} (h : S.Card = n + 1) : Finset.centroid k S P ∈ affine_Span k (set.Range P)
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (P1 P2 : P) : P1 ∈ affine_Span k {P2} ↔ P1 = P2
(R : Type u_1) [Ring R] : Polynomial.cyclotomic 1 R = Polynomial.x - 1
{α : Type u_1} {γ : Type u_3} [TopologicalSpace α] [MeasurableSpace α] [Opens_MeasurableSpace α] [TopologicalSpace γ] [MeasurableSpace γ] [BorelSpace γ] {F g : α → γ} {S : set α} [Π (j : α), Decidable (j ∈ S)] (hF : Continuous_on F S) (hg : Continuous_on g Sᶜ) (hs : Measurable_set S) : Measurable (S.piecewise F g)
(P : ℕ) : padic_norm P 0 = 0
{α : Type u_1} {m : Type u_5} {N : Type u_7} {R : Type u_11} [Semiring R] [AddCommMonoid m] [AddCommMonoid N] [Distrib_MulAction R m] [Distrib_MulAction R N] {F g : (α →₀ m) →+[R] N} (h : ∀ (A : α), F.Comp (Finsupp.Distrib_MulAction_hom.single A) = g.Comp (Finsupp.Distrib_MulAction_hom.single A)) : F = g
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] (F : m →ₗ[R] m) [hfg : module.Finite R m] (F_surj : Function.Surjective ⇑F) : Function.Injective ⇑F
{α : Type u} [PseudoMetricSpace α] {S : set α} {x : α} (hx : x ∈ Closure S) : metric.Inf_dist x S = 0
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {P1 P2 : P} (h : P1 ≠ P2) : EuclideanGeometry.angle P1 P2 P1 = 0
{R : Type u} [Ring R] {m : Type v} [AddCommGroup m] [module R m] {m₁ : Type v} [AddCommGroup m₁] [module R m₁] (F : m ≃ₗ[R] m₁) : module.rank R m = module.rank R m₁
{α : Type u_1} [LinearOrder α] {A B C D : α} (h₁ : LinearOrder.min A B < LinearOrder.max C D) (h₂ : LinearOrder.min C D < LinearOrder.max A B) : set.icc A B ∪ set.icc C D = set.icc (LinearOrder.min A C) (LinearOrder.max B D)
{α : Type u} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] : {S : set α | IsPreconnected S} ⊆ set.Range (Function.uncurry set.icc) ∪ set.Range (Function.uncurry set.Ico) ∪ set.Range (Function.uncurry set.ioc) ∪ set.Range (Function.uncurry set.Ioo) ∪ (set.Range set.ici ∪ set.Range set.ioi ∪ set.Range set.Iic ∪ set.Range set.Iio ∪ {set.Univ, ∅})
{R : Type v} [CommRing R] {n : ℕ} {A B : Matrix (Fin (n + 1)) (Fin (n + 1)) R} (C : Fin n → R) (A_Zero : ∀ (i : Fin (n + 1)), A i 0 = B i 0) (A_Succ : ∀ (i : Fin (n + 1)) (j : Fin n), A i j.Succ = B i j.Succ + C j * A i (⇑Fin.cast_Succ j)) : A.det = B.det
{ι : Type u} {F g : ι → ℝ} {P : ℝ} (hp : 1 ≤ P) (hF : ∀ (i : ι), 0 ≤ F i) (hg : ∀ (i : ι), 0 ≤ g i) (hF_Sum : Summable (λ (i : ι), F i ^ P)) (hg_Sum : Summable (λ (i : ι), g i ^ P)) : Summable (λ (i : ι), (F i + g i) ^ P) ∧ (∑' (i : ι), (F i + g i) ^ P) ^ (1 / P) ≤ (∑' (i : ι), F i ^ P) ^ (1 / P) + (∑' (i : ι), g i ^ P) ^ (1 / P)
{α : Type u} [PseudoMetricSpace α] {x : α} {r : ℝ} (h : 0 ≤ r) : Metric.diam (Metric.Ball x r) ≤ 2 * r
{n : ℕ} : Function.Injective Fin.Succ_above
{R : Type u_1} [Semiring R] (F : laurent_Polynomial R) (m n : ℤ) : F * laurent_Polynomial.t m * laurent_Polynomial.t n = F * laurent_Polynomial.t (m + n)
{α : Type u_1} [LinearOrder α] {S : Finset α} {k : ℕ} (h : S.Card = k) {F : Fin k ↪o α} (hfs : ∀ (x : Fin k), ⇑F x ∈ S) : F = S.order_emb_of_Fin h
{α : Type u_1} [circular_Preorder α] {A B C : α} (h : HasSbtw.Sbtw A B C) : HasSbtw.Sbtw C A B
{G : Type u_1} [Group G] (h : Subgroup G) [h.Normal] [h : Group.IsNilpotent G] : Group.nilpotency_class (G ⧸ h) ≤ Group.nilpotency_class G
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {x : top} (F : top.Presheaf C x) {x : ↥x} {Y : C} {F₁ F₂ : F.stalk x ⟶ Y} (ih : ∀ (U : TopologicalSpace.Opens ↥x) (hxU : x ∈ U), F.germ ⟨x, hxU⟩ ≫ F₁ = F.germ ⟨x, hxU⟩ ≫ F₂) : F₁ = F₂
{𝕜 : Type u_1} {_x : Ring 𝕜} {E : Type u_2} [semi_NormedGroup E] {_x_1 : module 𝕜 E} {S : Submodule 𝕜 E} (x : ↥S) : ∥x∥ = ∥↑x∥
{𝕜 : Type u_1} {E : Type u_2} [ordered_Ring 𝕜] [AddCommGroup E] [module 𝕜 E] {K : Geometry.SimplicialComplex 𝕜 E} {S t : Finset E} (hs : S ∈ K.Faces) (ht : t ∈ K.Faces) : Disjoint (⇑(Convex_hull 𝕜) ↑S) (⇑(Convex_hull 𝕜) ↑t) ∨ ∃ (u : Finset E) (h : u ∈ K.Faces), ⇑(Convex_hull 𝕜) ↑S ∩ ⇑(Convex_hull 𝕜) ↑t = ⇑(Convex_hull 𝕜) ↑u
{G : Type u} [Group G] [Fintype G] (P : ℕ) {n m : ℕ} [hp : Fact (Nat.Prime P)] (hdvd : P ^ m ∣ Fintype.Card G) (h : Subgroup G) (hH : Fintype.Card ↥h = P ^ n) (hnm : n ≤ m) : ∃ (K : Subgroup G), Fintype.Card ↥K = P ^ m ∧ h ≤ K
{A : Type u_4} (K : Type u_5) [CommRing A] [IsDomain A] (L : Type u_6) [Field K] [Field L] [Algebra A K] [_fraction_Ring A K] [Algebra A L] [Algebra K L] [IsScalarTower A K L] [Finite_dimensional K L] : _fraction_Ring ↥(integral_Closure A L) L
{α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} [TopologicalSpace β] {F : α → β} (hF : ∀ (x y : α), F x = F y) : MeasureTheory.strongly_Measurable F
{F : ℝ → ℝ} (hF : Differentiable ℝ F) (hF'_anti : Antitone (deriv F)) : ConcaveOn ℝ set.Univ F
(j : ℕ) : ¬AlgebraicTopology.DoldKan.C.Rel 0 j
{k : Type u_1} {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [CharZero k] {n : ℕ} (S : Affine.Simplex k P n) {fs₁ fs₂ : Finset (Fin (n + 1))} {m₁ m₂ : ℕ} (h₁ : fs₁.Card = m₁ + 1) (h₂ : fs₂.Card = m₂ + 1) : Finset.centroid k fs₁ S.points = Finset.centroid k fs₂ S.points ↔ fs₁ = fs₂
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (A B : F) : Char.quadratic_Char F (A * B) = Char.quadratic_Char F A * Char.quadratic_Char F B
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m →+ P} {t : Add_Submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ t) {q : Type u_4} [AddCommMonoid q] {k : t.Localization_Map q} (z : N) : ⇑(F.Map hy k) z + ⇑(k.to_Map) (⇑g ↑((F.sec z).Snd)) = ⇑(k.to_Map) (⇑g (F.sec z).fst)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} (P : ι → P) (i0 : ι) : Vector_Span k (set.Range P) = Submodule.Span k (set.Range (λ (i : ι), P i -ᵥ P i0))
{α : Type u} [PseudoEmetricSpace α] {S : set α} : Isometry Coe
{α : Type u_1} {R : Type u_2} [CommSemiring R] (A B : R) (S : Finset α) : S.powerset.Sum (λ (t : Finset α), A ^ t.Card * B ^ (S.Card - t.Card)) = (A + B) ^ S.Card
{K : Type u} [Field K] (S : Subfield K) {x y : K} : x ∈ S → y ∈ S → x * y ∈ S
{α : Type u_1} [has_Add α] [Preorder α] [CovariantClass α α has_Add.Add has_LE.LE] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B C D : α} (h₁ : A < B) (h₂ : C < D) : A + C < B + D
{α : Type u} [HasSsubset α] [IsIrrefl α HasSsubset.Ssubset] {A B : α} : A ⊂ B → A ≠ B
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] : ⊤.direction = ⊤
{R : Type u_1} {A B : R} [Monoid R] (h : A * B = 1) : IsRightRegular A
{α : Type u_1} {β : Type u_2} {m₁ : MeasurableSpace α} {m₂ : MeasurableSpace β} {F : α → β} : Measurable F → m₂ ≤ MeasurableSpace.Map F m₁
{α : Type u_1} {E : Type u_3} {F'' : Type u_10} [HasNorm E] [NormedGroup F''] {F : α → E} {g'' : α → F''} (h : F =O[Filter.cofinite] g'') : ∃ (C : ℝ) (h : C > 0), ∀ ⦃x : α⦄, g'' x ≠ 0 → ∥F x∥ ≤ C * ∥g'' x∥
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : Rˣ) : (λ (t : R), Ring.Inverse (↑x + t) - ↑x⁻¹ + ↑x⁻¹ * t * ↑x⁻¹) =O[nhds 0] λ (t : R), ∥t∥ ^ 2
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [module 𝕜 E] {x z : E} {S : set E} (hs : Star_Convex 𝕜 (x + z) S) : Star_Convex 𝕜 x ((λ (x : E), x + z) ⁻¹' S)
{F : Type u_1} [Field F] {P : Polynomial F} {E : Type u_2} [Field E] [Algebra F E] [Fact (Polynomial.Splits (Algebra_Map F E) P)] (ϕ : E ≃ₐ[F] E) (x : ↥(P.root_set E)) : ↑(⇑(Polynomial.Gal.Restrict P E) ϕ • x) = ⇑ϕ ↑x
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {ι : Type u_1} [Fintype ι] {B : ι → v} : LinearIndependent K B ↔ Fintype.Card ι = set.finrank K (set.Range B)
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) : Real.sin (InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) = Real.sin (InnerProductGeometry.angle x y)
{R : Type u_1} [has_Mul R] {A : R} : IsRightRegular A ↔ IsSmulRegular R (Mul_Opposite.Op A)
{ι : Type u_1} {E : Type u_2} [Fintype ι] [NormedGroup E] [NormedSpace ℝ E] (B : affine_Basis ι ℝ E) : Interior (⇑(Convex_hull ℝ) (set.Range B.points)) = {x : E | ∀ (i : ι), 0 < ⇑(B.coord i) x}
{α : Type u_1} {β : Type u_2} {S : set α} {u : α → set β} {x : α} (xs : x ∈ S) : u x ⊆ ⋃ (x : α) (h : x ∈ S), u x
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) (v : E) : v ∈ Kᗮ ↔ ∀ (u : E), u ∈ K → HasInner.inner u v = 0
{m : Type u_1} [has_Add m] (C : Add_Con m) {A B : m} : ↑A = ↑B ↔ ⇑C A B
{G : Type u} [Fintype G] [Left_cancel_Monoid G] (x : G) : 0 < order_of x
{α : Type u_1} {ι : sort u_4} {S : ι → set α} {t : set α} (i : ι) (h : S i ⊆ t) : (⋂ (i : ι), S i) ⊆ t
{α : Type u} (S : set α) : Subsingleton ↥S ↔ S.Subsingleton
(R : Type u_2) {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] (n : ℕ) (B : m) : n • B = ↑n • B
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {F : E → F × G} {x : E} (hF : ContDiff_at 𝕜 n F x) : ContDiff_at 𝕜 n (λ (x : E), (F x).fst) x
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {R₁ R₂ : ℝ} {F : ℂ → E} {C z : ℂ} (hD : DifferentiableOn ℂ F (Metric.Ball C R₁)) (h_maps : set.maps_to F (Metric.Ball C R₁) (Metric.Ball (F C) R₂)) (hz : z ∈ Metric.Ball C R₁) : ∥dslope F C z∥ ≤ R₂ / R₁
{α : Type u_1} [MeasurableSpace α] (m₁ m₂ : MeasureTheory.OuterMeasure α) : (m₁ ⊔ m₂).trim = m₁.trim ⊔ m₂.trim
{P : ℤ → Prop} (Hbdd : ∃ (B : ℤ), ∀ (z : ℤ), P z → B ≤ z) (Hinh : ∃ (z : ℤ), P z) : ∃ (lb : ℤ), P lb ∧ ∀ (z : ℤ), P z → lb ≤ z
{F : Polynomial ℂ} (hF : 0 < F.degree) : ∃ (z : ℂ), F._root z
{k : Type u_1} {v : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {P : ι → P} (hi : AffineIndependent k P) {S : Finset ι} {n : ℕ} (hc : S.Card = n + 1) : Finite_dimensional.finrank k ↥(Vector_Span k ↑(Finset.image P S)) = n
{α : Type u_1} {𝕜 : Type u_14} [NormedField 𝕜] {l : Filter α} {u v : α → 𝕜} (h : u =O[l] v) : u / v * v =ᶠ[l] u
{α : Type u} [TopologicalSpace α] {S : set α} [DiscreteTopology ↥S] {x : α} (hx : x ∈ S) : ∃ (U : set α) (h : U ∈ nhds_within x {x}ᶜ), Disjoint U S
{α : Type u} [SemilatticeInf α] [Nonempty α] (S : Finset α) : BddBelow ↑S
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] {P1 P2 : P} : P1 -ᵥ P2 = 0 ↔ P1 = P2
{α : Type u} {β : Type v} [Ring α] [Ring β] {F : α → β} {x y : α} (hF : _Ring_hom F) : F (x - y) = F x - F y
{α : sort u} {α' : sort W} [DecidableEq α] [DecidableEq α'] {β : sort u_1} (g : α' → β) {F : α → α'} (hF : Function.Injective F) (i : α) (A : β) : Function.update g (F i) A ∘ F = Function.update (g ∘ F) i A
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] {F : α → β} {S : set α} {A : α} (h_Mono : Monotone_on F S) (hs : S ∈ nhds_within A (set.ici A)) (hfs : ∀ (B : β), B > F A → (∃ (C : α) (h : C ∈ S), F C ∈ set.Ioo (F A) B)) : Continuous_within_at F (set.ici A) A
{J : Type v} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (F : J → C) [CategoryTheory.Limits.HasBiproduct F] {B : CategoryTheory.Limits.Bicone F} (hb : B._bilimit) : (hb._Limit.cone_point_Unique_Up_to_iso (CategoryTheory.Limits.biproduct._Limit F)).hom = CategoryTheory.Limits.biproduct.Lift B.π
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {F g : ℂ → E} (hdf : Diff_Cont_on_cl ℂ F (set.Iio 0 ×ℂ set.Iio 0)) (hBf : ∃ (C : ℝ) (h : C < 2) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal (set.Iio 0 ×ℂ set.Iio 0)] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hdg : Diff_Cont_on_cl ℂ g (set.Iio 0 ×ℂ set.Iio 0)) (hBg : ∃ (C : ℝ) (h : C < 2) (B : ℝ), g =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal (set.Iio 0 ×ℂ set.Iio 0)] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hre : ∀ (x : ℝ), x ≤ 0 → F ↑x = g ↑x) (him : ∀ (x : ℝ), x ≤ 0 → F (↑x * Complex.i) = g (↑x * Complex.i)) : set.Eq_on F g {z : ℂ | z.re ≤ 0 ∧ z.im ≤ 0}
{F : Type u_2} [NormedGroup F] {F : ℝ → F} {A B C : ℝ} (hF : (λ (x : ℝ), (x - C)⁻¹) =O[nhds_within C {C}ᶜ] F) (hne : A ≠ B) (hc : C ∈ set.Interval A B) : ¬IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x ⟶ Y} {C : CategoryTheory.Limits.Fork F g} (i : CategoryTheory.Limits.IsLimit C) : CategoryTheory.Mono C.ι
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] {C : Add_Con m} {F : m →+ P} (h : C ≤ Add_Con.Ker F) : (C.Lift F h).Comp C.Mk' = F
{α : Type u_1} {m : Type u_5} {N : Type u_7} {P : Type u_8} [has_Zero m] [AddCommMonoid N] [AddCommMonoid P] (h : N →+ P) (F : α →₀ m) (g : α → m → N) : ⇑h (F.Sum g) = F.Sum (λ (A : α) (B : m), ⇑h (g A B))
(A : Zmod 8) : ⇑Zmod.χ₈' A = ⇑Zmod.χ₄ ↑A * ⇑Zmod.χ₈ A
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A B : α} (ha : 1 < A) (hb : 1 < B) : 1 < A * B
{R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_NormedField R] [NormedGroup F] [NormedSpace R F] [TopologicalSpace B] {ι : Type u_6} (Z : TopologicalVectorBundleCore R B F ι) : Continuous Z.Proj
{α : Type u_1} {β : Type u_2} [Infinite α] [Fintype β] (F : α → β) : ∃ (x y : α), x ≠ y ∧ F x = F y
{F : Type u_1} {α : Type u_2} {β : Type u_3} [non_assoc_Semiring α] [non_assoc_Semiring β] [Ring_hom_class F α β] (F : F) (A : α) : ⇑F (bit1 A) = bit1 (⇑F A)
{α : Type u} [PseudoMetricSpace α] {S t : set α} {x : α} {r : ℝ} (h : x ∈ S) (h : metric.Hausdorff_dist S t < r) (Fin : Emetric.Hausdorff_edist S t ≠ ⊤) : ∃ (y : α) (h : y ∈ t), HasDist.dist x y < r
{α : Type u_1} [cancel_CommMonoid_with_Zero α] [Unique_factorization_Monoid α] {A P : Associates α} (hp : Irreducible P) [Π (n : ℕ), Decidable (A ∣ P ^ n)] {n : ℕ} (h : A ∣ P ^ n) : A = P ^ Nat.Find _
{R : Type u_1} [Semiring R] (S : Subsemiring R) {l : List R} : (∀ (x : R), x ∈ l → x ∈ S) → l.Prod ∈ S
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [Ring_hom_isometric σ₁₂] (F g : E →sl[σ₁₂] F) : ∥F + g∥ ≤ ∥F∥ + ∥g∥
{J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ AddMon) [CategoryTheory.IsFiltered J] (x y : Σ (j : J), ↥(F.obj j)) (k : J) (F : x.fst ⟶ k) (g : y.fst ⟶ k) : AddMon.FilteredColimits.m.Mk F x + AddMon.FilteredColimits.m.Mk F y = AddMon.FilteredColimits.m.Mk F ⟨k, ⇑(F.Map F) x.Snd + ⇑(F.Map g) y.Snd⟩
{G : Type u_1} [AddGroup G] [hN : Nontrivial G] : AddMonoid._torsion_free G → ¬AddMonoid._torsion G
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (e : LocalHomeomorph α β) (S : set β) : e.to_local_Equiv.Source ∩ ⇑e ⁻¹' Interior S = e.to_local_Equiv.Source ∩ Interior (⇑e ⁻¹' S)
{G : Type u_10} {h : Type u_11} [Group G] [division_Monoid h] (h : G ≃* h) (x : G) : ⇑h x⁻¹ = (⇑h x)⁻¹
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y : m} {r : R} (h : SameRay R x y) (hr : 0 ≤ r) : SameRay R (r • x) y
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) : o.oangle (⇑(o.rotation (o.oangle x y)) x) y = 0
{α : Type u_1} [UniformSpace α] : (Uniformity α).has_Basis (λ (v : set (α × α)), v ∈ Uniformity α) Closure
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {ι : Type W} (h : Basis ι K v) : ↑(Finite_dimensional.finrank K v) = Cardinal.Mk ι
{α : Type u_1} {m : Type u_5} [has_Zero m] : Function.Injective Coe_fn
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) {r : Nnreal} (h₀ : r ≠ 0) {A : ℝ} (ha : A ∈ set.Ioo (-1) 1) (hp : (λ (n : ℕ), ∥P n∥ * ↑r ^ n) =O[Filter.at_top] has_Pow.Pow A) : ↑r < P.radius
{n : ℕ} {α : Fin (n + 1) → Type u} (x : α (Fin.Last n)) (P : Π (i : Fin n), α (⇑Fin.cast_Succ i)) (z : α (Fin.Last n)) : Function.update (Fin.snoc P x) (Fin.Last n) z = Fin.snoc P z
{α : Type u} [TopologicalSpace α] [LocallyCompactSpace α] [RegularSpace α] {K U : set α} (hK : IsCompact K) (hU : IsOpen U) (hKU : K ⊆ U) : ∃ (v : set α), IsOpen v ∧ K ⊆ v ∧ Closure v ⊆ U ∧ IsCompact (Closure v)
(K : Type u_1) [Field K] [_alg_IsClosed K] (S : set ℕ+) : IsCyclotomicExtension S K K
{α : Type u} [HasSubset α] [IsTrans α HasSubset.Subset] {A B C : α} : A ⊆ B → B ⊆ C → A ⊆ C
(F : Circle_deg1_Lift) (x : ℝ) : Filter.Tendsto (λ (n : ℕ), (⇑(F ^ n) x - x) / ↑n) Filter.at_top (nhds F.TranslationNumber)
{α : Type u_1} {ι : sort u_3} [conditionally_CompleteLattice α] {B : α} [Nonempty ι] {F : ι → α} (h₁ : ∀ (i : ι), F i ≤ B) (h₂ : ∀ (W : α), W < B → (∃ (i : ι), W < F i)) : (⨆ (i : ι), F i) = B
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [Linear_ordered_AddCommMonoid β] [HasScalar 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F g : E → β} (hF : ConcaveOn 𝕜 S F) (hg : ConcaveOn 𝕜 S g) : ConcaveOn 𝕜 S (F ⊓ g)
{α : Type u_1} {m : Type u_5} {N : Type u_7} [has_Zero m] [AddCommMonoid N] (F : α →₀ m) (y : α) (g : α → m → N) (hg : ∀ (i : α), g i 0 = 0) : g y (⇑F y) + (Finsupp.erase y F).Sum g = F.Sum g
{C : Type u} [CategoryTheory.Category C] {P q R : C} (F : P ⟶ q) (g : q ⟶ R) [CategoryTheory.StrongMono F] [CategoryTheory.StrongMono g] : CategoryTheory.StrongMono (F ≫ g)
{x : Type u_2} [EmetricSpace x] {m₁ m₂ : Ennreal → Ennreal} {C : Ennreal} (hc : C ≠ ⊤) (h0 : C ≠ 0) (hle : m₁ ≤ᶠ[nhds_within 0 (set.ici 0)] C • m₂) : MeasureTheory.OuterMeasure.Mk_metric m₁ ≤ C • MeasureTheory.OuterMeasure.Mk_metric m₂
{α : Type u_1} [MeasurableSpace α] {ι : Type u_2} {F : ι → α → Ennreal} {g : α → Ennreal} (u : Filter ι) [u.Ne_IsBot] [u._countably_generated] (hF : ∀ (i : ι), Measurable (F i)) (lim : Filter.Tendsto F u (nhds g)) : Measurable g
{m : Type u} [Monoid m] {F : Type v} [DivisionRing F] [Mul_Semiring_action m F] (x : m) (m : F) : x • m⁻¹ = (x • m)⁻¹
{α : Type u_1} [PseudoEmetricSpace α] {F : ℕ → α} (D : ℕ → Ennreal) (hF : ∀ (n : ℕ), HasEdist.edist (F n) (F n.Succ) ≤ D n) {A : α} (ha : Filter.Tendsto F Filter.at_top (nhds A)) (n : ℕ) : HasEdist.edist (F n) A ≤ ∑' (m : ℕ), D (n + m)
{C : Type u} [CategoryTheory.Category C] (F : Cᵒᵖ ⥤ Type v) : (CategoryTheory.Category_of_Elements.from_CostructuredArrow F).Right_Op ⋙ CategoryTheory.Category_of_Elements.to_CostructuredArrow F = 𝟭 (CategoryTheory.CostructuredArrow CategoryTheory.yoneda F)
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x : v) : 2 • o.oangle x (-x) = 0
{m : Type u_1} [Monoid_with_Zero m] {F g : ℤ →*₀ m} (h_Neg_One : ⇑F (-1) = ⇑g (-1)) (h_Nat : F.Comp Int.of_Nat_hom.to_Monoid_with_ZeroHom = g.Comp Int.of_Nat_hom.to_Monoid_with_ZeroHom) : F = g
{v₁ : Type u_2} {v₂ : Type u_3} [semi_NormedGroup v₁] [semi_NormedGroup v₂] (F : NormedGroup_hom v₁ v₂) {m : ℝ} (hMp : 0 ≤ m) (hM : ∀ (x : v₁), ∥⇑F x∥ ≤ m * ∥x∥) : ∥F∥ ≤ m
{v : Type u_1} [InnerProductSpace ℝ v] (x : v) : InnerProductGeometry.angle 0 x = Real.Pi / 2
{n : ℕ} {α : Type u_1} [Preorder α] {F g : Fin n → α} (hF : StrictMono F) (hg : StrictMono g) (h : set.Range F = set.Range g) : F = g
{R : Type u_1} [Fintype R] [CommRing R] [IsReduced R] [Char_P R 2] (A : R) : IsSquare A
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : α → E} {g' : α → F'} {l : Filter α} : F =O[l] g' ↔ ∀ᶠ (C : ℝ) in Filter.at_top, ∀ᶠ (x : α) in l, ∥F x∥ ≤ C * ∥g' x∥
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} (K : ι → Submodule 𝕜 E) : (⨅ (i : ι), (K i)ᗮ) = (supr K)ᗮ
{R : Type u} {K : Type v} {L : Type z} {P : R} [CommRing R] [Field K] [Field L] [Algebra K L] [Algebra R L] [Algebra R K] [IsScalarTower R K L] [_IsSeparable K L] [IsDomain R] [normalized_Gcd_Monoid R] [_fraction_Ring R K] [_integrally_IsClosed R] {B : power_Basis K L} (hp : Prime P) (hBint : IsIntegral R B.gen) {n : ℕ} {z : L} (hzint : IsIntegral R z) (hz : P ^ n • z ∈ Algebra.Adjoin R {B.gen}) (hei : (minpoly R B.gen)._eisenstein_at (Submodule.Span R {P})) : z ∈ Algebra.Adjoin R {B.gen}
{α : Type u} {β : Type v} [PseudoMetricSpace α] {F : β → α} : Metric.Bounded (set.Range F) ↔ ∃ (C : ℝ), ∀ (x y : β), HasDist.dist (F x) (F y) ≤ C
{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (m : Matrix n n R) (k : ℕ) : m ^ k = ⇑(Polynomial.aeval m) (Polynomial.x ^ k %ₘ m.charpoly)
{α : Type u_1} [LinearOrder α] [DecidableEq α] {P : Finset α → Prop} (S : Finset α) (h0 : P ∅) (step : ∀ (A : α) (S : Finset α), (∀ (x : α), x ∈ S → A < x) → P S → P (HasInsert.Insert A S)) : P S
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.has_Finite_coproducts C] [CategoryTheory.Limits.HasCokernels C] [CategoryTheory.Normal_Epi_Category C] {x Y : C} (F g : x ⟶ Y) : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.ParallelPair F g)
{k : Type u_1} {v : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Finite_dimensional k v] [Fintype ι] {P : ι → P} (hi : AffineIndependent k P) : affine_Span k (set.Range P) = ⊤ ↔ Fintype.Card ι = Finite_dimensional.finrank k v + 1
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 : P) (hp1P2 : P1 ≠ P2) : EuclideanGeometry.angle P1 (midpoint ℝ P1 P2) P2 = Real.Pi
(m : Type u_1) (α : Type u_2) [Monoid m] [MulAction m α] {P q : Submonoid m} : MulAction.FixedPoints ↥(P ⊔ q) α = MulAction.FixedPoints ↥P α ∩ MulAction.FixedPoints ↥q α
{m : Type u_1} [Group_with_Zero m] : set.Center mˣ = Coe ⁻¹' set.Center m
{α : Type u} {n : ℕ} (F : Fin n → α) (i : ℕ) : (List.of_fn F).nth i = List.of_fn_nth_val F i
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : ∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * ⇑_R_or_C.re (HasInner.inner x y) + ∥y∥ ^ 2
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : HasInner.inner x y / (∥x∥ * ∥y∥) = 1 ↔ x ≠ 0 ∧ ∃ (r : ℝ), 0 < r ∧ y = r • x
{ι : Type u} {x : Type v} [TopologicalSpace x] {S : set x} [NormalSpace x] [ParacompactSpace x] (P : (x → ℝ) → Prop) (h01 : ∀ (S t : set x), IsClosed S → IsClosed t → Disjoint S t → (∃ (F : C(x, ℝ)), P ⇑F ∧ set.Eq_on ⇑F 0 S ∧ set.Eq_on ⇑F 1 t ∧ ∀ (x : x), ⇑F x ∈ set.icc 0 1)) (hs : IsClosed S) (U : ι → set x) (ho : ∀ (i : ι), IsOpen (U i)) (hU : S ⊆ ⋃ (i : ι), U i) : ∃ (F : BumpCovering ι x S), (∀ (i : ι), P ⇑(⇑F i)) ∧ F._subordinate U
{α : Type u_1} {β : Type u_2} {F : α →. β ⊕ α} (A A' : α) (ha' : Sum.inr_ A' ∈ F A) : F.fix A = F.fix A'
{α : Type u_1} [TopologicalSpace α] [t2_Space α] {F : α → α} (hF : Continuous F) : IsClosed (Function.FixedPoints F)
{S : set ℝ} : IsPreconnected S → Convex ℝ S
{F₁ F₂ : Circle_deg1_Liftˣ} (h : ↑F₁.TranslationNumber = ↑F₂.TranslationNumber) : ∃ (F : Circle_deg1_Lift), Function.Semiconj ⇑F ⇑F₁ ⇑F₂
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] (F : m →+ P) {x y : m} : ⇑(Add_Con.Ker F) x y ↔ ⇑F x = ⇑F y
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) {x Y : C} (P : x = Y) : F.Map (CategoryTheory.Eq_to_hom P) = CategoryTheory.Eq_to_hom _
{α : Type u_3} [SemilatticeSup α] (A : α) : Filter.at_top = Filter.comap Coe Filter.at_top
{α : Type u_1} [NormedRing α] [CompleteSpace α] {F g : ℕ → α} (hF : Summable (λ (x : ℕ), ∥F x∥)) (hg : Summable (λ (x : ℕ), ∥g x∥)) : (∑' (n : ℕ), F n) * ∑' (n : ℕ), g n = ∑' (n : ℕ), (Finset.Range (n + 1)).Sum (λ (k : ℕ), F k * g (n - k))
 : Filter.Tendsto (λ (n : ℕ), (Finset.Range n).Sum (λ (i : ℕ), 1 / (↑i + 1))) Filter.at_top Filter.at_top
{m : Type u_1} [cancel_CommMonoid_with_Zero m] [DecidableEq m] [Unique_factorization_Monoid m] [Unique mˣ] (x : m) : Unique_factorization_Monoid.Factors x = Unique_factorization_Monoid.normalized_Factors x
{α : sort u_1} {β : Type u_2} {γ : sort u_3} [DecidableEq β] (g : β → γ) {F : α → β} {i : β} (A : γ) (h : i ∉ set.Range F) : Function.update g i A ∘ F = g ∘ F
{𝕂 : Type u_1} {𝔸 : Type u_2} {𝔹 : Type u_3} [nondiscrete_NormedField 𝕂] [NormedRing 𝔸] [NormedRing 𝔹] [normed_Algebra 𝕂 𝔸] [normed_Algebra 𝕂 𝔹] [CompleteSpace 𝔸] {F : Type u_4} [Ring_hom_class F 𝔸 𝔹] (F : F) (hF : Continuous ⇑F) (x : 𝔸) (hx : x ∈ Emetric.Ball 0 (Exp_series 𝕂 𝔸).radius) : ⇑F (Exp 𝕂 x) = Exp 𝕂 (⇑F x)
{S : set ℝ} : Convex ℝ S → IsPreconnected S
{α : Type u_3} {β : Type u_4} [Nonempty α] [SemilatticeSup α] [Preorder β] {F : α → β} : Filter.Tendsto F Filter.at_top Filter.at_top ↔ ∀ (B : β), ∃ (i : α), ∀ (A : α), i ≤ A → B ≤ F A
{R : Type u} [non_assoc_Semiring R] {S t : Subsemiring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ t) : S = t
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] {v : ℝ → E → E} {t_min t₀ t_max : ℝ} (ht₀ : t₀ ∈ set.icc t_min t_max) (x₀ : E) {C R : ℝ} (hR : 0 ≤ R) {L : Nnreal} (Hlip : ∀ (t : ℝ), t ∈ set.icc t_min t_max → LipschitzOnWith L (v t) (metric.IsClosed_ball x₀ R)) (Hcont : ∀ (x : E), x ∈ metric.IsClosed_ball x₀ R → Continuous_on (λ (t : ℝ), v t x) (set.icc t_min t_max)) (Hnorm : ∀ (t : ℝ), t ∈ set.icc t_min t_max → ∀ (x : E), x ∈ metric.IsClosed_ball x₀ R → ∥v t x∥ ≤ C) (HMul_LE : C * LinearOrder.max (t_max - t₀) (t₀ - t_min) ≤ R) : ∃ (F : ℝ → E), F t₀ = x₀ ∧ ∀ (t : ℝ), t ∈ set.icc t_min t_max → HasDerivWithinAt F (v t (F t)) (set.icc t_min t_max) t
{S : set ℝ} (h : Metric.Bounded S) : Metric.diam S = HasSup.Sup S - HasInf.Inf S
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {j₁ j₂ j₃ k₁ k₂ l : C} (F₁ : j₁ ⟶ k₁) (F₂ : j₂ ⟶ k₁) (F₃ : j₂ ⟶ k₂) (F₄ : j₃ ⟶ k₂) (g₁ : j₁ ⟶ l) (g₂ : j₃ ⟶ l) : ∃ (S : C) (α : k₁ ⟶ S) (β : l ⟶ S) (γ : k₂ ⟶ S), F₁ ≫ α = g₁ ≫ β ∧ F₂ ≫ α = F₃ ≫ γ ∧ F₄ ≫ γ = g₂ ≫ β
{β : Type u} {α : Type v} [CommMonoid β] [DecidableEq α] (S : Finset α) (F : α → β) {A : α} (h : A ∈ S) : F A * (S.erase A).Prod (λ (x : α), F x) = S.Prod (λ (x : α), F x)
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] (Z : TopologicalFiberBundleCore ι B F) : IsTopologicalFiberBundle F Z.Proj
{α : Type u_1} [has_LE α] {A B : α} : B ≤ A → ⇑order_dual.to_dual A ≤ ⇑order_dual.to_dual B
{α : Type u} [PseudoMetricSpace α] (x y : UniformSpace.completion α) (h : HasDist.dist x y = 0) : x = y
{β : Type v} {δ : Type u_2} [TopologicalSpace β] [TopologicalSpace δ] {α : Type u_1} {γ : Type u_3} (F : α → β) (g : γ → δ) : Prod.TopologicalSpace = TopologicalSpace.induced (λ (P : α × γ), (F P.fst, g P.Snd)) Prod.TopologicalSpace
(x : Pgame) : (0 * x).Equiv 0
{α : Type u} {β : α → Type u} [Π (A : α), Fintype (β A)] : Cardinal.Mk (W_Type β) ≤ LinearOrder.max (Cardinal.Mk α) Cardinal.aleph0
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [Finite_dimensional ℝ E] {x : E} {S : set E} (hs : S ∈ nhds x) : ∃ (F : E → ℝ), F =ᶠ[nhds x] 1 ∧ (∀ (y : E), F y ∈ set.icc 0 1) ∧ ContDiff ℝ ⊤ F ∧ has_IsCompact_Support F ∧ Tsupport F ⊆ S
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {v : m} (h : v ≠ 0) {r : R} (hr : 0 < r) (hrv : r • v ≠ 0) : Ray_of_Ne_Zero R (r • v) hrv = Ray_of_Ne_Zero R v h
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {G : C ⥤ D} (h : CategoryTheory.cover_Dense K G) [CategoryTheory.Full G] {ℱ : Dᵒᵖ ⥤ Type v} {ℱ' : CategoryTheory.SheafOfTypes K} (α : G.Op ⋙ ℱ ⟶ G.Op ⋙ ℱ'.val) {x : D} (x : ℱ.obj (Opposite.Op x)) : (CategoryTheory.cover_Dense.types.pushforward_family h α x).compatible
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMaxOrder α] {A : α} {S : set α} : S ∈ nhds_within A (set.ioi A) ↔ ∃ (u : α) (h : u ∈ set.ioi A), set.Ioo A u ⊆ S
{ι : Type u_1} {R : Type u_8} [canonically_ordered_CommSemiring R] [Nontrivial R] [DecidableEq R] {S : Finset ι} {F : ι → WithTop R} (h : ∀ (i : ι), i ∈ S → F i ≠ ⊤) : S.Prod (λ (i : ι), F i) < ⊤
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_4} [DecidableEq ι] [Fintype ι] (e : Basis ι R m) (W : ι → Rˣ) : ⇑(e.det) ⇑(e.units_Smul W) = Finset.Univ.Prod (λ (i : ι), ↑(W i))
(h : Type u) (m : Type u_2) [TopologicalSpace h] [TopologicalSpace m] [ChartedSpace h m] [LocallyCompactSpace h] : LocallyCompactSpace m
{A B : Prop} : ¬(A ∨ B) ↔ ¬A ∧ ¬B
{g : Matrix.special_Linear_Group (Fin 2) ℤ} {z : UpperHalfPlane} (hz : z ∈ modular_Group.Fdo) (hg : g • z ∈ modular_Group.Fdo) : z = g • z
{β : Type u} {α : Type v} [CommMonoid β] [DecidableEq α] (S : Finset α) (A : α) (B : α → β) : S.Prod (λ (x : α), Ite (x = A) (B x) 1) = Ite (A ∈ S) (B A) 1
{R : Type u_1} {A : Type u_2} [CommSemiring R] [Semiring A] [Algebra R A] [no_Zero_divisors A] (h : Function.Injective ⇑(Algebra_Map R A)) : NoZeroSmulDivisors R A
{ι : Type v} (F : ι → Cardinal) : (Cardinal.Sup F).Lift = Cardinal.Sup (λ (i : ι), (F i).Lift)
{x Y Z : AlgebraicGeometry.scheme} (𝒰 : x.IsOpen_cover) (F : x ⟶ Z) (g : Y ⟶ Z) [∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (𝒰.Map i ≫ F) g] (i : 𝒰.J) : CategoryTheory.Limits.pullback.Lift CategoryTheory.Limits.pullback.Snd (CategoryTheory.Limits.pullback.fst ≫ AlgebraicGeometry.scheme.pullback.P2 𝒰 F g) _ ≫ (AlgebraicGeometry.scheme.pullback.gluing 𝒰 F g).ι i = CategoryTheory.Limits.pullback.fst
{α : Type u_1} (L : List (List α)) {i j : ℕ} (hi : i < L.length) (hj : j < (L.nth_LE i hi).length) : L.Join.nth_LE ((List.take i (List.Map List.length L)).Sum + j) _ = (L.nth_LE i hi).nth_LE j hj
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {g : α → F} {F' : α → E'} {l : Filter α} : (λ (x : α), -F' x) =O[l] g → F' =O[l] g
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {L₁ L₂ : C ⥤ D} {R₁ R₂ : D ⥤ C} (Adj₁ : L₁ ⊣ R₁) (Adj₂ : L₂ ⊣ R₂) (F : R₁ ⟶ R₂) [CategoryTheory.IsIso (⇑((CategoryTheory.transfer_Nat_Trans_self Adj₁ Adj₂).Symm) F)] : CategoryTheory.IsIso F
{x y : Game} : ¬x.lf y ↔ y ≤ x
{α : Type u_1} [DecidableEq α] {𝒜 : Finset (Finset α)} {r : ℕ} (h𝒜 : set.sized r ↑𝒜) : set.sized (r - 1) ↑(𝒜.shadow)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] {K' : Submodule 𝕜 E} [CompleteSpace ↥K'] (h : K = K') (u : E) : ↑(⇑(Orthogonal_projection K) u) = ↑(⇑(Orthogonal_projection K') u)
{m : Type u_1} [AddMonoid m] {S : set m} (hs : _Add_Submonoid S) {l : List m} : (∀ (x : m), x ∈ l → x ∈ S) → l.Sum ∈ S
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) (ps : set P) : affine_Span k (HasInsert.Insert P ↑(affine_Span k ps)) = affine_Span k (HasInsert.Insert P ps)
{k : Type u_1} {G : Type u_2} {v : Type u_3} [CommRing k] [Group G] [AddCommGroup v] [module k v] (ρ : Representation k G v) (g h : G) : ρ.character (h * g * h⁻¹) = ρ.character g
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : set P} (h : S.Finite) : Finite_dimensional k ↥(Vector_Span k S)
{α : Type u_1} [MeasurableSpace α] (m₁ m₂ : MeasureTheory.OuterMeasure α) : (m₁ + m₂).trim = m₁.trim + m₂.trim
{α : Type u_1} {β : Type u_2} {S : Finset α} {t : Finset β} (hc : t.Card < S.Card) {F : α → β} (hF : ∀ (A : α), A ∈ S → F A ∈ t) : ∃ (x : α) (h : x ∈ S) (y : α) (h : y ∈ S), x ≠ y ∧ F x = F y
{R : Type u_1} {m : Type u_2} [Ring R] [AddCommGroup m] [module R m] [IsArtinian R m] (F : m →ₗ[R] m) (S : Function.Injective ⇑F) : Function.Surjective ⇑F
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {x : CategoryTheory.SimplicialObject C} (q : ℕ) : (AlgebraicTopology.DoldKan.hσ q).F 0 = 0
{α : Type u_1} {β : Type u_2} {S S₁ : set α} {t t₁ : set β} : S ×ˢ t ⊆ S₁ ×ˢ t₁ ↔ S ⊆ S₁ ∧ t ⊆ t₁ ∨ S = ∅ ∨ t = ∅
{R : Type u_1} {S : Type u_2} [CommSemiring R] [CommSemiring S] [h : local_Ring S] (F : R →+* S) [_local_Ring_hom F] : local_Ring R
{F : ℕ →₀ ℕ} (hF : 0 ∉ F.Support) : 0 < F.Prod has_Pow.Pow
(S : ℝ) (hs : 1 < S) : MeasureTheory.IntegrableOn (λ (x : ℝ), ∥Real.Exp (-x) * Real.log x * x ^ (S - 1)∥) (set.ioi 0) MeasureTheory.MeasureSpace.Volume
{β : Type u} {α : Type v} {γ : Type W} [AddCommMonoid β] {S : Finset γ} {t : Finset α} {F : γ → α → β} : (S.Product t).Sum (λ (x : γ × α), F x.fst x.Snd) = t.Sum (λ (y : α), S.Sum (λ (x : γ), F x y))
{z : UpperHalfPlane} (h : 1 < ⇑Complex.norm_sq ↑z) : ⇑Complex.norm_sq ↑(modular_Group.S • z) < 1
{A : Type u_1} [NormedRing A] [normed_Algebra ℂ A] [CompleteSpace A] [Star_Ring A] [cstar_Ring A] [Star_module ℂ A] [Nontrivial A] {A : A} (ha : A ∈ self_Adjoint A) {z : ℂ} (hz : z ∈ Spectrum ℂ A) : z = ↑(z.re)
{R : Type u_1} {m : Type u_9} {ι : Type u_17} [Semiring R] [AddCommMonoid m] [module R m] [Fintype ι] [DecidableEq ι] (F : (ι → R) →ₗ[R] m) (x : ι → R) : ⇑F x = Finset.Univ.Sum (λ (i : ι), x i • ⇑F (λ (j : ι), Ite (i = j) 1 0))
{α : Type u_1} {β : Type u_2} [UniformSpace β] {F : α → β} {S : set α} [TopologicalSpace α] (L : ∀ (x : α), x ∈ S → ∀ (u : set (β × β)), u ∈ Uniformity β → (∃ (t : set α) (h : t ∈ nhds_within x S) (F : α → β), Continuous_within_at F S x ∧ ∀ (y : α), y ∈ t → (F y, F y) ∈ u)) : Continuous_on F S
{α : Type u_1} [TopologicalSpace α] [BaireSpace α] {S : set (set α)} (ho : ∀ (S : set α), S ∈ S → _Gδ S) (hS : S.countable) (hD : ∀ (S : set α), S ∈ S → Dense S) : Dense (⋂₀ S)
{R : Type u_2} [cancel_CommMonoid_with_Zero R] [Unique_factorization_Monoid R] [Nontrivial R] [normalization_Monoid R] [DecidableEq R] {P x : R} (hp : Irreducible P) (hnorm : ⇑normalize P = P) {n : ℕ} (hle : P ^ n ∣ x) (hlt : ¬P ^ (n + 1) ∣ x) : Multiset.count P (Unique_factorization_Monoid.normalized_Factors x) = n
{α : Type u_1} [PartialOrder α] {F : α → α} {P : α → Prop} {hF : ∀ (x : α), x ≤ F x} {hfp : ∀ (x : α), P (F x)} {hmin : ∀ ⦃x y : α⦄, x ≤ y → P y → F x ≤ y} (x : α) : P (⇑(Closure_operator.Mk₃ F P hF hfp hmin) x)
{m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (e : n ≃ m) (A : Matrix m m R) : (A.minor ⇑e ⇑e).det = A.det
{x : Type u_2} [EmetricSpace x] [MeasurableSpace x] [BorelSpace x] {β : Type u_1} {ι : β → Type u_3} [hι : Π (n : β), Fintype (ι n)] (S : set x) {l : Filter β} (r : β → Ennreal) (hr : Filter.Tendsto r l (nhds 0)) (t : Π (n : β), ι n → set x) (ht : ∀ᶠ (n : β) in l, ∀ (i : ι n), Emetric.diam (t n i) ≤ r n) (hst : ∀ᶠ (n : β) in l, S ⊆ ⋃ (i : ι n), t n i) (m : Ennreal → Ennreal) : ⇑(MeasureTheory.Measure.Mk_metric m) S ≤ l.liminf (λ (n : β), Finset.Univ.Sum (λ (i : ι n), m (Emetric.diam (t n i))))
{𝕜 : Type u_1} [NormedField 𝕜] [CompleteSpace 𝕜] {r : 𝕜} (hr : ∥r∥ < 1) : ∑' (n : ℕ), ↑n * r ^ n = r / (1 - r) ^ 2
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.SimplicialObject C) {n : ℕ} {i : Fin (n + 2)} {j : Fin (n + 1)} (h : ⇑Fin.cast_Succ j < i) : x.σ (⇑Fin.cast_Succ j) ≫ x.δ i.Succ = x.δ i ≫ x.σ j
{k : Type u₁} {G : Type u₂} {R : Type u_1} [Semiring k] [AddMonoid G] [Semiring R] {F g : AddMonoid_Algebra k G →+* R} (h₁ : F.Comp AddMonoid_Algebra.single_Zero_Ring_hom = g.Comp AddMonoid_Algebra.single_Zero_Ring_hom) (h_of : ↑F.Comp (AddMonoid_Algebra.of k G) = ↑g.Comp (AddMonoid_Algebra.of k G)) : F = g
{R : Type u_1} {A : R} [Mul_Zero_class R] [Nontrivial R] (la : IsLeftRegular A) : A ≠ 0
{α : Type u_1} [conditionally_CompleteLattice α] {S t : set α} (hs : BddBelow S) (sne : S.Nonempty) (ht : BddBelow t) (tne : t.Nonempty) : HasInf.Inf (S ∪ t) = HasInf.Inf S ⊓ HasInf.Inf t
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {C : ℝ} {g : α → F} {F' : α → E'} {l : Filter α} : Asymptotics._O_with C l F' g → Asymptotics._O_with C l (λ (x : α), ∥F' x∥) g
{ι : Type u_1} {R : Type u_2} {N : Type u_5} [decι : DecidableEq ι] [Semiring R] [AddCommMonoid N] [module R N] (P : ι → Prop) [Decidable_Pred P] (S : ι → Submodule R N) : (⨆ (i : ι) (h : P i), S i) = ((⇑(Dfinsupp.lsum ℕ) (λ (i : ι), (S i).Subtype)).Comp (Dfinsupp.Filter_Linear_Map R (λ (i : ι), ↥(S i)) P)).Range
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {A₁ A₂ : α} {B₁ B₂ : β} (q₁ : Path.Homotopic.Quotient A₁ A₂) (q₂ : Path.Homotopic.Quotient B₁ B₂) : Path.Homotopic.Proj_Left (Path.Homotopic.Prod q₁ q₂) = q₁
{ι : Type u_1} {N : Type u_5} [decι : DecidableEq ι] [AddCommGroup N] (P : ι → Add_Subgroup N) : CompleteLattice.Independent P ↔ Function.Injective ⇑(Dfinsupp.Sum_Add_hom (λ (i : ι), (P i).Subtype))
{G : Type u_7} [comm_Group G] (L : List G) : (L.Prod)⁻¹ = (List.Map (λ (x : G), x⁻¹) L).Prod
(α : Type u_1) : Subsingleton α ∨ Nontrivial α
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S1 S2 : AffineSubspace k P} {P1 P2 : P} (hp1 : P1 ∈ S1) (hp2 : P2 ∈ S2) : (S1 ⊔ S2).direction = S1.direction ⊔ S2.direction ⊔ Submodule.Span k {P2 -ᵥ P1}
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {F : J ⥤ C} {x : C} (h : CategoryTheory.yoneda.obj x ⋙ CategoryTheory.ulift_Functor ≅ F.cones) (S : CategoryTheory.Limits.Cone F) : (CategoryTheory.Limits.IsLimit.of_Nat_iso.Limit_cone h).extend (CategoryTheory.Limits.IsLimit.of_Nat_iso.hom_of_cone h S) = S
{Fq : Type u_1} [Fintype Fq] [Ring Fq] {D m : ℕ} (hm : Fintype.Card Fq ^ D ≤ m) (B : Polynomial Fq) (A : Fin m.Succ → Polynomial Fq) (hA : ∀ (i : Fin m.Succ), (A i).degree < B.degree) : ∃ (i₀ i₁ : Fin m.Succ), i₀ ≠ i₁ ∧ (A i₁ - A i₀).degree < ↑(B.Nat_degree - D)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S u : set E} {F : E → F} {x : E} {n : ℕ} (hu : u ∈ nhds x) (hs : UniqueDiffOn 𝕜 S) (xs : x ∈ S) : iterated_fderiv_within 𝕜 n F (S ∩ u) x = iterated_fderiv_within 𝕜 n F S x
 : Cont_mdiff (model_with_corners_self ℝ ℝ) (model_with_corners_self ℝ (EuclideanSpace ℝ (Fin 1))) ⊤ ⇑Exp_Map_Circle
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F ≠ 2) {A : F} (ha : A ≠ 0) : Char.quadratic_Char F A = Ite (A ^ (Fintype.Card F / 2) = 1) 1 (-1)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {n : WithTop ℕ} {F : E → 𝕜} {g : E → F} (hF : ContDiff_at 𝕜 n F x) (hg : ContDiff_at 𝕜 n g x) : ContDiff_at 𝕜 n (λ (x : E), F x • g x) x
{R : Type u} {S : Type v} [non_assoc_Semiring R] [non_assoc_Semiring S] (F : R →+* S) (hF : Function.Surjective ⇑F) : F.srange = ⊤
(𝕂 : Type u_1) (𝕂' : Type u_2) (𝔸 : Type u_3) [Field 𝕂] [Field 𝕂'] [Ring 𝔸] [Algebra 𝕂 𝔸] [Algebra 𝕂' 𝔸] [TopologicalSpace 𝔸] [topological_Ring 𝔸] (n : ℕ) (x : 𝔸) : ⇑(Exp_series 𝕂 𝔸 n) (λ (_x : Fin n), x) = ⇑(Exp_series 𝕂' 𝔸 n) (λ (_x : Fin n), x)
{E : Type u_1} {F : Type u_2} [InnerProductSpace ℝ E] [InnerProductSpace ℝ F] (F : E →L[ℝ] F) : IsConformalMap F ↔ ∃ (C : ℝ), 0 < C ∧ ∀ (u v : E), HasInner.inner (⇑F u) (⇑F v) = C * HasInner.inner u v
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {m : α → β → γ} {F : Filter α} {g : Filter β} {n : γ → δ} {m' : β → α' → δ} {n' : α → α'} (h_antidistrib : ∀ (A : α) (B : β), n (m A B) = m' B (n' A)) : Filter.Map n (Filter.Map₂ m F g) = Filter.Map₂ m' g (Filter.Map n' F)
{P n : ℕ} (n_big : 2 < n) (P_LE_n : P ≤ n) (big : 2 * n < 3 * P) : ⇑(n.central_binom.factorization) P = 0
{ι : Type u_1} {α : ι → Type u_2} [DecidableEq ι] [Π (i : ι), LinearOrder (α i)] (x y z : Π (i : ι), α i) : set.icc x z  set.Univ.Pi (λ (i : ι), set.ioc (y i) (z i)) ⊆ ⋃ (i : ι), set.icc x (Function.update z i (y i))
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} (h : InnerProductGeometry.angle x y = Real.Pi) : ∥x - y∥ = ∥x∥ + ∥y∥
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {F : α → β} : Monotone F → Antitone (⇑order_dual.to_dual ∘ F)
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] (u : Rˣ) (v : module.Ray R m) : u⁻¹ • v = u • v
{α : Type u_1} {β : Type u_2} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] {S : set β} : IsCompact S → S.Nonempty → ∀ {F : β → α}, Continuous_on F S → (∃ (x : β) (h : x ∈ S), ∀ (y : β), y ∈ S → F y ≤ F x)
{α : Type u_1} [TopologicalSpace α] [PolishSpace α] {S : set α} (hs : IsOpen S) : PolishSpace ↥S
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasZeroMorphisms C] {x : C} (F : 0 ⟶ x) : F = 0
{R : Type u_1} [CommRing R] {C₁ C₂ : R} (C : clifford_Algebra (clifford_Algebra_Quaternion.q C₁ C₂)) : ⇑clifford_Algebra_Quaternion.to_Quaternion (⇑clifford_Algebra.involute (⇑clifford_Algebra.reverse C)) = ⇑Quaternion_Algebra.Conj (⇑clifford_Algebra_Quaternion.to_Quaternion C)
(P : ℕ) (A : Zmod P) (ha : A ^ (P - 1) = 1) (hD : ∀ (q : ℕ), Nat.Prime q → q ∣ P - 1 → A ^ ((P - 1) / q) ≠ 1) : Nat.Prime P
{x Y : Profinite} (F : x ⟶ Y) : IsClosed_Map ⇑F
{v₁ : Type u_2} {v₂ : Type u_3} [semi_NormedGroup v₁] [semi_NormedGroup v₂] (F : NormedGroup_hom v₁ v₂) : LipschitzWith ⟨∥F∥, _⟩ ⇑F
{α : Type u} [PseudoMetricSpace α] {S : set α} (h : ¬Metric.Bounded S) : Metric.diam S = 0
{R : Type u_1} {S : Type u_2} [CommRing R] [IsDomain R] [CommRing S] {L : Type u_3} [Field L] [Algebra R S] [Algebra S L] [Algebra R L] [IsScalarTower R S L] [IsIntegral_Closure S R L] (h : Algebra.IsAlgebraic R L) (inj : Function.Injective ⇑(Algebra_Map R L)) (A : S) {B : S} (hb : B ≠ 0) : ∃ (C : S) (D : R) (h : D ≠ 0), D • A = B * C
{α : Type u_2} [Bornology α] {S : set α} : Bornology._bounded S → Bornology._cobounded Sᶜ
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] {A : α} (h : (set.ioi A).Nonempty) : Closure (set.ioi A) = set.ici A
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [Linear_ordered_AddCommMonoid β] [HasScalar 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F : E → β} (hF : strict_Convex_on 𝕜 S F) {x y : E} (hx : x ∈ S) (hy : y ∈ S) (hxy : x ≠ y) {A B : 𝕜} (ha : 0 < A) (hb : 0 < B) (hab : A + B = 1) : F (A • x + B • y) < LinearOrder.max (F x) (F y)
{α : Type v} {S : Finset α} {m : Type u_1} [CommMonoid m] (F : α → m) (P : m → Prop) (P_Mul : ∀ (A B : m), P A → P B → P (A * B)) (P_One : P 1) (P_S : ∀ (x : α), x ∈ S → P (F x)) : P (S.Prod (λ (x : α), F x))
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [Linear_ordered_Field 𝕜] [AddCommGroup E] [ordered_AddCommGroup β] [module 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F : E → β} {t : Finset ι} {W : ι → 𝕜} {P : ι → E} (hF : ConcaveOn 𝕜 S F) (h₀ : ∀ (i : ι), i ∈ t → 0 ≤ W i) (h₁ : 0 < t.Sum (λ (i : ι), W i)) (hmem : ∀ (i : ι), i ∈ t → P i ∈ S) : t.Center_mass W (F ∘ P) ≤ F (t.Center_mass W P)
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {F : α → β} : StrictAnti F → StrictMono (⇑order_dual.to_dual ∘ F)
{G : Type u_3} [AddGroup G] : AddGroup.fg G ↔ AddMonoid.fg G
{J : Type u₁} [CategoryTheory.Category J] {K : Type u₂} [CategoryTheory.Category K] {C : Type u} [CategoryTheory.Category C] {F : J ⥤ C} [CategoryTheory.Limits.HasLimit F] {E : K ⥤ J} [CategoryTheory.Limits.HasLimit (E ⋙ F)] (S : CategoryTheory.Limits.Limit_cone (E ⋙ F)) (t : CategoryTheory.Limits.Limit_cone F) : CategoryTheory.Limits.Limit.pre F E = (CategoryTheory.Limits.Limit.iso_Limit_cone t).hom ≫ S._Limit.Lift (CategoryTheory.Limits.Cone.whisker E t.cone) ≫ (CategoryTheory.Limits.Limit.iso_Limit_cone S).Inv
{G : Type W} [TopologicalSpace G] [Group G] [topological_Group G] {m : Type u_1} {hom : Type u_2} [MulOneClass m] [TopologicalSpace m] [has_Continuous_Mul m] [Monoid_hom_class hom G m] (F : hom) (hF : Continuous_at ⇑F 1) : Continuous ⇑F
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (m : m) : ⇑(S.normed_Mk) m = ⇑(Quotient_AddGroup.Mk' S) m
{α : Type u_1} {n : Type u_4} {m : Type u_5} [Mul_Zero_class α] {A : Matrix m m α} {B : Matrix n n α} (hA : A.IsDiag) (hB : B.IsDiag) : (Matrix.kronecker_Map has_Mul.Mul A B).IsDiag
{𝕂 : Type u_1} [nondiscrete_NormedField 𝕂] [CompleteSpace 𝕂] (h : 0 < (Exp_series 𝕂 𝕂).radius) : HasDerivAt (Exp 𝕂) 1 0
{ι : Type u_1} {ι' : Type u_2} {α : Type u_3} [Fintype ι] [Preorder ι'] [_Directed ι' (Function.Swap has_LE.LE)] [Nonempty ι'] {S : ι → ι' → set α} (hs : ∀ (i : ι), Antitone (S i)) : (⋃ (j : ι'), ⋂ (i : ι), S i j) = ⋂ (i : ι), ⋃ (j : ι'), S i j
{G : Type u_1} [AddGroup G] {ι : sort u_2} (S : ι → Add_Subgroup G) {C : Π (x : G), (x ∈ ⨆ (i : ι), S i) → Prop} (hp : ∀ (i : ι) (x : G) (h : x ∈ S i), C x _) (h1 : C 0 _) (HMul : ∀ (x y : G) (hx : x ∈ ⨆ (i : ι), S i) (hy : y ∈ ⨆ (i : ι), S i), C x hx → C y hy → C (x + y) _) {x : G} (hx : x ∈ ⨆ (i : ι), S i) : C x hx
{α : Type u} {β : Type v} {t : set β} {F : α → β} (h : ∀ (x : α), F x ∈ t) : Function.Injective F → Function.Injective (set.cod_Restrict F t h)
{v : Type u} {G : SimpleGraph v} [DecidableEq v] {u v W : v} (P : G.Walk v W) (h : u ∈ P.Support) : (P.take_until u h).Append (P.Drop_until u h) = P
{G : Type u_1} [Group G] {ι : Type u_2} (S : Finset ι) (F : ι → G) (comm : ∀ (x : ι), x ∈ S → ∀ (y : ι), y ∈ S → Commute (F x) (F y)) (K : ι → Subgroup G) (hind : CompleteLattice.Independent K) (hmem : ∀ (x : ι), x ∈ S → F x ∈ K x) (HEq1 : S.noncomm_Prod F comm = 1) (i : ι) (h : i ∈ S) : F i = 1
(u : pnat.xgcd_Type) : u.r + (u.bp + 1) * u.q = u.ap + 1
{β α : Type u} (F : β → α) (h₁ : Cardinal.aleph0 ≤ Cardinal.Mk β) (h₂ : Cardinal.Mk α < (Cardinal.Mk β).Ord.cof) : ∃ (A : α), Cardinal.Mk ↥(F ⁻¹' {A}) = Cardinal.Mk β
{ι : Type u_1} {m : Type u_4} {N : Type u_5} [CommMonoid m] [ordered_CommMonoid N] (F : m → N) (P : m → Prop) (h_Mul : ∀ (x y : m), P x → P y → F (x * y) ≤ F x * F y) (hp_Mul : ∀ (x y : m), P x → P y → P (x * y)) (g : ι → m) (S : Finset ι) (hs_Nonempty : S.Nonempty) (hs : ∀ (i : ι), i ∈ S → P (g i)) : F (S.Prod (λ (i : ι), g i)) ≤ S.Prod (λ (i : ι), F (g i))
{α : Type u} [PseudoMetricSpace α] {S : set α} (h : S.Finite) : Metric.Bounded S
{R : Type u} [Semiring R] [no_Zero_divisors R] [Nontrivial R] (l : List (Polynomial R)) : l.Prod.degree = (List.Map Polynomial.degree l).Sum
(F : Type u₀ → Type u₁) [Equiv_Functor F] {α β γ : Type u₀} (Ab : α ≃ β) (bc : β ≃ γ) : (Equiv_Functor.Map_Equiv F Ab).Trans (Equiv_Functor.Map_Equiv F bc) = Equiv_Functor.Map_Equiv F (Ab.Trans bc)
{R : Type u_1} (m : Type u_3) [Monoid R] [MulAction R m] : IsSmulRegular m 1
{C : Type u} [CategoryTheory.Category C] (S : set (CategoryTheory.GrothendieckTopology C)) : IsGlb S (HasInf.Inf S)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {m n : WithTop ℕ} {F : E → F} (hF : ContDiff 𝕜 n F) (hmn : m + 1 ≤ n) : ContDiff 𝕜 m (λ (P : E × E), ⇑(fderiv 𝕜 F P.fst) P.Snd)
{α : Type u_1} {m : Type u_5} {N : Type u_7} {P : Type u_8} [has_Zero m] [CommMonoid N] [CommMonoid P] (h : N →* P) (F : α →₀ m) (g : α → m → N) : ⇑h (F.Prod g) = F.Prod (λ (A : α) (B : m), ⇑h (g A B))
{α : Type u_1} {l : Filter α} {F : α → ℝ} : ((λ (x : α), 1) =O[l] λ (x : α), Real.Exp (F x)) ↔ Filter._bounded_under Ge l F
{L : FirstOrder.Language} (t : L.Theory) (κ : Cardinal) (m : Type W') [L.structure m] [m ⊨ t] [Infinite m] : ∃ (N : t.model), κ.Lift ≤ Cardinal.Mk ↥N
{E : Type u_1} [semi_NormedGroup E] {S : Add_Subgroup E} (x : ↥S) : ∥x∥ = ∥↑x∥
{E : Type u_1} [semi_NormedGroup E] [NormedSpace ℝ E] (P : Subspace ℝ E) (F : ↥P →L[ℝ] ℝ) : ∃ (g : E →L[ℝ] ℝ), (∀ (x : ↥P), ⇑g ↑x = ⇑F x) ∧ ∥g∥ = ∥F∥
{α : Type u_1} {β : Type u_2} {r : Setoid α} (F : α → β) (h : ∀ (x y : α), r.Rel x y → F x = F y) (h : Function.Injective (Quotient.Lift F h)) : Setoid.Ker F = r
{α : Type u} [PseudoEmetricSpace α] {S t : set α} (hs : IsClosed S) (ht : IsClosed t) : Emetric.Hausdorff_edist S t = 0 ↔ S = t
{α : Type u_1} {r : α → α → Prop} [IsRefl α r] {x y : α} : x ≠ y → r x y ↔ r x y
(Γ₀ : Type u_1) [Linear_ordered_comm_Group_with_Zero Γ₀] : has_pure.pure ≤ Linear_ordered_comm_Group_with_Zero.nhds_fun Γ₀
{n : ℕ} {α : Fin (n + 1) → Type u} : Function.Injective2 Fin.Cons
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y z : v} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle (-x) y + o.oangle (-y) z + o.oangle (-z) x = ↑Real.Pi
{G : Type u_2} [Group G] {A B : G} : A = B → A / B = 1
{α : Type u} [Preorder α] {A B C : α} : A ≤ B → B < C → A < C
{v₁ : Type u_1} {v₂ : Type u_2} [NormedGroup v₁] [NormedGroup v₂] {F : NormedGroup_hom v₁ v₂} : ∥F∥ = 0 ↔ F = 0
{α : Type u} [AddCommGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] {A B C : α} : A - B < C → A < B + C
{S : Type u_2} [CommRing S] {K : Type u_4} [Field K] {F : Type u_6} [Field F] [Algebra K S] [Algebra K F] [Nontrivial S] (pB : power_Basis K S) (hF : Polynomial.Splits (Algebra_Map K F) (minpoly K pB.gen)) : ⇑(Algebra_Map K F) (⇑(Algebra.trace K S) pB.gen) = (Polynomial.Map (Algebra_Map K F) (minpoly K pB.gen)).roots.Sum
{m : Type u_1} [AddZeroClass m] (S : Add_Submonoid m) : S = ⊥ ∨ ∃ (x : m) (h : x ∈ S), x ≠ 0
{t : ℂ} {S1 S2 x : ℝ} (ht1 : S1 ≤ t.re) (ht2 : t.re ≤ S2) (hx : 0 < x) : ∥dGamma_integrand t x∥ ≤ dGamma_integrand_Real S1 x + dGamma_integrand_Real S2 x
{m : Type u_1} [MulOneClass m] (S : set m) {P : Π (x : m), x ∈ Submonoid.Closure S → Prop} (Hs : ∀ (x : m) (h : x ∈ S), P x _) (h1 : P 1 _) (HMul : ∀ (x : m) (hx : x ∈ Submonoid.Closure S) (y : m) (hy : y ∈ Submonoid.Closure S), P x hx → P y hy → P (x * y) _) {x : m} (hx : x ∈ Submonoid.Closure S) : P x hx
(R : Type u) [Ring R] [strong_RankCondition R] {ι : Type v} [Fintype ι] : Finite_dimensional.finrank R (ι →₀ R) = Fintype.Card ι
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x ⟶ Y} (h₀ : F = g) {C : CategoryTheory.Limits.Fork F g} (h : CategoryTheory.Limits.IsLimit C) : CategoryTheory.IsIso C.ι
{R : Type u} [Semiring R] [no_Zero_divisors R] {P₁ P₂ q₁ q₂ : Polynomial R} (hp₁ : P₁ ≠ 0) (hq₁ : q₁ ≠ 0) (hp₂ : P₂ ≠ 0) (hq₂ : q₂ ≠ 0) (h_Eq : P₁ * q₂ = P₂ * q₁) : ↑(P₁.Nat_degree) - ↑(q₁.Nat_degree) = ↑(P₂.Nat_degree) - ↑(q₂.Nat_degree)
{ι : Type v} (F : ι → Cardinal) (t : Cardinal) (W : ∀ (i : ι), (F i).Lift ≤ t) : (Cardinal.Sup F).Lift ≤ t
{α : Type u} [TopologicalSpace α] {x : α} {S : set α} : ClusterPt x (Filter.principal S) ↔ ∀ (U : set α), U ∈ nhds x → (U ∩ S).Nonempty
{α : Type u} {β : Type v} [DecidableEq β] [Fintype α] [Fintype β] (F : α → β) {n : ℕ} (hn : Fintype.Card α < Fintype.Card β * n) : ∃ (y : β), (Finset.Filter (λ (x : α), F x = y) Finset.Univ).Card < n
{ι : Type u} {β : ι → Type v} [Π (i : ι), has_Zero (β i)] : Function.Injective Coe_fn
{G : Type u_1} [Group G] [TopologicalSpace G] [nonarchimedean_Group G] {U : set (G × G)} (hU : U ∈ nhds 1) : ∃ (v : IsOpen_Subgroup G), ↑v ×ˢ ↑v ⊆ U
{m : Type u_1} [AddZeroClass m] {ι : sort u_2} (S : ι → Add_Submonoid m) {C : Π (x : m), (x ∈ ⨆ (i : ι), S i) → Prop} (hp : ∀ (i : ι) (x : m) (h : x ∈ S i), C x _) (h1 : C 0 _) (HMul : ∀ (x y : m) (hx : x ∈ ⨆ (i : ι), S i) (hy : y ∈ ⨆ (i : ι), S i), C x hx → C y hy → C (x + y) _) {x : m} (hx : x ∈ ⨆ (i : ι), S i) : C x hx
{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] {ι : Type u_3} {P : ι → Submodule R m} {m : m} : (m ∈ ⨆ (i : ι), P i) ↔ ∃ (S : Finset ι), m ∈ ⨆ (i : ι) (h : i ∈ S), P i
{m₀ : Type u_6} [Monoid_with_Zero m₀] {L : List m₀} (h : 0 ∈ L) : L.Prod = 0
{R : Type u_1} [CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_4} [DecidableEq ι] [Fintype ι] (e : Basis ι R m) (F : AlternatingMap R m R ι) : F = ⇑F ⇑e • e.det
{P : Type u_1} [SemilatticeInf P] {x y : P} {F : Order.Pfilter P} (hx : x ∈ F) (hy : y ∈ F) : x ⊓ y ∈ F
{m : Type u_1} [has_Mul m] (C : Con m) {x y : m} : ⇑C x y → ⇑C y x
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {S : set E} (S_conv : Convex ℝ S) (hne : (Interior S).Nonempty) {F : E → F} {F' : E → (E →L[ℝ] F)} {F'' : E →L[ℝ] E →L[ℝ] F} (hF : ∀ (x : E), x ∈ Interior S → HasFderivAt F (F' x) x) {x : E} (xs : x ∈ S) (hx : HasFderivWithinAt F' F'' (Interior S) x) (v W : E) : ⇑(⇑F'' v) W = ⇑(⇑F'' W) v
{α : Type u} {β : Type v} (F : α → β) (g : β → α) : set.bij_on g (Function.FixedPoints (F ∘ g)) (Function.FixedPoints (g ∘ F))
{R : Type u_1} {m : Type u_2} {m₂ : Type u_3} [TopologicalSpace m] [TopologicalSpace m₂] [Ring R] [AddCommGroup m] [topological_AddGroup m] [module R m] [AddCommGroup m₂] [module R m₂] (e : m ≃L[R] m₂) (F : m →L[R] m₂) : F.Inverse = (Ring.Inverse (↑(e.Symm).Comp F)).Comp ↑(e.Symm)
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (θ : Real.Angle) : (o.rotation θ).Symm = o.rotation (-θ)
{e : ℂ → ℂ} {e' : ℂ} {z : ℝ} (h : HasStrictDerivAt e e' ↑z) : HasStrictDerivAt (λ (x : ℝ), (e ↑x).re) e'.re z
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] : ContDiff 𝕜 ⊤ ⇑(Equiv.Prod_assoc E F G)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (F : E →L[𝕜] F) [CompleteSpace F] [CompleteSpace E] (surj : Function.Surjective ⇑F) : ∃ (C : ℝ) (h : C > 0), ∀ (y : F), ∃ (x : E), ⇑F x = y ∧ ∥x∥ ≤ C * ∥y∥
{R : Type u_4} {S : Type u_5} [non_unital_non_assoc_Semiring R] [non_unital_non_assoc_Semiring S] (F : R ≃+* S) : ⇑F 0 = 0
{n : ℕ} : Fin_Succ_Equiv' 0 = Fin_Succ_Equiv n
{R : Type u} [CommSemiring R] [Star_Ring R] (x : R) : ⇑(Star_Ring_end R) (⇑(Star_Ring_end R) x) = x
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (F : S.Localization_Map N) {g : m →* P} {t : Submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ t) {q : Type u_4} [CommMonoid q] {k : t.Localization_Map q} (z : N) : ⇑(k.to_Map) (⇑g ↑((F.sec z).Snd)) * ⇑(F.Map hy k) z = ⇑(k.to_Map) (⇑g (F.sec z).fst)
{C : Type u} [CategoryTheory.Category C] {x : C} {S R : CategoryTheory.Sieve x} (J : CategoryTheory.GrothendieckTopology C) (Hss : S ≤ R) (sjx : S ∈ ⇑J x) : R ∈ ⇑J x
{K : Type u} [Field K] (S : Subfield K) {l : List K} : (∀ (x : K), x ∈ l → x ∈ S) → l.Prod ∈ S
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {n : ℕ} {S1 S2 : Affine.Simplex k P n} (h : ∀ (i : Fin (n + 1)), S1.points i = S2.points i) : S1 = S2
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (E : intermediate_Field K L) [Finite_dimensional K ↥E] : IsClosed ↑(E.fixing_Subgroup)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P B : P) : ⇑(S.weighted_vsub_of_point (λ (_x : ι), P) B) W = S.Sum (λ (i : ι), W i) • (P -ᵥ B)
(k n : ℕ) : (List.Nat.antidiagonal_tuple k n).Nodup
{α : Type u_1} [LinearOrder α] {S : Finset α} {k : ℕ} (h : S.Card = k) (hz : 0 < k) : ⇑(S.order_emb_of_Fin h) ⟨0, hz⟩ = S.min' _
{α : Type u} [PseudoMetricSpace α] {S t : set α} (Fin : Emetric.Hausdorff_edist S t ≠ ⊤) : metric.Hausdorff_dist S t = 0 ↔ Closure S = Closure t
{α : Type u} : Function.Injective free_Group.of
{m₀ : Type u_1} [Mul_Zero_class m₀] [no_Zero_divisors m₀] {A B : m₀} : A * B = 0 ↔ B * A = 0
{α : Type u_1} [LinearOrder α] {A B : Finset α} (h : A ⊆ B) : A.to_colex ≤ B.to_colex
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [Linear_ordered_Ring α] [FloorRing α] [TopologicalSpace α] [OrderTopology α] [topological_AddGroup α] [TopologicalSpace β] [TopologicalSpace γ] {F : β → α → γ} (h : Continuous_on (Function.uncurry F) (set.Univ ×ˢ set.icc 0 1)) (hF : ∀ (S : β), F S 0 = F S 1) : Continuous (λ (st : β × α), F st.fst (Int.fract st.Snd))
{R : Type u_1} {S : Type u_2} [EuclideanDomain R] [CommRing S] [IsDomain S] [Algebra R S] {abv : AbsoluteValue R ℤ} {ι : Type u_5} [DecidableEq ι] [Fintype ι] (bS : Basis ι R S) (adm : abv._Admissible) [Infinite R] [DecidableEq R] (A : S) {B : R} (hb : B ≠ 0) : ∃ (q : S) (r : R) (h : r ∈ class_Group.Finset_approx bS adm), ⇑abv (⇑(Algebra.norm R) (r • A - B • q)) < ⇑abv (⇑(Algebra.norm R) (⇑(Algebra_Map R S) B))
{α : Type u_1} [Monoid α] {A B u : α} (hu : IsUnit u) : A * u ∣ B ↔ A ∣ B
{P : ℕ} (hp : 1 < P) : padic_norm P ↑P < 1
{R : Type u} {A' : Type u_1} {B' : Type u_2} [CommSemiring A'] [Semiring B'] [CommSemiring R] [Algebra R A'] [Algebra R B'] {F g : Polynomial A' →ₐ[R] B'} (h₁ : F.Comp (IsScalarTower.to_AlgHom R A' (Polynomial A')) = g.Comp (IsScalarTower.to_AlgHom R A' (Polynomial A'))) (h₂ : ⇑F Polynomial.x = ⇑g Polynomial.x) : F = g
{α : Type u} [SemilatticeSup α] {β : Type u_1} [Preorder β] {F g : α → β} (hF : Monotone F) (hg : Antitone g) (h : F ≤ g) (m n : α) : F m ≤ g n
{R : Type u_1} [CommRing R] {P : ℕ} (hp : Nat.Prime P) : Polynomial.cyclotomic P R = (Finset.Range P).Sum (λ (i : ℕ), Polynomial.x ^ i)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [cs : CompleteSpace E] {F : E → F} {F' : E ≃L[𝕜] F} {A : E} (hF : HasStrictFderivAt F ↑F' A) {g : F → E} (hg : ∀ᶠ (x : E) in nhds A, g (F x) = x) : HasStrictFderivAt g ↑(F'.Symm) (F A)
{C : Type u} [CategoryTheory.Category C] {P q : C} (F : P ⟶ q) [CategoryTheory.Mono F] [CategoryTheory.StrongEpi F] : CategoryTheory.IsIso F
{ι : Type u_1} {ι' : Type u_2} {R : Type u_5} {m : Type u_6} [CommSemiring R] [AddCommMonoid m] [module R m] (B : Basis ι R m) (B' : Basis ι' R m) {ι'' : Type u_3} [Fintype ι'] (B'' : ι'' → m) : (B.to_Matrix ⇑B').Mul (B'.to_Matrix B'') = B.to_Matrix B''
{G : Type u_1} [AddGroup G] {k : set G} {P : Π (x : G), x ∈ Add_Subgroup.Closure k → Prop} (Hs : ∀ (x : G) (h : x ∈ k), P x _) (h1 : P 0 _) (HMul : ∀ (x : G) (hx : x ∈ Add_Subgroup.Closure k) (y : G) (hy : y ∈ Add_Subgroup.Closure k), P x hx → P y hy → P (x + y) _) (Hinv : ∀ (x : G) (hx : x ∈ Add_Subgroup.Closure k), P x hx → P (-x) _) {x : G} (hx : x ∈ Add_Subgroup.Closure k) : P x hx
{ι : Type u_1} {v : Type u} [CategoryTheory.Category v] [CategoryTheory.Limits.HasZeroMorphisms v] {C : Complex_shape ι} (C : homological_Complex v C) {i i' j : ι} (rij : C.Rel i j) (rij' : C.Rel i' j) : CategoryTheory.Eq_to_hom _ ≫ C.D i' j = C.D i j
{K : Type u_1} [Linear_ordered_Field K] [FloorRing K] (v : K) (n : ℕ) : ∃ (q : ℚ), (GeneralizedContinuedFraction.of v).convergents n = ↑q
{ι : Type u} (S : Finset ι) (F g : ι → Ennreal) {P q : ℝ} (hpq : P.IsConjugateExponent q) : S.Sum (λ (i : ι), F i * g i) ≤ S.Sum (λ (i : ι), F i ^ P) ^ (1 / P) * S.Sum (λ (i : ι), g i ^ q) ^ (1 / q)
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {C : ℝ} {F : ℂ → E} {z : ℂ} (hD : Diff_Cont_on_cl ℂ F {z : ℂ | 0 < z.re}) (hexp : ∃ (C : ℝ) (h : C < 2) (B : ℝ), F =O[Filter.comap Complex.Abs Filter.at_top ⊓ Filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), Real.Exp (B * Complex.Abs z ^ C)) (hre : Filter.Tendsto (λ (x : ℝ), F ↑x) Filter.at_top (nhds 0)) (him : ∀ (x : ℝ), ∥F (↑x * Complex.i)∥ ≤ C) (hz : 0 ≤ z.re) : ∥F z∥ ≤ C
{R : Type u_1} {m : Type u_3} {A : R} [Monoid R] [MulAction R m] (n : ℕ) (ra : IsSmulRegular m A) : IsSmulRegular m (A ^ n)
{R : Type u₁} {L : Type u₂} [CommRing R] [lie_Ring L] [lie_Algebra R L] [IsNoetherian R L] : lie_Algebra.IsNilpotent R L ↔ ∀ (x : L), IsNilpotent (⇑(lie_Algebra.ad R L) x)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x : v} (hx : x ≠ 0) : hb.oangle (-x) x = ↑Real.Pi
(𝕜 : Type u_1) (E : Type u_2) [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {n : ℕ} (h : n = 1) (v : Fin n → E) : ⇑(FormalMultilinearSeries.Id 𝕜 E n) v = v ⟨0, _⟩
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} (h : ↑S.Nonempty) (v : v) : v ∈ S.direction ↔ ∃ (P1 : P) (h : P1 ∈ S) (P2 : P) (h : P2 ∈ S), v = P1 -ᵥ P2
{R : Type u_4} [NormedRing R] [CompleteSpace R] (x : R) (h : ∥x∥ < 1) : Summable (λ (n : ℕ), x ^ n)
{α : Type u_1} {β : Type u_2} [PseudoMetricSpace α] [PseudoMetricSpace β] {K : Nnreal} {F : α → β} : (∀ (x y : α), HasNndist.nndist x y ≤ K * HasNndist.nndist (F x) (F y)) → AntilipschitzWith K F
(R : Type u) [Semiring R] [Nontrivial R] (P q : ℕ) [Char_P R P] [ExpChar R q] : q = 1 ↔ P = 0
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S : set P} (hs : S.Nonempty) : affine_Span k S = ⊤ ↔ Vector_Span k S = ⊤
{α : Type u_1} {r : α → α → Prop} {C : set α} (hc : IsChain r C) : ∃ (m : set α), IsMax_chain r m ∧ C ⊆ m
{R : Type u} {ι : Type u'} {m₁ : ι → Type v₁} {m₂ : Type v₂} [DecidableEq ι] [CommSemiring R] [Π (i : ι), AddCommMonoid (m₁ i)] [AddCommMonoid m₂] [Π (i : ι), module R (m₁ i)] [module R m₂] (F : MultilinearMap R m₁ m₂) (C : ι → R) (m : Π (i : ι), m₁ i) (S : Finset ι) : ⇑F (S.piecewise (λ (i : ι), C i • m i) m) = S.Prod (λ (i : ι), C i) • ⇑F m
{E : Type u_1} [AddCommGroup E] [module ℝ E] {S : set E} (x : E) : 0 ≤ gauge S x
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type W} {x : C} {R : CategoryTheory.Presieve x} {x : CategoryTheory.Presieve.FamilyOfElements P R} (hx : x.compatible) : x.Sieve_extend.compatible
{α : Type u} [TopologicalSpace α] {S : set α} (h : IsClosed S) : Interior (Frontier S) = ∅
{R : Type u_1} [CommRing R] (S : Subring R) (m : Multiset R) : (∀ (A : R), A ∈ m → A ∈ S) → m.Prod ∈ S
{L : FirstOrder.Language} {m : Type u_3} [L.structure m] : FirstOrder.Language.structure.cg L m ↔ ∃ (S : set m), S.countable ∧ ⇑(FirstOrder.Language.Substructure.Closure L) S = ⊤
{S : ℂ} (hs : 1 < S.re) : MeasureTheory.IntegrableOn (λ (x : ℝ), ↑(Real.Exp (-x)) * ↑(Real.log x) * ↑x ^ (S - 1)) (set.ioi 0) MeasureTheory.MeasureSpace.Volume ∧ HasDerivAt Complex.gamma_integral (∫ (x : ℝ) in set.ioi 0, ↑(Real.Exp (-x)) * ↑(Real.log x) * ↑x ^ (S - 1)) S
{C : Type u} [CategoryTheory.Category C] {x Y Z : C} (F : x ⟶ Y) (g : x ⟶ Z) [CategoryTheory.Limits.HasPushout F g] : CategoryTheory.Limits.HasPushout g F
{α : Type u} {β : Type v} [EmetricSpace α] [PseudoEmetricSpace β] {F : α → β} (hF : Isometry F) : Embedding F
{m : Type u_3} {N : Type u_4} [Monoid m] [Monoid N] (F : m →* Nᵐᵒᵖ) (l : List m) : Mul_Opposite.Unop (⇑F l.Prod) = (List.Map (Mul_Opposite.Unop ∘ ⇑F) l).reverse.Prod
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [CompleteSpace E] [CompleteSpace F] (A : E →L[𝕜] F) (x : E) (y : F) : HasInner.inner x (⇑(⇑Continuous_LinearMap.Adjoint A) y) = HasInner.inner (⇑A x) y
{R : Type u_2} {Γ₀ : Type u_3} [CommRing R] [Linear_ordered_CommMonoid_with_Zero Γ₀] (v : Valuation R Γ₀) {J : Ideal R} (hJ : J ≤ v.supp) : (v.on_quot hJ).supp = Ideal.Map (Ideal.Quotient.Mk J) v.supp
{α : Type u_1} [LinearOrder α] {k l : ℕ} {S : Finset α} {i : Fin k} {j : Fin l} {h : S.Card = k} {h' : S.Card = l} : ⇑(S.order_emb_of_Fin h) i = ⇑(S.order_emb_of_Fin h') j ↔ ↑i = ↑j
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {x : E} {n : WithTop ℕ} {S : set E} {F : E → F} {g : E → G} (hF : ContDiff_within_at 𝕜 n F S x) (hg : ContDiff_within_at 𝕜 n g S x) : ContDiff_within_at 𝕜 n (λ (x : E), (F x, g x)) S x
 : (Submodule.Span ℂ (set.Range fourier)).topological_Closure = ⊤
{α : Type u} {β : Type v} [Linear_ordered_Field α] [TopologicalSpace α] [OrderTopology α] {l : Filter β} {F g : β → α} {C : α} (hC : 0 < C) (hF : Filter.Tendsto F l (nhds C)) (hg : Filter.Tendsto g l Filter.at_IsBot) : Filter.Tendsto (λ (x : β), F x * g x) l Filter.at_IsBot
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.has_Finite_products C] : CategoryTheory.Limits.has_Finite_biproducts C
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m →+ P} (hg : ∀ (y : ↥S), IsAddUnit (⇑g ↑y)) (z : N) (W v : P) : ⇑(F.Lift hg) z + W = v ↔ ⇑g (F.sec z).fst + W = ⇑g ↑((F.sec z).Snd) + v
{R : Type u_1} {m : Type u_3} {A B : R} [HasScalar R m] [has_Mul R] [IsScalarTower R R m] : IsSmulRegular m (A * B) ∧ IsSmulRegular m (B * A) ↔ IsSmulRegular m A ∧ IsSmulRegular m B
{D : set ℝ} (hD : Convex ℝ D) {F : ℝ → ℝ} (hF : Continuous_on F D) (hF' : DifferentiableOn ℝ F (Interior D)) (hF'' : ∀ (x : ℝ), x ∈ Interior D → deriv^[2] F x < 0) : strict_ConcaveOn ℝ D F
{α : Type u_1} {m : Type u_3} {n : Type u_4} [NonUnitalSemiring α] [Star_Ring α] {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α} {D : Matrix n n α} (hA : A._hermitian) (hBC : B.Conj_transpose = C) (hD : D._hermitian) : (Matrix.from_blocks A B C D)._hermitian
(K : Type u) {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] {v₂ : Type v'} [AddCommGroup v₂] [module K v₂] (F : v →ₗ[K] v₂) (P : Submodule K v) [Finite_dimensional K ↥P] : Finite_dimensional.finrank K ↥(Submodule.Map F P) ≤ Finite_dimensional.finrank K ↥P
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] {P1 P2 P : P} : P -ᵥ P1 = P -ᵥ P2 ↔ P1 = P2
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (x y : m ⧸ S) : ∥x + y∥ ≤ ∥x∥ + ∥y∥
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D ⥤ C} [CategoryTheory.IsRightAdjoint i] (A : C) [CategoryTheory.IsIso ((CategoryTheory.adjunction.of_Right_Adjoint i).Unit.App A)] : A ∈ i.EssImage
{α : Type u} [SemilatticeInf α] [OrderTop α] (x y : α) : (x ⨯ y) = x ⊓ y
{α : Type u_1} (L : List (List α)) (C : Composition L.Join.length) (h : List.Map List.length L = C.blocks) : L.Join.split_wrt_Composition C = L
{α : Type u_1} {n : Type u_4} {R : Type u_5} [HasSub n] [HasScalar R α] (k : R) (v : n → α) : Matrix.circulant (k • v) = k • Matrix.circulant v
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} (v : v) {P : P} (hp : P ∈ S) : v +ᵥ P ∈ S ↔ v ∈ S.direction
(R : Type u_1) {S : Type u_2} {m : Type u_3} [Semiring R] [Semiring S] [AddCommMonoid m] [HasScalar R S] [module S m] [module R m] [IsScalarTower R S m] (h : IsNoetherian R m) : IsNoetherian S m
{J : Type u₁} [CategoryTheory.Category J] [Nonempty J] (h : ∀ (j₁ j₂ : J), ∃ (l : List J), List.chain CategoryTheory.Zag j₁ l ∧ (j₁ :: l).Last _ = j₂) : CategoryTheory.IsConnected J
{𝕜 : Type u_1} {x : Type u_2} [_R_or_C 𝕜] [TopologicalSpace x] [CompactSpace x] (A : Subalgebra 𝕜 C(x, 𝕜)) (hA : A.separates_points) (hA' : Continuous_Map.Conj_invariant_Subalgebra (Subalgebra.Restrict_scalars ℝ A)) : A.topological_Closure = ⊤
{α : Type u_1} [UniformSpace α] {S : set α} : IsOpen S ↔ ∀ (x : α), x ∈ S → (∃ (v : set (α × α)) (h : v ∈ Uniformity α), UniformSpace.ball x v ⊆ S)
{𝕜 : Type u_3} [Field 𝕜] (n : Type) [Fintype n] [DecidableEq n] (m : Matrix n n 𝕜) : ∃ (L L' : List (Matrix.TransvectionStruct n 𝕜)) (D : n → 𝕜), ((List.Map Matrix.TransvectionStruct.to_Matrix L).Prod.Mul m).Mul (List.Map Matrix.TransvectionStruct.to_Matrix L').Prod = Matrix.Diagonal D
{k : Type u_1} {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [CharZero k] {n : ℕ} (S : Affine.Simplex k P n) {fs₁ fs₂ : Finset (Fin (n + 1))} {m₁ m₂ : ℕ} (h₁ : fs₁.Card = m₁ + 1) (h₂ : fs₂.Card = m₂ + 1) : Finset.centroid k Finset.Univ (S.face h₁).points = Finset.centroid k Finset.Univ (S.face h₂).points ↔ fs₁ = fs₂
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {C : Con m} {F : m →* P} (h : C ≤ Con.Ker F) : (C.Lift F h).mrange = F.mrange
{α : Type u} [PseudoMetricSpace α] (S : set α) : uniform_Continuous (λ (x : α), metric.Inf_dist x S)
{R : Type u_1} (S : Type u_2) [CommRing R] [CommRing S] (y : R) [Algebra R S] [IsLocalization.Away y S] [h : Ideal._jacobson R] (J : Ideal S) : J.IsMaximal ↔ (Ideal.comap (Algebra_Map R S) J).IsMaximal ∧ y ∉ Ideal.comap (Algebra_Map R S) J
{x₁ x₂ Y : top} {F : C(↥x₁, ↥Y)} {g : C(↥x₂, ↥Y)} {x₀ x₁ : ↥x₁} {x₂ x₃ : ↥x₂} {P : Path x₀ x₁} {q : Path x₂ x₃} (hfg : ∀ (t : ↥Unit_Interval), ⇑F (⇑P t) = ⇑g (⇑q t)) : (FundamentalGroupoid.FundamentalGroupoid_Functor.Map F).Map ⟦P⟧ == (FundamentalGroupoid.FundamentalGroupoid_Functor.Map g).Map ⟦q⟧
{α : Type u_1} {C : set (set α)} (h : ∀ (A : α), ∃! (B : set α) (h : B ∈ C), A ∈ B) {S : set α} {y : α} (hs : S ∈ C) (hy : y ∈ S) : S = {x : α | (Setoid.Mk_Classes C h).Rel x y}
{F : Type u_1} [NormedGroup F] [NormedSpace ℝ F] (F : ℝ → F) {K : set F} (hK : IsComplete K) : Measurable_set {x : ℝ | Differentiable_within_at ℝ F (set.ici x) x ∧ deriv_within F (set.ici x) x ∈ K}
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasPullbacks C] {x Y : C} (g : x ⟶ Y) (F₁ F₂ : CategoryTheory.Subobject Y) : (CategoryTheory.Subobject.pullback g).obj (F₁ ⊓ F₂) = (CategoryTheory.Subobject.pullback g).obj F₁ ⊓ (CategoryTheory.Subobject.pullback g).obj F₂
{β : Type u} {γ : Type W} [Semiring β] [Semiring γ] (F : β →+* γᵐᵒᵖ) (l : List β) : Mul_Opposite.Unop (⇑F l.Prod) = (List.Map (Mul_Opposite.Unop ∘ ⇑F) l).reverse.Prod
{o : Ordinal} : Ordinal.principal has_Mul.Mul o ↔ o ≤ 2 ∨ ∃ (A : Ordinal), o = Ordinal.omega ^ Ordinal.omega ^ A
{v : Type u} (G : SimpleGraph v) [Fintype v] [Decidable_Rel G.Adj] (v : v) : G.degree v ≤ G.max_degree
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (h : B.Orientation = o) (θ : ℝ) : o.rotation ↑θ = hb.rotation ↑θ
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) (m : Multiset L) : (∀ (A : L), A ∈ m → A ∈ S) → m.Prod ∈ S
{R : Type u} [CommRing R] [IsDomain R] [Unique_factorization_Monoid R] (h₁ : ∃ (P : R), Irreducible P) (h₂ : ∀ ⦃P q : R⦄, Irreducible P → Irreducible q → Associated P q) : discrete_Valuation_Ring R
{α : Type u} {β : Type v} {fa : α → α} {fb : β → β} {g : α → β} (h : Function.Semiconj g fa fb) : set.maps_to g (Function.FixedPoints fa) (Function.FixedPoints fb)
(R : Type u) [CommRing R] [IsDomain R] [discrete_Valuation_Ring R] : ∃ (ϖ : R), Irreducible ϖ
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LE.LE] {A B : α} (ha : 1 ≤ A) (hb : 1 ≤ B) : 1 ≤ A * B
{α : Type u_1} [TopologicalSpace α] [t0_Space α] [CompactSpace α] {S : set α} (hS : IsClosed S) (hne : S.Nonempty) : ∃ (x : α), x ∈ S ∧ IsClosed {x}
(N : ℕ) {j : ℝ} (hj : 0 < j) {C : ℝ} (hc : 1 < C) : (Finset.Filter (λ (i : ℕ), j < ↑⌊C ^ i⌋₊) (Finset.Range N)).Sum (λ (i : ℕ), 1 / ↑⌊C ^ i⌋₊ ^ 2) ≤ C ^ 5 * (C - 1)⁻¹ ^ 3 / j ^ 2
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {ι : Type u_1} (v : ι → m) (i : LinearIndependent R v) (W : set m) [Fintype ↥W] (S : Submodule.Span R W = ⊤) : Cardinal.Mk ι ≤ ↑(Fintype.Card ↥W)
{α : Type u} [Group α] [has_LE α] [CovariantClass α α has_Mul.Mul has_LE.LE] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LE.LE] {A B : α} : A⁻¹ ≤ B → B⁻¹ ≤ A
{ι : Type u} (S : Finset ι) {F g : ι → ℝ} {P q : ℝ} (hpq : P.IsConjugateExponent q) (hF : ∀ (i : ι), i ∈ S → 0 ≤ F i) (hg : ∀ (i : ι), i ∈ S → 0 ≤ g i) : S.Sum (λ (i : ι), F i * g i) ≤ S.Sum (λ (i : ι), F i ^ P) ^ (1 / P) * S.Sum (λ (i : ι), g i ^ q) ^ (1 / q)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (P : P) : Vector_Span k {P} = ⊥
{α : Type u} {A B : α} [MulZeroOneClass α] [PartialOrder α] [ZeroLt.PosMulMono α] (ha : A ≤ 1) (hb : B ≤ 1) (A0 : 0 ≤ A) : A * B ≤ 1
{α : Type u_1} {β : Type u_2} [AddCommMonoid α] [TopologicalSpace α] {F : β → α} {S : Finset β} (hF : ∀ (B : β), B ∉ S → F B = 0) : has_Sum F (S.Sum (λ (B : β), F B))
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {x : E} {n : WithTop ℕ} {P : E → FormalMultilinearSeries 𝕜 E F} (h : HasFtaylorSeriesUpToOn n F P S) (hn : 1 ≤ n) (hx : S ∈ nhds x) : Differentiable_at 𝕜 F x
{α : Type u_1} {n : Type u_4} [Semiring α] [Fintype n] [AddGroup n] (v W : n → α) : (Matrix.circulant v).Mul (Matrix.circulant W) = Matrix.circulant ((Matrix.circulant v).Mul_vec W)
{m : Type u_1} [AddCommMonoid m] {S : Add_Submonoid m} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (F : S.Localization_Map N) {g : m →+ P} (hg : ∀ (y : ↥S), IsAddUnit (⇑g ↑y)) (z : N) (v : P) : ⇑(F.Lift hg) z = v ↔ ⇑g (F.sec z).fst = ⇑g ↑((F.sec z).Snd) + v
{m : Type u_1} [semi_NormedGroup m] {S : Add_Subgroup m} (x : m ⧸ S) : ∥-x∥ = ∥x∥
{α : Type u_1} {β : Type u_2} [AddZeroClass α] [AddZeroClass β] (F g : αᵐᵒᵖ →+ β) (h : F.Comp Mul_Opposite.Op_Add_Equiv.to_AddMonoid_hom = g.Comp Mul_Opposite.Op_Add_Equiv.to_AddMonoid_hom) : F = g
{α : Type u} {β : Type v} [TopologicalSpace α] [PseudoMetricSpace β] : Continuous (λ (P : bounded_Continuous_Function α β × α), ⇑(P.fst) P.Snd)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] {u v : E} (hv : v ∈ K) (hvo : u - v ∈ Kᗮ) : ↑(⇑(Orthogonal_projection K) u) = v
{ι : Type u_1} {R : Type u_3} {m : Type u_5} {m' : Type u_6} {v : ι → m} [Semiring R] [AddCommMonoid m] [AddCommMonoid m'] [module R m] [module R m'] (hv : LinearIndependent R v) (F : m →ₗ[R] m') (hF_inj : F.Ker = ⊥) : LinearIndependent R (⇑F ∘ v)
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) : _R_or_C.Abs (HasInner.inner x y) ≤ ∥x∥ * ∥y∥
{ι : Type u_1} {S : Type u_3} {R : Type u_4} [DecidableEq ι] [AddMonoid ι] [CommSemiring S] [Semiring R] [Algebra S R] (A : ι → Submodule S R) [set_like.graded_Monoid A] : (⨆ (i : ι), A i) = (direct_Sum.Coe_AlgHom A).Range.to_Submodule
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : ∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * ⇑_R_or_C.re (HasInner.inner x y) + ∥y∥ ^ 2
{R : Type u} [Semiring R] {ι : Type v} [decι : DecidableEq ι] {m : Type u_1} [AddCommMonoid m] [module R m] {A : ι → Submodule R m} {i j : ι} (hij : i ≠ j) (h : set.Univ = {i, j}) (hi : direct_Sum._internal A) : _IsCompl (A i) (A j)
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x ⟶ Y} [CategoryTheory.Limits.HasCoequalizer F g] (h : F = g) : CategoryTheory.IsIso (CategoryTheory.Limits.coequalizerπ F g)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (ha : Continuous_at F A) (hb : Continuous_at F B) : fderiv ℝ (λ (P : ℝ × ℝ), ∫ (x : ℝ) in P.fst..P.Snd, F x) (A, B) = (Continuous_Linear_Map.Snd ℝ ℝ ℝ).Smul_Right (F B) - (Continuous_Linear_Map.fst ℝ ℝ ℝ).Smul_Right (F A)
(A : ℝ) {B : ℝ} (h : 0 < B) : MeasureTheory.IntegrableOn (λ (x : ℝ), Real.Exp (-B * x)) (set.ioi A) MeasureTheory.MeasureSpace.Volume
{K : Type u_1} [Field K] (n : ℕ) : Polynomial.Splits (Ring_hom.Id K) (Polynomial.cyclotomic' n K)
{C : Type u₁} [CategoryTheory.Category C] {x Y : C} {R : CategoryTheory.Presieve x} (F : Y ⟶ x) [CategoryTheory.SplitEpi F] (hF : R F) : CategoryTheory.Sieve.generate R = ⊤
{α : Type u_1} {ι' : sort u_5} (S : ι' → set α) : (⋂ (i : ι'), S i) = ⋂ (t : Finset (plift ι')) (i : plift ι') (h : i ∈ t), S i.down
{α : Type u_1} {n : ℕ} (v : Vector α n) : Vector.Map Id v = v
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] (hfp : Algebra.Finite_presentation R A) (ι : Type u_3) [Fintype ι] : Algebra.Finite_presentation R (mv_Polynomial ι A)
{α : Type u} (S : set α) [h : Fintype ↥S] : S.Finite
(P : ℕ) [P_Prime : Fact (Nat.Prime P)] {q : ℚ} {n D : ℤ} (hqz : q ≠ 0) (qdf : q = Rat.Mk n D) : padic_val_rat P q = ↑((multiplicity ↑P n).get _) - ↑((multiplicity ↑P D).get _)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {x : top} (F : top.Presheaf C x) (U : TopologicalSpace.Opens ↥x) (R : CategoryTheory.Presieve U) (F : Σ (v : TopologicalSpace.Opens ↥x), {F // R F}) : (top.Presheaf.covering_of_Presieve.FirstObj_iso_Pi_Opens F U R).hom ≫ CategoryTheory.Limits.Pi.π (λ (i : Σ (v : TopologicalSpace.Opens ↥x), {F // R F}), F.obj (Opposite.Op (top.Presheaf.covering_of_Presieve U R i))) F = CategoryTheory.Limits.Pi.π (λ (F : Σ (v : TopologicalSpace.Opens ↥x), {F // R F}), F.obj (Opposite.Op F.fst)) F
{G : Type u_1} [Group G] [hG : Group.IsNilpotent G] : Nat.Find _ = Group.nilpotency_class G
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : E → ℝ} {A : E} {F' : E →L[ℝ] ℝ} {S : set E} (h : IsLocalMinOn F S A) (hF : HasFderivWithinAt F F' S A) {y : E} (hy : y ∈ Pos_TangentConeAt S A) (hy' : -y ∈ Pos_TangentConeAt S A) : ⇑F' y = 0
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + 2 * HasInner.inner x y + ∥y∥ * ∥y∥
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {y : L} : y ∈ S → ∀ {x : K}, x • y ∈ S
(J : Type u_1) (C : Type u_2) [CategoryTheory.Category J] [CategoryTheory.Category C] : CategoryTheory.Idempotents.to_Karoubi (J ⥤ C) ⋙ CategoryTheory.Idempotents.Karoubi_Functor_Category_Embedding J C = (CategoryTheory.whiskering_Right J C (CategoryTheory.Idempotents.Karoubi C)).obj (CategoryTheory.Idempotents.to_Karoubi C)
{α : Type u_1} [CommSemiring α] (t : Tree α) (r : tactic_.Ring2.CsringExpr) : (tactic_.Ring2.HornerExpr.of_csexpr r)._cs ∧ tactic_.Ring2.HornerExpr.cseval t (tactic_.Ring2.HornerExpr.of_csexpr r) = tactic_.Ring2.CsringExpr.Eval t r
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W₁ W₂ : ι → k) (P : ι → P) : ⇑(S.weighted_vsub P) W₁ +ᵥ ⇑(S.affine_combination P) W₂ = ⇑(S.affine_combination P) (W₁ + W₂)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {P1 P2 : P} (hp1 : P1 ∈ S) : (affine_Span k (HasInsert.Insert P2 ↑S)).direction = Submodule.Span k {P2 -ᵥ P1} ⊔ S.direction
{α : Type u} {β : Type v} [Linear_ordered_Field α] [TopologicalSpace α] [OrderTopology α] {l : Filter β} {F g : β → α} {C : α} (hC : C < 0) (hF : Filter.Tendsto F l (nhds C)) (hg : Filter.Tendsto g l Filter.at_IsBot) : Filter.Tendsto (λ (x : β), F x * g x) l Filter.at_top
{S : set ℂ} : S.countable → (Complex.Exp ⁻¹' S).countable
{α : Type u_1} {n : Type u_4} [has_Zero α] [DecidableEq n] (A : Matrix n n α) : A.IsDiag ↔ Matrix.Diagonal A.diag = A
{α : Type u_1} {E : α → Type u_2} {P : Ennreal} [Π (i : α), NormedGroup (E i)] {ι : Type u_3} {l : Filter ι} [l.Ne_IsBot] [Fact (1 ≤ P)] {C : ℝ} {F : ι → ↥(Lp E P)} (hCF : ∀ᶠ (k : ι) in l, ∥F k∥ ≤ C) {F : ↥(Lp E P)} (hF : Filter.Tendsto (Id (λ (i : ι), ⇑(F i))) l (nhds ⇑F)) : ∥F∥ ≤ C
{m : Type u_3} {N : Type u_4} [AddZeroClass m] [AddZeroClass N] (F : m →+ N) : ⇑F 0 = 0
{E : Type u_1} [InnerProductSpace ℝ E] {n : ℕ} [Fact (Finite_dimensional.finrank ℝ E = n + 1)] : Cont_mdiff (model_with_corners_self ℝ (EuclideanSpace ℝ (Fin n))) (model_with_corners_self ℝ (EuclideanSpace ℝ (Fin n))) ⊤ (λ (x : ↥(Metric.Sphere 0 1)), -x)
{m : Type u_1} [Monoid m] {S : set m} (hs : _Submonoid S) {l : List m} : (∀ (x : m), x ∈ l → x ∈ S) → l.Prod ∈ S
{G : Type u_7} [AddGroup G] (L : List G) : L.reverse.Sum = -(List.Map (λ (x : G), -x) L).Sum
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {F : 𝕜 → F} : iterated_deriv (n + 1) F = deriv (iterated_deriv n F)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [AddCommMonoid α] [TopologicalSpace α] [t2_Space α] [Encodable γ] [CompleteLattice β] (m : β → α) (m0 : m ⊥ = 0) (S : γ → β) : ∑' (i : ℕ), m (⨆ (B : γ) (h : B ∈ Encodable.decode₂ γ i), S B) = ∑' (B : γ), m (S B)
{α : Type u} {β : Type v} [Group α] [Group β] {F : α → β} (hF : _Group_hom F) : F 1 = 1
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {P : E → FormalMultilinearSeries 𝕜 E F} {n : ℕ} : HasFtaylorSeriesUpToOn ↑(n + 1) F P S ↔ (∀ (x : E), x ∈ S → (P x 0).uncurry0 = F x) ∧ (∀ (x : E), x ∈ S → HasFderivWithinAt (λ (y : E), P y 0) (P x 1).Curry_Left S x) ∧ HasFtaylorSeriesUpToOn ↑n (λ (x : E), ⇑(Continuous_multilinear_Curry_Fin1 𝕜 E F) (P x 1)) (λ (x : E), (P x).shift) S
{α : Type u} [Subsingleton α] (l : Filter α) [l.Ne_IsBot] : l = ⊤
(t : ℝ) : Filter.Tendsto (λ (x : ℝ), x * Real.log (1 + t / x)) Filter.at_top (nhds t)
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {F : α → β × γ} (hF : Continuous F) : Continuous (λ (A : α), (F A).Snd)
{α : Type u} [AddGroup α] [has_LE α] [CovariantClass α α has_Add.Add has_LE.LE] {A : α} : -A ≤ 0 → 0 ≤ A
{G : Type u_1} [Group G] {x y : G} : y ∈ Subgroup.Closure {x} ↔ ∃ (n : ℤ), x ^ n = y
{α : Type u_1} (r : α → α → Prop) : EqvGen.Setoid r = HasInf.Inf {S : Setoid α | ∀ ⦃x y : α⦄, r x y → S.Rel x y}
{G : Type u_1} [AddGroup G] (K : Add_Subgroup G) {l : List G} : (∀ (x : G), x ∈ l → x ∈ K) → l.Sum ∈ K
{α : Type u_1} [cancel_CommMonoid_with_Zero α] [wf_Dvd_Monoid α] [Gcd_Monoid α] : Unique_factorization_Monoid α
(C : Type u) [CategoryTheory.Category C] : CategoryTheory.EssentiallySmall C ↔ Small (CategoryTheory.Skeleton C) ∧ CategoryTheory.locally_Small C
{A B C : ℤ} (h1 : A % B = C) (h2 : (A - C).Nat_Abs < B.Nat_Abs) : A = C
{R : Type u_1} [Semiring R] [Nontrivial R] : PowerSeries.x.order = 1
{m : Type u_2} [AddCommGroup m] {A : Type u_1} [CommRing A] [module A m] (F : m ≃ₗ[A] m) : ⇑LinearMap.det ↑(F.Symm) * ⇑LinearMap.det ↑F = 1
{n : ℕ} {i : Fin (n + 1)} : SimplexCategoryδ (⇑Fin.cast_Succ i) ≫ SimplexCategoryσ i = 𝟙 (SimplexCategory.Mk n)
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type W} (J : CategoryTheory.GrothendieckTopology C) {P' : Cᵒᵖ ⥤ Type W} (i : P ≅ P') (h : CategoryTheory.Presieve._sheaf J P) : CategoryTheory.Presieve._sheaf J P'
{t : Type u} [CategoryTheory.Category t] (i : CategoryTheory.Arrow t) {x Y : t} (P : x ≅ Y) (sq : i ⟶ CategoryTheory.Arrow.Mk P.hom) : i.hom ≫ sq.Right ≫ P.Inv = sq.Left
{n : ℕ} {A : Cardinal} (h : n ≠ 0) : n • A < Cardinal.aleph0 ↔ A < Cardinal.aleph0
{α : Type u} {β : Type v} [TopologicalSpace α] {F g : α → β} {A : α} (h : F =ᶠ[nhds A] g) : ∀ᶠ (y : α) in nhds A, F =ᶠ[nhds y] g
(x : Type u) (Y : Type v) [MetricSpace x] [CompactSpace x] [Nonempty x] [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : Isometry (GromovHausdorff.optimal_GH_injl x Y)
{α : Type u_2} {ι : Type u_5} [AddCommMonoid α] (t : Finset ι) (F : ι → set α) (g : ι → α) (hg : ∀ (i : ι), i ∈ t → g i ∈ F i) : t.Sum (λ (i : ι), g i) ∈ t.Sum (λ (i : ι), F i)
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] {A B C : α} : A + B < C → B < -A + C
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] {F : E → F} {S : set E} {z W : E} (hD : Diff_Cont_on_cl ℂ F S) (hz : IsMaxOn (HasNorm.norm ∘ F) S z) (HSub : Metric.Ball z (HasDist.dist W z) ⊆ S) : ∥F W∥ = ∥F z∥
{ι : Type u_1} {R : Type u_3} {K : Type u_4} {m : Type u_5} {v : ι → m} [Semiring R] [AddCommMonoid m] [module R m] [Semiring K] [SmulWithZero R K] [module K m] [IsScalarTower R K m] (hinj : Function.Injective (λ (r : R), r • 1)) (li : LinearIndependent K v) : LinearIndependent R v
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [HasScalar 𝕜 E] {x : E} {S : set E} : Star_Convex 𝕜 x S ↔ ∀ ⦃A B : 𝕜⦄, 0 ≤ A → 0 ≤ B → A + B = 1 → A • {x} + B • S ⊆ S
{E : Type u_1} {F : Type u_2} [InnerProductSpace ℝ E] [InnerProductSpace ℝ F] {F : E → F} {x : E} : ConformalAt F x ↔ ∃ (C : ℝ), 0 < C ∧ ∀ (u v : E), HasInner.inner (⇑(fderiv ℝ F x) u) (⇑(fderiv ℝ F x) v) = C * HasInner.inner u v
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] (F F' : ℝ → E) {A B : ℝ} (hle : A ≤ B) {S : set ℝ} (hs : S.countable) (Hc : Continuous_on F (set.icc A B)) (hD : ∀ (x : ℝ), x ∈ set.Ioo A B  S → HasDerivAt F (F' x) x) (Hi : IntervalIntegrable F' MeasureTheory.MeasureSpace.Volume A B) : ∫ (x : ℝ) in A..B, F' x = F B - F A
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} : InnerProductGeometry.angle x y = Real.Pi ↔ x ≠ 0 ∧ ∃ (r : ℝ), r < 0 ∧ y = r • x
{C : Type u₁} [CategoryTheory.Category C] {t : CategoryTheory.Monad C} {J : Type u} [CategoryTheory.Category J] {D : J ⥤ t.Algebra} (C : CategoryTheory.Limits.Cocone (D ⋙ t.Forget)) (t : CategoryTheory.Limits.IsColimit C) [CategoryTheory.Limits.PreservesColimit (D ⋙ t.Forget) ↑t] (j : J) : ↑t.Map (C.ι.App j) ≫ CategoryTheory.Monad.Forget_creates_colimits.lambda C t = (D.obj j).A ≫ C.ι.App j
{R : Type u_1} [CommRing R] (m : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization m S] (A : S) : ∃ (B : ↥m), IsLocalization._integer R (A * ⇑(Algebra_Map R S) ↑B)
{α : Type u_1} [circular_Preorder α] {A B C : α} : HasBtw.Btw A B C ↔ HasBtw.Btw C A B
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) : Function.Surjective ⇑(S.normed_Mk)
{n : ℕ} : order_of (dihedral_Group.r 1) = n
{α : Type u_1} {β : Type u_2} [Nontrivial β] {F : α → β} (hF : Function.Surjective F) : Nontrivial α
{α : Type u_1} [cancel_CommMonoid_with_Zero α] [Gcd_Monoid α] {m n k : α} (h : k ∣ m * n) : ∃ (D₁ : α) (hD₁ : D₁ ∣ m) (D₂ : α) (hD₂ : D₂ ∣ n), k = D₁ * D₂
{α : Type u} [TopologicalSpace α] {S : set α} : Dense S → Dense (Closure S)
{α : Type u_1} (S : Finset α) : S.powerset.Card = 2 ^ S.Card
{𝕂 : Type u_1} {𝔸 : Type u_2} [nondiscrete_NormedField 𝕂] [normed_CommRing 𝔸] [normed_Algebra 𝕂 𝔸] [CompleteSpace 𝔸] [CharZero 𝕂] {x : 𝔸} (hx : x ∈ Emetric.Ball 0 (Exp_series 𝕂 𝔸).radius) : HasStrictFderivAt (Exp 𝕂) (Exp 𝕂 x • 1) x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {x Y : C} (F : x ⟶ Y) [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasKernel F] [CategoryTheory.Mono F] : CategoryTheory.Limits.Kernelι F = 0
{α : Type u_1} [Monoid α] {A u : α} (hu : IsUnit u) : u ∣ A
{α : Type u_1} {δ : Type u_5} [TopologicalSpace α] [MeasurableSpace α] [BorelSpace α] [MeasurableSpace δ] [complete_LinearOrder α] [OrderTopology α] [TopologicalSpace.SecondCountableTopology α] {ι : Type u_2} {ι' : Type u_3} {F : ι → δ → α} {u : Filter ι} (hF : ∀ (i : ι), Measurable (F i)) {P : ι' → Prop} {S : ι' → set ι} (hu : u.has_countable_Basis P S) (hs : ∀ (i : ι'), (S i).countable) : Measurable (λ (x : δ), u.limsup (λ (i : ι), F i x))
(S : set ℕ+) (K : Type W) (L : Type z) [Field K] [Field L] [Algebra K L] [h : number_Field K] [Fintype ↥S] [IsCyclotomicExtension S K L] : number_Field L
{R : Type u_1} {A : Type u_2} [CommSemiring R] [CommSemiring A] [Algebra R A] (S t : Subalgebra R A) : S.to_Submodule * t.to_Submodule = (S ⊔ t).to_Submodule
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {x : m} [NoZeroSmulDivisors R m] (h : SameRay R x (-x)) : x = 0
{n : ℕ} {α : Type u_1} [Preorder α] {F : Fin (n + 1) → α} : Antitone F ↔ ∀ (i : Fin n), F i.Succ ≤ F (⇑Fin.cast_Succ i)
(m : Type u_1) [Monoid_with_Zero m] : IsSquare 0
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (h : module.rank K v < Cardinal.aleph0) : (Basis.of_Vector_Space_Index K v).Finite
{R : Type u_1} {A : R} [Monoid R] {n : ℕ} (n0 : 0 < n) : IsRegular (A ^ n) ↔ IsRegular A
{C : Type u₁} [CategoryTheory.Category C] {A : C} [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Mono (CategoryTheory.Limits.terminal.from A)] : CategoryTheory.IsSubterminal A
{x : top} {t : ↥x → Type v} (P : top.LocalPredicate t) (x : ↥x) (W : ∀ (t : t x), ∃ (U : TopologicalSpace.IsOpen_nhds x) (F : Π (y : ↥(U.val)), t ↑y) (h : P.to_prelocal_predicate.Pred F), F ⟨x, _⟩ = t) : Function.Surjective (top.stalk_to_fiber P x)
{ι : Type u_1} {α : ι → Type u_2} [Fintype ι] [DecidableEq ι] [Π (i : ι), DecidableEq (α i)] (r : Π (i : ι), α i → Finset (α i) → Prop) (h_ex : ∀ (i : ι) (S : Finset (α i)), S.Nonempty → (∃ (x : α i) (h : x ∈ S), r i x (S.erase x))) {P : (Π (i : ι), Finset (α i)) → Prop} (F : Π (i : ι), Finset (α i)) (h0 : P (λ (_x : ι), ∅)) (step : ∀ (g : Π (i : ι), Finset (α i)) (i : ι) (x : α i), r i x (g i) → P g → P (Function.update g i (HasInsert.Insert x (g i)))) : P F
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : E → ℝ} {A : E} {F' : E →L[ℝ] ℝ} {S : set E} (h : IsLocalMaxOn F S A) (hF : HasFderivWithinAt F F' S A) {y : E} (hy : y ∈ Pos_TangentConeAt S A) : ⇑F' y ≤ 0
{J : Type u₁} [CategoryTheory.Category J] [Nonempty J] (h : ∀ {α : Type u₁} (F : J ⥤ CategoryTheory.Discrete α) (j j' : J), F.obj j = F.obj j') : CategoryTheory.IsConnected J
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {A B : C} (F : A ⟶ B) (F : C ⥤ D) [CategoryTheory.IsIso (F.Map F)] [CategoryTheory.ReflectsIsomorphisms F] : CategoryTheory.IsIso F
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} {v₂ : Type u_5} {P₂ : Type u_6} [AddCommGroup v₂] [module k v₂] [AddTorsor v₂ P₂] {P : ι → P} (F : P →ᵃ[k] P₂) (hai : AffineIndependent k (⇑F ∘ P)) : AffineIndependent k P
{R : Type u} [non_assoc_Semiring R] {S : set R} {t : Subsemiring R} : Subsemiring.Closure S ≤ t ↔ S ⊆ ↑t
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {S t : set E} (hs₁ : Convex ℝ S) (hs₂ : IsOpen S) (ht : Convex ℝ t) (disj : Disjoint S t) : ∃ (F : E →L[ℝ] ℝ) (u : ℝ), (∀ (A : E), A ∈ S → ⇑F A < u) ∧ ∀ (B : E), B ∈ t → u ≤ ⇑F B
{𝕜 : Type u_1} {E : Type u_2} [NormedField 𝕜] [semi_NormedGroup E] [NormedSpace 𝕜 E] {x : E} {S : set E} (hs : Metric.Bounded S) {u : set E} (hu : u ∈ nhds x) : ∀ᶠ (r : 𝕜) in nhds 0, {x} + r • S ⊆ u
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : Rˣ) (n : ℕ) : ∀ᶠ (t : R) in nhds 0, Ring.Inverse (↑x + t) = (Finset.Range n).Sum (λ (i : ℕ), (-↑x⁻¹ * t) ^ i) * ↑x⁻¹ + (-↑x⁻¹ * t) ^ n * Ring.Inverse (↑x + t)
{α : Type u} [TopologicalSpace α] [t1_Space α] [∀ (x : α), (nhds_within x {x}ᶜ).Ne_IsBot] {S : set α} (hs : Dense S) (t : Finset α) : Dense (S  ↑t)
{𝕜 : Type u_1} [Field 𝕜] {m : Type u_2} [AddCommGroup m] [module 𝕜 m] : ⇑LinearMap.det 0 = 0 ^ Finite_dimensional.finrank 𝕜 m
{α : Type u_1} {m : set α → Ennreal} {m_Empty : m ∅ = 0} {S t : set α} (h : ∀ (u : set α), (S ∩ u).Nonempty → (t ∩ u).Nonempty → m u = ⊤) : ⇑(MeasureTheory.OuterMeasure.of_Function m m_Empty) (S ∪ t) = ⇑(MeasureTheory.OuterMeasure.of_Function m m_Empty) S + ⇑(MeasureTheory.OuterMeasure.of_Function m m_Empty) t
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (G : C ⥤ D) [CategoryTheory.Limits.HasInitial C] [CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.Empty C) G] : CategoryTheory.Limits.HasInitial D
{m : Type u_1} [AddZeroClass m] {C : Add_Con m} : Function.Surjective ⇑(C.Mk')
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (F : C ⥤ D) [CategoryTheory.Abelian C] [CategoryTheory.Abelian D] [F.Additive] [CategoryTheory.EnoughInjectives C] {x Y : C} (F : x ⟶ Y) (P : CategoryTheory.InjectiveResolution x) (q : CategoryTheory.InjectiveResolution Y) : F.Map F ≫ CategoryTheory.Abelian.Functor.Right_derived_Zero_to_self_App_Inv F q = CategoryTheory.Abelian.Functor.Right_derived_Zero_to_self_App_Inv F P ≫ (F.Right_derived 0).Map F
{α : Type u_1} {r : α → α → Prop} {S t : set α} (ht : IsAntichain r t) (h : Minimals r S ⊆ t) (hs : ∀ ⦃A : α⦄, A ∈ t → (∃ (B : α) (h : B ∈ Minimals r S), r A B)) : Minimals r S = t
{G : Type u_1} [Group G] (S : set G) : _Subgroup (Group.Normal_Closure S)
{α : Type u} {β : Type v} {fa : α → α} {fb : β → β} {x : α} (hx : Function.IsFixedPt fa x) {g : α → β} (h : Function.Semiconj g fa fb) : Function.IsFixedPt fb (g x)
{K : Type u_1} [Linear_ordered_Field K] {A : K} (h : 1 < A) (n : ℕ) : ↑n ≤ A ^ n / (A - 1)
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} [DecidableEq α'] [DecidableEq γ] [DecidableEq δ] {S : Finset α} {t : Finset β} {F : α' → β → γ} {g : α → α'} {F' : β → α → δ} {g' : δ → γ} (h_Left_anticomm : ∀ (A : α) (B : β), F (g A) B = g' (F' B A)) : Finset.image₂ F (Finset.image g S) t = Finset.image g' (Finset.image₂ F' t S)
{C : Type u₁} [CategoryTheory.Category C] {B A₁ A₂ : C} (F : A₁ ⟶ B) (g : A₂ ⟶ B) [CategoryTheory.Mono F] [CategoryTheory.Mono g] (i : A₁ ≅ A₂) (W : i.hom ≫ g = F) : CategoryTheory.Subobject.Mk F = CategoryTheory.Subobject.Mk g
{α : Type u_1} [Order.Frame α] {S : set α} : S.Pairwise_Disjoint Id → CompleteLattice.set_Independent S
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {ps : set P} {n : ℕ} [Finite_dimensional ℝ v] (hD : Finite_dimensional.finrank ℝ v = n) (hc : EuclideanGeometry.Cospherical ps) : ∃ (C : P), ∀ (sx : Affine.Simplex ℝ P n), set.Range sx.points ⊆ ps → sx.circumcenter = C
{τ : Type u_1} {α : Type u_2} {β : Type u_3} [TopologicalSpace β] (F : Filter τ) (ϕ : τ → α → β) (S : set α) [t2_Space β] {C : set β} (hc₁ : IsCompact C) (hc₂ : ∀ᶠ (t : τ) in F, set.maps_to (ϕ t) S C) {n : set β} (hn₁ : IsOpen n) (hn₂ : OmegaLimit F ϕ S ⊆ n) : ∃ (u : set τ) (h : u ∈ F), Closure (set.image2 ϕ u S) ⊆ n
{α : Type u_1} [generalized_boolean_Algebra α] [Decidable_Rel Disjoint] [Decidable_Rel has_LE.LE] {S : Finset α} {u v A : α} : A ∈ Uv.Compression u v S ↔ A ∈ S ∧ Uv.compress u v A ∈ S ∨ A ∉ S ∧ ∃ (B : α) (h : B ∈ S), Uv.compress u v B = A
{𝕜 : Type u_1} {E : Type u_4} [semi_NormedGroup E] [nondiscrete_NormedField 𝕜] [NormedSpace 𝕜 E] (h : ∃ (x : E), ∥x∥ ≠ 0) : ∥Continuous_LinearMap.Id 𝕜 E∥ = 1
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : E → ℝ} {A : E} {S : set E} (h : IsLocalMinOn F S A) {y : E} (hy : y ∈ Pos_TangentConeAt S A) (hy' : -y ∈ Pos_TangentConeAt S A) : ⇑(fderiv_within ℝ F S A) y = 0
{n : ℕ} {F : Typevec (n + 1) → Type u} [Mvfunctor F] [q : Mvqpf F] {α : Typevec n} {β : Type u_1} (q : β → Prop) (u v : β → Mvqpf.Cofix F α) (h : ∀ (x : β), q x → (∃ (A : (Mvqpf.P F).A) (F' : ((Mvqpf.P F).Drop.B A).arrow α) (F₀ F₁ : (Mvqpf.P F).Last.B A → Mvqpf.Cofix F α), (u x).dest = Mvqpf.Abs ⟨A, (Mvqpf.P F).Append_contents F' F₀⟩ ∧ (v x).dest = Mvqpf.Abs ⟨A, (Mvqpf.P F).Append_contents F' F₁⟩ ∧ ∀ (i : (Mvqpf.P F).Last.B A), ∃ (x' : β), q x' ∧ F₀ i = u x' ∧ F₁ i = v x')) (x : β) : q x → u x = v x
{R : Type u_3} {m : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] (S : set m) (li : LinearIndependent R Coe) (t : Finset ↥S) : LinearIndependent R Coe
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W₁ W₂ : ι → k) (P : ι → P) : ⇑(S.affine_combination P) W₁ -ᵥ ⇑(S.affine_combination P) W₂ = ⇑(S.weighted_vsub P) (W₁ - W₂)
{C : Type u} [CategoryTheory.Category C] {P q R : C} (F : P ⟶ q) (g : q ⟶ R) [CategoryTheory.StrongEpi (F ≫ g)] : CategoryTheory.StrongEpi g
{P : ℂ × ℂ} (hp_fst : 0 < P.fst.re ∨ P.fst.im ≠ 0) : Continuous_at (λ (x : ℂ × ℂ), x.fst ^ x.Snd) P
 : Real.cos (Real.Pi / 3) = 1 / 2
(n : ℕ) (P : Fin (n + 1)) : Finset.Univ = Finset.Cons P (Finset.Map P.Succ_above.to_Embedding Finset.Univ) _
{E : Type u_1} {F : Type u_2} [InnerProductSpace ℝ E] [InnerProductSpace ℝ F] {F : E → F} {x : E} {F' : E →L[ℝ] F} (h : HasFderivAt F F' x) (h : ConformalAt F x) (u v : E) : InnerProductGeometry.angle (⇑F' u) (⇑F' v) = InnerProductGeometry.angle u v
{A : Type u_1} [CommRing A] [Algebra ℚ A] (A B : A) : ⇑(PowerSeries.rescale A) (PowerSeries.Exp A) * ⇑(PowerSeries.rescale B) (PowerSeries.Exp A) = ⇑(PowerSeries.rescale (A + B)) (PowerSeries.Exp A)
(A B : ℕ) : A ^ 2 - B ^ 2 = (A + B) * (A - B)
{k : Type u_1} {l : Type u_2} {m : Type u_3} {n : Type u_4} {α : Type v} [Fintype n] [Fintype k] [DecidableEq n] [DecidableEq k] [DecidableEq m] [Semiring α] (A : m) (B : n) (C : k) (m : Matrix k l α) : (Pequiv.single A B).to_Matrix.Mul ((Pequiv.single B C).to_Matrix.Mul m) = (Pequiv.single A C).to_Matrix.Mul m
{α : Type u} {ι : Type v} [MetricSpace α] [ProperSpace α] {C : ι → α} {S : set α} {r : ι → ℝ} (hr : ∀ (i : ι), 0 < r i) (hs : IsClosed S) (uf : ∀ (x : α), x ∈ S → {i : ι | x ∈ Metric.Ball (C i) (r i)}.Finite) (us : S ⊆ ⋃ (i : ι), Metric.Ball (C i) (r i)) : ∃ (r' : ι → ℝ), (S ⊆ ⋃ (i : ι), Metric.Ball (C i) (r' i)) ∧ ∀ (i : ι), r' i ∈ set.Ioo 0 (r i)
{G : Type u_1} [Group G] (F₁ F₂ : G →* Circle_deg1_Lift) (h : ∀ (g : G), (⇑F₁ g).TranslationNumber = (⇑F₂ g).TranslationNumber) : ∃ (F : Circle_deg1_Lift), ∀ (g : G), Function.Semiconj ⇑F ⇑(⇑F₁ g) ⇑(⇑F₂ g)
{α : Type u_1} {β : Type u_2} {m : Type u_5} [AddCommMonoid m] [DecidableEq α] [DecidableEq β] (S : Finset (α × β)) (F : α × β → m) : finsum (λ (Ab : α × β), finsum (λ (h : Ab ∈ S), F Ab)) = finsum (λ (A : α), finsum (λ (B : β), finsum (λ (h : B ∈ Finset.image Prod.Snd (Finset.Filter (λ (Ab : α × β), Ab.fst = A) S)), F (A, B))))
{G : Type u_1} [AddGroup G] {h : Add_Subgroup G} {N : Type u_3} [AddGroup N] (F : G →+ N) : Add_Subgroup.Map F h.Normalizer ≤ (Add_Subgroup.Map F h).Normalizer
{α : Type u_2} {β : Type u_3} {F : α → β} (hF : Function.Injective F) : Filter.comap F Filter.cofinite = Filter.cofinite
{α : Type u_1} {β : Type u_2} {m : Type u_3} [Fintype α] [Fintype β] [CommMonoid m] (e : α → β) (hE : Function.Bijective e) (F : α → m) (g : β → m) (h : ∀ (x : α), F x = g (e x)) : Finset.Univ.Prod (λ (x : α), F x) = Finset.Univ.Prod (λ (x : β), g x)
{k : Type u_1} {v1 : Type u_2} {P1 : Type u_3} {v2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup v1] [module k v1] [AddTorsor v1 P1] [AddCommGroup v2] [module k v2] [AddTorsor v2 P2] (F : P1 →ᵃ[k] P2) : F.ToFun = ⇑F
{α : Type u_1} [PseudoMetricSpace α] (r C : ℝ) (hr : r < 1) {F : ℕ → α} (hu : ∀ (n : ℕ), HasDist.dist (F n) (F (n + 1)) ≤ C * r ^ n) {A : α} (ha : Filter.Tendsto F Filter.at_top (nhds A)) : HasDist.dist (F 0) A ≤ C / (1 - r)
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {G : C ⥤ D} (h : CategoryTheory.cover_Dense K G) [CategoryTheory.Full G] [CategoryTheory.Faithful G] : CategoryTheory.CompatiblePreserving K G
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] {A B C : Matrix n n α} (h : B.Mul A = 1) (g : C.Mul A = 1) : B = C
{𝕜 : Type u} {G : Type wG} {G' : Type wG'} [nondiscrete_NormedField 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] [NormedGroup G'] [NormedSpace 𝕜 G'] {k n : ℕ} (F : MultilinearMap 𝕜 (λ (i : Fin n), G) G') (S : Finset (Fin n)) (hk : S.Card = k) (z : G) {C : ℝ} (h : ∀ (m : Fin n → G), ∥⇑F m∥ ≤ C * Finset.Univ.Prod (λ (i : Fin n), ∥m i∥)) (v : Fin k → G) : ∥⇑(F.restr S hk z) v∥ ≤ C * ∥z∥ ^ (n - k) * Finset.Univ.Prod (λ (i : Fin k), ∥v i∥)
(k : Type u₁) {G : Type u₂} [Semiring k] [has_Add G] {A : Type u₃} [non_unital_non_assoc_Semiring A] [Distrib_MulAction k A] {φ₁ φ₂ : AddMonoid_Algebra k G →ₙₐ[k] A} (h : ∀ (x : G), ⇑φ₁ (Finsupp.single x 1) = ⇑φ₂ (Finsupp.single x 1)) : φ₁ = φ₂
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {ι : Type u_2} [DecidableEq ι] {E : ι → Type u_3} [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] {S : Π (i : ι), set (E i)} {x : Π (i : ι), E i} {i : ι} (hi : ∀ (j : ι), j ≠ i → x j ∈ Closure (S j)) : set.maps_to ⇑(LinearMap.single i) (TangentConeAt 𝕜 (S i) (x i)) (TangentConeAt 𝕜 (set.Univ.Pi S) x)
(R : Type u_1) (m : Type u_2) [Ring R] [TopologicalSpace R] [TopologicalSpace m] [AddCommGroup m] [has_Continuous_Add m] [module R m] [has_Continuous_Smul R m] [Nontrivial m] [(nhds_within 0 {0}ᶜ).Ne_IsBot] [NoZeroSmulDivisors R m] (x : m) : (nhds_within x {x}ᶜ).Ne_IsBot
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {g : α → F} {F' : α → E'} {l : Filter α} : (λ (x : α), ∥F' x∥) =o[l] g → F' =o[l] g
{ι : Type u_1} {𝕜 : Type u_2} [_R_or_C 𝕜] {E : Type u_3} [InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {G : ι → Type u_4} [Π (i : ι), InnerProductSpace 𝕜 (G i)] {v : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 v) [∀ (i : ι), CompleteSpace (G i)] (hV' : (⨆ (i : ι), (v i).to_LinearMap.Range).topological_Closure = ⊤) {i : ι} (x : G i) : ⇑((hV.Linear_Isometry_Equiv hV').Symm) (Lp.single 2 i x) = ⇑(v i) x
{ι : Type u_1} {R : Type u_3} {m : Type u_5} {v : ι → m} [Ring R] [AddCommGroup m] [module R m] {hli : LinearIndependent R v} {hsp : Submodule.Span R (set.Range v) = ⊤} {i j : ι} (h : j ≠ i) : ⇑((Basis.Mk hli hsp).coord i) (v j) = 0
{x Y : top} {F g : C(↥x, ↥Y)} (h : F.Homotopy g) (x : ↥x) : ⟦h.Eval_at x⟧ = Continuous_Map.Homotopy.hcast _ ≫ (FundamentalGroupoid.FundamentalGroupoid_Functor.Map h.ulift_Map).Map (Continuous_Map.Homotopy.Prod_to_Prod_top_i Unit_Interval.uhpath01 (𝟙 x)) ≫ Continuous_Map.Homotopy.hcast _
{m : Type u_1} [AddZeroClass m] (S : Add_Submonoid m) : AddSubmonoid.Closure ↑S = S
{ι : Type W} [Fintype ι] (K : Type u) {L : Type v} (E : Type z) [Field K] [Field L] [Field E] [Algebra K L] [Algebra K E] [module.Finite K L] [_alg_IsClosed E] (B : ι → L) [DecidableEq ι] [_IsSeparable K L] (e : ι ≃ (L →ₐ[K] E)) : ⇑(Algebra_Map K E) (Algebra.discr K B) = (Algebra.embeddings_Matrix_reindex K E B e).det ^ 2
(C : Type u) [𝒞 : CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryProducts C] [CategoryTheory.Limits.HasEqualizers C] : CategoryTheory.Limits.HasPullbacks C
{h : Type u_1} [TopologicalSpace h] [LocallyCompactSpace h] [t2_Space h] [TotallyDisconnectedSpace h] : TopologicalSpace._topological_Basis {S : set h | IsClopen S}
{α : Type u} {β : Type v} [TopologicalSpace α] [PseudoMetricSpace β] {F g : bounded_Continuous_Function α β} (x : α) : HasDist.dist (⇑F x) (⇑g x) ≤ HasDist.dist F g
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasLimits_of_size C] : CategoryTheory.Limits.HasLimits_of_size C
{m : Type u_1} {N : Type u_2} [AddZeroClass m] [AddZeroClass N] {C : Add_Con m} {F : N →+ m} : Add_Con.comap ⇑F _ C = Add_Con.Ker (C.Mk'.Comp F)
{R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.height_One_Spectrum R) : v.Int_Valuation_def 0 = 0
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} {S t : set α} (hst : Disjoint S t) (hs : S.Finite) (ht : t.Finite) : finsum (λ (i : α), finsum (λ (h : i ∈ S ∪ t), F i)) = finsum (λ (i : α), finsum (λ (h : i ∈ S), F i)) + finsum (λ (i : α), finsum (λ (h : i ∈ t), F i))
{α : Type u_1} {A B C : α} [LinearOrder α] [Add_comm_Semigroup α] [HasSub α] [HasOrderedSub α] : A < B - C ↔ A + C < B
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (t : Affine.Triangle ℝ P) : t.orthocenter ∈ affine_Span ℝ (set.Range t.points)
(A : ℝ) : Cardinal.Mk ↥(set.Iic A) = Cardinal.Continuum
{K : Type u_1} {n : ℕ} {S : Seq (GeneralizedContinuedFraction.Pair K)} [DivisionRing K] {gp_n gp_Succ_n : GeneralizedContinuedFraction.Pair K} (S_nth_Eq : S.nth n = Option.Some gp_n) (S_Succ_nth_Eq : S.nth (n + 1) = Option.Some gp_Succ_n) : (GeneralizedContinuedFraction.squash_Seq S n).nth n = Option.Some {A := gp_n.A, B := gp_n.B + gp_Succ_n.A / gp_Succ_n.B}
(t : Type u) [TopologicalSpace t] : CategoryTheory.Pretopology.to_grothendieck (TopologicalSpace.Opens t) (Opens.pretopology t) = Opens.GrothendieckTopology t
{α : Type u_1} {β : Type u_2} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] {S : set β} (hs : IsCompact S) (Ne_S : S.Nonempty) {F : β → α} (hF : Continuous_on F S) : ∃ (x : β) (h : x ∈ S), ∀ (y : β), y ∈ S → F x ≤ F y
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasZeroMorphisms C] {x : C} (F : x ⟶ 0) : F = 0
{n : ℕ} {l : Multiset ℕ} (hl : l.Sum = n) {i : ℕ} (hi : i ≠ 0) : Multiset.count i (Nat.Partition.of_sums n l hl).Parts = Multiset.count i l
{C : Type u} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) (h : ∀ (x : C), CategoryTheory.Presieve._sheaf J (CategoryTheory.yoneda.obj x)) : CategoryTheory.sheaf.Subcanonical J
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} {ι2 : Type u_5} (F : ι2 ↪ ι) {P : ι → P} (ha : AffineIndependent k P) : AffineIndependent k (P ∘ ⇑F)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {C : E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (hb : Filter.Tendsto F (nhds B ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) : deriv (λ (u : ℝ), ∫ (x : ℝ) in A..u, F x) B = C
{α : Type u_1} {m : Type u_5} {N : Type u_7} {P : Type u_8} [has_Zero m] [AddCommMonoid N] [AddCommMonoid P] (h : N ≃+ P) (F : α →₀ m) (g : α → m → N) : ⇑h (F.Sum g) = F.Sum (λ (A : α) (B : m), ⇑h (g A B))
{m : Type u_1} [has_Mul m] (C : Con m) (x : m) : ⇑C x x
{α : Type u_1} {β : Type u_2} [LinearOrder α] [DecidableEq β] [Preorder β] {F : α → β} (h₁ : StrictMono F) (A B : Finset α) : (Finset.image F A).to_colex < (Finset.image F B).to_colex ↔ A.to_colex < B.to_colex
{𝕜 : Type u_3} {E : Type u_4} [NormedField 𝕜] [AddCommGroup E] [module 𝕜 E] (P : Seminorm 𝕜 E) {r : ℝ} {x : E} (hpr : ⇑P x < r) : Absorbent 𝕜 (P.ball x r)
{K : Type u_1} {v : Type u_2} [Field K] [AddCommGroup v] [module K v] (n : ℕ) [Fact (Finite_dimensional.finrank K v = n + 1)] : Finite_dimensional K v
{α : Type u} [Preorder α] {A B : α} : A < B → A ≤ B
{β : Type u} {α : Type v} {γ : Type W} [CommMonoid β] [CommMonoid γ] (g : β ≃* γ) (F : α → β) (S : Finset α) : ⇑g (S.Prod (λ (x : α), F x)) = S.Prod (λ (x : α), ⇑g (F x))
{l : Filter ℝ} {F F' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in Filter.at_IsBot, HasDerivAt F (F' x) x) (hgg' : ∀ᶠ (x : ℝ) in Filter.at_IsBot, HasDerivAt g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in Filter.at_IsBot, g' x ≠ 0) (hfbot : Filter.Tendsto F Filter.at_IsBot (nhds 0)) (hgbot : Filter.Tendsto g Filter.at_IsBot (nhds 0)) (HDiv : Filter.Tendsto (λ (x : ℝ), F' x / g' x) Filter.at_IsBot l) : Filter.Tendsto (λ (x : ℝ), F x / g x) Filter.at_IsBot l
{m : Type u_4} [AddCommMonoid m] {ι : Type u_1} [Subsingleton ι] {S : Finset ι} {F : ι → m} {B : m} (h : S.Sum (λ (i : ι), F i) = B) (i : ι) (h : i ∈ S) : F i = B
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] [CompleteSpace 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [Finite_dimensional 𝕜 F] {F : E → F} {F' : E →L[𝕜] F} {A : E} (hF : HasStrictFderivAt F F' A) (hF' : F'.Range = ⊤) : ∀ᶠ (P : F × ↥(F'.Ker)) in nhds (F A, 0), F (HasStrictFderivAt.implicit_Function F F' hF hF' P.fst P.Snd) = P.fst
{x : ℝ} (h : 0 < x) : Real.sin x < x
{R : Type u_1} [Add_cancel_Monoid R] (g : R) : IsAddRegular g
{𝕜 : Type u_4} {E : Type u_5} [Linear_ordered_Field 𝕜] [TopologicalSpace E] [AddCommMonoid E] [module 𝕜 E] {S : set E} (hs₀ : IsClosed S) (hs₁ : strict_Convex 𝕜 S) : Add_salem_spencer (Frontier S)
{R : Type u} [non_assoc_Semiring R] (S : Subsemiring R) {x y : R} : x ∈ S → y ∈ S → x * y ∈ S
{R : Type u_1} {m : Type u_4} [Semiring R] [AddCommMonoid m] [module R m] {S : set m} {x : m} (hx : x ∈ Submodule.Span R S) : ∃ (t : Finset m), ↑t ⊆ S ∧ x ∈ Submodule.Span R ↑t
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P ⟶ q) [CategoryTheory.Epi F] : Function.Surjective ⇑F
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S1 S2 : AffineSubspace k P) : S1 ≤ S2 ↔ ↑S1 ⊆ ↑S2
{A : Type u_1} [AddMonoid A] {F g : ℤ →+ A} (h1 : ⇑F 1 = ⇑g 1) : F = g
{α : Type u_1} [Linear_ordered_AddCommGroup α] {n : ℤ} (hn : n ≠ 0) : Function.Injective (λ (_x : α), n • _x)
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B : α} (ha : A ≤ 0) (hb : B < 0) : A + B < 0
{α : Type u} [PseudoMetricSpace α] {F : ℝ → α} {C : ℝ} (hp : Function.Periodic F C) (hc : C ≠ 0) (hF : Continuous F) : Metric.Bounded (set.Range F)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y z : v} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x y + hb.oangle y z = hb.oangle x z
{R : Type u_1} {E : Type u_2} [Linear_ordered_Field R] [AddCommGroup E] [module R E] (S : set E) : ⇑(Convex_hull R) S = {x : E | ∃ (ι : Type u') (t : Finset ι) (W : ι → R) (z : ι → E) (hw₀ : ∀ (i : ι), i ∈ t → 0 ≤ W i) (hw₁ : t.Sum (λ (i : ι), W i) = 1) (hz : ∀ (i : ι), i ∈ t → z i ∈ S), t.Center_mass W z = x}
{α : Type u} [Group α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A : α} : 1 < A⁻¹ → A < 1
{G : Type u_1} [Group G] {S : set G} {N : Subgroup G} [N.Normal] (h : S ⊆ ↑N) : Subgroup.Normal_Closure S ≤ N
(n : ℕ) (R : Type u_1) [Ring R] [Nontrivial R] : (Polynomial.cyclotomic n R).Nat_degree = n.Totient
(A : ℝ) : Cardinal.Mk ↥(set.Iio A) = Cardinal.Continuum
{α : Type u} {r : α → α → Prop} {S : set α} : Directed_on r S → Directed r Coe
(R : Type u) [Ring R] [strong_RankCondition R] (m n : Type v) [Fintype m] [Fintype n] : Finite_dimensional.finrank R (Matrix m n R) = Fintype.Card m * Fintype.Card n
{α : Type u_1} (t : set (set α)) (δ : set α → ℝ) (τ : ℝ) (hτ : 1 < τ) (δnonneg : ∀ (A : set α), A ∈ t → 0 ≤ δ A) (R : ℝ) (δLE : ∀ (A : set α), A ∈ t → δ A ≤ R) (hne : ∀ (A : set α), A ∈ t → A.Nonempty) : ∃ (u : set (set α)) (h : u ⊆ t), u.Pairwise_Disjoint Id ∧ ∀ (A : set α), A ∈ t → (∃ (B : set α) (h : B ∈ u), (A ∩ B).Nonempty ∧ δ A ≤ τ * δ B)
{R : Type u} [CommSemiring R] (S : Multiset (Polynomial R)) (x : R) : Polynomial.Eval x S.Prod = (Multiset.Map (Polynomial.Eval x) S).Prod
{α : Type u_1} {β : Type u_2} {r : Setoid α} {F : α → β} (h : r ≤ Setoid.Ker F) (g : Quotient r → β) (Hg : F = g ∘ Quotient.Mk) : Quotient.Lift F h = g
{m : Type u_2} {n : Type u_3} (R : Type u_11) [CommRing R] [Fintype m] [DecidableEq m] [Fintype n] [DecidableEq n] (e : m ≃ n) (m : Matrix m m R) : (⇑(Matrix.reindex_Linear_Equiv R R e e) m).det = m.det
{𝕜 : Type u_1} {E : Type u_3} [OrderedSemiring 𝕜] [TopologicalSpace E] [AddCommMonoid E] [module 𝕜 E] {S : set E} (h : IsOpen S) (hs : Convex 𝕜 S) : strict_Convex 𝕜 S
{R : Type u_1} [Mul_Zero_class R] : IsRightRegular 0 ↔ Subsingleton R
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_5} [NormedGroup E'] [NormedSpace 𝕜 E'] {n : WithTop ℕ} {F : E → E'} : Cont_mdiff (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n F → ContDiff 𝕜 n F
{α : Type u_1} {β : Type u_2} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] {F : β → α} (hF : Continuous F) (x₀ : β) (h : ∀ᶠ (x : β) in Filter.cocompact β, F x₀ ≤ F x) : ∃ (x : β), ∀ (y : β), F x ≤ F y
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {A : Type u_7} [CategoryTheory.Category A] {G : C ⥤ D} (h : CategoryTheory.cover_Dense K G) [CategoryTheory.Full G] {ℱ : Dᵒᵖ ⥤ A} {ℱ' : CategoryTheory.sheaf K A} (α : ℱ ⟶ ℱ'.val) : h.sheaf_hom (CategoryTheory.whisker_Left G.Op α) = α
{xl xr : Type u_1} {xL : xl → Pgame} {xR : xr → Pgame} {yl yr : Type u_1} {yL : yl → Pgame} {yR : yr → Pgame} : Pgame.Mk xl xr xL xR ≤ Pgame.Mk yl yr yL yR ↔ (∀ (i : xl), (xL i).lf (Pgame.Mk yl yr yL yR)) ∧ ∀ (j : yr), (Pgame.Mk xl xr xL xR).lf (yR j)
{α : Type u_1} [CompleteLattice α] [_modular_Lattice α] [IsCompactlyGenerated α] (h : HasSup.Sup {A : α | IsAtom A} = ⊤) : IsComplemented α
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) : S.points_with_circumcenter Affine.Simplex.points_with_circumcenter_Index.circumcenter_Index = S.circumcenter
{R : Type u} [non_assoc_Semiring R] (S : Subsemiring R) (m : Multiset R) : (∀ (A : R), A ∈ m → A ∈ S) → m.Sum ∈ S
{P : ℕ} (hp : Nat.Prime P) {n : ℤ} (hpn : _IsCoprime n ↑P) : n ^ (P - 1) ≡ 1 [Zmod ↑P]
{α : Type v} {S : Finset α} {m : Type u_1} [AddCommMonoid m] (F : α → m) (P : m → Prop) (P_Mul : ∀ (A B : m), P A → P B → P (A + B)) (P_One : P 0) (P_S : ∀ (x : α), x ∈ S → P (F x)) : P (S.Sum (λ (x : α), F x))
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LE.LE] {A B : α} (ha : A < 0) (hb : B < 0) : A + B < 0
(k : Type u_1) {v : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Fintype ι] (P : ι → P) {n : ℕ} (hc : Fintype.Card ι = n + 1) : AffineIndependent k P ↔ n ≤ Finite_dimensional.finrank k ↥(Vector_Span k (set.Range P))
(R : Type u_1) (A : Type u_2) (m : Type u_3) [CommSemiring R] [Semiring A] [Algebra R A] [AddCommMonoid m] [module R m] [module A m] [IsScalarTower R A m] (x : set m) (hsur : Function.Surjective ⇑(Algebra_Map R A)) : Submodule.Span R x = Submodule.Restrict_scalars R (Submodule.Span A x)
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] (A : Matrix n n R) : (-A).det = (-1) ^ Fintype.Card n • A.det
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) : 0 ≤ InnerProductGeometry.angle x y
{α : Type u} [non_unital_non_assoc_Ring α] {A B C D e : α} : A * e + C = B * e + D → (A - B) * e + C = D
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {n : ℕ} (hs : UniqueDiffOn 𝕜 S) : ContDiff_on 𝕜 ↑(n + 1) F S ↔ DifferentiableOn 𝕜 F S ∧ ContDiff_on 𝕜 ↑n (λ (y : E), fderiv_within 𝕜 F S y) S
{R : Type u_1} [CommRing R] (m : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] (t : Type u_4) [CommRing t] [Algebra R t] [Algebra S t] [IsScalarTower R S t] [IsLocalization m S] (P : Ideal S) [Hp : P.Prime] [IsLocalization.at_Prime t P] : IsLocalization.at_Prime t (Ideal.comap (Algebra_Map R S) P)
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y z : v} (hxyne : x ≠ y) (hxzne : x ≠ z) (hxy : ∥x∥ = ∥y∥) (hxz : ∥x∥ = ∥z∥) : o.oangle y z = 2 • o.oangle (y - x) (z - x)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {P : FormalMultilinearSeries 𝕜 E F} {r : Ennreal} {F : E → F} {x : E} [CompleteSpace F] (h : HasFpowerSeriesOnBall F P x r) : HasFpowerSeriesOnBall (fderiv 𝕜 F) (↑(Continuous_multilinear_Curry_Fin1 𝕜 E F).Comp_FormalMultilinearSeries (P.change_origin_series 1)) x r
{α : Type u_1} [conditionally_complete_LinearOrder α] {S : set α} {B : α} (hs : S.Nonempty) (hb : B < HasSup.Sup S) : ∃ (A : α) (h : A ∈ S), B < A
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {C : E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (hb : Filter.Tendsto F (nhds B ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds C)) : HasStrictDerivAt (λ (u : ℝ), ∫ (x : ℝ) in A..u, F x) C B
(k : Type u_1) {v : Type u_2} (P : Type u_3) [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] : Collinear k ∅
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {x : E} {n : ℕ} (hs : UniqueDiffOn 𝕜 S) (hx : x ∈ S) : iterated_fderiv_within 𝕜 (n + 1) F S x = (⇑(Continuous_multilinear_Curry_Right_Equiv' 𝕜 n E F) ∘ iterated_fderiv_within 𝕜 n (λ (y : E), fderiv_within 𝕜 F S y) S) x
{x : Type u_2} {Y : Type u_3} [EmetricSpace x] [EmetricSpace Y] [TopologicalSpace.SecondCountableTopology x] {F : x → Y} (hF : ∀ (x : x), ∃ (C : Nnreal) (S : set x) (h : S ∈ nhds x), LipschitzOnWith C F S) : dimH (set.Range F) ≤ dimH set.Univ
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {S : set E} : Unique_mdiff_on (model_with_corners_self 𝕜 E) S → UniqueDiffOn 𝕜 S
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LT.LT] {A B : α} (ha : 1 < A) (hb : 1 < B) : 1 < A * B
{R : Type u_1} [CommRing R] {x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ : R} : (x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 + x₅ ^ 2 + x₆ ^ 2 + x₇ ^ 2 + x₈ ^ 2) * (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 + y₅ ^ 2 + y₆ ^ 2 + y₇ ^ 2 + y₈ ^ 2) = (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄ - x₅ * y₅ - x₆ * y₆ - x₇ * y₇ - x₈ * y₈) ^ 2 + (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃ + x₅ * y₆ - x₆ * y₅ - x₇ * y₈ + x₈ * y₇) ^ 2 + (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂ + x₅ * y₇ + x₆ * y₈ - x₇ * y₅ - x₈ * y₆) ^ 2 + (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁ + x₅ * y₈ - x₆ * y₇ + x₇ * y₆ - x₈ * y₅) ^ 2 + (x₁ * y₅ - x₂ * y₆ - x₃ * y₇ - x₄ * y₈ + x₅ * y₁ + x₆ * y₂ + x₇ * y₃ + x₈ * y₄) ^ 2 + (x₁ * y₆ + x₂ * y₅ - x₃ * y₈ + x₄ * y₇ - x₅ * y₂ + x₆ * y₁ - x₇ * y₄ + x₈ * y₃) ^ 2 + (x₁ * y₇ + x₂ * y₈ + x₃ * y₅ - x₄ * y₆ - x₅ * y₃ + x₆ * y₄ + x₇ * y₁ - x₈ * y₂) ^ 2 + (x₁ * y₈ - x₂ * y₇ + x₃ * y₆ + x₄ * y₅ - x₅ * y₄ - x₆ * y₃ + x₇ * y₂ + x₈ * y₁) ^ 2
(R : Type u_2) (m : Type u_5) [Semiring R] [AddCommMonoid m] [module R m] [has_One m] [CharZero m] : CharZero R
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LE.LE] {A B : α} (ha : A < 0) (hb : B ≤ 0) : A + B < 0
{m : Type u_1} [AddMonoid m] (P : Add_Submonoid m) : P.fg ↔ ∃ (S : set m), AddSubmonoid.Closure S = P ∧ S.Finite
{ι : Type u_6} [DecidableEq ι] {ι₁ : Type u_7} [Fintype ι] {R' : Type u_8} {N₁ : Type u_9} {N₂ : Type u_10} [CommSemiring R'] [AddCommMonoid N₁] [AddCommMonoid N₂] [module R' N₁] [module R' N₂] {F g : AlternatingMap R' N₁ N₂ ι} (e : Basis ι₁ R' N₁) (h : ∀ (v : ι → ι₁), Function.Injective v → ⇑F (λ (i : ι), ⇑e (v i)) = ⇑g (λ (i : ι), ⇑e (v i))) : F = g
{α : Type u} {r : α → α → Prop} {A B : α} (P : α → Prop) (l : List α) (h : List.chain r A l) (hb : (A :: l).Last _ = B) (carries : ∀ ⦃x y : α⦄, r x y → P y → P x) (final : P B) (i : α) (h : i ∈ A :: l) : P i
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [nondiscrete_NormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (F : Continuous_MultilinearMap 𝕜 E G) {m : ℝ} (hMp : 0 ≤ m) (hM : ∀ (m : Π (i : ι), E i), ∥⇑F m∥ ≤ m * Finset.Univ.Prod (λ (i : ι), ∥m i∥)) : ∥F∥ ≤ m
{v : Type u} [CategoryTheory.Category v] [CategoryTheory.Limits.HasImages v] [CategoryTheory.Limits.has_Zero_object v] [CategoryTheory.Preadditive v] [CategoryTheory.Limits.HasKernels v] [CategoryTheory.Limits.HasCokernels v] {A B C : v} (F : A ⟶ B) (g : B ⟶ C) : CategoryTheory.Exact F g ↔ ∃ (W : F ≫ g = 0), Nonempty (homology F g W ≅ 0)
{C : Type u₁} [CategoryTheory.Category C] {A : C} [CategoryTheory.Limits.HasBinaryProduct A A] [CategoryTheory.IsIso (CategoryTheory.Limits.diag A)] : CategoryTheory.IsSubterminal A
{C : Type u₁} [CategoryTheory.Category C] {A : C} (hA : CategoryTheory.IsSubterminal A) [CategoryTheory.Limits.HasBinaryProduct A A] : CategoryTheory.IsIso (CategoryTheory.Limits.diag A)
(G : Type u) (F : Type v) [Group G] [Field F] [Fintype G] [Mul_Semiring_action G F] [HasFaithfulSmul G F] : Function.Bijective (Mul_Semiring_action.to_AlgHom ↥(FixedPoints.Subfield G F) F)
(P : ℕ) [Fact (Nat.Prime P)] (R : Type u₁) [CommSemiring R] [Char_P R P] [perfect_Ring R P] : PerfectionMap P (Ring_hom.Id R)
(R : Type u_1) {K : Type u_2} [CommRing R] [Field K] [Algebra R K] [_fraction_Ring R K] [CharZero R] : CharZero K
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] {u v z : E} (hv : v ∈ K) (hz : z ∈ Kᗮ) (hu : u = v + z) : ↑(⇑(Orthogonal_projection K) u) = v
{α : Type u} [PseudoMetricSpace α] {S t u : set α} (Fin : Emetric.Hausdorff_edist t u ≠ ⊤) : metric.Hausdorff_dist S u ≤ metric.Hausdorff_dist S t + metric.Hausdorff_dist t u
{α : Type u_1} [TopologicalSpace α] {S : set α} {γ : Type u_4} [Linear_ordered_AddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] {F g : α → γ} (hF : LowerSemicontinuousOn F S) (hg : LowerSemicontinuousOn g S) (hcont : ∀ (x : α), x ∈ S → Continuous_at (λ (P : γ × γ), P.fst + P.Snd) (F x, g x)) : LowerSemicontinuousOn (λ (z : α), F z + g z) S
(S : ℂ) (h2 : S ≠ 0) : (S + 1).gamma = S * S.gamma
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {F : m →* P} (x : m) : ⇑(Con.Ker F) x = ⇑F ⁻¹' {⇑F x}
(R : Type u) [Ring R] [strong_RankCondition R] {ι : Type v} [Fintype ι] {m : ι → Type W} [Π (i : ι), AddCommGroup (m i)] [Π (i : ι), module R (m i)] [∀ (i : ι), module.free R (m i)] [∀ (i : ι), module.Finite R (m i)] : Finite_dimensional.finrank R (Π (i : ι), m i) = Finset.Univ.Sum (λ (i : ι), Finite_dimensional.finrank R (m i))
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommGroup E] [module 𝕜 E] {S : set E} : Convex_Independent 𝕜 (λ (x : ↥S), ↑x) ↔ ∀ (x : E), x ∈ S → x ∉ ⇑(Convex_hull 𝕜) (S  {x})
{α : Type u} [Group α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A : α} : 1 < A⁻¹ ↔ A < 1
{α : Type u} {β : Type v} [Preorder α] [SemilatticeSup β] {F g : α → β} (hF : Antitone F) (hg : Antitone g) : Antitone (F ⊔ g)
{α : Type u_1} [UniformSpace α] {S : set α} {U : set (α × α)} (hs : Dense S) (hU : U ∈ Uniformity α) : (⋃ (x : α) (h : x ∈ S), UniformSpace.ball x U) = set.Univ
{R : Type u_1} {R₂ : Type u_2} {m : Type u_4} {m₂ : Type u_5} [Semiring R] [AddCommMonoid m] [module R m] [Semiring R₂] [AddCommMonoid m₂] [module R₂ m₂] {σ₁₂ : R →+* R₂} {S : set m} {F g : m →ₛₗ[σ₁₂] m₂} (hv : Submodule.Span R S = ⊤) (h : set.Eq_on ⇑F ⇑g S) : F = g
 : Irrational (Real.sqrt 2)
{ι : Type u_1} {α : ι → Type u_2} [Fintype ι] : Filter.Coprod (λ (i : ι), Filter.cofinite) = Filter.cofinite
{R : Type u} {S : Type v} [Ring R] [Ring S] (F : R →+* S) (hF : Function.Surjective ⇑F) : F.Range = ⊤
{α : Type u_1} {β : Type u_2} [Fintype α] [CompleteLattice β] (F : α → β) : Finset.Univ.Inf F = infi F
{C : Type u₁} [CategoryTheory.Category C] {J : Type u₂} [CategoryTheory.Category J] [CategoryTheory.Limits.HasLimits_of_shape Jᵒᵖ C] : CategoryTheory.Limits.HasColimits_of_shape J Cᵒᵖ
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] : Continuous_Map.IsCompact_IsOpen = Continuous_Map.IsCompact_convergence_topology
{α : Type u} [Preorder α] {F : ℤ → α} (hF : Monotone F) (n : ℤ) {x : α} (h1 : F n < x) (h2 : x < F (n + 1)) (A : ℤ) : F A ≠ x
{α : Type u_1} [TopologicalSpace α] {ι : Type u_2} [Encodable ι] {S : ι → set α} (hs : ∀ (n : ι), MeasureTheory.analytic_set (S n)) : MeasureTheory.analytic_set (⋃ (n : ι), S n)
{A : Type u_5} [CommRing A] {m : Type u_6} {n : Type u_7} [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n] {m : Matrix m n A} {m' : Matrix n m A} {N : Matrix n n A} (hMM' : m.Mul m' = 1) (hM'm : m'.Mul m = 1) : ((m.Mul N).Mul m').det = N.det
{o : Ordinal} {F : Π (B : Ordinal), B < o → Ordinal → Ordinal} (h : ∀ (i : Ordinal) (hi : i < o), Ordinal._Normal (F i hi)) : set.Unbounded has_LT.LT (⋂ (i : Ordinal) (hi : i < o), Function.FixedPoints (F i hi))
{R : Type u_1} {m : Type u_2} [CommRing R] [AddCommGroup m] [module R m] (q : QuadraticForm R m) (n : Zmod 2) {P : Π (x : clifford_Algebra q), x ∈ clifford_Algebra.Even_Odd q n → Prop} (hr : ∀ (v : clifford_Algebra q) (h : v ∈ (clifford_Algebra.ι q).Range ^ n.val), P v _) (HAdd : ∀ {x y : clifford_Algebra q} {hx : x ∈ clifford_Algebra.Even_Odd q n} {hy : y ∈ clifford_Algebra.Even_Odd q n}, P x hx → P y hy → P (x + y) _) (hιι_Mul : ∀ (m₁ m₂ : m) {x : clifford_Algebra q} {hx : x ∈ clifford_Algebra.Even_Odd q n}, P x hx → P (⇑(clifford_Algebra.ι q) m₁ * ⇑(clifford_Algebra.ι q) m₂ * x) _) (x : clifford_Algebra q) (hx : x ∈ clifford_Algebra.Even_Odd q n) : P x hx
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {A : Type u_7} [CategoryTheory.Category A] {G : C ⥤ D} (h : CategoryTheory.cover_Dense K G) [CategoryTheory.Full G] {ℱ ℱ' : CategoryTheory.sheaf K A} (α : ℱ ⟶ ℱ') (i : CategoryTheory.IsIso (CategoryTheory.whisker_Left G.Op α.val)) : CategoryTheory.IsIso α
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] [IsNoetherian R m] {S : set m} (hi : LinearIndependent R Coe) : S.Finite
{α : Type u} {F : Ultrafilter α} {P : α → Prop} : (∃ᶠ (x : α) in ↑F, P x) → (∀ᶠ (x : α) in ↑F, P x)
{ι : Type u₁} {k : Type u₂} {v : Type u₃} {P : Type u₄} [AddCommGroup v] [AddTorsor v P] [CommRing k] [module k v] [DecidableEq ι] [Fintype ι] (B B₂ : affine_Basis ι k P) (x : P) : Matrix.vec_Mul (⇑(B.coords) x) (B.to_Matrix B₂.points)⁻¹ = ⇑(B₂.coords) x
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} [decι : DecidableEq ι] {v : ι → E} : Orthonormal 𝕜 v ↔ ∀ (i j : ι), HasInner.inner (v i) (v j) = Ite (i = j) 1 0
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] (F : E →L[𝕜] F →L[𝕜] G) : Continuous (Function.uncurry (λ (x : E) (y : F), ⇑(⇑F x) y))
{q : ℚ} (q_Pos : 0 < q) : (GeneralizedContinuedFraction.Int_fract_pair.of q⁻¹).fr.Num < q.Num
{α : Type u_1} [has_LT α] {A B : α} (h : A < B) : ¬A ⋖ B → (∃ (C : α), A < C ∧ C < B)
{α : Type u_1} [Linear_ordered_Field α] {A B : α} (ha : A < 0) (hb : B < 0) : 1 / A < 1 / B ↔ B < A
{R : Type u_1} [NormedRing R] (k : ℕ) {r : ℝ} (hr : 1 < r) : (λ (n : ℕ), ↑n ^ k) =o[Filter.at_top] λ (n : ℕ), r ^ n
(k : Type u_1) (v : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S t : set P) : affine_Span k (S ∪ t) = affine_Span k S ⊔ affine_Span k t
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.Limits.HasCokernels C] {P q : C} (F : P ⟶ q) : CategoryTheory.Abelian.coimage.π F ≫ CategoryTheory.Abelian.FactorThruCoimage F = F
{α : Type u} [EmetricSpace α] [CompleteSpace α] : IsClosed (set.Range TopologicalSpace.Nonempty_Compacts.to_Closeds)
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x : v) (θ : Real.Angle) : x = ⇑(o.rotation θ) x ↔ x = 0 ∨ θ = 0
{ι : Type W} [Fintype ι] (K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [module.Finite K L] {R : Type z} [CommRing R] [Algebra R K] [Algebra R L] [IsScalarTower R K L] {B : ι → L} (h : ∀ (i : ι), IsIntegral R (B i)) : IsIntegral R (Algebra.discr K B)
{𝕜 : Type u_3} [_R_or_C 𝕜] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {h : Type u_5} [NormedGroup h] [NormedSpace 𝕜 h] {F : G → h} {F' : G → (G →L[𝕜] h)} {x : G} (hder : ∀ᶠ (y : G) in nhds x, HasFderivAt F (F' y) y) (hcont : Continuous_at F' x) : HasStrictFderivAt F (F' x) x
{α : Type u_2} {β : Type u_3} {rα : non_assoc_Semiring α} {rβ : non_assoc_Semiring β} (F : α →+* β) [Nontrivial β] : Nontrivial α
{𝕜 : Type u_3} {E : Type u_4} [semi_NormedRing 𝕜] [AddCommGroup E] [module 𝕜 E] (P : Seminorm 𝕜 E) (x y : E) : ⇑P x ≤ ⇑P y + ⇑P (x - y)
{β α : Type u} (F : β → α) (W : Cardinal.Mk α < Cardinal.Mk β) (W' : Cardinal.aleph0 ≤ Cardinal.Mk α) : ∃ (A : α), Cardinal.Mk α < Cardinal.Mk ↥(F ⁻¹' {A})
{α : sort u_1} (hH : α) {β : Prop} (x : Tactic.CalculatedProp β hH . "derive_elementwise_proof") : β
{R : Type u} [Semiring R] {P : Polynomial R} {n : ℕ} : P.degree ≤ ↑n → P.Nat_degree ≤ n
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [OrderedSemiring 𝕜] [AddCommGroup E] [module 𝕜 E] {P : ι → E} (hc : Convex_Independent 𝕜 P) : Function.Injective P
{α : Type u} [CompleteLattice α] {J : Type u} [CategoryTheory.SmallCategory J] (F : J ⥤ α) : CategoryTheory.Limits.Colimit F = supr F.obj
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F g : α → m} {S : set α} (hs : S.Finite) : finsum (λ (i : α), finsum (λ (h : i ∈ S), F i + g i)) = finsum (λ (i : α), finsum (λ (h : i ∈ S), F i)) + finsum (λ (i : α), finsum (λ (h : i ∈ S), g i))
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : ℝ → E} {F' : E} {S : set ℝ} {x r : ℝ} (hF : HasDerivWithinAt F F' S x) (hr : ∥F'∥ < r) : ∀ᶠ (z : ℝ) in nhds_within x S, ∥z - x∥⁻¹ * (∥F z∥ - ∥F x∥) < r
{m : Type u} {α : Type v} [CommRing α] [Fintype m] [DecidableEq m] (u v : m → α) : (1 + (Matrix.col u).Mul (Matrix.row v)).det = 1 + Matrix.dot_Product v u
{α : Type u} {A B : α} [MulOneClass α] [has_Zero α] [Preorder α] [Zero_LT.Pos_Mul_StrictMono α] (ha : A ≤ 1) (hb : B < 1) (A0 : 0 < A) : A * B < 1
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) : 0 ≤ S.circumradius
{β : Type u} {α : Type v} {γ : Type W} [CommMonoid β] [CommMonoid γ] (g : β →* γ) (F : α → β) (S : Finset α) : ⇑g (S.Prod (λ (x : α), F x)) = S.Prod (λ (x : α), ⇑g (F x))
{C : Type u} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) {A A' B B' : C} [CategoryTheory.Limits.HasBinaryProduct A B] [CategoryTheory.Limits.HasBinaryProduct A' B'] [CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)] [CategoryTheory.Limits.HasBinaryProduct (F.obj A') (F.obj B')] (F : A ⟶ A') (g : B ⟶ B') [CategoryTheory.IsIso (CategoryTheory.Limits.Prod_comparison F A B)] [CategoryTheory.IsIso (CategoryTheory.Limits.Prod_comparison F A' B')] : CategoryTheory.Inv (CategoryTheory.Limits.Prod_comparison F A B) ≫ F.Map (CategoryTheory.Limits.Prod.Map F g) = CategoryTheory.Limits.Prod.Map (F.Map F) (F.Map g) ≫ CategoryTheory.Inv (CategoryTheory.Limits.Prod_comparison F A' B')
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S : set P} (h : affine_Span k S = ⊤) : Vector_Span k S = ⊤
{α : Type u_1} [PseudoEmetricSpace α] {δSeq : ℕ → ℝ} (δSeq_Pos : ∀ (n : ℕ), 0 < δSeq n) (δSeq_lim : Filter.Tendsto δSeq Filter.at_top (nhds 0)) (E : set α) : Filter.Tendsto (λ (n : ℕ), ⇑(thickened_indicator _ E)) Filter.at_top (nhds ((Closure E).indicator (λ (x : α), 1)))
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (t : Affine.Triangle ℝ P) (i : Fin 3) : affine_Span ℝ {t.orthocenter, t.points i} ≤ Affine.Simplex.altitude t i
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {E' : Type u_4} [NormedGroup E'] [NormedSpace 𝕜 E'] {F' : Type u_5} [NormedGroup F'] [NormedSpace 𝕜 F'] {S : set E} {t : set E'} {F : E → F} {g : E' → F'} (hF : ContDiff_on 𝕜 n F S) (hg : ContDiff_on 𝕜 n g t) : ContDiff_on 𝕜 n (Prod.Map F g) (S ×ˢ t)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {F : F → G} (hF : ContDiff 𝕜 n F) : ContDiff 𝕜 n (λ (x : E × F), F x.Snd)
{α : Type u_1} [DecidableEq α] {S : Finset α} : S.Nonempty → S.Sym2.Nonempty
{m : Type u_4} [TopologicalSpace m] [Monoid m] [has_Continuous_Mul m] {U : set m} (hU : U ∈ nhds 1) : ∃ (v : set m), IsOpen v ∧ 1 ∈ v ∧ v * v ⊆ U
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {P : FormalMultilinearSeries 𝕜 E F} {x : E} (h : HasFpowerSeriesAt 0 P x) (n : ℕ) (y : E) : ⇑(P n) (λ (i : Fin n), y) = 0
{α : Type u} {β : Type v} [PseudoMetricSpace α] [PseudoMetricSpace β] {K : Nnreal} {F : α → β} : LipschitzWith K F → ∀ (x y : α), HasDist.dist (F x) (F y) ≤ ↑K * HasDist.dist x y
(R : Type u) [Ring R] [strong_RankCondition R] {ι : Type v} [Fintype ι] (m : ι → Type W) [Π (i : ι), AddCommGroup (m i)] [Π (i : ι), module R (m i)] [∀ (i : ι), module.free R (m i)] [∀ (i : ι), module.Finite R (m i)] : Finite_dimensional.finrank R (direct_Sum ι (λ (i : ι), m i)) = Finset.Univ.Sum (λ (i : ι), Finite_dimensional.finrank R (m i))
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommMonoid β] [module 𝕜 E] [HasScalar 𝕜 β] {S : set E} {F : E → β} (hF : ConcaveOn 𝕜 S F) (C : E) : ConcaveOn 𝕜 ((λ (z : E), C + z) ⁻¹' S) (F ∘ λ (z : E), z + C)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMinOrder α] [DenselyOrdered α] {A : α} {S : set α} : S ∈ nhds_within A (set.Iic A) ↔ ∃ (l : α), l < A ∧ set.icc l A ⊆ S
{P A B : ℕ} (hab : A.IsCoprime B) (hpb : P ∈ B.Factors) : ⇑((A * B).factorization) P = ⇑(B.factorization) P
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] [Nontrivial B] {x : B} (hx : IsIntegral A x) : 0 < (minpoly A x).degree
{g : ℂ →L[ℝ] ℂ} : IsConformalMap g ↔ ((∃ (Map : ℂ →L[ℂ] ℂ), Continuous_Linear_Map.Restrict_scalars ℝ Map = g) ∨ ∃ (Map : ℂ →L[ℂ] ℂ), Continuous_Linear_Map.Restrict_scalars ℝ Map = g.Comp ↑Complex.Conj_cle) ∧ g ≠ 0
{α : Type u_1} [has_LE α] {A : α} : IsMin A → IsMax (⇑order_dual.to_dual A)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y z : v} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle (-x) y + hb.oangle (-y) z + hb.oangle (-z) x = ↑Real.Pi
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) : Real.sin (InnerProductGeometry.angle x y + InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) = 0
(m n : ℕ) : Nat.fib (m.Gcd n) = (Nat.fib m).Gcd (Nat.fib n)
{P : ℕ+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [Ne_Zero ↑↑P] [hpri : Fact (Nat.Prime ↑P)] [hcyc : IsCyclotomicExtension {P} K L] (hirr : Irreducible (Polynomial.cyclotomic ↑P K)) (h : P ≠ 2) : ⇑(Algebra.norm K) (IsCyclotomicExtension.zeta P K L - 1) = ↑P
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [semi_NormedGroup F'] {F : α → E} {g' : α → F'} {l : Filter α} : F =o[l] g' → (F =o[l] λ (x : α), -g' x)
(x : ℝ) : Real.sqrt (1 + Real.sinh x ^ 2) = Real.cosh x
{α : Type u_1} [CompleteLattice α] {A : α} {S : set α} : (⨆ (B : α) (h : B ∈ S), A ⊓ B) ≤ A ⊓ HasSup.Sup S
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (x : m ⧸ S) : 0 ≤ ∥x∥
{α : Type u} {F g : α → α} (h : Function.Commute F g) : set.bij_on g (Function.FixedPoints (F ∘ g)) (Function.FixedPoints (F ∘ g))
{i : ℕ} {F g : ℕ → ℝ} (h0 : ∀ (B : ℕ), 0 ≤ F B) (h : ∀ (B : ℕ), F B ≤ g B) (hi : F i < g i) (hg : Summable g) : ∑' (n : ℕ), F n < ∑' (n : ℕ), g n
{α : Type u} [TopologicalSpace α] {S U Z : set α} (hZ : IsPreirreducible Z) (hU : U.Nonempty) (hU' : IsOpen U) (h₁ : U ⊆ S) (h₂ : S ⊆ Z) : _Irreducible S
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] [t1_Space β] {F : α → β} {A : α} {B : β} (h : Filter.Tendsto F (nhds A) (nhds B)) : Continuous_at F A
{n : Type u} [DecidableEq n] [Fintype n] {α : Type v} [CommRing α] (A : Matrix n n α) {β : Type u_1} (S : Finset β) (F : β → n → α) : S.Sum (λ (x : β), ⇑(A.cramer) (F x)) = ⇑(A.cramer) (S.Sum (λ (x : β), F x))
{m : Type u_3} {N : Type u_4} [has_Add m] [has_Add N] (F : Add_hom m N) {x y : m} (h : x = y) : ⇑F x = ⇑F y
(P : ℕ) [Fact (Nat.Prime P)] (hp : P ≠ 2) : Zmod.legendre_Sym P (-1) = ⇑Zmod.χ₄ ↑P
{J : Type u₁} [CategoryTheory.Category J] [CategoryTheory.IsPreconnected J] (P : set J) {j₀ : J} (h0 : j₀ ∈ P) (h1 : ∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → (j₁ ∈ P ↔ j₂ ∈ P)) (j : J) : j ∈ P
{α : Type u} [MulOneClass α] [has_Distrib_Neg α] (A : α) : A * -1 = -A
{G : Type u_1} [Group G] [TopologicalSpace G] [topological_Group G] [t2_Space G] {K₀ : TopologicalSpace.PositiveCompacts G} (g : G) (K : TopologicalSpace.Compacts G) : ⇑(MeasureTheory.Measure.haar.haar_content K₀) (TopologicalSpace.Compacts.Map (λ (B : G), g * B) _ K) = ⇑(MeasureTheory.Measure.haar.haar_content K₀) K
{α : Type u} [OrderedSemiring α] [Nontrivial α] : 0 < 3
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} {F' : ℝ → E} {C : ℝ} (hF : ∀ (x : ℝ), x ∈ set.icc A B → HasDerivWithinAt F (F' x) (set.icc A B) x) (bound : ∀ (x : ℝ), x ∈ set.Ico A B → ∥F' x∥ ≤ C) (x : ℝ) (h : x ∈ set.icc A B) : ∥F x - F A∥ ≤ C * (x - A)
{ι : Type u_1} {α : Type u_2} {S : ι → set α} (hs : IndexedPartition S) (x : hs.Quotient) : hs.Index (Quotient.out' x) = hs.Index (⇑(hs.out) x)
{n : ℕ} {i₁ i₂ : Fin (n + 3)} (h : i₁ ≠ i₂) : Affine.Simplex.monge_point_vsub_face_centroid_weights_with_circumcenter i₁ i₂ = Affine.Simplex.monge_point_weights_with_circumcenter n - Affine.Simplex.centroid_weights_with_circumcenter {i₁, i₂}ᶜ
{α : Type u_1} [LinearOrder α] (A : α) : {A}.max' _ = A
{F : ℕ →. ℕ} : Nat.partrec F ↔ ∃ (C : Nat.Partrec.Code), C.Eval = F
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {A₁ A₂ A₃ : α} {B₁ B₂ B₃ : β} (q₁ : Path.Homotopic.Quotient A₁ A₂) (q₂ : Path.Homotopic.Quotient B₁ B₂) (r₁ : Path.Homotopic.Quotient A₂ A₃) (r₂ : Path.Homotopic.Quotient B₂ B₃) : (Path.Homotopic.Prod q₁ q₂).Comp (Path.Homotopic.Prod r₁ r₂) = Path.Homotopic.Prod (q₁.Comp r₁) (q₂.Comp r₂)
{C : Type u₁} [CategoryTheory.Category C] {x Y Z : C} {C : CategoryTheory.Limits.BinaryFan x Y} (h : CategoryTheory.Limits.IsLimit C) (t : CategoryTheory.Limits.IsTerminal Z) : CategoryTheory.IsPullback C.fst C.Snd (t.from ((CategoryTheory.Limits.pair x Y).obj {as := CategoryTheory.Limits.WalkingPair.Left})) (t.from ((CategoryTheory.Limits.pair x Y).obj {as := CategoryTheory.Limits.WalkingPair.Right}))
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] [LocallyCompactSpace α] : Continuous (λ (P : C(α, β) × α), ⇑(P.fst) P.Snd)
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) : Real.cos (InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) = -Real.cos (InnerProductGeometry.angle x y)
{R : Type u_1} {A : R} [Add_Semigroup R] (B : R) (ha : _Add_Left_regular A) : _Add_Left_regular (A + B) ↔ _Add_Left_regular B
{α : Type u} [PseudoMetricSpace α] (B : ℕ → ℝ) (hB : ∀ (n : ℕ), 0 < B n) (h : ∀ (u : ℕ → α), (∀ (N n m : ℕ), N ≤ n → N ≤ m → HasDist.dist (u n) (u m) < B N) → (∃ (x : α), Filter.Tendsto u Filter.at_top (nhds x))) : CompleteSpace α
{E : Type u_2} [semi_NormedGroup E] [NormedSpace ℝ E] {S : set E} {x : E} (hx : x ∈ ⇑(Convex_hull ℝ) S) (y : E) : ∃ (x' : E) (h : x' ∈ S), HasDist.dist x y ≤ HasDist.dist x' y
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [nondiscrete_NormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (F g : Continuous_MultilinearMap 𝕜 E G) : ∥F + g∥ ≤ ∥F∥ + ∥g∥
{G : Type W} [TopologicalSpace G] [has_Inv G] [has_Mul G] [has_Continuous_Mul G] (g : G) : Continuous (λ (h : G), g * h * g⁻¹)
{α : Type u_1} [MetricSpace α] (t : set (set α)) (R : ℝ) (ht : ∀ (S : set α), S ∈ t → (∃ (x : α) (r : ℝ), S = metric.IsClosed_ball x r ∧ r ≤ R)) : ∃ (u : set (set α)) (h : u ⊆ t), u.Pairwise_Disjoint Id ∧ ∀ (A : set α), A ∈ t → (∃ (x : α) (r : ℝ), metric.IsClosed_ball x r ∈ u ∧ A ⊆ metric.IsClosed_ball x (5 * r))
{𝕜 : Type u_1} [Linear_ordered_Field 𝕜] {x y : 𝕜} (h : x < y) {z : 𝕜} : z ∈ set.Ico x y ↔ ∃ (A B : 𝕜), 0 < A ∧ 0 ≤ B ∧ A + B = 1 ∧ A * x + B * y = z
{R : Type u₁} [Monoid R] [has_Distrib_Neg R] (A : R) : (-A) ^ 2 = A ^ 2
{R : Type u_1} {m : Type u_2} [CommSemiring R] [AddCommMonoid m] [module R m] [no_Zero_divisors R] [Nontrivial R] : NoZeroSmulDivisors R m ↔ Submodule.torsion R m = ⊥
{E : ℕ → Type u_1} [Π (n : ℕ), TopologicalSpace (E n)] [∀ (n : ℕ), DiscreteTopology (E n)] {x y : Π (n : ℕ), E n} {S : set (Π (n : ℕ), E n)} (hs : IsClosed S) (hne : S.Nonempty) (h : Pi_Nat.longest_prefix x S < Pi_Nat.first_Diff x y) (xs : x ∉ S) (ys : y ∉ S) : Pi_Nat.Cylinder x (Pi_Nat.longest_prefix x S) = Pi_Nat.Cylinder y (Pi_Nat.longest_prefix y S)
{α : Type u_1} {β : Type u_2} {e e' : local_Equiv α β} (hE : e ≈ e') (S : set α) : e.restr S ≈ e'.restr S
{R : Type x} [CommRing R] (A B : R) : A * A - B * B = (A + B) * (A - B)
{m₀ : Type u_1} {m₀' : Type u_3} [has_Mul m₀] [has_Zero m₀] [has_Mul m₀'] [has_Zero m₀'] [no_Zero_divisors m₀'] (F : m₀ → m₀') (hF : Function.Injective F) (Zero : F 0 = 0) (Mul : ∀ (x y : m₀), F (x * y) = F x * F y) : no_Zero_divisors m₀
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] [LocallyCompactSpace α] [LocallyCompactSpace β] : Continuous Continuous_Map.uncurry
{α : Type u_1} {n : Type u_4} [AddGroup n] {v : n → α} (h : (Matrix.circulant v).IsSymm) (i : n) : v (-i) = v i
{α : Type u} {A : set α} (h : A.Finite) : {B : set α | B ⊆ A}.Finite
{α : Type u_1} {ι : sort u_2} [Nonempty ι] (m : ι → MeasureTheory.OuterMeasure α) (S : set α) : (⇑⨅ (i : ι), m i) S = ⨅ (t : ℕ → set α) (h2 : S ⊆ set.Union t), ∑' (n : ℕ), ⨅ (i : ι), ⇑(m i) (t n)
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] (C : Add_Con m) (F : m →+ P) (h : C ≤ Add_Con.Ker F) (h : Function.Injective ⇑(C.Lift F h)) : Add_Con.Ker F = C
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] {A B C : Matrix n n α} (h : A.Mul B = 1) (g : A.Mul C = 1) : B = C
{α : Type u} (F : Filter α) [h : F.Ne_IsBot] : ∃ (u : Ultrafilter α), ↑u ≤ F
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {x y : v} (h : hb.oangle x y = 0) : x = y ↔ ∥x∥ = ∥y∥
{G : Type u_1} [TopologicalSpace G] [Group G] [topological_Group G] (N : Subgroup G) [N.Normal] : N.topological_Closure.Normal
{ι : Type u_1} {R : Type u_3} {m : Type u_5} {v : ι → m} [Ring R] [AddCommGroup m] [module R m] : LinearIndependent R v → Function.Injective ⇑(Finsupp.Total ι m R v)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S1 S2 : AffineSubspace k P} (h : S1 < S2) : ∃ (P : P) (h : P ∈ S2), P ∉ S1
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {F : α → β} {S : set α} : Monotone_on F S → Antitone_on (⇑order_dual.to_dual ∘ F) S
(K : Type u) [DivisionRing K] {n : ℕ} : Finite_dimensional.finrank K (Fin n → K) = n
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P : P) : P -ᵥ P = 0
{α : Type u_1} [has_Mul α] [Preorder α] [CovariantClass α α has_Mul.Mul has_LE.LE] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LT.LT] {A B C D : α} (h₁ : A < B) (h₂ : C < D) : A * C < B * D
{α : Type u} [PseudoMetricSpace α] [Preorder α] [IsCompact_icc_Space α] {S : set α} (h₁ : BddAbove S) (h₂ : BddBelow S) : Metric.Bounded S
{m : Type u_1} [AddMonoid m] {x : m} (m : ℕ) {n : ℕ} (h : n • x = 0) : m • x = (m % n) • x
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : HasInner.inner (x - y) (x - y) = HasInner.inner x x - 2 * HasInner.inner x y + HasInner.inner y y
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] [CompleteSpace E] (g : E →ₗ[𝕜] F) (hg : ∀ (u : ℕ → E) (x : E) (y : F), Filter.Tendsto u Filter.at_top (nhds x) → Filter.Tendsto (⇑g ∘ u) Filter.at_top (nhds y) → y = ⇑g x) : Continuous ⇑g
{C : Type u} [CategoryTheory.Category C] {x : C} (P : Cᵒᵖ ⥤ Type v) (R S : CategoryTheory.Sieve x) (hR : CategoryTheory.Presieve.IsSheafFor P ⇑R) (hR' : ∀ ⦃Y : C⦄ ⦃F : Y ⟶ x⦄, ⇑S F → CategoryTheory.Presieve.IsSeparated_for P ⇑(CategoryTheory.Sieve.pullback F R)) (hS : ∀ ⦃Y : C⦄ ⦃F : Y ⟶ x⦄, ⇑R F → CategoryTheory.Presieve.IsSheafFor P ⇑(CategoryTheory.Sieve.pullback F S)) : CategoryTheory.Presieve.IsSheafFor P ⇑S
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {C : ℝ} {F : α → E} {g : α → F} {l : Filter α} : Asymptotics._O_with C l F g ↔ ∀ᶠ (x : α) in l, ∥F x∥ ≤ C * ∥g x∥
{R : Type u} {ι : Type u'} {m₁ : ι → Type v₁} {m₂ : Type v₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (m₁ i)] [AddCommMonoid m₂] [Π (i : ι), module R (m₁ i)] [module R m₂] (F : MultilinearMap R m₁ m₂) {α : ι → Type u_1} (g : Π (i : ι), α i → m₁ i) (A : Π (i : ι), Finset (α i)) [Fintype ι] {n : ℕ} (h : Finset.Univ.Sum (λ (i : ι), (A i).Card) = n) : ⇑F (λ (i : ι), (A i).Sum (λ (j : α i), g i j)) = (Fintype.Pi_Finset A).Sum (λ (r : Π (A : ι), α A), ⇑F (λ (i : ι), g i (r i)))
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x ⟶ Y} {C : CategoryTheory.Limits.Cofork F g} (h : CategoryTheory.Limits.IsColimit C) [CategoryTheory.Mono C.π] : CategoryTheory.IsIso C.π
{m : Type u_3} {N : Type u_4} [AddMonoid m] [AddMonoid N] (F : m →+ N) (l : List m) : ⇑F l.Sum = (List.Map ⇑F l).Sum
{α : Type u_1} (P : α → Prop) (r : α → α → Prop) [IsSymm α r] (h : ∀ (S : Finset α), (∀ (x : α), x ∈ S → P x) → (∃ (y : α), P y ∧ ∀ (x : α), x ∈ S → r x y)) : ∃ (F : ℕ → α), (∀ (n : ℕ), P (F n)) ∧ ∀ (m n : ℕ), m ≠ n → r (F m) (F n)
(P : ℕ) [Fact (Nat.Prime P)] (x : (Zmod P)ˣ) : (∃ (y : (Zmod P)ˣ), y ^ 2 = x) ↔ x ^ (P / 2) = 1
{B : Type u} [Quiver B] {A B C : B} (P : Quiver.Path A B) {F g : CategoryTheory.FreeBicategory.Hom B C} (η : F ⟶ g) : CategoryTheory.FreeBicategory.normalize_aux P F = CategoryTheory.FreeBicategory.normalize_aux P g
{r : ℝ} (tr : Transcendental ℚ r) : Irrational r
{E : Type u_2} [AddCommGroup E] [module ℝ E] (S : Convex_cone ℝ E) (F : LinearPmap ℝ E ℝ) (nonneg : ∀ (x : ↥(F.IsDomain)), ↑x ∈ S → 0 ≤ ⇑F x) (Dense : ∀ (y : E), ∃ (x : ↥(F.IsDomain)), ↑x + y ∈ S) : ∃ (g : E →ₗ[ℝ] ℝ), (∀ (x : ↥(F.IsDomain)), ⇑g ↑x = ⇑F x) ∧ ∀ (x : E), x ∈ S → 0 ≤ ⇑g x
{α : Type u_1} {m : Type u_5} [AddCommMonoid m] {F : α → m} {S : set α} (P : m → Prop) (hp₀ : P 0) (hp₁ : ∀ (x y : m), P x → P y → P (x + y)) (hp₂ : ∀ (x : α), x ∈ S → P (F x)) : P (finsum (λ (i : α), finsum (λ (h : i ∈ S), F i)))
{m : Type u_1} [AddMonoid m] {x y z : m} : y ∈ Multiples x → z ∈ Multiples x → y + z ∈ Multiples x
{n : ℕ} {E : Type u_1} [NormedGroup E] (A : E) (C : Fin n → ℂ) (R : Fin n → ℝ) : TorusIntegrable (λ (_x : Fin n → ℂ), A) C R
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) (θ : Real.Angle) : hb.oangle (⇑(hb.rotation θ) x) (⇑(hb.rotation θ) y) = hb.oangle x y
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x : E} {r : 𝕜} (hx : x ≠ 0) (hr : r ≠ 0) : _R_or_C.Abs (HasInner.inner x (r • x)) / (∥x∥ * ∥r • x∥) = 1
{α : Type u_1} {m : Type u_5} {N : Type u_7} [has_Zero m] [AddCommMonoid N] [DecidableEq α] (F : α →₀ m) (A : α) (B : α → m → N) : F.Sum (λ (x : α) (v : m), Ite (x = A) (B x v) 0) = Ite (A ∈ F.Support) (B A (⇑F A)) 0
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x : v) {r : ℝ} (hr : 0 ≤ r) : hb.oangle x (r • x) = 0
{α : Type u} [Group α] [has_LE α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A : α} : 1 ≤ A⁻¹ ↔ A ≤ 1
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {x y : m} (h : SameRay R x y) (hx : x ≠ 0) : ∃ (r : R), 0 ≤ r ∧ r • x = y
{L : FirstOrder.Language} (m : Type W') [L.structure m] [im : Infinite m] (κ : Cardinal) (h1 : L.Card.Lift ≤ κ.Lift) (h2 : (Cardinal.Mk m).Lift ≤ κ.Lift) : ∃ (N : CategoryTheory.Bundled L.structure), Nonempty (L.elementary_Embedding m ↥N) ∧ Cardinal.Mk ↥N = κ.Lift
{α : Type u} {β : Type v} : (Cardinal.Mk α).Lift ≤ (Cardinal.Mk β).Lift ↔ Nonempty (α ↪ β)
{α : Type u} [PseudoMetricSpace α] {S : set α} : metric.Hausdorff_dist ∅ S = 0
{K : Type v} {v : Type W} [Field K] [AddCommGroup v] [module K v] (F : module.End K v) : CompleteLattice.Independent F.eigenspace
{C : Type u₁} [CategoryTheory.Category C] {A : Type u₂} [CategoryTheory.Category A] (P : Cᵒᵖ ⥤ A) {x : C} (S : CategoryTheory.Sieve x) : (∀ (C : CategoryTheory.Limits.Cone (S.Arrows.Diagram.Op ⋙ P)), Subsingleton (C ⟶ P.Map_cone S.Arrows.Cocone.Op)) ↔ ∀ (E : Aᵒᵖ), CategoryTheory.Presieve.IsSeparated_for (P ⋙ CategoryTheory.coyoneda.obj E) ⇑S
(L : List ℕ) : L.head + L.tail.Sum = L.Sum
{A B : ℕ} (ha : A ≠ 0) (hb : B ≠ 0) : (A * B).Factors ~ A.Factors ++ B.Factors
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_NormedGroup E] [semi_NormedGroup F] [nondiscrete_NormedField 𝕜] [nondiscrete_NormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [Ring_hom_isometric σ₁₂] (F : E →sl[σ₁₂] F) (x : E) : ∥⇑F x∥ ≤ ∥F∥ * ∥x∥
{α : Type u} {A B : α} [MulOneClass α] [has_Zero α] [Preorder α] [Zero_LT.Pos_Mul_StrictMono α] (ha : 1 < A) (hb : 1 < B) (A0 : 0 < A) : 1 < A * B
{ι : Type u} (S : Finset ι) {F : ι → ℝ} {P : ℝ} (hp : 1 ≤ P) (hF : ∀ (i : ι), i ∈ S → 0 ≤ F i) : S.Sum (λ (i : ι), F i) ^ P ≤ ↑(S.Card) ^ (P - 1) * S.Sum (λ (i : ι), F i ^ P)
{m : Type u_2} [AddCommGroup m] {ι : Type u_4} [DecidableEq ι] [Fintype ι] {A : Type u_5} [CommRing A] [module A m] {κ : Type u_6} [Fintype κ] [DecidableEq κ] (B : Basis ι A m) (C : Basis κ A m) (F : m →ₗ[A] m) : (⇑(Linear_Map.to_Matrix B B) F).det = (⇑(Linear_Map.to_Matrix C C) F).det
{α : Type u_1} (r : α → α → Prop) [IsRefl α r] [IsTrans α r] {S : set α} (h : S.partially_well_ordered_on r) : {l : List α | ∀ (x : α), x ∈ l → x ∈ S}.partially_well_ordered_on (List.sublist_forall₂ r)
{C : Type u} [CategoryTheory.Category C] {D : Type u_1} [CategoryTheory.Category D] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.has_Zero_object C] [CategoryTheory.Limits.HasEqualizers C] [CategoryTheory.Limits.HasImages C] [CategoryTheory.HasProjectiveResolutions C] [CategoryTheory.Preadditive D] [CategoryTheory.Limits.has_Zero_object D] [CategoryTheory.Limits.HasEqualizers D] [CategoryTheory.Limits.HasCokernels D] [CategoryTheory.Limits.HasImages D] [CategoryTheory.Limits.HasImage_maps D] (F : C ⥤ D) [F.Additive] (n : ℕ) {x Y : C} (F : x ⟶ Y) {P : CategoryTheory.ProjectiveResolution x} {q : CategoryTheory.ProjectiveResolution Y} (g : P.Complex ⟶ q.Complex) (W : g ≫ q.π = P.π ≫ (chain_Complex.single₀ C).Map F) : (F.Left_derived n).Map F = (F.Left_derived_obj_iso n P).hom ≫ (homology_Functor D (ComplexShape.down ℕ) n).Map ((F.Map_homological_Complex (ComplexShape.down ℕ)).Map g) ≫ (F.Left_derived_obj_iso n q).Inv
{n : ℕ} {β : Type u_1} (A : β) (q : Fin n → β) (B : β) : Fin.Cons A (Fin.snoc q B) = Fin.snoc (Fin.Cons A q) B
{m n : ℕ} (hmn : m.IsCoprime n) : Squarefree (m * n) ↔ Squarefree m ∧ Squarefree n
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (P1 : P) {P2 P3 P4 : P} (h : EuclideanGeometry.angle P2 P3 P4 = Real.Pi) : EuclideanGeometry.angle P1 P3 P2 + EuclideanGeometry.angle P1 P3 P4 = Real.Pi
{J : Type u₁} [CategoryTheory.Category J] {K : Type u₂} [CategoryTheory.Category K] {C : Type u} [CategoryTheory.Category C] {F : J ⥤ C} [CategoryTheory.Limits.HasColimit F] {E : K ⥤ J} [CategoryTheory.Limits.HasColimit (E ⋙ F)] (S : CategoryTheory.Limits.Colimit_Cocone (E ⋙ F)) (t : CategoryTheory.Limits.Colimit_Cocone F) : CategoryTheory.Limits.Colimit.pre F E = (CategoryTheory.Limits.Colimit.iso_Colimit_Cocone S).hom ≫ S._Colimit.Desc (CategoryTheory.Limits.Cocone.whisker E t.Cocone) ≫ (CategoryTheory.Limits.Colimit.iso_Colimit_Cocone t).Inv
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasCoproducts C] : CategoryTheory.Limits.has_Finite_coproducts C
{R : Type u_4} {S : Type u_5} [has_Mul R] [has_Add R] [has_Mul S] [has_Add S] (e : R ≃+* S) (x y : R) : ⇑e (x * y) = ⇑e x * ⇑e y
{α : Type u} (S : Seq α) {Aₙ : α} {n m : ℕ} (m_LE_n : m ≤ n) (S_nth_Eq_Some : S.nth n = Option.Some Aₙ) : ∃ (Aₘ : α), S.nth m = Option.Some Aₘ
{α : Type u} [PseudoMetricSpace α] {S : set α} {F : α → ℝ} (K : ℝ) (h : ∀ (x : α), x ∈ S → ∀ (y : α), y ∈ S → F x ≤ F y + K * HasDist.dist x y) : LipschitzOnWith K.to_Nnreal F S
{n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n
{α : Type u} [UniformSpace α] (h : IsComplete set.Univ) : CompleteSpace α
{α : Type u_1} [Preorder α] [locally_Finite_order α] {A B : α} : ¬A < B → Multiset.Ico A B = 0
{R : Type u} {ι : Type u'} {m₁ : ι → Type v₁} {m₂ : Type v₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (m₁ i)] [AddCommMonoid m₂] [Π (i : ι), module R (m₁ i)] [module R m₂] (F : MultilinearMap R m₁ m₂) (m m' : Π (i : ι), m₁ i) (t : Finset ι) : ⇑F (t.piecewise (m + m') m') = t.powerset.Sum (λ (S : Finset ι), ⇑F (S.piecewise m m'))
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {F : α → γ} {x : α × β} (hF : Continuous_at F x.fst) : Continuous_at (λ (x : α × β), F x.fst) x
{P : ℕ} (hp : Nat.Prime P) {R : Type u_1} [CommRing R] [IsDomain R] {n m : ℕ} (hmn : m ≤ n) (h : Irreducible (Polynomial.cyclotomic (P ^ n) R)) : Irreducible (Polynomial.cyclotomic (P ^ m) R)
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] [Finite_dimensional K v] : 0 < Finite_dimensional.finrank K v ↔ ∃ (x : v), x ≠ 0
{ι : Type u_1} {R : Type u_3} [Ring R] {m : Type u_2} [AddCommGroup m] [module R m] {v : ι → m} (li : LinearIndependent R v) (C D : R) (i j : ι) (hc : C ≠ 0) (h : C • v i = D • v j) : i = j
{α : Type u} [SemilatticeInf α] [OrderTop α] {x y z : α} (F : x ⟶ z) (g : y ⟶ z) : CategoryTheory.Limits.pullback F g = x ⊓ y
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [BaireSpace α] {S : set β} {F : Π (x : β), x ∈ S → set α} (ho : ∀ (S : β) (h : S ∈ S), _Gδ (F S h)) (hS : S.countable) (hD : ∀ (S : β) (h : S ∈ S), Dense (F S h)) : Dense (⋂ (S : β) (h : S ∈ S), F S h)
{α : Type u_1} [MetricSpace α] {β : Type u} [Nonempty β] (P : Besicovitch.TauPackage β α) {i : Ordinal} (hi : i < P.Last_step) {N : ℕ} (hN : IsEmpty (Besicovitch.SatelliteConfig α N P.τ)) : P.color i < N
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} (x : E) {v : ι → E} (hv : Orthonormal 𝕜 v) : Summable (λ (i : ι), ∥HasInner.inner (v i) x∥ ^ 2)
{x : Type u_1} [TopologicalSpace x] [SequentialSpace x] {S : set x} {A : x} : A ∈ Closure S ↔ ∃ (x : ℕ → x), (∀ (n : ℕ), x n ∈ S) ∧ Filter.Tendsto x Filter.at_top (nhds A)
{R : Type u} {S : Type v} [Ring R] [Ring S] {F g : R →+* S} {S : set R} (h : set.Eq_on ⇑F ⇑g S) : set.Eq_on ⇑F ⇑g ↑(Subring.Closure S)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P : ι → P) {i : ι} (his : i ∈ S) (hwi : W i = 1) (hw0 : ∀ (i2 : ι), i2 ∈ S → i2 ≠ i → W i2 = 0) : ⇑(S.affine_combination P) W = P i
{α : Type u} [PseudoEmetricSpace α] {F : ℕ → α} (n : ℕ) {D : ℕ → Ennreal} (hD : ∀ {k : ℕ}, k < n → HasEdist.edist (F k) (F (k + 1)) ≤ D k) : HasEdist.edist (F 0) (F n) ≤ (Finset.Range n).Sum (λ (i : ℕ), D i)
{t : ℝ} {g : ℝ → ℝ} (hg : Function.Periodic g t) (h_Int : ∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.MeasureSpace.Volume t₁ t₂) (h₀ : 0 < ∫ (x : ℝ) in 0..t, g x) (hT : 0 < t) : Filter.Tendsto (λ (t : ℝ), ∫ (x : ℝ) in 0..t, g x) Filter.at_top Filter.at_top
{P : ℕ} [P_Prime : Fact (Nat.Prime P)] {A : ℤ} : multiplicity.Finite ↑P A ↔ A ≠ 0
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) : HasInner.inner x y = -(∥x∥ * ∥y∥) ↔ InnerProductGeometry.angle x y = Real.Pi
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {A : F} (ha : A ≠ 0) : Char.quadratic_Char F A ^ 2 = 1
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {ι : Type u_5} [DecidableEq ι] [Fintype ι] (g : G →L[𝕜] E) : IsBoundedLinearMap 𝕜 (λ (F : Continuous_MultilinearMap 𝕜 (λ (i : ι), E) F), F.Comp_Continuous_Linear_Map (λ (_x : ι), g))
{K : Type u_1} {v : K} {n : ℕ} [Linear_ordered_Field K] [FloorRing K] {ifp_n : GeneralizedContinuedFraction.Int_fract_pair K} (nth_Stream_Eq : GeneralizedContinuedFraction.Int_fract_pair.Stream v n = Option.Some ifp_n) : 0 ≤ ifp_n.fr ∧ ifp_n.fr < 1
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) : IsUnit A ↔ IsUnit A.det
{α : Type u_1} (F : set α → α) : ¬Function.Injective F
{R : Type u_2} [CommRing R] [IsDomain R] [Fintype R] {F g : Polynomial R} (hF2 : F.degree = 2) (hg2 : g.degree = 2) (hR : Fintype.Card R % 2 = 1) : ∃ (A B : R), Polynomial.Eval A F + Polynomial.Eval B g = 0
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} {S₁ S₂ : Affine.Simplex ℝ P n} (h : set.Range S₁.points = set.Range S₂.points) : S₁.monge_point = S₂.monge_point
{α : Type u_1} [Preorder α] [SuccOrder α] {A : α} : ¬IsMax A → A < Order.Succ A
{R : Type u_4} {S : Type u_5} [Semiring R] [Semiring S] (F : R ≃+* Sᵐᵒᵖ) (l : List R) : Mul_Opposite.Unop (⇑F l.Prod) = (List.Map (Mul_Opposite.Unop ∘ ⇑F) l).reverse.Prod
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] {F : x → Y} [SequentialSpace x] : Seq_Continuous F → Continuous F
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {m n : WithTop ℕ} {S : set E} {F : E → F} (hF : ContDiff_on 𝕜 n F S) (hs : UniqueDiffOn 𝕜 S) (hmn : m + 1 ≤ n) : ContDiff_on 𝕜 m (λ (P : E × E), ⇑(fderiv_within 𝕜 F S P.fst) P.Snd) (S ×ˢ set.Univ)
(G : Type u_1) [AddMonoid G] : ¬AddMonoid._torsion_free G ↔ ∃ (g : G), g ≠ 0 ∧ _of_Fin_Add_order g
{G : Type u} [Fintype G] [Add_Left_cancel_Monoid G] (x : G) : 0 < Add_order_of x
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P : ι → P) : ⇑(S.weighted_vsub P) W = S.Sum (λ (i : ι), W i • (P i -ᵥ Classical.choice AddTorsor.Nonempty))
{m : Type u_1} [has_Mul m] (S : set m) {P : Π (x : m), x ∈ Subsemigroup.Closure S → Prop} (Hs : ∀ (x : m) (h : x ∈ S), P x _) (HMul : ∀ (x : m) (hx : x ∈ Subsemigroup.Closure S) (y : m) (hy : y ∈ Subsemigroup.Closure S), P x hx → P y hy → P (x * y) _) {x : m} (hx : x ∈ Subsemigroup.Closure S) : P x hx
{α : Type u} [PseudoMetricSpace α] {S t : set α} (hs : S.Nonempty) (bs : Metric.Bounded S) (ht : t.Nonempty) (bt : Metric.Bounded t) : metric.Hausdorff_dist S t ≤ Metric.diam (S ∪ t)
{τ : Type u_1} {α : Type u_2} {β : Type u_3} [TopologicalSpace β] (F : Filter τ) (ϕ : τ → α → β) (x : α) (y : β) : y ∈ OmegaLimit F ϕ {x} ↔ Map_ClusterPt y F (λ (t : τ), ϕ t x)
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B : α} (ha : A ≤ 0) (hb : B ≤ 0) : A + B ≤ 0
{m : Type u_1} [has_Mul m] {S : set m} : S ⊆ ↑(Subsemigroup.Closure S)
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [Linear_ordered_AddCommMonoid β] [HasScalar 𝕜 E] [module 𝕜 β] [OrderedSmul 𝕜 β] {S : set E} {F g : E → β} (hF : Convex_on 𝕜 S F) (hg : Convex_on 𝕜 S g) : Convex_on 𝕜 S (F ⊔ g)
{α : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [semi_NormedGroup E] [semi_NormedGroup F] [semi_NormedGroup G] {F : α → E} {g : α → F} {l : Filter α} (hF : Filter.Tendsto F l (nhds 0)) (hg : Filter._bounded_under has_LE.LE l (HasNorm.norm ∘ g)) (Op : E → F → G) (h_Op : ∃ (A : ℝ), ∀ (x : E) (y : F), ∥Op x y∥ ≤ A * ∥x∥ * ∥y∥) : Filter.Tendsto (λ (x : α), Op (F x) (g x)) l (nhds 0)
(m : ℕ) : padic_val_rat m 0 = 0
{m : Type u_1} [has_Add m] {C : Add_Con m} (x y : m) : ↑(x + y) = ↑x + ↑y
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (F : C(α × β, γ)) : Continuous F.Curry'
{E : Type u_1} [AddCommGroup E] [module ℝ E] {S : set E} : gauge S 0 = 0
{α : Type u_1} {β : Type u_2} {δ : Type u_4} [AddCommMonoid α] [TopologicalSpace α] [t2_Space α] [CompleteLattice β] (m : β → α) (m0 : m ⊥ = 0) (R : α → α → Prop) (m_supr : ∀ (S : ℕ → β), R (m (⨆ (i : ℕ), S i)) (∑' (i : ℕ), m (S i))) (S : δ → β) (t : Finset δ) : R (m (⨆ (D : δ) (h : D ∈ t), S D)) (t.Sum (λ (D : δ), m (S D)))
{α : Type u} {β : Type v} : (Cardinal.Mk α).Lift = (Cardinal.Mk β).Lift ↔ Nonempty (α ≃ β)
{α : Type u_1} [cancel_CommMonoid_with_Zero α] [Unique_factorization_Monoid α] [normalization_Monoid α] [DecidableEq α] {n : α} : (factorization n).Support = (Unique_factorization_Monoid.normalized_Factors n).to_Finset
{α : Type u_2} [DecidableEq α] [has_div α] {u : Finset α} {S t : set α} : ↑u ⊆ S / t → (∃ (S' t' : Finset α), ↑S' ⊆ S ∧ ↑t' ⊆ t ∧ u ⊆ S' / t')
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} (h : ∥x∥ = ∥y∥) : InnerProductGeometry.angle x (x - y) = InnerProductGeometry.angle y (y - x)
(F : Type u_1) [Field F] {E : Type u_2} [Field E] [Algebra F E] (S t : set E) : ↑(intermediate_Field.Adjoin ↥(intermediate_Field.Adjoin F S) t) = intermediate_Field.Adjoin F (S ∪ t)
{R : Type u_1} [Semiring R] {x y : R} (h : Commute x y) (n : ℕ) : (x + y) ^ n = (Finset.Nat.antidiagonal n).Sum (λ (m : ℕ × ℕ), n.choose m.fst • (x ^ m.fst * y ^ m.Snd))
{α : sort u_1} {S₁ : Setoid α} {P : Quotient S₁ → Prop} (q : Quotient S₁) (h : ∀ (A : α), P (Quotient.Mk' A)) : P q
{ι : Type u_1} {R : Type u_2} {N : Type u_5} [decι : DecidableEq ι] [Ring R] [AddCommGroup N] [module R N] {P : ι → Submodule R N} (h : CompleteLattice.Independent P) : Function.Injective ⇑(⇑(Dfinsupp.lsum ℕ) (λ (i : ι), (P i).Subtype))
{α : Type u_2} {β : Type u_3} {rα : non_assoc_Semiring α} {rβ : non_assoc_Semiring β} (F : α →+* β) (A B : α) : ⇑F (A * B) = ⇑F A * ⇑F B
{α : Type u_1} (L : List (List α)) {i j : ℕ} (hi : i < L.length) (hj : j < (L.nth_LE i hi).length) : (List.take i (List.Map List.length L)).Sum + j < (List.take (i + 1) (List.Map List.length L)).Sum
{α : sort u_1} {P : α → Prop} {q : Π (x : α), P x → Prop} : (∃ (x : α) (h : P x), q x h) ↔ ∃ (x : {A // P A}), q ↑x _
{P : ℕ} [Fact (Nat.Prime P)] (x : Zmod P) : x ^ P = x
{m : Type u_1} {N : Type u_2} [has_Add m] [has_Add N] {C : Add_Con m} {D : Add_Con N} {C : C.Quotient → D.Quotient → Prop} (P : C.Quotient) (q : D.Quotient) (h : ∀ (x : m) (y : N), C ↑x ↑y) : C P q
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} [TopologicalSpace β] [TopologicalSpace.pseudo_metrizable_Space β] (u : Filter ι) [u.Ne_IsBot] [u._countably_generated] {F : ι → α → β} {g : α → β} (hF : ∀ (i : ι), MeasureTheory.strongly_Measurable (F i)) (lim : Filter.Tendsto F u (nhds g)) : MeasureTheory.strongly_Measurable g
{α : Type u} (P : α → Prop) [Decidable_Pred P] (as : List α) : (List.zip_with has_Append.Append (List.split_on_P P as) (List.Map (λ (x : α), [x]) (List.Filter P as) ++ [List.Nil])).Join = as
{m : Type u_1} [has_Add m] (C : Add_Con m) (x : m) : ⇑C x x
{α : Type u_1} [canonically_ordered_AddMonoid α] [HasSub α] [HasOrderedSub α] {A B C : α} (h : C ≤ B) (h2 : A - C < B - C) : A < B
(S : set ℝ) (hS : ∀ (x : ℝ), x ∈ S → x ≤ 0) : HasSup.Sup S ≤ 0
{α : Type u} [TopologicalSpace α] {S t : set α} (h : IsPreconnected S) (Kst : S ⊆ t) (Ktcs : t ⊆ Closure S) : IsPreconnected t
{x : Type u_2} [EmetricSpace x] [TopologicalSpace.SecondCountableTopology x] (S : set x) : (⨆ (x : x), (nhds_within x S).Small_sets.limsup dimH) = dimH S
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {x y : m} {S : Type u_3} [Monoid S] [Distrib_MulAction S m] [SmulCommClass R S m] (h : SameRay R x y) (S : S) : SameRay R (S • x) (S • y)
{G : Type u_6} {h : Type u_7} {F : Type u_8} [AddGroup G] [subtraction_Monoid h] [AddMonoid_hom_class F G h] (F : F) (A B : G) : ⇑F (A - B) = ⇑F A - ⇑F B
{α : Type u} {ι : Type v} [MetricSpace α] [ProperSpace α] {C : ι → α} {S : set α} {r : ι → ℝ} (hs : IsClosed S) (uf : ∀ (x : α), x ∈ S → {i : ι | x ∈ Metric.Ball (C i) (r i)}.Finite) (us : S ⊆ ⋃ (i : ι), Metric.Ball (C i) (r i)) : ∃ (r' : ι → ℝ), (S ⊆ ⋃ (i : ι), Metric.Ball (C i) (r' i)) ∧ ∀ (i : ι), r' i < r i
{α : Type u} {β : Type v} [AddGroup α] [AddGroup β] {F : α → β} (hF : _AddGroup_hom F) : _AddMonoid_hom F
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P q : C} (F : P ⟶ q) : (∀ (A : ↥P), ⇑F A = 0 → A = 0) → CategoryTheory.Mono F
(v : Type u_1) [semi_NormedGroup v] : ∥NormedGroup_hom.Id v∥ ≤ 1
{C : Type u₁} [CategoryTheory.Category C] {x Y : C} (F : x ⟶ Y) [CategoryTheory.IsIso (CategoryTheory.yoneda.Map F)] : CategoryTheory.IsIso F
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S1 S2 : AffineSubspace k P} (h : S1 ≤ S2) : S1.direction ≤ S2.direction
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) {B₂ : Basis (Fin 2) ℝ v} (hb₂ : Orthonormal ℝ ⇑B₂) (ho : B.Orientation = -B₂.Orientation) (θ : Real.Angle) : hb.rotation θ = hb₂.rotation (-θ)
{D : set ℝ} (hD : Convex ℝ D) {F : ℝ → ℝ} (hF : Continuous_on F D) (hF' : DifferentiableOn ℝ F (Interior D)) (h_anti : Antitone_on (deriv F) (Interior D)) : ConcaveOn ℝ D F
{J : Type v} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasLimits_of_shape (CategoryTheory.Limits.WidePullbackShape J) C] {B : C} : CategoryTheory.Limits.HasLimits_of_shape (CategoryTheory.Discrete J) (CategoryTheory.Over B)
 : Continuous_Map.Conj_invariant_Subalgebra (Subalgebra.Restrict_scalars ℝ fourier_Subalgebra)
{α : Type u_1} [TopologicalSpace α] {S : set (set α)} (h : ∀ (S : set α), S ∈ S → _Gδ S) (hS : S.countable) : _Gδ (⋂₀ S)
{ι : Type u_3} {χ : ι → Type u_4} [Π (i : ι), TopologicalSpace (χ i)] {as bs cs : Π (i : ι), χ i} (γ₀ : Π (i : ι), Path (as i) (bs i)) (γ₁ : Π (i : ι), Path (bs i) (cs i)) : (Path.Pi γ₀).Trans (Path.Pi γ₁) = Path.Pi (λ (i : ι), (γ₀ i).Trans (γ₁ i))
{α : Type u_1} {n : Type u_3} {A : Matrix n n α} : A.IsSymm ↔ ∀ (i j : n), A j i = A i j
{α J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.Fin_Category J] [SemilatticeSup α] [OrderBot α] (F : J ⥤ α) : CategoryTheory.Limits.Colimit F = Finset.Univ.Sup F.obj
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {x Y Z x' Y' Z' : C} (F : x ⟶ Y) (g : Y ⟶ Z) [CategoryTheory.Limits.HasKernel g] (W : F ≫ g = 0) (F' : x' ⟶ Y') (g' : Y' ⟶ Z') [CategoryTheory.Limits.HasKernel g'] (W' : F' ≫ g' = 0) (P : x ⟶ x') (q : Y ⟶ Y') (r : Z ⟶ Z') (h₁ : F ≫ q = P ≫ F') (h₂ : g ≫ r = q ≫ g') : CategoryTheory.Limits.Kernel.Lift g F W ≫ CategoryTheory.Limits.Kernel.Map g g' q r h₂ = P ≫ CategoryTheory.Limits.Kernel.Lift g' F' W'
{α : Type u_1} {β : Type u_2} {m₁ : MeasurableSpace α} {m₂ : MeasurableSpace β} {F : α → β} : m₂ ≤ MeasurableSpace.Map F m₁ → Measurable F
{α : Type u} {β : Type v} {γ : Type W} [PseudoEmetricSpace α] [TopologicalSpace β] [PseudoEmetricSpace γ] (F : α × β → γ) (K : Nnreal) (ha : ∀ (A : α), Continuous (λ (y : β), F (A, y))) (hb : ∀ (B : β), LipschitzWith K (λ (x : α), F (x, B))) : Continuous F
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : Nnreal} {C : ℂ} {F : ℂ → E} (hD : DifferentiableOn ℂ F (metric.IsClosed_ball C ↑R)) (hR : 0 < R) : HasFpowerSeriesOnBall F (Cauchy_PowerSeries F C ↑R) C ↑R
{C : Type u₁} [CategoryTheory.Category C] {x Y : C} (F : x ⟶ Y) [CategoryTheory.IsIso F.Op] : CategoryTheory.IsIso F
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {x : top} {F G : top.Presheaf C x} (α : F ≅ G) (h : F._sheaf) : G._sheaf
{ι : Type u_1} {𝕜 : Type u_2} {F : Type u_3} [Fintype ι] [Semiring 𝕜] [TopologicalSpace 𝕜] [AddCommMonoid F] [module 𝕜 F] [TopologicalSpace F] [has_Continuous_Add F] [has_Continuous_Smul 𝕜 F] (F : (ι → 𝕜) →ₗ[𝕜] F) : Continuous ⇑F
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [Finite_dimensional ℝ E] {S : set E} {F : E → E} {F' : E → (E →L[ℝ] E)} [MeasurableSpace E] [BorelSpace E] (hs : Measurable_set S) (hF' : ∀ (x : E), x ∈ S → HasFderivWithinAt F (F' x) S x) (hF : set.inj_on F S) : Measurable_Embedding (S.Restrict F)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (x Y : C) : CategoryTheory.IsIso (CategoryTheory.Limits.Kernelι 0)
{α : Type u} [AddGroup α] [has_LE α] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B : α} : A - B ≤ 0 → A ≤ B
{α : Type u_1} [PartialOrder α] [SuccOrder α] [IsSuccArchimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ set.Ico m n → r (Order.Succ i) i) (hmn : m < n) : Relation.TransGen r n m
(n : ℕ) (n_Pos : 0 < n) : 4 ^ n ≤ 2 * n * n.central_binom
{R : Type u} {ι : Type v} {m₁ : ι → Type W₁} {m₂ : Type W₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (m₁ i)] [AddCommMonoid m₂] [Π (i : ι), module R (m₁ i)] [module R m₂] [Π (i : ι), TopologicalSpace (m₁ i)] [TopologicalSpace m₂] (F : Continuous_MultilinearMap R m₁ m₂) [Fintype ι] (m m' : Π (i : ι), m₁ i) : ⇑F (m + m') = Finset.Univ.Sum (λ (S : Finset ι), ⇑F (S.piecewise m m'))
{α : Type u} [TopologicalSpace α] (x : α) [(nhds_within x {x}ᶜ).Ne_IsBot] : Closure {x}ᶜ = set.Univ
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {β : Type u_4} [Linear_ordered_Field 𝕜] [AddCommGroup E] [AddCommGroup F] [ordered_AddCommMonoid β] [module 𝕜 E] [module 𝕜 F] [HasScalar 𝕜 β] {F : F → β} (g : E →ᵃ[𝕜] F) {S : set F} (hF : ConcaveOn 𝕜 S F) : ConcaveOn 𝕜 (⇑g ⁻¹' S) (F ∘ ⇑g)
{P : ℕ} : padic_val_rat P 1 = 0
{v : Type u} [CategoryTheory.Category v] [CategoryTheory.Limits.HasZeroMorphisms v] {A B C : v} (F : A ⟶ B) [CategoryTheory.Limits.HasImage F] (g : B ⟶ C) [CategoryTheory.Limits.HasKernel g] (W : F ≫ g = 0) (h : CategoryTheory.Limits.image_Subobject F ≤ CategoryTheory.Limits.Kernel_Subobject g) : (CategoryTheory.Limits.image_Subobject F).of_LE (CategoryTheory.Limits.Kernel_Subobject g) h = image_to_Kernel F g W
{α : sort u_1} {β : sort u_2} {γ : sort u_3} {F : α → β → γ} (hF : Function.Injective2 F) (A : α) : Function.Injective (F A)
{α : Type u} {β : Type v} [Group α] [Group β] {F : α → β} (hF : _Group_hom F) : _Monoid_hom F
{n : ℕ} (hn : Even n) (h : n ≠ 0) : strict_Convex_on ℝ set.Univ (λ (x : ℝ), x ^ n)
{R : Type u} [CommRing R] [IsNoetherian_Ring R] : IsNoetherian_Ring (Polynomial R)
{D : set ℝ} (hD : Convex ℝ D) {F : ℝ → ℝ} (hF : Continuous_on F D) (hF' : DifferentiableOn ℝ F (Interior D)) {C : ℝ} (LE_hF' : ∀ (x : ℝ), x ∈ Interior D → deriv F x ≤ C) (x : ℝ) (h : x ∈ D) (y : ℝ) (h_1 : y ∈ D) : x ≤ y → F y - F x ≤ C * (y - x)
{R : Type u_1} [has_Mul R] {A : R} : IsLeftRegular A ↔ IsSmulRegular R A
{R : Type u_1} {α : Type u_2} {β : Type u_4} {γ : Type u_6} {l : Type u_8} {m : Type u_9} {n : Type u_10} {l' : Type u_14} {m' : Type u_15} {n' : Type u_16} [CommSemiring R] [Fintype m] [Fintype m'] [non_unital_non_assoc_Semiring α] [non_unital_non_assoc_Semiring β] [non_unital_non_assoc_Semiring γ] [module R α] [module R β] [module R γ] (F : α →ₗ[R] β →ₗ[R] γ) (h_comm : ∀ (A B : α) (A' B' : β), ⇑(⇑F (A * B)) (A' * B') = ⇑(⇑F A) A' * ⇑(⇑F B) B') (A : Matrix l m α) (B : Matrix m n α) (A' : Matrix l' m' β) (B' : Matrix m' n' β) : ⇑(⇑(Matrix.kronecker_Map_bilinear F) (A.Mul B)) (A'.Mul B') = (⇑(⇑(Matrix.kronecker_Map_bilinear F) A) A').Mul (⇑(⇑(Matrix.kronecker_Map_bilinear F) B) B')
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [SemilatticeSup α] [OrderBot α] (S : Finset β) (t : Finset γ) (F : β × γ → α) : (S.Product t).Sup F = S.Sup (λ (i : β), t.Sup (λ (i' : γ), F (i, i')))
{A : Type u_2} [CommRing A] [IsDomain A] (h : IsDedekindDomain_Inv A) : IsDedekindDomain A
{ι : Type u_1} {α : Type u_3} [Preorder ι] [Preorder α] {l : Filter ι} {u : ι → α} (h : Monotone u) [l.Ne_IsBot] (hu : Filter.Tendsto u l Filter.at_IsBot) : Filter.Tendsto u Filter.at_IsBot Filter.at_IsBot
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {v₁ v₂ : Ray_Vector R m} : v₁ ≈ v₂ ↔ SameRay R ↑v₁ ↑v₂
{α : Type u} [OrderedSemiring α] [Nontrivial α] : 0 < 4
{α : Type u_1} {β : Type u_2} {m : Type u_5} [AddCommMonoid m] {g : β → m} (e : α → β) (hE₀ : Function.Bijective e) : finsum (λ (i : α), g (e i)) = finsum (λ (j : β), g j)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (P1 P2 P3 : P) : 0 ≤ EuclideanGeometry.angle P1 P2 P3
(n : ℕ) : n.choose 2 = n * (n - 1) / 2
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace E] [CompleteSpace ↥K] (W : E) : W = ↑(⇑(Orthogonal_projection K) W) + ↑(⇑(Orthogonal_projection Kᗮ) W)
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {S1 S2 : AffineSubspace k P} (h1 : ↑S1.Nonempty) (h2 : ↑S2.Nonempty) (hE : ↑S1 ∩ ↑S2 = ∅) : S1.direction ⊔ S2.direction < (S1 ⊔ S2).direction
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (e : C ≌ D) (Y : D) : e.Unit.App (e.Inverse.obj Y) ≫ e.Inverse.Map (e.counit.App Y) = 𝟙 (e.Inverse.obj Y)
{α : Type u} [Preorder α] {A B C : α} : B = C → A < B → A < C
(R : Type u) (m : Type v) [Ring R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] : ↑(Finite_dimensional.finrank R m) = module.rank R m
{Y : Type u_2} [TopologicalSpace Y] [NormalSpace Y] {S : set Y} (F : C(↥S, ℝ)) {t : set ℝ} [t.Ord_connected] (ht : ∀ (x : ↥S), ⇑F x ∈ t) (hne : t.Nonempty) (hs : IsClosed S) : ∃ (g : C(Y, ℝ)), (∀ (y : Y), ⇑g y ∈ t) ∧ Continuous_Map.Restrict S g = F
{P : Ereal × Ereal} (h : P.fst ≠ ⊤ ∨ P.Snd ≠ ⊥) (h' : P.fst ≠ ⊥ ∨ P.Snd ≠ ⊤) : Continuous_at (λ (P : Ereal × Ereal), P.fst + P.Snd) P
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {S : set α} {P : Filter ι} (h : TendstoUniformlyOn F F P S) (g : γ → α) : TendstoUniformlyOn (λ (n : ι), F n ∘ g) (F ∘ g) P (g ⁻¹' S)
{α : Type u} [TopologicalSpace α] (x : α) [(nhds_within x {x}ᶜ).Ne_IsBot] : Dense {x}ᶜ
{n : ℕ} {α : Fin (n + 1) → Type u} (q : Π (i : Fin (n + 1)), α i) : Fin.snoc (Fin.init q) (q (Fin.Last n)) = q
{R : Type u} {A : Type W} [CommSemiring R] [Semiring A] [Algebra R A] (r : R) (x y : A) : r • x * y = r • (x * y)
 : ¬Small Ordinal
{α : Type u} [PseudoEmetricSpace α] (E : set α) : Closure E = ⋂ (δ : ℝ) (h : 0 < δ), Metric.Cthickening δ E
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommGroup β] [HasScalar 𝕜 E] [module 𝕜 β] {S : set E} {F : E → β} : strict_Convex_on 𝕜 S F → strict_ConcaveOn 𝕜 S (-F)
{K : Type u} {v : Type v} [Field K] [AddCommGroup v] [module K v] [Finite_dimensional K v] {S : Submodule K v} (h : S < ⊤) : Finite_dimensional.finrank K ↥S < Finite_dimensional.finrank K v
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {F : ℝ → E} {A B : ℝ} {F' g : ℝ → E} (derivf : ∀ (x : ℝ), x ∈ set.Ico A B → HasDerivWithinAt F (F' x) (set.ici x) x) (derivg : ∀ (x : ℝ), x ∈ set.Ico A B → HasDerivWithinAt g (F' x) (set.ici x) x) (fcont : Continuous_on F (set.icc A B)) (gcont : Continuous_on g (set.icc A B)) (hi : F A = g A) (y : ℝ) (h : y ∈ set.icc A B) : F y = g y
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y : v} (hn : x ≠ y) (h : ∥x∥ = ∥y∥) : o.oangle y x = ↑Real.Pi - 2 • o.oangle (y - x) y
{R : Type u_1} {A : R} [Add_Semigroup R] (B : R) (ha : _Add_Right_regular A) : _Add_Right_regular (B + A) ↔ _Add_Right_regular B
{α : Type u_1} {G : Type u_5} [TopologicalSpace G] [AddCommGroup G] [topological_AddGroup G] {F : α → G} (hF : Summable F) : Filter.Tendsto F Filter.cofinite (nhds 0)
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] (F : ℂ → E) (z W : ℂ) (hD : DifferentiableOn ℝ F (set.Interval z.re W.re ×ℂ set.Interval z.im W.im)) (Hi : MeasureTheory.IntegrableOn (λ (z : ℂ), Complex.i • ⇑(fderiv ℝ F z) 1 - ⇑(fderiv ℝ F z) Complex.i) (set.Interval z.re W.re ×ℂ set.Interval z.im W.im) MeasureTheory.MeasureSpace.Volume) : (((∫ (x : ℝ) in z.re..W.re, F (↑x + ↑(z.im) * Complex.i)) - ∫ (x : ℝ) in z.re..W.re, F (↑x + ↑(W.im) * Complex.i)) + Complex.i • ∫ (y : ℝ) in z.im..W.im, F (↑(W.re) + ↑y * Complex.i)) - Complex.i • ∫ (y : ℝ) in z.im..W.im, F (↑(z.re) + ↑y * Complex.i) = ∫ (x : ℝ) in z.re..W.re, ∫ (y : ℝ) in z.im..W.im, Complex.i • ⇑(fderiv ℝ F (↑x + ↑y * Complex.i)) 1 - ⇑(fderiv ℝ F (↑x + ↑y * Complex.i)) Complex.i
(𝕜 : Type u) [nondiscrete_NormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace 𝕜] {r : ℝ} (rpos : 0 < r) {C : E} (h : IsCompact (metric.IsClosed_ball C r)) : Finite_dimensional 𝕜 E
{α : Type u} {β : Type v} [AddGroup α] [AddGroup β] {F : α → β} (hF : _AddGroup_hom F) : Function.Injective F ↔ ∀ (A : α), F A = 0 → A = 0
(m : ℕ) {n : ℕ} (hn : 0 < n) : (∃ (k : ℕ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {F : 𝕜 → F} {S : set 𝕜} : iterated_deriv_within n F S = ⇑((Continuous_MultilinearMap.Pi_Field_Equiv 𝕜 (Fin n) F).Symm) ∘ iterated_fderiv_within 𝕜 n F S
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {F : α → β} {S : set β} (hF : Continuous F) : F ⁻¹' Interior S ⊆ Interior (F ⁻¹' S)
{α : Type u_1} {β : Type u_2} [AddCommGroup α] [TopologicalSpace α] [topological_AddGroup α] {F : β → α} [t2_Space α] [DecidableEq β] (hF : Summable F) (B : β) : ∑' (n : β), F n = F B + ∑' (n : β), Ite (n = B) 0 (F n)
{R : Type u} [Ring R] (A : R) {n : ℕ} (h : n ≠ 0) : (Polynomial.x ^ n - ⇑Polynomial.C A).monic
{K : Type u_1} {v : K} {n : ℕ} [Linear_ordered_Field K] [FloorRing K] (hyp : n = 0 ∨ ¬(GeneralizedContinuedFraction.of v).TerminatedAt (n - 1)) : ↑(Nat.fib (n + 1)) ≤ (GeneralizedContinuedFraction.of v).denominators n
{α : Type u} {β : Type v} [complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [complete_LinearOrder β] [TopologicalSpace β] [OrderTopology β] {ι : sort u_1} {F : α → β} {g : ι → α} (Cf : Continuous_at F (supr g)) (Mf : Monotone F) (fbot : F ⊥ = ⊥) : F (⨆ (i : ι), g i) = ⨆ (i : ι), F (g i)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] [∀ (x Y : C), Subsingleton (x ⟶ Y)] (hC : CategoryTheory.Skeletal C) : CategoryTheory.Skeletal (D ⥤ C)
{K : Type u} [hring : CommRing K] [hdomain : IsDomain K] {P : Ratfunc K → Prop} (x : Ratfunc K) (F : ∀ (P q : Polynomial K), q ≠ 0 → P (Ratfunc.Mk P q)) : P x
{ι : Type u_1} {R : Type u_2} {N : Type u_5} [decι : DecidableEq ι] [Semiring R] [AddCommMonoid N] [module R N] (P : ι → Submodule R N) : supr P = (⇑(Dfinsupp.lsum ℕ) (λ (i : ι), (P i).Subtype)).Range
{α : Type u_1} [PartialOrder α] [SuccOrder α] [IsSuccArchimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ set.Ico m n → r (Order.Succ i) i) (hmn : m ≤ n) : Relation.refl_Trans_gen r n m
{x : Type u_1} [TopologicalSpace x] [NormalSpace x] (C : Urysohns.CU x) : Continuous C.lim
{α : Type u} {β : Type v} [DecidableEq β] [Fintype α] [Fintype β] (F : α → β) {n : ℕ} [Nonempty β] (hn : Fintype.Card β * n ≤ Fintype.Card α) : ∃ (y : β), n ≤ (Finset.Filter (λ (x : α), F x = y) Finset.Univ).Card
 : (λ (n : ℕ), ↑(Nat.fib n)) = λ (n : ℕ), (GoldenRatio ^ n - golden_Conj ^ n) / Real.sqrt 5
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {F : α → β} (hi : Inducing F) (ho : IsOpen (set.Range F)) : IsOpen_Map F
{α : Type u_3} [SemilatticeInf α] [NoMinOrder α] (A : α) : Filter.Map Coe Filter.at_IsBot = Filter.at_IsBot
{G : Type u_1} [Group G] {G' : Type u_2} [Group G'] [h : Group.IsNilpotent G] (F : G ≃* G') : Group.IsNilpotent G'
{A : Type u_1} (B : Type u_2) [Field A] [Ring B] [Algebra A B] [Nontrivial B] (A : A) : minpoly A (⇑(Algebra_Map A B) A) = Polynomial.x - ⇑Polynomial.C A
{α : Type u} [PseudoEmetricSpace α] {S t : set α} {r : Ennreal} (h1 : ∀ (x : α), x ∈ S → (∃ (y : α) (h : y ∈ t), HasEdist.edist x y ≤ r)) (h2 : ∀ (x : α), x ∈ t → (∃ (y : α) (h : y ∈ S), HasEdist.edist x y ≤ r)) : Emetric.Hausdorff_edist S t ≤ r
{R : Type u} [CommSemiring R] (l : List (Polynomial R)) (x : R) : Polynomial.Eval x l.Prod = (List.Map (Polynomial.Eval x) l).Prod
{F : Type v} [NormedGroup F] [NormedSpace ℂ F] {F : ℂ → F} (hF : Differentiable ℂ F) (hb : Metric.Bounded (set.Range F)) (z W : ℂ) : F z = F W
{n : Type u_4} [DecidableEq n] (v : n → ℝ) : (Matrix.Diagonal v)._hermitian
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {E : Type u_5} [CategoryTheory.Category E] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {L : CategoryTheory.GrothendieckTopology E} {F : C ⥤ D} (hu : CategoryTheory.CoverLifting J K F) {G : D ⥤ E} (hv : CategoryTheory.CoverLifting K L G) : CategoryTheory.CoverLifting J L (F ⋙ G)
{α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β] (F : MeasureTheory.SimpleFunc α β) : Measurable ⇑F
{C : Type u} [CategoryTheory.Category C] {D : Type u'} [CategoryTheory.Category D] [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Limits.has_Finite_products D] (F : C ⥤ D) {L : D ⥤ C} [CategoryTheory.cartesian_IsClosed C] [CategoryTheory.cartesian_IsClosed D] [CategoryTheory.Limits.PreservesLimits_of_shape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F] (h : L ⊣ F) (A : C) [i : CategoryTheory.IsIso (CategoryTheory.Exp_comparison F A)] : CategoryTheory.IsIso (CategoryTheory.frobenius_morphism F h A)
 : StrictMono (λ (n : ℕ), Nat.fib (n + 2))
{m : Type u_6} {N : Type u_7} [has_Mul m] [has_Mul N] (F : m ≃* N) (x y : m) : ⇑F (x * y) = ⇑F x * ⇑F y
{k : Type u_1} {G : Type u_2} {v : Type u_3} [CommSemiring k] [Group G] [AddCommMonoid v] [module k v] (ρ : Representation k G v) [Fintype G] [Invertible ↑(Fintype.Card G)] (v : v) : ⇑(ρ.average_Map) v ∈ ρ.invariants
{β : Type u} {α : Type v} [CommSemiring β] {S : Finset α} {i : α} {F g h : α → β} (hi : i ∈ S) (h1 : g i + h i = F i) (h2 : ∀ (j : α), j ∈ S → j ≠ i → g j = F j) (h3 : ∀ (j : α), j ∈ S → j ≠ i → h j = F j) : S.Prod (λ (i : α), g i) + S.Prod (λ (i : α), h i) = S.Prod (λ (i : α), F i)
{α : Type u_1} {n : ℕ} {S t : Finset α} : S ∈ Finset.powerset_len n t ↔ S ⊆ t ∧ S.Card = n
{α : Type u_1} {ι : Type u_4} (S : ι → set α) : (⋃ (i : ι), S i) = ⋃ (t : Finset ι) (i : ι) (h : i ∈ t), S i
{G : Type u_1} [AddGroup G] (h : AddMonoid.exponent_exists G) : AddMonoid._torsion G
{α : sort u_1} {β : sort u_2} {γ : sort u_3} {S₁ : Setoid α} {S₂ : Setoid β} {S₃ : Setoid γ} {P : Quotient S₁ → Quotient S₂ → Quotient S₃ → Prop} (q₁ : Quotient S₁) (q₂ : Quotient S₂) (q₃ : Quotient S₃) (h : ∀ (A₁ : α) (A₂ : β) (A₃ : γ), P (Quotient.Mk' A₁) (Quotient.Mk' A₂) (Quotient.Mk' A₃)) : P q₁ q₂ q₃
{R : Type u} {S : Type v} {A : Type W} [CommSemiring R] [CommSemiring S] [Semiring A] [Algebra R S] [Algebra S A] [Algebra R A] (h : Algebra_Map R A = (Algebra_Map S A).Comp (Algebra_Map R S)) : IsScalarTower R S A
{R : Type u_1} [Linear_ordered_Field R] [FloorRing R] {B : ℕ} (hb : 1 < B) {x : ℤ} {r : R} (hr : 0 < r) : ↑B ^ x ≤ r ↔ x ≤ Int.log B r
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace ↥K] (v : E) : ∃ (y : E) (h : y ∈ K) (z : E) (h : z ∈ Kᗮ), v = y + z
{m : Type u_1} {N : Type u_2} [has_Mul m] [has_Mul N] {F g : m →ₙ* N} {S : set m} (h : set.Eq_on ⇑F ⇑g S) : set.Eq_on ⇑F ⇑g ↑(Subsemigroup.Closure S)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (F : LocalHomeomorph E F) {F' : E ≃L[𝕜] F} {A : F} (ha : A ∈ F.to_local_Equiv.Target) (htff' : HasStrictFderivAt ⇑F ↑F' (⇑(F.Symm) A)) : HasStrictFderivAt ⇑(F.Symm) ↑(F'.Symm) A
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommGroup E] [module 𝕜 E] {S t : set E} (hc : Convex_Independent 𝕜 (λ (x : ↥t), ↑x)) (hs : S ⊆ t) : Convex_Independent 𝕜 (λ (x : ↥S), ↑x)
{α : Type u} [TopologicalSpace α] [t0_Space α] {S : set α} (hfin : S.Finite) (hne : S.Nonempty) (ho : IsOpen S) : ∃ (x : α) (h : x ∈ S), IsOpen {x}
{α : Type u} [DecidableEq α] [Fintype α] {P : Equiv.perm α → Prop} (F : Equiv.perm α) : P 1 → (∀ (F : Equiv.perm α) (x y : α), x ≠ y → P F → P (F * Equiv.Swap x y)) → P F
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : LocalHomeomorph α β} {S : set α} {t : set β} : e.to_local_Equiv.Source ∩ ⇑e ⁻¹' (e.to_local_Equiv.Target ∩ t) = e.to_local_Equiv.Source ∩ S → e._image S t
{α : sort u_1} {β : sort u_2} {γ : sort u_3} [has_Coe α β] [has_Coe_t β γ] (A : α) : ↑A = ↑↑A
{α : Type u} [PseudoMetricSpace α] {x : α} : metric.Inf_dist x ∅ = 0
{α : Type u_1} [Linear_ordered_Ring α] [Archimedean α] {x y : α} (hx : 1 ≤ x) (hy : 1 < y) : ∃ (n : ℕ), y ^ n ≤ x ∧ x < y ^ (n + 1)
{α : Type u_1} {β : Type u_2} {m : Type u_5} [CommMonoid m] {F : α → m} {g : β → α} (hg : set.inj_on g (Function.MulSupport (F ∘ g))) : finprod (λ (i : α), finprod (λ (h : i ∈ set.Range g), F i)) = finprod (λ (j : β), F (g j))
(K : Type u) (v : Type v) [DivisionRing K] [AddCommGroup v] [module K v] [IsNoetherian K v] : module.rank K v < Cardinal.aleph0
{A B C : ℤ} : fermat_42.Minimal A B C → fermat_42.Minimal B A C
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {A B : ℝ} (ha : 0 < A) (hb : 0 < B) (hab : A + B = 1) (h : ∀ (x y : E), ∥x∥ ≤ 1 → ∥y∥ ≤ 1 → x ≠ y → ∥A • x + B • y∥ < 1) : strict_Convex_Space ℝ E
(n : ℕ) (z : ℂ) : (Complex.cos z + Complex.sin z * Complex.i) ^ n = Complex.cos (↑n * z) + Complex.sin (↑n * z) * Complex.i
{C : Type u₁} [CategoryTheory.SmallCategory C] {ℰ : Type u₂} [CategoryTheory.Category ℰ] (A : C ⥤ ℰ) (P : Cᵒᵖ ⥤ Type u₁) (E₁ E₂ : ℰ) (g : E₁ ⟶ E₂) {C : CategoryTheory.Limits.Cocone ((CategoryTheory.Category_of_Elements.π P).Left_Op ⋙ A)} (t : CategoryTheory.Limits.IsColimit C) (k : C.x ⟶ E₁) : ⇑(CategoryTheory.Colimit_Adj.Restrict_yoneda_hom_Equiv A P E₂ t) (k ≫ g) = ⇑(CategoryTheory.Colimit_Adj.Restrict_yoneda_hom_Equiv A P E₁ t) k ≫ (CategoryTheory.Colimit_Adj.restricted_yoneda A).Map g
{L : FirstOrder.Language} {m : Type u_3} {N : Type u_4} {P : Type u_5} {q : Type u_6} [L.structure m] [L.structure N] [L.structure P] [L.structure q] (F : L.elementary_Embedding m N) (g : L.elementary_Embedding N P) (h : L.elementary_Embedding P q) : (h.Comp g).Comp F = h.Comp (g.Comp F)
{m : Type u_2} [AddCommGroup m] {A : Type u_1} [CommRing A] [module A m] (F : m →ₗ[A] m) (hF : IsUnit F) : IsUnit (⇑LinearMap.det F)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] (S : set P) : (affine_Span k S).direction = Vector_Span k S
{α : Type u} [PartialOrder α] [OrderTop α] {A : α} : IsMax A → A = ⊤
{α : Type u_1} [PseudoEmetricSpace α] {F : ℕ → α} (D : ℕ → Ennreal) (hF : ∀ (n : ℕ), HasEdist.edist (F n) (F n.Succ) ≤ D n) {A : α} (ha : Filter.Tendsto F Filter.at_top (nhds A)) : HasEdist.edist (F 0) A ≤ ∑' (m : ℕ), D m
{α : Type u} [TopologicalSpace α] {S : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), IsOpen (U i)) → (S ⊆ ⋃ (i : ι), U i) → (∃ (t : Finset ι), S ⊆ ⋃ (i : ι) (h : i ∈ t), U i)) : IsCompact S
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {x y : L} : x ∈ S → y ∈ S → x - y ∈ S
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] {F : ℝ → E} {t : ℝ} (hF : Function.Periodic F t) (hT : 0 < t) (t S : ℝ) : ∫ (x : ℝ) in t..t + t, F x = ∫ (x : ℝ) in S..S + t, F x
{G : Type u_1} [AddGroup G] (h : Add_Subgroup G) {x y : G} (hx : x ∈ h) (hy : y ∈ h) : x - y ∈ h
{u : ℕ → ℝ} (h : Subadditive u) (hbdd : BddBelow (set.Range (λ (n : ℕ), u n / ↑n))) : Filter.Tendsto (λ (n : ℕ), u n / ↑n) Filter.at_top (nhds h.lim)
{α : Type u_1} {m : Type u_5} {N : Type u_6} [AddCommMonoid m] [AddCommMonoid N] {S : set α} {F : α → m} (g : m →+ N) (h₀ : (S ∩ Function.Support F).Finite) : ⇑g (finsum (λ (j : α), finsum (λ (h : j ∈ S), F j))) = finsum (λ (i : α), finsum (λ (h : i ∈ S), ⇑g (F i)))
{γ : Type W} [Preorder γ] [OrderBot γ] (S : set γ) : BddBelow S
{α : Type u} [PseudoMetricSpace α] {S t u : set α} (Fin : Emetric.Hausdorff_edist S t ≠ ⊤) : metric.Hausdorff_dist S u ≤ metric.Hausdorff_dist S t + metric.Hausdorff_dist t u
{α : Type u_2} [DecidableEq α] {B : Finset (Finset α)} {n : ℕ} [Fintype α] (h : ∀ (A : α), n ≤ (Finset.Filter (HasMem.Mem A) B).Card) : Fintype.Card α * n ≤ B.Sum (λ (S : Finset α), S.Card)
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y z : v} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle y z + o.oangle x y = o.oangle x z
{t : ℝ} {g : ℝ → ℝ} (hg : Function.Periodic g t) (h_Int : ∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.MeasureSpace.Volume t₁ t₂) (h₀ : ∀ (x : ℝ), 0 < g x) (hT : 0 < t) : Filter.Tendsto (λ (t : ℝ), ∫ (x : ℝ) in 0..t, g x) Filter.at_top Filter.at_top
{α : Type u} (S : Finset α) : ↑S.Finite
{m : Type u_3} {N : Type u_4} [Monoid m] [Monoid N] {F : Type u_1} [Monoid_hom_class F m Nᵐᵒᵖ] (F : F) (l : List m) : Mul_Opposite.Unop (⇑F l.Prod) = (List.Map (Mul_Opposite.Unop ∘ ⇑F) l).reverse.Prod
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {F : J ⥤ C} {x : C} (h : CategoryTheory.coyoneda.obj (Opposite.Op x) ⋙ CategoryTheory.ulift_Functor ≅ F.cocones) {Y : C} (F : x ⟶ Y) : CategoryTheory.Limits.IsColimit.of_Nat_iso.Cocone_of_hom h F = (CategoryTheory.Limits.IsColimit.of_Nat_iso.Colimit_Cocone h).extend F
{m : Type u_2} (R : Type u_5) [Semiring R] [AddCommMonoid m] [module R m] (S : set m) : Submodule.Span R S = (Finsupp.Total ↥S m R Coe).Range
{R : Type u} {S : Type v} [CommSemiring R] [local_Ring R] [CommSemiring S] [local_Ring S] (F : R →+* S) [_local_Ring_hom F] (A : R) (h : A ∈ local_Ring.Maximal_Ideal R) : ⇑F A ∈ local_Ring.Maximal_Ideal S
{m₀ : Type u_1} [MulZeroOneClass m₀] : 0 = 1 → Subsingleton m₀
{α : Type u} (L : List α) {i j : ℕ} (h : i + j < L.length) : L.nth_LE (i + j) h = (List.Drop i L).nth_LE j _
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {S : set (E × F)} {P : E × F} : ContDiff_within_at 𝕜 n Prod.fst S P
{G : Type u_3} [Group G] : Group.fg G ↔ ∃ (S : set G), Subgroup.Closure S = ⊤ ∧ S.Finite
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} {x : E} : Differentiable_at 𝕜 F x → MdifferentiableAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F x
(R : Type u_1) (m : Type u_4) [Semiring R] [AddCommMonoid m] [module R m] (x : m) : Submodule.Span R {x} = (Linear_Map.to_Span_Singleton R m x).Range
{m n : ℕ} : Even (m ^ n) ↔ Even m ∧ n ≠ 0
{F : Type u_3} [InnerProductSpace ℝ F] [Finite_dimensional ℝ F] : Subgroup.Closure (set.Range (λ (v : F), reflection (Submodule.Span ℝ {v})ᗮ)) = ⊤
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {x y : v} (h : ∥x∥ = ∥y∥) : o.oangle x (x - y) = o.oangle (y - x) y
{R : Type u_1} [non_assoc_Ring R] [Nontrivial R] (hR : Ring_Char R ≠ 2) : -1 ≠ 1
{E : Type u_1} [AddCommGroup E] [Star_AddMonoid E] [module ℂ E] [Star_module ℂ E] (x : E) : ↑(⇑Star_module.re x) + Complex.i • ↑(⇑Star_module.im x) = x
{α : Type u} [Group α] [has_LE α] [CovariantClass α α has_Mul.Mul has_LE.LE] {A : α} : A⁻¹ ≤ 1 ↔ 1 ≤ A
{α : Type u_1} {ι : sort u_3} [conditionally_CompleteLattice α] {F g : ι → α} (B : BddBelow (set.Range F)) (h : ∀ (x : ι), F x ≤ g x) : infi F ≤ infi g
{α : Type u_2} [DecidableEq α] {B : Finset (Finset α)} {n : ℕ} [Fintype α] (h : ∀ (A : α), (Finset.Filter (HasMem.Mem A) B).Card = n) : B.Sum (λ (S : Finset α), S.Card) = Fintype.Card α * n
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {e e' : local_Equiv α β} {F F' : local_Equiv β γ} (hE : e ≈ e') (hF : F ≈ F') : e.Trans F ≈ e'.Trans F'
{α : Type u_1} [canonically_ordered_AddMonoid α] [HasSub α] [HasOrderedSub α] {A B C : α} [ContravariantClass α α has_Add.Add has_LE.LE] (h : C ≤ B) : A < B - C ↔ C + A < B
{α : Type u} [TopologicalSpace α] [t1_Space α] [∀ (x : α), (nhds_within x {x}ᶜ).Ne_IsBot] {S : set α} (hs : Dense S) {t : set α} (ht : t.Finite) : Dense (S  t)
{α : Type u_1} {β : Type u_2} [UniformSpace β] {F : α → β} {S : set α} {x : α} [TopologicalSpace α] (hx : x ∈ S) (L : ∀ (u : set (β × β)), u ∈ Uniformity β → (∃ (t : set α) (h : t ∈ nhds_within x S) (F : α → β), Continuous_within_at F S x ∧ ∀ (y : α), y ∈ t → (F y, F y) ∈ u)) : Continuous_within_at F S x
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} {S : Finset ι} {W : ι → k} (h : S.Sum (λ (i : ι), W i) = 0) (P : ι → P) : ⇑(S.weighted_vsub P) W ∈ Vector_Span k (set.Range P)
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [ordered_AddCommGroup β] [HasScalar 𝕜 E] [module 𝕜 β] {S : set E} {F : E → β} : strict_ConcaveOn 𝕜 S (-F) ↔ strict_Convex_on 𝕜 S F
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {F : ℝ → E} {ca cb : E} {A B : ℝ} (hF : IntervalIntegrable F MeasureTheory.MeasureSpace.Volume A B) (hmeas_A : StronglyMeasurableAtFilter F (nhds A) MeasureTheory.MeasureSpace.Volume) (hmeas_B : StronglyMeasurableAtFilter F (nhds B) MeasureTheory.MeasureSpace.Volume) (ha : Filter.Tendsto F (nhds A ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds ca)) (hb : Filter.Tendsto F (nhds B ⊓ MeasureTheory.MeasureSpace.Volume.ae) (nhds cb)) : fderiv ℝ (λ (P : ℝ × ℝ), ∫ (x : ℝ) in P.fst..P.Snd, F x) (A, B) = (Continuous_Linear_Map.Snd ℝ ℝ ℝ).Smul_Right cb - (Continuous_Linear_Map.fst ℝ ℝ ℝ).Smul_Right ca
{α : Type u} {A B : α} [Mul_Zero_class α] [Preorder α] [Zero_LT.Mul_Pos_StrictMono α] (ha : 0 < A) (hb : 0 < B) : 0 < A * B
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_Add.Add has_LT.LT] {A B : α} (ha : A ≤ 0) (hb : B < 0) : A + B < 0
{α : Type u_1} [conditionally_CompleteLattice α] (A : α) : HasSup.Sup {A} = A
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] [Fintype α] [Fintype β] (F : α → β) {W : α → m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] [Nonempty β] (hb : Finset.Univ.Sum (λ (x : α), W x) ≤ Fintype.Card β • B) : ∃ (y : β), (Finset.Filter (λ (x : α), F x = y) Finset.Univ).Sum (λ (x : α), W x) ≤ B
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMaxOrder α] [DenselyOrdered α] {A : α} {S : set α} : S ∈ nhds_within A (set.ici A) ↔ ∃ (u : α), A < u ∧ set.icc A u ⊆ S
{𝕜 : Type u_1} {F : Type u_3} [_R_or_C 𝕜] [AddCommGroup F] [module 𝕜 F] [C : InnerProductSpace.core 𝕜 F] (x y : F) : _R_or_C.Abs (HasInner.inner x y) * _R_or_C.Abs (HasInner.inner y x) ≤ ⇑_R_or_C.re (HasInner.inner x x) * ⇑_R_or_C.re (HasInner.inner y y)
{α : Type u_1} [LinearOrder α] [PredOrder α] [_Pred_Archimedean α] (r : α → α → Prop) {n m : α} (hr : Reflexive r) (h1 : ∀ (i : α), i ∈ set.ioc m n → r i (Order.Pred i)) (h2 : ∀ (i : α), i ∈ set.ioc n m → r (Order.Pred i) i) : Relation.TransGen r n m
{R : Type v} [CommRing R] {n : Type u_1} [Unique n] [DecidableEq n] [Fintype n] (A : Matrix n n R) : A.det = A Inhabited.Default Inhabited.Default
{C : Type u} [CategoryTheory.Category C] {x Y : C} {F g : x ⟶ Y} (h₀ : F = g) {C : CategoryTheory.Limits.Cofork F g} (h : CategoryTheory.Limits.IsColimit C) : CategoryTheory.IsIso C.π
{x : ℝ} (hx : 0 ≤ x) : x + 1 ≤ Real.Exp x
(P : ℕ) [hp : Fact (Nat.Prime P)] {q r : ℚ} (hne : padic_norm P q ≠ padic_norm P r) : padic_norm P (q + r) = LinearOrder.max (padic_norm P q) (padic_norm P r)
 : fib_rec._solution (has_Pow.Pow golden_Conj)
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (h : ↑(S.topological_Closure) ≠ set.Univ) : ∥S.normed_Mk∥ = 1
{G : Type u_1} [Group G] (h : ℕ → Subgroup G) (hH : IsAscendingCentralSeries h) (n : ℕ) : h n ≤ upper_central_series G n
{G : Type W} [TopologicalSpace G] [AddGroup G] [topological_AddGroup G] {m : Type u_1} {hom : Type u_2} [AddZeroClass m] [TopologicalSpace m] [has_Continuous_Add m] [AddMonoid_hom_class hom G m] (F : hom) (hF : Continuous_at ⇑F 0) : Continuous ⇑F
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] [LocallyCompactSpace α] [t2_Space α] [t2_Space β] {ι : Type u_3} {l : Filter ι} [l.Ne_IsBot] (F : ι → C(α, β)) : (∃ (F : C(α, β)), Filter.Tendsto F l (nhds F)) ↔ ∀ (S : set α), IsCompact S → (∃ (F : C(↥S, β)), Filter.Tendsto (λ (i : ι), Continuous_Map.Restrict S (F i)) l (nhds F))
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {S : set E} (hscomp : IsCompact S) (hAconv : Convex ℝ S) : Closure (⇑(Convex_hull ℝ) (set.ExtremePoints ℝ S)) = S
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [nondiscrete_NormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (F : MultilinearMap 𝕜 E G) {C : ℝ} (hC : 0 ≤ C) (h : ∀ (m : Π (i : ι), E i), ∥⇑F m∥ ≤ C * Finset.Univ.Prod (λ (i : ι), ∥m i∥)) : ∥F.Mk_Continuous C h∥ ≤ C
{α : Type u} {β : Type v} [Linear_ordered_Field α] [TopologicalSpace α] [OrderTopology α] {l : Filter β} {F g : β → α} {C : α} (hC : 0 < C) (hF : Filter.Tendsto F l Filter.at_top) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (λ (x : β), F x * g x) l Filter.at_top
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) : hb.Conj_lie.Symm = hb.Conj_lie
{ι : Type u} {F g : ι → ℝ} {P q : ℝ} (hpq : P.IsConjugateExponent q) {A B : ℝ} (hA : 0 ≤ A) (hB : 0 ≤ B) (hF : ∀ (i : ι), 0 ≤ F i) (hg : ∀ (i : ι), 0 ≤ g i) (hF_Sum : has_Sum (λ (i : ι), F i ^ P) (A ^ P)) (hg_Sum : has_Sum (λ (i : ι), g i ^ q) (B ^ q)) : ∃ (C : ℝ), 0 ≤ C ∧ C ≤ A * B ∧ has_Sum (λ (i : ι), F i * g i) C
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P : C} : Transitive (CategoryTheory.Abelian.PseudoEqual P)
{L : FirstOrder.Language} {m : Type W} [L.structure m] {S : set m} : S ⊆ ↑(⇑(FirstOrder.Language.Substructure.Closure L) S)
{g : Matrix.special_Linear_Group (Fin 2) ℤ} (z : UpperHalfPlane) {P : Fin 2 → ℤ} (hp : _IsCoprime (P 0) (P 1)) (hg : ↑g 1 = P) : ↑(g • z) = ↑(⇑(modular_Group.lc_row0 P) ↑↑g) / (↑(P 0) ^ 2 + ↑(P 1) ^ 2) + (↑(P 1) * ↑z - ↑(P 0)) / ((↑(P 0) ^ 2 + ↑(P 1) ^ 2) * (↑(P 0) * ↑z + ↑(P 1)))
{B : Type u_3} {S : B} {m : Type u_1} [CommMonoid m] [set_like B m] [Submonoid_class B m] {ι : Type u_2} {t : Finset ι} {F : ι → m} (h : ∀ (C : ι), C ∈ t → F C ∈ S) : t.Prod (λ (C : ι), F C) ∈ S
(F : ℝ → ℝ) {A B : ℝ} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hfd : DifferentiableOn ℝ F (set.Ioo A B)) (g : ℝ → ℝ) (hgc : Continuous_on g (set.icc A B)) (hgd : DifferentiableOn ℝ g (set.Ioo A B)) : ∃ (C : ℝ) (h : C ∈ set.Ioo A B), (g B - g A) * deriv F C = (F B - F A) * deriv g C
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (hp : 0 < P.radius) : 0 < (P.Right_Inv i).radius
{A : Type u_2} [CommRing A] [IsDomain A] : IsDedekindDomain A ↔ IsDedekindDomain_Inv A
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (v : v) (nz : v ≠ 0) : Finite_dimensional.finrank K v = 1 ↔ Submodule.Span K {v} = ⊤
{v : Type u_1} [InnerProductSpace ℝ v] (x y : v) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ InnerProductGeometry.angle x y = Real.Pi / 2
{m : Type u_1} [has_Mul m] {r S : m → m → Prop} (h : ∀ (x y : m), r x y → S x y) : Con_gen r ≤ Con_gen S
(x : AlgebraicGeometry.LocallyRingedSpace) (r : ↥(AlgebraicGeometry.LocallyRingedSpace.Γ.obj (Opposite.Op x))) : x.toΓ_spec_Map_basic_IsOpen r = x.to_RingedSpace.basic_IsOpen r
{α : Type u} {A B : α} [MulZeroOneClass α] [PartialOrder α] [Zero_LT.Mul_Pos_Mono α] (ha : 1 ≤ A) (hb : 1 ≤ B) (B0 : 0 ≤ B) : 1 ≤ A * B
{n : ℕ} (hn : Even n) : Convex_on ℝ set.Univ (λ (x : ℝ), x ^ n)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {n : ℕ} (hs : IsOpen S) : ContDiff_on 𝕜 ↑(n + 1) F S ↔ DifferentiableOn 𝕜 F S ∧ ContDiff_on 𝕜 ↑n (λ (y : E), fderiv 𝕜 F y) S
{α : Type u_1} [DecidableEq α] {S t u : Multiset α} : S - t ≤ u ↔ S ≤ u + t
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] [LocallyCompactSpace α] : Continuous Coe_fn
{α : Type u} [TopologicalSpace α] [RegularSpace α] {x y : α} (h : x ≠ y) : ∃ (U₁ : set α) (h : U₁ ∈ nhds x) (v₁ : set α) (h : v₁ ∈ nhds x) (U₂ : set α) (h : U₂ ∈ nhds y) (v₂ : set α) (h : v₂ ∈ nhds y), IsClosed v₁ ∧ IsClosed v₂ ∧ IsOpen U₁ ∧ IsOpen U₂ ∧ v₁ ⊆ U₁ ∧ v₂ ⊆ U₂ ∧ U₁ ∩ U₂ = ∅
{α : Type u_1} [comm_Semigroup α] {A B : α} (h : A ∣ B) (C : α) : A ∣ C * B
{G₀ : Type u_1} {G₀' : Type u_2} [Group_with_Zero G₀] [Group_with_Zero G₀'] (F : G₀ →*₀ G₀') (x : G₀) (n : ℤ) : ⇑F (x ^ n) = ⇑F x ^ n
{α : Type u} {β : Type v} {γ : Type W} [Preorder α] [Preorder β] [Preorder γ] {F : α → β → γ} {S : set α} {t : set β} (h₀ : ∀ (B : β), Monotone (Function.Swap F B)) (h₁ : ∀ (A : α), Monotone (F A)) : BddBelow S → BddBelow t → BddBelow (set.image2 F S t)
{P : ℕ → Prop} [Decidable_Pred P] {n : ℕ} : ¬P n → Nat.count P (n + 1) = Nat.count P n
{m : Type u_1} [Group m] (C : Con m) {W x y z : m} : ⇑C W x → ⇑C y z → ⇑C (W / y) (x / z)
{α : Type u} [AddCommGroup α] : _AddGroup_hom HasNeg.Neg
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [Field k] [AddCommGroup E] [module k E] [AddTorsor E PE] (F : k → PE) (A B r : k) : ⇑(affine_Map.line_Map (slope F (⇑(affine_Map.line_Map A B) r) B) (slope F A (⇑(affine_Map.line_Map A B) r))) r = slope F A B
 : ∃ (F : Nat.Partrec.Code → ℕ → Nat.Partrec.Code), Computable₂ F ∧ ∀ (C : Nat.Partrec.Code) (n x : ℕ), (F C n).Eval x = C.Eval (Nat.mkpair n x)
{k : Type u_1} {v : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] [Fintype ι] {P : ι → P} (hi : AffineIndependent k P) {n : ℕ} (hc : Fintype.Card ι = n + 1) : Finite_dimensional.finrank k ↥(Vector_Span k (set.Range P)) = n
{α : Type u} {L₁ L₂ : List (α × Bool)} : free_Group.red L₁ L₂ → L₂ <+ L₁
(P q : ℕ) [Fact (Nat.Prime P)] [Fact (Nat.Prime q)] (hp1 : P ≠ 2) (hq1 : q ≠ 2) (hpq : P ≠ q) : Zmod.legendre_Sym q ↑P * Zmod.legendre_Sym P ↑q = (-1) ^ (P / 2 * (q / 2))
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] [TopologicalSpace Y] [NormalSpace Y] (F : C(x, ℝ)) {t : set ℝ} {e : x → Y} [hs : t.Ord_connected] (hF : ∀ (x : x), ⇑F x ∈ t) (hne : t.Nonempty) (hE : IsClosed_Embedding e) : ∃ (g : C(Y, ℝ)), (∀ (y : Y), ⇑g y ∈ t) ∧ ⇑g ∘ e = ⇑F
{K : Type u} {A : Type v} [Field K] [Ring A] [Algebra K A] {x : A} : IsAlgebraic K x ↔ IsIntegral K x
{α : Type u_1} [MeasurableSpace α] [Measurable_Singleton_class α] {S : set α} (u t : set α) (hs : S.Finite) : ⇑(ProbabilityTheory.Cond_count (S ∩ u)) t * ⇑(ProbabilityTheory.Cond_count S) u + ⇑(ProbabilityTheory.Cond_count (S ∩ uᶜ)) t * ⇑(ProbabilityTheory.Cond_count S) uᶜ = ⇑(ProbabilityTheory.Cond_count S) t
{α : Type u_1} [Semigroup α] {A B : α} (h : A ∣ B) (C : α) : A ∣ B * C
{R : Type u_1} [Linear_ordered_Field R] {m : Type u_2} [AddCommGroup m] [module R m] {v₁ v₂ : m} (h : SameRay R v₁ v₂) : ∃ (u : m) (A B : R), 0 ≤ A ∧ 0 ≤ B ∧ A + B = 1 ∧ v₁ = A • u ∧ v₂ = B • u
{α : Type u} {β : Type v} [DecidableEq β] {S : Finset α} {t : Finset β} {F : α → β} {n : ℕ} (hF : ∀ (A : α), A ∈ S → F A ∈ t) (hn : t.Card * n < S.Card) : ∃ (y : β) (h : y ∈ t), n < (Finset.Filter (λ (x : α), F x = y) S).Card
{α : Type u} [Preorder α] {A : α} {S t P : set α} (hs : IsLub S A) (hp : IsLub P A) (hst : S ⊆ t) (htp : t ⊆ P) : IsLub t A
(n : ℕ) (R : Type u_1) [Ring R] : Polynomial.Map (Int.cast_Ring_hom R) (Polynomial.cyclotomic n ℤ) = Polynomial.cyclotomic n R
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F = 2) {A : F} (ha : A ≠ 0) : Char.quadratic_Char F A = 1
{R : Type u} {ι : Type W} (S : Finset ι) [CommSemiring R] [no_Zero_divisors R] (F : ι → Polynomial R) (h : ∀ (i : ι), i ∈ S → F i ≠ 0) : (S.Prod (λ (i : ι), F i)).Nat_degree = S.Sum (λ (i : ι), (F i).Nat_degree)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {F g : ℝ → E} {x : ℝ} (F_Diff : ∀ (y : ℝ), y ≠ x → HasDerivAt F (g y) y) (hF : Continuous_at F x) (hg : Continuous_at g x) : HasDerivAt F (g x) x
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {r : ℝ} (hr : 0 ≤ r) (x : E) : x +ᵥ r • metric.IsClosed_ball 0 1 = metric.IsClosed_ball x r
(n k : ℕ) : n.asc_factorial k = (n + k).factorial / n.factorial
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x : v) {r₁ r₂ : ℝ} : 2 • hb.oangle (r₁ • x) (r₂ • x) = 0
{v : Type u} [Fintype v] {G : SimpleGraph v} [Decidable_Rel G.Adj] {v W : v} (h : G.Adj v W) : Fintype.Card ↥(G.CommonNeighbors v W) < G.degree v
{R : Type u} [CommRing R] {n : Type W} [DecidableEq n] [Fintype n] (m : Matrix n n R) : ⇑(Polynomial.aeval m) m.charpoly = 0
(C : Type u_1) [CategoryTheory.Category C] : CategoryTheory.IsIdempotentComplete C ↔ ∀ (x : C) (P : x ⟶ x), P ≫ P = P → CategoryTheory.Limits.HasEqualizer (𝟙 x) P
(𝕜 : Type v) [_R_or_C 𝕜] {E : Type u} [NormedGroup E] [NormedSpace 𝕜 E] (x : E) : ∃ (g : E →L[𝕜] 𝕜), ∥g∥ ≤ 1 ∧ ⇑g x = ↑∥x∥
{α : Type u} [PseudoEmetricSpace α] (E : set α) : Closure E = ⋂ (δ : ℝ) (h : 0 < δ), Metric.Thickening δ E
{R : Type u} [Semiring R] {A B : AddMonoid_Algebra R ℕ} : {to_Finsupp := A} = {to_Finsupp := B} ↔ A = B
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {F : F → G} {x : E × F} (hF : ContDiff_at 𝕜 n F x.Snd) : ContDiff_at 𝕜 n (λ (x : E × F), F x.Snd) x
(n : ℕ) : Finset.Univ = Finset.Cons 0 (Finset.Map {ToFun := Fin.Succ n, inj' := _} Finset.Univ) _
{n : ℕ} {α : Type u_1} {β : Type u_2} (F : β → α → β) (B : β) (v : Vector α n) : (Vector.scanl F B v).head = B
{α : Type u_1} {β : Type u_2} [LinearOrder α] [SuccOrder α] [IsSuccArchimedean α] [LinearOrder β] {F : α → β} (hF : Monotone F) (m n : α) : (⋃ (i : α) (h : i ∈ set.Ico m n), set.ioc (F i) (F (Order.Succ i))) = set.ioc (F m) (F n)
{n m : ℕ} (h : n ≠ m) : _IsCoprime (Polynomial.cyclotomic n ℚ) (Polynomial.cyclotomic m ℚ)
{ι : Type u} (S : Finset ι) (W z : ι → Nnreal) (hw' : S.Sum (λ (i : ι), W i) = 1) (n : ℕ) : S.Sum (λ (i : ι), W i * z i) ^ n ≤ S.Sum (λ (i : ι), W i * z i ^ n)
{R : Type u_4} {S : Type u_5} [non_assoc_Semiring R] [non_assoc_Semiring S] (F : R ≃+* S) : ↑F.to_AddMonoid_hom = ↑F.to_AddMonoid_hom
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) (h : IsUnit A.det) : A⁻¹.Mul A = 1
{α : Type u} [PseudoMetricSpace α] {S : set α} {x : α} {r : ℝ} (hs : S.Nonempty) : metric.Inf_dist x S < r ↔ ∃ (y : α) (h : y ∈ S), HasDist.dist x y < r
{m : Type u_1} [AddCommMonoid m] {S : set m} (hs : _Add_Submonoid S) (m : Multiset m) : (∀ (A : m), A ∈ m → A ∈ S) → m.Sum ∈ S
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {F : R →+* S} {S : S} (h : S ∈ set.Range ⇑F) : ⇑Polynomial.C S ∈ Polynomial.lifts F
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] (S1 S2 : AffineSubspace k P) : (S1 ⊓ S2).direction ≤ S1.direction ⊓ S2.direction
{P : ℕ} (hp : 1 < P) : padic_val_rat P ↑P = 1
{α : Type u} {l₁ l₂ : List α} {n : ℕ} : List.take n (l₁ ++ l₂) = List.take n l₁ ++ List.take (n - l₁.length) l₂
 : set.inj_on Nat.factorization {x : ℕ | x ≠ 0}
{m : Type u_1} [AddZeroClass m] (S : Add_Submonoid m) : S = ⊥ ∨ Nontrivial ↥S
{𝕜 : Type u_1} {E : Type u_2} [Linear_ordered_Field 𝕜] [AddCommGroup E] [module 𝕜 E] {x : E} {S : set E} : Star_Convex 𝕜 x S ↔ ∀ ⦃y : E⦄, y ∈ S → ∀ ⦃A B : 𝕜⦄, 0 ≤ A → 0 ≤ B → 0 < A + B → (A / (A + B)) • x + (B / (A + B)) • y ∈ S
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : ∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * HasInner.inner x y + ∥y∥ ^ 2
{β : Type u} {α : Type v} [CommMonoid β] [Fintype α] [DecidableEq α] (S : Finset α) (F : α → β) : S.Prod (λ (i : α), F i) * Sᶜ.Prod (λ (i : α), F i) = Finset.Univ.Prod (λ (i : α), F i)
{α : Type uu} {r : α → α → Prop} [Decidable_Rel r] {l : List α} (h : List.Sorted r l) : List.insertion_sort r l = l
{α : Type u} [HasSubset α] {A B : α} [IsAntisymm α HasSubset.Subset] (h : A ⊆ B) (h' : B ⊆ A) : B = A
{x k l : ℕ} (W : 1 < x) : x ^ k ∣ x ^ l ↔ k ≤ l
{α : Type u_1} [IsEmpty α] : Finset.Univ = ∅
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z → B} [TopologicalSpace Z] [Nonempty F] (h : IsTopologicalFiberBundle F Proj) : Function.Surjective Proj
{m : Type u_1} [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (m N P : Matrix m m R) : ((m.Mul N).Mul P).det = ((m.Mul P).Mul N).det
{α : Type u} {β : Type v} [Group α] [MulAction α β] (g : α) (x : β) : MulAction.Stabilizer α (g • x) = Subgroup.Map (Mul_Equiv.to_Monoid_hom (⇑Mul_aut.Conj g)) (MulAction.Stabilizer α x)
{n : ℕ} {i : Fin (n + 2)} {j : Fin (n + 1)} (h : ⇑Fin.cast_Succ j < i) : SimplexCategoryδ i.Succ ≫ SimplexCategoryσ (⇑Fin.cast_Succ j) = SimplexCategoryσ j ≫ SimplexCategoryδ i
{𝕜 : Type u_3} {E : Type u_4} [NormedField 𝕜] [semi_NormedGroup E] [NormedSpace 𝕜 E] {r : ℝ} : Balanced 𝕜 (Metric.Ball 0 r)
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {F : α → β} {P : Filter ι} (h : TendstoUniformly F F P) (x : α) : Filter.Tendsto (λ (n : ι), F n x) P (nhds (F x))
{K : Type u} [Field K] {S t : Subfield K} (h : ∀ (x : K), x ∈ S ↔ x ∈ t) : S = t
{α : Type u_3} {β : Type u_4} [Linear_ordered_Field α] {l : Filter β} {F : β → α} {r : α} (hr : 0 < r) (hF : Filter.Tendsto F l Filter.at_IsBot) : Filter.Tendsto (λ (x : β), F x * r) l Filter.at_IsBot
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.Limits.HasCokernels C] [∀ {x Y : C} (F : x ⟶ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimage_image_comparison F)] : CategoryTheory.Limits.HasImages C
{R : Type u} {A₁ : Type v} {A₂ : Type W} [CommSemiring R] [Semiring A₁] [Semiring A₂] [Algebra R A₁] [Algebra R A₂] (e : A₁ ≃ₐ[R] A₂) : ↑↑e = ↑↑e
{m : Type u_1} [AddZeroClass m] (C : Add_Con m) : Add_Con.Ker C.Mk' = C
{J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ Mon_) [CategoryTheory.IsFiltered J] (x y : Σ (j : J), ↥(F.obj j)) (k : J) (F : x.fst ⟶ k) (g : y.fst ⟶ k) : Mon_.FilteredColimits.m.Mk F x * Mon_.FilteredColimits.m.Mk F y = Mon_.FilteredColimits.m.Mk F ⟨k, ⇑(F.Map F) x.Snd * ⇑(F.Map g) y.Snd⟩
{α : Type u} [PseudoMetricSpace α] {S : set α} {x : α} (h : IsClosed S) (hs : S.Nonempty) : x ∉ S ↔ 0 < metric.Inf_dist x S
(cf cg : Nat.Partrec.Code) (A k : ℕ) : (cf.prec cg).Eval (Nat.mkpair A k.Succ) = (cf.prec cg).Eval (Nat.mkpair A k) >>= λ (ih : ℕ), cg.Eval (Nat.mkpair A (Nat.mkpair k ih))
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {F : 𝕜 → F} : iterated_deriv n F = ⇑((Continuous_MultilinearMap.Pi_Field_Equiv 𝕜 (Fin n) F).Symm) ∘ iterated_fderiv 𝕜 n F
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {F : α → β × γ} {x : α} (hF : Continuous_at F x) : Continuous_at (λ (A : α), (F A).fst) x
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z → B} [TopologicalSpace Z] [Nonempty F] (h : IsTopologicalFiberBundle F Proj) : QuotientMap Proj
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] {A B : α} (hab : A ≠ B) : Closure (set.Ioo A B) = set.icc A B
{m : Type u_3} {N : Type u_4} [MulZeroOneClass m] [MulZeroOneClass N] {F g : m →*₀ N} : F = g ↔ ∀ (x : m), ⇑F x = ⇑g x
{α : Type u_1} [has_LT α] {A B : α} {o : Ordering} : o.compares B A → o.Swap.compares A B
{α : Type u} [Group α] (g : Group_topology α) : Continuous (λ (P : α × α), P.fst * P.Snd)
{α : Type u} [PseudoMetricSpace α] {S t : set α} : Metric.Bounded (S ∪ t) ↔ Metric.Bounded S ∧ Metric.Bounded t
{x : Type u} [Preorder x] {x y : x} (h : x ⟶ y) : x ≤ y
{v : Type u} [Quiver v] (r : v) [Quiver.RootedConnected r] {A : v} (P : Quiver.Path r A) : (Quiver.shortest_Path r A).length ≤ P.length
{𝕜 : Type u_1} [_R_or_C 𝕜] {m : Type u_5} {n : Type u_6} [Fintype m] [DecidableEq m] [Fintype n] [DecidableEq n] (A : Matrix m n 𝕜) : ⇑Matrix.to_lin' A.Conj_transpose = ⇑LinearMap.Adjoint (⇑Matrix.to_lin' A)
{α : Type u} [PseudoMetricSpace α] {x y : α} : metric.Inf_dist x {y} = HasDist.dist x y
{R : Type u_1} {A B : R} [Semigroup R] (Ab : IsRegular (A * B)) (ba : IsRegular (B * A)) : IsRegular A ∧ IsRegular B
{α : Type u_1} {β : Type u_2} [LinearOrder α] [SuccOrder α] [Preorder β] {F : α → β} (hF : Monotone F) : Pairwise (Disjoint on λ (n : α), set.Ico (F n) (F (Order.Succ n)))
{α : Type u} {A B : α} [MulOneClass α] [has_Zero α] [Preorder α] [Zero_LT.Mul_Pos_StrictMono α] (ha : 1 < A) (hb : 1 < B) (B0 : 0 < B) : 1 < A * B
{α : Type u_1} [has_LT α] {A B : α} : B < A → ⇑order_dual.to_dual A < ⇑order_dual.to_dual B
{α : Type u} [AddGroup α] [has_LT α] [CovariantClass α α (Function.Swap has_Add.Add) has_LT.LT] {A B : α} : A < B → A - B < 0
(R : Type u_1) [has_One R] [HasNeg R] : Cardinal.Mk (Quaternion R) = Cardinal.Mk R ^ 4
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} [DecidableEq β'] [DecidableEq γ] [DecidableEq δ] {S : Finset α} {t : Finset β} {F : α → β' → γ} {g : β → β'} {F' : α → β → δ} {g' : δ → γ} (h_Right_comm : ∀ (A : α) (B : β), F A (g B) = g' (F' A B)) : Finset.image₂ F S (Finset.image g t) = Finset.image g' (Finset.image₂ F' S t)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) : hb.oangle y x = -hb.oangle x y
{F : ℝ → ℝ} {A : ℝ} (h : IsLocalMin F A) : deriv F A = 0
{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] {n : Type W} [Nontrivial R] {B : BilinForm R m} {v : Basis n R m} (h : B._Ortho ⇑v) (hB : B.nondegenerate) (i : n) : ¬B.IsOrtho (⇑v i) (⇑v i)
{ι : Type u_1} {R₂ : Type u_7} {m₂ : Type u_8} [CommRing R₂] [AddCommGroup m₂] [module R₂ m₂] [DecidableEq ι] (e : Basis ι R₂ m₂) {W : ι → R₂} (hw : ∀ (i : ι), IsUnit (W i)) : e.to_Matrix ⇑(e.IsUnit_Smul hw) = Matrix.Diagonal W
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) {x : L} : x ∈ S → -x ∈ S
{A B : Prop} (h₁ : A → B) (h₂ : ¬B) : ¬A
{α : Type u_2} [Bornology α] {S : set α} : Bornology._cobounded S → Bornology._bounded Sᶜ
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {F : E → G} {S : set E} {C : Nnreal} (hF : DifferentiableOn 𝕜 F S) (bound : ∀ (x : E), x ∈ S → ∥fderiv_within 𝕜 F S x∥₊ ≤ C) (hs : Convex ℝ S) : LipschitzOnWith C F S
{m : Type u} [MulOneClass m] (A : m) : SemiconjBy A 1 1
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {F G : C ⥤ D} (α : F ⟶ G) [∀ (x : C), CategoryTheory.Mono (α.App x)] : CategoryTheory.Mono α
{m : Type u_1} [CommMonoid m] {S : Submonoid m} {N : Type u_2} [CommMonoid N] {F : m →* N} (h : ∀ (y : ↥S), IsUnit (⇑F ↑y)) (y : ↥S) (W z : N) : W * ↑(⇑(IsUnit.Lift_Right (F.Restrict S) h) y)⁻¹ = z ↔ W = ⇑F ↑y * z
{K : Type u} [Field K] (S : Subfield K) : 1 ∈ S
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] (O : Finset C) : ∃ (S : C), ∀ {x : C}, x ∈ O → Nonempty (S ⟶ x)
{α : Type u_1} {β : Type u_2} {Op : β → β → β} [hc : IsCommutative β Op] [ha : IsAssociative β Op] {F : α → β} {B : β} {S : Finset α} {g : α → β} (hb : Op B B = B) (P : α → Prop) [Decidable_Pred P] : Finset.Fold Op B (λ (i : α), Ite (P i) (F i) (g i)) S = Op (Finset.Fold Op B F (Finset.Filter P S)) (Finset.Fold Op B g (Finset.Filter (λ (i : α), ¬P i) S))
{F : Type u_1} [Field F] [Fintype F] : IsSquare (-1) ↔ Fintype.Card F % 4 ≠ 3
(F : ↥(MeasureTheory.Lp ℂ 2 haar_Circle)) : has_Sum (λ (i : ℤ), ⇑(⇑(fourier_series.repr) F) i • fourier_Lp 2 i) F
{K : Type u_1} {n : ℕ} {g : GeneralizedContinuedFraction K} [DivisionRing K] : g.convergents' (n + 1) = (g.squash_gcf n).convergents' n
{R : Type u} [Ring R] [strong_RankCondition R] {m : Type v} [AddCommGroup m] [module R m] {ι : Type u_1} (B : Basis ι R m) (h : module.rank R m < Cardinal.aleph0) : Nonempty (Fintype ι)
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {C : ℂ} {r R : ℝ} (h0 : 0 < r) (hle : r ≤ R) {F : ℂ → E} {S : set ℂ} (hs : S.countable) (hc : Continuous_on F (metric.IsClosed_ball C R  Metric.Ball C r)) (hD : ∀ (z : ℂ), z ∈ Metric.Ball C R  metric.IsClosed_ball C r  S → Differentiable_at ℂ F z) : ∮ (z : ℂ) in C(C, R), (z - C)⁻¹ • F z = ∮ (z : ℂ) in C(C, r), (z - C)⁻¹ • F z
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) (i : Fin (n + 1)) : S.points_with_circumcenter (Affine.Simplex.points_with_circumcenter_Index.point_Index i) = S.points i
{C : Type u₁} [CategoryTheory.Category C] (x : Type v₁) [CategoryTheory.Limits.HasProducts_of_shape x C] : CategoryTheory.Limits.HasCoproductsOfShape x Cᵒᵖ
{α : Type u_1} [TopologicalSpace α] {γ : Type u_4} [Linear_ordered_AddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] {F g : α → γ} (hF : LowerSemicontinuous F) (hg : LowerSemicontinuous g) (hcont : ∀ (x : α), Continuous_at (λ (P : γ × γ), P.fst + P.Snd) (F x, g x)) : LowerSemicontinuous (λ (z : α), F z + g z)
{β : Type u_2} [EmetricSpace β] {A : β} {r : Ennreal} (x y : ↥(Emetric.Ball A r)) : HasEdist.edist x.val y.val ≠ ⊤
{α : Type u} [AddGroup α] [has_LE α] [CovariantClass α α has_Add.Add has_LE.LE] {A B C : α} : A + B ≤ C → B ≤ -A + C
{α : Type u} [TopologicalSpace α] {S : set α} (h : IsTotallySeparated S) : IsTotallyDisconnected S
{𝕜 : Type u_1} {E : Type u_2} [NormedField 𝕜] [AddCommGroup E] [module 𝕜 E] [TopologicalSpace E] [has_Continuous_Smul 𝕜 E] (x : E) : Bornology._vonN_bounded 𝕜 {x}
{α : Type u_1} [Linear_ordered_Field α] {A B : α} (ha : A < 0) (hb : B < 0) : 1 / A ≤ 1 / B ↔ B ≤ A
{α : Type u_1} {m : Type u_5} {N : Type u_7} [has_Zero m] [AddCommMonoid N] {S : Finset α} {F : α → m} {g : α → m → N} (hF : ∀ (A : α), F A ≠ 0 → A ∈ S) (hg : ∀ (A : α), g A 0 = 0) : (Finsupp.on_Finset S F hF).Sum g = S.Sum (λ (A : α), g A (F A))
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {S : set α} {t : set β} : IsOpen (S ×ˢ t) ↔ IsOpen S ∧ IsOpen t ∨ S = ∅ ∨ t = ∅
{α : Type u_1} {ι : Type u_2} {β : Type u_3} {S : ι → set α} {F : Π (i : ι), ↥(S i) → β} {hF : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), F i ⟨x, hxi⟩ = F j ⟨x, hxj⟩} {t : set α} {hT : t ⊆ set.Union S} (C : ↥t) (ci : Π (i : ι), ↥(S i)) (hci : ∀ (i : ι), ↑(ci i) = ↑C) (Cβ : β) (h : ∀ (i : ι), F i (ci i) = Cβ) : set.Union_Lift S F hF t hT C = Cβ
{G : Type u_1} [AddGroup G] {k : set G} {P : G → Prop} {x : G} (h : x ∈ Add_Subgroup.Closure k) (Hk : ∀ (x : G), x ∈ k → P x) (h1 : P 0) (HMul : ∀ (x y : G), P x → P y → P (x + y)) (Hinv : ∀ (x : G), P x → P (-x)) : P x
{x : top} (F : top.Presheaf (Type v) x) : F._sheaf ↔ F._sheaf_Unique_gluing
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (x Y : C) : CategoryTheory.IsIso (CategoryTheory.Limits.Cokernelπ 0)
{α : Type u_1} {ι : Type u_4} (S : ι → set α) : (⋂ (i : ι), S i) = ⋂ (t : Finset ι) (i : ι) (h : i ∈ t), S i
{α : Type u} {β : Type v} [PseudoEmetricSpace α] [PseudoEmetricSpace β] {K : Nnreal} {F : α → β} (hF : LipschitzWith K F) : uniform_Continuous F
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {F : Type u_2} [NormedGroup F] [NormedSpace ℝ F] [Finite_dimensional ℝ F] {S : set E} {F : E → F} {F' : E ≃L[ℝ] F} {C : Nnreal} (hF : ApproximatesLinearOn F ↑F' S C) (hc : Subsingleton E ∨ lipschitz_extension_constant F * C < ∥↑(F'.Symm)∥₊⁻¹) : ∃ (g : E ≃ₜ F), set.Eq_on F ⇑g S
{R : Type u_1} [CommRing R] (v W : Fin 3 → R) : -⇑(⇑CrossProduct v) W = ⇑(⇑CrossProduct W) v
(P : ℕ) [P_Prime : Fact (Nat.Prime P)] {n₁ n₂ D₁ D₂ : ℤ} (hn₁ : n₁ ≠ 0) (hn₂ : n₂ ≠ 0) (hD₁ : D₁ ≠ 0) (hD₂ : D₂ ≠ 0) : padic_val_rat P (Rat.Mk n₁ D₁) ≤ padic_val_rat P (Rat.Mk n₂ D₂) ↔ ∀ (n : ℕ), ↑P ^ n ∣ n₁ * D₂ → ↑P ^ n ∣ n₂ * D₁
{R : Type u} [CommSemiring R] [Star_Ring R] (x : R) : ⇑(Star_Ring_end R) (⇑(Star_Ring_end R) x) = x
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} {F' : E →L[𝕜] F} {S : set E} {C : Nnreal} : ApproximatesLinearOn F F' S C → LipschitzOnWith C (F - ⇑F') S
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {n : WithTop ℕ} (h : ContDiff_on 𝕜 n F S) (hs : UniqueDiffOn 𝕜 S) : HasFtaylorSeriesUpToOn n F (ftaylor_series_within 𝕜 F S) S
{α : Type u_1} (L : List (List α)) {i j : ℕ} (hi : i < L.length) (hj : j < (L.nth_LE i hi).length) : (List.take i (List.Map List.length L)).Sum + j < L.Join.length
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_NormedGroup E'] [semi_NormedGroup F'] {F' : α → E'} {g' : α → F'} {l : Filter α} : ((λ (x : α), ∥F' x∥) =O[l] λ (x : α), ∥g' x∥) → F' =O[l] g'
{𝕜 : Type u_1} {E : Type u_4} {Fₗ : Type u_7} [NormedGroup E] [NormedGroup Fₗ] [nondiscrete_NormedField 𝕜] [NormedSpace 𝕜 E] [NormedSpace 𝕜 Fₗ] (C : E →L[𝕜] 𝕜) (F : Fₗ) : ∥C.Smul_Right F∥ = ∥C∥ * ∥F∥
(P : ℕ) [P_Prime : Fact (Nat.Prime P)] {q r : ℚ} (hq : q ≠ 0) (hr : r ≠ 0) : padic_val_rat P (q * r) = padic_val_rat P q + padic_val_rat P r
{Γ₀ : Type u_1} [Linear_ordered_comm_Group_with_Zero Γ₀] (γ : Γ₀) (h : γ ≠ 0) : {γ} ∈ nhds γ
{K : Type v} {v : Type W} [Field K] [AddCommGroup v] [module K v] [_alg_IsClosed K] [Finite_dimensional K v] [Nontrivial v] (F : module.End K v) : ∃ (C : K), F.HasEigenvalue C
{x : Type u} [MetricSpace x] [CompactSpace x] [Nonempty x] {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : GromovHausdorff.to_GH_Space x = GromovHausdorff.to_GH_Space Y ↔ Nonempty (x ≃ᵢ Y)
{α : Type u} : TopologicalSpace.induced has_pure.pure Ultrafilter.TopologicalSpace = ⊥
(P : ℕ) : ↑(mersenne P) = 0
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {x Y Z : C} [CategoryTheory.HasRightDual x] [CategoryTheory.HasRightDual Y] [CategoryTheory.HasRightDual Z] {F : x ⟶ Y} {g : Y ⟶ Z} : (F ≫ g)ᘁ = gᘁ ≫ Fᘁ
{α : Type u} [PseudoEmetricSpace α] : Isometry Id
{β : Type u} {α : Type v} {γ : Type W} [CommMonoid β] {S : Finset α} {t : Finset γ} {F : α → β} {g : γ → β} (i : Π (A : α), A ∈ S → γ) (hi : ∀ (A : α) (ha : A ∈ S), i A ha ∈ t) (h : ∀ (A : α) (ha : A ∈ S), F A = g (i A ha)) (j : Π (A : γ), A ∈ t → α) (hj : ∀ (A : γ) (ha : A ∈ t), j A ha ∈ S) (Left_Inv : ∀ (A : α) (ha : A ∈ S), j (i A ha) _ = A) (Right_Inv : ∀ (A : γ) (ha : A ∈ t), i (j A ha) _ = A) : S.Prod (λ (x : α), F x) = t.Prod (λ (x : γ), g x)
{K : Type u_1} {v : Type u_2} [Field K] [Ring v] [Algebra K v] {S : Subalgebra K v} (h : Finite_dimensional K ↥(S.to_Submodule)) : Finite_dimensional K ↥S
{α : Type u_1} (l : List α) (C : Composition l.length) : List.Map List.length (l.split_wrt_Composition C) = C.blocks
(u : pnat.xgcd_Type) (hr : u.r ≠ 0) : sizeOf u.step < sizeOf u
(A : Type u_4) (K : Type u_5) (C : Type u_6) [CommRing A] [IsDomain A] [Field K] [Algebra A K] [_fraction_Ring A K] [CommRing C] [Algebra A C] [Algebra K C] [IsScalarTower A K C] {x : C} : IsAlgebraic A x ↔ IsAlgebraic K x
{k : Type u_1} {E : Type u_2} [Linear_ordered_Field k] [ordered_AddCommGroup E] [module k E] [OrderedSmul k E] {F : k → E} {A B r : k} (h : 0 < (1 - r) * (B - A)) : ⇑(affine_Map.line_Map (F A) (F B)) r < F (⇑(affine_Map.line_Map A B) r) ↔ slope F (⇑(affine_Map.line_Map A B) r) B < slope F A B
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} {ι₂ : Type u_5} (S₂ : Finset ι₂) (e : ι₂ ↪ ι) (P : ι → P) : Finset.centroid k (Finset.Map e S₂) P = Finset.centroid k S₂ (P ∘ ⇑e)
{G : Type u} [Monoid G] (h : Submonoid G) (x : ↥h) : _of_Fin_order x ↔ _of_Fin_order ↑x
{α : Type u_1} {β : Type u_2} [conditionally_complete_LinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] {S : set β} {F : β → α} (hF : Continuous_on F S) (hsc : IsClosed S) {x₀ : β} (h₀ : x₀ ∈ S) (hc : ∀ᶠ (x : β) in Filter.cocompact β ⊓ Filter.principal S, F x₀ ≤ F x) : ∃ (x : β) (h : x ∈ S), ∀ (y : β), y ∈ S → F x ≤ F y
{α : Type u_1} {C : set (set α)} (hu : ⋃₀C = set.Univ) (h : C.Pairwise_Disjoint Id) (A : α) : ∃! (B : set α) (h : B ∈ C), A ∈ B
{G : Type u_4} [NormedGroup G] [NormedSpace ℝ G] {S : set G} (conv : Convex ℝ S) (hs : (Interior S).Nonempty) {x : G} (hx : x ∈ Closure S) : UniqueDiffWithinAt ℝ S x
{A k : ℕ} (h0 : 0 < A) (h1 : A < k) (n : ℕ) : (k + n).Prime_counting' ≤ k.Prime_counting' + A.Totient * (n / A + 1)
{cb : CharBuffer} {n n' val : ℕ} (h : Parser.Nat cb n = ParseResult.done n' val) (hn : n' ≤ Buffer.size cb) (k : ℕ) (hk : k < n') : n ≤ k → '0' ≤ Buffer.read cb ⟨k, _⟩ ∧ Buffer.read cb ⟨k, _⟩ ≤ '9'
{α : Type u_1} {r₁ r₂ : Setoid α} : r₁ = r₂ ↔ ∀ (x : α), {y : α | r₁.Rel x y} = {y : α | r₂.Rel x y}
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace 𝕜] {C : 𝕜} (hc : 1 < ∥C∥) {R : ℝ} (hR : ∥C∥ < R) (h : ¬Finite_dimensional 𝕜 E) (S : Finset E) : ∃ (x : E), ∥x∥ ≤ R ∧ ∀ (y : E), y ∈ S → 1 ≤ ∥y - x∥
(R : Type u) (m : Type v) [Ring R] [strong_RankCondition R] [AddCommGroup m] [module R m] [module.free R m] [module.Finite R m] : module.rank R m < Cardinal.aleph0
{α : Type u_3} [OrderedSemiring α] {n : ℕ} (hn : 1 ≤ n) : Filter.Tendsto (λ (x : α), x ^ n) Filter.at_top Filter.at_top
{α : Type u_1} {ι' : sort u_5} (S : ι' → set α) : (⋃ (i : ι'), S i) = ⋃ (t : Finset (plift ι')) (i : plift ι') (h : i ∈ t), S i.down
{R : Type u_1} [AddCommGroup R] {F g : ℕ → R} : (∀ (n : ℕ), 0 < n → n.divisors.Sum (λ (i : ℕ), F i) = g n) ↔ ∀ (n : ℕ), 0 < n → n.divisors_antidiagonal.Sum (λ (x : ℕ × ℕ), ⇑Nat.ArithmeticFunction.moebius x.fst • g x.Snd) = F n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasBinaryBiproducts C] (P q : C) : (CategoryTheory.Limits.biprod.braiding P q).hom ≫ (CategoryTheory.Limits.biprod.braiding q P).hom = 𝟙 (P ⊞ q)
{F : ℂ → ℂ} {C : ℂ} {R : ℝ} (hD : DifferentiableOn ℂ F (Metric.Ball C R)) (h_maps : set.maps_to F (Metric.Ball C R) (Metric.Ball C R)) (hc : F C = C) (h₀ : 0 < R) : Complex.Abs (deriv F C) ≤ 1
{R : Type u} [Semiring R] {S : Type v} [Semiring S] (F : R →+* S) (n : ℕ) : Polynomial.x ^ n ∈ Polynomial.lifts F
{C : Type u₁} [CategoryTheory.Category C] (t : CategoryTheory.Monad C) {A B : t.Algebra} (F : A ⟶ B) [CategoryTheory.IsIso F.F] : CategoryTheory.IsIso F
{R : Type u} [CommRing R] {P q : Polynomial R} (hmonic : q.monic) (hdegree : q.degree ≤ P.degree) : (P /ₘ q).leading_Coeff = P.leading_Coeff
{R : Type u} [non_assoc_Semiring R] {S : set R} : S ⊆ ↑(Subsemiring.Closure S)
{P A B : ℕ} (hab : A.IsCoprime B) (hpa : P ∈ A.Factors) : ⇑((A * B).factorization) P = ⇑(A.factorization) P
{m n : ℕ+} : m.factor_Multiset ≤ n.factor_Multiset ↔ m ∣ n
{m₀ : Type u_1} [Mul_Zero_class m₀] [no_Zero_divisors m₀] {A B : m₀} : A * B = 0 ↔ A = 0 ∨ B = 0
{𝕜 : Type u_3} {E : Type u_4} [semi_NormedRing 𝕜] [AddCommGroup E] [module 𝕜 E] (P : Seminorm 𝕜 E) (x y : E) : ⇑P y ≤ ⇑P x + ⇑P (x - y)
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x : v) {r₁ r₂ : ℝ} (hr₁ : 0 ≤ r₁) (hr₂ : 0 ≤ r₂) : hb.oangle (r₁ • x) (r₂ • x) = 0
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {S : set E} {F : E → F} {x : E} {n : WithTop ℕ} (e : F ≃L[𝕜] G) : ContDiff_within_at 𝕜 n (⇑e ∘ F) S x ↔ ContDiff_within_at 𝕜 n F S x
(x : ℝ) : Real.sinh (Real.arsinh x) = x
{m : Type u_3} [AddMonoid m] [Preorder m] (L : List m) (h : 0 < L.Sum) : 0 < L.length
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → Submodule 𝕜 E} (hV : OrthogonalFamily 𝕜 (λ (i : ι), (v i).Subtypeₗᵢ)) : CompleteLattice.Independent v
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} (S : Finset ι) (F : ι → E) (x : E) : HasInner.inner (S.Sum (λ (i : ι), F i)) x = S.Sum (λ (i : ι), HasInner.inner (F i) x)
{G : Type u_1} [Group G] [TopologicalSpace G] [nonarchimedean_Group G] {h : Type u_2} [Group h] [TopologicalSpace h] [topological_Group h] (F : G →* h) (emb : IsOpen_Embedding ⇑F) : nonarchimedean_Group h
{P : ℕ} {z : ℤ} : padic_val_rat P ↑z = ↑(padic_val_Int P z)
{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] (S : Submodule R m) : S.fg ↔ CompleteLattice.IsCompact_element S
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.Swap has_Mul.Mul) has_LE.LE] {A B : α} (ha : A < 1) (hb : B < 1) : A * B < 1
{ι : Type u} {β : ι → Type v} [dec : DecidableEq ι] [Π (i : ι), AddCommMonoid (β i)] : ⇑Dfinsupp.Lift_Add_hom (Dfinsupp.single_Add_hom β) = AddMonoid_hom.Id (Π₀ (i : ι), β i)
{x : Type u_1} {Y : Type u_2} [PseudoEmetricSpace x] [PseudoEmetricSpace Y] {C : Nnreal} {F : x → Y} {S : set x} : LipschitzOnWith C F S → HolderOnWith C 1 F S
{β : Type u} {α : Type v} {γ : Type W} {S : Finset α} [AddCommMonoid β] [DecidableEq γ] (F : γ → β) (g : α → γ) : S.Sum (λ (A : α), F (g A)) = (Finset.image g S).Sum (λ (B : γ), (Finset.Filter (λ (A : α), g A = B) S).Card • F B)
{α : Type u} {A B : α} [MulOneClass α] [has_Zero α] [Preorder α] [Zero_LT.Mul_Pos_Mono α] (ha : A ≤ 1) (hb : B ≤ 1) (B0 : 0 < B) : A * B ≤ 1
{G₀ : Type u_2} {G₀' : Type u_4} [Group_with_Zero G₀] [Group_with_Zero G₀'] (F : G₀ →*₀ G₀') (A : G₀) : ⇑F A⁻¹ = (⇑F A)⁻¹
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryCoproducts C] (P q : C) : (CategoryTheory.Limits.Coprod.braiding P q).hom ≫ (CategoryTheory.Limits.Coprod.braiding q P).hom = 𝟙 (P ⨿ q)
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (θ : Real.Angle) : ⇑LinearMap.det ↑((o.rotation θ).to_Linear_Equiv) = 1
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {K : J ⥤ C} {C D : CategoryTheory.Limits.Cone K} (F : C ⟶ D) [i : CategoryTheory.IsIso F.hom] : CategoryTheory.IsIso F
{α : Type u} {β : Type v} [Preorder α] [PartialOrder β] {l : α → β} {u : β → α} (gc : GaloisConnection l u) (B : β) : (∃ (A : α), B = l A) ↔ B = l (u B)
{ι : Type u_1} {ι' : Type u_2} {α : Type u_3} [Fintype ι] [Preorder ι'] [_Directed ι' (Function.Swap has_LE.LE)] [Nonempty ι'] {S : ι → ι' → set α} (hs : ∀ (i : ι), Monotone (S i)) : (⋂ (j : ι'), ⋃ (i : ι), S i j) = ⋃ (i : ι), ⋂ (j : ι'), S i j
{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), AddGroup (Gs i)] (tfGs : ∀ (i : η), AddMonoid._torsion_free (Gs i)) : AddMonoid._torsion_free (Π (i : η), Gs i)
{v : Type u_1} (α : Type u_2) (G : SimpleGraph v) [Decidable_Rel G.Adj] [has_Zero α] [has_One α] : (SimpleGraph.Adj_Matrix α G)._Adj_Matrix
{C : Type u₁} [CategoryTheory.Category C] {x Y : C} {F : x ⟶ Y} [CategoryTheory.SplitEpi F] [CategoryTheory.Epi (CategoryTheory.section_ F)] : CategoryTheory.IsIso F
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (A : F) : Char.quadratic_Char F A = 0 ↔ A = 0
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : AffineSubspace k P} {P : P} (hp : P ∈ S) (P2 : P) : P -ᵥ P2 ∈ S.direction ↔ P2 ∈ S
{α : Type u_1} [Semigroup α] {A B : α} (C : α) (h : A * C = B) : A ∣ B
{α : Type u} [TopologicalSpace α] {S t : set α} (hs : IsCompact S) (ht : IsClosed t) (h : t ⊆ S) : IsCompact t
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {F : α → β → γ} {ta1 ta2 : TopologicalSpace α} {tb1 tb2 : TopologicalSpace β} {Tc1 : TopologicalSpace γ} (h : Continuous (λ (P : α × β), F P.fst P.Snd)) : Continuous (λ (P : α × β), F P.fst P.Snd)
{m : Type u_3} {N : Type u_4} [MulOneClass m] [MulOneClass N] (F : m →* N) : ⇑F 1 = 1
{G : Type u_1} {P : Type u_2} [AddGroup G] [t : AddTorsor G P] (P1 P2 : P) : P1 -ᵥ P2 +ᵥ P2 = P1
(P L : Type u) [HasMem P L] [Configuration.HasLines P L] [Fintype P] [Fintype L] : Fintype.Card P ≤ Fintype.Card L
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] {ι : Type u_4} (S : Finset ι) (W : ι → k) (P₁ : ι → P) (P₂ B : P) : S.Sum (λ (i : ι), W i • (P₁ i -ᵥ P₂)) = ⇑(S.weighted_vsub_of_point P₁ B) W - S.Sum (λ (i : ι), W i) • (P₂ -ᵥ B)
{α : Type u} {S : set α} (hs : S.Nonempty) : S.countable ↔ ∃ (F : ℕ → ↥S), Function.Surjective F
{𝕂 : Type u_1} [nondiscrete_NormedField 𝕂] [CompleteSpace 𝕂] [CharZero 𝕂] {x : 𝕂} (hx : x ∈ Emetric.Ball 0 (Exp_series 𝕂 𝕂).radius) : HasStrictDerivAt (Exp 𝕂) (Exp 𝕂 x) x
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [BaireSpace α] {S : set β} {F : β → set α} (hc : ∀ (S : β), S ∈ S → IsClosed (F S)) (hS : S.countable) (hU : (⋃ (S : β) (h : S ∈ S), F S) = set.Univ) : Dense (⋃ (S : β) (h : S ∈ S), Interior (F S))
{n : ℕ} {P : Fin n} {i : Fin (n + 1)} (h : i ≠ ⇑Fin.cast_Succ P) : ⇑((⇑Fin.cast_Succ P).Succ_above) (P.Pred_above i) = i
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] (P : P) : ⇑(EuclideanGeometry.reflection S) P = P ↔ P ∈ S
{α : Type u_1} (A : α) [Subsingleton α] : Fintype.Card α = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasWidePullbacks C] {B : C} : CategoryTheory.Limits.HasProducts (CategoryTheory.Over B)
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : HasInner.inner x y / (∥x∥ * ∥y∥) = -1 ↔ x ≠ 0 ∧ ∃ (r : ℝ), r < 0 ∧ y = r • x
{G : Type u} {x y : G} [AddCommMonoid G] (hx : _of_Fin_Add_order x) (hy : _of_Fin_Add_order y) : _of_Fin_Add_order (x + y)
(A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) [Nontrivial B] : ¬IsUnit (minpoly A x)
{α : Type u} {ι : sort x} {F : ι → Filter α} [Nonempty ι] (hD : Directed Ge F) (hb : ∀ (i : ι), (F i).Ne_IsBot) : (infi F).Ne_IsBot
{m : Type u_5} [AddCommGroup m] (h : module ℤ m) (n : ℤ) (x : m) : n • x = n • x
{R : Type u_1} {E : Type u_2} {ι : Type u_4} [Linear_ordered_Field R] [AddCommGroup E] [module R E] (S : Finset ι) (hs : S.Nonempty) (P : ι → E) : Finset.centroid R S P = S.Center_mass (Finset.centroid_weights R S) P
{α : Type u_1} [Preorder α] {A B : α} (h : B < A) : ¬IsMin A
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (e : LocalHomeomorph α β) {F : γ → α} {x : γ} (h : F ⁻¹' e.to_local_Equiv.Source ∈ nhds x) : Continuous_at F x ↔ Continuous_at (⇑e ∘ F) x
{α : Type u} [AddGroup α] [has_LE α] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B : α} : B ≤ A → 0 ≤ A - B
{x : Type u_1} [TopologicalSpace x] {A B : x} (γ : Path A B) : Continuous (λ (x : ℝ × ℝ × ↥Unit_Interval), ⇑(γ.truncate x.fst x.Snd.fst) x.Snd.Snd)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} {x : E} : mfderiv (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F x = fderiv 𝕜 F x
{α : Type u} [PseudoMetricSpace α] {S : ℕ → set α} (h0 : IsComplete (S 0)) (hs : ∀ (n : ℕ), IsClosed (S n)) (h'S : ∀ (n : ℕ), Metric.Bounded (S n)) (h : ∀ (N : ℕ), (⋂ (n : ℕ) (h : n ≤ N), S n).Nonempty) (h' : Filter.Tendsto (λ (n : ℕ), Metric.diam (S n)) Filter.at_top (nhds 0)) : (⋂ (n : ℕ), S n).Nonempty
{G : Type W} [TopologicalSpace G] [Group G] [topological_Group G] {K U : set G} (hK : IsCompact K) (hU : IsOpen U) (hKU : K ⊆ U) : ∃ (v : set G) (h : v ∈ nhds 1), K * v ⊆ U
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : intermediate_Field K L) (x : K) : ⇑(Algebra_Map K L) x ∈ S
{α : Type u_1} [DecidableEq α] (xs : List α) (x D D' : α) (x_mem : x ∈ xs) (x_Ne : x ≠ xs.Last _) : xs.next_or x D = xs.next_or x D'
{ι : Type u_1} {R : Type u_3} {m : Type u_5} {v : ι → m} [Ring R] [AddCommGroup m] [module R m] {hli : LinearIndependent R v} {hsp : Submodule.Span R (set.Range v) = ⊤} (i : ι) : ⇑((Basis.Mk hli hsp).coord i) (v i) = 1
{α : Type u_1} [Preorder α] [locally_Finite_order α] {A B : α} : ¬A ≤ B → Multiset.icc A B = 0
{m : Type u_3} {N : Type u_4} [AddZeroClass m] [AddZeroClass N] {F g : m →+ N} (h : F = g) (x : m) : ⇑F x = ⇑g x
{v : Type u_1} [InnerProductSpace ℝ v] {P : Type u_2} [MetricSpace P] [NormedAddTorsor v P] {A B C D P : P} (h : EuclideanGeometry.Cospherical {A, B, C, D}) (hab : A ≠ B) (hcd : C ≠ D) (hapb : EuclideanGeometry.angle A P B = 0) (hcpd : EuclideanGeometry.angle C P D = 0) : HasDist.dist A P * HasDist.dist B P = HasDist.dist C P * HasDist.dist D P
{α : Type u_1} {β : Type u_2} [LinearOrder α] [SuccOrder α] [Preorder β] {F : α → β} (hF : Antitone F) : Pairwise (Disjoint on λ (n : α), set.Ioo (F (Order.Succ n)) (F n))
(P : Nat.Primes) : ↑P.factor_Multiset = Prime_Multiset.of_Prime P
{m : Type u_1} [has_Mul m] (r : m → m → Prop) : Con_gen ⇑(Con_gen r) = Con_gen r
(K : Type u) {L : Type v} (E : Type z) [Field K] [Field L] [Field E] [Algebra K L] [Algebra K E] [module.Finite K L] [_alg_IsClosed E] (pB : power_Basis K L) [_IsSeparable K L] (e : Fin pB.dim ≃ (L →ₐ[K] E)) : ⇑(Algebra_Map K E) (Algebra.discr K ⇑(pB.Basis)) = Finset.Univ.Prod (λ (i : Fin pB.dim), (Finset.Filter (λ (j : Fin pB.dim), i < j) Finset.Univ).Prod (λ (j : Fin pB.dim), -((⇑(⇑e j) pB.gen - ⇑(⇑e i) pB.gen) * (⇑(⇑e i) pB.gen - ⇑(⇑e j) pB.gen))))
{S : Type u_2} [CommRing S] {K : Type u_6} [Field K] [Algebra K S] (pB : power_Basis K S) : Finite_dimensional K S
{α : Type u} [AddCommGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] {A B C : α} : B < C - A → A + B < C
{m : Type u_1} [AddMonoid m] {S : set m} {A : m} (h : A ∈ AddMonoid.Closure S) : ∃ (l : List m), (∀ (x : m), x ∈ l → x ∈ S) ∧ l.Sum = A
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] [Nontrivial α] {S : set α} : Dense S ↔ ∀ (A B : α), A < B → (∃ (C : α) (h : C ∈ S), A < C ∧ C < B)
{𝕜 : Type u_1} {E : Type u} [Linear_ordered_Field 𝕜] [AddCommGroup E] [module 𝕜 E] [DecidableEq E] {t : Finset E} (h : ¬AffineIndependent 𝕜 Coe) {x : E} (m : x ∈ ⇑(Convex_hull 𝕜) ↑t) : ∃ (y : ↥↑t), x ∈ ⇑(Convex_hull 𝕜) ↑(t.erase ↑y)
{α : Type u_1} [Linear_ordered_Field α] {A B : α} (ha : 0 < A) (hb : 0 < B) : A⁻¹ < B ↔ B⁻¹ < A
{E : Type u_4} {F : Type u_5} [NormedGroup E] [NormedSpace ℝ E] [Finite_dimensional ℝ E] [NormedGroup F] [NormedSpace ℝ F] {F : E → F} (h : ContDiff ℝ 1 F) : dimH (set.Range F) ≤ ↑(Finite_dimensional.finrank ℝ E)
{P A B : ℕ} (hpa : P ∈ A.Factors) (hb : B ≠ 0) : P ∈ (A * B).Factors
{α : Type u_1} [Group α] [Fintype α] (S : Subgroup α) [Fintype ↥S] : Fintype.Card ↥S ∣ Fintype.Card α
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {x : top} (F : top.Presheaf C x) (U : TopologicalSpace.Opens ↥x) (R : CategoryTheory.Presieve U) : CategoryTheory.presheaf.first_Map R F ≫ (top.Presheaf.covering_of_Presieve.second_obj_iso_Pi_inters F U R).hom = (top.Presheaf.covering_of_Presieve.FirstObj_iso_Pi_Opens F U R).hom ≫ top.Presheaf.sheaf_condition_Equalizer_products.Left_res F (top.Presheaf.covering_of_Presieve U R)
{α : Type u} {ι : Type v} [MetricSpace α] [ProperSpace α] {C : ι → α} {r : ι → ℝ} (uf : ∀ (x : α), {i : ι | x ∈ Metric.Ball (C i) (r i)}.Finite) (uU : (⋃ (i : ι), Metric.Ball (C i) (r i)) = set.Univ) : ∃ (r' : ι → ℝ), (⋃ (i : ι), Metric.Ball (C i) (r' i)) = set.Univ ∧ ∀ (i : ι), r' i < r i
{α : Type u_1} (r : α → α → Prop) [IsIrrefl α r] : {C : Cardinal | ∃ (S : set α), set.Unbounded r S ∧ Cardinal.Mk ↥S = C}.Nonempty
(R : Type u_2) {m : Type u_5} [Ring R] [AddCommGroup m] [module R m] (n : ℤ) (B : m) : n • B = ↑n • B
{α : Type u_1} {γ : Type u_3} {ι : sort u_2} {P : ι → Prop} {S : ι → set α} {F : Filter α} (hF : F.has_Basis P S) {β : ι → Type u_4} {pg : Π (i : ι), β i → Prop} {sg : Π (i : ι), β i → set γ} {g : set α → Filter γ} (hg : ∀ (i : ι), (g (S i)).has_Basis (pg i) (sg i)) (gm : Monotone g) {S_1 : set γ} : S_1 ∈ F.Lift g ↔ ∃ (i : ι) (hi : P i) (x : β i) (hx : pg i x), sg i x ⊆ S_1
(R : Type u) [Ring R] [strong_RankCondition R] {ι : Type u} : module.rank R (ι →₀ R) = Cardinal.Mk ι
{α : Type u_1} [CompleteLattice α] {k : α} (h : CompleteLattice.IsCompact_element k) : IsCoatomic ↥(set.Iic k)
{α : Type u_1} [Fintype α] {𝒜 : Finset (Finset α)} {r : ℕ} : set.sized r ↑𝒜 → 𝒜 ⊆ Finset.powerset_len r Finset.Univ
{m : Type u_1} [has_Mul m] {S : set m} {P : m → m → Prop} {x y : m} (hx : x ∈ Subsemigroup.Closure S) (hy : y ∈ Subsemigroup.Closure S) (Hs : ∀ (x : m), x ∈ S → ∀ (y : m), y ∈ S → P x y) (HMul_Left : ∀ (x y z : m), P x z → P y z → P (x * y) z) (HMul_Right : ∀ (x y z : m), P z x → P z y → P z (x * y)) : P x y
(k : Type u_1) (v : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup v] [module k v] [S : AddTorsor v P] : affine_Span k ∅ = ⊥
{ι : Type u_1} {ι' : Type u_2} {α : Type u_3} [Fintype ι] [Preorder ι'] [_Directed ι' has_LE.LE] [Nonempty ι'] {S : ι → ι' → set α} (hs : ∀ (i : ι), Antitone (S i)) : (⋂ (j : ι'), ⋃ (i : ι), S i j) = ⋃ (i : ι), ⋂ (j : ι'), S i j
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : set P} (hs : EuclideanGeometry.Cospherical S) {P : Fin 3 → P} (hps : set.Range P ⊆ S) (hpi : Function.Injective P) : AffineIndependent ℝ P
{R : Type u_1} [Mul_Zero_class R] : ¬IsLeftRegular 0 ↔ Nontrivial R
{α : Type u} [PseudoMetricSpace α] {S : set α} (h : IsCompact S) : Metric.Bounded S
{α : Type} {D : ℕ} {ds : List ℕ} [Ring α] (x : Holor α (D :: ds)) : (Finset.Range D).attach.Sum (λ (i : {x // x ∈ Finset.Range D}), (Holor.Unit_vec D ↑i).Mul (x.Slice ↑i _)) = x
{C : Type u} [CategoryTheory.Category C] (x : CategoryTheory.CosimplicialObject C) {n : ℕ} {i : Fin (n + 1)} : x.δ i.Succ ≫ x.σ i = 𝟙 (x.obj (SimplexCategory.Mk n))
{C : Type u₁} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) : CategoryTheory.CoverPreserving J J (𝟭 C)
{α : Type u} [SemilatticeSup α] [Nonempty α] {S : set α} (hs : S.Finite) : BddAbove S
{R : Type u} [CommSemiring R] [no_Zero_divisors R] (t : Multiset (Polynomial R)) [Nontrivial R] : t.Prod.degree = (Multiset.Map (λ (F : Polynomial R), F.degree) t).Sum
{C : Type u} [CategoryTheory.Category C] [∀ (x Y : C), Subsingleton (x ⟶ Y)] : CategoryTheory.EssentiallySmall C ↔ Small (CategoryTheory.Skeleton C)
{α : sort u_1} (P : Prop) [Decidable P] (x : ¬P → α) (y : ¬¬P → α) : dite (¬P) x y = dite P (λ (h : P), y _) x
{R : Type u} [Ring R] (S : Subring R) : Subring.Closure ↑S = S
{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A] {S : set A} {P : A → A → Prop} {A B : A} (ha : A ∈ Algebra.Adjoin R S) (hb : B ∈ Algebra.Adjoin R S) (Hs : ∀ (x : A), x ∈ S → ∀ (y : A), y ∈ S → P x y) (Halg : ∀ (r₁ r₂ : R), P (⇑(Algebra_Map R A) r₁) (⇑(Algebra_Map R A) r₂)) (Halg_Left : ∀ (r : R) (x : A), x ∈ S → P (⇑(Algebra_Map R A) r) x) (Halg_Right : ∀ (r : R) (x : A), x ∈ S → P x (⇑(Algebra_Map R A) r)) (HAdd_Left : ∀ (x₁ x₂ y : A), P x₁ y → P x₂ y → P (x₁ + x₂) y) (HAdd_Right : ∀ (x y₁ y₂ : A), P x y₁ → P x y₂ → P x (y₁ + y₂)) (HMul_Left : ∀ (x₁ x₂ y : A), P x₁ y → P x₂ y → P (x₁ * x₂) y) (HMul_Right : ∀ (x y₁ y₂ : A), P x y₁ → P x y₂ → P x (y₁ * y₂)) : P A B
{α : Type u} (F : Filter α) : (⨆ (g : Ultrafilter α) (hg : ↑g ≤ F), ↑g) = F
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} (h : InnerProductGeometry.angle x (x - y) = InnerProductGeometry.angle y (y - x)) (hpi : InnerProductGeometry.angle x y ≠ Real.Pi) : ∥x∥ = ∥y∥
{R S : Type u} [CommRing R] [CommRing S] (m : Submonoid R) (R' : Type u) [CommRing R'] [Algebra R R'] [Algebra R' S] [Algebra R S] [IsScalarTower R R' S] [IsLocalization m R'] (S : set S) (x : S) (hx : x ∈ Submodule.Span R' S) : ∃ (t : ↥m), t • x ∈ Submodule.Span R S
{C : Type u} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type W} [CategoryTheory.Category D] [CategoryTheory.ConcreteCategory D] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.Forget D)] [∀ (x : C), CategoryTheory.Limits.HasColimits_of_shape (J.cover x)ᵒᵖ D] [∀ (P : Cᵒᵖ ⥤ D) (x : C) (S : J.cover x), CategoryTheory.Limits.HasMultiequalizer (S.Index P)] [Π (x : C), CategoryTheory.Limits.PreservesColimitsOfShape (J.cover x)ᵒᵖ (CategoryTheory.Forget D)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Forget D)] (P : Cᵒᵖ ⥤ D) : CategoryTheory.Presheaf.IsSheaf J (J.plus_obj (J.plus_obj P))
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (P : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) : P.remove_Zero.Left_Inv i = P.Left_Inv i
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {x : top} (F : top.Presheaf C x) {ι : Type v} (U : ι → TopologicalSpace.Opens ↥x) (S : CategoryTheory.Limits.Fork (top.Presheaf.sheaf_condition_Equalizer_products.Left_res F U) (top.Presheaf.sheaf_condition_Equalizer_products.Right_res F U)) : S.ι ≫ top.Presheaf.Presieve_of_covering.Pi_Opens_to_FirstObj F U ≫ top.Presheaf.Presieve_of_covering.FirstObj_to_Pi_Opens F U = S.ι
{k : Type u₁} {G : Type u₂} {R : Type u_1} [Semiring k] [MulOneClass G] [Semiring R] {F g : Monoid_Algebra k G →+* R} (h₁ : ∀ (B : k), ⇑F (Finsupp.single 1 B) = ⇑g (Finsupp.single 1 B)) (h_of : ∀ (A : G), ⇑F (Finsupp.single A 1) = ⇑g (Finsupp.single A 1)) : F = g
{α : Type u_1} {ι : sort u_3} [conditionally_CompleteLattice α] {F g : ι → α} (B : BddAbove (set.Range g)) (h : ∀ (x : ι), F x ≤ g x) : supr F ≤ supr g
{m : Type u_1} [AddGroup m] (C : Add_Con m) (n : ℤ) {W x : m} : ⇑C W x → ⇑C (n • W) (n • x)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_5} [NormedGroup E'] [NormedSpace 𝕜 E'] {n : WithTop ℕ} {F : E → E'} {S : set E} : ContDiff_on 𝕜 n F S → Cont_mdiff_on (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n F S
{α : Type u_6} {β : Type u_7} [has_Mul β] [HasScalar α β] [SmulCommClass α β β] (S : α) (x y : β) : x * S • y = S • (x * y)
{α : Type u_1} [PartialOrder α] (C : Closure_operator α) : _.Closure_operator = C
(α : Type u_1) [CompleteLattice α] : WellFounded Gt → CompleteLattice._Sup_IsClosed_IsCompact α
{K : Type u} {v : Type v} [DivisionRing K] [AddCommGroup v] [module K v] (h : 0 < Finite_dimensional.finrank K v) : Nontrivial v
{x : Type u_2} [EmetricSpace x] {S : set x} (h : S.Subsingleton) : dimH S = 0
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {A B : α} (hab : A < B) (S : set α) : [S ∈ nhds_within A (set.ioi A), S ∈ nhds_within A (set.ioc A B), S ∈ nhds_within A (set.Ioo A B), ∃ (u : α) (h : u ∈ set.ioc A B), set.Ioo A u ⊆ S, ∃ (u : α) (h : u ∈ set.ioi A), set.Ioo A u ⊆ S].tfae
{ι : Type W} [Fintype ι] (K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [module.Finite K L] [_IsSeparable K L] (B : Basis ι K L) : IsUnit (Algebra.discr K ⇑B)
{E : Type u_2} [semi_NormedGroup E] [NormedSpace ℝ E] {r : ℝ} (hr : 0 < r) : r • Metric.Ball 0 1 = Metric.Ball 0 r
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι →₀ 𝕜) (i : ι) : HasInner.inner (v i) (⇑(Finsupp.Total ι E 𝕜 v) l) = ⇑l i
{α : sort u_1} (P : Prop) [Decidable P] (A B : α) : Ite (¬P) A B = Ite P B A
{α : Type u_1} {r : α → α → Prop} {S : set α} (h : IsChain r S) : IsChain (Flip r) S
{α : Type u} [PseudoEmetricSpace α] {S t : set α} {r : Ennreal} (h1 : ∀ (x : α), x ∈ S → Emetric.Inf_edist x t ≤ r) (h2 : ∀ (x : α), x ∈ t → Emetric.Inf_edist x S ≤ r) : Emetric.Hausdorff_edist S t ≤ r
{R : Type u_1} [Semiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {N' : Type u_5} [AddCommGroup N'] [module R N'] {ι : Type u_6} [DecidableEq ι] {N'₂ : Type u_7} [AddCommGroup N'₂] [module R N'₂] [Fintype ι] (g : N' →ₗ[R] N'₂) (F : MultilinearMap R (λ (_x : ι), m) N') : ⇑MultilinearMap.alternatization (g.Comp_MultilinearMap F) = ⇑(g.Comp_AlternatingMap) (⇑MultilinearMap.alternatization F)
{α : Type u_1} {β : Type u_2} [UniformSpace α] [MetricSpace β] {F : α → β} (h : uniform_Embedding F) : Isometry F
{α : Type u_1} {𝕜 : Type u_14} [NormedField 𝕜] {l : Filter α} {F g : α → 𝕜} (hgf : ∀ᶠ (x : α) in l, g x = 0 → F x = 0) : Filter.Tendsto (λ (x : α), F x / g x) l (nhds 0) → F =o[l] g
{α : Type u_2} [Fintype α] {𝒜 : Finset (Finset α)} (h𝒜 : IsAntichain HasSubset.Subset ↑𝒜) : 𝒜.Card ≤ (Fintype.Card α).choose (Fintype.Card α / 2)
{α : Type u_2} [DecidableEq α] [Fintype α] {𝒜 : Finset (Finset α)} {r : ℕ} (h𝒜 : set.sized r ↑𝒜) : 𝒜.Card * r ≤ 𝒜.shadow.Card * (Fintype.Card α - r + 1)
{A : Ennreal} : A - ⊤ = 0
(k : Type u_1) {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] {S : set P} {P : P} {v : v} (hp : P ∈ SpanPoints k S) (hv : v ∈ Vector_Span k S) : v +ᵥ P ∈ SpanPoints k S
{α : Type u} [t : TopologicalSpace α] [TopologicalSpace.IsSeparable_Space α] {ι : Type u_1} {S : ι → set α} {A : set ι} (h : A.Pairwise_Disjoint S) (ha : ∀ (i : ι), i ∈ A → (Interior (S i)).Nonempty) : A.countable
{C : Type v} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] {x Y : C} (F : x ⟶ Y) (i : Function.Injective ⇑F) : CategoryTheory.Mono F
{k : Type u_1} {v : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup v] [module k v] [AddTorsor v P] : Function.Injective Coe
{R : Type u_1} {G : Type u_2} [CommRing R] [IsDomain R] [Group G] [Fintype G] (F : G →* R) (hF : Function.Injective ⇑F) : IsCyclic G
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] {S : Finset α} {t : Finset β} {F : α → β} {W : α → m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (hF : ∀ (A : α), A ∈ S → F A ∈ t) (ht : t.Nonempty) (hb : S.Sum (λ (x : α), W x) ≤ t.Card • B) : ∃ (y : β) (h : y ∈ t), (Finset.Filter (λ (x : α), F x = y) S).Sum (λ (x : α), W x) ≤ B
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] (S : AffineSubspace ℝ P) [Nonempty ↥S] [CompleteSpace ↥(S.direction)] : Function.involutive ⇑(EuclideanGeometry.reflection S)
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) : InnerProductGeometry.angle x y + InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x) = Real.Pi
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P n) (fs : Finset (Fin (n + 1))) : Finset.centroid ℝ fs S.points = ⇑(Finset.Univ.affine_combination S.points_with_circumcenter) (Affine.Simplex.centroid_weights_with_circumcenter fs)
{𝕜 : Type u_1} {α : Type u_2} [Linear_ordered_Field 𝕜] {𝒜 : Finset (Finset α)} [Fintype α] (h𝒜 : IsAntichain HasSubset.Subset ↑𝒜) : (Finset.Range (Fintype.Card α + 1)).Sum (λ (r : ℕ), ↑((𝒜.Slice r).Card) / ↑((Fintype.Card α).choose r)) ≤ 1
{α : Type u_1} {l : List α} {x : α} : List.Duplicate x l ↔ ∃ (n : ℕ) (hn : n < l.length) (m : ℕ) (hm : m < l.length) (h : n < m), x = l.nth_LE n hn ∧ x = l.nth_LE m hm
{α : Type u} [Group α] [has_LT α] [CovariantClass α α has_Mul.Mul has_LT.LT] {A B C : α} : B⁻¹ * A < C → A < B * C
{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {S : β → β → Prop} [IsTrichotomous α r] [IsIrrefl β S] (F : r →r S) : Function.Injective ⇑F
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {J : Type u} [CategoryTheory.Category J] (E : C ⥤ D) [CategoryTheory.IsEquivalence E] [CategoryTheory.Limits.HasColimits_of_shape J D] : CategoryTheory.Limits.HasColimits_of_shape J C
{K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [DivisionRing K] {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K} (Succ_nth_S_Eq : g.S.nth (n + 1) = Option.Some gp) (nth_Num_Eq : g.numerators n = ppredA) (Succ_nth_Num_Eq : g.numerators (n + 1) = predA) : g.numerators (n + 2) = gp.B * predA + gp.A * ppredA
{K : Type u} [Field K] (S : Subfield K) (m : Multiset K) : (∀ (A : K), A ∈ m → A ∈ S) → m.Sum ∈ S
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [semi_NormedGroup E'] {g : α → F} {F' : α → E'} {l : Filter α} : F' =O[l] g → (λ (x : α), ∥F' x∥) =O[l] g
{α : Type u_2} [AddGroup α] {S t : set α} : Disjoint S t → 0 ∉ S - t
{v₁ : Type u_2} {v₂ : Type u_3} [semi_NormedGroup v₁] [semi_NormedGroup v₂] (F : v₁ →+ v₂) {C : ℝ} (h : ∀ (x : v₁), ∥⇑F x∥ ≤ C * ∥x∥) : ∥F.Mk_NormedGroup_hom C h∥ ≤ LinearOrder.max C 0
{α : Type u_1} [semi_NormedGroup α] {r C : ℝ} {F : ℕ → α} (hr : r < 1) (hF : ∀ (n : ℕ), ∥F n∥ ≤ C * r ^ n) : Cauchy_Seq (λ (S : Finset ℕ), S.Sum (λ (x : ℕ), F x))
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : ∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * HasInner.inner x y + ∥y∥ ^ 2
(F : ℝ → ℝ) {A B : ℝ} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hfd : DifferentiableOn ℝ F (set.Ioo A B)) : ∃ (C : ℝ) (h : C ∈ set.Ioo A B), deriv F C = (F B - F A) / (B - A)
{α : Type u_1} [conditionally_CompleteLattice α] {S : set α} {A B : α} : BddBelow S → A ∈ S → A < B → HasInf.Inf S < B
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (F : C ⥤ D) {x Y Z : C} {F : x ⟶ Y} {g : Y ⟶ Z} [CategoryTheory.Abelian C] [CategoryTheory.Abelian D] [F.Additive] [CategoryTheory.Limits.PreservesFiniteLimits F] [CategoryTheory.Mono F] (ex : CategoryTheory.Exact F g) : CategoryTheory.Exact (F.Map F) (F.Map g)
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} {ps : set P} (h : ps ⊆ ↑S) [Nonempty ↥S] [CompleteSpace ↥(S.direction)] : EuclideanGeometry.Cospherical ps ↔ ∃ (Center : P) (h : Center ∈ S) (radius : ℝ), ∀ (P : P), P ∈ ps → HasDist.dist P Center = radius
{α : Type u} {A B : α} [MulOneClass α] [has_Zero α] [Preorder α] [Zero_LT.Mul_Pos_StrictMono α] (ha : A < 1) (hb : B ≤ 1) (B0 : 0 < B) : A * B < 1
{α : Type u_1} [PartialOrder α] (C : Closure_operator α) : C = Closure_operator.Mk₃ ⇑C C.IsClosed _ _ _
{α : Type u_1} {β : Type u_2} (t : α) (ts : List α) (r : List β) (ys : List α) (F : List α → β) : (List.PermutationsAux2 t ts List.Nil ys F).Snd ++ r = (List.PermutationsAux2 t ts r ys F).Snd
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} [Nonempty ↥S] [CompleteSpace ↥(S.direction)] {P₁ : P} (P₂ : P) (r : ℝ) (hp₁ : P₁ ∈ S) : ⇑(EuclideanGeometry.reflection S) (r • (P₂ -ᵥ ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P₂)) +ᵥ P₁) = -(r • (P₂ -ᵥ ↑(⇑(EuclideanGeometry.Orthogonal_projection S) P₂))) +ᵥ P₁
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {F : ℂ → E} {C : ℂ} {R : ℝ} {W : ℂ} (hF : CircleIntegrable F C R) (hw : Complex.Abs W < R) : (Cauchy_PowerSeries F C R).Sum W = (2 * ↑Real.Pi * Complex.i)⁻¹ • ∮ (z : ℂ) in C(C, R), (z - (C + W))⁻¹ • F z
{R : Type u_1} {S : Type u_2} {m : Type u_3} {ι : Type u_4} [CommSemiring R] [Semiring S] [AddCommMonoid m] [Algebra R S] [module R m] [module S m] [IsScalarTower R S m] (hinj : Function.Injective ⇑(Algebra_Map R S)) {v : ι → m} (li : LinearIndependent S v) : LinearIndependent R v
{𝕜 : Type u_1} {F : Type u_3} [_R_or_C 𝕜] [AddCommGroup F] [module 𝕜 F] [C : InnerProductSpace.core 𝕜 F] (x y : F) : _R_or_C.Abs (HasInner.inner x y) ≤ ∥x∥ * ∥y∥
{n : ℕ} [Fact (0 < n)] (i : Zmod n) : order_of (dihedral_Group.r i) = n / n.Gcd i.val
{α : Type u_2} {G₀ : Type u_6} [Group_with_Zero G₀] [MulAction G₀ α] [TopologicalSpace α] [has_Continuous_Const_Smul G₀ α] {C : G₀} {S : set α} {x : α} (hs : S ∈ nhds x) (hc : C ≠ 0) : C • S ∈ nhds (C • x)
{m : Type u_1} [Monoid m] {N : Type u_2} [Monoid N] {F : m → N} (hF : _Monoid_hom F) {S : set N} (hs : _Submonoid S) : _Submonoid (F ⁻¹' S)
(F F' : ℝ → ℝ) {A B : ℝ} (hab : A < B) (hfc : Continuous_on F (set.icc A B)) (hff' : ∀ (x : ℝ), x ∈ set.Ioo A B → HasDerivAt F (F' x) x) (g g' : ℝ → ℝ) (hgc : Continuous_on g (set.icc A B)) (hgg' : ∀ (x : ℝ), x ∈ set.Ioo A B → HasDerivAt g (g' x) x) : ∃ (C : ℝ) (h : C ∈ set.Ioo A B), (g B - g A) * F' C = (F B - F A) * g' C
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {ι : Type u_3} {S : Finset ι} {W₁ W₂ : ι → ℝ} (P : ι → P) (h₁ : S.Sum (λ (i : ι), W₁ i) = 1) (h₂ : S.Sum (λ (i : ι), W₂ i) = 1) : HasDist.dist (⇑(S.affine_combination P) W₁) (⇑(S.affine_combination P) W₂) * HasDist.dist (⇑(S.affine_combination P) W₁) (⇑(S.affine_combination P) W₂) = -S.Sum (λ (i₁ : ι), S.Sum (λ (i₂ : ι), (W₁ - W₂) i₁ * (W₁ - W₂) i₂ * (HasDist.dist (P i₁) (P i₂) * HasDist.dist (P i₁) (P i₂)))) / 2
{α : Type u_1} [Linear_ordered_Field α] {A B C D : α} (hc : C ≠ 0) (hD : D ≠ 0) : (A * D - B * C) / (C * D) < 0 → A / C < B / D
{K : Type u_1} {n : ℕ} {g : GeneralizedContinuedFraction K} [Linear_ordered_Field K] (S_Pos : ∀ {gp : GeneralizedContinuedFraction.Pair K} {m : ℕ}, m < n → g.S.nth m = Option.Some gp → 0 < gp.A ∧ 0 < gp.B) : g.convergents n = g.convergents' n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasBinaryCoproducts C] : CategoryTheory.Limits.HasBinaryBiproducts C
{α : Type u} {ι : sort x} {F : ι → α} : Function.Surjective F → set.Range F = set.Univ
{m : Type u_1} [has_Mul m] {S : set m} {P : m → Prop} {x : m} (h : x ∈ Subsemigroup.Closure S) (Hs : ∀ (x : m), x ∈ S → P x) (HMul : ∀ (x y : m), P x → P y → P (x * y)) : P x
(P : ℕ) [P_Prime : Fact (Nat.Prime P)] {q r : ℚ} (hqr : q + r ≠ 0) : LinearOrder.min (padic_val_rat P q) (padic_val_rat P r) ≤ padic_val_rat P (q + r)
{R : Type u_1} [Linear_ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [Nontrivial R] [Nonempty ι] (e : Basis ι R m) (x : Orientation R m ι) : (e.adjust_to_Orientation x).Orientation = x
{R : Type u_1} [CommRing R] [Fintype R] (P : ℕ) [Fact (Nat.Prime P)] : P ∣ Ring_Char R ↔ P ∣ Fintype.Card R
{α : Type u} [TopologicalSpace α] [LocallyCompactSpace α] {x : α} {U : set α} (hU : IsOpen U) (hx : x ∈ U) : ∃ (K : set α), IsCompact K ∧ x ∈ Interior K ∧ K ⊆ U
{C : Type u} [CategoryTheory.Category C] {D : Type u'} [CategoryTheory.Category D] [CategoryTheory.Limits.has_Finite_products C] [CategoryTheory.Limits.has_Finite_products D] (F : C ⥤ D) {L : D ⥤ C} [CategoryTheory.cartesian_IsClosed C] [CategoryTheory.cartesian_IsClosed D] [CategoryTheory.Limits.PreservesLimits_of_shape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F] (h : L ⊣ F) (A : C) [i : CategoryTheory.IsIso (CategoryTheory.frobenius_morphism F h A)] : CategoryTheory.IsIso (CategoryTheory.Exp_comparison F A)
{α : Type u_1} {β : Type u_2} {Op : β → β → β} [hc : IsCommutative β Op] [ha : IsAssociative β Op] {F : α → β} {B : β} {S : Finset α} [IsIdempotent β Op] {g : α → β} (P : α → Prop) [Decidable_Pred P] : Finset.Fold Op B (λ (i : α), Ite (P i) (F i) (g i)) S = Op (Finset.Fold Op B F (Finset.Filter P S)) (Finset.Fold Op B g (Finset.Filter (λ (i : α), ¬P i) S))
(R : Type u) [CommSemiring R] {S : Type v} [Semiring S] [Algebra R S] (P : Polynomial S) : P ∈ Polynomial.lifts (Algebra_Map R S) ↔ P ∈ (Polynomial.Map_alg R S).Range
{R : Type u_1} [ordered_CommRing R] {m : Type u_2} [AddCommGroup m] [module R m] {x y : m} : SameRay R x y → SameRay R (-x) (-y)
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {F : α → E} {g : α → F} {l : Filter α} : (∀ ⦃C : ℝ⦄, 0 < C → (∀ᶠ (x : α) in l, ∥F x∥ ≤ C * ∥g x∥)) → F =o[l] g
{R : Type u_2} [cancel_CommMonoid_with_Zero R] [Unique_factorization_Monoid R] {A B C : R} (ha : A ≠ 0) : (∀ {D : R}, D ∣ A → D ∣ C → ¬Prime D) → A ∣ B * C → A ∣ B
(𝕜 : Type u_1) {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} [LinearOrder ι] [OrderBot ι] [locally_Finite_order ι] [IsWellOrder ι has_LT.LT] [SuccOrder ι] [IsSuccArchimedean ι] (F : ι → E) (n : ι) (h₀ : LinearIndependent 𝕜 F) : gram_schmidt 𝕜 F n ≠ 0
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (h : B.Orientation = o) (x y : v) : o.oangle x y = hb.oangle x y
{𝕜 : Type u} [nondiscrete_NormedField 𝕜] {F g : 𝕜 → 𝕜} {F' A : 𝕜} (hg : Continuous_at g A) (hF : HasDerivAt F F' (g A)) (hF' : F' ≠ 0) (hfg : ∀ᶠ (y : 𝕜) in nhds A, F (g y) = y) : HasDerivAt g F'⁻¹ A
{R : Type u_1} {S : Type u_2} [CommRing R] [CommRing S] [Algebra R S] {ι : Type W} [Fintype ι] (B : Basis ι R S) (x : R) : ⇑(Algebra.norm R) (⇑(Algebra_Map R S) x) = x ^ Fintype.Card ι
{R₁ : Type u_1} {R₂ : Type u_2} {R₃ : Type u_3} [Semiring R₁] [Semiring R₂] [Semiring R₃] {σ₁₂ : R₁ →+* R₂} {σ₂₃ : R₂ →+* R₃} {σ₁₃ : R₁ →+* R₃} [Ring_hom_Comp_triple σ₁₂ σ₂₃ σ₁₃] [Ring_hom_surjective σ₁₂] [Ring_hom_surjective σ₂₃] : Ring_hom_surjective σ₁₃
{G₀ : Type u_2} [Group_with_Zero G₀] (A : G₀) : A⁻¹ * A * A = A
{α : Type u} [AddGroup α] [has_LE α] [CovariantClass α α has_Add.Add has_LE.LE] {A : α} : 0 ≤ -A ↔ A ≤ 0
{α : Type u_1} {m : Type u_5} {N : Type u_6} [AddCommMonoid m] [AddCommMonoid N] {S : set α} (F : α → m) (g : m →+ N) (hs : S.Finite) : ⇑g (finsum (λ (j : α), finsum (λ (h : j ∈ S), F j))) = finsum (λ (i : α), finsum (λ (h : i ∈ S), ⇑g (F i)))
{α : Type u_1} {β : Type u_2} [has_Add α] [AddCommGroup β] {F : α → β} (hF : _Add_hom F) : _Add_hom (λ (A : α), -F A)
{α : Type u_1} {β : Type u_2} {m : Type u_5} [CommMonoid m] (S : Finset (α × β)) (F : α × β → m) : finprod (λ (Ab : α × β), finprod (λ (h : Ab ∈ S), F Ab)) = finprod (λ (A : α), finprod (λ (B : β), finprod (λ (h : (A, B) ∈ S), F (A, B))))
{R : Type u_1} {m : Type u_2} [CommSemiring R] [AddCommMonoid m] [module R m] (A : R) : module._IsTorsionBy R ↥(Submodule.IsTorsionBy R m A) A
{α : Type u} (l : List α) (n k : ℕ) (hk : k < l.length) : (l.Rotate n).nth_LE ((l.length - n % l.length + k) % l.length) _ = l.nth_LE k hk
{α : Type u} [PseudoMetricSpace α] {S t : set α} {x : α} (h : S ⊆ t) (hs : S.Nonempty) : metric.Inf_dist x t ≤ metric.Inf_dist x S
{G : Type u_1} [comm_Group G] (K : Subgroup G) {ι : Type u_2} {t : Finset ι} {F : ι → G} (h : ∀ (C : ι), C ∈ t → F C ∈ K) : t.Prod (λ (C : ι), F C) ∈ K
{m : Type u_1} [has_Mul m] (C : Con m) {x y z : m} : ⇑C x y → ⇑C y z → ⇑C x z
(n : ℕ) : (Finset.Nat.antidiagonal n).Card = n + 1
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder α] [order_IsClosed_topology α] [Nonempty α] [TopologicalSpace β] [has_One α] {F : β → α} (hF : Continuous F) (h : HasCompactMulSupport F) : BddAbove (set.Range F)
{α : Type u} {β : Type v} [PseudoEmetricSpace α] [PseudoEmetricSpace β] {K : Nnreal} {F : α → β} (hF : LipschitzWith K F) : Continuous F
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {F : E → E'} {x : E} {F' : TangentSpace (model_with_corners_self 𝕜 E) x →L[𝕜] TangentSpace (model_with_corners_self 𝕜 E') (F x)} : HasFderivAt F F' x → HasMfderivAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') F x F'
{α : Type u_1} [PartialOrder α] [PredOrder α] {A B : α} [NoMinOrder α] : A ≠ B → Order.Pred A ≠ Order.Pred B
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {n : WithTop ℕ} [CompleteSpace 𝕜] (F : LocalHomeomorph 𝕜 𝕜) {F₀' A : 𝕜} (h₀ : F₀' ≠ 0) (ha : A ∈ F.to_local_Equiv.Target) (hF₀' : HasDerivAt ⇑F F₀' (⇑(F.Symm) A)) (hF : ContDiff_at 𝕜 n ⇑F (⇑(F.Symm) A)) : ContDiff_at 𝕜 n ⇑(F.Symm) A
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : Rˣ) (n : ℕ) : (λ (t : R), Ring.Inverse (↑x + t) - (Finset.Range n).Sum (λ (i : ℕ), (-↑x⁻¹ * t) ^ i) * ↑x⁻¹) =O[nhds 0] λ (t : R), ∥t∥ ^ n
{𝕜 : Type u_1} {E : Type u_2} [_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) (h : IsComplete ↑K) (u : E) : ∃ (v : E) (h : v ∈ K), ∥u - v∥ = ⨅ (W : ↥↑K), ∥u - ↑W∥
{α : Type u_1} {P : set α → Prop} {m : Π (S : set α), P S → Ennreal} {P0 : P ∅} {m0 : m ∅ P0 = 0} (PU : ∀ ⦃F : ℕ → set α⦄, (∀ (i : ℕ), P (F i)) → P (⋃ (i : ℕ), F i)) (msU : ∀ ⦃F : ℕ → set α⦄ (hm : ∀ (i : ℕ), P (F i)), m (⋃ (i : ℕ), F i) _ ≤ ∑' (i : ℕ), m (F i) _) (m_Mono : ∀ ⦃S₁ S₂ : set α⦄ (hs₁ : P S₁) (hs₂ : P S₂), S₁ ⊆ S₂ → m S₁ hs₁ ≤ m S₂ hs₂) (S : set α) : Measurable_set S ↔ ∀ (t : set α), P t → ⇑(MeasureTheory.induced_OuterMeasure m P0 m0) (t ∩ S) + ⇑(MeasureTheory.induced_OuterMeasure m P0 m0) (t  S) ≤ ⇑(MeasureTheory.induced_OuterMeasure m P0 m0) t
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x : v) : hb.oangle x x = 0
{α : Type u} (r S : α → α → Prop) [IsNonstrictStrictOrder α r S] {A B : α} : S A B ↔ r A B ∧ ¬r B A
{α : Type u} [TopologicalSpace α] {S t : set α} (hs : IsPreconnected S) (ht : IsClopen t) (hne : (S ∩ t).Nonempty) : S ⊆ t
{α : Type u} [AddCommGroup α] [has_LT α] [CovariantClass α α has_Add.Add has_LT.LT] {A B C : α} : A + B < C → B < C - A
{β : Type u} {α : Type v} {γ : Type W} [CommSemiring β] [CommSemiring γ] (g : β →+* γ) (F : α → β) (S : Finset α) : ⇑g (S.Prod (λ (x : α), F x)) = S.Prod (λ (x : α), ⇑g (F x))
{α : Type u} [AddMonoid α] (F : ℕ → α) (n : ℕ) : (List.Map F (List.Range n.Succ)).Sum = F 0 + (List.Map (λ (i : ℕ), F i.Succ) (List.Range n)).Sum
{α : Type u_1} {β : Type u_3} [MeasurableSpace α] [MeasurableSpace β] {ν : MeasureTheory.Measure β} [MeasureTheory.sigma_Finite ν] {F : α → β → Ennreal} (hF : Measurable (Function.uncurry F)) : Measurable (λ (x : α), ∫⁻ (y : β), F x y ∂ν)
(K : Type u) {L : Type v} (E : Type z) [Field K] [Field L] [Field E] [Algebra K L] [Algebra K E] [module.Finite K L] [_alg_IsClosed E] (pB : power_Basis K L) [_IsSeparable K L] (e : Fin pB.dim ≃ (L →ₐ[K] E)) : ⇑(Algebra_Map K E) (Algebra.discr K ⇑(pB.Basis)) = (-1) ^ (Finite_dimensional.finrank K L * (Finite_dimensional.finrank K L - 1) / 2) * Finset.Univ.Prod (λ (i : Fin pB.dim), (Finset.Filter (λ (j : Fin pB.dim), i < j) Finset.Univ).Prod (λ (j : Fin pB.dim), (⇑(⇑e j) pB.gen - ⇑(⇑e i) pB.gen) * (⇑(⇑e i) pB.gen - ⇑(⇑e j) pB.gen)))
{R : Type u₁} [OrderedSemiring R] {A : R} (Hsq : 0 ≤ A * A) (Hsq' : 0 ≤ (1 + A) * (1 + A)) (h : 0 ≤ 2 + A) (n : ℕ) : 1 + ↑n * A ≤ (1 + A) ^ n
(m : Type u_1) (α : Type u_2) [Group m] [MulAction m α] {ι : sort u_3} {P : ι → Subgroup m} : MulAction.FixedPoints ↥(supr P) α = ⋂ (i : ι), MulAction.FixedPoints ↥(P i) α
{R : Type u} [Ring R] (S : Subring R) {x y : R} : x ∈ S → y ∈ S → x + y ∈ S
 : ⇑MeasureTheory.MeasureSpace.Volume (⋃ (P : ℝ) (hp : 2 < P), {x : ℝ | LiouvilleWith P x}) = 0
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} (hx : x ≠ 0) (hy : y ≠ 0) : Real.cos (InnerProductGeometry.angle x y + InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) = -1
{C : Type u₁} [CategoryTheory.Category C] {A : Type u₂} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (P : Cᵒᵖ ⥤ A) : CategoryTheory.Presheaf.IsSheaf J P ↔ ∀ ⦃x : C⦄ (S : CategoryTheory.Sieve x), S ∈ ⇑J x → Nonempty (CategoryTheory.Limits.IsLimit (P.Map_cone S.Arrows.Cocone.Op))
{α : Type u} [AddGroup α] [has_LE α] [CovariantClass α α has_Add.Add has_LE.LE] [CovariantClass α α (Function.Swap has_Add.Add) has_LE.LE] {A B : α} : -A ≤ B → -B ≤ A
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} (K : set (E →L[𝕜] F)) : {x : E | Differentiable_at 𝕜 F x ∧ fderiv 𝕜 F x ∈ K} ⊆ fderiv_Measurable_aux.D F K
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasBinaryBiproducts C] (x : C) [CategoryTheory.Simple x] : CategoryTheory.Indecomposable x
{v : Type u_1} [InnerProductSpace ℝ v] {x y : v} (h : InnerProductGeometry.angle x y = Real.Pi) : HasInner.inner x y = -(∥x∥ * ∥y∥)
(x : Pgame) : (1 * x).Equiv x
{m : Type u_1} {P : Type u_3} [MulOneClass m] [MulOneClass P] {C : Con m} (F : C.Quotient →* P) : C.Lift (F.Comp C.Mk') _ = F
{α : Type u_1} {r₁ r₂ : Setoid α} : r₁ = r₂ ↔ r₁.Rel = r₂.Rel
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [OrderedSemiring 𝕜] [AddCommGroup E] [module 𝕜 E] {P : ι → E} (hc : Convex_Independent 𝕜 P) : Convex_Independent 𝕜 (λ (x : ↥(set.Range P)), ↑x)
{R : Type u_1} [Add_Right_cancel_Semigroup R] (g : R) : _Add_Right_regular g
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x y : v) : o.oangle x (-y) + o.oangle y (-x) = 0
{α : Type u_1} {E : α → Type u_2} {P : Ennreal} [Π (i : α), NormedGroup (E i)] [Fact (1 ≤ P)] : uniform_Continuous Coe
{α : Type u} {β : Type v} {m : Type W} [DecidableEq β] {S : Finset α} {t : Finset β} {F : α → β} {W : α → m} {B : m} [Linear_ordered_cancel_AddCommMonoid m] (hF : ∀ (y : β), y ∉ t → 0 ≤ (Finset.Filter (λ (x : α), F x = y) S).Sum (λ (x : α), W x)) (ht : t.Nonempty) (hb : S.Sum (λ (x : α), W x) ≤ t.Card • B) : ∃ (y : β) (h : y ∈ t), (Finset.Filter (λ (x : α), F x = y) S).Sum (λ (x : α), W x) ≤ B
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder α] [order_IsClosed_topology α] [Nonempty α] [TopologicalSpace β] [has_Zero α] {F : β → α} (hF : Continuous F) (h : has_IsCompact_Support F) : BddBelow (set.Range F)
{𝕜 : Type u_1} [nondiscrete_NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {S : set E} {F : E → F} {x : E} {n : WithTop ℕ} {P : E → FormalMultilinearSeries 𝕜 E F} (h : HasFtaylorSeriesUpToOn n F P S) {m : ℕ} (hmn : ↑m ≤ n) (hs : UniqueDiffOn 𝕜 S) (hx : x ∈ S) : P x m = iterated_fderiv_within 𝕜 m F S x
{α : Type u_1} [Linear_ordered_Field α] {A B C : α} (hb : 0 ≤ B) (hc : 0 ≤ C) (h : A ≤ C * B) : A / B ≤ C
{τ : Type u_1} [AddMonoid τ] [TopologicalSpace τ] [has_Continuous_Add τ] {α : Type u_2} [TopologicalSpace α] (ϕ : Flow τ α) {β : Type u_3} [TopologicalSpace β] {t : β → τ} (ht : Continuous t) {F : β → α} (hF : Continuous F) : Continuous (λ (x : β), ⇑ϕ (t x) (F x))
{α : Type u} {β : Type v} [DecidableEq β] {S : Finset α} {t : Finset β} {F : α → β} {n : ℕ} (hF : ∀ (A : α), A ∈ S → F A ∈ t) (ht : t.Nonempty) (hn : t.Card * n ≤ S.Card) : ∃ (y : β) (h : y ∈ t), n ≤ (Finset.Filter (λ (x : α), F x = y) S).Card
{R : Type u_2} {m : Type u_3} {N : Type u_4} [CommSemiring R] [AddCommMonoid m] [AddCommMonoid N] [module R m] [module R N] {m : Type u_1} {n : Type u_5} [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n] (bM : Basis m R m) (bN : Basis n R N) (j : m) (i : n) : ⇑(Linear_Map.to_Matrix bM bN) (⇑(dual_tensor_hom R m N) (bM.coord j ⊗ₜ[R] ⇑bN i)) = Matrix.std_Basis_Matrix i j 1
(n : ℕ) (θ : ℂ) : Complex.sin ((↑n + 1) * θ) = Polynomial.Eval (Complex.cos θ) (Polynomial.Chebyshev.U ℂ n) * Complex.sin θ
{α : Type u} [TopologicalSpace α] [t2_Space α] [CompactSpace α] (x : α) : ConnectedComponent x = ⋂ (Z : {Z // IsClopen Z ∧ x ∈ Z}), ↑Z
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {ι : Type u_4} [Invertible 2] (P : ι → P) (i₁ i₂ : ι) : Finset.centroid k {i₁, i₂} P = 2⁻¹ • (P i₂ -ᵥ P i₁) +ᵥ P i₁
{G : Type u_1} [AddGroup G] (K : Add_Subgroup G) {k : set G} : Add_Subgroup.Closure k ≤ K ↔ k ⊆ ↑K
{R : Type u_1} {m : Type u_5} {n : Type u_14} [CommRing R] [AddCommGroup m] [module R m] [no_Zero_divisors R] {B : m →ₗ[R] m →ₗ[R] R} (v : Basis n R m) (hO : B._Ortho ⇑v) (h : ∀ (i : n), ¬B.IsOrtho (⇑v i) (⇑v i)) : B.nondegenerate
{v : Type u_1} [InnerProductSpace ℝ v] {B : Basis (Fin 2) ℝ v} (hb : Orthonormal ℝ ⇑B) (x y : v) {r : ℝ} (hr : r < 0) : hb.oangle x (r • y) = hb.oangle x (-y)
{R : Type u1} [CommSemiring R] {m : Type u2} [AddCommMonoid m] [module R m] {A : Type u_1} [Semiring A] [Algebra R A] {F g : exterior_Algebra R m →ₐ[R] A} (h : F.to_Linear_Map.Comp (exterior_Algebra.ι R) = g.to_Linear_Map.Comp (exterior_Algebra.ι R)) : F = g
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {S : AffineSubspace ℝ P} {P1 P2 : P} (hp1 : P1 ∈ S) (hp2 : P2 ∈ S) (r1 r2 : ℝ) {v : v} (hv : v ∈ (S.direction)ᗮ) : HasDist.dist (r1 • v +ᵥ P1) (r2 • v +ᵥ P2) * HasDist.dist (r1 • v +ᵥ P1) (r2 • v +ᵥ P2) = HasDist.dist P1 P2 * HasDist.dist P1 P2 + (r1 - r2) * (r1 - r2) * (∥v∥ * ∥v∥)
{γ : Type u_3} [tγ : TopologicalSpace γ] [PolishSpace γ] [MeasurableSpace γ] [BorelSpace γ] {β : Type u_4} [tβ : TopologicalSpace β] [t2_Space β] [MeasurableSpace β] [BorelSpace β] {F : γ → β} [TopologicalSpace.SecondCountableTopology β] (F_Meas : Measurable F) (F_inj : Function.Injective F) : Measurable_Embedding F
 : Cardinal.Mk ↥set.Univ = Cardinal.Continuum
{R : Type x} [has_Mul R] [has_Add R] [Left_Distrib_class R] (A B C : R) : A * (B + C) = A * B + A * C
{α : Type u_1} [Linear_ordered_Field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n
{v : Type u_1} [InnerProductSpace ℝ v] [hD2 : Fact (Finite_dimensional.finrank ℝ v = 2)] (o : Orientation ℝ v (Fin 2)) (x : v) {r : ℝ} (hr : 0 ≤ r) : o.oangle (r • x) x = 0
{α : Type u_1} {β : Type u_2} [LinearOrder α] [PredOrder α] [Preorder β] {F : α → β} (hF : Monotone F) : Pairwise (Disjoint on λ (n : α), set.ioc (F (Order.Pred n)) (F n))
{v : Type u_1} {P : Type u_2} [InnerProductSpace ℝ v] [MetricSpace P] [NormedAddTorsor v P] {n : ℕ} (S : Affine.Simplex ℝ P (n + 2)) {i₁ i₂ : Fin (n + 3)} : (S.monge_plane i₁ i₂).direction = (Submodule.Span ℝ {S.points i₁ -ᵥ S.points i₂})ᗮ ⊓ Vector_Span ℝ (set.Range S.points)
{m : Type u_1} {P : Type u_3} [AddZeroClass m] [AddZeroClass P] (F : m →+ P) : Function.Injective ⇑(Add_Con.Ker_Lift F)
{α : Type u} [TopologicalSpace α] {S : set α} : S.Nonempty → (Closure S).Nonempty
{α : Type u_1} {β : Type u_2} {m : Type u_5} [CommMonoid m] [DecidableEq α] [DecidableEq β] (S : Finset (α × β)) (F : α × β → m) : finprod (λ (Ab : α × β), finprod (λ (h : Ab ∈ S), F Ab)) = finprod (λ (A : α), finprod (λ (B : β), finprod (λ (h : B ∈ Finset.image Prod.Snd (Finset.Filter (λ (Ab : α × β), Ab.fst = A) S)), F (A, B))))
{x : Type u_1} {Y : Type u_2} [TopologicalSpace x] {F : x → Y} (hF : IsLocallyConstant F) {S : set x} (hs : IsPreconnected S) {x y : x} (hx : x ∈ S) (hy : y ∈ S) : F x = F y
{ι : Type u_1} {R : Type u_8} [canonically_ordered_CommSemiring R] {F g h : ι → R} {S : Finset ι} {i : ι} (hi : i ∈ S) (h2i : g i + h i ≤ F i) (hgf : ∀ (j : ι), j ∈ S → j ≠ i → g j ≤ F j) (hhf : ∀ (j : ι), j ∈ S → j ≠ i → h j ≤ F j) : S.Prod (λ (i : ι), g i) + S.Prod (λ (i : ι), h i) ≤ S.Prod (λ (i : ι), F i)
{R : Type u_1} [ordered_CommSemiring R] {m : Type u_2} [AddCommMonoid m] [module R m] {N : Type u_3} [AddCommMonoid N] [module R N] {x y : m} (F : m →ₗ[R] N) (h : SameRay R x y) : SameRay R (⇑F x) (⇑F y)
(k : Type u_1) {v : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup v] [module k v] [AddTorsor v P] {P₁ P₂ : P} (h : P₁ ≠ P₂) : AffineIndependent k ![P₁, P₂]
{α : Type u_1} [Preorder α] [locally_Finite_order α] {A B : α} : ¬A < B → Finset.Ico A B = ∅
{m : Type u_1} [Monoid m] (A : m) (u : mˣ) : IsUnit (A * ↑u) ↔ IsUnit A
{α : Type u} {β : Type v} [DecidableEq α] [CommMonoid β] {S : Finset α} {x : α} (h : x ∉ S) (F : Finset α → β) : (HasInsert.Insert x S).powerset.Prod (λ (A : Finset α), F A) = S.powerset.Prod (λ (A : Finset α), F A) * S.powerset.Prod (λ (t : Finset α), F (HasInsert.Insert x t))
{α : Type u} [TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → set α) (hZd : Directed Superset Z) (hZn : ∀ (i : ι), (Z i).Nonempty) (hZc : ∀ (i : ι), IsCompact (Z i)) (hZcl : ∀ (i : ι), IsClosed (Z i)) : (⋂ (i : ι), Z i).Nonempty
{ι : Type u₁} {k : Type u₂} {v : Type u₃} {P : Type u₄} [AddCommGroup v] [AddTorsor v P] [CommRing k] [module k v] [DecidableEq ι] [Fintype ι] (B B₂ : affine_Basis ι k P) (x : P) : (B.to_Matrix B₂.points).det • ⇑(B₂.coords) x = ⇑((B.to_Matrix B₂.points).transpose.cramer) (⇑(B.coords) x)
{m : Type u_1} [semi_NormedGroup m] (S : Add_Subgroup m) (m : m) : ∥↑m∥ ≤ ∥m∥
