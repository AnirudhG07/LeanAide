{α : Type u} [PseudoMetricSpace α] (x y z : α) : HasNndist.nndist x z ≤ HasNndist.nndist x y + HasNndist.nndist y z
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] : IsNoetherian K V ↔ Module.rank K V < Cardinal.aleph_0
{α : Type u_2} [DecidableEq α] {s : Finset α} {B : Finset (Finset α)} {n : ℕ} (h : ∀ (a : α), a ∈ s → (Finset.filter (HasMem.Mem a) B).card ≤ n) : B.sum (λ (t : Finset α), (s ∩ t).card) ≤ s.card * n
{R : Type u_1} {n : ℕ} {M : Fin n → Type u_3} {M₂ : Type u_4} [CommSemiring R] [AddCommMonoid M₂] [Π (i : Fin n), AddCommMonoid (M i)] [Π (i : Fin n), Module R (M i)] [Module R M₂] {f g : MultilinearMap R M M₂} {ι₁ : Fin n → Type u_2} (e : Π (i : Fin n), Basis (ι₁ i) R (M i)) (h : ∀ (v : Π (i : Fin n), ι₁ i), ⇑f (λ (i : Fin n), ⇑(e i) (v i)) = ⇑g (λ (i : Fin n), ⇑(e i) (v i))) : f = g
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {X : Top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget C)] (F : Top.Sheaf C X) (U : TopologicalSpace.Opens ↥X) (s t : ↥(F.val.obj (Opposite.op U))) (h : ∀ (x : ↥U), ⇑(F.val.germ x) s = ⇑(F.val.germ x) t) : s = t
{G : Type u_7} [AddGroup G] (L : List G) (i : ℕ) (p : i < L.length) : (List.drop (i + 1) L).sum = -L.nth_LE i p + (List.drop i L).sum
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b : α} : a - b < 0 ↔ a < b
{𝕜 : Type u_1} {𝕝 : Type u_2} {E : Type u_3} [NormedField 𝕜] [NormedRing 𝕝] [NormedSpace 𝕜 𝕝] [AddCommGroup E] [Module 𝕜 E] [SmulWithZero 𝕝 E] [IsScalarTower 𝕜 𝕝 E] {s : Set E} (hs : Balanced 𝕝 s) {a : 𝕝} {b : 𝕜} (h : ∥a∥ ≤ ∥b∥) : a • s ⊆ b • s
{C : Type u} [CategoryTheory.Category C] (i p : CategoryTheory.Arrow C) (h : CategoryTheory.Limits.IsInitial i.left) : CategoryTheory.HasLiftingProperty i p ↔ ∀ {e : i.right ⟶ p.right}, ∃ (l : i.right ⟶ p.left), l ≫ p.hom = e
{α : Type u} {a b : α} [MulOneClass α] [HasZero α] [Preorder α] [ZeroLt.PosMulMono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 < a) : a * b ≤ 1
(R : Type u_1) [CommRing R] {n m : ℕ} (hpos : 0 < n) (hm : m ∣ n) (hdiff : m ≠ n) : Polynomial.x ^ m - 1 ∣ n.proper_divisors.prod (λ (i : ℕ), Polynomial.cyclotomic i R)
{M : Type u_6} {N : Type u_7} [HasMul M] [HasMul N] (e : M ≃* N) (y : N) : ⇑e (⇑(e.symm) y) = y
(p : ℕ) : WittVector.IsPoly p (λ (R : Type u_1) (_Rcr : CommRing R), WittVector.verschiebung_fun)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {f : E → F} (g : F →L[𝕜] G) (hF : ContDiff 𝕜 n f) : ContDiff 𝕜 n (λ (x : E), ⇑g (f x))
{R : Type u_1} [AddMonoid R] (a : AddUnits R) : IsAddRegular ↑a
{α : Type u_1} [TopologicalSpace α] (S : Set (Set α)) (hS : ∀ (s : ↥S), is_IsOpen ↑s) [hS' : ∀ (s : ↥S), QuasiSober ↥s] (hS'' : ⋃₀S = ⊤) : QuasiSober α
{α : Type u_1} {n : Type u_4} [HasZero α] [Subsingleton n] (A : Matrix n n α) : A.is_diag
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set ℝ} [Interval_integral.FTC_Filter b (nhds_within b s) (nhds_within b t)] (hmeas : StronglyMeasurableAtFilter f (nhds_within b t) MeasureTheory.MeasureSpace.volume) (hb : Filter.Tendsto f (nhds_within b t ⊓ MeasureTheory.Measure_space.volume.ae) (nhds c)) (hs : UniqueDiffWithinAt ℝ s b . "UniqueDiffWithinAt_ici_Iic_Univ") : deriv_within (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) s b = c
{C : Type u₁} [CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} : ⇑S (𝟙 X) ↔ S = ⊤
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (p1 p2 p3 : P) : HasDist.dist p1 p3 * HasDist.dist p1 p3 = HasDist.dist p1 p2 * HasDist.dist p1 p2 + HasDist.dist p3 p2 * HasDist.dist p3 p2 ↔ EuclideanGeometry.angle p1 p2 p3 = Real.pi / 2
{M : Type u_2} [AddCommGroup M] {𝕜 : Type u_1} [Field 𝕜] [Module 𝕜 M] {f : M →ₗ[𝕜] M} (hF : ⇑LinearMap.det f = 0) : ⊥ < f.ker
{m : Type u_2} {n : Type u_3} {R : Type u_7} [Fintype n] [Fintype m] [NonUnitalSemiring R] (v : m → R) (A : Matrix m n R) (w : n → R) : matrix.dot_Product v (A.mul_vec w) = matrix.dot_Product (matrix.vec_Mul v A) w
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {D : Type u₂} [CategoryTheory.Category D] [CategoryTheory.Abelian D] (F : C ⥤ D) (G : D ⥤ C) [G.preserves_Zero_morphisms] (i : F ⋙ G ≅ 𝟭 C) [CategoryTheory.Limits.PreservesFiniteLimits G] : CategoryTheory.Limits.HasKernels C
{V : Type u} (G : SimpleGraph V) {v w : V} : G.adj v w ↔ v ≠ w ∧ ∃ (e : Sym2 V) (H : e ∈ G.edge_Set), v ∈ e ∧ w ∈ e
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [Module 𝕜 E] {s : Set E} : s.nonempty → (⇑(Convex_hull 𝕜) s).nonempty
{G : Type u_1} [AddGroup G] [Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)] (hdvd : p ∣ Fintype.card G) : ∃ (x : G), Add_order_of x = p
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {a b c : α} [IsTrans α HasSubset.Subset] (h₁ : a ⊂ b) (h₂ : b ⊆ c) : a ⊂ c
{R : Type u} {S : Type v} [CommRing R] [CommRing S] (f : R →+* S) : Function.Injective ⇑(f.ker_Lift)
{G : Type u_1} [AddCommGroup G] (f : ℕ → G) (n : ℕ) : (Finset.range n).sum (λ (i : ℕ), f (i + 1) - f i) = f n - f 0
{M : Type u_2} [AddCommGroup M] {ι : Type u_4} [DecidableEq ι] [Fintype ι] {A : Type u_5} [CommRing A] [Module A M] (b : Basis ι A M) (f : M →ₗ[A] M) : ⇑(LinearMap.det_aux (Trunc.mk b)) f = (⇑(Linear_map.to_Matrix b b) f).det
{α : Type u_1} {l l' : List α} : l <+ l' ↔ ∃ (f : ℕ ↪o ℕ), ∀ (ix : ℕ), l.nth ix = l'.nth (⇑f ix)
{C : Type u} [CategoryTheory.Category C] {X Y Z : C} {i : CategoryTheory.Arrow C} {f : X ⟶ Y} {g : Y ⟶ Z} (hF : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.mk f)) (hg : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.mk g)) : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.mk (f ≫ g))
{α : Type u_1} [HasLt α] {a b : αᵒᵈ} : b < a → ⇑order_dual.of_dual a < ⇑order_dual.of_dual b
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e e' : LocalHomeomorph α β} (h : e ≈ e') : e.to_local_equiv.target = e'.to_local_equiv.target
{α : Type u} [TopologicalSpace α] [SigmaCompactSpace α] {f : α → Set α} {s : Set α} (hs : is_IsClosed s) (hF : ∀ (x : α), x ∈ s → f x ∈ nhds_within x s) : ∃ (t : Set α) (H : t ⊆ s), t.countable ∧ s ⊆ ⋃ (x : α) (H : x ∈ t), f x
{R : Type u_1} {G : Type u_2} [CommRing R] [is_IsDomain R] [Group G] [Fintype G] (f : G →* R) [Decidable (f = 1)] : finset.univ.sum (λ (g : G), ⇑f g) = Ite (f = 1) ↑(Fintype.card G) 0
{J K : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.SmallCategory K] {C : Type u} [CategoryTheory.Category C] (F : J × K ⥤ C) [CategoryTheory.Limits.HasLimitsOfShape J C] [CategoryTheory.Limits.HasColimitsOfShape K C] (j : J) (k : K) : CategoryTheory.Limits.colimitι (Category_theory.curry.obj (CategoryTheory.prod.swap K J ⋙ F) ⋙ CategoryTheory.Limits.lim) k ≫ CategoryTheory.Limits.colimit_Limit_to_Limit_Colimit F ≫ CategoryTheory.Limits.limitπ (Category_theory.curry.obj F ⋙ CategoryTheory.Limits.colim) j = CategoryTheory.Limits.limitπ ((Category_theory.curry.obj (CategoryTheory.prod.swap K J ⋙ F)).obj k) j ≫ CategoryTheory.Limits.colimitι ((Category_theory.curry.obj F).obj j) k
{b : ℝ} (a X : ℝ) (h2 : 0 < b) : ∫ (x : ℝ) in a..X, Real.exp (-b * x) ≤ Real.exp (-b * a) / b
{F : Type u_1} {K : Type u_2} {L : Type u_3} [Field F] [Field K] [Field L] [Algebra F K] [Algebra F L] (s : Finset K) : (∀ (x : K), x ∈ s → IsIntegral F x ∧ Polynomial.Splits (Algebra_Map F L) (minpoly F x)) → Nonempty (↥(Algebra.adjoin F ↑s) →ₐ[F] L)
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b c : α} : a - c < b → a < b + c
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} {s t : Set α} (hst : s ⊆ t) (ht : (t ∩ Function.MulSupport f).finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t  s), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))
{R : Type u_1} [Semiring R] (x y : DualNumber R) : (x * y).snd = TrivSqZeroExt.fst x * TrivSqZeroExt.snd y + TrivSqZeroExt.fst y * TrivSqZeroExt.snd x
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {a u' : α} {s : Set α} (hu' : a < u') : s ∈ nhds_within a (Set.Ioi a) ↔ ∃ (u : α) (H : u ∈ Set.Ioi a), Set.Ioo a u ⊆ s
{β : Type u_4} [LinearOrder β] [NoMaxOrder β] {u : ℕ → β} (hu : Filter.Tendsto u filter.at_Top filter.at_Top) : ∃ᶠ (n : ℕ) in filter.at_Top, ∀ (k : ℕ), k < n → u k < u n
{Γ₀ : Type u_1} [LinearOrderedCommGroupWithZero Γ₀] (γ : Γ₀ˣ) : {x : Γ₀ | x < ↑γ} ∈ nhds 0
{β : Type u_2} {f g : β → Nnreal} {r : Nnreal} (hgf : ∀ (b : β), g b ≤ f b) (hfr : HasSum f r) : ∃ (p : Nnreal) (H : p ≤ r), HasSum g p
(c : Turing.ToPartrec.Code) (k k' : Turing.ToPartrec.Cont) (v : List ℕ) : turing.to_partrec.step_Normal c (k.then k') v = (turing.to_partrec.step_Normal c k v).then k'
{C : Type u₁} [CategoryTheory.Category C] {T : CategoryTheory.Monad C} {J : Type u} [CategoryTheory.Category J] [CategoryTheory.Limits.PreservesColimitsOfShape J ↑T] (D : J ⥤ T.algebra) [CategoryTheory.Limits.HasColimit (D ⋙ T.forget)] : CategoryTheory.Limits.HasColimit D
{R : Type u_1} {ι : Type u_4} [LinearOrderedField R] [Fintype ι] {f : ι → R} (hF : f ∈ StdSimplex R ι) (x : ι) : f x ∈ Set.Icc 0 1
{R₁ : Type u_1} {R₂ : Type u_2} [Semiring R₁] [Semiring R₂] (σ₁₂ : R₁ →+* R₂) (σ₂₁ : R₂ →+* R₁) [RingHomInvPair σ₁₂ σ₂₁] : RingHomInvPair σ₂₁ σ₁₂
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X ⟶ Y} [CategoryTheory.Limits.HasEqualizer f g] [CategoryTheory.Epi (CategoryTheory.Limits.equalizerι f g)] : f = g
{α : Type u} [PseudoMetricSpace α] (x : α) : Emetric.Ball x ⊤ = Set.Univ
{α : Type u_1} (p : Pmf α) {s t : Set α} (h : s ∩ p.support ⊆ t) : ⇑(p.to_OuterMeasure) s ≤ ⇑(p.to_OuterMeasure) t
{K : Type u_1} {v : K} {n : ℕ} [LinearOrderedField K] [FloorRing K] : 0 ≤ (GeneralizedContinuedFraction.of v).denominators n
{n : WithTop ℕ} {𝕂 : Type u_6} [is_R_or_C 𝕂] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {f : 𝕂 → F'} {x : 𝕂} (hF : ContDiff 𝕂 n f) (hn : 1 ≤ n) : HasStrictDerivAt f (deriv f x) x
{p q x : ℝ} (h : LiouvilleWith p x) (hle : q ≤ p) : LiouvilleWith q x
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (p : P) (s : Set P) : p ∈ s → p ∈ SpanPoints k s
{α : Type u_1} [CompleteLattice α] [IsCompactlyGenerated α] {a : α} {s : Set α} : a ⊓ HasSup.sup s = ⨆ (t : Finset α) (H : ↑t ⊆ s), a ⊓ t.sup Id
{C : Type u_1} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) : CategoryTheory.CoverLifting J J (𝟭 C)
{ι : Type u_1} {X : ι → Type u_2} [Π (i : ι), TopologicalSpace (X i)] {as bs : Π (i : ι), X i} (i : ι) (Paths : Π (i : ι), Path.Homotopic.Quotient (as i) (bs i)) : Path.Homotopic.proj i (Path.Homotopic.pi Paths) = Paths i
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (t : Affine.Triangle ℝ P) : t.orthocenter = 3 • (Finset.centroid ℝ Finset.univ t.points -ᵥ Affine.Simplex.circumcenter t) +ᵥ Affine.Simplex.circumcenter t
{α : Type u_1} [HasLt α] {a b : α} (h : a < b) : ¬a ⋖ b → (∃ (c : α), a < c ∧ c < b)
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {f : α → γ} (hF : Continuous f) : Continuous (λ (x : α × β), f x.fst)
{α : Type u_2} {β : Type u_3} {γ : Type u_4} [rα : NonUnitalNonAssocSemiring α] [rβ : NonUnitalNonAssocSemiring β] {rγ : NonUnitalNonAssocSemiring γ} {δ : Type u_1} {rδ : NonUnitalNonAssocSemiring δ} (f : α →ₙ+* β) (g : β →ₙ+* γ) (h : γ →ₙ+* δ) : (h.comp g).comp f = h.comp (g.comp f)
(Γ₀ : Type u_1) [LinearOrderedCommGroupWithZero Γ₀] : Directed GE (λ (γ₀ : Γ₀ˣ), Filter.principal {γ : Γ₀ | γ < ↑γ₀})
(n : ℕ) {a : ℝ} (h : Real.sqrt_two_Add_series (↑0 / ↑1) n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2) : a < Real.pi
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X : C} (p : X ⟶ X) (hp : p ≫ p = p) : (𝟙 X - p) ≫ (𝟙 X - p) = 𝟙 X - p
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} {s t : Set α} (hst : s ⊆ t) (ht : t.finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ t  s), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ t), f i))
{α : Type u_1} {β : Type u_4} [PartialOrder α] [PartialOrder β] {u : β → α} (l : LowerAdjoint u) : l.closed = Set.Range (u ∘ ⇑l)
{G : Type u} [Group G] [Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] (hdvd : p ^ (n + 1) ∣ Fintype.card G) {H : Subgroup G} (hH : Fintype.card ↥H = p ^ n) : p ^ (n + 1) ∣ Fintype.card ↥(H.normalizer)
{E : Type u_1} {β : Type u_2} [AddCommGroup E] [TopologicalSpace E] [Module ℝ E] [TopologicalAddGroup E] [HasContinuousSmul ℝ E] [OrderedAddCommGroup β] [Module ℝ β] [OrderedSmul ℝ β] {s : Set E} {f : E → β} {a : E} (a_in_s : a ∈ s) (h_localmax : is_IsLocalMaxOn f s a) (h_conc : ConcaveOn ℝ s f) : IsMaxOn f s a
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {x : E} {n : ℕ} : iterated_fderiv 𝕜 (n + 1) f x = (⇑(Continuous_multilinear_Curry_Right_Equiv' 𝕜 n E F) ∘ iterated_fderiv 𝕜 n (λ (y : E), fderiv 𝕜 f y)) x
{ι : Type u_1} {R : Type u_2} [CommRing R] [LinearOrder ι] (s : Finset ι) (f g : ι → R) : s.prod (λ (i : ι), f i - g i) = s.prod (λ (i : ι), f i) - s.sum (λ (i : ι), g i * (Finset.filter (λ (_x : ι), _x < i) s).prod (λ (j : ι), f j - g j) * (Finset.filter (λ (j : ι), i < j) s).prod (λ (j : ι), f j))
(p : ℕ) [Fact (Nat.Prime p)] (a : ℤ) : zmod.legendre_Sym p a = 0 ↔ ↑a = 0
(i j : ℕ) (h : j + 1 = i) : algebraic_topology.dold_kan.c.rel i j
{α : Type u_1} [MetricSpace α] {K : Nnreal} {f : α → α} (hF : ContractingWith K f) [Nonempty α] [CompleteSpace α] : Function.IsFixedPt f (contracting_with.fixed_point f hF)
{α : Type u_1} [HasMul α] [Preorder α] [CovariantClass α α has_mul.mul has_lt.lt] [CovariantClass α α (Function.swap has_mul.mul) has_le.le] {a b c d : α} (h₁ : a < b) (h₂ : c < d) : a * c < b * d
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f g : α → M} (hF : (Function.MulSupport f).finite) (hg : (Function.MulSupport g).finite) : finprod (λ (i : α), f i * g i) = finprod (λ (i : α), f i) * finprod (λ (i : α), g i)
{α : Type u} [PseudoMetricSpace α] {s t : Set α} : 0 ≤ metric.Hausdorff_dist s t
{K : Type u} [Field K] (s : Subfield K) {l : List K} : (∀ (x : K), x ∈ l → x ∈ s) → l.sum ∈ s
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (u : E) {v : E} (hv : v ∈ (Submodule.span 𝕜 {u})ᗮ) : HasInner.inner u v = 0
{R : Type u_1} {a : R} [CancelMonoidWithZero R] [Nontrivial R] : IsRegular a ↔ a ≠ 0
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {a : α} {s : Set α} (f : α → M) (h : a ∉ s) (hs : (s ∩ Function.Support f).finite) : finsum (λ (i : α), finsum (λ (H : i ∈ HasInsert.insert a s), f i)) = f a + finsum (λ (i : α), finsum (λ (H : i ∈ s), f i))
{α : Type u_1} {n : Type u_4} [HasZero α] [DecidableEq n] {A : Matrix n n α} (h : A.is_diag) : Matrix.diagonal A.diag = A
{R : Type u_1} [CommRing R] [is_IsDomain R] {f : Polynomial R} {P : Ideal R} (hP : P.is_Prime) (hfl : f.leading_Coeff ∉ P) (hfP : ∀ (n : ℕ), ↑n < f.degree → f.coeff n ∈ P) (hfd0 : 0 < f.degree) (h0 : f.coeff 0 ∉ P ^ 2) (hu : f.is_primitive) : Irreducible f
{α : Type u} [PseudoMetricSpace α] {s : Set α} {x : α} (h : s.nonempty) : emetric.inf_edist x s ≠ ⊤
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x₁ x₂ y z : V} (hx₁yne : x₁ ≠ y) (hx₁zne : x₁ ≠ z) (hx₂yne : x₂ ≠ y) (hx₂zne : x₂ ≠ z) {r : ℝ} (hx₁ : ∥x₁∥ = r) (hx₂ : ∥x₂∥ = r) (hy : ∥y∥ = r) (hz : ∥z∥ = r) : 2 • o.oangle (y - x₁) (z - x₁) = 2 • o.oangle (y - x₂) (z - x₂)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : EuclideanGeometry.angle p1 p2 p3 = Real.pi) : HasDist.dist p3 p2 ≠ 0
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommMonoid β] [Module 𝕜 E] [Module 𝕜 β] [LinearOrder E] {s : Set E} {f : E → β} (hs : Convex 𝕜 s) (hF : ∀ ⦃x y : E⦄, x ∈ s → y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → a • f x + b • f y < f (a • x + b • y)) : StrictConcaveOn 𝕜 s f
{M : Type u_1} [AddZeroClass M] {p : M → Prop} (x : M) {s : Set M} (hs : AddSubmonoid.closure s = ⊤) (Hs : ∀ (x : M), x ∈ s → p x) (H1 : p 0) (hMul : ∀ (x y : M), p x → p y → p (x + y)) : p x
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : ∥x + y∥ = ∥x∥ + ∥y∥ ↔ InnerProductGeometry.angle x y = 0
{D : Set ℝ} (hD : Convex ℝ D) (hD₂ : is_IsOpen D) {f : ℝ → ℝ} (hF' : DifferentiableOn ℝ f D) (hF'' : ∀ (x : ℝ), x ∈ D → 0 < deriv^[2] f x) : StrictConvexOn ℝ D f
{r p : Nnreal} : ↑(r - p) = ↑r - ↑p
{G : Type u_1} [Group G] (H : ℕ → Subgroup G) (hH : IsDescendingCentralSeries H) (n : ℕ) : lower_central_series G n ≤ H n
(p : ℕ) [p_Prime : Fact (Nat.Prime p)] (q : ℚ) : padic_val_rat p q⁻¹ = -padic_val_rat p q
{k : Type u_1} {V : Type u_2} [Ring k] [AddCommGroup V] [Module k V] {ι : Type u_4} (s : Finset ι) (p : ι → V) (w : ι → k) (hw : s.sum (λ (i : ι), w i) = 1) : ⇑(s.affine_combination p) w = s.sum (λ (i : ι), w i • p i)
{α : Type u} [Preorder α] {f : ℤ → α} (hF : Antitone f) (n : ℤ) {x : α} (h1 : f (n + 1) < x) (h2 : x < f n) (a : ℤ) : f a ≠ x
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f : ℂ → E} {c : ℂ} {R C : ℝ} (hR : 0 < R) (hc : ContinuousOn f (Metric.Sphere c R)) (hF : ∀ (z : ℂ), z ∈ Metric.Sphere c R → ∥f z∥ ≤ C) (hlt : ∃ (z : ℂ) (H : z ∈ Metric.Sphere c R), ∥f z∥ < C) : ∥∮ (z : ℂ) in C(c, R), f z∥ < 2 * Real.pi * R * C
{α : Type u_1} [MeasurableSpace α] {f : ℕ → α → Ennreal} {g : α → Ennreal} (hF : ∀ (i : ℕ), Measurable (f i)) (lim : Filter.Tendsto f filter.at_Top (nhds g)) : Measurable g
{ι : Type u} {f g : ι → Nnreal} {A B : Nnreal} {p q : ℝ} (hpq : p.is_conjugate_exponent q) (hF : HasSum (λ (i : ι), f i ^ p) (A ^ p)) (hg : HasSum (λ (i : ι), g i ^ q) (B ^ q)) : ∃ (C : Nnreal), C ≤ A * B ∧ HasSum (λ (i : ι), f i * g i) C
{α : Type u_1} {β : Type u_2} {la : Filter α} {lb : Filter β} {f : α → Set β} : Filter.Tendsto f la lb.small_sets ↔ ∀ (t : Set β), t ∈ lb → (∀ᶠ (x : α) in la, f x ⊆ t)
(R : Type u_1) [CommRing R] [LocalRing R] (q : ℕ) [Char_R_q : Char_p R q] : q = 0 ∨ IsPrimePow q
(x y : Pgame) : x < y ∨ x.equiv y ∨ y < x ∨ x.fuzzy y
{M : Type u_1} [MulOneClass M] (S : Submonoid M) : S = ⊥ ∨ Nontrivial ↥S
{R : Type u_1} {a : R} [Monoid R] (n : ℕ) (rla : IsLeftRegular a) : IsLeftRegular (a ^ n)
{G : Type u_1} [Group G] (H : Subgroup G) {x : G} : x ∈ H → x⁻¹ ∈ H
(𝕜 : Type u_1) (E : Type u_2) [OrderedSemiring 𝕜] [OrderedAddCommGroup E] [Module 𝕜 E] [OrderedSmul 𝕜 E] : (Convex_cone.positive_cone 𝕜 E).salient
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s u : Set E} {f : E → F} {x : E} {n : ℕ} (hu : u ∈ nhds_within x s) (hs : UniqueDiffOn 𝕜 s) (xs : x ∈ s) : iterated_fderiv_within 𝕜 n f (s ∩ u) x = iterated_fderiv_within 𝕜 n f s x
{C : Type u₁} [CategoryTheory.Category C] (P : Cᵒᵖ ⥤ Type (max v₁ u₁)) {X : C} (S : CategoryTheory.Sieve X) : CategoryTheory.Presieve.IsSheafFor P ⇑S ↔ Nonempty (CategoryTheory.Limits.IsLimit (Category_theory.limits.fork.of_ι (Category_theory.equalizer.fork_Map P ⇑S) _))
{X : Type u} {Y : Type v} [Preorder X] [Preorder Y] (f : X ⥤ Y) : Monotone f.obj
{R₁ : Type u_1} {R₂ : Type u_2} [Semiring R₁] [Semiring R₂] {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_4} [TopologicalSpace M₁] [AddCommMonoid M₁] {M₂ : Type u_6} [TopologicalSpace M₂] [AddCommMonoid M₂] [Module R₁ M₁] [Module R₂ M₂] [RingHomSurjective σ₁₂] [TopologicalSpace R₁] [TopologicalSpace R₂] [HasContinuousSmul R₁ M₁] [HasContinuousAdd M₁] [HasContinuousSmul R₂ M₂] [HasContinuousAdd M₂] {f : M₁ →sl[σ₁₂] M₂} (hF' : DenseRange ⇑f) {s : Submodule R₁ M₁} (hs : s.topological_Closure = ⊤) : (Submodule.map ↑f s).topological_Closure = ⊤
{α : Type u_1} {ι : sort u_4} {ι' : sort u_5} {s : ι → ι' → Set α} : (⋃ (j : ι'), ⋂ (i : ι), s i j) ⊆ ⋂ (i : ι), ⋃ (j : ι'), s i j
{α : Type u_1} {β : Type u_2} {M : Type u_5} [CommMonoid M] {g : β → M} (e : α → β) (hE₀ : Function.bijective e) : finprod (λ (i : α), g (e i)) = finprod (λ (j : β), g j)
 : Real.cos (Real.pi / 6) ^ 2 = 3 / 4
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {f : β → γ} {x : α × β} (hF : ContinuousAt f x.snd) : ContinuousAt (λ (x : α × β), f x.snd) x
{S : Type u_2} [CommRing S] {R : Type u_3} [CommRing R] [Algebra R S] {A : Type u_4} [CommRing A] [Algebra R A] [Algebra S A] [IsScalarTower R S A] {B : PowerBasis S A} (hB : IsIntegral R B.gen) [is_IsDomain S] (hmin : minpoly S B.gen = Polynomial.map (Algebra_Map R S) (minpoly R B.gen)) (n : ℕ) (i : Fin B.dim) : IsIntegral R (⇑(⇑(B.basis.repr) (B.gen ^ n)) i)
{α : Type u_1} {β : Type u_2} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] [Nonempty β] [has_One α] {f : β → α} (hF : Continuous f) (h : HasCompactMulSupport f) : ∃ (x : β), ∀ (y : β), f y ≤ f x
{M : Type u_1} {κ : Type u_2} [AddCommMonoid M] (S : Finset M) [Fintype κ] (C : M → κ) : ∃ (a : ℕ) (H : a > 0) (b : M) (c : κ), ∀ (s : M), s ∈ S → C (a • s + b) = c
{R : Type u_1} {a : R} [Monoid R] {n : ℕ} (n0 : 0 < n) : IsRightRegular (a ^ n) ↔ IsRightRegular a
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : LocalHomeomorph α β) {b : β} (hb : b ∈ e.to_local_equiv.target) {f : β → E} {g : β → F} : f =O[nhds b] g ↔ (f ∘ ⇑e) =O[nhds (⇑(e.symm) b)] (g ∘ ⇑e)
(A : Type u_2) (K : Type u_3) [CommRing A] [Field K] [is_IsDomain A] [Algebra A K] [IsFractionRing A K] (L : Type u_4) [Field L] [Algebra K L] [FiniteDimensional K L] [Algebra A L] [IsScalarTower A K L] : ∃ (s : Finset L) (b : Basis ↥s K L), ∀ (x : ↥s), IsIntegral A (⇑b x)
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {f : M →* P} (x : M) : ⇑(Con.ker_Lift f) ↑x = ⇑f x
{α : Type u_1} {s : Set (Set α)} (hs : IsPiSystem s) : Measurable_space.generate_from s = (MeasurableSpace.DynkinSystem.generate s).to_MeasurableSpace _
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} {V₂ : Type u_5} {P₂ : Type u_6} [AddCommGroup V₂] [Module k V₂] [AddTorsor V₂ P₂] {p : ι → P} (e : P ≃ᵃ[k] P₂) : AffineIndependent k (⇑e ∘ p) ↔ AffineIndependent k p
{α : Type u_1} {β : Type u_2} [ConditionallyCompleteLattice α] [SemilatticeSup β] {f g : β → α} (h : Antitone (λ (n : β), Set.Icc (f n) (g n))) (h' : ∀ (n : β), f n ≤ g n) : (⨆ (n : β), f n) ∈ ⋂ (n : β), Set.Icc (f n) (g n)
{M : Type u_1} [SemiNormedGroup M] (S : AddSubgroup M) : S.normed_mk.is_Quotient
{C : Type u} [CategoryTheory.Category C] {A B R : C} {f g : R ⟶ A} {q : A ⟶ B} (h : CategoryTheory.IsKernelPair q f g) : CategoryTheory.IsReflexivePair f g
{α : Type u} [PseudoEmetricSpace α] (f : ℕ → α) {m n : ℕ} (h : m ≤ n) : HasEdist.edist (f m) (f n) ≤ (Finset.ico m n).sum (λ (i : ℕ), HasEdist.edist (f i) (f (i + 1)))
{α : sort u_1} {β : sort u_2} {γ : sort u_3} {f : α → β → γ} (hF : Function.Injective2 f) (b : β) : Function.Injective (λ (a : α), f a b)
{α : Type u_1} (f : α → α) (x : α) : Function.IsPeriodicPt f 0 x
{α : Type u_3} {β : Type u_4} [LinearOrderedField α] {l : Filter β} {f : β → α} {r : α} (hr : 0 < r) (hF : Filter.Tendsto f l filter.at_Top) : Filter.Tendsto (λ (x : β), f x / r) l filter.at_Top
{R : Type u_2} {Γ₀ : Type u_3} {Γ'₀ : Type u_4} [LinearOrderedAddCommMonoidWithTop Γ₀] [LinearOrderedAddCommMonoidWithTop Γ'₀] [Ring R] {v₁ : AddValuation R Γ₀} {v₂ : AddValuation R Γ'₀} {S : Type u_1} [Ring S] (f : S →+* R) (h : v₁.is_Equiv v₂) : (AddValuation.comap f v₁).is_Equiv (AddValuation.comap f v₂)
{G : Type u_4} [NormedGroup G] [NormedSpace ℝ G] {s : Set G} (conv : Convex ℝ s) (hs : (Interior s).nonempty) : UniqueDiffOn ℝ s
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {J : Type v} [Fintype J] {f : J → C} [CategoryTheory.Limits.HasBiproduct f] : finset.univ.sum (λ (j : J), CategoryTheory.Limits.biproductπ f j ≫ CategoryTheory.Limits.biproductι f j) = 𝟙 (⨁ f)
{α : Type u_1} [Preorder α] [OrderTop α] {a : α} : IsCoatom a → IsAtom (⇑order_dual.to_dual a)
{α : Type u} {β : Type v} [PseudoMetricSpace α] [PseudoMetricSpace β] {f : α → β} : Isometry f ↔ ∀ (x y : α), HasDist.dist (f x) (f y) = HasDist.dist x y
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {E' : Type u_7} [InnerProductSpace 𝕜 E'] {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 ⇑v) (f : E ≃ₗᵢ[𝕜] E') : Orthonormal 𝕜 ⇑(v.map f.to_LinearEquiv)
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M →* P} (hg : ∀ (y : ↥S), IsUnit (⇑g ↑y)) {x y : M} (h : ⇑(f.to_Map) x = ⇑(f.to_Map) y) : ⇑g x = ⇑g y
{α : Type u_1} {β : Type u_2} [Nontrivial α] {f : α → β} (hF : Function.Injective f) (y : β) : ∃ (x : α), f x ≠ y
{α : Type u_1} [SemiNormedRing α] [NormOneClass α] (a : α) (n : ℕ) : ∥a ^ n∥ ≤ ∥a∥ ^ n
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMaxOrder α] {a : α} {s : Set α} : s ∈ nhds_within a (Set.Ici a) ↔ ∃ (u : α) (H : u ∈ Set.Ioi a), Set.Ico a u ⊆ s
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {f : E → ℝ} {s : Set E} {x y : E} {f' : E → (E →L[ℝ] ℝ)} (hF : ∀ (x : E), x ∈ s → HasFderivWithinAt f (f' x) s x) (hs : Convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∃ (z : E) (H : z ∈ Segment ℝ x y), f y - f x = ⇑(f' z) (y - x)
(p : ℕ) [hp : Fact (Nat.Prime p)] {q r : ℚ} : padic_norm p (q + r) ≤ Linear_order.max (padic_norm p q) (padic_norm p r)
{R : Type u_1} [CommRing R] : is_is_IsOpenMap ⇑(PrimeSpectrum.comap Polynomial.c)
{α : Type u} {G : Type u_1} [Group G] (f g : FreeGroup α →* G) (h : ∀ (a : α), ⇑f (FreeGroup.of a) = ⇑g (FreeGroup.of a)) : f = g
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] {f : Filter α} {a : α} (hl : Filter.IsBounded has_le.le f) (hg : Filter.IsBounded GE f) (hs : f.Limsup = a) (hi : f.Liminf = a) : f ≤ nhds a
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {s : Set E} {f : E → F} {n : WithTop ℕ} (hF : ContDiffOn 𝕜 n f s) (g : G →L[𝕜] E) : ContDiffOn 𝕜 n (f ∘ ⇑g) (⇑g ⁻¹' s)
{M : Type u_1} [AddMonoid M] (x : M) : IsAddSubmonoid (Multiples x)
{a b c : ℝ} : IntervalIntegrable (λ (x : ℝ), (x - c)⁻¹) MeasureTheory.MeasureSpace.volume a b ↔ a = b ∨ c ∉ Set.Interval a b
{α : Type u_1} {m : Set α → Ennreal} {s t : Set α} (h : ∀ (u : Set α), (s ∩ u).nonempty → (t ∩ u).nonempty → m u = ⊤) : ⇑(measure_theory.outer_measure.bounded_by m) (s ∪ t) = ⇑(measure_theory.outer_measure.bounded_by m) s + ⇑(measure_theory.outer_measure.bounded_by m) t
{D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ} (hF : ContinuousOn f D) (hF' : ∀ (x : ℝ), x ∈ Interior D → deriv f x < 0) : StrictAntiOn f D
{α : Type u} {β : Type v} [TopologicalSpace α] {f : Filter β} {g : β → α} (h : ∃ (a : α), Filter.Tendsto g f (nhds a)) : Filter.Tendsto g f (nhds (lim f g))
{ι : Type u_1} {R : Type u_2} {N : Type u_5} [Ring R] [AddCommGroup N] [Module R N] [NoZeroSmulDivisors R N] (p : ι → Submodule R N) (hp : CompleteLattice.Independent p) {v : ι → N} (hv : ∀ (i : ι), v i ∈ p i) (hv' : ∀ (i : ι), v i ≠ 0) : LinearIndependent R v
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {n : WithTop ℕ} {s : Set E} {f g : E → 𝕜} (hF : ContDiffOn 𝕜 n f s) (hg : ContDiffOn 𝕜 n g s) : ContDiffOn 𝕜 n (λ (x : E), f x * g x) s
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {f : α → β} (is_IsOpenMap : is_is_IsOpenMap f) (Cont : Continuous f) (surj : Function.Surjective f) : QuotientMap f
{M : Type u_1} [HasMul M] (S : Subsemigroup M) {x y : M} : x ∈ S → y ∈ S → x * y ∈ S
{R : Type u_1} [CommRing R] {S : Type u_2} [CommRing S] [Algebra R S] [is_IsDomain S] (H : Algebra.IsIntegral R S) (P : Ideal R) [P.is_Prime] (hP : (Algebra_Map R S).ker ≤ P) : ∃ (Q : Ideal S), Q.is_Prime ∧ Ideal.comap (Algebra_Map R S) Q = P
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) [CategoryTheory.Limits.HasLimits C] (i : D.to_glue_data.J) (U : TopologicalSpace.Opens ↥((D.to_glue_data.U i).carrier)) : D.diagram_over_IsOpen_π U i ≫ D.ι_Inv_Appπ_Eq_Map U ≫ D.ι_Inv_App U = 𝟙 (CategoryTheory.Limits.limit (D.diagram_over_IsOpen U))
{𝕜 : Type u_1} [is_R_or_C 𝕜] {F : Type u_2} [SemiNormedGroup F] [NormedSpace 𝕜 F] [NormedSpace ℝ F] [IsScalarTower ℝ 𝕜 F] (fr : F →L[ℝ] ℝ) (x : F) : ∥⇑(fr.to_Linear_map.extend_to𝕜') x∥ ≤ ∥fr∥ * ∥x∥
{ι : Type u} {X : Type v} [TopologicalSpace X] {s : Set X} [NormalSpace X] (hs : is_IsClosed s) (U : ι → Set X) (ho : ∀ (i : ι), is_IsOpen (U i)) (hF : LocallyFinite U) (hU : s ⊆ ⋃ (i : ι), U i) : ∃ (f : BumpCovering ι X s), f.is_subordinate U
{α : Type u_1} {n : Type u_4} {m : Type u_5} [HasZero α] {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α} {D : Matrix n n α} : (matrix.from_blocks A B C D).is_diag ↔ A.is_diag ∧ B = 0 ∧ C = 0 ∧ D.is_diag
 : Set.Unbounded has_lt.lt {b : Ordinal | b.card.ord = b ∧ Ordinal.omega ≤ b}
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : E → ℝ} {a : E} (h : IsLocalExtr f a) : fderiv ℝ f a = 0
{α : Type u} [TopologicalSpace α] {s : Set (α × α)} {x : α} (hx : s ∈ nhds (x, x)) : ∃ (U : Set α), is_IsOpen U ∧ x ∈ U ∧ U ×ˢ U ⊆ s
{C : Type u} [CategoryTheory.Category C] {D : Type u_1} [CategoryTheory.Category D] [CategoryTheory.Abelian C] [CategoryTheory.HasInjectiveResolutions C] [CategoryTheory.Abelian D] {F G : C ⥤ D} [F.additive] [G.additive] (α : F ⟶ G) (n : ℕ) {X : C} (P : CategoryTheory.InjectiveResolution X) : (Category_theory.nat_trans.right_derived α n).app X = (F.right_derived_obj_iso n P).hom ≫ (homology_Functor D (ComplexShape.up ℕ) n).map ((Category_theory.nat_trans.map_HomologicalComplex α (ComplexShape.up ℕ)).app P.cocomplex) ≫ (G.right_derived_obj_iso n P).inv
{H : Type u_1} {M : Type u_2} [TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M] {H' : Type u_3} {M' : Type u_4} [TopologicalSpace H'] [TopologicalSpace M'] [ChartedSpace H' M'] {G : StructureGroupoid H} {G' : StructureGroupoid H'} {e e' : LocalHomeomorph M H} {f f' : LocalHomeomorph M' H'} {P : (H → H') → Set H → H → Prop} {g : M → M'} {s : Set M} {x : M} (hG : G.local_invariant_prop G' P) (hE : e ∈ StructureGroupoid.MaximalAtlas M G) (xe : x ∈ e.to_local_equiv.source) (hE' : e' ∈ StructureGroupoid.MaximalAtlas M G) (xe' : x ∈ e'.to_local_equiv.source) (hF : f ∈ StructureGroupoid.MaximalAtlas M' G') (xf : g x ∈ f.to_local_equiv.source) (hF' : f' ∈ StructureGroupoid.MaximalAtlas M' G') (xf' : g x ∈ f'.to_local_equiv.source) (hgs : ContinuousWithinAt g s x) (h : P (⇑f ∘ g ∘ ⇑(e.symm)) (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' (s ∩ g ⁻¹' f.to_local_equiv.source)) (⇑e x)) : P (⇑f' ∘ g ∘ ⇑(e'.symm)) (e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' (s ∩ g ⁻¹' f'.to_local_equiv.source)) (⇑e' x)
{p : ℕ} (hp : Nat.Prime p) {R : Type u_1} [CommRing R] [is_IsDomain R] {n : ℕ} (hn : n ≠ 0) (h : Irreducible (Polynomial.cyclotomic (p ^ n) R)) : Irreducible (Polynomial.cyclotomic p R)
{β : Type u} {α : Type v} {s : Finset α} [CommMonoid β] (f : α → β) {p : α → Prop} [DecidablePred p] (h : ∀ (x : α), x ∈ s → p x) : (Finset.subtype p s).prod (λ (x : Subtype_ p), f ↑x) = s.prod (λ (x : α), f x)
{α : Type u_3} {β : Type u_4} [LinearOrderedField α] {l : Filter β} {f : β → α} {r : α} (hr : r < 0) (hF : Filter.Tendsto f l filter.at_Top) : Filter.Tendsto (λ (x : β), f x * r) l filter.at_IsBot
{M : Type u_3} {N : Type u_4} [HasZero M] [HasZero N] {f g : ZeroHom M N} (h : f = g) (x : M) : ⇑f x = ⇑g x
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace ↥K] : Function.involutive ⇑(reflection K)
{R : Type u_1} [CommRing R] (M : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] (N : Submonoid S) (T : Type u_4) [CommRing T] [Algebra R T] [Algebra S T] [IsScalarTower R S T] [IsLocalization M S] [IsLocalization N T] : IsLocalization (is_localization.localization_Localization_Submodule M N) T
{R : Type u_1} [LinearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_3} [DecidableEq ι] [Fintype ι] (e : Basis ι R M) (x : Orientation R M ι) : x ≠ e.orientation ↔ x = -e.orientation
{b : ℕ} {l : List ℕ} (hl : ∀ (x : ℕ), x ∈ l → x < b + 2) : nat.of_digits (b + 2) l < (b + 2) ^ l.length
{C : Type u₁} [CategoryTheory.Category C] {X Y : C} (t : CategoryTheory.Limits.IsTerminal X) (f : X ⟶ Y) : CategoryTheory.Mono f
{G : Type u} [Group G] [Fintype G] (p : ℕ) {n : ℕ} [Fact (Nat.Prime p)] (hdvd : p ^ n ∣ Fintype.card G) : ∃ (K : Subgroup G), Fintype.card ↥K = p ^ n
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M →* P} {T : Submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [CommMonoid Q] {k : T.localization_Map Q} (z : N) : ⇑(f.map hy k) z * ⇑(k.to_Map) (⇑g ↑((f.sec z).snd)) = ⇑(k.to_Map) (⇑g (f.sec z).fst)
{α : Type u_1} [CancelCommMonoidWithZero α] [dec_irr : Π (p : Associates α), Decidable (Irreducible p)] [UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {p a : Associates α} (hp : Irreducible p) {n : ℕ} (h : a ∣ p ^ n) : a = p ^ p.count a.factors
{n : ℕ} (p : Fin (n + 1)) (i : Fin n) : p < ⇑(p.succ_above) i ↔ p ≤ ⇑fin.cast_Succ i
{α : Type u_1} [AddCommMonoid α] (m M N : ℕ) (f : (Σ (n : ℕ), Fin n → ℕ) → α) (g : (Σ (n : ℕ), Composition n) → α) (h : ∀ (e : Σ (n : ℕ), Fin n → ℕ) (hE : e ∈ formal_multilinear_series.comp_partial_Sum_Source m M N), f e = g (formal_multilinear_series.comp_change_of_variables m M N e hE)) : (formal_multilinear_series.comp_partial_Sum_Source m M N).sum (λ (e : Σ (n : ℕ), Fin n → ℕ), f e) = (formal_multilinear_series.comp_partial_Sum_Target m M N).sum (λ (e : Σ (n : ℕ), Composition n), g e)
{K : Type u} [Field K] (s : Subfield K) {x : K} : x ∈ s → -x ∈ s
{M : Type u_1} [AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M →+ P} {T : AddSubmonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [AddCommMonoid Q] {k : T.localization_Map Q} {A : Type u_5} [AddCommMonoid A] {U : AddSubmonoid A} {R : Type u_6} [AddCommMonoid R] (j : U.localization_Map R) {l : P →+ A} (hl : ∀ (w : ↥T), ⇑l ↑w ∈ U) (x : N) : ⇑(k.map hl j) (⇑(f.map hy k) x) = ⇑(f.map _ j) x
{α : Type u_1} {δ : Type u_5} [TopologicalSpace α] [MeasurableSpace α] [BorelSpace α] [MeasurableSpace δ] [CompleteLinearOrder α] [OrderTopology α] [TopologicalSpace.SecondCountableTopology α] {ι : Type u_2} {ι' : Type u_3} {f : ι → δ → α} {u : Filter ι} (hF : ∀ (i : ι), Measurable (f i)) {p : ι' → Prop} {s : ι' → Set ι} (hu : u.has_countable_Basis p s) (hs : ∀ (i : ι'), (s i).countable) : Measurable (λ (x : δ), u.liminf (λ (i : ι), f i x))
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) : hb.oangle (-x) y + hb.oangle (-y) x = 0
{α : Type u} [PseudoEmetricSpace α] (δ : ℝ) (E : Set α) : Closure E ⊆ Metric.Cthickening δ E
(R : Type u_1) [Ring R] : Algebra_Map ℤ R = int.cast_RingHom R
{ι : Type u} {X : Type v} [TopologicalSpace X] {s : Set X} [NormalSpace X] (hs : is_IsClosed s) (U : ι → Set X) (ho : ∀ (i : ι), is_IsOpen (U i)) (hF : LocallyFinite U) (hU : s ⊆ ⋃ (i : ι), U i) : ∃ (f : PartitionOfUnity ι X s), f.is_subordinate U
{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3
{G₀ : Type u_2} [GroupWithZero G₀] (a : G₀) : a * a⁻¹ * a = a
(𝕜 : Type u_1) (E : Type u_2) [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] : GaloisConnection Submodule.orthogonal Submodule.orthogonal
{M : Type u_1} [has_Add M] {s : Set M} : s ⊆ ↑(AddSubsemigroup.closure s)
 : Dense {x : ℝ | Liouville x}
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {b : M} [LinearOrderedCommRing M] (ht : t.nonempty) (hb : ↑(s.card) ≤ t.card • b) : ∃ (y : β) (H : y ∈ t), ↑((Finset.filter (λ (x : α), f x = y) s).card) ≤ b
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] (h : ∀ (x : E), Module.rank F ↥F⟮x⟯ = 1) : ⊥ = ⊤
{α : Type u_1} {r : Setoid α} {x y : α} : Quotient.mk' x = Quotient.mk' y ↔ r.rel x y
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [SemiNormedGroup F'] {f : α → E} {g' : α → F'} {l : Filter α} : f =o[l] g' → (f =o[l] λ (x : α), ∥g' x∥)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {u : ℕ → E} {l : E} (h : Filter.Tendsto u filter.at_Top (nhds l)) : Filter.Tendsto (λ (n : ℕ), (↑n)⁻¹ • (Finset.range n).sum (λ (i : ℕ), u i)) filter.at_Top (nhds l)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {a u' : α} {s : Set α} (hu' : a < u') : s ∈ nhds_within a (Set.Ici a) ↔ ∃ (u : α) (H : u ∈ Set.Ioi a), Set.Ico a u ⊆ s
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x y + hb.oangle y z + hb.oangle z x = 0
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (p1 p2 p3 : P) : EuclideanGeometry.angle p1 p2 p3 = EuclideanGeometry.angle p3 p2 p1
{R : Type u_1} {S : Type u_2} [CommRing R] [CommRing S] (y : R) [Algebra R S] [IsLocalization.Away y S] [H : Ideal.IsJacobson R] : Ideal.IsJacobson S
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} [CharZero k] {s : Finset ι} (p : ι → P) (h : s.nonempty) : Finset.centroid k s p ∈ affine_Span k (Set.Range p)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p : ι → P) (h : s.sum (λ (i : ι), w i) = 0) (b₁ b₂ : P) : ⇑(s.weighted_vsub_of_point p b₁) w = ⇑(s.weighted_vsub_of_point p b₂) w
(R : Type u_1) [CommRing R] (M : Type u_2) [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] [Nontrivial R] : ⇑(LinearMap.trace R M) 1 = ↑(FiniteDimensional.finrank R M)
{α : Type u_1} {β : Type u_2} [MulOneClass α] [CommGroup β] {f : α → β} (hF : IsMonoidHom f) : IsMonoidHom (λ (a : α), (f a)⁻¹)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] (p : FormalMultilinearSeries 𝕜 E F) {x y : E} (h : ↑∥x∥₊ + ↑∥y∥₊ < p.radius) : (p.change_origin x).sum y = p.sum (x + y)
{G : Type u} [CategoryTheory.Groupoid G] [IsFreeGroupoid G] {a b : G} : Nonempty (a ⟶ b) → Nonempty (Quiver.Path (symgen a) (symgen b))
{K : Type u_4} {V : Type u} {V' : Type u_8} [Field K] [AddCommGroup V] [AddCommGroup V'] [Module K V] [Module K V'] {p : Submodule K V} (f : ↥p →ₗ[K] V') : ∃ (g : V →ₗ[K] V'), g.comp p.subtype = f
(R : Type u) [Semiring R] (q : ℕ) [hp : Char_p R 0] [hq : ExpChar R q] : q = 1
{α : Type u_3} {β : Type u_4} [LinearOrderedField α] {l : Filter β} {f : β → α} {r : α} (hr : r < 0) (hF : Filter.Tendsto f l filter.at_IsBot) : Filter.Tendsto (λ (x : β), r * f x) l filter.at_Top
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι} [UniformSpace γ] {g : β → γ} (h : TendstoUniformlyOn F f p s) (hg : UniformContinuous g) : TendstoUniformlyOn (λ (i : ι), g ∘ F i) (g ∘ f) p s
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} {s : Set E} {x : E} {f' : TangentSpace (model_with_corners_self 𝕜 E) x →L[𝕜] TangentSpace (model_with_corners_self 𝕜 E') (f x)} : HasMfderivWithinAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x f' → HasFderivWithinAt f f' s x
{n : ℕ} {i j : Fin (n + 1)} (H : i ≤ j) : SimplexCategoryσ (⇑fin.cast_Succ i) ≫ SimplexCategoryσ j = SimplexCategoryσ j.succ ≫ SimplexCategoryσ i
{R : Type u_1} {S : Type u_4} [CommRing R] [CommRing S] (f : R →+* S) (p : Polynomial R) (x : S) (h : Polynomial.eval₂ f x p = 0) : f.is_integral_elem (⇑f p.leading_Coeff * x)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {f' : E ≃L[𝕜] F} {g : F → E} {a : F} (hg : ContinuousAt g a) (hF : HasFderivAt f ↑f' (g a)) (hfg : ∀ᶠ (y : F) in nhds a, f (g y) = y) : HasFderivAt g ↑(f'.symm) a
{α : Type u_1} [LinearOrderedField α] {a b c d : α} (hc : c ≠ 0) (hD : d ≠ 0) : a / c ≤ b / d → (a * d - b * c) / (c * d) ≤ 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] (s1 s2 : AffineSubspace k P) : ¬s1 ≤ s2 ↔ ∃ (p : P) (H : p ∈ s1), p ∉ s2
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) : v.int_Valuation_def 1 = 1
{α : Type u_1} [CommMonoid α] {a b : α} {u : αˣ} : ↑u * a ∣ b ↔ a ∣ b
{M : Type u_1} {R : Type u_4} [NonUnitalNonAssocSemiring R] [SetLike M R] [MulMemClass M R] {S : M} {a b : R} (ha : a ∈ AddSubmonoid.closure ↑S) (hb : b ∈ S) : a * b ∈ AddSubmonoid.closure ↑S
(z : ℂ) : ↑(z.re) = (z + ⇑(StarRing_end ℂ) z) / 2
{m : Type u_2} {n : Type u_3} {R : Type u_7} {α : Type v} [HasStar R] [HasStar α] [HasScalar R α] [StarModule R α] (c : R) (M : Matrix m n α) : (c • M).conj_transpose = HasStar.star c • M.conj_transpose
{n : ℕ} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ ⇑fin.cast_Succ j) : SimplexCategoryδ (⇑fin.cast_Succ i) ≫ SimplexCategoryσ j.succ = SimplexCategoryσ j ≫ SimplexCategoryδ i
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {J : Type v} [Fintype J] (f : J → C) [CategoryTheory.Limits.HasProduct f] : CategoryTheory.Limits.HasBiproduct f
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] [CompleteSpace E] (g : E →ₗ[𝕜] F) (hg : is_IsClosed ↑(g.graph)) : Continuous ⇑g
{𝕜 : Type u_1} {E : Type u_2} [NormedField 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [HasContinuousSmul 𝕜 E] : ⋃₀SetOf (bornology.is_vonN_bounded 𝕜) = Set.Univ
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} {a : α} : finprod (λ (i : α), finprod (λ (H : i ∈ {a}), f i)) = f a
{R : Type u_1} [NormedRing R] [CompleteSpace R] : is_IsOpen {x : R | IsUnit x}
{M : Type u_1} {N : Type u_2} [MulOneClass M] [MulOneClass N] {f g : M →* N} {s : Set M} (h : Set.EqOn ⇑f ⇑g s) : Set.EqOn ⇑f ⇑g ↑(Submonoid.closure s)
{𝕂 : Type u_1} {𝔸 : Type u_2} [is_R_or_C 𝕂] [NormedRing 𝔸] [NormedAlgebra 𝕂 𝔸] [CompleteSpace 𝔸] {x y : 𝔸} (hxy : Commute x y) : Exp 𝕂 (x + y) = Exp 𝕂 x * Exp 𝕂 y
{M : Type u_3} {N : Type u_4} [MulZeroOneClass M] [MulZeroOneClass N] {f g : M →*₀ N} (h : f = g) (x : M) : ⇑f x = ⇑g x
{R : Type u_1} {K : Type u_2} [CommRing R] [Field K] [Algebra R K] [IsFractionRing R K] [is_IsDomain R] [IsDedekindDomain R] [Fintype (ClassGroup R K)] : Fintype.card (ClassGroup R K) = 1 ↔ IsPrincipalIdealRing R
{α : Type u} [Group α] [HasLt α] [CovariantClass α α (Function.swap has_mul.mul) has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1
{α : Type u} [Ring α] {a b : α} : a ∣ a + b ↔ a ∣ b
{ι : Type w} {R : Type u} [Ring R] [RankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {J : Set M} (v : Basis ι R M) (hJ : Submodule.span R J = ⊤) : Cardinal.mk ↥(Set.Range ⇑v) ≤ Cardinal.mk ↥J
{R : Type u} [Ring R] {s : Set R} {p : R → Prop} {x : R} (h : x ∈ Subring.closure s) (Hs : ∀ (x : R), x ∈ s → p x) (H0 : p 0) (H1 : p 1) (hAdd : ∀ (x y : R), p x → p y → p (x + y)) (Hneg : ∀ (x : R), p x → p (-x)) (hMul : ∀ (x y : R), p x → p y → p (x * y)) : p x
{p : Prop} (a : Erased p) : p
{α : Type u_1} {ι : Type u_4} [LinearOrder α] [DecidableEq ι] (f : ι → α) {p : Finset ι → Prop} (s : Finset ι) (h0 : p ∅) (step : ∀ (a : ι) (s : Finset ι), a ∉ s → (∀ (x : ι), x ∈ s → f a ≤ f x) → p s → p (HasInsert.insert a s)) : p s
{M : Type u_1} [AddMonoid M] {ι : Type u_2} [hι : Nonempty ι] {s : ι → Set M} (hs : ∀ (i : ι), IsAddSubmonoid (s i)) (Directed : ∀ (i j : ι), ∃ (k : ι), s i ⊆ s k ∧ s j ⊆ s k) : IsAddSubmonoid (⋃ (i : ι), s i)
{α : Type u_1} {ι : Type u_2} {ι' : Type u_3} [Lattice α] [OrderBot α] {s : Set ι'} {g : ι' → Finset ι} {f : ι → α} (hs : s.pairwise_Disjoint (λ (i' : ι'), (g i').sup f)) (hg : ∀ (i : ι'), i ∈ s → ↑(g i).pairwise_Disjoint f) : (⋃ (i : ι') (H : i ∈ s), ↑(g i)).pairwise_Disjoint f
{G : Type u_1} [DivInvMonoid G] (a b : G) : a / b = a * b⁻¹
(x : ℤ) : ↑(x.nat_Abs) ^ 2 = x ^ 2
(R : Type u) (M : Type v) [CommRing R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] (N : Type v) [AddCommGroup N] [Module R N] [Module.Free R N] : Module.rank R (TensorProduct R M N) = Module.rank R M * Module.rank R N
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} (h : HasInner.inner x y = 0) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y : M} {r : R} (h : SameRay R x y) (hr : 0 < r) : SameRay R (r • x) y
{C : Type u} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) {A A' B B' : C} [CategoryTheory.Limits.HasBinaryCoproduct A B] [CategoryTheory.Limits.HasBinaryCoproduct A' B'] [CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)] [CategoryTheory.Limits.HasBinaryCoproduct (F.obj A') (F.obj B')] (f : A ⟶ A') (g : B ⟶ B') [CategoryTheory.IsIso (Category_theory.limits.coprod_comparison F A B)] [CategoryTheory.IsIso (Category_theory.limits.coprod_comparison F A' B')] : CategoryTheory.inv (Category_theory.limits.coprod_comparison F A B) ≫ CategoryTheory.Limits.coprod.map (F.map f) (F.map g) = F.map (CategoryTheory.Limits.coprod.map f g) ≫ CategoryTheory.inv (Category_theory.limits.coprod_comparison F A' B')
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.NormalMonoCategory C] {X Y Z : C} (a : X ⟶ Z) (b : Y ⟶ Z) [CategoryTheory.Mono a] [CategoryTheory.Mono b] : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan a b)
{α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] {f : Filter β} {u : β → α} {a : α} (hinf : a ≤ f.liminf u) (hsup : f.limsup u ≤ a) (h : Filter.IsBoundedUnder has_le.le f u . "is_bounded_Default") (h' : Filter.IsBoundedUnder GE f u . "is_bounded_Default") : Filter.Tendsto u f (nhds a)
{C : Type u₁} [CategoryTheory.Category C] {X Y : C} (t : CategoryTheory.Limits.IsInitial X) (f g : X ⟶ Y) : f = g
{M : Type u_5} [AddCommMonoid M] (h : Module ℕ M) (n : ℕ) (x : M) : n • x = n • x
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {x : 𝕜} {s : Set 𝕜} (hx : x ∈ s) : StarConvex 𝕜 x s → s.ord_connected
{𝕜 : Type u_1} {E : Type u_2} [SemiNormedRing 𝕜] [AddCommGroup E] [Module 𝕜 E] {t t' : TopologicalSpace E} (h : t ≤ t') {s : Set E} (hs : bornology.is_vonN_bounded 𝕜 s) : bornology.is_vonN_bounded 𝕜 s
{α : Type u} {β : Type v} [PseudoMetricSpace α] [PseudoMetricSpace β] {f : α → β} (hF : Isometry f) (x y : α) : HasDist.dist (f x) (f y) = HasDist.dist x y
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (f : E →L[𝕜] F) [CompleteSpace F] [CompleteSpace E] (surj : Function.Surjective ⇑f) : is_is_IsOpenMap ⇑f
 : Real.sin (Real.pi / 6) = 1 / 2
{C : Type u₁} [CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {P : Cᵒᵖ ⥤ Type v₁} (h : CategoryTheory.Presieve.IsSheafFor P ⇑S) (f : S.functor ⟶ P) : S.functor_inclusion ≫ h.extend f = f
(q : ℚ) : (GeneralizedContinuedFraction.of q).terminates
{R : Type v} [CommRing R] {n : ℕ} {A B : Matrix (Fin (n + 1)) (Fin (n + 1)) R} (c : Fin n → R) (A_Zero : ∀ (j : Fin (n + 1)), A 0 j = B 0 j) (A_Succ : ∀ (i : Fin n) (j : Fin (n + 1)), A i.succ j = B i.succ j + c i * A (⇑fin.cast_Succ i) j) : A.det = B.det
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] (f g : ℝ × ℝ → E) (f' g' : ℝ × ℝ → (ℝ × ℝ →L[ℝ] E)) (a b : ℝ × ℝ) (hle : a ≤ b) (s : Set (ℝ × ℝ)) (hs : s.countable) (Hcf : ContinuousOn f (Set.Icc a b)) (Hcg : ContinuousOn g (Set.Icc a b)) (Hdf : ∀ (x : ℝ × ℝ), x ∈ Set.Ioo a.fst b.fst ×ˢ Set.Ioo a.snd b.snd  s → HasFderivAt f (f' x) x) (Hdg : ∀ (x : ℝ × ℝ), x ∈ Set.Ioo a.fst b.fst ×ˢ Set.Ioo a.snd b.snd  s → HasFderivAt g (g' x) x) (Hi : MeasureTheory.IntegrableOn (λ (x : ℝ × ℝ), ⇑(f' x) (1, 0) + ⇑(g' x) (0, 1)) (Set.Icc a b) MeasureTheory.MeasureSpace.volume) : ∫ (x : ℝ × ℝ) in Set.Icc a b, ⇑(f' x) (1, 0) + ⇑(g' x) (0, 1) = (((∫ (x : ℝ) in a.fst..b.fst, g (x, b.snd)) - ∫ (x : ℝ) in a.fst..b.fst, g (x, a.snd)) + ∫ (y : ℝ) in a.snd..b.snd, f (b.fst, y)) - ∫ (y : ℝ) in a.snd..b.snd, f (a.fst, y)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {E' : Type u_6} [NormedGroup E'] [NormedSpace 𝕜 E'] {F' : Type u_7} [NormedGroup F'] [NormedSpace 𝕜 F'] {f : E → F} {g : E' → F'} {p : E × E'} (hF : ContDiffAt 𝕜 n f p.fst) (hg : ContDiffAt 𝕜 n g p.snd) : ContDiffAt 𝕜 n (Prod.map f g) p
{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] {s : Set E} (hs : Convex 𝕜 s) {x y : E} (hx : x ∈ Closure s) (hy : x + y ∈ Interior s) {t : 𝕜} (ht : t ∈ Set.Ioc 0 1) : x + t • y ∈ Interior s
{α : Type u} {s : Set α} : s.countable ↔ ∃ (f : α → ℕ), Set.InjOn f s
{α : Type u_1} {γ : Type u_3} [TopologicalSpace α] [MeasurableSpace α] [OpensMeasurableSpace α] [TopologicalSpace γ] [MeasurableSpace γ] [BorelSpace γ] {f : α → γ} (hF : Continuous f) : Measurable f
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (q n m : ℕ) (hnm : algebraic_topology.dold_kan.c.rel m n) {X Y : CategoryTheory.SimplicialObject C} (f : X ⟶ Y) : f.app (Opposite.op (SimplexCategory.mk n)) ≫ algebraic_topology.dold_kan.hσ' q n m hnm = algebraic_topology.dold_kan.hσ' q n m hnm ≫ f.app (Opposite.op (SimplexCategory.mk m))
(R L : Type u) [CommRing R] [CommRing L] [is_IsDomain L] [Algebra R L] [NoZeroSmulDivisors R L] (halg : Algebra.IsAlgebraic R L) : Cardinal.mk L ≤ Linear_order.max (Cardinal.mk R) Cardinal.aleph_0
{α : Type u} {β : Type v} (f : α → β) (g : β → α) : Set.MapsTo f (Function.FixedPoints (g ∘ f)) (Function.FixedPoints (f ∘ g))
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteBiproducts C] : CategoryTheory.Limits.HasBinaryBiproducts C
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s₁ s₂ : AffineSubspace ℝ P} [Nonempty ↥s₁] [CompleteSpace ↥(s₁.direction)] (hle : s₁ ≤ s₂) {p : P} (hp : p ∈ s₂) : ⇑(EuclideanGeometry.reflection s₁) p ∈ s₂
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] {a b c : α} : b < -a + c → a + b < c
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {n : WithTop ℕ} (h : ContDiff 𝕜 n f) (hn : 1 ≤ n) : Continuous (λ (p : E × E), ⇑(fderiv 𝕜 f p.fst) p.snd)
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] [DiscreteTopology α] {f : α → β → γ} (hF : ∀ (a : α), Continuous (f a)) : Continuous (Function.uncurry f)
(M : Type u_1) (α : Type u_2) [Monoid M] [MulAction M α] {ι : sort u_3} {P : ι → Submonoid M} : MulAction.FixedPoints ↥(supr P) α = ⋂ (i : ι), MulAction.FixedPoints ↥(P i) α
{K : Type u_1} {n : ℕ} {s : Seq (GeneralizedContinuedFraction.Pair K)} [DivisionRing K] {m : ℕ} (m_Lt_n : m < n) : (generalized_continued_fraction.squash_Seq s n).nth m = s.nth m
{𝕜 : Type u_1} {E : Type u_2} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {p₁ p₂ : FormalMultilinearSeries 𝕜 𝕜 E} {f : 𝕜 → E} {x : 𝕜} (h₁ : HasFpowerSeriesAt f p₁ x) (h₂ : HasFpowerSeriesAt f p₂ x) : p₁ = p₂
(p q r : ℕ+) : 1 < ADE_inequality.sum_Inv {p, q, r} ↔ ADE_inequality.admissible {p, q, r}
{α : Type u_3} {β : Type u_4} [Preorder α] [Preorder β] {f : α → β} (hF : Monotone f) (h : ∀ (b : β), ∃ (a : α), f a ≤ b) : Filter.Tendsto f filter.at_IsBot filter.at_IsBot
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {f : F → G} {x : E} {y : F} (hF : ContDiffAt 𝕜 n f y) : ContDiffAt 𝕜 n (λ (x : E × F), f x.snd) (x, y)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) : hb.oangle x (⇑(hb.rotation θ) y) = hb.oangle x y + θ
{J : Type v} {C : Type u} [CategoryTheory.Category C] {X Y : C} {f : J → (X ⟶ Y)} [Nonempty J] {c : CategoryTheory.Limits.Cocone (Category_theory.limits.parallel_family f)} (i : CategoryTheory.Limits.IsColimit c) : CategoryTheory.Epi (c.ι.app CategoryTheory.Limits.WalkingParallelFamily.one)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P (n + 1)) (i : Fin (n + 2)) : FiniteDimensional.finrank ℝ ↥((s.altitude i).direction) = 1
(x y : Pgame) : (x * y).equiv (y * x)
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {δ : Type u_1} [LinearOrder δ] [TopologicalSpace δ] [OrderClosedTopology δ] {f : α → δ} {s : Set α} [s.ord_connected] (hs : s.nonempty) (hF : ContinuousOn f s) (hbot : Filter.Tendsto (λ (x : ↥s), f ↑x) filter.at_IsBot filter.at_IsBot) (htop : Filter.Tendsto (λ (x : ↥s), f ↑x) filter.at_Top filter.at_Top) : Set.SurjOn f s Set.Univ
{E : Type u_1} [InnerProductSpace ℝ E] {n : ℕ} [Fact (FiniteDimensional.finrank ℝ E = n + 1)] : ContMdiff (model_with_corners_self ℝ (EuclideanSpace ℝ (Fin n))) (model_with_corners_self ℝ E) ⊤ Coe
(p : ℝ × ℝ) (hp : 0 < p.fst) : HasStrictFderivAt (λ (x : ℝ × ℝ), x.fst ^ x.snd) ((p.snd * p.fst ^ (p.snd - 1)) • ContinuousLinearMap.fst ℝ ℝ ℝ + (p.fst ^ p.snd * Real.log p.fst) • ContinuousLinearMap.snd ℝ ℝ ℝ) p
{α : Type u_1} [NormedDivisionRing α] {a : α} (ha : a ≠ 0) : Filter.Tendsto (has_mul.mul a) (Filter.comap HasNorm.norm filter.at_Top) (Filter.comap HasNorm.norm filter.at_Top)
{α : Type u_1} [HasMul α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] {b c : α} (bc : b < c) (a : α) : a * b < a * c
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x z - hb.oangle y z = hb.oangle x y
(A : Type u_4) [CommRing A] [is_IsDomain A] {L : Type u_6} [Field L] [Algebra A L] (C : Type u_7) [CommRing C] [is_IsDomain C] [Algebra C L] [is_IsIntegralClosure C A L] [Algebra A C] [IsScalarTower A C L] (alg : Algebra.IsAlgebraic A L) (inj : ∀ (x : A), ⇑(Algebra_Map A L) x = 0 → x = 0) : IsFractionRing C L
{α : Type u} [Preorder α] (a : α) : a ≤ a
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : HasInner.inner x y ≤ ∥x∥ * ∥y∥
{E : Type u_1} {PE : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [MetricSpace PE] [NormedAddTorsor E PE] {F : Type u_3} {PF : Type u_4} [NormedGroup F] [NormedSpace ℝ F] [MetricSpace PF] [NormedAddTorsor F PF] (f : PE ≃ᵢ PF) (x y : PE) : ⇑f (midpoint ℝ x y) = midpoint ℝ (⇑f x) (⇑f y)
{E : Type u_1} (R : Type u_2) (S : Type u_3) [AddCommGroup E] [DivisionRing R] [DivisionRing S] [Module R E] [Module S E] (n : ℕ) (x : E) : (↑n)⁻¹ • x = (↑n)⁻¹ • x
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
(k : Type u_1) (G : Type u_2) [CommSemiring k] [Group G] [Fintype G] [Invertible ↑(Fintype.card G)] (g : G) : Finsupp.single g 1 * GroupAlgebra.average k G = GroupAlgebra.average k G
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasZeroObject C] (X : C) : CategoryTheory.Simple X ↔ IsSimpleOrder (CategoryTheory.Subobject X)
{α : Type u_1} [SemiNormedRing α] (a : α) {n : ℕ} : 0 < n → ∥a ^ n∥₊ ≤ ∥a∥₊ ^ n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X Y : C} (f g : X ⟶ Y) [CategoryTheory.Limits.HasBinaryBiproduct X X] : f + g = CategoryTheory.Limits.biprod.lift (𝟙 X) (𝟙 X) ≫ CategoryTheory.Limits.biprod.desc f g
{α : Type u_1} {β : Type u_2} (f : α → β) : Function.Injective f ↔ setoid.ker f = ⊥
{α : Type u_1} {G : Type u_4} {s : Set α} [DivisionCommMonoid G] (f g : α → G) (hs : s.finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i / g i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) / finprod (λ (i : α), finprod (λ (H : i ∈ s), g i))
{α : Type u_1} [PseudoMetricSpace α] (x y : α) : HasEdist.edist x y < ⊤
{R : Type u} [Semiring R] {S : Type v} [Semiring S] (f : R →+* S) (r : R) : ⇑Polynomial.c (⇑f r) ∈ Polynomial.lifts f
{α : Type u_1} {β : Type u_2} {f : α → β} : Monotone (Set.image f)
{k : Type u_1} {K : Type u_2} [Field k] [IsAlgClosed k] [Field K] {f : K →+* k} (p : Polynomial K) : Polynomial.Splits f p
{α : Type u_1} {ι : Type u_3} [CompleteLattice α] [Fintype ι] {f : ι → α} : finset.univ.sup_indep f → CompleteLattice.Independent f
{α : Type u_1} {l₁ l₂ : List α} : l₁ <+: l₂ → l₁.reverse <:+ l₂.reverse
 : Filter.Tendsto (λ (x : ℝ), Real.exp (-x)) filter.at_Top (nhds 0)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι →₀ 𝕜) (i : ι) : HasInner.inner (⇑(Finsupp.total ι E 𝕜 v) l) (v i) = ⇑(StarRing_end 𝕜) (⇑l i)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} {r' : Nnreal} (hF : HasFpowerSeriesOnBall f p x r) (h : ↑r' < r) : ∃ (a : ℝ) (H : a ∈ Set.Ioo 0 1) (C : ℝ) (H : C > 0), ∀ (y : E), y ∈ Metric.Ball 0 ↑r' → ∀ (n : ℕ), ∥f (x + y) - p.partial_Sum n y∥ ≤ C * (a * (∥y∥ / ↑r')) ^ n
{R : Type u_1} [NormedRing R] [CompleteSpace R] : is_is_IsOpenMap Coe
{𝕂 : Type u_1} [is_R_or_C 𝕂] {x : 𝕂} : HasStrictDerivAt (Exp 𝕂) (Exp 𝕂 x) x
{n : ℕ} {l : List ℕ} (h₁ : l.prod = n) (h₂ : ∀ (p : ℕ), p ∈ l → Nat.Prime p) : l ~ n.factors
{α : Type u} [Preorder α] {x y : α} (h : x = y) : y ≤ x
 : ¬set.univ.countable
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {n : WithTop ℕ} (h : ContDiff 𝕜 n f) (hn : 1 ≤ n) : Differentiable 𝕜 f
{S : Type u} [Semigroup S] {a b x y z : S} (ha : SemiconjBy a y z) (hb : SemiconjBy b x y) : SemiconjBy (a * b) x z
{𝕜 : Type u_1} {E : Type u_2} [SemiNormedRing 𝕜] [HasScalar 𝕜 E] [HasZero E] [TopologicalSpace E] {s₁ s₂ : Set E} (hs₁ : bornology.is_vonN_bounded 𝕜 s₁) (hs₂ : bornology.is_vonN_bounded 𝕜 s₂) : bornology.is_vonN_bounded 𝕜 (s₁ ∪ s₂)
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] [Nontrivial E] {f g : E → F} {U : Set E} (hU : Metric.Bounded U) (hF : DiffContOnCl ℂ f U) (hg : DiffContOnCl ℂ g U) (hfg : Set.EqOn f g (Frontier U)) : Set.EqOn f g (Closure U)
{R : Type u} [Semiring R] (r : R) (n : ℕ) : Polynomial.x ^ n * ⇑Polynomial.c r = ⇑Polynomial.c r * Polynomial.x ^ n
{𝕜 : Type u_1} {E : Type u_3} [NormedField 𝕜] [AddCommGroup E] [Module 𝕜 E] {A : Set E} (hA : Balanced 𝕜 A) : Absorbs 𝕜 A A
{V : Type u_9} {K : Type u_10} [Field K] [AddCommGroup V] [Module K V] (B : BilinForm K V) (b₁ : B.nondegenerate) (b₂ : B.is_refl) {x : V} (hx : ¬B.is_IsOrtho x x) : (B.restrict (B.orthogonal (Submodule.span K {x}))).nondegenerate
{α : sort u_1} {β : sort u_2} {f : α → β} (hF : Function.bijective f) (b : β) : ∃! (a : α), f a = b
{α : Type u} [Preorder α] {a b : α} : a = b → a ≤ b
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : HasDist.dist p1 p2 = HasDist.dist p1 p3) : EuclideanGeometry.angle p1 p2 p3 = EuclideanGeometry.angle p1 p3 p2
{x y z : ℤ} (h : PythagoreanTriple x y z) (k : ℤ) : PythagoreanTriple (k * x) (k * y) (k * z)
{α : Type u_1} {ι : sort u_3} [ConditionallyCompleteLattice α] {f : ι → α} (H : BddAbove (Set.Range f)) (c : ι) : f c ≤ supr f
{C : Type u} [CategoryTheory.CategoryStruct C] {X Y : CategoryTheory.LocallyDiscrete C} {f g : X ⟶ Y} (η : f ⟶ g) : f = g
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {F : Type u_2} [NormedGroup F] [NormedSpace ℝ F] {f : E → F} {s : Set E} {x : E} {f' : E →L[ℝ] F} (f_Diff : DifferentiableOn ℝ f s) (s_conv : Convex ℝ s) (s_IsOpen : is_IsOpen s) (f_Cont : ∀ (y : E), y ∈ Closure s → ContinuousWithinAt f s y) (h : Filter.Tendsto (λ (y : E), fderiv ℝ f y) (nhds_within x s) (nhds f')) : HasFderivWithinAt f f' (Closure s) x
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {ι : Type u_3} [hne : Nonempty ι] [Fintype ι] {p : ι → P} (ha : AffineIndependent ℝ p) : ∃! (cccr : P × ℝ), cccr.fst ∈ affine_Span ℝ (Set.Range p) ∧ ∀ (i : ι), HasDist.dist (p i) cccr.fst = cccr.snd
{α : Type u_1} [PartialOrder α] [SuccOrder α] {a : α} : IsMax a → Order.succ a = a
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} (p : ι → P) (i1 : ι) : AffineIndependent k p ↔ LinearIndependent k (λ (i : {x // x ≠ i1}), p ↑i -ᵥ p i1)
{ι : Type u_1} {α : Type u_2} {E : Type u_3} [SemiNormedGroup E] {f : ι → E} (hF : Summable (λ (a : ι), ∥f a∥)) {s : α → Finset ι} {p : Filter α} [p.ne_IsBot] (hs : Filter.Tendsto s p filter.at_Top) {a : E} (ha : Filter.Tendsto (λ (b : α), (s b).sum (λ (i : ι), f i)) p (nhds a)) : HasSum f a
{α : Type u_1} {M : Type u_5} [HasZero M] {f g : α →₀ M} (h : f = g) (a : α) : ⇑f a = ⇑g a
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι} {g : ι → α} [TopologicalSpace α] (h : TendstoUniformly F f p) (hF : ContinuousAt f x) (hg : Filter.Tendsto g p (nhds x)) : Filter.Tendsto (λ (n : ι), F n (g n)) p (nhds (f x))
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₂} [CategoryTheory.Category C] [CategoryTheory.IsPreconnected J] {X Y : C} (α : (CategoryTheory.Functor.const J).obj X ⟶ (CategoryTheory.Functor.const J).obj Y) (j j' : J) : α.app j = α.app j'
{β α : Type u} (f : β → α) (θ : Cardinal) (hθ : θ ≤ Cardinal.mk β) (h₁ : Cardinal.aleph_0 ≤ θ) (h₂ : Cardinal.mk α < θ.ord.cof) : ∃ (a : α), θ ≤ Cardinal.mk ↥(f ⁻¹' {a})
{F : Type u_1} [Field F] (p q : Polynomial F) : Function.Injective ⇑(Polynomial.Gal.restrict_Prod p q)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} [DecidableEq ι] [FiniteDimensional 𝕜 E] {V : ι → Submodule 𝕜 E} (hV : OrthogonalFamily 𝕜 (λ (i : ι), (V i).subtypeₗᵢ)) : DirectSum.IsInternal V ↔ (supr V)ᗮ = ⊥
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type w} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace 𝕜] {ι : Type u_1} [Fintype ι] (v : Basis ι 𝕜 E) : ∃ (C : Nnreal) (H : C > 0), ∀ {u : E →L[𝕜] F} (M : Nnreal), (∀ (i : ι), ∥⇑u (⇑v i)∥₊ ≤ M) → ∥u∥₊ ≤ C * M
{X : Type u} [Lattice X] [JordanHolderLattice X] (s : CompositionSeries X) (x : X) (hm : JordanHolderLattice.IsMaximal x s.top) (hb : s.bot ≤ x) : ∃ (t : CompositionSeries X), t.bot = s.bot ∧ t.length + 1 = s.length ∧ ∃ (htx : t.top = x), s.equivalent (t.snoc s.top _)
(F : Type u) (K : Type v) (A : Type w) [Field F] [Field K] [AddCommGroup A] [Algebra F K] [Module K A] [Module F A] [IsScalarTower F K A] [FiniteDimensional F K] : FiniteDimensional.finrank F K * FiniteDimensional.finrank K A = FiniteDimensional.finrank F A
{𝕂 : Type u_1} {𝔸 : Type u_2} [NondiscreteNormedField 𝕂] [NormedRing 𝔸] [NormedAlgebra 𝕂 𝔸] [CompleteSpace 𝔸] (h : 0 < (Exp_series 𝕂 𝔸).radius) : HasFderivAt (Exp 𝕂) 1 0
{K : Type u_1} {v : K} {n : ℕ} [LinearOrderedField K] [FloorRing K] {b : K} (nth_Part_denom_Eq : (GeneralizedContinuedFraction.of v).partial_denominators.nth n = Option.some b) : b * (GeneralizedContinuedFraction.of v).denominators n ≤ (GeneralizedContinuedFraction.of v).denominators (n + 1)
{G : Type u} [Group G] [Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] (hdvd : p ^ (n + 1) ∣ Fintype.card G) {H : Subgroup G} (hH : Fintype.card ↥H = p ^ n) : p ∣ Fintype.card (↥(H.normalizer) ⧸ Subgroup.comap H.normalizer.subtype H)
{F : Type u_3} [Field F] [Fintype F] (hF : Ring_Char F ≠ 2) {a : F} (ha : a ≠ 0) : IsSquare a ↔ a ^ (Fintype.card F / 2) = 1
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (s : Finset ι) : Finset.centroid_weights k s = Function.const ι (↑(s.card))⁻¹
{x y : SimplexCategory} {f : x ⟶ y} : CategoryTheory.Mono f → x.len ≤ y.len
(n : ℕ) : (1 + n).pred = n
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder β] [SuccOrder β] [IsSuccArchimedean β] {s : β → Set α} (H : ∀ (n : β), IsPreconnected (s n)) (K : ∀ (n : β), (s n ∩ s (Order.succ n)).nonempty) : IsPreconnected (⋃ (n : β), s n)
(p n : ℕ) : WittPolynomial p (Zmod(p ^ (n + 1))) (n + 1) = ⇑(MvPolynomial.expand p) (WittPolynomial p (Zmod(p ^ (n + 1))) n)
{α : Type u} [PseudoMetricSpace α] {s : ℕ → α} : CauchySeq s ↔ ∃ (b : ℕ → ℝ), (∀ (n : ℕ), 0 ≤ b n) ∧ (∀ (n m N : ℕ), N ≤ n → N ≤ m → HasDist.dist (s n) (s m) ≤ b N) ∧ Filter.Tendsto b filter.at_Top (nhds 0)
{J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ Mon_) [CategoryTheory.IsFiltered J] {x y y' : Σ (j : J), ↥(F.obj j)} (hyy' : CategoryTheory.Limits.Types.FilteredColimit.Rel (F ⋙ CategoryTheory.forget Mon_) y y') : Mon.filtered_colimits.colimit_Mul_aux F x y = Mon.filtered_colimits.colimit_Mul_aux F x y'
{α : Type u} [PseudoMetricSpace α] {s : Set α} [t2_Space α] [ProperSpace α] : is_IsCompact s ↔ is_IsClosed s ∧ Metric.Bounded s
(x : ℂ) : HasDerivAt Complex.sin (Complex.cos x) x
{p : ℂ × ℂ} (h₁ : 0 ≤ p.fst.re ∨ p.fst.im ≠ 0) (h₂ : 0 < p.snd.re) : ContinuousAt (λ (x : ℂ × ℂ), x.fst ^ x.snd) p
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F ≠ 2) : char.quadratic_Char F (-1) = ⇑Zmodχ₄ ↑(Fintype.card F)
{n : ℕ} {α : Fin (n + 1) → Type u} (x : α 0) (p : Π (i : Fin n), α i.succ) (i : Fin n) (y : α i.succ) : fin.cons x (Function.update p i y) = Function.update (fin.cons x p) i.succ y
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {J : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.FinCategory J] (F : J ⥤ C) : Nonempty (CategoryTheory.Limits.Cocone F)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P : C} (a : CategoryTheory.Over P) : ↑a = 0 ↔ a.hom = 0
{R : Type u} [CommRing R] {P : Ideal R} (H : P.is_Prime) : (Ideal.map Polynomial.c P).is_Prime
{α : Type u_1} {β : Type u_2} [AddGroup α] [AddCommGroup β] {f g : α → β} (hF : IsAddGroupHom f) (hg : IsAddGroupHom g) : IsAddGroupHom (λ (a : α), f a - g a)
{a b c : Prop} : a ∧ (b ∨ c) ↔ a ∧ b ∨ a ∧ c
{R : ℝ} {c w : ℂ} {s : Set ℂ} (hs : s.countable) (hw : w ∈ Metric.Ball c R) {f : ℂ → ℂ} (hc : ContinuousOn f (Metric.ClosedBall c R)) (hD : ∀ (z : ℂ), z ∈ Metric.Ball c R  s → DifferentiableAt ℂ f z) : ∮ (z : ℂ) in C(c, R), f z / (z - w) = 2 * ↑Real.pi * Complex.i * f w
{α : Type u_1} {P : α → Prop} : Antitone (λ (s : Set α), ∀ (x : α), x ∈ s → P x)
{α : Type u} [Preorder α] {a b c : α} : b < c → a < b → a < c
{α : Type u} [TopologicalSpace α] (x : α) (c : Set (Set α)) (H1 : ∀ (s : Set α), s ∈ c → x ∈ s) (H2 : ∀ (s : Set α), s ∈ c → IsPreconnected s) : IsPreconnected (⋃₀c)
{M : Type u_1} [MulOneClass M] (S : Submonoid M) : Submonoid.closure ↑S = S
(𝕜 : Type v) [is_R_or_C 𝕜] {E : Type u} [NormedGroup E] [NormedSpace 𝕜 E] (x : E) {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ (f : NormedSpace.Dual 𝕜 E), ∥⇑f x∥ ≤ M * ∥f∥) : ∥x∥ ≤ M
{a b c : Prop} : (a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] : (Filter.cocompact α).coprod (Filter.cocompact β) = Filter.cocompact (α × β)
{G : Type u_1} {s : Set G} [Group G] : IsNormalSubgroup (group.normal_Closure s)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {n : WithTop ℕ} : ContDiff 𝕜 n Id
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b c : α} : a < b + c → a - c < b
{α : Type u} [PseudoMetricSpace α] (f : ℕ → α) (n : ℕ) : HasDist.dist (f 0) (f n) ≤ (Finset.range n).sum (λ (i : ℕ), HasDist.dist (f i) (f (i + 1)))
{α : Type u} [Preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c
{C : Type u₁} [CategoryTheory.Category C] {X Y : C} (f : X ⟶ Y) [CategoryTheory.Mono f] [CategoryTheory.SplitEpi f] : CategoryTheory.IsIso f
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] [LocallyCompactSpace (α × β)] : Continuous ContinuousMap.curry
{x y z : ℤ} (h : PythagoreanTriple x y z) (h_IsCoprime : x.gcd y = 1) (h_parity : x % 2 = 1) (h_Pos : 0 < z) : ∃ (m n : ℤ), x = m ^ 2 - n ^ 2 ∧ y = 2 * m * n ∧ z = m ^ 2 + n ^ 2 ∧ m.gcd n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0) ∧ 0 ≤ m
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] : K ⊔ Kᗮ = ⊤
{R : Type u_1} [CommRing R] (S : Type u_2) [CommRing S] [Algebra R S] (M N : Submonoid R) [IsLocalization M S] (h : M ≤ N) (h' : ∀ (x : ↥N), ∃ (m : R), m * ↑x ∈ M) : IsLocalization N S
{R : Type u} {n : ℕ} {M : Fin n.succ → Type v} {M₂ : Type v₂} [Semiring R] [Π (i : Fin n.succ), AddCommMonoid (M i)] [AddCommMonoid M₂] [Π (i : Fin n.succ), Module R (M i)] [Module R M₂] (f : MultilinearMap R M M₂) (m : Π (i : Fin n), M (⇑fin.cast_Succ i)) (x y : M (fin.last n)) : ⇑f (fin.snoc m (x + y)) = ⇑f (fin.snoc m x) + ⇑f (fin.snoc m y)
{α : Type u} {a b : α} [MulZeroOneClass α] [PartialOrder α] [ZeroLt.MulPosMono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b ≤ 1
(A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) {p : Polynomial A} (pmonic : p.monic) (hp : ⇑(Polynomial.aeval x) p = 0) : (minpoly A x).degree ≤ p.degree
{p : ℕ} [Fact (Nat.Prime p)] {f : PadicSeq p} (hF : ¬f ≈ 0) (v2 v3 : ℕ) : padic_norm p (⇑f (padic_seq.stationary_point hF)) = padic_norm p (⇑f (Linear_order.max (padic_seq.stationary_point hF) (Linear_order.max v2 v3)))
{M : Type u_3} {N : Type u_4} [MulZeroOneClass M] [MulZeroOneClass N] (f : M →*₀ N) {x y : M} (h : x = y) : ⇑f x = ⇑f y
{k : Type u_1} {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {n : ℕ} {s₁ s₂ : Affine.Simplex k P n} (h : Set.Range s₁.points = Set.Range s₂.points) : Finset.centroid k Finset.univ s₁.points = Finset.centroid k Finset.univ s₂.points
{α : Type u_1} {β : Type u_2} (f : α → β) (P : RegularExpression α) : (RegularExpression.map f P).matches = ⇑(Language.map f) P.matches
(S : Set ℝ) (hS : ∀ (x : ℝ), x ∈ S → 0 ≤ x) : 0 ≤ HasInf.inf S
(α : Type u) [MetricSpace α] [TopologicalSpace.SeparableSpace α] : ∃ (f : α → ↥(Lp (λ (n : ℕ), ℝ) ⊤)), Isometry f
{L : FirstOrder.Language} {M : Type w} [L.Structure M] (s : Set M) {p : Π (x : M), x ∈ ⇑(FirstOrder.Language.Substructure.closure L) s → Prop} (Hs : ∀ (x : M) (h : x ∈ s), p x _) (Hfun : ∀ {n : ℕ} (f : L.functions n), FirstOrder.Language.ClosedUnder f {x : M | ∃ (hx : x ∈ ⇑(FirstOrder.Language.Substructure.closure L) s), p x hx}) {x : M} (hx : x ∈ ⇑(FirstOrder.Language.Substructure.closure L) s) : p x hx
{α : Type u_1} {β : Type u_2} [CompleteLattice α] {f : Filter β} {u : β → α} : f.liminf u = ⨆ (s : Set β) (H : s ∈ f), ⨅ (a : β) (H : a ∈ s), u a
{α : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [HasZero M] [CommMonoid N] [CommMonoid P] (h : N ≃* P) (f : α →₀ M) (g : α → M → N) : ⇑h (f.prod g) = f.prod (λ (a : α) (b : M), ⇑h (g a b))
{α : Type u} [Preorder α] {s t : Set α} (h : BddAbove t) : BddAbove (s ∩ t)
{G : Type u_1} [Group G] {k : Set G} {p : G → Prop} {x : G} (h : x ∈ Subgroup.closure k) (Hk : ∀ (x : G), x ∈ k → p x) (Hk_Inv : ∀ (x : G), x ∈ k → p x⁻¹) (H1 : p 1) (hMul : ∀ (x y : G), p x → p y → p (x * y)) : p x
{Y : Type u_2} [TopologicalSpace Y] [NormalSpace Y] {s : Set Y} (f : BoundedContinuousFunction ↥s ℝ) (hs : is_IsClosed s) {t : Set ℝ} [t.ord_connected] (hF : ∀ (x : ↥s), ⇑f x ∈ t) (hne : t.nonempty) : ∃ (g : BoundedContinuousFunction Y ℝ), (∀ (y : Y), ⇑g y ∈ t) ∧ g.restrict s = f
{n : ℕ} {α : Type u_1} [Preorder α] {f g : Fin n ↪o α} (h : Set.Range ⇑f = Set.Range ⇑g) : f = g
{α : Type u} [TopologicalSpace α] {s : Set α} (H : IsPreconnected s) : IsPreconnected (Closure s)
(A B : Finset ℕ) : A.sum (λ (i : ℕ), 2 ^ i) < B.sum (λ (i : ℕ), 2 ^ i) ↔ A.to_colex < B.to_colex
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [FiniteDimensional 𝕜 E] (T : E →ₗ[𝕜] E) : InnerProductSpace.IsSelfAdjoint (⇑LinearMap.adjoint T * T)
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [LinearOrderedAddCommMonoid β] [HasScalar 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f : E → β} (hF : StrictConcaveOn 𝕜 s f) {x y : E} (hx : x ∈ s) (hy : y ∈ s) (hxy : x ≠ y) {a b : 𝕜} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : Linear_order.min (f x) (f y) < f (a • x + b • y)
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {c : ℝ} {f : α → E} {g : α → F} {l : Filter α} : asymptotics.is_O_with c l f g → (∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥)
{R : Type u_1} {S : Type u_2} [ConditionallyCompleteLinearOrder R] (s : Finset S) (f : S → Tropical (WithTop R)) : Tropical.untrop (s.sum (λ (i : S), f i)) = ⨅ (i : ↥s), Tropical.untrop (f ↑i)
{ι : Type u_1} {𝕜 : Type u_3} [is_R_or_C 𝕜] {E : Type u_4} [InnerProductSpace 𝕜 E] {E' : Type u_5} [InnerProductSpace 𝕜 E'] [Fintype ι] (v : Basis ι 𝕜 E) (hv : Orthonormal 𝕜 ⇑v) (f : E ≃ₗᵢ[𝕜] E') : ((v.map f.to_LinearEquiv).to_Orthonormal_Basis _).repr = f.symm.trans (v.to_Orthonormal_Basis hv).repr
{α : Type u_1} {M : Type u_5} {N : Type u_7} {R : Type u_11} [Monoid R] [AddMonoid M] [AddCommMonoid N] [DistribMulAction R M] {g : α →₀ M} {b : R} {h : α → M →+ N} : (b • g).sum (λ (a : α), ⇑(h a)) = g.sum (λ (i : α) (c : M), ⇑(h i) (b • c))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : Set P} {p₀ : P} (h : p₀ ∈ s) : Collinear k s ↔ ∃ (v : V), ∀ (p : P), p ∈ s → (∃ (r : k), p = r • v +ᵥ p₀)
{R : Type u} [Field R] (p : Polynomial R) : (Multiset.map (λ (a : R), Polynomial.x - ⇑Polynomial.c a) p.roots).prod ∣ p
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {a b : α} {s : Set α} (hs : is_IsClosed (s ∩ Set.Icc a b)) (ha : a ∈ s) (hgt : ∀ (x : α), x ∈ s ∩ Set.Ico a b → s ∈ nhds_within x (Set.Ioi x)) : Set.Icc a b ⊆ s
{A : Type u_2} [NormedRing A] [NormedAlgebra ℂ A] [CompleteSpace A] [NormOneClass A] (a : A) : Filter.Tendsto (λ (n : ℕ), ennreal.of_Real (∥a ^ n∥ ^ (1 / ↑n))) filter.at_Top (nhds (spectral_radius ℂ a))
{p : ℕ+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [NeZero ↑↑p] {k : ℕ} [hpri : Fact (Nat.Prime ↑p)] [IsCyclotomicExtension {p ^ (k + 1)} K L] (hirr : Irreducible (Polynomial.cyclotomic ↑(p ^ (k + 1)) K)) (h : p ≠ 2) : ⇑(Algebra.norm K) (IsCyclotomicExtension.zeta (p ^ (k + 1)) K L - 1) = ↑p
{F : Type u} [Field F] {n : ℕ} : (Polynomial.x ^ n - 1).separable ↔ ↑n ≠ 0
{x y : Pgame} (ox : x.numeric) (oy : y.numeric) : x < y ↔ (∃ (i : y.left_moves), x ≤ y.move_Left i) ∨ ∃ (j : x.right_moves), x.move_Right j ≤ y
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} [LinearOrder 𝕜] [OrderClosedTopology 𝕜] {x y : 𝕜} (h : x < y) : HasDerivWithinAt f f' (Set.Ioi x) x → HasDerivWithinAt f f' (Set.Ioo x y) x
{α : Type u} [PartialOrder α] {a b : α} : a ≤ b → b ≤ a → a = b
(f f' : ℝ → ℝ) {a b : ℝ} (hab : a < b) (g g' : ℝ → ℝ) {lfa lga lfb lgb : ℝ} (hff' : ∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivAt f (f' x) x) (hgg' : ∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivAt g (g' x) x) (hfa : Filter.Tendsto f (nhds_within a (Set.Ioi a)) (nhds lfa)) (hga : Filter.Tendsto g (nhds_within a (Set.Ioi a)) (nhds lga)) (hfb : Filter.Tendsto f (nhds_within b (Set.Iio b)) (nhds lfb)) (hgb : Filter.Tendsto g (nhds_within b (Set.Iio b)) (nhds lgb)) : ∃ (c : ℝ) (H : c ∈ Set.Ioo a b), (lgb - lga) * f' c = (lfb - lfa) * g' c
{α : Type u} [TopologicalSpace α] {s : Set α} : Dense s → ∀ (U : Set α), is_IsOpen U → U.nonempty → (U ∩ s).nonempty
{V : Type u_1} [CategoryTheory.Category V] {A₁ B₁ C₁ A₂ B₂ C₂ A₃ B₃ C₃ : V} {f₁ : A₁ ⟶ B₁} {g₁ : B₁ ⟶ C₁} {f₂ : A₂ ⟶ B₂} {g₂ : B₂ ⟶ C₂} {f₃ : A₃ ⟶ B₃} {g₃ : B₃ ⟶ C₃} {α₁ : CategoryTheory.Arrow.mk f₁ ⟶ CategoryTheory.Arrow.mk f₂} {β₁ : CategoryTheory.Arrow.mk g₁ ⟶ CategoryTheory.Arrow.mk g₂} {α₂ : CategoryTheory.Arrow.mk f₂ ⟶ CategoryTheory.Arrow.mk f₃} {β₂ : CategoryTheory.Arrow.mk g₂ ⟶ CategoryTheory.Arrow.mk g₃} (p₁ : α₁.right = β₁.left) (p₂ : α₂.right = β₂.left) : (α₁ ≫ α₂).right = (β₁ ≫ β₂).left
{x : Pgame} : 0 ≤ x ↔ ∀ (j : x.right_moves), ∃ (i : (x.move_Right j).left_moves), 0 ≤ (x.move_Right j).move_Left i
{α : Type u_3} {β : Type u_4} {γ : Type u_5} [CommMonoid α] {f : β → α} {g : γ → α} (h_Eq : ∀ (u : Finset γ), ∃ (v : Finset β), ∀ (v' : Finset β), v ⊆ v' → (∃ (u' : Finset γ), u ⊆ u' ∧ u'.prod (λ (x : γ), g x) = v'.prod (λ (b : β), f b))) : Filter.map (λ (s : Finset β), s.prod (λ (b : β), f b)) filter.at_Top ≤ Filter.map (λ (s : Finset γ), s.prod (λ (x : γ), g x)) filter.at_Top
{R : Type u_1} {M : Type u_2} [OrderedSemiring R] [OrderedAddCommMonoid M] [SmulWithZero R M] [OrderedSmul R M] {a : M} {c : R} (hc : 0 < c) : 0 < a → 0 < c • a
{S : Set Ordinal} (hS : Set.Unbounded has_lt.lt S) (a : Ordinal) : (S ∩ Set.Ici a).nonempty
{R : Type u_1} [LinearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [FiniteDimensional R M] (x₁ x₂ : Orientation R M ι) (h : Fintype.card ι = FiniteDimensional.finrank R M) : x₁ ≠ x₂ ↔ x₁ = -x₂
{S : Type u} [AddSemigroup S] {a b x y z : S} (ha : AddSemiconjBy a y z) (hb : AddSemiconjBy b x y) : AddSemiconjBy (a + b) x z
{α : Type u} : DenseEmbedding has_pure.pure
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (f : E →L[𝕜] F) : IsBoundedLinearMap 𝕜 ⇑f
{k : Type u_1} [DivisionRing k] {ι : Type u_4} (s : Finset ι) (h : ↑(s.card) ≠ 0) : s.sum (λ (i : ι), Finset.centroid_weights k s i) = 1
{p : ℕ} (hp : Nat.Prime p) : p.factorization = Finsupp.single p 1
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s1 s2 : AffineSubspace k P} (hD : s1.direction = s2.direction) (hn : (↑s1 ∩ ↑s2).nonempty) : s1 = s2
{G : Type u_7} [AddCommGroup G] (L : List G) : -L.sum = (List.map (λ (x : G), -x) L).sum
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) : o.oangle (-x) y = o.oangle x (-y)
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) (b : n → α) (h : IsUnit A.det) : A.det • A⁻¹.mul_vec b = ⇑(A.cramer) b
{ι : Type u_1} {E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {c : E} {l l' : Filter ℝ} {Lt : Filter ι} {a : ℝ} [Interval_integral.FTC_Filter a l l'] (hfm : StronglyMeasurableAtFilter f l' MeasureTheory.MeasureSpace.volume) (hF : Filter.Tendsto f (l' ⊓ MeasureTheory.Measure_space.volume.ae) (nhds c)) {u v : ι → ℝ} (hu : Filter.Tendsto u Lt l) (hv : Filter.Tendsto v Lt l) : (λ (t : ι), (∫ (x : ℝ) in u t..v t, f x) - (v t - u t) • c) =o[Lt] (v - u)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [SemiNormedGroup E] [SemiNormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →ₛₗ[σ₁₂] F) {C : ℝ} (hC : 0 ≤ C) (h : ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_Continuous C h∥ ≤ C
{M : Type u_1} [has_Add M] (S : AddSubsemigroup M) : AddSubsemigroup.closure ↑S = S
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [OrderedSemiring 𝕜] [AddCommGroup E] [Module 𝕜 E] {p : ι → E} (hi : Function.Injective p) : ConvexIndependent 𝕜 (λ (x : ↥(Set.Range p)), ↑x) ↔ ConvexIndependent 𝕜 p
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {s : Set E} (hscomp : is_IsCompact s) (hsnemp : s.nonempty) : (Set.ExtremePoints ℝ s).nonempty
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (a b c : P) : HasDist.dist a b ^ 2 + HasDist.dist a c ^ 2 = 2 * (HasDist.dist a (midpoint ℝ b c) ^ 2 + (HasDist.dist b c / 2) ^ 2)
{M : Type u_1} {N : Type u_2} [MulOneClass M] [MulOneClass N] {c : Con M} {f : N →* M} : Con.comap ⇑f _ c = Con.ker (c.mk'.comp f)
(R : Type u_1) {S : Type u_2} {M : Type u_3} [CommRing R] [Ring S] [AddCommGroup M] [Algebra R S] [Module S M] [Module R M] [IsScalarTower R S M] (h : IsArtinian R M) : IsArtinian S M
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] : ContDiff 𝕜 ⊤ ⇑((equiv.prod_assoc E F G).symm)
{R : Type u_1} [CommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] : Disjoint (TensorAlgebraι R).range 1
(p : ℝ × ℝ) (hp : p.fst ≠ 0) {n : WithTop ℕ} : ContDiffAt ℝ n (λ (p : ℝ × ℝ), p.fst ^ p.snd) p
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (f : C(α, β)) : Continuous ⇑f
{α : Type u} [Preorder α] {a b : α} (h : a < b) : ¬b ≤ a
{M : Type u_1} [AddMonoid M] (u : AddUnits M) (a : M) : IsAddUnit (↑u + a) ↔ IsAddUnit a
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0
{α : Type u} [PseudoEmetricSpace α] (δ : ℝ) : Metric.Thickening δ ∅ = ∅
{α : Type u} {f : Filter α} {β : Type v} {s : β → Set α} (is : Finset β) : (⋂ (i : β) (H : i ∈ is), s i) ∈ f ↔ ∀ (i : β), i ∈ is → s i ∈ f
{C : Type u₁} [CategoryTheory.Category C] {X Y Z : C} (p : X ⟶ Y) (q : Z = Y) : _.mpr p = p ≫ Category_theory.eq_to_hom _
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) : hb.oangle (⇑(hb.rotation (hb.oangle x y)) x) y = 0
{M : Type u_1} [AddMonoid M] {s : Set M} : s ⊆ Add_monoid.closure s
{α : Type u} {β : Type v} [Preorder α] [Preorder β] (oi : α ≃o β) : GaloisConnection ⇑oi ⇑(oi.symm)
{R : Type u_1} {M : Type u_2} [Ring R] [TopologicalSpace R] [TopologicalSpace M] [AddCommGroup M] [HasContinuousAdd M] [Module R M] [HasContinuousSmul R M] [(nhds_within 0 {x : R | IsUnit x}).ne_IsBot] (s : Submodule R M) (hs : (Interior ↑s).nonempty) : s = ⊤
{T : ℝ} {g : ℝ → ℝ} (hg : Function.Periodic g T) (h_Int : ∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.MeasureSpace.volume t₁ t₂) (h₀ : ∀ (x : ℝ), 0 < g x) (hT : 0 < T) : Filter.Tendsto (λ (t : ℝ), ∫ (x : ℝ) in 0..t, g x) filter.at_IsBot filter.at_IsBot
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommGroup β] [HasScalar 𝕜 E] [Module 𝕜 β] {s : Set E} {f : E → β} : ConvexOn 𝕜 s f → ConcaveOn 𝕜 s (-f)
{α : Type u} [TopologicalSpace α] (Z : ℕ → Set α) (hZd : ∀ (i : ℕ), Z (i + 1) ⊆ Z i) (hZn : ∀ (i : ℕ), (Z i).nonempty) (hZ0 : is_IsCompact (Z 0)) (hZcl : ∀ (i : ℕ), is_IsClosed (Z i)) : (⋂ (i : ℕ), Z i).nonempty
{R : Type u_1} [CommSemiring R] (M : Submonoid R) {S : Type u_2} [CommSemiring S] [Algebra R S] [IsLocalization M S] (z : S) : ⇑(Algebra_Map R S) (IsLocalization.sec M z).fst = ⇑(Algebra_Map R S) ↑((IsLocalization.sec M z).snd) * z
{R : Type u_1} {a b : R} [CommSemigroup R] : IsRegular (a * b) ↔ IsRegular a ∧ IsRegular b
{η : Type u_5} {f : η → Type u_6} [Π (i : η), Group (f i)] [DecidableEq η] [Fintype η] {H : Π (i : η), Subgroup (f i)} {J : Subgroup (Π (i : η), f i)} : Subgroup.pi Set.Univ H ≤ J ↔ ∀ (i : η), Subgroup.map (MonoidHom.single f i) (H i) ≤ J
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} {s : Set α} (hF : Set.EqOn f 1 s) : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) = 1
(k : Type u_1) {V : Type u_2} (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (p : P) (s : AffineSubspace k P) : p ∈ ↑s ↔ p ∈ s
{Γ₀ : Type u_1} [LinearOrderedCommGroupWithZero Γ₀] (γ : Γ₀ˣ) : {↑γ} ∈ nhds ↑γ
{α : Type u} [PseudoMetricSpace α] {s t : Set α} {r : ℝ} (hr : 0 ≤ r) (H1 : ∀ (x : α), x ∈ s → metric.inf_dist x t ≤ r) (H2 : ∀ (x : α), x ∈ t → metric.inf_dist x s ≤ r) : metric.Hausdorff_dist s t ≤ r
{R : Type u_1} {R₁ : Type u_2} {R₂ : Type u_3} {M₁ : Type u_6} {M₂ : Type u_7} [CommSemiring R] [CommSemiring R₁] [AddCommMonoid M₁] [Module R₁ M₁] [CommSemiring R₂] [AddCommMonoid M₂] [Module R₂ M₂] {I₁ : R₁ →+* R} {I₂ : R₂ →+* R} {B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] R} : B.separating_Left ↔ B.ker = ⊥
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {ps : Set P} {n : ℕ} [FiniteDimensional ℝ V] (hD : FiniteDimensional.finrank ℝ V = n) (hc : EuclideanGeometry.Cospherical ps) {sx₁ sx₂ : Affine.Simplex ℝ P n} (hsx₁ : Set.Range sx₁.points ⊆ ps) (hsx₂ : Set.Range sx₂.points ⊆ ps) : sx₁.circumcenter = sx₂.circumcenter
{α : Type u_1} {p : Prop} {q : α → Prop} : p → ∀ (x : α), q x ↔ ∀ (x : α), p → q x
{M : Type u_1} [AddMonoid M] (c : AddCon M) (n : ℕ) {w x : M} : ⇑c w x → ⇑c (n • w) (n • x)
{R : Type u} {N : Type z} [Semiring R] [AddCommMonoid N] [Module R N] {P : Type v} [AddCommMonoid P] [Module R P] (h : Module.Free R P) (e : P ≃ₗ[R] N) : Module.Free R N
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] {a b : α} (hab : a ≠ b) : Closure (Set.Ico a b) = Set.Icc a b
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] (O : Finset C) (H : Finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y)) {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : X ⟶ Y} (mf : ⟨X, ⟨Y, ⟨mX, ⟨mY, f⟩⟩⟩⟩ ∈ H) : Category_theory.is_cofiltered.inf_to O H mX ≫ f = Category_theory.is_cofiltered.inf_to O H mY
{α : Type u_1} {β : Type u_2} [AddCommGroup α] [UniformSpace α] [UniformAddGroup α] [t1_Space α] (f : β → α) : Filter.Tendsto (λ (s : Finset β), ∑' (b : {x // x ∉ s}), f ↑b) filter.at_Top (nhds 0)
{R : Type u_1} {A : Type u_2} [CommSemiring R] [Semiring A] [Algebra R A] (h : Function.Injective ⇑(Algebra_Map R A)) (p : ℕ) [Char_p R p] : Char_p A p
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] {p1 p2 : P} (h : p1 -ᵥ p2 = 0) : p1 = p2
{G : Type u_1} [AddGroup G] [hN : Nontrivial G] : Add_monoid.is_torsion G → ¬Add_monoid.is_torsion_free G
{α : Type u} {β : Type v} {γ : Type w} [TopologicalSpace α] [PseudoMetricSpace β] [PseudoMetricSpace γ] {G : β → γ} {C : Nnreal} (H : LipschitzWith C G) : UniformContinuous (BoundedContinuousFunction.comp G H)
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Q : QuadraticForm R M} (a b : M) : ⇑(CliffordAlgebraι Q) a * ⇑(CliffordAlgebraι Q) b + ⇑(CliffordAlgebraι Q) b * ⇑(CliffordAlgebraι Q) a = ⇑(Algebra_Map R (CliffordAlgebra Q)) (QuadraticForm.polar ⇑Q a b)
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] (f : M →* P) : Function.Injective ⇑(Con.ker_Lift f)
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] {S T : IntermediateField K L} (h : ∀ (x : L), x ∈ S ↔ x ∈ T) : S = T
{R : Type u} {L : Type v} {L' : Type w₂} [CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L'] (f : L →ₗ⁅R⁆ L') {I₁ I₂ : LieIdeal R L} : LieIdeal.map f ⁅I₁,I₂⁆ ≤ ⁅LieIdeal.map f I₁,LieIdeal.map f I₂⁆
{α : Type u} [TopologicalSpace α] {s : Set α} : is_IsClosed (Frontier s)
{G : Type u_1} [Group G] (H : Subgroup G) : H = ⊥ ∨ ∃ (x : G) (H : x ∈ H), x ≠ 1
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {f : E × F → G} (h : IsBoundedBilinearMap 𝕜 f) : Continuous f
{α : Type u} [PseudoMetricSpace α] {f : ℕ → α} {m n : ℕ} (hmn : m ≤ n) {d : ℕ → ℝ} (hD : ∀ {k : ℕ}, m ≤ k → k < n → HasDist.dist (f k) (f (k + 1)) ≤ d k) : HasDist.dist (f m) (f n) ≤ (Finset.ico m n).sum (λ (i : ℕ), d i)
{A : Type u_4} [CommRing A] [is_IsDomain A] {L : Type u_6} [Field L] [Algebra A L] (alg : Algebra.IsAlgebraic A L) (inj : ∀ (x : A), ⇑(Algebra_Map A L) x = 0 → x = 0) : IsFractionRing ↥(IsIntegralClosure A L) L
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] (q : FormalMultilinearSeries 𝕜 F G) (p : FormalMultilinearSeries 𝕜 E F) (N : ℕ) (z : E) : q.partial_Sum N ((Finset.ico 1 N).sum (λ (i : ℕ), ⇑(p i) (λ (j : Fin i), z))) = (formal_multilinear_series.comp_partial_Sum_Target 0 N N).sum (λ (i : Σ (n : ℕ), Composition n), ⇑(q.comp_along_Composition p i.snd) (λ (j : Fin i.fst), z))
{α : sort u_1} (P : Prop) [Decidable P] (a b : α) : dite P (λ (h : P), a) (λ (h : ¬P), b) = Ite P a b
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι} (h : TendstoUniformly F f p) (g : γ → α) : TendstoUniformly (λ (n : ι), F n ∘ g) (f ∘ g) p
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f : X ⟶ Y} {F F' : CategoryTheory.Limits.MonoFactorisation f} (hI : F.I = F'.I) (hm : F.m = Category_theory.eq_to_hom hI ≫ F'.m) : F = F'
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (s : Affine.Simplex ℝ P 0) (i : Fin 1) : s.circumcenter = s.points i
{M : Type u_1} [Nonempty M] [Semigroup M] [TopologicalSpace M] [CompactSpace M] [t2_Space M] (Continuous_Mul_Left : ∀ (r : M), Continuous (λ (_x : M), _x * r)) : ∃ (m : M), m * m = m
{R : Type u_1} (M : Type u_3) [Monoid R] [MulAction R M] (a : Rˣ) : IsSmulRegular M ↑a
{cb : CharBuffer} {n n' val : ℕ} (h : Parser.nat cb n = ParseResult.done n' val) (hn : n' < Buffer.size cb) : '0' ≤ Buffer.read cb ⟨n', hn⟩ → '9' < Buffer.read cb ⟨n', hn⟩
{α : Type u} {f g : α → α} (h : Function.Commute f g) : Set.BijOn f (Function.FixedPoints (f ∘ g)) (Function.FixedPoints (f ∘ g))
{F : Type u_3} [InnerProductSpace ℝ F] (K : Submodule ℝ F) {u v : F} (hv : v ∈ K) : (∥u - v∥ = ⨅ (w : ↥↑K), ∥u - ↑w∥) ↔ ∀ (w : F), w ∈ K → HasInner.inner (u - v) w = 0
{α : Type u} {β : Type v} [Preorder β] {f : α → β} {l : Filter α} {a : α} : IsMaxFilter (⇑order_dual.to_dual ∘ f) l a → IsMinFilter f l a
{m : Type u_1} {n : Type u_2} [Fintype m] [Fintype n] {R : Type v} [Field R] : FiniteDimensional.finrank R (Matrix m n R) = Fintype.card m * Fintype.card n
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x : E} (hF : HasStrictFderivAt f f' x) (K : Nnreal) (hK : ∥f'∥₊ < K) : ∃ (s : Set E) (H : s ∈ nhds x), LipschitzOnWith K f s
(n : ℕ+) : n.factor_multiset.prod = n
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasZeroMorphisms C] (X : C) : CategoryTheory.IsPullback 0 0 0 (𝟙 X)
{M : Type u_1} [Monoid M] (c : Con M) (n : ℕ) {w x : M} : ⇑c w x → ⇑c (w ^ n) (x ^ n)
{α : Type u_1} {M : Type u_5} [HasZero M] {b : M} (h : b ≠ 0) : Function.Injective (λ (a : α), Finsupp.single a b)
{C : Type u₁} [CategoryTheory.Category C] {X Y : C} {f : X ⟶ Y} [CategoryTheory.SplitMono f] [CategoryTheory.Mono (CategoryTheory.retraction f)] : CategoryTheory.IsIso f
{ι : Type u} {β : ι → Type v} [dec : DecidableEq ι] [Π (i : ι), HasZero (β i)] {i j : ι} {xi : β i} {xj : β j} (h : ⟨i, xi⟩ = ⟨j, xj⟩) : Dfinsupp.single i xi = Dfinsupp.single j xj
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] {M : Matrix n n R} {i j : n} (i_NE_j : i ≠ j) (hij : M i = M j) : M.det = 0
(r : Ennreal) : ∑' (n : ℕ), r ^ n = (1 - r)⁻¹
{p : ℕ} [Fact (Nat.Prime p)] : WittVector.IsPoly₂ p (λ (_x : Type u_1) (_x_1 : CommRing _x), has_mul.mul)
{R : Type u_2} {Γ₀ : Type u_3} [Ring R] [LinearOrderedCommMonoidWithZero Γ₀] {v₁ v₂ : Valuation R Γ₀} : v₁ = v₂ ↔ ∀ (r : R), ⇑v₁ r = ⇑v₂ r
(R : Type u) (L : Type v) [CommRing R] [LieRing L] [LieAlgebra R L] (H : LieSubalgebra R L) [LieAlgebra.IsNilpotent R ↥H] (h : lie_algebra.zero_root_Subalgebra R L H = H) : H.is_cartan_Subalgebra
{α : Type u_1} {𝒜 : Finset (Finset α)} {r : ℕ} : 𝒜.slice r ⊆ 𝒜
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} (hx : x ≠ 0) (θ : Real.Angle) : o.oangle (⇑(o.rotation θ) x) x = -θ
{G : Type u_3} [AddGroup G] : Add_group.fg G ↔ ∃ (S : Set G), AddSubgroup.closure S = ⊤ ∧ S.finite
(a b c : ℝ) (hb : 0 ≠ b) : Filter.Tendsto (λ (x : ℝ), x ^ (a / (b * x + c))) filter.at_Top (nhds 1)
{R : Type u_1} [OrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {x y : M} : SameRay R (-x) (-y) → SameRay R x y
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {c₁ c₂ p₁ p₂ : P} (hc₁ : HasDist.dist p₁ c₁ = HasDist.dist p₂ c₁) (hc₂ : HasDist.dist p₁ c₂ = HasDist.dist p₂ c₂) : HasInner.inner (c₂ -ᵥ c₁) (p₂ -ᵥ p₁) = 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {p : ι → P} (hi : AffineIndependent k p) {s : Finset ι} {sp : AffineSubspace k P} [FiniteDimensional k ↥(sp.direction)] (hle : affine_Span k ↑(Finset.image p s) ≤ sp) (hc : s.card = FiniteDimensional.finrank k ↥(sp.direction) + 1) : affine_Span k ↑(Finset.image p s) = sp
{α : Type u_1} {β : Type u_2} [AddCommGroup α] [UniformSpace α] [CompleteSpace α] {f : β → α} : Summable f ↔ CauchySeq (λ (s : Finset β), s.sum (λ (b : β), f b))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} {v : V} {s : Set ι} {p : ι → P} : (∃ (fs : Finset ι) (hfs : ↑fs ⊆ s) (w : ι → k) (hw : fs.sum (λ (i : ι), w i) = 0), v = ⇑(fs.weighted_vsub p) w) ↔ ∃ (fs : Finset ↥s) (w : ↥s → k) (hw : fs.sum (λ (i : ↥s), w i) = 0), v = ⇑(fs.weighted_vsub (λ (i : ↥s), p ↑i)) w
{α : Type u} {β : Type v} {s : Set β} (hs : s.subsingleton) {f : α → β} (hF : Function.Injective f) : (f ⁻¹' s).subsingleton
{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] : IsNoetherian R M ↔ ∀ (s : Submodule R M), s.fg
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] {s : Set α} (hs : IsConnected s) (hb : BddBelow s) (ha : BddAbove s) : Set.Ioo (HasInf.inf s) (HasSup.sup s) ⊆ s
{ι : Type u_1} {R : Type u_3} {A : Type u_5} {x : ι → A} [CommRing R] [CommRing A] [Algebra R A] {K : Type u_2} [CommRing K] [Algebra R K] [Algebra K A] [IsScalarTower R K A] (hinj : Function.Injective ⇑(Algebra_Map R K)) (ai : AlgebraicIndependent K x) : AlgebraicIndependent R x
{n : WithTop ℕ} {𝕂 : Type u_6} [is_R_or_C 𝕂] {E' : Type u_7} [NormedGroup E'] [NormedSpace 𝕂 E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {f : E' → F'} {x : E'} (hF : ContDiffAt 𝕂 n f x) (hn : 1 ≤ n) : HasStrictFderivAt f (fderiv 𝕂 f x) x
{a b c : Prop} : a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_5} [NormedGroup E'] [NormedSpace 𝕜 E'] {n : WithTop ℕ} {f : E → E'} {s : Set E} : ContMdiffOn (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f s → ContDiffOn 𝕜 n f s
{α : Type u_1} {β : Type u_2} {M : Type u_3} [Fintype α] [Fintype β] [CommMonoid M] (e : α ≃ β) (f : α → M) (g : β → M) (h : ∀ (x : α), f x = g (⇑e x)) : finset.univ.prod (λ (x : α), f x) = finset.univ.prod (λ (x : β), g x)
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
{α : Type uu} [DecidableEq α] {l₁ l₂ : List α} : l₁ <+~ l₂ ↔ ∀ (x : α), x ∈ l₁ → List.count x l₁ ≤ List.count x l₂
{ι : Type u_1} {M : Type u_4} [OrderedAddCommMonoid M] {s : Finset ι} {f : ι → WithTop M} : s.sum (λ (i : ι), f i) < ⊤ ↔ ∀ (i : ι), i ∈ s → f i < ⊤
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x₁ x₂ y z : V} (hx₁yne : x₁ ≠ y) (hx₁zne : x₁ ≠ z) (hx₂yne : x₂ ≠ y) (hx₂zne : x₂ ≠ z) {r : ℝ} (hx₁ : ∥x₁∥ = r) (hx₂ : ∥x₂∥ = r) (hy : ∥y∥ = r) (hz : ∥z∥ = r) : 2 • hb.oangle (y - x₁) (z - x₁) = 2 • hb.oangle (y - x₂) (z - x₂)
{A : Type u_1} (B : Type u_2) [Ring A] [Ring B] [is_IsDomain B] (e : A ≃+* B) : is_IsDomain A
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {s : Set E} {f : E → 𝕜} {g : E → F} (hF : ContDiffOn 𝕜 n f s) (hg : ContDiffOn 𝕜 n g s) : ContDiffOn 𝕜 n (λ (x : E), f x • g x) s
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (s : AffineSubspace k P) : s.direction = Vector_Span k ↑s
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] (f : ℂ → E) (f' : ℂ → (ℂ →L[ℝ] E)) (z w : ℂ) (Hc : ContinuousOn f (Set.Interval z.re w.re ×ℂ Set.Interval z.im w.im)) (hD : ∀ (x : ℂ), x ∈ Set.Ioo (Linear_order.min z.re w.re) (Linear_order.max z.re w.re) ×ℂ Set.Ioo (Linear_order.min z.im w.im) (Linear_order.max z.im w.im) → HasFderivAt f (f' x) x) (Hi : MeasureTheory.IntegrableOn (λ (z : ℂ), Complex.i • ⇑(f' z) 1 - ⇑(f' z) Complex.i) (Set.Interval z.re w.re ×ℂ Set.Interval z.im w.im) MeasureTheory.MeasureSpace.volume) : (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(z.im) * Complex.i)) - ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(w.im) * Complex.i)) + Complex.i • ∫ (y : ℝ) in z.im..w.im, f (↑(w.re) + ↑y * Complex.i)) - Complex.i • ∫ (y : ℝ) in z.im..w.im, f (↑(z.re) + ↑y * Complex.i) = ∫ (x : ℝ) in z.re..w.re, ∫ (y : ℝ) in z.im..w.im, Complex.i • ⇑(f' (↑x + ↑y * Complex.i)) 1 - ⇑(f' (↑x + ↑y * Complex.i)) Complex.i
{K : Type u_1} {v : K} {n : ℕ} [LinearOrderedField K] [FloorRing K] {a : K} (nth_Part_Num_Eq : (GeneralizedContinuedFraction.of v).partial_numerators.nth n = Option.some a) : a = 1
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] [Fintype α] [Fintype β] (f : α → β) {b : M} [LinearOrderedCommRing M] (hb : ↑(Fintype.card α) < Fintype.card β • b) : ∃ (y : β), ↑((Finset.filter (λ (x : α), f x = y) Finset.univ).card) < b
{α : Type u} [Preorder α] {a b : α} (h : a < b) : ¬b < a
{α : Type u_1} {E : α → Type u_2} {p : Ennreal} [Π (i : α), NormedGroup (E i)] [DecidableEq α] [Fact (1 ≤ p)] (hp : p ≠ ⊤) (f : ↥(Lp E p)) : HasSum (λ (i : α), lp.single p i (⇑f i)) f
{G : Type u} {y : G} [AddMonoid G] {x : G} (h : AddCommute x y) (hx : IsOfFinAddOrder x) (hy : IsOfFinAddOrder y) : IsOfFinAddOrder (x + y)
(θ : ℂ) (n : ℕ) : Polynomial.eval (Complex.cos θ) (Polynomial.Chebyshev.t ℂ n) = Complex.cos (↑n * θ)
{R : Type u_1} [LinearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_3} [DecidableEq ι] [Fintype ι] (e : Basis ι R M) (f : M ≃ₗ[R] M) : (e.map f).orientation = e.orientation ↔ 0 < ⇑LinearMap.det ↑f
{A : Type u_1} [CommRing A] [Algebra ℚ A] (t : A) : PowerSeries.mk (λ (n : ℕ), ⇑(Polynomial.aeval t) ((1 / ↑(n.factorial)) • Polynomial.bernoulli n)) * (PowerSeries.exp A - 1) = PowerSeries.x * ⇑(PowerSeries.rescale t) (PowerSeries.exp A)
{p : ℕ+} {k : ℕ} [hp : Fact (Nat.Prime ↑p)] : is_IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ)
{α : Type u_1} [DecidableEq α] (a : α) : Derangements.Equiv.RemoveNone.Fiber (Option.some a) = {f : Equiv.perm α | Function.FixedPoints ⇑f ⊆ {a}}
{M : Type u_1} [has_Add M] {S T : AddSubsemigroup M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T
{M : Type u} [Monoid M] {x y : M} (hxy : x ∣ y) {n : ℕ} (hn : n ≠ 0) : x ∣ y ^ n
{α : Type u_1} {β : Type u_2} [PseudoMetricSpace α] [PseudoMetricSpace β] {K : Nnreal} {f : α → β} : AntilipschitzWith K f → ∀ (x y : α), HasDist.dist x y ≤ ↑K * HasDist.dist (f x) (f y)
{α : Type u} {ι : Type v} [MetricSpace α] [ProperSpace α] {c : ι → α} {r : ι → ℝ} (hr : ∀ (i : ι), 0 < r i) (uf : ∀ (x : α), {i : ι | x ∈ Metric.Ball (c i) (r i)}.finite) (uU : (⋃ (i : ι), Metric.Ball (c i) (r i)) = Set.Univ) : ∃ (r' : ι → ℝ), (⋃ (i : ι), Metric.Ball (c i) (r' i)) = Set.Univ ∧ ∀ (i : ι), r' i ∈ Set.Ioo 0 (r i)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} {x : E} {f' : TangentSpace (model_with_corners_self 𝕜 E) x →L[𝕜] TangentSpace (model_with_corners_self 𝕜 E') (f x)} : HasMfderivAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f x f' → HasFderivAt f f' x
{G : Type u_1} [AddGroup G] (tG : Add_monoid.is_torsion_free G) (H : AddSubgroup G) : Add_monoid.is_torsion_free ↥H
{α : Type u} [PseudoMetricSpace α] {s : Set α} {x y : α} : metric.inf_dist x s ≤ metric.inf_dist y s + HasDist.dist x y
{M : Type u_1} [AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M →+ P} {T : AddSubmonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [AddCommMonoid Q] {k : T.localization_Map Q} {A : Type u_5} [AddCommMonoid A] {U : AddSubmonoid A} {R : Type u_6} [AddCommMonoid R] (j : U.localization_Map R) {l : P →+ A} (hl : ∀ (w : ↥T), ⇑l ↑w ∈ U) : (k.map hl j).comp (f.map hy k) = f.map _ j
{α : Type u_1} [Preorder α] [BoundedOrder α] [IsSimpleOrder α] {a b : α} (h : a < b) : b = ⊤
{k : Type u_1} {E : Type u_2} [LinearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k → E} {a b r : k} (hab : a < b) (h₀ : 0 < r) (h₁ : r < 1) : f (⇑(affine_map.line_Map a b) r) < ⇑(affine_map.line_Map (f a) (f b)) r ↔ slope f a (⇑(affine_map.line_Map a b) r) < slope f (⇑(affine_map.line_Map a b) r) b
{A : Type u_1} {R : Type u_2} (K : Type u_3) [CommRing A] [is_IsDomain A] [NormalizedGcdMonoid A] [Field K] [CommRing R] [is_IsDomain R] [Algebra A K] [IsFractionRing A K] [Algebra K R] [Algebra A R] [IsScalarTower A K R] {x : R} (hx : IsIntegral A x) : minpoly K x = Polynomial.map (Algebra_Map A K) (minpoly A x)
{R : Type u_1} {M : Type u_3} {a b : R} [Monoid R] [MulAction R M] (h : a * b = 1) : IsSmulRegular M b
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {f : E → G} {x : E} {y : F} (hF : ContDiffAt 𝕜 n f x) : ContDiffAt 𝕜 n (λ (x : E × F), f x.fst) (x, y)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {f g : E → F} (hF : ContDiff 𝕜 n f) (hg : ContDiff 𝕜 n g) : ContDiff 𝕜 n (λ (x : E), f x - g x)
{α : Type u} [PseudoMetricSpace α] {s : Set α} {C : ℝ} (h₀ : 0 ≤ C) (h : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → HasDist.dist x y ≤ C) : Metric.diam s ≤ C
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {x : E} {n : WithTop ℕ} {f : E → F} {g : E → G} (hF : ContDiffAt 𝕜 n f x) (hg : ContDiffAt 𝕜 n g x) : ContDiffAt 𝕜 n (λ (x : E), (f x, g x)) x
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] : IsNoetherian K V ↔ Module.Finite K V
(R : Type u) [Ring R] [StrongRankCondition R] (m n : Type u) [Fintype m] [Fintype n] : Module.rank R (Matrix m n R) = Cardinal.mk m * Cardinal.mk n
{α : Type u} [PartialOrder α] {a b : α} : a ≤ b → a ≠ b → a < b
{M₀ : Type u_1} [MulZeroClass M₀] [NoZeroDivisors M₀] {a b : M₀} : a * b ≠ 0 ↔ b * a ≠ 0
{α : Type u_1} [PartialOrder α] [SuccOrder α] [IsSuccArchimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ Set.Ico n m → r i (Order.succ i)) (hnm : n < m) : Relation.TransGen r n m
{A : Type u_1} {K : Type u_2} [CommRing A] [is_IsDomain A] [UniqueFactorizationMonoid A] [Field K] [Algebra A K] [IsFractionRing A K] {p : Polynomial A} (hp : p.monic) {r : K} (hr : ⇑(Polynomial.aeval r) p = 0) : IsLocalization.IsInteger A r
(𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {v : E} (w : E) : ↑(⇑(Orthogonal_projection (Submodule.span 𝕜 {v})) w) = (HasInner.inner v w / ↑∥v∥ ^ 2) • v
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] [DenselyOrdered β] {f : α → β} (h_Mono : Monotone f) (h_surj : Function.Surjective f) : Continuous f
{α : Type u} {s : Set α} : s.finite ∨ s.infinite
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace 𝕜] (s : Submodule 𝕜 E) [FiniteDimensional 𝕜 ↥s] : IsComplete ↑s
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [Nontrivial E] {x : E} {r : ℝ} : (Metric.Sphere x r).nonempty ↔ 0 ≤ r
{ι : Type u_1} {N : Type u_5} [OrderedAddCommMonoid N] {f g : ι → N} {s : Finset ι} (h : ∀ (i : ι), i ∈ s → f i ≤ g i) : s.sum (λ (i : ι), f i) ≤ s.sum (λ (i : ι), g i)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) (l₁ l₂ : ι → 𝕜) (s : Finset ι) : HasInner.inner (s.sum (λ (i : ι), l₁ i • v i)) (s.sum (λ (i : ι), l₂ i • v i)) = s.sum (λ (i : ι), ⇑(StarRing_end 𝕜) (l₁ i) * l₂ i)
{G : Type u_1} [AddGroup G] (g1 g2 : G) : g1 -ᵥ g2 = g1 - g2
{P : Type u_2} [MetricSpace P] (ps : Set P) : EuclideanGeometry.Cospherical ps ↔ ∃ (Center : P) (radius : ℝ), ∀ (p : P), p ∈ ps → HasDist.dist p Center = radius
{α : Type u_1} [TopologicalSpace α] {s : Set α} {γ : Type u_4} [LinearOrderedAddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] [HasContinuousAdd γ] {f g : α → γ} (hF : LowerSemicontinuousOn f s) (hg : LowerSemicontinuousOn g s) : LowerSemicontinuousOn (λ (z : α), f z + g z) s
(A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {p : Polynomial A} (pnz : p ≠ 0) (hp : ⇑(Polynomial.aeval x) p = 0) : (minpoly A x).degree ≤ p.degree
{α : Type u} {β : Type v} [PseudoEmetricSpace α] [PseudoEmetricSpace β] {f : α → β} (hF : Isometry f) : Continuous f
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] [FiniteDimensional k V] {s : Set P} (hi : AffineIndependent k Coe) : s.finite
{ι : Type u_1} {E : Type u_3} [SemiNormedGroup E] [CompleteSpace E] {f : ι → E} (g : ι → ℝ) (hg : Summable g) (h : ∀ᶠ (i : ι) in Filter.cofinite, ∥f i∥ ≤ g i) : Summable f
{α : Type u} [AddCommGroup α] [HasLe α] [CovariantClass α α has_add.add has_le.le] {a b c : α} : a - b ≤ c → a ≤ b + c
{α : Type u} [PseudoMetricSpace α] {s : Set α} : metric.Hausdorff_dist s s = 0
{K : Type u} [Field K] {s : Set K} : s ⊆ ↑(Subfield.closure s)
{ι : Type u_1} {R : Type u_4} [DecidableEq ι] [AddMonoid ι] [Semiring R] (A : ι → AddSubmonoid R) [SetLike.GradedMonoid A] (i : ι) (x : ↥(A i)) : ⇑(direct_sum.coe_RingHom A) (⇑(DirectSum.of (λ (i : ι), ↥(A i)) i) x) = ↑x
{α β : Type u} (r : α → α → Prop) [wo : IsWellOrder α r] (s : β → Set α) (h₁ : Set.Unbounded r (⋃ (x : β), s x)) (h₂ : Cardinal.mk β < StrictOrder.cof r) : ∃ (x : β), Set.Unbounded r (s x)
{J : Type u₁} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {F G : J ⥤ C} [CategoryTheory.Limits.HasLimit F] (α : F ≅ G) : CategoryTheory.Limits.HasLimit G
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (s : AffineSubspace ℝ P) [Nonempty ↥s] [CompleteSpace ↥(s.direction)] (p : P) : ⇑(EuclideanGeometry.reflection s) p = ↑(⇑(euclidean_geometry.orthogonal_projection s) p) -ᵥ p +ᵥ ↑(⇑(euclidean_geometry.orthogonal_projection s) p)
{n : ℕ} (p : Fin (n + 1)) (i : Fin n) (h : ⇑fin.cast_Succ i < p) : ⇑(p.succ_above) i = ⇑fin.cast_Succ i
{G : Type u_1} [AddGroup G] (H N : AddSubgroup G) [N.normal] : ↑(H ⊔ N) = ↑H + ↑N
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} {t : Set (Set α)} (h : t.pairwise_Disjoint Id) (ht₀ : t.finite) (ht₁ : ∀ (x : Set α), x ∈ t → x.finite) : finsum (λ (a : α), finsum (λ (H : a ∈ ⋃₀t), f a)) = finsum (λ (s : Set α), finsum (λ (H : s ∈ t), finsum (λ (a : α), finsum (λ (H : a ∈ s), f a))))
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ θ₂ : Real.Angle) : (o.rotation θ₁).trans (o.rotation θ₂) = o.rotation (θ₂ + θ₁)
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [SemiNormedGroup F'] {f : α → E} {g' : α → F'} {l : Filter α} : f =O[l] g' ↔ ∀ᶠ (c : ℝ) in filter.at_Top, asymptotics.is_O_with c l f g'
{α : Type u_1} [LinearOrder α] {s : Set α} : ¬BddAbove s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), x < y
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] {A B : Matrix n n α} (h : A.mul B = 1) : A⁻¹ = B
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.ConcreteCategory.forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.ConcreteCategory.forget C)] {X : Top} (F : Top.Sheaf C X) {ι : Type v} (U : ι → TopologicalSpace.Opens ↥X) (V : TopologicalSpace.Opens ↥X) (iUV : Π (i : ι), U i ⟶ V) (hcover : V ≤ supr U) (sf : Π (i : ι), ↥(F.val.obj (Opposite.op (U i)))) (h : F.val.is_compatible U sf) : ∃! (s : ↥(F.val.obj (Opposite.op V))), ∀ (i : ι), ⇑(F.val.map (iUV i).op) s = sf i
(n k : ℕ) : n.factorial * n.asc_factorial k = (n + k).factorial
{α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β] (e : α ≃ᵐ β) : MeasurableEmbedding ⇑e
{F : Type u_3} [InnerProductSpace ℝ F] (x : F) (r : ℝ) : HasInner.inner x (r • x) = r * (∥x∥ * ∥x∥)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) : hb.oangle (⇑(hb.rotation θ) x) y = hb.oangle x y - θ
 : CategoryTheory.EssSurj Compactum_to_CompHaus
{D : Set ℝ} (hD : Convex ℝ D) (hD₂ : is_IsOpen D) {f : ℝ → ℝ} (hF' : DifferentiableOn ℝ f D) (hF'' : DifferentiableOn ℝ (deriv f) D) (hF''_nonpos : ∀ (x : ℝ), x ∈ D → deriv^[2] f x ≤ 0) : ConcaveOn ℝ D f
{k : Type u_1} {K : Type u_2} [Field k] [IsAlgClosed k] [Field K] {f : k →+* K} (p : Polynomial k) : Polynomial.Splits f p
{k : Type u_1} {V : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] [FiniteDimensional k V] [Fintype ι] {p : ι → P} (hi : AffineIndependent k p) (hc : Fintype.card ι = FiniteDimensional.finrank k V + 1) : Vector_Span k (Set.Range p) = ⊤
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P : C} (Q : C) (a : ↥P) : ⇑0 a = 0
{E : Type u_1} {F : Type u_2} {𝕜 : Type u_3} {𝕜₂ : Type u_4} [SemiNormedGroup E] [SemiNormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [RingHomIsometric σ₁₂] {ι : Type u_5} [CompleteSpace E] {g : ι → (E →sl[σ₁₂] F)} (h : ∀ (x : E), (⨆ (i : ι), ↑∥⇑(g i) x∥₊) < ⊤) : (⨆ (i : ι), ↑∥g i∥₊) < ⊤
{G : Type u_1} [AddGroup G] {x y : G} : y ∈ AddSubgroup.closure {x} ↔ ∃ (n : ℤ), n • x = y
{G : Type u_1} [AddGroup G] (H : AddSubgroup G) {x y : G} : x ∈ H → y ∈ H → x + y ∈ H
{M : Type u_1} [MulOneClass M] {c : Con M} : ↑1 = 1
{R : Type u_1} [MulZeroClass R] (h : IsRegular 0) : Subsingleton R
{C : Type u} [CategoryTheory.Category C] {J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ C) [CategoryTheory.Limits.HasLimit (CategoryTheory.Discrete.functor F.obj)] [CategoryTheory.Limits.HasLimit (CategoryTheory.Discrete.functor (λ (f : Σ (p : J × J), p.fst ⟶ p.snd), F.obj f.fst.snd))] [CategoryTheory.Limits.HasEqualizers C] : CategoryTheory.Limits.HasLimit F
{η : Type u_2} [Fintype η] {Gs : η → Type u_3} [Π (i : η), Group (Gs i)] [∀ (i : η), group.is_nilpotent (Gs i)] : group.nilpotency_class (Π (i : η), Gs i) = finset.univ.sup (λ (i : η), group.nilpotency_class (Gs i))
{α : Type u} [Group α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a
{p : ℕ} (hp : Nat.Prime p) (n : ℕ) : (p ^ (n + 1)).totient = p ^ n * (p - 1)
{α : Type u} [PseudoEmetricSpace α] {f : ℕ → α} {m n : ℕ} (hmn : m ≤ n) {d : ℕ → Ennreal} (hD : ∀ {k : ℕ}, m ≤ k → k < n → HasEdist.edist (f k) (f (k + 1)) ≤ d k) : HasEdist.edist (f m) (f n) ≤ (Finset.ico m n).sum (λ (i : ℕ), d i)
{R : Type u_4} {S : Type u_5} [NonAssocSemiring R] [NonAssocSemiring S] (f : R ≃+* S) : ⇑f 1 = 1
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {ps : Set P} {n : ℕ} [FiniteDimensional ℝ V] (hD : FiniteDimensional.finrank ℝ V = n) (hc : EuclideanGeometry.Cospherical ps) {sx₁ sx₂ : Affine.Simplex ℝ P n} (hsx₁ : Set.Range sx₁.points ⊆ ps) (hsx₂ : Set.Range sx₂.points ⊆ ps) : sx₁.circumradius = sx₂.circumradius
 : List.Nat.antidiagonal 0 = [(0, 0)]
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D ⥤ C} [CategoryTheory.Reflective i] (X : C) : (Category_theory.adjunction.of_Right_Adjoint i).unit.app (i.obj ((CategoryTheory.IsLeftAdjoint i).obj X)) = i.map ((CategoryTheory.IsLeftAdjoint i).map ((Category_theory.adjunction.of_Right_Adjoint i).unit.app X))
 : Multiset.Nat.antidiagonal 0 = {(0, 0)}
{α : Type u} [TopologicalSpace α] [t2_Space α] {K U V : Set α} (hK : is_IsCompact K) (hU : is_IsOpen U) (hV : is_IsOpen V) (h2K : K ⊆ U ∪ V) : ∃ (K₁ K₂ : Set α), is_IsCompact K₁ ∧ is_IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra A B] [Algebra R B] [Algebra R A] [IsScalarTower R A B] (A_Int : Algebra.IsIntegral R A) (x : B) (hx : IsIntegral A x) : IsIntegral R x
{x y : Pgame} (ox : x.numeric) (oy : y.numeric) : x < y ↔ (∃ (i : y.left_moves), (∀ (i' : x.left_moves), x.move_Left i' < y.move_Left i) ∧ ∀ (j : (y.move_Left i).right_moves), x < (y.move_Left i).move_Right j) ∨ ∃ (j : x.right_moves), (∀ (i : (x.move_Right j).left_moves), (x.move_Right j).move_Left i < y) ∧ ∀ (j' : y.right_moves), x.move_Right j < y.move_Right j'
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCancelCommMonoid E] [OrderedAddCommMonoid β] [Module 𝕜 E] [HasScalar 𝕜 β] {s : Set E} {f : E → β} (hF : StrictConcaveOn 𝕜 s f) (c : E) : StrictConcaveOn 𝕜 ((λ (z : E), c + z) ⁻¹' s) (f ∘ λ (z : E), c + z)
{α : Type u_1} {β : Type u_2} [UniformSpace α] [Group α] [UniformGroup α] {hom : Type u_3} [UniformSpace β] [DiscreteTopology β] [Group β] [UniformGroup β] [MonoidHomClass hom α β] {f : hom} : UniformContinuous ⇑f ↔ is_IsOpen ↑(↑f.ker)
{α : sort u_1} {s₁ : Setoid α} {p : Quotient s₁ → Prop} (h : ∀ (a : α), p (Quotient.mk' a)) (q : Quotient s₁) : p q
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] [Nontrivial E] {f : E → F} {U : Set E} (hU : Metric.Bounded U) (hD : DiffContOnCl ℂ f U) {C : ℝ} (hC : ∀ (z : E), z ∈ Frontier U → ∥f z∥ ≤ C) {z : E} (hz : z ∈ Closure U) : ∥f z∥ ≤ C
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) [CategoryTheory.IsEquivalence F] : CategoryTheory.EssSurj F
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] (v : E) : v - ↑(⇑(Orthogonal_projection K) v) ∈ Kᗮ
{α : Type u_1} {ι' : sort u_5} {f : Filter α} [h : f.is_countably_generated] {p : ι' → Prop} {s : ι' → Set α} (hs : f.has_Basis p s) : ∃ (x : ℕ → ι'), (∀ (i : ℕ), p (x i)) ∧ f.has_Antitone_Basis (λ (i : ℕ), s (x i))
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommMonoid β] [Module 𝕜 E] [HasScalar 𝕜 β] {s : Set E} {f : E → β} (hF : ConvexOn 𝕜 s f) (c : E) : ConvexOn 𝕜 ((λ (z : E), c + z) ⁻¹' s) (f ∘ λ (z : E), z + c)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {s : Set E} {x : E} : UniqueDiffWithinAt 𝕜 s x → UniqueMdiffWithinAt (model_with_corners_self 𝕜 E) s x
{C : Type u} [CategoryTheory.Category C] {X Y : C} (J : CategoryTheory.GrothendieckTopology C) (f : Y ⟶ X) (S R : CategoryTheory.Sieve X) (h : J.covers S f) : (∀ {Z : C} (g : Z ⟶ X), ⇑S g → J.covers R g) → J.covers R f
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type w} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace 𝕜] {X : Type u_1} [TopologicalSpace X] [FiniteDimensional 𝕜 E] {f : X → (E →L[𝕜] F)} {s : Set X} : ContinuousOn f s ↔ ∀ (y : E), ContinuousOn (λ (x : X), ⇑(f x) y) s
{α : Type u} [PseudoMetricSpace α] {x : α} {r : ℝ} : Metric.Bounded (Metric.ClosedBall x r)
{a : ℕ} (a1 : 1 < a) {x y : ℕ} (hp : x * x - d a1 * y * y = 1) : ∃ (n : ℕ), x = Pell.xn a1 n ∧ y = Pell.yn a1 n
{α : Type u_1} {r : α → α → Prop} (hr : WellFounded r) : WellFounded (Relation.CutExpand r)
{V₁ : Type u_2} {V₂ : Type u_3} [SemiNormedGroup V₁] [SemiNormedGroup V₂] : ∥0∥ = 0
{α : Type u} {β : Type v} [Group α] [Group β] {f : α → β} (hF : IsGroupHom f) : Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1
{m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (A : Matrix m m R) (B : Matrix m n R) (D : Matrix n n R) : (matrix.from_blocks A B 0 D).det = A.det * D.det
{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), Group (Gs i)] (H K : Π (i : η), Subgroup (Gs i)) : ⁅Subgroup.pi Set.Univ H,Subgroup.pi Set.Univ K⁆ ≤ Subgroup.pi Set.Univ (λ (i : η), ⁅H i,K i⁆)
{α : Type u_1} {r : Setoid α} (a : α) : ∃! (b : Set α) (H : b ∈ r.classes), a ∈ b
{R : Type u} [CommRing R] [is_IsDomain R] (a : R) (n : ℕ) : polynomial.root_multiplicity a ((Polynomial.x - ⇑Polynomial.c a) ^ n) = n
{𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] {f : ?? → G} (hF : Differentiable 𝕜 f) (hF' : ∀ (x : 𝕜), deriv f x = 0) (x y : 𝕜) : f x = f y
{α : Type u} [PseudoMetricSpace α] {s : Set α} : metric.Hausdorff_dist s ∅ = 0
{α : Type u_1} {β : Type u_2} [CompleteLattice α] {f : Filter β} {u : β → α} : f.limsup u = ⨅ (s : Set β) (H : s ∈ f), ⨆ (a : β) (H : a ∈ s), u a
{cb : CharBuffer} {n n' val : ℕ} (h : Parser.nat cb n = ParseResult.done n' val) : val = nat.of_digits 10 (List.map (λ (c : Char), c.to_Nat - '0'.to_Nat) (List.take (n' - n) (List.drop n (buffer.to_List cb))).reverse)
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {s : Set 𝕜} {f' : 𝕜 →L[𝕜] F} : HasFderivWithinAt f f' s x ↔ HasDerivWithinAt f (⇑f' 1) s x
{α : Type u} [TopologicalSpace α] {s : Set α} {ι : Type v} (hs : is_IsCompact s) (Z : ι → Set α) (hZc : ∀ (i : ι), is_IsClosed (Z i)) (hsZ : ∀ (t : Finset ι), (s ∩ ⋂ (i : ι) (H : i ∈ t), Z i).nonempty) : (s ∩ ⋂ (i : ι), Z i).nonempty
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) (v : E) : v ∈ Kᗮ ↔ ∀ (u : E), u ∈ K → HasInner.inner v u = 0
{R : Type u_1} [CommRing R] [Ideal.IsJacobson R] (P : Ideal (Polynomial R)) [hP : P.is_Maximal] : ((Ideal.Quotient.mk P).comp Polynomial.c).is_integral
{a b : ℝ} {g' g : ℝ → ℝ} (hab : a ≤ b) (hcont : ContinuousOn g (Set.Icc a b)) (hderiv : ∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivWithinAt g (g' x) (Set.Ioi x) x) (g'Pos : ∀ (x : ℝ), x ∈ Set.Ioo a b → 0 ≤ g' x) : MeasureTheory.IntegrableOn g' (Set.Ioc a b) MeasureTheory.MeasureSpace.volume
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} {V3 : Type u_6} {P3 : Type u_7} [Ring k] [AddCommGroup V1] [Module k V1] [AddTorsor V1 P1] [AddCommGroup V2] [Module k V2] [AddTorsor V2 P2] [AddCommGroup V3] [Module k V3] [AddTorsor V3 P3] (f : P2 →ᵃ[k] P3) (g : P1 →ᵃ[k] P2) : ⇑(f.comp g) = ⇑f ∘ ⇑g
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {s t : Set E} (hs₁ : Convex ℝ s) (hs₂ : is_IsClosed s) (ht₁ : Convex ℝ t) (ht₂ : is_IsCompact t) (disj : Disjoint s t) : ∃ (f : E →L[ℝ] ℝ) (u v : ℝ), (∀ (a : E), a ∈ s → ⇑f a < u) ∧ u < v ∧ ∀ (b : E), b ∈ t → v < ⇑f b
{α : Type u_3} {β : Type u_4} [Preorder β] {f : β → Finset α} (h : Monotone f) (h' : ∀ (x : α), ∃ (n : β), x ∈ f n) : Filter.Tendsto f filter.at_Top filter.at_Top
{α : Type u_1} [LinearOrderedField α] {a b : α} (ha : 0 < a) (hb : 0 < b) : 1 / a ≤ 1 / b ↔ b ≤ a
{α : Type u_1} (L : List (List α)) (i : ℕ) : List.drop (List.take i (List.map List.length L)).sum L.join = (List.drop i L).join
{R : Type u} [NonAssocSemiring R] {s : Set R} {p : R → R → Prop} {x y : R} (hx : x ∈ Subsemiring.closure s) (hy : y ∈ Subsemiring.closure s) (Hs : ∀ (x : R), x ∈ s → ∀ (y : R), y ∈ s → p x y) (H0_Left : ∀ (x : R), p 0 x) (H0_Right : ∀ (x : R), p x 0) (H1_Left : ∀ (x : R), p 1 x) (H1_Right : ∀ (x : R), p x 1) (hAdd_Left : ∀ (x₁ x₂ y : R), p x₁ y → p x₂ y → p (x₁ + x₂) y) (hAdd_Right : ∀ (x y₁ y₂ : R), p x y₁ → p x y₂ → p x (y₁ + y₂)) (hMul_Left : ∀ (x₁ x₂ y : R), p x₁ y → p x₂ y → p (x₁ * x₂) y) (hMul_Right : ∀ (x y₁ y₂ : R), p x y₁ → p x y₂ → p x (y₁ * y₂)) : p x y
{α : Type u} (s : Set α) : is_IsClosed {u : Ultrafilter α | s ∈ u}
{α : Type u} [TopologicalSpace α] [SigmaCompactSpace α] {ι : Type u_1} {f : ι → Set α} (hF : LocallyFinite f) (hne : ∀ (i : ι), (f i).nonempty) : set.univ.countable
{F : Type u_3} [Field F] [Fintype F] (hF : Ring_Char F = 2) (a : F) : IsSquare a
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} {p1 : P} {p : ι → P} (h : p1 ∈ affine_Span k (Set.Range p)) : ∃ (s : Finset ι) (w : ι → k) (hw : s.sum (λ (i : ι), w i) = 1), p1 = ⇑(s.affine_combination p) w
{n : Type u_3} [Fintype n] {A : Type u_1} [DecidableEq n] [CommRing A] [is_IsDomain A] {M : Matrix n n A} : M.nondegenerate → M.det ≠ 0
 : ⇑MeasureTheory.MeasureSpace.volume {x : ℝ | Liouville x} = 0
(k : Type u₁) {G : Type u₂} [Semiring k] [HasMul G] {A : Type u₃} [NonUnitalNonAssocSemiring A] [DistribMulAction k A] {φ₁ φ₂ : MonoidAlgebra k G →ₙₐ[k] A} (h : ∀ (x : G), ⇑φ₁ (Finsupp.single x 1) = ⇑φ₂ (Finsupp.single x 1)) : φ₁ = φ₂
{M : Type u_1} [MulOneClass M] {s : Set M} {p : M → Prop} {x : M} (h : x ∈ Submonoid.closure s) (Hs : ∀ (x : M), x ∈ s → p x) (H1 : p 1) (hMul : ∀ (x y : M), p x → p y → p (x * y)) : p x
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (hM : M (Sum.inr ()) (Sum.inr ()) ≠ 0) : ∃ (L L' : List (Matrix.TransvectionStruct (Fin r ⊕ Unit) 𝕜)), (((List.map matrix.transvection_struct.to_Matrix L).prod.mul M).mul (List.map matrix.transvection_struct.to_Matrix L').prod).is_two_block_Diagonal
{M : Type u_1} [Monoid M] {s t : Set M} (ht : IsSubmonoid t) (h : s ⊆ t) : monoid.closure s ⊆ t
(a : ℤ) : ↑(a.nat_Abs) ≤ a ^ 2
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {s : Set (E × F)} : ContDiffOn 𝕜 n Prod.fst s
{α : Type u_1} [LinearOrder α] [SuccOrder α] [IsSuccArchimedean α] (r : α → α → Prop) {n m : α} (h1 : ∀ (i : α), i ∈ Set.Ico n m → r i (Order.succ i)) (h2 : ∀ (i : α), i ∈ Set.Ico m n → r (Order.succ i) i) : Relation.ReflTransGen r n m
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NormedCommRing 𝕜] [AddCommMonoid E] [AddCommMonoid F] [Module 𝕜 E] [Module 𝕜 F] (B : E →ₗ[𝕜] F →ₗ[𝕜] 𝕜) : GaloisConnection (⇑order_dual.to_dual ∘ B.polar) (B.flip.polar ∘ ⇑order_dual.of_dual)
{α : Type u_2} [Bornology α] {s : Set α} : Bornology.IsBounded sᶜ → Bornology.IsCobounded s
{n : Type u_3} {α : Type v} [Fintype n] [NonUnitalSemiring α] [StarRing α] (M N : Matrix n n α) : HasStar.star (M.mul N) = (HasStar.star N).mul (HasStar.star M)
(C : Type u) [CategoryTheory.Category C] [∀ {J : Type v} {X Y : C} {f : J → (X ⟶ Y)}, CategoryTheory.Limits.HasLimit (Category_theory.limits.parallel_family f)] : CategoryTheory.Limits.HasWideEqualizers C
{α : Type u} {β : Type v} [Ring α] [Ring β] [is_IsDomain β] (e : α ≃+* β) : is_IsDomain α
{m : ℤ} (hm₀ : m ≠ 0) (hm₁ : m ≠ 1) : StrictConvexOn ℝ (Set.Ioi 0) (λ (x : ℝ), x ^ m)
{l : Filter ℝ} {f g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in filter.at_Top, DifferentiableAt ℝ f x) (hg' : ∀ᶠ (x : ℝ) in filter.at_Top, deriv g x ≠ 0) (hftop : Filter.Tendsto f filter.at_Top (nhds 0)) (hgtop : Filter.Tendsto g filter.at_Top (nhds 0)) (hDiv : Filter.Tendsto (λ (x : ℝ), deriv f x / deriv g x) filter.at_Top l) : Filter.Tendsto (λ (x : ℝ), f x / g x) filter.at_Top l
(M : Type u_1) (α : Type u_2) [Monoid M] [MulAction M α] {s t : Set α} : fixing_Submonoid M (s ∪ t) = fixing_Submonoid M s ⊓ fixing_Submonoid M t
{R : Type u_1} {M : Type u_2} [LinearOrderedSemiring R] [OrderedAddCommMonoid M] [MulActionWithZero R M] (hR : ∀ {c : R}, c ≠ 0 → IsUnit c) (hlt : ∀ ⦃a b : M⦄ ⦃c : R⦄, a < b → 0 < c → c • a ≤ c • b) : OrderedSmul R M
{α : Type u} [HasSsubset α] [IsIrrefl α HasSsubset.Ssubset] {a : α} : ¬a ⊂ a
{X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X] {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] {γ : Type w} [MetricSpace γ] {Φ : X → γ} {Ψ : Y → γ} (ha : Isometry Φ) (hb : Isometry Ψ) : Gromov_Hausdorff.GH_dist X Y ≤ metric.Hausdorff_dist (Set.Range Φ) (Set.Range Ψ)
{α : Type u} [PseudoMetricSpace α] {x : α} {u : Set α} (hu : u ∈ nhds x) : ∀ᶠ (r : ℝ) in nhds 0, Metric.ClosedBall x r ⊆ u
{M : Type u_3} [Monoid M] [Preorder M] (L : List M) (h : 1 < L.prod) : 0 < L.length
{G : Type u_7} [Group G] (L : List G) (i : ℕ) (p : i < L.length) : (List.drop (i + 1) L).prod = (L.nth_LE i p)⁻¹ * (List.drop i L).prod
{α : Type u_1} {β : Type u_2} {f : α → β} {mα : MeasurableSpace α} [MeasurableSpace β] [TopologicalSpace β] [TopologicalSpace.MetrizableSpace β] [BorelSpace β] [TopologicalSpace.SecondCountableTopology β] : MeasureTheory.StronglyMeasurable f ↔ Measurable f
{k : Type u_1} {E : Type u_2} [LinearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k → E} {a b r : k} (h : 0 < r * (b - a)) : ⇑(affine_map.line_Map (f a) (f b)) r ≤ f (⇑(affine_map.line_Map a b) r) ↔ slope f a b ≤ slope f a (⇑(affine_map.line_Map a b) r)
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} {s : Set E} {x : E} : DifferentiableWithinAt 𝕜 f s x → MdifferentiableWithinAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V} (θ : Real.Angle) : o.oangle x y = θ ↔ (x ≠ 0 ∧ y ≠ 0 ∧ ∃ (r : ℝ), 0 < r ∧ y = r • ⇑(o.rotation θ) x) ∨ θ = 0 ∧ (x = 0 ∨ y = 0)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} (g : F →L[𝕜] G) (h : HasFpowerSeriesOnBall f p x r) : HasFpowerSeriesOnBall (⇑g ∘ f) (g.comp_FormalMultilinearSeries p) x r
{α : Type u} [TopologicalSpace α] {f : Filter α} {a : α} {s : Set α} (h : a ∈ s) (o : is_IsOpen s) (sf : Filter.principal s ≤ f) : nhds a ≤ f
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] {f : E → F} {f' : E →L[𝕜] F} {a : E} (hF : HasStrictFderivAt f f' a) (hF' : f'.range = ⊤) (hker : f'.ker.closed_complemented) : ∀ᶠ (x : E) in nhds a, has_strict_fderiv_at.implicit_Function_of_complemented f f' hF hF' hker (f x) (⇑(has_strict_fderiv_at.implicit_to_LocalHomeomorph_of_complemented f f' hF hF' hker) x).snd = x
{n : ℕ} {E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f : (Fin (n + 1) → ℂ) → E} {c : Fin (n + 1) → ℂ} {R : Fin (n + 1) → ℝ} (hF : TorusIntegrable f c R) : ∯ (x : Fin (n + 1) → ℂ) in T(c, R), f x = ∮ (x : ℂ) in C(c 0, R 0), ∯ (y : Fin n → ℂ) in T(c ∘ Fin.succ, R ∘ Fin.succ), f (fin.cons x y)
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hD : DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hre : ∀ (x : ℝ), x ≤ 0 → ∥f ↑x∥ ≤ C) (him : ∀ (x : ℝ), x ≤ 0 → ∥f (↑x * Complex.i)∥ ≤ C) (hz_re : z.re ≤ 0) (hz_im : z.im ≤ 0) : ∥f z∥ ≤ C
{α : Type u_1} {l₁ l₂ : List α} : l₁ <:+: l₂ → l₁.reverse <:+: l₂.reverse
{α : Type u} [NonUnitalRing α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c
{X : Type u_1} [TopologicalSpace X] [NormalSpace X] {s t : Set X} (hs : is_IsClosed s) (ht : is_IsClosed t) (hD : Disjoint s t) : ∃ (f : C(X, ℝ)), Set.EqOn ⇑f 0 s ∧ Set.EqOn ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ Set.Icc 0 1
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (s : Set P) : (SpanPoints k s).nonempty ↔ s.nonempty
{α : Type u} {l : List α} : l.sublists'.nodup → l.nodup
{R : Type u_1} [Ring R] (s : Subring R) (m : Multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.sum ∈ s
{C : Type v} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] {X Y : C} (f : X ⟶ Y) (s : Function.Surjective ⇑f) : CategoryTheory.Epi f
{𝕜 : Type u_1} {E : Type u_3} [NormedField 𝕜] [AddCommGroup E] [Module 𝕜 E] {A : Set E} [TopologicalSpace E] [HasContinuousSmul 𝕜 E] (hA : Balanced 𝕜 A) : Balanced 𝕜 (0 ∪ Interior A)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [NormedSpace ℝ E] : IsBoundedBilinearMap ℝ (λ (p : E × E), HasInner.inner p.fst p.snd)
{α : Type u} [Lattice α] [AddCommGroup α] (a : α) (h : 0 ≤ a) : a⁺ = a
{α : Type u} [PseudoEmetricSpace α] {x y : α} : emetric.inf_edist x {y} = HasEdist.edist x y
(n : ℕ) {R : Type u_1} {S : Type u_2} [Ring R] [Ring S] (f : R →+* S) : Polynomial.map f (Polynomial.cyclotomic n R) = Polynomial.cyclotomic n S
{ι : Type u_1} {R : Type u_8} [OrderedCommSemiring R] {f g : ι → R} {s : Finset ι} (h0 : ∀ (i : ι), i ∈ s → 0 ≤ f i) (h1 : ∀ (i : ι), i ∈ s → f i ≤ g i) : s.prod (λ (i : ι), f i) ≤ s.prod (λ (i : ι), g i)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X Y : C} (f g : X ⟶ Y) [CategoryTheory.Limits.HasCokernel (f - g)] : CategoryTheory.Limits.HasCoequalizer f g
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) {u v : E} (hv : v ∈ K) : (∥u - v∥ = ⨅ (w : ↥↑K), ∥u - ↑w∥) ↔ ∀ (w : E), w ∈ K → HasInner.inner (u - v) w = 0
{α : Type u} {β : Type v} [MulOneClass α] [Group β] {f : α → β} (hF : IsMulHom f) : IsMonoidHom f
{α : Type u} [TopologicalSpace α] {ι : Type u_1} {f : ι → Set α} (hF : LocallyFinite f) {s : Set α} (hs : is_IsCompact s) : {i : ι | (f i ∩ s).nonempty}.finite
{s : Set ℝ} (h : Metric.Bounded s) : Emetric.diam s = ennreal.of_Real (HasSup.sup s - HasInf.inf s)
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] {a b c : α} : a < b + c → -b + a < c
(α : Type u) [t : TopologicalSpace α] [TopologicalSpace.SeparableSpace α] [Nonempty α] : DenseRange (topological_space.dense_Seq α)
{α : Type u} [PseudoMetricSpace α] (s : Set α) : LipschitzWith 1 (λ (x : α), metric.inf_nndist x s)
{C : Type u₁} [CategoryTheory.Category C] (P : Cᵒᵖ ⥤ Type (max v₁ u₁)) {X : C} (R : CategoryTheory.Presieve X) [CategoryTheory.Limits.HasPullbacks C] (x : CategoryTheory.Equalizer.FirstObj P R) : ((CategoryTheory.Equalizer.FirstObj_Eq_family P R).hom x).compatible ↔ Category_theory.equalizer.presieve.first_Map P R x = Category_theory.equalizer.presieve.second_Map P R x
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] {p1 : P} (p2 : P) (hp1 : p1 ∈ s) : ↑(⟨p1, hp1⟩ -ᵥ ⇑(euclidean_geometry.orthogonal_projection s) p2) ∈ s.direction
{R : Type u_1} [Ring R] {f g : ℕ → R} : (∀ (n : ℕ), 0 < n → n.divisors.sum (λ (i : ℕ), f i) = g n) ↔ ∀ (n : ℕ), 0 < n → n.divisors_antidiagonal.sum (λ (x : ℕ × ℕ), ↑(⇑Nat.ArithmeticFunction.moebius x.fst) * g x.snd) = f n
{R : Type u_1} {B : Type u_3} {F : Type u_4} [NondiscreteNormedField R] [NormedGroup F] [NormedSpace R F] [TopologicalSpace B] {ι : Type u_6} (Z : TopologicalVectorBundleCore R B F ι) : is_is_IsOpenMap Z.proj
{R : Type u_1} {S : Type u_2} {M : Type u_3} {a : R} [HasScalar R M] [HasScalar R S] [HasScalar S M] [IsScalarTower R S M] (b : S) (ha : IsSmulRegular M a) : IsSmulRegular M (a • b) ↔ IsSmulRegular M b
{β : Type u_2} [CommMonoid β] {n : ℕ} (f : Fin (n + 1) → β) : finset.univ.prod (λ (i : Fin (n + 1)), f i) = f 0 * finset.univ.prod (λ (i : Fin n), f i.succ)
{G : Type u_1} [AddCommMonoid G] : Add_monoid.is_torsion ↥(Add_comm_monoid.add_torsion G)
(𝕜 : Type u_1) [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (f : E → F) [MeasurableSpace E] [OpensMeasurableSpace E] [CompleteSpace F] : MeasurableSet {x : E | DifferentiableAt 𝕜 f x}
{𝕜 : Type u_3} {E : Type u_4} [NormedField 𝕜] [SemiNormedGroup E] [NormedSpace 𝕜 E] {r : ℝ} {x : E} (hx : ∥x∥ < r) : Absorbent 𝕜 (Metric.Ball x r)
{α : Type u} [TopologicalSpace α] : TotallyDisconnectedSpace α ↔ ∀ (x : α), (ConnectedComponent x).subsingleton
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (i : Fin r ⊕ Unit) : (matrix.pivot.list_transvec_col M).prod.mul M (Sum.inr ()) i = M (Sum.inr ()) i
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} {s : Set α} (h : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) ≠ 1) : s.nonempty
{ι : Type u_1} {x : ℕ} {s : ι → ℕ} {t : Finset ι} : (∀ (i : ι), i ∈ t → (s i).coprime x) → (t.prod (λ (i : ι), s i)).coprime x
 : ¬set.univ.countable
{α : Type u_1} {β : Type u_2} {M : Type u_3} [Fintype α] [Fintype β] [AddCommMonoid M] (e : α ≃ β) (f : α → M) (g : β → M) (h : ∀ (x : α), f x = g (⇑e x)) : finset.univ.sum (λ (x : α), f x) = finset.univ.sum (λ (x : β), g x)
{M : Type u_3} [Monoid M] (L : List M) (h : L.prod ≠ 1) : 0 < L.length
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) {r : ℝ} (hr : 0 < r) : InnerProductGeometry.angle x (r • y) = InnerProductGeometry.angle x y
{α : Type u_1} {𝒜 : Finset (Finset α)} {A₁ A₂ : Finset α} {r₁ r₂ : ℕ} (h₁ : A₁ ∈ 𝒜.slice r₁) (h₂ : A₂ ∈ 𝒜.slice r₂) : r₁ ≠ r₂ → A₁ ≠ A₂
{𝕜 : Type u_1} {E : Type u_2} [NormedLinearOrderedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {A B : Set E} (hAB : IsExposed 𝕜 A B) : ∃ (l : E →L[𝕜] 𝕜) (a : 𝕜), B = {x ∈ A | a ≤ ⇑l x}
(K : Type u_1) [Field K] [Fintype K] [Fintype Kˣ] (i : ℕ) : finset.univ.sum (λ (x : Kˣ), ↑x ^ i) = Ite (Fintype.card K - 1 ∣ i) (-1) 0
{β : Type u} {α : Type v} [AddCommMonoid β] {p : α → Prop} {s : Finset {x // p x}} {f : {x // p x} → β} {g : α → β} (h : ∀ (x : {x // p x}), x ∈ s → g ↑x = f x) : (Finset.map (Function.Embedding.subtype (λ (x : α), p x)) s).sum (λ (x : α), g x) = s.sum (λ (x : {x // p x}), f x)
{G : Type u_1} [Group G] (K : Subgroup G) : Subgroup.closure ↑K = K
{α : Type u} [TopologicalSpace α] [t2_Space α] [CompactSpace α] : TotallyDisconnectedSpace α ↔ TotallySeparatedSpace α
{f : ℝ → ℝ} {f' a : ℝ} (h : is_is_IsLocalMax f a) (hF : HasDerivAt f f' a) : f' = 0
{F : Type u_1} [NormedGroup F] [NormedSpace ℝ F] (f : ℝ → F) [CompleteSpace F] : MeasurableSet {x : ℝ | DifferentiableWithinAt ℝ f (Set.Ioi x) x}
{β : Type u_2} {f g : β → Nnreal} (hgf : ∀ (b : β), g b ≤ f b) : Summable f → Summable g
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {s : Set E} (s_conv : Convex ℝ s) {f : E → F} {f' : E → (E →L[ℝ] F)} {f'' : E →L[ℝ] E →L[ℝ] F} (hF : ∀ (x : E), x ∈ Interior s → HasFderivAt f (f' x) x) {x : E} (xs : x ∈ s) (hx : HasFderivWithinAt f' f'' (Interior s) x) {v w : E} (h4v : x + 4 • v ∈ Interior s) (h4w : x + 4 • w ∈ Interior s) : ⇑(⇑f'' w) v = ⇑(⇑f'' v) w
{𝕜 : Type u} [NondiscreteNormedField 𝕜] (p : Polynomial 𝕜) (x : 𝕜) : HasDerivAt (λ (x : 𝕜), Polynomial.eval x p) (Polynomial.eval x (⇑Polynomial.derivative p)) x
{α : Type u_1} [PartialOrder α] (c : ClosureOperator α) (x : α) : x ≤ ⇑c x
{R : Type u_2} {Γ₀ : Type u_3} {Γ'₀ : Type u_4} [Ring R] [LinearOrderedCommMonoidWithZero Γ₀] [LinearOrderedCommMonoidWithZero Γ'₀] {v₁ : Valuation R Γ₀} {v₂ : Valuation R Γ'₀} {S : Type u_1} [Ring S] (f : S →+* R) (h : v₁.is_Equiv v₂) : (Valuation.comap f v₁).is_Equiv (Valuation.comap f v₂)
(n : ℕ+) (S : Set ℕ+) (K : Type w) (L : Type z) [Field K] [Field L] [Algebra K L] [NeZero ↑↑n] [H : IsCyclotomicExtension S K L] (hS : n ∈ S) : Polynomial.Splits (Algebra_Map K L) (Polynomial.x ^ ↑n - 1)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p : P) (h : s.sum (λ (i : ι), w i) = 0) : ⇑(s.weighted_vsub (λ (_x : ι), p)) w = 0
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder α] [OrderClosedTopology α] [Nonempty α] [TopologicalSpace β] [has_One α] {f : β → α} (hF : Continuous f) (h : HasCompactMulSupport f) : BddBelow (Set.Range f)
{α : Type u} {β : Type v} {f : α → β} (h : Function.Injective f) (s : Set α) : Set.InjOn f s
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] (M : Matrix n n R) : M.transpose.det = M.det
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] (f : S.localization_Map N) : f.of_MulEquiv_of_Dom _ = f
{k : Type u₁} {G : Type u₂} {R : Type u_1} [Semiring k] [MulOneClass G] [Semiring R] {f g : MonoidAlgebra k G →+* R} (h₁ : f.comp Monoid_algebra.single_One_RingHom = g.comp Monoid_algebra.single_One_RingHom) (h_of : ↑f.comp (MonoidAlgebra.of k G) = ↑g.comp (MonoidAlgebra.of k G)) : f = g
(α : Type u) [UniformSpace α] [(Uniformity α).is_countably_generated] [TopologicalSpace.SeparableSpace α] : TopologicalSpace.SecondCountableTopology α
(R : Type u_1) [CommRing R] (M : Type u_2) [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] [Nontrivial R] : ⇑(LinearMap.trace R M) LinearMap.id = ↑(FiniteDimensional.finrank R M)
{α : Type u_1} [LinearOrderedField α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b⁻¹ ↔ b < a
{α : Type u_1} {r s : α → α → Prop} (h : ∀ (x y : α), r x y → s x y) : EqvGen.setoid r ≤ EqvGen.setoid s
{p : ℕ} [Fact (Nat.Prime p)] {f : PadicSeq p} (hF : ¬f ≈ 0) (v1 v2 : ℕ) : padic_norm p (⇑f (padic_seq.stationary_point hF)) = padic_norm p (⇑f (Linear_order.max v1 (Linear_order.max v2 (padic_seq.stationary_point hF))))
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1
{α : Type u_1} [HasLe α] {s : Set α} : IsUpperSet s → IsLowerSet (⇑order_dual.of_dual ⁻¹' s)
{β : Type u} {α : Type v} [AddCommMonoid β] [DecidableEq α] (s : Finset α) (f : α → β) {a : α} (h : a ∈ s) : f a + (s.erase a).sum (λ (x : α), f x) = s.sum (λ (x : α), f x)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {A : Type u₃} [CategoryTheory.Category A] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {G : C ⥤ D} (hG₁ : CategoryTheory.CompatiblePreserving K G) (hG₂ : CategoryTheory.CoverPreserving J K G) (ℱ : CategoryTheory.Sheaf K A) : CategoryTheory.Presheaf.IsSheaf J (G.op ⋙ ℱ.val)
{α : Type u_1} [TopologicalSpace α] {γ : Type u_4} [LinearOrderedAddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] {f g : α → γ} (hF : UpperSemicontinuous f) (hg : UpperSemicontinuous g) (hcont : ∀ (x : α), ContinuousAt (λ (p : γ × γ), p.fst + p.snd) (f x, g x)) : UpperSemicontinuous (λ (z : α), f z + g z)
{α : Type u_1} {n : Type u_2} {m : Type u_3} [HasMul α] [AddCommMonoid α] (A : Matrix m n α) [Fintype m] : A.transpose.has_Orthogonal_rows ↔ A.has_Orthogonal_cols
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X ⟶ Y} (t : CategoryTheory.Limits.Fork f g) [CategoryTheory.Epi t.ι] : f = g
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {f : E → F} {p : E → FormalMultilinearSeries ℝ E F} {s : Set E} {x : E} (hF : HasFtaylorSeriesUpToOn 1 f p (HasInsert.insert x s)) (hs : Convex ℝ s) (K : Nnreal) (hK : ∥p x 1∥₊ < K) : ∃ (t : Set E) (H : t ∈ nhds_within x s), LipschitzOnWith K f t
(a b : ℕ) {c : ℕ} (hc : 0 < c) : c * a / (c * b) = a / b
{s : Set ℕ} (hs : s.infinite) {k : ℕ} (hk : 0 < k) : ∃ (m : ℕ) (H : m ∈ s) (n : ℕ) (H : n ∈ s), m < n ∧ m ≡ n [Mod k]
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {X X' Y Y' Z Z' : C} [CategoryTheory.ExactPairing Y Y'] (f : X ⟶ Y ⊗ Z) (g : X' ⟶ Z') : ⇑((Category_theory.tensor_Left_hom_Equiv (X ⊗ X') Y Y' (Z ⊗ Z')).symm) ((f ⊗ g) ≫ (α_ Y Z Z').hom) = (α_ Y' X X').inv ≫ (⇑((Category_theory.tensor_Left_hom_Equiv X Y Y' Z).symm) f ⊗ g)
{C : Type u₁} [CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {P : Cᵒᵖ ⥤ Type v₁} : CategoryTheory.Presieve.IsSheafFor P ⇑S ↔ CategoryTheory.Presieve.YonedaSheafCondition P S
(p : ℕ) [hp : Fact (Nat.Prime p)] {q r : ℚ} : padic_norm p (q - r) ≤ Linear_order.max (padic_norm p q) (padic_norm p r)
(α : Type u) (β : Type v) [AddGroup α] [AddAction α β] [Fintype α] [Π (a : α), Fintype ↥(AddAction.FixedBy α β a)] [Fintype (Quotient (AddAction.Orbit_Rel α β))] : finset.univ.sum (λ (a : α), Fintype.card ↥(AddAction.FixedBy α β a)) = Fintype.card (Quotient (AddAction.Orbit_Rel α β)) * Fintype.card α
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] (s1 s2 : AffineSubspace k P) : s1 < s2 ↔ ↑s1 ⊂ ↑s2
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace ↥K] : ∥Orthogonal_projection K∥ ≤ 1
{ι : Type u_1} {R : Type u_8} [OrderedCommSemiring R] {s : Finset ι} {i : ι} {f g h : ι → R} (hi : i ∈ s) (h2i : g i + h i ≤ f i) (hgf : ∀ (j : ι), j ∈ s → j ≠ i → g j ≤ f j) (hhf : ∀ (j : ι), j ∈ s → j ≠ i → h j ≤ f j) (hg : ∀ (i : ι), i ∈ s → 0 ≤ g i) (hH : ∀ (i : ι), i ∈ s → 0 ≤ h i) : s.prod (λ (i : ι), g i) + s.prod (λ (i : ι), h i) ≤ s.prod (λ (i : ι), f i)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (r : ℝ) (v : V) (p₁ p₂ : P) : HasDist.dist (r • v +ᵥ p₁) p₂ * HasDist.dist (r • v +ᵥ p₁) p₂ = HasInner.inner v v * r * r + 2 * HasInner.inner v (p₁ -ᵥ p₂) * r + HasInner.inner (p₁ -ᵥ p₂) (p₁ -ᵥ p₂)
{M : Type u_1} [Nonempty M] [AddSemigroup M] [TopologicalSpace M] [CompactSpace M] [t2_Space M] (Continuous_Mul_Left : ∀ (r : M), Continuous (λ (_x : M), _x + r)) : ∃ (m : M), m + m = m
 : IsTrivialTopologicalFiberBundle ℝ Complex.re
{k : ℕ} (n : ℕ) (hpos : 0 < k) : ∃ (p : ℕ), Nat.Prime p ∧ n ≤ p ∧ p ≡ 1 [Mod k]
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) {p1 : P} (p2 : P) (r : ℝ) (hp : p1 ∈ affine_Span ℝ (Set.Range s.points)) : ⇑(s.orthogonal_projection_Span) (r • (p2 -ᵥ ↑(⇑(s.orthogonal_projection_Span) p2)) +ᵥ p1) = ⟨p1, hp⟩
 : IsTrivialTopologicalFiberBundle ℝ Complex.im
{M : Type u_1} [HasMul M] {c d : Con M} (H : c.to_Setoid = d.to_Setoid) : c = d
{R : Type u} {L : Type v} [CommRing R] [LieRing L] [LieAlgebra R L] (M : Type w) [AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M] [Nontrivial M] [LieAlgebra.IsNilpotent R L] [LieModule.IsNilpotent R L M] : LieModule.IsWeight ⊤ M 0
{B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] : IsTopologicalFiberBundle F Prod.fst
{X : Type u} {Y : Type v} [Preorder X] [Preorder Y] {L : X ⥤ Y} {R : Y ⥤ X} (Adj : L ⊣ R) : GaloisConnection L.obj R.obj
{α : Type u_1} [TopologicalSpace α] [BaireSpace α] {S : Set (Set α)} (hc : ∀ (s : Set α), s ∈ S → is_IsClosed s) (hS : S.countable) (hU : ⋃₀S = Set.Univ) : Dense (⋃ (s : Set α) (H : s ∈ S), Interior s)
{S : Type u} [Semigroup S] {a x y x' y' : S} (h : SemiconjBy a x y) (h' : SemiconjBy a x' y') : SemiconjBy a (x * x') (y * y')
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) : 2 • o.oangle x (-y) = 2 • o.oangle x y
{ι : Type u_1} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {G : ι → Type u_4} [Π (i : ι), InnerProductSpace 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 V) [∀ (i : ι), CompleteSpace (G i)] (hV' : (⨆ (i : ι), (V i).to_LinearMap.range).topological_Closure = ⊤) (w : ↥(Lp G 2)) : HasSum (λ (i : ι), ⇑(V i) (⇑w i)) (⇑((hV.linear_Isometry_Equiv hV').symm) w)
{R : Type u_1} [Semiring R] {M : LaurentPolynomial R → Prop} (p : LaurentPolynomial R) (h_Add : ∀ (p q : LaurentPolynomial R), M p → M q → M (p + q)) (h_C_Mul_T : ∀ (n : ℤ) (a : R), M (⇑LaurentPolynomial.c a * LaurentPolynomial.t n)) : M p
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι → 𝕜) {s : Finset ι} {i : ι} (hi : i ∈ s) : HasInner.inner (s.sum (λ (i : ι), l i • v i)) (v i) = ⇑(StarRing_end 𝕜) (l i)
{R : Type u} [Ring R] {ι : sort u_1} [hι : Nonempty ι] {S : ι → Subring R} (hS : Directed has_le.le S) {x : R} : (x ∈ ⨆ (i : ι), S i) ↔ ∃ (i : ι), x ∈ S i
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (hp1p2 : p1 ≠ p2) (hp3p2 : p3 ≠ p2) : HasDist.dist p1 p3 = HasDist.dist p1 p2 + HasDist.dist p3 p2 ↔ EuclideanGeometry.angle p1 p2 p3 = Real.pi
(R : Type u_1) (M : Type u_2) [Semiring R] [Nontrivial M] [AddCommMonoid M] [Module R M] : Nontrivial R
{α : Type u} {β : Type v} [Preorder α] [LinearOrder β] {f g : α → β} (hF : Antitone f) (hg : Antitone g) : Antitone (λ (x : α), Linear_order.max (f x) (g x))
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (h : p 1 = ⇑((Continuous_multilinear_Curry_Fin1 𝕜 E F).symm) ↑i) : p.left_Inv i = p.right_Inv i
{α : Type u} {β : Type v} {f : α → β} {g : β → α} (hF : Function.Injective f) (hg : Function.Injective g) : ∃ (h : α → β), Function.bijective h
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1
{K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] (s t : Submodule K V) [FiniteDimensional K ↥s] [FiniteDimensional K ↥t] : FiniteDimensional.finrank K ↥(s ⊔ t) + FiniteDimensional.finrank K ↥(s ⊓ t) = FiniteDimensional.finrank K ↥s + FiniteDimensional.finrank K ↥t
{R : Type u_1} [CancelCommMonoidWithZero R] {α : Type u_2} [DecidableEq α] {x y a : R} {s : Finset α} {p : α → R} (hp : ∀ (i : α), i ∈ s → Prime (p i)) (hx : x * y = a * s.prod (λ (i : α), p i)) : ∃ (t u : Finset α) (b c : R), t ∪ u = s ∧ Disjoint t u ∧ a = b * c ∧ x = b * t.prod (λ (i : α), p i) ∧ y = c * u.prod (λ (i : α), p i)
{G : Type w} [TopologicalSpace G] [AddGroup G] [TopologicalAddGroup G] {K V : Set G} (hK : is_IsCompact K) (hV : (Interior V).nonempty) : ∃ (t : Finset G), K ⊆ ⋃ (g : G) (H : g ∈ t), (λ (h : G), g + h) ⁻¹' V
{p n k b : ℕ} (hp : Nat.Prime p) (hkn : k ≤ n) (hnb : Nat.log p n < b) : multiplicity p (n.choose k) = ↑((Finset.filter (λ (i : ℕ), p ^ i ≤ k % p ^ i + (n - k) % p ^ i) (Finset.ico 1 b)).card)
{M : Type u_1} [HasMul M] {s : Set M} {S : Subsemigroup M} : Subsemigroup.closure s ≤ S ↔ s ⊆ ↑S
{β : Type u} {α : Type v} {s : Finset α} {f : α → β} [CommMonoid β] (R : Setoid α) [DecidableRel Setoid.r] (h : ∀ (x : α), x ∈ s → (Finset.filter (λ (y : α), y ≈ x) s).prod (λ (a : α), f a) = 1) : s.prod (λ (x : α), f x) = 1
{α : Type u_1} {r : Setoid α} {x : α} {b : Set α} (hc : b ∈ r.classes) (hb : x ∈ b) {b' : Set α} (hc' : b' ∈ r.classes) (hb' : x ∈ b') : b = b'
{α : sort u_1} {a a' : α} {β : sort u_2} (y : β) (h : a = a') : eq.rec y h = y
{α : Type u} {L₁ L₂ : List (α × Bool)} : FreeGroup.Red.Step L₁ L₂ → L₂.length + 2 = L₁.length
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommMonoid β] [Module 𝕜 E] [HasScalar 𝕜 β] {s : Set E} {f : E → β} (hF : ConcaveOn 𝕜 s f) (c : E) : ConcaveOn 𝕜 ((λ (z : E), c + z) ⁻¹' s) (f ∘ λ (z : E), c + z)
{𝕜 : Type u_1} {E : Type u_3} {F : Type u_4} [OrderedRing 𝕜] [TopologicalSpace E] [TopologicalSpace F] [AddCommGroup E] [AddCommGroup F] [Module 𝕜 E] [Module 𝕜 F] {s : Set F} (hs : StrictConvex 𝕜 s) {f : E →ᵃ[𝕜] F} (hF : Continuous ⇑f) (hfinj : Function.Injective ⇑f) : StrictConvex 𝕜 (⇑f ⁻¹' s)
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {a : F} (ha : a ≠ 0) : char.quadratic_Char F a = 1 ∨ char.quadratic_Char F a = -1
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] : Orthogonal_projection ⊥ = 0
{R : Type u_1} {a : R} [Semigroup R] (b : R) (ha : IsLeftRegular a) : IsLeftRegular (a * b) ↔ IsLeftRegular b
{α : Type u} [Group α] [HasLe α] [CovariantClass α α has_mul.mul has_le.le] {a b c : α} : a * b ≤ c → b ≤ a⁻¹ * c
(x y : ℕ) : ↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y
(𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} [LinearOrder ι] [OrderBot ι] [LocallyFiniteOrder ι] [IsWellOrder ι has_lt.lt] (f : ι → E) {a b : ι} (h₀ : a ≠ b) : HasInner.inner (gram_schmidt 𝕜 f a) (gram_schmidt 𝕜 f b) = 0
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s₁ s₂ : Set P} (h : s₁ ⊆ s₂) : Vector_Span k s₁ ≤ Vector_Span k s₂
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M →* P} (hg : ∀ (y : ↥S), IsUnit (⇑g ↑y)) (z : N) : ⇑(f.lift hg) z * ⇑g ↑((f.sec z).snd) = ⇑g (f.sec z).fst
{a b : Ereal} (h : -a ≤ b) : -b ≤ a
{X : Type u_1} [TopologicalSpace X] [SequentialSpace X] {s : Set X} : IsSeqClosed s ↔ is_IsClosed s
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x₀ : E} (hF : HasFderivAt f f' x₀) {s : Set E} (hs : s ∈ nhds x₀) {C : Nnreal} (hlip : LipschitzOnWith C f s) : ∥f'∥ ≤ ↑C
{R : Type u_1} [CommRing R] {a b : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) [Invertible A] : (⅟ A).mul A = 1
{K : Type u} [Field K] (s : Subfield K) {ι : Type u_1} {t : Finset ι} {f : ι → K} (h : ∀ (c : ι), c ∈ t → f c ∈ s) : t.prod (λ (i : ι), f i) ∈ s
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (f : C(α, β)) {x y : α} (h : x = y) : ⇑f x = ⇑f y
{α : Type u} {a b : α} [MulOneClass α] [HasZero α] [Preorder α] [ZeroLt.PosMulStrictMono α] (ha : 1 ≤ a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [CompleteSpace E] [CompleteSpace F] (A : E →L[𝕜] F) (x : E) (y : F) : HasInner.inner (⇑(⇑ContinuousLinearMap.adjoint A) y) x = HasInner.inner y (⇑A x)
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {ι : Type w} {b : Finset ι} (h : Basis ↥b K V) : FiniteDimensional.finrank K V = b.card
{n n' : ℕ} (m : ℕ) (i : Fin n') (h : n' = n) : ⇑(fin.nat_Add m) (⇑(fin.cast h) i) = ⇑(fin.cast _) (⇑(fin.nat_Add m) i)
{M : Type u_3} {N : Type u_4} [MulOneClass M] [MulOneClass N] (f : M →* N) {x y : M} (h : x = y) : ⇑f x = ⇑f y
{α : Type u_1} [MeasurableSpace α] {f : ℕ → α → Nnreal} {g : α → Nnreal} (hF : ∀ (i : ℕ), Measurable (f i)) (lim : Filter.Tendsto f filter.at_Top (nhds g)) : Measurable g
{x : Pgame} : x.lf 0 ↔ ∃ (j : x.right_moves), x.move_Right j ≤ 0
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [SemiNormedGroup E'] {g : α → F} {f' : α → E'} {l : Filter α} : f' =O[l] g → (λ (x : α), -f' x) =O[l] g
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : α → β} : Monotone f → Antitone (f ∘ ⇑order_dual.of_dual)
(𝕂 : Type u_1) (𝔸 : Type u_2) [is_R_or_C 𝕂] [NormedRing 𝔸] [NormedAlgebra 𝕂 𝔸] : (Exp_series 𝕂 𝔸).radius = ⊤
{K : Type u} {L : Type v} [Field K] [Field L] {f g : K →+* L} {s : Set K} (h : Set.EqOn ⇑f ⇑g s) : Set.EqOn ⇑f ⇑g ↑(Subfield.closure s)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s₁ s₂ : AffineSubspace k P} {p : P} (h₁ : p ∈ s₁) (h₂ : p ∈ s₂) : s₁ = s₂ ↔ s₁.direction = s₂.direction
{R : Type u_2} [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R] {a b c : R} (ha : a ≠ 0) (no_Factors : ∀ {d : R}, d ∣ a → d ∣ b → ¬Prime d) : a ∣ b * c → a ∣ c
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {s : Set P} [Nontrivial P] : affine_Span k s = ⊤ ↔ Vector_Span k s = ⊤
{C : Type u} [CategoryTheory.Category C] {J : CategoryTheory.GrothendieckTopology C} (hJ : CategoryTheory.Sheaf.Subcanonical J) (P : Cᵒᵖ ⥤ Type v) [P.representable] : CategoryTheory.Presieve.IsSheaf J P
{α : Type u} [TopologicalSpace α] {s : Set α} : Dense s ↔ ∀ (U : Set α), is_IsOpen U → U.nonempty → (U ∩ s).nonempty
{α : Type u_2} {β : Type u_3} [DecidableEq β] [HasVadd α β] {u : Finset β} {s : Set α} {t : Set β} : ↑u ⊆ s +ᵥ t → (∃ (s' : Finset α) (t' : Finset β), ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' +ᵥ t')
(𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {v : E} (hv : ∥v∥ = 1) (w : E) : ↑(⇑(Orthogonal_projection (Submodule.span 𝕜 {v})) w) = HasInner.inner v w • v
{α : Type u} {a b : α} [MulOneClass α] [HasZero α] [Preorder α] [ZeroLt.PosMulMono α] (ha : 1 < a) (hb : 1 ≤ b) (a0 : 0 < a) : 1 < a * b
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} {s t : Set α} (hst : s ⊆ t) (ht : (t ∩ Function.Support f).finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ t  s), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ t), f i))
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {v : Set E} [FiniteDimensional 𝕜 E] (hv : Orthonormal 𝕜 Coe) : ∃ (u : Set E) (H : u ⊇ v) (b : Basis ↥u 𝕜 E), Orthonormal 𝕜 ⇑b ∧ ⇑b = Coe
(S : Set ℝ) (hS : ∀ (x : ℝ), x ∈ S → x ≤ 0) : HasInf.inf S ≤ 0
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K₁ K₂ : Submodule 𝕜 E} (h : K₁ ≤ K₂) [CompleteSpace ↥K₁] : K₁ ⊔ K₁ᗮ ⊓ K₂ = K₂
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} {ps : Set P} (h : ps ⊆ ↑s) [Nonempty ↥s] {n : ℕ} [FiniteDimensional ℝ ↥(s.direction)] (hD : FiniteDimensional.finrank ℝ ↥(s.direction) = n) (hc : EuclideanGeometry.Cospherical ps) {sx₁ sx₂ : Affine.Simplex ℝ P n} (hsx₁ : Set.Range sx₁.points ⊆ ps) (hsx₂ : Set.Range sx₂.points ⊆ ps) : sx₁.circumradius = sx₂.circumradius
{α : sort u} {β : sort v} {γ : sort w} {g : β → γ} (hg : Function.Surjective g) : Function.Surjective (Function.comp g)
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} [PartialOrder 𝕜] : HasDerivWithinAt f f' (Set.Ici x) x → HasDerivWithinAt f f' (Set.Ioi x) x
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] : EuclideanGeometry.Cospherical ∅
{α : Type v} [LinearOrder α] {x₁ x₂ y₁ y₂ : α} (h : Disjoint (Set.Ico x₁ x₂) (Set.Ico y₁ y₂)) (hx : x₁ < x₂) (h2 : x₂ ∈ Set.Ico y₁ y₂) : y₁ = x₂
{R : Type u_1} [CommRing R] [is_IsDomain R] : (Ideal.span {PowerSeries.x}).is_Prime
{F : Type u_1} [Field F] (p : Polynomial F) (E : Type u_2) [Field E] [Algebra F E] [Fact (Polynomial.Splits (Algebra_Map F E) p)] : Function.Injective ⇑(polynomial.gal.gal_action_hom p E)
{α : Type u_1} [MeasurableSpace α] (s : MeasureTheory.SignedMeasure α) : s.to_jordan_decomposition.to_SignedMeasure = s
(C : Type u) [CategoryTheory.Category C] [∀ {X Y : C} {f g : X ⟶ Y}, CategoryTheory.Limits.HasColimit (Category_theory.limits.parallel_pair f g)] : CategoryTheory.Limits.HasCoequalizers C
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p ∈ s) (p2 : P) : p2 -ᵥ p ∈ s.direction ↔ p2 ∈ s
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (hM : M (Sum.inr ()) (Sum.inr ()) ≠ 0) (i : Fin r) : (matrix.pivot.list_transvec_col M).prod.mul M (Sum.inl i) (Sum.inr ()) = 0
{p n : ℕ} (h : 2 * n < p) : ⇑(n.central_binom.factorization) p = 0
{G : Type u} [Group G] (a x : G) : SemiconjBy a x (a * x * a⁻¹)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {s : Set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_Diff : DifferentiableOn ℝ f s) (f_lim : ContinuousWithinAt f s a) (hs : s ∈ nhds_within a (Set.Iio a)) (f_lim' : Filter.Tendsto (λ (x : ℝ), deriv f x) (nhds_within a (Set.Iio a)) (nhds e)) : HasDerivWithinAt f e (Set.Iic a) a
{R : Type u_1} [Semiring R] (f : LaurentPolynomial R) {Q : LaurentPolynomial R → Prop} (is_qf : ∀ (f : Polynomial R), Q (⇑polynomial.to_laurent f)) (QT : ∀ (f : LaurentPolynomial R), Q (f * LaurentPolynomial.t 1) → Q f) : Q f
{k : Type u_1} {G : Type u_2} {V : Type u_3} [CommSemiring k] [Group G] [AddCommMonoid V] [Module k V] (ρ : Representation k G V) [Fintype G] [Invertible ↑(Fintype.card G)] (v : V) (hv : v ∈ ρ.invariants) : ⇑(ρ.average_Map) v = v
{G : Type u_3} [Group G] (P : Subgroup G) : P.fg ↔ P.to_submonoid.fg
{𝕜 : Type u_1} {E : Type u_2} [OrderedRing 𝕜] [AddCommGroup E] [Module 𝕜 E] {K : Geometry.SimplicialComplex 𝕜 E} {s t : Finset E} (hs : s ∈ K.faces) (ht : t ∈ K.faces) : ⇑(Convex_hull 𝕜) ↑s ⊆ ⇑(Convex_hull 𝕜) ↑t ↔ s ⊆ t
{J : Type u₁} [CategoryTheory.Category J] [CategoryTheory.IsPreconnected J] {α : Type u₁} (F : J ⥤ CategoryTheory.Discrete α) (j j' : J) : F.obj j = F.obj j'
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {δ : Type u_1} [LinearOrder δ] [TopologicalSpace δ] [OrderClosedTopology δ] {s : Set α} [hs : s.ord_connected] {f : α → δ} (hF : ContinuousOn f s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) : Set.SurjOn f s (Set.Icc (f a) (f b))
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {X Y Z : C} [CategoryTheory.HasLeftDual X] [CategoryTheory.HasLeftDual Y] [CategoryTheory.HasLeftDual Z] {f : X ⟶ Y} {g : Y ⟶ Z} : ᘁ(f ≫ g) = ᘁg ≫ ᘁf
{γ : Type w} [SemilatticeSup γ] {a b : γ} {s t : Set γ} (hs : is_is_IsLub s a) (ht : is_is_IsLub t b) : is_is_IsLub (s ∪ t) (a ⊔ b)
{K : Type u} [hfield : Field K] (p : Polynomial K) {q : Polynomial K} (hq : q ≠ 0) : ⇑Polynomial.c ((q / GcdMonoid.gcd p q).leading_Coeff)⁻¹ * (p / GcdMonoid.gcd p q) ∣ p
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} (p : ι → P) : AffineIndependent k p ↔ ∀ (s1 s2 : Finset ι) (w1 w2 : ι → k), s1.sum (λ (i : ι), w1 i) = 1 → s2.sum (λ (i : ι), w2 i) = 1 → ⇑(s1.affine_combination p) w1 = ⇑(s2.affine_combination p) w2 → ↑s1.indicator w1 = ↑s2.indicator w2
{R : Type u_1} {M : Type u_2} {N : Type u_3} {P : Type u_4} [Ring R] [AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N] [AddCommGroup P] [Module R P] (f : M →ₗ[R] N) (g : N →ₗ[R] P) (hF1 : f.ker.fg) (hF2 : g.ker.fg) (hsur : Function.Surjective ⇑f) : (g.comp f).ker.fg
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) : o.oangle (⇑(o.rotation θ) x) y = o.oangle x y - θ
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {c : F} : ContDiff 𝕜 n (λ (x : E), c)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] [Nontrivial α] {s : Set α} [TopologicalSpace.SeparableSpace ↥s] (hs : Dense s) : ∃ (t : Set α) (H : t ⊆ s), t.countable ∧ Dense t ∧ (∀ (x : α), IsBot x → x ∉ t) ∧ ∀ (x : α), IsTop x → x ∉ t
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [CommRing 𝕜] [AddCommGroup E] [AddCommGroup F] [Module 𝕜 E] [Module 𝕜 F] [TopologicalSpace E] [TopologicalSpace F] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] [TopologicalAddGroup F] [HasContinuousConstSmul 𝕜 F] (q : FormalMultilinearSeries 𝕜 E F) (p : FormalMultilinearSeries 𝕜 E E) : q.comp p 0 = q 0
{M₀ : Type u_1} [MulZeroClass M₀] [NoZeroDivisors M₀] {a b : M₀} : a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [dec_E : DecidableEq E] {s : Set E} : Orthonormal 𝕜 Coe ↔ ∀ (v : E), v ∈ s → ∀ (w : E), w ∈ s → HasInner.inner v w = Ite (v = w) 1 0
{M : Type u_1} [has_Add M] {s : Set M} {p : M → Prop} {x : M} (h : x ∈ AddSubsemigroup.closure s) (Hs : ∀ (x : M), x ∈ s → p x) (hMul : ∀ (x y : M), p x → p y → p (x + y)) : p x
{α : Type u_1} {β : Type u_2} [AddGroup α] [SubtractionMonoid β] (f : α →+ β) (g : α) (n : ℤ) : ⇑f (n • g) = n • ⇑f g
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
{α : Type u_1} {β : Type u_2} {α₂ : Type u_3} [Semiring β] [has_Add α] [has_Add α₂] {F : Type u_4} [AddHomClass F α α₂] (f : F) (x y : AddMonoidAlgebra β α) : finsupp.map_IsDomain ⇑f (x * y) = finsupp.map_IsDomain ⇑f x * finsupp.map_IsDomain ⇑f y
{α : Type u_2} [DecidableEq α] [HasMul α] {u : Finset α} {s t : Set α} : ↑u ⊆ s * t → (∃ (s' t' : Finset α), ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' * t')
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} [Fintype ι] (p : ι → P) : AffineIndependent k p ↔ ∀ (w1 w2 : ι → k), finset.univ.sum (λ (i : ι), w1 i) = 1 → finset.univ.sum (λ (i : ι), w2 i) = 1 → ⇑(finset.univ.affine_combination p) w1 = ⇑(finset.univ.affine_combination p) w2 → w1 = w2
{ι : Type u} {γ : Type w} {β : ι → Type v} [dec : DecidableEq ι] {δ : Type u_1} [Π (i : ι), AddZeroClass (β i)] [AddCommMonoid γ] [AddCommMonoid δ] (g : γ →+ δ) (f : Π (i : ι), β i →+ γ) : g.comp (⇑dfinsupp.lift_AddHom f) = ⇑dfinsupp.lift_AddHom (λ (a : ι), g.comp (f a))
{𝕜 : Type u_1} {E : Type u_2} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {f : 𝕜 → E} {r : Ennreal} {x : 𝕜} {p : FormalMultilinearSeries 𝕜 𝕜 E} (h : HasFpowerSeriesOnBall f p x r) (h' : ∀ (r' : Nnreal), 0 < r' → (∃ (p' : FormalMultilinearSeries 𝕜 𝕜 E), HasFpowerSeriesOnBall f p' x ↑r')) : HasFpowerSeriesOnBall f p x ⊤
(R : Type u_1) [CommSemiring R] (X : Type u_2) {C : FreeAlgebra R X → Prop} (h_grade0 : ∀ (r : R), C (⇑(Algebra_Map R (FreeAlgebra R X)) r)) (h_grade1 : ∀ (x : X), C (FreeAlgebraι R x)) (h_Mul : ∀ (a b : FreeAlgebra R X), C a → C b → C (a * b)) (h_Add : ∀ (a b : FreeAlgebra R X), C a → C b → C (a + b)) (a : FreeAlgebra R X) : C a
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [SemiNormedGroup E'] [SemiNormedGroup F'] {c : ℝ} {f' : α → E'} {g' : α → F'} {l : Filter α} : asymptotics.is_O_with c l (λ (x : α), ∥f' x∥) (λ (x : α), ∥g' x∥) → asymptotics.is_O_with c l f' g'
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z → B} [TopologicalSpace Z] {B' : Type u_5} [TopologicalSpace B'] (h : IsTopologicalFiberBundle F Proj) {f : B' → B} (hF : Continuous f) : IsTopologicalFiberBundle F (λ (x : ↥{p : B' × Z | f p.fst = Proj p.snd}), ↑x.fst)
{α : Type u} [PseudoMetricSpace α] {f : ℕ → α} (n : ℕ) {d : ℕ → ℝ} (hD : ∀ {k : ℕ}, k < n → HasDist.dist (f k) (f (k + 1)) ≤ d k) : HasDist.dist (f 0) (f n) ≤ (Finset.range n).sum (λ (i : ℕ), d i)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {x : E} {n : WithTop ℕ} {f g : E → 𝕜} (hF : ContDiffAt 𝕜 n f x) (hg : ContDiffAt 𝕜 n g x) : ContDiffAt 𝕜 n (λ (x : E), f x * g x) x
{α : Type u_1} [LinearOrder α] [DenselyOrdered α] [NoMinOrder α] [NoMaxOrder α] [nonem : Nonempty α] (lo hi : Finset α) (lo_Lt_hi : ∀ (x : α), x ∈ lo → ∀ (y : α), y ∈ hi → x < y) : ∃ (m : α), (∀ (x : α), x ∈ lo → x < m) ∧ ∀ (y : α), y ∈ hi → m < y
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (hM : M (Sum.inr ()) (Sum.inr ()) ≠ 0) (i : Fin r) : ((matrix.pivot.list_transvec_col M).prod.mul M).mul (matrix.pivot.list_transvec_row M).prod (Sum.inr ()) (Sum.inl i) = 0
{K : Type u_1} [Field K] [Invertible 2] {a b c : K} (ha : a ≠ 0) (h : ∃ (s : K), discrim a b c = s * s) : ∃ (x : K), a * x * x + b * x + c = 0
{R : Type v} [CommRing R] {n : ℕ} (A : Matrix (Fin n.succ) (Fin n.succ) R) (j : Fin n.succ) : A.det = finset.univ.sum (λ (i : Fin n.succ), (-1) ^ (↑i + ↑j) * A i j * (A.minor ⇑(i.succ_above) ⇑(j.succ_above)).det)
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} {a b : α} (h : a ≠ b) : finprod (λ (i : α), finprod (λ (H : i ∈ {a, b}), f i)) = f a * f b
{ι : Type u_1} {R : Type u_3} {M : Type u_5} [Ring R] [AddCommGroup M] [Module R M] [Nontrivial R] (b : Basis ι R M) : _.maximal
{R : Type u_1} {a b : R} [Semigroup R] (Ab : IsLeftRegular (a * b)) : IsLeftRegular b
{E : Type u_1} [AddCommGroup E] [Module ℝ E] {s : Set E} {x : E} (Absorbs : Absorbent ℝ s) : {r : ℝ | 0 < r ∧ x ∈ r • s}.nonempty
{α : Type u} {a b : α} [MulOneClass α] [HasZero α] [Preorder α] [ZeroLt.MulPosStrictMono α] (ha : a < 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1
{R : Type u_1} {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] [IsNoetherian R M] (f : M →ₗ[R] M) (s : Function.Surjective ⇑f) : Function.bijective ⇑f
{n : ℕ} {a b : Fin n} {x : Fin (n + 1)} : ⇑(x.succ_above) a = ⇑(x.succ_above) b ↔ a = b
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {f : E → F} {f' : E →L[𝕜] F} (x : E) {g : F → G} {g' : F →L[𝕜] G} (hg : HasStrictFderivAt g g' (f x)) (hF : HasStrictFderivAt f f' x) : HasStrictFderivAt (λ (x : E), g (f x)) (g'.comp f') x
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] {f : E → F} {c : E} (hD : ∀ᶠ (z : E) in nhds c, DifferentiableAt ℂ f z) (hc : is_is_IsLocalMax (HasNorm.norm ∘ f) c) : ∀ᶠ (y : E) in nhds c, ∥f y∥ = ∥f c∥
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) {r : Nnreal} (h : (λ (n : ℕ), ∥p n∥ * ↑r ^ n) =O[filter.at_Top] λ (n : ℕ), 1) : ↑r ≤ p.radius
{R : Type u} [Ring R] {s : Set R} {p : R → R → Prop} {a b : R} (ha : a ∈ Subring.closure s) (hb : b ∈ Subring.closure s) (Hs : ∀ (x : R), x ∈ s → ∀ (y : R), y ∈ s → p x y) (H0_Left : ∀ (x : R), p 0 x) (H0_Right : ∀ (x : R), p x 0) (H1_Left : ∀ (x : R), p 1 x) (H1_Right : ∀ (x : R), p x 1) (Hneg_Left : ∀ (x y : R), p x y → p (-x) y) (Hneg_Right : ∀ (x y : R), p x y → p x (-y)) (hAdd_Left : ∀ (x₁ x₂ y : R), p x₁ y → p x₂ y → p (x₁ + x₂) y) (hAdd_Right : ∀ (x y₁ y₂ : R), p x y₁ → p x y₂ → p x (y₁ + y₂)) (hMul_Left : ∀ (x₁ x₂ y : R), p x₁ y → p x₂ y → p (x₁ * x₂) y) (hMul_Right : ∀ (x y₁ y₂ : R), p x y₁ → p x y₂ → p x (y₁ * y₂)) : p a b
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} [PartialOrder 𝕜] : HasDerivWithinAt f f' (Set.Iio x) x → HasDerivWithinAt f f' (Set.Iic x) x
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [SemiNormedGroup F'] {c : ℝ} {f : α → E} {g' : α → F'} {l : Filter α} : asymptotics.is_O_with c l f g' → asymptotics.is_O_with c l f (λ (x : α), ∥g' x∥)
{R : Type u} [Ring R] {M : Type v} [AddCommGroup M] [Module R M] [Nontrivial R] {ι : Type w} (b : Basis ι R M) [Infinite ι] {κ : Type w'} (v : κ → M) (i : LinearIndependent R v) (m : i.maximal) : (Cardinal.mk ι).lift ≤ (Cardinal.mk κ).lift
{M : Type u_1} [AddSemigroup M] [TopologicalSpace M] [t2_Space M] (Continuous_Mul_Left : ∀ (r : M), Continuous (λ (_x : M), _x + r)) (s : Set M) (snemp : s.nonempty) (s_IsCompact : is_IsCompact s) (s_Add : ∀ (x : M), x ∈ s → ∀ (y : M), y ∈ s → x + y ∈ s) : ∃ (m : M) (H : m ∈ s), m + m = m
{R : Type u_1} [CommRing R] {S : Submonoid R} {P : Type u_2} [CommRing P] [Algebra R P] : ↑1 = is_localization.coe_Submodule P ⊤
{α : Type v} [LinearOrder α] [TopologicalSpace α] [OrderClosedTopology α] {s : Set α} (hs : IsPreconnected s) (hb : ¬BddBelow s) (ha : ¬BddAbove s) : s = Set.Univ
{α : Type u} [PseudoMetricSpace α] (s : Set α) : LipschitzWith 1 (λ (x : α), metric.inf_dist x s)
{G : Type u_1} [Group G] [Fintype G] : monoid.is_torsion G
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {s : Set E} (hs : Orthonormal 𝕜 Coe) : ∃ (w : Set E) (H : w ⊇ s), Orthonormal 𝕜 Coe ∧ ∀ (u : Set E), u ⊇ w → Orthonormal 𝕜 Coe → u = w
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {x : E} {n : WithTop ℕ} {p : E → FormalMultilinearSeries 𝕜 E F} (h : HasFtaylorSeriesUpToOn n f p s) (hn : 1 ≤ n) (hx : x ∈ s) : HasFderivWithinAt f (⇑(Continuous_multilinear_Curry_Fin1 𝕜 E F) (p x 1)) s x
{α : Type u_2} {ι : Type u_5} [AddCommMonoid α] (t : Finset ι) (f : ι → Set α) (a : α) : a ∈ t.sum (λ (i : ι), f i) ↔ ∃ (g : ι → α) (hg : ∀ {i : ι}, i ∈ t → g i ∈ f i), t.sum (λ (i : ι), g i) = a
{α : Type u} [Infinite α] : Nonempty (Field α)
(n a : ℕ) : Finset.image (λ (_x : ℕ), _x % a) (Finset.ico n (n + a)) = Finset.range a
{n : ℕ} {a b : Fin n} : a ⋖ b → ↑a ⋖ ↑b
{X : Type u} {m₁ m₂ : X → X → X} {e₁ e₂ : X} (h₁ : EckmannHilton.IsUnital m₁ e₁) (h₂ : EckmannHilton.IsUnital m₂ e₂) (Distrib : ∀ (a b c d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) : m₁ = m₂
{G : Type u_1} [Group G] : group.is_nilpotent G ↔ ∃ (n : ℕ), lower_central_series G n = ⊥
{α : Type u} [Group α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a
(T : Type u) [TopologicalSpace T] : Category_theory.pretopology.of_grothendieck (TopologicalSpace.Opens T) (opens.grothendieck_topology T) = Opens.pretopology T
{α : Type u_1} [LinearOrder α] [SuccOrder α] [IsSuccArchimedean α] (r : α → α → Prop) {n m : α} (hr : Reflexive r) (h1 : ∀ (i : α), i ∈ Set.Ico n m → r i (Order.succ i)) (h2 : ∀ (i : α), i ∈ Set.Ico m n → r (Order.succ i) i) : Relation.TransGen r n m
{n : Type u} [DecidableEq n] [Fintype n] {α : Type v} [CommRing α] (A : Matrix n n α) (b : n → α) : A.mul_vec (⇑(A.cramer) b) = A.det • b
{𝕜 : Type u_3} {E : Type u_4} [SemiNormedRing 𝕜] [AddCommGroup E] [Module 𝕜 E] (p : Seminorm 𝕜 E) (r : ℝ) : Balanced 𝕜 (p.ball 0 r)
{α : Type u} [PseudoMetricSpace α] {s t : Set α} : metric.Hausdorff_dist (Closure s) (Closure t) = metric.Hausdorff_dist s t
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [SemiNormedGroup E'] {c : ℝ} {g : α → F} {f' : α → E'} {l : Filter α} : asymptotics.is_O_with c l (λ (x : α), -f' x) g → asymptotics.is_O_with c l f' g
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : α → β} {s : Set α} : MonotoneOn f s → AntitoneOn (f ∘ ⇑order_dual.of_dual) s
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b
(z : ℂ) : ↑(z.im) = (z - ⇑(StarRing_end ℂ) z) / (2 * Complex.i)
{ι : Type u} (s : Finset ι) (w z : ι → ℝ) (hw : ∀ (i : ι), i ∈ s → 0 ≤ w i) (hw' : s.sum (λ (i : ι), w i) = 1) (hz : ∀ (i : ι), i ∈ s → 0 ≤ z i) : s.prod (λ (i : ι), z i ^ w i) ≤ s.sum (λ (i : ι), w i * z i)
{α : Type u_1} {p : Finset α → Prop} [DecidableEq α] (S : Finset α) (h₁ : p ∅) (h₂ : ∀ {a : α} {s : Finset α}, a ∈ S → s ⊆ S → a ∉ s → p s → p (HasInsert.insert a s)) : p S
{α : Type u} [Preorder α] {a b c : α} : b < c → a = b → a < c
(n : ℕ) (p : ℕ → ℝ) (hp : ∀ (k : ℕ), 0 ≤ p k) {r a : ℝ} (hr : 0 ≤ r) (ha : 0 ≤ a) : (Finset.ico 2 (n + 1)).sum (λ (k : ℕ), a ^ k * {c : Composition k | 1 < c.length}.to_finset.sum (λ (c : Composition k), r ^ c.length * finset.univ.prod (λ (j : Fin c.length), p (c.blocks_fun j)))) ≤ (Finset.ico 2 (n + 1)).sum (λ (j : ℕ), r ^ j * (Finset.ico 1 n).sum (λ (k : ℕ), a ^ k * p k) ^ j)
(l : List ℕ) (n : ℕ) : List.Sorted has_lt.lt (Denumerable.raise' l n)
{J : Type u₁} [CategoryTheory.Category J] {K : Type u₂} [CategoryTheory.Category K] {C : Type u} [CategoryTheory.Category C] {F : J ⥤ C} (e : K ≌ J) [CategoryTheory.Limits.HasLimit (e.functor ⋙ F)] : CategoryTheory.Limits.HasLimit F
{α : Type u} {β : Type v} [Fintype β] (r : α → β → Prop) [Π (a : α), DecidablePred (r a)] : (∀ (A : Finset α), A.card ≤ (Finset.filter (λ (b : β), ∃ (a : α) (H : a ∈ A), r a b) Finset.univ).card) ↔ ∃ (f : α → β), Function.Injective f ∧ ∀ (x : α), r x (f x)
{α : Type u} {f : α → α} {x : α} (hF : Function.IsFixedPt f x) : f x = x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] [CategoryTheory.Limits.HasPullbacks C] {P Q R : C} {f : P ⟶ R} {g : Q ⟶ R} {p : ↥P} {q : ↥Q} : ⇑f p = ⇑g q → (∃ (s : ↥(CategoryTheory.Limits.pullback f g)), ⇑CategoryTheory.Limits.pullback.fst s = p ∧ ⇑CategoryTheory.Limits.pullback.snd s = q)
{α : Type u} {l : List α} : l.sublists.nodup → l.nodup
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (v : M) {r : R} (h : 0 ≤ r) : SameRay R (r • v) v
{α : Type u_1} {β : Type u_2} {M : Type u_5} [CommMonoid M] {f : α → M} {g : β → M} (e : α → β) (hE₀ : Function.bijective e) (hE₁ : ∀ (x : α), f x = g (e x)) : finprod (λ (i : α), f i) = finprod (λ (j : β), g j)
{K : Type u} {V V₁ : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] [AddCommGroup V₁] [Module K V₁] (Cond : Module.rank K V = Module.rank K V₁) : Nonempty (V ≃ₗ[K] V₁)
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : Rˣ) : ∀ᶠ (t : R) in nhds 0, Ring.inverse (↑x + t) = Ring.inverse (1 + ↑x⁻¹ * t) * ↑x⁻¹
{E : Type u_2} [SemiNormedGroup E] [NormedSpace ℝ E] : ConvexOn ℝ Set.Univ HasNorm.norm
 : GoldenRatio⁻¹ = -golden_Conj
{α : Type u_3} {β : Type u_4} [Preorder β] {f : β → Finset α} (h : Monotone f) (h' : ∀ (x : α), ∃ (n : β), x ∈ f n) : Filter.Tendsto f filter.at_Top filter.at_Top
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] (f : ℂ → E) (z w : ℂ) (Hc : ContinuousOn f (Set.Interval z.re w.re ×ℂ Set.Interval z.im w.im)) (hD : DifferentiableOn ℂ f (Set.Ioo (Linear_order.min z.re w.re) (Linear_order.max z.re w.re) ×ℂ Set.Ioo (Linear_order.min z.im w.im) (Linear_order.max z.im w.im))) : (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(z.im) * Complex.i)) - ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(w.im) * Complex.i)) + Complex.i • ∫ (y : ℝ) in z.im..w.im, f (↑(w.re) + ↑y * Complex.i)) - Complex.i • ∫ (y : ℝ) in z.im..w.im, f (↑(z.re) + ↑y * Complex.i) = 0
{α : Type u_1} {β : Type u_2} [LinearOrder α] {a b : α} {h : a ≤ b} [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] {f : ↥(Set.Icc a b) → β} (hF : Continuous f) : Continuous (Set.Icc_extend h f)
{α : Type u_1} [ConditionallyCompleteLattice α] {s : Set α} {a : α} (H : IsLeast s a) : HasInf.inf s = a
{R : Type u_1} {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] [IsNoetherian R M] (f : M →ₗ[R] M) (s : Function.Surjective ⇑f) : Function.Injective ⇑f
{R : Type u} {M : Type v} [CommRing R] [Nontrivial R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] (f : M →ₗ[R] M) {ι : Type w} [Fintype ι] (b : Basis ι R M) : (⇑(Linear_map.to_Matrix b b) f).charpoly = f.charpoly
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {f : R →+* S} {s : S} (n : ℕ) (h : s ∈ Set.Range ⇑f) : ⇑(Polynomial.monomial n) s ∈ Polynomial.lifts f
{G₀ : Type u_2} [GroupWithZero G₀] (a : G₀) : a * a / a = a
{𝕜 : Type u_1} {E : Type u_3} [NormedField 𝕜] [AddCommGroup E] [Module 𝕜 E] {A : Set E} [TopologicalSpace E] [HasContinuousSmul 𝕜 E] (hA : Balanced 𝕜 A) (h : 0 ∈ Interior A) : Balanced 𝕜 (Interior A)
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ - 2 * HasInner.inner x y + ∥y∥ * ∥y∥
{M : Type u_3} [AddMonoid M] [Inhabited M] (l : List M) (h : l ≠ List.nil) : l.head + l.tail.sum = l.sum
{p k : ℕ} (hp : Nat.Prime p) : (p ^ k).factorization = Finsupp.single p k
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {t₁ t₂ : Affine.Triangle ℝ P} {i₁ i₂ i₃ j₁ j₂ j₃ : Fin 3} (hi₁₂ : i₁ ≠ i₂) (hi₁₃ : i₁ ≠ i₃) (hi₂₃ : i₂ ≠ i₃) (hj₁₂ : j₁ ≠ j₂) (hj₁₃ : j₁ ≠ j₃) (hj₂₃ : j₂ ≠ j₃) (h₁ : t₂.points j₁ = t₁.orthocenter) (h₂ : t₂.points j₂ = t₁.points i₂) (h₃ : t₂.points j₃ = t₁.points i₃) : t₂.orthocenter = t₁.points i₁
{ι : Type u} {f g : ι → Nnreal} {p : ℝ} (hp : 1 ≤ p) (hF : Summable (λ (i : ι), f i ^ p)) (hg : Summable (λ (i : ι), g i ^ p)) : Summable (λ (i : ι), (f i + g i) ^ p) ∧ (∑' (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤ (∑' (i : ι), f i ^ p) ^ (1 / p) + (∑' (i : ι), g i ^ p) ^ (1 / p)
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι} {g : ι → α} [TopologicalSpace α] (h : ContinuousAt f x) (hg : Filter.Tendsto g p (nhds x)) (hunif : ∀ (u : Set (β × β)), u ∈ Uniformity β → (∃ (t : Set α) (H : t ∈ nhds x), ∀ᶠ (n : ι) in p, ∀ (y : α), y ∈ t → (f y, F n y) ∈ u)) : Filter.Tendsto (λ (n : ι), F n (g n)) p (nhds (f x))
{R : Type u_1} {M : Type u_3} {a b : R} [CommSemigroup R] [HasScalar R M] [IsScalarTower R R M] : IsSmulRegular M (a * b) ↔ IsSmulRegular M a ∧ IsSmulRegular M b
{α : Type u_1} [Monoid α] {p q : α} (hp : Irreducible p) (hq : Irreducible q) : p ∣ q → q ∣ p
{R : Type u_1} {S : Type u_2} [CommRing R] [Nontrivial R] [CommRing S] [is_IsDomain S] [Algebra R S] (H : Algebra.IsIntegral R S) (hRS : Function.Injective ⇑(Algebra_Map R S)) (hS : IsField S) : IsField R
{α : Type u_1} {ι : Type u_4} [CompleteLattice α] (s : ι → α) : (⨅ (i : ι), s i) = ⨅ (t : Finset ι) (i : ι) (H : i ∈ t), s i
{R : Type u} [Ring R] (s : Subring R) {x y : R} (hx : x ∈ s) (hy : y ∈ s) : x - y ∈ s
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [HasScalar 𝕜 E] {S T : ConvexCone 𝕜 E} (h : ∀ (x : E), x ∈ S ↔ x ∈ T) : S = T
{p n k : ℕ} (p_Large : n < p ^ 2) : ⇑((n.choose k).factorization) p ≤ 1
{R : Type u} [Ring R] {L M N : Module R} (f : L ⟶ M) [CategoryTheory.Limits.HasImage f] (g : ↑(Category_theory.limits.image_Subobject f) ⟶ N) [CategoryTheory.Limits.HasCokernel g] {x y : ↥N} (l : ↥L) (w : x = y + ⇑g (⇑(Category_theory.limits.factor_thru_image_Subobject f) l)) : ⇑(CategoryTheory.Limits.cokernelπ g) x = ⇑(CategoryTheory.Limits.cokernelπ g) y
{α : Type u} [PseudoEmetricSpace α] (f : ℕ → α) (n : ℕ) : HasEdist.edist (f 0) (f n) ≤ (Finset.range n).sum (λ (i : ℕ), HasEdist.edist (f i) (f (i + 1)))
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {n : WithTop ℕ} {s : Set E} {f g : E → F} (hF : ContDiffWithinAt 𝕜 n f s x) (hg : ContDiffWithinAt 𝕜 n g s x) : ContDiffWithinAt 𝕜 n (λ (x : E), f x - g x) s x
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (h_Int : Algebra.IsIntegral K L) : t2_Space (L ≃ₐ[K] L)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [SemiNormedGroup E] [SemiNormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [RingHomIsometric σ₁₂] (f : E →ₛₗ[σ₁₂] F) (hF : Continuous ⇑f) : ∃ (C : ℝ), 0 < C ∧ ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (e : LocalHomeomorph α β) (h : e.to_local_equiv.source = Set.Univ) : OpenEmbedding ⇑e
 : ∃ (α β : Type) (Iα : TopologicalSpace α) (Iβ : TopologicalSpace β), CompactSpace α ∧ t1_Space β ∧ ∃ (f : α ≃ β), Continuous ⇑f ∧ ¬Continuous ⇑(f.symm)
{G : Type u_1} {H : Type u_2} [Group G] [Group H] {f : G →* H} (hF : Function.Surjective ⇑f) (tG : monoid.is_torsion G) : monoid.is_torsion H
{G : Type u_1} {H : Type u_2} [AddGroup G] [AddGroup H] {f : G →+ H} (hF : Function.Surjective ⇑f) (tG : Add_monoid.is_torsion G) : Add_monoid.is_torsion H
{α : Type u} [Group α] [Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)] (h : Fintype.card α = p) : IsCyclic α
{M : Type u_1} [AddZeroClass M] {S T : AddSubmonoid M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T
{α : Type u} [TopologicalSpace α] {S U : Set α} (hS : IsPreirreducible S) (hU : is_IsOpen U) (h : (S ∩ U).nonempty) : S ⊆ Closure (S ∩ U)
{l : Type u_1} {m : Type u_2} {α : Type v} [HasZero α] [DecidableEq m] [DecidableEq l] (d : m → α) (e : l → m) (hE : Function.Injective e) : (Matrix.diagonal d).minor e e = Matrix.diagonal (d ∘ e)
{M₀ : Type u_1} [CancelMonoidWithZero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : a * b = a) : a = 0
{a b : Cardinal} (ha : Cardinal.aleph_0 ≤ a) (hb : Cardinal.aleph_0 ≤ b) : a * b = Linear_order.max a b
{E : Type u_1} {β : Type u_2} [AddCommGroup E] [TopologicalSpace E] [Module ℝ E] [TopologicalAddGroup E] [HasContinuousSmul ℝ E] [OrderedAddCommGroup β] [Module ℝ β] [OrderedSmul ℝ β] {f : E → β} {a : E} (h_is_IsLocalMax : is_is_IsLocalMax f a) (h_conc : ConcaveOn ℝ Set.Univ f) (x : E) : f x ≤ f a
(s : ℝ) {b : ℝ} (hb : 0 < b) : (λ (x : ℝ), x ^ s) =o[filter.at_Top] λ (x : ℝ), Real.exp (b * x)
{C : Type u} [CategoryTheory.Category C] {X Y : C} (f : X ⟶ Y) [CategoryTheory.Limits.HasImage f] : (Category_theory.limits.image.mono_factorisation f).e = Category_theory.limits.factor_thru_image f
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] : ⊥.fixing_Subgroup = ⊤
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {F G : C ⥤ D} (h_obj : ∀ (X : C), F.obj X = G.obj X) (h_Map : ∀ (X Y : C) (f : X ⟶ Y), F.map f == G.map f) : F = G
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] [NormalSpace Y] (f : BoundedContinuousFunction X ℝ) {t : Set ℝ} {e : X → Y} [hs : t.ord_connected] (hF : ∀ (x : X), ⇑f x ∈ t) (hne : t.nonempty) (hE : ClosedEmbedding e) : ∃ (g : BoundedContinuousFunction Y ℝ), (∀ (y : Y), ⇑g y ∈ t) ∧ ⇑g ∘ e = ⇑f
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q R : C} (f : P ⟶ Q) (g : Q ⟶ R) : ⇑g ∘ ⇑f = ⇑(f ≫ g)
{R : Type u₁} [CommRing R] (a b : R) : (a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2
{ι : Type u_1} {X : ι → Type u_2} [Π (i : ι), TopologicalSpace (X i)] {as bs cs : Π (i : ι), X i} (γ₀ : Π (i : ι), Path.Homotopic.Quotient (as i) (bs i)) (γ₁ : Π (i : ι), Path.Homotopic.Quotient (bs i) (cs i)) : (Path.Homotopic.pi γ₀).comp (Path.Homotopic.pi γ₁) = Path.Homotopic.pi (λ (i : ι), (γ₀ i).comp (γ₁ i))
{p : ℕ} {G : Type u_1} [Group G] (hG : is_p_Group p G) [hp : Fact (Nat.Prime p)] (α : Type u_2) [MulAction G α] [Fintype α] [Fintype ↥(MulAction.FixedPoints G α)] (hpα : ¬p ∣ Fintype.card α) : (MulAction.FixedPoints G α).nonempty
{𝕜 : Type u_1} {E : Type u_2} [OrderedRing 𝕜] [AddCommGroup E] [Module 𝕜 E] (Q : AffineSubspace 𝕜 E) : Convex 𝕜 ↑Q
{R : Type u_1} [CommRing R] (M : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization M S] (a : S) : ∃ (b : ↥M), IsLocalization.IsInteger R (↑b • a)
{a b c : ℕ} (h : a % c = b % c) : (a - b) % c = 0
 : Fact (FiniteDimensional.finrank ℝ ℂ = 2)
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (E : IntermediateField K L) [FiniteDimensional K ↥E] : is_IsOpen ↑(E.fixing_Subgroup)
{M : Type u_1} [AddCommMonoid M] (f : ℕ → ℕ → M) (n : ℕ) : (Finset.Nat.antidiagonal n).sum (λ (ij : ℕ × ℕ), f ij.fst ij.snd) = (Finset.range n.succ).sum (λ (k : ℕ), f k (n - k))
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] [Nonempty V] (k : ℕ) (h : ∀ (v : V), k ≤ G.degree v) : k ≤ G.min_degree
{J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ AddMon) [CategoryTheory.IsFiltered J] {x y y' : Σ (j : J), ↥(F.obj j)} (hyy' : CategoryTheory.Limits.Types.FilteredColimit.Rel (F ⋙ CategoryTheory.forget AddMon) y y') : AddMon.filtered_colimits.colimit_Add_aux F x y = AddMon.filtered_colimits.colimit_Add_aux F x y'
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] (f : ℂ → E) (z w : ℂ) (H : DifferentiableOn ℂ f (Set.Interval z.re w.re ×ℂ Set.Interval z.im w.im)) : (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(z.im) * Complex.i)) - ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(w.im) * Complex.i)) + Complex.i • ∫ (y : ℝ) in z.im..w.im, f (↑(w.re) + ↑y * Complex.i)) - Complex.i • ∫ (y : ℝ) in z.im..w.im, f (↑(z.re) + ↑y * Complex.i) = 0
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q R : C} (f : P ⟶ Q) (g : Q ⟶ R) (a : ↥P) : ⇑(f ≫ g) a = ⇑g (⇑f a)
{n : ℕ} {α : Type u_1} {v w : Vector α n} (h : ∀ (m : Fin n), v.nth m = w.nth m) : v = w
{R : Type u} [Field R] [StarRing R] (x y : R) : HasStar.star (x / y) = HasStar.star x / HasStar.star y
{G : Type u} [AddMonoid G] {H : Type v} [AddMonoid H] (f : G →+ H) {x : G} (h : IsOfFinAddOrder x) : IsOfFinAddOrder (⇑f x)
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (s : Finset ι) : Finset.centroid_weights_indicator k s = ↑s.indicator (Finset.centroid_weights k s)
{α : Type u_1} [CompleteLattice α] {a : α} {s : Set α} : a ⊔ HasInf.inf s ≤ ⨅ (b : α) (H : b ∈ s), a ⊔ b
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : ℝ} {c w : ℂ} {f : ℂ → E} (hD : DifferentiableOn ℂ f (Metric.ClosedBall c R)) (hw : w ∈ Metric.Ball c R) : ∮ (z : ℂ) in C(c, R), (z - w)⁻¹ • f z = (2 * ↑Real.pi * Complex.i) • f w
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.ConcreteCategory.forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.ConcreteCategory.forget C)] {X : Top} (F : Top.Sheaf C X) {ι : Type v} (U : ι → TopologicalSpace.Opens ↥X) (sf : Π (i : ι), ↥(F.val.obj (Opposite.op (U i)))) (h : F.val.is_compatible U sf) : ∃! (s : ↥(F.val.obj (Opposite.op (supr U)))), F.val.is_gluing U sf s
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {f : β → γ} {x : α} {y : β} (hF : ContinuousAt f y) : ContinuousAt (λ (x : α × β), f x.snd) (x, y)
{α : Type u_1} {l : Filter α} {p : α → Prop} : (∀ᶠ (s : Set α) in l.small_sets, ∀ (x : α), x ∈ s → p x) → (∀ᶠ (x : α) in l, p x)
{k : Type u_1} {V : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {p : ι → P} (hi : AffineIndependent k p) {s : Finset ι} {sm : Submodule k V} [FiniteDimensional k ↥sm] (hle : Vector_Span k ↑(Finset.image p s) ≤ sm) (hc : s.card = FiniteDimensional.finrank k ↥sm + 1) : Vector_Span k ↑(Finset.image p s) = sm
{α : Type u} [PseudoMetricSpace α] {s : Set α} : Metric.Bounded s ↔ Emetric.diam s ≠ ⊤
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} {x : E} : MdifferentiableAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f x ↔ DifferentiableAt 𝕜 f x
{α : Type u_1} {l l' : List α} (f : ℕ ↪o ℕ) (hF : ∀ (ix : ℕ), l.nth ix = l'.nth (⇑f ix)) : l <+ l'
{X : Type u_1} [TopologicalSpace X] [CompactSpace X] (A : Subalgebra ℝ C(X, ℝ)) (w : A.separates_points) : A.topological_Closure = ⊤
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x z - o.oangle x y = o.oangle y z
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] : affine_Span k Set.Univ = ⊤
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜} (hF : ConvexOn 𝕜 s f) {x y z : 𝕜} (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) : (f y - f x) / (y - x) ≤ (f z - f y) / (z - y)
(a b : ℝ) : (Polynomial_Functions (Set.Icc a b)).topological_Closure = ⊤
(a b : ℝ) (f : C(↥(Set.Icc a b), ℝ)) : f ∈ (Polynomial_Functions (Set.Icc a b)).topological_Closure
{R : Type u_1} {E : Type u_2} [LinearOrderedField R] [AddCommGroup E] [Module R E] {ι : Type u_3} (b : AffineBasis ι R E) : ⇑(Convex_hull R) (Set.Range b.points) = {x : E | ∀ (i : ι), 0 ≤ ⇑(b.coord i) x}
{α : Type u} {p : α → Prop} {a : α} (h : a ∈ {x : α | p x}) : p a
{n : ℕ} {α : Fin (n + 1) → Type u} (q : Π (i : Fin (n + 1)), α i) (z : α 0) : fin.tail (Function.update q 0 z) = fin.tail q
{α : Type u_1} [DecidableEq α] : Monotone Finset.shadow
(R : Type u_1) (A : Type u_2) [CommSemiring R] : pi.const_RingHom A R = Algebra_Map R (A → R)
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R : CategoryTheory.Presieve X} : CategoryTheory.Presieve.IsSheafFor P R → CategoryTheory.Presieve.IsSeparatedFor P R
{G : Type u_6} {H : Type u_7} {F : Type u_8} [AddGroup G] [SubtractionMonoid H] [AddMonoidHomClass F G H] (f : F) (n : ℤ) (g : G) : ⇑f (n • g) = n • ⇑f g
(n : ℕ) : ↑(n.totient) = ↑n * n.factors.to_finset.prod (λ (p : ℕ), 1 - (↑p)⁻¹)
{E : Type u_1} [AddCommGroup E] [Module ℝ E] (p : Seminorm ℝ E) : gauge (p.ball 0 1) = ⇑p
{F : Type u_3} [InnerProductSpace ℝ F] {x : F} {r : ℝ} (hx : x ≠ 0) (hr : r < 0) : HasInner.inner x (r • x) / (∥x∥ * ∥r • x∥) = -1
{R : Type u_1} {α : Type u_2} (G : SimpleGraph α) [HasZero R] [has_One R] [DecidableEq α] [DecidableRel G.adj] {a : α} {e : Sym2 α} : simple_graph.inc_Matrix R G a e = Ite (e ∈ G.incidence_Set a) 1 0
{m : Type u} {n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) (B : Matrix n m α) [Invertible A] : (⅟ A).mul (A.mul B) = B
(p : ℕ) [hp : Fact (Nat.Prime p)] {q : ℚ} (h : padic_norm p q = 0) : q = 0
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) : o.oangle (-x) (-y) = o.oangle x y
{α : Type u} [Preorder α] [NoMaxOrder α] (a : α) : ∃ (f : ℕ → α), StrictMono f ∧ f 0 = a
{α : Type u_1} [ConditionallyCompleteLattice α] {s : Set α} {b : α} (hs : s.nonempty) (H : ∀ (a : α), a ∈ s → a ≤ b) (H' : ∀ (w : α), w < b → (∃ (a : α) (H : a ∈ s), w < a)) : HasSup.sup s = b
(p : Polynomial ℚ) : (p.root_Set ℂ).to_finset.card = (p.root_Set ℝ).to_finset.card + (⇑(polynomial.gal.gal_action_hom p ℂ) (⇑(Polynomial.Gal.restrict p ℂ) (alg_equiv.restrict_scalars ℚ complex.conj_ae))).support.card
(z : UpperHalfPlane) : Filter.Tendsto (λ (p : Fin 2 → ℤ), ⇑complex.norm_sq (↑(p 0) * ↑z + ↑(p 1))) Filter.cofinite filter.at_Top
{p : ℕ} [hp : Fact (Nat.Prime p)] : WittVector.IsPoly p (λ (R : Type u_1) (_Rcr : CommRing R), ⇑WittVector.verschiebung)
{ι : Type u} {X : Type v} [TopologicalSpace X] {s : Set X} [NormalSpace X] [ParacompactSpace X] (hs : is_IsClosed s) (U : ι → Set X) (ho : ∀ (i : ι), is_IsOpen (U i)) (hU : s ⊆ ⋃ (i : ι), U i) : ∃ (f : BumpCovering ι X s), f.is_subordinate U
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasPullbacks C] {X Y : C} (g : Y ⟶ X) [CategoryTheory.Mono g] (f₁ f₂ : CategoryTheory.Subobject Y) : (CategoryTheory.Subobject.map g).obj (f₁ ⊓ f₂) = (CategoryTheory.Subobject.map g).obj f₁ ⊓ (CategoryTheory.Subobject.map g).obj f₂
{J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ AddMon) [CategoryTheory.IsFiltered J] (j : J) : 0 = AddMon.FilteredColimits.M.mk F ⟨j, 0⟩
{α : Type u} [PseudoMetricSpace α] {s : Set α} {x : α} (h : is_IsClosed s) (hs : s.nonempty) : x ∈ s ↔ metric.inf_dist x s = 0
{𝕜 : Type u_1} {X : Type u_2} [is_R_or_C 𝕜] [TopologicalSpace X] {A : Subalgebra 𝕜 C(X, 𝕜)} (hA : A.separates_points) (hA' : ContinuousMap.ConjInvariantSubalgebra (subalgebra.restrict_scalars ℝ A)) : ((subalgebra.restrict_scalars ℝ A).comap' (alg_hom.comp_Left_Continuous ℝ is_R_or_C.of_Real_am is_R_or_C.continuous_of_Real)).separates_points
{X : Type u} {Y : Type v} [MetricSpace X] [MetricSpace Y] : Isometry Sum.inl
(s b : ℝ) (hb : 0 < b) : Filter.Tendsto (λ (x : ℝ), x ^ s * Real.exp (-b * x)) filter.at_Top (nhds 0)
{α : Type u} [PseudoMetricSpace α] {s : Set α} [ProperSpace α] (h : Metric.Bounded s) : is_IsCompact (Closure s)
{𝕜 : Type u_1} [NormedField 𝕜] [CompleteSpace 𝕜] {r : 𝕜} (hr : ∥r∥ < 1) : HasSum (λ (n : ℕ), ↑n * r ^ n) (r / (1 - r) ^ 2)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) : ⇑is_R_or_C.re (HasInner.inner x y) = (∥x + y∥ * ∥x + y∥ - ∥x - y∥ * ∥x - y∥) / 4
{α : Type u} [PartialOrder α] {a b : α} (hab : a ≤ b) (hba : ¬a < b) : a = b
{α : Type u} {β : Type v} {s : Set α} {f : α → β} : Set.InjOn f s → Function.Injective (s.restrict f)
{α : Type u} {β : Type v} [Preorder α] [LinearOrder β] {f g : α → β} (hF : Monotone f) (hg : Monotone g) : Monotone (λ (x : α), Linear_order.max (f x) (g x))
{A : Type u_1} {B : Type u_2} [i : SetLike A B] {p q : A} (h : ∀ (x : B), x ∈ p ↔ x ∈ q) : p = q
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) : 2 • o.oangle (-x) x = 0
{R : Type u} [Semiring R] {S : Type v} [Semiring S] (f : R →+* S) : Polynomial.x ∈ Polynomial.lifts f
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [LinearOrderedField 𝕜] [AddCommGroup E] [LinearOrderedAddCommGroup β] [Module 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f : E → β} (hF : ConvexOn 𝕜 (⇑(Convex_hull 𝕜) s) f) {x : E} (hx : x ∈ ⇑(Convex_hull 𝕜) s) : ∃ (y : E) (H : y ∈ s), f x ≤ f y
{α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] {f : Filter β} {u : β → α} {a : α} [f.ne_IsBot] (h : Filter.Tendsto u f (nhds a)) : f.limsup u = a
{R : Type u_1} [Semiring R] {Q : LaurentPolynomial R → Prop} (f : LaurentPolynomial R) (is_qf : ∀ {f : Polynomial R} {n : ℕ}, Q (⇑polynomial.to_laurent f * LaurentPolynomial.t (-↑n))) : Q f
{α : Type u} [PseudoMetricSpace α] {x : α} {r : ℝ} (h : 0 ≤ r) : Metric.diam (Metric.ClosedBall x r) ≤ 2 * r
(α : Type u_1) (β : Type u_2) [LinearOrder α] [LinearOrder β] [Encodable α] [DenselyOrdered α] [NoMinOrder α] [NoMaxOrder α] [Nonempty α] [Encodable β] [DenselyOrdered β] [NoMinOrder β] [NoMaxOrder β] [Nonempty β] : Nonempty (α ≃o β)
{α : Type u_2} {β : Type u_3} {rα : NonAssocSemiring α} {rβ : NonAssocSemiring β} (f : α →+* β) (a : α) : ⇑f (bit1 a) = bit1 (⇑f a)
{α : Type u_1} {f g : Poly α} : (∀ (x : α → ℕ), ⇑f x = ⇑g x) → f = g
{α : Type u_2} {β : Type u_3} [NonAssocRing α] [NonAssocRing β] (f : α →+* β) (x y : α) : ⇑f (x - y) = ⇑f x - ⇑f y
{R : Type u} {ι : Type v} {M₁ : ι → Type w₁} {M₂ : Type w₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [Π (i : ι), Module R (M₁ i)] [Module R M₂] [Π (i : ι), TopologicalSpace (M₁ i)] [TopologicalSpace M₂] (f : ContinuousMultilinearMap R M₁ M₂) {α : ι → Type u_1} [Fintype ι] (g : Π (i : ι), α i → M₁ i) (A : Π (i : ι), Finset (α i)) : ⇑f (λ (i : ι), (A i).sum (λ (j : α i), g i j)) = (fintype.pi_Finset A).sum (λ (r : Π (a : ι), α a), ⇑f (λ (i : ι), g i (r i)))
{α : Type u_1} (f : α → α → α) [IsAssociative α f] (x y : α) : ((λ (z : α), f z x) ∘ λ (z : α), f z y) = λ (z : α), f z (f y x)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X Y : C} (f g : X ⟶ Y) [CategoryTheory.Limits.HasKernel (f - g)] : CategoryTheory.Limits.HasEqualizer f g
{X : Type u_1} [TopologicalSpace X] {s : Set X} (h : ∀ (x : ℕ → X) (a : X), (∀ (n : ℕ), x n ∈ s) → Filter.Tendsto x filter.at_Top (nhds a) → a ∈ s) : IsSeqClosed s
{m n : ℕ} : m ∣ m + n ↔ m ∣ n
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {β : Type u_4} [LinearOrderedField 𝕜] [AddCommGroup E] [AddCommGroup F] [OrderedAddCommMonoid β] [Module 𝕜 E] [Module 𝕜 F] [HasScalar 𝕜 β] {f : F → β} (g : E →ᵃ[𝕜] F) {s : Set F} (hF : ConvexOn 𝕜 s f) : ConvexOn 𝕜 (⇑g ⁻¹' s) (f ∘ ⇑g)
{α : Type u_1} {β : Type u_2} {α₂ : Type u_3} [Semiring β] [HasZero α] [HasZero α₂] {F : Type u_4} [ZeroHomClass F α α₂] (f : F) : finsupp.map_IsDomain ⇑f 1 = 1
{C : Type u} [CategoryTheory.Category C] {D : Type u_1} [CategoryTheory.Category D] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasEqualizers C] [CategoryTheory.Limits.HasImages C] [CategoryTheory.HasProjectiveResolutions C] [CategoryTheory.Preadditive D] [CategoryTheory.Limits.HasZeroObject D] [CategoryTheory.Limits.HasEqualizers D] [CategoryTheory.Limits.HasCokernels D] [CategoryTheory.Limits.HasImages D] [CategoryTheory.Limits.HasImageMaps D] {F G : C ⥤ D} [F.additive] [G.additive] (α : F ⟶ G) (n : ℕ) {X : C} (P : CategoryTheory.ProjectiveResolution X) : (Category_theory.nat_trans.left_derived α n).app X = (F.left_derived_obj_iso n P).hom ≫ (homology_Functor D (ComplexShape.down ℕ) n).map ((Category_theory.nat_trans.map_HomologicalComplex α (ComplexShape.down ℕ)).app P.complex) ≫ (G.left_derived_obj_iso n P).inv
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) : InnerProductGeometry.angle x y ≤ Real.pi
{α : Type u_1} [DecidableEq α] [Fintype α] {𝒜 : Finset (Finset α)} {r : ℕ} (h𝒜 : Set.Sized r ↑𝒜) : Set.Sized (r + 1) ↑(𝒜.up_shadow)
{H : Type u} {M : Type u_2} [TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M] (G : StructureGroupoid H) [HasGroupoid M G] {e : LocalHomeomorph M H} (hE : e ∈ ChartedSpace.Atlas H M) : e ∈ StructureGroupoid.MaximalAtlas M G
{R : Type u_1} {a b : R} [Monoid R] (h : b * a = 1) : IsLeftRegular a
{K : Type v} [Field K] {P : Polynomial K} (hmo : P.monic) (hP : Polynomial.Splits (RingHom.id K) P) : P.coeff 0 = (-1) ^ P.nat_degree * P.roots.prod
{R : Type u} (L : Type v) [CommRing R] [LieRing L] [LieAlgebra R L] (M₁ : Type w₁) (M₂ : Type w₂) (M₃ : Type w₃) [AddCommGroup M₁] [Module R M₁] [LieRingModule L M₁] [LieModule R L M₁] [AddCommGroup M₂] [Module R M₂] [LieRingModule L M₂] [LieModule R L M₂] [AddCommGroup M₃] [Module R M₃] [LieRingModule L M₃] [LieModule R L M₃] (g : TensorProduct R M₁ M₂ →ₗ⁅R,L⁆ M₃) (χ₁ χ₂ : L → R) : (↑g.comp (tensor_product.map_incl (lie_module.pre_weight_Space M₁ χ₁) (lie_module.pre_weight_Space M₂ χ₂))).range ≤ lie_module.pre_weight_Space M₃ (χ₁ + χ₂)
(p : ℕ) [Fact (Nat.Prime p)] : ↑((p - 1).factorial) = -1
{α : Type u} {β : Type v} [Preorder β] {f : α → β} {s : Set α} {a : α} : IsMinOn (⇑order_dual.to_dual ∘ f) s a → IsMaxOn f s a
{α : Type u_1} [NormedDivisionRing α] {a : α} (ha : a ≠ 0) : Filter.Tendsto (λ (x : α), x * a) (Filter.comap HasNorm.norm filter.at_Top) (Filter.comap HasNorm.norm filter.at_Top)
{R : Type u_1} {a : R} [Monoid R] (ua : IsUnit a) : IsRegular a
{a : ℝ} {l : Filter ℝ} {f g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in nhds_within a (Set.Univ  {a}), DifferentiableAt ℝ f x) (hg' : ∀ᶠ (x : ℝ) in nhds_within a (Set.Univ  {a}), deriv g x ≠ 0) (hfa : Filter.Tendsto f (nhds_within a (Set.Univ  {a})) (nhds 0)) (hga : Filter.Tendsto g (nhds_within a (Set.Univ  {a})) (nhds 0)) (hDiv : Filter.Tendsto (λ (x : ℝ), deriv f x / deriv g x) (nhds_within a (Set.Univ  {a})) l) : Filter.Tendsto (λ (x : ℝ), f x / g x) (nhds_within a (Set.Univ  {a})) l
{M : Type u_1} [AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [AddCommMonoid N] (f : S.localization_Map N) (z : N) : f.mk' (f.sec z).fst (f.sec z).snd = z
{α : Type u_1} {β : Type u_2} [LinearOrder α] [PredOrder α] [Preorder β] {f : α → β} (hF : Antitone f) : Pairwise (Disjoint on λ (n : α), Set.Ioc (f n) (f (Order.pred n)))
{ι : Type u} {β : ι → Type v} [dec : DecidableEq ι] [Π (i : ι), HasZero (β i)] (i j : ι) (xi : β i) (xj : β j) : Dfinsupp.single i xi = Dfinsupp.single j xj ↔ i = j ∧ xi == xj ∨ xi = 0 ∧ xj = 0
{α : Type u_1} {β : Type u_2} [Semigroup α] [CommSemigroup β] {f g : α → β} (hF : IsMulHom f) (hg : IsMulHom g) : IsMulHom (λ (a : α), f a * g a)
{α : Type u_1} {β : Type u_2} [UniformSpace β] {f : α → β} {s : Set α} [TopologicalSpace α] (L : ∀ (u : Set (β × β)), u ∈ Uniformity β → (∃ (F : α → β), ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u)) : ContinuousOn f s
{X : Type u_2} {Y : Type u_3} [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace.PseudoMetrizableSpace Y] {f : X → Y} (hF : Inducing f) : TopologicalSpace.PseudoMetrizableSpace X
 : Function.RightInverse Coe ⇑cardinal.to_Nat
{R : Type u_1} [CommRing R] {a b : Quaternion R} (h : Commute a b) : Commute (⇑Quaternion.conj a) (⇑Quaternion.conj b)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (X Y : C) [CategoryTheory.Limits.HasBinaryBiproduct X Y] {b : CategoryTheory.Limits.BinaryBicone X Y} (hb : b.is_bilimit) : (hb.is_limit.cone_point_Unique_Up_to_iso (Category_theory.limits.binary_biproduct.is_Limit X Y)).hom = CategoryTheory.Limits.biprod.lift b.fst b.snd
{M : Type u_1} {N : Type u_2} [AddZeroClass M] [AddZeroClass N] (h : M ≃+ N) : ⇑h 0 = 0
{R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] [Semiring R₂] [AddCommMonoid M₂] [Module R₂ M₂] {σ₁₂ : R →+* R₂} {ι : Type u_3} {v : ι → M} {f g : M →ₛₗ[σ₁₂] M₂} (hv : Submodule.span R (Set.Range v) = ⊤) (h : ∀ (i : ι), ⇑f (v i) = ⇑g (v i)) : f = g
{G : Type u_1} [Group G] [hN : Nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G
{α : Type u_1} [HasLt α] {a b : α} {o : Ordering} : o.swap.compares a b → o.compares b a
{α : Type u_1} : Sym2.map (λ (x : α), x) = Id
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {x y : E} (hxy : x ≠ y) : ∃ (f : E →L[ℝ] ℝ), ⇑f x < ⇑f y
{a : Ennreal} (h : a < ⊤) : AddLeCancellable a
{x y : SimplexCategory} {f : x ⟶ y} : CategoryTheory.Epi f → y.len ≤ x.len
{R : Type u_1} [MulZeroClass R] : IsLeftRegular 0 ↔ Subsingleton R
{α : Type u_1} [LinearOrder α] {r s : α} : {r}.to_colex ≤ {s}.to_colex ↔ r ≤ s
{α : Type u} {β : Type v} [AddGroup α] [AddGroup β] {f : α → β} (hF : IsAddGroupHom f) (a : α) : f (-a) = -f a
{α : Type u} {s : Set α} (hc : s.countable) (hs : s.nonempty) : ∃ (f : ℕ → α), s = Set.Range f
{α : Type u_1} (o : Part α) : {Dom := o.dom, get := λ (h : o.dom), o.get h} = o
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {f' f₁' : E →L[𝕜] F} {x : E} {s : Set E} (H : UniqueDiffWithinAt 𝕜 s x) (hF : HasFderivWithinAt f f' s x) (hg : HasFderivWithinAt f f₁' s x) : f' = f₁'
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : ℕ} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : ⇑fin.cast_Succ j < i) : X.δ i.succ ≫ X.σ (⇑fin.cast_Succ j) = X.σ j ≫ X.δ i
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] {u v : E} (hvm : v ∈ K) (hvo : ∀ (w : E), w ∈ K → HasInner.inner (u - v) w = 0) : Orthogonal_projection_fn K u = v
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] {f : E → F} {f' : E →L[𝕜] F} {a : E} (hF : HasStrictFderivAt f f' a) (hF' : f'.range = ⊤) (hker : f'.ker.closed_complemented) : ∀ᶠ (p : F × ↥(f'.ker)) in nhds (f a, 0), f (has_strict_fderiv_at.implicit_Function_of_complemented f f' hF hF' hker p.fst p.snd) = p.fst
{k : Type u_1} {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {n : ℕ} (s : Affine.Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ℕ} (h : fs.card = m + 1) : Finset.centroid k Finset.univ (s.face h).points = Finset.centroid k fs s.points
{α : Type u_1} {ι : Type u_3} [Lattice α] [OrderBot α] {s : Finset ι} {f : ι → α} [DecidableEq ι] : s.sup_indep f ↔ ∀ (i : ι), i ∈ s → Disjoint (f i) ((s.erase i).sup f)
(x : ℂ) : HasDerivAt Complex.cos (-Complex.sin x) x
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} {L : Filter 𝕜} : HasDerivAtFilter f f' x L ↔ Filter.Tendsto (slope f x) (L ⊓ Filter.principal {x}ᶜ) (nhds f')
{L : FirstOrder.Language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] {Q : Type u_2} [L.Structure Q] (f : L.hom M N) (g : L.hom N P) (h : L.hom P Q) : (h.comp g).comp f = h.comp (g.comp f)
{E : Type u_2} [SemiNormedGroup E] [NormedSpace ℝ E] {s : Set E} : Metric.Bounded (⇑(Convex_hull ℝ) s) ↔ Metric.Bounded s
{α : Type u_1} [Preorder α] [AddCommSemigroup α] [HasSub α] [HasOrderedSub α] {a b : α} : a + b - a ≤ b
{α : Type u} [Group α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1
 : absolute_value.abs.is_euclidean
{R : Type u} {n : ℕ} {M : Fin n.succ → Type v} {M₂ : Type v₂} [Semiring R] [Π (i : Fin n.succ), AddCommMonoid (M i)] [AddCommMonoid M₂] [Π (i : Fin n.succ), Module R (M i)] [Module R M₂] (f : MultilinearMap R M M₂) (m : Π (i : Fin n), M i.succ) (x y : M 0) : ⇑f (fin.cons (x + y) m) = ⇑f (fin.cons x m) + ⇑f (fin.cons y m)
{α : Type u_1} (G : SimpleGraph α) [Fintype α] [DecidableEq α] [DecidableRel G.adj] {n : ℕ} : G.clique_free n → G.clique_Finset n = ∅
 : RingHom.LocalizationPreserves RingHom.Finite
{α : Type u} {L₁ L₂ : List (α × Bool)} [DecidableEq α] (H : FreeGroup.Red L₁ L₂) : FreeGroup.Red L₂ (FreeGroup.reduce L₁)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p ∈ s) (v : V) : v ∈ s.direction ↔ ∃ (p2 : P) (H : p2 ∈ s), v = p -ᵥ p2
{C : Type u} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w} [CategoryTheory.Category D] [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)] (P : Cᵒᵖ ⥤ D) [∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (J.cover X)ᵒᵖ D] : J.plus_Map (J.to_plus P) = J.to_plus (J.plus_obj P)
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {w : α → M} {b : M} [LinearOrderedCancelAddCommMonoid M] (hF : ∀ (a : α), a ∈ s → f a ∈ t) (hb : t.card • b < s.sum (λ (x : α), w x)) : ∃ (y : β) (H : y ∈ t), b < (Finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x)
{α : Type u} {β : Type v} {m₁ m₂ : α → β} {f : Filter α} (h : m₁ =ᶠ[f] m₂) : Filter.map m₁ f = Filter.map m₂ f
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {f : 𝕜 → F} {s : Set 𝕜} : iterated_fderiv_within 𝕜 n f s = ⇑(Continuous_multilinear_map.pi_Field_Equiv 𝕜 (Fin n) F) ∘ iterated_deriv_within n f s
{G : Type u} [CategoryTheory.Groupoid G] [IsFreeGroupoid G] (T : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))) [Quiver.Arborescence ↥T] {a : G} (p : Quiver.Path (Quiver.root ↥T) a) : is_free_groupoid.spanning_tree.tree_hom T a = is_free_groupoid.spanning_tree.hom_of_Path T p
{α : Type u_1} [LinearOrder α] {A B : Finset α} (h : A ⊂ B) : A.to_colex < B.to_colex
{α : Type u_1} [has_Add α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] {b c : α} (bc : b < c) (a : α) : a + b < a + c
{X : Type u_2} {Y : Type u_3} [EmetricSpace X] [EmetricSpace Y] {K : Nnreal} {f : X → Y} (h : LipschitzWith K f) : dimH (Set.Range f) ≤ dimH Set.Univ
{D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ} (hF : ContinuousOn f D) (hF' : DifferentiableOn ℝ f (Interior D)) {C : ℝ} (hF'_GT : ∀ (x : ℝ), x ∈ Interior D → C < deriv f x) (x : ℝ) (H : x ∈ D) (y : ℝ) (H_1 : y ∈ D) : x < y → C * (y - x) < f y - f x
{α : Type u_1} [AddSemigroup α] (x y : α) : ((λ (_x : α), _x + x) ∘ λ (_x : α), _x + y) = λ (_x : α), _x + (y + x)
{β : Type u} (f : β → Type u) {P : Type u} (s : Π (b : β), P ⟶ f b) (b : β) (x : P) : Category_theory.limits.pi.π f b (CategoryTheory.Limits.Pi.lift s x) = s b x
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [cs : CompleteSpace E] {f : E → F} {f' : E ≃L[𝕜] F} {a : E} (hF : HasStrictFderivAt f ↑f' a) : HasStrictFderivAt (has_strict_fderiv_at.local_Inverse f f' a hF) ↑(f'.symm) (f a)
{α : Type u} [TopologicalSpace α] [t2_Space α] (s : Finset α) : ∃ (f : α → Set α), ↑s.pairwise_Disjoint f ∧ ∀ (x : α), x ∈ s → x ∈ f x ∧ is_IsOpen (f x)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {x₀ : E} (hF : DifferentiableAt 𝕜 f x₀) {s : Set E} (hs : s ∈ nhds x₀) {C : Nnreal} (hlip : LipschitzOnWith C f s) : ∥fderiv 𝕜 f x₀∥ ≤ ↑C
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {x₀ : α} {K : Set β} (hK : is_IsCompact K) {P : α → β → Prop} (hP : ∀ (y : β), y ∈ K → (∀ᶠ (z : α × β) in nhds (x₀, y), P z.fst z.snd)) : ∀ᶠ (x : α) in nhds x₀, ∀ (y : β), y ∈ K → P x y
{α : Type u} {s : Set (Set α)} (hs : Cardinal.mk ↥s ≤ Cardinal.continuum) : Cardinal.mk ↥{t : Set α | MeasurableSpace.GenerateMeasurable s t} ≤ Cardinal.continuum
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {s : Set E} {f : E → F} {n : WithTop ℕ} (g : F →L[𝕜] G) (hF : ContDiffOn 𝕜 n f s) : ContDiffOn 𝕜 n (⇑g ∘ f) s
{G : Type u_1} [TopologicalSpace G] [AddGroup G] [TopologicalAddGroup G] (N : AddSubgroup G) [N.normal] : N.topological_closure.normal
{𝕜 : Type u_1} {α : Type u_2} [LinearOrderedField 𝕜] [DecidableEq α] {k : ℕ} {𝒜 : Finset (Finset α)} [Fintype α] (hk : k ≤ Fintype.card α) (h𝒜 : IsAntichain HasSubset.Subset ↑𝒜) : (Finset.range (k + 1)).sum (λ (r : ℕ), ↑((𝒜.slice (Fintype.card α - r)).card) / ↑((Fintype.card α).choose (Fintype.card α - r))) ≤ ↑((Finset.falling (Fintype.card α - k) 𝒜).card) / ↑((Fintype.card α).choose (Fintype.card α - k))
{η : Type u_1} [Fintype η] {Gs : η → Type u_2} [Π (i : η), Group (Gs i)] (H K : Π (i : η), Subgroup (Gs i)) : ⁅Subgroup.pi Set.Univ H,Subgroup.pi Set.Univ K⁆ = Subgroup.pi Set.Univ (λ (i : η), ⁅H i,K i⁆)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} [CompleteSpace E] (e : E ≃L[𝕜] F) : ContDiffAt 𝕜 n ContinuousLinearMap.inverse ↑e
(n p : ℕ) : (Finset.filter (λ (e : ℕ), p ∣ e + 1) (Finset.range n)).card = n / p
{B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] : IsTrivialTopologicalFiberBundle F Prod.fst
{R : Type u} {S : Type v} [Semiring R] [AddCommMonoid S] (p : Polynomial R) {f : ℕ → R → S} (h : ∀ (n : ℕ), f n 0 = 0) : p.sum f = (Finset.range (p.nat_degree + 1)).sum (λ (a : ℕ), f a (p.coeff a))
{J K : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.SmallCategory K] (F : J × K ⥤ Type v) [CategoryTheory.IsFiltered K] [CategoryTheory.FinCategory J] : Function.Surjective (CategoryTheory.Limits.colimit_Limit_to_Limit_Colimit F)
{α : Type u} [PseudoEmetricSpace α] {s t : Set α} : emetric.Hausdorff_edist (Closure s) t = emetric.Hausdorff_edist s t
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V} (h : ∥x∥ = ∥y∥) : x = y ↔ o.oangle x y = 0
{α : Type u_1} [TopologicalSpace α] {x : α} {γ : Type u_4} [LinearOrderedAddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] [HasContinuousAdd γ] {f g : α → γ} (hF : UpperSemicontinuousAt f x) (hg : UpperSemicontinuousAt g x) : UpperSemicontinuousAt (λ (z : α), f z + g z) x
(K : Type u_1) (L : Type u_2) [Field K] [Field L] [Algebra K L] [FiniteDimensional K L] : Algebra.IsIntegral K L
{β : Type u} {α : Type v} {s : Finset α} {f : α → β} [AddCommMonoid β] (R : Setoid α) [DecidableRel Setoid.r] : s.sum (λ (x : α), f x) = (Finset.image Quotient.mk s).sum (λ (xbar : Quotient R), (Finset.filter (λ (y : α), ⟦y⟧ = xbar) s).sum (λ (y : α), f y))
{C D E : CategoryTheory.Groupoid} (f : C ⟶ D) (g : D ⟶ E) : f ≫ g = f ⋙ g
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {n : WithTop ℕ} {s : Set E} {f : E → F} (hF : ContDiffWithinAt 𝕜 n f s x) : ContDiffWithinAt 𝕜 n (λ (x : E), -f x) s x
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {f g : C(α, β)} (H : f = g) (x : α) : ⇑f x = ⇑g x
{G : Type w} [TopologicalSpace G] [AddGroup G] [TopologicalAddGroup G] {K U : Set G} (hK : is_IsCompact K) (hU : is_IsOpen U) (hKU : K ⊆ U) : ∃ (V : Set G) (H : V ∈ nhds 0), V + K ⊆ U
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (x : Module.Ray R M) : x.some_Vector ≠ 0
(k : Type u_1) {V1 : Type u_2} {P1 : Type u_3} [Ring k] [AddCommGroup V1] [Module k V1] [AddTorsor V1 P1] (p : P1) : ⇑(AffineMap.id k P1) p = p
{n : ℕ} {F : Typevec (n + 1) → Type u} [Mvfunctor F] [q : Mvqpf F] {α : Typevec n} (r : Mvqpf.Cofix F α → Mvqpf.Cofix F α → Prop) (h : ∀ (x y : Mvqpf.Cofix F α), r x y → Mvfunctor.Liftr (α.rel_Last r) x.dest y.dest) (x y : Mvqpf.Cofix F α) : r x y → x = y
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P (n + 1)) (i : Fin (n + 2)) : s.points i ∈ s.altitude i
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] : {s : Set α | IsPreconnected s} = Set.Range (Function.uncurry Set.Icc) ∪ Set.Range (Function.uncurry Set.Ico) ∪ Set.Range (Function.uncurry Set.Ioc) ∪ Set.Range (Function.uncurry Set.Ioo) ∪ (Set.Range Set.Ici ∪ Set.Range Set.Ioi ∪ Set.Range Set.Iic ∪ Set.Range Set.Iio ∪ {Set.Univ, ∅})
{α : Type u} [PseudoMetricSpace α] (R : ℝ) (h : ∀ (x : α) (r : ℝ), R ≤ r → is_IsCompact (Metric.ClosedBall x r)) : ProperSpace α
{α : sort u_1} {β : sort u_2} {γ : sort u_3} {f : α → β → γ} (hF : Function.Injective2 f) [Nonempty α] : Function.Injective (λ (b : β) (a : α), f a b)
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [StrictConvexSpace ℝ E] {x y : E} (h : ¬SameRay ℝ x y) : ∥x + y∥ < ∥x∥ + ∥y∥
{G : Type u_1} [Group G] {G₂ : Type u_2} [Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)] [hp₂ : Fact (Nat.Prime p₂)] (hne : p₁ ≠ p₂) (H₁ : Subgroup G) (H₂ : Subgroup G₂) [Fintype ↥H₁] [Fintype ↥H₂] (hH₁ : is_p_Group p₁ ↥H₁) (hH₂ : is_p_Group p₂ ↥H₂) : (Fintype.card ↥H₁).coprime (Fintype.card ↥H₂)
{α : Type u} [SemilatticeSup α] [OrderBot α] (x y : α) : (x ⨿ y) = x ⊔ y
(R : Type u) [CommRing R] : GaloisConnection (λ (s : Set R), PrimeSpectrum.ZeroLocus s) (λ (t : (Set (PrimeSpectrum R))ᵒᵈ), ↑(Prime_spectrum.vanishing_Ideal t))
{C : Type u₁} [CategoryTheory.Category C] {X₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₂₁ : X₂₁ ⟶ X₂₂} {h₃₁ : X₃₁ ⟶ X₃₂} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₂₁ : X₂₁ ⟶ X₃₁} {v₂₂ : X₂₂ ⟶ X₃₂} (s : CategoryTheory.IsPushout h₁₁ v₁₁ v₁₂ h₂₁) (t : CategoryTheory.IsPushout h₂₁ v₂₁ v₂₂ h₃₁) : CategoryTheory.IsPushout h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁
{G : Type u_1} [Group G] {N : Type u_3} [Group N] (H : Subgroup G) {f : G →* N} (hF : Function.bijective ⇑f) : Subgroup.map f H.normalizer = (Subgroup.map f H).normalizer
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {f : ℝ → E} {a b C : ℝ} (hF : DifferentiableOn ℝ f (Set.Icc a b)) (bound : ∀ (x : ℝ), x ∈ Set.Ico a b → ∥deriv_within f (Set.Icc a b) x∥ ≤ C) (x : ℝ) (H : x ∈ Set.Icc a b) : ∥f x - f a∥ ≤ C * (x - a)
{C : Type u} [CategoryTheory.Category C] {J K : Type u₁} [CategoryTheory.Category J] [CategoryTheory.Category K] (F : J ⥤ C) (G : K ⥤ C) (h : F.cones ≅ G.cones) [CategoryTheory.Limits.HasLimit F] : CategoryTheory.Limits.HasLimit G
{ι : Type u_1} {R : Type u_3} {M : Type u_5} {v : ι → M} [Semiring R] [AddCommMonoid M] [Module R M] {s : Set ι} : ¬LinearIndependent R (v ∘ Coe) ↔ ∃ (f : ι →₀ R), f ∈ Finsupp.supported R R s ∧ f.support.sum (λ (i : ι), ⇑f i • v i) = 0 ∧ f ≠ 0
{C : Type u₁} [CategoryTheory.Category C] {X Y : C} {P : CategoryTheory.Subobject Y} {f g : X ⟶ ↑P} (h : f ≫ P.arrow = g ≫ P.arrow) : f = g
{ι : Type u_1} [Fintype ι] [DecidableEq ι] {R : Type u_2} [Semiring R] (x : ι → R) : x = finset.univ.sum (λ (i : ι), x i • λ (j : ι), Ite (i = j) 1 0)
{V : Type u} [Fintype V] [DecidableEq V] {ℓ : ℕ} : ⊥.is_SRG_with (Fintype.card V) 0 ℓ 0
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] {f : C(α, β)} {ι : Type u₃} {p : Filter ι} {F : ι → C(α, β)} [CompactSpace α] : Filter.Tendsto F p (nhds f) ↔ TendstoUniformly (λ (i : ι) (a : α), ⇑(F i) a) ⇑f p
{E : Type u_1} {β : Type u_2} [AddCommGroup E] [TopologicalSpace E] [Module ℝ E] [TopologicalAddGroup E] [HasContinuousSmul ℝ E] [OrderedAddCommGroup β] [Module ℝ β] [OrderedSmul ℝ β] {s : Set E} {f : E → β} {a : E} (a_in_s : a ∈ s) (h_localmin : is_IsLocalMinOn f s a) (h_conv : ConvexOn ℝ s f) : IsMinOn f s a
{ι : Type u_6} [DecidableEq ι] {K : Type u_1} [Ring K] {M : Type u_2} [AddCommGroup M] [Module K M] {N : Type u_3} [AddCommGroup N] [Module K N] [NoZeroSmulDivisors K N] (f : AlternatingMap K M N ι) (v : ι → M) (h : ¬LinearIndependent K v) : ⇑f v = 0
{α : Type u_1} {s : Multiset α} : s.powerset.nodup → s.nodup
{ι : Type u_1} {R : Type u_3} {M : Type u_5} [Ring R] [Nontrivial R] [AddCommGroup M] [Module R M] [NoZeroSmulDivisors R M] (v : ι → M) [Unique ι] : v Inhabited.default ≠ 0 → LinearIndependent R v
{𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] {f : 𝕜 → G} {s : Set 𝕜} {C : Nnreal} (hs : Convex ℝ s) (hF : DifferentiableOn 𝕜 f s) (bound : ∀ (x : 𝕜), x ∈ s → ∥deriv_within f s x∥₊ ≤ C) : LipschitzOnWith C f s
(R : Type u_1) [Rack R] (G : Type u_2) [Group G] (f : ShelfHom R (Quandle.Conj G)) : (Quandle.Conj.map (⇑rack.to_envel_group.map f)).comp (rack.to_EnvelGroup R) = f
{α : Type u} {l₁ l₂ : List α} (i : ℕ) : List.drop (l₁.length + i) (l₁ ++ l₂) = List.drop i l₂
{α : Type u} (r : α → α → Prop) [IsAntisymm α r] {a b : α} : r a b → r b a → b = a
{f : ℕ → Nnreal} {r : Nnreal} : HasSum f r ↔ Filter.Tendsto (λ (n : ℕ), (Finset.range n).sum (λ (i : ℕ), f i)) filter.at_Top (nhds r)
{X : Type u_1} {Y : Type u_2} [PseudoEmetricSpace X] [PseudoEmetricSpace Y] {C r : Nnreal} {f : X → Y} (hF : HolderWith C r f) (h0 : 0 < r) : UniformContinuous f
{a b : ℝ} (h : a < b) : Cardinal.mk ↥(Set.Icc a b) = Cardinal.continuum
{ι₁ : Type u_1} {ι₂ : Type u_2} {R : Type u_3} {R₂ : Type u_4} {S : Type u_5} {S₂ : Type u_6} {M : Type u_7} {N : Type u_8} {P : Type u_9} [CommRing R] [CommRing S] [CommRing R₂] [CommRing S₂] [AddCommGroup M] [AddCommGroup N] [AddCommGroup P] [Module R M] [Module S N] [Module R₂ P] [Module S₂ P] [SmulCommClass S₂ R₂ P] {ρ₁₂ : R →+* R₂} {σ₁₂ : S →+* S₂} (b₁ : Basis ι₁ R M) (b₂ : Basis ι₂ S N) {B : M →ₛₗ[ρ₁₂] N →ₛₗ[σ₁₂] P} (x : M) (y : N) : (⇑(b₁.repr) x).sum (λ (i : ι₁) (xi : R), (⇑(b₂.repr) y).sum (λ (j : ι₂) (yj : S), ⇑ρ₁₂ xi • ⇑σ₁₂ yj • ⇑(⇑B (⇑b₁ i)) (⇑b₂ j))) = ⇑(⇑B x) y
{x y : ℝ} (h : x < y) : ∃ (r : ℝ), Irrational r ∧ x < r ∧ r < y
{α : Type u} [CommSemiring α] {p p' : α} {ps ps' : ℕ} : p = p' → ps = ps' → p ^ ps = p' ^ ps'
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] [FiniteDimensional F E] : [IsGalois F E, intermediate_field.fixed_Field ⊤ = ⊥, Fintype.card (E ≃ₐ[F] E) = FiniteDimensional.finrank F E, ∃ (p : Polynomial F), p.separable ∧ Polynomial.IsSplittingField F E p].tfae
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {f : E → F} {s : Set E} {x : E} (hF : ContDiffWithinAt ℝ 1 f s x) (hs : Convex ℝ s) : ∃ (K : Nnreal) (t : Set E) (H : t ∈ nhds_within x s), LipschitzOnWith K f t
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [BaireSpace α] [Encodable β] {f : β → Set α} (ho : ∀ (s : β), is_Gδ (f s)) (hD : ∀ (s : β), Dense (f s)) : Dense (⋂ (s : β), f s)
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] [Nonempty V] : ∃ (v : V), G.max_degree = G.degree v
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f f' : X ⟶ Y} [CategoryTheory.Limits.HasImage f] [CategoryTheory.Limits.HasImage f'] [CategoryTheory.Limits.HasEqualizers C] (h : f = f') : CategoryTheory.Limits.imageι f = (Category_theory.limits.image.eq_to_iso h).hom ≫ CategoryTheory.Limits.imageι f'
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {n : WithTop ℕ} (h : ContDiffOn 𝕜 n f s) (hn : 1 ≤ n) : DifferentiableOn 𝕜 f s
(p : ℕ) [Fact (Nat.Prime p)] (hp : p ≠ 2) (a : ℤ) : ↑({x : Zmod p | x ^ 2 = ↑a}.to_finset.card) = zmod.legendre_Sym p a + 1
{C : Type u₁} [CategoryTheory.Category C] {B : C} {X Y : CategoryTheory.Subobject B} (f : ↑X ≅ ↑Y) (w : f.hom ≫ Y.arrow = X.arrow) : X = Y
{α : Type u_1} [CancelCommMonoidWithZero α] [UniqueFactorizationMonoid α] [NormalizationMonoid α] [DecidableEq α] {a b : α} (ha : a ≠ 0) (hb : b ≠ 0) : factorization (a * b) = factorization a + factorization b
{α : Type u} [Preorder α] {a : α} : a ≤ a
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] [TopologicalSpace δ] {e₁ : α → β} {e₂ : γ → δ} (de₁ : DenseEmbedding e₁) (de₂ : DenseEmbedding e₂) : DenseEmbedding (λ (p : α × γ), (e₁ p.fst, e₂ p.snd))
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {a b : α} (h : a < b) (s : Set α) : [s ∈ nhds_within b (Set.Iic b), s ∈ nhds_within b (Set.Icc a b), s ∈ nhds_within b (Set.Ioc a b), ∃ (l : α) (H : l ∈ Set.Ico a b), Set.Ioc l b ⊆ s, ∃ (l : α) (H : l ∈ Set.Iio b), Set.Ioc l b ⊆ s].tfae
{α : Type u_1} {s : Finset α} {f : α → Ennreal} (hF : ∀ (a : α), a ∈ s → f a ≠ ⊤) : (s.sum (λ (a : α), f a)).to_Real = s.sum (λ (a : α), (f a).to_Real)
{α : Type u} {β : Type v} [TopologicalSpace α] [PseudoMetricSpace β] {f g : BoundedContinuousFunction α β} {C : ℝ} (C0 : 0 ≤ C) : HasDist.dist f g ≤ C ↔ ∀ (x : α), HasDist.dist (⇑f x) (⇑g x) ≤ C
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (s : Set P) : ↑(affine_Span k s).nonempty ↔ s.nonempty
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (g : C(β, γ)) : Continuous g.comp
(P L : Type u) [HasMem P L] [Configuration.HasPoints P L] [Fintype P] [Fintype L] : Fintype.card L ≤ Fintype.card P
{R : Type u_1} {a : R} [Monoid R] {n : ℕ} (n0 : 0 < n) : IsLeftRegular (a ^ n) ↔ IsLeftRegular a
{K : Type u_1} {n : ℕ} {s : Seq (GeneralizedContinuedFraction.Pair K)} [DivisionRing K] : (generalized_continued_fraction.squash_Seq s (n + 1)).tail = generalized_continued_fraction.squash_Seq s.tail n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.NonPreadditiveAbelian C] {X Y : C} (f : X ⟶ Y) : CategoryTheory.NonPreadditiveAbelianσ ≫ f = CategoryTheory.Limits.prod.map f f ≫ CategoryTheory.NonPreadditiveAbelianσ
{R : Type u_1} {M : Type u_2} [AddZeroClass R] [AddZeroClass M] {P : TrivSqZeroExt R M → Prop} (h : ∀ (r : R) (m : M), P (TrivSqZeroExt.inl r + TrivSqZeroExt.inr m)) (x : TrivSqZeroExt R M) : P x
{ι : Type u_1} {R : Type u_2} [CommRing R] [is_IsDomain R] [IsPrincipalIdealRing R] [Fintype ι] {O : Type u_3} [AddCommGroup O] [Module R O] (M N : Submodule R O) (b'M : Basis ι R ↥M) (N_IsBot : N ≠ ⊥) (N_LE_M : N ≤ M) : ∃ (y : O) (H : y ∈ M) (a : R) (hay : a • y ∈ N) (M' : Submodule R O) (H : M' ≤ M) (N' : Submodule R O) (H : N' ≤ N) (N'_LE_M' : N' ≤ M') (y_IsOrtho_M' : ∀ (c : R) (z : O), z ∈ M' → c • y + z = 0 → c = 0) (ay_IsOrtho_N' : ∀ (c : R) (z : O), z ∈ N' → c • a • y + z = 0 → c = 0), ∀ (n' : ℕ) (bN' : Basis (Fin n') R ↥N'), ∃ (bN : Basis (Fin (n' + 1)) R ↥N), ∀ (m' : ℕ) (hn'm' : n' ≤ m') (bM' : Basis (Fin m') R ↥M'), ∃ (hnm : n' + 1 ≤ m' + 1) (bM : Basis (Fin (m' + 1)) R ↥M), ∀ (as : Fin n' → R), (∀ (i : Fin n'), ↑(⇑bN' i) = as i • ↑(⇑bM' (⇑(fin.cast_LE hn'm') i))) → (∃ (as' : Fin (n' + 1) → R), ∀ (i : Fin (n' + 1)), ↑(⇑bN i) = as' i • ↑(⇑bM (⇑(fin.cast_LE hnm) i)))
{G : Type u_1} [AddGroup G] (K : AddSubgroup G) : AddSubgroup.closure ↑K = K
{E : ℕ → Type u_1} [Π (n : ℕ), TopologicalSpace (E n)] [∀ (n : ℕ), DiscreteTopology (E n)] {s : Set (Π (n : ℕ), E n)} (hs : is_IsClosed s) (hne : s.nonempty) : ∃ (f : (Π (n : ℕ), E n) → Π (n : ℕ), E n), (∀ (x : Π (n : ℕ), E n), x ∈ s → f x = x) ∧ Set.Range f = s ∧ LipschitzWith 1 f
{α : Type u} {β : Type v} (e : α ≃ β) [Nontrivial β] : Nontrivial α
{α : Type u_1} [MeasurableSpace α] {m₁ m₂ m₃ : MeasureTheory.OuterMeasure α} {Op : Ennreal → Ennreal → Ennreal} (h : ∀ (s : Set α), ⇑m₁ s = Op (⇑m₂ s) (⇑m₃ s)) (s : Set α) : ⇑(m₁.trim) s = Op (⇑(m₂.trim) s) (⇑(m₃.trim) s)
{α : Type u} [AddCommGroup α] [HasLe α] [CovariantClass α α has_add.add has_le.le] {a b c : α} : a ≤ b + c → a - b ≤ c
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [FiniteDimensional 𝕜 E] [FiniteDimensional 𝕜 F] {ι₁ : Type u_4} {ι₂ : Type u_5} (b₁ : Basis ι₁ 𝕜 E) (b₂ : Basis ι₂ 𝕜 F) (A : E →ₗ[𝕜] F) (B : F →ₗ[𝕜] E) : A = ⇑LinearMap.adjoint B ↔ ∀ (i₁ : ι₁) (i₂ : ι₂), HasInner.inner (⇑A (⇑b₁ i₁)) (⇑b₂ i₂) = HasInner.inner (⇑b₁ i₁) (⇑B (⇑b₂ i₂))
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) {ι : Type u_3} {t : Finset ι} {f : ι → L} (h : ∀ (c : ι), c ∈ t → f c ∈ S) : t.prod (λ (i : ι), f i) ∈ S
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f : ℂ → E} {c : ℂ} (hD : ∀ᶠ (z : ℂ) in nhds_within c {c}ᶜ, DifferentiableAt ℂ f z) (hb : Filter.IsBoundedUnder has_le.le (nhds_within c {c}ᶜ) (λ (z : ℂ), ∥f z - f c∥)) : Filter.Tendsto f (nhds_within c {c}ᶜ) (nhds (lim (nhds_within c {c}ᶜ) f))
{R : Type u_1} [CommSemiring R] {A : Type u} [TopologicalSpace A] [Semiring A] [Algebra R A] [TopologicalSemiring A] (s : Subalgebra R A) {B : Type u_2} [TopologicalSpace B] [Ring B] [TopologicalRing B] [Algebra R B] (f : B →ₐ[R] A) (f' : B ≃ₜ A) (w : ⇑f = ⇑f') : s.topological_closure.comap' f = (s.comap' f).topological_Closure
{α : Type u_1} {C : Cycle α → Prop} (s : Cycle α) (H0 : C Cycle.nil) (HI : ∀ (a : α) (l : List α), C ↑l → C ↑(a :: l)) : C s
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x : V} (hx : x ≠ 0) (θ : Real.Angle) : ⇑(hb.rotation θ) x = x ↔ θ = 0
{x y : ℝ} : Irrational (x + y) → Irrational x ∨ Irrational y
{X : Type u_2} [EmetricSpace X] [TopologicalSpace.SecondCountableTopology X] {s : Set X} {r : Ennreal} (h : r < dimH s) : ∃ (x : X) (H : x ∈ s), ∀ (t : Set X), t ∈ nhds_within x s → r < dimH t
{A : Type u_1} [CommRing A] [Algebra ℚ A] (n : ℕ) : (Finset.range n).sum (λ (k : ℕ), PowerSeries.exp A ^ k) = PowerSeries.mk (λ (p : ℕ), (Finset.range n).sum (λ (k : ℕ), ↑k ^ p * ⇑(Algebra_Map ℚ A) (↑(p.factorial))⁻¹))
{G : Type u_1} [CommMonoid G] : monoid.is_torsion ↥(comm_monoid.torsion G)
{α : Type u} [PseudoEmetricSpace α] {x : α} {s : Set α} {r : Ennreal} : emetric.inf_edist x s < r ↔ ∃ (y : α) (H : y ∈ s), HasEdist.edist x y < r
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [NondiscreteNormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (f : ContinuousMultilinearMap 𝕜 E G) (m₁ m₂ : Π (i : ι), E i) : ∥⇑f m₁ - ⇑f m₂∥ ≤ ∥f∥ * ↑(Fintype.card ι) * Linear_order.max ∥m₁∥ ∥m₂∥ ^ (Fintype.card ι - 1) * ∥m₁ - m₂∥
{f₁ f₂ : Circle_deg1_Lift} (h₁ : Function.bijective ⇑f₁) (h₂ : Function.bijective ⇑f₂) (h : f₁.translation_number = f₂.translation_number) : ∃ (F : Circle_deg1_Lift), Function.Semiconj ⇑F ⇑f₁ ⇑f₂
{X : Type u} [Lattice X] [JordanHolderLattice X] (s₁ s₂ : CompositionSeries X) (hb : s₁.bot = s₂.bot) (ht : s₁.top = s₂.top) : s₁.equivalent s₂
{α : Type u_1} [CompleteLattice α] {s : Set α} {b : α} (_x : ∀ (a : α), a ∈ s → a ≤ b) (H : ∀ (w : α), w < b → (∃ (a : α) (H : a ∈ s), w < a)) : HasSup.sup s = b
{K : Type u_1} [Field K] [Fintype K] (i : ℕ) (h : i < Fintype.card K - 1) : finset.univ.sum (λ (x : K), x ^ i) = 0
{R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [Ring R] [AddCommGroup M] [AddCommGroup M₂] [Module R M] [Module R M₂] (f : M ≃ₗ[R] M₂) : FiniteDimensional.finrank R M = FiniteDimensional.finrank R M₂
{R : Type u} {S : Type v} [Semiring R] [AddCommMonoid S] (p : Polynomial R) {f : ℕ → R → S} (h : ∀ (n : ℕ), f n 0 = 0) (n : ℕ) (w : p.nat_degree < n) : p.sum f = (Finset.range n).sum (λ (a : ℕ), f a (p.coeff a))
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] {K : Type u_2} [Field K] [Algebra R K] [IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R) {r : R} {s : ↥(NonZeroDivisors R)} : ⇑(v.valuation) (IsLocalization.mk' K r s) = ⇑(v.int_Valuation) r / ⇑(v.int_Valuation) ↑s
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) (C : Nnreal) {r : Nnreal} (h : ∀ (n : ℕ), ∥p n∥₊ * r ^ n ≤ C) : ↑r ≤ p.radius
{α : Type u_1} [LinearOrderedField α] [Archimedean α] {x y : α} (hx : 0 < x) (hy : 1 < y) : ∃ (n : ℤ), x ∈ Set.Ioc (y ^ n) (y ^ (n + 1))
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {f : M →* N} (h : ∀ (y : ↥S), IsUnit (⇑f ↑y)) (y : ↥S) (w z : N) : z = w * ↑(⇑(is_unit.lift_Right (f.restrict S) h) y)⁻¹ ↔ z * ⇑f ↑y = w
{α : Type u} {β : Type v} [AddZeroClass α] [AddZeroClass β] {f : α → β} (hF : IsAddMonoidHom f) {γ : Type u_1} [AddZeroClass γ] {g : β → γ} (hg : IsAddMonoidHom g) : IsAddMonoidHom (g ∘ f)
(α : Type u_1) [CompleteLattice α] : CompleteLattice.IsSupFiniteCompact α → WellFounded GT
{R : Type u_1} [MulZeroClass R] [nR : Nontrivial R] : ¬IsRightRegular 0
{α : Type u} [TopologicalSpace α] {s : Set α} (hs : is_IsCompact s) {p : Set α → Prop} (hE : p ∅) (hmono : ∀ ⦃s t : Set α⦄, s ⊆ t → p t → p s) (hunion : ∀ ⦃s t : Set α⦄, p s → p t → p (s ∪ t)) (hnhds : ∀ (x : α), x ∈ s → (∃ (t : Set α) (H : t ∈ nhds_within x s), p t)) : p s
{α : Type u} {β : Type v} [Group α] [Group β] {f : α → β} (hF : IsGroupHom f) (a : α) : f a⁻¹ = (f a)⁻¹
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q) (a b : CategoryTheory.Over P) : a ≈ b → CategoryTheory.Abelian.app f a ≈ CategoryTheory.Abelian.app f b
{α : Type u_1} {β : Type u_3} [MeasurableSpace α] [MeasurableSpace β] : Measurable_space.generate_from (Set.image2 HasSetProd.prod {s : Set α | MeasurableSet s} {t : Set β | MeasurableSet t}) = prod.measurable_Space
{𝕜 : Type u_1} {E : Type u_2} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {p₁ p₂ : FormalMultilinearSeries 𝕜 𝕜 E} {f : 𝕜 → E} {r₁ r₂ : Ennreal} {x : 𝕜} (h₁ : HasFpowerSeriesOnBall f p₁ x r₁) (h₂ : HasFpowerSeriesOnBall f p₂ x r₂) : HasFpowerSeriesOnBall f p₁ x r₂
{R : Type u} [Semiring R] {p : Polynomial R} {n : ℕ} : p.nat_degree ≤ n → p.degree ≤ ↑n
{α : Type u} {β : Type v} [DecidableEq β] [Fintype α] [Fintype β] (f : α → β) {n : ℕ} [Nonempty β] (hn : Fintype.card α ≤ Fintype.card β * n) : ∃ (y : β), (Finset.filter (λ (x : α), f x = y) Finset.univ).card ≤ n
{X : Top} {T : ↥X → Type v} (P : Top.LocalPredicate T) : (Top.subpresheaf_to_Types P.to_prelocal_predicate).is_sheaf
{𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {s : Set E} (hs : Orthonormal 𝕜 Coe) : ∃ (w : Set E) (b : HilbertBasis ↥w 𝕜 E), s ⊆ w ∧ ⇑b = Coe
{𝕜 : Type u_1} [is_R_or_C 𝕜] {F : Type u_2} [SemiNormedGroup F] [NormedSpace 𝕜 F] (p : Subspace 𝕜 F) (f : ↥p →L[𝕜] 𝕜) : ∃ (g : F →L[𝕜] 𝕜), (∀ (x : ↥p), ⇑g ↑x = ⇑f x) ∧ ∥g∥ = ∥f∥
{C : Type u₁} [CategoryTheory.Category C] {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₁₂ : X₁₂ ⟶ X₁₃} {h₂₁ : X₂₁ ⟶ X₂₂} {h₂₂ : X₂₂ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃} (s : CategoryTheory.IsPushout h₁₁ v₁₁ v₁₂ h₂₁) (t : CategoryTheory.IsPushout h₁₂ v₁₂ v₁₃ h₂₂) : CategoryTheory.IsPushout (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β → γ} {tas : Set (TopologicalSpace α)} {tbs : Set (TopologicalSpace β)} {ta : TopologicalSpace α} {tb : TopologicalSpace β} {Tc : TopologicalSpace γ} (ha : ta ∈ tas) (hb : tb ∈ tbs) (hF : Continuous (λ (p : α × β), f p.fst p.snd)) : Continuous (λ (p : α × β), f p.fst p.snd)
{M : Type u_1} [MulOneClass M] {ι : sort u_2} (S : ι → Submonoid M) {C : M → Prop} {x : M} (hx : x ∈ ⨆ (i : ι), S i) (hp : ∀ (i : ι) (x : M), x ∈ S i → C x) (h1 : C 1) (hMul : ∀ (x y : M), C x → C y → C (x * y)) : C x
{G : Type u} [Group G] [Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G) : Fintype.card ↥P = p ^ ⇑((Fintype.card G).factorization) p
(n : ℕ) : HasDerivAt (Exp_Neg_Inv_glue.f_aux n) 0 0
{α : Type u} [NonUnitalNonAssocRing α] {a b c d e : α} : a * e + c = b * e + d ↔ (a - b) * e + c = d
{f : Ordinal → Ordinal} (H : Ordinal.IsNormal f) : Set.Unbounded has_lt.lt (Function.FixedPoints f)
{α : Type u_1} [MeasurableSpace α] {ι : Type u_2} {f : ι → α → Nnreal} {g : α → Nnreal} (u : Filter ι) [u.ne_IsBot] [u.is_countably_generated] (hF : ∀ (i : ι), Measurable (f i)) (lim : Filter.Tendsto f u (nhds g)) : Measurable g
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] {f : α → β} {s : Set α} {a : α} (h_Mono : StrictMonoOn f s) (hs : s ∈ nhds a) (hfs_l : ∀ (b : β), b < f a → (∃ (c : α) (H : c ∈ s), f c ∈ Set.Ico b (f a))) (hfs_r : ∀ (b : β), b > f a → (∃ (c : α) (H : c ∈ s), f c ∈ Set.Ioc (f a) b)) : ContinuousAt f a
{x y : Pgame} (h : x < y) : x.lf y
{α : Type u_1} {r : α → α → Prop} (h : ∀ (c : Set α), IsChain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (Trans : ∀ {a b c : α}, r a b → r b c → r a c) : ∃ (m : α), ∀ (a : α), r m a → r a m
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] [t2_Space α] {s : Set β} {f g : β → α} (h : Set.EqOn f g s) (hF : Continuous f) (hg : Continuous g) : Set.EqOn f g (Closure s)
{α : Type u} [PseudoEmetricSpace α] {x y : α} {s : Set α} : emetric.inf_edist x s ≤ emetric.inf_edist y s + HasEdist.edist x y
{M : Type u_1} [AddGroup M] (c : AddCon M) {w x : M} : ⇑c w x → ⇑c (-w) (-x)
{R : Type u_1} {a : R} [Monoid R] (n : ℕ) (rra : IsRightRegular a) : IsRightRegular (a ^ n)
{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] {s : Set E} (hs : Convex 𝕜 s) : Convex 𝕜 (Interior s)
{β : Type v} [PseudoEmetricSpace β] {α : Type u} [EmetricSpace α] {f : α → β} (h : Isometry f) : Function.Injective f
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) : hb.oangle (-x) y = hb.oangle x (-y)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {s : Set (E × F)} : ContDiffOn 𝕜 n Prod.snd s
{α : Type u} [TopologicalSpace α] {s : Set α} {x : α} : x ∈ Closure s ↔ ∃ (u : Ultrafilter α), s ∈ u ∧ ↑u ≤ nhds x
 : Filter.Tendsto (λ (k : ℕ), (Finset.range k).sum (λ (i : ℕ), (-1) ^ i / (2 * ↑i + 1))) filter.at_Top (nhds (Real.pi / 4))
{H : Type u_1} [TopologicalSpace H] {x : H} : charted_space.chart_at H x = LocalHomeomorph.refl H
{R : Type u_1} [CommRing R] {x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : R} : (x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2) * (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2) = (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄) ^ 2 + (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃) ^ 2 + (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂) ^ 2 + (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁) ^ 2
{R : Type u_1} {a b : R} [AddMonoid R] (h : b + a = 0) : IsAddLeftRegular a
{G : Type u_1} [AddGroup G] (tG : Add_monoid.is_torsion G) (bounded : (Set.Range (λ (g : G), Add_order_of g)).finite) : Add_monoid.exponent_exists G
{α : Type u} [Preorder α] {s : Set α} {a : α} (h : IsLeast s a) : BddBelow s
(p : ℕ) [Fact (Nat.Prime p)] (R : Type u₁) [CommSemiring R] [Char_p R p] : PerfectionMap p (Perfection.coeff R p 0)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasZeroObject C] {X : C} (Y : CategoryTheory.Subobject X) : CategoryTheory.Simple ↑Y ↔ IsAtom Y
{ι : Type u_1} {E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {c : E} {lb lb' : Filter ℝ} {Lt : Filter ι} {a b : ℝ} {u v : ι → ℝ} [Interval_integral.FTC_Filter b lb lb'] (hab : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f lb' MeasureTheory.MeasureSpace.volume) (hF : Filter.Tendsto f (lb' ⊓ MeasureTheory.Measure_space.volume.ae) (nhds c)) (hu : Filter.Tendsto u Lt lb) (hv : Filter.Tendsto v Lt lb) : (λ (t : ι), ((∫ (x : ℝ) in a..v t, f x) - ∫ (x : ℝ) in a..u t, f x) - (v t - u t) • c) =o[Lt] (v - u)
{α : Type u} [CanonicallyOrderedCommSemiring α] [Nontrivial α] : 0 < 1
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace 𝕜] (s : Submodule 𝕜 E) [FiniteDimensional 𝕜 ↥s] : is_IsClosed ↑s
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (θ : Real.Angle) : (hb.rotation θ).symm = hb.rotation (-θ)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : Set P} (ho : EuclideanGeometry.OrthocentricSystem s) {p : Fin 3 → P} (hps : Set.Range p ⊆ s) (hpi : Function.Injective p) : affine_Span ℝ (Set.Range p) = affine_Span ℝ s
{G : Type u_2} [AddGroup G] {a b : G} : a = b → a - b = 0
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v w : ι → E} (hv : Orthonormal 𝕜 v) (hw : ∀ (i : ι), w i = v i ∨ w i = -v i) : Orthonormal 𝕜 w
 : Function.bijective Real.sinh
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {a b : α} [IsAntisymm α HasSubset.Subset] (h₁ : a ≠ b) (h₂ : a ⊆ b) : a ⊂ b
(p : ℕ) [Fact (Nat.Prime p)] {a : Zmod p} (ha : a ≠ 0) : IsSquare a ↔ a ^ (p / 2) = 1
{γ : Type w} [SemilatticeSup γ] (a : γ) {s : Set γ} : BddAbove (HasInsert.insert a s) ↔ BddAbove s
{α : Type u_2} [DecidableEq α] {s : Finset α} {B : Finset (Finset α)} {n : ℕ} (h : ∀ (a : α), a ∈ s → n ≤ (Finset.filter (HasMem.Mem a) B).card) : s.card * n ≤ B.sum (λ (t : Finset α), (s ∩ t).card)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] {p : P} (hp : p ∈ s) {v : V} (hv : v ∈ (s.direction)ᗮ) : ⇑(EuclideanGeometry.reflection s) (v +ᵥ p) = -v +ᵥ p
{R : Type u_1} {K : Type u_2} [Ring R] [Field K] (f : R →+* K) (hF : Function.Surjective ⇑f) : f.ker.is_Maximal
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂] [Module K V₂] [h : FiniteDimensional K V] (f : V →ₗ[K] V₂) (hF : f.range = ⊤) : FiniteDimensional K V₂
{V₁ : Type u_2} {V₂ : Type u_3} [SemiNormedGroup V₁] [SemiNormedGroup V₂] (f : V₁ →+ V₂) {C : ℝ} (hC : 0 ≤ C) (h : ∀ (x : V₁), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_NormedGroupHom C h∥ ≤ C
{𝕜 : Type u_3} {E : Type u_4} [NormedField 𝕜] [AddCommGroup E] [Module 𝕜 E] (p : Seminorm 𝕜 E) {r : ℝ} (hr : 0 < r) : Absorbent 𝕜 (p.ball 0 r)
{R : Type u₁} [Monoid R] [HasDistribNeg R] : (-1) ^ 2 = 1
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} (hx : ∥x∥ = 1) (hy : ∥y∥ = 1) : HasInner.inner x y = 1 ↔ x = y
{α : Type u} [Preorder α] {a b c : α} : b ≤ c → a < b → a < c
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) {r : ℝ} (hr : 0 < r) : hb.oangle x (r • y) = hb.oangle x y
{M : Type u_1} [AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {k : S.localization_Map P} (z : N) : ⇑(k.lift _) (⇑(f.lift _) z) = z
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} [TopologicalSpace β] [Preorder ι] {u : ι → α → β} {f : MeasureTheory.Filtration ι m} [TopologicalSpace ι] [TopologicalSpace.MetrizableSpace ι] [MeasurableSpace ι] [TopologicalSpace.SecondCountableTopology ι] [OpensMeasurableSpace ι] [TopologicalSpace.MetrizableSpace β] (h : MeasureTheory.Adapted f u) (hu_Cont : ∀ (x : α), Continuous (λ (i : ι), u i x)) : MeasureTheory.ProgMeasurable f u
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (s : AffineSubspace ℝ P) [Nonempty ↥s] [CompleteSpace ↥(s.direction)] (p : P) : ↑(⇑(euclidean_geometry.orthogonal_projection s) p) ∈ AffineSubspace.mk' p (s.direction)ᗮ
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : LocalHomeomorph α β) {b : β} (hb : b ∈ e.to_local_equiv.target) {f : β → E} {g : β → F} {C : ℝ} : asymptotics.is_O_with C (nhds b) f g ↔ asymptotics.is_O_with C (nhds (⇑(e.symm) b)) (f ∘ ⇑e) (g ∘ ⇑e)
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y : M} {r : R} (h : SameRay R x y) (hr : 0 ≤ r) : SameRay R x (r • y)
{G : Type u_1} [AddGroup G] {k : Set G} {p : G → Prop} {x : G} (h : x ∈ AddSubgroup.closure k) (Hk : ∀ (x : G), x ∈ k → p x) (Hk_Inv : ∀ (x : G), x ∈ k → p (-x)) (H1 : p 0) (hMul : ∀ (x y : G), p x → p y → p (x + y)) : p x
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) (m : Multiset L) : (∀ (a : L), a ∈ m → a ∈ S) → m.sum ∈ S
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜} : ConvexOn 𝕜 s f ↔ Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) ≤ (f z - f y) / (z - y)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x : V} (hx : x ≠ 0) (θ : Real.Angle) : hb.oangle x (⇑(hb.rotation θ) x) = θ
{α : Type u} [TopologicalSpace α] {s t : Set α} (hs : IsPreconnected s) (ht : is_IsClopen t) : Disjoint s t ∨ s ⊆ t
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {s : Set E} {f : E → F} {n : WithTop ℕ} {p : E → FormalMultilinearSeries 𝕜 E F} (hF : HasFtaylorSeriesUpToOn n f p s) (g : G →L[𝕜] E) : HasFtaylorSeriesUpToOn n (f ∘ ⇑g) (λ (x : G) (k : ℕ), (p (⇑g x) k).comp_ContinuousLinearMap (λ (_x : Fin k), g)) (⇑g ⁻¹' s)
{R : Type u_1} [CommRing R] {M : Submonoid R} {S : Type u_2} [CommRing S] [Algebra R S] (Rₘ : Type u_4) (Sₘ : Type u_5) [CommRing Rₘ] [CommRing Sₘ] [Algebra R Rₘ] [IsLocalization M Rₘ] [Algebra S Sₘ] [IsLocalization (algebra.algebra_Map_Submonoid S M) Sₘ] (hRS : Function.Injective ⇑(Algebra_Map R S)) (hM : algebra.algebra_Map_Submonoid S M ≤ NonZeroDivisors S) : Function.Injective ⇑(Algebra_Map Rₘ Sₘ)
{R : Type u_1} {M : Type u_2} [CommSemiring R] [AddCommMonoid M] [Module R M] (S : Type u_3) [CommMonoid S] [DistribMulAction S M] [SmulCommClass S R M] : Module.IsTorsion' ↥(Submodule.torsion' R M S) S
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : E → ℝ} {a : E} {f' : E →L[ℝ] ℝ} {s : Set E} (h : is_IsLocalMaxOn f s a) (hF : HasFderivWithinAt f f' s a) {y : E} (hy : y ∈ PosTangentConeAt s a) (hy' : -y ∈ PosTangentConeAt s a) : ⇑f' y = 0
{β : Type u} {α : Type v} {s : Finset α} {f : α → β} [CommMonoid β] (R : Setoid α) [DecidableRel Setoid.r] : s.prod (λ (x : α), f x) = (Finset.image Quotient.mk s).prod (λ (xbar : Quotient R), (Finset.filter (λ (y : α), ⟦y⟧ = xbar) s).prod (λ (y : α), f y))
{M : Type u_1} [HasMul M] {N : Type u_2} [HasMul N] (f : M →ₙ* N) (hF : Function.Surjective ⇑f) : f.srange = ⊤
(f : ℝ → ℝ) {a b : ℝ} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hfI : f a = f b) : ∃ (c : ℝ) (H : c ∈ Set.Ioo a b), deriv f c = 0
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Limits.HasBinaryProducts C
(n : ℕ) (R : Type u_1) [CommRing R] [is_IsDomain R] : Polynomial.cyclotomic' n R ≠ 0
{α : Type u} [Preorder α] {s t : Set α} (h : BddAbove s) : BddAbove (s ∩ t)
{α : Type u_1} [UniformSpace α] (x : α) : nhds (x, x) ≤ Uniformity α
{α : Type u_2} {ι : Type u_5} [CommMonoid α] (t : Finset ι) (f : ι → Set α) (a : α) : a ∈ t.prod (λ (i : ι), f i) ↔ ∃ (g : ι → α) (hg : ∀ {i : ι}, i ∈ t → g i ∈ f i), t.prod (λ (i : ι), g i) = a
{𝕜 : Type u_1} {A : Type u_2} [is_R_or_C 𝕜] [NormedRing A] [NormedAlgebra 𝕜 A] [CompleteSpace A] (a : A) {z : 𝕜} (hz : z ∈ Spectrum 𝕜 a) : Exp 𝕜 z ∈ Spectrum 𝕜 (Exp 𝕜 a)
(n : ℕ) : ↑n.numeric
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {p : E → FormalMultilinearSeries 𝕜 E F} {n : ℕ} : HasFtaylorSeriesUpToOn (↑n + 1) f p s ↔ HasFtaylorSeriesUpToOn ↑n f p s ∧ (∀ (x : E), x ∈ s → HasFderivWithinAt (λ (y : E), p y n) (p x n.succ).curry_Left s x) ∧ ContinuousOn (λ (x : E), p x (n + 1)) s
{n : WithTop ℕ} : ContDiff ℝ n Exp_Neg_Inv_glue
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) : o.oangle x y = θ ↔ y = (∥y∥ / ∥x∥) • ⇑(o.rotation θ) x
{α : Type u_1} {β : Type u_2} {f : α → β} {x y : α} : (setoid.ker f).rel x y ↔ x ∈ f ⁻¹' {f y}
{p : ℕ} : padic_val_Int p 1 = 0
{S : Type u_2} [CommRing S] {K : Type u_4} {F : Type u_6} [Field K] [Field F] [Algebra K F] [Algebra K S] (pB : PowerBasis K S) (hF : Polynomial.Splits (Algebra_Map K F) (minpoly K pb.gen)) : ⇑(Algebra_Map K F) (⇑(Algebra.norm K) pb.gen) = (Polynomial.map (Algebra_Map K F) (minpoly K pb.gen)).roots.prod
{a b : Ordinal} : {o : Ordinal | a ≤ b + o}.nonempty
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {r : ℝ} (hr : 0 ≤ r) : r • Metric.ClosedBall 0 1 = Metric.ClosedBall 0 r
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] {p1 : P} (p2 : P) (r : ℝ) (hp : p1 ∈ s) : ⇑(euclidean_geometry.orthogonal_projection s) (r • (p2 -ᵥ ↑(⇑(euclidean_geometry.orthogonal_projection s) p2)) +ᵥ p1) = ⟨p1, hp⟩
(k : Type u_1) {V1 : Type u_2} (P1 : Type u_3) [Ring k] [AddCommGroup V1] [Module k V1] [AddTorsor V1 P1] : ⇑(AffineMap.id k P1) = Id
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] (k : ℕ) (h : ∀ (v : V), G.degree v ≤ k) : G.max_degree ≤ k
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e e' : LocalHomeomorph α β} (h : e ≈ e') : e.symm ≈ e'.symm
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (E1 E2 : IntermediateField K L) (h1 : FiniteDimensional K ↥E1) (h2 : FiniteDimensional K ↥E2) : FiniteDimensional K ↥(E1 ⊔ E2)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (u : E) {v : E} (hv : v ∈ (Submodule.span 𝕜 {u})ᗮ) : HasInner.inner v u = 0
(R : Type u_1) [Ring R] : Polynomial.cyclotomic 2 R = Polynomial.x + 1
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommGroup β] [HasScalar 𝕜 E] [Module 𝕜 β] {s : Set E} {f : E → β} : ConcaveOn 𝕜 s (-f) ↔ ConvexOn 𝕜 s f
(G : Type u_1) [AddCommGroup G] : Add_comm_monoid.add_torsion G = (AddIsTorsion G).to_AddSubmonoid
{α : Type u} [PseudoMetricSpace α] : Isometry Coe
{γ : Type u_3} [tγ : TopologicalSpace γ] [PolishSpace γ] [MeasurableSpace γ] [BorelSpace γ] {β : Type u_4} [tβ : TopologicalSpace β] [t2_Space β] [MeasurableSpace β] [BorelSpace β] {f : γ → β} (f_Cont : Continuous f) (f_inj : Function.Injective f) : MeasurableEmbedding f
{R : Type u_1} [CommSemiring R] (M : Submonoid R) {S : Type u_2} [CommSemiring S] [Algebra R S] {P : Type u_3} [CommSemiring P] [IsLocalization M S] (j k : S → P) (hj1 : j 1 = 1) (hk1 : k 1 = 1) (hjm : ∀ (a b : S), j (a * b) = j a * j b) (hkm : ∀ (a b : S), k (a * b) = k a * k b) (h : ∀ (a : R), j (⇑(Algebra_Map R S) a) = k (⇑(Algebra_Map R S) a)) : j = k
{α : Type u} [TopologicalSpace α] {S : Set (Set α)} (K : DirectedOn HasSubset.Subset S) (H : ∀ (s : Set α), s ∈ S → IsPreconnected s) : IsPreconnected (⋃₀S)
{α : Type u_1} [Lattice α] [IsModularLattice α] {β : Type u_2} {γ : Type u_3} [PartialOrder β] [Preorder γ] (h₁ : WellFounded has_lt.lt) (h₂ : WellFounded has_lt.lt) (K : α) (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ) (gci : GaloisCoinsertion f₁ f₂) (gi : GaloisInsertion g₂ g₁) (hF : ∀ (a : α), f₁ (f₂ a) = a ⊓ K) (hg : ∀ (a : α), g₁ (g₂ a) = a ⊔ K) : WellFounded has_lt.lt
{α : Type u_1} [PartialOrder α] [PredOrder α] {a : α} : IsMin a → Order.pred a = a
{R : Type u} [CommSemiring R] (t : Multiset (Polynomial R)) : t.prod.degree ≤ (Multiset.map Polynomial.degree t).sum
{M : Type u_1} [has_Add M] {c d : AddCon M} : (∀ (x y : M), ⇑c x y ↔ ⇑d x y) ↔ c = d
(F : Type u) (K A : Type v) [Field F] [Field K] [AddCommGroup A] [Algebra F K] [Module K A] [Module F A] [IsScalarTower F K A] : Module.rank F K * Module.rank K A = Module.rank F A
{M : Type u_1} [CommMonoid M] (f s : ℕ → M) (h0 : s 0 = 1) (h : ∀ (n : ℕ), s (n + 1) = s n * f n) (n : ℕ) : (Finset.range n).prod (λ (k : ℕ), f k) = s n
{α : Type u} {L₁ L₂ : List (α × Bool)} [DecidableEq α] (H : FreeGroup.mk L₁ = FreeGroup.mk L₂) : FreeGroup.reduce L₁ = FreeGroup.reduce L₂
{α : Type u} [PseudoEmetricSpace α] {p : α → Prop} (x y : Subtype_ p) : HasEdist.edist x y = HasEdist.edist ↑x ↑y
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] {a b : α} (hab : a ≠ b) : Closure (Set.Ioc a b) = Set.Icc a b
{n : ℕ} {p : Fin n → Prop} [DecidablePred p] : fin.find p = Option.none ↔ ∀ (i : Fin n), ¬p i
{A : Type u_2} {K : Type u_3} [CommRing A] [Field K] [is_IsDomain A] [IsDedekindDomain A] [Algebra A K] [IsFractionRing A K] {J : Ideal A} (hJ : J ≠ ⊤) {ι : Type u_1} (s : Finset ι) (f : ι → K) {j : ι} (hjs : j ∈ s) (hjf : f j ≠ 0) : ∃ (a : K), (∀ (i : ι), i ∈ s → IsLocalization.IsInteger A (a * f i)) ∧ ∃ (i : ι) (H : i ∈ s), a * f i ∉ ↑J
{α : Type u} {a b : α} [MulOneClass α] [HasZero α] [Preorder α] [ZeroLt.MulPosMono α] (ha : 1 ≤ a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} (hx : x ≠ 0) : o.oangle x (-x) = ↑Real.pi
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_5} [NormedGroup E'] [NormedSpace 𝕜 E'] {n : WithTop ℕ} {f : E → E'} {x : E} : ContDiffAt 𝕜 n f x → ContMdiffAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f x
{K : Type u_1} {n : ℕ} {g : GeneralizedContinuedFraction K} [DivisionRing K] (TerminatedAt_n : g.terminated_at n) : g.squash_gcf n = g
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} (p : ι → P) (i : ι) : Finset.centroid k {i} p = p i
{ι : Type u_1} {M : Type u_4} {N : Type u_5} [CommMonoid M] [OrderedCommMonoid N] (f : M → N) (h_One : f 1 = 1) (h_Mul : ∀ (x y : M), f (x * y) ≤ f x * f y) (s : Finset ι) (g : ι → M) : f (s.prod (λ (i : ι), g i)) ≤ s.prod (λ (i : ι), f (g i))
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type w} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace 𝕜] {f : E →ₗ[𝕜] F} (hF : f.ker = ⊥) [FiniteDimensional 𝕜 E] : ClosedEmbedding ⇑f
{α : Type u_1} {β : Type u_2} [LinearOrder α] [SuccOrder α] [Preorder β] {f : α → β} (hF : Monotone f) : Pairwise (Disjoint on λ (n : α), Set.Ioc (f n) (f (Order.succ n)))
{n : ℕ} (p i : Fin n) : p.pred_above (⇑((⇑fin.cast_Succ p).succ_above) i) = i
{F : Type u_8} {G : Type u_1} {H : Type u_2} [AddGroup G] [AddZeroClass H] [AddMonoidHomClass F G H] (f : F) : Function.Injective ⇑f ↔ ∀ (a : G), ⇑f a = 0 ↔ a = 0
{α : Type u_1} {c : Set (Set α)} (H : ∀ (a : α), ∃! (b : Set α) (H : b ∈ c), a ∈ b) {y : α} : {x : α | (setoid.mk_Classes c H).rel x y} ∈ c
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] (Z : TopologicalFiberBundleCore ι B F) (i j : ι) : (Z.local_triv_as_LocalEquiv i).symm.trans (Z.local_triv_as_LocalEquiv j) ≈ (Z.triv_change i j).to_LocalEquiv
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hD : DiffContOnCl ℂ f {z : ℂ | 0 < z.re}) (hexp : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hre : Filter.IsBoundedUnder has_le.le filter.at_Top (λ (x : ℝ), ∥f ↑x∥)) (him : ∀ (x : ℝ), ∥f (↑x * Complex.i)∥ ≤ C) (hz : 0 ≤ z.re) : ∥f z∥ ≤ C
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [StrictConvexSpace ℝ E] {x y : E} {a b r : ℝ} (hx : ∥x∥ ≤ r) (hy : ∥y∥ ≤ r) (hne : x ≠ y) (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : ∥a • x + b • y∥ < r
{M : Type u_1} [Monoid M] {x y : M} : y ∈ Submonoid.closure {x} ↔ ∃ (n : ℕ), x ^ n = y
{α : Type u} [PseudoMetricSpace α] {s : Set α} : 0 ≤ Metric.diam s
{G : Type u_1} [AddGroup G] [TopologicalSpace G] [TopologicalAddGroup G] {H : AddSubgroup G} (h_1_Int : 0 ∈ Interior ↑H) : is_IsOpen ↑H
{α : Type u_1} [Bornology α] {s : Set α} : Bornology.IsBounded s → BoundedSpace ↥s
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {p : P} {ps : Set P} (h : p ∈ affine_Span k ps) : affine_Span k (HasInsert.insert p ps) = affine_Span k ps
{R : Type u} [CommGroup R] [StarSemigroup R] (x y : R) : HasStar.star (x / y) = HasStar.star x / HasStar.star y
{R : Type u_1} [LinearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] [NoZeroSmulDivisors R M] {v : M} (hv : v ≠ 0) {r : R} (hr : r ≠ 0) : SameRay R (r • v) v ↔ 0 < r
{R : Type u_1} {M : Type u_3} [MonoidWithZero R] [HasZero M] [MulActionWithZero R M] [sM : Subsingleton M] : IsSmulRegular M 0
{F : Type} [CommSemiring F] {q : ℕ} {f g : Polynomial F} (hF : Polynomial.IsSeparableContraction q f g) : ∃ (m : ℕ), g.nat_degree * q ^ m = f.nat_degree
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) {X : C} (S : CategoryTheory.Sieve X) : J₁.is_IsClosed S ↔ J₁.close S = S
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) : CategoryTheory.Exact f g ↔ Category_theory.limits.image_Subobject f = Category_theory.limits.kernel_Subobject g
{ι : Type u_2} {R : Type u_3} [DecidableEq ι] [AddMonoid ι] [CommSemiring R] : DirectSum.IsInternal (AddMonoidAlgebra.grade R)
{G : Type u_1} [AddGroup G] {N : Type u_3} [AddGroup N] (H : AddSubgroup G) {f : G →+ N} (hF : Function.bijective ⇑f) : AddSubgroup.map f H.normalizer = (AddSubgroup.map f H).normalizer
{α : Type u_2} [DecidableEq α] [has_Add α] {u : Finset α} {s t : Set α} : ↑u ⊆ s + t → (∃ (s' t' : Finset α), ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' + t')
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.NormalMonoCategory C] {X Y : C} (f : X ⟶ Y) (Z : C) (l : CategoryTheory.Limits.IsColimit (Category_theory.limits.cokernel_cofork.of_π 0 _)) : CategoryTheory.Epi f
{B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] : IsTrivialTopologicalFiberBundle F Prod.snd
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {a : α} {s : Set α} (f : α → M) (h : a ∉ s) (hs : s.finite) : finsum (λ (i : α), finsum (λ (H : i ∈ HasInsert.insert a s), f i)) = f a + finsum (λ (i : α), finsum (λ (H : i ∈ s), f i))
(R : Type u) [Semiring R] [Nontrivial R] (p : ℕ) [hp : Char_p R p] [hq : ExpChar R 1] : p = 0
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : Rˣ) : (λ (t : R), Ring.inverse (↑x + t) - ↑x⁻¹) =O[nhds 0] λ (t : R), ∥t∥
{M : Type u_1} [Monoid M] {x : M} : 1 ∈ Powers x
{α : Type u_3} {β : Type u_4} {γ : Type u_5} [AddCommMonoid α] {g : γ → β} (hg : Function.Injective g) {f : β → α} (hF : ∀ (x : β), x ∉ Set.Range g → f x = 0) : Filter.map (λ (s : Finset γ), s.sum (λ (i : γ), f (g i))) filter.at_Top = Filter.map (λ (s : Finset β), s.sum (λ (i : β), f i)) filter.at_Top
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : HasDist.dist p3 p1 = HasDist.dist p3 p2) : EuclideanGeometry.angle p3 (midpoint ℝ p1 p2) p1 = Real.pi / 2
{R : Type u_1} {E : Type u_2} {ι : Type u_4} [LinearOrderedField R] [AddCommGroup E] [Module R E] {s : Set E} {t : Finset ι} {w : ι → R} {z : ι → E} (hs : Convex R s) : (∀ (i : ι), i ∈ t → 0 ≤ w i) → 0 < t.sum (λ (i : ι), w i) → (∀ (i : ι), i ∈ t → z i ∈ s) → t.center_mass w z ∈ s
{R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [Π (i : ι), Module R (M₁ i)] [Module R M₂] {M₁' : ι → Type u_1} [Π (i : ι), AddCommMonoid (M₁' i)] [Π (i : ι), Module R (M₁' i)] (f : Π (i : ι), M₁ i →ₗ[R] M₁' i) (hF : ∀ (i : ι), Function.Surjective ⇑(f i)) : Function.Injective (λ (g : MultilinearMap R M₁' M₂), g.comp_Linear_Map f)
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] : ⊥.direction = ⊥
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : ∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * ⇑is_R_or_C.re (HasInner.inner x y) + ∥y∥ ^ 2
(α : Type u) [PseudoEmetricSpace α] [SigmaCompactSpace α] : TopologicalSpace.SecondCountableTopology α
{𝕂 : Type u_1} [is_R_or_C 𝕂] {x : 𝕂} : HasDerivAt (Exp 𝕂) (Exp 𝕂 x) x
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (ha : ContinuousAt f a) : HasDerivAt (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) (-f a) a
(R : Type u) (L : Type v) (M : Type w) [CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M] {N : LieSubmodule R L M} (h₁ : N ≤ lie_module.max_triv_Submodule R L M) (h₂ : LieModule.IsNilpotent R L (M ⧸ N)) : LieModule.IsNilpotent R L M
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x : V} (hx : x ≠ 0) (θ : Real.Angle) : x = ⇑(hb.rotation θ) x ↔ θ = 0
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [AddCommMonoid α] [TopologicalSpace α] [HasContinuousAdd α] [RegularSpace α] {f : β × γ → α} {g : β → α} {a : α} (ha : HasSum f a) (hF : ∀ (b : β), HasSum (λ (c : γ), f (b, c)) (g b)) : HasSum g a
{α : Type u} [Preorder α] {a b c : α} : b ≤ c → a ≤ b → a ≤ c
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] : CategoryTheory.Preadditive_coyoneda ⋙ (Category_theory.whiskering_Right C AddCommGroup (Type v)).obj (CategoryTheory.forget AddCommGroup) = CategoryTheory.coyoneda
{α : Type u_1} (f : Poly α) : IsPoly ⇑f
{α : Type u} {β : α → Type u} {κ : Cardinal} (hκ : Cardinal.sum (λ (a : α), κ ^ Cardinal.mk (β a)) ≤ κ) : Cardinal.mk (W_Type β) ≤ κ
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasInitial C] : CategoryTheory.Limits.HasZeroObject C
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {f g : E → F} (hF : ContDiff 𝕜 n f) (hg : ContDiff 𝕜 n g) : ContDiff 𝕜 n (λ (x : E), f x + g x)
(p : ℕ) [hp : Fact (Nat.Prime p)] (a : Zmod p) (hap : a ≠ 0) : Multiset.map (λ (x : ℕ), (a * ↑x).val_min_abs.nat_Abs) (Finset.ico 1 (p / 2).succ).val = Multiset.map (λ (a : ℕ), a) (Finset.ico 1 (p / 2).succ).val
{α : Type u_1} [TopologicalSpace α] {𝕜 : Type u_5} [TopologicalSpace 𝕜] [Field 𝕜] [TopologicalRing 𝕜] {s : Subalgebra 𝕜 C(α, 𝕜)} (h : s.separates_points) : ↑s.separates_points_strongly
{R : Type u_1} [CommRing R] (M : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] (N : Submonoid S) (T : Type u_4) [CommRing T] [Algebra R T] [Algebra S T] [IsScalarTower R S T] [IsLocalization M S] [IsLocalization N T] (H : ∀ (x : S), IsUnit x → x ∈ N) : IsLocalization (Submonoid.comap (Algebra_Map R S).to_MonoidHom N) T
{τ : Type u_1} {α : Type u_2} [CanonicallyOrderedAddMonoid τ] {ϕ : τ → α → α} {s : Set α} : IsFwInvariant ϕ s ↔ IsInvariant ϕ s
{α : Type u} [PseudoEmetricSpace α] {s : Set α} : emetric.Hausdorff_edist s s = 0
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [FiniteDimensional 𝕜 E] [FiniteDimensional 𝕜 F] (A : E →ₗ[𝕜] F) (B : F →ₗ[𝕜] E) : A = ⇑LinearMap.adjoint B ↔ ∀ (x : E) (y : F), HasInner.inner (⇑A x) y = HasInner.inner x (⇑B y)
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] [Fintype α] [Fintype β] (f : α → β) {w : α → M} {b : M} [LinearOrderedCancelAddCommMonoid M] (hb : finset.univ.sum (λ (x : α), w x) < Fintype.card β • b) : ∃ (y : β), (Finset.filter (λ (x : α), f x = y) Finset.univ).sum (λ (x : α), w x) < b
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = ↑Real.pi
{R : Type u_4} {S : Type u_5} [HasMul R] [has_Add R] [HasMul S] [has_Add S] (e : R ≃+* S) (x y : R) : ⇑e (x + y) = ⇑e x + ⇑e y
{M : Type u_3} {F : Type u_8} {G : Type u_1} [AddGroup G] [AddMonoid M] [AddMonoidHomClass F G M] {f g : F} {x : G} (h : ⇑f x = ⇑g x) : ⇑f (-x) = ⇑g (-x)
{α : Type u_1} {β : Type u_2} [UniformSpace α] {l : Filter β} {f₁ f₂ f₃ : β → α} (h₁₂ : Filter.Tendsto (λ (x : β), (f₁ x, f₂ x)) l (Uniformity α)) (h₂₃ : Filter.Tendsto (λ (x : β), (f₂ x, f₃ x)) l (Uniformity α)) : Filter.Tendsto (λ (x : β), (f₁ x, f₃ x)) l (Uniformity α)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X Y : C} [CategoryTheory.Limits.HasBinaryBiproduct X Y] : CategoryTheory.Limits.biprod.fst ≫ CategoryTheory.Limits.biprod.inl + CategoryTheory.Limits.biprod.snd ≫ CategoryTheory.Limits.biprod.inr = 𝟙 (X ⊞ Y)
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] [FiniteDimensional F E] (h : ∀ (x : E), FiniteDimensional.finrank F ↥F⟮x⟯ ≤ 1) : ⊥ = ⊤
(n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ Nat.Prime p
{α : Type u} [MulZeroClass α] [HasDistribNeg α] : -0 = 0
{R : Type u} {A : Type w} [CommSemiring R] [Semiring A] [Algebra R A] (r : R) (x : A) : ⇑(Algebra_Map R A) r * x = x * ⇑(Algebra_Map R A) r
{α : Type u_1} {c : Set (Set α)} (hc : setoid.is_Partition c) {s : Set α} (h : s ∈ c) : s.nonempty
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type w} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace 𝕜] {ι : Type u_1} [Fintype ι] (v : Basis ι 𝕜 E) : ∃ (C : ℝ) (H : C > 0), ∀ {u : E →L[𝕜] F} {M : ℝ}, 0 ≤ M → (∀ (i : ι), ∥⇑u (⇑v i)∥ ≤ M) → ∥u∥ ≤ C * M
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] [Nonempty V] : G.max_degree < Fintype.card V
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {F : J ⥤ C} {X : C} (h : Category_theory.yoneda.obj X ⋙ Category_theory.ulift_Functor ≅ F.cones) {Y : C} (f : Y ⟶ X) : Category_theory.limits.is_limit.of_Nat_iso.cone_of_hom h f = (Category_theory.limits.is_limit.of_Nat_iso.limit_cone h).extend f
{α : Type u_1} {β : Type u_2} [UniformSpace α] [UniformSpace β] [SeparatedSpace α] {s : Set α} {f : α → β} (hs : is_IsCompact s) (hF : ContinuousOn f s) : UniformContinuousOn f s
{a b c : ℤ} (h : fermat_42 a b c) : ∃ (a0 b0 c0 : ℤ), fermat_42.minimal a0 b0 c0
{M : Type u_1} [AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M →+ P} {T : AddSubmonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [AddCommMonoid Q] {k : T.localization_Map Q} (z : N) : ⇑(k.to_Map) (⇑g ↑((f.sec z).snd)) + ⇑(f.map hy k) z = ⇑(k.to_Map) (⇑g (f.sec z).fst)
{β : Type u_2} [CommMonoid β] {n : ℕ} (f : Fin (n + 1) → β) (x : Fin (n + 1)) : finset.univ.prod (λ (i : Fin (n + 1)), f i) = f x * finset.univ.prod (λ (i : Fin n), f (⇑(x.succ_above) i))
{n : ℕ} {a : Cardinal} : n • a < Cardinal.aleph_0 ↔ n = 0 ∨ a < Cardinal.aleph_0
{α : Type u} {ι : sort x} {f : ι → Filter α} [hn : Nonempty α] (hD : Directed GE f) (hb : ∀ (i : ι), (f i).ne_IsBot) : (infi f).ne_IsBot
{α : Type u_3} {β : Type u_4} [LinearOrderedField α] {l : Filter β} {f : β → α} {r : α} (hr : 0 < r) (hF : Filter.Tendsto f l filter.at_IsBot) : Filter.Tendsto (λ (x : β), r * f x) l filter.at_IsBot
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (v : M) {r : R} (h : 0 < r) : SameRay R v (r • v)
{α : Type u} {β : Type v} {f : α → β} {a : Filter α} {b₁ b₂ : Filter β} (hF : Filter.Tendsto f a b₁) [a.ne_IsBot] (hb : Disjoint b₁ b₂) : ¬Filter.Tendsto f a b₂
{S : Type u_1} [has_Add S] (a : S) : AddCommute a a
{A : Type u_2} [CommRing A] [is_IsDomain A] [IsDedekindDomain A] {P : Ideal A} (hP : P ≠ ⊥) : Prime P ↔ P.is_Prime
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {b : M} [LinearOrderedCommRing M] (hF : ∀ (a : α), a ∈ s → f a ∈ t) (ht : t.card • b < ↑(s.card)) : ∃ (y : β) (H : y ∈ t), b < ↑((Finset.filter (λ (x : α), f x = y) s).card)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (θ : Real.Angle) : ⇑LinearMap.det ↑((hb.rotation θ).to_LinearEquiv) = 1
(p : ℕ) [Fact (Nat.Prime p)] (a : (Zmod p)ˣ) : a ^ (p - 1) = 1
{α : Type u} {l : List α} : l.nodup → l.sublists.nodup
(R : CommRing) (M : Submonoid ↥R) (x : PrimeSpectrum (Localization M)) : CategoryTheory.IsIso (algebraic_geometry.PresheafedSpace.stalk_Map (algebraic_geometry.Spec.to_PresheafedSpace.map (CommRing.of_hom (Algebra_Map ↥R (Localization M))).op) x)
 : Filter.Tendsto Real.exp (nhds 0) (nhds 1)
{M : Type u_1} [Monoid M] {γ : Type u_2} [Monoid γ] {f : M → γ} (hF : IsMonoidHom f) : IsSubmonoid (Set.Range f)
{α : Type u} [AddGroup α] [HasLe α] [CovariantClass α α has_add.add has_le.le] {a b c : α} : b ≤ -a + c → a + b ≤ c
{f : Nat.Partrec.Code → Nat.Partrec.Code} (hF : Computable f) : ∃ (c : Nat.Partrec.Code), (f c).eval = c.eval
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {f : E → 𝕜} {g : E → F} (hF : ContDiff 𝕜 n f) (hg : ContDiff 𝕜 n g) : ContDiff 𝕜 n (λ (x : E), f x • g x)
{α : Type u_1} [ConditionallyCompleteLattice α] {s t : Set α} (sne : s.nonempty) (tne : t.nonempty) (hst : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ t → x ≤ y) : (UpperBounds s ∩ LowerBounds t).nonempty
{r : Nnreal} : ⊤ - ↑r = ⊤
{R : Type u_1} {M : Type u_3} [MonoidWithZero R] [HasZero M] [MulActionWithZero R M] [nM : Nontrivial M] : ¬IsSmulRegular M 0
{α : Type u_1} [GeneralizedBooleanAlgebra α] [DecidableRel Disjoint] [DecidableRel has_le.le] {s : Finset α} {u v a : α} (ha : a ∈ Uv.compression u v s) (hva : v ≤ a) (hua : Disjoint u a) : (a ⊔ u)  v ∈ s
{α : Type u} [HasSubset α] {a b : α} [IsAntisymm α HasSubset.Subset] (h : a ⊆ b) (h' : b ⊆ a) : a = b
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 ∈ s) (hp2 : p2 ∈ s) : p1 -ᵥ p2 ∈ s.direction
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) : o.oangle y x = -o.oangle x y
{J : Type u₁} [CategoryTheory.Category J] [Nonempty J] (h : ∀ (j₁ j₂ : J), CategoryTheory.Zigzag j₁ j₂) : CategoryTheory.IsConnected J
{p : ℕ} {G : Type u_1} [Group G] (hG : is_p_Group p G) [hp : Fact (Nat.Prime p)] (α : Type u_2) [MulAction G α] [Fintype α] [Fintype ↥(MulAction.FixedPoints G α)] (hpα : p ∣ Fintype.card α) {a : α} (ha : a ∈ MulAction.FixedPoints G α) : ∃ (b : α), b ∈ MulAction.FixedPoints G α ∧ a ≠ b
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : o.oangle (-x) y = o.oangle x y + ↑Real.pi
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} {p : ι → P} (ha : AffineIndependent k (λ (x : ↥(Set.Range p)), ↑x)) (hi : Function.Injective p) : AffineIndependent k p
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {X Y Z X' Y' Z' : C} (f : X ⟶ Y) [CategoryTheory.Limits.HasCokernel f] (g : Y ⟶ Z) (w : f ≫ g = 0) (f' : X' ⟶ Y') [CategoryTheory.Limits.HasCokernel f'] (g' : Y' ⟶ Z') (w' : f' ≫ g' = 0) (p : X ⟶ X') (q : Y ⟶ Y') (r : Z ⟶ Z') (h₁ : f ≫ q = p ≫ f') (h₂ : g ≫ r = q ≫ g') : CategoryTheory.Limits.cokernel.map f f' p q h₁ ≫ CategoryTheory.Limits.cokernel.desc f' g' w' = CategoryTheory.Limits.cokernel.desc f g w ≫ r
{α : Type u_2} [AddMonoid α] (m : α) : Even m → (∃ (c : α), m = 2 • c)
(R : Type u) [NonAssocRing R] (p : ℕ) [hc : Char_p R p] [Fintype R] : p ≠ 0
(R : Type u) [Ring R] [StrongRankCondition R] {ι : Type v} (M : ι → Type w) [Π (i : ι), AddCommGroup (M i)] [Π (i : ι), Module R (M i)] [∀ (i : ι), Module.Free R (M i)] : Module.rank R (DirectSum ι (λ (i : ι), M i)) = Cardinal.sum (λ (i : ι), Module.rank R (M i))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : Finset P} {p : P} (hp : p ∈ s) : Vector_Span k ↑s = Submodule.span k ↑(Finset.image (λ (_x : P), _x -ᵥ p) (s.erase p))
(R : Type u) (M : Type v) [Ring R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] (N : Type v) [AddCommGroup N] [Module R N] [Module.Free R N] : Module.rank R (M × N) = Module.rank R M + Module.rank R N
{R : Type u_1} [MonoidWithZero R] {f : Nat.ArithmeticFunction R} : f.is_Multiplicative ↔ ⇑f 1 = 1 ∧ ∀ {m n : ℕ}, m ≠ 0 → n ≠ 0 → m.coprime n → ⇑f (m * n) = ⇑f m * ⇑f n
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] (c : Con M) (f : M →* P) (H : c ≤ Con.ker f) (h : Function.Injective ⇑(c.lift f H)) : Con.ker f = c
{n : ℕ} {E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f : (Fin (n + 1) → ℂ) → E} {c : Fin (n + 1) → ℂ} {R : Fin (n + 1) → ℝ} (hF : TorusIntegrable f c R) (i : Fin (n + 1)) : ∯ (x : Fin (n + 1) → ℂ) in T(c, R), f x = ∮ (x : ℂ) in C(c i, R i), ∯ (y : Fin n → ℂ) in T(c ∘ ⇑(i.succ_above), R ∘ ⇑(i.succ_above)), f (i.insert_nth x y)
{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), n ≤ m → P n → P (n - 1)) (n : ℤ) : n ≤ m → P n
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {a b : α} (h : a ⊂ b) : ¬b ⊆ a
(s : ℝ) : (λ (x : ℝ), x ^ s) =o[filter.at_Top] Real.exp
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι} {s : Set α} : TendstoUniformlyOn F f p s ↔ Filter.Tendsto (λ (q : ι × α), (f q.snd, F q.fst q.snd)) (p.prod (Filter.principal s)) (Uniformity β)
{R : Type u_1} [CommSemiring R] (M : Submonoid R) {S : Type u_2} [CommSemiring S] [Algebra R S] [IsLocalization M S] (z : S) : z * ⇑(Algebra_Map R S) ↑((IsLocalization.sec M z).snd) = ⇑(Algebra_Map R S) (IsLocalization.sec M z).fst
{X : Type u_2} [EmetricSpace X] [TopologicalSpace.SecondCountableTopology X] (s : Set X) : (⨆ (x : X) (H : x ∈ s), (nhds_within x s).small_sets.limsup dimH) = dimH s
{R : Type u} {a : R} [Semiring R] {p : Polynomial R} (h : a * p.leading_Coeff ≠ 0) : (⇑Polynomial.c a * p).nat_degree = p.nat_degree
{α : Type u_1} [DecidableEq α] [Fintype α] (f : Equiv.perm α) {x : α} : (f.cycle_of x).is_Cycle ↔ ⇑f x ≠ x
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrderedAddCommGroup α] [OrderTopology α] {l : Filter β} {f g : β → α} {C : α} (hF : Filter.Tendsto f l filter.at_IsBot) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (λ (x : β), f x + g x) l filter.at_IsBot
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [LinearOrderedAddCommMonoid β] [HasScalar 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f : E → β} (hF : ConcaveOn 𝕜 s f) {x y : E} (hx : x ∈ s) (hy : y ∈ s) {a b : 𝕜} (ha : 0 ≤ a) (hb : 0 ≤ b) (hab : a + b = 1) : Linear_order.min (f x) (f y) ≤ f (a • x + b • y)
(R : Type u_1) [Rack R] (G : Type u_2) [Group G] (f : ShelfHom R (Quandle.Conj G)) (g : Rack.EnvelGroup R →* G) (h : f = (Quandle.Conj.map g).comp (rack.to_EnvelGroup R)) : g = ⇑rack.to_envel_group.map f
{K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [NeZero 2] {k : ℕ} (hk : 2 ≤ k) [IsCyclotomicExtension {2 ^ k} K L] (hirr : Irreducible (Polynomial.cyclotomic (2 ^ k) K)) : ⇑(Algebra.norm K) (IsCyclotomicExtension.zeta (2 ^ k) K L - 1) = 2
{α : Type u} {β : Type v} [AddGroup α] [AddGroup β] {f : α → β} (hF : ∀ (x y : α), f (x + y) = f x + f y) : IsAddGroupHom f
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {g : F → G} {f : E → F} (hg : ContDiff 𝕜 n g) (hF : ContDiff 𝕜 n f) : ContDiff 𝕜 n (g ∘ f)
{k : Type u_1} {E : Type u_2} [LinearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k → E} {a b r : k} (hab : a < b) (h₀ : 0 < r) (h₁ : r < 1) : ⇑(affine_map.line_Map (f a) (f b)) r ≤ f (⇑(affine_map.line_Map a b) r) ↔ slope f (⇑(affine_map.line_Map a b) r) b ≤ slope f a (⇑(affine_map.line_Map a b) r)
{X : Top} (F : Top.Presheaf (Type v) X) (Fsh : F.is_sheaf_Unique_gluing) : F.is_sheaf
{𝕜 : Type u_3} [is_R_or_C 𝕜] {n m : ℕ} (A B : Matrix (Fin n) (Fin m) 𝕜) (i j : Fin n) : HasInner.inner (A i) (B j) = B.mul A.conj_transpose j i
{M : Type u_1} [AddZeroClass M] {s : Set M} {p : M → M → Prop} {x y : M} (hx : x ∈ AddSubmonoid.closure s) (hy : y ∈ AddSubmonoid.closure s) (Hs : ∀ (x : M), x ∈ s → ∀ (y : M), y ∈ s → p x y) (H1_Left : ∀ (x : M), p 0 x) (H1_Right : ∀ (x : M), p x 0) (hMul_Left : ∀ (x y z : M), p x z → p y z → p (x + y) z) (hMul_Right : ∀ (x y z : M), p z x → p z y → p z (x + y)) : p x y
{α : Type u} [TopologicalSpace α] {s : Set α} {ι : Type v} [hι : Nonempty ι] (hs : is_IsCompact s) (U : ι → Set α) (hUo : ∀ (i : ι), is_IsOpen (U i)) (hsU : s ⊆ ⋃ (i : ι), U i) (hdU : Directed HasSubset.Subset U) : ∃ (i : ι), s ⊆ U i
{α : Type u_1} [UniformSpace α] : (Uniformity α).has_Basis (λ (s : Set (α × α)), s ∈ Uniformity α ∧ SymmetricRel s) Id
{𝕜 : Type u_1} {E : Type u_3} [OrderedSemiring 𝕜] [TopologicalSpace E] [AddCommGroup E] [Module 𝕜 E] [HasContinuousAdd E] {s : Set E} (hs : StrictConvex 𝕜 s) (x : E) : StrictConvex 𝕜 (x +ᵥ s)
{V : Type u_1} [InnerProductSpace ℝ V] {P : Type u_2} [MetricSpace P] [NormedAddTorsor V P] {a b c d p : P} (h : EuclideanGeometry.Cospherical {a, b, c, d}) (hapc : EuclideanGeometry.angle a p c = Real.pi) (hbpd : EuclideanGeometry.angle b p d = Real.pi) : HasDist.dist a b * HasDist.dist c d + HasDist.dist b c * HasDist.dist d a = HasDist.dist a c * HasDist.dist b d
{R : Type u_1} [LinearOrderedField R] [FloorRing R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : r < ↑b ^ x ↔ Int.log b r < x
{α : Type u_1} [TopologicalSpace α] [PolishSpace α] [MeasurableSpace α] [BorelSpace α] {s : Set α} (hs : MeasurableSet s) : PolishSpace.IsClopenable s
{ι : Type u_1} {R : Type u_3} {M : Type u_5} {v : ι → M} [Ring R] [AddCommGroup M] [Module R M] {hli : LinearIndependent R v} {hsp : Submodule.span R (Set.Range v) = ⊤} {i j : ι} : ⇑((Basis.mk hli hsp).coord i) (v j) = Ite (j = i) 1 0
{p n : ℕ} (h_Pos : 0 < ⇑(n.central_binom.factorization) p) : p ≤ 2 * n
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : ℝ} {c w : ℂ} {f : ℂ → E} {s : Set ℂ} (hs : s.countable) (hw : w ∈ Metric.Ball c R) (hc : ContinuousOn f (Metric.ClosedBall c R)) (hD : ∀ (x : ℂ), x ∈ Metric.Ball c R  s → DifferentiableAt ℂ f x) : (2 * ↑Real.pi * Complex.i)⁻¹ • ∮ (z : ℂ) in C(c, R), (z - w)⁻¹ • f z = f w
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder β] [SuccOrder β] [IsSuccArchimedean β] {s : β → Set α} {t : Set β} (hnt : t.nonempty) (ht : t.ord_connected) (H : ∀ (n : β), n ∈ t → IsConnected (s n)) (K : ∀ (n : β), n ∈ t → Order.succ n ∈ t → (s n ∩ s (Order.succ n)).nonempty) : IsConnected (⋃ (n : β) (H : n ∈ t), s n)
{R : Type v} [CommRing R] (A : Matrix (Fin 2) (Fin 2) R) : A.det = A 0 0 * A 1 1 - A 0 1 * A 1 0
(R : Type u_3) (M : Type u_4) [AddCommMonoid M] [Semiring R] [Module R M] (tr : Add_monoid.is_torsion R) : Add_monoid.is_torsion M
{α : Type u} [TopologicalSpace α] {p : α → Prop} {a : α} (h : ∀ᶠ (y : α) in nhds a, p y) : p a
{G : Type u_1} [Group G] (h : group.is_nilpotent (G ⧸ Subgroup.center G)) : group.is_nilpotent G
{G : Type u_1} [hG : Group G] [hF : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (h : is_p_Group p G) : group.is_nilpotent G
{P : Type u_2} [MetricSpace P] (p : P) : EuclideanGeometry.Cospherical {p}
{K : Type u_1} [LinearOrderedField K] [FloorRing K] (v : K) : (GeneralizedContinuedFraction.of v).terminates ↔ ∃ (q : ℚ), v = ↑q
{E : Type u_1} {PE : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [MetricSpace PE] [NormedAddTorsor E PE] {x y : PE} (e : PE ≃ᵢ PE) : ⇑e x = x → ⇑e y = y → ⇑e (midpoint ℝ x y) = midpoint ℝ x y
(S T : Set ℕ+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension T A B] (hS : S ⊆ T) : IsCyclotomicExtension S A ↥(Algebra.adjoin A {b : B | ∃ (a : ℕ+), a ∈ S ∧ b ^ ↑a = 1})
{R : Type u_1} (M : Type u_3) {a : R} [Monoid R] [MulAction R M] (ua : IsUnit a) : IsSmulRegular M a
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {t : Affine.Triangle ℝ P} (ho : t.orthocenter ∉ Set.Range t.points) {p : Fin 3 → P} (hps : Set.Range p ⊆ HasInsert.insert t.orthocenter (Set.Range t.points)) (hpi : Function.Injective p) : (∃ (i₁ i₂ i₃ j₂ j₃ : Fin 3), i₁ ≠ i₂ ∧ i₁ ≠ i₃ ∧ i₂ ≠ i₃ ∧ (∀ (i : Fin 3), i = i₁ ∨ i = i₂ ∨ i = i₃) ∧ p i₁ = t.orthocenter ∧ j₂ ≠ j₃ ∧ t.points j₂ = p i₂ ∧ t.points j₃ = p i₃) ∨ Set.Range p = Set.Range t.points
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] (S : Set M) (h : S.finite) : CompleteLattice.IsCompactElement (Submodule.span R S)
{α : Type u_1} {r : α → α → Prop} (H : WellFounded r) (s : Set α) : s.nonempty → (∃ (a : α) (H : a ∈ s), ∀ (x : α), x ∈ s → ¬r x a)
{E : Type u_1} [InnerProductSpace ℝ E] {ι : Type u_2} [Fintype ι] [DecidableEq ι] [Nonempty ι] {e : Basis ι ℝ E} (h : Orthonormal ℝ ⇑e) (x : Orientation ℝ E ι) : Orthonormal ℝ ⇑(e.adjust_to_Orientation x)
{α : Type u_1} {E' : Type u_6} {E'' : Type u_9} [SemiNormedGroup E'] [NormedGroup E''] {f' : α → E'} {l : Filter α} {c : E''} (hc : c ≠ 0) : (λ (x : α), c) =O[l] f' ↔ ∃ (b : ℝ), 0 < b ∧ ∀ᶠ (x : α) in l, b ≤ ∥f' x∥
{G : Type u} {n : ℕ} [Fintype G] [AddLeftCancelMonoid G] (x : G) : Add_order_of (n • x) = Add_order_of x / (Add_order_of x).gcd n
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] [CompleteSpace 𝕜] {f f' : 𝕜 → 𝕜} (hF : ∀ (x : 𝕜), HasStrictDerivAt f (f' x) x) (h0 : ∀ (x : 𝕜), f' x ≠ 0) : is_is_IsOpenMap f
{R : Type u_1} [CommRing R] {S : Type u_2} [CommRing S] {p : Ideal R} {P : Ideal S} [Algebra R S] [Algebra (R ⧸ p) (S ⧸ P)] [IsScalarTower R (R ⧸ p) (S ⧸ P)] (h : Function.Injective ⇑(Algebra_Map (R ⧸ p) (S ⧸ P))) : Ideal.comap (Algebra_Map R S) P = p
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {k : S.localization_Map P} (z : N) : ⇑(k.lift _) (⇑(f.lift _) z) = z
{α : Type u} {β : Type v} [PseudoMetricSpace α] [PseudoMetricSpace β] {f : α → β} {x : α} {r : ℝ} (hr : 0 < r) (K : ℝ) (h : ∀ (y : α), HasDist.dist y x < r → HasDist.dist (f y) (f x) ≤ K * HasDist.dist y x) : ContinuousAt f x
{α : Type u_1} {β : Type u_2} (f : α → β) : Function.Injective (Quotient.lift f _)
{𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] {f : 𝕜 → G} {s : Set 𝕜} {x y : 𝕜} {C : ℝ} (hF : ∀ (x : 𝕜), x ∈ s → DifferentiableAt 𝕜 f x) (bound : ∀ (x : 𝕜), x ∈ s → ∥deriv f x∥ ≤ C) (hs : Convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
{M : Type u_2} [AddCommGroup M] {𝕜 : Type u_1} [Field 𝕜] [Module 𝕜 M] {f : M →ₗ[𝕜] M} (hF : ⇑LinearMap.det f = 0) : f.range < ⊤
{α : Type u_1} {β : Type u_2} [PseudoEmetricSpace α] [Nonempty β] [SemilatticeSup β] {s : β → α} : CauchySeq s ↔ ∃ (b : β → Ennreal), (∀ (n m N : β), N ≤ n → N ≤ m → HasEdist.edist (s n) (s m) ≤ b N) ∧ Filter.Tendsto b filter.at_Top (nhds 0)
{α : Type u_1} {β : Type u_2} [UniformSpace α] (f : β → α) (l : Filter β) : Filter.Tendsto (λ (x : β), (f x, f x)) l (Uniformity α)
{δ : Type u_1} [Fintype δ] {κ : δ → Type u_2} {t : Π (d : δ), Set (κ d)} (ht : ∀ (d : δ), (t d).finite) : (set.univ.pi t).finite
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] (f : M →* P) {x y : M} : ⇑(Con.ker f) x y ↔ ⇑f x = ⇑f y
{C : Type u} [CategoryTheory.Category C] {J₁ J₂ : CategoryTheory.GrothendieckTopology C} (h : CategoryTheory.Presieve.IsSheaf J₁ (Category_theory.functor.closed_sieves J₂)) : J₁ ≤ J₂
(E : Type u_1) [AddCommGroup E] : Subsingleton (Module ℚ E)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x : V) (θ : Real.Angle) : x = ⇑(hb.rotation θ) x ↔ x = 0 ∨ θ = 0
{α : Type u} [TopologicalSpace α] {s : Set α} : IsConnected s ↔ ∀ (U : Finset (Set α)), (∀ (u v : Set α), u ∈ U → v ∈ U → (s ∩ (u ∩ v)).nonempty → u = v) → (∀ (u : Set α), u ∈ U → is_IsOpen u) → s ⊆ ⋃₀↑U → (∃ (u : Set α) (H : u ∈ U), s ⊆ u)
{G : Type u_1} [AddCommGroup G] (K : AddSubgroup G) {ι : Type u_2} {t : Finset ι} {f : ι → G} (h : ∀ (c : ι), c ∈ t → f c ∈ K) : t.sum (λ (c : ι), f c) ∈ K
(𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} [LinearOrder ι] [OrderBot ι] [LocallyFiniteOrder ι] [IsWellOrder ι has_lt.lt] (f : ι → E) (n : ι) : gram_schmidt 𝕜 f n = f n - (Finset.iio n).sum (λ (i : ι), ↑(⇑(Orthogonal_projection (Submodule.span 𝕜 {gram_schmidt 𝕜 f i})) (f n)))
(n : ℕ) : (List.Nat.antidiagonal n).nodup
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {p : FormalMultilinearSeries 𝕜 E F} [CompleteSpace F] : ContinuousOn p.sum (Emetric.Ball 0 p.radius)
{α J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.FinCategory J] [SemilatticeInf α] [OrderTop α] (F : J ⥤ α) : CategoryTheory.Limits.limit F = finset.univ.inf F.obj
{α : Type u_1} [SemiNormedRing α] [NormOneClass α] (a : α) (n : ℕ) : ∥a ^ n∥₊ ≤ ∥a∥₊ ^ n
{G : Type u_1} [CategoryTheory.Groupoid G] [IsFreeGroupoid G] {X : Type v} [Group X] (f g : G ⥤ CategoryTheory.SingleObj X) (h : ∀ (a b : IsFreeGroupoid.Generators G) (e : a ⟶ b), f.map (IsFreeGroupoid.of e) = g.map (IsFreeGroupoid.of e)) : f = g
(n : ℕ) {R : Type u_1} [LinearOrderedCommRing R] {x : R} (hx : 1 ≤ x) : 0 ≤ Polynomial.eval x (Polynomial.cyclotomic n R)
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (l : List (Matrix n n α)) : (l.prod)⁻¹ = (List.map has_inv.inv l.reverse).prod
{R : Type u} [Semiring R] {P : Ideal R} (hmax : ∀ (m : Ideal R), P < m → ¬m.is_Maximal) (J : Ideal R) (hPJ : P < J) : J = ⊤
{C : Type u₁} [CategoryTheory.Category C] {A : Type u₂} [CategoryTheory.Category A] (P : Cᵒᵖ ⥤ A) [CategoryTheory.Limits.HasPullbacks C] (K : CategoryTheory.Pretopology C) : CategoryTheory.Presheaf.IsSheaf (Category_theory.pretopology.to_grothendieck C K) P ↔ ∀ ⦃X : C⦄ (R : CategoryTheory.Presieve X), R ∈ ⇑K X → Nonempty (CategoryTheory.Limits.IsLimit (P.map_cone (CategoryTheory.Sieve.generate R).arrows.cocone.op))
{β : Type u} {α : Type v} [AddCommMonoid β] {s : Finset α} {f : α → β} {a : α} (hp : s.sum (λ (x : α), f x) = 0) (h1 : ∀ (x : α), x ∈ s → x ≠ a → f x = 0) (x : α) (H : x ∈ s) : f x = 0
{E : Type u_1} (R : Type u_2) (S : Type u_3) [AddCommGroup E] [DivisionRing R] [DivisionRing S] [Module R E] [Module S E] (n : ℤ) (x : E) : (↑n)⁻¹ • x = (↑n)⁻¹ • x
{E : Type u_3} {F : Type u_4} [SemiNormedGroup E] [SemiNormedGroup F] (f : E →+ F) (C : ℝ) (h : ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥) : Continuous ⇑f
{α : Type u} [PseudoEmetricSpace α] {δ₁ δ₂ : ℝ} (δ₂_Pos : 0 < δ₂) (hlt : δ₁ < δ₂) (E : Set α) : Metric.Cthickening δ₁ E ⊆ Metric.Thickening δ₂ E
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (f : α → C(β, γ)) (h : Continuous (Function.uncurry (λ (x : α) (y : β), ⇑(f x) y))) : Continuous f
{α : Type u} [TopologicalSpace α] [LocallyCompactSpace α] [RegularSpace α] {K U : Set α} (hK : is_IsCompact K) (hU : is_IsOpen U) (hKU : K ⊆ U) : ∃ (K' : Set α), is_IsCompact K' ∧ K ⊆ Interior K' ∧ K' ⊆ U
(n : ℕ+) (x : ℂˣ) : x ∈ roots_of_unity n ℂ ↔ ∃ (i : ℕ) (H : i < ↑n), Complex.exp (2 * ↑Real.pi * Complex.i * (↑i / ↑n)) = ↑x
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] (p : Fin 3 → P) : Collinear k (Set.Range p) ↔ ¬AffineIndependent k p
{α : Type u_1} {β : Type u_2} {t₁ t₂ : TopologicalSpace α} {t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₁) {s : Set α} {f : α → β} (h₂ : ContinuousOn f s) : ContinuousOn f s
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] {f : α → β} {s : Set α} {a : α} (h_Mono : StrictMonoOn f s) (hs : s ∈ nhds_within a (Set.Ici a)) (hfs : ∀ (b : β), b > f a → (∃ (c : α) (H : c ∈ s), f c ∈ Set.Ioc (f a) b)) : ContinuousWithinAt f (Set.Ici a) a
{C : Type u} [CategoryTheory.Category C] {X Y Z : AlgebraicGeometry.PresheafedSpace C} (α : X ⟶ Y) (β : Y ⟶ Z) (U : (TopologicalSpace.Opens ↥(Z.carrier))ᵒᵖ) : (α ≫ β).c.app U = β.c.app U ≫ α.c.app (Opposite.op ((TopologicalSpace.Opens.map β.base).obj (Opposite.unop U)))
{n k : ℕ} : k ≤ n → (n - k).factorial * n.desc_factorial k = n.factorial
{a b : ℝ} (h : a < b) : Cardinal.mk ↥(Set.Ioo a b) = Cardinal.continuum
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {f : α → γ} {x : α} {y : β} (hF : ContinuousAt f x) : ContinuousAt (λ (x : α × β), f x.fst) (x, y)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {f : 𝕜 → F} {s : Set 𝕜} {x : 𝕜} (hxs : UniqueDiffWithinAt 𝕜 s x) : iterated_deriv_within (n + 1) f s x = deriv_within (iterated_deriv_within n f s) s x
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [FiniteDimensional 𝕜 E] {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) {ι : Type u_4} [Fintype ι] [DecidableEq ι] {V : ι → Submodule 𝕜 E} (hV : DirectSum.IsInternal V) (hV' : OrthogonalFamily 𝕜 (λ (i : ι), (V i).subtypeₗᵢ)) : Orthonormal 𝕜 ⇑(direct_sum.is_internal.subordinate_Orthonormal_Basis hn hV)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall f p x r) : TendstoLocallyUniformlyOn (λ (n : ℕ) (y : E), p.partial_Sum n y) (λ (y : E), f (x + y)) filter.at_Top (Emetric.Ball 0 r)
{α : Type u} [EmetricSpace α] : Continuous (λ (p : α × TopologicalSpace.Closeds α), emetric.inf_edist p.fst ↑(p.snd))
(R : Type u) [Semiring R] {ι : Type v} [decι : DecidableEq ι] {M : ι → Type w} [Π (i : ι), AddCommMonoid (M i)] [Π (i : ι), Module R (M i)] (s : Finset ι) (c : R) (x : Π (i : ↥↑s), M i.val) : ⇑(DirectSum.mk M s) (c • x) = c • ⇑(DirectSum.mk M s) x
{α : Type u_1} [PseudoEmetricSpace α] (r C : Ennreal) {f : ℕ → α} (hu : ∀ (n : ℕ), HasEdist.edist (f n) (f (n + 1)) ≤ C * r ^ n) {a : α} (ha : Filter.Tendsto f filter.at_Top (nhds a)) (n : ℕ) : HasEdist.edist (f n) a ≤ C * r ^ n / (1 - r)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] (p₁ p₂ : P) : Collinear k {p₁, p₂}
{α : Type u_1} [DecidableEq α] : ∅.shadow = ∅
{R : Type u_1} {S : Type u_2} {M : Type u_3} {s : S} [HasScalar R M] [HasScalar R S] [HasScalar S M] [IsScalarTower R S M] (a : R) (Ab : IsSmulRegular M (a • s)) : IsSmulRegular M s
{α : Type u_1} [SemiNormedGroup α] {r C : ℝ} {f : ℕ → α} (hr : r < 1) (hF : ∀ (n : ℕ), ∥f n∥ ≤ C * r ^ n) {a : α} (ha : HasSum f a) (n : ℕ) : ∥(Finset.range n).sum (λ (x : ℕ), f x) - a∥ ≤ C * r ^ n / (1 - r)
{J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ AddMon) [CategoryTheory.IsFiltered J] {x x' y : Σ (j : J), ↥(F.obj j)} (hxx' : CategoryTheory.Limits.Types.FilteredColimit.Rel (F ⋙ CategoryTheory.forget AddMon) x x') : AddMon.filtered_colimits.colimit_Add_aux F x y = AddMon.filtered_colimits.colimit_Add_aux F x' y
{M : Type u_3} [Monoid M] [Preorder M] (L : List M) (h : L.prod < 1) : 0 < L.length
{α : Type u_1} [TopologicalSpace α] {s t : Set α} (hs : is_Gδ s) (ht : is_Gδ t) : is_Gδ (s ∪ t)
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) : o.oangle 0 x = 0
(n : ℕ) : n.totient = n / n.factors.to_finset.prod (λ (p : ℕ), p) * n.factors.to_finset.prod (λ (p : ℕ), p - 1)
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) {r : ℝ} (hr : 0 ≤ r) : o.oangle x (r • x) = 0
{C : Type u} [CategoryTheory.Category C] {A B : C} {f g : A ⟶ B} [CategoryTheory.IsCoreflexivePair f g] : CategoryTheory.IsCoreflexivePair g f
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] (G : Set A) (hG : ∀ (x : A), x ∈ G → IsIntegral R x) (x : A) (H : x ∈ Subring.closure G) : IsIntegral R x
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) [CategoryTheory.Limits.HasLimitsOfSize D] [CategoryTheory.CreatesLimitsOfSize F] : CategoryTheory.Limits.HasLimitsOfSize C
 : ¬Summable (λ (n : ℕ), 1 / ↑n)
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.NormalMonoCategory C] [CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X ⟶ Y) (hF : ∀ (Z : C) (g : Y ⟶ Z), f ≫ g = 0 → g = 0) : CategoryTheory.Epi f
{R₁ : Type u_1} {R₂ : Type u_2} [Semiring R₁] [Semiring R₂] {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_4} [TopologicalSpace M₁] [AddCommMonoid M₁] {M₂ : Type u_6} [TopologicalSpace M₂] [AddCommMonoid M₂] [Module R₁ M₁] [Module R₂ M₂] [RingHomSurjective σ₁₂] [TopologicalSpace R₁] [TopologicalSpace R₂] [HasContinuousSmul R₁ M₁] [HasContinuousAdd M₁] [HasContinuousSmul R₂ M₂] [HasContinuousAdd M₂] (f : M₁ →sl[σ₁₂] M₂) (s : Submodule R₁ M₁) : Submodule.map ↑f s.topological_Closure ≤ (Submodule.map ↑f s).topological_Closure
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [HasScalar 𝕜 E] {s : Set E} : Convex 𝕜 s ↔ ∀ ⦃a b : 𝕜⦄, 0 ≤ a → 0 ≤ b → a + b = 1 → a • s + b • s ⊆ s
{M : Type u_1} [has_Add M] {N : Type u_2} [has_Add N] (f : AddHom M N) (hF : Function.Surjective ⇑f) : f.srange = ⊤
{ι : Type u_1} {E : ι → Type u_2} [Π (i : ι), MetricSpace (E i)] (i : ι) : Isometry (Sigma.mk i)
(x : ℝ) : Real.cosh x = (Real.exp x + Real.exp (-x)) / 2
{α : Type u} [AddGroup α] [HasLe α] [CovariantClass α α has_add.add has_le.le] [CovariantClass α α (Function.swap has_add.add) has_le.le] {a b : α} : a ≤ -b → b ≤ -a
{α : Type u} [PartialOrder α] {a b : α} (h : a ≤ b) : b = a ∨ a < b
(n : ℕ) : ↑(Nat.fib n) = (GoldenRatio ^ n - golden_Conj ^ n) / Real.sqrt 5
{S : Set ℕ} (hb : 0 ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) (n : ℕ) : n ∈ S
{E : Type u_1} [InnerProductSpace ℝ E] {c : E} (f : ContDiffBumpOfInner c) (x : E) : 0 ≤ ⇑f x
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] {A : Set X} {f : X → Y} {x : X} (h : ∃ (y : Y), Filter.Tendsto f (nhds_within x A) (nhds y)) : Filter.Tendsto f (nhds_within x A) (nhds (extend_from A f x))
(R : Type u) (M : Type v) [Ring R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] : FiniteDimensional.finrank R M = Fintype.card (Module.Free.ChooseBasisIndex R M)
{α : Type u} [AddGroup α] [HasLe α] [CovariantClass α α has_add.add has_le.le] [CovariantClass α α (Function.swap has_add.add) has_le.le] {a b : α} : -a ≤ -b → b ≤ a
(A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {p : Polynomial A} (pmonic : p.monic) (hp : ⇑(Polynomial.aeval x) p = 0) (pmin : ∀ (q : Polynomial A), q.monic → ⇑(Polynomial.aeval x) q = 0 → p.degree ≤ q.degree) : p = minpoly A x
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (i : Fin r ⊕ Unit) {k : ℕ} (hk : k ≤ r) : (List.drop k (matrix.pivot.list_transvec_col M)).prod.mul M (Sum.inr ()) i = M (Sum.inr ()) i
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f₂ : 𝕜 → F} {s₂ : Set 𝕜} (hs : is_IsOpen s₂) : ContDiffOn 𝕜 ⊤ f₂ s₂ ↔ DifferentiableOn 𝕜 f₂ s₂ ∧ ContDiffOn 𝕜 ⊤ (deriv f₂) s₂
{β : Type u} {α : Type v} [CommMonoid β] [DecidableEq α] (s : Finset α) {f : α → β} {a : α} (h : f a = 1) : (s.erase a).prod (λ (x : α), f x) = s.prod (λ (x : α), f x)
{G : Type u_1} [Group G] {s : Set G} {x c : G} : x ∈ group.conjugates_OfSet s → c * x * c⁻¹ ∈ group.conjugates_OfSet s
{α : Type u} [Group α] [HasLe α] [CovariantClass α α has_mul.mul has_le.le] {a b c : α} : a ≤ b * c → b⁻¹ * a ≤ c
{R : Type u_1} [NonAssocRing R] [Nontrivial R] [NoZeroDivisors R] (hR : Ring_Char R ≠ 2) {a : R} : -a = a ↔ a = 0
{G : Type u_1} [AddGroup G] {ι : sort u_2} (S : ι → AddSubgroup G) {C : G → Prop} {x : G} (hx : x ∈ ⨆ (i : ι), S i) (hp : ∀ (i : ι) (x : G), x ∈ S i → C x) (h1 : C 0) (hMul : ∀ (x y : G), C x → C y → C (x + y)) : C x
{n : Type u_1} {𝕜 : Type u_3} [Field 𝕜] [DecidableEq n] [Fintype n] (P : Matrix n n 𝕜 → Prop) (M : Matrix n n 𝕜) (hMdet : M.det ≠ 0) (hdiag : ∀ (D : n → 𝕜), (Matrix.diagonal D).det ≠ 0 → P (Matrix.diagonal D)) (htransvec : ∀ (t : Matrix.TransvectionStruct n 𝕜), P t.to_Matrix) (hMul : ∀ (A B : Matrix n n 𝕜), A.det ≠ 0 → B.det ≠ 0 → P A → P B → P (A.mul B)) : P M
{S : Type u_2} [CommRing S] {R : Type u_3} [CommRing R] [Algebra R S] {A : Type u_4} [CommRing A] [Algebra R A] [Algebra S A] [IsScalarTower R S A] {B : PowerBasis S A} (hB : IsIntegral R B.gen) [is_IsDomain S] {x : A} (hx : ∀ (i : Fin B.dim), IsIntegral R (⇑(⇑(B.basis.repr) x) i)) (hmin : minpoly S B.gen = Polynomial.map (Algebra_Map R S) (minpoly R B.gen)) (n : ℕ) (i : Fin B.dim) : IsIntegral R (⇑(⇑(B.basis.repr) (x ^ n)) i)
{R : Type u} {ι : Type v} {M₁ : ι → Type w₁} {M₂ : Type w₂} [DecidableEq ι] [CommSemiring R] [Π (i : ι), AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [Π (i : ι), Module R (M₁ i)] [Module R M₂] [Π (i : ι), TopologicalSpace (M₁ i)] [TopologicalSpace M₂] (f : ContinuousMultilinearMap R M₁ M₂) [Fintype ι] (c : ι → R) (m : Π (i : ι), M₁ i) : ⇑f (λ (i : ι), c i • m i) = finset.univ.prod (λ (i : ι), c i) • ⇑f m
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {a : F} (ha : a ≠ 0) : char.quadratic_Char F (a ^ 2) = 1
{α : Type u} [TopologicalSpace α] {s : Set α} [DiscreteTopology ↥s] {x : α} (hx : x ∈ s) : nhds_within x s = has_pure.pure x
{α : Type u_1} [CanonicallyLinearOrderedAddMonoid α] [HasSub α] [HasOrderedSub α] {a b c : α} (ha : AddLeCancellable a) (hb : AddLeCancellable b) (h : b ≤ a) : a - b < a - c ↔ c < b
{A : Type u_4} [CommRing A] [is_IsDomain A] {K : Type u_5} [Field K] {L : Type u_7} [Field L] [Algebra A K] [IsFractionRing A K] {g : A →+* L} (hg : Function.Injective ⇑g) (x : A) : ⇑(IsFractionRing.lift hg) (⇑(Algebra_Map A K) x) = ⇑g x
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) : o.oangle x y + o.oangle y x = 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {s₁ s₂ : AffineSubspace k P} (hD : s₁.direction = s₂.direction) (hn : ↑s₁.nonempty) (hle : s₁ ≤ s₂) : s₁ = s₂
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.ConcreteCategory.forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.ConcreteCategory.forget C)] {X : Top} (F : Top.Sheaf C X) {ι : Type v} (U : ι → TopologicalSpace.Opens ↥X) (V : TopologicalSpace.Opens ↥X) (iUV : Π (i : ι), U i ⟶ V) (hcover : V ≤ supr U) (s t : ↥(F.val.obj (Opposite.op V))) (h : ∀ (i : ι), ⇑(F.val.map (iUV i).op) s = ⇑(F.val.map (iUV i).op) t) : s = t
{α : Type u_1} {o p : Part α} (H1 : o.dom ↔ p.dom) (H2 : ∀ (h₁ : o.dom) (h₂ : p.dom), o.get h₁ = p.get h₂) : o = p
{α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) : Vector.scanl f b Vector.nil = b::ᵥVector.nil
{α : Type u_1} {β : Type u_2} [LinearOrder α] [LinearOrder β] {f : α → β} (h₁ : StrictMono f) (A B : Finset α) : (Finset.image f A).to_colex ≤ (Finset.image f B).to_colex ↔ A.to_colex ≤ B.to_colex
{α : Type u} [PseudoEmetricSpace α] {s : Set α} : Continuous (λ (x : α), emetric.inf_edist x s)
{α : Type u_1} [LinearOrderedField α] {a b c d : α} (hc : c ≠ 0) (hD : d ≠ 0) : (a * d - b * c) / (c * d) ≤ 0 → a / c ≤ b / d
{α : Type u_1} [TopologicalSpace α] {U : Set α} {hU : is_IsOpen U} : ↑⟨U, hU⟩ = U
{α : Type u_1} {β : Type u_2} [UniformSpace β] {f : α → β} {x : α} [TopologicalSpace α] (L : ∀ (u : Set (β × β)), u ∈ Uniformity β → (∃ (t : Set α) (H : t ∈ nhds x) (F : α → β), ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u)) : ContinuousAt f x
{X : Type u_1} [TopologicalSpace X] [Infinite X] [DiscreteTopology X] : ¬Continuous ⇑(cofinite_topology.of.symm)
{𝕜 : Type u_3} [is_R_or_C 𝕜] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {f f' : 𝕜 → G} {x : 𝕜} (hder : ∀ᶠ (y : 𝕜) in nhds x, HasDerivAt f (f' y) y) (hcont : ContinuousAt f' x) : HasStrictDerivAt f (f' x) x
{n : ℕ} (a : Fin (n + 1)) : ↑(a.val) = a
{g : Equiv.perm (Fin 5)} (ha : g ∈ alternating_Group (Fin 5)) (h1 : g ≠ 1) (h2 : ∀ (n : ℕ), n ∈ g.cycle_Type → n = 2) : IsConj (equiv.swap 0 4 * equiv.swap 1 3) g
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] (Z : TopologicalFiberBundleCore ι B F) : is_is_IsOpenMap Z.proj
{α : Type u} {β : Type v} [PseudoMetricSpace α] [PseudoMetricSpace β] {K : Nnreal} {s : Set α} {f : α → β} : LipschitzOnWith K f s → ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → HasDist.dist (f x) (f y) ≤ ↑K * HasDist.dist x y
{M : Type u_1} [HasMul M] {β : sort u_2} (c : Con M) (f : M → β) (h : ∀ (a b : M), ⇑c a b → f a = f b) (x : M) : con.lift_on ↑x f h = f x
{R : Type u_1} [CommRing R] {c₁ c₂ : R} (q : QuaternionAlgebra R c₁ c₂) : ⇑CliffordAlgebra_quaternion.of_Quaternion (⇑QuaternionAlgebra.conj q) = ⇑CliffordAlgebra.involute (⇑CliffordAlgebra.reverse (⇑CliffordAlgebra_quaternion.of_Quaternion q))
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜} (hs : Convex 𝕜 s) (hF : ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) < (f y - f x) / (y - x)) : StrictConcaveOn 𝕜 s f
{α : Type u_1} {ι : sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α} {t : Set α} (hl : l.has_Basis p s) : t ∈ l ↔ ∃ (i : ι) (hi : p i), s i ⊆ t
{α : Type u_1} {β : α → Type u_2} {γ : Type u_3} [Π (a : α), AddCommMonoid (β a)] (s : Finset γ) (g : γ → Π (a : α), β a) : s.sum (λ (c : γ), g c) = λ (a : α), s.sum (λ (c : γ), g c a)
{n : ℕ} {α : Fin (n + 1) → Type u} (x : α (fin.last n)) (p : Π (i : Fin n), α (⇑fin.cast_Succ i)) (i : Fin n) (y : α (⇑fin.cast_Succ i)) : fin.snoc (Function.update p i y) x = Function.update (fin.snoc p x) (⇑fin.cast_Succ i) y
{X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X] {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : metric.Hausdorff_dist (Set.Range (Gromov_Hausdorff.optimal_GH_injl X Y)) (Set.Range (Gromov_Hausdorff.optimal_GH_injr X Y)) = Gromov_Hausdorff.GH_dist X Y
{α : Type u} [OrderedSemiring α] {a b c d : α} [HasExistsAddOfLe α] (hba : b ≤ a) (hdc : d ≤ c) : a • d + b • c ≤ a • c + b • d
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) : o.oangle x 0 = 0
{α : Type u} [PseudoEmetricSpace α] (δ : ℝ) (E : Set α) : Metric.Thickening δ E = (λ (x : α), emetric.inf_edist x E) ⁻¹' Set.Iio (ennreal.of_Real δ)
{M : Type u_3} {S : Type u_4} [DivInvMonoid M] [SetLike S M] [hSM : SubgroupClass S M] {H : S} {x y : M} (hx : x ∈ H) (hy : y ∈ H) : x / y ∈ H
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜} (hF : StrictConvexOn 𝕜 s f) {x y z : 𝕜} (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) : (f y - f x) / (y - x) < (f z - f y) / (z - y)
{R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] [Nontrivial R] (x : R) : IsAlgebraic R (⇑(Algebra_Map R A) x)
{G : Type u} [Group G] {x : G} (hx : IsOfFinOrder x) : IsOfFinOrder x⁻¹
{α : Type u} [LinearOrder α] {x y : α} : x < y ∨ y < x ↔ x ≠ y
(n : ℕ) : ∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace ↥K] : reflection K * reflection K = 1
(K : Type u) {L : Type v} (E : Type z) [Field K] [Field L] [Field E] [Algebra K L] [Algebra K E] [Module.Finite K L] [IsAlgClosed E] (pB : PowerBasis K L) (e : Fin pb.dim ≃ (L →ₐ[K] E)) [IsSeparable K L] : ⇑(Algebra_Map K E) (Algebra.discr K ⇑(pb.basis)) = finset.univ.prod (λ (i : Fin pb.dim), (Finset.filter (λ (j : Fin pb.dim), i < j) Finset.univ).prod (λ (j : Fin pb.dim), (⇑(⇑e j) pb.gen - ⇑(⇑e i) pb.gen) ^ 2))
{a b : Cardinal} (ha : Cardinal.aleph_0 ≤ a) : a + b = Linear_order.max a b
{S : Type u_2} [CommRing S] {R : Type u_3} [CommRing R] [Algebra R S] {A : Type u_4} [CommRing A] [Algebra R A] [Algebra S A] [IsScalarTower R S A] {B : PowerBasis S A} (hB : IsIntegral R B.gen) [is_IsDomain S] {x y : A} (hx : ∀ (i : Fin B.dim), IsIntegral R (⇑(⇑(B.basis.repr) x) i)) (hy : ∀ (i : Fin B.dim), IsIntegral R (⇑(⇑(B.basis.repr) y) i)) (hmin : minpoly S B.gen = Polynomial.map (Algebra_Map R S) (minpoly R B.gen)) (i : Fin B.dim) : IsIntegral R (⇑(⇑(B.basis.repr) (x * y)) i)
{R : Type u} {ι : Type u'} {M₂ : Type v₂} [DecidableEq ι] [Semiring R] [AddCommMonoid M₂] [Module R M₂] {M₁' : ι → Type u_1} [Π (i : ι), AddCommMonoid (M₁' i)] [Π (i : ι), Module R (M₁' i)] (g : MultilinearMap R M₁' M₂) : g.comp_Linear_Map (λ (i : ι), LinearMap.id) = g
{a : Ennreal} (h : a ≠ ⊤) : AddLeCancellable a
{α : Type u_1} {β : Type u_2} [UniformSpace α] [UniformSpace β] [CompactSpace α] [SeparatedSpace α] {f : α → β} (h : Continuous f) : UniformContinuous f
(α : Type u_1) (β : Type u_2) [LinearOrder α] [LinearOrder β] [Encodable α] [DenselyOrdered β] [Nontrivial β] : Nonempty (α ↪o β)
{α : Type u} [NonUnitalRing α] {a b c : α} (h : a ∣ c) : a ∣ b + c ↔ a ∣ b
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R : CategoryTheory.Presieve X} {x₁ x₂ : CategoryTheory.Presieve.FamilyOfElements P ⇑(CategoryTheory.Sieve.generate R)} (t₁ : x₁.compatible) (t₂ : x₂.compatible) : CategoryTheory.Presieve.FamilyOfElements.restrict _ x₁ = CategoryTheory.Presieve.FamilyOfElements.restrict _ x₂ → x₁ = x₂
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {s : Set E} {f : E → F} (hF : ContDiffOn 𝕜 n f s) : ContDiffOn 𝕜 n (λ (x : E), -f x) s
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {a b : α} (h : a < b) (s : Set α) : [s ∈ nhds_within b (Set.Iio b), s ∈ nhds_within b (Set.Ico a b), s ∈ nhds_within b (Set.Ioo a b), ∃ (l : α) (H : l ∈ Set.Ico a b), Set.Ioo l b ⊆ s, ∃ (l : α) (H : l ∈ Set.Iio b), Set.Ioo l b ⊆ s].tfae
{α : Type u_2} {β : Type u_3} {f : α → β} (hF : Function.Injective f) : Filter.Tendsto f Filter.cofinite Filter.cofinite
{α : Type u} {β : Type v} [TopologicalSpace α] [PseudoMetricSpace β] {x : α} : Continuous (λ (f : BoundedContinuousFunction α β), ⇑f x)
{γ : Type w} [MetricSpace γ] {x y : γ} : HasNndist.nndist x y = 0 → x = y
{R : Type u_1} {M : Type u_2} [AddCommMonoid M] [CommRing R] [Nontrivial R] [h : Algebra.FiniteType R (AddMonoidAlgebra R M)] : Add_monoid.fg M
{α : Type u} [TopologicalSpace α] (x : α) [(nhds_within x {x}ᶜ).ne_IsBot] : Interior {x} = ∅
{m : Type u_1} {n : Type u_2} {R : Type u_3} {S : Type u_4} [CommSemiring R] [CommSemiring S] (f : R →+* S) (A : Matrix m n S) : (matrix.mv_Polynomial.x m n R).map (MvPolynomial.eval₂ f (λ (p : m × n), A p.fst p.snd)) = A
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M →* P} (hg : ∀ (y : ↥S), IsUnit (⇑g ↑y)) (x : M) (y : ↥S) : ⇑(f.lift hg) (f.mk' x y) = ⇑g x * ↑(⇑(is_unit.lift_Right (g.restrict S) hg) y)⁻¹
{α : Type uu} [DecidableEq α] {l₁ l₂ : List α} (h : ∀ (x : α), x ∈ l₁ → List.count x l₁ ≤ List.count x l₂) : l₁ ++ l₂.diff l₁ ~ l₂
{α : Type u} {f g : α → α} (h : Function.Commute f g) : Set.InvOn f g (Function.FixedPoints (f ∘ g)) (Function.FixedPoints (f ∘ g))
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (p1 p2 : P) : EuclideanGeometry.angle p1 p2 p2 = Real.pi / 2
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) : 2 • hb.oangle x (-y) = 2 • hb.oangle x y
{α : Type u_1} {E : Type u_3} [SemiNormedGroup E] {l : Filter α} {f : α → E} (h : Filter.Tendsto (λ (y : α), ∥f y∥) l filter.at_Top) (x : E) : ∀ᶠ (y : α) in l, f y ≠ x
{α : Type u_1} [Preorder α] {a b : α} (h : a ≤ b) : Set.Iio a ⊆ Set.Iic b
{R : Type u_1} {a : R} [Monoid R] (n : ℕ) (ra : IsRegular a) : IsRegular (a ^ n)
{α : Type u_2} {β : Type u_3} [Ring α] [is_IsDomain α] [Ring β] (f : β →+* α) (hF : Function.Injective ⇑f) : is_IsDomain β
{α : Type u} {β : Type v} {γ : Type w} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderTopology β] [Nonempty γ] {f : α → β} {g : γ → α} (Cf : ContinuousAt f (⨅ (i : γ), g i)) (Mf : Monotone f) (H : BddBelow (Set.Range g)) : f (⨅ (i : γ), g i) = ⨅ (i : γ), f (g i)
{α : Type u_1} {β : Type u_2} [Fintype α] [Fintype β] (f : α → β) (h : Fintype.card β < Fintype.card α) : ∃ (x y : α), x ≠ y ∧ f x = f y
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {n : ℕ} (hn : FiniteDimensional.finrank K V = n.succ) : Nontrivial V
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (hb : ContinuousAt f b) : deriv (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) b = f b
{R : Type u} [Semiring R] (p q : Polynomial R) (n : ℕ) : (p * q).coeff n = (Finset.Nat.antidiagonal n).sum (λ (x : ℕ × ℕ), p.coeff x.fst * q.coeff x.snd)
{C : Type u₁} [CategoryTheory.Category C] {X Y : Top} (f : X ⟶ Y) [CategoryTheory.Limits.HasProducts C] {F : Top.Presheaf C X} (h : F.is_sheaf) : (f _* F).is_sheaf
(n : ℕ) : Filter.Tendsto (λ (x : ℝ), x ^ n * Real.exp (-x)) filter.at_Top (nhds 0)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p : P) (h : s.sum (λ (i : ι), w i) = 1) : ⇑(s.affine_combination (λ (_x : ι), p)) w = p
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderClosedTopology α] [Nonempty α] {s : Set α} (hs : is_IsCompact s) : BddBelow s
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z → B} [TopologicalSpace Z] (h : IsTopologicalFiberBundle F Proj) : Continuous Proj
{α : Type u_1} [TopologicalSpace α] [NonAssocRing α] [HasContinuousMul α] : HasContinuousNeg α
{α : Type u} [PseudoEmetricSpace α] {δ : ℝ} (E : Set α) : E ⊆ Metric.Cthickening δ E
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {p : P} {s : Set P} (hp : p ∈ s) : p ∈ affine_Span k s
{R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] (S : Subalgebra R A) : S.is_algebraic ↔ Algebra.IsAlgebraic R ↥S
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasInitial C] [CategoryTheory.Limits.HasPushouts C] : CategoryTheory.Limits.HasBinaryCoproducts C
{R : Type u_1} [CommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {C : TensorAlgebra R M → Prop} (h_grade0 : ∀ (r : R), C (⇑(Algebra_Map R (TensorAlgebra R M)) r)) (h_grade1 : ∀ (x : M), C (⇑(TensorAlgebraι R) x)) (h_Mul : ∀ (a b : TensorAlgebra R M), C a → C b → C (a * b)) (h_Add : ∀ (a b : TensorAlgebra R M), C a → C b → C (a + b)) (a : TensorAlgebra R M) : C a
{α : Type u} {β : Type v} [TopologicalSpace α] [Preorder α] [t : OrderClosedTopology α] {f g : β → α} {b : Filter β} {a₁ a₂ : α} [b.ne_IsBot] (hF : Filter.Tendsto f b (nhds a₁)) (hg : Filter.Tendsto g b (nhds a₂)) (h : f ≤ᶠ[b] g) : a₁ ≤ a₂
{α : Type u_1} [LinearOrder α] [DecidableEq α] {p : Finset α → Prop} (s : Finset α) (h0 : p ∅) (step : ∀ (a : α) (s : Finset α), (∀ (x : α), x ∈ s → x < a) → p s → p (HasInsert.insert a s)) : p s
{R : Type u_1} [CommRing R] (g : Matrix.SpecialLinearGroup (Fin 2) R) : IsCoprime (↑g 1 0) (↑g 1 1)
(α : Type u) [Preorder α] [Nonempty α] [NoMinOrder α] [NoMaxOrder α] : ∃ (f : ℤ → α), StrictAnti f
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [UniformSpace α] [UniformSpace β] [SeparatedSpace α] [LocallyCompactSpace α] [CompactSpace β] [SeparatedSpace β] [UniformSpace γ] (f : α → β → γ) (h : Continuous ↿f) (x : α) : TendstoUniformly f (f x) (nhds x)
{K : Type u_1} [Field K] [NumberField K] : number_field.class_number K = 1 ↔ IsPrincipalIdealRing ↥(number_field.ring_of_integers K)
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : ∥x - y∥ = ∥x∥ + ∥y∥ ↔ InnerProductGeometry.angle x y = Real.pi
{𝕜 : Type u} [hnorm : NondiscreteNormedField 𝕜] {E : Type v} [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousSmul 𝕜 E] [CompleteSpace 𝕜] [t2_Space E] {ι : Type u_1} [Fintype ι] (ξ : Basis ι 𝕜 E) : Continuous ⇑(ξ.equiv_fun)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_6} [NormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_10} [SemiNormedGroup E'] [NormedSpace 𝕜 E'] [RingHomIsometric σ₁₂] {f : ℕ → (E' →sl[σ₁₂] F)} {g : E' →sl[σ₁₂] F} (hg : Filter.Tendsto (λ (n : ℕ) (x : E'), ⇑(f n) x) filter.at_Top (nhds ⇑g)) (hF : CauchySeq f) : Filter.Tendsto f filter.at_Top (nhds g)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set ℝ} [Interval_integral.FTC_Filter a (nhds_within a s) (nhds_within a t)] (hmeas : StronglyMeasurableAtFilter f (nhds_within a t) MeasureTheory.MeasureSpace.volume) (ha : ContinuousWithinAt f t a) : HasDerivWithinAt (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) (-f a) s a
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) (θ : Real.Angle) : ⇑(o.rotation θ) x = x ↔ x = 0 ∨ θ = 0
{R : Type u} [NonAssocSemiring R] (s : Set R) : ↑(Subsemiring.closure s) = ↑(AddSubmonoid.closure ↑(Submonoid.closure s))
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {s : Finset ι} {v : ι → E} (hv : Orthonormal 𝕜 v) {a : ι → ι → 𝕜} : s.sum (λ (i : ι), s.sum (λ (j : ι), a i j • HasInner.inner (v j) (v i))) = s.sum (λ (k : ι), a k k)
{K : Type u} {V V₁ : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] [AddCommGroup V₁] [Module K V₁] : Nonempty (V ≃ₗ[K] V₁) ↔ Module.rank K V = Module.rank K V₁
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e e' : LocalHomeomorph α β} (h : e ≈ e') : Set.EqOn ⇑e ⇑e' e.to_local_equiv.source
{α : Type u_1} [LinearOrderedField α] [FloorSemiring α] (m n : ℕ) : ⌊↑m / ↑n⌋₊ = m / n
{K L : Type} [Field K] [Field L] [IsAlgClosed K] [IsAlgClosed L] (p : ℕ) [Char_p K p] [Char_p L p] (hK : Cardinal.aleph_0 < Cardinal.mk K) (hKL : Cardinal.mk K = Cardinal.mk L) : K ≃+* L
{α : Type u_1} [hα : UniformSpace α] (h : Uniformity α = Filter.principal IdRel) : DiscreteTopology α
{b m d : ℕ} (hb : 2 ≤ b) (hD : d ∈ b.digits m) : d < b
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) : o.oangle x (⇑(o.rotation θ) y) = o.oangle x y + θ
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : α ≃ₜ β) {b : β} {f : β → E} {g : β → F} : f =O[nhds b] g ↔ (f ∘ ⇑e) =O[nhds (⇑(e.symm) b)] (g ∘ ⇑e)
(G : AddSubgroup ℝ) : Dense ↑G ∨ ∃ (a : ℝ), G = AddSubgroup.closure {a}
{n : ℕ} {α : Type u_1} [Preorder α] {f : Fin (n + 1) → α} : StrictMono f ↔ ∀ (i : Fin n), f (⇑fin.cast_Succ i) < f i.succ
{R : Type u_1} [CommRing R] {M : Submonoid R} {S : Type u_2} [CommRing S] [Algebra R S] {Rₘ : Type u_4} {Sₘ : Type u_5} [CommRing Rₘ] [CommRing Sₘ] [Algebra R Rₘ] [IsLocalization M Rₘ] [Algebra S Sₘ] [IsLocalization (algebra.algebra_Map_Submonoid S M) Sₘ] (H : Algebra.IsIntegral R S) : (IsLocalization.map Sₘ (Algebra_Map R S) _).is_integral
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasWideEqualizers C] {T : C} (hT : ∀ (X : C), Nonempty (T ⟶ X)) : CategoryTheory.Limits.HasInitial C
{x y : Pgame} : x.lf y ↔ (∃ (i : y.left_moves), x ≤ y.move_Left i) ∨ ∃ (j : x.right_moves), x.move_Right j ≤ y
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} (hx : x ≠ 0) (θ : Real.Angle) : o.oangle x (⇑(o.rotation θ) x) = θ
{G : Type u_1} {H : Type u_2} [Group G] {N : Subgroup G} [Group H] {f : G →* H} (hN : N = f.ker) (tH : monoid.is_torsion H) (tN : monoid.is_torsion ↥N) : monoid.is_torsion G
{α : Type u_1} {β : Type u_2} (e : LocalEquiv α β) : e.symm.trans e ≈ local_equiv.of_Set e.target
{α : Type u_1} {β : Type u_2} [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β} (h : Function.Semiconj g ⇑fa ⇑fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') : Function.Semiconj g' ⇑fb ⇑fa
{V : Type u_1} (α : Type u_2) (G : SimpleGraph V) [DecidableRel G.adj] [MulZeroOneClass α] [Nontrivial α] : _.to_graph = G
{α : Type u_1} {β : Type u_2} {e e' : LocalEquiv α β} (h : e ≈ e') : Set.EqOn ⇑(e.symm) ⇑(e'.symm) e.target
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryProducts C] [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Limits.HasEqualizers C
{R : Type u_1} {M : Type u_2} [CommSemiring R] [AddCommMonoid M] [Module R M] (S : Type u_3) [CommMonoid S] [DistribMulAction S M] [SmulCommClass S R M] : Module.IsTorsion' M S ↔ Submodule.torsion' R M S = ⊤
(ι : Type u_1) [Fintype ι] : is_IsClosed (StdSimplex ℝ ι)
{α : Type u_1} [Preorder α] [SuccOrder α] {a b : α} [NoMaxOrder α] : a < b → Order.succ a < Order.succ b
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} (z : V) (h : InnerProductGeometry.angle x y = Real.pi) : InnerProductGeometry.angle x z + InnerProductGeometry.angle y z = Real.pi
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V} (θ : Real.Angle) : o.oangle x y = θ ↔ x ≠ 0 ∧ y ≠ 0 ∧ y = (∥y∥ / ∥x∥) • ⇑(o.rotation θ) x ∨ θ = 0 ∧ (x = 0 ∨ y = 0)
{β : Type u} {α : Type v} {s : Finset α} {a : α} {f : α → β} [AddCommMonoid β] [DecidableEq α] (h : a ∉ s → f a = 0) : (HasInsert.insert a s).sum (λ (x : α), f x) = s.sum (λ (x : α), f x)
{α : Type u_1} {ι : sort u_4} [CompleteLattice α] (f : ι → α) : (⨅ (i : {i // f i ≠ ⊤}), f ↑i) = ⨅ (i : ι), f i
{α : Type u} [PseudoMetricSpace α] {s : Set α} : metric.Hausdorff_dist s (Closure s) = 0
{𝕜 : Type u_1} {_x : Ring 𝕜} {E : Type u_2} [SemiNormedGroup E] {_x_1 : Module 𝕜 E} {s : Submodule 𝕜 E} (x : ↥s) : ∥↑x∥ = ∥x∥
{n : ℕ} {F : Typevec (n + 1) → Type u} [Mvfunctor F] [q : Mvqpf F] {α : Typevec n} (r : Mvqpf.Cofix F α → Mvqpf.Cofix F α → Prop) (h : ∀ (x y : Mvqpf.Cofix F α), r x y → Mvfunctor.Liftr' (α.rel_Last' r) x.dest y.dest) (x y : Mvqpf.Cofix F α) : r x y → x = y
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {w : α → M} {b : M} [LinearOrderedCancelAddCommMonoid M] (hF : ∀ (a : α), a ∈ s → f a ∈ t) (hb : s.sum (λ (x : α), w x) < t.card • b) : ∃ (y : β) (H : y ∈ t), (Finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x) < b
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] {f : Filter α} {a : α} [f.ne_IsBot] : f ≤ nhds a → f.Limsup = a
{S : Type u} [HasMul S] {a x y : S} (h : SemiconjBy a x y) : a * x = y * a
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] {K : Set α} (f : C(α, β)) (hK : is_IsCompact K) {U : Set β} (hU : is_IsOpen U) (hF : f ∈ ContinuousMap.CompactOpen.Gen K U) : ∃ (V : Set (β × β)) (H : V ∈ Uniformity β), is_IsOpen V ∧ ContinuousMap.CompactConvNhd K V f ⊆ ContinuousMap.CompactOpen.Gen K U
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : ℕ} {i : Fin (n + 1)} : X.σ i ≫ X.δ (⇑fin.cast_Succ i) = 𝟙 (X.obj (Opposite.op (SimplexCategory.mk n)))
{n : ℕ} {α : Fin (n + 1) → Type u} (q : Π (i : Fin (n + 1)), α i) : fin.cons (q 0) (fin.tail q) = q
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] (s : Submodule K V) : Module.rank K ↥s ≤ 1 ↔ ∃ (v₀ : V) (H : v₀ ∈ s), s ≤ Submodule.span K {v₀}
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] (v w : E) (H : w ∈ K) : HasInner.inner (v - Orthogonal_projection_fn K v) w = 0
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {a b : α} (hab : a < b) (s : Set α) : [s ∈ nhds_within a (Set.Ici a), s ∈ nhds_within a (Set.Icc a b), s ∈ nhds_within a (Set.Ico a b), ∃ (u : α) (H : u ∈ Set.Ioc a b), Set.Ico a u ⊆ s, ∃ (u : α) (H : u ∈ Set.Ioi a), Set.Ico a u ⊆ s].tfae
{C : Type u} [CategoryTheory.Category C] {P Q R : C} (f : P ⟶ Q) (g : Q ⟶ R) [CategoryTheory.StrongEpi f] [CategoryTheory.StrongEpi g] : CategoryTheory.StrongEpi (f ≫ g)
{R : Type u_1} [Semiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {N : Type u_3} [AddCommMonoid N] [Module R N] {ι : Type u_6} [DecidableEq ι] {M₂ : Type u_7} [AddCommMonoid M₂] [Module R M₂] {M₃ : Type u_8} [AddCommMonoid M₃] [Module R M₃] (f : AlternatingMap R M N ι) (g₁ : M₂ →ₗ[R] M) (g₂ : M₃ →ₗ[R] M₂) : (f.comp_Linear_Map g₁).comp_Linear_Map g₂ = f.comp_Linear_Map (g₁.comp g₂)
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{R : Type u_1} [CommSemiring R] (s : Subsemiring R) (m : Multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.prod ∈ s
{n n' : ℕ} (m : ℕ) (i : Fin n') (h : n' = n) : ⇑(fin.cast_Add m) (⇑(fin.cast h) i) = ⇑(fin.cast _) (⇑(fin.cast_Add m) i)
{F : Type} [Field F] (q : ℕ) [hq : Fact (Nat.Prime q)] [hF : Char_p F q] (g g' : Polynomial F) (m m' : ℕ) (h_expand : ⇑(Polynomial.expand F (q ^ m)) g = ⇑(Polynomial.expand F (q ^ m')) g') (h : m < m') (hg : g.separable) : g.nat_degree = g'.nat_degree
{α : Type u_1} {n : Type u_4} [CommSemigroup α] [AddCommMonoid α] [Fintype n] [AddCommGroup n] (v w : n → α) : (Matrix.circulant v).mul (Matrix.circulant w) = (Matrix.circulant w).mul (Matrix.circulant v)
{α : Type u} [PseudoMetricSpace α] (x y : α) : HasNndist.nndist x y = (HasDist.dist x y).to_Nnreal
(α : Type u_1) [PartialOrder α] : WellFounded GT ↔ ∀ (a : ℕ →o α), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑a n = ⇑a m
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : HasInner.inner (x + y) (x + y) = HasInner.inner x x + 2 * HasInner.inner x y + HasInner.inner y y
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {n : ℕ} [Fact (FiniteDimensional.finrank 𝕜 E = n + 1)] {v : E} (hv : v ≠ 0) : FiniteDimensional.finrank 𝕜 ↥(Submodule.span 𝕜 {v})ᗮ = n
{V : Type u_4} [InnerProductSpace ℂ V] (T : V →ₗ[ℂ] V) (x y : V) : HasInner.inner (⇑T y) x = (HasInner.inner (⇑T (x + y)) (x + y) - HasInner.inner (⇑T (x - y)) (x - y) + Complex.i * HasInner.inner (⇑T (x + Complex.i • y)) (x + Complex.i • y) - Complex.i * HasInner.inner (⇑T (x - Complex.i • y)) (x - Complex.i • y)) / 4
{ι₁ : Type u_1} {ι₂ : Type u_2} {R : Type u_3} {R₂ : Type u_4} {S : Type u_5} {S₂ : Type u_6} {M : Type u_7} {N : Type u_8} {P : Type u_9} [CommRing R] [CommRing S] [CommRing R₂] [CommRing S₂] [AddCommGroup M] [AddCommGroup N] [AddCommGroup P] [Module R M] [Module S N] [Module R₂ P] [Module S₂ P] [SmulCommClass S₂ R₂ P] {ρ₁₂ : R →+* R₂} {σ₁₂ : S →+* S₂} (b₁ : Basis ι₁ R M) (b₂ : Basis ι₂ S N) {B B' : M →ₛₗ[ρ₁₂] N →ₛₗ[σ₁₂] P} (h : ∀ (i : ι₁) (j : ι₂), ⇑(⇑B (⇑b₁ i)) (⇑b₂ j) = ⇑(⇑B' (⇑b₁ i)) (⇑b₂ j)) : B = B'
{p : ℕ} : Summable (λ (n : ℕ), (↑n ^ p)⁻¹) ↔ 1 < p
{α : Type u_1} {β : Type u_2} [CompleteLattice α] {f : Filter β} : f.liminf (λ (x : β), ⊤) = ⊤
{α : Type u} [MetricSpace α] (x : ℕ → α) (a b : α) : HasDist.dist (Kuratowski_embedding.embedding_of_Subset x a) (Kuratowski_embedding.embedding_of_Subset x b) ≤ HasDist.dist a b
{α : Type u_1} {β : Type u_2} [Fintype α] [CompleteLattice β] (f : α → β) : finset.univ.sup f = supr f
{α : Type u_1} [GeneralizedBooleanAlgebra α] [DecidableRel Disjoint] [DecidableRel has_le.le] (u v : α) (s : Finset α) : (Uv.compression u v s).card = s.card
{R : Type u} {ι : Type w} (s : Finset ι) [CommSemiring R] [NoZeroDivisors R] (f : ι → Polynomial R) [Nontrivial R] : (s.prod (λ (i : ι), f i)).degree = s.sum (λ (i : ι), (f i).degree)
 : ⇑LinearMap.det complex.conj_ae.to_Linear_Map = -1
{R : Type u_1} [LinearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {v₁ v₂ : M} (h : SameRay R v₁ v₂) : ∃ (a b : R), 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ v₁ = a • (v₁ + v₂) ∧ v₂ = b • (v₁ + v₂)
{α : Type u} [PseudoEmetricSpace α] {s : Set α} (hs : is_IsCompact s) : ∃ (t : Set α) (H : t ⊆ s), t.countable ∧ s ⊆ Closure t
{S : Type v} [CommRing S] {R : Type u} (c : ℤ →+* S) (f : MvPolynomial R ℤ →+* S) (x : MvPolynomial R ℤ) : MvPolynomial.eval₂ c (⇑f ∘ MvPolynomial.x) x = ⇑f x
{α : Type u_1} [AddSemigroup α] (x y : α) : has_add.add x ∘ has_add.add y = has_add.add (x + y)
{A : Type u} {B : Type v} {ι : Type w} [CommRing A] [CommRing B] [Algebra A B] [Fintype ι] [DecidableEq ι] (b : ι → B) (P : Matrix ι ι A) : Algebra.discr A (matrix.vec_Mul b (P.map ⇑(Algebra_Map A B))) = P.det ^ 2 * Algebra.discr A b
{b : ℕ} {S : Set ℕ} (hb : b ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) {n : ℕ} (hbn : b ≤ n) : n ∈ S
{G : Type u} [AddGroup G] (H : AddSubgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤
{α : Type u_1} {M : Type u_5} [HasZero M] {f g : α →₀ M} : ⇑f = ⇑g ↔ f = g
{R : Type u} [Ring R] : CategoryTheory.Limits.HasCokernels (Module R)
{α : Type u_1} {β : Type u_2} (t : α) (ts ys : List α) (f : List α → β) : List.map f (list.permutations_aux2 t ts List.nil ys Id).snd = (list.permutations_aux2 t ts List.nil ys f).snd
{f : ℝ → ℝ} (hF : Differentiable ℝ f) (hF'_anti : StrictAnti (deriv f)) : StrictConcaveOn ℝ Set.Univ f
{α : Type u} [PseudoMetricSpace α] {x : α} : Metric.diam {x} = 0
{n : ℕ} : 0 < n → 0 < szemeredi_regularity.step_bound n
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [Module 𝕜 E] {s : Set E} (hs : Convex 𝕜 s) (z : E) : Convex 𝕜 ((λ (x : E), z + x) ⁻¹' s)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : LocalHomeomorph α β} {s : Set α} {t : Set β} : e.is_image s t → e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s = e.to_local_equiv.target ∩ t
{α : Type u_1} (r : α → α → Prop) [IsTrans α r] (f : ℕ → α) : ∃ (g : ℕ ↪o ℕ), (∀ (m n : ℕ), m < n → r (f (⇑g m)) (f (⇑g n))) ∨ ∀ (m n : ℕ), m < n → ¬r (f (⇑g m)) (f (⇑g n))
{M : Type u_1} [AddMonoid M] {x : M} : x ∈ Multiples x
 : Filter.Tendsto Complex.exp (Filter.comap Complex.re filter.at_Top) (Filter.comap Complex.abs filter.at_Top)
{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : Function.Injective Coe_fn
{R S : Type u} [CommRing R] [CommRing S] (M : Submonoid R) (R' : Type u) [CommRing R'] [Algebra R R'] [Algebra R' S] [Algebra R S] [IsScalarTower R R' S] [IsLocalization M R'] (s : Set S) (x : S) (hx : x ∈ Algebra.adjoin R' s) : ∃ (t : ↥M), t • x ∈ Algebra.adjoin R s
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasFiniteCoproducts C] [CategoryTheory.Limits.HasCoequalizers C] : CategoryTheory.Limits.HasFiniteColimits C
{G : Type u_1} [Group G] {k : Set G} {p : G → Prop} {x : G} (h : x ∈ Subgroup.closure k) (Hk : ∀ (x : G), x ∈ k → p x) (H1 : p 1) (hMul : ∀ (x y : G), p x → p y → p (x * y)) (Hinv : ∀ (x : G), p x → p x⁻¹) : p x
{α : Type u_1} {β : Type u_2} [LinearOrder α] [SuccOrder α] [Preorder β] {f : α → β} (hF : Antitone f) : Pairwise (Disjoint on λ (n : α), Set.Ioc (f (Order.succ n)) (f n))
{G : Type u} {x : G} [AddMonoid G] : 0 < Add_order_of x ↔ IsOfFinAddOrder x
{R : Type u} [CommSemiring R] [StarRing R] {x : R} : ⇑(StarRing_end R) x = HasStar.star x
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] (v : V) (nz : v ≠ 0) : FiniteDimensional.finrank K V = 1 ↔ ∀ (w : V), ∃ (c : K), c • v = w
{G : Type w} [TopologicalSpace G] [has_Inv G] [HasMul G] [HasContinuousMul G] [HasContinuousInv G] : Continuous (λ (g : G × G), g.fst * g.snd * (g.fst)⁻¹)
{E : Type u_3} [SemiNormedGroup E] (u v : E) : ∥v∥₊ ≤ ∥u∥₊ + ∥u - v∥₊
{α : Type u_1} {β : Type u_2} [AddCommMonoid α] [TopologicalSpace α] : HasSum (λ (b : β), 0) 0
{α : Type u_1} {M : Type u_5} {N : Type u_6} [CommMonoid M] [CommMonoid N] {s : Set α} {f : α → M} (g : M →* N) (h₀ : (s ∩ Function.MulSupport f).finite) : ⇑g (finprod (λ (j : α), finprod (λ (H : j ∈ s), f j))) = finprod (λ (i : α), finprod (λ (H : i ∈ s), ⇑g (f i)))
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra A B] [Algebra R B] [Algebra R A] [IsScalarTower R A B] {x : B} (h : IsIntegral R x) : IsIntegral A x
{α : Type u_1} [TopologicalSpace α] [t2_Space α] [MeasurableSpace α] [BorelSpace α] {f g : (ℕ → ℕ) → α} (hF : Continuous f) (hg : Continuous g) (h : Disjoint (Set.Range f) (Set.Range g)) : MeasureTheory.MeasurablySeparable (Set.Range f) (Set.Range g)
{n : ℕ+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [NeZero ↑↑n] (hn : IsPrimePow ↑n) [IsCyclotomicExtension {n} K L] (hirr : Irreducible (Polynomial.cyclotomic ↑n K)) (h : n ≠ 2) : ⇑(Algebra.norm K) (IsCyclotomicExtension.zeta n K L - 1) = ↑(↑n.min_fac)
{α : Type u_1} {β : Type u_2} [Group α] [CommGroup β] {f g : α → β} (hF : IsGroupHom f) (hg : IsGroupHom g) : IsGroupHom (λ (a : α), f a * g a)
{R : Type u} {n : ℕ} {M : Fin n.succ → Type w} {M₂ : Type w₂} [Semiring R] [Π (i : Fin n.succ), AddCommMonoid (M i)] [AddCommMonoid M₂] [Π (i : Fin n.succ), Module R (M i)] [Module R M₂] [Π (i : Fin n.succ), TopologicalSpace (M i)] [TopologicalSpace M₂] (f : ContinuousMultilinearMap R M M₂) (m : Π (i : Fin n), M i.succ) (c : R) (x : M 0) : ⇑f (fin.cons (c • x) m) = c • ⇑f (fin.cons x m)
{G : Type u} {n : ℕ} [Fintype G] [LeftCancelMonoid G] (x : G) : order_of (x ^ n) = order_of x / (order_of x).gcd n
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] [PolishSpace β] {f : α → β} (hF : ClosedEmbedding f) : PolishSpace α
{Γ : Type u_1} [Inhabited Γ] (l : Turing.ListBlank Γ) : ∃ (a : Γ) (l' : Turing.ListBlank Γ), l = Turing.ListBlank.cons a l'
{E : Type u_2} [SemiNormedGroup E] [NormedSpace ℝ E] {s : Set E} (hs₀ : 0 ∈ s) (hs₁ : Convex ℝ s) (hs₂ : is_IsOpen s) {x₀ : E} (hx₀ : x₀ ∉ s) : ∃ (f : E →L[ℝ] ℝ), ⇑f x₀ = 1 ∧ ∀ (x : E), x ∈ s → ⇑f x < 1
{b m d : ℕ} : d ∈ (b + 2).digits m → d < b + 2
{α : sort u_1} {p : α → Prop} (P : ∃ (a : α), p a) : p P.some
{α : Type u} [PseudoEmetricSpace α] {δ : ℝ} {s : Set α} {x : α} : emetric.inf_edist x s ≤ emetric.inf_edist x (Metric.Cthickening δ s) + ennreal.of_Real δ
{m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (A : Matrix m m R) (C : Matrix n m R) (D : Matrix n n R) : (matrix.from_blocks A 0 C D).det = A.det * D.det
{α : Type u_1} [CanonicallyOrderedAddMonoid α] [HasSub α] [HasOrderedSub α] {a b c : α} [ContravariantClass α α has_add.add has_le.le] (h : c ≤ b) : a < b - c ↔ a + c < b
{R : Type u_4} [LinearOrderedCommRing R] (a b : R) : 2 * a * b ≤ a ^ 2 + b ^ 2
(A : Type u_2) [CommRing A] [is_IsDomain A] (K : Type u_1) [Field K] [Algebra A K] [IsFractionRing A K] : IsDedekindDomain A ↔ IsNoetherianRing A ∧ ring.dimension_LE_One A ∧ ∀ {x : K}, IsIntegral A x → (∃ (y : A), ⇑(Algebra_Map A K) y = x)
{a b c m : ℕ} (hmc : m.gcd c = 1) (h : c * a ≡ c * b [Mod m]) : a ≡ b [Mod m]
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X ⟶ Y} {t : CategoryTheory.Limits.Cofork f g} {Z Z' : C} (q : Z ⟶ Z') (ht : CategoryTheory.Limits.IsColimit t) (k : t.X ⟶ Z) : ↑(⇑(Category_theory.limits.cofork.is_colimit.hom_iso ht Z') (k ≫ q)) = ↑(⇑(Category_theory.limits.cofork.is_colimit.hom_iso ht Z) k) ≫ q
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMinOrder α] [DenselyOrdered α] {a : α} {s : Set α} : s ∈ nhds_within a (Set.Iio a) ↔ ∃ (l : α) (H : l ∈ Set.Iio a), Set.Ico l a ⊆ s
{R : Type u_1} {M : Type u_2} [CommRing R] [AddCommGroup M] [Module R M] {ι : Type u_3} [DecidableEq ι] {S : Finset ι} {q : ι → R} (hq : ↑S.pairwise (IsCoprime on q)) (hM : Module.IsTorsionBy R M (S.prod (λ (i : ι), q i))) : DirectSum.IsInternal (λ (i : ↥S), Submodule.torsion_by R M (q ↑i))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (s : Set P) : Vector_Span k s = Submodule.span k (s -ᵥ s)
(F : Type u) (K : Type v) (A : Type w) [Field F] [Field K] [AddCommGroup A] [Algebra F K] [Module K A] [Module F A] [IsScalarTower F K A] : (Module.rank F K).lift * (Module.rank K A).lift = (Module.rank F A).lift
{α : Type u_1} [GeneralizedBooleanAlgebra α] [DecidableRel Disjoint] [DecidableRel has_le.le] (u v a : α) : Uv.compress u v (Uv.compress u v a) = Uv.compress u v a
{α : Type u_1} {r : α → α → Prop} (h : Reflexive r) {x y : α} : x ≠ y → r x y ↔ r x y
{α : Type u} [PseudoMetricSpace α] {s : Set α} {f : α → ℝ} (K : Nnreal) (h : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → f x ≤ f y + ↑K * HasDist.dist x y) : LipschitzOnWith K f s
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} {E' : Type u_3} [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 E'] (f : E ≃ₗᵢ[𝕜] E') (p : Submodule 𝕜 E) [CompleteSpace ↥p] (x : E') : ↑(⇑(Orthogonal_projection (Submodule.map ↑(f.to_LinearEquiv) p)) x) = ⇑f ↑(⇑(Orthogonal_projection p) (⇑(f.symm) x))
{α : Type u} {β : Type v} (f : α → β) (l₁ : Filter α) (l₂ : Filter β) : Filter.Tendsto f l₁ l₂ ↔ ∀ (g : Ultrafilter α), ↑g ≤ l₁ → Filter.Tendsto f ↑g l₂
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {c : ℂ} {r R : ℝ} (h0 : 0 < r) (hle : r ≤ R) {f : ℂ → E} {s : Set ℂ} (hs : s.countable) (hc : ContinuousOn f (Metric.ClosedBall c R  Metric.Ball c r)) (hD : ∀ (z : ℂ), z ∈ Metric.Ball c R  Metric.ClosedBall c r  s → DifferentiableAt ℂ f z) : ∮ (z : ℂ) in C(c, R), f z = ∮ (z : ℂ) in C(c, r), f z
{A : Type u_4} [CommRing A] [is_IsDomain A] {K : Type u_5} [Field K] {L : Type u_7} [Field L] [Algebra A K] [IsFractionRing A K] {g : A →+* L} (hg : Function.Injective ⇑g) (x : A) (y : ↥(NonZeroDivisors A)) : ⇑(IsFractionRing.lift hg) (IsLocalization.mk' K x y) = ⇑g x / ⇑g ↑y
{v : ℕ → ℝ} {c : ℝ} (h₀ : 0 < v 0) (hc : 1 < c) (hu : ∀ (n : ℕ), c * v n ≤ v (n + 1)) : Filter.Tendsto v filter.at_Top filter.at_Top
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : Set P} {p1 p2 : P} (hp1 : p1 ∈ SpanPoints k s) (hp2 : p2 ∈ SpanPoints k s) : p1 -ᵥ p2 ∈ Vector_Span k s
(G : Type u_1) [Group G] : IsAscendingCentralSeries (upper_central_series G)
{G : Type u_1} [Group G] [hH : group.is_nilpotent G] [Nontrivial G] : group.nilpotency_class G = group.nilpotency_class (G ⧸ Subgroup.center G) + 1
(a b : Nnreal) {p q : ℝ} (hpq : p.is_conjugate_exponent q) : a * b ≤ a ^ p / p.to_Nnreal + b ^ q / q.to_Nnreal
{p : ℕ} [Fact (Nat.Prime p)] : p % 2 = 1 ↔ p ≠ 2
 : ⇑fourier_series = fourier_Lp 2
{α : Type u} {β : Type v} {γ : Type w} (g : β → γ) (f : α → β) : List.map g ∘ List.map f = List.map (g ∘ f)
{R : Type u_1} {S : Type u_2} [EuclideanDomain R] [CommRing S] [is_IsDomain S] [Algebra R S] (abv : AbsoluteValue R ℤ) {ι : Type u_5} [DecidableEq ι] [Fintype ι] (bS : Basis ι R S) (a : S) {y : ℤ} (hy : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y) : ⇑abv (⇑(Algebra.norm R) a) ≤ class_group.norm_bound abv bS * y ^ Fintype.card ι
{R : Type u_1} [MulZeroClass R] : ¬IsRightRegular 0 ↔ Nontrivial R
(x y : ℤ) : ↑(x.gcd y) = x * x.gcd_a y + y * x.gcd_b y
{𝕂 : Type u_1} {𝔸 : Type u_2} [is_R_or_C 𝕂] [NormedCommRing 𝔸] [NormedAlgebra 𝕂 𝔸] [CompleteSpace 𝔸] {x : 𝔸} : HasStrictFderivAt (Exp 𝕂) (Exp 𝕂 x • 1) x
{ι : Type u₁} {k : Type u₂} {V : Type u₃} {P : Type u₄} [AddCommGroup V] [AddTorsor V P] [Ring k] [Module k V] (b : AffineBasis ι k P) [Fintype ι] (b₂ : AffineBasis ι k P) (x : P) : matrix.vec_Mul (⇑(b₂.coords) x) (b.to_Matrix b₂.points) = ⇑(b.coords) x
{K : Type u_1} [is_R_or_C K] : ⇑is_R_or_C.re is_R_or_C.I = 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {n : ℕ} (s1 s2 : Affine.Simplex k P n) : s1 = s2 ↔ ∀ (i : Fin (n + 1)), s1.points i = s2.points i
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X Y : C} (f g : X ⟶ Y) [CategoryTheory.Limits.HasBinaryBiproduct Y Y] : f + g = CategoryTheory.Limits.biprod.lift f g ≫ CategoryTheory.Limits.biprod.desc (𝟙 Y) (𝟙 Y)
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {R₁ R₂ : ℝ} {f : ℂ → E} {c : ℂ} (hD : DifferentiableOn ℂ f (Metric.Ball c R₁)) (h_maps : Set.MapsTo f (Metric.Ball c R₁) (Metric.Ball (f c) R₂)) (h₀ : 0 < R₁) : ∥deriv f c∥ ≤ R₂ / R₁
{α : Type u} [PseudoMetricSpace α] {s : Set α} {x y : α} (h : y ∈ s) : metric.inf_dist x s ≤ HasDist.dist x y
{M : Type u_1} [has_Add M] (c : AddCon M) : AddConGen ⇑c = c
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [Module 𝕜 E] {x z : E} {s : Set E} (hs : StarConvex 𝕜 (z + x) s) : StarConvex 𝕜 x ((λ (x : E), z + x) ⁻¹' s)
{α : Type u_1} [IsEmpty α] (s : Finset α) : s = ∅
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [CompleteSpace E] (v : E) : ⇑(reflection (Submodule.span 𝕜 {v})ᗮ) v = -v
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} [DecidableEq β'] [DecidableEq γ] [DecidableEq δ] {s : Finset α} {t : Finset β} {f : α → β' → γ} {g : β → β'} {f' : β → α → δ} {g' : δ → γ} (h_Right_anticomm : ∀ (a : α) (b : β), f a (g b) = g' (f' b a)) : Finset.image₂ f s (Finset.image g t) = Finset.image g' (Finset.image₂ f' t s)
{ι : Type u_1} {N : Type u_5} [OrderedCommMonoid N] {f g : ι → N} {s : Finset ι} (h : ∀ (i : ι), i ∈ s → f i ≤ g i) : s.prod (λ (i : ι), f i) ≤ s.prod (λ (i : ι), g i)
{α : Type u_2} {β : Type u_3} [HasZero α] [HasZero β] [SmulWithZero α β] {s : Set β} (h : s.nonempty) : 0 • s = 0
{R : Type u_1} [Ring R] [TopologicalSpace R] [NonarchimedeanRing R] (U : OpenAddSubgroup R) : ∃ (V : OpenAddSubgroup R), ↑V * ↑V ⊆ ↑U
{α : Type u} {β : Type v} [LinearOrderedField α] [TopologicalSpace α] [OrderTopology α] {l : Filter β} {f g : β → α} {C : α} (hC : C < 0) (hF : Filter.Tendsto f l filter.at_Top) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (λ (x : β), f x * g x) l filter.at_IsBot
{α : Type u_1} [HasLe α] {a : α} : IsBot a → IsTop (⇑order_dual.to_dual a)
{𝕜 : Type u_2} {E : Type u_5} {F : Type u_6} [TopologicalSpace 𝕜] [CommSemiring 𝕜] [AddCommMonoid E] [Module 𝕜 E] [AddCommMonoid F] [Module 𝕜 F] {B : E →ₗ[𝕜] F →ₗ[𝕜] 𝕜} (hB : Function.Injective ⇑B) : Embedding (λ (x : WeakBilin B) (y : F), ⇑(⇑B x) y)
 : {p : ℕ | Nat.Prime p}.infinite
(α : Type u) (β : Type v) : Nonempty (α ↪ β) ∨ Nonempty (β ↪ α)
{n : ℕ} {i j : Fin (n + 2)} (H : i ≤ j) : SimplexCategoryδ i ≫ SimplexCategoryδ j.succ = SimplexCategoryδ j ≫ SimplexCategoryδ (⇑fin.cast_Succ i)
(p : ℕ) [hp : Fact (Nat.Prime p)] : WittVector.IsPoly p (λ (R : Type u_1) (_Rcr : CommRing R), WittVector.frobenius_fun)
{M : Type u_6} {N : Type u_7} [has_Add M] [has_Add N] (f : M ≃+ N) (x y : M) : ⇑f (x + y) = ⇑f x + ⇑f y
{ι : Type u} {X : Type v} [TopologicalSpace X] [ParacompactSpace X] {s : Set X} (hs : is_IsClosed s) (u : ι → Set X) (uo : ∀ (i : ι), is_IsOpen (u i)) (us : s ⊆ ⋃ (i : ι), u i) : ∃ (v : ι → Set X), (∀ (i : ι), is_IsOpen (v i)) ∧ (s ⊆ ⋃ (i : ι), v i) ∧ LocallyFinite v ∧ ∀ (i : ι), v i ⊆ u i
{ι : Type u_1} {V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasZeroMorphisms V] {c : ComplexShape ι} (C : HomologicalComplex V c) {i j j' : ι} (rij : c.rel i j) (rij' : c.rel i j') : C.d i j' ≫ Category_theory.eq_to_hom _ = C.d i j
{α : Type u} [Preorder α] {s : Set α} {a : α} (h : is_is_IsLub s a) : BddAbove s
{α : sort u_1} {β : sort u_2} {γ : sort u_3} {f : α → β → γ} (hF : Function.Injective2 f) [Nonempty β] : Function.Injective f
{R : Type u} [CommRing R] [is_IsDomain R] [IsPrincipalIdealRing R] {N : Type (max u v)} [AddCommGroup N] [Module R N] {p : R} (hp : Irreducible p) (hN : Module.IsTorsion' N ↥(Submonoid.powers p)) [h' : Module.Finite R N] : ∃ (d : ℕ) (k : Fin d → ℕ), Nonempty (N ≃ₗ[R] DirectSum (Fin d) (λ (i : Fin d), R ⧸ Submodule.span R {p ^ k i}))
(S : Set ℕ+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [is_IsDomain B] [IsNoetherianRing A] [Fintype ↥S] [IsCyclotomicExtension S A B] : Algebra.IsIntegral A B
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {α β γ : ↥(IsSolvableByRad F E)} (hγ : γ ∈ F⟮α, β⟯) (hα : solvable_by_rad.P α) (hβ : solvable_by_rad.P β) : solvable_by_rad.P γ
{k k' : Turing.ToPartrec.Cont} {v : List ℕ} : turing.to_partrec.step_ret (k.then k') v = (turing.to_partrec.step_ret k v).then k'
{α : Type u_1} [LinearOrder α] [TopologicalSpace α] [CompactIccSpace α] {a b : α} : is_IsCompact (Set.Interval a b)
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (s : Finset ι) [Fintype ι] : finset.univ.sum (λ (i : ι), Finset.centroid_weights_indicator k s i) = s.sum (λ (i : ι), Finset.centroid_weights k s i)
{a b : ℕ} (hab : a.coprime b) : (a * b).factors ~ a.factors ++ b.factors
{M : Type u_1} [HasMul M] {c d : Con M} : c ≤ d ↔ ∀ {x y : M}, ⇑c x y → ⇑d x y
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMinOrder α] {a : α} {s : Set α} : s ∈ nhds_within a (Set.Iio a) ↔ ∃ (l : α) (H : l ∈ Set.Iio a), Set.Ioo l a ⊆ s
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {n : WithTop ℕ} {s : Set E} {f : E → 𝕜} {g : E → F} (hF : ContDiffWithinAt 𝕜 n f s x) (hg : ContDiffWithinAt 𝕜 n g s x) : ContDiffWithinAt 𝕜 n (λ (x : E), f x • g x) s x
{R : Type u} [OrderedRing R] [StarOrderedRing R] [Algebra ℝ R] [OrderedSmul ℝ R] [StarModule ℝ R] (A₀ A₁ B₀ B₁ : R) (T : is_CHSH_tuple A₀ A₁ B₀ B₁) : A₀ * B₀ + A₀ * B₁ + A₁ * B₀ - A₁ * B₁ ≤ Real.sqrt 2 ^ 3 • 1
{α : sort u_1} {β : sort u_2} (f : α → β) (P : Prop) [Decidable P] (x : P → α) (y : ¬P → α) : f (dite P x y) = dite P (λ (h : P), f (x h)) (λ (h : ¬P), f (y h))
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι} {g : ι → α} [TopologicalSpace α] (h : TendstoLocallyUniformly F f p) (hF : ContinuousAt f x) (hg : Filter.Tendsto g p (nhds x)) : Filter.Tendsto (λ (n : ι), F n (g n)) p (nhds (f x))
{α : Type u_1} [MetricSpace α] {β : Type u} {N : ℕ} {τ : ℝ} (hτ : 1 < τ) (hN : IsEmpty (Besicovitch.SatelliteConfig α N τ)) (q : Besicovitch.BallPackage β α) : ∃ (s : Fin N → Set β), (∀ (i : Fin N), (s i).pairwise_Disjoint (λ (j : β), Metric.ClosedBall (q.c j) (q.r j))) ∧ Set.Range q.c ⊆ ⋃ (i : Fin N) (j : β) (H : j ∈ s i), Metric.Ball (q.c j) (q.r j)
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} {a : α} : finsum (λ (i : α), finsum (λ (H : i ∈ {a}), f i)) = f a
{α : Type u_1} {M : Type u_4} {N : Type u_5} [CommMonoid M] [has_One N] (f : α → N) (g : α → N → M) {s t : Finset α} (h : s ⊆ t) (hg : ∀ (a : α), g a 1 = 1) : s.prod (λ (i : α), g i (f i)) = t.prod (λ (i : α), g i (↑s.mul_indicator f i))
{E : Type u_1} [SemiNormedGroup E] {s : AddSubgroup E} (x : ↥s) : ∥↑x∥ = ∥x∥
{ι : Type u} (s : Finset ι) (w z : ι → Nnreal) (hw' : s.sum (λ (i : ι), w i) = 1) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), w i * z i) ^ p ≤ s.sum (λ (i : ι), w i * z i ^ p)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : LocalHomeomorph α β} {s : Set α} {t : Set β} : e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' (e.to_local_equiv.source ∩ s) = e.to_local_equiv.target ∩ t → e.is_image s t
{o : Ordinal} : Ordinal.Principal has_add.add o ↔ o = 0 ∨ ∃ (a : Ordinal), o = Ordinal.omega ^ a
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {l : α → β} {u : β → α} (gc : GaloisConnection l u) {x y z : α} (hxy : x ≤ u (l y)) (hyz : y ≤ u (l z)) : x ≤ u (l z)
{G : Type u_1} [Group G] {H : Subgroup G} {N : Type u_3} [Group N] (f : G →* N) : Subgroup.map f H.normalizer ≤ (Subgroup.map f H).normalizer
{α : Type u} [Group α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] [CovariantClass α α (Function.swap has_mul.mul) has_lt.lt] {a b : α} : a⁻¹ < b → b⁻¹ < a
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {J : Type v} [Fintype J] {f : J → C} (b : CategoryTheory.Limits.Bicone f) (Total : finset.univ.sum (λ (j : J), b.π j ≫ b.ι j) = 𝟙 b.X) : CategoryTheory.Limits.HasBiproduct f
{R : Type u_1} (c₁ c₂ : R) : Cardinal.mk ↥Set.Univ = Cardinal.mk R ^ 4
{n : ℕ} (p : Fin (n + 1)) (i : Fin n) : ⇑fin.cast_Succ i < p ∨ p < i.succ
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {v : ℝ → E → E} {K : Nnreal} (hv : ∀ (t : ℝ), LipschitzWith K (v t)) {f g f' g' : ℝ → E} {a b εf εg δ : ℝ} (hF : ContinuousOn f (Set.Icc a b)) (hF' : ∀ (t : ℝ), t ∈ Set.Ico a b → HasDerivWithinAt f (f' t) (Set.Ici t) t) (f_bound : ∀ (t : ℝ), t ∈ Set.Ico a b → HasDist.dist (f' t) (v t (f t)) ≤ εf) (hg : ContinuousOn g (Set.Icc a b)) (hg' : ∀ (t : ℝ), t ∈ Set.Ico a b → HasDerivWithinAt g (g' t) (Set.Ici t) t) (g_bound : ∀ (t : ℝ), t ∈ Set.Ico a b → HasDist.dist (g' t) (v t (g t)) ≤ εg) (ha : HasDist.dist (f a) (g a) ≤ δ) (t : ℝ) (H : t ∈ Set.Icc a b) : HasDist.dist (f t) (g t) ≤ gronwall_bound δ ↑K (εf + εg) (t - a)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x : E} (hF : HasStrictFderivAt f f' x) : ∃ (K : Nnreal) (s : Set E) (H : s ∈ nhds x), LipschitzOnWith K f s
{α : Type u_1} {β : Type u_2} {C : Set (Set α)} {D : Set (Set β)} (hC : IsCountablySpanning C) (hD : IsCountablySpanning D) : prod.measurable_Space = Measurable_space.generate_from (Set.image2 HasSetProd.prod C D)
{α : Type u_1} [GeneralizedBooleanAlgebra α] [DecidableRel Disjoint] [DecidableRel has_le.le] (u v : α) (s : Finset α) : Uv.compression u v (Uv.compression u v s) = Uv.compression u v s
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : LocalHomeomorph α β} {s : Set α} {t : Set β} : e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s = e.to_local_equiv.target ∩ t → e.is_image s t
{n a b : ℕ} (h : a ≤ b) : a ≡ b [Mod n] ↔ n ∣ b - a
{K : Type u_1} {v : K} {n : ℕ} [LinearOrderedField K] [FloorRing K] {ifp_n : GeneralizedContinuedFraction.IntFractPair K} (nth_Stream_Eq : GeneralizedContinuedFraction.IntFractPair.stream v n = Option.some ifp_n) : ifp_n.fr < 1
(R : Type u_1) {K : Type u_2} {T : Type u_3} {U : Type u_4} [CommRing R] [Field K] [CommRing T] [Algebra R K] [Algebra K T] [Algebra R T] [IsScalarTower R K T] [CommSemiring U] [Algebra K U] [Algebra R U] [IsScalarTower R K U] (x : T) (y : U) (hy : ⇑(Polynomial.aeval y) (minpoly K x) = 0) : ⇑(Polynomial.aeval y) (minpoly R x) = 0
{n : ℕ} (P : Mvpfunctor (n + 1)) {α : Typevec n} {C : P.W α → Prop} (ih : ∀ (a : P.A) (f' : (P.drop.B a).arrow α) (f : P.last.B a → P.W α), (∀ (i : P.last.B a), C (f i)) → C (P.W_Mk a f' f)) (x : P.W α) : C x
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p : ι → P) (h : s.sum (λ (i : ι), w i) = 0) (b : P) : ⇑(s.weighted_vsub p) w = ⇑(s.weighted_vsub_of_point p b) w
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) : K ≤ Kᗮᗮ
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} {x : E} : MdifferentiableAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f x → DifferentiableAt 𝕜 f x
{G : Type u_1} [AddGroup G] (N H : AddSubgroup G) [N.normal] : ↑(N ⊔ H) = ↑N + ↑H
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {x : E} {n : WithTop ℕ} {s : Set E} {f g : E → 𝕜} (hF : ContDiffWithinAt 𝕜 n f s x) (hg : ContDiffWithinAt 𝕜 n g s x) : ContDiffWithinAt 𝕜 n (λ (x : E), f x * g x) s x
{α : Type u} {L L' : List α} (h : L = L') {i : ℕ} (hi : i < L.length) : L.nth_LE i hi = L'.nth_LE i _
{α : Type u_1} [HasLe α] {s : Set α} : IsLowerSet s → IsUpperSet (⇑order_dual.of_dual ⁻¹' s)
{M : Type u} [Monoid M] (a : M) : a ^ 2 = a * a
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : hb.oangle x (-y) = hb.oangle x y + ↑Real.pi
{M : Type u_1} [HasMul M] (S : Subsemigroup M) : Subsemigroup.closure ↑S = S
{α : Type u_1} [Preorder α] {f g : α → α} (hg : Monotone g) (h : f ≤ g) (n : ℕ) : f^[n] ≤ (g^[n])
{R : Type v} [CommRing R] {n : ℕ} (A : Matrix (Fin n.succ) (Fin n.succ) R) (i : Fin n.succ) : A.det = finset.univ.sum (λ (j : Fin n.succ), (-1) ^ (↑i + ↑j) * A i j * (A.minor ⇑(i.succ_above) ⇑(j.succ_above)).det)
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M →* P} {T : Submonoid P} {Q : Type u_4} [CommMonoid Q] (hg : ∀ (y : ↥S), ⇑g ↑y ∈ T) (k : T.localization_Map Q) {x y : M} (h : ⇑(f.to_Map) x = ⇑(f.to_Map) y) : ⇑(k.to_Map) (⇑g x) = ⇑(k.to_Map) (⇑g y)
{α : Type u_1} (f : Filter α) [f.is_countably_generated] : ∃ (x : ℕ → Set α), f.has_Antitone_Basis x
(K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [Module.Finite K L] (pB : PowerBasis K L) [IsSeparable K L] : Algebra.discr K ⇑(pb.basis) = (-1) ^ (FiniteDimensional.finrank K L * (FiniteDimensional.finrank K L - 1) / 2) * ⇑(Algebra.norm K) (⇑(Polynomial.aeval pb.gen) (⇑Polynomial.derivative (minpoly K pb.gen)))
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {c : AddCon M} (f g : c.quotient →+ P) (h : ∀ (a : M), ⇑f ↑a = ⇑g ↑a) : f = g
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (s : Finset ι) [CharZero k] (h : s.card ≠ 0) : s.sum (λ (i : ι), Finset.centroid_weights k s i) = 1
{α : Type u_1} {s : Finset α} {f : α → Ennreal} (h : ∀ (a : α), a ∈ s → f a ≠ ⊤) : s.sum (λ (a : α), f a) < ⊤
{R : Type u_1} [CommRing R] [Fintype R] (p : ℕ) [Fact (Nat.Prime p)] (hp : p ∣ Fintype.card R) : ¬IsUnit ↑p
{m : Type u} {α : Type v} [CommRing α] [Fintype m] [DecidableEq m] {M : Matrix m m α} (h : IsUnit M) (N : Matrix m m α) : ((M⁻¹.mul N).mul M).det = N.det
{α : Type u_1} [TopologicalSpace α] {x : α} {s : Set α} {γ : Type u_4} [LinearOrderedAddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] [HasContinuousAdd γ] {f g : α → γ} (hF : UpperSemicontinuousWithinAt f s x) (hg : UpperSemicontinuousWithinAt g s x) : UpperSemicontinuousWithinAt (λ (z : α), f z + g z) s x
{u : ℕ → ℝ} {l : ℝ} (h : Filter.Tendsto u filter.at_Top (nhds l)) : Filter.Tendsto (λ (n : ℕ), (↑n)⁻¹ * (Finset.range n).sum (λ (i : ℕ), u i)) filter.at_Top (nhds l)
{k : Type u_1} {V : Type u_2} [Ring k] [AddCommGroup V] [Module k V] {ι : Type u_3} {p : ι → V} : AffineIndependent k p ↔ ∀ (s : Finset ι) (w : ι → k), s.sum w = 0 → s.sum (λ (e : ι), w e • p e) = 0 → ∀ (e : ι), e ∈ s → w e = 0
{F : Type u_1} [Field F] {p : Polynomial F} (hp : p.separable) : Fintype.card p.gal = FiniteDimensional.finrank F p.splitting_Field
(S T : Set ℕ+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension (S ∪ T) A B] : IsCyclotomicExtension T ↥(Algebra.adjoin A {b : B | ∃ (a : ℕ+), a ∈ S ∧ b ^ ↑a = 1}) B
{α : Type u} [AddGroup α] [HasLe α] [CovariantClass α α has_add.add has_le.le] {a : α} : -a ≤ 0 ↔ 0 ≤ a
{R : Type u_1} [CommRing R] (P : Ideal (Polynomial R)) : Function.Injective ⇑((Ideal.map (Polynomial.map_RingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.c P))) P).quotient_Map (Polynomial.map_RingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.c P))) Ideal.le_comap_Map)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {s : Set E} {c : Nnreal} : LipschitzOnWith c (f - ⇑f') s → ApproximatesLinearOn f f' s c
{n p k : ℕ} (hn : n ≠ 0) (h : n.factorization = Finsupp.single p k) : n = p ^ k
(p q : ℕ) [hp : Fact (Nat.Prime p)] (hq0 : ↑q ≠ 0) : (Finset.ico 1 (p / 2).succ).sum (λ (a : ℕ), a * q / p) + (Finset.ico 1 (q / 2).succ).sum (λ (a : ℕ), a * p / q) = p / 2 * (q / 2)
{α : Type u} {β : Type v} [Semiring α] [Semiring β] {f : α → β} (hF : IsSemiringHom f) : IsAddMonoidHom f
{c w : ℂ} {R : ℝ} (hw : w ∈ Metric.Ball c R) : ∮ (z : ℂ) in C(c, R), (z - w)⁻¹ = 2 * ↑Real.pi * Complex.i
{α : Type u_1} {β : Type u_2} [CompleteLattice α] (a : α) (f : β → α) : (⨆ (o : Option β), Option.elim a f o) = a ⊔ ⨆ (b : β), f b
{α : Type u} [PseudoEmetricSpace α] {x : α} {s t : Set α} (h : s ⊆ t) : emetric.inf_edist x t ≤ emetric.inf_edist x s
{α : Type u_1} {β : Type u_2} [PseudoMetricSpace α] [PseudoMetricSpace β] {K : Nnreal} {f : α → β} : (∀ (x y : α), HasDist.dist x y ≤ ↑K * HasDist.dist (f x) (f y)) → AntilipschitzWith K f
{R : Type u} [Semiring R] {P : Type (max u v)} [AddCommMonoid P] [Module R P] (huniv : ∀ {M : Type (max v u)} {N : Type (max u v)} [_inst_8 : AddCommMonoid M] [_inst_9 : AddCommMonoid N] [_inst_10 : Module R M] [_inst_11 : Module R N] (f : M →ₗ[R] N) (g : P →ₗ[R] N), Function.Surjective ⇑f → (∃ (h : P →ₗ[R] M), f.comp h = g)) : Module.Projective R P
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (e : C ≌ D) : CategoryTheory.WellPowered C ↔ CategoryTheory.WellPowered D
{α : Type u_1} [CommRing α] (E : LinearRecurrence α) (q : α) : E.is_solution (λ (n : ℕ), q ^ n) ↔ E.char_poly.is_root q
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : ℝ} (h0 : 0 < R) {f : ℂ → E} {c : ℂ} {s : Set ℂ} (hs : s.countable) (hc : ContinuousOn f (Metric.ClosedBall c R)) (hD : ∀ (z : ℂ), z ∈ Metric.Ball c R  s → DifferentiableAt ℂ f z) : ∮ (z : ℂ) in C(c, R), (z - c)⁻¹ • f z = (2 * ↑Real.pi * Complex.i) • f c
{α : Type u_1} {M : Type u_4} [CommMonoid M] (f : α → M) {s t : Finset α} (h : s ⊆ t) : s.prod (λ (i : α), f i) = t.prod (λ (i : α), ↑s.mul_indicator f i)
{a b : ℝ} (h : a < b) : Cardinal.mk ↥(Set.Ioc a b) = Cardinal.continuum
{q : ℕ+} : Fintype.card (LucasLehmer.X q) = ↑q ^ 2
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (hb : ContinuousAt f b) : HasStrictDerivAt (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) (f b) b
{α : Type u_1} [Preorder α] [LocallyFiniteOrder α] {a b : α} : ¬a ≤ b → Finset.icc a b = ∅
 : WellFounded Nat.lt
{α : Type u} {β : Type v} [PseudoMetricSpace α] [PseudoMetricSpace β] {K : Nnreal} {f : α → β} : (∀ (x y : α), HasDist.dist (f x) (f y) ≤ ↑K * HasDist.dist x y) → LipschitzWith K f
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] {x : B} (hx : IsIntegral A x) : (minpoly A x).monic
{α : Type u_1} {β : Type u_2} [ConditionallyCompleteLattice α] [SemilatticeSup β] {f g : β → α} (hF : Monotone f) (hg : Antitone g) (h : f ≤ g) : (⨆ (n : β), f n) ∈ ⋂ (n : β), Set.Icc (f n) (g n)
{M : Type u_3} [AddMonoid M] (L : List M) (h : L.sum ≠ 0) : 0 < L.length
{ι : Type u_1} {M : Type u_4} [OrderedAddCommMonoid M] {s : Finset ι} {f : ι → WithTop M} : s.sum (λ (i : ι), f i) = ⊤ ↔ ∃ (i : ι) (H : i ∈ s), f i = ⊤
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{R : Type u_1} [CommRing R] {p n : ℕ} (hp : Nat.Prime p) : Polynomial.cyclotomic (p ^ (n + 1)) R = (Finset.range p).sum (λ (i : ℕ), (Polynomial.x ^ p ^ n) ^ i)
{cb : CharBuffer} {n n' val : ℕ} : Parser.nat cb n = ParseResult.done n' val ↔ ∃ (hn : n < n'), val = nat.of_digits 10 (List.map (λ (c : Char), c.to_Nat - '0'.to_Nat) (List.take (n' - n) (List.drop n (buffer.to_List cb))).reverse) ∧ (∀ (hn' : n' < Buffer.size cb), '0' ≤ Buffer.read cb ⟨n', hn'⟩ → '9' < Buffer.read cb ⟨n', hn'⟩) ∧ ∃ (hn'' : n' ≤ Buffer.size cb), ∀ (k : ℕ) (hk : k < n'), n ≤ k → '0' ≤ Buffer.read cb ⟨k, _⟩ ∧ Buffer.read cb ⟨k, _⟩ ≤ '9'
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] (v : V) : G.min_degree ≤ G.degree v
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {r : ℝ} (r_nonneg : 0 ≤ r) {x : E} (hx : x ≠ 0) : ∥(↑r * (↑∥x∥)⁻¹) • x∥ = r
{α : Type u_1} {G₀ : Type u_3} [GroupWithZero G₀] [TopologicalSpace G₀] [HasContinuousInv₀ G₀] [HasContinuousMul G₀] {f g : α → G₀} [TopologicalSpace α] {a : α} (hF : ContinuousAt f a) (hg : ContinuousAt g a) (h₀ : g a ≠ 0) : ContinuousAt (f / g) a
{R : Type u_2} {Γ₀ : Type u_3} [LinearOrderedAddCommMonoidWithTop Γ₀] [CommRing R] (v : AddValuation R Γ₀) {J : Ideal R} (hJ : J ≤ v.supp) : (v.on_quot hJ).supp = Ideal.map (Ideal.Quotient.mk J) v.supp
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {ι : Type w} [Fintype ι] (h : Basis ι K V) : FiniteDimensional.finrank K V = Fintype.card ι
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] {p1 : P} (p2 : P) (hp1 : p1 ∈ s) : HasDist.dist p1 p2 * HasDist.dist p1 p2 = HasDist.dist p1 ↑(⇑(euclidean_geometry.orthogonal_projection s) p2) * HasDist.dist p1 ↑(⇑(euclidean_geometry.orthogonal_projection s) p2) + HasDist.dist p2 ↑(⇑(euclidean_geometry.orthogonal_projection s) p2) * HasDist.dist p2 ↑(⇑(euclidean_geometry.orthogonal_projection s) p2)
{α : Type u} [PseudoEmetricSpace α] {s : Set α} : emetric.Hausdorff_edist s (Closure s) = 0
{α : Type u_1} [PartialOrder α] [SuccOrder α] [IsSuccArchimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ Set.Ico n m → r i (Order.succ i)) (hnm : n ≤ m) : Relation.ReflTransGen r n m
{f : ℝ → ℝ} {a : ℝ} (h : is_is_IsLocalMax f a) : deriv f a = 0
{R : Type u} {ι : Type w} (s : Finset ι) [CommSemiring R] (f : ι → Polynomial R) (h : s.prod (λ (i : ι), (f i).leading_Coeff) ≠ 0) : (s.prod (λ (i : ι), f i)).nat_degree = s.sum (λ (i : ι), (f i).nat_degree)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (p : P) (i : Fin 1) : (affine.simplex.mk_of_point k p).points i = p
{k : Type u} [LinearOrderedField k] {a : k} (ha : 0 < a) : (Set.Ioo 0 a)⁻¹ = Set.Ioi a⁻¹
{α : Type u_1} {β : Type u_2} (e e' : LocalEquiv α β) (h : e ≈ e') (s : e.source = Set.Univ) (t : e.target = Set.Univ) : e = e'
{𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] {f : 𝕜 → G} {C : Nnreal} (hF : Differentiable 𝕜 f) (bound : ∀ (x : 𝕜), ∥deriv f x∥₊ ≤ C) : LipschitzWith C f
{α : Type u_1} {β : Type u_2} [LinearOrder α] [Preorder β] {a : α} {f : α → β} (h₁ : StrictAntiOn f (Set.Iic a)) (h₂ : StrictAntiOn f (Set.Ici a)) : StrictAnti f
{R : Type u_1} {F : Type u_3} [AddCommGroup F] [TopologicalSpace F] [TopologicalAddGroup F] [Ring R] [Module R F] [TopologicalSpace R] [HasContinuousSmul R F] {p v : F} : Continuous ⇑(affine_map.line_Map p v)
{α : Type u_1} {s t : Set α} : s = t → s ⊆ t
{M : Type u_3} {N : Type u_4} [HasMul M] [HasMul N] (f : M →ₙ* N) {x y : M} (h : x = y) : ⇑f x = ⇑f y
{m n : ℕ} (cop : m.coprime n) (hm : 1 < m) (hn : 1 < n) : IsFrobeniusNumber (m * n - m - n) {m, n}
{γ : Type w} [EmetricSpace γ] {x y : γ} : HasEdist.edist x y = 0 ↔ x = y
{p : ℕ} [hp_Prime : Fact (Nat.Prime p)] {R : Type u_1} [NonAssocSemiring R] {f : Π (k : ℕ), R →+* Zmod(p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), (zmod.cast_hom _ (Zmod(p ^ k1))).comp (f k2) = f k1) (g : R →+* ℤ_[p]) (hg : ∀ (n : ℕ), (padic_int.to_Zmod_Pow n).comp g = f n) : PadicInt.lift f_compat = g
{α : Type u_1} [DecidableEq α] (s : Multiset α) : s - 0 = s
{p n : ℕ} (hp : Nat.Prime p) (hDiv : ¬p ∣ n) (R : Type u_1) [CommRing R] : ⇑(Polynomial.expand R p) (Polynomial.cyclotomic n R) = Polynomial.cyclotomic (n * p) R * Polynomial.cyclotomic n R
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [HasScalar 𝕜 E] {s : Set E} : Convex 𝕜 s → ∀ ⦃a b : 𝕜⦄, 0 ≤ a → 0 ≤ b → a + b = 1 → a • s + b • s ⊆ s
(R : Type u) [Field R] : IsField R
{M : Type u_1} [CommMonoid M] (f : ℕ → ℕ → M) (n : ℕ) : (Finset.Nat.antidiagonal n).prod (λ (ij : ℕ × ℕ), f ij.fst ij.snd) = (Finset.range n.succ).prod (λ (k : ℕ), f k (n - k))
{M : Type u_1} [has_Add M] (c : AddCon M) {x y : M} : ⇑c x y → ⇑c y x
{ι : Type u₁} {k : Type u₂} {V : Type u₃} [AddCommGroup V] [Ring k] [Module k V] [Fintype ι] (b : AffineBasis ι k V) (v : V) : finset.univ.sum (λ (i : ι), ⇑(b.coord i) v • b.points i) = v
{ι : Type u_1} {V : Type u} [CategoryTheory.Category V] [CategoryTheory.Preadditive V] {c : ComplexShape ι} {C D : HomologicalComplex V c} {f g : C ⟶ D} [CategoryTheory.Limits.HasEqualizers V] [CategoryTheory.Limits.HasCokernels V] [CategoryTheory.Limits.HasImages V] [CategoryTheory.Limits.HasImageMaps V] [CategoryTheory.Limits.HasZeroObject V] (h : Homotopy f g) (i : ι) : (homology_Functor V c i).map f = (homology_Functor V c i).map g
{ι : Type u_1} {M : Type u_4} {N : Type u_5} [AddCommMonoid M] [OrderedAddCommMonoid N] (f : M → N) (h_One : f 0 = 0) (h_Mul : ∀ (x y : M), f (x + y) ≤ f x + f y) (s : Finset ι) (g : ι → M) : f (s.sum (λ (i : ι), g i)) ≤ s.sum (λ (i : ι), f (g i))
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {E' : Type u_7} [InnerProductSpace 𝕜 E'] (f : E ≃ₗᵢ[𝕜] E') (x y : E) : HasInner.inner (⇑f x) (⇑f y) = HasInner.inner x y
{α : Type u_1} {β : Type u_2} [Fintype α] (f : α → β) [Fintype β] [DecidablePred (λ (y : β), y ∈ Set.Range f)] [DecidableEq β] : Finset.filter (λ (y : β), y ∈ Set.Range f) Finset.univ = Finset.image f Finset.univ
{ι : Type u} {f : ι → Ordinal → Ordinal} (H : ∀ (i : ι), Ordinal.IsNormal (f i)) : Set.Unbounded has_lt.lt (⋂ (i : ι), Function.FixedPoints (f i))
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) : A⁻¹ = Ring.inverse A
{K : Type u} {V V₁ : Type v} [Field K] [AddCommGroup V] [Module K V] [AddCommGroup V₁] [Module K V₁] (f : V →ₗ[K] V₁) : Module.rank K ↥(f.range) + Module.rank K ↥(f.ker) = Module.rank K V
{X : Type u_2} [EmetricSpace X] {s : Set X} (hs : s.countable) : dimH s = 0
{α : Type u_1} {β : Type u_4} [Preorder α] [Preorder β] {u : β → α} (l : LowerAdjoint u) (x : α) : x ≤ u (⇑l x)
{M₀ : Type u_1} [MonoidWithZero M₀] (x : M₀) (h : ¬IsUnit x) : Ring.inverse x = 0
{α : Type u_1} {M : Type u_5} {N : Type u_7} [HasZero M] [CommMonoid N] (f : α →₀ M) (y : α) (g : α → M → N) (hyf : y ∈ f.support) : g y (⇑f y) * (Finsupp.erase y f).prod g = f.prod g
(x y z : Pgame) : ((x + y) * z).equiv (x * z + y * z)
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {a b : α} (h : a ⊆ b) : ¬b ⊂ a
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [OrderedSemiring 𝕜] [AddCommGroup E] [Module 𝕜 E] [Subsingleton ι] (p : ι → E) : ConvexIndependent 𝕜 p
{α : sort u_1} (hH : α) {β : Prop} (x : Tactic.CalculatedProp β hH . "derive_reassoc_proof") : β
{F : Type u_1} [NormedGroup F] [NormedSpace ℝ F] (f : ℝ → F) [CompleteSpace F] : MeasurableSet {x : ℝ | DifferentiableWithinAt ℝ f (Set.Ici x) x}
(M : Type u_1) (α : Type u_2) [Group M] [MulAction M α] {P Q : Subgroup M} : MulAction.FixedPoints ↥(P ⊔ Q) α = MulAction.FixedPoints ↥P α ∩ MulAction.FixedPoints ↥Q α
{M : Type u_1} [MulOneClass M] {p : M → Prop} (x : M) {s : Set M} (hs : Submonoid.closure s = ⊤) (Hs : ∀ (x : M), x ∈ s → p x) (H1 : p 1) (hMul : ∀ (x y : M), p x → p y → p (x * y)) : p x
{α : Type u_2} [Monoid α] (m : α) : (∃ (c : α), m = c ^ 2) → IsSquare m
{R : Type u_1} [CommRing R] (M : Submonoid R) (S : Type u_2) [CommRing S] [Algebra R S] {P : Type u_3} [CommRing P] [IsLocalization M S] (Q : Type u_5) [CommRing Q] {g : R →+* P} [Algebra P Q] (hg : Function.Injective ⇑g) [IsLocalization (Submonoid.map ↑g M) Q] (hM : Submonoid.map ↑g M ≤ NonZeroDivisors P) : Function.Injective ⇑(IsLocalization.map Q g _)
{α : Type u_1} {β : Type u_2} {M : Type u_5} {N : Type u_7} [AddCommMonoid M] [AddCommMonoid N] (f : α → β) (v : α →₀ M) (g : M → N) (h0 : g 0 = 0) (hAdd : ∀ (x y : M), g (x + y) = g x + g y) : finsupp.map_IsDomain f (finsupp.map_Range g h0 v) = finsupp.map_Range g h0 (finsupp.map_IsDomain f v)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {J : Type v} [Fintype J] (f : J → C) [CategoryTheory.Limits.HasCoproduct f] : CategoryTheory.Limits.HasBiproduct f
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] [Fintype α] [Fintype β] (f : α → β) {w : α → M} {b : M} [LinearOrderedCancelAddCommMonoid M] [Nonempty β] (hb : Fintype.card β • b ≤ finset.univ.sum (λ (x : α), w x)) : ∃ (y : β), b ≤ (Finset.filter (λ (x : α), f x = y) Finset.univ).sum (λ (x : α), w x)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (p₁ p₂ : P) : EuclideanGeometry.Cospherical {p₁, p₂}
 : golden_Conj⁻¹ = -GoldenRatio
{α : Type u} [TopologicalSpace α] (a : α) : (nhds a).has_Basis (λ (s : Set α), s ∈ nhds a ∧ is_IsOpen s) (λ (x : Set α), x)
{X : Type u_2} [EmetricSpace X] [MeasurableSpace X] [BorelSpace X] (s : Set X) : dimH s = ⨆ (d : Nnreal) (hD : ⇑(measure_theory.measure.hausdorff_measure ↑d) s = ⊤), ↑d
{M : Type u_1} [AddMonoid M] {s t : Set M} (ht : IsAddSubmonoid t) (h : s ⊆ t) : Add_monoid.closure s ⊆ t
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {G : C ⥤ D} {K : CategoryTheory.GrothendieckTopology D} [CategoryTheory.Full G] [CategoryTheory.Faithful G] (Hld : CategoryTheory.LocallyCoverDense K G) : CategoryTheory.CoverLifting Hld.induced_topology K G
{R : Type u_1} [LinearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [FiniteDimensional R M] (x₁ x₂ : Orientation R M ι) (h : Fintype.card ι = FiniteDimensional.finrank R M) : x₁ = x₂ ∨ x₁ = -x₂
{α : Type u_1} {β : Type u_2} {s : Set α} {t : α → Set β} {x : α} (xs : x ∈ s) : (⋂ (x : α) (H : x ∈ s), t x) ⊆ t x
{α : Type u_1} {s t : Set α} : (s ∩ t).nonempty → ¬Disjoint s t
{R : Type u_1} {S : Type u_2} [CommRing R] [is_IsDomain R] [IsPrincipalIdealRing R] [Semiring S] (f : R →+* S) (s : Submonoid S) (a : R) (ha : a ≠ 0) (h : ∀ (b : R), b ∈ PrincipalIdealRing.factors a → ⇑f b ∈ s) (hF : ∀ (c : Rˣ), ⇑f ↑c ∈ s) : ⇑f a ∈ s
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {s : Set E} {x : E} {f' : E → (E →L[𝕜] G)} (hs : Convex ℝ s) {f : E → G} (hder : ∀ᶠ (y : E) in nhds_within x s, HasFderivWithinAt f (f' y) s y) (hcont : ContinuousWithinAt f' s x) (K : Nnreal) (hK : ∥f' x∥₊ < K) : ∃ (t : Set E) (H : t ∈ nhds_within x s), LipschitzOnWith K f t
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] {f : ℝ → E} {T : ℝ} (hF : Function.Periodic f T) (n : ℤ) (t : ℝ) (h_Int : ∀ (t₁ t₂ : ℝ), IntervalIntegrable f MeasureTheory.MeasureSpace.volume t₁ t₂) : ∫ (x : ℝ) in t..t + n • T, f x = n • ∫ (x : ℝ) in t..t + T, f x
{α : Type u} [Preorder α] [NoMinOrder α] (a : α) : ∃ (f : ℕ → α), StrictAnti f ∧ f 0 = a
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] {a : α} : 0 < -a ↔ a < 0
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {f : V ≃ₗᵢ[ℝ] V} (hD : 0 < ⇑LinearMap.det ↑(f.to_LinearEquiv)) : ∃ (θ : Real.Angle), f = hb.rotation θ
{C : Type u₁} [CategoryTheory.Category C] {A : C} (hA : CategoryTheory.IsSubterminal A) {T : C} (hT : CategoryTheory.Limits.IsTerminal T) : CategoryTheory.Mono (hT.from A)
{α : Type u_1} {ι : Type u_2} (m : MeasureTheory.OuterMeasure α) {s : ι → Set α} (l : Filter ι) [l.ne_IsBot] (h0 : Filter.Tendsto (λ (k : ι), ⇑m ((⋃ (n : ι), s n)  s k)) l (nhds 0)) : ⇑m (⋃ (n : ι), s n) = ⨆ (n : ι), ⇑m (s n)
{M : Type u_1} [MulOneClass M] {ι : sort u_2} (S : ι → Submonoid M) {C : Π (x : M), (x ∈ ⨆ (i : ι), S i) → Prop} (hp : ∀ (i : ι) (x : M) (H : x ∈ S i), C x _) (h1 : C 1 _) (hMul : ∀ (x y : M) (hx : x ∈ ⨆ (i : ι), S i) (hy : y ∈ ⨆ (i : ι), S i), C x hx → C y hy → C (x * y) _) {x : M} (hx : x ∈ ⨆ (i : ι), S i) : C x hx
{M : Type u_1} [Monoid M] (s : Submonoid M) {l : List M} (hl : ∀ (x : M), x ∈ l → x ∈ s) : l.prod ∈ s
{α : Type u_1} {s : Finset α} : s.nonempty → ↑s.nonempty
(x y z : Pgame) : (x * y * z).equiv (x * (y * z))
{α : sort u_1} {β : sort u_2} {γ : sort u_3} {δ : out_param (sort u_4)} [has_Coe α β] [has_Coe_t_aux β γ] [has_Coe_ToFun γ (λ (_x : γ), δ)] (x : α) : ⇑x = ⇑↑x
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y : V} (hn : x ≠ y) (h : ∥x∥ = ∥y∥) : hb.oangle y x = ↑Real.pi - 2 • hb.oangle (y - x) y
(R : Type u) (M : Type v) (N : Type w) [CommRing R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] [AddCommGroup N] [Module R N] [Module.Free R N] [Module.Finite R N] : FiniteDimensional.finrank R (M →ₗ[R] N) = FiniteDimensional.finrank R M * FiniteDimensional.finrank R N
{H : Type u} [TopologicalSpace H] (G : StructureGroupoid H) : ClosedUnderRestriction G ↔ Id_restr_groupoid ≤ G
{R : Type u_1} {M : Type u_2} {R₂ : Type u_3} {M₂ : Type u_4} [Ring R] [Ring R₂] [AddCommMonoid M] [AddCommGroup M₂] [Module R M] [Module R₂ M₂] {τ₁₂ : R →+* R₂} [RingHomSurjective τ₁₂] {f : M →ₛₗ[τ₁₂] M₂} (h : ∀ (u v : M₂ →ₗ[R₂] M₂ ⧸ f.range), u.comp f = v.comp f → u = v) : f.range = ⊤
{M : Type u_1} [AddCommGroup M] [Module ℂ M] [FiniteDimensional ℂ M] (Q₁ Q₂ : QuadraticForm ℂ M) (hQ₁ : (⇑QuadraticForm.associated Q₁).nondegenerate) (hQ₂ : (⇑QuadraticForm.associated Q₂).nondegenerate) : Q₁.equivalent Q₂
{J : Type u} [CategoryTheory.SmallCategory J] (F : J ⥤ Top) [CategoryTheory.IsCofiltered J] [∀ (j : J), Nonempty ↥(F.obj j)] [∀ (j : J), CompactSpace ↥(F.obj j)] [∀ (j : J), t2_Space ↥(F.obj j)] : Nonempty ↥((Top.limit_cone F).X)
{R : Type u_1} {a b : R} [AddSemigroup R] (Ab : IsAddRightRegular (b + a)) : IsAddRightRegular b
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {s : Set α} {t : Set β} (hs : Dense s) (ht : Dense t) : Dense (s ×ˢ t)
{R : Type u_1} [CommRing R] [is_IsDomain R] [NormalizedGcdMonoid R] {K : Type u_2} [Field K] [Algebra R K] [IsFractionRing R K] {p : Polynomial R} (hp : p.is_primitive) : Irreducible p ↔ Irreducible (Polynomial.map (Algebra_Map R K) p)
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] (Z : TopologicalFiberBundleCore ι B F) (b : B) : Continuous (Bundle.TotalSpace_Mk b)
{α : Type u} [PseudoMetricSpace α] {s : Set α} (hs : is_IsCompact s) {e : ℝ} (hE : 0 < e) : ∃ (t : Set α) (H : t ⊆ s), t.finite ∧ s ⊆ ⋃ (x : α) (H : x ∈ t), Metric.Ball x e
{R : Type u} [CommSemiring R] {A : Type v} [Semiring A] [Algebra R A] (M : Submodule R A) {C : A → Prop} (hr : ∀ (r : R), C (⇑(Algebra_Map R A) r)) (hAdd : ∀ (x y : A), C x → C y → C (x + y)) (hMul : ∀ (x : A), C x → ∀ (m : A), m ∈ M → C (x * m)) {x : A} {n : ℕ} (hx : x ∈ M ^ n) : C x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {X : Top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget C)] {F G : Top.Sheaf C X} (f : F ⟶ G) (U : TopologicalSpace.Opens ↥X) (hinj : ∀ (x : ↥U), Function.Injective ⇑((Top.presheaf.stalk_Functor C x.val).map f)) (hsurj : ∀ (t : ↥(G.val.obj (Opposite.op U))) (x : ↥U), ∃ (V : TopologicalSpace.Opens ↥X) (m : x.val ∈ V) (iVU : V ⟶ U) (s : ↥(F.val.obj (Opposite.op V))), ⇑(f.app (Opposite.op V)) s = ⇑(G.val.map iVU.op) t) : Function.Surjective ⇑(f.app (Opposite.op U))
{R : Type u_1} [CommSemiring R] {X : Type u_2} {A : Type u_3} [Semiring A] [Algebra R A] {f g : FreeAlgebra R X →ₐ[R] A} (w : ⇑f ∘ FreeAlgebraι R = ⇑g ∘ FreeAlgebraι R) : f = g
(α : Type u) [Preorder α] [Nonempty α] [NoMinOrder α] [NoMaxOrder α] : ∃ (f : ℤ → α), StrictMono f
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Q : QuadraticForm R M} : Function.Commute ⇑CliffordAlgebra.reverse ⇑CliffordAlgebra.involute
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_4} [DecidableEq ι] [Fintype ι] (e : Basis ι R M) {w : ι → R} (hw : ∀ (i : ι), IsUnit (w i)) : ⇑(e.det) ⇑(e.is_Unit_Smul hw) = finset.univ.prod (λ (i : ι), w i)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) {r : Nnreal} (h : ↑r < p.radius) : ∃ (C : ℝ) (H : C > 0), ∀ (n : ℕ), ∥p n∥ * ↑r ^ n ≤ C
{α : Type u_1} {β : Type u_2} [Group α] [DivisionMonoid β] (f : α →* β) (g h : α) : ⇑f (g / h) = ⇑f g / ⇑f h
{α : sort u_1} {β : sort u_2} (f : α → β) : Nonempty α → Nonempty β
{J : Type u₁} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {J' : Type u₂} [CategoryTheory.Category J'] (e : J ≌ J') [CategoryTheory.Limits.HasColimitsOfShape J C] : CategoryTheory.Limits.HasColimitsOfShape J' C
{c : ℝ} (h1 : 0 < c) (h2 : c < 1 / 2) {n : ℕ} {f g : ℕ → Bool} (hn : ∀ (k : ℕ), k < n → f k = g k) (fn : f n = bool.ff) (gn : g n = bool.tt) : cardinal.cantor_Function c f < cardinal.cantor_Function c g
{F : Type u_1} [NormedGroup F] [NormedSpace ℝ F] {f : ℝ → F} {K : Set F} (hK : IsComplete K) : RightDerivMeasurableAux.D f K ⊆ {x : ℝ | DifferentiableWithinAt ℝ f (Set.Ici x) x ∧ deriv_within f (Set.Ici x) x ∈ K}
{b : ℕ} {l : List ℕ} (hb : 2 ≤ b) (hl : ∀ (x : ℕ), x ∈ l → x < b) : nat.of_digits b l < b ^ l.length
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {x : E} {f : E → F} {f' : E → (E →L[ℝ] F)} {f'' : E →L[ℝ] E →L[ℝ] F} (hF : ∀ᶠ (y : E) in nhds x, HasFderivAt f (f' y) y) (hx : HasFderivAt f' f'' x) (v w : E) : ⇑(⇑f'' v) w = ⇑(⇑f'' w) v
{α : Type u} {β : Type v} [Group α] [Group β] {f : α → β} (hF : ∀ (x y : α), f (x * y) = f x * f y) : IsGroupHom f
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : ℕ} {i j : Fin (n + 2)} (H : i ≤ j) : X.δ i ≫ X.δ j.succ = X.δ j ≫ X.δ (⇑fin.cast_Succ i)
{k : Type u_1} {E : Type u_2} [LinearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k → E} {a b r : k} (h : 0 < r * (b - a)) : f (⇑(affine_map.line_Map a b) r) ≤ ⇑(affine_map.line_Map (f a) (f b)) r ↔ slope f a (⇑(affine_map.line_Map a b) r) ≤ slope f a b
{f : ℝ → ℝ} (hF' : ∀ (x : ℝ), deriv f x < 0) : StrictAnti f
{α : Type u_1} {E : Type u_2} {m m₂ : MeasurableSpace α} [TopologicalSpace E] [HasZero E] {s : Set α} {f : α → E} (hs_m : MeasurableSet s) (hs : ∀ (t : Set α), MeasurableSet (s ∩ t) → MeasurableSet (s ∩ t)) (hF : MeasureTheory.StronglyMeasurable f) (hF_Zero : ∀ (x : α), x ∉ s → f x = 0) : MeasureTheory.StronglyMeasurable f
{f : ℝ → ℝ} (hF' : ∀ (x : ℝ), 0 < deriv f x) : StrictMono f
{R : Type u} [CommSemiring R] {A : Type v} [Semiring A] [Algebra R A] (M : Submodule R A) {C : A → Prop} (hr : ∀ (r : R), C (⇑(Algebra_Map R A) r)) (hAdd : ∀ (x y : A), C x → C y → C (x + y)) (hMul : ∀ (m : A), m ∈ M → ∀ (x : A), C x → C (m * x)) {x : A} {n : ℕ} (hx : x ∈ M ^ n) : C x
{α : Type u_1} {β : Type u_2} {M : Type u_5} [AddCommMonoid M] {s : Set α} {t : Set β} {f : α → M} {g : β → M} (e : α → β) (hE₀ : Set.BijOn e s t) (hE₁ : ∀ (x : α), x ∈ s → f x = g (e x)) : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) = finsum (λ (j : β), finsum (λ (H : j ∈ t), g j))
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {F F' : C ⥤ D} (h : F ≅ F') : F.ess_image = F'.ess_image
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {s : Set E} {t : Set F} {g : F → G} {f : E → F} (x : E) (hg : ContDiffWithinAt 𝕜 n g t (f x)) (hF : ContDiffWithinAt 𝕜 n f s x) : ContDiffWithinAt 𝕜 n (g ∘ f) (s ∩ f ⁻¹' t) x
{α : Type u_1} [PseudoEmetricSpace α] (r C : Ennreal) {f : ℕ → α} (hu : ∀ (n : ℕ), HasEdist.edist (f n) (f (n + 1)) ≤ C * r ^ n) {a : α} (ha : Filter.Tendsto f filter.at_Top (nhds a)) : HasEdist.edist (f 0) a ≤ C / (1 - r)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [AddCommMonoid α] [TopologicalSpace α] {f : β → α} [AddCommMonoid γ] [TopologicalSpace γ] {G : Type u_4} [AddEquivClass G α γ] (g : G) (hg : Continuous ⇑g) (hg' : Continuous (AddEquivClass.inv g)) : Summable (⇑g ∘ f) ↔ Summable f
{G : Type u} [AddGroup G] (a x : G) : AddSemiconjBy a x (a + x + -a)
{β : Type u_2} [AddCommMonoid β] (f : Fin 0 → β) : finset.univ.sum (λ (i : Fin 0), f i) = 0
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] [LocallyCompactSpace β] (f : C(α, C(β, γ))) : Continuous (Function.uncurry (λ (x : α) (y : β), ⇑(⇑f x) y))
(c : Turing.ToPartrec.Code) (k : turing.partrec_to_tm2.cont') : turing.TM2.supports turing.partrec_to_tm2.tr (turing.partrec_to_tm2.code_supp c k)
{R : Type u_1} {M : Type u_2} [CommRing R] [AddCommGroup M] [Module R M] (Q : QuadraticForm R M) {P : Π (x : CliffordAlgebra Q), x ∈ clifford_algebra.even_Odd Q 0 → Prop} (hr : ∀ (r : R), P (⇑(Algebra_Map R (CliffordAlgebra Q)) r) _) (hAdd : ∀ {x y : CliffordAlgebra Q} {hx : x ∈ clifford_algebra.even_Odd Q 0} {hy : y ∈ clifford_algebra.even_Odd Q 0}, P x hx → P y hy → P (x + y) _) (hιι_Mul : ∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ clifford_algebra.even_Odd Q 0}, P x hx → P (⇑(CliffordAlgebraι Q) m₁ * ⇑(CliffordAlgebraι Q) m₂ * x) _) (x : CliffordAlgebra Q) (hx : x ∈ clifford_algebra.even_Odd Q 0) : P x hx
{α : sort u_1} {β : sort u_2} {γ : sort u_3} (f : α → β → γ) (P : Prop) [Decidable P] (a : P → α) (b : ¬P → α) (c : P → β) (d : ¬P → β) : f (dite P a b) (dite P c d) = dite P (λ (h : P), f (a h) (c h)) (λ (h : ¬P), f (b h) (d h))
{α : Type u_1} [HasLt α] {a b : αᵒᵈ} : b ⋖ a → ⇑order_dual.of_dual a ⋖ ⇑order_dual.of_dual b
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {a : α} {s : Set α} (hl : ∃ (l : α), l < a) (hu : ∃ (u : α), a < u) : s ∈ nhds a ↔ ∃ (l u : α), a ∈ Set.Ioo l u ∧ Set.Ioo l u ⊆ s
{S : Type u} [AddSemigroup S] {a x y x' y' : S} (h : AddSemiconjBy a x y) (h' : AddSemiconjBy a x' y') : AddSemiconjBy a (x + x') (y + y')
{α : Type u} {β : Type v} {γ : Type w} [PseudoEmetricSpace α] [PseudoEmetricSpace β] [PseudoEmetricSpace γ] {g : β → γ} {f : α → β} (hg : Isometry g) (hF : Isometry f) : Isometry (g ∘ f)
{α : Type u_1} [CompleteLattice α] [IsCompactlyGenerated α] {a : α} {s : Set α} (h : DirectedOn has_le.le s) : a ⊓ HasSup.sup s = ⨆ (b : α) (H : b ∈ s), a ⊓ b
{α : Type u} [TopologicalSpace α] {x : α} : ConnectedComponent x ⊆ ⋂ (Z : {Z // is_IsClopen Z ∧ x ∈ Z}), ↑Z
{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : Function.Injective Coe_fn
{H : Type u_1} [TopologicalSpace H] [LocallyCompactSpace H] [t2_Space H] : TotallyDisconnectedSpace H ↔ TotallySeparatedSpace H
{G : Type u_1} {P : Type u_2} [AddGroup G] [AddTorsor G P] {x y : P} (h : Function.Injective bit0) : ⇑(equiv.point_reflection x) y = y ↔ y = x
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {E' : Type u_7} [InnerProductSpace 𝕜 E'] {v : ι → E} (hv : Orthonormal 𝕜 v) (f : E →ₗᵢ[𝕜] E') : Orthonormal 𝕜 (⇑f ∘ v)
{C : Type u} [CategoryTheory.Category C] {J₁ J₂ : CategoryTheory.GrothendieckTopology C} (h : ⇑J₁ = ⇑J₂) : J₁ = J₂
{α : Type u} {β : Type v} [Ring α] [Ring β] {f : α → β} (hF : IsRingHom f) : IsSemiringHom f
{α : Type u_1} [HasLe α] {a b : αᵒᵈ} : b ≤ a → ⇑order_dual.of_dual a ≤ ⇑order_dual.of_dual b
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {f : V ≃ₗᵢ[ℝ] V} (hD : 0 < ⇑LinearMap.det ↑(f.to_LinearEquiv)) : ∃ (θ : Real.Angle), f = o.rotation θ
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) (h : InnerProductGeometry.angle x y = Real.pi / 2) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
(R : Type u) [CommRing R] [is_IsDomain R] : DiscreteValuationRing R ↔ IsPrincipalIdealRing R ∧ ∃! (P : Ideal R), P ≠ ⊥ ∧ P.is_Prime
{γ : Type w} [SemilatticeInf γ] {a₁ a₂ : γ} {s t : Set γ} (hs : IsGlb s a₁) (ht : IsGlb t a₂) : IsGlb (s ∪ t) (a₁ ⊓ a₂)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {f : E → F} {f' : E →L[𝕜] F} (x : E) {g : F → G} {g' : F →L[𝕜] G} (hg : HasFderivAt g g' (f x)) (hF : HasFderivAt f f' x) : HasFderivAt (g ∘ f) (g'.comp f') x
{M : Type u_3} {N : Type u_4} {P : Type u_5} {Q : Type u_1} [has_One M] [has_One N] [has_One P] [has_One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q) : (h.comp g).comp f = h.comp (g.comp f)
{C : Type u₁} [CategoryTheory.Category C] {X Y : C} (t : CategoryTheory.Limits.IsTerminal X) (f g : Y ⟶ X) : f = g
{ι : Type u_1} {X : Type u_2} [TopologicalSpace X] [NormalSpace X] {u : ι → Set X} {s : Set X} (hs : is_IsClosed s) (uo : ∀ (i : ι), is_IsOpen (u i)) (uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite) (us : s ⊆ ⋃ (i : ι), u i) : ∃ (v : ι → Set X), s ⊆ Set.Union v ∧ (∀ (i : ι), is_IsClosed (v i)) ∧ ∀ (i : ι), v i ⊆ u i
 : is_absolute_value.uniform_Space HasAbs.abs = pseudo_metric_space.to_UniformSpace
{α : Type u_1} [TopologicalSpace α] [PartialOrder α] {s : Set α} [TopologicalSpace.SeparableSpace ↥s] (hs : Dense s) : ∃ (t : Set α) (H : t ⊆ s), t.countable ∧ Dense t ∧ (∀ (x : α), IsBot x → x ∈ s → x ∈ t) ∧ ∀ (x : α), IsTop x → x ∈ s → x ∈ t
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {a b : α} (h : a ⊂ b) : a ⊆ b
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {F : J ⥤ C} {s t : CategoryTheory.Limits.Cone F} (P : CategoryTheory.Limits.IsLimit s) (Q : CategoryTheory.Limits.IsLimit t) (f : s ⟶ t) : CategoryTheory.IsIso f
(n : ℕ) : ConvexOn ℝ (Set.Ici 0) (λ (x : ℝ), x ^ n)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [SemiNormedGroup E] [SemiNormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [RingHomIsometric σ₁₂] (f : E →sl[σ₁₂] F) (x : E) : ∥x∥ ≤ 1 → ∥⇑f x∥ ≤ ∥f∥
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace E] {f : E → F} {f' : E → (E ≃L[𝕜] F)} (hF : ∀ (x : E), HasStrictFderivAt f ↑(f' x) x) : is_is_IsOpenMap f
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {ps : Set P} {n : ℕ} [FiniteDimensional ℝ V] (hD : FiniteDimensional.finrank ℝ V = n) (hc : EuclideanGeometry.Cospherical ps) : ∃ (r : ℝ), ∀ (sx : Affine.Simplex ℝ P n), Set.Range sx.points ⊆ ps → sx.circumradius = r
{A : Type u_1} {B : Type u_2} [CommRing A] [is_IsDomain A] [Ring B] [Algebra A B] {x : B} {a : Polynomial A} (hx : IsIntegral A x) (hamonic : a.monic) (hdvd : DvdNotUnit a (minpoly A x)) : ⇑(Polynomial.aeval x) a ≠ 0
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Q : QuadraticForm R M} {C : CliffordAlgebra Q → Prop} (h_grade0 : ∀ (r : R), C (⇑(Algebra_Map R (CliffordAlgebra Q)) r)) (h_grade1 : ∀ (x : M), C (⇑(CliffordAlgebraι Q) x)) (h_Mul : ∀ (a b : CliffordAlgebra Q), C a → C b → C (a * b)) (h_Add : ∀ (a b : CliffordAlgebra Q), C a → C b → C (a + b)) (a : CliffordAlgebra Q) : C a
{p : NatOrdinal → Prop} (i : NatOrdinal) (h : ∀ (j : NatOrdinal), (∀ (k : NatOrdinal), k < j → p k) → p j) : p i
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) {r : ℝ} (hr : r ≠ 0) : 2 • o.oangle x (r • y) = 2 • o.oangle x y
{α : Type u} [PseudoMetricSpace α] {x : α} : Metric.Bounded {x}
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} {s t : Set α} (hst : Disjoint (s ∩ Function.MulSupport f) (t ∩ Function.MulSupport f)) (hs : (s ∩ Function.MulSupport f).finite) (ht : (t ∩ Function.MulSupport f).finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s ∪ t), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))
{R : Type u_1} [CommRing R] {x₁ x₂ y₁ y₂ : R} : (x₁ ^ 2 + x₂ ^ 2) * (y₁ ^ 2 + y₂ ^ 2) = (x₁ * y₁ - x₂ * y₂) ^ 2 + (x₁ * y₂ + x₂ * y₁) ^ 2
{α : Type u} [PseudoMetricSpace α] {f : α → ℝ} (K : ℝ) (h : ∀ (x y : α), f x ≤ f y + K * HasDist.dist x y) : LipschitzWith K.to_Nnreal f
(n a : ℕ) (p : ℕ → Prop) [DecidablePred p] (pp : Function.Periodic p a) : ⇑Multiset.card (Multiset.filter p (Multiset.ico n (n + a))) = Nat.count p a
{α : Type u_1} [Semigroup α] (x y : α) : ((λ (_x : α), _x * x) ∘ λ (_x : α), _x * y) = λ (_x : α), _x * (y * x)
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {A : Type u_7} [CategoryTheory.Category A] {G : C ⥤ D} (H : CategoryTheory.CoverDense K G) [CategoryTheory.Full G] {ℱ : Dᵒᵖ ⥤ A} {ℱ' : CategoryTheory.Sheaf K A} (α : G.op ⋙ ℱ ⟶ G.op ⋙ ℱ'.val) : Category_theory.whisker_Left G.op (H.sheaf_hom α) = α
{G : Type u_1} [Group G] {G' : Type u_2} [Group G'] [h : group.is_nilpotent G] (f : G →* G') (hF : Function.Surjective ⇑f) : group.is_nilpotent G'
{𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} {P : Type u_8} {P₂ : Type u_9} [NormedField 𝕜] [SemiNormedGroup V] [SemiNormedGroup V₂] [NormedSpace 𝕜 V] [NormedSpace 𝕜 V₂] [PseudoMetricSpace P] [PseudoMetricSpace P₂] [NormedAddTorsor V P] [NormedAddTorsor V₂ P₂] {f : P → P₂} (hF : Isometry f) {p : P} {g : V → V₂} (hg : ∀ (v : V), g v = f (v +ᵥ p) -ᵥ f p) : Isometry g
{ι : Type u_1} {R : Type u_8} [OrderedCommSemiring R] {f : ι → R} {s : Finset ι} (h0 : ∀ (i : ι), i ∈ s → 0 ≤ f i) (h1 : ∀ (i : ι), i ∈ s → f i ≤ 1) : s.prod (λ (i : ι), f i) ≤ 1
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [HasScalar 𝕜 E] {A : Set E} {x : E} : x ∈ Set.ExtremePoints 𝕜 A ↔ IsExtreme 𝕜 A {x}
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) : hb.oangle y (⇑(hb.rotation (hb.oangle x y)) x) = 0
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] [NormalSpace Y] (f : BoundedContinuousFunction X ℝ) {a b : ℝ} {e : X → Y} (hF : ∀ (x : X), ⇑f x ∈ Set.Icc a b) (hle : a ≤ b) (hE : ClosedEmbedding e) : ∃ (g : BoundedContinuousFunction Y ℝ), (∀ (y : Y), ⇑g y ∈ Set.Icc a b) ∧ ⇑g ∘ e = ⇑f
{R S : Type u} [CommRing R] [CommRing S] (M : Submonoid R) (S' : Type u) [CommRing S'] [Algebra S S'] [Algebra R S] [Algebra R S'] [IsScalarTower R S S'] [IsLocalization (Submonoid.map ↑(Algebra_Map R S) M) S'] (x : S) (s : Finset S') (hx : ⇑(Algebra_Map S S') x ∈ Submodule.span R ↑s) : ∃ (m : ↥M), m • x ∈ Submodule.span R ↑(is_localization.finset_integer_multiple (Submonoid.map ↑(Algebra_Map R S) M) s)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] (ι : Type u_2) [Fintype ι] (E : ι → Type u_3) [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] (s : Π (i : ι), Set (E i)) (h : ∀ (i : ι), UniqueDiffOn 𝕜 (s i)) : UniqueDiffOn 𝕜 (set.univ.pi s)
(x : ℂ) : HasDerivAt Complex.exp (Complex.exp x) x
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] (F : D ⥤ C) (Y : D) : F.obj Y ∈ F.ess_image
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x : V) : hb.oangle x 0 = 0
{G : Type u} [Group G] [Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G) : (Fintype.card ↥P).coprime ↑P.index
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] [h : Subsingleton V] : FiniteDimensional.finrank K V = 0
(X : Top) (T : ↥X → Type u) : (X.presheaf_to_Types T).is_sheaf
{α : Type u_2} {β : Type u_3} {rα : NonAssocSemiring α} {rβ : NonAssocSemiring β} (f : α →+* β) (a : α) : ⇑f (bit0 a) = bit0 (⇑f a)
{α : Type u} [t : TopologicalSpace α] {ι : Type u_1} [Encodable ι] {U : ι → Set α} [∀ (i : ι), TopologicalSpace.SecondCountableTopology ↥(U i)] (Uo : ∀ (i : ι), is_IsOpen (U i)) (hc : (⋃ (i : ι), U i) = Set.Univ) : TopologicalSpace.SecondCountableTopology α
(S : Set ℕ+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [is_IsDomain B] [h₁ : Fintype ↥S] [h₂ : IsCyclotomicExtension S A B] : Module.Finite A B
 : Primrec (λ (a : (ℕ × Nat.Partrec.Code) × ℕ), Nat.Partrec.Code.evaln a.fst.fst a.fst.snd a.snd)
{α : Type u} [PseudoEmetricSpace α] (B : ℕ → Ennreal) (hB : ∀ (n : ℕ), 0 < B n) (H : ∀ (u : ℕ → α), (∀ (N n m : ℕ), N ≤ n → N ≤ m → HasEdist.edist (u n) (u m) < B N) → (∃ (x : α), Filter.Tendsto u filter.at_Top (nhds x))) : CompleteSpace α
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (e : LocalHomeomorph α β) : e.trans e.symm ≈ local_homeomorph.of_Set e.to_local_equiv.source _
{n : Type u} [DecidableEq n] [Fintype n] {R : Type v} [LinearOrderedCommRing R] (g : Matrix.SpecialLinearGroup n R) : ↑↑↑g = ↑g
{B : Type u_3} (E₁ : B → Type u_6) (E₂ : B → Type u_7) [TopologicalSpace (Bundle.TotalSpace E₁)] [TopologicalSpace (Bundle.TotalSpace E₂)] : Inducing (λ (p : Bundle.TotalSpace (λ (x : B), E₁ x × E₂ x)), (⟨p.fst, p.snd.fst⟩, ⟨p.fst, p.snd.snd⟩))
(n : ℕ) : n.totient * n.factors.to_finset.prod (λ (p : ℕ), p) = n * n.factors.to_finset.prod (λ (p : ℕ), p - 1)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {a : α} {s : Set α} (ha : IsGlb s a) (hs : s.nonempty) (sc : is_IsClosed s) : a ∈ s
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {D : Type u_3} [CategoryTheory.Category D] [CategoryTheory.Preadditive D] (G : C ⥤ D) [G.additive] (X : CategoryTheory.SimplicialObject C) (q n m : ℕ) (hnm : algebraic_topology.dold_kan.c.rel m n) : algebraic_topology.dold_kan.hσ' q n m hnm = G.map (algebraic_topology.dold_kan.hσ' q n m hnm)
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.swap has_add.add) has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : ℕ} {i j : Fin (n + 1)} (H : i ≤ j) : X.σ j ≫ X.σ (⇑fin.cast_Succ i) = X.σ i ≫ X.σ j.succ
(a : Ordinal) : ∃ (f : Π (b : Ordinal), b < a.cof.ord → Ordinal), a.is_fundamental_sequence a.cof.ord f
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α} {p : Filter ι} {g : ι → α} [TopologicalSpace α] (h : TendstoLocallyUniformlyOn F f p s) (hF : ContinuousWithinAt f s x) (hx : x ∈ s) (hg : Filter.Tendsto g p (nhds_within x s)) : Filter.Tendsto (λ (n : ι), F n (g n)) p (nhds (f x))
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f g : α → M} (hF : (Function.Support f).finite) (hg : (Function.Support g).finite) : finsum (λ (i : α), f i + g i) = finsum (λ (i : α), f i) + finsum (λ (i : α), g i)
(k : ℤ) {b : ℝ} (hb : 0 < b) : (λ (x : ℝ), x ^ k) =o[filter.at_Top] λ (x : ℝ), Real.exp (b * x)
{α : Type u_1} {R : α → α → Prop} [DecidableRel R] {l : List α} : List.Pairwise R l → list.pw_Filter R l = l
{α : Type u} {β : Type v} {γ : Type w} (h : β → γ) (g : α → β) (l : List α) : List.map (h ∘ g) l = List.map h (List.map g l)
{C : Type u} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type v} (Ps : Set (Cᵒᵖ ⥤ Type v)) (h : P ∈ Ps) : CategoryTheory.Presieve.IsSheaf (Category_theory.sheaf.finest_topology Ps) P
{x : ℝ} (hx : x ≤ 0) : Exp_Neg_Inv_glue x = 0
{C : Type u₁} [CategoryTheory.Category C] (X : Type v₁) [CategoryTheory.Limits.HasCoproductsOfShape X C] : CategoryTheory.Limits.HasProductsOfShape X Cᵒᵖ
{α : Type u_1} {f g : ℕ → α} [TopologicalSpace α] [NonUnitalNonAssocSemiring α] [RegularSpace α] [TopologicalSemiring α] (hF : Summable f) (hg : Summable g) (hfg : Summable (λ (x : ℕ × ℕ), f x.fst * g x.snd)) : (∑' (n : ℕ), f n) * ∑' (n : ℕ), g n = ∑' (n : ℕ), (Finset.range (n + 1)).sum (λ (k : ℕ), f k * g (n - k))
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f₂ : 𝕜 → F} : ContDiff 𝕜 ⊤ f₂ ↔ Differentiable 𝕜 f₂ ∧ ContDiff 𝕜 ⊤ (deriv f₂)
{G : Type u_1} [Group G] {H : Subgroup G} [hG : group.fg G] (hH : H.index ≠ 0) : group.fg ↥H
 : Filter.Tendsto (λ (k : ℕ), (Finset.range k).prod (λ (i : ℕ), (2 * ↑i + 2) / (2 * ↑i + 1) * ((2 * ↑i + 2) / (2 * ↑i + 3)))) filter.at_Top (nhds (Real.pi / 2))
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {f : E → F} {g : G →L[𝕜] E} (hF : ContDiff 𝕜 n f) : ContDiff 𝕜 n (f ∘ ⇑g)
{α : Type u} [PseudoEmetricSpace α] (E : Set α) : Metric.Cthickening 0 E = Closure E
{S : Set Ordinal} (o : Ordinal) : ordinal.enum_Ord S o = HasInf.inf (S ∩ Set.Ici (o.blsub (λ (a : Ordinal) (_x : a < o), ordinal.enum_Ord S a)))
{M : Type u_1} [AddCommGroup M] [Module ℝ M] [FiniteDimensional ℝ M] (Q : QuadraticForm ℝ M) : ∃ (w : Fin (FiniteDimensional.finrank ℝ M) → ℝ), (∀ (i : Fin (FiniteDimensional.finrank ℝ M)), w i = -1 ∨ w i = 0 ∨ w i = 1) ∧ Q.equivalent (quadratic_form.weighted_Sum_squares ℝ w)
{G : AddSubgroup ℝ} {g₀ : ℝ} (g₀_in : g₀ ∈ G) (g₀_NE : g₀ ≠ 0) (H' : ¬∃ (a : ℝ), IsLeast {g : ℝ | g ∈ G ∧ 0 < g} a) : Dense ↑G
{R : Type u_1} [CommRing R] [Nontrivial R] {M : Ideal R} (max : M.is_Maximal) (not_IsField : ¬IsField R) : M ≠ ⊥
{ιa : Type u_7} {ιb : Type u_8} [DecidableEq ιa] [DecidableEq ιb] [Fintype ιa] [Fintype ιb] {R' : Type u_9} {Mᵢ : Type u_10} {N₁ : Type u_11} {N₂ : Type u_12} [CommSemiring R'] [AddCommGroup N₁] [Module R' N₁] [AddCommGroup N₂] [Module R' N₂] [AddCommMonoid Mᵢ] [Module R' Mᵢ] (a : AlternatingMap R' Mᵢ N₁ ιa) (b : AlternatingMap R' Mᵢ N₂ ιb) : ⇑MultilinearMap.alternatization (↑a.dom_Coprod ↑b) = ((Fintype.card ιa).factorial * (Fintype.card ιb).factorial) • a.dom_Coprod b
{J : Type v} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [DecidableEq J] (f : J → C) [CategoryTheory.Limits.HasBiproduct f] (j j' : J) : CategoryTheory.Limits.biproductι f j ≫ CategoryTheory.Limits.biproductπ f j' = dite (j = j') (λ (h : j = j'), Category_theory.eq_to_hom _) (λ (h : ¬j = j'), 0)
(n : ℕ) (θ : ℂ) : Complex.cos (↑n * θ) = Polynomial.eval (Complex.cos θ) (Polynomial.Chebyshev.t ℂ n)
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) : o.oangle (-x) y + o.oangle (-y) x = 0
{f : ℂ → ℂ} {z : ℂ} {R : ℝ} (hD : DifferentiableOn ℂ f (Metric.Ball 0 R)) (h_maps : Set.MapsTo f (Metric.Ball 0 R) (Metric.Ball 0 R)) (h₀ : f 0 = 0) (hz : Complex.abs z < R) : Complex.abs (f z) ≤ Complex.abs z
{M : Type u_1} [Monoid M] {f g : ℤ →* M} (h_Neg_One : ⇑f (-1) = ⇑g (-1)) (h_Nat : f.comp int.of_Nat_hom.to_MonoidHom = g.comp int.of_Nat_hom.to_MonoidHom) : f = g
{ι : Type v} {ι' : Type v'} (f : ι → Cardinal) (f' : ι' → Cardinal) (g : ι → ι') (h : ∀ (i : ι), (f i).lift ≤ (f' (g i)).lift) : (Cardinal.sup f).lift ≤ (Cardinal.sup f').lift
{α : Type u_1} [Monoid α] {a b : α} {u : αˣ} : a * ↑u ∣ b ↔ a ∣ b
{α : Type u_1} {β : Type u_2} {M : Type u_5} [CommMonoid M] {s : Set α} {t : Set β} (f : α → β → M) (hs : s.finite) (ht : t.finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s), finprod (λ (j : β), finprod (λ (H : j ∈ t), f i j)))) = finprod (λ (j : β), finprod (λ (H : j ∈ t), finprod (λ (i : α), finprod (λ (H : i ∈ s), f i j))))
{x y z : Pgame} (h₁ : x.lf y) (h₂ : y ≤ z) : x.lf z
{L : FirstOrder.Language} {M : Type w} [L.Structure M] [h : Nonempty L.constants] : Nonempty M
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] (f : (Fin 1 → ℂ) → E) (c : Fin 1 → ℂ) (R : Fin 1 → ℝ) : ∯ (x : Fin 1 → ℂ) in T(c, R), f x = ∮ (z : ℂ) in C(c 0, R 0), f (λ (_x : Fin 1), z)
{α : Type u_1} [MeasurableSpace α] {R : Type u_2} [HasScalar R Ennreal] [IsScalarTower R Ennreal Ennreal] (c : R) (m : MeasureTheory.OuterMeasure α) : (c • m).trim = c • m.trim
{Fq : Type u_1} [Fintype Fq] [Semiring Fq] {d m : ℕ} (hm : Fintype.card Fq ^ d ≤ m) (b : Polynomial Fq) (hb : b.nat_degree ≤ d) (A : Fin m.succ → Polynomial Fq) (hA : ∀ (i : Fin m.succ), (A i).degree < b.degree) : ∃ (i₀ i₁ : Fin m.succ), i₀ ≠ i₁ ∧ A i₁ = A i₀
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] [t2_Space α] {s : Set β} (hs : Dense s) {f g : β → α} (hF : Continuous f) (hg : Continuous g) (h : Set.EqOn f g s) : f = g
{c : Cardinal} (h : Cardinal.aleph_0 ≤ c) : c + c = c
{𝒜 : Type u_1} [CategoryTheory.Category 𝒜] [CategoryTheory.Preadditive 𝒜] [CategoryTheory.Limits.HasKernels 𝒜] [CategoryTheory.Limits.HasImages 𝒜] [CategoryTheory.Limits.HasBinaryBiproducts 𝒜] (A B : 𝒜) : CategoryTheory.Exact CategoryTheory.Limits.biprod.inl CategoryTheory.Limits.biprod.snd
{α : Type u_1} [DecidableEq α] [Fintype α] : Monotone finset.up_shadow
{α : Type u} [MulOneClass α] [HasDistribNeg α] (a : α) : (-1) * a = -a
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) {V₂ : Type u_5} {P₂ : Type u_6} [AddCommGroup V₂] [Module k V₂] [AddTorsor V₂ P₂] (p : ι → P) (w : ι → k) (hw : s.sum w = 1) (f : P →ᵃ[k] P₂) : ⇑f (⇑(s.affine_combination p) w) = ⇑(s.affine_combination (⇑f ∘ p)) w
(R : Type u) (M : Type v) (N : Type w) [Ring R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] [AddCommGroup N] [Module R N] [Module.Free R N] [Module.Finite R N] : FiniteDimensional.finrank R (M × N) = FiniteDimensional.finrank R M + FiniteDimensional.finrank R N
(R : Type u_1) [CommRing R] (S : Type u_2) [CommRing S] [Algebra R S] (K : Type u_5) [Field K] [is_IsDomain R] [is_IsDomain S] [Algebra R K] [Algebra S K] [NoZeroSmulDivisors R K] [IsFractionRing S K] [IsScalarTower R S K] : Algebra.IsAlgebraic R S ↔ Algebra.IsAlgebraic R K
{α : Type u_1} [SemigroupWithZero α] {a : α} : 0 ∣ a ↔ a = 0
{α : Type u_1} [DecidableEq α] {s t : Finset α} (h : s ⊆ t) : (Finset.icc s t).card = 2 ^ (t.card - s.card)
{α : Type u_1} {β : Type u_2} {f : α → β} {m : MeasurableSpace α} [TopologicalSpace β] (hF : MeasureTheory.StronglyMeasurable f) : TopologicalSpace.IsSeparable (Set.Range f)
(p : ℕ) [Fact (Nat.Prime p)] {a : ℤ} (hp : p ≠ 2) (ha0 : ↑a ≠ 0) : zmod.legendre_Sym p a = (-1) ^ (Finset.filter (λ (x : ℕ), p / 2 < (↑a * ↑x).val) (Finset.ico 1 (p / 2).succ)).card
{n p : ℕ} (hp : Nat.Prime p) : multiplicity p (p * n).factorial = multiplicity p n.factorial + ↑n
{M : Type u_2} [AddCommGroup M] {A : Type u_5} [CommRing A] [Module A M] [DecidableEq M] {P : A → Prop} (f : M →ₗ[A] M) (hb : ∀ (s : Finset M) (b : Basis ↥s A M), P (⇑(Linear_map.to_Matrix b b) f).det) (h1 : P 1) : P (⇑LinearMap.det f)
{α : Type u_1} [DecidableEq α] [Fintype α] {f c : Equiv.perm α} {a : α} (ha : a ∈ c.support) (hc : c ∈ f.cycle_Factors_Finset) : c = f.cycle_of a
{α : Type u_1} [TopologicalSpace α] [MeasurableSpace α] [BorelSpace α] [LinearOrder α] [OrderTopology α] [TopologicalSpace.SecondCountableTopology α] {s : Set α} (h : ∀ (x : α), x ∈ s → s ∈ nhds_within x (Set.Ioi x)) : MeasurableSet s
{V : Type u_1} [InnerProductSpace ℝ V] {P : Type u_2} [MetricSpace P] [NormedAddTorsor V P] {a b c d p : P} (h : EuclideanGeometry.Cospherical {a, b, c, d}) (hapb : EuclideanGeometry.angle a p b = Real.pi) (hcpd : EuclideanGeometry.angle c p d = Real.pi) : HasDist.dist a p * HasDist.dist b p = HasDist.dist c p * HasDist.dist d p
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : α → β} {s : Set α} : StrictMonoOn f s → StrictAntiOn (⇑order_dual.to_dual ∘ f) s
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] {a b c : α} : -b + a < c → a < b + c
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [TopologicalSpace.SecondCountableTopology E] [CompleteSpace E] [NormedGroup F] {f : ℝ → E} {g : ℝ → F} {a b c : ℝ} (h_deriv : ∀ᶠ (x : ℝ) in nhds_within c {c}ᶜ, DifferentiableAt ℝ f x) (h_infty : Filter.Tendsto (λ (x : ℝ), ∥f x∥) (nhds_within c {c}ᶜ) filter.at_Top) (hg : deriv f =O[nhds_within c {c}ᶜ] g) (hne : a ≠ b) (hc : c ∈ Set.Interval a b) : ¬IntervalIntegrable g MeasureTheory.MeasureSpace.volume a b
{α : Type u} {a b : α} [MulZeroClass α] [PartialOrder α] [ZeroLt.MulPosMono α] (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b
{α : Type u_1} {t : Set α} (s : Finset ↥t) : ↑(Finset.map (Function.Embedding.subtype (λ (x : α), x ∈ t)) s) ⊆ t
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {c : AddCon M} (f : c.quotient →+ P) : c.lift (f.comp c.mk') _ = f
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {b : M} [LinearOrderedCommRing M] (hF : ∀ (a : α), a ∈ s → f a ∈ t) (ht : t.nonempty) (hb : t.card • b ≤ ↑(s.card)) : ∃ (y : β) (H : y ∈ t), b ≤ ↑((Finset.filter (λ (x : α), f x = y) s).card)
{E : Type u_1} [InnerProductSpace ℝ E] {n : ℕ} (hn : 0 < n) (h : FiniteDimensional.finrank ℝ E = n) (x : Orientation ℝ E (Fin n)) : (orientation.fin_Orthonormal_Basis hn h x).orientation = x
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [Algebra R A] [CommRing B] [Algebra R B] [Algebra A B] [IsScalarTower R A B] (hfpA : Algebra.FinitePresentation R A) (hfpB : Algebra.FinitePresentation A B) : Algebra.FinitePresentation R B
{M : Type u_1} {N : Type u_2} {α : Type u_6} {β : Type u_7} [HasScalar M α] [HasScalar β α] [SmulCommClass M β α] (g : N → M) : SmulCommClass N β α
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} (hcont : ContinuousOn f (Set.Interval a b)) (hderiv : ∀ (x : ℝ), x ∈ Set.Ioo (Linear_order.min a b) (Linear_order.max a b) → HasDerivWithinAt f (f' x) (Set.Ioi x) x) (hint : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b) : ∫ (y : ℝ) in a..b, f' y = f b - f a
{n : ℕ} (P : Mvpfunctor (n + 1)) {α : Typevec n} {C : Type u_1} (g : Π (a : P.A), (P.drop.B a).arrow α → (P.last.B a → P.W α) → (P.last.B a → C) → C) (a : P.A) (f' : (P.drop.B a).arrow α) (f : P.last.B a → P.W α) : P.W_rec g (P.W_Mk a f' f) = g a f' f (λ (i : P.last.B a), P.W_rec g (f i))
{α : Type u_1} [CanonicallyLinearOrderedAddMonoid α] [HasSub α] [HasOrderedSub α] {a b c : α} [ContravariantClass α α has_add.add has_le.le] (h : c ≤ a) : a - c < b - c ↔ a < b
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {s : Set 𝕜} [CompleteSpace F] (h : AnalyticOn 𝕜 f s) : AnalyticOn 𝕜 (deriv f) s
{α : Type u_1} {𝕜 : Type u_14} [NormedField 𝕜] {l : Filter α} {u v : α → 𝕜} (h : u =o[l] v) : u / v * v =ᶠ[l] u
{α : Type u_1} [CircularPreorder α] {a b c : α} (h : HasSbtw.Sbtw a b c) : ¬HasBtw.Btw c b a
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] [Nontrivial B] {x : B} (hx : IsIntegral A x) : 0 < (minpoly A x).nat_degree
{X : Type u_2} [EmetricSpace X] [MeasurableSpace X] [BorelSpace X] {β : Type u_1} {ι : β → Type u_3} [hι : Π (n : β), Fintype (ι n)] (d : ℝ) (s : Set X) {l : Filter β} (r : β → Ennreal) (hr : Filter.Tendsto r l (nhds 0)) (t : Π (n : β), ι n → Set X) (ht : ∀ᶠ (n : β) in l, ∀ (i : ι n), Emetric.diam (t n i) ≤ r n) (hst : ∀ᶠ (n : β) in l, s ⊆ ⋃ (i : ι n), t n i) : ⇑(measure_theory.measure.hausdorff_measure d) s ≤ l.liminf (λ (n : β), finset.univ.sum (λ (i : ι n), Emetric.diam (t n i) ^ d))
{t : ↥UnitInterval} : t ≤ 1
{α : Type u_1} {s : Finset α} {a : α} [DecidableEq α] : (s.erase a).card = Ite (a ∈ s) (s.card - 1) s.card
{C : Type u₁} [CategoryTheory.Category C] (G : CategoryTheory.Comonad C) {A B : G.coalgebra} (f : A ⟶ B) [CategoryTheory.IsIso f.f] : CategoryTheory.IsIso f
{l : Filter ℝ} {f g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in filter.at_IsBot, DifferentiableAt ℝ f x) (hg' : ∀ᶠ (x : ℝ) in filter.at_IsBot, deriv g x ≠ 0) (hfbot : Filter.Tendsto f filter.at_IsBot (nhds 0)) (hgbot : Filter.Tendsto g filter.at_IsBot (nhds 0)) (hDiv : Filter.Tendsto (λ (x : ℝ), deriv f x / deriv g x) filter.at_IsBot l) : Filter.Tendsto (λ (x : ℝ), f x / g x) filter.at_IsBot l
{V : Type u_1} [InnerProductSpace ℝ V] {P : Type u_2} [MetricSpace P] [NormedAddTorsor V P] {a b c d p : P} (h : EuclideanGeometry.Cospherical {a, b, c, d}) (hapb : ∃ (k₁ : ℝ), k₁ ≠ 1 ∧ b -ᵥ p = k₁ • (a -ᵥ p)) (hcpd : ∃ (k₂ : ℝ), k₂ ≠ 1 ∧ d -ᵥ p = k₂ • (c -ᵥ p)) : HasDist.dist a p * HasDist.dist b p = HasDist.dist c p * HasDist.dist d p
{f : ℝ → ℝ} {f' a : ℝ} (h : IsLocalExtr f a) : HasDerivAt f f' a → f' = 0
{ι : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : ι → M} [Semiring R] [AddCommMonoid M] [AddCommMonoid M'] [Module R M] [Module R M'] (f : M →ₗ[R] M') (hF_inj : f.ker = ⊥) : LinearIndependent R (⇑f ∘ v) ↔ LinearIndependent R v
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] [CompleteSpace 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [FiniteDimensional 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {a : E} (hF : HasStrictFderivAt f f' a) (hF' : f'.range = ⊤) : ∀ᶠ (x : E) in nhds a, has_strict_fderiv_at.implicit_Function f f' hF hF' (f x) (⇑(has_strict_fderiv_at.implicit_to_LocalHomeomorph f f' hF hF') x).snd = x
{F : Type u_3} [InnerProductSpace ℝ F] (T : F →ₗ[ℝ] F) : InnerProductSpace.IsSelfAdjoint T ↔ BilinForm_of_Real_inner.is_IsSelfAdjoint T
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {c : AddCon M} {f : M →+ P} (H : c ≤ AddCon.ker f) : (c.lift f H).mrange = f.mrange
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace ↥K] : Kᗮᗮ = K
(b m : ℕ) (hm : m ≠ 0) : (b + 2) ^ ((b + 2).digits m).length ≤ (b + 2) * m
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y z : V} (hxyne : x ≠ y) (hxzne : x ≠ z) (hxy : ∥x∥ = ∥y∥) (hxz : ∥x∥ = ∥z∥) : hb.oangle y z = 2 • hb.oangle (y - x) (z - x)
{α : Type u_1} [has_Add α] [HasLe α] [ContravariantClass α α has_add.add has_le.le] {a b c : α} (bc : a + b ≤ a + c) : b ≤ c
{α : Type u} {L : List (α × Bool)} [DecidableEq α] : FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L
{p a b : ℕ} (hab : a.coprime b) : ⇑((a * b).factorization) p = ⇑(a.factorization) p + ⇑(b.factorization) p
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f : ℂ → E} {s : Set ℂ} {c : ℂ} (hc : s ∈ nhds_within c {c}ᶜ) (hD : DifferentiableOn ℂ f s) (ho : (λ (z : ℂ), f z - f c) =o[nhds_within c {c}ᶜ] λ (z : ℂ), (z - c)⁻¹) : DifferentiableOn ℂ (Function.update f c (lim (nhds_within c {c}ᶜ) f)) (HasInsert.insert c s)
{C : Type u₁} [CategoryTheory.Category C] (X : C) [h : Π (Y : C), Unique (Y ⟶ X)] : CategoryTheory.Limits.HasTerminal C
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : ℝ} {c w : ℂ} {f : ℂ → E} {s : Set ℂ} (hs : s.countable) (hw : w ∈ Metric.Ball c R  s) (hc : ContinuousOn f (Metric.ClosedBall c R)) (hD : ∀ (x : ℂ), x ∈ Metric.Ball c R  s → DifferentiableAt ℂ f x) : ∮ (z : ℂ) in C(c, R), (z - w)⁻¹ • f z = (2 * ↑Real.pi * Complex.i) • f w
{α : Type u_1} {β : Type u_2} [HasMul α] [Preorder α] [Preorder β] {f g : β → α} [CovariantClass α α has_mul.mul has_lt.lt] [CovariantClass α α (Function.swap has_mul.mul) has_lt.lt] (hF : StrictMono f) (hg : StrictMono g) : StrictMono (λ (x : β), f x * g x)
{k : Type u_1} {E : Type u_2} [LinearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k → E} {a b r : k} (h : 0 < r * (b - a)) : f (⇑(affine_map.line_Map a b) r) < ⇑(affine_map.line_Map (f a) (f b)) r ↔ slope f a (⇑(affine_map.line_Map a b) r) < slope f a b
{G : Type u_6} {H : Type u_7} {F : Type u_8} [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) (a b : G) : ⇑f (a * b⁻¹) = ⇑f a * (⇑f b)⁻¹
{α : Type u_1} {c : Set (Set α)} (hc : setoid.is_Partition c) {s : Set α} (hs : s ∈ c) : ∃ (y : α), s = {x : α | (setoid.mk_Classes c _).rel x y}
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] : (reflection K)⁻¹ = reflection K
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Q : QuadraticForm R M} {A : Type u_3} [Semiring A] [Algebra R A] {f g : CliffordAlgebra Q →ₐ[R] A} : f.to_Linear_map.comp (CliffordAlgebraι Q) = g.to_Linear_map.comp (CliffordAlgebraι Q) → f = g
{𝕜 : Type u_3} {E : Type u_4} [NormedField 𝕜] [SemiNormedGroup E] [NormedSpace 𝕜 E] {r : ℝ} (hr : 0 < r) : Absorbent 𝕜 (Metric.Ball 0 r)
{F : Type u_1} [Field F] (p q : Polynomial F) (hq : q.nat_degree ≠ 0) : Polynomial.Splits (Algebra_Map F (p.comp q).splitting_Field) p
{M : Type u_3} {N : Type u_4} [MulOneClass M] [MulOneClass N] {f g : M →* N} : f = g ↔ ∀ (x : M), ⇑f x = ⇑g x
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) {X : C} (S : CategoryTheory.Sieve X) : J₁.close S = ⊤ ↔ S ∈ ⇑J₁ X
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (t : Affine.Triangle ℝ P) {i₁ i₂ i₃ : Fin 3} (h₁₂ : i₁ ≠ i₂) (h₁₃ : i₁ ≠ i₃) (h₂₃ : i₂ ≠ i₃) : Affine.Simplex.altitude t i₁ = affine.simplex.monge_plane t i₂ i₃
{α : Type u_1} {G₀ : Type u_3} [HasZero G₀] [has_Inv G₀] [TopologicalSpace G₀] [HasContinuousInv₀ G₀] {l : Filter α} {f : α → G₀} {a : G₀} (hF : Filter.Tendsto f l (nhds a)) (ha : a ≠ 0) : Filter.Tendsto (λ (x : α), (f x)⁻¹) l (nhds a⁻¹)
{X : Type u_1} [TopologicalSpace X] {s : Set X} (hs : is_IsClosed s) : IsSeqClosed s
{α : Type u_2} {ι : Type u_5} [CommMonoid α] [Fintype ι] (f : ι → Set α) (a : α) : a ∈ finset.univ.prod (λ (i : ι), f i) ↔ ∃ (g : ι → α) (hg : ∀ (i : ι), g i ∈ f i), finset.univ.prod (λ (i : ι), g i) = a
{R : Type u_2} [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R] (a : R) (H : a ≠ 0) (b : R) : ∃ (a' b' c' : R), (∀ {d : R}, d ∣ a' → d ∣ b' → IsUnit d) ∧ c' * a' = a ∧ c' * b' = b
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {α β : ↥(IsSolvableByRad F E)} (hβ : β ∈ F⟮α⟯) (hα : solvable_by_rad.P α) : solvable_by_rad.P β
{n : ℕ} (c : Composition n) : c.boundaries.order_emb_of_Fin _ = c.boundary
{ι : Type u_1} [Fintype ι] : measure_theory.measure.hausdorff_measure ↑(Fintype.card ι) = MeasureTheory.MeasureSpace.volume
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) : is_IsClosed ↑Kᗮ
{R : Type u} {n : ℕ} {M : Fin n.succ → Type w} {M₂ : Type w₂} [Semiring R] [Π (i : Fin n.succ), AddCommMonoid (M i)] [AddCommMonoid M₂] [Π (i : Fin n.succ), Module R (M i)] [Module R M₂] [Π (i : Fin n.succ), TopologicalSpace (M i)] [TopologicalSpace M₂] (f : ContinuousMultilinearMap R M M₂) (m : Π (i : Fin n), M i.succ) (x y : M 0) : ⇑f (fin.cons (x + y) m) = ⇑f (fin.cons x m) + ⇑f (fin.cons y m)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {f : ℝ → E} {C : ℝ} (hF : DifferentiableOn ℝ f (Set.Icc 0 1)) (bound : ∀ (x : ℝ), x ∈ Set.Ico 0 1 → ∥deriv_within f (Set.Icc 0 1) x∥ ≤ C) : ∥f 1 - f 0∥ ≤ C
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} {s : Affine.Simplex ℝ P (n + 2)} {i₁ : Fin (n + 3)} {p : P} (h : ∀ (i₂ : Fin (n + 3)), i₁ ≠ i₂ → p ∈ s.monge_plane i₁ i₂) : p = s.monge_point
{α : Type u_1} {a b c : α} [LinearOrder α] [AddCommSemigroup α] [HasSub α] [HasOrderedSub α] [CovariantClass α α has_add.add has_le.le] (h : a - b < a - c) : c < b
{K : Type u_4} {L : Type u_5} [Field K] [Field L] [Algebra K L] [FiniteDimensional K L] {x : L} : ⇑LinearMap.det (⇑(Algebra.lmul K L) x) = 0 ↔ x = 0
{C : Type u} [CategoryTheory.Category C] {J₁ J₂ : CategoryTheory.GrothendieckTopology C} : J₁ = J₂ ↔ ∀ (P : Cᵒᵖ ⥤ Type (max v u)), CategoryTheory.Presieve.IsSheaf J₁ P ↔ CategoryTheory.Presieve.IsSheaf J₂ P
{p : ℕ} : padic_val_Nat p 1 = 0
{α : Type u_1} [TopologicalSpace α] {s : Set α} {γ : Type u_4} [LinearOrderedAddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] {f g : α → γ} (hF : UpperSemicontinuousOn f s) (hg : UpperSemicontinuousOn g s) (hcont : ∀ (x : α), x ∈ s → ContinuousAt (λ (p : γ × γ), p.fst + p.snd) (f x, g x)) : UpperSemicontinuousOn (λ (z : α), f z + g z) s
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) : Real.cos (InnerProductGeometry.angle x y) * (∥x∥ * ∥y∥) = HasInner.inner x y
{α : sort u_1} {p : α → Prop} (x : Subtype_ p) : p ↑x
{α : Type u_3} {β : Type u_4} [LinearOrderedField α] {l : Filter β} {f : β → α} {r : α} (hr : r < 0) (hF : Filter.Tendsto f l filter.at_IsBot) : Filter.Tendsto (λ (x : β), f x * r) l filter.at_Top
{E : Type u_1} [SemiNormedGroup E] {s : Set E} : Metric.Bounded s → (∃ (R : ℝ), ∀ (x : E), x ∈ s → ∥x∥ ≤ R)
{X : Type u_1} [TopologicalSpace X] [NormalSpace X] {s t : Set X} (hs : is_IsClosed s) (ht : is_IsClosed t) (hD : Disjoint s t) : ∃ (f : BoundedContinuousFunction X ℝ), Set.EqOn ⇑f 0 s ∧ Set.EqOn ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ Set.Icc 0 1
{α : Type u} [TopologicalSpace α] {s : Set α} (x : α) (H : ∀ (y : α), y ∈ s → (∃ (t : Set α) (H : t ⊆ s), x ∈ t ∧ y ∈ t ∧ IsPreconnected t)) : IsPreconnected s
{x : Pgame} : x ≤ 0 ↔ ∀ (i : x.left_moves), ∃ (j : (x.move_Left i).right_moves), (x.move_Left i).move_Right j ≤ 0
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) {r : ℝ} (hr : 0 < r) : o.oangle x (r • y) = o.oangle x y
{α : Type u} [PseudoMetricSpace α] {f : α → ℝ} (K : Nnreal) (h : ∀ (x y : α), f x ≤ f y + ↑K * HasDist.dist x y) : LipschitzWith K f
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P (n + 2)) {i₁ i₂ : Fin (n + 3)} : s.monge_point ∈ s.monge_plane i₁ i₂
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (x : Module.Ray R M) : Ray_of_NeZero R x.some_Vector _ = x
{α : Type u} [t : TopologicalSpace α] [TopologicalSpace.SecondCountableTopology α] {ι : Type u_1} (s : ι → Set α) (H : ∀ (i : ι), is_IsOpen (s i)) : ∃ (T : Set ι), T.countable ∧ (⋃ (i : ι) (H : i ∈ T), s i) = ⋃ (i : ι), s i
(p : ℕ) [hp : Fact (Nat.Prime p)] (n : ℕ) {m : ℕ} (hm : n ≤ m) : (TruncatedWittVector.truncate hm).comp (truncated_witt_vector.zmod_Equiv_trunc p m).to_RingHom = (truncated_witt_vector.zmod_Equiv_trunc p n).to_Ring_hom.comp (zmod.cast_hom _ (Zmod(p ^ n)))
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (s : Set α) : Continuous (λ (F : C(α, β)), ContinuousMap.restrict s F)
{n : Type u_1} {𝕜 : Type u_3} [Field 𝕜] [DecidableEq n] [Fintype n] (M : Matrix n n 𝕜) : ∃ (L L' : List (Matrix.TransvectionStruct n 𝕜)) (D : n → 𝕜), ((List.map matrix.transvection_struct.to_Matrix L).prod.mul M).mul (List.map matrix.transvection_struct.to_Matrix L').prod = Matrix.diagonal D
{m : Type u_2} {n : Type u_3} {α : Type v} (M : Matrix m n α) (i : m) (j : n) : M.transpose j i = M i j
{G : Type w} [TopologicalSpace G] [HasNeg G] [has_Add G] [HasContinuousAdd G] (g : G) : Continuous (λ (h : G), g + h + -g)
{α : Type u} {β : Type v} [TopologicalSpace α] [SemiNormedGroup β] (f : BoundedContinuousFunction α β) [h : Nonempty α] : ∥f∥ = HasInf.inf {C : ℝ | ∀ (x : α), ∥⇑f x∥ ≤ C}
{M : Type u_1} [AddCommMonoid M] (a b : ℕ) (f : ℕ → ℕ → M) : (Finset.ico a b).sum (λ (i : ℕ), (Finset.ico i b).sum (λ (j : ℕ), f i j)) = (Finset.ico a b).sum (λ (j : ℕ), (Finset.ico a (j + 1)).sum (λ (i : ℕ), f i j))
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (s : AffineSubspace ℝ P) [Nonempty ↥s] [CompleteSpace ↥(s.direction)] (p : P) : ⇑(euclidean_geometry.orthogonal_projection s) ↑(⇑(euclidean_geometry.orthogonal_projection s) p) = ⇑(euclidean_geometry.orthogonal_projection s) p
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] (s : Submodule K V) : FiniteDimensional.finrank K (V ⧸ s) ≤ FiniteDimensional.finrank K V
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] (x : α × β) : Filter.map Prod.snd (nhds_within x (Prod.fst ⁻¹' {x.fst})) = nhds x.snd
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} {s t : Set α} (hst : Disjoint (s ∩ Function.Support f) (t ∩ Function.Support f)) (hs : (s ∩ Function.Support f).finite) (ht : (t ∩ Function.Support f).finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s ∪ t), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ t), f i))
{K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [DivisionRing K] {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K} (Succ_nth_s_Eq : g.s.nth (n + 1) = Option.some gp) (nth_denom_Eq : g.denominators n = ppredB) (Succ_nth_denom_Eq : g.denominators (n + 1) = predB) : g.denominators (n + 2) = gp.b * predB + gp.a * ppredB
{α : Type u_1} {M : Type u_5} [CommMonoid M] (s : Set α) : finprod (λ (i : α), finprod (λ (H : i ∈ s), 1)) = 1
{M : Type u_1} [AddMonoid M] {x : M} : 0 ∈ Multiples x
{α : Type u_1} [Semigroup α] (x y : α) : has_mul.mul x ∘ has_mul.mul y = has_mul.mul (x * y)
{n : ℕ} (p : Fin (n + 1)) : Set.Range ⇑(p.succ_above) = {p}ᶜ
{G₀ : Type u_2} [GroupWithZero G₀] (a : G₀) : a / (a / a) = a
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {f : α → β} (hF : ClosedEmbedding f) : Filter.Tendsto f (Filter.cocompact α) (Filter.cocompact β)
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜} : ConcaveOn 𝕜 s f ↔ Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) ≤ (f y - f x) / (y - x)
{p : ℝ} : Summable (λ (n : ℕ), 1 / ↑n ^ p) ↔ 1 < p
{α : Type u_1} {M : Type u_5} {N : Type u_7} [AddZeroClass M] [AddCommMonoid N] {f g : α →₀ M} {h : α → M → N} (h_Zero : ∀ (a : α), h a 0 = 0) (h_Add : ∀ (a : α) (b₁ b₂ : M), h a (b₁ + b₂) = h a b₁ + h a b₂) : (f + g).sum h = f.sum h + g.sum h
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] (x : α × β) : Filter.map Prod.fst (nhds_within x (Prod.snd ⁻¹' {x.snd})) = nhds x.fst
{G : Type u_1} [Group G] {H : Subgroup G} {N : Type u_3} [Group N] (f : N →* G) : Subgroup.comap f H.normalizer ≤ (Subgroup.comap f H).normalizer
{n : ℕ} (c : Composition n) {i₁ i₂ : Fin c.length} (h : i₁ ≠ i₂) : Disjoint (Set.Range ⇑(c.embedding i₁)) (Set.Range ⇑(c.embedding i₂))
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [LinearOrderedAddCommMonoid β] [HasScalar 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f : E → β} (hF : StrictConvexOn 𝕜 s f) {x y z : E} (hx : x ∈ s) (hy : y ∈ s) (hxy : x ≠ y) (hz : z ∈ OpenSegment 𝕜 x y) : f z < Linear_order.max (f x) (f y)
{α : Type u_1} {β : Type u_3} {C : Set (Set α)} {D : Set (Set β)} (hC : IsCountablySpanning C) (hD : IsCountablySpanning D) : IsCountablySpanning (Set.image2 HasSetProd.prod C D)
{α : Type u} {f g : Filter α} (h : ∀ (s : Set α), sᶜ ∈ f ↔ sᶜ ∈ g) : f = g
{M : Type u_1} [AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [AddCommMonoid N] {f : M →+ N} (hF : ∀ (y : ↥S), IsAddUnit (⇑f ↑y)) {y z : ↥S} (h : -⇑(is_Add_unit.lift_Right (f.restrict S) hF) y = -⇑(is_Add_unit.lift_Right (f.restrict S) hF) z) : ⇑f ↑y = ⇑f ↑z
(R : Type u) [Ring R] [StrongRankCondition R] {ι : Type v} [Fintype ι] {M : ι → Type w} [Π (i : ι), AddCommGroup (M i)] [Π (i : ι), Module R (M i)] [∀ (i : ι), Module.Free R (M i)] : Module.rank R (Π (i : ι), M i) = Cardinal.sum (λ (i : ι), Module.rank R (M i))
(n : ℕ) : ∑' (i : ℕ), Ite (n ≤ i) (2⁻¹ ^ i) 0 = 2 * 2⁻¹ ^ n
{α : Type u_1} [PartialOrder α] (c : ClosureOperator α) : c.closed = Set.Range ⇑c
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) {x y : L} : x ∈ S → y ∈ S → x / y ∈ S
{a b c m : ℕ} (hm : 0 < m) (h : c * a ≡ c * b [Mod m]) : a ≡ b [Mod m / m.gcd c]
{C : Type u₁} [CategoryTheory.Category C] {X₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₂₁ : X₂₁ ⟶ X₂₂} {h₃₁ : X₃₁ ⟶ X₃₂} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₂₁ : X₂₁ ⟶ X₃₁} {v₂₂ : X₂₂ ⟶ X₃₂} (s : CategoryTheory.IsPullback h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁) (p : h₁₁ ≫ v₁₂ = v₁₁ ≫ h₂₁) (t : CategoryTheory.IsPullback h₂₁ v₂₁ v₂₂ h₃₁) : CategoryTheory.IsPullback h₁₁ v₁₁ v₁₂ h₂₁
{J : Type v} {C : Type u} [CategoryTheory.Category C] {X Y : C} {f : J → (X ⟶ Y)} [Nonempty J] {t : CategoryTheory.Limits.Cotrident f} {Z Z' : C} (q : Z ⟶ Z') (ht : CategoryTheory.Limits.IsColimit t) (k : t.X ⟶ Z) : ↑(⇑(Category_theory.limits.cotrident.is_colimit.hom_iso ht Z') (k ≫ q)) = ↑(⇑(Category_theory.limits.cotrident.is_colimit.hom_iso ht Z) k) ≫ q
{X Y : Compactum} (f : X ⟶ Y) : Continuous ⇑f
{R : Type u} [CommSemiring R] {A : Type v} [Semiring A] [Algebra R A] {M N : Submodule R A} {C : Π (r : A), r ∈ M * N → Prop} (hm : ∀ (m : A) (H : m ∈ M) (n : A) (H_1 : n ∈ N), C (m * n) _) (ha : ∀ (x : A) (hx : x ∈ M * N) (y : A) (hy : y ∈ M * N), C x hx → C y hy → C (x + y) _) {r : A} (hr : r ∈ M * N) : C r hr
{R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [TopologicalSpace M] [TopologicalSpace M₂] [Semiring R] [AddCommMonoid M₂] [Module R M₂] [AddCommMonoid M] [Module R M] (e : M ≃L[R] M₂) : ↑e.inverse = ↑(e.symm)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) (h : 0 < p.radius) : ∃ (C r : ℝ) (hC : 0 < C) (hr : 0 < r), ∀ (n : ℕ), ∥p n∥ ≤ C * r ^ n
{n : ℕ} (i : Fin (n + 1)) : finset.univ.sum (λ (j : Affine.Simplex.PointsWithCircumcenterIndex n), affine.simplex.point_weights_with_circumcenter i j) = 1
(k : Type u₁) {G : Type u₂} [Semiring k] [HasMul G] {A : Type u₃} [NonUnitalNonAssocSemiring A] [DistribMulAction k A] {φ₁ φ₂ : MonoidAlgebra k G →ₙₐ[k] A} (h : φ₁.to_Mul_hom.comp (MonoidAlgebra.of_magma k G) = φ₂.to_Mul_hom.comp (MonoidAlgebra.of_magma k G)) : φ₁ = φ₂
{F : Type u_3} [Field F] [Fintype F] (hF : Ring_Char F ≠ 2) : ∃ (a : F), ¬IsSquare a
{α : Type u_1} {o p : Part α} (H : ∀ (a : α), a ∈ o ↔ a ∈ p) : o = p
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x : V} (hx : x ≠ 0) : hb.oangle x (-x) = ↑Real.pi
{E : Type u_1} {F : Type u_2} [InnerProductSpace ℝ E] [InnerProductSpace ℝ F] {f : E → F} {x : E} {f' : E →L[ℝ] F} (h : HasFderivAt f f' x) : ConformalAt f x ↔ ∃ (c : ℝ), 0 < c ∧ ∀ (u v : E), HasInner.inner (⇑f' u) (⇑f' v) = c * HasInner.inner u v
{V₁ : Type u_2} {V₂ : Type u_3} [SemiNormedGroup V₁] [SemiNormedGroup V₂] (f g : NormedGroupHom V₁ V₂) : ∥f + g∥ ≤ ∥f∥ + ∥g∥
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (s : AffineSubspace ℝ P) [Nonempty ↥s] [CompleteSpace ↥(s.direction)] (p : P) : ↑(⇑(euclidean_geometry.orthogonal_projection s) p) -ᵥ p ∈ (s.direction)ᗮ
{α : Type u} {β : Type v} [Preorder β] {f : α → β} {s : Set α} {a : α} : IsExtrOn f s a → IsExtrOn (⇑order_dual.to_dual ∘ f) s a
{ι : Type u} {α : Type v} [Fintype ι] {t : ι → Finset α} [DecidableEq α] (ht : ∀ (s : Finset ι), s.card ≤ (s.bUnion t).card) : ∃ (f : ι → α), Function.Injective f ∧ ∀ (x : ι), f x ∈ t x
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {E' : Type u_6} [NormedGroup E'] [NormedSpace 𝕜 E'] {F' : Type u_7} [NormedGroup F'] [NormedSpace 𝕜 F'] {f : E → F} {g : E' → F'} {x : E} {y : E'} (hF : ContDiffAt 𝕜 n f x) (hg : ContDiffAt 𝕜 n g y) : ContDiffAt 𝕜 n (Prod.map f g) (x, y)
{G : Type u_1} [DivInvMonoid G] [MeasurableSpace G] [HasMeasurableMul G] (g : G) : Measurable (λ (h : G), h / g)
{α : sort u_1} {k l : ℕ} (h : k = l) {f : Fin k → α} {g : Fin l → α} : f == g ↔ ∀ (i : Fin k), f i = g ⟨↑i, _⟩
{R : Type u_1} [CommSemiring R] {n : Type u_4} [Fintype n] [DecidableEq n] {M₁ : Type u_5} [AddCommMonoid M₁] [Module R M₁] (v₁ : Basis n R M₁) : ⇑(Linear_map.to_Matrix v₁ v₁) LinearMap.id = 1
{R : Type u} {M : Type v} [CommSemiring R] [AddCommMonoid M] [Module R M] (M' : Submodule R M) (s : Set R) (hs : Ideal.span s = ⊤) (x : M) (H : ∀ (r : ↥s), ∃ (n : ℕ), ↑r ^ n • x ∈ M') : x ∈ M'
{α : Type u} [PartialOrder α] [OrderTop α] {a : α} : IsTop a → a = ⊤
{R : Type u} [Ring R] {ι : Type v} [decι : DecidableEq ι] {M : Type u_1} [AddCommGroup M] [Module R M] (A : ι → Submodule R M) : DirectSum.IsInternal A ↔ CompleteLattice.Independent A ∧ supr A = ⊤
{R : Type x} [Ring R] [NoZeroDivisors R] (u : Rˣ) : u⁻¹ = u ↔ u = 1 ∨ u = -1
{R : Type u_3} {A : Type u_5} [CommRing R] [CommRing A] [Algebra R A] (s : Set A) (li : AlgebraicIndependent R Coe) (t : Finset ↥s) : AlgebraicIndependent R Coe
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f : X ⟶ Y} {c : CategoryTheory.Limits.Fork f f} (h : CategoryTheory.Limits.IsLimit c) : CategoryTheory.IsIso c.ι
{β : Type u} {α : Type v} {γ : Type w} [AddCommMonoid β] {s : Finset α} {t : Finset γ} {f : α → β} {g : γ → β} (i : Π (a : α), a ∈ s → γ) (hi : ∀ (a : α) (ha : a ∈ s), i a ha ∈ t) (h : ∀ (a : α) (ha : a ∈ s), f a = g (i a ha)) (i_inj : ∀ (a₁ a₂ : α) (ha₁ : a₁ ∈ s) (ha₂ : a₂ ∈ s), i a₁ ha₁ = i a₂ ha₂ → a₁ = a₂) (i_surj : ∀ (b : γ), b ∈ t → (∃ (a : α) (ha : a ∈ s), b = i a ha)) : s.sum (λ (x : α), f x) = t.sum (λ (x : γ), g x)
{α : Type u} [PseudoEmetricSpace α] : Emetric.diam ∅ = 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] (s1 s2 : AffineSubspace k P) : ↑s1 ⊓ ↑s2 = ↑s1 ∩ ↑s2
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [NondiscreteNormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (f : ContinuousMultilinearMap 𝕜 E G) (m : Π (i : ι), E i) : ∥⇑f m∥ ≤ ∥f∥ * finset.univ.prod (λ (i : ι), ∥m i∥)
 : Cardinal.mk ↥Set.Univ = Cardinal.continuum
{α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {f : MeasureTheory.Filtration ℕ m} {u : ℕ → α → β} [AddCommMonoid β] [TopologicalSpace β] [HasContinuousAdd β] (h : MeasureTheory.Adapted f u) : MeasureTheory.ProgMeasurable f u
{a : ℝ} {l : Filter ℝ} {f f' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in nhds_within a (Set.Univ  {a}), HasDerivAt f (f' x) x) (hgg' : ∀ᶠ (x : ℝ) in nhds_within a (Set.Univ  {a}), HasDerivAt g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in nhds_within a (Set.Univ  {a}), g' x ≠ 0) (hfa : Filter.Tendsto f (nhds_within a (Set.Univ  {a})) (nhds 0)) (hga : Filter.Tendsto g (nhds_within a (Set.Univ  {a})) (nhds 0)) (hDiv : Filter.Tendsto (λ (x : ℝ), f' x / g' x) (nhds_within a (Set.Univ  {a})) l) : Filter.Tendsto (λ (x : ℝ), f x / g x) (nhds_within a (Set.Univ  {a})) l
{R : Type u} {K : Type v} {L : Type z} {p : R} [CommRing R] [Field K] [Field L] [Algebra K L] [Algebra R L] [Algebra R K] [IsScalarTower R K L] [IsSeparable K L] [is_IsDomain R] [NormalizedGcdMonoid R] [IsFractionRing R K] [IsIntegrallyClosed R] {B : PowerBasis K L} (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} {Q : Polynomial R} (hQ : ⇑(Polynomial.aeval B.gen) Q = p • z) (hzint : IsIntegral R z) (hei : (minpoly R B.gen).is_eisenstein_at (Submodule.span R {p})) : p ∣ Q.coeff 0
{α : Type u_3} {β : Type u_4} [LinearOrderedField α] {l : Filter β} {f : β → α} {r : α} (hr : r < 0) (hF : Filter.Tendsto f l filter.at_Top) : Filter.Tendsto (λ (x : β), r * f x) l filter.at_IsBot
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {G : ι → Type u_5} [Π (i : ι), InnerProductSpace 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 V) {γ : Type u_3} {f : γ → ι} (hF : Function.Injective f) : OrthogonalFamily 𝕜 (λ (g : γ), V (f g))
{α : Type u_1} {β : Type u_2} {α₂ : Type u_3} [Semiring β] [has_One α] [has_One α₂] {F : Type u_4} [OneHomClass F α α₂] (f : F) : finsupp.map_IsDomain ⇑f 1 = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] (O : Finset C) : ∃ (S : C), ∀ {X : C}, X ∈ O → Nonempty (X ⟶ S)
{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : Function.Injective Coe_fn
(p : ℕ) {q : ℚ} (hq : q ≠ 0) : padic_norm p q = ↑p ^ -padic_val_rat p q
{α : Type u_2} [DecidableEq α] [has_Inv α] {s : Finset α} : s.nonempty → s⁻¹.nonempty
{α : Type u} [has_Add α] : IsAddHom Id
{R : Type u_1} {A : Type u_2} [CommSemiring R] [Semiring A] [Algebra R A] (S : Subalgebra R A) : S.to_Submodule * S.to_Submodule = S.to_Submodule
{K : Type u_1} [LinearOrderedField K] [FloorRing K] {a : K} (b c : K) (fract_a_NeZero : Int.fract a ≠ 0) : (↑⌊a⌋ * b + c) / Int.fract a + b = (b * a + c) / Int.fract a
{D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ} (hF : ContinuousOn f D) (hF' : DifferentiableOn ℝ f (Interior D)) {C : ℝ} (hF'_GE : ∀ (x : ℝ), x ∈ Interior D → C ≤ deriv f x) (x : ℝ) (H : x ∈ D) (y : ℝ) (H_1 : y ∈ D) : x ≤ y → C * (y - x) ≤ f y - f x
{R : Type u_1} {L : Type u_2} [CommRing R] [LieRing L] [LieAlgebra R L] {H : LieSubalgebra R L} {x y : L} (hx : x ∈ H.normalizer) (hy : y ∈ H) : ⁅x,y⁆ ∈ H
{R : Type u_1} {M : Type u_2} [AddCommMonoid M] [CommSemiring R] {S : Set M} (hS : AddSubmonoid.closure S = ⊤) : Function.Surjective ⇑(MvPolynomial.aeval (λ (s : ↥S), AddMonoidAlgebra.of' R M ↑s))
{n : ℕ} (w : 0 < n) (h : ¬Nat.Prime n) : n.min_fac ^ 2 ≤ n
{α : Type u_1} {f g : α → ℝ} {t₀ : Filter α} (hF : ∀ (t : α), 0 ≤ f t) (hft : ∀ (t : α), f t ≤ g t) (g0 : Filter.Tendsto g t₀ (nhds 0)) : Filter.Tendsto f t₀ (nhds 0)
{C : Type u} [CategoryTheory.Category C] {X Y : C} (J : CategoryTheory.GrothendieckTopology C) (f : Y ⟶ X) (S : CategoryTheory.Sieve X) (hF : ⇑S f) : J.covers S f
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜} (hF : StrictConcaveOn 𝕜 s f) {x y z : 𝕜} (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) : (f z - f y) / (z - y) < (f y - f x) / (y - x)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (R : D ⥤ C) [CategoryTheory.Reflective R] [CategoryTheory.Limits.HasColimitsOfSize C] : CategoryTheory.Limits.HasColimitsOfSize D
{G : Type u_1} {H : Type u_2} [AddGroup G] {N : AddSubgroup G} [AddGroup H] {f : G →+ H} (hN : N = f.ker) (tH : Add_monoid.is_torsion H) (tN : Add_monoid.is_torsion ↥N) : Add_monoid.is_torsion G
{α : Type u_1} {β : Type u_2} {M : Type u_5} [AddCommMonoid M] (s : Finset (α × β)) (f : α × β → M) : finsum (λ (Ab : α × β), finsum (λ (h : Ab ∈ s), f Ab)) = finsum (λ (a : α), finsum (λ (b : β), finsum (λ (h : (a, b) ∈ s), f (a, b))))
(R : Type u) [Semiring R] [Nontrivial R] [NoZeroDivisors R] {p : ℕ} [hp : Char_p R p] (p_NeZero : p ≠ 0) : Nat.Prime p
(n : ℕ) : (pgame.pow_half n).numeric
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (p1 p2 p3 : P) : HasDist.dist p1 p3 * HasDist.dist p1 p3 = HasDist.dist p1 p2 * HasDist.dist p1 p2 + HasDist.dist p3 p2 * HasDist.dist p3 p2 - 2 * HasDist.dist p1 p2 * HasDist.dist p3 p2 * Real.cos (EuclideanGeometry.angle p1 p2 p3)
{R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [DecidableEq ι] [Ring R] [Π (i : ι), AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [Π (i : ι), Module R (M₁ i)] [Module R M₂] [Nonempty ι] (f : MultilinearMap R M₁ M₂) (p : Π (i : ι), Submodule R (M₁ i)) : ↑(f.map p).nonempty
{G : Type u_1} [Group G] (H : Subgroup G) {x y : G} : x ∈ H → y ∈ H → x * y ∈ H
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] {f : C(α, β)} {ι : Type u₃} {p : Filter ι} {F : ι → C(α, β)} [LocallyCompactSpace α] : Filter.Tendsto F p (nhds f) ↔ TendstoLocallyUniformly (λ (i : ι) (a : α), ⇑(F i) a) ⇑f p
{α : Type u_1} {ι : Type u_4} {ι' : Type u_5} [NormedRing α] [CompleteSpace α] {f : ι → α} {g : ι' → α} (hF : Summable (λ (x : ι), ∥f x∥)) (hg : Summable (λ (x : ι'), ∥g x∥)) : (∑' (x : ι), f x) * ∑' (y : ι'), g y = ∑' (z : ι × ι'), f z.fst * g z.snd
{K : Type u_1} {V : Type u_2} [Field K] [AddCommGroup V] [Module K V] {P : ℙ K V → Prop} (h : ∀ (v : V) (h : v ≠ 0), P (Projectivization.mk K v h)) (p : ℙ K V) : P p
(p : ℕ) [hp : Fact (Nat.Prime p)] (n : ℕ) : WittVector.IsPoly p (λ (R : Type u_1) (_Rcr : CommRing R) (x : WittVector p R), x * ↑n)
{ι : Type u} {f g : ι → ℝ} {p q : ℝ} (hpq : p.is_conjugate_exponent q) (hF : ∀ (i : ι), 0 ≤ f i) (hg : ∀ (i : ι), 0 ≤ g i) (hF_Sum : Summable (λ (i : ι), f i ^ p)) (hg_Sum : Summable (λ (i : ι), g i ^ q)) : Summable (λ (i : ι), f i * g i) ∧ ∑' (i : ι), f i * g i ≤ (∑' (i : ι), f i ^ p) ^ (1 / p) * (∑' (i : ι), g i ^ q) ^ (1 / q)
{C : Type u} [𝒞 : CategoryTheory.Category C] {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)] [CategoryTheory.Limits.HasLimit (Category_theory.limits.parallel_pair (CategoryTheory.Limits.prod.fst ≫ f) (CategoryTheory.Limits.prod.snd ≫ g))] : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan f g)
{γ : Type w} [LinearOrder γ] {a b : γ} {s t : Set γ} (ha : IsGreatest s a) (hb : IsGreatest t b) : IsGreatest (s ∪ t) (Linear_order.max a b)
(θ : ℂ) (n : ℕ) : Polynomial.eval (Complex.cos θ) (Polynomial.Chebyshev.u ℂ n) * Complex.sin θ = Complex.sin ((↑n + 1) * θ)
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [Algebra R A] [CommRing B] [Algebra R B] {f : A →ₐ[R] B} (hF : Function.Surjective ⇑f) (hker : f.to_Ring_hom.ker.fg) (hfp : Algebra.FinitePresentation R A) : Algebra.FinitePresentation R B
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜} : StrictConcaveOn 𝕜 s f ↔ Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) < (f y - f x) / (y - x)
{α : Type u_1} [Semigroup α] {a b c : α} : a ∣ b → b ∣ c → a ∣ c
{C : Type u₁} [CategoryTheory.Category C] (X : C) [h : Π (Y : C), Unique (X ⟶ Y)] : CategoryTheory.Limits.HasInitial C
{α : Type u} {β : Type v} [TopologicalSpace α] [SemiNormedGroup β] (f : BoundedContinuousFunction α β) (x y : α) : HasDist.dist (⇑f x) (⇑f y) ≤ 2 * ∥f∥
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) : x = y ↔ ∥x∥ = ∥y∥ ∧ hb.oangle x y = 0
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [CompleteSpace ↥(s.direction)] {ps : Set P} (hnps : ps.nonempty) {p : P} (hps : ps ⊆ ↑s) (hp : p ∉ s) (hu : ∃! (cccr : P × ℝ), cccr.fst ∈ s ∧ ∀ (p1 : P), p1 ∈ ps → HasDist.dist p1 cccr.fst = cccr.snd) : ∃! (cccr₂ : P × ℝ), cccr₂.fst ∈ affine_Span ℝ (HasInsert.insert p ↑s) ∧ ∀ (p1 : P), p1 ∈ HasInsert.insert p ps → HasDist.dist p1 cccr₂.fst = cccr₂.snd
(z : UpperHalfPlane) : ∃ (g : Matrix.SpecialLinearGroup (Fin 2) ℤ), ∀ (g' : Matrix.SpecialLinearGroup (Fin 2) ℤ), (g' • z).im ≤ (g • z).im
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [CommRing 𝕜] [AddCommGroup E] [AddCommGroup F] [AddCommGroup G] [Module 𝕜 E] [Module 𝕜 F] [Module 𝕜 G] [TopologicalSpace E] [TopologicalSpace F] [TopologicalSpace G] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] [TopologicalAddGroup F] [HasContinuousConstSmul 𝕜 F] [TopologicalAddGroup G] [HasContinuousConstSmul 𝕜 G] (q : FormalMultilinearSeries 𝕜 F G) (p : FormalMultilinearSeries 𝕜 E F) (v : Fin 0 → E) (v' : Fin 0 → F) : ⇑(q.comp p 0) v = ⇑(q 0) v'
{R : Type u} [Ring R] : ¬IsField (Polynomial R)
{cd : Fin 2 → ℤ} (hcd : IsCoprime (cd 0) (cd 1)) : Filter.Tendsto (λ (g : {g // ↑g 1 = cd}), ⇑(modular_group.lc_row0 cd) ↑↑g) Filter.cofinite (Filter.cocompact ℝ)
{α : Type u_1} [TopologicalSpace α] {ι : Type u_2} [hι : Nonempty ι] [Encodable ι] [t2_Space α] {s : ι → Set α} (hs : ∀ (n : ι), MeasureTheory.AnalyticSet (s n)) : MeasureTheory.AnalyticSet (⋂ (n : ι), s n)
{α : Type u} (e p : Equiv.perm α) : ⇑(Equiv.perm_congr e) p = e * p * e⁻¹
{α : Type u_1} {β : Type u_2} [UniformSpace β] {f : α → β} [TopologicalSpace α] (L : ∀ (u : Set (β × β)), u ∈ Uniformity β → (∃ (F : α → β), Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u)) : Continuous f
{α : Type uu} (r : α → α → Prop) [DecidableRel r] [IsTotal α r] [IsTrans α r] (l : List α) : List.Sorted r (list.insertion_sort r l)
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] (p : P) : p ∈ ⊤
(R : Type u_1) {V : Type u_2} {P : Type u_4} [Ring R] [Invertible 2] [AddCommGroup V] [Module R V] [AddTorsor V P] (R' : Type u_3) [Ring R'] [Invertible 2] [Module R' V] (x y : P) : midpoint R x y = midpoint R' x y
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {f : E → F} {g : F → G} {n : WithTop ℕ} (x : E) (hg : ContDiffAt 𝕜 n g (f x)) (hF : ContDiffAt 𝕜 n f x) : ContDiffAt 𝕜 n (g ∘ f) x
{e : ℂ → ℂ} {e' : ℂ} {z : ℝ} (h : HasDerivAt e e' ↑z) : HasDerivAt (λ (x : ℝ), (e ↑x).re) e'.re z
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} {s t : Set α} (hs : (s ∩ Function.MulSupport f).finite) (ht : (t ∩ Function.MulSupport f).finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s ∪ t), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ s ∩ t), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))
{α : Type u_2} {β : Type u_3} {rα : NonAssocSemiring α} {rβ : NonAssocSemiring β} (f : α →+* β) : 0 = 1 ↔ Set.Range ⇑f = {0}
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [StrictConvexSpace ℝ E] {x y : E} : ¬SameRay ℝ x y ↔ ∥x + y∥ < ∥x∥ + ∥y∥
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) {r : ℝ} (hr : r < 0) : o.oangle x (r • y) = o.oangle x (-y)
{ι : Type u_1} {E : Type u_3} [SemiNormedGroup E] {f : ι → E} (hF : Summable (λ (i : ι), ∥f i∥)) : ∥∑' (i : ι), f i∥ ≤ ∑' (i : ι), ∥f i∥
{n : ℕ} {i : Fin (n + 2)} : SimplexCategoryδ i ≫ SimplexCategoryδ (⇑fin.cast_Succ i) = SimplexCategoryδ i ≫ SimplexCategoryδ i.succ
{α : Type u} {β : Type v} [PseudoMetricSpace α] [TopologicalSpace β] {f g : β → UniformSpace.Completion α} (hF : Continuous f) (hg : Continuous g) : Continuous (λ (x : β), HasDist.dist (f x) (g x))
{M : Type u_1} [AddZeroClass M] (s : Set M) {p : Π (x : M), x ∈ AddSubmonoid.closure s → Prop} (Hs : ∀ (x : M) (h : x ∈ s), p x _) (H1 : p 0 _) (hMul : ∀ (x : M) (hx : x ∈ AddSubmonoid.closure s) (y : M) (hy : y ∈ AddSubmonoid.closure s), p x hx → p y hy → p (x + y) _) {x : M} (hx : x ∈ AddSubmonoid.closure s) : p x hx
{α : Type u} {β : Type v} (f : α → β) (g : β → α) : Set.InvOn f g (Function.FixedPoints (f ∘ g)) (Function.FixedPoints (g ∘ f))
{F : Type} [Field F] (q : ℕ) [hq : Fact (Nat.Prime q)] [Char_p F q] (g g' : Polynomial F) (m m' : ℕ) (h_expand : ⇑(Polynomial.expand F (q ^ m)) g = ⇑(Polynomial.expand F (q ^ m')) g') (hg : g.separable) (hg' : g'.separable) : g.nat_degree = g'.nat_degree
{a b c : ℤ} (h : a % b = c) : b ∣ a - c
{α : Type u} [PseudoMetricSpace α] {s t : Set α} {x : α} (hx : x ∈ s) (Fin : emetric.Hausdorff_edist s t ≠ ⊤) : metric.inf_dist x t ≤ metric.Hausdorff_dist s t
{R : Type u} [CommRing R] (S : Submonoid R) {L : Type u} [CommRing L] [Algebra R L] [IsLocalization S L] : Cardinal.mk L ≤ Cardinal.mk R
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι} [TopologicalSpace α] (hs : is_IsCompact s) : TendstoLocallyUniformlyOn F f p s ↔ TendstoUniformlyOn F f p s
{X : Top} (F : Top.Presheaf (Type v) X) {ι : Type v} (U : ι → TopologicalSpace.Opens ↥X) (sf : Top.presheaf.sheaf_condition_Equalizer_products.pi_Opens F U) : F.is_compatible U ((F.pi_Opens_iso_sections_family U).hom sf) ↔ Top.presheaf.sheaf_condition_Equalizer_products.left_res F U sf = Top.presheaf.sheaf_condition_Equalizer_products.right_res F U sf
(n : ℕ) : Finset.univ = Finset.cons (fin.last n) (Finset.map fin.cast_succ.to_Embedding Finset.univ) _
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [Field k] [AddCommGroup E] [Module k E] [AddTorsor E PE] (f : k → PE) (a b c : k) : ((b - a) / (c - a)) • slope f a b + ((c - b) / (c - a)) • slope f b c = slope f a c
(k : Type u_1) {V : Type u_2} (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] : Vector_Span k ∅ = ⊥
{c c' : Σ (n : ℕ), Composition n} : c = c' ↔ c.snd.blocks = c'.snd.blocks
{α : Type u_1} [Semiring α] {m n : ℕ} (h : m ∣ n) : ↑m ∣ ↑n
{n : Type u} [DecidableEq n] [Fintype n] {α : Type v} [CommRing α] (A B : Matrix n n α) : (A.mul B).adjugate = B.adjugate.mul A.adjugate
{M : Type u_4} [GroupWithZero M] {f g : ℚ →*₀ M} (same_on_Int : f.comp (int.cast_RingHom ℚ).to_MonoidWithZero_hom = g.comp (int.cast_RingHom ℚ).to_MonoidWithZero_hom) : f = g
{β : Type u_1} [CommRing β] : fib_rec.char_Poly = Polynomial.x ^ 2 - (Polynomial.x + 1)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P : C} (Q : C) (f : CategoryTheory.Over P) : f ≈ ↑0 ↔ f.hom = 0
{α : Type u_1} {β : Type u_2} (p : Pmf α) (f : α → Pmf β) : p.bind_on_Support (λ (a : α) (_x : a ∈ p.support), f a) = p.bind f
{α : Type u_1} [GeneralizedBooleanAlgebra α] [DecidableRel Disjoint] [DecidableRel has_le.le] (u : α) (s : Finset α) : Uv.IsCompressed u u s
{α : Type u_3} {β : Type u_4} [LinearOrderedField α] {l : Filter β} {f : β → α} {r : α} (hr : 0 < r) (hF : Filter.Tendsto f l filter.at_Top) : Filter.Tendsto (λ (x : β), r * f x) l filter.at_Top
{M : Type u_1} [AddZeroClass M] (S : AddSubmonoid M) {x y : M} : x ∈ S → y ∈ S → x + y ∈ S
{A : Type u_1} {B : Type u_2} [Field A] [Ring B] [is_IsDomain B] [Algebra A B] {x : B} (hx : IsIntegral A x) (h : x ≠ 0) : (minpoly A x).coeff 0 ≠ 0
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [Preorder α] {f : α → Set β} {g : α → Set γ} (hF : Monotone f) (hg : Monotone g) : Monotone (λ (x : α), f x ×ˢ g x)
{α : Type u} [PseudoEmetricSpace α] {x : α} {s : Set α} (h : is_IsClosed s) : x ∈ s ↔ emetric.inf_edist x s = 0
{ι : Type u} {α : Type v} [DecidableEq α] (t : ι → Finset α) (h : ∀ (s : Finset ι), s.card ≤ (s.bUnion t).card) (ι' : Finset ι) : Nonempty ↥(HallMatchingsOn t ι')
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {t : Affine.Triangle ℝ P} {i₁ i₂ : Fin 3} {p : P} (h₁₂ : i₁ ≠ i₂) (h₁ : p ∈ Affine.Simplex.altitude t i₁) (h₂ : p ∈ Affine.Simplex.altitude t i₂) : p = t.orthocenter
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) : HasInner.inner x y = (↑∥x + y∥ ^ 2 - ↑∥x - y∥ ^ 2 + (↑∥x - is_R_or_C.I • y∥ ^ 2 - ↑∥x + is_R_or_C.I • y∥ ^ 2) * is_R_or_C.I) / 4
(p : ℕ) {q : ℚ} (hq : q ≠ 0) : ∃ (z : ℤ), padic_norm p q = ↑p ^ -z
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) : HasInner.inner x y = 0 ↔ InnerProductGeometry.angle x y = Real.pi / 2
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜} (hs : Convex 𝕜 s) (hF : ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) ≤ (f z - f y) / (z - y)) : ConvexOn 𝕜 s f
{k : Type u_1} {V : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] [Fintype ι] {p : ι → P} (hi : AffineIndependent k p) {sp : AffineSubspace k P} [FiniteDimensional k ↥(sp.direction)] (hle : affine_Span k (Set.Range p) ≤ sp) (hc : Fintype.card ι = FiniteDimensional.finrank k ↥(sp.direction) + 1) : affine_Span k (Set.Range p) = sp
{α : Type u_1} [LinearOrderedAddCommGroup α] [Archimedean α] {a : α} (ha : 0 < a) (g : α) : ∃! (k : ℤ), k • a ≤ g ∧ g < (k + 1) • a
{K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {f : V →ₗ[K] V} : Function.Injective ⇑f ↔ Function.Surjective ⇑f
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q R : C} {f : P ⟶ Q} {g : Q ⟶ R} (h : CategoryTheory.Exact f g) : (∀ (a : ↥P), ⇑g (⇑f a) = 0) ∧ ∀ (b : ↥Q), ⇑g b = 0 → (∃ (a : ↥P), ⇑f a = b)
{α : Type u} [PseudoMetricSpace α] {s t : Set α} (incl : s ⊆ t) : Metric.Bounded t → Metric.Bounded s
{β : Type u} {α : Type v} [AddCommMonoid β] {s : Finset α} (hc : s.card ≤ 1) {f : α → β} {b : β} (h : s.sum (λ (x : α), f x) = b) (x : α) (H : x ∈ s) : f x = b
{n : ℕ} (p : Fin (n + 1)) (i : Fin n) : ⇑(p.succ_above) i ≠ p
{ι : Type u_1} {X : Type u_2} [TopologicalSpace X] [NormalSpace X] {u : ι → Set X} {s : Set X} (hs : is_IsClosed s) (uo : ∀ (i : ι), is_IsOpen (u i)) (uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite) (us : s ⊆ ⋃ (i : ι), u i) : ∃ (v : ι → Set X), s ⊆ Set.Union v ∧ (∀ (i : ι), is_IsOpen (v i)) ∧ ∀ (i : ι), Closure (v i) ⊆ u i
{G : Type u} [AddGroup G] {x : G} (hx : IsOfFinAddOrder x) : IsOfFinAddOrder (-x)
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) {X : C} (S : CategoryTheory.Sieve X) : J₁.is_IsClosed (J₁.close S)
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommMonoid β] [Module 𝕜 E] [Module 𝕜 β] [LinearOrder E] {s : Set E} {f : E → β} (hs : Convex 𝕜 s) (hF : ∀ ⦃x y : E⦄, x ∈ s → y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → a • f x + b • f y ≤ f (a • x + b • y)) : ConcaveOn 𝕜 s f
{α : Type u_1} {P : Set α → Prop} {m : Π (s : Set α), P s → Ennreal} {P0 : P ∅} {m0 : m ∅ P0 = 0} {s t : Set α} (h : ∀ (u : Set α), (s ∩ u).nonempty → (t ∩ u).nonempty → ¬P u) : ⇑(measure_theory.induced_OuterMeasure m P0 m0) (s ∪ t) = ⇑(measure_theory.induced_OuterMeasure m P0 m0) s + ⇑(measure_theory.induced_OuterMeasure m P0 m0) t
{n : ℕ} (A B : Finset (Fin n)) : (Finset.image (λ (i : Fin n), ↑i) A).to_colex < (Finset.image (λ (i : Fin n), ↑i) B).to_colex ↔ A.to_colex < B.to_colex
{m : Type u} {n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] [Fintype m] [DecidableEq m] (A : Matrix m m α) (B : Matrix m n α) (C : Matrix n m α) (D : Matrix n n α) [Invertible A] : (matrix.from_blocks A B C D).det = A.det * (D - (C.mul (⅟ A)).mul B).det
{M : Type u_1} [CommMonoid M] (S : Submonoid M) (m : Multiset M) (hm : ∀ (a : M), a ∈ m → a ∈ S) : m.prod ∈ S
{a b : ℕ} (hab : a.coprime b) : (a * b).factorization.support = a.factorization.support ∪ b.factorization.support
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : HasDist.dist p3 p1 = HasDist.dist p3 p2) : EuclideanGeometry.angle p3 (midpoint ℝ p1 p2) p2 = Real.pi / 2
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] [Nontrivial k] {s : Set P} {p : P} (hp : p ∈ s) (w : ↥s → kˣ) : affine_Span k (Set.Range (λ (q : ↥s), ⇑(affine_map.line_Map p ↑q) ↑(w q))) = affine_Span k s
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ HasInner.inner x y = 0
{α : Type u_1} {β : Type u_2} [LinearOrder α] [PredOrder α] [Preorder β] {f : α → β} (hF : Antitone f) : Pairwise (Disjoint on λ (n : α), Set.Ico (f n) (f (Order.pred n)))
(p : ℕ) [hp : Fact (Nat.Prime p)] : Prime ↑p ↔ p % 4 = 3
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) {r : ℝ} (hr : r < 0) : InnerProductGeometry.angle x (r • y) = InnerProductGeometry.angle x (-y)
{α : Type u} [TopologicalSpace α] {a : α} {p : α → Prop} : (∀ᶠ (x : α) in nhds a, p x) ↔ ∃ (t : Set α), (∀ (x : α), x ∈ t → p x) ∧ is_IsOpen t ∧ a ∈ t
{G : Type u_1} [Group G] {H₁ H₂ H₃ : Subgroup G} (h1 : ⁅⁅H₂,H₃⁆,H₁⁆ = ⊥) (h2 : ⁅⁅H₃,H₁⁆,H₂⁆ = ⊥) : ⁅⁅H₁,H₂⁆,H₃⁆ = ⊥
{α : Type u} [TopologicalSpace α] {p : α → Prop} {a : α} (h : ∀ᶠ (y : α) in nhds a, p y) : ∀ᶠ (y : α) in nhds a, ∀ᶠ (x : α) in nhds y, p x
{α : Type u_1} [PseudoEmetricSpace α] (C : Ennreal) {f : ℕ → α} (hu : ∀ (n : ℕ), HasEdist.edist (f n) (f (n + 1)) ≤ C / 2 ^ n) {a : α} (ha : Filter.Tendsto f filter.at_Top (nhds a)) (n : ℕ) : HasEdist.edist (f n) a ≤ 2 * C / 2 ^ n
(A : Type u_1) (B : Type u_2) [Field A] [Ring B] [Algebra A B] [Nontrivial B] : minpoly A 1 = Polynomial.x - 1
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {f : E → F × G} (hF : ContDiff 𝕜 n f) : ContDiff 𝕜 n (λ (x : E), (f x).fst)
(R : Type u_1) [CommRing R] [Fintype R] (p : ℕ) [Fact (Nat.Prime p)] : IsUnit ↑p ↔ ¬p ∣ Ring_Char R
(C : Type u_1) [CategoryTheory.Category C] [CategoryTheory.Preadditive C] : CategoryTheory.IsIdempotentComplete C ↔ ∀ (X : C) (p : X ⟶ X), p ≫ p = p → CategoryTheory.Limits.HasKernel p
{α : Type u_3} [SemilatticeInf α] (a : α) : Filter.map Coe filter.at_IsBot = filter.at_IsBot
{X : Type u} {m₁ m₂ : X → X → X} {e₁ e₂ : X} (h₁ : EckmannHilton.IsUnital m₁ e₁) (h₂ : EckmannHilton.IsUnital m₂ e₂) (Distrib : ∀ (a b c d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) : IsAssociative X m₂
{α : Type u} [TopologicalSpace α] {s : Set α} : Dense (Closure s) → Dense s
{R : Type u_1} [CommRing R] [is_IsDomain R] (K : Type u_2) [Field K] [Algebra R K] [IsFractionRing R K] : IsIntegrallyClosed R ↔ ∀ {x : K}, IsIntegral R x → (∃ (y : R), ⇑(Algebra_Map R K) y = x)
{C : Type u₁} [CategoryTheory.Category C] {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₁₂ : X₁₂ ⟶ X₁₃} {h₂₁ : X₂₁ ⟶ X₂₂} {h₂₂ : X₂₂ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃} (s : CategoryTheory.IsPullback h₁₁ v₁₁ v₁₂ h₂₁) (t : CategoryTheory.IsPullback h₁₂ v₁₂ v₁₃ h₂₂) : CategoryTheory.IsPullback (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂)
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [NondiscreteNormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (f : ContinuousMultilinearMap 𝕜 E G) : ∥f∥ = 0 ↔ f = 0
{ι : Type u_1} {ι' : Type u_2} {R : Type u_3} {M : Type u_5} {v : ι → M} [Semiring R] [AddCommMonoid M] [Module R M] (h : LinearIndependent R v) (f : ι' → ι) (hF : Function.Injective f) : LinearIndependent R (v ∘ f)
{X : Type u_1} [TopologicalSpace X] {α : Type u_2} {β : Type u_3} (f : X → α) (g : α → β) (h : IsLocallyConstant (g ∘ f)) (inj : Function.Injective g) : IsLocallyConstant f
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] (s : Set M) (r : R) (hr : IsUnit r) : Submodule.span R (r • s) = Submodule.span R s
{α : Type u_1} {ι : sort u_3} [ConditionallyCompleteLattice α] [Nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), f x ≤ c) : supr f ≤ c
{α : Type u} [TopologicalSpace α] {s : Set α} : IsPreconnected s ↔ ∀ (u v : Set α), is_IsOpen u → is_IsOpen v → s ⊆ u ∪ v → s ∩ (u ∩ v) = ∅ → s ⊆ u ∨ s ⊆ v
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : E → ℝ} {a : E} (h : is_is_IsLocalMin f a) : fderiv ℝ f a = 0
{M : Type u_1} [SemiNormedGroup M] (S : AddSubgroup M) : ∥0∥ = 0
{𝕜 : Type u_3} {E : Type u_4} [NormedField 𝕜] [AddCommGroup E] [NormedSpace ℝ 𝕜] [Module 𝕜 E] [HasScalar ℝ E] [IsScalarTower ℝ 𝕜 E] (p : Seminorm 𝕜 E) : ConvexOn ℝ Set.Univ ⇑p
(w₁ w₂ p₁ p₂ : Nnreal) : w₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂
{α : Type u} [t : TopologicalSpace α] [TopologicalSpace.SecondCountableTopology α] {f : α → Set α} (hF : ∀ (x : α), f x ∈ nhds x) : ∃ (s : Set α), s.countable ∧ (⋃ (x : α) (H : x ∈ s), f x) = Set.Univ
{a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd b = 1) : a ∣ c
 : Real.sin (Real.pi / 3) ^ 2 = 3 / 4
{α : Type u_1} {r₁ r₂ : Setoid α} : r₁ = r₂ ↔ r₁.classes = r₂.classes
 : subgroup.normal_Closure {⟨Fin_Rotate 5, _⟩} = ⊤
{R : Type u} {M : Type v} [CommRing R] [Nontrivial R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] (f : M →ₗ[R] M) : ⇑(Polynomial.aeval f) f.charpoly = 0
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {M' : Type u_3} [AddCommGroup M'] [Module R M'] (f : M ≃ₗ[R] M) (e : M ≃ₗ[R] M') : ⇑LinearEquiv.det ((e.symm.trans f).trans e) = ⇑LinearEquiv.det f
{α : Type u_1} {c : Set (Set α)} (H : ∀ (a : α), ∃! (b : Set α) (H : b ∈ c), a ∈ b) {x : α} {b b' : Set α} (hc : b ∈ c) (hb : x ∈ b) (hc' : b' ∈ c) (hb' : x ∈ b') : b = b'
{x y : Pgame} (h : x.lf y) (ox : x.numeric) (oy : y.numeric) : x < y
{R : Type u_1} [NonAssocRing R] [Nontrivial R] (hR : Ring_Char R ≠ 2) : Set.InjOn Coe {0, 1, -1}
{ι : Type u_1} {N : Type u_5} [decι : DecidableEq ι] [AddCommGroup N] {p : ι → AddSubgroup N} (h : CompleteLattice.Independent p) : Function.Injective ⇑(dfinsupp.sum_AddHom (λ (i : ι), (p i).subtype))
{α : Type u} [LinearOrderedField α] [TopologicalSpace α] [OrderTopology α] : Filter.Tendsto (λ (r : α), r⁻¹) filter.at_Top (nhds_within 0 (Set.Ioi 0))
 : IsCyclic (QuaternionGroup 1)
{n : Type u_3} {α : Type v} {β : Type w} [HasMul α] [HasMul β] (f : α → β) (r : α) (A : Matrix n n α) (hF : ∀ (a₁ a₂ : α), f (a₁ * a₂) = f a₁ * f a₂) : (r • A).map f = f r • A.map f
{η : Type u_2} {Gs : η → Type u_3} [Π (i : η), Group (Gs i)] [∀ (i : η), group.is_nilpotent (Gs i)] (n : ℕ) (h : ∀ (i : η), group.nilpotency_class (Gs i) ≤ n) : group.is_nilpotent (Π (i : η), Gs i)
{M₀ : Type u_1} [MonoidWithZero M₀] (u : M₀ˣ) : Ring.inverse ↑u = ↑u⁻¹
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) (C : ℝ) {r : Nnreal} (h : ∀ (n : ℕ), ∥p n∥ * ↑r ^ n ≤ C) : ↑r ≤ p.radius
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {x : E} {s t : Set E} (h : nhds_within x s = nhds_within x t) : TangentConeAt 𝕜 s x = TangentConeAt 𝕜 t x
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜} (hF : ConcaveOn 𝕜 s f) {x y z : 𝕜} (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) : (f z - f y) / (z - y) ≤ (f y - f x) / (y - x)
{α : Type u} [PseudoEmetricSpace α] (E : Set α) {δ : ℝ} (δ_Pos : 0 < δ) : Frontier (Metric.Thickening δ E) ⊆ {x : α | emetric.inf_edist x E = ennreal.of_Real δ}
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {t : Set F} (hs : UniqueDiffOn 𝕜 s) (ht : UniqueDiffOn 𝕜 t) : UniqueDiffOn 𝕜 (s ×ˢ t)
{α : Type u_1} {β : Type u_2} [HasMul α] [Preorder α] [Preorder β] [CovariantClass α α has_mul.mul has_lt.lt] [CovariantClass α α (Function.swap has_mul.mul) has_le.le] {f g : β → α} (hF : Monotone f) (hg : StrictMono g) : StrictMono (λ (x : β), f x * g x)
{α : Type u_3} [SemilatticeInf α] (a : α) : filter.at_IsBot = Filter.comap Coe filter.at_IsBot
(R : Type u) [Semiring R] [Nontrivial R] [NoZeroDivisors R] (q : ℕ) [hq : ExpChar R q] : Nat.Prime q ∨ q = 1
{S : Type u_1} [Semigroup S] {a b c : S} (hac : Commute a c) (hbc : Commute b c) : Commute (a * b) c
{α : Type u} [PseudoEmetricSpace α] {s t : Set α} : emetric.Hausdorff_edist s (Closure t) = emetric.Hausdorff_edist s t
(x : ℝ) : LiouvilleWith 1 x
{G : Type u_1} [Group G] {G' : Type u_2} [Group G'] (f : G →* G') (hF : Function.Surjective ⇑f) [h : group.is_nilpotent G] : group.nilpotency_class G' ≤ group.nilpotency_class G
{α : Type u_1} {δ : Type u_5} [TopologicalSpace α] [MeasurableSpace α] [BorelSpace α] [MeasurableSpace δ] [CompleteLinearOrder α] [OrderTopology α] [TopologicalSpace.SecondCountableTopology α] {f : ℕ → δ → α} (hF : ∀ (i : ℕ), Measurable (f i)) : Measurable (λ (x : δ), filter.at_top.limsup (λ (i : ℕ), f i x))
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x : V) {r : ℝ} : 2 • hb.oangle x (r • x) = 0
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {s : Set E} {x : E} {f' : E → (E →L[𝕜] G)} (hs : Convex ℝ s) {f : E → G} (hder : ∀ᶠ (y : E) in nhds_within x s, HasFderivWithinAt f (f' y) s y) (hcont : ContinuousWithinAt f' s x) : ∃ (K : Nnreal) (t : Set E) (H : t ∈ nhds_within x s), LipschitzOnWith K f t
{M : Type u_6} {N : Type u_7} [HasMul M] [HasMul N] (e : M ≃* N) (x : M) : ⇑(e.symm) (⇑e x) = x
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [SemiNormedGroup E] [NormedSpace 𝕜 E] {s : Set E} {x' : NormedSpace.Dual 𝕜 E} {c : 𝕜} (hc : ∀ (z : E), z ∈ s → ∥⇑x' z∥ ≤ ∥c∥) : c⁻¹ • x' ∈ NormedSpace.Polar 𝕜 s
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b
{α : Type u_1} [CanonicallyOrderedAddMonoid α] [HasSub α] [HasOrderedSub α] {a b : α} [ContravariantClass α α has_add.add has_le.le] (h : a ≤ b) : b - (b - a) = a
{R : Type u} {L : Type v} [CommRing R] [LieRing L] [LieAlgebra R L] : LieAlgebra.IsNilpotent R ↥((LieAlgebra.ad R L).range) ↔ LieAlgebra.IsNilpotent R L
{P : Type u_2} [MetricSpace P] {ps₁ ps₂ : Set P} (hs : ps₁ ⊆ ps₂) (hc : EuclideanGeometry.Cospherical ps₂) : EuclideanGeometry.Cospherical ps₁
 : Real.cos (Real.pi / 6) = Real.sqrt 3 / 2
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {f : E → G} {s : Set E} {f' : E → (E →L[𝕜] G)} {C : Nnreal} (hF : ∀ (x : E), x ∈ s → HasFderivWithinAt f (f' x) s x) (bound : ∀ (x : E), x ∈ s → ∥f' x∥₊ ≤ C) (hs : Convex ℝ s) : LipschitzOnWith C f s
{x : Pgame} : x ≤ 0 ↔ ∀ (i : x.left_moves), (x.move_Left i).lf 0
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} : ContDiff 𝕜 ⊤ f ↔ Differentiable 𝕜 f ∧ ContDiff 𝕜 ⊤ (λ (y : E), fderiv 𝕜 f y)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] (O : Finset C) (H : Finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y)) {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : X ⟶ Y} (mf : ⟨X, ⟨Y, ⟨mX, ⟨mY, f⟩⟩⟩⟩ ∈ H) : f ≫ Category_theory.is_filtered.to_Sup O H mY = Category_theory.is_filtered.to_Sup O H mX
{n : ℕ} {E : Type u_1} [NormedGroup E] {f : (Fin n → ℂ) → E} {c : Fin n → ℂ} {R : Fin n → ℝ} (hF : TorusIntegrable f c R) : TorusIntegrable (-f) c R
{n : ℕ+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [NeZero ↑↑n] [IsCyclotomicExtension {n} K L] (hn : n ≠ 2) (hirr : Irreducible (Polynomial.cyclotomic ↑n K)) : ⇑(Algebra.norm K) (IsCyclotomicExtension.zeta n K L) = 1
{M : Type u_1} [MulOneClass M] {c : Con M} : Function.Surjective ⇑(c.mk')
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (x : ↥(NonZeroDivisors R)) : v.int_Valuation_def ↑x ≠ 0
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {s : Set E} {f : E → F} {g : E → G} (hF : ContDiffOn 𝕜 n f s) (hg : ContDiffOn 𝕜 n g s) : ContDiffOn 𝕜 n (λ (x : E), (f x, g x)) s
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {ι : Type u_1} (b : Basis ι R M) [Infinite ι] {κ : Type u_1} (v : κ → M) (i : LinearIndependent R v) (m : i.maximal) : Cardinal.mk κ = Cardinal.mk ι
{a b : Ennreal} (h : a < b) : AddLeCancellable a
{α : sort u_1} (r : α → α → Prop) : Function.Surjective (Quot.mk r)
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {b : M} [LinearOrderedCommRing M] (ht : ↑(s.card) < t.card • b) : ∃ (y : β) (H : y ∈ t), ↑((Finset.filter (λ (x : α), f x = y) s).card) < b
{X : Type u_1} [TopologicalSpace X] [CompactSpace X] (A : Subalgebra ℝ C(X, ℝ)) (f : ↥A) (g : Polynomial ℝ) : (g.to_Continuous_Map_on (Set.Icc (-∥f∥) ∥f∥)).comp ↑f.attach_bound ∈ A
{E : Type u_2} [SemiNormedGroup E] [NormedSpace ℝ E] (s : Set E) : Metric.diam (⇑(Convex_hull ℝ) s) = Metric.diam s
{G : Type u_1} [Group G] [hH : group.is_nilpotent G] : group.nilpotency_class (G ⧸ Subgroup.center G) = group.nilpotency_class G - 1
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x y + o.oangle y z + o.oangle z x = 0
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) : ⇑(hb.rotation (hb.oangle x y)) x = y ↔ ∥x∥ = ∥y∥
(n : ℤ) : ⇑Zmodχ₄ ↑n = Ite (n % 2 = 0) 0 (Ite (n % 4 = 1) 1 (-1))
{X : Type u_1} [TopologicalSpace X] {s t : Set X} (ds : DiscreteTopology ↥s) (ts : t ⊆ s) : DiscreteTopology ↥t
{M : Type u_1} [Monoid M] {x : M} (m : ℕ) {n : ℕ} (h : x ^ n = 1) : x ^ m = x ^ (m % n)
{ι : Type u} {X : Type v} [TopologicalSpace X] {s : Set X} [NormalSpace X] [ParacompactSpace X] (hs : is_IsClosed s) (U : ι → Set X) (ho : ∀ (i : ι), is_IsOpen (U i)) (hU : s ⊆ ⋃ (i : ι), U i) : ∃ (f : PartitionOfUnity ι X s), f.is_subordinate U
{Fq : Type u_1} [Fintype Fq] [Field Fq] {x y z : Polynomial Fq} {a : ℤ} (hxy : ⇑polynomial.card_Pow_degree (x - y) < a) (hyz : ⇑polynomial.card_Pow_degree (y - z) < a) : ⇑polynomial.card_Pow_degree (x - z) < a
{R : Type u} [Semiring R] {ι : Type v} [decι : DecidableEq ι] {M : Type u_1} [AddCommMonoid M] [Module R M] {A : ι → Submodule R M} (h : DirectSum.IsInternal A) : CompleteLattice.Independent A
{x y : Pgame} (r : x.relabelling y) : x.equiv y
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂] [Module K V₂] {f : V →ₗ[K] V₂} (hF : Function.Injective ⇑f) : FiniteDimensional.finrank K ↥(f.range) = FiniteDimensional.finrank K V
{γ : Type u_1} [NonUnitalNonAssocSemiring γ] (x : γ) : IsAddMonoidHom (λ (y : γ), x * y)
{R : Type u_1} {E : Type u_2} {F : Type u_3} [AddCommGroup E] [TopologicalSpace E] [AddCommGroup F] [TopologicalSpace F] [TopologicalAddGroup F] [Ring R] [Module R E] [Module R F] {f : E →ᵃ[R] F} : Continuous ⇑f ↔ Continuous ⇑(f.linear)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] (a : α) [NoMinOrder α] : Closure (Set.Iio a) = Set.Iic a
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) {r : Nnreal} (h : ↑r < p.radius) : ∃ (C : Nnreal) (H : C > 0), ∀ (n : ℕ), ∥p n∥₊ * r ^ n ≤ C
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0
(α : Type u) (β : Type u_1) [t : TopologicalSpace β] [TopologicalSpace.SecondCountableTopology β] (f : α → β) : TopologicalSpace.SecondCountableTopology α
{α : Type u} [TopologicalSpace α] {s : Set α} : is_IsClopen s → Frontier s = ∅
{α : Type u_1} [ConditionallyCompleteLattice α] {s : Set α} {b : α} (hs : s.nonempty) (h_is_ub : ∀ (a : α), a ∈ s → a ≤ b) (h_b_LE_ub : ∀ (ub : α), (∀ (a : α), a ∈ s → a ≤ ub) → b ≤ ub) : HasSup.sup s = b
{α : Type u_1} {β : Type u_2} [MeasurableSpace α] [TopologicalSpace β] [TopologicalSpace.PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β] {f : ℕ → α → β} {g : α → β} (hF : ∀ (i : ℕ), Measurable (f i)) (lim : Filter.Tendsto f filter.at_Top (nhds g)) : Measurable g
{α : Type u} [TopologicalSpace α] {ι : Type u_1} [CompactSpace α] {f : ι → Set α} (hF : LocallyFinite f) (hne : ∀ (i : ι), (f i).nonempty) : set.univ.finite
{R : Type u_1} [CommRing R] [is_IsDomain R] (K : Type u_2) [Field K] [Algebra R K] [IsFractionRing R K] : IsIntegrallyClosed R ↔ is_IsIntegralClosure R R K
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {f : E → F × G} (hF : ContDiff 𝕜 n f) : ContDiff 𝕜 n (λ (x : E), (f x).snd)
{R : Type u₁} {L : Type u₂} [CommRing R] [LieRing L] [LieAlgebra R L] [IsNoetherian R L] : LieAlgebra.IsEngelian R L
{R : Type v} [CommRing R] (A : Matrix (Fin 1) (Fin 1) R) : A.det = A 0 0
{α : Type u_1} (L : List (List α)) {i : ℕ} (hi : i < L.length) : List.drop (List.take i (List.map List.length L)).sum (List.take (List.take (i + 1) (List.map List.length L)).sum L.join) = L.nth_LE i hi
{M : Type u_4} [TopologicalSpace M] [AddMonoid M] [HasContinuousAdd M] {U : Set M} (hU : U ∈ nhds 0) : ∃ (V : Set M), is_IsOpen V ∧ 0 ∈ V ∧ V + V ⊆ U
(n p : ℕ) : (Finset.ico 1 (n + 1)).sum (λ (k : ℕ), ↑k ^ p) = (Finset.range (p + 1)).sum (λ (i : ℕ), bernoulli' i * ↑((p + 1).choose i) * ↑n ^ (p + 1 - i) / (↑p + 1))
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] [IsNoetherianRing R] : Algebra.FiniteType R A ↔ Algebra.FinitePresentation R A
{α : Type u_1} [TopologicalSpace α] [PolishSpace α] {s : Set α} (hs : is_IsClosed s) : PolishSpace.IsClopenable s
{α : Type u} [SemilatticeInf α] [OrderTop α] {ι : Type u} [Fintype ι] (f : ι → α) : (∏ f) = (Fintype.elems ι).inf f
{α : Type u} {β : Type v} [PseudoEmetricSpace α] [PseudoEmetricSpace β] {f : α → β} (hF : Isometry f) : UniformInducing f
{α : Type u_1} [Preorder α] [OrderBot α] {a : α} : IsAtom a → IsCoatom (⇑order_dual.to_dual a)
{α : Type u} [HasSsubset α] [IsAsymm α HasSsubset.Ssubset] {a b : α} (h : a ⊂ b) : ¬b ⊂ a
{p : ℕ} {G : Type u_1} [Group G] {P : Subgroup G} (hP : is_p_Group p ↥P) : ∃ (Q : Sylow p G), P ≤ ↑Q
{M : Type u_1} [Monoid M] : monoid.fg M ↔ ∃ (S : Set M), Submonoid.closure S = ⊤ ∧ S.finite
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set ℝ} [Interval_integral.FTC_Filter b (nhds_within b s) (nhds_within b t)] (hmeas : StronglyMeasurableAtFilter f (nhds_within b t) MeasureTheory.MeasureSpace.volume) (hb : ContinuousWithinAt f t b) : HasDerivWithinAt (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) (f b) s b
{C : Type u} [CategoryTheory.Category C] {X Y : C} (i : CategoryTheory.Arrow C) (p : X ≅ Y) : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.mk p.hom)
{K : Type u} {V : Type v} {V' : Type v'} [DivisionRing K] [AddCommGroup V] [Module K V] [AddCommGroup V'] [Module K V'] (Cond : (Module.rank K V).lift = (Module.rank K V').lift) : Nonempty (V ≃ₗ[K] V')
 : StrictMono Real.sinh
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι} [UniformSpace γ] {g : β → γ} (h : TendstoUniformly F f p) (hg : UniformContinuous g) : TendstoUniformly (λ (i : ι), g ∘ F i) (g ∘ f) p
{a b : ℝ} : ∫ (x : ℝ) in a..b, Real.sin x * Real.cos x = (Real.sin b ^ 2 - Real.sin a ^ 2) / 2
{ι : Type u_1} {X : Type u_2} [TopologicalSpace X] [NormalSpace X] {u : ι → Set X} {s : Set X} (v : ShrinkingLemma.PartialRefinement u s) (hs : is_IsClosed s) (i : ι) (hi : i ∉ v.carrier) : ∃ (v' : ShrinkingLemma.PartialRefinement u s), v < v'
{K : Type u_8} {K₁ : Type u_9} {V₁ : Type u_12} {n : Type u_14} [Field K] [Field K₁] [AddCommGroup V₁] [Module K₁ V₁] {I₁ I₁' : K₁ →+* K} {B : V₁ →ₛₗ[I₁] V₁ →ₛₗ[I₁'] K} {v : n → V₁} (hv₁ : B.is_Ortho v) (hv₂ : ∀ (i : n), ¬B.is_IsOrtho (v i) (v i)) : LinearIndependent K₁ v
{F : Type u_8} {G : Type u_1} {H : Type u_2} [Group G] [MulOneClass H] [MonoidHomClass F G H] (f : F) : Function.Injective ⇑f ↔ ∀ (a : G), ⇑f a = 1 ↔ a = 1
{n : ℕ} (c : Composition n) {j : ℕ} (h : j < n) : ∃ (i : ℕ), j < c.size_Up_to i.succ ∧ i < c.length
 : True
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {ι : Type w} {s : Finset ι} (h : Basis ↥s K V) : FiniteDimensional K V
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f : ℂ → E} {c : ℂ} {R : ℝ} {w : ℂ} (hF : CircleIntegrable f c R) (hw : Complex.abs w < R) : HasSum (λ (n : ℕ), ∮ (z : ℂ) in C(c, R), (w / (z - c)) ^ n • (z - c)⁻¹ • f z) (∮ (z : ℂ) in C(c, R), (z - (c + w))⁻¹ • f z)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x : V) : hb.oangle 0 x = 0
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {G : C ⥤ D} {K : CategoryTheory.GrothendieckTopology D} [CategoryTheory.Full G] [CategoryTheory.Faithful G] (Hld : CategoryTheory.LocallyCoverDense K G) : CategoryTheory.CoverPreserving Hld.induced_topology K G
{ι : Type u} {β : ι → Type v} [Π (i : ι), HasZero (β i)] {f g : Π₀ (i : ι), β i} : f = g ↔ ∀ (i : ι), ⇑f i = ⇑g i
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f : ℂ → E} {c : ℂ} (hD : ∀ᶠ (z : ℂ) in nhds_within c {c}ᶜ, DifferentiableAt ℂ f z) (hc : ContinuousAt f c) : AnalyticAt ℂ f c
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : ℕ} {i : Fin (n + 1)} : X.σ i ≫ X.δ i.succ = 𝟙 (X.obj (Opposite.op (SimplexCategory.mk n)))
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] (p : P) : Function.Injective (λ (_x : G), _x +ᵥ p)
{α : Type u} [DecidableEq α] (i j : α) : Function.involutive (has_mul.mul (equiv.swap i j))
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι} [TopologicalSpace α] [CompactSpace α] : TendstoLocallyUniformly F f p ↔ TendstoUniformly F f p
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [SemiNormedGroup E'] {g : α → F} {f' : α → E'} {l : Filter α} : f' =o[l] g → (λ (x : α), ∥f' x∥) =o[l] g
{α : Type u} [OrderedSemiring α] {a b c d : α} [HasExistsAddOfLe α] (hab : a < b) (hcd : c < d) : a * d + b * c < a * c + b * d
{α : Type u} {L : List (α × Bool)} [DecidableEq α] : FreeGroup.Red L (FreeGroup.reduce L)
{V₁ : Type u_2} {V₂ : Type u_3} [SemiNormedGroup V₁] [SemiNormedGroup V₂] (f : V₁ →+ V₂) {C : ℝ} (h : ∀ (x : V₁), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_NormedGroupHom C h∥ ≤ Linear_order.max C 0
{l : Filter ℝ} {f f' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in filter.at_Top, HasDerivAt f (f' x) x) (hgg' : ∀ᶠ (x : ℝ) in filter.at_Top, HasDerivAt g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in filter.at_Top, g' x ≠ 0) (hftop : Filter.Tendsto f filter.at_Top (nhds 0)) (hgtop : Filter.Tendsto g filter.at_Top (nhds 0)) (hDiv : Filter.Tendsto (λ (x : ℝ), f' x / g' x) filter.at_Top l) : Filter.Tendsto (λ (x : ℝ), f x / g x) filter.at_Top l
{p : ℕ} {R : Type u_1} [hp : Fact (Nat.Prime p)] [CommRing R] (x y : WittVector p R) : ⇑WittVector.verschiebung (x * ⇑WittVector.frobenius y) = ⇑WittVector.verschiebung x * y
{α : Type u_1} {m m' : MetricSpace α} (h : pseudo_metric_space.to_HasDist = pseudo_metric_space.to_HasDist) : m = m'
{α : Type u} {β : Type v} [PseudoMetricSpace α] [Nonempty β] [SemilatticeSup β] {s : β → α} (b : β → ℝ) (h : ∀ (n m : β), n ≤ m → HasDist.dist (s n) (s m) ≤ b n) (h₀ : Filter.Tendsto b filter.at_Top (nhds 0)) : CauchySeq s
{p : ℕ} [Fact (Nat.Prime p)] {q r : ℚ_[p]} : padic_norm_e q ≠ padic_norm_e r → padic_norm_e (q + r) = Linear_order.max (padic_norm_e q) (padic_norm_e r)
{A : Type u_1} {K : Type u_2} [CommRing A] [is_IsDomain A] [UniqueFactorizationMonoid A] [Field K] [Algebra A K] [IsFractionRing A K] {p : Polynomial A} {r : K} (hr : ⇑(Polynomial.aeval r) p = 0) : ↑(IsFractionRing.denom A r) ∣ p.leading_Coeff
{M : Type u_3} {N : Type u_4} [MulOneClass M] [MulOneClass N] (f : M →* N) (a b : M) : ⇑f (a * b) = ⇑f a * ⇑f b
{α : Type u} [TopologicalSpace α] {s : Set α} (hs : is_IsClosed s) : IsPreconnected s ↔ ∀ (u v : Set α), is_IsClosed u → is_IsClosed v → s ⊆ u ∪ v → u ∩ v = ∅ → s ⊆ u ∨ s ⊆ v
{ι : Type u_1} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {G : ι → Type u_4} [Π (i : ι), InnerProductSpace 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 V) [∀ (i : ι), CompleteSpace (G i)] (hV' : (⨆ (i : ι), (V i).to_LinearMap.range).topological_Closure = ⊤) (W₀ : Π₀ (i : ι), G i) : ⇑(⇑(hV.linear_Isometry_Equiv hV') (W₀.sum (λ (i : ι), ⇑(V i)))) = ⇑W₀
(a b : Ennreal) {p q : ℝ} (hpq : p.is_conjugate_exponent q) : a * b ≤ a ^ p / ennreal.of_Real p + b ^ q / ennreal.of_Real q
{n : ℕ} (a : Fin (n + 1)) : ↑↑a = a
{C : Type u} [CategoryTheory.Category C] {X Y : C} (f : X ⟶ Y) (t : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.PushoutCocone.mk (𝟙 Y) (𝟙 Y) rfl)) : CategoryTheory.Epi f
{α : Type u_1} {r : α → α → Prop} (h : Reflexive r) {x y : α} (hr : x ≠ y → r x y) : r x y
{R : Type u} [Ring R] (s : Subring R) {x y : R} : x ∈ s → y ∈ s → x * y ∈ s
{R : Type u_1} (M : Type u_3) [HasZero R] [HasZero M] [SmulWithZero R M] (r : R) : r • 0 = 0
{α : Type u_2} {β : Type u_3} [SemilatticeInf α] [OrderBot α] [SemilatticeInf β] [OrderBot β] {a b : α} (f : α ≃o β) (ha : Disjoint a b) : Disjoint (⇑f a) (⇑f b)
{α : Type u} {β : Type v} [Preorder α] [SemilatticeInf β] {f g : α → β} (hF : Antitone f) (hg : Antitone g) : Antitone (f ⊓ g)
(X : AlgebraicGeometry.LocallyRingedSpace (x : ↥X) : algebraic_geometry.structure_sheaf.to_stalk ↥(Opposite.unop (Opposite.op (AlgebraicGeometry.LocallyRingedSpaceΓ.obj (Opposite.op X)))) (⇑(X.to_Γ_spec_SheafedSpace.base) x) ≫ algebraic_geometry.PresheafedSpace.stalk_Map X.to_Γ_spec_SheafedSpace x = X.Γ_to_stalk x
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {R₁ R₂ : ℝ} {f : ℂ → E} {c z : ℂ} (hD : DifferentiableOn ℂ f (Metric.Ball c R₁)) (h_maps : Set.MapsTo f (Metric.Ball c R₁) (Metric.Ball (f c) R₂)) (hz : z ∈ Metric.Ball c R₁) : HasDist.dist (f z) (f c) ≤ R₂ / R₁ * HasDist.dist z c
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {F : J ⥤ C} {X : C} (h : Category_theory.coyoneda.obj (Opposite.op X) ⋙ Category_theory.ulift_Functor ≅ F.cocones) (s : CategoryTheory.Limits.Cocone F) : (Category_theory.limits.is_colimit.of_Nat_iso.colimit_Cocone h).extend (Category_theory.limits.is_colimit.of_Nat_iso.hom_of_Cocone h s) = s
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_4} [Fintype ι] (b : Basis ι R M) : (LinearMap.trace R M).comp (dual_tensor_hom R M M) = contract_Left R M
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : HasInner.inner (x + y) (x - y) = 0 ↔ ∥x∥ = ∥y∥
{α : Type u_1} [TopologicalSpace α] [TopologicalSpace.SecondCountableTopology α] (m : MeasureTheory.OuterMeasure α) {s : Set α} (hs : ⇑m s ≠ 0) : ∃ (x : α) (H : x ∈ s), ∀ (t : Set α), t ∈ nhds_within x s → 0 < ⇑m t
{G : Type u_1} [Group G] (H : Subgroup G) {x y : G} (hx : x ∈ H) (hy : y ∈ H) : x / y ∈ H
{α : Type u_1} {β : Type u_2} [AddMonoid β] {s : Finset α} (f g : α → β) (comm_ff : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → AddCommute (f x) (f y)) (comm_gg : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → AddCommute (g x) (g y)) (comm_gf : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≠ y → AddCommute (g x) (f y)) : s.noncomm_Sum (f + g) _ = s.noncomm_Sum f comm_ff + s.noncomm_Sum g comm_gg
(k : Type u_1) (G : Type u_2) [CommSemiring k] [Group G] [Fintype G] [Invertible ↑(Fintype.card G)] (g : G) : GroupAlgebra.average k G * Finsupp.single g 1 = GroupAlgebra.average k G
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) : ⇑LinearMap.det ↑(hb.conj_lie.to_LinearEquiv) = -1
 : Irrational GoldenRatio
{n : ℤ} : Even n → Even n.nat_Abs
{M : Type u_1} [Monoid M] {x y z : M} : y ∈ Powers x → z ∈ Powers x → y * z ∈ Powers x
{M : Type u_1} [HasMul M] {c d : Con M} (H : ∀ (x y : M), ⇑c x y ↔ ⇑d x y) : c = d
{n : WithTop ℕ} {𝕂 : Type u_6} [is_R_or_C 𝕂] {E' : Type u_7} [NormedGroup E'] [NormedSpace 𝕂 E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {f : E' → F'} {f' : E' →L[𝕂] F'} {x : E'} (hF : ContDiffAt 𝕂 n f x) (hF' : HasFderivAt f f' x) (hn : 1 ≤ n) : HasStrictFderivAt f f' x
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) {l : List L} : (∀ (x : L), x ∈ l → x ∈ S) → l.prod ∈ S
{R : Type u} {A : Type v} [CommSemiring R] [Ring A] [Algebra R A] {r : R} {a : A} : r ∈ ResolventSet R a ↔ IsUnit (resolvent a r)
{α : Type u_1} [HasLt α] {a b : α} (h : a < b) : ¬a ⋖ b ↔ ∃ (c : α), a < c ∧ c < b
{α : Type u} [Preorder α] {a b c : α} (hab : a = b) (hbc : b < c) : a < c
(a b : Nnreal) {p q : Nnreal} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1) : a * b ≤ a ^ ↑p / p + b ^ ↑q / q
 : Cardinal.mk ℝ = Cardinal.continuum
(K : Type u) {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {A : Set V} (hA : A.finite) : FiniteDimensional K ↥(Submodule.span K A)
{α : Type u_1} [PseudoMetricSpace α] {E' : Type u_2} [NormedGroup E'] [NormedSpace ℝ E'] [FiniteDimensional ℝ E'] {s : Set α} {f : α → E'} {K : Nnreal} (hF : LipschitzOnWith K f s) : ∃ (g : α → E'), LipschitzWith (lipschitz_extension_constant E' * K) g ∧ Set.EqOn f g s
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {e e' : LocalHomeomorph α β} {f f' : LocalHomeomorph β γ} (hE : e ≈ e') (hF : f ≈ f') : e.trans f ≈ e'.trans f'
{α : Type u_1} {ι : sort u_4} [CompleteLattice α] {b : α} {f : ι → α} (h₁ : ∀ (i : ι), f i ≤ b) (h₂ : ∀ (w : α), w < b → (∃ (i : ι), w < f i)) : (⨆ (i : ι), f i) = b
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] {p : P} (hp : p ∈ s) {v : V} (hv : v ∈ (s.direction)ᗮ) : ⇑(euclidean_geometry.orthogonal_projection s) (v +ᵥ p) = ⟨p, hp⟩
{𝕜 : Type u_1} {n : Type u_3} [is_R_or_C 𝕜] [Fintype n] [DecidableEq n] {U : Matrix n n 𝕜} (hU : U ∈ matrix.unitary_Group n 𝕜) : ∥U∥ ≤ 1
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X ⟶ Y} (t : CategoryTheory.Limits.Cofork f g) [CategoryTheory.Mono t.π] : f = g
(𝕂 : Type u_1) (𝕂' : Type u_2) (𝔸 : Type u_3) [Field 𝕂] [Field 𝕂'] [Ring 𝔸] [Algebra 𝕂 𝔸] [Algebra 𝕂' 𝔸] [TopologicalSpace 𝔸] [TopologicalRing 𝔸] : Exp 𝕂 = Exp 𝕂'
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} [LinearOrder 𝕜] [OrderClosedTopology 𝕜] {x y : 𝕜} (h : x < y) : HasDerivWithinAt f f' (Set.Ioo x y) x → HasDerivWithinAt f f' (Set.Ioi x) x
{α : Type u} {ι : Type u_1} [TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α} (hs : is_IsCompact s) (hc₁ : ∀ (i : ι), i ∈ b → is_IsOpen (c i)) (hc₂ : s ⊆ ⋃ (i : ι) (H : i ∈ b), c i) : ∃ (b' : Set ι) (H : b' ⊆ b), b'.finite ∧ s ⊆ ⋃ (i : ι) (H : i ∈ b'), c i
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M →* P} (hg : ∀ (y : ↥S), IsUnit (⇑g ↑y)) (z : N) (w v : P) : ⇑(f.lift hg) z * w = v ↔ ⇑g (f.sec z).fst * w = ⇑g ↑((f.sec z).snd) * v
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type w} {X Y : C} {R : CategoryTheory.Presieve X} {x : CategoryTheory.Presieve.FamilyOfElements P R} (t : x.compatible) {f : Y ⟶ X} (hF : R f) : x.sieve_extend f _ = x f hF
(L : List ℕ) (h : ∀ (i : ℕ), i ∈ L → 1 ≤ i) : L.length ≤ L.sum
{R : Type u} [Ring R] (s : Subring R) {l : List R} : (∀ (x : R), x ∈ l → x ∈ s) → l.sum ∈ s
{E : Type u_1} [SemiNormedGroup E] [NormedSpace ℝ E] {x y : E} (h : SameRay ℝ x y) : ∥x + y∥ = ∥x∥ + ∥y∥
{K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {f g : V →ₗ[K] V} (hfg : f * g = 1) : g * f = 1
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hF : HasFpowerSeriesAt f p x) : (λ (y : E × E), f y.fst - f y.snd - ⇑(p 1) (λ (_x : Fin 1), y.fst - y.snd)) =O[nhds (x, x)] λ (y : E × E), ∥y - (x, x)∥ * ∥y.fst - y.snd∥
{α : Type u_1} [CommSemiring α] (E : LinearRecurrence α) {u : ℕ → α} {init : Fin E.order → α} (h : E.is_solution u) (HEq : ∀ (n : Fin E.order), u ↑n = init n) (n : ℕ) : u n = E.mk_sol init n
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {n : ℕ} : ContDiff 𝕜 ↑(n + 1) f ↔ Differentiable 𝕜 f ∧ ContDiff 𝕜 ↑n (λ (y : E), fderiv 𝕜 f y)
{R : Type u_2} [CommRing R] [is_IsDomain R] [IsPrincipalIdealRing R] {M : Type u_3} [AddCommGroup M] [Module R M] {ι : Type u_1} [Fintype ι] (b : Basis ι R M) (N : Submodule R M) : ∃ (n : ℕ), Nonempty (Basis (Fin n) R ↥N)
{β : Type u} {α : Type v} {s : Finset α} {f : α → β} [AddCommMonoid β] (R : Setoid α) [DecidableRel Setoid.r] (h : ∀ (x : α), x ∈ s → (Finset.filter (λ (y : α), y ≈ x) s).sum (λ (a : α), f a) = 0) : s.sum (λ (x : α), f x) = 0
{R : Type u_1} {M : Type u_2} [CommRing R] [AddCommGroup M] [Module R M] (Q : QuadraticForm R M) {P : Π (x : CliffordAlgebra Q), x ∈ clifford_algebra.even_Odd Q 1 → Prop} (hι : ∀ (v : M), P (⇑(CliffordAlgebraι Q) v) _) (hAdd : ∀ {x y : CliffordAlgebra Q} {hx : x ∈ clifford_algebra.even_Odd Q 1} {hy : y ∈ clifford_algebra.even_Odd Q 1}, P x hx → P y hy → P (x + y) _) (hιι_Mul : ∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ clifford_algebra.even_Odd Q 1}, P x hx → P (⇑(CliffordAlgebraι Q) m₁ * ⇑(CliffordAlgebraι Q) m₂ * x) _) (x : CliffordAlgebra Q) (hx : x ∈ clifford_algebra.even_Odd Q 1) : P x hx
{M : Type u_1} {N : Type u_2} {α : Type u_6} {β : Type u_7} [HasScalar M α] [HasScalar β α] [SmulCommClass β M α] (g : N → M) : SmulCommClass β N α
{m : Type u_1} {A : Type u_3} [Fintype m] [CommRing A] [is_IsDomain A] [DecidableEq m] {M : Matrix m m A} (hM : M.det ≠ 0) : M.nondegenerate
{α : Type u_1} {β : Type u_2} {e e' : LocalEquiv α β} (h : e ≈ e') : e.symm ≈ e'.symm
{α : Type u} [PseudoEmetricSpace α] {s t : Set α} : emetric.Hausdorff_edist (Closure s) (Closure t) = emetric.Hausdorff_edist s t
{R : Type u} {M : Type v} [Monoid R] [MulAction R M] {p : SubMulAction R M} (m : ↥p) : MulAction.Stabilizer.submonoid R m = MulAction.Stabilizer.submonoid R ↑m
{α : Type u_2} [DecidableEq α] {B : Finset (Finset α)} {n : ℕ} [Fintype α] (h : ∀ (a : α), (Finset.filter (HasMem.Mem a) B).card ≤ n) : B.sum (λ (s : Finset α), s.card) ≤ Fintype.card α * n
{G : Type u_1} [Group G] {H : Type u_2} [Group H] (f : G →* H) (hF1 : f.ker ≤ Subgroup.center G) (hH : group.is_nilpotent H) : group.is_nilpotent G
{α : Type u} [Group α] [HasLe α] [CovariantClass α α has_mul.mul has_le.le] [CovariantClass α α (Function.swap has_mul.mul) has_le.le] {a b : α} : a ≤ b⁻¹ → b ≤ a⁻¹
{β : Type u_2} [PseudoMetricSpace β] {α : Type u_1} [MetricSpace α] {K : Nnreal} {f : α → β} [ProperSpace α] (hK : AntilipschitzWith K f) (f_Cont : Continuous f) (hF : Function.Surjective f) : ProperSpace β
{α : Type u} [EmetricSpace α] {s t : TopologicalSpace.Closeds α} : HasEdist.edist s t = emetric.Hausdorff_edist ↑s ↑t
{R : Type u} [NonAssocSemiring R] (s : Subsemiring R) : 0 ∈ s
{X : Type u_2} [EmetricSpace X] [MeasurableSpace X] [OpensMeasurableSpace X] (m : Set X → Ennreal) (hcl : ∀ (s : Set X), m (Closure s) = m s) (r : Ennreal) : (measure_theory.outer_measure.mk_metric'.pre m r).trim = measure_theory.outer_measure.mk_metric'.pre m r
{ι : Type u_1} {R : Type u_2} [CommRing R] [is_IsDomain R] [IsPrincipalIdealRing R] {M : Type u_3} [AddCommGroup M] [Module R M] [Fintype ι] (b : Basis ι R M) (N O : Submodule R M) (N_LE_O : N ≤ O) : ∃ (n o : ℕ) (hno : n ≤ o) (bO : Basis (Fin o) R ↥O) (bN : Basis (Fin n) R ↥N) (a : Fin n → R), ∀ (i : Fin n), ↑(⇑bN i) = a i • ↑(⇑bO (⇑(fin.cast_LE hno) i))
{α : Type u} [TopologicalSpace α] [t2_Space α] [CompactSpace α] [TotallyDisconnectedSpace α] {x : α} {U : Set α} (is_IsOpen : _root_.is_IsOpen U) (memU : x ∈ U) : ∃ (V : Set α) (hV : is_IsClopen V), x ∈ V ∧ V ⊆ U
{α : Type u_1} {n : Type u_2} {m : Type u_3} [HasMul α] [AddCommMonoid α] (A : Matrix m n α) [Fintype n] : A.transpose.has_Orthogonal_cols ↔ A.has_Orthogonal_rows
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {E' : Type u_6} [NormedGroup E'] [NormedSpace 𝕜 E'] {F' : Type u_7} [NormedGroup F'] [NormedSpace 𝕜 F'] {s : Set E} {t : Set E'} {f : E → F} {g : E' → F'} {p : E × E'} (hF : ContDiffWithinAt 𝕜 n f s p.fst) (hg : ContDiffWithinAt 𝕜 n g t p.snd) : ContDiffWithinAt 𝕜 n (Prod.map f g) (s ×ˢ t) p
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} {E' : Type u_3} [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 E'] (f : E ≃ₗᵢ[𝕜] E') (K : Submodule 𝕜 E) [CompleteSpace ↥K] (x : E') : ⇑(reflection (Submodule.map ↑(f.to_LinearEquiv) K)) x = ⇑f (⇑(reflection K) (⇑(f.symm) x))
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : HasInner.inner (x + y) (x + y) = HasInner.inner x x + HasInner.inner x y + HasInner.inner y x + HasInner.inner y y
{α : Type u_1} {β : Type u_2} [AddGroup α] [AddCommGroup β] {f : α → β} (hF : IsAddGroupHom f) : IsAddGroupHom (λ (a : α), -f a)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {t₁ t₂ : Affine.Triangle ℝ P} {i₁ i₂ i₃ j₁ j₂ j₃ : Fin 3} (hi₁₂ : i₁ ≠ i₂) (hi₁₃ : i₁ ≠ i₃) (hi₂₃ : i₂ ≠ i₃) (hj₁₂ : j₁ ≠ j₂) (hj₁₃ : j₁ ≠ j₃) (hj₂₃ : j₂ ≠ j₃) (h₁ : t₂.points j₁ = t₁.orthocenter) (h₂ : t₂.points j₂ = t₁.points i₂) (h₃ : t₂.points j₃ = t₁.points i₃) : Affine.Simplex.altitude t₂ j₂ = affine_Span ℝ {t₁.points i₁, t₁.points i₂}
{α : Type u_1} {G : Type u_4} [CompleteLattice α] [Group G] (f₁ f₂ : G →* α ≃o α) (g : G) : Function.Semiconj (λ (x : α), ⨆ (g' : G), ⇑(⇑f₁ g')⁻¹ (⇑(⇑f₂ g') x)) ⇑(⇑f₂ g) ⇑(⇑f₁ g)
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} {r' : Nnreal} (hF : HasFpowerSeriesOnBall f p x r) (h : ↑r' < r) : ∃ (a : ℝ) (H : a ∈ Set.Ioo 0 1) (C : ℝ) (H : C > 0), ∀ (y : E), y ∈ Metric.Ball 0 ↑r' → ∀ (n : ℕ), ∥f (x + y) - p.partial_Sum n y∥ ≤ C * a ^ n
(p : ℕ) [Fact (Nat.Prime p)] {a : ℤ} : zmod.legendre_Sym p a = -1 ↔ ¬IsSquare ↑a
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] {i : α → β} [TopologicalSpace γ] [t2_Space γ] {f : α → γ} (di : DenseInducing i) (hF : ∀ (b : β), ∃ (c : γ), Filter.Tendsto f (Filter.comap i (nhds b)) (nhds c)) (a : α) : di.extend f (i a) = f a
{R : Type u} [CommSemiring R] {ι : Type u_1} (s : Finset ι) (p : ι → Polynomial R) (x : R) : Polynomial.eval x (s.prod (λ (j : ι), p j)) = s.prod (λ (j : ι), Polynomial.eval x (p j))
{α : Type u} [PartialOrder α] [OrderBot α] {a : α} : IsMin a → a = ⊥
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {X : Top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget C)] {F G : Top.Sheaf C X} (f : F ⟶ G) : CategoryTheory.IsIso f ↔ ∀ (x : ↥X), CategoryTheory.IsIso ((Top.presheaf.stalk_Functor C x).map f)
{C : Type u₁} [CategoryTheory.Category C] {X₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₂₁ : X₂₁ ⟶ X₂₂} {h₃₁ : X₃₁ ⟶ X₃₂} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₂₁ : X₂₁ ⟶ X₃₁} {v₂₂ : X₂₂ ⟶ X₃₂} (s : CategoryTheory.IsPushout h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁) (p : h₂₁ ≫ v₂₂ = v₂₁ ≫ h₃₁) (t : CategoryTheory.IsPushout h₁₁ v₁₁ v₁₂ h₂₁) : CategoryTheory.IsPushout h₂₁ v₂₁ v₂₂ h₃₁
{α : Type u_2} {β : Type u_3} {rα : NonAssocSemiring α} {rβ : NonAssocSemiring β} (f : α →+* β) (a b : α) : ⇑f (a + b) = ⇑f a + ⇑f b
{n : Type u} [DecidableEq n] [Fintype n] {α : Type v} [CommRing α] (A : Matrix n n α) {β : Type u_1} (s : Finset β) (f : n → β → α) (i : n) : s.sum (λ (x : β), ⇑(A.cramer) (λ (j : n), f j x) i) = ⇑(A.cramer) (λ (j : n), s.sum (λ (x : β), f j x)) i
{α : Type u} (L : List α) {i j : ℕ} (hi : i < (List.take j L).length) : (List.take j L).nth_LE i hi = L.nth_LE i _
{α : Type u_1} [CircularPreorder α] {a b c : α} (h : HasBtw.Btw a b c) : ¬HasSbtw.Sbtw c b a
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) : ⇑(o.rotation (o.oangle x y)) x = y ↔ ∥x∥ = ∥y∥
{α : Type u_1} {E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E] {f : α → E} : Summable (λ (x : α), ∥f x∥) ↔ Summable f
{M : Type u} [Monoid M] {a : M} {x y : Mˣ} (h : SemiconjBy a ↑x ↑y) : SemiconjBy a ↑x⁻¹ ↑y⁻¹
{M : Type u_2} [AddCommGroup M] {A : Type u_5} [CommRing A] [Module A M] {N : Type u_1} [AddCommGroup N] [Module A N] (f : M →ₗ[A] M) (e : M ≃ₗ[A] N) : ⇑LinearMap.det (↑e.comp (f.comp ↑(e.symm))) = ⇑LinearMap.det f
{E : Type u_2} [SemiNormedGroup E] [StarAddMonoid E] [NormedStarGroup E] : Isometry HasStar.star
{ι : Type u_1} [Fintype ι] [DecidableEq ι] (t : Matrix.TransvectionStruct ι ℝ) : MeasureTheory.MeasurePreserving ⇑(⇑matrix.to_lin' t.to_Matrix) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [CompactSpace α] [MetricSpace β] : Continuous Coe_fn
{T : Type u₁} [CategoryTheory.Category T] {X : T} {f g : CategoryTheory.Over X} (k : f ⟶ g) [hk : CategoryTheory.Mono k.left] : CategoryTheory.Mono k
{α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α) (h : ∀ (a₁ : α), a₁ ≠ a₂ → ↥((⇑f a₁).is_Some)) : Function.Injective ⇑f
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r r' : Ennreal} (hF : HasFpowerSeriesOnBall f p x r) (hr : r' < r) : (λ (y : E × E), f y.fst - f y.snd - ⇑(p 1) (λ (_x : Fin 1), y.fst - y.snd)) =O[Filter.principal (Emetric.Ball (x, x) r')] λ (y : E × E), ∥y - (x, x)∥ * ∥y.fst - y.snd∥
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{R : Type u_1} [LinearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {v₁ v₂ : M} (h : v₁ ∈ MulAction.Orbit ↥(units.pos_Subgroup R) v₂) : SameRay R v₁ v₂
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasFiniteColimits C] : CategoryTheory.Limits.HasFiniteWidePushouts C
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [CommRing 𝕜] [AddCommGroup E] [AddCommGroup F] [Module 𝕜 E] [Module 𝕜 F] [TopologicalSpace E] [TopologicalSpace F] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] [TopologicalAddGroup F] [HasContinuousConstSmul 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (c : Composition n) (j : Fin n) (v : Fin n → E) (z : E) : p.apply_Composition c (Function.update v j z) = Function.update (p.apply_Composition c v) (c.index j) (⇑(p (c.blocks_fun (c.index j))) (Function.update (v ∘ ⇑(c.embedding (c.index j))) (c.inv_Embedding j) z))
{α : Type u} [TopologicalSpace α] {s : Set α} : (Closure s).nonempty → s.nonempty
{x y : Pgame} (h : x.lf y) (ox : x.numeric) (oy : y.numeric) : x ≤ y
{n : ℕ} (p : Fin n → Prop) [DecidablePred p] {i : Fin n} (hi : i ∈ fin.find p) : p i
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] [t1_Space β] {f : α → β} {a : α} {b : β} (h : Filter.Tendsto f (nhds a) (nhds b)) : f a = b
{R : Type u_1} [CommRing R] (M : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization M S] {ι : Type u_3} [Fintype ι] (f : ι → S) : ∃ (b : ↥M), ∀ (i : ι), IsLocalization.IsInteger R (↑b • f i)
{α : Type u} {l : List α} : l.nodup → l.sublists'.nodup
{K : Type u_1} {S : Type u_2} [Field K] [CommRing S] [Algebra K S] {R : Type u_3} [CommRing R] [Algebra R S] [Algebra R K] [IsScalarTower R K S] {B B' : PowerBasis K S} {P : Polynomial R} (h : ⇑(Polynomial.aeval B.gen) P = B'.gen) (hB : IsIntegral R B.gen) (hmin : minpoly K B.gen = Polynomial.map (Algebra_Map R K) (minpoly R B.gen)) (i : Fin B.dim) (j : Fin B'.dim) : IsIntegral R (B.basis.to_Matrix ⇑(B'.basis) i j)
{R : Type u} {S : Type v} [Semiring R] [Semiring S] (f : R →+* S) {r : R} : r ∈ f.ker ↔ ⇑f r = 0
{K : Type u} [Field K] (s : Subfield K) {ι : Type u_1} {t : Finset ι} {f : ι → K} (h : ∀ (c : ι), c ∈ t → f c ∈ s) : t.sum (λ (i : ι), f i) ∈ s
{X : Type u} [Preorder X] {x y : X} (h : x ⟶ y) : x ≤ y
{n : WithTop ℕ} {𝕂 : Type u_6} [is_R_or_C 𝕂] {E' : Type u_7} [NormedGroup E'] [NormedSpace 𝕂 E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {f : E' → F'} {x : E'} (hF : ContDiff 𝕂 n f) (hn : 1 ≤ n) : HasStrictFderivAt f (fderiv 𝕂 f x) x
{R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] [Semiring R₂] {σ₁₂ : R →+* R₂} [AddCommMonoid M₂] [Module R₂ M₂] (f : M →ₛₗ[σ₁₂] M₂) (s : Set M₂) : Submodule.span R (⇑f ⁻¹' s) ≤ Submodule.comap f (Submodule.span R₂ s)
{D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ} (hF : ContinuousOn f D) (hF' : DifferentiableOn ℝ f (Interior D)) (hF'' : DifferentiableOn ℝ (deriv f) (Interior D)) (hF''_nonneg : ∀ (x : ℝ), x ∈ Interior D → 0 ≤ deriv^[2] f x) : ConvexOn ℝ D f
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : ℝ} (h0 : 0 ≤ R) {f : ℂ → E} {c : ℂ} {s : Set ℂ} (hs : s.countable) (hc : ContinuousOn f (Metric.ClosedBall c R)) (hD : ∀ (z : ℂ), z ∈ Metric.Ball c R  s → DifferentiableAt ℂ f z) : ∮ (z : ℂ) in C(c, R), f z = 0
{α : Type u} [Ring α] : is_RingHom.id
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [LinearOrderedAddCommMonoid β] [HasScalar 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f g : E → β} (hF : StrictConvexOn 𝕜 s f) (hg : StrictConvexOn 𝕜 s g) : StrictConvexOn 𝕜 s (f ⊔ g)
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) : 1 ∈ S
{G₀ : Type u_2} [GroupWithZero G₀] (a : G₀) : a * a * a⁻¹ = a
{ι : Type w} {ι' : Type u_1} [Fintype ι'] [Fintype ι] (K : Type u) [Field K] [NumberField K] {b : Basis ι ℚ K} {b' : Basis ι' ℚ K} (h : ∀ (i : ι) (j : ι'), IsIntegral ℤ (b.to_Matrix ⇑b' i j)) (h' : ∀ (i : ι') (j : ι), IsIntegral ℤ (b'.to_Matrix ⇑b i j)) : Algebra.discr ℚ ⇑b = Algebra.discr ℚ ⇑b'
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (p q : FormalMultilinearSeries 𝕜 E F) : Linear_order.min p.radius q.radius ≤ (p + q).radius
{α : Type u_1} (r : Setoid α) : setoid.ker Quotient.mk = r
(c : CliffordAlgebra CliffordAlgebraComplex.q) : ⇑CliffordAlgebra_complex.to_Complex (⇑CliffordAlgebra.involute c) = ⇑(StarRing_end ℂ) (⇑CliffordAlgebra_complex.to_Complex c)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) : p.remove_zero.right_Inv i = p.right_Inv i
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : ℕ} {i j : Fin (n + 1)} (H : i ≤ j) : X.σ (⇑fin.cast_Succ i) ≫ X.σ j = X.σ j.succ ≫ X.σ i
{α : Type u} [OrderedSemiring α] {a b c d : α} [HasExistsAddOfLe α] (hab : a ≤ b) (hcd : c ≤ d) : a * d + b * c ≤ a * c + b * d
{D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ} (hF : ContinuousOn f D) (hF' : DifferentiableOn ℝ f (Interior D)) (h_anti : StrictAntiOn (deriv f) (Interior D)) : StrictConcaveOn ℝ D f
{n : Type u_5} {R : Type u_8} [TopologicalSpace R] [Fintype n] [DecidableEq n] [CommRing R] [TopologicalRing R] (A : Matrix n n R) (h : ContinuousAt Ring.inverse A.det) : ContinuousAt has_inv.inv A
{M : Type u_1} [has_Add M] (S : AddSubsemigroup M) {x y : M} : x ∈ S → y ∈ S → x + y ∈ S
{α : Type u_1} {β : Type u_2} [HasMul α] [Preorder α] [Preorder β] {f g : β → α} [CovariantClass α α has_mul.mul has_le.le] [CovariantClass α α (Function.swap has_mul.mul) has_le.le] (hF : Monotone f) (hg : Monotone g) : Monotone (λ (x : β), f x * g x)
{α : Type v} [CanonicallyOrderedAddMonoid α] [HasSub α] [HasOrderedSub α] [ContravariantClass α α has_add.add has_le.le] {f : ℕ → α} (h : Monotone f) (n : ℕ) : (Finset.range n).sum (λ (i : ℕ), f (i + 1) - f i) = f n - f 0
{R : Type u_1} [CommRing R] [is_IsDomain R] {a b c : R} (h2 : 2 ≠ 0) (ha : a ≠ 0) (h : ∀ (s : R), discrim a b c ≠ s * s) (x : R) : a * x * x + b * x + c ≠ 0
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : Set P} (ho : EuclideanGeometry.OrthocentricSystem s) {p : Fin 3 → P} (hps : Set.Range p ⊆ s) (hpi : Function.Injective p) : AffineIndependent ℝ p
{n : ℕ} {α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) (v : Vector α n) : (Vector.scanl f b v).to_List = List.scanl f b v.to_List
(α : Type u_1) [MetricSpace α] [CompleteSpace α] [TopologicalSpace.SecondCountableTopology α] [Nonempty α] : ∃ (f : (ℕ → ℕ) → α), Continuous f ∧ Function.Surjective f
{G₀ : Type u_2} [GroupWithZero G₀] {p : Π (g : G₀), g ≠ 0 → Prop} : (∃ (g : G₀) (hg : g ≠ 0), p g hg) ↔ ∃ (g : G₀ˣ), p ↑g _
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} (hx : x ≠ 0) (θ : Real.Angle) : x = ⇑(o.rotation θ) x ↔ θ = 0
(k : Type u_1) {P₁ : Type u_2} {V₁ : Type u_6} [Ring k] [AddCommGroup V₁] [Module k V₁] [AddTorsor V₁ P₁] {x y : P₁} (h : Function.Injective bit0) : ⇑(affine_equiv.point_reflection k x) y = y ↔ y = x
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e e' : LocalHomeomorph α β} (hE : e ≈ e') (s : Set α) : e.restr s ≈ e'.restr s
{α : sort u} {β : sort v} {γ : sort w} {g : β → γ} (hg : Function.bijective g) : Function.bijective (Function.comp g)
{α : Type u_1} [MeasurableSpace α] {ι : Type u_2} [Encodable ι] {f : ι → α → Ennreal} (h : ∀ (i : ι), Measurable (f i)) : Measurable (λ (x : α), ∑' (i : ι), f i x)
{R : Type u_1} [OrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] (u : Rˣ) (hu : ↑u < 0) (v : Module.Ray R M) : u • v = -v
{K : Type u_1} [LinearOrderedField K] [FloorRing K] {v : K} {q : ℚ} (v_Eq_q : v = ↑q) : {h := ↑((GeneralizedContinuedFraction.of q).h), s := seq.map (GeneralizedContinuedFraction.Pair.map Coe) (GeneralizedContinuedFraction.of q).s} = GeneralizedContinuedFraction.of v
{M : Type u_1} {α : Type u_6} [Monoid M] [MulAction M α] [HasMul α] (r s : M) (x y : α) [IsScalarTower M α α] [SmulCommClass M α α] : r • x * s • y = (r * s) • (x * y)
{R : Type u} [Semiring R] : AddSubmonoid.closure {p : Polynomial R | ∃ (n : ℕ) (a : R), p = ⇑(Polynomial.monomial n) a} = ⊤
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (r : R) (n : ℕ) : v.int_Valuation_def r ≤ ↑(⇑multiplicative.of_Add (-↑n)) ↔ v.as_Ideal ^ n ∣ Ideal.span {r}
{n : ℕ} {α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) {v : Vector α n} : (Vector.scanl f b v).val = List.scanl f b v.val
{J : Type u₁} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {J' : Type u₂} [CategoryTheory.Category J'] (e : J ≌ J') [CategoryTheory.Limits.HasLimitsOfShape J C] : CategoryTheory.Limits.HasLimitsOfShape J' C
{B : Type u} [CategoryTheory.Bicategory B] {a b : B} {f g h i : a ⟶ b} [CategoryTheory.Bicategory.LiftHom f] [CategoryTheory.Bicategory.LiftHom g] [CategoryTheory.Bicategory.LiftHom h] (η : f ⟶ g) (θ : g ⟶ h) (ι : h ⟶ i) [CategoryTheory.Bicategory.LiftHom₂ η] [CategoryTheory.Bicategory.LiftHom₂ θ] : η ≫ θ ≫ ι = (η ≫ θ) ≫ ι
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : LocalHomeomorph α β} {s : Set α} {t : Set β} : e.is_image s t → e.to_local_equiv.source ∩ ⇑e ⁻¹' t = e.to_local_equiv.source ∩ s
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x : E} {s : Set E} (h : x ∉ Closure s) : HasFderivWithinAt f f' s x
{M : Type u_1} [HasMul M] {r : M → M → Prop} {c : Con M} (h : ∀ (x y : M), r x y → Setoid.r x y) : ConGen r ≤ c
{C D : Type u} [CategoryTheory.Category C] [CategoryTheory.Category D] {A : Type w} [CategoryTheory.Category A] [CategoryTheory.Limits.HasLimits A] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {G : C ⥤ D} (hu : CategoryTheory.CoverLifting J K G) (ℱ : CategoryTheory.Sheaf J A) {X : A} {U : D} {S : CategoryTheory.Sieve U} (hS : S ∈ ⇑K U) {x : CategoryTheory.Presieve.FamilyOfElements ((CategoryTheory.ran G.op).obj ℱ.val ⋙ Category_theory.coyoneda.obj (Opposite.op X)) S.arrows} (hx : x.compatible) (y : ((CategoryTheory.ran G.op).obj ℱ.val ⋙ Category_theory.coyoneda.obj (Opposite.op X)).obj (Opposite.op U)) (hy : x.is_amalgamation y) : y = CategoryTheory.ran_is_sheaf_of_cover_lifting.glued_section hu ℱ hS hx
(b : ℤ) : b ≤ b ^ 2
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {a : α} {s : Set α} (ha : is_is_IsLub s a) (hs : s.nonempty) (sc : is_IsClosed s) : a ∈ s
{z : UpperHalfPlane} (hz : z ∈ ModularGroup.Fdo) (n : ℤ) : 1 < ⇑complex.norm_sq ↑(ModularGroup.t ^ n • z)
{α : Type u_1} [NormedRing α] [CompleteSpace α] {f g : ℕ → α} (hF : Summable (λ (x : ℕ), ∥f x∥)) (hg : Summable (λ (x : ℕ), ∥g x∥)) : (∑' (n : ℕ), f n) * ∑' (n : ℕ), g n = ∑' (n : ℕ), (Finset.Nat.antidiagonal n).sum (λ (kl : ℕ × ℕ), f kl.fst * g kl.snd)
{M : Type u_1} {R : Type u_2} [Monoid M] [NonUnitalNonAssocRing R] [DistribMulAction M R] (k : M) (h : ∀ (x : R), k • x = 0 → x = 0) {a b : R} (h' : k • a = k • b) : a = b
{g : Equiv.perm (Fin 5)} (h : 3 ∈ g.cycle_Type) : (g * g).is_three_Cycle
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.CoproductsDisjoint C] : CategoryTheory.Limits.InitialMonoClass C
{S : Type u_2} [CommRing S] (A : Type u_6) [CommRing A] [is_IsDomain A] [Algebra A S] {M : Submonoid A} [IsLocalization M S] (hM : M ≤ NonZeroDivisors A) : is_IsDomain S
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {b₂ : Basis (Fin 2) ℝ V} (hb₂ : Orthonormal ℝ ⇑b₂) (ho : b.orientation = -b₂.orientation) : ∃ (θ : Real.Angle), b₂ = b.map (hb.conj_lie.trans (hb.rotation θ)).to_LinearEquiv
(n : ℕ) {R : Type u_1} [LinearOrderedCommRing R] {x : R} (hx : 1 < x) : 0 < Polynomial.eval x (Polynomial.cyclotomic n R)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {f g : ℝ → E} {x : ℝ} (f_Diff : ∀ (y : ℝ), y ≠ x → HasDerivAt f (g y) y) (hF : ContinuousAt f x) (hg : ContinuousAt g x) (y : ℝ) : HasDerivAt f (g y) y
{α : Type u_1} [LinearOrder α] {A B : Finset α} (t : α) (h₁ : A.to_colex < B.to_colex) (h₂ : ∀ (x : α), x ∈ B → x < t) (x : α) (H : x ∈ A) : x < t
{R : Type u} [Ring R] {S : Type v} [Ring S] (f : R →+* S) (p : Polynomial S) : p ∈ Polynomial.lifts f ↔ p ∈ Polynomial.lifts_Ring f
{α : Type u_1} [CanonicallyOrderedAddMonoid α] [HasSub α] [HasOrderedSub α] {a b c : α} [ContravariantClass α α has_add.add has_le.le] (h : a + c < b) : a < b - c
{β : Type u} {α : Type v} {γ : Type w} {s : Finset α} [CommMonoid β] [DecidableEq γ] (f : γ → β) (g : α → γ) : s.prod (λ (a : α), f (g a)) = (Finset.image g s).prod (λ (b : γ), f b ^ (Finset.filter (λ (a : α), g a = b) s).card)
{K : Type u} [Field K] {s : Set K} {t : Subfield K} : Subfield.closure s ≤ t ↔ s ⊆ ↑t
{α : Type u} {β : Type v} [LinearOrderedField α] [TopologicalSpace α] [OrderTopology α] {l : Filter β} {f g : β → α} {C : α} (hC : 0 < C) (hF : Filter.Tendsto f l filter.at_IsBot) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (λ (x : β), f x * g x) l filter.at_IsBot
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (s : Affine.Simplex ℝ P 1) : s.circumcenter = Finset.centroid ℝ Finset.univ s.points
{β : Type u_2} {f g : β → ℝ} (hg : ∀ (b : β), 0 ≤ g b) (hgf : ∀ (b : β), g b ≤ f b) (hF : Summable f) : Summable g
{α : Type u} [MetricSpace α] [ProperSpace α] {s : Set α} (hs : is_IsClosed s) {R : α → ℝ} (hR : ∀ (x : α), x ∈ s → 0 < R x) : ∃ (ι : Type u) (c : ι → α) (r r' : ι → ℝ), (∀ (i : ι), c i ∈ s ∧ 0 < r i ∧ r i < r' i ∧ r' i < R (c i)) ∧ LocallyFinite (λ (i : ι), Metric.Ball (c i) (r' i)) ∧ s ⊆ ⋃ (i : ι), Metric.Ball (c i) (r i)
{M : Type u_1} [Monoid M] {s t : Set M} (h : s ⊆ t) : monoid.closure s ⊆ monoid.closure t
{k : Type u_1} {E : Type u_2} [LinearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k → E} {a b r : k} (hab : a < b) (h₀ : 0 < r) (h₁ : r < 1) : ⇑(affine_map.line_Map (f a) (f b)) r < f (⇑(affine_map.line_Map a b) r) ↔ slope f (⇑(affine_map.line_Map a b) r) b < slope f a (⇑(affine_map.line_Map a b) r)
{𝕜 : Type u_1} {E : Type u_2} [NormedField 𝕜] [HasNorm E] {a : 𝕜} {f : 𝕜 → E} (h : Filter.IsBoundedUnder has_le.le (nhds_within a {a}ᶜ) (HasNorm.norm ∘ f)) : f =o[nhds_within a {a}ᶜ] λ (x : 𝕜), (x - a)⁻¹
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasCokernels C] : CategoryTheory.Limits.HasCoequalizers C
{M : Type u_3} {N : Type u_4} [AddZeroClass M] [AddZeroClass N] (f : M →+ N) (a b : M) : ⇑f (a + b) = ⇑f a + ⇑f b
{J : Type v} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (f : J → C) [CategoryTheory.Limits.HasBiproduct f] {b : CategoryTheory.Limits.Bicone f} (hb : b.is_bilimit) : (hb.is_limit.cone_point_Unique_Up_to_iso (Category_theory.limits.biproduct.is_Limit f)).inv = CategoryTheory.Limits.biproduct.desc b.ι
{R : Type u_2} [CommRing R] [is_IsDomain R] [DecidableEq R] [Fintype R] {p : Polynomial R} (hp : 0 < p.degree) : Fintype.card R ≤ p.nat_degree * (Finset.image (λ (x : R), Polynomial.eval x p) Finset.univ).card
{K : Type u_1} [LinearOrderedField K] {a b c : K} (ha : a ≠ 0) (h : ∀ (x : K), 0 < a * x * x + b * x + c) : discrim a b c < 0
{α : Type u} {ι : Type u_1} {s : Set ι} (hs : s.finite) {t : Π (i : ι), i ∈ s → Set α} (ht : ∀ (i : ι) (H : i ∈ s), (t i H).finite) : (⋃ (i : ι) (H : i ∈ s), t i H).finite
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type w} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace 𝕜] [FiniteDimensional 𝕜 E] [FiniteDimensional 𝕜 F] (Cond : FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 F) : Nonempty (E ≃L[𝕜] F)
{α : Type u} {β : Type v} [MulOneClass α] [MulOneClass β] {f : α → β} (hF : IsMonoidHom f) (x y : α) : f (x * y) = f x * f y
{p a b : ℕ} (hpb : p ∈ b.factors) (ha : a ≠ 0) : p ∈ (a * b).factors
{α : Type u_1} [HasLe α] {a : αᵒᵈ} : IsMax a → IsMin (⇑order_dual.of_dual a)
{J : Type u} [CategoryTheory.Category J] [CategoryTheory.IsCofiltered J] (F : J ⥤ Type v) [Π (j : J), Fintype (F.obj j)] [∀ (j : J), Nonempty (F.obj j)] : F.sections.nonempty
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} [DecidableEq β'] [DecidableEq γ] [DecidableEq δ] {f : α → β → γ} {s : Finset α} {t : Finset β} {g : γ → δ} {f' : β' → α → δ} {g' : β → β'} (h_antidistrib : ∀ (a : α) (b : β), g (f a b) = f' (g' b) a) : Finset.image g (Finset.image₂ f s t) = Finset.image₂ f' (Finset.image g' t) s
{α : Type u_2} {β : Type u_3} {rα : NonAssocSemiring α} {rβ : NonAssocSemiring β} (f : α →+* β) [Nontrivial β] : ⇑f 1 ≠ 0
{R : Type u_1} {G : Type u_2} [AddCommGroup G] [CommRing R] [Nontrivial R] : Algebra.FiniteType R (AddMonoidAlgebra R G) ↔ Add_group.fg G
{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] {s : Set E} (hs : Convex 𝕜 s) {x y : E} (hx : x ∈ s) (hy : x + y ∈ Interior s) {t : 𝕜} (ht : t ∈ Set.Ioc 0 1) : x + t • y ∈ Interior s
(x : ℂ) : HasDerivAt Complex.sinh (Complex.cosh x) x
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : AffineSubspace k P} (h : ↑s.nonempty) : affine_subspace.direction_of_Nonempty h = s.direction
{ι : Type u_1} {α : ι → Type u_2} [DecidableEq ι] [Π (i : ι), HasZero (α i)] {s : Finset ι} {f : Π₀ (i : ι), α i} [Π (i : ι), DecidableEq (α i)] {t : Π₀ (i : ι), Finset (α i)} (ht : t.support ⊆ s) : f ∈ s.dfinsupp ⇑t ↔ ∀ (i : ι), ⇑f i ∈ ⇑t i
(p : ℕ) [hp : Fact (Nat.Prime p)] (q r : ℚ) : padic_norm p (q * r) = padic_norm p q * padic_norm p r
{α : Type u_1} [Fintype α] : Nonempty (Field α) ↔ IsPrimePow (Fintype.card α)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace E] {v : E} (hv : v ∈ K) : ⇑(reflection Kᗮ) v = -v
{γ : Type w} [Preorder γ] [OrderTop γ] (s : Set γ) : BddAbove s
{α : Type u} [PseudoEmetricSpace α] {s t : Set α} : emetric.Hausdorff_edist s t = emetric.Hausdorff_edist t s
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] (v w : E) (H : w ∈ K) : HasInner.inner (v - ↑(⇑(Orthogonal_projection K) v)) w = 0
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} [TopologicalSpace α] [TopologicalSpace β] {i : α → β} [TopologicalSpace δ] {f : γ → α} {g : γ → δ} {h : δ → β} {d : δ} {a : α} (di : DenseInducing i) (H : Filter.Tendsto h (nhds d) (nhds (i a))) (comm : h ∘ g = i ∘ f) : Filter.Tendsto f (Filter.comap g (nhds d)) (nhds a)
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {a b : α} [IsAntisymm α HasSubset.Subset] (h₁ : a ⊆ b) (h₂ : a ≠ b) : a ⊂ b
{ι : Type u_1} {X : Type u_2} [TopologicalSpace X] [NormalSpace X] {u : ι → Set X} {s : Set X} {c : Set (ShrinkingLemma.PartialRefinement u s)} (hc : IsChain has_le.le c) (NE : c.nonempty) (hfin : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite) (hU : s ⊆ ⋃ (i : ι), u i) {v : ShrinkingLemma.PartialRefinement u s} (hv : v ∈ c) : v ≤ shrinking_lemma.partial_refinement.chain_Sup c hc NE hfin hU
{n : Type u_3} [Fintype n] {A : Type u_1} [DecidableEq n] [CommRing A] [is_IsDomain A] {M : Matrix n n A} : M.det ≠ 0 → M.nondegenerate
{a : ℝ} {l : Filter ℝ} {f g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in nhds_within a (Set.Iio a), DifferentiableAt ℝ f x) (hg' : ∀ᶠ (x : ℝ) in nhds_within a (Set.Iio a), deriv g x ≠ 0) (hfa : Filter.Tendsto f (nhds_within a (Set.Iio a)) (nhds 0)) (hga : Filter.Tendsto g (nhds_within a (Set.Iio a)) (nhds 0)) (hDiv : Filter.Tendsto (λ (x : ℝ), deriv f x / deriv g x) (nhds_within a (Set.Iio a)) l) : Filter.Tendsto (λ (x : ℝ), f x / g x) (nhds_within a (Set.Iio a)) l
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] {x y : X} {γ : Y → Path x y} {f : Y → ℝ} (hγ : Continuous ↿γ) (hF : Continuous f) : Continuous (λ (t : Y), (γ t).extend (f t))
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b
{𝕜 : Type u_1} [is_R_or_C 𝕜] [dec𝕜 : DecidableEq 𝕜] {E : Type u_2} [InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : InnerProductSpace.IsSelfAdjoint T) [FiniteDimensional 𝕜 E] {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n) : ⇑(hT.diagonalization_Basis hn) (⇑T v) i = ↑(hT.eigenvalues hn i) * ⇑(hT.diagonalization_Basis hn) v i
{α : Type u_1} {r : α → α → Prop} {s t : Set α} (ht : IsAntichain r t) (h : Maximals r s ⊆ t) (hs : ∀ ⦃a : α⦄, a ∈ t → (∃ (b : α) (H : b ∈ Maximals r s), r b a)) : Maximals r s = t
{α : Type u} [PseudoMetricSpace α] {s t : Set α} (hs : is_IsClosed s) (ht : is_IsClosed t) (Fin : emetric.Hausdorff_edist s t ≠ ⊤) : metric.Hausdorff_dist s t = 0 ↔ s = t
{n : ℕ} {α : Fin (n + 1) → Type u} (q : Π (i : Fin (n + 1)), α i) (z : α (fin.last n)) : fin.init (Function.update q (fin.last n) z) = fin.init q
{α : Type u} [t : TopologicalSpace α] {b : Set (Set α)} (hb : TopologicalSpace.IsTopologicalBasis b) {s : Set α} : Dense s ↔ ∀ (o : Set α), o ∈ b → o.nonempty → (o ∩ s).nonempty
{G : Type u_1} [Group G] {H K : Subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) : H = K
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] {E1 E2 : IntermediateField K L} (h12 : E1 ≤ E2) : E2.fixing_Subgroup ≤ E1.fixing_Subgroup
{α : Type u} [Preorder α] {a b : α} (h : a < b) : a ≠ b
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (s : AffineSubspace ℝ P) [Nonempty ↥s] [CompleteSpace ↥(s.direction)] (p : P) : p -ᵥ ↑(⇑(euclidean_geometry.orthogonal_projection s) p) ∈ (s.direction)ᗮ
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x (-y) + hb.oangle y (-z) + hb.oangle z (-x) = ↑Real.pi
(R : Type u_1) (S : Type u_2) [Ring R] [Ring S] [is_IsDomain (R × S)] [Nontrivial R] [Nontrivial S] : False
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X ⟶ Y} {c : CategoryTheory.Limits.Cofork f g} (i : CategoryTheory.Limits.IsColimit c) : CategoryTheory.Epi c.π
{ι : Type u_1} {ι' : Type u_2} {R : Type u_5} {M : Type u_6} [CommSemiring R] [AddCommMonoid M] [Module R M] (b : Basis ι R M) (b' : Basis ι' R M) [Fintype ι'] [Fintype ι] [DecidableEq ι] : ⇑(Linear_map.to_Matrix b b') LinearMap.id = b'.to_Matrix ⇑b
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMaxOrder α] [DenselyOrdered α] {a : α} {s : Set α} : s ∈ nhds_within a (Set.Ici a) ↔ ∃ (u : α) (H : u ∈ Set.Ioi a), Set.Icc a u ⊆ s
{G : Type u_1} {M : Type u_3} [Group G] [Monoid M] [MulAction G M] [SmulCommClass G M M] [IsScalarTower G M M] (g : G) (m : Mˣ) : (g • m)⁻¹ = g⁻¹ • m⁻¹
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (E : IntermediateField K L) : E.map (AlgHom.id K L) = E
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {f : M →+ P} : (AddCon.ker_Lift f).mrange = f.mrange
{ι : Type u} (f : ι → Cardinal) : BddAbove (Set.Range f)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) : hb.oangle x y = θ ↔ y = (∥y∥ / ∥x∥) • ⇑(hb.rotation θ) x
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) : o.oangle x x = 0
{K : Type u} {V : Type v} {V' : Type v'} [DivisionRing K] [AddCommGroup V] [Module K V] [AddCommGroup V'] [Module K V'] : Nonempty (V ≃ₗ[K] V') ↔ (Module.rank K V).lift = (Module.rank K V').lift
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMaxOrder α] [NoMinOrder α] {a : α} {s : Set α} : s ∈ nhds a ↔ ∃ (l u : α), a ∈ Set.Ioo l u ∧ Set.Ioo l u ⊆ s
{ι : Type u_1} {Mᵢ : ι → Type u_7} [Π (i : ι), AddCommGroup (Mᵢ i)] [Fintype ι] {R : Type u_2} [OrderedRing R] [Π (i : ι), Module R (Mᵢ i)] {Q : Π (i : ι), QuadraticForm R (Mᵢ i)} (h : (QuadraticForm.pi Q).anisotropic) (i : ι) : (Q i).anisotropic
{S : Type u} [has_Add S] {a x y : S} (h : AddSemiconjBy a x y) : a + x = y + a
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C} (f : X ⟶ Y) [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasCokernel f] [CategoryTheory.Epi f] : CategoryTheory.Limits.cokernelπ f = 0
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x z - hb.oangle x y = hb.oangle y z
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {G : ι → Type u_5} [Π (i : ι), InnerProductSpace 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 V) [CompleteSpace E] (f : Π (i : ι), G i) : Summable (λ (i : ι), ⇑(V i) (f i)) ↔ Summable (λ (i : ι), ∥f i∥ ^ 2)
{a : ℕ} : Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {s1 s2 : AffineSubspace k P} (h : s1 < s2) (hn : ↑s1.nonempty) : s1.direction < s2.direction
{n : ℕ} {E : Type u_1} [NormedGroup E] {f : (Fin n → ℂ) → E} {c : Fin n → ℂ} {R : Fin n → ℝ} [NormedSpace ℂ E] (hF : TorusIntegrable f c R) : MeasureTheory.IntegrableOn (λ (θ : Fin n → ℝ), finset.univ.prod (λ (i : Fin n), ↑(R i) * Complex.exp (↑(θ i) * Complex.i) * Complex.i) • f (torus_Map c R θ)) (Set.Icc 0 (λ (_x : Fin n), 2 * Real.pi)) MeasureTheory.MeasureSpace.volume
{K : Type u_4} {V : Type u} [Field K] [AddCommGroup V] [Module K V] (p : Submodule K V) (hp : p < ⊤) : ∃ (f : V →ₗ[K] K) (H : f ≠ 0), p ≤ f.ker
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {s : Set E} {f : E → F} {n : WithTop ℕ} {x : G} (g : G →L[𝕜] E) (hF : ContDiffWithinAt 𝕜 n f s (⇑g x)) : ContDiffWithinAt 𝕜 n (f ∘ ⇑g) (⇑g ⁻¹' s) x
{R : Type u_1} [Semiring R] (P : Polynomial R → Prop) (N : ℕ) (P_0 : P 0) (P_C_Mul_Pow : ∀ (n : ℕ) (r : R), r ≠ 0 → n ≤ N → P (⇑Polynomial.c r * Polynomial.x ^ n)) (P_C_Add : ∀ (f g : Polynomial R), f.nat_degree < g.nat_degree → g.nat_degree ≤ N → P f → P g → P (f + g)) (f : Polynomial R) : f.nat_degree ≤ N → P f
{α : Type u_1} {r s : Setoid α} : (r ⊓ s).rel = r.rel ⊓ s.rel
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder β] [SuccOrder β] [IsSuccArchimedean β] [Nonempty β] {s : β → Set α} (H : ∀ (n : β), IsConnected (s n)) (K : ∀ (n : β), (s n ∩ s (Order.succ n)).nonempty) : IsConnected (⋃ (n : β), s n)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x y : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall f p x r) (h : ↑∥y∥₊ < r) : HasFpowerSeriesOnBall f (p.change_origin y) (x + y) (r - ↑∥y∥₊)
{α : Type u} {u : Ultrafilter (Ultrafilter α)} {x : Ultrafilter α} : ↑u ≤ nhds x ↔ x = mjoin u
{Γ : Type u_4} [Group Γ] {T : Type u_5} [TopologicalSpace T] [MulAction Γ T] [HasContinuousConstSmul Γ T] : is_is_IsOpenMap Quotient.mk
{n : ℕ} {α : Fin (n + 1) → Type u} (q : Π (i : Fin (n + 1)), α i) (i : Fin n) (y : α (⇑fin.cast_Succ i)) : fin.init (Function.update q (⇑fin.cast_Succ i) y) = Function.update (fin.init q) i y
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y : M} (h : SameRay R x y) (hx : x ≠ 0) (hy : y ≠ 0) : ∃ (r₁ r₂ : R), 0 < r₁ ∧ 0 < r₂ ∧ r₁ • x = r₂ • y
{α : Type u_1} [TopologicalSpace α] [t2_Space α] [MeasurableSpace α] [BorelSpace α] {s t : Set α} (hs : MeasureTheory.AnalyticSet s) (ht : MeasureTheory.AnalyticSet t) (h : Disjoint s t) : MeasureTheory.MeasurablySeparable s t
{p : ℕ} {R : Type u_1} {S : Type u_2} [hp : Fact (Nat.Prime p)] [CommRing R] [CommRing S] (f : R →+* S) (x : WittVector p R) : ⇑(WittVector.map f) (⇑WittVector.verschiebung x) = ⇑WittVector.verschiebung (⇑(WittVector.map f) x)
{x y z : ℤ} (k : ℤ) (hk : k ≠ 0) : PythagoreanTriple (k * x) (k * y) (k * z) ↔ PythagoreanTriple x y z
{α : Type u_2} {ι : Type u_5} [CommMonoid α] (t : Finset ι) (f : ι → Set α) (g : ι → α) (hg : ∀ (i : ι), i ∈ t → g i ∈ f i) : t.prod (λ (i : ι), g i) ∈ t.prod (λ (i : ι), f i)
{α : Type u} {β : Type v} [Preorder α] [LinearOrder β] {f g : α → β} (hF : Monotone f) (hg : Monotone g) : Monotone (λ (x : α), Linear_order.min (f x) (g x))
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K₁ K₂ : Submodule 𝕜 E} [FiniteDimensional 𝕜 ↥K₂] (h : K₁ ≤ K₂) {n : ℕ} (h_dim : FiniteDimensional.finrank 𝕜 ↥K₁ + n = FiniteDimensional.finrank 𝕜 ↥K₂) : FiniteDimensional.finrank 𝕜 ↥(K₁ᗮ ⊓ K₂) = n
{R : Type u} [Ring R] {P : Type (max u v)} [AddCommGroup P] [Module R P] (huniv : ∀ {M : Type (max v u)} {N : Type (max u v)} [_inst_4 : AddCommGroup M] [_inst_5 : AddCommGroup N] [_inst_6 : Module R M] [_inst_7 : Module R N] (f : M →ₗ[R] N) (g : P →ₗ[R] N), Function.Surjective ⇑f → (∃ (h : P →ₗ[R] M), f.comp h = g)) : Module.Projective R P
{α : Type u} {β : Type v} [TopologicalSpace α] [SemiNormedGroup β] (b : β) : ∥BoundedContinuousFunction.const α b∥ ≤ ∥b∥
{n a : ℕ} (h : a < n + 1) : ↑a.val = a
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [LinearOrderedField 𝕜] [AddCommGroup E] [OrderedAddCommGroup β] [Module 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f : E → β} {t : Finset ι} {w : ι → 𝕜} {p : ι → E} (hF : ConcaveOn 𝕜 s f) (h₀ : ∀ (i : ι), i ∈ t → 0 ≤ w i) (h₁ : t.sum (λ (i : ι), w i) = 1) (hmem : ∀ (i : ι), i ∈ t → p i ∈ s) : t.sum (λ (i : ι), w i • f (p i)) ≤ f (t.sum (λ (i : ι), w i • p i))
{α : Type u} [PseudoEmetricSpace α] {s t : Set α} (hs : s.nonempty) (ht : t.nonempty) : emetric.Hausdorff_edist s t ≤ Emetric.diam (s ∪ t)
(V : Type u_1) [SemiNormedGroup V] (h : ∃ (x : V), ∥x∥ ≠ 0) : ∥NormedGroupHom.id V∥ = 1
{α : Type u} [PseudoEmetricSpace α] {x : α} {s t : Set α} (h : x ∈ s) : emetric.inf_edist x t ≤ emetric.Hausdorff_edist s t
{C : Type u₁} [CategoryTheory.Category C] {J : Type u₂} [CategoryTheory.Category J] (F : J ⥤ Cᵒᵖ) [CategoryTheory.Limits.HasColimit F.left_Op] : CategoryTheory.Limits.HasLimit F
{b m : ℕ} (hb : 2 ≤ b) : m < b ^ (b.digits m).length
 : Cardinal.ord ∘ Cardinal.aleph = ordinal.enum_Ord {b : Ordinal | b.card.ord = b ∧ Ordinal.omega ≤ b}
{R : Type u} [Ring R] {p : Polynomial R} (r : R) : Polynomial.eval r (p * (Polynomial.x - ⇑Polynomial.c r)) = 0
{α : Type u} [SemilatticeSup α] [OrderBot α] {ι : Type u} [Fintype ι] (f : ι → α) : (∐ f) = (Fintype.elems ι).sup f
{M : Type u_1} [has_Add M] (s : Set M) {p : Π (x : M), x ∈ AddSubsemigroup.closure s → Prop} (Hs : ∀ (x : M) (h : x ∈ s), p x _) (hMul : ∀ (x : M) (hx : x ∈ AddSubsemigroup.closure s) (y : M) (hy : y ∈ AddSubsemigroup.closure s), p x hx → p y hy → p (x + y) _) {x : M} (hx : x ∈ AddSubsemigroup.closure s) : p x hx
{R : Type u_1} [LinearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [FiniteDimensional R M] [Nonempty ι] (x : Orientation R M ι) (h : Fintype.card ι = FiniteDimensional.finrank R M) : (x.some_Basis h).orientation = x
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_5} [NormedGroup E'] [NormedSpace 𝕜 E'] {n : WithTop ℕ} {f : E → E'} {s : Set E} {x : E} : ContMdiffWithinAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f s x → ContDiffWithinAt 𝕜 n f s x
{α : Type u} {β : Type v} {f : α ≃. β} (h : ∀ (a : α), ↥((⇑f a).is_Some)) : Function.Injective ⇑f
(x : ℝ) : Real.sinh x = (Real.exp x - Real.exp (-x)) / 2
{R : Type u_1} [CommSemiring R] (s : Subsemiring R) {ι : Type u_2} {t : Finset ι} {f : ι → R} (h : ∀ (c : ι), c ∈ t → f c ∈ s) : t.prod (λ (i : ι), f i) ∈ s
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [OrderedRing 𝕜] [AddCommGroup E] [AddCommGroup F] [Module 𝕜 E] [Module 𝕜 F] (f : E →ᵃ[𝕜] F) {s : Set F} (hs : Convex 𝕜 s) : Convex 𝕜 (⇑f ⁻¹' s)
{α : Type u_1} {M : Type u_5} {N : Type u_7} [HasZero M] [CommMonoid N] {s : Finset α} {f : α → M} {g : α → M → N} (hF : ∀ (a : α), f a ≠ 0 → a ∈ s) (hg : ∀ (a : α), g a 0 = 1) : (finsupp.on_Finset s f hF).prod g = s.prod (λ (a : α), g a (f a))
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasFiniteCoproducts C] : CategoryTheory.Limits.HasFiniteBiproducts C
{α' : sort w} [DecidableEq α'] {α : sort u_1} {β : sort u_2} (g : α' → β) {f : α → α'} {i : α'} (a : β) (h : ∀ (x : α), f x ≠ i) : Function.update g i a ∘ f = g ∘ f
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {p : E × F} : ContDiffAt 𝕜 n Prod.fst p
{R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [Π (i : ι), Module R (M₁ i)] [Module R M₂] (f : MultilinearMap R M₁ M₂) {α : ι → Type u_1} (g : Π (i : ι), α i → M₁ i) [Fintype ι] [Π (i : ι), Fintype (α i)] : ⇑f (λ (i : ι), finset.univ.sum (λ (j : α i), g i j)) = finset.univ.sum (λ (r : Π (i : ι), α i), ⇑f (λ (i : ι), g i (r i)))
{α : sort u_1} {β : sort u_2} {s₁ : Setoid α} {s₂ : Setoid β} {p : Quotient s₁ → Quotient s₂ → Prop} (h : ∀ (a₁ : α) (a₂ : β), p (Quotient.mk' a₁) (Quotient.mk' a₂)) (q₁ : Quotient s₁) (q₂ : Quotient s₂) : p q₁ q₂
{α : Type u_1} (f : α → Nnreal) : Filter.Tendsto (λ (s : Finset α), ∑' (b : {x // x ∉ s}), f ↑b) filter.at_Top (nhds 0)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {f : α → β} {x : α} {s : Set α} : ContinuousWithinAt f s x → ContinuousWithinAt f (HasInsert.insert x s) x
(a : ↥Circle) : ⇑LinearEquiv.det (⇑rotation a).to_LinearEquiv = 1
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommGroup E] [HasScalar 𝕜 E] {S : ConvexCone 𝕜 E} (hS : S.flat) : S.pointed
(K : Type u_1) (L : Type u_2) {A : Type u_5} [Field K] [Field L] [CommRing A] [Algebra K L] [Algebra L A] [Algebra K A] [IsScalarTower K L A] (A_alg : Algebra.IsAlgebraic K A) : Algebra.IsAlgebraic L A
{α : Type u_1} [TopologicalSpace α] [PolishSpace α] {s : Set α} (hs : is_IsClosed s) : PolishSpace ↥s
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q) : Function.Surjective ⇑f → CategoryTheory.Epi f
{n : ℕ} (a : Zmod n) : ↑↑a = a
{E : ℕ → Type u_1} {α : Type u_2} [PseudoMetricSpace α] {f : (Π (n : ℕ), E n) → α} : (∀ (x y : Π (n : ℕ), E n), HasDist.dist (f x) (f y) ≤ HasDist.dist x y) ↔ ∀ (x y : Π (n : ℕ), E n) (n : ℕ), y ∈ PiNat.Cylinder x n → HasDist.dist (f x) (f y) ≤ (1 / 2) ^ n
{ι : Type u_1} {E : Type u_3} [SemiNormedGroup E] {f : ι → E} {g : ι → Nnreal} {a : Nnreal} (hg : HasSum g a) (h : ∀ (i : ι), ∥f i∥₊ ≤ g i) : ∥∑' (i : ι), f i∥₊ ≤ a
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) (h : HasInner.inner x y = 0) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
{α : Type u_1} [LinearOrderedField α] {a b c d : α} (hc : c ≠ 0) (hD : d ≠ 0) : a / c < b / d → (a * d - b * c) / (c * d) < 0
{E : Type u_2} [AddCommGroup E] [Module ℝ E] (f : LinearPmap ℝ E ℝ) (N : E → ℝ) (N_hom : ∀ (c : ℝ), 0 < c → ∀ (x : E), N (c • x) = c * N x) (N_Add : ∀ (x y : E), N (x + y) ≤ N x + N y) (hF : ∀ (x : ↥(f.domain)), ⇑f x ≤ N ↑x) : ∃ (g : E →ₗ[ℝ] ℝ), (∀ (x : ↥(f.domain)), ⇑g ↑x = ⇑f x) ∧ ∀ (x : E), ⇑g x ≤ N x
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall f p x r) : TendstoLocallyUniformlyOn (λ (n : ℕ) (y : E), p.partial_Sum n (y - x)) f filter.at_Top (Emetric.Ball x r)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} {Fₗ : Type u_7} [NormedGroup E] [NormedGroup F] [NormedGroup Fₗ] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] [NormedSpace 𝕜 Fₗ] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →sl[σ₁₂] F) [CompleteSpace F] (e : E →L[𝕜] Fₗ) (h_Dense : DenseRange ⇑e) {N : Nnreal} (h_e : ∀ (x : E), ∥x∥ ≤ ↑N * ∥⇑e x∥) [RingHomIsometric σ₁₂] : ∥f.extend e h_Dense _∥ ≤ ↑N * ∥f∥
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a : ℝ} {s : Set ℝ} (hintg : ∀ (x : ℝ), x ∈ s → IntervalIntegrable f MeasureTheory.MeasureSpace.volume a x) (hcont : Continuous f) : DifferentiableOn ℝ (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) s
{R : Type u_1} {a : R} [MulZeroClass R] [Nontrivial R] (la : IsRegular a) : a ≠ 0
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] {K : Type u_2} [Field K] [Algebra R K] [IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R) (r : R) : ⇑(v.valuation) (⇑(Algebra_Map R K) r) = ⇑(v.int_Valuation) r
{α : Type u} {β : Type v} [TopologicalSpace α] [SemiNormedGroup β] {f : BoundedContinuousFunction α β} {C : ℝ} (C0 : 0 ≤ C) : ∥f∥ ≤ C ↔ ∀ (x : α), ∥⇑f x∥ ≤ C
{M : Type u_1} [CommMonoid M] {s t : Set M} {x : M} : x ∈ monoid.closure (s ∪ t) ↔ ∃ (y : M) (H : y ∈ monoid.closure s) (z : M) (H : z ∈ monoid.closure t), y * z = x
{α : Type u} [NormedField α] {u : ℕ → α} : IsCauSeq HasNorm.norm u ↔ CauchySeq u
{m : Type u_1} {R : Type u_3} [Fintype m] [DecidableEq m] [CommSemiring R] (A : Matrix m m R) : ⇑((MvPolynomial.eval (λ (p : m × m), A p.fst p.snd)).map_Matrix) (matrix.mv_Polynomial.x m m R) = A
(R : Type u) [Ring R] (hF : IsField R) (x : R) : x ≠ 0 → (∃! (y : R), x * y = 1)
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {F : J ⥤ C} {t : CategoryTheory.Limits.Cone F} (h : CategoryTheory.Limits.IsLimit t) (s : CategoryTheory.Limits.Cone F) : ∃! (l : s.X ⟶ t.X), ∀ (j : J), l ≫ t.π.app j = s.π.app j
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (s : Set (Submodule 𝕜 E)) : (⨅ (K : Submodule 𝕜 E) (H : K ∈ s), Kᗮ) = (HasSup.sup s)ᗮ
{G : Type w} [TopologicalSpace G] [HasNeg G] [has_Add G] [HasContinuousAdd G] [HasContinuousNeg G] (h : G) : Continuous (λ (g : G), g + h + -g)
{R₁ : Type u_1} {R₂ : Type u_2} [Semiring R₁] [Semiring R₂] (e : R₁ ≃+* R₂) : RingHomInvPair ↑e ↑(e.symm)
{α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β] {f : β → α} (hF : ∀ (x y : β), f x = f y) : Measurable f
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {b₂ : Basis (Fin 2) ℝ V} (hb₂ : Orthonormal ℝ ⇑b₂) (ho : b.orientation = b₂.orientation) : ∃ (θ : Real.Angle), b₂ = b.map (hb.rotation θ).to_LinearEquiv
{G₀ : Type u_2} [GroupWithZero G₀] {p : G₀ˣ → Prop} : (∃ (g : G₀ˣ), p g) ↔ ∃ (g : G₀) (hg : g ≠ 0), p (Units.mk0 g hg)
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] : is_is_IsOpenMap Prod.fst
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} {v : V} {x : k} {s : Set ι} {p : ι → P} {b : P} : (∃ (fs : Finset ι) (hfs : ↑fs ⊆ s) (w : ι → k) (hw : fs.sum (λ (i : ι), w i) = x), v = ⇑(fs.weighted_vsub_of_point p b) w) ↔ ∃ (fs : Finset ↥s) (w : ↥s → k) (hw : fs.sum (λ (i : ↥s), w i) = x), v = ⇑(fs.weighted_vsub_of_point (λ (i : ↥s), p ↑i) b) w
{X : Type u_1} [TopologicalSpace X] [SequentialSpace X] {s : Set X} : IsSeqClosed s → is_IsClosed s
(K : Type u_1) (L : Type u_2) {A : Type u_5} [Field K] [Field L] [CommRing A] [Algebra K L] [Algebra L A] [Algebra K A] [IsScalarTower K L A] {x : A} (A_alg : IsAlgebraic K x) : IsAlgebraic L x
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (s : Finset ι) [CharZero k] {n : ℕ} (h : s.card = n + 1) : s.sum (λ (i : ι), Finset.centroid_weights k s i) = 1
{α : Type u_1} {M : Type u_4} {N : Type u_5} [AddCommMonoid M] [HasZero N] (f : α → N) (g : α → N → M) {s t : Finset α} (h : s ⊆ t) (hg : ∀ (a : α), g a 0 = 0) : s.sum (λ (i : α), g i (f i)) = t.sum (λ (i : α), g i (↑s.indicator f i))
{α : Type u_3} [LinearOrderedAddCommGroup α] : Filter.Tendsto HasAbs.abs filter.at_IsBot filter.at_Top
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {f : Filter α} {g : Filter β} {m : α' → β → γ} {n : α → α'} {m' : α → β → δ} {n' : δ → γ} (h_Left_comm : ∀ (a : α) (b : β), m (n a) b = n' (m' a b)) : Filter.map₂ m (Filter.map n f) g = Filter.map n' (Filter.map₂ m' f g)
{R : Type u_1} [CommSemiring R] {l : Type u_2} {m : Type u_3} {n : Type u_4} [Fintype n] [DecidableEq n] [Fintype m] [DecidableEq m] (M : Matrix l m R) (N : Matrix m n R) (x : n → R) : ⇑(⇑matrix.to_lin' (M.mul N)) x = ⇑(⇑matrix.to_lin' M) (⇑(⇑matrix.to_lin' N) x)
{R : Type u_1} [CommRing R] {n : ℕ} (hpos : 0 < n) : Polynomial.cyclotomic n R = (Polynomial.x ^ n - 1) /ₘ n.proper_divisors.prod (λ (i : ℕ), Polynomial.cyclotomic i R)
{X : Type u_2} {Y : Type u_3} [EmetricSpace X] [EmetricSpace Y] [TopologicalSpace.SecondCountableTopology X] {r : Nnreal} {f : X → Y} (hr : 0 < r) (hF : ∀ (x : X), ∃ (C : Nnreal) (s : Set X) (H : s ∈ nhds x), HolderOnWith C r f s) : dimH (Set.Range f) ≤ dimH Set.Univ / ↑r
{β : Type u} {α : Type v} [CommMonoid β] {s : Finset α} {f : α → β} {a : α} (hp : s.prod (λ (x : α), f x) = 1) (h1 : ∀ (x : α), x ∈ s → x ≠ a → f x = 1) (x : α) (H : x ∈ s) : f x = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasKernels C] : CategoryTheory.Limits.HasEqualizers C
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : α → β} {s : Set α} : AntitoneOn f s → MonotoneOn (⇑order_dual.to_dual ∘ f) s
{β : Type u} {α : Type v} {s : Finset α} [AddCommMonoid β] (f : α → β) {p : α → Prop} [DecidablePred p] (h : ∀ (x : α), x ∈ s → p x) : (Finset.subtype p s).sum (λ (x : Subtype_ p), f ↑x) = s.sum (λ (x : α), f x)
{R : Type u_1} [CancelMonoid R] (g : R) : IsRegular g
{α : Type u_3} {β : Type u_4} {f : α → β} {k : Filter α} {l : Filter β} [k.is_countably_generated] : Filter.Tendsto f k l ↔ ∀ (x : ℕ → α), Filter.Tendsto x filter.at_Top k → Filter.Tendsto (f ∘ x) filter.at_Top l
{F : Type} [CommSemiring F] {f : Polynomial F} (hF : Polynomial.HasSeparableContraction 1 f) : hf.degree = f.nat_degree
{α : Type u_1} {β : Type u_2} [AddZeroClass α] [AddCommGroup β] {f : α → β} (hF : IsAddMonoidHom f) : IsAddMonoidHom (λ (a : α), -f a)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {i : α → β} (di : DenseInducing i) [TopologicalSpace.SeparableSpace α] : TopologicalSpace.SeparableSpace β
{α : Type u_1} (L : List α) {i : ℕ} (hi : i < L.length) : List.drop i (List.take (i + 1) L) = [L.nth_LE i hi]
{M : Type u_3} {N : Type u_4} [HasZero M] [HasZero N] {f g : ZeroHom M N} : f = g ↔ ∀ (x : M), ⇑f x = ⇑g x
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) : o.oangle y (⇑(o.rotation (o.oangle x y)) x) = 0
{α : Type u_1} {β : Type u_2} [LinearOrder α] [SuccOrder α] [Preorder β] {f : α → β} (hF : Monotone f) : Pairwise (Disjoint on λ (n : α), Set.Ioo (f n) (f (Order.succ n)))
 : Disjoint (residual ℝ) MeasureTheory.Measure_space.volume.ae
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p₁ : ι → P) (p₂ : P) (h : s.sum (λ (i : ι), w i) = 0) : s.sum (λ (i : ι), w i • (p₁ i -ᵥ p₂)) = ⇑(s.weighted_vsub p₁) w
{a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) : (a * b).factorization = a.factorization + b.factorization
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [SemiNormedGroup F'] {f : α → E} {g' : α → F'} {l : Filter α} : (f =o[l] λ (x : α), -g' x) → f =o[l] g'
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasKernels C] {X Y : C} [CategoryTheory.Simple X] [CategoryTheory.Simple Y] (f : X ⟶ Y) : CategoryTheory.IsIso f ↔ f ≠ 0
{R : Type u_1} [CommRing R] (M : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization M S] (s : Finset S) : ∃ (b : ↥M), ∀ (a : S), a ∈ s → IsLocalization.IsInteger R (↑b • a)
{α : Type u_1} {ι : Type u_3} [CompleteLattice α] {s : Finset ι} {f : ι → α} : CompleteLattice.Independent (f ∘ Coe) → s.sup_indep f
 : Filter.Tendsto ⇑complex.norm_sq (Filter.cocompact ℂ) filter.at_Top
{α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] {f : Filter β} {u : β → α} {a : α} [f.ne_IsBot] (h : Filter.Tendsto u f (nhds a)) : f.liminf u = a
{α : sort u} {β : α → sort v} {f₁ f₂ : Π (x : α), β x} (h : ∀ (x : α), f₁ x = f₂ x) : f₁ = f₂
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hF : HasFpowerSeriesAt f p x) (n : ℕ) : (λ (y : E), f (x + y) - p.partial_Sum n y) =O[nhds 0] λ (y : E), ∥y∥ ^ n
{R : Type u_1} [LinearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_3} [DecidableEq ι] [Fintype ι] (e : Basis ι R M) (f : M ≃ₗ[R] M) : (e.map f).orientation = -e.orientation ↔ ⇑LinearMap.det ↑f < 0
{α : Type u} [TopologicalSpace α] : t2_Space α ↔ ∀ {x y : α}, (nhds x ⊓ nhds y).ne_IsBot → x = y
{M : Type u_1} [Monoid M] (P : Submonoid M) : P.fg ↔ ∃ (S : Set M), Submonoid.closure S = P ∧ S.finite
{K : Type u_1} [LinearOrderedField K] {v : K} {n : ℕ} [FloorRing K] (TerminatedAt_n : (GeneralizedContinuedFraction.of v).terminated_at n) : v = (GeneralizedContinuedFraction.of v).convergents n
{α : Type u_1} {β : Type u_2} {M : Type u_5} [AddCommMonoid M] {f : α → M} {g : β → M} (e : α → β) (hE₀ : Function.bijective e) (hE₁ : ∀ (x : α), f x = g (e x)) : finsum (λ (i : α), f i) = finsum (λ (j : β), g j)
{R : Type u} [Rack R] {a b : Rack.PreEnvelGroup R} : Rack.PreEnvelGroupRel' R a b → Rack.PreEnvelGroupRel R a b
(p : ℕ) (a : ℤ) [hp : Fact (Nat.Prime p)] : ↑(zmod.legendre_Sym p a) = ↑a ^ (p / 2)
{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) (p : Polynomial R) : ⇑(Polynomial.aeval M) p = ⇑(Polynomial.aeval M) (p %ₘ M.charpoly)
{α : Type u_1} [AddCommMonoid α] {n : ℕ} (f : Affine.Simplex.PointsWithCircumcenterIndex n → α) : finset.univ.sum (λ (i : Affine.Simplex.PointsWithCircumcenterIndex n), f i) = finset.univ.sum (λ (i : Fin (n + 1)), f (Affine.Simplex.PointsWithCircumcenterIndex.point_Index i)) + f Affine.Simplex.PointsWithCircumcenterIndex.circumcenter_Index
{α : Type u_1} {β : Type u_2} [UniformSpace α] [Group α] [UniformGroup α] {hom : Type u_3} [UniformSpace β] [Group β] [UniformGroup β] [MonoidHomClass hom α β] (f : hom) (hF : ContinuousAt ⇑f 1) : UniformContinuous ⇑f
{C : Type u} [CategoryTheory.Category C] {S : Type w} [CategoryTheory.SmallCategory S] (e : C ≌ S) : CategoryTheory.EssentiallySmall C
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b
{α : Type u} [AddGroup α] [Preorder α] [CovariantClass α α has_add.add has_le.le] {a : α} (h : 0 ≤ a) : -a ≤ a
{α : Type u} [TopologicalSpace α] {s : Set α} (H : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → (∃ (t : Set α) (H : t ⊆ s), x ∈ t ∧ y ∈ t ∧ IsPreconnected t)) : IsPreconnected s
{f : ℂ → ℂ} {z : ℂ} : ConformalAt f z ↔ (DifferentiableAt ℂ f z ∨ DifferentiableAt ℂ (f ∘ ⇑(StarRing_end ℂ)) (⇑(StarRing_end ℂ) z)) ∧ fderiv ℝ f z ≠ 0
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {ι : Type u_1} {s : Set ι} [IsNoetherian K V] (b : Basis ↥s K V) : s.finite
{α : Type u_1} [PartialOrder α] [OrderBot α] {a : α} : ⊥ ⋖ a → IsAtom a
{p : ℕ} : padic_val_Nat p 0 = 0
{R : Type u_1} [Semiring R] [Nontrivial R] (n : ℕ) : (PowerSeries.x ^ n).order = ↑n
{G : Type u_1} [Group G] {k : Set G} : k ⊆ ↑(Subgroup.closure k)
(F : Type u_1) [Field F] (E : Type u_2) [Field E] [Algebra F E] [Fintype E] : ∃ (α : E), F⟮α⟯ = ⊤
{𝒜 : Type u_1} [CategoryTheory.Category 𝒜] [CategoryTheory.Preadditive 𝒜] [CategoryTheory.Limits.HasKernels 𝒜] [CategoryTheory.Limits.HasImages 𝒜] [CategoryTheory.Limits.HasBinaryBiproducts 𝒜] (A B : 𝒜) : CategoryTheory.Exact CategoryTheory.Limits.biprod.inr CategoryTheory.Limits.biprod.fst
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] [Invertible 2] (p : Fin 2 → P) : Finset.centroid k Finset.univ p = 2⁻¹ • (p 1 -ᵥ p 0) +ᵥ p 0
{α : Type u} [HasSubset α] {a b : α} [IsRefl α HasSubset.Subset] : a = b → a ⊆ b
(R : Type u_1) (M : Type u_2) [Semiring R] [Subsingleton R] [AddCommMonoid M] [Module R M] : Subsingleton M
{R : Type u_1} [Semiring R] (n : ℕ) (a : R) (h : a ≠ 0) : (⇑(PowerSeries.monomial R n) a).order = ↑n
{M : Type u_2} [AddCommGroup M] {A : Type u_1} [CommRing A] [Module A M] (f : M ≃ₗ[A] M) : ⇑LinearMap.det ↑f * ⇑LinearMap.det ↑(f.symm) = 1
(n p : ℕ) : (↑p + 1) * (Finset.range n).sum (λ (k : ℕ), ↑k ^ p) = Polynomial.eval ↑n (Polynomial.bernoulli p.succ) - bernoulli p.succ
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q R : C} (f : P ⟶ Q) (g : Q ⟶ R) : ((∀ (a : ↥P), ⇑g (⇑f a) = 0) ∧ ∀ (b : ↥Q), ⇑g b = 0 → (∃ (a : ↥P), ⇑f a = b)) → CategoryTheory.Exact f g
{Γ₀ : Type u_1} [LinearOrderedCommGroupWithZero Γ₀] (γ : Γ₀) (h : γ ≠ 0) : {x : Γ₀ | x < γ} ∈ nhds 0
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] [CompleteSpace 𝕜] {n : WithTop ℕ} {f : E → (F →L[𝕜] G)} {s : Set E} [FiniteDimensional 𝕜 F] : ContDiffOn 𝕜 n f s ↔ ∀ (y : F), ContDiffOn 𝕜 n (λ (x : E), ⇑(f x) y) s
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {f : E → F} {g : E → G} (hF : ContDiff 𝕜 n f) (hg : ContDiff 𝕜 n g) : ContDiff 𝕜 n (λ (x : E), (f x, g x))
{R : Type u} {ι : Type w} (s : Finset ι) [CommSemiring R] [NoZeroDivisors R] (f : ι → Polynomial R) : (s.prod (λ (i : ι), f i)).leading_Coeff = s.prod (λ (i : ι), (f i).leading_Coeff)
{α : Type u_1} {β : Type u_2} {e e' : LocalEquiv α β} (hE : e ≈ e') (s : Set β) : e.source ∩ ⇑e ⁻¹' s = e'.source ∩ ⇑e' ⁻¹' s
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P (n + 2)) : s.monge_point = ⇑(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.monge_point_weights_with_circumcenter n)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {ι : Type v} {B : ι → C} (hB : ∀ (A : C), ∃ (i : ι), Nonempty (B i ⟶ A)) : ∃ (T : C), ∀ (X : C), Nonempty (T ⟶ X)
{α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) (v : Vector α 1) : Vector.scanl f b v = b::ᵥf b v.head::ᵥVector.nil
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} {a : α} {s : Set α} (h : f a = 0) : finsum (λ (i : α), finsum (λ (H : i ∈ HasInsert.insert a s), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i))
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {t : Finset V} (h : FiniteDimensional.finrank K V < t.card) : ∃ (f : V → K), t.sum (λ (e : V), f e • e) = 0 ∧ ∃ (x : V) (H : x ∈ t), f x ≠ 0
{m : Type u_1} {R : Type u_2} [Fintype m] [CommRing R] {M : Matrix m m R} (hM : M.nondegenerate) {v : m → R} (hv : ∀ (w : m → R), matrix.dot_Product v (M.mul_vec w) = 0) : v = 0
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {f g : ℂ → E} (hfd : DiffContOnCl ℂ f {z : ℂ | 0 < z.re}) (hgd : DiffContOnCl ℂ g {z : ℂ | 0 < z.re}) (hfexp : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hgexp : ∃ (c : ℝ) (H : c < 2) (B : ℝ), g =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hre : Asymptotics.SuperpolynomialDecay filter.at_Top Real.exp (λ (x : ℝ), ∥f ↑x - g ↑x∥)) (hfim : ∃ (C : ℝ), ∀ (x : ℝ), ∥f (↑x * Complex.i)∥ ≤ C) (hgim : ∃ (C : ℝ), ∀ (x : ℝ), ∥g (↑x * Complex.i)∥ ≤ C) : Set.EqOn f g {z : ℂ | 0 ≤ z.re}
{G : Type w} [TopologicalSpace G] [Group G] [TopologicalGroup G] [t2_Space G] (K : TopologicalSpace.PositiveCompacts G) : LocallyCompactSpace G
{α : Type u} [Preorder α] {a b : α} (h : a < b) : ¬b < a
{α : Type u_1} {β : Type u_2} (t : α) (ts : List α) (r : List β) (ys : List α) (f : List α → β) : (list.permutations_aux2 t ts r ys f).snd = List.map (λ (x : List α), f (x ++ ts)) (list.permutations_aux2 t List.nil List.nil ys Id).snd ++ r
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι} : TendstoUniformly F f p ↔ Filter.Tendsto (λ (q : ι × α), (f q.snd, F q.fst q.snd)) (p.prod ⊤) (Uniformity β)
{M : Type u_1} {N : Type u_2} {α : Type u_6} {β : Type u_7} [HasScalar M α] [HasScalar M β] [HasScalar α β] [IsScalarTower M α β] (g : N → M) : IsScalarTower N α β
 : fourier_subalgebra.separates_points
(n : ℕ) (R : Type u_1) [Ring R] [Nontrivial R] : Polynomial.cyclotomic n R ≠ 0
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] {a : α} : -a < 0 ↔ 0 < a
{α : Type u_1} {ι : Type u_3} [CompleteLattice α] {s : Finset ι} {f : ι → α} : s.sup_indep f → CompleteLattice.Independent (f ∘ Coe)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {f : 𝕜 → F} {s : Set 𝕜} {x : 𝕜} (hxs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) : iterated_deriv_within (n + 1) f s x = iterated_deriv_within n (deriv_within f s) s x
{R : Type u} [NonAssocSemiring R] {s : Set R} {p : R → Prop} {x : R} (h : x ∈ Subsemiring.closure s) (Hs : ∀ (x : R), x ∈ s → p x) (H0 : p 0) (H1 : p 1) (hAdd : ∀ (x y : R), p x → p y → p (x + y)) (hMul : ∀ (x y : R), p x → p y → p (x * y)) : p x
{R : Type u_1} {a b : R} [AddSemigroup R] (Ab : IsAddLeftRegular (a + b)) : IsAddLeftRegular b
{β : Type u_2} [DecidableEq β] (s : Finset β) (b : β) : Finset.filter (λ (a : β), a = b) s = Ite (b ∈ s) {b} ∅
{k : Type u_1} {M : Type u_2} [OrderedRing k] [OrderedAddCommGroup M] [Module k M] [OrderedSmul k M] [ContravariantClass M M has_add.add has_le.le] {a b : k} {c d : M} (hba : b ≤ a) (hdc : d ≤ c) : a • d + b • c ≤ a • c + b • d
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] (i : D ⥤ C) [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.CartesianClosed C] [CategoryTheory.Reflective i] (h : Π (A : C), i ⋙ CategoryTheory.exp A ⋙ CategoryTheory.IsLeftAdjoint i ⋙ i ≅ i ⋙ CategoryTheory.exp A) : CategoryTheory.ExponentialIdeal i
{M : Type u_1} [AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M →+ P} {T : AddSubmonoid P} {Q : Type u_4} [AddCommMonoid Q] (hg : ∀ (y : ↥S), ⇑g ↑y ∈ T) (k : T.localization_Map Q) {x y : M} (h : ⇑(f.to_Map) x = ⇑(f.to_Map) y) : ⇑(k.to_Map) (⇑g x) = ⇑(k.to_Map) (⇑g y)
{R : Type u} [Ring R] (s : Subring R) : 1 ∈ s
{α : Type u_1} [SemiNormedRing α] (a : α) {n : ℕ} (h : 0 < n) : ∥a ^ n∥ ≤ ∥a∥ ^ n
(p : ℕ) {R : Type u_1} [hp : Fact (Nat.Prime p)] [CommRing R] (r : R) (n : ℕ) : ⇑(witt_vector.ghost_component n) (⇑(WittVector.teichmuller p) r) = r ^ p ^ n
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [SemiNormedGroup F'] {c : ℝ} {f : α → E} {g' : α → F'} {l : Filter α} : asymptotics.is_O_with c l f g' → asymptotics.is_O_with c l f (λ (x : α), -g' x)
{α : Type u_1} {R : Type u_2} {l : Filter α} {f : α → R} {r : R} [LinearOrderedSemiring R] [Archimedean R] (hr : 0 < r) (hF : Filter.Tendsto f l filter.at_Top) : Filter.Tendsto (λ (x : α), r * f x) l filter.at_Top
{R : Type u_4} {S : Type u_5} [HasMul R] [has_Add R] [HasMul S] [has_Add S] {f g : R ≃+* S} (h : ∀ (x : R), ⇑f x = ⇑g x) : f = g
{M : Type u_1} [SemiNormedGroup M] (S : AddSubgroup M) (hS : is_IsClosed ↑S) (m : M) (h : ∥⇑(QuotientAddGroup.mk' S) m∥ = 0) : m ∈ S
{J : Type u₁} [CategoryTheory.Category J] [Nonempty J] (h : ∀ {α : Type u₁} (F : J → α), (∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → F j₁ = F j₂) → ∀ (j j' : J), F j = F j') : CategoryTheory.IsConnected J
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} [Subsingleton ι] (p : ι → P) : AffineIndependent k p
{R₂ : Type u_5} {M₂ : Type u_6} [CommSemiring R₂] [AddCommMonoid M₂] [Module R₂ M₂] {B : BilinForm R₂ M₂} : B.nondegenerate ↔ (⇑bilin_form.to_lin B).ker = ⊥
{G : Type u_1} [AddGroup G] {k : Set G} {p : G → G → Prop} {x y : G} (hx : x ∈ AddSubgroup.closure k) (hy : y ∈ AddSubgroup.closure k) (Hk : ∀ (x : G), x ∈ k → ∀ (y : G), y ∈ k → p x y) (H1_Left : ∀ (x : G), p 0 x) (H1_Right : ∀ (x : G), p x 0) (hMul_Left : ∀ (x₁ x₂ y : G), p x₁ y → p x₂ y → p (x₁ + x₂) y) (hMul_Right : ∀ (x y₁ y₂ : G), p x y₁ → p x y₂ → p x (y₁ + y₂)) (Hinv_Left : ∀ (x y : G), p x y → p (-x) y) (Hinv_Right : ∀ (x y : G), p x y → p x (-y)) : p x y
{R : Type u_1} {S : Type u_2} [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S] (f : R →+ S) : (∀ (x y : R), ⇑f (x * y) = ⇑f x * ⇑f y) ↔ AddMonoid_hom.mul.compr₂ f = (AddMonoid_hom.mul.comp f).compl₂ f
{M : Type u_1} [has_Add M] (r : M → M → Prop) : AddConGen r = HasInf.inf {s : AddCon M | ∀ (x y : M), r x y → ⇑s x y}
{α : Type u_1} {β : Type u_2} [AddSemigroup α] [AddCommSemigroup β] {f g : α → β} (hF : IsAddHom f) (hg : IsAddHom g) : IsAddHom (λ (a : α), f a + g a)
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {f : R →+* S} [Nontrivial S] {p : Polynomial S} (hlifts : p ∈ Polynomial.lifts f) (hp : p.monic) : ∃ (q : Polynomial R), Polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
{X : Type u} {α : Type v} [TopologicalSpace X] [LinearOrder α] [TopologicalSpace α] [OrderClosedTopology α] [PreconnectedSpace X] {a b : X} {f g : X → α} (hF : Continuous f) (hg : Continuous g) (ha : f a ≤ g a) (hb : g b ≤ f b) : ∃ (x : X), f x = g x
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] {f : α → β} {s : Set α} {a : α} (hF : MonotoneOn f s) (hs : s ∈ nhds_within a (Set.Iic a)) (hfs : ∀ (b : β), b < f a → (∃ (c : α) (H : c ∈ s), f c ∈ Set.Ioo b (f a))) : ContinuousWithinAt f (Set.Iic a) a
{𝕜 : Type u_1} {E : Type u_3} {F : Type u_4} [CommRing 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] [AddCommGroup F] [Module 𝕜 F] [TopologicalSpace F] [TopologicalAddGroup F] [HasContinuousConstSmul 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) {m n : ℕ} {v : Fin m → E} {w : Fin n → E} (h1 : m = n) (h2 : ∀ (i : ℕ) (him : i < m) (hin : i < n), v ⟨i, him⟩ = w ⟨i, hin⟩) : ⇑(p m) v = ⇑(p n) w
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (hb : ContinuousAt f b) : HasDerivAt (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) (f b) b
(m n : ℕ+) : (m.gcd n).factor_Multiset = m.factor_Multiset ⊓ n.factor_Multiset
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [Ring 𝕜] [AddCommGroup E] [AddCommGroup F] [Module 𝕜 E] [Module 𝕜 F] [TopologicalSpace E] [TopologicalSpace F] [TopologicalAddGroup E] [TopologicalAddGroup F] [HasContinuousConstSmul 𝕜 E] [HasContinuousConstSmul 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) (n : ℕ) : Continuous (p.partial_Sum n)
(α : Type u) [Preorder α] [Nonempty α] [NoMinOrder α] : ∃ (f : ℕ → α), StrictAnti f
{M : Type u} [Monoid M] (u : Mˣ) (x : M) : SemiconjBy ↑u x (↑u * x * ↑u⁻¹)
{ι : Type u} {f g : ι → Nnreal} {A B : Nnreal} {p : ℝ} (hp : 1 ≤ p) (hF : HasSum (λ (i : ι), f i ^ p) (A ^ p)) (hg : HasSum (λ (i : ι), g i ^ p) (B ^ p)) : ∃ (C : Nnreal), C ≤ A + B ∧ HasSum (λ (i : ι), (f i + g i) ^ p) (C ^ p)
{f : Bool → Bool → Bool} (hF : ∀ (b b' : Bool), f b b' = f b' b) (hF' : f bool.ff bool.ff = bool.ff) (n m : ℕ) : Nat.bitwise f n m = Nat.bitwise f m n
{S : Type v} [CommRing S] (d : ℕ) (y : S) : Polynomial.eval (1 + y) (⇑(Polynomial.monomial d) (↑d + 1)) - Polynomial.eval y (⇑(Polynomial.monomial d) (↑d + 1)) = (Finset.range (d + 1)).sum (λ (x_1 : ℕ), ↑((d + 1).choose x_1) * (↑x_1 * y ^ (x_1 - 1)))
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {a l' : α} {s : Set α} (hl' : l' < a) : s ∈ nhds_within a (Set.Iio a) ↔ ∃ (l : α) (H : l ∈ Set.Iio a), Set.Ioo l a ⊆ s
{α : Type u} {L₁ L₂ L₃ : List (α × Bool)} : FreeGroup.Red L₁ L₂ → FreeGroup.Red L₁ L₃ → Relation.Join FreeGroup.Red L₂ L₃
(ι : Type u_1) [Fintype ι] : MeasureTheory.Measure.IsAddHaarMeasure (topological_space.positive_compacts.pi_icc01 ι) = MeasureTheory.MeasureSpace.volume
{R : Type u_1} {a b : R} [Semigroup R] (lra : IsLeftRegular a) (lrb : IsLeftRegular b) : IsLeftRegular (a * b)
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] : ↑⊤ = Set.Univ
{J : Type u₁} [CategoryTheory.Category J] [CategoryTheory.IsConnected J] (r : J → J → Prop) (hr : Equivalence r) (h : ∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → r j₁ j₂) (j₁ j₂ : J) : r j₁ j₂
{n k : ℕ} : n < k → n.desc_factorial k = 0
{α : Type u_1} {β : Type u_2} [LinearOrder α] [PredOrder α] [Preorder β] {f : α → β} (hF : Monotone f) : Pairwise (Disjoint on λ (n : α), Set.Ioo (f (Order.pred n)) (f n))
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {s : Set E} : UniqueDiffOn 𝕜 s → UniqueMdiffOn (model_with_corners_self 𝕜 E) s
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] (p : P) : ↑s ∩ ↑(AffineSubspace.mk' p (s.direction)ᗮ) = {euclidean_geometry.orthogonal_projection_fn s p}
{D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ} (hF : ContinuousOn f D) (hF' : DifferentiableOn ℝ f (Interior D)) (hF'_nonneg : ∀ (x : ℝ), x ∈ Interior D → 0 ≤ deriv f x) : MonotoneOn f D
{R : Type u_1} [CommGroupWithZero R] {f g : ℕ → R} (hF : ∀ (n : ℕ), 0 < n → f n ≠ 0) (hg : ∀ (n : ℕ), 0 < n → g n ≠ 0) : (∀ (n : ℕ), 0 < n → n.divisors.prod (λ (i : ℕ), f i) = g n) ↔ ∀ (n : ℕ), 0 < n → n.divisors_antidiagonal.prod (λ (x : ℕ × ℕ), g x.snd ^ ⇑Nat.ArithmeticFunction.moebius x.fst) = f n
{n : ℕ} {i₁ i₂ : Fin (n + 1)} (h : i₁ ≠ i₂) : finset.univ.sum (λ (i : Affine.Simplex.PointsWithCircumcenterIndex n), affine.simplex.reflection_circumcenter_weights_with_circumcenter i₁ i₂ i) = 1
{X : Type u} [PseudoMetricSpace X] {δ : ℝ} {E : Set X} : Metric.Thickening δ E = ⋃ (x : X) (H : x ∈ E), Metric.Ball x δ
(R : Type u_3) (M : Type u_4) [AddCommMonoid M] [Ring R] [Fintype R] [Module R M] : Add_monoid.is_torsion M
(𝕜 : Type u_1) {A : Type u_2} [NondiscreteNormedField 𝕜] [NormedRing A] [NormedAlgebra 𝕜 A] [CompleteSpace A] (a : A) : HasFpowerSeriesOnBall (λ (z : 𝕜), Ring.inverse (1 - z • a)) (λ (n : ℕ), Continuous_multilinear_map.mk_Pi_Field 𝕜 (Fin n) (a ^ n)) 0 (↑∥a∥₊)⁻¹
{α : Type u_1} {β : Type u_2} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] [Nonempty β] {f : β → α} (hF : Continuous f) (hlim : Filter.Tendsto f (Filter.cocompact β) filter.at_IsBot) : ∃ (x : β), ∀ (y : β), f y ≤ f x
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) : InnerProductGeometry.angle x (-y) = Real.pi - InnerProductGeometry.angle x y
{R : Type u_1} [LeftCancelSemigroup R] (g : R) : IsLeftRegular g
(S T : Set ℕ+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] (C : Type w) [CommRing C] [Algebra A C] [Algebra B C] [IsScalarTower A B C] [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C] : IsCyclotomicExtension (S ∪ T) A C
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z → B} [TopologicalSpace Z] (h : IsTopologicalFiberBundle F Proj) : is_is_IsOpenMap Proj
{x y z : ℤ} : PythagoreanTriple x y z ↔ ∃ (k m n : ℤ), (x = k * (m ^ 2 - n ^ 2) ∧ y = k * (2 * m * n) ∨ x = k * (2 * m * n) ∧ y = k * (m ^ 2 - n ^ 2)) ∧ (z = k * (m ^ 2 + n ^ 2) ∨ z = -k * (m ^ 2 + n ^ 2))
{α : Type u_1} {β : Type u_2} [DecidableEq α] [Fintype α] [CommMonoid β] {δ : α → Type u_3} {t : Π (a : α), Finset (δ a)} (f : (Π (a : α), a ∈ Finset.univ → δ a) → β) : (finset.univ.pi t).prod (λ (x : Π (a : α), a ∈ Finset.univ → δ a), f x) = (fintype.pi_Finset t).prod (λ (x : Π (a : α), δ a), f (λ (a : α) (_x : a ∈ Finset.univ), x a))
{α : Type u} {β : Type v} [TopologicalSpace α] [PartialOrder α] [t : OrderTopology α] {f g h : β → α} {b : Filter β} {a : α} (hg : Filter.Tendsto g b (nhds a)) (hH : Filter.Tendsto h b (nhds a)) (hgf : g ≤ f) (hfh : f ≤ h) : Filter.Tendsto f b (nhds a)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasBinaryProducts C] : CategoryTheory.Limits.HasBinaryBiproducts C
{β : Type u_2} [CommMonoid β] (f : Fin 0 → β) : finset.univ.prod (λ (i : Fin 0), f i) = 1
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [Nontrivial E] {x : E} {K : Set E} (hK : is_IsCompact K) (hx : x ∈ K) : ∃ (y : E) (H : y ∈ Frontier K), metric.inf_dist x Kᶜ = HasDist.dist x y
{C : Type u₁} [CategoryTheory.SmallCategory C] (P : Cᵒᵖ ⥤ Type u₁) (j : (P.elements)ᵒᵖ) : (Category_theory.cocone_of_representable P).ι.app j = (CategoryTheory.yoneda_sections_Small ((CategoryTheory.Category_of_elements.π P).left_op.obj j) (((CategoryTheory.Functor.const (P.elements)ᵒᵖ).obj (Category_theory.cocone_of_representable P).X).obj j)).inv (Opposite.unop j).snd
(𝕜 : Type u_1) [NondiscreteNormedField 𝕜] {E : Type u_2} [SemiNormedGroup E] [NormedSpace 𝕜 E] {s : Set E} (s_nhd : s ∈ nhds 0) : Metric.Bounded (NormedSpace.Polar 𝕜 s)
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {L : Filter 𝕜} {f' : 𝕜 →L[𝕜] F} : HasFderivAtFilter f f' x L ↔ HasDerivAtFilter f (⇑f' 1) x L
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f : X ⟶ Y} {c : CategoryTheory.Limits.Cofork f f} (h : CategoryTheory.Limits.IsColimit c) : CategoryTheory.IsIso c.π
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
{α : Type u_1} [TopologicalSpace α] {x : α} {γ : Type u_4} [LinearOrderedAddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] [HasContinuousAdd γ] {f g : α → γ} (hF : LowerSemicontinuousAt f x) (hg : LowerSemicontinuousAt g x) : LowerSemicontinuousAt (λ (z : α), f z + g z) x
{C : Type u} [CategoryTheory.Category C] {D : Type u'} [CategoryTheory.Category D] [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Limits.HasFiniteProducts D] (F : C ⥤ D) [CategoryTheory.CartesianClosed C] [CategoryTheory.CartesianClosed D] [CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F] {A A' : C} (f : A' ⟶ A) : CategoryTheory.exp_comparison F A ≫ Category_theory.whisker_Left F (CategoryTheory.pre (F.map f)) = Category_theory.whisker_Right (CategoryTheory.pre f) F ≫ CategoryTheory.exp_comparison F A'
{α : Type u} (L : List α) {i j : ℕ} (hi : i < L.length) (hj : i < j) : L.nth_LE i hi = (List.take j L).nth_LE i _
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {X : Top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget C)] {F G : Top.Sheaf C X} (f : F ⟶ G) [∀ (x : ↥X), CategoryTheory.IsIso ((Top.presheaf.stalk_Functor C x).map f)] : CategoryTheory.IsIso f
{α : Type u} [PseudoMetricSpace α] (x y : α) : HasEdist.edist x y = ↑(HasNndist.nndist x y)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {R : Type u_6} [NormedRing R] [NormedAlgebra 𝕜 R] [CompleteSpace R] (x : Rˣ) : HasFderivAt Ring.inverse (-⇑(⇑(Continuous_Linear_map.lmul_Left_Right 𝕜 R) ↑x⁻¹) ↑x⁻¹) ↑x
{m : Type u_2} {n : Type u_3} {α : Type v} [HasStar α] (M : Matrix m n α) (i : m) (j : n) : M.conj_transpose j i = HasStar.star (M i j)
(𝕜 : Type u_1) {E : Type u_2} [NormedLinearOrderedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [StrictConvexSpace 𝕜 E] (x : E) (r : ℝ) : StrictConvex 𝕜 (Metric.ClosedBall x r)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p : ι → P) (h : s.sum (λ (i : ι), w i) = 1) (b₁ b₂ : P) : ⇑(s.weighted_vsub_of_point p b₁) w +ᵥ b₁ = ⇑(s.weighted_vsub_of_point p b₂) w +ᵥ b₂
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : Nnreal} {c : ℂ} {f : ℂ → E} {s : Set ℂ} (hs : s.countable) (hc : ContinuousOn f (Metric.ClosedBall c ↑R)) (hD : ∀ (z : ℂ), z ∈ Metric.Ball c ↑R  s → DifferentiableAt ℂ f z) (hR : 0 < R) : HasFpowerSeriesOnBall f (Cauchy_PowerSeries f c ↑R) c ↑R
{α : Type u_1} {E : α → Type u_2} {p : Ennreal} [Π (i : α), NormedGroup (E i)] {ι : Type u_3} {l : Filter ι} [l.ne_IsBot] [Fact (1 ≤ p)] {F : ι → ↥(Lp E p)} (hF : Metric.Bounded (Set.Range F)) {f : Π (a : α), E a} (hF : Filter.Tendsto (Id (λ (i : ι), ⇑(F i))) l (nhds f)) : memℓp f p
{C : Type u} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) {A A' B B' : C} [CategoryTheory.Limits.HasBinaryProduct A B] [CategoryTheory.Limits.HasBinaryProduct A' B'] [CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)] [CategoryTheory.Limits.HasBinaryProduct (F.obj A') (F.obj B')] (f : A ⟶ A') (g : B ⟶ B') : F.map (CategoryTheory.Limits.prod.map f g) ≫ Category_theory.limits.prod_comparison F A' B' = Category_theory.limits.prod_comparison F A B ≫ CategoryTheory.Limits.prod.map (F.map f) (F.map g)
{𝕜 : Type u_1} {E : Type u} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] {s : Set E} : ⇑(Convex_hull 𝕜) s = ⋃ (t : Finset E) (hss : ↑t ⊆ s) (hai : AffineIndependent 𝕜 Coe), ⇑(Convex_hull 𝕜) ↑t
{G : Type u_1} [Group G] {H : Subgroup G} [DecidableEq G] {R S : Finset G} (hR : ↑R ∈ Subgroup.RightTransversals ↑H) (hR1 : 1 ∈ R) (hS : Subgroup.closure ↑S = ⊤) : Subgroup.closure ↑(Finset.image (λ (g : G), ⟨g * (↑(subgroup.mem_Right_transversals.to_fun hR g))⁻¹, _⟩) (R * S)) = ⊤
{𝕂 : Type u_1} {𝔸 : Type u_2} [NondiscreteNormedField 𝕂] [NormedCommRing 𝔸] [NormedAlgebra 𝕂 𝔸] [CompleteSpace 𝔸] [CharZero 𝕂] {x y : 𝔸} (hx : x ∈ Emetric.Ball 0 (Exp_series 𝕂 𝔸).radius) (hy : y ∈ Emetric.Ball 0 (Exp_series 𝕂 𝔸).radius) : Exp 𝕂 (x + y) = Exp 𝕂 x * Exp 𝕂 y
{M : Type u_1} [AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M →+ P} (hg : ∀ (y : ↥S), IsAddUnit (⇑g ↑y)) (z : N) : ⇑(f.lift hg) z + ⇑g ↑((f.sec z).snd) = ⇑g (f.sec z).fst
{V : Type u_1} [InnerProductSpace ℝ V] {x : V} (hx : x ≠ 0) : InnerProductGeometry.angle x (-x) = Real.pi
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} {a : α} {s : Set α} (h : f a = 1) : finprod (λ (i : α), finprod (λ (H : i ∈ HasInsert.insert a s), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i))
{R : Type u_1} {M : Type u_2} [TopologicalSpace R] [DivisionRing R] [HasContinuousSub R] [AddCommGroup M] [TopologicalSpace M] [HasContinuousAdd M] [Module R M] [HasContinuousSmul R M] (f : M →L[R] R) (hF : f ≠ 0) : is_is_IsOpenMap ⇑f
(n : ℕ+) (K : Type w) (L : Type z) [Field K] [Field L] [Algebra K L] [NeZero ↑↑n] [IsCyclotomicExtension {n} K L] : Polynomial.IsSplittingField K L (Polynomial.cyclotomic ↑n K)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) {X : C} [CategoryTheory.IsIso (h.unit.app X)] : CategoryTheory.inv (L.map (h.unit.app X)) = h.counit.app (L.obj X)
{m : Type u_1} [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (M N : Matrix m m R) : (M.mul N).det = (N.mul M).det
{𝕜 : Type u_1} {E : Type u_2} [SemiNormedRing 𝕜] [HasScalar 𝕜 E] {s t : Set E} (hs : Balanced 𝕜 s) (h : s ⊆ t) : s ⊆ BalancedCore 𝕜 t
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Limits.HasEqualizers C] : CategoryTheory.Limits.HasFiniteLimits C
{α : Type u_1} [TopologicalSpace α] {s : Set α} : MeasureTheory.AnalyticSet s ↔ ∃ (β : Type) (h : TopologicalSpace β) (h' : PolishSpace β) (f : β → α), Continuous f ∧ Set.Range f = s
{M : Type u_1} [Monoid M] {s : Set M} {a : M} (hs : IsSubmonoid s) (h : a ∈ s) : Powers a ⊆ s
{C : Type u} [CategoryTheory.Category C] {X Y : C} [CategoryTheory.Limits.HasEqualizers C] {X' : C} (h : X' ⟶ X) [CategoryTheory.IsIso h] (f : X ⟶ Y) [CategoryTheory.Limits.HasImage f] : Category_theory.limits.image_Subobject (h ≫ f) = Category_theory.limits.image_Subobject f
{α : Type u} [Preorder α] {a b c : α} : a < b → b < c → a < c
{𝕜 : Type u} [hnorm : NondiscreteNormedField 𝕜] {E : Type v} [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousSmul 𝕜 E] {F' : Type x} [AddCommGroup F'] [Module 𝕜 F'] [TopologicalSpace F'] [TopologicalAddGroup F'] [HasContinuousSmul 𝕜 F'] [CompleteSpace 𝕜] [t2_Space E] [FiniteDimensional 𝕜 E] (f : E →ₗ[𝕜] F') : Continuous ⇑f
{𝕜 : Type u_1} {E : Type u_4} [SemiNormedGroup E] [NondiscreteNormedField 𝕜] [NormedSpace 𝕜 E] {𝕜' : Type u_10} [NormedField 𝕜'] [NormedAlgebra 𝕜 𝕜'] [NormedSpace 𝕜' E] [IsScalarTower 𝕜 𝕜' E] : ∥ContinuousLinearMap.lsmul 𝕜 𝕜'∥ ≤ 1
{C : Type u} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) {A A' B B' : C} [CategoryTheory.Limits.HasBinaryCoproduct A B] [CategoryTheory.Limits.HasBinaryCoproduct A' B'] [CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)] [CategoryTheory.Limits.HasBinaryCoproduct (F.obj A') (F.obj B')] (f : A ⟶ A') (g : B ⟶ B') : Category_theory.limits.coprod_comparison F A B ≫ F.map (CategoryTheory.Limits.coprod.map f g) = CategoryTheory.Limits.coprod.map (F.map f) (F.map g) ≫ Category_theory.limits.coprod_comparison F A' B'
{α : Type u_1} [ConditionallyCompleteLattice α] {s : Set α} {a : α} (hs : BddAbove s) (sne : s.nonempty) : HasSup.sup (HasInsert.insert a s) = a ⊔ HasSup.sup s
{α : Type u_1} {l₁ l₂ : List α} : l₁ <:+ l₂ → l₁.reverse <+: l₂.reverse
{G : Type u_1} [AddGroup G] [Fintype G] : Add_monoid.is_torsion G
{α : Type u} [PseudoMetricSpace α] {s : Set α} (h : Metric.Bounded s) : Metric.Bounded (Closure s)
{ι : Type u_1} {R : Type u_2} {N : Type u_5} [decι : DecidableEq ι] [Semiring R] [AddCommMonoid N] [Module R N] (p : ι → Submodule R N) : CompleteLattice.Independent p ↔ ∀ (i : ι) (x : ↥(p i)) (v : Π₀ (i : ι), ↥(p i)), ⇑(⇑(Dfinsupp.lsum ℕ) (λ (i : ι), (p i).subtype)) (Dfinsupp.erase i v) = ↑x → x = 0
{α : Type u_1} {β : Type u_2} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] {s : Set β} {f : β → α} (hF : ContinuousOn f s) (hsc : is_IsClosed s) {x₀ : β} (h₀ : x₀ ∈ s) (hc : ∀ᶠ (x : β) in Filter.cocompact β ⊓ Filter.principal s, f x ≤ f x₀) : ∃ (x : β) (H : x ∈ s), ∀ (y : β), y ∈ s → f y ≤ f x
{α : Type u} {n : ℕ} (f : Fin n → α) : (list.of_fn f).length = n
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] (f g : ℝ × ℝ → E) (f' g' : ℝ × ℝ → (ℝ × ℝ →L[ℝ] E)) (a₁ a₂ b₁ b₂ : ℝ) (s : Set (ℝ × ℝ)) (hs : s.countable) (Hcf : ContinuousOn f (Set.Interval a₁ b₁ ×ˢ Set.Interval a₂ b₂)) (Hcg : ContinuousOn g (Set.Interval a₁ b₁ ×ˢ Set.Interval a₂ b₂)) (Hdf : ∀ (x : ℝ × ℝ), x ∈ Set.Ioo (Linear_order.min a₁ b₁) (Linear_order.max a₁ b₁) ×ˢ Set.Ioo (Linear_order.min a₂ b₂) (Linear_order.max a₂ b₂)  s → HasFderivAt f (f' x) x) (Hdg : ∀ (x : ℝ × ℝ), x ∈ Set.Ioo (Linear_order.min a₁ b₁) (Linear_order.max a₁ b₁) ×ˢ Set.Ioo (Linear_order.min a₂ b₂) (Linear_order.max a₂ b₂)  s → HasFderivAt g (g' x) x) (Hi : MeasureTheory.IntegrableOn (λ (x : ℝ × ℝ), ⇑(f' x) (1, 0) + ⇑(g' x) (0, 1)) (Set.Interval a₁ b₁ ×ˢ Set.Interval a₂ b₂) MeasureTheory.MeasureSpace.volume) : ∫ (x : ℝ) in a₁..b₁, ∫ (y : ℝ) in a₂..b₂, ⇑(f' (x, y)) (1, 0) + ⇑(g' (x, y)) (0, 1) = (((∫ (x : ℝ) in a₁..b₁, g (x, b₂)) - ∫ (x : ℝ) in a₁..b₁, g (x, a₂)) + ∫ (y : ℝ) in a₂..b₂, f (b₁, y)) - ∫ (y : ℝ) in a₂..b₂, f (a₁, y)
{α : Type u_1} [PartialOrder α] {f : α → α} {p : α → Prop} {hF : ∀ (x : α), x ≤ f x} {hfp : ∀ (x : α), p (f x)} {hmin : ∀ ⦃x y : α⦄, x ≤ y → p y → f x ≤ y} {x : α} (hx : p x) : x ∈ (ClosureOperator.mk₃ f p hF hfp hmin).closed
{C : Type u₁} [CategoryTheory.Category C] {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₁₂ : X₁₂ ⟶ X₁₃} {h₂₁ : X₂₁ ⟶ X₂₂} {h₂₂ : X₂₂ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃} (s : CategoryTheory.IsPushout (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂)) (p : h₁₂ ≫ v₁₃ = v₁₂ ≫ h₂₂) (t : CategoryTheory.IsPushout h₁₁ v₁₁ v₁₂ h₂₁) : CategoryTheory.IsPushout h₁₂ v₁₂ v₁₃ h₂₂
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [InnerProductSpace 𝕜 G] [CompleteSpace E] [CompleteSpace G] [CompleteSpace F] (A : F →L[𝕜] G) (B : E →L[𝕜] F) : ⇑ContinuousLinearMap.adjoint (A.comp B) = (⇑ContinuousLinearMap.adjoint B).comp (⇑ContinuousLinearMap.adjoint A)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {J : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.FinCategory J] (F : J ⥤ C) : Nonempty (CategoryTheory.Limits.Cone F)
{α : Type u_1} {p : Finset α → Prop} [DecidableEq α] (s : Finset α) (h₁ : p ∅) (h₂ : ∀ ⦃a : α⦄ {s : Finset α}, a ∉ s → p s → p (HasInsert.insert a s)) : p s
{s : ℝ} (h : 0 < s) : MeasureTheory.IntegrableOn (λ (x : ℝ), Real.exp (-x) * x ^ (s - 1)) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {f : E → G} {C : ℝ} {s : Set E} {x y : E} (hF : DifferentiableOn 𝕜 f s) (bound : ∀ (x : E), x ∈ s → ∥fderiv_within 𝕜 f s x∥ ≤ C) (hs : Convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
{α : Type u_2} [SubtractionMonoid α] {a : α} : Even a → Even (-a)
{R : Type u} {A : Type w} [CommSemiring R] [Semiring A] [Algebra R A] (s : R) (x y : A) : x * s • y = s • (x * y)
{C : Type u} [CategoryTheory.Category C] {F₁ F₂ : Cᵒᵖ ⥤ Type v} (α : F₁ ⟶ F₂) : (CategoryTheory.Category_of_elements.map α).op ⋙ CategoryTheory.Category_of_elements.to_CostructuredArrow F₂ = CategoryTheory.Category_of_elements.to_CostructuredArrow F₁ ⋙ CategoryTheory.CostructuredArrow.map α
{α : Type u} {L : List (α × Bool)} [DecidableEq α] : FreeGroup.reduce (FreeGroup.reduce L) = FreeGroup.reduce L
{R : Type u} {a : R} [Semiring R] {p : Polynomial R} (h : p.leading_Coeff * a ≠ 0) : (p * ⇑Polynomial.c a).nat_degree = p.nat_degree
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {J : Type u} [CategoryTheory.Category J] [CategoryTheory.Limits.HasLimitsOfShape J C] (R : D ⥤ C) [CategoryTheory.Reflective R] : CategoryTheory.Limits.HasLimitsOfShape J D
{R : Type u_1} [CommRing R] (P : Ideal (Polynomial R)) : ((Ideal.Quotient.mk (Ideal.map (Polynomial.map_RingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.c P))) P)).comp Polynomial.c).comp (Ideal.Quotient.mk (Ideal.comap Polynomial.c P)) = ((Ideal.map (Polynomial.map_RingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.c P))) P).quotient_Map (Polynomial.map_RingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.c P))) Ideal.le_comap_Map).comp ((Ideal.Quotient.mk P).comp Polynomial.c)
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [SemiNormedGroup E'] [SemiNormedGroup F'] {f' : α → E'} {g' : α → F'} {l : Filter α} : f' =O[l] g' → ((λ (x : α), ∥f' x∥) =O[l] λ (x : α), ∥g' x∥)
{α : Type u_1} [Preorder α] {a b : α} : a ⩿ b → ⇑order_dual.to_dual b ⩿ ⇑order_dual.to_dual a
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [UniformSpace α] [UniformSpace β] [LocallyCompactSpace α] [CompactSpace β] [SeparatedSpace β] [UniformSpace γ] {f : α → β → γ} {x : α} {U : Set α} (hxU : U ∈ nhds x) (hU : IsSeparated U) (h : ContinuousOn ↿f (U ×ˢ Set.Univ)) : TendstoUniformly f (f x) (nhds x)
{a : ℝ} {l : Filter ℝ} {f f' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in nhds a, HasDerivAt f (f' x) x) (hgg' : ∀ᶠ (x : ℝ) in nhds a, HasDerivAt g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in nhds a, g' x ≠ 0) (hfa : Filter.Tendsto f (nhds a) (nhds 0)) (hga : Filter.Tendsto g (nhds a) (nhds 0)) (hDiv : Filter.Tendsto (λ (x : ℝ), f' x / g' x) (nhds a) l) : Filter.Tendsto (λ (x : ℝ), f x / g x) (nhds_within a (Set.Univ  {a})) l
{p : ℝ} : Summable (λ (n : ℕ), (↑n ^ p)⁻¹) ↔ 1 < p
(x : Pgame) : (x * 1).equiv x
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {f : Filter α} {g : Filter β} {m : α → β' → γ} {n : β → β'} {m' : α → β → δ} {n' : δ → γ} (h_Right_comm : ∀ (a : α) (b : β), m a (n b) = n' (m' a b)) : Filter.map₂ m f (Filter.map n g) = Filter.map n' (Filter.map₂ m' f g)
{α : Type u} [PseudoEmetricSpace α] {x : α} : Emetric.diam {x} = 0
(R : Type u_1) {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] [IsArtinianRing R] {A : Set M} (hA : A.finite) : IsArtinian R ↥(Submodule.span R A)
{V : Type u_1} [InnerProductSpace ℝ V] {x : V} (hx : x ≠ 0) : InnerProductGeometry.angle x x = 0
(p n : ℕ) : WittVector.IsPoly p (λ (R : Type u_1) (_Rcr : CommRing R), WittVector.init n)
{R : Type u} {L : Type v} [CommRing R] [LieRing L] [LieAlgebra R L] (M : Type w) [AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M] [LieAlgebra.IsNilpotent R L] [LieModule.IsNilpotent R L M] : lie_module.weight_Space M 0 = ⊤
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] [NormalSpace Y] (f : BoundedContinuousFunction X ℝ) (e : C(X, Y)) (hE : ClosedEmbedding ⇑e) : ∃ (g : BoundedContinuousFunction Y ℝ), ∥g∥ ≤ ∥f∥ / 3 ∧ HasDist.dist (g.comp_Continuous e) f ≤ 2 / 3 * ∥f∥
{C : Type u} [CategoryTheory.Category C] (P Q : C) [CategoryTheory.Limits.HasBinaryProduct P Q] [CategoryTheory.Limits.HasBinaryProduct Q P] : (CategoryTheory.Limits.prod.braiding P Q).hom ≫ (CategoryTheory.Limits.prod.braiding Q P).hom = 𝟙 (P ⨯ Q)
{α : Type u_1} {β : Type u_2} (rα : α → α → Prop) (rβ : β → β → Prop) : Prod.rprod rα rβ ≤ Relation.TransGen (Relation.GameAdd rα rβ)
{E : Type u_3} [SemiNormedGroup E] : Filter.Tendsto has_neg.neg (Filter.comap HasNorm.norm filter.at_Top) (Filter.comap HasNorm.norm filter.at_Top)
{α : Type u} : Nonempty (Field α) ↔ IsPrimePow (Cardinal.mk α)
(x : Pgame) : (x * 0).equiv 0
{α : Type u_1} {M : Type u_5} {G : Type u_9} [Group G] [MulAction G α] [AddCommMonoid M] (g : G) (f : α →₀ M) (a : α) : ⇑(g • f) a = ⇑f (g⁻¹ • a)
 : ∀ᶠ (x : ℝ) in residual ℝ, Liouville x
{S : Type u_1} [AddSemigroup S] {a b c : S} (hac : AddCommute a c) (hbc : AddCommute b c) : AddCommute (a + b) c
{ι : Type u_1} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {G : ι → Type u_4} [Π (i : ι), InnerProductSpace 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 V) [∀ (i : ι), CompleteSpace (G i)] (hV' : (⨆ (i : ι), (V i).to_LinearMap.range).topological_Closure = ⊤) (W₀ : Π₀ (i : ι), G i) : ⇑((hV.linear_Isometry_Equiv hV').symm) (W₀.sum (lp.single 2)) = W₀.sum (λ (i : ι), ⇑(V i))
{α : sort u_1} {β : sort u_2} {s₁ : Setoid α} {s₂ : Setoid β} {p : Quotient s₁ → Quotient s₂ → Prop} (q₁ : Quotient s₁) (q₂ : Quotient s₂) (h : ∀ (a₁ : α) (a₂ : β), p (Quotient.mk' a₁) (Quotient.mk' a₂)) : p q₁ q₂
(𝕜 : Type v) [is_R_or_C 𝕜] {E : Type u} [NormedGroup E] [NormedSpace 𝕜 E] {x y : E} : x = y ↔ ∀ (g : NormedSpace.Dual 𝕜 E), ⇑g x = ⇑g y
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (u : E) {v : E} (hv : HasInner.inner v u = 0) : v ∈ (Submodule.span 𝕜 {u})ᗮ
(x : ℂ) : HasStrictDerivAt Complex.cos (-Complex.sin x) x
(u : ℕ → ℝ) (l : ℝ) (hmono : Monotone u) (c : ℕ → ℝ) (cone : ∀ (k : ℕ), 1 < c k) (clim : Filter.Tendsto c filter.at_Top (nhds 1)) (hc : ∀ (k : ℕ), Filter.Tendsto (λ (n : ℕ), u ⌊c k ^ n⌋₊ / ↑⌊c k ^ n⌋₊) filter.at_Top (nhds l)) : Filter.Tendsto (λ (n : ℕ), u n / ↑n) filter.at_Top (nhds l)
{E : Type u_1} [AddCommGroup E] [HasNorm E] (C : NormedGroup.Core E) : SemiNormedGroup.Core E
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι} [TopologicalSpace α] (h : TendstoUniformlyOn F f p s) (hc : ∀ᶠ (n : ι) in p, ContinuousOn (F n) s) [p.ne_IsBot] : ContinuousOn f s
{R : Type u_4} {S : Type u_5} [NonAssocSemiring R] [NonAssocSemiring S] (f : R ≃+* S) : ↑↑f = ↑f
{n m : SimplexCategory} {f : n ⟶ m} : CategoryTheory.Epi f ↔ Function.Surjective ⇑(Simplex_category.hom.to_order_hom f)
{α : Type u_2} [has_Add α] {a : α} : Even a → (∃ (b : α), a = bit0 b)
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] (p1 p2 : P) (g : G) : p1 -ᵥ (g +ᵥ p2) = p1 -ᵥ p2 - g
{α : Type u} [PseudoEmetricSpace α] {s t u : Set α} : emetric.Hausdorff_edist s u ≤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u
{α : Type u_1} [PseudoMetricSpace α] (r C : ℝ) (hr : r < 1) {f : ℕ → α} (hu : ∀ (n : ℕ), HasDist.dist (f n) (f (n + 1)) ≤ C * r ^ n) : CauchySeq f
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] (Z : TopologicalFiberBundleCore ι B F) : Continuous Z.proj
{𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] {f : 𝕜 → G} {s : Set 𝕜} {C : Nnreal} (hF : ∀ (x : 𝕜), x ∈ s → DifferentiableAt 𝕜 f x) (bound : ∀ (x : 𝕜), x ∈ s → ∥deriv f x∥₊ ≤ C) (hs : Convex ℝ s) : LipschitzOnWith C f s
{G : Type u_1} [Group G] (tG : monoid.is_torsion G) (H : Subgroup G) : monoid.is_torsion ↥H
{p n k : ℕ} (hn : 0 < n) : p ^ ⇑((n.choose k).factorization) p ≤ n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasEqualizers C] [CategoryTheory.Limits.HasImages C] {Y Z : C} (f : Y ⟶ Z) (P : CategoryTheory.ProjectiveResolution Y) (Q : CategoryTheory.ProjectiveResolution Z) : CategoryTheory.ProjectiveResolution.lift_f_One f P Q ≫ Q.complex.d 1 0 = P.complex.d 1 0 ≫ CategoryTheory.ProjectiveResolution.lift_f_Zero f P Q
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (i : Fin r ⊕ Unit) {k : ℕ} (hk : k ≤ r) : M.mul (List.take k (matrix.pivot.list_transvec_row M)).prod i (Sum.inr ()) = M i (Sum.inr ())
{ι : Type u_1} {E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {c : E} {la la' : Filter ℝ} {Lt : Filter ι} {a b : ℝ} {u v : ι → ℝ} [Interval_integral.FTC_Filter a la la'] (hab : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f la' MeasureTheory.MeasureSpace.volume) (hF : Filter.Tendsto f (la' ⊓ MeasureTheory.Measure_space.volume.ae) (nhds c)) (hu : Filter.Tendsto u Lt la) (hv : Filter.Tendsto v Lt la) : (λ (t : ι), ((∫ (x : ℝ) in v t..b, f x) - ∫ (x : ℝ) in u t..b, f x) + (v t - u t) • c) =o[Lt] (v - u)
{a : Nnreal} : AddLeCancellable ↑a
{α : Type u} [HasSsubset α] [IsIrrefl α HasSsubset.Ssubset] {a b : α} : a ⊂ b → b ≠ a
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [CompleteSpace E] (v : E) : ⇑(Orthogonal_projection (Submodule.span 𝕜 {v})ᗮ) v = 0
{α : Type} {f g : (α → ℕ) → ℕ} (df : Dioph.DiophFn f) (dg : Dioph.DiophFn g) : Dioph.DiophFn (λ (v : α → ℕ), f v ^ g v)
(R : Type u) (L : Type v) [CommRing R] [LieRing L] [LieAlgebra R L] [LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L] : Subsingleton L
{G : Type u_3} [AddGroup G] (P : AddSubgroup G) : P.fg ↔ P.to_Add_submonoid.fg
{R : Type u_1} [CommRing R] (u v w : Fin 3 → R) : matrix.dot_Product u (⇑(⇑CrossProduct v) w) = matrix.dot_Product v (⇑(⇑CrossProduct w) u)
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (G : D ⥤ C) [CategoryTheory.IsRightAdjoint G] : CategoryTheory.SolutionSetCondition G
{R : Type u_1} [CommSemiring R] (x y : R) (n : ℕ) : (x + y) ^ n = (Finset.range (n + 1)).sum (λ (m : ℕ), x ^ m * y ^ (n - m) * ↑(n.choose m))
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] {v : E} (hv : v ∈ Kᗮ) : ⇑(reflection K) v = -v
{b m : ℕ} : m < (b + 2) ^ ((b + 2).digits m).length
{α : Type u_1} {r : Setoid α} : ∅ ∉ r.classes
{G : Type u_1} {H : Type u_2} [Group G] {N : Subgroup G} [Group H] {f : G →* H} (hF : Function.Surjective ⇑f) (hN : N = f.ker) (tN : monoid.is_torsion ↥N) : monoid.is_torsion H ↔ monoid.is_torsion G
{p : ℕ} (hp : 1 < p) : padic_val_Nat p p = 1
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {f : α → E} {g : α → F} {l : Filter α} : f =O[l] g ↔ ∃ (c : ℝ), ∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥
{p n k : ℕ} : ⇑((n.choose k).factorization) p ≤ Nat.log p n
{R : Type u_1} [MulZeroClass R] (h : IsRightRegular 0) : Subsingleton R
{α : Type u_1} {s : Multiset α} : s.nodup → s.powerset.nodup
{α : Type u_1} {M : Type u_5} {R : Type u_11} {S : Type u_12} [HasZero M] [CommSemiring R] [CommSemiring S] (h : R →+* S) (f : α →₀ M) (g : α → M → R) : ⇑h (f.prod g) = f.prod (λ (a : α) (b : M), ⇑h (g a b))
{G : Type u_6} {H : Type u_7} {F : Type u_8} [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) (a : G) : ⇑f a⁻¹ = (⇑f a)⁻¹
{α : Type u} {β : Type v} [CommSemiring β] {δ : α → Type u_1} [DecidableEq α] [Π (a : α), DecidableEq (δ a)] {s : Finset α} {t : Π (a : α), Finset (δ a)} {f : Π (a : α), δ a → β} : s.prod (λ (a : α), (t a).sum (λ (b : δ a), f a b)) = (s.pi t).sum (λ (p : Π (a : α), a ∈ s → δ a), s.attach.prod (λ (x : {x // x ∈ s}), f x.val (p x.val _)))
(R : Type u) [CommSemiring R] {M : Type v} [AddCommMonoid M] [Module R M] (g : M →ₗ[R] M) (f : (M →ₗ[R] M)ˣ) : ⇑(LinearMap.trace R M) (↑f * g * ↑f⁻¹) = ⇑(LinearMap.trace R M) g
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {F G H : C ⥤ D} (e : F ≅ G) (e' : G ≅ H) (hF : CategoryTheory.IsEquivalence F) : Category_theory.is_equivalence.of_iso e' (Category_theory.is_equivalence.of_iso e hF) = Category_theory.is_equivalence.of_iso (e ≪≫ e') hF
{J : Type v} [CategoryTheory.SmallCategory J] {F : J ⥤ Type (max v u)} (x : CategoryTheory.Limits.colimit F) : ∃ (j : J) (y : F.obj j), CategoryTheory.Limits.colimitι F j y = x
{J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ Mon_) [CategoryTheory.IsFiltered J] {x x' y : Σ (j : J), ↥(F.obj j)} (hxx' : CategoryTheory.Limits.Types.FilteredColimit.Rel (F ⋙ CategoryTheory.forget Mon_) x x') : Mon.filtered_colimits.colimit_Mul_aux F x y = Mon.filtered_colimits.colimit_Mul_aux F x' y
{α : Type u} [AddGroup α] [LinearOrder α] [CovariantClass α α has_add.add has_le.le] (a : α) : Linear_order.max a 0 - Linear_order.max (-a) 0 = a
{a b : ℕ} (hab : a.coprime b) : (a * b).factorization = a.factorization + b.factorization
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} (s : Finset ι) (p : ι → P) : Finset.centroid k s p = ⇑(s.affine_combination p) (Finset.centroid_weights k s)
{R : Type u_1} [OrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_4} [Fintype ι] [DecidableEq ι] [Nontrivial R] (e : Basis ι R M) (w : ι → Rˣ) : (e.units_Smul w).orientation = (finset.univ.prod (λ (i : ι), w i))⁻¹ • e.orientation
(n : ℕ) (R : Type u_1) [CommRing R] [is_IsDomain R] : (Polynomial.cyclotomic' n R).roots = (primitive_roots n R).val
{M : Type u_1} {ι : Type u_2} {R : Type u_3} [DecidableEq M] [AddMonoid M] [DecidableEq ι] [AddMonoid ι] [CommSemiring R] (f : M →+ ι) : DirectSum.IsInternal (AddMonoidAlgebra.grade_by R ⇑f)
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : α → β} : Antitone f → Monotone (⇑order_dual.to_dual ∘ f)
{α : Type u_1} [TopologicalSpace α] [NonUnitalNonAssocRing α] [TopologicalRing α] (x : α) : Continuous ⇑(AddMonoid_hom.mul_Right x)
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {f : ℂ → E} (hD : DiffContOnCl ℂ f (Set.Ioi 0 ×ℂ Set.Ioi 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Ioi 0)] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hre : ∀ (x : ℝ), 0 ≤ x → f ↑x = 0) (him : ∀ (x : ℝ), 0 ≤ x → f (↑x * Complex.i) = 0) : Set.EqOn f 0 {z : ℂ | 0 ≤ z.re ∧ 0 ≤ z.im}
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasZeroMorphisms C] (X : C) : CategoryTheory.IsPushout 0 (𝟙 X) 0 0
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {s : Set E} (s_conv : Convex ℝ s) {f : E → F} {f' : E → (E →L[ℝ] F)} {f'' : E →L[ℝ] E →L[ℝ] F} (hF : ∀ (x : E), x ∈ Interior s → HasFderivAt f (f' x) x) {x : E} (xs : x ∈ s) (hx : HasFderivWithinAt f' f'' (Interior s) x) {v w : E} (hv : x + v ∈ Interior s) (hw : x + v + w ∈ Interior s) : (λ (h : ℝ), f (x + h • v + h • w) - f (x + h • v) - h • ⇑(f' x) w - h ^ 2 • ⇑(⇑f'' v) w - (h ^ 2 / 2) • ⇑(⇑f'' w) w) =o[nhds_within 0 (Set.Ioi 0)] λ (h : ℝ), h ^ 2
{H : Type u_1} [TopologicalSpace H] {e : LocalHomeomorph H H} : e ∈ ChartedSpace.Atlas H H ↔ e = LocalHomeomorph.refl H
{R : Type u_1} {E : Type u_2} [LinearOrderedField R] [AddCommGroup E] [Module R E] (s : Set E) : ⇑(Convex_hull R) s = ⋃ (t : Finset E) (w : ↑t ⊆ s), ⇑(Convex_hull R) ↑t
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasFiniteLimits C] : CategoryTheory.Limits.HasFiniteWidePullbacks C
{n : ℕ} {x : ℕ × ℕ} : x ∈ Finset.Nat.antidiagonal n ↔ x.fst + x.snd = n
{p : ℕ} [hp : Fact (Nat.Prime p)] {R : Type u_1} [CommRing R] {S : Type u_2} [Semiring S] {f : Π (k : ℕ), S →+* TruncatedWittVector p k R} (f_compat : ∀ (k₁ k₂ : ℕ) (hk : k₁ ≤ k₂), (TruncatedWittVector.truncate hk).comp (f k₂) = f k₁) (g : S →+* WittVector p R) (g_compat : ∀ (k : ℕ), (WittVector.truncate k).comp g = f k) : WittVector.lift (λ (k₂ : ℕ), f k₂) f_compat = g
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {a b : ℝ} {f f' : ℝ → ℝ} {g : ℝ → E} (h : ∀ (x : ℝ), x ∈ Set.Interval a b → HasDerivAt f (f' x) x) (h' : ContinuousOn f' (Set.Interval a b)) (hg : Continuous g) : ∫ (x : ℝ) in a..b, f' x • (g ∘ f) x = ∫ (x : ℝ) in f a..f b, g x
{k : Type u_1} {M : Type u_2} [LinearOrderedField k] [OrderedAddCommMonoid M] [MulActionWithZero k M] (hlt : ∀ ⦃a b : M⦄ ⦃c : k⦄, a < b → 0 < c → c • a ≤ c • b) : OrderedSmul k M
{γ : Type u_3} [tγ : TopologicalSpace γ] [PolishSpace γ] [MeasurableSpace γ] [BorelSpace γ] {β : Type u_4} [tβ : TopologicalSpace β] [t2_Space β] [MeasurableSpace β] [BorelSpace β] {s : Set γ} {f : γ → β} (hs : MeasurableSet s) (f_Cont : ContinuousOn f s) (f_inj : Set.InjOn f s) : MeasurableEmbedding (s.restrict f)
{R : Type u} [CommSemiring R] (t : Multiset (Polynomial R)) (h : (Multiset.map (λ (f : Polynomial R), f.leading_Coeff) t).prod ≠ 0) : t.prod.nat_degree = (Multiset.map (λ (f : Polynomial R), f.nat_degree) t).sum
{ι : Type u₁} {k : Type u₂} {V : Type u₃} {P : Type u₄} [AddCommGroup V] [AddTorsor V P] [Ring k] [Module k V] (b : AffineBasis ι k P) {ι' : Type u_1} [Fintype ι'] [Fintype ι] [DecidableEq ι] [Nontrivial k] (p : ι' → P) {A : Matrix ι ι' k} (hA : A.mul (b.to_Matrix p) = 1) : affine_Span k (Set.Range p) = ⊤
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {ι : Type w} {s : Set ι} (h : Basis ↥s K V) (hs : s.finite) : FiniteDimensional K V
{α : Type u_1} [ConditionallyCompleteLattice α] (a : α) : HasInf.inf {a} = a
(p : ℕ) [hp : Fact (Nat.Prime p)] {k : Type u_1} [CommRing k] [Char_p k p] (n : ℕ) (x y : WittVector p k) : WittVector.peval (witt_vector.poly_of_interest p n) ![λ (i : ℕ), x.coeff i, λ (i : ℕ), y.coeff i] = (x * y).coeff (n + 1) - y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) - x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1)
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {s : Set ℂ} {f : ℂ → E} {z : ℂ} (hD : DifferentiableOn ℂ f s) (hz : s ∈ nhds z) : AnalyticAt ℂ f z
{α : Type u} [TopologicalSpace α] [t2_Space α] {s : Set α} (hs : is_IsCompact s) {ι : Type u_1} (t : Finset ι) (U : ι → Set α) (hU : ∀ (i : ι), i ∈ t → is_IsOpen (U i)) (hsC : s ⊆ ⋃ (i : ι) (H : i ∈ t), U i) : ∃ (K : ι → Set α), (∀ (i : ι), is_IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (H : i ∈ t), K i
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [LinearOrderedAddCommMonoid β] [HasScalar 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f : E → β} (hF : ConvexOn 𝕜 s f) {x y z : E} (hx : x ∈ s) (hy : y ∈ s) (hz : z ∈ Segment 𝕜 x y) : f z ≤ Linear_order.max (f x) (f y)
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : ℝ} {c w : ℂ} {f : ℂ → E} (h : DiffContOnCl ℂ f (Metric.Ball c R)) (hw : w ∈ Metric.Ball c R) : ∮ (z : ℂ) in C(c, R), (z - w)⁻¹ • f z = (2 * ↑Real.pi * Complex.i) • f w
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q) : Function.Injective ⇑f → ∀ (a : ↥P), ⇑f a = 0 → a = 0
{𝕜 : Type u} {A : Type v} [Field 𝕜] [Ring A] [Algebra 𝕜 A] [Nontrivial A] : Spectrum 𝕜 0 = {0}
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommGroup β] [HasScalar 𝕜 E] [Module 𝕜 β] {s : Set E} {f : E → β} : StrictConvexOn 𝕜 s (-f) ↔ StrictConcaveOn 𝕜 s f
{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] {s : Set E} (hs : Convex 𝕜 s) {a b : 𝕜} (ha : 0 ≤ a) (hb : 0 < b) (hab : a + b = 1) : a • Closure s + b • Interior s ⊆ Interior s
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (s : AffineSubspace ℝ P) [Nonempty ↥s] [CompleteSpace ↥(s.direction)] : (EuclideanGeometry.reflection s).symm = EuclideanGeometry.reflection s
{𝕜 : Type u_1} {E : Type u_2} [SemiNormedRing 𝕜] [HasScalar 𝕜 E] [HasZero E] [TopologicalSpace E] {s₁ s₂ : Set E} (h : s₁ ⊆ s₂) (hs₂ : bornology.is_vonN_bounded 𝕜 s₂) : bornology.is_vonN_bounded 𝕜 s₁
{R : Type u_1} [MulZeroClass R] : IsRegular 0 ↔ Subsingleton R
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {f : α → E} {g : α → F} {l : Filter α} : f =o[l] g ↔ ∀ ⦃c : ℝ⦄, 0 < c → asymptotics.is_O_with c l f g
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] {f : α → β} {s : Set α} {a : α} (h_Mono : StrictMonoOn f s) (hs : s ∈ nhds_within a (Set.Iic a)) (hfs : Set.SurjOn f s (Set.Iio (f a))) : ContinuousWithinAt f (Set.Iic a) a
{X Y : Top} {f g : C(↥X, ↥Y)} (H : f.homotopy g) {x₀ x₁ : ↥X} (p : fundamental_groupoid.from_Top x₀ ⟶ fundamental_groupoid.from_Top x₁) : (fundamental_groupoid.fundamental_groupoid_functor.map g).map p = ContinuousMap.Homotopy.hcast _ ≫ (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_Map).map (Continuous_map.homotopy.prod_to_Prod_Top_I (𝟙 {down := 1}) p) ≫ ContinuousMap.Homotopy.hcast _
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y : V} (θ : Real.Angle) : hb.oangle x y = θ ↔ x ≠ 0 ∧ y ≠ 0 ∧ y = (∥y∥ / ∥x∥) • ⇑(hb.rotation θ) x ∨ θ = 0 ∧ (x = 0 ∨ y = 0)
{R : Type u_1} {R₂ : Type u_2} {E : Type u_5} {E₂ : Type u_6} [Semiring R] [Semiring R₂] {σ₁₂ : R →+* R₂} [SemiNormedGroup E] [SemiNormedGroup E₂] [Module R E] [Module R₂ E₂] {ι : Type u_3} (b : Basis ι R E) {f₁ f₂ : E →ₛₗᵢ[σ₁₂] E₂} (h : ∀ (i : ι), ⇑f₁ (⇑b i) = ⇑f₂ (⇑b i)) : f₁ = f₂
{G : Type u_4} [NormedGroup G] [NormedSpace ℝ G] {s : Set G} {x y : G} (h : OpenSegment ℝ x y ⊆ s) : y - x ∈ TangentConeAt ℝ s x
{α : Type u} [SemilatticeSup α] [OrderBot α] (x y z : α) (f : z ⟶ x) (g : z ⟶ y) : CategoryTheory.Limits.pushout f g = x ⊔ y
{M : Type u_1} [HasMul M] (c : Con M) : ConGen ⇑c = c
{K : Type u_4} {V : Type u} [DivisionRing K] [AddCommGroup V] [Module K V] {x : V} {n : ℕ} {v : Fin n → V} (hv : LinearIndependent K v) (hx : x ∉ Submodule.span K (Set.Range v)) : LinearIndependent K (fin.cons x v)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) (l₁ l₂ : ι →₀ 𝕜) : HasInner.inner (⇑(Finsupp.total ι E 𝕜 v) l₁) (⇑(Finsupp.total ι E 𝕜 v) l₂) = l₁.sum (λ (i : ι) (y : 𝕜), ⇑(StarRing_end 𝕜) y * ⇑l₂ i)
{α : Type u_1} [has_Add α] [Preorder α] [CovariantClass α α has_add.add has_lt.lt] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b c d : α} (h₁ : a < b) (h₂ : c < d) : a + c < b + d
(n : ℕ+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] : IsCyclotomicExtension {n} A B ↔ (∃ (r : B), ⇑(Polynomial.aeval r) (Polynomial.cyclotomic ↑n A) = 0) ∧ ∀ (x : B), x ∈ Algebra.adjoin A {b : B | b ^ ↑n = 1}
{α : Type u} [TopologicalSpace α] {s : Set α} {a : α} : (∃ᶠ (x : α) in nhds a, x ∈ s) → a ∈ Closure s
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] : CategoryTheory.Limits.HasFiniteProducts C
{α : Type} {d : ℕ} {ds : List ℕ} (x y : Holor α (d :: ds)) (h : x.slice = y.slice) : x = y
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] [FiniteDimensional ℝ V] (hD : FiniteDimensional.finrank ℝ V = 2) {c₁ c₂ p₁ p₂ p : P} {r₁ r₂ : ℝ} (hc : c₁ ≠ c₂) (hp : p₁ ≠ p₂) (hp₁c₁ : HasDist.dist p₁ c₁ = r₁) (hp₂c₁ : HasDist.dist p₂ c₁ = r₁) (hpc₁ : HasDist.dist p c₁ = r₁) (hp₁c₂ : HasDist.dist p₁ c₂ = r₂) (hp₂c₂ : HasDist.dist p₂ c₂ = r₂) (hpc₂ : HasDist.dist p c₂ = r₂) : p = p₁ ∨ p = p₂
{𝕜 : Type u_1} [NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Subspace 𝕜 E} (hFc : is_IsClosed ↑F) (hF : ∃ (x : E), x ∉ F) {r : ℝ} (hr : r < 1) : ∃ (x₀ : E), x₀ ∉ F ∧ ∀ (y : E), y ∈ F → r * ∥x₀∥ ≤ ∥x₀ - y∥
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} {ps : Set P} (h : ps ⊆ ↑s) [Nonempty ↥s] {n : ℕ} [FiniteDimensional ℝ ↥(s.direction)] (hD : FiniteDimensional.finrank ℝ ↥(s.direction) = n) (hc : EuclideanGeometry.Cospherical ps) : ∃ (r : ℝ), ∀ (sx : Affine.Simplex ℝ P n), Set.Range sx.points ⊆ ps → sx.circumradius = r
{α : Type u_1} [HasMul α] [HasLe α] [ContravariantClass α α has_mul.mul has_le.le] {a b c : α} (bc : a * b ≤ a * c) : b ≤ c
{C : Type u} [CategoryTheory.Category C] {X Y : C} (J : CategoryTheory.GrothendieckTopology C) (f : Y ⟶ X) (S : CategoryTheory.Sieve X) (h : J.covers S f) {Z : C} (g : Z ⟶ Y) : J.covers S (g ≫ f)
{α : Type u_1} [AddCommMonoid α] {β : Type u_2} [Fintype β] (s : Set β) [DecidablePred (λ (_x : β), _x ∈ s)] (f : β → α) (g : ↥s → α) (w : ∀ (x : β) (h : x ∈ s), f x = g ⟨x, h⟩) (w' : ∀ (x : β), x ∉ s → f x = 0) : finset.univ.sum f = finset.univ.sum g
{K : Type u_1} {S : Type u_2} [Field K] [CommRing S] [Algebra K S] (h : PowerBasis K S) : (⇑(algebra.left_Mul_Matrix h.basis) h.gen).charpoly = minpoly K h.gen
(n : ℕ) : n.factors.to_Finset = Finset.filter Nat.Prime n.divisors
(R : Type u_1) [CommSemiring R] (M : Type u_4) (N : Type u_5) [AddCommMonoid M] [AddCommMonoid N] [Module R M] [Module R N] : Submodule.span R {t : TensorProduct R M N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t} = ⊤
{α : Type u} [PseudoMetricSpace α] : Metric.diam ∅ = 0
{R : Type u} {S : Type v} [NonAssocSemiring R] [NonAssocSemiring S] {f g : R →+* S} {s : Set R} (h : Set.EqOn ⇑f ⇑g s) : Set.EqOn ⇑f ⇑g ↑(Subsemiring.closure s)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace.SeparableSpace α] [TopologicalSpace β] {f : α → β} (h : DenseRange f) (h' : Continuous f) : TopologicalSpace.SeparableSpace β
{p : ℕ} [Fact (Nat.Prime p)] {a : Zmod p} (ha : a ≠ 0) : a ^ (p - 1) = 1
{J : Type u₁} [CategoryTheory.Category J] {K : Type u₁} [CategoryTheory.Category K] [CategoryTheory.IsPreconnected J] (e : J ≌ K) : CategoryTheory.IsPreconnected K
{G : Type w} [TopologicalSpace G] [HasNeg G] [has_Add G] [HasContinuousAdd G] [HasContinuousNeg G] : Continuous (λ (g : G × G), g.fst + g.snd + -g.fst)
{α : Type u_1} [Preorder α] {s : Set α} : s.ord_connected ↔ ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → Set.Icc x y ⊆ s
{G : Type u_1} [Group G] {k : Set G} {p : Π (x : G), x ∈ Subgroup.closure k → Prop} (Hs : ∀ (x : G) (h : x ∈ k), p x _) (H1 : p 1 _) (hMul : ∀ (x : G) (hx : x ∈ Subgroup.closure k) (y : G) (hy : y ∈ Subgroup.closure k), p x hx → p y hy → p (x * y) _) (Hinv : ∀ (x : G) (hx : x ∈ Subgroup.closure k), p x hx → p x⁻¹ _) {x : G} (hx : x ∈ Subgroup.closure k) : p x hx
{K : Type u_4} [NormedField K] {ξ : K} : Summable (λ (n : ℕ), ξ ^ n) ↔ ∥ξ∥ < 1
{R : Type u_1} {M : Type u_2} [CommRing R] [AddCommGroup M] [Module R M] : Submodule.torsion R (M ⧸ Submodule.torsion R M) = ⊥
{K : Type u} [Field K] (s : Subfield K) {x y : K} : x ∈ s → y ∈ s → x + y ∈ s
{R : Type u} [Semiring R] {P : Type (max u v)} [AddCommMonoid P] [Module R P] {M : Type (max u v)} [AddCommGroup M] [Module R M] {N : Type u_1} [AddCommGroup N] [Module R N] [h : Module.Projective R P] (f : M →ₗ[R] N) (g : P →ₗ[R] N) (hF : Function.Surjective ⇑f) : ∃ (h : P →ₗ[R] M), f.comp h = g
{α : Type u_1} [LinearOrderedCommGroup α] {n : ℤ} {a b : α} (hn : n ≠ 0) : a ^ n = b ^ n ↔ a = b
{α : Type u_1} {m : Type u_3} {n : Type u_4} [NonUnitalSemiring α] [StarRing α] {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α} {D : Matrix n n α} : (matrix.from_blocks A B C D).is_hermitian ↔ A.is_hermitian ∧ B.conj_transpose = C ∧ C.conj_transpose = B ∧ D.is_hermitian
{α : Type u_1} {β : Type u_2} {M : Type u_5} [AddZeroClass M] {f : α → β} (hF : Function.Injective f) (v₁ v₂ : β →₀ M) : finsupp.comap_IsDomain f (v₁ + v₂) _ = finsupp.comap_IsDomain f v₁ _ + finsupp.comap_IsDomain f v₂ _
{M : Type u_1} [HasMul M] {c d : Con M} : c ⊔ d = ConGen (Setoid.r ⊔ Setoid.r)
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} [PartialOrder 𝕜] : HasDerivWithinAt f f' (Set.Iic x) x → HasDerivWithinAt f f' (Set.Iio x) x
(n : ℕ) : ⇑Multiset.card (Multiset.Nat.antidiagonal n) = n + 1
{α : Type u_1} {β : Type u_2} {mβ : MeasurableSpace β} {m : MeasurableSpace α} (t : ℕ → Set β) (t_Meas : ∀ (n : ℕ), MeasurableSet (t n)) (t_disj : Pairwise (Disjoint on t)) (g : ℕ → β → α) (hg : ∀ (n : ℕ), Measurable (g n)) : ∃ (f : β → α), Measurable f ∧ ∀ (n : ℕ) (x : β), x ∈ t n → f x = g n x
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} {r' : Nnreal} (hF : HasFpowerSeriesOnBall f p x r) (h : ↑r' < r) : TendstoUniformlyOn (λ (n : ℕ) (y : E), p.partial_Sum n y) (λ (y : E), f (x + y)) filter.at_Top (Metric.Ball 0 ↑r')
{α : sort u} {β : sort v} (e : α ≃ β) : IsEmpty α ↔ IsEmpty β
{M : Type u_1} [has_Add M] {c d : AddCon M} : c ⊔ d = AddConGen (Setoid.r ⊔ Setoid.r)
{R : Type u} [NonAssocSemiring R] (M : Submonoid R) : M.subsemiring_Closure = Subsemiring.closure ↑M
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] : IsCompl K Kᗮ
{α : sort u_1} {β : sort u_2} (f : α → β) (P : Prop) [Decidable P] (a b : α) : f (Ite P a b) = Ite P (f a) (f b)
{a b : ℝ} {g' g : ℝ → ℝ} (hab : a ≤ b) (hcont : ContinuousOn g (Set.Icc a b)) (hderiv : ∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivWithinAt g (g' x) (Set.Ioi x) x) (g'Int : MeasureTheory.IntegrableOn g' (Set.Icc a b) MeasureTheory.MeasureSpace.volume) : ∫ (y : ℝ) in a..b, g' y = g b - g a
{p : ℕ} (hp : 1 < p) : padic_norm p ↑p = 1 / ↑p
{R : Type u_1} {R₂ : Type u_2} {E : Type u_5} {E₂ : Type u_6} [Semiring R] [Semiring R₂] {σ₁₂ : R →+* R₂} {σ₂₁ : R₂ →+* R} [RingHomInvPair σ₁₂ σ₂₁] [RingHomInvPair σ₂₁ σ₁₂] [SemiNormedGroup E] [SemiNormedGroup E₂] [Module R E] [Module R₂ E₂] {ι : Type u_3} (b : Basis ι R E) {f₁ f₂ : E ≃ₛₗᵢ[σ₁₂] E₂} (h : ∀ (i : ι), ⇑f₁ (⇑b i) = ⇑f₂ (⇑b i)) : f₁ = f₂
{n : ℕ} (R : Type u_1) [Ring R] [Fact (0 < n)] : Coe ∘ Zmod.val = Coe
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f f₁ : E → F} {n : WithTop ℕ} {p : E → FormalMultilinearSeries 𝕜 E F} (h : HasFtaylorSeriesUpToOn n f p s) (h₁ : ∀ (x : E), x ∈ s → f₁ x = f x) : HasFtaylorSeriesUpToOn n f₁ p s
{E : Type u_3} {F : Type u_4} [SemiNormedGroup E] [SemiNormedGroup F] (f : E →+ F) (C : ℝ) (h : ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥) : LipschitzWith C.to_Nnreal ⇑f
{C : Type u₁} [CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {P : Cᵒᵖ ⥤ Type v₁} (h : CategoryTheory.Presieve.IsSheafFor P ⇑S) {f : S.functor ⟶ P} (t : Category_theory.yoneda.obj X ⟶ P) (ht : S.functor_inclusion ≫ t = f) : t = h.extend f
{E : Type u_2} [SemiNormedGroup E] [NormedSpace ℝ E] (s : Set E) : Emetric.diam (⇑(Convex_hull ℝ) s) = Emetric.diam s
(p : Set → Prop) : Class.Iota p ∈ Class.Univ
{M : Type u_1} [SemiNormedGroup M] (S : AddSubgroup M) (m : M) : ∥⇑(QuotientAddGroup.mk' S) m∥ = 0 ↔ m ∈ Closure ↑S
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {F F' : C ⥤ D} (h : F ≅ F') {Y : D} (hY : Y ∈ F.ess_image) : Y ∈ F'.ess_image
{K : Type u_1} {L : Type u_2} {M : Type u_3} [Field K] [Field L] [Field M] [Algebra K L] [Algebra K M] {E1 E2 : IntermediateField K L} (e : L ≃ₐ[K] M) (h12 : E1 ≤ E2) : E1.map e.to_AlgHom ≤ E2.map e.to_AlgHom
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [SemiNormedGroup F'] {f : α → E} {g' : α → F'} {l : Filter α} : f =O[l] g' → (f =O[l] λ (x : α), ∥g' x∥)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} [Fintype ι] {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι → 𝕜) (i : ι) : HasInner.inner (finset.univ.sum (λ (i : ι), l i • v i)) (v i) = ⇑(StarRing_end 𝕜) (l i)
{n : ℕ} (hn : 2 ≤ n) : StrictConvexOn ℝ (Set.Ici 0) (λ (x : ℝ), x ^ n)
{R : Type u_1} {M : Type u_2} {P : Type u_3} [Ring R] [AddCommGroup M] [Module R M] [AddCommGroup P] [Module R P] (f : M →ₗ[R] P) {s : Submodule R M} (hs1 : (Submodule.map f s).fg) (hs2 : (s ⊓ f.ker).fg) : s.fg
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {ι : Type w} {p : ι → Submodule K V} (hp : CompleteLattice.Independent p) [Fintype {i // p i ≠ ⊥}] : Fintype.card {i // p i ≠ ⊥} ≤ FiniteDimensional.finrank K V
{α : Type u_1} {β : Type u_2} [HasMem α β] {s t : β} {a : α} : a ∈ s → a ∉ t → s ≠ t
{S : Type u_1} [has_Add S] {a b : S} (h : AddCommute a b) : AddCommute b a
{K : Type u_1} {L : Type u_2} {A : Type u_5} [Field K] [Field L] [CommRing A] [Algebra K L] [Algebra L A] [Algebra K A] [IsScalarTower K L A] (L_alg : Algebra.IsAlgebraic K L) (A_alg : Algebra.IsAlgebraic L A) : Algebra.IsAlgebraic K A
{α : Type u} : DenseRange has_pure.pure
{α : Type u} [Semiring α] {x y : α} (h : Commute x y) (n : ℕ) : (Finset.range n).sum (λ (i : ℕ), (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {E' : Type u_7} [InnerProductSpace 𝕜 E'] (f : E →ₗᵢ[𝕜] E') (x y : E) : HasInner.inner (⇑f x) (⇑f y) = HasInner.inner x y
{Y : Type u_2} [TopologicalSpace Y] [NormalSpace Y] {s : Set Y} (f : BoundedContinuousFunction ↥s ℝ) (hs : is_IsClosed s) : ∃ (g : BoundedContinuousFunction Y ℝ), ∥g∥ = ∥f∥ ∧ g.restrict s = f
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {X Y : C} [CategoryTheory.Simple X] {f : X ⟶ Y} [CategoryTheory.Epi f] (w : f ≠ 0) : CategoryTheory.IsIso f
{M : Type u_3} [AddMonoid M] (l : List M) : (l.nth 0).get_or_else 0 + l.tail.sum = l.sum
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] : Continuous_map.compact_IsOpen = ⨅ (s : Set α) (hs : is_IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) Continuous_map.compact_IsOpen
{A : Type u_1} [NormedRing A] [NormedAlgebra ℂ A] [CompleteSpace A] [StarRing A] [CstarRing A] [StarModule ℂ A] [Nontrivial A] (a : ↥(IsSelfAdjoint A)) {z : ℂ} (hz : z ∈ Spectrum ℂ ↑a) : z = ↑(z.re)
{R : Type u} [Ring R] [RankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {ι : Type u_1} (b : Basis ι R M) {w : Set M} [Fintype ↥w] (s : Submodule.span R w = ⊤) : Cardinal.mk ι ≤ ↑(Fintype.card ↥w)
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] {K : Type u_2} [Field K] [Algebra R K] [IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R) (r : R) : ⇑(v.valuation) (⇑(Algebra_Map R K) r) < 1 ↔ v.as_Ideal ∣ Ideal.span {r}
{α : Type u} [SemilatticeInf α] [OrderBot α] {a : α} : Disjoint a a → a = ⊥
{R : Type u_1} [CommRing R] {x₁ x₂ y₁ y₂ n : R} : (x₁ ^ 2 + n * x₂ ^ 2) * (y₁ ^ 2 + n * y₂ ^ 2) = (x₁ * y₁ - n * x₂ * y₂) ^ 2 + n * (x₁ * y₂ + x₂ * y₁) ^ 2
{K : Type u_3} {L : Type u_4} [Field K] [Field L] [Algebra K L] (A : Subalgebra K L) (hKL : Algebra.IsAlgebraic K L) : IsField ↥A
{ι : Type u} (s : Finset ι) (f g : ι → Nnreal) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤ s.sum (λ (i : ι), f i ^ p) ^ (1 / p) + s.sum (λ (i : ι), g i ^ p) ^ (1 / p)
{M : Type u_1} {A : Type u_2} [AddCommMonoid M] {s : Set M} (hs : IsAddSubmonoid s) (f : A → M) (t : Finset A) : (∀ (b : A), b ∈ t → f b ∈ s) → t.sum (λ (b : A), f b) ∈ s
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] {p : P} : ↑(⇑(euclidean_geometry.orthogonal_projection s) p) = p ↔ p ∈ s
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (e : LocalHomeomorph α β) {f : γ → α} {s : Set γ} (h : s ⊆ f ⁻¹' e.to_local_equiv.source) : ContinuousOn f s ↔ ContinuousOn (⇑e ∘ f) s
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {s1 s2 : AffineSubspace k P} (h1 : ↑s1.nonempty) (h2 : ↑s2.nonempty) (hD : s1.direction ⊔ s2.direction = ⊤) : (↑s1 ∩ ↑s2).nonempty
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {a b c : α} [IsTrans α HasSubset.Subset] (h₁ : a ⊆ b) (h₂ : b ⊂ c) : a ⊂ c
{M : Type u_1} {N : Type u_2} [AddZeroClass M] [AddZeroClass N] (h : M ≃+ N) : IsAddMonoidHom ⇑h
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {E : Type w} [NormedGroup E] [NormedSpace 𝕜 E] {f : 𝕜 → F} {f' : F} (x : 𝕜) {l : F → E} {l' : F →L[𝕜] E} (hl : HasFderivAt l l' (f x)) (hF : HasDerivAt f f' x) : HasDerivAt (l ∘ f) (⇑l' f') x
{m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (e : m ≃ n) (A : Matrix m m R) : (⇑(Matrix.reindex e e) A).det = A.det
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [CompleteSpace E] [CompleteSpace F] (A : E →L[𝕜] F) : ⇑ContinuousLinearMap.adjoint (⇑ContinuousLinearMap.adjoint A) = A
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {s : Set E} {x : E} : UniqueMdiffWithinAt (model_with_corners_self 𝕜 E) s x → UniqueDiffWithinAt 𝕜 s x
{α : Type u_1} {r : α → α → Prop} {f : Filter α} [IsTrans α r] (a : α) (h : ∀ (s : Set α), s ∈ f → (∃ (x : α) (H : x ∈ s), r a x)) : Filter.IsCobounded r f
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {f : E → G} {x : E × F} (hF : ContDiffAt 𝕜 n f x.fst) : ContDiffAt 𝕜 n (λ (x : E × F), f x.fst) x
{α : Type v} {s : Finset α} {M : Type u_1} [AddCommMonoid M] (f : α → M) (p : M → Prop) (p_Mul : ∀ (a b : M), p a → p b → p (a + b)) (hs_Nonempty : s.nonempty) (p_s : ∀ (x : α), x ∈ s → p (f x)) : p (s.sum (λ (x : α), f x))
{α : Type u_1} [PartialOrder α] [OrderTop α] {a : α} : a ⋖ ⊤ → IsCoatom a
(𝕜 : Type u_1) [NondiscreteNormedField 𝕜] (E : Type u_2) [NormedGroup E] [NormedSpace 𝕜 E] : (model_with_corners_self 𝕜 E).to_LocalEquiv = LocalEquiv.refl E
{α : Type v} {s : Finset α} {M : Type u_1} [CommMonoid M] (f : α → M) (p : M → Prop) (p_Mul : ∀ (a b : M), p a → p b → p (a * b)) (hs_Nonempty : s.nonempty) (p_s : ∀ (x : α), x ∈ s → p (f x)) : p (s.prod (λ (x : α), f x))
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasZeroMorphisms C] (X : C) : CategoryTheory.IsPushout (𝟙 X) 0 0 0
{a b : ℝ} (h : a < b) : Cardinal.mk ↥(Set.Ico a b) = Cardinal.continuum
{α : Type u} {β : Type v} [PseudoMetricSpace α] [PseudoMetricSpace β] {f : α → β} (hF : Isometry f) (x y : α) : HasNndist.nndist (f x) (f y) = HasNndist.nndist x y
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [CompactSpace α] [MetricSpace β] {f g : C(α, β)} (x : α) : HasDist.dist (⇑f x) (⇑g x) ≤ HasDist.dist f g
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] {g : F → G} {f : E → F} {x : E} (hg : AnalyticAt 𝕜 g (f x)) (hF : AnalyticAt 𝕜 f x) : AnalyticAt 𝕜 (g ∘ f) x
{M : Type u_1} {N : Type u_2} [has_Add M] [has_Add N] {f g : AddHom M N} {s : Set M} (h : Set.EqOn ⇑f ⇑g s) : Set.EqOn ⇑f ⇑g ↑(AddSubsemigroup.closure s)
{α : Type u} [PseudoMetricSpace α] (s : Set α) : Continuous (λ (x : α), metric.inf_nndist x s)
(A : Type u_4) (K : Type u_5) [CommRing A] [is_IsDomain A] (L : Type u_6) [Field K] [Field L] [Algebra A K] [Algebra A L] [IsFractionRing A K] (C : Type u_7) [CommRing C] [is_IsDomain C] [Algebra C L] [is_IsIntegralClosure C A L] [Algebra A C] [IsScalarTower A C L] [Algebra K L] [IsScalarTower A K L] [FiniteDimensional K L] : IsFractionRing C L
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {ca cb : E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (ha : Filter.Tendsto f (nhds a ⊓ MeasureTheory.Measure_space.volume.ae) (nhds ca)) (hb : Filter.Tendsto f (nhds b ⊓ MeasureTheory.Measure_space.volume.ae) (nhds cb)) : HasStrictFderivAt (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) ((ContinuousLinearMap.snd ℝ ℝ ℝ).smul_Right cb - (ContinuousLinearMap.fst ℝ ℝ ℝ).smul_Right ca) (a, b)
{𝕜 : Type u_1} {E : Type u_2} [LinearOrderedRing 𝕜] [AddCommGroup E] [Module 𝕜 E] [DenselyOrdered 𝕜] [NoZeroSmulDivisors 𝕜 E] {A : Set E} {x : E} : x ∈ Set.ExtremePoints 𝕜 A ↔ x ∈ A ∧ ∀ (x₁ : E), x₁ ∈ A → ∀ (x₂ : E), x₂ ∈ A → x ∈ Segment 𝕜 x₁ x₂ → x₁ = x ∨ x₂ = x
{k : ℕ} {A : Finset ℕ} (h₁ : ∀ {x : ℕ}, x ∈ A → x < k) : A.sum (has_pow.pow 2) < 2 ^ k
{α : Type u_1} [CircularPreorder α] {a b c : α} (h : HasSbtw.Sbtw a b c) : ¬HasSbtw.Sbtw c b a
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] [Fintype α] [Fintype β] (f : α → β) {b : M} [LinearOrderedCommRing M] [Nonempty β] (hb : Fintype.card β • b ≤ ↑(Fintype.card α)) : ∃ (y : β), b ≤ ↑((Finset.filter (λ (x : α), f x = y) Finset.univ).card)
{n : ℕ} (i : Fin (n + 2)) : ⇑(i.succ.succ_above) 1 = (⇑(i.succ_above) 0).succ
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : LocalHomeomorph α β} {s : Set α} {t : Set β} : e.to_local_equiv.source ∩ ⇑e ⁻¹' t = e.to_local_equiv.source ∩ s → e.is_image s t
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {v : ℝ → E → E} {s : ℝ → Set E} {K : ℝ} (hv : ∀ (t : ℝ) (x : E), x ∈ s t → ∀ (y : E), y ∈ s t → HasDist.dist (v t x) (v t y) ≤ K * HasDist.dist x y) {f g : ℝ → E} {a b δ : ℝ} (hF : ContinuousOn f (Set.Icc a b)) (hF' : ∀ (t : ℝ), t ∈ Set.Ico a b → HasDerivWithinAt f (v t (f t)) (Set.Ici t) t) (hfs : ∀ (t : ℝ), t ∈ Set.Ico a b → f t ∈ s t) (hg : ContinuousOn g (Set.Icc a b)) (hg' : ∀ (t : ℝ), t ∈ Set.Ico a b → HasDerivWithinAt g (v t (g t)) (Set.Ici t) t) (hgs : ∀ (t : ℝ), t ∈ Set.Ico a b → g t ∈ s t) (ha : HasDist.dist (f a) (g a) ≤ δ) (t : ℝ) (H : t ∈ Set.Icc a b) : HasDist.dist (f t) (g t) ≤ δ * Real.exp (K * (t - a))
(n : ℕ) : Filter.Tendsto (λ (x : ℝ), Polynomial.eval x (Exp_Neg_Inv_glue.P_aux n) * Real.exp (-x⁻¹) / x ^ (2 * n)) (nhds_within 0 (Set.Ioi 0)) (nhds 0)
{α : Type u_1} {β : Type u_2} [LinearOrder α] [LinearOrder β] [DenselyOrdered β] [NoMinOrder β] [NoMaxOrder β] [Nonempty β] (f : Order.PartialIso α β) (a : α) : ∃ (b : β), ∀ (p : α × β), p ∈ f.val → cmp p.fst a = cmp p.snd b
(p : ℕ) [p_Prime : Fact (Nat.Prime p)] {n : ℕ} {F : ℕ → ℚ} (hF : ∀ (i : ℕ), i < n → 0 < padic_val_rat p (F i)) (hn0 : (Finset.range n).sum (λ (i : ℕ), F i) ≠ 0) : 0 < padic_val_rat p ((Finset.range n).sum (λ (i : ℕ), F i))
{M : Type u_1} [Monoid M] {x : M} : monoid.closure {x} = Powers x
{α : Type u} {β : Type v} {γ : Type w} [Preorder α] [Preorder β] [Preorder γ] {f : α → β → γ} {s : Set α} {t : Set β} (h₀ : ∀ (b : β), Monotone (Function.swap f b)) (h₁ : ∀ (a : α), Monotone (f a)) : BddAbove s → BddAbove t → BddAbove (Set.image2 f s t)
{α : Type u_1} [DecidableEq α] [Fintype α] : Fintype.card (Sym2 α) = Fintype.card α * (Fintype.card α + 1) / 2
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {f : E → G} {C : ℝ} {s : Set E} {x y : E} {f' : E → (E →L[𝕜] G)} (hF : ∀ (x : E), x ∈ s → HasFderivWithinAt f (f' x) s x) (bound : ∀ (x : E), x ∈ s → ∥f' x∥ ≤ C) (hs : Convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) {X Y : C} (p : X = Y) : F.map_iso (Category_theory.eq_to_iso p) = Category_theory.eq_to_iso _
{α : Type u} [TopologicalSpace α] {ι : Type u_1} [CompactSpace α] {f : ι → Set α} (hF : LocallyFinite f) : {i : ι | (f i).nonempty}.finite
(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1
(p' : ℕ) (h : lucas_lehmer.lucas_lehmer_residue (p' + 2) = 0) : order_of (lucas_lehmer.ω_Unit (p' + 2)) = 2 ^ (p' + 2)
{R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [Ring R] [AddCommGroup M] [AddCommGroup M₂] [Module R M] [Module R M₂] (f : M ≃ₗ[R] M₂) (p : Submodule R M) : FiniteDimensional.finrank R ↥(Submodule.map ↑f p) = FiniteDimensional.finrank R ↥p
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) [CategoryTheory.Limits.HasLimits C] (i j : D.to_glue_data.J) (U : TopologicalSpace.Opens ↥((D.to_glue_data.U i).carrier)) : D.diagram_over_IsOpen_π U i ≫ D.ι_Inv_Appπ_Eq_Map U ≫ D.ι_Inv_App U ≫ D.diagram_over_IsOpen_π U j = D.diagram_over_IsOpen_π U j
{α : Type u_1} [DecidableEq α] [Fintype α] {𝒜 : Finset (Finset α)} {s : Finset α} : s ∈ 𝒜.up_shadow ↔ ∃ (t : Finset α) (H : t ∈ 𝒜), t ⊆ s ∧ t.card + 1 = s.card
{A : Type u_2} [NormedRing A] [NormedAlgebra ℂ A] [CompleteSpace A] [NormOneClass A] (a : A) : Filter.Tendsto (λ (n : ℕ), ↑∥a ^ n∥₊ ^ (1 / ↑n)) filter.at_Top (nhds (spectral_radius ℂ a))
{α : Type u_1} [PartialOrder α] [SuccOrder α] {a b : α} [NoMaxOrder α] : a ≠ b → Order.succ a ≠ Order.succ b
{K : Type u_1} {n : ℕ} {s : Seq (GeneralizedContinuedFraction.Pair K)} [DivisionRing K] : GeneralizedContinuedFraction.convergents'_aux s (n + 2) = GeneralizedContinuedFraction.convergents'_aux (generalized_continued_fraction.squash_Seq s n) (n + 1)
{J K : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.SmallCategory K] (F : J × K ⥤ Type v) [CategoryTheory.IsFiltered K] [Fintype J] : Function.Injective (CategoryTheory.Limits.colimit_Limit_to_Limit_Colimit F)
{R : Type v} [CommRing R] {n : ℕ} (A : Matrix (Fin n.succ) (Fin n.succ) R) : A.det = finset.univ.sum (λ (j : Fin n.succ), (-1) ^ ↑j * A 0 j * (A.minor Fin.succ ⇑(j.succ_above)).det)
{α : Type u_1} [Preorder α] [AddCommSemigroup α] [HasSub α] [HasOrderedSub α] {a b : α} : b - (b - a) ≤ a
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {a : E} (hF : HasStrictFderivAt f f' a) {c : Nnreal} (hc : Subsingleton E ∨ 0 < c) : ∃ (s : Set E) (H : s ∈ nhds a), ApproximatesLinearOn f f' s c
{ι : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : ι → M} [Semiring R] [AddCommMonoid M] [AddCommMonoid M'] [Module R M] [Module R M'] (hv : LinearIndependent R v) {f : M →ₗ[R] M'} (hF_inj : Disjoint (Submodule.span R (Set.Range v)) f.ker) : LinearIndependent R (⇑f ∘ v)
{β : Type u} {α : Type v} {γ : Type w} [CommMonoid β] {s : Finset γ} {t : Finset α} {f : γ → α → β} : (s.product t).prod (λ (x : γ × α), f x.fst x.snd) = t.prod (λ (y : α), s.prod (λ (x : γ), f x y))
{X : Type u} {α : Type v} [TopologicalSpace X] [LinearOrder α] [TopologicalSpace α] [OrderClosedTopology α] [PreconnectedSpace X] (a b : X) {f : X → α} (hF : Continuous f) : Set.Icc (f a) (f b) ⊆ Set.Range f
{K : Type u_1} [Field K] [Invertible 2] {a b c : K} (ha : a ≠ 0) {s : K} (h : discrim a b c = s * s) (x : K) : a * x * x + b * x + c = 0 ↔ x = (-b + s) / (2 * a) ∨ x = (-b - s) / (2 * a)
{α : Type u_1} {β : Type u_2} {p : α → β → Prop} {x₀ x₁ : Σ (a : α), Subtype_ (p a)} : x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁
{m : Type u} {n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix m n α) (B : Matrix n n α) [Invertible B] : (A.mul (⅟ B)).mul B = A
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {ι : Type u_5} [DecidableEq ι] [Fintype ι] {E : ι → Type u_2} [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] : IsBoundedLinearMap 𝕜 (λ (p : ContinuousMultilinearMap 𝕜 E F × ContinuousMultilinearMap 𝕜 E G), p.fst.prod p.snd)
{α : Type u₁} {X Y : CategoryTheory.Discrete α} (i : X ⟶ Y) : X.as = Y.as
{R : Type u} {S : Type v} [Ring R] [Ring S] [is_IsDomain S] (f : R →+* S) : f.ker.is_Prime
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R : CategoryTheory.Presieve X} {x : CategoryTheory.Presieve.FamilyOfElements P R} (t : x.compatible) : CategoryTheory.Presieve.FamilyOfElements.restrict _ x.sieve_extend = x
{α : Type u} {β : Type v} [PseudoMetricSpace α] {f : β → α} [TopologicalSpace β] (hF : Inducing f) {s : Set α} (hs : TopologicalSpace.IsSeparable s) : TopologicalSpace.IsSeparable (f ⁻¹' s)
{ι : Type u_1} {ι' : Type u_2} {R : Type u_5} {M : Type u_6} [CommSemiring R] [AddCommMonoid M] [Module R M] (b : Basis ι R M) (b' : Basis ι' R M) [DecidableEq ι] [Fintype ι'] : (b.to_Matrix ⇑b').mul (b'.to_Matrix ⇑b) = 1
{M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : MulOneClass M} {mN : MulOneClass N} [MonoidHomClass F M N] (f : F) {x : M} (hx : ∃ (y : M), x * y = 1) : ∃ (y : N), ⇑f x * y = 1
{α : Type u_3} [SemilatticeSup α] (a : α) : Filter.map Coe filter.at_Top = filter.at_Top
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) {X : C} {S T : CategoryTheory.Sieve X} (h : S ≤ T) (hT : J₁.is_IsClosed T) : J₁.close S ≤ T
{α : Type u_1} {ι : Type u_2} {ι' : Type u_3} [CompleteLattice α] {s : Set ι'} {g : ι' → Set ι} {f : ι → α} (hs : s.pairwise_Disjoint (λ (i' : ι'), ⨆ (i : ι) (H : i ∈ g i'), f i)) (hg : ∀ (i : ι'), i ∈ s → (g i).pairwise_Disjoint f) : (⋃ (i : ι') (H : i ∈ s), g i).pairwise_Disjoint f
{x y z : Pgame} (h₁ : x < y) (h₂ : y.lf z) : x.lf z
{R : Type u} {K : Type v} {L : Type z} {p : R} [CommRing R] [Field K] [Field L] [Algebra K L] [Algebra R L] [Algebra R K] [IsScalarTower R K L] [IsSeparable K L] [is_IsDomain R] [NormalizedGcdMonoid R] [IsFractionRing R K] [IsIntegrallyClosed R] {B : PowerBasis K L} (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} (hzint : IsIntegral R z) (hz : p • z ∈ Algebra.adjoin R {B.gen}) (hei : (minpoly R B.gen).is_eisenstein_at (Submodule.span R {p})) : z ∈ Algebra.adjoin R {B.gen}
{α : Type u_1} [Bornology α] {p : α → Prop} : Bornology.IsBounded {x : α | p x} → BoundedSpace (Subtype_ p)
{M₀ : Type u_1} [MulZeroOneClass M₀] : 0 ≠ 1 ∨ ∀ (a : M₀), a = 0
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) : s.monge_point ∈ affine_Span ℝ (Set.Range s.points)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : α → β} (de : DenseEmbedding e) [TopologicalSpace.SeparableSpace α] : TopologicalSpace.SeparableSpace β
{R : Type u_1} {E : Type u_2} [LinearOrderedField R] [AddCommGroup E] [Module R E] (t : Finset E) {w : E → R} (hw₀ : ∀ (i : E), i ∈ t → 0 ≤ w i) (hws : 0 < t.sum (λ (i : E), w i)) : t.center_mass w Id ∈ ⇑(Convex_hull R) ↑t
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [BaireSpace α] {S : Set β} {f : β → Set α} (ho : ∀ (s : β), s ∈ S → is_IsOpen (f s)) (hS : S.countable) (hD : ∀ (s : β), s ∈ S → Dense (f s)) : Dense (⋂ (s : β) (H : s ∈ S), f s)
{α : Type u} [TopologicalSpace α] [t2_Space α] {s : Set α} (hs : is_IsCompact s) : is_IsClosed s
(S : Type u_1) [Ring S] (a : ℕ) : ↑(a.desc_factorial 2) = ↑a * (↑a - 1)
{R : Type u_1} [CommRing R] : Ideal.IsJacobson R ↔ ∀ (P : Ideal R), P.is_Prime → P.jacobson = P
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] {A B C : Matrix n n α} (h : A.mul B = 1) (g : C.mul A = 1) : B = C
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : HasInner.inner x y = ∥x∥ * ∥y∥ ↔ ∥y∥ • x = ∥x∥ • y
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [SemiNormedGroup E] [SemiNormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →ₛₗ[σ₁₂] F) {C : ℝ} (h : ∀ (x : E), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_Continuous C h∥ ≤ Linear_order.max C 0
(a b : ℝ) (h : a < b) : (Polynomial_Functions UnitInterval).comap' (Continuous_map.comp_Right_AlgHom ℝ (icc_homeo_I a b h).symm.to_Continuous_Map) = Polynomial_Functions (Set.Icc a b)
{α : Type u} {β : Type v} [AddGroup α] [AddGroup β] {f : α → β} (hF : IsAddGroupHom f) {γ : Type u_1} [AddGroup γ] {g : β → γ} (hg : IsAddGroupHom g) : IsAddGroupHom (g ∘ f)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (s : AffineSubspace ℝ P) [Nonempty ↥s] [CompleteSpace ↥(s.direction)] (p : P) : ⇑(Orthogonal_projection s.direction) (p -ᵥ ↑(⇑(euclidean_geometry.orthogonal_projection s) p)) = 0
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι} (hF : TendstoUniformlyOn F f p s) : UniformCauchySeqOn F p s
{K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [DivisionRing K] {gp ppred Pred : GeneralizedContinuedFraction.Pair K} (Succ_nth_s_Eq : g.s.nth (n + 1) = Option.some gp) (nth_conts_Eq : g.continuants n = ppred) (Succ_nth_conts_Eq : g.continuants (n + 1) = Pred) : g.continuants (n + 2) = {a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b}
{α : Type uu} (r : α → α → Prop) [DecidableRel r] (a : α) (l : List α) : list.ordered_Insert r a l = List.take_while (λ (b : α), ¬r a b) l ++ a :: List.drop_while (λ (b : α), ¬r a b) l
{α : Type u_1} [CircularPreorder α] {a b c d : α} (hbc : HasSbtw.Sbtw a b c) (hcd : HasSbtw.Sbtw a c d) : HasSbtw.Sbtw a b d
{C : Type u} [CategoryTheory.Category C] {X : Top} (F : Top.Presheaf C X) : CategoryTheory.Presheaf.IsSheaf (opens.grothendieck_topology ↥X) F ↔ F.is_sheaf_Opens_LE_cover
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [SemiNormedGroup F'] {f : α → E} {g' : α → F'} {l : Filter α} : f =O[l] g' → (f =O[l] λ (x : α), -g' x)
{M : Type u_3} {N : Type u_4} [has_One M] [has_One N] (f : OneHom M N) {x y : M} (h : x = y) : ⇑f x = ⇑f y
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F ≠ 2) (a : F) : ↑({x : F | x ^ 2 = a}.to_finset.card) = char.quadratic_Char F a + 1
{𝕂 : Type u_1} {𝔸 : Type u_2} [is_R_or_C 𝕂] [NormedRing 𝔸] [NormedAlgebra 𝕂 𝔸] [CompleteSpace 𝔸] : HasFderivAt (Exp 𝕂) 1 0
(A : Type u) {B : Type v} {ι : Type w} [CommRing A] [CommRing B] [Algebra A B] [Fintype ι] [is_IsDomain A] {b : ι → B} (hli : ¬LinearIndependent A b) : Algebra.discr A b = 0
{α : sort u} {β : sort v} [DecidableEq α] {v : α → β} {i j : α} (hv : v i = v j) (k : α) : v (⇑(equiv.swap i j) k) = v k
{α : Type u_1} [EmetricSpace α] {K : Nnreal} {f : α → α} (hF : ContractingWith K f) {s : Set α} (hsc : IsComplete s) (hsf : Set.MapsTo f s s) (hfs : ContractingWith K (Set.MapsTo.restrict f s s hsf)) {x : α} (hxs : x ∈ s) (hx : HasEdist.edist x (f x) ≠ ⊤) {t : Set α} (htc : IsComplete t) (htf : Set.MapsTo f t t) (hft : ContractingWith K (Set.MapsTo.restrict f t t htf)) {y : α} (hyt : y ∈ t) (hy : HasEdist.edist y (f y) ≠ ⊤) (hxy : HasEdist.edist x y ≠ ⊤) : contracting_with.efixed_point' f hsc hsf hfs x hxs hx = contracting_with.efixed_point' f htc htf hft y hyt hy
(𝕜 : Type u_1) (E : Type u_2) [OrderedSemiring 𝕜] [OrderedAddCommGroup E] [Module 𝕜 E] [OrderedSmul 𝕜 E] : (Convex_cone.positive_cone 𝕜 E).pointed
(N i : ℕ) : polynomial.rev_at_fun N i = ⇑(polynomial.rev_at N) i
{α : Type u_1} {β : Type u_2} [DecidableEq β] {f : α →. β} [Π (x : α), Decidable (f x).dom] {s : Finset α} : Finset.pimage f s = Finset.image (λ (x : {x // x ∈ Finset.filter (λ (x : α), (f x).dom) s}), (f ↑x).get _) (Finset.filter (λ (x : α), (f x).dom) s).attach
{n : ℕ} {α : Type u_1} (l : List α) (c : Composition n) : (l.split_wrt_Composition c).length = c.length
{α : Type u_1} {ι : Type u_4} [CompleteLattice α] (s : ι → α) : (⨆ (i : ι), s i) = ⨆ (t : Finset ι) (i : ι) (H : i ∈ t), s i
{β : Type u} {γ : Type w} [NonAssocSemiring β] [NonAssocSemiring γ] (f : β →+* γ) (l : List β) : ⇑f l.sum = (List.map ⇑f l).sum
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} [Fintype ι] (p : ι → P) : AffineIndependent k p ↔ ∀ (w : ι → k), finset.univ.sum (λ (i : ι), w i) = 0 → ⇑(finset.univ.weighted_vsub p) w = 0 → ∀ (i : ι), w i = 0
{L : FirstOrder.Language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] {Q : Type u_2} [L.Structure Q] (f : L.embedding M N) (g : L.embedding N P) (h : L.embedding P Q) : (h.comp g).comp f = h.comp (g.comp f)
{α : Type u_1} {β : Type u_2} {M : Type u_5} {R : Type u_11} [AddMonoid M] [Monoid R] [DistribMulAction R M] {f : α → β} (hF : Function.Injective f) (r : R) (v : β →₀ M) : finsupp.comap_IsDomain f (r • v) _ = r • finsupp.comap_IsDomain f v _
{α : Type u} [Group α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] {a b c : α} : a * b < c → b < a⁻¹ * c
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {x : E} {n : WithTop ℕ} {p : E → FormalMultilinearSeries 𝕜 E F} (h : HasFtaylorSeriesUpToOn n f p s) (hn : 1 ≤ n) (hx : s ∈ nhds x) : HasFderivAt f (⇑(Continuous_multilinear_Curry_Fin1 𝕜 E F) (p x 1)) x
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R : CategoryTheory.Presieve X} (t : CategoryTheory.Presieve.IsSeparatedFor P R) : (∀ (x : CategoryTheory.Presieve.FamilyOfElements P R), x.compatible → (∃ (t : P.obj (Opposite.op X)), x.is_amalgamation t)) → CategoryTheory.Presieve.IsSheafFor P R
{L : FirstOrder.Language} (K : Set (CategoryTheory.Bundled L.Structure)) {M : Type w} [L.Structure M] [L.countable_Functions] (h : FirstOrder.Language.IsFraisseLimit K M) : FirstOrder.Language.IsFraisse K
{α : Type u_1} (n : ℕ) (x : α) : Function.IsPeriodicPt Id n x
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
{𝕜 : Type u_1} {E : Type u_2} [SemiNormedRing 𝕜] [HasScalar 𝕜 E] {s t : Set E} (ht : Balanced 𝕜 t) (h : s ⊆ t) : BalancedHull 𝕜 s ⊆ t
{R : Type u} [Ring R] {ι : Type v} [decι : DecidableEq ι] {M : Type u_1} [AddCommGroup M] [Module R M] {A : ι → Submodule R M} (hi : CompleteLattice.Independent A) (hs : supr A = ⊤) : DirectSum.IsInternal A
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι} [TopologicalSpace α] (h : TendstoLocallyUniformlyOn F f p s) (hc : ∀ᶠ (n : ι) in p, ContinuousOn (F n) s) [p.ne_IsBot] : ContinuousOn f s
(f : ↥(MeasureTheory.lp ℂ 2 haar_Circle)) (i : ℤ) : ⇑(⇑(fourier_series.repr) f) i = ∫ (t : ↥Circle), ↑t ^ -i * ⇑f t ∂haar_Circle
{R : Type u_1} [LinearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_3} [DecidableEq ι] [Fintype ι] (e : Basis ι R M) (x : Orientation R M ι) : x = e.orientation ∨ x = -e.orientation
{α : Type u} [PseudoMetricSpace α] : UniformContinuous (λ (p : UniformSpace.Completion α × UniformSpace.Completion α), HasDist.dist p.fst p.snd)
{X Y : Top} {f g : C(↥X, ↥Y)} (H : f.homotopy g) {x₀ x₁ : ↥X} (p : fundamental_groupoid.from_Top x₀ ⟶ fundamental_groupoid.from_Top x₁) : (fundamental_groupoid.fundamental_groupoid_functor.map f).map p = ContinuousMap.Homotopy.hcast _ ≫ (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_Map).map (Continuous_map.homotopy.prod_to_Prod_Top_I (𝟙 {down := 0}) p) ≫ ContinuousMap.Homotopy.hcast _
{m : Type u_1} [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (M N P : Matrix m m R) : (M.mul (N.mul P)).det = (N.mul (M.mul P)).det
{M : Type u_1} [AddCommMonoid M] (S : AddSubmonoid M) (m : Multiset M) (hm : ∀ (a : M), a ∈ m → a ∈ S) : m.sum ∈ S
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] (v : E) : Orthogonal_projection_fn K v ∈ K
 : Irrational golden_Conj
{R : Type u1} [CommSemiring R] {M : Type u2} [AddCommMonoid M] [Module R M] {C : ExteriorAlgebra R M → Prop} (h_grade0 : ∀ (r : R), C (⇑(Algebra_Map R (ExteriorAlgebra R M)) r)) (h_grade1 : ∀ (x : M), C (⇑(ExteriorAlgebraι R) x)) (h_Mul : ∀ (a b : ExteriorAlgebra R M), C a → C b → C (a * b)) (h_Add : ∀ (a b : ExteriorAlgebra R M), C a → C b → C (a + b)) (a : ExteriorAlgebra R M) : C a
{ι : Type u_1} {M : Type u_4} {N : Type u_5} [AddCommMonoid M] [OrderedAddCommMonoid N] (f : M → N) (p : M → Prop) (h_Mul : ∀ (x y : M), p x → p y → f (x + y) ≤ f x + f y) (hp_Mul : ∀ (x y : M), p x → p y → p (x + y)) (g : ι → M) (s : Finset ι) (hs_Nonempty : s.nonempty) (hs : ∀ (i : ι), i ∈ s → p (g i)) : f (s.sum (λ (i : ι), g i)) ≤ s.sum (λ (i : ι), f (g i))
{a b : ℕ} (hab : a.coprime b) : a.factors.disjoint b.factors
(G : Type u_1) [AddCommGroup G] : Add_monoid.is_torsion_free (G ⧸ AddIsTorsion G)
(ι : Type u_3) : WellFounded has_lt.lt
{K : Type u} {V V₁ V₂ V₃ : Type v} [Field K] [AddCommGroup V] [Module K V] [AddCommGroup V₁] [Module K V₁] [AddCommGroup V₂] [Module K V₂] [AddCommGroup V₃] [Module K V₃] (db : V₂ →ₗ[K] V) (eb : V₃ →ₗ[K] V) (cd : V₁ →ₗ[K] V₂) (ce : V₁ →ₗ[K] V₃) (hde : ⊤ ≤ db.range ⊔ eb.range) (hgd : cd.ker = ⊥) (Eq : db.comp cd = eb.comp ce) (Eq₂ : ∀ (d : V₂) (e : V₃), ⇑db d = ⇑eb e → (∃ (c : V₁), ⇑cd c = d ∧ ⇑ce c = e)) : Module.rank K V + Module.rank K V₁ = Module.rank K V₂ + Module.rank K V₃
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : E → ℝ} {a : E} {s : Set E} (h : is_IsLocalMinOn f s a) {y : E} (hy : y ∈ PosTangentConeAt s a) : 0 ≤ ⇑(fderiv_within ℝ f s a) y
{C : Type v} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] {X Y : C} {f g : X ⟶ Y} (h : f = g) (x : ↥X) : ⇑f x = ⇑g x
{ι : Type u} (s : Finset ι) (w z : ι → Ennreal) (hw' : s.sum (λ (i : ι), w i) = 1) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), w i * z i) ^ p ≤ s.sum (λ (i : ι), w i * z i ^ p)
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂] [Module K V₂] [FiniteDimensional K V] [FiniteDimensional K V₂] : Nonempty (V ≃ₗ[K] V₂) ↔ FiniteDimensional.finrank K V = FiniteDimensional.finrank K V₂
{a b : ℤ} (ha : a ≠ 0) : IsLeast {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b)
{α : Type u} {a b : α} [MulOneClass α] [HasZero α] [Preorder α] [ZeroLt.MulPosStrictMono α] (ha : 1 < a) (hb : 1 ≤ b) (b0 : 0 < b) : 1 < a * b
(X : Type u) (Y : Type v) [MetricSpace X] [CompactSpace X] [Nonempty X] [MetricSpace Y] [CompactSpace Y] [Nonempty Y] {f : Cb X Y} (h : f ∈ candidates_b X Y) : metric.Hausdorff_dist (Set.Range (Gromov_Hausdorff.optimal_GH_injl X Y)) (Set.Range (Gromov_Hausdorff.optimal_GH_injr X Y)) ≤ GromovHausdorff.hD f
{α : Type u_1} {r : α → α → Prop} [IsRefl α r] [IsAntisymm α r] {a b : α} : AntisymmRel r a b → a = b
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [CompleteSpace E] [CompleteSpace F] (A : E →L[𝕜] F) (B : F →L[𝕜] E) : A = ⇑ContinuousLinearMap.adjoint B ↔ ∀ (x : E) (y : F), HasInner.inner (⇑A x) y = HasInner.inner x (⇑B y)
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [SemiNormedGroup F'] {c : ℝ} {f : α → E} {g' : α → F'} {l : Filter α} : asymptotics.is_O_with c l f (λ (x : α), ∥g' x∥) → asymptotics.is_O_with c l f g'
{M : Type u_3} {N : Type u_4} [Monoid M] [Monoid N] (f : M →* N) (l : List M) : ⇑f l.prod = (List.map ⇑f l).prod
{n : ℕ} {a b : Fin n} : ↑a ≤ ↑b ↔ a ≤ b
{α : Type u_1} [PartialOrder α] [OrderBot α] {a : α} : IsAtom a → ⊥ ⋖ a
{α : Type u_1} [Preorder α] [PredOrder α] {a b : α} [NoMinOrder α] : a < b → Order.pred a < Order.pred b
{K : Type u_1} [LinearOrderedField K] [FloorRing K] {v : K} : (GeneralizedContinuedFraction.of v).h = ↑⌊v⌋
{p : ℕ} [Fact (Nat.Prime p)] {f : CauSeq ℚ (padic_norm p)} (hF : ¬f ≈ 0) : ∃ (N : ℕ), ∀ (m n : ℕ), N ≤ m → N ≤ n → padic_norm p (⇑f n) = padic_norm p (⇑f m)
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (h_Int : Algebra.IsIntegral K L) : IsTotallyDisconnected Set.Univ
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {K : J ⥤ C} {c d : CategoryTheory.Limits.Cocone K} (f : c ⟶ d) [i : CategoryTheory.IsIso f.hom] : CategoryTheory.IsIso f
{G : Type u} [AddMonoid G] : IsOfFinAddOrder 0
{R : Type u_1} {a b : R} [AddSemigroup R] (lra : IsAddLeftRegular a) (lrb : IsAddLeftRegular b) : IsAddLeftRegular (a + b)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) {r : ℝ} (hr : r ≠ 0) : 2 • hb.oangle (r • x) y = 2 • hb.oangle x y
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : Set P} (ho : EuclideanGeometry.OrthocentricSystem s) {t : Affine.Triangle ℝ P} (ht : Set.Range t.points ⊆ s) : s = HasInsert.insert t.orthocenter (Set.Range t.points)
{G : Type u_10} {H : Type u_11} [AddGroup G] [SubtractionMonoid H] (h : G ≃+ H) (x y : G) : ⇑h (x - y) = ⇑h x - ⇑h y
{n : Type u} [DecidableEq n] [Fintype n] {α : Type v} [CommRing α] (A : Matrix n n α) [Nontrivial n] : A.adjugate.adjugate = A.det ^ (Fintype.card n - 2) • A
{α : Type u_1} [HasMul α] [HasLt α] [ContravariantClass α α has_mul.mul has_lt.lt] {a b c : α} (bc : a * b < a * c) : b < c
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {n : WithTop ℕ} : ContDiff 𝕜 n f ↔ (∀ (m : ℕ), ↑m ≤ n → Continuous (iterated_deriv m f)) ∧ ∀ (m : ℕ), ↑m < n → Differentiable 𝕜 (iterated_deriv m f)
{R : Type u} [Semiring R] (r : R) : Polynomial.x * ⇑Polynomial.c r = ⇑Polynomial.c r * Polynomial.x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasEqualizers C] [CategoryTheory.Limits.HasImages C] {Y Z : C} (f : Y ⟶ Z) (P : CategoryTheory.ProjectiveResolution Y) (Q : CategoryTheory.ProjectiveResolution Z) : CategoryTheory.ProjectiveResolution.lift f P Q ≫ Q.π = P.π ≫ (chain_complex.single₀ C).map f
{α : Type u_1} {r s : Setoid α} : r ⊔ s = EqvGen.setoid (r.rel ⊔ s.rel)
{E : Type u_3} {F : Type u_4} [SemiNormedGroup E] [SemiNormedGroup F] {f : E → F} {C : Nnreal} : LipschitzWith C f → ∀ (x y : E), ∥f x - f y∥ ≤ ↑C * ∥x - y∥
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {V : Type u_14} [NormedGroup V] [NormedSpace 𝕜 V] : Smooth ((model_with_corners_self 𝕜 𝕜).prod (model_with_corners_self 𝕜 V)) (model_with_corners_self 𝕜 V) (λ (p : 𝕜 × V), p.fst • p.snd)
{p : Ordinal → Prop} (i : Ordinal) (h : ∀ (j : Ordinal), (∀ (k : Ordinal), k < j → p k) → p j) : p i
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : ∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * HasInner.inner x y + ∥y∥ ^ 2
 : Function.Injective Real.sinh
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {A : Type u₃} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (K : CategoryTheory.GrothendieckTopology D) {L : CategoryTheory.GrothendieckTopology A} {F : C ⥤ D} (hF : CategoryTheory.CoverPreserving J K F) {G : D ⥤ A} (hG : CategoryTheory.CoverPreserving K L G) : CategoryTheory.CoverPreserving J L (F ⋙ G)
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCancelCommMonoid E] [OrderedAddCommMonoid β] [Module 𝕜 E] [HasScalar 𝕜 β] {s : Set E} {f : E → β} (hF : StrictConvexOn 𝕜 s f) (c : E) : StrictConvexOn 𝕜 ((λ (z : E), c + z) ⁻¹' s) (f ∘ λ (z : E), c + z)
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a : α} : 0 < -a ↔ a < 0
{M : Type u_1} [Group M] (c : Con M) {w x : M} : ⇑c w x → ⇑c w⁻¹ x⁻¹
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Q : QuadraticForm R M} (l : List M) : ⇑CliffordAlgebra.involute (List.map ⇑(CliffordAlgebraι Q) l).prod = (-1) ^ l.length • (List.map ⇑(CliffordAlgebraι Q) l).prod
{α : Type u} [TopologicalSpace α] {s : Set α} : IsPreirreducible s ↔ ∀ (z₁ z₂ : Set α), is_IsClosed z₁ → is_IsClosed z₂ → s ⊆ z₁ ∪ z₂ → s ⊆ z₁ ∨ s ⊆ z₂
{R : Type u_1} {M : Type u_9} [Semiring R] [AddCommMonoid M] [Module R M] (p : Submodule R M) : Submodule.map p.subtype ⊤ = p
(α : sort u_1) [s : Setoid α] : Function.Surjective Quotient.mk
{M : Type u_1} [AddZeroClass M] {N : Type u_2} [AddZeroClass N] (f : M →+ N) (hF : Function.Surjective ⇑f) : f.mrange = ⊤
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f : ℂ → E} {s : Set ℂ} {c : ℂ} (hc : s ∈ nhds c) (hD : DifferentiableOn ℂ f (s  {c})) (ho : (λ (z : ℂ), f z - f c) =o[nhds_within c {c}ᶜ] λ (z : ℂ), (z - c)⁻¹) : DifferentiableOn ℂ (Function.update f c (lim (nhds_within c {c}ᶜ) f)) s
{n : Type u} [DecidableEq n] [Fintype n] {α : Type v} [CommRing α] (A : Matrix n n α) (h : Fintype.card n ≠ 1) : A.adjugate.adjugate = A.det ^ (Fintype.card n - 2) • A
{ι : Type u_1} {R : Type u_2} {N : Type u_5} [decι : DecidableEq ι] [Ring R] [AddCommGroup N] [Module R N] (p : ι → Submodule R N) : CompleteLattice.Independent p ↔ Function.Injective ⇑(⇑(Dfinsupp.lsum ℕ) (λ (i : ι), (p i).subtype))
{P : Type u_1} [Preorder P] [OrderTop P] {F : Order.Pfilter P} : ⊤ ∈ F
{G : Type u_1} [Group G] {s t : Set G} (ht : IsNormalSubgroup t) (h : s ⊆ t) : group.normal_Closure s ⊆ t
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {p : E → FormalMultilinearSeries 𝕜 E F} {n : ℕ} : HasFtaylorSeriesUpTo ↑(n + 1) f p ↔ (∀ (x : E), (p x 0).uncurry0 = f x) ∧ (∀ (x : E), HasFderivAt (λ (y : E), p y 0) (p x 1).curry_Left x) ∧ HasFtaylorSeriesUpTo ↑n (λ (x : E), ⇑(Continuous_multilinear_Curry_Fin1 𝕜 E F) (p x 1)) (λ (x : E), (p x).shift)
{α : Type u_1} [LinearOrderedSemiring α] : Subsingleton (FloorSemiring α)
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {c : AddCon M} {f : M →+ P} (H : c ≤ AddCon.ker f) (g : c.quotient →+ P) (Hg : g.comp c.mk' = f) : g = c.lift f H
{r : Nnreal} (hr : r < 1) : HasSum (λ (n : ℕ), r ^ n) (1 - r)⁻¹
{ι : Type u_1} {R : Type u_2} [CommSemiring R] [LinearOrder ι] (s : Finset ι) (f g : ι → R) : s.prod (λ (i : ι), f i + g i) = s.prod (λ (i : ι), f i) + s.sum (λ (i : ι), g i * (Finset.filter (λ (_x : ι), _x < i) s).prod (λ (j : ι), f j + g j) * (Finset.filter (λ (j : ι), i < j) s).prod (λ (j : ι), f j))
{α : Type u} [PseudoEmetricSpace α] : (∀ (u : ℕ → α), CauchySeq u → (∃ (a : α), Filter.Tendsto u filter.at_Top (nhds a))) → CompleteSpace α
{α : Type u} [PseudoEmetricSpace α] {δ₁ δ₂ : ℝ} (hle : δ₁ ≤ δ₂) (E : Set α) : Metric.Thickening δ₁ E ⊆ Metric.Thickening δ₂ E
{n : ℕ} (hpos : 0 < n) {p : ℕ} [hprime : Fact (Nat.Prime p)] {a : ℕ} (hroot : (Polynomial.cyclotomic n (Zmod p)).is_root (⇑(nat.cast_RingHom (Zmod p)) a)) : a.coprime p
{α : Type u_1} {n : Type u_3} {A : Matrix n n α} : (∀ (i j : n), A j i = A i j) → A.is_Symm
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {v : ℝ → E → E} {s : ℝ → Set E} {K : ℝ} (hv : ∀ (t : ℝ) (x : E), x ∈ s t → ∀ (y : E), y ∈ s t → HasDist.dist (v t x) (v t y) ≤ K * HasDist.dist x y) {f g : ℝ → E} {a b : ℝ} (hF : ContinuousOn f (Set.Icc a b)) (hF' : ∀ (t : ℝ), t ∈ Set.Ico a b → HasDerivWithinAt f (v t (f t)) (Set.Ici t) t) (hfs : ∀ (t : ℝ), t ∈ Set.Ico a b → f t ∈ s t) (hg : ContinuousOn g (Set.Icc a b)) (hg' : ∀ (t : ℝ), t ∈ Set.Ico a b → HasDerivWithinAt g (v t (g t)) (Set.Ici t) t) (hgs : ∀ (t : ℝ), t ∈ Set.Ico a b → g t ∈ s t) (ha : f a = g a) (t : ℝ) (H : t ∈ Set.Icc a b) : f t = g t
{C : Type u} [CategoryTheory.Category C] {ι : Type u_1} {s : ι → C} [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasFiniteBiproducts C] [∀ (i : ι), InvariantBasisNumber (CategoryTheory.End (s i))] (o : CategoryTheory.HomOrthogonal s) {α β : Type v} [Fintype α] [Fintype β] {f : α → ι} {g : β → ι} (i : (⨁ λ (a : α), s (f a)) ≅ ⨁ λ (b : β), s (g b)) : ∃ (e : α ≃ β), ∀ (a : α), g (⇑e a) = f a
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R₁ R₂ : CategoryTheory.Presieve X} (h : R₁ ≤ R₂) {x : CategoryTheory.Presieve.FamilyOfElements P R₂} : x.compatible → (CategoryTheory.Presieve.FamilyOfElements.restrict h x).compatible
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {m : α → β → γ} {f : Filter α} {g : Filter β} {n : γ → δ} {m' : α' → β → δ} {n' : α → α'} (h_Distrib : ∀ (a : α) (b : β), n (m a b) = m' (n' a) b) : Filter.map n (Filter.map₂ m f g) = Filter.map₂ m' (Filter.map n' f) g
(n : ℕ) : (Finset.range n).sum (λ (i : ℕ), i) * 2 = n * (n - 1)
{ι : Type u_1} {M : Type u_4} {N : Type u_5} [CommMonoid M] [OrderedCommMonoid N] (f : M → N) (h_Mul : ∀ (x y : M), f (x * y) ≤ f x * f y) {s : Finset ι} (hs : s.nonempty) (g : ι → M) : f (s.prod (λ (i : ι), g i)) ≤ s.prod (λ (i : ι), f (g i))
{α : Type u} [HasSsubset α] [IsTrans α HasSsubset.Ssubset] {a b c : α} : a ⊂ b → b ⊂ c → a ⊂ c
(p : ℝ × ℝ) (hp : p.fst < 0) : HasStrictFderivAt (λ (x : ℝ × ℝ), x.fst ^ x.snd) ((p.snd * p.fst ^ (p.snd - 1)) • ContinuousLinearMap.fst ℝ ℝ ℝ + (p.fst ^ p.snd * Real.log p.fst - Real.exp (Real.log p.fst * p.snd) * Real.sin (p.snd * Real.pi) * Real.pi) • ContinuousLinearMap.snd ℝ ℝ ℝ) p
{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] : (∀ (f : ℕ →o Submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ IsNoetherian R M
{S : Type u_1} [HasMul S] (a : S) : Commute a a
{C : Type u₁} [CategoryTheory.Category C] {X Y Z : C} (p : X = Y) (q : Y ⟶ Z) : _.mpr q = Category_theory.eq_to_hom p ≫ q
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a : α} : -a < 0 ↔ 0 < a
{X : Type u_1} [TopologicalSpace X] [NoncompactSpace X] : DenseRange Coe
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [LinearOrderedField 𝕜] [AddCommGroup E] [OrderedAddCommGroup β] [Module 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f : E → β} {t : Finset ι} {w : ι → 𝕜} {p : ι → E} (hF : ConvexOn 𝕜 s f) (h₀ : ∀ (i : ι), i ∈ t → 0 ≤ w i) (h₁ : 0 < t.sum (λ (i : ι), w i)) (hmem : ∀ (i : ι), i ∈ t → p i ∈ s) : f (t.center_mass w p) ≤ t.center_mass w (f ∘ p)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) : hb.oangle (⇑(hb.conj_lie) x) (⇑(hb.conj_lie) y) = -hb.oangle x y
{K : Type u_1} [LinearOrderedField K] [FloorRing K] {v : K} {n : ℕ} {ifp_n : GeneralizedContinuedFraction.IntFractPair K} (Stream_nth_Eq : GeneralizedContinuedFraction.IntFractPair.stream v n = Option.some ifp_n) (nth_fr_NeZero : ifp_n.fr ≠ 0) : (GeneralizedContinuedFraction.of v).s.nth n = Option.some {a := 1, b := ↑((GeneralizedContinuedFraction.IntFractPair.of (ifp_n.fr)⁻¹).b)}
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (t : Affine.Triangle ℝ P) {i₁ : Fin 3} : t.orthocenter ∈ Affine.Simplex.altitude t i₁
{α : Type u} [Semigroup α] [HasDistribNeg α] (a b : α) : a ∣ -b ↔ a ∣ b
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : EuclideanGeometry.angle p1 p2 p3 = Real.pi) : EuclideanGeometry.angle p2 p1 p3 = 0
{E : Type u_2} [AddCommGroup E] [Module ℝ E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousSmul ℝ E] : PathConnectedSpace E
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0
{F : Type u_2} [NormedGroup F] [NormedSpace ℝ F] {x y : F} (hx : x ≠ 0) (hy : y ≠ 0) : SameRay ℝ x y ↔ ∥x∥⁻¹ • x = ∥y∥⁻¹ • y
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y z : M} (hxy : SameRay R x y) (hyz : SameRay R y z) (hy : y = 0 → x = 0 ∨ z = 0) : SameRay R x z
{𝕜 : Type u} [hnorm : NondiscreteNormedField 𝕜] {t : TopologicalSpace 𝕜} (h₁ : TopologicalAddGroup 𝕜) (h₂ : HasContinuousSmul 𝕜 𝕜) (h₃ : t2_Space 𝕜) : t = uniform_space.to_TopologicalSpace
{α : Type u_1} [CompleteLattice α] {p q : Prop} {s : p → q → α} : (⨅ (h₁ : p) (h₂ : q), s h₁ h₂) = ⨅ (h : p ∧ q), s _ _
{β : Type u} {γ : Type w} [Semiring β] [Semiring γ] (f : β →+* γ) (l : List β) : ⇑f l.prod = (List.map ⇑f l).prod
{M : Type u_1} [AddGroup M] (c : AddCon M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w - y) (x - z)
{R : Type u} [Semiring R] {P : Polynomial R → Prop} (p : Polynomial R) (h0 : 0 < p.degree) (hC : ∀ {a : R}, a ≠ 0 → P (⇑Polynomial.c a * Polynomial.x)) (hX : ∀ {p : Polynomial R}, 0 < p.degree → P p → P (p * Polynomial.x)) (hAdd : ∀ {p : Polynomial R} {a : R}, 0 < p.degree → P p → P (p + ⇑Polynomial.c a)) : P p
{α : Type u} (s : Seq α) {m n : ℕ} (m_LE_n : m ≤ n) (TerminatedAt_m : s.terminated_at m) : s.terminated_at n
{k n : ℕ} (s : Finset ℕ) (hs : AddSalemSpencer ↑s) (hsn : ∀ (x : ℕ), x ∈ s → x < n) (hsk : s.card = k) : k ≤ ⇑roth_number_Nat n
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : α → β} {s : Set α} : StrictAntiOn f s → StrictMonoOn (f ∘ ⇑order_dual.of_dual) s
{α : Type u_1} {β : Type u_2} [Infinite α] [Fintype β] (f : α → β) : ∃ (y : β), Infinite ↥(f ⁻¹' {y})
{α : Type u_3} (f : Filter α) [f.is_countably_generated] [f.ne_IsBot] : ∃ (x : ℕ → α), Filter.Tendsto x filter.at_Top f
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] [t2_Space α] {s t : Set β} {f g : β → α} (h : Set.EqOn f g s) (hF : ContinuousOn f t) (hg : ContinuousOn g t) (hst : s ⊆ t) (hts : t ⊆ Closure s) : Set.EqOn f g t
{α : Type u_1} [HasLe α] {a : αᵒᵈ} : IsMin a → IsMax (⇑order_dual.of_dual a)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : LocalHomeomorph α β) {b : β} (hb : b ∈ e.to_local_equiv.target) {f : β → E} {g : β → F} : f =o[nhds b] g ↔ (f ∘ ⇑e) =o[nhds (⇑(e.symm) b)] (g ∘ ⇑e)
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [SemiNormedGroup E'] [SemiNormedGroup F'] {c : ℝ} {f' : α → E'} {g' : α → F'} {l : Filter α} : asymptotics.is_O_with c l f' g' → asymptotics.is_O_with c l (λ (x : α), ∥f' x∥) (λ (x : α), ∥g' x∥)
{α : Type v} {S : Type w} (e : α ≃ S) : Small α
{G : Type w} [TopologicalSpace G] [has_Inv G] [HasMul G] [HasContinuousMul G] [HasContinuousInv G] (h : G) : Continuous (λ (g : G), g * h * g⁻¹)
{α : Type u} [Group α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] [CovariantClass α α (Function.swap has_mul.mul) has_lt.lt] {a b : α} : a⁻¹ < b⁻¹ → b < a
{β : Type u} {α : Type v} {γ : Type w} [AddCommMonoid β] {s : Finset γ} {t : Finset α} {f : γ → α → β} : (s.product t).sum (λ (x : γ × α), f x.fst x.snd) = s.sum (λ (x : γ), t.sum (λ (y : α), f x y))
{n : ℕ} {E : Type u_1} [NormedGroup E] {f g : (Fin n → ℂ) → E} {c : Fin n → ℂ} {R : Fin n → ℝ} (hF : TorusIntegrable f c R) (hg : TorusIntegrable g c R) : TorusIntegrable (f + g) c R
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] {f : E → F} (hF : Differentiable ℂ f) (hb : Metric.Bounded (Set.Range f)) : ∃ (c : F), f = Function.const E c
{F : Type} [CommSemiring F] {q : ℕ} {f : Polynomial F} (hF : Polynomial.HasSeparableContraction q f) : hf.degree ∣ f.nat_degree
(α : Type u) (β : Type v) [Group α] [MulAction α β] [Fintype α] [Π (a : α), Fintype ↥(MulAction.FixedBy α β a)] [Fintype (Quotient (MulAction.Orbit_Rel α β))] : finset.univ.sum (λ (a : α), Fintype.card ↥(MulAction.FixedBy α β a)) = Fintype.card (Quotient (MulAction.Orbit_Rel α β)) * Fintype.card α
{m : Type u} {n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] [Fintype m] [DecidableEq m] (A : Matrix m n α) (B : Matrix n m α) : (1 + A.mul B).det = (1 + B.mul A).det
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D ⥤ C} [CategoryTheory.Reflective i] {A : C} {B : D} (f : i.obj ((CategoryTheory.IsLeftAdjoint i).obj A) ⟶ i.obj B) : ⇑((Category_theory.unit_Comp_partial_Bijective_aux A B).symm) f = (Category_theory.adjunction.of_Right_Adjoint i).unit.app A ≫ f
{α : Type u} {β : Type v} [TopologicalSpace α] [PseudoMetricSpace β] {f g : BoundedContinuousFunction α β} [IsEmpty α] : HasDist.dist f g = 0
(X : AlgebraicGeometry.LocallyRingedSpace (r : ↥(AlgebraicGeometry.LocallyRingedSpaceΓ.obj (Opposite.op X))) (f : (algebraic_geometry.Spec.structure_sheaf ↥(AlgebraicGeometry.LocallyRingedSpaceΓ.obj (Opposite.op X))).val.obj (Opposite.op (Prime_spectrum.basic_IsOpen r)) ⟶ X.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (Opposite.op (X.to_Γ_spec_Map_basic_IsOpen r))) : algebraic_geometry.structure_sheaf.to_IsOpen ↥(AlgebraicGeometry.LocallyRingedSpaceΓ.obj (Opposite.op X)) (Prime_spectrum.basic_IsOpen r) ≫ f = X.to_toΓ_spec_Map_basic_IsOpen r ↔ f = X.to_Γ_spec_c_App r
{α : Type u} [UniformSpace α] {f : Filter α} {x : α} (adhs : ∀ (s : Set (α × α)), s ∈ Uniformity α → (∃ (t : Set α) (H : t ∈ f), t ×ˢ t ⊆ s ∧ ∃ (y : α), (x, y) ∈ s ∧ y ∈ t)) : f ≤ nhds x
{α : Type u} {β : Type v} [PseudoEmetricSpace α] [PseudoEmetricSpace β] {f : α → β} {g : β → α} (h : Isometry f) (hg : Function.RightInverse g f) : Isometry g
(p : ℕ) [Fact (Nat.Prime p)] (k : Type u_1) [Field k] [IsAlgClosed k] [Char_p k p] (V : Type u_2) [AddCommGroup V] [WittVector.Isocrystal p k V] (h_dim : FiniteDimensional.finrank (FractionRing (WittVector p k)) V = 1) : ∃ (m : ℤ), Nonempty (WittVector.IsocrystalEquiv p k (WittVector.StandardOneDimIsocrystal p k m) V)
{α : Type u} [AddCommGroup α] [HasLe α] [CovariantClass α α has_add.add has_le.le] {a b c : α} : b ≤ c - a → a + b ≤ c
(n : ℕ) : finset.univ.sum (λ (i : Affine.Simplex.PointsWithCircumcenterIndex (n + 2)), affine.simplex.monge_point_weights_with_circumcenter n i) = 1
{α : Type u_1} {β : Type u_2} [Monoid β] {s : Finset α} (f g : α → β) (comm_ff : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → Commute (f x) (f y)) (comm_gg : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → Commute (g x) (g y)) (comm_gf : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≠ y → Commute (g x) (f y)) : s.noncomm_Prod (f * g) _ = s.noncomm_Prod f comm_ff * s.noncomm_Prod g comm_gg
{R : Type u_1} {M : Type u_2} [CommMonoid M] [CommRing R] [Nontrivial R] : Algebra.FiniteType R (MonoidAlgebra R M) ↔ monoid.fg M
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {ca cb : E} {la lb : Filter ℝ} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f la MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f lb MeasureTheory.MeasureSpace.volume) {s t : Set ℝ} [Interval_integral.FTC_Filter a (nhds_within a s) la] [Interval_integral.FTC_Filter b (nhds_within b t) lb] (ha : Filter.Tendsto f (la ⊓ MeasureTheory.Measure_space.volume.ae) (nhds ca)) (hb : Filter.Tendsto f (lb ⊓ MeasureTheory.Measure_space.volume.ae) (nhds cb)) (hs : UniqueDiffWithinAt ℝ s a . "UniqueDiffWithinAt_ici_Iic_Univ") (ht : UniqueDiffWithinAt ℝ t b . "UniqueDiffWithinAt_ici_Iic_Univ") : fderiv_within ℝ (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) (s ×ˢ t) (a, b) = (ContinuousLinearMap.snd ℝ ℝ ℝ).smul_Right cb - (ContinuousLinearMap.fst ℝ ℝ ℝ).smul_Right ca
{k : Type u_1} {E : Type u_2} [LinearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k → E} {a b r : k} (h : 0 < r * (b - a)) : ⇑(affine_map.line_Map (f a) (f b)) r < f (⇑(affine_map.line_Map a b) r) ↔ slope f a b < slope f a (⇑(affine_map.line_Map a b) r)
{α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (hs : b ∈ s) (hsa : b ∉ s.erase a) : b = a
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_4} [Fintype ι] [DecidableEq ι] (b : Basis ι R M) : LinearMap.trace R M = (contract_Left R M).comp (dual_tensor_hom_Equiv_of_Basis b).symm.to_Linear_Map
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} {s : Set E} {x : E} : mfderiv_within (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x = fderiv_within 𝕜 f s x
{α : Type u_1} {s : Finset α} : s.nonempty → 0 < s.card
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {m : α → β → γ} {f : Filter α} {g : Filter β} {n : γ → δ} {m' : β' → α → δ} {n' : β → β'} (h_antidistrib : ∀ (a : α) (b : β), n (m a b) = m' (n' b) a) : Filter.map n (Filter.map₂ m f g) = Filter.map₂ m' (Filter.map n' g) f
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : ℝ → E} {f' : E} {x r : ℝ} (hF : HasDerivWithinAt f f' (Set.Ici x) x) (hr : ∥f'∥ < r) : ∃ᶠ (z : ℝ) in nhds_within x (Set.Ioi x), ∥z - x∥⁻¹ * ∥f z - f x∥ < r
(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A] [Nontrivial R] {x : A} : IsIntegral R x → IsAlgebraic R x
{X Y : Profinite} (f : X ⟶ Y) (bij : Function.bijective ⇑f) : CategoryTheory.IsIso f
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x : E) (S : Submodule 𝕜 E) [CompleteSpace E] [CompleteSpace ↥S] : ∥x∥ ^ 2 = ∥⇑(Orthogonal_projection S) x∥ ^ 2 + ∥⇑(Orthogonal_projection Sᗮ) x∥ ^ 2
{α : Type u} [AddGroup α] [HasLe α] [CovariantClass α α (Function.swap has_add.add) has_le.le] {a b c : α} : a ≤ c - b → a + b ≤ c
{p : ℕ} (hp : 1 < p) : padic_val_Int p ↑p = 1
(n : ℤ) : ⇑Zmodχ₈' ↑n = Ite (n % 2 = 0) 0 (Ite (n % 8 = 1 ∨ n % 8 = 3) 1 (-1))
{X : Type u_1} [TopologicalSpace X] [NormalSpace X] {s t : Set X} (hs : is_IsClosed s) (ht : is_IsClosed t) (hD : Disjoint s t) {a b : ℝ} (hle : a ≤ b) : ∃ (f : BoundedContinuousFunction X ℝ), Set.EqOn ⇑f (Function.const X a) s ∧ Set.EqOn ⇑f (Function.const X b) t ∧ ∀ (x : X), ⇑f x ∈ Set.Icc a b
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} {a b : α} (h : a ≠ b) : finsum (λ (i : α), finsum (λ (H : i ∈ {a, b}), f i)) = f a + f b
{α : Type u_1} {ι : Type u_2} {β : Type u_3} {S : ι → Set α} {f : Π (i : ι), ↥(S i) → β} {hF : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩} {T : Set α} (hT' : T = Set.Union S) (Dir : Directed has_le.le S) (Op : ↥T → ↥T → ↥T) (opi : Π (i : ι), ↥(S i) → ↥(S i) → ↥(S i)) (hopi : ∀ (i : ι) (x y : ↥(S i)), Set.inclusion _ (opi i x y) = Op (Set.inclusion _ x) (Set.inclusion _ y)) (Opβ : β → β → β) (h : ∀ (i : ι) (x y : ↥(S i)), f i (opi i x y) = Opβ (f i x) (f i y)) (x y : ↥T) : Set.Union_Lift S f hF T _ (Op x y) = Opβ (Set.Union_Lift S f hF T _ x) (Set.Union_Lift S f hF T _ y)
(G : Type u_1) [Monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ IsOfFinOrder g
{α : Type u} [TopologicalSpace α] (s : Set α) : Frontier sᶜ = Frontier s
(n : ℕ) (n_big : 4 ≤ n) : 4 ^ n < n * n.central_binom
{α : Type u_1} {β : Type u_2} {f g : α →. β} (H1 : ∀ (a : α), a ∈ f.dom ↔ a ∈ g.dom) (H2 : ∀ (a : α) (p : f.dom a) (q : g.dom a), f.fn a p = g.fn a q) : f = g
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} (s : Finset ι) (f : ι → E) (x : E) : HasInner.inner x (s.sum (λ (i : ι), f i)) = s.sum (λ (i : ι), HasInner.inner x (f i))
{P : Type u → Prop} (of_Equiv : ∀ {α β : Type u}, α ≃ β → P α → P β) (h_Empty : P PEmpty) (h_Option : ∀ {α : Type u} [_inst_1 : Fintype α], P α → P (Option α)) (α : Type u) [Fintype α] : P α
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] (p : FormalMultilinearSeries 𝕜 E F) (h : 0 < p.radius) : HasFpowerSeriesOnBall p.sum p 0 p.radius
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteCoproducts C] [CategoryTheory.Limits.HasCokernels C] [CategoryTheory.NormalEpiCategory C] [CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X ⟶ Y) (hF : ∀ (Z : C) (g : Z ⟶ X), g ≫ f = 0 → g = 0) : CategoryTheory.Mono f
{α : Type u_1} [CommSemiring α] (E : LinearRecurrence α) (init : Fin E.order → α) : E.is_solution (E.mk_sol init)
{ι : Type u} {α : Type v} [Fintype ι] {t : ι → Finset α} [DecidableEq α] {n : ℕ} (hn : Fintype.card ι = n + 1) (ht : ∀ (s : Finset ι), s.card ≤ (s.bUnion t).card) (ih : ∀ {ι' : Type u} [_inst_3 : Fintype ι'] (t' : ι' → Finset α), Fintype.card ι' ≤ n → (∀ (s' : Finset ι'), s'.card ≤ (s'.bUnion t').card) → (∃ (f : ι' → α), Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x)) (ha : ∀ (s : Finset ι), s.nonempty → s ≠ Finset.univ → s.card < (s.bUnion t).card) : ∃ (f : ι → α), Function.Injective f ∧ ∀ (x : ι), f x ∈ t x
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {x : E} {n : ℕ} : ContDiffWithinAt 𝕜 ↑(n + 1) f s x ↔ ∃ (u : Set E) (H : u ∈ nhds_within x (HasInsert.insert x s)) (f' : E → (E →L[𝕜] F)), (∀ (x : E), x ∈ u → HasFderivWithinAt f (f' x) u x) ∧ ContDiffWithinAt 𝕜 ↑n f' u x
{C : Type u₁} [CategoryTheory.Category C] {X Y : C} (t : CategoryTheory.Limits.IsInitial X) (f : Y ⟶ X) : CategoryTheory.Epi f
{ι : Type w} {R : Type u} [Ring R] [Nontrivial R] {M : Type v} [AddCommGroup M] [Module R M] {v : ι → M} (i : LinearIndependent R v) : i.maximal ↔ ∀ (κ : Type v) (w : κ → M), LinearIndependent R w → ∀ (j : ι → κ), w ∘ j = v → Function.Surjective j
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [SemiNormedGroup F'] {f : α → E} {g' : α → F'} {l : Filter α} : (f =O[l] λ (x : α), -g' x) → f =O[l] g'
{α : Type u_1} [Preorder α] [Nonempty α] [NoMaxOrder α] : Infinite α
{α : Type u_2} {m : Type u_4} {n : Type u_5} {R : Type u_8} [TopologicalSpace R] [TopologicalSpace α] {f : α → Matrix m n R} (h : ∀ (i : m) (j : n), Continuous (λ (a : α), f a i j)) : Continuous f
{α : Type u} [NonUnitalNonAssocRing α] (a b c : α) : a * (b - c) = a * b - a * c
{α : Type u_1} [Preorder α] [LocallyFiniteOrder α] {a b : α} : ¬a < b → Multiset.ioc a b = 0
{ι : Type u} (s : Finset ι) (f : ι → Nnreal) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), f i) ^ p ≤ ↑(s.card) ^ (p - 1) * s.sum (λ (i : ι), f i ^ p)
{α : Type u_1} [PseudoMetricSpace α] (C : ℝ) {f : ℕ → α} (hu₂ : ∀ (n : ℕ), HasDist.dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n) {a : α} (ha : Filter.Tendsto f filter.at_Top (nhds a)) (n : ℕ) : HasDist.dist (f n) a ≤ C / 2 ^ n
{β : Type u_1} [ConditionallyCompleteLattice β] {s : Set (WithTop β)} (hs : s.nonempty) : is_is_IsLub s (HasSup.sup s)
{α : Type u_1} {β : Type u_2} {M : Type u_5} [AddCommMonoid M] {f : α → M} {g : β → α} (hg : Function.Injective g) : finsum (λ (i : α), finsum (λ (H : i ∈ Set.Range g), f i)) = finsum (λ (j : β), f (g j))
{M : Type u_1} [Monoid M] : IsSubmonoid Set.Univ
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x : E} {s : Set E} (h : HasFderivWithinAt f f' s x) {α : Type u_4} (l : Filter α) {c : α → 𝕜} {d : α → E} {v : E} (dtop : ∀ᶠ (n : α) in l, x + d n ∈ s) (clim : Filter.Tendsto (λ (n : α), ∥c n∥) l filter.at_Top) (cdlim : Filter.Tendsto (λ (n : α), c n • d n) l (nhds v)) : Filter.Tendsto (λ (n : α), c n • (f (x + d n) - f x)) l (nhds (⇑f' v))
{p : ℕ+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [NeZero ↑↑p] {k : ℕ} [hpri : Fact (Nat.Prime ↑p)] [IsCyclotomicExtension {p ^ (k + 1)} K L] (hirr : Irreducible (Polynomial.cyclotomic ↑(p ^ (k + 1)) K)) {s : ℕ} (hs : s ≤ k) (htwo : p ^ (k - s + 1) ≠ 2) : ⇑(Algebra.norm K) (IsCyclotomicExtension.zeta (p ^ (k + 1)) K L ^ ↑p ^ s - 1) = ↑p ^ ↑p ^ s
{q : ℚ} {n : ℕ} {ifp_n ifp_Succ_n : GeneralizedContinuedFraction.IntFractPair ℚ} (Stream_nth_Eq : GeneralizedContinuedFraction.IntFractPair.stream q n = Option.some ifp_n) (Stream_Succ_nth_Eq : GeneralizedContinuedFraction.IntFractPair.stream q (n + 1) = Option.some ifp_Succ_n) : ifp_Succ_n.fr.num < ifp_n.fr.num
{G : Type u_1} [AddGroup G] {N : Type u_3} [AddGroup N] (H : AddSubgroup G) {f : N →+ G} (hF : Function.Surjective ⇑f) : AddSubgroup.comap f H.normalizer = (AddSubgroup.comap f H).normalizer
{α : Type u_1} {a b c : α} [LinearOrder α] [AddCommSemigroup α] [HasSub α] [HasOrderedSub α] : a < b - c ↔ c + a < b
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : E → ℝ} {a : E} {s : Set E} (h : is_IsLocalMaxOn f s a) {y : E} (hy : y ∈ PosTangentConeAt s a) : ⇑(fderiv_within ℝ f s a) y ≤ 0
(F : Type u_1) [Field F] {E : Type u_2} [Field E] [Algebra F E] (S T : Set E) : ↑(IntermediateField.adjoin ↥(IntermediateField.adjoin F S) T) = ↑(IntermediateField.adjoin ↥(IntermediateField.adjoin F T) S)
{α : Type u_1} {ι : sort u_4} [CompleteLattice α] (f : ι → α) : (⨆ (i : {i // f i ≠ ⊥}), f ↑i) = ⨆ (i : ι), f i
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] {f : ℝ → E} {T : ℝ} (hF : Function.Periodic f T) (t s : ℝ) (h_Int : ∀ (t₁ t₂ : ℝ), IntervalIntegrable f MeasureTheory.MeasureSpace.volume t₁ t₂) : ∫ (x : ℝ) in t..s + T, f x = (∫ (x : ℝ) in t..s, f x) + ∫ (x : ℝ) in t..t + T, f x
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {f : R →+* S} {p : Polynomial S} (r : R) (hp : p ∈ Polynomial.lifts f) : ⇑Polynomial.c (⇑f r) * p ∈ Polynomial.lifts f
{α : Type u_1} {s : Set α} : Set.Range Subtype.val = s
{A : Type u_1} [NormedRing A] [NormedAlgebra ℂ A] [CompleteSpace A] [Nontrivial A] (a : A) : (Spectrum ℂ a).nonempty
{α : Type u_1} {β : Type u_2} {e : LocalEquiv α β} {s : Set α} {t : Set β} : e.is_image s t → e.target ∩ ⇑(e.symm) ⁻¹' s = e.target ∩ t
{R : Type u_1} [Semiring R] (n : ℕ) (a : R) [Decidable (a = 0)] : (⇑(PowerSeries.monomial R n) a).order = Ite (a = 0) ⊤ ↑n
{α : Type u} {β : Type v} [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {n : ℕ} (ht : t.nonempty) (hn : s.card ≤ t.card * n) : ∃ (y : β) (H : y ∈ t), (Finset.filter (λ (x : α), f x = y) s).card ≤ n
{α : Type u} [Preorder α] {a b c : α} : a < b → b ≤ c → a < c
{t : Set Gromov_Hausdorff.GH_Space} {C : ℝ} {u : ℕ → ℝ} {K : ℕ → ℕ} (ulim : Filter.Tendsto u filter.at_Top (nhds 0)) (hdiam : ∀ (p : Gromov_Hausdorff.GH_Space), p ∈ t → Metric.diam Set.Univ ≤ C) (hcov : ∀ (p : Gromov_Hausdorff.GH_Space), p ∈ t → ∀ (n : ℕ), ∃ (s : Set p.rep), Cardinal.mk ↥s ≤ ↑(K n) ∧ Set.Univ ⊆ ⋃ (x : p.rep) (H : x ∈ s), Metric.Ball x (u n)) : TotallyBounded t
{α : Type u_1} {m : MeasurableSpace α} (ν : MeasureTheory.Measure α) [MeasureTheory.SigmaFinite ν] {s : Set α} (hs : MeasurableSet s) : (ν.restrict s).rn_deriv ν =ᵐ[ν] s.indicator 1
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) [CategoryTheory.Limits.HasColimitsOfSize D] [CategoryTheory.CreatesColimitsOfSize F] : CategoryTheory.Limits.HasColimitsOfSize C
{E : Type u_2} [SemiNormedGroup E] [NormedSpace ℝ E] {s t : Set E} {x y : E} (hx : x ∈ ⇑(Convex_hull ℝ) s) (hy : y ∈ ⇑(Convex_hull ℝ) t) : ∃ (x' : E) (H : x' ∈ s) (y' : E) (H : y' ∈ t), HasDist.dist x y ≤ HasDist.dist x' y'
{α : Type u_1} [LinearOrderedField α] [Archimedean α] {x y : α} (hx : 0 < x) (hy : y < 1) : ∃ (n : ℕ), y ^ n < x
{α : Type u} [Preorder α] {s t : Set α} (h : BddBelow s) : BddBelow (s ∩ t)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} {u v : E} (hu : u ∈ K) (hv : v ∈ Kᗮ) : HasInner.inner u v = 0
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) {r : ℝ} : 2 • o.oangle x (r • x) = 0
(p' : ℕ) : 2 < LucasLehmer.q (p' + 2)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {D : Type u₁} [CategoryTheory.Category D] {L : D ⥤ C} {R : C ⥤ D} (h : L ⊣ R) : CategoryTheory.IsFiltered D
{α : Type u} {β : Type v} [PseudoEmetricSpace α] [PseudoEmetricSpace β] {f : α → β} [Subsingleton α] : Isometry f
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] (a : α) [NoMaxOrder α] : Closure (Set.Ioi a) = Set.Ici a
{C : Type u₁} [CategoryTheory.Category C] {A : Type u₂} [CategoryTheory.Category A] (P : Cᵒᵖ ⥤ A) {X : C} (R : CategoryTheory.Presieve X) : Nonempty (CategoryTheory.Limits.IsLimit (P.map_cone (CategoryTheory.Sieve.generate R).arrows.cocone.op)) ↔ ∀ (E : Aᵒᵖ), CategoryTheory.Presieve.IsSheafFor (P ⋙ Category_theory.coyoneda.obj E) R
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) : Real.sin (InnerProductGeometry.angle x y) * (∥x∥ * ∥y∥) = Real.sqrt (HasInner.inner x x * HasInner.inner y y - HasInner.inner x y * HasInner.inner x y)
{n : ℕ} (hpos : 0 < n) : Irreducible (Polynomial.cyclotomic n ℤ)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [NormedGroup E] [NormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →sl[σ₁₂] F) [RingHomIsometric σ₁₂] : ∥f∥ = 0 ↔ f = 0
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} : Mdifferentiable (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f ↔ Differentiable 𝕜 f
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] (q : FormalMultilinearSeries 𝕜 F G) (p : FormalMultilinearSeries 𝕜 E F) (r : Nnreal) (hr : Summable (λ (i : Σ (n : ℕ), Composition n), ∥q.comp_along_Composition p i.snd∥₊ * r ^ i.fst)) : ↑r ≤ (q.comp p).radius
{α : Type u_1} {ι : Type u_4} [LinearOrder α] [DecidableEq ι] (f : ι → α) {p : Finset ι → Prop} (s : Finset ι) (h0 : p ∅) (step : ∀ (a : ι) (s : Finset ι), a ∉ s → (∀ (x : ι), x ∈ s → f x ≤ f a) → p s → p (HasInsert.insert a s)) : p s
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} {s t : Set α} (hst : Disjoint s t) (hs : (s ∩ Function.MulSupport f).finite) (ht : (t ∩ Function.MulSupport f).finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s ∪ t), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))
{α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [LinearOrderedAddCommGroup α] [Archimedean α] (h : Function.Periodic f c) (hc : 0 < c) (x : α) : ∃ (y : α) (H : y ∈ Set.Ico 0 c), f x = f y
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [OrderedSemiring 𝕜] [AddCommGroup E] [Module 𝕜 E] {p : ι → E} (hc : ConvexIndependent 𝕜 p) (s : Set ι) : ConvexIndependent 𝕜 (λ (i : ↥s), p ↑i)
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} (h : InnerProductGeometry.angle x y = 0) : HasInner.inner x y = ∥x∥ * ∥y∥
{𝕜 : Type u_1} [LinearOrderedField 𝕜] [TopologicalSpace 𝕜] [OrderTopology 𝕜] [Archimedean 𝕜] : DenseRange Coe
{R : Type u_1} [LinearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {x y : M} (h : SameRay R x y) (hy : y ≠ 0) : ∃ (r : R), 0 ≤ r ∧ x = r • y
{α : Type u} [PseudoMetricSpace α] {s t : Set α} : metric.Hausdorff_dist (Closure s) t = metric.Hausdorff_dist s t
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (p1 p2 : P) : HasDist.dist p1 (midpoint ℝ p1 p2) = HasDist.dist p2 (midpoint ℝ p1 p2)
{Γ₀ : Type u_3} [LinearOrderedCommMonoidWithZero Γ₀] [Nontrivial Γ₀] {K : Type u_1} [DivisionRing K] (v : Valuation K Γ₀) {x : K} : ⇑v x = 0 ↔ x = 0
{R : Type u_1} [OrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] [NoZeroSmulDivisors R M] (x : Module.Ray R M) : x ≠ -x
(a : Zmod8) : ⇑Zmodχ₈' a = 0 ∨ ⇑Zmodχ₈' a = 1 ∨ ⇑Zmodχ₈' a = -1
{α : Type u_2} {β : Type u_3} [LinearOrderedField α] [LinearOrderedField β] [Archimedean β] : Subsingleton (α ≃+*o β)
{α : Type u} (L : List α) {i j : ℕ} (h : j < (List.drop i L).length) : (List.drop i L).nth_LE j h = L.nth_LE (i + j) _
{α : Type u_1} [LinearOrder α] (a : α) : {a}.min' _ = a
{x : ℝ} (n : ℕ) (m : ℤ) (hxr : x ^ n = ↑m) (hv : ¬∃ (y : ℤ), x = ↑y) (hnpos : 0 < n) : Irrational x
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} (p : ι → P) (i0 : ι) : Vector_Span k (Set.Range p) = Submodule.span k (Set.Range (λ (i : ι), p i0 -ᵥ p i))
{X Y : Type u} (f : X ⟶ Y) : CategoryTheory.IsIso f ↔ Function.bijective f
{X : Type u_1} {Y : Type u_2} [NormedGroup X] [NormedGroup Y] [NormedSpace ℝ X] [NormedSpace ℝ Y] {f : X → Y} {x : X} : ConformalAt f x ↔ IsConformalMap (fderiv ℝ f x)
(f : ℝ → ℝ) {a b : ℝ} (hab : a < b) (g : ℝ → ℝ) {lfa lga lfb lgb : ℝ} (hdf : DifferentiableOn ℝ f (Set.Ioo a b)) (hdg : DifferentiableOn ℝ g (Set.Ioo a b)) (hfa : Filter.Tendsto f (nhds_within a (Set.Ioi a)) (nhds lfa)) (hga : Filter.Tendsto g (nhds_within a (Set.Ioi a)) (nhds lga)) (hfb : Filter.Tendsto f (nhds_within b (Set.Iio b)) (nhds lfb)) (hgb : Filter.Tendsto g (nhds_within b (Set.Iio b)) (nhds lgb)) : ∃ (c : ℝ) (H : c ∈ Set.Ioo a b), (lgb - lga) * deriv f c = (lfb - lfa) * deriv g c
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] {p : ι → E} : ConvexIndependent 𝕜 p ↔ ∀ (s : Finset ι) (x : ι), p x ∈ ⇑(Convex_hull 𝕜) ↑(Finset.image p s) → x ∈ s
 : Filter.Tendsto Coe Filter.cofinite (Filter.cocompact ℝ)
{η : Type u_5} {f : η → Type u_6} [Π (i : η), AddGroup (f i)] [DecidableEq η] [Fintype η] {H : Π (i : η), AddSubgroup (f i)} {J : AddSubgroup (Π (i : η), f i)} : AddSubgroup.pi Set.Univ H ≤ J ↔ ∀ (i : η), AddSubgroup.map (AddMonoidHom.single f i) (H i) ≤ J
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_5} [NormedGroup E'] [NormedSpace 𝕜 E'] {n : WithTop ℕ} {f : E → E'} : ContDiff 𝕜 n f → ContMdiff (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {s : Set 𝕜} {n : WithTop ℕ} {m : ℕ} (h : ContDiffOn 𝕜 n f s) (hmn : ↑m ≤ n) (hs : UniqueDiffOn 𝕜 s) : ContinuousOn (iterated_deriv_within m f s) s
{γ : Type w} [EmetricSpace γ] {s : Set γ} (hs : is_IsCompact s) : ∃ (t : Set γ) (H : t ⊆ s), t.countable ∧ s = Closure t
{M : Type u_1} [MulOneClass M] {S T : Submonoid M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T
{R : Type u_1} [LinearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [Nontrivial R] [Nonempty ι] (e : Basis ι R M) (x : Orientation R M ι) (i : ι) : ⇑(e.adjust_to_Orientation x) i = ⇑e i ∨ ⇑(e.adjust_to_Orientation x) i = -⇑e i
{M : Type u_3} [AddMonoid M] [Preorder M] (L : List M) (h : L.sum < 0) : 0 < L.length
{M : Type u_1} [SemiNormedGroup M] (S : AddSubgroup M) (h : ↑(S.topological_Closure) = Set.Univ) : ∥S.normed_Mk∥ = 0
{C : Type u} [CategoryTheory.Category C] {X Y : C} (f : X ⟶ Y) (t : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.PullbackCone.mk (𝟙 X) (𝟙 X) rfl)) : CategoryTheory.Mono f
{α : Type u} {β : Type v} [PseudoMetricSpace α] [Nonempty β] [SemilatticeSup β] {s : β → α} (b : β → ℝ) (h : ∀ (n m N : β), N ≤ n → N ≤ m → HasDist.dist (s n) (s m) ≤ b N) (h₀ : Filter.Tendsto b filter.at_Top (nhds 0)) : CauchySeq s
{x : ℝ} (hx : 0 ≤ x) (y z : ℝ) : x ^ y * x ^ z ≤ x ^ (y + z)
{ι : Type u_1} {M : Type u_4} {N : Type u_5} [AddCommMonoid M] [OrderedAddCommMonoid N] (f : M → N) (h_Mul : ∀ (x y : M), f (x + y) ≤ f x + f y) {s : Finset ι} (hs : s.nonempty) (g : ι → M) : f (s.sum (λ (i : ι), g i)) ≤ s.sum (λ (i : ι), f (g i))
(n : ℕ) : (n + 2).factors = (n + 2).min_fac :: ((n + 2) / (n + 2).min_fac).factors
{α : Type u} [Preorder α] {s : Set α} {a : α} (h : IsGreatest s a) : BddAbove s
{α : Type u} {β : Type v} [DecidableEq β] [Fintype α] [Fintype β] (f : α → β) {n : ℕ} (hn : Fintype.card β * n < Fintype.card α) : ∃ (y : β), n < (Finset.filter (λ (x : α), f x = y) Finset.univ).card
{n m : ℕ} (e : Fin n ≃o Fin m) (i : Fin n) : ↑(⇑e i) = ↑i
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{α : Type u_1} {ι : sort u_2} (m : ι → MeasureTheory.OuterMeasure α) {s : Set α} (hs : s.nonempty) : (⇑⨅ (i : ι), m i) s = ⨅ (t : ℕ → Set α) (h2 : s ⊆ Set.Union t), ∑' (n : ℕ), ⨅ (i : ι), ⇑(m i) (t n)
{M : Type u_1} [AddMonoid M] : IsAddSubmonoid Set.Univ
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : Set P} (h : s.finite) : FiniteDimensional k ↥((affine_Span k s).direction)
{α : Type u_1} {β : Type u_2} {f : α → β} (hF : Function.Injective f) : Function.Injective (Option.map f)
(s : ℝ) : Filter.Tendsto (λ (x : ℝ), Real.exp x / x ^ s) filter.at_Top filter.at_Top
{G : Type u_2} [Group G] : MulAction.FixedPoints (ConjAct G) G = ↑(Subgroup.center G)
{α : Type u_1} [ConditionallyCompleteLattice α] {s t : Set α} (hs : BddAbove s) (sne : s.nonempty) (ht : BddAbove t) (tne : t.nonempty) : HasSup.sup (s ∪ t) = HasSup.sup s ⊔ HasSup.sup t
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] (p : P) : euclidean_geometry.orthogonal_projection_fn s p -ᵥ p ∈ (s.direction)ᗮ
{β : Type u} {α : Type v} [AddCommMonoid β] {s : Finset α} (f : α → β) : MulOpposite.op (s.sum (λ (x : α), f x)) = s.sum (λ (x : α), MulOpposite.op (f x))
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {f : α → β} {s : Set α} {x : α} (h : ContinuousWithinAt f s x) : Filter.Tendsto f (nhds_within x s) (nhds (f x))
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [DecidableEq γ] (s : Finset α) (t : Finset β) (f : α × β → Finset γ) : (s.product t).bUnion f = s.bUnion (λ (a : α), t.bUnion (λ (b : β), f (a, b)))
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : α → β} : StrictMono f → StrictAnti (⇑order_dual.to_dual ∘ f)
{α : Type u} [Preorder α] {a b c : α} : b ≤ c → a = b → a ≤ c
{α : Type u} {β : Type v} [AddCommMonoid β] (s : Finset α) (f : Finset α → β) : s.powerset.sum (λ (t : Finset α), f t) = (Finset.range (s.card + 1)).sum (λ (j : ℕ), (finset.powerset_len j s).sum (λ (t : Finset α), f t))
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] [CompleteSpace 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [FiniteDimensional 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {a : E} (hF : HasStrictFderivAt f f' a) (hF' : f'.range = ⊤) {α : Type u_4} {l : Filter α} {g₁ : α → F} {g₂ : α → ↥(f'.ker)} (h₁ : Filter.Tendsto g₁ l (nhds (f a))) (h₂ : Filter.Tendsto g₂ l (nhds 0)) : Filter.Tendsto (λ (t : α), has_strict_fderiv_at.implicit_Function f f' hF hF' (g₁ t) (g₂ t)) l (nhds a)
{α : Type u_3} {β : Type u_4} [Nonempty α] [SemilatticeSup α] [Preorder β] {f : α → β} (hF : Monotone f) : Filter.Tendsto f filter.at_Top filter.at_Top ↔ ∀ (b : β), ∃ (a : α), b ≤ f a
{R : Type u₁} [LinearOrderedRing R] {a : R} (H : -2 ≤ a) (n : ℕ) : 1 + ↑n * a ≤ (1 + a) ^ n
{α : Type u} [Group α] [HasLe α] [CovariantClass α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ → a ≤ 1
{α : Type u_1} {M : Type u_4} [HasZero M] {s : Set α} {f : α → M} {a : α} (h : s.indicator f a ≠ 0) : a ∈ s
{R : Type u_1} [CommMonoidWithZero R] (f : Nat.ArithmeticFunction R) (hF : f.is_Multiplicative) (g : Nat.ArithmeticFunction R) (hg : g.is_Multiplicative) : f = g ↔ ∀ (p i : ℕ), Nat.Prime p → ⇑f (p ^ i) = ⇑g (p ^ i)
{ι : Type u} {γ : Type w} {β : ι → Type v} [dec : DecidableEq ι] [Π (i : ι), AddZeroClass (β i)] [AddCommMonoid γ] (f : Π (i : ι), β i →+ γ) (i : ι) : (⇑dfinsupp.lift_AddHom f).comp (Dfinsupp.single_AddHom β i) = f i
{α : Type u_1} {R : Type u_2} {l : Filter α} {f : α → R} {r : R} [LinearOrderedRing R] [Archimedean R] (hr : r < 0) (hF : Filter.Tendsto f l filter.at_IsBot) : Filter.Tendsto (λ (x : α), f x * r) l filter.at_Top
{K : Type u_1} {n : ℕ} {g : GeneralizedContinuedFraction K} [Field K] (nth_Part_denom_NeZero : ∀ {b : K}, g.partial_denominators.nth n = Option.some b → b ≠ 0) : g.convergents (n + 1) = (g.squash_gcf n).convergents n
{R : Type u_1} [CommRing R] [is_IsDomain R] {a b c : R} (h2 : 2 ≠ 0) (ha : a ≠ 0) (x : R) : a * x * x + b * x + c = 0 ↔ discrim a b c = (2 * a * x + b) ^ 2
{K : Type u_1} [LinearOrderedField K] [FloorRing K] {v : K} {n : ℕ} : GeneralizedContinuedFraction.IntFractPair.stream v (n + 1) = Option.none ↔ GeneralizedContinuedFraction.IntFractPair.stream v n = Option.none ∨ ∃ (ifp : GeneralizedContinuedFraction.IntFractPair K), GeneralizedContinuedFraction.IntFractPair.stream v n = Option.some ifp ∧ ifp.fr = 0
{α : Type u_1} (f : α → α → α) [IsAssociative α f] (x y : α) : f x ∘ f y = f (f x y)
{M₀ : Type u_1} [MulZeroClass M₀] : (λ (_x : M₀), _x * 0) = Function.const M₀ 0
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {f : ℂ → E} (hD : DiffContOnCl ℂ f {z : ℂ | 0 < z.re}) (hexp : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hre : Asymptotics.SuperpolynomialDecay filter.at_Top Real.exp (λ (x : ℝ), ∥f ↑x∥)) (him : ∃ (C : ℝ), ∀ (x : ℝ), ∥f (↑x * Complex.i)∥ ≤ C) : Set.EqOn f 0 {z : ℂ | 0 ≤ z.re}
{E : Type u_1} [AddCommGroup E] [Module ℝ E] [TopologicalSpace E] [HasContinuousSmul ℝ E] {F : Type u_2} [AddCommGroup F] [Module ℝ F] [TopologicalSpace F] [HasContinuousSmul ℝ F] [t2_Space F] (f : E →+ F) (hF : Continuous ⇑f) (c : ℝ) (x : E) : ⇑f (c • x) = c • ⇑f x
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {J : Type w} [CategoryTheory.Category J] (K : J ⥤ C) (F : C ⥤ D) [CategoryTheory.Limits.HasLimit (K ⋙ F)] [CategoryTheory.CreatesLimit K F] : CategoryTheory.Limits.HasLimit K
(n : ℕ) (R : Type u_1) [Ring R] : (Polynomial.cyclotomic n R).monic
{a b : Prop} : ¬(a ∧ b) ↔ ¬a ∨ ¬b
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} {a : α} {s : Set α} (h : a ∉ s → f a = 0) : finsum (λ (i : α), finsum (λ (H : i ∈ HasInsert.insert a s), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i))
{α : Type u_1} {β : Type u_2} [PseudoMetricSpace α] [PseudoMetricSpace β] {K : Nnreal} {f : α → β} : AntilipschitzWith K f → ∀ (x y : α), HasNndist.nndist x y ≤ K * HasNndist.nndist (f x) (f y)
(x : ℂ) : HasStrictDerivAt Complex.cosh (Complex.sinh x) x
{M : Type u_1} [Monoid M] (u : Mˣ) (a : M) : IsUnit (↑u * a) ↔ IsUnit a
{R : Type u_1} [CommRing R] : Set.SurjOn (λ (g : Matrix.SpecialLinearGroup (Fin 2) R), ↑g 1) Set.Univ {cd : Fin 2 → R | IsCoprime (cd 0) (cd 1)}
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{α : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} [LinearOrder ι] {f : MeasureTheory.Filtration ι m} {τ : α → ι} [TopologicalSpace ι] [OrderTopology ι] [TopologicalSpace.FirstCountableTopology ι] (hτ : MeasureTheory.IsStoppingTime f τ) (i : ι) (h_is_IsLub : is_is_IsLub (Set.Iio i) i) : MeasurableSet {x : α | τ x < i}
{α : Type u} {β : Type v} [Semiring α] [Semiring β] {f : α → β} (hF : IsSemiringHom f) {γ : Type u_1} [Semiring γ] {g : β → γ} (hg : IsSemiringHom g) : IsSemiringHom (g ∘ f)
{α : Type u_1} {ι : Type u_3} [CompleteLattice α] [Fintype ι] {f : ι → α} : CompleteLattice.Independent f → finset.univ.sup_indep f
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (ha : ContinuousAt f a) (hb : ContinuousAt f b) : HasFderivAt (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) ((ContinuousLinearMap.snd ℝ ℝ ℝ).smul_Right (f b) - (ContinuousLinearMap.fst ℝ ℝ ℝ).smul_Right (f a)) (a, b)
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : ℕ} {i : Fin (n + 2)} : X.δ i ≫ X.δ (⇑fin.cast_Succ i) = X.δ i ≫ X.δ i.succ
{M : Type u_1} [has_Add M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y) : AddConGen r ≤ AddConGen s
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (𝕜 : Type u_3) [DivisionRing 𝕜] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.Linear 𝕜 C] {X Y : C} [CategoryTheory.Simple X] [CategoryTheory.Simple Y] (h : (X ≅ Y) → False) : FiniteDimensional.finrank 𝕜 (X ⟶ Y) = 0
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) (b : n → α) (h : IsUnit A.det) : A.det • matrix.vec_Mul b A⁻¹ = ⇑(A.transpose.cramer) b
{α : Type u_1} [LinearOrder α] {s : Set α} : ¬BddBelow s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), y < x
{k : ℕ} : Fact (Even (Fintype.card (Fin (bit0 k))))
{n : ℕ} (hn : n % 2 = 1) : ⇑Zmodχ₄ ↑n = (-1) ^ (n / 2)
{ι : Type u_1} {R₂ : Type u_7} {M₂ : Type u_8} [CommRing R₂] [AddCommGroup M₂] [Module R₂ M₂] [DecidableEq ι] (e : Basis ι R₂ M₂) (w : ι → R₂ˣ) : e.to_Matrix ⇑(e.units_Smul w) = Matrix.diagonal (Coe ∘ w)
{α : Type u} [TopologicalSpace α] {s : Set α} {ι : Type v} (hs : is_IsCompact s) (Z : ι → Set α) (hZc : ∀ (i : ι), is_IsClosed (Z i)) (hsZ : (s ∩ ⋂ (i : ι), Z i) = ∅) : ∃ (t : Finset ι), (s ∩ ⋂ (i : ι) (H : i ∈ t), Z i) = ∅
(l : List ℕ) (n : ℕ) : List.Sorted has_le.le (Denumerable.raise l n)
{J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ Mon_) [CategoryTheory.IsFiltered J] (j : J) : 1 = Mon.FilteredColimits.M.mk F ⟨j, 1⟩
{K : Type u_1} [LinearOrderedField K] [FloorRing K] {v : K} {n : ℕ} {ifp_Succ_n : GeneralizedContinuedFraction.IntFractPair K} (Stream_Succ_nth_Eq : GeneralizedContinuedFraction.IntFractPair.stream v (n + 1) = Option.some ifp_Succ_n) : (GeneralizedContinuedFraction.of v).s.nth n = Option.some {a := 1, b := ↑(ifp_Succ_n.b)}
(𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} [LinearOrder ι] [OrderBot ι] [LocallyFiniteOrder ι] [IsWellOrder ι has_lt.lt] [SuccOrder ι] [IsSuccArchimedean ι] (f : ι → E) (h₀ : LinearIndependent 𝕜 f) : Orthonormal 𝕜 (gram_schmidt_normed 𝕜 f)
{G : Type u_1} [Group G] {N : Type u_2} [Group N] (f : G →* N) (hF : Function.Surjective ⇑f) : f.range = ⊤
{R : Type u_1} {a : R} [MulZeroClass R] [Nontrivial R] (ra : IsRightRegular a) : a ≠ 0
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {n : WithTop ℕ} {f : E → F} (hF : ContDiffAt 𝕜 n f x) : ContDiffAt 𝕜 n (λ (x : E), -f x) x
{α : Type u_1} {β : sort u_2} {γ : sort u_3} {s : Set α} (e : β ≃ ↥s) (v : β → γ) (w : α → γ) (j : β) (x : γ) [DecidableEq β] [DecidableEq α] [Π (j : α), Decidable (j ∈ s)] : (λ (i : α), dite (i ∈ s) (λ (h : i ∈ s), Function.update v j x (⇑(e.symm) ⟨i, h⟩)) (λ (h : i ∉ s), w i)) = Function.update (λ (i : α), dite (i ∈ s) (λ (h : i ∈ s), v (⇑(e.symm) ⟨i, h⟩)) (λ (h : i ∉ s), w i)) ↑(⇑e j) x
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {c : Con M} {f : M →* P} (H : c ≤ Con.ker f) (x : M) : ⇑(c.lift f H) ↑x = ⇑f x
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) {r : ℝ} : 2 • o.oangle (r • x) x = 0
{G : Type u_6} {H : Type u_7} {F : Type u_8} [AddGroup G] [SubtractionMonoid H] [AddMonoidHomClass F G H] (f : F) (a b : G) : ⇑f (a + -b) = ⇑f a + -⇑f b
{α : Type u} [TopologicalSpace α] [t2_Space α] (h : TopologicalSpace.IsTopologicalBasis {s : Set α | is_IsClopen s}) : TotallySeparatedSpace α
{α : Type uu} (a : α) {l₁ l₂ : List α} : a :: l₁ <+~ a :: l₂ → l₁ <+~ l₂
{M : Type u_3} {F : Type u_8} {G : Type u_1} [Group G] [Monoid M] [MonoidHomClass F G M] {f g : F} {x : G} (h : ⇑f x = ⇑g x) : ⇑f x⁻¹ = ⇑g x⁻¹
{α : Type u} [PseudoMetricSpace α] {s : Set α} [CompactSpace α] : Metric.Bounded s
{X : Type u_2} [EmetricSpace X] {m₁ m₂ : Ennreal → Ennreal} (hle : m₁ ≤ᶠ[nhds_within 0 (Set.Ici 0)] m₂) : measure_theory.outer_measure.mk_metric m₁ ≤ measure_theory.outer_measure.mk_metric m₂
{V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasZeroMorphisms V] {A B C : V} {f : A ⟶ B} [CategoryTheory.Limits.HasImage f] {g : B ⟶ C} [CategoryTheory.Limits.HasKernel g] (w : f ≫ g = 0) {A' B' C' : V} {f' : A' ⟶ B'} [CategoryTheory.Limits.HasImage f'] {g' : B' ⟶ C'} [CategoryTheory.Limits.HasKernel g'] (w' : f' ≫ g' = 0) (α : CategoryTheory.Arrow.mk f ⟶ CategoryTheory.Arrow.mk f') [CategoryTheory.Limits.HasImageMap α] (β : CategoryTheory.Arrow.mk g ⟶ CategoryTheory.Arrow.mk g') (p : α.right = β.left) : image_to_Kernel f g w ≫ Category_theory.limits.kernel_Subobject_Map β = Category_theory.limits.image_Subobject_Map α ≫ image_to_Kernel f' g' w'
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup V1] [Module k V1] [AddTorsor V1 P1] [AddCommGroup V2] [Module k V2] [AddTorsor V2 P2] {f g : P1 →ᵃ[k] P2} (h : ∀ (p : P1), ⇑f p = ⇑g p) : f = g
{α : Type u_1} [Preorder α] [LocallyFiniteOrder α] {a b : α} : ¬a < b → Finset.ioc a b = ∅
{E : Type u_1} [NormedGroup E] {f : ℂ → E} {c : ℂ} {R : ℝ} [NormedSpace ℂ E] (hF : CircleIntegrable f c R) : IntervalIntegrable (λ (θ : ℝ), deriv (Circle_Map c R) θ • f (Circle_Map c R θ)) MeasureTheory.MeasureSpace.volume 0 (2 * Real.pi)
{α : Type u_1} (c : Set (Set α)) (hc : setoid.is_Partition c) : (setoid.mk_Classes c _).classes = c
{α : Type u} [Group α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] {a b c : α} : b < a⁻¹ * c → a * b < c
{α : Type u_1} {s t : Set α} : Disjoint s t → Disjoint (Filter.principal s) (Filter.principal t)
{α : Type u_1} {l : List α} : l <+: List.nil → l = List.nil
{α : Type u_1} {M : Type u_5} {N : Type u_7} [AddZeroClass M] [AddCommMonoid N] {f g : α →₀ M} {h : α → M → N} (h_Zero : ∀ (a : α), a ∈ f.support ∪ g.support → h a 0 = 0) (h_Add : ∀ (a : α), a ∈ f.support ∪ g.support → ∀ (b₁ b₂ : M), h a (b₁ + b₂) = h a b₁ + h a b₂) : (f + g).sum h = f.sum h + g.sum h
(α : Type u) [Semiring α] [Nontrivial α] : ∃ (M : Ideal α), M.is_Maximal
{α : Type u_1} {ι : sort u_4} [CompleteLattice α] {b : α} {f : ι → α} (h₁ : ∀ (i : ι), b ≤ f i) (h₂ : ∀ (w : α), b < w → (∃ (i : ι), f i < w)) : (⨅ (i : ι), f i) = b
(x : ℝ) : 0 < Real.cosh x
{n p : ℕ} (hp : Nat.Prime p) : multiplicity p (p * (n + 1)).factorial = multiplicity p (p * n).factorial + multiplicity p (n + 1) + 1
{𝕂 : Type u_1} [NondiscreteNormedField 𝕂] [CompleteSpace 𝕂] [CharZero 𝕂] {x : 𝕂} (hx : x ∈ Emetric.Ball 0 (Exp_series 𝕂 𝕂).radius) : HasDerivAt (Exp 𝕂) (Exp 𝕂 x) x
{R : Type u_1} [MulOneClass R] : IsRegular 1
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} [Nontrivial k] {p : ι → P} (ha : AffineIndependent k p) : Function.Injective p
{a b c : ℤ} (h : fermat_42 a b c) : ∃ (a0 b0 c0 : ℤ), fermat_42.minimal a0 b0 c0 ∧ a0 % 2 = 1 ∧ 0 < c0
{α : Type u_1} {β : Type u_2} [has_Add α] [Preorder α] [Preorder β] [CovariantClass α α has_add.add has_lt.lt] [CovariantClass α α (Function.swap has_add.add) has_le.le] {f g : β → α} (hF : Monotone f) (hg : StrictMono g) : StrictMono (λ (x : β), f x + g x)
(p : ℕ) [hp : Fact (Nat.Prime p)] {n i j : ℕ} (hi : i < n) (hj : j < p ^ (n - i)) : j - pnat_multiplicity p ⟨j + 1, _⟩ + n = i + j + (n - i - pnat_multiplicity p ⟨j + 1, _⟩)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {n : ℕ} (s : Affine.Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ℕ} (h : fs.card = m + 1) (i : Fin (m + 1)) : (s.face h).points i = s.points (⇑(fs.order_emb_of_Fin h) i)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (p : ι → P) : (s.affine_combination p).linear = s.weighted_vsub p
{α : Type u} (ls : List (List α)) [DecidableEq α] (x : α) (hx : ∀ (l : List α), l ∈ ls → x ∉ l) (hls : ls ≠ List.nil) : list.split_on x ([x].intercalate ls) = ls
{β : Type u} {α : Type v} {γ : Type w} [AddCommMonoid β] [AddCommMonoid γ] (g : β →+ γ) (f : α → β) (s : Finset α) : ⇑g (s.sum (λ (x : α), f x)) = s.sum (λ (x : α), ⇑g (f x))
{C : Type u₁} [CategoryTheory.Category C] {X₁₁ X₁₂ X₂₁ X₂₂ X₃₁ X₃₂ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₂₁ : X₂₁ ⟶ X₂₂} {h₃₁ : X₃₁ ⟶ X₃₂} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₂₁ : X₂₁ ⟶ X₃₁} {v₂₂ : X₂₂ ⟶ X₃₂} (s : CategoryTheory.IsPullback h₁₁ v₁₁ v₁₂ h₂₁) (t : CategoryTheory.IsPullback h₂₁ v₂₁ v₂₂ h₃₁) : CategoryTheory.IsPullback h₁₁ (v₁₁ ≫ v₂₁) (v₁₂ ≫ v₂₂) h₃₁
{M₀ : Type u_1} [MonoidWithZero M₀] [Nontrivial M₀] (u : M₀ˣ) : ↑u ≠ 0
{C : Type u} [CategoryTheory.Category C] (P Q : C) [CategoryTheory.Limits.HasBinaryProduct P Q] : CategoryTheory.Limits.HasBinaryProduct Q P
 : (Polynomial_Functions UnitInterval).topological_Closure = ⊤
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (F : C ⥤ D) {X Y Z : C} {f : X ⟶ Y} {g : Y ⟶ Z} [CategoryTheory.Abelian C] [CategoryTheory.Abelian D] [F.additive] [CategoryTheory.Limits.PreservesFiniteColimits F] [CategoryTheory.Epi g] (ex : CategoryTheory.Exact f g) : CategoryTheory.Exact (F.map f) (F.map g)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) {p : P} (hr : ∃ (r : ℝ), ∀ (i : Fin (n + 1)), HasDist.dist (s.points i) p = r) : ↑(⇑(s.orthogonal_projection_Span) p) = s.circumcenter
{k : Type u_1} {E : Type u_2} [LinearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k → E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : f (⇑(affine_map.line_Map a b) r) < ⇑(affine_map.line_Map (f a) (f b)) r ↔ slope f a b < slope f (⇑(affine_map.line_Map a b) r) b
{α : Type u} {β : Type v} : (α ↪ β) → (β ↪ α) → Nonempty (α ≃ β)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h2 : p2 ≠ p1) (h3 : p3 ≠ p1) : EuclideanGeometry.angle p1 p2 p3 + EuclideanGeometry.angle p2 p3 p1 + EuclideanGeometry.angle p3 p1 p2 = Real.pi
{G : Type u_6} {H : Type u_7} {F : Type u_8} [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) (g : G) (n : ℤ) : ⇑f (g ^ n) = ⇑f g ^ n
{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] {n : Type w} [Nontrivial R] [NoZeroDivisors R] (B : BilinForm R M) (v : Basis n R M) (hO : B.is_Ortho ⇑v) : B.nondegenerate ↔ ∀ (i : n), ¬B.is_IsOrtho (⇑v i) (⇑v i)
{X : Type u_1} [TopologicalSpace X] [CompactSpace X] {Y : Type u_2} [TopologicalSpace Y] : IsClosedMap Prod.snd
{n : ℕ} : IsPrimePow n ↔ ∃! (p : ℕ), Nat.Prime p ∧ p ∣ n
{α : Type u} (x : α) : Function.IsFixedPt Id x
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {n : WithTop ℕ} : ContDiff 𝕜 n f ↔ HasFtaylorSeriesUpTo n f (ftaylor_series 𝕜 f)
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] (Q : QuadraticForm R M) (m : M) : ⇑(CliffordAlgebraι Q) m * ⇑(CliffordAlgebraι Q) m = ⇑(Algebra_Map R (CliffordAlgebra Q)) (⇑Q m)
(𝕜 : Type u_5) (E : Type u_6) [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [Nontrivial E] : NoncompactSpace E
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [NondiscreteNormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] : Continuous (λ (p : ContinuousMultilinearMap 𝕜 E G × Π (i : ι), E i), ⇑(p.fst) p.snd)
{G : Type u_1} [AddCommMonoid G] (tG : Add_monoid.is_torsion G) : Add_comm_monoid.add_torsion G = ⊤
{M : Type u_1} [has_Add M] {c d : AddCon M} (H : ∀ (x y : M), ⇑c x y ↔ ⇑d x y) : c = d
{K : Type u_4} {L : Type u_5} [Field K] [Field L] [Algebra K L] [FiniteDimensional K L] {x : L} : ⇑(Algebra.norm K) x = 0 ↔ x = 0
{x : ℝ} (h : 0 < x) (h' : x ≤ 1) : x - x ^ 3 / 4 < Real.sin x
{γ : Type w} [MetricSpace γ] {x y : γ} : HasNndist.nndist x y = 0 ↔ x = y
{K : Type u} [Field K] (s : Subfield K) (m : Multiset K) : (∀ (a : K), a ∈ m → a ∈ s) → m.prod ∈ s
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (G : C ⥤ D) [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) G] : CategoryTheory.Limits.HasTerminal D
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b : α} : 0 < a - b → b < a
(p : ℕ) [Fact (Nat.Prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_Sym p (a ^ 2) = 1
{α : Type u} (S T : Set α) : Cardinal.mk ↥(S ∪ T) ≤ Cardinal.mk ↥S + Cardinal.mk ↥T
{ι : Type u} (s : Finset ι) (f g : ι → Nnreal) {p q : ℝ} (hpq : p.is_conjugate_exponent q) : s.sum (λ (i : ι), f i * g i) ≤ s.sum (λ (i : ι), f i ^ p) ^ (1 / p) * s.sum (λ (i : ι), g i ^ q) ^ (1 / q)
{R : Type u} [CommRing R] {P : Ideal R} (H : P.is_Prime) : is_IsDomain (Polynomial R ⧸ Ideal.map Polynomial.c P)
(G : Type u_1) [Monoid G] (L : Type u_2) [CommRing L] [NoZeroDivisors L] : LinearIndependent L (λ (f : G →* L), ⇑f)
{α : Type u} {s : Set α} : s.countable → {t : Set α | t.finite ∧ t ⊆ s}.countable
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {ι : Type u_1} (b : Basis ι R M) {κ : Type u_1} (v : κ → M) (i : LinearIndependent R v) : Cardinal.mk κ ≤ Cardinal.mk ι
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) [Invertible A] : ⅟ A = A⁻¹
{C D : Type u} [CategoryTheory.Category C] [CategoryTheory.Category D] {A : Type w} [CategoryTheory.Category A] [CategoryTheory.Limits.HasLimits A] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {G : C ⥤ D} (hu : CategoryTheory.CoverLifting J K G) (ℱ : CategoryTheory.Sheaf J A) {X : A} {U : D} {S : CategoryTheory.Sieve U} (hS : S ∈ ⇑K U) {x : CategoryTheory.Presieve.FamilyOfElements ((CategoryTheory.ran G.op).obj ℱ.val ⋙ Category_theory.coyoneda.obj (Opposite.op X)) S.arrows} (hx : x.compatible) : x.is_amalgamation (CategoryTheory.ran_is_sheaf_of_cover_lifting.glued_section hu ℱ hS hx)
(R : Type u_1) [CommRing R] (M : Type u_2) [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] [Nontrivial R] : LinearMap.trace R M = (contract_Left R M).comp (dual_tensor_hom_Equiv R M M).symm.to_Linear_Map
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) {r : Nnreal} (h0 : 0 < r) (h : ↑r < p.radius) : ∃ (C : ℝ) (H : C > 0), ∀ (n : ℕ), ∥p n∥ ≤ C / ↑r ^ n
{𝒪 : Type u} {K : Type v} {Γ : Type w} [CommRing 𝒪] [is_IsDomain 𝒪] [Field K] [Algebra 𝒪 K] [LinearOrderedCommGroupWithZero Γ] (v : Valuation K Γ) (hH : v.integers 𝒪) : ValuationRing 𝒪
{β : Type u} {α : Type v} [AddCommMonoid β] [DecidableEq α] (s : Finset α) (f : α → β) {a : α} (h : a ∈ s) : (s.erase a).sum (λ (x : α), f x) + f a = s.sum (λ (x : α), f x)
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} : finprod (λ (i : α), finprod (λ (H : i ∈ ∅), f i)) = 1
{α : Type u_1} {n : Type u_3} [DecidableEq n] [HasZero α] (v : n → α) : (Matrix.diagonal v).is_Symm
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {s : Set E} {f : E → F} {n : WithTop ℕ} (e : G ≃L[𝕜] E) : ContDiffOn 𝕜 n (f ∘ ⇑e) (⇑e ⁻¹' s) ↔ ContDiffOn 𝕜 n f s
{α : Type u_1} {ι : sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α} (h : l.has_Basis p s) {V : Set α} (hV : V ∈ l) : l.has_Basis (λ (i : ι), p i ∧ s i ⊆ V) s
{α : Type u} [TopologicalSpace α] {s : Set α} : is_IsCompact s ↔ ∀ {ι : Type u} (Z : ι → Set α), (∀ (i : ι), is_IsClosed (Z i)) → (s ∩ ⋂ (i : ι), Z i) = ∅ → (∃ (t : Finset ι), (s ∩ ⋂ (i : ι) (H : i ∈ t), Z i) = ∅)
{α : Type u} [LinearOrderedField α] [TopologicalSpace α] [OrderTopology α] : Filter.Tendsto (λ (x : α), x⁻¹) (nhds_within 0 (Set.Ioi 0)) filter.at_Top
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (t : Affine.Triangle ℝ P) : t.orthocenter = affine.simplex.monge_point t
{α : sort u_1} {β : sort u_2} {γ : sort u_3} {g : β → γ} (hg : Function.Injective g) : Function.Injective (Function.comp g)
(o : Ordinal) : o.to_pgame.numeric
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α} {p : Filter ι} {g : ι → α} [TopologicalSpace α] (h : TendstoUniformlyOn F f p s) (hF : ContinuousWithinAt f s x) (hg : Filter.Tendsto g p (nhds_within x s)) : Filter.Tendsto (λ (n : ι), F n (g n)) p (nhds (f x))
{a b : ℝ} {g' g : ℝ → ℝ} (hab : a ≤ b) (hcont : ContinuousOn g (Set.Icc a b)) (hderiv : ∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivAt g (g' x) x) (g'Pos : ∀ (x : ℝ), x ∈ Set.Ioo a b → 0 ≤ g' x) : MeasureTheory.IntegrableOn g' (Set.Ioc a b) MeasureTheory.MeasureSpace.volume
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) : (s.circumcenter_circumradius.fst ∈ affine_Span ℝ (Set.Range s.points) ∧ ∀ (i : Fin (n + 1)), HasDist.dist (s.points i) s.circumcenter_circumradius.fst = s.circumcenter_circumradius.snd) ∧ ∀ (cccr : P × ℝ), (cccr.fst ∈ affine_Span ℝ (Set.Range s.points) ∧ ∀ (i : Fin (n + 1)), HasDist.dist (s.points i) cccr.fst = cccr.snd) → cccr = s.circumcenter_circumradius
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] {f : α → β} {s : Set α} {a : α} (h_Mono : StrictMonoOn f s) (hs : s ∈ nhds_within a (Set.Iic a)) (hfs : ∀ (b : β), b < f a → (∃ (c : α) (H : c ∈ s), f c ∈ Set.Ico b (f a))) : ContinuousWithinAt f (Set.Iic a) a
(A : Type u_1) (B : Type u_2) [Field A] [Ring B] [Algebra A B] [Nontrivial B] : minpoly A 0 = Polynomial.x
{G : Type u_1} [Group G] {ι : sort u_2} (S : ι → Subgroup G) {C : Π (x : G), (x ∈ ⨆ (i : ι), S i) → Prop} (hp : ∀ (i : ι) (x : G) (H : x ∈ S i), C x _) (h1 : C 1 _) (hMul : ∀ (x y : G) (hx : x ∈ ⨆ (i : ι), S i) (hy : y ∈ ⨆ (i : ι), S i), C x hx → C y hy → C (x * y) _) {x : G} (hx : x ∈ ⨆ (i : ι), S i) : C x hx
(x : ℝ) : Real.arsinh (Real.sinh x) = x
(n : ℕ) {a : ℝ} (h : 2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ Real.sqrt_two_Add_series (↑0 / ↑1) n) (h₂ : 1 / 4 ^ n ≤ a) : Real.pi < a
{α : sort u} {β : sort v} {f : α → β} (hF : Function.Injective f) [Subsingleton β] : Subsingleton α
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] {p : P} (hp : p ∉ s) : HasDist.dist p ↑(⇑(euclidean_geometry.orthogonal_projection s) p) ≠ 0
(P : ℕ → ℕ → Prop) (ha : ∀ (a : ℕ), P (a + 1) (a + 1)) (hb : ∀ (b : ℕ), P 0 (b + 1)) (hD : ∀ (a b : ℕ), a < b → P (a + 1) b → P a (b + 1) → P (a + 1) (b + 1)) (a b : ℕ) : a < b → P a b
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] (p : P) : Function.Injective (λ (_x : P), _x -ᵥ p)
{G : Type u_1} [Group G] [hG : group.is_nilpotent G] : Nat.find _ = group.nilpotency_class G
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} {p : ι → P} (ha : AffineIndependent k p) : AffineIndependent k (λ (x : ↥(Set.Range p)), ↑x)
{α : Type u_1} [Preorder α] {a b : α} (h : a < b) : ¬IsMax a
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} {g : ℝ → E} (fdiff : DifferentiableOn ℝ f (Set.Icc a b)) (gdiff : DifferentiableOn ℝ g (Set.Icc a b)) (hderiv : Set.EqOn (deriv_within f (Set.Icc a b)) (deriv_within g (Set.Icc a b)) (Set.Ico a b)) (hi : f a = g a) (y : ℝ) (H : y ∈ Set.Icc a b) : f y = g y
{G : Type u_7} [Group G] (L : List G) : (L.prod)⁻¹ = (List.map (λ (x : G), x⁻¹) L).reverse.prod
{α : Type u_1} {β : Type u_2} {f : α → β} {m : MeasurableSpace α} [TopologicalSpace β] [TopologicalSpace.PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β] : MeasureTheory.StronglyMeasurable f ↔ Measurable f ∧ TopologicalSpace.IsSeparable (Set.Range f)
{n : ℕ} : order_of (QuaternionGroup.a 1) = 2 * n
{α : Type u_1} [TopologicalSpace α] {x : α} {γ : Type u_4} [LinearOrderedAddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] {f g : α → γ} (hF : UpperSemicontinuousAt f x) (hg : UpperSemicontinuousAt g x) (hcont : ContinuousAt (λ (p : γ × γ), p.fst + p.snd) (f x, g x)) : UpperSemicontinuousAt (λ (z : α), f z + g z) x
{R : Type u_1} [CommSemiring R] {M : Submonoid R} {S : Type u_2} [CommSemiring S] [Algebra R S] {P : Type u_3} [CommSemiring P] [IsLocalization M S] {g : R →+* P} (hg : ∀ (y : ↥M), IsUnit (⇑g ↑y)) (x : R) (y : ↥M) : ⇑(IsLocalization.lift hg) (IsLocalization.mk' S x y) = ⇑g x * ↑(⇑(is_unit.lift_Right (g.to_Monoid_hom.restrict M) hg) y)⁻¹
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {f : ℂ → E} (hD : DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hre : ∀ (x : ℝ), x ≤ 0 → f ↑x = 0) (him : ∀ (x : ℝ), x ≤ 0 → f (↑x * Complex.i) = 0) : Set.EqOn f 0 {z : ℂ | z.re ≤ 0 ∧ z.im ≤ 0}
{α : Type u_1} {G : Type u_4} [ConditionallyCompleteLattice α] [Group G] (f₁ f₂ : G →* α ≃o α) (hbdd : ∀ (x : α), BddAbove (Set.Range (λ (g : G), ⇑(⇑f₁ g)⁻¹ (⇑(⇑f₂ g) x)))) (g : G) : Function.Semiconj (λ (x : α), ⨆ (g' : G), ⇑(⇑f₁ g')⁻¹ (⇑(⇑f₂ g') x)) ⇑(⇑f₂ g) ⇑(⇑f₁ g)
{R : Type u_1} {A : Type u_2} {M : Type u_3} {N : Type u_4} {P : Type u_5} [CommSemiring R] [Semiring A] [Algebra R A] [AddCommMonoid M] [Module R M] [Module A M] [IsScalarTower R A M] [AddCommMonoid N] [Module R N] [AddCommMonoid P] [Module R P] [Module A P] [IsScalarTower R A P] : Function.Injective TensorProduct.AlgebraTensorModule.curry
{C : Type u} [CategoryTheory.Category C] {X : C} (i : CategoryTheory.Arrow C) : CategoryTheory.HasLiftingProperty i (CategoryTheory.Arrow.mk (𝟙 X))
{α : Type u} [SemilatticeSup α] [Nonempty α] (s : Finset α) : BddAbove ↑s
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : (Matrix n n α)ˣ) : ↑A⁻¹ = (↑A)⁻¹
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommGroup β] [HasScalar 𝕜 E] [Module 𝕜 β] {s : Set E} {f : E → β} : ConvexOn 𝕜 s (-f) ↔ ConcaveOn 𝕜 s f
{X : Type u_2} [EmetricSpace X] [MeasurableSpace X] [BorelSpace X] {m₁ m₂ : Ennreal → Ennreal} (hle : m₁ ≤ᶠ[nhds_within 0 (Set.Ici 0)] m₂) : measure_theory.measure.mk_metric m₁ ≤ measure_theory.measure.mk_metric m₂
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {s : AffineSubspace k P} (h : ↑s.nonempty) : s.direction = ⊤ ↔ s = ⊤
{G : Type u_1} [AddGroup G] {k : Set G} : k ⊆ ↑(AddSubgroup.closure k)
{C : Type u} [CategoryTheory.Category C] {A B : C} {f g : A ⟶ B} [CategoryTheory.IsReflexivePair f g] : CategoryTheory.IsReflexivePair g f
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {c : Con M} {f : M →* P} (H : c ≤ Con.ker f) : (c.lift f H).comp c.mk' = f
{M : Type u_1} [SemiNormedGroup M] (S : AddSubgroup M) : S.normed_mk.ker = S
{α : Type u_1} [NonUnitalSemiNormedRing α] (x y : α) : ∥⇑(AddMonoid_hom.mul_Right x) y∥ ≤ ∥x∥ * ∥y∥
{R : Type u} [CommRing R] {n : ℕ} (u : Rˣ) (hn : IsUnit ↑n) : (Polynomial.x ^ n - ⇑Polynomial.c ↑u).separable
{α : sort u_1} (x : α) (h : ∀ (y : α), y = x) : Subsingleton α
{α : Type u_1} (L : List (List α)) (i : ℕ) : List.take (List.take i (List.map List.length L)).sum L.join = (List.take i L).join
{K : Type u_1} {Kₘ : Type u_2} [Field K] [CommRing Kₘ] {M : Submonoid K} (hM : 0 ∉ M) [Algebra K Kₘ] [IsLocalization M Kₘ] : Function.bijective ⇑(Algebra_Map K Kₘ)
{R₁ : Type u_1} {R₂ : Type u_2} [Semiring R₁] [Semiring R₂] {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_4} [TopologicalSpace M₁] [AddCommMonoid M₁] {M₂ : Type u_6} [TopologicalSpace M₂] [AddCommMonoid M₂] [Module R₁ M₁] [Module R₂ M₂] [t2_Space M₂] {s : Set M₁} (hs : Dense ↑(Submodule.span R₁ s)) {f g : M₁ →sl[σ₁₂] M₂} (h : Set.EqOn ⇑f ⇑g s) : f = g
{M : Type u_1} [AddMonoid M] {s : Set M} {a : M} (hs : IsAddSubmonoid s) (h : a ∈ s) {n : ℕ} : n • a ∈ s
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) {x : L} : x ∈ S → x⁻¹ ∈ S
{X : Type u_1} [UniformSpace X] {s : Set X} [(Uniformity X).is_countably_generated] : is_IsCompact s ↔ IsSeqCompact s
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (x : Module.Ray R M) : ⟦x.some_RayVector⟧ = x
{α : Type u_1} [TopologicalSpace α] {γ : Type u_4} [LinearOrderedAddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] [HasContinuousAdd γ] {f g : α → γ} (hF : LowerSemicontinuous f) (hg : LowerSemicontinuous g) : LowerSemicontinuous (λ (z : α), f z + g z)
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b
{α : Type u_1} {β : Type u_2} {f g : α → β} {m : MeasurableSpace α} {mβ : MeasurableSpace β} {p : α → Prop} {_x : DecidablePred p} (hp : MeasurableSet {a : α | p a}) (hF : Measurable f) (hg : Measurable g) : Measurable (λ (x : α), Ite (p x) (f x) (g x))
{α : Type u} [TopologicalSpace α] (a : α) : (nhds a).has_Basis (λ (s : Set α), a ∈ s ∧ is_IsOpen s) (λ (s : Set α), s)
{α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [LinearOrderedAddCommGroup α] [Archimedean α] (h : Function.Periodic f c) (hc : 0 < c) (x a : α) : ∃ (y : α) (H : y ∈ Set.Ico a (a + c)), f x = f y
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {V₂ : Type u_5} {P₂ : Type u_6} [AddCommGroup V₂] [Module k V₂] [AddTorsor V₂ P₂] {s : Set P} (e : P ≃ᵃ[k] P₂) : AffineIndependent k Coe ↔ AffineIndependent k Coe
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (X : CategoryTheory.SimplicialObject C) (n : ℕ) : algebraic_topology.alternating_face_Map_complex.obj_d X (n + 1) ≫ algebraic_topology.alternating_face_Map_complex.obj_d X n = 0
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] {v : E} : ↑(⇑(Orthogonal_projection K) v) = v ↔ v ∈ K
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [SemiNormedGroup F'] {f : α → E} {g' : α → F'} {l : Filter α} : (f =O[l] λ (x : α), ∥g' x∥) → f =O[l] g'
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] (X : C) (h : ∀ {Z : C} (f : X ⟶ Z) [_inst_3 : CategoryTheory.Epi f], CategoryTheory.IsIso f ↔ f ≠ 0) : CategoryTheory.Simple X
{R : Type u_1} {S : Type u_2} [EuclideanDomain R] [CommRing S] [is_IsDomain S] [Algebra R S] (abv : AbsoluteValue R ℤ) {ι : Type u_5} [DecidableEq ι] [Fintype ι] (bS : Basis ι R S) {T : Type u_3} [LinearOrderedRing T] (a : S) {y : T} (hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y) : ↑(⇑abv (⇑(Algebra.norm R) a)) < ↑(class_group.norm_bound abv bS) * y ^ Fintype.card ι
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (s : Finset ι) [CharZero k] [Fintype ι] {n : ℕ} (h : s.card = n + 1) : finset.univ.sum (λ (i : ι), Finset.centroid_weights_indicator k s i) = 1
{M : Type u_1} [AddMonoid M] {s₁ s₂ : Set M} (is₁ : IsAddSubmonoid s₁) (is₂ : IsAddSubmonoid s₂) : IsAddSubmonoid (s₁ ∩ s₂)
{M : Type u_1} [HasMul M] {c d : Con M} : Setoid.r = Setoid.r ↔ c = d
{α : Type u_1} {β : Type u_2} {α₂ : Type u_3} [Semiring β] [HasMul α] [HasMul α₂] {F : Type u_4} [MulHomClass F α α₂] (f : F) (x y : MonoidAlgebra β α) : finsupp.map_IsDomain ⇑f (x * y) = finsupp.map_IsDomain ⇑f x * finsupp.map_IsDomain ⇑f y
{R : Type u_1} [OrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {x y : M} : SameRay R (-x) (-y) ↔ SameRay R x y
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {D : Type u₁} [CategoryTheory.Category D] (h : C ≌ D) : CategoryTheory.IsFiltered D
{p : Polynomial ℚ} (p_irr : Irreducible p) (p_deg : Nat.Prime p.nat_degree) (p_roots1 : Fintype.card ↥(p.root_Set ℝ) + 1 ≤ Fintype.card ↥(p.root_Set ℂ)) (p_roots2 : Fintype.card ↥(p.root_Set ℂ) ≤ Fintype.card ↥(p.root_Set ℝ) + 3) : Function.bijective ⇑(polynomial.gal.gal_action_hom p ℂ)
{G : Type u_1} [LinearOrderedAddCommGroup G] [Archimedean G] {H : AddSubgroup G} {a : G} (ha : IsLeast {g : G | g ∈ H ∧ 0 < g} a) : H = AddSubgroup.closure {a}
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
{m : ℕ} (hm : 0 < m) (k : ℕ) : ∃ (p : ℕ), liouville.liouville_number_initial_terms ↑m k = ↑p / ↑m ^ k.factorial
{α : Type u_1} [HasLe α] {a : αᵒᵈ} : IsBot a → IsTop (⇑order_dual.of_dual a)
{J : Type v} {C : Type u} [CategoryTheory.Category C] {X Y : C} {f : J → (X ⟶ Y)} [Nonempty J] {t : CategoryTheory.Limits.Trident f} (ht : CategoryTheory.Limits.IsLimit t) {Z Z' : C} (q : Z' ⟶ Z) (k : Z ⟶ t.X) : ↑(⇑(Category_theory.limits.trident.is_limit.hom_iso ht Z') (q ≫ k)) = q ≫ ↑(⇑(Category_theory.limits.trident.is_limit.hom_iso ht Z) k)
{α : Type u_1} {β : Type u_2} [LinearOrder α] [PredOrder α] [Preorder β] {f : α → β} (hF : Monotone f) : Pairwise (Disjoint on λ (n : α), Set.Ico (f (Order.pred n)) (f n))
{β : Type u} {γ : Type w} [CommSemiring β] [CommSemiring γ] (f : β →+* γ) (s : Multiset β) : ⇑f s.prod = (Multiset.map ⇑f s).prod
{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), Monoid (Gs i)] {x : Π (i : η), Gs i} (h : IsOfFinOrder x) (i : η) : IsOfFinOrder (x i)
{α : Type u_3} {β : Type u_4} [LinearOrderedField α] {l : Filter β} {f : β → α} {r : α} (hr : 0 < r) (hF : Filter.Tendsto f l filter.at_IsBot) : Filter.Tendsto (λ (x : β), f x / r) l filter.at_IsBot
{α : Type u} {β : Type v} [AddZeroClass α] [AddZeroClass β] {f : α → β} (hF : IsAddMonoidHom f) (x y : α) : f (x + y) = f x + f y
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : ∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * HasInner.inner x y + ∥y∥ ^ 2
{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] {s : Set E} (hs : Convex 𝕜 s) {x y : E} (hx : x ∈ s) (hy : y ∈ Interior s) {t : 𝕜} (ht : t ∈ Set.Ioc 0 1) : x + t • (y - x) ∈ Interior s
(𝕜 : Type u_1) [NondiscreteNormedField 𝕜] {n : WithTop ℕ} {R : Type u_6} [NormedRing R] [NormedAlgebra 𝕜 R] [CompleteSpace R] (x : Rˣ) : ContDiffAt 𝕜 n Ring.inverse ↑x
{K : Type u} [Field K] (s : Subfield K) {x : K} : x ∈ s → x⁻¹ ∈ s
{K : Type u_1} [Field K] (f : Polynomial K) (a : K) (hF' : Polynomial.eval a (⇑Polynomial.derivative f) ≠ 0) : IsCoprime (Polynomial.x - ⇑Polynomial.c a) (f /ₘ (Polynomial.x - ⇑Polynomial.c a))
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)] {X : Top} (F : Top.Presheaf C X) : F.is_sheaf ↔ F.is_sheaf_Unique_gluing
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y : M} {r : R} (h : SameRay R x y) (hr : 0 < r) : SameRay R x (r • y)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : InnerProductSpace.IsSelfAdjoint T) {V : Submodule 𝕜 E} (hV : ∀ (v : E), v ∈ V → ⇑T v ∈ V) : InnerProductSpace.IsSelfAdjoint (T.restrict hV)
{α : Type u} [t : TopologicalSpace α] {a : α} {s : Set α} {b : Set (Set α)} (hb : TopologicalSpace.IsTopologicalBasis b) : s ∈ nhds a ↔ ∃ (t : Set α) (H : t ∈ b), a ∈ t ∧ t ⊆ s
{n : ℕ} {i : Fin (n + 1)} : SimplexCategoryδ i.succ ≫ SimplexCategoryσ i = 𝟙 (SimplexCategory.mk n)
{G : Type u_1} [Group G] (H : Subgroup G) [H.normal] : upper_central_series_step H = Subgroup.comap (QuotientGroup.mk' H) (Subgroup.center (G ⧸ H))
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] (s : Set P) [FiniteDimensional k ↥(Vector_Span k s)] : Collinear k s ↔ FiniteDimensional.finrank k ↥(Vector_Span k s) ≤ 1
{R : Type u_4} [LinearOrderedRing R] (a : R) (h : a ≠ 0) : 0 < a ^ 2
{n : ℕ} {α : Type u_1} {v : Vector α n} : v.reverse.to_List = v.to_list.reverse
{R : Type u_1} [Ring R] {M : Type u_2} [AddCommGroup M] [Module R M] {N : Type u_3} [AddCommGroup N] [Module R N] [IsSimpleModule R M] [IsSimpleModule R N] (f : M →ₗ[R] N) : Function.bijective ⇑f ∨ f = 0
{r : ℝ} (hr : 0 ≤ r) (h'r : r < 1) : Filter.Tendsto (λ (n : ℕ), ↑n * r ^ n) filter.at_Top (nhds 0)
(K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [Module.Finite K L] {R : Type z} [CommRing R] [Algebra R K] [Algebra R L] [IsScalarTower R K L] [is_IsDomain R] [IsSeparable K L] [IsIntegrallyClosed R] [IsFractionRing R K] {B : PowerBasis K L} (hint : IsIntegral R B.gen) {z : L} (hz : IsIntegral R z) : Algebra.discr K ⇑(B.basis) • z ∈ Algebra.adjoin R {B.gen}
{ι : Type u_1} {E : ι → Type u_2} [Π (i : ι), MetricSpace (E i)] [∀ (i : ι), CompleteSpace (E i)] : CompleteSpace (Σ (i : ι), E i)
{F : Type u_8} {G : Type u_1} {H : Type u_2} [Group G] [MulOneClass H] [MonoidHomClass F G H] (f : F) : Function.Injective ⇑f ↔ ∀ (a : G), ⇑f a = 1 → a = 1
{α : Type u_1} {𝕜 : Type u_14} [NormedField 𝕜] {l : Filter α} {f g : α → 𝕜} (hgf : ∀ (x : α), g x = 0 → f x = 0) : Filter.Tendsto (λ (x : α), f x / g x) l (nhds 0) → f =o[l] g
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {f : ℂ → E} (hD : DiffContOnCl ℂ f (Set.Ioi 0 ×ℂ Set.Iio 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Iio 0)] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hre : ∀ (x : ℝ), 0 ≤ x → f ↑x = 0) (him : ∀ (x : ℝ), x ≤ 0 → f (↑x * Complex.i) = 0) : Set.EqOn f 0 {z : ℂ | 0 ≤ z.re ∧ z.im ≤ 0}
{X : Type u_1} [TopologicalSpace X] {x y : X} {F : Set X} (h : JoinedIn F x y) : Joined ⟨x, _⟩ ⟨y, _⟩
{α : Type u_1} {β : Type u_2} {m₁ : MeasurableSpace α} {m₂ : MeasurableSpace β} {f : α → β} : Measurable f → MeasurableSpace.comap f m₂ ≤ m₁
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {s : Set E} [CompleteSpace F] (h : AnalyticOn 𝕜 f s) : AnalyticOn 𝕜 (fderiv 𝕜 f) s
(k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] [Fintype ι] (p : ι → P) {n : ℕ} (hc : Fintype.card ι = n + 1) : AffineIndependent k p ↔ FiniteDimensional.finrank k ↥(Vector_Span k (Set.Range p)) = n
{α : Type u} [AddCommGroup α] [HasLe α] [CovariantClass α α has_add.add has_le.le] {a b c : α} : a + b ≤ c → b ≤ c - a
{R : Type u} [Ring R] {s : Set R} : s ⊆ ↑(Subring.closure s)
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {f g : ℂ → E} (hdf : DiffContOnCl ℂ f (Set.Ioi 0 ×ℂ Set.Ioi 0)) (hBf : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Ioi 0)] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hdg : DiffContOnCl ℂ g (Set.Ioi 0 ×ℂ Set.Ioi 0)) (hBg : ∃ (c : ℝ) (H : c < 2) (B : ℝ), g =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Ioi 0)] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hre : ∀ (x : ℝ), 0 ≤ x → f ↑x = g ↑x) (him : ∀ (x : ℝ), 0 ≤ x → f (↑x * Complex.i) = g (↑x * Complex.i)) : Set.EqOn f g {z : ℂ | 0 ≤ z.re ∧ 0 ≤ z.im}
{K : Type u_1} {v : K} {n : ℕ} [LinearOrderedField K] [FloorRing K] {b : K} (nth_Part_denom_Eq : (GeneralizedContinuedFraction.of v).partial_denominators.nth n = Option.some b) : ∃ (z : ℤ), b = ↑z
(R : Type u_1) [CommRing R] (m k : ℕ) : 2 * Polynomial.Chebyshev.t R m * Polynomial.Chebyshev.t R (m + k) = Polynomial.Chebyshev.t R (2 * m + k) + Polynomial.Chebyshev.t R k
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {D : Type u_3} [CategoryTheory.Category D] [CategoryTheory.Preadditive D] (G : C ⥤ D) [G.additive] (X : CategoryTheory.SimplicialObject C) (q n : ℕ) : (algebraic_topology.dold_kan.Hσ q).f n = G.map ((algebraic_topology.dold_kan.Hσ q).f n)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {D : Type u₁} [CategoryTheory.Category D] {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) : CategoryTheory.IsCofiltered D
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {c : Con M} {f : M →* P} (H : c ≤ Con.ker f) (g : c.quotient →* P) (Hg : g.comp c.mk' = f) : g = c.lift f H
(G : Type u_1) [Group G] (n : ℕ) (x : G) : x ∈ upper_central_series G (n + 1) ↔ ∀ (y : G), x * y * x⁻¹ * y⁻¹ ∈ upper_central_series G n
(p : ℕ) [Fact (Nat.Prime p)] (a b : ℤ) : zmod.legendre_Sym p (a * b) = zmod.legendre_Sym p a * zmod.legendre_Sym p b
{V : Type u_9} {K : Type u_10} [Field K] [AddCommGroup V] [Module K V] {B : BilinForm K V} {x : V} (hx : ¬B.is_IsOrtho x x) : IsCompl (Submodule.span K {x}) (B.orthogonal (Submodule.span K {x}))
{R : Type u_1} {a b : R} [Semigroup R] (rra : IsRightRegular a) (rrb : IsRightRegular b) : IsRightRegular (a * b)
(α : Type u) [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] [TopologicalSpace.SeparableSpace α] [Nontrivial α] : ∃ (s : Set α), s.countable ∧ Dense s ∧ (∀ (x : α), IsBot x → x ∉ s) ∧ ∀ (x : α), IsTop x → x ∉ s
{C : Type u₁} [CategoryTheory.Category C] {B A : C} {X : CategoryTheory.Subobject B} (f : A ⟶ B) [CategoryTheory.Mono f] (i : ↑X ≅ A) (w : i.hom ≫ f = X.arrow) : X = CategoryTheory.Subobject.mk f
{C : Type u₁} [CategoryTheory.Category C] {J : Type u₂} [CategoryTheory.Category J] (F : J ⥤ Cᵒᵖ) [CategoryTheory.Limits.HasLimit F.left_Op] : CategoryTheory.Limits.HasColimit F
(E : Type u_1) [NormedGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E] : ∃ (δ : ℝ), 0 < δ ∧ δ < 1 ∧ ∀ (s : Finset E), (∀ (c : E), c ∈ s → ∥c∥ ≤ 2) → (∀ (c : E), c ∈ s → ∀ (d : E), d ∈ s → c ≠ d → 1 - δ ≤ ∥c - d∥) → s.card ≤ Besicovitch.multiplicity E
{p k : ℕ} (hk : k ≠ 0) (hp : Nat.Prime p) : (p ^ k).factors.to_Finset = {p}
{α : Type u} [PseudoEmetricSpace α] {x y : α} {s : Set α} (hx : x ∈ s) (hy : y ∈ s) : HasEdist.edist x y ≤ Emetric.diam s
{C : Type u₁} [CategoryTheory.Category C] {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂} {h₁₂ : X₁₂ ⟶ X₁₃} {h₂₁ : X₂₁ ⟶ X₂₂} {h₂₂ : X₂₂ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃} (s : CategoryTheory.IsPullback (h₁₁ ≫ h₁₂) v₁₁ v₁₃ (h₂₁ ≫ h₂₂)) (p : h₁₁ ≫ v₁₂ = v₁₁ ≫ h₂₁) (t : CategoryTheory.IsPullback h₁₂ v₁₂ v₁₃ h₂₂) : CategoryTheory.IsPullback h₁₁ v₁₁ v₁₂ h₂₁
{α : Type u_1} {c : Set (Set α)} (H : ∀ (a : α), ∃! (b : Set α) (H : b ∈ c), a ∈ b) : c.pairwise_Disjoint Id
{x : ℝ} (hx : 0 < x) : 0 < Exp_Neg_Inv_glue x
{p : ℕ} [hp : Fact (Nat.Prime p)] {k : Type u_1} [Field k] [Char_p k p] [PerfectRing k p] : DiscreteValuationRing (WittVector p k)
(k : Type u₁) {G : Type u₂} [Semiring k] [has_Add G] {A : Type u₃} [NonUnitalNonAssocSemiring A] [DistribMulAction k A] {φ₁ φ₂ : AddMonoidAlgebra k G →ₙₐ[k] A} (h : φ₁.to_Mul_hom.comp (AddMonoidAlgebra.of_magma k G) = φ₂.to_Mul_hom.comp (AddMonoidAlgebra.of_magma k G)) : φ₁ = φ₂
{α : Type u_1} {p : α → Prop} [DecidablePred p] {s : Finset α} (h : ∀ (x : α), x ∈ s → p x) : Finset.filter p s = s
{a b : Cardinal} : Cardinal.aleph_0 ≤ a * b ↔ a ≠ 0 ∧ b ≠ 0 ∧ (Cardinal.aleph_0 ≤ a ∨ Cardinal.aleph_0 ≤ b)
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {X X' Y Y' Z Z' : C} [CategoryTheory.ExactPairing Y Y'] (f : X ⟶ Z ⊗ Y') (g : X' ⟶ Z') : ⇑((Category_theory.tensor_Right_hom_Equiv (X' ⊗ X) Y Y' (Z' ⊗ Z)).symm) ((g ⊗ f) ≫ (α_ Z' Z Y').inv) = (α_ X' X Y).hom ≫ (g ⊗ ⇑((Category_theory.tensor_Right_hom_Equiv X Y Y' Z).symm) f)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [BaireSpace α] [Encodable β] {f : β → Set α} (hc : ∀ (s : β), is_IsClosed (f s)) (hU : (⋃ (s : β), f s) = Set.Univ) : Dense (⋃ (s : β), Interior (f s))
{α : Type u_1} {E : Type u_3} [SemiNormedGroup E] {f : α → E} {g : α → ℝ} {t₀ : Filter α} (h : ∀ (n : α), ∥f n∥ ≤ g n) (h' : Filter.Tendsto g t₀ (nhds 0)) : Filter.Tendsto f t₀ (nhds 0)
(f : ℕ → Nnreal) : Filter.Tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_Top (nhds 0)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X Y : C} (b : CategoryTheory.Limits.BinaryBicone X Y) (Total : b.fst ≫ b.inl + b.snd ≫ b.inr = 𝟙 b.X) : CategoryTheory.Limits.HasBinaryBiproduct X Y
{α : Type u} [TopologicalSpace α] {s : Set α} [DiscreteTopology ↥s] {x : α} (hx : x ∈ s) : ∃ (U : Set α) (H : U ∈ nhds x), U ∩ s = {x}
{α : Type u} {β : Type v} [CompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [CompleteLinearOrder β] [TopologicalSpace β] [OrderTopology β] {ι : sort u_1} {f : α → β} {g : ι → α} (Cf : ContinuousAt f (infi g)) (Mf : Monotone f) (ftop : f ⊤ = ⊤) : f (infi g) = infi (f ∘ g)
{α : Type u_1} {β : Type u_2} [UniformSpace α] [AddGroup α] [UniformAddGroup α] {hom : Type u_3} [UniformSpace β] [DiscreteTopology β] [AddGroup β] [UniformAddGroup β] [AddMonoidHomClass hom α β] {f : hom} : UniformContinuous ⇑f ↔ is_IsOpen ↑(↑f.ker)
{α : Type u} [TopologicalSpace α] {Z a b : Set α} (h : is_IsClopen Z) (cover : Z ⊆ a ∪ b) (ha : is_IsOpen a) (hb : is_IsOpen b) (hab : a ∩ b = ∅) : is_IsClopen (Z ∩ a)
{ι : Type u_1} {α : Type u_2} [HasZero α] {s : Finset ι} {f : ι →₀ α} {t : ι →₀ Finset α} (ht : t.support ⊆ s) : f ∈ s.finsupp ⇑t ↔ ∀ (i : ι), ⇑f i ∈ ⇑t i
(X : Type u) (Y : Type v) [MetricSpace X] [CompactSpace X] [Nonempty X] [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : Isometry (Gromov_Hausdorff.optimal_GH_injr X Y)
{α : Type u_1} {E : α → Type u_2} [Π (i : α), NormedGroup (E i)] {p q : Ennreal} (hpq : p.to_real.is_conjugate_exponent q.to_Real) (f : ↥(Lp E p)) (g : ↥(Lp E q)) : Summable (λ (i : α), ∥⇑f i∥ * ∥⇑g i∥) ∧ ∑' (i : α), ∥⇑f i∥ * ∥⇑g i∥ ≤ ∥f∥ * ∥g∥
{R : Type u_1} [AddLeftCancelSemigroup R] (g : R) : IsAddLeftRegular g
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] (h : ∀ (x y : E), ∥x + y∥ = ∥x∥ + ∥y∥ → SameRay ℝ x y) : StrictConvexSpace ℝ E
{s : ℂ} (hs : 0 < s.re) {X : ℝ} (hX : 0 ≤ X) : (s + 1).partial_gamma X = s * s.partial_gamma X - ↑(Real.exp (-X)) * ↑X ^ s
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall f p x r) (y : E) : HasFpowerSeriesOnBall (λ (z : E), f (z - y)) p (x + y) r
{α : Type u_1} [CanonicallyOrderedAddMonoid α] [HasSub α] [HasOrderedSub α] {b c : α} [ContravariantClass α α has_add.add has_le.le] (h : c ≤ b) (a : α) : a + b - c = a + (b - c)
(n : ℕ) (x : ℝ) (hx : 0 < x) : HasDerivAt (Exp_Neg_Inv_glue.f_aux n) (Polynomial.eval x (Exp_Neg_Inv_glue.P_aux (n + 1)) * Real.exp (-x⁻¹) / x ^ (2 * (n + 1))) x
{C : Type u} [CategoryTheory.Category C] (F G : CategoryTheory.Discrete PEmpty ⥤ C) : F = G
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] (Q : QuadraticForm R M) (p q : Submodule R (CliffordAlgebra Q)) : Submodule.map CliffordAlgebra.reverse (p * q) = Submodule.map CliffordAlgebra.reverse q * Submodule.map CliffordAlgebra.reverse p
{ι : Type u_1} [Fintype ι] : StdSimplex ℝ ι ⊆ Metric.ClosedBall 0 1
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] : reflection ⊥ = LinearIsometryEquiv.neg 𝕜
{E : Type u_1} [AddCommGroup E] [Module ℝ E] {s : Set E} {x : E} : gauge s x = HasInf.inf {r ∈ Set.Ioi 0 | r⁻¹ • x ∈ s}
{R : Type u_1} [CommSemiring R] {A : Type u_2} [CommSemiring A] [Algebra R A] {M : Type u_3} [AddCommMonoid M] [Module A M] [Module R M] {D1 D2 : Derivation R A M} (s : Set A) (hs : Algebra.adjoin R s = ⊤) (h : Set.EqOn ⇑D1 ⇑D2 s) : D1 = D2
{X : Type u_2} [EmetricSpace X] [MeasurableSpace X] [BorelSpace X] (d : ℝ) (s : Set X) : ⇑(measure_theory.measure.hausdorff_measure d) s = ⨆ (r : Ennreal) (hr : 0 < r), ⨅ (t : ℕ → Set X) (hts : s ⊆ ⋃ (n : ℕ), t n) (ht : ∀ (n : ℕ), Emetric.diam (t n) ≤ r), ∑' (n : ℕ), ⨆ (h : (t n).nonempty), Emetric.diam (t n) ^ d
{x y z : Pgame} (h₁ : x ≤ y) (h₂ : y.lf z) : x.lf z
{α : Type u} [LinearOrder α] {a b c : α} : Set.Interval a c ⊆ Set.Interval a b ∪ Set.Interval b c
{R : Type u_1} [LinearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [FiniteDimensional R M] (x : Orientation R M ι) (f : M ≃ₗ[R] M) (h : Fintype.card ι = FiniteDimensional.finrank R M) : ⇑(Orientation.map ι f) x = (⇑LinearEquiv.det f)⁻¹ • x
{H : Type u_1} [TopologicalSpace H] (G : StructureGroupoid H) {M : Type u_2} [TopologicalSpace M] [ChartedSpace H M] [HasGroupoid M G] {e e' : LocalHomeomorph M H} (hE : e ∈ ChartedSpace.Atlas H M) (hE' : e' ∈ ChartedSpace.Atlas H M) : e.symm.trans e' ∈ G
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
{α : Type u_1} [Fintype α] [Field α] : IsPrimePow (Fintype.card α)
{𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] {f f' : 𝕜 → G} {s : Set 𝕜} {C : Nnreal} (hs : Convex ℝ s) (hF : ∀ (x : 𝕜), x ∈ s → HasDerivWithinAt f (f' x) s x) (bound : ∀ (x : 𝕜), x ∈ s → ∥f' x∥₊ ≤ C) : LipschitzOnWith C f s
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) : (-o).oangle x y = -o.oangle x y
{α : Type u_3} {β : Type u_4} {γ : Type u_5} [AddCommMonoid α] {f : β → α} {g : γ → α} (h_Eq : ∀ (u : Finset γ), ∃ (v : Finset β), ∀ (v' : Finset β), v ⊆ v' → (∃ (u' : Finset γ), u ⊆ u' ∧ u'.sum (λ (x : γ), g x) = v'.sum (λ (b : β), f b))) : Filter.map (λ (s : Finset β), s.sum (λ (b : β), f b)) filter.at_Top ≤ Filter.map (λ (s : Finset γ), s.sum (λ (x : γ), g x)) filter.at_Top
{G : Type u_3} [Group G] : group.fg G ↔ monoid.fg G
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q) (x y : ↥P) : ⇑f x = ⇑f y → (∃ (z : ↥P), ⇑f z = 0 ∧ ∀ (R : C) (g : P ⟶ R), ⇑g y = 0 → ⇑g z = ⇑g x)
(p : ℕ) [p_Prime : Fact (Nat.Prime p)] {q : ℚ} (hq : q ≠ 0) {k : ℕ} : padic_val_rat p (q ^ k) = ↑k * padic_val_rat p q
 : fourier_subalgebra.topological_Closure = ⊤
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] (x : 𝕜) {𝕜' : Type u_1} [NondiscreteNormedField 𝕜'] [NormedAlgebra 𝕜 𝕜'] [NormedSpace 𝕜' F] [IsScalarTower 𝕜 𝕜' F] {h : 𝕜 → 𝕜'} {h' : 𝕜'} {g₁ : 𝕜' → F} {g₁' : F} (hg : HasDerivAt g₁ g₁' (h x)) (hH : HasDerivAt h h' x) : HasDerivAt (g₁ ∘ h) (h' • g₁') x
{f : ℝ → ℝ} (hF : Differentiable ℝ f) (hF'_Mono : StrictMono (deriv f)) : StrictConvexOn ℝ Set.Univ f
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f : ℂ → E} {c : ℂ} (hD : ∀ᶠ (z : ℂ) in nhds_within c {c}ᶜ, DifferentiableAt ℂ f z) (ho : (λ (z : ℂ), f z - f c) =o[nhds_within c {c}ᶜ] λ (z : ℂ), (z - c)⁻¹) : Filter.Tendsto f (nhds_within c {c}ᶜ) (nhds (lim (nhds_within c {c}ᶜ) f))
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] {a : α} : 0 < -a → a < 0
{E : ℕ → Type u_1} [Π (n : ℕ), TopologicalSpace (E n)] [∀ (n : ℕ), DiscreteTopology (E n)] {s : Set (Π (n : ℕ), E n)} (hs : is_IsClosed s) (hne : s.nonempty) : ∃ (f : (Π (n : ℕ), E n) → Π (n : ℕ), E n), (∀ (x : Π (n : ℕ), E n), x ∈ s → f x = x) ∧ Set.Range f = s ∧ Continuous f
{S : Type u_2} [CommRing S] {K : Type u_4} [Field K] [Algebra K S] (pB : PowerBasis K S) : ⇑(Algebra.norm K) pb.gen = (-1) ^ pb.dim * (minpoly K pb.gen).coeff 0
{M : Type u_2} {α : sort u_4} [CommMonoid M] {f : α → M} (p : M → Prop) (hp₀ : p 1) (hp₁ : ∀ (x y : M), p x → p y → p (x * y)) (hp₂ : ∀ (i : α), p (f i)) : p (finprod (λ (i : α), f i))
{F : Type u_3} [InnerProductSpace ℝ F] {K : Set F} (NE : K.nonempty) (h₁ : IsComplete K) (h₂ : Convex ℝ K) (u : F) : ∃ (v : F) (H : v ∈ K), ∥u - v∥ = ⨅ (w : ↥K), ∥u - ↑w∥
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : HasInner.inner x y = (∥x + y∥ * ∥x + y∥ - ∥x∥ * ∥x∥ - ∥y∥ * ∥y∥) / 2
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E] [NormedGroup F] [NormedSpace ℝ F] [MeasurableSpace E] [BorelSpace E] [TopologicalSpace.SecondCountableTopology F] (f : E → F) (s : Set E) (f' : E → (E →L[ℝ] F)) (hF' : ∀ (x : E), x ∈ s → HasFderivWithinAt f (f' x) s x) (r : (E →L[ℝ] F) → Nnreal) (rpos : ∀ (A : E →L[ℝ] F), r A ≠ 0) : ∃ (t : ℕ → Set E) (A : ℕ → (E →L[ℝ] F)), Pairwise (Disjoint on t) ∧ (∀ (n : ℕ), MeasurableSet (t n)) ∧ (s ⊆ ⋃ (n : ℕ), t n) ∧ (∀ (n : ℕ), ApproximatesLinearOn f (A n) (s ∩ t n) (r (A n))) ∧ (s.nonempty → ∀ (n : ℕ), ∃ (y : E) (H : y ∈ s), A n = f' y)
{B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] : IsTopologicalFiberBundle F Prod.snd
{p : ℕ} (hp : Nat.Prime p) {n : ℕ} (hn : 0 < n) : (p ^ n).totient = p ^ (n - 1) * (p - 1)
(X : Top) (T : Type u) : (X.presheaf_to_Type T).is_sheaf
 : Filter.Tendsto (λ (x : ℝ), x ^ (1 / x)) filter.at_Top (nhds 1)
(K : Type u) [Field K] (V : Type v) [AddCommGroup V] [Module K V] [FiniteDimensional K V] : (LinearMap.rtensor (Module.Dual K V) (contract_Left K V)).comp ((TensorProduct.assoc K (Module.Dual K V) V (Module.Dual K V)).symm.to_Linear_map.comp (LinearMap.ltensor (Module.Dual K V) (coevaluation K V))) = (TensorProduct.lid K (Module.Dual K V)).symm.to_Linear_map.comp (TensorProduct.rid K (Module.Dual K V)).to_Linear_Map
{α : Type u} {β : Type v} (f : α → Finset β) (h : (Set.Range f).finite) : (⋃ (a : α), ↑(f a)).finite
{α : Type u_1} {β : Type u_3} [MeasurableSpace α] [MeasurableSpace β] {ν : MeasureTheory.Measure β} [MeasureTheory.SigmaFinite ν] {f : α × β → Ennreal} (hF : Measurable f) : Measurable (λ (x : α), ∫⁻ (y : β), f (x, y) ∂ν)
{α : Type u_1} [DecidableEq α] {s t : Finset α} (h : s ⊆ t) : (Finset.ico s t).card = 2 ^ (t.card - s.card) - 1
{A : Type u_1} {B : Type u_2} [Field A] [Ring B] [is_IsDomain B] [Algebra A B] {x : B} (hx : IsIntegral A x) : (minpoly A x).coeff 0 = 0 ↔ x = 0
{ι : Type u} {f g : ι → ℝ} {p : ℝ} (hp : 1 ≤ p) (hF : ∀ (i : ι), 0 ≤ f i) (hg : ∀ (i : ι), 0 ≤ g i) {A B : ℝ} (hA : 0 ≤ A) (hB : 0 ≤ B) (hfA : HasSum (λ (i : ι), f i ^ p) (A ^ p)) (hgB : HasSum (λ (i : ι), g i ^ p) (B ^ p)) : ∃ (C : ℝ), 0 ≤ C ∧ C ≤ A + B ∧ HasSum (λ (i : ι), (f i + g i) ^ p) (C ^ p)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {f : E → G} {s : Set E} {x y : E} (hs : Convex ℝ s) (hF : DifferentiableOn 𝕜 f s) (hF' : ∀ (x : E), x ∈ s → fderiv_within 𝕜 f s x = 0) (hx : x ∈ s) (hy : y ∈ s) : f x = f y
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} (p : ι → P) (i₀ : ι) : Vector_Span k (Set.Range p) = Submodule.span k (Set.Range (λ (i : {x // x ≠ i₀}), p ↑i -ᵥ p i₀))
{C : Type u₁} [CategoryTheory.Category C] {Z X Y : C} {c : CategoryTheory.Limits.BinaryCofan X Y} (h : CategoryTheory.Limits.IsColimit c) (t : CategoryTheory.Limits.IsInitial Z) : CategoryTheory.IsPushout (t.to ((CategoryTheory.Limits.pair X Y).obj {as := CategoryTheory.Limits.WalkingPair.left})) (t.to ((CategoryTheory.Limits.pair X Y).obj {as := CategoryTheory.Limits.WalkingPair.right})) c.inl c.inr
{R : Type u} [Ring R] {M : Type v} [AddCommGroup M] [Module R M] [Nontrivial R] {ι : Type w} (b : Basis ι R M) {κ : Type w'} (v : κ → M) (i : LinearIndependent R v) (m : i.maximal) : (⋃ (k : κ), ↑((⇑(b.repr) (v k)).support)) = Set.Univ
(C : Type (u+1)) [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] (D : Type (u+1)) [CategoryTheory.Category D] [CategoryTheory.ConcreteCategory D] [Category_theory.has_Forget₂ C D] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget C)] : CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget₂ C D)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] {f : E → F} {s : Set E} (g : F →L[𝕜] G) (h : AnalyticOn 𝕜 f s) : AnalyticOn 𝕜 (⇑g ∘ f) s
{𝕜 : Type u_1} [LinearOrderedField 𝕜] [TopologicalSpace 𝕜] [OrderTopology 𝕜] {s : Set 𝕜} : StrictConvex 𝕜 s ↔ Convex 𝕜 s
{M : Type u_1} [MonoidWithZero M] {φ₁ φ₂ : ℤ →*₀ M} (h_Neg_One : ⇑φ₁ (-1) = ⇑φ₂ (-1)) (h_Pos : ∀ (n : ℕ), 0 < n → ⇑φ₁ ↑n = ⇑φ₂ ↑n) : φ₁ = φ₂
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryProducts C] [CategoryTheory.Limits.HasTerminal C] : CategoryTheory.Limits.HasFiniteProducts C
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasPullbacks C] : Category_theory.pretopology.to_grothendieck C ⊥ = ⊥
{ι : Type u} (s : Finset ι) {f g : ι → ℝ} {p : ℝ} (hp : 1 ≤ p) (hF : ∀ (i : ι), i ∈ s → 0 ≤ f i) (hg : ∀ (i : ι), i ∈ s → 0 ≤ g i) : s.sum (λ (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤ s.sum (λ (i : ι), f i ^ p) ^ (1 / p) + s.sum (λ (i : ι), g i ^ p) ^ (1 / p)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] (s1 s2 : AffineSubspace k P) : s1 < s2 ↔ s1 ≤ s2 ∧ ∃ (p : P) (H : p ∈ s2), p ∉ s1
{α : Type u_1} {β : Type u_2} {f g : α → β} {m : MeasurableSpace α} [TopologicalSpace β] {p : α → Prop} {_x : DecidablePred p} (hp : MeasurableSet {a : α | p a}) (hF : MeasureTheory.StronglyMeasurable f) (hg : MeasureTheory.StronglyMeasurable g) : MeasureTheory.StronglyMeasurable (λ (x : α), Ite (p x) (f x) (g x))
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] (s : AffineSubspace k P) : affine_Span k ↑s = s
{α : Type u_1} {n : Type u_4} {m : Type u_5} [HasZero α] {A : Matrix m m α} {D : Matrix n n α} (ha : A.is_diag) (hD : D.is_diag) : (matrix.from_blocks A 0 0 D).is_diag
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] [Fintype α] [Fintype β] (f : α → β) {b : M} [LinearOrderedCommRing M] (hb : Fintype.card β • b < ↑(Fintype.card α)) : ∃ (y : β), b < ↑((Finset.filter (λ (x : α), f x = y) Finset.univ).card)
{G : Type u_10} [AddGroup G] (a : G) : ⇑(Equiv.symm (equiv.add_Right a)) = λ (x : G), x + -a
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} {ι₂ : Type u_5} (s₂ : Finset ι₂) (e : ι₂ ↪ ι) (w : ι → k) (p : ι → P) : ⇑((Finset.map e s₂).affine_combination p) w = ⇑(s₂.affine_combination (p ∘ ⇑e)) (w ∘ ⇑e)
{α : Type u} {β : Type v} [CompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [CompleteLinearOrder β] [TopologicalSpace β] [OrderTopology β] {ι : sort u_1} [Nonempty ι] {f : α → β} {g : ι → α} (Cf : ContinuousAt f (infi g)) (Mf : Monotone f) : f (⨅ (i : ι), g i) = ⨅ (i : ι), f (g i)
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {f : α → β × γ} (hF : Continuous f) : Continuous (λ (a : α), (f a).fst)
{α : Type u} [Preorder α] {a b : α} : a ≤ b → ¬b ≤ a → a < b
{V : Type u} [CategoryTheory.Category V] [CategoryTheory.Abelian V] {A B C D A' B' C' D' : V} {f : A ⟶ B} {g : B ⟶ C} {h : C ⟶ D} {f' : A' ⟶ B'} {g' : B' ⟶ C'} {h' : C' ⟶ D'} {α : A ⟶ A'} {β : B ⟶ B'} {γ : C ⟶ C'} {δ : D ⟶ D'} (comm₁ : α ≫ f' = f ≫ β) (comm₂ : β ≫ g' = g ≫ γ) (comm₃ : γ ≫ h' = h ≫ δ) (hfg : CategoryTheory.Exact f g) (hgh : CategoryTheory.Exact g h) (hF'g' : CategoryTheory.Exact f' g') (hα : CategoryTheory.Epi α) (hβ : CategoryTheory.Mono β) (hδ : CategoryTheory.Mono δ) : CategoryTheory.Mono γ
{R : Type u_1} [LinearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [FiniteDimensional R M] (x : Orientation R M ι) (f : M ≃ₗ[R] M) (h : Fintype.card ι = FiniteDimensional.finrank R M) : ⇑(Orientation.map ι f) x = x ↔ 0 < ⇑LinearMap.det ↑f
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : ι → Set P) : affine_Span k (⋃ (i : ι), s i) = ⨆ (i : ι), affine_Span k (s i)
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (u : Rˣ) (hu : 0 < ↑u) (v : Module.Ray R M) : u • v = v
{α : Type u} [PseudoMetricSpace α] {s t : Set α} {x : α} (Fin : emetric.Hausdorff_edist s t ≠ ⊤) : metric.inf_dist x t ≤ metric.inf_dist x s + metric.Hausdorff_dist s t
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {n : ℕ} (s : Affine.Simplex k P n) (i : Fin (n + 1)) : s.face _ = affine.simplex.mk_of_point k (s.points i)
{α : Type u} {β : Type v} {γ : Type w} [PseudoEmetricSpace α] [TopologicalSpace β] [PseudoEmetricSpace γ] (f : α × β → γ) {s : Set α} {t : Set β} (K : Nnreal) (ha : ∀ (a : α), a ∈ s → ContinuousOn (λ (y : β), f (a, y)) t) (hb : ∀ (b : β), b ∈ t → LipschitzOnWith K (λ (x : α), f (x, b)) s) : ContinuousOn f (s ×ˢ t)
{α : Type u} [DecidableEq α] (i j : α) : Function.involutive (λ (_x : Equiv.perm α), _x * equiv.swap i j)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (f : C(α, β)) (x : α) : ContinuousAt ⇑f x
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} {s : Set α} (h : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) ≠ 0) : s.nonempty
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) : ⇑is_R_or_C.re (HasInner.inner x y) = (∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - ∥x - y∥ * ∥x - y∥) / 2
{ι : Type u_1} {α : Type u_3} [Preorder ι] [LinearOrder α] {u : ι → α} (h : Monotone u) (H : ¬BddBelow (Set.Range u)) : Filter.Tendsto u filter.at_IsBot filter.at_IsBot
{C : Type u₁} [CategoryTheory.Category C] {X Y : Cᵒᵖ} (f : X ⟶ Y) [CategoryTheory.IsIso (Category_theory.coyoneda.map f)] : CategoryTheory.IsIso f
{M : Type u_3} [AddMonoid M] [Preorder M] [CovariantClass M M (Function.swap has_add.add) has_le.le] [CovariantClass M M has_add.add has_le.le] {l₁ l₂ : List M} (h : l₁ <+ l₂) (h₁ : ∀ (a : M), a ∈ l₂ → 0 ≤ a) : l₁.sum ≤ l₂.sum
{M : Type u_1} [AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M →+ P} {T : AddSubmonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [AddCommMonoid Q] {k : T.localization_Map Q} (z : N) (u : Q) : ⇑(f.map hy k) z = u ↔ ⇑(k.to_Map) (⇑g (f.sec z).fst) = ⇑(k.to_Map) (⇑g ↑((f.sec z).snd)) + u
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {n : WithTop ℕ} (h : ContDiffOn 𝕜 n f s) (hs : UniqueDiffOn 𝕜 s) (hn : 1 ≤ n) : ContinuousOn (λ (p : E × E), ⇑(fderiv_within 𝕜 f s p.fst) p.snd) (s ×ˢ Set.Univ)
{α : Type u_1} {ι : Type u_4} [TopologicalSpace α] {s : Set ι} (hs : s.finite) {f : ι → Set α} (h : ∀ (i : ι), i ∈ s → is_Gδ (f i)) : is_Gδ (⋃ (i : ι) (H : i ∈ s), f i)
{α : Type u} [NonUnitalNonAssocRing α] (k : α) (h : ∀ (x : α), x * k = 0 → x = 0) : IsRightRegular k
{C : Type u₁} [CategoryTheory.Category C] (P : Cᵒᵖ ⥤ Type (max v₁ u₁)) {X : C} (R : CategoryTheory.Presieve X) [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Presieve.IsSheafFor P R ↔ Nonempty (CategoryTheory.Limits.IsLimit (Category_theory.limits.fork.of_ι (Category_theory.equalizer.fork_Map P R) _))
{α : Type u_1} [CircularPreorder α] {a b c : α} (h : HasBtw.Btw a b c) : HasBtw.Btw c a b
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) {r₁ r₂ : ℝ} : 2 • o.oangle (r₁ • x) (r₂ • x) = 0
{α : Type u_1} {a b c : α} [LinearOrder α] [AddCommSemigroup α] [HasSub α] [HasOrderedSub α] (h : a - c < b - c) : a < b
{α : Type u} [LinearOrder α] (a b : α) : Linear_order.min a b = a ∧ a ≤ b ∨ Linear_order.min a b = b ∧ b < a
{x y : Pgame} : x ≤ y ↔ (∀ (i : x.left_moves), (∃ (i' : y.left_moves), x.move_Left i ≤ y.move_Left i') ∨ ∃ (j : (x.move_Left i).right_moves), (x.move_Left i).move_Right j ≤ y) ∧ ∀ (j : y.right_moves), (∃ (i : (y.move_Right j).left_moves), x ≤ (y.move_Right j).move_Left i) ∨ ∃ (j' : x.right_moves), x.move_Right j' ≤ y.move_Right j
{R : Type u_1} {E : Type u_2} {ι : Type u_4} [LinearOrderedField R] [AddCommGroup E] [Module R E] (s : Finset ι) (w₁ w₂ : ι → R) (z : ι → E) (hw₁ : s.sum (λ (i : ι), w₁ i) = 1) (hw₂ : s.sum (λ (i : ι), w₂ i) = 1) (a b : R) (hab : a + b = 1) : a • s.center_mass w₁ z + b • s.center_mass w₂ z = s.center_mass (λ (i : ι), a * w₁ i + b * w₂ i) z
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜} : StrictConvexOn 𝕜 s f ↔ Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) < (f z - f y) / (z - y)
{α : Type u} [PseudoEmetricSpace α] {s t : Set α} : emetric.Hausdorff_edist s t = 0 ↔ Closure s = Closure t
{α : Type u} [TopologicalSpace α] [LocallyCompactSpace α] [t2_Space α] (x : α) : ∃ (U : Set α), is_IsOpen U ∧ x ∈ U ∧ is_IsCompact (Closure U)
{α : Type u_1} [PartialOrder α] {f : α → α} {p : α → Prop} {hF : ∀ (x : α), x ≤ f x} {hfp : ∀ (x : α), p (f x)} {hmin : ∀ ⦃x y : α⦄, x ≤ y → p y → f x ≤ y} {x y : α} (hxy : x ≤ y) (hy : p y) : ⇑(ClosureOperator.mk₃ f p hF hfp hmin) x ≤ y
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {f : M →* N} (hF : ∀ (y : ↥S), IsUnit (⇑f ↑y)) {y z : ↥S} (h : (⇑(is_unit.lift_Right (f.restrict S) hF) y)⁻¹ = (⇑(is_unit.lift_Right (f.restrict S) hF) z)⁻¹) : ⇑f ↑y = ⇑f ↑z
{α : Type u_1} {β : Type u_2} [Group α] [DivisionMonoid β] (f : α →* β) (g : α) (n : ℤ) : ⇑f (g ^ n) = ⇑f g ^ n
{α : Type u} [TopologicalSpace α] {f : Filter α} (h : ∃ (a : α), f ≤ nhds a) : f ≤ nhds (lim f)
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [Module 𝕜 E] {s : Set E} (hs : Convex 𝕜 s) (z : E) : Convex 𝕜 ((λ (x : E), x + z) ⁻¹' s)
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder β] [SuccOrder β] [IsSuccArchimedean β] {s : β → Set α} {t : Set β} (ht : t.ord_connected) (H : ∀ (n : β), n ∈ t → IsPreconnected (s n)) (K : ∀ (n : β), n ∈ t → Order.succ n ∈ t → (s n ∩ s (Order.succ n)).nonempty) : IsPreconnected (⋃ (n : β) (H : n ∈ t), s n)
(R : Type u) (L : Type v) [CommRing R] [LieRing L] [LieAlgebra R L] [LieAlgebra.IsNilpotent R L] : (⨅ (x : L), (⇑(LieAlgebra.ad R L) x).maximal_generalized_eigenspace 0) = ⊤
{α : Type u} {n : ℕ} (a : Array n α) : a.to_List = list.of_fn a.read
 : Filter.Tendsto Real.log filter.at_Top filter.at_Top
{α : Type u} [PseudoMetricSpace α] {u : ℕ → α} (hu : CauchySeq u) : ∃ (R : ℝ) (H : R > 0), ∀ (m n : ℕ), HasDist.dist (u m) (u n) < R
{R : Type u_1} [CommRing R] (hR : DiscreteValuationRing.HasUnitMulPowIrreducibleFactorization R) [is_IsDomain R] : UniqueFactorizationMonoid R
{α : Type u} {β : Type v} [DecidableEq β] (r : α → β → Prop) [Π (a : α), Fintype ↥(Rel.Image r {a})] : (∀ (A : Finset α), A.card ≤ Fintype.card ↥(Rel.Image r ↑A)) ↔ ∃ (f : α → β), Function.Injective f ∧ ∀ (x : α), r x (f x)
{K : Type u_1} [LinearOrderedField K] [FloorRing K] (v : K) : (GeneralizedContinuedFraction.IntFractPair.stream v).is_Seq
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [TopologicalSpace.SecondCountableTopology E] [CompleteSpace E] [NormedGroup F] {f : ℝ → E} {g : ℝ → F} {a b c : ℝ} (hne : a ≠ b) (hc : c ∈ Set.Interval a b) (h_deriv : ∀ᶠ (x : ℝ) in nhds_within c (Set.Interval a b  {c}), DifferentiableAt ℝ f x) (h_infty : Filter.Tendsto (λ (x : ℝ), ∥f x∥) (nhds_within c (Set.Interval a b  {c})) filter.at_Top) (hg : deriv f =O[nhds_within c (Set.Interval a b  {c})] g) : ¬IntervalIntegrable g MeasureTheory.MeasureSpace.volume a b
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommMonoid β] [Module 𝕜 E] [Module 𝕜 β] (f : E →ₗ[𝕜] β) {s : Set E} (hs : Convex 𝕜 s) : ConvexOn 𝕜 s ⇑f
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) {r : Nnreal} (h : ↑r < p.radius) : ∃ (a : ℝ) (H : a ∈ Set.Ioo 0 1), (λ (n : ℕ), ∥p n∥ * ↑r ^ n) =o[filter.at_Top] has_pow.pow a
{α : Type u_1} {p : α → Prop} (s : Finset {x // p x}) {a : α} (h : ¬p a) : a ∉ Finset.map (Function.Embedding.subtype (λ (x : α), p x)) s
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {j j' : C} (f f' : j ⟶ j') : f ≫ Category_theory.is_filtered.coeq_hom f f' = f' ≫ Category_theory.is_filtered.coeq_hom f f'
{p : ℕ} [p_Prime : Fact (Nat.Prime p)] {b : ℕ} (Dvd : p ∣ b) : padic_val_Nat p (b / p) = padic_val_Nat p b - 1
{F : Type u_2} [NormedGroup F] [NormedSpace ℝ F] {x y : F} : SameRay ℝ x y ↔ x = 0 ∨ y = 0 ∨ ∥x∥⁻¹ • x = ∥y∥⁻¹ • y
{α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [Semiring α] [AddGroup β] (h : Function.Antiperiodic f c) : Function.Periodic f (2 * c)
{R : Type u_2} {M : Type u_3} [AddCommGroup M] [Ring R] [Module R M] {B : BilinForm R M} (hB : B.to_quadratic_form.anisotropic) : B.nondegenerate
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) {p : P} (hp : p ∈ affine_Span ℝ (Set.Range s.points)) {r : ℝ} (hr : ∀ (i : Fin (n + 1)), HasDist.dist (s.points i) p = r) : r = s.circumradius
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K₁ K₂ : Submodule 𝕜 E} [FiniteDimensional 𝕜 ↥K₂] (h : K₁ ≤ K₂) : FiniteDimensional.finrank 𝕜 ↥K₁ + FiniteDimensional.finrank 𝕜 ↥(K₁ᗮ ⊓ K₂) = FiniteDimensional.finrank 𝕜 ↥K₂
{M : Type u_1} [Monoid M] {ι : sort u_2} {s : ι → Set M} (h : ∀ (y : ι), IsSubmonoid (s y)) : IsSubmonoid (Set.Inter s)
{M : Type u_1} [AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M →+ P} (hg : ∀ (y : ↥S), IsAddUnit (⇑g ↑y)) {x y : M} (h : ⇑(f.to_Map) x = ⇑(f.to_Map) y) : ⇑g x = ⇑g y
{R : Type u} [NonAssocSemiring R] (s : Subsemiring R) : Subsemiring.closure ↑s = s
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (x : M) : SameRay R x x
{α : Type u_1} {M : Type u_5} {R : Type u_11} {S : Type u_12} [HasZero M] [Semiring R] [Semiring S] (h : R →+* S) (f : α →₀ M) (g : α → M → R) : ⇑h (f.sum g) = f.sum (λ (a : α) (b : M), ⇑h (g a b))
{ι : Type u_1} {α : Type u_2} {s : ι → Set α} (hs : IndexedPartition s) (x : α) : ⇑(hs.out) (hs.proj x) = hs.some (hs.index x)
{α : Type u} {β : Type v} [Preorder α] [SemilatticeSup β] {f g : α → β} (hF : Monotone f) (hg : Monotone g) : Monotone (f ⊔ g)
{α : Type u_1} : Subsingleton (Option α) ↔ IsEmpty α
{ι : Type u_1} (f g : ι → Cardinal) (H : ∀ (i : ι), f i < g i) : Cardinal.sum f < Cardinal.prod g
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) : 2 • o.oangle (-x) y = 2 • o.oangle x y
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {F : J ⥤ C} {t : CategoryTheory.Limits.Cocone F} (h : CategoryTheory.Limits.IsColimit t) (s : CategoryTheory.Limits.Cocone F) : ∃! (d : t.X ⟶ s.X), ∀ (j : J), t.ι.app j ≫ d = s.ι.app j
{α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [LinearOrderedAddCommGroup α] [Archimedean α] (h : Function.Periodic f c) (hc : 0 < c) (x a : α) : ∃ (y : α) (H : y ∈ Set.Ioc a (a + c)), f x = f y
{R : Type u_1} [CommSemiring R] {R' : Type u_2} [Monoid R'] {M : Type u_4} {N : Type u_5} [AddCommMonoid M] [AddCommMonoid N] [Module R M] [Module R N] [DistribMulAction R' M] [DistribMulAction R' N] [TensorProduct.CompatibleSmul R R' M N] (r : R') (m : M) (n : N) : (r • m) ⊗ₜ[R] n = m ⊗ₜ[R] (r • n)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {K : Set (E →L[𝕜] F)} (hK : IsComplete K) : FderivMeasurableAux.D f K ⊆ {x : E | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K}
{α : Type u} [PseudoEmetricSpace α] {s : Set α} (hs : s.subsingleton) : Emetric.diam s = 0
{K : Type u} [Field K] {ι : sort u_1} [hι : Nonempty ι] {S : ι → Subfield K} (hS : Directed has_le.le S) {x : K} : (x ∈ ⨆ (i : ι), S i) ↔ ∃ (i : ι), x ∈ S i
{α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {f : MeasureTheory.Filtration ℕ m} {u : ℕ → α → β} {τ : α → ℕ} [AddCommMonoid β] [TopologicalSpace β] [HasContinuousAdd β] (hu : MeasureTheory.Adapted f u) (hτ : MeasureTheory.IsStoppingTime f τ) : MeasureTheory.Adapted f (measure_theory.stopped_process u τ)
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{V : Type u_4} [InnerProductSpace ℂ V] (T : V →ₗ[ℂ] V) : (∀ (x : V), HasInner.inner (⇑T x) x = 0) ↔ T = 0
{α : Type u_1} {β : Type u_2} [t : TopologicalSpace α] [PolishSpace α] [MeasurableSpace α] [BorelSpace α] [tβ : TopologicalSpace β] [TopologicalSpace.SecondCountableTopology β] [MeasurableSpace β] [BorelSpace β] {f : α → β} (hF : Measurable f) : ∃ (t' : TopologicalSpace α), t' ≤ t ∧ Continuous f ∧ PolishSpace α
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι} [TopologicalSpace α] (h : TendstoUniformly F f p) (hc : ∀ᶠ (n : ι) in p, Continuous (F n)) [p.ne_IsBot] : Continuous f
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] (q : FormalMultilinearSeries 𝕜 F G) (p : FormalMultilinearSeries 𝕜 E F) (hq : 0 < q.radius) (hp : 0 < p.radius) : ∃ (r : Nnreal) (H : r > 0), Summable (λ (i : Σ (n : ℕ), Composition n), ∥q.comp_along_Composition p i.snd∥₊ * r ^ i.fst)
{R : Type u_1} [Rack R] {x y z : R} : Shelf.act x (Shelf.act y z) = Shelf.act (Shelf.act x y) z ↔ Shelf.act x z = z
{α : Type u_2} {β : Type u_3} {rα : NonAssocSemiring α} {rβ : NonAssocSemiring β} (f : α →+* β) : ⇑f 0 = 0
{α : Type u_2} {β : Type u_3} {rα : NonAssocSemiring α} {rβ : NonAssocSemiring β} (f : α →+* β) : 0 = 1 ↔ ⇑f 1 = 0
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) {r : ℝ} (hr : r ≠ 0) : 2 • o.oangle (r • x) y = 2 • o.oangle x y
(z w : ℂ) : Complex.abs (z + w) ≤ Complex.abs z + Complex.abs w
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] (a : α) {b : α} : 0 < b → a - b < a
{a : ℝ} {l : Filter ℝ} {f f' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in nhds_within a (Set.Iio a), HasDerivAt f (f' x) x) (hgg' : ∀ᶠ (x : ℝ) in nhds_within a (Set.Iio a), HasDerivAt g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in nhds_within a (Set.Iio a), g' x ≠ 0) (hfa : Filter.Tendsto f (nhds_within a (Set.Iio a)) (nhds 0)) (hga : Filter.Tendsto g (nhds_within a (Set.Iio a)) (nhds 0)) (hDiv : Filter.Tendsto (λ (x : ℝ), f' x / g' x) (nhds_within a (Set.Iio a)) l) : Filter.Tendsto (λ (x : ℝ), f x / g x) (nhds_within a (Set.Iio a)) l
{G : Type u_1} [Group G] (tG : monoid.is_torsion G) (bounded : (Set.Range (λ (g : G), order_of g)).finite) : monoid.exponent_exists G
(𝕜 : Type u_1) [NondiscreteNormedField 𝕜] {E : Type u_2} [SemiNormedGroup E] [NormedSpace 𝕜 E] [ProperSpace 𝕜] (x' : NormedSpace.Dual 𝕜 E) (r : ℝ) : is_IsCompact (⇑weak_dual.to_normed_dual ⁻¹' Metric.ClosedBall x' r)
{ι : Type u_1} {R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] [Fintype ι] (b : Basis ι R M) (x : ι → R) : ⇑(b.equiv_fun.symm) x = finset.univ.sum (λ (i : ι), x i • ⇑b i)
{α : Type u} [PseudoEmetricSpace α] {s : Set α} (NE : s.nonempty) : emetric.Hausdorff_edist s ∅ = ⊤
{a : Prop} : ¬¬a ↔ a
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x : V) {r : ℝ} : 2 • hb.oangle (r • x) x = 0
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : α → β} : StrictAnti f → StrictMono (f ∘ ⇑order_dual.of_dual)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e e' : LocalHomeomorph α β} (h : e ≈ e') : e.to_local_equiv.source = e'.to_local_equiv.source
{J : Type u₁} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {F G : J ⥤ C} [CategoryTheory.Limits.HasColimit F] (α : G ≅ F) : CategoryTheory.Limits.HasColimit G
(α : Type u) [t : TopologicalSpace α] [TopologicalSpace.SeparableSpace α] [Nonempty α] : ∃ (u : ℕ → α), DenseRange u
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [FiniteDimensional 𝕜 E] (K : Submodule 𝕜 E) : FiniteDimensional.finrank 𝕜 ↥K + FiniteDimensional.finrank 𝕜 ↥Kᗮ = FiniteDimensional.finrank 𝕜 E
{α : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} [Preorder ι] {𝒢 : MeasureTheory.Filtration ι m} {τ η : α → ι} {i : ι} {s : Set α} [DecidablePred (λ (_x : α), _x ∈ s)] (hτ_st : MeasureTheory.IsStoppingTime 𝒢 τ) (hη_st : MeasureTheory.IsStoppingTime 𝒢 η) (hτ : ∀ (x : α), i ≤ τ x) (hη : ∀ (x : α), i ≤ η x) (hs : MeasurableSet s) : MeasureTheory.IsStoppingTime 𝒢 (s.piecewise τ η)
{V : Type u_1} {P : Type u_2} [NormedGroup V] [NormedSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s u : Set P} (hu : is_IsOpen u) (hsu : s ⊆ u) (hne : s.nonempty) (h : AffineIndependent ℝ Coe) : ∃ (t : Set P), s ⊆ t ∧ t ⊆ u ∧ AffineIndependent ℝ Coe ∧ affine_Span ℝ t = ⊤
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (v : M) {r : R} (h : 0 ≤ r) : SameRay R v (r • v)
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) [CategoryTheory.Limits.HasLimits C] (i j k : D.to_glue_data.J) (U : TopologicalSpace.Opens ↥((D.to_glue_data.U i).carrier)) : D.opens_image_preimage_Map i j U ≫ (D.to_glue_data.f j k).c.app (Opposite.op ((TopologicalSpace.Opens.map (D.to_glue_data.ι j).base).obj (_.functor.obj U))) = (CategoryTheory.Limits.pullback.fst ≫ D.to_glue_data.t j i ≫ D.to_glue_data.f i j).c.app (Opposite.op U) ≫ _.inv_App (Opposite.unop ((TopologicalSpace.Opens.map (CategoryTheory.Limits.pullback.fst ≫ D.to_glue_data.t j i ≫ D.to_glue_data.f i j).base).op.obj (Opposite.op U))) ≫ (D.to_glue_data.V (j, k)).presheaf.map (Category_theory.eq_to_hom _)
{α : Type u_1} {E : Type u_3} [SemiNormedGroup E] {f : α → E} {g : α → ℝ} {t₀ : Filter α} (h : ∀ᶠ (n : α) in t₀, ∥f n∥ ≤ g n) (h' : Filter.Tendsto g t₀ (nhds 0)) : Filter.Tendsto f t₀ (nhds 0)
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : α → β} : StrictMono f → StrictAnti (f ∘ ⇑order_dual.of_dual)
(G : Type u_1) [CommGroup G] : monoid.is_torsion_free (G ⧸ torsion G)
{β : Type u} {α : Type v} {γ : Type w} [AddCommMonoid β] [AddCommMonoid γ] (g : β ≃+ γ) (f : α → β) (s : Finset α) : ⇑g (s.sum (λ (x : α), f x)) = s.sum (λ (x : α), ⇑g (f x))
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : EuclideanGeometry.angle p1 p2 p3 = Real.pi) : HasDist.dist p1 p2 ≠ 0
{G : Type u} [Group G] {x : G} : IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [NondiscreteNormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (f : ContinuousMultilinearMap 𝕜 E G) (m₁ m₂ : Π (i : ι), E i) : ∥⇑f m₁ - ⇑f m₂∥ ≤ ∥f∥ * finset.univ.sum (λ (i : ι), finset.univ.prod (λ (j : ι), Ite (j = i) ∥m₁ i - m₂ i∥ (Linear_order.max ∥m₁ j∥ ∥m₂ j∥)))
{f : ℂ → ℂ} {c z : ℂ} {R : ℝ} (hD : DifferentiableOn ℂ f (Metric.Ball c R)) (h_maps : Set.MapsTo f (Metric.Ball c R) (Metric.Ball c R)) (hc : f c = c) (hz : z ∈ Metric.Ball c R) : HasDist.dist (f z) c ≤ HasDist.dist z c
(A : Type w) (B : Type u₁) (C : Type u_1) [CommRing A] [CommRing B] [CommRing C] [Algebra A B] [Algebra B C] [Algebra A C] [IsScalarTower A B C] [IsNoetherianRing A] (hAC : ⊤.fg) (hBC : ⊤.fg) (hBCi : Function.Injective ⇑(Algebra_Map B C)) : ⊤.fg
{α : Type u_1} {M : Type u_5} [HasZero M] (a : α) : Function.Injective (Finsupp.single a)
{α : Type u_1} {β : Type u_2} [AddGroup α] [SubtractionMonoid β] (f : α →+ β) (a : α) : ⇑f (-a) = -⇑f a
(R : Type u) (L : Type v) (M : Type w) [CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M] : LieModule.IsNilpotent R L M ↔ ∃ (k : ℕ), lie_module.lower_central_series R L M k = ⊥
{E : Type u_2} [SemiNormedGroup E] [NormedSpace ℝ E] {s t : Set E} (disj : Disjoint s t) (hs₁ : Convex ℝ s) (hs₂ : is_IsCompact s) (ht₁ : Convex ℝ t) (ht₂ : is_IsClosed t) : ∃ (u v : Set E), is_IsOpen u ∧ is_IsOpen v ∧ Convex ℝ u ∧ Convex ℝ v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint u v
{R : Type u} {M : Type v} [CommRing R] [Nontrivial R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] (f : M →ₗ[R] M) (k : ℕ) : f ^ k = ⇑(Polynomial.aeval f) (Polynomial.x ^ k %ₘ f.charpoly)
{m : Type u} {n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix m n α) (B : Matrix n n α) [Invertible B] : (A.mul B).mul (⅟ B) = A
{α : Type u} [PseudoEmetricSpace α] {x : α} {s : Set α} : x ∈ Closure s ↔ emetric.inf_edist x s = 0
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {δ : Type u_1} [LinearOrder δ] [TopologicalSpace δ] [OrderClosedTopology δ] {f : α → δ} (hF : Continuous f) (h_Top : Filter.Tendsto f filter.at_IsBot filter.at_Top) (h_IsBot : Filter.Tendsto f filter.at_Top filter.at_IsBot) : Function.Surjective f
{α : Type u} [TopologicalSpace α] {s U : Set α} (h : U ∈ ⨆ (x : α) (H : x ∈ s), nhds x) : ∃ (V : Set α), s ⊆ V ∧ is_IsOpen V ∧ V ⊆ U
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCancelCommMonoid E] [OrderedAddCommMonoid β] [Module 𝕜 E] [HasScalar 𝕜 β] {s : Set E} {f : E → β} (hF : StrictConcaveOn 𝕜 s f) (c : E) : StrictConcaveOn 𝕜 ((λ (z : E), c + z) ⁻¹' s) (f ∘ λ (z : E), z + c)
{K : Type u_4} {L : Type u_5} [Field K] [Field L] [Algebra K L] (x : K) : ⇑(Algebra.trace K L) (⇑(Algebra_Map K L) x) = FiniteDimensional.finrank K L • x
{n : ℕ} (hpos : 0 < n) : Irreducible (Polynomial.cyclotomic n ℚ)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y : V} (h : ∥x∥ = ∥y∥) : hb.oangle x (x - y) = hb.oangle (y - x) y
{α : Type u_1} {β : Type u_3} {C : Set (Set α)} {D : Set (Set β)} (hC : IsPiSystem C) (hD : IsPiSystem D) : IsPiSystem (Set.image2 HasSetProd.prod C D)
{𝕂 : Type u_1} [NondiscreteNormedField 𝕂] [CompleteSpace 𝕂] (h : 0 < (Exp_series 𝕂 𝕂).radius) : HasStrictDerivAt (Exp 𝕂) 1 0
{𝕜 : Type u_1} {A : Type u_2} [NondiscreteNormedField 𝕜] [NormedRing A] [NormedAlgebra 𝕜 A] [CompleteSpace A] {a : A} {r : Nnreal} (hr : ↑r < (spectral_radius 𝕜 a)⁻¹) : DifferentiableOn 𝕜 (λ (z : 𝕜), Ring.inverse (1 - z • a)) (Metric.ClosedBall 0 ↑r)
{α : Type u_1} {β : Type u_2} {t : α} {ts ys : List α} {r : List β} (f : List α → β) : (list.permutations_aux2 t List.nil r ys (λ (x : List α), f (x ++ ts))).snd = (list.permutations_aux2 t ts r ys f).snd
{α : Type u_1} (r : α → α → Prop) : Relation.Fibration (Relation.GameAdd (Relation.CutExpand r) (Relation.CutExpand r)) (Relation.CutExpand r) (λ (s : Multiset α × Multiset α), s.fst + s.snd)
{n p : ℕ} : List.count p n.factors = ⇑(n.factorization) p
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) {x y : L} : x ∈ S → y ∈ S → x * y ∈ S
{α : Type u} {β : Type v} [Preorder α] [LinearOrder β] {f g : α → β} (hF : Antitone f) (hg : Antitone g) : Antitone (λ (x : α), Linear_order.min (f x) (g x))
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [SemiNormedGroup F'] {f : α → E} {g' : α → F'} {l : Filter α} : (f =o[l] λ (x : α), ∥g' x∥) → f =o[l] g'
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {s : Set 𝕜} {n : WithTop ℕ} (Hcont : ∀ (m : ℕ), ↑m ≤ n → ContinuousOn (λ (x : 𝕜), iterated_deriv_within m f s x) s) (Hdiff : ∀ (m : ℕ), ↑m < n → DifferentiableOn 𝕜 (λ (x : 𝕜), iterated_deriv_within m f s x) s) : ContDiffOn 𝕜 n f s
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (p1 : P) {p2 p3 p4 : P} (h : EuclideanGeometry.angle p2 p3 p4 = Real.pi) : EuclideanGeometry.angle p1 p2 p3 = EuclideanGeometry.angle p1 p2 p4
{α : Type u_1} {μ₁ μ₂ : MeasureTheory.OuterMeasure α} (h : ∀ (s : Set α), s.nonempty → ⇑μ₁ s = ⇑μ₂ s) : μ₁ = μ₂
{β : Type u} {α : Type v} {γ : Type w} [CommMonoid β] {s : Finset γ} {t : Finset α} {f : γ → α → β} : (s.product t).prod (λ (x : γ × α), f x.fst x.snd) = s.prod (λ (x : γ), t.prod (λ (y : α), f x y))
{X : Top} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] (F : Top.Presheaf C X) : F.is_sheaf ↔ F.is_sheaf_PreservesLimit_Pairwise_intersections
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) {r : ℝ} (hr : r < 0) : InnerProductGeometry.angle (r • x) y = InnerProductGeometry.angle (-x) y
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {J : Type u} [CategoryTheory.Category J] (E : D ⥤ C) [CategoryTheory.IsEquivalence E] [CategoryTheory.Limits.HasLimitsOfShape J C] : CategoryTheory.Limits.HasLimitsOfShape J D
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : α → β} : Antitone f → Monotone (f ∘ ⇑order_dual.of_dual)
{α : Type u} [MetricSpace α] [ProperSpace α] {R : α → ℝ} (hR : ∀ (x : α), 0 < R x) : ∃ (ι : Type u) (c : ι → α) (r r' : ι → ℝ), (∀ (i : ι), 0 < r i ∧ r i < r' i ∧ r' i < R (c i)) ∧ LocallyFinite (λ (i : ι), Metric.Ball (c i) (r' i)) ∧ (⋃ (i : ι), Metric.Ball (c i) (r i)) = Set.Univ
{G : Type u} [Group G] [Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G} (hH : Fintype.card ↥H = p ^ n) : Fintype.card (↥(H.normalizer) ⧸ Subgroup.comap H.normalizer.subtype H) ≡ Fintype.card (G ⧸ H) [Mod p]
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} {s : Set E} {x : E} : MdifferentiableWithinAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x → DifferentiableWithinAt 𝕜 f s x
{z : ℂ} (hz : 0 < z.re) : ContinuousAt (λ (x : ℂ × ℂ), x.fst ^ x.snd) (0, z)
{M : Type u_1} [AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M →+ P} (hg : ∀ (y : ↥S), IsAddUnit (⇑g ↑y)) (z : N) : ⇑g ↑((f.sec z).snd) + ⇑(f.lift hg) z = ⇑g (f.sec z).fst
{f : ℕ →₀ ℕ} (hF : ∀ (p : ℕ), p ∈ f.support → Nat.Prime p) : (f.prod has_pow.pow).factorization = f
(ι : Type u_1) [Fintype ι] : is_IsCompact (StdSimplex ℝ ι)
{X : Type u} {Y : Type v} [MetricSpace X] [CompactSpace X] [Nonempty X] [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : GromovHausdorff.hD (Gromov_Hausdorff.candidates_b_dist X Y) ≤ Metric.diam Set.Univ + 1 + Metric.diam Set.Univ
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.Limits.HasCokernels C] {P Q : C} (f : P ⟶ Q) : Category_theory.abelian.factor_thru_image f ≫ CategoryTheory.Abelian.imageι f = f
{α : Type u} [Preorder α] {s : Set α} : ¬BddAbove s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), ¬y ≤ x
{x y z : ℤ} : PythagoreanTriple x y z ↔ PythagoreanTriple y x z
{X : Type u_2} [EmetricSpace X] {s : Set X} (hs : s.finite) : dimH s = 0
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] {ι : Type u_2} (s : Finset ι) (f : ι → Ideal R) (e : ι → ℕ) (Prime : ∀ (i : ι), i ∈ s → _root_.prime (f i)) (IsCoprime : ∀ (i : ι), i ∈ s → ∀ (j : ι), j ∈ s → i ≠ j → f i ≠ f j) : s.inf (λ (i : ι), f i ^ e i) = s.prod (λ (i : ι), f i ^ e i)
{R : Type u_1} [LinearOrderedField R] [FloorRing R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : r ≤ ↑b ^ x ↔ Int.clog b r ≤ x
{C : Type u₁} [CategoryTheory.Category C] {A : Type u₂} [CategoryTheory.Category A] (P : Cᵒᵖ ⥤ A) {X : C} (S : CategoryTheory.Sieve X) : Nonempty (CategoryTheory.Limits.IsLimit (P.map_cone S.arrows.cocone.op)) ↔ ∀ (E : Aᵒᵖ), CategoryTheory.Presieve.IsSheafFor (P ⋙ Category_theory.coyoneda.obj E) ⇑S
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {x y : 𝕜} (h : x ≤ y) {z : 𝕜} : z ∈ Set.Icc x y ↔ ∃ (a b : 𝕜), 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ a * x + b * y = z
{V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasZeroMorphisms V] {A B C : V} (f : A ⟶ B) [CategoryTheory.Limits.HasImage f] (g : B ⟶ C) [CategoryTheory.Limits.HasKernel g] (w : f ≫ g = 0) [CategoryTheory.Limits.HasCokernel (image_to_Kernel f g w)] {D : V} {k k' : homology f g w ⟶ D} (p : homologyπ f g w ≫ k = homologyπ f g w ≫ k') : k = k'
{G : Type u_1} {H : Type u_2} [AddGroup G] {N : AddSubgroup G} [AddGroup H] {f : G →+ H} (hF : Function.Surjective ⇑f) (hN : N = f.ker) (tN : Add_monoid.is_torsion ↥N) : Add_monoid.is_torsion H ↔ Add_monoid.is_torsion G
{P : ℕ → Prop} {m : ℕ} (h0 : P m) (h1 : ∀ (n : ℕ), m ≤ n → P n → P (n + 1)) (n : ℕ) : m ≤ n → P n
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] {p : P} : HasDist.dist p ↑(⇑(euclidean_geometry.orthogonal_projection s) p) = 0 ↔ p ∈ s
{α : Type u_2} {β : Type u_3} [DecidableEq α] [HasVsub α β] {u : Finset α} {s t : Set β} : ↑u ⊆ s -ᵥ t → (∃ (s' t' : Finset β), ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' -ᵥ t')
{α : Type u_1} (P : α → Prop) (r : α → α → Prop) (h : ∀ (s : Finset α), (∀ (x : α), x ∈ s → P x) → (∃ (y : α), P y ∧ ∀ (x : α), x ∈ s → r x y)) : ∃ (f : ℕ → α), (∀ (n : ℕ), P (f n)) ∧ ∀ (m n : ℕ), m < n → r (f m) (f n)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [BaireSpace α] [Encodable β] {f : β → Set α} (ho : ∀ (s : β), is_IsOpen (f s)) (hD : ∀ (s : β), Dense (f s)) : Dense (⋂ (s : β), f s)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {b₂ : Basis (Fin 2) ℝ V} (hb₂ : Orthonormal ℝ ⇑b₂) (ho : b.orientation = b₂.orientation) (θ : Real.Angle) : hb.rotation θ = hb₂.rotation θ
{G : Type u} [AddGroup G] {x : G} : IsOfFinAddOrder (-x) ↔ IsOfFinAddOrder x
{K : Type u_1} {v : K} {n : ℕ} [LinearOrderedField K] [FloorRing K] {b : K} (nth_Part_denom_Eq : (GeneralizedContinuedFraction.of v).partial_denominators.nth n = Option.some b) : 1 ≤ b
{α : Type u} [PseudoMetricSpace α] (s : Set α) : Continuous (λ (x : α), metric.inf_dist x s)
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y z : V} (hxyne : x ≠ y) (hxzne : x ≠ z) {r : ℝ} (hx : ∥x∥ = r) (hy : ∥y∥ = r) (hz : ∥z∥ = r) : o.oangle y z = 2 • o.oangle (y - x) (z - x)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x : V) : 2 • hb.oangle (-x) x = 0
{α : Type u_1} {β : Type u_2} {m₁ : MeasurableSpace α} {m₂ : MeasurableSpace β} {f : α → β} : MeasurableSpace.comap f m₂ ≤ m₁ → Measurable f
{α : Type u_1} [MetricSpace α] {β : Type u} [Nonempty β] (p : Besicovitch.TauPackage β α) (x : β) : p.to_ball_package.c x ∈ p.Union_Up_to p.last_step
{R : Type u} {S : Type v} [Semiring R] [Semiring S] [Nontrivial S] (f : R →+* S) : 1 ∉ f.ker
{β : Type u} {α : Type v} {s : Finset α} [CommMonoid β] (f : α → β) {p : α → Prop} [DecidablePred p] : (Finset.subtype p s).prod (λ (x : Subtype_ p), f ↑x) = (Finset.filter p s).prod (λ (x : α), f x)
{α : Type u} {a b : α} [MulZeroClass α] [PartialOrder α] [ZeroLt.PosMulMono α] (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b
{X Y S : Top} {f : X ⟶ S} {g : Y ⟶ S} (H₁ : OpenEmbedding ⇑f) (H₂ : OpenEmbedding ⇑g) : OpenEmbedding ⇑(CategoryTheory.Limits.limitπ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] (s1 s2 : AffineSubspace k P) : s1.direction ⊔ s2.direction ≤ (s1 ⊔ s2).direction
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f : ℂ → E} (hF : Differentiable ℂ f) (z : ℂ) : AnalyticAt ℂ f z
(M : Type u_1) (N : Type u_2) (α : Type u_3) [HasScalar M α] [HasScalar N α] [SmulCommClass M N α] : SmulCommClass N M α
(M : Type u_1) (α : Type u_2) [Monoid M] [MulAction M α] {ι : sort u_3} {s : ι → Set α} : fixing_Submonoid M (⋃ (i : ι), s i) = ⨅ (i : ι), fixing_Submonoid M (s i)
(E : Type u_1) [NormedGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E] : IsEmpty (Besicovitch.SatelliteConfig E (Besicovitch.multiplicity E) (besicovitch.good_τ E))
 : Filter.Tendsto (λ (N : ℕ), formal_multilinear_series.comp_partial_Sum_Target 0 N N) filter.at_Top filter.at_Top
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {x : E} {n : ℕ} : ContDiffAt 𝕜 ↑(n + 1) f x ↔ ∃ (f' : E → (E →L[𝕜] F)), (∃ (u : Set E) (H : u ∈ nhds x), ∀ (x : E), x ∈ u → HasFderivAt f (f' x) x) ∧ ContDiffAt 𝕜 ↑n f' x
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.FinitePresentation R A → Algebra.FiniteType R A
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (p : ι → P) (j : ι) (w₁ w₂ : ι → k) (hw : ∀ (i : ι), i ≠ j → w₁ i = w₂ i) : ⇑(s.weighted_vsub_of_point p (p j)) w₁ = ⇑(s.weighted_vsub_of_point p (p j)) w₂
{n : ℕ} {a b : Fin n} : ↑a < ↑b ↔ a < b
{G : Type u_1} [Group G] (K : Subgroup G) {k : Set G} : Subgroup.closure k ≤ K ↔ k ⊆ ↑K
{α : Type u_1} [LinearOrderedAddCommGroup α] {n : ℤ} {a b : α} (hn : n ≠ 0) : n • a = n • b ↔ a = b
(p : ℕ) [hp : Fact (Nat.Prime p)] (q r : ℚ) : padic_norm p (q / r) = padic_norm p q / padic_norm p r
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (hb : Filter.Tendsto f (nhds a ⊓ MeasureTheory.Measure_space.volume.ae) (nhds c)) : deriv (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) a = -c
{γ : Type u_1} [NonUnitalNonAssocSemiring γ] (x : γ) : IsAddMonoidHom (λ (y : γ), y * x)
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) {X Y : C} (f : Y ⟶ X) (S : CategoryTheory.Sieve X) : J₁.is_IsClosed S → J₁.is_IsClosed (CategoryTheory.Sieve.pullback f S)
{R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] [Semiring R₂] {σ₁₂ : R →+* R₂} [AddCommMonoid M₂] [Module R₂ M₂] [RingHomSurjective σ₁₂] (f : M →ₛₗ[σ₁₂] M₂) (s : Set M) (N : Submodule R₂ M₂) : Submodule.map f (Submodule.span R s) ≤ N ↔ ∀ (m : M), m ∈ s → ⇑f m ∈ N
{M : Type u_1} [MulOneClass M] {s : Set M} {p : M → M → Prop} {x y : M} (hx : x ∈ Submonoid.closure s) (hy : y ∈ Submonoid.closure s) (Hs : ∀ (x : M), x ∈ s → ∀ (y : M), y ∈ s → p x y) (H1_Left : ∀ (x : M), p 1 x) (H1_Right : ∀ (x : M), p x 1) (hMul_Left : ∀ (x y z : M), p x z → p y z → p (x * y) z) (hMul_Right : ∀ (x y z : M), p z x → p z y → p z (x * y)) : p x y
(M : Type u_1) {α : Type u_6} [Monoid M] [MulAction M α] (a₁ a₂ : M) : HasScalar.smul a₁ ∘ HasScalar.smul a₂ = HasScalar.smul (a₁ * a₂)
{R : Type u} [Ring R] (s : Subring R) {x : R} : x ∈ s → -x ∈ s
{α : Type u} [PartialOrder α] {a b : α} : a ≤ b → a < b ∨ a = b
 : UniqueDiffOn ℝ (Set.Icc 0 1)
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [LinearOrderedAddCommMonoid β] [HasScalar 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f g : E → β} (hF : StrictConcaveOn 𝕜 s f) (hg : StrictConcaveOn 𝕜 s g) : StrictConcaveOn 𝕜 s (f ⊓ g)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} {r' : Nnreal} (hF : HasFpowerSeriesOnBall f p x r) (h : ↑r' < r) : TendstoUniformlyOn (λ (n : ℕ) (y : E), p.partial_Sum n (y - x)) f filter.at_Top (Metric.Ball x ↑r')
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {ι : Type u_1} (b : Basis ι R M) [Infinite ι] {κ : Type u_1} (v : κ → M) (i : LinearIndependent R v) : Cardinal.mk κ ≤ Cardinal.mk ι
(f : ℝ → ℝ) {a b : ℝ} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hfI : f a = f b) : ∃ (c : ℝ) (H : c ∈ Set.Ioo a b), IsExtrOn f (Set.Icc a b) c
{𝕂 : Type u_1} {𝔸 : Type u_2} [NondiscreteNormedField 𝕂] [NormedCommRing 𝔸] [NormedAlgebra 𝕂 𝔸] [CompleteSpace 𝔸] [CharZero 𝕂] {x : 𝔸} (hx : x ∈ Emetric.Ball 0 (Exp_series 𝕂 𝔸).radius) : HasFderivAt (Exp 𝕂) (Exp 𝕂 x • 1) x
{k : Type u_1} {M : Type u_2} [OrderedRing k] [OrderedAddCommGroup M] [Module k M] [OrderedSmul k M] [CovariantClass M M has_add.add has_lt.lt] [ContravariantClass M M has_add.add has_lt.lt] {a b : k} {c d : M} (hba : b < a) (hdc : d < c) : a • d + b • c < a • c + b • d
{X : Type u} {m₁ m₂ : X → X → X} {e₁ e₂ : X} (h₁ : EckmannHilton.IsUnital m₁ e₁) (h₂ : EckmannHilton.IsUnital m₂ e₂) (Distrib : ∀ (a b c d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) : IsCommutative X m₂
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [SemiNormedGroup E'] {c : ℝ} {g : α → F} {f' : α → E'} {l : Filter α} : asymptotics.is_O_with c l (λ (x : α), ∥f' x∥) g → asymptotics.is_O_with c l f' g
{R : Type u} [Semiring R] {M : Polynomial R → Prop} (p : Polynomial R) (h_Add : ∀ (p q : Polynomial R), M p → M q → M (p + q)) (h_monomial : ∀ (n : ℕ) (a : R), M (⇑(Polynomial.monomial n) a)) : M p
{a x : ℝ} (ha : a < 0) : HasStrictDerivAt (λ (x : ℝ), a ^ x) (a ^ x * Real.log a - Real.exp (Real.log a * x) * Real.sin (x * Real.pi) * Real.pi) x
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] [LocallyCompactSpace α] (a : α) : Continuous (λ (f : C(α, β)), ⇑f a)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [TopologicalSpace.SecondCountableTopology α] : {x : α | ∃ (y : α), y < x ∧ Set.Ioo y x = ∅}.countable
{R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [Π (i : ι), Module R (M₁ i)] [Module R M₂] (f : MultilinearMap R M₁ M₂) [Fintype ι] (m m' : Π (i : ι), M₁ i) : ⇑f (m + m') = finset.univ.sum (λ (s : Finset ι), ⇑f (s.piecewise m m'))
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} (hab : a ≤ b) (hcont : ContinuousOn f (Set.Icc a b)) (hderiv : ∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivWithinAt f (f' x) (Set.Ioi x) x) (f'Int : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b) : ∫ (y : ℝ) in a..b, f' y = f b - f a
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [AddCommMonoid α] [TopologicalSpace α] [t2_Space α] [Encodable γ] (m : Set β → α) (m0 : m ∅ = 0) (s : γ → Set β) : ∑' (i : ℕ), m (⋃ (b : γ) (H : b ∈ Encodable.decode₂ γ i), s b) = ∑' (b : γ), m (s b)
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂] [Module K V₂] (f : V →ₗ[K] V₂) (w : Function.Injective ⇑f) [FiniteDimensional K V₂] : FiniteDimensional K V
{α : Type u_1} {ι : Type u_3} {M : Type u_5} [AddCommMonoid M] {f : α → M} [Fintype ι] {t : ι → Set α} (h : Pairwise (Disjoint on t)) (ht : ∀ (i : ι), (t i).finite) : finsum (λ (a : α), finsum (λ (H : a ∈ ⋃ (i : ι), t i), f a)) = finsum (λ (i : ι), finsum (λ (a : α), finsum (λ (H : a ∈ t i), f a)))
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜} (hs : Convex 𝕜 s) (hF : ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) ≤ (f y - f x) / (y - x)) : ConcaveOn 𝕜 s f
{α : Type u_1} [TopologicalSpace α] [MeasurableSpace α] [OpensMeasurableSpace α] {s : Set α} (hs : MeasurableSet s) (a : α) : (nhds_within a s).is_measurably_generated
{G : Type u_10} [AddGroup G] (a : G) : ⇑(Equiv.symm (equiv.add_Left a)) = has_add.add (-a)
{J : Type v} {C : Type u} [CategoryTheory.Category C] {X Y : C} {f : J → (X ⟶ Y)} [Nonempty J] {c : CategoryTheory.Limits.Cone (Category_theory.limits.parallel_family f)} (i : CategoryTheory.Limits.IsLimit c) : CategoryTheory.Mono (CategoryTheory.Limits.Tridentι c)
(R : Type u) [Semiring R] {ι : Type v} [decι : DecidableEq ι] {M : ι → Type w} [Π (i : ι), AddCommMonoid (M i)] [Π (i : ι), Module R (M i)] (i : ι) (c : R) (x : M i) : ⇑(DirectSum.of M i) (c • x) = c • ⇑(DirectSum.of M i) x
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [NondiscreteNormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (f : MultilinearMap 𝕜 E G) (C : ℝ) (H : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) : Continuous ⇑f
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) [CategoryTheory.Full F] [CategoryTheory.Faithful F] {X Y : C} (f : X ⟶ Y) [CategoryTheory.IsIso (F.map f)] : CategoryTheory.IsIso f
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] (f f' : ℝ → E) {a b : ℝ} {s : Set ℝ} (hs : s.countable) (Hc : ContinuousOn f (Set.Interval a b)) (hD : ∀ (x : ℝ), x ∈ Set.Ioo (Linear_order.min a b) (Linear_order.max a b)  s → HasDerivAt f (f' x) x) (Hi : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b) : ∫ (x : ℝ) in a..b, f' x = f b - f a
{α : Type u_1} (l : List α) (c : Composition l.length) : (l.split_wrt_Composition c).join = l
{α : Type u_1} {β : Type u_2} [LinearOrderedRing α] [FloorRing α] [TopologicalSpace α] [OrderTopology α] [TopologicalAddGroup α] [TopologicalSpace β] {f : α → β} (h : ContinuousOn f (Set.Icc 0 1)) (hF : f 0 = f 1) : Continuous (f ∘ Int.fract)
{D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ} (hF : ContinuousOn f D) (hF' : DifferentiableOn ℝ f (Interior D)) (hF'' : ∀ (x : ℝ), x ∈ Interior D → 0 < deriv^[2] f x) : StrictConvexOn ℝ D f
{α : Type u_1} [Preorder α] [PredOrder α] {a b : α} [NoMinOrder α] : Order.pred a < Order.pred b → a < b
{α : Type u_1} [CancelMonoidWithZero α] {a b c : α} (ha : a ≠ 0) : a * b ∣ a * c ↔ b ∣ c
{K : Type u_1} {S : Type u_2} {T : Type u_3} [Field K] [CommRing S] [CommRing T] [Algebra K S] [Algebra K T] [Algebra S T] [IsScalarTower K S T] (hST : Function.Injective ⇑(Algebra_Map S T)) {x : S} {y : T} (hx : IsIntegral K x) (h : y = ⇑(Algebra_Map S T) x) : minpoly K x = minpoly K y
(M : Type u_1) (N : Type u_2) (α : Type u_3) [HasVadd M α] [HasVadd N α] [VaddCommClass M N α] : VaddCommClass N M α
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : α ≃ₜ β) {b : β} {f : β → E} {g : β → F} {C : ℝ} : asymptotics.is_O_with C (nhds b) f g ↔ asymptotics.is_O_with C (nhds (⇑(e.symm) b)) (f ∘ ⇑e) (g ∘ ⇑e)
(F : Type u_1) (E : Type u_2) [Field F] [Field E] [Algebra F E] [FiniteDimensional F E] [IsSeparable F E] : ∃ (α : E), F⟮α⟯ = ⊤
{Γ₀ : Type u_1} [LinearOrderedCommGroupWithZero Γ₀] (γ : Γ₀ˣ) : nhds ↑γ = has_pure.pure ↑γ
{α : Type u_1} {p : α → Prop} (s : Finset {x // p x}) {a : α} (h : a ∈ Finset.map (Function.Embedding.subtype (λ (x : α), p x)) s) : p a
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {F G : C ⥤ D} (h_obj : ∀ (X : C), F.obj X = G.obj X) (h_Map : ∀ (X Y : C) (f : X ⟶ Y), F.map f = Category_theory.eq_to_hom _ ≫ G.map f ≫ Category_theory.eq_to_hom _) : F = G
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {s : Set α} {t : Set β} {f : α → β} (h : Set.MapsTo f s t) (hc : Continuous f) : Set.MapsTo f (Closure s) (Closure t)
(𝕜 : Type u_1) {E : Type u_2} [NormedField 𝕜] [NormedSpace ℝ 𝕜] [SemiNormedGroup E] [NormedSpace 𝕜 E] [Module ℝ E] [IsScalarTower ℝ 𝕜 E] : LocallyConvexSpace ℝ E
{α : Type u} [PseudoMetricSpace α] [ProperSpace α] {x : α} {r : ℝ} {s : Set α} (hs : is_IsClosed s) (h : s ⊆ Metric.Ball x r) : ∃ (r' : ℝ) (H : r' < r), s ⊆ Metric.Ball x r'
{X : Type u} {Y : Type v} [TopologicalSpace X] [TopologicalSpace Y] {f₀ f₁ : C(X, Y)} (F : f₀.homotopy f₁) : Continuous ⇑F
{α : Type u} [TopologicalSpace α] {ι : Type u_1} [Nonempty ι] {V : ι → Set α} (hV : Directed Superset V) (hV_cpct : ∀ (i : ι), is_IsCompact (V i)) (hV_IsClosed : ∀ (i : ι), is_IsClosed (V i)) {U : Set α} (hU : ∀ (x : α), (x ∈ ⋂ (i : ι), V i) → U ∈ nhds x) : ∃ (i : ι), V i ⊆ U
(X : Type u_2) [TopologicalSpace X] [RegularSpace X] [TopologicalSpace.SecondCountableTopology X] : TopologicalSpace.MetrizableSpace X
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (x y : R) : v.int_Valuation_def (x + y) ≤ Linear_order.max (v.int_Valuation_def x) (v.int_Valuation_def y)
{M : Type u_1} [HasMul M] {S T : Subsemigroup M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T
{α : Type u} [t : TopologicalSpace α] [TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α} {a : Set ι} (h : a.pairwise_Disjoint s) (ha : ∀ (i : ι), i ∈ a → is_IsOpen (s i)) (h'a : ∀ (i : ι), i ∈ a → (s i).nonempty) : a.countable
{C : Type u₁} [CategoryTheory.Category C] {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [CategoryTheory.Limits.HasPullback f g] : CategoryTheory.IsPullback CategoryTheory.Limits.pullback.fst CategoryTheory.Limits.pullback.snd f g
{α : Type u_1} {f : α → α} {x y : α} {m n : ℕ} (hx : Function.IsPeriodicPt f m x) (hy : Function.IsPeriodicPt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) : x = y
{α : Type u_1} [CommMonoid α] (a b u : α) (hu : IsUnit u) : a ∣ u * b ↔ a ∣ b
{α : Type u} {a b : α} [MulOneClass α] [HasZero α] [Preorder α] [ZeroLt.PosMulMono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 < a) : 1 ≤ a * b
{K : Type u_1} {v : K} {n : ℕ} [LinearOrderedField K] [FloorRing K] {ifp_n ifp_Succ_n : GeneralizedContinuedFraction.IntFractPair K} (nth_Stream_Eq : GeneralizedContinuedFraction.IntFractPair.stream v n = Option.some ifp_n) (Succ_nth_Stream_Eq : GeneralizedContinuedFraction.IntFractPair.stream v (n + 1) = Option.some ifp_Succ_n) : ↑(ifp_Succ_n.b) ≤ (ifp_n.fr)⁻¹
{p : ℕ} (z : ℤ) (hp : p ≠ 1) (hz : z ≠ 0) : padic_val_rat p ↑z = ↑((multiplicity ↑p z).get _)
{α : Type u_1} {β : Type u_2} (rα : α → α → Prop) (rβ : β → β → Prop) : Relation.GameAdd rα rβ ≤ Prod.lex rα rβ
{α : Type u} [TopologicalSpace α] {s t : Set α} (hs : Dense s) (ht : Dense t) (hso : is_IsOpen s) : Dense (s ∩ t)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {t₁ t₂ : Affine.Triangle ℝ P} (h : Set.Range t₁.points = Set.Range t₂.points) : t₁.orthocenter = t₂.orthocenter
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {b₂ : Basis (Fin 2) ℝ V} (hb₂ : Orthonormal ℝ ⇑b₂) (ho : b.orientation = b₂.orientation) (x y : V) : hb.oangle x y = hb₂.oangle x y
{R : Type u_1} {M : Type u_3} {a : R} [Monoid R] [MulAction R M] {n : ℕ} (n0 : 0 < n) : IsSmulRegular M (a ^ n) ↔ IsSmulRegular M a
{α : Type u_1} [PseudoMetricSpace α] (r C : ℝ) (hr : r < 1) {f : ℕ → α} (hu : ∀ (n : ℕ), HasDist.dist (f n) (f (n + 1)) ≤ C * r ^ n) {a : α} (ha : Filter.Tendsto f filter.at_Top (nhds a)) (n : ℕ) : HasDist.dist (f n) a ≤ C * r ^ n / (1 - r)
{R : Type u_1} [CommRing R] (f : Polynomial R) (r : R) : (⇑(Polynomial.taylor r) f).sum (λ (i : ℕ) (a : R), ⇑Polynomial.c a * (Polynomial.x - ⇑Polynomial.c r) ^ i) = f
{α : Type u_1} {ι' : sort u_5} [CompleteLattice α] (s : ι' → α) : (⨆ (i : ι'), s i) = ⨆ (t : Finset (plift ι')) (i : plift ι') (H : i ∈ t), s i.down
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [TopologicalSpace.SecondCountableTopology α] {y : α → α} {s : Set α} (h : s.pairwise_Disjoint (λ (x : α), Set.Ioo x (y x))) (h' : ∀ (x : α), x ∈ s → x < y x) : s.countable
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommGroup β] [HasScalar 𝕜 E] [Module 𝕜 β] {s : Set E} {f : E → β} : StrictConcaveOn 𝕜 s f → StrictConvexOn 𝕜 s (-f)
{X : Type u} {Y : Type v} [MetricSpace X] [MetricSpace Y] : Isometry Sum.inr
{M : Type u} [AddZeroClass M] (a : M) : AddSemiconjBy a 0 0
{X : Type u} [Lattice X] [JordanHolderLattice X] {s₁ s₂ : CompositionSeries X} (hl : s₁.length = s₂.length) (h : ∀ (i : Fin (s₁.length + 1)), ⇑s₁ i = ⇑s₂ (⇑(fin.cast _) i)) : s₁ = s₂
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {E : Type u₃} [CategoryTheory.Category E] {F : C ⥤ D} {G : D ⥤ E} {H : C ⥤ E} [ℋ : CategoryTheory.Faithful H] (h : F ⋙ G ≅ H) : CategoryTheory.Faithful F
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] {u v : E} (hvm : v ∈ K) (hvo : ∀ (w : E), w ∈ K → HasInner.inner (u - v) w = 0) : ↑(⇑(Orthogonal_projection K) u) = v
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (e e' : LocalHomeomorph α β) (h : ∀ (x : α), ⇑e x = ⇑e' x) (hinv : ∀ (x : β), ⇑(e.symm) x = ⇑(e'.symm) x) (hs : e.to_local_equiv.source = e'.to_local_equiv.source) : e = e'
{R : Type u} [Ring R] {P : Type (max u v)} [AddCommGroup P] [Module R P] {ι : Type u_1} (b : Basis ι R P) : Module.Projective R P
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {f : 𝕜 → F} : iterated_deriv (n + 1) f = iterated_deriv n (deriv f)
(A B : Finset ℕ) : A.sum (λ (i : ℕ), 2 ^ i) ≤ B.sum (λ (i : ℕ), 2 ^ i) ↔ A.to_colex ≤ B.to_colex
{α : Type u} {a b : α} [MulZeroOneClass α] [PartialOrder α] [ZeroLt.PosMulMono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 ≤ a) : 1 ≤ a * b
(x : ℝ) (h1 : 0 < x) (h2 : x < Real.pi / 2) : x < Real.tan x
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b
{G : Type u} [Group G] [Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] (hdvd : p ^ (n + 1) ∣ Fintype.card G) {H : Subgroup G} (hH : Fintype.card ↥H = p ^ n) : ∃ (K : Subgroup G), Fintype.card ↥K = p ^ (n + 1) ∧ H ≤ K
{R : Type u_1} [CommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {A : Type u_3} [Semiring A] [Algebra R A] {f g : TensorAlgebra R M →ₐ[R] A} (w : f.to_Linear_map.comp (TensorAlgebraι R) = g.to_Linear_map.comp (TensorAlgebraι R)) : f = g
{α : Type u_2} {β : Type u_3} [LinearOrderedField α] [Archimedean α] [LinearOrderedField β] : Subsingleton (α ≃+*o β)
{R : Type u_1} [CommRing R] (S : Type u_2) [CommRing S] [Algebra R S] (T : Type u_4) [CommRing T] [Algebra R T] (M N : Submonoid R) (h : M ≤ N) [IsLocalization M S] [IsLocalization N T] [Algebra S T] [IsScalarTower R S T] : IsLocalization (Submonoid.map (Algebra_Map R S).to_MonoidHom N) T
{α : Type u_1} {ι : Type u_2} [Encodable ι] [t : TopologicalSpace α] [p : PolishSpace α] (m : ι → TopologicalSpace α) (hm : ∀ (n : ι), m n ≤ t) (h'm : ∀ (n : ι), PolishSpace α) : ∃ (t' : TopologicalSpace α), (∀ (n : ι), t' ≤ m n) ∧ t' ≤ t ∧ PolishSpace α
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M →* P} (hg : ∀ (y : ↥S), IsUnit (⇑g ↑y)) (z : N) : ⇑g ↑((f.sec z).snd) * ⇑(f.lift hg) z = ⇑g (f.sec z).fst
{M : Type u_1} [HasMul M] (r : M → M → Prop) : ConGen r = HasInf.inf {s : Con M | ∀ (x y : M), r x y → ⇑s x y}
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommMonoid β] [Module 𝕜 E] [Module 𝕜 β] (f : E →ₗ[𝕜] β) {s : Set E} (hs : Convex 𝕜 s) : ConcaveOn 𝕜 s ⇑f
{R₁ : Type u_1} [Semiring R₁] {M₁ : Type u_4} [TopologicalSpace M₁] [AddCommMonoid M₁] [Module R₁ M₁] [TopologicalSpace R₁] {f g : R₁ ≃L[R₁] M₁} (h : ⇑f 1 = ⇑g 1) : f = g
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : E → ℝ} {a : E} {f' : E →L[ℝ] ℝ} (h : IsLocalExtr f a) : HasFderivAt f f' a → f' = 0
{M : Type u_3} {N : Type u_4} [HasMul M] [HasMul N] {f g : M →ₙ* N} (h : f = g) (x : M) : ⇑f x = ⇑g x
(X : AlgebraicGeometry.RingedSpace) {U : TopologicalSpace.Opens ↥X} (f : ↥(X.to_PresheafedSpace.presheaf.obj (Opposite.op U))) : IsUnit (⇑(X.to_PresheafedSpace.presheaf.map (Category_theory.hom_of_LE _).op) f)
{ι : sort u_1} [Nonempty ι] {f : ι → Ennreal} {x : Ennreal} (h : x ≠ ⊤) : infi f * x = ⨅ (i : ι), f i * x
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {E' : Type u_7} [InnerProductSpace 𝕜 E'] {v : ι → E} (hv : Orthonormal 𝕜 v) (f : E ≃ₗᵢ[𝕜] E') : Orthonormal 𝕜 (⇑f ∘ v)
{a b : Cardinal} : Cardinal.aleph_0 ≤ a * b ↔ a ≠ 0 ∧ Cardinal.aleph_0 ≤ b ∨ Cardinal.aleph_0 ≤ a ∧ b ≠ 0
{M : Type u_1} [MulOneClass M] (S : Submonoid M) : 1 ∈ S
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {ι : Type w} [Fintype ι] (h : Basis ι R M) : Module.rank R M = ↑(Fintype.card ι)
{α : Type u_1} [CommSemiring α] (t : Tree α) (r₁ r₂ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr r₁ = tactic.ring2.horner_expr.of_csexpr r₂) : tactic.ring2.csring_expr.eval t r₁ = tactic.ring2.csring_expr.eval t r₂
{k : Type u_1} {M : Type u_2} [OrderedRing k] [OrderedAddCommGroup M] [Module k M] [OrderedSmul k M] {a : M} {c : k} (hc : c < 0) : 0 < a → c • a < 0
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) : hb.oangle x y + hb.oangle y x = 0
(A : Type u_2) (K : Type u_3) [CommRing A] [Field K] [is_IsDomain A] [Algebra A K] [IsFractionRing A K] {L : Type u_4} [Field L] [Algebra K L] [FiniteDimensional K L] [Algebra A L] [IsScalarTower A K L] (s : Finset L) : ∃ (y : A) (H : y ≠ 0), ∀ (x : L), x ∈ s → IsIntegral A (y • x)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e e' : LocalHomeomorph α β} (h : e ≈ e') : Set.EqOn ⇑(e.symm) ⇑(e'.symm) e.to_local_equiv.target
{α : Type u} [PseudoMetricSpace α] (p : α → Prop) (x : α) (H : ∃ᶠ (R : ℝ) in filter.at_Top, ∀ (y : α), y ∈ Metric.ClosedBall x R → p y) (y : α) : p y
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X Y : C} (f g : X ⟶ Y) [CategoryTheory.Limits.HasCoequalizer f g] : CategoryTheory.Limits.HasCokernel (f - g)
{x : ℝ} (n : ℕ) {m : ℤ} (hm : m ≠ 0) (p : ℕ) [hp : Fact (Nat.Prime p)] (hxr : x ^ n = ↑m) (hv : (multiplicity ↑p m).get _ % n ≠ 0) : Irrational x
{k : Type u_1} {M : Type u_2} [OrderedRing k] [OrderedAddCommGroup M] [Module k M] [OrderedSmul k M] [ContravariantClass M M has_add.add has_le.le] {a b : k} {c d : M} (hab : a ≤ b) (hcd : c ≤ d) : a • d + b • c ≤ a • c + b • d
{R : Type u} [CommRing R] [is_IsDomain R] (hR : DiscreteValuationRing.HasUnitMulPowIrreducibleFactorization R) : DiscreteValuationRing R
(𝕜 : Type u_2) [is_R_or_C 𝕜] (E : Type u_3) [InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] : ∃ (w : Set E) (b : HilbertBasis ↥w 𝕜 E), ⇑b = Coe
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {s : Set (E × F)} {p : E × F} : ContDiffWithinAt 𝕜 n Prod.snd s p
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {ι' : Type u_3} {v : ι → E} (hv : Orthonormal 𝕜 v) (f : ι' → ι) (hF : Function.Injective f) : Orthonormal 𝕜 (v ∘ f)
(R : Type u) (L : Type v) (M : Type w) [CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M] [LieModule.IsNilpotent R L M] : (⨅ (x : L), (⇑(lie_module.to_endomorphism R L M) x).maximal_generalized_eigenspace 0) = ⊤
{R : Type u_1} [NonAssocSemiring R] [Nontrivial R] (hR : Ring_Char R ≠ 2) : 2 ≠ 0
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [NondiscreteNormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (f : ContinuousMultilinearMap 𝕜 E G) (m : Π (i : ι), E i) : ∥⇑f m∥₊ ≤ ∥f∥₊ * finset.univ.prod (λ (i : ι), ∥m i∥₊)
{K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂] [Module K V₂] [FiniteDimensional K V] (f : V →ₗ[K] V₂) : FiniteDimensional.finrank K ↥(f.range) + FiniteDimensional.finrank K ↥(f.ker) = FiniteDimensional.finrank K V
{M : Type u_2} {α : sort u_4} [AddCommMonoid M] {f : α → M} (p : M → Prop) (hp₀ : p 0) (hp₁ : ∀ (x y : M), p x → p y → p (x + y)) (hp₂ : ∀ (i : α), p (f i)) : p (finsum (λ (i : α), f i))
{α : Type u_1} [TopologicalSpace α] [BaireSpace α] {f : ℕ → Set α} (ho : ∀ (n : ℕ), is_IsOpen (f n)) (hD : ∀ (n : ℕ), Dense (f n)) : Dense (⋂ (n : ℕ), f n)
{α : Type u_1} {β : Type u_2} {ι : Type u_3} (a : α) (b : β) (i : ι) : (Filter.map (λ (_x : α), b) (Filter.principal {a})).coprod (Filter.map Id (Filter.principal {i})) = Filter.principal ({b} ×ˢ Set.Univ ∪ Set.Univ ×ˢ {i})
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (θ₁ θ₂ : Real.Angle) : (hb.rotation θ₁).trans (hb.rotation θ₂) = hb.rotation (θ₂ + θ₁)
{C : Type u₁} [CategoryTheory.Category C] {Z X Y : C} (f : Z ⟶ X) (g : Z ⟶ Y) [CategoryTheory.Limits.HasPushout f g] : CategoryTheory.IsPushout f g CategoryTheory.Limits.pushout.inl CategoryTheory.Limits.pushout.inr
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.FiniteType R A ↔ ∃ (s : Finset A) (f : MvPolynomial {x // x ∈ s} R →ₐ[R] A), Function.Surjective ⇑f
{X Y : CompHaus} (f : X ⟶ Y) (bij : Function.bijective ⇑f) : CategoryTheory.IsIso f
{α : Type u} [PseudoMetricSpace α] {s : Set α} (h : s.finite) : Metric.Bounded s
{α : Type u_3} {β : Type u_4} [LinearOrderedField α] {l : Filter β} {f : β → α} {r : α} (hr : 0 < r) (hF : Filter.Tendsto f l filter.at_Top) : Filter.Tendsto (λ (x : β), f x * r) l filter.at_Top
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p₁ : ι → P) (p₂ : P) (h : s.sum (λ (i : ι), w i) = 1) : s.sum (λ (i : ι), w i • (p₁ i -ᵥ p₂)) = ⇑(s.affine_combination p₁) w -ᵥ p₂
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) : ⇑LinearEquiv.det hb.conj_lie.to_LinearEquiv = -1
{𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} {P : Type u_8} {P₂ : Type u_9} [NormedField 𝕜] [SemiNormedGroup V] [SemiNormedGroup V₂] [NormedSpace 𝕜 V] [NormedSpace 𝕜 V₂] [PseudoMetricSpace P] [PseudoMetricSpace P₂] [NormedAddTorsor V P] [NormedAddTorsor V₂ P₂] {f : P →ᵃ[𝕜] P₂} : Continuous ⇑(f.linear) ↔ Continuous ⇑f
(k : ℕ) {r : ℝ} (hr : 0 ≤ r) (h'r : r < 1) : Filter.Tendsto (λ (n : ℕ), ↑n ^ k * r ^ n) filter.at_Top (nhds 0)
{β : Type u} {γ : Type w} [NonAssocSemiring β] [NonAssocSemiring γ] (f : β →+* γ) (s : Multiset β) : ⇑f s.sum = (Multiset.map ⇑f s).sum
{α : Type u} {β : Type v} [TopologicalSpace α] [Preorder α] [t : OrderClosedTopology α] [TopologicalSpace β] {f g : β → α} {s : Set β} (hs : is_IsClosed s) (hF : ContinuousOn f s) (hg : ContinuousOn g s) : is_IsClosed {x ∈ s | f x ≤ g x}
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (ha : Filter.Tendsto f (nhds a ⊓ MeasureTheory.Measure_space.volume.ae) (nhds c)) : HasStrictDerivAt (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) (-c) a
{α : Type u} (f : Fin 0 → α) : list.of_fn f = List.nil
{K : Type u_1} [LinearOrderedField K] {v : K} [FloorRing K] (terminates : (GeneralizedContinuedFraction.of v).terminates) : ∃ (n : ℕ), v = (GeneralizedContinuedFraction.of v).convergents n
{α β : Type u_1} (e : α ≃ β) : e.option_congr = Equiv_functor.map_Equiv Option e
{α : Type u_1} [CommMonoid α] (a b u : α) (hu : IsUnit u) : u * a ∣ b ↔ a ∣ b
(𝕜 : Type u_1) {E : Type u_4} [NormedGroup E] [NondiscreteNormedField 𝕜] [NormedSpace 𝕜 E] (𝕜' : Type u_12) [NormedField 𝕜'] [NormedAlgebra 𝕜 𝕜'] [NormedSpace 𝕜' E] [IsScalarTower 𝕜 𝕜' E] [Nontrivial E] : ∥ContinuousLinearMap.lsmul 𝕜 𝕜'∥ = 1
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (f : E →L[𝕜] F) [CompleteSpace F] (surj : Function.Surjective ⇑f) : ∃ (C : ℝ) (H : C ≥ 0), ∀ (y : F), ∃ (x : E), HasDist.dist (⇑f x) y ≤ 1 / 2 * ∥y∥ ∧ ∥x∥ ≤ C * ∥y∥
{q : ℕ+} (w : 1 < q) : Fintype.card (LucasLehmer.X q)ˣ < ↑q ^ 2
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} [DecidableEq α'] [DecidableEq γ] [DecidableEq δ] {f : α → β → γ} {s : Finset α} {t : Finset β} {g : γ → δ} {f' : α' → β → δ} {g' : α → α'} (h_Distrib : ∀ (a : α) (b : β), g (f a b) = f' (g' a) b) : Finset.image g (Finset.image₂ f s t) = Finset.image₂ f' (Finset.image g' s) t
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f₂ : 𝕜 → F} {s₂ : Set 𝕜} {n : ℕ} (hs : UniqueDiffOn 𝕜 s₂) : ContDiffOn 𝕜 ↑(n + 1) f₂ s₂ ↔ DifferentiableOn 𝕜 f₂ s₂ ∧ ContDiffOn 𝕜 ↑n (deriv_within f₂ s₂) s₂
{G : Type u_1} [AddGroup G] {H K : AddSubgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) : H = K
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f : X ⟶ Y} (F : CategoryTheory.Limits.StrongEpiMonoFactorisation f) {F' : CategoryTheory.Limits.MonoFactorisation f} (hF' : CategoryTheory.Limits.IsImage F') : CategoryTheory.StrongEpi F'.e
{α : Type u} [PseudoMetricSpace α] (x y : α) : HasEdist.edist x y ≠ ⊤
{ι : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : ι → M} [Semiring R] [AddCommMonoid M] [AddCommMonoid M'] [Module R M] [Module R M'] (f : M →ₗ[R] M') (hfv : LinearIndependent R (⇑f ∘ v)) : LinearIndependent R v
 : ¬Summable (λ (n : ℕ), (↑n)⁻¹)
(R : Type u) [Semiring R] (p q : ℕ) [hp : Char_p R p] [hq : ExpChar R q] : p = q ↔ Nat.Prime p
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasZeroObject C] (X : C) [IsSimpleOrder (CategoryTheory.Subobject X)] : CategoryTheory.Simple X
{G : Type u_1} [Group G] (H₁ H₂ : Subgroup G) (hH₁ : H₁.normal) (hH₂ : H₂.normal) (hdis : Disjoint H₁ H₂) (x y : G) (hx : x ∈ H₁) (hy : y ∈ H₂) : Commute x y
{R : Type u} [CommSemiring R] {n : ℕ} (m : Fin n →₀ ℕ) (f : MvPolynomial (Fin (n + 1)) R) (i : ℕ) : MvPolynomial.coeff m ((⇑(mv_polynomial.fin_Succ_Equiv R n) f).coeff i) = MvPolynomial.coeff (Finsupp.cons i m) f
(t : ℝ) : Filter.Tendsto (λ (x : ℕ), (1 + t / ↑x) ^ x) filter.at_Top (nhds (Real.exp t))
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [AddCommMonoid F] [OrderedAddCommMonoid β] [Module 𝕜 E] [Module 𝕜 F] [HasScalar 𝕜 β] {f : F → β} {s : Set F} (hF : ConvexOn 𝕜 s f) (g : E →ₗ[𝕜] F) : ConvexOn 𝕜 (⇑g ⁻¹' s) (f ∘ ⇑g)
{α : Type u_1} {N : Type u_6} [CommMonoid N] {f : α → N} (a : α) (hF : (Function.MulSupport f).finite) : f a ∣ finprod f
{C : Type u} [CategoryTheory.Category C] (F G : C ⥤ CategoryTheory.Discrete Punit) : F = G
{p : ℕ} [hp : Fact (Nat.Prime p)] : WittVector.IsPoly p (λ (R : Type u_1) (_x : CommRing R), has_neg.neg)
{α : Type u_1} {β : Type u_2} [t : TopologicalSpace β] [PolishSpace β] (f : α ≃ β) : PolishSpace α
{R : Type u} {n : ℕ} {M : Fin n.succ → Type v} {M₂ : Type v₂} [Semiring R] [Π (i : Fin n.succ), AddCommMonoid (M i)] [AddCommMonoid M₂] [Π (i : Fin n.succ), Module R (M i)] [Module R M₂] (f : MultilinearMap R M M₂) (m : Π (i : Fin n), M (⇑fin.cast_Succ i)) (c : R) (x : M (fin.last n)) : ⇑f (fin.snoc m (c • x)) = c • ⇑f (fin.snoc m x)
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂] [Module K V₂] (f : V ≃ₗ[K] V₂) [FiniteDimensional K V] : FiniteDimensional K V₂
(C : Type u) [𝒞 : CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryCoproducts C] [CategoryTheory.Limits.HasCoequalizers C] : CategoryTheory.Limits.HasPushouts C
{α : Type u_1} {β : Type u_2} [Group α] [CommGroup β] {f : α → β} (hF : IsGroupHom f) : IsGroupHom (λ (a : α), (f a)⁻¹)
(R : Type u_1) [CommRing R] [is_IsDomain R] (p : ℕ) [Char_p R p] (hp : p ≠ 2) : Polynomial.cyclotomic' 2 R = Polynomial.x + 1
{R : Type u_8} [OrderedSemiring R] [Nontrivial R] (l : List R) (h : ∀ (a : R), a ∈ l → 0 < a) : 0 < l.prod
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) {p : P} (hp : p ∈ affine_Span ℝ (Set.Range s.points)) {r : ℝ} (hr : ∀ (i : Fin (n + 1)), HasDist.dist (s.points i) p = r) : p = s.circumcenter
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type w} [CategoryTheory.Limits.HasPullbacks C] (K : CategoryTheory.Pretopology C) : CategoryTheory.Presieve.IsSheaf (Category_theory.pretopology.to_grothendieck C K) P ↔ ∀ {X : C} (R : CategoryTheory.Presieve X), R ∈ ⇑K X → CategoryTheory.Presieve.IsSheafFor P R
{α : Type u_3} [SemilatticeSup α] [NoMaxOrder α] (a : α) : Filter.map Coe filter.at_Top = filter.at_Top
{α : Type u_1} (r : α → α → Prop) [IsRefl α r] : {c : Cardinal | ∃ (S : Set α), (∀ (a : α), ∃ (b : α) (H : b ∈ S), r a b) ∧ Cardinal.mk ↥S = c}.nonempty
{x y : Game} : ¬x ≤ y ↔ y.lf x
{C : Type u₁} [CategoryTheory.Category C] {Z X Y : C} {f : Z ⟶ X} {g : Z ⟶ Y} {c : CategoryTheory.Limits.PushoutCocone f g} (h : CategoryTheory.Limits.IsColimit c) : CategoryTheory.IsPushout f g c.inl c.inr
{M : Type u_1} [CommMonoid M] (S : Submonoid M) : Localization.r S = Localization.r' S
{G : Type u_1} [Group G] [TopologicalSpace G] [TopologicalGroup G] {H : Subgroup G} (h_1_Int : 1 ∈ Interior ↑H) : is_IsOpen ↑H
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) {r : ℝ} (hr : 0 < r) : o.oangle (r • x) y = o.oangle x y
{R : Type u_1} [CommRing R] (v w : Fin 3 → R) : matrix.dot_Product v (⇑(⇑CrossProduct v) w) = 0
{G : Type u} [Group G] {N : Subgroup G} [N.normal] (hN : (Nat.card ↥N).coprime N.index) : ∃ (H : Subgroup G), H.is_complement' N
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P (n + 1)) : 0 < s.circumradius
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set ℝ} [Interval_integral.FTC_Filter b (nhds_within b s) (nhds_within b t)] (hmeas : StronglyMeasurableAtFilter f (nhds_within b t) MeasureTheory.MeasureSpace.volume) (hb : ContinuousWithinAt f t b) (hs : UniqueDiffWithinAt ℝ s b . "UniqueDiffWithinAt_ici_Iic_Univ") : deriv_within (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) s b = f b
{α : Type u_1} (v : Vector α 1) : v.to_List = [v.head]
{α : Type u} {β : Type v} {γ : Type w} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderTopology β] [Nonempty γ] {f : α → β} {g : γ → α} (Cf : ContinuousAt f (⨆ (i : γ), g i)) (Mf : Monotone f) (H : BddAbove (Set.Range g)) : f (⨆ (i : γ), g i) = ⨆ (i : γ), f (g i)
{k : Type u₁} {G : Type u₂} {R : Type u_1} [Semiring k] [AddMonoid G] [Semiring R] {f g : AddMonoidAlgebra k G →+* R} (h₀ : ∀ (b : k), ⇑f (Finsupp.single 0 b) = ⇑g (Finsupp.single 0 b)) (h_of : ∀ (a : G), ⇑f (Finsupp.single a 1) = ⇑g (Finsupp.single a 1)) : f = g
(a : Zmod8) : ⇑Zmodχ₈ a = 0 ∨ ⇑Zmodχ₈ a = 1 ∨ ⇑Zmodχ₈ a = -1
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] : FiniteDimensional.finrank K V = 1 ↔ ∃ (v : V) (n : v ≠ 0), ∀ (w : V), ∃ (c : K), c • v = w
{p : ℝ} : p ≤ 0 → ennreal.of_Real p = 0
(p : ℕ → Prop) [DecidablePred p] (i : Infinite ↥(SetOf p)) (n : ℕ) : Nat.nth p n = ↑(⇑(nat.subtype.order_iso_of_Nat (SetOf p)) n)
{x : Pgame} (h : 0 ≤ x) (j : x.right_moves) : 0 ≤ (x.move_Right j).move_Left (pgame.left_response h j)
{α : Type u} [TopologicalSpace α] {s : Set α} : is_IsCompact s → ∀ (f : Ultrafilter α), ↑f ≤ Filter.principal s → (∃ (a : α) (H : a ∈ s), ↑f ≤ nhds a)
{α : Type u} (f : α → Type (max u v)) : ¬Function.Surjective f
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {s : Set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_Diff : DifferentiableOn ℝ f s) (f_lim : ContinuousWithinAt f s a) (hs : s ∈ nhds_within a (Set.Ioi a)) (f_lim' : Filter.Tendsto (λ (x : ℝ), deriv f x) (nhds_within a (Set.Ioi a)) (nhds e)) : HasDerivWithinAt f e (Set.Ici a) a
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [CompactSpace α] [MetricSpace β] : Continuous (λ (p : C(α, β) × α), ⇑(p.fst) p.snd)
{α : Type u_1} {ι : Type u_2} {β : Type u_3} {S : ι → Set α} {f : Π (i : ι), ↥(S i) → β} {hF : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩} {T : Set α} (hT' : T = Set.Union S) (u : ↥T → ↥T) (ui : Π (i : ι), ↥(S i) → ↥(S i)) (hui : ∀ (i : ι) (x : ↥(S i)), u (Set.inclusion _ x) = Set.inclusion _ (ui i x)) (uβ : β → β) (h : ∀ (i : ι) (x : ↥(S i)), f i (ui i x) = uβ (f i x)) (x : ↥T) : Set.Union_Lift S f hF T _ (u x) = uβ (Set.Union_Lift S f hF T _ x)
{a b p q : ℝ} (ha : 0 ≤ a) (hb : 0 ≤ b) (hpq : p.is_conjugate_exponent q) : a * b ≤ a ^ p / p + b ^ q / q
{α : Type u_1} [ConditionallyCompleteLattice α] {s : Set α} {a : α} (hs : BddBelow s) (sne : s.nonempty) : HasInf.inf (HasInsert.insert a s) = a ⊓ HasInf.inf s
{M : Type u_1} {N : Type u_2} [MulOneClass M] [MulOneClass N] (h : M ≃* N) : IsMonoidHom ⇑h
{α : Type u} [TopologicalSpace α] {s : Set α} (hs : is_IsCompact s) {f : Filter α} (hF : ∀ (a : α), a ∈ s → (∃ (t : Set α) (H : t ∈ nhds_within a s), tᶜ ∈ f)) : sᶜ ∈ f
(p : ℕ) [hp : Fact (Nat.Prime p)] (n j : ℕ) (hj : j < p ^ n) : p ^ (n - pnat_multiplicity p ⟨j + 1, _⟩) ∣ (p ^ n).choose (j + 1)
(b c : ℝ) (n : ℕ) (hb : 0 < b) : Filter.Tendsto (λ (x : ℝ), (b * Real.exp x + c) / x ^ n) filter.at_Top filter.at_Top
{α : Type u_1} {β : Type u_2} [HasMul α] [CommGroup β] {f : α → β} (hF : IsMulHom f) : IsMulHom (λ (a : α), (f a)⁻¹)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (h : p 1 = ⇑((Continuous_multilinear_Curry_Fin1 𝕜 E F).symm) ↑i) : (p.left_Inv i).comp p = FormalMultilinearSeries.id 𝕜 E
{x y : Pgame} : x ≤ y ↔ (∀ (i : x.left_moves), (x.move_Left i).lf y) ∧ ∀ (j : y.right_moves), x.lf (y.move_Right j)
{M : Type u_1} [Monoid M] (x : M) : IsSubmonoid (Powers x)
{M : Type u} [AddZeroClass M] (x : M) : AddSemiconjBy 0 x x
{R : Type u_1} [LinearOrderedField R] [FloorRing R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : ↑b ^ x < r ↔ x < Int.clog b r
{α : Type u} {β : Type v} [Ring α] [Ring β] {f : α → β} (hF : IsRingHom f) {γ : Type u_1} [Ring γ] {g : β → γ} (hg : IsRingHom g) : IsRingHom (g ∘ f)
(K : Type u) [Field K] (V : Type v) [AddCommGroup V] [Module K V] [FiniteDimensional K V] : (LinearMap.ltensor V (contract_Left K V)).comp ((TensorProduct.assoc K V (Module.Dual K V) V).to_Linear_map.comp (LinearMap.rtensor V (coevaluation K V))) = (TensorProduct.rid K V).symm.to_Linear_map.comp (TensorProduct.lid K V).to_Linear_Map
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} [Nontrivial k] {s : Finset ι} {w : ι → k} (h : s.sum (λ (i : ι), w i) = 1) (p : ι → P) : ⇑(s.affine_combination p) w ∈ affine_Span k (Set.Range p)
{α : Type u_1} [DecidableEq α] [Fintype α] {f g : Equiv.perm α} (hF : f.is_Cycle) (hg : g.is_Cycle) (h : f.support ⊆ g.support) (h' : ∀ (x : α), x ∈ f.support → ⇑f x = ⇑g x) : f = g
{α : Type u} [Preorder α] {s t : Set α} (h : BddBelow t) : BddBelow (s ∩ t)
{α : Type u_1} [DecidableEq α] {s t : Finset α} (h : s ⊆ t) : (Finset.ioc s t).card = 2 ^ (t.card - s.card) - 1
(C : Type u) [CategoryTheory.Category C] : Nonempty (C ≌ CategoryTheory.Discrete Punit) ↔ Nonempty C ∧ ∀ (x y : C), Nonempty (Unique (x ⟶ y))
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} : InnerProductGeometry.angle x y = 0 ↔ x ≠ 0 ∧ ∃ (r : ℝ), 0 < r ∧ y = r • x
{C : Type u₁} [CategoryTheory.Category C] {A : C} [CategoryTheory.Limits.HasTerminal C] (hA : CategoryTheory.IsSubterminal A) : CategoryTheory.Mono (CategoryTheory.Limits.terminal.from A)
{n : ℤ} : IsUnit n → n.nat_Abs = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {D : Type u₁} [CategoryTheory.Category D] (L : C ⥤ D) [CategoryTheory.IsLeftAdjoint L] : CategoryTheory.IsCofiltered D
(𝕂 : Type u_1) {𝔸 : Type u_2} {𝔹 : Type u_3} [is_R_or_C 𝕂] [NormedRing 𝔸] [NormedAlgebra 𝕂 𝔸] [NormedRing 𝔹] [NormedAlgebra 𝕂 𝔹] [CompleteSpace 𝔸] {F : Type u_4} [RingHomClass F 𝔸 𝔹] (f : F) (hF : Continuous ⇑f) (x : 𝔸) : ⇑f (Exp 𝕂 x) = Exp 𝕂 (⇑f x)
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y z : M} (hx : SameRay R x z) (hy : SameRay R y z) : SameRay R (x + y) z
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [MetricSpace β] {f : α → β} (h : Embedding f) : Isometry f
{α : Type u} {β : Type v} [PseudoEmetricSpace α] [PseudoEmetricSpace β] {f : α → β} (hF : Isometry f) (x y : α) : HasEdist.edist (f x) (f y) = HasEdist.edist x y
{R : Type u} [Semiring R] {p : Polynomial R} {n : ℕ} (r : R) : p * Polynomial.x ^ n * ⇑Polynomial.c r = p * ⇑Polynomial.c r * Polynomial.x ^ n
(p : ℕ → Prop) [DecidablePred p] (n : ℕ) : Nat.count p n = Fintype.card {k // k < n ∧ p k}
{ι : Type u_1} {R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] (b : Basis ι R M) {x y : M} (h : ∀ (i : ι), ⇑(⇑(b.repr) x) i = ⇑(⇑(b.repr) y) i) : x = y
{𝕜 : Type u_1} {E : Type u_2} [LinearOrderedField 𝕜] [OrderedAddCommGroup E] [Module 𝕜 E] (S : ConvexCone 𝕜 E) (h : ∀ (x y : E), x ≤ y ↔ y - x ∈ S) : OrderedSmul 𝕜 E
{G : Type u_4} [NormedGroup G] [NormedSpace ℝ G] {s : Set G} {x y : G} (h : Segment ℝ x y ⊆ s) : y - x ∈ TangentConeAt ℝ s x
{α : Type u} [PseudoEmetricSpace α] {s t : Set α} (hs : s.nonempty) (Fin : emetric.Hausdorff_edist s t ≠ ⊤) : t.nonempty
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) [CategoryTheory.IsIso h.counit] : CategoryTheory.Faithful R
{M : Type u_1} [AddCommMonoid M] (S : AddSubmonoid M) : AddLocalization.r S = AddLocalization.r' S
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} {t : Set (Set α)} (h : t.pairwise_Disjoint Id) (ht₀ : t.finite) (ht₁ : ∀ (x : Set α), x ∈ t → x.finite) : finprod (λ (a : α), finprod (λ (H : a ∈ ⋃₀t), f a)) = finprod (λ (s : Set α), finprod (λ (H : s ∈ t), finprod (λ (a : α), finprod (λ (H : a ∈ s), f a))))
{R₂ : Type u_5} {M₂ : Type u_6} [CommSemiring R₂] [AddCommMonoid M₂] [Module R₂ M₂] {B₂ : BilinForm R₂ M₂} {ι : Type u_13} (b : Basis ι R₂ M₂) (x y : M₂) : (⇑(b.repr) x).sum (λ (i : ι) (xi : R₂), (⇑(b.repr) y).sum (λ (j : ι) (yj : R₂), xi • yj • ⇑B₂ (⇑b i) (⇑b j))) = ⇑B₂ x y
{C : Type u} [CategoryTheory.Category C] {X Y : AlgebraicGeometry.PresheafedSpace C} (f : X ⟶ Y) [h : AlgebraicGeometry.PresheafedSpace.IsOpenImmersion f] [h' : CategoryTheory.Epi f.base] : CategoryTheory.IsIso f
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [LinearOrderedField 𝕜] [AddCommGroup E] [OrderedAddCommGroup β] [Module 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f : E → β} {t : Finset ι} {w : ι → 𝕜} {p : ι → E} (hF : ConvexOn 𝕜 s f) (h₀ : ∀ (i : ι), i ∈ t → 0 ≤ w i) (h₁ : t.sum (λ (i : ι), w i) = 1) (hmem : ∀ (i : ι), i ∈ t → p i ∈ s) : f (t.sum (λ (i : ι), w i • p i)) ≤ t.sum (λ (i : ι), w i • f (p i))
{β : Type u_2} [CommMonoid β] {n : ℕ} (f : Fin (n + 1) → β) : finset.univ.prod (λ (i : Fin (n + 1)), f i) = finset.univ.prod (λ (i : Fin n), f (⇑fin.cast_Succ i)) * f (fin.last n)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {la lb : Filter ℝ} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f la MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f lb MeasureTheory.MeasureSpace.volume) {s t : Set ℝ} [Interval_integral.FTC_Filter a (nhds_within a s) la] [Interval_integral.FTC_Filter b (nhds_within b t) lb] (ha : Filter.Tendsto f la (nhds (f a))) (hb : Filter.Tendsto f lb (nhds (f b))) : HasFderivWithinAt (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) ((ContinuousLinearMap.snd ℝ ℝ ℝ).smul_Right (f b) - (ContinuousLinearMap.fst ℝ ℝ ℝ).smul_Right (f a)) (s ×ˢ t) (a, b)
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] (g : G) (p : P) : g +ᵥ p -ᵥ p = g
{n : WithTop ℕ} {𝕂 : Type u_6} [is_R_or_C 𝕂] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {f : 𝕂 → F'} {x : 𝕂} (hF : ContDiffAt 𝕂 n f x) (hn : 1 ≤ n) : HasStrictDerivAt f (deriv f x) x
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {r : ℝ} (hr : 0 < r) : NormedSpace.Polar 𝕜 (Metric.ClosedBall 0 r) = Metric.ClosedBall 0 r⁻¹
{R : Type u_1} {Rₘ : Type u_2} [CommRing R] [CommRing Rₘ] {M : Submonoid R} (hM : 0 ∉ M) (hR : IsField R) [Algebra R Rₘ] [IsLocalization M Rₘ] : Function.bijective ⇑(Algebra_Map R Rₘ)
(p : ℕ) (q : ℚ) : 0 ≤ padic_norm p q
{α : Type u_1} {β : Type u_2} [SemilatticeInf α] [OrderTop α] {P : α → Prop} {Ptop : P ⊤} {Pinf : ∀ ⦃x y : α⦄, P x → P y → P (x ⊓ y)} (t : Finset β) (f : β → {x // P x}) : ↑(t.inf f) = t.inf (λ (x : β), ↑(f x))
{α : Type u_1} {f g : ℕ → α} [TopologicalSpace α] [NonUnitalNonAssocSemiring α] [RegularSpace α] [TopologicalSemiring α] (hF : Summable f) (hg : Summable g) (hfg : Summable (λ (x : ℕ × ℕ), f x.fst * g x.snd)) : (∑' (n : ℕ), f n) * ∑' (n : ℕ), g n = ∑' (n : ℕ), (Finset.Nat.antidiagonal n).sum (λ (kl : ℕ × ℕ), f kl.fst * g kl.snd)
{M : Type u_1} [AddMonoid M] {γ : Type u_2} [AddMonoid γ] {f : M → γ} (hF : IsAddMonoidHom f) : IsAddSubmonoid (Set.Range f)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} (hderiv : ∀ (x : ℝ), x ∈ Set.Interval a b → HasDerivAt f (f' x) x) (hint : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b) : ∫ (y : ℝ) in a..b, f' y = f b - f a
{α : Type u} {β : Type v} [AddGroup α] [AddAction α β] (g : α) (x : β) : AddAction.stabilizer α (g +ᵥ x) = AddSubgroup.map (Add_equiv.to_Add_MonoidHom (⇑AddAut.conj g)) (AddAction.stabilizer α x)
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {m : α → β → γ} {f : Filter α} {g : Filter β} {n : γ → δ} {m' : α → β' → δ} {n' : β → β'} (h_Distrib : ∀ (a : α) (b : β), n (m a b) = m' a (n' b)) : Filter.map n (Filter.map₂ m f g) = Filter.map₂ m' f (Filter.map n' g)
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type w} {X : C} (R : CategoryTheory.Presieve X) : CategoryTheory.Presieve.IsSheafFor P R ↔ CategoryTheory.Presieve.IsSheafFor P ⇑(CategoryTheory.Sieve.generate R)
{α : Type u_1} {β : Type u_2} {rα : α → α → Prop} {rβ : β → β → Prop} (f : α → β) (fib : Relation.Fibration rα rβ f) {a : α} (ha : Acc rα a) : Acc rβ (f a)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) {fs : Finset (Fin (n + 1))} {m : ℕ} (h : fs.card = m + 1) : ↑(⇑((s.face h).orthogonal_projection_Span) s.circumcenter) = (s.face h).circumcenter
{k : Type u_1} {E : Type u_2} [LinearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k → E} {a b r : k} (hab : a < b) (h₀ : 0 < r) (h₁ : r < 1) : f (⇑(affine_map.line_Map a b) r) ≤ ⇑(affine_map.line_Map (f a) (f b)) r ↔ slope f a (⇑(affine_map.line_Map a b) r) ≤ slope f (⇑(affine_map.line_Map a b) r) b
{S : Type u_1} [HasMul S] {a b : S} (h : Commute a b) : a * b = b * a
(w₁ w₂ z₁ z₂ : Nnreal) (hw' : w₁ + w₂ = 1) {p : ℝ} (hp : 1 ≤ p) : (w₁ * z₁ + w₂ * z₂) ^ p ≤ w₁ * z₁ ^ p + w₂ * z₂ ^ p
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {ι₁ : Type u_3} {s₁ : Finset ι₁} {w₁ : ι₁ → ℝ} (p₁ : ι₁ → P) (h₁ : s₁.sum (λ (i : ι₁), w₁ i) = 0) {ι₂ : Type u_4} {s₂ : Finset ι₂} {w₂ : ι₂ → ℝ} (p₂ : ι₂ → P) (h₂ : s₂.sum (λ (i : ι₂), w₂ i) = 0) : HasInner.inner (⇑(s₁.weighted_vsub p₁) w₁) (⇑(s₂.weighted_vsub p₂) w₂) = -s₁.sum (λ (i₁ : ι₁), s₂.sum (λ (i₂ : ι₂), w₁ i₁ * w₂ i₂ * (HasDist.dist (p₁ i₁) (p₂ i₂) * HasDist.dist (p₁ i₁) (p₂ i₂)))) / 2
{p : ℕ} [Fact (Nat.Prime p)] (q r : ℚ_[p]) : padic_norm_e (q + r) ≤ Linear_order.max (padic_norm_e q) (padic_norm_e r)
 : ⇑LinearMap.det ↑(complex.conj_lie.to_LinearEquiv) = -1
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (s : AffineSubspace ℝ P) [Nonempty ↥s] [CompleteSpace ↥(s.direction)] {p₁ : P} (hp₁ : p₁ ∈ s) (p₂ : P) : HasDist.dist p₁ (⇑(EuclideanGeometry.reflection s) p₂) = HasDist.dist p₁ p₂
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hD : DiffContOnCl ℂ f (Set.Ioi 0 ×ℂ Set.Ioi 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Ioi 0)] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hre : ∀ (x : ℝ), 0 ≤ x → ∥f ↑x∥ ≤ C) (him : ∀ (x : ℝ), 0 ≤ x → ∥f (↑x * Complex.i)∥ ≤ C) (hz_re : 0 ≤ z.re) (hz_im : 0 ≤ z.im) : ∥f z∥ ≤ C
{M : Type u_1} {N : Type u_2} [has_Add M] [has_Add N] {c : AddCon M} {f : M → N} (H : ∀ (x y : M), f (x + y) = f x + f y) (h : Add_con.add_Ker f H ≤ c) (hF : Function.Surjective f) : c.map_gen f = c.map_of_surjective f H h hF
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {f : R →+* S} {p : Polynomial S} (hlifts : p ∈ Polynomial.lifts f) : ∃ (q : Polynomial R), Polynomial.map f q = p ∧ q.degree = p.degree
 : Function.Injective has_dvd.dvd
{α : Type u_1} (s : Multiset α) (p : α → Prop) [DecidablePred p] : Multiset.count True (Multiset.map p s) = ⇑Multiset.card (Multiset.filter p s)
{𝕜 : Type u_1} [LinearOrderedField 𝕜] [TopologicalSpace 𝕜] [OrderTopology 𝕜] {s : Set 𝕜} : StrictConvex 𝕜 s → s.ord_connected
{R : Type u_1} [Rack R] (x y : R) : Rack.act (Shelf.act x y) = Rack.act x * Rack.act y * (Rack.act x)⁻¹
{α : Type u} {β : Type v} [CompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [CompleteLinearOrder β] [TopologicalSpace β] [OrderTopology β] {ι : sort u_1} [Nonempty ι] {f : α → β} {g : ι → α} (Cf : ContinuousAt f (supr g)) (Mf : Monotone f) : f (⨆ (i : ι), g i) = ⨆ (i : ι), f (g i)
{α : Type u_1} {l : List α} : l <:+ List.nil → l = List.nil
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (e : M ≃ₗ[R] M) (v : Module.Ray R M) : e • v = ⇑(Module.Ray.map e) v
{X : Type u_1} [TopologicalSpace X] (s : Set X) : SeqClosure s ⊆ Closure s
{M : Type u_1} [AddMonoid M] : Add_monoid.fg M ↔ ∃ (S : Set M), AddSubmonoid.closure S = ⊤ ∧ S.finite
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {D : Type u₁} [CategoryTheory.Category D] (R : C ⥤ D) [CategoryTheory.IsRightAdjoint R] : CategoryTheory.IsFiltered D
{α : Type u} {β : Type v} [Setoid α] [TopologicalSpace α] {f : β → α} (hF : DenseRange f) : DenseRange (Quotient.mk ∘ f)
{α : Type u} [MetricSpace α] (x : ℕ → α) (H : DenseRange x) : Isometry (Kuratowski_embedding.embedding_of_Subset x)
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b
{α : Type u} [OrderedSemiring α] {a b c d : α} [HasExistsAddOfLe α] (hba : b < a) (hdc : d < c) : a • d + b • c < a • c + b • d
{α : Type u} [SemilatticeInf α] [Nonempty α] {s : Set α} (hs : s.finite) : BddBelow s
{α : Type u_1} {r : α → α → Prop} : IsMaxChain r (MaxChain r)
{p : Polynomial ℤ} (hp : p.is_primitive) : Irreducible p ↔ Irreducible (Polynomial.map (int.cast_RingHom ℚ) p)
{α : Type u} {r : α → α → Prop} {a b : α} (p : α → Prop) (l : List α) (h : List.Chain r a l) (hb : (a :: l).last _ = b) (carries : ∀ ⦃x y : α⦄, r x y → p y → p x) (final : p b) : p a
{D : Set ℝ} (hD : Convex ℝ D) (hD₂ : is_IsOpen D) {f : ℝ → ℝ} (hF' : DifferentiableOn ℝ f D) (hF'' : ∀ (x : ℝ), x ∈ D → deriv^[2] f x < 0) : StrictConcaveOn ℝ D f
{α : Type u} [TopologicalSpace α] {s : Set α} {ι : Type v} (hs : is_IsCompact s) (U : ι → Set α) (hUo : ∀ (i : ι), is_IsOpen (U i)) (hsU : s ⊆ ⋃ (i : ι), U i) : ∃ (t : Finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i
{α : Type u_1} {r : α → α → Prop} {a b c : α} (h : ∀ (a b c : α), r a b → r a c → (∃ (d : α), Relation.ReflGen r b d ∧ Relation.ReflTransGen r c d)) (hab : Relation.ReflTransGen r a b) (hac : Relation.ReflTransGen r a c) : Relation.Join (Relation.ReflTransGen r) b c
{α : Type u} [PseudoMetricSpace α] {s : Set α} {x y : α} (h : Metric.Bounded s) (hx : x ∈ s) (hy : y ∈ s) : HasDist.dist x y ≤ Metric.diam s
{R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [Π (i : ι), Module R (M₁ i)] [Module R M₂] {M₁' : ι → Type u_1} [Π (i : ι), AddCommMonoid (M₁' i)] [Π (i : ι), Module R (M₁' i)] (g : MultilinearMap R M₁' M₂) (f : Π (i : ι), M₁ i ≃ₗ[R] M₁' i) : g.comp_Linear_Map (λ (i : ι), ↑(f i)) = 0 ↔ g = 0
{C : Type u} [CategoryTheory.Category C] {X : Top} (F : Top.Presheaf C X) : F.is_sheaf_Opens_LE_cover ↔ F.is_sheaf_Pairwise_intersections
{ι : Type u} {X : Type v} [TopologicalSpace X] {s : Set X} [NormalSpace X] (p : (X → ℝ) → Prop) (h01 : ∀ (s t : Set X), is_IsClosed s → is_IsClosed t → Disjoint s t → (∃ (f : C(X, ℝ)), p ⇑f ∧ Set.EqOn ⇑f 0 s ∧ Set.EqOn ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ Set.Icc 0 1)) (hs : is_IsClosed s) (U : ι → Set X) (ho : ∀ (i : ι), is_IsOpen (U i)) (hF : LocallyFinite U) (hU : s ⊆ ⋃ (i : ι), U i) : ∃ (f : BumpCovering ι X s), (∀ (i : ι), p ⇑(⇑f i)) ∧ f.is_subordinate U
{α : Type u} [PseudoMetricSpace α] [CompleteSpace α] {s : ℕ → Set α} (hs : ∀ (n : ℕ), is_IsClosed (s n)) (h's : ∀ (n : ℕ), Metric.Bounded (s n)) (h : ∀ (N : ℕ), (⋂ (n : ℕ) (H : n ≤ N), s n).nonempty) (h' : Filter.Tendsto (λ (n : ℕ), Metric.diam (s n)) filter.at_Top (nhds 0)) : (⋂ (n : ℕ), s n).nonempty
{R : Type x} [HasMul R] [has_Add R] [RightDistribClass R] (a b c : R) : (a + b) * c = a * c + b * c
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ HasInner.inner x y = 0
{α : Type u} {a b : α} [MulOneClass α] [HasZero α] [Preorder α] [ZeroLt.PosMulMono α] (ha : a < 1) (hb : b ≤ 1) (a0 : 0 < a) : a * b < 1
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {a b : α} (h₁ : a ⊆ b) (h₂ : ¬b ⊆ a) : a ⊂ b
{α : Type u_1} {β : Type u_2} {M : Type u_5} [CommMonoid M] {s : Set α} {t : Set β} {f : α → M} {g : β → M} (e : α → β) (hE₀ : Set.BijOn e s t) (hE₁ : ∀ (x : α), x ∈ s → f x = g (e x)) : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) = finprod (λ (j : β), finprod (λ (H : j ∈ t), g j))
(p : ℕ) [hp : Fact (Nat.Prime p)] : WittVector.IsPoly p (λ (R : Type u_1) (_Rcr : CommRing R), ⇑WittVector.frobenius)
(p : ℕ) [p_Prime : Fact (Nat.Prime p)] {q r : ℚ} (hqr : q + r ≠ 0) (h : padic_val_rat p q ≤ padic_val_rat p r) : padic_val_rat p q ≤ padic_val_rat p (q + r)
{α : Type u_1} [HasLe α] {a : αᵒᵈ} : IsTop a → IsBot (⇑order_dual.of_dual a)
{M : Type u_4} [CommMonoid M] {ι : Type u_1} [Subsingleton ι] {s : Finset ι} {f : ι → M} {b : M} (h : s.prod (λ (i : ι), f i) = b) (i : ι) (H : i ∈ s) : f i = b
{x : ℝ} (hx : 0 ≤ x) (hx' : x ≤ Real.pi / 2) : 2 / Real.pi * x ≤ Real.sin x
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] (v : ↥K) : ⇑(Orthogonal_projection K) ↑v = v
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} {p : ι → P} (ha : AffineIndependent k p) (s : Set ι) : AffineIndependent k (λ (i : ↥s), p ↑i)
{δ : ℝ} {X : Type u} [PseudoMetricSpace X] {E : Set X} {x : X} : x ∈ Metric.Thickening δ E ↔ ∃ (z : X) (H : z ∈ E), HasDist.dist x z < δ
{R : Type v} [Ring R] {L M N K : Module R} {f : L ⟶ M} {g : M ⟶ N} (w : f ≫ g = 0) {h k : homology f g w ⟶ K} (w_1 : ∀ (x : ↥(LinearMap.ker g)), ⇑h (⇑(CategoryTheory.Limits.cokernelπ (image_to_Kernel f g w)) (⇑Module.to_Kernel_Subobject x)) = ⇑k (⇑(CategoryTheory.Limits.cokernelπ (image_to_Kernel f g w)) (⇑Module.to_Kernel_Subobject x))) : h = k
{p n : ℕ} : padic_val_rat p ↑n = ↑(padic_val_Nat p n)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) : hb.rotation ↑Real.pi = LinearIsometryEquiv.neg ℝ
{C : Type u₁} [CategoryTheory.Category C] {J : Type u₂} [CategoryTheory.Category J] [CategoryTheory.Limits.HasColimitsOfShape Jᵒᵖ C] : CategoryTheory.Limits.HasLimitsOfShape J Cᵒᵖ
{A : Type u_1} {B : Type u_2} [Field A] [Ring B] [is_IsDomain B] [Algebra A B] {x : B} (hx : IsIntegral A x) {y : A} (h : (minpoly A x).is_root y) : ⇑(Algebra_Map A B) y = x
{H : Type u} {M : Type u_2} [TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M] {G : StructureGroupoid H} {e e' : LocalHomeomorph M H} (hE : e ∈ StructureGroupoid.MaximalAtlas M G) (hE' : e' ∈ StructureGroupoid.MaximalAtlas M G) : e.symm.trans e' ∈ G
{α : Type u_1} [HasLe α] {a : α} : IsMax a → IsMin (⇑order_dual.to_dual a)
{C : Type v} [CategoryTheory.SmallCategory C] {D : Type v} [CategoryTheory.SmallCategory D] (F : C ⥤ D) [F.initial] {E : Type u} [CategoryTheory.Category E] {G : D ⥤ E} [CategoryTheory.Limits.HasLimit (F ⋙ G)] : CategoryTheory.Limits.HasLimit G
{α : Type u_1} [TopologicalSpace α] [TopologicalSpace.SecondCountableTopology α] (m : MeasureTheory.OuterMeasure α) (s : Set α) (hs : ∀ (x : α), x ∈ s → (∃ (u : Set α) (H : u ∈ nhds_within x s), ⇑m u = 0)) : ⇑m s = 0
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {f : α → E} {g : α → F} {l : Filter α} : (∀ ⦃c : ℝ⦄, 0 < c → asymptotics.is_O_with c l f g) → f =o[l] g
{α : Type u_1} {ι : sort u_3} [ConditionallyCompleteLinearOrder α] {b : α} [Nonempty ι] {f : ι → α} (h : b < supr f) : ∃ (i : ι), b < f i
(𝕜 : Type u_1) {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] (f : E → F) : is_IsOpen {x : E | AnalyticAt 𝕜 f x}
{α : Type u} [DecidableEq α] [Fintype α] {P : Equiv.perm α → Prop} (f : Equiv.perm α) : P 1 → (∀ (f : Equiv.perm α) (x y : α), x ≠ y → P f → P (equiv.swap x y * f)) → P f
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {a b : α} : IsPreconnected (Set.Icc a b)
(f : ℝ → ℝ) {a b : ℝ} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hfI : f a = f b) : ∃ (c : ℝ) (H : c ∈ Set.Ioo a b), IsLocalExtr f c
{G : Type u_1} [Group G] (H : Subgroup G) (hnc : NormalizerCondition G) (hmax : IsCoatom H) : H.normal
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M →* P} {T : Submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [CommMonoid Q] {k : T.localization_Map Q} {A : Type u_5} [CommMonoid A] {U : Submonoid A} {R : Type u_6} [CommMonoid R] (j : U.localization_Map R) {l : P →* A} (hl : ∀ (w : ↥T), ⇑l ↑w ∈ U) (x : N) : ⇑(k.map hl j) (⇑(f.map hy k) x) = ⇑(f.map _ j) x
{P : Type u_1} [Preorder P] (s t : Order.Pfilter P) (h : ↑s = ↑t) : s = t
{α : Type u_1} [LinearOrderedField α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b ↔ b⁻¹ ≤ a
{R : Type u} {M : Type v} {ι : Type w} [Semiring R] [AddCommMonoid M] {Module_M : Module R M} (p : Submodule R M) (x : ι → ↥p) (s : Finset ι) : ↑(s.sum (λ (i : ι), x i)) = s.sum (λ (i : ι), ↑(x i))
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] : (reflection K).symm = reflection K
{M : Type u_1} {R : Type u_4} [NonUnitalNonAssocSemiring R] [SetLike M R] [MulMemClass M R] {S : M} {a b : R} (ha : a ∈ S) (hb : b ∈ AddSubmonoid.closure ↑S) : a * b ∈ AddSubmonoid.closure ↑S
{α : Type u} {β : Type v} [PartialOrder α] [Preorder β] {l : α → β} {u : β → α} (gc : GaloisConnection l u) (a : α) : (∃ (b : β), a = u b) ↔ a = u (l a)
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] {ι : sort u_2} (p : ι → Submodule R M) {C : Π (x : M), (x ∈ ⨆ (i : ι), p i) → Prop} (hp : ∀ (i : ι) (x : M) (H : x ∈ p i), C x _) (h0 : C 0 _) (hAdd : ∀ (x y : M) (hx : x ∈ ⨆ (i : ι), p i) (hy : y ∈ ⨆ (i : ι), p i), C x hx → C y hy → C (x + y) _) {x : M} (hx : x ∈ ⨆ (i : ι), p i) : C x hx
{α : sort u_1} {β : sort u_2} {γ : sort u_3} (f : α → β → γ) (P : Prop) [Decidable P] (a b : α) (c d : β) : f (Ite P a b) (Ite P c d) = Ite P (f a c) (f b d)
{X : Type u_1} [TopologicalSpace X] {x y : X} (γ : Path x y) : Continuous γ.extend
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [LinearOrderedAddCommMonoid β] [HasScalar 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f : E → β} (hF : StrictConcaveOn 𝕜 s f) {x y z : E} (hx : x ∈ s) (hy : y ∈ s) (hxy : x ≠ y) (hz : z ∈ OpenSegment 𝕜 x y) : Linear_order.min (f x) (f y) < f z
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] (i : D ⥤ C) [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.CartesianClosed C] (h : ∀ (B : D) (A : C), (CategoryTheory.exp A).obj (i.obj B) ∈ i.ess_image) : CategoryTheory.ExponentialIdeal i
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b
{α : Type u} {ι : sort x} {f : ι → α} [h : Unique ι] : Set.Range f = {f Inhabited.default}
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] : 0 < FiniteDimensional.finrank K V ↔ Nontrivial V
{n : ℕ} {x : ℕ × ℕ} : x ∈ Multiset.Nat.antidiagonal n ↔ x.fst + x.snd = n
{α : Type u_1} {M : Type u_5} {N : Type u_6} [CommMonoid M] [CommMonoid N] {s : Set α} (f : α → M) (g : M →* N) (hs : s.finite) : ⇑g (finprod (λ (j : α), finprod (λ (H : j ∈ s), f j))) = finprod (λ (i : α), finprod (λ (H : i ∈ s), ⇑g (f i)))
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y : V} (h : ∥x∥ = ∥y∥) : x = y ↔ hb.oangle x y = 0
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (θ : Real.Angle) : ⇑LinearEquiv.det (hb.rotation θ).to_LinearEquiv = 1
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] (p1 p2 p3 : P) : p1 -ᵥ p2 + (p2 -ᵥ p3) = p1 -ᵥ p3
{α : Type u_1} {M : Type u_5} {N : Type u_7} [AddZeroClass M] [CommMonoid N] {f g : α →₀ M} {h : α → M → N} (h_Zero : ∀ (a : α), a ∈ f.support ∪ g.support → h a 0 = 1) (h_Add : ∀ (a : α), a ∈ f.support ∪ g.support → ∀ (b₁ b₂ : M), h a (b₁ + b₂) = h a b₁ * h a b₂) : (f + g).prod h = f.prod h * g.prod h
{ι : Type u} (f : ι → Ordinal) : BddAbove (Set.Range f)
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] (p1 p2 : P) : -(p1 -ᵥ p2) = p2 -ᵥ p1
{α : Type u_1} {M : Type u_4} [has_One M] {s : Set α} {f : α → M} {a : α} (h : s.mul_indicator f a ≠ 1) : a ∈ s
 : Cardinal.ord ∘ Cardinal.aleph' = ordinal.enum_Ord {b : Ordinal | b.card.ord = b}
{α : Type u} {β : Type v} [Preorder β] {f : α → β} {l : Filter α} {a : α} : IsExtrFilter (⇑order_dual.to_dual ∘ f) l a → IsExtrFilter f l a
{n d : ℕ} (hnd : d ∣ n) : (n / d).totient = (Finset.filter (λ (k : ℕ), n.gcd k = d) (Finset.range n)).card
{α : Type u_1} [CancelCommMonoidWithZero α] {a b c : α} (hc : c ≠ 0) : a * c ∣ b * c ↔ a ∣ b
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} [DecidableEq β'] [DecidableEq γ] [DecidableEq δ] {f : α → β → γ} {s : Finset α} {t : Finset β} {g : γ → δ} {f' : α → β' → δ} {g' : β → β'} (h_Distrib : ∀ (a : α) (b : β), g (f a b) = f' a (g' b)) : Finset.image g (Finset.image₂ f s t) = Finset.image₂ f' s (Finset.image g' t)
{α : Type u} (r : α → α → Prop) [IsPartialOrder α r] : ∃ (s : α → α → Prop) (_x : IsLinearOrder α s), r ≤ s
{S : Type u_1} [Semigroup S] {a b c : S} (hab : Commute a b) (hac : Commute a c) : Commute a (b * c)
(f : Circle_deg1_Lift) (hF : Continuous ⇑f) : ∃ (x : ℝ), ⇑f x = x + f.translation_number
{α : Type u_1} [ConditionallyCompleteLattice α] {s : Set α} {a : α} (H : IsGreatest s a) : HasSup.sup s = a
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] (p : P) : Collinear k {p}
 : Cardinal.mk ℂ = Cardinal.continuum
{K : Type u} [Field K] {s : Set K} {p : K → Prop} {x : K} (h : x ∈ Subfield.closure s) (Hs : ∀ (x : K), x ∈ s → p x) (H1 : p 1) (hAdd : ∀ (x y : K), p x → p y → p (x + y)) (Hneg : ∀ (x : K), p x → p (-x)) (Hinv : ∀ (x : K), p x → p x⁻¹) (hMul : ∀ (x y : K), p x → p y → p (x * y)) : p x
{α : Type u_1} [LinearOrder α] {s : Finset α} {k : ℕ} (h : s.card = k) {f : Fin k → α} (hfs : ∀ (x : Fin k), f x ∈ s) (hmono : StrictMono f) : f = ⇑(s.order_emb_of_Fin h)
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} : finsum (λ (i : α), finsum (λ (H : i ∈ ∅), f i)) = 0
{V : Type u_1} {α : Type u_2} [MulZeroOneClass α] [Nontrivial α] {A : Matrix V V α} (h : A.is_IsAdjMatrix) [DecidableEq α] : simple_graph.adj_Matrix α h.to_graph = A
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [FiniteDimensional 𝕜 E] {K : Submodule 𝕜 E} {n : ℕ} (h_dim : FiniteDimensional.finrank 𝕜 ↥K + n = FiniteDimensional.finrank 𝕜 E) : FiniteDimensional.finrank 𝕜 ↥Kᗮ = n
 : PythagoreanTriple 0 0 0
{D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ} (hF : ContinuousOn f D) (hF' : DifferentiableOn ℝ f (Interior D)) (hF'_Mono : StrictMonoOn (deriv f) (Interior D)) : StrictConvexOn ℝ D f
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : ℕ} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ ⇑fin.cast_Succ j) : X.σ j.succ ≫ X.δ (⇑fin.cast_Succ i) = X.δ i ≫ X.σ j
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] (a b : α) : Filter.comap Coe (nhds_within b (Set.Iio b)) = filter.at_Top
{R : Type u} [CommSemiring R] [Nontrivial R] {p : Fin 2 → R} (h : IsCoprime (p 0) (p 1)) : p ≠ 0
{a b : ℝ} (m n : ℕ) : ∫ (x : ℝ) in a..b, Real.sin x ^ m * Real.cos x ^ (2 * n + 1) = ∫ (u : ℝ) in Real.sin a..real.sin b, u ^ m * (1 - u ^ 2) ^ n
{n : Type u} [DecidableEq n] [Fintype n] {α : Type v} [CommRing α] (A : Matrix n n α) (b : n → α) : ⇑(A.cramer) b = A.adjugate.mul_vec b
(n : ℕ) : (n + 1) * (n + 1).central_binom = 2 * (2 * n + 1) * n.central_binom
{ι : Type u_1} {R : Type u_2} {α : Type u_3} {S : Type u_4} [SetLike S R] [Monoid R] [AddMonoid ι] (A : ι → S) [SetLike.GradedMonoid A] (fι : α → ι) (fA : Π (a : α), ↥(A (fι a))) (l : List α) : ↑(l.dprod fι fA) = (List.map (λ (a : α), ↑(fA a)) l).prod
{C : Type u} [𝒞 : CategoryTheory.Category C] {X Y Z : C} (f : X ⟶ Y) (g : X ⟶ Z) [CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair Y Z)] [CategoryTheory.Limits.HasColimit (Category_theory.limits.parallel_pair (f ≫ CategoryTheory.Limits.coprod.inl) (g ≫ CategoryTheory.Limits.coprod.inr))] : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span f g)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x : V} (hx : x ≠ 0) (θ : Real.Angle) : hb.oangle (⇑(hb.rotation θ) x) x = -θ
{β : Type v} {γ : Type u_1} [TopologicalSpace β] [TopologicalSpace γ] {ι : Type u_2} {κ : Type u_3} {f : ι → β} {g : κ → γ} (hF : DenseRange f) (hg : DenseRange g) : DenseRange (Prod.map f g)
{γ : Type w} [SemilatticeInf γ] (a : γ) {s : Set γ} : BddBelow (HasInsert.insert a s) ↔ BddBelow s
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ InnerProductGeometry.angle x y = Real.pi / 2
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {ι : Type u_1} (v : ι → M) (i : LinearIndependent R v) (w : Set M) [Fintype ↥w] (s : Set.Range v ≤ ↑(Submodule.span R w)) : Cardinal.mk ι ≤ ↑(Fintype.card ↥w)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] : CategoryTheory.Preadditive_yoneda ⋙ (Category_theory.whiskering_Right Cᵒᵖ AddCommGroup (Type v)).obj (CategoryTheory.forget AddCommGroup) = CategoryTheory.yoneda
{α : Type u} [PseudoEmetricSpace α] {δ : ℝ} {s : Set α} {x : α} : emetric.inf_edist x s ≤ emetric.inf_edist x (Metric.Thickening δ s) + ennreal.of_Real δ
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) {ι : Type u_3} {t : Finset ι} {f : ι → L} (h : ∀ (c : ι), c ∈ t → f c ∈ S) : t.sum (λ (i : ι), f i) ∈ S
{ι : Type u_1} {E : Type u_3} [SemiNormedGroup E] {f : ι → E} (hF : Summable (λ (i : ι), ∥f i∥₊)) : ∥∑' (i : ι), f i∥₊ ≤ ∑' (i : ι), ∥f i∥₊
{a b : Ordinal} (h : b ≠ 0) : {o : Ordinal | a < b * Order.succ o}.nonempty
{α : Type u_1} [DecidableEq α] (P : Finset α → Finset α → Prop) (Symm : ∀ {a b : Finset α}, P a b → P b a) (Empty_Right : ∀ {a : Finset α}, P a ∅) (singletons : ∀ {a b : α}, P {a} {b}) (union_of : ∀ {a b c : Finset α}, P a c → P b c → P (a ∪ b) c) (a b : Finset α) : P a b
{α : Type u_1} {β : Type u_2} {f : α ↪ β} {s : Finset α} : s.nonempty → (Finset.map f s).nonempty
{C : Type u} [CategoryTheory.Category C] (Ps : Set (Cᵒᵖ ⥤ Type v)) (J : CategoryTheory.GrothendieckTopology C) (hJ : ∀ (P : Cᵒᵖ ⥤ Type v), P ∈ Ps → CategoryTheory.Presieve.IsSheaf J P) : J ≤ Category_theory.sheaf.finest_topology Ps
{R : Type u_3} {A : Type u_5} [CommRing R] [CommRing A] [Algebra R A] {ι : Type u_1} {f : ι → A} (hF : Function.Injective f) : AlgebraicIndependent R Coe → AlgebraicIndependent R f
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (u : E) {v : E} (hv : HasInner.inner u v = 0) : v ∈ (Submodule.span 𝕜 {u})ᗮ
(n : ℕ) : (Nat.fib n).coprime (Nat.fib (n + 1))
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (s : Finset ι) [CharZero k] (h : s.nonempty) : s.sum (λ (i : ι), Finset.centroid_weights k s i) = 1
{M : Type u_3} [Monoid M] [Preorder M] [CovariantClass M M (Function.swap has_mul.mul) has_le.le] [CovariantClass M M has_mul.mul has_le.le] {l₁ l₂ : List M} (h : l₁ <+ l₂) (h₁ : ∀ (a : M), a ∈ l₂ → 1 ≤ a) : l₁.prod ≤ l₂.prod
{α : Type u} [Group α] [Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)] (h : Fintype.card α = p) : IsSimpleGroup α
(f : Bool → Bool) (x : Bool) : f (f (f x)) = f x
{α : Type u} [PartialOrder α] {a b : α} : a ≤ b → b ≤ a → b = a
{G : Type u_1} [Group G] : NormalizerCondition G ↔ ∀ (H : Subgroup G), H.normalizer = H → H = ⊤
{C : Type u} [CategoryTheory.Category C] (F : Cᵒᵖ ⥤ Type v) : (CategoryTheory.Category_of_elements.to_CostructuredArrow F).right_Op ⋙ CategoryTheory.Category_of_elements.from_CostructuredArrow F = 𝟭 F.elements
{α : Type u} [PseudoMetricSpace α] {s : Set α} (c : α) : Metric.Bounded s ↔ ∃ (r : ℝ), s ⊆ Metric.ClosedBall c r
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NormedCommRing 𝕜] [AddCommMonoid E] [AddCommMonoid F] [Module 𝕜 E] [Module 𝕜 F] (B : E →ₗ[𝕜] F →ₗ[𝕜] 𝕜) (s : Set E) : is_IsClosed (B.polar s)
{α : Type u} [PseudoEmetricSpace α] {δ : ℝ} (δ_Pos : 0 < δ) (E : Set α) : E ⊆ Metric.Thickening δ E
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) {r : ℝ} (hr : 0 < r) : InnerProductGeometry.angle (r • x) y = InnerProductGeometry.angle x y
{X Y : Type u} (f : X ⟶ Y) : CategoryTheory.Mono f ↔ Function.Injective f
{α : Type u_1} {β : Type u_2} [has_Add α] [Preorder α] [Preorder β] {f g : β → α} [CovariantClass α α has_add.add has_lt.lt] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] (hF : StrictMono f) (hg : StrictMono g) : StrictMono (λ (x : β), f x + g x)
{G : Type u} {x : G} {n : ℕ} [Fintype G] [Group G] : x ^ n = 1 ↔ x ^ n.gcd (Fintype.card G) = 1
{C : Type u₁} [CategoryTheory.Category C] {A : Type u₂} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (P : Cᵒᵖ ⥤ A) : (∀ (E : A), CategoryTheory.Presieve.IsSeparated J (P ⋙ Category_theory.coyoneda.obj (Opposite.op E))) ↔ ∀ ⦃X : C⦄ (S : CategoryTheory.Sieve X), S ∈ ⇑J X → ∀ (c : CategoryTheory.Limits.Cone (S.arrows.diagram.op ⋙ P)), Subsingleton (c ⟶ P.map_cone S.arrows.cocone.op)
{R : Type u_1} [CommSemiring R] {x : R} : HasStar.star x = x
{α : Type u_1} [PseudoEmetricSpace α] (C : Ennreal) (hC : C ≠ ⊤) {f : ℕ → α} (hu : ∀ (n : ℕ), HasEdist.edist (f n) (f (n + 1)) ≤ C / 2 ^ n) : CauchySeq f
{R : Type u_1} [Ring R] [TopologicalSpace R] [NonarchimedeanRing R] (U : OpenAddSubgroup R) (r : R) : ∃ (V : OpenAddSubgroup R), r • ↑V ⊆ ↑U
{f : ℝ → ℝ} (hF : Differentiable ℝ f) (hF' : ∀ (x : ℝ), deriv f x ≤ 0) : Antitone f
{G : Type u_1} {H : Type u_2} [AddGroup G] [AddGroup H] [IsAddCyclic H] (f : G →+ H) (hF : f.ker ≤ AddSubgroup.center G) (a b : G) : a + b = b + a
{M : Type u_1} [has_Add M] {r : M → M → Prop} {c : AddCon M} (h : ∀ (x y : M), r x y → Setoid.r x y) : AddConGen r ≤ c
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (w : ι → k) (p : ι → P) {s₁ s₂ : Finset ι} (h : s₁ ⊆ s₂) : ⇑(s₁.weighted_vsub p) w = ⇑(s₂.weighted_vsub p) (↑s₁.indicator w)
{α : Type u} [PseudoMetricSpace α] {f : α → ℝ} {s : Set α} {K : Nnreal} (hF : LipschitzOnWith K f s) : ∃ (g : α → ℝ), LipschitzWith K g ∧ Set.EqOn f g s
{𝕜 : Type u_1} [NormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {c : 𝕜} (hc : 1 < ∥c∥) {R : ℝ} (hR : ∥c∥ < R) {F : Subspace 𝕜 E} (hFc : is_IsClosed ↑F) (hF : ∃ (x : E), x ∉ F) : ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥
{p n : ℕ} (hp : Nat.Prime p) (hDiv : p ∣ n) (R : Type u_1) [CommRing R] : ⇑(Polynomial.expand R p) (Polynomial.cyclotomic n R) = Polynomial.cyclotomic (n * p) R
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y z : M} (hy : SameRay R x y) (hz : SameRay R x z) : SameRay R x (y + z)
{K : Type u_1} {n : ℕ} {g : GeneralizedContinuedFraction K} [DivisionRing K] {m : ℕ} (m_Lt_n : m < n) : (g.squash_gcf (n + 1)).s.nth m = g.s.nth m
{p : ℕ} [hp : Fact (Nat.Prime p)] {n : ℕ} (hn : 0 < n) : padic_val_Nat p n = (multiplicity p n).get _
{α : sort u_1} {s₁ : Setoid α} : Function.Surjective Quotient.mk'
{R : Type u_1} {M : Type u_3} [MonoidWithZero R] [HasZero M] [MulActionWithZero R M] (h : IsSmulRegular M 0) : Subsingleton M
{M : Type u_1} [Semigroup M] (a : Stream M) (s : Set (Set M)) (sfin : s.finite) (scov : Hindman.FP a ⊆ ⋃₀s) : ∃ (c : Set M) (H : c ∈ s) (b : Stream M), Hindman.FP b ⊆ c
(α : Type u_1) [CompleteLattice α] (k : α) : CompleteLattice.IsCompactElement k ↔ ∀ (s : Set α), s.nonempty → DirectedOn has_le.le s → k ≤ HasSup.sup s → (∃ (x : α), x ∈ s ∧ k ≤ x)
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteCoproducts C] [CategoryTheory.Limits.HasCokernels C] [CategoryTheory.NormalEpiCategory C] {X Y : C} (f : X ⟶ Y) (Z : C) (l : CategoryTheory.Limits.IsLimit (Category_theory.limits.kernel_fork.of_ι 0 _)) : CategoryTheory.Mono f
{α : Type u_1} [LinearOrder α] [PredOrder α] [IsPredArchimedean α] (r : α → α → Prop) {n m : α} (h1 : ∀ (i : α), i ∈ Set.Ioc m n → r i (Order.pred i)) (h2 : ∀ (i : α), i ∈ Set.Ioc n m → r (Order.pred i) i) (hnm : n ≠ m) : Relation.TransGen r n m
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G} {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFpowerSeriesAt g q (f x)) (hF : HasFpowerSeriesAt f p x) : HasFpowerSeriesAt (g ∘ f) (q.comp p) x
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : EuclideanGeometry.angle p1 p2 p3 = EuclideanGeometry.angle p1 p3 p2) (hpi : EuclideanGeometry.angle p2 p1 p3 ≠ Real.pi) : HasDist.dist p1 p2 = HasDist.dist p1 p3
{p : ℕ} [Fact (Nat.Prime p)] {R : Type u₁} [CommSemiring R] [Char_p R p] {P : Type u₃} [CommSemiring P] [Char_p P p] [PerfectRing P p] {f : P →+* R} (g : P ≃+* ring.perfection R p) (hfg : ⇑(Perfection.lift p P R) f = ↑g) : PerfectionMap p f
{α : Type u_1} {β : Type u_2} [UniformSpace β] {f : α → β} [TopologicalSpace α] (L : ∀ (x : α) (u : Set (β × β)), u ∈ Uniformity β → (∃ (t : Set α) (H : t ∈ nhds x) (F : α → β), ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u)) : Continuous f
{q : ℕ+} (i : ℕ) : ↑(LucasLehmer.s i) = LucasLehmer.Xω ^ 2 ^ i + LucasLehmer.Xωb ^ 2 ^ i
{α : Type u} [PseudoMetricSpace α] (f : ℕ → α) {m n : ℕ} (h : m ≤ n) : HasDist.dist (f m) (f n) ≤ (Finset.ico m n).sum (λ (i : ℕ), HasDist.dist (f i) (f (i + 1)))
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {n : WithTop ℕ} {s : Set E} {f g : E → F} (hF : ContDiffWithinAt 𝕜 n f s x) (hg : ContDiffWithinAt 𝕜 n g s x) : ContDiffWithinAt 𝕜 n (λ (x : E), f x + g x) s x
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} [DecidableEq α'] [DecidableEq γ] [DecidableEq δ] {s : Finset α} {t : Finset β} {f : α' → β → γ} {g : α → α'} {f' : α → β → δ} {g' : δ → γ} (h_Left_comm : ∀ (a : α) (b : β), f (g a) b = g' (f' a b)) : Finset.image₂ f (Finset.image g s) t = Finset.image g' (Finset.image₂ f' s t)
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type w} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace 𝕜] [FiniteDimensional 𝕜 E] [FiniteDimensional 𝕜 F] : Nonempty (E ≃L[𝕜] F) ↔ FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 F
{𝕜 : Type u_1} {E : Type u} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] {s : Set E} {x : E} (hx : x ∈ ⇑(Convex_hull 𝕜) s) : ∃ (ι : Type u) (_x : Fintype ι) (z : ι → E) (w : ι → 𝕜) (hss : Set.Range z ⊆ s) (hai : AffineIndependent 𝕜 z) (hw : ∀ (i : ι), 0 < w i), finset.univ.sum (λ (i : ι), w i) = 1 ∧ finset.univ.sum (λ (i : ι), w i • z i) = x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C} [CategoryTheory.Simple Y] {f : X ⟶ Y} [CategoryTheory.Mono f] (w : f ≠ 0) : CategoryTheory.IsIso f
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] (ι : Type u_1) [Unique ι] : FiniteDimensional.finrank K V = 1 ↔ Nonempty (Basis ι K V)
(x : Pgame) : (0 + x).equiv x
{α : Type u} [PseudoEmetricSpace α] (δ : ℝ) {E₁ E₂ : Set α} (h : E₁ ⊆ E₂) : Metric.Cthickening δ E₁ ⊆ Metric.Cthickening δ E₂
{ι : Type u_1} {α : ι → Type u_2} [Fintype ι] [DecidableEq ι] [Π (i : ι), DecidableEq (α i)] [Π (i : ι), LinearOrder (α i)] {p : (Π (i : ι), Finset (α i)) → Prop} (f : Π (i : ι), Finset (α i)) (h0 : p (λ (_x : ι), ∅)) (step : ∀ (g : Π (i : ι), Finset (α i)) (i : ι) (x : α i), (∀ (y : α i), y ∈ g i → y < x) → p g → p (Function.update g i (HasInsert.insert x (g i)))) : p f
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [NondiscreteNormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (f : MultilinearMap 𝕜 E G) {C : ℝ} (hC : 0 ≤ C) (H : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) (m₁ m₂ : Π (i : ι), E i) : ∥⇑f m₁ - ⇑f m₂∥ ≤ C * ↑(Fintype.card ι) * Linear_order.max ∥m₁∥ ∥m₂∥ ^ (Fintype.card ι - 1) * ∥m₁ - m₂∥
{G : Type u} {x y : G} [CommMonoid G] (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) : IsOfFinOrder (x * y)
{α : Type u_1} [DecidableEq α] {𝒜 : Finset (Finset α)} {s : Finset α} (hs : s ∈ 𝒜.shadow) : ∃ (t : Finset α) (H : t ∈ 𝒜), s ⊆ t
{n : ℕ} {α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) (v : Vector α n) (x : α) : Vector.scanl f b (x::ᵥv) = b::ᵥVector.scanl f (f b x) v
{𝕜 : Type u_1} [Field 𝕜] {M : Type u_2} [AddCommGroup M] [Module 𝕜 M] (c : 𝕜) (f : M →ₗ[𝕜] M) : ⇑LinearMap.det (c • f) = c ^ FiniteDimensional.finrank 𝕜 M * ⇑LinearMap.det f
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} (hx : ∥x∥ = 1) (hy : ∥y∥ = 1) : HasInner.inner x y < 1 ↔ x ≠ y
(p : ℕ) [hp : Fact (Nat.Prime p)] (z : ℤ) : padic_norm p ↑z ≤ 1
{A : Type u_6} [CommRing A] [is_IsDomain A] {M : Submonoid A} (hM : M ≤ NonZeroDivisors A) : is_IsDomain (Localization M)
{α : Type u} [NonUnitalNonAssocRing α] (a b c : α) : (a - b) * c = a * c - b * c
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {f : Filter α} {g : Filter β} {m : α → β' → γ} {n : β → β'} {m' : β → α → δ} {n' : δ → γ} (h_Right_anticomm : ∀ (a : α) (b : β), m a (n b) = n' (m' b a)) : Filter.map₂ m f (Filter.map n g) = Filter.map n' (Filter.map₂ m' g f)
{α : Type u} {β : Type v} [Ring α] [Ring β] {f : α → β} (H : IsSemiringHom f) : IsRingHom f
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_4} [DecidableEq ι] [Fintype ι] (e : Basis ι R M) [Nontrivial R] : e.det ≠ 0
{α : Type u_1} [Preorder α] [AddCommMonoid α] [HasSub α] [HasOrderedSub α] {a b : α} : a ≤ b → a - b ≤ 0
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (X Y : C) [CategoryTheory.Limits.HasBinaryProduct X Y] : CategoryTheory.Limits.HasBinaryBiproduct X Y
{ι : Type u_1} {α : Type u_3} [Preorder ι] [Preorder α] {l : Filter ι} {u : ι → α} (h : Monotone u) [l.ne_IsBot] (hu : Filter.Tendsto u l filter.at_Top) : Filter.Tendsto u filter.at_Top filter.at_Top
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (x : R) (hx : x ≠ 0) : v.int_Valuation_def x ≠ 0
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] [h : Nontrivial V] : 0 < FiniteDimensional.finrank K V
{𝕜 : Type u_3} [is_R_or_C 𝕜] {n m : ℕ} (A B : Matrix (Fin n) (Fin m) 𝕜) (i j : Fin m) : HasInner.inner (A.transpose i) (B.transpose j) = A.conj_transpose.mul B i j
{F : Type u_8} {G : Type u_1} {H : Type u_2} [AddGroup G] [AddZeroClass H] [AddMonoidHomClass F G H] (f : F) : Function.Injective ⇑f ↔ ∀ (a : G), ⇑f a = 0 → a = 0
{G : Type u_6} {H : Type u_7} {F : Type u_8} [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) (a b : G) : ⇑f (a / b) = ⇑f a / ⇑f b
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M →* P} {T : Submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [CommMonoid Q] {k : T.localization_Map Q} {A : Type u_5} [CommMonoid A] {U : Submonoid A} {R : Type u_6} [CommMonoid R] (j : U.localization_Map R) {l : P →* A} (hl : ∀ (w : ↥T), ⇑l ↑w ∈ U) : (k.map hl j).comp (f.map hy k) = f.map _ j
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {r : ℝ} (hr : 0 < r) (x : E) : x +ᵥ r • Metric.Ball 0 1 = Metric.Ball x r
{α : Type u_1} {G : Type u_4} {s : Set α} [SubtractionCommMonoid G] (f g : α → G) (hs : s.finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i - g i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) - finsum (λ (i : α), finsum (λ (H : i ∈ s), g i))
{δ : Type u_1} {κ : δ → Type u_2} [Π (d : δ), TopologicalSpace (κ d)] : Filter.coprod (λ (d : δ), Filter.cocompact (κ d)) = Filter.cocompact (Π (d : δ), κ d)
{R : Type u_1} [NormedRing R] [CompleteSpace R] : OpenEmbedding Coe
(v : PrimeMultiset) : v.prod.factor_Multiset = v
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] : is_is_IsOpenMap Prod.snd
{α : Type u_1} {γ : Type u_3} {ι : Type u_2} {p : ι → Prop} {s : ι → Set α} {f : Filter α} (hF : f.has_Basis p s) {β : ι → Type u_4} {pg : Π (i : ι), β i → Prop} {sg : Π (i : ι), β i → Set γ} {g : Set α → Filter γ} (hg : ∀ (i : ι), (g (s i)).has_Basis (pg i) (sg i)) (gm : Monotone g) : (f.lift g).has_Basis (λ (i : Σ (i : ι), β i), p i.fst ∧ pg i.fst i.snd) (λ (i : Σ (i : ι), β i), sg i.fst i.snd)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x : V) {r : ℝ} (hr : 0 ≤ r) : hb.oangle (r • x) x = 0
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] (s : Set P) : Collinear k s ↔ ∃ (p₀ : P) (v : V), ∀ (p : P), p ∈ s → (∃ (r : k), p = r • v +ᵥ p₀)
{α : Type u_1} {S : Finset α} {g : α → ℕ} (hS : ∀ (x : α), x ∈ S → g x ≠ 0) : (S.prod g).factorization = S.sum (λ (x : α), (g x).factorization)
{M : Type u_1} [has_Add M] (r : M → M → Prop) : AddConGen ⇑(AddConGen r) = AddConGen r
{E : Type u_3} [SemiNormedGroup E] (g h : E) : ∥g + h∥ ≤ ∥g∥ + ∥h∥
{R : Type u1} [CommSemiring R] {M : Type u2} [AddCommMonoid M] [Module R M] (m : M) : ⇑(ExteriorAlgebraι R) m * ⇑(ExteriorAlgebraι R) m = 0
{F : Type u_1} [NormedGroup F] [NormedSpace ℝ F] {f : ℝ → F} (K : Set F) : {x : ℝ | DifferentiableWithinAt ℝ f (Set.Ici x) x ∧ deriv_within f (Set.Ici x) x ∈ K} ⊆ RightDerivMeasurableAux.D f K
(m n k : ℕ) : (m + n).choose k = (Finset.Nat.antidiagonal k).sum (λ (ij : ℕ × ℕ), m.choose ij.fst * n.choose ij.snd)
{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), Group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace ↥K] : (reflection K).trans (reflection K) = LinearIsometryEquiv.refl 𝕜 E
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] {n : ℕ} (q : FormalMultilinearSeries 𝕜 F G) (p : FormalMultilinearSeries 𝕜 E F) (c : Composition n) : ∥q.comp_along_Composition p c∥ ≤ ∥q c.length∥ * finset.univ.prod (λ (i : Fin c.length), ∥p (c.blocks_fun i)∥)
{ι : Type u_1} {R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] (b : Basis ι R M) (f : M → ι → R) (hAdd : ∀ (x y : M), f (x + y) = f x + f y) (hsmul : ∀ (c : R) (x : M), f (c • x) = c • f x) (f_Eq : ∀ (i : ι), f (⇑b i) = ⇑(Finsupp.single i 1)) (x : M) (i : ι) : ⇑(⇑(b.repr) x) i = f x i
{K : Type u_1} [LinearOrderedField K] {c : ContinuedFraction K} : ↑c.convergents = ↑c.convergents'
{R : Type u_1} [Semiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {N : Type u_3} [AddCommMonoid N] [Module R N] {ι : Type u_6} [DecidableEq ι] {M₂ : Type u_7} [AddCommMonoid M₂] [Module R M₂] (f : AlternatingMap R M N ι) (g : M₂ ≃ₗ[R] M) : f.comp_Linear_Map ↑g = 0 ↔ f = 0
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {v : V} (p₁ p₂ : P) (hv : v ≠ 0) (r : ℝ) : HasDist.dist (r • v +ᵥ p₁) p₂ = HasDist.dist p₁ p₂ ↔ r = 0 ∨ r = (-2) * HasInner.inner v (p₁ -ᵥ p₂) / HasInner.inner v v
{α : Type u} [Group α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] {a : α} : a < 1 → 1 < a⁻¹
(R : Type u_1) [CommRing R] {n : ℕ} (hn : 2 ≤ n) : (Polynomial.cyclotomic n R).coeff 0 = 1
{α : Type u} [EmetricSpace α] : UniformEmbedding topological_space.nonempty_compacts.to_Closeds
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] {K : Type u_2} [Field K] [Algebra R K] [IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R) (r : R) : ⇑(v.valuation) (⇑(Algebra_Map R K) r) ≤ 1
{X : Top} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] (F : Top.Presheaf C X) : F.is_sheaf ↔ F.is_sheaf_Pairwise_intersections
{α : Type u_1} (m : MeasureTheory.OuterMeasure α) {s : ℕ → Set α} (h_Mono : ∀ (n : ℕ), s n ⊆ s (n + 1)) (h0 : ∑' (k : ℕ), ⇑m (s (k + 1)  s k) ≠ ⊤) : ⇑m (⋃ (n : ℕ), s n) = ⨆ (n : ℕ), ⇑m (s n)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {v w : E} (h : HasInner.inner v w = 0) : ∥w - v∥ = ∥w + v∥
{α : Type u_1} [CompleteLattice α] {p q : Prop} {s : p → q → α} : (⨆ (h₁ : p) (h₂ : q), s h₁ h₂) = ⨆ (h : p ∧ q), s _ _
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle y z + hb.oangle x y = hb.oangle x z
{α : Type u_1} {β : Type u_2} [AddGroup α] [SubtractionMonoid β] (f : α →+ β) (g h : α) : ⇑f (g - h) = ⇑f g - ⇑f h
{R : Type u_1} {E : Type u_2} {ι : Type u_4} {ι' : Type u_5} [LinearOrderedField R] [AddCommGroup E] [Module R E] (s : Finset ι) (t : Finset ι') (ws : ι → R) (zs : ι → E) (wt : ι' → R) (zt : ι' → E) (hws : s.sum (λ (i : ι), ws i) = 1) (hwt : t.sum (λ (i : ι'), wt i) = 1) (a b : R) (hab : a + b = 1) : a • s.center_mass ws zs + b • t.center_mass wt zt = (Finset.map Function.Embedding.inl s ∪ Finset.map Function.Embedding.inr t).center_mass (Sum.elim (λ (i : ι), a * ws i) (λ (j : ι'), b * wt j)) (Sum.elim zs zt)
{R : Type u_1} [NonAssocSemiring R] (f : ℕ →+* R) : f = nat.cast_RingHom R
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) {r : ℝ} (hr : r < 0) : hb.oangle (r • x) y = hb.oangle (-x) y
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} (hderiv : ∀ (x : ℝ), x ∈ Set.Interval a b → DifferentiableAt ℝ f x) (hint : IntervalIntegrable (deriv f) MeasureTheory.MeasureSpace.volume a b) : ∫ (y : ℝ) in a..b, deriv f y = f b - f a
{α : Type u_1} {r : α → α → Prop} [Nonempty α] (h : ∀ (c : Set α), IsChain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (Trans : ∀ {a b c : α}, r a b → r b c → r a c) : ∃ (m : α), ∀ (a : α), r m a → r a m
{α : Type u_1} (a : α) (s : Set α) [MeasurableSpace α] (hs : MeasurableSet s) : ⇑((Pmf.pure a).to_measure) s = Ite (a ∈ s) 1 0
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {S₁ S₂ : Submodule K V} [FiniteDimensional K ↥S₂] (hle : S₁ ≤ S₂) (hD : FiniteDimensional.finrank K ↥S₁ = FiniteDimensional.finrank K ↥S₂) : S₁ = S₂
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [LinearOrderedAddCommMonoid β] [HasScalar 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f : E → β} (hF : ConcaveOn 𝕜 s f) {x y z : E} (hx : x ∈ s) (hy : y ∈ s) (hz : z ∈ Segment 𝕜 x y) : Linear_order.min (f x) (f y) ≤ f z
{α : Type u} [PseudoMetricSpace α] {s t : Set α} (hs : Metric.Bounded s) (ht : Metric.Bounded t) : Metric.Bounded (s ∪ t)
{α : Type u} {β : Type v} {F : Type u_1} [NonAssocSemiring α] [NonAssocSemiring β] [AddHomClass F α β] (f : F) (a : α) : ⇑f (bit0 a) = bit0 (⇑f a)
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} {s t u : Set 𝕜} (hu : u ∈ nhds x) (h : s ∩ u = t ∩ u) : HasDerivWithinAt f f' s x → HasDerivWithinAt f f' t x
{α : Type u_1} [PseudoMetricSpace α] {f : ℕ → α} (d : ℕ → ℝ) (hF : ∀ (n : ℕ), HasDist.dist (f n) (f n.succ) ≤ d n) (hD : Summable d) : CauchySeq f
 : ¬BddAbove {p : ℕ | Nat.Prime p}
{C : Type (max v u)} [CategoryTheory.Category C] {J : CategoryTheory.GrothendieckTopology C} {D : Type w} [CategoryTheory.Category D] {K : Type (max v u)} [CategoryTheory.SmallCategory K] [CategoryTheory.Limits.HasLimitsOfShape K D] (F : K ⥤ CategoryTheory.Sheaf J D) (E : CategoryTheory.Limits.Cone (F ⋙ CategoryTheory.Sheaf_to_presheaf J D)) (hE : CategoryTheory.Limits.IsLimit E) : CategoryTheory.Presheaf.IsSheaf J E.X
{R : Type u_1} {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] (f : ℕ → R) (g : ℕ → M) (n : ℕ) : (Finset.range n).sum (λ (i : ℕ), f i • g i) = f (n - 1) • (Finset.range n).sum (λ (i : ℕ), g i) - (Finset.range (n - 1)).sum (λ (i : ℕ), (f (i + 1) - f i) • (Finset.range (i + 1)).sum (λ (i : ℕ), g i))
{B : Type u_3} {S : B} {M : Type u_1} [AddCommMonoid M] [SetLike B M] [AddSubmonoidClass B M] (m : Multiset M) (hm : ∀ (a : M), a ∈ m → a ∈ S) : m.sum ∈ S
{𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] {f : 𝕜 → G} {s : Set 𝕜} {x y : 𝕜} {C : ℝ} (hF : DifferentiableOn 𝕜 f s) (bound : ∀ (x : 𝕜), x ∈ s → ∥deriv_within f s x∥ ≤ C) (hs : Convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
{ι : Type u_1} {E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {ca cb : E} {la la' lb lb' : Filter ℝ} {Lt : Filter ι} {a b : ℝ} {ua ub va vb : ι → ℝ} [Interval_integral.FTC_Filter a la la'] [Interval_integral.FTC_Filter b lb lb'] (hab : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f la' MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f lb' MeasureTheory.MeasureSpace.volume) (ha_lim : Filter.Tendsto f (la' ⊓ MeasureTheory.Measure_space.volume.ae) (nhds ca)) (hb_lim : Filter.Tendsto f (lb' ⊓ MeasureTheory.Measure_space.volume.ae) (nhds cb)) (hua : Filter.Tendsto ua Lt la) (hva : Filter.Tendsto va Lt la) (hub : Filter.Tendsto ub Lt lb) (hvb : Filter.Tendsto vb Lt lb) : (λ (t : ι), ((∫ (x : ℝ) in va t..vb t, f x) - ∫ (x : ℝ) in ua t..ub t, f x) - ((vb t - ub t) • cb - (va t - ua t) • ca)) =o[Lt] λ (t : ι), ∥va t - ua t∥ + ∥vb t - ub t∥
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] (f : C(α, β)) {ι : Type u₃} {p : Filter ι} {F : ι → C(α, β)} : Filter.Tendsto F p (nhds f) ↔ ∀ (K : Set α), is_IsCompact K → TendstoUniformlyOn (λ (i : ι) (a : α), ⇑(F i) a) ⇑f p K
{C : Type u₁} [CategoryTheory.Category C] {X Y : C} (F₁ F₂ : CategoryTheory.MonoOver X ⥤ CategoryTheory.MonoOver Y) (h : F₁ ≅ F₂) : CategoryTheory.Subobject.lower F₁ = CategoryTheory.Subobject.lower F₂
{𝕂 : Type u_1} {𝔸 : Type u_2} [is_R_or_C 𝕂] [NormedRing 𝔸] [NormedAlgebra 𝕂 𝔸] [CompleteSpace 𝔸] : HasStrictFderivAt (Exp 𝕂) 1 0
{α : Type u_1} [TopologicalSpace α] [t1_Space α] (x : α) [hx : (nhds_within x {x}ᶜ).ne_IsBot] {s : Set α} (hs : s ∈ nhds x) : s.infinite
{ι : Type u_1} {R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] {b₁ b₂ : Basis ι R M} (h : ∀ (i : ι), ⇑b₁ i = ⇑b₂ i) : b₁ = b₂
{J : Type u₁} [CategoryTheory.Category J] {K : Type u₁} [CategoryTheory.Category K] (e : J ≌ K) [CategoryTheory.IsConnected J] : CategoryTheory.IsConnected K
{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] {s : Set E} (hs : Convex 𝕜 s) {a b : 𝕜} (ha : 0 ≤ a) (hb : 0 < b) (hab : a + b = 1) : a • s + b • Interior s ⊆ Interior s
{α : Type u} [Group α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 → 1 < a
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] (f : ℂ → E) (z w : ℂ) (s : Set ℂ) (hs : s.countable) (Hc : ContinuousOn f (Set.Interval z.re w.re ×ℂ Set.Interval z.im w.im)) (hD : ∀ (x : ℂ), x ∈ Set.Ioo (Linear_order.min z.re w.re) (Linear_order.max z.re w.re) ×ℂ Set.Ioo (Linear_order.min z.im w.im) (Linear_order.max z.im w.im)  s → DifferentiableAt ℂ f x) : (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(z.im) * Complex.i)) - ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(w.im) * Complex.i)) + Complex.i • ∫ (y : ℝ) in z.im..w.im, f (↑(w.re) + ↑y * Complex.i)) - Complex.i • ∫ (y : ℝ) in z.im..w.im, f (↑(z.re) + ↑y * Complex.i) = 0
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type w} : CategoryTheory.Presieve.IsSheaf ⊥ P
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {F₁ F₂ : D ⥤ C} [∀ (X Y : C), Subsingleton (X ⟶ Y)] (hC : CategoryTheory.Skeletal C) (hF : F₁ ≅ F₂) : F₁ = F₂
{α : Type u} {β : Type v} [Preorder β] {f : α → β} {s : Set α} {a : α} : IsExtrOn (⇑order_dual.to_dual ∘ f) s a → IsExtrOn f s a
{p : ℕ} [Fact (Nat.Prime p)] : padic_norm_e 1 = 1
{ι : Type u} (s : Finset ι) (w z : ι → Nnreal) (hw' : s.sum (λ (i : ι), w i) = 1) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), w i * z i) ≤ s.sum (λ (i : ι), w i * z i ^ p) ^ (1 / p)
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : α → β} {s : Set α} : StrictMonoOn f s → StrictAntiOn (f ∘ ⇑order_dual.of_dual) s
{τ : Type u_1} {α : Type u_2} {β : Type u_3} [TopologicalSpace β] (f : Filter τ) (ϕ : τ → α → β) (s : Set α) {c : Set β} (hc₁ : is_IsCompact c) (hc₂ : ∃ (v : Set τ) (H : v ∈ f), Closure (Set.image2 ϕ v s) ⊆ c) {n : Set β} (hn₁ : is_IsOpen n) (hn₂ : OmegaLimit f ϕ s ⊆ n) : ∃ (u : Set τ) (H : u ∈ f), Closure (Set.image2 ϕ u s) ⊆ n
{G : Type u_1} [Group G] [hG : group.is_nilpotent G] : Nat.find _ = group.nilpotency_class G
{α : Type u} [PseudoEmetricSpace α] {x : α} {s t : Set α} {r : Ennreal} (h : x ∈ s) (H : emetric.Hausdorff_edist s t < r) : ∃ (y : α) (H : y ∈ t), HasEdist.edist x y < r
{α : Type u} (r : α → α → Prop) [IsSymm α r] {a b : α} : r a b ↔ r b a
{α : Type u} [TopologicalSpace α] [t2_Space α] {ι : Type u_1} [Nonempty ι] {V : ι → Set α} (hV : Directed Superset V) (hV_cpct : ∀ (i : ι), is_IsCompact (V i)) {U : Set α} (hU : ∀ (x : α), (x ∈ ⋂ (i : ι), V i) → U ∈ nhds x) : ∃ (i : ι), V i ⊆ U
{α : Type u} [Infinite α] {s : Set α} (hF : s.finite) : sᶜ ∈ Filter.hyperfilter α
{R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [Semiring R] [Semiring R₂] [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module R₂ M₂] {τ₁₂ : R →+* R₂} {f : M →ₛₗ[τ₁₂] M₂} (h : ∀ (u v : ↥(f.ker) →ₗ[R] M), f.comp u = f.comp v → u = v) : f.ker = ⊥
{R : Type u_1} {S : Type u_2} {M : Type u_3} {a : R} {s : S} [Monoid S] [HasScalar R M] [HasScalar R S] [MulAction S M] [IsScalarTower R S M] (h : a • s = 1) : IsSmulRegular M s
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {w : α → M} {b : M} [LinearOrderedCancelAddCommMonoid M] (hF : ∀ (a : α), a ∈ s → f a ∈ t) (ht : t.nonempty) (hb : t.card • b ≤ s.sum (λ (x : α), w x)) : ∃ (y : β) (H : y ∈ t), b ≤ (Finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x)
{α : Type u} [PartialOrder α] [OrderBot α] {a : α} : IsBot a → a = ⊥
 : Filter.cofinite = filter.at_Top
{α : Type u_1} [LinearOrderedAddCommGroup α] {x dx y dy : α} (h : dy < dx) (hx : 0 < dx) : Nonempty ↥(Set.Ico x (x + dx)  Set.Ico y (y + dy))
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {a : F} (ha : a ≠ 0) : char.quadratic_Char F a = -1 ↔ ¬char.quadratic_Char F a = 1
{α : Type u_1} {β : Type u_2} [DecidableEq α] [Fintype α] [AddCommMonoid β] {δ : α → Type u_3} {t : Π (a : α), Finset (δ a)} (f : (Π (a : α), a ∈ Finset.univ → δ a) → β) : (finset.univ.pi t).sum (λ (x : Π (a : α), a ∈ Finset.univ → δ a), f x) = (fintype.pi_Finset t).sum (λ (x : Π (a : α), δ a), f (λ (a : α) (_x : a ∈ Finset.univ), x a))
{α : Type u_1} {β : Type u_2} {ι : Type u_3} (a : α) (b : β) (i : ι) : Filter.map (Prod.map (λ (_x : α), b) Id) ((Filter.principal {a}).coprod (Filter.principal {i})) = Filter.principal ({b} ×ˢ Set.Univ)
{m : ℝ} (hm : 1 < m) (k : ℕ) : liouville.liouville_number m = liouville.liouville_number_initial_terms m k + liouville.liouville_number_tail m k
{M : Type u_1} [SemiNormedGroup M] (S : AddSubgroup M) : ∥S.normed_Mk∥ ≤ 1
{k : Type u_1} {M : Type u_2} [OrderedSemiring k] [OrderedAddCommGroup M] [Module k M] [OrderedSmul k M] {a : M} {c : k} (hc : 0 < c) : a < 0 → c • a < 0
{α : Type u_2} [Monoid α] (m : α) : IsSquare m → (∃ (c : α), m = c ^ 2)
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (x : R) : v.int_Valuation_def x ≤ 1
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] : CategoryTheory.Limits.HasLimits Cᵒᵖ
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} {ι₂ : Type u_5} (s₂ : Finset ι₂) (e : ι₂ ↪ ι) (w : ι → k) (p : ι → P) (b : P) : ⇑((Finset.map e s₂).weighted_vsub_of_point p b) w = ⇑(s₂.weighted_vsub_of_point (p ∘ ⇑e) b) (w ∘ ⇑e)
{ι : Type u_1} {α : ι → Type u_2} [Fintype ι] [DecidableEq ι] [Π (i : ι), DecidableEq (α i)] [Π (i : ι), LinearOrder (α i)] {p : (Π (i : ι), Finset (α i)) → Prop} (f : Π (i : ι), Finset (α i)) (h0 : p (λ (_x : ι), ∅)) (step : ∀ (g : Π (i : ι), Finset (α i)) (i : ι) (x : α i), (∀ (y : α i), y ∈ g i → x < y) → p g → p (Function.update g i (HasInsert.insert x (g i)))) : p f
{α : Type u_1} {β : α → Type u_2} {γ : Type u_3} [Π (a : α), CommMonoid (β a)] (s : Finset γ) (g : γ → Π (a : α), β a) : s.prod (λ (c : γ), g c) = λ (a : α), s.prod (λ (c : γ), g c a)
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {v₁ v₂ : M} (hv₁ : v₁ ≠ 0) (hv₂ : v₂ ≠ 0) : Ray_of_NeZero R v₁ hv₁ = Ray_of_NeZero R v₂ hv₂ ↔ SameRay R v₁ v₂
{β : Type u} {α : Type v} [AddCommMonoid β] [DecidableEq α] (s : Finset α) (a : α) (b : α → β) : s.sum (λ (x : α), Ite (x = a) (b x) 0) = Ite (a ∈ s) (b a) 0
{R : Type u_1} {M : Type u_2} {ι : Type u_5} [CommRing R] [AddCommGroup M] [Module R M] [Fintype ι] (b : Basis ι R M) (f : ι →₀ R) (i : ι) : ⇑(⇑(Finsupp.total ι (Module.Dual R M) R b.coord) f) (⇑b i) = ⇑f i
{R : Type u_1} (c₁ c₂ : R) : Cardinal.mk (QuaternionAlgebra R c₁ c₂) = Cardinal.mk R ^ 4
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {s : Set E} {f g : E → F} (hF : ContDiffOn 𝕜 n f s) (hg : ContDiffOn 𝕜 n g s) : ContDiffOn 𝕜 n (λ (x : E), f x - g x) s
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] {f : α → β} {s : Set α} {a : α} (h_Mono : MonotoneOn f s) (hs : s ∈ nhds a) (hfs_l : ∀ (b : β), b < f a → (∃ (c : α) (H : c ∈ s), f c ∈ Set.Ioo b (f a))) (hfs_r : ∀ (b : β), b > f a → (∃ (c : α) (H : c ∈ s), f c ∈ Set.Ioo (f a) b)) : ContinuousAt f a
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_4} [DecidableEq ι] [Fintype ι] (e : Basis ι R M) {v : ι → M} (hli : LinearIndependent R v) (hsp : Submodule.span R (Set.Range v) = ⊤) (i : ι) : ⇑(e.det) v • (Basis.mk hli hsp).coord i = e.det.to_multilinear_map.to_Linear_Map v i
{α : Type u_1} [DecidableEq α] [Fintype α] {𝒜 : Finset (Finset α)} {s : Finset α} (hs : s ∈ 𝒜.up_shadow) : ∃ (t : Finset α) (H : t ∈ 𝒜), t ⊆ s
{β : Type u} {f g : β → Type u} (α : Π (j : β), f j ⟶ g j) (b : β) (x : ∏ λ (j : β), f j) : Category_theory.limits.pi.π g b (CategoryTheory.Limits.Pi.map α x) = α b (Category_theory.limits.pi.π f b x)
{α : Type u_1} {β : Type u_2} {f : α → β} {m : MeasurableSpace α} [TopologicalSpace β] [TopologicalSpace.PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β] (hF : MeasureTheory.StronglyMeasurable f) : Measurable f
{α : Type u_1} {s : Multiset α} {x : Multiset α × Multiset α} : x ∈ s.antidiagonal ↔ x.fst + x.snd = s
{R : Type u} [Semiring R] {M : Polynomial R → Prop} {f : Polynomial R} (f0 : f.nat_degree ≠ 0) (h_C_Add : ∀ {a : R} {p : Polynomial R}, M p → M (⇑Polynomial.c a + p)) (h_Add : ∀ {p q : Polynomial R}, M p → M q → M (p + q)) (h_monomial : ∀ {n : ℕ} {a : R}, a ≠ 0 → n ≠ 0 → M (⇑(Polynomial.monomial n) a)) : M f
{R : Type u_1} {M : Type u_2} [AddCommMonoid M] [CommRing R] [Nontrivial R] : Algebra.FiniteType R (AddMonoidAlgebra R M) ↔ Add_monoid.fg M
{α : Type u_1} {β : Type u_2} [SemilatticeSup α] [OrderBot α] {P : α → Prop} {Pbot : P ⊥} {Psup : ∀ ⦃x y : α⦄, P x → P y → P (x ⊔ y)} (t : Finset β) (f : β → {x // P x}) : ↑(t.sup f) = t.sup (λ (x : β), ↑(f x))
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂] [Module K V₂] [FiniteDimensional K V] [FiniteDimensional K V₂] (Cond : FiniteDimensional.finrank K V = FiniteDimensional.finrank K V₂) : Nonempty (V ≃ₗ[K] V₂)
{f : ℕ → Nnreal} (hF : ∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m) : Summable (λ (k : ℕ), 2 ^ k * f (2 ^ k)) ↔ Summable f
{F : Type u} [Field F] {n : ℕ} (a : F) (hn : ↑n ≠ 0) (ha : a ≠ 0) : (Polynomial.x ^ n - ⇑Polynomial.c a).separable
{α : Type u_1} [Preorder α] {a b : α} (h : a ≤ b) : Set.Iio a ⊆ Set.Iio b
{p : ℕ} (hp : Nat.Prime p) (n k : ℕ) : multiplicity p n ≤ multiplicity p (n.choose k) + multiplicity p k
{M : Type u_1} [has_Add M] {c : AddCon M} {C : c.quotient → Prop} (q : c.quotient) (H : ∀ (x : M), C ↑x) : C q
{α : Type u} {β : Type v} [TopologicalSpace α] [SemiNormedGroup β] (f : BoundedContinuousFunction α β) (C : Nnreal) : ∥f∥₊ ≤ C ↔ ∀ (x : α), ∥⇑f x∥₊ ≤ C
{α : Type u} [AddGroup α] [Preorder α] [CovariantClass α α has_add.add has_lt.lt] {a : α} (h : 0 < a) : -a < a
{M : Type u_1} [MulOneClass M] (S : Submonoid M) {x y : M} : x ∈ S → y ∈ S → x * y ∈ S
{M : Type u_3} [AddCommGroup M] {R₁ : Type u_4} [CommRing R₁] [Module R₁ M] {ι : Type u_6} [Fintype ι] [Invertible 2] (Q : QuadraticForm R₁ M) (v : Basis ι R₁ M) (hv₂ : (⇑QuadraticForm.associated Q).is_Ortho ⇑v) : Q.basis_repr v = quadratic_form.weighted_Sum_squares R₁ (λ (i : ι), ⇑Q (⇑v i))
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {f : α → E} {g : α → F} {l : Filter α} : f =o[l] g → ∀ ⦃c : ℝ⦄, 0 < c → asymptotics.is_O_with c l f g
{M : Type u_1} [has_Add M] {s : Set M} {p : M → M → Prop} {x y : M} (hx : x ∈ AddSubsemigroup.closure s) (hy : y ∈ AddSubsemigroup.closure s) (Hs : ∀ (x : M), x ∈ s → ∀ (y : M), y ∈ s → p x y) (hMul_Left : ∀ (x y z : M), p x z → p y z → p (x + y) z) (hMul_Right : ∀ (x y z : M), p z x → p z y → p z (x + y)) : p x y
{x y : Pgame} (ox : x.numeric) (oy : y.numeric) : x ≤ y ↔ (∀ (i : x.left_moves), x.move_Left i < y) ∧ ∀ (j : y.right_moves), x < y.move_Right j
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] (p : P) : Function.Injective (HasVsub.vsub p)
{R : Type u_1} {M : Type u_2} {N : Type u_3} [HasZero R] [HasZero M] [HasZero N] [HasScalar R M] [HasScalar R N] [NoZeroSmulDivisors R N] (f : M → N) (hF : Function.Injective f) (h0 : f 0 = 0) (hs : ∀ (c : R) (x : M), f (c • x) = c • f x) : NoZeroSmulDivisors R M
(f f' : ℝ → ℝ) {a b : ℝ} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hff' : ∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivAt f (f' x) x) : ∃ (c : ℝ) (H : c ∈ Set.Ioo a b), f' c = (f b - f a) / (b - a)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (p : P) (direction : Submodule k V) : ↑(AffineSubspace.mk' p direction).nonempty
{α : Type u_1} [PartialOrder α] [PredOrder α] [IsPredArchimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ Set.Ioc n m → r (Order.pred i) i) (hmn : n < m) : Relation.TransGen r n m
(p : ℕ) [hp : Fact (Nat.Prime p)] (n : ℕ) {m : ℕ} (hm : n ≤ m) : (truncated_witt_vector.zmod_Equiv_trunc p n).symm.to_Ring_hom.comp (TruncatedWittVector.truncate hm) = (zmod.cast_hom _ (Zmod(p ^ n))).comp (truncated_witt_vector.zmod_Equiv_trunc p m).symm.to_RingHom
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (e : LocalHomeomorph α β) {f : γ → α} (h : f ⁻¹' e.to_local_equiv.source = Set.Univ) : Continuous f ↔ Continuous (⇑e ∘ f)
{n : ℕ} : Nat.fib (n + 2) = Nat.fib n + Nat.fib (n + 1)
{α : Type u_1} {E : Type u_3} [TopologicalSpace α] [CompactSpace α] [NormedGroup E] (f : C(α, E)) (x y : α) : HasDist.dist (⇑f x) (⇑f y) ≤ 2 * ∥f∥
{α : Type u} {β : Type v} [Semiring α] [Semiring β] {f : α → β} (hF : IsSemiringHom f) : IsMonoidHom f
{V : Type u_4} [InnerProductSpace ℂ V] (T : V →ₗ[ℂ] V) : InnerProductSpace.IsSelfAdjoint T ↔ ∀ (v : V), ⇑(StarRing_end ℂ) (HasInner.inner (⇑T v) v) = HasInner.inner (⇑T v) v
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {s₁ s₂ : AffineSubspace k P} {p : P} (h : p ∈ s₁ ⊓ s₂) : (s₁ ⊓ s₂).direction = s₁.direction ⊓ s₂.direction
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : AffineSubspace k P} (h : ↑s.nonempty) : ↑(s.direction) = ↑s -ᵥ ↑s
{α : sort u_1} {p : α → Prop} (hp : ∀ (a : α), ¬p a) : IsEmpty (Subtype_ p)
{F : Type} [Field F] (q : ℕ) [hF : ExpChar F q] (f : Polynomial F) [irred : Irreducible f] : Polynomial.HasSeparableContraction q f
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {s : Set E} {t : Set F} {g : F → G} {f : E → F} (x : E) (hg : ContDiffWithinAt 𝕜 n g t (f x)) (hF : ContDiffWithinAt 𝕜 n f s x) (st : s ⊆ f ⁻¹' t) : ContDiffWithinAt 𝕜 n (g ∘ f) s x
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} : Convex 𝕜 s → s.ord_connected
(R : Type u) (M : Type v) (N : Type w) [Ring R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] [AddCommGroup N] [Module R N] [Module.Free R N] : Module.rank R (M × N) = (Module.rank R M).lift + (Module.rank R N).lift
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x : V) (θ : Real.Angle) : ⇑(hb.rotation θ) x = x ↔ x = 0 ∨ θ = 0
{A : Type u_2} [NormedRing A] [NormedAlgebra ℂ A] [CompleteSpace A] (a : A) : filter.at_top.limsup (λ (n : ℕ), ↑∥a ^ n∥₊ ^ (1 / ↑n)) ≤ spectral_radius ℂ a
{R : Type u_1} [CommSemiring R] {A : Type u_2} [Semiring A] (P Q : Algebra R A) (w : ∀ (r : R), ⇑(Algebra_Map R A) r = ⇑(Algebra_Map R A) r) : P = Q
{G : Type u_1} [Group G] (h : monoid.exponent_exists G) : monoid.is_torsion G
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [SemiNormedGroup E'] {c : ℝ} {g : α → F} {f' : α → E'} {l : Filter α} : asymptotics.is_O_with c l f' g → asymptotics.is_O_with c l (λ (x : α), -f' x) g
{M : Type u_1} [AddZeroClass M] (S : AddSubmonoid M) : 0 ∈ S
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder α] [OrderClosedTopology α] [Nonempty α] [TopologicalSpace β] [HasZero α] {f : β → α} (hF : Continuous f) (h : HasCompactSupport f) : BddAbove (Set.Range f)
{α : Type u_1} {s : Set α} : ⊥.is_clique s → s.subsingleton
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x : E} (hF : HasFderivAt f f' x) (v : E) {α : Type u_4} {c : α → 𝕜} {l : Filter α} (hc : Filter.Tendsto (λ (n : α), ∥c n∥) l filter.at_Top) : Filter.Tendsto (λ (n : α), c n • (f (x + (c n)⁻¹ • v) - f x)) l (nhds (⇑f' v))
{α : Type u_1} [MeasurableSpace α] {m₁ m₂ : MeasureTheory.OuterMeasure α} {Op : Ennreal → Ennreal} (h : ∀ (s : Set α), ⇑m₁ s = Op (⇑m₂ s)) (s : Set α) : ⇑(m₁.trim) s = Op (⇑(m₂.trim) s)
{R : Type u_2} {M : Type u_3} [AddCommGroup M] [Ring R] [Module R M] [Invertible 2] (Q : QuadraticForm R M) (hB : Q.anisotropic) : (⇑QuadraticForm.associated' Q).nondegenerate
{M : Type u_2} [AddCommGroup M] {𝕜 : Type u_1} [Field 𝕜] [Module 𝕜 M] (f : M ≃ₗ[𝕜] M) : ⇑LinearMap.det ↑(f.symm) = (⇑LinearMap.det ↑f)⁻¹
{α : Type u_1} [PseudoEmetricSpace α] {δSeq : ℕ → ℝ} (δSeq_lim : Filter.Tendsto δSeq filter.at_Top (nhds 0)) (E : Set α) : Filter.Tendsto (λ (n : ℕ), thickened_indicator_aux (δSeq n) E) filter.at_Top (nhds ((Closure E).indicator (λ (x : α), 1)))
{α : Type u} [TopologicalSpace α] [t2_Space α] {x y : α} (h : x ≠ y) : ∃ (u v : Set α), is_IsOpen u ∧ is_IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ u ∩ v = ∅
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.FiniteType R A ↔ ∃ (n : ℕ) (f : MvPolynomial (Fin n) R →ₐ[R] A), Function.Surjective ⇑f
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] {p1 p2 p : P} (h : p -ᵥ p1 = p -ᵥ p2) : p1 = p2
{α : Type u} [CommSemiring α] {p p' ps ps' : α} : p = p' → ps = ps' → p + ps = p' + ps'
{α : Type u_1} {β : Type u_2} {M : Type u_5} {N : Type u_7} [AddCommMonoid M] [AddCommMonoid N] {f : α → β} {s : α →₀ M} (h : β → M →+ N) : (finsupp.map_IsDomain f s).sum (λ (b : β) (m : M), ⇑(h b) m) = s.sum (λ (a : α) (m : M), ⇑(h (f a)) m)
{a b k : ℕ} (h_Ab_IsCoprime : a.coprime b) (hka : k ∣ a) (hkb : k ∣ b) : k = 1
{α : Type u_1} [PseudoMetricSpace α] {δ : ℝ} {E : Set α} (hE : is_IsCompact E) (hδ : 0 ≤ δ) : Metric.Cthickening δ E = ⋃ (x : α) (H : x ∈ E), Metric.ClosedBall x δ
{α : Type u_1} {𝒜 : Finset (Finset α)} {A : Finset α} {r : ℕ} : A ∈ 𝒜.slice r ↔ A ∈ 𝒜 ∧ A.card = r
{k : Type u_1} {V : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] [Fintype ι] {p : ι → P} (hi : AffineIndependent k p) {sm : Submodule k V} [FiniteDimensional k ↥sm] (hle : Vector_Span k (Set.Range p) ≤ sm) (hc : Fintype.card ι = FiniteDimensional.finrank k ↥sm + 1) : Vector_Span k (Set.Range p) = sm
{K : Type u_1} [LinearOrderedField K] {v : K} {n : ℕ} [FloorRing K] {ifp_n : GeneralizedContinuedFraction.IntFractPair K} : GeneralizedContinuedFraction.IntFractPair.stream v n = Option.some ifp_n → v = generalized_continued_fraction.comp_exact_value ((GeneralizedContinuedFraction.of v).continuants_aux n) ((GeneralizedContinuedFraction.of v).continuants_aux (n + 1)) ifp_n.fr
{C : Type u} [CategoryTheory.Category C] {X Y : C} [CategoryTheory.Limits.HasZeroMorphisms C] (f : X ⟶ Y) [CategoryTheory.Limits.HasKernel f] {Z : C} (h : Y ⟶ Z) [CategoryTheory.Mono h] : Category_theory.limits.kernel_Subobject (f ≫ h) = Category_theory.limits.kernel_Subobject f
{M : Type u_1} [AddZeroClass M] {c d : AddCon M} (h : c ≤ d) (x : c.quotient) : ⇑(c.map d h) x = ⇑(c.lift d.mk' _) x
{G : Type u_3} [Group G] (P : Subgroup G) : P.fg ↔ ∃ (S : Set G), Subgroup.closure S = P ∧ S.finite
{α : Type u_1} {β : Type u_3} {γ : Type u_5} [DecidableEq γ] {f f' : α → β → γ} {s : Finset α} {t : Finset β} (h : ∀ (a : α) (b : β), f a b = f' a b) : Finset.image₂ f s t = Finset.image₂ f' s t
{α : Type u_1} {β : Type u_2} {e : LocalEquiv α β} {s : Set α} {t : Set β} : e.is_image s t → e.source ∩ ⇑e ⁻¹' t = e.source ∩ s
{𝕜 : Type u_1} {E : Type u_4} {Fₗ : Type u_7} [NormedGroup E] [NormedGroup Fₗ] [NondiscreteNormedField 𝕜] [NormedSpace 𝕜 E] [NormedSpace 𝕜 Fₗ] {r : ℝ} (r_Pos : 0 < r) (c : ℝ) (f : E →ₗ[𝕜] Fₗ) (h : ∀ (z : E), z ∈ Metric.Ball 0 r → ∥⇑f z∥ ≤ c) : ∃ (C : ℝ), ∀ (z : E), ∥⇑f z∥ ≤ C * ∥z∥
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [LinearOrder α] [TopologicalSpace γ] {a b : α} {h : a ≤ b} [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] {f : γ → ↥(Set.Icc a b) → β} {g : γ → α} (hF : Continuous ↿f) (hg : Continuous g) : Continuous (λ (a_1 : γ), Set.Icc_extend h (f a_1) (g a_1))
{G : Type u_1} [Group G] (H : Subgroup G) : H = ⊥ ∨ Nontrivial ↥H
{R : Type u_1} {G : Type u_4} [Group G] [MulAction G R] (g : G) : IsSmulRegular R g
{α : Type u} {β : Type v} [has_Add α] [has_Add β] {γ : Type u_1} [has_Add γ] {f : α → β} {g : β → γ} (hF : IsAddHom f) (hg : IsAddHom g) : IsAddHom (g ∘ f)
{X : Type u_1} {Y : Type u_2} [PseudoEmetricSpace X] [PseudoEmetricSpace Y] {C : Nnreal} {f : X → Y} : LipschitzWith C f → HolderWith C 1 f
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (hM : M (Sum.inr ()) (Sum.inr ()) ≠ 0) (i : Fin r) : ((matrix.pivot.list_transvec_col M).prod.mul M).mul (matrix.pivot.list_transvec_row M).prod (Sum.inl i) (Sum.inr ()) = 0
{α : Type u_1} [PartialOrder α] [PredOrder α] [IsPredArchimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ Set.Ioc n m → r (Order.pred i) i) (hmn : n ≤ m) : Relation.ReflTransGen r n m
{β : Type u} {α : Type v} {γ : Type w} [AddCommMonoid β] {s : Finset γ} {t : γ → Finset α} {t' : Finset α} {s' : α → Finset γ} (h : ∀ (x : γ) (y : α), x ∈ s ∧ y ∈ t x ↔ x ∈ s' y ∧ y ∈ t') {f : γ → α → β} : s.sum (λ (x : γ), (t x).sum (λ (y : α), f x y)) = t'.sum (λ (y : α), (s' y).sum (λ (x : γ), f x y))
(C : Type u) [CategoryTheory.Category C] [∀ {J : Type v} {X Y : C} {f : J → (X ⟶ Y)}, CategoryTheory.Limits.HasColimit (Category_theory.limits.parallel_family f)] : CategoryTheory.Limits.HasWideCoequalizers C
{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {f : Filter β} {u : β → α} : (∃ (b : α), ∀ (x : β), r (u x) b) → Filter.IsBoundedUnder r f u
{α : Type u_1} [Field α] (E : LinearRecurrence α) : Module.rank α ↥(E.sol_Space) = ↑(E.order)
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1
{R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [Π (i : ι), Module R (M₁ i)] [Module R M₂] {M₁' : ι → Type u_1} [Π (i : ι), AddCommMonoid (M₁' i)] [Π (i : ι), Module R (M₁' i)] {M₁'' : ι → Type u_2} [Π (i : ι), AddCommMonoid (M₁'' i)] [Π (i : ι), Module R (M₁'' i)] (g : MultilinearMap R M₁'' M₂) (f₁ : Π (i : ι), M₁' i →ₗ[R] M₁'' i) (f₂ : Π (i : ι), M₁ i →ₗ[R] M₁' i) : (g.comp_Linear_Map f₁).comp_Linear_Map f₂ = g.comp_Linear_Map (λ (i : ι), (f₁ i).comp (f₂ i))
(R : Type u_1) {K : Type u_2} [CommRing R] [Field K] [Algebra R K] [IsFractionRing R K] (p : ℕ) [Char_p R p] : Char_p K p
(n : ℕ) : iterated_deriv n (Exp_Neg_Inv_glue.f_aux 0) = Exp_Neg_Inv_glue.f_aux n
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (ha : ContinuousAt f a) : HasStrictDerivAt (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) (-f a) a
{α : Type u} (p : α → Prop) [DecidablePred p] (xs : List α) (h : ∀ (x : α), x ∈ xs → ¬p x) : list.split_on_p p xs = [xs]
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace E] [CompleteSpace ↥K] (u v : E) : HasInner.inner ↑(⇑(Orthogonal_projection K) u) v = HasInner.inner u ↑(⇑(Orthogonal_projection K) v)
{X : Type v} [TopologicalSpace X] [LocallyCompactSpace X] [SigmaCompactSpace X] [t2_Space X] {ι : X → Type u} {p : Π (x : X), ι x → Prop} {B : Π (x : X), ι x → Set X} (hB : ∀ (x : X), (nhds x).has_Basis (p x) (B x)) : ∃ (α : Type v) (c : α → X) (r : Π (a : α), ι (c a)), (∀ (a : α), p (c a) (r a)) ∧ (⋃ (a : α), B (c a) (r a)) = Set.Univ ∧ LocallyFinite (λ (a : α), B (c a) (r a))
{G : Type u_1} [Group G] {ι : sort u_2} (S : ι → Subgroup G) {C : G → Prop} {x : G} (hx : x ∈ ⨆ (i : ι), S i) (hp : ∀ (i : ι) (x : G), x ∈ S i → C x) (h1 : C 1) (hMul : ∀ (x y : G), C x → C y → C (x * y)) : C x
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : HasInner.inner x y * HasInner.inner x y ≤ HasInner.inner x x * HasInner.inner y y
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} {s t : Set α} (hs : (s ∩ Function.Support f).finite) (ht : (t ∩ Function.Support f).finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s ∪ t), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ s ∩ t), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ t), f i))
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] (f : ℂ → E) (f' : ℂ → (ℂ →L[ℝ] E)) (z w : ℂ) (s : Set ℂ) (hs : s.countable) (Hc : ContinuousOn f (Set.Interval z.re w.re ×ℂ Set.Interval z.im w.im)) (hD : ∀ (x : ℂ), x ∈ Set.Ioo (Linear_order.min z.re w.re) (Linear_order.max z.re w.re) ×ℂ Set.Ioo (Linear_order.min z.im w.im) (Linear_order.max z.im w.im)  s → HasFderivAt f (f' x) x) (Hi : MeasureTheory.IntegrableOn (λ (z : ℂ), Complex.i • ⇑(f' z) 1 - ⇑(f' z) Complex.i) (Set.Interval z.re w.re ×ℂ Set.Interval z.im w.im) MeasureTheory.MeasureSpace.volume) : (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(z.im) * Complex.i)) - ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(w.im) * Complex.i)) + Complex.i • ∫ (y : ℝ) in z.im..w.im, f (↑(w.re) + ↑y * Complex.i)) - Complex.i • ∫ (y : ℝ) in z.im..w.im, f (↑(z.re) + ↑y * Complex.i) = ∫ (x : ℝ) in z.re..w.re, ∫ (y : ℝ) in z.im..w.im, Complex.i • ⇑(f' (↑x + ↑y * Complex.i)) 1 - ⇑(f' (↑x + ↑y * Complex.i)) Complex.i
{α : Type u} [Group α] [HasLe α] [CovariantClass α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a
{R : Type u_2} {M : Type u_3} [AddCommGroup M] [Ring R] [Module R M] [Invertible 2] {Q : QuadraticForm R M} (hB₁ : ⇑QuadraticForm.associated' Q ≠ 0) : ∃ (x : M), ⇑Q x ≠ 0
{α : Type u} [PseudoEmetricSpace α] {x y : α} {s t : Set α} (xs : x ∈ s) (yt : y ∈ t) : Emetric.diam (s ∪ t) ≤ Emetric.diam s + HasEdist.edist x y + Emetric.diam t
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [SemiNormedGroup E] [SemiNormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [RingHomIsometric σ₁₂] (f : E →sl[σ₁₂] F) (M : Nnreal) (hM : ∀ (x : E), ∥⇑f x∥₊ ≤ M * ∥x∥₊) : ∥f∥₊ ≤ M
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {f g : ℂ → E} (hdf : DiffContOnCl ℂ f (Set.Ioi 0 ×ℂ Set.Iio 0)) (hBf : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Iio 0)] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hdg : DiffContOnCl ℂ g (Set.Ioi 0 ×ℂ Set.Iio 0)) (hBg : ∃ (c : ℝ) (H : c < 2) (B : ℝ), g =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Iio 0)] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hre : ∀ (x : ℝ), 0 ≤ x → f ↑x = g ↑x) (him : ∀ (x : ℝ), x ≤ 0 → f (↑x * Complex.i) = g (↑x * Complex.i)) : Set.EqOn f g {z : ℂ | 0 ≤ z.re ∧ z.im ≤ 0}
{M : Type u_4} [GroupWithZero M] {f g : ℚ →*₀ M} (same_on_Neg_One : ⇑f (-1) = ⇑g (-1)) (same_on_pnat : ∀ (n : ℕ), 0 < n → ⇑f ↑n = ⇑g ↑n) : f = g
{α : Type u_1} {β : Type u_2} (e : LocalEquiv α β) : e.trans e.symm ≈ local_equiv.of_Set e.source
(A : Type u_4) [CommRing A] [is_IsDomain A] {K : Type u_5} [CommRing K] [Algebra A K] [IsFractionRing A K] : is_IsDomain K
{R : Type u_1} [CommRing R] (u v w x : Fin 3 → R) : matrix.dot_Product (⇑(⇑CrossProduct u) v) (⇑(⇑CrossProduct w) x) = matrix.dot_Product u w * matrix.dot_Product v x - matrix.dot_Product u x * matrix.dot_Product v w
{ι : Type u} (s : Finset ι) (f : ι → Ennreal) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), f i) ^ p ≤ ↑(s.card) ^ (p - 1) * s.sum (λ (i : ι), f i ^ p)
{R : Type u} {M : Type v} [Group R] [MulAction R M] {p : SubMulAction R M} (m : ↥p) : MulAction.stabilizer R m = MulAction.stabilizer R ↑m
{R : Type u_1} {M : Type u_2} {ι : Type u_3} [CommRing R] [AddCommGroup M] [Module R M] [Fintype ι] (b : Basis ι R M) : Module.Finite R M
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q) : (∀ (a : ↥P), ⇑f a = 0) → f = 0
{V : Type u} [CategoryTheory.Category V] [CategoryTheory.Abelian V] {A B C D A' B' C' D' : V} {f : A ⟶ B} {g : B ⟶ C} {h : C ⟶ D} {f' : A' ⟶ B'} {g' : B' ⟶ C'} {h' : C' ⟶ D'} {α : A ⟶ A'} {β : B ⟶ B'} {γ : C ⟶ C'} {δ : D ⟶ D'} (comm₁ : α ≫ f' = f ≫ β) (comm₂ : β ≫ g' = g ≫ γ) (comm₃ : γ ≫ h' = h ≫ δ) (hgh : CategoryTheory.Exact g h) (hF'g' : CategoryTheory.Exact f' g') (hg'h' : CategoryTheory.Exact g' h') (hα : CategoryTheory.Epi α) (hγ : CategoryTheory.Epi γ) (hδ : CategoryTheory.Mono δ) : CategoryTheory.Epi β
{R : Type u_1} {a b : R} [Semigroup R] (Ab : IsRightRegular (b * a)) : IsRightRegular b
{M : Type u_6} {N : Type u_7} [has_Add M] [has_Add N] {f g : M ≃+ N} (h : ∀ (x : M), ⇑f x = ⇑g x) : f = g
{b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : 0 < y) : b ^ x ≤ y ↔ x ≤ Nat.log b y
{α : Type u_1} [UniformSpace α] [CompactSpace α] [SeparatedSpace α] : Uniformity α = ⨆ (x : α), nhds (x, x)
{G : Type u_1} [Group G] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)] [hp₂ : Fact (Nat.Prime p₂)] (hne : p₁ ≠ p₂) (H₁ H₂ : Subgroup G) (hH₁ : is_p_Group p₁ ↥H₁) (hH₂ : is_p_Group p₂ ↥H₂) : Disjoint H₁ H₂
{α : Type u_2} [DecidableEq α] [HasSub α] {u : Finset α} {s t : Set α} : ↑u ⊆ s - t → (∃ (s' t' : Finset α), ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' - t')
{R : Type u_1} {K : Type u_2} [Semiring R] [CommSemiring K] {b : R} {bi : K} (i : R →+* K) (f : Polynomial R) (a : R) (bu : bi * ⇑i b = 1) : DenomsClearable a b f.nat_degree f i
(H : AddSubgroup ℤ) : ∃ (a : ℤ), H = AddSubgroup.closure {a}
{R : Type u} [Semiring R] {p : Polynomial R} : Polynomial.x * p = p * Polynomial.x
{α : Type u_1} {n : Type u_4} {m : Type u_5} [HasZero α] {A : Matrix m m α} {C : Matrix n m α} {D : Matrix n n α} (h : (matrix.from_blocks A 0 C D).is_Symm) (ha : A.is_diag) (hD : D.is_diag) : (matrix.from_blocks A 0 C D).is_diag
{R : Type u_1} [CommRing R] (u v w : Fin 3 → R) : ⇑(⇑CrossProduct u) (⇑(⇑CrossProduct v) w) + ⇑(⇑CrossProduct v) (⇑(⇑CrossProduct w) u) + ⇑(⇑CrossProduct w) (⇑(⇑CrossProduct u) v) = 0
{ι : Type u_1} {X : Type u_2} [TopologicalSpace X] [NormalSpace X] {u : ι → Set X} {s : Set X} {c : Set (ShrinkingLemma.PartialRefinement u s)} (hc : IsChain has_le.le c) {v₁ v₂ : ShrinkingLemma.PartialRefinement u s} (h₁ : v₁ ∈ c) (h₂ : v₂ ∈ c) {i : ι} (hi₁ : i ∈ v₁.carrier) (hi₂ : i ∈ v₂.carrier) : ⇑v₁ i = ⇑v₂ i
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} {ps : Set P} (h : ps ⊆ ↑s) [Nonempty ↥s] {n : ℕ} [FiniteDimensional ℝ ↥(s.direction)] (hD : FiniteDimensional.finrank ℝ ↥(s.direction) = n) (hc : EuclideanGeometry.Cospherical ps) : ∃ (c : P), ∀ (sx : Affine.Simplex ℝ P n), Set.Range sx.points ⊆ ps → sx.circumcenter = c
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {f : 𝕜 → F} : iterated_fderiv 𝕜 n f = ⇑(Continuous_multilinear_map.pi_Field_Equiv 𝕜 (Fin n) F) ∘ iterated_deriv n f
{𝕂 : Type u_6} [is_R_or_C 𝕂] {E' : Type u_7} [NormedGroup E'] [NormedSpace 𝕂 E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {f : E' → F'} {x : E'} (hF : ContDiffAt 𝕂 1 f x) (K : Nnreal) (hK : ∥fderiv 𝕂 f x∥₊ < K) : ∃ (t : Set E') (H : t ∈ nhds x), LipschitzOnWith K f t
{α : Type u} {a b c d : α} [Preorder α] (hca : c ≤ a) (hbd : b ≤ d) : a ≤ b → c ≤ d
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} [DecidableEq ι] {V : ι → Submodule 𝕜 E} (hV : OrthogonalFamily 𝕜 (λ (i : ι), (V i).subtypeₗᵢ)) (hc : IsComplete ↑(supr V)) : DirectSum.IsInternal V ↔ (supr V)ᗮ = ⊥
{α : Type u_1} {l : List α} {x : α} : List.Duplicate x l ↔ [x, x] <+ l
{β : Type u} {α : Type v} [CommMonoid β] {s : Finset α} (hc : s.card ≤ 1) {f : α → β} {b : β} (h : s.prod (λ (x : α), f x) = b) (x : α) (H : x ∈ s) : f x = b
{α : Type u_1} {m : MeasurableSpace α} (ν : MeasureTheory.Measure α) [MeasureTheory.SigmaFinite ν] {f : α → Ennreal} (hF : Measurable f) : (ν.with_density f).rn_deriv ν =ᵐ[ν] f
{t : ↥UnitInterval} : 0 ≤ t
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : AffineSubspace k P} {v : V} (hv : v ∈ s.direction) {p : P} (hp : p ∈ s) : v +ᵥ p ∈ s
(a : ↥Circle) : ⇑LinearMap.det ↑((⇑rotation a).to_LinearEquiv) = 1
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {f : α → β} (hF : Continuous f) : Filter.comap f (Filter.cocompact β) ≤ Filter.cocompact α
(Fq F : Type) [Field Fq] [Field F] (Fqt : Type u_1) [Field Fqt] [Algebra (Polynomial Fq) Fqt] [IsFractionRing (Polynomial Fq) Fqt] [Algebra (Ratfunc Fq) F] [Algebra Fqt F] [Algebra (Polynomial Fq) F] [IsScalarTower (Polynomial Fq) Fqt F] [IsScalarTower (Polynomial Fq) (Ratfunc Fq) F] : FunctionField Fq F ↔ FiniteDimensional Fqt F
{α : Type u} {β : Type v} [Preorder β] {f : α → β} {s : Set α} {a : α} : IsMaxOn (⇑order_dual.to_dual ∘ f) s a → IsMinOn f s a
{α : Type u} {r : α → α → Prop} {a b : α} (l : List α) (hl₁ : List.Chain r a l) (hl₂ : (a :: l).last _ = b) : Relation.ReflTransGen r a b
{α : Type u_1} [CircularPreorder α] {a b c : α} (habc : HasBtw.Btw a b c) (hcba : ¬HasBtw.Btw c b a) : HasSbtw.Sbtw a b c
{n : WithTop ℕ} {𝕂 : Type u_6} [is_R_or_C 𝕂] {E' : Type u_7} [NormedGroup E'] [NormedSpace 𝕂 E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {s : Set E'} {f : E' → F'} {x : E'} {p : E' → FormalMultilinearSeries 𝕂 E' F'} (hF : HasFtaylorSeriesUpToOn n f p s) (hn : 1 ≤ n) (hs : s ∈ nhds x) : HasStrictFderivAt f (⇑(Continuous_multilinear_Curry_Fin1 𝕂 E' F') (p x 1)) x
{α : Type u_1} [DecidableEq α] (s : Set α) [Fintype ↥s] {a : α} (h : a ∈ s) : a ∈ tactic.interval_cases.set_elems s
{α : Type u_1} {β : Type u_2} [DecidableEq α] [Fintype α] [CommSemiring β] {δ : α → Type u_1} [Π (a : α), DecidableEq (δ a)] {t : Π (a : α), Finset (δ a)} {f : Π (a : α), δ a → β} : finset.univ.prod (λ (a : α), (t a).sum (λ (b : δ a), f a b)) = (fintype.pi_Finset t).sum (λ (p : Π (a : α), δ a), finset.univ.prod (λ (x : α), f x (p x)))
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} : ContDiff 𝕜 n Prod.fst
(R : Type u_1) {p m : ℕ} [Fact (Nat.Prime p)] [Ring R] [Char_p R p] (hm : ¬p ∣ m) {k : ℕ} : 0 < k → Polynomial.cyclotomic (p ^ k * m) R = Polynomial.cyclotomic m R ^ (p ^ k - p ^ (k - 1))
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {F G : C ⥤ D} (α : F ⟶ G) [∀ (X : C), CategoryTheory.Epi (α.app X)] : CategoryTheory.Epi α
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {f : V →ₗ[K] V} (hinj : Function.Injective ⇑f) : Function.Surjective ⇑f
{α : Type u} {a b : α} [MulOneClass α] [HasZero α] [Preorder α] [ZeroLt.MulPosMono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 < b) : 1 ≤ a * b
{α : Type v} [LinearOrder α] [TopologicalSpace α] [OrderClosedTopology α] {s : Set α} (hs : IsPreconnected s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) : Set.Icc a b ⊆ s
{R : Type u_1} [CommRing R] (S : Type u_2) [CommRing S] [Algebra R S] (T : Type u_4) [CommRing T] [Algebra R T] (M N : Submonoid R) (h : M ≤ N) [IsLocalization M S] [IsLocalization N T] : IsScalarTower R S T
{α : Type u_1} {s : Finset α} {p : α → Prop} [DecidablePred p] (h : ∀ (x : α), x ∈ s → p x) : Finset.map (Function.Embedding.subtype p) (Finset.subtype p s) = s
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) : hb.oangle (-x) (-y) = hb.oangle x y
{ι : Type u_1} {R : Type u_2} {α : Type u_3} {S : Type u_4} [SetLike S R] [Monoid R] [AddMonoid ι] (A : ι → S) [SetLike.GradedMonoid A] (fι : α → ι) (fA : Π (a : α), ↥(A (fι a))) (l : List α) : l.dprod fι fA = ⟨(List.map (λ (a : α), ↑(fA a)) l).prod, _⟩
{α : Type u_1} [AddCommMonoid α] [TopologicalSpace α] {a : α} {f : ℕ → α} (h : HasSum f a) : Filter.Tendsto (λ (n : ℕ), (Finset.range n).sum (λ (i : ℕ), f i)) filter.at_Top (nhds a)
{α : Type u_1} [MeasurableSpace α] {s : Set α} : MeasurableSet s → (Filter.principal s).is_measurably_generated
(p : ℕ) [Fact (Nat.Prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_Sym p a = 1 ∨ zmod.legendre_Sym p a = -1
{β : Type u_2} {γ : Type u_3} [TopologicalSpace β] [TopologicalSpace γ] {κ : Type u_5} {g : β → γ} {f : κ → β} (hg : DenseRange g) (hF : DenseRange f) (cg : Continuous g) : DenseRange (g ∘ f)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X Y : C} (f g : X ⟶ Y) [CategoryTheory.Limits.HasEqualizer f g] : CategoryTheory.Limits.HasKernel (f - g)
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {x y : 𝕜} (h : x < y) {z : 𝕜} : z ∈ Set.Ioc x y ↔ ∃ (a b : 𝕜), 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z
{M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : AddZeroClass M} {mN : AddZeroClass N} [AddMonoidHomClass F M N] (f : F) {x : M} (hx : ∃ (y : M), x + y = 0) : ∃ (y : N), ⇑f x + y = 0
{R : Type u1} [CommSemiring R] {M : Type u2} [AddCommMonoid M] [Module R M] : Disjoint (ExteriorAlgebraι R).range 1
{F : Type u_3} [InnerProductSpace ℝ F] {K : Set F} (h : Convex ℝ K) {u v : F} (hv : v ∈ K) : (∥u - v∥ = ⨅ (w : ↥K), ∥u - ↑w∥) ↔ ∀ (w : F), w ∈ K → HasInner.inner (u - v) (w - v) ≤ 0
{R : Type u_1} [CancelCommMonoidWithZero R] {x y a p : R} {n : ℕ} (hp : Prime p) (hx : x * y = a * p ^ n) : ∃ (i j : ℕ) (b c : R), i + j = n ∧ a = b * c ∧ x = b * p ^ i ∧ y = c * p ^ j
(A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension ∅ A B] : ⊥ = ⊤
{α : Type u_1} [HasLe α] {a : α} : IsTop a → IsBot (⇑order_dual.to_dual a)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E] {x : E} {s : Set E} (hx : x ∈ s) (hs : s ≠ Set.Univ) : ∃ (y : E) (H : y ∈ Frontier s), metric.inf_dist x sᶜ = HasDist.dist x y
{α : Type u_1} [PseudoEmetricSpace α] (C : Ennreal) {f : ℕ → α} (hu : ∀ (n : ℕ), HasEdist.edist (f n) (f (n + 1)) ≤ C / 2 ^ n) {a : α} (ha : Filter.Tendsto f filter.at_Top (nhds a)) : HasEdist.edist (f 0) a ≤ 2 * C
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {X : Top} (F : Top.Presheaf C X) (U : TopologicalSpace.Opens ↥X) (R : CategoryTheory.Presieve U) (hR : CategoryTheory.Sieve.generate R ∈ ⇑(opens.grothendieck_topology ↥X) U) : Category_theory.presheaf.fork_Map R F ≫ (Top.presheaf.covering_of_presieve.first_obj_iso_Pi_Opens F U R).hom = F.map (Category_theory.eq_to_hom _).op ≫ Top.Presheaf.SheafConditionEqualizerProducts.res F (Top.presheaf.covering_of_Presieve U R)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] (p : P) : euclidean_geometry.orthogonal_projection_fn s p ∈ AffineSubspace.mk' p (s.direction)ᗮ
{α : Type u_1} {G : Type u_4} [SubtractionCommMonoid G] {f g : α → G} (hF : (Function.Support f).finite) (hg : (Function.Support g).finite) : finsum (λ (i : α), f i - g i) = finsum (λ (i : α), f i) - finsum (λ (i : α), g i)
{α : Type u_2} [Semiring α] {a : α} : Odd a → (∃ (b : α), a = bit1 b)
(p : ℕ) [p_Prime : Fact (Nat.Prime p)] {q r : ℕ} (hq : q ≠ 0) (hr : r ≠ 0) : padic_val_Nat p (q * r) = padic_val_Nat p q + padic_val_Nat p r
(f : Circle_deg1_Lift) {x : ℝ} {n : ℕ} {m : ℤ} (h : ⇑(f ^ n) x = x + ↑m) (hn : 0 < n) : f.translation_number = ↑m / ↑n
{G : Type u_1} [AddGroup G] {ι : Type u_2} (s : Finset ι) (f : ι → G) (comm : ∀ (x : ι), x ∈ s → ∀ (y : ι), y ∈ s → AddCommute (f x) (f y)) (K : ι → AddSubgroup G) (hind : CompleteLattice.Independent K) (hmem : ∀ (x : ι), x ∈ s → f x ∈ K x) (HEq1 : s.noncomm_Sum f comm = 0) (i : ι) (H : i ∈ s) : f i = 0
{α : Type u_1} {M : Type u_5} [CommMonoid M] {a : α} {s : Set α} (f : α → M) (h : a ∉ s) (hs : s.finite) : finprod (λ (i : α), finprod (λ (H : i ∈ HasInsert.insert a s), f i)) = f a * finprod (λ (i : α), finprod (λ (H : i ∈ s), f i))
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - 2 * ∥x∥ * ∥y∥ * Real.cos (InnerProductGeometry.angle x y)
{G₀ : Type u_2} [GroupWithZero G₀] (a : G₀) : a / a * a = a
{M : Type u_3} {N : Type u_4} [has_Add M] [has_Add N] {f g : AddHom M N} (h : f = g) (x : M) : ⇑f x = ⇑g x
{α : Type u_1} {β : Type u_2} {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃) {s : Set α} {f : α → β} (h₂ : ContinuousOn f s) : ContinuousOn f s
(a : ℝ) : Cardinal.mk ↥(Set.Ioi a) = Cardinal.continuum
{G : Type u_1} [AddGroup G] (H : AddSubgroup G) {x : G} : x ∈ H → -x ∈ H
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasInitial C] (h : ∀ (X : C), CategoryTheory.Mono (CategoryTheory.Limits.initial.to X)) : CategoryTheory.Limits.InitialMonoClass C
{α : Type u_2} {ι : Type u_5} [CommMonoid α] (t : Finset ι) (f₁ f₂ : ι → Set α) (hF : ∀ {i : ι}, i ∈ t → f₁ i ⊆ f₂ i) : t.prod (λ (i : ι), f₁ i) ⊆ t.prod (λ (i : ι), f₂ i)
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (K : Type u_2) [Field K] [Algebra R K] [IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R) : Classical.some _ ≠ 0
{X : Type u_2} [EmetricSpace X] [MeasurableSpace X] [BorelSpace X] {m₁ m₂ : Ennreal → Ennreal} {c : Ennreal} (hc : c ≠ ⊤) (h0 : c ≠ 0) (hle : m₁ ≤ᶠ[nhds_within 0 (Set.Ici 0)] c • m₂) : measure_theory.measure.mk_metric m₁ ≤ c • measure_theory.measure.mk_metric m₂
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace E] {v : E} (hv : v ∈ K) : ⇑(Orthogonal_projection Kᗮ) v = 0
{H : Type u} [TopologicalSpace H] (G : StructureGroupoid H) : LocalHomeomorph.refl H ∈ StructureGroupoid.MaximalAtlas H G
{M : Type u_1} {N : Type u_2} [MulOneClass M] [MulOneClass N] (h : M ≃* N) : IsMulHom ⇑h
(w₁ w₂ z₁ z₂ : Ennreal) (hw' : w₁ + w₂ = 1) {p : ℝ} (hp : 1 ≤ p) : (w₁ * z₁ + w₂ * z₂) ^ p ≤ w₁ * z₁ ^ p + w₂ * z₂ ^ p
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {f : M →* P} : (Con.ker_Lift f).mrange = f.mrange
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] (i : D ⥤ C) [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Reflective i] [CategoryTheory.CartesianClosed C] [CategoryTheory.ExponentialIdeal i] (A B : C) : CategoryTheory.IsIso (Category_theory.limits.prod_comparison (CategoryTheory.IsLeftAdjoint i) A B)
{C : Type u₁} [CategoryTheory.Category C] {X : C} (P : Cᵒᵖ ⥤ Type w) {S : CategoryTheory.Sieve X} {R : CategoryTheory.Presieve X} (h : ⇑S ≤ R) (Trans : ∀ ⦃Y : C⦄ (f : Y ⟶ X), CategoryTheory.Presieve.IsSheafFor P ⇑(CategoryTheory.Sieve.pullback f S)) : CategoryTheory.Presieve.IsSheafFor P R
{M : Type u_1} [HasMul M] (c : Con M) {a b : M} : ↑a = ↑b ↔ ⇑c a b
{R : Type u} [NonAssocSemiring R] (s : Subsemiring R) {l : List R} : (∀ (x : R), x ∈ l → x ∈ s) → l.sum ∈ s
(C : Type u) [CategoryTheory.Category C] [∀ {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span f g)] : CategoryTheory.Limits.HasPushouts C
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [BaireSpace α] [Nonempty α] [Encodable β] {f : β → Set α} (hc : ∀ (s : β), is_IsClosed (f s)) (hU : (⋃ (s : β), f s) = Set.Univ) : ∃ (s : β), (Interior (f s)).nonempty
{ι : Type u_1} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {G : ι → Type u_4} [Π (i : ι), InnerProductSpace 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 V) [∀ (i : ι), CompleteSpace (G i)] (hV' : (⨆ (i : ι), (V i).to_LinearMap.range).topological_Closure = ⊤) (w : ↥(Lp G 2)) : ⇑((hV.linear_Isometry_Equiv hV').symm) w = ∑' (i : ι), ⇑(V i) (⇑w i)
{α : Type u_1} {f : α → α} {x : α} (hF : Function.IsFixedPt f x) (n : ℕ) : Function.IsPeriodicPt f n x
(n : ℕ) : (Finset.range (n + 1)).sum (λ (m : ℕ), n.choose m) = 2 ^ n
{α : Type u_1} {β : Type u_3} [MeasurableSpace α] [MeasurableSpace β] {ν : MeasureTheory.Measure β} [MeasureTheory.IsFiniteMeasure ν] {s : Set (α × β)} (hs : MeasurableSet s) : Measurable (λ (x : α), ⇑ν (Prod.mk x ⁻¹' s))
{G : Type u} [Group G] [Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G} (hH : Fintype.card ↥H = p ^ n) : Fintype.card ↥(H.normalizer) ≡ Fintype.card G [Mod p ^ (n + 1)]
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] {a b : α} {s : Set α} (hs : is_IsClosed (s ∩ Set.Icc a b)) (ha : a ∈ s) (hgt : ∀ (x : α), x ∈ s ∩ Set.Ico a b → ∀ (y : α), y ∈ Set.Ioi x → (s ∩ Set.Ioc x y).nonempty) : Set.Icc a b ⊆ s
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace 𝕜] {c : 𝕜} (hc : 1 < ∥c∥) {R : ℝ} (hR : ∥c∥ < R) (h : ¬FiniteDimensional 𝕜 E) : ∃ (f : ℕ → E), (∀ (n : ℕ), ∥f n∥ ≤ R) ∧ ∀ (m n : ℕ), m ≠ n → 1 ≤ ∥f m - f n∥
{α : Type u_1} [ConditionallyCompleteLattice α] {s t : Set α} : BddBelow s → BddBelow t → (s ∩ t).nonempty → HasInf.inf s ⊔ HasInf.inf t ≤ HasInf.inf (s ∩ t)
{α : Type u} [Group α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a
{n : ℕ} (R : Type u_1) [Ring R] : Coe ∘ Coe = Coe
(r n : ℕ) : (2 * n).choose r ≤ n.central_binom
{α : Type u_1} {β : Type u_2} {p : Pmf α} (f : Π (a : α), a ∈ p.support → Pmf β) (s : Set β) [MeasurableSpace β] (hs : MeasurableSet s) : ⇑((p.bind_on_Support f).to_measure) s = ∑' (a : α), ↑(⇑p a) * dite (⇑p a = 0) (λ (h : ⇑p a = 0), 0) (λ (h : ¬⇑p a = 0), ⇑((f a h).to_measure) s)
{α : Type u_1} [TopologicalSpace α] [BaireSpace α] {S : Set (Set α)} (ho : ∀ (s : Set α), s ∈ S → is_IsOpen s) (hS : S.countable) (hD : ∀ (s : Set α), s ∈ S → Dense s) : Dense (⋂₀ S)
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] {f : E → F} {z : E} {r : ℝ} (hD : DiffContOnCl ℂ f (Metric.Ball z r)) (hz : IsMaxOn (HasNorm.norm ∘ f) (Metric.Ball z r) z) : Set.EqOn (HasNorm.norm ∘ f) (Function.const E ∥f z∥) (Metric.ClosedBall z r)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {f' f₁' : E →L[𝕜] F} {x : E} {s : Set E} (hF : HasFderivWithinAt f f' s x) (hg : HasFderivWithinAt f f₁' s x) : Set.EqOn ⇑f' ⇑f₁' (TangentConeAt 𝕜 s x)
{α : Type u_1} {p : α → Prop} : Set.Range Coe = {x : α | p x}
{R : Type u_1} {a b : R} [AddSemigroup R] : IsAddRegular (a + b) ∧ IsAddRegular (b + a) ↔ IsAddRegular a ∧ IsAddRegular b
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] {a b c : α} : -b + a < c → a < b + c
{R : Type u₁} [CommRing R] (a b : R) : a ^ 2 - b ^ 2 = (a + b) * (a - b)
{α : Type u_1} [DecidableEq α] (s : Finset α) : s.sym2.card = s.card * (s.card + 1) / 2
{α : Type u_3} {β : Type u_4} {γ : Type u_5} [CommMonoid α] {g : γ → β} (hg : Function.Injective g) {f : β → α} (hF : ∀ (x : β), x ∉ Set.Range g → f x = 1) : Filter.map (λ (s : Finset γ), s.prod (λ (i : γ), f (g i))) filter.at_Top = Filter.map (λ (s : Finset β), s.prod (λ (i : β), f i)) filter.at_Top
{α : Type u} [t : TopologicalSpace α] {b : Set (Set α)} (hb : TopologicalSpace.IsTopologicalBasis b) {s : Set α} {a : α} : a ∈ Closure s ↔ ∀ (o : Set α), o ∈ b → a ∈ o → (o ∩ s).nonempty
(n : ℕ) : (Multiset.Nat.antidiagonal n).nodup
(α : Type u) {β : Type v} [AddGroup α] [AddAction α β] (b : β) [Fintype α] [Fintype ↥(AddAction.Orbit α b)] [Fintype ↥(AddAction.stabilizer α b)] : Fintype.card ↥(AddAction.Orbit α b) * Fintype.card ↥(AddAction.stabilizer α b) = Fintype.card α
{R : Type u_1} [OrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {v₁ v₂ : RayVector R M} : -v₁ ≈ -v₂ ↔ v₁ ≈ v₂
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderClosedTopology α] [Nonempty α] {s : Set α} (hs : is_IsCompact s) : BddAbove s
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {f : α → E} {g : α → F} {l : Filter α} : f =O[l] g ↔ ∃ (c : ℝ), asymptotics.is_O_with c l f g
{F : Type u → Type u} [Functor F] [q : Qpf F] {α : Type u} (u : F α → α) (x y : (Qpf.p F).W) : Qpf.Wequiv x y → Qpf.recF u x = Qpf.recF u y
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) (i : Fin (n + 1)) : HasDist.dist (s.points i) s.circumcenter = s.circumradius
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) : s.circumcenter ∈ affine_Span ℝ (Set.Range s.points)
{α : Type u_1} {β : Type u_2} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] [Nonempty β] {f : β → α} (hF : Continuous f) (hlim : Filter.Tendsto f (Filter.cocompact β) filter.at_Top) : ∃ (x : β), ∀ (y : β), f x ≤ f y
{S : Type u_2} [CommRing S] {K : Type u_6} [Field K] [Algebra K S] {x : S} (hx : IsIntegral K x) : LinearIndependent K (λ (i : Fin (minpoly K x).nat_degree), x ^ ↑i)
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} {s t : Set α} (hst : Disjoint s t) (hs : s.finite) (ht : t.finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s ∪ t), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))
{a b : ℕ} (hab : a.coprime b) : Disjoint a.factorization.support b.factorization.support
{K : Type u} [Field K] (s : Subfield K) : Subfield.closure ↑s = s
{α : Type u} {β : Type v} [Preorder β] {f : α → β} {l : Filter α} {a : α} : IsMinFilter (⇑order_dual.to_dual ∘ f) l a → IsMaxFilter f l a
{R : Type u} [CommRing R] [is_IsDomain R] [DiscreteValuationRing R] (ϖ : R) : Irreducible ϖ ↔ local_ring.maximal_Ideal R = Ideal.span {ϖ}
{α : Type u} [PartialOrder α] {a b : α} (hab : a ≤ b) (hba : ¬a < b) : b = a
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] [NormalSpace Y] (f : BoundedContinuousFunction X ℝ) {e : X → Y} (hE : ClosedEmbedding e) : ∃ (g : BoundedContinuousFunction Y ℝ), ∥g∥ = ∥f∥ ∧ ⇑g ∘ e = ⇑f
{G : Type u_1} [AddCommGroup G] (K : AddSubgroup G) (g : Multiset G) : (∀ (a : G), a ∈ g → a ∈ K) → g.sum ∈ K
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} (s : Finset ι) [Fintype ι] (p : ι → P) : Finset.centroid k s p = ⇑(finset.univ.affine_combination p) (Finset.centroid_weights_indicator k s)
(n : ℕ) : Filter.Tendsto (λ (x : ℝ), Real.exp x / x ^ n) filter.at_Top filter.at_Top
(m n : ℕ) : Nat.fib (m + n + 1) = Nat.fib m * Nat.fib n + Nat.fib (m + 1) * Nat.fib (n + 1)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : AffineSubspace k P} {p1 : P} (hp1 : p1 ∈ s) (p2 p : P) : p ∈ affine_Span k (HasInsert.insert p2 ↑s) ↔ ∃ (r : k) (p0 : P) (hp0 : p0 ∈ s), p = r • (p2 -ᵥ p1) +ᵥ p0
{α : Type u_1} {p : Π (s : Finset α), s.nonempty → Prop} (h₀ : ∀ (a : α), p {a} _) (h₁ : ∀ ⦃a : α⦄ (s : Finset α) (h : a ∉ s) (hs : s.nonempty), p s hs → p (Finset.cons a s h) _) {s : Finset α} (hs : s.nonempty) : p s hs
{G : Type u_1} [SubNegMonoid G] [MeasurableSpace G] [HasMeasurableAdd G] (g : G) : Measurable (λ (h : G), h - g)
{M : Type u_1} [HasMul M] {c d : Con M} (H : Setoid.r = Setoid.r) : c = d
{R : Type u_1} {A : Type u_2} [CommSemiring R] [CommRing A] [Algebra R A] (𝒜 : ℕ → Submodule R A) [GradedAlgebra 𝒜] : GaloisConnection (λ (s : Set A), ProjectiveSpectrum.ZeroLocus 𝒜 s) (λ (t : (Set (ProjectiveSpectrum 𝒜))ᵒᵈ), ↑(projective_spectrum.vanishing_Ideal t))
{α : Type u_3} {β : Type u_4} [Nonempty α] [SemilatticeInf α] [Preorder β] {f : α → β} (hF : Monotone f) : Filter.Tendsto f filter.at_IsBot filter.at_IsBot ↔ ∀ (b : β), ∃ (a : α), f a ≤ b
{R : Type v} [CommRing R] {n : ℕ} (A : Matrix (Fin n.succ) (Fin n.succ) R) : A.det = finset.univ.sum (λ (i : Fin n.succ), (-1) ^ ↑i * A i 0 * (A.minor ⇑(i.succ_above) Fin.succ).det)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {J : Type w} [CategoryTheory.Category J] (F : C ⥤ D) [CategoryTheory.Limits.HasColimitsOfShape J D] [CategoryTheory.CreatesColimitsOfShape J F] : CategoryTheory.Limits.HasColimitsOfShape J C
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : ℝ} {c w : ℂ} {f : ℂ → E} {s : Set ℂ} (hs : s.countable) (hw : w ∈ Metric.Ball c R) (hc : ContinuousOn f (Metric.ClosedBall c R)) (hD : ∀ (x : ℂ), x ∈ Metric.Ball c R  s → DifferentiableAt ℂ f x) : ∮ (z : ℂ) in C(c, R), (z - w)⁻¹ • f z = (2 * ↑Real.pi * Complex.i) • f w
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] {a b : α} {s : Set α} (hs : is_IsClosed (s ∩ Set.Icc a b)) (ha : a ∈ s) (hab : a ≤ b) (hgt : ∀ (x : α), x ∈ s ∩ Set.Ico a b → (s ∩ Set.Ioc x b).nonempty) : b ∈ s
{R : Type u_4} [LinearOrderedRing R] (a : R) : 0 ≤ a ^ 2
{K : Type u_1} {v : K} {n : ℕ} [LinearOrderedField K] [FloorRing K] {ifp_Succ_n : GeneralizedContinuedFraction.IntFractPair K} (Succ_nth_Stream_Eq : GeneralizedContinuedFraction.IntFractPair.stream v (n + 1) = Option.some ifp_Succ_n) : 1 ≤ ifp_Succ_n.b
(R : Type u) [CommSemiring R] {M : Type v} [AddCommMonoid M] [Module R M] {s : Finset M} (b : Basis ↥s R M) (f : M →ₗ[R] M) : ⇑(LinearMap.trace R M) f = (⇑(Linear_map.to_Matrix b b) f).trace
{R : Type u_1} [CommRing R] {S : Type u_2} [CommRing S] [Algebra R S] [is_IsDomain S] (H : Algebra.IsIntegral R S) (P : Ideal R) [P_max : P.is_Maximal] (hP : (Algebra_Map R S).ker ≤ P) : ∃ (Q : Ideal S), Q.is_Maximal ∧ Ideal.comap (Algebra_Map R S) Q = P
(M : Type u_1) (α : Type u_2) [Monoid M] [MulAction M α] : GaloisConnection (⇑order_dual.to_dual ∘ fixing_Submonoid M) ((λ (P : Submonoid M), MulAction.FixedPoints ↥P α) ∘ ⇑order_dual.of_dual)
{α : Type u_1} {β : Type u_3} {γ : Type u_5} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ] {δ : Type u_7} [MeasurableSpace δ] {μa : MeasureTheory.Measure α} {μb : MeasureTheory.Measure β} {μc : MeasureTheory.Measure γ} {μd : MeasureTheory.Measure δ} [MeasureTheory.SigmaFinite μb] [MeasureTheory.SigmaFinite μd] {f : α → β} {g : γ → δ} (hF : MeasureTheory.MeasurePreserving f μa μb) (hg : MeasureTheory.MeasurePreserving g μc μd) : MeasureTheory.MeasurePreserving (Prod.map f g) (μa.prod μc) (μb.prod μd)
 : Filter.Tendsto Complex.abs (Filter.cocompact ℂ) filter.at_Top
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {c : AddCon M} {f : M →+ P} (H : c ≤ AddCon.ker f) (x : M) : ⇑(c.lift f H) ↑x = ⇑f x
{n : ℕ} (i j : Σ (a : Composition n), Composition a.length) : i = j ↔ i.fst.blocks = j.fst.blocks ∧ i.snd.blocks = j.snd.blocks
{K : Type u_1} [LinearOrderedField K] {a b c : K} (h : ∀ (x : K), 0 ≤ a * x * x + b * x + c) : discrim a b c ≤ 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (p : P) (direction : Submodule k V) : p ∈ AffineSubspace.mk' p direction
{M : Type u_1} [HasMul M] {c : Con M} {C : c.quotient → Prop} (q : c.quotient) (H : ∀ (x : M), C ↑x) : C q
{ι : Type u} {γ : Type w} [dec : DecidableEq ι] [AddCommMonoid γ] (S : ι → AddSubmonoid γ) : supr S = (dfinsupp.sum_AddHom (λ (i : ι), (S i).subtype)).mrange
(p : ℕ) [hp : Fact (Nat.Prime p)] {q : ℚ} (hq : q ≠ 0) : padic_norm p q ≠ 0
{R : Type u} [Ring R] {P : Type (max u v)} [AddCommGroup P] [Module R P] : Module.Projective R P ↔ CategoryTheory.Projective (Module.of R P)
{R : Type u} [Ring R] : CategoryTheory.Limits.HasKernels (Module R)
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : Rˣ) : ContinuousAt Ring.inverse ↑x
{R : Type u} [NonAssocSemiring R] (s : Subsemiring R) {x y : R} : x ∈ s → y ∈ s → x + y ∈ s
{X : Type u_2} {Y : Type u_3} [EmetricSpace X] [EmetricSpace Y] {C r : Nnreal} {f : X → Y} (h : HolderWith C r f) (hr : 0 < r) : dimH (Set.Range f) ≤ dimH Set.Univ / ↑r
{α : Type u_1} [ConditionallyCompleteLattice α] {s t : Set α} (hs : BddAbove s) (ht : BddAbove t) (hst : (s ∩ t).nonempty) : HasSup.sup (s ∩ t) ≤ HasSup.sup s ⊓ HasSup.sup t
{P L : Type u} [HasMem P L] [Configuration.Nondegenerate P L] [Fintype P] [Fintype L] (h : Fintype.card L ≤ Fintype.card P) : ∃ (f : L → P), Function.Injective f ∧ ∀ (l : L), f l ∉ l
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] {M : Matrix n n R} {i j : n} (i_NE_j : i ≠ j) (hij : ∀ (k : n), M k i = M k j) : M.det = 0
{G : Type u} {x : G} {n : ℕ} [Monoid G] (hn : 0 < n) (hx : x ^ n = 1) (hD : ∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) : order_of x = n
{M : Type u_1} [AddMonoid M] {x : M} : Add_monoid.closure {x} = Multiples x
{α : Type u} [PseudoMetricSpace α] {x : α} {r : ℝ} : Metric.Bounded (Metric.Sphere x r)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) : 2 • hb.oangle (-x) y = 2 • hb.oangle x y
{α : Type u_1} [UniformSpace α] {s : Set (α × α)} (hs : s ∈ Uniformity α) : ∀ᶠ (t : Set (α × α)) in (Uniformity α).small_sets, CompRel t t ⊆ s
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) : hb.rotation 0 = LinearIsometryEquiv.refl ℝ V
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasStrictTerminalObjects C] {J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ C) [CategoryTheory.Limits.HasLimit F] (i : J) (H : Π (j : J), j ≠ i → CategoryTheory.Limits.IsTerminal (F.obj j)) [Subsingleton (i ⟶ i)] : CategoryTheory.IsIso (CategoryTheory.Limits.limitπ F i)
{G : Type u_1} [Group G] : IsDescendingCentralSeries (lower_central_series G)
{x : Pgame} (h : x ≤ 0) (i : x.left_moves) : (x.move_Left i).move_Right (pgame.right_response h i) ≤ 0
{G : Type u} [Group G] [Fintype G] {N : Subgroup G} [N.normal] (h1 : (Fintype.card ↥N).coprime N.index) (h2 : ∀ (G' : Type u) [_inst_4 : Group G'] [_inst_5 : Fintype G'], Fintype.card G' < Fintype.card G → ∀ {N' : Subgroup G'} [_inst_6 : N'.normal], (Fintype.card ↥N').coprime N'.index → (∃ (H' : Subgroup G'), N'.is_complement' H')) (h3 : ∀ (H : Subgroup G), ¬N.is_complement' H) : N.is_commutative
(𝕜 : Type u_1) [NondiscreteNormedField 𝕜] {E : Type u_2} [SemiNormedGroup E] [NormedSpace 𝕜 E] (s : Set E) : is_IsClosed (WeakDual.Polar 𝕜 s)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {v : ℝ → E → E} {K : Nnreal} (hv : ∀ (t : ℝ), LipschitzWith K (v t)) {f g : ℝ → E} {a b : ℝ} (hF : ContinuousOn f (Set.Icc a b)) (hF' : ∀ (t : ℝ), t ∈ Set.Ico a b → HasDerivWithinAt f (v t (f t)) (Set.Ici t) t) (hg : ContinuousOn g (Set.Icc a b)) (hg' : ∀ (t : ℝ), t ∈ Set.Ico a b → HasDerivWithinAt g (v t (g t)) (Set.Ici t) t) (ha : f a = g a) (t : ℝ) (H : t ∈ Set.Icc a b) : f t = g t
(R : Type u) [Ring R] [StrongRankCondition R] {ι : Type v} : Module.rank R (ι →₀ R) = (Cardinal.mk ι).lift
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f₂ : 𝕜 → F} {n : ℕ} : ContDiff 𝕜 ↑(n + 1) f₂ ↔ Differentiable 𝕜 f₂ ∧ ContDiff 𝕜 ↑n (deriv f₂)
(n : ℕ) (R : Type u_1) [CommRing R] : (Polynomial.cyclotomic n R).is_primitive
{α : Type u} [TopologicalSpace α] {s t : Set α} (hs : is_IsCompact s) (ht : is_IsOpen t) : is_IsCompact (s  t)
(n : ℤ) : ⇑Zmodχ₈ ↑n = Ite (n % 2 = 0) 0 (Ite (n % 8 = 1 ∨ n % 8 = 7) 1 (-1))
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f : ℂ → E} {c : ℂ} {R : Nnreal} (hF : CircleIntegrable f c ↑R) (hR : 0 < R) : HasFpowerSeriesOnBall (λ (w : ℂ), (2 * ↑Real.pi * Complex.i)⁻¹ • ∮ (z : ℂ) in C(c, ↑R), (z - w)⁻¹ • f z) (Cauchy_PowerSeries f c ↑R) c ↑R
{α : Type u_1} {s : Set α} (p : ↥s) : ↑p ∈ s
{L : FirstOrder.Language} {M : Type w} [L.Structure M] {S T : L.substructure M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T
{α : Type u_1} [CircularPreorder α] {a b c : α} : HasSbtw.Sbtw a b c ↔ HasSbtw.Sbtw c a b
{n : ℕ} {i₁ i₂ : Fin (n + 3)} (h : i₁ ≠ i₂) : finset.univ.sum (λ (i : Affine.Simplex.PointsWithCircumcenterIndex (n + 2)), affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter i₁ i₂ i) = 0
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) : Category_theory.topology_of_ClosureOperator J₁.closure_operator _ = J₁
(R : Type u_1) [CommRing R] [is_IsDomain R] : Polynomial.cyclotomic' 1 R = Polynomial.x - 1
{J : Type u₁} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {F : J ⥤ C} [CategoryTheory.Limits.HasColimit F] (c : CategoryTheory.Limits.Cocone F) (j : J) : CategoryTheory.Limits.colimitι F j ≫ CategoryTheory.Limits.colimit.desc F c = c.ι.app j
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) : p.radius = filter.at_top.liminf (λ (n : ℕ), 1 / ↑(∥p n∥₊ ^ (1 / ↑n)))
{R : Type u_1} [CommRing R] (s : Subring R) {ι : Type u_2} {t : Finset ι} {f : ι → R} (h : ∀ (c : ι), c ∈ t → f c ∈ s) : t.prod (λ (i : ι), f i) ∈ s
{n : Type u_3} [Fintype n] {K : Type u_1} [DecidableEq n] [Field K] {M : Matrix n n K} : (∃ (v : n → K) (H : v ≠ 0), M.mul_vec v = 0) ↔ M.det = 0
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} {s t : Set α} (hs : s.finite) (ht : t.finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s ∪ t), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ s ∩ t), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ t), f i))
{α : Type u} [PseudoMetricSpace α] {s : Set α} {x y : α} (h : Emetric.diam s ≠ ⊤) (hx : x ∈ s) (hy : y ∈ s) : HasDist.dist x y ≤ Metric.diam s
{R : Type u_1} [CommRing R] [CharZero R] : Function.Injective (λ (n : ℕ), Polynomial.cyclotomic n R)
{R : Type u} [Semiring R] {ι : Type v} [decι : DecidableEq ι] {M : Type u_1} [AddCommMonoid M] [Module R M] {A : ι → Submodule R M} (h : DirectSum.IsInternal A) : supr A = ⊤
{α : Type u_1} {M : Type u_5} {N : Type u_7} [HasZero M] [CommMonoid N] [DecidableEq α] (f : α →₀ M) (a : α) (b : α → M → N) : f.prod (λ (x : α) (v : M), Ite (x = a) (b x v) 1) = Ite (a ∈ f.support) (b a (⇑f a)) 1
 : subgroup.normal_Closure {⟨equiv.swap 0 4 * equiv.swap 1 3, _⟩} = ⊤
{α : Type u_1} [ConditionallyCompleteLattice α] {s : Set α} {b : α} : s.nonempty → (∀ (a : α), a ∈ s → b ≤ a) → (∀ (w : α), b < w → (∃ (a : α) (H : a ∈ s), a < w)) → HasInf.inf s = b
{α : Type u_1} [DecidableEq α] [Fintype α] : ∅.up_shadow = ∅
{α : Type u} [TopologicalSpace α] {s t : Set α} (hs : is_IsCompact s) (ht : is_IsClosed t) : is_IsCompact (s ∩ t)
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] {n : ℕ} {F : Type u_1} [NormedGroup F] [NormedSpace ℝ F] [PartialOrder F] [MeasureTheory.MeasureSpace F] [BorelSpace F] (eL : F ≃L[ℝ] Fin (n + 1) → ℝ) (hE_Ord : ∀ (x y : F), ⇑eL x ≤ ⇑eL y ↔ x ≤ y) (hE_vol : MeasureTheory.MeasurePreserving ⇑eL MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume) (f : Fin (n + 1) → F → E) (f' : Fin (n + 1) → F → (F →L[ℝ] E)) (s : Set F) (hs : s.countable) (a b : F) (hle : a ≤ b) (Hc : ∀ (i : Fin (n + 1)), ContinuousOn (f i) (Set.Icc a b)) (hD : ∀ (x : F), x ∈ Interior (Set.Icc a b)  s → ∀ (i : Fin (n + 1)), HasFderivAt (f i) (f' i x) x) (DF : F → E) (hDF : ∀ (x : F), DF x = finset.univ.sum (λ (i : Fin (n + 1)), ⇑(f' i x) (⇑(eL.symm) (Pi.single i 1)))) (Hi : MeasureTheory.IntegrableOn DF (Set.Icc a b) MeasureTheory.MeasureSpace.volume) : ∫ (x : F) in Set.Icc a b, DF x = finset.univ.sum (λ (i : Fin (n + 1)), (∫ (x : Fin n → ℝ) in Set.Icc (⇑eL a ∘ ⇑(i.succ_above)) (⇑eL b ∘ ⇑(i.succ_above)), f i (⇑(eL.symm) (i.insert_nth (⇑eL b i) x))) - ∫ (x : Fin n → ℝ) in Set.Icc (⇑eL a ∘ ⇑(i.succ_above)) (⇑eL b ∘ ⇑(i.succ_above)), f i (⇑(eL.symm) (i.insert_nth (⇑eL a i) x)))
{α : Type u_1} [TopologicalSpace α] [BaireSpace α] {s t : Set α} (hs : is_Gδ s) (ht : is_Gδ t) (hsc : Dense s) (htc : Dense t) : Dense (s ∩ t)
{a b : ℝ} (m n : ℕ) : ∫ (x : ℝ) in a..b, Real.sin x ^ (2 * m) * Real.cos x ^ (2 * n) = ∫ (x : ℝ) in a..b, ((1 - Real.cos (2 * x)) / 2) ^ m * ((1 + Real.cos (2 * x)) / 2) ^ n
{R : Type u_1} [Semiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {N' : Type u_5} [AddCommGroup N'] [Module R N'] {ι : Type u_6} [DecidableEq ι] [Fintype ι] (a : AlternatingMap R M N' ι) : ⇑MultilinearMap.alternatization ↑a = (Fintype.card ι).factorial • a
{p : ℕ} : padic_val_Int p 0 = 0
{M : Type u_1} [AddZeroClass M] {c : AddCon M} : ↑0 = 0
{α : Type u} [PseudoMetricSpace α] {s : Set α} {x y : α} {t : Set α} (xs : x ∈ s) (yt : y ∈ t) : Metric.diam (s ∪ t) ≤ Metric.diam s + HasDist.dist x y + Metric.diam t
{α : Type u} {β : Type v} [SemilatticeSup α] {f : α → β} {r : β → β → Prop} (H : ∀ ⦃i j : α⦄, i ≤ j → r (f i) (f j)) : Directed r f
{R : Type u} {ι : Type v} {M₁ : ι → Type w₁} {M₂ : Type w₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [Π (i : ι), Module R (M₁ i)] [Module R M₂] [Π (i : ι), TopologicalSpace (M₁ i)] [TopologicalSpace M₂] (f : ContinuousMultilinearMap R M₁ M₂) {α : ι → Type u_1} [Fintype ι] (g : Π (i : ι), α i → M₁ i) [Π (i : ι), Fintype (α i)] : ⇑f (λ (i : ι), finset.univ.sum (λ (j : α i), g i j)) = finset.univ.sum (λ (r : Π (i : ι), α i), ⇑f (λ (i : ι), g i (r i)))
{α : Type u_1} {β : Type u_2} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] [Nonempty β] [has_One α] {f : β → α} (hF : Continuous f) (h : HasCompactMulSupport f) : ∃ (x : β), ∀ (y : β), f x ≤ f y
{a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd c = 1) : a ∣ b
{α : Type u} [PseudoMetricSpace α] (a : α) : HasNndist.nndist a a = 0
{α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : α → β → γ} {s s' : Set α} {t t' : Set β} (hs : s ⊆ s') (ht : t ⊆ t') : Set.image2 f s t ⊆ Set.image2 f s' t'
{β : Type u} {α : Type v} [CommMonoid β] [DecidableEq α] (s : Finset α) (f : α → β) {a : α} (h : a ∈ s) : (s.erase a).prod (λ (x : α), f x) * f a = s.prod (λ (x : α), f x)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} (x : E) {v : ι → E} (hv : Orthonormal 𝕜 v) : ∑' (i : ι), ∥HasInner.inner (v i) x∥ ^ 2 ≤ ∥x∥ ^ 2
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {s : Set E} (hs₁ : Convex ℝ s) (hs₂ : is_IsClosed s) : (⋂ (l : E →L[ℝ] ℝ), {x : E | ∃ (y : E) (H : y ∈ s), ⇑l x ≤ ⇑l y}) = s
{M : Type u_3} {N : Type u_4} [AddZeroClass M] [AddZeroClass N] (f : M →+ N) {x y : M} (h : x = y) : ⇑f x = ⇑f y
{D : Set ℝ} (hD : Convex ℝ D) (hD₂ : is_IsOpen D) {f : ℝ → ℝ} (hF' : DifferentiableOn ℝ f D) (hF'' : DifferentiableOn ℝ (deriv f) D) (hF''_nonneg : ∀ (x : ℝ), x ∈ D → 0 ≤ deriv^[2] f x) : ConvexOn ℝ D f
(α : Type u_1) [TopologicalSpace α] [TopologicalSpace.SeparableSpace α] [PartialOrder α] : ∃ (s : Set α), s.countable ∧ Dense s ∧ (∀ (x : α), IsBot x → x ∈ s) ∧ ∀ (x : α), IsTop x → x ∈ s
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCancelCommMonoid E] [OrderedAddCommMonoid β] [Module 𝕜 E] [HasScalar 𝕜 β] {s : Set E} {f : E → β} (hF : StrictConvexOn 𝕜 s f) (c : E) : StrictConvexOn 𝕜 ((λ (z : E), c + z) ⁻¹' s) (f ∘ λ (z : E), z + c)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) (f : V ≃ₗᵢ[ℝ] V) : _.oangle x y = hb.oangle (⇑(f.symm) x) (⇑(f.symm) y)
{J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.IsCofiltered J] {F : J ⥤ Profinite} (C : CategoryTheory.Limits.Cone F) (hC : CategoryTheory.Limits.IsLimit C) {α : Type u_1} (f : LocallyConstant ↥(C.X) α) : ∃ (j : J) (g : LocallyConstant ↥(F.obj j) α), f = LocallyConstant.comap ⇑(C.π.app j) g
{R : Type u_1} [CommRing R] (u v w : Fin 3 → R) : matrix.dot_Product u (⇑(⇑CrossProduct v) w) = Matrix.det ![u, v, w]
{T : ℝ} {g : ℝ → ℝ} (hg : Function.Periodic g T) (h_Int : ∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.MeasureSpace.volume t₁ t₂) (h₀ : 0 < ∫ (x : ℝ) in 0..T, g x) (hT : 0 < T) : Filter.Tendsto (λ (t : ℝ), ∫ (x : ℝ) in 0..t, g x) filter.at_IsBot filter.at_IsBot
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) (h : InnerProductGeometry.angle x y = Real.pi / 2) : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [SemiNormedGroup E] [SemiNormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [RingHomIsometric σ₁₂] (x : E) : LipschitzWith ∥x∥₊ (λ (f : E →sl[σ₁₂] F), ⇑f x)
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] (s : Submodule K V) : Module.rank K ↥s ≤ 1 ↔ ∃ (v₀ : V), s ≤ Submodule.span K {v₀}
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {Q : QuadraticForm R M} (l : List M) : ⇑CliffordAlgebra.reverse (List.map ⇑(CliffordAlgebraι Q) l).prod = (List.map ⇑(CliffordAlgebraι Q) l).reverse.prod
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] {p1 : P} (p2 : P) (hp1 : p1 ∈ s) : ↑(⇑(euclidean_geometry.orthogonal_projection s) p2 -ᵥ ⟨p1, hp1⟩) ∈ s.direction
{M₀ : Type u_1} [MulZeroOneClass M₀] (h : 0 = 1) (a : M₀) : a = 0
{𝕂 : Type u_6} [is_R_or_C 𝕂] {E' : Type u_7} [NormedGroup E'] [NormedSpace 𝕂 E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {f : E' → F'} {x : E'} (hF : ContDiffAt 𝕂 1 f x) : ∃ (K : Nnreal) (t : Set E') (H : t ∈ nhds x), LipschitzOnWith K f t
{H : Type u} [TopologicalSpace H] {α : Type u_5} [TopologicalSpace α] (e : LocalHomeomorph α H) (h : e.to_local_equiv.source = Set.Univ) (G : StructureGroupoid H) [ClosedUnderRestriction G] : HasGroupoid α G
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {a l' : α} {s : Set α} (hl' : l' < a) : s ∈ nhds_within a (Set.Iic a) ↔ ∃ (l : α) (H : l ∈ Set.Iio a), Set.Ioc l a ⊆ s
 : Filter.Tendsto Complex.exp (Filter.comap Complex.re filter.at_IsBot) (nhds 0)
(n : ℕ) (x : ℝ) (hx : x ≠ 0) : HasDerivAt (λ (x : ℝ), Polynomial.eval x (Exp_Neg_Inv_glue.P_aux n) * Real.exp (-x⁻¹) / x ^ (2 * n)) (Polynomial.eval x (Exp_Neg_Inv_glue.P_aux (n + 1)) * Real.exp (-x⁻¹) / x ^ (2 * (n + 1))) x
{α : Type u} [PseudoEmetricSpace α] {δ : ℝ} (δ_Pos : 0 < δ) (E : Set α) : Closure E ⊆ Metric.Thickening δ E
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} (h : HasInner.inner x y = 0) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥
(L : List ℕ) : L.tail.sum = L.sum - L.head
{α : Type u_1} {γ : Type u_2} [MeasurableSpace α] [AddMonoid γ] {P : MeasureTheory.SimpleFunc α γ → Prop} (h_ind : ∀ (c : γ) {s : Set α} (hs : MeasurableSet s), P (MeasureTheory.SimpleFunc.piecewise s hs (MeasureTheory.SimpleFunc.const α c) (MeasureTheory.SimpleFunc.const α 0))) (h_Add : ∀ ⦃f g : MeasureTheory.SimpleFunc α γ⦄, Disjoint (Function.Support ⇑f) (Function.Support ⇑g) → P f → P g → P (f + g)) (f : MeasureTheory.SimpleFunc α γ) : P f
{α : Type u_1} [CommMonoid α] {β : Type u_2} [Fintype β] (s : Set β) [DecidablePred (λ (_x : β), _x ∈ s)] (f : β → α) (g : ↥s → α) (w : ∀ (x : β) (h : x ∈ s), f x = g ⟨x, h⟩) (w' : ∀ (x : β), x ∉ s → f x = 1) : finset.univ.prod f = finset.univ.prod g
{α : Type u_1} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {g g' : α → β → γ → δ} {s : Set α} {t : Set β} {u : Set γ} (h : ∀ (a : α) (b : β) (c : γ), g a b c = g' a b c) : Set.image3 g s t u = Set.image3 g' s t u
{α : Type u} {L : List (α × Bool)} {x : α} {b : Bool} : FreeGroup.Red ((x, b) :: L) List.nil ↔ FreeGroup.Red L [(x, !b)]
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (e : LocalHomeomorph α β) {x : β} (h : x ∈ e.to_local_equiv.target) : ContinuousAt ⇑(e.symm) x
{α : Type u_1} {β : Type u_2} [has_Add α] [Preorder α] [Preorder β] {f g : β → α} [CovariantClass α α has_add.add has_le.le] [CovariantClass α α (Function.swap has_add.add) has_le.le] (hF : Monotone f) (hg : Monotone g) : Monotone (λ (x : β), f x + g x)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) {r : ℝ} (hr : r ≠ 0) : 2 • hb.oangle x (r • y) = 2 • hb.oangle x y
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {f : β → γ} (hF : Continuous f) : Continuous (λ (x : α × β), f x.snd)
{α : Type u_1} {β : Type u_2} [UniformSpace α] [UniformSpace β] {s : Set α} {f : α → β} (hs : is_IsCompact s) (hs' : IsSeparated s) (hF : ContinuousOn f s) : UniformContinuousOn f s
 : CategoryTheory.Faithful Compactum_to_CompHaus
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [StrictConvexSpace ℝ E] {x y z : E} {r : ℝ} (hx : x ∈ Metric.ClosedBall z r) (hy : y ∈ Metric.ClosedBall z r) (hne : x ≠ y) : OpenSegment ℝ x y ⊆ Metric.Ball z r
{n m : SimplexCategory} {f : n ⟶ m} : CategoryTheory.Mono f ↔ Function.Injective ⇑(Simplex_category.hom.to_order_hom f)
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {f : R →+* S} {p : Polynomial S} (n : ℕ) (h : p ∈ Polynomial.lifts f) : Polynomial.erase n p ∈ Polynomial.lifts f
{a b c : Prop} : a ∧ b ∨ c ↔ (a ∨ c) ∧ (b ∨ c)
{α : Type u_2} {β : Type u_3} {rα : NonAssocSemiring α} {rβ : NonAssocSemiring β} (f : α →+* β) : 0 = 1 ↔ ∀ (x : α), ⇑f x = 0
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f₂ : 𝕜 → F} {s₂ : Set 𝕜} (hs : UniqueDiffOn 𝕜 s₂) : ContDiffOn 𝕜 ⊤ f₂ s₂ ↔ DifferentiableOn 𝕜 f₂ s₂ ∧ ContDiffOn 𝕜 ⊤ (deriv_within f₂ s₂) s₂
{β : Type u} {α : Type v} [AddCommMonoid β] [DecidableEq α] (s : Finset α) {f : α → β} {a : α} (h : f a = 0) : (s.erase a).sum (λ (x : α), f x) = s.sum (λ (x : α), f x)
{n : ℕ} {E : Type u_1} [NormedGroup E] {f g : (Fin n → ℂ) → E} {c : Fin n → ℂ} {R : Fin n → ℝ} (hF : TorusIntegrable f c R) (hg : TorusIntegrable g c R) : TorusIntegrable (f - g) c R
{R : Type u_1} {A : Type u_2} [AddZeroClass R] [AddZeroClass A] {P : Unitization R A → Prop} (h : ∀ (r : R) (a : A), P (Unitization.inl r + ↑a)) (x : Unitization R A) : P x
{R : Type u_3} {S : Type u_4} {A : Type u_5} [CommRing R] [CommRing S] [CommRing A] [Algebra R S] [Algebra S A] [Algebra R A] [IsScalarTower R S A] (hinj : Function.Injective ⇑(Algebra_Map R S)) (A_alg : Algebra.IsAlgebraic R A) : Algebra.IsAlgebraic S A
{R : Type u} [CommRing R] (S : Submonoid R) (L : Type u) [CommRing L] [Algebra R L] [IsLocalization S L] (hS : S ≤ NonZeroDivisors R) : Cardinal.mk R = Cardinal.mk L
{α : Type u} [UniformSpace α] {s : Set α} {c : Set (Set α)} (hs : is_IsCompact s) (hc₁ : ∀ (t : Set α), t ∈ c → is_IsOpen t) (hc₂ : s ⊆ ⋃₀c) : ∃ (n : Set (α × α)) (H : n ∈ Uniformity α), ∀ (x : α), x ∈ s → (∃ (t : Set α) (H : t ∈ c), ∀ (y : α), (x, y) ∈ n → y ∈ t)
{α : Type u} [Group α] [HasLe α] [CovariantClass α α has_mul.mul has_le.le] {a b c : α} : b ≤ a⁻¹ * c → a * b ≤ c
{R : Type u_1} [CommRing R] {P : Ideal (Polynomial R)} (pB : P ≠ ⊥) (hP : ∀ (x : R), ⇑Polynomial.c x ∈ P → x = 0) : ∃ (p : Polynomial R), p ∈ P ∧ Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.c P)) p ≠ 0
{M : Type u_1} [Monoid M] {x : M} : x ∈ Powers x
{M : Type u_1} [AddCommGroup M] [Module ℝ M] [FiniteDimensional ℝ M] (Q : QuadraticForm ℝ M) (hQ : (⇑QuadraticForm.associated Q).nondegenerate) : ∃ (w : Fin (FiniteDimensional.finrank ℝ M) → ℝ), (∀ (i : Fin (FiniteDimensional.finrank ℝ M)), w i = -1 ∨ w i = 1) ∧ Q.equivalent (quadratic_form.weighted_Sum_squares ℝ w)
{R : Type v} [CommRing R] {A : Matrix (Fin 0) (Fin 0) R} : A.det = 1
{C D : Type u} [CategoryTheory.Category C] [CategoryTheory.Category D] {A : Type w} [CategoryTheory.Category A] [CategoryTheory.Limits.HasLimits A] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {G : C ⥤ D} (hG : CategoryTheory.CoverLifting J K G) (ℱ : CategoryTheory.Sheaf J A) : CategoryTheory.Presheaf.IsSheaf K ((CategoryTheory.ran G.op).obj ℱ.val)
 : (λ (N : ℕ), ↑(⇑roth_number_Nat N)) =O[filter.at_Top] λ (N : ℕ), ↑N
(z : UpperHalfPlane) : ∃ (g : Matrix.SpecialLinearGroup (Fin 2) ℤ), g • z ∈ ModularGroup.Fd
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set ℝ} [Interval_integral.FTC_Filter b (nhds_within b s) (nhds_within b t)] (hmeas : StronglyMeasurableAtFilter f (nhds_within b t) MeasureTheory.MeasureSpace.volume) (hb : Filter.Tendsto f (nhds_within b t ⊓ MeasureTheory.Measure_space.volume.ae) (nhds c)) : HasDerivWithinAt (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) c s b
{R : Type u_1} {G : Type u_2} [CommRing R] [is_IsDomain R] [Group G] [Fintype G] (f : G →* R) (hF : f ≠ 1) : finset.univ.sum (λ (g : G), ⇑f g) = 0
{α : Type u_1} [MeasurableSpace α] [TopologicalSpace α] [OpensMeasurableSpace α] {β : Type u_2} [TopologicalSpace β] [TopologicalSpace.PseudoMetrizableSpace β] [h : SecondCountableTopologyEither α β] {f : α → β} (hF : Continuous f) : MeasureTheory.StronglyMeasurable f
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1
{α : Type u_1} [CancelCommMonoidWithZero α] [UniqueFactorizationMonoid α] [NormalizationMonoid α] [DecidableEq α] {x : α} {n : ℕ} : factorization (x ^ n) = n • factorization x
{a b : Ereal} : -a ≤ b ↔ -b ≤ a
{R : Type u} [Ring R] {M : Type v} [AddCommGroup M] [Module R M] {M₁ : Type v} [AddCommGroup M₁] [Module R M₁] (f : M ≃ₗ[R] M₁) (p : Submodule R M) : Module.rank R ↥(Submodule.map ↑f p) = Module.rank R ↥p
{K : Type u} [hring : CommRing K] [hdomain : is_IsDomain K] {P : Ratfunc K → Prop} (x : Ratfunc K) (f : ∀ (p q : Polynomial K), q ≠ 0 → P (⇑(Algebra_Map (Polynomial K) (Ratfunc K)) p / ⇑(Algebra_Map (Polynomial K) (Ratfunc K)) q)) : P x
{G : Type w} [TopologicalSpace G] [Group G] [TopologicalGroup G] {K V : Set G} (hK : is_IsCompact K) (hV : (Interior V).nonempty) : ∃ (t : Finset G), K ⊆ ⋃ (g : G) (H : g ∈ t), (λ (h : G), g * h) ⁻¹' V
{τ : Type u_1} {α : Type u_2} {β : Type u_3} [TopologicalSpace β] (f : Filter τ) (ϕ : τ → α → β) (s : Set α) [f.ne_IsBot] {c : Set β} (hc₁ : is_IsCompact c) (hc₂ : ∃ (v : Set τ) (H : v ∈ f), Closure (Set.image2 ϕ v s) ⊆ c) (hs : s.nonempty) : (OmegaLimit f ϕ s).nonempty
{α : Type u} {ι : Type x} [PseudoEmetricSpace α] (f : ι → Function.End α) (K : ι → Nnreal) (h : ∀ (i : ι), LipschitzWith (K i) (f i)) (l : List ι) : LipschitzWith (List.map K l).prod (List.map f l).prod
{M : Type u_1} [AddMonoid M] (a : M) (u : AddUnits M) : IsAddUnit (a + ↑u) ↔ IsAddUnit a
{α : Type u_1} [CompleteLattice α] {k : α} (hk : CompleteLattice.IsCompactElement k) {s : Set α} (hemp : s.nonempty) (hdir : DirectedOn has_le.le s) (hbelow : ∀ (x : α), x ∈ s → x < k) : HasSup.sup s < k
{C : Type v} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] {X Y : C} (f g : X ⟶ Y) (w : ∀ (x : ↥X), ⇑f x = ⇑g x) : f = g
{α : Type u_1} {M : Type u_4} [AddCommMonoid M] (f : α → M) {s t : Finset α} (h : s ⊆ t) : s.sum (λ (i : α), f i) = t.sum (λ (i : α), ↑s.indicator f i)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p : ι → P) (i : ι) : ⇑((s.erase i).weighted_vsub_of_point p (p i)) w = ⇑(s.weighted_vsub_of_point p (p i)) w
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) : InnerProductGeometry.angle x y = InnerProductGeometry.angle y x
{α : Type u_1} {β : Type u_2} {r : Setoid α} {f : α → β} (h : setoid.ker f ≤ r) (hF : Function.Surjective f) : r.map f = r.map_of_surjective f h hF
(a : Cardinal) : a < 2 ^ a
{X : Type u_2} [EmetricSpace X] [MeasurableSpace X] [BorelSpace X] {β : Type u_1} {ι : β → Type u_3} [Π (n : β), Encodable (ι n)] (s : Set X) {l : Filter β} (r : β → Ennreal) (hr : Filter.Tendsto r l (nhds 0)) (t : Π (n : β), ι n → Set X) (ht : ∀ᶠ (n : β) in l, ∀ (i : ι n), Emetric.diam (t n i) ≤ r n) (hst : ∀ᶠ (n : β) in l, s ⊆ ⋃ (i : ι n), t n i) (m : Ennreal → Ennreal) : ⇑(measure_theory.measure.mk_metric m) s ≤ l.liminf (λ (n : β), ∑' (i : ι n), m (Emetric.diam (t n i)))
{g : Matrix.SpecialLinearGroup (Fin 2) ℤ} {z : UpperHalfPlane} (hz : z ∈ ModularGroup.Fdo) (hg : g • z ∈ ModularGroup.Fdo) : ↑g 1 0 = 0
{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), AddMonoid (Gs i)] {x : Π (i : η), Gs i} (h : IsOfFinAddOrder x) (i : η) : IsOfFinAddOrder (x i)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} {V₂ : Type u_5} {P₂ : Type u_6} [AddCommGroup V₂] [Module k V₂] [AddTorsor V₂ P₂] {p : ι → P} (hai : AffineIndependent k p) (f : P →ᵃ[k] P₂) (hF : Function.Injective ⇑f) : AffineIndependent k (⇑f ∘ p)
{R : Type u_1} [CommRing R] (v w : Fin 3 → R) : matrix.dot_Product w (⇑(⇑CrossProduct v) w) = 0
{M : Type u_1} [has_Add M] {β : sort u_2} (c : AddCon M) (f : M → β) (h : ∀ (a b : M), ⇑c a b → f a = f b) (x : M) : Add_con.lift_on ↑x f h = f x
 : StrictConvexOn ℝ Set.Univ Real.exp
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] (X : Set (C(α, β) × C(α, β))) : X ∈ Continuous_map.compact_convergence_Uniformity ↔ ∃ (K : Set α) (V : Set (β × β)) (hK : is_IsCompact K) (hV : V ∈ Uniformity β), {fg : C(α, β) × C(α, β) | ∀ (x : α), x ∈ K → (⇑(fg.fst) x, ⇑(fg.snd) x) ∈ V} ⊆ X
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K₁ K₂ : Submodule 𝕜 E} (h : K₁ ≤ K₂) : K₁ᗮᗮ ≤ K₂ᗮᗮ
{ι : Type u_1} {α : Type u_3} [Preorder ι] [LinearOrder α] {u : ι → α} (h : Monotone u) (H : ¬BddAbove (Set.Range u)) : Filter.Tendsto u filter.at_Top filter.at_Top
(p : ℕ) (G : Type u_1) [Group G] [Fact (Nat.Prime p)] [Fintype (Sylow p G)] : Fintype.card (Sylow p G) ≡ 1 [Mod p]
{M : Type u_1} [HasMul M] (c : Con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w * y) (x * z)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {s₁ s₂ : AffineSubspace k P} {p : P} (h₁ : p ∈ s₁) (h₂ : p ∈ s₂) : (s₁ ⊓ s₂).direction = s₁.direction ⊓ s₂.direction
{α : Type u} [AddCommGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] {a b c : α} : a < b + c → a - b < c
{α : Type u_1} {β : Type u_2} [DecidableEq α] [DecidableEq β] (f : α → β) (s : Multiset α) (hF : Set.InjOn f {x : α | x ∈ s}) (x : α) (H : x ∈ s) : Multiset.count (f x) (Multiset.map f s) = Multiset.count x s
 : ⇑LinearEquiv.det complex.conj_lie.to_LinearEquiv = -1
{C : Type u} [CategoryTheory.Category C] {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [CategoryTheory.Limits.HasPullback f g] : CategoryTheory.Limits.HasPullback g f
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} (hx : x ≠ 0) (θ : Real.Angle) : ⇑(o.rotation θ) x = x ↔ θ = 0
{p n : ℕ} : padic_val_Int p ↑n = padic_val_Nat p n
{R : Type u} [Ring R] {M : Type v} [AddCommGroup M] [Module R M] {M' : Type v'} [AddCommGroup M'] [Module R M'] (f : M ≃ₗ[R] M') : (Module.rank R M).lift = (Module.rank R M').lift
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {j₁ j₂ k₁ k₂ : C} (f₁ : j₁ ⟶ k₁) (g₁ : j₁ ⟶ k₂) (f₂ : j₂ ⟶ k₁) (g₂ : j₂ ⟶ k₂) : ∃ (s : C) (α : k₁ ⟶ s) (β : k₂ ⟶ s), f₁ ≫ α = g₁ ≫ β ∧ f₂ ≫ α = g₂ ≫ β
{α : Type u_1} [LinearOrderedField α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a
{C : CategoryTheory.Groupoid} : 𝟭 ↥C = 𝟙 C
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (x : ↥(NonZeroDivisors R)) : 0 < v.int_Valuation_def ↑x
{M : Type u_1} [MulOneClass M] (S : Submonoid M) : S = ⊥ ∨ ∃ (x : M) (H : x ∈ S), x ≠ 1
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} {s : Set α} (h : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) ≠ 1) : ∃ (x : α) (H : x ∈ s), f x ≠ 1
{ι : Type u_1} {α : Type u_2} {s : ι → Set α} (hs : IndexedPartition s) (x : hs.quotient) : hs.proj (⇑(hs.out) x) = x
{α : Type u} [CommGroup α] : IsGroupHom has_inv.inv
{α : Type u} [UniformSpace α] {s : Set α} (h : TotallyBounded s) : TotallyBounded (Closure s)
 : Filter.Tendsto (λ (x : ℝ), x ^ ((-1) / x)) filter.at_Top (nhds 1)
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] [NormalSpace Y] [Nonempty X] (f : BoundedContinuousFunction X ℝ) {e : X → Y} (hE : ClosedEmbedding e) : ∃ (g : BoundedContinuousFunction Y ℝ), (∀ (y : Y), ∃ (x₁ x₂ : X), ⇑g y ∈ Set.Icc (⇑f x₁) (⇑f x₂)) ∧ ⇑g ∘ e = ⇑f
(s : ℝ) : (λ (x : ℝ), Real.exp (-x) * x ^ s) =o[filter.at_Top] λ (x : ℝ), Real.exp (-(1 / 2) * x)
{α : Type u} [TopologicalSpace α] {f : Filter α} : is_IsClosed {x : α | ClusterPt x f}
{α : Type u} [Preorder α] {a b : α} (h : a ≤ b) : ¬b < a
{f : ℕ → ℝ} (hfa : Monotone f) (hF0 : Filter.Tendsto f filter.at_Top (nhds 0)) : ∃ (l : ℝ), Filter.Tendsto (λ (n : ℕ), (Finset.range (n + 1)).sum (λ (i : ℕ), (-1) ^ i * f i)) filter.at_Top (nhds l)
{β : Type u} {α : Type v} {s : Finset α} {a : α} {f : α → β} [AddCommMonoid β] [DecidableEq α] (h : f a = 0) : (HasInsert.insert a s).sum (λ (x : α), f x) = s.sum (λ (x : α), f x)
{α : Type u} [Preorder α] {a : α} {s t p : Set α} (hs : IsGlb s a) (hp : IsGlb p a) (hst : s ⊆ t) (htp : t ⊆ p) : IsGlb t a
{α : Type u_1} {δ : Type u_5} [TopologicalSpace α] [MeasurableSpace α] [BorelSpace α] [MeasurableSpace δ] [CompleteLinearOrder α] [OrderTopology α] [TopologicalSpace.SecondCountableTopology α] {f : ℕ → δ → α} (hF : ∀ (i : ℕ), Measurable (f i)) : Measurable (λ (x : δ), filter.at_top.liminf (λ (i : ℕ), f i x))
{α : Type u} {f g : α → α} {x : α} (hF : Function.IsFixedPt f x) (hg : Function.IsFixedPt g x) : Function.IsFixedPt (f ∘ g) x
(b m : ℕ) (hb : 2 ≤ b) : m ≠ 0 → b ^ (b.digits m).length ≤ b * m
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {f : E → G} {C : ℝ} {s : Set E} {x y : E} (hF : ∀ (x : E), x ∈ s → DifferentiableAt 𝕜 f x) (bound : ∀ (x : E), x ∈ s → ∥fderiv 𝕜 f x∥ ≤ C) (hs : Convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
{f : ℝ → ℝ} {a : ℝ} (h : IsLocalExtr f a) : deriv f a = 0
{G : Type u_1} {H : Type u_2} [Group G] [Group H] [IsCyclic H] (f : G →* H) (hF : f.ker ≤ Subgroup.center G) (a b : G) : a * b = b * a
{α : Type u} [PseudoEmetricSpace α] (δ : ℝ) {E₁ E₂ : Set α} (h : E₁ ⊆ E₂) : Metric.Thickening δ E₁ ⊆ Metric.Thickening δ E₂
{R : Type u₁} {L : Type u₂} {M : Type u₄} [CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M] [IsNoetherian R L] : LieModule.IsNilpotent R L M ↔ ∀ (x : L), IsNilpotent (⇑(lie_module.to_endomorphism R L M) x)
{ι : Type u} {X : Type v} [TopologicalSpace X] [ParacompactSpace X] (u : ι → Set X) (uo : ∀ (a : ι), is_IsOpen (u a)) (uc : (⋃ (i : ι), u i) = Set.Univ) : ∃ (v : ι → Set X), (∀ (a : ι), is_IsOpen (v a)) ∧ (⋃ (i : ι), v i) = Set.Univ ∧ LocallyFinite v ∧ ∀ (a : ι), v a ⊆ u a
(n : ℕ) : LinearIndependent ℚ (λ (ν : Fin (n + 1)), bernstein_Polynomial ℚ n ↑ν)
{M : Type u_1} [AddMonoid M] {ι : sort u_2} {s : ι → Set M} (h : ∀ (y : ι), IsAddSubmonoid (s y)) : IsAddSubmonoid (Set.Inter s)
{α : Type u_1} [CompleteLattice α] {a : α} {s : Set α} : HasInf.inf s ⊔ a ≤ ⨅ (b : α) (H : b ∈ s), b ⊔ a
{M : Type u_3} {N : Type u_4} [has_One M] [has_One N] {f g : OneHom M N} : f = g ↔ ∀ (x : M), ⇑f x = ⇑g x
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (s : AffineSubspace ℝ P) [Nonempty ↥s] [CompleteSpace ↥(s.direction)] (p₁ p₂ : P) : HasDist.dist p₁ (⇑(EuclideanGeometry.reflection s) p₂) = HasDist.dist (⇑(EuclideanGeometry.reflection s) p₁) p₂
{ι : sort u_1} {ι' : sort u_2} {α : Type u_3} [CompleteLattice α] {s : ι → α} (hs : CompleteLattice.Independent s) (f : ι' → ι) (hF : Function.Injective f) : CompleteLattice.Independent (s ∘ f)
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [LinearOrderedField 𝕜] [AddCommGroup E] [LinearOrderedAddCommGroup β] [Module 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f : E → β} (hF : ConcaveOn 𝕜 (⇑(Convex_hull 𝕜) s) f) {x : E} (hx : x ∈ ⇑(Convex_hull 𝕜) s) : ∃ (y : E) (H : y ∈ s), f y ≤ f x
 : Set.Unbounded has_lt.lt {b : Ordinal | b.card.ord = b}
{α : Type u_1} {R : Type u_2} {l : Filter α} {f : α → R} {r : R} [LinearOrderedRing R] [Archimedean R] (hr : r < 0) (hF : Filter.Tendsto f l filter.at_Top) : Filter.Tendsto (λ (x : α), f x * r) l filter.at_IsBot
{z : UpperHalfPlane} (h : ⇑complex.norm_sq ↑z < 1) : z.im < (ModularGroup.s • z).im
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [OrderedSemiring 𝕜] [AddCommGroup E] [Module 𝕜 E] {ι' : Type u_4} (f : ι' ↪ ι) {p : ι → E} (hc : ConvexIndependent 𝕜 p) : ConvexIndependent 𝕜 (p ∘ ⇑f)
{R : Type u_1} {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] (f : ℕ → R) (g : ℕ → M) {m n : ℕ} (hmn : m < n) : (Finset.ico m n).sum (λ (i : ℕ), f i • g i) = f (n - 1) • (Finset.range n).sum (λ (i : ℕ), g i) - f m • (Finset.range m).sum (λ (i : ℕ), g i) - (Finset.ico m (n - 1)).sum (λ (i : ℕ), (f (i + 1) - f i) • (Finset.range (i + 1)).sum (λ (i : ℕ), g i))
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {s t : Set E} (hs₁ : Convex ℝ s) (hs₂ : is_IsCompact s) (ht₁ : Convex ℝ t) (ht₂ : is_IsClosed t) (disj : Disjoint s t) : ∃ (f : E →L[ℝ] ℝ) (u v : ℝ), (∀ (a : E), a ∈ s → ⇑f a < u) ∧ u < v ∧ ∀ (b : E), b ∈ t → v < ⇑f b
{α : Type u} [Group α] [HasLt α] [CovariantClass α α (Function.swap has_mul.mul) has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a
{α : Type u} [TopologicalSpace α] {s : Set α} : Dense (Closure s) ↔ Dense s
{M : Type u_1} {F : Type u_2} [Monoid F] (c : F → M → M) (h1 : c 1 = Id) (hMul : ∀ (f g : F), c (f * g) = c f ∘ c g) (f : F) (n : ℕ) : c (f ^ n) = (c f^[n])
{α : Type u_1} {β : Type u_2} {e e' : LocalEquiv α β} (h : ∀ (x : α), ⇑e x = ⇑e' x) (hsymm : ∀ (x : β), ⇑(e.symm) x = ⇑(e'.symm) x) (hs : e.source = e'.source) : e = e'
{𝕜 : Type u_1} {E : Type u_4} [NormedGroup E] [NondiscreteNormedField 𝕜] [NormedSpace 𝕜 E] [Nontrivial E] : ∥ContinuousLinearMap.id 𝕜 E∥ = 1
{f : ℝ → ℝ} (hF : Differentiable ℝ f) (hF'_Mono : Monotone (deriv f)) : ConvexOn ℝ Set.Univ f
{α : Type u_1} {β : Type u_2} {G₀ : Type u_3} [GroupWithZero G₀] [TopologicalSpace G₀] [HasContinuousInv₀ G₀] [HasContinuousMul G₀] [TopologicalSpace α] [TopologicalSpace β] {f g : α → G₀} (h : α → G₀ → β) (hF : Continuous f) (hg : Continuous g) (hH : ∀ (a : α), g a ≠ 0 → ContinuousAt ↿h (a, f a / g a)) (h2h : ∀ (a : α), g a = 0 → Filter.Tendsto ↿h ((nhds a).prod ⊤) (nhds (h a 0))) : Continuous (λ (x : α), h x (f x / g x))
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] {a : α} : a < 0 → 0 < -a
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {c : ℝ} {f : α → E} {g : α → F} {l : Filter α} : (∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥) → asymptotics.is_O_with c l f g
(p : ℕ) [Fact (Nat.Prime p)] {a : ℤ} (ha0 : ↑a ≠ 0) : zmod.legendre_Sym p a = 1 ↔ IsSquare ↑a
(𝕜 : Type u_1) [NondiscreteNormedField 𝕜] {E : Type u_2} [SemiNormedGroup E] [NormedSpace 𝕜 E] [ProperSpace 𝕜] {s : Set E} (s_nhd : s ∈ nhds 0) : is_IsCompact (WeakDual.Polar 𝕜 s)
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] {f : X → Y} [SequentialSpace X] : Continuous f ↔ SeqContinuous f
{α : Type u} [Preorder α] {a b c : α} (hab : a = b) (hbc : b ≤ c) : a ≤ c
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hD : DiffContOnCl ℂ f (Set.Ioi 0 ×ℂ Set.Iio 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Iio 0)] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hre : ∀ (x : ℝ), 0 ≤ x → ∥f ↑x∥ ≤ C) (him : ∀ (x : ℝ), x ≤ 0 → ∥f (↑x * Complex.i)∥ ≤ C) (hz_re : 0 ≤ z.re) (hz_im : z.im ≤ 0) : ∥f z∥ ≤ C
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ : Real.Angle) : (-o).rotation θ = o.rotation (-θ)
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] : OmegaCompletePartialOrder.Continuous' Coe
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {p : Filter ι} {c : β} : Filter.Tendsto ↿F (p.prod ⊤) (nhds c) ↔ TendstoUniformly F (λ (_x : α), c) p
{α : Type u_1} {r : α → α → Prop} (hi : Irreflexive r) {s : Multiset α} : (∀ (a : α), a ∈ s → Acc (Relation.CutExpand r) {a}) → Acc (Relation.CutExpand r) s
{S : Set Ordinal} (o : Ordinal) : ordinal.enum_Ord S o = HasInf.inf (S ∩ {b : Ordinal | ∀ (c : Ordinal), c < o → ordinal.enum_Ord S c < b})
(n : ℕ) : finset.univ.sum (λ (i : Affine.Simplex.PointsWithCircumcenterIndex n), Affine.Simplex.circumcenter_weights_with_circumcenter n i) = 1
{α : Type u} [PseudoEmetricSpace α] (E : Set α) {δ : ℝ} : Frontier (Metric.Cthickening δ E) ⊆ {x : α | emetric.inf_edist x E = ennreal.of_Real δ}
(f f' : ℝ → ℝ) {a b : ℝ} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hfI : f a = f b) (hff' : ∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivAt f (f' x) x) : ∃ (c : ℝ) (H : c ∈ Set.Ioo a b), f' c = 0
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : E → ℝ} {a : E} {f' : E →L[ℝ] ℝ} (h : is_is_IsLocalMax f a) (hF : HasFderivAt f f' a) : f' = 0
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] {K : Set α} {V : Set (β × β)} (f : C(α, β)) (hV : V ∈ Uniformity β) : ∃ (V' : Set (β × β)) (H : V' ∈ Uniformity β), V' ⊆ V ∧ ∀ (g : C(α, β)), g ∈ ContinuousMap.CompactConvNhd K V' f → ContinuousMap.CompactConvNhd K V' g ⊆ ContinuousMap.CompactConvNhd K V f
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) {X : C} {S : CategoryTheory.Sieve X} (h : J₁.is_IsClosed S) {Y : C} (f : Y ⟶ X) : J₁.covers S f ↔ ⇑S f
 : Real.sin (Real.pi / 3) = Real.sqrt 3 / 2
{X : Compactum} (F : Ultrafilter ↥X) : F.Lim = X.str F
(p : ℕ) (q : ℚ) : padic_norm p (-q) = padic_norm p q
{𝕜 : Type u_1} {E : Type u_3} [OrderedSemiring 𝕜] [TopologicalSpace E] [AddCancelCommMonoid E] [HasContinuousAdd E] [Module 𝕜 E] {s : Set E} (hs : StrictConvex 𝕜 s) (z : E) : StrictConvex 𝕜 ((λ (x : E), z + x) ⁻¹' s)
{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), m ≤ n → P n → P (n + 1)) (n : ℤ) : m ≤ n → P n
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.FinitePresentation R A ↔ ∃ (ι : Type u_2) (_x : Fintype ι) (f : MvPolynomial ι R →ₐ[R] A), Function.Surjective ⇑f ∧ f.to_Ring_hom.ker.fg
{n : ℕ} [Fact (0 < n)] (x : (Zmod n)ˣ) : x ^ n.totient = 1
{γ : Type w} [LinearOrder γ] {a b : γ} {s t : Set γ} (ha : IsLeast s a) (hb : IsLeast t b) : IsLeast (s ∪ t) (Linear_order.min a b)
{R : Type u_1} {M : Type u_3} [MonoidWithZero R] [HasZero M] [MulActionWithZero R M] : ¬IsSmulRegular M 0 ↔ Nontrivial M
{R : Type u_4} [LinearOrderedCommRing R] (a b : R) : 2 * a * b ≤ a ^ 2 + b ^ 2
{α : Type u} [TopologicalSpace α] : TotallyDisconnectedSpace α ↔ ∀ (x : α), ConnectedComponent x = {x}
{E : Type u_4} {F : Type u_5} [NormedGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E] [NormedGroup F] [NormedSpace ℝ F] [FiniteDimensional ℝ F] {f : E → F} (h : ContDiff ℝ 1 f) (hEF : FiniteDimensional.finrank ℝ E < FiniteDimensional.finrank ℝ F) : Dense (Set.Range f)ᶜ
{F : Type u_2} [NormedGroup F] [NormedSpace ℝ F] {x y : F} (hx : x ≠ 0) (hy : y ≠ 0) : SameRay ℝ x y → ∥x∥⁻¹ • x = ∥y∥⁻¹ • y
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] (p : P) : p ∉ ⊥
{m : Type u} {n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] [Fintype m] [DecidableEq m] (A : Matrix m n α) (B : Matrix n m α) : (A.mul B + 1).det = (B.mul A + 1).det
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) : K ⊓ Kᗮ = ⊥
{α : Type u} {β : Type v} [AddGroup α] [AddGroup β] {f : α → β} (hF : IsAddGroupHom f) : f 0 = 0
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {f : α → β} (hF' : DenseRange f) (hF : Continuous f) {s : Set α} (hs : Dense s) {t : Set β} (ht : Set.MapsTo f s t) : Dense t
(M N : ℕ) : ⇑roth_number_Nat (M + N) ≤ ⇑roth_number_Nat M + ⇑roth_number_Nat N
{E : Type u_4} [NormedGroup E] [NormedSpace ℝ E] {b : ℝ} {f : ℕ → ℝ} {z : ℕ → E} (hfa : Antitone f) (hF0 : Filter.Tendsto f filter.at_Top (nhds 0)) (hzb : ∀ (n : ℕ), ∥(Finset.range n).sum (λ (i : ℕ), z i)∥ ≤ b) : CauchySeq (λ (n : ℕ), (Finset.range (n + 1)).sum (λ (i : ℕ), f i • z i))
{α : Type u} [PseudoEmetricSpace α] {s t : Set α} (h : s ⊆ t) : Emetric.diam s ≤ Emetric.diam t
(m : ℤ) : ConvexOn ℝ (Set.Ioi 0) (λ (x : ℝ), x ^ m)
{α : Type u_1} [AddSemigroup α] [PartialOrder α] [CovariantClass α α has_add.add has_lt.lt] [CovariantClass α α (Function.swap has_add.add) has_le.le] [ContravariantClass α α has_add.add has_le.le] [ContravariantClass α α (Function.swap has_add.add) has_le.le] {a b c d : α} (hac : a ≤ c) (hbd : b ≤ d) : a + b = c + d ↔ a = c ∧ b = d
{α : Type u} [PseudoMetricSpace α] {s t : Set α} (h : (s ∩ t).nonempty) : Metric.diam (s ∪ t) ≤ Metric.diam s + Metric.diam t
{α : Type u_1} [CommMonoid α] (f : ℕ → α) (n : ℕ) : finset.univ.prod (λ (i : Fin n), f ↑i) = (Finset.range n).prod (λ (i : ℕ), f i)
(K : Type u_1) (L : Type u_2) [Field K] [Field L] [Algebra K L] [Finite : FiniteDimensional K L] : Algebra.IsAlgebraic K L
(α : Type u_1) [Fintype α] {R : Type u_2} [CommSemiring R] (a b : R) : finset.univ.sum (λ (s : Finset α), a ^ s.card * b ^ (Fintype.card α - s.card)) = (a + b) ^ Fintype.card α
(n k : ℕ) : (n ^ k).factorization = k • n.factorization
{α : Type u} {L₁ L₂ : List (α × Bool)} [DecidableEq α] (H : FreeGroup.reduce L₁ = FreeGroup.reduce L₂) : FreeGroup.mk L₁ = FreeGroup.mk L₂
{M : Type u_3} [Monoid M] [Inhabited M] (l : List M) (h : l ≠ List.nil) : l.head * l.tail.prod = l.prod
{α : Type u} [Preorder α] {f : ℕ → α} (hF : Monotone f) (n : ℕ) {x : α} (h1 : f n < x) (h2 : x < f (n + 1)) (a : ℕ) : f a ≠ x
{M : Type u_1} {N : Type u_2} [MulOneClass M] [MulOneClass N] (h : M ≃* N) : ⇑h 1 = 1
(R : Type u_1) [CommRing R] [is_IsDomain R] : Polynomial.cyclotomic' 0 R = 1
{α : Type u} {l : List α} (hn : l.nodup) : l.cyclic_permutations.nodup
{𝕂 : Type u_1} [is_R_or_C 𝕂] : HasStrictDerivAt (Exp 𝕂) 1 0
{α : Type u_1} {s : Finset α} {f : α → Ennreal} : s.sum (λ (a : α), f a) < ⊤ ↔ ∀ (a : α), a ∈ s → f a < ⊤
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} {V₂ : Type u_5} {P₂ : Type u_6} [AddCommGroup V₂] [Module k V₂] [AddTorsor V₂ P₂] {p : ι → P} (f : P →ᵃ[k] P₂) (hF : Function.Injective ⇑f) : AffineIndependent k (⇑f ∘ p) ↔ AffineIndependent k p
{x : ℝ} (hx : Liouville x) (p : ℝ) : LiouvilleWith p x
{n : Type u_1} {𝕜 : Type u_3} [Field 𝕜] [DecidableEq n] [Fintype n] (M : Matrix n n 𝕜) : ∃ (L L' : List (Matrix.TransvectionStruct n 𝕜)) (D : n → 𝕜), M = ((List.map matrix.transvection_struct.to_Matrix L).prod.mul (Matrix.diagonal D)).mul (List.map matrix.transvection_struct.to_Matrix L').prod
(K : Type u) (V : Type v) [DivisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] : ↑(FiniteDimensional.finrank K V) = Module.rank K V
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{α : Type u_1} {β : Type u_2} {f : α → β} {r : Setoid β} : setoid.comap f r = setoid.ker (Quotient.mk ∘ f)
(x : ℝ) : Summable (λ (n : ℕ), x ^ n / ↑(n.factorial))
{α : Type u} [PseudoMetricSpace α] (s : Set α) : UniformContinuous (λ (x : α), metric.inf_nndist x s)
{R : Type u_1} {M : Type u_2} [CommSemiring R] [AddCommMonoid M] [Module R M] : Submodule.torsion R ↥(Submodule.torsion R M) = ⊤
{ι : Type u} {α : Type v} [DecidableEq α] (t : ι → Finset α) : (∀ (s : Finset ι), s.card ≤ (s.bUnion t).card) ↔ ∃ (f : ι → α), Function.Injective f ∧ ∀ (x : ι), f x ∈ t x
{n : ℕ} (A B : Finset (Fin n)) : (Finset.image (λ (i : Fin n), ↑i) A).to_colex ≤ (Finset.image (λ (i : Fin n), ↑i) B).to_colex ↔ A.to_colex ≤ B.to_colex
{F : Type u_3} [Field F] [Fintype F] (hF : Ring_Char F ≠ 2) (a : Fˣ) : IsSquare a ↔ a ^ (Fintype.card F / 2) = 1
{G : Type u} {y : G} [Monoid G] {x : G} (h : Commute x y) (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) : IsOfFinOrder (x * y)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (hb : Filter.Tendsto f (nhds b ⊓ MeasureTheory.Measure_space.volume.ae) (nhds c)) : HasDerivAt (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) c b
{M : Type u} [DivInvMonoid M] (x : M) (z : ℤ) : MulOpposite.op (x ^ z) = MulOpposite.op x ^ z
{X Y : Type u} (f : X ⟶ Y) : CategoryTheory.Epi f ↔ Function.Surjective f
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} (n : ℕ) (hs : is_IsOpen s) : Set.EqOn (iterated_fderiv_within 𝕜 n f s) (iterated_fderiv 𝕜 n f) s
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) [CategoryTheory.Limits.HasLimits C] {i : D.to_glue_data.J} (U : TopologicalSpace.Opens ↥((D.to_glue_data.U i).carrier)) : ∃ (Eq1 : Opposite.op U = Opposite.op ((TopologicalSpace.Opens.map (CategoryTheory.Limits.colimitι D.to_glue_data.diagram.multispan (Opposite.unop (Opposite.op (CategoryTheory.Limits.WalkingMultispan.right i)))).base).obj (_.functor.obj U))), D.ι_Inv_App U ≫ D.diagram_over_IsOpen_π U i = (D.to_glue_data.U i).presheaf.map (Category_theory.eq_to_hom Eq1)
{α : Type u} {β : Type v} [Preorder β] {f : α → β} {s : Set α} {a : α} : IsMinOn f s a → IsMaxOn (⇑order_dual.to_dual ∘ f) s a
{L : FirstOrder.Language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] {Q : Type u_2} [L.Structure Q] (f : L.equiv M N) (g : L.equiv N P) (h : L.equiv P Q) : (h.comp g).comp f = h.comp (g.comp f)
{f : ℂ → ℂ} {c : ℂ} {R₁ R₂ : ℝ} (hD : DifferentiableOn ℂ f (Metric.Ball c R₁)) (h_maps : Set.MapsTo f (Metric.Ball c R₁) (Metric.Ball (f c) R₂)) (h₀ : 0 < R₁) : Complex.abs (deriv f c) ≤ R₂ / R₁
(n : ℕ+) (K : Type w) (L : Type z) [Field K] [Field L] [Algebra K L] [NeZero ↑↑n] [IsCyclotomicExtension {n} K L] : Polynomial.IsSplittingField K L (Polynomial.x ^ ↑n - 1)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {n : WithTop ℕ} {p : E → FormalMultilinearSeries 𝕜 E F} (h : HasFtaylorSeriesUpTo n f p) (hn : 1 ≤ n) (x : E) : HasFderivAt f (⇑(Continuous_multilinear_Curry_Fin1 𝕜 E F) (p x 1)) x
{n : ℕ} : n.factorization.support = n.factors.to_Finset
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (𝕜 : Type u_3) [Field 𝕜] [IsAlgClosed 𝕜] [CategoryTheory.Linear 𝕜 C] [CategoryTheory.Limits.HasKernels C] (X Y : C) [FiniteDimensional 𝕜 (X ⟶ X)] [CategoryTheory.Simple X] [CategoryTheory.Simple Y] : FiniteDimensional.finrank 𝕜 (X ⟶ Y) ≤ 1
(a : Zmod4) : ⇑Zmodχ₄ a = 0 ∨ ⇑Zmodχ₄ a = 1 ∨ ⇑Zmodχ₄ a = -1
{α : Type u} (r : α → α → Prop) [IsAntisymm α r] {a b : α} : r a b → r b a → a = b
{R : Type u₁} [CommSemiring R] (a b : R) : (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2
(n : ℕ) (R : Type u_1) [CommRing R] [is_IsDomain R] : (Polynomial.cyclotomic' n R).monic
(R : Type u_1) {M : Type u_4} (S : Type u_7) [Semiring R] [AddCommMonoid M] [Module R M] (s : Set M) [Semiring S] [HasScalar R S] [Module S M] [IsScalarTower R S M] : Submodule.span S ↑(Submodule.span R s) = Submodule.span S s
{K : Type u_8} {V : Type u_11} [Field K] [AddCommGroup V] [Module K V] {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.is_IsOrtho x x) : IsCompl (Submodule.span K {x}) ((Submodule.span K {x}).orthogonal_bilin B)
{R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [TopologicalSpace M] [TopologicalSpace M₂] [Semiring R] [AddCommMonoid M₂] [Module R M₂] [AddCommMonoid M] [Module R M] (f : M →L[R] M₂) (h : ¬∃ (e' : M ≃L[R] M₂), ↑e' = f) : f.inverse = 0
(p : ℕ) [Fact (Nat.Prime p)] (a : ℤ) : zmod.legendre_Sym p a = zmod.legendre_Sym p (a % ↑p)
(R : Type u₁) {L : Type u₂} [CommRing R] [LieRing L] [LieAlgebra R L] {A : Type u₃} [Ring A] [Algebra R A] {g₁ g₂ : UniversalEnvelopingAlgebra R L →ₐ[R] A} (h : ↑g₁.comp (UniversalEnvelopingAlgebraι R) = ↑g₂.comp (UniversalEnvelopingAlgebraι R)) : g₁ = g₂
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {f g : 𝕜 → 𝕜} {f' a : 𝕜} (hg : ContinuousAt g a) (hF : HasStrictDerivAt f f' (g a)) (hF' : f' ≠ 0) (hfg : ∀ᶠ (y : 𝕜) in nhds a, f (g y) = y) : HasStrictDerivAt g f'⁻¹ a
(K : Type u) [DivisionRing K] : FiniteDimensional.finrank K K = 1
{X : Type u_2} [EmetricSpace X] [MeasurableSpace X] [BorelSpace X] {d₁ d₂ : ℝ} (h : d₁ < d₂) (s : Set X) : ⇑(measure_theory.measure.hausdorff_measure d₂) s = 0 ∨ ⇑(measure_theory.measure.hausdorff_measure d₁) s = ⊤
{F : Type u_3} [InnerProductSpace ℝ F] {x : F} {r : ℝ} (hx : x ≠ 0) (hr : 0 < r) : HasInner.inner x (r • x) / (∥x∥ * ∥r • x∥) = 1
{R : Type u₁} [LinearOrderedRing R] {a : R} (H : -1 ≤ a) (n : ℕ) : 1 + ↑n * (a - 1) ≤ a ^ n
{α : Type u} {β : Type v} [AddZeroClass α] [AddGroup β] {f : α → β} (hF : IsAddHom f) : IsAddMonoidHom f
{α : Type u_1} {β : Type u_2} [HasMem α β] {s : β} {a b : α} : a ∈ s → b ∉ s → a ≠ b
{α : Type u} [Preorder α] {f : ℕ → α} (hF : Antitone f) (n : ℕ) {x : α} (h1 : f (n + 1) < x) (h2 : x < f n) (a : ℕ) : f a ≠ x
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) : CategoryTheory.Presieve.IsSheaf J₁ (Category_theory.functor.closed_sieves J₁)
(p : ℕ) {R : Type u_1} {S : Type u_2} [hp : Fact (Nat.Prime p)] [CommRing R] [CommRing S] (f : R →+* S) (r : R) : ⇑(WittVector.map f) (⇑(WittVector.teichmuller p) r) = ⇑(WittVector.teichmuller p) (⇑f r)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p₂ : ι → P) (p₁ : P) (h : s.sum (λ (i : ι), w i) = 1) : s.sum (λ (i : ι), w i • (p₁ -ᵥ p₂ i)) = p₁ -ᵥ ⇑(s.affine_combination p₂) w
{r n : ℕ} (h : r < n / 2) : n.choose r ≤ n.choose (r + 1)
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} [Nontrivial k] {p1 : P} {p : ι → P} : p1 ∈ affine_Span k (Set.Range p) ↔ ∃ (s : Finset ι) (w : ι → k) (hw : s.sum (λ (i : ι), w i) = 1), p1 = ⇑(s.affine_combination p) w
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {f : E → F} {x : E} {n : WithTop ℕ} (g : F →L[𝕜] G) (hF : ContDiffAt 𝕜 n f x) : ContDiffAt 𝕜 n (⇑g ∘ f) x
{α : Type u_1} [DecidableEq α] {s t : Finset α} (h : s ⊆ t) : (Finset.ioo s t).card = 2 ^ (t.card - s.card) - 2
{R : Type u} [Ring R] [RankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {ι : Type u_1} [Fintype ι] (b : Basis ι R M) {w : Set M} [Fintype ↥w] (s : Submodule.span R w = ⊤) : Fintype.card ι ≤ Fintype.card ↥w
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {f : E → G} (hF : ContDiff 𝕜 n f) : ContDiff 𝕜 n (λ (x : E × F), f x.fst)
{K : Type u_1} [LinearOrderedField K] [FloorRing K] {v : K} : (generalized_continued_fraction.int_fract_pair.seq1 v).fst = GeneralizedContinuedFraction.IntFractPair.of v
{α : Type u_1} [DecidableEq α] (s : Finset α) : (Finset.image Quotient.mk s.diag).card = s.card
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {n : ℕ} : iterated_fderiv_within 𝕜 (n + 1) f s = ⇑(Continuous_multilinear_Curry_Left_Equiv 𝕜 (λ (i : Fin (n + 1)), E) F) ∘ fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n f s) s
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b c : α} : a < c - b → a + b < c
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {S : Submodule K V} (h : FiniteDimensional.finrank K ↥S = FiniteDimensional.finrank K V) : S = ⊤
{C : Type u₁} [CategoryTheory.Category C] {X : C} (P : Cᵒᵖ ⥤ Type w) : CategoryTheory.Presieve.IsSheafFor P ⇑⊤
{α : Type uu} (a : α) {l₁ l₂ : List α} : l₁ <+~ l₂ → a :: l₁ <+~ a :: l₂
{α : Type u_1} {ι : sort u_3} [ConditionallyCompleteLattice α] [Nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), c ≤ f x) : c ≤ infi f
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) (hF : CategoryTheory.IsEquivalence F) : Category_theory.is_equivalence.of_iso (CategoryTheory.Iso.refl F) hF = hF
{α : Type u_1} : HasStar.star 1 = 1
(𝕜 : Type v) [is_R_or_C 𝕜] {E : Type u} [NormedGroup E] [NormedSpace 𝕜 E] (x : E) (h : x ≠ 0) : ∃ (g : E →L[𝕜] 𝕜), ∥g∥ = 1 ∧ ⇑g x = ↑∥x∥
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {j j' : C} (f f' : j ⟶ j') : Category_theory.is_cofiltered.eq_hom f f' ≫ f = Category_theory.is_cofiltered.eq_hom f f' ≫ f'
{p x : ℝ} {r : ℚ} (hr : r ≠ 0) : LiouvilleWith p (x * ↑r) ↔ LiouvilleWith p x
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (w : ι → k) (p : ι → P) {s₁ s₂ : Finset ι} (h : s₁ ⊆ s₂) : ⇑(s₁.affine_combination p) w = ⇑(s₂.affine_combination p) (↑s₁.indicator w)
{R₁ : Type u_3} {A : Type u_5} {B : Type u_6} [CommSemiring R₁] [CommRing A] [CommRing B] [Algebra R₁ A] [Algebra R₁ B] (f : A →ₐ[R₁] B) : Function.Injective ⇑(ideal.ker_Lift_alg f)
{L : FirstOrder.Language} {M : Type u_3} [L.Structure M] : FirstOrder.Language.Structure.Fg L M ↔ ∃ (S : Set M), S.finite ∧ ⇑(FirstOrder.Language.Substructure.closure L) S = ⊤
{α : Type u_1} [CommSemiring α] (E : LinearRecurrence α) (u v : ℕ → α) (hu : E.is_solution u) (hv : E.is_solution v) : u = v ↔ Set.EqOn u v ↑(Finset.range E.order)
 : Filter.Tendsto Real.exp filter.at_Top filter.at_Top
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f f₁ : E → F} {x : E} {n : ℕ} (hs : UniqueDiffOn 𝕜 s) (hL : ∀ (y : E), y ∈ s → f₁ y = f y) (hx : x ∈ s) : iterated_fderiv_within 𝕜 n f₁ s x = iterated_fderiv_within 𝕜 n f s x
{α : Type u_1} [TopologicalSpace α] {s : Set α} {γ : Type u_4} [LinearOrderedAddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] [HasContinuousAdd γ] {f g : α → γ} (hF : UpperSemicontinuousOn f s) (hg : UpperSemicontinuousOn g s) : UpperSemicontinuousOn (λ (z : α), f z + g z) s
{α : Type u_1} {r : α → α → Prop} (hi : Irreflexive r) {a : α} (hacc : Acc r a) : Acc (Relation.CutExpand r) {a}
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p ∈ s) : AffineSubspace.mk' p s.direction = s
{ι : Type u_1} {V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasZeroMorphisms V] {c : ComplexShape ι} [CategoryTheory.Limits.HasZeroObject V] [CategoryTheory.Limits.HasKernels V] [CategoryTheory.Limits.HasImages V] (C : HomologicalComplex V c) (i : ι) (h : C.boundaries i ≤ C.cycles i) : (C.boundaries i).of_LE (C.cycles i) h = C.boundaries_to_cycles i
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : HasInner.inner x y = ↑∥x∥ * ↑∥y∥ ↔ ↑∥y∥ • x = ↑∥x∥ • y
{α : Type u} {R : α → α → Prop} {l₁ l₂ l₃ : List α} (h₁ : List.Chain' R (l₁ ++ l₂)) (h₂ : List.Chain' R (l₂ ++ l₃)) (hn : l₂ ≠ List.nil) : List.Chain' R (l₁ ++ l₂ ++ l₃)
{M : Type u_1} [AddCommGroup M] [Module ℂ M] [FiniteDimensional ℂ M] (Q : QuadraticForm ℂ M) (hQ : (⇑QuadraticForm.associated Q).nondegenerate) : Q.equivalent (quadratic_form.weighted_Sum_squares ℂ 1)
{M : Type u_1} [AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [AddCommMonoid N] (f : S.localization_Map N) (x : M) (y : ↥S) : ∃ (c : ↥S), x + ↑((f.sec (f.mk' x y)).snd) + ↑c = (f.sec (f.mk' x y)).fst + ↑y + ↑c
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) (i : Fin (n + 1)) : s.points i = ⇑(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.point_weights_with_circumcenter i)
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] (v : V) (h : ∀ (w : V), ∃ (c : K), c • v = w) : FiniteDimensional.finrank K V ≤ 1
{β : Type u} {α : Type v} {s : Finset α} {a : α} {f : α → β} [CommMonoid β] [DecidableEq α] (h : a ∉ s → f a = 1) : (HasInsert.insert a s).prod (λ (x : α), f x) = s.prod (λ (x : α), f x)
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [SemiNormedGroup E] [SemiNormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →sl[σ₁₂] F) : Isometry ⇑f ↔ ∀ (x : E), ∥⇑f x∥ = ∥x∥
(ι : Type u_1) {R : Type u_2} {α : Type u_3} [AddMonoid ι] [Monoid R] (l : List α) (fι : α → ι) (fA : α → R) : l.dprod fι fA = (List.map fA l).prod
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] : Algebra.FiniteType R A ↔ ∃ (ι : Type u_2) (_x : Fintype ι) (f : MvPolynomial ι R →ₐ[R] A), Function.Surjective ⇑f
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {f : α → β} (hF : ClosedEmbedding f) {K : Set β} (hK : is_IsCompact K) : is_IsCompact (f ⁻¹' K)
{M₀ : Type u_1} {M₀' : Type u_3} [MulZeroOneClass M₀] [Nontrivial M₀] [HasZero M₀'] [has_One M₀'] (f : M₀' → M₀) (Zero : f 0 = 0) (One : f 1 = 1) : Nontrivial M₀'
{α : Type u_2} {G₀ : Type u_4} [TopologicalSpace α] [GroupWithZero G₀] [MulAction G₀ α] [HasContinuousConstSmul G₀ α] {c : G₀} (hc : c ≠ 0) : IsClosedMap (λ (x : α), c • x)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} {s : Affine.Simplex ℝ P n} {p p₁ p₂ : P} {r : ℝ} (hp₁ : p₁ ∈ affine_Span ℝ (HasInsert.insert p (Set.Range s.points))) (hp₂ : p₂ ∈ affine_Span ℝ (HasInsert.insert p (Set.Range s.points))) (h₁ : ∀ (i : Fin (n + 1)), HasDist.dist (s.points i) p₁ = r) (h₂ : ∀ (i : Fin (n + 1)), HasDist.dist (s.points i) p₂ = r) : p₁ = p₂ ∨ p₁ = ⇑(EuclideanGeometry.reflection (affine_Span ℝ (Set.Range s.points))) p₂
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {ι : Type u_2} {E : ι → Type u_5} [DecidableEq ι] [Fintype ι] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] : IsBoundedBilinearMap 𝕜 (λ (p : (F →L[𝕜] G) × ContinuousMultilinearMap 𝕜 E F), p.fst.comp_ContinuousMultilinearMap p.snd)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} {ps : Set P} (h : ps ⊆ ↑s) [Nonempty ↥s] [FiniteDimensional ℝ ↥(s.direction)] : EuclideanGeometry.Cospherical ps ↔ ∃ (Center : P) (H : Center ∈ s) (radius : ℝ), ∀ (p : P), p ∈ ps → HasDist.dist p Center = radius
{𝕂 : Type u_1} {𝔸 : Type u_2} [is_R_or_C 𝕂] [NormedCommRing 𝔸] [NormedAlgebra 𝕂 𝔸] [CompleteSpace 𝔸] {x : 𝔸} : HasFderivAt (Exp 𝕂) (Exp 𝕂 x • 1) x
{β : Type u_4} [LinearOrder β] [NoMinOrder β] {u : ℕ → β} (hu : Filter.Tendsto u filter.at_Top filter.at_IsBot) : ∃ᶠ (n : ℕ) in filter.at_Top, ∀ (k : ℕ), k < n → u n < u k
{m : Type u} {α : Type v} [CommRing α] [Fintype m] [DecidableEq m] {M : Matrix m m α} (h : IsUnit M) (N : Matrix m m α) : ((M.mul N).mul M⁻¹).det = N.det
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] [NormalSpace Y] (f : BoundedContinuousFunction X ℝ) (e : C(X, Y)) (hE : ClosedEmbedding ⇑e) : ∃ (g : BoundedContinuousFunction Y ℝ), ∥g∥ = ∥f∥ ∧ g.comp_Continuous e = f
{α : Type u_1} [Semigroup α] [PartialOrder α] [CovariantClass α α has_mul.mul has_lt.lt] [CovariantClass α α (Function.swap has_mul.mul) has_le.le] [ContravariantClass α α has_mul.mul has_le.le] [ContravariantClass α α (Function.swap has_mul.mul) has_le.le] {a b c d : α} (hac : a ≤ c) (hbd : b ≤ d) : a * b = c * d ↔ a = c ∧ b = d
{M : Type u_1} [HasMul M] {c d : Con M} : Setoid.r = Setoid.r ⊓ Setoid.r
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {n : ℕ} : ContDiffOn 𝕜 ↑(n + 1) f s ↔ ∀ (x : E), x ∈ s → (∃ (u : Set E) (H : u ∈ nhds_within x (HasInsert.insert x s)) (f' : E → (E →L[𝕜] F)), (∀ (x : E), x ∈ u → HasFderivWithinAt f (f' x) u x) ∧ ContDiffOn 𝕜 ↑n f' u)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} {s : Set E} : MdifferentiableOn (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s → DifferentiableOn 𝕜 f s
{α : Type u} (p : α → Prop) [DecidablePred p] (xs : List α) (h : ∀ (x : α), x ∈ xs → ¬p x) (Sep : α) (hsep : p Sep) (as : List α) : list.split_on_p p (xs ++ Sep :: as) = xs :: list.split_on_p p as
{α : Type u_1} [CommMonoid α] {a b : α} {u : αˣ} : a ∣ ↑u * b ↔ a ∣ b
{α : Type u_1} [CircularPreorder α] {a b c : α} (h : HasSbtw.Sbtw a b c) : HasBtw.Btw a b c
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) : s.circumcenter = ⇑(finset.univ.affine_combination s.points_with_circumcenter) (Affine.Simplex.circumcenter_weights_with_circumcenter n)
(R : Type u_1) {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] [IsNoetherianRing R] {A : Set M} (hA : A.finite) : IsNoetherian R ↥(Submodule.span R A)
{α : Type u_1} [Preorder α] {a b : α} (h : a ≤ b) : Set.Ioi b ⊆ Set.Ici a
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] (s : Set α) : finsum (λ (i : α), finsum (λ (H : i ∈ s), 0)) = 0
{𝕂 : Type u_1} {𝔸 : Type u_2} [NondiscreteNormedField 𝕂] [NormedRing 𝔸] [NormedAlgebra 𝕂 𝔸] [CompleteSpace 𝔸] (h : 0 < (Exp_series 𝕂 𝔸).radius) : HasStrictFderivAt (Exp 𝕂) 1 0
{β : Type u} {α : Type v} {γ : Type w} [CommMonoid β] {s : Finset α} {t : Finset γ} {f : α → β} {g : γ → β} (i : Π (a : α), a ∈ s → γ) (hi : ∀ (a : α) (ha : a ∈ s), i a ha ∈ t) (h : ∀ (a : α) (ha : a ∈ s), f a = g (i a ha)) (i_inj : ∀ (a₁ a₂ : α) (ha₁ : a₁ ∈ s) (ha₂ : a₂ ∈ s), i a₁ ha₁ = i a₂ ha₂ → a₁ = a₂) (i_surj : ∀ (b : γ), b ∈ t → (∃ (a : α) (ha : a ∈ s), b = i a ha)) : s.prod (λ (x : α), f x) = t.prod (λ (x : γ), g x)
(X : AlgebraicGeometry.LocallyRingedSpace (r : ↥(AlgebraicGeometry.LocallyRingedSpaceΓ.obj (Opposite.op X))) : IsUnit (⇑(X.to_toΓ_spec_Map_basic_IsOpen r) r)
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {f : M →+ P} (x : M) : ⇑(AddCon.ker_Lift f) ↑x = ⇑f x
{n : Type u_1} {p : Type u_2} {𝕜 : Type u_3} [Field 𝕜] [DecidableEq n] [DecidableEq p] [Fintype n] [Fintype p] (M : Matrix p p 𝕜) (e : p ≃ n) (H : ∃ (L L' : List (Matrix.TransvectionStruct n 𝕜)) (D : n → 𝕜), ((List.map matrix.transvection_struct.to_Matrix L).prod.mul (⇑(Matrix.reindex_AlgEquiv 𝕜 e) M)).mul (List.map matrix.transvection_struct.to_Matrix L').prod = Matrix.diagonal D) : ∃ (L L' : List (Matrix.TransvectionStruct p 𝕜)) (D : p → 𝕜), ((List.map matrix.transvection_struct.to_Matrix L).prod.mul M).mul (List.map matrix.transvection_struct.to_Matrix L').prod = Matrix.diagonal D
{C : Type u} [CategoryTheory.Category C] {X Y : AlgebraicGeometry.PresheafedSpace C} (f : X ⟶ Y) [CategoryTheory.IsIso f.base] [CategoryTheory.IsIso f.c] : CategoryTheory.IsIso f
(f : StieltjesFunction) {a b : ℝ} {c d : ℕ → ℝ} (ss : Set.Icc a b ⊆ ⋃ (i : ℕ), Set.Ioo (c i) (d i)) : ennreal.of_Real (⇑f b - ⇑f a) ≤ ∑' (i : ℕ), ennreal.of_Real (⇑f (d i) - ⇑f (c i))
(F : Type u_1) [Field F] [Fintype F] {a : F} (ha : a ≠ 0) : ∃ (b : F), ⇑(Algebra.trace (Zmod(Ring_Char F)) F) (a * b) ≠ 0
{R : Type u} [OrderedCommRing R] [StarOrderedRing R] [Algebra ℝ R] [OrderedSmul ℝ R] (A₀ A₁ B₀ B₁ : R) (T : is_CHSH_tuple A₀ A₁ B₀ B₁) : A₀ * B₀ + A₀ * B₁ + A₁ * B₀ - A₁ * B₁ ≤ 2
{α : Type u} [TopologicalSpace α] {s : Set α} : IsIrreducible s ↔ ∀ (U : Finset (Set α)), (∀ (u : Set α), u ∈ U → is_IsOpen u) → (∀ (u : Set α), u ∈ U → (s ∩ u).nonempty) → (s ∩ ⋂₀ ↑U).nonempty
{G : Type u} {x : G} [Fintype G] [Group G] [DecidableEq G] : Finset.image (λ (i : ℕ), x ^ i) (Finset.range (order_of x)) = ↑(Subgroup.zpowers x).to_Finset
{M : Type u_1} [AddZeroClass M] {s : Set M} {p : M → Prop} {x : M} (h : x ∈ AddSubmonoid.closure s) (Hs : ∀ (x : M), x ∈ s → p x) (H1 : p 0) (hMul : ∀ (x y : M), p x → p y → p (x + y)) : p x
{α : Type u_1} {f : α → α} {x y : α} {n : ℕ} (hx : Function.IsPeriodicPt f n x) (hy : Function.IsPeriodicPt f n y) (hn : 0 < n) (h : f x = f y) : x = y
(G : Type u_1) [CommGroup G] : comm_monoid.torsion G = (torsion G).to_Submonoid
(α : Type u_1) [CompleteLattice α] : CompleteLattice.IsSupClosedCompact α → CompleteLattice.IsSupFiniteCompact α
{α : Type u} {β : Type v} [CommMonoid β] (s : Finset α) (f : Finset α → β) : s.powerset.prod (λ (t : Finset α), f t) = (Finset.range (s.card + 1)).prod (λ (j : ℕ), (finset.powerset_len j s).prod (λ (t : Finset α), f t))
{α : Type u} {L₁ L₂ : List (α × Bool)} [DecidableEq α] (H : FreeGroup.Red (FreeGroup.reduce L₁) L₂) : FreeGroup.reduce L₁ = L₂
{Y : Type u_2} [TopologicalSpace Y] [NormalSpace Y] {s : Set Y} (f : C(↥s, ℝ)) (hs : is_IsClosed s) : ∃ (g : C(Y, ℝ)), ContinuousMap.restrict s g = f
{α : Type u_1} {M : Type u_5} {N : Type u_7} [HasZero M] [AddCommMonoid N] (f : α →₀ M) (y : α) (g : α → M → N) (hyf : y ∈ f.support) : g y (⇑f y) + (Finsupp.erase y f).sum g = f.sum g
(cf cg : Nat.Partrec.Code) (a : ℕ) : (cf.prec cg).eval (Nat.mkpair a 0) = cf.eval a
{α : Type u_2} {β : Type u_3} [NonAssocRing α] [NonAssocRing β] (f : α →+* β) (x : α) : ⇑f (-x) = -⇑f x
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {J : Type w} [CategoryTheory.Category J] (K : J ⥤ C) (F : C ⥤ D) [CategoryTheory.Limits.HasColimit (K ⋙ F)] [CategoryTheory.CreatesColimit K F] : CategoryTheory.Limits.HasColimit K
{a b : ℝ} : ∫ (x : ℝ) in a..b, Real.sin x * Real.cos x = (Real.cos a ^ 2 - Real.cos b ^ 2) / 2
{𝕜 : Type u} [NondiscreteNormedField 𝕜] (f : LocalHomeomorph 𝕜 𝕜) {a f' : 𝕜} (ha : a ∈ f.to_local_equiv.target) (hF' : f' ≠ 0) (htff' : HasStrictDerivAt ⇑f f' (⇑(f.symm) a)) : HasStrictDerivAt ⇑(f.symm) f'⁻¹ a
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] [CompleteSpace E] (e : E ≃ₗ[𝕜] F) (h : Continuous ⇑e) : Continuous ⇑(e.symm)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {f f' : ℝ → E} {C : ℝ} (hF : ∀ (x : ℝ), x ∈ Set.Icc 0 1 → HasDerivWithinAt f (f' x) (Set.Icc 0 1) x) (bound : ∀ (x : ℝ), x ∈ Set.Ico 0 1 → ∥f' x∥ ≤ C) : ∥f 1 - f 0∥ ≤ C
{n : ℕ} [Fact (0 < n)] : Fintype.card (QuaternionGroup n) = 4 * n
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (s : Set P) : s ⊆ ↑(affine_Span k s)
{n : WithTop ℕ} {𝕂 : Type u_6} [is_R_or_C 𝕂] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] {f : 𝕂 → F'} {f' : F'} {x : 𝕂} (hF : ContDiffAt 𝕂 n f x) (hF' : HasDerivAt f f' x) (hn : 1 ≤ n) : HasStrictDerivAt f f' x
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x y + o.oangle y z = o.oangle x z
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup V1] [Module k V1] [AddTorsor V1 P1] [AddCommGroup V2] [Module k V2] [AddTorsor V2 P2] (f : P1 → P2) (Linear : V1 →ₗ[k] V2) (Add : ∀ (p : P1) (v : V1), f (v +ᵥ p) = ⇑Linear v +ᵥ f p) : ⇑{ToFun := f, Linear := Linear, Map_vadd' := Add} = f
{α : Type u} [PseudoEmetricSpace α] {x y : α} {s : Set α} (h : y ∈ s) : emetric.inf_edist x s ≤ HasEdist.edist x y
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {𝕜₃ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [NormedGroup E] [NormedGroup F] [NormedGroup G] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NondiscreteNormedField 𝕜₃] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] [NormedSpace 𝕜₃ G] {σ₁₂ : 𝕜 →+* 𝕜₂} {σ₂₃ : 𝕜₂ →+* 𝕜₃} {σ₁₃ : 𝕜 →+* 𝕜₃} [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] [RingHomIsometric σ₁₂] (f : F →ₛₗᵢ[σ₂₃] G) {g : E →sl[σ₁₂] F} : ∥f.to_Continuous_Linear_map.comp g∥ = ∥g∥
{p : ℕ} [hp_Prime : Fact (Nat.Prime p)] (z : ℤ_[p]) : z - ↑(⇑padic_int.to_Zmod z) ∈ local_ring.maximal_Ideal ℤ_[p]
{R : Type u_2} {M : Type u_3} [AddCommGroup M] [Ring R] [Module R M] [htwo : Invertible 2] {B : BilinForm R M} (hB₁ : B ≠ 0) (hB₂ : B.is_Symm) : ∃ (x : M), ¬B.is_IsOrtho x x
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [FiniteDimensional 𝕜 E] {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) {ι : Type u_4} [Fintype ι] [DecidableEq ι] {V : ι → Submodule 𝕜 E} (hV : DirectSum.IsInternal V) (a : Fin n) : ⇑(direct_sum.is_internal.subordinate_Orthonormal_Basis hn hV) a ∈ V (direct_sum.is_internal.subordinate_Orthonormal_Basis_Index hn hV a)
{α : Type u_1} [CompleteLattice α] [IsModularLattice α] [IsCompactlyGenerated α] [IsAtomistic α] : IsComplemented α
{α : Type u} {β : Type v} [EmetricSpace α] [CompleteSpace α] [EmetricSpace β] {f : α → β} (hF : Isometry f) : ClosedEmbedding f
{C : Type u} [CategoryTheory.Category C] (B : C) : CategoryTheory.Limits.HasTerminal (CategoryTheory.Over B)
{α : Type u_1} {β : Type u_2} {f : α →. β ⊕ α} (a : α) {b : β} (hb : Sum.inl b ∈ f a) : b ∈ f.fix a
(M : Type u_1) {α : Type u_6} [Monoid M] [MulAction M α] : HasScalar.smul 1 = Id
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasZeroObject C] {X : C} (h : ¬CategoryTheory.Limits.IsZero X) : Nontrivial (CategoryTheory.Subobject X)
{α : Type u} {β : Type v} [LinearOrderedField α] [TopologicalSpace α] [OrderTopology α] {l : Filter β} {f g : β → α} {C : α} (hC : 0 < C) (hF : Filter.Tendsto f l (nhds C)) (hg : Filter.Tendsto g l filter.at_Top) : Filter.Tendsto (λ (x : β), f x * g x) l filter.at_Top
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] (f : X → Y) (h : ∀ (x : X), ∃ (e : LocalHomeomorph X Y), x ∈ e.to_local_equiv.source ∧ ∀ (x : X), x ∈ e.to_local_equiv.source → f x = ⇑e x) : IsLocallyHomeomorph f
{X : Type u_2} [EmetricSpace X] [MeasurableSpace X] [BorelSpace X] (m : Ennreal → Ennreal) (s : Set X) : ⇑(measure_theory.measure.mk_metric m) s = ⨆ (r : Ennreal) (hr : 0 < r), ⨅ (t : ℕ → Set X) (h : s ⊆ Set.Union t) (h' : ∀ (n : ℕ), Emetric.diam (t n) ≤ r), ∑' (n : ℕ), ⨆ (h : (t n).nonempty), m (Emetric.diam (t n))
{G : Type u_1} [CommMonoid G] (tG : monoid.is_torsion G) : comm_monoid.torsion G = ⊤
(X : Type u_2) [TopologicalSpace X] [RegularSpace X] [TopologicalSpace.SecondCountableTopology X] : ∃ (f : X → BoundedContinuousFunction ℕ ℝ), Embedding f
{T : Type u₁} [CategoryTheory.Category T] {X : T} {f g : CategoryTheory.Over X} (k : f ⟶ g) [hk : CategoryTheory.Epi k.left] : CategoryTheory.Epi k
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) {r : ℝ} (hr : 0 < r) : hb.oangle (r • x) y = hb.oangle x y
{P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → z ≤ b) (Hinh : ∃ (z : ℤ), P z) : ∃ (ub : ℤ), P ub ∧ ∀ (z : ℤ), P z → z ≤ ub
(R : Type u_1) [Ring R] : Polynomial.cyclotomic 0 R = 1
{α : Type u_1} (r : α → α → Prop) : EqvGen.setoid (EqvGen.setoid r).rel = EqvGen.setoid r
{K : Type u} [Field K] (s : Subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (p1 p2 p3 : P) : HasDist.dist p1 p3 * HasDist.dist p1 p3 = HasDist.dist p1 p2 * HasDist.dist p1 p2 + HasDist.dist p3 p2 * HasDist.dist p3 p2 - 2 * HasDist.dist p1 p2 * HasDist.dist p3 p2 * Real.cos (EuclideanGeometry.angle p1 p2 p3)
{α : Type u_2} {β : Type u_3} [DecidableEq β] [HasScalar α β] {u : Finset β} {s : Set α} {t : Set β} : ↑u ⊆ s • t → (∃ (s' : Finset α) (t' : Finset β), ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' • t')
{α : Type u} [TopologicalSpace α] {s : Set α} : IsIrreducible s ↔ ∀ (Z : Finset (Set α)), (∀ (z : Set α), z ∈ Z → is_IsClosed z) → s ⊆ ⋃₀↑Z → (∃ (z : Set α) (H : z ∈ Z), s ⊆ z)
{G : Type u_1} [DivInvMonoid G] (a b : G) : a / b = a * b⁻¹
{α : Type u_1} {s t : Multiset α} : s ≤ t → s ⊆ t
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] {f : Filter α} {a : α} [f.ne_IsBot] (h : f ≤ nhds a) : f.Liminf = a
{α : Type u} [TopologicalSpace α] {f : ℝ → α} {c : ℝ} (hp : Function.Periodic f c) (hc : c ≠ 0) (hF : Continuous f) : is_IsCompact (Set.Range f)
(R : Type u_1) [CommRing R] (m n : ℕ) : Polynomial.Chebyshev.t R (m * n) = (Polynomial.Chebyshev.t R m).comp (Polynomial.Chebyshev.t R n)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasTerminal C] : CategoryTheory.Limits.HasZeroObject C
{α : Type u} [LinearOrderedField α] [TopologicalSpace α] [OrderTopology α] {n : ℕ} (hn : 1 ≤ n) : Filter.Tendsto (λ (x : α), x ^ -↑n) filter.at_Top (nhds 0)
{α : Type u_1} {n : Type u_3} {m : Type u_4} {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α} {D : Matrix n n α} : (matrix.from_blocks A B C D).is_Symm ↔ A.is_Symm ∧ B.transpose = C ∧ C.transpose = B ∧ D.is_Symm
{F : Type u_3} [Field F] [Fintype F] (hF : Ring_Char F ≠ 2) {a : F} (ha : a ≠ 0) : a ^ (Fintype.card F / 2) = 1 ∨ a ^ (Fintype.card F / 2) = -1
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} {v : ι → E} (hz : ∀ (i : ι), v i ≠ 0) (ho : ∀ (i j : ι), i ≠ j → HasInner.inner (v i) (v j) = 0) : LinearIndependent 𝕜 v
{R : Type u_1} [MulZeroClass R] [nR : Nontrivial R] : ¬IsLeftRegular 0
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (G : C ⥤ D) [CategoryTheory.ReflectsIsomorphisms G] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.HasLimits D] [CategoryTheory.Limits.PreservesLimits G] {X : Top} (F : Top.Presheaf C X) : F.is_sheaf ↔ Top.Presheaf.IsSheaf (F ⋙ G)
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {f : α → E} {g : α → F} {l : Filter α} : f =o[l] g → ∀ ⦃c : ℝ⦄, 0 < c → (∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥)
{R : Type u} {S : Type u_1} [Ring R] [Ring S] [IsPrincipalIdealRing R] (f : R →+* S) (hF : Function.Surjective ⇑f) : IsPrincipalIdealRing S
{C : Type u₁} [CategoryTheory.Category C] {X Y : C} (f : X ⟶ Y) [CategoryTheory.SplitMono f] [CategoryTheory.Epi f] : CategoryTheory.IsIso f
{G : Type u_10} [Group G] (a : G) : ⇑(Equiv.symm (equiv.mul_Right a)) = λ (x : G), x * a⁻¹
(α : Type u) [TopologicalSpace α] [TopologicalSpace.SecondCountableTopology α] [RegularSpace α] : NormalSpace α
{α : Type u} [PseudoMetricSpace α] {s t : Set α} {r : ℝ} (hr : 0 ≤ r) (H1 : ∀ (x : α), x ∈ s → (∃ (y : α) (H : y ∈ t), HasDist.dist x y ≤ r)) (H2 : ∀ (x : α), x ∈ t → (∃ (y : α) (H : y ∈ s), HasDist.dist x y ≤ r)) : metric.Hausdorff_dist s t ≤ r
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : Set P} (ho : EuclideanGeometry.OrthocentricSystem s) : ∃ (r : ℝ), ∀ (t : Affine.Triangle ℝ P), Set.Range t.points ⊆ s → Affine.Simplex.circumradius t = r
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMinOrder α] {a : α} {s : Set α} : s ∈ nhds_within a (Set.Iic a) ↔ ∃ (l : α) (H : l ∈ Set.Iio a), Set.Ioc l a ⊆ s
{R : Type u} {L : Type v} [CommRing R] [LieRing L] [LieAlgebra R L] : Subsingleton (LieIdeal R ↥⊥)
{L : FirstOrder.Language} {M : Type w} [L.Structure M] {S : L.substructure M} {s : Set M} : ⇑(FirstOrder.Language.Substructure.closure L) s ≤ S ↔ s ⊆ ↑S
{G : Type u_1} [CommGroup G] (K : Subgroup G) (g : Multiset G) : (∀ (a : G), a ∈ g → a ∈ K) → g.prod ∈ K
(G : Type u_1) [AddMonoid G] : ¬Add_monoid.is_torsion G ↔ ∃ (g : G), ¬IsOfFinAddOrder g
{n : ℕ} {α : Type u_1} [Preorder α] {f : Fin (n + 1) → α} : Monotone f ↔ ∀ (i : Fin n), f (⇑fin.cast_Succ i) ≤ f i.succ
{k : Type u_1} {V : Type u_2} [Ring k] [AddCommGroup V] [Module k V] {ι : Type u_3} (s : Finset ι) {w : ι → k} {p : ι → V} (hw : s.sum w = 0) : ⇑(s.weighted_vsub p) w = s.sum (λ (i : ι), w i • p i)
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} [Nontrivial k] (p : ι → P) (j : ι) (q : P) : q ∈ affine_Span k (Set.Range p) ↔ ∃ (s : Finset ι) (w : ι → k), q = ⇑(s.weighted_vsub_of_point p (p j)) w +ᵥ p j
{α : Type u} [TopologicalSpace α] {Z : Set α} (h : is_IsClopen Z) : (⋃ (x : α) (H : x ∈ Z), ConnectedComponent x) = Z
{K : Type u_1} [Field K] [Invertible 2] {a b c : K} (ha : a ≠ 0) (h : discrim a b c = 0) (x : K) : a * x * x + b * x + c = 0 ↔ x = -b / (2 * a)
{F : Type v} [NormedGroup F] [NormedSpace ℂ F] {c : ℂ} {R C : ℝ} {f : ℂ → F} (hR : 0 < R) (hD : DiffContOnCl ℂ f (Metric.Ball c R)) (hC : ∀ (z : ℂ), z ∈ Metric.Sphere c R → ∥f z∥ ≤ C) : ∥deriv f c∥ ≤ C / R
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) (i : Fin (n + 1)) : HasDist.dist s.circumcenter (s.points i) = s.circumradius
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] (g : G) (p1 p2 : P) : g +ᵥ p1 -ᵥ p2 = g + (p1 -ᵥ p2)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (h : p 1 = ⇑((Continuous_multilinear_Curry_Fin1 𝕜 E F).symm) ↑i) (h0 : p 0 = 0) : p.comp (p.right_Inv i) = FormalMultilinearSeries.id 𝕜 F
 : ⇑LinearEquiv.det complex.conj_ae.to_LinearEquiv = -1
(p q n : ℕ) [Fact (Nat.Prime p)] (hq : q ≠ 0) : padic_val_Nat p (q ^ n) = n * padic_val_Nat p q
{m : Type u} {n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) (B : Matrix n m α) [Invertible A] : A.mul ((⅟ A).mul B) = B
{α : Type u} [Lattice α] [CommGroup α] (a : α) (h : 1 ≤ a) : a⁺ = a
{K : Type u_1} [LinearOrderedField K] {v : K} [FloorRing K] (terminates : (GeneralizedContinuedFraction.of v).terminates) : ∀ᶠ (n : ℕ) in filter.at_Top, v = (GeneralizedContinuedFraction.of v).convergents n
{G : Type u_10} [Group G] (a : G) : ⇑(Equiv.symm (equiv.mul_Left a)) = has_mul.mul a⁻¹
{B : Type u_3} {S : B} {M : Type u_1} [CommMonoid M] [SetLike B M] [SubmonoidClass B M] (m : Multiset M) (hm : ∀ (a : M), a ∈ m → a ∈ S) : m.prod ∈ S
{Γ₀ : Type u_1} [LinearOrderedCommGroupWithZero Γ₀] : (nhds 0).has_Basis (λ (_x : Γ₀ˣ), True) (λ (γ₀ : Γ₀ˣ), {γ : Γ₀ | γ < ↑γ₀})
(x : ℂ) : HasStrictDerivAt Complex.sinh (Complex.cosh x) x
{K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {f g : V →ₗ[K] V} : f.comp g = LinearMap.id ↔ g.comp f = LinearMap.id
{n : ℕ} (R : Type u_1) [CommRing R] [is_IsDomain R] : ⇑(Algebra_Map (Polynomial R) (Ratfunc R)) (Polynomial.cyclotomic n R) = n.divisors_antidiagonal.prod (λ (i : ℕ × ℕ), ⇑(Algebra_Map (Polynomial R) (Ratfunc R)) (Polynomial.x ^ i.snd - 1) ^ ⇑Nat.ArithmeticFunction.moebius i.fst)
{C : Type u} [CategoryTheory.Category C] {P Q : C} (f : P ⟶ Q) [CategoryTheory.Epi f] [CategoryTheory.StrongMono f] : CategoryTheory.IsIso f
{P : Type u_1} [SemilatticeSup P] {x y : P} {s : Order.Ideal P} (hx : x ∈ s) (hy : y ∈ s) : x ⊔ y ∈ s
{α : Type u_1} [LinearOrder α] {r : α} {s : Finset α} : s.to_colex < {r}.to_colex ↔ ∀ (x : α), x ∈ s → x < r
{α : Type u_1} {β : Type u_2} {e : LocalEquiv α β} {s : Set α} {t : Set β} : e.source ∩ ⇑e ⁻¹' t = e.source ∩ s → e.is_image s t
{α : Type u} [PseudoMetricSpace α] {s t : Set α} : metric.Hausdorff_dist s t = metric.Hausdorff_dist t s
{C : Type u} [CategoryTheory.Category C] (X : C) : CategoryTheory.Presieve.IsSheaf (Category_theory.sheaf.canonical_topology C) (Category_theory.yoneda.obj X)
{α : Type u_1} {β : Type u_2} [AddGroup α] [SubtractionMonoid β] (f : α →+ β) (g h : α) : ⇑f (g + -h) = ⇑f g + -⇑f h
{G : Type u} [CategoryTheory.Groupoid G] [IsFreeGroupoid G] (T : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))) [Quiver.Arborescence ↥T] {a b : IsFreeGroupoid.Generators G} (e : a ⟶ b) (H : e ∈ Quiver.WideSubquiverSymmetrify T a b) : is_free_groupoid.spanning_tree.loop_of_hom T (IsFreeGroupoid.of e) = 𝟙 (root' T)
{α : Type u} {ι : Type x} [PseudoMetricSpace α] [Fintype ι] {f : α → ι → ℝ} {s : Set α} {K : Nnreal} (hF : LipschitzOnWith K f s) : ∃ (g : α → ι → ℝ), LipschitzWith K g ∧ Set.EqOn f g s
(f : ↥(MeasureTheory.lp ℂ 2 haar_Circle)) : ∑' (i : ℤ), ∥⇑(⇑(fourier_series.repr) f) i∥ ^ 2 = ∫ (t : ↥Circle), ∥⇑f t∥ ^ 2 ∂haar_Circle
{M : Type u_1} [HasMul M] (c : Con M) : con.mul_Ker Coe _ = c
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] {f : C(α, β)} {ι : Type u₃} {p : Filter ι} {F : ι → C(α, β)} (h : TendstoLocallyUniformly (λ (i : ι) (a : α), ⇑(F i) a) ⇑f p) : Filter.Tendsto F p (nhds f)
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : Rˣ) : (λ (t : R), Ring.inverse (↑x + t)) =O[nhds 0] λ (t : R), 1
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] (v : M) {r : R} (h : 0 < r) : SameRay R (r • v) v
(C : Type u₁) [CategoryTheory.Category C] (D : Type u₂) [CategoryTheory.Category D] (X : C) (Y : D) : 𝟙 (X, Y) = (𝟙 X, 𝟙 Y)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} (l : ι →₀ 𝕜) (v : ι → E) (x : E) : HasInner.inner (l.sum (λ (i : ι) (a : 𝕜), a • v i)) x = l.sum (λ (i : ι) (a : 𝕜), ⇑(StarRing_end 𝕜) a • HasInner.inner (v i) x)
(n : ℕ) : Ring_Char (Zmod n) = n
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] {s : Set α} (hs : IsPreconnected s) : s ∈ {Set.Icc (HasInf.inf s) (HasSup.sup s), Set.Ico (HasInf.inf s) (HasSup.sup s), Set.Ioc (HasInf.inf s) (HasSup.sup s), Set.Ioo (HasInf.inf s) (HasSup.sup s), Set.Ici (HasInf.inf s), Set.Ioi (HasInf.inf s), Set.Iic (HasSup.sup s), Set.Iio (HasSup.sup s), Set.Univ, ∅}
{α : Type u_1} {s : Finset α} {f : α → Ennreal} (hF : ∀ (a : α), a ∈ s → f a ≠ ⊤) : (s.sum (λ (a : α), f a)).to_Nnreal = s.sum (λ (a : α), (f a).to_Nnreal)
{α : Type u_1} [TopologicalSpace α] [BaireSpace α] {p : α → Prop} : (∀ᶠ (x : α) in residual α, p x) ↔ ∃ (t : Set α), is_Gδ t ∧ Dense t ∧ ∀ (x : α), x ∈ t → p x
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : ℕ} {i j : Fin (n + 2)} (H : i ≤ j) : X.δ j.succ ≫ X.δ i = X.δ (⇑fin.cast_Succ i) ≫ X.δ j
{G : Type u_1} [Group G] (N H : Subgroup G) [N.normal] : ↑(N ⊔ H) = ↑N * ↑H
{α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {f : Filter β} {u : β → α} {s : Set α} (hs : Dense s) (H : ∀ (a : α), a ∈ s → ∀ (b : α), b ∈ s → a < b → ¬((∃ᶠ (n : β) in f, u n < a) ∧ ∃ᶠ (n : β) in f, b < u n)) (h : Filter.IsBoundedUnder has_le.le f u . "is_bounded_Default") (h' : Filter.IsBoundedUnder GE f u . "is_bounded_Default") : ∃ (c : α), Filter.Tendsto u f (nhds c)
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : α → β} {s : Set α} : StrictAntiOn f s → StrictMonoOn (⇑order_dual.to_dual ∘ f) s
{R : Type u_1} [Ring R] (s : Subring R) {ι : Type u_2} {t : Finset ι} {f : ι → R} (h : ∀ (c : ι), c ∈ t → f c ∈ s) : t.sum (λ (i : ι), f i) ∈ s
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {m : MeasurableSpace α} [TopologicalSpace β] [TopologicalSpace.PseudoMetrizableSpace β] [TopologicalSpace γ] [TopologicalSpace.PseudoMetrizableSpace γ] {g : β → γ} {f : α → β} (hg : Embedding g) : MeasureTheory.StronglyMeasurable (λ (x : α), g (f x)) ↔ MeasureTheory.StronglyMeasurable f
{K : Type u_4} {L : Type u_5} [Field K] [Field L] [Algebra K L] (x : K) : ⇑(Algebra.norm K) (⇑(Algebra_Map K L) x) = x ^ FiniteDimensional.finrank K L
{n m : ℕ} (h : Fin n = Fin m) : cast h = ⇑(fin.cast _)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) : ⇑is_R_or_C.im (HasInner.inner x y) = (∥x - is_R_or_C.I • y∥ * ∥x - is_R_or_C.I • y∥ - ∥x + is_R_or_C.I • y∥ * ∥x + is_R_or_C.I • y∥) / 4
(n b : ℕ) : (n + 1) / (b + 2) < n + 1
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {f : α → β} (connected_fibers : ∀ (t : β), IsConnected (f ⁻¹' {t})) (hcl : ∀ (T : Set β), is_IsClosed T ↔ is_IsClosed (f ⁻¹' T)) (t : β) : IsConnected (f ⁻¹' ConnectedComponent t)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} [CharZero k] {s : Finset ι} (p : ι → P) (h : s.card ≠ 0) : Finset.centroid k s p ∈ affine_Span k (Set.Range p)
{R : Type u_1} {M : Type u_4} {S : Type u_7} [Semiring R] [AddCommMonoid M] [Module R M] (p : Submodule R M) [Semiring S] [HasScalar S R] [Module S M] [IsScalarTower S R M] : Submodule.span S ↑p = submodule.restrict_scalars S p
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) {l : List L} : (∀ (x : L), x ∈ l → x ∈ S) → l.sum ∈ S
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) : InnerProductGeometry.angle (-x) (-y) = InnerProductGeometry.angle x y
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R : CategoryTheory.Presieve X} : (CategoryTheory.Presieve.IsSeparatedFor P R ∧ ∀ (x : CategoryTheory.Presieve.FamilyOfElements P R), x.compatible → (∃ (t : P.obj (Opposite.op X)), x.is_amalgamation t)) ↔ CategoryTheory.Presieve.IsSheafFor P R
{β : Type u_2} [DecidableEq β] (s : Finset β) (b : β) : Finset.filter (Eq b) s = Ite (b ∈ s) {b} ∅
{G : Type u_1} [AddCommGroup G] (B : AddGroupFilterBasis G) : UniformAddGroup G
{f g : ℝ → ℝ} {a b : ℝ} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hgc : ContinuousOn g (Set.Icc a b)) (hle : ∀ (x : ℝ), x ∈ Set.Ioc a b → f x ≤ g x) (hlt : ∃ (c : ℝ) (H : c ∈ Set.Icc a b), f c < g c) : ∫ (x : ℝ) in a..b, f x < ∫ (x : ℝ) in a..b, g x
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {c : Con M} (f g : c.quotient →* P) (h : ∀ (a : M), ⇑f ↑a = ⇑g ↑a) : f = g
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] (p : P) : ↑s ∩ ↑(AffineSubspace.mk' p (s.direction)ᗮ) = {↑(⇑(euclidean_geometry.orthogonal_projection s) p)}
{α : Type u_1} {β : Type u_2} [EmetricSpace α] [PseudoEmetricSpace β] {f : α → β} (h : AntilipschitzWith 0 f) : Subsingleton α
{R : Type u_1} {a : R} [Semigroup R] (b : R) (ha : IsRightRegular a) : IsRightRegular (b * a) ↔ IsRightRegular b
{α : Type u} [UniformSpace α] {s : Set α} {ι : sort u_1} {c : ι → Set α} (hs : is_IsCompact s) (hc₁ : ∀ (i : ι), is_IsOpen (c i)) (hc₂ : s ⊆ ⋃ (i : ι), c i) : ∃ (n : Set (α × α)) (H : n ∈ Uniformity α), ∀ (x : α), x ∈ s → (∃ (i : ι), {y : α | (x, y) ∈ n} ⊆ c i)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y : V} (θ : Real.Angle) : hb.oangle x y = θ ↔ (x ≠ 0 ∧ y ≠ 0 ∧ ∃ (r : ℝ), 0 < r ∧ y = r • ⇑(hb.rotation θ) x) ∨ θ = 0 ∧ (x = 0 ∨ y = 0)
(n : ℕ) [Fact (0 < n)] [Fintype (Zmod n)ˣ] : Fintype.card (Zmod n)ˣ = n.totient
(K : Type u_1) (L : Type u_2) [Field K] [Field L] [Algebra K L] : FiniteDimensional K ↥⊥
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : ∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * ⇑is_R_or_C.re (HasInner.inner x y) + ∥y∥ ^ 2
{α : Type u_1} [GeneralizedBooleanAlgebra α] (u v : α) : Set.InjOn (λ (x : α), (x ⊔ u)  v) {x : α | Disjoint u x ∧ v ≤ x}
{β : Type u_4} [LinearOrder β] [NoMaxOrder β] {u : ℕ → β} (hu : Filter.Tendsto u filter.at_Top filter.at_Top) (N : ℕ) : ∃ (n : ℕ) (H : n ≥ N), ∀ (k : ℕ), k < n → u k < u n
{R : Type u_1} [CommRing R] [Top : TopologicalSpace R] [TopologicalRing R] {J : Ideal R} : IsAdic J ↔ (∀ (n : ℕ), is_IsOpen ↑(J ^ n)) ∧ ∀ (s : Set R), s ∈ nhds 0 → (∃ (n : ℕ), ↑(J ^ n) ⊆ s)
{X : Type u_2} [EmetricSpace X] [MeasurableSpace X] [BorelSpace X] {d₁ d₂ : ℝ} (h : d₁ ≤ d₂) (s : Set X) : ⇑(measure_theory.measure.hausdorff_measure d₂) s ≤ ⇑(measure_theory.measure.hausdorff_measure d₁) s
{R : Type x} [NonUnitalNonAssocRing R] {a b : R} (h : Commute a b) : a * a - b * b = (a + b) * (a - b)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {x₀ : E} (hF : HasFderivAt f f' x₀) {C : ℝ} (hC₀ : 0 ≤ C) (hlip : ∀ᶠ (x : E) in nhds x₀, ∥f x - f x₀∥ ≤ C * ∥x - x₀∥) : ∥f'∥ ≤ C
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} (p : ι → P) (i₀ : ι) : Vector_Span k (Set.Range p) = Submodule.span k (Set.Range (λ (i : {x // x ≠ i₀}), p i₀ -ᵥ p ↑i))
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} (hx : x ≠ 0) : o.oangle (-x) x = ↑Real.pi
{G : Type u} [Group G] {N : Subgroup G} [N.normal] (hN : (Nat.card ↥N).coprime N.index) : ∃ (H : Subgroup G), N.is_complement' H
 : fourier_subalgebra.to_Submodule = Submodule.span ℂ (Set.Range fourier)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P (n + 2)) (i₁ i₂ : Fin (n + 3)) : s.monge_plane i₁ i₂ = s.monge_plane i₂ i₁
{α : Type u_1} [Preorder α] [PredOrder α] {a : α} : ¬IsMin a → Order.pred a < a
{G : Type u_1} [Group G] {N : Type u_3} [Group N] (H : Subgroup G) (f : G ≃* N) : Subgroup.map f.to_MonoidHom H.normalizer = (Subgroup.map f.to_MonoidHom H).normalizer
{R : Type u_1} [CommRing R] {a b : R} : a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)
{α : Type u_1} [Preorder α] {a b : α} (h1 : a ≤ b) (h2 : b ≤ a) : a ⩿ b
{n : Type u_1} {𝕜 : Type u_3} [Field 𝕜] [DecidableEq n] [Fintype n] (P : Matrix n n 𝕜 → Prop) (M : Matrix n n 𝕜) (hdiag : ∀ (D : n → 𝕜), (Matrix.diagonal D).det = M.det → P (Matrix.diagonal D)) (htransvec : ∀ (t : Matrix.TransvectionStruct n 𝕜), P t.to_Matrix) (hMul : ∀ (A B : Matrix n n 𝕜), P A → P B → P (A.mul B)) : P M
{α : Type u_1} {β : Type u_2} [MeasurableSpace α] [TopologicalSpace β] [TopologicalSpace.PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β] {ι : Type u_3} {f : ι → α → β} {g : α → β} (u : Filter ι) [u.ne_IsBot] [u.is_countably_generated] (hF : ∀ (i : ι), Measurable (f i)) (lim : Filter.Tendsto f u (nhds g)) : Measurable g
{α : Type u} [PseudoEmetricSpace α] {x : α} {s : Set α} (h : x ∈ s) : emetric.inf_edist x s = 0
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] : FiniteDimensional.finrank K V ≤ 1 ↔ ∃ (v : V), ∀ (w : V), ∃ (c : K), c • v = w
{a : ℝ} {l : Filter ℝ} {f g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in nhds a, DifferentiableAt ℝ f x) (hg' : ∀ᶠ (x : ℝ) in nhds a, deriv g x ≠ 0) (hfa : Filter.Tendsto f (nhds a) (nhds 0)) (hga : Filter.Tendsto g (nhds a) (nhds 0)) (hDiv : Filter.Tendsto (λ (x : ℝ), deriv f x / deriv g x) (nhds a) l) : Filter.Tendsto (λ (x : ℝ), f x / g x) (nhds_within a (Set.Univ  {a})) l
{R : Type u_1} {M : Type u_3} [MonoidWithZero R] [HasZero M] [MulActionWithZero R M] : IsSmulRegular M 0 ↔ Subsingleton M
{ι : Type u₁} {k : Type u₂} {V : Type u₃} {P : Type u₄} [AddCommGroup V] [AddTorsor V P] [Ring k] [Module k V] (b : AffineBasis ι k P) {ι' : Type u_1} [Fintype ι'] [Fintype ι] [DecidableEq ι'] (p : ι' → P) {A : Matrix ι ι' k} (hA : (b.to_Matrix p).mul A = 1) : AffineIndependent k p
{X : Type u} {α : Type v} [TopologicalSpace X] [LinearOrder α] [TopologicalSpace α] [OrderClosedTopology α] [PreconnectedSpace X] {c : α} {f : X → α} (hF : Continuous f) (h₁ : ∃ (a : X), f a ≤ c) (h₂ : ∃ (b : X), c ≤ f b) : c ∈ Set.Range f
{α : Type u_1} [PseudoMetricSpace α] (C : ℝ) {f : ℕ → α} (hu₂ : ∀ (n : ℕ), HasDist.dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n) : CauchySeq f
{xl xr : Type u_1} {xL : xl → Pgame} {xR : xr → Pgame} {yl yr : Type u_1} {yL : yl → Pgame} {yR : yr → Pgame} : (Pgame.mk xl xr xL xR).lf (Pgame.mk yl yr yL yR) ↔ (∃ (i : yl), Pgame.mk xl xr xL xR ≤ yL i) ∨ ∃ (j : xr), xR j ≤ Pgame.mk yl yr yL yR
{G : Type u} {x : G} [Monoid G] : 0 < order_of x ↔ IsOfFinOrder x
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [HasScalar 𝕜 E] {S T : ConvexCone 𝕜 E} (h : ↑S = ↑T) : S = T
{α : Type u} (s : Set (Set α)) : Cardinal.mk ↥{t : Set α | MeasurableSpace.GenerateMeasurable s t} ≤ Linear_order.max (Cardinal.mk ↥s) 2 ^ Cardinal.aleph_0
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] (p1 p2 p3 : P) : p1 -ᵥ p3 - (p2 -ᵥ p3) = p1 -ᵥ p2
(p : ℕ) [Fact (Nat.Prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_Sym p a ^ 2 = 1
{R : Type u_4} {S : Type u_5} [NonAssocSemiring R] [NonAssocSemiring S] (f : R ≃+* S) : ↑f.to_Equiv = ↑f.to_Equiv
(S : Set ℕ+) (K : Type w) [Field K] (C : Type z) [Fintype ↥S] [CommRing C] [Algebra K C] [is_IsDomain C] [IsCyclotomicExtension S K C] : FiniteDimensional K C
{V : Type u_9} {K : Type u_10} [Field K] [AddCommGroup V] [Module K V] {n : Type w} {B : BilinForm K V} {v : n → V} (hv₁ : B.is_Ortho v) (hv₂ : ∀ (i : n), ¬B.is_IsOrtho (v i) (v i)) : LinearIndependent K v
{α : Type u} [Preorder α] {a b c : α} : b < c → a ≤ b → a < c
{R : Type u_1} [MulZeroClass R] (h : IsLeftRegular 0) : Subsingleton R
{R : Type u_1} {G : Type u_2} [CommGroup G] [CommRing R] [Nontrivial R] : Algebra.FiniteType R (MonoidAlgebra R G) ↔ group.fg G
{α : Type u} [TopologicalSpace α] [SigmaCompactSpace α] {f : α → Set α} (hF : ∀ (x : α), f x ∈ nhds x) : ∃ (s : Set α), s.countable ∧ (⋃ (x : α) (H : x ∈ s), f x) = Set.Univ
{A : Type u_1} [AddCommMonoid A] (a b c : A) : c ∈ AddSubmonoid.closure {a, b} ↔ ∃ (m n : ℕ), m • a + n • b = c
{R : Type u} [Ring R] {M : Type v} [AddCommGroup M] [Module R M] [Nontrivial R] {ι : Type w} (b : Basis ι R M) [Infinite ι] {κ : Type w} (v : κ → M) (i : LinearIndependent R v) (m : i.maximal) : Cardinal.mk ι ≤ Cardinal.mk κ
{α : Type u_1} [CanonicallyOrderedAddMonoid α] [HasSub α] [HasOrderedSub α] {a b : α} (h : a ≤ b) : a - b = 0
(p : ℕ) [Fact (Nat.Prime p)] : padic_norm p ↑p < 1
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {S₁ S₂ : Submodule K V} [FiniteDimensional K ↥S₂] (h : S₁ ≤ S₂) : FiniteDimensional K ↥S₁
{Γ₀ : Type u_3} [LinearOrderedAddCommMonoidWithTop Γ₀] [Nontrivial Γ₀] {K : Type u_1} [DivisionRing K] (v : AddValuation K Γ₀) {x : K} : ⇑v x = ⊤ ↔ x = 0
{α : Type u_3} {β : Type u_4} {γ : Type u_5} [Preorder β] [Preorder γ] {f : α → β} {e : β → γ} {l : Filter α} (hm : ∀ (b₁ b₂ : β), e b₁ ≤ e b₂ ↔ b₁ ≤ b₂) (hu : ∀ (c : γ), ∃ (b : β), e b ≤ c) : Filter.Tendsto (e ∘ f) l filter.at_IsBot ↔ Filter.Tendsto f l filter.at_IsBot
{α : Type u_1} [DecidableEq α] [Fintype α] {𝒜 : Finset (Finset α)} {s : Finset α} : s ∈ 𝒜.up_shadow ↔ ∃ (a : α) (H : a ∈ s), s.erase a ∈ 𝒜
{α : Type u_1} [CancelCommMonoidWithZero α] {a : α} {f : Multiset α} (ha : Irreducible a) (pfa : (∀ (b : α), b ∈ f → Prime b) ∧ Associated f.prod a) : ∃ (p : α), Associated a p ∧ f = {p}
{α : Type u} [PseudoEmetricSpace α] {δ₁ δ₂ : ℝ} (hle : δ₁ ≤ δ₂) (E : Set α) : Metric.Cthickening δ₁ E ⊆ Metric.Cthickening δ₂ E
{K : Type v} [Field K] {p : Polynomial K} : Polynomial.Splits (RingHom.id K) p ↔ ⇑Multiset.card p.roots = p.nat_degree
{R : Type u_1} [CommSemiring R] {n : Type u_4} [Fintype n] [DecidableEq n] : Linear_map.to_Matrix (pi.basis_fun R n) (pi.basis_fun R n) = Linear_map.to_Matrix'
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} : Mdifferentiable (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f → Differentiable 𝕜 f
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {s : Set E} {t : Set F} {y : F} (hs : UniqueDiffWithinAt 𝕜 s x) (ht : UniqueDiffWithinAt 𝕜 t y) : UniqueDiffWithinAt 𝕜 (s ×ˢ t) (x, y)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {J : Type u} [CategoryTheory.Category J] (R : D ⥤ C) [CategoryTheory.Reflective R] [CategoryTheory.Limits.HasColimitsOfShape J C] : CategoryTheory.Limits.HasColimitsOfShape J D
{M : Type u_1} [AddMonoid M] {N : Type u_2} [AddMonoid N] {f : M → N} (hF : IsAddMonoidHom f) {s : Set N} (hs : IsAddSubmonoid s) : IsAddSubmonoid (f ⁻¹' s)
{α : Type u_1} [CanonicallyOrderedAddMonoid α] [HasSub α] [HasOrderedSub α] {a b c : α} [ContravariantClass α α has_add.add has_le.le] [ContravariantClass α α has_add.add has_lt.lt] (hca : c ≤ a) (h : a - b < a - c) : c < b
{G : Type u_7} [AddGroup G] (L : List G) : -L.sum = (List.map (λ (x : G), -x) L).reverse.sum
{α : Type u_1} [CompleteLattice α] {s : Set α} (hs : CompleteLattice.SetIndependent s) : s.pairwise_Disjoint Id
{R : Type u} [Ring R] {ι : Type v} [decι : DecidableEq ι] {M : Type u_1} [AddCommGroup M] [Module R M] (A : ι → Submodule R M) {i j : ι} (hij : i ≠ j) (h : Set.Univ = {i, j}) : DirectSum.IsInternal A ↔ IsCompl (A i) (A j)
{α : Type u_1} [MetricSpace α] {K : Nnreal} {f : α → α} (hF : ContractingWith K f) (g : α → α) {x y : α} (hx : Function.IsFixedPt f x) (hy : Function.IsFixedPt g y) {C : ℝ} (hfg : ∀ (z : α), HasDist.dist (f z) (g z) ≤ C) : HasDist.dist x y ≤ C / (1 - ↑K)
(X : AlgebraicGeometry.LocallyRingedSpace : Continuous X.to_Γ_spec_fun
{G : Type u_10} {H : Type u_11} [AddGroup G] [SubtractionMonoid H] (h : G ≃+ H) (x : G) : ⇑h (-x) = -⇑h x
{M : Type u_1} {B : Type u_3} [Monoid M] [SetLike B M] [SubmonoidClass B M] {S : B} {l : List M} (hl : ∀ (x : M), x ∈ l → x ∈ S) : l.prod ∈ S
(G : Type u_1) [Monoid G] : ¬monoid.is_torsion G ↔ ∃ (g : G), ¬IsOfFinOrder g
{k : Type u_1} {E : Type u_2} [LinearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k → E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : ⇑(affine_map.line_Map (f a) (f b)) r ≤ f (⇑(affine_map.line_Map a b) r) ↔ slope f (⇑(affine_map.line_Map a b) r) b ≤ slope f a b
{M : Type u_1} [MulOneClass M] {c d : Con M} (h : c ≤ d) (x : c.quotient) : ⇑(c.map d h) x = ⇑(c.lift d.mk' _) x
{α : Type u} [UniformSpace α] [(Uniformity α).is_countably_generated] (U : ℕ → Set (α × α)) (U_mem : ∀ (n : ℕ), U n ∈ Uniformity α) (HU : ∀ (u : ℕ → α), (∀ (N m n : ℕ), N ≤ m → N ≤ n → (u m, u n) ∈ U N) → (∃ (a : α), Filter.Tendsto u filter.at_Top (nhds a))) : CompleteSpace α
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryCoproducts C] [CategoryTheory.Limits.HasInitial C] : CategoryTheory.Limits.HasFiniteCoproducts C
{α : Type u} [PartialOrder α] {a b : α} : a ≤ b → b ≠ a → a < b
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommGroup β] [HasScalar 𝕜 E] [Module 𝕜 β] {s : Set E} {f : E → β} : ConcaveOn 𝕜 s f → ConvexOn 𝕜 s (-f)
(R : Type u) (M : Type v) (N : Type w) [CommRing R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] [AddCommGroup N] [Module R N] [Module.Free R N] : Module.rank R (TensorProduct R M N) = (Module.rank R M).lift * (Module.rank R N).lift
{α : Type v} [LinearOrder α] [TopologicalSpace α] [OrderClosedTopology α] {s : Set α} (hs : IsConnected s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) : Set.Icc a b ⊆ s
{𝕜 : Type u_1} {E : Type u_4} [SemiNormedGroup E] [NondiscreteNormedField 𝕜] [NormedSpace 𝕜 E] : ∥ContinuousLinearMap.id 𝕜 E∥ ≤ 1
{k : Type u_1} {E : Type u_2} [LinearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k → E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : f (⇑(affine_map.line_Map a b) r) ≤ ⇑(affine_map.line_Map (f a) (f b)) r ↔ slope f a b ≤ slope f (⇑(affine_map.line_Map a b) r) b
{k : Type u_1} {M : Type u_2} [OrderedRing k] [OrderedAddCommGroup M] [Module k M] [OrderedSmul k M] {a : M} {c : k} (hc : c < 0) : a < 0 → 0 < c • a
{n a : ℕ} (h : a < n + 1) : ↑↑a = a
{R : Type u} {A : Type w} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) (r : R) (y : A) : x * ⇑(Algebra_Map R A) r * y = x * y * ⇑(Algebra_Map R A) r
{C : Type u₁} [CategoryTheory.Category C] {X Y : C} [CategoryTheory.Limits.HasImages C] (f : X ⟶ Y) [CategoryTheory.Mono f] : CategoryTheory.Subobject.exists f = CategoryTheory.Subobject.map f
{a b : Ereal} (h : a ≤ -b) : b ≤ -a
{G : Type u_3} [AddGroup G] (P : AddSubgroup G) : P.fg ↔ ∃ (S : Set G), AddSubgroup.closure S = P ∧ S.finite
{R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] : Algebra.IsAlgebraic R A ↔ ⊤.is_algebraic
{α : Type u_1} [DecidableEq α] {s : Multiset α} : s.nodup → s.dedup = s
{H : Type u_1} [TopologicalSpace H] (G : StructureGroupoid H) [ClosedUnderRestriction G] : G.local_invariant_prop G G.is_local_structomorph_within_at
{X : Type u} {m₁ m₂ : X → X → X} {e₁ e₂ : X} (h₁ : EckmannHilton.IsUnital m₁ e₁) (h₂ : EckmannHilton.IsUnital m₂ e₂) (Distrib : ∀ (a b c d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) : e₁ = e₂
(S : Set ℝ) (hS : ∀ (x : ℝ), x ∈ S → 0 ≤ x) : 0 ≤ HasSup.sup S
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {s : Set E} {f : E → F} {n : WithTop ℕ} {p : E → FormalMultilinearSeries 𝕜 E F} (g : F →L[𝕜] G) (hF : HasFtaylorSeriesUpToOn n f p s) : HasFtaylorSeriesUpToOn n (⇑g ∘ f) (λ (x : E) (k : ℕ), g.comp_ContinuousMultilinearMap (p x k)) s
{α : Type u_1} [LinearOrderedField α] [Archimedean α] {x y : α} (hx : 0 < x) (hy : 1 < y) : ∃ (n : ℤ), x ∈ Set.Ico (y ^ n) (y ^ (n + 1))
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {α : E} {q : Polynomial F} (q_irred : Irreducible q) (q_aeval : ⇑(Polynomial.aeval α) q = 0) (hα : IsSolvableByRad F α) : IsSolvable q.gal
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (e : LocalHomeomorph α β) {f : β → γ} {s : Set β} (h : s ⊆ e.to_local_equiv.target) : ContinuousOn f s ↔ ContinuousOn (f ∘ ⇑e) (e.to_local_equiv.source ∩ ⇑e ⁻¹' s)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) : Disjoint K Kᗮ
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {f' : 𝕜 →L[𝕜] F} : HasFderivAt f f' x ↔ HasDerivAt f (⇑f' 1) x
{L : FirstOrder.Language} {M : Type w} [L.Structure M] {s : Set M} {p : M → Prop} {x : M} (h : x ∈ ⇑(FirstOrder.Language.Substructure.closure L) s) (Hs : ∀ (x : M), x ∈ s → p x) (Hfun : ∀ {n : ℕ} (f : L.functions n), FirstOrder.Language.ClosedUnder f (SetOf p)) : p x
{B : Type u} [CategoryTheory.Bicategory B] {a b c : B} (f : a ⟶ b) (g : b ⟶ c) : Category_theory.bicategory.whisker_Right (Category_theory.bicategory.left_unitor f).hom g = (CategoryTheory.Bicategory.associator (𝟙 a) f g).hom ≫ (Category_theory.bicategory.left_unitor (f ≫ g)).hom
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p₁ p₂ : ι → P) : s.sum (λ (i : ι), w i • (p₁ i -ᵥ p₂ i)) = ⇑(s.affine_combination p₁) w -ᵥ ⇑(s.affine_combination p₂) w
{α : Type u_1} [Preorder α] [PredOrder α] {a b : α} [NoMinOrder α] : Order.pred a ≤ Order.pred b → a ≤ b
{α : Type u} [TopologicalSpace α] {s : Set α} : IsPreconnected s ↔ ∀ (u v : Set α), is_IsClosed u → is_IsClosed v → s ⊆ u ∪ v → s ∩ (u ∩ v) = ∅ → s ⊆ u ∨ s ⊆ v
{n : ℕ} {α : Fin (n + 1) → Type u} (q : Π (i : Fin (n + 1)), α i) (i : Fin n) (y : α i.succ) : fin.tail (Function.update q i.succ y) = Function.update (fin.tail q) i y
{C : Type u} [CategoryTheory.Category C] {X Y : AlgebraicGeometry.PresheafedSpace C} {f : X ⟶ Y} (H : AlgebraicGeometry.PresheafedSpace.IsOpenImmersion f) (U : TopologicalSpace.Opens ↥Y) (hU : ↑U ⊆ Set.Range ⇑(f.base)) : f.c.app (Opposite.op U) ≫ H.inv_App ((TopologicalSpace.Opens.map f.base).obj U) = Y.presheaf.map (Category_theory.eq_to_hom _).op
{n : ℕ} (p : Fin (n + 1)) (i : Fin n) : ⇑(p.succ_above) i < p ↔ ⇑fin.cast_Succ i < p
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) : hb.oangle x (-y) + hb.oangle y (-x) = 0
{α : Type u_3} [SemilatticeSup α] (a : α) : filter.at_Top = Filter.comap Coe filter.at_Top
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [SemiNormedGroup F'] {c : ℝ} {f : α → E} {g' : α → F'} {l : Filter α} : asymptotics.is_O_with c l f (λ (x : α), -g' x) → asymptotics.is_O_with c l f g'
(k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] [Fintype ι] (p : ι → P) {n : ℕ} (hc : Fintype.card ι = n + 1) : FiniteDimensional.finrank k ↥(Vector_Span k (Set.Range p)) ≤ n
{n : ℕ} {p : Fin n → Prop} [DecidablePred p] : ↥((fin.find p).is_Some) ↔ ∃ (i : Fin n), p i
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (s : Set P) : ↑(affine_Span k s) = SpanPoints k s
{k : Type u₁} {G : Type u₂} [CommSemiring k] [AddMonoid G] {A : Type u₃} [Semiring A] [Algebra k A] (F : AddMonoidAlgebra k G →ₐ[k] A) (f : MonoidAlgebra k G) : ⇑F f = Finsupp.sum f (λ (a : G) (b : k), b • ⇑F (Finsupp.single a 1))
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {n : WithTop ℕ} {f g : E → 𝕜} (hF : ContDiff 𝕜 n f) (hg : ContDiff 𝕜 n g) : ContDiff 𝕜 n (λ (x : E), f x * g x)
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) {X : C} (S : CategoryTheory.Sieve X) : S ≤ J₁.close S
(n : ℕ) : (Finset.range n).sum (λ (i : ℕ), i) = n * (n - 1) / 2
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [SemiNormedGroup E] [SemiNormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →sl[σ₁₂] F) {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ (x : E), ∥⇑f x∥ ≤ M * ∥x∥) : ∥f∥ ≤ M
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {x : E} {n : WithTop ℕ} {p : E → FormalMultilinearSeries 𝕜 E F} (h : HasFtaylorSeriesUpToOn n f p s) (hn : 1 ≤ n) (hx : s ∈ nhds x) : ∀ᶠ (y : E) in nhds x, HasFderivAt f (⇑(Continuous_multilinear_Curry_Fin1 𝕜 E F) (p y 1)) y
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b : α} : a < -b → b < -a
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [CommRing 𝕜] [AddCommGroup E] [AddCommGroup F] [AddCommGroup G] [Module 𝕜 E] [Module 𝕜 F] [Module 𝕜 G] [TopologicalSpace E] [TopologicalSpace F] [TopologicalSpace G] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] [TopologicalAddGroup F] [HasContinuousConstSmul 𝕜 F] [TopologicalAddGroup G] [HasContinuousConstSmul 𝕜 G] (q : FormalMultilinearSeries 𝕜 F G) (p : FormalMultilinearSeries 𝕜 E F) (v : Fin 1 → E) : ⇑(q.comp p 1) v = ⇑(q 1) (λ (i : Fin 1), ⇑(p 1) v)
{α : Type u_1} [TopologicalSpace α] [NonAssocRing α] (h : TopologicalSemiring α) : TopologicalRing α
{α : Type u} [PartialOrder α] {a b : α} (h : a ≤ b) : a = b ∨ a < b
{R₁ : Type u_1} {R₂ : Type u_2} [Semiring R₁] [Semiring R₂] {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_4} [TopologicalSpace M₁] [AddCommMonoid M₁] {M₂ : Type u_6} [TopologicalSpace M₂] [AddCommMonoid M₂] [Module R₁ M₁] [Module R₂ M₂] [t2_Space M₂] {s : Set M₁} {f g : M₁ →sl[σ₁₂] M₂} (h : Set.EqOn ⇑f ⇑g s) : Set.EqOn ⇑f ⇑g (Closure ↑(Submodule.span R₁ s))
{f₁ f₂ : Circle_deg1_Lift} (h₁ : IsUnit f₁) (h₂ : IsUnit f₂) (h : f₁.translation_number = f₂.translation_number) : ∃ (F : Circle_deg1_Lift), Function.Semiconj ⇑F ⇑f₁ ⇑f₂
(α : Type u) [MetricSpace α] [TopologicalSpace.SeparableSpace α] : Isometry (KuratowskiEmbedding α)
{𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [AddCommGroup F] [Module 𝕜 F] [c : InnerProductSpace.Core 𝕜 F] {x y : F} : HasInner.inner (x + y) (x + y) = HasInner.inner x x + HasInner.inner x y + HasInner.inner y x + HasInner.inner y y
{α : Type u} {β : Type v} [TopologicalSpace α] [MetricSpace β] [HasZero β] {ι : Type u_1} {F : ι → ZeroAtInftyContinuousMap α β} {f : ZeroAtInftyContinuousMap α β} {l : Filter ι} : Filter.Tendsto F l (nhds f) ↔ TendstoUniformly (λ (i : ι), ⇑(F i)) ⇑f l
{α : Type u_1} [MeasurableSpace α] : Function.Injective measure_theory.jordan_decomposition.to_SignedMeasure
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {s : Set E} {f : E → F} {n : WithTop ℕ} (e : F ≃L[𝕜] G) : ContDiffOn 𝕜 n (⇑e ∘ f) s ↔ ContDiffOn 𝕜 n f s
{M : Type u_1} [AddMonoid M] {s : Set M} {a : M} (hs : IsAddSubmonoid s) (h : a ∈ s) : Multiples a ⊆ s
{α : Type u} [PseudoMetricSpace α] {s : Set α} [ProperSpace α] (hc : is_IsClosed s) (hb : Metric.Bounded s) : is_IsCompact s
{n : ℕ} {α : Type u_1} (l : List α) (c : Composition n) {i : ℕ} (hi : i < (l.split_wrt_Composition c).length) : (l.split_wrt_Composition c).nth_LE i hi = List.drop (c.size_Up_to i) (List.take (c.size_Up_to (i + 1)) l)
{s : ℂ} (hs : 0 < s.re) : MeasureTheory.IntegrableOn (λ (x : ℝ), ↑(Real.exp (-x)) * ↑x ^ (s - 1)) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [OrderedRing 𝕜] [AddCommGroup E] [AddCommGroup F] [Module 𝕜 E] [Module 𝕜 F] {a b : 𝕜} {x y : E} {f : E →ᵃ[𝕜] F} (h : a + b = 1) : ⇑f (a • x + b • y) = a • ⇑f x + b • ⇑f y
{M : Type u_1} [Monoid M] {s : Set M} {a : M} (h : a ∈ monoid.closure s) : ∃ (l : List M), (∀ (x : M), x ∈ l → x ∈ s) ∧ l.prod = a
{α : Type u} [Preorder α] {a b c : α} (hab : a < b) (hbc : b = c) : a < c
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} [Fintype ι] {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι → 𝕜) (i : ι) : HasInner.inner (v i) (finset.univ.sum (λ (i : ι), l i • v i)) = l i
{α : Type u_1} [CommMonoid α] [DecidableRel has_dvd.dvd] {a b : α} : a ∣ b → 0 < multiplicity a b
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r r' : Ennreal} (hF : HasFpowerSeriesOnBall f p x r) (hr : r' < r) : ∃ (C : ℝ), ∀ (y : E), y ∈ Emetric.Ball x r' → ∀ (z : E), z ∈ Emetric.Ball x r' → ∥f y - f z - ⇑(p 1) (λ (_x : Fin 1), y - z)∥ ≤ C * Linear_order.max ∥y - x∥ ∥z - x∥ * ∥y - z∥
{α : Type u_1} [TopologicalSpace α] {γ : Type u_4} [LinearOrderedAddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] [HasContinuousAdd γ] {f g : α → γ} (hF : UpperSemicontinuous f) (hg : UpperSemicontinuous g) : UpperSemicontinuous (λ (z : α), f z + g z)
{α : Type u_1} {β : Type u_2} {M : Type u_5} [CommMonoid M] {f : α → M} {g : β → α} (hg : Function.Injective g) : finprod (λ (i : α), finprod (λ (H : i ∈ Set.Range g), f i)) = finprod (λ (j : β), f (g j))
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {ι : Type u_1} {s : Set ι} (b : Basis ↥s R M) (h : Module.rank R M < Cardinal.aleph_0) : s.finite
{p : Real.Angle → Prop} (θ : Real.Angle) (h : ∀ (x : ℝ), p ↑x) : p θ
{α : Type u_1} {ι : sort u_3} [ConditionallyCompleteLattice α] {f : ι → α} (H : BddBelow (Set.Range f)) (c : ι) : infi f ≤ f c
{A : Type u_1} [CommRing A] [Algebra ℚ A] : PowerSeries.exp A * ⇑power_series.eval_Neg_hom (PowerSeries.exp A) = 1
{K : Type u_1} {n : ℕ} {g : GeneralizedContinuedFraction K} [DivisionRing K] {m : ℕ} : m ≤ n → g.continuants_aux m = (g.squash_gcf n).continuants_aux m
{n : ℕ} {p : Fin n → Prop} [DecidablePred p] {i : Fin n} (hi : i ∈ fin.find p) {j : Fin n} (hj : j < i) : ¬p j
{ιa : Type u_7} {ιb : Type u_8} [DecidableEq ιa] [DecidableEq ιb] [Fintype ιa] [Fintype ιb] {R' : Type u_9} {Mᵢ : Type u_10} {N₁ : Type u_11} {N₂ : Type u_12} [CommSemiring R'] [AddCommGroup N₁] [Module R' N₁] [AddCommGroup N₂] [Module R' N₂] [AddCommMonoid Mᵢ] [Module R' Mᵢ] (a : MultilinearMap R' (λ (_x : ιa), Mᵢ) N₁) (b : MultilinearMap R' (λ (_x : ιb), Mᵢ) N₂) : ↑(⇑MultilinearMap.alternatization a).dom_Coprod ↑(⇑MultilinearMap.alternatization b) = finset.univ.sum (λ (σa : Equiv.perm ιa), finset.univ.sum (λ (σb : Equiv.perm ιb), ⇑equiv.perm.sign σa • ⇑equiv.perm.sign σb • (multilinear_map.dom_Dom_congr σa a).dom_Coprod (multilinear_map.dom_Dom_congr σb b)))
{α : Type u} {l₁ l₂ : List α} (i : ℕ) : List.take (l₁.length + i) (l₁ ++ l₂) = l₁ ++ List.take i l₂
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X ⟶ Y} [CategoryTheory.Limits.HasCoequalizer f g] [CategoryTheory.Mono (CategoryTheory.Limits.coequalizerπ f g)] : f = g
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.EnoughProjectives C] [CategoryTheory.Abelian C] {X Y : C} (f : X ⟶ Y) : CategoryTheory.Exact (CategoryTheory.Projective.d f) f
{α : Type u} [AddGroup α] [HasLe α] [CovariantClass α α (Function.swap has_add.add) has_le.le] {a b c : α} : a + b ≤ c → a ≤ c - b
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {p : E × F} : ContDiffAt 𝕜 n Prod.snd p
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
{α : Type u} [CommSemiring α] (x y : α) (n : ℕ) : (Finset.range n).sum (λ (i : ℕ), (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n
{α : Type u_2} [DecidableEq α] {𝒜 : Finset (Finset α)} {m n : ℕ} (h𝒜 : IsAntichain HasSubset.Subset ↑𝒜) : Disjoint (𝒜.slice m) (Finset.falling n 𝒜).shadow
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {t : Affine.Triangle ℝ P} (ho : t.orthocenter ∉ Set.Range t.points) {p : Fin 3 → P} (hps : Set.Range p ⊆ HasInsert.insert t.orthocenter (Set.Range t.points)) (hpi : Function.Injective p) : ∃ (c : P) (H : c ∈ affine_Span ℝ (Set.Range t.points)), ∀ (p₁ : P), p₁ ∈ Set.Range p → HasDist.dist p₁ c = Affine.Simplex.circumradius t
{R : Type u} [NonAssocSemiring R] (s : Subsemiring R) : 1 ∈ s
(n p : ℕ) : Polynomial.eval ↑n (Polynomial.bernoulli p.succ) = bernoulli p.succ + (↑p + 1) * (Finset.range n).sum (λ (k : ℕ), ↑k ^ p)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] {v : E} (hv : v ∈ Kᗮ) : ⇑(Orthogonal_projection K) v = 0
(R : Type u_1) [CommRing R] (n : ℕ) : (Finset.range (n + 1)).sum (λ (ν : ℕ), (n • Polynomial.x - ↑ν) ^ 2 * bernstein_Polynomial R n ν) = n • Polynomial.x * (1 - Polynomial.x)
{R : Type u} [EuclideanDomain R] [DecidableEq R] (a b : R) : EuclideanDomain.gcd a b = a * EuclideanDomain.gcd_a a b + b * EuclideanDomain.gcd_b a b
{α : Type u} [HasMul α] : IsMulHom Id
{p x : ℝ} {r : ℚ} (h : LiouvilleWith p x) (hr : r ≠ 0) : LiouvilleWith p (x * ↑r)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (E : D ⥤ C) [CategoryTheory.IsEquivalence E] [CategoryTheory.Limits.HasLimitsOfSize C] : CategoryTheory.Limits.HasLimitsOfSize D
(k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] [Fintype ι] (p : ι → P) {n : ℕ} (hc : Fintype.card ι = n + 2) : FiniteDimensional.finrank k ↥(Vector_Span k (Set.Range p)) ≤ n ↔ ¬AffineIndependent k p
{α : Type u_1} [PseudoEmetricSpace α] {f : ℕ → α} (d : ℕ → Nnreal) (hF : ∀ (n : ℕ), HasEdist.edist (f n) (f n.succ) ≤ ↑(d n)) (hD : Summable d) : CauchySeq f
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : ℕ} {i : Fin (n + 2)} : X.δ (⇑fin.cast_Succ i) ≫ X.δ i = X.δ i.succ ≫ X.δ i
{α : Type u} [Semiring α] : IsSemiringHom Id
{ι : sort u_1} {f : ι → Ennreal} {x : Ennreal} (h0 : x ≠ 0) (h : x ≠ ⊤) : infi f * x = ⨅ (i : ι), f i * x
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set ℝ} [Interval_integral.FTC_Filter a (nhds_within a s) (nhds_within a t)] (hmeas : StronglyMeasurableAtFilter f (nhds_within a t) MeasureTheory.MeasureSpace.volume) (ha : Filter.Tendsto f (nhds_within a t ⊓ MeasureTheory.Measure_space.volume.ae) (nhds c)) (hs : UniqueDiffWithinAt ℝ s a . "UniqueDiffWithinAt_ici_Iic_Univ") : deriv_within (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) s a = -c
{k : Type u₁} {G : Type u₂} [CommSemiring k] [Monoid G] {A : Type u₃} [Semiring A] [Algebra k A] (F : MonoidAlgebra k G →ₐ[k] A) (f : MonoidAlgebra k G) : ⇑F f = Finsupp.sum f (λ (a : G) (b : k), b • ⇑F (Finsupp.single a 1))
{α : Type u_1} [CommSemiring α] : fib_rec.is_solution (λ (x : ℕ), ↑(Nat.fib x))
{V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasImages V] [CategoryTheory.Limits.HasZeroObject V] [CategoryTheory.Preadditive V] [CategoryTheory.Limits.HasKernels V] [CategoryTheory.Limits.HasCokernels V] {A₁ B₁ C₁ A₂ B₂ C₂ : V} (f₁ : A₁ ⟶ B₁) (g₁ : B₁ ⟶ C₁) (f₂ : A₂ ⟶ B₂) (g₂ : B₂ ⟶ C₂) (α : A₁ ≅ A₂) (β : B₁ ≅ B₂) (γ : C₁ ≅ C₂) (hsq₁ : α.hom ≫ f₂ = f₁ ≫ β.hom) (hsq₂ : β.hom ≫ g₂ = g₁ ≫ γ.hom) (h : CategoryTheory.Exact f₁ g₁) : CategoryTheory.Exact f₂ g₂
{R : Type u_1} {M : Type u_2} [CommSemiring R] [AddCommMonoid M] [Module R M] : Module.IsTorsion R ↥(Submodule.torsion R M)
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {s : Set α} (hs : is_IsCompact s) {t : Set β} (ht : is_IsCompact t) {n : Set (α × β)} (hn : is_IsOpen n) (hp : s ×ˢ t ⊆ n) : ∃ (u : Set α) (v : Set β), is_IsOpen u ∧ is_IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ u ×ˢ v ⊆ n
{α : Type u_1} [LinearOrder α] [SuccOrder α] [IsSuccArchimedean α] (r : α → α → Prop) {n m : α} (h1 : ∀ (i : α), i ∈ Set.Ico n m → r i (Order.succ i)) (h2 : ∀ (i : α), i ∈ Set.Ico m n → r (Order.succ i) i) (hnm : n ≠ m) : Relation.TransGen r n m
(b c : ℝ) (n : ℕ) (hb : 0 ≠ b) : Filter.Tendsto (λ (x : ℝ), x ^ n / (b * Real.exp x + c)) filter.at_Top (nhds 0)
{α : Type u_1} {β : Type u_2} [Fintype α] [Fintype β] (h : Fintype.card β < Fintype.card α) : IsEmpty (α ↪ β)
(A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) [Nontrivial B] : minpoly A x ≠ 1
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [SemiNormedGroup E'] [SemiNormedGroup F'] {f' : α → E'} {g' : α → F'} {l : Filter α} : ((λ (x : α), ∥f' x∥) =o[l] λ (x : α), ∥g' x∥) → f' =o[l] g'
{R : Type u} {M : Type v} {M₂ : Type w} {M₃ : Type y} [Ring R] [AddCommGroup M] [AddCommGroup M₂] [AddCommGroup M₃] [Module R M] [Module R M₂] [Module R M₃] {f : M →ₗ[R] M₂} {g : M →ₗ[R] M₃} (h : f.ker ⊔ g.ker = ⊤) : (f.prod g).range = f.range.prod g.range
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set ℝ} [Interval_integral.FTC_Filter a (nhds_within a s) (nhds_within a t)] (hmeas : StronglyMeasurableAtFilter f (nhds_within a t) MeasureTheory.MeasureSpace.volume) (ha : Filter.Tendsto f (nhds_within a t ⊓ MeasureTheory.Measure_space.volume.ae) (nhds c)) : HasDerivWithinAt (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) (-c) s a
{𝕂 : Type u_6} [is_R_or_C 𝕂] {E' : Type u_7} [NormedGroup E'] [NormedSpace 𝕂 E'] {F' : Type u_8} [NormedGroup F'] [NormedSpace 𝕂 F'] [CompleteSpace E'] {f : E' → F'} {f' : E' ≃L[𝕂] F'} {a : E'} {n : WithTop ℕ} (hF : ContDiffAt 𝕂 n f a) (hF' : HasFderivAt f ↑f' a) (hn : 1 ≤ n) : ContDiffAt 𝕂 n (hf.local_Inverse hF' hn) (f a)
{β : Type u_2} [TopologicalSpace β] {κ : Type u_5} {f : κ → β} (hF : Function.Surjective f) : DenseRange f
{C : Type u} [CategoryTheory.Category C] {D : Type u_1} [CategoryTheory.Category D] [CategoryTheory.Abelian C] [CategoryTheory.HasInjectiveResolutions C] [CategoryTheory.Abelian D] (F : C ⥤ D) [F.additive] (n : ℕ) {X Y : C} (f : Y ⟶ X) {P : CategoryTheory.InjectiveResolution X} {Q : CategoryTheory.InjectiveResolution Y} (g : Q.cocomplex ⟶ P.cocomplex) (w : Q.ι ≫ g = (cochain_complex.single₀ C).map f ≫ P.ι) : (F.right_derived n).map f = (F.right_derived_obj_iso n Q).hom ≫ (homology_Functor D (ComplexShape.up ℕ) n).map ((F.map_HomologicalComplex (ComplexShape.up ℕ)).map g) ≫ (F.right_derived_obj_iso n P).inv
{R : Type u_1} [Ring R] [StrongRankCondition R] (n : ℕ) {m : ℕ} (v : Fin m → Fin n → R) : LinearIndependent R v → m ≤ n
{α : Type u_1} [AddCommGroup α] [TopologicalSpace α] [TopologicalAddGroup α] [t2_Space α] (f : ℕ → α) : Filter.Tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_Top (nhds 0)
{α : Type u_1} [TopologicalSpace α] {x : α} {s : Set α} {γ : Type u_4} [LinearOrderedAddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] {f g : α → γ} (hF : UpperSemicontinuousWithinAt f s x) (hg : UpperSemicontinuousWithinAt g s x) (hcont : ContinuousAt (λ (p : γ × γ), p.fst + p.snd) (f x, g x)) : UpperSemicontinuousWithinAt (λ (z : α), f z + g z) s x
{R : Type u_3} {A : Type u_5} [CommRing R] [CommRing A] [Algebra R A] {n : ℕ} (H : ∀ (s : Finset A), AlgebraicIndependent R (λ (i : ↥s), ↑i) → s.card ≤ n) (s : Set A) : AlgebraicIndependent R Coe → Cardinal.mk ↥s ≤ ↑n
{α : Type u} [UniformSpace α] [(Uniformity α).is_countably_generated] (H' : ∀ (u : ℕ → α), CauchySeq u → (∃ (a : α), Filter.Tendsto u filter.at_Top (nhds a))) : CompleteSpace α
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (s : AffineSubspace ℝ P) [Nonempty ↥s] [CompleteSpace ↥(s.direction)] (p : P) : ⇑(EuclideanGeometry.reflection s) (⇑(EuclideanGeometry.reflection s) p) = p
(n : ℕ) : ↑(n.succ) • Polynomial.bernoulli n = ⇑(Polynomial.monomial n) ↑(n.succ) - (Finset.range n).sum (λ (k : ℕ), ↑((n + 1).choose k) • Polynomial.bernoulli k)
{R : Type u_1} {M : Type u_5} {n : Type u_14} [CommRing R] [AddCommGroup M] [Module R M] [NoZeroDivisors R] {B : M →ₗ[R] M →ₗ[R] R} (v : Basis n R M) (hO : B.is_Ortho ⇑v) (h : ∀ (i : n), ¬B.is_IsOrtho (⇑v i) (⇑v i)) : B.separating_Left
(R : Type u) [Ring R] [StrongRankCondition R] (m n : Type v) [Fintype m] [Fintype n] : Module.rank R (Matrix m n R) = (Cardinal.mk m * Cardinal.mk n).lift
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b
{M : Type u_1} [Semigroup M] [TopologicalSpace M] [t2_Space M] (Continuous_Mul_Left : ∀ (r : M), Continuous (λ (_x : M), _x * r)) (s : Set M) (snemp : s.nonempty) (s_IsCompact : is_IsCompact s) (s_Add : ∀ (x : M), x ∈ s → ∀ (y : M), y ∈ s → x * y ∈ s) : ∃ (m : M) (H : m ∈ s), m * m = m
{R : Type u_1} [LinearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [FiniteDimensional R M] (x : Orientation R M ι) (f : M ≃ₗ[R] M) (h : Fintype.card ι = FiniteDimensional.finrank R M) : ⇑(Orientation.map ι f) x = -x ↔ ⇑LinearMap.det ↑f < 0
{α : Type u_1} [NonUnitalSemiNormedRing α] (x y : α) : ∥⇑(AddMonoid_hom.mul_Left x) y∥ ≤ ∥x∥ * ∥y∥
{α : Type u_1} [LinearOrder α] {r s : α} : {r}.to_colex < {s}.to_colex ↔ r < s
{X : Top} (F : Top.Presheaf (CategoryTheory.Discrete Punit) X) : F.is_sheaf
{α : Type u} [TopologicalSpace α] {s t : Set α} (ht : is_IsCompact t) (hs : is_IsClosed s) : is_IsCompact (s ∩ t)
{n : ℕ} [Fact (0 < n)] : Fintype.card (DihedralGroup n) = 2 * n
{α : Type u} [TopologicalSpace α] [LocallyCompactSpace α] {K : Set α} (hK : is_IsCompact K) : ∃ (K' : Set α), is_IsCompact K' ∧ K ⊆ Interior K'
{α : Type u_1} {G : Type u_4} [DivisionCommMonoid G] {f g : α → G} (hF : (Function.MulSupport f).finite) (hg : (Function.MulSupport g).finite) : finprod (λ (i : α), f i / g i) = finprod (λ (i : α), f i) / finprod (λ (i : α), g i)
{β : Type u} {α : Type v} {s : Finset α} [AddCommMonoid β] (f : α → β) {p : α → Prop} [DecidablePred p] : (Finset.subtype p s).sum (λ (x : Subtype_ p), f ↑x) = (Finset.filter p s).sum (λ (x : α), f x)
{α : Type u_3} {β : Type u_4} [SemilatticeSup α] [SemilatticeSup β] {f : α → β} (g : β → α) (b' : β) (hF : Monotone f) (gc : ∀ (a : α) (b : β), b ≥ b' → (f a ≤ b ↔ a ≤ g b)) (hgi : ∀ (b : β), b ≥ b' → b ≤ f (g b)) : Filter.map f filter.at_Top = filter.at_Top
{α : Type u} [LinearOrderedRing α] (a b c : α) : 0 ≤ a * b ∨ 0 ≤ b * c ∨ 0 ≤ c * a
{R : Type u_1} {S : Type u_2} (L : Type u_4) [EuclideanDomain R] [CommRing S] [is_IsDomain S] [Field L] [algRL : Algebra R L] [Algebra R S] [Algebra S L] [ist : IsScalarTower R S L] [Iic : is_IsIntegralClosure S R L] {abv : AbsoluteValue R ℤ} {ι : Type u_5} [DecidableEq ι] [Fintype ι] (bS : Basis ι R S) (adm : abv.is_Admissible) [Infinite R] [DecidableEq R] (h : Algebra.IsAlgebraic R L) (a : S) {b : S} (hb : b ≠ 0) : ∃ (q : S) (r : R) (H : r ∈ class_group.finset_approx bS adm), ⇑abv (⇑(Algebra.norm R) (r • a - q * b)) < ⇑abv (⇑(Algebra.norm R) b)
{γ : Type w} [SemilatticeSup γ] {s t : Set γ} : BddAbove s → BddAbove t → BddAbove (s ∪ t)
{γ : Type w} [SemilatticeInf γ] {s t : Set γ} : BddBelow (s ∪ t) ↔ BddBelow s ∧ BddBelow t
{T : Type u} [CategoryTheory.Category T] {X Y : T} (i : X ≅ Y) (p : CategoryTheory.Arrow T) (sq : CategoryTheory.Arrow.mk i.hom ⟶ p) : i.inv ≫ sq.left ≫ p.hom = sq.right
{α : Type u} [MonoidWithZero α] (x : α) [Invertible x] : Ring.inverse x = ⅟ x
(n : ℕ+) (A : Type w) (B : Type z) [CommRing A] [CommRing B] [Algebra A B] [IsCyclotomicExtension {n} A B] [is_IsDomain B] [NeZero ↑↑n] : IsPrimitiveRoot (IsCyclotomicExtension.zeta n A B) ↑n
{α : Type u_1} [TopologicalSpace α] {x : α} {γ : Type u_4} [LinearOrderedAddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] {f g : α → γ} (hF : LowerSemicontinuousAt f x) (hg : LowerSemicontinuousAt g x) (hcont : ContinuousAt (λ (p : γ × γ), p.fst + p.snd) (f x, g x)) : LowerSemicontinuousAt (λ (z : α), f z + g z) x
(R : Type u) [Ring R] [StrongRankCondition R] {ι : Type v} [Fintype ι] : FiniteDimensional.finrank R (ι → R) = Fintype.card ι
{α : Type u} {β : Type v} [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {n : ℕ} (hn : s.card < t.card * n) : ∃ (y : β) (H : y ∈ t), (Finset.filter (λ (x : α), f x = y) s).card < n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] [CategoryTheory.Limits.HasEqualizers C] : CategoryTheory.Limits.HasLimits C
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p₂ : ι → P) (p₁ : P) (h : s.sum (λ (i : ι), w i) = 0) : s.sum (λ (i : ι), w i • (p₁ -ᵥ p₂ i)) = -⇑(s.weighted_vsub p₂) w
(M : Type u_1) (α : Type u_2) [Group M] [MulAction M α] {s t : Set α} : fixing_Subgroup M (s ∪ t) = fixing_Subgroup M s ⊓ fixing_Subgroup M t
(C : Type u) [CategoryTheory.Category C] [∀ {X Y : C}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)] : CategoryTheory.Limits.HasBinaryProducts C
{X : Type u_1} [tX : TopologicalSpace X] {s t : Set X} (ts : t ⊆ s) : subtype.topological_Space = TopologicalSpace.induced (Set.inclusion ts) subtype.topological_Space
{p : ℕ} (q : ℚ) : padic_val_rat p (-q) = padic_val_rat p q
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {s1 s2 : AffineSubspace k P} (h1 : ↑s1.nonempty) (h2 : ↑s2.nonempty) (hD : IsCompl s1.direction s2.direction) : ∃ (p : P), ↑s1 ∩ ↑s2 = {p}
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [OrderedRing 𝕜] [AddCommGroup E] [AddCommGroup F] [Module 𝕜 E] [Module 𝕜 F] {x : E} (f : E →ᵃ[𝕜] F) {s : Set F} (hs : StarConvex 𝕜 (⇑f x) s) : StarConvex 𝕜 x (⇑f ⁻¹' s)
{f : ℕ → ℝ} (hfa : Antitone f) (hF0 : Filter.Tendsto f filter.at_Top (nhds 0)) : ∃ (l : ℝ), Filter.Tendsto (λ (n : ℕ), (Finset.range (n + 1)).sum (λ (i : ℕ), (-1) ^ i * f i)) filter.at_Top (nhds l)
{ι : Type u} {γ : Type w} [dec : DecidableEq ι] (p : ι → Prop) [DecidablePred p] [AddCommMonoid γ] (S : ι → AddSubmonoid γ) : (⨆ (i : ι) (h : p i), S i) = ((dfinsupp.sum_AddHom (λ (i : ι), (S i).subtype)).comp (dfinsupp.filter_Add_MonoidHom (λ (i : ι), ↥(S i)) p)).mrange
{α : Type u_1} {p : α → Prop} [DecidablePred p] {s : Finset α} (h : ∀ (x : α), x ∈ s → ¬p x) : Finset.filter p s = ∅
{a b : ℕ} (w : a ∣ b) (h : b < a) : b = 0
{K : Type u_1} {v : K} {n : ℕ} [LinearOrderedField K] [FloorRing K] : (GeneralizedContinuedFraction.of v).denominators n ≤ (GeneralizedContinuedFraction.of v).denominators (n + 1)
{S : Type u_1} [has_Add S] {a b : S} (h : AddCommute a b) : a + b = b + a
{p : Ennreal} [Fact (1 ≤ p)] (hp : p ≠ ⊤) : (Submodule.span ℂ (Set.Range (fourier_Lp p))).topological_Closure = ⊤
{α : Type u_1} [HasLe α] {s : Set αᵒᵈ} : IsLowerSet s → IsUpperSet (⇑order_dual.to_dual ⁻¹' s)
{α : Type u} {γ : Type u_1} [TopologicalSpace γ] [t2_Space γ] [CompactSpace γ] {f : α → γ} {b : Ultrafilter α} {c : γ} : Ultrafilter.extend f b = c ↔ ↑(Ultrafilter.map f b) ≤ nhds c
{n : ℕ} (hpos : 0 < n) {p : ℕ} [Fact (Nat.Prime p)] {a : ℕ} (hroot : (Polynomial.cyclotomic n (Zmod p)).is_root (⇑(nat.cast_RingHom (Zmod p)) a)) : order_of (zmod.unit_of_IsCoprime a _) ∣ n
 : fib_rec.is_solution (has_pow.pow GoldenRatio)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {y : E} {α : Type u_3} (l : Filter α) {c : α → 𝕜} {d : α → E} (hc : Filter.Tendsto (λ (n : α), ∥c n∥) l filter.at_Top) (hD : Filter.Tendsto (λ (n : α), c n • d n) l (nhds y)) : Filter.Tendsto d l (nhds 0)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {X : Top} (F : Top.Presheaf C X) (U : TopologicalSpace.Opens ↥X) (R : CategoryTheory.Presieve U) : Category_theory.presheaf.second_Map R F ≫ (Top.presheaf.covering_of_presieve.second_obj_iso_Pi_inters F U R).hom = (Top.presheaf.covering_of_presieve.first_obj_iso_Pi_Opens F U R).hom ≫ Top.presheaf.sheaf_condition_Equalizer_products.right_res F (Top.presheaf.covering_of_Presieve U R)
{α : Type u} [PseudoMetricSpace α] {s : Set α} (hs : s.nonempty) {C : ℝ} (h : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → HasDist.dist x y ≤ C) : Metric.diam s ≤ C
{m : ℝ} {f : ℕ → ℕ} (hm : 1 < m) (fi : ∀ (i : ℕ), i ≤ f i) : Summable (λ (i : ℕ), 1 / m ^ f i)
{α : Type u} {β : Type v} {s : Set α} {t : Set β} {f : α → β} {f' : β → α} (h : Set.InvOn f' f s t) (hF : Set.MapsTo f s t) (hF' : Set.MapsTo f' t s) : Set.BijOn f s t
{α : Type u_1} {ι : Type u_3} {ι' : Type u_4} [DistribLattice α] [OrderBot α] [DecidableEq ι] {s : Finset ι'} {g : ι' → Finset ι} {f : ι → α} (hs : s.sup_indep (λ (i : ι'), (g i).sup f)) (hg : ∀ (i' : ι'), i' ∈ s → (g i').sup_indep f) : (s.sup g).sup_indep f
{𝕂 : Type u_1} {𝔸 : Type u_2} [NondiscreteNormedField 𝕂] [NormedRing 𝔸] [NormedAlgebra 𝕂 𝔸] [CompleteSpace 𝔸] [CharZero 𝕂] {x y : 𝔸} (hxy : Commute x y) (hx : x ∈ Emetric.Ball 0 (Exp_series 𝕂 𝔸).radius) (hy : y ∈ Emetric.Ball 0 (Exp_series 𝕂 𝔸).radius) : Exp 𝕂 (x + y) = Exp 𝕂 x * Exp 𝕂 y
(n a : ℕ) (p : ℕ → Prop) [DecidablePred p] (pp : Function.Periodic p a) : (Finset.filter p (Finset.ico n (n + a))).card = Nat.count p a
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : LocalHomeomorph α β} {s : Set α} {t : Set β} : e.is_image s t → e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' (e.to_local_equiv.source ∩ s) = e.to_local_equiv.target ∩ t
{K : Type v} [Field K] {P : Polynomial K} (hmo : P.monic) (hP : Polynomial.Splits (RingHom.id K) P) : P.next_Coeff = -P.roots.sum
{α : Type u} [PseudoMetricSpace α] {x : α} {r : ℝ} : Metric.Bounded (Metric.Ball x r)
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [NondiscreteNormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (f : MultilinearMap 𝕜 E G) {C : ℝ} (hC : 0 ≤ C) (H : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) (m₁ m₂ : Π (i : ι), E i) : ∥⇑f m₁ - ⇑f m₂∥ ≤ C * finset.univ.sum (λ (i : ι), finset.univ.prod (λ (j : ι), Ite (j = i) ∥m₁ i - m₂ i∥ (Linear_order.max ∥m₁ j∥ ∥m₂ j∥)))
{α : Type u_1} {β : Type u_2} {e : LocalEquiv α β} {s : Set α} {t : Set β} : e.target ∩ ⇑(e.symm) ⁻¹' s = e.target ∩ t → e.is_image s t
(R : Type u_1) [CommRing R] (M : Type u_2) [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] [Nontrivial R] : (LinearMap.trace R M).comp (dual_tensor_hom R M M) = contract_Left R M
{α : Type u_1} [DecidableEq α] [Fintype α] {𝒜 : Finset (Finset α)} {s : Finset α} : s ∈ 𝒜.up_shadow ↔ ∃ (t : Finset α) (H : t ∈ 𝒜) (a : α) (H : a ∉ t), HasInsert.insert a t = s
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (f : α ≃ₜ β) (K : TopologicalSpace.Compacts α) : (⇑(TopologicalSpace.Compacts.equiv f) K).carrier = ⇑(f.symm) ⁻¹' K.carrier
{α : sort u_1} {β : sort u_2} {γ : out_param (sort u_3)} [has_Coe α β] [has_Coe_ToFun β (λ (_x : β), γ)] (x : α) : ⇑x = ⇑↑x
{a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) : (a * b).factors.to_Finset = a.factors.to_Finset ∪ b.factors.to_Finset
{α : Type u_1} [Preorder α] {a b : α} (h : a ≤ b) : Set.Ioi b ⊆ Set.Ioi a
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommMonoid β] [Module 𝕜 E] [Module 𝕜 β] [LinearOrder E] {s : Set E} {f : E → β} (hs : Convex 𝕜 s) (hF : ∀ ⦃x y : E⦄, x ∈ s → y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → f (a • x + b • y) < a • f x + b • f y) : StrictConvexOn 𝕜 s f
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : α → β} {s : Set α} : AntitoneOn f s → MonotoneOn (f ∘ ⇑order_dual.of_dual) s
{α : Type u_1} [CircularPreorder α] {a b c : α} (h : HasSbtw.Sbtw a b c) : HasSbtw.Sbtw b c a
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (ha : Filter.Tendsto f (nhds a ⊓ MeasureTheory.Measure_space.volume.ae) (nhds c)) : HasDerivAt (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) (-c) a
{α : Type u_1} {R : Type u_2} {l : Filter α} {f : α → R} {r : R} [LinearOrderedRing R] [Archimedean R] (hr : 0 < r) (hF : Filter.Tendsto f l filter.at_IsBot) : Filter.Tendsto (λ (x : α), f x * r) l filter.at_IsBot
{n : ℕ+} (h1 : n ≠ 1) : ∃ (k : ℕ+), n = k + 1
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} {s : Set E} : DifferentiableOn 𝕜 f s → MdifferentiableOn (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s
{K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] (s : Submodule K V) : FiniteDimensional.finrank K (V ⧸ s) + FiniteDimensional.finrank K ↥s = FiniteDimensional.finrank K V
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (e : LocalHomeomorph α β) {f : β → γ} {s : Set β} {x : β} (h : x ∈ e.to_local_equiv.target) : ContinuousWithinAt f s x ↔ ContinuousWithinAt (f ∘ ⇑e) (⇑e ⁻¹' s) (⇑(e.symm) x)
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] {x : B} [Nontrivial A] (hx : IsIntegral A x) : minpoly A x ≠ 0
{α : Type u_1} {β : Type u_2} {s : Set α} {t : α → Set β} {x : α} {y : β} (xs : x ∈ s) (ytx : y ∈ t x) : y ∈ ⋃ (x : α) (H : x ∈ s), t x
(p : ℕ) {Idx : Type u_2} [hp : Fact (Nat.Prime p)] (Φ : MvPolynomial Idx ℚ) (n : ℕ) : witt_structure_rat p Φ n = ⇑MvPolynomial.c (1 / ↑p ^ n) * (⇑(mv_polynomial.bind₁ (λ (b : Idx), ⇑(MvPolynomial.rename (λ (i : ℕ), (b, i))) (WittPolynomial p ℚ n))) Φ - (Finset.range n).sum (λ (i : ℕ), ⇑MvPolynomial.c (↑p ^ i) * witt_structure_rat p Φ i ^ p ^ (n - i)))
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [StrictConvexSpace ℝ E] {x y z : E} {a b r : ℝ} (hx : x ∈ Metric.ClosedBall z r) (hy : y ∈ Metric.ClosedBall z r) (hne : x ≠ y) (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : a • x + b • y ∈ Metric.Ball z r
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {f : α → β × γ} {x : α} (hF : ContinuousAt f x) : ContinuousAt (λ (a : α), (f a).snd) x
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup V1] [Module k V1] [AddTorsor V1 P1] [AddCommGroup V2] [Module k V2] [AddTorsor V2 P2] (f : P1 →ᵃ[k] P2) (p : P1) (v : V1) : ⇑f (v +ᵥ p) = ⇑(f.linear) v +ᵥ ⇑f p
{R : Type u_1} {R₁ : Type u_2} {R₂ : Type u_3} {M₁ : Type u_6} {M₂ : Type u_7} [CommSemiring R] [CommSemiring R₁] [AddCommMonoid M₁] [Module R₁ M₁] [CommSemiring R₂] [AddCommMonoid M₂] [Module R₂ M₂] {I₁ : R₁ →+* R} {I₂ : R₂ →+* R} {B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] R} : B.separating_Right ↔ B.flip.ker = ⊥
{C : Type u₁} [CategoryTheory.Category C] {X Y : C} (f : X ⟶ Y) [CategoryTheory.RegularMono f] [e : CategoryTheory.Epi f] : CategoryTheory.IsIso f
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [InnerProductSpace 𝕜 G] [FiniteDimensional 𝕜 E] [FiniteDimensional 𝕜 F] [FiniteDimensional 𝕜 G] (A : F →ₗ[𝕜] G) (B : E →ₗ[𝕜] F) : ⇑LinearMap.adjoint (A.comp B) = (⇑LinearMap.adjoint B).comp (⇑LinearMap.adjoint A)
{G : Type u_1} [CommGroup G] : group.nilpotency_class G ≤ 1
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b : α} : -a < b → -b < a
{F : Type u_3} [InnerProductSpace ℝ F] {ι₁ : Type u_1} {s₁ : Finset ι₁} {w₁ : ι₁ → ℝ} (v₁ : ι₁ → F) (h₁ : s₁.sum (λ (i : ι₁), w₁ i) = 0) {ι₂ : Type u_2} {s₂ : Finset ι₂} {w₂ : ι₂ → ℝ} (v₂ : ι₂ → F) (h₂ : s₂.sum (λ (i : ι₂), w₂ i) = 0) : HasInner.inner (s₁.sum (λ (i₁ : ι₁), w₁ i₁ • v₁ i₁)) (s₂.sum (λ (i₂ : ι₂), w₂ i₂ • v₂ i₂)) = -s₁.sum (λ (i₁ : ι₁), s₂.sum (λ (i₂ : ι₂), w₁ i₁ * w₂ i₂ * (∥v₁ i₁ - v₂ i₂∥ * ∥v₁ i₁ - v₂ i₂∥))) / 2
{E : Type u_2} [SemiNormedGroup E] [NormedSpace ℝ E] {s : Set E} (hs : Convex ℝ s) : ConvexOn ℝ s HasNorm.norm
{α : Type u_1} [HasLt α] {a b : α} : a ⋖ b → ⇑order_dual.to_dual b ⋖ ⇑order_dual.to_dual a
{R S : Type u} [CommRing R] [CommRing S] (M : Submonoid R) (S' : Type u) [CommRing S'] [Algebra S S'] [Algebra R S] [Algebra R S'] [IsScalarTower R S S'] [IsLocalization (Submonoid.map ↑(Algebra_Map R S) M) S'] (x : S) (s : Finset S') (hx : ⇑(Algebra_Map S S') x ∈ Algebra.adjoin R ↑s) : ∃ (m : ↥M), m • x ∈ Algebra.adjoin R ↑(is_localization.finset_integer_multiple (Submonoid.map ↑(Algebra_Map R S) M) s)
{ι : Type u_1} {M : Type u_4} {N : Type u_5} [AddCommMonoid M] [OrderedAddCommMonoid N] (f : M → N) (p : M → Prop) (h_One : f 0 = 0) (h_Mul : ∀ (x y : M), p x → p y → f (x + y) ≤ f x + f y) (hp_Mul : ∀ (x y : M), p x → p y → p (x + y)) (g : ι → M) {s : Finset ι} (hs : ∀ (i : ι), i ∈ s → p (g i)) : f (s.sum (λ (i : ι), g i)) ≤ s.sum (λ (i : ι), f (g i))
{M : Type u_1} [AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [AddCommMonoid N] (f : S.localization_Map N) : f.of_AddEquiv_of_Dom _ = f
(n : ℕ) (R : Type u_1) (hpos : 0 < n) [Ring R] [Nontrivial R] : 0 < (Polynomial.cyclotomic n R).degree
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} {s t : Set α} (hst : Disjoint s t) (hs : (s ∩ Function.Support f).finite) (ht : (t ∩ Function.Support f).finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s ∪ t), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ t), f i))
{𝕜 : Type u_3} {E : Type u_4} [NormedField 𝕜] [AddCommGroup E] [NormedSpace ℝ 𝕜] [Module 𝕜 E] [Module ℝ E] [IsScalarTower ℝ 𝕜 E] (p : Seminorm 𝕜 E) (x : E) (r : ℝ) : Convex ℝ (p.ball x r)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : HasInner.inner (x + y) (x + y) + HasInner.inner (x - y) (x - y) = 2 * (HasInner.inner x x + HasInner.inner y y)
{C : Type u} [CategoryTheory.Category C] (J₁ : CategoryTheory.GrothendieckTopology C) {X Y : C} (f : Y ⟶ X) (S : CategoryTheory.Sieve X) : J₁.close (CategoryTheory.Sieve.pullback f S) = CategoryTheory.Sieve.pullback f (J₁.close S)
{α : Type u_2} [Bornology α] {s : Set α} : Bornology.IsCobounded sᶜ → Bornology.IsBounded s
{p : ℕ} [hp : Fact (Nat.Prime p)] (x : WittVector p (Zmod p)) : ⇑WittVector.verschiebung x = x * ↑p
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} {s₁ s₂ : Affine.Simplex ℝ P n} (h : Set.Range s₁.points = Set.Range s₂.points) : s₁.circumcenter = s₂.circumcenter
{𝕂 : Type u_1} {𝔸 : Type u_2} [is_R_or_C 𝕂] [NormedCommRing 𝔸] [NormedAlgebra 𝕂 𝔸] [CompleteSpace 𝔸] {x y : 𝔸} : Exp 𝕂 (x + y) = Exp 𝕂 x * Exp 𝕂 y
{n : ℕ} {α : Fin (n + 1) → Type u} (x : α 0) (p : Π (i : Fin n), α i.succ) (z : α 0) : Function.update (fin.cons x p) 0 z = fin.cons z p
{ι : Type u_1} {α : ι → Type u_2} [Fintype ι] [DecidableEq ι] [Π (i : ι), DecidableEq (α i)] {p : (Π (i : ι), Finset (α i)) → Prop} (f : Π (i : ι), Finset (α i)) (h0 : p (λ (_x : ι), ∅)) (step : ∀ (g : Π (i : ι), Finset (α i)) (i : ι) (x : α i), x ∉ g i → p g → p (Function.update g i (HasInsert.insert x (g i)))) : p f
{α : Type u_1} {β : Type u_2} [DecidableEq α] [DecidableEq β] (f : α → β) (s : Multiset α) (hF : Function.Injective f) (x : α) : Multiset.count (f x) (Multiset.map f s) = Multiset.count x s
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K₁ K₂ : Submodule 𝕜 E} (h : K₁ ≤ K₂) : K₂ᗮ ≤ K₁ᗮ
{G : Type u_7} [CommGroup G] (L : List G) (n : ℕ) (a : G) : (L.update_nth n a).prod = L.prod * dite (n < L.length) (λ (hn : n < L.length), (L.nth_LE n hn)⁻¹ * a) (λ (hn : ¬n < L.length), 1)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} {p : ι → P} (hp : AffineIndependent k p) (j : ι) (w : ι → kˣ) : AffineIndependent k (λ (i : ι), ⇑(affine_map.line_Map (p j) (p i)) ↑(w i))
{α : Type u_2} [DecidableEq α] [has_Inv α] {s : Finset α} : s⁻¹.nonempty → s.nonempty
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {E : Type w} [NormedGroup E] [NormedSpace 𝕜 E] {f : 𝕜 → F} {f' : F} (x : 𝕜) {s : Set 𝕜} {l : F → E} {l' : F →L[𝕜] E} {t : Set F} (hl : HasFderivWithinAt l l' t (f x)) (hF : HasDerivWithinAt f f' s x) (hst : Set.MapsTo f s t) : HasDerivWithinAt (l ∘ f) (⇑l' f') s x
{α : Type u} [PseudoMetricSpace α] (x y : α) : HasNndist.nndist x y = (HasEdist.edist x y).to_Nnreal
{m : Type u_1} (R : Type u_3) {S : Type u_4} [Fintype m] [DecidableEq m] [CommSemiring R] [CommSemiring S] [Algebra R S] (A : Matrix m m S) : ⇑((MvPolynomial.aeval (λ (p : m × m), A p.fst p.snd)).map_Matrix) (matrix.mv_Polynomial.x m m R) = A
{M₀ : Type u_1} [MulZeroOneClass M₀] : 0 = 1 ↔ Subsingleton M₀
{c : Cardinal} (h : Cardinal.aleph_0 ≤ c) : c * c = c
{E : Type u_1} [NormedGroup E] {a : ℝ} {f g : ℂ → E} {l : Filter ℂ} (hBf : ∃ (c : ℝ) (H : c < a) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ l] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hBg : ∃ (c : ℝ) (H : c < a) (B : ℝ), g =O[Filter.comap Complex.abs filter.at_Top ⊓ l] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) : ∃ (c : ℝ) (H : c < a) (B : ℝ), (f - g) =O[Filter.comap Complex.abs filter.at_Top ⊓ l] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)
{α : Type u} {s t : Set α} {l : Filter α} : (∀ᶠ (x : α) in l, x ∈ s ↔ x ∈ t) → s =ᶠ[l] t
{X Y : CompHaus} (f : X ⟶ Y) : IsClosedMap ⇑f
{G : Type u_10} {H : Type u_11} [Group G] [DivisionMonoid H] (h : G ≃* H) (x y : G) : ⇑h (x / y) = ⇑h x / ⇑h y
{α : Type u_1} {β : Type u_2} {e e' : LocalEquiv α β} (h : e ≈ e') : e.source = e'.source
{X : Type u} {α : Type v} [TopologicalSpace X] [LinearOrder α] [TopologicalSpace α] [OrderClosedTopology α] {s : Set X} (hs : IsPreconnected s) {a b : X} (ha : a ∈ s) (hb : b ∈ s) {f g : X → α} (hF : ContinuousOn f s) (hg : ContinuousOn g s) (ha' : f a ≤ g a) (hb' : g b ≤ f b) : ∃ (x : X) (H : x ∈ s), f x = g x
{z w : ℂ} (hz : 0 ≤ z.re ∨ z.im ≠ 0) (hw : 0 < w.re) : ContinuousAt (λ (x : ℂ), x ^ w) z
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} (hab : a ≤ b) (hcont : ContinuousOn f (Set.Icc a b)) (hderiv : ∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivAt f (f' x) x) (hint : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b) : ∫ (y : ℝ) in a..b, f' y = f b - f a
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β → γ} {ta1 ta2 : TopologicalSpace α} {tb1 tb2 : TopologicalSpace β} {Tc1 : TopologicalSpace γ} (h : Continuous (λ (p : α × β), f p.fst p.snd)) : Continuous (λ (p : α × β), f p.fst p.snd)
{C : Type u₁} [CategoryTheory.SmallCategory C] {P₁ P₂ : Cᵒᵖ ⥤ Type u₁} (α : P₁ ⟶ P₂) (j : (P₁.elements)ᵒᵖ) : (Category_theory.cocone_of_representable P₁).ι.app j ≫ α = (Category_theory.cocone_of_representable P₂).ι.app ((CategoryTheory.Category_of_elements.map α).op.obj j)
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] [NormalSpace Y] (f : C(X, ℝ)) (e : X → Y) (hE : ClosedEmbedding e) : ∃ (g : C(Y, ℝ)), ⇑g ∘ e = ⇑f
{p : ℕ} (hp : Nat.Prime p) {n b : ℕ} : Nat.log p n < b → multiplicity p n.factorial = ↑((Finset.ico 1 b).sum (λ (i : ℕ), n / p ^ i))
(G : Type u_1) [Group G] : group.is_nilpotent G ↔ ∃ (n : ℕ) (H : ℕ → Subgroup G), IsAscendingCentralSeries H ∧ H n = ⊤
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f g : α → M} {s : Set α} (hs : s.finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i * g i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ s), g i))
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [FiniteDimensional 𝕜 E] (T : E →ₗ[𝕜] E) (x : E) : 0 ≤ ⇑is_R_or_C.re (HasInner.inner x (⇑(⇑LinearMap.adjoint T * T) x))
(𝕜 : Type u_5) (E : Type u_6) [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [Nontrivial E] (c : ℝ) : ∃ (x : E), c < ∥x∥
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {s : Set 𝕜} {n : WithTop ℕ} (hs : UniqueDiffOn 𝕜 s) : ContDiffOn 𝕜 n f s ↔ (∀ (m : ℕ), ↑m ≤ n → ContinuousOn (iterated_deriv_within m f s) s) ∧ ∀ (m : ℕ), ↑m < n → DifferentiableOn 𝕜 (iterated_deriv_within m f s) s
{α : Type u} {β : Type v} [Preorder β] {f : α → β} {l : Filter α} {a : α} : IsMinFilter f l a → IsMaxFilter (⇑order_dual.to_dual ∘ f) l a
{B : Type u_3} {S : B} {M : Type u_1} [AddCommMonoid M] [SetLike B M] [AddSubmonoidClass B M] {ι : Type u_2} {t : Finset ι} {f : ι → M} (h : ∀ (c : ι), c ∈ t → f c ∈ S) : t.sum (λ (c : ι), f c) ∈ S
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] [Nontrivial E] [FiniteDimensional ℂ E] {f : E → F} {U : Set E} (hb : Metric.Bounded U) (hne : U.nonempty) (hD : DiffContOnCl ℂ f U) : ∃ (z : E) (H : z ∈ Frontier U), IsMaxOn (HasNorm.norm ∘ f) (Closure U) z
{α : Type u_1} [CompleteLattice α] {a : α} {s : Set α} : (⨆ (b : α) (H : b ∈ s), b ⊓ a) ≤ HasSup.sup s ⊓ a
{α : Type u_3} [LinearOrderedAddCommGroup α] : Filter.Tendsto HasAbs.abs filter.at_Top filter.at_Top
{α : Type u_1} {β : Type u_2} [UniformSpace α] [AddGroup α] [UniformAddGroup α] {hom : Type u_3} [UniformSpace β] [AddGroup β] [UniformAddGroup β] [AddMonoidHomClass hom α β] (f : hom) (hF : ContinuousAt ⇑f 0) : UniformContinuous ⇑f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] (p : P) (s1 s2 : AffineSubspace k P) : p ∈ s1 ⊓ s2 ↔ p ∈ s1 ∧ p ∈ s2
(n : ℕ) {m : ℝ} (m1 : 1 < m) : ∑' (i : ℕ), 1 / m ^ (i + (n + 1)).factorial < (1 - 1 / m)⁻¹ * (1 / m ^ (n + 1).factorial)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {v : ℝ → E → E} {K : Nnreal} (hv : ∀ (t : ℝ), LipschitzWith K (v t)) {f g : ℝ → E} {a b δ : ℝ} (hF : ContinuousOn f (Set.Icc a b)) (hF' : ∀ (t : ℝ), t ∈ Set.Ico a b → HasDerivWithinAt f (v t (f t)) (Set.Ici t) t) (hg : ContinuousOn g (Set.Icc a b)) (hg' : ∀ (t : ℝ), t ∈ Set.Ico a b → HasDerivWithinAt g (v t (g t)) (Set.Ici t) t) (ha : HasDist.dist (f a) (g a) ≤ δ) (t : ℝ) (H : t ∈ Set.Icc a b) : HasDist.dist (f t) (g t) ≤ δ * Real.exp (↑K * (t - a))
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (w : ι → k) (p : ι → P) (b : P) {s₁ s₂ : Finset ι} (h : s₁ ⊆ s₂) : ⇑(s₁.weighted_vsub_of_point p b) w = ⇑(s₂.weighted_vsub_of_point p b) (↑s₁.indicator w)
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} {E' : Type u_3} [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 E'] (f : E ≃ₗᵢ[𝕜] E') (K : Submodule 𝕜 E) [CompleteSpace ↥K] : reflection (Submodule.map ↑(f.to_LinearEquiv) K) = f.symm.trans ((reflection K).trans f)
{X : Type u_2} [EmetricSpace X] [MeasurableSpace X] [BorelSpace X] {β : Type u_1} {ι : β → Type u_3} [hι : Π (n : β), Encodable (ι n)] (d : ℝ) (s : Set X) {l : Filter β} (r : β → Ennreal) (hr : Filter.Tendsto r l (nhds 0)) (t : Π (n : β), ι n → Set X) (ht : ∀ᶠ (n : β) in l, ∀ (i : ι n), Emetric.diam (t n i) ≤ r n) (hst : ∀ᶠ (n : β) in l, s ⊆ ⋃ (i : ι n), t n i) : ⇑(measure_theory.measure.hausdorff_measure d) s ≤ l.liminf (λ (n : β), ∑' (i : ι n), Emetric.diam (t n i) ^ d)
(R : Type u) [CommRing R] [is_IsDomain R] [DiscreteValuationRing R] : ∃ (ϖ : R), Prime ϖ
{M : Type u_1} [SemiNormedGroup M] (S : AddSubgroup M) (m : M) : ∥⇑(QuotientAddGroup.mk' S) m∥ ≤ ∥m∥
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q) [CategoryTheory.Mono f] : Function.Injective ⇑f
{L : FirstOrder.Language} {M : Type w} [L.Structure M] (S : L.substructure M) : ⇑(FirstOrder.Language.Substructure.closure L) ↑S = S
{J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.IsCofiltered J] {F : J ⥤ Profinite} (C : CategoryTheory.Limits.Cone F) (hC : CategoryTheory.Limits.IsLimit C) {U : Set ↥(C.X)} (hU : is_IsClopen U) : ∃ (j : J) (V : Set ↥(F.obj j)) (hV : is_IsClopen V), U = ⇑(C.π.app j) ⁻¹' V
{M : Type u_2} [AddCommGroup M] {A : Type u_1} [CommRing A] [Module A M] (f : M ≃ₗ[A] M) : IsUnit (⇑LinearMap.det ↑f)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (s : Set P) : s -ᵥ s ⊆ ↑(Vector_Span k s)
{M : Type u_1} {R : Type u_4} [NonUnitalNonAssocSemiring R] [SetLike M R] [MulMemClass M R] {S : M} {a b : R} (ha : a ∈ AddSubmonoid.closure ↑S) (hb : b ∈ AddSubmonoid.closure ↑S) : a * b ∈ AddSubmonoid.closure ↑S
{α : Type u_1} [DecidableEq α] {𝒜 : Finset (Finset α)} {s : Finset α} : s ∈ 𝒜.shadow ↔ ∃ (t : Finset α) (H : t ∈ 𝒜), s ⊆ t ∧ t.card = s.card + 1
{R : Type u_2} [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R] [Nontrivial R] [NormalizationMonoid R] [DecidableEq R] [dec_Dvd : DecidableRel has_dvd.dvd] {a b : R} (ha : Irreducible a) (hb : b ≠ 0) : multiplicity a b = ↑(Multiset.count (⇑normalize a) (Unique_factorization_monoid.normalized_Factors b))
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] {ps : Set P} (hps : ps ⊆ ↑s) (p : P) : (∃ (r : ℝ), ∀ (p1 : P), p1 ∈ ps → HasDist.dist p1 p = r) ↔ ∃ (r : ℝ), ∀ (p1 : P), p1 ∈ ps → HasDist.dist p1 ↑(⇑(euclidean_geometry.orthogonal_projection s) p) = r
{𝕂 : Type u_1} {𝔸 : Type u_2} [is_R_or_C 𝕂] [NormedCommRing 𝔸] [NormedAlgebra 𝕂 𝔸] [CompleteSpace 𝔸] {ι : Type u_3} (s : Finset ι) (f : ι → 𝔸) : Exp 𝕂 (s.sum (λ (i : ι), f i)) = s.prod (λ (i : ι), Exp 𝕂 (f i))
{α : Type u} [PseudoEmetricSpace α] {x : α} {s t : Set α} : emetric.inf_edist x (s ∪ t) = emetric.inf_edist x s ⊓ emetric.inf_edist x t
(x : ℝ) (h : Real.cos x ≠ 0) : deriv (λ (y : ℝ), Real.tan y - y) x = 1 / Real.cos x ^ 2 - 1
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {s : Set E} {t : Set F} {g : F → G} {f : E → F} (hg : ContDiffOn 𝕜 n g t) (hF : ContDiffOn 𝕜 n f s) (st : s ⊆ f ⁻¹' t) : ContDiffOn 𝕜 n (g ∘ f) s
{ι : Type u_1} {ι' : Type u_2} {R : Type u_5} {M : Type u_6} [CommSemiring R] [AddCommMonoid M] [Module R M] [Fintype ι'] [Fintype ι] [DecidableEq ι] [DecidableEq ι'] (b : Basis ι R M) (v : ι' → M) (e : ι ≃ ι') : (b.reindex e).to_Matrix v = ⇑(Matrix.reindex_AlgEquiv R e) (b.to_Matrix (v ∘ ⇑e))
{X : Type u_2} [EmetricSpace X] (s : Finset X) : dimH ↑s = 0
{α : Type u} {f g : α → α} {x : α} (hF : Function.IsFixedPt f x) (h : Function.LeftInverse g f) : Function.IsFixedPt g x
{R : Type u} [CommRing R] [is_IsDomain R] [IsPrincipalIdealRing R] [GcdMonoid R] (a b : R) : ∃ (x y : R), GcdMonoid.gcd a b = a * x + b * y
(R : Type u_1) [CommRing R] (ι : Type u_2) [Fintype ι] : Algebra.FinitePresentation R (MvPolynomial ι R)
{n : ℕ} {α : Type u_1} [Preorder α] {f : Fin (n + 1) → α} : StrictAnti f ↔ ∀ (i : Fin n), f i.succ < f (⇑fin.cast_Succ i)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {b₂ : Basis (Fin 2) ℝ V} (hb₂ : Orthonormal ℝ ⇑b₂) (ho : b.orientation = -b₂.orientation) (x y : V) : hb.oangle x y = -hb₂.oangle x y
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : ℝ → E} {f' : E} {s : Set ℝ} {x r : ℝ} (hF : HasDerivWithinAt f f' s x) (hr : ∥f'∥ < r) : ∀ᶠ (z : ℝ) in nhds_within x s, ∥z - x∥⁻¹ * ∥f z - f x∥ < r
{α : Type u_1} {r : α → α → Prop} {s : Setoid α} (h : ∀ (x y : α), r x y → s.rel x y) : EqvGen.setoid r ≤ s
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x y : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall f p x r) (h : y ∈ Emetric.Ball x r) : AnalyticAt 𝕜 f y
{x : Pgame} : x.lf 0 ↔ ∃ (j : x.right_moves), ∀ (i : (x.move_Right j).left_moves), ((x.move_Right j).move_Left i).lf 0
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) {r : ℝ} (hr : r < 0) : o.oangle (r • x) y = o.oangle (-x) y
{ι : Type u_1} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {G : ι → Type u_4} [Π (i : ι), InnerProductSpace 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 V) [∀ (i : ι), CompleteSpace (G i)] : hV.linear_isometry.to_LinearMap.range = (⨆ (i : ι), (V i).to_LinearMap.range).topological_Closure
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ : Real.Angle) : ⇑LinearEquiv.det (o.rotation θ).to_LinearEquiv = 1
{α : sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop} : (∀ (x : α) (h : p x), q x h) ↔ ∀ (x : {a // p a}), q ↑x _
{G : Type u} [Monoid G] : IsOfFinOrder 1
{n : ℤ} (hn : n ≠ -1) (c w : ℂ) (R : ℝ) : ∮ (z : ℂ) in C(c, R), (z - w) ^ n = 0
{M : Type u_3} {N : Type u_4} [HasMul M] [HasMul N] {f g : M →ₙ* N} : f = g ↔ ∀ (x : M), ⇑f x = ⇑g x
{α : Type u} (s : Set (Set α)) : Cardinal.mk ↥{t : Set α | MeasurableSet t} ≤ Linear_order.max (Cardinal.mk ↥s) 2 ^ Cardinal.aleph_0
{V₁ : Type u_2} {V₂ : Type u_3} [SemiNormedGroup V₁] [SemiNormedGroup V₂] (f : NormedGroupHom V₁ V₂) (x : V₁) : ∥⇑f x∥ ≤ ∥f∥ * ∥x∥
{α : Type u_1} [Monoid α] {a b : α} {u : αˣ} : a ∣ b * ↑u ↔ a ∣ b
 : Orthonormal ℂ (fourier_Lp 2)
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] {A B : Matrix n n α} (h : B.mul A = 1) : A⁻¹ = B
{M₀ : Type u_1} [MulZeroClass M₀] : has_mul.mul 0 = Function.const M₀ 0
{R : Type u_1} [LinearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] [NoZeroSmulDivisors R M] {v : M} (hv : v ≠ 0) {r : R} (hr : r ≠ 0) : SameRay R v (r • v) ↔ 0 < r
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {f : E × F → G} (h : IsBoundedBilinearMap 𝕜 f) : IsBoundedLinearMap 𝕜 (λ (p : E × F), h.deriv p)
{R : Type u_1} {M : Type u_5} {n : Type u_14} [CommRing R] [AddCommGroup M] [Module R M] [NoZeroDivisors R] {B : M →ₗ[R] M →ₗ[R] R} (v : Basis n R M) (hO : B.is_Ortho ⇑v) (h : ∀ (i : n), ¬B.is_IsOrtho (⇑v i) (⇑v i)) : B.separating_Right
{p x : ℝ} {r : ℚ} (hr : r ≠ 0) : LiouvilleWith p (↑r * x) ↔ LiouvilleWith p x
{α : Type u_1} [HasSup α] [HasInf α] (Sup_comm : ∀ (a b : α), a ⊔ b = b ⊔ a) (Sup_assoc : ∀ (a b c : α), a ⊔ b ⊔ c = a ⊔ (b ⊔ c)) (Sup_idem : ∀ (a : α), a ⊔ a = a) (Inf_comm : ∀ (a b : α), a ⊓ b = b ⊓ a) (Inf_assoc : ∀ (a b c : α), a ⊓ b ⊓ c = a ⊓ (b ⊓ c)) (Inf_idem : ∀ (a : α), a ⊓ a = a) (Sup_Inf_self : ∀ (a b : α), a ⊔ a ⊓ b = a) (Inf_Sup_self : ∀ (a b : α), a ⊓ (a ⊔ b) = a) : semilattice_sup.to_PartialOrder α = semilattice_inf.to_PartialOrder α
{α : Type u} (s : Set α) : is_IsOpen {u : Ultrafilter α | s ∈ u}
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {v : V} (p : P) {direction : Submodule k V} (hv : v ∈ direction) : v +ᵥ p ∈ AffineSubspace.mk' p direction
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [SemiNormedGroup E'] {g : α → F} {f' : α → E'} {l : Filter α} : f' =o[l] g → (λ (x : α), -f' x) =o[l] g
{α : Type u} [OrderedSemiring α] [Nontrivial α] : 0 < 1
{α : Type u_1} {β : Type u_2} [Group α] [DivisionMonoid β] (f : α →* β) (g h : α) : ⇑f (g * h⁻¹) = ⇑f g * (⇑f h)⁻¹
{M : Type u_1} [MulOneClass M] {s : Set M} : s ⊆ ↑(Submonoid.closure s)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {s : Set 𝕜} {n : WithTop ℕ} (h : ∀ (m : ℕ), ↑m ≤ n → DifferentiableOn 𝕜 (iterated_deriv_within m f s) s) : ContDiffOn 𝕜 n f s
{α : Type u_1} {β : Type u_2} {f g : α → β} {m : MeasurableSpace α} {mβ : MeasurableSpace β} [MeasurableSingletonClass α] (hF : Measurable f) (h : {x : α | f x ≠ g x}.countable) : Measurable g
{α : Type u} {β : Type v} [HasMul α] [HasMul β] {γ : Type u_1} [HasMul γ] {f : α → β} {g : β → γ} (hF : IsMulHom f) (hg : IsMulHom g) : IsMulHom (g ∘ f)
{α : Type u} {β : Type v} [MulOneClass α] [MulOneClass β] {f : α → β} (hF : IsMonoidHom f) {γ : Type u_1} [MulOneClass γ] {g : β → γ} (hg : IsMonoidHom g) : IsMonoidHom (g ∘ f)
{M : Type u_1} [has_Add M] {s : Set M} {S : AddSubsemigroup M} : AddSubsemigroup.closure s ≤ S ↔ s ⊆ ↑S
{M : Type u_1} [MulOneClass M] {N : Type u_2} [MulOneClass N] (f : M →* N) (hF : Function.Surjective ⇑f) : f.mrange = ⊤
{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {α : ↥(IsSolvableByRad F E)} {n : ℕ} (hn : n ≠ 0) (hα : solvable_by_rad.P (α ^ n)) : solvable_by_rad.P α
{α : Type u_1} [GeneralizedBooleanAlgebra α] {f d : ℕ → α} (hdisj : Pairwise (Disjoint on d)) (hsups : partial_sups d = partial_sups f) : d = disjointed f
{X : Type u_1} {m : Type u_4} {n : Type u_5} {p : Type u_6} {R : Type u_8} [TopologicalSpace X] [TopologicalSpace R] [Fintype n] [HasMul R] [AddCommMonoid R] [HasContinuousAdd R] [HasContinuousMul R] {A : X → Matrix m n R} {B : X → Matrix n p R} (hA : Continuous A) (hB : Continuous B) : Continuous (λ (x : X), (A x).mul (B x))
 : Finset.Nat.antidiagonal 0 = {(0, 0)}
{β : Type u} {α : Type v} {γ : Type w} [NonAssocSemiring β] [NonAssocSemiring γ] (g : β →+* γ) (f : α → β) (s : Finset α) : ⇑g (s.sum (λ (x : α), f x)) = s.sum (λ (x : α), ⇑g (f x))
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) : o.rotation 0 = LinearIsometryEquiv.refl ℝ V
{α : Type u_3} [SemilatticeInf α] (a : α) : filter.at_IsBot = Filter.comap Coe filter.at_IsBot
{α : Type u} {L : List (α × Bool)} : FreeGroup.Red List.nil L ↔ L = List.nil
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) : 0 ∈ S
{α : Type u} [CompleteLattice α] {J : Type u} [CategoryTheory.SmallCategory J] (F : J ⥤ α) : CategoryTheory.Limits.limit F = infi F.obj
{M : Type u_3} {N : Type u_4} [HasZero M] [HasZero N] (f : ZeroHom M N) {x y : M} (h : x = y) : ⇑f x = ⇑f y
{α : Type u} [Group α] [HasLe α] [CovariantClass α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1
{M : Type u_3} {S : Type u_4} [SubNegMonoid M] [SetLike S M] [hSM : AddSubgroupClass S M] {H : S} {x y : M} (hx : x ∈ H) (hy : y ∈ H) : x - y ∈ H
{α : Type u_1} [MeasurableSpace α] {f g : α → ℝ} {s : Set α} (hF : Measurable f) (hg : Measurable g) (hs : MeasurableSet s) : MeasurableSet (RegionBetween f g s)
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {x : E} (hx : x ≠ 0) : ∥(↑∥x∥)⁻¹ • x∥ = 1
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] {a : α} : -a < 0 ↔ 0 < a
{n m : ℕ} (h : n = m) : ⇑(fin.cast h) = cast _
{m : Type u_2} {n : Type u_3} (R : Type u_11) [CommRing R] [Fintype m] [DecidableEq m] [Fintype n] [DecidableEq n] (e : m ≃ n) (A : Matrix m m R) : (⇑(Matrix.reindex_AlgEquiv R e) A).det = A.det
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [CompactSpace α] [MetricSpace β] (x : α) : Continuous (λ (f : C(α, β)), ⇑f x)
{α : sort u_1} {γ : sort u_4} {r : α → α → Prop} (f : α → γ) (h : ∀ (a₁ a₂ : α), r a₁ a₂ → f a₁ = f a₂) (a : α) : Quot.lift f h (Quot.mk r a) = f a
{α : Type u} [NonUnitalNonAssocRing α] (k : α) (h : ∀ (x : α), k * x = 0 → x = 0) : IsLeftRegular k
{α : Type u} {β : Type v} [Group α] [MulAction α β] [HasFaithfulSmul α β] : Function.Injective Mul_action.to_perm
(R : Type u_1) {M : Type u_4} (S : Type u_7) [Semiring R] [AddCommMonoid M] [Module R M] (s : Set M) [Semiring S] [HasScalar R S] [Module S M] [IsScalarTower R S M] : ↑(Submodule.span R s) ⊆ ↑(Submodule.span S s)
{F : Type u_3} [InnerProductSpace ℝ F] (x : F) (r : ℝ) : HasInner.inner (r • x) x = r * (∥x∥ * ∥x∥)
{α : Type u} {β : Type v} {f : α → β} {l₁ : Filter α} {l₂ : Filter β} : Filter.Tendsto f l₁ l₂ → l₁ ≤ Filter.comap f l₂
{a b : ℝ} {f f' g : ℝ → ℝ} (h : ∀ (x : ℝ), x ∈ Set.Interval a b → HasDerivAt f (f' x) x) (h' : ContinuousOn f' (Set.Interval a b)) (hg : Continuous g) : ∫ (x : ℝ) in a..b, (g ∘ f) x * f' x = ∫ (x : ℝ) in f a..f b, g x
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (s : Finset ι) [CharZero k] [Fintype ι] (h : s.nonempty) : finset.univ.sum (λ (i : ι), Finset.centroid_weights_indicator k s i) = 1
{M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : AddZeroClass M} {mN : AddZeroClass N} [AddMonoidHomClass F M N] (f : F) {x : M} (hx : ∃ (y : M), y + x = 0) : ∃ (y : N), y + ⇑f x = 0
{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] {s : Set E} (hs : Convex 𝕜 s) {a b : 𝕜} (ha : 0 < a) (hb : 0 ≤ b) (hab : a + b = 1) : a • Interior s + b • s ⊆ Interior s
{α : Type u_1} [Preorder α] {a b : α} (h : a ≤ b) : ¬a ⩿ b ↔ ∃ (c : α), a < c ∧ c < b
{G : Type u_1} [Group G] {N : Type u_3} [Group N] (f : G →* N) {H K : Subgroup G} (hH : f.ker ≤ H) (hK : f.ker ≤ K) (hF : Subgroup.map f H = Subgroup.map f K) : H = K
{α : Type u} [Group α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] {a b c : α} : a < b * c → b⁻¹ * a < c
(K : Type u) [DivisionRing K] {ι : Type v} [Fintype ι] : FiniteDimensional.finrank K (ι → K) = Fintype.card ι
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] (s : Submodule K V) : FiniteDimensional.finrank K ↥s ≤ FiniteDimensional.finrank K V
{α : Type u} [PseudoEmetricSpace α] {x : α} {s t : Set α} : emetric.inf_edist x t ≤ emetric.inf_edist x s + emetric.Hausdorff_edist s t
{p : ℕ} {R : Type u_1} [hp : Fact (Nat.Prime p)] [CommRing R] (x : WittVector p R) : ⇑WittVector.frobenius (⇑WittVector.verschiebung x) = x * ↑p
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_5} [NormedGroup E'] [NormedSpace 𝕜 E'] {n : WithTop ℕ} {f : E → E'} {s : Set E} {x : E} : ContDiffWithinAt 𝕜 n f s x → ContMdiffWithinAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f s x
{K : Type u_1} {v : K} {n : ℕ} [LinearOrderedField K] [FloorRing K] {ifp_n : GeneralizedContinuedFraction.IntFractPair K} (nth_Stream_Eq : GeneralizedContinuedFraction.IntFractPair.stream v n = Option.some ifp_n) : 0 ≤ ifp_n.fr
{G : Type u_1} [Group G] (K : Subgroup G) {l : List G} : (∀ (x : G), x ∈ l → x ∈ K) → l.prod ∈ K
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {δ : Type u_1} [LinearOrder δ] [TopologicalSpace δ] [OrderClosedTopology δ] {f : α → δ} {s : Set α} [s.ord_connected] (hs : s.nonempty) (hF : ContinuousOn f s) (hbot : Filter.Tendsto (λ (x : ↥s), f ↑x) filter.at_IsBot filter.at_Top) (htop : Filter.Tendsto (λ (x : ↥s), f ↑x) filter.at_Top filter.at_IsBot) : Set.SurjOn f s Set.Univ
{a : ℕ} : ↑(Nat.sqrt a) ≤ Real.sqrt ↑a
{C : Type u₁} [CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {P : Cᵒᵖ ⥤ Type v₁} (h : CategoryTheory.Presieve.IsSheafFor P ⇑S) (t₁ t₂ : Category_theory.yoneda.obj X ⟶ P) (ht : S.functor_inclusion ≫ t₁ = S.functor_inclusion ≫ t₂) : t₁ = t₂
{α : Type u} [TopologicalSpace α] {x : α} : Dense {x}ᶜ ↔ ¬is_IsOpen {x}
{G : Type u_7} [Group G] (L : List G) : L.reverse.prod = ((List.map (λ (x : G), x⁻¹) L).prod)⁻¹
{M : Type u_1} [HasMul M] {c d : Con M} {x y : M} : ⇑(c ⊓ d) x y ↔ ⇑c x y ∧ ⇑d x y
{𝕜 : Type u} {A : Type v} [Field 𝕜] [Ring A] [Algebra 𝕜 A] [Nontrivial A] (k : 𝕜) (a : A) (ha : (Spectrum 𝕜 a).nonempty) : Spectrum 𝕜 (k • a) = k • Spectrum 𝕜 a
{f : ℕ → ℝ} (hfa : Monotone f) (hF0 : Filter.Tendsto f filter.at_Top (nhds 0)) : CauchySeq (λ (n : ℕ), (Finset.range (n + 1)).sum (λ (i : ℕ), (-1) ^ i * f i))
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommGroup E] [HasScalar 𝕜 E] {S : ConvexCone 𝕜 E} : S.blunt → S.salient
{α : Type u_1} {β : Type u_2} {M : Type u_5} [AddCommMonoid M] {f : α → M} {g : β → α} (hg : Set.InjOn g (Function.Support (f ∘ g))) : finsum (λ (i : α), finsum (λ (H : i ∈ Set.Range g), f i)) = finsum (λ (j : β), f (g j))
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {n : WithTop ℕ} (h : ∀ (m : ℕ), ↑m ≤ n → Differentiable 𝕜 (iterated_deriv m f)) : ContDiff 𝕜 n f
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) : s.monge_point = (↑(n + 1) / ↑(n - 1)) • (Finset.centroid ℝ Finset.univ s.points -ᵥ s.circumcenter) +ᵥ s.circumcenter
(R : Type u) [CommRing R] [StrongRankCondition R] (M : Type v) (N : Type w) [AddCommGroup M] [Module R M] [Module.Free R M] [AddCommGroup N] [Module R N] [Module.Free R N] : FiniteDimensional.finrank R (TensorProduct R M N) = FiniteDimensional.finrank R M * FiniteDimensional.finrank R N
{R : Type u} [CommRing R] [is_IsDomain R] {p : Polynomial R} {a : R} {n : ℕ} (hzero : p ≠ 0) (h : (Polynomial.x - ⇑Polynomial.c a) ^ n ∣ p) : n ≤ polynomial.root_multiplicity a p
{ι : Type u_1} {α : Type u_2} [Fintype ι] [DecidableEq α] (t : ι → Finset α) : (∀ (s : Finset ι), s.card ≤ (s.bUnion t).card) ↔ ∃ (f : ι → α), Function.Injective f ∧ ∀ (x : ι), f x ∈ t x
{α : Type u_1} {β : Type u_2} {e e' : LocalEquiv α β} (h : e ≈ e') : Set.EqOn ⇑e ⇑e' e.source
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {r : ℝ} (r_Pos : 0 < r) (c : ℝ) (f : E →ₗ[𝕜] 𝕜) (h : ∀ (z : E), z ∈ Metric.ClosedBall 0 r → ∥⇑f z∥ ≤ c) (z : E) : ∥⇑f z∥ ≤ c / r * ∥z∥
{α : Type u} [EmetricSpace α] {s : Set α} (hs : is_IsClosed s) : is_IsClosed {t : TopologicalSpace.Closeds α | ↑t ⊆ s}
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {f : α → β} (hF : Continuous f) (x : α) (y : β) (h : f x = y) : Filter.Tendsto f (nhds x) (nhds y)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {n : WithTop ℕ} (h : ∀ (x : E), x ∈ s → (∃ (u : Set E), is_IsOpen u ∧ x ∈ u ∧ ContDiffOn 𝕜 n f (s ∩ u))) : ContDiffOn 𝕜 n f s
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X ⟶ Y} {t : CategoryTheory.Limits.Fork f g} (ht : CategoryTheory.Limits.IsLimit t) {Z Z' : C} (q : Z' ⟶ Z) (k : Z ⟶ t.X) : ↑(⇑(Category_theory.limits.fork.is_limit.hom_iso ht Z') (q ≫ k)) = q ≫ ↑(⇑(Category_theory.limits.fork.is_limit.hom_iso ht Z) k)
{𝕜 : Type u} [NondiscreteNormedField 𝕜] (f : LocalHomeomorph 𝕜 𝕜) {a f' : 𝕜} (ha : a ∈ f.to_local_equiv.target) (hF' : f' ≠ 0) (htff' : HasDerivAt ⇑f f' (⇑(f.symm) a)) : HasDerivAt ⇑(f.symm) f'⁻¹ a
{α : Type u} [TopologicalSpace α] [t1_Space α] {s : Set α} (hs : Dense s) (x : α) [(nhds_within x {x}ᶜ).ne_IsBot] : Dense (s  {x})
{α : Type u_1} [PartialOrder α] [OrderTop α] {a : α} : IsCoatom a → a ⋖ ⊤
{α : Type u} {β : Type v} [TopologicalSpace α] [PartialOrder α] [t : OrderTopology α] {f g h : β → α} {b : Filter β} {a : α} (hg : Filter.Tendsto g b (nhds a)) (hH : Filter.Tendsto h b (nhds a)) (hgf : ∀ᶠ (b : β) in b, g b ≤ f b) (hfh : ∀ᶠ (b : β) in b, f b ≤ h b) : Filter.Tendsto f b (nhds a)
{R : Type u_1} {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] : (∀ (f : ℕ →o (Submodule R M)ᵒᵈ), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ IsArtinian R M
{R : Type u_1} [CommSemiring R] {M : Submonoid R} {S : Type u_2} [CommSemiring S] [Algebra R S] {P : Type u_3} [CommSemiring P] [IsLocalization M S] {g : R →+* P} (hg : ∀ (y : ↥M), IsUnit (⇑g ↑y)) {x y : R} (h : ⇑(Algebra_Map R S) x = ⇑(Algebra_Map R S) y) : ⇑g x = ⇑g y
{R : Type u_1} {a : R} [CancelMonoidWithZero R] (a0 : a ≠ 0) : IsRegular a
{m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n
{A : Type u_1} {B : Type u_2} [CommRing A] [is_IsDomain A] [Ring B] [Algebra A B] {x : B} [is_IsDomain B] (hx : IsIntegral A x) : Irreducible (minpoly A x)
{V₁ : Type u_2} {V₂ : Type u_3} [SemiNormedGroup V₁] [SemiNormedGroup V₂] (f : V₁ →+ V₂) {C : ℝ} (hC : 0 ≤ C) (h : ∀ (x : V₁), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_NormedGroupHom C h∥ ≤ C
{ι : Type u_1} {α : Type u_2} {A : ι → Type u_3} [AddMonoid ι] [GradedMonoid.Gmonoid A] (l : List α) (f : α → GradedMonoid A) : (List.map f l).prod = GradedMonoid.mk (l.dprod_Index (λ (i : α), (f i).fst)) (l.dprod (λ (i : α), (f i).fst) (λ (i : α), (f i).snd))
{α : Type u_1} {R : Type u_2} {l : Filter α} {f : α → R} {r : R} [LinearOrderedSemiring R] [Archimedean R] (hr : 0 < r) (hF : Filter.Tendsto f l filter.at_Top) : Filter.Tendsto (λ (x : α), f x * r) l filter.at_Top
{α : Type u} [HasSubset α] {a b : α} [IsRefl α HasSubset.Subset] : a = b → b ⊆ a
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMinOrder α] [DenselyOrdered α] {a : α} {s : Set α} : s ∈ nhds_within a (Set.Iic a) ↔ ∃ (l : α) (H : l ∈ Set.Iio a), Set.Icc l a ⊆ s
(A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {p : Polynomial A} (hp : ⇑(Polynomial.aeval x) p = 0) : minpoly A x ∣ p
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} [DecidableEq α'] [DecidableEq γ] [DecidableEq δ] {f : α → β → γ} {s : Finset α} {t : Finset β} {g : γ → δ} {f' : β → α' → δ} {g' : α → α'} (h_antidistrib : ∀ (a : α) (b : β), g (f a b) = f' b (g' a)) : Finset.image g (Finset.image₂ f s t) = Finset.image₂ f' t (Finset.image g' s)
{α : Type u} [Group α] : IsGroupHom Id
{α : Type u_1} {β : Type u_2} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] {f : β → α} (hF : Continuous f) (x₀ : β) (h : ∀ᶠ (x : β) in Filter.cocompact β, f x ≤ f x₀) : ∃ (x : β), ∀ (y : β), f y ≤ f x
{α : Type u_1} {β : Type u_2} {s : Set α} {t : α → Set β} {y : β} (h : ∀ (x : α), x ∈ s → y ∈ t x) : y ∈ ⋂ (x : α) (H : x ∈ s), t x
(f : Circle_deg1_Lift) (P : ℝ → Prop) (h : ∀ (x : ℝ), x ∈ Set.Icc 0 1 → P (⇑f x - x)) (x : ℝ) : P (⇑f x - x)
(k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] (p : ι → P) (s : Finset ι) {n : ℕ} (hc : s.card = n + 1) : FiniteDimensional.finrank k ↥(Vector_Span k ↑(Finset.image p s)) ≤ n
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (e : LocalHomeomorph α β) {f : γ → α} {s : Set γ} {x : γ} (hx : f x ∈ e.to_local_equiv.source) (h : f ⁻¹' e.to_local_equiv.source ∈ nhds_within x s) : ContinuousWithinAt f s x ↔ ContinuousWithinAt (⇑e ∘ f) s x
{α : Type u_1} {ι : Type u_2} {f : ι → α} : Function.Injective f → Pairwise (NE on f)
{α : Type u_1} {n : ℕ} (s : Sym α n) : Sym.map (λ (x : α), x) s = s
{k : Type u_1} {G : Type u_2} {V : Type u_3} [CommRing k] [Group G] [AddCommGroup V] [Module k V] (ρ : Representation k G V) [Nontrivial k] [Module.Free k V] [Module.Finite k V] : ρ.character 1 = ↑(FiniteDimensional.finrank k V)
{k : Type u_1} {V1 : Type u_2} {V2 : Type u_4} [Ring k] [AddCommGroup V1] [Module k V1] [AddCommGroup V2] [Module k V2] (f : V1 →ᵃ[k] V2) : ⇑f = ⇑(f.linear) + λ (z : V1), ⇑f 0
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hD : DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Ioi 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Ioi 0)] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hre : ∀ (x : ℝ), x ≤ 0 → ∥f ↑x∥ ≤ C) (him : ∀ (x : ℝ), 0 ≤ x → ∥f (↑x * Complex.i)∥ ≤ C) (hz_re : z.re ≤ 0) (hz_im : 0 ≤ z.im) : ∥f z∥ ≤ C
{L : FirstOrder.Language} {M : Type w} [L.Structure M] {p : M → Prop} (x : M) {s : Set M} (hs : ⇑(FirstOrder.Language.Substructure.closure L) s = ⊤) (Hs : ∀ (x : M), x ∈ s → p x) (Hfun : ∀ {n : ℕ} (f : L.functions n), FirstOrder.Language.ClosedUnder f (SetOf p)) : p x
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {s : Set E} [CompleteSpace F] (h : AnalyticOn 𝕜 f s) (n : ℕ) : AnalyticOn 𝕜 (iterated_fderiv 𝕜 n f) s
{α : Type u_1} [Fintype α] (p q : α → Prop) [Fintype {x // p x}] [Fintype {x // ¬p x}] [Fintype {x // q x}] [Fintype {x // ¬q x}] (h : Fintype.card {x // p x} = Fintype.card {x // q x}) : Fintype.card {x // ¬p x} = Fintype.card {x // ¬q x}
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R : CategoryTheory.Presieve X} {P' : Cᵒᵖ ⥤ Type w} (i : P ≅ P') : CategoryTheory.Presieve.IsSheafFor P R → CategoryTheory.Presieve.IsSheafFor P' R
{𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] {f f' : 𝕜 → G} {s : Set 𝕜} {x y : 𝕜} {C : ℝ} (hF : ∀ (x : 𝕜), x ∈ s → HasDerivWithinAt f (f' x) s x) (bound : ∀ (x : 𝕜), x ∈ s → ∥f' x∥ ≤ C) (hs : Convex ℝ s) (xs : x ∈ s) (ys : y ∈ s) : ∥f y - f x∥ ≤ C * ∥y - x∥
{α : Type u_1} {M : Type u_5} [CommMonoid M] {a : α} {s : Set α} (f : α → M) (h : a ∉ s) (hs : (s ∩ Function.MulSupport f).finite) : finprod (λ (i : α), finprod (λ (H : i ∈ HasInsert.insert a s), f i)) = f a * finprod (λ (i : α), finprod (λ (H : i ∈ s), f i))
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : E → ℝ} {a : E} {f' : E →L[ℝ] ℝ} {s : Set E} (h : is_IsLocalMinOn f s a) (hF : HasFderivWithinAt f f' s a) {y : E} (hy : y ∈ PosTangentConeAt s a) : 0 ≤ ⇑f' y
{J : Type u} [Preorder J] [IsDirected J has_le.le] (F : Jᵒᵖ ⥤ Type v) [Π (j : Jᵒᵖ), Fintype (F.obj j)] [∀ (j : Jᵒᵖ), Nonempty (F.obj j)] : F.sections.nonempty
{M : Type u_1} [Semigroup M] [Nonempty M] (s : Set (Set M)) (sfin : s.finite) (scov : ⊤ ⊆ ⋃₀s) : ∃ (c : Set M) (H : c ∈ s) (a : Stream M), Hindman.FP a ⊆ c
{E : Type u_4} [NormedGroup E] [NormedSpace ℝ E] {b : ℝ} {f : ℕ → ℝ} {z : ℕ → E} (hfa : Monotone f) (hF0 : Filter.Tendsto f filter.at_Top (nhds 0)) (hgb : ∀ (n : ℕ), ∥(Finset.range n).sum (λ (i : ℕ), z i)∥ ≤ b) : CauchySeq (λ (n : ℕ), (Finset.range (n + 1)).sum (λ (i : ℕ), f i • z i))
{α : Type u} [Semigroup α] [HasDistribNeg α] (a b : α) : -a ∣ b ↔ a ∣ b
{R : Type u_1} [OrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_4} [Fintype ι] [DecidableEq ι] (e : Basis ι R M) (x : Orientation R M ι) (f : M ≃ₗ[R] M) : ⇑(Orientation.map ι f) x = (⇑LinearEquiv.det f)⁻¹ • x
{α : Type u_1} [DecidableEq α] [Fintype α] : Finset.univ = Finset.map equiv.perm.decompose_option.symm.to_Embedding Finset.univ
{E : Type u_3} [SemiNormedGroup E] {f : ℕ → E} (g : ℕ → ℝ) (hg : CauchySeq (λ (n : ℕ), (Finset.range n).sum (λ (i : ℕ), g i))) (hF : ∀ (i : ℕ), ∥f i∥ ≤ g i) : CauchySeq (λ (n : ℕ), (Finset.range n).sum (λ (i : ℕ), f i))
{E : Type u_2} [AddCommGroup E] [Module ℝ E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousSmul ℝ E] [t2_Space E] {s : Set E} (hs : s.finite) : is_IsClosed (⇑(Convex_hull ℝ) s)
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (hM : M (Sum.inr ()) (Sum.inr ()) ≠ 0) : (((matrix.pivot.list_transvec_col M).prod.mul M).mul (matrix.pivot.list_transvec_row M).prod).is_two_block_Diagonal
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (p : P) (direction : Submodule k V) : (AffineSubspace.mk' p direction).direction = direction
{α : Type u} [Preorder α] {a b c : α} : b = c → a ≤ b → a ≤ c
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V} (h : o.oangle x y = 0) : x = y ↔ ∥x∥ = ∥y∥
{α : Type u} (xs : List α) (x : α) [DecidableEq α] : [x].intercalate (list.split_on x xs) = xs
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [SemiNormedGroup E] [SemiNormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {f : E →ₛₗ[σ₁₂] F} (hF : Continuous ⇑f) {x : E} (hx : ∥x∥ = 0) : ∥⇑f x∥ = 0
{α : Type u} {r : α → α → Prop} {a b : α} (h : Relation.ReflTransGen r a b) : ∃ (l : List α), List.Chain r a l ∧ (a :: l).last _ = b
{K : Type u} [Field K] (s : Subfield K) : 0 ∈ s
{A : Type u_1} [CommMonoid A] (a b c : A) : c ∈ Submonoid.closure {a, b} ↔ ∃ (m n : ℕ), a ^ m * b ^ n = c
{α : Type u_2} {ι : Type u_5} [AddCommMonoid α] (t : Finset ι) (f₁ f₂ : ι → Set α) (hF : ∀ {i : ι}, i ∈ t → f₁ i ⊆ f₂ i) : t.sum (λ (i : ι), f₁ i) ⊆ t.sum (λ (i : ι), f₂ i)
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z → B} [TopologicalSpace Z] (e : TopologicalFiberBundle.Trivialization F Proj) {x : Z} (ex : x ∈ e.to_local_homeomorph.to_local_equiv.source) : ContinuousAt Proj x
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] {v : n → α} : IsUnit (Matrix.diagonal v) ↔ IsUnit v
(r : ℝ) (h : r ≠ 0) : r.sign = -1 ∨ r.sign = 1
{a b c : ℤ} (h : fermat_42.minimal a b c) : IsCoprime a b
{α : Type u_1} [has_Add α] [HasLt α] [ContravariantClass α α has_add.add has_lt.lt] {a b c : α} (bc : a + b < a + c) : b < c
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {a b : α} [IsAntisymm α HasSubset.Subset] (h : a ⊆ b) : a = b ∨ a ⊂ b
{x y : Pgame} : x.lf y ↔ (∃ (i : y.left_moves), (∀ (i' : x.left_moves), (x.move_Left i').lf (y.move_Left i)) ∧ ∀ (j : (y.move_Left i).right_moves), x.lf ((y.move_Left i).move_Right j)) ∨ ∃ (j : x.right_moves), (∀ (i : (x.move_Right j).left_moves), ((x.move_Right j).move_Left i).lf y) ∧ ∀ (j' : y.right_moves), (x.move_Right j).lf (y.move_Right j')
(R : Type u_1) {M : Type u_4} (S : Type u_7) [Semiring R] [AddCommMonoid M] [Module R M] (s : Set M) [Semiring S] [HasScalar R S] [Module S M] [IsScalarTower R S M] : Submodule.span R s ≤ submodule.restrict_scalars R (Submodule.span S s)
{α : Type u} {L₁ : List (α × Bool)} {x : α × Bool} : FreeGroup.Red [x] L₁ ↔ L₁ = [x]
{α : Type u_1} [Lattice α] [IsModularLattice α] {β : Type u_2} {γ : Type u_3} [Preorder β] [PartialOrder γ] (h₁ : WellFounded GT) (h₂ : WellFounded GT) (K : α) (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ) (gci : GaloisCoinsertion f₁ f₂) (gi : GaloisInsertion g₂ g₁) (hF : ∀ (a : α), f₁ (f₂ a) = a ⊓ K) (hg : ∀ (a : α), g₁ (g₂ a) = a ⊔ K) : WellFounded GT
(x : ℂ) : HasStrictDerivAt Complex.sin (Complex.cos x) x
{α : Type u_1} {ι : Type u_3} [CompleteLattice α] {t : ι → α} (ht : CompleteLattice.Independent t) : Pairwise (Disjoint on t)
{R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [DecidableEq ι] [CommSemiring R] [Π (i : ι), AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [Π (i : ι), Module R (M₁ i)] [Module R M₂] (f : MultilinearMap R M₁ M₂) [Fintype ι] (c : ι → R) (m : Π (i : ι), M₁ i) : ⇑f (λ (i : ι), c i • m i) = finset.univ.prod (λ (i : ι), c i) • ⇑f m
{m n b : ℕ} (hm : m ≠ 1) (hn : 0 < n) (hb : Nat.log m n < b) : multiplicity m n = ↑((Finset.filter (λ (i : ℕ), m ^ i ∣ n) (Finset.ico 1 b)).card)
{β α : Type u_1} (f : β → α) (w : Cardinal.mk α < Cardinal.mk β) (w' : Infinite α) : ∃ (a : α), Infinite ↥(f ⁻¹' {a})
{α : Type u} {β : Type v} [AddCommGroup β] (g h : FreeAbelianGroup α →+ β) (H : ∀ (x : α), ⇑g (FreeAbelianGroup.of x) = ⇑h (FreeAbelianGroup.of x)) : g = h
{ι : Type u_1} {ι' : Type u_2} {R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] (b : Basis ι R M) (e : ι ≃ ι') : Set.Range (⇑b ∘ ⇑(e.symm)) = Set.Range ⇑b
{K : Type u_1} [LinearOrderedField K] {v : K} {n : ℕ} [FloorRing K] (nth_Stream_Eq_None : GeneralizedContinuedFraction.IntFractPair.stream v n = Option.none) : v = (GeneralizedContinuedFraction.of v).convergents (n - 1)
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [NondiscreteNormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (f : ContinuousMultilinearMap 𝕜 E G) (m : Π (i : ι), E i) (h : ∥m∥ ≤ 1) : ∥⇑f m∥ ≤ ∥f∥
{α : Type u_1} {m : MeasurableSpace α} (s : Set α) : Nonempty {t // s ⊆ t ∧ MeasurableSet t}
{α : Type u_2} {β : Type u_3} : filter.cofinite.coprod Filter.cofinite = Filter.cofinite
{α : Type u_1} [UniformSpace α] : (Uniformity α).has_Basis (λ (V : Set (α × α)), V ∈ Uniformity α ∧ is_IsOpen V ∧ SymmetricRel V) Id
{α : Type u} [Ring α] {a b : α} : a ∣ b + a ↔ a ∣ b
{α : Type u_1} {β : Type u_2} [LinearOrder α] [Preorder β] {a : α} {f : α → β} (h₁ : StrictMonoOn f (Set.Iic a)) (h₂ : StrictMonoOn f (Set.Ici a)) : StrictMono f
{α : Type u_1} [Fintype α] [DecidableEq α] (h5 : 5 ≤ Fintype.card α) {f : Equiv.perm α} (hF : f.is_three_Cycle) : subgroup.normal_Closure {⟨f, _⟩} = ⊤
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrderedAddCommGroup α] [OrderTopology α] {l : Filter β} {f g : β → α} {C : α} (hF : Filter.Tendsto f l (nhds C)) (hg : Filter.Tendsto g l filter.at_Top) : Filter.Tendsto (λ (x : β), f x + g x) l filter.at_Top
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F ≠ 2) : finset.univ.sum (λ (a : F), char.quadratic_Char F a) = 0
{α : Type u_2} {β : Type u_3} {rα : NonAssocSemiring α} {rβ : NonAssocSemiring β} (f : α →+* β) : ⇑f 1 = 1
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] (s : Set P) : Collinear k s ↔ Module.rank k ↥(Vector_Span k s) ≤ 1
{α : Type u} [TopologicalSpace α] {s t : Set α} (hs : Dense s) (ht : Dense t) (hto : is_IsOpen t) : Dense (s ∩ t)
{R : Type u_1} {ι₁ : Type u_2} {ι₂ : Type u_3} {ι₃ : Type u_4} {ι₄ : Type u_5} [CommSemiring R] [DecidableEq ι₁] [DecidableEq ι₂] [DecidableEq ι₃] [DecidableEq ι₄] {N₁ : Type u_6} [AddCommMonoid N₁] [Module R N₁] {N₂ : Type u_7} [AddCommMonoid N₂] [Module R N₂] {N : Type u_8} [AddCommMonoid N] [Module R N] (a : MultilinearMap R (λ (_x : ι₁), N) N₁) (b : MultilinearMap R (λ (_x : ι₂), N) N₂) (σa : ι₁ ≃ ι₃) (σb : ι₂ ≃ ι₄) : multilinear_map.dom_Dom_congr (σa.sum_congr σb) (a.dom_Coprod b) = (multilinear_map.dom_Dom_congr σa a).dom_Coprod (multilinear_map.dom_Dom_congr σb b)
{α : Type u} [PseudoMetricSpace α] {s : Set α} {x : α} (h : s.nonempty) : x ∈ Closure s ↔ metric.inf_dist x s = 0
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0
{τ : Type u_1} {α : Type u_2} [CanonicallyOrderedAddMonoid τ] {ϕ : τ → α → α} {s : Set α} (h : IsFwInvariant ϕ s) : IsInvariant ϕ s
{M : Type u_1} [MulOneClass M] {s : Set M} {S : Submonoid M} : Submonoid.closure s ≤ S ↔ s ⊆ ↑S
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {f : M →* N} (h : ∀ (y : ↥S), IsUnit (⇑f ↑y)) {y : ↥S} {z : N} (H : ⇑f ↑y * z = 1) : ↑(⇑(is_unit.lift_Right (f.restrict S) h) y)⁻¹ = z
{α : Type u_1} [LinearOrder α] {s : Finset α} {k : ℕ} (h : s.card = k) (hz : 0 < k) : ⇑(s.order_emb_of_Fin h) ⟨k - 1, _⟩ = s.max' _
{M : Type u} [Monoid M] {a : Mˣ} {x y : M} (h : SemiconjBy ↑a x y) : SemiconjBy ↑a⁻¹ y x
(X : AlgebraicGeometry.LocallyRingedSpace : algebraic_geometry.to_specΓ (AlgebraicGeometry.LocallyRingedSpaceΓ.obj (Opposite.op X)) ≫ X.to_Γ_Spec.val.c.app (Opposite.op ⊤) = 𝟙 (AlgebraicGeometry.LocallyRingedSpaceΓ.obj (Opposite.op X))
{R : Type u_1} [NormedRing R] {r : ℝ} (hr : 1 < r) : Coe =o[filter.at_Top] λ (n : ℕ), r ^ n
{α : Type u_1} {β : Type u_3} [MeasurableSpace α] [MeasurableSpace β] {ν : MeasureTheory.Measure β} [MeasureTheory.SigmaFinite ν] {s : Set (α × β)} (hs : MeasurableSet s) : Measurable (λ (x : α), ⇑ν (Prod.mk x ⁻¹' s))
{α : Type u} [PseudoMetricSpace α] {ι : Type u_1} {f₁ f₂ : ι → α} {p : Filter ι} {a : α} (h₁ : Filter.Tendsto f₁ p (nhds a)) (h : Filter.Tendsto (λ (x : ι), HasDist.dist (f₁ x) (f₂ x)) p (nhds 0)) : Filter.Tendsto f₂ p (nhds a)
{α : Type u_1} (f : α → Set α) : ¬Function.Surjective f
{E : Type u_1} {X : Type u_2} [InnerProductSpace ℝ E] [NormedGroup X] [NormedSpace ℝ X] {n : WithTop ℕ} {c g : X → E} {f : Π (x : X), ContDiffBumpOfInner (c x)} {x : X} (hc : ContDiffAt ℝ n c x) (hr : ContDiffAt ℝ n (λ (x : X), (f x).r) x) (hR : ContDiffAt ℝ n (λ (x : X), (f x).R) x) (hg : ContDiffAt ℝ n g x) : ContDiffAt ℝ n (λ (x : X), ⇑(f x) (g x)) x
{α : Type u_1} [LinearOrderedField α] [Archimedean α] {x y : α} (xpos : 0 < x) (hx : x ≤ 1) (ypos : 0 < y) (hy : y < 1) : ∃ (n : ℕ), y ^ (n + 1) < x ∧ x ≤ y ^ n
{R : Type u} [Ring R] (s : Subring R) {l : List R} : (∀ (x : R), x ∈ l → x ∈ s) → l.prod ∈ s
(K : Type u_1) [is_R_or_C K] (E : Type u_2) [NormedGroup E] [NormedSpace K E] [FiniteDimensional K E] : ProperSpace E
{ι : Type u_1} {X : Type u_2} [TopologicalSpace X] [NormalSpace X] {u : ι → Set X} (uo : ∀ (i : ι), is_IsOpen (u i)) (uf : ∀ (x : X), {i : ι | x ∈ u i}.finite) (uU : (⋃ (i : ι), u i) = Set.Univ) : ∃ (v : ι → Set X), Set.Union v = Set.Univ ∧ (∀ (i : ι), is_IsOpen (v i)) ∧ ∀ (i : ι), Closure (v i) ⊆ u i
{α : Type u} [PseudoEmetricSpace α] {s : Set α} {d : Ennreal} (h : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → HasEdist.edist x y ≤ d) : Emetric.diam s ≤ d
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) (f : V ≃ₗᵢ[ℝ] V) : (⇑(Orientation.map (Fin 2) f.to_LinearEquiv) o).oangle x y = o.oangle (⇑(f.symm) x) (⇑(f.symm) y)
{α : Type u} {s : Set (Set α)} : Cardinal.mk ↥s ≤ Cardinal.continuum → Cardinal.mk ↥{t : Set α | MeasurableSet t} ≤ Cardinal.continuum
{α : Type u_1} [TopologicalSpace α] {s : Set α} (h : is_IsOpen s) : is_Gδ s
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {𝕜₃ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [SemiNormedGroup E] [SemiNormedGroup F] [SemiNormedGroup G] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NondiscreteNormedField 𝕜₃] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] [NormedSpace 𝕜₃ G] {σ₁₂ : 𝕜 →+* 𝕜₂} {σ₂₃ : 𝕜₂ →+* 𝕜₃} {σ₁₃ : 𝕜 →+* 𝕜₃} [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] [RingHomIsometric σ₁₂] [RingHomIsometric σ₂₃] (h : F →sl[σ₂₃] G) (f : E →sl[σ₁₂] F) : ∥h.comp f∥ ≤ ∥h∥ * ∥f∥
{ι : Type u_1} {E : Type u_3} [SemiNormedGroup E] [CompleteSpace E] {f : ι → E} (g : ι → ℝ) (hg : Summable g) (h : ∀ (i : ι), ∥f i∥ ≤ g i) : Summable f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s t : Set P} (ha : AffineIndependent k (λ (x : ↥t), ↑x)) (hs : s ⊆ t) : AffineIndependent k (λ (x : ↥s), ↑x)
{X : Top} {ι : Type v} (U : ι → TopologicalSpace.Opens ↥X) : CategoryTheory.Sieve.generate (Top.Presheaf.PresieveOfCovering U) ∈ ⇑(opens.grothendieck_topology ↥X) (supr U)
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [NondiscreteNormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (f : MultilinearMap 𝕜 E G) {C : ℝ} (H : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) : ∥f.mk_Continuous C H∥ ≤ Linear_order.max C 0
{α : Type u} {β : Type v} {f : α → β} {b : β} {l : List α} : b ∈ List.map f l → (∃ (a : α), a ∈ l ∧ f a = b)
{α : Type u_1} {ι : Type u_3} [CompleteLattice α] [Fintype ι] {f : ι → α} : CompleteLattice.Independent f ↔ finset.univ.sup_indep f
{R : Type u_1} {a b : R} [AddSemigroup R] (rra : IsAddRightRegular a) (rrb : IsAddRightRegular b) : IsAddRightRegular (a + b)
{α : Type u_1} [UniformSpace α] {K U : Set α} (hK : is_IsCompact K) (hU : is_IsOpen U) (hKU : K ⊆ U) : ∃ (V : Set (α × α)) (H : V ∈ Uniformity α), is_IsOpen V ∧ ∀ (x : α), x ∈ K → UniformSpace.Ball x V ⊆ U
{α : Type u_2} [Group α] {s t : Set α} : Disjoint s t → 1 ∉ s / t
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : Ennreal} (hF : HasFpowerSeriesOnBall f p x r) : ContinuousOn f (Emetric.Ball x r)
{n : ℕ} (p : Fin (n + 1)) (i : Fin n) (h : p ≤ ⇑fin.cast_Succ i) : ⇑(p.succ_above) i = i.succ
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [UniformSpace β] [(Uniformity β).is_countably_generated] (f : α → β) : is_Gδ {x : α | ContinuousAt f x}
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} {v : V} {p : ι → P} : v ∈ Vector_Span k (Set.Range p) ↔ ∃ (s : Finset ι) (w : ι → k) (h : s.sum (λ (i : ι), w i) = 0), v = ⇑(s.weighted_vsub p) w
{α : Type u_1} {β : Type u_2} {l : Filter α} {f : α → β} {lb : Filter β} : Filter.Tendsto f l lb → ↑f.tendsto lb
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} {p0 : P} {s : Set ι} {p : ι → P} : (∃ (fs : Finset ι) (hfs : ↑fs ⊆ s) (w : ι → k) (hw : fs.sum (λ (i : ι), w i) = 1), p0 = ⇑(fs.affine_combination p) w) ↔ ∃ (fs : Finset ↥s) (w : ↥s → k) (hw : fs.sum (λ (i : ↥s), w i) = 1), p0 = ⇑(fs.affine_combination (λ (i : ↥s), p ↑i)) w
{a : Ennreal} : AddLeCancellable a ↔ a ≠ ⊤
{R : Type u} [CommRing R] [is_IsDomain R] {p q : Polynomial R} (a : R) (hzero : p + q ≠ 0) : Linear_order.min (polynomial.root_multiplicity a p) (polynomial.root_multiplicity a q) ≤ polynomial.root_multiplicity a (p + q)
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [StrictConvexSpace ℝ E] {x y z : E} : HasDist.dist x y + HasDist.dist y z = HasDist.dist x z ↔ y ∈ Segment ℝ x z
{𝕜 : Type u_1} {E : Type u_2} [NormedLinearOrderedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {A : Set E} {x : E} : x ∈ Set.ExposedPoints 𝕜 A ↔ IsExposed 𝕜 A {x}
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (IH : ∀ (M : Matrix (Fin r) (Fin r) 𝕜), ∃ (L₀ L₀' : List (Matrix.TransvectionStruct (Fin r) 𝕜)) (D₀ : Fin r → 𝕜), ((List.map matrix.transvection_struct.to_Matrix L₀).prod.mul M).mul (List.map matrix.transvection_struct.to_Matrix L₀').prod = Matrix.diagonal D₀) (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) : ∃ (L L' : List (Matrix.TransvectionStruct (Fin r ⊕ Unit) 𝕜)) (D : Fin r ⊕ Unit → 𝕜), ((List.map matrix.transvection_struct.to_Matrix L).prod.mul M).mul (List.map matrix.transvection_struct.to_Matrix L').prod = Matrix.diagonal D
{α : Type u_1} [Preorder α] [has_Add α] [HasSub α] [HasOrderedSub α] {a b : α} : a + b - b ≤ a
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f : ℂ → E} (h : Differentiable ℂ f) (z : ℂ) {R : Nnreal} (hR : 0 < R) : HasFpowerSeriesOnBall f (Cauchy_PowerSeries f z ↑R) z ⊤
{α : Type u} {β : Type v} [TopologicalSpace α] [HasLe β] {f g : α → β} {a : α} (h : f ≤ᶠ[nhds a] g) : ∀ᶠ (y : α) in nhds a, f ≤ᶠ[nhds y] g
{α : Type u} [MetricSpace α] {x y : TopologicalSpace.NonemptyCompacts α} : HasDist.dist x y = metric.Hausdorff_dist ↑x ↑y
{α : sort u} {f : α → α} (h : Function.involutive f) (P : Prop) [Decidable P] (x : α) : f (Ite P x (f x)) = Ite (¬P) x (f x)
{α : Type u_1} {β : Type u_2} {f : α → β} {mα : MeasurableSpace α} [MeasurableSpace β] [TopologicalSpace β] [TopologicalSpace.PseudoMetrizableSpace β] [TopologicalSpace.SecondCountableTopology β] [OpensMeasurableSpace β] (hF : Measurable f) : MeasureTheory.StronglyMeasurable f
{R : Type u_1} [CommRing R] [is_IsDomain R] : Prime PowerSeries.x
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {J : Type w} [CategoryTheory.Category J] (F : C ⥤ D) [CategoryTheory.Limits.HasLimitsOfShape J D] [CategoryTheory.CreatesLimitsOfShape J F] : CategoryTheory.Limits.HasLimitsOfShape J C
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} : ContDiff 𝕜 n Prod.snd
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] (x : E) : ⇑(reflection K) x = x ↔ x ∈ K
{n n' m : ℕ} (i : Fin n') (h : n' = n) : ⇑(fin.add_Nat m) (⇑(fin.cast h) i) = ⇑(fin.cast _) (⇑(fin.add_Nat m) i)
(x : ℝ) : 0 ≤ Exp_Neg_Inv_glue x
{α : Type u_1} [CanonicallyLinearOrderedAddMonoid α] [HasSub α] [HasOrderedSub α] {a b c : α} [ContravariantClass α α has_add.add has_le.le] (h : b ≤ a) : a - b < a - c ↔ c < b
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasLimits C] : CategoryTheory.Limits.HasColimits Cᵒᵖ
{M : Type u_1} [HasMul M] {p : M → Prop} (x : M) {s : Set M} (hs : Subsemigroup.closure s = ⊤) (Hs : ∀ (x : M), x ∈ s → p x) (hMul : ∀ (x y : M), p x → p y → p (x * y)) : p x
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f1 f2 : α →₀ M} (hD : Disjoint f1.support f2.support) {β : Type u_2} [CommMonoid β] (g : α → M → β) : (f1 + f2).prod g = f1.prod g * f2.prod g
{n : ℕ} {F : Typevec (n + 1) → Type u} [Mvfunctor F] [q : Mvqpf F] {α : Typevec n} (r : Mvqpf.Cofix F α → Mvqpf.Cofix F α → Prop) (h : ∀ (x y : Mvqpf.Cofix F α), r x y → Mvfunctor.map (Typevec.id ::: Quot.mk r) x.dest = Mvfunctor.map (Typevec.id ::: Quot.mk r) y.dest) (x y : Mvqpf.Cofix F α) : r x y → x = y
(x : PrimeSpectrum Punit) : False
{G : Type u_1} [Group G] [Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)] (hdvd : p ∣ Fintype.card G) : ∃ (x : G), order_of x = p
{𝕜 : Type u_1} {E : Type u_4} {Fₗ : Type u_7} [NormedGroup E] [NormedGroup Fₗ] [NondiscreteNormedField 𝕜] [NormedSpace 𝕜 E] [NormedSpace 𝕜 Fₗ] (f : E →L[𝕜] Fₗ) (hF : UniformEmbedding ⇑f) : ∃ (K : Nnreal), AntilipschitzWith K ⇑f
{α : Type u} (s : Set α) : Cardinal.mk (↥𝒫s) = 2 ^ Cardinal.mk ↥s
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommMonoid β] [Module 𝕜 E] [Module 𝕜 β] [LinearOrder E] {s : Set E} {f : E → β} (hs : Convex 𝕜 s) (hF : ∀ ⦃x y : E⦄, x ∈ s → y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → f (a • x + b • y) ≤ a • f x + b • f y) : ConvexOn 𝕜 s f
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] : Even (Finset.filter (λ (v : V), Odd (G.degree v)) Finset.univ).card
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (e : LocalHomeomorph α β) {f : β → γ} {x : β} (h : x ∈ e.to_local_equiv.target) : ContinuousAt f x ↔ ContinuousAt (f ∘ ⇑e) (⇑(e.symm) x)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace E] [CompleteSpace ↥K] : ContinuousLinearMap.id 𝕜 E = K.subtypeL.comp (Orthogonal_projection K) + Kᗮ.subtypeL.comp (Orthogonal_projection Kᗮ)
{M : Type u_1} [AddCommMonoid M] (f s : ℕ → M) (h0 : s 0 = 0) (h : ∀ (n : ℕ), s (n + 1) = s n + f n) (n : ℕ) : (Finset.range n).sum (λ (k : ℕ), f k) = s n
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} {ι₂ : Type u_5} (s₂ : Finset ι₂) (e : ι₂ ↪ ι) (w : ι → k) (p : ι → P) : ⇑((Finset.map e s₂).weighted_vsub p) w = ⇑(s₂.weighted_vsub (p ∘ ⇑e)) (w ∘ ⇑e)
{a b : ℕ} : a ⋖ b → ↑a ⋖ ↑b
{R : Type u} [Ring R] {M : Module R} {ι : Type u_1} (b : Basis ι R ↥M) : CategoryTheory.Projective M
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b c : α} : a + b < c → a < c - b
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f₂ : 𝕜 → F} {s₂ : Set 𝕜} {n : ℕ} (hs : is_IsOpen s₂) : ContDiffOn 𝕜 ↑(n + 1) f₂ s₂ ↔ DifferentiableOn 𝕜 f₂ s₂ ∧ ContDiffOn 𝕜 ↑n (deriv f₂) s₂
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] (F : C ⥤ D) {X Y : C} (f : X ⟶ Y) [CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.span f f) F] [CategoryTheory.Epi (F.map f)] : CategoryTheory.Epi f
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} (hs : is_IsOpen s) : ContDiffOn 𝕜 ⊤ f s ↔ DifferentiableOn 𝕜 f s ∧ ContDiffOn 𝕜 ⊤ (λ (y : E), fderiv 𝕜 f y) s
(v w : ℕ → ℕ) (t : Omega.Nat.Preterm) : (∀ (x : ℕ), x < t.fresh_Index → v x = w x) → Omega.Nat.Preterm.val v t = Omega.Nat.Preterm.val w t
{α : Type u} [PseudoMetricSpace α] (x y : α) : HasDist.dist x y = (HasEdist.edist x y).to_Real
(L : FirstOrder.Language) {M : Type w} [Nonempty M] [L.Structure M] (s : Set M) (κ : Cardinal) (h1 : Cardinal.aleph_0 ≤ κ) (h2 : (Cardinal.mk ↥s).lift ≤ κ.lift) (h3 : L.card.lift ≤ κ.lift) (h4 : κ.lift ≤ (Cardinal.mk M).lift) : ∃ (S : L.elementary_Substructure M), s ⊆ ↑S ∧ (Cardinal.mk ↥S).lift = κ.lift
{S : Set Ordinal} (f : Ordinal → Ordinal) (hS : Set.Unbounded has_lt.lt S) : StrictMono f ∧ Set.Range f = S ↔ f = ordinal.enum_Ord S
(Ee : List Omega.Ee) (c : Omega.Clause) : (omega.eq_elim Ee c).unsat → c.unsat
{G : Type u_1} [AddGroup G] {N : Type u_2} [AddGroup N] (f : G →+ N) (hF : Function.Surjective ⇑f) : f.range = ⊤
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] (p : P) : ↑(affine_Span k {p}) = {p}
{n : ℕ} (a : Composition n) (b : Composition a.length) {i j : ℕ} (hi : i < b.length) (hj : j < b.blocks_fun ⟨i, hi⟩) : a.size_Up_to (b.size_Up_to i + j) = (a.gather b).size_Up_to i + (a.sigma_Composition_aux b ⟨i, _⟩).size_Up_to j
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] {a₁ a₂ a₃ : X} {b₁ b₂ b₃ : Y} (γ₁ : Path a₁ a₂) (δ₁ : Path a₂ a₃) (γ₂ : Path b₁ b₂) (δ₂ : Path b₂ b₃) : (γ₁.prod γ₂).trans (δ₁.prod δ₂) = (γ₁.trans δ₁).prod (γ₂.trans δ₂)
(X : AlgebraicGeometry.RingedSpace) (U : TopologicalSpace.Opens ↥X) (f : ↥(X.to_PresheafedSpace.presheaf.obj (Opposite.op U))) (h : ∀ (x : ↥U), IsUnit (⇑(X.to_PresheafedSpace.presheaf.germ x) f)) : IsUnit f
{R : Type u_1} {a b : R} [Semigroup R] : IsRegular (a * b) ∧ IsRegular (b * a) ↔ IsRegular a ∧ IsRegular b
{α : Type u} {β : Type v} [UniformSpace α] [SemilatticeSup β] {K : Set α} (h₁ : IsComplete K) {u : β → α} (h₂ : ∀ (n : β), u n ∈ K) (h₃ : CauchySeq u) : ∃ (v : α) (H : v ∈ K), Filter.Tendsto u filter.at_Top (nhds v)
{α : Type u} [t : TopologicalSpace α] {s : Set (Set α)} (h_IsOpen : ∀ (u : Set α), u ∈ s → is_IsOpen u) (h_nhds : ∀ (a : α) (u : Set α), a ∈ u → is_IsOpen u → (∃ (v : Set α) (H : v ∈ s), a ∈ v ∧ v ⊆ u)) : TopologicalSpace.IsTopologicalBasis s
{p q : ℕ} [p_Prime : Fact (Nat.Prime p)] [q_Prime : Fact (Nat.Prime q)] (neq : p ≠ q) : padic_norm p ↑q = 1
{α : Type u} [Group α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] {a b c : α} : b⁻¹ * a < c → a < b * c
{M : Type u_1} [has_Add M] (c : AddCon M) : Add_con.add_Ker Coe _ = c
{α : Type u_1} {ι : Type u_3} {M : Type u_5} [CommMonoid M] {f : α → M} [Fintype ι] {t : ι → Set α} (h : Pairwise (Disjoint on t)) (ht : ∀ (i : ι), (t i).finite) : finprod (λ (a : α), finprod (λ (H : a ∈ ⋃ (i : ι), t i), f a)) = finprod (λ (i : ι), finprod (λ (a : α), finprod (λ (H : a ∈ t i), f a)))
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {E' : Type u_6} [NormedGroup E'] [NormedSpace 𝕜 E'] {F' : Type u_7} [NormedGroup F'] [NormedSpace 𝕜 F'] {f : E → F} {g : E' → F'} (hF : ContDiff 𝕜 n f) (hg : ContDiff 𝕜 n g) : ContDiff 𝕜 n (Prod.map f g)
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D ⥤ C} [CategoryTheory.Reflective i] {A : C} [CategoryTheory.SplitMono ((Category_theory.adjunction.of_Right_Adjoint i).unit.app A)] : A ∈ i.ess_image
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α} {p : Filter ι} {g : ι → α} [TopologicalSpace α] (h : ContinuousWithinAt f s x) (hg : Filter.Tendsto g p (nhds_within x s)) (hunif : ∀ (u : Set (β × β)), u ∈ Uniformity β → (∃ (t : Set α) (H : t ∈ nhds_within x s), ∀ᶠ (n : ι) in p, ∀ (y : α), y ∈ t → (f y, F n y) ∈ u)) : Filter.Tendsto (λ (n : ι), F n (g n)) p (nhds (f x))
{α : Type u_1} {s : Set α} [MeasurableSpace α] (hs : s.infinite) : ⇑MeasureTheory.Measure.count s = ⊤
{C : Type u₁} [CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {P : Cᵒᵖ ⥤ Type v₁} (x : S.functor ⟶ P) (g : Category_theory.yoneda.obj X ⟶ P) : S.functor_inclusion ≫ g = x ↔ (⇑Category_theory.presieve.nat_Trans_Equiv_compatible_family x).val.is_amalgamation (⇑CategoryTheory.yoneda_Equiv g)
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f g : α → M} {s : Set α} (hF : (s ∩ Function.MulSupport f).finite) (hg : (s ∩ Function.MulSupport g).finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i * g i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ s), g i))
{α : Type u_1} {E : Type u_2} (R : Type u_3) [AddCommGroup E] [DivisionRing R] [Monoid α] [Module R E] [DistribMulAction α E] (n : ℤ) (s : α) (x : E) : (↑n)⁻¹ • s • x = s • (↑n)⁻¹ • x
(R : Type u_1) [has_One R] [HasNeg R] : Cardinal.mk ↥Set.Univ = Cardinal.mk R ^ 4
{α : Type u_1} [LinearOrder α] (s : Finset α) (h₂ : 1 < s.card) : s.min' _ < s.max' _
{X : Type u_1} [TopologicalSpace X] (hX : ∀ {x y : X}, x ≠ y → (∃ (U : Set X) (h_IsClopen : is_IsClopen U), x ∈ U ∧ y ∉ U)) : IsTotallyDisconnected Set.Univ
{A : Type u_1} {F : Type u_2} [MulZeroOneClass A] [MonoidWithZeroHomClass F ℕ A] (f g : F) (h_Pos : ∀ {n : ℕ}, 0 < n → ⇑f n = ⇑g n) : f = g
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) : x = y ↔ ∥x∥ = ∥y∥ ∧ o.oangle x y = 0
{n : ℕ} (p : Fin (n + 1)) (i : Fin n) : ⇑fin.cast_Succ i < p ∨ p ≤ ⇑fin.cast_Succ i
{n : ℕ} {i : Fin (n + 1)} (h : 0 < i) : 0 < ⇑fin.cast_Succ i
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : HasInner.inner x y = ∥x∥ * ∥y∥ ↔ InnerProductGeometry.angle x y = 0
{M : Type u_1} [CommMonoidWithZero M] {p : M} {L : List M} (pp : Prime p) : p ∣ L.prod ↔ ∃ (a : M) (H : a ∈ L), p ∣ a
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [SemiNormedGroup E] [SemiNormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [RingHomIsometric σ₁₂] : ∥0∥ = 0
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b
(X : AlgebraicGeometry.RingedSpace) (U : TopologicalSpace.Opens ↥X) (f : ↥(X.to_PresheafedSpace.presheaf.obj (Opposite.op U))) (x : ↥U) (h : IsUnit (⇑(X.to_PresheafedSpace.presheaf.germ x) f)) : ∃ (V : TopologicalSpace.Opens ↥X) (i : V ⟶ U) (hxV : x.val ∈ V), IsUnit (⇑(X.to_PresheafedSpace.presheaf.map i.op) f)
{J : Type u₁} [CategoryTheory.Category J] {K : Type u₂} [CategoryTheory.Category K] {C : Type u} [CategoryTheory.Category C] {F : J ⥤ C} (e : K ≌ J) [CategoryTheory.Limits.HasColimit (e.functor ⋙ F)] : CategoryTheory.Limits.HasColimit F
{α : Type u} [PseudoMetricSpace α] {s t : Set α} (hs : s.nonempty) (ht : t.nonempty) (bs : Metric.Bounded s) (bt : Metric.Bounded t) : emetric.Hausdorff_edist s t ≠ ⊤
{D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ} (hF : ContinuousOn f D) (hF' : DifferentiableOn ℝ f (Interior D)) {C : ℝ} (Lt_hF' : ∀ (x : ℝ), x ∈ Interior D → deriv f x < C) (x : ℝ) (H : x ∈ D) (y : ℝ) (H_1 : y ∈ D) : x < y → f y - f x < C * (y - x)
{X : Type u_1} [TopologicalSpace X] {s : Set X} (hs : IsSeqClosed s) {x : ℕ → X} (hmem : ∀ (n : ℕ), x n ∈ s) {a : X} (ha : Filter.Tendsto x filter.at_Top (nhds a)) : a ∈ s
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {F : C ⥤ D} {Y Y' : D} (h : Y ≅ Y') (hY : Y ∈ F.ess_image) : Y' ∈ F.ess_image
{M : Type u_1} [has_Add M] {p : M → Prop} (x : M) {s : Set M} (hs : AddSubsemigroup.closure s = ⊤) (Hs : ∀ (x : M), x ∈ s → p x) (hMul : ∀ (x y : M), p x → p y → p (x + y)) : p x
{M : Type u_3} {N : Type u_4} [MulOneClass M] [MulOneClass N] {f g : M →* N} (h : f = g) (x : M) : ⇑f x = ⇑g x
{A : Type u} {B : Type v} {ι : Type w} [CommRing A] [CommRing B] [Algebra A B] [Fintype ι] [DecidableEq ι] (b : ι → B) (P : Matrix ι ι A) : Algebra.discr A ((P.map ⇑(Algebra_Map A B)).mul_vec b) = P.det ^ 2 * Algebra.discr A b
{α : sort u} [DecidableEq α] {β : sort u_1} (f : α → β) (a' : α) (b : β) (a : α) : Function.update f a' b a = Ite (a = a') b (f a)
{α : Type u_1} {l : Filter α} {p : α → Prop} : (∀ᶠ (x : α) in l, p x) → (∀ᶠ (s : Set α) in l.small_sets, ∀ (x : α), x ∈ s → p x)
{n n' : ℕ} (i : Fin n) (h : n.succ = n'.succ) : ⇑(fin.cast h) i.succ = (⇑(fin.cast _) i).succ
{ι : Type v} {ι' : Type v'} (f : ι → Cardinal) (f' : ι' → Cardinal) (g : ι → ι') (h : ∀ (i : ι), (f i).lift ≤ (f' (g i)).lift) : (Cardinal.sup f).lift ≤ (Cardinal.sup f').lift
(R : Type u_5) [Semiring R] (M : Type u_1) [AddCommMonoid M] [Module R M] : Function.Surjective ⇑(Finsupp.total M M R Id)
{X : Type u_1} [TopologicalSpace X] [CompactSpace X] (A : Subalgebra ℝ C(X, ℝ)) (w : A.separates_points) (f : C(X, ℝ)) : f ∈ A.topological_Closure
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] [DecidableEq V] : finset.univ.sum (λ (v : V), G.degree v) = 2 * G.edge_finset.card
{C : Type u₁} [CategoryTheory.Category C] (P : Cᵒᵖ ⥤ Type (max v₁ u₁)) {X : C} (S : CategoryTheory.Sieve X) (x : CategoryTheory.Equalizer.FirstObj P ⇑S) : ((CategoryTheory.Equalizer.FirstObj_Eq_family P ⇑S).hom x).compatible ↔ Category_theory.equalizer.sieve.first_Map P S x = Category_theory.equalizer.sieve.second_Map P S x
(Fq F : Type) [Field Fq] [Fintype Fq] [Field F] [Algebra (Polynomial Fq) F] [Algebra (Ratfunc Fq) F] [IsScalarTower (Polynomial Fq) (Ratfunc Fq) F] [FunctionField Fq F] [IsSeparable (Ratfunc Fq) F] : Function_field.class_number Fq F = 1 ↔ IsPrincipalIdealRing ↥(Function_field.ring_of_integers Fq F)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] {a : α} (h : (Set.Iio a).nonempty) : Closure (Set.Iio a) = Set.Iic a
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] (p : Fin 3 → P) : AffineIndependent k p ↔ ¬Collinear k (Set.Range p)
{F : Type u_3} [Field F] [Fintype F] : Ring_Char F = 2 ↔ Fintype.card F % 2 = 0
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] {f : E → F} (hF : Differentiable ℂ f) (hb : Metric.Bounded (Set.Range f)) (z w : E) : f z = f w
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X ⟶ Y} [CategoryTheory.Limits.HasEqualizer f g] (h : f = g) : CategoryTheory.IsIso (CategoryTheory.Limits.equalizerι f g)
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {δ : Type u_1} [LinearOrder δ] [TopologicalSpace δ] [OrderClosedTopology δ] {s : Set α} [hs : s.ord_connected] {f : α → δ} (hF : ContinuousOn f s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) : Set.SurjOn f s (Set.Interval (f a) (f b))
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {a : F} : char.quadratic_Char F a = -1 ↔ ¬IsSquare a
{α : Type u_1} [TopologicalSpace α] [NonUnitalNonAssocRing α] [TopologicalRing α] (x : α) : Continuous ⇑(AddMonoid_hom.mul_Left x)
(p : Prop) [Decidable p] : p ∨ ¬p
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) {r : Nnreal} (h : ↑r < p.radius) : ∃ (a : ℝ) (H : a ∈ Set.Ioo 0 1) (C : ℝ) (H : C > 0), ∀ (n : ℕ), ∥p n∥ * ↑r ^ n ≤ C * a ^ n
{J : Type u₁} [CategoryTheory.Category J] [Nonempty J] {j₀ : J} (h : ∀ (p : Set J), j₀ ∈ p → (∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → (j₁ ∈ p ↔ j₂ ∈ p)) → ∀ (j : J), j ∈ p) : CategoryTheory.IsConnected J
{M : Type u_1} [AddMonoid M] (s : AddSubmonoid M) {l : List M} (hl : ∀ (x : M), x ∈ l → x ∈ s) : l.sum ∈ s
{α : Type u_1} {β : Type u_2} (p : Pmf α) (f : α → Pmf β) (s : Set β) [MeasurableSpace β] (hs : MeasurableSet s) : ⇑((p.bind f).to_measure) s = ∑' (a : α), ↑(⇑p a) * ⇑((f a).to_measure) s
{G : Type u_1} [Group G] (H : Subgroup G) : 1 ∈ H
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] {D : Type u₁} [CategoryTheory.Category D] (h : C ≌ D) : CategoryTheory.IsCofiltered D
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) : is_R_or_C.abs (HasInner.inner x y) * is_R_or_C.abs (HasInner.inner y x) ≤ ⇑is_R_or_C.re (HasInner.inner x x) * ⇑is_R_or_C.re (HasInner.inner y y)
{a b c m : ℕ} (hmc : m.gcd c = 1) (h : a * c ≡ b * c [Mod m]) : a ≡ b [Mod m]
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] {x : M} {s : Set M} {p : M → Prop} (h : x ∈ Submodule.span R s) (Hs : ∀ (x : M), x ∈ s → p x) (H0 : p 0) (H1 : ∀ (x y : M), p x → p y → p (x + y)) (H2 : ∀ (a : R) (x : M), p x → p (a • x)) : p x
{α : Type u_1} {ι : sort u_3} [ConditionallyCompleteLinearOrder α] {a : α} [Nonempty ι] {f : ι → α} (h : infi f < a) : ∃ (i : ι), f i < a
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {s : Set E} {f : E → F} {x : E} {n : WithTop ℕ} (e : G ≃L[𝕜] E) : ContDiffWithinAt 𝕜 n (f ∘ ⇑e) (⇑e ⁻¹' s) (⇑(e.symm) x) ↔ ContDiffWithinAt 𝕜 n f s x
{M : Type u_6} {N : Type u_7} [HasMul M] [HasMul N] {f g : M ≃* N} (h : ∀ (x : M), ⇑f x = ⇑g x) : f = g
{C : Type v} [CategoryTheory.SmallCategory C] {D : Type v} [CategoryTheory.SmallCategory D] {L : C ⥤ D} {R : D ⥤ C} (Adj : L ⊣ R) : R.final
(s b : ℝ) (hb : 0 < b) : Filter.Tendsto (λ (x : ℝ), Real.exp (b * x) / x ^ s) filter.at_Top filter.at_Top
{R : Type u} {ι : Type w} (s : Finset ι) [CommSemiring R] (f : ι → Polynomial R) (h : s.prod (λ (i : ι), (f i).leading_Coeff) ≠ 0) : (s.prod (λ (i : ι), f i)).leading_Coeff = s.prod (λ (i : ι), (f i).leading_Coeff)
{X : Top} {Y : TopologicalSpace.Opens ↥X} (R : CategoryTheory.Presieve Y) : Top.Presheaf.PresieveOfCoveringAux (Top.presheaf.covering_of_Presieve Y R) Y = R
{α : Type u_1} {β : Type u_2} {M : Type u_3} [Fintype α] [Fintype β] [AddCommMonoid M] (e : α → β) (hE : Function.bijective e) (f : α → M) (g : β → M) (h : ∀ (x : α), f x = g (e x)) : finset.univ.sum (λ (x : α), f x) = finset.univ.sum (λ (x : β), g x)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {s : Set E} {f : E → F} {x : E} {n : WithTop ℕ} (g : F →L[𝕜] G) (hF : ContDiffWithinAt 𝕜 n f s x) : ContDiffWithinAt 𝕜 n (⇑g ∘ f) s x
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] {g1 g2 : G} (p : P) (h : g1 +ᵥ p = g2 +ᵥ p) : g1 = g2
{α : Type u_1} {β : Type u_2} (r : α → α → Prop) (s : β → β → Prop) [IsTrichotomous α r] [IsIrrefl β s] (f : α → β) (hF : ∀ {x y : α}, r x y → s (f x) (f y)) : Function.Injective f
{α : Type u_1} {β : Type u_3} {γ : Type u_5} {f f' : α → β → γ} {s : Set α} {t : Set β} (h : ∀ (a : α) (b : β), f a b = f' a b) : Set.image2 f s t = Set.image2 f' s t
{M : Type u_1} [has_Add M] {c d : AddCon M} (H : c.to_Setoid = d.to_Setoid) : c = d
{C : Type u} [CategoryTheory.Category C] {X Y : C} [CategoryTheory.Limits.HasZeroMorphisms C] (f : X ⟶ Y) [CategoryTheory.Limits.HasKernel f] {Z : C} (h : Y ⟶ Z) [CategoryTheory.Limits.HasKernel (f ≫ h)] : Category_theory.limits.kernel_Subobject f ≤ Category_theory.limits.kernel_Subobject (f ≫ h)
{K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {f g : V →ₗ[K] V} : f * g = 1 ↔ g * f = 1
{V : Type u_1} [InnerProductSpace ℝ V] {x : V} (hx : x ≠ 0) : InnerProductGeometry.angle (-x) x = Real.pi
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] {p1 p2 : P} (p3 : P) (hp1 : p1 ∈ s) (hp2 : p2 ∈ s) : HasDist.dist p1 p3 = HasDist.dist p2 p3 ↔ HasDist.dist p1 ↑(⇑(euclidean_geometry.orthogonal_projection s) p3) = HasDist.dist p2 ↑(⇑(euclidean_geometry.orthogonal_projection s) p3)
{M : Type u_1} [AddCommMonoid M] (S : AddSubmonoid M) {ι : Type u_2} {t : Finset ι} {f : ι → M} (h : ∀ (c : ι), c ∈ t → f c ∈ S) : t.sum (λ (c : ι), f c) ∈ S
{J : Type u₁} [CategoryTheory.Category J] [CategoryTheory.IsPreconnected J] {α : Type u₁} (F : J → α) (h : ∀ (j₁ j₂ : J), (j₁ ⟶ j₂) → F j₁ = F j₂) (j j' : J) : F j = F j'
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) {x : E} : p.radius - ↑∥x∥₊ ≤ (p.change_origin x).radius
{R : Type u_1} [CommMonoidWithZero R] (n : R) : IsPrimePow n ↔ ∃ (p : R) (k : ℕ), Prime p ∧ p ^ (k + 1) = n
(c : ℂ) (R : ℝ) : Function.Periodic (Circle_Map c R) (2 * Real.pi)
{α : Type u} [PseudoEmetricSpace α] (x y z : α) : HasEdist.edist x y ≤ HasEdist.edist z x + HasEdist.edist z y
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (s₁ s₂ : AffineSubspace ℝ P) [Nonempty ↥s₁] [Nonempty ↥s₂] [CompleteSpace ↥(s₁.direction)] [CompleteSpace ↥(s₂.direction)] (p : P) : ⇑(EuclideanGeometry.reflection s₁) p = ⇑(EuclideanGeometry.reflection s₂) p ↔ ↑(⇑(euclidean_geometry.orthogonal_projection s₁) p) = ↑(⇑(euclidean_geometry.orthogonal_projection s₂) p)
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] {n : ℕ} (a b : Fin (n + 1) → ℝ) (hle : a ≤ b) (f : (Fin (n + 1) → ℝ) → Fin (n + 1) → E) (f' : (Fin (n + 1) → ℝ) → ((Fin (n + 1) → ℝ) →L[ℝ] Fin (n + 1) → E)) (s : Set (Fin (n + 1) → ℝ)) (hs : s.countable) (Hc : ContinuousOn f (Set.Icc a b)) (hD : ∀ (x : Fin (n + 1) → ℝ), x ∈ set.univ.pi (λ (i : Fin (n + 1)), Set.Ioo (a i) (b i))  s → HasFderivAt f (f' x) x) (Hi : MeasureTheory.IntegrableOn (λ (x : Fin (n + 1) → ℝ), finset.univ.sum (λ (i : Fin (n + 1)), ⇑(f' x) (Pi.single i 1) i)) (Set.Icc a b) MeasureTheory.MeasureSpace.volume) : ∫ (x : Fin (n + 1) → ℝ) in Set.Icc a b, finset.univ.sum (λ (i : Fin (n + 1)), ⇑(f' x) (Pi.single i 1) i) = finset.univ.sum (λ (i : Fin (n + 1)), (∫ (x : Fin n → ℝ) in Set.Icc (a ∘ ⇑(i.succ_above)) (b ∘ ⇑(i.succ_above)), f (i.insert_nth (b i) x) i) - ∫ (x : Fin n → ℝ) in Set.Icc (a ∘ ⇑(i.succ_above)) (b ∘ ⇑(i.succ_above)), f (i.insert_nth (a i) x) i)
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {f : α → E} {g : α → F} {l : Filter α} : f =o[l] g ↔ ∀ ⦃c : ℝ⦄, 0 < c → (∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥)
{α : Type u_1} [has_Add α] [Preorder α] [CovariantClass α α has_add.add has_lt.lt] [CovariantClass α α (Function.swap has_add.add) has_le.le] {a b c d : α} (h₁ : a < b) (h₂ : c < d) : a + c < b + d
{α : Type u_1} [CommSemiring α] (E : LinearRecurrence α) (init : Fin E.order → α) (n : Fin E.order) : E.mk_sol init ↑n = init n
{C : Type u₁} [CategoryTheory.Category C] {A : Type u₂} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (P : Cᵒᵖ ⥤ A) [CategoryTheory.Limits.HasProducts A] [CategoryTheory.Limits.HasPullbacks C] : CategoryTheory.Presheaf.IsSheaf J P ↔ CategoryTheory.Presheaf.IsSheaf' J P
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} {ps : Set P} (h : ps ⊆ ↑s) [Nonempty ↥s] {n : ℕ} [FiniteDimensional ℝ ↥(s.direction)] (hD : FiniteDimensional.finrank ℝ ↥(s.direction) = n) (hc : EuclideanGeometry.Cospherical ps) {sx₁ sx₂ : Affine.Simplex ℝ P n} (hsx₁ : Set.Range sx₁.points ⊆ ps) (hsx₂ : Set.Range sx₂.points ⊆ ps) : sx₁.circumcenter = sx₂.circumcenter
{α : Type u_1} {β : Type u_2} [CompleteLattice α] (a : α) (f : β → α) : (⨅ (o : Option β), Option.elim a f o) = a ⊓ ⨅ (b : β), f b
{M : Type u_6} {N : Type u_7} [has_Add M] [has_Add N] (e : M ≃+ N) (y : N) : ⇑e (⇑(e.symm) y) = y
{β : Type u_4} [LinearOrder β] [NoMinOrder β] {u : ℕ → β} (hu : Filter.Tendsto u filter.at_Top filter.at_IsBot) (N : ℕ) : ∃ (n : ℕ) (H : n ≥ N), ∀ (k : ℕ), k < n → u n < u k
{α : Type u_1} {M : Type u_5} {N : Type u_7} [HasZero M] [CommMonoid N] (f : α →₀ M) (y : α) (g : α → M → N) (hg : ∀ (i : α), g i 0 = 1) : g y (⇑f y) * (Finsupp.erase y f).prod g = f.prod g
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] {p1 p2 p : P} : p1 -ᵥ p = p2 -ᵥ p ↔ p1 = p2
{α : Type u} [LinearOrderedRing α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.swap has_add.add) has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
{α : Type u_1} [Subsingleton α] (s : Finset α) : s.card ≤ 1
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasKernels C] {X Y : C} [CategoryTheory.Simple X] [CategoryTheory.Simple Y] {f : X ⟶ Y} (w : f ≠ 0) : CategoryTheory.IsIso f
{p : ℕ} {G : Type u_1} [Group G] (hG : is_p_Group p G) [hp : Fact (Nat.Prime p)] (α : Type u_2) [MulAction G α] [Fintype α] [Fintype ↥(MulAction.FixedPoints G α)] : Fintype.card α ≡ Fintype.card ↥(MulAction.FixedPoints G α) [Mod p]
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Simple 0] : False
{R : Type u_1} {a b : R} [AddMonoid R] (h : a + b = 0) : IsAddRightRegular a
{α : Type u_1} {β : Type u_2} [AddGroup α] [AddCommGroup β] {f g : α → β} (hF : IsAddGroupHom f) (hg : IsAddGroupHom g) : IsAddGroupHom (λ (a : α), f a + g a)
{G : Type u_1} [Group G] [hN : Nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G
{ι : Type u_1} {R : Type u_2} (S : Type u_3) {M : ι → Type u_4} {N : Type u_5} [decι : DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (M i)] [Π (i : ι), Module R (M i)] [AddCommMonoid N] [Module R N] [Semiring S] [Module S N] [SmulCommClass R S N] (F : Π (i : ι), M i →ₗ[R] N) (i : ι) (x : M i) : ⇑(⇑(Dfinsupp.lsum S) F) (Dfinsupp.single i x) = ⇑(F i) x
{α : Type u_1} {g g' : GeneralizedContinuedFraction α} : g = g' ↔ g.h = g'.h ∧ g.s = g'.s
{a : ℝ} {l : Filter ℝ} {f f' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in nhds_within a (Set.Ioi a), HasDerivAt f (f' x) x) (hgg' : ∀ᶠ (x : ℝ) in nhds_within a (Set.Ioi a), HasDerivAt g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in nhds_within a (Set.Ioi a), g' x ≠ 0) (hfa : Filter.Tendsto f (nhds_within a (Set.Ioi a)) (nhds 0)) (hga : Filter.Tendsto g (nhds_within a (Set.Ioi a)) (nhds 0)) (hDiv : Filter.Tendsto (λ (x : ℝ), f' x / g' x) (nhds_within a (Set.Ioi a)) l) : Filter.Tendsto (λ (x : ℝ), f x / g x) (nhds_within a (Set.Ioi a)) l
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι} [TopologicalSpace α] (h : TendstoLocallyUniformly F f p) (hc : ∀ᶠ (n : ι) in p, Continuous (F n)) [p.ne_IsBot] : Continuous f
{R : Type u_1} [CommRing R] (M : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization M S] {ι : Type u_3} (s : Finset ι) (f : ι → S) : ∃ (b : ↥M), ∀ (i : ι), i ∈ s → IsLocalization.IsInteger R (↑b • f i)
(𝕜 : Type u_1) (E : Type u_2) [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] (v : Fin 1 → E) : ⇑(FormalMultilinearSeries.id 𝕜 E 1) v = v 0
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {X Y : AlgebraicGeometry.PresheafedSpace C} (α β : X ⟶ Y) (h₁ : α = β) (x x' : ↥X) (h₂ : x = x') : algebraic_geometry.PresheafedSpace.stalk_Map α x ≫ Category_theory.eq_to_hom _ = Category_theory.eq_to_hom _ ≫ algebraic_geometry.PresheafedSpace.stalk_Map β x'
{α : Type u_1} {β : Type u_2} [has_Add α] [Preorder α] [Preorder β] {f g : β → α} [CovariantClass α α has_add.add has_le.le] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] (hF : StrictMono f) (hg : Monotone g) : StrictMono (λ (x : β), f x + g x)
{α : Type u_1} [CompleteLattice α] {s : Set α} {b : α} : (∀ (a : α), a ∈ s → b ≤ a) → (∀ (w : α), b < w → (∃ (a : α) (H : a ∈ s), a < w)) → HasInf.inf s = b
{α : Type u_1} {E : Type u_3} [TopologicalSpace α] [CompactSpace α] [NormedGroup E] (f : C(α, E)) {C : ℝ} (C0 : 0 ≤ C) : ∥f∥ ≤ C ↔ ∀ (x : α), ∥⇑f x∥ ≤ C
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] [DenselyOrdered β] {f : α → β} (h_Mono : Monotone f) (h_Dense : DenseRange f) : Continuous f
{α : Type u} [PseudoMetricSpace α] {s t : Set α} (h : s ⊆ t) (ht : Metric.Bounded t) : Metric.diam s ≤ Metric.diam t
{ι : sort u_1} {f : ι → Ennreal} {x : Ennreal} (h0 : x ≠ 0) (h : x ≠ ⊤) : x * infi f = ⨅ (i : ι), x * f i
{M : Type u_1} {N : Type u_2} [AddZeroClass M] [AddZeroClass N] (h : M ≃+ N) : IsAddHom ⇑h
{M : Type u_1} [has_Add M] (c : AddCon M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w + y) (x + z)
{α : Type u} [PseudoMetricSpace α] {s : Set α} (hs : TopologicalSpace.IsSeparable s) : TopologicalSpace.SeparableSpace ↥s
{R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] {n : ℕ} (H : ∀ (s : Finset M), LinearIndependent R (λ (i : ↥s), ↑i) → s.card ≤ n) (s : Set M) : LinearIndependent R Coe → Cardinal.mk ↥s ≤ ↑n
{R : Type u} [Ring R] {S T : Subring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) : S = T
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) {x y : L} : x ∈ S → y ∈ S → x + y ∈ S
{α : sort u} : WellFounded EmptyRelation
{α : Type u} {G : Type w} [TopologicalSpace G] [has_Inv G] [HasContinuousInv G] {f : α → G} {l : Filter α} {y : G} (h : Filter.Tendsto f l (nhds y)) : Filter.Tendsto (λ (x : α), (f x)⁻¹) l (nhds y⁻¹)
{α : Type u_1} {ι : Type u_2} {x : ι → α} {f : Filter α} {l : Filter ι} [l.is_countably_generated] (hxy : ∀ (ns : ℕ → ι), Filter.Tendsto ns filter.at_Top l → (∃ (ms : ℕ → ℕ), Filter.Tendsto (λ (n : ℕ), x (ns (ms n))) filter.at_Top f)) : Filter.Tendsto x l f
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f g : α → M} {s : Set α} (hF : (s ∩ Function.Support f).finite) (hg : (s ∩ Function.Support g).finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i + g i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ s), g i))
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (i : Fin r ⊕ Unit) : M.mul (matrix.pivot.list_transvec_row M).prod i (Sum.inr ()) = M i (Sum.inr ())
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {z : ℂ} {f : ℂ → E} (h : DifferentiableAt ℂ f z) (hF' : deriv f z ≠ 0) : ConformalAt f z
{R : Type u_1} {M : Type u_2} [CommSemiring R] [AddCommMonoid M] [Module R M] (a : R) : Module.IsTorsionBy R M a ↔ Submodule.torsion_by R M a = ⊤
{R : Type u_1} [LinearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_3} [DecidableEq ι] [Fintype ι] (e₁ e₂ : Basis ι R M) : e₁.orientation = e₂.orientation ↔ 0 < ⇑(e₁.det) ⇑e₂
{α : Type u} {l : List α} : l.attach.nodup → l.nodup
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : E → ℝ} {a : E} {s : Set E} (h : is_IsLocalMaxOn f s a) {y : E} (hy : y ∈ PosTangentConeAt s a) (hy' : -y ∈ PosTangentConeAt s a) : ⇑(fderiv_within ℝ f s a) y = 0
{A : Type u_1} {K : Type u_2} [CommRing A] [is_IsDomain A] [UniqueFactorizationMonoid A] [Field K] [Algebra A K] [IsFractionRing A K] {p : Polynomial A} {r : K} (hr : ⇑(Polynomial.aeval r) p = 0) : IsFractionRing.num A r ∣ p.coeff 0
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] (S : Subalgebra R A) (HS : S.to_submodule.fg) (x : A) (hx : x ∈ S) : IsIntegral R x
{R : Type u} [CommRing R] (U V : TopologicalSpace.Opens ↥(AlgebraicGeometry.PrimeSpectrum.top R)) (iVU : V ⟶ U) : AlgebraicGeometry.StructureSheaf.comap (RingHom.id R) U V _ = (algebraic_geometry.Spec.structure_sheaf R).val.map iVU.op
{M : Type u_1} [AddCommMonoid M] {s t : Set M} {x : M} : x ∈ Add_monoid.closure (s ∪ t) ↔ ∃ (y : M) (H : y ∈ Add_monoid.closure s) (z : M) (H : z ∈ Add_monoid.closure t), y + z = x
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) : ∥x + y∥ = ∥x - y∥ ↔ InnerProductGeometry.angle x y = Real.pi / 2
{α : Type u} [PseudoEmetricSpace α] {δ : ℝ} {E : Set α} : is_IsOpen (Metric.Thickening δ E)
(u : Pnat.XgcdType) (hr : u.r ≠ 0) : u.step.v = u.v.swap
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (s : Set P) : s ⊆ SpanPoints k s
{α : Type u_1} [Preorder α] [SuccOrder α] {a b : α} [NoMaxOrder α] : Order.succ a < Order.succ b → a < b
{α : Type u_1} [GeneralizedBooleanAlgebra α] [DecidableRel Disjoint] [DecidableRel has_le.le] {s : Finset α} {u v a : α} (ha : a ∈ Uv.compression u v s) (hva : v ≤ a) (hvu : v = ⊥ → u = ⊥) : a ∈ s
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {f : ℂ → E} (hD : DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Ioi 0)) (hB : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Ioi 0)] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hre : ∀ (x : ℝ), x ≤ 0 → f ↑x = 0) (him : ∀ (x : ℝ), 0 ≤ x → f (↑x * Complex.i) = 0) : Set.EqOn f 0 {z : ℂ | z.re ≤ 0 ∧ 0 ≤ z.im}
{α : Type u_3} {β : Type u_4} [Preorder α] [Preorder β] {f : α → β} (hF : Monotone f) (h : ∀ (b : β), ∃ (a : α), b ≤ f a) : Filter.Tendsto f filter.at_Top filter.at_Top
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} : Differentiable 𝕜 f → Mdifferentiable (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f
{α : Type u_1} [LinearOrderedField α] {a : α} (a2 : 2 ≤ a) : (1 - 1 / a)⁻¹ ≤ 2
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (R : D ⥤ C) [CategoryTheory.Limits.HasLimitsOfSize C] [CategoryTheory.Reflective R] : CategoryTheory.Limits.HasLimitsOfSize D
(𝕜 : Type v) [is_R_or_C 𝕜] {E : Type u} [NormedGroup E] [NormedSpace 𝕜 E] [Nontrivial E] (x : E) : ∃ (g : E →L[𝕜] 𝕜), ∥g∥ = 1 ∧ ⇑g x = ↑∥x∥
{R : Type u_1} {S : Type u_2} {M : Type u_3} {a : R} {s : S} [HasScalar R M] [HasScalar R S] [HasScalar S M] [IsScalarTower R S M] (ra : IsSmulRegular M a) (rs : IsSmulRegular M s) : IsSmulRegular M (a • s)
{G : Type u} [Group G] (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤
{α : Type u_1} {n : Type u_3} {m : Type u_4} {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α} {D : Matrix n n α} (hA : A.is_Symm) (hBC : B.transpose = C) (hD : D.is_Symm) : (matrix.from_blocks A B C D).is_Symm
{M : Type u_1} [Semigroup M] {a : Stream M} {m : M} (hm : m ∈ Hindman.FP a) : ∃ (n : ℕ), ∀ (m' : M), m' ∈ Hindman.FP (stream.drop n a) → m * m' ∈ Hindman.FP a
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) : hb.oangle x y = θ ↔ ∃ (r : ℝ), 0 < r ∧ y = r • ⇑(hb.rotation θ) x
{𝕜 : Type u_1} {E : Type u_2} [LinearOrderedField 𝕜] [OrderedAddCommGroup E] [Module 𝕜 E] {s : Set E} (hs : Convex 𝕜 s) : IsLeast {t : ConvexCone 𝕜 E | s ⊆ ↑t} (convex.to_cone s hs)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {f : 𝕜 → F} {s : Set 𝕜} {x : 𝕜} {m : Fin n → 𝕜} : ⇑(iterated_fderiv_within 𝕜 n f s x) m = finset.univ.prod (λ (i : Fin n), m i) • iterated_deriv_within n f s x
(c : ℂ) : ⇑CliffordAlgebra_complex.of_Complex (⇑(StarRing_end ℂ) c) = ⇑CliffordAlgebra.involute (⇑CliffordAlgebra_complex.of_Complex c)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (f : V ≃ₗᵢ[ℝ] V) : ∃ (θ : Real.Angle), f = hb.rotation θ ∨ f = hb.conj_lie.trans (hb.rotation θ)
{ι : Type u} (s : Finset ι) (w z : ι → Nnreal) (hw' : s.sum (λ (i : ι), w i) = 1) : s.prod (λ (i : ι), z i ^ ↑(w i)) ≤ s.sum (λ (i : ι), w i * z i)
{x : ℝ} (lx : Liouville x) : Transcendental ℤ x
{f : ℝ → ℝ} {a b : ℝ} (hfi : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (h : ∀ (x : ℝ), 0 < f x) (hab : a < b) : 0 < ∫ (x : ℝ) in a..b, f x
{A B C D B' D' : SemiNormedGroup} {fab : A ⟶ B} {fbd : B ⟶ D} {fac : A ⟶ C} {fcd : C ⟶ D} {h : fab ≫ fbd = fac ≫ fcd} {fbb' : B ⟶ B'} {fdd' : D ⟶ D'} {condb : fab ≫ fbb' = 0} {condd : fcd ≫ fdd' = 0} {g : B' ⟶ D'} (h' : fbb' ≫ g = fbd ≫ fdd') : SemiNormedGroup.explicit_Cokernel_Desc condb ≫ g = SemiNormedGroup.explicit_cokernel.map h ≫ SemiNormedGroup.explicit_Cokernel_Desc condd
{R : Type u_1} [Semiring R] (p : Polynomial R) : ⇑polynomial.to_laurent p = finsupp.map_IsDomain Coe p.to_Finsupp
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {f : E → F} {p : E → FormalMultilinearSeries ℝ E F} {s : Set E} {x : E} (hF : HasFtaylorSeriesUpToOn 1 f p (HasInsert.insert x s)) (hs : Convex ℝ s) : ∃ (K : Nnreal) (t : Set E) (H : t ∈ nhds_within x s), LipschitzOnWith K f t
{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] {m : M} {s : Set M} : m ∈ Submodule.span R s ↔ ∃ (c : M →₀ R), ↑(c.support) ⊆ s ∧ c.sum (λ (mi : M) (r : R), r • mi) = m
{X : Type u_1} {Y : Type u_2} {f : X → Y} (hF : Function.Injective f) : TopologicalSpace.induced f ⊥ = ⊥
{α : Type u_1} {f : α → Ennreal} (hF : ∑' (x : α), f x ≠ ⊤) : Filter.Tendsto (λ (s : Finset α), ∑' (b : {x // x ∉ s}), f ↑b) filter.at_Top (nhds 0)
(𝕜 : Type u_1) (E : Type u_2) [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {n : ℕ} (h : n ≠ 1) : FormalMultilinearSeries.id 𝕜 E n = 0
{α : Type u} {β : Type v} {γ : Type w} [TopologicalSpace α] [PseudoMetricSpace β] [PseudoMetricSpace γ] {G : β → γ} {C : Nnreal} (H : LipschitzWith C G) : LipschitzWith C (BoundedContinuousFunction.comp G H)
{Γ : Type u_1} [Inhabited Γ] (l : Turing.ListBlank Γ) : Turing.ListBlank.cons l.head l.tail = l
{G : Type u_1} [AddGroup G] {H : AddSubgroup G} {N : Type u_3} [AddGroup N] (f : N →+ G) : AddSubgroup.comap f H.normalizer ≤ (AddSubgroup.comap f H).normalizer
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {v : ℝ → E → E} {s : ℝ → Set E} {K : ℝ} (hv : ∀ (t : ℝ) (x : E), x ∈ s t → ∀ (y : E), y ∈ s t → HasDist.dist (v t x) (v t y) ≤ K * HasDist.dist x y) {f g f' g' : ℝ → E} {a b εf εg δ : ℝ} (hF : ContinuousOn f (Set.Icc a b)) (hF' : ∀ (t : ℝ), t ∈ Set.Ico a b → HasDerivWithinAt f (f' t) (Set.Ici t) t) (f_bound : ∀ (t : ℝ), t ∈ Set.Ico a b → HasDist.dist (f' t) (v t (f t)) ≤ εf) (hfs : ∀ (t : ℝ), t ∈ Set.Ico a b → f t ∈ s t) (hg : ContinuousOn g (Set.Icc a b)) (hg' : ∀ (t : ℝ), t ∈ Set.Ico a b → HasDerivWithinAt g (g' t) (Set.Ici t) t) (g_bound : ∀ (t : ℝ), t ∈ Set.Ico a b → HasDist.dist (g' t) (v t (g t)) ≤ εg) (hgs : ∀ (t : ℝ), t ∈ Set.Ico a b → g t ∈ s t) (ha : HasDist.dist (f a) (g a) ≤ δ) (t : ℝ) (H : t ∈ Set.Icc a b) : HasDist.dist (f t) (g t) ≤ gronwall_bound δ K (εf + εg) (t - a)
{M : Type u_1} [has_Add M] {c d : AddCon M} {x y : M} : ⇑(c ⊓ d) x y ↔ ⇑c x y ∧ ⇑d x y
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [Algebra R A] [CommRing B] [Algebra R B] (hfp : Algebra.FinitePresentation R A) (e : A ≃ₐ[R] B) : Algebra.FinitePresentation R B
{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), Monoid (M i)] (w : FreeProduct.Word M) (h : w ≠ FreeProduct.Word.empty) : ∃ (i j : ι) (w' : FreeProduct.Neword M i j), w'.to_Word = w
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : ℕ} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ ⇑fin.cast_Succ j) : X.δ (⇑fin.cast_Succ i) ≫ X.σ j.succ = X.σ j ≫ X.δ i
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {n : WithTop ℕ} (hF : IsBoundedLinearMap 𝕜 f) : ContDiff 𝕜 n f
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {w : α → M} {b : M} [LinearOrderedCancelAddCommMonoid M] (ht : ∀ (y : β), y ∉ t → 0 ≤ (Finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x)) (hb : s.sum (λ (x : α), w x) < t.card • b) : ∃ (y : β) (H : y ∈ t), (Finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x) < b
{A : Type u_1} [CommRing A] [Algebra ℚ A] (k : ℕ) : PowerSeries.exp A ^ k = ⇑(PowerSeries.rescale ↑k) (PowerSeries.exp A)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {f' : E ≃L[𝕜] F} {g : F → E} {a : F} (hg : ContinuousAt g a) (hF : HasStrictFderivAt f ↑f' (g a)) (hfg : ∀ᶠ (y : F) in nhds a, f (g y) = y) : HasStrictFderivAt g ↑(f'.symm) a
(X : Type u) [MetricSpace X] [CompactSpace X] [Nonempty X] (Y : Type v) [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : ∃ (Φ : X → ↥(Lp (λ (n : ℕ), ℝ) ⊤)) (Ψ : Y → ↥(Lp (λ (n : ℕ), ℝ) ⊤)), Isometry Φ ∧ Isometry Ψ ∧ Gromov_Hausdorff.GH_dist X Y = metric.Hausdorff_dist (Set.Range Φ) (Set.Range Ψ)
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂] [Module K V₂] (f : V →ₗ[K] V₂) (w : Function.Surjective ⇑f) [FiniteDimensional K V] : FiniteDimensional K V₂
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {x : E} {f : E → F} {f' : E → (E →L[ℝ] F)} {f'' : E →L[ℝ] E →L[ℝ] F} (hF : ∀ (y : E), HasFderivAt f (f' y) y) (hx : HasFderivAt f' f'' x) (v w : E) : ⇑(⇑f'' v) w = ⇑(⇑f'' w) v
{α : Type u_1} {ι' : sort u_5} [CompleteLattice α] (s : ι' → α) : (⨅ (i : ι'), s i) = ⨅ (t : Finset (plift ι')) (i : plift ι') (H : i ∈ t), s i.down
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {f : V ≃ₗᵢ[ℝ] V} (hD : ⇑LinearMap.det ↑(f.to_LinearEquiv) < 0) : ∃ (θ : Real.Angle), f = hb.conj_lie.trans (hb.rotation θ)
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.NormalMonoCategory C] {X Y : C} (f g : X ⟶ Y) : CategoryTheory.Limits.HasLimit (Category_theory.limits.parallel_pair f g)
{α : Type u_1} {M : Type u_5} {N : Type u_7} [AddZeroClass M] [CommMonoid N] {f g : α →₀ M} {h : α → M → N} (h_Zero : ∀ (a : α), h a 0 = 1) (h_Add : ∀ (a : α) (b₁ b₂ : M), h a (b₁ + b₂) = h a b₁ * h a b₂) : (f + g).prod h = f.prod h * g.prod h
{R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] [Semiring R₂] [AddCommMonoid M₂] [Module R₂ M₂] {σ₁₂ : R →+* R₂} {s : Set M} {f g : M →ₛₗ[σ₁₂] M₂} (H : Set.EqOn ⇑f ⇑g s) : Set.EqOn ⇑f ⇑g ↑(Submodule.span R s)
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] {p1 p2 p : P} (h : p1 -ᵥ p = p2 -ᵥ p) : p1 = p2
{α : Type u_1} [CommSemiring α] (E : LinearRecurrence α) {u : ℕ → α} {init : Fin E.order → α} (h : E.is_solution u) (HEq : ∀ (n : Fin E.order), u ↑n = init n) : u = E.mk_sol init
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : EuclideanGeometry.angle p1 p2 p3 = Real.pi) : HasDist.dist p1 p3 = HasDist.dist p1 p2 + HasDist.dist p3 p2
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} {s : Set E} {x : E} : MdifferentiableWithinAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x ↔ DifferentiableWithinAt 𝕜 f s x
{M : Type u} [Monoid M] (x : M) (n : ℕ) : MulOpposite.op (x ^ n) = MulOpposite.op x ^ n
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} {s : Set α} (h : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) ≠ 0) : ∃ (x : α) (H : x ∈ s), f x ≠ 0
{b x c : Ordinal} (b1 : 1 < b) (x0 : 0 < x) : b ^ c ≤ x ↔ c ≤ Ordinal.log b x
(G : Type u_1) [Group G] : group.is_nilpotent G ↔ ∃ (n : ℕ) (H : ℕ → Subgroup G), IsDescendingCentralSeries H ∧ H n = ⊥
{β : Type u} {α : Type v} {s : Finset α} {a : α} {f : α → β} [CommMonoid β] [DecidableEq α] (h : f a = 1) : (HasInsert.insert a s).prod (λ (x : α), f x) = s.prod (λ (x : α), f x)
 : Function.Injective Fin
{R : Type u} [CommSemigroup R] [StarSemigroup R] (x y : R) : HasStar.star (x * y) = HasStar.star x * HasStar.star y
{α : Type u} {β : Type v} [TopologicalSpace α] {f : β → α} {l : Filter β} {s : Set β} {a : α} (h : ∀ (x : β), x ∉ s → f x = a) : Filter.Tendsto f (l ⊓ Filter.principal s) (nhds a) ↔ Filter.Tendsto f l (nhds a)
{R : Type u_1} {M : Type u_2} [CommSemiring R] [AddCommMonoid M] [Module R M] (s : Set R) : Submodule.torsion_by_Set R M s = Submodule.torsion_by_Set R M ↑(Ideal.span s)
{V : Type u_1} [NormedGroup V] [Nontrivial V] : ∥NormedGroupHom.id V∥ = 1
{R K : Type u} [CommRing R] [Field K] [Algebra R K] [IsAlgClosed K] {ι : Type u} (v : ι → K) [Nontrivial R] (hv : IsTranscendenceBasis R v) (hR : Cardinal.mk R ≤ Cardinal.aleph_0) (hK : Cardinal.aleph_0 < Cardinal.mk K) : Cardinal.mk K = Cardinal.mk ι
{M : Type u_1} [MulOneClass M] (c : Con M) : Con.ker c.mk' = c
{k : Type u_1} {M : Type u_2} [OrderedRing k] [OrderedAddCommGroup M] [Module k M] [OrderedSmul k M] [CovariantClass M M has_add.add has_lt.lt] [ContravariantClass M M has_add.add has_lt.lt] {a b : k} {c d : M} (hab : a < b) (hcd : c < d) : a • d + b • c < a • c + b • d
{α : Type u_1} [UniformSpace α] : (⨆ (x : α), nhds (x, x)) ≤ Uniformity α
{X : Type u_2} [EmetricSpace X] (m : Set X → Ennreal) : (measure_theory.outer_measure.mk_metric' m).is_metric
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {f : M →* N} (h : ∀ (y : ↥S), IsUnit (⇑f ↑y)) {x₁ x₂ : M} {y₁ y₂ : ↥S} : ⇑f x₁ * ↑(⇑(is_unit.lift_Right (f.restrict S) h) y₁)⁻¹ = ⇑f x₂ * ↑(⇑(is_unit.lift_Right (f.restrict S) h) y₂)⁻¹ ↔ ⇑f (x₁ * ↑y₂) = ⇑f (x₂ * ↑y₁)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {f : E → F} (hF : ContDiff 𝕜 n f) : ContDiff 𝕜 n (λ (x : E), -f x)
{A : Type u_1} {R : Type u_2} (K : Type u_3) [CommRing A] [is_IsDomain A] [NormalizedGcdMonoid A] [Field K] [CommRing R] [is_IsDomain R] [Algebra A K] [IsFractionRing A K] [Algebra K R] [Algebra A R] [IsScalarTower A K R] {x : R} (hx : IsIntegral A x) {P : Polynomial A} (hprim : P.is_primitive) (hroot : ⇑(Polynomial.aeval x) P = 0) : minpoly A x ∣ P
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [FiniteDimensional ℝ ↥(s.direction)] (hD : FiniteDimensional.finrank ℝ ↥(s.direction) = 2) {c₁ c₂ p₁ p₂ p : P} (hc₁s : c₁ ∈ s) (hc₂s : c₂ ∈ s) (hp₁s : p₁ ∈ s) (hp₂s : p₂ ∈ s) (hps : p ∈ s) {r₁ r₂ : ℝ} (hc : c₁ ≠ c₂) (hp : p₁ ≠ p₂) (hp₁c₁ : HasDist.dist p₁ c₁ = r₁) (hp₂c₁ : HasDist.dist p₂ c₁ = r₁) (hpc₁ : HasDist.dist p c₁ = r₁) (hp₁c₂ : HasDist.dist p₁ c₂ = r₂) (hp₂c₂ : HasDist.dist p₂ c₂ = r₂) (hpc₂ : HasDist.dist p c₂ = r₂) : p = p₁ ∨ p = p₂
{R : Type u_1} [Semiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {N : Type u_3} [AddCommMonoid N] [Module R N] {ι : Type u_6} [DecidableEq ι] (f : AlternatingMap R M N ι) : f.comp_Linear_Map LinearMap.id = f
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {s : Set E} {g : F → G} {f : E → F} (hg : ContDiff 𝕜 n g) (hF : ContDiffOn 𝕜 n f s) : ContDiffOn 𝕜 n (g ∘ f) s
{n : ℕ} (u v : Σ (c : Composition n), Π (i : Fin c.length), Composition (c.blocks_fun i)) : u = v ↔ list.of_fn (λ (i : Fin u.fst.length), (u.snd i).blocks) = list.of_fn (λ (i : Fin v.fst.length), (v.snd i).blocks)
{n : ℕ} {x : ℕ × ℕ} : x ∈ List.Nat.antidiagonal n ↔ x.fst + x.snd = n
{a b : ℝ} : IntervalIntegrable (λ (x : ℝ), x⁻¹) MeasureTheory.MeasureSpace.volume a b ↔ a = b ∨ 0 ∉ Set.Interval a b
(𝕜 : Type u_1) [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] (x : E) : ext_chart_at (model_with_corners_self 𝕜 E) x = LocalEquiv.refl E
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [TopologicalSpace.SecondCountableTopology E] [CompleteSpace E] [NormedGroup F] {f : ℝ → E} {g : ℝ → F} {a b : ℝ} (l : Filter ℝ) [l.ne_IsBot] [Filter.TendstoIxxClass Set.Icc l l] (hl : Set.Interval a b ∈ l) (hD : ∀ᶠ (x : ℝ) in l, DifferentiableAt ℝ f x) (hF : Filter.Tendsto (λ (x : ℝ), ∥f x∥) l filter.at_Top) (hfg : deriv f =O[l] g) : ¬IntervalIntegrable g MeasureTheory.MeasureSpace.volume a b
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} [CompleteSpace E] (f : LocalHomeomorph E F) {f₀' : E ≃L[𝕜] F} {a : F} (ha : a ∈ f.to_local_equiv.target) (hF₀' : HasFderivAt ⇑f ↑f₀' (⇑(f.symm) a)) (hF : ContDiffAt 𝕜 n ⇑f (⇑(f.symm) a)) : ContDiffAt 𝕜 n ⇑(f.symm) a
(α : Type u_1) [HasZero α] [has_One α] (n : ℕ) : Matrix.circulant (λ (i : Fin n), Ite (↑i = 0) 1 0) = 1
{m : Type u_1} {R : Type u_2} [Fintype m] [CommRing R] {M : Matrix m m R} (hM : M.nondegenerate) {v : m → R} (hv : v ≠ 0) : ∃ (w : m → R), matrix.dot_Product v (M.mul_vec w) ≠ 0
{R : Type u_4} [NormedRing R] [CompleteSpace R] (x : R) (h : ∥x∥ < 1) : ∥∑' (n : ℕ), x ^ n∥ ≤ ∥1∥ - 1 + (1 - ∥x∥)⁻¹
{α : Type u_2} {β : Type u_3} {γ : Type u_4} [rα : NonAssocSemiring α] [rβ : NonAssocSemiring β] {rγ : NonAssocSemiring γ} {δ : Type u_1} {rδ : NonAssocSemiring δ} (f : α →+* β) (g : β →+* γ) (h : γ →+* δ) : (h.comp g).comp f = h.comp (g.comp f)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s₁ s₂ : Set P} (h : s₁ ⊆ s₂) : affine_Span k s₁ ≤ affine_Span k s₂
{R : Type u_1} {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] [IsArtinian R M] (f : M →ₗ[R] M) (s : Function.Injective ⇑f) : Function.bijective ⇑f
{M : Type u} [Monoid M] (a : M) : a ^ 2 = a * a
{α : Type u_1} {E : Type u_2} (R : Type u_3) [AddCommGroup E] [DivisionRing R] [Monoid α] [Module R E] [DistribMulAction α E] (n : ℕ) (s : α) (x : E) : (↑n)⁻¹ • s • x = s • (↑n)⁻¹ • x
{R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] {ι : Type u_1} {f : ι → M} (hF : Function.Injective f) : LinearIndependent R Coe → LinearIndependent R f
(k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] [Fintype ι] (p : ι → P) {n : ℕ} (hc : Fintype.card ι = n + 2) : AffineIndependent k p ↔ ¬FiniteDimensional.finrank k ↥(Vector_Span k (Set.Range p)) ≤ n
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] [RegularSpace Y] {f : X → Y} {A B : Set X} (hB : B ⊆ Closure A) (hF : ∀ (x : X), x ∈ B → (∃ (y : Y), Filter.Tendsto f (nhds_within x A) (nhds y))) : ContinuousOn (extend_from A f) B
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] {s : Set M} {p : Π (x : M), x ∈ Submodule.span R s → Prop} (Hs : ∀ (x : M) (h : x ∈ s), p x _) (H0 : p 0 _) (H1 : ∀ (x : M) (hx : x ∈ Submodule.span R s) (y : M) (hy : y ∈ Submodule.span R s), p x hx → p y hy → p (x + y) _) (H2 : ∀ (a : R) (x : M) (hx : x ∈ Submodule.span R s), p x hx → p (a • x) _) {x : M} (hx : x ∈ Submodule.span R s) : p x hx
{𝕜 : Type u_1} {E : Type u_3} [NormedField 𝕜] [AddCommGroup E] [Module 𝕜 E] {A : Set E} [TopologicalSpace E] [HasContinuousSmul 𝕜 E] (hA : A ∈ nhds 0) : Absorbent 𝕜 A
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {b : E × F → G} {n : WithTop ℕ} (hb : IsBoundedBilinearMap 𝕜 b) : ContDiff 𝕜 n b
{M : Type u_1} [has_Add M] {c d : AddCon M} (H : Setoid.r = Setoid.r) : c = d
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimitsOfSize C] : CategoryTheory.Limits.HasColimitsOfSize C
(n : ℕ) (x : ℝ) : HasDerivAt (Exp_Neg_Inv_glue.f_aux n) (Exp_Neg_Inv_glue.f_aux (n + 1) x) x
(R : Type u_1) {p n : ℕ} [hp : Fact (Nat.Prime p)] [Ring R] [Char_p R p] (hn : ¬p ∣ n) : Polynomial.cyclotomic (n * p) R = Polynomial.cyclotomic n R ^ (p - 1)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (hb : ContinuousAt f a) : deriv (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) a = -f a
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {n : WithTop ℕ} {f g : E → F} (hF : ContDiffAt 𝕜 n f x) (hg : ContDiffAt 𝕜 n g x) : ContDiffAt 𝕜 n (λ (x : E), f x - g x) x
{a b : ℝ} (m n : ℕ) : ∫ (x : ℝ) in a..b, Real.sin x ^ (2 * m + 1) * Real.cos x ^ n = ∫ (u : ℝ) in Real.cos b..real.cos a, u ^ n * (1 - u ^ 2) ^ m
{ι : Type u} {α : Type v} [Fintype ι] {t : ι → Finset α} [DecidableEq α] {n : ℕ} (hn : Fintype.card ι = n + 1) (ht : ∀ (s : Finset ι), s.card ≤ (s.bUnion t).card) (ih : ∀ {ι' : Type u} [_inst_3 : Fintype ι'] (t' : ι' → Finset α), Fintype.card ι' ≤ n → (∀ (s' : Finset ι'), s'.card ≤ (s'.bUnion t').card) → (∃ (f : ι' → α), Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x)) (s : Finset ι) (hs : s.nonempty) (hns : s ≠ Finset.univ) (hus : s.card = (s.bUnion t).card) : ∃ (f : ι → α), Function.Injective f ∧ ∀ (x : ι), f x ∈ t x
{α : Type u} [AddGroup α] [HasLe α] [CovariantClass α α has_add.add has_le.le] {a : α} : 0 ≤ -a → a ≤ 0
{𝕜₂ : Type u_2} {𝕜₃ : Type u_3} {F : Type u_6} {G : Type u_8} [NormedGroup F] [NormedGroup G] [NondiscreteNormedField 𝕜₂] [NondiscreteNormedField 𝕜₃] [NormedSpace 𝕜₂ F] [NormedSpace 𝕜₃ G] {σ₂₃ : 𝕜₂ →+* 𝕜₃} {𝕜₂' : Type u_10} [NondiscreteNormedField 𝕜₂'] {F' : Type u_11} [NormedGroup F'] [NormedSpace 𝕜₂' F'] {σ₂' : 𝕜₂' →+* 𝕜₂} {σ₂'' : 𝕜₂ →+* 𝕜₂'} {σ₂₃' : 𝕜₂' →+* 𝕜₃} [RingHomInvPair σ₂' σ₂''] [RingHomInvPair σ₂'' σ₂'] [RingHomCompTriple σ₂' σ₂₃ σ₂₃'] [RingHomCompTriple σ₂'' σ₂₃' σ₂₃] [RingHomIsometric σ₂₃] [RingHomIsometric σ₂'] [RingHomIsometric σ₂''] [RingHomIsometric σ₂₃'] (f : F →sl[σ₂₃] G) (g : F' ≃ₛₗᵢ[σ₂'] F) : ∥f.comp g.to_Linear_isometry.to_ContinuousLinearMap∥ = ∥f∥
{n m : ℕ} (h : n = m) (i : Fin n) : ↑(⇑(fin.cast h) i) = ↑i
{ι : Type u} {γ : Type w} {β : ι → Type v} [dec : DecidableEq ι] [Π (i : ι), AddZeroClass (β i)] [AddCommMonoid γ] (f : Π (i : ι), β i →+ γ) (i : ι) (x : β i) : ⇑(⇑dfinsupp.lift_AddHom f) (Dfinsupp.single i x) = ⇑(f i) x
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] {f : α → β} {s : Set α} {a : α} (h_Mono : StrictMonoOn f s) (hs : s ∈ nhds_within a (Set.Ici a)) (hfs : Set.SurjOn f s (Set.Ioi (f a))) : ContinuousWithinAt f (Set.Ici a) a
{R : Type u} [Ring R] (s : Subring R) : 0 ∈ s
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y z : V} (hxyne : x ≠ y) (hxzne : x ≠ z) {r : ℝ} (hx : ∥x∥ = r) (hy : ∥y∥ = r) (hz : ∥z∥ = r) : hb.oangle y z = 2 • hb.oangle (y - x) (z - x)
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] : ↑⊥ = ∅
{α : Type u_1} [CommSemigroup α] {a b : α} (c : α) (h : c * a = b) : a ∣ b
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra A B] [Algebra R B] [Algebra R A] [IsScalarTower R A B] (H : Function.Injective ⇑(Algebra_Map A B)) {x : A} (h : IsIntegral R (⇑(Algebra_Map A B) x)) : IsIntegral R x
{M : Type u} [MulOneClass M] (x : M) : SemiconjBy 1 x x
{R : Type u_1} {A : Type u_2} [CommSemiring R] [Semiring A] [Algebra R A] (h : Function.Injective ⇑(Algebra_Map R A)) [CharZero R] : CharZero A
{α : Type u_1} {β : Type u_2} [AddCommMonoid α] [TopologicalSpace α] [t2_Space α] [CompleteLattice β] (m : β → α) (m0 : m ⊥ = 0) (R : α → α → Prop) (m_supr : ∀ (s : ℕ → β), R (m (⨆ (i : ℕ), s i)) (∑' (i : ℕ), m (s i))) (s₁ s₂ : β) : R (m (s₁ ⊔ s₂)) (m s₁ + m s₂)
{C : Type u} [CategoryTheory.Category C] {X Y X' : C} (h : X' ⟶ X) (f : X ⟶ Y) [CategoryTheory.Limits.HasImage f] [CategoryTheory.Limits.HasImage (h ≫ f)] : Category_theory.limits.image_Subobject (h ≫ f) ≤ Category_theory.limits.image_Subobject f
{R₁ R₂ : ℝ} {c z : ℂ} {f : ℂ → ℂ} (hD : DifferentiableOn ℂ f (Metric.Ball c R₁)) (h_maps : Set.MapsTo f (Metric.Ball c R₁) (Metric.Ball (f c) R₂)) (hz : z ∈ Metric.Ball c R₁) : ∥dslope f c z∥ ≤ R₂ / R₁
{α : Type u} {a b : α} [MulOneClass α] [HasZero α] [Preorder α] [ZeroLt.MulPosMono α] (ha : a ≤ 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1
{R : Type u} [CommSemiring R] (p q : Polynomial R) : ⇑Polynomial.derivative (Polynomial.eval₂ Polynomial.c q p) = Polynomial.eval₂ Polynomial.c q (⇑Polynomial.derivative p) * ⇑Polynomial.derivative q
{R : Type u} [Ring R] {Γ₀ : Type v} [LinearOrderedCommGroupWithZero Γ₀] (v : Valuation R Γ₀) : RingSubgroupsBasis (λ (γ : Γ₀ˣ), v.lt_AddSubgroup γ)
{X : Type u_1} [TopologicalSpace X] {x y : X} : Inseparable x y → nhds x = nhds y
{R : Type u_1} [CommSemiring R] {l : Type u_2} {m : Type u_3} {n : Type u_4} [Fintype n] [Fintype m] [DecidableEq n] {M₁ : Type u_5} {M₂ : Type u_6} [AddCommMonoid M₁] [AddCommMonoid M₂] [Module R M₁] [Module R M₂] (v₁ : Basis n R M₁) (v₂ : Basis m R M₂) {M₃ : Type u_7} [AddCommMonoid M₃] [Module R M₃] (v₃ : Basis l R M₃) [Fintype l] [DecidableEq m] (A : Matrix l m R) (B : Matrix m n R) (x : M₁) : ⇑(⇑(matrix.to_lin v₁ v₃) (A.mul B)) x = ⇑(⇑(matrix.to_lin v₂ v₃) A) (⇑(⇑(matrix.to_lin v₁ v₂) B) x)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p₁ p₂ : ι → P) : s.sum (λ (i : ι), w i • (p₁ i -ᵥ p₂ i)) = ⇑(s.weighted_vsub p₁) w - ⇑(s.weighted_vsub p₂) w
(A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] [h : IsCyclotomicExtension {1} A B] : ⊥ = ⊤
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop) (hp₀ : p 1) (hp₁ : ∀ (x y : M), p x → p y → p (x * y)) (hp₂ : ∀ (x : α), x ∈ s → p (f x)) : p (finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)))
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set ℝ} [Interval_integral.FTC_Filter a (nhds_within a s) (nhds_within a t)] (hmeas : StronglyMeasurableAtFilter f (nhds_within a t) MeasureTheory.MeasureSpace.volume) (ha : ContinuousWithinAt f t a) (hs : UniqueDiffWithinAt ℝ s a . "UniqueDiffWithinAt_ici_Iic_Univ") : deriv_within (λ (u : ℝ), ∫ (x : ℝ) in u..b, f x) s a = -f a
{α : Type u_1} [TopologicalSpace α] {x : α} {s : Set α} {γ : Type u_4} [LinearOrderedAddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] {f g : α → γ} (hF : LowerSemicontinuousWithinAt f s x) (hg : LowerSemicontinuousWithinAt g s x) (hcont : ContinuousAt (λ (p : γ × γ), p.fst + p.snd) (f x, g x)) : LowerSemicontinuousWithinAt (λ (z : α), f z + g z) s x
(s : Set Cardinal) : BddAbove s ↔ Small ↥s
{R : Type u_1} [Semiring R] {M : Type u_2} [AddCommMonoid M] (P Q : Module R M) (w : ∀ (r : R) (m : M), r • m = r • m) : P = Q
{α : Type u} [PartialOrder α] [DecidableRel has_le.le] {a b : α} (hab : a ≤ b) : a = b ∨ a < b
{A : Type u_2} [AddMonoid A] {x y : A} : y ∈ AddSubmonoid.closure {x} ↔ ∃ (n : ℕ), n • x = y
{α : Type u} {a b : α} [MulZeroClass α] [Preorder α] [ZeroLt.PosMulStrictMono α] (ha : 0 < a) (hb : 0 < b) : 0 < a * b
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) : LinearIndependent 𝕜 v
{α : Type u_1} {β : Type u_2} {G₀ : Type u_3} [GroupWithZero G₀] [TopologicalSpace G₀] [HasContinuousInv₀ G₀] [HasContinuousMul G₀] [TopologicalSpace α] [TopologicalSpace β] {a : α} {f g : α → G₀} (h : α → G₀ → β) (hF : ContinuousAt f a) (hg : ContinuousAt g a) (hH : g a ≠ 0 → ContinuousAt ↿h (a, f a / g a)) (h2h : g a = 0 → Filter.Tendsto ↿h ((nhds a).prod ⊤) (nhds (h a 0))) : ContinuousAt (λ (x : α), h x (f x / g x)) a
{ι : sort u_1} {α : Type u_2} {β : Type u_3} [CompleteLattice α] [CompleteLattice β] (f : α ≃o β) {a : ι → α} (ha : CompleteLattice.Independent a) : CompleteLattice.Independent (⇑f ∘ a)
{C : Type u} [CategoryTheory.Category C] {F : C ⥤ C} {A : CategoryTheory.Endofunctor.Algebra F} (h : CategoryTheory.Limits.IsInitial A) : CategoryTheory.IsIso A.str
{R : Type u_1} {S : Type u_2} [CommRing R] [CommRing S] [Algebra R S] {ι : Type w} [Fintype ι] (b : Basis ι R S) (x : R) : ⇑(Algebra.trace R S) (⇑(Algebra_Map R S) x) = Fintype.card ι • x
{R : Type u_1} {M : Type u_2} [CommMonoid M] [CommSemiring R] {S : Set M} (hS : Submonoid.closure S = ⊤) : Function.Surjective ⇑(MvPolynomial.aeval (λ (s : ↥S), ⇑(MonoidAlgebra.of R M) ↑s))
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [FiniteDimensional 𝕜 E] [FiniteDimensional 𝕜 F] (A : E →ₗ[𝕜] F) (x : E) (y : F) : HasInner.inner (⇑(⇑LinearMap.adjoint A) y) x = HasInner.inner y (⇑A x)
{G₁ : Type u_2} {G₂ : Type u_3} [Group G₁] [Group G₂] [group.is_nilpotent G₁] [group.is_nilpotent G₂] : group.nilpotency_class (G₁ × G₂) = Linear_order.max (group.nilpotency_class G₁) (group.nilpotency_class G₂)
{ι : Type u} (s : Finset ι) (f g : ι → Ennreal) {p : ℝ} (hp : 1 ≤ p) : s.sum (λ (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤ s.sum (λ (i : ι), f i ^ p) ^ (1 / p) + s.sum (λ (i : ι), g i ^ p) ^ (1 / p)
{α : Type u} [PseudoMetricSpace α] (x y : α) : HasDist.dist x y = ↑(HasNndist.nndist x y)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [TopologicalSpace.SecondCountableTopology α] : {x : α | ∃ (y : α), x < y ∧ Set.Ioo x y = ∅}.countable
{R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] {m : ℕ} (x : M) (v : Fin m → M) (hli : LinearIndependent R v) (x_IsOrtho : ∀ (c : R) (y : ↥(Submodule.span R (Set.Range v))), c • x + ↑y = 0 → c = 0) : LinearIndependent R (fin.cons x v)
{M : Type u_1} [AddZeroClass M] {s : Set M} : s ⊆ ↑(AddSubmonoid.closure s)
{α : Type u} [Monoid α] (f : ℕ → α) (n : ℕ) : (List.map f (List.range n.succ)).prod = f 0 * (List.map (λ (i : ℕ), f i.succ) (List.range n)).prod
(𝕜 : Type u_1) [NondiscreteNormedField 𝕜] (𝕜' : Type u_2) [NormedRing 𝕜'] [NormedAlgebra 𝕜 𝕜'] : IsBoundedBilinearMap 𝕜 (λ (p : 𝕜' × 𝕜'), ⇑(⇑(Continuous_Linear_map.lmul_Left_Right 𝕜 𝕜') p.fst) p.snd)
{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] {s : Set E} (hs : Convex 𝕜 s) {a b : 𝕜} (ha : 0 < a) (hb : 0 ≤ b) (hab : a + b = 1) : a • Interior s + b • Closure s ⊆ Interior s
{s : ℂ} (hs : 0 < s.re) : (s + 1).Gamma_integral = s * s.Gamma_integral
{α : Type u} [OrderedSemiring α] [Nontrivial α] : 0 < 2
{α : Type u} {l : List α} : l.nodup → l.attach.nodup
{X Y Z : Type u} (f : X ⟶ Y) {g h : Y ⟶ Z} (w : f ≫ g = f ≫ h) (t : CategoryTheory.Limits.IsLimit (Category_theory.limits.fork.of_ι f w)) (y : Y) (hy : g y = h y) : ∃! (x : X), f x = y
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {n : ℕ} : iterated_fderiv 𝕜 (n + 1) f = ⇑(Continuous_multilinear_Curry_Left_Equiv 𝕜 (λ (i : Fin (n + 1)), E) F) ∘ fderiv 𝕜 (iterated_fderiv 𝕜 n f)
{α : Type u_1} {ι : Type u_4} [TopologicalSpace α] [Encodable ι] {s : ι → Set α} (hs : ∀ (i : ι), is_Gδ (s i)) : is_Gδ (⋂ (i : ι), s i)
(m : Type u_1) (R : Type u_3) [DecidableEq m] [Fintype m] [CommRing R] [Nontrivial R] : (matrix.mv_Polynomial.x m m R).det ≠ 0
{α : Type u_1} [DecidableEq α] (s : Finset α) : (Finset.image Quotient.mk s.off_diag).card = s.card.choose 2
{C : Type u} [CategoryTheory.Category C] {J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ C) [CategoryTheory.Limits.HasColimit (CategoryTheory.Discrete.functor F.obj)] [CategoryTheory.Limits.HasColimit (CategoryTheory.Discrete.functor (λ (f : Σ (p : J × J), p.fst ⟶ p.snd), F.obj f.fst.fst))] [CategoryTheory.Limits.HasCoequalizers C] : CategoryTheory.Limits.HasColimit F
{𝕜 : Type u_1} {E : Type u_2} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {p : FormalMultilinearSeries 𝕜 𝕜 E} {x : 𝕜} (h : HasFpowerSeriesAt 0 p x) : p = 0
{M : Type u_1} [Monoid M] {s₁ s₂ : Set M} (is₁ : IsSubmonoid s₁) (is₂ : IsSubmonoid s₂) : IsSubmonoid (s₁ ∩ s₂)
(A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : ⇑(Polynomial.aeval x) (minpoly A x) = 0
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} {s t : Set α} (hst : s ⊆ t) (ht : t.finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t  s), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))
{M₀ : Type u_1} [CancelMonoidWithZero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : b * a = a) : a = 0
{α : Type u} [Group α] [HasLe α] [CovariantClass α α (Function.swap has_mul.mul) has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] : FiniteDimensional.finrank K V = 0 ↔ Subsingleton V
{R : Type u_1} {M : Type u_2} [CommMonoid M] [CommRing R] [Nontrivial R] [h : Algebra.FiniteType R (MonoidAlgebra R M)] : monoid.fg M
{M : Type u_1} {N : Type u_2} [HasMul M] [HasMul N] {c : Con M} {d : Con N} {C : c.quotient → d.quotient → Prop} (p : c.quotient) (q : d.quotient) (H : ∀ (x : M) (y : N), C ↑x ↑y) : C p q
{α : Type u_1} [PseudoMetricSpace α] {x : α} {E : Set α} (hx : x ∈ E) (δ : ℝ) : Metric.ClosedBall x δ ⊆ Metric.Cthickening δ E
{V : Type u₁} [Quiver V] {C : Type u_1} [CategoryTheory.Category C] {F G : CategoryTheory.Paths V ⥤ C} (h_obj : F.obj = G.obj) (h : ∀ (a b : V) (e : a ⟶ b), F.map e.to_Path = Category_theory.eq_to_hom _ ≫ G.map e.to_Path ≫ Category_theory.eq_to_hom _) : F = G
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {s : Set E} (s_conv : Convex ℝ s) {f : E → F} {f' : E → (E →L[ℝ] F)} {f'' : E →L[ℝ] E →L[ℝ] F} (hF : ∀ (x : E), x ∈ Interior s → HasFderivAt f (f' x) x) {x : E} (xs : x ∈ s) (hx : HasFderivWithinAt f' f'' (Interior s) x) {v w : E} (h4v : x + 4 • v ∈ Interior s) (h4w : x + 4 • w ∈ Interior s) : (λ (h : ℝ), f (x + h • (2 • v + 2 • w)) + f (x + h • (v + w)) - f (x + h • (2 • v + w)) - f (x + h • (v + 2 • w)) - h ^ 2 • ⇑(⇑f'' v) w) =o[nhds_within 0 (Set.Ioi 0)] λ (h : ℝ), h ^ 2
{𝕜 : Type u_1} {E : Type u_4} {Fₗ : Type u_7} [NormedGroup E] [NormedGroup Fₗ] [NondiscreteNormedField 𝕜] [NormedSpace 𝕜 E] [NormedSpace 𝕜 Fₗ] (c : E →L[𝕜] 𝕜) (f : Fₗ) : ∥c.smul_Right f∥₊ = ∥c∥₊ * ∥f∥₊
{α : Type u_6} {β : Type u_7} [HasMul β] [HasScalar α β] [IsScalarTower α β β] (r : α) (x y : β) : r • x * y = r • (x * y)
{C : Type u₁} [CategoryTheory.Category C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} {c : CategoryTheory.Limits.PullbackCone f g} (h : CategoryTheory.Limits.IsLimit c) : CategoryTheory.IsPullback c.fst c.snd f g
{α : Type u_1} {β : Type u_2} {M : Type u_5} [AddCommMonoid M] {s : Set α} {t : Set β} (f : α → β → M) (hs : s.finite) (ht : t.finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s), finsum (λ (j : β), finsum (λ (H : j ∈ t), f i j)))) = finsum (λ (j : β), finsum (λ (H : j ∈ t), finsum (λ (i : α), finsum (λ (H : i ∈ s), f i j))))
{E : Type u_1} {F : Type u_2} {𝕜 : Type u_3} {𝕜₂ : Type u_4} [SemiNormedGroup E] [SemiNormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [RingHomIsometric σ₁₂] {ι : Type u_5} [CompleteSpace E] {g : ι → (E →sl[σ₁₂] F)} (h : ∀ (x : E), ∃ (C : ℝ), ∀ (i : ι), ∥⇑(g i) x∥ ≤ C) : ∃ (C' : ℝ), ∀ (i : ι), ∥g i∥ ≤ C'
{B : Type u} [Quiver B] {a b c : B} (p : Quiver.Path a b) {f g : CategoryTheory.FreeBicategory.Hom b c} (η : f ⟶ g) : Category_theory.bicategory.whisker_Left ((CategoryTheory.FreeBicategory.preinclusion B).map {as := p}) η ≫ (Category_theory.free_bicategory.normalize_iso p g).hom = (Category_theory.free_bicategory.normalize_iso p f).hom ≫ (CategoryTheory.FreeBicategory.preinclusion B).map₂ (Category_theory.eq_to_hom _)
{R : Type u} [CommRing R] (U V : TopologicalSpace.Opens ↥(AlgebraicGeometry.PrimeSpectrum.top R)) (hUV : U = V) : AlgebraicGeometry.StructureSheaf.comap (RingHom.id R) U V _ = Category_theory.eq_to_hom _
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] (s : Submodule K V) : s.fg ↔ FiniteDimensional K ↥s
{α : Type u_1} [DecidableEq α] {𝒜 : Finset (Finset α)} {s : Finset α} : s ∈ 𝒜.shadow ↔ ∃ (t : Finset α) (H : t ∈ 𝒜) (a : α) (H : a ∈ t), t.erase a = s
{α : Type u} [PseudoMetricSpace α] {s : Set α} {x : α} (h : x ∈ s) : metric.inf_dist x s = 0
{C : Type u} [CategoryTheory.Category C] {F : C ⥤ C} {A₀ A₁ : CategoryTheory.Endofunctor.Algebra F} (f : A₀ ⟶ A₁) [CategoryTheory.IsIso f.f] : CategoryTheory.IsIso f
{G : Type u_1} [Group G] {k : Set G} {p : G → G → Prop} {x y : G} (hx : x ∈ Subgroup.closure k) (hy : y ∈ Subgroup.closure k) (Hk : ∀ (x : G), x ∈ k → ∀ (y : G), y ∈ k → p x y) (H1_Left : ∀ (x : G), p 1 x) (H1_Right : ∀ (x : G), p x 1) (hMul_Left : ∀ (x₁ x₂ y : G), p x₁ y → p x₂ y → p (x₁ * x₂) y) (hMul_Right : ∀ (x y₁ y₂ : G), p x y₁ → p x y₂ → p x (y₁ * y₂)) (Hinv_Left : ∀ (x y : G), p x y → p x⁻¹ y) (Hinv_Right : ∀ (x y : G), p x y → p x y⁻¹) : p x y
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) (i j k : D.to_glue_data.J) (U : TopologicalSpace.Opens ↥((CategoryTheory.Limits.pullback (D.to_glue_data.f i j) (D.to_glue_data.f i k)).carrier)) : ∃ (Eq1 : (TopologicalSpace.Opens.map (D.to_glue_data.t k i).base).op.obj (Opposite.op (_.open_functor.obj U)) = Opposite.op (_.open_functor.obj (Opposite.unop ((TopologicalSpace.Opens.map (D.to_glue_data.t' k i j).base).op.obj (Opposite.op U))))), _.inv_App U ≫ (D.to_glue_data.t k i).c.app (Opposite.op (_.open_functor.obj U)) ≫ (D.to_glue_data.V (k, i)).presheaf.map (Category_theory.eq_to_hom Eq1) = (D.to_glue_data.t' k i j).c.app (Opposite.op U) ≫ _.inv_App (Opposite.unop ((TopologicalSpace.Opens.map (D.to_glue_data.t' k i j).base).op.obj (Opposite.op U)))
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] [RegularSpace Y] {f : X → Y} {A : Set X} (hA : Dense A) (hF : ∀ (x : X), ∃ (y : Y), Filter.Tendsto f (nhds_within x A) (nhds y)) : Continuous (extend_from A f)
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) (i j k : D.to_glue_data.J) (U : TopologicalSpace.Opens ↥((CategoryTheory.Limits.pullback (D.to_glue_data.f i j) (D.to_glue_data.f i k)).carrier)) : _.inv_App U ≫ (D.to_glue_data.t k i).c.app (Opposite.op (_.open_functor.obj U)) = (D.to_glue_data.t' k i j).c.app (Opposite.op U) ≫ _.inv_App (Opposite.unop ((TopologicalSpace.Opens.map (D.to_glue_data.t' k i j).base).op.obj (Opposite.op U))) ≫ (D.to_glue_data.V (k, i)).presheaf.map (Category_theory.eq_to_hom _)
{C : Type u₁} [CategoryTheory.Category C] {X : C} (P : Cᵒᵖ ⥤ Type w) {S : CategoryTheory.Sieve X} {R : CategoryTheory.Presieve X} (h : ⇑S ≤ R) (hS : CategoryTheory.Presieve.IsSheafFor P ⇑S) (Trans : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, R f → CategoryTheory.Presieve.IsSeparatedFor P ⇑(CategoryTheory.Sieve.pullback f S)) : CategoryTheory.Presieve.IsSheafFor P R
{R : Type u_1} {a b : R} [AddSemigroup R] (Ab : IsAddRegular (a + b)) (ba : IsAddRegular (b + a)) : IsAddRegular a ∧ IsAddRegular b
(S : Set ℕ+) (A : Type u) (B : Type v) [CommRing A] [CommRing B] [Algebra A B] : IsCyclotomicExtension S A B ↔ (∀ (a : ℕ+), a ∈ S → (∃ (r : B), ⇑(Polynomial.aeval r) (Polynomial.cyclotomic ↑a A) = 0)) ∧ Algebra.adjoin A {b : B | ∃ (a : ℕ+), a ∈ S ∧ b ^ ↑a = 1} = ⊤
{X : Type u_1} {Y : Type u_2} [PseudoEmetricSpace X] [PseudoEmetricSpace Y] {C r : Nnreal} {f : X → Y} {s : Set X} (hF : HolderOnWith C r f s) (h0 : 0 < r) : UniformContinuousOn f s
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b : α} : -a < -b → b < a
{α : Type u_1} : WellFounded has_lt.lt
{M : Type u_1} [has_Add M] (c : AddCon M) {x y z : M} : ⇑c x y → ⇑c y z → ⇑c x z
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} (x : E) {v : ι → E} {s : Finset ι} (hv : Orthonormal 𝕜 v) : s.sum (λ (i : ι), ∥HasInner.inner (v i) x∥ ^ 2) ≤ ∥x∥ ^ 2
{R : Type u} [CommSemiring R] (r : R) : ⇑Polynomial.c r = ⇑(Algebra_Map R (Polynomial R)) r
{α : Type u_2} {β : Type u_3} [LinearOrderedField α] [LinearOrderedField β] [Archimedean β] : Subsingleton (α →+*o β)
{x n : ℕ} (h : x.coprime n) : x ^ n.totient ≡ 1 [Mod n]
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] {f : ℝ → E} {T : ℝ} (hF : Function.Periodic f T) (t s : ℝ) : ∫ (x : ℝ) in t..t + T, f x = ∫ (x : ℝ) in s..s + T, f x
{α : Type u} [Preorder α] {s : Set α} : ¬BddBelow s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), ¬x ≤ y
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (a b c p : P) (h : EuclideanGeometry.angle b p c = Real.pi) : HasDist.dist a b ^ 2 * HasDist.dist c p + HasDist.dist a c ^ 2 * HasDist.dist b p = HasDist.dist b c * (HasDist.dist a p ^ 2 + HasDist.dist b p * HasDist.dist c p)
{α : Type u_1} {β : Type u_2} [CompleteLattice α] {f : Filter β} : f.limsup (λ (x : β), ⊥) = ⊥
{M : Type u_1} [HasMul M] {c : Con M} (x y : M) : ↑(x * y) = ↑x * ↑y
{α : Type u} {β : Type v} [CommSemiring β] (f g : α → β) (s : Finset α) : s.prod (λ (a : α), f a + g a) = s.powerset.sum (λ (t : Finset α), t.prod (λ (a : α), f a) * (s  t).prod (λ (a : α), g a))
{n : ℕ} (h_Odd : Odd n) (hlt : 1 < n) : bernoulli' n = 0
{n : ℕ} {x : Fin (n + 1)} : Function.Injective ⇑(x.succ_above)
{L : FirstOrder.Language} {T : L.Theory} : T.is_satisfiable ↔ T.is_finitely_satisfiable
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] {n : ℕ} (a b : Fin (n + 1) → ℝ) (hle : a ≤ b) (f : Fin (n + 1) → (Fin (n + 1) → ℝ) → E) (f' : Fin (n + 1) → (Fin (n + 1) → ℝ) → ((Fin (n + 1) → ℝ) →L[ℝ] E)) (s : Set (Fin (n + 1) → ℝ)) (hs : s.countable) (Hc : ∀ (i : Fin (n + 1)), ContinuousOn (f i) (Set.Icc a b)) (hD : ∀ (x : Fin (n + 1) → ℝ), x ∈ set.univ.pi (λ (i : Fin (n + 1)), Set.Ioo (a i) (b i))  s → ∀ (i : Fin (n + 1)), HasFderivAt (f i) (f' i x) x) (Hi : MeasureTheory.IntegrableOn (λ (x : Fin (n + 1) → ℝ), finset.univ.sum (λ (i : Fin (n + 1)), ⇑(f' i x) (Pi.single i 1))) (Set.Icc a b) MeasureTheory.MeasureSpace.volume) : ∫ (x : Fin (n + 1) → ℝ) in Set.Icc a b, finset.univ.sum (λ (i : Fin (n + 1)), ⇑(f' i x) (Pi.single i 1)) = finset.univ.sum (λ (i : Fin (n + 1)), (∫ (x : Fin n → ℝ) in Set.Icc (a ∘ ⇑(i.succ_above)) (b ∘ ⇑(i.succ_above)), f i (i.insert_nth (b i) x)) - ∫ (x : Fin n → ℝ) in Set.Icc (a ∘ ⇑(i.succ_above)) (b ∘ ⇑(i.succ_above)), f i (i.insert_nth (a i) x))
{V : Type u} {K : Type v} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] [hK : Invertible 2] {B : BilinForm K V} (hB₂ : B.is_Symm) : ∃ (v : Basis (Fin (FiniteDimensional.finrank K V)) K V), B.is_Ortho ⇑v
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (p1 p2 p3 : P) : EuclideanGeometry.angle p1 p2 p3 ≤ Real.pi
{α : Type u_1} [Preorder α] [AddCommSemigroup α] [HasSub α] [HasOrderedSub α] {a b c : α} [CovariantClass α α has_add.add has_le.le] : a + b - c ≤ a + (b - c)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : hb.oangle (-x) y = hb.oangle x y + ↑Real.pi
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b : α} : b < a → 0 < a - b
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {s : Set E} {t : Set F} {g : F → G} {f : E → F} (hg : ContDiffOn 𝕜 n g t) (hF : ContDiffOn 𝕜 n f s) : ContDiffOn 𝕜 n (g ∘ f) (s ∩ f ⁻¹' t)
{α : Type u} [PseudoMetricSpace α] {s : Set α} {x : α} : 0 ≤ metric.inf_dist x s
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z → B} [TopologicalSpace Z] [ConditionallyCompleteLinearOrder B] [OrderTopology B] (h : IsTopologicalFiberBundle F Proj) (a b : B) : ∃ (e : TopologicalFiberBundle.Trivialization F Proj), Set.Icc a b ⊆ e.base_Set
{M : Type u_1} [CancelCommMonoidWithZero M] {q : Associates M} {n : ℕ} (hn : n ≠ 0) {c : Fin (n + 1) → Associates M} (h₁ : StrictMono c) (h₂ : ∀ {r : Associates M}, r ≤ q ↔ ∃ (i : Fin (n + 1)), r = c i) (hq : q ≠ 0) : Irreducible (c 1)
{α : Type u_1} {β : Type u_2} [HasMul α] [Preorder α] [Preorder β] {f g : β → α} [CovariantClass α α has_mul.mul has_le.le] [CovariantClass α α (Function.swap has_mul.mul) has_lt.lt] (hF : StrictMono f) (hg : Monotone g) : StrictMono (λ (x : β), f x * g x)
(α : Type u_1) [TopologicalSpace α] [PolishSpace α] [Nonempty α] : ∃ (f : (ℕ → ℕ) → α), Continuous f ∧ Function.Surjective f
{R : Type u} [Semiring R] {p q : Polynomial R} : p * q = p.support.sum (λ (i : ℕ), q.sum (λ (j : ℕ) (a : R), ⇑(Polynomial.monomial (i + j)) (p.coeff i * a)))
{R : Type u_1} [CommSemiring R] {M : Type u_4} {N : Type u_5} {P : Type u_6} [AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P] [Module R M] [Module R N] [Module R P] {g h : TensorProduct R M N →ₗ[R] P} (H : (TensorProduct.mk R M N).compr₂ g = (TensorProduct.mk R M N).compr₂ h) : g = h
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s u : Set E} {f : E → F} {x : E} {n : ℕ} (hu : is_IsOpen u) (hs : UniqueDiffOn 𝕜 (s ∩ u)) (hx : x ∈ s ∩ u) : iterated_fderiv_within 𝕜 n f (s ∩ u) x = iterated_fderiv_within 𝕜 n f s x
{α : Type u} {β : Type v} [PseudoMetricSpace α] [PseudoMetricSpace β] {K : Nnreal} {s : Set α} {f : α → β} : (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → HasDist.dist (f x) (f y) ≤ ↑K * HasDist.dist x y) → LipschitzOnWith K f s
 : ¬IsField ℤ
{ι : Type u_1} {M : Type u_4} {N : Type u_5} [CommMonoid M] [OrderedCommMonoid N] (f : M → N) (p : M → Prop) (h_One : f 1 = 1) (h_Mul : ∀ (x y : M), p x → p y → f (x * y) ≤ f x * f y) (hp_Mul : ∀ (x y : M), p x → p y → p (x * y)) (g : ι → M) {s : Finset ι} (hs : ∀ (i : ι), i ∈ s → p (g i)) : f (s.prod (λ (i : ι), g i)) ≤ s.prod (λ (i : ι), f (g i))
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : E → ℝ} {a : E} (h : is_is_IsLocalMax f a) : fderiv ℝ f a = 0
{α : Type u_1} [Preorder α] [BoundedOrder α] [IsSimpleOrder α] {a b : α} (h : a < b) : a = ⊥
{α : Type u} {L₁ L₂ : List (α × Bool)} {x1 : α} {b1 : Bool} {x2 : α} {b2 : Bool} (H1 : (x1, b1) ≠ (x2, b2)) (H2 : FreeGroup.Red ((x1, b1) :: L₁) ((x2, b2) :: L₂)) : FreeGroup.Red L₁ ((x1, !b1) :: (x2, b2) :: L₂)
{α : Type u_1} {ι : sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α} (h : l.has_Basis p s) {q : ι → Prop} (hq : ∀ (i : ι), p i → (∃ (j : ι), p j ∧ q j ∧ s j ⊆ s i)) : l.has_Basis (λ (i : ι), p i ∧ q i) s
{C : Type u₁} [CategoryTheory.Category C] {A : Type u₂} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (P : Cᵒᵖ ⥤ A) [CategoryTheory.Limits.HasPullbacks C] (s : A ⥤ Type (max v₁ u₁)) [CategoryTheory.Limits.HasLimits A] [CategoryTheory.Limits.PreservesLimits s] [CategoryTheory.ReflectsIsomorphisms s] : CategoryTheory.Presheaf.IsSheaf J P ↔ CategoryTheory.Presheaf.IsSheaf J (P ⋙ s)
{α : Type u_1} {β : Type u_2} [LinearOrder α] [SuccOrder α] [Preorder β] {f : α → β} (hF : Antitone f) : Pairwise (Disjoint on λ (n : α), Set.Ico (f (Order.succ n)) (f n))
{C : Type u₁} [CategoryTheory.Category C] {A T : C} (hT : CategoryTheory.Limits.IsTerminal T) [CategoryTheory.Mono (hT.from A)] : CategoryTheory.IsSubterminal A
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] : Module.rank K V ≤ 1 ↔ ∃ (v₀ : V), ∀ (v : V), ∃ (r : K), r • v₀ = v
{ι : Type u_1} {E : Type u_3} [SemiNormedGroup E] {f : ι → E} {g : ι → ℝ} {a : ℝ} (hg : HasSum g a) (h : ∀ (i : ι), ∥f i∥ ≤ g i) : ∥∑' (i : ι), f i∥ ≤ a
{α : Type u} [TopologicalSpace α] [LocallyCompactSpace α] (x : α) : ∃ (K : Set α), is_IsCompact K ∧ K ∈ nhds x
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {f : E → G} {s : Set E} {C : Nnreal} (hF : ∀ (x : E), x ∈ s → DifferentiableAt 𝕜 f x) (bound : ∀ (x : E), x ∈ s → ∥fderiv 𝕜 f x∥₊ ≤ C) (hs : Convex ℝ s) : LipschitzOnWith C f s
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {n : WithTop ℕ} {f g : E → F} (hF : ContDiffAt 𝕜 n f x) (hg : ContDiffAt 𝕜 n g x) : ContDiffAt 𝕜 n (λ (x : E), f x + g x) x
{f : ℝ → ℝ} {a b l : ℝ} (hab : a < b) (hfa : Filter.Tendsto f (nhds_within a (Set.Ioi a)) (nhds l)) (hfb : Filter.Tendsto f (nhds_within b (Set.Iio b)) (nhds l)) : ∃ (c : ℝ) (H : c ∈ Set.Ioo a b), deriv f c = 0
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (s : Finset ι) [CharZero k] [Fintype ι] (h : s.card ≠ 0) : finset.univ.sum (λ (i : ι), Finset.centroid_weights_indicator k s i) = 1
{X : Type u} [Lattice X] [JordanHolderLattice X] {s₁ s₂ : CompositionSeries X} (h : ∀ (x : X), x ∈ s₁ ↔ x ∈ s₂) : s₁ = s₂
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) {s : Set ι} {i : ι} (hi : i ∉ s) {l : ι →₀ 𝕜} (hl : l ∈ Finsupp.supported 𝕜 𝕜 s) : HasInner.inner (⇑(Finsupp.total ι E 𝕜 v) l) (v i) = 0
{M : Type u_3} [Monoid M] (l : List M) : (l.nth 0).get_or_else 1 * l.tail.prod = l.prod
{α : Type u} {β : Type v} [EmetricSpace α] [PseudoEmetricSpace β] {f : α → β} (hF : Isometry f) : UniformEmbedding f
{K : Type u} [hfield : Field K] {L : Type u_1} [Field L] (f : K →+* L) (a : L) {x y : Ratfunc K} (hx : Polynomial.eval₂ f a x.denom ≠ 0) (hy : Polynomial.eval₂ f a y.denom ≠ 0) : Ratfunc.eval f a (x * y) = Ratfunc.eval f a x * Ratfunc.eval f a y
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b
{C : Type u_1} [CategoryTheory.Category C] (P : CategoryTheory.Idempotents.Karoubi C) : 𝟙 P = P.decomp_Id_i ≫ P.decomp_Id_p
{n : ℕ} {α : Type u_1} {v : Vector α (n + 1)} : v.last = v.nth (fin.last n)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] [TopologicalSpace δ] {e₁ : α → β} {e₂ : γ → δ} (de₁ : DenseInducing e₁) (de₂ : DenseInducing e₂) : DenseInducing (λ (p : α × γ), (e₁ p.fst, e₂ p.snd))
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] : IsBoundedBilinearMap 𝕜 (λ (p : (E →L[𝕜] 𝕜) × F), p.fst.smul_Right p.snd)
{X : Type v} [TopologicalSpace X] [LocallyCompactSpace X] [SigmaCompactSpace X] [t2_Space X] {ι : X → Type u} {p : Π (x : X), ι x → Prop} {B : Π (x : X), ι x → Set X} {s : Set X} (hs : is_IsClosed s) (hB : ∀ (x : X), x ∈ s → (nhds x).has_Basis (p x) (B x)) : ∃ (α : Type v) (c : α → X) (r : Π (a : α), ι (c a)), (∀ (a : α), c a ∈ s ∧ p (c a) (r a)) ∧ (s ⊆ ⋃ (a : α), B (c a) (r a)) ∧ LocallyFinite (λ (a : α), B (c a) (r a))
{α : Type u_1} {β : Type u_2} [Infinite β] (f : α → Finset β) (w : (⋃ (a : α), ↑(f a)) = ⊤) : Cardinal.mk β ≤ Cardinal.mk ↥(Set.Range f)
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [FiniteDimensional 𝕜 E] [FiniteDimensional 𝕜 F] (A : E →ₗ[𝕜] F) : ⇑LinearMap.adjoint (⇑LinearMap.adjoint A) = A
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} {s : Set E} : MdifferentiableOn (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s ↔ DifferentiableOn 𝕜 f s
(n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ List.ico a b
{α : Type u_1} {m m' : PseudoMetricSpace α} (h : pseudo_metric_space.to_HasDist = pseudo_metric_space.to_HasDist) : m = m'
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {f : E → F × G} {x : E} (hF : ContDiffAt 𝕜 n f x) : ContDiffAt 𝕜 n (λ (x : E), (f x).snd) x
{f : ℕ → ℝ} (h_nonneg : ∀ (n : ℕ), 0 ≤ f n) (h_Mono : ∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m) : Summable (λ (k : ℕ), 2 ^ k * f (2 ^ k)) ↔ Summable f
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {p1 p2 p3 p4 p5 : P} (hapc : EuclideanGeometry.angle p1 p5 p3 = Real.pi) (hbpd : EuclideanGeometry.angle p2 p5 p4 = Real.pi) : EuclideanGeometry.angle p1 p5 p2 = EuclideanGeometry.angle p3 p5 p4
{E : Type u_2} [AddCommGroup E] [Module ℝ E] (s : ConvexCone ℝ E) (f : LinearPmap ℝ E ℝ) (nonneg : ∀ (x : ↥(f.domain)), ↑x ∈ s → 0 ≤ ⇑f x) (Dense : ∀ (y : E), ∃ (x : ↥(f.domain)), ↑x + y ∈ s) (hdom : f.domain ≠ ⊤) : ∃ (g : LinearPmap ℝ E ℝ), f < g ∧ ∀ (x : ↥(g.domain)), ↑x ∈ s → 0 ≤ ⇑g x
{R : Type u_4} {S : Type u_5} [NonAssocSemiring R] [NonAssocSemiring S] (f : R ≃+* S) : ↑f.to_MonoidHom = ↑f.to_MonoidHom
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasFiniteWidePullbacks C] {B : C} : CategoryTheory.Limits.HasFiniteProducts (CategoryTheory.Over B)
{α : Type u} {β : Type v} [TopologicalSpace α] [SemiNormedGroup β] (f : BoundedContinuousFunction α β) : ∥f∥ = HasInf.inf {C : ℝ | 0 ≤ C ∧ ∀ (x : α), ∥⇑f x∥ ≤ C}
{α : Type u_1} [PseudoMetricSpace α] (C : ℝ) {f : ℕ → α} (hu₂ : ∀ (n : ℕ), HasDist.dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n) {a : α} (ha : Filter.Tendsto f filter.at_Top (nhds a)) : HasDist.dist (f 0) a ≤ C
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {x : E} {s t : Set E} (ht : t ∈ nhds x) : TangentConeAt 𝕜 (s ∩ t) x = TangentConeAt 𝕜 s x
{α : Type u} [PseudoMetricSpace α] {s t : Set α} {y : α} {r : ℝ} (h : y ∈ t) (H : metric.Hausdorff_dist s t < r) (Fin : emetric.Hausdorff_edist s t ≠ ⊤) : ∃ (x : α) (H : x ∈ s), HasDist.dist x y < r
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasEqualizers C] {X Y : C} [CategoryTheory.Simple Y] {f : X ⟶ Y} [CategoryTheory.Limits.HasImage f] (w : f ≠ 0) : CategoryTheory.Epi f
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [SemiNormedGroup E'] [SemiNormedGroup F'] {f' : α → E'} {g' : α → F'} {l : Filter α} : f' =o[l] g' → ((λ (x : α), ∥f' x∥) =o[l] λ (x : α), ∥g' x∥)
{n : ℕ} [Fact (0 < n)] (i : Zmod(2 * n)) : order_of (QuaternionGroup.a i) = 2 * n / (2 * n).gcd i.val
{n : ℕ} {fs : Finset (Fin (n + 1))} (h : fs.nonempty) : finset.univ.sum (λ (i : Affine.Simplex.PointsWithCircumcenterIndex n), affine.simplex.centroid_weights_with_circumcenter fs i) = 1
{M : Type u_1} [has_Add M] {c d : AddCon M} : c ≤ d ↔ ∀ {x y : M}, ⇑c x y → ⇑d x y
{α : Type u} [MulOneClass α] : IsMonoidHom Id
(𝕜 : Type u) [NondiscreteNormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace 𝕜] {r : ℝ} (rpos : 0 < r) (h : is_IsCompact (Metric.ClosedBall 0 r)) : FiniteDimensional 𝕜 E
{α : Type u_1} [ConditionallyCompleteLattice α] {s : Set α} {a b : α} (hs : BddAbove s) (ha : a ∈ s) (h : b < a) : b < HasSup.sup s
{ιa : Type u_7} {ιb : Type u_8} [DecidableEq ιa] [DecidableEq ιb] [Fintype ιa] [Fintype ιb] {R' : Type u_9} {Mᵢ : Type u_10} {N₁ : Type u_11} {N₂ : Type u_12} [CommSemiring R'] [AddCommGroup N₁] [Module R' N₁] [AddCommGroup N₂] [Module R' N₂] [AddCommMonoid Mᵢ] [Module R' Mᵢ] (a : MultilinearMap R' (λ (_x : ιa), Mᵢ) N₁) (b : MultilinearMap R' (λ (_x : ιb), Mᵢ) N₂) : ⇑MultilinearMap.alternatization (a.dom_Coprod b) = (⇑MultilinearMap.alternatization a).dom_Coprod (⇑MultilinearMap.alternatization b)
(x : Pgame) : (x + 0).equiv x
(R : Type u) [Semiring R] : StrongRankCondition R ↔ ∀ (n : ℕ) (f : (Fin (n + 1) → R) →ₗ[R] Fin n → R), ¬Function.Injective ⇑f
(p : ℕ) [Fact (Nat.Prime p)] : padic_norm p ↑p = 1 / ↑p
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) [Invertible A] : A.mul (⅟ A) = 1
{α : Type u_1} [DecidableEq α] {U V : Finset α} (hUV : U.card = V.card) (A : Finset α) : (Uv.compress U V A).card = A.card
{R : Type u_1} [CommSemiring R] (r : R) : ⇑LaurentPolynomial.c r = ⇑(Algebra_Map R (LaurentPolynomial R)) r
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] (p1 : P) (g : G) (p2 : P) : p1 = g +ᵥ p2 ↔ p1 -ᵥ p2 = g
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra A B] [Algebra R B] [Algebra R A] [IsScalarTower R A B] (hA : Algebra.IsIntegral R A) (hB : Algebra.IsIntegral A B) : Algebra.IsIntegral R B
{ι : Type u_1} {ι' : Type u_2} {α : Type u_3} [Fintype ι] [Preorder ι'] [IsDirected ι' has_le.le] [Nonempty ι'] {s : ι → ι' → Set α} (hs : ∀ (i : ι), Monotone (s i)) : (⋃ (j : ι'), ⋂ (i : ι), s i j) = ⋂ (i : ι), ⋃ (j : ι'), s i j
{J : Type u₁} [CategoryTheory.Category J] {C : Type u} [CategoryTheory.Category C] {K : Type u₁} [CategoryTheory.Category K] (F : J ⥤ C) (G : K ⥤ C) (h : F.cocones ≅ G.cocones) [CategoryTheory.Limits.HasColimit F] : CategoryTheory.Limits.HasColimit G
{α : Type u} [Infinite α] {s : Set α} (hF : s.finite) : s ∉ Filter.hyperfilter α
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1
{G : Type u} [Monoid G] {H : Type v} [Monoid H] (f : G →* H) {x : G} (h : IsOfFinOrder x) : IsOfFinOrder (⇑f x)
{α : Type u_1} {β : Type u_2} [UniformSpace α] {l : Filter β} {f : β → α × α} (h : Filter.Tendsto f l (Uniformity α)) : Filter.Tendsto (λ (x : β), ((f x).snd, (f x).fst)) l (Uniformity α)
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {f : Filter α} {g : Filter β} {m : α' → β → γ} {n : α → α'} {m' : β → α → δ} {n' : δ → γ} (h_Left_anticomm : ∀ (a : α) (b : β), m (n a) b = n' (m' b a)) : Filter.map₂ m (Filter.map n f) g = Filter.map n' (Filter.map₂ m' g f)
(u : ℤˣ) : u ^ 2 = 1
{G : Type w} [TopologicalSpace G] [AddGroup G] [TopologicalAddGroup G] {K U : Set G} (hK : is_IsCompact K) (hU : is_IsOpen U) (hKU : K ⊆ U) : ∃ (V : Set G) (H : V ∈ nhds 0), K + V ⊆ U
{b x : Ordinal} (h : 1 < b) : {o : Ordinal | x < b ^ o}.nonempty
{p : ℕ} [Fact (Nat.Prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [DenselyOrdered α] {δ : Type u_1} [LinearOrder δ] [TopologicalSpace δ] [OrderClosedTopology δ] {f : α → δ} (hF : Continuous f) (h_Top : Filter.Tendsto f filter.at_Top filter.at_Top) (h_IsBot : Filter.Tendsto f filter.at_IsBot filter.at_IsBot) : Function.Surjective f
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {f g : ℂ → E} (hdf : DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Ioi 0)) (hBf : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Ioi 0)] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hdg : DiffContOnCl ℂ g (Set.Iio 0 ×ℂ Set.Ioi 0)) (hBg : ∃ (c : ℝ) (H : c < 2) (B : ℝ), g =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Ioi 0)] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hre : ∀ (x : ℝ), x ≤ 0 → f ↑x = g ↑x) (him : ∀ (x : ℝ), 0 ≤ x → f (↑x * Complex.i) = g (↑x * Complex.i)) : Set.EqOn f g {z : ℂ | z.re ≤ 0 ∧ 0 ≤ z.im}
{R : Type u} [CommSemiring R] {S : Type v} [Semiring S] [Algebra R S] (p : Polynomial R) : ⇑(Polynomial.map_alg R S) p = Polynomial.map (Algebra_Map R S) p
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p₂ : ι → P) (p₁ b : P) : s.sum (λ (i : ι), w i • (p₁ -ᵥ p₂ i)) = s.sum (λ (i : ι), w i) • (p₁ -ᵥ b) - ⇑(s.weighted_vsub_of_point p₂ b) w
{S : Type u_1} [HasMul S] {a b : S} (h : Commute a b) : Commute b a
{R : Type u} [CommSemiring R] (t : Multiset (Polynomial R)) (h : (Multiset.map polynomial.leading_Coeff t).prod ≠ 0) : t.prod.leading_Coeff = (Multiset.map polynomial.leading_Coeff t).prod
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [HasScalar 𝕜 E] {S T : ConvexCone 𝕜 E} : ↑S = ↑T ↔ S = T
{x y z : Pgame} (h₁ : x.lf y) (h₂ : y < z) : x.lf z
{C : Type u₁} [CategoryTheory.Category C] {X Y : C} (f : X ⟶ Y) [CategoryTheory.RegularEpi f] [m : CategoryTheory.Mono f] : CategoryTheory.IsIso f
{γ : Type u_3} [tγ : TopologicalSpace γ] [PolishSpace γ] [MeasurableSpace γ] [BorelSpace γ] {s : Set γ} : PolishSpace.IsClopenable s ↔ MeasurableSet s
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] (a b : α) : Filter.comap Coe (nhds_within a (Set.Ioi a)) = filter.at_IsBot
(n : ℕ+) (S : Set ℕ+) (K : Type w) (L : Type z) [Field K] [Field L] [Algebra K L] [NeZero ↑↑n] [IsCyclotomicExtension S K L] (hS : n ∈ S) : Polynomial.Splits (Algebra_Map K L) (Polynomial.cyclotomic ↑n K)
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (x y : R) : v.int_Valuation_def (x * y) = v.int_Valuation_def x * v.int_Valuation_def y
{τ : Type u_1} {α : Type u_2} {β : Type u_3} [TopologicalSpace β] (f : Filter τ) (ϕ : τ → α → β) (s : Set α) (y : β) : y ∈ OmegaLimit f ϕ s ↔ ∀ (n : Set β), n ∈ nhds y → (∃ᶠ (t : τ) in f, (s ∩ ϕ t ⁻¹' n).nonempty)
{α : Type u_1} [TopologicalSpace α] {x : α} {s : Set α} {γ : Type u_4} [LinearOrderedAddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] [HasContinuousAdd γ] {f g : α → γ} (hF : LowerSemicontinuousWithinAt f s x) (hg : LowerSemicontinuousWithinAt g s x) : LowerSemicontinuousWithinAt (λ (z : α), f z + g z) s x
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f : ℂ → E} {c : ℂ} {R : ℝ} {w : ℂ} (hF : CircleIntegrable f c R) (hw : Complex.abs w < R) : HasSum (λ (n : ℕ), ⇑(Cauchy_PowerSeries f c R n) (λ (_x : Fin n), w)) ((2 * ↑Real.pi * Complex.i)⁻¹ • ∮ (z : ℂ) in C(c, R), (z - (c + w))⁻¹ • f z)
{α : Type u_1} {r : α → α → Prop} {s : Set α} [IsRefl α r] : s.pairwise r → ∀ ⦃a : α⦄, a ∈ s → ∀ ⦃b : α⦄, b ∈ s → r a b
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) : is_R_or_C.abs (HasInner.inner x y / (↑∥x∥ * ↑∥y∥)) = 1 ↔ x ≠ 0 ∧ ∃ (r : 𝕜), r ≠ 0 ∧ y = r • x
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] {a : α} : -a < 0 → 0 < a
{M : Type u_1} [Monoid M] {s : Set M} : s ⊆ monoid.closure s
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasCoproducts C] [CategoryTheory.Limits.HasCoequalizers C] : CategoryTheory.Limits.HasColimits C
{G : Type u_7} [AddCommGroup G] (L : List G) (n : ℕ) (a : G) : (L.update_nth n a).sum = L.sum + dite (n < L.length) (λ (hn : n < L.length), -L.nth_LE n hn + a) (λ (hn : ¬n < L.length), 0)
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜} (hs : Convex 𝕜 s) (hF : ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) < (f z - f y) / (z - y)) : StrictConvexOn 𝕜 s f
{M : Type u_1} {N : Type u_2} [HasMul M] [HasMul N] {c : Con M} {f : M → N} (H : ∀ (x y : M), f (x * y) = f x * f y) (h : con.mul_Ker f H ≤ c) (hF : Function.Surjective f) : c.map_gen f = c.map_of_surjective f H h hF
(M : Type u_1) (α : Type u_2) [Group M] [MulAction M α] {ι : sort u_3} {s : ι → Set α} : fixing_Subgroup M (⋃ (i : ι), s i) = ⨅ (i : ι), fixing_Subgroup M (s i)
{G : Type u_1} [Group G] [TopologicalSpace G] [TopologicalGroup G] [t2_Space G] {K₀ : TopologicalSpace.PositiveCompacts G} : ⇑(measure_theory.measure.haar.haar_content K₀) K₀.to_Compacts = 1
{γ : Type w} [SemilatticeSup γ] {s t : Set γ} : BddAbove (s ∪ t) ↔ BddAbove s ∧ BddAbove t
{α : Type u} [Group α] [HasLe α] [CovariantClass α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 → 1 ≤ a
(n p : ℕ) : (Finset.range n).sum (λ (k : ℕ), ↑k ^ p) = (Finset.range (p + 1)).sum (λ (i : ℕ), bernoulli i * ↑((p + 1).choose i) * ↑n ^ (p + 1 - i) / (↑p + 1))
{A : Type u_3} [Semiring A] [Algebra ℝ A] (f : ℂ →ₐ[ℝ] A) (x : ℝ) : ⇑f ↑x = ⇑(Algebra_Map ℝ A) x
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] : ⊤ ∈ FixedByFinite K L
{R : Type u} [NonAssocSemiring R] (s : Subsemiring R) {ι : Type u_1} {t : Finset ι} {f : ι → R} (h : ∀ (c : ι), c ∈ t → f c ∈ s) : t.sum (λ (i : ι), f i) ∈ s
{α : Type u_1} {M : Type u_5} [HasZero M] {f g : α →₀ M} : f = g ↔ ∀ (a : α), ⇑f a = ⇑g a
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {i : α → β} [t2_Space β] (di : DenseInducing i) (hD : Dense (Set.Range i)ᶜ) {s : Set α} (hs : is_IsCompact s) : Interior s = ∅
{C : Type u} [CategoryTheory.Category C] {X : Top} [CategoryTheory.Limits.HasProducts C] (F : Top.Presheaf C X) : F.is_sheaf ↔ F.is_sheaf_Opens_LE_cover
{α : Type u_1} (L L' : List (List α)) : L = L' ↔ L.join = L'.join ∧ List.map List.length L = List.map List.length L'
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {x : E} {n : WithTop ℕ} (h : ContDiffAt 𝕜 n f x) (hn : 1 ≤ n) : DifferentiableAt 𝕜 f x
{α : Type u} [PseudoEmetricSpace α] (δ : ℝ) : Metric.Cthickening δ ∅ = ∅
{C : Type v} [CategoryTheory.SmallCategory C] {D : Type v} [CategoryTheory.SmallCategory D] (F : C ⥤ D) [F.final] {E : Type u} [CategoryTheory.Category E] {G : D ⥤ E} [CategoryTheory.Limits.HasColimit (F ⋙ G)] : CategoryTheory.Limits.HasColimit G
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] (p : E) : ⇑(reflection K) p = bit0 ↑(⇑(Orthogonal_projection K) p) - p
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {ca cb : E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (ha : Filter.Tendsto f (nhds a ⊓ MeasureTheory.Measure_space.volume.ae) (nhds ca)) (hb : Filter.Tendsto f (nhds b ⊓ MeasureTheory.Measure_space.volume.ae) (nhds cb)) : HasFderivAt (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) ((ContinuousLinearMap.snd ℝ ℝ ℝ).smul_Right cb - (ContinuousLinearMap.fst ℝ ℝ ℝ).smul_Right ca) (a, b)
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : E → ℝ} {a : E} {f' : E →L[ℝ] ℝ} (h : is_is_IsLocalMin f a) (hF : HasFderivAt f f' a) : f' = 0
{α : Type u} {β : Type v} [Preorder β] {f : α → β} {s : Set α} {a : α} : IsMaxOn f s a → IsMinOn (⇑order_dual.to_dual ∘ f) s a
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) : Kᗮ = ⨅ (v : ↥K), (⇑innerSL ↑v).ker
{C : Type u} {A : Type u_1} [CategoryTheory.Category C] [AddCommMonoid A] [CategoryTheory.HasShift C A] {X Y : C} (f : X ⟶ Y) (i j : A) : (Category_theory.shift_Functor C j).map ((Category_theory.shift_Functor C i).map f) = (Category_theory.shift_comm X i j).hom ≫ (Category_theory.shift_Functor C i).map ((Category_theory.shift_Functor C j).map f) ≫ (Category_theory.shift_comm Y j i).hom
{α : Type u_1} [LinearOrder α] [PredOrder α] [IsPredArchimedean α] (r : α → α → Prop) {n m : α} (h1 : ∀ (i : α), i ∈ Set.Ioc m n → r i (Order.pred i)) (h2 : ∀ (i : α), i ∈ Set.Ioc n m → r (Order.pred i) i) : Relation.ReflTransGen r n m
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [SemiNormedGroup E] [SemiNormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [RingHomIsometric σ₁₂] (f : E →sl[σ₁₂] F) : LipschitzWith ∥f∥₊ ⇑f
{α : Type u_1} (r : Setoid α) : EqvGen.setoid Setoid.r = r
{α : Type u} [PseudoEmetricSpace α] (δ : ℝ) (E : Set α) : Metric.Thickening δ E ⊆ Metric.Cthickening δ E
{α : Type u} {β : Type v} [TopologicalSpace α] [SemiNormedGroup β] [StarAddMonoid β] [NormedStarGroup β] (f : BoundedContinuousFunction α β) : ⇑(HasStar.star f) = HasStar.star ⇑f
(x : CliffordAlgebra CliffordAlgebraComplex.q) : ⇑CliffordAlgebra.reverse x = x
{D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ} (hF : ContinuousOn f D) (hF' : ∀ (x : ℝ), x ∈ Interior D → 0 < deriv f x) : StrictMonoOn f D
{J : Type v} [CategoryTheory.SmallCategory J] [CategoryTheory.IsCofiltered J] (F : J ⥤ Top) (C : CategoryTheory.Limits.Cone F) (hC : CategoryTheory.Limits.IsLimit C) (T : Π (j : J), Set (Set ↥(F.obj j))) (hT : ∀ (j : J), TopologicalSpace.IsTopologicalBasis (T j)) (Univ : ∀ (i : J), Set.Univ ∈ T i) (Inter : ∀ (i : J) (U1 U2 : Set ↥(F.obj i)), U1 ∈ T i → U2 ∈ T i → U1 ∩ U2 ∈ T i) (compat : ∀ (i j : J) (f : i ⟶ j) (V : Set ↥(F.obj j)), V ∈ T j → ⇑(F.map f) ⁻¹' V ∈ T i) : TopologicalSpace.IsTopologicalBasis {U : Set ↥(C.X) | ∃ (j : J) (V : Set ↥(F.obj j)), V ∈ T j ∧ U = ⇑(C.π.app j) ⁻¹' V}
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {v : Set E} [FiniteDimensional 𝕜 E] (hv : Orthonormal 𝕜 Coe) : (∀ (u : Set E), u ⊇ v → Orthonormal 𝕜 Coe → u = v) ↔ ∃ (b : Basis ↥v 𝕜 E), ⇑b = Coe
{Γ₀ : Type u_1} [LinearOrderedCommGroupWithZero Γ₀] (γ : Γ₀) (h : γ ≠ 0) : nhds γ = has_pure.pure γ
{ι : Type u_1} {R : Type u_2} [CommRing R] [LinearOrder ι] (s : Finset ι) (f : ι → R) : s.prod (λ (i : ι), 1 - f i) = 1 - s.sum (λ (i : ι), f i * (Finset.filter (λ (_x : ι), _x < i) s).prod (λ (j : ι), 1 - f j))
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) {X : D} [CategoryTheory.IsIso (h.counit.app X)] : CategoryTheory.inv (R.map (h.counit.app X)) = h.unit.app (R.obj X)
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f f' : ℂ → E} {c : ℂ} {R : ℝ} (hR : 0 ≤ R) (h : ∀ (z : ℂ), z ∈ Metric.Sphere c R → HasDerivWithinAt f (f' z) (Metric.Sphere c R) z) : ∮ (z : ℂ) in C(c, R), f' z = 0
(C : Type u) [CategoryTheory.Category C] [∀ {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan f g)] : CategoryTheory.Limits.HasPullbacks C
{n k : ℕ} (h : k ≤ n) : n.desc_factorial k = n.factorial / (n - k).factorial
{α : Type u} {β : Type v} [DecidableEq α] [AddCommMonoid β] {s : Finset α} {x : α} (h : x ∉ s) (f : Finset α → β) : (HasInsert.insert x s).powerset.sum (λ (a : Finset α), f a) = s.powerset.sum (λ (a : Finset α), f a) + s.powerset.sum (λ (t : Finset α), f (HasInsert.insert x t))
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) (hx0 : x ≠ 0) (hy0 : y ≠ 0) : is_R_or_C.abs (HasInner.inner x y) = ∥x∥ * ∥y∥ ↔ ∃ (r : 𝕜), r ≠ 0 ∧ y = r • x
{α : Type u_1} [DecidableEq α] {𝒜 : Finset (Finset α)} {s : Finset α} : s ∈ 𝒜.shadow ↔ ∃ (a : α) (H : a ∉ s), HasInsert.insert a s ∈ 𝒜
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q) : ⇑f 0 = 0
{α : Type u} {β : Type v} [Group α] [Group β] {f : α → β} (hF : IsGroupHom f) {γ : Type u_1} [Group γ] {g : β → γ} (hg : IsGroupHom g) : IsGroupHom (g ∘ f)
{R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [Π (i : ι), Module R (M₁ i)] [Module R M₂] (f : MultilinearMap R M₁ M₂) {α : ι → Type u_1} (g : Π (i : ι), α i → M₁ i) (A : Π (i : ι), Finset (α i)) [Fintype ι] : ⇑f (λ (i : ι), (A i).sum (λ (j : α i), g i j)) = (fintype.pi_Finset A).sum (λ (r : Π (a : ι), α a), ⇑f (λ (i : ι), g i (r i)))
(Γ₀ : Type u_1) [LinearOrderedCommGroupWithZero Γ₀] (x : Γ₀) {s : Set Γ₀} (s_in : s ∈ LinearOrderedCommGroup_with_zero.nhds_fun Γ₀ x) : ∃ (t : Set Γ₀) (H : t ∈ LinearOrderedCommGroup_with_zero.nhds_fun Γ₀ x), t ⊆ s ∧ ∀ (y : Γ₀), y ∈ t → s ∈ LinearOrderedCommGroup_with_zero.nhds_fun Γ₀ y
{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] {s : Set E} (hs : Convex 𝕜 s) {x y : E} (hx : x ∈ Closure s) (hy : y ∈ Interior s) {t : 𝕜} (ht : t ∈ Set.Ioc 0 1) : x + t • (y - x) ∈ Interior s
{A : Type u_4} {K : Type u_5} {C : Type u_6} [CommRing A] [is_IsDomain A] [Field K] [Algebra A K] [IsFractionRing A K] [CommRing C] [Algebra A C] [Algebra K C] [IsScalarTower A K C] : Algebra.IsAlgebraic A C ↔ Algebra.IsAlgebraic K C
{K : Type u_1} [CommRing K] [is_IsDomain K] {p : Polynomial K} (hroots : ⇑Multiset.card p.roots = p.nat_degree) : ⇑Polynomial.c p.leading_Coeff * (Multiset.map (λ (a : K), Polynomial.x - ⇑Polynomial.c a) p.roots).prod = p
{α : Type u} {β : Type v} [Preorder α] [SemilatticeInf β] {f g : α → β} (hF : Monotone f) (hg : Monotone g) : Monotone (f ⊓ g)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [AddCommMonoid α] [TopologicalSpace α] [t2_Space α] [Encodable γ] [CompleteLattice β] (m : β → α) (m0 : m ⊥ = 0) (R : α → α → Prop) (m_supr : ∀ (s : ℕ → β), R (m (⨆ (i : ℕ), s i)) (∑' (i : ℕ), m (s i))) (s : γ → β) : R (m (⨆ (b : γ), s b)) (∑' (b : γ), m (s b))
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {F : J ⥤ C} {s t : CategoryTheory.Limits.Cocone F} (P : CategoryTheory.Limits.IsColimit s) (Q : CategoryTheory.Limits.IsColimit t) (f : s ⟶ t) : CategoryTheory.IsIso f
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] (s : Set P) : affine_Span k s = HasInf.inf {s' : AffineSubspace k P | s ⊆ ↑s'}
{α : Type u_1} {n : Type u_4} [is_R_or_C α] [Fintype n] [DecidableEq n] {A : Matrix n n α} : A.is_hermitian ↔ InnerProductSpace.IsSelfAdjoint (⇑((Pi_Lp.linear_Equiv α (λ (_x : n), α)).symm.conj) (⇑matrix.to_lin' A))
{α : Type u} [PseudoMetricSpace α] (x y : α) : HasDist.dist ↑x ↑y = HasDist.dist x y
{α : Type u_1} {β : Type u_2} {rα : α → α → Prop} {rβ : β → β → Prop} (hα : WellFounded rα) (hβ : WellFounded rβ) : WellFounded (Relation.GameAdd rα rβ)
{R : Type u_1} {S : Type u_4} [CommRing R] [CommRing S] (p : Polynomial R) (x : S) [Algebra R S] (h : ⇑(Polynomial.aeval x) p = 0) : IsIntegral R (p.leading_Coeff • x)
{n : ℕ} (hpos : 0 < n) (R : Type u_1) [CommRing R] : n.divisors.prod (λ (i : ℕ), Polynomial.cyclotomic i R) = Polynomial.x ^ n - 1
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) : ∃ (L L' : List (Matrix.TransvectionStruct (Fin r ⊕ Unit) 𝕜)), (((List.map matrix.transvection_struct.to_Matrix L).prod.mul M).mul (List.map matrix.transvection_struct.to_Matrix L').prod).is_two_block_Diagonal
{k : Type u_1} {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} {s : Finset ι} (p : ι → P) (h : ↑(s.card) ≠ 0) : Finset.centroid k s p ∈ affine_Span k (Set.Range p)
{α : Type u_1} (f : Finpartition Set.Univ) : setoid.is_Partition ↑(f.parts)
{n : ℕ} {β : Type u_1} (q : Fin (n + 2) → β) : fin.tail (fin.init q) = fin.init (fin.tail q)
(f : Circle_deg1_Lift) {x : ℝ} {m : ℤ} (h : ⇑f x = x + ↑m) : f.translation_number = ↑m
{𝕂 : Type u_1} [is_R_or_C 𝕂] : HasDerivAt (Exp 𝕂) 1 0
{α : Type u} {β : Type v} [UniformSpace α] [SemilatticeSup β] [CompleteSpace α] {u : β → α} (H : CauchySeq u) : ∃ (x : α), Filter.Tendsto u filter.at_Top (nhds x)
{a b r : ℝ} (h : -1 < r) : IntervalIntegrable (λ (x : ℝ), x ^ r) MeasureTheory.MeasureSpace.volume a b
{𝕜 : Type u_1} [is_R_or_C 𝕜] [DecidableEq 𝕜] {n : Type u_2} [Fintype n] [DecidableEq n] {A : Matrix n n 𝕜} (hA : A.is_hermitian) : hA.eigenvector_Matrix_inv.mul A = (Matrix.diagonal (Coe ∘ hA.eigenvalues)).mul hA.eigenvector_Matrix_Inv
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] [Nonempty V] : ∃ (v : V), G.min_degree = G.degree v
{S : Type u_1} [AddSemigroup S] {a b c : S} (hab : AddCommute a b) (hac : AddCommute a c) : AddCommute a (b + c)
{α : Type u_1} {l l' : List α} : l <+ l' ↔ ∃ (f : Fin l.length ↪o Fin l'.length), ∀ (ix : Fin l.length), l.nth_LE ↑ix _ = l'.nth_LE ↑(⇑f ix) _
{R S : CommRing} (f : R ⟶ S) (p : PrimeSpectrum ↥S) : (algebraic_geometry.structure_sheaf.stalk_iso ↥R (⇑(PrimeSpectrum.comap f) p)).hom ≫ localization.local_RingHom (⇑(PrimeSpectrum.comap f) p).as_Ideal p.as_Ideal f rfl ≫ (algebraic_geometry.structure_sheaf.stalk_iso ↥S p).inv = algebraic_geometry.PresheafedSpace.stalk_Map (algebraic_geometry.Spec.SheafedSpace_Map f) p
{R : Type u} [CommSemiring R] {S : Type v} [Semiring S] [Algebra R S] {p : Polynomial S} (r : R) (hp : p ∈ Polynomial.lifts (Algebra_Map R S)) : r • p ∈ Polynomial.lifts (Algebra_Map R S)
{M : Type u_1} {B : Type u_3} [AddMonoid M] [SetLike B M] [AddSubmonoidClass B M] {S : B} {l : List M} (hl : ∀ (x : M), x ∈ l → x ∈ S) : l.sum ∈ S
{R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B → Type u_5} [Semiring R] [Π (x : B), AddCommMonoid (E x)] [Π (x : B), Module R (E x)] [TopologicalSpace F] [AddCommMonoid F] [Module R F] [TopologicalSpace B] [TopologicalSpace (Bundle.TotalSpace E)] (e e' : TopologicalVectorBundle.Trivialization R F E) {b : B} (hb : b ∈ e.to_fiber_Bundle_trivialization.base_Set ∩ e'.to_fiber_Bundle_trivialization.base_Set) (y : F) : ⇑(e.coord_change e' b) y = (⇑e' (⇑(e.to_fiber_Bundle_trivialization.to_local_homeomorph.symm) (b, y))).snd
 : Function.Surjective Real.sinh
{α : Type u_1} [TopologicalSpace α] [BaireSpace α] {s : Set α} : s ∈ residual α ↔ ∃ (t : Set α) (H : t ⊆ s), is_Gδ t ∧ Dense t
{α : Type u} [TopologicalSpace α] {f : Filter α} {a : α} : f ≤ nhds a ↔ ∀ (s : Set α), a ∈ s → is_IsOpen s → s ∈ f
{R : Type u} [CommSemiring R] {n : ℕ} (hn : 0 < n) : Function.Injective ⇑(Polynomial.expand R n)
{α : Type u} [CommSemiring α] {p p' ps ps' : α} : p = p' → ps = ps' → p * ps = p' * ps'
{α : Type u_1} {n : Type u_4} [AddGroup n] {v : n → α} : (Matrix.circulant v).is_Symm ↔ ∀ (i : n), v (-i) = v i
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {f : 𝕜 → F} {x : 𝕜} {m : Fin n → 𝕜} : ⇑(iterated_fderiv 𝕜 n f x) m = finset.univ.prod (λ (i : Fin n), m i) • iterated_deriv n f x
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [StrictConvexSpace ℝ E] {x y : E} : SameRay ℝ x y ↔ ∥x + y∥ = ∥x∥ + ∥y∥
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (X Y : C) [CategoryTheory.Limits.HasBinaryBiproduct X Y] {b : CategoryTheory.Limits.BinaryBicone X Y} (hb : b.is_bilimit) : (hb.is_limit.cone_point_Unique_Up_to_iso (Category_theory.limits.binary_biproduct.is_Limit X Y)).inv = CategoryTheory.Limits.biprod.desc b.inl b.inr
{M : Type u_1} [has_Add M] {c d : AddCon M} : Setoid.r = Setoid.r ↔ c = d
{R : Type u} {n : ℕ} {M : Fin n.succ → Type v} {M₂ : Type v₂} [Semiring R] [Π (i : Fin n.succ), AddCommMonoid (M i)] [AddCommMonoid M₂] [Π (i : Fin n.succ), Module R (M i)] [Module R M₂] (f : MultilinearMap R M M₂) (m : Π (i : Fin n), M i.succ) (c : R) (x : M 0) : ⇑f (fin.cons (c • x) m) = c • ⇑f (fin.cons x m)
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} (h : InnerProductGeometry.angle x y = 0) : ∥x + y∥ = ∥x∥ + ∥y∥
{ι : Type u_1} {x : ℕ} {s : ι → ℕ} {t : Finset ι} : (∀ (i : ι), i ∈ t → x.coprime (s i)) → x.coprime (t.prod (λ (i : ι), s i))
{K : Type u_1} [LinearOrderedField K] {a : K} (H : 1 < a) (n : ℕ) : ↑n ≤ (a ^ n - 1) / (a - 1)
{α : Type u} {β : Type v} [OmegaCompletePartialOrder α] [OmegaCompletePartialOrder β] (c₀ : OmegaCompletePartialOrder.Chain (α →𝒄 β)) (c₁ : OmegaCompletePartialOrder.Chain α) (z : β) : (∀ (i j : ℕ), ⇑(⇑c₀ i) (⇑c₁ j) ≤ z) ↔ ∀ (i : ℕ), ⇑(⇑c₀ i) (⇑c₁ i) ≤ z
{α : Type u_1} [Preorder α] {f : α → α} (h : Id ≤ f) (n : ℕ) : Id ≤ (f^[n])
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [LinearOrderedField 𝕜] [AddCommGroup E] [LinearOrderedAddCommGroup β] [Module 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f : E → β} {t : Finset ι} {w : ι → 𝕜} {p : ι → E} (h : ConcaveOn 𝕜 s f) (hw₀ : ∀ (i : ι), i ∈ t → 0 ≤ w i) (hw₁ : 0 < t.sum (λ (i : ι), w i)) (hp : ∀ (i : ι), i ∈ t → p i ∈ s) : ∃ (i : ι) (H : i ∈ t), f (p i) ≤ f (t.center_mass w p)
{α : Type u} [AddGroup α] [HasLe α] [CovariantClass α α (Function.swap has_add.add) has_le.le] {a b : α} : a ≤ b → a - b ≤ 0
{𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} {P : Type u_8} {P₂ : Type u_9} [NormedField 𝕜] [SemiNormedGroup V] [SemiNormedGroup V₂] [NormedSpace 𝕜 V] [NormedSpace 𝕜 V₂] [PseudoMetricSpace P] [PseudoMetricSpace P₂] [NormedAddTorsor V P] [NormedAddTorsor V₂ P₂] {f : P →ᵃ[𝕜] P₂} : is_is_IsOpenMap ⇑(f.linear) ↔ is_is_IsOpenMap ⇑f
{K L : Type} [Field K] [Field L] [IsAlgClosed K] [IsAlgClosed L] [CharZero K] [CharZero L] (hK : Cardinal.aleph_0 < Cardinal.mk K) (hKL : Cardinal.mk K = Cardinal.mk L) : K ≃+* L
{R : Type u_1} [CommRing R] {M : Submonoid R} {S : Type u_2} [CommRing S] [Algebra R S] {Rₘ : Type u_4} {Sₘ : Type u_5} [CommRing Rₘ] [CommRing Sₘ] [Algebra R Rₘ] [IsLocalization M Rₘ] [Algebra S Sₘ] [IsLocalization (algebra.algebra_Map_Submonoid S M) Sₘ] {x : S} (p : Polynomial R) (hp : ⇑(Polynomial.aeval x) p = 0) (hM : p.leading_Coeff ∈ M) : (IsLocalization.map Sₘ (Algebra_Map R S) _).is_integral_elem (⇑(Algebra_Map S Sₘ) x)
{α : Type u} [HasSubset α] [HasSsubset α] [IsNonstrictStrictOrder α HasSubset.Subset HasSsubset.Ssubset] {a b : α} [IsAntisymm α HasSubset.Subset] (h : a ⊆ b) : a ⊂ b ∨ a = b
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] [CategoryTheory.Limits.HasLimits C] [CategoryTheory.Limits.HasColimits C] [CategoryTheory.ConcreteCategory C] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget C)] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)] {X Y : AlgebraicGeometry.SheafedSpace C} (f : X ⟶ Y) (hF : OpenEmbedding ⇑(f.base)) [H : ∀ (x : ↥X), CategoryTheory.IsIso (algebraic_geometry.PresheafedSpace.stalk_Map f x)] : AlgebraicGeometry.SheafedSpace.IsOpenImmersion f
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {s : Set E} {f g : E → F} (hF : ContDiffOn 𝕜 n f s) (hg : ContDiffOn 𝕜 n g s) : ContDiffOn 𝕜 n (λ (x : E), f x + g x) s
{n : ℕ} {x y : Fin (n + 1)} : x.succ_above = y.succ_above ↔ x = y
{𝕜 : Type u_1} {M : Type u_2} [DivisionRing 𝕜] [AddCommMonoid M] [TopologicalSpace M] [t1_Space M] [Module 𝕜 M] [HasContinuousConstSmul 𝕜 M] (c : 𝕜) : IsClosedMap (λ (x : M), c • x)
{α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] {f : Filter β} {u : β → α} {a : α} (hinf : f.liminf u = a) (hsup : f.limsup u = a) (h : Filter.IsBoundedUnder has_le.le f u . "is_bounded_Default") (h' : Filter.IsBoundedUnder GE f u . "is_bounded_Default") : Filter.Tendsto u f (nhds a)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K₁ K₂ : Submodule 𝕜 E) : K₁ᗮ ⊓ K₂ᗮ = (K₁ ⊔ K₂)ᗮ
{α : Type u_1} {ix : Fin 1} (x : α) : (x::ᵥVector.nil).nth ix = x
{α : Type u} (s : Set (Set α)) (i : (quotient.out (Cardinal.aleph 1).ord).α) : Cardinal.mk ↥(MeasurableSpace.GenerateMeasurableRec s i) ≤ Linear_order.max (Cardinal.mk ↥s) 2 ^ Cardinal.aleph_0
{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A] {s : Set A} {p : ↥(Algebra.adjoin R s) → Prop} (Hs : ∀ (x : A) (h : x ∈ s), p ⟨x, _⟩) (Halg : ∀ (r : R), p (⇑(Algebra_Map R ↥(Algebra.adjoin R s)) r)) (hAdd : ∀ (x y : ↥(Algebra.adjoin R s)), p x → p y → p (x + y)) (hMul : ∀ (x y : ↥(Algebra.adjoin R s)), p x → p y → p (x * y)) (x : ↥(Algebra.adjoin R s)) : p x
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (E : C ⥤ D) [CategoryTheory.IsEquivalence E] [CategoryTheory.Limits.HasColimitsOfSize D] : CategoryTheory.Limits.HasColimitsOfSize C
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) : o.oangle x y = θ ↔ ∃ (r : ℝ), 0 < r ∧ y = r • ⇑(o.rotation θ) x
{f f' : ℝ → ℝ} {a b l : ℝ} (hab : a < b) (hfa : Filter.Tendsto f (nhds_within a (Set.Ioi a)) (nhds l)) (hfb : Filter.Tendsto f (nhds_within b (Set.Iio b)) (nhds l)) (hff' : ∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivAt f (f' x) x) : ∃ (c : ℝ) (H : c ∈ Set.Ioo a b), f' c = 0
{a b c : ℤ} (h : fermat_42 a b c) : ∃ (a0 b0 c0 : ℤ), fermat_42.minimal a0 b0 c0 ∧ a0 % 2 = 1
{R : Type u_1} [Rack R] {G : Type u_2} [Group G] (f : ShelfHom R (Quandle.Conj G)) {a b : Rack.PreEnvelGroup R} : Rack.PreEnvelGroupRel' R a b → rack.to_envel_group.map_aux f a = rack.to_envel_group.map_aux f b
{α : Type u_1} [IsEmpty α] : Fintype.card α = 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) [DecidableEq ι] (w : ι → k) (p : ι → P) (i : ι) : ⇑((HasInsert.insert i s).weighted_vsub_of_point p (p i)) w = ⇑(s.weighted_vsub_of_point p (p i)) w
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : HasInner.inner x y = (∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - ∥x - y∥ * ∥x - y∥) / 2
{R : Type u_1} [CommSemiring R] {m : Type u_3} {n : Type u_4} [Fintype n] [Fintype m] [DecidableEq n] : matrix.to_lin (pi.basis_fun R n) (pi.basis_fun R m) = matrix.to_lin'
{n : ℤ} : Odd n → Odd n.nat_Abs
{S : Type u_2} [CommRing S] {K : Type u_4} [Field K] [Algebra K S] [Nontrivial S] (pB : PowerBasis K S) : ⇑(Algebra.trace K S) pb.gen = -(minpoly K pb.gen).next_Coeff
{R : Type u_1} {K : Type u_2} [CommRing R] [Field K] [Algebra R K] [IsFractionRing R K] [is_IsDomain R] [IsPrincipalIdealRing R] : Fintype.card (ClassGroup R K) = 1
{x y : PSet} : x.equiv y ↔ x.to_Set = y.to_Set
{α : Type u_1} {s : Finset α} {f : α → Ennreal} : s.sum (λ (x : α), f x) = ⊤ ↔ ∃ (a : α) (H : a ∈ s), f a = ⊤
{α : Type u} {β : Type v} [LinearOrderedField α] [TopologicalSpace α] [OrderTopology α] {l : Filter β} {f g : β → α} {C : α} (hC : C < 0) (hF : Filter.Tendsto f l (nhds C)) (hg : Filter.Tendsto g l filter.at_Top) : Filter.Tendsto (λ (x : β), f x * g x) l filter.at_IsBot
{R : Type u_1} [Monoid R] (a : Rˣ) : IsRegular ↑a
{α : Type u_1} [HasLt α] {a b : α} [DenselyOrdered α] : ¬a ⋖ b
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : ℕ} {i : Fin (n + 1)} : X.δ (⇑fin.cast_Succ i) ≫ X.σ i = 𝟙 (X.obj (SimplexCategory.mk n))
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] : (euclidean_geometry.orthogonal_projection s).linear = ↑(Orthogonal_projection s.direction)
{α : Type u_1} [PseudoMetricSpace α] [ProperSpace α] (x : α) (r : ℝ) : is_IsCompact (Metric.Sphere x r)
{M : Type u_1} [has_Add M] {c d : AddCon M} : Setoid.r = Setoid.r ⊓ Setoid.r
{M : Type u_1} [Group M] (c : Con M) (n : ℤ) {w x : M} : ⇑c w x → ⇑c (w ^ n) (x ^ n)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMaxOrder α] [DenselyOrdered α] {a : α} {s : Set α} : s ∈ nhds_within a (Set.Ioi a) ↔ ∃ (u : α) (H : u ∈ Set.Ioi a), Set.Ioc a u ⊆ s
{α : Type u_1} {s : Finset α} {a : α} [DecidableEq α] : (HasInsert.insert a s).card = Ite (a ∈ s) s.card (s.card + 1)
(R : Type u_1) [OrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] (v : M) (h : v ≠ 0) : -Ray_of_NeZero R v h = Ray_of_NeZero R (-v) _
{K : Type u} [Field K] (s : Subfield K) {x y : K} : x ∈ s → y ∈ s → x - y ∈ s
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {a : F} (ha : a ≠ 0) : char.quadratic_Char F a = 1 ↔ IsSquare a
{R : Type u_1} {a : R} [AddMonoid R] (ua : IsAddUnit a) : IsAddRegular a
(L : List ℕ) : L.head ≤ L.sum
{M : Type u_1} [Monoid M] {ι : Type u_2} [hι : Nonempty ι] {s : ι → Set M} (hs : ∀ (i : ι), IsSubmonoid (s i)) (Directed : ∀ (i j : ι), ∃ (k : ι), s i ⊆ s k ∧ s j ⊆ s k) : IsSubmonoid (⋃ (i : ι), s i)
{α : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [SemiNormedGroup E] [SemiNormedGroup F] [SemiNormedGroup G] {f : α → E} {g : α → F} {l : Filter α} (hF : Filter.Tendsto f l (nhds 0)) (hg : Filter.IsBoundedUnder has_le.le l (HasNorm.norm ∘ g)) (Op : E → F → G) (h_Op : ∀ (x : E) (y : F), ∥Op x y∥ ≤ ∥x∥ * ∥y∥) : Filter.Tendsto (λ (x : α), Op (f x) (g x)) l (nhds 0)
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : ℝ → E} {f' : E} {x r : ℝ} (hF : HasDerivWithinAt f f' (Set.Ici x) x) (hr : ∥f'∥ < r) : ∃ᶠ (z : ℝ) in nhds_within x (Set.Ioi x), (z - x)⁻¹ * (∥f z∥ - ∥f x∥) < r
{C : Type u} [CategoryTheory.Category C] (D : AlgebraicGeometry.PresheafedSpace.GlueData C) (i j k : D.to_glue_data.J) (U : TopologicalSpace.Opens ↥((D.to_glue_data.V (i, j)).carrier)) : _.inv_App U ≫ (D.to_glue_data.f i k).c.app (Opposite.op (_.open_functor.obj U)) = Category_theory.limits.pullback.fst.c.app (Opposite.op U) ≫ _.inv_App (Opposite.unop ((TopologicalSpace.Opens.map Category_theory.limits.pullback.fst.base).op.obj (Opposite.op U))) ≫ (D.to_glue_data.V (i, k)).presheaf.map (Category_theory.eq_to_hom _)
{M : Type u_1} [AddZeroClass M] {s : Set M} {S : AddSubmonoid M} : AddSubmonoid.closure s ≤ S ↔ s ⊆ ↑S
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [SemiNormedGroup E'] {g : α → F} {f' : α → E'} {l : Filter α} : (λ (x : α), ∥f' x∥) =O[l] g → f' =O[l] g
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {N : Type u_3} [AddCommMonoid N] [Module R N] {x y : M} (e : M ≃ₗ[R] N) : SameRay R (⇑e x) (⇑e y) ↔ SameRay R x y
{ι : Type u_1} {M : Type u_4} [OrderedAddCommMonoid M] {s : Finset ι} {f : ι → WithTop M} (h : ∀ (i : ι), i ∈ s → f i ≠ ⊤) : s.sum (λ (i : ι), f i) < ⊤
{α : Type u_1} [ConditionallyCompleteLinearOrder α] {s : Set α} {b : α} (hs : s.nonempty) (hb : HasInf.inf s < b) : ∃ (a : α) (H : a ∈ s), a < b
{α : Type u_1} [EmetricSpace α] {K : Nnreal} {f : α → α} (hF : ContractingWith K f) {s : Set α} (hs : Set.MapsTo f s s) : ContractingWith K (Set.MapsTo.restrict f s s hs)
{E : Type u_2} [AddCommGroup E] [Module ℝ E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousSmul ℝ E] {s : Set E} (hs : s.finite) : is_IsCompact (⇑(Convex_hull ℝ) s)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {ca cb : E} {la lb : Filter ℝ} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) {s t : Set ℝ} [Interval_integral.FTC_Filter a (nhds_within a s) la] [Interval_integral.FTC_Filter b (nhds_within b t) lb] (hmeas_a : StronglyMeasurableAtFilter f la MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f lb MeasureTheory.MeasureSpace.volume) (ha : Filter.Tendsto f (la ⊓ MeasureTheory.Measure_space.volume.ae) (nhds ca)) (hb : Filter.Tendsto f (lb ⊓ MeasureTheory.Measure_space.volume.ae) (nhds cb)) : HasFderivWithinAt (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) ((ContinuousLinearMap.snd ℝ ℝ ℝ).smul_Right cb - (ContinuousLinearMap.fst ℝ ℝ ℝ).smul_Right ca) (s ×ˢ t) (a, b)
{n : ℕ} {α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) (v : Vector α n) (i : Fin n) : (Vector.scanl f b v).nth i.succ = f ((Vector.scanl f b v).nth (⇑fin.cast_Succ i)) (v.nth i)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [SemiNormedGroup E] [NormedSpace 𝕜 E] : uniform_space.to_TopologicalSpace ≤ weak_dual.topological_Space 𝕜 E
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} (hs : UniqueDiffOn 𝕜 s) : ContDiffOn 𝕜 ⊤ f s ↔ DifferentiableOn 𝕜 f s ∧ ContDiffOn 𝕜 ⊤ (λ (y : E), fderiv_within 𝕜 f s y) s
{α : Type u} {β : Type v} [Ring α] [Ring β] {f : α → β} (hF : IsRingHom f) : f 0 = 0
{G : Type u_1} [Group G] {N : Type u_3} [Group N] {f g : G →* N} {s : Set G} (h : Set.EqOn ⇑f ⇑g s) : Set.EqOn ⇑f ⇑g ↑(Subgroup.closure s)
{α : Type u_1} {ι : sort u_3} [ConditionallyCompleteLattice α] {b : α} [Nonempty ι] {f : ι → α} (h₁ : ∀ (i : ι), b ≤ f i) (h₂ : ∀ (w : α), b < w → (∃ (i : ι), f i < w)) : (⨅ (i : ι), f i) = b
(α : Type u) {β : Type v} [Group α] [MulAction α β] (b : β) [Fintype α] [Fintype ↥(MulAction.Orbit α b)] [Fintype ↥(MulAction.stabilizer α b)] : Fintype.card ↥(MulAction.Orbit α b) * Fintype.card ↥(MulAction.stabilizer α b) = Fintype.card α
{ι : sort u_1} [Nonempty ι] {f : ι → Ennreal} {x : Ennreal} (h : x ≠ ⊤) : x * infi f = ⨅ (i : ι), x * f i
{α : Type u} {m : ℕ} (x : α) (u : Fin m.succ → α) : matrix.vec_Cons x u 1 = matrix.vec_head u
{α : Type u_1} {ι : Type u_3} [DistribLattice α] [OrderBot α] {s : Finset ι} {f : ι → α} : ↑s.pairwise_Disjoint f → s.sup_indep f
{α : Type u_1} {β : Type u_2} [Nontrivial α] {f : α → β} (hF : Function.Injective f) : Nontrivial β
{y : ℝ} (hy : 0 < y) : Filter.Tendsto (λ (x : ℝ), x ^ -y) filter.at_Top (nhds 0)
{G : Type u_1} {P : Type u_2} [AddCommGroup G] [AddTorsor G P] (p1 p2 p3 : P) : p3 -ᵥ p2 - (p3 -ᵥ p1) = p1 -ᵥ p2
{G : Type u} [Group G] [Fintype G] {N : Subgroup G} [N.normal] (hN : (Fintype.card ↥N).coprime N.index) : ∃ (H : Subgroup G), H.is_complement' N
{f : ℝ → ℝ} (hF : Differentiable ℝ f) (hF' : ∀ (x : ℝ), 0 ≤ deriv f x) : Monotone f
{α : Type u_1} [HasLt α] [DecidableEq α] (A B : Finset α) : (A  B).to_colex < (B  A).to_colex ↔ A.to_colex < B.to_colex
(r n : ℕ) : n.choose r ≤ n.choose (n / 2)
{R : Type u} [CommSemiring R] [Nontrivial R] (h : ∀ (a b : R), a ∈ Nonunits R → b ∈ Nonunits R → a + b ∈ Nonunits R) : LocalRing R
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) {p : P} {r : ℝ} (hr : ∀ (i : Fin (n + 1)), HasDist.dist (s.points i) p = r) : ↑(⇑(s.orthogonal_projection_Span) p) = s.circumcenter
{α : Type u} [AddZeroClass α] : is_AddMonoidHom.id
{M : Type u_1} [CommGroup M] (f : ℕ → M) (n : ℕ) : (Finset.range n).prod (λ (i : ℕ), f (i + 1) * (f i)⁻¹) = f n * (f 0)⁻¹
{f : ℕ → ℕ} (hF : Function.Injective f) : Filter.Tendsto f filter.at_Top filter.at_Top
{C : Type u} [CategoryTheory.Category C] (P : Cᵒᵖ ⥤ Type v) [P.representable] : CategoryTheory.Presieve.IsSheaf (Category_theory.sheaf.canonical_topology C) P
{α : Type u_1} (n : ℕ) (s : Finset α) : (finset.powerset_len n s).card = s.card.choose n
(R : Type u) (M : Type v) [Ring R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] : Module.rank R M = Cardinal.mk (Module.Free.ChooseBasisIndex R M)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {s : Set 𝕜} {n : WithTop ℕ} {m : ℕ} (h : ContDiffOn 𝕜 n f s) (hmn : ↑m < n) (hs : UniqueDiffOn 𝕜 s) : DifferentiableOn 𝕜 (iterated_deriv_within m f s) s
{k : Type u_1} {V1 : Type u_2} {V2 : Type u_4} [Ring k] [AddCommGroup V1] [Module k V1] [AddCommGroup V2] [Module k V2] (f : V1 →ᵃ[k] V2) : ⇑(f.linear) = ⇑f - λ (z : V1), ⇑f 0
{α : Type u_1} (v : Vector α 1) : v.tail = Vector.nil
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] {f : E → F} (hF : Differentiable ℂ f) (hb : Metric.Bounded (Set.Range f)) : ∃ (c : F), ∀ (z : E), f z = c
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι → 𝕜) {s : Finset ι} {i : ι} (hi : i ∈ s) : HasInner.inner (v i) (s.sum (λ (i : ι), l i • v i)) = l i
{α : Type u} [PseudoMetricSpace α] {s t : Set α} : metric.Hausdorff_dist s (Closure t) = metric.Hausdorff_dist s t
{R : Type u_1} [CommSemiring R] (M : Submonoid R) (S : Type u_2) [CommSemiring S] [Algebra R S] [IsLocalization M S] (J : Ideal S) : J.is_Prime ↔ (Ideal.comap (Algebra_Map R S) J).is_Prime ∧ Disjoint ↑M ↑(Ideal.comap (Algebra_Map R S) J)
{X : Top} (F : Top.Presheaf (Type v) X) (Fsh : F.is_sheaf) : F.is_sheaf_Unique_gluing
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {w : α → M} {b : M} [LinearOrderedCancelAddCommMonoid M] (ht : ∀ (y : β), y ∉ t → (Finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x) ≤ 0) (hb : t.card • b < s.sum (λ (x : α), w x)) : ∃ (y : β) (H : y ∈ t), b < (Finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x)
{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousConstSmul 𝕜 E] {s : Set E} (hs : Convex 𝕜 s) : Convex 𝕜 (Closure s)
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] {ι : sort u_2} (p : ι → Submodule R M) {C : M → Prop} {x : M} (hx : x ∈ ⨆ (i : ι), p i) (hp : ∀ (i : ι) (x : M), x ∈ p i → C x) (h0 : C 0) (hAdd : ∀ (x y : M), C x → C y → C (x + y)) : C x
{α : Type u_1} [LinearOrder α] (A B : Finset α) : (A  B).to_colex ≤ (B  A).to_colex ↔ A.to_colex ≤ B.to_colex
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : LocalHomeomorph α β} {s : Set α} {t : Set β} : e.is_image s t → e.to_local_equiv.source ∩ ⇑e ⁻¹' (e.to_local_equiv.target ∩ t) = e.to_local_equiv.source ∩ s
{R : Type u_1} {ι : Type u_2} {M₂ : Type u_4} {M₃ : Type u_5} [CommSemiring R] [AddCommMonoid M₂] [AddCommMonoid M₃] [Module R M₂] [Module R M₃] [DecidableEq ι] [Fintype ι] {f g : MultilinearMap R (λ (i : ι), M₂) M₃} {ι₁ : Type u_3} (e : Basis ι₁ R M₂) (h : ∀ (v : ι → ι₁), ⇑f (λ (i : ι), ⇑e (v i)) = ⇑g (λ (i : ι), ⇑e (v i))) : f = g
{K : Type u} [hfield : Field K] {L : Type u_1} [Field L] (f : K →+* L) (a : L) {x y : Ratfunc K} (hx : Polynomial.eval₂ f a x.denom ≠ 0) (hy : Polynomial.eval₂ f a y.denom ≠ 0) : Ratfunc.eval f a (x + y) = Ratfunc.eval f a x + Ratfunc.eval f a y
{α : Type u} [TopologicalSpace α] {s : Set α} (hs : is_IsCompact s) {f : Filter α} (hF : ∀ (a : α), a ∈ s → sᶜ ∈ nhds a ⊓ f) : sᶜ ∈ f
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {X : Top} [CategoryTheory.ConcreteCategory C] [CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)] (F : Top.Presheaf C X) (x : ↥X) (t : ↥(F.stalk x)) : ∃ (U : TopologicalSpace.Opens ↥X) (m : x ∈ U) (s : ↥(F.obj (Opposite.op U))), ⇑(F.germ ⟨x, m⟩) s = t
{α : Type u_1} {A B : Finset α} (i : ℕ) (h₁ : i + B.card ≤ A.card) (h₂ : B ⊆ A) : ∃ (C : Finset α), B ⊆ C ∧ C ⊆ A ∧ C.card = i + B.card
(𝕜 : Type u) [NondiscreteNormedField 𝕜] (E : Type v) [NormedGroup E] [NormedSpace 𝕜 E] [ProperSpace 𝕜] [FiniteDimensional 𝕜 E] : ProperSpace E
{α : Type u_2} [AddMonoid α] (m : α) : (∃ (c : α), m = 2 • c) → Even m
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [LinearOrderedAddCommMonoid β] [HasScalar 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f : E → β} (hF : ConvexOn 𝕜 s f) {x y : E} (hx : x ∈ s) (hy : y ∈ s) {a b : 𝕜} (ha : 0 ≤ a) (hb : 0 ≤ b) (hab : a + b = 1) : f (a • x + b • y) ≤ Linear_order.max (f x) (f y)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} {u v : E} (hu : u ∈ K) (hv : v ∈ Kᗮ) : HasInner.inner v u = 0
{α : Type u_1} [ConditionallyCompleteLattice α] {s : Set α} (hb : BddBelow s) (ha : BddAbove s) (NE : s.nonempty) : HasInf.inf s ≤ HasSup.sup s
{C : Type u₁} [CategoryTheory.Category C] {P X Y Z : C} {fst : P ⟶ X} {Snd : P ⟶ Y} {f : X ⟶ Z} {g : Y ⟶ Z} (w : CategoryTheory.CommSq fst Snd f g) (h : CategoryTheory.Limits.IsLimit w.cone) : CategoryTheory.IsPullback fst Snd f g
{α : Type u} [AddGroup α] [HasLe α] [CovariantClass α α has_add.add has_le.le] [CovariantClass α α (Function.swap has_add.add) has_le.le] (a : α) {b : α} : 0 ≤ b → a - b ≤ a
{n : ℕ+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [IsCyclotomicExtension {n} K L] (hirr : Irreducible (Polynomial.cyclotomic ↑n K)) [NeZero ↑↑n] : FiniteDimensional.finrank K L = ↑n.totient
{R : Type u} {L : Type v} {M : Type w} [CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M] {N₁ : LieSubmodule R L M} (h : N₁.centralizer = N₁) (k : ℕ) : LieSubmodule.ucs k ⊥ ≤ N₁
{G : Type u_1} [Group G] {N : Type u_3} [Group N] (H : Subgroup G) {f : N →* G} (hF : Function.Surjective ⇑f) : Subgroup.comap f H.normalizer = (Subgroup.comap f H).normalizer
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {c : AddCon M} {f : M →+ P} (H : c ≤ AddCon.ker f) (x : M) : ⇑(c.lift f H) (⇑(c.mk') x) = ⇑f x
{V : Type u_1} [InnerProductSpace ℝ V] (x : V) : InnerProductGeometry.angle x 0 = Real.pi / 2
{J : Type u₁} [CategoryTheory.Category J] {K : Type u₂} [CategoryTheory.Category K] (F : J ⥤ K) {j₁ j₂ : J} (h : CategoryTheory.Zigzag j₁ j₂) : CategoryTheory.Zigzag (F.obj j₁) (F.obj j₂)
(R : Type u_1) [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {C : Module.Ray R M → Prop} (h : ∀ (v : M) (hv : v ≠ 0), C (Ray_of_NeZero R v hv)) (x : Module.Ray R M) : C x
{p x : ℝ} (h : LiouvilleWith p x) (hp : 1 < p) : Irrational x
{R : Type u_1} [AddZeroClass R] : IsAddRegular 0
(M : Type u_1) (α : Type u_2) [Group M] [MulAction M α] : GaloisConnection (⇑order_dual.to_dual ∘ fixing_Subgroup M) ((λ (P : Subgroup M), MulAction.FixedPoints ↥P α) ∘ ⇑order_dual.of_dual)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} (p : ι → P) : AffineIndependent k p ↔ ∀ (s : Finset ι) (w : ι → k), s.sum (λ (i : ι), w i) = 0 → ⇑(s.weighted_vsub p) w = 0 → ∀ (i : ι), i ∈ s → w i = 0
{R : Type u_1} [MulZeroClass R] [Nontrivial R] : ¬IsRegular 0
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {x : E} {n : WithTop ℕ} (h : ContDiffWithinAt 𝕜 n f s x) (hn : 1 ≤ n) : DifferentiableWithinAt 𝕜 f (HasInsert.insert x s) x
{α : Type u} [TopologicalSpace α] [LocallyCompactSpace α] [t2_Space α] {K : Set α} (hK : is_IsCompact K) : ∃ (V : Set α), is_IsOpen V ∧ K ⊆ V ∧ is_IsCompact (Closure V)
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι} [p.ne_IsBot] (hF : UniformCauchySeqOn F p s) (hF' : ∀ (x : α), x ∈ s → Filter.Tendsto (λ (n : ι), F n x) p (nhds (f x))) : TendstoUniformlyOn F f p s
{α : Type u} [PseudoEmetricSpace α] {x : α} {s : Set α} : emetric.inf_edist x (Closure s) = emetric.inf_edist x s
{α : Type u_1} {ι : Type u_2} (s : ι → Set α) : (⨅ (i : ι), Filter.principal (s i)).has_Basis (λ (t : Set ι), t.finite) (λ (t : Set ι), ⋂ (i : ι) (H : i ∈ t), s i)
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {c : ℂ} {R : ℝ} (h0 : 0 < R) {f : ℂ → E} {y : E} {s : Set ℂ} (hs : s.countable) (hc : ContinuousOn f (Metric.ClosedBall c R  {c})) (hD : ∀ (z : ℂ), z ∈ Metric.Ball c R  {c}  s → DifferentiableAt ℂ f z) (hy : Filter.Tendsto f (nhds_within c {c}ᶜ) (nhds y)) : ∮ (z : ℂ) in C(c, R), (z - c)⁻¹ • f z = (2 * ↑Real.pi * Complex.i) • y
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b
{p q r : Prop} (h₁ : Implies p q) (h₂ : Implies q r) : Implies p r
{R : Type u_1} {A : Type u_2} {B : Type u_3} [CommRing R] [CommRing A] [CommRing B] [Algebra R A] [Algebra R B] (f : A ≃ₐ[R] B) : (IsIntegralClosure R A).map ↑f = IsIntegralClosure R B
{α : Type u} [PartialOrder α] [DecidableRel has_le.le] {a b : α} (hab : a ≤ b) : a < b ∨ a = b
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] {f : C(α, β)} {ι : Type u₃} {p : Filter ι} {F : ι → C(α, β)} (hα : ∀ (x : α), ∃ (n : Set α), is_IsCompact n ∧ n ∈ nhds x) (h : Filter.Tendsto F p (nhds f)) : TendstoLocallyUniformly (λ (i : ι) (a : α), ⇑(F i) a) ⇑f p
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b : α} : a - b < 0 → a < b
(k : Type u_1) [DivisionRing k] {ι : Type u_4} (s : Finset ι) (i : ι) : Finset.centroid_weights k s i = (↑(s.card))⁻¹
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_5} [NormedGroup E'] [NormedSpace 𝕜 E'] {n : WithTop ℕ} {f : E → E'} {x : E} : ContMdiffAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f x → ContDiffAt 𝕜 n f x
{α : Type u} [Preorder α] {a b c : α} (hab : a ≤ b) (hbc : b = c) : a ≤ c
(m : ℤ) {n : ℤ} (hn : 0 < n) : (∃ (k : ℤ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m
{F : Type v} [NormedGroup F] [NormedSpace ℂ F] [CompleteSpace F] {R : ℝ} {c : ℂ} {f : ℂ → F} (hR : 0 < R) (hF : DiffContOnCl ℂ f (Metric.Ball c R)) : deriv f c = (2 * ↑Real.pi * Complex.i)⁻¹ • ∮ (z : ℂ) in C(c, R), (z - c) ^ -2 • f z
{R : Type u_1} [Semiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {N : Type u_3} [AddCommMonoid N] [Module R N] {ι : Type u_6} [DecidableEq ι] {M₂ : Type u_7} [AddCommMonoid M₂] [Module R M₂] (f : M₂ →ₗ[R] M) (hF : Function.Surjective ⇑f) : Function.Injective (λ (g : AlternatingMap R M N ι), g.comp_Linear_Map f)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R) [CategoryTheory.IsIso h.unit] : CategoryTheory.Faithful L
{M₁ : Type u_3} {M₂ : Type u_4} [AddCommGroup M₁] [AddCommGroup M₂] {R : Type u_1} [OrderedRing R] [Module R M₁] [Module R M₂] {Q₁ : QuadraticForm R M₁} {Q₂ : QuadraticForm R M₂} (h : (Q₁.prod Q₂).anisotropic) : Q₁.anisotropic ∧ Q₂.anisotropic
(m : ℕ+) (p : Nat.Primes) (k : ℕ) : ↑p ^ k ∣ m ↔ k ≤ Multiset.count p m.factor_Multiset
{R : Type} [CommRing R] [CharZero R] {d : ℤ} (r : {r // r * r = ↑d}) (hD : ∀ (n : ℤ), d ≠ n * n) : Function.Injective ⇑(⇑Zsqrtd.lift r)
(V : Type u_2) {P : Type u_3} [SemiNormedGroup V] [PseudoMetricSpace P] [NormedAddTorsor V P] (x y : P) : HasDist.dist x y = ∥x -ᵥ y∥
{𝕜 : Type u} [NondiscreteNormedField 𝕜] (p : Polynomial 𝕜) (x : 𝕜) : HasStrictDerivAt (λ (x : 𝕜), Polynomial.eval x p) (Polynomial.eval x (⇑Polynomial.derivative p)) x
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] (v : PicardLindelof E) [CompleteSpace E] : ∃ (f : ℝ → E), f ↑(v.t₀) = v.x₀ ∧ ∀ (t : ℝ), t ∈ Set.Icc v.t_min v.t_max → HasDerivWithinAt f (⇑v t (f t)) (Set.Icc v.t_min v.t_max) t
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] (X Y : C) [CategoryTheory.Limits.HasBinaryCoproduct X Y] : CategoryTheory.Limits.HasBinaryBiproduct X Y
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (e : LocalHomeomorph α β) {x : α} (h : x ∈ e.to_local_equiv.source) : ContinuousAt ⇑e x
{α : Type u} (f : Filter α) [h : f.ne_IsBot] : ∃ (u : Ultrafilter α), ↑u ≤ f
{R : Type u} {M : Type v} {M₂ : Type w} {M₃ : Type y} [Semiring R] [AddCommMonoid M] [AddCommMonoid M₂] [AddCommMonoid M₃] [Module R M] [Module R M₂] [Module R M₃] {f g : M × M₂ →ₗ[R] M₃} (hl : f.comp (LinearMap.inl R M M₂) = g.comp (LinearMap.inl R M M₂)) (hr : f.comp (LinearMap.inr R M M₂) = g.comp (LinearMap.inr R M M₂)) : f = g
(C : Type u) [CategoryTheory.Category C] [∀ {X Y : C}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair X Y)] : CategoryTheory.Limits.HasBinaryCoproducts C
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] {A B : Matrix n n R} (c : n → R) (k : n) (hk : c k = 0) (A_Eq : ∀ (i j : n), A i j = B i j + c i * B k j) : A.det = B.det
{n : ℕ} {p q : ℕ × ℕ} (hp : p ∈ Finset.Nat.antidiagonal n) (hq : q ∈ Finset.Nat.antidiagonal n) : p = q ↔ p.fst = q.fst
{n : ℕ} [hpos : Fact (0 < n)] (i : Zmod(2 * n)) : order_of (QuaternionGroup.xa i) = 4
{β : Type u} {α : Type v} [AddCommMonoid β] [Fintype α] [DecidableEq α] (s : Finset α) (f : α → β) : s.sum (λ (i : α), f i) + sᶜ.sum (λ (i : α), f i) = finset.univ.sum (λ (i : α), f i)
{R : Type u_1} {a b : R} [AddCommSemigroup R] : IsAddRegular (a + b) ↔ IsAddRegular a ∧ IsAddRegular b
{α : Type u} [TopologicalSpace α] {s U : Set α} (h : ∀ (x : α), x ∈ s → U ∈ nhds x) : ∃ (V : Set α), s ⊆ V ∧ is_IsOpen V ∧ V ⊆ U
{α : Type u} [TopologicalSpace α] {s : Set α} : is_IsCompact s ↔ ∀ {ι : Type u} (U : ι → Set α), (∀ (i : ι), is_IsOpen (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : Finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b
{α : Type u} {s t : Set α} {l : Filter α} : s =ᶠ[l] t → (∀ᶠ (x : α) in l, x ∈ s ↔ x ∈ t)
{α : Type u} {f g : α → α} {x : α} (hfg : Function.IsFixedPt (f ∘ g) x) (hg : Function.IsFixedPt g x) : Function.IsFixedPt f x
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) (θ : Real.Angle) : o.oangle (⇑(o.rotation θ) x) (⇑(o.rotation θ) y) = o.oangle x y
{S : Set Ordinal} (hS : Set.Unbounded has_lt.lt S) {o : Ordinal} : {x : Ordinal | x ∈ S ∧ ∀ (c : Ordinal), c < o → ordinal.enum_Ord S c < x}.nonempty
{R : Type u_1} {M : Type u_2} {P : Type u_3} {N : Type w} [Ring R] [AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N] [AddCommGroup P] [Module R P] [IsNoetherian R M] [IsNoetherian R P] (f : M →ₗ[R] N) (g : N →ₗ[R] P) (hF : Function.Injective ⇑f) (hg : Function.Surjective ⇑g) (h : f.range = g.ker) : IsNoetherian R N
{R : Type u_1} [CommRing R] {G : Module R} {x y : CategoryTheory.Over G} (h : CategoryTheory.Abelian.PseudoEqual G x y) : LinearMap.range x.hom = LinearMap.range y.hom
{M : Type u_2} [AddCommGroup M] {𝕜 : Type u_1} [Field 𝕜] [Module 𝕜 M] (f : M →ₗ[𝕜] M) (hF : ⇑LinearMap.det f ≠ 1) : FiniteDimensional 𝕜 M
{α : Type u} {β : Type v} (f : α → β) {l : List α} {n : ℕ} (H : n < l.length) : f (l.nth_LE n H) = (List.map f l).nth_LE n _
(𝕜 : Type u_5) (𝕜' : Type u_6) [NormedField 𝕜] [SemiNormedRing 𝕜'] [NormedAlgebra 𝕜 𝕜'] [NormOneClass 𝕜'] : Isometry ⇑(Algebra_Map 𝕜 ??')
(x y z : Pgame) : (x * (y + z)).equiv (x * y + x * z)
{α : Type u_1} {ι : sort u_4} {s : Set α} {t : ι → Set α} (i : ι) (h : s ⊆ t i) : s ⊆ ⋃ (i : ι), t i
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {E : Type u₃} [CategoryTheory.Category E] {F : C ⥤ D} {G : D ⥤ E} {H : C ⥤ E} [ℋ : CategoryTheory.Faithful H] (h : F ⋙ G = H) : CategoryTheory.Faithful F
{y : ℝ} (hy : 0 < y) : Filter.Tendsto (λ (x : ℝ), x ^ y) filter.at_Top filter.at_Top
{a b : ℤ} (w : a ∣ b) (h : b.nat_Abs < a.nat_Abs) : b = 0
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} (hn : 2 ≤ n + 1) (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) {r a C : ℝ} (hr : 0 ≤ r) (ha : 0 ≤ a) (hC : 0 ≤ C) (hp : ∀ (n : ℕ), ∥p n∥ ≤ C * r ^ n) : (Finset.ico 1 (n + 1)).sum (λ (k : ℕ), a ^ k * ∥p.right_Inv i k∥) ≤ ∥↑(i.symm)∥ * a + ∥↑(i.symm)∥ * C * (Finset.ico 2 (n + 1)).sum (λ (k : ℕ), (r * (Finset.ico 1 n).sum (λ (j : ℕ), a ^ j * ∥p.right_Inv i j∥)) ^ k)
(f : C(↥UnitInterval, ℝ)) : Filter.Tendsto (λ (n : ℕ), bernstein_approximation n f) filter.at_Top (nhds f)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {s : Set E} {f : E → F} {n : WithTop ℕ} {p : E → FormalMultilinearSeries 𝕜 E F} (hF : HasFtaylorSeriesUpToOn n f p s) {g : E → G} {q : E → FormalMultilinearSeries 𝕜 E G} (hg : HasFtaylorSeriesUpToOn n g q s) : HasFtaylorSeriesUpToOn n (λ (y : E), (f y, g y)) (λ (y : E) (k : ℕ), (p y k).prod (q y k)) s
{α : Type u} [PseudoMetricSpace α] {s : Set α} {x : α} : metric.inf_dist x (Closure s) = metric.inf_dist x s
{α : Type u} {L₁ L₂ : List (α × Bool)} [DecidableEq α] (H : FreeGroup.Red L₁ L₂) : FreeGroup.reduce L₁ = FreeGroup.reduce L₂
{α : Type u} [Group α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] [CovariantClass α α (Function.swap has_mul.mul) has_lt.lt] {a b : α} : a < b⁻¹ → b < a⁻¹
{m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n
{n : ℕ} : (fin.last n).succ_above = fin.cast_Succ
 : ConvexOn ℝ Set.Univ Real.exp
{X : Type u_2} {Y : Type u_3} [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace.MetrizableSpace Y] {f : X → Y} (hF : Embedding f) : TopologicalSpace.MetrizableSpace X
{K : Type u_1} [LinearOrderedField K] [FloorRing K] {v : K} {n : ℕ} {ifp_Succ_n : GeneralizedContinuedFraction.IntFractPair K} : GeneralizedContinuedFraction.IntFractPair.stream v (n + 1) = Option.some ifp_Succ_n ↔ ∃ (ifp_n : GeneralizedContinuedFraction.IntFractPair K), GeneralizedContinuedFraction.IntFractPair.stream v n = Option.some ifp_n ∧ ifp_n.fr ≠ 0 ∧ GeneralizedContinuedFraction.IntFractPair.of (ifp_n.fr)⁻¹ = ifp_Succ_n
{F : Type} [Field F] (q : ℕ) {f : Polynomial F} (hF : Polynomial.HasSeparableContraction q f) [hF : ExpChar F q] (g : Polynomial F) (hg : Polynomial.IsSeparableContraction q f g) : g.nat_degree = hf.degree
{n : ℕ} {α : Type u_1} {v : Vector α (n + 1)} : v.reverse.head = v.last
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) {r₁ r₂ : ℝ} (hr₁ : 0 ≤ r₁) (hr₂ : 0 ≤ r₂) : o.oangle (r₁ • x) (r₂ • x) = 0
(G : Pgame) [G.impartial] : G.equiv (nim G.grundy_value)
{G : Type u_1} [AddGroup G] {N : Type u_3} [AddGroup N] (H : AddSubgroup G) (f : G ≃+ N) : AddSubgroup.map f.to_Add_MonoidHom H.normalizer = (AddSubgroup.map f.to_Add_MonoidHom H).normalizer
{C : Type u₁} [CategoryTheory.Category C] {Z X Y P : C} {f : Z ⟶ X} {g : Z ⟶ Y} {inl_ : X ⟶ P} {inr_ : Y ⟶ P} (w : CategoryTheory.CommSq f g inl_ inr_) (h : CategoryTheory.Limits.IsColimit w.cocone) : CategoryTheory.IsPushout f g inl_ inr_
{α : Type u} [Preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c
{K : Type u_1} {v : K} {n : ℕ} [LinearOrderedField K] [FloorRing K] (not_TerminatedAt_n : ¬(GeneralizedContinuedFraction.of v).terminated_at n) : (GeneralizedContinuedFraction.of v).numerators n * (GeneralizedContinuedFraction.of v).denominators (n + 1) - (GeneralizedContinuedFraction.of v).denominators n * (GeneralizedContinuedFraction.of v).numerators (n + 1) = (-1) ^ (n + 1)
{α : Type u} [AddGroup α] : IsAddGroupHom Id
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup V1] [Module k V1] [AddTorsor V1 P1] [AddCommGroup V2] [Module k V2] [AddTorsor V2 P2] (f : P1 →ᵃ[k] P2) (p1 p2 : P1) : ⇑(f.linear) (p1 -ᵥ p2) = ⇑f p1 -ᵥ ⇑f p2
{M : Type u_1} [CommMonoid M] {s : Set M} (hs : IsSubmonoid s) (m : Multiset M) : (∀ (a : M), a ∈ m → a ∈ s) → m.prod ∈ s
{𝕜 : Type u} [hnorm : NondiscreteNormedField 𝕜] {E : Type v} [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousSmul 𝕜 E] (l : E →ₗ[𝕜] 𝕜) (hl : is_IsClosed ↑(l.ker)) : Continuous ⇑l
{a : ℝ} {l : Filter ℝ} {f g : ℝ → ℝ} (hdf : ∀ᶠ (x : ℝ) in nhds_within a (Set.Ioi a), DifferentiableAt ℝ f x) (hg' : ∀ᶠ (x : ℝ) in nhds_within a (Set.Ioi a), deriv g x ≠ 0) (hfa : Filter.Tendsto f (nhds_within a (Set.Ioi a)) (nhds 0)) (hga : Filter.Tendsto g (nhds_within a (Set.Ioi a)) (nhds 0)) (hDiv : Filter.Tendsto (λ (x : ℝ), deriv f x / deriv g x) (nhds_within a (Set.Ioi a)) l) : Filter.Tendsto (λ (x : ℝ), f x / g x) (nhds_within a (Set.Ioi a)) l
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {D : Type u₂} [CategoryTheory.Category D] [CategoryTheory.Abelian D] (F : C ⥤ D) (G : D ⥤ C) [G.preserves_Zero_morphisms] (i : F ⋙ G ≅ 𝟭 C) (Adj : G ⊣ F) : CategoryTheory.Limits.HasCokernels C
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ - 2 * ⇑is_R_or_C.re (HasInner.inner x y) + ∥y∥ * ∥y∥
{J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.IsCofiltered J] (F : J ⥤ Type u) [hF : Π (j : J), Fintype (F.obj j)] [hne : ∀ (j : J), Nonempty (F.obj j)] : F.sections.nonempty
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] (p : P) : euclidean_geometry.orthogonal_projection_fn s p ∈ s
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrderedAddCommGroup α] [OrderTopology α] {l : Filter β} {f g : β → α} {C : α} (hF : Filter.Tendsto f l (nhds C)) (hg : Filter.Tendsto g l filter.at_IsBot) : Filter.Tendsto (λ (x : β), f x + g x) l filter.at_IsBot
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {p1 p2 p3 : P} (h : EuclideanGeometry.angle p1 p2 p3 = Real.pi) : EuclideanGeometry.angle p2 p3 p1 = 0
{R : Type u_1} [OrderedSemiring R] [Nontrivial R] : CharZero R
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (ha : ContinuousAt f a) (hb : ContinuousAt f b) : HasStrictFderivAt (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) ((ContinuousLinearMap.snd ℝ ℝ ℝ).smul_Right (f b) - (ContinuousLinearMap.fst ℝ ℝ ℝ).smul_Right (f a)) (a, b)
{R : Type u_3} {S : Type u_4} {A : Type u_5} [CommRing R] [CommRing S] [CommRing A] [Algebra R S] [Algebra S A] [Algebra R A] [IsScalarTower R S A] (hinj : Function.Injective ⇑(Algebra_Map R S)) {x : A} (A_alg : IsAlgebraic R x) : IsAlgebraic S x
{K : Type u_1} {v : K} {n : ℕ} [LinearOrderedField K] [FloorRing K] {gp : GeneralizedContinuedFraction.Pair K} (nth_s_Eq : (GeneralizedContinuedFraction.of v).s.nth n = Option.some gp) : gp.a = 1 ∧ ∃ (z : ℤ), gp.b = ↑z
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (w : ι → k) (p : ι → P) : ⇑(∅.weighted_vsub p) w = 0
{A : Type u_5} [CommRing A] {m : Type u_6} {n : Type u_7} [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n] {M : Matrix n m A} {N M' : Matrix m n A} (hMM' : M.mul M' = 1) (hM'M : M'.mul M = 1) : (M.mul N).det = (N.mul M).det
{R : Type u_1} [LinearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [Nontrivial R] (e : Basis ι R M) (i : ι) : (e.units_Smul (Function.update 1 i (-1))).orientation = -e.orientation
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D ⥤ C} [CategoryTheory.Reflective i] {A : C} (h : A ∈ i.ess_image) : CategoryTheory.IsIso ((Category_theory.adjunction.of_Right_Adjoint i).unit.app A)
{M₀ : Type u_1} [MulZeroClass M₀] [NoZeroDivisors M₀] {a b : M₀} : 0 = a * b ↔ a = 0 ∨ b = 0
{α : Type u_1} : vector.nil.tail = Vector.nil
{𝕜 : Type u_1} {α : Type u_2} [LinearOrderedField 𝕜] [DecidableEq α] [Fintype α] {𝒜 : Finset (Finset α)} {r : ℕ} (hr : r ≠ 0) (h𝒜 : Set.Sized r ↑𝒜) : ↑(𝒜.card) / ↑((Fintype.card α).choose r) ≤ ↑(𝒜.shadow.card) / ↑((Fintype.card α).choose (r - 1))
{α : Type u} : DenseInducing has_pure.pure
{α : Type u_1} {β : Type u_2} [Group α] [DivisionMonoid β] (f : α →* β) (a : α) : ⇑f a⁻¹ = (⇑f a)⁻¹
{α : Type u_1} [PartialOrder α] [PredOrder α] [IsPredArchimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ Set.Ioc m n → r i (Order.pred i)) (hnm : m ≤ n) : Relation.ReflTransGen r n m
 : Exp_Neg_Inv_glue.f_aux 0 = Exp_Neg_Inv_glue
(k : ℕ) {b : ℝ} (hb : 0 < b) : (λ (x : ℝ), x ^ k) =o[filter.at_Top] λ (x : ℝ), Real.exp (b * x)
{R : Type u_1} [CommGroup R] {f g : ℕ → R} : (∀ (n : ℕ), 0 < n → n.divisors.prod (λ (i : ℕ), f i) = g n) ↔ ∀ (n : ℕ), 0 < n → n.divisors_antidiagonal.prod (λ (x : ℕ × ℕ), g x.snd ^ ⇑Nat.ArithmeticFunction.moebius x.fst) = f n
{R₂ : Type u_5} {M₂ : Type u_6} [CommSemiring R₂] [AddCommMonoid M₂] [Module R₂ M₂] {B₂ F₂ : BilinForm R₂ M₂} {ι : Type u_13} (b : Basis ι R₂ M₂) (h : ∀ (i j : ι), ⇑B₂ (⇑b i) (⇑b j) = ⇑F₂ (⇑b i) (⇑b j)) : B₂ = F₂
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) : InnerProductGeometry.angle (-x) y = Real.pi - InnerProductGeometry.angle x y
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] (v : V) (n : v ≠ 0) (h : ∀ (w : V), ∃ (c : K), c • v = w) : FiniteDimensional.finrank K V = 1
{α : Type u_1} [DecidableEq α] [Fintype α] {f g : Equiv.perm α} (hF : f.is_Cycle) (hg : g.is_Cycle) (h : ∀ (x : α), x ∈ f.support ∩ g.support → ⇑f x = ⇑g x) {x : α} (hx : ⇑f x = ⇑g x) (hx' : x ∈ f.support) : f = g
{α : Type u} {β : Type v} [Ring α] [Ring β] {f : α → β} {x : α} (hF : IsRingHom f) : f (-x) = -f x
(F : Type u_1) [Field F] (E : Type u_2) [Field E] [Algebra F E] [Fintype F] [FiniteDimensional F E] : ∃ (α : E), F⟮α⟯ = ⊤
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (p1 p2 : P) : EuclideanGeometry.angle p1 p1 p2 = Real.pi / 2
{α : Type u_1} {A B : Set (Finset α)} {r : ℕ} : Set.Sized r A ∧ Set.Sized r B → Set.Sized r (A ∪ B)
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {f : M →+ P} (x : M) : ⇑(AddCon.ker f) x = ⇑f ⁻¹' {⇑f x}
{n : ℕ} (i : Zmod n) : order_of (DihedralGroup.sr i) = 2
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommMonoid β] [Module 𝕜 E] [HasScalar 𝕜 β] {s : Set E} {f : E → β} (hF : ConvexOn 𝕜 s f) (c : E) : ConvexOn 𝕜 ((λ (z : E), c + z) ⁻¹' s) (f ∘ λ (z : E), c + z)
{α : Type u} (s : Set (Set α)) : {t : Set α | MeasurableSpace.GenerateMeasurable s t} = ⋃ (i : (quotient.out (Cardinal.aleph 1).ord).α), MeasurableSpace.GenerateMeasurableRec s i
{x : ℝ} : (∀ (p : ℝ), LiouvilleWith p x) ↔ Liouville x
{M : Type u_1} {A : Type u_2} [CommMonoid M] {s : Set M} (hs : IsSubmonoid s) (f : A → M) (t : Finset A) : (∀ (b : A), b ∈ t → f b ∈ s) → t.prod (λ (b : A), f b) ∈ s
{α : sort u} {β : sort v} : Function.Injective Coe_fn
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x z - o.oangle y z = o.oangle x y
{α : Type u} [t : TopologicalSpace α] {B : Set (Set α)} (hB : TopologicalSpace.IsTopologicalBasis B) {u : Set α} (ou : is_IsOpen u) : u = ⋃₀{s ∈ B | s ⊆ u}
{α : Type u_1} [Preorder α] [SuccOrder α] {a b : α} [NoMaxOrder α] : Order.succ a ≤ Order.succ b → a ≤ b
{R : Type u} {A : Type v} {B : Type w} [CommSemiring R] [Semiring A] [Algebra R A] [Semiring B] [Algebra R B] [Subsingleton (Subalgebra R A)] : Subsingleton (A →ₐ[R] B)
{m n : ℕ} : m ∣ n + m ↔ m ∣ n
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {t : Finset V} (h : FiniteDimensional.finrank K V + 1 < t.card) : ∃ (f : V → K), t.sum (λ (e : V), f e • e) = 0 ∧ t.sum (λ (e : V), f e) = 0 ∧ ∃ (x : V) (H : x ∈ t), f x ≠ 0
{ι : Type w} {ι' : Type w'} {R : Type u} [Ring R] [InvariantBasisNumber R] {M : Type v} [AddCommGroup M] [Module R M] (v : Basis ι R M) (v' : Basis ι' R M) : (Cardinal.mk ι).lift = (Cardinal.mk ι').lift
{R : Type u_1} [NormedRing R] {x : R} (h : ∥x∥ < 1) : Filter.Tendsto (λ (n : ℕ), x ^ n) filter.at_Top (nhds 0)
{A : Type u_1} {B : Type u_2} [Field A] [Ring B] [is_IsDomain B] [Algebra A B] {x : B} (hx : IsIntegral A x) : Prime (minpoly A x)
{L : FirstOrder.Language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] {f g : L.hom M N} {s : Set M} (h : Set.EqOn ⇑f ⇑g s) : Set.EqOn ⇑f ⇑g ↑(⇑(FirstOrder.Language.Substructure.closure L) s)
{α : Type u_1} [UniformSpace α] : (Uniformity α).has_Basis (λ (V : Set (α × α)), V ∈ Uniformity α ∧ is_IsOpen V) Id
{α : Type u} [AddGroup α] [HasLe α] [CovariantClass α α (Function.swap has_add.add) has_le.le] {a b : α} : 0 ≤ a - b → b ≤ a
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M →* P} {T : Submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [CommMonoid Q] {k : T.localization_Map Q} (z : N) (u : Q) : ⇑(f.map hy k) z = u ↔ ⇑(k.to_Map) (⇑g (f.sec z).fst) = ⇑(k.to_Map) (⇑g ↑((f.sec z).snd)) * u
{p : ℕ → Prop} [DecidablePred p] {n : ℕ} : p n → Nat.count p (n + 1) = Nat.count p n + 1
{α : Type u_1} [Preorder α] {a b : αᵒᵈ} : b ⩿ a → ⇑order_dual.of_dual a ⩿ ⇑order_dual.of_dual b
{M : Type u_1} [AddMonoid M] {s t : Set M} (h : s ⊆ t) : Add_monoid.closure s ⊆ Add_monoid.closure t
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace β] [TopologicalSpace γ] [t2_Space γ] {f : α → β} (hfd : DenseRange f) {g h : β → γ} (hg : Continuous g) (hH : Continuous h) (H : g ∘ f = h ∘ f) : g = h
(K : Type u_1) [Field K] [NumberField K] : ¬IsField ↥(number_field.ring_of_integers K)
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : Nnreal} {c : ℂ} {f : ℂ → E} (hF : DiffContOnCl ℂ f (Metric.Ball c ↑R)) (hR : 0 < R) : HasFpowerSeriesOnBall f (Cauchy_PowerSeries f c ↑R) c ↑R
(a b : ℕ) : a - b.succ = a - b - 1
{X : Type u_1} {Y : Type u_2} [tY : TopologicalSpace Y] [DiscreteTopology Y] {f : X → Y} (hF : Function.Injective f) : DiscreteTopology X
{𝕜 : Type u_3} [Field 𝕜] {r : ℕ} (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (hM : M (Sum.inr ()) (Sum.inr ()) ≠ 0) (i : Fin r) : M.mul (matrix.pivot.list_transvec_row M).prod (Sum.inr ()) (Sum.inl i) = 0
{α : Type u_1} {r : α → α → Prop} {f : Filter α} [IsTrans α r] [f.ne_IsBot] : Filter.IsBounded r f → Filter.IsCobounded (Flip r) f
{c : ℝ} (h1 : 0 < c) (h2 : c < 1 / 2) : Function.Injective (cardinal.cantor_Function c)
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) : o.rotation ↑Real.pi = LinearIsometryEquiv.neg ℝ
(R : Type u_1) [CommRing R] (m n : ℕ) : Polynomial.dickson 1 1 (m * n) = (Polynomial.dickson 1 1 m).comp (Polynomial.dickson 1 1 n)
{α : Type u} [LinearOrder α] (a b : α) : Linear_order.max a b = a ∧ b ≤ a ∨ Linear_order.max a b = b ∧ a < b
{β : Type u} {α : Type v} {γ : Type w} [CommMonoid β] {s : Finset γ} {t : γ → Finset α} {t' : Finset α} {s' : α → Finset γ} (h : ∀ (x : γ) (y : α), x ∈ s ∧ y ∈ t x ↔ x ∈ s' y ∧ y ∈ t') {f : γ → α → β} : s.prod (λ (x : γ), (t x).prod (λ (y : α), f x y)) = t'.prod (λ (y : α), (s' y).prod (λ (x : γ), f x y))
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] (s1 s2 : AffineSubspace k P) : s1 ≤ s2 ↔ ∀ (p : P), p ∈ s1 → p ∈ s2
{G : Type u_1} [Group G] {p : ℕ} [Fact (Nat.Prime p)] {N : Subgroup G} [N.normal] [Fintype (Sylow p ↥N)] (P : Sylow p ↥N) : (Subgroup.map N.subtype ↑P).normalizer ⊔ N = ⊤
{ι : Type u_1} {R : Type u_2} {N : Type u_5} [decι : DecidableEq ι] [Semiring R] [AddCommMonoid N] [Module R N] [Π (m : R), Decidable (m ≠ 0)] (p : ι → Submodule R N) {v : ι → N} (hv : ∀ (i : ι), v i ∈ p i) : (⇑(Dfinsupp.lsum ℕ) (λ (i : ι), (p i).subtype)).comp ((dfinsupp.map_range.linear_Map (λ (i : ι), Linear_map.to_Span_Singleton R ↥(p i) ⟨v i, _⟩)).comp (Finsupp_lequiv_Dfinsupp R).to_Linear_Map) = Finsupp.total ι N R v
{α : Type u_1} [PseudoEmetricSpace α] (r C : Ennreal) (hr : r < 1) (hC : C ≠ ⊤) {f : ℕ → α} (hu : ∀ (n : ℕ), HasEdist.edist (f n) (f (n + 1)) ≤ C * r ^ n) : CauchySeq f
{R : Type u} [Ring R] {s : Set R} {t : Subring R} : Subring.closure s ≤ t ↔ s ⊆ ↑t
{α : Type u} [PseudoMetricSpace α] [ProperSpace α] {x : α} {r : ℝ} {s : Set α} (hr : 0 < r) (hs : is_IsClosed s) (h : s ⊆ Metric.Ball x r) : ∃ (r' : ℝ) (H : r' ∈ Set.Ioo 0 r), s ⊆ Metric.Ball x r'
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [FiniteDimensional 𝕜 E] [FiniteDimensional 𝕜 F] (A : E →ₗ[𝕜] F) (x : E) (y : F) : HasInner.inner x (⇑(⇑LinearMap.adjoint A) y) = HasInner.inner (⇑A x) y
(𝕜 : Type u_1) {E : Type u_2} [NormedLinearOrderedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedSpace ℝ E] [LinearMap.CompatibleSmul E E 𝕜 ℝ] (h : StrictConvex 𝕜 (Metric.ClosedBall 0 1)) : StrictConvexSpace 𝕜 E
{R : Type u_2} {M : Type u_3} [AddCommGroup M] [Ring R] [Module R M] {Q : QuadraticForm R M} : Q.to_fun = ⇑Q
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasEqualizers C] {X Y : C} {f : X ⟶ Y} (h : f = 0) [CategoryTheory.Limits.HasImage f] : CategoryTheory.Limits.imageι f = 0
{G : Type u_1} [Group G] (H N : Subgroup G) [N.normal] : ↑(H ⊔ N) = ↑H * ↑N
{K : Type u_1} {n : ℕ} {s : Seq (GeneralizedContinuedFraction.Pair K)} [DivisionRing K] (TerminatedAt_Succ_n : s.terminated_at (n + 1)) : generalized_continued_fraction.squash_Seq s n = s
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p : ι → P) (h : s.sum (λ (i : ι), w i) = 1) (b : P) : ⇑(s.affine_combination p) w = ⇑(s.weighted_vsub_of_point p b) w +ᵥ b
{α : Type u_1} {β : Type u_2} {rα : α → α → Prop} {rβ : β → β → Prop} {a : α} {b : β} (ha : Acc rα a) (hb : Acc rβ b) : Acc (Relation.GameAdd rα rβ) (a, b)
{ι : Type u_1} {X : Type u_2} [TopologicalSpace X] [NormalSpace X] {u : ι → Set X} (uo : ∀ (i : ι), is_IsOpen (u i)) (uf : ∀ (x : X), {i : ι | x ∈ u i}.finite) (uU : (⋃ (i : ι), u i) = Set.Univ) : ∃ (v : ι → Set X), Set.Union v = Set.Univ ∧ (∀ (i : ι), is_IsClosed (v i)) ∧ ∀ (i : ι), v i ⊆ u i
{C : Type u₁} [CategoryTheory.Category C] {T : CategoryTheory.Monad C} {J : Type u} [CategoryTheory.Category J] (D : J ⥤ T.algebra) [CategoryTheory.Limits.HasLimit (D ⋙ T.forget)] : CategoryTheory.Limits.HasLimit D
(t : ℝ) : Filter.Tendsto (λ (x : ℝ), (1 + t / x) ^ x) filter.at_Top (nhds (Real.exp t))
{D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ} (hF : ContinuousOn f D) (hF' : DifferentiableOn ℝ f (Interior D)) (hF'_nonpos : ∀ (x : ℝ), x ∈ Interior D → deriv f x ≤ 0) : AntitoneOn f D
{α : sort u} {f : α → α} (h : Function.involutive f) {x y : α} : f x = y ↔ x = f y
{n : ℕ} [Fact (0 < n)] (a : Zmod n) : ↑(a.val) = a
{n : ℕ} (h : n ≠ 0) (d : ℕ) : ∃ᶠ (m : ℕ) in filter.at_Top, m ≡ d [Mod n]
{ι : Type u_1} {R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] {b₁ b₂ : Basis ι R M} (h : ∀ (x : M) (i : ι), ⇑(⇑(b₁.repr) x) i = ⇑(⇑(b₂.repr) x) i) : b₁ = b₂
{f : ℝ → ℝ} {f' a : ℝ} (h : is_is_IsLocalMin f a) (hF : HasDerivAt f f' a) : f' = 0
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {s : Set E} [CompleteSpace F] (h : AnalyticOn 𝕜 f s) {n : WithTop ℕ} : ContDiffOn 𝕜 n f s
{C : Type v} [CategoryTheory.SmallCategory C] {D : Type v} [CategoryTheory.SmallCategory D] {L : C ⥤ D} {R : D ⥤ C} (Adj : L ⊣ R) : L.initial
{M₀ : Type u_6} [MonoidWithZero M₀] [Nontrivial M₀] [NoZeroDivisors M₀] {L : List M₀} : L.prod = 0 ↔ 0 ∈ L
{G : Type u_1} [AddGroup G] (tG : Add_monoid.is_torsion G) (H : AddSubgroup G) : Add_monoid.is_torsion ↥H
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {x y : 𝕜} (h : x < y) {z : 𝕜} : z ∈ Set.Ioo x y ↔ ∃ (a b : 𝕜), 0 < a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z
{K : Type u_1} {g : GeneralizedContinuedFraction K} {n m : ℕ} (n_LE_m : n ≤ m) (TerminatedAt_n : g.terminated_at n) : g.terminated_at m
{M : Type u_1} [Monoid M] {s : Set M} {a : M} (hs : IsSubmonoid s) (h : a ∈ s) {n : ℕ} : a ^ n ∈ s
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} {s : Set E} {x : E} {f' : TangentSpace (model_with_corners_self 𝕜 E) x →L[𝕜] TangentSpace (model_with_corners_self 𝕜 E') (f x)} : HasFderivWithinAt f f' s x → HasMfderivWithinAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f s x f'
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : Set P} {s1 : AffineSubspace k P} (h : s ⊆ ↑s1) : SpanPoints k s ⊆ ↑s1
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] [Fintype α] [Fintype β] (f : α → β) {w : α → M} {b : M} [LinearOrderedCancelAddCommMonoid M] (hb : Fintype.card β • b < finset.univ.sum (λ (x : α), w x)) : ∃ (y : β), b < (Finset.filter (λ (x : α), f x = y) Finset.univ).sum (λ (x : α), w x)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [CompactSpace α] [MetricSpace β] {f g : C(α, β)} {C : ℝ} (C0 : 0 ≤ C) : HasDist.dist f g ≤ C ↔ ∀ (x : α), HasDist.dist (⇑f x) (⇑g x) ≤ C
{R : Type u_1} [CommRing R] (u v w : Fin 3 → R) : ⇑(⇑CrossProduct u) (⇑(⇑CrossProduct v) w) = ⇑(⇑CrossProduct (⇑(⇑CrossProduct u) v)) w + ⇑(⇑CrossProduct v) (⇑(⇑CrossProduct u) w)
{α : Type u} [PseudoMetricSpace α] (p : α → Prop) (x : α) (H : ∃ᶠ (R : ℝ) in filter.at_Top, ∀ (y : α), y ∈ Metric.Ball x R → p y) (y : α) : p y
{α : Type u_1} [HasLe α] {s : Set αᵒᵈ} : IsUpperSet s → IsLowerSet (⇑order_dual.to_dual ⁻¹' s)
{R : Type u} {A : Type w} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) (r : R) (y : A) : x * (⇑(Algebra_Map R A) r * y) = ⇑(Algebra_Map R A) r * (x * y)
{R : Type u_5} [CommRing R] [is_IsDomain R] {k l : ℕ} (h : k ≠ l) : Disjoint (primitive_roots k R) (primitive_roots l R)
{R : Type u_1} [RightCancelSemigroup R] (g : R) : IsRightRegular g
{α : Type u} [PseudoMetricSpace α] {s : Set α} (hs : is_IsCompact s) {e : ℝ} (hE : 0 < e) : ∃ (t : Set α) (H : t ⊆ s), t.finite ∧ s ⊆ ⋃ (x : α) (H : x ∈ t), Metric.Ball x e
{ι : Type u_1} {α : ι → Type u_2} [DecidableEq ι] [Π (i : ι), LinearOrder (α i)] (x y x' y' : Π (i : ι), α i) : Set.Icc x y  set.univ.pi (λ (i : ι), Set.Ioo (x' i) (y' i)) ⊆ (⋃ (i : ι), Set.Icc x (Function.update y i (x' i))) ∪ ⋃ (i : ι), Set.Icc (Function.update x i (y' i)) y
{α : Type u} [UniformSpace α] {f : Filter α} {x : α} (hF : Cauchy f) (adhs : ClusterPt x f) : f ≤ nhds x
{α : Type u_1} [DecidableEq α] [Fintype α] : Function.Injective equiv.perm.cycle_Factors_Finset
{α : Type u_1} [Monoid α] {a : α} {u : αˣ} : ↑u ∣ a
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] [Fintype α] [Fintype β] (f : α → β) {b : M} [LinearOrderedCommRing M] [Nonempty β] (hb : ↑(Fintype.card α) ≤ Fintype.card β • b) : ∃ (y : β), ↑((Finset.filter (λ (x : α), f x = y) Finset.univ).card) ≤ b
{α : Type u_2} [DecidableEq α] {s : Finset α} {B : Finset (Finset α)} {n : ℕ} (h : ∀ (a : α), a ∈ s → (Finset.filter (HasMem.Mem a) B).card = n) : B.sum (λ (t : Finset α), (s ∩ t).card) = s.card * n
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {w : α → M} {b : M} [LinearOrderedCancelAddCommMonoid M] (hF : ∀ (y : β), y ∉ t → (Finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x) ≤ 0) (ht : t.nonempty) (hb : t.card • b ≤ s.sum (λ (x : α), w x)) : ∃ (y : β) (H : y ∈ t), b ≤ (Finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace ↥K] (p : E) : ⇑(reflection K) (⇑(reflection K) p) = p
{p : ℕ} : Summable (λ (n : ℕ), 1 / ↑n ^ p) ↔ 1 < p
{α : Type u} [TopologicalSpace α] {s : Set α} (h : ∀ {ι : Type u} (Z : ι → Set α), (∀ (i : ι), is_IsClosed (Z i)) → (s ∩ ⋂ (i : ι), Z i) = ∅ → (∃ (t : Finset ι), (s ∩ ⋂ (i : ι) (H : i ∈ t), Z i) = ∅)) : is_IsCompact s
{G : Type w} [TopologicalSpace G] [Group G] [TopologicalGroup G] {K U : Set G} (hK : is_IsCompact K) (hU : is_IsOpen U) (hKU : K ⊆ U) : ∃ (V : Set G) (H : V ∈ nhds 1), V * K ⊆ U
{α : Type u_1} [Preorder α] [Nonempty α] [NoMinOrder α] : Infinite α
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace 𝕜] [FiniteDimensional 𝕜 E] {n : ℕ} {f : E → F} : ContDiff 𝕜 ↑(n + 1) f ↔ Differentiable 𝕜 f ∧ ∀ (y : E), ContDiff 𝕜 ↑n (λ (x : E), ⇑(fderiv 𝕜 f x) y)
{m : Type u} {n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] [Fintype m] [DecidableEq m] (A : Matrix m m α) (B : Matrix m n α) (C : Matrix n m α) (D : Matrix n n α) [Invertible D] : (matrix.from_blocks A B C D).det = D.det * (A - (B.mul (⅟ D)).mul C).det
{R : Type u} {M : Type v} [CommRing R] [Nontrivial R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] (f : M →ₗ[R] M) (p : Polynomial R) : ⇑(Polynomial.aeval f) p = ⇑(Polynomial.aeval f) (p %ₘ f.charpoly)
{X : Top} (F : Top.Presheaf (Type v) X) {ι : Type v} (U : ι → TopologicalSpace.Opens ↥X) (sf : Top.presheaf.sheaf_condition_Equalizer_products.pi_Opens F U) (s : F.obj (Opposite.op (supr U))) : F.is_gluing U ((F.pi_Opens_iso_sections_family U).hom sf) s ↔ Top.Presheaf.SheafConditionEqualizerProducts.res F U s = sf
{D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ} (hF : ContinuousOn f D) (hF' : DifferentiableOn ℝ f (Interior D)) (hF'_Mono : MonotoneOn (deriv f) (Interior D)) : ConvexOn ℝ D f
{f : ℕ → ℝ} (hfa : Antitone f) (hF0 : Filter.Tendsto f filter.at_Top (nhds 0)) : CauchySeq (λ (n : ℕ), (Finset.range (n + 1)).sum (λ (i : ℕ), (-1) ^ i * f i))
{α : Type u} [NonUnitalCommRing α] {b c x : α} (h : x * x - b * x + c = 0) : ∃ (y : α), y * y - b * y + c = 0 ∧ x + y = b ∧ x * y = c
{β : Type u_2} [OrderedAddCommGroup β] [Module ℝ β] [OrderedSmul ℝ β] {f : ℝ → β} {a b : ℝ} (a_Lt_b : a < b) (h_is_IsLocalMin : is_IsLocalMinOn f (Set.Icc a b) a) (h_conv : ConvexOn ℝ (Set.Icc a b) f) : IsMinOn f (Set.Icc a b) a
{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), Monoid (M i)] {N : Type u_3} [Monoid N] (f g : FreeProduct M →* N) (h : ∀ (i : ι), f.comp FreeProduct.of = g.comp FreeProduct.of) : f = g
{M : Type u_1} [HasMul M] {c d : Con M} : (∀ (x y : M), ⇑c x y ↔ ⇑d x y) ↔ c = d
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} (l : ι →₀ 𝕜) (v : ι → E) (x : E) : HasInner.inner x (l.sum (λ (i : ι) (a : 𝕜), a • v i)) = l.sum (λ (i : ι) (a : 𝕜), a • HasInner.inner x (v i))
{M : Type u_1} [SemiNormedGroup M] (S : AddSubgroup M) (m : M) : 0 ≤ ∥⇑(QuotientAddGroup.mk' S) m∥
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + 2 * ⇑is_R_or_C.re (HasInner.inner x y) + ∥y∥ * ∥y∥
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (f : LocalHomeomorph E F) {f' : E ≃L[𝕜] F} {a : F} (ha : a ∈ f.to_local_equiv.target) (htff' : HasFderivAt ⇑f ↑f' (⇑(f.symm) a)) : HasFderivAt ⇑(f.symm) ↑(f'.symm) a
{α : Type u_1} (r : Setoid α) : setoid.mk_Classes r.classes setoid.classes_eqv_Classes = r
{α : Type u_1} {β : Type u_3} [MeasurableSpace α] [MeasurableSpace β] {C : Set (Set α)} {D : Set (Set β)} (hC : Measurable_space.generate_from C = _inst_1) (hD : Measurable_space.generate_from D = _inst_3) (h2C : IsCountablySpanning C) (h2D : IsCountablySpanning D) : Measurable_space.generate_from (Set.image2 HasSetProd.prod C D) = prod.measurable_Space
(a : ℝ) : Cardinal.mk ↥(Set.Ici a) = Cardinal.continuum
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y : M} (h : SameRay R x y) : SameRay R y x
{p : Polynomial ℚ} (p_irr : Irreducible p) (p_deg : Nat.Prime p.nat_degree) (p_roots : Fintype.card ↥(p.root_Set ℂ) = Fintype.card ↥(p.root_Set ℝ) + 2) : Function.bijective ⇑(polynomial.gal.gal_action_hom p ℂ)
{M : Type u_6} {N : Type u_7} [has_Add M] [has_Add N] (e : M ≃+ N) (x : M) : ⇑(e.symm) (⇑e x) = x
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] [NormedGroup G] [NormedSpace 𝕜 G] {n : ℕ} (p : FormalMultilinearSeries 𝕜 E F) (c : Composition n) (f : ContinuousMultilinearMap 𝕜 (λ (i : Fin c.length), F) G) (v : Fin n → E) : ∥⇑(Continuous_multilinear_map.comp_along_Composition p c f) v∥ ≤ ∥f∥ * finset.univ.prod (λ (i : Fin c.length), ∥p (c.blocks_fun i)∥) * finset.univ.prod (λ (i : Fin n), ∥v i∥)
{α : Type u_1} [LinearOrderedField α] {a b : α} (ha : 0 < a) (hb : 0 < b) : 1 / a < 1 / b ↔ b < a
{𝕜 : Type u_1} {E : Type u_2} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] {s : Set E} : Convex 𝕜 s ↔ ∀ ⦃x y : E⦄, x ∈ s → y ∈ s → ∀ ⦃a b : 𝕜⦄, 0 ≤ a → 0 ≤ b → 0 < a + b → (a / (a + b)) • x + (b / (a + b)) • y ∈ s
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x : E} : ∥⇑innerSL x∥ = ∥x∥
{α : Type u_2} [Preorder α] [NoMaxOrder α] : filter.at_Top ≤ Filter.cofinite
{p : ℕ} [hp_Prime : Fact (Nat.Prime p)] {R : Type u_1} [NonAssocSemiring R] {f : Π (k : ℕ), R →+* Zmod(p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), (zmod.cast_hom _ (Zmod(p ^ k1))).comp (f k2) = f k1) (n : ℕ) : (padic_int.to_Zmod_Pow n).comp (PadicInt.lift f_compat) = f n
{β : Type u} {α : Type v} [CommMonoid β] {p : α → Prop} {s : Finset {x // p x}} {f : {x // p x} → β} {g : α → β} (h : ∀ (x : {x // p x}), x ∈ s → g ↑x = f x) : (Finset.map (Function.Embedding.subtype (λ (x : α), p x)) s).prod (λ (x : α), g x) = s.prod (λ (x : {x // p x}), f x)
{α : Type u_2} {ι : Type u_5} [AddCommMonoid α] [Fintype ι] (f : ι → Set α) (a : α) : a ∈ finset.univ.sum (λ (i : ι), f i) ↔ ∃ (g : ι → α) (hg : ∀ (i : ι), g i ∈ f i), finset.univ.sum (λ (i : ι), g i) = a
{R : Type u_1} [Semiring R] (r : R) (f : Polynomial R) (n : ℕ) : (⇑(Polynomial.taylor r) f).coeff n = Polynomial.eval r (⇑(polynomial.hasse_deriv n) f)
{p : ℕ → Prop} : (∃ (x : ℕ), p x) → WellFounded (Nat.Upto.Gt p)
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E] [NormedGroup F] [NormedSpace ℝ F] [TopologicalSpace.SecondCountableTopology F] (f : E → F) (s : Set E) (f' : E → (E →L[ℝ] F)) (hF' : ∀ (x : E), x ∈ s → HasFderivWithinAt f (f' x) s x) (r : (E →L[ℝ] F) → Nnreal) (rpos : ∀ (A : E →L[ℝ] F), r A ≠ 0) : ∃ (t : ℕ → Set E) (A : ℕ → (E →L[ℝ] F)), (∀ (n : ℕ), is_IsClosed (t n)) ∧ (s ⊆ ⋃ (n : ℕ), t n) ∧ (∀ (n : ℕ), ApproximatesLinearOn f (A n) (s ∩ t n) (r (A n))) ∧ (s.nonempty → ∀ (n : ℕ), ∃ (y : E) (H : y ∈ s), A n = f' y)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {G : C ⥤ D} (hG : CategoryTheory.CompatiblePreserving K G) (ℱ : CategoryTheory.SheafOfTypes K) {Z : C} {T : CategoryTheory.Presieve Z} {x : CategoryTheory.Presieve.FamilyOfElements (G.op ⋙ ℱ.val) T} (h : x.compatible) : (Category_theory.presieve.family_of_elements.functor_pushforward G x).compatible
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} {C : ℝ} (hF : ContinuousOn f (Set.Icc a b)) (hF' : ∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt f (f' x) (Set.Ici x) x) (bound : ∀ (x : ℝ), x ∈ Set.Ico a b → ∥f' x∥ ≤ C) (x : ℝ) (H : x ∈ Set.Icc a b) : ∥f x - f a∥ ≤ C * (x - a)
{α : Type u} [Preorder α] [OrderTop α] {a b : α} (h : a < b) : a ≠ ⊤
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {c : Con M} {f : M →* P} (h : c ≤ Con.ker f) (hF : Function.Surjective ⇑f) : Function.Surjective ⇑(c.lift f h)
{α : Type u_1} {f g : α → ℝ} {t₀ : Filter α} (hF : ∀ᶠ (t : α) in t₀, 0 ≤ f t) (hft : ∀ᶠ (t : α) in t₀, f t ≤ g t) (g0 : Filter.Tendsto g t₀ (nhds 0)) : Filter.Tendsto f t₀ (nhds 0)
{ι : Type u} {f g : ι → Nnreal} {p q : ℝ} (hpq : p.is_conjugate_exponent q) (hF : Summable (λ (i : ι), f i ^ p)) (hg : Summable (λ (i : ι), g i ^ q)) : Summable (λ (i : ι), f i * g i) ∧ ∑' (i : ι), f i * g i ≤ (∑' (i : ι), f i ^ p) ^ (1 / p) * (∑' (i : ι), g i ^ q) ^ (1 / q)
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {ι : Type w} [Fintype ι] (h : Basis ι K V) : FiniteDimensional K V
{α : Type u_1} {s : Set α} : s.pairwise ⊥ → s.subsingleton
{R : Type u_1} [NormedRing R] (k : ℕ) {r₁ : R} {r₂ : ℝ} (h : ∥r₁∥ < r₂) : (λ (n : ℕ), ↑n ^ k * r₁ ^ n) =o[filter.at_Top] λ (n : ℕ), r₂ ^ n
{α : Type u} {l₁ l₂ : List α} {n : ℕ} : List.drop n (l₁ ++ l₂) = List.drop n l₁ ++ List.drop (n - l₁.length) l₂
{ι : Type u_1} {R : Type u_3} {M : Type u_5} {v : ι → M} [Semiring R] [AddCommMonoid M] [Module R M] [Fintype ι] : LinearIndependent R v ↔ (⇑(LinearMap.lsum R (λ (i : ι), R) ℕ) (λ (i : ι), Linear_map.id.smul_Right (v i))).ker = ⊥
{C : Type u} [CategoryTheory.Category C] {X : C} {S R : CategoryTheory.Sieve X} (J : CategoryTheory.GrothendieckTopology C) (rj : R ∈ ⇑J X) (sj : S ∈ ⇑J X) : R ⊓ S ∈ ⇑J X
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasInitial C] [CategoryTheory.Limits.HasTerminal C] (h : CategoryTheory.Mono (CategoryTheory.Limits.initial.to (⊤_ C))) : CategoryTheory.Limits.InitialMonoClass C
{p : ℕ} [Fact (Nat.Prime p)] : WittVector.IsPoly₂ p (λ (_x : Type u_1) (_x_1 : CommRing _x), has_add.add)
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} {a : α} {s : Set α} (h : a ∉ s → f a = 1) : finprod (λ (i : α), finprod (λ (H : i ∈ HasInsert.insert a s), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i))
{α : Type u} {β : Type v} [Preorder β] {f : α → β} {l : Filter α} {a : α} : IsExtrFilter f l a → IsExtrFilter (⇑order_dual.to_dual ∘ f) l a
{R : Type u_1} [Semiring R] {x y : R} (h : Commute x y) (n : ℕ) : (x + y) ^ n = (Finset.range (n + 1)).sum (λ (m : ℕ), x ^ m * y ^ (n - m) * ↑(n.choose m))
{α : Type u_1} [PartialOrder α] [PredOrder α] [IsPredArchimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ Set.Ioc m n → r i (Order.pred i)) (hnm : m < n) : Relation.TransGen r n m
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] (f : S.localization_Map N) (x : M) (y : ↥S) : ∃ (c : ↥S), x * ↑((f.sec (f.mk' x y)).snd) * ↑c = (f.sec (f.mk' x y)).fst * ↑y * ↑c
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {v : Set E} (hv : Orthonormal 𝕜 Coe) : (∀ (u : Set E), u ⊇ v → Orthonormal 𝕜 Coe → u = v) ↔ (Submodule.span 𝕜 v)ᗮ = ⊥
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [NondiscreteNormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (f : MultilinearMap 𝕜 E G) (hF : Continuous ⇑f) : ∃ (C : ℝ), 0 < C ∧ ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F ≠ 2) : ∃ (a : F), char.quadratic_Char F a = -1
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) : ⇑is_R_or_C.re (HasInner.inner x y) = (∥x + y∥ * ∥x + y∥ - ∥x∥ * ∥x∥ - ∥y∥ * ∥y∥) / 2
{G : Type u_1} [AddGroup G] (H : AddSubgroup G) : 0 ∈ H
{α : Type u_1} (A : Finset α) (i : ℕ) (h₁ : i ≤ A.card) : ∃ (B : Finset α), B ⊆ A ∧ B.card = i
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (F : C ⥤ D) [CategoryTheory.Abelian C] [CategoryTheory.Abelian D] [F.additive] [CategoryTheory.EnoughProjectives C] {X Y : C} (f : X ⟶ Y) (P : CategoryTheory.ProjectiveResolution X) (Q : CategoryTheory.ProjectiveResolution Y) : (F.left_derived 0).map f ≫ Category_theory.abelian.functor.left_derived_Zero_to_self_App F Q = Category_theory.abelian.functor.left_derived_Zero_to_self_App F P ≫ F.map f
{α : Type u} {β : Type v} {γ : Type w} [TopologicalSpace α] [PseudoMetricSpace β] [PseudoMetricSpace γ] {G : β → γ} {C : Nnreal} (H : LipschitzWith C G) : Continuous (BoundedContinuousFunction.comp G H)
{M : Type u_1} {N : Type u_2} [Preorder M] [has_Add M] [HasSub M] [HasOrderedSub M] [PartialOrder N] [has_Add N] [HasSub N] [HasOrderedSub N] (e : M ≃o N) (h_Add : ∀ (a b : M), ⇑e (a + b) = ⇑e a + ⇑e b) (a b : M) : ⇑e (a - b) = ⇑e a - ⇑e b
{X : Top} (U : TopologicalSpace.Opens ↥X) (R : CategoryTheory.Presieve U) (hR : CategoryTheory.Sieve.generate R ∈ ⇑(opens.grothendieck_topology ↥X) U) : supr (Top.presheaf.covering_of_Presieve U R) = U
{α β : Type u} (e : α ≃ β) : Cardinal.mk α = Cardinal.mk β
(u : ℕ → ℝ) (l : ℝ) (hmono : Monotone u) (hlim : ∀ (a : ℝ), 1 < a → (∃ (c : ℕ → ℕ), (∀ᶠ (n : ℕ) in filter.at_Top, ↑(c (n + 1)) ≤ a * ↑(c n)) ∧ Filter.Tendsto c filter.at_Top filter.at_Top ∧ Filter.Tendsto (λ (n : ℕ), u (c n) / ↑(c n)) filter.at_Top (nhds l))) : Filter.Tendsto (λ (n : ℕ), u n / ↑n) filter.at_Top (nhds l)
{𝕜 : Type u_1} {E : Type u_3} [OrderedSemiring 𝕜] [TopologicalSpace E] [AddCancelCommMonoid E] [HasContinuousAdd E] [Module 𝕜 E] {s : Set E} (hs : StrictConvex 𝕜 s) (z : E) : StrictConvex 𝕜 ((λ (x : E), x + z) ⁻¹' s)
{α : Type u} [TopologicalSpace α] : DenseRange stone_cech_Unit
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : Set P} {p1 p2 : P} (hp1 : p1 ∈ s) (hp2 : p2 ∈ s) : p1 -ᵥ p2 ∈ Vector_Span k s
{x y : Pgame} (h : x.fuzzy y) : x.lf y
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] (p : P) : ↑(⇑(euclidean_geometry.orthogonal_projection s) p) ∈ s
{G : Type u_1} [Group G] [IsFreeGroup G] {H : Type u_2} [Group H] (f : IsFreeGroup.Generators G → H) : ∃! (F : G →* H), ∀ (a : IsFreeGroup.Generators G), ⇑F (IsFreeGroup.of a) = f a
{α : Type u_1} {ι : Type u_3} {ι' : Type u_4} [DistribLattice α] [OrderBot α] [DecidableEq ι] {s : Finset ι'} {g : ι' → Finset ι} {f : ι → α} (hs : s.sup_indep (λ (i : ι'), (g i).sup f)) (hg : ∀ (i' : ι'), i' ∈ s → (g i').sup_indep f) : (s.bUnion g).sup_indep f
{α : Type u_1} [CanonicallyOrderedAddMonoid α] [HasSub α] [HasOrderedSub α] {a b c : α} [ContravariantClass α α has_add.add has_le.le] [ContravariantClass α α has_add.add has_lt.lt] (h₁ : b ≤ a) (h₂ : c ≤ a) : a - b < a - c ↔ c < b
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {T : E →L[𝕜] E} (hT : InnerProductSpace.IsSelfAdjoint ↑T) (x : E) : ↑(T.re_apply_inner_self x) = HasInner.inner (⇑T x) x
{α : Type u_1} {β : Type u_2} {e e' : LocalEquiv α β} (h : e ≈ e') : e.target = e'.target
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M →* P} (hg : ∀ (y : ↥S), IsUnit (⇑g ↑y)) (z : N) (v : P) : ⇑(f.lift hg) z = v ↔ ⇑g (f.sec z).fst = ⇑g ↑((f.sec z).snd) * v
(ι : Type u_1) [Fintype ι] : Metric.Bounded (StdSimplex ℝ ι)
{α : Type u_1} {M : Type u_5} [CommMonoid M] {f : α → M} {s t : Set α} (hs : s.finite) (ht : t.finite) : finprod (λ (i : α), finprod (λ (H : i ∈ s ∪ t), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ s ∩ t), f i)) = finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))
(F : Type u_1) [Field F] {E : Type u_2} [Field E] [Algebra F E] (S : Set E) {K : Subfield E} (hF : Set.Range ⇑(Algebra_Map F E) ⊆ ↑K) (HS : S ⊆ ↑K) : (IntermediateField.adjoin F S).to_Subfield ≤ K
{α : Type u_1} [CommSemiring α] (E : LinearRecurrence α) (u : ℕ → α) : E.is_solution u ↔ u ∈ E.sol_Space
(R : Type u) [CommRing R] [is_IsDomain R] (n : ℕ) : is_IsDomain (MvPolynomial (Fin n) R)
{α : Type u_1} [UniformSpace α] {s : Set (α × α)} (hs : s ∈ Uniformity α) : ∃ (t : Set (α × α)) (H : t ∈ Uniformity α), SymmetricRel t ∧ CompRel t t ⊆ s
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p : ι → P) : ⇑(s.affine_combination p) w = ⇑(s.weighted_vsub_of_point p (Classical.choice AddTorsor.nonempty)) w +ᵥ Classical.choice AddTorsor.nonempty
{n m : ℕ} (h : n = m) : (fin.cast h).to_Equiv = equiv.cast _
{α : Type u} [PseudoMetricSpace α] {s : Set α} {C : ℝ} (h : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → HasDist.dist x y ≤ C) : Emetric.diam s ≤ ennreal.of_Real C
{J : Type u₁} [CategoryTheory.Category J] [CategoryTheory.IsConnected J] (j₁ j₂ : J) : CategoryTheory.Zigzag j₁ j₂
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) : Real.cos (InnerProductGeometry.angle x y) = HasInner.inner x y / (∥x∥ * ∥y∥)
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {E : Type u_3} [HasNorm E] {F : Type u_4} [HasNorm F] (e : α ≃ₜ β) {b : β} {f : β → E} {g : β → F} : f =o[nhds b] g ↔ (f ∘ ⇑e) =o[nhds (⇑(e.symm) b)] (g ∘ ⇑e)
{α : Type u} [PseudoMetricSpace α] {s : Set α} (h : TotallyBounded s) : Metric.Bounded s
{α : Type u_1} {β : Type u_2} {mβ : MeasurableSpace β} {m : MeasurableSpace α} {f : ℕ → α → β} {p : ℕ → α → Prop} [Π (n : ℕ), DecidablePred (p n)] (hF : ∀ (n : ℕ), Measurable (f n)) (hp : ∀ (n : ℕ), MeasurableSet {x : α | p n x}) (h : ∀ (x : α), ∃ (n : ℕ), p n x) : Measurable (λ (x : α), f (Nat.find _) x)
{E : Type u_1} {β : Type u_2} [AddCommGroup E] [TopologicalSpace E] [Module ℝ E] [TopologicalAddGroup E] [HasContinuousSmul ℝ E] [OrderedAddCommGroup β] [Module ℝ β] [OrderedSmul ℝ β] {f : E → β} {a : E} (h_is_IsLocalMin : is_is_IsLocalMin f a) (h_conv : ConvexOn ℝ Set.Univ f) (x : E) : f a ≤ f x
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {F G : C ⥤ D} (α : F ⟶ G) [∀ (X : C), CategoryTheory.IsIso (α.app X)] : CategoryTheory.IsIso α
{α : Type u} [Group α] [HasLe α] [CovariantClass α α (Function.swap has_mul.mul) has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x : V) : 2 • hb.oangle x (-x) = 0
{α : Type u_1} [LinearOrderedRing α] : Subsingleton (FloorRing α)
(N : ℕ) {j : ℝ} (hj : 0 < j) {c : ℝ} (hc : 1 < c) : (Finset.filter (λ (i : ℕ), j < c ^ i) (Finset.range N)).sum (λ (i : ℕ), 1 / (c ^ i) ^ 2) ≤ c ^ 3 * (c - 1)⁻¹ / j ^ 2
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) (l₁ l₂ : ι →₀ 𝕜) : HasInner.inner (⇑(Finsupp.total ι E 𝕜 v) l₁) (⇑(Finsupp.total ι E 𝕜 v) l₂) = l₂.sum (λ (i : ι) (y : 𝕜), ⇑(StarRing_end 𝕜) (⇑l₁ i) * y)
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteCoproducts C] [CategoryTheory.Limits.HasCokernels C] [CategoryTheory.NormalEpiCategory C] {X Y Z : C} (a : X ⟶ Y) (b : X ⟶ Z) [CategoryTheory.Epi a] [CategoryTheory.Epi b] : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span a b)
{n m : ℕ} (h : ∀ (i : ℕ), n.test_bit i = m.test_bit i) : n = m
{α : Type u} {β : Type v} [UniformSpace α] [SemilatticeSup β] {u : β → α} (hu : CauchySeq u) {ι : Type u_1} {f : ι → β} {p : Filter ι} [p.ne_IsBot] (hF : Filter.Tendsto f p filter.at_Top) {a : α} (ha : Filter.Tendsto (u ∘ f) p (nhds a)) : Filter.Tendsto u filter.at_Top (nhds a)
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) (h : IsUnit A.det) : A.mul A⁻¹ = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasInitial C] (h : ∀ (A : C) (f : A ⟶ ⊥_ C), CategoryTheory.IsIso f) : CategoryTheory.Limits.HasStrictInitialObjects C
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p ∈ s) (v : V) : v ∈ s.direction ↔ ∃ (p2 : P) (H : p2 ∈ s), v = p2 -ᵥ p
{f : ℕ → ℝ} (hF : ∀ (i : ℕ), 0 ≤ f i) (r : ℝ) : HasSum f r ↔ Filter.Tendsto (λ (n : ℕ), (Finset.range n).sum (λ (i : ℕ), f i)) filter.at_Top (nhds r)
{α : Type u} {β : Type v} [LinearOrderedField α] [TopologicalSpace α] [OrderTopology α] {l : Filter β} {f g : β → α} {C : α} (hC : C < 0) (hF : Filter.Tendsto f l filter.at_IsBot) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (λ (x : β), f x * g x) l filter.at_Top
{ι : Type u_1} {α : Type u_2} [CompleteLattice α] {t : ι → α} (ht : CompleteLattice.Independent t) {x : ι} {y : Set ι} (hx : x ∉ y) : Disjoint (t x) (⨆ (i : ι) (H : i ∈ y), t i)
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] (S : Finset M) : CompleteLattice.IsCompactElement (Submodule.span R ↑S)
{α : Type u} {a b : α} [MulOneClass α] [HasZero α] [Preorder α] [ZeroLt.PosMulStrictMono α] (ha : a < 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1
{α : Type u_1} [LinearOrder α] (a : α) (i : Fin 1) : ⇑({a}.order_emb_of_Fin _) i = a
{α : Type u} [Preorder α] {s : Set α} {a : α} (h : IsGlb s a) : BddBelow s
{α : Type u_1} {r : α → α → Prop} {f : Filter α} : Filter.IsBounded r f ↔ ∃ (s : Set α) (H : s ∈ f.sets) (b : α), s ⊆ {x : α | r x b}
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] [Nontrivial E] {f g : E → F} {U : Set E} (hU : Metric.Bounded U) (hF : DiffContOnCl ℂ f U) (hg : DiffContOnCl ℂ g U) (hfg : Set.EqOn f g (Frontier U)) : Set.EqOn f g U
{α : Type u_1} {E : Type u_3} [NormedGroup E] [TopologicalSpace α] {f : α → E} : HasCompactSupport f → HasCompactSupport (λ (x : α), ∥f x∥)
(p : ℕ) : padic_norm p 1 = 1
{G : Type u_1} [SubNegMonoid G] (a b : G) : a - b = a + -b
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] (Q : QuadraticForm R M) (p : Submodule R (CliffordAlgebra Q)) (n : ℕ) : Submodule.map CliffordAlgebra.reverse (p ^ n) = Submodule.map CliffordAlgebra.reverse p ^ n
{α : sort u_1} {β : sort u_2} {p : α → β → Prop} {x₀ x₁ : Σ' (a : α), Subtype_ (p a)} : x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasPullbacks C] {B : C} : CategoryTheory.Limits.HasBinaryProducts (CategoryTheory.Over B)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E] (s : Finset E) (hs : ∀ (c : E), c ∈ s → ∥c∥ ≤ 2) (h : ∀ (c : E), c ∈ s → ∀ (d : E), d ∈ s → c ≠ d → 1 ≤ ∥c - d∥) : s.card ≤ 5 ^ FiniteDimensional.finrank ℝ E
{a b c : ℤ} : fermat_42.minimal a b c → fermat_42.minimal a b (-c)
{R : Type u_1} [CommRing R] (S : Submonoid R) {P : Type u_2} [CommRing P] [Algebra R P] [loc : IsLocalization S P] (x : P) (hx : IsIntegral R x) : IsFractional S (Algebra.adjoin R {x}).to_Submodule
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} {V3 : Type u_6} {P3 : Type u_7} [Ring k] [AddCommGroup V1] [Module k V1] [AddTorsor V1 P1] [AddCommGroup V2] [Module k V2] [AddTorsor V2 P2] [AddCommGroup V3] [Module k V3] [AddTorsor V3 P3] (f : P2 →ᵃ[k] P3) (g : P1 →ᵃ[k] P2) (p : P1) : ⇑(f.comp g) p = ⇑f (⇑g p)
{α : Type u_1} [LinearOrder α] {r : α} {s : Finset α} : {r}.to_colex ≤ s.to_colex ↔ ∃ (x : α) (H : x ∈ s), r ≤ x
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) {r : Nnreal} (h : ↑r < p.radius) : (λ (n : ℕ), ∥p n∥ * ↑r ^ n) =o[filter.at_Top] λ (_x : ℕ), 1
{k : Type u_1} {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : Set P} (h : AffineIndependent k (λ (p : ↥s), ↑p)) : ∃ (t : Set P), s ⊆ t ∧ AffineIndependent k (λ (p : ↥t), ↑p) ∧ affine_Span k t = ⊤
{α : Type u_1} [CompleteLattice α] {s : Set α} (hs : CompleteLattice.SetIndependent s) {x : α} {y : Set α} (hx : x ∈ s) (hy : y ⊆ s) (hxy : x ∉ y) : Disjoint x (HasSup.sup y)
{α : Type u} [Group α] (g : GroupTopology α) : Continuous has_inv.inv
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [AddCommMonoid F] [OrderedAddCommMonoid β] [Module 𝕜 E] [Module 𝕜 F] [HasScalar 𝕜 β] {f : F → β} {s : Set F} (hF : ConcaveOn 𝕜 s f) (g : E →ₗ[𝕜] F) : ConcaveOn 𝕜 (⇑g ⁻¹' s) (f ∘ ⇑g)
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b
(R : Type u_1) {p n : ℕ} [hp : Fact (Nat.Prime p)] [Ring R] [Char_p R p] (hn : p ∣ n) : Polynomial.cyclotomic (n * p) R = Polynomial.cyclotomic n R ^ p
{R : Type u_1} [CommRing R] {Rₘ : Type u_3} {Sₘ : Type u_4} [CommRing Rₘ] [CommRing Sₘ] (P : Ideal (Polynomial R)) (pX : Polynomial R) (hpX : pX ∈ P) [Algebra (R ⧸ Ideal.comap Polynomial.c P) Rₘ] [IsLocalization.Away (Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.c P)) pX).leading_Coeff Rₘ] [Algebra (Polynomial R ⧸ P) Sₘ] [IsLocalization (Submonoid.map ↑(P.quotient_Map Polynomial.c LE_rfl) (Submonoid.powers (Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.c P)) pX).leading_Coeff)) Sₘ] : (IsLocalization.map Sₘ (P.quotient_Map Polynomial.c LE_rfl) _).is_integral
{C : Type u} [CategoryTheory.Category C] {X Y Z : C} {f g : X ⟶ Y} (w : f = g) (h : Y ⟶ Z) : f ≫ h = g ≫ h
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {F : Type v} [NormedGroup F] [NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} [PartialOrder 𝕜] : HasDerivWithinAt f f' (Set.Ioi x) x → HasDerivWithinAt f f' (Set.Ici x) x
{α : Type u_1} {E : α → Type u_2} {p : Ennreal} [Π (i : α), NormedGroup (E i)] [Fact (1 ≤ p)] {F : ℕ → ↥(Lp E p)} (hF : CauchySeq F) {f : ↥(Lp E p)} (hF : Filter.Tendsto (Id (λ (i : ℕ), ⇑(F i))) filter.at_Top (nhds ⇑f)) : Filter.Tendsto F filter.at_Top (nhds f)
{E : Type u_3} [SemiNormedGroup E] (u v : E) : ∥v∥ ≤ ∥u∥ + ∥u - v∥
{D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ} (hF : ContinuousOn f D) (hF' : DifferentiableOn ℝ f (Interior D)) (hF'' : DifferentiableOn ℝ (deriv f) (Interior D)) (hF''_nonpos : ∀ (x : ℝ), x ∈ Interior D → deriv^[2] f x ≤ 0) : ConcaveOn ℝ D f
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {c : Con M} {f : M →* P} (H : c ≤ Con.ker f) (x : M) : ⇑(c.lift f H) (⇑(c.mk') x) = ⇑f x
{α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ) (s : Set α) (t : Set β) : Set.image2 f s t = ⋃ (i : α) (H : i ∈ s) (j : β) (H : j ∈ t), {f i j}
{α : Type u_1} [LinearOrder α] (s : Set α) (h : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → ∀ (z : α), z ∈ s → x ≤ y → y ≤ z → x = y ∨ y = z) : s.finite
{p : ℕ} [Fact (Nat.Prime p)] {f : PadicSeq p} (hF : ¬f ≈ 0) (v1 v3 : ℕ) : padic_norm p (⇑f (padic_seq.stationary_point hF)) = padic_norm p (⇑f (Linear_order.max v1 (Linear_order.max (padic_seq.stationary_point hF) v3)))
{f f' : ℝ → ℝ} {s : Set ℝ} (hs : Convex ℝ s) (hF : ∀ (x : ℝ), x ∈ s → HasDerivAt f (f' x) x) {m : ℝ} (hF' : ∀ (x : ℝ), x ∈ s → f' x ≠ m) : (∀ (x : ℝ), x ∈ s → f' x < m) ∨ ∀ (x : ℝ), x ∈ s → m < f' x
{G : Type u_1} [Group G] (tG : monoid.is_torsion_free G) (H : Subgroup G) : monoid.is_torsion_free ↥H
{n : ℕ} : Finset.univ = Finset.map equiv.perm.decompose_fin.symm.to_Embedding Finset.univ
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [LinearOrderedField 𝕜] [AddCommGroup E] [LinearOrderedAddCommGroup β] [Module 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f : E → β} {t : Finset ι} {w : ι → 𝕜} {p : ι → E} (h : ConvexOn 𝕜 s f) (hw₀ : ∀ (i : ι), i ∈ t → 0 ≤ w i) (hw₁ : 0 < t.sum (λ (i : ι), w i)) (hp : ∀ (i : ι), i ∈ t → p i ∈ s) : ∃ (i : ι) (H : i ∈ t), f (t.center_mass w p) ≤ f (p i)
{a p k : ℕ} (pp : Nat.Prime p) (h₁ : ¬a ∣ p ^ k) (h₂ : a ∣ p ^ (k + 1)) : a = p ^ (k + 1)
{G : Type u_1} [Group G] (H : Subgroup G) [hG : group.is_nilpotent G] : group.nilpotency_class ↥H ≤ group.nilpotency_class G
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {L₁ L₂ : C ⥤ D} {R₁ R₂ : D ⥤ C} (Adj₁ : L₁ ⊣ R₁) (Adj₂ : L₂ ⊣ R₂) (f : L₂ ⟶ L₁) [CategoryTheory.IsIso (⇑(Category_theory.transfer_NatTrans_self Adj₁ Adj₂) f)] : CategoryTheory.IsIso f
{C : Type u₁} [CategoryTheory.Category C] {B A : C} {X : CategoryTheory.Subobject B} (f : A ⟶ B) [CategoryTheory.Mono f] (i : A ≅ ↑X) (w : i.hom ≫ X.arrow = f) : CategoryTheory.Subobject.mk f = X
(R : CommRing) : algebraic_geometry.identity_toΓ_Spec.app (algebraic_geometry.Spec.to_LocallyRingedSpace.obj (Opposite.op R)) ≫ algebraic_geometry.Spec.to_LocallyRingedSpace.map (algebraic_geometry.Spec_Γ_identity.inv.app R).op = 𝟙 ((𝟭 AlgebraicGeometry.LocallyRingedSpace).obj (algebraic_geometry.Spec.to_LocallyRingedSpace.obj (Opposite.op R)))
{C : Type u₁} [CategoryTheory.Category C] {X : C} (P : Cᵒᵖ ⥤ Type w) : CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Presieve.Singleton (𝟙 X))
(x : ℂ) : HasDerivAt Complex.cosh (Complex.sinh x) x
{M : Type u_3} {N : Type u_4} [has_One M] [has_One N] {f g : OneHom M N} (h : f = g) (x : M) : ⇑f x = ⇑g x
{α : Type u} [TopologicalSpace α] {x : α} : Coe ⁻¹' {↑x} = ConnectedComponent x
{α : Type u_1} (r : α → α → Prop) [wo : IsWellOrder α r] {s : Set (Set α)} (h₁ : Set.Unbounded r (⋃₀s)) (h₂ : Cardinal.mk ↥s < StrictOrder.cof r) : ∃ (x : Set α) (H : x ∈ s), Set.Unbounded r x
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X ⟶ Y} {c : CategoryTheory.Limits.Fork f g} (h : CategoryTheory.Limits.IsLimit c) [CategoryTheory.Epi c.ι] : CategoryTheory.IsIso c.ι
(p : ℕ) [p_Prime : Fact (Nat.Prime p)] {q r : ℚ} (hq : q ≠ 0) (hr : r ≠ 0) : padic_val_rat p (q / r) = padic_val_rat p q - padic_val_rat p r
{𝕜 : Type u} [hnorm : NondiscreteNormedField 𝕜] {E : Type v} [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E] [HasContinuousSmul 𝕜 E] (l : E →ₗ[𝕜] 𝕜) : Continuous ⇑l ↔ is_IsClosed ↑(l.ker)
{R : Type v} [CommRing R] (A : Matrix (Fin 3) (Fin 3) R) : A.det = A 0 0 * A 1 1 * A 2 2 - A 0 0 * A 1 2 * A 2 1 - A 0 1 * A 1 0 * A 2 2 + A 0 1 * A 1 2 * A 2 0 + A 0 2 * A 1 0 * A 2 1 - A 0 2 * A 1 1 * A 2 0
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] (F : C ⥤ D) {X Y : C} (f : X ⟶ Y) [CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.cospan f f) F] [CategoryTheory.Mono (F.map f)] : CategoryTheory.Mono f
{M₀ : Type u_1} [MulZeroOneClass M₀] [Nontrivial M₀] : 0 ≠ 1
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R : CategoryTheory.Presieve X} {x : CategoryTheory.Presieve.FamilyOfElements P ⇑(CategoryTheory.Sieve.generate R)} (t : x.compatible) : (CategoryTheory.Presieve.FamilyOfElements.restrict _ x).sieve_extend = x
{C : Type u} [CategoryTheory.Category C] {P Q R : C} (f : P ⟶ Q) (g : Q ⟶ R) [CategoryTheory.StrongMono (f ≫ g)] : CategoryTheory.StrongMono f
{E : Type u_1} (R : Type u_2) (S : Type u_3) [AddCommGroup E] [DivisionRing R] [DivisionRing S] [Module R E] [Module S E] (r : ℚ) (x : E) : ↑r • x = ↑r • x
(n : ℕ) (R : Type u_1) [Ring R] [Nontrivial R] : (Polynomial.cyclotomic n R).degree = ↑(n.totient)
{a b : ℝ} {g' g : ℝ → ℝ} (hcont : ContinuousOn g (Set.Interval a b)) (hderiv : ∀ (x : ℝ), x ∈ Set.Ioo (Linear_order.min a b) (Linear_order.max a b) → HasDerivAt g (g' x) x) (hpos : ∀ (x : ℝ), x ∈ Set.Ioo (Linear_order.min a b) (Linear_order.max a b) → 0 ≤ g' x) : IntervalIntegrable g' MeasureTheory.MeasureSpace.volume a b
(𝕜 : Type u_1) [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (f : E → F) [MeasurableSpace E] [OpensMeasurableSpace E] {K : Set (E →L[𝕜] F)} (hK : IsComplete K) : MeasurableSet {x : E | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K}
{R : Type u} [CommSemiring R] [NoZeroDivisors R] (t : Multiset (Polynomial R)) : t.prod.leading_Coeff = (Multiset.map (λ (f : Polynomial R), f.leading_Coeff) t).prod
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasZeroMorphisms C] (X : C) : CategoryTheory.IsPullback 0 0 (𝟙 X) 0
{p n r b : ℕ} (hp : Nat.Prime p) (hbn : Nat.log p n < b) : p ^ r ∣ n.factorial ↔ r ≤ (Finset.ico 1 b).sum (λ (i : ℕ), n / p ^ i)
(n : ℕ) : (List.Nat.antidiagonal n).length = n + 1
{α : Type u_1} [Preorder α] {f g : α → α} (hF : Monotone f) (h : f ≤ g) (n : ℕ) : f^[n] ≤ (g^[n])
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrderedAddCommGroup α] [OrderTopology α] {l : Filter β} {f g : β → α} {C : α} (hF : Filter.Tendsto f l filter.at_Top) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (λ (x : β), f x + g x) l filter.at_Top
{α : Type u_1} {s : Finset α} (p : α → Prop) [DecidablePred p] : Finset.map (Function.Embedding.subtype p) (Finset.subtype p s) = Finset.filter p s
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {c : AddCon M} {f : M →+ P} (h : c ≤ AddCon.ker f) (hF : Function.Surjective ⇑f) : Function.Surjective ⇑(c.lift f h)
{α : Type u_1} {β : Type u_3} [MeasurableSpace α] [MeasurableSpace β] : IsPiSystem (Set.image2 HasSetProd.prod {s : Set α | MeasurableSet s} {t : Set β | MeasurableSet t})
{E : Type u_1} [InnerProductSpace ℝ E] {n : ℕ} (hn : 0 < n) (h : FiniteDimensional.finrank ℝ E = n) (x : Orientation ℝ E (Fin n)) : Orthonormal ℝ ⇑(orientation.fin_Orthonormal_Basis hn h x)
(C : Type u) [CategoryTheory.Category C] [∀ {X Y : C} {f g : X ⟶ Y}, CategoryTheory.Limits.HasLimit (Category_theory.limits.parallel_pair f g)] : CategoryTheory.Limits.HasEqualizers C
{M : Type u_1} [AddZeroClass M] {ι : sort u_2} (S : ι → AddSubmonoid M) {C : M → Prop} {x : M} (hx : x ∈ ⨆ (i : ι), S i) (hp : ∀ (i : ι) (x : M), x ∈ S i → C x) (h1 : C 0) (hMul : ∀ (x y : M), C x → C y → C (x + y)) : C x
{n : ℤ} (hn : n ≠ 0) (z : ↥Circle) : ⇑(fourier n) (⇑Exp_Map_Circle ((↑n)⁻¹ * Real.pi) * z) = -⇑(fourier n) z
{β : Type u_1} [ConditionallyCompleteLattice β] {s : Set (WithTop β)} (hs : BddBelow s) : IsGlb s (HasInf.inf s)
{n : ℕ} (p : Fin (n + 2)) (i : Fin (n + 1)) (h : 0 < i) : 0 < ⇑(p.succ_above) i
{C : Type u} [CategoryTheory.Category C] {X Y Z : C} (f : X ⟶ Y) {g h : Y ⟶ Z} (w : g = h) : f ≫ g = f ≫ h
{α : Type u} {β : Type v} [SemilatticeInf α] {r : β → β → Prop} {f : α → β} (hF : ∀ (a₁ a₂ : α), a₁ ≤ a₂ → r (f a₂) (f a₁)) : Directed r f
(R : Type u) [Ring R] [StrongRankCondition R] (m : Type v) (n : Type w) [Fintype m] [Fintype n] : Module.rank R (Matrix m n R) = (Cardinal.mk m).lift * (Cardinal.mk n).lift
{n : Type u_3} {α : Type v} {β : Type w} [HasMul α] [HasMul β] (f : α → β) (r : α) (A : Matrix n n α) (hF : ∀ (a₁ a₂ : α), f (a₁ * a₂) = f a₁ * f a₂) : (MulOpposite.op r • A).map f = MulOpposite.op (f r) • A.map f
{b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ Nat.clog b x ≤ y
{M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : MulOneClass M} {mN : MulOneClass N} [MonoidHomClass F M N] (f : F) {x : M} (hx : ∃ (y : M), y * x = 1) : ∃ (y : N), y * ⇑f x = 1
{α : Type u} [PseudoEmetricSpace α] {δ : ℝ} {E : Set α} : is_IsClosed (Metric.Cthickening δ E)
{X : Type u_1} [TopologicalSpace X] : DiscreteTopology X ↔ nhds = has_pure.pure
{K : Type u_1} [LinearOrderedField K] [FloorRing K] {v : K} (terminates : (GeneralizedContinuedFraction.of v).terminates) : ∃ (q : ℚ), v = ↑q
(X : AlgebraicGeometry.LocallyRingedSpace (r : ↥(AlgebraicGeometry.LocallyRingedSpaceΓ.obj (Opposite.op X))) : X.to_Γ_spec_fun ⁻¹' (Prime_spectrum.basic_IsOpen r).val = (X.to_RingedSpace.basic_IsOpen r).val
{ι : Type w} [Fintype ι] (K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [Module.Finite K L] [IsSeparable K L] (b : Basis ι K L) : Algebra.discr K ⇑b ≠ 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p₁ p₂ : ι → P) (b : P) : s.sum (λ (i : ι), w i • (p₁ i -ᵥ p₂ i)) = ⇑(s.weighted_vsub_of_point p₁ b) w - ⇑(s.weighted_vsub_of_point p₂ b) w
{G : Type u_6} {H : Type u_7} {F : Type u_8} [AddGroup G] [SubtractionMonoid H] [AddMonoidHomClass F G H] (f : F) (a : G) : ⇑f (-a) = -⇑f a
{𝕜 : Type u} [NondiscreteNormedField 𝕜] (x : 𝕜) {𝕜' : Type u_1} [NondiscreteNormedField 𝕜'] [NormedAlgebra 𝕜 𝕜'] {h : 𝕜 → 𝕜'} {h₂ : 𝕜' → 𝕜'} {h' h₂' : 𝕜'} (hH₂ : HasDerivAt h₂ h₂' (h x)) (hH : HasDerivAt h h' x) : HasDerivAt (h₂ ∘ h) (h₂' * h') x
{M : Type u_1} [CommMonoid M] (S : Submonoid M) {ι : Type u_2} {t : Finset ι} {f : ι → M} (h : ∀ (c : ι), c ∈ t → f c ∈ S) : t.prod (λ (c : ι), f c) ∈ S
{J : Type v} {C : Type u} [CategoryTheory.Category C] {B : C} (F : CategoryTheory.Discrete J ⥤ CategoryTheory.Over B) [CategoryTheory.Limits.HasLimit (Category_theory.over.construct_products.wide_pullback_Diagram_of_Diagram_over B F)] : CategoryTheory.Limits.HasLimit F
{α : Type u_1} {β : Type u_2} [UniformSpace α] [UniformSpace β] [SeparatedSpace α] {f : α → β} (hF : UniformInducing f) : UniformEmbedding f
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [RegularSpace α] [NonUnitalNonAssocSemiring α] [TopologicalSemiring α] {f : β → α} {g : γ → α} (hF : Summable f) (hg : Summable g) (hfg : Summable (λ (x : β × γ), f x.fst * g x.snd)) : (∑' (x : β), f x) * ∑' (y : γ), g y = ∑' (z : β × γ), f z.fst * g z.snd
{γ : Type u_3} [tγ : TopologicalSpace γ] [PolishSpace γ] {β : Type u_1} [TopologicalSpace β] [t2_Space β] [MeasurableSpace β] [BorelSpace β] {f : γ → β} (f_Cont : Continuous f) (f_inj : Function.Injective f) : MeasurableSet (Set.Range f)
{𝕜 : Type u_1} [is_R_or_C 𝕜] {E : Type u_2} [InnerProductSpace 𝕜 E] [CompleteSpace E] {T : E →L[𝕜] E} (hT : InnerProductSpace.IsSelfAdjoint ↑T) {x₀ : E} (hx₀ : x₀ ≠ 0) (hextr : IsLocalExtrOn T.re_apply_inner_self (Metric.Sphere 0 ∥x₀∥) x₀) : Module.End.HasEigenvector ↑T ↑((λ (x : E), T.re_apply_inner_self x / ∥x∥ ^ 2) x₀) x₀
(p : ℕ) [hp : Fact (Nat.Prime p)] (q r : ℚ) : padic_norm p (q + r) ≤ padic_norm p q + padic_norm p r
{α : Type u} {β : Type v} [Preorder β] {f : α → β} {l : Filter α} {a : α} : IsMaxFilter f l a → IsMinFilter (⇑order_dual.to_dual ∘ f) l a
{f : ℝ → ℝ} {a b : ℝ} (h0 : 0 < b) (h1 : ContinuousOn f (Set.Ici a)) (h2 : f =O[filter.at_Top] λ (x : ℝ), Real.exp (-b * x)) : MeasureTheory.IntegrableOn f (Set.Ioi a) MeasureTheory.MeasureSpace.volume
 : MeasureTheory.Measure.IsAddHaarMeasure topological_space.positive_compacts.Icc01 = MeasureTheory.MeasureSpace.volume
(R : Type u_1) [CommRing R] : Algebra.FinitePresentation R R
{α : Type u_1} {β : Type u_2} [LinearOrder α] [PredOrder α] [Preorder β] {f : α → β} (hF : Antitone f) : Pairwise (Disjoint on λ (n : α), Set.Ioo (f n) (f (Order.pred n)))
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} {s : Set α} (hF : Set.EqOn f 0 s) : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) = 0
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] (f : S.localization_Map N) (z : N) : f.mk' (f.sec z).fst (f.sec z).snd = z
(α : Type u) [Preorder α] [Nonempty α] [NoMaxOrder α] : ∃ (f : ℕ → α), StrictMono f
{α : Type u} [Preorder α] [OrderBot α] {a b : α} (h : a < b) : b ≠ ⊥
{α : Type u_1} {β : Type u_2} {l : Filter α} {f g : α → β} : f =ᶠ[l] g → ↑f = ↑g
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : o.oangle x (-y) = o.oangle x y + ↑Real.pi
{R : Type u} [CommRing R] (S : Submonoid R) {L : Type u} [CommRing L] [Algebra R L] [IsLocalization S L] [Fintype R] : Function.Surjective ⇑(Algebra_Map R L)
{β : Type u} {α : Type v} {γ : Type w} [AddCommMonoid β] {s : Finset α} {t : Finset γ} {f : α → β} {g : γ → β} (i : Π (a : α), a ∈ s → γ) (hi : ∀ (a : α) (ha : a ∈ s), i a ha ∈ t) (h : ∀ (a : α) (ha : a ∈ s), f a = g (i a ha)) (j : Π (a : γ), a ∈ t → α) (hj : ∀ (a : γ) (ha : a ∈ t), j a ha ∈ s) (IsLeftInv : ∀ (a : α) (ha : a ∈ s), j (i a ha) _ = a) (IsRightInv : ∀ (a : γ) (ha : a ∈ t), i (j a ha) _ = a) : s.sum (λ (x : α), f x) = t.sum (λ (x : γ), g x)
{α : sort u} {C : α → sort v} {r : α → α → Prop} (hwf : WellFounded r) (F : Π (x : α), (Π (y : α), r y x → C y) → C x) (x : α) : hwf.fix F x = F x (λ (y : α) (h : r y x), hwf.fix F y)
(a : ↥Circle) : ⇑(Linear_map.to_Matrix complex.basis_One_I complex.basis_One_I) ↑((⇑rotation a).to_LinearEquiv) = ⇑(matrix.plane_conformal_Matrix ↑a.re ↑a.im _)
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (r : R) : v.int_Valuation_def r < 1 ↔ v.as_Ideal ∣ Ideal.span {r}
{G : Type u} [Group G] [Fintype G] {N : Subgroup G} [N.normal] (hN : (Fintype.card ↥N).coprime N.index) : ∃ (H : Subgroup G), N.is_complement' H
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] [Nontrivial B] (a : A) (hF : Function.Injective ⇑(Algebra_Map A B)) : minpoly A (⇑(Algebra_Map A B) a) = Polynomial.x - ⇑Polynomial.c a
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {n : ℕ} (s : Affine.Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ℕ} (h : fs.card = m + 1) : (s.face h).points = s.points ∘ ⇑(fs.order_emb_of_Fin h)
{α : Type u_2} [DivisionMonoid α] {a : α} : IsSquare a → IsSquare a⁻¹
{𝕂 : Type u_1} {𝔸 : Type u_2} [is_R_or_C 𝕂] [NormedRing 𝔸] [NormedAlgebra 𝕂 𝔸] [CompleteSpace 𝔸] {ι : Type u_3} (s : Finset ι) (f : ι → 𝔸) (h : ∀ (i : ι), i ∈ s → ∀ (j : ι), j ∈ s → Commute (f i) (f j)) : Exp 𝕂 (s.sum (λ (i : ι), f i)) = s.noncomm_Prod (λ (i : ι), Exp 𝕂 (f i)) _
{α : Type u_1} {𝒜 : Finset (Finset α)} {r : ℕ} : Set.Sized r ↑(𝒜.slice r)
{α : Type u_1} {s : Finset α} {f : α → Ennreal} (h : ∀ (a : α), a ∈ s → f a ≠ ⊤) : s.prod (λ (a : α), f a) < ⊤
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [Field k] [AddCommGroup E] [Module k E] [AddTorsor E PE] (f : k → PE) (a b c : k) (h : a ≠ c) : ⇑(affine_map.line_Map (slope f a b) (slope f b c)) ((c - b) / (c - a)) = slope f a c
{R : Type u_1} [Ring R] {E : Type u_2} [AddCommGroup E] [Module R E] {F : Type u_3} [AddCommGroup F] [Module R F] (f g : LinearPmap R E F) (h : Disjoint f.domain g.domain) (x : ↥(f.domain)) (y : ↥(g.domain)) (hxy : ↑x = ↑y) : ⇑f x = ⇑g y
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} [CharZero k] {s : Finset ι} (p : ι → P) {n : ℕ} (h : s.card = n + 1) : Finset.centroid k s p ∈ affine_Span k (Set.Range p)
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] (p1 p2 : P) : p1 ∈ affine_Span k {p2} ↔ p1 = p2
(R : Type u_1) [Ring R] : Polynomial.cyclotomic 1 R = Polynomial.x - 1
{α : Type u_1} {γ : Type u_3} [TopologicalSpace α] [MeasurableSpace α] [OpensMeasurableSpace α] [TopologicalSpace γ] [MeasurableSpace γ] [BorelSpace γ] {f g : α → γ} {s : Set α} [Π (j : α), Decidable (j ∈ s)] (hF : ContinuousOn f s) (hg : ContinuousOn g sᶜ) (hs : MeasurableSet s) : Measurable (s.piecewise f g)
(p : ℕ) : padic_norm p 0 = 0
{α : Type u_1} {M : Type u_5} {N : Type u_7} {R : Type u_11} [Semiring R] [AddCommMonoid M] [AddCommMonoid N] [DistribMulAction R M] [DistribMulAction R N] {f g : (α →₀ M) →+[R] N} (h : ∀ (a : α), f.comp (Finsupp.DistribMulActionHom.single a) = g.comp (Finsupp.DistribMulActionHom.single a)) : f = g
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] (f : M →ₗ[R] M) [hfg : Module.Finite R M] (f_surj : Function.Surjective ⇑f) : Function.Injective ⇑f
{α : Type u} [PseudoMetricSpace α] {s : Set α} {x : α} (hx : x ∈ Closure s) : metric.inf_dist x s = 0
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {p1 p2 : P} (h : p1 ≠ p2) : EuclideanGeometry.angle p1 p2 p1 = 0
{R : Type u} [Ring R] {M : Type v} [AddCommGroup M] [Module R M] {M₁ : Type v} [AddCommGroup M₁] [Module R M₁] (f : M ≃ₗ[R] M₁) : Module.rank R M = Module.rank R M₁
{α : Type u_1} [LinearOrder α] {a b c d : α} (h₁ : Linear_order.min a b < Linear_order.max c d) (h₂ : Linear_order.min c d < Linear_order.max a b) : Set.Icc a b ∪ Set.Icc c d = Set.Icc (Linear_order.min a c) (Linear_order.max b d)
{α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] : {s : Set α | IsPreconnected s} ⊆ Set.Range (Function.uncurry Set.Icc) ∪ Set.Range (Function.uncurry Set.Ico) ∪ Set.Range (Function.uncurry Set.Ioc) ∪ Set.Range (Function.uncurry Set.Ioo) ∪ (Set.Range Set.Ici ∪ Set.Range Set.Ioi ∪ Set.Range Set.Iic ∪ Set.Range Set.Iio ∪ {Set.Univ, ∅})
{R : Type v} [CommRing R] {n : ℕ} {A B : Matrix (Fin (n + 1)) (Fin (n + 1)) R} (c : Fin n → R) (A_Zero : ∀ (i : Fin (n + 1)), A i 0 = B i 0) (A_Succ : ∀ (i : Fin (n + 1)) (j : Fin n), A i j.succ = B i j.succ + c j * A i (⇑fin.cast_Succ j)) : A.det = B.det
{ι : Type u} {f g : ι → ℝ} {p : ℝ} (hp : 1 ≤ p) (hF : ∀ (i : ι), 0 ≤ f i) (hg : ∀ (i : ι), 0 ≤ g i) (hF_Sum : Summable (λ (i : ι), f i ^ p)) (hg_Sum : Summable (λ (i : ι), g i ^ p)) : Summable (λ (i : ι), (f i + g i) ^ p) ∧ (∑' (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤ (∑' (i : ι), f i ^ p) ^ (1 / p) + (∑' (i : ι), g i ^ p) ^ (1 / p)
{α : Type u} [PseudoMetricSpace α] {x : α} {r : ℝ} (h : 0 ≤ r) : Metric.diam (Metric.Ball x r) ≤ 2 * r
{n : ℕ} : Function.Injective Fin.succ_above
{R : Type u_1} [Semiring R] (f : LaurentPolynomial R) (m n : ℤ) : f * LaurentPolynomial.t m * LaurentPolynomial.t n = f * LaurentPolynomial.t (m + n)
{α : Type u_1} [LinearOrder α] {s : Finset α} {k : ℕ} (h : s.card = k) {f : Fin k ↪o α} (hfs : ∀ (x : Fin k), ⇑f x ∈ s) : f = s.order_emb_of_Fin h
{α : Type u_1} [CircularPreorder α] {a b c : α} (h : HasSbtw.Sbtw a b c) : HasSbtw.Sbtw c a b
{G : Type u_1} [Group G] (H : Subgroup G) [H.normal] [h : group.is_nilpotent G] : group.nilpotency_class (G ⧸ H) ≤ group.nilpotency_class G
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasColimits C] {X : Top} (F : Top.Presheaf C X) {x : ↥X} {Y : C} {f₁ f₂ : F.stalk x ⟶ Y} (ih : ∀ (U : TopologicalSpace.Opens ↥X) (hxU : x ∈ U), F.germ ⟨x, hxU⟩ ≫ f₁ = F.germ ⟨x, hxU⟩ ≫ f₂) : f₁ = f₂
{𝕜 : Type u_1} {_x : Ring 𝕜} {E : Type u_2} [SemiNormedGroup E] {_x_1 : Module 𝕜 E} {s : Submodule 𝕜 E} (x : ↥s) : ∥x∥ = ∥↑x∥
{𝕜 : Type u_1} {E : Type u_2} [OrderedRing 𝕜] [AddCommGroup E] [Module 𝕜 E] {K : Geometry.SimplicialComplex 𝕜 E} {s t : Finset E} (hs : s ∈ K.faces) (ht : t ∈ K.faces) : Disjoint (⇑(Convex_hull 𝕜) ↑s) (⇑(Convex_hull 𝕜) ↑t) ∨ ∃ (u : Finset E) (H : u ∈ K.faces), ⇑(Convex_hull 𝕜) ↑s ∩ ⇑(Convex_hull 𝕜) ↑t = ⇑(Convex_hull 𝕜) ↑u
{G : Type u} [Group G] [Fintype G] (p : ℕ) {n m : ℕ} [hp : Fact (Nat.Prime p)] (hdvd : p ^ m ∣ Fintype.card G) (H : Subgroup G) (hH : Fintype.card ↥H = p ^ n) (hnm : n ≤ m) : ∃ (K : Subgroup G), Fintype.card ↥K = p ^ m ∧ H ≤ K
{A : Type u_4} (K : Type u_5) [CommRing A] [is_IsDomain A] (L : Type u_6) [Field K] [Field L] [Algebra A K] [IsFractionRing A K] [Algebra A L] [Algebra K L] [IsScalarTower A K L] [FiniteDimensional K L] : IsFractionRing ↥(IsIntegralClosure A L) L
{α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} [TopologicalSpace β] {f : α → β} (hF : ∀ (x y : α), f x = f y) : MeasureTheory.StronglyMeasurable f
{f : ℝ → ℝ} (hF : Differentiable ℝ f) (hF'_anti : Antitone (deriv f)) : ConcaveOn ℝ Set.Univ f
(j : ℕ) : ¬algebraic_topology.dold_kan.c.rel 0 j
{k : Type u_1} {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] [CharZero k] {n : ℕ} (s : Affine.Simplex k P n) {fs₁ fs₂ : Finset (Fin (n + 1))} {m₁ m₂ : ℕ} (h₁ : fs₁.card = m₁ + 1) (h₂ : fs₂.card = m₂ + 1) : Finset.centroid k fs₁ s.points = Finset.centroid k fs₂ s.points ↔ fs₁ = fs₂
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (a b : F) : char.quadratic_Char F (a * b) = char.quadratic_Char F a * char.quadratic_Char F b
{M : Type u_1} [AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M →+ P} {T : AddSubmonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [AddCommMonoid Q] {k : T.localization_Map Q} (z : N) : ⇑(f.map hy k) z + ⇑(k.to_Map) (⇑g ↑((f.sec z).snd)) = ⇑(k.to_Map) (⇑g (f.sec z).fst)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} (p : ι → P) (i0 : ι) : Vector_Span k (Set.Range p) = Submodule.span k (Set.Range (λ (i : ι), p i -ᵥ p i0))
{α : Type u} [PseudoEmetricSpace α] {s : Set α} : Isometry Coe
{α : Type u_1} {R : Type u_2} [CommSemiring R] (a b : R) (s : Finset α) : s.powerset.sum (λ (t : Finset α), a ^ t.card * b ^ (s.card - t.card)) = (a + b) ^ s.card
{K : Type u} [Field K] (s : Subfield K) {x y : K} : x ∈ s → y ∈ s → x * y ∈ s
{α : Type u_1} [has_Add α] [Preorder α] [CovariantClass α α has_add.add has_le.le] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b c d : α} (h₁ : a < b) (h₂ : c < d) : a + c < b + d
{α : Type u} [HasSsubset α] [IsIrrefl α HasSsubset.Ssubset] {a b : α} : a ⊂ b → a ≠ b
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] : ⊤.direction = ⊤
{R : Type u_1} {a b : R} [Monoid R] (h : a * b = 1) : IsRightRegular a
{α : Type u_1} {β : Type u_2} {m₁ : MeasurableSpace α} {m₂ : MeasurableSpace β} {f : α → β} : Measurable f → m₂ ≤ MeasurableSpace.map f m₁
{α : Type u_1} {E : Type u_3} {F'' : Type u_10} [HasNorm E] [NormedGroup F''] {f : α → E} {g'' : α → F''} (h : f =O[Filter.cofinite] g'') : ∃ (C : ℝ) (H : C > 0), ∀ ⦃x : α⦄, g'' x ≠ 0 → ∥f x∥ ≤ C * ∥g'' x∥
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : Rˣ) : (λ (t : R), Ring.inverse (↑x + t) - ↑x⁻¹ + ↑x⁻¹ * t * ↑x⁻¹) =O[nhds 0] λ (t : R), ∥t∥ ^ 2
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [Module 𝕜 E] {x z : E} {s : Set E} (hs : StarConvex 𝕜 (x + z) s) : StarConvex 𝕜 x ((λ (x : E), x + z) ⁻¹' s)
{F : Type u_1} [Field F] {p : Polynomial F} {E : Type u_2} [Field E] [Algebra F E] [Fact (Polynomial.Splits (Algebra_Map F E) p)] (ϕ : E ≃ₐ[F] E) (x : ↥(p.root_Set E)) : ↑(⇑(Polynomial.Gal.restrict p E) ϕ • x) = ⇑ϕ ↑x
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {ι : Type u_1} [Fintype ι] {b : ι → V} : LinearIndependent K b ↔ Fintype.card ι = Set.finrank K (Set.Range b)
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : Real.sin (InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) = Real.sin (InnerProductGeometry.angle x y)
{R : Type u_1} [HasMul R] {a : R} : IsRightRegular a ↔ IsSmulRegular R (MulOpposite.op a)
{ι : Type u_1} {E : Type u_2} [Fintype ι] [NormedGroup E] [NormedSpace ℝ E] (b : AffineBasis ι ℝ E) : Interior (⇑(Convex_hull ℝ) (Set.Range b.points)) = {x : E | ∀ (i : ι), 0 < ⇑(b.coord i) x}
{α : Type u_1} {β : Type u_2} {s : Set α} {u : α → Set β} {x : α} (xs : x ∈ s) : u x ⊆ ⋃ (x : α) (H : x ∈ s), u x
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) (v : E) : v ∈ Kᗮ ↔ ∀ (u : E), u ∈ K → HasInner.inner u v = 0
{M : Type u_1} [has_Add M] (c : AddCon M) {a b : M} : ↑a = ↑b ↔ ⇑c a b
{G : Type u} [Fintype G] [LeftCancelMonoid G] (x : G) : 0 < order_of x
{α : Type u_1} {ι : sort u_4} {s : ι → Set α} {t : Set α} (i : ι) (h : s i ⊆ t) : (⋂ (i : ι), s i) ⊆ t
{α : Type u} (s : Set α) : Subsingleton ↥s ↔ s.subsingleton
(R : Type u_2) {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] (n : ℕ) (b : M) : n • b = ↑n • b
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {f : E → F × G} {x : E} (hF : ContDiffAt 𝕜 n f x) : ContDiffAt 𝕜 n (λ (x : E), (f x).fst) x
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {R₁ R₂ : ℝ} {f : ℂ → E} {c z : ℂ} (hD : DifferentiableOn ℂ f (Metric.Ball c R₁)) (h_maps : Set.MapsTo f (Metric.Ball c R₁) (Metric.Ball (f c) R₂)) (hz : z ∈ Metric.Ball c R₁) : ∥dslope f c z∥ ≤ R₂ / R₁
{α : Type u_1} [MeasurableSpace α] (m₁ m₂ : MeasureTheory.OuterMeasure α) : (m₁ ⊔ m₂).trim = m₁.trim ⊔ m₂.trim
{P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → b ≤ z) (Hinh : ∃ (z : ℤ), P z) : ∃ (lb : ℤ), P lb ∧ ∀ (z : ℤ), P z → lb ≤ z
{f : Polynomial ℂ} (hF : 0 < f.degree) : ∃ (z : ℂ), f.is_root z
{k : Type u_1} {V : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {p : ι → P} (hi : AffineIndependent k p) {s : Finset ι} {n : ℕ} (hc : s.card = n + 1) : FiniteDimensional.finrank k ↥(Vector_Span k ↑(Finset.image p s)) = n
{α : Type u_1} {𝕜 : Type u_14} [NormedField 𝕜] {l : Filter α} {u v : α → 𝕜} (h : u =O[l] v) : u / v * v =ᶠ[l] u
{α : Type u} [TopologicalSpace α] {s : Set α} [DiscreteTopology ↥s] {x : α} (hx : x ∈ s) : ∃ (U : Set α) (H : U ∈ nhds_within x {x}ᶜ), Disjoint U s
{α : Type u} [SemilatticeInf α] [Nonempty α] (s : Finset α) : BddBelow ↑s
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] {p1 p2 : P} : p1 -ᵥ p2 = 0 ↔ p1 = p2
{α : Type u} {β : Type v} [Ring α] [Ring β] {f : α → β} {x y : α} (hF : IsRingHom f) : f (x - y) = f x - f y
{α : sort u} {α' : sort w} [DecidableEq α] [DecidableEq α'] {β : sort u_1} (g : α' → β) {f : α → α'} (hF : Function.Injective f) (i : α) (a : β) : Function.update g (f i) a ∘ f = Function.update (g ∘ f) i a
{α : Type u_1} {β : Type u_2} [LinearOrder α] [TopologicalSpace α] [OrderTopology α] [LinearOrder β] [TopologicalSpace β] [OrderTopology β] {f : α → β} {s : Set α} {a : α} (h_Mono : MonotoneOn f s) (hs : s ∈ nhds_within a (Set.Ici a)) (hfs : ∀ (b : β), b > f a → (∃ (c : α) (H : c ∈ s), f c ∈ Set.Ioo (f a) b)) : ContinuousWithinAt f (Set.Ici a) a
{J : Type v} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (f : J → C) [CategoryTheory.Limits.HasBiproduct f] {b : CategoryTheory.Limits.Bicone f} (hb : b.is_bilimit) : (hb.is_limit.cone_point_Unique_Up_to_iso (Category_theory.limits.biproduct.is_Limit f)).hom = CategoryTheory.Limits.biproduct.lift b.π
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {f g : ℂ → E} (hdf : DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0)) (hBf : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hdg : DiffContOnCl ℂ g (Set.Iio 0 ×ℂ Set.Iio 0)) (hBg : ∃ (c : ℝ) (H : c < 2) (B : ℝ), g =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hre : ∀ (x : ℝ), x ≤ 0 → f ↑x = g ↑x) (him : ∀ (x : ℝ), x ≤ 0 → f (↑x * Complex.i) = g (↑x * Complex.i)) : Set.EqOn f g {z : ℂ | z.re ≤ 0 ∧ z.im ≤ 0}
{F : Type u_2} [NormedGroup F] {f : ℝ → F} {a b c : ℝ} (hF : (λ (x : ℝ), (x - c)⁻¹) =O[nhds_within c {c}ᶜ] f) (hne : a ≠ b) (hc : c ∈ Set.Interval a b) : ¬IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X ⟶ Y} {c : CategoryTheory.Limits.Fork f g} (i : CategoryTheory.Limits.IsLimit c) : CategoryTheory.Mono c.ι
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] {c : AddCon M} {f : M →+ P} (H : c ≤ AddCon.ker f) : (c.lift f H).comp c.mk' = f
{α : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [HasZero M] [AddCommMonoid N] [AddCommMonoid P] (h : N →+ P) (f : α →₀ M) (g : α → M → N) : ⇑h (f.sum g) = f.sum (λ (a : α) (b : M), ⇑h (g a b))
(a : Zmod8) : ⇑Zmodχ₈' a = ⇑Zmodχ₄ ↑a * ⇑Zmodχ₈ a
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{R : Type u_1} {B : Type u_3} {F : Type u_4} [NondiscreteNormedField R] [NormedGroup F] [NormedSpace R F] [TopologicalSpace B] {ι : Type u_6} (Z : TopologicalVectorBundleCore R B F ι) : Continuous Z.proj
{α : Type u_1} {β : Type u_2} [Infinite α] [Fintype β] (f : α → β) : ∃ (x y : α), x ≠ y ∧ f x = f y
{F : Type u_1} {α : Type u_2} {β : Type u_3} [NonAssocSemiring α] [NonAssocSemiring β] [RingHomClass F α β] (f : F) (a : α) : ⇑f (bit1 a) = bit1 (⇑f a)
{α : Type u} [PseudoMetricSpace α] {s t : Set α} {x : α} {r : ℝ} (h : x ∈ s) (H : metric.Hausdorff_dist s t < r) (Fin : emetric.Hausdorff_edist s t ≠ ⊤) : ∃ (y : α) (H : y ∈ t), HasDist.dist x y < r
{α : Type u_1} [CancelCommMonoidWithZero α] [UniqueFactorizationMonoid α] {a p : Associates α} (hp : Irreducible p) [Π (n : ℕ), Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n) : a = p ^ Nat.find _
{R : Type u_1} [Semiring R] (s : Subsemiring R) {l : List R} : (∀ (x : R), x ∈ l → x ∈ s) → l.prod ∈ s
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [SemiNormedGroup E] [SemiNormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [RingHomIsometric σ₁₂] (f g : E →sl[σ₁₂] F) : ∥f + g∥ ≤ ∥f∥ + ∥g∥
{J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ AddMon) [CategoryTheory.IsFiltered J] (x y : Σ (j : J), ↥(F.obj j)) (k : J) (f : x.fst ⟶ k) (g : y.fst ⟶ k) : AddMon.FilteredColimits.M.mk F x + AddMon.FilteredColimits.M.mk F y = AddMon.FilteredColimits.M.mk F ⟨k, ⇑(F.map f) x.snd + ⇑(F.map g) y.snd⟩
{G : Type u_1} [AddGroup G] [hN : Nontrivial G] : Add_monoid.is_torsion_free G → ¬Add_monoid.is_torsion G
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] (e : LocalHomeomorph α β) (s : Set β) : e.to_local_equiv.source ∩ ⇑e ⁻¹' Interior s = e.to_local_equiv.source ∩ Interior (⇑e ⁻¹' s)
{G : Type u_10} {H : Type u_11} [Group G] [DivisionMonoid H] (h : G ≃* H) (x : G) : ⇑h x⁻¹ = (⇑h x)⁻¹
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y : M} {r : R} (h : SameRay R x y) (hr : 0 ≤ r) : SameRay R (r • x) y
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) : o.oangle (⇑(o.rotation (o.oangle x y)) x) y = 0
{α : Type u_1} [UniformSpace α] : (Uniformity α).has_Basis (λ (V : Set (α × α)), V ∈ Uniformity α) Closure
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {ι : Type w} (h : Basis ι K V) : ↑(FiniteDimensional.finrank K V) = Cardinal.mk ι
{α : Type u_1} {M : Type u_5} [HasZero M] : Function.Injective Coe_fn
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) {r : Nnreal} (h₀ : r ≠ 0) {a : ℝ} (ha : a ∈ Set.Ioo (-1) 1) (hp : (λ (n : ℕ), ∥p n∥ * ↑r ^ n) =O[filter.at_Top] has_pow.pow a) : ↑r < p.radius
{n : ℕ} {α : Fin (n + 1) → Type u} (x : α (fin.last n)) (p : Π (i : Fin n), α (⇑fin.cast_Succ i)) (z : α (fin.last n)) : Function.update (fin.snoc p x) (fin.last n) z = fin.snoc p z
{α : Type u} [TopologicalSpace α] [LocallyCompactSpace α] [RegularSpace α] {K U : Set α} (hK : is_IsCompact K) (hU : is_IsOpen U) (hKU : K ⊆ U) : ∃ (V : Set α), is_IsOpen V ∧ K ⊆ V ∧ Closure V ⊆ U ∧ is_IsCompact (Closure V)
(K : Type u_1) [Field K] [IsAlgClosed K] (S : Set ℕ+) : IsCyclotomicExtension S K K
{α : Type u} [HasSubset α] [IsTrans α HasSubset.Subset] {a b c : α} : a ⊆ b → b ⊆ c → a ⊆ c
(f : Circle_deg1_Lift) (x : ℝ) : Filter.Tendsto (λ (n : ℕ), (⇑(f ^ n) x - x) / ↑n) filter.at_Top (nhds f.translation_number)
{α : Type u_1} {ι : sort u_3} [ConditionallyCompleteLattice α] {b : α} [Nonempty ι] {f : ι → α} (h₁ : ∀ (i : ι), f i ≤ b) (h₂ : ∀ (w : α), w < b → (∃ (i : ι), w < f i)) : (⨆ (i : ι), f i) = b
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [LinearOrderedAddCommMonoid β] [HasScalar 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f g : E → β} (hF : ConcaveOn 𝕜 s f) (hg : ConcaveOn 𝕜 s g) : ConcaveOn 𝕜 s (f ⊓ g)
{α : Type u_1} {M : Type u_5} {N : Type u_7} [HasZero M] [AddCommMonoid N] (f : α →₀ M) (y : α) (g : α → M → N) (hg : ∀ (i : α), g i 0 = 0) : g y (⇑f y) + (Finsupp.erase y f).sum g = f.sum g
{C : Type u} [CategoryTheory.Category C] {P Q R : C} (f : P ⟶ Q) (g : Q ⟶ R) [CategoryTheory.StrongMono f] [CategoryTheory.StrongMono g] : CategoryTheory.StrongMono (f ≫ g)
{X : Type u_2} [EmetricSpace X] {m₁ m₂ : Ennreal → Ennreal} {c : Ennreal} (hc : c ≠ ⊤) (h0 : c ≠ 0) (hle : m₁ ≤ᶠ[nhds_within 0 (Set.Ici 0)] c • m₂) : measure_theory.outer_measure.mk_metric m₁ ≤ c • measure_theory.outer_measure.mk_metric m₂
{α : Type u_1} [MeasurableSpace α] {ι : Type u_2} {f : ι → α → Ennreal} {g : α → Ennreal} (u : Filter ι) [u.ne_IsBot] [u.is_countably_generated] (hF : ∀ (i : ι), Measurable (f i)) (lim : Filter.Tendsto f u (nhds g)) : Measurable g
{M : Type u} [Monoid M] {F : Type v} [DivisionRing F] [MulSemiringAction M F] (x : M) (m : F) : x • m⁻¹ = (x • m)⁻¹
{α : Type u_1} [PseudoEmetricSpace α] {f : ℕ → α} (d : ℕ → Ennreal) (hF : ∀ (n : ℕ), HasEdist.edist (f n) (f n.succ) ≤ d n) {a : α} (ha : Filter.Tendsto f filter.at_Top (nhds a)) (n : ℕ) : HasEdist.edist (f n) a ≤ ∑' (m : ℕ), d (n + m)
{C : Type u} [CategoryTheory.Category C] (F : Cᵒᵖ ⥤ Type v) : (CategoryTheory.Category_of_elements.from_CostructuredArrow F).right_Op ⋙ CategoryTheory.Category_of_elements.to_CostructuredArrow F = 𝟭 (CategoryTheory.CostructuredArrow CategoryTheory.yoneda F)
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) : 2 • o.oangle x (-x) = 0
{M : Type u_1} [MonoidWithZero M] {f g : ℤ →*₀ M} (h_Neg_One : ⇑f (-1) = ⇑g (-1)) (h_Nat : f.comp int.of_Nat_hom.to_MonoidWithZero_hom = g.comp int.of_Nat_hom.to_MonoidWithZero_hom) : f = g
{V₁ : Type u_2} {V₂ : Type u_3} [SemiNormedGroup V₁] [SemiNormedGroup V₂] (f : NormedGroupHom V₁ V₂) {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ (x : V₁), ∥⇑f x∥ ≤ M * ∥x∥) : ∥f∥ ≤ M
{V : Type u_1} [InnerProductSpace ℝ V] (x : V) : InnerProductGeometry.angle 0 x = Real.pi / 2
{n : ℕ} {α : Type u_1} [Preorder α] {f g : Fin n → α} (hF : StrictMono f) (hg : StrictMono g) (h : Set.Range f = Set.Range g) : f = g
{R : Type u_1} [Fintype R] [CommRing R] [IsReduced R] [Char_p R 2] (a : R) : IsSquare a
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [SemiNormedGroup F'] {f : α → E} {g' : α → F'} {l : Filter α} : f =O[l] g' ↔ ∀ᶠ (c : ℝ) in filter.at_Top, ∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g' x∥
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} (K : ι → Submodule 𝕜 E) : (⨅ (i : ι), (K i)ᗮ) = (supr K)ᗮ
{R : Type u} {K : Type v} {L : Type z} {p : R} [CommRing R] [Field K] [Field L] [Algebra K L] [Algebra R L] [Algebra R K] [IsScalarTower R K L] [IsSeparable K L] [is_IsDomain R] [NormalizedGcdMonoid R] [IsFractionRing R K] [IsIntegrallyClosed R] {B : PowerBasis K L} (hp : Prime p) (hBint : IsIntegral R B.gen) {n : ℕ} {z : L} (hzint : IsIntegral R z) (hz : p ^ n • z ∈ Algebra.adjoin R {B.gen}) (hei : (minpoly R B.gen).is_eisenstein_at (Submodule.span R {p})) : z ∈ Algebra.adjoin R {B.gen}
{α : Type u} {β : Type v} [PseudoMetricSpace α] {f : β → α} : Metric.Bounded (Set.Range f) ↔ ∃ (C : ℝ), ∀ (x y : β), HasDist.dist (f x) (f y) ≤ C
{R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) (k : ℕ) : M ^ k = ⇑(Polynomial.aeval M) (Polynomial.x ^ k %ₘ M.charpoly)
{α : Type u_1} [LinearOrder α] [DecidableEq α] {p : Finset α → Prop} (s : Finset α) (h0 : p ∅) (step : ∀ (a : α) (s : Finset α), (∀ (x : α), x ∈ s → a < x) → p s → p (HasInsert.insert a s)) : p s
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasFiniteCoproducts C] [CategoryTheory.Limits.HasCokernels C] [CategoryTheory.NormalEpiCategory C] {X Y : C} (f g : X ⟶ Y) : CategoryTheory.Limits.HasColimit (Category_theory.limits.parallel_pair f g)
{k : Type u_1} {V : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] [FiniteDimensional k V] [Fintype ι] {p : ι → P} (hi : AffineIndependent k p) : affine_Span k (Set.Range p) = ⊤ ↔ Fintype.card ι = FiniteDimensional.finrank k V + 1
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (p1 p2 : P) (hp1p2 : p1 ≠ p2) : EuclideanGeometry.angle p1 (midpoint ℝ p1 p2) p2 = Real.pi
(M : Type u_1) (α : Type u_2) [Monoid M] [MulAction M α] {P Q : Submonoid M} : MulAction.FixedPoints ↥(P ⊔ Q) α = MulAction.FixedPoints ↥P α ∩ MulAction.FixedPoints ↥Q α
{M : Type u_1} [GroupWithZero M] : Set.Center Mˣ = Coe ⁻¹' Set.Center M
{α : Type u} {n : ℕ} (f : Fin n → α) (i : ℕ) : (list.of_fn f).nth i = list.of_fn_nth_val f i
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : ∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * ⇑is_R_or_C.re (HasInner.inner x y) + ∥y∥ ^ 2
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : HasInner.inner x y / (∥x∥ * ∥y∥) = 1 ↔ x ≠ 0 ∧ ∃ (r : ℝ), 0 < r ∧ y = r • x
{ι : Type u} {X : Type v} [TopologicalSpace X] {s : Set X} [NormalSpace X] [ParacompactSpace X] (p : (X → ℝ) → Prop) (h01 : ∀ (s t : Set X), is_IsClosed s → is_IsClosed t → Disjoint s t → (∃ (f : C(X, ℝ)), p ⇑f ∧ Set.EqOn ⇑f 0 s ∧ Set.EqOn ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ Set.Icc 0 1)) (hs : is_IsClosed s) (U : ι → Set X) (ho : ∀ (i : ι), is_IsOpen (U i)) (hU : s ⊆ ⋃ (i : ι), U i) : ∃ (f : BumpCovering ι X s), (∀ (i : ι), p ⇑(⇑f i)) ∧ f.is_subordinate U
{α : Type u_1} {β : Type u_2} {f : α →. β ⊕ α} (a a' : α) (ha' : Sum.inr a' ∈ f a) : f.fix a = f.fix a'
{α : Type u_1} [TopologicalSpace α] [t2_Space α] {f : α → α} (hF : Continuous f) : is_IsClosed (Function.FixedPoints f)
{s : Set ℝ} : IsPreconnected s → Convex ℝ s
{f₁ f₂ : Circle_deg1_Liftˣ} (h : ↑f₁.translation_number = ↑f₂.translation_number) : ∃ (F : Circle_deg1_Lift), Function.Semiconj ⇑F ⇑f₁ ⇑f₂
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] (f : M →+ P) {x y : M} : ⇑(AddCon.ker f) x y ↔ ⇑f x = ⇑f y
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) {X Y : C} (p : X = Y) : F.map (Category_theory.eq_to_hom p) = Category_theory.eq_to_hom _
{α : Type u_3} [SemilatticeSup α] (a : α) : filter.at_Top = Filter.comap Coe filter.at_Top
{α : Type u_1} [NormedRing α] [CompleteSpace α] {f g : ℕ → α} (hF : Summable (λ (x : ℕ), ∥f x∥)) (hg : Summable (λ (x : ℕ), ∥g x∥)) : (∑' (n : ℕ), f n) * ∑' (n : ℕ), g n = ∑' (n : ℕ), (Finset.range (n + 1)).sum (λ (k : ℕ), f k * g (n - k))
 : Filter.Tendsto (λ (n : ℕ), (Finset.range n).sum (λ (i : ℕ), 1 / (↑i + 1))) filter.at_Top filter.at_Top
{M : Type u_1} [CancelCommMonoidWithZero M] [DecidableEq M] [UniqueFactorizationMonoid M] [Unique Mˣ] (x : M) : UniqueFactorizationMonoid.factors x = Unique_factorization_monoid.normalized_Factors x
{α : sort u_1} {β : Type u_2} {γ : sort u_3} [DecidableEq β] (g : β → γ) {f : α → β} {i : β} (a : γ) (h : i ∉ Set.Range f) : Function.update g i a ∘ f = g ∘ f
{𝕂 : Type u_1} {𝔸 : Type u_2} {𝔹 : Type u_3} [NondiscreteNormedField 𝕂] [NormedRing 𝔸] [NormedRing 𝔹] [NormedAlgebra 𝕂 𝔸] [NormedAlgebra 𝕂 𝔹] [CompleteSpace 𝔸] {F : Type u_4} [RingHomClass F 𝔸 𝔹] (f : F) (hF : Continuous ⇑f) (x : 𝔸) (hx : x ∈ Emetric.Ball 0 (Exp_series 𝕂 𝔸).radius) : ⇑f (Exp 𝕂 x) = Exp 𝕂 (⇑f x)
{s : Set ℝ} : Convex ℝ s → IsPreconnected s
{α : Type u_3} {β : Type u_4} [Nonempty α] [SemilatticeSup α] [Preorder β] {f : α → β} : Filter.Tendsto f filter.at_Top filter.at_Top ↔ ∀ (b : β), ∃ (i : α), ∀ (a : α), i ≤ a → b ≤ f a
{R : Type u} [NonAssocSemiring R] {S T : Subsemiring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) : S = T
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] {v : ℝ → E → E} {t_min t₀ t_max : ℝ} (ht₀ : t₀ ∈ Set.Icc t_min t_max) (x₀ : E) {C R : ℝ} (hR : 0 ≤ R) {L : Nnreal} (Hlip : ∀ (t : ℝ), t ∈ Set.Icc t_min t_max → LipschitzOnWith L (v t) (Metric.ClosedBall x₀ R)) (Hcont : ∀ (x : E), x ∈ Metric.ClosedBall x₀ R → ContinuousOn (λ (t : ℝ), v t x) (Set.Icc t_min t_max)) (Hnorm : ∀ (t : ℝ), t ∈ Set.Icc t_min t_max → ∀ (x : E), x ∈ Metric.ClosedBall x₀ R → ∥v t x∥ ≤ C) (hMul_LE : C * Linear_order.max (t_max - t₀) (t₀ - t_min) ≤ R) : ∃ (f : ℝ → E), f t₀ = x₀ ∧ ∀ (t : ℝ), t ∈ Set.Icc t_min t_max → HasDerivWithinAt f (v t (f t)) (Set.Icc t_min t_max) t
{s : Set ℝ} (h : Metric.Bounded s) : Metric.diam s = HasSup.sup s - HasInf.inf s
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsFiltered C] {j₁ j₂ j₃ k₁ k₂ l : C} (f₁ : j₁ ⟶ k₁) (f₂ : j₂ ⟶ k₁) (f₃ : j₂ ⟶ k₂) (f₄ : j₃ ⟶ k₂) (g₁ : j₁ ⟶ l) (g₂ : j₃ ⟶ l) : ∃ (s : C) (α : k₁ ⟶ s) (β : l ⟶ s) (γ : k₂ ⟶ s), f₁ ≫ α = g₁ ≫ β ∧ f₂ ≫ α = f₃ ≫ γ ∧ f₄ ≫ γ = g₂ ≫ β
{β : Type u} {α : Type v} [CommMonoid β] [DecidableEq α] (s : Finset α) (f : α → β) {a : α} (h : a ∈ s) : f a * (s.erase a).prod (λ (x : α), f x) = s.prod (λ (x : α), f x)
{ι : Type u_1} {B : Type u_2} {F : Type u_3} [TopologicalSpace B] [TopologicalSpace F] (Z : TopologicalFiberBundleCore ι B F) : IsTopologicalFiberBundle F Z.proj
{α : Type u_1} [HasLe α] {a b : α} : b ≤ a → ⇑order_dual.to_dual a ≤ ⇑order_dual.to_dual b
{α : Type u} [PseudoMetricSpace α] (x y : UniformSpace.Completion α) (h : HasDist.dist x y = 0) : x = y
{β : Type v} {δ : Type u_2} [TopologicalSpace β] [TopologicalSpace δ] {α : Type u_1} {γ : Type u_3} (f : α → β) (g : γ → δ) : prod.topological_Space = TopologicalSpace.induced (λ (p : α × γ), (f p.fst, g p.snd)) prod.topological_Space
(x : Pgame) : (0 * x).equiv 0
{α : Type u} {β : α → Type u} [Π (a : α), Fintype (β a)] : Cardinal.mk (W_Type β) ≤ Linear_order.max (Cardinal.mk α) Cardinal.aleph_0
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E] {x : E} {s : Set E} (hs : s ∈ nhds x) : ∃ (f : E → ℝ), f =ᶠ[nhds x] 1 ∧ (∀ (y : E), f y ∈ Set.Icc 0 1) ∧ ContDiff ℝ ⊤ f ∧ HasCompactSupport f ∧ Tsupport f ⊆ s
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {v : M} (h : v ≠ 0) {r : R} (hr : 0 < r) (hrv : r • v ≠ 0) : Ray_of_NeZero R (r • v) hrv = Ray_of_NeZero R v h
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {G : C ⥤ D} (H : CategoryTheory.CoverDense K G) [CategoryTheory.Full G] {ℱ : Dᵒᵖ ⥤ Type v} {ℱ' : CategoryTheory.SheafOfTypes K} (α : G.op ⋙ ℱ ⟶ G.op ⋙ ℱ'.val) {X : D} (x : ℱ.obj (Opposite.op X)) : (Category_theory.cover_dense.types.pushforward_family H α x).compatible
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMaxOrder α] {a : α} {s : Set α} : s ∈ nhds_within a (Set.Ioi a) ↔ ∃ (u : α) (H : u ∈ Set.Ioi a), Set.Ioo a u ⊆ s
{ι : Type u_1} {R : Type u_8} [CanonicallyOrderedCommSemiring R] [Nontrivial R] [DecidableEq R] {s : Finset ι} {f : ι → WithTop R} (h : ∀ (i : ι), i ∈ s → f i ≠ ⊤) : s.prod (λ (i : ι), f i) < ⊤
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_4} [DecidableEq ι] [Fintype ι] (e : Basis ι R M) (w : ι → Rˣ) : ⇑(e.det) ⇑(e.units_Smul w) = finset.univ.prod (λ (i : ι), ↑(w i))
(H : Type u) (M : Type u_2) [TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M] [LocallyCompactSpace H] : LocallyCompactSpace M
{a b : Prop} : ¬(a ∨ b) ↔ ¬a ∧ ¬b
{g : Matrix.SpecialLinearGroup (Fin 2) ℤ} {z : UpperHalfPlane} (hz : z ∈ ModularGroup.Fdo) (hg : g • z ∈ ModularGroup.Fdo) : z = g • z
{β : Type u} {α : Type v} [CommMonoid β] [DecidableEq α] (s : Finset α) (a : α) (b : α → β) : s.prod (λ (x : α), Ite (x = a) (b x) 1) = Ite (a ∈ s) (b a) 1
{R : Type u_1} {A : Type u_2} [CommSemiring R] [Semiring A] [Algebra R A] [NoZeroDivisors A] (h : Function.Injective ⇑(Algebra_Map R A)) : NoZeroSmulDivisors R A
{ι : Type v} (f : ι → Cardinal) : (Cardinal.sup f).lift = Cardinal.sup (λ (i : ι), (f i).lift)
{X Y Z : AlgebraicGeometry.Scheme} (𝒰 : X.open_cover) (f : X ⟶ Z) (g : Y ⟶ Z) [∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (𝒰.map i ≫ f) g] (i : 𝒰.J) : CategoryTheory.Limits.pullback.lift CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst ≫ algebraic_geometry.Scheme.pullback.p2 𝒰 f g) _ ≫ (AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).ι i = CategoryTheory.Limits.pullback.fst
{α : Type u_1} (L : List (List α)) {i j : ℕ} (hi : i < L.length) (hj : j < (L.nth_LE i hi).length) : L.join.nth_LE ((List.take i (List.map List.length L)).sum + j) _ = (L.nth_LE i hi).nth_LE j hj
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [SemiNormedGroup E'] {g : α → F} {f' : α → E'} {l : Filter α} : (λ (x : α), -f' x) =O[l] g → f' =O[l] g
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {L₁ L₂ : C ⥤ D} {R₁ R₂ : D ⥤ C} (Adj₁ : L₁ ⊣ R₁) (Adj₂ : L₂ ⊣ R₂) (f : R₁ ⟶ R₂) [CategoryTheory.IsIso (⇑((Category_theory.transfer_NatTrans_self Adj₁ Adj₂).symm) f)] : CategoryTheory.IsIso f
{x y : Game} : ¬x.lf y ↔ y ≤ x
{α : Type u_1} [DecidableEq α] {𝒜 : Finset (Finset α)} {r : ℕ} (h𝒜 : Set.Sized r ↑𝒜) : Set.Sized (r - 1) ↑(𝒜.shadow)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] {K' : Submodule 𝕜 E} [CompleteSpace ↥K'] (h : K = K') (u : E) : ↑(⇑(Orthogonal_projection K) u) = ↑(⇑(Orthogonal_projection K') u)
{M : Type u_1} [AddMonoid M] {s : Set M} (hs : IsAddSubmonoid s) {l : List M} : (∀ (x : M), x ∈ l → x ∈ s) → l.sum ∈ s
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (p : P) (ps : Set P) : affine_Span k (HasInsert.insert p ↑(affine_Span k ps)) = affine_Span k (HasInsert.insert p ps)
{k : Type u_1} {G : Type u_2} {V : Type u_3} [CommRing k] [Group G] [AddCommGroup V] [Module k V] (ρ : Representation k G V) (g h : G) : ρ.character (h * g * h⁻¹) = ρ.character g
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : Set P} (h : s.finite) : FiniteDimensional k ↥(Vector_Span k s)
{α : Type u_1} [MeasurableSpace α] (m₁ m₂ : MeasureTheory.OuterMeasure α) : (m₁ + m₂).trim = m₁.trim + m₂.trim
{α : Type u_1} {β : Type u_2} {s : Finset α} {t : Finset β} (hc : t.card < s.card) {f : α → β} (hF : ∀ (a : α), a ∈ s → f a ∈ t) : ∃ (x : α) (H : x ∈ s) (y : α) (H : y ∈ s), x ≠ y ∧ f x = f y
{R : Type u_1} {M : Type u_2} [Ring R] [AddCommGroup M] [Module R M] [IsArtinian R M] (f : M →ₗ[R] M) (s : Function.Injective ⇑f) : Function.Surjective ⇑f
{C : Type u_1} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] {X : CategoryTheory.SimplicialObject C} (q : ℕ) : (algebraic_topology.dold_kan.Hσ q).f 0 = 0
{α : Type u_1} {β : Type u_2} {s s₁ : Set α} {t t₁ : Set β} : s ×ˢ t ⊆ s₁ ×ˢ t₁ ↔ s ⊆ s₁ ∧ t ⊆ t₁ ∨ s = ∅ ∨ t = ∅
{R : Type u_1} {S : Type u_2} [CommSemiring R] [CommSemiring S] [H : LocalRing S] (f : R →+* S) [is_IsLocalRingHom f] : LocalRing R
{f : ℕ →₀ ℕ} (hF : 0 ∉ f.support) : 0 < f.prod has_pow.pow
(s : ℝ) (hs : 1 < s) : MeasureTheory.IntegrableOn (λ (x : ℝ), ∥Real.exp (-x) * Real.log x * x ^ (s - 1)∥) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume
{β : Type u} {α : Type v} {γ : Type w} [AddCommMonoid β] {s : Finset γ} {t : Finset α} {f : γ → α → β} : (s.product t).sum (λ (x : γ × α), f x.fst x.snd) = t.sum (λ (y : α), s.sum (λ (x : γ), f x y))
{z : UpperHalfPlane} (h : 1 < ⇑complex.norm_sq ↑z) : ⇑complex.norm_sq ↑(ModularGroup.s • z) < 1
{A : Type u_1} [NormedRing A] [NormedAlgebra ℂ A] [CompleteSpace A] [StarRing A] [CstarRing A] [StarModule ℂ A] [Nontrivial A] {a : A} (ha : a ∈ IsSelfAdjoint A) {z : ℂ} (hz : z ∈ Spectrum ℂ a) : z = ↑(z.re)
{R : Type u_1} {M : Type u_9} {ι : Type u_17} [Semiring R] [AddCommMonoid M] [Module R M] [Fintype ι] [DecidableEq ι] (f : (ι → R) →ₗ[R] M) (x : ι → R) : ⇑f x = finset.univ.sum (λ (i : ι), x i • ⇑f (λ (j : ι), Ite (i = j) 1 0))
{α : Type u_1} {β : Type u_2} [UniformSpace β] {f : α → β} {s : Set α} [TopologicalSpace α] (L : ∀ (x : α), x ∈ s → ∀ (u : Set (β × β)), u ∈ Uniformity β → (∃ (t : Set α) (H : t ∈ nhds_within x s) (F : α → β), ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u)) : ContinuousOn f s
{α : Type u_1} [TopologicalSpace α] [BaireSpace α] {S : Set (Set α)} (ho : ∀ (s : Set α), s ∈ S → is_Gδ s) (hS : S.countable) (hD : ∀ (s : Set α), s ∈ S → Dense s) : Dense (⋂₀ S)
{R : Type u_2} [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R] [Nontrivial R] [NormalizationMonoid R] [DecidableEq R] {p x : R} (hp : Irreducible p) (hnorm : ⇑normalize p = p) {n : ℕ} (hle : p ^ n ∣ x) (hlt : ¬p ^ (n + 1) ∣ x) : Multiset.count p (Unique_factorization_monoid.normalized_Factors x) = n
{α : Type u_1} [PartialOrder α] {f : α → α} {p : α → Prop} {hF : ∀ (x : α), x ≤ f x} {hfp : ∀ (x : α), p (f x)} {hmin : ∀ ⦃x y : α⦄, x ≤ y → p y → f x ≤ y} (x : α) : p (⇑(ClosureOperator.mk₃ f p hF hfp hmin) x)
{m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (e : n ≃ m) (A : Matrix m m R) : (A.minor ⇑e ⇑e).det = A.det
{X : Type u_2} [EmetricSpace X] [MeasurableSpace X] [BorelSpace X] {β : Type u_1} {ι : β → Type u_3} [hι : Π (n : β), Fintype (ι n)] (s : Set X) {l : Filter β} (r : β → Ennreal) (hr : Filter.Tendsto r l (nhds 0)) (t : Π (n : β), ι n → Set X) (ht : ∀ᶠ (n : β) in l, ∀ (i : ι n), Emetric.diam (t n i) ≤ r n) (hst : ∀ᶠ (n : β) in l, s ⊆ ⋃ (i : ι n), t n i) (m : Ennreal → Ennreal) : ⇑(measure_theory.measure.mk_metric m) s ≤ l.liminf (λ (n : β), finset.univ.sum (λ (i : ι n), m (Emetric.diam (t n i))))
{𝕜 : Type u_1} [NormedField 𝕜] [CompleteSpace 𝕜] {r : 𝕜} (hr : ∥r∥ < 1) : ∑' (n : ℕ), ↑n * r ^ n = r / (1 - r) ^ 2
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : ℕ} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : ⇑fin.cast_Succ j < i) : X.σ (⇑fin.cast_Succ j) ≫ X.δ i.succ = X.δ i ≫ X.σ j
{k : Type u₁} {G : Type u₂} {R : Type u_1} [Semiring k] [AddMonoid G] [Semiring R] {f g : AddMonoidAlgebra k G →+* R} (h₁ : f.comp AddMonoid_algebra.single_Zero_RingHom = g.comp AddMonoid_algebra.single_Zero_RingHom) (h_of : ↑f.comp (AddMonoidAlgebra.of k G) = ↑g.comp (AddMonoidAlgebra.of k G)) : f = g
{R : Type u_1} {a : R} [MulZeroClass R] [Nontrivial R] (la : IsLeftRegular a) : a ≠ 0
{α : Type u_1} [ConditionallyCompleteLattice α] {s t : Set α} (hs : BddBelow s) (sne : s.nonempty) (ht : BddBelow t) (tne : t.nonempty) : HasInf.inf (s ∪ t) = HasInf.inf s ⊓ HasInf.inf t
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [SemiNormedGroup E'] {c : ℝ} {g : α → F} {f' : α → E'} {l : Filter α} : asymptotics.is_O_with c l f' g → asymptotics.is_O_with c l (λ (x : α), ∥f' x∥) g
{ι : Type u_1} {R : Type u_2} {N : Type u_5} [decι : DecidableEq ι] [Semiring R] [AddCommMonoid N] [Module R N] (p : ι → Prop) [DecidablePred p] (S : ι → Submodule R N) : (⨆ (i : ι) (h : p i), S i) = ((⇑(Dfinsupp.lsum ℕ) (λ (i : ι), (S i).subtype)).comp (dfinsupp.filter_Linear_Map R (λ (i : ι), ↥(S i)) p)).range
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {a₁ a₂ : α} {b₁ b₂ : β} (q₁ : Path.Homotopic.Quotient a₁ a₂) (q₂ : Path.Homotopic.Quotient b₁ b₂) : Path.Homotopic.proj_Left (Path.Homotopic.prod q₁ q₂) = q₁
{ι : Type u_1} {N : Type u_5} [decι : DecidableEq ι] [AddCommGroup N] (p : ι → AddSubgroup N) : CompleteLattice.Independent p ↔ Function.Injective ⇑(dfinsupp.sum_AddHom (λ (i : ι), (p i).subtype))
{G : Type u_7} [CommGroup G] (L : List G) : (L.prod)⁻¹ = (List.map (λ (x : G), x⁻¹) L).prod
(α : Type u_1) : Subsingleton α ∨ Nontrivial α
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s1 s2 : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 ∈ s1) (hp2 : p2 ∈ s2) : (s1 ⊔ s2).direction = s1.direction ⊔ s2.direction ⊔ Submodule.span k {p2 -ᵥ p1}
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {F : J ⥤ C} {X : C} (h : Category_theory.yoneda.obj X ⋙ Category_theory.ulift_Functor ≅ F.cones) (s : CategoryTheory.Limits.Cone F) : (Category_theory.limits.is_limit.of_Nat_iso.limit_cone h).extend (Category_theory.limits.is_limit.of_Nat_iso.hom_of_cone h s) = s
{Fq : Type u_1} [Fintype Fq] [Ring Fq] {d m : ℕ} (hm : Fintype.card Fq ^ d ≤ m) (b : Polynomial Fq) (A : Fin m.succ → Polynomial Fq) (hA : ∀ (i : Fin m.succ), (A i).degree < b.degree) : ∃ (i₀ i₁ : Fin m.succ), i₀ ≠ i₁ ∧ (A i₁ - A i₀).degree < ↑(b.nat_degree - d)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s u : Set E} {f : E → F} {x : E} {n : ℕ} (hu : u ∈ nhds x) (hs : UniqueDiffOn 𝕜 s) (xs : x ∈ s) : iterated_fderiv_within 𝕜 n f (s ∩ u) x = iterated_fderiv_within 𝕜 n f s x
 : ContMdiff (model_with_corners_self ℝ ℝ) (model_with_corners_self ℝ (EuclideanSpace ℝ (Fin 1))) ⊤ ⇑Exp_Map_Circle
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F ≠ 2) {a : F} (ha : a ≠ 0) : char.quadratic_Char F a = Ite (a ^ (Fintype.card F / 2) = 1) 1 (-1)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {x : E} {n : WithTop ℕ} {f : E → 𝕜} {g : E → F} (hF : ContDiffAt 𝕜 n f x) (hg : ContDiffAt 𝕜 n g x) : ContDiffAt 𝕜 n (λ (x : E), f x • g x) x
{R : Type u} {S : Type v} [NonAssocSemiring R] [NonAssocSemiring S] (f : R →+* S) (hF : Function.Surjective ⇑f) : f.srange = ⊤
(𝕂 : Type u_1) (𝕂' : Type u_2) (𝔸 : Type u_3) [Field 𝕂] [Field 𝕂'] [Ring 𝔸] [Algebra 𝕂 𝔸] [Algebra 𝕂' 𝔸] [TopologicalSpace 𝔸] [TopologicalRing 𝔸] (n : ℕ) (x : 𝔸) : ⇑(Exp_series 𝕂 𝔸 n) (λ (_x : Fin n), x) = ⇑(Exp_series 𝕂' 𝔸 n) (λ (_x : Fin n), x)
{E : Type u_1} {F : Type u_2} [InnerProductSpace ℝ E] [InnerProductSpace ℝ F] (f : E →L[ℝ] F) : IsConformalMap f ↔ ∃ (c : ℝ), 0 < c ∧ ∀ (u v : E), HasInner.inner (⇑f u) (⇑f v) = c * HasInner.inner u v
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {m : α → β → γ} {f : Filter α} {g : Filter β} {n : γ → δ} {m' : β → α' → δ} {n' : α → α'} (h_antidistrib : ∀ (a : α) (b : β), n (m a b) = m' b (n' a)) : Filter.map n (Filter.map₂ m f g) = Filter.map₂ m' g (Filter.map n' f)
{p n : ℕ} (n_big : 2 < n) (p_LE_n : p ≤ n) (big : 2 * n < 3 * p) : ⇑(n.central_binom.factorization) p = 0
{ι : Type u_1} {α : ι → Type u_2} [DecidableEq ι] [Π (i : ι), LinearOrder (α i)] (x y z : Π (i : ι), α i) : Set.Icc x z  set.univ.pi (λ (i : ι), Set.Ioc (y i) (z i)) ⊆ ⋃ (i : ι), Set.Icc x (Function.update z i (y i))
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} (h : InnerProductGeometry.angle x y = Real.pi) : ∥x - y∥ = ∥x∥ + ∥y∥
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : α → β} : Monotone f → Antitone (⇑order_dual.to_dual ∘ f)
{R : Type u_1} [LinearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] (u : Rˣ) (v : Module.Ray R M) : u⁻¹ • v = u • v
{α : Type u_1} {β : Type u_2} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] {s : Set β} : is_IsCompact s → s.nonempty → ∀ {f : β → α}, ContinuousOn f s → (∃ (x : β) (H : x ∈ s), ∀ (y : β), y ∈ s → f y ≤ f x)
{α : Type u_1} [TopologicalSpace α] [PolishSpace α] {s : Set α} (hs : is_IsOpen s) : PolishSpace ↥s
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasZeroMorphisms C] {X : C} (f : 0 ⟶ X) : f = 0
{R : Type u_1} [CommRing R] {c₁ c₂ : R} (c : CliffordAlgebra (CliffordAlgebraQuaternion.q c₁ c₂)) : ⇑CliffordAlgebra_quaternion.to_Quaternion (⇑CliffordAlgebra.involute (⇑CliffordAlgebra.reverse c)) = ⇑QuaternionAlgebra.conj (⇑CliffordAlgebra_quaternion.to_Quaternion c)
(p : ℕ) (a : Zmod p) (ha : a ^ (p - 1) = 1) (hD : ∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) : Nat.Prime p
{X Y : Profinite} (f : X ⟶ Y) : IsClosedMap ⇑f
{V₁ : Type u_2} {V₂ : Type u_3} [SemiNormedGroup V₁] [SemiNormedGroup V₂] (f : NormedGroupHom V₁ V₂) : LipschitzWith ⟨∥f∥, _⟩ ⇑f
{α : Type u} [PseudoMetricSpace α] {s : Set α} (h : ¬Metric.Bounded s) : Metric.diam s = 0
{R : Type u_1} {S : Type u_2} [CommRing R] [is_IsDomain R] [CommRing S] {L : Type u_3} [Field L] [Algebra R S] [Algebra S L] [Algebra R L] [IsScalarTower R S L] [is_IsIntegralClosure S R L] (h : Algebra.IsAlgebraic R L) (inj : Function.Injective ⇑(Algebra_Map R L)) (a : S) {b : S} (hb : b ≠ 0) : ∃ (c : S) (d : R) (H : d ≠ 0), d • a = b * c
{α : Type u_2} [Bornology α] {s : Set α} : Bornology.IsBounded s → Bornology.IsCobounded sᶜ
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] {a : α} (h : (Set.Ioi a).nonempty) : Closure (Set.Ioi a) = Set.Ici a
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [LinearOrderedAddCommMonoid β] [HasScalar 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f : E → β} (hF : StrictConvexOn 𝕜 s f) {x y : E} (hx : x ∈ s) (hy : y ∈ s) (hxy : x ≠ y) {a b : 𝕜} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : f (a • x + b • y) < Linear_order.max (f x) (f y)
{α : Type v} {s : Finset α} {M : Type u_1} [CommMonoid M] (f : α → M) (p : M → Prop) (p_Mul : ∀ (a b : M), p a → p b → p (a * b)) (p_One : p 1) (p_s : ∀ (x : α), x ∈ s → p (f x)) : p (s.prod (λ (x : α), f x))
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [LinearOrderedField 𝕜] [AddCommGroup E] [OrderedAddCommGroup β] [Module 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f : E → β} {t : Finset ι} {w : ι → 𝕜} {p : ι → E} (hF : ConcaveOn 𝕜 s f) (h₀ : ∀ (i : ι), i ∈ t → 0 ≤ w i) (h₁ : 0 < t.sum (λ (i : ι), w i)) (hmem : ∀ (i : ι), i ∈ t → p i ∈ s) : t.center_mass w (f ∘ p) ≤ f (t.center_mass w p)
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : α → β} : StrictAnti f → StrictMono (⇑order_dual.to_dual ∘ f)
{G : Type u_3} [AddGroup G] : Add_group.fg G ↔ Add_monoid.fg G
{J : Type u₁} [CategoryTheory.Category J] {K : Type u₂} [CategoryTheory.Category K] {C : Type u} [CategoryTheory.Category C] {F : J ⥤ C} [CategoryTheory.Limits.HasLimit F] {E : K ⥤ J} [CategoryTheory.Limits.HasLimit (E ⋙ F)] (s : CategoryTheory.Limits.LimitCone (E ⋙ F)) (t : CategoryTheory.Limits.LimitCone F) : CategoryTheory.Limits.limit.pre F E = (Category_theory.limits.limit.iso_LimitCone t).hom ≫ s.is_limit.lift (CategoryTheory.Limits.Cone.whisker E t.cone) ≫ (Category_theory.limits.limit.iso_LimitCone s).inv
{G : Type w} [TopologicalSpace G] [Group G] [TopologicalGroup G] {M : Type u_1} {hom : Type u_2} [MulOneClass M] [TopologicalSpace M] [HasContinuousMul M] [MonoidHomClass hom G M] (f : hom) (hF : ContinuousAt ⇑f 1) : Continuous ⇑f
{M : Type u_1} [SemiNormedGroup M] (S : AddSubgroup M) (m : M) : ⇑(S.normed_Mk) m = ⇑(QuotientAddGroup.mk' S) m
{α : Type u_1} {n : Type u_4} {m : Type u_5} [MulZeroClass α] {A : Matrix m m α} {B : Matrix n n α} (hA : A.is_diag) (hB : B.is_diag) : (matrix.kronecker_Map has_mul.mul A B).is_diag
{𝕂 : Type u_1} [NondiscreteNormedField 𝕂] [CompleteSpace 𝕂] (h : 0 < (Exp_series 𝕂 𝕂).radius) : HasDerivAt (Exp 𝕂) 1 0
{ι : Type u_1} {ι' : Type u_2} {α : Type u_3} [Fintype ι] [Preorder ι'] [IsDirected ι' (Function.swap has_le.le)] [Nonempty ι'] {s : ι → ι' → Set α} (hs : ∀ (i : ι), Antitone (s i)) : (⋃ (j : ι'), ⋂ (i : ι), s i j) = ⋂ (i : ι), ⋃ (j : ι'), s i j
{G : Type u_1} [AddGroup G] {ι : sort u_2} (S : ι → AddSubgroup G) {C : Π (x : G), (x ∈ ⨆ (i : ι), S i) → Prop} (hp : ∀ (i : ι) (x : G) (H : x ∈ S i), C x _) (h1 : C 0 _) (hMul : ∀ (x y : G) (hx : x ∈ ⨆ (i : ι), S i) (hy : y ∈ ⨆ (i : ι), S i), C x hx → C y hy → C (x + y) _) {x : G} (hx : x ∈ ⨆ (i : ι), S i) : C x hx
{α : Type u} {β : Type v} {t : Set β} {f : α → β} (h : ∀ (x : α), f x ∈ t) : Function.Injective f → Function.Injective (set.cod_Restrict f t h)
{V : Type u} {G : SimpleGraph V} [DecidableEq V] {u v w : V} (p : G.walk v w) (h : u ∈ p.support) : (p.take_until u h).append (p.drop_until u h) = p
{G : Type u_1} [Group G] {ι : Type u_2} (s : Finset ι) (f : ι → G) (comm : ∀ (x : ι), x ∈ s → ∀ (y : ι), y ∈ s → Commute (f x) (f y)) (K : ι → Subgroup G) (hind : CompleteLattice.Independent K) (hmem : ∀ (x : ι), x ∈ s → f x ∈ K x) (HEq1 : s.noncomm_Prod f comm = 1) (i : ι) (H : i ∈ s) : f i = 1
(u : Pnat.XgcdType) : u.r + (u.bp + 1) * u.q = u.ap + 1
{β α : Type u} (f : β → α) (h₁ : Cardinal.aleph_0 ≤ Cardinal.mk β) (h₂ : Cardinal.mk α < (Cardinal.mk β).ord.cof) : ∃ (a : α), Cardinal.mk ↥(f ⁻¹' {a}) = Cardinal.mk β
{ι : Type u_1} {M : Type u_4} {N : Type u_5} [CommMonoid M] [OrderedCommMonoid N] (f : M → N) (p : M → Prop) (h_Mul : ∀ (x y : M), p x → p y → f (x * y) ≤ f x * f y) (hp_Mul : ∀ (x y : M), p x → p y → p (x * y)) (g : ι → M) (s : Finset ι) (hs_Nonempty : s.nonempty) (hs : ∀ (i : ι), i ∈ s → p (g i)) : f (s.prod (λ (i : ι), g i)) ≤ s.prod (λ (i : ι), f (g i))
{α : Type u} [PseudoMetricSpace α] {s : Set α} (h : s.finite) : Metric.Bounded s
{R : Type u} [Semiring R] [NoZeroDivisors R] [Nontrivial R] (l : List (Polynomial R)) : l.prod.degree = (List.map Polynomial.degree l).sum
(f : Type u₀ → Type u₁) [EquivFunctor f] {α β γ : Type u₀} (Ab : α ≃ β) (bc : β ≃ γ) : (Equiv_functor.map_Equiv f Ab).trans (Equiv_functor.map_Equiv f bc) = Equiv_functor.map_Equiv f (ab.trans bc)
{R : Type u_1} (M : Type u_3) [Monoid R] [MulAction R M] : IsSmulRegular M 1
{C : Type u} [CategoryTheory.Category C] (s : Set (CategoryTheory.GrothendieckTopology C)) : IsGlb s (HasInf.inf s)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {m n : WithTop ℕ} {f : E → F} (hF : ContDiff 𝕜 n f) (hmn : m + 1 ≤ n) : ContDiff 𝕜 m (λ (p : E × E), ⇑(fderiv 𝕜 f p.fst) p.snd)
{α : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [HasZero M] [CommMonoid N] [CommMonoid P] (h : N →* P) (f : α →₀ M) (g : α → M → N) : ⇑h (f.prod g) = f.prod (λ (a : α) (b : M), ⇑h (g a b))
{α : Type u_1} {l : Filter α} {f : α → ℝ} : ((λ (x : α), 1) =O[l] λ (x : α), Real.exp (f x)) ↔ Filter.IsBoundedUnder GE l f
{L : FirstOrder.Language} (T : L.Theory) (κ : Cardinal) (M : Type w') [L.Structure M] [M ⊨ T] [Infinite M] : ∃ (N : T.Model), κ.lift ≤ Cardinal.mk ↥N
{E : Type u_1} [SemiNormedGroup E] {s : AddSubgroup E} (x : ↥s) : ∥x∥ = ∥↑x∥
{E : Type u_1} [SemiNormedGroup E] [NormedSpace ℝ E] (p : Subspace ℝ E) (f : ↥p →L[ℝ] ℝ) : ∃ (g : E →L[ℝ] ℝ), (∀ (x : ↥p), ⇑g ↑x = ⇑f x) ∧ ∥g∥ = ∥f∥
{α : Type u_1} {β : Type u_2} {r : Setoid α} (f : α → β) (H : ∀ (x y : α), r.rel x y → f x = f y) (h : Function.Injective (Quotient.lift f H)) : setoid.ker f = r
{α : Type u} [PseudoEmetricSpace α] {s t : Set α} (hs : is_IsClosed s) (ht : is_IsClosed t) : emetric.Hausdorff_edist s t = 0 ↔ s = t
{α : Type u_1} {r : α → α → Prop} [IsRefl α r] {x y : α} : x ≠ y → r x y ↔ r x y
(Γ₀ : Type u_1) [LinearOrderedCommGroupWithZero Γ₀] : has_pure.pure ≤ LinearOrderedCommGroup_with_zero.nhds_fun Γ₀
{n : ℕ} {α : Fin (n + 1) → Type u} : Function.Injective2 fin.cons
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle (-x) y + o.oangle (-y) z + o.oangle (-z) x = ↑Real.pi
{G : Type u_2} [Group G] {a b : G} : a = b → a / b = 1
{α : Type u} [Preorder α] {a b c : α} : a ≤ b → b < c → a < c
{V₁ : Type u_1} {V₂ : Type u_2} [NormedGroup V₁] [NormedGroup V₂] {f : NormedGroupHom V₁ V₂} : ∥f∥ = 0 ↔ f = 0
{α : Type u} [AddCommGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] {a b c : α} : a - b < c → a < b + c
{S : Type u_2} [CommRing S] {K : Type u_4} [Field K] {F : Type u_6} [Field F] [Algebra K S] [Algebra K F] [Nontrivial S] (pB : PowerBasis K S) (hF : Polynomial.Splits (Algebra_Map K F) (minpoly K pb.gen)) : ⇑(Algebra_Map K F) (⇑(Algebra.trace K S) pb.gen) = (Polynomial.map (Algebra_Map K F) (minpoly K pb.gen)).roots.sum
{M : Type u_1} [AddZeroClass M] (S : AddSubmonoid M) : S = ⊥ ∨ ∃ (x : M) (H : x ∈ S), x ≠ 0
{t : ℂ} {s1 s2 x : ℝ} (ht1 : s1 ≤ t.re) (ht2 : t.re ≤ s2) (hx : 0 < x) : ∥dGamma_integrand t x∥ ≤ dGamma_integrand_Real s1 x + dGamma_integrand_Real s2 x
{M : Type u_1} [MulOneClass M] (s : Set M) {p : Π (x : M), x ∈ Submonoid.closure s → Prop} (Hs : ∀ (x : M) (h : x ∈ s), p x _) (H1 : p 1 _) (hMul : ∀ (x : M) (hx : x ∈ Submonoid.closure s) (y : M) (hy : y ∈ Submonoid.closure s), p x hx → p y hy → p (x * y) _) {x : M} (hx : x ∈ Submonoid.closure s) : p x hx
(R : Type u) [Ring R] [StrongRankCondition R] {ι : Type v} [Fintype ι] : FiniteDimensional.finrank R (ι →₀ R) = Fintype.card ι
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X ⟶ Y} (h₀ : f = g) {c : CategoryTheory.Limits.Fork f g} (h : CategoryTheory.Limits.IsLimit c) : CategoryTheory.IsIso c.ι
{R : Type u} [Semiring R] [NoZeroDivisors R] {p₁ p₂ q₁ q₂ : Polynomial R} (hp₁ : p₁ ≠ 0) (hq₁ : q₁ ≠ 0) (hp₂ : p₂ ≠ 0) (hq₂ : q₂ ≠ 0) (h_Eq : p₁ * q₂ = p₂ * q₁) : ↑(p₁.nat_degree) - ↑(q₁.nat_degree) = ↑(p₂.nat_degree) - ↑(q₂.nat_degree)
{ι : Type v} (f : ι → Cardinal) (t : Cardinal) (w : ∀ (i : ι), (f i).lift ≤ t) : (Cardinal.sup f).lift ≤ t
{α : Type u} [TopologicalSpace α] {x : α} {s : Set α} : ClusterPt x (Filter.principal s) ↔ ∀ (U : Set α), U ∈ nhds x → (U ∩ s).nonempty
{α : Type u} {β : Type v} [DecidableEq β] [Fintype α] [Fintype β] (f : α → β) {n : ℕ} (hn : Fintype.card α < Fintype.card β * n) : ∃ (y : β), (Finset.filter (λ (x : α), f x = y) Finset.univ).card < n
{ι : Type u} {β : ι → Type v} [Π (i : ι), HasZero (β i)] : Function.Injective Coe_fn
{G : Type u_1} [Group G] [TopologicalSpace G] [NonarchimedeanGroup G] {U : Set (G × G)} (hU : U ∈ nhds 1) : ∃ (V : OpenSubgroup G), ↑V ×ˢ ↑V ⊆ U
{M : Type u_1} [AddZeroClass M] {ι : sort u_2} (S : ι → AddSubmonoid M) {C : Π (x : M), (x ∈ ⨆ (i : ι), S i) → Prop} (hp : ∀ (i : ι) (x : M) (H : x ∈ S i), C x _) (h1 : C 0 _) (hMul : ∀ (x y : M) (hx : x ∈ ⨆ (i : ι), S i) (hy : y ∈ ⨆ (i : ι), S i), C x hx → C y hy → C (x + y) _) {x : M} (hx : x ∈ ⨆ (i : ι), S i) : C x hx
{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] {ι : Type u_3} {p : ι → Submodule R M} {m : M} : (m ∈ ⨆ (i : ι), p i) ↔ ∃ (s : Finset ι), m ∈ ⨆ (i : ι) (H : i ∈ s), p i
{M₀ : Type u_6} [MonoidWithZero M₀] {L : List M₀} (h : 0 ∈ L) : L.prod = 0
{R : Type u_1} [CommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_4} [DecidableEq ι] [Fintype ι] (e : Basis ι R M) (f : AlternatingMap R M R ι) : f = ⇑f ⇑e • e.det
{P : Type u_1} [SemilatticeInf P] {x y : P} {F : Order.Pfilter P} (hx : x ∈ F) (hy : y ∈ F) : x ⊓ y ∈ F
{M : Type u_1} [HasMul M] (c : Con M) {x y : M} : ⇑c x y → ⇑c y x
{E : Type u_1} {F : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [NormedGroup F] [NormedSpace ℝ F] {s : Set E} (s_conv : Convex ℝ s) (hne : (Interior s).nonempty) {f : E → F} {f' : E → (E →L[ℝ] F)} {f'' : E →L[ℝ] E →L[ℝ] F} (hF : ∀ (x : E), x ∈ Interior s → HasFderivAt f (f' x) x) {x : E} (xs : x ∈ s) (hx : HasFderivWithinAt f' f'' (Interior s) x) (v w : E) : ⇑(⇑f'' v) w = ⇑(⇑f'' w) v
{α : Type u} {β : Type v} (f : α → β) (g : β → α) : Set.BijOn g (Function.FixedPoints (f ∘ g)) (Function.FixedPoints (g ∘ f))
{R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [TopologicalSpace M] [TopologicalSpace M₂] [Ring R] [AddCommGroup M] [TopologicalAddGroup M] [Module R M] [AddCommGroup M₂] [Module R M₂] (e : M ≃L[R] M₂) (f : M →L[R] M₂) : f.inverse = (Ring.inverse (↑(e.symm).comp f)).comp ↑(e.symm)
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ : Real.Angle) : (o.rotation θ).symm = o.rotation (-θ)
{e : ℂ → ℂ} {e' : ℂ} {z : ℝ} (h : HasStrictDerivAt e e' ↑z) : HasStrictDerivAt (λ (x : ℝ), (e ↑x).re) e'.re z
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] : ContDiff 𝕜 ⊤ ⇑(equiv.prod_assoc E F G)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (f : E →L[𝕜] F) [CompleteSpace F] [CompleteSpace E] (surj : Function.Surjective ⇑f) : ∃ (C : ℝ) (H : C > 0), ∀ (y : F), ∃ (x : E), ⇑f x = y ∧ ∥x∥ ≤ C * ∥y∥
{R : Type u_4} {S : Type u_5} [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S] (f : R ≃+* S) : ⇑f 0 = 0
{n : ℕ} : Fin.succ_Equiv' 0 = Fin.succ_Equiv n
{R : Type u} [CommSemiring R] [StarRing R] (x : R) : ⇑(StarRing_end R) (⇑(StarRing_end R) x) = x
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {P : Type u_3} [CommMonoid P] (f : S.localization_Map N) {g : M →* P} {T : Submonoid P} (hy : ∀ (y : ↥S), ⇑g ↑y ∈ T) {Q : Type u_4} [CommMonoid Q] {k : T.localization_Map Q} (z : N) : ⇑(k.to_Map) (⇑g ↑((f.sec z).snd)) * ⇑(f.map hy k) z = ⇑(k.to_Map) (⇑g (f.sec z).fst)
{C : Type u} [CategoryTheory.Category C] {X : C} {S R : CategoryTheory.Sieve X} (J : CategoryTheory.GrothendieckTopology C) (Hss : S ≤ R) (sjx : S ∈ ⇑J X) : R ∈ ⇑J X
{K : Type u} [Field K] (s : Subfield K) {l : List K} : (∀ (x : K), x ∈ l → x ∈ s) → l.prod ∈ s
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {n : ℕ} {s1 s2 : Affine.Simplex k P n} (h : ∀ (i : Fin (n + 1)), s1.points i = s2.points i) : s1 = s2
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (E : IntermediateField K L) [FiniteDimensional K ↥E] : is_IsClosed ↑(E.fixing_Subgroup)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p b : P) : ⇑(s.weighted_vsub_of_point (λ (_x : ι), p) b) w = s.sum (λ (i : ι), w i) • (p -ᵥ b)
(k n : ℕ) : (List.Nat.antidiagonal_tuple k n).nodup
{α : Type u_1} [LinearOrder α] {s : Finset α} {k : ℕ} (h : s.card = k) (hz : 0 < k) : ⇑(s.order_emb_of_Fin h) ⟨0, hz⟩ = s.min' _
{α : Type u} [PseudoMetricSpace α] {s t : Set α} (Fin : emetric.Hausdorff_edist s t ≠ ⊤) : metric.Hausdorff_dist s t = 0 ↔ Closure s = Closure t
{α : Type u} : Function.Injective FreeGroup.of
{M₀ : Type u_1} [MulZeroClass M₀] [NoZeroDivisors M₀] {a b : M₀} : a * b = 0 ↔ b * a = 0
{α : Type u_1} [LinearOrder α] {A B : Finset α} (h : A ⊆ B) : A.to_colex ≤ B.to_colex
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [LinearOrderedRing α] [FloorRing α] [TopologicalSpace α] [OrderTopology α] [TopologicalAddGroup α] [TopologicalSpace β] [TopologicalSpace γ] {f : β → α → γ} (h : ContinuousOn (Function.uncurry f) (Set.Univ ×ˢ Set.Icc 0 1)) (hF : ∀ (s : β), f s 0 = f s 1) : Continuous (λ (st : β × α), f st.fst (Int.fract st.snd))
{R : Type u_1} {S : Type u_2} [EuclideanDomain R] [CommRing S] [is_IsDomain S] [Algebra R S] {abv : AbsoluteValue R ℤ} {ι : Type u_5} [DecidableEq ι] [Fintype ι] (bS : Basis ι R S) (adm : abv.is_Admissible) [Infinite R] [DecidableEq R] (a : S) {b : R} (hb : b ≠ 0) : ∃ (q : S) (r : R) (H : r ∈ class_group.finset_approx bS adm), ⇑abv (⇑(Algebra.norm R) (r • a - b • q)) < ⇑abv (⇑(Algebra.norm R) (⇑(Algebra_Map R S) b))
{α : Type u_1} [Monoid α] {a b u : α} (hu : IsUnit u) : a * u ∣ b ↔ a ∣ b
{p : ℕ} (hp : 1 < p) : padic_norm p ↑p < 1
{R : Type u} {A' : Type u_1} {B' : Type u_2} [CommSemiring A'] [Semiring B'] [CommSemiring R] [Algebra R A'] [Algebra R B'] {f g : Polynomial A' →ₐ[R] B'} (h₁ : f.comp (is_scalar_tower.to_AlgHom R A' (Polynomial A')) = g.comp (is_scalar_tower.to_AlgHom R A' (Polynomial A'))) (h₂ : ⇑f Polynomial.x = ⇑g Polynomial.x) : f = g
{α : Type u} [SemilatticeSup α] {β : Type u_1} [Preorder β] {f g : α → β} (hF : Monotone f) (hg : Antitone g) (h : f ≤ g) (m n : α) : f m ≤ g n
{R : Type u_1} [CommRing R] {p : ℕ} (hp : Nat.Prime p) : Polynomial.cyclotomic p R = (Finset.range p).sum (λ (i : ℕ), Polynomial.x ^ i)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [cs : CompleteSpace E] {f : E → F} {f' : E ≃L[𝕜] F} {a : E} (hF : HasStrictFderivAt f ↑f' a) {g : F → E} (hg : ∀ᶠ (x : E) in nhds a, g (f x) = x) : HasStrictFderivAt g ↑(f'.symm) (f a)
{C : Type u} [CategoryTheory.Category C] {P Q : C} (f : P ⟶ Q) [CategoryTheory.Mono f] [CategoryTheory.StrongEpi f] : CategoryTheory.IsIso f
{ι : Type u_1} {ι' : Type u_2} {R : Type u_5} {M : Type u_6} [CommSemiring R] [AddCommMonoid M] [Module R M] (b : Basis ι R M) (b' : Basis ι' R M) {ι'' : Type u_3} [Fintype ι'] (b'' : ι'' → M) : (b.to_Matrix ⇑b').mul (b'.to_Matrix b'') = b.to_Matrix b''
{G : Type u_1} [AddGroup G] {k : Set G} {p : Π (x : G), x ∈ AddSubgroup.closure k → Prop} (Hs : ∀ (x : G) (h : x ∈ k), p x _) (H1 : p 0 _) (hMul : ∀ (x : G) (hx : x ∈ AddSubgroup.closure k) (y : G) (hy : y ∈ AddSubgroup.closure k), p x hx → p y hy → p (x + y) _) (Hinv : ∀ (x : G) (hx : x ∈ AddSubgroup.closure k), p x hx → p (-x) _) {x : G} (hx : x ∈ AddSubgroup.closure k) : p x hx
{ι : Type u_1} {V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasZeroMorphisms V] {c : ComplexShape ι} (C : HomologicalComplex V c) {i i' j : ι} (rij : c.rel i j) (rij' : c.rel i' j) : Category_theory.eq_to_hom _ ≫ C.d i' j = C.d i j
{K : Type u_1} [LinearOrderedField K] [FloorRing K] (v : K) (n : ℕ) : ∃ (q : ℚ), (GeneralizedContinuedFraction.of v).convergents n = ↑q
{ι : Type u} (s : Finset ι) (f g : ι → Ennreal) {p q : ℝ} (hpq : p.is_conjugate_exponent q) : s.sum (λ (i : ι), f i * g i) ≤ s.sum (λ (i : ι), f i ^ p) ^ (1 / p) * s.sum (λ (i : ι), g i ^ q) ^ (1 / q)
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ} (hD : DiffContOnCl ℂ f {z : ℂ | 0 < z.re}) (hexp : ∃ (c : ℝ) (H : c < 2) (B : ℝ), f =O[Filter.comap Complex.abs filter.at_Top ⊓ Filter.principal {z : ℂ | 0 < z.re}] λ (z : ℂ), Real.exp (B * Complex.abs z ^ c)) (hre : Filter.Tendsto (λ (x : ℝ), f ↑x) filter.at_Top (nhds 0)) (him : ∀ (x : ℝ), ∥f (↑x * Complex.i)∥ ≤ C) (hz : 0 ≤ z.re) : ∥f z∥ ≤ C
{R : Type u_1} {M : Type u_3} {a : R} [Monoid R] [MulAction R M] (n : ℕ) (ra : IsSmulRegular M a) : IsSmulRegular M (a ^ n)
{R : Type u₁} {L : Type u₂} [CommRing R] [LieRing L] [LieAlgebra R L] [IsNoetherian R L] : LieAlgebra.IsNilpotent R L ↔ ∀ (x : L), IsNilpotent (⇑(LieAlgebra.ad R L) x)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x : V} (hx : x ≠ 0) : hb.oangle (-x) x = ↑Real.pi
(𝕜 : Type u_1) (E : Type u_2) [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {n : ℕ} (h : n = 1) (v : Fin n → E) : ⇑(FormalMultilinearSeries.id 𝕜 E n) v = v ⟨0, _⟩
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : AffineSubspace k P} (h : ↑s.nonempty) (v : V) : v ∈ s.direction ↔ ∃ (p1 : P) (H : p1 ∈ s) (p2 : P) (H : p2 ∈ s), v = p1 -ᵥ p2
{R : Type u_4} [NormedRing R] [CompleteSpace R] (x : R) (h : ∥x∥ < 1) : Summable (λ (n : ℕ), x ^ n)
{α : Type u_1} {β : Type u_2} [PseudoMetricSpace α] [PseudoMetricSpace β] {K : Nnreal} {f : α → β} : (∀ (x y : α), HasNndist.nndist x y ≤ K * HasNndist.nndist (f x) (f y)) → AntilipschitzWith K f
(R : Type u) [Semiring R] [Nontrivial R] (p q : ℕ) [Char_p R p] [ExpChar R q] : q = 1 ↔ p = 0
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {s : Set P} (hs : s.nonempty) : affine_Span k s = ⊤ ↔ Vector_Span k s = ⊤
{α : Type u_1} {r : α → α → Prop} {c : Set α} (hc : IsChain r c) : ∃ (M : Set α), IsMaxChain r M ∧ c ⊆ M
{R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [DecidableEq ι] [CommSemiring R] [Π (i : ι), AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [Π (i : ι), Module R (M₁ i)] [Module R M₂] (f : MultilinearMap R M₁ M₂) (c : ι → R) (m : Π (i : ι), M₁ i) (s : Finset ι) : ⇑f (s.piecewise (λ (i : ι), c i • m i) m) = s.prod (λ (i : ι), c i) • ⇑f m
{E : Type u_1} [AddCommGroup E] [Module ℝ E] {s : Set E} (x : E) : 0 ≤ gauge s x
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type w} {X : C} {R : CategoryTheory.Presieve X} {x : CategoryTheory.Presieve.FamilyOfElements P R} (hx : x.compatible) : x.sieve_extend.compatible
{α : Type u} [TopologicalSpace α] {s : Set α} (h : is_IsClosed s) : Interior (Frontier s) = ∅
{R : Type u_1} [CommRing R] (s : Subring R) (m : Multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.prod ∈ s
{L : FirstOrder.Language} {M : Type u_3} [L.Structure M] : FirstOrder.Language.Structure.Cg L M ↔ ∃ (S : Set M), S.countable ∧ ⇑(FirstOrder.Language.Substructure.closure L) S = ⊤
{s : ℂ} (hs : 1 < s.re) : MeasureTheory.IntegrableOn (λ (x : ℝ), ↑(Real.exp (-x)) * ↑(Real.log x) * ↑x ^ (s - 1)) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume ∧ HasDerivAt complex.Gamma_integral (∫ (x : ℝ) in Set.Ioi 0, ↑(Real.exp (-x)) * ↑(Real.log x) * ↑x ^ (s - 1)) s
{C : Type u} [CategoryTheory.Category C] {X Y Z : C} (f : X ⟶ Y) (g : X ⟶ Z) [CategoryTheory.Limits.HasPushout f g] : CategoryTheory.Limits.HasPushout g f
{α : Type u} {β : Type v} [EmetricSpace α] [PseudoEmetricSpace β] {f : α → β} (hF : Isometry f) : Embedding f
{M : Type u_3} {N : Type u_4} [Monoid M] [Monoid N] (f : M →* Nᵐᵒᵖ) (l : List M) : MulOpposite.unop (⇑f l.prod) = (List.map (MulOpposite.unop ∘ ⇑f) l).reverse.prod
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F] [CompleteSpace E] [CompleteSpace F] (A : E →L[𝕜] F) (x : E) (y : F) : HasInner.inner x (⇑(⇑ContinuousLinearMap.adjoint A) y) = HasInner.inner (⇑A x) y
{R : Type u_2} {Γ₀ : Type u_3} [CommRing R] [LinearOrderedCommMonoidWithZero Γ₀] (v : Valuation R Γ₀) {J : Ideal R} (hJ : J ≤ v.supp) : (v.on_quot hJ).supp = Ideal.map (Ideal.Quotient.mk J) v.supp
{α : Type u_1} [LinearOrder α] {k l : ℕ} {s : Finset α} {i : Fin k} {j : Fin l} {h : s.card = k} {h' : s.card = l} : ⇑(s.order_emb_of_Fin h) i = ⇑(s.order_emb_of_Fin h') j ↔ ↑i = ↑j
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {x : E} {n : WithTop ℕ} {s : Set E} {f : E → F} {g : E → G} (hF : ContDiffWithinAt 𝕜 n f s x) (hg : ContDiffWithinAt 𝕜 n g s x) : ContDiffWithinAt 𝕜 n (λ (x : E), (f x, g x)) s x
 : (Submodule.span ℂ (Set.Range fourier)).topological_Closure = ⊤
{α : Type u} {β : Type v} [LinearOrderedField α] [TopologicalSpace α] [OrderTopology α] {l : Filter β} {f g : β → α} {C : α} (hC : 0 < C) (hF : Filter.Tendsto f l (nhds C)) (hg : Filter.Tendsto g l filter.at_IsBot) : Filter.Tendsto (λ (x : β), f x * g x) l filter.at_IsBot
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasFiniteProducts C] : CategoryTheory.Limits.HasFiniteBiproducts C
{M : Type u_1} [AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M →+ P} (hg : ∀ (y : ↥S), IsAddUnit (⇑g ↑y)) (z : N) (w v : P) : ⇑(f.lift hg) z + w = v ↔ ⇑g (f.sec z).fst + w = ⇑g ↑((f.sec z).snd) + v
{R : Type u_1} {M : Type u_3} {a b : R} [HasScalar R M] [HasMul R] [IsScalarTower R R M] : IsSmulRegular M (a * b) ∧ IsSmulRegular M (b * a) ↔ IsSmulRegular M a ∧ IsSmulRegular M b
{D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ} (hF : ContinuousOn f D) (hF' : DifferentiableOn ℝ f (Interior D)) (hF'' : ∀ (x : ℝ), x ∈ Interior D → deriv^[2] f x < 0) : StrictConcaveOn ℝ D f
{α : Type u_1} {m : Type u_3} {n : Type u_4} [NonUnitalSemiring α] [StarRing α] {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α} {D : Matrix n n α} (hA : A.is_hermitian) (hBC : B.conj_transpose = C) (hD : D.is_hermitian) : (matrix.from_blocks A B C D).is_hermitian
(K : Type u) {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] {V₂ : Type v'} [AddCommGroup V₂] [Module K V₂] (f : V →ₗ[K] V₂) (p : Submodule K V) [FiniteDimensional K ↥p] : FiniteDimensional.finrank K ↥(Submodule.map f p) ≤ FiniteDimensional.finrank K ↥p
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] {p1 p2 p : P} : p -ᵥ p1 = p -ᵥ p2 ↔ p1 = p2
{M : Type u_1} [SemiNormedGroup M] (S : AddSubgroup M) (x y : M ⧸ S) : ∥x + y∥ ≤ ∥x∥ + ∥y∥
{C : Type u₁} {D : Type u₂} [CategoryTheory.Category C] [CategoryTheory.Category D] {i : D ⥤ C} [CategoryTheory.IsRightAdjoint i] (A : C) [CategoryTheory.IsIso ((Category_theory.adjunction.of_Right_Adjoint i).unit.app A)] : A ∈ i.ess_image
{α : Type u} [SemilatticeInf α] [OrderTop α] (x y : α) : (x ⨯ y) = x ⊓ y
{α : Type u_1} (L : List (List α)) (c : Composition L.join.length) (h : List.map List.length L = c.blocks) : L.join.split_wrt_Composition c = L
{α : Type u_1} {n : Type u_4} {R : Type u_5} [HasSub n] [HasScalar R α] (k : R) (v : n → α) : Matrix.circulant (k • v) = k • Matrix.circulant v
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : AffineSubspace k P} (v : V) {p : P} (hp : p ∈ s) : v +ᵥ p ∈ s ↔ v ∈ s.direction
(R : Type u_1) {S : Type u_2} {M : Type u_3} [Semiring R] [Semiring S] [AddCommMonoid M] [HasScalar R S] [Module S M] [Module R M] [IsScalarTower R S M] (h : IsNoetherian R M) : IsNoetherian S M
{J : Type u₁} [CategoryTheory.Category J] [Nonempty J] (h : ∀ (j₁ j₂ : J), ∃ (l : List J), List.Chain CategoryTheory.Zag j₁ l ∧ (j₁ :: l).last _ = j₂) : CategoryTheory.IsConnected J
{𝕜 : Type u_1} {X : Type u_2} [is_R_or_C 𝕜] [TopologicalSpace X] [CompactSpace X] (A : Subalgebra 𝕜 C(X, 𝕜)) (hA : A.separates_points) (hA' : ContinuousMap.ConjInvariantSubalgebra (subalgebra.restrict_scalars ℝ A)) : A.topological_Closure = ⊤
{α : Type u_1} [UniformSpace α] {s : Set α} : is_IsOpen s ↔ ∀ (x : α), x ∈ s → (∃ (V : Set (α × α)) (H : V ∈ Uniformity α), UniformSpace.Ball x V ⊆ s)
{𝕜 : Type u_3} [Field 𝕜] (n : Type) [Fintype n] [DecidableEq n] (M : Matrix n n 𝕜) : ∃ (L L' : List (Matrix.TransvectionStruct n 𝕜)) (D : n → 𝕜), ((List.map matrix.transvection_struct.to_Matrix L).prod.mul M).mul (List.map matrix.transvection_struct.to_Matrix L').prod = Matrix.diagonal D
{k : Type u_1} {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] [CharZero k] {n : ℕ} (s : Affine.Simplex k P n) {fs₁ fs₂ : Finset (Fin (n + 1))} {m₁ m₂ : ℕ} (h₁ : fs₁.card = m₁ + 1) (h₂ : fs₂.card = m₂ + 1) : Finset.centroid k Finset.univ (s.face h₁).points = Finset.centroid k Finset.univ (s.face h₂).points ↔ fs₁ = fs₂
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {c : Con M} {f : M →* P} (H : c ≤ Con.ker f) : (c.lift f H).mrange = f.mrange
{α : Type u} [PseudoMetricSpace α] (s : Set α) : UniformContinuous (λ (x : α), metric.inf_dist x s)
{R : Type u_1} (S : Type u_2) [CommRing R] [CommRing S] (y : R) [Algebra R S] [IsLocalization.Away y S] [H : Ideal.IsJacobson R] (J : Ideal S) : J.is_Maximal ↔ (Ideal.comap (Algebra_Map R S) J).is_Maximal ∧ y ∉ Ideal.comap (Algebra_Map R S) J
{X₁ X₂ Y : Top} {f : C(↥X₁, ↥Y)} {g : C(↥X₂, ↥Y)} {x₀ x₁ : ↥X₁} {x₂ x₃ : ↥X₂} {p : Path x₀ x₁} {q : Path x₂ x₃} (hfg : ∀ (t : ↥UnitInterval), ⇑f (⇑p t) = ⇑g (⇑q t)) : (fundamental_groupoid.fundamental_groupoid_functor.map f).map ⟦p⟧ == (fundamental_groupoid.fundamental_groupoid_functor.map g).map ⟦q⟧
{α : Type u_1} {c : Set (Set α)} (H : ∀ (a : α), ∃! (b : Set α) (H : b ∈ c), a ∈ b) {s : Set α} {y : α} (hs : s ∈ c) (hy : y ∈ s) : s = {x : α | (setoid.mk_Classes c H).rel x y}
{F : Type u_1} [NormedGroup F] [NormedSpace ℝ F] (f : ℝ → F) {K : Set F} (hK : IsComplete K) : MeasurableSet {x : ℝ | DifferentiableWithinAt ℝ f (Set.Ici x) x ∧ deriv_within f (Set.Ici x) x ∈ K}
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.Limits.HasPullbacks C] {X Y : C} (g : X ⟶ Y) (f₁ f₂ : CategoryTheory.Subobject Y) : (CategoryTheory.Subobject.pullback g).obj (f₁ ⊓ f₂) = (CategoryTheory.Subobject.pullback g).obj f₁ ⊓ (CategoryTheory.Subobject.pullback g).obj f₂
{β : Type u} {γ : Type w} [Semiring β] [Semiring γ] (f : β →+* γᵐᵒᵖ) (l : List β) : MulOpposite.unop (⇑f l.prod) = (List.map (MulOpposite.unop ∘ ⇑f) l).reverse.prod
{o : Ordinal} : Ordinal.Principal has_mul.mul o ↔ o ≤ 2 ∨ ∃ (a : Ordinal), o = Ordinal.omega ^ Ordinal.omega ^ a
{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.adj] (v : V) : G.degree v ≤ G.max_degree
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (h : b.orientation = o) (θ : ℝ) : o.rotation ↑θ = hb.rotation ↑θ
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) (m : Multiset L) : (∀ (a : L), a ∈ m → a ∈ S) → m.prod ∈ S
{R : Type u} [CommRing R] [is_IsDomain R] [UniqueFactorizationMonoid R] (h₁ : ∃ (p : R), Irreducible p) (h₂ : ∀ ⦃p q : R⦄, Irreducible p → Irreducible q → Associated p q) : DiscreteValuationRing R
{α : Type u} {β : Type v} {fa : α → α} {fb : β → β} {g : α → β} (h : Function.Semiconj g fa fb) : Set.MapsTo g (Function.FixedPoints fa) (Function.FixedPoints fb)
(R : Type u) [CommRing R] [is_IsDomain R] [DiscreteValuationRing R] : ∃ (ϖ : R), Irreducible ϖ
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b
{α : Type u_1} [TopologicalSpace α] [t0_Space α] [CompactSpace α] {S : Set α} (hS : is_IsClosed S) (hne : S.nonempty) : ∃ (x : α), x ∈ S ∧ is_IsClosed {x}
(N : ℕ) {j : ℝ} (hj : 0 < j) {c : ℝ} (hc : 1 < c) : (Finset.filter (λ (i : ℕ), j < ↑⌊c ^ i⌋₊) (Finset.range N)).sum (λ (i : ℕ), 1 / ↑⌊c ^ i⌋₊ ^ 2) ≤ c ^ 5 * (c - 1)⁻¹ ^ 3 / j ^ 2
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {ι : Type u_1} (v : ι → M) (i : LinearIndependent R v) (w : Set M) [Fintype ↥w] (s : Submodule.span R w = ⊤) : Cardinal.mk ι ≤ ↑(Fintype.card ↥w)
{α : Type u} [Group α] [HasLe α] [CovariantClass α α has_mul.mul has_le.le] [CovariantClass α α (Function.swap has_mul.mul) has_le.le] {a b : α} : a⁻¹ ≤ b → b⁻¹ ≤ a
{ι : Type u} (s : Finset ι) {f g : ι → ℝ} {p q : ℝ} (hpq : p.is_conjugate_exponent q) (hF : ∀ (i : ι), i ∈ s → 0 ≤ f i) (hg : ∀ (i : ι), i ∈ s → 0 ≤ g i) : s.sum (λ (i : ι), f i * g i) ≤ s.sum (λ (i : ι), f i ^ p) ^ (1 / p) * s.sum (λ (i : ι), g i ^ q) ^ (1 / q)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (p : P) : Vector_Span k {p} = ⊥
{α : Type u} {a b : α} [MulZeroOneClass α] [PartialOrder α] [ZeroLt.PosMulMono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 ≤ a) : a * b ≤ 1
{α : Type u_1} {β : Type u_2} [AddCommMonoid α] [TopologicalSpace α] {f : β → α} {s : Finset β} (hF : ∀ (b : β), b ∉ s → f b = 0) : HasSum f (s.sum (λ (b : β), f b))
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {x : E} {n : WithTop ℕ} {p : E → FormalMultilinearSeries 𝕜 E F} (h : HasFtaylorSeriesUpToOn n f p s) (hn : 1 ≤ n) (hx : s ∈ nhds x) : DifferentiableAt 𝕜 f x
{α : Type u_1} {n : Type u_4} [Semiring α] [Fintype n] [AddGroup n] (v w : n → α) : (Matrix.circulant v).mul (Matrix.circulant w) = Matrix.circulant ((Matrix.circulant v).mul_vec w)
{M : Type u_1} [AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [AddCommMonoid N] {P : Type u_3} [AddCommMonoid P] (f : S.localization_Map N) {g : M →+ P} (hg : ∀ (y : ↥S), IsAddUnit (⇑g ↑y)) (z : N) (v : P) : ⇑(f.lift hg) z = v ↔ ⇑g (f.sec z).fst = ⇑g ↑((f.sec z).snd) + v
{M : Type u_1} [SemiNormedGroup M] {S : AddSubgroup M} (x : M ⧸ S) : ∥-x∥ = ∥x∥
{α : Type u_1} {β : Type u_2} [AddZeroClass α] [AddZeroClass β] (f g : αᵐᵒᵖ →+ β) (h : f.comp MulOpposite.op_Add_equiv.to_Add_MonoidHom = g.comp MulOpposite.op_Add_equiv.to_Add_MonoidHom) : f = g
{α : Type u} {β : Type v} [TopologicalSpace α] [PseudoMetricSpace β] : Continuous (λ (p : BoundedContinuousFunction α β × α), ⇑(p.fst) p.snd)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] {u v : E} (hv : v ∈ K) (hvo : u - v ∈ Kᗮ) : ↑(⇑(Orthogonal_projection K) u) = v
{ι : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : ι → M} [Semiring R] [AddCommMonoid M] [AddCommMonoid M'] [Module R M] [Module R M'] (hv : LinearIndependent R v) (f : M →ₗ[R] M') (hF_inj : f.ker = ⊥) : LinearIndependent R (⇑f ∘ v)
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (x y : E) : is_R_or_C.abs (HasInner.inner x y) ≤ ∥x∥ * ∥y∥
{ι : Type u_1} {S : Type u_3} {R : Type u_4} [DecidableEq ι] [AddMonoid ι] [CommSemiring S] [Semiring R] [Algebra S R] (A : ι → Submodule S R) [SetLike.GradedMonoid A] : (⨆ (i : ι), A i) = (direct_sum.coe_AlgHom A).range.to_Submodule
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x y : E} : ∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * ⇑is_R_or_C.re (HasInner.inner x y) + ∥y∥ ^ 2
{R : Type u} [Semiring R] {ι : Type v} [decι : DecidableEq ι] {M : Type u_1} [AddCommMonoid M] [Module R M] {A : ι → Submodule R M} {i j : ι} (hij : i ≠ j) (h : Set.Univ = {i, j}) (hi : DirectSum.IsInternal A) : IsCompl (A i) (A j)
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X ⟶ Y} [CategoryTheory.Limits.HasCoequalizer f g] (h : f = g) : CategoryTheory.IsIso (CategoryTheory.Limits.coequalizerπ f g)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (ha : ContinuousAt f a) (hb : ContinuousAt f b) : fderiv ℝ (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) (a, b) = (ContinuousLinearMap.snd ℝ ℝ ℝ).smul_Right (f b) - (ContinuousLinearMap.fst ℝ ℝ ℝ).smul_Right (f a)
(a : ℝ) {b : ℝ} (h : 0 < b) : MeasureTheory.IntegrableOn (λ (x : ℝ), Real.exp (-b * x)) (Set.Ioi a) MeasureTheory.MeasureSpace.volume
{K : Type u_1} [Field K] (n : ℕ) : Polynomial.Splits (RingHom.id K) (Polynomial.cyclotomic' n K)
{C : Type u₁} [CategoryTheory.Category C] {X Y : C} {R : CategoryTheory.Presieve X} (f : Y ⟶ X) [CategoryTheory.SplitEpi f] (hF : R f) : CategoryTheory.Sieve.generate R = ⊤
{α : Type u_1} {ι' : sort u_5} (s : ι' → Set α) : (⋂ (i : ι'), s i) = ⋂ (t : Finset (plift ι')) (i : plift ι') (H : i ∈ t), s i.down
{α : Type u_1} {n : ℕ} (v : Vector α n) : Vector.map Id v = v
{R : Type u_1} {A : Type u_2} [CommRing R] [CommRing A] [Algebra R A] (hfp : Algebra.FinitePresentation R A) (ι : Type u_3) [Fintype ι] : Algebra.FinitePresentation R (MvPolynomial ι A)
{α : Type u} (s : Set α) [h : Fintype ↥s] : s.finite
(p : ℕ) [p_Prime : Fact (Nat.Prime p)] {q : ℚ} {n d : ℤ} (hqz : q ≠ 0) (qdf : q = Rat.mk n d) : padic_val_rat p q = ↑((multiplicity ↑p n).get _) - ↑((multiplicity ↑p d).get _)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {X : Top} (F : Top.Presheaf C X) (U : TopologicalSpace.Opens ↥X) (R : CategoryTheory.Presieve U) (f : Σ (V : TopologicalSpace.Opens ↥X), {f // R f}) : (Top.presheaf.covering_of_presieve.first_obj_iso_Pi_Opens F U R).hom ≫ Category_theory.limits.pi.π (λ (i : Σ (V : TopologicalSpace.Opens ↥X), {f // R f}), F.obj (Opposite.op (Top.presheaf.covering_of_Presieve U R i))) f = Category_theory.limits.pi.π (λ (f : Σ (V : TopologicalSpace.Opens ↥X), {f // R f}), F.obj (Opposite.op f.fst)) f
{G : Type u_1} [Group G] [hG : group.is_nilpotent G] : Nat.find _ = group.nilpotency_class G
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : E → ℝ} {a : E} {f' : E →L[ℝ] ℝ} {s : Set E} (h : is_IsLocalMinOn f s a) (hF : HasFderivWithinAt f f' s a) {y : E} (hy : y ∈ PosTangentConeAt s a) (hy' : -y ∈ PosTangentConeAt s a) : ⇑f' y = 0
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : ∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + 2 * HasInner.inner x y + ∥y∥ * ∥y∥
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) {y : L} : y ∈ S → ∀ {x : K}, x • y ∈ S
(J : Type u_1) (C : Type u_2) [CategoryTheory.Category J] [CategoryTheory.Category C] : Category_theory.idempotents.to_Karoubi (J ⥤ C) ⋙ CategoryTheory.Idempotents.Karoubi_Functor_Category_Embedding J C = (Category_theory.whiskering_Right J C (CategoryTheory.Idempotents.Karoubi C)).obj (Category_theory.idempotents.to_Karoubi C)
{α : Type u_1} [CommSemiring α] (t : Tree α) (r : tactic.ring2.csring_expr) : (tactic.ring2.horner_expr.of_csexpr r).is_cs ∧ tactic.ring2.horner_expr.cseval t (tactic.ring2.horner_expr.of_csexpr r) = tactic.ring2.csring_expr.eval t r
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w₁ w₂ : ι → k) (p : ι → P) : ⇑(s.weighted_vsub p) w₁ +ᵥ ⇑(s.affine_combination p) w₂ = ⇑(s.affine_combination p) (w₁ + w₂)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 ∈ s) : (affine_Span k (HasInsert.insert p2 ↑s)).direction = Submodule.span k {p2 -ᵥ p1} ⊔ s.direction
{α : Type u} {β : Type v} [LinearOrderedField α] [TopologicalSpace α] [OrderTopology α] {l : Filter β} {f g : β → α} {C : α} (hC : C < 0) (hF : Filter.Tendsto f l (nhds C)) (hg : Filter.Tendsto g l filter.at_IsBot) : Filter.Tendsto (λ (x : β), f x * g x) l filter.at_Top
{s : Set ℂ} : s.countable → (Complex.exp ⁻¹' s).countable
{α : Type u_1} {n : Type u_4} [HasZero α] [DecidableEq n] (A : Matrix n n α) : A.is_diag ↔ Matrix.diagonal A.diag = A
{α : Type u_1} {E : α → Type u_2} {p : Ennreal} [Π (i : α), NormedGroup (E i)] {ι : Type u_3} {l : Filter ι} [l.ne_IsBot] [Fact (1 ≤ p)] {C : ℝ} {F : ι → ↥(Lp E p)} (hCF : ∀ᶠ (k : ι) in l, ∥F k∥ ≤ C) {f : ↥(Lp E p)} (hF : Filter.Tendsto (Id (λ (i : ι), ⇑(F i))) l (nhds ⇑f)) : ∥f∥ ≤ C
{M : Type u_3} {N : Type u_4} [AddZeroClass M] [AddZeroClass N] (f : M →+ N) : ⇑f 0 = 0
{E : Type u_1} [InnerProductSpace ℝ E] {n : ℕ} [Fact (FiniteDimensional.finrank ℝ E = n + 1)] : ContMdiff (model_with_corners_self ℝ (EuclideanSpace ℝ (Fin n))) (model_with_corners_self ℝ (EuclideanSpace ℝ (Fin n))) ⊤ (λ (x : ↥(Metric.Sphere 0 1)), -x)
{M : Type u_1} [Monoid M] {s : Set M} (hs : IsSubmonoid s) {l : List M} : (∀ (x : M), x ∈ l → x ∈ s) → l.prod ∈ s
{G : Type u_7} [AddGroup G] (L : List G) : L.reverse.sum = -(List.map (λ (x : G), -x) L).sum
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {f : 𝕜 → F} : iterated_deriv (n + 1) f = deriv (iterated_deriv n f)
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [AddCommMonoid α] [TopologicalSpace α] [t2_Space α] [Encodable γ] [CompleteLattice β] (m : β → α) (m0 : m ⊥ = 0) (s : γ → β) : ∑' (i : ℕ), m (⨆ (b : γ) (H : b ∈ Encodable.decode₂ γ i), s b) = ∑' (b : γ), m (s b)
{α : Type u} {β : Type v} [Group α] [Group β] {f : α → β} (hF : IsGroupHom f) : f 1 = 1
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {p : E → FormalMultilinearSeries 𝕜 E F} {n : ℕ} : HasFtaylorSeriesUpToOn ↑(n + 1) f p s ↔ (∀ (x : E), x ∈ s → (p x 0).uncurry0 = f x) ∧ (∀ (x : E), x ∈ s → HasFderivWithinAt (λ (y : E), p y 0) (p x 1).curry_Left s x) ∧ HasFtaylorSeriesUpToOn ↑n (λ (x : E), ⇑(Continuous_multilinear_Curry_Fin1 𝕜 E F) (p x 1)) (λ (x : E), (p x).shift) s
{α : Type u} [Subsingleton α] (l : Filter α) [l.ne_IsBot] : l = ⊤
(t : ℝ) : Filter.Tendsto (λ (x : ℝ), x * Real.log (1 + t / x)) filter.at_Top (nhds t)
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {f : α → β × γ} (hF : Continuous f) : Continuous (λ (a : α), (f a).snd)
{α : Type u} [AddGroup α] [HasLe α] [CovariantClass α α has_add.add has_le.le] {a : α} : -a ≤ 0 → 0 ≤ a
{G : Type u_1} [Group G] {x y : G} : y ∈ Subgroup.closure {x} ↔ ∃ (n : ℤ), x ^ n = y
{α : Type u_1} (r : α → α → Prop) : EqvGen.setoid r = HasInf.inf {s : Setoid α | ∀ ⦃x y : α⦄, r x y → s.rel x y}
{G : Type u_1} [AddGroup G] (K : AddSubgroup G) {l : List G} : (∀ (x : G), x ∈ l → x ∈ K) → l.sum ∈ K
{α : Type u_1} [CancelCommMonoidWithZero α] [WfDvdMonoid α] [GcdMonoid α] : UniqueFactorizationMonoid α
(C : Type u) [CategoryTheory.Category C] : CategoryTheory.EssentiallySmall C ↔ Small (CategoryTheory.Skeleton C) ∧ CategoryTheory.LocallySmall C
{a b c : ℤ} (h1 : a % b = c) (h2 : (a - c).nat_Abs < b.nat_Abs) : a = c
{R : Type u_1} [Semiring R] [Nontrivial R] : power_series.X.order = 1
{M : Type u_2} [AddCommGroup M] {A : Type u_1} [CommRing A] [Module A M] (f : M ≃ₗ[A] M) : ⇑LinearMap.det ↑(f.symm) * ⇑LinearMap.det ↑f = 1
{n : ℕ} {i : Fin (n + 1)} : SimplexCategoryδ (⇑fin.cast_Succ i) ≫ SimplexCategoryσ i = 𝟙 (SimplexCategory.mk n)
{C : Type u₁} [CategoryTheory.Category C] {P : Cᵒᵖ ⥤ Type w} (J : CategoryTheory.GrothendieckTopology C) {P' : Cᵒᵖ ⥤ Type w} (i : P ≅ P') (h : CategoryTheory.Presieve.IsSheaf J P) : CategoryTheory.Presieve.IsSheaf J P'
{T : Type u} [CategoryTheory.Category T] (i : CategoryTheory.Arrow T) {X Y : T} (p : X ≅ Y) (sq : i ⟶ CategoryTheory.Arrow.mk p.hom) : i.hom ≫ sq.right ≫ p.inv = sq.left
{n : ℕ} {a : Cardinal} (h : n ≠ 0) : n • a < Cardinal.aleph_0 ↔ a < Cardinal.aleph_0
{α : Type u} {β : Type v} [TopologicalSpace α] {f g : α → β} {a : α} (h : f =ᶠ[nhds a] g) : ∀ᶠ (y : α) in nhds a, f =ᶠ[nhds y] g
(X : Type u) (Y : Type v) [MetricSpace X] [CompactSpace X] [Nonempty X] [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : Isometry (Gromov_Hausdorff.optimal_GH_injl X Y)
{α : Type u_2} {ι : Type u_5} [AddCommMonoid α] (t : Finset ι) (f : ι → Set α) (g : ι → α) (hg : ∀ (i : ι), i ∈ t → g i ∈ f i) : t.sum (λ (i : ι), g i) ∈ t.sum (λ (i : ι), f i)
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] {a b c : α} : a + b < c → b < -a + c
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] {F : Type v} [NormedGroup F] [NormedSpace ℂ F] {f : E → F} {s : Set E} {z w : E} (hD : DiffContOnCl ℂ f s) (hz : IsMaxOn (HasNorm.norm ∘ f) s z) (hSub : Metric.Ball z (HasDist.dist w z) ⊆ s) : ∥f w∥ = ∥f z∥
{ι : Type u_1} {R : Type u_3} {K : Type u_4} {M : Type u_5} {v : ι → M} [Semiring R] [AddCommMonoid M] [Module R M] [Semiring K] [SmulWithZero R K] [Module K M] [IsScalarTower R K M] (hinj : Function.Injective (λ (r : R), r • 1)) (li : LinearIndependent K v) : LinearIndependent R v
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommMonoid E] [HasScalar 𝕜 E] {x : E} {s : Set E} : StarConvex 𝕜 x s ↔ ∀ ⦃a b : 𝕜⦄, 0 ≤ a → 0 ≤ b → a + b = 1 → a • {x} + b • s ⊆ s
{E : Type u_1} {F : Type u_2} [InnerProductSpace ℝ E] [InnerProductSpace ℝ F] {f : E → F} {x : E} : ConformalAt f x ↔ ∃ (c : ℝ), 0 < c ∧ ∀ (u v : E), HasInner.inner (⇑(fderiv ℝ f x) u) (⇑(fderiv ℝ f x) v) = c * HasInner.inner u v
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] (f f' : ℝ → E) {a b : ℝ} (hle : a ≤ b) {s : Set ℝ} (hs : s.countable) (Hc : ContinuousOn f (Set.Icc a b)) (hD : ∀ (x : ℝ), x ∈ Set.Ioo a b  s → HasDerivAt f (f' x) x) (Hi : IntervalIntegrable f' MeasureTheory.MeasureSpace.volume a b) : ∫ (x : ℝ) in a..b, f' x = f b - f a
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} : InnerProductGeometry.angle x y = Real.pi ↔ x ≠ 0 ∧ ∃ (r : ℝ), r < 0 ∧ y = r • x
{C : Type u₁} [CategoryTheory.Category C] {T : CategoryTheory.Monad C} {J : Type u} [CategoryTheory.Category J] {D : J ⥤ T.algebra} (c : CategoryTheory.Limits.Cocone (D ⋙ T.forget)) (t : CategoryTheory.Limits.IsColimit c) [CategoryTheory.Limits.PreservesColimit (D ⋙ T.forget) ↑T] (j : J) : ↑T.map (c.ι.app j) ≫ CategoryTheory.Monad.ForgetCreatesColimits.lambda c t = (D.obj j).a ≫ c.ι.app j
{R : Type u_1} [CommRing R] (M : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] [IsLocalization M S] (a : S) : ∃ (b : ↥M), IsLocalization.IsInteger R (a * ⇑(Algebra_Map R S) ↑b)
{α : Type u_1} [CircularPreorder α] {a b c : α} : HasBtw.Btw a b c ↔ HasBtw.Btw c a b
{M : Type u_1} [SemiNormedGroup M] (S : AddSubgroup M) : Function.Surjective ⇑(S.normed_Mk)
{n : ℕ} : order_of (DihedralGroup.r 1) = n
{α : Type u_1} {β : Type u_2} [Nontrivial β] {f : α → β} (hF : Function.Surjective f) : Nontrivial α
{α : Type u_1} [CancelCommMonoidWithZero α] [GcdMonoid α] {m n k : α} (H : k ∣ m * n) : ∃ (d₁ : α) (hD₁ : d₁ ∣ m) (d₂ : α) (hD₂ : d₂ ∣ n), k = d₁ * d₂
{α : Type u} [TopologicalSpace α] {s : Set α} : Dense s → Dense (Closure s)
{α : Type u_1} (s : Finset α) : s.powerset.card = 2 ^ s.card
{𝕂 : Type u_1} {𝔸 : Type u_2} [NondiscreteNormedField 𝕂] [NormedCommRing 𝔸] [NormedAlgebra 𝕂 𝔸] [CompleteSpace 𝔸] [CharZero 𝕂] {x : 𝔸} (hx : x ∈ Emetric.Ball 0 (Exp_series 𝕂 𝔸).radius) : HasStrictFderivAt (Exp 𝕂) (Exp 𝕂 x • 1) x
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C} (f : X ⟶ Y) [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasKernel f] [CategoryTheory.Mono f] : CategoryTheory.Limits.kernelι f = 0
{α : Type u_1} [Monoid α] {a u : α} (hu : IsUnit u) : u ∣ a
{α : Type u_1} {δ : Type u_5} [TopologicalSpace α] [MeasurableSpace α] [BorelSpace α] [MeasurableSpace δ] [CompleteLinearOrder α] [OrderTopology α] [TopologicalSpace.SecondCountableTopology α] {ι : Type u_2} {ι' : Type u_3} {f : ι → δ → α} {u : Filter ι} (hF : ∀ (i : ι), Measurable (f i)) {p : ι' → Prop} {s : ι' → Set ι} (hu : u.has_countable_Basis p s) (hs : ∀ (i : ι'), (s i).countable) : Measurable (λ (x : δ), u.limsup (λ (i : ι), f i x))
(S : Set ℕ+) (K : Type w) (L : Type z) [Field K] [Field L] [Algebra K L] [h : NumberField K] [Fintype ↥S] [IsCyclotomicExtension S K L] : NumberField L
{R : Type u_1} {A : Type u_2} [CommSemiring R] [CommSemiring A] [Algebra R A] (S T : Subalgebra R A) : S.to_Submodule * T.to_Submodule = (S ⊔ T).to_Submodule
{R : Type u_1} [OrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {x : M} [NoZeroSmulDivisors R M] (h : SameRay R x (-x)) : x = 0
{n : ℕ} {α : Type u_1} [Preorder α] {f : Fin (n + 1) → α} : Antitone f ↔ ∀ (i : Fin n), f i.succ ≤ f (⇑fin.cast_Succ i)
(M : Type u_1) [MonoidWithZero M] : IsSquare 0
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] (h : Module.rank K V < Cardinal.aleph_0) : (Basis.OfVectorSpaceIndex K V).finite
{R : Type u_1} {a : R} [Monoid R] {n : ℕ} (n0 : 0 < n) : IsRegular (a ^ n) ↔ IsRegular a
{C : Type u₁} [CategoryTheory.Category C] {A : C} [CategoryTheory.Limits.HasTerminal C] [CategoryTheory.Mono (CategoryTheory.Limits.terminal.from A)] : CategoryTheory.IsSubterminal A
{X : Top} {T : ↥X → Type v} (P : Top.LocalPredicate T) (x : ↥X) (w : ∀ (t : T x), ∃ (U : TopologicalSpace.OpenNhds x) (f : Π (y : ↥(U.val)), T ↑y) (h : P.to_prelocal_predicate.pred f), f ⟨x, _⟩ = t) : Function.Surjective (Top.stalk_to_fiber P x)
{ι : Type u_1} {α : ι → Type u_2} [Fintype ι] [DecidableEq ι] [Π (i : ι), DecidableEq (α i)] (r : Π (i : ι), α i → Finset (α i) → Prop) (H_ex : ∀ (i : ι) (s : Finset (α i)), s.nonempty → (∃ (x : α i) (H : x ∈ s), r i x (s.erase x))) {p : (Π (i : ι), Finset (α i)) → Prop} (f : Π (i : ι), Finset (α i)) (h0 : p (λ (_x : ι), ∅)) (step : ∀ (g : Π (i : ι), Finset (α i)) (i : ι) (x : α i), r i x (g i) → p g → p (Function.update g i (HasInsert.insert x (g i)))) : p f
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : E → ℝ} {a : E} {f' : E →L[ℝ] ℝ} {s : Set E} (h : is_IsLocalMaxOn f s a) (hF : HasFderivWithinAt f f' s a) {y : E} (hy : y ∈ PosTangentConeAt s a) : ⇑f' y ≤ 0
{J : Type u₁} [CategoryTheory.Category J] [Nonempty J] (h : ∀ {α : Type u₁} (F : J ⥤ CategoryTheory.Discrete α) (j j' : J), F.obj j = F.obj j') : CategoryTheory.IsConnected J
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {A B : C} (f : A ⟶ B) (F : C ⥤ D) [CategoryTheory.IsIso (F.map f)] [CategoryTheory.ReflectsIsomorphisms F] : CategoryTheory.IsIso f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} {V₂ : Type u_5} {P₂ : Type u_6} [AddCommGroup V₂] [Module k V₂] [AddTorsor V₂ P₂] {p : ι → P} (f : P →ᵃ[k] P₂) (hai : AffineIndependent k (⇑f ∘ p)) : AffineIndependent k p
{R : Type u} [NonAssocSemiring R] {s : Set R} {t : Subsemiring R} : Subsemiring.closure s ≤ t ↔ s ⊆ ↑t
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {s t : Set E} (hs₁ : Convex ℝ s) (hs₂ : is_IsOpen s) (ht : Convex ℝ t) (disj : Disjoint s t) : ∃ (f : E →L[ℝ] ℝ) (u : ℝ), (∀ (a : E), a ∈ s → ⇑f a < u) ∧ ∀ (b : E), b ∈ t → u ≤ ⇑f b
{𝕜 : Type u_1} {E : Type u_2} [NormedField 𝕜] [SemiNormedGroup E] [NormedSpace 𝕜 E] {x : E} {s : Set E} (hs : Metric.Bounded s) {u : Set E} (hu : u ∈ nhds x) : ∀ᶠ (r : 𝕜) in nhds 0, {x} + r • s ⊆ u
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : Rˣ) (n : ℕ) : ∀ᶠ (t : R) in nhds 0, Ring.inverse (↑x + t) = (Finset.range n).sum (λ (i : ℕ), (-↑x⁻¹ * t) ^ i) * ↑x⁻¹ + (-↑x⁻¹ * t) ^ n * Ring.inverse (↑x + t)
{α : Type u} [TopologicalSpace α] [t1_Space α] [∀ (x : α), (nhds_within x {x}ᶜ).ne_IsBot] {s : Set α} (hs : Dense s) (t : Finset α) : Dense (s  ↑t)
{𝕜 : Type u_1} [Field 𝕜] {M : Type u_2} [AddCommGroup M] [Module 𝕜 M] : ⇑LinearMap.det 0 = 0 ^ FiniteDimensional.finrank 𝕜 M
{α : Type u_1} {m : Set α → Ennreal} {m_Empty : m ∅ = 0} {s t : Set α} (h : ∀ (u : Set α), (s ∩ u).nonempty → (t ∩ u).nonempty → m u = ⊤) : ⇑(measure_theory.outer_measure.of_Function m m_Empty) (s ∪ t) = ⇑(measure_theory.outer_measure.of_Function m m_Empty) s + ⇑(measure_theory.outer_measure.of_Function m m_Empty) t
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (G : C ⥤ D) [CategoryTheory.Limits.HasInitial C] [CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) G] : CategoryTheory.Limits.HasInitial D
{M : Type u_1} [AddZeroClass M] {c : AddCon M} : Function.Surjective ⇑(c.mk')
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (F : C ⥤ D) [CategoryTheory.Abelian C] [CategoryTheory.Abelian D] [F.additive] [CategoryTheory.EnoughInjectives C] {X Y : C} (f : X ⟶ Y) (P : CategoryTheory.InjectiveResolution X) (Q : CategoryTheory.InjectiveResolution Y) : F.map f ≫ Category_theory.abelian.functor.right_derived_Zero_to_self_App_Inv F Q = Category_theory.abelian.functor.right_derived_Zero_to_self_App_Inv F P ≫ (F.right_derived 0).map f
{α : Type u_1} {r : α → α → Prop} {s t : Set α} (ht : IsAntichain r t) (h : Minimals r s ⊆ t) (hs : ∀ ⦃a : α⦄, a ∈ t → (∃ (b : α) (H : b ∈ Minimals r s), r a b)) : Minimals r s = t
{G : Type u_1} [Group G] (s : Set G) : IsSubgroup (group.normal_Closure s)
{α : Type u} {β : Type v} {fa : α → α} {fb : β → β} {x : α} (hx : Function.IsFixedPt fa x) {g : α → β} (h : Function.Semiconj g fa fb) : Function.IsFixedPt fb (g x)
{K : Type u_1} [LinearOrderedField K] {a : K} (H : 1 < a) (n : ℕ) : ↑n ≤ a ^ n / (a - 1)
{α : Type u_1} {α' : Type u_2} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} [DecidableEq α'] [DecidableEq γ] [DecidableEq δ] {s : Finset α} {t : Finset β} {f : α' → β → γ} {g : α → α'} {f' : β → α → δ} {g' : δ → γ} (h_Left_anticomm : ∀ (a : α) (b : β), f (g a) b = g' (f' b a)) : Finset.image₂ f (Finset.image g s) t = Finset.image g' (Finset.image₂ f' t s)
{C : Type u₁} [CategoryTheory.Category C] {B A₁ A₂ : C} (f : A₁ ⟶ B) (g : A₂ ⟶ B) [CategoryTheory.Mono f] [CategoryTheory.Mono g] (i : A₁ ≅ A₂) (w : i.hom ≫ g = f) : CategoryTheory.Subobject.mk f = CategoryTheory.Subobject.mk g
{α : Type u_1} [Order.Frame α] {s : Set α} : s.pairwise_Disjoint Id → CompleteLattice.SetIndependent s
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {ps : Set P} {n : ℕ} [FiniteDimensional ℝ V] (hD : FiniteDimensional.finrank ℝ V = n) (hc : EuclideanGeometry.Cospherical ps) : ∃ (c : P), ∀ (sx : Affine.Simplex ℝ P n), Set.Range sx.points ⊆ ps → sx.circumcenter = c
{τ : Type u_1} {α : Type u_2} {β : Type u_3} [TopologicalSpace β] (f : Filter τ) (ϕ : τ → α → β) (s : Set α) [t2_Space β] {c : Set β} (hc₁ : is_IsCompact c) (hc₂ : ∀ᶠ (t : τ) in f, Set.MapsTo (ϕ t) s c) {n : Set β} (hn₁ : is_IsOpen n) (hn₂ : OmegaLimit f ϕ s ⊆ n) : ∃ (u : Set τ) (H : u ∈ f), Closure (Set.image2 ϕ u s) ⊆ n
{α : Type u_1} [GeneralizedBooleanAlgebra α] [DecidableRel Disjoint] [DecidableRel has_le.le] {s : Finset α} {u v a : α} : a ∈ Uv.compression u v s ↔ a ∈ s ∧ Uv.compress u v a ∈ s ∨ a ∉ s ∧ ∃ (b : α) (H : b ∈ s), Uv.compress u v b = a
{𝕜 : Type u_1} {E : Type u_4} [SemiNormedGroup E] [NondiscreteNormedField 𝕜] [NormedSpace 𝕜 E] (h : ∃ (x : E), ∥x∥ ≠ 0) : ∥ContinuousLinearMap.id 𝕜 E∥ = 1
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : E → ℝ} {a : E} {s : Set E} (h : is_IsLocalMinOn f s a) {y : E} (hy : y ∈ PosTangentConeAt s a) (hy' : -y ∈ PosTangentConeAt s a) : ⇑(fderiv_within ℝ f s a) y = 0
{n : ℕ} {F : Typevec (n + 1) → Type u} [Mvfunctor F] [q : Mvqpf F] {α : Typevec n} {β : Type u_1} (Q : β → Prop) (u v : β → Mvqpf.Cofix F α) (h : ∀ (x : β), Q x → (∃ (a : (Mvqpf.p F).A) (f' : ((Mvqpf.p F).drop.B a).arrow α) (f₀ f₁ : (Mvqpf.p F).last.B a → Mvqpf.Cofix F α), (u x).dest = Mvqpf.abs ⟨a, (Mvqpf.p F).append_contents f' f₀⟩ ∧ (v x).dest = Mvqpf.abs ⟨a, (Mvqpf.p F).append_contents f' f₁⟩ ∧ ∀ (i : (Mvqpf.p F).last.B a), ∃ (x' : β), Q x' ∧ f₀ i = u x' ∧ f₁ i = v x')) (x : β) : Q x → u x = v x
{R : Type u_3} {M : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] (s : Set M) (li : LinearIndependent R Coe) (t : Finset ↥s) : LinearIndependent R Coe
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w₁ w₂ : ι → k) (p : ι → P) : ⇑(s.affine_combination p) w₁ -ᵥ ⇑(s.affine_combination p) w₂ = ⇑(s.weighted_vsub p) (w₁ - w₂)
{C : Type u} [CategoryTheory.Category C] {P Q R : C} (f : P ⟶ Q) (g : Q ⟶ R) [CategoryTheory.StrongEpi (f ≫ g)] : CategoryTheory.StrongEpi g
{p : ℂ × ℂ} (hp_fst : 0 < p.fst.re ∨ p.fst.im ≠ 0) : ContinuousAt (λ (x : ℂ × ℂ), x.fst ^ x.snd) p
 : Real.cos (Real.pi / 3) = 1 / 2
(n : ℕ) (p : Fin (n + 1)) : Finset.univ = Finset.cons p (Finset.map p.succ_above.to_Embedding Finset.univ) _
{E : Type u_1} {F : Type u_2} [InnerProductSpace ℝ E] [InnerProductSpace ℝ F] {f : E → F} {x : E} {f' : E →L[ℝ] F} (h : HasFderivAt f f' x) (H : ConformalAt f x) (u v : E) : InnerProductGeometry.angle (⇑f' u) (⇑f' v) = InnerProductGeometry.angle u v
{A : Type u_1} [CommRing A] [Algebra ℚ A] (a b : A) : ⇑(PowerSeries.rescale a) (PowerSeries.exp A) * ⇑(PowerSeries.rescale b) (PowerSeries.exp A) = ⇑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)
(a b : ℕ) : a ^ 2 - b ^ 2 = (a + b) * (a - b)
{k : Type u_1} {l : Type u_2} {m : Type u_3} {n : Type u_4} {α : Type v} [Fintype n] [Fintype k] [DecidableEq n] [DecidableEq k] [DecidableEq m] [Semiring α] (a : m) (b : n) (c : k) (M : Matrix k l α) : (Pequiv.single a b).to_matrix.mul ((Pequiv.single b c).to_matrix.mul M) = (Pequiv.single a c).to_matrix.mul M
{α : Type u} {ι : Type v} [MetricSpace α] [ProperSpace α] {c : ι → α} {s : Set α} {r : ι → ℝ} (hr : ∀ (i : ι), 0 < r i) (hs : is_IsClosed s) (uf : ∀ (x : α), x ∈ s → {i : ι | x ∈ Metric.Ball (c i) (r i)}.finite) (us : s ⊆ ⋃ (i : ι), Metric.Ball (c i) (r i)) : ∃ (r' : ι → ℝ), (s ⊆ ⋃ (i : ι), Metric.Ball (c i) (r' i)) ∧ ∀ (i : ι), r' i ∈ Set.Ioo 0 (r i)
{G : Type u_1} [Group G] (f₁ f₂ : G →* Circle_deg1_Lift) (h : ∀ (g : G), (⇑f₁ g).translation_number = (⇑f₂ g).translation_number) : ∃ (F : Circle_deg1_Lift), ∀ (g : G), Function.Semiconj ⇑F ⇑(⇑f₁ g) ⇑(⇑f₂ g)
{α : Type u_1} {β : Type u_2} {M : Type u_5} [AddCommMonoid M] [DecidableEq α] [DecidableEq β] (s : Finset (α × β)) (f : α × β → M) : finsum (λ (Ab : α × β), finsum (λ (h : Ab ∈ s), f Ab)) = finsum (λ (a : α), finsum (λ (b : β), finsum (λ (h : b ∈ Finset.image Prod.snd (Finset.filter (λ (Ab : α × β), ab.fst = a) s)), f (a, b))))
{G : Type u_1} [AddGroup G] {H : AddSubgroup G} {N : Type u_3} [AddGroup N] (f : G →+ N) : AddSubgroup.map f H.normalizer ≤ (AddSubgroup.map f H).normalizer
{α : Type u_2} {β : Type u_3} {f : α → β} (hF : Function.Injective f) : Filter.comap f Filter.cofinite = Filter.cofinite
{α : Type u_1} {β : Type u_2} {M : Type u_3} [Fintype α] [Fintype β] [CommMonoid M] (e : α → β) (hE : Function.bijective e) (f : α → M) (g : β → M) (h : ∀ (x : α), f x = g (e x)) : finset.univ.prod (λ (x : α), f x) = finset.univ.prod (λ (x : β), g x)
{k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [Ring k] [AddCommGroup V1] [Module k V1] [AddTorsor V1 P1] [AddCommGroup V2] [Module k V2] [AddTorsor V2 P2] (f : P1 →ᵃ[k] P2) : f.to_fun = ⇑f
{α : Type u_1} [PseudoMetricSpace α] (r C : ℝ) (hr : r < 1) {f : ℕ → α} (hu : ∀ (n : ℕ), HasDist.dist (f n) (f (n + 1)) ≤ C * r ^ n) {a : α} (ha : Filter.Tendsto f filter.at_Top (nhds a)) : HasDist.dist (f 0) a ≤ C / (1 - r)
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {G : C ⥤ D} (H : CategoryTheory.CoverDense K G) [CategoryTheory.Full G] [CategoryTheory.Faithful G] : CategoryTheory.CompatiblePreserving K G
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] {A B C : Matrix n n α} (h : B.mul A = 1) (g : C.mul A = 1) : B = C
{𝕜 : Type u} {G : Type wG} {G' : Type wG'} [NondiscreteNormedField 𝕜] [NormedGroup G] [NormedSpace 𝕜 G] [NormedGroup G'] [NormedSpace 𝕜 G'] {k n : ℕ} (f : MultilinearMap 𝕜 (λ (i : Fin n), G) G') (s : Finset (Fin n)) (hk : s.card = k) (z : G) {C : ℝ} (H : ∀ (m : Fin n → G), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : Fin n), ∥m i∥)) (v : Fin k → G) : ∥⇑(f.restr s hk z) v∥ ≤ C * ∥z∥ ^ (n - k) * finset.univ.prod (λ (i : Fin k), ∥v i∥)
(k : Type u₁) {G : Type u₂} [Semiring k] [has_Add G] {A : Type u₃} [NonUnitalNonAssocSemiring A] [DistribMulAction k A] {φ₁ φ₂ : AddMonoidAlgebra k G →ₙₐ[k] A} (h : ∀ (x : G), ⇑φ₁ (Finsupp.single x 1) = ⇑φ₂ (Finsupp.single x 1)) : φ₁ = φ₂
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {ι : Type u_2} [DecidableEq ι] {E : ι → Type u_3} [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] {s : Π (i : ι), Set (E i)} {x : Π (i : ι), E i} {i : ι} (hi : ∀ (j : ι), j ≠ i → x j ∈ Closure (s j)) : Set.MapsTo ⇑(LinearMap.single i) (TangentConeAt 𝕜 (s i) (x i)) (TangentConeAt 𝕜 (set.univ.pi s) x)
(R : Type u_1) (M : Type u_2) [Ring R] [TopologicalSpace R] [TopologicalSpace M] [AddCommGroup M] [HasContinuousAdd M] [Module R M] [HasContinuousSmul R M] [Nontrivial M] [(nhds_within 0 {0}ᶜ).ne_IsBot] [NoZeroSmulDivisors R M] (x : M) : (nhds_within x {x}ᶜ).ne_IsBot
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [SemiNormedGroup E'] {g : α → F} {f' : α → E'} {l : Filter α} : (λ (x : α), ∥f' x∥) =o[l] g → f' =o[l] g
{ι : Type u_1} {𝕜 : Type u_2} [is_R_or_C 𝕜] {E : Type u_3} [InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {G : ι → Type u_4} [Π (i : ι), InnerProductSpace 𝕜 (G i)] {V : Π (i : ι), G i →ₗᵢ[𝕜] E} (hV : OrthogonalFamily 𝕜 V) [∀ (i : ι), CompleteSpace (G i)] (hV' : (⨆ (i : ι), (V i).to_LinearMap.range).topological_Closure = ⊤) {i : ι} (x : G i) : ⇑((hV.linear_Isometry_Equiv hV').symm) (lp.single 2 i x) = ⇑(V i) x
{ι : Type u_1} {R : Type u_3} {M : Type u_5} {v : ι → M} [Ring R] [AddCommGroup M] [Module R M] {hli : LinearIndependent R v} {hsp : Submodule.span R (Set.Range v) = ⊤} {i j : ι} (h : j ≠ i) : ⇑((Basis.mk hli hsp).coord i) (v j) = 0
{X Y : Top} {f g : C(↥X, ↥Y)} (H : f.homotopy g) (x : ↥X) : ⟦H.eval_at x⟧ = ContinuousMap.Homotopy.hcast _ ≫ (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_Map).map (Continuous_map.homotopy.prod_to_Prod_Top_I Unit_interval.uhpath01 (𝟙 x)) ≫ ContinuousMap.Homotopy.hcast _
{M : Type u_1} [AddZeroClass M] (S : AddSubmonoid M) : AddSubmonoid.closure ↑S = S
{ι : Type w} [Fintype ι] (K : Type u) {L : Type v} (E : Type z) [Field K] [Field L] [Field E] [Algebra K L] [Algebra K E] [Module.Finite K L] [IsAlgClosed E] (b : ι → L) [DecidableEq ι] [IsSeparable K L] (e : ι ≃ (L →ₐ[K] E)) : ⇑(Algebra_Map K E) (Algebra.discr K b) = (algebra.embeddings_Matrix.reindex K E b e).det ^ 2
(C : Type u) [𝒞 : CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryProducts C] [CategoryTheory.Limits.HasEqualizers C] : CategoryTheory.Limits.HasPullbacks C
{H : Type u_1} [TopologicalSpace H] [LocallyCompactSpace H] [t2_Space H] [TotallyDisconnectedSpace H] : TopologicalSpace.IsTopologicalBasis {s : Set H | is_IsClopen s}
{α : Type u} {β : Type v} [TopologicalSpace α] [PseudoMetricSpace β] {f g : BoundedContinuousFunction α β} (x : α) : HasDist.dist (⇑f x) (⇑g x) ≤ HasDist.dist f g
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasLimitsOfSize C] : CategoryTheory.Limits.HasLimitsOfSize C
{M : Type u_1} {N : Type u_2} [AddZeroClass M] [AddZeroClass N] {c : AddCon M} {f : N →+ M} : AddCon.comap ⇑f _ c = AddCon.ker (c.mk'.comp f)
{R : Type u_1} [CommRing R] [is_IsDomain R] [IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) : v.int_Valuation_def 0 = 0
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} {s t : Set α} (hst : Disjoint s t) (hs : s.finite) (ht : t.finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s ∪ t), f i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ t), f i))
{α : Type u_1} {a b c : α} [LinearOrder α] [AddCommSemigroup α] [HasSub α] [HasOrderedSub α] : a < b - c ↔ a + c < b
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (t : Affine.Triangle ℝ P) : t.orthocenter ∈ affine_Span ℝ (Set.Range t.points)
(a : ℝ) : Cardinal.mk ↥(Set.Iic a) = Cardinal.continuum
{K : Type u_1} {n : ℕ} {s : Seq (GeneralizedContinuedFraction.Pair K)} [DivisionRing K] {gp_n gp_Succ_n : GeneralizedContinuedFraction.Pair K} (s_nth_Eq : s.nth n = Option.some gp_n) (s_Succ_nth_Eq : s.nth (n + 1) = Option.some gp_Succ_n) : (generalized_continued_fraction.squash_Seq s n).nth n = Option.some {a := gp_n.a, b := gp_n.b + gp_Succ_n.a / gp_Succ_n.b}
(T : Type u) [TopologicalSpace T] : Category_theory.pretopology.to_grothendieck (TopologicalSpace.Opens T) (Opens.pretopology T) = opens.grothendieck_topology T
{α : Type u_1} {β : Type u_2} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] {s : Set β} (hs : is_IsCompact s) (NE_s : s.nonempty) {f : β → α} (hF : ContinuousOn f s) : ∃ (x : β) (H : x ∈ s), ∀ (y : β), y ∈ s → f x ≤ f y
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasZeroMorphisms C] {X : C} (f : X ⟶ 0) : f = 0
{n : ℕ} {l : Multiset ℕ} (hl : l.sum = n) {i : ℕ} (hi : i ≠ 0) : Multiset.count i (nat.partition.of_sums n l hl).parts = Multiset.count i l
{C : Type u} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) (h : ∀ (X : C), CategoryTheory.Presieve.IsSheaf J (Category_theory.yoneda.obj X)) : CategoryTheory.Sheaf.Subcanonical J
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} {ι2 : Type u_5} (f : ι2 ↪ ι) {p : ι → P} (ha : AffineIndependent k p) : AffineIndependent k (p ∘ ⇑f)
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (hb : Filter.Tendsto f (nhds b ⊓ MeasureTheory.Measure_space.volume.ae) (nhds c)) : deriv (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) b = c
{α : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [HasZero M] [AddCommMonoid N] [AddCommMonoid P] (h : N ≃+ P) (f : α →₀ M) (g : α → M → N) : ⇑h (f.sum g) = f.sum (λ (a : α) (b : M), ⇑h (g a b))
{M : Type u_1} [HasMul M] (c : Con M) (x : M) : ⇑c x x
{α : Type u_1} {β : Type u_2} [LinearOrder α] [DecidableEq β] [Preorder β] {f : α → β} (h₁ : StrictMono f) (A B : Finset α) : (Finset.image f A).to_colex < (Finset.image f B).to_colex ↔ A.to_colex < B.to_colex
{𝕜 : Type u_3} {E : Type u_4} [NormedField 𝕜] [AddCommGroup E] [Module 𝕜 E] (p : Seminorm 𝕜 E) {r : ℝ} {x : E} (hpr : ⇑p x < r) : Absorbent 𝕜 (p.ball x r)
{K : Type u_1} {V : Type u_2} [Field K] [AddCommGroup V] [Module K V] (n : ℕ) [Fact (FiniteDimensional.finrank K V = n + 1)] : FiniteDimensional K V
{α : Type u} [Preorder α] {a b : α} : a < b → a ≤ b
{β : Type u} {α : Type v} {γ : Type w} [CommMonoid β] [CommMonoid γ] (g : β ≃* γ) (f : α → β) (s : Finset α) : ⇑g (s.prod (λ (x : α), f x)) = s.prod (λ (x : α), ⇑g (f x))
{l : Filter ℝ} {f f' g g' : ℝ → ℝ} (hff' : ∀ᶠ (x : ℝ) in filter.at_IsBot, HasDerivAt f (f' x) x) (hgg' : ∀ᶠ (x : ℝ) in filter.at_IsBot, HasDerivAt g (g' x) x) (hg' : ∀ᶠ (x : ℝ) in filter.at_IsBot, g' x ≠ 0) (hfbot : Filter.Tendsto f filter.at_IsBot (nhds 0)) (hgbot : Filter.Tendsto g filter.at_IsBot (nhds 0)) (hDiv : Filter.Tendsto (λ (x : ℝ), f' x / g' x) filter.at_IsBot l) : Filter.Tendsto (λ (x : ℝ), f x / g x) filter.at_IsBot l
{M : Type u_4} [AddCommMonoid M] {ι : Type u_1} [Subsingleton ι] {s : Finset ι} {f : ι → M} {b : M} (h : s.sum (λ (i : ι), f i) = b) (i : ι) (H : i ∈ s) : f i = b
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] [CompleteSpace 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [FiniteDimensional 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {a : E} (hF : HasStrictFderivAt f f' a) (hF' : f'.range = ⊤) : ∀ᶠ (p : F × ↥(f'.ker)) in nhds (f a, 0), f (has_strict_fderiv_at.implicit_Function f f' hF hF' p.fst p.snd) = p.fst
{x : ℝ} (h : 0 < x) : Real.sin x < x
{R : Type u_1} [AddCancelMonoid R] (g : R) : IsAddRegular g
{𝕜 : Type u_4} {E : Type u_5} [LinearOrderedField 𝕜] [TopologicalSpace E] [AddCommMonoid E] [Module 𝕜 E] {s : Set E} (hs₀ : is_IsClosed s) (hs₁ : StrictConvex 𝕜 s) : AddSalemSpencer (Frontier s)
{R : Type u} [NonAssocSemiring R] (s : Subsemiring R) {x y : R} : x ∈ s → y ∈ s → x * y ∈ s
{R : Type u_1} {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] {S : Set M} {x : M} (hx : x ∈ Submodule.span R S) : ∃ (T : Finset M), ↑T ⊆ S ∧ x ∈ Submodule.span R ↑T
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q) [CategoryTheory.Epi f] : Function.Surjective ⇑f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] (s1 s2 : AffineSubspace k P) : s1 ≤ s2 ↔ ↑s1 ⊆ ↑s2
{A : Type u_1} [AddMonoid A] {f g : ℤ →+ A} (h1 : ⇑f 1 = ⇑g 1) : f = g
{α : Type u_1} [LinearOrderedAddCommGroup α] {n : ℤ} (hn : n ≠ 0) : Function.Injective (λ (_x : α), n • _x)
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0
{α : Type u} [PseudoMetricSpace α] {f : ℝ → α} {c : ℝ} (hp : Function.Periodic f c) (hc : c ≠ 0) (hF : Continuous f) : Metric.Bounded (Set.Range f)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x y + hb.oangle y z = hb.oangle x z
{R : Type u_1} {E : Type u_2} [LinearOrderedField R] [AddCommGroup E] [Module R E] (s : Set E) : ⇑(Convex_hull R) s = {x : E | ∃ (ι : Type u') (t : Finset ι) (w : ι → R) (z : ι → E) (hw₀ : ∀ (i : ι), i ∈ t → 0 ≤ w i) (hw₁ : t.sum (λ (i : ι), w i) = 1) (hz : ∀ (i : ι), i ∈ t → z i ∈ s), t.center_mass w z = x}
{α : Type u} [Group α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ → a < 1
{G : Type u_1} [Group G] {s : Set G} {N : Subgroup G} [N.normal] (h : s ⊆ ↑N) : subgroup.normal_Closure s ≤ N
(n : ℕ) (R : Type u_1) [Ring R] [Nontrivial R] : (Polynomial.cyclotomic n R).nat_degree = n.totient
(a : ℝ) : Cardinal.mk ↥(Set.Iio a) = Cardinal.continuum
{α : Type u} {r : α → α → Prop} {s : Set α} : DirectedOn r s → Directed r Coe
(R : Type u) [Ring R] [StrongRankCondition R] (m n : Type v) [Fintype m] [Fintype n] : FiniteDimensional.finrank R (Matrix m n R) = Fintype.card m * Fintype.card n
{α : Type u_1} (t : Set (Set α)) (δ : Set α → ℝ) (τ : ℝ) (hτ : 1 < τ) (δnonneg : ∀ (a : Set α), a ∈ t → 0 ≤ δ a) (R : ℝ) (δLE : ∀ (a : Set α), a ∈ t → δ a ≤ R) (hne : ∀ (a : Set α), a ∈ t → a.nonempty) : ∃ (u : Set (Set α)) (H : u ⊆ t), u.pairwise_Disjoint Id ∧ ∀ (a : Set α), a ∈ t → (∃ (b : Set α) (H : b ∈ u), (a ∩ b).nonempty ∧ δ a ≤ τ * δ b)
{R : Type u} [CommSemiring R] (s : Multiset (Polynomial R)) (x : R) : Polynomial.eval x s.prod = (Multiset.map (Polynomial.eval x) s).prod
{α : Type u_1} {β : Type u_2} {r : Setoid α} {f : α → β} (H : r ≤ setoid.ker f) (g : Quotient r → β) (Hg : f = g ∘ Quotient.mk) : Quotient.lift f H = g
{m : Type u_2} {n : Type u_3} (R : Type u_11) [CommRing R] [Fintype m] [DecidableEq m] [Fintype n] [DecidableEq n] (e : m ≃ n) (M : Matrix m m R) : (⇑(Matrix.reindex_LinearEquiv R R e e) M).det = M.det
{𝕜 : Type u_1} {E : Type u_3} [OrderedSemiring 𝕜] [TopologicalSpace E] [AddCommMonoid E] [Module 𝕜 E] {s : Set E} (h : is_IsOpen s) (hs : Convex 𝕜 s) : StrictConvex 𝕜 s
{R : Type u_1} [MulZeroClass R] : IsRightRegular 0 ↔ Subsingleton R
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_5} [NormedGroup E'] [NormedSpace 𝕜 E'] {n : WithTop ℕ} {f : E → E'} : ContMdiff (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f → ContDiff 𝕜 n f
{α : Type u_1} {β : Type u_2} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] {f : β → α} (hF : Continuous f) (x₀ : β) (h : ∀ᶠ (x : β) in Filter.cocompact β, f x₀ ≤ f x) : ∃ (x : β), ∀ (y : β), f x ≤ f y
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {A : Type u_7} [CategoryTheory.Category A] {G : C ⥤ D} (H : CategoryTheory.CoverDense K G) [CategoryTheory.Full G] {ℱ : Dᵒᵖ ⥤ A} {ℱ' : CategoryTheory.Sheaf K A} (α : ℱ ⟶ ℱ'.val) : H.sheaf_hom (Category_theory.whisker_Left G.op α) = α
{xl xr : Type u_1} {xL : xl → Pgame} {xR : xr → Pgame} {yl yr : Type u_1} {yL : yl → Pgame} {yR : yr → Pgame} : Pgame.mk xl xr xL xR ≤ Pgame.mk yl yr yL yR ↔ (∀ (i : xl), (xL i).lf (Pgame.mk yl yr yL yR)) ∧ ∀ (j : yr), (Pgame.mk xl xr xL xR).lf (yR j)
{α : Type u_1} [CompleteLattice α] [IsModularLattice α] [IsCompactlyGenerated α] (h : HasSup.sup {a : α | IsAtom a} = ⊤) : IsComplemented α
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) : s.points_with_circumcenter Affine.Simplex.PointsWithCircumcenterIndex.circumcenter_Index = s.circumcenter
{R : Type u} [NonAssocSemiring R] (s : Subsemiring R) (m : Multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.sum ∈ s
{p : ℕ} (hp : Nat.Prime p) {n : ℤ} (hpn : IsCoprime n ↑p) : n ^ (p - 1) ≡ 1 [Zmod ↑p]
{α : Type v} {s : Finset α} {M : Type u_1} [AddCommMonoid M] (f : α → M) (p : M → Prop) (p_Mul : ∀ (a b : M), p a → p b → p (a + b)) (p_One : p 0) (p_s : ∀ (x : α), x ∈ s → p (f x)) : p (s.sum (λ (x : α), f x))
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0
(k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] [Fintype ι] (p : ι → P) {n : ℕ} (hc : Fintype.card ι = n + 1) : AffineIndependent k p ↔ n ≤ FiniteDimensional.finrank k ↥(Vector_Span k (Set.Range p))
(R : Type u_1) (A : Type u_2) (M : Type u_3) [CommSemiring R] [Semiring A] [Algebra R A] [AddCommMonoid M] [Module R M] [Module A M] [IsScalarTower R A M] (X : Set M) (hsur : Function.Surjective ⇑(Algebra_Map R A)) : Submodule.span R X = submodule.restrict_scalars R (Submodule.span A X)
{n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] (A : Matrix n n R) : (-A).det = (-1) ^ Fintype.card n • A.det
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) : 0 ≤ InnerProductGeometry.angle x y
{α : Type u} [NonUnitalNonAssocRing α] {a b c d e : α} : a * e + c = b * e + d → (a - b) * e + c = d
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {n : ℕ} (hs : UniqueDiffOn 𝕜 s) : ContDiffOn 𝕜 ↑(n + 1) f s ↔ DifferentiableOn 𝕜 f s ∧ ContDiffOn 𝕜 ↑n (λ (y : E), fderiv_within 𝕜 f s y) s
{R : Type u_1} [CommRing R] (M : Submonoid R) {S : Type u_2} [CommRing S] [Algebra R S] (T : Type u_4) [CommRing T] [Algebra R T] [Algebra S T] [IsScalarTower R S T] [IsLocalization M S] (p : Ideal S) [Hp : p.is_Prime] [IsLocalization.AtPrime T p] : IsLocalization.AtPrime T (Ideal.comap (Algebra_Map R S) p)
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y z : V} (hxyne : x ≠ y) (hxzne : x ≠ z) (hxy : ∥x∥ = ∥y∥) (hxz : ∥x∥ = ∥z∥) : o.oangle y z = 2 • o.oangle (y - x) (z - x)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {p : FormalMultilinearSeries 𝕜 E F} {r : Ennreal} {f : E → F} {x : E} [CompleteSpace F] (h : HasFpowerSeriesOnBall f p x r) : HasFpowerSeriesOnBall (fderiv 𝕜 f) (↑(Continuous_multilinear_Curry_Fin1 𝕜 E F).comp_FormalMultilinearSeries (p.change_origin_series 1)) x r
{α : Type u_1} [ConditionallyCompleteLinearOrder α] {s : Set α} {b : α} (hs : s.nonempty) (hb : b < HasSup.sup s) : ∃ (a : α) (H : a ∈ s), b < a
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {c : E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (hb : Filter.Tendsto f (nhds b ⊓ MeasureTheory.Measure_space.volume.ae) (nhds c)) : HasStrictDerivAt (λ (u : ℝ), ∫ (x : ℝ) in a..u, f x) c b
(k : Type u_1) {V : Type u_2} (P : Type u_3) [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] : Collinear k ∅
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {x : E} {n : ℕ} (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) : iterated_fderiv_within 𝕜 (n + 1) f s x = (⇑(Continuous_multilinear_Curry_Right_Equiv' 𝕜 n E F) ∘ iterated_fderiv_within 𝕜 n (λ (y : E), fderiv_within 𝕜 f s y) s) x
{X : Type u_2} {Y : Type u_3} [EmetricSpace X] [EmetricSpace Y] [TopologicalSpace.SecondCountableTopology X] {f : X → Y} (hF : ∀ (x : X), ∃ (C : Nnreal) (s : Set X) (H : s ∈ nhds x), LipschitzOnWith C f s) : dimH (Set.Range f) ≤ dimH Set.Univ
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {s : Set E} : UniqueMdiffOn (model_with_corners_self 𝕜 E) s → UniqueDiffOn 𝕜 s
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{R : Type u_1} [CommRing R] {x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ : R} : (x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 + x₅ ^ 2 + x₆ ^ 2 + x₇ ^ 2 + x₈ ^ 2) * (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 + y₅ ^ 2 + y₆ ^ 2 + y₇ ^ 2 + y₈ ^ 2) = (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄ - x₅ * y₅ - x₆ * y₆ - x₇ * y₇ - x₈ * y₈) ^ 2 + (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃ + x₅ * y₆ - x₆ * y₅ - x₇ * y₈ + x₈ * y₇) ^ 2 + (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂ + x₅ * y₇ + x₆ * y₈ - x₇ * y₅ - x₈ * y₆) ^ 2 + (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁ + x₅ * y₈ - x₆ * y₇ + x₇ * y₆ - x₈ * y₅) ^ 2 + (x₁ * y₅ - x₂ * y₆ - x₃ * y₇ - x₄ * y₈ + x₅ * y₁ + x₆ * y₂ + x₇ * y₃ + x₈ * y₄) ^ 2 + (x₁ * y₆ + x₂ * y₅ - x₃ * y₈ + x₄ * y₇ - x₅ * y₂ + x₆ * y₁ - x₇ * y₄ + x₈ * y₃) ^ 2 + (x₁ * y₇ + x₂ * y₈ + x₃ * y₅ - x₄ * y₆ - x₅ * y₃ + x₆ * y₄ + x₇ * y₁ - x₈ * y₂) ^ 2 + (x₁ * y₈ - x₂ * y₇ + x₃ * y₆ + x₄ * y₅ - x₅ * y₄ - x₆ * y₃ + x₇ * y₂ + x₈ * y₁) ^ 2
(R : Type u_2) (M : Type u_5) [Semiring R] [AddCommMonoid M] [Module R M] [has_One M] [CharZero M] : CharZero R
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0
{M : Type u_1} [AddMonoid M] (P : AddSubmonoid M) : P.fg ↔ ∃ (S : Set M), AddSubmonoid.closure S = P ∧ S.finite
{ι : Type u_6} [DecidableEq ι] {ι₁ : Type u_7} [Fintype ι] {R' : Type u_8} {N₁ : Type u_9} {N₂ : Type u_10} [CommSemiring R'] [AddCommMonoid N₁] [AddCommMonoid N₂] [Module R' N₁] [Module R' N₂] {f g : AlternatingMap R' N₁ N₂ ι} (e : Basis ι₁ R' N₁) (h : ∀ (v : ι → ι₁), Function.Injective v → ⇑f (λ (i : ι), ⇑e (v i)) = ⇑g (λ (i : ι), ⇑e (v i))) : f = g
{α : Type u} {r : α → α → Prop} {a b : α} (p : α → Prop) (l : List α) (h : List.Chain r a l) (hb : (a :: l).last _ = b) (carries : ∀ ⦃x y : α⦄, r x y → p y → p x) (final : p b) (i : α) (H : i ∈ a :: l) : p i
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [NondiscreteNormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (f : ContinuousMultilinearMap 𝕜 E G) {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ M * finset.univ.prod (λ (i : ι), ∥m i∥)) : ∥f∥ ≤ M
{V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasImages V] [CategoryTheory.Limits.HasZeroObject V] [CategoryTheory.Preadditive V] [CategoryTheory.Limits.HasKernels V] [CategoryTheory.Limits.HasCokernels V] {A B C : V} (f : A ⟶ B) (g : B ⟶ C) : CategoryTheory.Exact f g ↔ ∃ (w : f ≫ g = 0), Nonempty (homology f g w ≅ 0)
{C : Type u₁} [CategoryTheory.Category C] {A : C} [CategoryTheory.Limits.HasBinaryProduct A A] [CategoryTheory.IsIso (CategoryTheory.Limits.diag A)] : CategoryTheory.IsSubterminal A
{C : Type u₁} [CategoryTheory.Category C] {A : C} (hA : CategoryTheory.IsSubterminal A) [CategoryTheory.Limits.HasBinaryProduct A A] : CategoryTheory.IsIso (CategoryTheory.Limits.diag A)
(G : Type u) (F : Type v) [Group G] [Field F] [Fintype G] [MulSemiringAction G F] [HasFaithfulSmul G F] : Function.bijective (Mul_Semiring_action.to_AlgHom ↥(FixedPoints.subfield G F) F)
(p : ℕ) [Fact (Nat.Prime p)] (R : Type u₁) [CommSemiring R] [Char_p R p] [PerfectRing R p] : PerfectionMap p (RingHom.id R)
(R : Type u_1) {K : Type u_2} [CommRing R] [Field K] [Algebra R K] [IsFractionRing R K] [CharZero R] : CharZero K
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {K : Submodule 𝕜 E} [CompleteSpace ↥K] {u v z : E} (hv : v ∈ K) (hz : z ∈ Kᗮ) (hu : u = v + z) : ↑(⇑(Orthogonal_projection K) u) = v
{α : Type u} [PseudoMetricSpace α] {s t u : Set α} (Fin : emetric.Hausdorff_edist t u ≠ ⊤) : metric.Hausdorff_dist s u ≤ metric.Hausdorff_dist s t + metric.Hausdorff_dist t u
{α : Type u_1} [TopologicalSpace α] {s : Set α} {γ : Type u_4} [LinearOrderedAddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] {f g : α → γ} (hF : LowerSemicontinuousOn f s) (hg : LowerSemicontinuousOn g s) (hcont : ∀ (x : α), x ∈ s → ContinuousAt (λ (p : γ × γ), p.fst + p.snd) (f x, g x)) : LowerSemicontinuousOn (λ (z : α), f z + g z) s
(s : ℂ) (h2 : s ≠ 0) : (s + 1).Gamma = s * s.Gamma
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {f : M →* P} (x : M) : ⇑(Con.ker f) x = ⇑f ⁻¹' {⇑f x}
(R : Type u) [Ring R] [StrongRankCondition R] {ι : Type v} [Fintype ι] {M : ι → Type w} [Π (i : ι), AddCommGroup (M i)] [Π (i : ι), Module R (M i)] [∀ (i : ι), Module.Free R (M i)] [∀ (i : ι), Module.Finite R (M i)] : FiniteDimensional.finrank R (Π (i : ι), M i) = finset.univ.sum (λ (i : ι), FiniteDimensional.finrank R (M i))
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommGroup E] [Module 𝕜 E] {s : Set E} : ConvexIndependent 𝕜 (λ (x : ↥s), ↑x) ↔ ∀ (x : E), x ∈ s → x ∉ ⇑(Convex_hull 𝕜) (s  {x})
{α : Type u} [Group α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1
{α : Type u} {β : Type v} [Preorder α] [SemilatticeSup β] {f g : α → β} (hF : Antitone f) (hg : Antitone g) : Antitone (f ⊔ g)
{α : Type u_1} [UniformSpace α] {s : Set α} {U : Set (α × α)} (hs : Dense s) (hU : U ∈ Uniformity α) : (⋃ (x : α) (H : x ∈ s), UniformSpace.Ball x U) = Set.Univ
{R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [Semiring R] [AddCommMonoid M] [Module R M] [Semiring R₂] [AddCommMonoid M₂] [Module R₂ M₂] {σ₁₂ : R →+* R₂} {s : Set M} {f g : M →ₛₗ[σ₁₂] M₂} (hv : Submodule.span R s = ⊤) (h : Set.EqOn ⇑f ⇑g s) : f = g
 : Irrational (Real.sqrt 2)
{ι : Type u_1} {α : ι → Type u_2} [Fintype ι] : Filter.coprod (λ (i : ι), Filter.cofinite) = Filter.cofinite
{R : Type u} {S : Type v} [Ring R] [Ring S] (f : R →+* S) (hF : Function.Surjective ⇑f) : f.range = ⊤
{α : Type u_1} {β : Type u_2} [Fintype α] [CompleteLattice β] (f : α → β) : finset.univ.inf f = infi f
{C : Type u₁} [CategoryTheory.Category C] {J : Type u₂} [CategoryTheory.Category J] [CategoryTheory.Limits.HasLimitsOfShape Jᵒᵖ C] : CategoryTheory.Limits.HasColimitsOfShape J Cᵒᵖ
{α : Type u₁} {β : Type u₂} [TopologicalSpace α] [UniformSpace β] : Continuous_map.compact_IsOpen = Continuous_map.compact_convergence_topology
{α : Type u} [Preorder α] {f : ℤ → α} (hF : Monotone f) (n : ℤ) {x : α} (h1 : f n < x) (h2 : x < f (n + 1)) (a : ℤ) : f a ≠ x
{α : Type u_1} [TopologicalSpace α] {ι : Type u_2} [Encodable ι] {s : ι → Set α} (hs : ∀ (n : ι), MeasureTheory.AnalyticSet (s n)) : MeasureTheory.AnalyticSet (⋃ (n : ι), s n)
{A : Type u_5} [CommRing A] {m : Type u_6} {n : Type u_7} [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n] {M : Matrix m n A} {M' : Matrix n m A} {N : Matrix n n A} (hMM' : M.mul M' = 1) (hM'M : M'.mul M = 1) : ((M.mul N).mul M').det = N.det
{o : Ordinal} {f : Π (b : Ordinal), b < o → Ordinal → Ordinal} (H : ∀ (i : Ordinal) (hi : i < o), Ordinal.IsNormal (f i hi)) : Set.Unbounded has_lt.lt (⋂ (i : Ordinal) (hi : i < o), Function.FixedPoints (f i hi))
{R : Type u_1} {M : Type u_2} [CommRing R] [AddCommGroup M] [Module R M] (Q : QuadraticForm R M) (n : Zmod2) {P : Π (x : CliffordAlgebra Q), x ∈ clifford_algebra.even_Odd Q n → Prop} (hr : ∀ (v : CliffordAlgebra Q) (h : v ∈ (CliffordAlgebraι Q).range ^ n.val), P v _) (hAdd : ∀ {x y : CliffordAlgebra Q} {hx : x ∈ clifford_algebra.even_Odd Q n} {hy : y ∈ clifford_algebra.even_Odd Q n}, P x hx → P y hy → P (x + y) _) (hιι_Mul : ∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ clifford_algebra.even_Odd Q n}, P x hx → P (⇑(CliffordAlgebraι Q) m₁ * ⇑(CliffordAlgebraι Q) m₂ * x) _) (x : CliffordAlgebra Q) (hx : x ∈ clifford_algebra.even_Odd Q n) : P x hx
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {K : CategoryTheory.GrothendieckTopology D} {A : Type u_7} [CategoryTheory.Category A] {G : C ⥤ D} (H : CategoryTheory.CoverDense K G) [CategoryTheory.Full G] {ℱ ℱ' : CategoryTheory.Sheaf K A} (α : ℱ ⟶ ℱ') (i : CategoryTheory.IsIso (Category_theory.whisker_Left G.op α.val)) : CategoryTheory.IsIso α
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] [IsNoetherian R M] {s : Set M} (hi : LinearIndependent R Coe) : s.finite
{α : Type u} {f : Ultrafilter α} {p : α → Prop} : (∃ᶠ (x : α) in ↑f, p x) → (∀ᶠ (x : α) in ↑f, p x)
{ι : Type u₁} {k : Type u₂} {V : Type u₃} {P : Type u₄} [AddCommGroup V] [AddTorsor V P] [CommRing k] [Module k V] [DecidableEq ι] [Fintype ι] (b b₂ : AffineBasis ι k P) (x : P) : matrix.vec_Mul (⇑(b.coords) x) (b.to_Matrix b₂.points)⁻¹ = ⇑(b₂.coords) x
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} [decι : DecidableEq ι] {v : ι → E} : Orthonormal 𝕜 v ↔ ∀ (i j : ι), HasInner.inner (v i) (v j) = Ite (i = j) 1 0
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] (f : E →L[𝕜] F →L[𝕜] G) : Continuous (Function.uncurry (λ (x : E) (y : F), ⇑(⇑f x) y))
{q : ℚ} (q_Pos : 0 < q) : (GeneralizedContinuedFraction.IntFractPair.of q⁻¹).fr.num < q.num
{α : Type u_1} [HasLt α] {a b : α} (h : a < b) : ¬a ⋖ b → (∃ (c : α), a < c ∧ c < b)
{α : Type u_1} [LinearOrderedField α] {a b : α} (ha : a < 0) (hb : b < 0) : 1 / a < 1 / b ↔ b < a
{R : Type u_1} [NormedRing R] (k : ℕ) {r : ℝ} (hr : 1 < r) : (λ (n : ℕ), ↑n ^ k) =o[filter.at_Top] λ (n : ℕ), r ^ n
(k : Type u_1) (V : Type u_2) {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] (s t : Set P) : affine_Span k (s ∪ t) = affine_Span k s ⊔ affine_Span k t
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.Limits.HasCokernels C] {P Q : C} (f : P ⟶ Q) : CategoryTheory.Abelian.coimageπ f ≫ Category_theory.abelian.factor_thru_coimage f = f
{α : Type u} [EmetricSpace α] [CompleteSpace α] : is_IsClosed (Set.Range topological_space.nonempty_compacts.to_Closeds)
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) (θ : Real.Angle) : x = ⇑(o.rotation θ) x ↔ x = 0 ∨ θ = 0
{ι : Type w} [Fintype ι] (K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [Module.Finite K L] {R : Type z} [CommRing R] [Algebra R K] [Algebra R L] [IsScalarTower R K L] {b : ι → L} (h : ∀ (i : ι), IsIntegral R (b i)) : IsIntegral R (Algebra.discr K b)
{𝕜 : Type u_3} [is_R_or_C 𝕜] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {H : Type u_5} [NormedGroup H] [NormedSpace 𝕜 H] {f : G → H} {f' : G → (G →L[𝕜] H)} {x : G} (hder : ∀ᶠ (y : G) in nhds x, HasFderivAt f (f' y) y) (hcont : ContinuousAt f' x) : HasStrictFderivAt f (f' x) x
{α : Type u_2} {β : Type u_3} {rα : NonAssocSemiring α} {rβ : NonAssocSemiring β} (f : α →+* β) [Nontrivial β] : Nontrivial α
{𝕜 : Type u_3} {E : Type u_4} [SemiNormedRing 𝕜] [AddCommGroup E] [Module 𝕜 E] (p : Seminorm 𝕜 E) (x y : E) : ⇑p x ≤ ⇑p y + ⇑p (x - y)
{β α : Type u} (f : β → α) (w : Cardinal.mk α < Cardinal.mk β) (w' : Cardinal.aleph_0 ≤ Cardinal.mk α) : ∃ (a : α), Cardinal.mk α < Cardinal.mk ↥(f ⁻¹' {a})
{α : sort u_1} (hH : α) {β : Prop} (x : Tactic.CalculatedProp β hH . "derive_elementwise_proof") : β
{R : Type u} [Semiring R] {p : Polynomial R} {n : ℕ} : p.degree ≤ ↑n → p.nat_degree ≤ n
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [OrderedSemiring 𝕜] [AddCommGroup E] [Module 𝕜 E] {p : ι → E} (hc : ConvexIndependent 𝕜 p) : Function.Injective p
{α : Type u} [CompleteLattice α] {J : Type u} [CategoryTheory.SmallCategory J] (F : J ⥤ α) : CategoryTheory.Limits.colimit F = supr F.obj
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f g : α → M} {s : Set α} (hs : s.finite) : finsum (λ (i : α), finsum (λ (H : i ∈ s), f i + g i)) = finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)) + finsum (λ (i : α), finsum (λ (H : i ∈ s), g i))
{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {f : ℝ → E} {f' : E} {s : Set ℝ} {x r : ℝ} (hF : HasDerivWithinAt f f' s x) (hr : ∥f'∥ < r) : ∀ᶠ (z : ℝ) in nhds_within x s, ∥z - x∥⁻¹ * (∥f z∥ - ∥f x∥) < r
{m : Type u} {α : Type v} [CommRing α] [Fintype m] [DecidableEq m] (u v : m → α) : (1 + (Matrix.col u).mul (Matrix.row v)).det = 1 + matrix.dot_Product v u
{α : Type u} {a b : α} [MulOneClass α] [HasZero α] [Preorder α] [ZeroLt.PosMulStrictMono α] (ha : a ≤ 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) : 0 ≤ s.circumradius
{β : Type u} {α : Type v} {γ : Type w} [CommMonoid β] [CommMonoid γ] (g : β →* γ) (f : α → β) (s : Finset α) : ⇑g (s.prod (λ (x : α), f x)) = s.prod (λ (x : α), ⇑g (f x))
{C : Type u} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (F : C ⥤ D) {A A' B B' : C} [CategoryTheory.Limits.HasBinaryProduct A B] [CategoryTheory.Limits.HasBinaryProduct A' B'] [CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)] [CategoryTheory.Limits.HasBinaryProduct (F.obj A') (F.obj B')] (f : A ⟶ A') (g : B ⟶ B') [CategoryTheory.IsIso (Category_theory.limits.prod_comparison F A B)] [CategoryTheory.IsIso (Category_theory.limits.prod_comparison F A' B')] : CategoryTheory.inv (Category_theory.limits.prod_comparison F A B) ≫ F.map (CategoryTheory.Limits.prod.map f g) = CategoryTheory.Limits.prod.map (F.map f) (F.map g) ≫ CategoryTheory.inv (Category_theory.limits.prod_comparison F A' B')
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {s : Set P} (h : affine_Span k s = ⊤) : Vector_Span k s = ⊤
{α : Type u_1} [PseudoEmetricSpace α] {δSeq : ℕ → ℝ} (δSeq_Pos : ∀ (n : ℕ), 0 < δSeq n) (δSeq_lim : Filter.Tendsto δSeq filter.at_Top (nhds 0)) (E : Set α) : Filter.Tendsto (λ (n : ℕ), ⇑(thickened_indicator _ E)) filter.at_Top (nhds ((Closure E).indicator (λ (x : α), 1)))
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (t : Affine.Triangle ℝ P) (i : Fin 3) : affine_Span ℝ {t.orthocenter, t.points i} ≤ Affine.Simplex.altitude t i
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {E' : Type u_4} [NormedGroup E'] [NormedSpace 𝕜 E'] {F' : Type u_5} [NormedGroup F'] [NormedSpace 𝕜 F'] {s : Set E} {t : Set E'} {f : E → F} {g : E' → F'} (hF : ContDiffOn 𝕜 n f s) (hg : ContDiffOn 𝕜 n g t) : ContDiffOn 𝕜 n (Prod.map f g) (s ×ˢ t)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {f : F → G} (hF : ContDiff 𝕜 n f) : ContDiff 𝕜 n (λ (x : E × F), f x.snd)
{α : Type u_1} [DecidableEq α] {s : Finset α} : s.nonempty → s.sym2.nonempty
{M : Type u_4} [TopologicalSpace M] [Monoid M] [HasContinuousMul M] {U : Set M} (hU : U ∈ nhds 1) : ∃ (V : Set M), is_IsOpen V ∧ 1 ∈ V ∧ V * V ⊆ U
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NondiscreteNormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] [NormedGroup F] [NormedSpace 𝕜 F] {p : FormalMultilinearSeries 𝕜 E F} {x : E} (h : HasFpowerSeriesAt 0 p x) (n : ℕ) (y : E) : ⇑(p n) (λ (i : Fin n), y) = 0
{α : Type u} {β : Type v} [PseudoMetricSpace α] [PseudoMetricSpace β] {K : Nnreal} {f : α → β} : LipschitzWith K f → ∀ (x y : α), HasDist.dist (f x) (f y) ≤ ↑K * HasDist.dist x y
(R : Type u) [Ring R] [StrongRankCondition R] {ι : Type v} [Fintype ι] (M : ι → Type w) [Π (i : ι), AddCommGroup (M i)] [Π (i : ι), Module R (M i)] [∀ (i : ι), Module.Free R (M i)] [∀ (i : ι), Module.Finite R (M i)] : FiniteDimensional.finrank R (DirectSum ι (λ (i : ι), M i)) = finset.univ.sum (λ (i : ι), FiniteDimensional.finrank R (M i))
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommMonoid β] [Module 𝕜 E] [HasScalar 𝕜 β] {s : Set E} {f : E → β} (hF : ConcaveOn 𝕜 s f) (c : E) : ConcaveOn 𝕜 ((λ (z : E), c + z) ⁻¹' s) (f ∘ λ (z : E), z + c)
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMinOrder α] [DenselyOrdered α] {a : α} {s : Set α} : s ∈ nhds_within a (Set.Iic a) ↔ ∃ (l : α), l < a ∧ Set.Icc l a ⊆ s
{p a b : ℕ} (hab : a.coprime b) (hpb : p ∈ b.factors) : ⇑((a * b).factorization) p = ⇑(b.factorization) p
{A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] [Nontrivial B] {x : B} (hx : IsIntegral A x) : 0 < (minpoly A x).degree
{g : ℂ →L[ℝ] ℂ} : IsConformalMap g ↔ ((∃ (Map : ℂ →L[ℂ] ℂ), Continuous_Linear_map.restrict_scalars ℝ Map = g) ∨ ∃ (Map : ℂ →L[ℂ] ℂ), Continuous_Linear_map.restrict_scalars ℝ Map = g.comp ↑complex.conj_cle) ∧ g ≠ 0
{α : Type u_1} [HasLe α] {a : α} : IsMin a → IsMax (⇑order_dual.to_dual a)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle (-x) y + hb.oangle (-y) z + hb.oangle (-z) x = ↑Real.pi
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : Real.sin (InnerProductGeometry.angle x y + InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) = 0
(m n : ℕ) : Nat.fib (m.gcd n) = (Nat.fib m).gcd (Nat.fib n)
{p : ℕ+} {K : Type u} (L : Type v) [Field K] [Field L] [Algebra K L] [NeZero ↑↑p] [hpri : Fact (Nat.Prime ↑p)] [hcyc : IsCyclotomicExtension {p} K L] (hirr : Irreducible (Polynomial.cyclotomic ↑p K)) (h : p ≠ 2) : ⇑(Algebra.norm K) (IsCyclotomicExtension.zeta p K L - 1) = ↑p
{α : Type u_1} {E : Type u_3} {F' : Type u_7} [HasNorm E] [SemiNormedGroup F'] {f : α → E} {g' : α → F'} {l : Filter α} : f =o[l] g' → (f =o[l] λ (x : α), -g' x)
(x : ℝ) : Real.sqrt (1 + Real.sinh x ^ 2) = Real.cosh x
{α : Type u_1} [CompleteLattice α] {a : α} {s : Set α} : (⨆ (b : α) (H : b ∈ s), a ⊓ b) ≤ a ⊓ HasSup.sup s
{M : Type u_1} [SemiNormedGroup M] (S : AddSubgroup M) (x : M ⧸ S) : 0 ≤ ∥x∥
{α : Type u} {f g : α → α} (h : Function.Commute f g) : Set.BijOn g (Function.FixedPoints (f ∘ g)) (Function.FixedPoints (f ∘ g))
{i : ℕ} {f g : ℕ → ℝ} (h0 : ∀ (b : ℕ), 0 ≤ f b) (h : ∀ (b : ℕ), f b ≤ g b) (hi : f i < g i) (hg : Summable g) : ∑' (n : ℕ), f n < ∑' (n : ℕ), g n
{α : Type u} [TopologicalSpace α] {S U Z : Set α} (hZ : IsPreirreducible Z) (hU : U.nonempty) (hU' : is_IsOpen U) (h₁ : U ⊆ S) (h₂ : S ⊆ Z) : IsIrreducible S
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] [t1_Space β] {f : α → β} {a : α} {b : β} (h : Filter.Tendsto f (nhds a) (nhds b)) : ContinuousAt f a
{n : Type u} [DecidableEq n] [Fintype n] {α : Type v} [CommRing α] (A : Matrix n n α) {β : Type u_1} (s : Finset β) (f : β → n → α) : s.sum (λ (x : β), ⇑(A.cramer) (f x)) = ⇑(A.cramer) (s.sum (λ (x : β), f x))
{M : Type u_3} {N : Type u_4} [has_Add M] [has_Add N] (f : AddHom M N) {x y : M} (h : x = y) : ⇑f x = ⇑f y
(p : ℕ) [Fact (Nat.Prime p)] (hp : p ≠ 2) : zmod.legendre_Sym p (-1) = ⇑Zmodχ₄ ↑p
{J : Type u₁} [CategoryTheory.Category J] [CategoryTheory.IsPreconnected J] (p : Set J) {j₀ : J} (h0 : j₀ ∈ p) (h1 : ∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → (j₁ ∈ p ↔ j₂ ∈ p)) (j : J) : j ∈ p
{α : Type u} [MulOneClass α] [HasDistribNeg α] (a : α) : a * -1 = -a
{G : Type u_1} [Group G] [TopologicalSpace G] [TopologicalGroup G] [t2_Space G] {K₀ : TopologicalSpace.PositiveCompacts G} (g : G) (K : TopologicalSpace.Compacts G) : ⇑(measure_theory.measure.haar.haar_content K₀) (TopologicalSpace.Compacts.map (λ (b : G), g * b) _ K) = ⇑(measure_theory.measure.haar.haar_content K₀) K
{α : Type u} [OrderedSemiring α] [Nontrivial α] : 0 < 3
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} {f' : ℝ → E} {C : ℝ} (hF : ∀ (x : ℝ), x ∈ Set.Icc a b → HasDerivWithinAt f (f' x) (Set.Icc a b) x) (bound : ∀ (x : ℝ), x ∈ Set.Ico a b → ∥f' x∥ ≤ C) (x : ℝ) (H : x ∈ Set.Icc a b) : ∥f x - f a∥ ≤ C * (x - a)
{ι : Type u_1} {α : Type u_2} {s : ι → Set α} (hs : IndexedPartition s) (x : hs.quotient) : hs.index (quotient.out' x) = hs.index (⇑(hs.out) x)
{n : ℕ} {i₁ i₂ : Fin (n + 3)} (h : i₁ ≠ i₂) : affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter i₁ i₂ = affine.simplex.monge_point_weights_with_circumcenter n - affine.simplex.centroid_weights_with_circumcenter {i₁, i₂}ᶜ
{α : Type u_1} [LinearOrder α] (a : α) : {a}.max' _ = a
{f : ℕ →. ℕ} : Nat.Partrec f ↔ ∃ (c : Nat.Partrec.Code), c.eval = f
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {a₁ a₂ a₃ : α} {b₁ b₂ b₃ : β} (q₁ : Path.Homotopic.Quotient a₁ a₂) (q₂ : Path.Homotopic.Quotient b₁ b₂) (r₁ : Path.Homotopic.Quotient a₂ a₃) (r₂ : Path.Homotopic.Quotient b₂ b₃) : (Path.Homotopic.prod q₁ q₂).comp (Path.Homotopic.prod r₁ r₂) = Path.Homotopic.prod (q₁.comp r₁) (q₂.comp r₂)
{C : Type u₁} [CategoryTheory.Category C] {X Y Z : C} {c : CategoryTheory.Limits.BinaryFan X Y} (h : CategoryTheory.Limits.IsLimit c) (t : CategoryTheory.Limits.IsTerminal Z) : CategoryTheory.IsPullback c.fst c.snd (t.from ((CategoryTheory.Limits.pair X Y).obj {as := CategoryTheory.Limits.WalkingPair.left})) (t.from ((CategoryTheory.Limits.pair X Y).obj {as := CategoryTheory.Limits.WalkingPair.right}))
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] [LocallyCompactSpace α] : Continuous (λ (p : C(α, β) × α), ⇑(p.fst) p.snd)
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : Real.cos (InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) = -Real.cos (InnerProductGeometry.angle x y)
{R : Type u_1} {a : R} [AddSemigroup R] (b : R) (ha : IsAddLeftRegular a) : IsAddLeftRegular (a + b) ↔ IsAddLeftRegular b
{α : Type u} [PseudoMetricSpace α] (B : ℕ → ℝ) (hB : ∀ (n : ℕ), 0 < B n) (H : ∀ (u : ℕ → α), (∀ (N n m : ℕ), N ≤ n → N ≤ m → HasDist.dist (u n) (u m) < B N) → (∃ (x : α), Filter.Tendsto u filter.at_Top (nhds x))) : CompleteSpace α
{E : Type u_2} [SemiNormedGroup E] [NormedSpace ℝ E] {s : Set E} {x : E} (hx : x ∈ ⇑(Convex_hull ℝ) s) (y : E) : ∃ (x' : E) (H : x' ∈ s), HasDist.dist x y ≤ HasDist.dist x' y
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [NondiscreteNormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (f g : ContinuousMultilinearMap 𝕜 E G) : ∥f + g∥ ≤ ∥f∥ + ∥g∥
{G : Type w} [TopologicalSpace G] [has_Inv G] [HasMul G] [HasContinuousMul G] (g : G) : Continuous (λ (h : G), g * h * g⁻¹)
{α : Type u_1} [MetricSpace α] (t : Set (Set α)) (R : ℝ) (ht : ∀ (s : Set α), s ∈ t → (∃ (x : α) (r : ℝ), s = Metric.ClosedBall x r ∧ r ≤ R)) : ∃ (u : Set (Set α)) (H : u ⊆ t), u.pairwise_Disjoint Id ∧ ∀ (a : Set α), a ∈ t → (∃ (x : α) (r : ℝ), Metric.ClosedBall x r ∈ u ∧ a ⊆ Metric.ClosedBall x (5 * r))
{𝕜 : Type u_1} [LinearOrderedField 𝕜] {x y : 𝕜} (h : x < y) {z : 𝕜} : z ∈ Set.Ico x y ↔ ∃ (a b : 𝕜), 0 < a ∧ 0 ≤ b ∧ a + b = 1 ∧ a * x + b * y = z
{R : Type u₁} [Monoid R] [HasDistribNeg R] (a : R) : (-a) ^ 2 = a ^ 2
{R : Type u_1} {M : Type u_2} [CommSemiring R] [AddCommMonoid M] [Module R M] [NoZeroDivisors R] [Nontrivial R] : NoZeroSmulDivisors R M ↔ Submodule.torsion R M = ⊥
{E : ℕ → Type u_1} [Π (n : ℕ), TopologicalSpace (E n)] [∀ (n : ℕ), DiscreteTopology (E n)] {x y : Π (n : ℕ), E n} {s : Set (Π (n : ℕ), E n)} (hs : is_IsClosed s) (hne : s.nonempty) (H : Pi_nat.longest_prefix x s < Pi_nat.first_Diff x y) (xs : x ∉ s) (ys : y ∉ s) : PiNat.Cylinder x (Pi_nat.longest_prefix x s) = PiNat.Cylinder y (Pi_nat.longest_prefix y s)
{α : Type u_1} {β : Type u_2} {e e' : LocalEquiv α β} (hE : e ≈ e') (s : Set α) : e.restr s ≈ e'.restr s
{R : Type x} [CommRing R] (a b : R) : a * a - b * b = (a + b) * (a - b)
{M₀ : Type u_1} {M₀' : Type u_3} [HasMul M₀] [HasZero M₀] [HasMul M₀'] [HasZero M₀'] [NoZeroDivisors M₀'] (f : M₀ → M₀') (hF : Function.Injective f) (Zero : f 0 = 0) (Mul : ∀ (x y : M₀), f (x * y) = f x * f y) : NoZeroDivisors M₀
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] [LocallyCompactSpace α] [LocallyCompactSpace β] : Continuous ContinuousMap.uncurry
{α : Type u_1} {n : Type u_4} [AddGroup n] {v : n → α} (h : (Matrix.circulant v).is_Symm) (i : n) : v (-i) = v i
{α : Type u} {a : Set α} (h : a.finite) : {b : Set α | b ⊆ a}.finite
{α : Type u_1} {ι : sort u_2} [Nonempty ι] (m : ι → MeasureTheory.OuterMeasure α) (s : Set α) : (⇑⨅ (i : ι), m i) s = ⨅ (t : ℕ → Set α) (h2 : s ⊆ Set.Union t), ∑' (n : ℕ), ⨅ (i : ι), ⇑(m i) (t n)
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] (c : AddCon M) (f : M →+ P) (H : c ≤ AddCon.ker f) (h : Function.Injective ⇑(c.lift f H)) : AddCon.ker f = c
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] {A B C : Matrix n n α} (h : A.mul B = 1) (g : A.mul C = 1) : B = C
{α : Type u} (f : Filter α) [h : f.ne_IsBot] : ∃ (u : Ultrafilter α), ↑u ≤ f
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y : V} (h : hb.oangle x y = 0) : x = y ↔ ∥x∥ = ∥y∥
{G : Type u_1} [TopologicalSpace G] [Group G] [TopologicalGroup G] (N : Subgroup G) [N.normal] : N.topological_closure.normal
{ι : Type u_1} {R : Type u_3} {M : Type u_5} {v : ι → M} [Ring R] [AddCommGroup M] [Module R M] : LinearIndependent R v → Function.Injective ⇑(Finsupp.total ι M R v)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {s1 s2 : AffineSubspace k P} (h : s1 < s2) : ∃ (p : P) (H : p ∈ s2), p ∉ s1
{α : Type u} {β : Type v} [Preorder α] [Preorder β] {f : α → β} {s : Set α} : MonotoneOn f s → AntitoneOn (⇑order_dual.to_dual ∘ f) s
(K : Type u) [DivisionRing K] {n : ℕ} : FiniteDimensional.finrank K (Fin n → K) = n
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] (p : P) : p -ᵥ p = 0
{α : Type u_1} [HasMul α] [Preorder α] [CovariantClass α α has_mul.mul has_le.le] [CovariantClass α α (Function.swap has_mul.mul) has_lt.lt] {a b c d : α} (h₁ : a < b) (h₂ : c < d) : a * c < b * d
{α : Type u} [PseudoMetricSpace α] [Preorder α] [CompactIccSpace α] {s : Set α} (h₁ : BddAbove s) (h₂ : BddBelow s) : Metric.Bounded s
{M : Type u_1} [AddMonoid M] {x : M} (m : ℕ) {n : ℕ} (h : n • x = 0) : m • x = (m % n) • x
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : HasInner.inner (x - y) (x - y) = HasInner.inner x x - 2 * HasInner.inner x y + HasInner.inner y y
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] [CompleteSpace F] [CompleteSpace E] (g : E →ₗ[𝕜] F) (hg : ∀ (u : ℕ → E) (x : E) (y : F), Filter.Tendsto u filter.at_Top (nhds x) → Filter.Tendsto (⇑g ∘ u) filter.at_Top (nhds y) → y = ⇑g x) : Continuous ⇑g
{C : Type u} [CategoryTheory.Category C] {X : C} (P : Cᵒᵖ ⥤ Type v) (R S : CategoryTheory.Sieve X) (hR : CategoryTheory.Presieve.IsSheafFor P ⇑R) (hR' : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, ⇑S f → CategoryTheory.Presieve.IsSeparatedFor P ⇑(CategoryTheory.Sieve.pullback f R)) (hS : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, ⇑R f → CategoryTheory.Presieve.IsSheafFor P ⇑(CategoryTheory.Sieve.pullback f S)) : CategoryTheory.Presieve.IsSheafFor P ⇑S
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {c : ℝ} {f : α → E} {g : α → F} {l : Filter α} : asymptotics.is_O_with c l f g ↔ ∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥
{R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [Π (i : ι), Module R (M₁ i)] [Module R M₂] (f : MultilinearMap R M₁ M₂) {α : ι → Type u_1} (g : Π (i : ι), α i → M₁ i) (A : Π (i : ι), Finset (α i)) [Fintype ι] {n : ℕ} (h : finset.univ.sum (λ (i : ι), (A i).card) = n) : ⇑f (λ (i : ι), (A i).sum (λ (j : α i), g i j)) = (fintype.pi_Finset A).sum (λ (r : Π (a : ι), α a), ⇑f (λ (i : ι), g i (r i)))
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X ⟶ Y} {c : CategoryTheory.Limits.Cofork f g} (h : CategoryTheory.Limits.IsColimit c) [CategoryTheory.Mono c.π] : CategoryTheory.IsIso c.π
{M : Type u_3} {N : Type u_4} [AddMonoid M] [AddMonoid N] (f : M →+ N) (l : List M) : ⇑f l.sum = (List.map ⇑f l).sum
{α : Type u_1} (P : α → Prop) (r : α → α → Prop) [IsSymm α r] (h : ∀ (s : Finset α), (∀ (x : α), x ∈ s → P x) → (∃ (y : α), P y ∧ ∀ (x : α), x ∈ s → r x y)) : ∃ (f : ℕ → α), (∀ (n : ℕ), P (f n)) ∧ ∀ (m n : ℕ), m ≠ n → r (f m) (f n)
(p : ℕ) [Fact (Nat.Prime p)] (x : (Zmod p)ˣ) : (∃ (y : (Zmod p)ˣ), y ^ 2 = x) ↔ x ^ (p / 2) = 1
{B : Type u} [Quiver B] {a b c : B} (p : Quiver.Path a b) {f g : CategoryTheory.FreeBicategory.Hom b c} (η : f ⟶ g) : Category_theory.free_bicategory.normalize_aux p f = Category_theory.free_bicategory.normalize_aux p g
{r : ℝ} (tr : Transcendental ℚ r) : Irrational r
{E : Type u_2} [AddCommGroup E] [Module ℝ E] (s : ConvexCone ℝ E) (f : LinearPmap ℝ E ℝ) (nonneg : ∀ (x : ↥(f.domain)), ↑x ∈ s → 0 ≤ ⇑f x) (Dense : ∀ (y : E), ∃ (x : ↥(f.domain)), ↑x + y ∈ s) : ∃ (g : E →ₗ[ℝ] ℝ), (∀ (x : ↥(f.domain)), ⇑g ↑x = ⇑f x) ∧ ∀ (x : E), x ∈ s → 0 ≤ ⇑g x
{α : Type u_1} {M : Type u_5} [AddCommMonoid M] {f : α → M} {s : Set α} (p : M → Prop) (hp₀ : p 0) (hp₁ : ∀ (x y : M), p x → p y → p (x + y)) (hp₂ : ∀ (x : α), x ∈ s → p (f x)) : p (finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)))
{M : Type u_1} [AddMonoid M] {x y z : M} : y ∈ Multiples x → z ∈ Multiples x → y + z ∈ Multiples x
{n : ℕ} {E : Type u_1} [NormedGroup E] (a : E) (c : Fin n → ℂ) (R : Fin n → ℝ) : TorusIntegrable (λ (_x : Fin n → ℂ), a) c R
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) (θ : Real.Angle) : hb.oangle (⇑(hb.rotation θ) x) (⇑(hb.rotation θ) y) = hb.oangle x y
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {x : E} {r : 𝕜} (hx : x ≠ 0) (hr : r ≠ 0) : is_R_or_C.abs (HasInner.inner x (r • x)) / (∥x∥ * ∥r • x∥) = 1
{α : Type u_1} {M : Type u_5} {N : Type u_7} [HasZero M] [AddCommMonoid N] [DecidableEq α] (f : α →₀ M) (a : α) (b : α → M → N) : f.sum (λ (x : α) (v : M), Ite (x = a) (b x v) 0) = Ite (a ∈ f.support) (b a (⇑f a)) 0
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x : V) {r : ℝ} (hr : 0 ≤ r) : hb.oangle x (r • x) = 0
{α : Type u} [Group α] [HasLe α] [CovariantClass α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1
{R : Type u_1} [LinearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {x y : M} (h : SameRay R x y) (hx : x ≠ 0) : ∃ (r : R), 0 ≤ r ∧ r • x = y
{L : FirstOrder.Language} (M : Type w') [L.Structure M] [im : Infinite M] (κ : Cardinal) (h1 : L.card.lift ≤ κ.lift) (h2 : (Cardinal.mk M).lift ≤ κ.lift) : ∃ (N : CategoryTheory.Bundled L.Structure), Nonempty (L.elementary_Embedding M ↥N) ∧ Cardinal.mk ↥N = κ.lift
{α : Type u} {β : Type v} : (Cardinal.mk α).lift ≤ (Cardinal.mk β).lift ↔ Nonempty (α ↪ β)
{α : Type u} [PseudoMetricSpace α] {s : Set α} : metric.Hausdorff_dist ∅ s = 0
{K : Type v} {V : Type w} [Field K] [AddCommGroup V] [Module K V] (f : Module.End K V) : CompleteLattice.Independent f.eigenspace
{C : Type u₁} [CategoryTheory.Category C] {A : Type u₂} [CategoryTheory.Category A] (P : Cᵒᵖ ⥤ A) {X : C} (S : CategoryTheory.Sieve X) : (∀ (c : CategoryTheory.Limits.Cone (S.arrows.diagram.op ⋙ P)), Subsingleton (c ⟶ P.map_cone S.arrows.cocone.op)) ↔ ∀ (E : Aᵒᵖ), CategoryTheory.Presieve.IsSeparatedFor (P ⋙ Category_theory.coyoneda.obj E) ⇑S
(L : List ℕ) : L.head + L.tail.sum = L.sum
{a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) : (a * b).factors ~ a.factors ++ b.factors
{𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_6} [SemiNormedGroup E] [SemiNormedGroup F] [NondiscreteNormedField 𝕜] [NondiscreteNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [RingHomIsometric σ₁₂] (f : E →sl[σ₁₂] F) (x : E) : ∥⇑f x∥ ≤ ∥f∥ * ∥x∥
{α : Type u} {a b : α} [MulOneClass α] [HasZero α] [Preorder α] [ZeroLt.PosMulStrictMono α] (ha : 1 < a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b
{ι : Type u} (s : Finset ι) {f : ι → ℝ} {p : ℝ} (hp : 1 ≤ p) (hF : ∀ (i : ι), i ∈ s → 0 ≤ f i) : s.sum (λ (i : ι), f i) ^ p ≤ ↑(s.card) ^ (p - 1) * s.sum (λ (i : ι), f i ^ p)
{M : Type u_2} [AddCommGroup M] {ι : Type u_4} [DecidableEq ι] [Fintype ι] {A : Type u_5} [CommRing A] [Module A M] {κ : Type u_6} [Fintype κ] [DecidableEq κ] (b : Basis ι A M) (c : Basis κ A M) (f : M →ₗ[A] M) : (⇑(Linear_map.to_Matrix b b) f).det = (⇑(Linear_map.to_Matrix c c) f).det
{α : Type u_1} (r : α → α → Prop) [IsRefl α r] [IsTrans α r] {s : Set α} (h : s.partially_well_ordered_on r) : {l : List α | ∀ (x : α), x ∈ l → x ∈ s}.partially_well_ordered_on (list.sublist_forall₂ r)
{C : Type u} [CategoryTheory.Category C] {D : Type u_1} [CategoryTheory.Category D] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasZeroObject C] [CategoryTheory.Limits.HasEqualizers C] [CategoryTheory.Limits.HasImages C] [CategoryTheory.HasProjectiveResolutions C] [CategoryTheory.Preadditive D] [CategoryTheory.Limits.HasZeroObject D] [CategoryTheory.Limits.HasEqualizers D] [CategoryTheory.Limits.HasCokernels D] [CategoryTheory.Limits.HasImages D] [CategoryTheory.Limits.HasImageMaps D] (F : C ⥤ D) [F.additive] (n : ℕ) {X Y : C} (f : X ⟶ Y) {P : CategoryTheory.ProjectiveResolution X} {Q : CategoryTheory.ProjectiveResolution Y} (g : P.complex ⟶ Q.complex) (w : g ≫ Q.π = P.π ≫ (chain_complex.single₀ C).map f) : (F.left_derived n).map f = (F.left_derived_obj_iso n P).hom ≫ (homology_Functor D (ComplexShape.down ℕ) n).map ((F.map_HomologicalComplex (ComplexShape.down ℕ)).map g) ≫ (F.left_derived_obj_iso n Q).inv
{n : ℕ} {β : Type u_1} (a : β) (q : Fin n → β) (b : β) : fin.cons a (fin.snoc q b) = fin.snoc (fin.cons a q) b
{m n : ℕ} (hmn : m.coprime n) : Squarefree (m * n) ↔ Squarefree m ∧ Squarefree n
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (p1 : P) {p2 p3 p4 : P} (h : EuclideanGeometry.angle p2 p3 p4 = Real.pi) : EuclideanGeometry.angle p1 p3 p2 + EuclideanGeometry.angle p1 p3 p4 = Real.pi
{J : Type u₁} [CategoryTheory.Category J] {K : Type u₂} [CategoryTheory.Category K] {C : Type u} [CategoryTheory.Category C] {F : J ⥤ C} [CategoryTheory.Limits.HasColimit F] {E : K ⥤ J} [CategoryTheory.Limits.HasColimit (E ⋙ F)] (s : CategoryTheory.Limits.ColimitCocone (E ⋙ F)) (t : CategoryTheory.Limits.ColimitCocone F) : CategoryTheory.Limits.colimit.pre F E = (Category_theory.limits.colimit.iso_ColimitCocone s).hom ≫ s.is_colimit.desc (CategoryTheory.Limits.Cocone.whisker E t.cocone) ≫ (Category_theory.limits.colimit.iso_ColimitCocone t).inv
(C : Type u) [CategoryTheory.Category C] [CategoryTheory.Limits.HasCoproducts C] : CategoryTheory.Limits.HasFiniteCoproducts C
{R : Type u_4} {S : Type u_5} [HasMul R] [has_Add R] [HasMul S] [has_Add S] (e : R ≃+* S) (x y : R) : ⇑e (x * y) = ⇑e x * ⇑e y
{α : Type u} (s : Seq α) {aₙ : α} {n m : ℕ} (m_LE_n : m ≤ n) (s_nth_Eq_Some : s.nth n = Option.some aₙ) : ∃ (aₘ : α), s.nth m = Option.some aₘ
{α : Type u} [PseudoMetricSpace α] {s : Set α} {f : α → ℝ} (K : ℝ) (h : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → f x ≤ f y + K * HasDist.dist x y) : LipschitzOnWith K.to_Nnreal f s
{n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n
{α : Type u} [UniformSpace α] (h : IsComplete Set.Univ) : CompleteSpace α
{α : Type u_1} [Preorder α] [LocallyFiniteOrder α] {a b : α} : ¬a < b → Multiset.ico a b = 0
{R : Type u} {ι : Type u'} {M₁ : ι → Type v₁} {M₂ : Type v₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [Π (i : ι), Module R (M₁ i)] [Module R M₂] (f : MultilinearMap R M₁ M₂) (m m' : Π (i : ι), M₁ i) (t : Finset ι) : ⇑f (t.piecewise (m + m') m') = t.powerset.sum (λ (s : Finset ι), ⇑f (s.piecewise m m'))
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {f : α → γ} {x : α × β} (hF : ContinuousAt f x.fst) : ContinuousAt (λ (x : α × β), f x.fst) x
{p : ℕ} (hp : Nat.Prime p) {R : Type u_1} [CommRing R] [is_IsDomain R] {n m : ℕ} (hmn : m ≤ n) (h : Irreducible (Polynomial.cyclotomic (p ^ n) R)) : Irreducible (Polynomial.cyclotomic (p ^ m) R)
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] : 0 < FiniteDimensional.finrank K V ↔ ∃ (x : V), x ≠ 0
{ι : Type u_1} {R : Type u_3} [Ring R] {M : Type u_2} [AddCommGroup M] [Module R M] {v : ι → M} (li : LinearIndependent R v) (c d : R) (i j : ι) (hc : c ≠ 0) (h : c • v i = d • v j) : i = j
{α : Type u} [SemilatticeInf α] [OrderTop α] {x y z : α} (f : x ⟶ z) (g : y ⟶ z) : CategoryTheory.Limits.pullback f g = x ⊓ y
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [BaireSpace α] {S : Set β} {f : Π (x : β), x ∈ S → Set α} (ho : ∀ (s : β) (H : s ∈ S), is_Gδ (f s H)) (hS : S.countable) (hD : ∀ (s : β) (H : s ∈ S), Dense (f s H)) : Dense (⋂ (s : β) (H : s ∈ S), f s H)
{α : Type u_1} [MetricSpace α] {β : Type u} [Nonempty β] (p : Besicovitch.TauPackage β α) {i : Ordinal} (hi : i < p.last_step) {N : ℕ} (hN : IsEmpty (Besicovitch.SatelliteConfig α N p.τ)) : p.color i < N
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} (x : E) {v : ι → E} (hv : Orthonormal 𝕜 v) : Summable (λ (i : ι), ∥HasInner.inner (v i) x∥ ^ 2)
{X : Type u_1} [TopologicalSpace X] [SequentialSpace X] {s : Set X} {a : X} : a ∈ Closure s ↔ ∃ (x : ℕ → X), (∀ (n : ℕ), x n ∈ s) ∧ Filter.Tendsto x filter.at_Top (nhds a)
{R : Type u} {S : Type v} [Ring R] [Ring S] {f g : R →+* S} {s : Set R} (h : Set.EqOn ⇑f ⇑g s) : Set.EqOn ⇑f ⇑g ↑(Subring.closure s)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p : ι → P) {i : ι} (his : i ∈ s) (hwi : w i = 1) (hw0 : ∀ (i2 : ι), i2 ∈ s → i2 ≠ i → w i2 = 0) : ⇑(s.affine_combination p) w = p i
{α : Type u} [PseudoEmetricSpace α] {f : ℕ → α} (n : ℕ) {d : ℕ → Ennreal} (hD : ∀ {k : ℕ}, k < n → HasEdist.edist (f k) (f (k + 1)) ≤ d k) : HasEdist.edist (f 0) (f n) ≤ (Finset.range n).sum (λ (i : ℕ), d i)
{T : ℝ} {g : ℝ → ℝ} (hg : Function.Periodic g T) (h_Int : ∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.MeasureSpace.volume t₁ t₂) (h₀ : 0 < ∫ (x : ℝ) in 0..T, g x) (hT : 0 < T) : Filter.Tendsto (λ (t : ℝ), ∫ (x : ℝ) in 0..t, g x) filter.at_Top filter.at_Top
{p : ℕ} [p_Prime : Fact (Nat.Prime p)] {a : ℤ} : multiplicity.Finite ↑p a ↔ a ≠ 0
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : HasInner.inner x y = -(∥x∥ * ∥y∥) ↔ InnerProductGeometry.angle x y = Real.pi
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] {a : F} (ha : a ≠ 0) : char.quadratic_Char F a ^ 2 = 1
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {ι : Type u_5} [DecidableEq ι] [Fintype ι] (g : G →L[𝕜] E) : IsBoundedLinearMap 𝕜 (λ (f : ContinuousMultilinearMap 𝕜 (λ (i : ι), E) F), f.comp_ContinuousLinearMap (λ (_x : ι), g))
{K : Type u_1} {v : K} {n : ℕ} [LinearOrderedField K] [FloorRing K] {ifp_n : GeneralizedContinuedFraction.IntFractPair K} (nth_Stream_Eq : GeneralizedContinuedFraction.IntFractPair.stream v n = Option.some ifp_n) : 0 ≤ ifp_n.fr ∧ ifp_n.fr < 1
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) : IsUnit A ↔ IsUnit A.det
{α : Type u_1} (f : Set α → α) : ¬Function.Injective f
{R : Type u_2} [CommRing R] [is_IsDomain R] [Fintype R] {f g : Polynomial R} (hF2 : f.degree = 2) (hg2 : g.degree = 2) (hR : Fintype.card R % 2 = 1) : ∃ (a b : R), Polynomial.eval a f + Polynomial.eval b g = 0
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} {s₁ s₂ : Affine.Simplex ℝ P n} (h : Set.Range s₁.points = Set.Range s₂.points) : s₁.monge_point = s₂.monge_point
{α : Type u_1} [Preorder α] [SuccOrder α] {a : α} : ¬IsMax a → a < Order.succ a
{R : Type u_4} {S : Type u_5} [Semiring R] [Semiring S] (f : R ≃+* Sᵐᵒᵖ) (l : List R) : MulOpposite.unop (⇑f l.prod) = (List.map (MulOpposite.unop ∘ ⇑f) l).reverse.prod
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] {f : X → Y} [SequentialSpace X] : SeqContinuous f → Continuous f
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {m n : WithTop ℕ} {s : Set E} {f : E → F} (hF : ContDiffOn 𝕜 n f s) (hs : UniqueDiffOn 𝕜 s) (hmn : m + 1 ≤ n) : ContDiffOn 𝕜 m (λ (p : E × E), ⇑(fderiv_within 𝕜 f s p.fst) p.snd) (s ×ˢ Set.Univ)
(G : Type u_1) [AddMonoid G] : ¬Add_monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 0 ∧ IsOfFinAddOrder g
{G : Type u} [Fintype G] [AddLeftCancelMonoid G] (x : G) : 0 < Add_order_of x
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p : ι → P) : ⇑(s.weighted_vsub p) w = s.sum (λ (i : ι), w i • (p i -ᵥ Classical.choice AddTorsor.nonempty))
{M : Type u_1} [HasMul M] (s : Set M) {p : Π (x : M), x ∈ Subsemigroup.closure s → Prop} (Hs : ∀ (x : M) (h : x ∈ s), p x _) (hMul : ∀ (x : M) (hx : x ∈ Subsemigroup.closure s) (y : M) (hy : y ∈ Subsemigroup.closure s), p x hx → p y hy → p (x * y) _) {x : M} (hx : x ∈ Subsemigroup.closure s) : p x hx
{α : Type u} [PseudoMetricSpace α] {s t : Set α} (hs : s.nonempty) (bs : Metric.Bounded s) (ht : t.nonempty) (bt : Metric.Bounded t) : metric.Hausdorff_dist s t ≤ Metric.diam (s ∪ t)
{τ : Type u_1} {α : Type u_2} {β : Type u_3} [TopologicalSpace β] (f : Filter τ) (ϕ : τ → α → β) (x : α) (y : β) : y ∈ OmegaLimit f ϕ {x} ↔ MapClusterPt y f (λ (t : τ), ϕ t x)
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α (Function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0
{M : Type u_1} [HasMul M] {s : Set M} : s ⊆ ↑(Subsemigroup.closure s)
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [LinearOrderedAddCommMonoid β] [HasScalar 𝕜 E] [Module 𝕜 β] [OrderedSmul 𝕜 β] {s : Set E} {f g : E → β} (hF : ConvexOn 𝕜 s f) (hg : ConvexOn 𝕜 s g) : ConvexOn 𝕜 s (f ⊔ g)
{α : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [SemiNormedGroup E] [SemiNormedGroup F] [SemiNormedGroup G] {f : α → E} {g : α → F} {l : Filter α} (hF : Filter.Tendsto f l (nhds 0)) (hg : Filter.IsBoundedUnder has_le.le l (HasNorm.norm ∘ g)) (Op : E → F → G) (h_Op : ∃ (A : ℝ), ∀ (x : E) (y : F), ∥Op x y∥ ≤ A * ∥x∥ * ∥y∥) : Filter.Tendsto (λ (x : α), Op (f x) (g x)) l (nhds 0)
(m : ℕ) : padic_val_rat m 0 = 0
{M : Type u_1} [has_Add M] {c : AddCon M} (x y : M) : ↑(x + y) = ↑x + ↑y
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (f : C(α × β, γ)) : Continuous f.curry'
{E : Type u_1} [AddCommGroup E] [Module ℝ E] {s : Set E} : gauge s 0 = 0
{α : Type u_1} {β : Type u_2} {δ : Type u_4} [AddCommMonoid α] [TopologicalSpace α] [t2_Space α] [CompleteLattice β] (m : β → α) (m0 : m ⊥ = 0) (R : α → α → Prop) (m_supr : ∀ (s : ℕ → β), R (m (⨆ (i : ℕ), s i)) (∑' (i : ℕ), m (s i))) (s : δ → β) (t : Finset δ) : R (m (⨆ (d : δ) (H : d ∈ t), s d)) (t.sum (λ (d : δ), m (s d)))
{α : Type u} {β : Type v} : (Cardinal.mk α).lift = (Cardinal.mk β).lift ↔ Nonempty (α ≃ β)
{α : Type u_1} [CancelCommMonoidWithZero α] [UniqueFactorizationMonoid α] [NormalizationMonoid α] [DecidableEq α] {n : α} : (factorization n).support = (Unique_factorization_monoid.normalized_Factors n).to_Finset
{α : Type u_2} [DecidableEq α] [has_div α] {u : Finset α} {s t : Set α} : ↑u ⊆ s / t → (∃ (s' t' : Finset α), ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' / t')
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} (h : ∥x∥ = ∥y∥) : InnerProductGeometry.angle x (x - y) = InnerProductGeometry.angle y (y - x)
(F : Type u_1) [Field F] {E : Type u_2} [Field E] [Algebra F E] (S T : Set E) : ↑(IntermediateField.adjoin ↥(IntermediateField.adjoin F S) T) = IntermediateField.adjoin F (S ∪ T)
{R : Type u_1} [Semiring R] {x y : R} (h : Commute x y) (n : ℕ) : (x + y) ^ n = (Finset.Nat.antidiagonal n).sum (λ (m : ℕ × ℕ), n.choose m.fst • (x ^ m.fst * y ^ m.snd))
{α : sort u_1} {s₁ : Setoid α} {p : Quotient s₁ → Prop} (q : Quotient s₁) (h : ∀ (a : α), p (Quotient.mk' a)) : p q
{ι : Type u_1} {R : Type u_2} {N : Type u_5} [decι : DecidableEq ι] [Ring R] [AddCommGroup N] [Module R N] {p : ι → Submodule R N} (h : CompleteLattice.Independent p) : Function.Injective ⇑(⇑(Dfinsupp.lsum ℕ) (λ (i : ι), (p i).subtype))
{α : Type u_2} {β : Type u_3} {rα : NonAssocSemiring α} {rβ : NonAssocSemiring β} (f : α →+* β) (a b : α) : ⇑f (a * b) = ⇑f a * ⇑f b
{α : Type u_1} (L : List (List α)) {i j : ℕ} (hi : i < L.length) (hj : j < (L.nth_LE i hi).length) : (List.take i (List.map List.length L)).sum + j < (List.take (i + 1) (List.map List.length L)).sum
{α : sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop} : (∃ (x : α) (h : p x), q x h) ↔ ∃ (x : {a // p a}), q ↑x _
{p : ℕ} [Fact (Nat.Prime p)] (x : Zmod p) : x ^ p = x
{M : Type u_1} {N : Type u_2} [has_Add M] [has_Add N] {c : AddCon M} {d : AddCon N} {C : c.quotient → d.quotient → Prop} (p : c.quotient) (q : d.quotient) (H : ∀ (x : M) (y : N), C ↑x ↑y) : C p q
{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} [TopologicalSpace β] [TopologicalSpace.PseudoMetrizableSpace β] (u : Filter ι) [u.ne_IsBot] [u.is_countably_generated] {f : ι → α → β} {g : α → β} (hF : ∀ (i : ι), MeasureTheory.StronglyMeasurable (f i)) (lim : Filter.Tendsto f u (nhds g)) : MeasureTheory.StronglyMeasurable g
{α : Type u} (p : α → Prop) [DecidablePred p] (as : List α) : (list.zip_with has_append.append (list.split_on_p p as) (List.map (λ (x : α), [x]) (List.filter p as) ++ [List.nil])).join = as
{M : Type u_1} [has_Add M] (c : AddCon M) (x : M) : ⇑c x x
{α : Type u_1} [CanonicallyOrderedAddMonoid α] [HasSub α] [HasOrderedSub α] {a b c : α} (h : c ≤ b) (h2 : a - c < b - c) : a < b
(S : Set ℝ) (hS : ∀ (x : ℝ), x ∈ S → x ≤ 0) : HasSup.sup S ≤ 0
{α : Type u} [TopologicalSpace α] {s t : Set α} (H : IsPreconnected s) (Kst : s ⊆ t) (Ktcs : t ⊆ Closure s) : IsPreconnected t
{X : Type u_2} [EmetricSpace X] [TopologicalSpace.SecondCountableTopology X] (s : Set X) : (⨆ (x : X), (nhds_within x s).small_sets.limsup dimH) = dimH s
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {x y : M} {S : Type u_3} [Monoid S] [DistribMulAction S M] [SmulCommClass R S M] (h : SameRay R x y) (s : S) : SameRay R (s • x) (s • y)
{G : Type u_6} {H : Type u_7} {F : Type u_8} [AddGroup G] [SubtractionMonoid H] [AddMonoidHomClass F G H] (f : F) (a b : G) : ⇑f (a - b) = ⇑f a - ⇑f b
{α : Type u} {ι : Type v} [MetricSpace α] [ProperSpace α] {c : ι → α} {s : Set α} {r : ι → ℝ} (hs : is_IsClosed s) (uf : ∀ (x : α), x ∈ s → {i : ι | x ∈ Metric.Ball (c i) (r i)}.finite) (us : s ⊆ ⋃ (i : ι), Metric.Ball (c i) (r i)) : ∃ (r' : ι → ℝ), (s ⊆ ⋃ (i : ι), Metric.Ball (c i) (r' i)) ∧ ∀ (i : ι), r' i < r i
{α : Type u} {β : Type v} [AddGroup α] [AddGroup β] {f : α → β} (hF : IsAddGroupHom f) : IsAddMonoidHom f
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q) : (∀ (a : ↥P), ⇑f a = 0 → a = 0) → CategoryTheory.Mono f
(V : Type u_1) [SemiNormedGroup V] : ∥NormedGroupHom.id V∥ ≤ 1
{C : Type u₁} [CategoryTheory.Category C] {X Y : C} (f : X ⟶ Y) [CategoryTheory.IsIso (Category_theory.yoneda.map f)] : CategoryTheory.IsIso f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {s1 s2 : AffineSubspace k P} (h : s1 ≤ s2) : s1.direction ≤ s2.direction
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {b₂ : Basis (Fin 2) ℝ V} (hb₂ : Orthonormal ℝ ⇑b₂) (ho : b.orientation = -b₂.orientation) (θ : Real.Angle) : hb.rotation θ = hb₂.rotation (-θ)
{D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ} (hF : ContinuousOn f D) (hF' : DifferentiableOn ℝ f (Interior D)) (h_anti : AntitoneOn (deriv f) (Interior D)) : ConcaveOn ℝ D f
{J : Type v} {C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WidePullbackShape J) C] {B : C} : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete J) (CategoryTheory.Over B)
 : ContinuousMap.ConjInvariantSubalgebra (subalgebra.restrict_scalars ℝ fourier_Subalgebra)
{α : Type u_1} [TopologicalSpace α] {S : Set (Set α)} (h : ∀ (s : Set α), s ∈ S → is_Gδ s) (hS : S.countable) : is_Gδ (⋂₀ S)
{ι : Type u_3} {χ : ι → Type u_4} [Π (i : ι), TopologicalSpace (χ i)] {as bs cs : Π (i : ι), χ i} (γ₀ : Π (i : ι), Path (as i) (bs i)) (γ₁ : Π (i : ι), Path (bs i) (cs i)) : (Path.pi γ₀).trans (Path.pi γ₁) = Path.pi (λ (i : ι), (γ₀ i).trans (γ₁ i))
{α : Type u_1} {n : Type u_3} {A : Matrix n n α} : A.is_Symm ↔ ∀ (i j : n), A j i = A i j
{α J : Type u} [CategoryTheory.SmallCategory J] [CategoryTheory.FinCategory J] [SemilatticeSup α] [OrderBot α] (F : J ⥤ α) : CategoryTheory.Limits.colimit F = finset.univ.sup F.obj
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] {X Y Z X' Y' Z' : C} (f : X ⟶ Y) (g : Y ⟶ Z) [CategoryTheory.Limits.HasKernel g] (w : f ≫ g = 0) (f' : X' ⟶ Y') (g' : Y' ⟶ Z') [CategoryTheory.Limits.HasKernel g'] (w' : f' ≫ g' = 0) (p : X ⟶ X') (q : Y ⟶ Y') (r : Z ⟶ Z') (h₁ : f ≫ q = p ≫ f') (h₂ : g ≫ r = q ≫ g') : CategoryTheory.Limits.kernel.lift g f w ≫ CategoryTheory.Limits.kernel.map g g' q r h₂ = p ≫ CategoryTheory.Limits.kernel.lift g' f' w'
{α : Type u_1} {β : Type u_2} {m₁ : MeasurableSpace α} {m₂ : MeasurableSpace β} {f : α → β} : m₂ ≤ MeasurableSpace.map f m₁ → Measurable f
{α : Type u} {β : Type v} {γ : Type w} [PseudoEmetricSpace α] [TopologicalSpace β] [PseudoEmetricSpace γ] (f : α × β → γ) (K : Nnreal) (ha : ∀ (a : α), Continuous (λ (y : β), f (a, y))) (hb : ∀ (b : β), LipschitzWith K (λ (x : α), f (x, b))) : Continuous f
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : Nnreal} {c : ℂ} {f : ℂ → E} (hD : DifferentiableOn ℂ f (Metric.ClosedBall c ↑R)) (hR : 0 < R) : HasFpowerSeriesOnBall f (Cauchy_PowerSeries f c ↑R) c ↑R
{C : Type u₁} [CategoryTheory.Category C] {X Y : C} (f : X ⟶ Y) [CategoryTheory.IsIso f.op] : CategoryTheory.IsIso f
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {X : Top} {F G : Top.Presheaf C X} (α : F ≅ G) (h : F.is_sheaf) : G.is_sheaf
{ι : Type u_1} {𝕜 : Type u_2} {F : Type u_3} [Fintype ι] [Semiring 𝕜] [TopologicalSpace 𝕜] [AddCommMonoid F] [Module 𝕜 F] [TopologicalSpace F] [HasContinuousAdd F] [HasContinuousSmul 𝕜 F] (f : (ι → 𝕜) →ₗ[𝕜] F) : Continuous ⇑f
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E] {s : Set E} {f : E → E} {f' : E → (E →L[ℝ] E)} [MeasurableSpace E] [BorelSpace E] (hs : MeasurableSet s) (hF' : ∀ (x : E), x ∈ s → HasFderivWithinAt f (f' x) s x) (hF : Set.InjOn f s) : MeasurableEmbedding (s.restrict f)
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (X Y : C) : CategoryTheory.IsIso (CategoryTheory.Limits.kernelι 0)
{α : Type u} [AddGroup α] [HasLe α] [CovariantClass α α (Function.swap has_add.add) has_le.le] {a b : α} : a - b ≤ 0 → a ≤ b
{α : Type u_1} [PartialOrder α] [SuccOrder α] [IsSuccArchimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ Set.Ico m n → r (Order.succ i) i) (hmn : m < n) : Relation.TransGen r n m
(n : ℕ) (n_Pos : 0 < n) : 4 ^ n ≤ 2 * n * n.central_binom
{R : Type u} {ι : Type v} {M₁ : ι → Type w₁} {M₂ : Type w₂} [DecidableEq ι] [Semiring R] [Π (i : ι), AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [Π (i : ι), Module R (M₁ i)] [Module R M₂] [Π (i : ι), TopologicalSpace (M₁ i)] [TopologicalSpace M₂] (f : ContinuousMultilinearMap R M₁ M₂) [Fintype ι] (m m' : Π (i : ι), M₁ i) : ⇑f (m + m') = finset.univ.sum (λ (s : Finset ι), ⇑f (s.piecewise m m'))
{α : Type u} [TopologicalSpace α] (x : α) [(nhds_within x {x}ᶜ).ne_IsBot] : Closure {x}ᶜ = Set.Univ
{𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} {β : Type u_4} [LinearOrderedField 𝕜] [AddCommGroup E] [AddCommGroup F] [OrderedAddCommMonoid β] [Module 𝕜 E] [Module 𝕜 F] [HasScalar 𝕜 β] {f : F → β} (g : E →ᵃ[𝕜] F) {s : Set F} (hF : ConcaveOn 𝕜 s f) : ConcaveOn 𝕜 (⇑g ⁻¹' s) (f ∘ ⇑g)
{p : ℕ} : padic_val_rat p 1 = 0
{V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasZeroMorphisms V] {A B C : V} (f : A ⟶ B) [CategoryTheory.Limits.HasImage f] (g : B ⟶ C) [CategoryTheory.Limits.HasKernel g] (w : f ≫ g = 0) (h : Category_theory.limits.image_Subobject f ≤ Category_theory.limits.kernel_Subobject g) : (Category_theory.limits.image_Subobject f).of_LE (Category_theory.limits.kernel_Subobject g) h = image_to_Kernel f g w
{α : sort u_1} {β : sort u_2} {γ : sort u_3} {f : α → β → γ} (hF : Function.Injective2 f) (a : α) : Function.Injective (f a)
{α : Type u} {β : Type v} [Group α] [Group β] {f : α → β} (hF : IsGroupHom f) : IsMonoidHom f
{n : ℕ} (hn : Even n) (h : n ≠ 0) : StrictConvexOn ℝ Set.Univ (λ (x : ℝ), x ^ n)
{R : Type u} [CommRing R] [IsNoetherianRing R] : IsNoetherianRing (Polynomial R)
{D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ} (hF : ContinuousOn f D) (hF' : DifferentiableOn ℝ f (Interior D)) {C : ℝ} (LE_hF' : ∀ (x : ℝ), x ∈ Interior D → deriv f x ≤ C) (x : ℝ) (H : x ∈ D) (y : ℝ) (H_1 : y ∈ D) : x ≤ y → f y - f x ≤ C * (y - x)
{R : Type u_1} [HasMul R] {a : R} : IsLeftRegular a ↔ IsSmulRegular R a
{R : Type u_1} {α : Type u_2} {β : Type u_4} {γ : Type u_6} {l : Type u_8} {m : Type u_9} {n : Type u_10} {l' : Type u_14} {m' : Type u_15} {n' : Type u_16} [CommSemiring R] [Fintype m] [Fintype m'] [NonUnitalNonAssocSemiring α] [NonUnitalNonAssocSemiring β] [NonUnitalNonAssocSemiring γ] [Module R α] [Module R β] [Module R γ] (f : α →ₗ[R] β →ₗ[R] γ) (h_comm : ∀ (a b : α) (a' b' : β), ⇑(⇑f (a * b)) (a' * b') = ⇑(⇑f a) a' * ⇑(⇑f b) b') (A : Matrix l m α) (B : Matrix m n α) (A' : Matrix l' m' β) (B' : Matrix m' n' β) : ⇑(⇑(matrix.kronecker_Map_bilinear f) (A.mul B)) (A'.mul B') = (⇑(⇑(matrix.kronecker_Map_bilinear f) A) A').mul (⇑(⇑(matrix.kronecker_Map_bilinear f) B) B')
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [SemilatticeSup α] [OrderBot α] (s : Finset β) (t : Finset γ) (f : β × γ → α) : (s.product t).sup f = s.sup (λ (i : β), t.sup (λ (i' : γ), f (i, i')))
{A : Type u_2} [CommRing A] [is_IsDomain A] (h : IsDedekindDomainInv A) : IsDedekindDomain A
{ι : Type u_1} {α : Type u_3} [Preorder ι] [Preorder α] {l : Filter ι} {u : ι → α} (h : Monotone u) [l.ne_IsBot] (hu : Filter.Tendsto u l filter.at_IsBot) : Filter.Tendsto u filter.at_IsBot filter.at_IsBot
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {v₁ v₂ : RayVector R M} : v₁ ≈ v₂ ↔ SameRay R ↑v₁ ↑v₂
{α : Type u} [OrderedSemiring α] [Nontrivial α] : 0 < 4
{α : Type u_1} {β : Type u_2} {M : Type u_5} [AddCommMonoid M] {g : β → M} (e : α → β) (hE₀ : Function.bijective e) : finsum (λ (i : α), g (e i)) = finsum (λ (j : β), g j)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (p1 p2 p3 : P) : 0 ≤ EuclideanGeometry.angle p1 p2 p3
(n : ℕ) : n.choose 2 = n * (n - 1) / 2
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace E] [CompleteSpace ↥K] (w : E) : w = ↑(⇑(Orthogonal_projection K) w) + ↑(⇑(Orthogonal_projection Kᗮ) w)
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {s1 s2 : AffineSubspace k P} (h1 : ↑s1.nonempty) (h2 : ↑s2.nonempty) (hE : ↑s1 ∩ ↑s2 = ∅) : s1.direction ⊔ s2.direction < (s1 ⊔ s2).direction
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] (e : C ≌ D) (Y : D) : e.unit.app (e.inverse.obj Y) ≫ e.inverse.map (e.counit.app Y) = 𝟙 (e.inverse.obj Y)
{α : Type u} [Preorder α] {a b c : α} : b = c → a < b → a < c
(R : Type u) (M : Type v) [Ring R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] : ↑(FiniteDimensional.finrank R M) = Module.rank R M
{Y : Type u_2} [TopologicalSpace Y] [NormalSpace Y] {s : Set Y} (f : C(↥s, ℝ)) {t : Set ℝ} [t.ord_connected] (ht : ∀ (x : ↥s), ⇑f x ∈ t) (hne : t.nonempty) (hs : is_IsClosed s) : ∃ (g : C(Y, ℝ)), (∀ (y : Y), ⇑g y ∈ t) ∧ ContinuousMap.restrict s g = f
{p : Ereal × Ereal} (h : p.fst ≠ ⊤ ∨ p.snd ≠ ⊥) (h' : p.fst ≠ ⊥ ∨ p.snd ≠ ⊤) : ContinuousAt (λ (p : Ereal × Ereal), p.fst + p.snd) p
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι} (h : TendstoUniformlyOn F f p s) (g : γ → α) : TendstoUniformlyOn (λ (n : ι), F n ∘ g) (f ∘ g) p (g ⁻¹' s)
{α : Type u} [TopologicalSpace α] (x : α) [(nhds_within x {x}ᶜ).ne_IsBot] : Dense {x}ᶜ
{n : ℕ} {α : Fin (n + 1) → Type u} (q : Π (i : Fin (n + 1)), α i) : fin.snoc (fin.init q) (q (fin.last n)) = q
{R : Type u} {A : Type w} [CommSemiring R] [Semiring A] [Algebra R A] (r : R) (x y : A) : r • x * y = r • (x * y)
 : ¬Small Ordinal
{α : Type u} [PseudoEmetricSpace α] (E : Set α) : Closure E = ⋂ (δ : ℝ) (h : 0 < δ), Metric.Cthickening δ E
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommGroup β] [HasScalar 𝕜 E] [Module 𝕜 β] {s : Set E} {f : E → β} : StrictConvexOn 𝕜 s f → StrictConcaveOn 𝕜 s (-f)
{K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {s : Submodule K V} (h : s < ⊤) : FiniteDimensional.finrank K ↥s < FiniteDimensional.finrank K V
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {f : ℝ → E} {a b : ℝ} {f' g : ℝ → E} (derivf : ∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt f (f' x) (Set.Ici x) x) (derivg : ∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt g (f' x) (Set.Ici x) x) (fcont : ContinuousOn f (Set.Icc a b)) (gcont : ContinuousOn g (Set.Icc a b)) (hi : f a = g a) (y : ℝ) (H : y ∈ Set.Icc a b) : f y = g y
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V} (hn : x ≠ y) (h : ∥x∥ = ∥y∥) : o.oangle y x = ↑Real.pi - 2 • o.oangle (y - x) y
{R : Type u_1} {a : R} [AddSemigroup R] (b : R) (ha : IsAddRightRegular a) : IsAddRightRegular (b + a) ↔ IsAddRightRegular b
{α : Type u_1} {G : Type u_5} [TopologicalSpace G] [AddCommGroup G] [TopologicalAddGroup G] {f : α → G} (hF : Summable f) : Filter.Tendsto f Filter.cofinite (nhds 0)
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] (f : ℂ → E) (z w : ℂ) (hD : DifferentiableOn ℝ f (Set.Interval z.re w.re ×ℂ Set.Interval z.im w.im)) (Hi : MeasureTheory.IntegrableOn (λ (z : ℂ), Complex.i • ⇑(fderiv ℝ f z) 1 - ⇑(fderiv ℝ f z) Complex.i) (Set.Interval z.re w.re ×ℂ Set.Interval z.im w.im) MeasureTheory.MeasureSpace.volume) : (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(z.im) * Complex.i)) - ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑(w.im) * Complex.i)) + Complex.i • ∫ (y : ℝ) in z.im..w.im, f (↑(w.re) + ↑y * Complex.i)) - Complex.i • ∫ (y : ℝ) in z.im..w.im, f (↑(z.re) + ↑y * Complex.i) = ∫ (x : ℝ) in z.re..w.re, ∫ (y : ℝ) in z.im..w.im, Complex.i • ⇑(fderiv ℝ f (↑x + ↑y * Complex.i)) 1 - ⇑(fderiv ℝ f (↑x + ↑y * Complex.i)) Complex.i
(𝕜 : Type u) [NondiscreteNormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace 𝕜] {r : ℝ} (rpos : 0 < r) {c : E} (h : is_IsCompact (Metric.ClosedBall c r)) : FiniteDimensional 𝕜 E
{α : Type u} {β : Type v} [AddGroup α] [AddGroup β] {f : α → β} (hF : IsAddGroupHom f) : Function.Injective f ↔ ∀ (a : α), f a = 0 → a = 0
(m : ℕ) {n : ℕ} (hn : 0 < n) : (∃ (k : ℕ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {f : 𝕜 → F} {s : Set 𝕜} : iterated_deriv_within n f s = ⇑((Continuous_multilinear_map.pi_Field_Equiv 𝕜 (Fin n) F).symm) ∘ iterated_fderiv_within 𝕜 n f s
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {f : α → β} {s : Set β} (hF : Continuous f) : f ⁻¹' Interior s ⊆ Interior (f ⁻¹' s)
{α : Type u_1} {β : Type u_2} [AddCommGroup α] [TopologicalSpace α] [TopologicalAddGroup α] {f : β → α} [t2_Space α] [DecidableEq β] (hF : Summable f) (b : β) : ∑' (n : β), f n = f b + ∑' (n : β), Ite (n = b) 0 (f n)
{R : Type u} [Ring R] (a : R) {n : ℕ} (h : n ≠ 0) : (Polynomial.x ^ n - ⇑Polynomial.c a).monic
{K : Type u_1} {v : K} {n : ℕ} [LinearOrderedField K] [FloorRing K] (hyp : n = 0 ∨ ¬(GeneralizedContinuedFraction.of v).terminated_at (n - 1)) : ↑(Nat.fib (n + 1)) ≤ (GeneralizedContinuedFraction.of v).denominators n
{α : Type u} {β : Type v} [CompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [CompleteLinearOrder β] [TopologicalSpace β] [OrderTopology β] {ι : sort u_1} {f : α → β} {g : ι → α} (Cf : ContinuousAt f (supr g)) (Mf : Monotone f) (fbot : f ⊥ = ⊥) : f (⨆ (i : ι), g i) = ⨆ (i : ι), f (g i)
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] [∀ (X Y : C), Subsingleton (X ⟶ Y)] (hC : CategoryTheory.Skeletal C) : CategoryTheory.Skeletal (D ⥤ C)
{K : Type u} [hring : CommRing K] [hdomain : is_IsDomain K] {P : Ratfunc K → Prop} (x : Ratfunc K) (f : ∀ (p q : Polynomial K), q ≠ 0 → P (Ratfunc.mk p q)) : P x
{ι : Type u_1} {R : Type u_2} {N : Type u_5} [decι : DecidableEq ι] [Semiring R] [AddCommMonoid N] [Module R N] (p : ι → Submodule R N) : supr p = (⇑(Dfinsupp.lsum ℕ) (λ (i : ι), (p i).subtype)).range
{α : Type u_1} [PartialOrder α] [SuccOrder α] [IsSuccArchimedean α] (r : α → α → Prop) {n m : α} (h : ∀ (i : α), i ∈ Set.Ico m n → r (Order.succ i) i) (hmn : m ≤ n) : Relation.ReflTransGen r n m
{X : Type u_1} [TopologicalSpace X] [NormalSpace X] (c : Urysohns.CU X) : Continuous c.lim
{α : Type u} {β : Type v} [DecidableEq β] [Fintype α] [Fintype β] (f : α → β) {n : ℕ} [Nonempty β] (hn : Fintype.card β * n ≤ Fintype.card α) : ∃ (y : β), n ≤ (Finset.filter (λ (x : α), f x = y) Finset.univ).card
 : (λ (n : ℕ), ↑(Nat.fib n)) = λ (n : ℕ), (GoldenRatio ^ n - golden_Conj ^ n) / Real.sqrt 5
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {f : α → β} (hi : Inducing f) (ho : is_IsOpen (Set.Range f)) : is_is_IsOpenMap f
{α : Type u_3} [SemilatticeInf α] [NoMinOrder α] (a : α) : Filter.map Coe filter.at_IsBot = filter.at_IsBot
{G : Type u_1} [Group G] {G' : Type u_2} [Group G'] [h : group.is_nilpotent G] (f : G ≃* G') : group.is_nilpotent G'
{A : Type u_1} (B : Type u_2) [Field A] [Ring B] [Algebra A B] [Nontrivial B] (a : A) : minpoly A (⇑(Algebra_Map A B) a) = Polynomial.x - ⇑Polynomial.c a
{α : Type u} [PseudoEmetricSpace α] {s t : Set α} {r : Ennreal} (H1 : ∀ (x : α), x ∈ s → (∃ (y : α) (H : y ∈ t), HasEdist.edist x y ≤ r)) (H2 : ∀ (x : α), x ∈ t → (∃ (y : α) (H : y ∈ s), HasEdist.edist x y ≤ r)) : emetric.Hausdorff_edist s t ≤ r
{R : Type u} [CommSemiring R] (l : List (Polynomial R)) (x : R) : Polynomial.eval x l.prod = (List.map (Polynomial.eval x) l).prod
{F : Type v} [NormedGroup F] [NormedSpace ℂ F] {f : ℂ → F} (hF : Differentiable ℂ f) (hb : Metric.Bounded (Set.Range f)) (z w : ℂ) : f z = f w
{n : Type u_4} [DecidableEq n] (v : n → ℝ) : (Matrix.diagonal v).is_hermitian
{C : Type u_1} [CategoryTheory.Category C] {D : Type u_3} [CategoryTheory.Category D] {E : Type u_5} [CategoryTheory.Category E] {J : CategoryTheory.GrothendieckTopology C} {K : CategoryTheory.GrothendieckTopology D} {L : CategoryTheory.GrothendieckTopology E} {F : C ⥤ D} (hu : CategoryTheory.CoverLifting J K F) {G : D ⥤ E} (hv : CategoryTheory.CoverLifting K L G) : CategoryTheory.CoverLifting J L (F ⋙ G)
{α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β] (f : MeasureTheory.SimpleFunc α β) : Measurable ⇑f
{C : Type u} [CategoryTheory.Category C] {D : Type u'} [CategoryTheory.Category D] [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Limits.HasFiniteProducts D] (F : C ⥤ D) {L : D ⥤ C} [CategoryTheory.CartesianClosed C] [CategoryTheory.CartesianClosed D] [CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F] (h : L ⊣ F) (A : C) [i : CategoryTheory.IsIso (CategoryTheory.exp_comparison F A)] : CategoryTheory.IsIso (Category_theory.frobenius_morphism F h A)
 : StrictMono (λ (n : ℕ), Nat.fib (n + 2))
{M : Type u_6} {N : Type u_7} [HasMul M] [HasMul N] (f : M ≃* N) (x y : M) : ⇑f (x * y) = ⇑f x * ⇑f y
{k : Type u_1} {G : Type u_2} {V : Type u_3} [CommSemiring k] [Group G] [AddCommMonoid V] [Module k V] (ρ : Representation k G V) [Fintype G] [Invertible ↑(Fintype.card G)] (v : V) : ⇑(ρ.average_Map) v ∈ ρ.invariants
{β : Type u} {α : Type v} [CommSemiring β] {s : Finset α} {i : α} {f g h : α → β} (hi : i ∈ s) (h1 : g i + h i = f i) (h2 : ∀ (j : α), j ∈ s → j ≠ i → g j = f j) (h3 : ∀ (j : α), j ∈ s → j ≠ i → h j = f j) : s.prod (λ (i : α), g i) + s.prod (λ (i : α), h i) = s.prod (λ (i : α), f i)
{α : Type u_1} {n : ℕ} {s t : Finset α} : s ∈ finset.powerset_len n t ↔ s ⊆ t ∧ s.card = n
{α : Type u_1} {ι : Type u_4} (s : ι → Set α) : (⋃ (i : ι), s i) = ⋃ (t : Finset ι) (i : ι) (H : i ∈ t), s i
{G : Type u_1} [AddGroup G] (h : Add_monoid.exponent_exists G) : Add_monoid.is_torsion G
{α : sort u_1} {β : sort u_2} {γ : sort u_3} {s₁ : Setoid α} {s₂ : Setoid β} {s₃ : Setoid γ} {p : Quotient s₁ → Quotient s₂ → Quotient s₃ → Prop} (q₁ : Quotient s₁) (q₂ : Quotient s₂) (q₃ : Quotient s₃) (h : ∀ (a₁ : α) (a₂ : β) (a₃ : γ), p (Quotient.mk' a₁) (Quotient.mk' a₂) (Quotient.mk' a₃)) : p q₁ q₂ q₃
{R : Type u} {S : Type v} {A : Type w} [CommSemiring R] [CommSemiring S] [Semiring A] [Algebra R S] [Algebra S A] [Algebra R A] (h : Algebra_Map R A = (Algebra_Map S A).comp (Algebra_Map R S)) : IsScalarTower R S A
{R : Type u_1} [LinearOrderedField R] [FloorRing R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : ↑b ^ x ≤ r ↔ x ≤ Int.log b r
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) [CompleteSpace ↥K] (v : E) : ∃ (y : E) (H : y ∈ K) (z : E) (H : z ∈ Kᗮ), v = y + z
{M : Type u_1} {N : Type u_2} [HasMul M] [HasMul N] {f g : M →ₙ* N} {s : Set M} (h : Set.EqOn ⇑f ⇑g s) : Set.EqOn ⇑f ⇑g ↑(Subsemigroup.closure s)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (f : LocalHomeomorph E F) {f' : E ≃L[𝕜] F} {a : F} (ha : a ∈ f.to_local_equiv.target) (htff' : HasStrictFderivAt ⇑f ↑f' (⇑(f.symm) a)) : HasStrictFderivAt ⇑(f.symm) ↑(f'.symm) a
{𝕜 : Type u_1} {E : Type u_2} [OrderedSemiring 𝕜] [AddCommGroup E] [Module 𝕜 E] {s t : Set E} (hc : ConvexIndependent 𝕜 (λ (x : ↥t), ↑x)) (hs : s ⊆ t) : ConvexIndependent 𝕜 (λ (x : ↥s), ↑x)
{α : Type u} [TopologicalSpace α] [t0_Space α] {s : Set α} (hfin : s.finite) (hne : s.nonempty) (ho : is_IsOpen s) : ∃ (x : α) (H : x ∈ s), is_IsOpen {x}
{α : Type u} [DecidableEq α] [Fintype α] {P : Equiv.perm α → Prop} (f : Equiv.perm α) : P 1 → (∀ (f : Equiv.perm α) (x y : α), x ≠ y → P f → P (f * equiv.swap x y)) → P f
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] {e : LocalHomeomorph α β} {s : Set α} {t : Set β} : e.to_local_equiv.source ∩ ⇑e ⁻¹' (e.to_local_equiv.target ∩ t) = e.to_local_equiv.source ∩ s → e.is_image s t
{α : sort u_1} {β : sort u_2} {γ : sort u_3} [has_Coe α β] [has_Coe_t β γ] (a : α) : ↑a = ↑↑a
{α : Type u} [PseudoMetricSpace α] {x : α} : metric.inf_dist x ∅ = 0
{α : Type u_1} [LinearOrderedRing α] [Archimedean α] {x y : α} (hx : 1 ≤ x) (hy : 1 < y) : ∃ (n : ℕ), y ^ n ≤ x ∧ x < y ^ (n + 1)
{α : Type u_1} {β : Type u_2} {M : Type u_5} [CommMonoid M] {f : α → M} {g : β → α} (hg : Set.InjOn g (Function.MulSupport (f ∘ g))) : finprod (λ (i : α), finprod (λ (H : i ∈ Set.Range g), f i)) = finprod (λ (j : β), f (g j))
(K : Type u) (V : Type v) [DivisionRing K] [AddCommGroup V] [Module K V] [IsNoetherian K V] : Module.rank K V < Cardinal.aleph_0
{a b c : ℤ} : fermat_42.minimal a b c → fermat_42.minimal b a c
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {a b : ℝ} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) (h : ∀ (x y : E), ∥x∥ ≤ 1 → ∥y∥ ≤ 1 → x ≠ y → ∥a • x + b • y∥ < 1) : StrictConvexSpace ℝ E
(n : ℕ) (z : ℂ) : (Complex.cos z + Complex.sin z * Complex.i) ^ n = Complex.cos (↑n * z) + Complex.sin (↑n * z) * Complex.i
{C : Type u₁} [CategoryTheory.SmallCategory C] {ℰ : Type u₂} [CategoryTheory.Category ℰ] (A : C ⥤ ℰ) (P : Cᵒᵖ ⥤ Type u₁) (E₁ E₂ : ℰ) (g : E₁ ⟶ E₂) {c : CategoryTheory.Limits.Cocone ((CategoryTheory.Category_of_elements.π P).left_Op ⋙ A)} (t : CategoryTheory.Limits.IsColimit c) (k : c.X ⟶ E₁) : ⇑(Category_theory.colimit_adj.restrict_yoneda_hom_Equiv A P E₂ t) (k ≫ g) = ⇑(Category_theory.colimit_adj.restrict_yoneda_hom_Equiv A P E₁ t) k ≫ (Category_theory.colimit_adj.restricted_yoneda A).map g
{L : FirstOrder.Language} {M : Type u_3} {N : Type u_4} {P : Type u_5} {Q : Type u_6} [L.Structure M] [L.Structure N] [L.Structure P] [L.Structure Q] (f : L.elementary_Embedding M N) (g : L.elementary_Embedding N P) (h : L.elementary_Embedding P Q) : (h.comp g).comp f = h.comp (g.comp f)
{M : Type u_2} [AddCommGroup M] {A : Type u_1} [CommRing A] [Module A M] (f : M →ₗ[A] M) (hF : IsUnit f) : IsUnit (⇑LinearMap.det f)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] (s : Set P) : (affine_Span k s).direction = Vector_Span k s
{α : Type u} [PartialOrder α] [OrderTop α] {a : α} : IsMax a → a = ⊤
{α : Type u_1} [PseudoEmetricSpace α] {f : ℕ → α} (d : ℕ → Ennreal) (hF : ∀ (n : ℕ), HasEdist.edist (f n) (f n.succ) ≤ d n) {a : α} (ha : Filter.Tendsto f filter.at_Top (nhds a)) : HasEdist.edist (f 0) a ≤ ∑' (m : ℕ), d m
{α : Type u} [TopologicalSpace α] {s : Set α} (h : ∀ {ι : Type u} (U : ι → Set α), (∀ (i : ι), is_IsOpen (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : Finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) : is_IsCompact s
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) {x y : L} : x ∈ S → y ∈ S → x - y ∈ S
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] [CompleteSpace E] {f : ℝ → E} {T : ℝ} (hF : Function.Periodic f T) (hT : 0 < T) (t s : ℝ) : ∫ (x : ℝ) in t..t + T, f x = ∫ (x : ℝ) in s..s + T, f x
{G : Type u_1} [AddGroup G] (H : AddSubgroup G) {x y : G} (hx : x ∈ H) (hy : y ∈ H) : x - y ∈ H
{u : ℕ → ℝ} (h : Subadditive u) (hbdd : BddBelow (Set.Range (λ (n : ℕ), u n / ↑n))) : Filter.Tendsto (λ (n : ℕ), u n / ↑n) filter.at_Top (nhds h.lim)
{α : Type u_1} {M : Type u_5} {N : Type u_6} [AddCommMonoid M] [AddCommMonoid N] {s : Set α} {f : α → M} (g : M →+ N) (h₀ : (s ∩ Function.Support f).finite) : ⇑g (finsum (λ (j : α), finsum (λ (H : j ∈ s), f j))) = finsum (λ (i : α), finsum (λ (H : i ∈ s), ⇑g (f i)))
{γ : Type w} [Preorder γ] [OrderBot γ] (s : Set γ) : BddBelow s
{α : Type u} [PseudoMetricSpace α] {s t u : Set α} (Fin : emetric.Hausdorff_edist s t ≠ ⊤) : metric.Hausdorff_dist s u ≤ metric.Hausdorff_dist s t + metric.Hausdorff_dist t u
{α : Type u_2} [DecidableEq α] {B : Finset (Finset α)} {n : ℕ} [Fintype α] (h : ∀ (a : α), n ≤ (Finset.filter (HasMem.Mem a) B).card) : Fintype.card α * n ≤ B.sum (λ (s : Finset α), s.card)
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle y z + o.oangle x y = o.oangle x z
{T : ℝ} {g : ℝ → ℝ} (hg : Function.Periodic g T) (h_Int : ∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.MeasureSpace.volume t₁ t₂) (h₀ : ∀ (x : ℝ), 0 < g x) (hT : 0 < T) : Filter.Tendsto (λ (t : ℝ), ∫ (x : ℝ) in 0..t, g x) filter.at_Top filter.at_Top
{α : Type u} (s : Finset α) : ↑s.finite
{M : Type u_3} {N : Type u_4} [Monoid M] [Monoid N] {F : Type u_1} [MonoidHomClass F M Nᵐᵒᵖ] (f : F) (l : List M) : MulOpposite.unop (⇑f l.prod) = (List.map (MulOpposite.unop ∘ ⇑f) l).reverse.prod
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {F : J ⥤ C} {X : C} (h : Category_theory.coyoneda.obj (Opposite.op X) ⋙ Category_theory.ulift_Functor ≅ F.cocones) {Y : C} (f : X ⟶ Y) : Category_theory.limits.is_colimit.of_Nat_iso.cocone_of_hom h f = (Category_theory.limits.is_colimit.of_Nat_iso.colimit_Cocone h).extend f
{M : Type u_2} (R : Type u_5) [Semiring R] [AddCommMonoid M] [Module R M] (s : Set M) : Submodule.span R s = (Finsupp.total ↥s M R Coe).range
{R : Type u} {S : Type v} [CommSemiring R] [LocalRing R] [CommSemiring S] [LocalRing S] (f : R →+* S) [is_IsLocalRingHom f] (a : R) (h : a ∈ local_ring.maximal_Ideal R) : ⇑f a ∈ local_ring.maximal_Ideal S
{M₀ : Type u_1} [MulZeroOneClass M₀] : 0 = 1 → Subsingleton M₀
{α : Type u} (L : List α) {i j : ℕ} (h : i + j < L.length) : L.nth_LE (i + j) h = (List.drop i L).nth_LE j _
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {n : WithTop ℕ} {s : Set (E × F)} {p : E × F} : ContDiffWithinAt 𝕜 n Prod.fst s p
{G : Type u_3} [Group G] : group.fg G ↔ ∃ (S : Set G), Subgroup.closure S = ⊤ ∧ S.finite
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} {x : E} : DifferentiableAt 𝕜 f x → MdifferentiableAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f x
(R : Type u_1) (M : Type u_4) [Semiring R] [AddCommMonoid M] [Module R M] (x : M) : Submodule.span R {x} = (Linear_map.to_Span_Singleton R M x).range
{m n : ℕ} : Even (m ^ n) ↔ Even m ∧ n ≠ 0
{F : Type u_3} [InnerProductSpace ℝ F] [FiniteDimensional ℝ F] : Subgroup.closure (Set.Range (λ (v : F), reflection (Submodule.span ℝ {v})ᗮ)) = ⊤
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V} (h : ∥x∥ = ∥y∥) : o.oangle x (x - y) = o.oangle (y - x) y
{R : Type u_1} [NonAssocRing R] [Nontrivial R] (hR : Ring_Char R ≠ 2) : -1 ≠ 1
{E : Type u_1} [AddCommGroup E] [StarAddMonoid E] [Module ℂ E] [StarModule ℂ E] (x : E) : ↑(⇑StarModule.re x) + Complex.i • ↑(⇑StarModule.im x) = x
{α : Type u} [Group α] [HasLe α] [CovariantClass α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a
{α : Type u_1} {ι : sort u_3} [ConditionallyCompleteLattice α] {f g : ι → α} (B : BddBelow (Set.Range f)) (H : ∀ (x : ι), f x ≤ g x) : infi f ≤ infi g
{α : Type u_2} [DecidableEq α] {B : Finset (Finset α)} {n : ℕ} [Fintype α] (h : ∀ (a : α), (Finset.filter (HasMem.Mem a) B).card = n) : B.sum (λ (s : Finset α), s.card) = Fintype.card α * n
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {e e' : LocalEquiv α β} {f f' : LocalEquiv β γ} (hE : e ≈ e') (hF : f ≈ f') : e.trans f ≈ e'.trans f'
{α : Type u_1} [CanonicallyOrderedAddMonoid α] [HasSub α] [HasOrderedSub α] {a b c : α} [ContravariantClass α α has_add.add has_le.le] (h : c ≤ b) : a < b - c ↔ c + a < b
{α : Type u} [TopologicalSpace α] [t1_Space α] [∀ (x : α), (nhds_within x {x}ᶜ).ne_IsBot] {s : Set α} (hs : Dense s) {t : Set α} (ht : t.finite) : Dense (s  t)
{α : Type u_1} {β : Type u_2} [UniformSpace β] {f : α → β} {s : Set α} {x : α} [TopologicalSpace α] (hx : x ∈ s) (L : ∀ (u : Set (β × β)), u ∈ Uniformity β → (∃ (t : Set α) (H : t ∈ nhds_within x s) (F : α → β), ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u)) : ContinuousWithinAt f s x
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} {s : Finset ι} {w : ι → k} (h : s.sum (λ (i : ι), w i) = 0) (p : ι → P) : ⇑(s.weighted_vsub p) w ∈ Vector_Span k (Set.Range p)
{𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [OrderedSemiring 𝕜] [AddCommMonoid E] [OrderedAddCommGroup β] [HasScalar 𝕜 E] [Module 𝕜 β] {s : Set E} {f : E → β} : StrictConcaveOn 𝕜 s (-f) ↔ StrictConvexOn 𝕜 s f
{E : Type u_3} [NormedGroup E] [CompleteSpace E] [NormedSpace ℝ E] {f : ℝ → E} {ca cb : E} {a b : ℝ} (hF : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (hmeas_a : StronglyMeasurableAtFilter f (nhds a) MeasureTheory.MeasureSpace.volume) (hmeas_b : StronglyMeasurableAtFilter f (nhds b) MeasureTheory.MeasureSpace.volume) (ha : Filter.Tendsto f (nhds a ⊓ MeasureTheory.Measure_space.volume.ae) (nhds ca)) (hb : Filter.Tendsto f (nhds b ⊓ MeasureTheory.Measure_space.volume.ae) (nhds cb)) : fderiv ℝ (λ (p : ℝ × ℝ), ∫ (x : ℝ) in p.fst..p.snd, f x) (a, b) = (ContinuousLinearMap.snd ℝ ℝ ℝ).smul_Right cb - (ContinuousLinearMap.fst ℝ ℝ ℝ).smul_Right ca
{α : Type u} {a b : α} [MulZeroClass α] [Preorder α] [ZeroLt.MulPosStrictMono α] (ha : 0 < a) (hb : 0 < b) : 0 < a * b
{α : Type u_1} [AddZeroClass α] [Preorder α] [CovariantClass α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0
{α : Type u_1} [ConditionallyCompleteLattice α] (a : α) : HasSup.sup {a} = a
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] [Fintype α] [Fintype β] (f : α → β) {w : α → M} {b : M} [LinearOrderedCancelAddCommMonoid M] [Nonempty β] (hb : finset.univ.sum (λ (x : α), w x) ≤ Fintype.card β • b) : ∃ (y : β), (Finset.filter (λ (x : α), f x = y) Finset.univ).sum (λ (x : α), w x) ≤ b
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [NoMaxOrder α] [DenselyOrdered α] {a : α} {s : Set α} : s ∈ nhds_within a (Set.Ici a) ↔ ∃ (u : α), a < u ∧ Set.Icc a u ⊆ s
{𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [AddCommGroup F] [Module 𝕜 F] [c : InnerProductSpace.Core 𝕜 F] (x y : F) : is_R_or_C.abs (HasInner.inner x y) * is_R_or_C.abs (HasInner.inner y x) ≤ ⇑is_R_or_C.re (HasInner.inner x x) * ⇑is_R_or_C.re (HasInner.inner y y)
{α : Type u_1} [LinearOrder α] [PredOrder α] [IsPredArchimedean α] (r : α → α → Prop) {n m : α} (hr : Reflexive r) (h1 : ∀ (i : α), i ∈ Set.Ioc m n → r i (Order.pred i)) (h2 : ∀ (i : α), i ∈ Set.Ioc n m → r (Order.pred i) i) : Relation.TransGen r n m
{R : Type v} [CommRing R] {n : Type u_1} [Unique n] [DecidableEq n] [Fintype n] (A : Matrix n n R) : A.det = A Inhabited.default Inhabited.default
{C : Type u} [CategoryTheory.Category C] {X Y : C} {f g : X ⟶ Y} (h₀ : f = g) {c : CategoryTheory.Limits.Cofork f g} (h : CategoryTheory.Limits.IsColimit c) : CategoryTheory.IsIso c.π
{x : ℝ} (hx : 0 ≤ x) : x + 1 ≤ Real.exp x
(p : ℕ) [hp : Fact (Nat.Prime p)] {q r : ℚ} (hne : padic_norm p q ≠ padic_norm p r) : padic_norm p (q + r) = Linear_order.max (padic_norm p q) (padic_norm p r)
 : fib_rec.is_solution (has_pow.pow golden_Conj)
{M : Type u_1} [SemiNormedGroup M] (S : AddSubgroup M) (h : ↑(S.topological_Closure) ≠ Set.Univ) : ∥S.normed_Mk∥ = 1
{G : Type u_1} [Group G] (H : ℕ → Subgroup G) (hH : IsAscendingCentralSeries H) (n : ℕ) : H n ≤ upper_central_series G n
{G : Type w} [TopologicalSpace G] [AddGroup G] [TopologicalAddGroup G] {M : Type u_1} {hom : Type u_2} [AddZeroClass M] [TopologicalSpace M] [HasContinuousAdd M] [AddMonoidHomClass hom G M] (f : hom) (hF : ContinuousAt ⇑f 0) : Continuous ⇑f
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] [LocallyCompactSpace α] [t2_Space α] [t2_Space β] {ι : Type u_3} {l : Filter ι} [l.ne_IsBot] (F : ι → C(α, β)) : (∃ (f : C(α, β)), Filter.Tendsto F l (nhds f)) ↔ ∀ (s : Set α), is_IsCompact s → (∃ (f : C(↥s, β)), Filter.Tendsto (λ (i : ι), ContinuousMap.restrict s (F i)) l (nhds f))
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {s : Set E} (hscomp : is_IsCompact s) (hAconv : Convex ℝ s) : Closure (⇑(Convex_hull ℝ) (Set.ExtremePoints ℝ s)) = s
{𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [DecidableEq ι] [Fintype ι] [NondiscreteNormedField 𝕜] [Π (i : ι), NormedGroup (E i)] [Π (i : ι), NormedSpace 𝕜 (E i)] [NormedGroup G] [NormedSpace 𝕜 G] (f : MultilinearMap 𝕜 E G) {C : ℝ} (hC : 0 ≤ C) (H : ∀ (m : Π (i : ι), E i), ∥⇑f m∥ ≤ C * finset.univ.prod (λ (i : ι), ∥m i∥)) : ∥f.mk_Continuous C H∥ ≤ C
{α : Type u} {β : Type v} [LinearOrderedField α] [TopologicalSpace α] [OrderTopology α] {l : Filter β} {f g : β → α} {C : α} (hC : 0 < C) (hF : Filter.Tendsto f l filter.at_Top) (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (λ (x : β), f x * g x) l filter.at_Top
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) : hb.conj_lie.symm = hb.conj_lie
{ι : Type u} {f g : ι → ℝ} {p q : ℝ} (hpq : p.is_conjugate_exponent q) {A B : ℝ} (hA : 0 ≤ A) (hB : 0 ≤ B) (hF : ∀ (i : ι), 0 ≤ f i) (hg : ∀ (i : ι), 0 ≤ g i) (hF_Sum : HasSum (λ (i : ι), f i ^ p) (A ^ p)) (hg_Sum : HasSum (λ (i : ι), g i ^ q) (B ^ q)) : ∃ (C : ℝ), 0 ≤ C ∧ C ≤ A * B ∧ HasSum (λ (i : ι), f i * g i) C
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Abelian C] {P : C} : Transitive (CategoryTheory.Abelian.PseudoEqual P)
{L : FirstOrder.Language} {M : Type w} [L.Structure M] {s : Set M} : s ⊆ ↑(⇑(FirstOrder.Language.Substructure.closure L) s)
{g : Matrix.SpecialLinearGroup (Fin 2) ℤ} (z : UpperHalfPlane) {p : Fin 2 → ℤ} (hp : IsCoprime (p 0) (p 1)) (hg : ↑g 1 = p) : ↑(g • z) = ↑(⇑(modular_group.lc_row0 p) ↑↑g) / (↑(p 0) ^ 2 + ↑(p 1) ^ 2) + (↑(p 1) * ↑z - ↑(p 0)) / ((↑(p 0) ^ 2 + ↑(p 1) ^ 2) * (↑(p 0) * ↑z + ↑(p 1)))
{B : Type u_3} {S : B} {M : Type u_1} [CommMonoid M] [SetLike B M] [SubmonoidClass B M] {ι : Type u_2} {t : Finset ι} {f : ι → M} (h : ∀ (c : ι), c ∈ t → f c ∈ S) : t.prod (λ (c : ι), f c) ∈ S
(f : ℝ → ℝ) {a b : ℝ} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hfd : DifferentiableOn ℝ f (Set.Ioo a b)) (g : ℝ → ℝ) (hgc : ContinuousOn g (Set.Icc a b)) (hgd : DifferentiableOn ℝ g (Set.Ioo a b)) : ∃ (c : ℝ) (H : c ∈ Set.Ioo a b), (g b - g a) * deriv f c = (f b - f a) * deriv g c
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (hp : 0 < p.radius) : 0 < (p.right_Inv i).radius
{A : Type u_2} [CommRing A] [is_IsDomain A] : IsDedekindDomain A ↔ IsDedekindDomainInv A
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] (v : V) (nz : v ≠ 0) : FiniteDimensional.finrank K V = 1 ↔ Submodule.span K {v} = ⊤
{V : Type u_1} [InnerProductSpace ℝ V] (x y : V) : ∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ ↔ InnerProductGeometry.angle x y = Real.pi / 2
{M : Type u_1} [HasMul M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y) : ConGen r ≤ ConGen s
(X : AlgebraicGeometry.LocallyRingedSpace (r : ↥(AlgebraicGeometry.LocallyRingedSpaceΓ.obj (Opposite.op X))) : X.to_Γ_spec_Map_basic_IsOpen r = X.to_RingedSpace.basic_IsOpen r
{α : Type u} {a b : α} [MulZeroOneClass α] [PartialOrder α] [ZeroLt.MulPosMono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 ≤ b) : 1 ≤ a * b
{n : ℕ} (hn : Even n) : ConvexOn ℝ Set.Univ (λ (x : ℝ), x ^ n)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {n : ℕ} (hs : is_IsOpen s) : ContDiffOn 𝕜 ↑(n + 1) f s ↔ DifferentiableOn 𝕜 f s ∧ ContDiffOn 𝕜 ↑n (λ (y : E), fderiv 𝕜 f y) s
{α : Type u_1} [DecidableEq α] {s t u : Multiset α} : s - t ≤ u ↔ s ≤ u + t
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [TopologicalSpace β] [LocallyCompactSpace α] : Continuous Coe_fn
{α : Type u} [TopologicalSpace α] [RegularSpace α] {x y : α} (h : x ≠ y) : ∃ (U₁ : Set α) (H : U₁ ∈ nhds x) (V₁ : Set α) (H : V₁ ∈ nhds x) (U₂ : Set α) (H : U₂ ∈ nhds y) (V₂ : Set α) (H : V₂ ∈ nhds y), is_IsClosed V₁ ∧ is_IsClosed V₂ ∧ is_IsOpen U₁ ∧ is_IsOpen U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ U₁ ∩ U₂ = ∅
{α : Type u_1} [CommSemigroup α] {a b : α} (h : a ∣ b) (c : α) : a ∣ c * b
{G₀ : Type u_1} {G₀' : Type u_2} [GroupWithZero G₀] [GroupWithZero G₀'] (f : G₀ →*₀ G₀') (x : G₀) (n : ℤ) : ⇑f (x ^ n) = ⇑f x ^ n
{α : Type u} {β : Type v} {γ : Type w} [Preorder α] [Preorder β] [Preorder γ] {f : α → β → γ} {s : Set α} {t : Set β} (h₀ : ∀ (b : β), Monotone (Function.swap f b)) (h₁ : ∀ (a : α), Monotone (f a)) : BddBelow s → BddBelow t → BddBelow (Set.image2 f s t)
{p : ℕ → Prop} [DecidablePred p] {n : ℕ} : ¬p n → Nat.count p (n + 1) = Nat.count p n
{M : Type u_1} [Group M] (c : Con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w / y) (x / z)
{α : Type u} [AddCommGroup α] : IsAddGroupHom has_neg.neg
{k : Type u_1} {E : Type u_2} {PE : Type u_3} [Field k] [AddCommGroup E] [Module k E] [AddTorsor E PE] (f : k → PE) (a b r : k) : ⇑(affine_map.line_Map (slope f (⇑(affine_map.line_Map a b) r) b) (slope f a (⇑(affine_map.line_Map a b) r))) r = slope f a b
 : ∃ (f : Nat.Partrec.Code → ℕ → Nat.Partrec.Code), Computable₂ f ∧ ∀ (c : Nat.Partrec.Code) (n x : ℕ), (f c n).eval x = c.eval (Nat.mkpair n x)
{k : Type u_1} {V : Type u_2} {P : Type u_3} {ι : Type u_4} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] [Fintype ι] {p : ι → P} (hi : AffineIndependent k p) {n : ℕ} (hc : Fintype.card ι = n + 1) : FiniteDimensional.finrank k ↥(Vector_Span k (Set.Range p)) = n
{α : Type u} {L₁ L₂ : List (α × Bool)} : FreeGroup.Red L₁ L₂ → L₂ <+ L₁
(p q : ℕ) [Fact (Nat.Prime p)] [Fact (Nat.Prime q)] (hp1 : p ≠ 2) (hq1 : q ≠ 2) (hpq : p ≠ q) : zmod.legendre_Sym q ↑p * zmod.legendre_Sym p ↑q = (-1) ^ (p / 2 * (q / 2))
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] [NormalSpace Y] (f : C(X, ℝ)) {t : Set ℝ} {e : X → Y} [hs : t.ord_connected] (hF : ∀ (x : X), ⇑f x ∈ t) (hne : t.nonempty) (hE : ClosedEmbedding e) : ∃ (g : C(Y, ℝ)), (∀ (y : Y), ⇑g y ∈ t) ∧ ⇑g ∘ e = ⇑f
{K : Type u} {A : Type v} [Field K] [Ring A] [Algebra K A] {x : A} : IsAlgebraic K x ↔ IsIntegral K x
{α : Type u_1} [MeasurableSpace α] [MeasurableSingletonClass α] {s : Set α} (u t : Set α) (hs : s.finite) : ⇑(probability_theory.cond_count (s ∩ u)) t * ⇑(probability_theory.cond_count s) u + ⇑(probability_theory.cond_count (s ∩ uᶜ)) t * ⇑(probability_theory.cond_count s) uᶜ = ⇑(probability_theory.cond_count s) t
{α : Type u_1} [Semigroup α] {a b : α} (h : a ∣ b) (c : α) : a ∣ b * c
{R : Type u_1} [LinearOrderedField R] {M : Type u_2} [AddCommGroup M] [Module R M] {v₁ v₂ : M} (h : SameRay R v₁ v₂) : ∃ (u : M) (a b : R), 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ v₁ = a • u ∧ v₂ = b • u
{α : Type u} {β : Type v} [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {n : ℕ} (hF : ∀ (a : α), a ∈ s → f a ∈ t) (hn : t.card * n < s.card) : ∃ (y : β) (H : y ∈ t), n < (Finset.filter (λ (x : α), f x = y) s).card
{α : Type u} [Preorder α] {a : α} {s t p : Set α} (hs : is_is_IsLub s a) (hp : is_is_IsLub p a) (hst : s ⊆ t) (htp : t ⊆ p) : is_is_IsLub t a
(n : ℕ) (R : Type u_1) [Ring R] : Polynomial.map (int.cast_RingHom R) (Polynomial.cyclotomic n ℤ) = Polynomial.cyclotomic n R
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : Ring_Char F = 2) {a : F} (ha : a ≠ 0) : char.quadratic_Char F a = 1
{R : Type u} {ι : Type w} (s : Finset ι) [CommSemiring R] [NoZeroDivisors R] (f : ι → Polynomial R) (h : ∀ (i : ι), i ∈ s → f i ≠ 0) : (s.prod (λ (i : ι), f i)).nat_degree = s.sum (λ (i : ι), (f i).nat_degree)
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {f g : ℝ → E} {x : ℝ} (f_Diff : ∀ (y : ℝ), y ≠ x → HasDerivAt f (g y) y) (hF : ContinuousAt f x) (hg : ContinuousAt g x) : HasDerivAt f (g x) x
{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] {r : ℝ} (hr : 0 ≤ r) (x : E) : x +ᵥ r • Metric.ClosedBall 0 1 = Metric.ClosedBall x r
(n k : ℕ) : n.asc_factorial k = (n + k).factorial / n.factorial
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x : V) {r₁ r₂ : ℝ} : 2 • hb.oangle (r₁ • x) (r₂ • x) = 0
{V : Type u} [Fintype V] {G : SimpleGraph V} [DecidableRel G.adj] {v w : V} (h : G.adj v w) : Fintype.card ↥(G.common_neighbors v w) < G.degree v
{R : Type u} [CommRing R] {n : Type w} [DecidableEq n] [Fintype n] (M : Matrix n n R) : ⇑(Polynomial.aeval M) M.charpoly = 0
(C : Type u_1) [CategoryTheory.Category C] : CategoryTheory.IsIdempotentComplete C ↔ ∀ (X : C) (p : X ⟶ X), p ≫ p = p → CategoryTheory.Limits.HasEqualizer (𝟙 X) p
(𝕜 : Type v) [is_R_or_C 𝕜] {E : Type u} [NormedGroup E] [NormedSpace 𝕜 E] (x : E) : ∃ (g : E →L[𝕜] 𝕜), ∥g∥ ≤ 1 ∧ ⇑g x = ↑∥x∥
{α : Type u} [PseudoEmetricSpace α] (E : Set α) : Closure E = ⋂ (δ : ℝ) (h : 0 < δ), Metric.Thickening δ E
{R : Type u} [Semiring R] {a b : AddMonoidAlgebra R ℕ} : {to_Finsupp := a} = {to_Finsupp := b} ↔ a = b
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {n : WithTop ℕ} {f : F → G} {x : E × F} (hF : ContDiffAt 𝕜 n f x.snd) : ContDiffAt 𝕜 n (λ (x : E × F), f x.snd) x
(n : ℕ) : Finset.univ = Finset.cons 0 (Finset.map {ToFun := Fin.succ n, inj' := _} Finset.univ) _
{n : ℕ} {α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) (v : Vector α n) : (Vector.scanl f b v).head = b
{α : Type u_1} {β : Type u_2} [LinearOrder α] [SuccOrder α] [IsSuccArchimedean α] [LinearOrder β] {f : α → β} (hF : Monotone f) (m n : α) : (⋃ (i : α) (H : i ∈ Set.Ico m n), Set.Ioc (f i) (f (Order.succ i))) = Set.Ioc (f m) (f n)
{n m : ℕ} (h : n ≠ m) : IsCoprime (Polynomial.cyclotomic n ℚ) (Polynomial.cyclotomic m ℚ)
{ι : Type u} (s : Finset ι) (w z : ι → Nnreal) (hw' : s.sum (λ (i : ι), w i) = 1) (n : ℕ) : s.sum (λ (i : ι), w i * z i) ^ n ≤ s.sum (λ (i : ι), w i * z i ^ n)
{R : Type u_4} {S : Type u_5} [NonAssocSemiring R] [NonAssocSemiring S] (f : R ≃+* S) : ↑f.to_Add_MonoidHom = ↑f.to_Add_MonoidHom
{n : Type u'} {α : Type v} [Fintype n] [DecidableEq n] [CommRing α] (A : Matrix n n α) (h : IsUnit A.det) : A⁻¹.mul A = 1
{α : Type u} [PseudoMetricSpace α] {s : Set α} {x : α} {r : ℝ} (hs : s.nonempty) : metric.inf_dist x s < r ↔ ∃ (y : α) (H : y ∈ s), HasDist.dist x y < r
{M : Type u_1} [AddCommMonoid M] {s : Set M} (hs : IsAddSubmonoid s) (m : Multiset M) : (∀ (a : M), a ∈ m → a ∈ s) → m.sum ∈ s
{R : Type u} [Semiring R] {S : Type v} [Semiring S] {f : R →+* S} {s : S} (h : s ∈ Set.Range ⇑f) : ⇑Polynomial.c s ∈ Polynomial.lifts f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] (s1 s2 : AffineSubspace k P) : (s1 ⊓ s2).direction ≤ s1.direction ⊓ s2.direction
{p : ℕ} (hp : 1 < p) : padic_val_rat p ↑p = 1
{α : Type u} {l₁ l₂ : List α} {n : ℕ} : List.take n (l₁ ++ l₂) = List.take n l₁ ++ List.take (n - l₁.length) l₂
 : Set.InjOn Nat.factorization {x : ℕ | x ≠ 0}
{M : Type u_1} [AddZeroClass M] (S : AddSubmonoid M) : S = ⊥ ∨ Nontrivial ↥S
{𝕜 : Type u_1} {E : Type u_2} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] {x : E} {s : Set E} : StarConvex 𝕜 x s ↔ ∀ ⦃y : E⦄, y ∈ s → ∀ ⦃a b : 𝕜⦄, 0 ≤ a → 0 ≤ b → 0 < a + b → (a / (a + b)) • x + (b / (a + b)) • y ∈ s
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : ∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * HasInner.inner x y + ∥y∥ ^ 2
{β : Type u} {α : Type v} [CommMonoid β] [Fintype α] [DecidableEq α] (s : Finset α) (f : α → β) : s.prod (λ (i : α), f i) * sᶜ.prod (λ (i : α), f i) = finset.univ.prod (λ (i : α), f i)
{α : Type uu} {r : α → α → Prop} [DecidableRel r] {l : List α} (h : List.Sorted r l) : list.insertion_sort r l = l
{α : Type u} [HasSubset α] {a b : α} [IsAntisymm α HasSubset.Subset] (h : a ⊆ b) (h' : b ⊆ a) : b = a
{x k l : ℕ} (w : 1 < x) : x ^ k ∣ x ^ l ↔ k ≤ l
{α : Type u_1} [IsEmpty α] : Finset.univ = ∅
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z → B} [TopologicalSpace Z] [Nonempty F] (h : IsTopologicalFiberBundle F Proj) : Function.Surjective Proj
{m : Type u_1} [DecidableEq m] [Fintype m] {R : Type v} [CommRing R] (M N P : Matrix m m R) : ((M.mul N).mul P).det = ((M.mul P).mul N).det
{α : Type u} {β : Type v} [Group α] [MulAction α β] (g : α) (x : β) : MulAction.stabilizer α (g • x) = Subgroup.map (Mul_equiv.to_MonoidHom (⇑MulAut.conj g)) (MulAction.stabilizer α x)
{n : ℕ} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : ⇑fin.cast_Succ j < i) : SimplexCategoryδ i.succ ≫ SimplexCategoryσ (⇑fin.cast_Succ j) = SimplexCategoryσ j ≫ SimplexCategoryδ i
{𝕜 : Type u_3} {E : Type u_4} [NormedField 𝕜] [SemiNormedGroup E] [NormedSpace 𝕜 E] {r : ℝ} : Balanced 𝕜 (Metric.Ball 0 r)
{α : Type u_1} {β : Type u_2} {ι : Type u_4} [UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι} (h : TendstoUniformly F f p) (x : α) : Filter.Tendsto (λ (n : ι), F n x) p (nhds (f x))
{K : Type u} [Field K] {S T : Subfield K} (h : ∀ (x : K), x ∈ S ↔ x ∈ T) : S = T
{α : Type u_3} {β : Type u_4} [LinearOrderedField α] {l : Filter β} {f : β → α} {r : α} (hr : 0 < r) (hF : Filter.Tendsto f l filter.at_IsBot) : Filter.Tendsto (λ (x : β), f x * r) l filter.at_IsBot
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasKernels C] [CategoryTheory.Limits.HasCokernels C] [∀ {X Y : C} (f : X ⟶ Y), CategoryTheory.IsIso (Category_theory.abelian.coimage_image_comparison f)] : CategoryTheory.Limits.HasImages C
{R : Type u} {A₁ : Type v} {A₂ : Type w} [CommSemiring R] [Semiring A₁] [Semiring A₂] [Algebra R A₁] [Algebra R A₂] (e : A₁ ≃ₐ[R] A₂) : ↑↑e = ↑↑e
{M : Type u_1} [AddZeroClass M] (c : AddCon M) : AddCon.ker c.mk' = c
{J : Type v} [CategoryTheory.SmallCategory J] (F : J ⥤ Mon_) [CategoryTheory.IsFiltered J] (x y : Σ (j : J), ↥(F.obj j)) (k : J) (f : x.fst ⟶ k) (g : y.fst ⟶ k) : Mon.FilteredColimits.M.mk F x * Mon.FilteredColimits.M.mk F y = Mon.FilteredColimits.M.mk F ⟨k, ⇑(F.map f) x.snd * ⇑(F.map g) y.snd⟩
{α : Type u} [PseudoMetricSpace α] {s : Set α} {x : α} (h : is_IsClosed s) (hs : s.nonempty) : x ∉ s ↔ 0 < metric.inf_dist x s
(cf cg : Nat.Partrec.Code) (a k : ℕ) : (cf.prec cg).eval (Nat.mkpair a k.succ) = (cf.prec cg).eval (Nat.mkpair a k) >>= λ (ih : ℕ), cg.eval (Nat.mkpair a (Nat.mkpair k ih))
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : Type u_2} [NormedGroup F] [NormedSpace 𝕜 F] {n : ℕ} {f : 𝕜 → F} : iterated_deriv n f = ⇑((Continuous_multilinear_map.pi_Field_Equiv 𝕜 (Fin n) F).symm) ∘ iterated_fderiv 𝕜 n f
{α : Type u} {β : Type v} {γ : Type u_1} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] {f : α → β × γ} {x : α} (hF : ContinuousAt f x) : ContinuousAt (λ (a : α), (f a).fst) x
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [TopologicalSpace B] [TopologicalSpace F] {Proj : Z → B} [TopologicalSpace Z] [Nonempty F] (h : IsTopologicalFiberBundle F Proj) : QuotientMap Proj
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] {a b : α} (hab : a ≠ b) : Closure (Set.Ioo a b) = Set.Icc a b
{M : Type u_3} {N : Type u_4} [MulZeroOneClass M] [MulZeroOneClass N] {f g : M →*₀ N} : f = g ↔ ∀ (x : M), ⇑f x = ⇑g x
{α : Type u_1} [HasLt α] {a b : α} {o : Ordering} : o.compares b a → o.swap.compares a b
{α : Type u} [Group α] (g : GroupTopology α) : Continuous (λ (p : α × α), p.fst * p.snd)
{α : Type u} [PseudoMetricSpace α] {s t : Set α} : Metric.Bounded (s ∪ t) ↔ Metric.Bounded s ∧ Metric.Bounded t
{X : Type u} [Preorder X] {x y : X} (h : x ⟶ y) : x ≤ y
{V : Type u} [Quiver V] (r : V) [Quiver.RootedConnected r] {a : V} (p : Quiver.Path r a) : (quiver.shortest_Path r a).length ≤ p.length
{𝕜 : Type u_1} [is_R_or_C 𝕜] {m : Type u_5} {n : Type u_6} [Fintype m] [DecidableEq m] [Fintype n] [DecidableEq n] (A : Matrix m n 𝕜) : ⇑matrix.to_lin' A.conj_transpose = ⇑LinearMap.adjoint (⇑matrix.to_lin' A)
{α : Type u} [PseudoMetricSpace α] {x y : α} : metric.inf_dist x {y} = HasDist.dist x y
{R : Type u_1} {a b : R} [Semigroup R] (Ab : IsRegular (a * b)) (ba : IsRegular (b * a)) : IsRegular a ∧ IsRegular b
{α : Type u_1} {β : Type u_2} [LinearOrder α] [SuccOrder α] [Preorder β] {f : α → β} (hF : Monotone f) : Pairwise (Disjoint on λ (n : α), Set.Ico (f n) (f (Order.succ n)))
{α : Type u} {a b : α} [MulOneClass α] [HasZero α] [Preorder α] [ZeroLt.MulPosStrictMono α] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b
{α : Type u_1} [HasLt α] {a b : α} : b < a → ⇑order_dual.to_dual a < ⇑order_dual.to_dual b
{α : Type u} [AddGroup α] [HasLt α] [CovariantClass α α (Function.swap has_add.add) has_lt.lt] {a b : α} : a < b → a - b < 0
(R : Type u_1) [has_One R] [HasNeg R] : Cardinal.mk (Quaternion R) = Cardinal.mk R ^ 4
{α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} [DecidableEq β'] [DecidableEq γ] [DecidableEq δ] {s : Finset α} {t : Finset β} {f : α → β' → γ} {g : β → β'} {f' : α → β → δ} {g' : δ → γ} (h_Right_comm : ∀ (a : α) (b : β), f a (g b) = g' (f' a b)) : Finset.image₂ f s (Finset.image g t) = Finset.image g' (Finset.image₂ f' s t)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) : hb.oangle y x = -hb.oangle x y
{f : ℝ → ℝ} {a : ℝ} (h : is_is_IsLocalMin f a) : deriv f a = 0
{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] {n : Type w} [Nontrivial R] {B : BilinForm R M} {v : Basis n R M} (h : B.is_Ortho ⇑v) (hB : B.nondegenerate) (i : n) : ¬B.is_IsOrtho (⇑v i) (⇑v i)
{ι : Type u_1} {R₂ : Type u_7} {M₂ : Type u_8} [CommRing R₂] [AddCommGroup M₂] [Module R₂ M₂] [DecidableEq ι] (e : Basis ι R₂ M₂) {w : ι → R₂} (hw : ∀ (i : ι), IsUnit (w i)) : e.to_Matrix ⇑(e.is_Unit_Smul hw) = Matrix.diagonal w
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) {x : L} : x ∈ S → -x ∈ S
{a b : Prop} (h₁ : a → b) (h₂ : ¬b) : ¬a
{α : Type u_2} [Bornology α] {s : Set α} : Bornology.IsCobounded s → Bornology.IsBounded sᶜ
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4} [is_R_or_C 𝕜] [NormedSpace 𝕜 E] [NormedGroup G] [NormedSpace 𝕜 G] {f : E → G} {s : Set E} {C : Nnreal} (hF : DifferentiableOn 𝕜 f s) (bound : ∀ (x : E), x ∈ s → ∥fderiv_within 𝕜 f s x∥₊ ≤ C) (hs : Convex ℝ s) : LipschitzOnWith C f s
{M : Type u} [MulOneClass M] (a : M) : SemiconjBy a 1 1
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {F G : C ⥤ D} (α : F ⟶ G) [∀ (X : C), CategoryTheory.Mono (α.app X)] : CategoryTheory.Mono α
{M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N] {f : M →* N} (h : ∀ (y : ↥S), IsUnit (⇑f ↑y)) (y : ↥S) (w z : N) : w * ↑(⇑(is_unit.lift_Right (f.restrict S) h) y)⁻¹ = z ↔ w = ⇑f ↑y * z
{K : Type u} [Field K] (s : Subfield K) : 1 ∈ s
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.IsCofiltered C] (O : Finset C) : ∃ (S : C), ∀ {X : C}, X ∈ O → Nonempty (S ⟶ X)
{α : Type u_1} {β : Type u_2} {Op : β → β → β} [hc : IsCommutative β Op] [ha : IsAssociative β Op] {f : α → β} {b : β} {s : Finset α} {g : α → β} (hb : Op b b = b) (p : α → Prop) [DecidablePred p] : Finset.fold Op b (λ (i : α), Ite (p i) (f i) (g i)) s = Op (Finset.fold Op b f (Finset.filter p s)) (Finset.fold Op b g (Finset.filter (λ (i : α), ¬p i) s))
{F : Type u_1} [Field F] [Fintype F] : IsSquare (-1) ↔ Fintype.card F % 4 ≠ 3
(f : ↥(MeasureTheory.lp ℂ 2 haar_Circle)) : HasSum (λ (i : ℤ), ⇑(⇑(fourier_series.repr) f) i • fourier_Lp 2 i) f
{K : Type u_1} {n : ℕ} {g : GeneralizedContinuedFraction K} [DivisionRing K] : g.convergents' (n + 1) = (g.squash_gcf n).convergents' n
{R : Type u} [Ring R] [StrongRankCondition R] {M : Type v} [AddCommGroup M] [Module R M] {ι : Type u_1} (b : Basis ι R M) (h : Module.rank R M < Cardinal.aleph_0) : Nonempty (Fintype ι)
{E : Type u} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {c : ℂ} {r R : ℝ} (h0 : 0 < r) (hle : r ≤ R) {f : ℂ → E} {s : Set ℂ} (hs : s.countable) (hc : ContinuousOn f (Metric.ClosedBall c R  Metric.Ball c r)) (hD : ∀ (z : ℂ), z ∈ Metric.Ball c R  Metric.ClosedBall c r  s → DifferentiableAt ℂ f z) : ∮ (z : ℂ) in C(c, R), (z - c)⁻¹ • f z = ∮ (z : ℂ) in C(c, r), (z - c)⁻¹ • f z
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) (i : Fin (n + 1)) : s.points_with_circumcenter (Affine.Simplex.PointsWithCircumcenterIndex.point_Index i) = s.points i
{C : Type u₁} [CategoryTheory.Category C] (X : Type v₁) [CategoryTheory.Limits.HasProductsOfShape X C] : CategoryTheory.Limits.HasCoproductsOfShape X Cᵒᵖ
{α : Type u_1} [TopologicalSpace α] {γ : Type u_4} [LinearOrderedAddCommMonoid γ] [TopologicalSpace γ] [OrderTopology γ] {f g : α → γ} (hF : LowerSemicontinuous f) (hg : LowerSemicontinuous g) (hcont : ∀ (x : α), ContinuousAt (λ (p : γ × γ), p.fst + p.snd) (f x, g x)) : LowerSemicontinuous (λ (z : α), f z + g z)
{β : Type u_2} [EmetricSpace β] {a : β} {r : Ennreal} (x y : ↥(Emetric.Ball a r)) : HasEdist.edist x.val y.val ≠ ⊤
{α : Type u} [AddGroup α] [HasLe α] [CovariantClass α α has_add.add has_le.le] {a b c : α} : a + b ≤ c → b ≤ -a + c
{α : Type u} [TopologicalSpace α] {s : Set α} (H : IsTotallySeparated s) : IsTotallyDisconnected s
{𝕜 : Type u_1} {E : Type u_2} [NormedField 𝕜] [AddCommGroup E] [Module 𝕜 E] [TopologicalSpace E] [HasContinuousSmul 𝕜 E] (x : E) : bornology.is_vonN_bounded 𝕜 {x}
{α : Type u_1} [LinearOrderedField α] {a b : α} (ha : a < 0) (hb : b < 0) : 1 / a ≤ 1 / b ↔ b ≤ a
{α : Type u_1} {M : Type u_5} {N : Type u_7} [HasZero M] [AddCommMonoid N] {s : Finset α} {f : α → M} {g : α → M → N} (hF : ∀ (a : α), f a ≠ 0 → a ∈ s) (hg : ∀ (a : α), g a 0 = 0) : (finsupp.on_Finset s f hF).sum g = s.sum (λ (a : α), g a (f a))
{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {s : Set α} {t : Set β} : is_IsOpen (s ×ˢ t) ↔ is_IsOpen s ∧ is_IsOpen t ∨ s = ∅ ∨ t = ∅
{α : Type u_1} {ι : Type u_2} {β : Type u_3} {S : ι → Set α} {f : Π (i : ι), ↥(S i) → β} {hF : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩} {T : Set α} {hT : T ⊆ Set.Union S} (c : ↥T) (ci : Π (i : ι), ↥(S i)) (hci : ∀ (i : ι), ↑(ci i) = ↑c) (cβ : β) (h : ∀ (i : ι), f i (ci i) = cβ) : Set.Union_Lift S f hF T hT c = cβ
{G : Type u_1} [AddGroup G] {k : Set G} {p : G → Prop} {x : G} (h : x ∈ AddSubgroup.closure k) (Hk : ∀ (x : G), x ∈ k → p x) (H1 : p 0) (hMul : ∀ (x y : G), p x → p y → p (x + y)) (Hinv : ∀ (x : G), p x → p (-x)) : p x
{X : Top} (F : Top.Presheaf (Type v) X) : F.is_sheaf ↔ F.is_sheaf_Unique_gluing
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (X Y : C) : CategoryTheory.IsIso (CategoryTheory.Limits.cokernelπ 0)
{α : Type u_1} {ι : Type u_4} (s : ι → Set α) : (⋂ (i : ι), s i) = ⋂ (t : Finset ι) (i : ι) (H : i ∈ t), s i
{α : Type u} {β : Type v} [PseudoEmetricSpace α] [PseudoEmetricSpace β] {K : Nnreal} {f : α → β} (hF : LipschitzWith K f) : UniformContinuous f
{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {F : Type u_2} [NormedGroup F] [NormedSpace ℝ F] [FiniteDimensional ℝ F] {s : Set E} {f : E → F} {f' : E ≃L[ℝ] F} {c : Nnreal} (hF : ApproximatesLinearOn f ↑f' s c) (hc : Subsingleton E ∨ lipschitz_extension_constant F * c < ∥↑(f'.symm)∥₊⁻¹) : ∃ (g : E ≃ₜ F), Set.EqOn f ⇑g s
{R : Type u_1} [CommRing R] (v w : Fin 3 → R) : -⇑(⇑CrossProduct v) w = ⇑(⇑CrossProduct w) v
(p : ℕ) [p_Prime : Fact (Nat.Prime p)] {n₁ n₂ d₁ d₂ : ℤ} (hn₁ : n₁ ≠ 0) (hn₂ : n₂ ≠ 0) (hD₁ : d₁ ≠ 0) (hD₂ : d₂ ≠ 0) : padic_val_rat p (Rat.mk n₁ d₁) ≤ padic_val_rat p (Rat.mk n₂ d₂) ↔ ∀ (n : ℕ), ↑p ^ n ∣ n₁ * d₂ → ↑p ^ n ∣ n₂ * d₁
{R : Type u} [CommSemiring R] [StarRing R] (x : R) : ⇑(StarRing_end R) (⇑(StarRing_end R) x) = x
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} {f' : E →L[𝕜] F} {s : Set E} {c : Nnreal} : ApproximatesLinearOn f f' s c → LipschitzOnWith c (f - ⇑f') s
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {n : WithTop ℕ} (h : ContDiffOn 𝕜 n f s) (hs : UniqueDiffOn 𝕜 s) : HasFtaylorSeriesUpToOn n f (ftaylor_series_within 𝕜 f s) s
{α : Type u_1} (L : List (List α)) {i j : ℕ} (hi : i < L.length) (hj : j < (L.nth_LE i hi).length) : (List.take i (List.map List.length L)).sum + j < L.join.length
{α : Type u_1} {E' : Type u_6} {F' : Type u_7} [SemiNormedGroup E'] [SemiNormedGroup F'] {f' : α → E'} {g' : α → F'} {l : Filter α} : ((λ (x : α), ∥f' x∥) =O[l] λ (x : α), ∥g' x∥) → f' =O[l] g'
{𝕜 : Type u_1} {E : Type u_4} {Fₗ : Type u_7} [NormedGroup E] [NormedGroup Fₗ] [NondiscreteNormedField 𝕜] [NormedSpace 𝕜 E] [NormedSpace 𝕜 Fₗ] (c : E →L[𝕜] 𝕜) (f : Fₗ) : ∥c.smul_Right f∥ = ∥c∥ * ∥f∥
(p : ℕ) [p_Prime : Fact (Nat.Prime p)] {q r : ℚ} (hq : q ≠ 0) (hr : r ≠ 0) : padic_val_rat p (q * r) = padic_val_rat p q + padic_val_rat p r
{Γ₀ : Type u_1} [LinearOrderedCommGroupWithZero Γ₀] (γ : Γ₀) (h : γ ≠ 0) : {γ} ∈ nhds γ
{K : Type v} {V : Type w} [Field K] [AddCommGroup V] [Module K V] [IsAlgClosed K] [FiniteDimensional K V] [Nontrivial V] (f : Module.End K V) : ∃ (c : K), f.has_eigenvalue c
{X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X] {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] : Gromov_Hausdorff.to_GH_Space X = Gromov_Hausdorff.to_GH_Space Y ↔ Nonempty (X ≃ᵢ Y)
{α : Type u} : TopologicalSpace.induced has_pure.pure ultrafilter.topological_Space = ⊥
(p : ℕ) : ↑(mersenne p) = 0
{C : Type u₁} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {X Y Z : C} [CategoryTheory.HasRightDual X] [CategoryTheory.HasRightDual Y] [CategoryTheory.HasRightDual Z] {f : X ⟶ Y} {g : Y ⟶ Z} : (f ≫ g)ᘁ = gᘁ ≫ fᘁ
{α : Type u} [PseudoEmetricSpace α] : Isometry Id
{β : Type u} {α : Type v} {γ : Type w} [CommMonoid β] {s : Finset α} {t : Finset γ} {f : α → β} {g : γ → β} (i : Π (a : α), a ∈ s → γ) (hi : ∀ (a : α) (ha : a ∈ s), i a ha ∈ t) (h : ∀ (a : α) (ha : a ∈ s), f a = g (i a ha)) (j : Π (a : γ), a ∈ t → α) (hj : ∀ (a : γ) (ha : a ∈ t), j a ha ∈ s) (IsLeftInv : ∀ (a : α) (ha : a ∈ s), j (i a ha) _ = a) (IsRightInv : ∀ (a : γ) (ha : a ∈ t), i (j a ha) _ = a) : s.prod (λ (x : α), f x) = t.prod (λ (x : γ), g x)
{K : Type u_1} {V : Type u_2} [Field K] [Ring V] [Algebra K V] {s : Subalgebra K V} (h : FiniteDimensional K ↥(s.to_Submodule)) : FiniteDimensional K ↥s
{α : Type u_1} (l : List α) (c : Composition l.length) : List.map List.length (l.split_wrt_Composition c) = c.blocks
(u : Pnat.XgcdType) (hr : u.r ≠ 0) : sizeOf u.step < sizeOf u
(A : Type u_4) (K : Type u_5) (C : Type u_6) [CommRing A] [is_IsDomain A] [Field K] [Algebra A K] [IsFractionRing A K] [CommRing C] [Algebra A C] [Algebra K C] [IsScalarTower A K C] {x : C} : IsAlgebraic A x ↔ IsAlgebraic K x
{k : Type u_1} {E : Type u_2} [LinearOrderedField k] [OrderedAddCommGroup E] [Module k E] [OrderedSmul k E] {f : k → E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : ⇑(affine_map.line_Map (f a) (f b)) r < f (⇑(affine_map.line_Map a b) r) ↔ slope f (⇑(affine_map.line_Map a b) r) b < slope f a b
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} {ι₂ : Type u_5} (s₂ : Finset ι₂) (e : ι₂ ↪ ι) (p : ι → P) : Finset.centroid k (Finset.map e s₂) p = Finset.centroid k s₂ (p ∘ ⇑e)
{G : Type u} [Monoid G] (H : Submonoid G) (x : ↥H) : IsOfFinOrder x ↔ IsOfFinOrder ↑x
{α : Type u_1} {β : Type u_2} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α] [OrderTopology α] [TopologicalSpace β] {s : Set β} {f : β → α} (hF : ContinuousOn f s) (hsc : is_IsClosed s) {x₀ : β} (h₀ : x₀ ∈ s) (hc : ∀ᶠ (x : β) in Filter.cocompact β ⊓ Filter.principal s, f x₀ ≤ f x) : ∃ (x : β) (H : x ∈ s), ∀ (y : β), y ∈ s → f x ≤ f y
{α : Type u_1} {c : Set (Set α)} (hu : ⋃₀c = Set.Univ) (H : c.pairwise_Disjoint Id) (a : α) : ∃! (b : Set α) (H : b ∈ c), a ∈ b
{G : Type u_4} [NormedGroup G] [NormedSpace ℝ G] {s : Set G} (conv : Convex ℝ s) (hs : (Interior s).nonempty) {x : G} (hx : x ∈ Closure s) : UniqueDiffWithinAt ℝ s x
{a k : ℕ} (h0 : 0 < a) (h1 : a < k) (n : ℕ) : (k + n).prime_counting' ≤ k.prime_counting' + a.totient * (n / a + 1)
{cb : CharBuffer} {n n' val : ℕ} (h : Parser.nat cb n = ParseResult.done n' val) (hn : n' ≤ Buffer.size cb) (k : ℕ) (hk : k < n') : n ≤ k → '0' ≤ Buffer.read cb ⟨k, _⟩ ∧ Buffer.read cb ⟨k, _⟩ ≤ '9'
{α : Type u_1} {r₁ r₂ : Setoid α} : r₁ = r₂ ↔ ∀ (x : α), {y : α | r₁.rel x y} = {y : α | r₂.rel x y}
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {E : Type v} [NormedGroup E] [NormedSpace 𝕜 E] [CompleteSpace 𝕜] {c : 𝕜} (hc : 1 < ∥c∥) {R : ℝ} (hR : ∥c∥ < R) (h : ¬FiniteDimensional 𝕜 E) (s : Finset E) : ∃ (x : E), ∥x∥ ≤ R ∧ ∀ (y : E), y ∈ s → 1 ≤ ∥y - x∥
(R : Type u) (M : Type v) [Ring R] [StrongRankCondition R] [AddCommGroup M] [Module R M] [Module.Free R M] [Module.Finite R M] : Module.rank R M < Cardinal.aleph_0
{α : Type u_3} [OrderedSemiring α] {n : ℕ} (hn : 1 ≤ n) : Filter.Tendsto (λ (x : α), x ^ n) filter.at_Top filter.at_Top
{α : Type u_1} {ι' : sort u_5} (s : ι' → Set α) : (⋃ (i : ι'), s i) = ⋃ (t : Finset (plift ι')) (i : plift ι') (H : i ∈ t), s i.down
{R : Type u_1} [AddCommGroup R] {f g : ℕ → R} : (∀ (n : ℕ), 0 < n → n.divisors.sum (λ (i : ℕ), f i) = g n) ↔ ∀ (n : ℕ), 0 < n → n.divisors_antidiagonal.sum (λ (x : ℕ × ℕ), ⇑Nat.ArithmeticFunction.moebius x.fst • g x.snd) = f n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] [CategoryTheory.Limits.HasBinaryBiproducts C] (P Q : C) : (CategoryTheory.Limits.biprod.braiding P Q).hom ≫ (CategoryTheory.Limits.biprod.braiding Q P).hom = 𝟙 (P ⊞ Q)
{f : ℂ → ℂ} {c : ℂ} {R : ℝ} (hD : DifferentiableOn ℂ f (Metric.Ball c R)) (h_maps : Set.MapsTo f (Metric.Ball c R) (Metric.Ball c R)) (hc : f c = c) (h₀ : 0 < R) : Complex.abs (deriv f c) ≤ 1
{R : Type u} [Semiring R] {S : Type v} [Semiring S] (f : R →+* S) (n : ℕ) : Polynomial.x ^ n ∈ Polynomial.lifts f
{C : Type u₁} [CategoryTheory.Category C] (T : CategoryTheory.Monad C) {A B : T.algebra} (f : A ⟶ B) [CategoryTheory.IsIso f.f] : CategoryTheory.IsIso f
{R : Type u} [CommRing R] {p q : Polynomial R} (hmonic : q.monic) (hdegree : q.degree ≤ p.degree) : (p /ₘ q).leading_Coeff = p.leading_Coeff
{R : Type u} [NonAssocSemiring R] {s : Set R} : s ⊆ ↑(Subsemiring.closure s)
{p a b : ℕ} (hab : a.coprime b) (hpa : p ∈ a.factors) : ⇑((a * b).factorization) p = ⇑(a.factorization) p
{m n : ℕ+} : m.factor_Multiset ≤ n.factor_Multiset ↔ m ∣ n
{M₀ : Type u_1} [MulZeroClass M₀] [NoZeroDivisors M₀] {a b : M₀} : a * b = 0 ↔ a = 0 ∨ b = 0
{𝕜 : Type u_3} {E : Type u_4} [SemiNormedRing 𝕜] [AddCommGroup E] [Module 𝕜 E] (p : Seminorm 𝕜 E) (x y : E) : ⇑p y ≤ ⇑p x + ⇑p (x - y)
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x : V) {r₁ r₂ : ℝ} (hr₁ : 0 ≤ r₁) (hr₂ : 0 ≤ r₂) : hb.oangle (r₁ • x) (r₂ • x) = 0
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {G : Type u_4} [NormedGroup G] [NormedSpace 𝕜 G] {s : Set E} {f : E → F} {x : E} {n : WithTop ℕ} (e : F ≃L[𝕜] G) : ContDiffWithinAt 𝕜 n (⇑e ∘ f) s x ↔ ContDiffWithinAt 𝕜 n f s x
(x : ℝ) : Real.sinh (Real.arsinh x) = x
{M : Type u_3} [AddMonoid M] [Preorder M] (L : List M) (h : 0 < L.sum) : 0 < L.length
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {V : ι → Submodule 𝕜 E} (hV : OrthogonalFamily 𝕜 (λ (i : ι), (V i).subtypeₗᵢ)) : CompleteLattice.Independent V
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} (s : Finset ι) (f : ι → E) (x : E) : HasInner.inner (s.sum (λ (i : ι), f i)) x = s.sum (λ (i : ι), HasInner.inner (f i) x)
{G : Type u_1} [Group G] [TopologicalSpace G] [NonarchimedeanGroup G] {H : Type u_2} [Group H] [TopologicalSpace H] [TopologicalGroup H] (f : G →* H) (emb : OpenEmbedding ⇑f) : NonarchimedeanGroup H
{p : ℕ} {z : ℤ} : padic_val_rat p ↑z = ↑(padic_val_Int p z)
{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] (s : Submodule R M) : s.fg ↔ CompleteLattice.IsCompactElement s
{α : Type u_1} [MulOneClass α] [Preorder α] [CovariantClass α α (Function.swap has_mul.mul) has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1
{ι : Type u} {β : ι → Type v} [dec : DecidableEq ι] [Π (i : ι), AddCommMonoid (β i)] : ⇑dfinsupp.lift_AddHom (Dfinsupp.single_AddHom β) = AddMonoidHom.id (Π₀ (i : ι), β i)
{X : Type u_1} {Y : Type u_2} [PseudoEmetricSpace X] [PseudoEmetricSpace Y] {C : Nnreal} {f : X → Y} {s : Set X} : LipschitzOnWith C f s → HolderOnWith C 1 f s
{β : Type u} {α : Type v} {γ : Type w} {s : Finset α} [AddCommMonoid β] [DecidableEq γ] (f : γ → β) (g : α → γ) : s.sum (λ (a : α), f (g a)) = (Finset.image g s).sum (λ (b : γ), (Finset.filter (λ (a : α), g a = b) s).card • f b)
{α : Type u} {a b : α} [MulOneClass α] [HasZero α] [Preorder α] [ZeroLt.MulPosMono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b ≤ 1
{G₀ : Type u_2} {G₀' : Type u_4} [GroupWithZero G₀] [GroupWithZero G₀'] (f : G₀ →*₀ G₀') (a : G₀) : ⇑f a⁻¹ = (⇑f a)⁻¹
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasBinaryCoproducts C] (P Q : C) : (CategoryTheory.Limits.coprod.braiding P Q).hom ≫ (CategoryTheory.Limits.coprod.braiding Q P).hom = 𝟙 (P ⨿ Q)
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ : Real.Angle) : ⇑LinearMap.det ↑((o.rotation θ).to_LinearEquiv) = 1
{J : Type u₁} [CategoryTheory.Category J] {C : Type u₃} [CategoryTheory.Category C] {K : J ⥤ C} {c d : CategoryTheory.Limits.Cone K} (f : c ⟶ d) [i : CategoryTheory.IsIso f.hom] : CategoryTheory.IsIso f
{α : Type u} {β : Type v} [Preorder α] [PartialOrder β] {l : α → β} {u : β → α} (gc : GaloisConnection l u) (b : β) : (∃ (a : α), b = l a) ↔ b = l (u b)
{ι : Type u_1} {ι' : Type u_2} {α : Type u_3} [Fintype ι] [Preorder ι'] [IsDirected ι' (Function.swap has_le.le)] [Nonempty ι'] {s : ι → ι' → Set α} (hs : ∀ (i : ι), Monotone (s i)) : (⋂ (j : ι'), ⋃ (i : ι), s i j) = ⋃ (i : ι), ⋂ (j : ι'), s i j
{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), AddGroup (Gs i)] (tfGs : ∀ (i : η), Add_monoid.is_torsion_free (Gs i)) : Add_monoid.is_torsion_free (Π (i : η), Gs i)
{V : Type u_1} (α : Type u_2) (G : SimpleGraph V) [DecidableRel G.adj] [HasZero α] [has_One α] : (simple_graph.adj_Matrix α G).is_IsAdjMatrix
{C : Type u₁} [CategoryTheory.Category C] {X Y : C} {f : X ⟶ Y} [CategoryTheory.SplitEpi f] [CategoryTheory.Epi (CategoryTheory.section_ f)] : CategoryTheory.IsIso f
{F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (a : F) : char.quadratic_Char F a = 0 ↔ a = 0
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p ∈ s) (p2 : P) : p -ᵥ p2 ∈ s.direction ↔ p2 ∈ s
{α : Type u_1} [Semigroup α] {a b : α} (c : α) (h : a * c = b) : a ∣ b
{α : Type u} [TopologicalSpace α] {s t : Set α} (hs : is_IsCompact s) (ht : is_IsClosed t) (h : t ⊆ s) : is_IsCompact t
{α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β → γ} {ta1 ta2 : TopologicalSpace α} {tb1 tb2 : TopologicalSpace β} {Tc1 : TopologicalSpace γ} (h : Continuous (λ (p : α × β), f p.fst p.snd)) : Continuous (λ (p : α × β), f p.fst p.snd)
{M : Type u_3} {N : Type u_4} [MulOneClass M] [MulOneClass N] (f : M →* N) : ⇑f 1 = 1
{G : Type u_1} {P : Type u_2} [AddGroup G] [T : AddTorsor G P] (p1 p2 : P) : p1 -ᵥ p2 +ᵥ p2 = p1
(P L : Type u) [HasMem P L] [Configuration.HasLines P L] [Fintype P] [Fintype L] : Fintype.card P ≤ Fintype.card L
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p₁ : ι → P) (p₂ b : P) : s.sum (λ (i : ι), w i • (p₁ i -ᵥ p₂)) = ⇑(s.weighted_vsub_of_point p₁ b) w - s.sum (λ (i : ι), w i) • (p₂ -ᵥ b)
{α : Type u} {s : Set α} (hs : s.nonempty) : s.countable ↔ ∃ (f : ℕ → ↥s), Function.Surjective f
{𝕂 : Type u_1} [NondiscreteNormedField 𝕂] [CompleteSpace 𝕂] [CharZero 𝕂] {x : 𝕂} (hx : x ∈ Emetric.Ball 0 (Exp_series 𝕂 𝕂).radius) : HasStrictDerivAt (Exp 𝕂) (Exp 𝕂 x) x
{α : Type u_1} {β : Type u_2} [TopologicalSpace α] [BaireSpace α] {S : Set β} {f : β → Set α} (hc : ∀ (s : β), s ∈ S → is_IsClosed (f s)) (hS : S.countable) (hU : (⋃ (s : β) (H : s ∈ S), f s) = Set.Univ) : Dense (⋃ (s : β) (H : s ∈ S), Interior (f s))
{n : ℕ} {p : Fin n} {i : Fin (n + 1)} (h : i ≠ ⇑fin.cast_Succ p) : ⇑((⇑fin.cast_Succ p).succ_above) (p.pred_above i) = i
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] (p : P) : ⇑(EuclideanGeometry.reflection s) p = p ↔ p ∈ s
{α : Type u_1} (a : α) [Subsingleton α] : Fintype.card α = 1
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasWidePullbacks C] {B : C} : CategoryTheory.Limits.HasProducts (CategoryTheory.Over B)
{F : Type u_3} [InnerProductSpace ℝ F] (x y : F) : HasInner.inner x y / (∥x∥ * ∥y∥) = -1 ↔ x ≠ 0 ∧ ∃ (r : ℝ), r < 0 ∧ y = r • x
{G : Type u} {x y : G} [AddCommMonoid G] (hx : IsOfFinAddOrder x) (hy : IsOfFinAddOrder y) : IsOfFinAddOrder (x + y)
(A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) [Nontrivial B] : ¬IsUnit (minpoly A x)
{α : Type u} {ι : sort x} {f : ι → Filter α} [Nonempty ι] (hD : Directed GE f) (hb : ∀ (i : ι), (f i).ne_IsBot) : (infi f).ne_IsBot
{M : Type u_5} [AddCommGroup M] (h : Module ℤ M) (n : ℤ) (x : M) : n • x = n • x
{R : Type u_1} {E : Type u_2} {ι : Type u_4} [LinearOrderedField R] [AddCommGroup E] [Module R E] (s : Finset ι) (hs : s.nonempty) (p : ι → E) : Finset.centroid R s p = s.center_mass (Finset.centroid_weights R s) p
{α : Type u_1} [Preorder α] {a b : α} (h : b < a) : ¬IsMin a
{α : Type u_1} {β : Type u_2} {γ : Type u_3} [TopologicalSpace α] [TopologicalSpace β] [TopologicalSpace γ] (e : LocalHomeomorph α β) {f : γ → α} {x : γ} (h : f ⁻¹' e.to_local_equiv.source ∈ nhds x) : ContinuousAt f x ↔ ContinuousAt (⇑e ∘ f) x
{α : Type u} [AddGroup α] [HasLe α] [CovariantClass α α (Function.swap has_add.add) has_le.le] {a b : α} : b ≤ a → 0 ≤ a - b
{X : Type u_1} [TopologicalSpace X] {a b : X} (γ : Path a b) : Continuous (λ (x : ℝ × ℝ × ↥UnitInterval), ⇑(γ.truncate x.fst x.snd.fst) x.snd.snd)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} {x : E} : mfderiv (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f x = fderiv 𝕜 f x
{α : Type u} [PseudoMetricSpace α] {s : ℕ → Set α} (h0 : IsComplete (s 0)) (hs : ∀ (n : ℕ), is_IsClosed (s n)) (h's : ∀ (n : ℕ), Metric.Bounded (s n)) (h : ∀ (N : ℕ), (⋂ (n : ℕ) (H : n ≤ N), s n).nonempty) (h' : Filter.Tendsto (λ (n : ℕ), Metric.diam (s n)) filter.at_Top (nhds 0)) : (⋂ (n : ℕ), s n).nonempty
{G : Type w} [TopologicalSpace G] [Group G] [TopologicalGroup G] {K U : Set G} (hK : is_IsCompact K) (hU : is_IsOpen U) (hKU : K ⊆ U) : ∃ (V : Set G) (H : V ∈ nhds 1), K * V ⊆ U
{K : Type u_1} {L : Type u_2} [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) (x : K) : ⇑(Algebra_Map K L) x ∈ S
{α : Type u_1} [DecidableEq α] (xs : List α) (x d d' : α) (x_mem : x ∈ xs) (x_NE : x ≠ xs.last _) : xs.next_or x d = xs.next_or x d'
{ι : Type u_1} {R : Type u_3} {M : Type u_5} {v : ι → M} [Ring R] [AddCommGroup M] [Module R M] {hli : LinearIndependent R v} {hsp : Submodule.span R (Set.Range v) = ⊤} (i : ι) : ⇑((Basis.mk hli hsp).coord i) (v i) = 1
{α : Type u_1} [Preorder α] [LocallyFiniteOrder α] {a b : α} : ¬a ≤ b → Multiset.icc a b = 0
{M : Type u_3} {N : Type u_4} [AddZeroClass M] [AddZeroClass N] {f g : M →+ N} (h : f = g) (x : M) : ⇑f x = ⇑g x
{V : Type u_1} [InnerProductSpace ℝ V] {P : Type u_2} [MetricSpace P] [NormedAddTorsor V P] {a b c d p : P} (h : EuclideanGeometry.Cospherical {a, b, c, d}) (hab : a ≠ b) (hcd : c ≠ d) (hapb : EuclideanGeometry.angle a p b = 0) (hcpd : EuclideanGeometry.angle c p d = 0) : HasDist.dist a p * HasDist.dist b p = HasDist.dist c p * HasDist.dist d p
{α : Type u_1} {β : Type u_2} [LinearOrder α] [SuccOrder α] [Preorder β] {f : α → β} (hF : Antitone f) : Pairwise (Disjoint on λ (n : α), Set.Ioo (f (Order.succ n)) (f n))
(p : Nat.Primes) : ↑p.factor_Multiset = Prime_multiset.of_Prime p
{M : Type u_1} [HasMul M] (r : M → M → Prop) : ConGen ⇑(ConGen r) = ConGen r
(K : Type u) {L : Type v} (E : Type z) [Field K] [Field L] [Field E] [Algebra K L] [Algebra K E] [Module.Finite K L] [IsAlgClosed E] (pB : PowerBasis K L) [IsSeparable K L] (e : Fin pb.dim ≃ (L →ₐ[K] E)) : ⇑(Algebra_Map K E) (Algebra.discr K ⇑(pb.basis)) = finset.univ.prod (λ (i : Fin pb.dim), (Finset.filter (λ (j : Fin pb.dim), i < j) Finset.univ).prod (λ (j : Fin pb.dim), -((⇑(⇑e j) pb.gen - ⇑(⇑e i) pb.gen) * (⇑(⇑e i) pb.gen - ⇑(⇑e j) pb.gen))))
{S : Type u_2} [CommRing S] {K : Type u_6} [Field K] [Algebra K S] (pB : PowerBasis K S) : FiniteDimensional K S
{α : Type u} [AddCommGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] {a b c : α} : b < c - a → a + b < c
{M : Type u_1} [AddMonoid M] {s : Set M} {a : M} (h : a ∈ Add_monoid.closure s) : ∃ (l : List M), (∀ (x : M), x ∈ l → x ∈ s) ∧ l.sum = a
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] [Nontrivial α] {s : Set α} : Dense s ↔ ∀ (a b : α), a < b → (∃ (c : α) (H : c ∈ s), a < c ∧ c < b)
{𝕜 : Type u_1} {E : Type u} [LinearOrderedField 𝕜] [AddCommGroup E] [Module 𝕜 E] [DecidableEq E] {t : Finset E} (h : ¬AffineIndependent 𝕜 Coe) {x : E} (m : x ∈ ⇑(Convex_hull 𝕜) ↑t) : ∃ (y : ↥↑t), x ∈ ⇑(Convex_hull 𝕜) ↑(t.erase ↑y)
{α : Type u_1} [LinearOrderedField α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b ↔ b⁻¹ < a
{E : Type u_4} {F : Type u_5} [NormedGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E] [NormedGroup F] [NormedSpace ℝ F] {f : E → F} (h : ContDiff ℝ 1 f) : dimH (Set.Range f) ≤ ↑(FiniteDimensional.finrank ℝ E)
{p a b : ℕ} (hpa : p ∈ a.factors) (hb : b ≠ 0) : p ∈ (a * b).factors
{α : Type u_1} [Group α] [Fintype α] (s : Subgroup α) [Fintype ↥s] : Fintype.card ↥s ∣ Fintype.card α
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {X : Top} (F : Top.Presheaf C X) (U : TopologicalSpace.Opens ↥X) (R : CategoryTheory.Presieve U) : Category_theory.presheaf.first_Map R F ≫ (Top.presheaf.covering_of_presieve.second_obj_iso_Pi_inters F U R).hom = (Top.presheaf.covering_of_presieve.first_obj_iso_Pi_Opens F U R).hom ≫ Top.presheaf.sheaf_condition_Equalizer_products.left_res F (Top.presheaf.covering_of_Presieve U R)
{α : Type u} {ι : Type v} [MetricSpace α] [ProperSpace α] {c : ι → α} {r : ι → ℝ} (uf : ∀ (x : α), {i : ι | x ∈ Metric.Ball (c i) (r i)}.finite) (uU : (⋃ (i : ι), Metric.Ball (c i) (r i)) = Set.Univ) : ∃ (r' : ι → ℝ), (⋃ (i : ι), Metric.Ball (c i) (r' i)) = Set.Univ ∧ ∀ (i : ι), r' i < r i
{α : Type u_1} (r : α → α → Prop) [IsIrrefl α r] : {c : Cardinal | ∃ (S : Set α), Set.Unbounded r S ∧ Cardinal.mk ↥S = c}.nonempty
(R : Type u_2) {M : Type u_5} [Ring R] [AddCommGroup M] [Module R M] (n : ℤ) (b : M) : n • b = ↑n • b
{α : Type u_1} {γ : Type u_3} {ι : sort u_2} {p : ι → Prop} {s : ι → Set α} {f : Filter α} (hF : f.has_Basis p s) {β : ι → Type u_4} {pg : Π (i : ι), β i → Prop} {sg : Π (i : ι), β i → Set γ} {g : Set α → Filter γ} (hg : ∀ (i : ι), (g (s i)).has_Basis (pg i) (sg i)) (gm : Monotone g) {s_1 : Set γ} : s_1 ∈ f.lift g ↔ ∃ (i : ι) (hi : p i) (x : β i) (hx : pg i x), sg i x ⊆ s_1
(R : Type u) [Ring R] [StrongRankCondition R] {ι : Type u} : Module.rank R (ι →₀ R) = Cardinal.mk ι
{α : Type u_1} [CompleteLattice α] {k : α} (h : CompleteLattice.IsCompactElement k) : IsCoatomic ↥(Set.Iic k)
{α : Type u_1} [Fintype α] {𝒜 : Finset (Finset α)} {r : ℕ} : Set.Sized r ↑𝒜 → 𝒜 ⊆ finset.powerset_len r Finset.univ
{M : Type u_1} [HasMul M] {s : Set M} {p : M → M → Prop} {x y : M} (hx : x ∈ Subsemigroup.closure s) (hy : y ∈ Subsemigroup.closure s) (Hs : ∀ (x : M), x ∈ s → ∀ (y : M), y ∈ s → p x y) (hMul_Left : ∀ (x y z : M), p x z → p y z → p (x * y) z) (hMul_Right : ∀ (x y z : M), p z x → p z y → p z (x * y)) : p x y
(k : Type u_1) (V : Type u_2) (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V] [S : AddTorsor V P] : affine_Span k ∅ = ⊥
{ι : Type u_1} {ι' : Type u_2} {α : Type u_3} [Fintype ι] [Preorder ι'] [IsDirected ι' has_le.le] [Nonempty ι'] {s : ι → ι' → Set α} (hs : ∀ (i : ι), Antitone (s i)) : (⋂ (j : ι'), ⋃ (i : ι), s i j) = ⋃ (i : ι), ⋂ (j : ι'), s i j
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : Set P} (hs : EuclideanGeometry.Cospherical s) {p : Fin 3 → P} (hps : Set.Range p ⊆ s) (hpi : Function.Injective p) : AffineIndependent ℝ p
{R : Type u_1} [MulZeroClass R] : ¬IsLeftRegular 0 ↔ Nontrivial R
{α : Type u} [PseudoMetricSpace α] {s : Set α} (h : is_IsCompact s) : Metric.Bounded s
{α : Type} {d : ℕ} {ds : List ℕ} [Ring α] (x : Holor α (d :: ds)) : (Finset.range d).attach.sum (λ (i : {x // x ∈ Finset.range d}), (holor.unit_vec d ↑i).mul (x.slice ↑i _)) = x
{C : Type u} [CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : ℕ} {i : Fin (n + 1)} : X.δ i.succ ≫ X.σ i = 𝟙 (X.obj (SimplexCategory.mk n))
{C : Type u₁} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) : CategoryTheory.CoverPreserving J J (𝟭 C)
{α : Type u} [SemilatticeSup α] [Nonempty α] {s : Set α} (hs : s.finite) : BddAbove s
{R : Type u} [CommSemiring R] [NoZeroDivisors R] (t : Multiset (Polynomial R)) [Nontrivial R] : t.prod.degree = (Multiset.map (λ (f : Polynomial R), f.degree) t).sum
{C : Type u} [CategoryTheory.Category C] [∀ (X Y : C), Subsingleton (X ⟶ Y)] : CategoryTheory.EssentiallySmall C ↔ Small (CategoryTheory.Skeleton C)
{α : sort u_1} (P : Prop) [Decidable P] (x : ¬P → α) (y : ¬¬P → α) : dite (¬P) x y = dite P (λ (h : P), y _) x
{R : Type u} [Ring R] (s : Subring R) : Subring.closure ↑s = s
{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A] {s : Set A} {p : A → A → Prop} {a b : A} (ha : a ∈ Algebra.adjoin R s) (hb : b ∈ Algebra.adjoin R s) (Hs : ∀ (x : A), x ∈ s → ∀ (y : A), y ∈ s → p x y) (Halg : ∀ (r₁ r₂ : R), p (⇑(Algebra_Map R A) r₁) (⇑(Algebra_Map R A) r₂)) (Halg_Left : ∀ (r : R) (x : A), x ∈ s → p (⇑(Algebra_Map R A) r) x) (Halg_Right : ∀ (r : R) (x : A), x ∈ s → p x (⇑(Algebra_Map R A) r)) (hAdd_Left : ∀ (x₁ x₂ y : A), p x₁ y → p x₂ y → p (x₁ + x₂) y) (hAdd_Right : ∀ (x y₁ y₂ : A), p x y₁ → p x y₂ → p x (y₁ + y₂)) (hMul_Left : ∀ (x₁ x₂ y : A), p x₁ y → p x₂ y → p (x₁ * x₂) y) (hMul_Right : ∀ (x y₁ y₂ : A), p x y₁ → p x y₂ → p x (y₁ * y₂)) : p a b
{α : Type u} (f : Filter α) : (⨆ (g : Ultrafilter α) (hg : ↑g ≤ f), ↑g) = f
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} (h : InnerProductGeometry.angle x (x - y) = InnerProductGeometry.angle y (y - x)) (hpi : InnerProductGeometry.angle x y ≠ Real.pi) : ∥x∥ = ∥y∥
{R S : Type u} [CommRing R] [CommRing S] (M : Submonoid R) (R' : Type u) [CommRing R'] [Algebra R R'] [Algebra R' S] [Algebra R S] [IsScalarTower R R' S] [IsLocalization M R'] (s : Set S) (x : S) (hx : x ∈ Submodule.span R' s) : ∃ (t : ↥M), t • x ∈ Submodule.span R s
{C : Type u} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w} [CategoryTheory.Category D] [CategoryTheory.ConcreteCategory D] [CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)] [∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (J.cover X)ᵒᵖ D] [∀ (P : Cᵒᵖ ⥤ D) (X : C) (S : J.cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)] [Π (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (J.cover X)ᵒᵖ (CategoryTheory.forget D)] [CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget D)] (P : Cᵒᵖ ⥤ D) : CategoryTheory.Presheaf.IsSheaf J (J.plus_obj (J.plus_obj P))
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) : p.remove_zero.left_Inv i = p.left_Inv i
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Limits.HasProducts C] {X : Top} (F : Top.Presheaf C X) {ι : Type v} (U : ι → TopologicalSpace.Opens ↥X) (s : CategoryTheory.Limits.Fork (Top.presheaf.sheaf_condition_Equalizer_products.left_res F U) (Top.presheaf.sheaf_condition_Equalizer_products.right_res F U)) : s.ι ≫ Top.presheaf.presieve_of_covering.pi_Opens_to_FirstObj F U ≫ Top.presheaf.presieve_of_covering.first_obj_to_Pi_Opens F U = s.ι
{k : Type u₁} {G : Type u₂} {R : Type u_1} [Semiring k] [MulOneClass G] [Semiring R] {f g : MonoidAlgebra k G →+* R} (h₁ : ∀ (b : k), ⇑f (Finsupp.single 1 b) = ⇑g (Finsupp.single 1 b)) (h_of : ∀ (a : G), ⇑f (Finsupp.single a 1) = ⇑g (Finsupp.single a 1)) : f = g
{α : Type u_1} {ι : sort u_3} [ConditionallyCompleteLattice α] {f g : ι → α} (B : BddAbove (Set.Range g)) (H : ∀ (x : ι), f x ≤ g x) : supr f ≤ supr g
{M : Type u_1} [AddGroup M] (c : AddCon M) (n : ℤ) {w x : M} : ⇑c w x → ⇑c (n • w) (n • x)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_5} [NormedGroup E'] [NormedSpace 𝕜 E'] {n : WithTop ℕ} {f : E → E'} {s : Set E} : ContDiffOn 𝕜 n f s → ContMdiffOn (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f s
{α : Type u_6} {β : Type u_7} [HasMul β] [HasScalar α β] [SmulCommClass α β β] (s : α) (x y : β) : x * s • y = s • (x * y)
{α : Type u_1} [PartialOrder α] (c : ClosureOperator α) : _.closure_operator = c
(α : Type u_1) [CompleteLattice α] : WellFounded GT → CompleteLattice.IsSupClosedCompact α
{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] (h : 0 < FiniteDimensional.finrank K V) : Nontrivial V
{X : Type u_2} [EmetricSpace X] {s : Set X} (h : s.subsingleton) : dimH s = 0
{α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {a b : α} (hab : a < b) (s : Set α) : [s ∈ nhds_within a (Set.Ioi a), s ∈ nhds_within a (Set.Ioc a b), s ∈ nhds_within a (Set.Ioo a b), ∃ (u : α) (H : u ∈ Set.Ioc a b), Set.Ioo a u ⊆ s, ∃ (u : α) (H : u ∈ Set.Ioi a), Set.Ioo a u ⊆ s].tfae
{ι : Type w} [Fintype ι] (K : Type u) {L : Type v} [Field K] [Field L] [Algebra K L] [Module.Finite K L] [IsSeparable K L] (b : Basis ι K L) : IsUnit (Algebra.discr K ⇑b)
{E : Type u_2} [SemiNormedGroup E] [NormedSpace ℝ E] {r : ℝ} (hr : 0 < r) : r • Metric.Ball 0 1 = Metric.Ball 0 r
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι →₀ 𝕜) (i : ι) : HasInner.inner (v i) (⇑(Finsupp.total ι E 𝕜 v) l) = ⇑l i
{α : sort u_1} (P : Prop) [Decidable P] (a b : α) : Ite (¬P) a b = Ite P b a
{α : Type u_1} {r : α → α → Prop} {s : Set α} (h : IsChain r s) : IsChain (Flip r) s
{α : Type u} [PseudoEmetricSpace α] {s t : Set α} {r : Ennreal} (H1 : ∀ (x : α), x ∈ s → emetric.inf_edist x t ≤ r) (H2 : ∀ (x : α), x ∈ t → emetric.inf_edist x s ≤ r) : emetric.Hausdorff_edist s t ≤ r
{R : Type u_1} [Semiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {N' : Type u_5} [AddCommGroup N'] [Module R N'] {ι : Type u_6} [DecidableEq ι] {N'₂ : Type u_7} [AddCommGroup N'₂] [Module R N'₂] [Fintype ι] (g : N' →ₗ[R] N'₂) (f : MultilinearMap R (λ (_x : ι), M) N') : ⇑MultilinearMap.alternatization (g.comp_MultilinearMap f) = ⇑(g.comp_AlternatingMap) (⇑MultilinearMap.alternatization f)
{α : Type u_1} {β : Type u_2} [UniformSpace α] [MetricSpace β] {f : α → β} (h : UniformEmbedding f) : Isometry f
{α : Type u_1} {𝕜 : Type u_14} [NormedField 𝕜] {l : Filter α} {f g : α → 𝕜} (hgf : ∀ᶠ (x : α) in l, g x = 0 → f x = 0) : Filter.Tendsto (λ (x : α), f x / g x) l (nhds 0) → f =o[l] g
{α : Type u_2} [Fintype α] {𝒜 : Finset (Finset α)} (h𝒜 : IsAntichain HasSubset.Subset ↑𝒜) : 𝒜.card ≤ (Fintype.card α).choose (Fintype.card α / 2)
{α : Type u_2} [DecidableEq α] [Fintype α] {𝒜 : Finset (Finset α)} {r : ℕ} (h𝒜 : Set.Sized r ↑𝒜) : 𝒜.card * r ≤ 𝒜.shadow.card * (Fintype.card α - r + 1)
{a : Ennreal} : a - ⊤ = 0
(k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] {s : Set P} {p : P} {v : V} (hp : p ∈ SpanPoints k s) (hv : v ∈ Vector_Span k s) : v +ᵥ p ∈ SpanPoints k s
{α : Type u} [t : TopologicalSpace α] [TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α} {a : Set ι} (h : a.pairwise_Disjoint s) (ha : ∀ (i : ι), i ∈ a → (Interior (s i)).nonempty) : a.countable
{C : Type v} [CategoryTheory.Category C] [CategoryTheory.ConcreteCategory C] {X Y : C} (f : X ⟶ Y) (i : Function.Injective ⇑f) : CategoryTheory.Mono f
{k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P] : Function.Injective Coe
{R : Type u_1} {G : Type u_2} [CommRing R] [is_IsDomain R] [Group G] [Fintype G] (f : G →* R) (hF : Function.Injective ⇑f) : IsCyclic G
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {w : α → M} {b : M} [LinearOrderedCancelAddCommMonoid M] (hF : ∀ (a : α), a ∈ s → f a ∈ t) (ht : t.nonempty) (hb : s.sum (λ (x : α), w x) ≤ t.card • b) : ∃ (y : β) (H : y ∈ t), (Finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x) ≤ b
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (s : AffineSubspace ℝ P) [Nonempty ↥s] [CompleteSpace ↥(s.direction)] : Function.involutive ⇑(EuclideanGeometry.reflection s)
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : InnerProductGeometry.angle x y + InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x) = Real.pi
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) (fs : Finset (Fin (n + 1))) : Finset.centroid ℝ fs s.points = ⇑(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.centroid_weights_with_circumcenter fs)
{𝕜 : Type u_1} {α : Type u_2} [LinearOrderedField 𝕜] {𝒜 : Finset (Finset α)} [Fintype α] (h𝒜 : IsAntichain HasSubset.Subset ↑𝒜) : (Finset.range (Fintype.card α + 1)).sum (λ (r : ℕ), ↑((𝒜.slice r).card) / ↑((Fintype.card α).choose r)) ≤ 1
{α : Type u_1} {l : List α} {x : α} : List.Duplicate x l ↔ ∃ (n : ℕ) (hn : n < l.length) (m : ℕ) (hm : m < l.length) (h : n < m), x = l.nth_LE n hn ∧ x = l.nth_LE m hm
{α : Type u} [Group α] [HasLt α] [CovariantClass α α has_mul.mul has_lt.lt] {a b c : α} : b⁻¹ * a < c → a < b * c
{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} [IsTrichotomous α r] [IsIrrefl β s] (f : r →r s) : Function.Injective ⇑f
{C : Type u₁} [CategoryTheory.Category C] {D : Type u₂} [CategoryTheory.Category D] {J : Type u} [CategoryTheory.Category J] (E : C ⥤ D) [CategoryTheory.IsEquivalence E] [CategoryTheory.Limits.HasColimitsOfShape J D] : CategoryTheory.Limits.HasColimitsOfShape J C
{K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [DivisionRing K] {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K} (Succ_nth_s_Eq : g.s.nth (n + 1) = Option.some gp) (nth_Num_Eq : g.numerators n = ppredA) (Succ_nth_Num_Eq : g.numerators (n + 1) = predA) : g.numerators (n + 2) = gp.b * predA + gp.a * ppredA
{K : Type u} [Field K] (s : Subfield K) (m : Multiset K) : (∀ (a : K), a ∈ m → a ∈ s) → m.sum ∈ s
{α : Type u_1} {F : Type u_4} {E' : Type u_6} [HasNorm F] [SemiNormedGroup E'] {g : α → F} {f' : α → E'} {l : Filter α} : f' =O[l] g → (λ (x : α), ∥f' x∥) =O[l] g
{α : Type u_2} [AddGroup α] {s t : Set α} : Disjoint s t → 0 ∉ s - t
{V₁ : Type u_2} {V₂ : Type u_3} [SemiNormedGroup V₁] [SemiNormedGroup V₂] (f : V₁ →+ V₂) {C : ℝ} (h : ∀ (x : V₁), ∥⇑f x∥ ≤ C * ∥x∥) : ∥f.mk_NormedGroupHom C h∥ ≤ Linear_order.max C 0
{α : Type u_1} [SemiNormedGroup α] {r C : ℝ} {f : ℕ → α} (hr : r < 1) (hF : ∀ (n : ℕ), ∥f n∥ ≤ C * r ^ n) : CauchySeq (λ (s : Finset ℕ), s.sum (λ (x : ℕ), f x))
{F : Type u_3} [InnerProductSpace ℝ F] {x y : F} : ∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * HasInner.inner x y + ∥y∥ ^ 2
(f : ℝ → ℝ) {a b : ℝ} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hfd : DifferentiableOn ℝ f (Set.Ioo a b)) : ∃ (c : ℝ) (H : c ∈ Set.Ioo a b), deriv f c = (f b - f a) / (b - a)
{α : Type u_1} [ConditionallyCompleteLattice α] {s : Set α} {a b : α} : BddBelow s → a ∈ s → a < b → HasInf.inf s < b
{C : Type u} [CategoryTheory.Category C] {D : Type u} [CategoryTheory.Category D] (F : C ⥤ D) {X Y Z : C} {f : X ⟶ Y} {g : Y ⟶ Z} [CategoryTheory.Abelian C] [CategoryTheory.Abelian D] [F.additive] [CategoryTheory.Limits.PreservesFiniteLimits F] [CategoryTheory.Mono f] (ex : CategoryTheory.Exact f g) : CategoryTheory.Exact (F.map f) (F.map g)
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} {ps : Set P} (h : ps ⊆ ↑s) [Nonempty ↥s] [CompleteSpace ↥(s.direction)] : EuclideanGeometry.Cospherical ps ↔ ∃ (Center : P) (H : Center ∈ s) (radius : ℝ), ∀ (p : P), p ∈ ps → HasDist.dist p Center = radius
{α : Type u} {a b : α} [MulOneClass α] [HasZero α] [Preorder α] [ZeroLt.MulPosStrictMono α] (ha : a < 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b < 1
{α : Type u_1} [PartialOrder α] (c : ClosureOperator α) : c = ClosureOperator.mk₃ ⇑c c.closed _ _ _
{α : Type u_1} {β : Type u_2} (t : α) (ts : List α) (r : List β) (ys : List α) (f : List α → β) : (list.permutations_aux2 t ts List.nil ys f).snd ++ r = (list.permutations_aux2 t ts r ys f).snd
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} [Nonempty ↥s] [CompleteSpace ↥(s.direction)] {p₁ : P} (p₂ : P) (r : ℝ) (hp₁ : p₁ ∈ s) : ⇑(EuclideanGeometry.reflection s) (r • (p₂ -ᵥ ↑(⇑(euclidean_geometry.orthogonal_projection s) p₂)) +ᵥ p₁) = -(r • (p₂ -ᵥ ↑(⇑(euclidean_geometry.orthogonal_projection s) p₂))) +ᵥ p₁
{E : Type u_1} [NormedGroup E] [NormedSpace ℂ E] [CompleteSpace E] {f : ℂ → E} {c : ℂ} {R : ℝ} {w : ℂ} (hF : CircleIntegrable f c R) (hw : Complex.abs w < R) : (Cauchy_PowerSeries f c R).sum w = (2 * ↑Real.pi * Complex.i)⁻¹ • ∮ (z : ℂ) in C(c, R), (z - (c + w))⁻¹ • f z
{R : Type u_1} {S : Type u_2} {M : Type u_3} {ι : Type u_4} [CommSemiring R] [Semiring S] [AddCommMonoid M] [Algebra R S] [Module R M] [Module S M] [IsScalarTower R S M] (hinj : Function.Injective ⇑(Algebra_Map R S)) {v : ι → M} (li : LinearIndependent S v) : LinearIndependent R v
{𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [AddCommGroup F] [Module 𝕜 F] [c : InnerProductSpace.Core 𝕜 F] (x y : F) : is_R_or_C.abs (HasInner.inner x y) ≤ ∥x∥ * ∥y∥
{n : ℕ} [Fact (0 < n)] (i : Zmod n) : order_of (DihedralGroup.r i) = n / n.gcd i.val
{α : Type u_2} {G₀ : Type u_6} [GroupWithZero G₀] [MulAction G₀ α] [TopologicalSpace α] [HasContinuousConstSmul G₀ α] {c : G₀} {s : Set α} {x : α} (hs : s ∈ nhds x) (hc : c ≠ 0) : c • s ∈ nhds (c • x)
{M : Type u_1} [Monoid M] {N : Type u_2} [Monoid N] {f : M → N} (hF : IsMonoidHom f) {s : Set N} (hs : IsSubmonoid s) : IsSubmonoid (f ⁻¹' s)
(f f' : ℝ → ℝ) {a b : ℝ} (hab : a < b) (hfc : ContinuousOn f (Set.Icc a b)) (hff' : ∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivAt f (f' x) x) (g g' : ℝ → ℝ) (hgc : ContinuousOn g (Set.Icc a b)) (hgg' : ∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivAt g (g' x) x) : ∃ (c : ℝ) (H : c ∈ Set.Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {ι : Type u_3} {s : Finset ι} {w₁ w₂ : ι → ℝ} (p : ι → P) (h₁ : s.sum (λ (i : ι), w₁ i) = 1) (h₂ : s.sum (λ (i : ι), w₂ i) = 1) : HasDist.dist (⇑(s.affine_combination p) w₁) (⇑(s.affine_combination p) w₂) * HasDist.dist (⇑(s.affine_combination p) w₁) (⇑(s.affine_combination p) w₂) = -s.sum (λ (i₁ : ι), s.sum (λ (i₂ : ι), (w₁ - w₂) i₁ * (w₁ - w₂) i₂ * (HasDist.dist (p i₁) (p i₂) * HasDist.dist (p i₁) (p i₂)))) / 2
{α : Type u_1} [LinearOrderedField α] {a b c d : α} (hc : c ≠ 0) (hD : d ≠ 0) : (a * d - b * c) / (c * d) < 0 → a / c < b / d
{K : Type u_1} {n : ℕ} {g : GeneralizedContinuedFraction K} [LinearOrderedField K] (s_Pos : ∀ {gp : GeneralizedContinuedFraction.Pair K} {m : ℕ}, m < n → g.s.nth m = Option.some gp → 0 < gp.a ∧ 0 < gp.b) : g.convergents n = g.convergents' n
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasBinaryCoproducts C] : CategoryTheory.Limits.HasBinaryBiproducts C
{α : Type u} {ι : sort x} {f : ι → α} : Function.Surjective f → Set.Range f = Set.Univ
{M : Type u_1} [HasMul M] {s : Set M} {p : M → Prop} {x : M} (h : x ∈ Subsemigroup.closure s) (Hs : ∀ (x : M), x ∈ s → p x) (hMul : ∀ (x y : M), p x → p y → p (x * y)) : p x
(p : ℕ) [p_Prime : Fact (Nat.Prime p)] {q r : ℚ} (hqr : q + r ≠ 0) : Linear_order.min (padic_val_rat p q) (padic_val_rat p r) ≤ padic_val_rat p (q + r)
{R : Type u_1} [LinearOrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {ι : Type u_3} [DecidableEq ι] [Fintype ι] [Nontrivial R] [Nonempty ι] (e : Basis ι R M) (x : Orientation R M ι) : (e.adjust_to_Orientation x).orientation = x
{R : Type u_1} [CommRing R] [Fintype R] (p : ℕ) [Fact (Nat.Prime p)] : p ∣ Ring_Char R ↔ p ∣ Fintype.card R
{α : Type u} [TopologicalSpace α] [LocallyCompactSpace α] {x : α} {U : Set α} (hU : is_IsOpen U) (hx : x ∈ U) : ∃ (K : Set α), is_IsCompact K ∧ x ∈ Interior K ∧ K ⊆ U
{C : Type u} [CategoryTheory.Category C] {D : Type u'} [CategoryTheory.Category D] [CategoryTheory.Limits.HasFiniteProducts C] [CategoryTheory.Limits.HasFiniteProducts D] (F : C ⥤ D) {L : D ⥤ C} [CategoryTheory.CartesianClosed C] [CategoryTheory.CartesianClosed D] [CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F] (h : L ⊣ F) (A : C) [i : CategoryTheory.IsIso (Category_theory.frobenius_morphism F h A)] : CategoryTheory.IsIso (CategoryTheory.exp_comparison F A)
{α : Type u_1} {β : Type u_2} {Op : β → β → β} [hc : IsCommutative β Op] [ha : IsAssociative β Op] {f : α → β} {b : β} {s : Finset α} [IsIdempotent β Op] {g : α → β} (p : α → Prop) [DecidablePred p] : Finset.fold Op b (λ (i : α), Ite (p i) (f i) (g i)) s = Op (Finset.fold Op b f (Finset.filter p s)) (Finset.fold Op b g (Finset.filter (λ (i : α), ¬p i) s))
(R : Type u) [CommSemiring R] {S : Type v} [Semiring S] [Algebra R S] (p : Polynomial S) : p ∈ Polynomial.lifts (Algebra_Map R S) ↔ p ∈ (Polynomial.map_alg R S).range
{R : Type u_1} [OrderedCommRing R] {M : Type u_2} [AddCommGroup M] [Module R M] {x y : M} : SameRay R x y → SameRay R (-x) (-y)
{α : Type u_1} {E : Type u_3} {F : Type u_4} [HasNorm E] [HasNorm F] {f : α → E} {g : α → F} {l : Filter α} : (∀ ⦃c : ℝ⦄, 0 < c → (∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥)) → f =o[l] g
{R : Type u_2} [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R] {a b c : R} (ha : a ≠ 0) : (∀ {d : R}, d ∣ a → d ∣ c → ¬Prime d) → a ∣ b * c → a ∣ b
(𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] {ι : Type u_3} [LinearOrder ι] [OrderBot ι] [LocallyFiniteOrder ι] [IsWellOrder ι has_lt.lt] [SuccOrder ι] [IsSuccArchimedean ι] (f : ι → E) (n : ι) (h₀ : LinearIndependent 𝕜 f) : gram_schmidt 𝕜 f n ≠ 0
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (h : b.orientation = o) (x y : V) : o.oangle x y = hb.oangle x y
{𝕜 : Type u} [NondiscreteNormedField 𝕜] {f g : 𝕜 → 𝕜} {f' a : 𝕜} (hg : ContinuousAt g a) (hF : HasDerivAt f f' (g a)) (hF' : f' ≠ 0) (hfg : ∀ᶠ (y : 𝕜) in nhds a, f (g y) = y) : HasDerivAt g f'⁻¹ a
{R : Type u_1} {S : Type u_2} [CommRing R] [CommRing S] [Algebra R S] {ι : Type w} [Fintype ι] (b : Basis ι R S) (x : R) : ⇑(Algebra.norm R) (⇑(Algebra_Map R S) x) = x ^ Fintype.card ι
{R₁ : Type u_1} {R₂ : Type u_2} {R₃ : Type u_3} [Semiring R₁] [Semiring R₂] [Semiring R₃] {σ₁₂ : R₁ →+* R₂} {σ₂₃ : R₂ →+* R₃} {σ₁₃ : R₁ →+* R₃} [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] [RingHomSurjective σ₁₂] [RingHomSurjective σ₂₃] : RingHomSurjective σ₁₃
{G₀ : Type u_2} [GroupWithZero G₀] (a : G₀) : a⁻¹ * a * a = a
{α : Type u} [AddGroup α] [HasLe α] [CovariantClass α α has_add.add has_le.le] {a : α} : 0 ≤ -a ↔ a ≤ 0
{α : Type u_1} {M : Type u_5} {N : Type u_6} [AddCommMonoid M] [AddCommMonoid N] {s : Set α} (f : α → M) (g : M →+ N) (hs : s.finite) : ⇑g (finsum (λ (j : α), finsum (λ (H : j ∈ s), f j))) = finsum (λ (i : α), finsum (λ (H : i ∈ s), ⇑g (f i)))
{α : Type u_1} {β : Type u_2} [has_Add α] [AddCommGroup β] {f : α → β} (hF : IsAddHom f) : IsAddHom (λ (a : α), -f a)
{α : Type u_1} {β : Type u_2} {M : Type u_5} [CommMonoid M] (s : Finset (α × β)) (f : α × β → M) : finprod (λ (Ab : α × β), finprod (λ (h : Ab ∈ s), f Ab)) = finprod (λ (a : α), finprod (λ (b : β), finprod (λ (h : (a, b) ∈ s), f (a, b))))
{R : Type u_1} {M : Type u_2} [CommSemiring R] [AddCommMonoid M] [Module R M] (a : R) : Module.IsTorsionBy R ↥(Submodule.torsion_by R M a) a
{α : Type u} (l : List α) (n k : ℕ) (hk : k < l.length) : (l.rotate n).nth_LE ((l.length - n % l.length + k) % l.length) _ = l.nth_LE k hk
{α : Type u} [PseudoMetricSpace α] {s t : Set α} {x : α} (h : s ⊆ t) (hs : s.nonempty) : metric.inf_dist x t ≤ metric.inf_dist x s
{G : Type u_1} [CommGroup G] (K : Subgroup G) {ι : Type u_2} {t : Finset ι} {f : ι → G} (h : ∀ (c : ι), c ∈ t → f c ∈ K) : t.prod (λ (c : ι), f c) ∈ K
{M : Type u_1} [HasMul M] (c : Con M) {x y z : M} : ⇑c x y → ⇑c y z → ⇑c x z
(n : ℕ) : (Finset.Nat.antidiagonal n).card = n + 1
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder α] [OrderClosedTopology α] [Nonempty α] [TopologicalSpace β] [has_One α] {f : β → α} (hF : Continuous f) (h : HasCompactMulSupport f) : BddAbove (Set.Range f)
{α : Type u} {β : Type v} [PseudoEmetricSpace α] [PseudoEmetricSpace β] {K : Nnreal} {f : α → β} (hF : LipschitzWith K f) : Continuous f
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {E' : Type u_3} [NormedGroup E'] [NormedSpace 𝕜 E'] {f : E → E'} {x : E} {f' : TangentSpace (model_with_corners_self 𝕜 E) x →L[𝕜] TangentSpace (model_with_corners_self 𝕜 E') (f x)} : HasFderivAt f f' x → HasMfderivAt (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') f x f'
{α : Type u_1} [PartialOrder α] [PredOrder α] {a b : α} [NoMinOrder α] : a ≠ b → Order.pred a ≠ Order.pred b
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {n : WithTop ℕ} [CompleteSpace 𝕜] (f : LocalHomeomorph 𝕜 𝕜) {f₀' a : 𝕜} (h₀ : f₀' ≠ 0) (ha : a ∈ f.to_local_equiv.target) (hF₀' : HasDerivAt ⇑f f₀' (⇑(f.symm) a)) (hF : ContDiffAt 𝕜 n ⇑f (⇑(f.symm) a)) : ContDiffAt 𝕜 n ⇑(f.symm) a
{R : Type u_1} [NormedRing R] [CompleteSpace R] (x : Rˣ) (n : ℕ) : (λ (t : R), Ring.inverse (↑x + t) - (Finset.range n).sum (λ (i : ℕ), (-↑x⁻¹ * t) ^ i) * ↑x⁻¹) =O[nhds 0] λ (t : R), ∥t∥ ^ n
{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) (h : IsComplete ↑K) (u : E) : ∃ (v : E) (H : v ∈ K), ∥u - v∥ = ⨅ (w : ↥↑K), ∥u - ↑w∥
{α : Type u_1} {P : Set α → Prop} {m : Π (s : Set α), P s → Ennreal} {P0 : P ∅} {m0 : m ∅ P0 = 0} (PU : ∀ ⦃f : ℕ → Set α⦄, (∀ (i : ℕ), P (f i)) → P (⋃ (i : ℕ), f i)) (msU : ∀ ⦃f : ℕ → Set α⦄ (hm : ∀ (i : ℕ), P (f i)), m (⋃ (i : ℕ), f i) _ ≤ ∑' (i : ℕ), m (f i) _) (m_Mono : ∀ ⦃s₁ s₂ : Set α⦄ (hs₁ : P s₁) (hs₂ : P s₂), s₁ ⊆ s₂ → m s₁ hs₁ ≤ m s₂ hs₂) (s : Set α) : MeasurableSet s ↔ ∀ (t : Set α), P t → ⇑(measure_theory.induced_OuterMeasure m P0 m0) (t ∩ s) + ⇑(measure_theory.induced_OuterMeasure m P0 m0) (t  s) ≤ ⇑(measure_theory.induced_OuterMeasure m P0 m0) t
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x : V) : hb.oangle x x = 0
{α : Type u} (r s : α → α → Prop) [IsNonstrictStrictOrder α r s] {a b : α} : s a b ↔ r a b ∧ ¬r b a
{α : Type u} [TopologicalSpace α] {s t : Set α} (hs : IsPreconnected s) (ht : is_IsClopen t) (hne : (s ∩ t).nonempty) : s ⊆ t
{α : Type u} [AddCommGroup α] [HasLt α] [CovariantClass α α has_add.add has_lt.lt] {a b c : α} : a + b < c → b < c - a
{β : Type u} {α : Type v} {γ : Type w} [CommSemiring β] [CommSemiring γ] (g : β →+* γ) (f : α → β) (s : Finset α) : ⇑g (s.prod (λ (x : α), f x)) = s.prod (λ (x : α), ⇑g (f x))
{α : Type u} [AddMonoid α] (f : ℕ → α) (n : ℕ) : (List.map f (List.range n.succ)).sum = f 0 + (List.map (λ (i : ℕ), f i.succ) (List.range n)).sum
{α : Type u_1} {β : Type u_3} [MeasurableSpace α] [MeasurableSpace β] {ν : MeasureTheory.Measure β} [MeasureTheory.SigmaFinite ν] {f : α → β → Ennreal} (hF : Measurable (Function.uncurry f)) : Measurable (λ (x : α), ∫⁻ (y : β), f x y ∂ν)
(K : Type u) {L : Type v} (E : Type z) [Field K] [Field L] [Field E] [Algebra K L] [Algebra K E] [Module.Finite K L] [IsAlgClosed E] (pB : PowerBasis K L) [IsSeparable K L] (e : Fin pb.dim ≃ (L →ₐ[K] E)) : ⇑(Algebra_Map K E) (Algebra.discr K ⇑(pb.basis)) = (-1) ^ (FiniteDimensional.finrank K L * (FiniteDimensional.finrank K L - 1) / 2) * finset.univ.prod (λ (i : Fin pb.dim), (Finset.filter (λ (j : Fin pb.dim), i < j) Finset.univ).prod (λ (j : Fin pb.dim), (⇑(⇑e j) pb.gen - ⇑(⇑e i) pb.gen) * (⇑(⇑e i) pb.gen - ⇑(⇑e j) pb.gen)))
{R : Type u₁} [OrderedSemiring R] {a : R} (Hsq : 0 ≤ a * a) (Hsq' : 0 ≤ (1 + a) * (1 + a)) (H : 0 ≤ 2 + a) (n : ℕ) : 1 + ↑n * a ≤ (1 + a) ^ n
(M : Type u_1) (α : Type u_2) [Group M] [MulAction M α] {ι : sort u_3} {P : ι → Subgroup M} : MulAction.FixedPoints ↥(supr P) α = ⋂ (i : ι), MulAction.FixedPoints ↥(P i) α
{R : Type u} [Ring R] (s : Subring R) {x y : R} : x ∈ s → y ∈ s → x + y ∈ s
 : ⇑MeasureTheory.MeasureSpace.volume (⋃ (p : ℝ) (hp : 2 < p), {x : ℝ | LiouvilleWith p x}) = 0
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) : Real.cos (InnerProductGeometry.angle x y + InnerProductGeometry.angle x (x - y) + InnerProductGeometry.angle y (y - x)) = -1
{C : Type u₁} [CategoryTheory.Category C] {A : Type u₂} [CategoryTheory.Category A] (J : CategoryTheory.GrothendieckTopology C) (P : Cᵒᵖ ⥤ A) : CategoryTheory.Presheaf.IsSheaf J P ↔ ∀ ⦃X : C⦄ (S : CategoryTheory.Sieve X), S ∈ ⇑J X → Nonempty (CategoryTheory.Limits.IsLimit (P.map_cone S.arrows.cocone.op))
{α : Type u} [AddGroup α] [HasLe α] [CovariantClass α α has_add.add has_le.le] [CovariantClass α α (Function.swap has_add.add) has_le.le] {a b : α} : -a ≤ b → -b ≤ a
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {f : E → F} (K : Set (E →L[𝕜] F)) : {x : E | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K} ⊆ FderivMeasurableAux.D f K
{C : Type u} [CategoryTheory.Category C] [CategoryTheory.Preadditive C] [CategoryTheory.Limits.HasBinaryBiproducts C] (X : C) [CategoryTheory.Simple X] : CategoryTheory.Indecomposable X
{V : Type u_1} [InnerProductSpace ℝ V] {x y : V} (h : InnerProductGeometry.angle x y = Real.pi) : HasInner.inner x y = -(∥x∥ * ∥y∥)
(x : Pgame) : (1 * x).equiv x
{M : Type u_1} {P : Type u_3} [MulOneClass M] [MulOneClass P] {c : Con M} (f : c.quotient →* P) : c.lift (f.comp c.mk') _ = f
{α : Type u_1} {r₁ r₂ : Setoid α} : r₁ = r₂ ↔ r₁.rel = r₂.rel
{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [OrderedSemiring 𝕜] [AddCommGroup E] [Module 𝕜 E] {p : ι → E} (hc : ConvexIndependent 𝕜 p) : ConvexIndependent 𝕜 (λ (x : ↥(Set.Range p)), ↑x)
{R : Type u_1} [AddRightCancelSemigroup R] (g : R) : IsAddRightRegular g
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) : o.oangle x (-y) + o.oangle y (-x) = 0
{α : Type u_1} {E : α → Type u_2} {p : Ennreal} [Π (i : α), NormedGroup (E i)] [Fact (1 ≤ p)] : UniformContinuous Coe
{α : Type u} {β : Type v} {M : Type w} [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {w : α → M} {b : M} [LinearOrderedCancelAddCommMonoid M] (hF : ∀ (y : β), y ∉ t → 0 ≤ (Finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x)) (ht : t.nonempty) (hb : s.sum (λ (x : α), w x) ≤ t.card • b) : ∃ (y : β) (H : y ∈ t), (Finset.filter (λ (x : α), f x = y) s).sum (λ (x : α), w x) ≤ b
{α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrder α] [OrderClosedTopology α] [Nonempty α] [TopologicalSpace β] [HasZero α] {f : β → α} (hF : Continuous f) (h : HasCompactSupport f) : BddBelow (Set.Range f)
{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {s : Set E} {f : E → F} {x : E} {n : WithTop ℕ} {p : E → FormalMultilinearSeries 𝕜 E F} (h : HasFtaylorSeriesUpToOn n f p s) {m : ℕ} (hmn : ↑m ≤ n) (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) : p x m = iterated_fderiv_within 𝕜 m f s x
{α : Type u_1} [LinearOrderedField α] {a b c : α} (hb : 0 ≤ b) (hc : 0 ≤ c) (h : a ≤ c * b) : a / b ≤ c
{τ : Type u_1} [AddMonoid τ] [TopologicalSpace τ] [HasContinuousAdd τ] {α : Type u_2} [TopologicalSpace α] (ϕ : Flow τ α) {β : Type u_3} [TopologicalSpace β] {t : β → τ} (ht : Continuous t) {f : β → α} (hF : Continuous f) : Continuous (λ (x : β), ⇑ϕ (t x) (f x))
{α : Type u} {β : Type v} [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} {n : ℕ} (hF : ∀ (a : α), a ∈ s → f a ∈ t) (ht : t.nonempty) (hn : t.card * n ≤ s.card) : ∃ (y : β) (H : y ∈ t), n ≤ (Finset.filter (λ (x : α), f x = y) s).card
{R : Type u_2} {M : Type u_3} {N : Type u_4} [CommSemiring R] [AddCommMonoid M] [AddCommMonoid N] [Module R M] [Module R N] {m : Type u_1} {n : Type u_5} [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n] (bM : Basis m R M) (bN : Basis n R N) (j : m) (i : n) : ⇑(Linear_map.to_Matrix bM bN) (⇑(dual_tensor_hom R M N) (bM.coord j ⊗ₜ[R] ⇑bN i)) = matrix.std_Basis_Matrix i j 1
(n : ℕ) (θ : ℂ) : Complex.sin ((↑n + 1) * θ) = Polynomial.eval (Complex.cos θ) (Polynomial.Chebyshev.u ℂ n) * Complex.sin θ
{α : Type u} [TopologicalSpace α] [t2_Space α] [CompactSpace α] (x : α) : ConnectedComponent x = ⋂ (Z : {Z // is_IsClopen Z ∧ x ∈ Z}), ↑Z
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {ι : Type u_4} [Invertible 2] (p : ι → P) (i₁ i₂ : ι) : Finset.centroid k {i₁, i₂} p = 2⁻¹ • (p i₂ -ᵥ p i₁) +ᵥ p i₁
{G : Type u_1} [AddGroup G] (K : AddSubgroup G) {k : Set G} : AddSubgroup.closure k ≤ K ↔ k ⊆ ↑K
{R : Type u_1} {M : Type u_5} {n : Type u_14} [CommRing R] [AddCommGroup M] [Module R M] [NoZeroDivisors R] {B : M →ₗ[R] M →ₗ[R] R} (v : Basis n R M) (hO : B.is_Ortho ⇑v) (h : ∀ (i : n), ¬B.is_IsOrtho (⇑v i) (⇑v i)) : B.nondegenerate
{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) (x y : V) {r : ℝ} (hr : r < 0) : hb.oangle x (r • y) = hb.oangle x (-y)
{R : Type u1} [CommSemiring R] {M : Type u2} [AddCommMonoid M] [Module R M] {A : Type u_1} [Semiring A] [Algebra R A] {f g : ExteriorAlgebra R M →ₐ[R] A} (h : f.to_Linear_map.comp (ExteriorAlgebraι R) = g.to_Linear_map.comp (ExteriorAlgebraι R)) : f = g
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {s : AffineSubspace ℝ P} {p1 p2 : P} (hp1 : p1 ∈ s) (hp2 : p2 ∈ s) (r1 r2 : ℝ) {v : V} (hv : v ∈ (s.direction)ᗮ) : HasDist.dist (r1 • v +ᵥ p1) (r2 • v +ᵥ p2) * HasDist.dist (r1 • v +ᵥ p1) (r2 • v +ᵥ p2) = HasDist.dist p1 p2 * HasDist.dist p1 p2 + (r1 - r2) * (r1 - r2) * (∥v∥ * ∥v∥)
{γ : Type u_3} [tγ : TopologicalSpace γ] [PolishSpace γ] [MeasurableSpace γ] [BorelSpace γ] {β : Type u_4} [tβ : TopologicalSpace β] [t2_Space β] [MeasurableSpace β] [BorelSpace β] {f : γ → β} [TopologicalSpace.SecondCountableTopology β] (f_Meas : Measurable f) (f_inj : Function.Injective f) : MeasurableEmbedding f
 : Cardinal.mk ↥Set.Univ = Cardinal.continuum
{R : Type x} [HasMul R] [has_Add R] [LeftDistribClass R] (a b c : R) : a * (b + c) = a * b + a * c
{α : Type u_1} [LinearOrderedField α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n
{V : Type u_1} [InnerProductSpace ℝ V] [hD2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) {r : ℝ} (hr : 0 ≤ r) : o.oangle (r • x) x = 0
{α : Type u_1} {β : Type u_2} [LinearOrder α] [PredOrder α] [Preorder β] {f : α → β} (hF : Monotone f) : Pairwise (Disjoint on λ (n : α), Set.Ioc (f (Order.pred n)) (f n))
{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P (n + 2)) {i₁ i₂ : Fin (n + 3)} : (s.monge_plane i₁ i₂).direction = (Submodule.span ℝ {s.points i₁ -ᵥ s.points i₂})ᗮ ⊓ Vector_Span ℝ (Set.Range s.points)
{M : Type u_1} {P : Type u_3} [AddZeroClass M] [AddZeroClass P] (f : M →+ P) : Function.Injective ⇑(AddCon.ker_Lift f)
{α : Type u} [TopologicalSpace α] {s : Set α} : s.nonempty → (Closure s).nonempty
{α : Type u_1} {β : Type u_2} {M : Type u_5} [CommMonoid M] [DecidableEq α] [DecidableEq β] (s : Finset (α × β)) (f : α × β → M) : finprod (λ (Ab : α × β), finprod (λ (h : Ab ∈ s), f Ab)) = finprod (λ (a : α), finprod (λ (b : β), finprod (λ (h : b ∈ Finset.image Prod.snd (Finset.filter (λ (Ab : α × β), ab.fst = a) s)), f (a, b))))
{X : Type u_1} {Y : Type u_2} [TopologicalSpace X] {f : X → Y} (hF : IsLocallyConstant f) {s : Set X} (hs : IsPreconnected s) {x y : X} (hx : x ∈ s) (hy : y ∈ s) : f x = f y
{ι : Type u_1} {R : Type u_8} [CanonicallyOrderedCommSemiring R] {f g h : ι → R} {s : Finset ι} {i : ι} (hi : i ∈ s) (h2i : g i + h i ≤ f i) (hgf : ∀ (j : ι), j ∈ s → j ≠ i → g j ≤ f j) (hhf : ∀ (j : ι), j ∈ s → j ≠ i → h j ≤ f j) : s.prod (λ (i : ι), g i) + s.prod (λ (i : ι), h i) ≤ s.prod (λ (i : ι), f i)
{R : Type u_1} [OrderedCommSemiring R] {M : Type u_2} [AddCommMonoid M] [Module R M] {N : Type u_3} [AddCommMonoid N] [Module R N] {x y : M} (f : M →ₗ[R] N) (h : SameRay R x y) : SameRay R (⇑f x) (⇑f y)
(k : Type u_1) {V : Type u_2} {P : Type u_3} [DivisionRing k] [AddCommGroup V] [Module k V] [AddTorsor V P] {p₁ p₂ : P} (h : p₁ ≠ p₂) : AffineIndependent k ![p₁, p₂]
{α : Type u_1} [Preorder α] [LocallyFiniteOrder α] {a b : α} : ¬a < b → Finset.ico a b = ∅
{M : Type u_1} [Monoid M] (a : M) (u : Mˣ) : IsUnit (a * ↑u) ↔ IsUnit a
{α : Type u} {β : Type v} [DecidableEq α] [CommMonoid β] {s : Finset α} {x : α} (h : x ∉ s) (f : Finset α → β) : (HasInsert.insert x s).powerset.prod (λ (a : Finset α), f a) = s.powerset.prod (λ (a : Finset α), f a) * s.powerset.prod (λ (t : Finset α), f (HasInsert.insert x t))
{α : Type u} [TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α) (hZd : Directed Superset Z) (hZn : ∀ (i : ι), (Z i).nonempty) (hZc : ∀ (i : ι), is_IsCompact (Z i)) (hZcl : ∀ (i : ι), is_IsClosed (Z i)) : (⋂ (i : ι), Z i).nonempty
{ι : Type u₁} {k : Type u₂} {V : Type u₃} {P : Type u₄} [AddCommGroup V] [AddTorsor V P] [CommRing k] [Module k V] [DecidableEq ι] [Fintype ι] (b b₂ : AffineBasis ι k P) (x : P) : (b.to_Matrix b₂.points).det • ⇑(b₂.coords) x = ⇑((b.to_Matrix b₂.points).transpose.cramer) (⇑(b.coords) x)
{M : Type u_1} [SemiNormedGroup M] (S : AddSubgroup M) (m : M) : ∥↑m∥ ≤ ∥m∥
