{"total-prompts": 33,
 "temperature": 0.5,
 "query-number": 12,
 "number-similar-sentences": 12,
 "number-keyword-sentences": 5,
 "include-fixed": false,
 "failures":
 ["Every set of Borel measure zero is Lebesgue measurable.",
  "For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.",
  "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero."],
 "elaborated-prompts":
 [{"theorem": "∀ (p : ℕ) [hp : Fact (Nat.Prime p)], p = 2 ∨ p % 2 = 1",
   "prompt": "Every prime number is `2` or odd.",
   "all-elabs":
   [" (  p :  ℕ ) ->  [ hp :  Fact   (   Nat.Prime  p  ) ] ->   p =  2 ∨   p %  2 =  1",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->   p =  2 ∨   p %  2 =  1",
    " (  p :  ℕ ) ->   Nat.Prime  p →   p =  2 ∨   p %  2 =  1",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->   p =  2 ∨   p %  2 =  1",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->   p =  2 ∨  (     p %  2 =  1 ∧  p ≠  2  )"]},
  {"theorem": "∀ (n : ℕ), ∃ m, m % 2 = 1 ∧ n < m",
   "prompt": "There are infinitely many odd natural numbers.",
   "all-elabs":
   [" ∀   (  n  :  ℕ  )  ,  ∃    (   m :  ℕ ) ,    m %  2 =  1 ∧  n < m",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   m :  ℕ ) ,   m > n ∧   m %  2 =  1",
    " ∃    (   n :  ℕ ) ,   n %  2 =  1",
    " ∀  n  ,  ∃     m  ,   n < m ∧  Odd  m",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   k :  ℕ ) ,   k ≥ n ∧  Odd  k",
    " ∃    (   n :  ℕ ) ,  Odd  n",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   k :  ℕ ) ,  n <    2 * k +  1",
    " ∃    (   n :  ℕ ) ,  ∀   (  m  :  ℕ  )  ,   m < n →  Odd  m",
    " ∀  p   :  ℕ ,  ∃     m  :  ℕ ,   m > p ∧  Odd  m"]},
  {"theorem": "Nat.Prime 3",
   "prompt": "The smallest odd prime is `3`.",
   "all-elabs":
   [" Nat.Prime   3",
    " ∀  p   :  ℕ ,   Nat.Prime  p →    p %  2 =  1 →  p =  3",
    " ∀   (  n  :  ℕ  )  ,   Nat.Prime  n →   Nat.Prime   (   n +  2  ) →  n =  1",
    " ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧    p %  2 =  1 ∧  ∀   (  p'  :  ℕ  )  ,    p' %  2 =  1 →   Nat.Prime  p' →  p ≤ p'"]},
  {"theorem": "∀ {n : ℕ}, ∃ p, n < p ∧ Nat.Prime p ∧ Odd p",
   "prompt": "There are infinitely many odd prime numbers.",
   "all-elabs":
   [" ∀   {  n  :  ℕ }  ,  ∃    (   p :  ℕ ) ,   n < p ∧   Nat.Prime  p ∧  Odd  p",
    " ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  Odd  p",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   p :  ℕ ) ,   n < p ∧   Nat.Prime  p ∧   p %  2 =  1",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   p :  ℕ ) ,   p ≥ n ∧   Nat.Prime  p ∧   p %  2 =  1",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   p :  ℕ ) ,   p > n ∧   Nat.Prime  p ∧  Odd  p",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   p :  ℕ ) ,   n < p ∧    p %  2 =  1 ∧  Nat.Prime  p",
    " ∀   (  a  :  ℕ  )  ,  ∃    (   b :  ℕ ) ,   Nat.Prime  b ∧  a < b",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  p > n",
    " ∃    (   p :  ℕ ) ,   p >  2 ∧  Nat.Prime  p"]},
  {"theorem": "∀ {R : Type u} [inst : Ringₓ R], IsField R",
   "prompt": "Every ring is a field.",
   "all-elabs": [" {  R :  Type  u } ->  [  Ringₓ  R ] ->  IsField  R"]},
  {"theorem": "(K : Type u) → [inst : Field K] → Ring K",
   "prompt": "Every field is a ring.",
   "all-elabs":
   [" (  K :  Type  u ) ->  [  Field  K ] ->  Ring  K",
    " (  K :  Type  u ) ->  [  Field  K ] ->  Ringₓ  K",
    " (  K :  Type  u ) ->  [  Field  K ] ->  Ring  K",
    " (  K :  Type  u ) ->  [  Field  K ] ->  Ringₓ  K",
    " {  K :  Type  u } ->  [  Field  K ] ->  Ring  K",
    " {  K :  Type  u } ->  [  Field  K ] ->  Ringₓ  K",
    " (  K :  Type  u ) ->  [  Field  K ] ->  CommRing  K",
    " (  K :  Type  u ) ->  [  Field  K ] ->  CommRingₓ  K"]},
  {"theorem": "{α : Type u_1} → [inst : Ringₓ α] → Group (Units α)",
   "prompt": "The set of units in a ring forms a group.",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  [  Ringₓ  α ] ->  Group   (   Units  α  )",
    " {  α :  Type  u_1 } ->  [  Ringₓ  α ] ->  Groupₓ   (   Units  α  )",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  Group   (   Units  α  )",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  Groupₓ   (   Units  α  )",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  Group   (   Units  R  )",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  Groupₓ   (   Units  R  )",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  Group   (    @ Units  R  _  )",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  Groupₓ   (    @ Units  R  _  )",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  Group   (   Units  R  )",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  Groupₓ   (   Units  R  )",
    " {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  [  Fintype  R ] ->  Monoid   (   Units  R  )",
    " {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  [  Fintype  R ] ->  Monoidₓ   (   Units  R  )",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  AddCommGroup   (   Units  R  )",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  AddCommGroupₓ   (   Units  R  )",
    " {  α :  Type  u_1 } ->  [  Ringₓ  α ] ->  [  One  α ] ->  Group   (   Units  α  )",
    " {  α :  Type  u_1 } ->  [  Ringₓ  α ] ->  [  One  α ] ->  Groupₓ   (   Units  α  )"]},
  {"theorem":
   "∀ (k : Type u_1) {V : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroupₓ V] [inst_2 : Module k V],\n  FiniteDimensional k V",
   "prompt": "Every vector space is finite dimensional.",
   "all-elabs":
   [" (  k :  Type  u_1 ) ->  {  V :  Type  u_2 } ->  [  DivisionRing  k ] ->  [  AddCommGroupₓ  V ] ->  [  Module  k V ] ->  FiniteDimensional  k V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  [  DecidableEq  V ] ->  FiniteDimensional  K V",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  [  DivisionRing  α ] ->  [  AddCommGroupₓ  β ] ->  [  Module  α β ] ->  FiniteDimensional  α β",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  FiniteDimensional  K V",
    " (  K :  Type  u ) ->  (  V :  Type  v ) ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  FiniteDimensional  K V",
    " {  k :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  k ] ->  [  AddCommGroupₓ  V ] ->  [  Module  k V ] ->  FiniteDimensional  k V"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
   "prompt":
   "If a vector space has dimension `2` then it is finite dimensional.",
   "all-elabs":
   [" {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->    Module.rank  K V =  2 →  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  {  n :  ℕ } ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V ≤  2 ) ->  FiniteDimensional  K V"]},
  {"theorem": "(K : Type u) → [inst : Field K] → DivisionRing K",
   "prompt": "Every field is a division ring.",
   "all-elabs":
   [" (  K :  Type  u ) ->  [  Field  K ] ->  DivisionRing  K",
    " {  K :  Type  u } ->  [  Field  K ] ->  DivisionRing  K",
    " {  K :  Type* } ->  [  Field  K ] ->  DivisionRing  K",
    " {  F :  Type  u } ->  [  Field  F ] ->  DivisionRing  F",
    " (  F :  Type  u ) ->  [  Field  F ] ->  DivisionRing  F"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
   "prompt": "If a space has dimension `2` then it is finite dimensional.",
   "all-elabs":
   [" {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->    Module.rank  K V =  2 →  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V ≤  2 ) ->  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V"]},
  {"theorem": "∀ {G : Type u_1} [inst : Groupₓ G], Monoidₓ.IsTorsion G",
   "prompt": "Every group is a torsion monoid.",
   "all-elabs":
   [" {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  Monoidₓ.IsTorsion  G",
    " (  G :  Type  u_1 ) ->  [  Groupₓ  G ] ->  Monoidₓ.IsTorsion  G",
    " {  G :  Type  u_3 } ->  [  Groupₓ  G ] ->  Monoidₓ.IsTorsion  G"]},
  {"theorem": "∀ {m : ℕ}, ∃ n, m < n",
   "prompt": "Every natural number has a successor.",
   "all-elabs":
   [" {  m :  ℕ } ->  ∃    (   n :  ℕ ) ,  m < n",
    " {  n :  ℕ } ->  ∃    (   m :  ℕ ) ,  n < m",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   m :  ℕ ) ,  m = n.succ",
    " {  n :  ℕ } ->  ∃    (   m :  ℕ ) ,  n = m.succ",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   m :  ℕ ) ,  n < m",
    " {  n :  ℕ } ->  ∃    (   a :  ℕ ) ,  n < a"]},
  {"theorem": "∀ (n : ℕ), n < Nat.succ n",
   "prompt": "Every natural number is less than its successor.",
   "all-elabs": [" (  n :  ℕ ) ->  n < n.succ", " {  n :  ℕ } ->  n < n.succ"]},
  {"theorem":
   "∀ {η G : Type u_1} {Gs : η → Type u_2} [inst : Groupₓ G] [inst_1 : (i : η) → Groupₓ (Gs i)],\n  Monoidₓ.IsTorsionFree (G × ((i : η) → Gs i)) → ∀ (i : η), Monoidₓ.IsTorsionFree (Gs i)",
   "prompt":
   "If the direct product of two groups is torsion free then each of the groups is torsion free.",
   "all-elabs":
   [" {  η :  Type  u_1 } ->  {  G :  Type  u_1 } ->  {  Gs :  η →  Type  u_2 } ->  [  Groupₓ  G ] ->  [  Π ( i : η ) ,  Groupₓ   (   Gs  i  ) ] ->  (  h :  Monoidₓ.IsTorsionFree   (   G ×  Π ( i : η ) ,  Gs  i  ) ) ->  (  i : η ) ->  Monoidₓ.IsTorsionFree   (   Gs  i  )"]},
  {"theorem":
   "∀ {G : Type u} [inst : Groupₓ G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Nat.Prime p ∧ Fintype.card G = p",
   "prompt": "Every finite simple group has prime order.",
   "all-elabs":
   [" {  G :  Type  u } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  (  h :  IsSimpleGroup  G ) ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   Fintype.card  G = p",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  (  h :  IsSimpleGroup  G ) ->  ∃     p  ,   Fact   (   Nat.Prime  p  ) ∧   Fintype.card  G = p",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  (  h :  IsSimpleGroup  G ) ->  ∃    (   p :  ℕ ) ,   Fact   (   Nat.Prime  p  ) ∧   Fintype.card  G = p",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  (  h :  IsSimpleGroup  G ) ->  ∃    (   p :  ℕ ) ,    Fintype.card  G = p ∧  Fact   (   Nat.Prime  p  )",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  [  IsSimpleGroup  α ] ->  ∃    (   p :  ℕ ) ,   Fact   (   Nat.Prime  p  ) ∧   Fintype.card  α = p",
    " {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  (  h :  IsSimpleGroup  α ) ->  ∃     p  ,   Nat.Prime  p ∧   Fintype.card  α = p",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  (  h :  IsSimpleGroup  α ) ->  ∃    (   p :  ℕ ) ,   Fact   (   Nat.Prime  p  ) ∧   Fintype.card  α = p",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  (  h :  IsSimpleGroup  α ) ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   Fintype.card  α = p"]},
  {"theorem":
   "∀ {G : Type u} [inst : Groupₓ G] [inst_1 : Fintype G], IsSimpleGroup G",
   "prompt": "Every finite group is simple.",
   "all-elabs":
   [" {  G :  Type  u } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  IsSimpleGroup  G",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  IsSimpleGroup  α",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  IsSimpleGroup  G",
    " (  G :  Type  u_1 ) ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  IsSimpleGroup  G"]},
  {"theorem":
   "∀ {α : Type u} [inst : Group α] [inst : Fintype α], ∃ p, Fintype.card α = p ∧ Fact (Nat.Prime p)",
   "prompt": "Every finite group has prime order.",
   "all-elabs":
   [" {  α :  Type  u } ->  [  Group  α ] ->  [  Fintype  α ] ->  ∃    (   p :  ℕ ) ,    Fintype.card  α = p ∧  Fact   (   Nat.Prime  p  )",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  ∃    (   p :  ℕ ) ,    Fintype.card  α = p ∧  Fact   (   Nat.Prime  p  )",
    " {  α :  Type  u } ->  [  Group  α ] ->  [  Fintype  α ] ->  ∃    (   p :  ℕ ) ,   Fact   (   Nat.Prime  p  ) ∧   Fintype.card  α = p",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  ∃    (   p :  ℕ ) ,   Fact   (   Nat.Prime  p  ) ∧   Fintype.card  α = p",
    " {  α :  Type  u } ->  [  Group  α ] ->  [  Fintype  α ] ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   Fintype.card  α = p",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   Fintype.card  α = p",
    " {  α :  Type  u } ->  [  Group  α ] ->  [  Fintype  α ] ->  ∃     p  :  ℕ ,   Fact   (   Nat.Prime  p  ) ∧   Fintype.card  α = p",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  ∃     p  :  ℕ ,   Fact   (   Nat.Prime  p  ) ∧   Fintype.card  α = p",
    " {  G :  Type  u_1 } ->  [  Group  G ] ->  [  Fintype  G ] ->  ∃    (   p :  ℕ ) ,   Fact   (   Nat.Prime  p  ) ∧   Fintype.card  G = p",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  ∃    (   p :  ℕ ) ,   Fact   (   Nat.Prime  p  ) ∧   Fintype.card  G = p",
    " {  G :  Type  u } ->  [  Group  G ] ->  [  Fintype  G ] ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   Fintype.card  G = p",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   Fintype.card  G = p",
    " {  G :  Type  u_1 } ->  [  Group  G ] ->  [  Fintype  G ] ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   Fintype.card  G = p",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   Fintype.card  G = p"]},
  {"theorem":
   "∀ (m n : ℕ), ∃ a b c, a * a + b * b = c * c ∧ gcd a b = 1 ∧ a > 0 ∧ b > 0 ∧ c > 0 ∧ a ≥ m ∧ b ≥ n",
   "prompt": "There are infinitely many Pythagorean triples.",
   "all-elabs":
   [" ∀   (  m  :  ℕ  )  (  n  :  ℕ  )  ,  ∃    (   a  b  c :  ℕ ) ,  (      a * a +  b * b =  c * c ∧    gcd  a b =  1 ∧   a >  0 ∧   b >  0 ∧   c >  0 ∧   a ≥ m ∧  b ≥ n  )",
    " ∀  n   :  ℕ ,  ∃    (   x  y  z :  ℕ ) ,   z > n ∧    x * x +  y * y =  z * z",
    " ∀   (  x y z  :  ℕ  )  ,  ∃    (   x'  y'  z' :  ℕ ) ,   PythagoreanTriple  x' y' z' ∧   x' > x ∧   y' > y ∧  z' > z",
    " ∀   (  x y z  :  ℤ  )  ,  ∃    (   a  b  c :  ℤ ) ,   PythagoreanTriple  a b c ∧   a > x ∧   b > y ∧  c > z",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   x  y  z :  ℕ ) ,     x ^  2 +  y ^  2 =  z ^  2 ∧   x >  0 ∧   y >  0 ∧   z >  0 ∧    x + y + z = n",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   x  y  z :  ℕ ) ,     x * x +  y * y =  z * z ∧  z > n",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   x  y  z :  ℕ ) ,   PythagoreanTriple  x y z ∧  x ≤ n",
    " ∀   (  m n  :  ℕ  )  ,  ∃    (   x  y  z :  ℕ ) ,     x * x +  y * y =  z * z ∧   x ≠  0 ∧   y ≠  0 ∧  z ≠  0",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   x  y  z :  ℕ ) ,     x ^  2 +  y ^  2 =  z ^  2 ∧  x ≥ n",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   x  y  z :  ℕ ) ,   PythagoreanTriple  x y z ∧  x > n",
    " ∀   (  z  :  ℕ  )  ,  ∃    (   x  y :  ℕ ) ,  PythagoreanTriple  x y z"]},
  {"theorem":
   "∀ {α : Type u_1} {m : MeasurableSpace α} (s : Set α), MeasurableSet s",
   "prompt": "Every set is Lebesgue measurable.",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  (  s :  Set  α ) ->  MeasurableSet  s",
    " {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  ∀   (  s  :  Set  α  )  ,  MeasurableSet  s",
    " {  α :  Type* } ->  MeasurableSpace  α",
    " {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  [  TopologicalSpace.PseudoMetrizableSpace  α ] ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  s :  Set  α ) ->  MeasurableSet  s"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MeasurableSpace α] (A : Set α), coeFn MeasureTheory.volume.toOuterMeasure A = 0",
   "prompt": "Every set has Lebesgue measure zero.",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  ∀   (  A  :  Set  α  )  ,   MeasureTheory.MeasureSpace.volume  A =  0",
    " ∀   {  α  :  Type  u_1 }  {  s  :  Set  α }  ,   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  α :  Type  u } ->  [  MeasurableSpace  α ] ->  ∀   {  s  :  Set  α }  ,   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  (  s :  Set  α ) ->   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  {  s :  Set  α } ->   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  α :  Type  u_1 } ->  ∀   (  s  :  Set  α  )  ,   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  α :  Type  u_1 } ->  (  s :  Set  α ) ->   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  α :  Type  u_1 } ->  {  s :  Set  α } ->   MeasureTheory.MeasureSpace.volume  s =  0"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (t : Set α), IsClosed t → s ≠ t → IsCompact t) → IsCompact s",
   "prompt":
   "If every proper closed set of a topological space is compact, then the space itself is compact.",
   "all-elabs":
   [" {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h :  ∀   (  t  :  Set  α  )  (  ht  :  IsClosed  t  )  (  hne  :  s ≠ t  )  ,  IsCompact  t ) ->  IsCompact  s"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α], CompactSpace α → ∀ (s : Set α), IsCompact s",
   "prompt": "If a topological space is compact, then every subset is compact.",
   "all-elabs":
   [" {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  h :  CompactSpace  α ) ->  (  s :  Set  α ) ->  IsCompact  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  h :  IsCompact  α ) ->  (  s :  Set  α ) ->  IsCompact  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  h :  IsCompact  α ) ->  {  s :  Set  α } ->  IsCompact  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  hα :  IsCompact  α ) ->  (  s :  Set  α ) ->  IsCompact  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  [  CompactSpace  α ] ->  {  s :  Set  α } ->  IsCompact  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  [  CompactSpace  α ] ->  (  s :  Set  α ) ->  IsCompact  s",
    " {  α :  Type* } ->  [  TopologicalSpace  α ] ->  [  CompactSpace  α ] ->  {  s :  Set  α } ->  IsCompact  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  h :  CompactSpace  α ) ->  {  s :  Set  α } ->  IsCompact  s"]},
  {"theorem":
   "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
   "prompt":
   "Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.",
   "all-elabs":
   [" (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp4 :   p %  4 =  1 ) ->  ∃    (   a  b :  ℕ ) ,    a ^  2 +  b ^  2 = p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp :   p %  4 =  1 ) ->  ∃    (   a  b :  ℕ ) ,    a ^  2 +  b ^  2 = p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h :   p %  4 =  1 ) ->  ∃    (   a  b :  ℕ ) ,    a ^  2 +  b ^  2 = p",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h :   p %  4 =  1 ) ->  ∃    (   a  b :  ℕ ) ,    a ^  2 +  b ^  2 = p",
    " {  p :  ℕ } ->  (  hp :  Nat.Prime  p ) ->  (  h :   p %  4 =  1 ) ->  ∃    (   a  b :  ℕ ) ,    a ^  2 +  b ^  2 = p",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp :   p %  4 =  1 ) ->  ∃    (   a  b :  ℕ ) ,    a ^  2 +  b ^  2 = p"]},
  {"theorem": "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], ¬∃ n, n * n = p",
   "prompt": "No prime number is a perfect square.",
   "all-elabs":
   [" {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  ¬  ∃    (   n :  ℕ ) ,   n * n = p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  ¬  ∃    (   n :  ℕ ) ,   n ^  2 = p",
    " {  n :  ℕ } ->  [  Fact   (   Nat.Prime  n  ) ] ->  ∀   (  m  :  ℕ  )  ,   m * m ≠ n",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  ¬  ∃    (   m :  ℕ ) ,   m * m = p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  ¬  ∃    (   t :  ℕ ) ,   t * t = p"]},
  {"theorem": "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p > 2",
   "prompt": "Every odd prime number is greater than `2`.",
   "all-elabs":
   [" (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  p >  2",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h :  Odd  p ) ->  p >  2",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h :  Odd  p ) ->   2 < p",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h :   p %  2 =  1 ) ->   2 < p",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h_odd :   p %  2 =  1 ) ->   2 < p",
    " (  p :  ℕ ) ->  [ hpri :  Fact   (   Nat.Prime  p  ) ] ->  (  h :   p %  2 =  1 ) ->   2 < p",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h :   p %  2 =  1 ) ->  p >  2",
    " {  p :  ℕ } ->  (  h_p_odd :  Odd  p ) ->  (  h_p_prime :  Nat.Prime  p ) ->   2 < p"]},
  {"theorem":
   "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : LinearOrderedRing 𝕜] [inst_1 : AddCommGroupₓ E] [inst_2 : Module 𝕜 E]\n  [inst_3 : DenselyOrdered 𝕜] [inst_4 : NoZeroSmulDivisors 𝕜 E] {A : Set E} {x₁ x₂ : E},\n  x₁ ∈ A → x₂ ∈ A → Segment 𝕜 x₁ x₂ ⊂ A",
   "prompt":
   "Every line segments whose endpoints are in a convex set `C` is contained in `C`.",
   "all-elabs":
   [" {  𝕜 :  Type  u_1 } ->  {  E :  Type  u_2 } ->  [  LinearOrderedRing  𝕜 ] ->  [  AddCommGroupₓ  E ] ->  [  Module  𝕜 E ] ->  [  DenselyOrdered  𝕜 ] ->  [  NoZeroSmulDivisors  𝕜 E ] ->  {  A :  Set  E } ->  {  x₁ x₂ : E } ->   x₁ ∈ A →   x₂ ∈ A →   Segment  𝕜 x₁ x₂ ⊆ A",
    " {  𝕜 :  Type  u_1 } ->  {  E :  Type  u_2 } ->  [  LinearOrderedRing  𝕜 ] ->  [  AddCommGroupₓ  E ] ->  [  Module  𝕜 E ] ->  [  DenselyOrdered  𝕜 ] ->  [  NoZeroSmulDivisors  𝕜 E ] ->  {  A :  Set  E } ->  {  x₁ x₂ : E } ->   x₁ ∈ A →   x₂ ∈ A →   x₁ ≠ x₂ →   Segment  𝕜 x₁ x₂ ⊆ A",
    " {  𝕜 :  Type  u_1 } ->  {  E :  Type  u_2 } ->  [  LinearOrderedRing  𝕜 ] ->  [  AddCommGroupₓ  E ] ->  [  Module  𝕜 E ] ->  [  DenselyOrdered  𝕜 ] ->  [  NoZeroSmulDivisors  𝕜 E ] ->  {  A :  Set  E } ->  {  x₁ : E } ->  {  x₂ : E } ->   x₁ ∈ A →   x₂ ∈ A →   Segment  𝕜 x₁ x₂ ⊆ A",
    " {  𝕜 :  Type  u_1 } ->  {  E :  Type  u_2 } ->  [  LinearOrderedField  𝕜 ] ->  [  AddCommGroupₓ  E ] ->  [  Module  𝕜 E ] ->  [  DenselyOrdered  𝕜 ] ->  [  NoZeroSmulDivisors  𝕜 E ] ->  {  C :  Set  E } ->  (  x y : E ) ->  (  Hx :  x ∈ C ) ->  (  Hy :  y ∈ C ) ->   Segment  𝕜 x y ⊆ C",
    " {  𝕜 :  Type  u_1 } ->  {  E :  Type  u_2 } ->  [  LinearOrderedRing  𝕜 ] ->  [  AddCommGroupₓ  E ] ->  [  Module  𝕜 E ] ->  [  DenselyOrdered  𝕜 ] ->  [  NoZeroSmulDivisors  𝕜 E ] ->  {  C :  Set  E } ->  {  x₁ : E } ->  {  x₂ : E } ->   x₁ ∈ C →   x₂ ∈ C →   Segment  𝕜 x₁ x₂ ⊆ C",
    " {  𝕜 :  Type  u_1 } ->  {  E :  Type  u_2 } ->  [  LinearOrderedRing  𝕜 ] ->  [  AddCommGroupₓ  E ] ->  [  Module  𝕜 E ] ->  [  DenselyOrdered  𝕜 ] ->  [  NoZeroSmulDivisors  𝕜 E ] ->  {  A :  Set  E } ->  {  x₁ x₂ : E } ->  (  hx₁ :  x₁ ∈ A ) ->  (  hx₂ :  x₂ ∈ A ) ->   Segment  𝕜 x₁ x₂ ⊆ A",
    " {  𝕜 :  Type  u_1 } ->  {  E :  Type  u_2 } ->  [  LinearOrderedRing  𝕜 ] ->  [  AddCommGroupₓ  E ] ->  [  Module  𝕜 E ] ->  [  DenselyOrdered  𝕜 ] ->  [  NoZeroSmulDivisors  𝕜 E ] ->  {  C :  Set  E } ->  (  H :  Convex  𝕜 C ) ->  {  x₁ x₂ : E } ->  (  H₁ :  x₁ ∈ C ) ->  (  H₂ :  x₂ ∈ C ) ->   Segment  𝕜 x₁ x₂ ⊆ C"]},
  {"theorem":
   "∀ {a b : ℕ},\n  ∃ x y z w,\n    a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ∧ b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ↔\n      ∃ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2",
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "all-elabs":
   [" {  a b :  ℕ } ->  ∃    (   x  y  z  w :  ℕ ) ,    a =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ∧  b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ↔  ∃    (   x  y  z  w :  ℕ ) ,   a * b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2",
    " {  a b :  ℕ } ->  (  ha :  ∃    (   x  y  z  w :  ℕ ) ,  a =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  (  hb :  ∃    (   x  y  z  w :  ℕ ) ,  b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  ∃    (   x  y  z  w :  ℕ ) ,   a * b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2",
    " {  a b :  ℕ } ->  (  h₁ :  ∃    (   x  y  z  w :  ℕ ) ,  a =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  (  h₂ :  ∃    (   x  y  z  w :  ℕ ) ,  b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  ∃    (   x  y  z  w :  ℕ ) ,   a * b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2",
    " {  α :  Type  u } ->  [  CommRing  α ] ->  {  x y : α } ->  (  hx :  ∃    (   a  b  c  d : α ) ,  x =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2 ) ->  (  hy :  ∃    (   a  b  c  d : α ) ,  y =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2 ) ->  ∃    (   a  b  c  d : α ) ,   x * y =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2",
    " {  α :  Type  u } ->  [  CommRingₓ  α ] ->  {  x y : α } ->  (  hx :  ∃    (   a  b  c  d : α ) ,  x =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2 ) ->  (  hy :  ∃    (   a  b  c  d : α ) ,  y =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2 ) ->  ∃    (   a  b  c  d : α ) ,   x * y =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2",
    " {  α :  Type  u } ->  [  Ring  α ] ->  {  a b : α } ->  (  hab :  ∃    (   x  y  z  w : α ) ,  a =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  (  hba :  ∃    (   x  y  z  w : α ) ,  b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  ∃    (   x  y  z  w : α ) ,   a * b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  {  a b : α } ->  (  hab :  ∃    (   x  y  z  w : α ) ,  a =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  (  hba :  ∃    (   x  y  z  w : α ) ,  b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  ∃    (   x  y  z  w : α ) ,   a * b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2",
    " {  α :  Type  u } ->  [  Field  α ] ->  {  x y : α } ->  (  hx :  ∃    (   a  b  c  d : α ) ,  x =     a * a +  b * b +  c * c +  d * d ) ->  (  hy :  ∃    (   a  b  c  d : α ) ,  y =     a * a +  b * b +  c * c +  d * d ) ->  ∃    (   a  b  c  d : α ) ,   x * y =     a * a +  b * b +  c * c +  d * d",
    " {  α :  Type  u } ->  [  LinearOrderedRing  α ] ->  {  x y : α } ->  (  hx :  ∃     a  b  c  d  : α ,  x =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2 ) ->  (  hy :  ∃     a  b  c  d  : α ,  y =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2 ) ->  ∃     a  b  c  d  : α ,   x * y =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2"]},
  {"theorem":
   "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
   "prompt": "Every compact topological space is locally compact.",
   "all-elabs":
   [" {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  [  CompactSpace  X ] ->  LocallyCompactSpace  X",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  [  CompactSpace  α ] ->  LocallyCompactSpace  α",
    " {  X :  Type  u } ->  [  TopologicalSpace  X ] ->  [  CompactSpace  X ] ->  LocallyCompactSpace  X",
    " {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  (  hX :  CompactSpace  X ) ->  LocallyCompactSpace  X"]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
   "prompt": "Every continuous function is uniformly continuous.",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  Continuous  f ) ->  UniformContinuous  f",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  Continuous  f ) ->  UniformContinuous  f"]}],
 "elaborated": 30}