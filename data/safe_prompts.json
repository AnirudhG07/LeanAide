[
  {
    "name": "nndist_triangle",
    "statement": "theorem nndist_triangle {α : Type u} [pseudo_metric_space α] (x y z : α) : has_nndist.nndist x z ≤ has_nndist.nndist x y + has_nndist.nndist y z",
    "theorem": "{α : Type u} [pseudo_metric_space α] (x y z : α) : has_nndist.nndist x z ≤ has_nndist.nndist x y + has_nndist.nndist y z",
    "args": "{α : Type u} [pseudo_metric_space α] (x y z : α)",
    "doc_string": "Triangle inequality for the nonnegative distance",
    "type": "has_nndist.nndist x z ≤ has_nndist.nndist x y + has_nndist.nndist y z"
  },
  {
    "name": "sub_lt_zero",
    "statement": "theorem sub_lt_zero {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a - b < 0 ↔ a < b",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a - b < 0 ↔ a < b",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α}",
    "doc_string": "**Alias** of sub_neg`.",
    "type": "a - b < 0 ↔ a < b"
  },
  {
    "name": "zero_lt.preorder.left.mul_le_one_of_le_of_le'",
    "statement": "theorem zero_lt.preorder.left.mul_le_one_of_le_of_le' {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 < a) : a * b ≤ 1",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 < a) : a * b ≤ 1",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 < a)",
    "doc_string": "Assumes left covariance.",
    "type": "a * b ≤ 1"
  },
  {
    "name": "add_units.is_add_regular",
    "statement": "theorem add_units.is_add_regular {R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular ↑a",
    "theorem": "{R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular ↑a",
    "args": "{R : Type u_1} [add_monoid R] (a : add_units R)",
    "doc_string": "If `R` is an additive monoid, an element in `add_units R` is add-regular.",
    "type": "is_add_regular ↑a"
  },
  {
    "name": "exists_prime_add_order_of_dvd_card",
    "statement": "theorem exists_prime_add_order_of_dvd_card {G : Type u_1} [add_group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), add_order_of x = p",
    "theorem": "{G : Type u_1} [add_group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), add_order_of x = p",
    "args": "{G : Type u_1} [add_group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G)",
    "doc_string": " For every prime `p` dividing the order of a finite additive group `G` there exists an element of order `p` in `G`. This is the additive version of Cauchy's theorem.",
    "type": "∃ (x : G), add_order_of x = p"
  },
  {
    "name": "lt_add_of_sub_right_lt",
    "statement": "theorem lt_add_of_sub_right_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a - c < b → a < b + c",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a - c < b → a < b + c",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of sub_lt_iff_lt_add`.",
    "type": "a - c < b → a < b + c"
  },
  {
    "name": "mem_Icc_of_mem_std_simplex",
    "statement": "theorem mem_Icc_of_mem_std_simplex {R : Type u_1} {ι : Type u_4} [linear_ordered_field R] [fintype ι] {f : ι → R} (hf : f ∈ std_simplex R ι) (x : ι) : f x ∈ set.Icc 0 1",
    "theorem": "{R : Type u_1} {ι : Type u_4} [linear_ordered_field R] [fintype ι] {f : ι → R} (hf : f ∈ std_simplex R ι) (x : ι) : f x ∈ set.Icc 0 1",
    "args": "{R : Type u_1} {ι : Type u_4} [linear_ordered_field R] [fintype ι] {f : ι → R} (hf : f ∈ std_simplex R ι) (x : ι)",
    "doc_string": "All values of a function `f ∈ std_simplex 𝕜 ι` belong to `[0, 1]`.",
    "type": "f x ∈ set.Icc 0 1"
  },
  {
    "name": "linear_ordered_comm_group_with_zero.directed_lt",
    "statement": "theorem linear_ordered_comm_group_with_zero.directed_lt (Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] : directed ge (λ (γ₀ : Γ₀ˣ), filter.principal {γ : Γ₀ | γ < ↑γ₀})",
    "theorem": "(Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] : directed ge (λ (γ₀ : Γ₀ˣ), filter.principal {γ : Γ₀ | γ < ↑γ₀})",
    "args": "(Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀]",
    "doc_string": " The neighbourhoods {γ | γ < γ₀} of 0 form a directed set indexed by the invertible elements γ₀.",
    "type": "directed ge (λ (γ₀ : Γ₀ˣ), filter.principal {γ : Γ₀ | γ < ↑γ₀})"
  },
  {
    "name": "zmod.legendre_sym_eq_zero_iff",
    "statement": "theorem zmod.legendre_sym_eq_zero_iff (p : ℕ) [fact (nat.prime p)] (a : ℤ) : zmod.legendre_sym p a = 0 ↔ ↑a = 0",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) : zmod.legendre_sym p a = 0 ↔ ↑a = 0",
    "args": "(p : ℕ) [fact (nat.prime p)] (a : ℤ)",
    "doc_string": "The Legendre symbol of `p` and `a` is zero iff `p ∣ a`.",
    "type": "zmod.legendre_sym p a = 0 ↔ ↑a = 0"
  },
  {
    "name": "metric.Hausdorff_dist_nonneg",
    "statement": "theorem metric.Hausdorff_dist_nonneg {α : Type u} [pseudo_metric_space α] {s t : set α} : 0 ≤ metric.Hausdorff_dist s t",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s t : set α} : 0 ≤ metric.Hausdorff_dist s t",
    "args": "{α : Type u} [pseudo_metric_space α] {s t : set α}",
    "doc_string": "The Hausdorff distance is nonnegative",
    "type": "0 ≤ metric.Hausdorff_dist s t"
  },
  {
    "name": "is_regular_iff_ne_zero",
    "statement": "theorem is_regular_iff_ne_zero {R : Type u_1} {a : R} [cancel_monoid_with_zero R] [nontrivial R] : is_regular a ↔ a ≠ 0",
    "theorem": "{R : Type u_1} {a : R} [cancel_monoid_with_zero R] [nontrivial R] : is_regular a ↔ a ≠ 0",
    "args": "{R : Type u_1} {a : R} [cancel_monoid_with_zero R] [nontrivial R]",
    "doc_string": "In a non-trivial integral domain, an element is regular iff it is non-zero.",
    "type": "is_regular a ↔ a ≠ 0"
  },
  {
    "name": "ennreal.coe_sub",
    "statement": "theorem ennreal.coe_sub {r p : nnreal} : ↑(r - p) = ↑r - ↑p",
    "theorem": "{r p : nnreal} : ↑(r - p) = ↑r - ↑p",
    "args": "{r p : nnreal}",
    "doc_string": "This is a special case of `with_top.coe_sub` in the `ennreal` namespace",
    "type": "↑(r - p) = ↑r - ↑p"
  },
  {
    "name": "descending_central_series_ge_lower",
    "statement": "theorem descending_central_series_ge_lower {G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_descending_central_series H) (n : ℕ) : lower_central_series G n ≤ H n",
    "theorem": "{G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_descending_central_series H) (n : ℕ) : lower_central_series G n ≤ H n",
    "args": "{G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_descending_central_series H) (n : ℕ)",
    "doc_string": "Any descending central series for a group is bounded below by the lower central series.",
    "type": "lower_central_series G n ≤ H n"
  },
  {
    "name": "measurable_of_tendsto_ennreal",
    "statement": "theorem measurable_of_tendsto_ennreal {α : Type u_1} [measurable_space α] {f : ℕ → α → ennreal} {g : α → ennreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g",
    "theorem": "{α : Type u_1} [measurable_space α] {f : ℕ → α → ennreal} {g : α → ennreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g",
    "args": "{α : Type u_1} [measurable_space α] {f : ℕ → α → ennreal} {g : α → ennreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g))",
    "doc_string": "A sequential limit of measurable `ℝ≥0∞` valued functions is measurable.",
    "type": "measurable g"
  },
  {
    "name": "char_p_zero_or_prime_power",
    "statement": "theorem char_p_zero_or_prime_power (R : Type u_1) [comm_ring R] [local_ring R] (q : ℕ) [char_R_q : char_p R q] : q = 0 ∨ is_prime_pow q",
    "theorem": "(R : Type u_1) [comm_ring R] [local_ring R] (q : ℕ) [char_R_q : char_p R q] : q = 0 ∨ is_prime_pow q",
    "args": "(R : Type u_1) [comm_ring R] [local_ring R] (q : ℕ) [char_R_q : char_p R q]",
    "doc_string": "In a local ring the characteristics is either zero or a prime power.",
    "type": "q = 0 ∨ is_prime_pow q"
  },
  {
    "name": "is_left_regular.pow",
    "statement": "theorem is_left_regular.pow {R : Type u_1} {a : R} [monoid R] (n : ℕ) (rla : is_left_regular a) : is_left_regular (a ^ n)",
    "theorem": "{R : Type u_1} {a : R} [monoid R] (n : ℕ) (rla : is_left_regular a) : is_left_regular (a ^ n)",
    "args": "{R : Type u_1} {a : R} [monoid R] (n : ℕ) (rla : is_left_regular a)",
    "doc_string": "Any power of a left-regular element is left-regular.",
    "type": "is_left_regular (a ^ n)"
  },
  {
    "name": "real.sq_cos_pi_div_six",
    "statement": "theorem real.sq_cos_pi_div_six  : real.cos (real.pi / 6) ^ 2 = 3 / 4",
    "theorem": " : real.cos (real.pi / 6) ^ 2 = 3 / 4",
    "args": "",
    "doc_string": " The square of the cosine of `π / 6` is `3 / 4` (this is sometimes more convenient than the result for cosine itself).",
    "type": "real.cos (real.pi / 6) ^ 2 = 3 / 4"
  },
  {
    "name": "is_right_regular.pow_iff",
    "statement": "theorem is_right_regular.pow_iff {R : Type u_1} {a : R} [monoid R] {n : ℕ} (n0 : 0 < n) : is_right_regular (a ^ n) ↔ is_right_regular a",
    "theorem": "{R : Type u_1} {a : R} [monoid R] {n : ℕ} (n0 : 0 < n) : is_right_regular (a ^ n) ↔ is_right_regular a",
    "args": "{R : Type u_1} {a : R} [monoid R] {n : ℕ} (n0 : 0 < n)",
    "doc_string": "An element `a` is right-regular if and only if a positive power of `a` is right-regular.",
    "type": "is_right_regular (a ^ n) ↔ is_right_regular a"
  },
  {
    "name": "function.injective2.left",
    "statement": "theorem function.injective2.left {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (b : β) : function.injective (λ (a : α), f a b)",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (b : β) : function.injective (λ (a : α), f a b)",
    "args": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (b : β)",
    "doc_string": "A binary injective function is injective when only the left argument varies.",
    "type": "function.injective (λ (a : α), f a b)"
  },
  {
    "name": "function.is_periodic_pt_zero",
    "statement": "theorem function.is_periodic_pt_zero {α : Type u_1} (f : α → α) (x : α) : function.is_periodic_pt f 0 x",
    "theorem": "{α : Type u_1} (f : α → α) (x : α) : function.is_periodic_pt f 0 x",
    "args": "{α : Type u_1} (f : α → α) (x : α)",
    "doc_string": "Any point is a periodic point of period `0`.",
    "type": "function.is_periodic_pt f 0 x"
  },
  {
    "name": "is_coatom.dual",
    "statement": "theorem is_coatom.dual {α : Type u_1} [preorder α] [order_top α] {a : α} : is_coatom a → is_atom (⇑order_dual.to_dual a)",
    "theorem": "{α : Type u_1} [preorder α] [order_top α] {a : α} : is_coatom a → is_atom (⇑order_dual.to_dual a)",
    "args": "{α : Type u_1} [preorder α] [order_top α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of is_atom_dual_iff_is_coatom`.",
    "type": "is_coatom a → is_atom (⇑order_dual.to_dual a)"
  },
  {
    "name": "function.injective.exists_ne",
    "statement": "theorem function.injective.exists_ne {α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) (y : β) : ∃ (x : α), f x ≠ y",
    "theorem": "{α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) (y : β) : ∃ (x : α), f x ≠ y",
    "args": "{α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) (y : β)",
    "doc_string": " An injective function from a nontrivial type has an argument at which it does not take a given value.",
    "type": "∃ (x : α), f x ≠ y"
  },
  {
    "name": "multiples.is_add_submonoid",
    "statement": "theorem multiples.is_add_submonoid {M : Type u_1} [add_monoid M] (x : M) : is_add_submonoid (multiples x)",
    "theorem": "{M : Type u_1} [add_monoid M] (x : M) : is_add_submonoid (multiples x)",
    "args": "{M : Type u_1} [add_monoid M] (x : M)",
    "doc_string": "The set of natural number multiples of an element of an `add_monoid` `M` is an `add_submonoid` of `M`.",
    "type": "is_add_submonoid (multiples x)"
  },
  {
    "name": "is_open_map.to_quotient_map",
    "statement": "theorem is_open_map.to_quotient_map {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f)",
    "doc_string": "A continuous surjective open map is a quotient map.",
    "type": "quotient_map f"
  },
  {
    "name": "cardinal.ord_card_unbounded'",
    "statement": "theorem cardinal.ord_card_unbounded'  : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}",
    "theorem": " : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}",
    "args": "",
    "doc_string": "Infinite ordinals that are cardinals are unbounded.",
    "type": "set.unbounded has_lt.lt {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}"
  },
  {
    "name": "polynomial.cyclotomic_irreducible_of_irreducible_pow",
    "statement": "theorem polynomial.cyclotomic_irreducible_of_irreducible_pow {p : ℕ} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n : ℕ} (hn : n ≠ 0) (h : irreducible (polynomial.cyclotomic (p ^ n) R)) : irreducible (polynomial.cyclotomic p R)",
    "theorem": "{p : ℕ} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n : ℕ} (hn : n ≠ 0) (h : irreducible (polynomial.cyclotomic (p ^ n) R)) : irreducible (polynomial.cyclotomic p R)",
    "args": "{p : ℕ} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n : ℕ} (hn : n ≠ 0) (h : irreducible (polynomial.cyclotomic (p ^ n) R))",
    "doc_string": "If `irreducible (cyclotomic (p ^ n) R)` then `irreducible (cyclotomic p R).`",
    "type": "irreducible (polynomial.cyclotomic p R)"
  },
  {
    "name": "zero_hom.congr_fun",
    "statement": "theorem zero_hom.congr_fun {M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N} (h : f = g) (x : M) : ⇑f x = ⇑g x",
    "theorem": "{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N} (h : f = g) (x : M) : ⇑f x = ⇑g x",
    "args": "{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N} (h : f = g) (x : M)",
    "doc_string": "Deprecated: use `fun_like.congr_fun` instead.",
    "type": "⇑f x = ⇑g x"
  },
  {
    "name": "nat.of_digits_lt_base_pow_length'",
    "statement": "theorem nat.of_digits_lt_base_pow_length' {b : ℕ} {l : list ℕ} (hl : ∀ (x : ℕ), x ∈ l → x < b + 2) : nat.of_digits (b + 2) l < (b + 2) ^ l.length",
    "theorem": "{b : ℕ} {l : list ℕ} (hl : ∀ (x : ℕ), x ∈ l → x < b + 2) : nat.of_digits (b + 2) l < (b + 2) ^ l.length",
    "args": "{b : ℕ} {l : list ℕ} (hl : ∀ (x : ℕ), x ∈ l → x < b + 2)",
    "doc_string": "an n-digit number in base b + 2 is less than (b + 2)^n",
    "type": "nat.of_digits (b + 2) l < (b + 2) ^ l.length"
  },
  {
    "name": "fin.lt_succ_above_iff",
    "statement": "theorem fin.lt_succ_above_iff {n : ℕ} (p : fin (n + 1)) (i : fin n) : p < ⇑(p.succ_above) i ↔ p ≤ ⇑fin.cast_succ i",
    "theorem": "{n : ℕ} (p : fin (n + 1)) (i : fin n) : p < ⇑(p.succ_above) i ↔ p ≤ ⇑fin.cast_succ i",
    "args": "{n : ℕ} (p : fin (n + 1)) (i : fin n)",
    "doc_string": " Embedding `i : fin n` into `fin (n + 1)` using a pivot `p` that is lesser results in a value that is greater than `p`.",
    "type": "p < ⇑(p.succ_above) i ↔ p ≤ ⇑fin.cast_succ i"
  },
  {
    "name": "algebra_map_int_eq",
    "statement": "theorem algebra_map_int_eq (R : Type u_1) [ring R] : algebra_map ℤ R = int.cast_ring_hom R",
    "theorem": "(R : Type u_1) [ring R] : algebra_map ℤ R = int.cast_ring_hom R",
    "args": "(R : Type u_1) [ring R]",
    "doc_string": "A special case of `ring_hom.eq_int_cast'` that happens to be true definitionally",
    "type": "algebra_map ℤ R = int.cast_ring_hom R"
  },
  {
    "name": "nat.odd_mod_four_iff",
    "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3",
    "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3",
    "args": "{n : ℕ}",
    "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`",
    "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"
  },
  {
    "name": "submodule.orthogonal_gc",
    "statement": "theorem submodule.orthogonal_gc (𝕜 : Type u_1) (E : Type u_2) [is_R_or_C 𝕜] [inner_product_space 𝕜 E] : galois_connection submodule.orthogonal submodule.orthogonal",
    "theorem": "(𝕜 : Type u_1) (E : Type u_2) [is_R_or_C 𝕜] [inner_product_space 𝕜 E] : galois_connection submodule.orthogonal submodule.orthogonal",
    "args": "(𝕜 : Type u_1) (E : Type u_2) [is_R_or_C 𝕜] [inner_product_space 𝕜 E]",
    "doc_string": " `submodule.orthogonal` gives a `galois_connection` between `submodule 𝕜 E` and its `order_dual`.",
    "type": "galois_connection submodule.orthogonal submodule.orthogonal"
  },
  {
    "name": "ideal.is_jacobson_localization",
    "statement": "theorem ideal.is_jacobson_localization {R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R] : ideal.is_jacobson S",
    "theorem": "{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R] : ideal.is_jacobson S",
    "args": "{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R]",
    "doc_string": " If `S` is the localization of the Jacobson ring `R` at the submonoid generated by `y : R`, then `S` is Jacobson.",
    "type": "ideal.is_jacobson S"
  },
  {
    "name": "is_monoid_hom.inv",
    "statement": "theorem is_monoid_hom.inv {α : Type u_1} {β : Type u_2} [mul_one_class α] [comm_group β] {f : α → β} (hf : is_monoid_hom f) : is_monoid_hom (λ (a : α), (f a)⁻¹)",
    "theorem": "{α : Type u_1} {β : Type u_2} [mul_one_class α] [comm_group β] {f : α → β} (hf : is_monoid_hom f) : is_monoid_hom (λ (a : α), (f a)⁻¹)",
    "args": "{α : Type u_1} {β : Type u_2} [mul_one_class α] [comm_group β] {f : α → β} (hf : is_monoid_hom f)",
    "doc_string": " The inverse of a map which preserves multiplication, preserves multiplication when the target is commutative.",
    "type": "is_monoid_hom (λ (a : α), (f a)⁻¹)"
  },
  {
    "name": "exp_char_one_of_char_zero",
    "statement": "theorem exp_char_one_of_char_zero (R : Type u) [semiring R] (q : ℕ) [hp : char_p R 0] [hq : exp_char R q] : q = 1",
    "theorem": "(R : Type u) [semiring R] (q : ℕ) [hp : char_p R 0] [hq : exp_char R q] : q = 1",
    "args": "(R : Type u) [semiring R] (q : ℕ) [hp : char_p R 0] [hq : exp_char R q]",
    "doc_string": "The exponential characteristic is one if the characteristic is zero.",
    "type": "q = 1"
  },
  {
    "name": "mul_sub_mul_div_mul_nonpos",
    "statement": "theorem mul_sub_mul_div_mul_nonpos {α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : a / c ≤ b / d → (a * d - b * c) / (c * d) ≤ 0",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : a / c ≤ b / d → (a * d - b * c) / (c * d) ≤ 0",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0)",
    "doc_string": "**Alias** of the reverse direction of mul_sub_mul_div_mul_nonpos_iff`.",
    "type": "a / c ≤ b / d → (a * d - b * c) / (c * d) ≤ 0"
  },
  {
    "name": "category_theory.limits.has_biproduct.of_has_product",
    "statement": "theorem category_theory.limits.has_biproduct.of_has_product {C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_product f] : category_theory.limits.has_biproduct f",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_product f] : category_theory.limits.has_biproduct f",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_product f]",
    "doc_string": "In a preadditive category, if the product over `f : J → C` exists,    then the biproduct over `f` exists.",
    "type": "category_theory.limits.has_biproduct f"
  },
  {
    "name": "right.one_lt_inv_iff",
    "statement": "theorem right.one_lt_inv_iff {α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α}",
    "doc_string": "Uses `right` co(ntra)variant.",
    "type": "1 < a⁻¹ ↔ a < 1"
  },
  {
    "name": "dvd_add_self_left",
    "statement": "theorem dvd_add_self_left {α : Type u} [ring α] {a b : α} : a ∣ a + b ↔ a ∣ b",
    "theorem": "{α : Type u} [ring α] {a b : α} : a ∣ a + b ↔ a ∣ b",
    "args": "{α : Type u} [ring α] {a b : α}",
    "doc_string": "An element a divides the sum a + b if and only if a divides b.",
    "type": "a ∣ a + b ↔ a ∣ b"
  },
  {
    "name": "erased.out_proof",
    "statement": "theorem erased.out_proof {p : Prop} (a : erased p) : p",
    "theorem": "{p : Prop} (a : erased p) : p",
    "args": "{p : Prop} (a : erased p)",
    "doc_string": "Extracts the erased value, if it is a proof.",
    "type": "p"
  },
  {
    "name": "division_def",
    "statement": "theorem division_def {G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * b⁻¹",
    "theorem": "{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * b⁻¹",
    "args": "{G : Type u_1} [div_inv_monoid G] (a b : G)",
    "doc_string": "**Alias** of div_eq_mul_inv`.",
    "type": "a / b = a * b⁻¹"
  },
  {
    "name": "int.nat_abs_pow_two",
    "statement": "theorem int.nat_abs_pow_two (x : ℤ) : ↑(x.nat_abs) ^ 2 = x ^ 2",
    "theorem": "(x : ℤ) : ↑(x.nat_abs) ^ 2 = x ^ 2",
    "args": "(x : ℤ)",
    "doc_string": "**Alias** of int.nat_abs_sq`.",
    "type": "↑(x.nat_abs) ^ 2 = x ^ 2"
  },
  {
    "name": "real.sin_pi_div_six",
    "statement": "theorem real.sin_pi_div_six  : real.sin (real.pi / 6) = 1 / 2",
    "theorem": " : real.sin (real.pi / 6) = 1 / 2",
    "args": "",
    "doc_string": "The sine of `π / 6` is `1 / 2`.",
    "type": "real.sin (real.pi / 6) = 1 / 2"
  },
  {
    "name": "function.maps_to_fixed_pts_comp",
    "statement": "theorem function.maps_to_fixed_pts_comp {α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.maps_to f (function.fixed_points (g ∘ f)) (function.fixed_points (f ∘ g))",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.maps_to f (function.fixed_points (g ∘ f)) (function.fixed_points (f ∘ g))",
    "args": "{α : Type u} {β : Type v} (f : α → β) (g : β → α)",
    "doc_string": "Any map `f` sends fixed points of `g ∘ f` to fixed points of `f ∘ g`.",
    "type": "set.maps_to f (function.fixed_points (g ∘ f)) (function.fixed_points (f ∘ g))"
  },
  {
    "name": "category_theory.limits.has_binary_biproducts_of_finite_biproducts",
    "statement": "theorem category_theory.limits.has_binary_biproducts_of_finite_biproducts (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_binary_biproducts C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_binary_biproducts C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C]",
    "doc_string": "A category with finite biproducts has binary biproducts.  This is not an instance as typically in concrete categories there will be an alternative construction with nicer definitional properties.",
    "type": "category_theory.limits.has_binary_biproducts C"
  },
  {
    "name": "add_lt_of_lt_neg_add",
    "statement": "theorem add_lt_of_lt_neg_add {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : b < -a + c → a + b < c",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : b < -a + c → a + b < c",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of lt_inv_mul_iff_mul_lt`.",
    "type": "b < -a + c → a + b < c"
  },
  {
    "name": "filter.tendsto_mul_left_cobounded",
    "statement": "theorem filter.tendsto_mul_left_cobounded {α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0) : filter.tendsto (has_mul.mul a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)",
    "theorem": "{α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0) : filter.tendsto (has_mul.mul a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)",
    "args": "{α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0)",
    "doc_string": " Multiplication on the left by a nonzero element of a normed division ring tends to infinity at infinity. TODO: use `bornology.cobounded` instead of `filter.comap has_norm.norm filter.at_top`.",
    "type": "filter.tendsto (has_mul.mul a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)"
  },
  {
    "name": "ordered_comm_group.mul_lt_mul_left'",
    "statement": "theorem ordered_comm_group.mul_lt_mul_left' {α : Type u_1} [has_mul α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {b c : α} (bc : b < c) (a : α) : a * b < a * c",
    "theorem": "{α : Type u_1} [has_mul α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {b c : α} (bc : b < c) (a : α) : a * b < a * c",
    "args": "{α : Type u_1} [has_mul α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {b c : α} (bc : b < c) (a : α)",
    "doc_string": "**Alias** of mul_lt_mul_left'`.",
    "type": "a * b < a * c"
  },
  {
    "name": "le_refl",
    "statement": "theorem le_refl {α : Type u} [preorder α] (a : α) : a ≤ a",
    "theorem": "{α : Type u} [preorder α] (a : α) : a ≤ a",
    "args": "{α : Type u} [preorder α] (a : α)",
    "doc_string": "The relation `≤` on a preorder is reflexive.",
    "type": "a ≤ a"
  },
  {
    "name": "mul_lt_one",
    "statement": "theorem mul_lt_one {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1)",
    "doc_string": "**Alias** of left.mul_lt_one`.",
    "type": "a * b < 1"
  },
  {
    "name": "category_theory.simple_iff_subobject_is_simple_order",
    "statement": "theorem category_theory.simple_iff_subobject_is_simple_order {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) : category_theory.simple X ↔ is_simple_order (category_theory.subobject X)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) : category_theory.simple X ↔ is_simple_order (category_theory.subobject X)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C)",
    "doc_string": "`X` is simple iff it has subobject lattice `{⊥, ⊤}`.",
    "type": "category_theory.simple X ↔ is_simple_order (category_theory.subobject X)"
  },
  {
    "name": "set.monotone_image",
    "statement": "theorem set.monotone_image {α : Type u_1} {β : Type u_2} {f : α → β} : monotone (set.image f)",
    "theorem": "{α : Type u_1} {β : Type u_2} {f : α → β} : monotone (set.image f)",
    "args": "{α : Type u_1} {β : Type u_2} {f : α → β}",
    "doc_string": "`set.image` is monotone. See `set.image_image` for the statement in terms of `⊆`.",
    "type": "monotone (set.image f)"
  },
  {
    "name": "real.tendsto_exp_neg_at_top_nhds_0",
    "statement": "theorem real.tendsto_exp_neg_at_top_nhds_0  : filter.tendsto (λ (x : ℝ), real.exp (-x)) filter.at_top (nhds 0)",
    "theorem": " : filter.tendsto (λ (x : ℝ), real.exp (-x)) filter.at_top (nhds 0)",
    "args": "",
    "doc_string": " The real exponential function tends to `0` at `-∞` or, equivalently, `exp(-x)` tends to `0` at `+∞`",
    "type": "filter.tendsto (λ (x : ℝ), real.exp (-x)) filter.at_top (nhds 0)"
  },
  {
    "name": "eq.ge",
    "statement": "theorem eq.ge {α : Type u} [preorder α] {x y : α} (h : x = y) : y ≤ x",
    "theorem": "{α : Type u} [preorder α] {x y : α} (h : x = y) : y ≤ x",
    "args": "{α : Type u} [preorder α] {x y : α} (h : x = y)",
    "doc_string": " If `x = y` then `y ≤ x`. Note: this lemma uses `y ≤ x` instead of `x ≥ y`, because `le` is used almost exclusively in mathlib.",
    "type": "y ≤ x"
  },
  {
    "name": "balanced.absorbs_self",
    "statement": "theorem balanced.absorbs_self {𝕜 : Type u_1} {E : Type u_3} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] {A : set E} (hA : balanced 𝕜 A) : absorbs 𝕜 A A",
    "theorem": "{𝕜 : Type u_1} {E : Type u_3} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] {A : set E} (hA : balanced 𝕜 A) : absorbs 𝕜 A A",
    "args": "{𝕜 : Type u_1} {E : Type u_3} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] {A : set E} (hA : balanced 𝕜 A)",
    "doc_string": "A balanced set absorbs itself.",
    "type": "absorbs 𝕜 A A"
  },
  {
    "name": "function.bijective.exists_unique",
    "statement": "theorem function.bijective.exists_unique {α : Sort u_1} {β : Sort u_2} {f : α → β} (hf : function.bijective f) (b : β) : ∃! (a : α), f a = b",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {f : α → β} (hf : function.bijective f) (b : β) : ∃! (a : α), f a = b",
    "args": "{α : Sort u_1} {β : Sort u_2} {f : α → β} (hf : function.bijective f) (b : β)",
    "doc_string": "Shorthand for using projection notation with `function.bijective_iff_exists_unique`.",
    "type": "∃! (a : α), f a = b"
  },
  {
    "name": "eq.le",
    "statement": "theorem eq.le {α : Type u} [preorder α] {a b : α} : a = b → a ≤ b",
    "theorem": "{α : Type u} [preorder α] {a b : α} : a = b → a ≤ b",
    "args": "{α : Type u} [preorder α] {a b : α}",
    "doc_string": "**Alias** of le_of_eq`.",
    "type": "a = b → a ≤ b"
  },
  {
    "name": "pythagorean_triple.mul",
    "statement": "theorem pythagorean_triple.mul {x y z : ℤ} (h : pythagorean_triple x y z) (k : ℤ) : pythagorean_triple (k * x) (k * y) (k * z)",
    "theorem": "{x y z : ℤ} (h : pythagorean_triple x y z) (k : ℤ) : pythagorean_triple (k * x) (k * y) (k * z)",
    "args": "{x y z : ℤ} (h : pythagorean_triple x y z) (k : ℤ)",
    "doc_string": " A triple is still a triple if you multiply `x`, `y` and `z` by a constant `k`.",
    "type": "pythagorean_triple (k * x) (k * y) (k * z)"
  },
  {
    "name": "le_csupr",
    "statement": "theorem le_csupr {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_above (set.range f)) (c : ι) : f c ≤ supr f",
    "theorem": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_above (set.range f)) (c : ι) : f c ≤ supr f",
    "args": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_above (set.range f)) (c : ι)",
    "doc_string": "The indexed supremum of a function is bounded below by the value taken at one point",
    "type": "f c ≤ supr f"
  },
  {
    "name": "is_max.succ_eq",
    "statement": "theorem is_max.succ_eq {α : Type u_1} [partial_order α] [succ_order α] {a : α} : is_max a → order.succ a = a",
    "theorem": "{α : Type u_1} [partial_order α] [succ_order α] {a : α} : is_max a → order.succ a = a",
    "args": "{α : Type u_1} [partial_order α] [succ_order α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of order.succ_eq_iff_is_max`.",
    "type": "is_max a → order.succ a = a"
  },
  {
    "name": "finite_field.is_square_iff",
    "statement": "theorem finite_field.is_square_iff {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) {a : F} (ha : a ≠ 0) : is_square a ↔ a ^ (fintype.card F / 2) = 1",
    "theorem": "{F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) {a : F} (ha : a ≠ 0) : is_square a ↔ a ^ (fintype.card F / 2) = 1",
    "args": "{F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) {a : F} (ha : a ≠ 0)",
    "doc_string": "A non-zero `a : F` is a square if and only if `a ^ (#F / 2) = 1`.",
    "type": "is_square a ↔ a ^ (fintype.card F / 2) = 1"
  },
  {
    "name": "witt_polynomial_zmod_self",
    "statement": "theorem witt_polynomial_zmod_self (p n : ℕ) : witt_polynomial p (zmod (p ^ (n + 1))) (n + 1) = ⇑(mv_polynomial.expand p) (witt_polynomial p (zmod (p ^ (n + 1))) n)",
    "theorem": "(p n : ℕ) : witt_polynomial p (zmod (p ^ (n + 1))) (n + 1) = ⇑(mv_polynomial.expand p) (witt_polynomial p (zmod (p ^ (n + 1))) n)",
    "args": "(p n : ℕ)",
    "doc_string": "Over the ring `zmod (p^(n+1))`, we produce the `n+1`st Witt polynomial by expanding the `n`th Witt polynomial by `p`.",
    "type": "witt_polynomial p (zmod (p ^ (n + 1))) (n + 1) = ⇑(mv_polynomial.expand p) (witt_polynomial p (zmod (p ^ (n + 1))) n)"
  },
  {
    "name": "char.quadratic_char_neg_one",
    "statement": "theorem char.quadratic_char_neg_one {F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2) : char.quadratic_char F (-1) = ⇑zmod.χ₄ ↑(fintype.card F)",
    "theorem": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2) : char.quadratic_char F (-1) = ⇑zmod.χ₄ ↑(fintype.card F)",
    "args": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2)",
    "doc_string": "The value of the quadratic character at `-1`",
    "type": "char.quadratic_char F (-1) = ⇑zmod.χ₄ ↑(fintype.card F)"
  },
  {
    "name": "category_theory.abelian.pseudoelement.pseudo_zero_iff",
    "statement": "theorem category_theory.abelian.pseudoelement.pseudo_zero_iff {C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : ↑a = 0 ↔ a.hom = 0",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : ↑a = 0 ↔ a.hom = 0",
    "args": "{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P)",
    "doc_string": "The pseudoelement induced by an arrow is zero precisely when that arrow is zero",
    "type": "↑a = 0 ↔ a.hom = 0"
  },
  {
    "name": "and_or_distrib_left",
    "statement": "theorem and_or_distrib_left {a b c : Prop} : a ∧ (b ∨ c) ↔ a ∧ b ∨ a ∧ c",
    "theorem": "{a b c : Prop} : a ∧ (b ∨ c) ↔ a ∧ b ∨ a ∧ c",
    "args": "{a b c : Prop}",
    "doc_string": "`∧` distributes over `∨` (on the left).",
    "type": "a ∧ (b ∨ c) ↔ a ∧ b ∨ a ∧ c"
  },
  {
    "name": "set.antitone_bforall",
    "statement": "theorem set.antitone_bforall {α : Type u_1} {P : α → Prop} : antitone (λ (s : set α), ∀ (x : α), x ∈ s → P x)",
    "theorem": "{α : Type u_1} {P : α → Prop} : antitone (λ (s : set α), ∀ (x : α), x ∈ s → P x)",
    "args": "{α : Type u_1} {P : α → Prop}",
    "doc_string": "Quantifying over a set is antitone in the set",
    "type": "antitone (λ (s : set α), ∀ (x : α), x ∈ s → P x)"
  },
  {
    "name": "has_lt.lt.trans'",
    "statement": "theorem has_lt.lt.trans' {α : Type u} [preorder α] {a b c : α} : b < c → a < b → a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : b < c → a < b → a < c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of lt_trans'`.",
    "type": "b < c → a < b → a < c"
  },
  {
    "name": "or_and_distrib_right",
    "statement": "theorem or_and_distrib_right {a b c : Prop} : (a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c",
    "theorem": "{a b c : Prop} : (a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c",
    "args": "{a b c : Prop}",
    "doc_string": "`∧` distributes over `∨` (on the right).",
    "type": "(a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c"
  },
  {
    "name": "group.normal_closure.is_normal",
    "statement": "theorem group.normal_closure.is_normal {G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s)",
    "theorem": "{G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s)",
    "args": "{G : Type u_1} {s : set G} [group G]",
    "doc_string": "The normal closure of s is a normal subgroup.",
    "type": "is_normal_subgroup (group.normal_closure s)"
  },
  {
    "name": "cont_diff_id",
    "statement": "theorem cont_diff_id {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {n : with_top ℕ} : cont_diff 𝕜 n id",
    "theorem": "{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {n : with_top ℕ} : cont_diff 𝕜 n id",
    "args": "{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {n : with_top ℕ}",
    "doc_string": "The identity is `C^∞`.",
    "type": "cont_diff 𝕜 n id"
  },
  {
    "name": "sub_right_lt_of_lt_add",
    "statement": "theorem sub_right_lt_of_lt_add {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a < b + c → a - c < b",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a < b + c → a - c < b",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of sub_lt_iff_lt_add`.",
    "type": "a < b + c → a - c < b"
  },
  {
    "name": "le_trans",
    "statement": "theorem le_trans {α : Type u} [preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "The relation `≤` on a preorder is transitive.",
    "type": "a ≤ b → b ≤ c → a ≤ c"
  },
  {
    "name": "continuous_map.continuous_curry",
    "statement": "theorem continuous_map.continuous_curry {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space (α × β)] : continuous continuous_map.curry",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space (α × β)] : continuous continuous_map.curry",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space (α × β)]",
    "doc_string": "The currying process is a continuous map between function spaces.",
    "type": "continuous continuous_map.curry"
  },
  {
    "name": "zero_lt.right.mul_le_one_of_le_of_le",
    "statement": "theorem zero_lt.right.mul_le_one_of_le_of_le {α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b ≤ 1",
    "theorem": "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b ≤ 1",
    "args": "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "type": "a * b ≤ 1"
  },
  {
    "name": "bdd_above.inter_of_right",
    "statement": "theorem bdd_above.inter_of_right {α : Type u} [preorder α] {s t : set α} (h : bdd_above t) : bdd_above (s ∩ t)",
    "theorem": "{α : Type u} [preorder α] {s t : set α} (h : bdd_above t) : bdd_above (s ∩ t)",
    "args": "{α : Type u} [preorder α] {s t : set α} (h : bdd_above t)",
    "doc_string": "If `t` is bounded, then so is `s ∩ t`",
    "type": "bdd_above (s ∩ t)"
  },
  {
    "name": "is_preconnected.closure",
    "statement": "theorem is_preconnected.closure {α : Type u} [topological_space α] {s : set α} (H : is_preconnected s) : is_preconnected (closure s)",
    "theorem": "{α : Type u} [topological_space α] {s : set α} (H : is_preconnected s) : is_preconnected (closure s)",
    "args": "{α : Type u} [topological_space α] {s : set α} (H : is_preconnected s)",
    "doc_string": "The closure of a (pre)connected set is (pre)connected as well.",
    "type": "is_preconnected (closure s)"
  },
  {
    "name": "polynomial.X_pow_sub_one_separable_iff",
    "statement": "theorem polynomial.X_pow_sub_one_separable_iff {F : Type u} [field F] {n : ℕ} : (polynomial.X ^ n - 1).separable ↔ ↑n ≠ 0",
    "theorem": "{F : Type u} [field F] {n : ℕ} : (polynomial.X ^ n - 1).separable ↔ ↑n ≠ 0",
    "args": "{F : Type u} [field F] {n : ℕ}",
    "doc_string": "In a field `F`, `X ^ n - 1` is separable iff `↑n ≠ 0`.",
    "type": "(polynomial.X ^ n - 1).separable ↔ ↑n ≠ 0"
  },
  {
    "name": "has_le.le.antisymm",
    "statement": "theorem has_le.le.antisymm {α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≤ a → a = b",
    "theorem": "{α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≤ a → a = b",
    "args": "{α : Type u} [partial_order α] {a b : α}",
    "doc_string": "**Alias** of le_antisymm`.",
    "type": "a ≤ b → b ≤ a → a = b"
  },
  {
    "name": "dense_embedding_pure",
    "statement": "theorem dense_embedding_pure {α : Type u} : dense_embedding has_pure.pure",
    "theorem": "{α : Type u} : dense_embedding has_pure.pure",
    "args": "{α : Type u}",
    "doc_string": "`pure : α → ultrafilter α` defines a dense embedding of `α` in `ultrafilter α`.",
    "type": "dense_embedding has_pure.pure"
  },
  {
    "name": "finset.sum_centroid_weights_eq_one_of_cast_card_ne_zero",
    "statement": "theorem finset.sum_centroid_weights_eq_one_of_cast_card_ne_zero {k : Type u_1} [division_ring k] {ι : Type u_4} (s : finset ι) (h : ↑(s.card) ≠ 0) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1",
    "theorem": "{k : Type u_1} [division_ring k] {ι : Type u_4} (s : finset ι) (h : ↑(s.card) ≠ 0) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1",
    "args": "{k : Type u_1} [division_ring k] {ι : Type u_4} (s : finset ι) (h : ↑(s.card) ≠ 0)",
    "doc_string": " The weights in the centroid sum to 1, if the number of points, converted to `k`, is not zero.",
    "type": "s.sum (λ (i : ι), finset.centroid_weights k s i) = 1"
  },
  {
    "name": "has_lt.lt.not_le",
    "statement": "theorem has_lt.lt.not_le {α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b ≤ a",
    "theorem": "{α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b ≤ a",
    "args": "{α : Type u} [preorder α] {a b : α} (h : a < b)",
    "doc_string": "**Alias** of not_le_of_lt`.",
    "type": "¬b ≤ a"
  },
  {
    "name": "add_units.is_add_unit_add_units_add",
    "statement": "theorem add_units.is_add_unit_add_units_add {M : Type u_1} [add_monoid M] (u : add_units M) (a : M) : is_add_unit (↑u + a) ↔ is_add_unit a",
    "theorem": "{M : Type u_1} [add_monoid M] (u : add_units M) (a : M) : is_add_unit (↑u + a) ↔ is_add_unit a",
    "args": "{M : Type u_1} [add_monoid M] (u : add_units M) (a : M)",
    "doc_string": "Addition of a `u : add_units M` on the left doesn't affect `is_add_unit`.",
    "type": "is_add_unit (↑u + a) ↔ is_add_unit a"
  },
  {
    "name": "right.add_neg_of_neg_of_nonpos",
    "statement": "theorem right.add_neg_of_neg_of_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b ≤ 0)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_neg_of_neg_of_nonpos`.",
    "type": "a + b < 0"
  },
  {
    "name": "is_regular_mul_iff",
    "statement": "theorem is_regular_mul_iff {R : Type u_1} {a b : R} [comm_semigroup R] : is_regular (a * b) ↔ is_regular a ∧ is_regular b",
    "theorem": "{R : Type u_1} {a b : R} [comm_semigroup R] : is_regular (a * b) ↔ is_regular a ∧ is_regular b",
    "args": "{R : Type u_1} {a b : R} [comm_semigroup R]",
    "doc_string": "A product is regular if and only if the factors are.",
    "type": "is_regular (a * b) ↔ is_regular a ∧ is_regular b"
  },
  {
    "name": "imp_forall_iff",
    "statement": "theorem imp_forall_iff {α : Type u_1} {p : Prop} {q : α → Prop} : p → ∀ (x : α), q x ↔ ∀ (x : α), p → q x",
    "theorem": "{α : Type u_1} {p : Prop} {q : α → Prop} : p → ∀ (x : α), q x ↔ ∀ (x : α), p → q x",
    "args": "{α : Type u_1} {p : Prop} {q : α → Prop}",
    "doc_string": " We intentionally restrict the type of `α` in this lemma so that this is a safer to use in simp than `forall_swap`.",
    "type": "p → ∀ (x : α), q x ↔ ∀ (x : α), p → q x"
  },
  {
    "name": "closure_Ico",
    "statement": "theorem closure_Ico {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ico a b) = set.Icc a b",
    "theorem": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ico a b) = set.Icc a b",
    "args": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b)",
    "doc_string": "The closure of the interval `[a, b)` is the closed interval `[a, b]`.",
    "type": "closure (set.Ico a b) = set.Icc a b"
  },
  {
    "name": "is_closed_frontier",
    "statement": "theorem is_closed_frontier {α : Type u} [topological_space α] {s : set α} : is_closed (frontier s)",
    "theorem": "{α : Type u} [topological_space α] {s : set α} : is_closed (frontier s)",
    "args": "{α : Type u} [topological_space α] {s : set α}",
    "doc_string": "The frontier of a set is closed.",
    "type": "is_closed (frontier s)"
  },
  {
    "name": "dite_eq_ite",
    "statement": "theorem dite_eq_ite {α : Sort u_1} (P : Prop) [decidable P] (a b : α) : dite P (λ (h : P), a) (λ (h : ¬P), b) = ite P a b",
    "theorem": "{α : Sort u_1} (P : Prop) [decidable P] (a b : α) : dite P (λ (h : P), a) (λ (h : ¬P), b) = ite P a b",
    "args": "{α : Sort u_1} (P : Prop) [decidable P] (a b : α)",
    "doc_string": "A `dite` whose results do not actually depend on the condition may be reduced to an `ite`.",
    "type": "dite P (λ (h : P), a) (λ (h : ¬P), b) = ite P a b"
  },
  {
    "name": "function.commute.left_bij_on_fixed_pts_comp",
    "statement": "theorem function.commute.left_bij_on_fixed_pts_comp {α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on f (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))",
    "theorem": "{α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on f (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))",
    "args": "{α : Type u} {f g : α → α} (h : function.commute f g)",
    "doc_string": " If self-maps `f` and `g` commute, then `f` is bijective on the set of fixed points of `f ∘ g`. This is a particular case of `function.bij_on_fixed_pts_comp`.",
    "type": "set.bij_on f (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))"
  },
  {
    "name": "is_max_filter.undual",
    "statement": "theorem is_max_filter.undual {α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_max_filter (⇑order_dual.to_dual ∘ f) l a → is_min_filter f l a",
    "theorem": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_max_filter (⇑order_dual.to_dual ∘ f) l a → is_min_filter f l a",
    "args": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α}",
    "doc_string": "**Alias** of the forward direction of is_max_filter_dual_iff`.",
    "type": "is_max_filter (⇑order_dual.to_dual ∘ f) l a → is_min_filter f l a"
  },
  {
    "name": "left.mul_lt_one",
    "statement": "theorem left.mul_lt_one {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.mul_lt_one`.",
    "type": "a * b < 1"
  },
  {
    "name": "con.pow",
    "statement": "theorem con.pow {M : Type u_1} [monoid M] (c : con M) (n : ℕ) {w x : M} : ⇑c w x → ⇑c (w ^ n) (x ^ n)",
    "theorem": "{M : Type u_1} [monoid M] (c : con M) (n : ℕ) {w x : M} : ⇑c w x → ⇑c (w ^ n) (x ^ n)",
    "args": "{M : Type u_1} [monoid M] (c : con M) (n : ℕ) {w x : M}",
    "doc_string": "Multiplicative congruence relations preserve natural powers.",
    "type": "⇑c w x → ⇑c (w ^ n) (x ^ n)"
  },
  {
    "name": "finsupp.single_left_injective",
    "statement": "theorem finsupp.single_left_injective {α : Type u_1} {M : Type u_5} [has_zero M] {b : M} (h : b ≠ 0) : function.injective (λ (a : α), finsupp.single a b)",
    "theorem": "{α : Type u_1} {M : Type u_5} [has_zero M] {b : M} (h : b ≠ 0) : function.injective (λ (a : α), finsupp.single a b)",
    "args": "{α : Type u_1} {M : Type u_5} [has_zero M] {b : M} (h : b ≠ 0)",
    "doc_string": " `finsupp.single a b` is injective in `a`. For the statement that it is injective in `b`, see `finsupp.single_injective`",
    "type": "function.injective (λ (a : α), finsupp.single a b)"
  },
  {
    "name": "valuation.ext_iff",
    "statement": "theorem valuation.ext_iff {R : Type u_2} {Γ₀ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Γ₀] {v₁ v₂ : valuation R Γ₀} : v₁ = v₂ ↔ ∀ (r : R), ⇑v₁ r = ⇑v₂ r",
    "theorem": "{R : Type u_2} {Γ₀ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Γ₀] {v₁ v₂ : valuation R Γ₀} : v₁ = v₂ ↔ ∀ (r : R), ⇑v₁ r = ⇑v₂ r",
    "args": "{R : Type u_2} {Γ₀ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Γ₀] {v₁ v₂ : valuation R Γ₀}",
    "doc_string": "Deprecated. Use `fun_like.ext_iff`.",
    "type": "v₁ = v₂ ↔ ∀ (r : R), ⇑v₁ r = ⇑v₂ r"
  },
  {
    "name": "add_nonpos",
    "statement": "theorem add_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0)",
    "doc_string": "**Alias** of `left.add_nonpos`.",
    "type": "a + b ≤ 0"
  },
  {
    "name": "same_ray.of_neg",
    "statement": "theorem same_ray.of_neg {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) → same_ray R x y",
    "theorem": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) → same_ray R x y",
    "args": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M}",
    "doc_string": "**Alias** of the forward direction of same_ray_neg_iff`.",
    "type": "same_ray R (-x) (-y) → same_ray R x y"
  },
  {
    "name": "or_and_distrib_left",
    "statement": "theorem or_and_distrib_left {a b c : Prop} : a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c)",
    "theorem": "{a b c : Prop} : a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c)",
    "args": "{a b c : Prop}",
    "doc_string": "`∨` distributes over `∧` (on the left).",
    "type": "a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c)"
  },
  {
    "name": "mul_lt_one'",
    "statement": "theorem mul_lt_one' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1)",
    "doc_string": "**Alias** of left.mul_lt_one'`.",
    "type": "a * b < 1"
  },
  {
    "name": "has_lt.lt.asymm",
    "statement": "theorem has_lt.lt.asymm {α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b < a",
    "theorem": "{α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b < a",
    "args": "{α : Type u} [preorder α] {a b : α} (h : a < b)",
    "doc_string": "**Alias** of lt_asymm`.",
    "type": "¬b < a"
  },
  {
    "name": "add_commute.is_of_fin_order_add",
    "statement": "theorem add_commute.is_of_fin_order_add {G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)",
    "theorem": "{G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)",
    "args": "{G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y)",
    "doc_string": "Commuting elements of finite additive order are closed under addition.",
    "type": "is_of_fin_add_order (x + y)"
  },
  {
    "name": "has_dvd.dvd.pow",
    "statement": "theorem has_dvd.dvd.pow {M : Type u} [monoid M] {x y : M} (hxy : x ∣ y) {n : ℕ} (hn : n ≠ 0) : x ∣ y ^ n",
    "theorem": "{M : Type u} [monoid M] {x y : M} (hxy : x ∣ y) {n : ℕ} (hn : n ≠ 0) : x ∣ y ^ n",
    "args": "{M : Type u} [monoid M] {x y : M} (hxy : x ∣ y) {n : ℕ} (hn : n ≠ 0)",
    "doc_string": "**Alias** of dvd_pow`.",
    "type": "x ∣ y ^ n"
  },
  {
    "name": "metric.inf_dist_le_inf_dist_add_dist",
    "statement": "theorem metric.inf_dist_le_inf_dist_add_dist {α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} : metric.inf_dist x s ≤ metric.inf_dist y s + has_dist.dist x y",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} : metric.inf_dist x s ≤ metric.inf_dist y s + has_dist.dist x y",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α} {x y : α}",
    "doc_string": " The minimal distance from `x` to `s` is bounded by the distance from `y` to `s`, modulo the distance between `x` and `y`",
    "type": "metric.inf_dist x s ≤ metric.inf_dist y s + has_dist.dist x y"
  },
  {
    "name": "is_smul_regular.of_mul_eq_one",
    "statement": "theorem is_smul_regular.of_mul_eq_one {R : Type u_1} {M : Type u_3} {a b : R} [monoid R] [mul_action R M] (h : a * b = 1) : is_smul_regular M b",
    "theorem": "{R : Type u_1} {M : Type u_3} {a b : R} [monoid R] [mul_action R M] (h : a * b = 1) : is_smul_regular M b",
    "args": "{R : Type u_1} {M : Type u_3} {a b : R} [monoid R] [mul_action R M] (h : a * b = 1)",
    "doc_string": "An element of `R` admitting a left inverse is `M`-regular.",
    "type": "is_smul_regular M b"
  },
  {
    "name": "is_noetherian.iff_fg",
    "statement": "theorem is_noetherian.iff_fg {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ↔ module.finite K V",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ↔ module.finite K V",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V]",
    "doc_string": "A module over a division ring is noetherian if and only if it is finitely generated.",
    "type": "is_noetherian K V ↔ module.finite K V"
  },
  {
    "name": "has_le.le.lt_of_ne",
    "statement": "theorem has_le.le.lt_of_ne {α : Type u} [partial_order α] {a b : α} : a ≤ b → a ≠ b → a < b",
    "theorem": "{α : Type u} [partial_order α] {a b : α} : a ≤ b → a ≠ b → a < b",
    "args": "{α : Type u} [partial_order α] {a b : α}",
    "doc_string": "**Alias** of lt_of_le_of_ne`.",
    "type": "a ≤ b → a ≠ b → a < b"
  },
  {
    "name": "mul_ne_zero_comm",
    "statement": "theorem mul_ne_zero_comm {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b ≠ 0 ↔ b * a ≠ 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b ≠ 0 ↔ b * a ≠ 0",
    "args": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀}",
    "doc_string": " If `α` has no zero divisors, then for elements `a, b : α`, `a * b` is nonzero iff so is `b * a`.",
    "type": "a * b ≠ 0 ↔ b * a ≠ 0"
  },
  {
    "name": "right.add_pos_of_nonneg_of_pos",
    "statement": "theorem right.add_pos_of_nonneg_of_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 < b)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_pos_of_nonneg_of_pos`.",
    "type": "0 < a + b"
  },
  {
    "name": "le_add_of_sub_left_le",
    "statement": "theorem le_add_of_sub_left_le {α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a - b ≤ c → a ≤ b + c",
    "theorem": "{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a - b ≤ c → a ≤ b + c",
    "args": "{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of sub_le_iff_le_add'`.",
    "type": "a - b ≤ c → a ≤ b + c"
  },
  {
    "name": "metric.Hausdorff_dist_self_zero",
    "statement": "theorem metric.Hausdorff_dist_self_zero {α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s s = 0",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s s = 0",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α}",
    "doc_string": "The Hausdorff distance between a set and itself is zero",
    "type": "metric.Hausdorff_dist s s = 0"
  },
  {
    "name": "not_bdd_above_iff",
    "statement": "theorem not_bdd_above_iff {α : Type u_1} [linear_order α] {s : set α} : ¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), x < y",
    "theorem": "{α : Type u_1} [linear_order α] {s : set α} : ¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), x < y",
    "args": "{α : Type u_1} [linear_order α] {s : set α}",
    "doc_string": " A set `s` is not bounded above if and only if for each `x` there exists `y ∈ s` that is greater than `x`. A version for preorders is called `not_bdd_above_iff'`.",
    "type": "¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), x < y"
  },
  {
    "name": "matrix.inv_eq_right_inv",
    "statement": "theorem matrix.inv_eq_right_inv {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : A.mul B = 1) : A⁻¹ = B",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : A.mul B = 1) : A⁻¹ = B",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : A.mul B = 1)",
    "doc_string": "If matrix A is right invertible, then its inverse equals its right inverse.",
    "type": "A⁻¹ = B"
  },
  {
    "name": "Compactum_to_CompHaus.ess_surj",
    "statement": "theorem Compactum_to_CompHaus.ess_surj  : category_theory.ess_surj Compactum_to_CompHaus",
    "theorem": " : category_theory.ess_surj Compactum_to_CompHaus",
    "args": "",
    "doc_string": "The functor Compactum_to_CompHaus is essentially surjective.",
    "type": "category_theory.ess_surj Compactum_to_CompHaus"
  },
  {
    "name": "con.coe_one",
    "statement": "theorem con.coe_one {M : Type u_1} [mul_one_class M] {c : con M} : ↑1 = 1",
    "theorem": "{M : Type u_1} [mul_one_class M] {c : con M} : ↑1 = 1",
    "args": "{M : Type u_1} [mul_one_class M] {c : con M}",
    "doc_string": "The 1 of the quotient of a monoid by a congruence relation is the equivalence class of the    monoid's 1.",
    "type": "↑1 = 1"
  },
  {
    "name": "is_regular.subsingleton",
    "statement": "theorem is_regular.subsingleton {R : Type u_1} [mul_zero_class R] (h : is_regular 0) : subsingleton R",
    "theorem": "{R : Type u_1} [mul_zero_class R] (h : is_regular 0) : subsingleton R",
    "args": "{R : Type u_1} [mul_zero_class R] (h : is_regular 0)",
    "doc_string": "The element `0` is regular if and only if `R` is trivial.",
    "type": "subsingleton R"
  },
  {
    "name": "inv_lt_one'",
    "statement": "theorem inv_lt_one' {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α}",
    "doc_string": "**Alias** of left.inv_lt_one_iff`.",
    "type": "a⁻¹ < 1 ↔ 1 < a"
  },
  {
    "name": "mul_lt_one_of_lt_of_le",
    "statement": "theorem mul_lt_one_of_lt_of_le {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1)",
    "doc_string": "**Alias** of left.mul_lt_one_of_lt_of_le`.",
    "type": "a * b < 1"
  },
  {
    "name": "well_founded.cut_expand",
    "statement": "theorem well_founded.cut_expand {α : Type u_1} {r : α → α → Prop} (hr : well_founded r) : well_founded (relation.cut_expand r)",
    "theorem": "{α : Type u_1} {r : α → α → Prop} (hr : well_founded r) : well_founded (relation.cut_expand r)",
    "args": "{α : Type u_1} {r : α → α → Prop} (hr : well_founded r)",
    "doc_string": "`cut_expand r` is well-founded when `r` is.",
    "type": "well_founded (relation.cut_expand r)"
  },
  {
    "name": "is_group_hom.injective_iff",
    "statement": "theorem is_group_hom.injective_iff {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1",
    "theorem": "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1",
    "args": "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f)",
    "doc_string": "A group homomorphism is injective iff its kernel is trivial.",
    "type": "function.injective f ↔ ∀ (a : α), f a = 1 → a = 1"
  },
  {
    "name": "polynomial.root_multiplicity_X_sub_C_pow",
    "statement": "theorem polynomial.root_multiplicity_X_sub_C_pow {R : Type u} [comm_ring R] [is_domain R] (a : R) (n : ℕ) : polynomial.root_multiplicity a ((polynomial.X - ⇑polynomial.C a) ^ n) = n",
    "theorem": "{R : Type u} [comm_ring R] [is_domain R] (a : R) (n : ℕ) : polynomial.root_multiplicity a ((polynomial.X - ⇑polynomial.C a) ^ n) = n",
    "args": "{R : Type u} [comm_ring R] [is_domain R] (a : R) (n : ℕ)",
    "doc_string": "The multiplicity of `a` as root of `(X - a) ^ n` is `n`.",
    "type": "polynomial.root_multiplicity a ((polynomial.X - ⇑polynomial.C a) ^ n) = n"
  },
  {
    "name": "metric.Hausdorff_dist_empty",
    "statement": "theorem metric.Hausdorff_dist_empty {α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s ∅ = 0",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s ∅ = 0",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α}",
    "doc_string": " The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable value ∞ instead, use `Hausdorff_edist`, which takes values in ℝ≥0∞)",
    "type": "metric.Hausdorff_dist s ∅ = 0"
  },
  {
    "name": "one_div_le_one_div",
    "statement": "theorem one_div_le_one_div {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : 1 / a ≤ 1 / b ↔ b ≤ a",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : 1 / a ≤ 1 / b ↔ b ≤ a",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "For the single implications with fewer assumptions, see `one_div_le_one_div_of_le` and  `le_of_one_div_le_one_div`",
    "type": "1 / a ≤ 1 / b ↔ b ≤ a"
  },
  {
    "name": "finite_field.is_square_of_char_two",
    "statement": "theorem finite_field.is_square_of_char_two {F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a",
    "theorem": "{F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a",
    "args": "{F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F)",
    "doc_string": "In a finite field of characteristic `2`, all elements are squares.",
    "type": "is_square a"
  },
  {
    "name": "volume_set_of_liouville",
    "statement": "theorem volume_set_of_liouville  : ⇑measure_theory.measure_space.volume {x : ℝ | liouville x} = 0",
    "theorem": " : ⇑measure_theory.measure_space.volume {x : ℝ | liouville x} = 0",
    "args": "",
    "doc_string": "The set of Liouville numbers has Lebesgue measure zero.",
    "type": "⇑measure_theory.measure_space.volume {x : ℝ | liouville x} = 0"
  },
  {
    "name": "monoid.closure_subset",
    "statement": "theorem monoid.closure_subset {M : Type u_1} [monoid M] {s t : set M} (ht : is_submonoid t) (h : s ⊆ t) : monoid.closure s ⊆ t",
    "theorem": "{M : Type u_1} [monoid M] {s t : set M} (ht : is_submonoid t) (h : s ⊆ t) : monoid.closure s ⊆ t",
    "args": "{M : Type u_1} [monoid M] {s t : set M} (ht : is_submonoid t) (h : s ⊆ t)",
    "doc_string": "The submonoid generated by a set is contained in any submonoid that contains the set.",
    "type": "monoid.closure s ⊆ t"
  },
  {
    "name": "int.abs_le_self_pow_two",
    "statement": "theorem int.abs_le_self_pow_two (a : ℤ) : ↑(a.nat_abs) ≤ a ^ 2",
    "theorem": "(a : ℤ) : ↑(a.nat_abs) ≤ a ^ 2",
    "args": "(a : ℤ)",
    "doc_string": "**Alias** of int.abs_le_self_sq`.",
    "type": "↑(a.nat_abs) ≤ a ^ 2"
  },
  {
    "name": "list.length_pos_of_one_lt_prod",
    "statement": "theorem list.length_pos_of_one_lt_prod {M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod) : 0 < L.length",
    "theorem": "{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod) : 0 < L.length",
    "args": "{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod)",
    "doc_string": "A list with product greater than one must have positive length.",
    "type": "0 < L.length"
  },
  {
    "name": "mul_lt_one_of_le_of_lt",
    "statement": "theorem mul_lt_one_of_le_of_lt {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1)",
    "doc_string": "**Alias** of left.mul_lt_one_of_le_of_lt`.",
    "type": "a * b < 1"
  },
  {
    "name": "dvd_add_right",
    "statement": "theorem dvd_add_right {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c",
    "theorem": "{α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c",
    "args": "{α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b)",
    "doc_string": "If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c.",
    "type": "a ∣ b + c ↔ a ∣ c"
  },
  {
    "name": "is_mul_hom.to_is_monoid_hom",
    "statement": "theorem is_mul_hom.to_is_monoid_hom {α : Type u} {β : Type v} [mul_one_class α] [group β] {f : α → β} (hf : is_mul_hom f) : is_monoid_hom f",
    "theorem": "{α : Type u} {β : Type v} [mul_one_class α] [group β] {f : α → β} (hf : is_mul_hom f) : is_monoid_hom f",
    "args": "{α : Type u} {β : Type v} [mul_one_class α] [group β] {f : α → β} (hf : is_mul_hom f)",
    "doc_string": "A map to a group preserving multiplication is a monoid homomorphism.",
    "type": "is_monoid_hom f"
  },
  {
    "name": "neg_add_lt_of_lt_add",
    "statement": "theorem neg_add_lt_of_lt_add {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a < b + c → -b + a < c",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a < b + c → -b + a < c",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of inv_mul_lt_iff_lt_mul`.",
    "type": "a < b + c → -b + a < c"
  },
  {
    "name": "topological_space.dense_range_dense_seq",
    "statement": "theorem topological_space.dense_range_dense_seq (α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : dense_range (topological_space.dense_seq α)",
    "theorem": "(α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : dense_range (topological_space.dense_seq α)",
    "args": "(α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α]",
    "doc_string": "The sequence `dense_seq α` has dense range.",
    "type": "dense_range (topological_space.dense_seq α)"
  },
  {
    "name": "metric.lipschitz_inf_nndist_pt",
    "statement": "theorem metric.lipschitz_inf_nndist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : lipschitz_with 1 (λ (x : α), metric.inf_nndist x s)",
    "theorem": "{α : Type u} [pseudo_metric_space α] (s : set α) : lipschitz_with 1 (λ (x : α), metric.inf_nndist x s)",
    "args": "{α : Type u} [pseudo_metric_space α] (s : set α)",
    "doc_string": "The minimal distance to a set (as `ℝ≥0`) is Lipschitz in point with constant 1",
    "type": "lipschitz_with 1 (λ (x : α), metric.inf_nndist x s)"
  },
  {
    "name": "list.length_pos_of_prod_ne_one",
    "statement": "theorem list.length_pos_of_prod_ne_one {M : Type u_3} [monoid M] (L : list M) (h : L.prod ≠ 1) : 0 < L.length",
    "theorem": "{M : Type u_3} [monoid M] (L : list M) (h : L.prod ≠ 1) : 0 < L.length",
    "args": "{M : Type u_3} [monoid M] (L : list M) (h : L.prod ≠ 1)",
    "doc_string": "A list with product not one must have positive length.",
    "type": "0 < L.length"
  },
  {
    "name": "compact_t2_tot_disc_iff_tot_sep",
    "statement": "theorem compact_t2_tot_disc_iff_tot_sep {α : Type u} [topological_space α] [t2_space α] [compact_space α] : totally_disconnected_space α ↔ totally_separated_space α",
    "theorem": "{α : Type u} [topological_space α] [t2_space α] [compact_space α] : totally_disconnected_space α ↔ totally_separated_space α",
    "args": "{α : Type u} [topological_space α] [t2_space α] [compact_space α]",
    "doc_string": "A compact Hausdorff space is totally disconnected if and only if it is totally separated, this  is also true for locally compact spaces.",
    "type": "totally_disconnected_space α ↔ totally_separated_space α"
  },
  {
    "name": "nnreal.summable_of_le",
    "statement": "theorem nnreal.summable_of_le {β : Type u_2} {f g : β → nnreal} (hgf : ∀ (b : β), g b ≤ f b) : summable f → summable g",
    "theorem": "{β : Type u_2} {f g : β → nnreal} (hgf : ∀ (b : β), g b ≤ f b) : summable f → summable g",
    "args": "{β : Type u_2} {f g : β → nnreal} (hgf : ∀ (b : β), g b ≤ f b)",
    "doc_string": "Comparison test of convergence of `ℝ≥0`-valued series.",
    "type": "summable f → summable g"
  },
  {
    "name": "closure_operator.le_closure",
    "statement": "theorem closure_operator.le_closure {α : Type u_1} [partial_order α] (c : closure_operator α) (x : α) : x ≤ ⇑c x",
    "theorem": "{α : Type u_1} [partial_order α] (c : closure_operator α) (x : α) : x ≤ ⇑c x",
    "args": "{α : Type u_1} [partial_order α] (c : closure_operator α) (x : α)",
    "doc_string": " Every element is less than its closure. This property is sometimes referred to as extensivity or inflationarity.",
    "type": "x ≤ ⇑c x"
  },
  {
    "name": "function.injective.inj_on",
    "statement": "theorem function.injective.inj_on {α : Type u} {β : Type v} {f : α → β} (h : function.injective f) (s : set α) : set.inj_on f s",
    "theorem": "{α : Type u} {β : Type v} {f : α → β} (h : function.injective f) (s : set α) : set.inj_on f s",
    "args": "{α : Type u} {β : Type v} {f : α → β} (h : function.injective f) (s : set α)",
    "doc_string": "**Alias** of set.inj_on_of_injective`.",
    "type": "set.inj_on f s"
  },
  {
    "name": "matrix.det_transpose",
    "statement": "theorem matrix.det_transpose {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det",
    "theorem": "{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det",
    "args": "{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R)",
    "doc_string": "Transposing a matrix preserves the determinant.",
    "type": "M.transpose.det = M.det"
  },
  {
    "name": "inv_lt_inv",
    "statement": "theorem inv_lt_inv {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b⁻¹ ↔ b < a",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b⁻¹ ↔ b < a",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "See `inv_lt_inv_of_lt` for the implication from right-to-left with one fewer assumption.",
    "type": "a⁻¹ < b⁻¹ ↔ b < a"
  },
  {
    "name": "setoid.eqv_gen_mono",
    "statement": "theorem setoid.eqv_gen_mono {α : Type u_1} {r s : α → α → Prop} (h : ∀ (x y : α), r x y → s x y) : eqv_gen.setoid r ≤ eqv_gen.setoid s",
    "theorem": "{α : Type u_1} {r s : α → α → Prop} (h : ∀ (x y : α), r x y → s x y) : eqv_gen.setoid r ≤ eqv_gen.setoid s",
    "args": "{α : Type u_1} {r s : α → α → Prop} (h : ∀ (x y : α), r x y → s x y)",
    "doc_string": "Equivalence closure of binary relations is monotone.",
    "type": "eqv_gen.setoid r ≤ eqv_gen.setoid s"
  },
  {
    "name": "right.mul_lt_one_of_lt_of_le",
    "statement": "theorem right.mul_lt_one_of_lt_of_le {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b ≤ 1)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.mul_lt_one_of_lt_of_le`.",
    "type": "a * b < 1"
  },
  {
    "name": "nat.mul_div_mul_left",
    "statement": "theorem nat.mul_div_mul_left (a b : ℕ) {c : ℕ} (hc : 0 < c) : c * a / (c * b) = a / b",
    "theorem": "(a b : ℕ) {c : ℕ} (hc : 0 < c) : c * a / (c * b) = a / b",
    "args": "(a b : ℕ) {c : ℕ} (hc : 0 < c)",
    "doc_string": "Alias of `nat.mul_div_mul`",
    "type": "c * a / (c * b) = a / b"
  },
  {
    "name": "is_topological_fiber_bundle_fst",
    "statement": "theorem is_topological_fiber_bundle_fst {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.fst",
    "theorem": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.fst",
    "args": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F]",
    "doc_string": "The first projection in a product is a topological fiber bundle.",
    "type": "is_topological_fiber_bundle F prod.fst"
  },
  {
    "name": "module.nontrivial",
    "statement": "theorem module.nontrivial (R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M] : nontrivial R",
    "theorem": "(R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M] : nontrivial R",
    "args": "(R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M]",
    "doc_string": "A semiring is `nontrivial` provided that there exists a nontrivial module over this semiring.",
    "type": "nontrivial R"
  },
  {
    "name": "function.embedding.schroeder_bernstein",
    "statement": "theorem function.embedding.schroeder_bernstein {α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) : ∃ (h : α → β), function.bijective h",
    "theorem": "{α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) : ∃ (h : α → β), function.bijective h",
    "args": "{α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g)",
    "doc_string": " **The Schröder-Bernstein Theorem**: Given injections `α → β` and `β → α`, we can get a bijection `α → β`.",
    "type": "∃ (h : α → β), function.bijective h"
  },
  {
    "name": "right.mul_le_one",
    "statement": "theorem right.mul_le_one {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.mul_le_one`.",
    "type": "a * b ≤ 1"
  },
  {
    "name": "free_group.red.step.length",
    "statement": "theorem free_group.red.step.length {α : Type u} {L₁ L₂ : list (α × bool)} : free_group.red.step L₁ L₂ → L₂.length + 2 = L₁.length",
    "theorem": "{α : Type u} {L₁ L₂ : list (α × bool)} : free_group.red.step L₁ L₂ → L₂.length + 2 = L₁.length",
    "args": "{α : Type u} {L₁ L₂ : list (α × bool)}",
    "doc_string": " Predicate asserting that word `w₁` can be reduced to `w₂` in one step, i.e. there are words `w₃ w₄` and letter `x` such that `w₁ = w₃xx⁻¹w₄` and `w₂ = w₃w₄`",
    "type": "free_group.red.step L₁ L₂ → L₂.length + 2 = L₁.length"
  },
  {
    "name": "char.quadratic_char_dichotomy",
    "statement": "theorem char.quadratic_char_dichotomy {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a = 1 ∨ char.quadratic_char F a = -1",
    "theorem": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a = 1 ∨ char.quadratic_char F a = -1",
    "args": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0)",
    "doc_string": "The quadratic character is `1` or `-1` on nonzero arguments.",
    "type": "char.quadratic_char F a = 1 ∨ char.quadratic_char F a = -1"
  },
  {
    "name": "mul_is_left_regular_iff",
    "statement": "theorem mul_is_left_regular_iff {R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a) : is_left_regular (a * b) ↔ is_left_regular b",
    "theorem": "{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a) : is_left_regular (a * b) ↔ is_left_regular b",
    "args": "{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a)",
    "doc_string": "  An element is left-regular if and only if multiplying it on the left by a left-regular element is left-regular.",
    "type": "is_left_regular (a * b) ↔ is_left_regular b"
  },
  {
    "name": "le_inv_mul_of_mul_le",
    "statement": "theorem le_inv_mul_of_mul_le {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : a * b ≤ c → b ≤ a⁻¹ * c",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : a * b ≤ c → b ≤ a⁻¹ * c",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of le_inv_mul_iff_mul_le`.",
    "type": "a * b ≤ c → b ≤ a⁻¹ * c"
  },
  {
    "name": "nat.gcd_eq_gcd_ab",
    "statement": "theorem nat.gcd_eq_gcd_ab (x y : ℕ) : ↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y",
    "theorem": "(x y : ℕ) : ↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y",
    "args": "(x y : ℕ)",
    "doc_string": " **Bézout's lemma**: given `x y : ℕ`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and `b = gcd_b x y` are computed by the extended Euclidean algorithm.",
    "type": "↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y"
  },
  {
    "name": "ereal.neg_le_of_neg_le",
    "statement": "theorem ereal.neg_le_of_neg_le {a b : ereal} (h : -a ≤ b) : -b ≤ a",
    "theorem": "{a b : ereal} (h : -a ≤ b) : -b ≤ a",
    "args": "{a b : ereal} (h : -a ≤ b)",
    "doc_string": "if `-a ≤ b` then `-b ≤ a` on `ereal`.",
    "type": "-b ≤ a"
  },
  {
    "name": "is_seq_closed_iff_is_closed",
    "statement": "theorem is_seq_closed_iff_is_closed {X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s ↔ is_closed s",
    "theorem": "{X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s ↔ is_closed s",
    "args": "{X : Type u_1} [topological_space X] [sequential_space X] {s : set X}",
    "doc_string": "In a sequential space, a set is closed iff it's sequentially closed.",
    "type": "is_seq_closed s ↔ is_closed s"
  },
  {
    "name": "pow_four_add_four_mul_pow_four",
    "statement": "theorem pow_four_add_four_mul_pow_four {R : Type u_1} [comm_ring R] {a b : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)",
    "theorem": "{R : Type u_1} [comm_ring R] {a b : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)",
    "args": "{R : Type u_1} [comm_ring R] {a b : R}",
    "doc_string": "Sophie Germain's identity, see <https://www.cut-the-knot.org/blue/SophieGermainIdentity.shtml>.",
    "type": "a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)"
  },
  {
    "name": "zero_lt.left.one_lt_mul_of_le_of_lt",
    "statement": "theorem zero_lt.left.one_lt_mul_of_le_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 ≤ a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 ≤ a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 ≤ a) (hb : 1 < b) (a0 : 0 < a)",
    "doc_string": "Assumes left covariance.",
    "type": "1 < a * b"
  },
  {
    "name": "fin.nat_add_cast",
    "statement": "theorem fin.nat_add_cast {n n' : ℕ} (m : ℕ) (i : fin n') (h : n' = n) : ⇑(fin.nat_add m) (⇑(fin.cast h) i) = ⇑(fin.cast _) (⇑(fin.nat_add m) i)",
    "theorem": "{n n' : ℕ} (m : ℕ) (i : fin n') (h : n' = n) : ⇑(fin.nat_add m) (⇑(fin.cast h) i) = ⇑(fin.cast _) (⇑(fin.nat_add m) i)",
    "args": "{n n' : ℕ} (m : ℕ) (i : fin n') (h : n' = n)",
    "doc_string": "For rewriting in the reverse direction, see `fin.cast_nat_add_right`.",
    "type": "⇑(fin.nat_add m) (⇑(fin.cast h) i) = ⇑(fin.cast _) (⇑(fin.nat_add m) i)"
  },
  {
    "name": "measurable_of_tendsto_nnreal",
    "statement": "theorem measurable_of_tendsto_nnreal {α : Type u_1} [measurable_space α] {f : ℕ → α → nnreal} {g : α → nnreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g",
    "theorem": "{α : Type u_1} [measurable_space α] {f : ℕ → α → nnreal} {g : α → nnreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g",
    "args": "{α : Type u_1} [measurable_space α] {f : ℕ → α → nnreal} {g : α → nnreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g))",
    "doc_string": "A sequential limit of measurable `ℝ≥0` valued functions is measurable.",
    "type": "measurable g"
  },
  {
    "name": "zero_lt.left.one_lt_mul_of_lt_of_le",
    "statement": "theorem zero_lt.left.one_lt_mul_of_lt_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 < a) (hb : 1 ≤ b) (a0 : 0 < a) : 1 < a * b",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 < a) (hb : 1 ≤ b) (a0 : 0 < a) : 1 < a * b",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 < a) (hb : 1 ≤ b) (a0 : 0 < a)",
    "doc_string": "Assumes left covariance.",
    "type": "1 < a * b"
  },
  {
    "name": "function.surjective.comp_left",
    "statement": "theorem function.surjective.comp_left {α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.surjective g) : function.surjective (function.comp g)",
    "theorem": "{α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.surjective g) : function.surjective (function.comp g)",
    "args": "{α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.surjective g)",
    "doc_string": "Composition by an surjective function on the left is itself surjective.",
    "type": "function.surjective (function.comp g)"
  },
  {
    "name": "mul_ne_zero_iff",
    "statement": "theorem mul_ne_zero_iff {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0",
    "args": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀}",
    "doc_string": " If `α` has no zero divisors, then the product of two elements is nonzero iff both of them are nonzero.",
    "type": "a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0"
  },
  {
    "name": "left.mul_lt_one'",
    "statement": "theorem left.mul_lt_one' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.mul_lt_one'`.",
    "type": "a * b < 1"
  },
  {
    "name": "is_left_regular.of_mul",
    "statement": "theorem is_left_regular.of_mul {R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b)) : is_left_regular b",
    "theorem": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b)) : is_left_regular b",
    "args": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b))",
    "doc_string": "  If an element `b` becomes left-regular after multiplying it on the left by a left-regular element, then `b` is left-regular.",
    "type": "is_left_regular b"
  },
  {
    "name": "zero_lt.right.mul_lt_one_of_lt_of_lt",
    "statement": "theorem zero_lt.right.mul_lt_one_of_lt_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b < 1) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "type": "a * b < 1"
  },
  {
    "name": "metric.lipschitz_inf_dist_pt",
    "statement": "theorem metric.lipschitz_inf_dist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : lipschitz_with 1 (λ (x : α), metric.inf_dist x s)",
    "theorem": "{α : Type u} [pseudo_metric_space α] (s : set α) : lipschitz_with 1 (λ (x : α), metric.inf_dist x s)",
    "args": "{α : Type u} [pseudo_metric_space α] (s : set α)",
    "doc_string": "The minimal distance to a set is Lipschitz in point with constant 1",
    "type": "lipschitz_with 1 (λ (x : α), metric.inf_dist x s)"
  },
  {
    "name": "is_torsion_of_fintype",
    "statement": "theorem is_torsion_of_fintype {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G",
    "theorem": "{G : Type u_1} [group G] [fintype G] : monoid.is_torsion G",
    "args": "{G : Type u_1} [group G] [fintype G]",
    "doc_string": "Finite groups are torsion groups.",
    "type": "monoid.is_torsion G"
  },
  {
    "name": "infinite.nonempty_field",
    "statement": "theorem infinite.nonempty_field {α : Type u} [infinite α] : nonempty (field α)",
    "theorem": "{α : Type u} [infinite α] : nonempty (field α)",
    "args": "{α : Type u} [infinite α]",
    "doc_string": "Any infinite type can be endowed a field structure.",
    "type": "nonempty (field α)"
  },
  {
    "name": "inv_lt_one_iff_one_lt",
    "statement": "theorem inv_lt_one_iff_one_lt {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α}",
    "doc_string": "**Alias** of left.inv_lt_one_iff`.",
    "type": "a⁻¹ < 1 ↔ 1 < a"
  },
  {
    "name": "right.add_pos_of_pos_of_nonneg",
    "statement": "theorem right.add_pos_of_pos_of_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 ≤ b)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_pos_of_pos_of_nonneg`.",
    "type": "0 < a + b"
  },
  {
    "name": "has_lt.lt.trans_eq'",
    "statement": "theorem has_lt.lt.trans_eq' {α : Type u} [preorder α] {a b c : α} : b < c → a = b → a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : b < c → a = b → a < c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of lt_of_lt_of_eq'`.",
    "type": "b < c → a = b → a < c"
  },
  {
    "name": "function.is_fixed_pt.eq",
    "statement": "theorem function.is_fixed_pt.eq {α : Type u} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) : f x = x",
    "theorem": "{α : Type u} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) : f x = x",
    "args": "{α : Type u} {f : α → α} {x : α} (hf : function.is_fixed_pt f x)",
    "doc_string": "If `x` is a fixed point of `f`, then `f x = x`. This is useful, e.g., for `rw` or `simp`.",
    "type": "f x = x"
  },
  {
    "name": "inv_gold",
    "statement": "theorem inv_gold  : golden_ratio⁻¹ = -golden_conj",
    "theorem": " : golden_ratio⁻¹ = -golden_conj",
    "args": "",
    "doc_string": "The inverse of the golden ratio is the opposite of its conjugate.",
    "type": "golden_ratio⁻¹ = -golden_conj"
  },
  {
    "name": "mul_self_div_self",
    "statement": "theorem mul_self_div_self {G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a * a / a = a",
    "theorem": "{G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a * a / a = a",
    "args": "{G₀ : Type u_2} [group_with_zero G₀] (a : G₀)",
    "doc_string": " Multiplying `a` by itself and then dividing by itself results in `a` (whether or not `a` is zero).",
    "type": "a * a / a = a"
  },
  {
    "name": "irreducible.dvd_symm",
    "statement": "theorem irreducible.dvd_symm {α : Type u_1} [monoid α] {p q : α} (hp : irreducible p) (hq : irreducible q) : p ∣ q → q ∣ p",
    "theorem": "{α : Type u_1} [monoid α] {p q : α} (hp : irreducible p) (hq : irreducible q) : p ∣ q → q ∣ p",
    "args": "{α : Type u_1} [monoid α] {p q : α} (hp : irreducible p) (hq : irreducible q)",
    "doc_string": "If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`.",
    "type": "p ∣ q → q ∣ p"
  },
  {
    "name": "is_cyclic_of_prime_card",
    "statement": "theorem is_cyclic_of_prime_card {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α",
    "theorem": "{α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α",
    "args": "{α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p)",
    "doc_string": "A finite group of prime order is cyclic.",
    "type": "is_cyclic α"
  },
  {
    "name": "eq_zero_of_mul_eq_self_right",
    "statement": "theorem eq_zero_of_mul_eq_self_right {M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : a * b = a) : a = 0",
    "theorem": "{M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : a * b = a) : a = 0",
    "args": "{M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : a * b = a)",
    "doc_string": " An element of a `cancel_monoid_with_zero` fixed by right multiplication by an element other than one must be zero.",
    "type": "a = 0"
  },
  {
    "name": "affine_subspace.convex",
    "statement": "theorem affine_subspace.convex {𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (Q : affine_subspace 𝕜 E) : convex 𝕜 ↑Q",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (Q : affine_subspace 𝕜 E) : convex 𝕜 ↑Q",
    "args": "{𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (Q : affine_subspace 𝕜 E)",
    "doc_string": "Affine subspaces are convex.",
    "type": "convex 𝕜 ↑Q"
  },
  {
    "name": "nat.sub_mod_eq_zero_of_mod_eq",
    "statement": "theorem nat.sub_mod_eq_zero_of_mod_eq {a b c : ℕ} (h : a % c = b % c) : (a - b) % c = 0",
    "theorem": "{a b c : ℕ} (h : a % c = b % c) : (a - b) % c = 0",
    "args": "{a b c : ℕ} (h : a % c = b % c)",
    "doc_string": "If `a` and `b` are equal mod `c`, `a - b` is zero mod `c`.",
    "type": "(a - b) % c = 0"
  },
  {
    "name": "vector.ext",
    "statement": "theorem vector.ext {n : ℕ} {α : Type u_1} {v w : vector α n} (h : ∀ (m : fin n), v.nth m = w.nth m) : v = w",
    "theorem": "{n : ℕ} {α : Type u_1} {v w : vector α n} (h : ∀ (m : fin n), v.nth m = w.nth m) : v = w",
    "args": "{n : ℕ} {α : Type u_1} {v w : vector α n} (h : ∀ (m : fin n), v.nth m = w.nth m)",
    "doc_string": "Two `v w : vector α n` are equal iff they are equal at every single index.",
    "type": "v = w"
  },
  {
    "name": "star_div'",
    "statement": "theorem star_div' {R : Type u} [field R] [star_ring R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y",
    "theorem": "{R : Type u} [field R] [star_ring R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y",
    "args": "{R : Type u} [field R] [star_ring R] (x y : R)",
    "doc_string": "When multiplication is commutative, `star` preserves division.",
    "type": "has_star.star (x / y) = has_star.star x / has_star.star y"
  },
  {
    "name": "finset.centroid_weights_indicator_def",
    "statement": "theorem finset.centroid_weights_indicator_def (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) : finset.centroid_weights_indicator k s = ↑s.indicator (finset.centroid_weights k s)",
    "theorem": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) : finset.centroid_weights_indicator k s = ↑s.indicator (finset.centroid_weights k s)",
    "args": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι)",
    "doc_string": "The definition of `centroid_weights_indicator`.",
    "type": "finset.centroid_weights_indicator k s = ↑s.indicator (finset.centroid_weights k s)"
  },
  {
    "name": "has_mem.mem.out",
    "statement": "theorem has_mem.mem.out {α : Type u} {p : α → Prop} {a : α} (h : a ∈ {x : α | p x}) : p a",
    "theorem": "{α : Type u} {p : α → Prop} {a : α} (h : a ∈ {x : α | p x}) : p a",
    "args": "{α : Type u} {p : α → Prop} {a : α} (h : a ∈ {x : α | p x})",
    "doc_string": " If `h : a ∈ {x | p x}` then `h.out : p x`. These are definitionally equal, but this can nevertheless be useful for various reasons, e.g. to apply further projection notation or in an argument to `simp`.",
    "type": "p a"
  },
  {
    "name": "fin.tail_update_zero",
    "statement": "theorem fin.tail_update_zero {n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α 0) : fin.tail (function.update q 0 z) = fin.tail q",
    "theorem": "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α 0) : fin.tail (function.update q 0 z) = fin.tail q",
    "args": "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α 0)",
    "doc_string": "Updating the first element of a tuple does not change the tail.",
    "type": "fin.tail (function.update q 0 z) = fin.tail q"
  },
  {
    "name": "finset.shadow_monotone",
    "statement": "theorem finset.shadow_monotone {α : Type u_1} [decidable_eq α] : monotone finset.shadow",
    "theorem": "{α : Type u_1} [decidable_eq α] : monotone finset.shadow",
    "args": "{α : Type u_1} [decidable_eq α]",
    "doc_string": "The shadow is monotone.",
    "type": "monotone finset.shadow"
  },
  {
    "name": "pi.const_ring_hom_eq_algebra_map",
    "statement": "theorem pi.const_ring_hom_eq_algebra_map (R : Type u_1) (A : Type u_2) [comm_semiring R] : pi.const_ring_hom A R = algebra_map R (A → R)",
    "theorem": "(R : Type u_1) (A : Type u_2) [comm_semiring R] : pi.const_ring_hom A R = algebra_map R (A → R)",
    "args": "(R : Type u_1) (A : Type u_2) [comm_semiring R]",
    "doc_string": " When `R` is commutative and permits an `algebra_map`, `pi.const_ring_hom` is equal to that map.",
    "type": "pi.const_ring_hom A R = algebra_map R (A → R)"
  },
  {
    "name": "nat.totient_eq_mul_prod_factors",
    "statement": "theorem nat.totient_eq_mul_prod_factors (n : ℕ) : ↑(n.totient) = ↑n * n.factors.to_finset.prod (λ (p : ℕ), 1 - (↑p)⁻¹)",
    "theorem": "(n : ℕ) : ↑(n.totient) = ↑n * n.factors.to_finset.prod (λ (p : ℕ), 1 - (↑p)⁻¹)",
    "args": "(n : ℕ)",
    "doc_string": "Euler's product formula for the totient function.",
    "type": "↑(n.totient) = ↑n * n.factors.to_finset.prod (λ (p : ℕ), 1 - (↑p)⁻¹)"
  },
  {
    "name": "nat.exists_strict_mono'",
    "statement": "theorem nat.exists_strict_mono' {α : Type u} [preorder α] [no_max_order α] (a : α) : ∃ (f : ℕ → α), strict_mono f ∧ f 0 = a",
    "theorem": "{α : Type u} [preorder α] [no_max_order α] (a : α) : ∃ (f : ℕ → α), strict_mono f ∧ f 0 = a",
    "args": "{α : Type u} [preorder α] [no_max_order α] (a : α)",
    "doc_string": " If `α` is a preorder with no maximal elements, then there exists a strictly monotone function `ℕ → α` with any prescribed value of `f 0`.",
    "type": "∃ (f : ℕ → α), strict_mono f ∧ f 0 = a"
  },
  {
    "name": "modular_group.tendsto_norm_sq_coprime_pair",
    "statement": "theorem modular_group.tendsto_norm_sq_coprime_pair (z : upper_half_plane) : filter.tendsto (λ (p : fin 2 → ℤ), ⇑complex.norm_sq (↑(p 0) * ↑z + ↑(p 1))) filter.cofinite filter.at_top",
    "theorem": "(z : upper_half_plane) : filter.tendsto (λ (p : fin 2 → ℤ), ⇑complex.norm_sq (↑(p 0) * ↑z + ↑(p 1))) filter.cofinite filter.at_top",
    "args": "(z : upper_half_plane)",
    "doc_string": "The function `(c,d) → |cz+d|^2` is proper, that is, preimages of bounded-above sets are finite.",
    "type": "filter.tendsto (λ (p : fin 2 → ℤ), ⇑complex.norm_sq (↑(p 0) * ↑z + ↑(p 1))) filter.cofinite filter.at_top"
  },
  {
    "name": "has_le.le.eq_of_not_lt",
    "statement": "theorem has_le.le.eq_of_not_lt {α : Type u} [partial_order α] {a b : α} (hab : a ≤ b) (hba : ¬a < b) : a = b",
    "theorem": "{α : Type u} [partial_order α] {a b : α} (hab : a ≤ b) (hba : ¬a < b) : a = b",
    "args": "{α : Type u} [partial_order α] {a b : α} (hab : a ≤ b) (hba : ¬a < b)",
    "doc_string": "**Alias** of eq_of_le_of_not_lt`.",
    "type": "a = b"
  },
  {
    "name": "set.inj_on.injective",
    "statement": "theorem set.inj_on.injective {α : Type u} {β : Type v} {s : set α} {f : α → β} : set.inj_on f s → function.injective (s.restrict f)",
    "theorem": "{α : Type u} {β : Type v} {s : set α} {f : α → β} : set.inj_on f s → function.injective (s.restrict f)",
    "args": "{α : Type u} {β : Type v} {s : set α} {f : α → β}",
    "doc_string": "**Alias** of the forward direction of set.inj_on_iff_injective`.",
    "type": "set.inj_on f s → function.injective (s.restrict f)"
  },
  {
    "name": "poly.ext",
    "statement": "theorem poly.ext {α : Type u_1} {f g : poly α} : (∀ (x : α → ℕ), ⇑f x = ⇑g x) → f = g",
    "theorem": "{α : Type u_1} {f g : poly α} : (∀ (x : α → ℕ), ⇑f x = ⇑g x) → f = g",
    "args": "{α : Type u_1} {f g : poly α}",
    "doc_string": "Extensionality for `poly α`",
    "type": "(∀ (x : α → ℕ), ⇑f x = ⇑g x) → f = g"
  },
  {
    "name": "nat.dvd_add_self_left",
    "statement": "theorem nat.dvd_add_self_left {m n : ℕ} : m ∣ m + n ↔ m ∣ n",
    "theorem": "{m n : ℕ} : m ∣ m + n ↔ m ∣ n",
    "args": "{m n : ℕ}",
    "doc_string": "A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.",
    "type": "m ∣ m + n ↔ m ∣ n"
  },
  {
    "name": "is_left_regular_of_mul_eq_one",
    "statement": "theorem is_left_regular_of_mul_eq_one {R : Type u_1} {a b : R} [monoid R] (h : b * a = 1) : is_left_regular a",
    "theorem": "{R : Type u_1} {a b : R} [monoid R] (h : b * a = 1) : is_left_regular a",
    "args": "{R : Type u_1} {a b : R} [monoid R] (h : b * a = 1)",
    "doc_string": "An element admitting a left inverse is left-regular.",
    "type": "is_left_regular a"
  },
  {
    "name": "zmod.wilsons_lemma",
    "statement": "theorem zmod.wilsons_lemma (p : ℕ) [fact (nat.prime p)] : ↑((p - 1).factorial) = -1",
    "theorem": "(p : ℕ) [fact (nat.prime p)] : ↑((p - 1).factorial) = -1",
    "args": "(p : ℕ) [fact (nat.prime p)]",
    "doc_string": "**Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`.",
    "type": "↑((p - 1).factorial) = -1"
  },
  {
    "name": "is_min_on.undual",
    "statement": "theorem is_min_on.undual {α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_min_on (⇑order_dual.to_dual ∘ f) s a → is_max_on f s a",
    "theorem": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_min_on (⇑order_dual.to_dual ∘ f) s a → is_max_on f s a",
    "args": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α}",
    "doc_string": "**Alias** of the forward direction of is_min_on_dual_iff`.",
    "type": "is_min_on (⇑order_dual.to_dual ∘ f) s a → is_max_on f s a"
  },
  {
    "name": "filter.tendsto_mul_right_cobounded",
    "statement": "theorem filter.tendsto_mul_right_cobounded {α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0) : filter.tendsto (λ (x : α), x * a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)",
    "theorem": "{α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0) : filter.tendsto (λ (x : α), x * a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)",
    "args": "{α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0)",
    "doc_string": " Multiplication on the right by a nonzero element of a normed division ring tends to infinity at infinity. TODO: use `bornology.cobounded` instead of `filter.comap has_norm.norm filter.at_top`.",
    "type": "filter.tendsto (λ (x : α), x * a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)"
  },
  {
    "name": "is_unit.is_regular",
    "statement": "theorem is_unit.is_regular {R : Type u_1} {a : R} [monoid R] (ua : is_unit a) : is_regular a",
    "theorem": "{R : Type u_1} {a : R} [monoid R] (ua : is_unit a) : is_regular a",
    "args": "{R : Type u_1} {a : R} [monoid R] (ua : is_unit a)",
    "doc_string": "A unit in a monoid is regular.",
    "type": "is_regular a"
  },
  {
    "name": "inducing.pseudo_metrizable_space",
    "statement": "theorem inducing.pseudo_metrizable_space {X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.pseudo_metrizable_space Y] {f : X → Y} (hf : inducing f) : topological_space.pseudo_metrizable_space X",
    "theorem": "{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.pseudo_metrizable_space Y] {f : X → Y} (hf : inducing f) : topological_space.pseudo_metrizable_space X",
    "args": "{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.pseudo_metrizable_space Y] {f : X → Y} (hf : inducing f)",
    "doc_string": " Given an inducing map of a topological space into a pseudo metrizable space, the source space is also pseudo metrizable.",
    "type": "topological_space.pseudo_metrizable_space X"
  },
  {
    "name": "commute.quaternion_conj",
    "statement": "theorem commute.quaternion_conj {R : Type u_1} [comm_ring R] {a b : quaternion R} (h : commute a b) : commute (⇑quaternion.conj a) (⇑quaternion.conj b)",
    "theorem": "{R : Type u_1} [comm_ring R] {a b : quaternion R} (h : commute a b) : commute (⇑quaternion.conj a) (⇑quaternion.conj b)",
    "args": "{R : Type u_1} [comm_ring R] {a b : quaternion R} (h : commute a b)",
    "doc_string": "**Alias** of quaternion.commute_conj_conj`.",
    "type": "commute (⇑quaternion.conj a) (⇑quaternion.conj b)"
  },
  {
    "name": "is_torsion.not_torsion_free",
    "statement": "theorem is_torsion.not_torsion_free {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G",
    "theorem": "{G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G",
    "args": "{G : Type u_1} [group G] [hN : nontrivial G]",
    "doc_string": "A nontrivial torsion group is not torsion-free.",
    "type": "monoid.is_torsion G → ¬monoid.is_torsion_free G"
  },
  {
    "name": "sym2.map_id'",
    "statement": "theorem sym2.map_id' {α : Type u_1} : sym2.map (λ (x : α), x) = id",
    "theorem": "{α : Type u_1} : sym2.map (λ (x : α), x) = id",
    "args": "{α : Type u_1}",
    "doc_string": "Note: `sym2.map_id` will not simplify `sym2.map id z` due to `sym2.map_congr`.",
    "type": "sym2.map (λ (x : α), x) = id"
  },
  {
    "name": "is_left_regular_zero_iff_subsingleton",
    "statement": "theorem is_left_regular_zero_iff_subsingleton {R : Type u_1} [mul_zero_class R] : is_left_regular 0 ↔ subsingleton R",
    "theorem": "{R : Type u_1} [mul_zero_class R] : is_left_regular 0 ↔ subsingleton R",
    "args": "{R : Type u_1} [mul_zero_class R]",
    "doc_string": "The element `0` is left-regular if and only if `R` is trivial.",
    "type": "is_left_regular 0 ↔ subsingleton R"
  },
  {
    "name": "colex.singleton_le_iff_le",
    "statement": "theorem colex.singleton_le_iff_le {α : Type u_1} [linear_order α] {r s : α} : {r}.to_colex ≤ {s}.to_colex ↔ r ≤ s",
    "theorem": "{α : Type u_1} [linear_order α] {r s : α} : {r}.to_colex ≤ {s}.to_colex ↔ r ≤ s",
    "args": "{α : Type u_1} [linear_order α] {r s : α}",
    "doc_string": "Colex is an extension of the base ordering on α.",
    "type": "{r}.to_colex ≤ {s}.to_colex ↔ r ≤ s"
  },
  {
    "name": "is_add_group_hom.map_neg",
    "statement": "theorem is_add_group_hom.map_neg {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) (a : α) : f (-a) = -f a",
    "theorem": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) (a : α) : f (-a) = -f a",
    "args": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) (a : α)",
    "doc_string": "An additive group homomorphism sends negations to negations.",
    "type": "f (-a) = -f a"
  },
  {
    "name": "part.eta",
    "statement": "theorem part.eta {α : Type u_1} (o : part α) : {dom := o.dom, get := λ (h : o.dom), o.get h} = o",
    "theorem": "{α : Type u_1} (o : part α) : {dom := o.dom, get := λ (h : o.dom), o.get h} = o",
    "args": "{α : Type u_1} (o : part α)",
    "doc_string": "`part` eta expansion",
    "type": "{dom := o.dom, get := λ (h : o.dom), o.get h} = o"
  },
  {
    "name": "add_tsub_le_left",
    "statement": "theorem add_tsub_le_left {α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α} : a + b - a ≤ b",
    "theorem": "{α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α} : a + b - a ≤ b",
    "args": "{α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α}",
    "doc_string": "See `add_tsub_cancel_left` for the equality if `contravariant_class α α (+) (≤)`.",
    "type": "a + b - a ≤ b"
  },
  {
    "name": "left.one_lt_inv_iff",
    "statement": "theorem left.one_lt_inv_iff {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α}",
    "doc_string": "Uses `left` co(ntra)variant.",
    "type": "1 < a⁻¹ ↔ a < 1"
  },
  {
    "name": "localization_finite",
    "statement": "theorem localization_finite  : ring_hom.localization_preserves ring_hom.finite",
    "theorem": " : ring_hom.localization_preserves ring_hom.finite",
    "args": "",
    "doc_string": "If `S` is a finite `R`-algebra, then `S' = M⁻¹S` is a finite `R' = M⁻¹R`-algebra.",
    "type": "ring_hom.localization_preserves ring_hom.finite"
  },
  {
    "name": "free_group.reduce.rev",
    "statement": "theorem free_group.reduce.rev {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂) : free_group.red L₂ (free_group.reduce L₁)",
    "theorem": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂) : free_group.red L₂ (free_group.reduce L₁)",
    "args": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂)",
    "doc_string": " If words `w₁ w₂` are such that `w₁` reduces to `w₂`, then `w₂` reduces to the maximal reduction of `w₁`.",
    "type": "free_group.red L₂ (free_group.reduce L₁)"
  },
  {
    "name": "ordered_add_comm_group.add_lt_add_left",
    "statement": "theorem ordered_add_comm_group.add_lt_add_left {α : Type u_1} [has_add α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {b c : α} (bc : b < c) (a : α) : a + b < a + c",
    "theorem": "{α : Type u_1} [has_add α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {b c : α} (bc : b < c) (a : α) : a + b < a + c",
    "args": "{α : Type u_1} [has_add α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {b c : α} (bc : b < c) (a : α)",
    "doc_string": "**Alias** of mul_lt_mul_left'`.",
    "type": "a + b < a + c"
  },
  {
    "name": "lipschitz_with.dimH_range_le",
    "statement": "theorem lipschitz_with.dimH_range_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f) : dimH (set.range f) ≤ dimH set.univ",
    "theorem": "{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f) : dimH (set.range f) ≤ dimH set.univ",
    "args": "{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f)",
    "doc_string": " If `f` is a Lipschitz continuous map, then the Hausdorff dimension of its range is at most the Hausdorff dimension of its domain.",
    "type": "dimH (set.range f) ≤ dimH set.univ"
  },
  {
    "name": "comp_add_right",
    "statement": "theorem comp_add_right {α : Type u_1} [add_semigroup α] (x y : α) : ((λ (_x : α), _x + x) ∘ λ (_x : α), _x + y) = λ (_x : α), _x + (y + x)",
    "theorem": "{α : Type u_1} [add_semigroup α] (x y : α) : ((λ (_x : α), _x + x) ∘ λ (_x : α), _x + y) = λ (_x : α), _x + (y + x)",
    "args": "{α : Type u_1} [add_semigroup α] (x y : α)",
    "doc_string": "Composing two additions on the right by `y` and `x` is equal to a addition on the right by `y + x`.",
    "type": "((λ (_x : α), _x + x) ∘ λ (_x : α), _x + y) = λ (_x : α), _x + (y + x)"
  },
  {
    "name": "is_trivial_topological_fiber_bundle_fst",
    "statement": "theorem is_trivial_topological_fiber_bundle_fst {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.fst",
    "theorem": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.fst",
    "args": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F]",
    "doc_string": "The first projection in a product is a trivial topological fiber bundle.",
    "type": "is_trivial_topological_fiber_bundle F prod.fst"
  },
  {
    "name": "algebra.is_integral_of_finite",
    "statement": "theorem algebra.is_integral_of_finite (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L] : algebra.is_integral K L",
    "theorem": "(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L] : algebra.is_integral K L",
    "args": "(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L]",
    "doc_string": "A field extension is integral if it is finite.",
    "type": "algebra.is_integral K L"
  },
  {
    "name": "affine_map.id_apply",
    "statement": "theorem affine_map.id_apply (k : Type u_1) {V1 : Type u_2} {P1 : Type u_3} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] (p : P1) : ⇑(affine_map.id k P1) p = p",
    "theorem": "(k : Type u_1) {V1 : Type u_2} {P1 : Type u_3} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] (p : P1) : ⇑(affine_map.id k P1) p = p",
    "args": "(k : Type u_1) {V1 : Type u_2} {P1 : Type u_3} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] (p : P1)",
    "doc_string": "The identity affine map acts as the identity.",
    "type": "⇑(affine_map.id k P1) p = p"
  },
  {
    "name": "function.injective2.right'",
    "statement": "theorem function.injective2.right' {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty α] : function.injective (λ (b : β) (a : α), f a b)",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty α] : function.injective (λ (b : β) (a : α), f a b)",
    "args": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty α]",
    "doc_string": "As a map from the right argument to a unary function, `f` is injective.",
    "type": "function.injective (λ (b : β) (a : α), f a b)"
  },
  {
    "name": "prime_spectrum.gc_set",
    "statement": "theorem prime_spectrum.gc_set (R : Type u) [comm_ring R] : galois_connection (λ (s : set R), prime_spectrum.zero_locus s) (λ (t : (set (prime_spectrum R))ᵒᵈ), ↑(prime_spectrum.vanishing_ideal t))",
    "theorem": "(R : Type u) [comm_ring R] : galois_connection (λ (s : set R), prime_spectrum.zero_locus s) (λ (t : (set (prime_spectrum R))ᵒᵈ), ↑(prime_spectrum.vanishing_ideal t))",
    "args": "(R : Type u) [comm_ring R]",
    "doc_string": "`zero_locus` and `vanishing_ideal` form a galois connection.",
    "type": "galois_connection (λ (s : set R), prime_spectrum.zero_locus s) (λ (t : (set (prime_spectrum R))ᵒᵈ), ↑(prime_spectrum.vanishing_ideal t))"
  },
  {
    "name": "antisymm_of'",
    "statement": "theorem antisymm_of' {α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α} : r a b → r b a → b = a",
    "theorem": "{α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α} : r a b → r b a → b = a",
    "args": "{α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α}",
    "doc_string": " A version of `antisymm'` with `r` explicit.  This lemma matches the lemmas from lean core in `init.algebra.classes`, but is missing there.",
    "type": "r a b → r b a → b = a"
  },
  {
    "name": "nnreal.has_sum_iff_tendsto_nat",
    "statement": "theorem nnreal.has_sum_iff_tendsto_nat {f : ℕ → nnreal} {r : nnreal} : has_sum f r ↔ filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), f i)) filter.at_top (nhds r)",
    "theorem": "{f : ℕ → nnreal} {r : nnreal} : has_sum f r ↔ filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), f i)) filter.at_top (nhds r)",
    "args": "{f : ℕ → nnreal} {r : nnreal}",
    "doc_string": " A series of non-negative real numbers converges to `r` in the sense of `has_sum` if and only if the sequence of partial sum converges to `r`.",
    "type": "has_sum f r ↔ filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), f i)) filter.at_top (nhds r)"
  },
  {
    "name": "tactic.ring_exp.exp_congr",
    "statement": "theorem tactic.ring_exp.exp_congr {α : Type u} [comm_semiring α] {p p' : α} {ps ps' : ℕ} : p = p' → ps = ps' → p ^ ps = p' ^ ps'",
    "theorem": "{α : Type u} [comm_semiring α] {p p' : α} {ps ps' : ℕ} : p = p' → ps = ps' → p ^ ps = p' ^ ps'",
    "args": "{α : Type u} [comm_semiring α] {p p' : α} {ps ps' : ℕ}",
    "doc_string": "Congruence lemma for constructing `ex.exp`.",
    "type": "p = p' → ps = ps' → p ^ ps = p' ^ ps'"
  },
  {
    "name": "zmod.legendre_sym_card_sqrts",
    "statement": "theorem zmod.legendre_sym_card_sqrts (p : ℕ) [fact (nat.prime p)] (hp : p ≠ 2) (a : ℤ) : ↑({x : zmod p | x ^ 2 = ↑a}.to_finset.card) = zmod.legendre_sym p a + 1",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (hp : p ≠ 2) (a : ℤ) : ↑({x : zmod p | x ^ 2 = ↑a}.to_finset.card) = zmod.legendre_sym p a + 1",
    "args": "(p : ℕ) [fact (nat.prime p)] (hp : p ≠ 2) (a : ℤ)",
    "doc_string": "The number of square roots of `a` modulo `p` is determined by the Legendre symbol.",
    "type": "↑({x : zmod p | x ^ 2 = ↑a}.to_finset.card) = zmod.legendre_sym p a + 1"
  },
  {
    "name": "le_rfl",
    "statement": "theorem le_rfl {α : Type u} [preorder α] {a : α} : a ≤ a",
    "theorem": "{α : Type u} [preorder α] {a : α} : a ≤ a",
    "args": "{α : Type u} [preorder α] {a : α}",
    "doc_string": "A version of `le_refl` where the argument is implicit",
    "type": "a ≤ a"
  },
  {
    "name": "configuration.has_points.card_le",
    "statement": "theorem configuration.has_points.card_le (P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] : fintype.card L ≤ fintype.card P",
    "theorem": "(P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] : fintype.card L ≤ fintype.card P",
    "args": "(P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L]",
    "doc_string": "If a nondegenerate configuration has a unique point on any two lines, then `|L| ≤ |P|`.",
    "type": "fintype.card L ≤ fintype.card P"
  },
  {
    "name": "ordinal.fp_unbounded",
    "statement": "theorem ordinal.fp_unbounded {f : ordinal → ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f)",
    "theorem": "{f : ordinal → ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f)",
    "args": "{f : ordinal → ordinal} (H : ordinal.is_normal f)",
    "doc_string": " The fixed point lemma for normal functions: any normal function has an unbounded set of fixed points.",
    "type": "set.unbounded has_lt.lt (function.fixed_points f)"
  },
  {
    "name": "emetric.inf_edist_le_inf_edist_add_edist",
    "statement": "theorem emetric.inf_edist_le_inf_edist_add_edist {α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} : emetric.inf_edist x s ≤ emetric.inf_edist y s + has_edist.edist x y",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} : emetric.inf_edist x s ≤ emetric.inf_edist y s + has_edist.edist x y",
    "args": "{α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α}",
    "doc_string": " The edist of `x` to `s` is bounded by the sum of the edist of `y` to `s` and the edist from `x` to `y`",
    "type": "emetric.inf_edist x s ≤ emetric.inf_edist y s + has_edist.edist x y"
  },
  {
    "name": "add_con.neg",
    "statement": "theorem add_con.neg {M : Type u_1} [add_group M] (c : add_con M) {w x : M} : ⇑c w x → ⇑c (-w) (-x)",
    "theorem": "{M : Type u_1} [add_group M] (c : add_con M) {w x : M} : ⇑c w x → ⇑c (-w) (-x)",
    "args": "{M : Type u_1} [add_group M] (c : add_con M) {w x : M}",
    "doc_string": "Additive congruence relations preserve negation.",
    "type": "⇑c w x → ⇑c (-w) (-x)"
  },
  {
    "name": "is_right_regular.pow",
    "statement": "theorem is_right_regular.pow {R : Type u_1} {a : R} [monoid R] (n : ℕ) (rra : is_right_regular a) : is_right_regular (a ^ n)",
    "theorem": "{R : Type u_1} {a : R} [monoid R] (n : ℕ) (rra : is_right_regular a) : is_right_regular (a ^ n)",
    "args": "{R : Type u_1} {a : R} [monoid R] (n : ℕ) (rra : is_right_regular a)",
    "doc_string": "Any power of a right-regular element is right-regular.",
    "type": "is_right_regular (a ^ n)"
  },
  {
    "name": "isometry.injective",
    "statement": "theorem isometry.injective {β : Type v} [pseudo_emetric_space β] {α : Type u} [emetric_space α] {f : α → β} (h : isometry f) : function.injective f",
    "theorem": "{β : Type v} [pseudo_emetric_space β] {α : Type u} [emetric_space α] {f : α → β} (h : isometry f) : function.injective f",
    "args": "{β : Type v} [pseudo_emetric_space β] {α : Type u} [emetric_space α] {f : α → β} (h : isometry f)",
    "doc_string": "An isometry from an emetric space is injective",
    "type": "function.injective f"
  },
  {
    "name": "chart_at_self_eq",
    "statement": "theorem chart_at_self_eq {H : Type u_1} [topological_space H] {x : H} : charted_space.chart_at H x = local_homeomorph.refl H",
    "theorem": "{H : Type u_1} [topological_space H] {x : H} : charted_space.chart_at H x = local_homeomorph.refl H",
    "args": "{H : Type u_1} [topological_space H] {x : H}",
    "doc_string": "In the model space, chart_at is always the identity",
    "type": "charted_space.chart_at H x = local_homeomorph.refl H"
  },
  {
    "name": "is_add_left_regular_of_add_eq_zero",
    "statement": "theorem is_add_left_regular_of_add_eq_zero {R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0) : is_add_left_regular a",
    "theorem": "{R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0) : is_add_left_regular a",
    "args": "{R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0)",
    "doc_string": "An element admitting a left additive opposite is add-left-regular.",
    "type": "is_add_left_regular a"
  },
  {
    "name": "is_least.bdd_below",
    "statement": "theorem is_least.bdd_below {α : Type u} [preorder α] {s : set α} {a : α} (h : is_least s a) : bdd_below s",
    "theorem": "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_least s a) : bdd_below s",
    "args": "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_least s a)",
    "doc_string": "If `s` has a least element, then it is bounded below.",
    "type": "bdd_below s"
  },
  {
    "name": "perfection_map.of",
    "statement": "theorem perfection_map.of (p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] : perfection_map p (perfection.coeff R p 0)",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] : perfection_map p (perfection.coeff R p 0)",
    "args": "(p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p]",
    "doc_string": "The canonical perfection map from the perfection of a ring.",
    "type": "perfection_map p (perfection.coeff R p 0)"
  },
  {
    "name": "category_theory.subobject_simple_iff_is_atom",
    "statement": "theorem category_theory.subobject_simple_iff_is_atom {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (Y : category_theory.subobject X) : category_theory.simple ↑Y ↔ is_atom Y",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (Y : category_theory.subobject X) : category_theory.simple ↑Y ↔ is_atom Y",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (Y : category_theory.subobject X)",
    "doc_string": "A subobject is simple iff it is an atom in the subobject lattice.",
    "type": "category_theory.simple ↑Y ↔ is_atom Y"
  },
  {
    "name": "canonically_ordered_comm_semiring.zero_lt_one",
    "statement": "theorem canonically_ordered_comm_semiring.zero_lt_one {α : Type u} [canonically_ordered_comm_semiring α] [nontrivial α] : 0 < 1",
    "theorem": "{α : Type u} [canonically_ordered_comm_semiring α] [nontrivial α] : 0 < 1",
    "args": "{α : Type u} [canonically_ordered_comm_semiring α] [nontrivial α]",
    "doc_string": "A version of `zero_lt_one : 0 < 1` for a `canonically_ordered_comm_semiring`.",
    "type": "0 < 1"
  },
  {
    "name": "sub_eq_zero_of_eq",
    "statement": "theorem sub_eq_zero_of_eq {G : Type u_2} [add_group G] {a b : G} : a = b → a - b = 0",
    "theorem": "{G : Type u_2} [add_group G] {a b : G} : a = b → a - b = 0",
    "args": "{G : Type u_2} [add_group G] {a b : G}",
    "doc_string": "**Alias** of the reverse direction of sub_eq_zero`.",
    "type": "a = b → a - b = 0"
  },
  {
    "name": "real.sinh_bijective",
    "statement": "theorem real.sinh_bijective  : function.bijective real.sinh",
    "theorem": " : function.bijective real.sinh",
    "args": "",
    "doc_string": "`sinh` is bijective, both injective and surjective.",
    "type": "function.bijective real.sinh"
  },
  {
    "name": "zmod.euler_criterion",
    "statement": "theorem zmod.euler_criterion (p : ℕ) [fact (nat.prime p)] {a : zmod p} (ha : a ≠ 0) : is_square a ↔ a ^ (p / 2) = 1",
    "theorem": "(p : ℕ) [fact (nat.prime p)] {a : zmod p} (ha : a ≠ 0) : is_square a ↔ a ^ (p / 2) = 1",
    "args": "(p : ℕ) [fact (nat.prime p)] {a : zmod p} (ha : a ≠ 0)",
    "doc_string": "Euler's Criterion: a nonzero `a : zmod p` is a square if and only if `x ^ (p / 2) = 1`.",
    "type": "is_square a ↔ a ^ (p / 2) = 1"
  },
  {
    "name": "bdd_above_insert",
    "statement": "theorem bdd_above_insert {γ : Type w} [semilattice_sup γ] (a : γ) {s : set γ} : bdd_above (has_insert.insert a s) ↔ bdd_above s",
    "theorem": "{γ : Type w} [semilattice_sup γ] (a : γ) {s : set γ} : bdd_above (has_insert.insert a s) ↔ bdd_above s",
    "args": "{γ : Type w} [semilattice_sup γ] (a : γ) {s : set γ}",
    "doc_string": "Adding a point to a set preserves its boundedness above.",
    "type": "bdd_above (has_insert.insert a s) ↔ bdd_above s"
  },
  {
    "name": "neg_one_pow_two",
    "statement": "theorem neg_one_pow_two {R : Type u₁} [monoid R] [has_distrib_neg R] : (-1) ^ 2 = 1",
    "theorem": "{R : Type u₁} [monoid R] [has_distrib_neg R] : (-1) ^ 2 = 1",
    "args": "{R : Type u₁} [monoid R] [has_distrib_neg R]",
    "doc_string": "**Alias** of neg_one_sq`.",
    "type": "(-1) ^ 2 = 1"
  },
  {
    "name": "has_le.le.trans_lt'",
    "statement": "theorem has_le.le.trans_lt' {α : Type u} [preorder α] {a b c : α} : b ≤ c → a < b → a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : b ≤ c → a < b → a < c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of lt_of_le_of_lt'`.",
    "type": "b ≤ c → a < b → a < c"
  },
  {
    "name": "has_binary_products_of_terminal_and_pullbacks",
    "statement": "theorem has_binary_products_of_terminal_and_pullbacks (C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_binary_products C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_binary_products C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_pullbacks C]",
    "doc_string": "Any category with pullbacks and terminal object has binary products.",
    "type": "category_theory.limits.has_binary_products C"
  },
  {
    "name": "bdd_above.inter_of_left",
    "statement": "theorem bdd_above.inter_of_left {α : Type u} [preorder α] {s t : set α} (h : bdd_above s) : bdd_above (s ∩ t)",
    "theorem": "{α : Type u} [preorder α] {s t : set α} (h : bdd_above s) : bdd_above (s ∩ t)",
    "args": "{α : Type u} [preorder α] {s t : set α} (h : bdd_above s)",
    "doc_string": "If `s` is bounded, then so is `s ∩ t`",
    "type": "bdd_above (s ∩ t)"
  },
  {
    "name": "nhds_le_uniformity",
    "statement": "theorem nhds_le_uniformity {α : Type u_1} [uniform_space α] (x : α) : nhds (x, x) ≤ uniformity α",
    "theorem": "{α : Type u_1} [uniform_space α] (x : α) : nhds (x, x) ≤ uniformity α",
    "args": "{α : Type u_1} [uniform_space α] (x : α)",
    "doc_string": "Entourages are neighborhoods of the diagonal.",
    "type": "nhds (x, x) ≤ uniformity α"
  },
  {
    "name": "padic_val_int.one",
    "statement": "theorem padic_val_int.one {p : ℕ} : padic_val_int p 1 = 0",
    "theorem": "{p : ℕ} : padic_val_int p 1 = 0",
    "args": "{p : ℕ}",
    "doc_string": "`padic_val_int p 1` is 0 for any `p`.",
    "type": "padic_val_int p 1 = 0"
  },
  {
    "name": "left.mul_lt_one_of_lt_of_le",
    "statement": "theorem left.mul_lt_one_of_lt_of_le {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.mul_lt_one_of_lt_of_le`.",
    "type": "a * b < 1"
  },
  {
    "name": "is_preconnected.sUnion_directed",
    "statement": "theorem is_preconnected.sUnion_directed {α : Type u} [topological_space α] {S : set (set α)} (K : directed_on has_subset.subset S) (H : ∀ (s : set α), s ∈ S → is_preconnected s) : is_preconnected (⋃₀S)",
    "theorem": "{α : Type u} [topological_space α] {S : set (set α)} (K : directed_on has_subset.subset S) (H : ∀ (s : set α), s ∈ S → is_preconnected s) : is_preconnected (⋃₀S)",
    "args": "{α : Type u} [topological_space α] {S : set (set α)} (K : directed_on has_subset.subset S) (H : ∀ (s : set α), s ∈ S → is_preconnected s)",
    "doc_string": "The directed sUnion of a set S of preconnected subsets is preconnected.",
    "type": "is_preconnected (⋃₀S)"
  },
  {
    "name": "is_min.pred_eq",
    "statement": "theorem is_min.pred_eq {α : Type u_1} [partial_order α] [pred_order α] {a : α} : is_min a → order.pred a = a",
    "theorem": "{α : Type u_1} [partial_order α] [pred_order α] {a : α} : is_min a → order.pred a = a",
    "args": "{α : Type u_1} [partial_order α] [pred_order α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of order.pred_eq_iff_is_min`.",
    "type": "is_min a → order.pred a = a"
  },
  {
    "name": "add_con.ext_iff",
    "statement": "theorem add_con.ext_iff {M : Type u_1} [has_add M] {c d : add_con M} : (∀ (x y : M), ⇑c x y ↔ ⇑d x y) ↔ c = d",
    "theorem": "{M : Type u_1} [has_add M] {c d : add_con M} : (∀ (x y : M), ⇑c x y ↔ ⇑d x y) ↔ c = d",
    "args": "{M : Type u_1} [has_add M] {c d : add_con M}",
    "doc_string": "Iff version of extensionality rule for additive congruence relations.",
    "type": "(∀ (x y : M), ⇑c x y ↔ ⇑d x y) ↔ c = d"
  },
  {
    "name": "free_group.reduce.sound",
    "statement": "theorem free_group.reduce.sound {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) : free_group.reduce L₁ = free_group.reduce L₂",
    "theorem": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) : free_group.reduce L₁ = free_group.reduce L₂",
    "args": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂)",
    "doc_string": " If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined.",
    "type": "free_group.reduce L₁ = free_group.reduce L₂"
  },
  {
    "name": "subtype.edist_eq",
    "statement": "theorem subtype.edist_eq {α : Type u} [pseudo_emetric_space α] {p : α → Prop} (x y : subtype p) : has_edist.edist x y = has_edist.edist ↑x ↑y",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {p : α → Prop} (x y : subtype p) : has_edist.edist x y = has_edist.edist ↑x ↑y",
    "args": "{α : Type u} [pseudo_emetric_space α] {p : α → Prop} (x y : subtype p)",
    "doc_string": " The extended psuedodistance on a subset of a pseudoemetric space is the restriction of the original pseudodistance, by definition",
    "type": "has_edist.edist x y = has_edist.edist ↑x ↑y"
  },
  {
    "name": "closure_Ioc",
    "statement": "theorem closure_Ioc {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ioc a b) = set.Icc a b",
    "theorem": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ioc a b) = set.Icc a b",
    "args": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b)",
    "doc_string": "The closure of the interval `(a, b]` is the closed interval `[a, b]`.",
    "type": "closure (set.Ioc a b) = set.Icc a b"
  },
  {
    "name": "zero_lt.right.one_lt_mul_of_le_of_lt",
    "statement": "theorem zero_lt.right.one_lt_mul_of_le_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 < b) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "type": "1 < a * b"
  },
  {
    "name": "metric.diam_nonneg",
    "statement": "theorem metric.diam_nonneg {α : Type u} [pseudo_metric_space α] {s : set α} : 0 ≤ metric.diam s",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} : 0 ≤ metric.diam s",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α}",
    "doc_string": "The diameter of a set is always nonnegative",
    "type": "0 ≤ metric.diam s"
  },
  {
    "name": "add_subgroup.is_open_of_zero_mem_interior",
    "statement": "theorem add_subgroup.is_open_of_zero_mem_interior {G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 ∈ interior ↑H) : is_open ↑H",
    "theorem": "{G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 ∈ interior ↑H) : is_open ↑H",
    "args": "{G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 ∈ interior ↑H)",
    "doc_string": "If a subgroup of an additive topological group has `0` in its interior, then it is open.",
    "type": "is_open ↑H"
  },
  {
    "name": "star_div",
    "statement": "theorem star_div {R : Type u} [comm_group R] [star_semigroup R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y",
    "theorem": "{R : Type u} [comm_group R] [star_semigroup R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y",
    "args": "{R : Type u} [comm_group R] [star_semigroup R] (x y : R)",
    "doc_string": "When multiplication is commutative, `star` preserves division.",
    "type": "has_star.star (x / y) = has_star.star x / has_star.star y"
  },
  {
    "name": "is_smul_regular.zero",
    "statement": "theorem is_smul_regular.zero {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M] : is_smul_regular M 0",
    "theorem": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M] : is_smul_regular M 0",
    "args": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M]",
    "doc_string": "The element `0` is `M`-regular when `M` is trivial.",
    "type": "is_smul_regular M 0"
  },
  {
    "name": "is_trivial_topological_fiber_bundle_snd",
    "statement": "theorem is_trivial_topological_fiber_bundle_snd {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.snd",
    "theorem": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.snd",
    "args": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F]",
    "doc_string": "The second projection in a product is a trivial topological fiber bundle.",
    "type": "is_trivial_topological_fiber_bundle F prod.snd"
  },
  {
    "name": "char_zero_of_exp_char_one",
    "statement": "theorem char_zero_of_exp_char_one (R : Type u) [semiring R] [nontrivial R] (p : ℕ) [hp : char_p R p] [hq : exp_char R 1] : p = 0",
    "theorem": "(R : Type u) [semiring R] [nontrivial R] (p : ℕ) [hp : char_p R p] [hq : exp_char R 1] : p = 0",
    "args": "(R : Type u) [semiring R] [nontrivial R] (p : ℕ) [hp : char_p R p] [hq : exp_char R 1]",
    "doc_string": "The exponential characteristic is one if the characteristic is zero.",
    "type": "p = 0"
  },
  {
    "name": "powers.one_mem",
    "statement": "theorem powers.one_mem {M : Type u_1} [monoid M] {x : M} : 1 ∈ powers x",
    "theorem": "{M : Type u_1} [monoid M] {x : M} : 1 ∈ powers x",
    "args": "{M : Type u_1} [monoid M] {x : M}",
    "doc_string": "1 is in the set of natural number powers of an element of a monoid.",
    "type": "1 ∈ powers x"
  },
  {
    "name": "has_le.le.trans'",
    "statement": "theorem has_le.le.trans' {α : Type u} [preorder α] {a b c : α} : b ≤ c → a ≤ b → a ≤ c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : b ≤ c → a ≤ b → a ≤ c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of le_trans'`.",
    "type": "b ≤ c → a ≤ b → a ≤ c"
  },
  {
    "name": "category_theory.limits.has_zero_object_of_has_initial_object",
    "statement": "theorem category_theory.limits.has_zero_object_of_has_initial_object {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C]",
    "doc_string": "If there are zero morphisms, any initial object is a zero object.",
    "type": "category_theory.limits.has_zero_object C"
  },
  {
    "name": "is_fw_invariant_iff_is_invariant",
    "statement": "theorem is_fw_invariant_iff_is_invariant {τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α} : is_fw_invariant ϕ s ↔ is_invariant ϕ s",
    "theorem": "{τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α} : is_fw_invariant ϕ s ↔ is_invariant ϕ s",
    "args": "{τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α}",
    "doc_string": " If `τ` is a `canonically_ordered_add_monoid` (e.g., `ℕ` or `ℝ≥0`), then the notions `is_fw_invariant` and `is_invariant` are equivalent.",
    "type": "is_fw_invariant ϕ s ↔ is_invariant ϕ s"
  },
  {
    "name": "emetric.Hausdorff_edist_self",
    "statement": "theorem emetric.Hausdorff_edist_self {α : Type u} [pseudo_emetric_space α] {s : set α} : emetric.Hausdorff_edist s s = 0",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {s : set α} : emetric.Hausdorff_edist s s = 0",
    "args": "{α : Type u} [pseudo_emetric_space α] {s : set α}",
    "doc_string": "The Hausdorff edistance of a set to itself vanishes",
    "type": "emetric.Hausdorff_edist s s = 0"
  },
  {
    "name": "nat.exists_infinite_primes",
    "statement": "theorem nat.exists_infinite_primes (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p",
    "theorem": "(n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p",
    "args": "(n : ℕ)",
    "doc_string": " Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`.",
    "type": "∃ (p : ℕ), n ≤ p ∧ nat.prime p"
  },
  {
    "name": "neg_zero'",
    "statement": "theorem neg_zero' {α : Type u} [mul_zero_class α] [has_distrib_neg α] : -0 = 0",
    "theorem": "{α : Type u} [mul_zero_class α] [has_distrib_neg α] : -0 = 0",
    "args": "{α : Type u} [mul_zero_class α] [has_distrib_neg α]",
    "doc_string": "Prefer `neg_zero` if `subtraction_monoid` is available.",
    "type": "-0 = 0"
  },
  {
    "name": "add_commute.refl",
    "statement": "theorem add_commute.refl {S : Type u_1} [has_add S] (a : S) : add_commute a a",
    "theorem": "{S : Type u_1} [has_add S] (a : S) : add_commute a a",
    "args": "{S : Type u_1} [has_add S] (a : S)",
    "doc_string": "Any element commutes with itself.",
    "type": "add_commute a a"
  },
  {
    "name": "range.is_submonoid",
    "statement": "theorem range.is_submonoid {M : Type u_1} [monoid M] {γ : Type u_2} [monoid γ] {f : M → γ} (hf : is_monoid_hom f) : is_submonoid (set.range f)",
    "theorem": "{M : Type u_1} [monoid M] {γ : Type u_2} [monoid γ] {f : M → γ} (hf : is_monoid_hom f) : is_submonoid (set.range f)",
    "args": "{M : Type u_1} [monoid M] {γ : Type u_2} [monoid γ] {f : M → γ} (hf : is_monoid_hom f)",
    "doc_string": "The image of a monoid hom is a submonoid of the codomain.",
    "type": "is_submonoid (set.range f)"
  },
  {
    "name": "add_le_of_le_neg_add",
    "statement": "theorem add_le_of_le_neg_add {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : b ≤ -a + c → a + b ≤ c",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : b ≤ -a + c → a + b ≤ c",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of le_inv_mul_iff_mul_le`.",
    "type": "b ≤ -a + c → a + b ≤ c"
  },
  {
    "name": "is_smul_regular.not_zero",
    "statement": "theorem is_smul_regular.not_zero {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M] : ¬is_smul_regular M 0",
    "theorem": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M] : ¬is_smul_regular M 0",
    "args": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M]",
    "doc_string": "The `0` element is not `M`-regular, on a non-trivial module.",
    "type": "¬is_smul_regular M 0"
  },
  {
    "name": "category_theory.zigzag_is_connected",
    "statement": "theorem category_theory.zigzag_is_connected {J : Type u₁} [category_theory.category J] [nonempty J] (h : ∀ (j₁ j₂ : J), category_theory.zigzag j₁ j₂) : category_theory.is_connected J",
    "theorem": "{J : Type u₁} [category_theory.category J] [nonempty J] (h : ∀ (j₁ j₂ : J), category_theory.zigzag j₁ j₂) : category_theory.is_connected J",
    "args": "{J : Type u₁} [category_theory.category J] [nonempty J] (h : ∀ (j₁ j₂ : J), category_theory.zigzag j₁ j₂)",
    "doc_string": "If any two objects in an nonempty category are related by `zigzag`, the category is connected.",
    "type": "category_theory.is_connected J"
  },
  {
    "name": "char_p.char_ne_zero_of_fintype",
    "statement": "theorem char_p.char_ne_zero_of_fintype (R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0",
    "theorem": "(R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0",
    "args": "(R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R]",
    "doc_string": "The characteristic of a finite ring cannot be zero.",
    "type": "p ≠ 0"
  },
  {
    "name": "int.le_induction_down",
    "statement": "theorem int.le_induction_down {P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), n ≤ m → P n → P (n - 1)) (n : ℤ) : n ≤ m → P n",
    "theorem": "{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), n ≤ m → P n → P (n - 1)) (n : ℤ) : n ≤ m → P n",
    "args": "{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), n ≤ m → P n → P (n - 1)) (n : ℤ)",
    "doc_string": "See `int.induction_on'` for an induction in both directions.",
    "type": "n ≤ m → P n"
  },
  {
    "name": "int.lt_zpow_iff_log_lt",
    "statement": "theorem int.lt_zpow_iff_log_lt {R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : r < ↑b ^ x ↔ int.log b r < x",
    "theorem": "{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : r < ↑b ^ x ↔ int.log b r < x",
    "args": "{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r)",
    "doc_string": "`zpow b` and `int.log b` (almost) form a Galois connection.",
    "type": "r < ↑b ^ x ↔ int.log b r < x"
  },
  {
    "name": "measurable_set.is_clopenable",
    "statement": "theorem measurable_set.is_clopenable {α : Type u_1} [topological_space α] [polish_space α] [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) : polish_space.is_clopenable s",
    "theorem": "{α : Type u_1} [topological_space α] [polish_space α] [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) : polish_space.is_clopenable s",
    "args": "{α : Type u_1} [topological_space α] [polish_space α] [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s)",
    "doc_string": " Given a Borel-measurable set in a Polish space, there exists a finer Polish topology making it clopen. This is in fact an equivalence, see `is_clopenable_iff_measurable_set`.",
    "type": "polish_space.is_clopenable s"
  },
  {
    "name": "nat.le_two_mul_of_factorization_central_binom_pos",
    "statement": "theorem nat.le_two_mul_of_factorization_central_binom_pos {p n : ℕ} (h_pos : 0 < ⇑(n.central_binom.factorization) p) : p ≤ 2 * n",
    "theorem": "{p n : ℕ} (h_pos : 0 < ⇑(n.central_binom.factorization) p) : p ≤ 2 * n",
    "args": "{p n : ℕ} (h_pos : 0 < ⇑(n.central_binom.factorization) p)",
    "doc_string": "Contrapositive form of `nat.factorization_central_binom_eq_zero_of_two_mul_lt`",
    "type": "p ≤ 2 * n"
  },
  {
    "name": "is_p_group.is_nilpotent",
    "statement": "theorem is_p_group.is_nilpotent {G : Type u_1} [hG : group G] [hf : fintype G] {p : ℕ} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G",
    "theorem": "{G : Type u_1} [hG : group G] [hf : fintype G] {p : ℕ} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G",
    "args": "{G : Type u_1} [hG : group G] [hf : fintype G] {p : ℕ} [hp : fact (nat.prime p)] (h : is_p_group p G)",
    "doc_string": "A p-group is nilpotent",
    "type": "group.is_nilpotent G"
  },
  {
    "name": "is_unit.is_smul_regular",
    "statement": "theorem is_unit.is_smul_regular {R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a) : is_smul_regular M a",
    "theorem": "{R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a) : is_smul_regular M a",
    "args": "{R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a)",
    "doc_string": "A unit is `M`-regular.",
    "type": "is_smul_regular M a"
  },
  {
    "name": "setoid.ker_lift_injective",
    "statement": "theorem setoid.ker_lift_injective {α : Type u_1} {β : Type u_2} (f : α → β) : function.injective (quotient.lift f _)",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) : function.injective (quotient.lift f _)",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β)",
    "doc_string": "Given a map f from α to β, the natural map from the quotient of α by the kernel of f is    injective.",
    "type": "function.injective (quotient.lift f _)"
  },
  {
    "name": "tendsto_diag_uniformity",
    "statement": "theorem tendsto_diag_uniformity {α : Type u_1} {β : Type u_2} [uniform_space α] (f : β → α) (l : filter β) : filter.tendsto (λ (x : β), (f x, f x)) l (uniformity α)",
    "theorem": "{α : Type u_1} {β : Type u_2} [uniform_space α] (f : β → α) (l : filter β) : filter.tendsto (λ (x : β), (f x, f x)) l (uniformity α)",
    "args": "{α : Type u_1} {β : Type u_2} [uniform_space α] (f : β → α) (l : filter β)",
    "doc_string": "Relation `λ f g, tendsto (λ x, (f x, g x)) l (𝓤 α)` is reflexive.",
    "type": "filter.tendsto (λ (x : β), (f x, f x)) l (uniformity α)"
  },
  {
    "name": "category_theory.le_topology_of_closed_sieves_is_sheaf",
    "statement": "theorem category_theory.le_topology_of_closed_sieves_is_sheaf {C : Type u} [category_theory.category C] {J₁ J₂ : category_theory.grothendieck_topology C} (h : category_theory.presieve.is_sheaf J₁ (category_theory.functor.closed_sieves J₂)) : J₁ ≤ J₂",
    "theorem": "{C : Type u} [category_theory.category C] {J₁ J₂ : category_theory.grothendieck_topology C} (h : category_theory.presieve.is_sheaf J₁ (category_theory.functor.closed_sieves J₂)) : J₁ ≤ J₂",
    "args": "{C : Type u} [category_theory.category C] {J₁ J₂ : category_theory.grothendieck_topology C} (h : category_theory.presieve.is_sheaf J₁ (category_theory.functor.closed_sieves J₂))",
    "doc_string": "If presheaf of `J₁`-closed sieves is a `J₂`-sheaf then `J₁ ≤ J₂`. Note the converse is true by `classifier_is_sheaf` and `is_sheaf_of_le`.",
    "type": "J₁ ≤ J₂"
  },
  {
    "name": "polynomial.cyclotomic_nonneg",
    "statement": "theorem polynomial.cyclotomic_nonneg (n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 ≤ x) : 0 ≤ polynomial.eval x (polynomial.cyclotomic n R)",
    "theorem": "(n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 ≤ x) : 0 ≤ polynomial.eval x (polynomial.cyclotomic n R)",
    "args": "(n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 ≤ x)",
    "doc_string": "Cyclotomic polynomials are always nonnegative on inputs one or more.",
    "type": "0 ≤ polynomial.eval x (polynomial.cyclotomic n R)"
  },
  {
    "name": "emetric.continuous_inf_edist_Hausdorff_edist",
    "statement": "theorem emetric.continuous_inf_edist_Hausdorff_edist {α : Type u} [emetric_space α] : continuous (λ (p : α × topological_space.closeds α), emetric.inf_edist p.fst ↑(p.snd))",
    "theorem": "{α : Type u} [emetric_space α] : continuous (λ (p : α × topological_space.closeds α), emetric.inf_edist p.fst ↑(p.snd))",
    "args": "{α : Type u} [emetric_space α]",
    "doc_string": "The edistance to a closed set depends continuously on the point and the set",
    "type": "continuous (λ (p : α × topological_space.closeds α), emetric.inf_edist p.fst ↑(p.snd))"
  },
  {
    "name": "list.length_pos_of_prod_lt_one",
    "statement": "theorem list.length_pos_of_prod_lt_one {M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1) : 0 < L.length",
    "theorem": "{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1) : 0 < L.length",
    "args": "{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1)",
    "doc_string": "A list with product less than one must have positive length.",
    "type": "0 < L.length"
  },
  {
    "name": "is_Gδ.union",
    "statement": "theorem is_Gδ.union {α : Type u_1} [topological_space α] {s t : set α} (hs : is_Gδ s) (ht : is_Gδ t) : is_Gδ (s ∪ t)",
    "theorem": "{α : Type u_1} [topological_space α] {s t : set α} (hs : is_Gδ s) (ht : is_Gδ t) : is_Gδ (s ∪ t)",
    "args": "{α : Type u_1} [topological_space α] {s t : set α} (hs : is_Gδ s) (ht : is_Gδ t)",
    "doc_string": "The union of two Gδ sets is a Gδ set.",
    "type": "is_Gδ (s ∪ t)"
  },
  {
    "name": "real.not_summable_one_div_nat_cast",
    "statement": "theorem real.not_summable_one_div_nat_cast  : ¬summable (λ (n : ℕ), 1 / ↑n)",
    "theorem": " : ¬summable (λ (n : ℕ), 1 / ↑n)",
    "args": "",
    "doc_string": "Harmonic series is not unconditionally summable.",
    "type": "¬summable (λ (n : ℕ), 1 / ↑n)"
  },
  {
    "name": "has_le.le.eq_or_gt",
    "statement": "theorem has_le.le.eq_or_gt {α : Type u} [partial_order α] {a b : α} (h : a ≤ b) : b = a ∨ a < b",
    "theorem": "{α : Type u} [partial_order α] {a b : α} (h : a ≤ b) : b = a ∨ a < b",
    "args": "{α : Type u} [partial_order α] {a b : α} (h : a ≤ b)",
    "doc_string": "**Alias** of eq_or_gt_of_le`.",
    "type": "b = a ∨ a < b"
  },
  {
    "name": "nat.set_induction",
    "statement": "theorem nat.set_induction {S : set ℕ} (hb : 0 ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) (n : ℕ) : n ∈ S",
    "theorem": "{S : set ℕ} (hb : 0 ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) (n : ℕ) : n ∈ S",
    "args": "{S : set ℕ} (hb : 0 ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) (n : ℕ)",
    "doc_string": "A subset of `ℕ` containing zero and closed under `nat.succ` contains all of `ℕ`.",
    "type": "n ∈ S"
  },
  {
    "name": "inv_mul_le_of_le_mul",
    "statement": "theorem inv_mul_le_of_le_mul {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : a ≤ b * c → b⁻¹ * a ≤ c",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : a ≤ b * c → b⁻¹ * a ≤ c",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of inv_mul_le_iff_le_mul`.",
    "type": "a ≤ b * c → b⁻¹ * a ≤ c"
  },
  {
    "name": "ring.eq_self_iff_eq_zero_of_char_ne_two",
    "statement": "theorem ring.eq_self_iff_eq_zero_of_char_ne_two {R : Type u_1} [non_assoc_ring R] [nontrivial R] [no_zero_divisors R] (hR : ring_char R ≠ 2) {a : R} : -a = a ↔ a = 0",
    "theorem": "{R : Type u_1} [non_assoc_ring R] [nontrivial R] [no_zero_divisors R] (hR : ring_char R ≠ 2) {a : R} : -a = a ↔ a = 0",
    "args": "{R : Type u_1} [non_assoc_ring R] [nontrivial R] [no_zero_divisors R] (hR : ring_char R ≠ 2) {a : R}",
    "doc_string": "Characteristic `≠ 2` in a domain implies that `-a = a` iff `a = 0`.",
    "type": "-a = a ↔ a = 0"
  },
  {
    "name": "char.quadratic_char_sq_one'",
    "statement": "theorem char.quadratic_char_sq_one' {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F (a ^ 2) = 1",
    "theorem": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F (a ^ 2) = 1",
    "args": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0)",
    "doc_string": "The quadratic character takes the value `1` on nonzero squares.",
    "type": "char.quadratic_char F (a ^ 2) = 1"
  },
  {
    "name": "emetric.continuous_inf_edist",
    "statement": "theorem emetric.continuous_inf_edist {α : Type u} [pseudo_emetric_space α] {s : set α} : continuous (λ (x : α), emetric.inf_edist x s)",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {s : set α} : continuous (λ (x : α), emetric.inf_edist x s)",
    "args": "{α : Type u} [pseudo_emetric_space α] {s : set α}",
    "doc_string": "The edist to a set depends continuously on the point",
    "type": "continuous (λ (x : α), emetric.inf_edist x s)"
  },
  {
    "name": "div_le_div_of_mul_sub_mul_div_nonpos",
    "statement": "theorem div_le_div_of_mul_sub_mul_div_nonpos {α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : (a * d - b * c) / (c * d) ≤ 0 → a / c ≤ b / d",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : (a * d - b * c) / (c * d) ≤ 0 → a / c ≤ b / d",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0)",
    "doc_string": "**Alias** of the forward direction of mul_sub_mul_div_mul_nonpos_iff`.",
    "type": "(a * d - b * c) / (c * d) ≤ 0 → a / c ≤ b / d"
  },
  {
    "name": "topological_space.opens.coe_mk",
    "statement": "theorem topological_space.opens.coe_mk {α : Type u_1} [topological_space α] {U : set α} {hU : is_open U} : ↑⟨U, hU⟩ = U",
    "theorem": "{α : Type u_1} [topological_space α] {U : set α} {hU : is_open U} : ↑⟨U, hU⟩ = U",
    "args": "{α : Type u_1} [topological_space α] {U : set α} {hU : is_open U}",
    "doc_string": "the coercion `opens α → set α` applied to a pair is the same as taking the first component",
    "type": "↑⟨U, hU⟩ = U"
  },
  {
    "name": "fin.coe_val_eq_self",
    "statement": "theorem fin.coe_val_eq_self {n : ℕ} (a : fin (n + 1)) : ↑(a.val) = a",
    "theorem": "{n : ℕ} (a : fin (n + 1)) : ↑(a.val) = a",
    "args": "{n : ℕ} (a : fin (n + 1))",
    "doc_string": " Converting the value of a `fin (n + 1)` to `fin (n + 1)` results in the same value.",
    "type": "↑(a.val) = a"
  },
  {
    "name": "topological_fiber_bundle_core.is_open_map_proj",
    "statement": "theorem topological_fiber_bundle_core.is_open_map_proj {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : is_open_map Z.proj",
    "theorem": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : is_open_map Z.proj",
    "args": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F)",
    "doc_string": "The projection on the base of a topological bundle created from core is an open map",
    "type": "is_open_map Z.proj"
  },
  {
    "name": "is_algebraic_algebra_map",
    "statement": "theorem is_algebraic_algebra_map {R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] (x : R) : is_algebraic R (⇑(algebra_map R A) x)",
    "theorem": "{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] (x : R) : is_algebraic R (⇑(algebra_map R A) x)",
    "args": "{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] (x : R)",
    "doc_string": "An element of `R` is algebraic, when viewed as an element of the `R`-algebra `A`.",
    "type": "is_algebraic R (⇑(algebra_map R A) x)"
  },
  {
    "name": "left.one_lt_mul",
    "statement": "theorem left.one_lt_mul {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul`.",
    "type": "1 < a * b"
  },
  {
    "name": "comp_add_left",
    "statement": "theorem comp_add_left {α : Type u_1} [add_semigroup α] (x y : α) : has_add.add x ∘ has_add.add y = has_add.add (x + y)",
    "theorem": "{α : Type u_1} [add_semigroup α] (x y : α) : has_add.add x ∘ has_add.add y = has_add.add (x + y)",
    "args": "{α : Type u_1} [add_semigroup α] (x y : α)",
    "doc_string": "Composing two additions on the left by `y` then `x` is equal to a addition on the left by `x + y`.",
    "type": "has_add.add x ∘ has_add.add y = has_add.add (x + y)"
  },
  {
    "name": "nat.set_induction_bounded",
    "statement": "theorem nat.set_induction_bounded {b : ℕ} {S : set ℕ} (hb : b ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) {n : ℕ} (hbn : b ≤ n) : n ∈ S",
    "theorem": "{b : ℕ} {S : set ℕ} (hb : b ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) {n : ℕ} (hbn : b ≤ n) : n ∈ S",
    "args": "{b : ℕ} {S : set ℕ} (hb : b ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) {n : ℕ} (hbn : b ≤ n)",
    "doc_string": "A subset of `ℕ` containing `b : ℕ` and closed under `nat.succ` contains every `n ≥ b`.",
    "type": "n ∈ S"
  },
  {
    "name": "szemeredi_regularity.step_bound_pos",
    "statement": "theorem szemeredi_regularity.step_bound_pos {n : ℕ} : 0 < n → 0 < szemeredi_regularity.step_bound n",
    "theorem": "{n : ℕ} : 0 < n → 0 < szemeredi_regularity.step_bound n",
    "args": "{n : ℕ}",
    "doc_string": "**Alias** of the reverse direction of szemeredi_regularity.step_bound_pos_iff`.",
    "type": "0 < n → 0 < szemeredi_regularity.step_bound n"
  },
  {
    "name": "multiples.self_mem",
    "statement": "theorem multiples.self_mem {M : Type u_1} [add_monoid M] {x : M} : x ∈ multiples x",
    "theorem": "{M : Type u_1} [add_monoid M] {x : M} : x ∈ multiples x",
    "args": "{M : Type u_1} [add_monoid M] {x : M}",
    "doc_string": "An element of an `add_monoid` is in the set of that element's natural number multiples.",
    "type": "x ∈ multiples x"
  },
  {
    "name": "complex.tendsto_exp_comap_re_at_top",
    "statement": "theorem complex.tendsto_exp_comap_re_at_top  : filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)",
    "theorem": " : filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)",
    "args": "",
    "doc_string": "`complex.abs (complex.exp z) → ∞` as `complex.re z → ∞`. TODO: use `bornology.cobounded`.",
    "type": "filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)"
  },
  {
    "name": "rel_embedding.coe_fn_injective",
    "statement": "theorem rel_embedding.coe_fn_injective {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn",
    "theorem": "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn",
    "args": "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop}",
    "doc_string": "The map `coe_fn : (r ↪r s) → (α → β)` is injective.",
    "type": "function.injective coe_fn"
  },
  {
    "name": "category_theory.limits.finite_colimits_from_coequalizers_and_finite_coproducts",
    "statement": "theorem category_theory.limits.finite_colimits_from_coequalizers_and_finite_coproducts {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_finite_colimits C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_finite_colimits C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C]",
    "doc_string": "Any category with finite coproducts and coequalizers has all finite colimits.  See <https://stacks.math.columbia.edu/tag/002Q>.",
    "type": "category_theory.limits.has_finite_colimits C"
  },
  {
    "name": "add_order_of_pos_iff",
    "statement": "theorem add_order_of_pos_iff {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x",
    "theorem": "{G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x",
    "args": "{G : Type u} {x : G} [add_monoid G]",
    "doc_string": "A group element has finite additive order iff its order is positive.",
    "type": "0 < add_order_of x ↔ is_of_fin_add_order x"
  },
  {
    "name": "star_ring_end_apply",
    "statement": "theorem star_ring_end_apply {R : Type u} [comm_semiring R] [star_ring R] {x : R} : ⇑(star_ring_end R) x = has_star.star x",
    "theorem": "{R : Type u} [comm_semiring R] [star_ring R] {x : R} : ⇑(star_ring_end R) x = has_star.star x",
    "args": "{R : Type u} [comm_semiring R] [star_ring R] {x : R}",
    "doc_string": "This is not a simp lemma, since we usually want simp to keep `star_ring_end` bundled. For example, for complex conjugation, we don't want simp to turn `conj x` into the bare function `star x` automatically since most lemmas are about `conj x`.",
    "type": "⇑(star_ring_end R) x = has_star.star x"
  },
  {
    "name": "topological_group.continuous_conj_prod",
    "statement": "theorem topological_group.continuous_conj_prod {G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] : continuous (λ (g : G × G), g.fst * g.snd * (g.fst)⁻¹)",
    "theorem": "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] : continuous (λ (g : G × G), g.fst * g.snd * (g.fst)⁻¹)",
    "args": "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G]",
    "doc_string": "Conjugation is jointly continuous on `G × G` when both `mul` and `inv` are continuous.",
    "type": "continuous (λ (g : G × G), g.fst * g.snd * (g.fst)⁻¹)"
  },
  {
    "name": "has_sum_zero",
    "statement": "theorem has_sum_zero {α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] : has_sum (λ (b : β), 0) 0",
    "theorem": "{α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] : has_sum (λ (b : β), 0) 0",
    "args": "{α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α]",
    "doc_string": "Constant zero function has sum `0`",
    "type": "has_sum (λ (b : β), 0) 0"
  },
  {
    "name": "closed_embedding.polish_space",
    "statement": "theorem closed_embedding.polish_space {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [polish_space β] {f : α → β} (hf : closed_embedding f) : polish_space α",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [polish_space β] {f : α → β} (hf : closed_embedding f) : polish_space α",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [polish_space β] {f : α → β} (hf : closed_embedding f)",
    "doc_string": "Given a closed embedding into a Polish space, the source space is also Polish.",
    "type": "polish_space α"
  },
  {
    "name": "turing.list_blank.exists_cons",
    "statement": "theorem turing.list_blank.exists_cons {Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : ∃ (a : Γ) (l' : turing.list_blank Γ), l = turing.list_blank.cons a l'",
    "theorem": "{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : ∃ (a : Γ) (l' : turing.list_blank Γ), l = turing.list_blank.cons a l'",
    "args": "{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ)",
    "doc_string": " The `cons` and `head`/`tail` functions are mutually inverse, unlike in the case of `list` where this only holds for nonempty lists.",
    "type": "∃ (a : Γ) (l' : turing.list_blank Γ), l = turing.list_blank.cons a l'"
  },
  {
    "name": "Exists.some_spec",
    "statement": "theorem Exists.some_spec {α : Sort u_1} {p : α → Prop} (P : ∃ (a : α), p a) : p P.some",
    "theorem": "{α : Sort u_1} {p : α → Prop} (P : ∃ (a : α), p a) : p P.some",
    "args": "{α : Sort u_1} {p : α → Prop} (P : ∃ (a : α), p a)",
    "doc_string": "Show that an element extracted from `P : ∃ a, p a` using `P.some` satisfies `p`.",
    "type": "p P.some"
  },
  {
    "name": "uv.compress_idem",
    "statement": "theorem uv.compress_idem {α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : α) : uv.compress u v (uv.compress u v a) = uv.compress u v a",
    "theorem": "{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : α) : uv.compress u v (uv.compress u v a) = uv.compress u v a",
    "args": "{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : α)",
    "doc_string": "Compressing an element is idempotent.",
    "type": "uv.compress u v (uv.compress u v a) = uv.compress u v a"
  },
  {
    "name": "reflexive.ne_imp_iff",
    "statement": "theorem reflexive.ne_imp_iff {α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} : x ≠ y → r x y ↔ r x y",
    "theorem": "{α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} : x ≠ y → r x y ↔ r x y",
    "args": "{α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α}",
    "doc_string": " If a reflexive relation `r : α → α → Prop` holds over `x y : α`, then it holds whether or not `x ≠ y`.",
    "type": "x ≠ y → r x y ↔ r x y"
  },
  {
    "name": "upper_central_series_is_ascending_central_series",
    "statement": "theorem upper_central_series_is_ascending_central_series (G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G)",
    "theorem": "(G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G)",
    "args": "(G : Type u_1) [group G]",
    "doc_string": "The upper central series of a group is an ascending central series.",
    "type": "is_ascending_central_series (upper_central_series G)"
  },
  {
    "name": "nat.prime.mod_two_eq_one_iff_ne_two",
    "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2",
    "theorem": "{p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2",
    "args": "{p : ℕ} [fact (nat.prime p)]",
    "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.",
    "type": "p % 2 = 1 ↔ p ≠ 2"
  },
  {
    "name": "coe_fourier_series",
    "statement": "theorem coe_fourier_series  : ⇑fourier_series = fourier_Lp 2",
    "theorem": " : ⇑fourier_series = fourier_Lp 2",
    "args": "",
    "doc_string": " The elements of the Hilbert basis `fourier_series` for `Lp ℂ 2 haar_circle` are the functions `fourier_Lp 2`, the monomials `λ z, z ^ n` on the circle considered as elements of `L2`.",
    "type": "⇑fourier_series = fourier_Lp 2"
  },
  {
    "name": "list.map_comp_map",
    "statement": "theorem list.map_comp_map {α : Type u} {β : Type v} {γ : Type w} (g : β → γ) (f : α → β) : list.map g ∘ list.map f = list.map (g ∘ f)",
    "theorem": "{α : Type u} {β : Type v} {γ : Type w} (g : β → γ) (f : α → β) : list.map g ∘ list.map f = list.map (g ∘ f)",
    "args": "{α : Type u} {β : Type v} {γ : Type w} (g : β → γ) (f : α → β)",
    "doc_string": "Composing a `list.map` with another `list.map` is equal to a single `list.map` of composed functions.",
    "type": "list.map g ∘ list.map f = list.map (g ∘ f)"
  },
  {
    "name": "not_is_right_regular_zero_iff",
    "statement": "theorem not_is_right_regular_zero_iff {R : Type u_1} [mul_zero_class R] : ¬is_right_regular 0 ↔ nontrivial R",
    "theorem": "{R : Type u_1} [mul_zero_class R] : ¬is_right_regular 0 ↔ nontrivial R",
    "args": "{R : Type u_1} [mul_zero_class R]",
    "doc_string": "In a non-trivial `mul_zero_class`, the `0` element is not right-regular.",
    "type": "¬is_right_regular 0 ↔ nontrivial R"
  },
  {
    "name": "metric.inf_dist_le_dist_of_mem",
    "statement": "theorem metric.inf_dist_le_dist_of_mem {α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} (h : y ∈ s) : metric.inf_dist x s ≤ has_dist.dist x y",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} (h : y ∈ s) : metric.inf_dist x s ≤ has_dist.dist x y",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} (h : y ∈ s)",
    "doc_string": "The minimal distance to a set is bounded by the distance to any point in this set",
    "type": "metric.inf_dist x s ≤ has_dist.dist x y"
  },
  {
    "name": "finset.eq_empty_of_is_empty",
    "statement": "theorem finset.eq_empty_of_is_empty {α : Type u_1} [is_empty α] (s : finset α) : s = ∅",
    "theorem": "{α : Type u_1} [is_empty α] (s : finset α) : s = ∅",
    "args": "{α : Type u_1} [is_empty α] (s : finset α)",
    "doc_string": "A `finset` for an empty type is empty.",
    "type": "s = ∅"
  },
  {
    "name": "nonarchimedean_ring.mul_subset",
    "statement": "theorem nonarchimedean_ring.mul_subset {R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R) : ∃ (V : open_add_subgroup R), ↑V * ↑V ⊆ ↑U",
    "theorem": "{R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R) : ∃ (V : open_add_subgroup R), ↑V * ↑V ⊆ ↑U",
    "args": "{R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R)",
    "doc_string": "An open subgroup of a nonarchimedean ring contains the square of another one.",
    "type": "∃ (V : open_add_subgroup R), ↑V * ↑V ⊆ ↑U"
  },
  {
    "name": "is_bot.to_dual",
    "statement": "theorem is_bot.to_dual {α : Type u_1} [has_le α] {a : α} : is_bot a → is_top (⇑order_dual.to_dual a)",
    "theorem": "{α : Type u_1} [has_le α] {a : α} : is_bot a → is_top (⇑order_dual.to_dual a)",
    "args": "{α : Type u_1} [has_le α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of is_top_to_dual_iff`.",
    "type": "is_bot a → is_top (⇑order_dual.to_dual a)"
  },
  {
    "name": "is_lub.bdd_above",
    "statement": "theorem is_lub.bdd_above {α : Type u} [preorder α] {s : set α} {a : α} (h : is_lub s a) : bdd_above s",
    "theorem": "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_lub s a) : bdd_above s",
    "args": "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_lub s a)",
    "doc_string": "If `s` has a least upper bound, then it is bounded above.",
    "type": "bdd_above s"
  },
  {
    "name": "function.injective2.left'",
    "statement": "theorem function.injective2.left' {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty β] : function.injective f",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty β] : function.injective f",
    "args": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty β]",
    "doc_string": "As a map from the left argument to a unary function, `f` is injective.",
    "type": "function.injective f"
  },
  {
    "name": "is_compact_interval",
    "statement": "theorem is_compact_interval {α : Type u_1} [linear_order α] [topological_space α] [compact_Icc_space α] {a b : α} : is_compact (set.interval a b)",
    "theorem": "{α : Type u_1} [linear_order α] [topological_space α] [compact_Icc_space α] {a b : α} : is_compact (set.interval a b)",
    "args": "{α : Type u_1} [linear_order α] [topological_space α] [compact_Icc_space α] {a b : α}",
    "doc_string": "An unordered closed interval is compact.",
    "type": "is_compact (set.interval a b)"
  },
  {
    "name": "con.le_def",
    "statement": "theorem con.le_def {M : Type u_1} [has_mul M] {c d : con M} : c ≤ d ↔ ∀ {x y : M}, ⇑c x y → ⇑d x y",
    "theorem": "{M : Type u_1} [has_mul M] {c d : con M} : c ≤ d ↔ ∀ {x y : M}, ⇑c x y → ⇑d x y",
    "args": "{M : Type u_1} [has_mul M] {c d : con M}",
    "doc_string": "Definition of `≤` for congruence relations.",
    "type": "c ≤ d ↔ ∀ {x y : M}, ⇑c x y → ⇑d x y"
  },
  {
    "name": "ordinal.principal_add_iff_zero_or_omega_opow",
    "statement": "theorem ordinal.principal_add_iff_zero_or_omega_opow {o : ordinal} : ordinal.principal has_add.add o ↔ o = 0 ∨ ∃ (a : ordinal), o = ordinal.omega ^ a",
    "theorem": "{o : ordinal} : ordinal.principal has_add.add o ↔ o = 0 ∨ ∃ (a : ordinal), o = ordinal.omega ^ a",
    "args": "{o : ordinal}",
    "doc_string": "The main characterization theorem for additive principal ordinals.",
    "type": "ordinal.principal has_add.add o ↔ o = 0 ∨ ∃ (a : ordinal), o = ordinal.omega ^ a"
  },
  {
    "name": "fin.succ_above_lt_gt",
    "statement": "theorem fin.succ_above_lt_gt {n : ℕ} (p : fin (n + 1)) (i : fin n) : ⇑fin.cast_succ i < p ∨ p < i.succ",
    "theorem": "{n : ℕ} (p : fin (n + 1)) (i : fin n) : ⇑fin.cast_succ i < p ∨ p < i.succ",
    "args": "{n : ℕ} (p : fin (n + 1)) (i : fin n)",
    "doc_string": "Embedding `i : fin n` into `fin (n + 1)` is always about some hole `p`.",
    "type": "⇑fin.cast_succ i < p ∨ p < i.succ"
  },
  {
    "name": "generalized_continued_fraction.int_fract_pair.nth_stream_fr_lt_one",
    "statement": "theorem generalized_continued_fraction.int_fract_pair.nth_stream_fr_lt_one {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : ifp_n.fr < 1",
    "theorem": "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : ifp_n.fr < 1",
    "args": "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n)",
    "doc_string": "Shows that the fractional parts of the stream are smaller than one.",
    "type": "ifp_n.fr < 1"
  },
  {
    "name": "pow_two",
    "statement": "theorem pow_two {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a",
    "theorem": "{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a",
    "args": "{M : Type u} [monoid M] (a : M)",
    "doc_string": "Note that most of the lemmas about powers of two refer to it as `sq`.",
    "type": "a ^ 2 = a * a"
  },
  {
    "name": "finset.sum_centroid_weights_eq_one_of_card_ne_zero",
    "statement": "theorem finset.sum_centroid_weights_eq_one_of_card_ne_zero (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] (h : s.card ≠ 0) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1",
    "theorem": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] (h : s.card ≠ 0) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1",
    "args": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] (h : s.card ≠ 0)",
    "doc_string": " In the characteristic zero case, the weights in the centroid sum to 1 if the number of points is not zero.",
    "type": "s.sum (λ (i : ι), finset.centroid_weights k s i) = 1"
  },
  {
    "name": "not_is_unit_prime_of_dvd_card",
    "statement": "theorem not_is_unit_prime_of_dvd_card {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p",
    "theorem": "{R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p",
    "args": "{R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R)",
    "doc_string": " A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`.",
    "type": "¬is_unit ↑p"
  },
  {
    "name": "neg_nonpos",
    "statement": "theorem neg_nonpos {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : -a ≤ 0 ↔ 0 ≤ a",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : -a ≤ 0 ↔ 0 ≤ a",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α}",
    "doc_string": "**Alias** of left.inv_le_one_iff`.",
    "type": "-a ≤ 0 ↔ 0 ≤ a"
  },
  {
    "name": "nat.eq_pow_of_factorization_eq_single",
    "statement": "theorem nat.eq_pow_of_factorization_eq_single {n p k : ℕ} (hn : n ≠ 0) (h : n.factorization = finsupp.single p k) : n = p ^ k",
    "theorem": "{n p k : ℕ} (hn : n ≠ 0) (h : n.factorization = finsupp.single p k) : n = p ^ k",
    "args": "{n p k : ℕ} (hn : n ≠ 0) (h : n.factorization = finsupp.single p k)",
    "doc_string": "If the factorization of `n` contains just one number `p` then `n` is a power of `p`",
    "type": "n = p ^ k"
  },
  {
    "name": "is_semiring_hom.to_is_add_monoid_hom",
    "statement": "theorem is_semiring_hom.to_is_add_monoid_hom {α : Type u} {β : Type v} [semiring α] [semiring β] {f : α → β} (hf : is_semiring_hom f) : is_add_monoid_hom f",
    "theorem": "{α : Type u} {β : Type v} [semiring α] [semiring β] {f : α → β} (hf : is_semiring_hom f) : is_add_monoid_hom f",
    "args": "{α : Type u} {β : Type v} [semiring α] [semiring β] {f : α → β} (hf : is_semiring_hom f)",
    "doc_string": "A semiring homomorphism is an additive monoid homomorphism.",
    "type": "is_add_monoid_hom f"
  },
  {
    "name": "emetric.inf_edist_anti",
    "statement": "theorem emetric.inf_edist_anti {α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : s ⊆ t) : emetric.inf_edist x t ≤ emetric.inf_edist x s",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : s ⊆ t) : emetric.inf_edist x t ≤ emetric.inf_edist x s",
    "args": "{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : s ⊆ t)",
    "doc_string": "The edist is antitone with respect to inclusion.",
    "type": "emetric.inf_edist x t ≤ emetric.inf_edist x s"
  },
  {
    "name": "finset.Icc_eq_empty",
    "statement": "theorem finset.Icc_eq_empty {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a ≤ b → finset.Icc a b = ∅",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a ≤ b → finset.Icc a b = ∅",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of finset.Icc_eq_empty_iff`.",
    "type": "¬a ≤ b → finset.Icc a b = ∅"
  },
  {
    "name": "nat.lt_wf",
    "statement": "theorem nat.lt_wf  : well_founded nat.lt",
    "theorem": " : well_founded nat.lt",
    "args": "",
    "doc_string": "less-than is well-founded",
    "type": "well_founded nat.lt"
  },
  {
    "name": "list.length_pos_of_sum_ne_zero",
    "statement": "theorem list.length_pos_of_sum_ne_zero {M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0) : 0 < L.length",
    "theorem": "{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0) : 0 < L.length",
    "args": "{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0)",
    "doc_string": "A list with sum not zero must have positive length.",
    "type": "0 < L.length"
  },
  {
    "name": "one_lt_mul'",
    "statement": "theorem one_lt_mul' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": "**Alias** of left.one_lt_mul`.",
    "type": "1 < a * b"
  },
  {
    "name": "set.inv_Ioo_0_left",
    "statement": "theorem set.inv_Ioo_0_left {k : Type u} [linear_ordered_field k] {a : k} (ha : 0 < a) : (set.Ioo 0 a)⁻¹ = set.Ioi a⁻¹",
    "theorem": "{k : Type u} [linear_ordered_field k] {a : k} (ha : 0 < a) : (set.Ioo 0 a)⁻¹ = set.Ioi a⁻¹",
    "args": "{k : Type u} [linear_ordered_field k] {a : k} (ha : 0 < a)",
    "doc_string": "The (pre)image under `inv` of `Ioo 0 a` is `Ioi a⁻¹`.",
    "type": "(set.Ioo 0 a)⁻¹ = set.Ioi a⁻¹"
  },
  {
    "name": "eq.subset",
    "statement": "theorem eq.subset {α : Type u_1} {s t : set α} : s = t → s ⊆ t",
    "theorem": "{α : Type u_1} {s t : set α} : s = t → s ⊆ t",
    "args": "{α : Type u_1} {s t : set α}",
    "doc_string": "Duplicate of `eq.subset'`, which currently has elaboration problems.",
    "type": "s = t → s ⊆ t"
  },
  {
    "name": "edist_eq_zero",
    "statement": "theorem edist_eq_zero {γ : Type w} [emetric_space γ] {x y : γ} : has_edist.edist x y = 0 ↔ x = y",
    "theorem": "{γ : Type w} [emetric_space γ] {x y : γ} : has_edist.edist x y = 0 ↔ x = y",
    "args": "{γ : Type w} [emetric_space γ] {x y : γ}",
    "doc_string": "Characterize the equality of points by the vanishing of their extended distance",
    "type": "has_edist.edist x y = 0 ↔ x = y"
  },
  {
    "name": "multiset.sub_zero",
    "statement": "theorem multiset.sub_zero {α : Type u_1} [decidable_eq α] (s : multiset α) : s - 0 = s",
    "theorem": "{α : Type u_1} [decidable_eq α] (s : multiset α) : s - 0 = s",
    "args": "{α : Type u_1} [decidable_eq α] (s : multiset α)",
    "doc_string": "This is a special case of `tsub_zero`, which should be used instead of this.  This is needed to prove `has_ordered_sub (multiset α)`.",
    "type": "s - 0 = s"
  },
  {
    "name": "field.to_is_field",
    "statement": "theorem field.to_is_field (R : Type u) [field R] : is_field R",
    "theorem": "(R : Type u) [field R] : is_field R",
    "args": "(R : Type u) [field R]",
    "doc_string": "Transferring from field to is_field",
    "type": "is_field R"
  },
  {
    "name": "add_con.symm",
    "statement": "theorem add_con.symm {M : Type u_1} [has_add M] (c : add_con M) {x y : M} : ⇑c x y → ⇑c y x",
    "theorem": "{M : Type u_1} [has_add M] (c : add_con M) {x y : M} : ⇑c x y → ⇑c y x",
    "args": "{M : Type u_1} [has_add M] (c : add_con M) {x y : M}",
    "doc_string": "Additive congruence relations are symmetric.",
    "type": "⇑c x y → ⇑c y x"
  },
  {
    "name": "matrix.nonsing_inv_eq_ring_inverse",
    "statement": "theorem matrix.nonsing_inv_eq_ring_inverse {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) : A⁻¹ = ring.inverse A",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) : A⁻¹ = ring.inverse A",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α)",
    "doc_string": "The nonsingular inverse is the same as the general `ring.inverse`.",
    "type": "A⁻¹ = ring.inverse A"
  },
  {
    "name": "lower_adjoint.le_closure",
    "statement": "theorem lower_adjoint.le_closure {α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {u : β → α} (l : lower_adjoint u) (x : α) : x ≤ u (⇑l x)",
    "theorem": "{α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {u : β → α} (l : lower_adjoint u) (x : α) : x ≤ u (⇑l x)",
    "args": "{α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {u : β → α} (l : lower_adjoint u) (x : α)",
    "doc_string": " Every element is less than its closure. This property is sometimes referred to as extensivity or inflationarity.",
    "type": "x ≤ u (⇑l x)"
  },
  {
    "name": "ring.inverse_non_unit",
    "statement": "theorem ring.inverse_non_unit {M₀ : Type u_1} [monoid_with_zero M₀] (x : M₀) (h : ¬is_unit x) : ring.inverse x = 0",
    "theorem": "{M₀ : Type u_1} [monoid_with_zero M₀] (x : M₀) (h : ¬is_unit x) : ring.inverse x = 0",
    "args": "{M₀ : Type u_1} [monoid_with_zero M₀] (x : M₀) (h : ¬is_unit x)",
    "doc_string": "By definition, if `x` is not invertible then `inverse x = 0`.",
    "type": "ring.inverse x = 0"
  },
  {
    "name": "subsingleton.convex_independent",
    "statement": "theorem subsingleton.convex_independent {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] [subsingleton ι] (p : ι → E) : convex_independent 𝕜 p",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] [subsingleton ι] (p : ι → E) : convex_independent 𝕜 p",
    "args": "{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] [subsingleton ι] (p : ι → E)",
    "doc_string": "A family with at most one point is convex independent.",
    "type": "convex_independent 𝕜 p"
  },
  {
    "name": "is_square_of_exists_sq",
    "statement": "theorem is_square_of_exists_sq {α : Type u_2} [monoid α] (m : α) : (∃ (c : α), m = c ^ 2) → is_square m",
    "theorem": "{α : Type u_2} [monoid α] (m : α) : (∃ (c : α), m = c ^ 2) → is_square m",
    "args": "{α : Type u_2} [monoid α] (m : α)",
    "doc_string": "**Alias** of the reverse direction of is_square_iff_exists_sq`.",
    "type": "(∃ (c : α), m = c ^ 2) → is_square m"
  },
  {
    "name": "category_theory.limits.has_biproduct.of_has_coproduct",
    "statement": "theorem category_theory.limits.has_biproduct.of_has_coproduct {C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_coproduct f] : category_theory.limits.has_biproduct f",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_coproduct f] : category_theory.limits.has_biproduct f",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_coproduct f]",
    "doc_string": "In a preadditive category, if the coproduct over `f : J → C` exists,    then the biproduct over `f` exists.",
    "type": "category_theory.limits.has_biproduct f"
  },
  {
    "name": "inv_gold_conj",
    "statement": "theorem inv_gold_conj  : golden_conj⁻¹ = -golden_ratio",
    "theorem": " : golden_conj⁻¹ = -golden_ratio",
    "args": "",
    "doc_string": "The opposite of the golden ratio is the inverse of its conjugate.",
    "type": "golden_conj⁻¹ = -golden_ratio"
  },
  {
    "name": "nat.exists_strict_anti'",
    "statement": "theorem nat.exists_strict_anti' {α : Type u} [preorder α] [no_min_order α] (a : α) : ∃ (f : ℕ → α), strict_anti f ∧ f 0 = a",
    "theorem": "{α : Type u} [preorder α] [no_min_order α] (a : α) : ∃ (f : ℕ → α), strict_anti f ∧ f 0 = a",
    "args": "{α : Type u} [preorder α] [no_min_order α] (a : α)",
    "doc_string": " If `α` is a preorder with no maximal elements, then there exists a strictly antitone function `ℕ → α` with any prescribed value of `f 0`.",
    "type": "∃ (f : ℕ → α), strict_anti f ∧ f 0 = a"
  },
  {
    "name": "neg_pos",
    "statement": "theorem neg_pos {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : 0 < -a ↔ a < 0",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : 0 < -a ↔ a < 0",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α}",
    "doc_string": "**Alias** of left.one_lt_inv_iff`.",
    "type": "0 < -a ↔ a < 0"
  },
  {
    "name": "category_theory.is_subterminal.mono_is_terminal_from",
    "statement": "theorem category_theory.is_subterminal.mono_is_terminal_from {C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A)",
    "theorem": "{C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A)",
    "args": "{C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T)",
    "doc_string": "If `A` is subterminal, the unique morphism from it to a terminal object is a monomorphism. The converse of `is_subterminal_of_mono_is_terminal_from`.",
    "type": "category_theory.mono (hT.from A)"
  },
  {
    "name": "is_add_right_regular.of_add",
    "statement": "theorem is_add_right_regular.of_add {R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a)) : is_add_right_regular b",
    "theorem": "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a)) : is_add_right_regular b",
    "args": "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a))",
    "doc_string": "If an element `b` becomes add-right-regular after adding to it on the right a add-right-regular element, then `b` is add-right-regular.",
    "type": "is_add_right_regular b"
  },
  {
    "name": "topological_fiber_bundle_core.continuous_total_space_mk",
    "statement": "theorem topological_fiber_bundle_core.continuous_total_space_mk {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (b : B) : continuous (bundle.total_space_mk b)",
    "theorem": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (b : B) : continuous (bundle.total_space_mk b)",
    "args": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (b : B)",
    "doc_string": "The inclusion of a fiber into the total space is a continuous map.",
    "type": "continuous (bundle.total_space_mk b)"
  },
  {
    "name": "int.exists_strict_mono",
    "statement": "theorem int.exists_strict_mono (α : Type u) [preorder α] [nonempty α] [no_min_order α] [no_max_order α] : ∃ (f : ℤ → α), strict_mono f",
    "theorem": "(α : Type u) [preorder α] [nonempty α] [no_min_order α] [no_max_order α] : ∃ (f : ℤ → α), strict_mono f",
    "args": "(α : Type u) [preorder α] [nonempty α] [no_min_order α] [no_max_order α]",
    "doc_string": " If `α` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly monotone function `f : ℤ → α`.",
    "type": "∃ (f : ℤ → α), strict_mono f"
  },
  {
    "name": "nonempty.map",
    "statement": "theorem nonempty.map {α : Sort u_1} {β : Sort u_2} (f : α → β) : nonempty α → nonempty β",
    "theorem": "{α : Sort u_1} {β : Sort u_2} (f : α → β) : nonempty α → nonempty β",
    "args": "{α : Sort u_1} {β : Sort u_2} (f : α → β)",
    "doc_string": "Given `f : α → β`, if `α` is nonempty then `β` is also nonempty.  `nonempty` cannot be a `functor`, because `functor` is restricted to `Type`.",
    "type": "nonempty α → nonempty β"
  },
  {
    "name": "nat.of_digits_lt_base_pow_length",
    "statement": "theorem nat.of_digits_lt_base_pow_length {b : ℕ} {l : list ℕ} (hb : 2 ≤ b) (hl : ∀ (x : ℕ), x ∈ l → x < b) : nat.of_digits b l < b ^ l.length",
    "theorem": "{b : ℕ} {l : list ℕ} (hb : 2 ≤ b) (hl : ∀ (x : ℕ), x ∈ l → x < b) : nat.of_digits b l < b ^ l.length",
    "args": "{b : ℕ} {l : list ℕ} (hb : 2 ≤ b) (hl : ∀ (x : ℕ), x ∈ l → x < b)",
    "doc_string": "an n-digit number in base b is less than b^n if b ≥ 2",
    "type": "nat.of_digits b l < b ^ l.length"
  },
  {
    "name": "add_semiconj_by.conj_mk",
    "statement": "theorem add_semiconj_by.conj_mk {G : Type u} [add_group G] (a x : G) : add_semiconj_by a x (a + x + -a)",
    "theorem": "{G : Type u} [add_group G] (a x : G) : add_semiconj_by a x (a + x + -a)",
    "args": "{G : Type u} [add_group G] (a x : G)",
    "doc_string": "`a` semiconjugates `x` to `a + x + -a`.",
    "type": "add_semiconj_by a x (a + x + -a)"
  },
  {
    "name": "rel_iso.coe_fn_injective",
    "statement": "theorem rel_iso.coe_fn_injective {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn",
    "theorem": "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn",
    "args": "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop}",
    "doc_string": " The map `coe_fn : (r ≃r s) → (α → β)` is injective. Lean fails to parse `function.injective (λ e : r ≃r s, (e : α → β))`, so we use a trick to say the same.",
    "type": "function.injective coe_fn"
  },
  {
    "name": "loc_compact_t2_tot_disc_iff_tot_sep",
    "statement": "theorem loc_compact_t2_tot_disc_iff_tot_sep {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H ↔ totally_separated_space H",
    "theorem": "{H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H ↔ totally_separated_space H",
    "args": "{H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H]",
    "doc_string": "A locally compact Hausdorff space is totally disconnected  if and only if it is totally separated.",
    "type": "totally_disconnected_space H ↔ totally_separated_space H"
  },
  {
    "name": "equiv.point_reflection_fixed_iff_of_injective_bit0",
    "statement": "theorem equiv.point_reflection_fixed_iff_of_injective_bit0 {G : Type u_1} {P : Type u_2} [add_group G] [add_torsor G P] {x y : P} (h : function.injective bit0) : ⇑(equiv.point_reflection x) y = y ↔ y = x",
    "theorem": "{G : Type u_1} {P : Type u_2} [add_group G] [add_torsor G P] {x y : P} (h : function.injective bit0) : ⇑(equiv.point_reflection x) y = y ↔ y = x",
    "args": "{G : Type u_1} {P : Type u_2} [add_group G] [add_torsor G P] {x y : P} (h : function.injective bit0)",
    "doc_string": " `x` is the only fixed point of `point_reflection x`. This lemma requires `x + x = y + y ↔ x = y`. There is no typeclass to use here, so we add it as an explicit argument.",
    "type": "⇑(equiv.point_reflection x) y = y ↔ y = x"
  },
  {
    "name": "category_theory.grothendieck_topology.ext",
    "statement": "theorem category_theory.grothendieck_topology.ext {C : Type u} [category_theory.category C] {J₁ J₂ : category_theory.grothendieck_topology C} (h : ⇑J₁ = ⇑J₂) : J₁ = J₂",
    "theorem": "{C : Type u} [category_theory.category C] {J₁ J₂ : category_theory.grothendieck_topology C} (h : ⇑J₁ = ⇑J₂) : J₁ = J₂",
    "args": "{C : Type u} [category_theory.category C] {J₁ J₂ : category_theory.grothendieck_topology C} (h : ⇑J₁ = ⇑J₂)",
    "doc_string": "An extensionality lemma in terms of the coercion to a pi-type. We prove this explicitly rather than deriving it so that it is in terms of the coercion rather than the projection `.sieves`.",
    "type": "J₁ = J₂"
  },
  {
    "name": "is_ring_hom.to_is_semiring_hom",
    "statement": "theorem is_ring_hom.to_is_semiring_hom {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f) : is_semiring_hom f",
    "theorem": "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f) : is_semiring_hom f",
    "args": "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f)",
    "doc_string": "A ring homomorphism is also a semiring homomorphism.",
    "type": "is_semiring_hom f"
  },
  {
    "name": "rat.uniform_space_eq",
    "statement": "theorem rat.uniform_space_eq  : is_absolute_value.uniform_space has_abs.abs = pseudo_metric_space.to_uniform_space",
    "theorem": " : is_absolute_value.uniform_space has_abs.abs = pseudo_metric_space.to_uniform_space",
    "args": "",
    "doc_string": " The metric space uniform structure on ℚ (which presupposes the existence of real numbers) agrees with the one coming directly from (abs : ℚ → ℚ).",
    "type": "is_absolute_value.uniform_space has_abs.abs = pseudo_metric_space.to_uniform_space"
  },
  {
    "name": "nat_ordinal.induction",
    "statement": "theorem nat_ordinal.induction {p : nat_ordinal → Prop} (i : nat_ordinal) (h : ∀ (j : nat_ordinal), (∀ (k : nat_ordinal), k < j → p k) → p j) : p i",
    "theorem": "{p : nat_ordinal → Prop} (i : nat_ordinal) (h : ∀ (j : nat_ordinal), (∀ (k : nat_ordinal), k < j → p k) → p j) : p i",
    "args": "{p : nat_ordinal → Prop} (i : nat_ordinal) (h : ∀ (j : nat_ordinal), (∀ (k : nat_ordinal), k < j → p k) → p j)",
    "doc_string": "`ordinal.induction` but for `nat_ordinal`.",
    "type": "p i"
  },
  {
    "name": "sq_add_sq_mul_sq_add_sq",
    "statement": "theorem sq_add_sq_mul_sq_add_sq {R : Type u_1} [comm_ring R] {x₁ x₂ y₁ y₂ : R} : (x₁ ^ 2 + x₂ ^ 2) * (y₁ ^ 2 + y₂ ^ 2) = (x₁ * y₁ - x₂ * y₂) ^ 2 + (x₁ * y₂ + x₂ * y₁) ^ 2",
    "theorem": "{R : Type u_1} [comm_ring R] {x₁ x₂ y₁ y₂ : R} : (x₁ ^ 2 + x₂ ^ 2) * (y₁ ^ 2 + y₂ ^ 2) = (x₁ * y₁ - x₂ * y₂) ^ 2 + (x₁ * y₂ + x₂ * y₁) ^ 2",
    "args": "{R : Type u_1} [comm_ring R] {x₁ x₂ y₁ y₂ : R}",
    "doc_string": "Brahmagupta-Fibonacci identity or Diophantus identity, see <https://en.wikipedia.org/wiki/Brahmagupta%E2%80%93Fibonacci_identity>.  This sign choice here corresponds to the signs obtained by multiplying two complex numbers.",
    "type": "(x₁ ^ 2 + x₂ ^ 2) * (y₁ ^ 2 + y₂ ^ 2) = (x₁ * y₁ - x₂ * y₂) ^ 2 + (x₁ * y₂ + x₂ * y₁) ^ 2"
  },
  {
    "name": "nat.filter_multiset_Ico_card_eq_of_periodic",
    "statement": "theorem nat.filter_multiset_Ico_card_eq_of_periodic (n a : ℕ) (p : ℕ → Prop) [decidable_pred p] (pp : function.periodic p a) : ⇑multiset.card (multiset.filter p (multiset.Ico n (n + a))) = nat.count p a",
    "theorem": "(n a : ℕ) (p : ℕ → Prop) [decidable_pred p] (pp : function.periodic p a) : ⇑multiset.card (multiset.filter p (multiset.Ico n (n + a))) = nat.count p a",
    "args": "(n a : ℕ) (p : ℕ → Prop) [decidable_pred p] (pp : function.periodic p a)",
    "doc_string": " An interval of length `a` filtered over a periodic predicate of period `a` has cardinality equal to the number naturals below `a` for which `p a` is true.",
    "type": "⇑multiset.card (multiset.filter p (multiset.Ico n (n + a))) = nat.count p a"
  },
  {
    "name": "comp_mul_right",
    "statement": "theorem comp_mul_right {α : Type u_1} [semigroup α] (x y : α) : ((λ (_x : α), _x * x) ∘ λ (_x : α), _x * y) = λ (_x : α), _x * (y * x)",
    "theorem": "{α : Type u_1} [semigroup α] (x y : α) : ((λ (_x : α), _x * x) ∘ λ (_x : α), _x * y) = λ (_x : α), _x * (y * x)",
    "args": "{α : Type u_1} [semigroup α] (x y : α)",
    "doc_string": "Composing two multiplications on the right by `y` and `x` is equal to a multiplication on the right by `y * x`.",
    "type": "((λ (_x : α), _x * x) ∘ λ (_x : α), _x * y) = λ (_x : α), _x * (y * x)"
  },
  {
    "name": "finite_dimensional.finrank_zero_of_subsingleton",
    "statement": "theorem finite_dimensional.finrank_zero_of_subsingleton {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V] : finite_dimensional.finrank K V = 0",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V] : finite_dimensional.finrank K V = 0",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V]",
    "doc_string": "A finite dimensional space that is a subsingleton has zero `finrank`.",
    "type": "finite_dimensional.finrank K V = 0"
  },
  {
    "name": "nat.partrec.code.evaln_prim",
    "statement": "theorem nat.partrec.code.evaln_prim  : primrec (λ (a : (ℕ × nat.partrec.code) × ℕ), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)",
    "theorem": " : primrec (λ (a : (ℕ × nat.partrec.code) × ℕ), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)",
    "args": "",
    "doc_string": "The `nat.partrec.code.evaln` function is primitive recursive.",
    "type": "primrec (λ (a : (ℕ × nat.partrec.code) × ℕ), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)"
  },
  {
    "name": "matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix",
    "statement": "theorem matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix {n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R) : ↑↑↑g = ↑g",
    "theorem": "{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R) : ↑↑↑g = ↑g",
    "args": "{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R)",
    "doc_string": " Coercing a `special_linear_group` via `GL_pos` and `GL` is the same as coercing striaght to a matrix.",
    "type": "↑↑↑g = ↑g"
  },
  {
    "name": "right.add_pos'",
    "statement": "theorem right.add_pos' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_pos'`.",
    "type": "0 < a + b"
  },
  {
    "name": "list.pairwise.pw_filter",
    "statement": "theorem list.pairwise.pw_filter {α : Type u_1} {R : α → α → Prop} [decidable_rel R] {l : list α} : list.pairwise R l → list.pw_filter R l = l",
    "theorem": "{α : Type u_1} {R : α → α → Prop} [decidable_rel R] {l : list α} : list.pairwise R l → list.pw_filter R l = l",
    "args": "{α : Type u_1} {R : α → α → Prop} [decidable_rel R] {l : list α}",
    "doc_string": "**Alias** of the reverse direction of list.pw_filter_eq_self`.",
    "type": "list.pairwise R l → list.pw_filter R l = l"
  },
  {
    "name": "category_theory.exact_inl_snd",
    "statement": "theorem category_theory.exact_inl_snd {𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜) : category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd",
    "theorem": "{𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜) : category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd",
    "args": "{𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜)",
    "doc_string": "The sequence `A ⟶ A ⊞ B ⟶ B` is exact.",
    "type": "category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd"
  },
  {
    "name": "finset.up_shadow_monotone",
    "statement": "theorem finset.up_shadow_monotone {α : Type u_1} [decidable_eq α] [fintype α] : monotone finset.up_shadow",
    "theorem": "{α : Type u_1} [decidable_eq α] [fintype α] : monotone finset.up_shadow",
    "args": "{α : Type u_1} [decidable_eq α] [fintype α]",
    "doc_string": "The upper shadow is monotone.",
    "type": "monotone finset.up_shadow"
  },
  {
    "name": "neg_one_mul",
    "statement": "theorem neg_one_mul {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : (-1) * a = -a",
    "theorem": "{α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : (-1) * a = -a",
    "args": "{α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α)",
    "doc_string": "The additive inverse of one multiplied by an element of a ring is the element's additive  inverse.",
    "type": "(-1) * a = -a"
  },
  {
    "name": "zero_dvd_iff",
    "statement": "theorem zero_dvd_iff {α : Type u_1} [semigroup_with_zero α] {a : α} : 0 ∣ a ↔ a = 0",
    "theorem": "{α : Type u_1} [semigroup_with_zero α] {a : α} : 0 ∣ a ↔ a = 0",
    "args": "{α : Type u_1} [semigroup_with_zero α] {a : α}",
    "doc_string": "Given an element `a` of a commutative semigroup with zero, there exists another element whose    product with zero equals `a` iff `a` equals zero.",
    "type": "0 ∣ a ↔ a = 0"
  },
  {
    "name": "measure_theory.strongly_measurable.is_separable_range",
    "statement": "theorem measure_theory.strongly_measurable.is_separable_range {α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] (hf : measure_theory.strongly_measurable f) : topological_space.is_separable (set.range f)",
    "theorem": "{α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] (hf : measure_theory.strongly_measurable f) : topological_space.is_separable (set.range f)",
    "args": "{α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] (hf : measure_theory.strongly_measurable f)",
    "doc_string": "The range of a strongly measurable function is separable.",
    "type": "topological_space.is_separable (set.range f)"
  },
  {
    "name": "strict_mono_on.dual_right",
    "statement": "theorem strict_mono_on.dual_right {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : strict_mono_on f s → strict_anti_on (⇑order_dual.to_dual ∘ f) s",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : strict_mono_on f s → strict_anti_on (⇑order_dual.to_dual ∘ f) s",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α}",
    "doc_string": "**Alias** of the reverse direction of strict_anti_on_to_dual_comp_iff`.",
    "type": "strict_mono_on f s → strict_anti_on (⇑order_dual.to_dual ∘ f) s"
  },
  {
    "name": "lt_add_of_neg_add_lt_left",
    "statement": "theorem lt_add_of_neg_add_lt_left {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : -b + a < c → a < b + c",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : -b + a < c → a < b + c",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of lt_mul_of_inv_mul_lt`.",
    "type": "-b + a < c → a < b + c"
  },
  {
    "name": "zero_lt.right.mul_nonneg",
    "statement": "theorem zero_lt.right.mul_nonneg {α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b",
    "theorem": "{α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b",
    "args": "{α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b)",
    "doc_string": "Assumes right covariance.",
    "type": "0 ≤ a * b"
  },
  {
    "name": "has_sbtw.sbtw.not_btw",
    "statement": "theorem has_sbtw.sbtw.not_btw {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : ¬has_btw.btw c b a",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : ¬has_btw.btw c b a",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c)",
    "doc_string": "**Alias** of not_btw_of_sbtw`.",
    "type": "¬has_btw.btw c b a"
  },
  {
    "name": "ordered_add_comm_group.le_of_add_le_add_left",
    "statement": "theorem ordered_add_comm_group.le_of_add_le_add_left {α : Type u_1} [has_add α] [has_le α] [contravariant_class α α has_add.add has_le.le] {a b c : α} (bc : a + b ≤ a + c) : b ≤ c",
    "theorem": "{α : Type u_1} [has_add α] [has_le α] [contravariant_class α α has_add.add has_le.le] {a b c : α} (bc : a + b ≤ a + c) : b ≤ c",
    "args": "{α : Type u_1} [has_add α] [has_le α] [contravariant_class α α has_add.add has_le.le] {a b c : α} (bc : a + b ≤ a + c)",
    "doc_string": "**Alias** of le_of_mul_le_mul_left'`.",
    "type": "b ≤ c"
  },
  {
    "name": "free_group.reduce.self",
    "statement": "theorem free_group.reduce.self {α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.mk (free_group.reduce L) = free_group.mk L",
    "theorem": "{α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.mk (free_group.reduce L) = free_group.mk L",
    "args": "{α : Type u} {L : list (α × bool)} [decidable_eq α]",
    "doc_string": " A word and its maximal reduction correspond to the same element of the free group.",
    "type": "free_group.mk (free_group.reduce L) = free_group.mk L"
  },
  {
    "name": "is_closed.is_seq_closed",
    "statement": "theorem is_closed.is_seq_closed {X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s) : is_seq_closed s",
    "theorem": "{X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s) : is_seq_closed s",
    "args": "{X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s)",
    "doc_string": "A set is sequentially closed if it is closed.",
    "type": "is_seq_closed s"
  },
  {
    "name": "algebra.norm_eq_zero_iff'",
    "statement": "theorem algebra.norm_eq_zero_iff' {K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] [finite_dimensional K L] {x : L} : ⇑linear_map.det (⇑(algebra.lmul K L) x) = 0 ↔ x = 0",
    "theorem": "{K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] [finite_dimensional K L] {x : L} : ⇑linear_map.det (⇑(algebra.lmul K L) x) = 0 ↔ x = 0",
    "args": "{K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] [finite_dimensional K L] {x : L}",
    "doc_string": "This is `algebra.norm_eq_zero_iff` composed with `algebra.norm_apply`.",
    "type": "⇑linear_map.det (⇑(algebra.lmul K L) x) = 0 ↔ x = 0"
  },
  {
    "name": "padic_val_nat.one",
    "statement": "theorem padic_val_nat.one {p : ℕ} : padic_val_nat p 1 = 0",
    "theorem": "{p : ℕ} : padic_val_nat p 1 = 0",
    "args": "{p : ℕ}",
    "doc_string": "`padic_val_nat p 1` is 0 for any `p`.",
    "type": "padic_val_nat p 1 = 0"
  },
  {
    "name": "subtype.prop",
    "statement": "theorem subtype.prop {α : Sort u_1} {p : α → Prop} (x : subtype p) : p ↑x",
    "theorem": "{α : Sort u_1} {p : α → Prop} (x : subtype p) : p ↑x",
    "args": "{α : Sort u_1} {p : α → Prop} (x : subtype p)",
    "doc_string": "A version of `x.property` or `x.2` where `p` is syntactically applied to the coercion of `x`  instead of `x.1`. A similar result is `subtype.mem` in `data.set.basic`.",
    "type": "p ↑x"
  },
  {
    "name": "continuous_map.continuous_restrict",
    "statement": "theorem continuous_map.continuous_restrict {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (s : set α) : continuous (λ (F : C(α, β)), continuous_map.restrict s F)",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (s : set α) : continuous (λ (F : C(α, β)), continuous_map.restrict s F)",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (s : set α)",
    "doc_string": " For any subset `s` of `α`, the restriction of continuous functions to `s` is continuous as a function from `C(α, β)` to `C(s, β)` with their respective compact-open topologies.",
    "type": "continuous (λ (F : C(α, β)), continuous_map.restrict s F)"
  },
  {
    "name": "matrix.transpose_apply",
    "statement": "theorem matrix.transpose_apply {m : Type u_2} {n : Type u_3} {α : Type v} (M : matrix m n α) (i : m) (j : n) : M.transpose j i = M i j",
    "theorem": "{m : Type u_2} {n : Type u_3} {α : Type v} (M : matrix m n α) (i : m) (j : n) : M.transpose j i = M i j",
    "args": "{m : Type u_2} {n : Type u_3} {α : Type v} (M : matrix m n α) (i : m) (j : n)",
    "doc_string": "Tell `simp` what the entries are in a transposed matrix.  Compare with `mul_apply`, `diagonal_apply_eq`, etc.",
    "type": "M.transpose j i = M i j"
  },
  {
    "name": "topological_add_group.continuous_conj",
    "statement": "theorem topological_add_group.continuous_conj {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G) : continuous (λ (h : G), g + h + -g)",
    "theorem": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G) : continuous (λ (h : G), g + h + -g)",
    "args": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G)",
    "doc_string": "Conjugation by a fixed element is continuous when `add` is continuous.",
    "type": "continuous (λ (h : G), g + h + -g)"
  },
  {
    "name": "finprod_mem_one",
    "statement": "theorem finprod_mem_one {α : Type u_1} {M : Type u_5} [comm_monoid M] (s : set α) : finprod (λ (i : α), finprod (λ (H : i ∈ s), 1)) = 1",
    "theorem": "{α : Type u_1} {M : Type u_5} [comm_monoid M] (s : set α) : finprod (λ (i : α), finprod (λ (H : i ∈ s), 1)) = 1",
    "args": "{α : Type u_1} {M : Type u_5} [comm_monoid M] (s : set α)",
    "doc_string": "The product of the constant function `1` over any set equals `1`.",
    "type": "finprod (λ (i : α), finprod (λ (H : i ∈ s), 1)) = 1"
  },
  {
    "name": "multiples.zero_mem",
    "statement": "theorem multiples.zero_mem {M : Type u_1} [add_monoid M] {x : M} : 0 ∈ multiples x",
    "theorem": "{M : Type u_1} [add_monoid M] {x : M} : 0 ∈ multiples x",
    "args": "{M : Type u_1} [add_monoid M] {x : M}",
    "doc_string": "0 is in the set of natural number multiples of an element of an `add_monoid`.",
    "type": "0 ∈ multiples x"
  },
  {
    "name": "comp_mul_left",
    "statement": "theorem comp_mul_left {α : Type u_1} [semigroup α] (x y : α) : has_mul.mul x ∘ has_mul.mul y = has_mul.mul (x * y)",
    "theorem": "{α : Type u_1} [semigroup α] (x y : α) : has_mul.mul x ∘ has_mul.mul y = has_mul.mul (x * y)",
    "args": "{α : Type u_1} [semigroup α] (x y : α)",
    "doc_string": "Composing two multiplications on the left by `y` then `x` is equal to a multiplication on the left by `x * y`.",
    "type": "has_mul.mul x ∘ has_mul.mul y = has_mul.mul (x * y)"
  },
  {
    "name": "div_div_self",
    "statement": "theorem div_div_self {G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a / (a / a) = a",
    "theorem": "{G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a / (a / a) = a",
    "args": "{G₀ : Type u_2} [group_with_zero G₀] (a : G₀)",
    "doc_string": " Dividing `a` by the result of dividing `a` by itself results in `a` (whether or not `a` is zero).",
    "type": "a / (a / a) = a"
  },
  {
    "name": "closed_embedding.tendsto_cocompact",
    "statement": "theorem closed_embedding.tendsto_cocompact {α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : closed_embedding f) : filter.tendsto f (filter.cocompact α) (filter.cocompact β)",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : closed_embedding f) : filter.tendsto f (filter.cocompact α) (filter.cocompact β)",
    "args": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : closed_embedding f)",
    "doc_string": " A closed embedding is proper, ie, inverse images of compact sets are contained in compacts. Moreover, the preimage of a compact set is compact, see `closed_embedding.is_compact_preimage`.",
    "type": "filter.tendsto f (filter.cocompact α) (filter.cocompact β)"
  },
  {
    "name": "is_countably_spanning.prod",
    "statement": "theorem is_countably_spanning.prod {α : Type u_1} {β : Type u_3} {C : set (set α)} {D : set (set β)} (hC : is_countably_spanning C) (hD : is_countably_spanning D) : is_countably_spanning (set.image2 has_set_prod.prod C D)",
    "theorem": "{α : Type u_1} {β : Type u_3} {C : set (set α)} {D : set (set β)} (hC : is_countably_spanning C) (hD : is_countably_spanning D) : is_countably_spanning (set.image2 has_set_prod.prod C D)",
    "args": "{α : Type u_1} {β : Type u_3} {C : set (set α)} {D : set (set β)} (hC : is_countably_spanning C) (hD : is_countably_spanning D)",
    "doc_string": "Rectangles of countably spanning sets are countably spanning.",
    "type": "is_countably_spanning (set.image2 has_set_prod.prod C D)"
  },
  {
    "name": "finite_field.exists_nonsquare",
    "statement": "theorem finite_field.exists_nonsquare {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a",
    "theorem": "{F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a",
    "args": "{F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2)",
    "doc_string": "In a finite field of odd characteristic, not every element is a square.",
    "type": "∃ (a : F), ¬is_square a"
  },
  {
    "name": "is_extr_on.dual",
    "statement": "theorem is_extr_on.dual {α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_extr_on f s a → is_extr_on (⇑order_dual.to_dual ∘ f) s a",
    "theorem": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_extr_on f s a → is_extr_on (⇑order_dual.to_dual ∘ f) s a",
    "args": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α}",
    "doc_string": "**Alias** of the reverse direction of is_extr_on_dual_iff`.",
    "type": "is_extr_on f s a → is_extr_on (⇑order_dual.to_dual ∘ f) s a"
  },
  {
    "name": "measurable_div_const'",
    "statement": "theorem measurable_div_const' {G : Type u_1} [div_inv_monoid G] [measurable_space G] [has_measurable_mul G] (g : G) : measurable (λ (h : G), h / g)",
    "theorem": "{G : Type u_1} [div_inv_monoid G] [measurable_space G] [has_measurable_mul G] (g : G) : measurable (λ (h : G), h / g)",
    "args": "{G : Type u_1} [div_inv_monoid G] [measurable_space G] [has_measurable_mul G] (g : G)",
    "doc_string": "A version of `measurable_div_const` that assumes `has_measurable_mul` instead of  `has_measurable_div`. This can be nice to avoid unnecessary type-class assumptions.",
    "type": "measurable (λ (h : G), h / g)"
  },
  {
    "name": "emetric.diam_empty",
    "statement": "theorem emetric.diam_empty {α : Type u} [pseudo_emetric_space α] : emetric.diam ∅ = 0",
    "theorem": "{α : Type u} [pseudo_emetric_space α] : emetric.diam ∅ = 0",
    "args": "{α : Type u} [pseudo_emetric_space α]",
    "doc_string": "The diameter of the empty set vanishes",
    "type": "emetric.diam ∅ = 0"
  },
  {
    "name": "rel_hom.coe_fn_injective",
    "statement": "theorem rel_hom.coe_fn_injective {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn",
    "theorem": "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn",
    "args": "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop}",
    "doc_string": "The map `coe_fn : (r →r s) → (α → β)` is injective.",
    "type": "function.injective coe_fn"
  },
  {
    "name": "is_add_hom.id",
    "statement": "theorem is_add_hom.id {α : Type u} [has_add α] : is_add_hom id",
    "theorem": "{α : Type u} [has_add α] : is_add_hom id",
    "args": "{α : Type u} [has_add α]",
    "doc_string": "The identity map preserves addition",
    "type": "is_add_hom id"
  },
  {
    "name": "char_prime_of_ne_zero",
    "statement": "theorem char_prime_of_ne_zero (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : ℕ} [hp : char_p R p] (p_ne_zero : p ≠ 0) : nat.prime p",
    "theorem": "(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : ℕ} [hp : char_p R p] (p_ne_zero : p ≠ 0) : nat.prime p",
    "args": "(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : ℕ} [hp : char_p R p] (p_ne_zero : p ≠ 0)",
    "doc_string": "A helper lemma: the characteristic is prime if it is non-zero.",
    "type": "nat.prime p"
  },
  {
    "name": "has_dvd.dvd.trans",
    "statement": "theorem has_dvd.dvd.trans {α : Type u_1} [semigroup α] {a b c : α} : a ∣ b → b ∣ c → a ∣ c",
    "theorem": "{α : Type u_1} [semigroup α] {a b c : α} : a ∣ b → b ∣ c → a ∣ c",
    "args": "{α : Type u_1} [semigroup α] {a b c : α}",
    "doc_string": "**Alias** of dvd_trans`.",
    "type": "a ∣ b → b ∣ c → a ∣ c"
  },
  {
    "name": "ideal.polynomial_not_is_field",
    "statement": "theorem ideal.polynomial_not_is_field {R : Type u} [ring R] : ¬is_field (polynomial R)",
    "theorem": "{R : Type u} [ring R] : ¬is_field (polynomial R)",
    "args": "{R : Type u} [ring R]",
    "doc_string": "`polynomial R` is never a field for any ring `R`.",
    "type": "¬is_field (polynomial R)"
  },
  {
    "name": "list.sorted_insertion_sort",
    "statement": "theorem list.sorted_insertion_sort {α : Type uu} (r : α → α → Prop) [decidable_rel r] [is_total α r] [is_trans α r] (l : list α) : list.sorted r (list.insertion_sort r l)",
    "theorem": "{α : Type uu} (r : α → α → Prop) [decidable_rel r] [is_total α r] [is_trans α r] (l : list α) : list.sorted r (list.insertion_sort r l)",
    "args": "{α : Type uu} (r : α → α → Prop) [decidable_rel r] [is_total α r] [is_trans α r] (l : list α)",
    "doc_string": "The list `list.insertion_sort r l` is `list.sorted` with respect to `r`.",
    "type": "list.sorted r (list.insertion_sort r l)"
  },
  {
    "name": "function.inv_on_fixed_pts_comp",
    "statement": "theorem function.inv_on_fixed_pts_comp {α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.inv_on f g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.inv_on f g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))",
    "args": "{α : Type u} {β : Type v} (f : α → β) (g : β → α)",
    "doc_string": " Any two maps `f : α → β` and `g : β → α` are inverse of each other on the sets of fixed points of `f ∘ g` and `g ∘ f`, respectively.",
    "type": "set.inv_on f g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))"
  },
  {
    "name": "int.dvd_sub_of_mod_eq",
    "statement": "theorem int.dvd_sub_of_mod_eq {a b c : ℤ} (h : a % b = c) : b ∣ a - c",
    "theorem": "{a b c : ℤ} (h : a % b = c) : b ∣ a - c",
    "args": "{a b c : ℤ} (h : a % b = c)",
    "doc_string": "If `a % b = c` then `b` divides `a - c`.",
    "type": "b ∣ a - c"
  },
  {
    "name": "is_localization.card_le",
    "statement": "theorem is_localization.card_le {R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] : cardinal.mk L ≤ cardinal.mk R",
    "theorem": "{R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] : cardinal.mk L ≤ cardinal.mk R",
    "args": "{R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L]",
    "doc_string": "A localization always has cardinality less than or equal to the base ring.",
    "type": "cardinal.mk L ≤ cardinal.mk R"
  },
  {
    "name": "composition.sigma_eq_iff_blocks_eq",
    "statement": "theorem composition.sigma_eq_iff_blocks_eq {c c' : Σ (n : ℕ), composition n} : c = c' ↔ c.snd.blocks = c'.snd.blocks",
    "theorem": "{c c' : Σ (n : ℕ), composition n} : c = c' ↔ c.snd.blocks = c'.snd.blocks",
    "args": "{c c' : Σ (n : ℕ), composition n}",
    "doc_string": " Two compositions (possibly of different integers) coincide if and only if they have the same sequence of blocks.",
    "type": "c = c' ↔ c.snd.blocks = c'.snd.blocks"
  },
  {
    "name": "has_dvd.dvd.nat_cast",
    "statement": "theorem has_dvd.dvd.nat_cast {α : Type u_1} [semiring α] {m n : ℕ} (h : m ∣ n) : ↑m ∣ ↑n",
    "theorem": "{α : Type u_1} [semiring α] {m n : ℕ} (h : m ∣ n) : ↑m ∣ ↑n",
    "args": "{α : Type u_1} [semiring α] {m n : ℕ} (h : m ∣ n)",
    "doc_string": "**Alias** of nat.coe_nat_dvd`.",
    "type": "↑m ∣ ↑n"
  },
  {
    "name": "uv.is_compressed_self",
    "statement": "theorem uv.is_compressed_self {α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u : α) (s : finset α) : uv.is_compressed u u s",
    "theorem": "{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u : α) (s : finset α) : uv.is_compressed u u s",
    "args": "{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u : α) (s : finset α)",
    "doc_string": "Any family is compressed along two identical elements.",
    "type": "uv.is_compressed u u s"
  },
  {
    "name": "metric.bounded.mono",
    "statement": "theorem metric.bounded.mono {α : Type u} [pseudo_metric_space α] {s t : set α} (incl : s ⊆ t) : metric.bounded t → metric.bounded s",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s t : set α} (incl : s ⊆ t) : metric.bounded t → metric.bounded s",
    "args": "{α : Type u} [pseudo_metric_space α] {s t : set α} (incl : s ⊆ t)",
    "doc_string": "Subsets of a bounded set are also bounded",
    "type": "metric.bounded t → metric.bounded s"
  },
  {
    "name": "is_of_fin_add_order.neg",
    "statement": "theorem is_of_fin_add_order.neg {G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x)",
    "theorem": "{G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x)",
    "args": "{G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x)",
    "doc_string": "Inverses of elements of finite additive order have finite additive order.",
    "type": "is_of_fin_add_order (-x)"
  },
  {
    "name": "gaussian_int.prime_iff_mod_four_eq_three_of_nat_prime",
    "statement": "theorem gaussian_int.prime_iff_mod_four_eq_three_of_nat_prime (p : ℕ) [hp : fact (nat.prime p)] : prime ↑p ↔ p % 4 = 3",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] : prime ↑p ↔ p % 4 = 3",
    "args": "(p : ℕ) [hp : fact (nat.prime p)]",
    "doc_string": "A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4`",
    "type": "prime ↑p ↔ p % 4 = 3"
  },
  {
    "name": "is_unit_iff_not_dvd_char",
    "statement": "theorem is_unit_iff_not_dvd_char (R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R",
    "theorem": "(R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R",
    "args": "(R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)]",
    "doc_string": " A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic.",
    "type": "is_unit ↑p ↔ ¬p ∣ ring_char R"
  },
  {
    "name": "dense.of_closure",
    "statement": "theorem dense.of_closure {α : Type u} [topological_space α] {s : set α} : dense (closure s) → dense s",
    "theorem": "{α : Type u} [topological_space α] {s : set α} : dense (closure s) → dense s",
    "args": "{α : Type u} [topological_space α] {s : set α}",
    "doc_string": "**Alias** of the forward direction of dense_closure`.",
    "type": "dense (closure s) → dense s"
  },
  {
    "name": "is_locally_constant.desc",
    "statement": "theorem is_locally_constant.desc {X : Type u_1} [topological_space X] {α : Type u_2} {β : Type u_3} (f : X → α) (g : α → β) (h : is_locally_constant (g ∘ f)) (inj : function.injective g) : is_locally_constant f",
    "theorem": "{X : Type u_1} [topological_space X] {α : Type u_2} {β : Type u_3} (f : X → α) (g : α → β) (h : is_locally_constant (g ∘ f)) (inj : function.injective g) : is_locally_constant f",
    "args": "{X : Type u_1} [topological_space X] {α : Type u_2} {β : Type u_3} (f : X → α) (g : α → β) (h : is_locally_constant (g ∘ f)) (inj : function.injective g)",
    "doc_string": " If a composition of a function `f` followed by an injection `g` is locally constant, then the locally constant property descends to `f`.",
    "type": "is_locally_constant f"
  },
  {
    "name": "csupr_le",
    "statement": "theorem csupr_le {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), f x ≤ c) : supr f ≤ c",
    "theorem": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), f x ≤ c) : supr f ≤ c",
    "args": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), f x ≤ c)",
    "doc_string": "The indexed supremum of a function is bounded above by a uniform bound",
    "type": "supr f ≤ c"
  },
  {
    "name": "nnreal.geom_mean_le_arith_mean2_weighted",
    "statement": "theorem nnreal.geom_mean_le_arith_mean2_weighted (w₁ w₂ p₁ p₂ : nnreal) : w₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂",
    "theorem": "(w₁ w₂ p₁ p₂ : nnreal) : w₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂",
    "args": "(w₁ w₂ p₁ p₂ : nnreal)",
    "doc_string": " The geometric mean is less than or equal to the arithmetic mean, weighted version for two `nnreal` numbers.",
    "type": "w₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂"
  },
  {
    "name": "int.dvd_of_dvd_mul_right_of_gcd_one",
    "statement": "theorem int.dvd_of_dvd_mul_right_of_gcd_one {a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd b = 1) : a ∣ c",
    "theorem": "{a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd b = 1) : a ∣ c",
    "args": "{a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd b = 1)",
    "doc_string": " Euclid's lemma: if `a ∣ b * c` and `gcd a b = 1` then `a ∣ c`. Compare with `is_coprime.dvd_of_dvd_mul_right` and `unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors`",
    "type": "a ∣ c"
  },
  {
    "name": "real.sq_sin_pi_div_three",
    "statement": "theorem real.sq_sin_pi_div_three  : real.sin (real.pi / 3) ^ 2 = 3 / 4",
    "theorem": " : real.sin (real.pi / 3) ^ 2 = 3 / 4",
    "args": "",
    "doc_string": " The square of the sine of `π / 3` is `3 / 4` (this is sometimes more convenient than the result for cosine itself).",
    "type": "real.sin (real.pi / 3) ^ 2 = 3 / 4"
  },
  {
    "name": "tendsto_inv_at_top_zero'",
    "statement": "theorem tendsto_inv_at_top_zero' {α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (λ (r : α), r⁻¹) filter.at_top (nhds_within 0 (set.Ioi 0))",
    "theorem": "{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (λ (r : α), r⁻¹) filter.at_top (nhds_within 0 (set.Ioi 0))",
    "args": "{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α]",
    "doc_string": "The function `r ↦ r⁻¹` tends to `0` on the right as `r → +∞`.",
    "type": "filter.tendsto (λ (r : α), r⁻¹) filter.at_top (nhds_within 0 (set.Ioi 0))"
  },
  {
    "name": "quaternion_group.quaternion_group_one_is_cyclic",
    "statement": "theorem quaternion_group.quaternion_group_one_is_cyclic  : is_cyclic (quaternion_group 1)",
    "theorem": " : is_cyclic (quaternion_group 1)",
    "args": "",
    "doc_string": "In the special case `n = 1`, `quaternion 1` is a cyclic group (of order `4`).",
    "type": "is_cyclic (quaternion_group 1)"
  },
  {
    "name": "exp_char_is_prime_or_one",
    "statement": "theorem exp_char_is_prime_or_one (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q] : nat.prime q ∨ q = 1",
    "theorem": "(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q] : nat.prime q ∨ q = 1",
    "args": "(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q]",
    "doc_string": "The exponential characteristic is a prime number or one.",
    "type": "nat.prime q ∨ q = 1"
  },
  {
    "name": "commute.mul_left",
    "statement": "theorem commute.mul_left {S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c",
    "theorem": "{S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c",
    "args": "{S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c)",
    "doc_string": "If both `a` and `b` commute with `c`, then their product commutes with `c`.",
    "type": "commute (a * b) c"
  },
  {
    "name": "left.add_pos_of_pos_of_nonneg",
    "statement": "theorem left.add_pos_of_pos_of_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_pos_of_pos_of_nonneg`.",
    "type": "0 < a + b"
  },
  {
    "name": "tsub_tsub_cancel_of_le",
    "statement": "theorem tsub_tsub_cancel_of_le {α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} [contravariant_class α α has_add.add has_le.le] (h : a ≤ b) : b - (b - a) = a",
    "theorem": "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} [contravariant_class α α has_add.add has_le.le] (h : a ≤ b) : b - (b - a) = a",
    "args": "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} [contravariant_class α α has_add.add has_le.le] (h : a ≤ b)",
    "doc_string": "See `tsub_tsub_le` for an inequality.",
    "type": "b - (b - a) = a"
  },
  {
    "name": "euclidean_geometry.cospherical_subset",
    "statement": "theorem euclidean_geometry.cospherical_subset {P : Type u_2} [metric_space P] {ps₁ ps₂ : set P} (hs : ps₁ ⊆ ps₂) (hc : euclidean_geometry.cospherical ps₂) : euclidean_geometry.cospherical ps₁",
    "theorem": "{P : Type u_2} [metric_space P] {ps₁ ps₂ : set P} (hs : ps₁ ⊆ ps₂) (hc : euclidean_geometry.cospherical ps₂) : euclidean_geometry.cospherical ps₁",
    "args": "{P : Type u_2} [metric_space P] {ps₁ ps₂ : set P} (hs : ps₁ ⊆ ps₂) (hc : euclidean_geometry.cospherical ps₂)",
    "doc_string": "A subset of a cospherical set is cospherical.",
    "type": "euclidean_geometry.cospherical ps₁"
  },
  {
    "name": "ennreal.cancel_of_lt'",
    "statement": "theorem ennreal.cancel_of_lt' {a b : ennreal} (h : a < b) : add_le_cancellable a",
    "theorem": "{a b : ennreal} (h : a < b) : add_le_cancellable a",
    "args": "{a b : ennreal} (h : a < b)",
    "doc_string": "This lemma has an abbreviated name because it is used frequently.",
    "type": "add_le_cancellable a"
  },
  {
    "name": "surjective_quot_mk",
    "statement": "theorem surjective_quot_mk {α : Sort u_1} (r : α → α → Prop) : function.surjective (quot.mk r)",
    "theorem": "{α : Sort u_1} (r : α → α → Prop) : function.surjective (quot.mk r)",
    "args": "{α : Sort u_1} (r : α → α → Prop)",
    "doc_string": "`quot.mk r` is a surjective function.",
    "type": "function.surjective (quot.mk r)"
  },
  {
    "name": "pow_eq_pow_mod",
    "statement": "theorem pow_eq_pow_mod {M : Type u_1} [monoid M] {x : M} (m : ℕ) {n : ℕ} (h : x ^ n = 1) : x ^ m = x ^ (m % n)",
    "theorem": "{M : Type u_1} [monoid M] {x : M} (m : ℕ) {n : ℕ} (h : x ^ n = 1) : x ^ m = x ^ (m % n)",
    "args": "{M : Type u_1} [monoid M] {x : M} (m : ℕ) {n : ℕ} (h : x ^ n = 1)",
    "doc_string": "If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)`",
    "type": "x ^ m = x ^ (m % n)"
  },
  {
    "name": "is_add_monoid_hom.is_add_monoid_hom_mul_left",
    "statement": "theorem is_add_monoid_hom.is_add_monoid_hom_mul_left {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y)",
    "theorem": "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y)",
    "args": "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ)",
    "doc_string": "Left multiplication in a ring is an additive monoid morphism.",
    "type": "is_add_monoid_hom (λ (y : γ), x * y)"
  },
  {
    "name": "closure_Iio",
    "statement": "theorem closure_Iio {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_min_order α] : closure (set.Iio a) = set.Iic a",
    "theorem": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_min_order α] : closure (set.Iio a) = set.Iic a",
    "args": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_min_order α]",
    "doc_string": "The closure of the interval `(-∞, a)` is the interval `(-∞, a]`.",
    "type": "closure (set.Iio a) = set.Iic a"
  },
  {
    "name": "add_neg_of_nonpos_of_neg",
    "statement": "theorem add_neg_of_nonpos_of_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0)",
    "doc_string": "**Alias** of `left.add_neg_of_nonpos_of_neg`.",
    "type": "a + b < 0"
  },
  {
    "name": "is_clopen.frontier_eq",
    "statement": "theorem is_clopen.frontier_eq {α : Type u} [topological_space α] {s : set α} : is_clopen s → frontier s = ∅",
    "theorem": "{α : Type u} [topological_space α] {s : set α} : is_clopen s → frontier s = ∅",
    "args": "{α : Type u} [topological_space α] {s : set α}",
    "doc_string": "**Alias** of the forward direction of is_clopen_iff_frontier_eq_empty`.",
    "type": "is_clopen s → frontier s = ∅"
  },
  {
    "name": "is_integrally_closed_iff_is_integral_closure",
    "statement": "theorem is_integrally_closed_iff_is_integral_closure {R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] : is_integrally_closed R ↔ is_integral_closure R R K",
    "theorem": "{R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] : is_integrally_closed R ↔ is_integral_closure R R K",
    "args": "{R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K]",
    "doc_string": "`R` is integrally closed iff it is the integral closure of itself in its field of fractions.",
    "type": "is_integrally_closed R ↔ is_integral_closure R R K"
  },
  {
    "name": "lie_algebra.is_engelian_of_is_noetherian",
    "statement": "theorem lie_algebra.is_engelian_of_is_noetherian {R : Type u₁} {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L",
    "theorem": "{R : Type u₁} {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L",
    "args": "{R : Type u₁} {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L]",
    "doc_string": " *Engel's theorem*.  Note that this implies all traditional forms of Engel's theorem via `lie_module.nontrivial_max_triv_of_is_nilpotent`, `lie_module.is_nilpotent_iff_forall`, `lie_algebra.is_nilpotent_iff_forall`.",
    "type": "lie_algebra.is_engelian R L"
  },
  {
    "name": "matrix.det_fin_one",
    "statement": "theorem matrix.det_fin_one {R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R) : A.det = A 0 0",
    "theorem": "{R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R) : A.det = A 0 0",
    "args": "{R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R)",
    "doc_string": "Determinant of 1x1 matrix",
    "type": "A.det = A 0 0"
  },
  {
    "name": "algebra.finite_presentation.of_finite_type",
    "statement": "theorem algebra.finite_presentation.of_finite_type {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A ↔ algebra.finite_presentation R A",
    "theorem": "{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A ↔ algebra.finite_presentation R A",
    "args": "{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R]",
    "doc_string": " An algebra over a Noetherian ring is finitely generated if and only if it is finitely presented.",
    "type": "algebra.finite_type R A ↔ algebra.finite_presentation R A"
  },
  {
    "name": "is_closed.is_clopenable",
    "statement": "theorem is_closed.is_clopenable {α : Type u_1} [topological_space α] [polish_space α] {s : set α} (hs : is_closed s) : polish_space.is_clopenable s",
    "theorem": "{α : Type u_1} [topological_space α] [polish_space α] {s : set α} (hs : is_closed s) : polish_space.is_clopenable s",
    "args": "{α : Type u_1} [topological_space α] [polish_space α] {s : set α} (hs : is_closed s)",
    "doc_string": " Given a closed set `s` in a Polish space, one can construct a finer Polish topology for which `s` is both open and closed.",
    "type": "polish_space.is_clopenable s"
  },
  {
    "name": "is_atom.dual",
    "statement": "theorem is_atom.dual {α : Type u_1} [preorder α] [order_bot α] {a : α} : is_atom a → is_coatom (⇑order_dual.to_dual a)",
    "theorem": "{α : Type u_1} [preorder α] [order_bot α] {a : α} : is_atom a → is_coatom (⇑order_dual.to_dual a)",
    "args": "{α : Type u_1} [preorder α] [order_bot α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of is_coatom_dual_iff_is_atom`.",
    "type": "is_atom a → is_coatom (⇑order_dual.to_dual a)"
  },
  {
    "name": "real.sinh_strict_mono",
    "statement": "theorem real.sinh_strict_mono  : strict_mono real.sinh",
    "theorem": " : strict_mono real.sinh",
    "args": "",
    "doc_string": "`sinh` is strictly monotone.",
    "type": "strict_mono real.sinh"
  },
  {
    "name": "vadd_right_injective",
    "statement": "theorem vadd_right_injective {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : G), _x +ᵥ p)",
    "theorem": "{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : G), _x +ᵥ p)",
    "args": "{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P)",
    "doc_string": " Adding a group element to the point `p` is an injective function.",
    "type": "function.injective (λ (_x : G), _x +ᵥ p)"
  },
  {
    "name": "equiv.swap_mul_involutive",
    "statement": "theorem equiv.swap_mul_involutive {α : Type u} [decidable_eq α] (i j : α) : function.involutive (has_mul.mul (equiv.swap i j))",
    "theorem": "{α : Type u} [decidable_eq α] (i j : α) : function.involutive (has_mul.mul (equiv.swap i j))",
    "args": "{α : Type u} [decidable_eq α] (i j : α)",
    "doc_string": "A stronger version of `mul_right_injective`",
    "type": "function.involutive (has_mul.mul (equiv.swap i j))"
  },
  {
    "name": "free_group.reduce.red",
    "statement": "theorem free_group.reduce.red {α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.red L (free_group.reduce L)",
    "theorem": "{α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.red L (free_group.reduce L)",
    "args": "{α : Type u} {L : list (α × bool)} [decidable_eq α]",
    "doc_string": " The first theorem that characterises the function `reduce`: a word reduces to its maximal reduction.",
    "type": "free_group.red L (free_group.reduce L)"
  },
  {
    "name": "metric_space.ext",
    "statement": "theorem metric_space.ext {α : Type u_1} {m m' : metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'",
    "theorem": "{α : Type u_1} {m m' : metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'",
    "args": "{α : Type u_1} {m m' : metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist)",
    "doc_string": "Two metric space structures with the same distance coincide.",
    "type": "m = m'"
  },
  {
    "name": "fin.coe_coe_eq_self",
    "statement": "theorem fin.coe_coe_eq_self {n : ℕ} (a : fin (n + 1)) : ↑↑a = a",
    "theorem": "{n : ℕ} (a : fin (n + 1)) : ↑↑a = a",
    "args": "{n : ℕ} (a : fin (n + 1))",
    "doc_string": " Converting a `fin (n + 1)` to `ℕ` and back results in the same value.",
    "type": "↑↑a = a"
  },
  {
    "name": "reflexive.rel_of_ne_imp",
    "statement": "theorem reflexive.rel_of_ne_imp {α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} (hr : x ≠ y → r x y) : r x y",
    "theorem": "{α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} (hr : x ≠ y → r x y) : r x y",
    "args": "{α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} (hr : x ≠ y → r x y)",
    "doc_string": " To show a reflexive relation `r : α → α → Prop` holds over `x y : α`, it suffices to show it holds when `x ≠ y`.",
    "type": "r x y"
  },
  {
    "name": "gold_irrational",
    "statement": "theorem gold_irrational  : irrational golden_ratio",
    "theorem": " : irrational golden_ratio",
    "args": "",
    "doc_string": "The golden ratio is irrational.",
    "type": "irrational golden_ratio"
  },
  {
    "name": "powers.mul_mem",
    "statement": "theorem powers.mul_mem {M : Type u_1} [monoid M] {x y z : M} : y ∈ powers x → z ∈ powers x → y * z ∈ powers x",
    "theorem": "{M : Type u_1} [monoid M] {x y z : M} : y ∈ powers x → z ∈ powers x → y * z ∈ powers x",
    "args": "{M : Type u_1} [monoid M] {x y z : M}",
    "doc_string": "The set of natural number powers of an element of a monoid is closed under multiplication.",
    "type": "y ∈ powers x → z ∈ powers x → y * z ∈ powers x"
  },
  {
    "name": "con.ext",
    "statement": "theorem con.ext {M : Type u_1} [has_mul M] {c d : con M} (H : ∀ (x y : M), ⇑c x y ↔ ⇑d x y) : c = d",
    "theorem": "{M : Type u_1} [has_mul M] {c d : con M} (H : ∀ (x y : M), ⇑c x y ↔ ⇑d x y) : c = d",
    "args": "{M : Type u_1} [has_mul M] {c d : con M} (H : ∀ (x y : M), ⇑c x y ↔ ⇑d x y)",
    "doc_string": "Extensionality rule for congruence relations.",
    "type": "c = d"
  },
  {
    "name": "spectrum.is_unit_resolvent",
    "statement": "theorem spectrum.is_unit_resolvent {R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] {r : R} {a : A} : r ∈ resolvent_set R a ↔ is_unit (resolvent a r)",
    "theorem": "{R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] {r : R} {a : A} : r ∈ resolvent_set R a ↔ is_unit (resolvent a r)",
    "args": "{R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] {r : R} {a : A}",
    "doc_string": "The resolvent is a unit when the argument is in the resolvent set.",
    "type": "r ∈ resolvent_set R a ↔ is_unit (resolvent a r)"
  },
  {
    "name": "eq.trans_lt",
    "statement": "theorem eq.trans_lt {α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b < c) : a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b < c) : a < c",
    "args": "{α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b < c)",
    "doc_string": "**Alias** of lt_of_eq_of_lt`.",
    "type": "a < c"
  },
  {
    "name": "nnreal.young_inequality",
    "statement": "theorem nnreal.young_inequality (a b : nnreal) {p q : nnreal} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1) : a * b ≤ a ^ ↑p / p + b ^ ↑q / q",
    "theorem": "(a b : nnreal) {p q : nnreal} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1) : a * b ≤ a ^ ↑p / p + b ^ ↑q / q",
    "args": "(a b : nnreal) {p q : nnreal} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1)",
    "doc_string": " Young's inequality, `ℝ≥0` version. We use `{p q : ℝ≥0}` in order to avoid constructing witnesses of `0 ≤ p` and `0 ≤ q` for the denominators.",
    "type": "a * b ≤ a ^ ↑p / p + b ^ ↑q / q"
  },
  {
    "name": "list.length_le_sum_of_one_le",
    "statement": "theorem list.length_le_sum_of_one_le (L : list ℕ) (h : ∀ (i : ℕ), i ∈ L → 1 ≤ i) : L.length ≤ L.sum",
    "theorem": "(L : list ℕ) (h : ∀ (i : ℕ), i ∈ L → 1 ≤ i) : L.length ≤ L.sum",
    "args": "(L : list ℕ) (h : ∀ (i : ℕ), i ∈ L → 1 ≤ i)",
    "doc_string": " If all elements in a list are bounded below by `1`, then the length of the list is bounded by the sum of the elements.",
    "type": "L.length ≤ L.sum"
  },
  {
    "name": "is_add_group_hom.neg",
    "statement": "theorem is_add_group_hom.neg {α : Type u_1} {β : Type u_2} [add_group α] [add_comm_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_group_hom (λ (a : α), -f a)",
    "theorem": "{α : Type u_1} {β : Type u_2} [add_group α] [add_comm_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_group_hom (λ (a : α), -f a)",
    "args": "{α : Type u_1} {β : Type u_2} [add_group α] [add_comm_group β] {f : α → β} (hf : is_add_group_hom f)",
    "doc_string": "The negation of an additive group homomorphism is an additive group homomorphism if the target is commutative.",
    "type": "is_add_group_hom (λ (a : α), -f a)"
  },
  {
    "name": "left.one_le_mul",
    "statement": "theorem left.one_le_mul {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.one_le_mul`.",
    "type": "1 ≤ a * b"
  },
  {
    "name": "zmod.legendre_sym_eq_neg_one_iff",
    "statement": "theorem zmod.legendre_sym_eq_neg_one_iff (p : ℕ) [fact (nat.prime p)] {a : ℤ} : zmod.legendre_sym p a = -1 ↔ ¬is_square ↑a",
    "theorem": "(p : ℕ) [fact (nat.prime p)] {a : ℤ} : zmod.legendre_sym p a = -1 ↔ ¬is_square ↑a",
    "args": "(p : ℕ) [fact (nat.prime p)] {a : ℤ}",
    "doc_string": "`legendre_sym p a = -1` iff`a` is a nonsquare mod `p`.",
    "type": "zmod.legendre_sym p a = -1 ↔ ¬is_square ↑a"
  },
  {
    "name": "has_btw.btw.not_sbtw",
    "statement": "theorem has_btw.btw.not_sbtw {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : ¬has_sbtw.sbtw c b a",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : ¬has_sbtw.sbtw c b a",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c)",
    "doc_string": "**Alias** of not_sbtw_of_btw`.",
    "type": "¬has_sbtw.sbtw c b a"
  },
  {
    "name": "star_isometry",
    "statement": "theorem star_isometry {E : Type u_2} [semi_normed_group E] [star_add_monoid E] [normed_star_group E] : isometry has_star.star",
    "theorem": "{E : Type u_2} [semi_normed_group E] [star_add_monoid E] [normed_star_group E] : isometry has_star.star",
    "args": "{E : Type u_2} [semi_normed_group E] [star_add_monoid E] [normed_star_group E]",
    "doc_string": "The `star` map in a normed star group is an isometry",
    "type": "isometry has_star.star"
  },
  {
    "name": "continuous_map.continuous_coe",
    "statement": "theorem continuous_map.continuous_coe {α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] : continuous coe_fn",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] : continuous coe_fn",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β]",
    "doc_string": "See also `continuous_map.continuous_coe'`",
    "type": "continuous coe_fn"
  },
  {
    "name": "left.add_pos'",
    "statement": "theorem left.add_pos' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_pos'`.",
    "type": "0 < a + b"
  },
  {
    "name": "category_theory.limits.has_finite_wide_pushouts_of_has_finite_limits",
    "statement": "theorem category_theory.limits.has_finite_wide_pushouts_of_has_finite_limits (C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_wide_pushouts C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_wide_pushouts C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C]",
    "doc_string": "Finite wide pushouts are finite colimits, so if `C` has all finite colimits, it also has finite wide pushouts",
    "type": "category_theory.limits.has_finite_wide_pushouts C"
  },
  {
    "name": "fin.find_spec",
    "statement": "theorem fin.find_spec {n : ℕ} (p : fin n → Prop) [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p) : p i",
    "theorem": "{n : ℕ} (p : fin n → Prop) [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p) : p i",
    "args": "{n : ℕ} (p : fin n → Prop) [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p)",
    "doc_string": "If `find p = some i`, then `p i` holds",
    "type": "p i"
  },
  {
    "name": "is_ring_hom.id",
    "statement": "theorem is_ring_hom.id {α : Type u} [ring α] : is_ring_hom id",
    "theorem": "{α : Type u} [ring α] : is_ring_hom id",
    "args": "{α : Type u} [ring α]",
    "doc_string": "The identity map is a ring homomorphism.",
    "type": "is_ring_hom id"
  },
  {
    "name": "clifford_algebra_complex.to_complex_involute",
    "statement": "theorem clifford_algebra_complex.to_complex_involute (c : clifford_algebra clifford_algebra_complex.Q) : ⇑clifford_algebra_complex.to_complex (⇑clifford_algebra.involute c) = ⇑(star_ring_end ℂ) (⇑clifford_algebra_complex.to_complex c)",
    "theorem": "(c : clifford_algebra clifford_algebra_complex.Q) : ⇑clifford_algebra_complex.to_complex (⇑clifford_algebra.involute c) = ⇑(star_ring_end ℂ) (⇑clifford_algebra_complex.to_complex c)",
    "args": "(c : clifford_algebra clifford_algebra_complex.Q)",
    "doc_string": "`clifford_algebra.involute` is analogous to `complex.conj`.",
    "type": "⇑clifford_algebra_complex.to_complex (⇑clifford_algebra.involute c) = ⇑(star_ring_end ℂ) (⇑clifford_algebra_complex.to_complex c)"
  },
  {
    "name": "function.bijective.comp_left",
    "statement": "theorem function.bijective.comp_left {α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.bijective g) : function.bijective (function.comp g)",
    "theorem": "{α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.bijective g) : function.bijective (function.comp g)",
    "args": "{α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.bijective g)",
    "doc_string": "Composition by an bijective function on the left is itself bijective.",
    "type": "function.bijective (function.comp g)"
  },
  {
    "name": "int.le_self_pow_two",
    "statement": "theorem int.le_self_pow_two (b : ℤ) : b ≤ b ^ 2",
    "theorem": "(b : ℤ) : b ≤ b ^ 2",
    "args": "(b : ℤ)",
    "doc_string": "**Alias** of int.le_self_sq`.",
    "type": "b ≤ b ^ 2"
  },
  {
    "name": "modular_group.one_lt_norm_sq_T_zpow_smul",
    "statement": "theorem modular_group.one_lt_norm_sq_T_zpow_smul {z : upper_half_plane} (hz : z ∈ modular_group.fdo) (n : ℤ) : 1 < ⇑complex.norm_sq ↑(modular_group.T ^ n • z)",
    "theorem": "{z : upper_half_plane} (hz : z ∈ modular_group.fdo) (n : ℤ) : 1 < ⇑complex.norm_sq ↑(modular_group.T ^ n • z)",
    "args": "{z : upper_half_plane} (hz : z ∈ modular_group.fdo) (n : ℤ)",
    "doc_string": "If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`.",
    "type": "1 < ⇑complex.norm_sq ↑(modular_group.T ^ n • z)"
  },
  {
    "name": "category_theory.limits.initial_mono_class_of_disjoint_coproducts",
    "statement": "theorem category_theory.limits.initial_mono_class_of_disjoint_coproducts {C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C] : category_theory.limits.initial_mono_class C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C] : category_theory.limits.initial_mono_class C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C]",
    "doc_string": " If `C` has disjoint coproducts, any morphism out of initial is mono. Note it isn't true in general that `C` has strict initial objects, for instance consider the category of types and partial functions.",
    "type": "category_theory.limits.initial_mono_class C"
  },
  {
    "name": "polynomial.cyclotomic_pos'",
    "statement": "theorem polynomial.cyclotomic_pos' (n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 < x) : 0 < polynomial.eval x (polynomial.cyclotomic n R)",
    "theorem": "(n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 < x) : 0 < polynomial.eval x (polynomial.cyclotomic n R)",
    "args": "(n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 < x)",
    "doc_string": " Cyclotomic polynomials are always positive on inputs larger than one. Similar to `cyclotomic_pos` but with the condition on the input rather than index of the cyclotomic polynomial.",
    "type": "0 < polynomial.eval x (polynomial.cyclotomic n R)"
  },
  {
    "name": "monoid.closure_mono",
    "statement": "theorem monoid.closure_mono {M : Type u_1} [monoid M] {s t : set M} (h : s ⊆ t) : monoid.closure s ⊆ monoid.closure t",
    "theorem": "{M : Type u_1} [monoid M] {s t : set M} (h : s ⊆ t) : monoid.closure s ⊆ monoid.closure t",
    "args": "{M : Type u_1} [monoid M] {s t : set M} (h : s ⊆ t)",
    "doc_string": "Given subsets `t` and `s` of a monoid `M`, if `s ⊆ t`, the submonoid of `M` generated by `s` is    contained in the submonoid generated by `t`.",
    "type": "monoid.closure s ⊆ monoid.closure t"
  },
  {
    "name": "category_theory.preadditive.has_coequalizers_of_has_cokernels",
    "statement": "theorem category_theory.preadditive.has_coequalizers_of_has_cokernels {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C]",
    "doc_string": "If a preadditive category has all cokernels, then it also has all coequalizers.",
    "type": "category_theory.limits.has_coequalizers C"
  },
  {
    "name": "fintype.nonempty_field_iff",
    "statement": "theorem fintype.nonempty_field_iff {α : Type u_1} [fintype α] : nonempty (field α) ↔ is_prime_pow (fintype.card α)",
    "theorem": "{α : Type u_1} [fintype α] : nonempty (field α) ↔ is_prime_pow (fintype.card α)",
    "args": "{α : Type u_1} [fintype α]",
    "doc_string": "A `fintype` can be given a field structure iff its cardinality is a prime power.",
    "type": "nonempty (field α) ↔ is_prime_pow (fintype.card α)"
  },
  {
    "name": "order_top.bdd_above",
    "statement": "theorem order_top.bdd_above {γ : Type w} [preorder γ] [order_top γ] (s : set γ) : bdd_above s",
    "theorem": "{γ : Type w} [preorder γ] [order_top γ] (s : set γ) : bdd_above s",
    "args": "{γ : Type w} [preorder γ] [order_top γ] (s : set γ)",
    "doc_string": "When there is a global maximum, every set is bounded above.",
    "type": "bdd_above s"
  },
  {
    "name": "emetric.Hausdorff_edist_comm",
    "statement": "theorem emetric.Hausdorff_edist_comm {α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist s t = emetric.Hausdorff_edist t s",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist s t = emetric.Hausdorff_edist t s",
    "args": "{α : Type u} [pseudo_emetric_space α] {s t : set α}",
    "doc_string": "The Haudorff edistances of `s` to `t` and of `t` to `s` coincide",
    "type": "emetric.Hausdorff_edist s t = emetric.Hausdorff_edist t s"
  },
  {
    "name": "one_le_mul",
    "statement": "theorem one_le_mul {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b)",
    "doc_string": "**Alias** of left.one_le_mul`.",
    "type": "1 ≤ a * b"
  },
  {
    "name": "fin.init_update_last",
    "statement": "theorem fin.init_update_last {n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α (fin.last n)) : fin.init (function.update q (fin.last n) z) = fin.init q",
    "theorem": "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α (fin.last n)) : fin.init (function.update q (fin.last n) z) = fin.init q",
    "args": "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α (fin.last n))",
    "doc_string": "Updating the last element of a tuple does not change the beginning.",
    "type": "fin.init (function.update q (fin.last n) z) = fin.init q"
  },
  {
    "name": "has_lt.lt.ne",
    "statement": "theorem has_lt.lt.ne {α : Type u} [preorder α] {a b : α} (h : a < b) : a ≠ b",
    "theorem": "{α : Type u} [preorder α] {a b : α} (h : a < b) : a ≠ b",
    "args": "{α : Type u} [preorder α] {a b : α} (h : a < b)",
    "doc_string": "**Alias** of ne_of_lt`.",
    "type": "a ≠ b"
  },
  {
    "name": "right.mul_lt_one_of_le_of_lt",
    "statement": "theorem right.mul_lt_one_of_le_of_lt {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b < 1)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.mul_lt_one_of_le_of_lt`.",
    "type": "a * b < 1"
  },
  {
    "name": "intermediate_field.map_id",
    "statement": "theorem intermediate_field.map_id {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) : E.map (alg_hom.id K L) = E",
    "theorem": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) : E.map (alg_hom.id K L) = E",
    "args": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L)",
    "doc_string": "Mapping intermediate fields along the identity does not change them",
    "type": "E.map (alg_hom.id K L) = E"
  },
  {
    "name": "cardinal.bdd_above_range",
    "statement": "theorem cardinal.bdd_above_range {ι : Type u} (f : ι → cardinal) : bdd_above (set.range f)",
    "theorem": "{ι : Type u} (f : ι → cardinal) : bdd_above (set.range f)",
    "args": "{ι : Type u} (f : ι → cardinal)",
    "doc_string": "The range of an indexed cardinal function, whose outputs live in a higher universe than the    inputs, is always bounded above.",
    "type": "bdd_above (set.range f)"
  },
  {
    "name": "add_semiconj_by.eq",
    "statement": "theorem add_semiconj_by.eq {S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y) : a + x = y + a",
    "theorem": "{S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y) : a + x = y + a",
    "args": "{S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y)",
    "doc_string": "Equality behind `add_semiconj_by a x y`; useful for rewriting.",
    "type": "a + x = y + a"
  },
  {
    "name": "ultrafilter_converges_iff",
    "statement": "theorem ultrafilter_converges_iff {α : Type u} {u : ultrafilter (ultrafilter α)} {x : ultrafilter α} : ↑u ≤ nhds x ↔ x = mjoin u",
    "theorem": "{α : Type u} {u : ultrafilter (ultrafilter α)} {x : ultrafilter α} : ↑u ≤ nhds x ↔ x = mjoin u",
    "args": "{α : Type u} {u : ultrafilter (ultrafilter α)} {x : ultrafilter α}",
    "doc_string": "Every ultrafilter `u` on `ultrafilter α` converges to a unique  point of `ultrafilter α`, namely `mjoin u`.",
    "type": "↑u ≤ nhds x ↔ x = mjoin u"
  },
  {
    "name": "is_open_map_quotient_mk_mul",
    "statement": "theorem is_open_map_quotient_mk_mul {Γ : Type u_4} [group Γ] {T : Type u_5} [topological_space T] [mul_action Γ T] [has_continuous_const_smul Γ T] : is_open_map quotient.mk",
    "theorem": "{Γ : Type u_4} [group Γ] {T : Type u_5} [topological_space T] [mul_action Γ T] [has_continuous_const_smul Γ T] : is_open_map quotient.mk",
    "args": "{Γ : Type u_4} [group Γ] {T : Type u_5} [topological_space T] [mul_action Γ T] [has_continuous_const_smul Γ T]",
    "doc_string": "The quotient map by a group action is open.",
    "type": "is_open_map quotient.mk"
  },
  {
    "name": "pythagorean_triple.mul_iff",
    "statement": "theorem pythagorean_triple.mul_iff {x y z : ℤ} (k : ℤ) (hk : k ≠ 0) : pythagorean_triple (k * x) (k * y) (k * z) ↔ pythagorean_triple x y z",
    "theorem": "{x y z : ℤ} (k : ℤ) (hk : k ≠ 0) : pythagorean_triple (k * x) (k * y) (k * z) ↔ pythagorean_triple x y z",
    "args": "{x y z : ℤ} (k : ℤ) (hk : k ≠ 0)",
    "doc_string": " `(k*x, k*y, k*z)` is a Pythagorean triple if and only if `(x, y, z)` is also a triple.",
    "type": "pythagorean_triple (k * x) (k * y) (k * z) ↔ pythagorean_triple x y z"
  },
  {
    "name": "fin.coe_val_of_lt",
    "statement": "theorem fin.coe_val_of_lt {n a : ℕ} (h : a < n + 1) : ↑a.val = a",
    "theorem": "{n a : ℕ} (h : a < n + 1) : ↑a.val = a",
    "args": "{n a : ℕ} (h : a < n + 1)",
    "doc_string": " Converting an in-range number to `fin (n + 1)` produces a result whose value is the original number.",
    "type": "↑a.val = a"
  },
  {
    "name": "emetric.inf_edist_le_Hausdorff_edist_of_mem",
    "statement": "theorem emetric.inf_edist_le_Hausdorff_edist_of_mem {α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : x ∈ s) : emetric.inf_edist x t ≤ emetric.Hausdorff_edist s t",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : x ∈ s) : emetric.inf_edist x t ≤ emetric.Hausdorff_edist s t",
    "args": "{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : x ∈ s)",
    "doc_string": "The distance to a set is controlled by the Hausdorff distance",
    "type": "emetric.inf_edist x t ≤ emetric.Hausdorff_edist s t"
  },
  {
    "name": "cardinal.ord_aleph_eq_enum_card",
    "statement": "theorem cardinal.ord_aleph_eq_enum_card  : cardinal.ord ∘ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}",
    "theorem": " : cardinal.ord ∘ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}",
    "args": "",
    "doc_string": "`ord ∘ aleph` enumerates the infinite ordinals that are cardinals.",
    "type": "cardinal.ord ∘ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}"
  },
  {
    "name": "category_theory.limits.has_finite_biproducts.of_has_finite_coproducts",
    "statement": "theorem category_theory.limits.has_finite_biproducts.of_has_finite_coproducts {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C] : category_theory.limits.has_finite_biproducts C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C] : category_theory.limits.has_finite_biproducts C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C]",
    "doc_string": "A preadditive category with finite coproducts has finite biproducts.",
    "type": "category_theory.limits.has_finite_biproducts C"
  },
  {
    "name": "nnreal.tendsto_tsum_compl_at_top_zero",
    "statement": "theorem nnreal.tendsto_tsum_compl_at_top_zero {α : Type u_1} (f : α → nnreal) : filter.tendsto (λ (s : finset α), ∑' (b : {x // x ∉ s}), f ↑b) filter.at_top (nhds 0)",
    "theorem": "{α : Type u_1} (f : α → nnreal) : filter.tendsto (λ (s : finset α), ∑' (b : {x // x ∉ s}), f ↑b) filter.at_top (nhds 0)",
    "args": "{α : Type u_1} (f : α → nnreal)",
    "doc_string": " The sum over the complement of a finset tends to `0` when the finset grows to cover the whole space. This does not need a summability assumption, as otherwise all sums are zero.",
    "type": "filter.tendsto (λ (s : finset α), ∑' (b : {x // x ∉ s}), f ↑b) filter.at_top (nhds 0)"
  },
  {
    "name": "zmod.int_cast_zmod_cast",
    "statement": "theorem zmod.int_cast_zmod_cast {n : ℕ} (a : zmod n) : ↑↑a = a",
    "theorem": "{n : ℕ} (a : zmod n) : ↑↑a = a",
    "args": "{n : ℕ} (a : zmod n)",
    "doc_string": " So-named because the outer coercion is `int.cast` into `zmod`. For `int.cast` into an arbitrary ring, see `zmod.int_cast_cast`.",
    "type": "↑↑a = a"
  },
  {
    "name": "mul_sub_mul_div_mul_neg",
    "statement": "theorem mul_sub_mul_div_mul_neg {α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : a / c < b / d → (a * d - b * c) / (c * d) < 0",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : a / c < b / d → (a * d - b * c) / (c * d) < 0",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0)",
    "doc_string": "**Alias** of the reverse direction of mul_sub_mul_div_mul_neg_iff`.",
    "type": "a / c < b / d → (a * d - b * c) / (c * d) < 0"
  },
  {
    "name": "is_regular.ne_zero",
    "statement": "theorem is_regular.ne_zero {R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a) : a ≠ 0",
    "theorem": "{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a) : a ≠ 0",
    "args": "{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a)",
    "doc_string": "A regular element of a `nontrivial` `mul_zero_class` is non-zero.",
    "type": "a ≠ 0"
  },
  {
    "name": "uniq_inv_of_is_field",
    "statement": "theorem uniq_inv_of_is_field (R : Type u) [ring R] (hf : is_field R) (x : R) : x ≠ 0 → (∃! (y : R), x * y = 1)",
    "theorem": "(R : Type u) [ring R] (hf : is_field R) (x : R) : x ≠ 0 → (∃! (y : R), x * y = 1)",
    "args": "(R : Type u) [ring R] (hf : is_field R) (x : R)",
    "doc_string": " For each field, and for each nonzero element of said field, there is a unique inverse. Since `is_field` doesn't remember the data of an `inv` function and as such, a lemma that there is a unique inverse could be useful.",
    "type": "x ≠ 0 → (∃! (y : R), x * y = 1)"
  },
  {
    "name": "topological_add_group.continuous_conj'",
    "statement": "theorem topological_add_group.continuous_conj' {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G) : continuous (λ (g : G), g + h + -g)",
    "theorem": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G) : continuous (λ (g : G), g + h + -g)",
    "args": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G)",
    "doc_string": "Conjugation acting on fixed element of the additive group is continuous when both   `add` and `neg` are continuous.",
    "type": "continuous (λ (g : G), g + h + -g)"
  },
  {
    "name": "measurable_const'",
    "statement": "theorem measurable_const' {α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] {f : β → α} (hf : ∀ (x y : β), f x = f y) : measurable f",
    "theorem": "{α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] {f : β → α} (hf : ∀ (x y : β), f x = f y) : measurable f",
    "args": "{α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] {f : β → α} (hf : ∀ (x y : β), f x = f y)",
    "doc_string": " A version of `measurable_const` that assumes `f x = f y` for all `x, y`. This version works for functions between empty types.",
    "type": "measurable f"
  },
  {
    "name": "is_open_map_fst",
    "statement": "theorem is_open_map_fst {α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.fst",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.fst",
    "args": "{α : Type u} {β : Type v} [topological_space α] [topological_space β]",
    "doc_string": "The first projection in a product of topological spaces sends open sets to open sets.",
    "type": "is_open_map prod.fst"
  },
  {
    "name": "is_seq_closed.is_closed",
    "statement": "theorem is_seq_closed.is_closed {X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s → is_closed s",
    "theorem": "{X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s → is_closed s",
    "args": "{X : Type u_1} [topological_space X] [sequential_space X] {s : set X}",
    "doc_string": "**Alias** of the forward direction of is_seq_closed_iff_is_closed`.",
    "type": "is_seq_closed s → is_closed s"
  },
  {
    "name": "finset.sum_centroid_weights_eq_one_of_card_eq_add_one",
    "statement": "theorem finset.sum_centroid_weights_eq_one_of_card_eq_add_one (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] {n : ℕ} (h : s.card = n + 1) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1",
    "theorem": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] {n : ℕ} (h : s.card = n + 1) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1",
    "args": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] {n : ℕ} (h : s.card = n + 1)",
    "doc_string": " In the characteristic zero case, the weights in the centroid sum to 1 if the number of points is `n + 1`.",
    "type": "s.sum (λ (i : ι), finset.centroid_weights k s i) = 1"
  },
  {
    "name": "filter.tendsto_abs_at_bot_at_top",
    "statement": "theorem filter.tendsto_abs_at_bot_at_top {α : Type u_3} [linear_ordered_add_comm_group α] : filter.tendsto has_abs.abs filter.at_bot filter.at_top",
    "theorem": "{α : Type u_3} [linear_ordered_add_comm_group α] : filter.tendsto has_abs.abs filter.at_bot filter.at_top",
    "args": "{α : Type u_3} [linear_ordered_add_comm_group α]",
    "doc_string": "$\\lim_{x\\to-\\infty}|x|=+\\infty$",
    "type": "filter.tendsto has_abs.abs filter.at_bot filter.at_top"
  },
  {
    "name": "category_theory.preadditive.has_equalizers_of_has_kernels",
    "statement": "theorem category_theory.preadditive.has_equalizers_of_has_kernels {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C]",
    "doc_string": "If a preadditive category has all kernels, then it also has all equalizers.",
    "type": "category_theory.limits.has_equalizers C"
  },
  {
    "name": "antitone_on.dual_right",
    "statement": "theorem antitone_on.dual_right {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : antitone_on f s → monotone_on (⇑order_dual.to_dual ∘ f) s",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : antitone_on f s → monotone_on (⇑order_dual.to_dual ∘ f) s",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α}",
    "doc_string": "**Alias** of the reverse direction of monotone_on_to_dual_comp_iff`.",
    "type": "antitone_on f s → monotone_on (⇑order_dual.to_dual ∘ f) s"
  },
  {
    "name": "is_regular_of_cancel_monoid",
    "statement": "theorem is_regular_of_cancel_monoid {R : Type u_1} [cancel_monoid R] (g : R) : is_regular g",
    "theorem": "{R : Type u_1} [cancel_monoid R] (g : R) : is_regular g",
    "args": "{R : Type u_1} [cancel_monoid R] (g : R)",
    "doc_string": "Elements of a cancel monoid are regular.  Cancel semigroups do not appear to exist.",
    "type": "is_regular g"
  },
  {
    "name": "is_add_monoid_hom.neg",
    "statement": "theorem is_add_monoid_hom.neg {α : Type u_1} {β : Type u_2} [add_zero_class α] [add_comm_group β] {f : α → β} (hf : is_add_monoid_hom f) : is_add_monoid_hom (λ (a : α), -f a)",
    "theorem": "{α : Type u_1} {β : Type u_2} [add_zero_class α] [add_comm_group β] {f : α → β} (hf : is_add_monoid_hom f) : is_add_monoid_hom (λ (a : α), -f a)",
    "args": "{α : Type u_1} {β : Type u_2} [add_zero_class α] [add_comm_group β] {f : α → β} (hf : is_add_monoid_hom f)",
    "doc_string": "The negation of a map which preserves addition, preserves addition when the target is commutative.",
    "type": "is_add_monoid_hom (λ (a : α), -f a)"
  },
  {
    "name": "dense_inducing.separable_space",
    "statement": "theorem dense_inducing.separable_space {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {i : α → β} (di : dense_inducing i) [topological_space.separable_space α] : topological_space.separable_space β",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {i : α → β} (di : dense_inducing i) [topological_space.separable_space α] : topological_space.separable_space β",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {i : α → β} (di : dense_inducing i) [topological_space.separable_space α]",
    "doc_string": "If the domain of a `dense_inducing` map is a separable space, then so is the codomain.",
    "type": "topological_space.separable_space β"
  },
  {
    "name": "zero_hom.ext_iff",
    "statement": "theorem zero_hom.ext_iff {M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N} : f = g ↔ ∀ (x : M), ⇑f x = ⇑g x",
    "theorem": "{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N} : f = g ↔ ∀ (x : M), ⇑f x = ⇑g x",
    "args": "{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N}",
    "doc_string": "Deprecated: use `fun_like.ext_iff` instead.",
    "type": "f = g ↔ ∀ (x : M), ⇑f x = ⇑g x"
  },
  {
    "name": "funext",
    "statement": "theorem funext {α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x} (h : ∀ (x : α), f₁ x = f₂ x) : f₁ = f₂",
    "theorem": "{α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x} (h : ∀ (x : α), f₁ x = f₂ x) : f₁ = f₂",
    "args": "{α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x} (h : ∀ (x : α), f₁ x = f₂ x)",
    "doc_string": "Function extensionality, proven using quotients.",
    "type": "f₁ = f₂"
  },
  {
    "name": "zmod.legendre_sym_eq_pow",
    "statement": "theorem zmod.legendre_sym_eq_pow (p : ℕ) (a : ℤ) [hp : fact (nat.prime p)] : ↑(zmod.legendre_sym p a) = ↑a ^ (p / 2)",
    "theorem": "(p : ℕ) (a : ℤ) [hp : fact (nat.prime p)] : ↑(zmod.legendre_sym p a) = ↑a ^ (p / 2)",
    "args": "(p : ℕ) (a : ℤ) [hp : fact (nat.prime p)]",
    "doc_string": "We have the congruence `legendre_sym p a ≡ a ^ (p / 2) mod p`.",
    "type": "↑(zmod.legendre_sym p a) = ↑a ^ (p / 2)"
  },
  {
    "name": "right.one_lt_mul_of_lt_of_le",
    "statement": "theorem right.one_lt_mul_of_lt_of_le {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 ≤ b)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul_of_lt_of_le`.",
    "type": "1 < a * b"
  },
  {
    "name": "neg_le_self",
    "statement": "theorem neg_le_self {α : Type u} [add_group α] [preorder α] [covariant_class α α has_add.add has_le.le] {a : α} (h : 0 ≤ a) : -a ≤ a",
    "theorem": "{α : Type u} [add_group α] [preorder α] [covariant_class α α has_add.add has_le.le] {a : α} (h : 0 ≤ a) : -a ≤ a",
    "args": "{α : Type u} [add_group α] [preorder α] [covariant_class α α has_add.add has_le.le] {a : α} (h : 0 ≤ a)",
    "doc_string": "**Alias** of left.neg_le_self`.",
    "type": "-a ≤ a"
  },
  {
    "name": "padic_val_nat.zero",
    "statement": "theorem padic_val_nat.zero {p : ℕ} : padic_val_nat p 0 = 0",
    "theorem": "{p : ℕ} : padic_val_nat p 0 = 0",
    "args": "{p : ℕ}",
    "doc_string": "`padic_val_nat p 0` is 0 for any `p`.",
    "type": "padic_val_nat p 0 = 0"
  },
  {
    "name": "power_series.order_X_pow",
    "statement": "theorem power_series.order_X_pow {R : Type u_1} [semiring R] [nontrivial R] (n : ℕ) : (power_series.X ^ n).order = ↑n",
    "theorem": "{R : Type u_1} [semiring R] [nontrivial R] (n : ℕ) : (power_series.X ^ n).order = ↑n",
    "args": "{R : Type u_1} [semiring R] [nontrivial R] (n : ℕ)",
    "doc_string": "The order of the formal power series `X^n` is `n`.",
    "type": "(power_series.X ^ n).order = ↑n"
  },
  {
    "name": "category_theory.exact_inr_fst",
    "statement": "theorem category_theory.exact_inr_fst {𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜) : category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst",
    "theorem": "{𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜) : category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst",
    "args": "{𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜)",
    "doc_string": "The sequence `B ⟶ A ⊞ B ⟶ A` is exact.",
    "type": "category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst"
  },
  {
    "name": "module.subsingleton",
    "statement": "theorem module.subsingleton (R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M] : subsingleton M",
    "theorem": "(R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M] : subsingleton M",
    "args": "(R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M]",
    "doc_string": " A module over a `subsingleton` semiring is a `subsingleton`. We cannot register this as an instance because Lean has no way to guess `R`.",
    "type": "subsingleton M"
  },
  {
    "name": "power_series.order_monomial_of_ne_zero",
    "statement": "theorem power_series.order_monomial_of_ne_zero {R : Type u_1} [semiring R] (n : ℕ) (a : R) (h : a ≠ 0) : (⇑(power_series.monomial R n) a).order = ↑n",
    "theorem": "{R : Type u_1} [semiring R] (n : ℕ) (a : R) (h : a ≠ 0) : (⇑(power_series.monomial R n) a).order = ↑n",
    "args": "{R : Type u_1} [semiring R] (n : ℕ) (a : R) (h : a ≠ 0)",
    "doc_string": "The order of the monomial `a*X^n` is `n` if `a ≠ 0`.",
    "type": "(⇑(power_series.monomial R n) a).order = ↑n"
  },
  {
    "name": "topological_space.positive_compacts.locally_compact_space_of_group",
    "statement": "theorem topological_space.positive_compacts.locally_compact_space_of_group {G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G",
    "theorem": "{G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G",
    "args": "{G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G)",
    "doc_string": " Every separated topological group in which there exists a compact set with nonempty interior is locally compact.",
    "type": "locally_compact_space G"
  },
  {
    "name": "has_lt.lt.not_lt",
    "statement": "theorem has_lt.lt.not_lt {α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b < a",
    "theorem": "{α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b < a",
    "args": "{α : Type u} [preorder α] {a b : α} (h : a < b)",
    "doc_string": "**Alias** of lt_asymm`.",
    "type": "¬b < a"
  },
  {
    "name": "polynomial.cyclotomic_ne_zero",
    "statement": "theorem polynomial.cyclotomic_ne_zero (n : ℕ) (R : Type u_1) [ring R] [nontrivial R] : polynomial.cyclotomic n R ≠ 0",
    "theorem": "(n : ℕ) (R : Type u_1) [ring R] [nontrivial R] : polynomial.cyclotomic n R ≠ 0",
    "args": "(n : ℕ) (R : Type u_1) [ring R] [nontrivial R]",
    "doc_string": "`cyclotomic n R` is different from `0`.",
    "type": "polynomial.cyclotomic n R ≠ 0"
  },
  {
    "name": "neg_neg_iff_pos",
    "statement": "theorem neg_neg_iff_pos {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 ↔ 0 < a",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 ↔ 0 < a",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α}",
    "doc_string": "**Alias** of left.inv_lt_one_iff`.",
    "type": "-a < 0 ↔ 0 < a"
  },
  {
    "name": "is_add_left_regular.of_add",
    "statement": "theorem is_add_left_regular.of_add {R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b)) : is_add_left_regular b",
    "theorem": "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b)) : is_add_left_regular b",
    "args": "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b))",
    "doc_string": "If an element `b` becomes add-left-regular after adding to it on the left a add-left-regular element, then `b` is add-left-regular.",
    "type": "is_add_left_regular b"
  },
  {
    "name": "witt_vector.ghost_component_teichmuller",
    "statement": "theorem witt_vector.ghost_component_teichmuller (p : ℕ) {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (r : R) (n : ℕ) : ⇑(witt_vector.ghost_component n) (⇑(witt_vector.teichmuller p) r) = r ^ p ^ n",
    "theorem": "(p : ℕ) {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (r : R) (n : ℕ) : ⇑(witt_vector.ghost_component n) (⇑(witt_vector.teichmuller p) r) = r ^ p ^ n",
    "args": "(p : ℕ) {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (r : R) (n : ℕ)",
    "doc_string": "The `n`-th ghost component of `teichmuller p r` is `r ^ p ^ n`.",
    "type": "⇑(witt_vector.ghost_component n) (⇑(witt_vector.teichmuller p) r) = r ^ p ^ n"
  },
  {
    "name": "nat.exists_strict_anti",
    "statement": "theorem nat.exists_strict_anti (α : Type u) [preorder α] [nonempty α] [no_min_order α] : ∃ (f : ℕ → α), strict_anti f",
    "theorem": "(α : Type u) [preorder α] [nonempty α] [no_min_order α] : ∃ (f : ℕ → α), strict_anti f",
    "args": "(α : Type u) [preorder α] [nonempty α] [no_min_order α]",
    "doc_string": " If `α` is a nonempty preorder with no minimal elements, then there exists a strictly antitone function `ℕ → α`.",
    "type": "∃ (f : ℕ → α), strict_anti f"
  },
  {
    "name": "free_group.red.church_rosser",
    "statement": "theorem free_group.red.church_rosser {α : Type u} {L₁ L₂ L₃ : list (α × bool)} : free_group.red L₁ L₂ → free_group.red L₁ L₃ → relation.join free_group.red L₂ L₃",
    "theorem": "{α : Type u} {L₁ L₂ L₃ : list (α × bool)} : free_group.red L₁ L₂ → free_group.red L₁ L₃ → relation.join free_group.red L₂ L₃",
    "args": "{α : Type u} {L₁ L₂ L₃ : list (α × bool)}",
    "doc_string": " **Church-Rosser theorem** for word reduction: If `w1 w2 w3` are words such that `w1` reduces to `w2` and `w3` respectively, then there is a word `w4` such that `w2` and `w3` reduce to `w4` respectively. This is also known as Newman's diamond lemma.",
    "type": "free_group.red L₁ L₂ → free_group.red L₁ L₃ → relation.join free_group.red L₂ L₃"
  },
  {
    "name": "is_left_regular.mul",
    "statement": "theorem is_left_regular.mul {R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b) : is_left_regular (a * b)",
    "theorem": "{R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b) : is_left_regular (a * b)",
    "args": "{R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b)",
    "doc_string": "In a semigroup, the product of left-regular elements is left-regular.",
    "type": "is_left_regular (a * b)"
  },
  {
    "name": "affine_subspace.top_coe",
    "statement": "theorem affine_subspace.top_coe (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ↑⊤ = set.univ",
    "theorem": "(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ↑⊤ = set.univ",
    "args": "(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P]",
    "doc_string": "`⊤`, coerced to a set, is the whole set of points.",
    "type": "↑⊤ = set.univ"
  },
  {
    "name": "is_left_regular_of_left_cancel_semigroup",
    "statement": "theorem is_left_regular_of_left_cancel_semigroup {R : Type u_1} [left_cancel_semigroup R] (g : R) : is_left_regular g",
    "theorem": "{R : Type u_1} [left_cancel_semigroup R] (g : R) : is_left_regular g",
    "args": "{R : Type u_1} [left_cancel_semigroup R] (g : R)",
    "doc_string": "Elements of a left cancel semigroup are left regular.",
    "type": "is_left_regular g"
  },
  {
    "name": "is_topological_fiber_bundle.is_open_map_proj",
    "statement": "theorem is_topological_fiber_bundle.is_open_map_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : is_open_map proj",
    "theorem": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : is_open_map proj",
    "args": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] (h : is_topological_fiber_bundle F proj)",
    "doc_string": "The projection from a topological fiber bundle to its base is an open map.",
    "type": "is_open_map proj"
  },
  {
    "name": "category_theory.limits.has_binary_biproducts.of_has_binary_products",
    "statement": "theorem category_theory.limits.has_binary_biproducts.of_has_binary_products {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C] : category_theory.limits.has_binary_biproducts C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C] : category_theory.limits.has_binary_biproducts C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C]",
    "doc_string": "In a preadditive category, if all binary products exist, then all binary biproducts exist.",
    "type": "category_theory.limits.has_binary_biproducts C"
  },
  {
    "name": "add_neg'",
    "statement": "theorem add_neg' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0)",
    "doc_string": "**Alias** of `left.add_neg'`.",
    "type": "a + b < 0"
  },
  {
    "name": "edist_nndist",
    "statement": "theorem edist_nndist {α : Type u} [pseudo_metric_space α] (x y : α) : has_edist.edist x y = ↑(has_nndist.nndist x y)",
    "theorem": "{α : Type u} [pseudo_metric_space α] (x y : α) : has_edist.edist x y = ↑(has_nndist.nndist x y)",
    "args": "{α : Type u} [pseudo_metric_space α] (x y : α)",
    "doc_string": "Express `edist` in terms of `nndist`",
    "type": "has_edist.edist x y = ↑(has_nndist.nndist x y)"
  },
  {
    "name": "category_theory.limits.finite_limits_from_equalizers_and_finite_products",
    "statement": "theorem category_theory.limits.finite_limits_from_equalizers_and_finite_products {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_finite_limits C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_finite_limits C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_equalizers C]",
    "doc_string": "Any category with finite products and equalizers has all finite limits.  See <https://stacks.math.columbia.edu/tag/002O>.",
    "type": "category_theory.limits.has_finite_limits C"
  },
  {
    "name": "is_submonoid.power_subset",
    "statement": "theorem is_submonoid.power_subset {M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a ∈ s) : powers a ⊆ s",
    "theorem": "{M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a ∈ s) : powers a ⊆ s",
    "args": "{M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a ∈ s)",
    "doc_string": "The set of natural number powers of an element of a submonoid is a subset of the submonoid.",
    "type": "powers a ⊆ s"
  },
  {
    "name": "has_lt.lt.trans",
    "statement": "theorem has_lt.lt.trans {α : Type u} [preorder α] {a b c : α} : a < b → b < c → a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : a < b → b < c → a < c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of lt_trans`.",
    "type": "a < b → b < c → a < c"
  },
  {
    "name": "even.neg",
    "statement": "theorem even.neg {α : Type u_2} [subtraction_monoid α] {a : α} : even a → even (-a)",
    "theorem": "{α : Type u_2} [subtraction_monoid α] {a : α} : even a → even (-a)",
    "args": "{α : Type u_2} [subtraction_monoid α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of is_square_inv`.",
    "type": "even a → even (-a)"
  },
  {
    "name": "free_group.reduce.idem",
    "statement": "theorem free_group.reduce.idem {α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.reduce (free_group.reduce L) = free_group.reduce L",
    "theorem": "{α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.reduce (free_group.reduce L) = free_group.reduce L",
    "args": "{α : Type u} {L : list (α × bool)} [decidable_eq α]",
    "doc_string": " `reduce` is idempotent, i.e. the maximal reduction of the maximal reduction of a word is the maximal reduction of the word.",
    "type": "free_group.reduce (free_group.reduce L) = free_group.reduce L"
  },
  {
    "name": "filter.tendsto_neg_cobounded",
    "statement": "theorem filter.tendsto_neg_cobounded {E : Type u_3} [semi_normed_group E] : filter.tendsto has_neg.neg (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)",
    "theorem": "{E : Type u_3} [semi_normed_group E] : filter.tendsto has_neg.neg (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)",
    "args": "{E : Type u_3} [semi_normed_group E]",
    "doc_string": " In a (semi)normed group, negation `x ↦ -x` tends to infinity at infinity. TODO: use `bornology.cobounded` instead of `filter.comap has_norm.norm filter.at_top`.",
    "type": "filter.tendsto has_neg.neg (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)"
  },
  {
    "name": "field.nonempty_iff",
    "statement": "theorem field.nonempty_iff {α : Type u} : nonempty (field α) ↔ is_prime_pow (cardinal.mk α)",
    "theorem": "{α : Type u} : nonempty (field α) ↔ is_prime_pow (cardinal.mk α)",
    "args": "{α : Type u}",
    "doc_string": "There is a field structure on type if and only if its cardinality is a prime power.",
    "type": "nonempty (field α) ↔ is_prime_pow (cardinal.mk α)"
  },
  {
    "name": "add_commute.add_left",
    "statement": "theorem add_commute.add_left {S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c) : add_commute (a + b) c",
    "theorem": "{S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c) : add_commute (a + b) c",
    "args": "{S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c)",
    "doc_string": "If both `a` and `b` commute with `c`, then their product commutes with `c`.",
    "type": "add_commute (a + b) c"
  },
  {
    "name": "normed_group.core.to_semi_normed_group.core",
    "statement": "theorem normed_group.core.to_semi_normed_group.core {E : Type u_1} [add_comm_group E] [has_norm E] (C : normed_group.core E) : semi_normed_group.core E",
    "theorem": "{E : Type u_1} [add_comm_group E] [has_norm E] (C : normed_group.core E) : semi_normed_group.core E",
    "args": "{E : Type u_1} [add_comm_group E] [has_norm E] (C : normed_group.core E)",
    "doc_string": "The `semi_normed_group.core` induced by a `normed_group.core`.",
    "type": "semi_normed_group.core E"
  },
  {
    "name": "even.exists_bit0",
    "statement": "theorem even.exists_bit0 {α : Type u_2} [has_add α] {a : α} : even a → (∃ (b : α), a = bit0 b)",
    "theorem": "{α : Type u_2} [has_add α] {a : α} : even a → (∃ (b : α), a = bit0 b)",
    "args": "{α : Type u_2} [has_add α] {a : α}",
    "doc_string": "**Alias** of the forward direction of even_iff_exists_bit0`.",
    "type": "even a → (∃ (b : α), a = bit0 b)"
  },
  {
    "name": "emetric.Hausdorff_edist_triangle",
    "statement": "theorem emetric.Hausdorff_edist_triangle {α : Type u} [pseudo_emetric_space α] {s t u : set α} : emetric.Hausdorff_edist s u ≤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {s t u : set α} : emetric.Hausdorff_edist s u ≤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u",
    "args": "{α : Type u} [pseudo_emetric_space α] {s t u : set α}",
    "doc_string": "The Hausdorff distance satisfies the triangular inequality",
    "type": "emetric.Hausdorff_edist s u ≤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u"
  },
  {
    "name": "topological_fiber_bundle_core.continuous_proj",
    "statement": "theorem topological_fiber_bundle_core.continuous_proj {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : continuous Z.proj",
    "theorem": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : continuous Z.proj",
    "args": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F)",
    "doc_string": "The projection on the base of a topological bundle created from core is continuous",
    "type": "continuous Z.proj"
  },
  {
    "name": "ennreal.cancel_coe",
    "statement": "theorem ennreal.cancel_coe {a : nnreal} : add_le_cancellable ↑a",
    "theorem": "{a : nnreal} : add_le_cancellable ↑a",
    "args": "{a : nnreal}",
    "doc_string": "This lemma has an abbreviated name because it is used frequently.",
    "type": "add_le_cancellable ↑a"
  },
  {
    "name": "lie_algebra.subsingleton_of_semisimple_lie_abelian",
    "statement": "theorem lie_algebra.subsingleton_of_semisimple_lie_abelian (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L] : subsingleton L",
    "theorem": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L] : subsingleton L",
    "args": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L]",
    "doc_string": "A semisimple Abelian Lie algebra is trivial.",
    "type": "subsingleton L"
  },
  {
    "name": "triple_product_permutation",
    "statement": "theorem triple_product_permutation {R : Type u_1} [comm_ring R] (u v w : fin 3 → R) : matrix.dot_product u (⇑(⇑cross_product v) w) = matrix.dot_product v (⇑(⇑cross_product w) u)",
    "theorem": "{R : Type u_1} [comm_ring R] (u v w : fin 3 → R) : matrix.dot_product u (⇑(⇑cross_product v) w) = matrix.dot_product v (⇑(⇑cross_product w) u)",
    "args": "{R : Type u_1} [comm_ring R] (u v w : fin 3 → R)",
    "doc_string": "Cyclic permutations preserve the triple product. See also `triple_product_eq_det`.",
    "type": "matrix.dot_product u (⇑(⇑cross_product v) w) = matrix.dot_product v (⇑(⇑cross_product w) u)"
  },
  {
    "name": "padic_val_nat.self",
    "statement": "theorem padic_val_nat.self {p : ℕ} (hp : 1 < p) : padic_val_nat p p = 1",
    "theorem": "{p : ℕ} (hp : 1 < p) : padic_val_nat p p = 1",
    "args": "{p : ℕ} (hp : 1 < p)",
    "doc_string": "For `p ≠ 0, p ≠ 1, `padic_val_rat p p` is 1.",
    "type": "padic_val_nat p p = 1"
  },
  {
    "name": "is_right_regular.subsingleton",
    "statement": "theorem is_right_regular.subsingleton {R : Type u_1} [mul_zero_class R] (h : is_right_regular 0) : subsingleton R",
    "theorem": "{R : Type u_1} [mul_zero_class R] (h : is_right_regular 0) : subsingleton R",
    "args": "{R : Type u_1} [mul_zero_class R] (h : is_right_regular 0)",
    "doc_string": "The element `0` is right-regular if and only if `R` is trivial.",
    "type": "subsingleton R"
  },
  {
    "name": "antitone.dual_right",
    "statement": "theorem antitone.dual_right {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : antitone f → monotone (⇑order_dual.to_dual ∘ f)",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : antitone f → monotone (⇑order_dual.to_dual ∘ f)",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β}",
    "doc_string": "**Alias** of the reverse direction of monotone_to_dual_comp_iff`.",
    "type": "antitone f → monotone (⇑order_dual.to_dual ∘ f)"
  },
  {
    "name": "charted_space_self_atlas",
    "statement": "theorem charted_space_self_atlas {H : Type u_1} [topological_space H] {e : local_homeomorph H H} : e ∈ charted_space.atlas H H ↔ e = local_homeomorph.refl H",
    "theorem": "{H : Type u_1} [topological_space H] {e : local_homeomorph H H} : e ∈ charted_space.atlas H H ↔ e = local_homeomorph.refl H",
    "args": "{H : Type u_1} [topological_space H] {e : local_homeomorph H H}",
    "doc_string": " In the trivial charted_space structure of a space modelled over itself through the identity, the atlas members are just the identity",
    "type": "e ∈ charted_space.atlas H H ↔ e = local_homeomorph.refl H"
  },
  {
    "name": "category_theory.limits.has_finite_wide_pullbacks_of_has_finite_limits",
    "statement": "theorem category_theory.limits.has_finite_wide_pullbacks_of_has_finite_limits (C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_wide_pullbacks C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_wide_pullbacks C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C]",
    "doc_string": "Finite wide pullbacks are finite limits, so if `C` has all finite limits, it also has finite wide pullbacks",
    "type": "category_theory.limits.has_finite_wide_pullbacks C"
  },
  {
    "name": "cInf_singleton",
    "statement": "theorem cInf_singleton {α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Inf.Inf {a} = a",
    "theorem": "{α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Inf.Inf {a} = a",
    "args": "{α : Type u_1} [conditionally_complete_lattice α] (a : α)",
    "doc_string": "The infimum of a singleton is the element of the singleton",
    "type": "has_Inf.Inf {a} = a"
  },
  {
    "name": "is_regular_iff_subsingleton",
    "statement": "theorem is_regular_iff_subsingleton {R : Type u_1} [mul_zero_class R] : is_regular 0 ↔ subsingleton R",
    "theorem": "{R : Type u_1} [mul_zero_class R] : is_regular 0 ↔ subsingleton R",
    "args": "{R : Type u_1} [mul_zero_class R]",
    "doc_string": "The element `0` is regular if and only if `R` is trivial.",
    "type": "is_regular 0 ↔ subsingleton R"
  },
  {
    "name": "category_theory.limits.has_finite_products_of_has_products",
    "statement": "theorem category_theory.limits.has_finite_products_of_has_products (C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : category_theory.limits.has_finite_products C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : category_theory.limits.has_finite_products C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_products C]",
    "doc_string": "If a category has all products then in particular it has finite products.",
    "type": "category_theory.limits.has_finite_products C"
  },
  {
    "name": "holor.slice_eq",
    "statement": "theorem holor.slice_eq {α : Type} {d : ℕ} {ds : list ℕ} (x y : holor α (d :: ds)) (h : x.slice = y.slice) : x = y",
    "theorem": "{α : Type} {d : ℕ} {ds : list ℕ} (x y : holor α (d :: ds)) (h : x.slice = y.slice) : x = y",
    "args": "{α : Type} {d : ℕ} {ds : list ℕ} (x y : holor α (d :: ds)) (h : x.slice = y.slice)",
    "doc_string": "Two holors are equal if all their slices are equal.",
    "type": "x = y"
  },
  {
    "name": "ordered_comm_group.le_of_mul_le_mul_left",
    "statement": "theorem ordered_comm_group.le_of_mul_le_mul_left {α : Type u_1} [has_mul α] [has_le α] [contravariant_class α α has_mul.mul has_le.le] {a b c : α} (bc : a * b ≤ a * c) : b ≤ c",
    "theorem": "{α : Type u_1} [has_mul α] [has_le α] [contravariant_class α α has_mul.mul has_le.le] {a b c : α} (bc : a * b ≤ a * c) : b ≤ c",
    "args": "{α : Type u_1} [has_mul α] [has_le α] [contravariant_class α α has_mul.mul has_le.le] {a b c : α} (bc : a * b ≤ a * c)",
    "doc_string": "**Alias** of le_of_mul_le_mul_left'`.",
    "type": "b ≤ c"
  },
  {
    "name": "charpoly_left_mul_matrix",
    "statement": "theorem charpoly_left_mul_matrix {K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] (h : power_basis K S) : (⇑(algebra.left_mul_matrix h.basis) h.gen).charpoly = minpoly K h.gen",
    "theorem": "{K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] (h : power_basis K S) : (⇑(algebra.left_mul_matrix h.basis) h.gen).charpoly = minpoly K h.gen",
    "args": "{K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] (h : power_basis K S)",
    "doc_string": " The characteristic polynomial of the map `λ x, a * x` is the minimal polynomial of `a`.  In combination with `det_eq_sign_charpoly_coeff` or `trace_eq_neg_charpoly_coeff` and a bit of rewriting, this will allow us to conclude the field norm resp. trace of `x` is the product resp. sum of `x`'s conjugates.",
    "type": "(⇑(algebra.left_mul_matrix h.basis) h.gen).charpoly = minpoly K h.gen"
  },
  {
    "name": "metric.diam_empty",
    "statement": "theorem metric.diam_empty {α : Type u} [pseudo_metric_space α] : metric.diam ∅ = 0",
    "theorem": "{α : Type u} [pseudo_metric_space α] : metric.diam ∅ = 0",
    "args": "{α : Type u} [pseudo_metric_space α]",
    "doc_string": "The empty set has zero diameter",
    "type": "metric.diam ∅ = 0"
  },
  {
    "name": "dense_range.separable_space",
    "statement": "theorem dense_range.separable_space {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space.separable_space α] [topological_space β] {f : α → β} (h : dense_range f) (h' : continuous f) : topological_space.separable_space β",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space.separable_space α] [topological_space β] {f : α → β} (h : dense_range f) (h' : continuous f) : topological_space.separable_space β",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space.separable_space α] [topological_space β] {f : α → β} (h : dense_range f) (h' : continuous f)",
    "doc_string": " If `α` is a separable space and `f : α → β` is a continuous map with dense range, then `β` is a separable space as well. E.g., the completion of a separable uniform space is separable.",
    "type": "topological_space.separable_space β"
  },
  {
    "name": "zmod.pow_card_sub_one_eq_one",
    "statement": "theorem zmod.pow_card_sub_one_eq_one {p : ℕ} [fact (nat.prime p)] {a : zmod p} (ha : a ≠ 0) : a ^ (p - 1) = 1",
    "theorem": "{p : ℕ} [fact (nat.prime p)] {a : zmod p} (ha : a ≠ 0) : a ^ (p - 1) = 1",
    "args": "{p : ℕ} [fact (nat.prime p)] {a : zmod p} (ha : a ≠ 0)",
    "doc_string": "**Fermat's Little Theorem**: for all nonzero `a : zmod p`, we have `a ^ (p - 1) = 1`.",
    "type": "a ^ (p - 1) = 1"
  },
  {
    "name": "topological_add_group.continuous_conj_sum",
    "statement": "theorem topological_add_group.continuous_conj_sum {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] : continuous (λ (g : G × G), g.fst + g.snd + -g.fst)",
    "theorem": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] : continuous (λ (g : G × G), g.fst + g.snd + -g.fst)",
    "args": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G]",
    "doc_string": "Conjugation is jointly continuous on `G × G` when both `mul` and `inv` are continuous.",
    "type": "continuous (λ (g : G × G), g.fst + g.snd + -g.fst)"
  },
  {
    "name": "zpow_eq_zpow_iff'",
    "statement": "theorem zpow_eq_zpow_iff' {α : Type u_1} [linear_ordered_comm_group α] {n : ℤ} {a b : α} (hn : n ≠ 0) : a ^ n = b ^ n ↔ a = b",
    "theorem": "{α : Type u_1} [linear_ordered_comm_group α] {n : ℤ} {a b : α} (hn : n ≠ 0) : a ^ n = b ^ n ↔ a = b",
    "args": "{α : Type u_1} [linear_ordered_comm_group α] {n : ℤ} {a b : α} (hn : n ≠ 0)",
    "doc_string": " Alias of `zsmul_right_inj`, for ease of discovery alongside `zsmul_le_zsmul_iff'` and `zsmul_lt_zsmul_iff'`.",
    "type": "a ^ n = b ^ n ↔ a = b"
  },
  {
    "name": "multiset.nat.card_antidiagonal",
    "statement": "theorem multiset.nat.card_antidiagonal (n : ℕ) : ⇑multiset.card (multiset.nat.antidiagonal n) = n + 1",
    "theorem": "(n : ℕ) : ⇑multiset.card (multiset.nat.antidiagonal n) = n + 1",
    "args": "(n : ℕ)",
    "doc_string": "The cardinality of the antidiagonal of `n` is `n+1`.",
    "type": "⇑multiset.card (multiset.nat.antidiagonal n) = n + 1"
  },
  {
    "name": "add_commute.symm",
    "statement": "theorem add_commute.symm {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a",
    "theorem": "{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a",
    "args": "{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b)",
    "doc_string": "If `a` commutes with `b`, then `b` commutes with `a`.",
    "type": "add_commute b a"
  },
  {
    "name": "dense_range_pure",
    "statement": "theorem dense_range_pure {α : Type u} : dense_range has_pure.pure",
    "theorem": "{α : Type u} : dense_range has_pure.pure",
    "args": "{α : Type u}",
    "doc_string": "The range of `pure : α → ultrafilter α` is dense in `ultrafilter α`.",
    "type": "dense_range has_pure.pure"
  },
  {
    "name": "metric.continuous_inf_nndist_pt",
    "statement": "theorem metric.continuous_inf_nndist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_nndist x s)",
    "theorem": "{α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_nndist x s)",
    "args": "{α : Type u} [pseudo_metric_space α] (s : set α)",
    "doc_string": "The minimal distance to a set (as `ℝ≥0`) is continuous in point",
    "type": "continuous (λ (x : α), metric.inf_nndist x s)"
  },
  {
    "name": "has_sbtw.sbtw.not_sbtw",
    "statement": "theorem has_sbtw.sbtw.not_sbtw {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : ¬has_sbtw.sbtw c b a",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : ¬has_sbtw.sbtw c b a",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c)",
    "doc_string": "**Alias** of sbtw_asymm`.",
    "type": "¬has_sbtw.sbtw c b a"
  },
  {
    "name": "exp_neg_inv_glue.f_aux_limit",
    "statement": "theorem exp_neg_inv_glue.f_aux_limit (n : ℕ) : filter.tendsto (λ (x : ℝ), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-x⁻¹) / x ^ (2 * n)) (nhds_within 0 (set.Ioi 0)) (nhds 0)",
    "theorem": "(n : ℕ) : filter.tendsto (λ (x : ℝ), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-x⁻¹) / x ^ (2 * n)) (nhds_within 0 (set.Ioi 0)) (nhds 0)",
    "args": "(n : ℕ)",
    "doc_string": " To get differentiability at `0` of the auxiliary functions, we need to know that their limit is `0`, to be able to apply general differentiability extension theorems. This limit is checked in this lemma.",
    "type": "filter.tendsto (λ (x : ℝ), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-x⁻¹) / x ^ (2 * n)) (nhds_within 0 (set.Ioi 0)) (nhds 0)"
  },
  {
    "name": "nat.factorization_eq_zero_iff",
    "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1",
    "theorem": "(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1",
    "args": "(n : ℕ)",
    "doc_string": "The only numbers with empty prime factorization are `0` and `1`",
    "type": "n.factorization = 0 ↔ n = 0 ∨ n = 1"
  },
  {
    "name": "order.succ_ne_succ",
    "statement": "theorem order.succ_ne_succ {α : Type u_1} [partial_order α] [succ_order α] {a b : α} [no_max_order α] : a ≠ b → order.succ a ≠ order.succ b",
    "theorem": "{α : Type u_1} [partial_order α] [succ_order α] {a b : α} [no_max_order α] : a ≠ b → order.succ a ≠ order.succ b",
    "args": "{α : Type u_1} [partial_order α] [succ_order α] {a b : α} [no_max_order α]",
    "doc_string": "**Alias** of the reverse direction of order.succ_ne_succ_iff`.",
    "type": "a ≠ b → order.succ a ≠ order.succ b"
  },
  {
    "name": "tsub_tsub_le",
    "statement": "theorem tsub_tsub_le {α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α} : b - (b - a) ≤ a",
    "theorem": "{α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α} : b - (b - a) ≤ a",
    "args": "{α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α}",
    "doc_string": "See `tsub_tsub_cancel_of_le` for the equality.",
    "type": "b - (b - a) ≤ a"
  },
  {
    "name": "sigma.subtype_ext",
    "statement": "theorem sigma.subtype_ext {α : Type u_1} {β : Type u_2} {p : α → β → Prop} {x₀ x₁ : Σ (a : α), subtype (p a)} : x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁",
    "theorem": "{α : Type u_1} {β : Type u_2} {p : α → β → Prop} {x₀ x₁ : Σ (a : α), subtype (p a)} : x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁",
    "args": "{α : Type u_1} {β : Type u_2} {p : α → β → Prop} {x₀ x₁ : Σ (a : α), subtype (p a)}",
    "doc_string": "A specialized ext lemma for equality of sigma types over an indexed subtype.",
    "type": "x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁"
  },
  {
    "name": "bornology.is_bounded.bounded_space_subtype",
    "statement": "theorem bornology.is_bounded.bounded_space_subtype {α : Type u_1} [bornology α] {p : α → Prop} : bornology.is_bounded {x : α | p x} → bounded_space (subtype p)",
    "theorem": "{α : Type u_1} [bornology α] {p : α → Prop} : bornology.is_bounded {x : α | p x} → bounded_space (subtype p)",
    "args": "{α : Type u_1} [bornology α] {p : α → Prop}",
    "doc_string": "**Alias** of the reverse direction of bounded_space_subtype_iff`.",
    "type": "bornology.is_bounded {x : α | p x} → bounded_space (subtype p)"
  },
  {
    "name": "zero_ne_one_or_forall_eq_0",
    "statement": "theorem zero_ne_one_or_forall_eq_0 {M₀ : Type u_1} [mul_zero_one_class M₀] : 0 ≠ 1 ∨ ∀ (a : M₀), a = 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_one_class M₀] : 0 ≠ 1 ∨ ∀ (a : M₀), a = 0",
    "args": "{M₀ : Type u_1} [mul_zero_one_class M₀]",
    "doc_string": "In a monoid with zero, either zero and one are nonequal, or zero is the only element.",
    "type": "0 ≠ 1 ∨ ∀ (a : M₀), a = 0"
  },
  {
    "name": "dense_embedding.separable_space",
    "statement": "theorem dense_embedding.separable_space {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : α → β} (de : dense_embedding e) [topological_space.separable_space α] : topological_space.separable_space β",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : α → β} (de : dense_embedding e) [topological_space.separable_space α] : topological_space.separable_space β",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : α → β} (de : dense_embedding e) [topological_space.separable_space α]",
    "doc_string": "If the domain of a `dense_embedding` is a separable space, then so is its codomain.",
    "type": "topological_space.separable_space β"
  },
  {
    "name": "is_compact.is_closed",
    "statement": "theorem is_compact.is_closed {α : Type u} [topological_space α] [t2_space α] {s : set α} (hs : is_compact s) : is_closed s",
    "theorem": "{α : Type u} [topological_space α] [t2_space α] {s : set α} (hs : is_compact s) : is_closed s",
    "args": "{α : Type u} [topological_space α] [t2_space α] {s : set α} (hs : is_compact s)",
    "doc_string": "In a `t2_space`, every compact set is closed.",
    "type": "is_closed s"
  },
  {
    "name": "nat.cast_desc_factorial_two",
    "statement": "theorem nat.cast_desc_factorial_two (S : Type u_1) [ring S] (a : ℕ) : ↑(a.desc_factorial 2) = ↑a * (↑a - 1)",
    "theorem": "(S : Type u_1) [ring S] (a : ℕ) : ↑(a.desc_factorial 2) = ↑a * (↑a - 1)",
    "args": "(S : Type u_1) [ring S] (a : ℕ)",
    "doc_string": " Convenience lemma. The `a - 1` is not using truncated substraction, as opposed to the definition of `nat.desc_factorial` as a natural.",
    "type": "↑(a.desc_factorial 2) = ↑a * (↑a - 1)"
  },
  {
    "name": "has_sbtw.sbtw.trans_right",
    "statement": "theorem has_sbtw.sbtw.trans_right {α : Type u_1} [circular_preorder α] {a b c d : α} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d) : has_sbtw.sbtw a b d",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c d : α} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d) : has_sbtw.sbtw a b d",
    "args": "{α : Type u_1} [circular_preorder α] {a b c d : α} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d)",
    "doc_string": "**Alias** of sbtw_trans_right`.",
    "type": "has_sbtw.sbtw a b d"
  },
  {
    "name": "one_hom.congr_arg",
    "statement": "theorem one_hom.congr_arg {M : Type u_3} {N : Type u_4} [has_one M] [has_one N] (f : one_hom M N) {x y : M} (h : x = y) : ⇑f x = ⇑f y",
    "theorem": "{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] (f : one_hom M N) {x y : M} (h : x = y) : ⇑f x = ⇑f y",
    "args": "{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] (f : one_hom M N) {x y : M} (h : x = y)",
    "doc_string": "Deprecated: use `fun_like.congr_arg` instead.",
    "type": "⇑f x = ⇑f y"
  },
  {
    "name": "char.quadratic_char_card_sqrts",
    "statement": "theorem char.quadratic_char_card_sqrts {F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2) (a : F) : ↑({x : F | x ^ 2 = a}.to_finset.card) = char.quadratic_char F a + 1",
    "theorem": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2) (a : F) : ↑({x : F | x ^ 2 = a}.to_finset.card) = char.quadratic_char F a + 1",
    "args": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2) (a : F)",
    "doc_string": "The number of solutions to `x^2 = a` is determined by the quadratic character.",
    "type": "↑({x : F | x ^ 2 = a}.to_finset.card) = char.quadratic_char F a + 1"
  },
  {
    "name": "polynomial.rev_at_fun_eq",
    "statement": "theorem polynomial.rev_at_fun_eq (N i : ℕ) : polynomial.rev_at_fun N i = ⇑(polynomial.rev_at N) i",
    "theorem": "(N i : ℕ) : polynomial.rev_at_fun N i = ⇑(polynomial.rev_at N) i",
    "args": "(N i : ℕ)",
    "doc_string": "We prefer to use the bundled `rev_at` over unbundled `rev_at_fun`.",
    "type": "polynomial.rev_at_fun N i = ⇑(polynomial.rev_at N) i"
  },
  {
    "name": "lt_inv_mul_of_mul_lt",
    "statement": "theorem lt_inv_mul_of_mul_lt {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : a * b < c → b < a⁻¹ * c",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : a * b < c → b < a⁻¹ * c",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of lt_inv_mul_iff_mul_lt`.",
    "type": "a * b < c → b < a⁻¹ * c"
  },
  {
    "name": "function.is_periodic_id",
    "statement": "theorem function.is_periodic_id {α : Type u_1} (n : ℕ) (x : α) : function.is_periodic_pt id n x",
    "theorem": "{α : Type u_1} (n : ℕ) (x : α) : function.is_periodic_pt id n x",
    "args": "{α : Type u_1} (n : ℕ) (x : α)",
    "doc_string": "For the identity map, all points are periodic.",
    "type": "function.is_periodic_pt id n x"
  },
  {
    "name": "right.add_neg",
    "statement": "theorem right.add_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_neg`.",
    "type": "a + b < 0"
  },
  {
    "name": "uniform_space.completion.uniform_continuous_dist",
    "statement": "theorem uniform_space.completion.uniform_continuous_dist {α : Type u} [pseudo_metric_space α] : uniform_continuous (λ (p : uniform_space.completion α × uniform_space.completion α), has_dist.dist p.fst p.snd)",
    "theorem": "{α : Type u} [pseudo_metric_space α] : uniform_continuous (λ (p : uniform_space.completion α × uniform_space.completion α), has_dist.dist p.fst p.snd)",
    "args": "{α : Type u} [pseudo_metric_space α]",
    "doc_string": "The new distance is uniformly continuous.",
    "type": "uniform_continuous (λ (p : uniform_space.completion α × uniform_space.completion α), has_dist.dist p.fst p.snd)"
  },
  {
    "name": "gold_conj_irrational",
    "statement": "theorem gold_conj_irrational  : irrational golden_conj",
    "theorem": " : irrational golden_conj",
    "args": "",
    "doc_string": "The conjugate of the golden ratio is irrational.",
    "type": "irrational golden_conj"
  },
  {
    "name": "nat.coprime_factors_disjoint",
    "statement": "theorem nat.coprime_factors_disjoint {a b : ℕ} (hab : a.coprime b) : a.factors.disjoint b.factors",
    "theorem": "{a b : ℕ} (hab : a.coprime b) : a.factors.disjoint b.factors",
    "args": "{a b : ℕ} (hab : a.coprime b)",
    "doc_string": "The sets of factors of coprime `a` and `b` are disjoint",
    "type": "a.factors.disjoint b.factors"
  },
  {
    "name": "finsupp.lt_wf",
    "statement": "theorem finsupp.lt_wf (ι : Type u_3) : well_founded has_lt.lt",
    "theorem": "(ι : Type u_3) : well_founded has_lt.lt",
    "args": "(ι : Type u_3)",
    "doc_string": "The order on `ι →₀ ℕ` is well-founded.",
    "type": "well_founded has_lt.lt"
  },
  {
    "name": "int.gcd_least_linear",
    "statement": "theorem int.gcd_least_linear {a b : ℤ} (ha : a ≠ 0) : is_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b)",
    "theorem": "{a b : ℤ} (ha : a ≠ 0) : is_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b)",
    "args": "{a b : ℤ} (ha : a ≠ 0)",
    "doc_string": " For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be written in the form `a * x + b * y` for some pair of integers `x` and `y`",
    "type": "is_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b)"
  },
  {
    "name": "zero_lt.right.one_lt_mul_of_lt_of_le",
    "statement": "theorem zero_lt.right.one_lt_mul_of_lt_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 ≤ b) (b0 : 0 < b) : 1 < a * b",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 ≤ b) (b0 : 0 < b) : 1 < a * b",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 ≤ b) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "type": "1 < a * b"
  },
  {
    "name": "antisymm_rel.eq",
    "statement": "theorem antisymm_rel.eq {α : Type u_1} {r : α → α → Prop} [is_refl α r] [is_antisymm α r] {a b : α} : antisymm_rel r a b → a = b",
    "theorem": "{α : Type u_1} {r : α → α → Prop} [is_refl α r] [is_antisymm α r] {a b : α} : antisymm_rel r a b → a = b",
    "args": "{α : Type u_1} {r : α → α → Prop} [is_refl α r] [is_antisymm α r] {a b : α}",
    "doc_string": "**Alias** of the forward direction of antisymm_rel_iff_eq`.",
    "type": "antisymm_rel r a b → a = b"
  },
  {
    "name": "fin.coe_fin_le",
    "statement": "theorem fin.coe_fin_le {n : ℕ} {a b : fin n} : ↑a ≤ ↑b ↔ a ≤ b",
    "theorem": "{n : ℕ} {a b : fin n} : ↑a ≤ ↑b ↔ a ≤ b",
    "args": "{n : ℕ} {a b : fin n}",
    "doc_string": "`a ≤ b` as natural numbers if and only if `a ≤ b` in `fin n`.",
    "type": "↑a ≤ ↑b ↔ a ≤ b"
  },
  {
    "name": "pred_lt_pred",
    "statement": "theorem pred_lt_pred {α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : a < b → order.pred a < order.pred b",
    "theorem": "{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : a < b → order.pred a < order.pred b",
    "args": "{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α]",
    "doc_string": "**Alias** of the reverse direction of order.pred_lt_pred_iff`.",
    "type": "a < b → order.pred a < order.pred b"
  },
  {
    "name": "krull_topology_totally_disconnected",
    "statement": "theorem krull_topology_totally_disconnected {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (h_int : algebra.is_integral K L) : is_totally_disconnected set.univ",
    "theorem": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (h_int : algebra.is_integral K L) : is_totally_disconnected set.univ",
    "args": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (h_int : algebra.is_integral K L)",
    "doc_string": "If `L/K` is an algebraic field extension, then the Krull topology on `L ≃ₐ[K] L` is  totally disconnected.",
    "type": "is_totally_disconnected set.univ"
  },
  {
    "name": "is_of_fin_order_zero",
    "statement": "theorem is_of_fin_order_zero {G : Type u} [add_monoid G] : is_of_fin_add_order 0",
    "theorem": "{G : Type u} [add_monoid G] : is_of_fin_add_order 0",
    "args": "{G : Type u} [add_monoid G]",
    "doc_string": "0 is of finite order in any additive monoid.",
    "type": "is_of_fin_add_order 0"
  },
  {
    "name": "is_add_left_regular.add",
    "statement": "theorem is_add_left_regular.add {R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b) : is_add_left_regular (a + b)",
    "theorem": "{R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b) : is_add_left_regular (a + b)",
    "args": "{R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b)",
    "doc_string": "In an additive semigroup, the sum of add-left-regular elements is add-left.regular.",
    "type": "is_add_left_regular (a + b)"
  },
  {
    "name": "ordered_comm_group.lt_of_mul_lt_mul_left",
    "statement": "theorem ordered_comm_group.lt_of_mul_lt_mul_left {α : Type u_1} [has_mul α] [has_lt α] [contravariant_class α α has_mul.mul has_lt.lt] {a b c : α} (bc : a * b < a * c) : b < c",
    "theorem": "{α : Type u_1} [has_mul α] [has_lt α] [contravariant_class α α has_mul.mul has_lt.lt] {a b c : α} (bc : a * b < a * c) : b < c",
    "args": "{α : Type u_1} [has_mul α] [has_lt α] [contravariant_class α α has_mul.mul has_lt.lt] {a b c : α} (bc : a * b < a * c)",
    "doc_string": "**Alias** of lt_of_mul_lt_mul_left'`.",
    "type": "b < c"
  },
  {
    "name": "ordinal.induction",
    "statement": "theorem ordinal.induction {p : ordinal → Prop} (i : ordinal) (h : ∀ (j : ordinal), (∀ (k : ordinal), k < j → p k) → p j) : p i",
    "theorem": "{p : ordinal → Prop} (i : ordinal) (h : ∀ (j : ordinal), (∀ (k : ordinal), k < j → p k) → p j) : p i",
    "args": "{p : ordinal → Prop} (i : ordinal) (h : ∀ (j : ordinal), (∀ (k : ordinal), k < j → p k) → p j)",
    "doc_string": " Reformulation of well founded induction on ordinals as a lemma that works with the `induction` tactic, as in `induction i using ordinal.induction with i IH`.",
    "type": "p i"
  },
  {
    "name": "real.sinh_injective",
    "statement": "theorem real.sinh_injective  : function.injective real.sinh",
    "theorem": " : function.injective real.sinh",
    "args": "",
    "doc_string": "`sinh` is injective, `∀ a b, sinh a = sinh b → a = b`.",
    "type": "function.injective real.sinh"
  },
  {
    "name": "right.neg_pos_iff",
    "statement": "theorem right.neg_pos_iff {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α} : 0 < -a ↔ a < 0",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α} : 0 < -a ↔ a < 0",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α}",
    "doc_string": "Uses `right` co(ntra)variant.",
    "type": "0 < -a ↔ a < 0"
  },
  {
    "name": "con.inv",
    "statement": "theorem con.inv {M : Type u_1} [group M] (c : con M) {w x : M} : ⇑c w x → ⇑c w⁻¹ x⁻¹",
    "theorem": "{M : Type u_1} [group M] (c : con M) {w x : M} : ⇑c w x → ⇑c w⁻¹ x⁻¹",
    "args": "{M : Type u_1} [group M] (c : con M) {w x : M}",
    "doc_string": "Multiplicative congruence relations preserve inversion.",
    "type": "⇑c w x → ⇑c w⁻¹ x⁻¹"
  },
  {
    "name": "surjective_quotient_mk",
    "statement": "theorem surjective_quotient_mk (α : Sort u_1) [s : setoid α] : function.surjective quotient.mk",
    "theorem": "(α : Sort u_1) [s : setoid α] : function.surjective quotient.mk",
    "args": "(α : Sort u_1) [s : setoid α]",
    "doc_string": "`quotient.mk` is a surjective function.",
    "type": "function.surjective quotient.mk"
  },
  {
    "name": "group.normal_closure_subset",
    "statement": "theorem group.normal_closure_subset {G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s ⊆ t) : group.normal_closure s ⊆ t",
    "theorem": "{G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s ⊆ t) : group.normal_closure s ⊆ t",
    "args": "{G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s ⊆ t)",
    "doc_string": "The normal closure of s is the smallest normal subgroup containing s.",
    "type": "group.normal_closure s ⊆ t"
  },
  {
    "name": "subsingleton_floor_semiring",
    "statement": "theorem subsingleton_floor_semiring {α : Type u_1} [linear_ordered_semiring α] : subsingleton (floor_semiring α)",
    "theorem": "{α : Type u_1} [linear_ordered_semiring α] : subsingleton (floor_semiring α)",
    "args": "{α : Type u_1} [linear_ordered_semiring α]",
    "doc_string": "There exists at most one `floor_semiring` structure on a linear ordered semiring.",
    "type": "subsingleton (floor_semiring α)"
  },
  {
    "name": "nnreal.has_sum_geometric",
    "statement": "theorem nnreal.has_sum_geometric {r : nnreal} (hr : r < 1) : has_sum (λ (n : ℕ), r ^ n) (1 - r)⁻¹",
    "theorem": "{r : nnreal} (hr : r < 1) : has_sum (λ (n : ℕ), r ^ n) (1 - r)⁻¹",
    "args": "{r : nnreal} (hr : r < 1)",
    "doc_string": "**Sum of a Geometric Series**",
    "type": "has_sum (λ (n : ℕ), r ^ n) (1 - r)⁻¹"
  },
  {
    "name": "commute.refl",
    "statement": "theorem commute.refl {S : Type u_1} [has_mul S] (a : S) : commute a a",
    "theorem": "{S : Type u_1} [has_mul S] (a : S) : commute a a",
    "args": "{S : Type u_1} [has_mul S] (a : S)",
    "doc_string": "Any element commutes with itself.",
    "type": "commute a a"
  },
  {
    "name": "right.neg_neg_iff",
    "statement": "theorem right.neg_neg_iff {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α} : -a < 0 ↔ 0 < a",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α} : -a < 0 ↔ 0 < a",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α}",
    "doc_string": "Uses `right` co(ntra)variant.",
    "type": "-a < 0 ↔ 0 < a"
  },
  {
    "name": "dvd_neg",
    "statement": "theorem dvd_neg {α : Type u} [semigroup α] [has_distrib_neg α] (a b : α) : a ∣ -b ↔ a ∣ b",
    "theorem": "{α : Type u} [semigroup α] [has_distrib_neg α] (a b : α) : a ∣ -b ↔ a ∣ b",
    "args": "{α : Type u} [semigroup α] [has_distrib_neg α] (a b : α)",
    "doc_string": " An element a of a semigroup with a distributive negation divides the negation of an element b iff a divides b.",
    "type": "a ∣ -b ↔ a ∣ b"
  },
  {
    "name": "add_neg_of_neg_of_nonpos",
    "statement": "theorem add_neg_of_neg_of_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0)",
    "doc_string": "**Alias** of `left.add_neg_of_neg_of_nonpos`.",
    "type": "a + b < 0"
  },
  {
    "name": "add_con.sub",
    "statement": "theorem add_con.sub {M : Type u_1} [add_group M] (c : add_con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w - y) (x - z)",
    "theorem": "{M : Type u_1} [add_group M] (c : add_con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w - y) (x - z)",
    "args": "{M : Type u_1} [add_group M] (c : add_con M) {w x y z : M}",
    "doc_string": "Additive congruence relations preserve subtraction.",
    "type": "⇑c w x → ⇑c y z → ⇑c (w - y) (x - z)"
  },
  {
    "name": "topological_group.continuous_conj'",
    "statement": "theorem topological_group.continuous_conj' {G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] (h : G) : continuous (λ (g : G), g * h * g⁻¹)",
    "theorem": "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] (h : G) : continuous (λ (g : G), g * h * g⁻¹)",
    "args": "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] (h : G)",
    "doc_string": " Conjugation acting on fixed element of the group is continuous when both `mul` and `inv` are continuous.",
    "type": "continuous (λ (g : G), g * h * g⁻¹)"
  },
  {
    "name": "bounded_continuous_function.dist_zero_of_empty",
    "statement": "theorem bounded_continuous_function.dist_zero_of_empty {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} [is_empty α] : has_dist.dist f g = 0",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} [is_empty α] : has_dist.dist f g = 0",
    "args": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} [is_empty α]",
    "doc_string": "On an empty space, bounded continuous functions are at distance 0",
    "type": "has_dist.dist f g = 0"
  },
  {
    "name": "isometry.right_inv",
    "statement": "theorem isometry.right_inv {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} {g : β → α} (h : isometry f) (hg : function.right_inverse g f) : isometry g",
    "theorem": "{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} {g : β → α} (h : isometry f) (hg : function.right_inverse g f) : isometry g",
    "args": "{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} {g : β → α} (h : isometry f) (hg : function.right_inverse g f)",
    "doc_string": "The right inverse of an isometry is an isometry.",
    "type": "isometry g"
  },
  {
    "name": "add_le_of_le_sub_left",
    "statement": "theorem add_le_of_le_sub_left {α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : b ≤ c - a → a + b ≤ c",
    "theorem": "{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : b ≤ c - a → a + b ≤ c",
    "args": "{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of le_sub_iff_add_le'`.",
    "type": "b ≤ c - a → a + b ≤ c"
  },
  {
    "name": "monoid_algebra.finite_type_iff_fg",
    "statement": "theorem monoid_algebra.finite_type_iff_fg {R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R M) ↔ monoid.fg M",
    "theorem": "{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R M) ↔ monoid.fg M",
    "args": "{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R]",
    "doc_string": "A monoid `M` is finitely generated if and only if `monoid_algebra R M` is of finite type.",
    "type": "algebra.finite_type R (monoid_algebra R M) ↔ monoid.fg M"
  },
  {
    "name": "is_integral.is_algebraic",
    "statement": "theorem is_integral.is_algebraic (R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] {x : A} : is_integral R x → is_algebraic R x",
    "theorem": "(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] {x : A} : is_integral R x → is_algebraic R x",
    "args": "(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] {x : A}",
    "doc_string": "An integral element of an algebra is algebraic.",
    "type": "is_integral R x → is_algebraic R x"
  },
  {
    "name": "add_le_of_le_sub_right",
    "statement": "theorem add_le_of_le_sub_right {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α} : a ≤ c - b → a + b ≤ c",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α} : a ≤ c - b → a + b ≤ c",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of le_sub_iff_add_le`.",
    "type": "a ≤ c - b → a + b ≤ c"
  },
  {
    "name": "padic_val_int.self",
    "statement": "theorem padic_val_int.self {p : ℕ} (hp : 1 < p) : padic_val_int p ↑p = 1",
    "theorem": "{p : ℕ} (hp : 1 < p) : padic_val_int p ↑p = 1",
    "args": "{p : ℕ} (hp : 1 < p)",
    "doc_string": "For `p ≠ 0, p ≠ 1, `padic_val_int p p` is 1.",
    "type": "padic_val_int p ↑p = 1"
  },
  {
    "name": "monoid.not_is_torsion_free_iff",
    "statement": "theorem monoid.not_is_torsion_free_iff (G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g",
    "theorem": "(G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g",
    "args": "(G : Type u_1) [monoid G]",
    "doc_string": "A nontrivial monoid is not torsion-free if any nontrivial element has finite order.",
    "type": "¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g"
  },
  {
    "name": "no_max_order.infinite",
    "statement": "theorem no_max_order.infinite {α : Type u_1} [preorder α] [nonempty α] [no_max_order α] : infinite α",
    "theorem": "{α : Type u_1} [preorder α] [nonempty α] [no_max_order α] : infinite α",
    "args": "{α : Type u_1} [preorder α] [nonempty α] [no_max_order α]",
    "doc_string": " A nonempty preorder with no maximal element is infinite. This is not an instance to avoid a cycle with `infinite α → nontrivial α → nonempty α`.",
    "type": "infinite α"
  },
  {
    "name": "mul_sub",
    "statement": "theorem mul_sub {α : Type u} [non_unital_non_assoc_ring α] (a b c : α) : a * (b - c) = a * b - a * c",
    "theorem": "{α : Type u} [non_unital_non_assoc_ring α] (a b c : α) : a * (b - c) = a * b - a * c",
    "args": "{α : Type u} [non_unital_non_assoc_ring α] (a b c : α)",
    "doc_string": "**Alias** of mul_sub_left_distrib`.",
    "type": "a * (b - c) = a * b - a * c"
  },
  {
    "name": "multiset.Ioc_eq_zero",
    "statement": "theorem multiset.Ioc_eq_zero {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → multiset.Ioc a b = 0",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → multiset.Ioc a b = 0",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of multiset.Ioc_eq_zero_iff`.",
    "type": "¬a < b → multiset.Ioc a b = 0"
  },
  {
    "name": "univ.is_submonoid",
    "statement": "theorem univ.is_submonoid {M : Type u_1} [monoid M] : is_submonoid set.univ",
    "theorem": "{M : Type u_1} [monoid M] : is_submonoid set.univ",
    "args": "{M : Type u_1} [monoid M]",
    "doc_string": "A monoid is a submonoid of itself.",
    "type": "is_submonoid set.univ"
  },
  {
    "name": "lt_tsub_iff_left",
    "statement": "theorem lt_tsub_iff_left {α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] : a < b - c ↔ c + a < b",
    "theorem": "{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] : a < b - c ↔ c + a < b",
    "args": "{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α]",
    "doc_string": "See `lt_tsub_iff_left_of_le` for a weaker statement in a partial order.",
    "type": "a < b - c ↔ c + a < b"
  },
  {
    "name": "has_lt.lt.trans_le",
    "statement": "theorem has_lt.lt.trans_le {α : Type u} [preorder α] {a b c : α} : a < b → b ≤ c → a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : a < b → b ≤ c → a < c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of lt_of_lt_of_le`.",
    "type": "a < b → b ≤ c → a < c"
  },
  {
    "name": "exists_pow_lt_of_lt_one",
    "statement": "theorem exists_pow_lt_of_lt_one {α : Type u_1} [linear_ordered_field α] [archimedean α] {x y : α} (hx : 0 < x) (hy : y < 1) : ∃ (n : ℕ), y ^ n < x",
    "theorem": "{α : Type u_1} [linear_ordered_field α] [archimedean α] {x y : α} (hx : 0 < x) (hy : y < 1) : ∃ (n : ℕ), y ^ n < x",
    "args": "{α : Type u_1} [linear_ordered_field α] [archimedean α] {x y : α} (hx : 0 < x) (hy : y < 1)",
    "doc_string": "For any `y < 1` and any positive `x`, there exists `n : ℕ` with `y ^ n < x`.",
    "type": "∃ (n : ℕ), y ^ n < x"
  },
  {
    "name": "bdd_below.inter_of_left",
    "statement": "theorem bdd_below.inter_of_left {α : Type u} [preorder α] {s t : set α} (h : bdd_below s) : bdd_below (s ∩ t)",
    "theorem": "{α : Type u} [preorder α] {s t : set α} (h : bdd_below s) : bdd_below (s ∩ t)",
    "args": "{α : Type u} [preorder α] {s t : set α} (h : bdd_below s)",
    "doc_string": "If `s` is bounded, then so is `s ∩ t`",
    "type": "bdd_below (s ∩ t)"
  },
  {
    "name": "lucas_lehmer.two_lt_q",
    "statement": "theorem lucas_lehmer.two_lt_q (p' : ℕ) : 2 < lucas_lehmer.q (p' + 2)",
    "theorem": "(p' : ℕ) : 2 < lucas_lehmer.q (p' + 2)",
    "args": "(p' : ℕ)",
    "doc_string": "If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2.",
    "type": "2 < lucas_lehmer.q (p' + 2)"
  },
  {
    "name": "isometry_subsingleton",
    "statement": "theorem isometry_subsingleton {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} [subsingleton α] : isometry f",
    "theorem": "{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} [subsingleton α] : isometry f",
    "args": "{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} [subsingleton α]",
    "doc_string": "Any map on a subsingleton is an isometry",
    "type": "isometry f"
  },
  {
    "name": "closure_Ioi",
    "statement": "theorem closure_Ioi {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_max_order α] : closure (set.Ioi a) = set.Ici a",
    "theorem": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_max_order α] : closure (set.Ioi a) = set.Ici a",
    "args": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_max_order α]",
    "doc_string": "The closure of the interval `(a, +∞)` is the closed interval `[a, +∞)`.",
    "type": "closure (set.Ioi a) = set.Ici a"
  },
  {
    "name": "polynomial.cyclotomic.irreducible",
    "statement": "theorem polynomial.cyclotomic.irreducible {n : ℕ} (hpos : 0 < n) : irreducible (polynomial.cyclotomic n ℤ)",
    "theorem": "{n : ℕ} (hpos : 0 < n) : irreducible (polynomial.cyclotomic n ℤ)",
    "args": "{n : ℕ} (hpos : 0 < n)",
    "doc_string": "`cyclotomic n ℤ` is irreducible.",
    "type": "irreducible (polynomial.cyclotomic n ℤ)"
  },
  {
    "name": "valuation.zero_iff",
    "statement": "theorem valuation.zero_iff {Γ₀ : Type u_3} [linear_ordered_comm_monoid_with_zero Γ₀] [nontrivial Γ₀] {K : Type u_1} [division_ring K] (v : valuation K Γ₀) {x : K} : ⇑v x = 0 ↔ x = 0",
    "theorem": "{Γ₀ : Type u_3} [linear_ordered_comm_monoid_with_zero Γ₀] [nontrivial Γ₀] {K : Type u_1} [division_ring K] (v : valuation K Γ₀) {x : K} : ⇑v x = 0 ↔ x = 0",
    "args": "{Γ₀ : Type u_3} [linear_ordered_comm_monoid_with_zero Γ₀] [nontrivial Γ₀] {K : Type u_1} [division_ring K] (v : valuation K Γ₀) {x : K}",
    "doc_string": "If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`.",
    "type": "⇑v x = 0 ↔ x = 0"
  },
  {
    "name": "module.ray.ne_neg_self",
    "statement": "theorem module.ray.ne_neg_self {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] (x : module.ray R M) : x ≠ -x",
    "theorem": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] (x : module.ray R M) : x ≠ -x",
    "args": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] (x : module.ray R M)",
    "doc_string": "A ray does not equal its own negation.",
    "type": "x ≠ -x"
  },
  {
    "name": "finset.min'_singleton",
    "statement": "theorem finset.min'_singleton {α : Type u_1} [linear_order α] (a : α) : {a}.min' _ = a",
    "theorem": "{α : Type u_1} [linear_order α] (a : α) : {a}.min' _ = a",
    "args": "{α : Type u_1} [linear_order α] (a : α)",
    "doc_string": "`{a}.min' _` is `a`.",
    "type": "{a}.min' _ = a"
  },
  {
    "name": "list.length_pos_of_sum_neg",
    "statement": "theorem list.length_pos_of_sum_neg {M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : L.sum < 0) : 0 < L.length",
    "theorem": "{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : L.sum < 0) : 0 < L.length",
    "args": "{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : L.sum < 0)",
    "doc_string": "A list with negative sum must have positive length.",
    "type": "0 < L.length"
  },
  {
    "name": "is_greatest.bdd_above",
    "statement": "theorem is_greatest.bdd_above {α : Type u} [preorder α] {s : set α} {a : α} (h : is_greatest s a) : bdd_above s",
    "theorem": "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_greatest s a) : bdd_above s",
    "args": "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_greatest s a)",
    "doc_string": "If `s` has a greatest element, then it is bounded above.",
    "type": "bdd_above s"
  },
  {
    "name": "left.add_pos",
    "statement": "theorem left.add_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_pos`.",
    "type": "0 < a + b"
  },
  {
    "name": "univ.is_add_submonoid",
    "statement": "theorem univ.is_add_submonoid {M : Type u_1} [add_monoid M] : is_add_submonoid set.univ",
    "theorem": "{M : Type u_1} [add_monoid M] : is_add_submonoid set.univ",
    "args": "{M : Type u_1} [add_monoid M]",
    "doc_string": "An `add_monoid` is an `add_submonoid` of itself.",
    "type": "is_add_submonoid set.univ"
  },
  {
    "name": "option.map_injective",
    "statement": "theorem option.map_injective {α : Type u_1} {β : Type u_2} {f : α → β} (Hf : function.injective f) : function.injective (option.map f)",
    "theorem": "{α : Type u_1} {β : Type u_2} {f : α → β} (Hf : function.injective f) : function.injective (option.map f)",
    "args": "{α : Type u_1} {β : Type u_2} {f : α → β} (Hf : function.injective f)",
    "doc_string": "`option.map f` is injective if `f` is injective.",
    "type": "function.injective (option.map f)"
  },
  {
    "name": "conj_act.fixed_points_eq_center",
    "statement": "theorem conj_act.fixed_points_eq_center {G : Type u_2} [group G] : mul_action.fixed_points (conj_act G) G = ↑(subgroup.center G)",
    "theorem": "{G : Type u_2} [group G] : mul_action.fixed_points (conj_act G) G = ↑(subgroup.center G)",
    "args": "{G : Type u_2} [group G]",
    "doc_string": "The set of fixed points of the conjugation action of `G` on itself is the center of `G`.",
    "type": "mul_action.fixed_points (conj_act G) G = ↑(subgroup.center G)"
  },
  {
    "name": "strict_mono.dual_right",
    "statement": "theorem strict_mono.dual_right {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : strict_mono f → strict_anti (⇑order_dual.to_dual ∘ f)",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : strict_mono f → strict_anti (⇑order_dual.to_dual ∘ f)",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β}",
    "doc_string": "**Alias** of the reverse direction of strict_anti_to_dual_comp_iff`.",
    "type": "strict_mono f → strict_anti (⇑order_dual.to_dual ∘ f)"
  },
  {
    "name": "has_le.le.trans_eq'",
    "statement": "theorem has_le.le.trans_eq' {α : Type u} [preorder α] {a b c : α} : b ≤ c → a = b → a ≤ c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : b ≤ c → a = b → a ≤ c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of le_of_le_of_eq'`.",
    "type": "b ≤ c → a = b → a ≤ c"
  },
  {
    "name": "one_add_mul_le_pow",
    "statement": "theorem one_add_mul_le_pow {R : Type u₁} [linear_ordered_ring R] {a : R} (H : -2 ≤ a) (n : ℕ) : 1 + ↑n * a ≤ (1 + a) ^ n",
    "theorem": "{R : Type u₁} [linear_ordered_ring R] {a : R} (H : -2 ≤ a) (n : ℕ) : 1 + ↑n * a ≤ (1 + a) ^ n",
    "args": "{R : Type u₁} [linear_ordered_ring R] {a : R} (H : -2 ≤ a) (n : ℕ)",
    "doc_string": "Bernoulli's inequality for `n : ℕ`, `-2 ≤ a`.",
    "type": "1 + ↑n * a ≤ (1 + a) ^ n"
  },
  {
    "name": "le_one_of_one_le_inv",
    "statement": "theorem le_one_of_one_le_inv {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ → a ≤ 1",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ → a ≤ 1",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α}",
    "doc_string": "**Alias** of the forward direction of left.one_le_inv_iff`.",
    "type": "1 ≤ a⁻¹ → a ≤ 1"
  },
  {
    "name": "set.mem_of_indicator_ne_zero",
    "statement": "theorem set.mem_of_indicator_ne_zero {α : Type u_1} {M : Type u_4} [has_zero M] {s : set α} {f : α → M} {a : α} (h : s.indicator f a ≠ 0) : a ∈ s",
    "theorem": "{α : Type u_1} {M : Type u_4} [has_zero M] {s : set α} {f : α → M} {a : α} (h : s.indicator f a ≠ 0) : a ∈ s",
    "args": "{α : Type u_1} {M : Type u_4} [has_zero M] {s : set α} {f : α → M} {a : α} (h : s.indicator f a ≠ 0)",
    "doc_string": "If an additive indicator function is not equal to `0` at a point, then that point is in the set.",
    "type": "a ∈ s"
  },
  {
    "name": "comp_assoc_left",
    "statement": "theorem comp_assoc_left {α : Type u_1} (f : α → α → α) [is_associative α f] (x y : α) : f x ∘ f y = f (f x y)",
    "theorem": "{α : Type u_1} (f : α → α → α) [is_associative α f] (x y : α) : f x ∘ f y = f (f x y)",
    "args": "{α : Type u_1} (f : α → α → α) [is_associative α f] (x y : α)",
    "doc_string": "Composing two associative operations of `f : α → α → α` on the left is equal to an associative operation on the left.",
    "type": "f x ∘ f y = f (f x y)"
  },
  {
    "name": "mul_zero_eq_const",
    "statement": "theorem mul_zero_eq_const {M₀ : Type u_1} [mul_zero_class M₀] : (λ (_x : M₀), _x * 0) = function.const M₀ 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_class M₀] : (λ (_x : M₀), _x * 0) = function.const M₀ 0",
    "args": "{M₀ : Type u_1} [mul_zero_class M₀]",
    "doc_string": "To match `mul_one_eq_id`.",
    "type": "(λ (_x : M₀), _x * 0) = function.const M₀ 0"
  },
  {
    "name": "not_and_distrib",
    "statement": "theorem not_and_distrib {a b : Prop} : ¬(a ∧ b) ↔ ¬a ∨ ¬b",
    "theorem": "{a b : Prop} : ¬(a ∧ b) ↔ ¬a ∨ ¬b",
    "args": "{a b : Prop}",
    "doc_string": " One of de Morgan's laws: the negation of a conjunction is logically equivalent to the disjunction of the negations.",
    "type": "¬(a ∧ b) ↔ ¬a ∨ ¬b"
  },
  {
    "name": "modular_group.bottom_row_surj",
    "statement": "theorem modular_group.bottom_row_surj {R : Type u_1} [comm_ring R] : set.surj_on (λ (g : matrix.special_linear_group (fin 2) R), ↑g 1) set.univ {cd : fin 2 → R | is_coprime (cd 0) (cd 1)}",
    "theorem": "{R : Type u_1} [comm_ring R] : set.surj_on (λ (g : matrix.special_linear_group (fin 2) R), ↑g 1) set.univ {cd : fin 2 → R | is_coprime (cd 0) (cd 1)}",
    "args": "{R : Type u_1} [comm_ring R]",
    "doc_string": " Every pair `![c, d]` of coprime integers is the \"bottom_row\" of some element `g=[[*,*],[c,d]]` of `SL(2,ℤ)`.",
    "type": "set.surj_on (λ (g : matrix.special_linear_group (fin 2) R), ↑g 1) set.univ {cd : fin 2 → R | is_coprime (cd 0) (cd 1)}"
  },
  {
    "name": "one_lt_mul''",
    "statement": "theorem one_lt_mul'' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": "**Alias** of left.one_lt_mul'`.",
    "type": "1 < a * b"
  },
  {
    "name": "add_con.add_con_gen_mono",
    "statement": "theorem add_con.add_con_gen_mono {M : Type u_1} [has_add M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y) : add_con_gen r ≤ add_con_gen s",
    "theorem": "{M : Type u_1} [has_add M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y) : add_con_gen r ≤ add_con_gen s",
    "args": "{M : Type u_1} [has_add M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y)",
    "doc_string": "Given binary relations `r, s` with `r` contained in `s`, the smallest additive congruence relation containing `s` contains the smallest additive congruence relation containing `r`.",
    "type": "add_con_gen r ≤ add_con_gen s"
  },
  {
    "name": "not_bdd_below_iff",
    "statement": "theorem not_bdd_below_iff {α : Type u_1} [linear_order α] {s : set α} : ¬bdd_below s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), y < x",
    "theorem": "{α : Type u_1} [linear_order α] {s : set α} : ¬bdd_below s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), y < x",
    "args": "{α : Type u_1} [linear_order α] {s : set α}",
    "doc_string": " A set `s` is not bounded below if and only if for each `x` there exists `y ∈ s` that is less than `x`. A version for preorders is called `not_bdd_below_iff'`.",
    "type": "¬bdd_below s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), y < x"
  },
  {
    "name": "fintype.card_fin_even",
    "statement": "theorem fintype.card_fin_even {k : ℕ} : fact (even (fintype.card (fin (bit0 k))))",
    "theorem": "{k : ℕ} : fact (even (fintype.card (fin (bit0 k))))",
    "args": "{k : ℕ}",
    "doc_string": " The cardinality of `fin (bit0 k)` is even, `fact` version. This `fact` is needed as an instance by `matrix.special_linear_group.has_neg`.",
    "type": "fact (even (fintype.card (fin (bit0 k))))"
  },
  {
    "name": "denumerable.raise_sorted",
    "statement": "theorem denumerable.raise_sorted (l : list ℕ) (n : ℕ) : list.sorted has_le.le (denumerable.raise l n)",
    "theorem": "(l : list ℕ) (n : ℕ) : list.sorted has_le.le (denumerable.raise l n)",
    "args": "(l : list ℕ) (n : ℕ)",
    "doc_string": "`raise l n` is an non-decreasing sequence.",
    "type": "list.sorted has_le.le (denumerable.raise l n)"
  },
  {
    "name": "is_right_regular.ne_zero",
    "statement": "theorem is_right_regular.ne_zero {R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (ra : is_right_regular a) : a ≠ 0",
    "theorem": "{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (ra : is_right_regular a) : a ≠ 0",
    "args": "{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (ra : is_right_regular a)",
    "doc_string": "A right-regular element of a `nontrivial` `mul_zero_class` is non-zero.",
    "type": "a ≠ 0"
  },
  {
    "name": "tot_sep_of_zero_dim",
    "statement": "theorem tot_sep_of_zero_dim {α : Type u} [topological_space α] [t2_space α] (h : topological_space.is_topological_basis {s : set α | is_clopen s}) : totally_separated_space α",
    "theorem": "{α : Type u} [topological_space α] [t2_space α] (h : topological_space.is_topological_basis {s : set α | is_clopen s}) : totally_separated_space α",
    "args": "{α : Type u} [topological_space α] [t2_space α] (h : topological_space.is_topological_basis {s : set α | is_clopen s})",
    "doc_string": "A Hausdorff space with a clopen basis is totally separated.",
    "type": "totally_separated_space α"
  },
  {
    "name": "finset.Ioc_eq_empty",
    "statement": "theorem finset.Ioc_eq_empty {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → finset.Ioc a b = ∅",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → finset.Ioc a b = ∅",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of finset.Ioc_eq_empty_iff`.",
    "type": "¬a < b → finset.Ioc a b = ∅"
  },
  {
    "name": "mul_lt_of_lt_inv_mul",
    "statement": "theorem mul_lt_of_lt_inv_mul {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b < a⁻¹ * c → a * b < c",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b < a⁻¹ * c → a * b < c",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of lt_inv_mul_iff_mul_lt`.",
    "type": "b < a⁻¹ * c → a * b < c"
  },
  {
    "name": "is_regular_one",
    "statement": "theorem is_regular_one {R : Type u_1} [mul_one_class R] : is_regular 1",
    "theorem": "{R : Type u_1} [mul_one_class R] : is_regular 1",
    "args": "{R : Type u_1} [mul_one_class R]",
    "doc_string": "If multiplying by `1` on either side is the identity, `1` is regular.",
    "type": "is_regular 1"
  },
  {
    "name": "category_theory.limits.has_binary_product.swap",
    "statement": "theorem category_theory.limits.has_binary_product.swap {C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q] : category_theory.limits.has_binary_product Q P",
    "theorem": "{C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q] : category_theory.limits.has_binary_product Q P",
    "args": "{C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q]",
    "doc_string": "Construct `has_binary_product Q P` from `has_binary_product P Q`. This can't be an instance, as it would cause a loop in typeclass search.",
    "type": "category_theory.limits.has_binary_product Q P"
  },
  {
    "name": "is_closed_proj_of_is_compact",
    "statement": "theorem is_closed_proj_of_is_compact {X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd",
    "theorem": "{X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd",
    "args": "{X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y]",
    "doc_string": "If X is is_compact then pr₂ : X × Y → Y is a closed map",
    "type": "is_closed_map prod.snd"
  },
  {
    "name": "is_prime_pow_iff_unique_prime_dvd",
    "statement": "theorem is_prime_pow_iff_unique_prime_dvd {n : ℕ} : is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n",
    "theorem": "{n : ℕ} : is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n",
    "args": "{n : ℕ}",
    "doc_string": " An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it.",
    "type": "is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n"
  },
  {
    "name": "function.is_fixed_pt_id",
    "statement": "theorem function.is_fixed_pt_id {α : Type u} (x : α) : function.is_fixed_pt id x",
    "theorem": "{α : Type u} (x : α) : function.is_fixed_pt id x",
    "args": "{α : Type u} (x : α)",
    "doc_string": "Every point is a fixed point of `id`.",
    "type": "function.is_fixed_pt id x"
  },
  {
    "name": "add_con.ext",
    "statement": "theorem add_con.ext {M : Type u_1} [has_add M] {c d : add_con M} (H : ∀ (x y : M), ⇑c x y ↔ ⇑d x y) : c = d",
    "theorem": "{M : Type u_1} [has_add M] {c d : add_con M} (H : ∀ (x y : M), ⇑c x y ↔ ⇑d x y) : c = d",
    "args": "{M : Type u_1} [has_add M] {c d : add_con M} (H : ∀ (x y : M), ⇑c x y ↔ ⇑d x y)",
    "doc_string": "Extensionality rule for additive congruence relations.",
    "type": "c = d"
  },
  {
    "name": "algebra.norm_eq_zero_iff",
    "statement": "theorem algebra.norm_eq_zero_iff {K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] [finite_dimensional K L] {x : L} : ⇑(algebra.norm K) x = 0 ↔ x = 0",
    "theorem": "{K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] [finite_dimensional K L] {x : L} : ⇑(algebra.norm K) x = 0 ↔ x = 0",
    "args": "{K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] [finite_dimensional K L] {x : L}",
    "doc_string": "See also `algebra.norm_eq_zero_iff'` if you already have rewritten with `algebra.norm_apply`.",
    "type": "⇑(algebra.norm K) x = 0 ↔ x = 0"
  },
  {
    "name": "nndist_eq_zero",
    "statement": "theorem nndist_eq_zero {γ : Type w} [metric_space γ] {x y : γ} : has_nndist.nndist x y = 0 ↔ x = y",
    "theorem": "{γ : Type w} [metric_space γ] {x y : γ} : has_nndist.nndist x y = 0 ↔ x = y",
    "args": "{γ : Type w} [metric_space γ] {x y : γ}",
    "doc_string": "Characterize the equality of points with the vanishing of the nonnegative distance",
    "type": "has_nndist.nndist x y = 0 ↔ x = y"
  },
  {
    "name": "lt_of_sub_pos",
    "statement": "theorem lt_of_sub_pos {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : 0 < a - b → b < a",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : 0 < a - b → b < a",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α}",
    "doc_string": "**Alias** of the forward direction of sub_pos`.",
    "type": "0 < a - b → b < a"
  },
  {
    "name": "zmod.legendre_sym_sq_one'",
    "statement": "theorem zmod.legendre_sym_sq_one' (p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p (a ^ 2) = 1",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p (a ^ 2) = 1",
    "args": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0)",
    "doc_string": "The Legendre symbol of `a^2` at `p` is 1 if `p ∤ a`.",
    "type": "zmod.legendre_sym p (a ^ 2) = 1"
  },
  {
    "name": "linear_independent_monoid_hom",
    "statement": "theorem linear_independent_monoid_hom (G : Type u_1) [monoid G] (L : Type u_2) [comm_ring L] [no_zero_divisors L] : linear_independent L (λ (f : G →* L), ⇑f)",
    "theorem": "(G : Type u_1) [monoid G] (L : Type u_2) [comm_ring L] [no_zero_divisors L] : linear_independent L (λ (f : G →* L), ⇑f)",
    "args": "(G : Type u_1) [monoid G] (L : Type u_2) [comm_ring L] [no_zero_divisors L]",
    "doc_string": "Dedekind's linear independence of characters",
    "type": "linear_independent L (λ (f : G →* L), ⇑f)"
  },
  {
    "name": "finprod_mem_empty",
    "statement": "theorem finprod_mem_empty {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} : finprod (λ (i : α), finprod (λ (H : i ∈ ∅), f i)) = 1",
    "theorem": "{α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} : finprod (λ (i : α), finprod (λ (H : i ∈ ∅), f i)) = 1",
    "args": "{α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M}",
    "doc_string": "The product of any function over an empty set is `1`.",
    "type": "finprod (λ (i : α), finprod (λ (H : i ∈ ∅), f i)) = 1"
  },
  {
    "name": "tendsto_inv_zero_at_top",
    "statement": "theorem tendsto_inv_zero_at_top {α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (λ (x : α), x⁻¹) (nhds_within 0 (set.Ioi 0)) filter.at_top",
    "theorem": "{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (λ (x : α), x⁻¹) (nhds_within 0 (set.Ioi 0)) filter.at_top",
    "args": "{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α]",
    "doc_string": "The function `x ↦ x⁻¹` tends to `+∞` on the right of `0`.",
    "type": "filter.tendsto (λ (x : α), x⁻¹) (nhds_within 0 (set.Ioi 0)) filter.at_top"
  },
  {
    "name": "function.injective.comp_left",
    "statement": "theorem function.injective.comp_left {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {g : β → γ} (hg : function.injective g) : function.injective (function.comp g)",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {g : β → γ} (hg : function.injective g) : function.injective (function.comp g)",
    "args": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {g : β → γ} (hg : function.injective g)",
    "doc_string": "Composition by an injective function on the left is itself injective.",
    "type": "function.injective (function.comp g)"
  },
  {
    "name": "function.injective.subsingleton",
    "statement": "theorem function.injective.subsingleton {α : Sort u} {β : Sort v} {f : α → β} (hf : function.injective f) [subsingleton β] : subsingleton α",
    "theorem": "{α : Sort u} {β : Sort v} {f : α → β} (hf : function.injective f) [subsingleton β] : subsingleton α",
    "args": "{α : Sort u} {β : Sort v} {f : α → β} (hf : function.injective f) [subsingleton β]",
    "doc_string": " If the codomain of an injective function is a subsingleton, then the domain is a subsingleton as well.",
    "type": "subsingleton α"
  },
  {
    "name": "vsub_left_injective",
    "statement": "theorem vsub_left_injective {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : P), _x -ᵥ p)",
    "theorem": "{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : P), _x -ᵥ p)",
    "args": "{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P)",
    "doc_string": "Subtracting the point `p` is an injective function.",
    "type": "function.injective (λ (_x : P), _x -ᵥ p)"
  },
  {
    "name": "has_lt.lt.not_is_max",
    "statement": "theorem has_lt.lt.not_is_max {α : Type u_1} [preorder α] {a b : α} (h : a < b) : ¬is_max a",
    "theorem": "{α : Type u_1} [preorder α] {a b : α} (h : a < b) : ¬is_max a",
    "args": "{α : Type u_1} [preorder α] {a b : α} (h : a < b)",
    "doc_string": "**Alias** of not_is_max_of_lt`.",
    "type": "¬is_max a"
  },
  {
    "name": "quaternion_group.order_of_a_one",
    "statement": "theorem quaternion_group.order_of_a_one {n : ℕ} : order_of (quaternion_group.a 1) = 2 * n",
    "theorem": "{n : ℕ} : order_of (quaternion_group.a 1) = 2 * n",
    "args": "{n : ℕ}",
    "doc_string": "If `0 < n`, then `a 1` has order `2 * n`.",
    "type": "order_of (quaternion_group.a 1) = 2 * n"
  },
  {
    "name": "finset.bdd_above",
    "statement": "theorem finset.bdd_above {α : Type u} [semilattice_sup α] [nonempty α] (s : finset α) : bdd_above ↑s",
    "theorem": "{α : Type u} [semilattice_sup α] [nonempty α] (s : finset α) : bdd_above ↑s",
    "args": "{α : Type u} [semilattice_sup α] [nonempty α] (s : finset α)",
    "doc_string": "A finset is bounded above.",
    "type": "bdd_above ↑s"
  },
  {
    "name": "subsingleton_of_forall_eq",
    "statement": "theorem subsingleton_of_forall_eq {α : Sort u_1} (x : α) (h : ∀ (y : α), y = x) : subsingleton α",
    "theorem": "{α : Sort u_1} (x : α) (h : ∀ (y : α), y = x) : subsingleton α",
    "args": "{α : Sort u_1} (x : α) (h : ∀ (y : α), y = x)",
    "doc_string": "If all points are equal to a given point `x`, then `α` is a subsingleton.",
    "type": "subsingleton α"
  },
  {
    "name": "one_lt_mul_of_lt_of_le'",
    "statement": "theorem one_lt_mul_of_lt_of_le' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b)",
    "doc_string": "**Alias** of left.one_lt_mul_of_lt_of_le`.",
    "type": "1 < a * b"
  },
  {
    "name": "is_add_submonoid.inter",
    "statement": "theorem is_add_submonoid.inter {M : Type u_1} [add_monoid M] {s₁ s₂ : set M} (is₁ : is_add_submonoid s₁) (is₂ : is_add_submonoid s₂) : is_add_submonoid (s₁ ∩ s₂)",
    "theorem": "{M : Type u_1} [add_monoid M] {s₁ s₂ : set M} (is₁ : is_add_submonoid s₁) (is₂ : is_add_submonoid s₂) : is_add_submonoid (s₁ ∩ s₂)",
    "args": "{M : Type u_1} [add_monoid M] {s₁ s₂ : set M} (is₁ : is_add_submonoid s₁) (is₂ : is_add_submonoid s₂)",
    "doc_string": "The intersection of two `add_submonoid`s of an `add_monoid` `M` is an `add_submonoid` of M.",
    "type": "is_add_submonoid (s₁ ∩ s₂)"
  },
  {
    "name": "same_ray_neg_iff",
    "statement": "theorem same_ray_neg_iff {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) ↔ same_ray R x y",
    "theorem": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) ↔ same_ray R x y",
    "args": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M}",
    "doc_string": "`same_ray.neg` as an `iff`.",
    "type": "same_ray R (-x) (-y) ↔ same_ray R x y"
  },
  {
    "name": "left.add_neg",
    "statement": "theorem left.add_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_neg`.",
    "type": "a + b < 0"
  },
  {
    "name": "is_of_fin_order.apply",
    "statement": "theorem is_of_fin_order.apply {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_order x) (i : η) : is_of_fin_order (x i)",
    "theorem": "{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_order x) (i : η) : is_of_fin_order (x i)",
    "args": "{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_order x) (i : η)",
    "doc_string": "If a direct product has finite order then so does each component.",
    "type": "is_of_fin_order (x i)"
  },
  {
    "name": "joined_in.joined_subtype",
    "statement": "theorem joined_in.joined_subtype {X : Type u_1} [topological_space X] {x y : X} {F : set X} (h : joined_in F x y) : joined ⟨x, _⟩ ⟨y, _⟩",
    "theorem": "{X : Type u_1} [topological_space X] {x y : X} {F : set X} (h : joined_in F x y) : joined ⟨x, _⟩ ⟨y, _⟩",
    "args": "{X : Type u_1} [topological_space X] {x y : X} {F : set X} (h : joined_in F x y)",
    "doc_string": "If `x` and `y` are joined in the set `F`, then they are joined in the subtype `F`.",
    "type": "joined ⟨x, _⟩ ⟨y, _⟩"
  },
  {
    "name": "measurable.comap_le",
    "statement": "theorem measurable.comap_le {α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable f → measurable_space.comap f m₂ ≤ m₁",
    "theorem": "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable f → measurable_space.comap f m₂ ≤ m₁",
    "args": "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β}",
    "doc_string": "**Alias** of the forward direction of measurable_iff_comap_le`.",
    "type": "measurable f → measurable_space.comap f m₂ ≤ m₁"
  },
  {
    "name": "le_sub_left_of_add_le",
    "statement": "theorem le_sub_left_of_add_le {α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a + b ≤ c → b ≤ c - a",
    "theorem": "{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a + b ≤ c → b ≤ c - a",
    "args": "{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of le_sub_iff_add_le'`.",
    "type": "a + b ≤ c → b ≤ c - a"
  },
  {
    "name": "is_right_regular.mul",
    "statement": "theorem is_right_regular.mul {R : Type u_1} {a b : R} [semigroup R] (rra : is_right_regular a) (rrb : is_right_regular b) : is_right_regular (a * b)",
    "theorem": "{R : Type u_1} {a b : R} [semigroup R] (rra : is_right_regular a) (rrb : is_right_regular b) : is_right_regular (a * b)",
    "args": "{R : Type u_1} {a b : R} [semigroup R] (rra : is_right_regular a) (rrb : is_right_regular b)",
    "doc_string": "In a semigroup, the product of right-regular elements is right-regular.",
    "type": "is_right_regular (a * b)"
  },
  {
    "name": "emetric.edist_le_diam_of_mem",
    "statement": "theorem emetric.edist_le_diam_of_mem {α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} (hx : x ∈ s) (hy : y ∈ s) : has_edist.edist x y ≤ emetric.diam s",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} (hx : x ∈ s) (hy : y ∈ s) : has_edist.edist x y ≤ emetric.diam s",
    "args": "{α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} (hx : x ∈ s) (hy : y ∈ s)",
    "doc_string": "If two points belong to some set, their edistance is bounded by the diameter of the set",
    "type": "has_edist.edist x y ≤ emetric.diam s"
  },
  {
    "name": "nnreal.tendsto_sum_nat_add",
    "statement": "theorem nnreal.tendsto_sum_nat_add (f : ℕ → nnreal) : filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)",
    "theorem": "(f : ℕ → nnreal) : filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)",
    "args": "(f : ℕ → nnreal)",
    "doc_string": " For `f : ℕ → ℝ≥0`, then `∑' k, f (k + i)` tends to zero. This does not require a summability assumption on `f`, as otherwise all sums are zero.",
    "type": "filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)"
  },
  {
    "name": "is_add_left_regular_of_left_cancel_add_semigroup",
    "statement": "theorem is_add_left_regular_of_left_cancel_add_semigroup {R : Type u_1} [add_left_cancel_semigroup R] (g : R) : is_add_left_regular g",
    "theorem": "{R : Type u_1} [add_left_cancel_semigroup R] (g : R) : is_add_left_regular g",
    "args": "{R : Type u_1} [add_left_cancel_semigroup R] (g : R)",
    "doc_string": "Elements of an add left cancel semigroup are add-left-regular.",
    "type": "is_add_left_regular g"
  },
  {
    "name": "set.interval_subset_interval_union_interval",
    "statement": "theorem set.interval_subset_interval_union_interval {α : Type u} [linear_order α] {a b c : α} : set.interval a c ⊆ set.interval a b ∪ set.interval b c",
    "theorem": "{α : Type u} [linear_order α] {a b c : α} : set.interval a c ⊆ set.interval a b ∪ set.interval b c",
    "args": "{α : Type u} [linear_order α] {a b c : α}",
    "doc_string": "A sort of triangle inequality.",
    "type": "set.interval a c ⊆ set.interval a b ∪ set.interval b c"
  },
  {
    "name": "add_neg",
    "statement": "theorem add_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0)",
    "doc_string": "**Alias** of `left.add_neg`.",
    "type": "a + b < 0"
  },
  {
    "name": "fintype.is_prime_pow_card_of_field",
    "statement": "theorem fintype.is_prime_pow_card_of_field {α : Type u_1} [fintype α] [field α] : is_prime_pow (fintype.card α)",
    "theorem": "{α : Type u_1} [fintype α] [field α] : is_prime_pow (fintype.card α)",
    "args": "{α : Type u_1} [fintype α] [field α]",
    "doc_string": "A finite field has prime power cardinality.",
    "type": "is_prime_pow (fintype.card α)"
  },
  {
    "name": "group.fg_iff_monoid.fg",
    "statement": "theorem group.fg_iff_monoid.fg {G : Type u_3} [group G] : group.fg G ↔ monoid.fg G",
    "theorem": "{G : Type u_3} [group G] : group.fg G ↔ monoid.fg G",
    "args": "{G : Type u_3} [group G]",
    "doc_string": "A group is finitely generated if and only if it is finitely generated as a monoid.",
    "type": "group.fg G ↔ monoid.fg G"
  },
  {
    "name": "neg_of_neg_pos",
    "statement": "theorem neg_of_neg_pos {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : 0 < -a → a < 0",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : 0 < -a → a < 0",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α}",
    "doc_string": "**Alias** of the forward direction of left.one_lt_inv_iff`.",
    "type": "0 < -a → a < 0"
  },
  {
    "name": "is_topological_fiber_bundle_snd",
    "statement": "theorem is_topological_fiber_bundle_snd {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.snd",
    "theorem": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.snd",
    "args": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F]",
    "doc_string": "The second projection in a product is a topological fiber bundle.",
    "type": "is_topological_fiber_bundle F prod.snd"
  },
  {
    "name": "tendsto_rpow_div",
    "statement": "theorem tendsto_rpow_div  : filter.tendsto (λ (x : ℝ), x ^ (1 / x)) filter.at_top (nhds 1)",
    "theorem": " : filter.tendsto (λ (x : ℝ), x ^ (1 / x)) filter.at_top (nhds 1)",
    "args": "",
    "doc_string": "The function `x ^ (1 / x)` tends to `1` at `+∞`.",
    "type": "filter.tendsto (λ (x : ℝ), x ^ (1 / x)) filter.at_top (nhds 1)"
  },
  {
    "name": "strict_convex_iff_convex",
    "statement": "theorem strict_convex_iff_convex {𝕜 : Type u_1} [linear_ordered_field 𝕜] [topological_space 𝕜] [order_topology 𝕜] {s : set 𝕜} : strict_convex 𝕜 s ↔ convex 𝕜 s",
    "theorem": "{𝕜 : Type u_1} [linear_ordered_field 𝕜] [topological_space 𝕜] [order_topology 𝕜] {s : set 𝕜} : strict_convex 𝕜 s ↔ convex 𝕜 s",
    "args": "{𝕜 : Type u_1} [linear_ordered_field 𝕜] [topological_space 𝕜] [order_topology 𝕜] {s : set 𝕜}",
    "doc_string": "A set in a linear ordered field is strictly convex if and only if it is convex.",
    "type": "strict_convex 𝕜 s ↔ convex 𝕜 s"
  },
  {
    "name": "category_theory.has_finite_products_of_has_binary_and_terminal",
    "statement": "theorem category_theory.has_finite_products_of_has_binary_and_terminal {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C]",
    "doc_string": "If `C` has a terminal object and binary products, then it has finite products.",
    "type": "category_theory.limits.has_finite_products C"
  },
  {
    "name": "equiv.add_right_symm_apply",
    "statement": "theorem equiv.add_right_symm_apply {G : Type u_10} [add_group G] (a : G) : ⇑(equiv.symm (equiv.add_right a)) = λ (x : G), x + -a",
    "theorem": "{G : Type u_10} [add_group G] (a : G) : ⇑(equiv.symm (equiv.add_right a)) = λ (x : G), x + -a",
    "args": "{G : Type u_10} [add_group G] (a : G)",
    "doc_string": "Extra simp lemma that `dsimp` can use. `simp` will never use this.",
    "type": "⇑(equiv.symm (equiv.add_right a)) = λ (x : G), x + -a"
  },
  {
    "name": "has_le.le.lt_of_not_le",
    "statement": "theorem has_le.le.lt_of_not_le {α : Type u} [preorder α] {a b : α} : a ≤ b → ¬b ≤ a → a < b",
    "theorem": "{α : Type u} [preorder α] {a b : α} : a ≤ b → ¬b ≤ a → a < b",
    "args": "{α : Type u} [preorder α] {a b : α}",
    "doc_string": "**Alias** of lt_of_le_not_le`.",
    "type": "a ≤ b → ¬b ≤ a → a < b"
  },
  {
    "name": "equiv.mul_swap_involutive",
    "statement": "theorem equiv.mul_swap_involutive {α : Type u} [decidable_eq α] (i j : α) : function.involutive (λ (_x : equiv.perm α), _x * equiv.swap i j)",
    "theorem": "{α : Type u} [decidable_eq α] (i j : α) : function.involutive (λ (_x : equiv.perm α), _x * equiv.swap i j)",
    "args": "{α : Type u} [decidable_eq α] (i j : α)",
    "doc_string": "A stronger version of `mul_left_injective`",
    "type": "function.involutive (λ (_x : equiv.perm α), _x * equiv.swap i j)"
  },
  {
    "name": "filter.tendsto_at_bot_at_bot_of_monotone'",
    "statement": "theorem filter.tendsto_at_bot_at_bot_of_monotone' {ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_below (set.range u)) : filter.tendsto u filter.at_bot filter.at_bot",
    "theorem": "{ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_below (set.range u)) : filter.tendsto u filter.at_bot filter.at_bot",
    "args": "{ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_below (set.range u))",
    "doc_string": " If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded below, then `tendsto u at_bot at_bot`.",
    "type": "filter.tendsto u filter.at_bot filter.at_bot"
  },
  {
    "name": "is_right_regular_of_non_zero_divisor",
    "statement": "theorem is_right_regular_of_non_zero_divisor {α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), x * k = 0 → x = 0) : is_right_regular k",
    "theorem": "{α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), x * k = 0 → x = 0) : is_right_regular k",
    "args": "{α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), x * k = 0 → x = 0)",
    "doc_string": " Right `mul` by a `k : α` over `[ring α]` is injective, if `k` is not a zero divisor. The typeclass that restricts all terms of `α` to have this property is `no_zero_divisors`.",
    "type": "is_right_regular k"
  },
  {
    "name": "has_btw.btw.cyclic_right",
    "statement": "theorem has_btw.btw.cyclic_right {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : has_btw.btw c a b",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : has_btw.btw c a b",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c)",
    "doc_string": "**Alias** of btw_cyclic_right`.",
    "type": "has_btw.btw c a b"
  },
  {
    "name": "lt_of_tsub_lt_tsub_right",
    "statement": "theorem lt_of_tsub_lt_tsub_right {α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] (h : a - c < b - c) : a < b",
    "theorem": "{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] (h : a - c < b - c) : a < b",
    "args": "{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] (h : a - c < b - c)",
    "doc_string": "See `lt_of_tsub_lt_tsub_right_of_le` for a weaker statement in a partial order.",
    "type": "a < b"
  },
  {
    "name": "exists_open_with_compact_closure",
    "statement": "theorem exists_open_with_compact_closure {α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] (x : α) : ∃ (U : set α), is_open U ∧ x ∈ U ∧ is_compact (closure U)",
    "theorem": "{α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] (x : α) : ∃ (U : set α), is_open U ∧ x ∈ U ∧ is_compact (closure U)",
    "args": "{α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] (x : α)",
    "doc_string": "In a locally compact T₂ space, every point has an open neighborhood with compact closure",
    "type": "∃ (U : set α), is_open U ∧ x ∈ U ∧ is_compact (closure U)"
  },
  {
    "name": "real.tendsto_log_at_top",
    "statement": "theorem real.tendsto_log_at_top  : filter.tendsto real.log filter.at_top filter.at_top",
    "theorem": " : filter.tendsto real.log filter.at_top filter.at_top",
    "args": "",
    "doc_string": "The real logarithm function tends to `+∞` at `+∞`.",
    "type": "filter.tendsto real.log filter.at_top filter.at_top"
  },
  {
    "name": "discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization.to_unique_factorization_monoid",
    "statement": "theorem discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization.to_unique_factorization_monoid {R : Type u_1} [comm_ring R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) [is_domain R] : unique_factorization_monoid R",
    "theorem": "{R : Type u_1} [comm_ring R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) [is_domain R] : unique_factorization_monoid R",
    "args": "{R : Type u_1} [comm_ring R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) [is_domain R]",
    "doc_string": " An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a unique factorization domain. See `discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization`.",
    "type": "unique_factorization_monoid R"
  },
  {
    "name": "padic_val_nat.div",
    "statement": "theorem padic_val_nat.div {p : ℕ} [p_prime : fact (nat.prime p)] {b : ℕ} (dvd : p ∣ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1",
    "theorem": "{p : ℕ} [p_prime : fact (nat.prime p)] {b : ℕ} (dvd : p ∣ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1",
    "args": "{p : ℕ} [p_prime : fact (nat.prime p)] {b : ℕ} (dvd : p ∣ b)",
    "doc_string": "Dividing out by a prime factor reduces the padic_val_nat by 1.",
    "type": "padic_val_nat p (b / p) = padic_val_nat p b - 1"
  },
  {
    "name": "function.antiperiodic.periodic",
    "statement": "theorem function.antiperiodic.periodic {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [semiring α] [add_group β] (h : function.antiperiodic f c) : function.periodic f (2 * c)",
    "theorem": "{α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [semiring α] [add_group β] (h : function.antiperiodic f c) : function.periodic f (2 * c)",
    "args": "{α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [semiring α] [add_group β] (h : function.antiperiodic f c)",
    "doc_string": "If a function is `antiperiodic` with antiperiod `c`, then it is also `periodic` with period  `2 * c`.",
    "type": "function.periodic f (2 * c)"
  },
  {
    "name": "is_submonoid.Inter",
    "statement": "theorem is_submonoid.Inter {M : Type u_1} [monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_submonoid (s y)) : is_submonoid (set.Inter s)",
    "theorem": "{M : Type u_1} [monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_submonoid (s y)) : is_submonoid (set.Inter s)",
    "args": "{M : Type u_1} [monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_submonoid (s y))",
    "doc_string": "The intersection of an indexed set of submonoids of a monoid `M` is a submonoid of `M`.",
    "type": "is_submonoid (set.Inter s)"
  },
  {
    "name": "same_ray.refl",
    "statement": "theorem same_ray.refl {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : M) : same_ray R x x",
    "theorem": "{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : M) : same_ray R x x",
    "args": "{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : M)",
    "doc_string": "`same_ray` is reflexive.",
    "type": "same_ray R x x"
  },
  {
    "name": "indexed_partition.out_proj",
    "statement": "theorem indexed_partition.out_proj {ι : Type u_1} {α : Type u_2} {s : ι → set α} (hs : indexed_partition s) (x : α) : ⇑(hs.out) (hs.proj x) = hs.some (hs.index x)",
    "theorem": "{ι : Type u_1} {α : Type u_2} {s : ι → set α} (hs : indexed_partition s) (x : α) : ⇑(hs.out) (hs.proj x) = hs.some (hs.index x)",
    "args": "{ι : Type u_1} {α : Type u_2} {s : ι → set α} (hs : indexed_partition s) (x : α)",
    "doc_string": "This lemma is analogous to `quotient.mk_out'`.",
    "type": "⇑(hs.out) (hs.proj x) = hs.some (hs.index x)"
  },
  {
    "name": "option.subsingleton_iff_is_empty",
    "statement": "theorem option.subsingleton_iff_is_empty {α : Type u_1} : subsingleton (option α) ↔ is_empty α",
    "theorem": "{α : Type u_1} : subsingleton (option α) ↔ is_empty α",
    "args": "{α : Type u_1}",
    "doc_string": "`option α` is a `subsingleton` if and only if `α` is empty.",
    "type": "subsingleton (option α) ↔ is_empty α"
  },
  {
    "name": "cardinal.sum_lt_prod",
    "statement": "theorem cardinal.sum_lt_prod {ι : Type u_1} (f g : ι → cardinal) (H : ∀ (i : ι), f i < g i) : cardinal.sum f < cardinal.prod g",
    "theorem": "{ι : Type u_1} (f g : ι → cardinal) (H : ∀ (i : ι), f i < g i) : cardinal.sum f < cardinal.prod g",
    "args": "{ι : Type u_1} (f g : ι → cardinal) (H : ∀ (i : ι), f i < g i)",
    "doc_string": "**König's theorem**",
    "type": "cardinal.sum f < cardinal.prod g"
  },
  {
    "name": "add_pos'",
    "statement": "theorem add_pos' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "**Alias** of `left.add_pos'`.",
    "type": "0 < a + b"
  },
  {
    "name": "rack.assoc_iff_id",
    "statement": "theorem rack.assoc_iff_id {R : Type u_1} [rack R] {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z ↔ shelf.act x z = z",
    "theorem": "{R : Type u_1} [rack R] {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z ↔ shelf.act x z = z",
    "args": "{R : Type u_1} [rack R] {x y z : R}",
    "doc_string": "Associative racks are uninteresting.",
    "type": "shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z ↔ shelf.act x z = z"
  },
  {
    "name": "not_not",
    "statement": "theorem not_not {a : Prop} : ¬¬a ↔ a",
    "theorem": "{a : Prop} : ¬¬a ↔ a",
    "args": "{a : Prop}",
    "doc_string": " The Double Negation Theorem: `¬ ¬ P` is equivalent to `P`. The left-to-right direction, double negation elimination (DNE), is classically true but not constructively.",
    "type": "¬¬a ↔ a"
  },
  {
    "name": "topological_space.exists_dense_seq",
    "statement": "theorem topological_space.exists_dense_seq (α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : ∃ (u : ℕ → α), dense_range u",
    "theorem": "(α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : ∃ (u : ℕ → α), dense_range u",
    "args": "(α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α]",
    "doc_string": " A nonempty separable space admits a sequence with dense range. Instead of running `cases` on the conclusion of this lemma, you might want to use `topological_space.dense_seq` and `topological_space.dense_range_dense_seq`.  If `α` might be empty, then `exists_countable_dense` is the main way to use separability of `α`.",
    "type": "∃ (u : ℕ → α), dense_range u"
  },
  {
    "name": "is_of_fin_order_inv_iff",
    "statement": "theorem is_of_fin_order_inv_iff {G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x",
    "theorem": "{G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x",
    "args": "{G : Type u} [group G] {x : G}",
    "doc_string": "Inverses of elements of finite order have finite order.",
    "type": "is_of_fin_order x⁻¹ ↔ is_of_fin_order x"
  },
  {
    "name": "finsupp.single_injective",
    "statement": "theorem finsupp.single_injective {α : Type u_1} {M : Type u_5} [has_zero M] (a : α) : function.injective (finsupp.single a)",
    "theorem": "{α : Type u_1} {M : Type u_5} [has_zero M] (a : α) : function.injective (finsupp.single a)",
    "args": "{α : Type u_1} {M : Type u_5} [has_zero M] (a : α)",
    "doc_string": " `finsupp.single a b` is injective in `b`. For the statement that it is injective in `a`, see `finsupp.single_left_injective`",
    "type": "function.injective (finsupp.single a)"
  },
  {
    "name": "is_pi_system.prod",
    "statement": "theorem is_pi_system.prod {α : Type u_1} {β : Type u_3} {C : set (set α)} {D : set (set β)} (hC : is_pi_system C) (hD : is_pi_system D) : is_pi_system (set.image2 has_set_prod.prod C D)",
    "theorem": "{α : Type u_1} {β : Type u_3} {C : set (set α)} {D : set (set β)} (hC : is_pi_system C) (hD : is_pi_system D) : is_pi_system (set.image2 has_set_prod.prod C D)",
    "args": "{α : Type u_1} {β : Type u_3} {C : set (set α)} {D : set (set β)} (hC : is_pi_system C) (hD : is_pi_system D)",
    "doc_string": "Rectangles formed by π-systems form a π-system.",
    "type": "is_pi_system (set.image2 has_set_prod.prod C D)"
  },
  {
    "name": "nat.factors_count_eq",
    "statement": "theorem nat.factors_count_eq {n p : ℕ} : list.count p n.factors = ⇑(n.factorization) p",
    "theorem": "{n p : ℕ} : list.count p n.factors = ⇑(n.factorization) p",
    "args": "{n p : ℕ}",
    "doc_string": " We can write both `n.factorization p` and `n.factors.count p` to represent the power of `p` in the factorization of `n`: we declare the former to be the simp-normal form. However, since `factorization` is a finsupp it's noncomputable.  This theorem can also be used in reverse to compute values of `factorization n p` when required.",
    "type": "list.count p n.factors = ⇑(n.factorization) p"
  },
  {
    "name": "not_bdd_above_iff'",
    "statement": "theorem not_bdd_above_iff' {α : Type u} [preorder α] {s : set α} : ¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), ¬y ≤ x",
    "theorem": "{α : Type u} [preorder α] {s : set α} : ¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), ¬y ≤ x",
    "args": "{α : Type u} [preorder α] {s : set α}",
    "doc_string": " A set `s` is not bounded above if and only if for each `x` there exists `y ∈ s` such that `x` is not greater than or equal to `y`. This version only assumes `preorder` structure and uses `¬(y ≤ x)`. A version for linear orders is called `not_bdd_above_iff`.",
    "type": "¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), ¬y ≤ x"
  },
  {
    "name": "pythagorean_triple_comm",
    "statement": "theorem pythagorean_triple_comm {x y z : ℤ} : pythagorean_triple x y z ↔ pythagorean_triple y x z",
    "theorem": "{x y z : ℤ} : pythagorean_triple x y z ↔ pythagorean_triple y x z",
    "args": "{x y z : ℤ}",
    "doc_string": " Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity.",
    "type": "pythagorean_triple x y z ↔ pythagorean_triple y x z"
  },
  {
    "name": "int.le_zpow_iff_clog_le",
    "statement": "theorem int.le_zpow_iff_clog_le {R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : r ≤ ↑b ^ x ↔ int.clog b r ≤ x",
    "theorem": "{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : r ≤ ↑b ^ x ↔ int.clog b r ≤ x",
    "args": "{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r)",
    "doc_string": "`int.clog b` and `zpow b` (almost) form a Galois connection.",
    "type": "r ≤ ↑b ^ x ↔ int.clog b r ≤ x"
  },
  {
    "name": "nat.le_induction",
    "statement": "theorem nat.le_induction {P : ℕ → Prop} {m : ℕ} (h0 : P m) (h1 : ∀ (n : ℕ), m ≤ n → P n → P (n + 1)) (n : ℕ) : m ≤ n → P n",
    "theorem": "{P : ℕ → Prop} {m : ℕ} (h0 : P m) (h1 : ∀ (n : ℕ), m ≤ n → P n → P (n + 1)) (n : ℕ) : m ≤ n → P n",
    "args": "{P : ℕ → Prop} {m : ℕ} (h0 : P m) (h1 : ∀ (n : ℕ), m ≤ n → P n → P (n + 1)) (n : ℕ)",
    "doc_string": "Induction principle starting at a non-zero number. For maps to a `Sort*` see `le_rec_on`.",
    "type": "m ≤ n → P n"
  },
  {
    "name": "is_of_fin_order_neg_iff",
    "statement": "theorem is_of_fin_order_neg_iff {G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) ↔ is_of_fin_add_order x",
    "theorem": "{G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) ↔ is_of_fin_add_order x",
    "args": "{G : Type u} [add_group G] {x : G}",
    "doc_string": "Inverses of elements of finite additive order have finite additive order.",
    "type": "is_of_fin_add_order (-x) ↔ is_of_fin_add_order x"
  },
  {
    "name": "metric.continuous_inf_dist_pt",
    "statement": "theorem metric.continuous_inf_dist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_dist x s)",
    "theorem": "{α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_dist x s)",
    "args": "{α : Type u} [pseudo_metric_space α] (s : set α)",
    "doc_string": "The minimal distance to a set is continuous in point",
    "type": "continuous (λ (x : α), metric.inf_dist x s)"
  },
  {
    "name": "measurable.of_comap_le",
    "statement": "theorem measurable.of_comap_le {α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable_space.comap f m₂ ≤ m₁ → measurable f",
    "theorem": "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable_space.comap f m₂ ≤ m₁ → measurable f",
    "args": "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β}",
    "doc_string": "**Alias** of the reverse direction of measurable_iff_comap_le`.",
    "type": "measurable_space.comap f m₂ ≤ m₁ → measurable f"
  },
  {
    "name": "zero_lt.left.mul_nonneg",
    "statement": "theorem zero_lt.left.mul_nonneg {α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b",
    "theorem": "{α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b",
    "args": "{α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b)",
    "doc_string": "Assumes left covariance.",
    "type": "0 ≤ a * b"
  },
  {
    "name": "formal_multilinear_series.comp_partial_sum_target_tendsto_at_top",
    "statement": "theorem formal_multilinear_series.comp_partial_sum_target_tendsto_at_top  : filter.tendsto (λ (N : ℕ), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top",
    "theorem": " : filter.tendsto (λ (N : ℕ), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top",
    "args": "",
    "doc_string": " The auxiliary set corresponding to the composition of partial sums asymptotically contains all possible compositions.",
    "type": "filter.tendsto (λ (N : ℕ), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top"
  },
  {
    "name": "algebra.finite_type.of_finite_presentation",
    "statement": "theorem algebra.finite_type.of_finite_presentation {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_presentation R A → algebra.finite_type R A",
    "theorem": "{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_presentation R A → algebra.finite_type R A",
    "args": "{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A]",
    "doc_string": "A finitely presented algebra is of finite type.",
    "type": "algebra.finite_presentation R A → algebra.finite_type R A"
  },
  {
    "name": "fin.coe_fin_lt",
    "statement": "theorem fin.coe_fin_lt {n : ℕ} {a b : fin n} : ↑a < ↑b ↔ a < b",
    "theorem": "{n : ℕ} {a b : fin n} : ↑a < ↑b ↔ a < b",
    "args": "{n : ℕ} {a b : fin n}",
    "doc_string": "`a < b` as natural numbers if and only if `a < b` in `fin n`.",
    "type": "↑a < ↑b ↔ a < b"
  },
  {
    "name": "is_add_monoid_hom.is_add_monoid_hom_mul_right",
    "statement": "theorem is_add_monoid_hom.is_add_monoid_hom_mul_right {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x)",
    "theorem": "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x)",
    "args": "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ)",
    "doc_string": "Right multiplication in a ring is an additive monoid morphism.",
    "type": "is_add_monoid_hom (λ (y : γ), y * x)"
  },
  {
    "name": "has_le.le.lt_or_eq",
    "statement": "theorem has_le.le.lt_or_eq {α : Type u} [partial_order α] {a b : α} : a ≤ b → a < b ∨ a = b",
    "theorem": "{α : Type u} [partial_order α] {a b : α} : a ≤ b → a < b ∨ a = b",
    "args": "{α : Type u} [partial_order α] {a b : α}",
    "doc_string": "**Alias** of lt_or_eq_of_le`.",
    "type": "a ≤ b → a < b ∨ a = b"
  },
  {
    "name": "continuous_map.continuous_eval_const'",
    "statement": "theorem continuous_map.continuous_eval_const' {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] (a : α) : continuous (λ (f : C(α, β)), ⇑f a)",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] (a : α) : continuous (λ (f : C(α, β)), ⇑f a)",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] (a : α)",
    "doc_string": "See also `continuous_map.continuous_eval_const`",
    "type": "continuous (λ (f : C(α, β)), ⇑f a)"
  },
  {
    "name": "order.lt_of_pred_lt_pred",
    "statement": "theorem order.lt_of_pred_lt_pred {α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : order.pred a < order.pred b → a < b",
    "theorem": "{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : order.pred a < order.pred b → a < b",
    "args": "{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α]",
    "doc_string": "**Alias** of the forward direction of order.pred_lt_pred_iff`.",
    "type": "order.pred a < order.pred b → a < b"
  },
  {
    "name": "mul_dvd_mul_iff_left",
    "statement": "theorem mul_dvd_mul_iff_left {α : Type u_1} [cancel_monoid_with_zero α] {a b c : α} (ha : a ≠ 0) : a * b ∣ a * c ↔ b ∣ c",
    "theorem": "{α : Type u_1} [cancel_monoid_with_zero α] {a b c : α} (ha : a ≠ 0) : a * b ∣ a * c ↔ b ∣ c",
    "args": "{α : Type u_1} [cancel_monoid_with_zero α] {a b c : α} (ha : a ≠ 0)",
    "doc_string": "Given two elements `b`, `c` of a `cancel_monoid_with_zero` and a nonzero element `a`, `a*b` divides `a*c` iff `b` divides `c`.",
    "type": "a * b ∣ a * c ↔ b ∣ c"
  },
  {
    "name": "vadd_comm_class.symm",
    "statement": "theorem vadd_comm_class.symm (M : Type u_1) (N : Type u_2) (α : Type u_3) [has_vadd M α] [has_vadd N α] [vadd_comm_class M N α] : vadd_comm_class N M α",
    "theorem": "(M : Type u_1) (N : Type u_2) (α : Type u_3) [has_vadd M α] [has_vadd N α] [vadd_comm_class M N α] : vadd_comm_class N M α",
    "args": "(M : Type u_1) (N : Type u_2) (α : Type u_3) [has_vadd M α] [has_vadd N α] [vadd_comm_class M N α]",
    "doc_string": " Commutativity of additive actions is a symmetric relation. This lemma can't be an instance because this would cause a loop in the instance search graph.",
    "type": "vadd_comm_class N M α"
  },
  {
    "name": "is_unit.dvd_mul_left",
    "statement": "theorem is_unit.dvd_mul_left {α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u) : a ∣ u * b ↔ a ∣ b",
    "theorem": "{α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u) : a ∣ u * b ↔ a ∣ b",
    "args": "{α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u)",
    "doc_string": "In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left    associates of `b`.",
    "type": "a ∣ u * b ↔ a ∣ b"
  },
  {
    "name": "zero_lt.preorder.left.one_le_mul_of_le_of_le",
    "statement": "theorem zero_lt.preorder.left.one_le_mul_of_le_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 < a) : 1 ≤ a * b",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 < a) : 1 ≤ a * b",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 < a)",
    "doc_string": "Assumes left covariance.",
    "type": "1 ≤ a * b"
  },
  {
    "name": "dense.inter_of_open_left",
    "statement": "theorem dense.inter_of_open_left {α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s ∩ t)",
    "theorem": "{α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s ∩ t)",
    "args": "{α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hso : is_open s)",
    "doc_string": "The intersection of an open dense set with a dense set is a dense set.",
    "type": "dense (s ∩ t)"
  },
  {
    "name": "is_smul_regular.pow_iff",
    "statement": "theorem is_smul_regular.pow_iff {R : Type u_1} {M : Type u_3} {a : R} [monoid R] [mul_action R M] {n : ℕ} (n0 : 0 < n) : is_smul_regular M (a ^ n) ↔ is_smul_regular M a",
    "theorem": "{R : Type u_1} {M : Type u_3} {a : R} [monoid R] [mul_action R M] {n : ℕ} (n0 : 0 < n) : is_smul_regular M (a ^ n) ↔ is_smul_regular M a",
    "args": "{R : Type u_1} {M : Type u_3} {a : R} [monoid R] [mul_action R M] {n : ℕ} (n0 : 0 < n)",
    "doc_string": "An element `a` is `M`-regular if and only if a positive power of `a` is `M`-regular.",
    "type": "is_smul_regular M (a ^ n) ↔ is_smul_regular M a"
  },
  {
    "name": "polynomial.sum_taylor_eq",
    "statement": "theorem polynomial.sum_taylor_eq {R : Type u_1} [comm_ring R] (f : polynomial R) (r : R) : (⇑(polynomial.taylor r) f).sum (λ (i : ℕ) (a : R), ⇑polynomial.C a * (polynomial.X - ⇑polynomial.C r) ^ i) = f",
    "theorem": "{R : Type u_1} [comm_ring R] (f : polynomial R) (r : R) : (⇑(polynomial.taylor r) f).sum (λ (i : ℕ) (a : R), ⇑polynomial.C a * (polynomial.X - ⇑polynomial.C r) ^ i) = f",
    "args": "{R : Type u_1} [comm_ring R] (f : polynomial R) (r : R)",
    "doc_string": "Taylor's formula.",
    "type": "(⇑(polynomial.taylor r) f).sum (λ (i : ℕ) (a : R), ⇑polynomial.C a * (polynomial.X - ⇑polynomial.C r) ^ i) = f"
  },
  {
    "name": "add_semiconj_by.zero_right",
    "statement": "theorem add_semiconj_by.zero_right {M : Type u} [add_zero_class M] (a : M) : add_semiconj_by a 0 0",
    "theorem": "{M : Type u} [add_zero_class M] (a : M) : add_semiconj_by a 0 0",
    "args": "{M : Type u} [add_zero_class M] (a : M)",
    "doc_string": "Any element additively semiconjugates `0` to `0`.",
    "type": "add_semiconj_by a 0 0"
  },
  {
    "name": "iterated_deriv_succ'",
    "statement": "theorem iterated_deriv_succ' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} : iterated_deriv (n + 1) f = iterated_deriv n (deriv f)",
    "theorem": "{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} : iterated_deriv (n + 1) f = iterated_deriv n (deriv f)",
    "args": "{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F}",
    "doc_string": " The `n+1`-th iterated derivative can be obtained by taking the `n`-th derivative of the derivative.",
    "type": "iterated_deriv (n + 1) f = iterated_deriv n (deriv f)"
  },
  {
    "name": "zero_lt.left.one_le_mul_of_le_of_le",
    "statement": "theorem zero_lt.left.one_le_mul_of_le_of_le {α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 ≤ a) : 1 ≤ a * b",
    "theorem": "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 ≤ a) : 1 ≤ a * b",
    "args": "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 ≤ a)",
    "doc_string": "Assumes left covariance.",
    "type": "1 ≤ a * b"
  },
  {
    "name": "right.add_nonneg",
    "statement": "theorem right.add_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_nonneg`.",
    "type": "0 ≤ a + b"
  },
  {
    "name": "tactic.ring2.correctness",
    "statement": "theorem tactic.ring2.correctness {α : Type u_1} [comm_semiring α] (t : tree α) (r₁ r₂ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr r₁ = tactic.ring2.horner_expr.of_csexpr r₂) : tactic.ring2.csring_expr.eval t r₁ = tactic.ring2.csring_expr.eval t r₂",
    "theorem": "{α : Type u_1} [comm_semiring α] (t : tree α) (r₁ r₂ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr r₁ = tactic.ring2.horner_expr.of_csexpr r₂) : tactic.ring2.csring_expr.eval t r₁ = tactic.ring2.csring_expr.eval t r₂",
    "args": "{α : Type u_1} [comm_semiring α] (t : tree α) (r₁ r₂ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr r₁ = tactic.ring2.horner_expr.of_csexpr r₂)",
    "doc_string": " The main proof-by-reflection theorem. Given reflected csring expressions `r₁` and `r₂` plus a storage `t` of atoms, if both expressions go to the same Horner normal form, then the original non-reflected expressions are equal. `H` follows from kernel reduction and is therefore `rfl`.",
    "type": "tactic.ring2.csring_expr.eval t r₁ = tactic.ring2.csring_expr.eval t r₂"
  },
  {
    "name": "discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization",
    "statement": "theorem discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R",
    "theorem": "{R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R",
    "args": "{R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R)",
    "doc_string": "An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring.",
    "type": "discrete_valuation_ring R"
  },
  {
    "name": "ring.two_ne_zero",
    "statement": "theorem ring.two_ne_zero {R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0",
    "theorem": "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0",
    "args": "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2)",
    "doc_string": "We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`.",
    "type": "2 ≠ 0"
  },
  {
    "name": "list.of_fn_zero",
    "statement": "theorem list.of_fn_zero {α : Type u} (f : fin 0 → α) : list.of_fn f = list.nil",
    "theorem": "{α : Type u} (f : fin 0 → α) : list.of_fn f = list.nil",
    "args": "{α : Type u} (f : fin 0 → α)",
    "doc_string": "`of_fn` on an empty domain is the empty list.",
    "type": "list.of_fn f = list.nil"
  },
  {
    "name": "is_unit.mul_left_dvd",
    "statement": "theorem is_unit.mul_left_dvd {α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u) : u * a ∣ b ↔ a ∣ b",
    "theorem": "{α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u) : u * a ∣ b ↔ a ∣ b",
    "args": "{α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u)",
    "doc_string": "In a commutative monoid, an element `a` divides an element `b` iff all  left associates of `a` divide `b`.",
    "type": "u * a ∣ b ↔ a ∣ b"
  },
  {
    "name": "real.not_summable_nat_cast_inv",
    "statement": "theorem real.not_summable_nat_cast_inv  : ¬summable (λ (n : ℕ), (↑n)⁻¹)",
    "theorem": " : ¬summable (λ (n : ℕ), (↑n)⁻¹)",
    "args": "",
    "doc_string": "Harmonic series is not unconditionally summable.",
    "type": "¬summable (λ (n : ℕ), (↑n)⁻¹)"
  },
  {
    "name": "char_eq_exp_char_iff",
    "statement": "theorem char_eq_exp_char_iff (R : Type u) [semiring R] (p q : ℕ) [hp : char_p R p] [hq : exp_char R q] : p = q ↔ nat.prime p",
    "theorem": "(R : Type u) [semiring R] (p q : ℕ) [hp : char_p R p] [hq : exp_char R q] : p = q ↔ nat.prime p",
    "args": "(R : Type u) [semiring R] (p q : ℕ) [hp : char_p R p] [hq : exp_char R q]",
    "doc_string": "The characteristic equals the exponential characteristic iff the former is prime.",
    "type": "p = q ↔ nat.prime p"
  },
  {
    "name": "category_theory.simple_of_is_simple_order_subobject",
    "statement": "theorem category_theory.simple_of_is_simple_order_subobject {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)] : category_theory.simple X",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)] : category_theory.simple X",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)]",
    "doc_string": "If `X` has subobject lattice `{⊥, ⊤}`, then `X` is simple.",
    "type": "category_theory.simple X"
  },
  {
    "name": "category_theory.limits.has_pushouts_of_has_binary_coproducts_of_has_coequalizers",
    "statement": "theorem category_theory.limits.has_pushouts_of_has_binary_coproducts_of_has_coequalizers (C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_pushouts C",
    "theorem": "(C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_pushouts C",
    "args": "(C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C]",
    "doc_string": "If a category has all binary coproducts and all coequalizers, then it also has all pushouts.    As usual, this is not an instance, since there may be a more direct way to construct    pushouts.",
    "type": "category_theory.limits.has_pushouts C"
  },
  {
    "name": "is_group_hom.inv",
    "statement": "theorem is_group_hom.inv {α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f : α → β} (hf : is_group_hom f) : is_group_hom (λ (a : α), (f a)⁻¹)",
    "theorem": "{α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f : α → β} (hf : is_group_hom f) : is_group_hom (λ (a : α), (f a)⁻¹)",
    "args": "{α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f : α → β} (hf : is_group_hom f)",
    "doc_string": "The inverse of a group homomorphism is a group homomorphism if the target is commutative.",
    "type": "is_group_hom (λ (a : α), (f a)⁻¹)"
  },
  {
    "name": "list.prod_pos",
    "statement": "theorem list.prod_pos {R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : ∀ (a : R), a ∈ l → 0 < a) : 0 < l.prod",
    "theorem": "{R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : ∀ (a : R), a ∈ l → 0 < a) : 0 < l.prod",
    "args": "{R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : ∀ (a : R), a ∈ l → 0 < a)",
    "doc_string": " The product of a list of positive natural numbers is positive, and likewise for any nontrivial ordered semiring.",
    "type": "0 < l.prod"
  },
  {
    "name": "subgroup.is_open_of_one_mem_interior",
    "statement": "theorem subgroup.is_open_of_one_mem_interior {G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ∈ interior ↑H) : is_open ↑H",
    "theorem": "{G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ∈ interior ↑H) : is_open ↑H",
    "args": "{G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ∈ interior ↑H)",
    "doc_string": "If a subgroup of a topological group has `1` in its interior, then it is open.",
    "type": "is_open ↑H"
  },
  {
    "name": "dot_self_cross",
    "statement": "theorem dot_self_cross {R : Type u_1} [comm_ring R] (v w : fin 3 → R) : matrix.dot_product v (⇑(⇑cross_product v) w) = 0",
    "theorem": "{R : Type u_1} [comm_ring R] (v w : fin 3 → R) : matrix.dot_product v (⇑(⇑cross_product v) w) = 0",
    "args": "{R : Type u_1} [comm_ring R] (v w : fin 3 → R)",
    "doc_string": "The cross product of two vectors is perpendicular to the first vector.",
    "type": "matrix.dot_product v (⇑(⇑cross_product v) w) = 0"
  },
  {
    "name": "is_compact.ultrafilter_le_nhds",
    "statement": "theorem is_compact.ultrafilter_le_nhds {α : Type u} [topological_space α] {s : set α} : is_compact s → ∀ (f : ultrafilter α), ↑f ≤ filter.principal s → (∃ (a : α) (H : a ∈ s), ↑f ≤ nhds a)",
    "theorem": "{α : Type u} [topological_space α] {s : set α} : is_compact s → ∀ (f : ultrafilter α), ↑f ≤ filter.principal s → (∃ (a : α) (H : a ∈ s), ↑f ≤ nhds a)",
    "args": "{α : Type u} [topological_space α] {s : set α}",
    "doc_string": "**Alias** of the forward direction of is_compact_iff_ultrafilter_le_nhds`.",
    "type": "is_compact s → ∀ (f : ultrafilter α), ↑f ≤ filter.principal s → (∃ (a : α) (H : a ∈ s), ↑f ≤ nhds a)"
  },
  {
    "name": "function.not_surjective_Type",
    "statement": "theorem function.not_surjective_Type {α : Type u} (f : α → Type (max u v)) : ¬function.surjective f",
    "theorem": "{α : Type u} (f : α → Type (max u v)) : ¬function.surjective f",
    "args": "{α : Type u} (f : α → Type (max u v))",
    "doc_string": "There is no surjection from `α : Type u` into `Type u`. This theorem  demonstrates why `Type : Type` would be inconsistent in Lean.",
    "type": "¬function.surjective f"
  },
  {
    "name": "continuous_map.continuous_eval",
    "statement": "theorem continuous_map.continuous_eval {α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] : continuous (λ (p : C(α, β) × α), ⇑(p.fst) p.snd)",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] : continuous (λ (p : C(α, β) × α), ⇑(p.fst) p.snd)",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β]",
    "doc_string": "See also `continuous_map.continuous_eval'`",
    "type": "continuous (λ (p : C(α, β) × α), ⇑(p.fst) p.snd)"
  },
  {
    "name": "is_mul_hom.inv",
    "statement": "theorem is_mul_hom.inv {α : Type u_1} {β : Type u_2} [has_mul α] [comm_group β] {f : α → β} (hf : is_mul_hom f) : is_mul_hom (λ (a : α), (f a)⁻¹)",
    "theorem": "{α : Type u_1} {β : Type u_2} [has_mul α] [comm_group β] {f : α → β} (hf : is_mul_hom f) : is_mul_hom (λ (a : α), (f a)⁻¹)",
    "args": "{α : Type u_1} {β : Type u_2} [has_mul α] [comm_group β] {f : α → β} (hf : is_mul_hom f)",
    "doc_string": " The inverse of a map which preserves multiplication, preserves multiplication when the target is commutative.",
    "type": "is_mul_hom (λ (a : α), (f a)⁻¹)"
  },
  {
    "name": "powers.is_submonoid",
    "statement": "theorem powers.is_submonoid {M : Type u_1} [monoid M] (x : M) : is_submonoid (powers x)",
    "theorem": "{M : Type u_1} [monoid M] (x : M) : is_submonoid (powers x)",
    "args": "{M : Type u_1} [monoid M] (x : M)",
    "doc_string": "The set of natural number powers of an element of a monoid `M` is a submonoid of `M`.",
    "type": "is_submonoid (powers x)"
  },
  {
    "name": "add_semiconj_by.zero_left",
    "statement": "theorem add_semiconj_by.zero_left {M : Type u} [add_zero_class M] (x : M) : add_semiconj_by 0 x x",
    "theorem": "{M : Type u} [add_zero_class M] (x : M) : add_semiconj_by 0 x x",
    "args": "{M : Type u} [add_zero_class M] (x : M)",
    "doc_string": "Zero additively semiconjugates any element to itself.",
    "type": "add_semiconj_by 0 x x"
  },
  {
    "name": "int.zpow_lt_iff_lt_clog",
    "statement": "theorem int.zpow_lt_iff_lt_clog {R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : ↑b ^ x < r ↔ x < int.clog b r",
    "theorem": "{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : ↑b ^ x < r ↔ x < int.clog b r",
    "args": "{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r)",
    "doc_string": "`int.clog b` and `zpow b` (almost) form a Galois connection.",
    "type": "↑b ^ x < r ↔ x < int.clog b r"
  },
  {
    "name": "bdd_below.inter_of_right",
    "statement": "theorem bdd_below.inter_of_right {α : Type u} [preorder α] {s t : set α} (h : bdd_below t) : bdd_below (s ∩ t)",
    "theorem": "{α : Type u} [preorder α] {s t : set α} (h : bdd_below t) : bdd_below (s ∩ t)",
    "args": "{α : Type u} [preorder α] {s t : set α} (h : bdd_below t)",
    "doc_string": "If `t` is bounded, then so is `s ∩ t`",
    "type": "bdd_below (s ∩ t)"
  },
  {
    "name": "category_theory.is_subterminal.mono_terminal_from",
    "statement": "theorem category_theory.is_subterminal.mono_terminal_from {C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A)",
    "theorem": "{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A)",
    "args": "{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A)",
    "doc_string": "If `A` is subterminal, the unique morphism from it to the terminal object is a monomorphism. The converse of `is_subterminal_of_mono_terminal_from`.",
    "type": "category_theory.mono (category_theory.limits.terminal.from A)"
  },
  {
    "name": "range.is_add_submonoid",
    "statement": "theorem range.is_add_submonoid {M : Type u_1} [add_monoid M] {γ : Type u_2} [add_monoid γ] {f : M → γ} (hf : is_add_monoid_hom f) : is_add_submonoid (set.range f)",
    "theorem": "{M : Type u_1} [add_monoid M] {γ : Type u_2} [add_monoid γ] {f : M → γ} (hf : is_add_monoid_hom f) : is_add_submonoid (set.range f)",
    "args": "{M : Type u_1} [add_monoid M] {γ : Type u_2} [add_monoid γ] {f : M → γ} (hf : is_add_monoid_hom f)",
    "doc_string": "The image of an `add_monoid` hom is an `add_submonoid` of the codomain.",
    "type": "is_add_submonoid (set.range f)"
  },
  {
    "name": "commute.eq",
    "statement": "theorem commute.eq {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : a * b = b * a",
    "theorem": "{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : a * b = b * a",
    "args": "{S : Type u_1} [has_mul S] {a b : S} (h : commute a b)",
    "doc_string": "Equality behind `commute a b`; useful for rewriting.",
    "type": "a * b = b * a"
  },
  {
    "name": "complex.det_conj_lie",
    "statement": "theorem complex.det_conj_lie  : ⇑linear_map.det ↑(complex.conj_lie.to_linear_equiv) = -1",
    "theorem": " : ⇑linear_map.det ↑(complex.conj_lie.to_linear_equiv) = -1",
    "args": "",
    "doc_string": "The determinant of `conj_lie`, as a linear map.",
    "type": "⇑linear_map.det ↑(complex.conj_lie.to_linear_equiv) = -1"
  },
  {
    "name": "nat.dvd_left_injective",
    "statement": "theorem nat.dvd_left_injective  : function.injective has_dvd.dvd",
    "theorem": " : function.injective has_dvd.dvd",
    "args": "",
    "doc_string": "`dvd` is injective in the left argument",
    "type": "function.injective has_dvd.dvd"
  },
  {
    "name": "seq_closure_subset_closure",
    "statement": "theorem seq_closure_subset_closure {X : Type u_1} [topological_space X] (s : set X) : seq_closure s ⊆ closure s",
    "theorem": "{X : Type u_1} [topological_space X] (s : set X) : seq_closure s ⊆ closure s",
    "args": "{X : Type u_1} [topological_space X] (s : set X)",
    "doc_string": " The sequential closure of a set is contained in the closure of that set. The converse is not true.",
    "type": "seq_closure s ⊆ closure s"
  },
  {
    "name": "dense_range.quotient",
    "statement": "theorem dense_range.quotient {α : Type u} {β : Type v} [setoid α] [topological_space α] {f : β → α} (hf : dense_range f) : dense_range (quotient.mk ∘ f)",
    "theorem": "{α : Type u} {β : Type v} [setoid α] [topological_space α] {f : β → α} (hf : dense_range f) : dense_range (quotient.mk ∘ f)",
    "args": "{α : Type u} {β : Type v} [setoid α] [topological_space α] {f : β → α} (hf : dense_range f)",
    "doc_string": "The composition of `quotient.mk` and a function with dense range has dense range.",
    "type": "dense_range (quotient.mk ∘ f)"
  },
  {
    "name": "add_pos_of_nonneg_of_pos",
    "statement": "theorem add_pos_of_nonneg_of_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b)",
    "doc_string": "**Alias** of `left.add_pos_of_nonneg_of_pos`.",
    "type": "0 < a + b"
  },
  {
    "name": "max_chain_spec",
    "statement": "theorem max_chain_spec {α : Type u_1} {r : α → α → Prop} : is_max_chain r (max_chain r)",
    "theorem": "{α : Type u_1} {r : α → α → Prop} : is_max_chain r (max_chain r)",
    "args": "{α : Type u_1} {r : α → α → Prop}",
    "doc_string": " **Hausdorff's maximality principle**  There exists a maximal totally ordered set of `α`. Note that we do not require `α` to be partially ordered by `r`.",
    "type": "is_max_chain r (max_chain r)"
  },
  {
    "name": "zero_lt.left.mul_lt_one_of_lt_of_le",
    "statement": "theorem zero_lt.left.mul_lt_one_of_lt_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a < 1) (hb : b ≤ 1) (a0 : 0 < a) : a * b < 1",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a < 1) (hb : b ≤ 1) (a0 : 0 < a) : a * b < 1",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a < 1) (hb : b ≤ 1) (a0 : 0 < a)",
    "doc_string": "Assumes left covariance.",
    "type": "a * b < 1"
  },
  {
    "name": "is_max.to_dual",
    "statement": "theorem is_max.to_dual {α : Type u_1} [has_le α] {a : α} : is_max a → is_min (⇑order_dual.to_dual a)",
    "theorem": "{α : Type u_1} [has_le α] {a : α} : is_max a → is_min (⇑order_dual.to_dual a)",
    "args": "{α : Type u_1} [has_le α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of is_min_to_dual_iff`.",
    "type": "is_max a → is_min (⇑order_dual.to_dual a)"
  },
  {
    "name": "exists_lt_of_lt_csupr",
    "statement": "theorem exists_lt_of_lt_csupr {α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {b : α} [nonempty ι] {f : ι → α} (h : b < supr f) : ∃ (i : ι), b < f i",
    "theorem": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {b : α} [nonempty ι] {f : ι → α} (h : b < supr f) : ∃ (i : ι), b < f i",
    "args": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {b : α} [nonempty ι] {f : ι → α} (h : b < supr f)",
    "doc_string": "Indexed version of the above lemma `exists_lt_of_lt_cSup`. When `b < supr f`, there is an element `i` such that `b < f i`.",
    "type": "∃ (i : ι), b < f i"
  },
  {
    "name": "is_preconnected_Icc",
    "statement": "theorem is_preconnected_Icc {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a b : α} : is_preconnected (set.Icc a b)",
    "theorem": "{α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a b : α} : is_preconnected (set.Icc a b)",
    "args": "{α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a b : α}",
    "doc_string": "A closed interval in a densely ordered conditionally complete linear order is preconnected.",
    "type": "is_preconnected (set.Icc a b)"
  },
  {
    "name": "order.pfilter.ext",
    "statement": "theorem order.pfilter.ext {P : Type u_1} [preorder P] (s t : order.pfilter P) (h : ↑s = ↑t) : s = t",
    "theorem": "{P : Type u_1} [preorder P] (s t : order.pfilter P) (h : ↑s = ↑t) : s = t",
    "args": "{P : Type u_1} [preorder P] (s t : order.pfilter P) (h : ↑s = ↑t)",
    "doc_string": "Two filters are equal when their underlying sets are equal.",
    "type": "s = t"
  },
  {
    "name": "inv_le",
    "statement": "theorem inv_le {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b ↔ b⁻¹ ≤ a",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b ↔ b⁻¹ ≤ a",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": " In a linear ordered field, for positive `a` and `b` we have `a⁻¹ ≤ b ↔ b⁻¹ ≤ a`. See also `inv_le_of_inv_le` for a one-sided implication with one fewer assumption.",
    "type": "a⁻¹ ≤ b ↔ b⁻¹ ≤ a"
  },
  {
    "name": "left.add_nonneg",
    "statement": "theorem left.add_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_nonneg`.",
    "type": "0 ≤ a + b"
  },
  {
    "name": "finite_dimensional.finrank_pos_iff",
    "statement": "theorem finite_dimensional.finrank_pos_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ nontrivial V",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ nontrivial V",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V]",
    "doc_string": "A finite dimensional space has positive `finrank` iff it is nontrivial.",
    "type": "0 < finite_dimensional.finrank K V ↔ nontrivial V"
  },
  {
    "name": "ordinal.bdd_above_range",
    "statement": "theorem ordinal.bdd_above_range {ι : Type u} (f : ι → ordinal) : bdd_above (set.range f)",
    "theorem": "{ι : Type u} (f : ι → ordinal) : bdd_above (set.range f)",
    "args": "{ι : Type u} (f : ι → ordinal)",
    "doc_string": "The range of any family of ordinals is bounded above. See also `lsub_not_mem_range`.",
    "type": "bdd_above (set.range f)"
  },
  {
    "name": "is_extr_filter.undual",
    "statement": "theorem is_extr_filter.undual {α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_extr_filter (⇑order_dual.to_dual ∘ f) l a → is_extr_filter f l a",
    "theorem": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_extr_filter (⇑order_dual.to_dual ∘ f) l a → is_extr_filter f l a",
    "args": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α}",
    "doc_string": "**Alias** of the forward direction of is_extr_filter_dual_iff`.",
    "type": "is_extr_filter (⇑order_dual.to_dual ∘ f) l a → is_extr_filter f l a"
  },
  {
    "name": "mul_dvd_mul_iff_right",
    "statement": "theorem mul_dvd_mul_iff_right {α : Type u_1} [cancel_comm_monoid_with_zero α] {a b c : α} (hc : c ≠ 0) : a * c ∣ b * c ↔ a ∣ b",
    "theorem": "{α : Type u_1} [cancel_comm_monoid_with_zero α] {a b c : α} (hc : c ≠ 0) : a * c ∣ b * c ↔ a ∣ b",
    "args": "{α : Type u_1} [cancel_comm_monoid_with_zero α] {a b c : α} (hc : c ≠ 0)",
    "doc_string": "Given two elements `a`, `b` of a commutative `cancel_monoid_with_zero` and a nonzero  element `c`, `a*c` divides `b*c` iff `a` divides `b`.",
    "type": "a * c ∣ b * c ↔ a ∣ b"
  },
  {
    "name": "extend_partial_order",
    "statement": "theorem extend_partial_order {α : Type u} (r : α → α → Prop) [is_partial_order α r] : ∃ (s : α → α → Prop) (_x : is_linear_order α s), r ≤ s",
    "theorem": "{α : Type u} (r : α → α → Prop) [is_partial_order α r] : ∃ (s : α → α → Prop) (_x : is_linear_order α s), r ≤ s",
    "args": "{α : Type u} (r : α → α → Prop) [is_partial_order α r]",
    "doc_string": "Any partial order can be extended to a linear order.",
    "type": "∃ (s : α → α → Prop) (_x : is_linear_order α s), r ≤ s"
  },
  {
    "name": "commute.mul_right",
    "statement": "theorem commute.mul_right {S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)",
    "theorem": "{S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)",
    "args": "{S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c)",
    "doc_string": "If `a` commutes with both `b` and `c`, then it commutes with their product.",
    "type": "commute a (b * c)"
  },
  {
    "name": "finsum_mem_empty",
    "statement": "theorem finsum_mem_empty {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} : finsum (λ (i : α), finsum (λ (H : i ∈ ∅), f i)) = 0",
    "theorem": "{α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} : finsum (λ (i : α), finsum (λ (H : i ∈ ∅), f i)) = 0",
    "args": "{α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M}",
    "doc_string": "The sum of any function over an empty set is `0`.",
    "type": "finsum (λ (i : α), finsum (λ (H : i ∈ ∅), f i)) = 0"
  },
  {
    "name": "pythagorean_triple.zero",
    "statement": "theorem pythagorean_triple.zero  : pythagorean_triple 0 0 0",
    "theorem": " : pythagorean_triple 0 0 0",
    "args": "",
    "doc_string": "The zeroth Pythagorean triple is all zeros.",
    "type": "pythagorean_triple 0 0 0"
  },
  {
    "name": "is_coprime.ne_zero",
    "statement": "theorem is_coprime.ne_zero {R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1)) : p ≠ 0",
    "theorem": "{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1)) : p ≠ 0",
    "args": "{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1))",
    "doc_string": "If a 2-vector `p` satisfies `is_coprime (p 0) (p 1)`, then `p ≠ 0`.",
    "type": "p ≠ 0"
  },
  {
    "name": "bdd_below_insert",
    "statement": "theorem bdd_below_insert {γ : Type w} [semilattice_inf γ] (a : γ) {s : set γ} : bdd_below (has_insert.insert a s) ↔ bdd_below s",
    "theorem": "{γ : Type w} [semilattice_inf γ] (a : γ) {s : set γ} : bdd_below (has_insert.insert a s) ↔ bdd_below s",
    "args": "{γ : Type w} [semilattice_inf γ] (a : γ) {s : set γ}",
    "doc_string": "Adding a point to a set preserves its boundedness below.",
    "type": "bdd_below (has_insert.insert a s) ↔ bdd_below s"
  },
  {
    "name": "is_simple_group_of_prime_card",
    "statement": "theorem is_simple_group_of_prime_card {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α",
    "theorem": "{α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α",
    "args": "{α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p)",
    "doc_string": "A finite group of prime order is simple.",
    "type": "is_simple_group α"
  },
  {
    "name": "bool.apply_apply_apply",
    "statement": "theorem bool.apply_apply_apply (f : bool → bool) (x : bool) : f (f (f x)) = f x",
    "theorem": "(f : bool → bool) (x : bool) : f (f (f x)) = f x",
    "args": "(f : bool → bool) (x : bool)",
    "doc_string": "**Kaminski's Equation**",
    "type": "f (f (f x)) = f x"
  },
  {
    "name": "has_le.le.antisymm'",
    "statement": "theorem has_le.le.antisymm' {α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≤ a → b = a",
    "theorem": "{α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≤ a → b = a",
    "args": "{α : Type u} [partial_order α] {a b : α}",
    "doc_string": "**Alias** of ge_antisymm`.",
    "type": "a ≤ b → b ≤ a → b = a"
  },
  {
    "name": "pow_gcd_card_eq_one_iff",
    "statement": "theorem pow_gcd_card_eq_one_iff {G : Type u} {x : G} {n : ℕ} [fintype G] [group G] : x ^ n = 1 ↔ x ^ n.gcd (fintype.card G) = 1",
    "theorem": "{G : Type u} {x : G} {n : ℕ} [fintype G] [group G] : x ^ n = 1 ↔ x ^ n.gcd (fintype.card G) = 1",
    "args": "{G : Type u} {x : G} {n : ℕ} [fintype G] [group G]",
    "doc_string": "TODO: Generalise to `finite_cancel_monoid`.",
    "type": "x ^ n = 1 ↔ x ^ n.gcd (fintype.card G) = 1"
  },
  {
    "name": "polynomial.cyclotomic_expand_eq_cyclotomic",
    "statement": "theorem polynomial.cyclotomic_expand_eq_cyclotomic {p n : ℕ} (hp : nat.prime p) (hdiv : p ∣ n) (R : Type u_1) [comm_ring R] : ⇑(polynomial.expand R p) (polynomial.cyclotomic n R) = polynomial.cyclotomic (n * p) R",
    "theorem": "{p n : ℕ} (hp : nat.prime p) (hdiv : p ∣ n) (R : Type u_1) [comm_ring R] : ⇑(polynomial.expand R p) (polynomial.cyclotomic n R) = polynomial.cyclotomic (n * p) R",
    "args": "{p n : ℕ} (hp : nat.prime p) (hdiv : p ∣ n) (R : Type u_1) [comm_ring R]",
    "doc_string": " If `p` is a prime such that `p ∣ n`, then `expand R p (cyclotomic n R) = cyclotomic (p * n) R`.",
    "type": "⇑(polynomial.expand R p) (polynomial.cyclotomic n R) = polynomial.cyclotomic (n * p) R"
  },
  {
    "name": "is_smul_regular.subsingleton",
    "statement": "theorem is_smul_regular.subsingleton {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] (h : is_smul_regular M 0) : subsingleton M",
    "theorem": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] (h : is_smul_regular M 0) : subsingleton M",
    "args": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] (h : is_smul_regular M 0)",
    "doc_string": "The element `0` is `M`-regular if and only if `M` is trivial.",
    "type": "subsingleton M"
  },
  {
    "name": "finrank_eq_one_iff",
    "statement": "theorem finrank_eq_one_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι] : finite_dimensional.finrank K V = 1 ↔ nonempty (basis ι K V)",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι] : finite_dimensional.finrank K V = 1 ↔ nonempty (basis ι K V)",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι]",
    "doc_string": "A module has dimension 1 iff there is some `v : V` so `{v}` is a basis.",
    "type": "finite_dimensional.finrank K V = 1 ↔ nonempty (basis ι K V)"
  },
  {
    "name": "is_of_fin_order.mul",
    "statement": "theorem is_of_fin_order.mul {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)",
    "theorem": "{G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)",
    "args": "{G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y)",
    "doc_string": "Elements of finite order are closed under multiplication.",
    "type": "is_of_fin_order (x * y)"
  },
  {
    "name": "is_localization.is_domain_localization",
    "statement": "theorem is_localization.is_domain_localization {A : Type u_6} [comm_ring A] [is_domain A] {M : submonoid A} (hM : M ≤ non_zero_divisors A) : is_domain (localization M)",
    "theorem": "{A : Type u_6} [comm_ring A] [is_domain A] {M : submonoid A} (hM : M ≤ non_zero_divisors A) : is_domain (localization M)",
    "args": "{A : Type u_6} [comm_ring A] [is_domain A] {M : submonoid A} (hM : M ≤ non_zero_divisors A)",
    "doc_string": " The localization at of an integral domain to a set of non-zero elements is an integral domain. See note [reducible non-instances].",
    "type": "is_domain (localization M)"
  },
  {
    "name": "sub_mul",
    "statement": "theorem sub_mul {α : Type u} [non_unital_non_assoc_ring α] (a b c : α) : (a - b) * c = a * c - b * c",
    "theorem": "{α : Type u} [non_unital_non_assoc_ring α] (a b c : α) : (a - b) * c = a * c - b * c",
    "args": "{α : Type u} [non_unital_non_assoc_ring α] (a b c : α)",
    "doc_string": "**Alias** of mul_sub_right_distrib`.",
    "type": "(a - b) * c = a * c - b * c"
  },
  {
    "name": "is_ring_hom.of_semiring",
    "statement": "theorem is_ring_hom.of_semiring {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (H : is_semiring_hom f) : is_ring_hom f",
    "theorem": "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (H : is_semiring_hom f) : is_ring_hom f",
    "args": "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (H : is_semiring_hom f)",
    "doc_string": "A map of rings that is a semiring homomorphism is also a ring homomorphism.",
    "type": "is_ring_hom f"
  },
  {
    "name": "tsub_nonpos_of_le",
    "statement": "theorem tsub_nonpos_of_le {α : Type u_1} [preorder α] [add_comm_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} : a ≤ b → a - b ≤ 0",
    "theorem": "{α : Type u_1} [preorder α] [add_comm_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} : a ≤ b → a - b ≤ 0",
    "args": "{α : Type u_1} [preorder α] [add_comm_monoid α] [has_sub α] [has_ordered_sub α] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of tsub_nonpos`.",
    "type": "a ≤ b → a - b ≤ 0"
  },
  {
    "name": "category_theory.limits.has_binary_biproduct.of_has_binary_product",
    "statement": "theorem category_theory.limits.has_binary_biproduct.of_has_binary_product {C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_product X Y] : category_theory.limits.has_binary_biproduct X Y",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_product X Y] : category_theory.limits.has_binary_biproduct X Y",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_product X Y]",
    "doc_string": "In a preadditive category, if the product of `X` and `Y` exists, then the    binary biproduct of `X` and `Y` exists.",
    "type": "category_theory.limits.has_binary_biproduct X Y"
  },
  {
    "name": "finite_dimensional.finrank_pos",
    "statement": "theorem finite_dimensional.finrank_pos {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V] : 0 < finite_dimensional.finrank K V",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V] : 0 < finite_dimensional.finrank K V",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V]",
    "doc_string": "A nontrivial finite dimensional space has positive `finrank`.",
    "type": "0 < finite_dimensional.finrank K V"
  },
  {
    "name": "is_open_map_snd",
    "statement": "theorem is_open_map_snd {α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.snd",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.snd",
    "args": "{α : Type u} {β : Type v} [topological_space α] [topological_space β]",
    "doc_string": "The second projection in a product of topological spaces sends open sets to open sets.",
    "type": "is_open_map prod.snd"
  },
  {
    "name": "is_torsion_free.prod",
    "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)",
    "theorem": "{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)",
    "args": "{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i))",
    "doc_string": "Direct products of torsion free groups are torsion free.",
    "type": "monoid.is_torsion_free (Π (i : η), Gs i)"
  },
  {
    "name": "continued_fraction.convergents_eq_convergents'",
    "statement": "theorem continued_fraction.convergents_eq_convergents' {K : Type u_1} [linear_ordered_field K] {c : continued_fraction K} : ↑c.convergents = ↑c.convergents'",
    "theorem": "{K : Type u_1} [linear_ordered_field K] {c : continued_fraction K} : ↑c.convergents = ↑c.convergents'",
    "args": "{K : Type u_1} [linear_ordered_field K] {c : continued_fraction K}",
    "doc_string": " Shows that the recurrence relation (`convergents`) and direct evaluation (`convergents'`) of a (regular) continued fraction coincide.",
    "type": "↑c.convergents = ↑c.convergents'"
  },
  {
    "name": "one_lt_inv_of_inv",
    "statement": "theorem one_lt_inv_of_inv {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a < 1 → 1 < a⁻¹",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a < 1 → 1 < a⁻¹",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α}",
    "doc_string": "**Alias** of the reverse direction of left.one_lt_inv_iff`.",
    "type": "a < 1 → 1 < a⁻¹"
  },
  {
    "name": "metric.bounded.union",
    "statement": "theorem metric.bounded.union {α : Type u} [pseudo_metric_space α] {s t : set α} (hs : metric.bounded s) (ht : metric.bounded t) : metric.bounded (s ∪ t)",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s t : set α} (hs : metric.bounded s) (ht : metric.bounded t) : metric.bounded (s ∪ t)",
    "args": "{α : Type u} [pseudo_metric_space α] {s t : set α} (hs : metric.bounded s) (ht : metric.bounded t)",
    "doc_string": "The union of two bounded sets is bounded.",
    "type": "metric.bounded (s ∪ t)"
  },
  {
    "name": "nat.not_bdd_above_set_of_prime",
    "statement": "theorem nat.not_bdd_above_set_of_prime  : ¬bdd_above {p : ℕ | nat.prime p}",
    "theorem": " : ¬bdd_above {p : ℕ | nat.prime p}",
    "args": "",
    "doc_string": "A version of `nat.exists_infinite_primes` using the `bdd_above` predicate.",
    "type": "¬bdd_above {p : ℕ | nat.prime p}"
  },
  {
    "name": "one_lt_of_inv_lt_one",
    "statement": "theorem one_lt_of_inv_lt_one {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 → 1 < a",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 → 1 < a",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α}",
    "doc_string": "**Alias** of the forward direction of left.inv_lt_one_iff`.",
    "type": "a⁻¹ < 1 → 1 < a"
  },
  {
    "name": "is_extr_on.undual",
    "statement": "theorem is_extr_on.undual {α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_extr_on (⇑order_dual.to_dual ∘ f) s a → is_extr_on f s a",
    "theorem": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_extr_on (⇑order_dual.to_dual ∘ f) s a → is_extr_on f s a",
    "args": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α}",
    "doc_string": "**Alias** of the forward direction of is_extr_on_dual_iff`.",
    "type": "is_extr_on (⇑order_dual.to_dual ∘ f) s a → is_extr_on f s a"
  },
  {
    "name": "padic_norm_e.one'",
    "statement": "theorem padic_norm_e.one' {p : ℕ} [fact (nat.prime p)] : padic_norm_e 1 = 1",
    "theorem": "{p : ℕ} [fact (nat.prime p)] : padic_norm_e 1 = 1",
    "args": "{p : ℕ} [fact (nat.prime p)]",
    "doc_string": " Theorems about `padic_norm_e` are named with a `'` so the names do not conflict with the equivalent theorems about `norm` (`∥ ∥`).",
    "type": "padic_norm_e 1 = 1"
  },
  {
    "name": "comm_of",
    "statement": "theorem comm_of {α : Type u} (r : α → α → Prop) [is_symm α r] {a b : α} : r a b ↔ r b a",
    "theorem": "{α : Type u} (r : α → α → Prop) [is_symm α r] {a b : α} : r a b ↔ r b a",
    "args": "{α : Type u} (r : α → α → Prop) [is_symm α r] {a b : α}",
    "doc_string": " A version of `comm` with `r` explicit.  This lemma matches the lemmas from lean core in `init.algebra.classes`, but is missing there.",
    "type": "r a b ↔ r b a"
  },
  {
    "name": "nat.cofinite_eq_at_top",
    "statement": "theorem nat.cofinite_eq_at_top  : filter.cofinite = filter.at_top",
    "theorem": " : filter.cofinite = filter.at_top",
    "args": "",
    "doc_string": "For natural numbers the filters `cofinite` and `at_top` coincide.",
    "type": "filter.cofinite = filter.at_top"
  },
  {
    "name": "char.quadratic_char_eq_neg_one_iff_not_one",
    "statement": "theorem char.quadratic_char_eq_neg_one_iff_not_one {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a = -1 ↔ ¬char.quadratic_char F a = 1",
    "theorem": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a = -1 ↔ ¬char.quadratic_char F a = 1",
    "args": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0)",
    "doc_string": "A variant",
    "type": "char.quadratic_char F a = -1 ↔ ¬char.quadratic_char F a = 1"
  },
  {
    "name": "is_square.exists_sq",
    "statement": "theorem is_square.exists_sq {α : Type u_2} [monoid α] (m : α) : is_square m → (∃ (c : α), m = c ^ 2)",
    "theorem": "{α : Type u_2} [monoid α] (m : α) : is_square m → (∃ (c : α), m = c ^ 2)",
    "args": "{α : Type u_2} [monoid α] (m : α)",
    "doc_string": "**Alias** of the forward direction of is_square_iff_exists_sq`.",
    "type": "is_square m → (∃ (c : α), m = c ^ 2)"
  },
  {
    "name": "one_lt_mul_of_le_of_lt'",
    "statement": "theorem one_lt_mul_of_le_of_lt' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b)",
    "doc_string": "**Alias** of left.one_lt_mul_of_le_of_lt`.",
    "type": "1 < a * b"
  },
  {
    "name": "cardinal.mk_quaternion_algebra",
    "statement": "theorem cardinal.mk_quaternion_algebra {R : Type u_1} (c₁ c₂ : R) : cardinal.mk (quaternion_algebra R c₁ c₂) = cardinal.mk R ^ 4",
    "theorem": "{R : Type u_1} (c₁ c₂ : R) : cardinal.mk (quaternion_algebra R c₁ c₂) = cardinal.mk R ^ 4",
    "args": "{R : Type u_1} (c₁ c₂ : R)",
    "doc_string": "The cardinality of a quaternion algebra, as a type.",
    "type": "cardinal.mk (quaternion_algebra R c₁ c₂) = cardinal.mk R ^ 4"
  },
  {
    "name": "measure_theory.strongly_measurable.measurable",
    "statement": "theorem measure_theory.strongly_measurable.measurable {α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] (hf : measure_theory.strongly_measurable f) : measurable f",
    "theorem": "{α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] (hf : measure_theory.strongly_measurable f) : measurable f",
    "args": "{α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] (hf : measure_theory.strongly_measurable f)",
    "doc_string": "A strongly measurable function is measurable.",
    "type": "measurable f"
  },
  {
    "name": "nnreal.summable_condensed_iff",
    "statement": "theorem nnreal.summable_condensed_iff {f : ℕ → nnreal} (hf : ∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m) : summable (λ (k : ℕ), 2 ^ k * f (2 ^ k)) ↔ summable f",
    "theorem": "{f : ℕ → nnreal} (hf : ∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m) : summable (λ (k : ℕ), 2 ^ k * f (2 ^ k)) ↔ summable f",
    "args": "{f : ℕ → nnreal} (hf : ∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m)",
    "doc_string": "Cauchy condensation test for a series of `nnreal` version.",
    "type": "summable (λ (k : ℕ), 2 ^ k * f (2 ^ k)) ↔ summable f"
  },
  {
    "name": "mul_le_one'",
    "statement": "theorem mul_le_one' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1)",
    "doc_string": "**Alias** of left.mul_le_one`.",
    "type": "a * b ≤ 1"
  },
  {
    "name": "inv_le_one'",
    "statement": "theorem inv_le_one' {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α}",
    "doc_string": "**Alias** of left.inv_le_one_iff`.",
    "type": "a⁻¹ ≤ 1 ↔ 1 ≤ a"
  },
  {
    "name": "is_fraction_ring.is_domain",
    "statement": "theorem is_fraction_ring.is_domain (A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : is_domain K",
    "theorem": "(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : is_domain K",
    "args": "(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K]",
    "doc_string": " A `comm_ring` `K` which is the localization of an integral domain `R` at `R - {0}` is an integral domain.",
    "type": "is_domain K"
  },
  {
    "name": "module.finite.of_basis",
    "statement": "theorem module.finite.of_basis {R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M) : module.finite R M",
    "theorem": "{R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M) : module.finite R M",
    "args": "{R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M)",
    "doc_string": "A free module with a basis indexed by a `fintype` is finite.",
    "type": "module.finite R M"
  },
  {
    "name": "is_right_regular.of_mul",
    "statement": "theorem is_right_regular.of_mul {R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a)) : is_right_regular b",
    "theorem": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a)) : is_right_regular b",
    "args": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a))",
    "doc_string": "  If an element `b` becomes right-regular after multiplying it on the right by a right-regular element, then `b` is right-regular.",
    "type": "is_right_regular b"
  },
  {
    "name": "nat.pow_le_iff_le_log",
    "statement": "theorem nat.pow_le_iff_le_log {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : 0 < y) : b ^ x ≤ y ↔ x ≤ nat.log b y",
    "theorem": "{b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : 0 < y) : b ^ x ≤ y ↔ x ≤ nat.log b y",
    "args": "{b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : 0 < y)",
    "doc_string": "`pow b` and `log b` (almost) form a Galois connection.",
    "type": "b ^ x ≤ y ↔ x ≤ nat.log b y"
  },
  {
    "name": "le_implies_le_of_le_of_le",
    "statement": "theorem le_implies_le_of_le_of_le {α : Type u} {a b c d : α} [preorder α] (hca : c ≤ a) (hbd : b ≤ d) : a ≤ b → c ≤ d",
    "theorem": "{α : Type u} {a b c d : α} [preorder α] (hca : c ≤ a) (hbd : b ≤ d) : a ≤ b → c ≤ d",
    "args": "{α : Type u} {a b c d : α} [preorder α] (hca : c ≤ a) (hbd : b ≤ d)",
    "doc_string": "monotonicity of `≤` with respect to `→`",
    "type": "a ≤ b → c ≤ d"
  },
  {
    "name": "filter.comap_cocompact_le",
    "statement": "theorem filter.comap_cocompact_le {α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : continuous f) : filter.comap f (filter.cocompact β) ≤ filter.cocompact α",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : continuous f) : filter.comap f (filter.cocompact β) ≤ filter.cocompact α",
    "args": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : continuous f)",
    "doc_string": " The comap of the cocompact filter on `β` by a continuous function `f : α → β` is less than or equal to the cocompact filter on `α`. This is a reformulation of the fact that images of compact sets are compact.",
    "type": "filter.comap f (filter.cocompact β) ≤ filter.cocompact α"
  },
  {
    "name": "is_max_on.undual",
    "statement": "theorem is_max_on.undual {α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_max_on (⇑order_dual.to_dual ∘ f) s a → is_min_on f s a",
    "theorem": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_max_on (⇑order_dual.to_dual ∘ f) s a → is_min_on f s a",
    "args": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α}",
    "doc_string": "**Alias** of the forward direction of is_max_on_dual_iff`.",
    "type": "is_max_on (⇑order_dual.to_dual ∘ f) s a → is_min_on f s a"
  },
  {
    "name": "has_btw.btw.sbtw_of_not_btw",
    "statement": "theorem has_btw.btw.sbtw_of_not_btw {α : Type u_1} [circular_preorder α] {a b c : α} (habc : has_btw.btw a b c) (hcba : ¬has_btw.btw c b a) : has_sbtw.sbtw a b c",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (habc : has_btw.btw a b c) (hcba : ¬has_btw.btw c b a) : has_sbtw.sbtw a b c",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (habc : has_btw.btw a b c) (hcba : ¬has_btw.btw c b a)",
    "doc_string": "**Alias** of sbtw_of_btw_not_btw`.",
    "type": "has_sbtw.sbtw a b c"
  },
  {
    "name": "zero_lt.preorder.right.one_le_mul_of_le_of_le",
    "statement": "theorem zero_lt.preorder.right.one_le_mul_of_le_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 < b) : 1 ≤ a * b",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 < b) : 1 ≤ a * b",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "type": "1 ≤ a * b"
  },
  {
    "name": "zmod.legendre_sym_eq_one_or_neg_one",
    "statement": "theorem zmod.legendre_sym_eq_one_or_neg_one (p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ∨ zmod.legendre_sym p a = -1",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ∨ zmod.legendre_sym p a = -1",
    "args": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0)",
    "doc_string": "If `p ∤ a`, then `legendre_sym p a` is `1` or `-1`.",
    "type": "zmod.legendre_sym p a = 1 ∨ zmod.legendre_sym p a = -1"
  },
  {
    "name": "is_top.to_dual",
    "statement": "theorem is_top.to_dual {α : Type u_1} [has_le α] {a : α} : is_top a → is_bot (⇑order_dual.to_dual a)",
    "theorem": "{α : Type u_1} [has_le α] {a : α} : is_top a → is_bot (⇑order_dual.to_dual a)",
    "args": "{α : Type u_1} [has_le α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of is_bot_to_dual_iff`.",
    "type": "is_top a → is_bot (⇑order_dual.to_dual a)"
  },
  {
    "name": "odd.exists_bit1",
    "statement": "theorem odd.exists_bit1 {α : Type u_2} [semiring α] {a : α} : odd a → (∃ (b : α), a = bit1 b)",
    "theorem": "{α : Type u_2} [semiring α] {a : α} : odd a → (∃ (b : α), a = bit1 b)",
    "args": "{α : Type u_2} [semiring α] {a : α}",
    "doc_string": "**Alias** of the forward direction of odd_iff_exists_bit1`.",
    "type": "odd a → (∃ (b : α), a = bit1 b)"
  },
  {
    "name": "padic_val_nat.mul",
    "statement": "theorem padic_val_nat.mul (p : ℕ) [p_prime : fact (nat.prime p)] {q r : ℕ} (hq : q ≠ 0) (hr : r ≠ 0) : padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r",
    "theorem": "(p : ℕ) [p_prime : fact (nat.prime p)] {q r : ℕ} (hq : q ≠ 0) (hr : r ≠ 0) : padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r",
    "args": "(p : ℕ) [p_prime : fact (nat.prime p)] {q r : ℕ} (hq : q ≠ 0) (hr : r ≠ 0)",
    "doc_string": "A rewrite lemma for `padic_val_nat p (q * r)` with conditions `q ≠ 0`, `r ≠ 0`.",
    "type": "padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r"
  },
  {
    "name": "add_hom.congr_fun",
    "statement": "theorem add_hom.congr_fun {M : Type u_3} {N : Type u_4} [has_add M] [has_add N] {f g : add_hom M N} (h : f = g) (x : M) : ⇑f x = ⇑g x",
    "theorem": "{M : Type u_3} {N : Type u_4} [has_add M] [has_add N] {f g : add_hom M N} (h : f = g) (x : M) : ⇑f x = ⇑g x",
    "args": "{M : Type u_3} {N : Type u_4} [has_add M] [has_add N] {f g : add_hom M N} (h : f = g) (x : M)",
    "doc_string": "Deprecated: use `fun_like.congr_fun` instead.",
    "type": "⇑f x = ⇑g x"
  },
  {
    "name": "category_theory.limits.initial_mono_class.of_initial",
    "statement": "theorem category_theory.limits.initial_mono_class.of_initial {C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] (h : ∀ (X : C), category_theory.mono (category_theory.limits.initial.to X)) : category_theory.limits.initial_mono_class C",
    "theorem": "{C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] (h : ∀ (X : C), category_theory.mono (category_theory.limits.initial.to X)) : category_theory.limits.initial_mono_class C",
    "args": "{C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] (h : ∀ (X : C), category_theory.mono (category_theory.limits.initial.to X))",
    "doc_string": " To show a category is a `initial_mono_class` it suffices to show every morphism out of the initial object is a monomorphism.",
    "type": "category_theory.limits.initial_mono_class C"
  },
  {
    "name": "is_dedekind_domain.height_one_spectrum.valuation_uniformizer_ne_zero",
    "statement": "theorem is_dedekind_domain.height_one_spectrum.valuation_uniformizer_ne_zero {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : classical.some _ ≠ 0",
    "theorem": "{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : classical.some _ ≠ 0",
    "args": "{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R)",
    "doc_string": "Uniformizers are nonzero.",
    "type": "classical.some _ ≠ 0"
  },
  {
    "name": "structure_groupoid.id_mem_maximal_atlas",
    "statement": "theorem structure_groupoid.id_mem_maximal_atlas {H : Type u} [topological_space H] (G : structure_groupoid H) : local_homeomorph.refl H ∈ structure_groupoid.maximal_atlas H G",
    "theorem": "{H : Type u} [topological_space H] (G : structure_groupoid H) : local_homeomorph.refl H ∈ structure_groupoid.maximal_atlas H G",
    "args": "{H : Type u} [topological_space H] (G : structure_groupoid H)",
    "doc_string": "In the model space, the identity is in any maximal atlas.",
    "type": "local_homeomorph.refl H ∈ structure_groupoid.maximal_atlas H G"
  },
  {
    "name": "con.eq",
    "statement": "theorem con.eq {M : Type u_1} [has_mul M] (c : con M) {a b : M} : ↑a = ↑b ↔ ⇑c a b",
    "theorem": "{M : Type u_1} [has_mul M] (c : con M) {a b : M} : ↑a = ↑b ↔ ⇑c a b",
    "args": "{M : Type u_1} [has_mul M] (c : con M) {a b : M}",
    "doc_string": "Two elements are related by a congruence relation `c` iff they are represented by the same    element of the quotient by `c`.",
    "type": "↑a = ↑b ↔ ⇑c a b"
  },
  {
    "name": "function.is_fixed_pt.is_periodic_pt",
    "statement": "theorem function.is_fixed_pt.is_periodic_pt {α : Type u_1} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) (n : ℕ) : function.is_periodic_pt f n x",
    "theorem": "{α : Type u_1} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) (n : ℕ) : function.is_periodic_pt f n x",
    "args": "{α : Type u_1} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) (n : ℕ)",
    "doc_string": "A fixed point of `f` is a periodic point of `f` of any prescribed period.",
    "type": "function.is_periodic_pt f n x"
  },
  {
    "name": "left.inv_lt_one_iff",
    "statement": "theorem left.inv_lt_one_iff {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α}",
    "doc_string": "Uses `left` co(ntra)variant.",
    "type": "a⁻¹ < 1 ↔ 1 < a"
  },
  {
    "name": "is_add_regular_add_and_add_iff",
    "statement": "theorem is_add_regular_add_and_add_iff {R : Type u_1} {a b : R} [add_semigroup R] : is_add_regular (a + b) ∧ is_add_regular (b + a) ↔ is_add_regular a ∧ is_add_regular b",
    "theorem": "{R : Type u_1} {a b : R} [add_semigroup R] : is_add_regular (a + b) ∧ is_add_regular (b + a) ↔ is_add_regular a ∧ is_add_regular b",
    "args": "{R : Type u_1} {a b : R} [add_semigroup R]",
    "doc_string": "Two elements `a` and `b` are add-regular if and only if both sums `a + b` and `b + a` are add-regular.",
    "type": "is_add_regular (a + b) ∧ is_add_regular (b + a) ↔ is_add_regular a ∧ is_add_regular b"
  },
  {
    "name": "lt_add_of_neg_add_lt",
    "statement": "theorem lt_add_of_neg_add_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : -b + a < c → a < b + c",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : -b + a < c → a < b + c",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of inv_mul_lt_iff_lt_mul`.",
    "type": "-b + a < c → a < b + c"
  },
  {
    "name": "pow_two_sub_pow_two",
    "statement": "theorem pow_two_sub_pow_two {R : Type u₁} [comm_ring R] (a b : R) : a ^ 2 - b ^ 2 = (a + b) * (a - b)",
    "theorem": "{R : Type u₁} [comm_ring R] (a b : R) : a ^ 2 - b ^ 2 = (a + b) * (a - b)",
    "args": "{R : Type u₁} [comm_ring R] (a b : R)",
    "doc_string": "**Alias** of sq_sub_sq`.",
    "type": "a ^ 2 - b ^ 2 = (a + b) * (a - b)"
  },
  {
    "name": "finset.card_sym2",
    "statement": "theorem finset.card_sym2 {α : Type u_1} [decidable_eq α] (s : finset α) : s.sym2.card = s.card * (s.card + 1) / 2",
    "theorem": "{α : Type u_1} [decidable_eq α] (s : finset α) : s.sym2.card = s.card * (s.card + 1) / 2",
    "args": "{α : Type u_1} [decidable_eq α] (s : finset α)",
    "doc_string": "Finset **stars and bars** for the case `n = 2`.",
    "type": "s.sym2.card = s.card * (s.card + 1) / 2"
  },
  {
    "name": "is_compact.bdd_above",
    "statement": "theorem is_compact.bdd_above {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] {s : set α} (hs : is_compact s) : bdd_above s",
    "theorem": "{α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] {s : set α} (hs : is_compact s) : bdd_above s",
    "args": "{α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] {s : set α} (hs : is_compact s)",
    "doc_string": "A compact set is bounded above",
    "type": "bdd_above s"
  },
  {
    "name": "nat.factorization_disjoint_of_coprime",
    "statement": "theorem nat.factorization_disjoint_of_coprime {a b : ℕ} (hab : a.coprime b) : disjoint a.factorization.support b.factorization.support",
    "theorem": "{a b : ℕ} (hab : a.coprime b) : disjoint a.factorization.support b.factorization.support",
    "args": "{a b : ℕ} (hab : a.coprime b)",
    "doc_string": "The prime factorizations of coprime `a` and `b` are disjoint",
    "type": "disjoint a.factorization.support b.factorization.support"
  },
  {
    "name": "is_min_filter.undual",
    "statement": "theorem is_min_filter.undual {α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_min_filter (⇑order_dual.to_dual ∘ f) l a → is_max_filter f l a",
    "theorem": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_min_filter (⇑order_dual.to_dual ∘ f) l a → is_max_filter f l a",
    "args": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α}",
    "doc_string": "**Alias** of the forward direction of is_min_filter_dual_iff`.",
    "type": "is_min_filter (⇑order_dual.to_dual ∘ f) l a → is_max_filter f l a"
  },
  {
    "name": "has_le.le.eq_of_not_gt",
    "statement": "theorem has_le.le.eq_of_not_gt {α : Type u} [partial_order α] {a b : α} (hab : a ≤ b) (hba : ¬a < b) : b = a",
    "theorem": "{α : Type u} [partial_order α] {a b : α} (hab : a ≤ b) (hba : ¬a < b) : b = a",
    "args": "{α : Type u} [partial_order α] {a b : α} (hab : a ≤ b) (hba : ¬a < b)",
    "doc_string": "**Alias** of eq_of_ge_of_not_gt`.",
    "type": "b = a"
  },
  {
    "name": "real.tendsto_exp_div_pow_at_top",
    "statement": "theorem real.tendsto_exp_div_pow_at_top (n : ℕ) : filter.tendsto (λ (x : ℝ), real.exp x / x ^ n) filter.at_top filter.at_top",
    "theorem": "(n : ℕ) : filter.tendsto (λ (x : ℝ), real.exp x / x ^ n) filter.at_top filter.at_top",
    "args": "(n : ℕ)",
    "doc_string": "The function `exp(x)/x^n` tends to `+∞` at `+∞`, for any natural number `n`",
    "type": "filter.tendsto (λ (x : ℝ), real.exp x / x ^ n) filter.at_top filter.at_top"
  },
  {
    "name": "measurable_sub_const'",
    "statement": "theorem measurable_sub_const' {G : Type u_1} [sub_neg_monoid G] [measurable_space G] [has_measurable_add G] (g : G) : measurable (λ (h : G), h - g)",
    "theorem": "{G : Type u_1} [sub_neg_monoid G] [measurable_space G] [has_measurable_add G] (g : G) : measurable (λ (h : G), h - g)",
    "args": "{G : Type u_1} [sub_neg_monoid G] [measurable_space G] [has_measurable_add G] (g : G)",
    "doc_string": "A version of `measurable_sub_const` that assumes `has_measurable_add` instead of  `has_measurable_sub`. This can be nice to avoid unnecessary type-class assumptions.",
    "type": "measurable (λ (h : G), h - g)"
  },
  {
    "name": "generalized_continued_fraction.int_fract_pair.one_le_succ_nth_stream_b",
    "statement": "theorem generalized_continued_fraction.int_fract_pair.one_le_succ_nth_stream_b {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : 1 ≤ ifp_succ_n.b",
    "theorem": "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : 1 ≤ ifp_succ_n.b",
    "args": "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n)",
    "doc_string": "Shows that the integer parts of the stream are at least one.",
    "type": "1 ≤ ifp_succ_n.b"
  },
  {
    "name": "composition.sigma_composition_eq_iff",
    "statement": "theorem composition.sigma_composition_eq_iff {n : ℕ} (i j : Σ (a : composition n), composition a.length) : i = j ↔ i.fst.blocks = j.fst.blocks ∧ i.snd.blocks = j.snd.blocks",
    "theorem": "{n : ℕ} (i j : Σ (a : composition n), composition a.length) : i = j ↔ i.fst.blocks = j.fst.blocks ∧ i.snd.blocks = j.snd.blocks",
    "args": "{n : ℕ} (i j : Σ (a : composition n), composition a.length)",
    "doc_string": " Rewriting equality in the dependent type `Σ (a : composition n), composition a.length)` in non-dependent terms with lists, requiring that the blocks coincide.",
    "type": "i = j ↔ i.fst.blocks = j.fst.blocks ∧ i.snd.blocks = j.snd.blocks"
  },
  {
    "name": "lower_central_series_is_descending_central_series",
    "statement": "theorem lower_central_series_is_descending_central_series {G : Type u_1} [group G] : is_descending_central_series (lower_central_series G)",
    "theorem": "{G : Type u_1} [group G] : is_descending_central_series (lower_central_series G)",
    "args": "{G : Type u_1} [group G]",
    "doc_string": "The lower central series of a group is a descending central series.",
    "type": "is_descending_central_series (lower_central_series G)"
  },
  {
    "name": "weak_dual.is_closed_polar",
    "statement": "theorem weak_dual.is_closed_polar (𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] (s : set E) : is_closed (weak_dual.polar 𝕜 s)",
    "theorem": "(𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] (s : set E) : is_closed (weak_dual.polar 𝕜 s)",
    "args": "(𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] (s : set E)",
    "doc_string": " The polar `polar 𝕜 s` of a set `s : E` is a closed subset when the weak star topology is used.",
    "type": "is_closed (weak_dual.polar 𝕜 s)"
  },
  {
    "name": "sbtw_cyclic",
    "statement": "theorem sbtw_cyclic {α : Type u_1} [circular_preorder α] {a b c : α} : has_sbtw.sbtw a b c ↔ has_sbtw.sbtw c a b",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} : has_sbtw.sbtw a b c ↔ has_sbtw.sbtw c a b",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α}",
    "doc_string": " The order of the `↔` has been chosen so that `rw sbtw_cyclic` cycles to the right while `rw ←sbtw_cyclic` cycles to the left (thus following the prepended arrow).",
    "type": "has_sbtw.sbtw a b c ↔ has_sbtw.sbtw c a b"
  },
  {
    "name": "polynomial.cyclotomic_injective",
    "statement": "theorem polynomial.cyclotomic_injective {R : Type u_1} [comm_ring R] [char_zero R] : function.injective (λ (n : ℕ), polynomial.cyclotomic n R)",
    "theorem": "{R : Type u_1} [comm_ring R] [char_zero R] : function.injective (λ (n : ℕ), polynomial.cyclotomic n R)",
    "args": "{R : Type u_1} [comm_ring R] [char_zero R]",
    "doc_string": "Over a ring `R` of characteristic zero, `λ n, cyclotomic n R` is injective.",
    "type": "function.injective (λ (n : ℕ), polynomial.cyclotomic n R)"
  },
  {
    "name": "is_compact.inter_right",
    "statement": "theorem is_compact.inter_right {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t)",
    "theorem": "{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t)",
    "args": "{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t)",
    "doc_string": "The intersection of a compact set and a closed set is a compact set.",
    "type": "is_compact (s ∩ t)"
  },
  {
    "name": "padic_val_int.zero",
    "statement": "theorem padic_val_int.zero {p : ℕ} : padic_val_int p 0 = 0",
    "theorem": "{p : ℕ} : padic_val_int p 0 = 0",
    "args": "{p : ℕ}",
    "doc_string": "`padic_val_int p 0` is 0 for any `p`.",
    "type": "padic_val_int p 0 = 0"
  },
  {
    "name": "add_con.coe_zero",
    "statement": "theorem add_con.coe_zero {M : Type u_1} [add_zero_class M] {c : add_con M} : ↑0 = 0",
    "theorem": "{M : Type u_1} [add_zero_class M] {c : add_con M} : ↑0 = 0",
    "args": "{M : Type u_1} [add_zero_class M] {c : add_con M}",
    "doc_string": "The 0 of the quotient of an `add_monoid` by an additive congruence relation is the equivalence class of the `add_monoid`'s 0.",
    "type": "↑0 = 0"
  },
  {
    "name": "int.dvd_of_dvd_mul_left_of_gcd_one",
    "statement": "theorem int.dvd_of_dvd_mul_left_of_gcd_one {a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd c = 1) : a ∣ b",
    "theorem": "{a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd c = 1) : a ∣ b",
    "args": "{a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd c = 1)",
    "doc_string": " Euclid's lemma: if `a ∣ b * c` and `gcd a c = 1` then `a ∣ b`. Compare with `is_coprime.dvd_of_dvd_mul_left` and `unique_factorization_monoid.dvd_of_dvd_mul_left_of_no_prime_factors`",
    "type": "a ∣ b"
  },
  {
    "name": "nndist_self",
    "statement": "theorem nndist_self {α : Type u} [pseudo_metric_space α] (a : α) : has_nndist.nndist a a = 0",
    "theorem": "{α : Type u} [pseudo_metric_space α] (a : α) : has_nndist.nndist a a = 0",
    "args": "{α : Type u} [pseudo_metric_space α] (a : α)",
    "doc_string": "`nndist x x` vanishes",
    "type": "has_nndist.nndist a a = 0"
  },
  {
    "name": "eq_zero_of_zero_eq_one",
    "statement": "theorem eq_zero_of_zero_eq_one {M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) (a : M₀) : a = 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) (a : M₀) : a = 0",
    "args": "{M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) (a : M₀)",
    "doc_string": "In a monoid with zero, if zero equals one, then zero is the only element.",
    "type": "a = 0"
  },
  {
    "name": "Compactum_to_CompHaus.faithful",
    "statement": "theorem Compactum_to_CompHaus.faithful  : category_theory.faithful Compactum_to_CompHaus",
    "theorem": " : category_theory.faithful Compactum_to_CompHaus",
    "args": "",
    "doc_string": "The functor Compactum_to_CompHaus is faithful.",
    "type": "category_theory.faithful Compactum_to_CompHaus"
  },
  {
    "name": "and_or_distrib_right",
    "statement": "theorem and_or_distrib_right {a b c : Prop} : a ∧ b ∨ c ↔ (a ∨ c) ∧ (b ∨ c)",
    "theorem": "{a b c : Prop} : a ∧ b ∨ c ↔ (a ∨ c) ∧ (b ∨ c)",
    "args": "{a b c : Prop}",
    "doc_string": "`∨` distributes over `∧` (on the right).",
    "type": "a ∧ b ∨ c ↔ (a ∨ c) ∧ (b ∨ c)"
  },
  {
    "name": "mul_le_of_le_inv_mul",
    "statement": "theorem mul_le_of_le_inv_mul {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : b ≤ a⁻¹ * c → a * b ≤ c",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : b ≤ a⁻¹ * c → a * b ≤ c",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of le_inv_mul_iff_mul_le`.",
    "type": "b ≤ a⁻¹ * c → a * b ≤ c"
  },
  {
    "name": "powers.self_mem",
    "statement": "theorem powers.self_mem {M : Type u_1} [monoid M] {x : M} : x ∈ powers x",
    "theorem": "{M : Type u_1} [monoid M] {x : M} : x ∈ powers x",
    "args": "{M : Type u_1} [monoid M] {x : M}",
    "doc_string": "An element of a monoid is in the set of that element's natural number powers.",
    "type": "x ∈ powers x"
  },
  {
    "name": "matrix.det_fin_zero",
    "statement": "theorem matrix.det_fin_zero {R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1",
    "theorem": "{R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1",
    "args": "{R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R}",
    "doc_string": "Determinant of 0x0 matrix",
    "type": "A.det = 1"
  },
  {
    "name": "left.mul_lt_one_of_le_of_lt",
    "statement": "theorem left.mul_lt_one_of_le_of_lt {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.mul_lt_one_of_le_of_lt`.",
    "type": "a * b < 1"
  },
  {
    "name": "ereal.neg_le",
    "statement": "theorem ereal.neg_le {a b : ereal} : -a ≤ b ↔ -b ≤ a",
    "theorem": "{a b : ereal} : -a ≤ b ↔ -b ≤ a",
    "args": "{a b : ereal}",
    "doc_string": "`-a ≤ b ↔ -b ≤ a` on `ereal`.",
    "type": "-a ≤ b ↔ -b ≤ a"
  },
  {
    "name": "add_units.is_add_unit_add_add_units",
    "statement": "theorem add_units.is_add_unit_add_add_units {M : Type u_1} [add_monoid M] (a : M) (u : add_units M) : is_add_unit (a + ↑u) ↔ is_add_unit a",
    "theorem": "{M : Type u_1} [add_monoid M] (a : M) (u : add_units M) : is_add_unit (a + ↑u) ↔ is_add_unit a",
    "args": "{M : Type u_1} [add_monoid M] (a : M) (u : add_units M)",
    "doc_string": "Addition of a `u : add_units M` on the right doesn't affect `is_add_unit`.",
    "type": "is_add_unit (a + ↑u) ↔ is_add_unit a"
  },
  {
    "name": "cardinal.cantor",
    "statement": "theorem cardinal.cantor (a : cardinal) : a < 2 ^ a",
    "theorem": "(a : cardinal) : a < 2 ^ a",
    "args": "(a : cardinal)",
    "doc_string": "**Cantor's theorem**",
    "type": "a < 2 ^ a"
  },
  {
    "name": "is_of_fin_add_order.apply",
    "statement": "theorem is_of_fin_add_order.apply {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_add_order x) (i : η) : is_of_fin_add_order (x i)",
    "theorem": "{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_add_order x) (i : η) : is_of_fin_add_order (x i)",
    "args": "{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_add_order x) (i : η)",
    "doc_string": "If a direct product has finite additive order then so does each component.",
    "type": "is_of_fin_add_order (x i)"
  },
  {
    "name": "dot_cross_self",
    "statement": "theorem dot_cross_self {R : Type u_1} [comm_ring R] (v w : fin 3 → R) : matrix.dot_product w (⇑(⇑cross_product v) w) = 0",
    "theorem": "{R : Type u_1} [comm_ring R] (v w : fin 3 → R) : matrix.dot_product w (⇑(⇑cross_product v) w) = 0",
    "args": "{R : Type u_1} [comm_ring R] (v w : fin 3 → R)",
    "doc_string": "The cross product of two vectors is perpendicular to the second vector.",
    "type": "matrix.dot_product w (⇑(⇑cross_product v) w) = 0"
  },
  {
    "name": "filter.tendsto_at_top_at_top_of_monotone'",
    "statement": "theorem filter.tendsto_at_top_at_top_of_monotone' {ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_above (set.range u)) : filter.tendsto u filter.at_top filter.at_top",
    "theorem": "{ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_above (set.range u)) : filter.tendsto u filter.at_top filter.at_top",
    "args": "{ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_above (set.range u))",
    "doc_string": " If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded above, then `tendsto u at_top at_top`.",
    "type": "filter.tendsto u filter.at_top filter.at_top"
  },
  {
    "name": "con.mul",
    "statement": "theorem con.mul {M : Type u_1} [has_mul M] (c : con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w * y) (x * z)",
    "theorem": "{M : Type u_1} [has_mul M] (c : con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w * y) (x * z)",
    "args": "{M : Type u_1} [has_mul M] (c : con M) {w x y z : M}",
    "doc_string": "Multiplicative congruence relations preserve multiplication.",
    "type": "⇑c w x → ⇑c y z → ⇑c (w * y) (x * z)"
  },
  {
    "name": "sub_left_lt_of_lt_add",
    "statement": "theorem sub_left_lt_of_lt_add {α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a < b + c → a - b < c",
    "theorem": "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a < b + c → a - b < c",
    "args": "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of sub_lt_iff_lt_add'`.",
    "type": "a < b + c → a - b < c"
  },
  {
    "name": "complex.linear_equiv_det_conj_lie",
    "statement": "theorem complex.linear_equiv_det_conj_lie  : ⇑linear_equiv.det complex.conj_lie.to_linear_equiv = -1",
    "theorem": " : ⇑linear_equiv.det complex.conj_lie.to_linear_equiv = -1",
    "args": "",
    "doc_string": "The determinant of `conj_lie`, as a linear equiv.",
    "type": "⇑linear_equiv.det complex.conj_lie.to_linear_equiv = -1"
  },
  {
    "name": "padic_val_int.of_nat",
    "statement": "theorem padic_val_int.of_nat {p n : ℕ} : padic_val_int p ↑n = padic_val_nat p n",
    "theorem": "{p n : ℕ} : padic_val_int p ↑n = padic_val_nat p n",
    "args": "{p n : ℕ}",
    "doc_string": "The p-adic value of an natural is its p-adic_value as an integer",
    "type": "padic_val_int p ↑n = padic_val_nat p n"
  },
  {
    "name": "inv_le_inv",
    "statement": "theorem inv_le_inv {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "See `inv_le_inv_of_le` for the implication from right-to-left with one fewer assumption.",
    "type": "a⁻¹ ≤ b⁻¹ ↔ b ≤ a"
  },
  {
    "name": "inv.is_group_hom",
    "statement": "theorem inv.is_group_hom {α : Type u} [comm_group α] : is_group_hom has_inv.inv",
    "theorem": "{α : Type u} [comm_group α] : is_group_hom has_inv.inv",
    "args": "{α : Type u} [comm_group α]",
    "doc_string": "Inversion is a group homomorphism if the group is commutative.",
    "type": "is_group_hom has_inv.inv"
  },
  {
    "name": "totally_bounded.closure",
    "statement": "theorem totally_bounded.closure {α : Type u} [uniform_space α] {s : set α} (h : totally_bounded s) : totally_bounded (closure s)",
    "theorem": "{α : Type u} [uniform_space α] {s : set α} (h : totally_bounded s) : totally_bounded (closure s)",
    "args": "{α : Type u} [uniform_space α] {s : set α} (h : totally_bounded s)",
    "doc_string": "The closure of a totally bounded set is totally bounded.",
    "type": "totally_bounded (closure s)"
  },
  {
    "name": "tendsto_rpow_neg_div",
    "statement": "theorem tendsto_rpow_neg_div  : filter.tendsto (λ (x : ℝ), x ^ ((-1) / x)) filter.at_top (nhds 1)",
    "theorem": " : filter.tendsto (λ (x : ℝ), x ^ ((-1) / x)) filter.at_top (nhds 1)",
    "args": "",
    "doc_string": "The function `x ^ (-1 / x)` tends to `1` at `+∞`.",
    "type": "filter.tendsto (λ (x : ℝ), x ^ ((-1) / x)) filter.at_top (nhds 1)"
  },
  {
    "name": "is_closed_set_of_cluster_pt",
    "statement": "theorem is_closed_set_of_cluster_pt {α : Type u} [topological_space α] {f : filter α} : is_closed {x : α | cluster_pt x f}",
    "theorem": "{α : Type u} [topological_space α] {f : filter α} : is_closed {x : α | cluster_pt x f}",
    "args": "{α : Type u} [topological_space α] {f : filter α}",
    "doc_string": " The set of cluster points of a filter is closed. In particular, the set of limit points of a sequence is closed.",
    "type": "is_closed {x : α | cluster_pt x f}"
  },
  {
    "name": "has_le.le.not_lt",
    "statement": "theorem has_le.le.not_lt {α : Type u} [preorder α] {a b : α} (h : a ≤ b) : ¬b < a",
    "theorem": "{α : Type u} [preorder α] {a b : α} (h : a ≤ b) : ¬b < a",
    "args": "{α : Type u} [preorder α] {a b : α} (h : a ≤ b)",
    "doc_string": "**Alias** of not_lt_of_le`.",
    "type": "¬b < a"
  },
  {
    "name": "function.is_fixed_pt.comp",
    "statement": "theorem function.is_fixed_pt.comp {α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f ∘ g) x",
    "theorem": "{α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f ∘ g) x",
    "args": "{α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x)",
    "doc_string": "If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f ∘ g`.",
    "type": "function.is_fixed_pt (f ∘ g) x"
  },
  {
    "name": "is_add_submonoid.Inter",
    "statement": "theorem is_add_submonoid.Inter {M : Type u_1} [add_monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_add_submonoid (s y)) : is_add_submonoid (set.Inter s)",
    "theorem": "{M : Type u_1} [add_monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_add_submonoid (s y)) : is_add_submonoid (set.Inter s)",
    "args": "{M : Type u_1} [add_monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_add_submonoid (s y))",
    "doc_string": "The intersection of an indexed set of `add_submonoid`s of an `add_monoid` `M` is an `add_submonoid` of `M`.",
    "type": "is_add_submonoid (set.Inter s)"
  },
  {
    "name": "one_hom.ext_iff",
    "statement": "theorem one_hom.ext_iff {M : Type u_3} {N : Type u_4} [has_one M] [has_one N] {f g : one_hom M N} : f = g ↔ ∀ (x : M), ⇑f x = ⇑g x",
    "theorem": "{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] {f g : one_hom M N} : f = g ↔ ∀ (x : M), ⇑f x = ⇑g x",
    "args": "{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] {f g : one_hom M N}",
    "doc_string": "Deprecated: use `fun_like.ext_iff` instead.",
    "type": "f = g ↔ ∀ (x : M), ⇑f x = ⇑g x"
  },
  {
    "name": "complete_lattice.independent.comp",
    "statement": "theorem complete_lattice.independent.comp {ι : Sort u_1} {ι' : Sort u_2} {α : Type u_3} [complete_lattice α] {s : ι → α} (hs : complete_lattice.independent s) (f : ι' → ι) (hf : function.injective f) : complete_lattice.independent (s ∘ f)",
    "theorem": "{ι : Sort u_1} {ι' : Sort u_2} {α : Type u_3} [complete_lattice α] {s : ι → α} (hs : complete_lattice.independent s) (f : ι' → ι) (hf : function.injective f) : complete_lattice.independent (s ∘ f)",
    "args": "{ι : Sort u_1} {ι' : Sort u_2} {α : Type u_3} [complete_lattice α] {s : ι → α} (hs : complete_lattice.independent s) (f : ι' → ι) (hf : function.injective f)",
    "doc_string": " Composing an independent indexed family with an injective function on the index results in another indepedendent indexed family.",
    "type": "complete_lattice.independent (s ∘ f)"
  },
  {
    "name": "cardinal.ord_card_unbounded",
    "statement": "theorem cardinal.ord_card_unbounded  : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b}",
    "theorem": " : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b}",
    "args": "",
    "doc_string": "Ordinals that are cardinals are unbounded.",
    "type": "set.unbounded has_lt.lt {b : ordinal | b.card.ord = b}"
  },
  {
    "name": "right.inv_lt_one_iff",
    "statement": "theorem right.inv_lt_one_iff {α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α}",
    "doc_string": "Uses `right` co(ntra)variant.",
    "type": "a⁻¹ < 1 ↔ 1 < a"
  },
  {
    "name": "dense_closure",
    "statement": "theorem dense_closure {α : Type u} [topological_space α] {s : set α} : dense (closure s) ↔ dense s",
    "theorem": "{α : Type u} [topological_space α] {s : set α} : dense (closure s) ↔ dense s",
    "args": "{α : Type u} [topological_space α] {s : set α}",
    "doc_string": "The closure of a set `s` is dense if and only if `s` is dense.",
    "type": "dense (closure s) ↔ dense s"
  },
  {
    "name": "neg_pos_of_neg",
    "statement": "theorem neg_pos_of_neg {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : a < 0 → 0 < -a",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : a < 0 → 0 < -a",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α}",
    "doc_string": "**Alias** of the reverse direction of left.one_lt_inv_iff`.",
    "type": "a < 0 → 0 < -a"
  },
  {
    "name": "zmod.legendre_sym_eq_one_iff",
    "statement": "theorem zmod.legendre_sym_eq_one_iff (p : ℕ) [fact (nat.prime p)] {a : ℤ} (ha0 : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ↔ is_square ↑a",
    "theorem": "(p : ℕ) [fact (nat.prime p)] {a : ℤ} (ha0 : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ↔ is_square ↑a",
    "args": "(p : ℕ) [fact (nat.prime p)] {a : ℤ} (ha0 : ↑a ≠ 0)",
    "doc_string": "When `p ∤ a`, then `legendre_sym p a = 1` iff `a` is a square mod `p`.",
    "type": "zmod.legendre_sym p a = 1 ↔ is_square ↑a"
  },
  {
    "name": "continuous_iff_seq_continuous",
    "statement": "theorem continuous_iff_seq_continuous {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : continuous f ↔ seq_continuous f",
    "theorem": "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : continuous f ↔ seq_continuous f",
    "args": "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X]",
    "doc_string": "In a sequential space, continuity and sequential continuity coincide.",
    "type": "continuous f ↔ seq_continuous f"
  },
  {
    "name": "eq.trans_le",
    "statement": "theorem eq.trans_le {α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b ≤ c) : a ≤ c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b ≤ c) : a ≤ c",
    "args": "{α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b ≤ c)",
    "doc_string": "**Alias** of le_of_eq_of_le`.",
    "type": "a ≤ c"
  },
  {
    "name": "int.le_induction",
    "statement": "theorem int.le_induction {P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), m ≤ n → P n → P (n + 1)) (n : ℤ) : m ≤ n → P n",
    "theorem": "{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), m ≤ n → P n → P (n + 1)) (n : ℤ) : m ≤ n → P n",
    "args": "{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), m ≤ n → P n → P (n + 1)) (n : ℤ)",
    "doc_string": "See `int.induction_on'` for an induction in both directions.",
    "type": "m ≤ n → P n"
  },
  {
    "name": "is_smul_regular.not_zero_iff",
    "statement": "theorem is_smul_regular.not_zero_iff {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : ¬is_smul_regular M 0 ↔ nontrivial M",
    "theorem": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : ¬is_smul_regular M 0 ↔ nontrivial M",
    "args": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M]",
    "doc_string": "The `0` element is not `M`-regular, on a non-trivial module.",
    "type": "¬is_smul_regular M 0 ↔ nontrivial M"
  },
  {
    "name": "totally_disconnected_space_iff_connected_component_singleton",
    "statement": "theorem totally_disconnected_space_iff_connected_component_singleton {α : Type u} [topological_space α] : totally_disconnected_space α ↔ ∀ (x : α), connected_component x = {x}",
    "theorem": "{α : Type u} [topological_space α] : totally_disconnected_space α ↔ ∀ (x : α), connected_component x = {x}",
    "args": "{α : Type u} [topological_space α]",
    "doc_string": "A space is totally disconnected iff its connected components are singletons.",
    "type": "totally_disconnected_space α ↔ ∀ (x : α), connected_component x = {x}"
  },
  {
    "name": "is_add_group_hom.map_zero",
    "statement": "theorem is_add_group_hom.map_zero {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : f 0 = 0",
    "theorem": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : f 0 = 0",
    "args": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f)",
    "doc_string": "An additive group homomorphism sends 0 to 0.",
    "type": "f 0 = 0"
  },
  {
    "name": "roth_number_nat_add_le",
    "statement": "theorem roth_number_nat_add_le (M N : ℕ) : ⇑roth_number_nat (M + N) ≤ ⇑roth_number_nat M + ⇑roth_number_nat N",
    "theorem": "(M N : ℕ) : ⇑roth_number_nat (M + N) ≤ ⇑roth_number_nat M + ⇑roth_number_nat N",
    "args": "(M N : ℕ)",
    "doc_string": " The Roth number is a subadditive function. Note that by Fekete's lemma this shows that the limit `roth_number_nat N / N` exists, but Roth's theorem gives the stronger result that this limit is actually `0`.",
    "type": "⇑roth_number_nat (M + N) ≤ ⇑roth_number_nat M + ⇑roth_number_nat N"
  },
  {
    "name": "emetric.diam_mono",
    "statement": "theorem emetric.diam_mono {α : Type u} [pseudo_emetric_space α] {s t : set α} (h : s ⊆ t) : emetric.diam s ≤ emetric.diam t",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {s t : set α} (h : s ⊆ t) : emetric.diam s ≤ emetric.diam t",
    "args": "{α : Type u} [pseudo_emetric_space α] {s t : set α} (h : s ⊆ t)",
    "doc_string": "The diameter is monotonous with respect to inclusion",
    "type": "emetric.diam s ≤ emetric.diam t"
  },
  {
    "name": "algebra.is_algebraic_of_finite",
    "statement": "theorem algebra.is_algebraic_of_finite (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L] : algebra.is_algebraic K L",
    "theorem": "(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L] : algebra.is_algebraic K L",
    "args": "(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L]",
    "doc_string": "A field extension is algebraic if it is finite.",
    "type": "algebra.is_algebraic K L"
  },
  {
    "name": "free_group.reduce.exact",
    "statement": "theorem free_group.reduce.exact {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.reduce L₁ = free_group.reduce L₂) : free_group.mk L₁ = free_group.mk L₂",
    "theorem": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.reduce L₁ = free_group.reduce L₂) : free_group.mk L₁ = free_group.mk L₂",
    "args": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.reduce L₁ = free_group.reduce L₂)",
    "doc_string": " If two words have a common maximal reduction, then they correspond to the same element in the free group.",
    "type": "free_group.mk L₁ = free_group.mk L₂"
  },
  {
    "name": "has_strict_deriv_at_exp_zero",
    "statement": "theorem has_strict_deriv_at_exp_zero {𝕂 : Type u_1} [is_R_or_C 𝕂] : has_strict_deriv_at (exp 𝕂) 1 0",
    "theorem": "{𝕂 : Type u_1} [is_R_or_C 𝕂] : has_strict_deriv_at (exp 𝕂) 1 0",
    "args": "{𝕂 : Type u_1} [is_R_or_C 𝕂]",
    "doc_string": "The exponential map in `𝕂 = ℝ` or `𝕂 = ℂ` has strict derivative `1` at zero.",
    "type": "has_strict_deriv_at (exp 𝕂) 1 0"
  },
  {
    "name": "finite_dimensional.finrank_eq_dim",
    "statement": "theorem finite_dimensional.finrank_eq_dim (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : ↑(finite_dimensional.finrank K V) = module.rank K V",
    "theorem": "(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : ↑(finite_dimensional.finrank K V) = module.rank K V",
    "args": "(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V]",
    "doc_string": " In a finite-dimensional space, its dimension (seen as a cardinal) coincides with its `finrank`.",
    "type": "↑(finite_dimensional.finrank K V) = module.rank K V"
  },
  {
    "name": "add_pos",
    "statement": "theorem add_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "**Alias** of `left.add_pos`.",
    "type": "0 < a + b"
  },
  {
    "name": "setoid.comap_eq",
    "statement": "theorem setoid.comap_eq {α : Type u_1} {β : Type u_2} {f : α → β} {r : setoid β} : setoid.comap f r = setoid.ker (quotient.mk ∘ f)",
    "theorem": "{α : Type u_1} {β : Type u_2} {f : α → β} {r : setoid β} : setoid.comap f r = setoid.ker (quotient.mk ∘ f)",
    "args": "{α : Type u_1} {β : Type u_2} {f : α → β} {r : setoid β}",
    "doc_string": "Given a map `f : N → M` and an equivalence relation `r` on `β`, the equivalence relation    induced on `α` by `f` equals the kernel of `r`'s quotient map composed with `f`.",
    "type": "setoid.comap f r = setoid.ker (quotient.mk ∘ f)"
  },
  {
    "name": "metric.uniform_continuous_inf_nndist_pt",
    "statement": "theorem metric.uniform_continuous_inf_nndist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_nndist x s)",
    "theorem": "{α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_nndist x s)",
    "args": "{α : Type u} [pseudo_metric_space α] (s : set α)",
    "doc_string": "The minimal distance to a set (as `ℝ≥0`) is uniformly continuous in point",
    "type": "uniform_continuous (λ (x : α), metric.inf_nndist x s)"
  },
  {
    "name": "commute.is_of_fin_order_mul",
    "statement": "theorem commute.is_of_fin_order_mul {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)",
    "theorem": "{G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)",
    "args": "{G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y)",
    "doc_string": "Commuting elements of finite order are closed under multiplication.",
    "type": "is_of_fin_order (x * y)"
  },
  {
    "name": "mul_opposite.op_zpow",
    "statement": "theorem mul_opposite.op_zpow {M : Type u} [div_inv_monoid M] (x : M) (z : ℤ) : mul_opposite.op (x ^ z) = mul_opposite.op x ^ z",
    "theorem": "{M : Type u} [div_inv_monoid M] (x : M) (z : ℤ) : mul_opposite.op (x ^ z) = mul_opposite.op x ^ z",
    "args": "{M : Type u} [div_inv_monoid M] (x : M) (z : ℤ)",
    "doc_string": "Moving to the opposite group or group_with_zero commutes with taking powers.",
    "type": "mul_opposite.op (x ^ z) = mul_opposite.op x ^ z"
  },
  {
    "name": "is_min_on.dual",
    "statement": "theorem is_min_on.dual {α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_min_on f s a → is_max_on (⇑order_dual.to_dual ∘ f) s a",
    "theorem": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_min_on f s a → is_max_on (⇑order_dual.to_dual ∘ f) s a",
    "args": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α}",
    "doc_string": "**Alias** of the reverse direction of is_max_on_dual_iff`.",
    "type": "is_min_on f s a → is_max_on (⇑order_dual.to_dual ∘ f) s a"
  },
  {
    "name": "antisymm_of",
    "statement": "theorem antisymm_of {α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α} : r a b → r b a → a = b",
    "theorem": "{α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α} : r a b → r b a → a = b",
    "args": "{α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α}",
    "doc_string": " A version of `antisymm` with `r` explicit.  This lemma matches the lemmas from lean core in `init.algebra.classes`, but is missing there.",
    "type": "r a b → r b a → a = b"
  },
  {
    "name": "zmod.legendre_sym_mod",
    "statement": "theorem zmod.legendre_sym_mod (p : ℕ) [fact (nat.prime p)] (a : ℤ) : zmod.legendre_sym p a = zmod.legendre_sym p (a % ↑p)",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) : zmod.legendre_sym p a = zmod.legendre_sym p (a % ↑p)",
    "args": "(p : ℕ) [fact (nat.prime p)] (a : ℤ)",
    "doc_string": "The Legendre symbol depends only on `a` mod `p`.",
    "type": "zmod.legendre_sym p a = zmod.legendre_sym p (a % ↑p)"
  },
  {
    "name": "finite_dimensional.finrank_self",
    "statement": "theorem finite_dimensional.finrank_self (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1",
    "theorem": "(K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1",
    "args": "(K : Type u) [division_ring K]",
    "doc_string": "A division_ring is one-dimensional as a vector space over itself.",
    "type": "finite_dimensional.finrank K K = 1"
  },
  {
    "name": "one_add_mul_sub_le_pow",
    "statement": "theorem one_add_mul_sub_le_pow {R : Type u₁} [linear_ordered_ring R] {a : R} (H : -1 ≤ a) (n : ℕ) : 1 + ↑n * (a - 1) ≤ a ^ n",
    "theorem": "{R : Type u₁} [linear_ordered_ring R] {a : R} (H : -1 ≤ a) (n : ℕ) : 1 + ↑n * (a - 1) ≤ a ^ n",
    "args": "{R : Type u₁} [linear_ordered_ring R] {a : R} (H : -1 ≤ a) (n : ℕ)",
    "doc_string": "Bernoulli's inequality reformulated to estimate `a^n`.",
    "type": "1 + ↑n * (a - 1) ≤ a ^ n"
  },
  {
    "name": "is_add_hom.to_is_add_monoid_hom",
    "statement": "theorem is_add_hom.to_is_add_monoid_hom {α : Type u} {β : Type v} [add_zero_class α] [add_group β] {f : α → β} (hf : is_add_hom f) : is_add_monoid_hom f",
    "theorem": "{α : Type u} {β : Type v} [add_zero_class α] [add_group β] {f : α → β} (hf : is_add_hom f) : is_add_monoid_hom f",
    "args": "{α : Type u} {β : Type v} [add_zero_class α] [add_group β] {f : α → β} (hf : is_add_hom f)",
    "doc_string": "A map to an additive group preserving addition is an additive monoid homomorphism.",
    "type": "is_add_monoid_hom f"
  },
  {
    "name": "category_theory.classifier_is_sheaf",
    "statement": "theorem category_theory.classifier_is_sheaf {C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) : category_theory.presieve.is_sheaf J₁ (category_theory.functor.closed_sieves J₁)",
    "theorem": "{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) : category_theory.presieve.is_sheaf J₁ (category_theory.functor.closed_sieves J₁)",
    "args": "{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C)",
    "doc_string": "The presheaf of `J`-closed sieves is a `J`-sheaf. The proof of this is adapted from [MM92], Chatper III, Section 7, Lemma 1.",
    "type": "category_theory.presieve.is_sheaf J₁ (category_theory.functor.closed_sieves J₁)"
  },
  {
    "name": "nat.choose_le_succ_of_lt_half_left",
    "statement": "theorem nat.choose_le_succ_of_lt_half_left {r n : ℕ} (h : r < n / 2) : n.choose r ≤ n.choose (r + 1)",
    "theorem": "{r n : ℕ} (h : r < n / 2) : n.choose r ≤ n.choose (r + 1)",
    "args": "{r n : ℕ} (h : r < n / 2)",
    "doc_string": "Show that `nat.choose` is increasing for small values of the right argument.",
    "type": "n.choose r ≤ n.choose (r + 1)"
  },
  {
    "name": "add_lt_of_lt_sub_right",
    "statement": "theorem add_lt_of_lt_sub_right {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a < c - b → a + b < c",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a < c - b → a + b < c",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of lt_sub_iff_add_lt`.",
    "type": "a < c - b → a + b < c"
  },
  {
    "name": "le_cinfi",
    "statement": "theorem le_cinfi {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), c ≤ f x) : c ≤ infi f",
    "theorem": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), c ≤ f x) : c ≤ infi f",
    "args": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), c ≤ f x)",
    "doc_string": "The indexed minimum of a function is bounded below by a uniform lower bound",
    "type": "c ≤ infi f"
  },
  {
    "name": "free_monoid.star_one",
    "statement": "theorem free_monoid.star_one {α : Type u_1} : has_star.star 1 = 1",
    "theorem": "{α : Type u_1} : has_star.star 1 = 1",
    "args": "{α : Type u_1}",
    "doc_string": "Note that `star_one` is already a global simp lemma, but this one works with dsimp too",
    "type": "has_star.star 1 = 1"
  },
  {
    "name": "real.tendsto_exp_at_top",
    "statement": "theorem real.tendsto_exp_at_top  : filter.tendsto real.exp filter.at_top filter.at_top",
    "theorem": " : filter.tendsto real.exp filter.at_top filter.at_top",
    "args": "",
    "doc_string": "The real exponential function tends to `+∞` at `+∞`.",
    "type": "filter.tendsto real.exp filter.at_top filter.at_top"
  },
  {
    "name": "pullback_nonzero",
    "statement": "theorem pullback_nonzero {M₀ : Type u_1} {M₀' : Type u_3} [mul_zero_one_class M₀] [nontrivial M₀] [has_zero M₀'] [has_one M₀'] (f : M₀' → M₀) (zero : f 0 = 0) (one : f 1 = 1) : nontrivial M₀'",
    "theorem": "{M₀ : Type u_1} {M₀' : Type u_3} [mul_zero_one_class M₀] [nontrivial M₀] [has_zero M₀'] [has_one M₀'] (f : M₀' → M₀) (zero : f 0 = 0) (one : f 1 = 1) : nontrivial M₀'",
    "args": "{M₀ : Type u_1} {M₀' : Type u_3} [mul_zero_one_class M₀] [nontrivial M₀] [has_zero M₀'] [has_one M₀'] (f : M₀' → M₀) (zero : f 0 = 0) (one : f 1 = 1)",
    "doc_string": "Pullback a `nontrivial` instance along a function sending `0` to `0` and `1` to `1`.",
    "type": "nontrivial M₀'"
  },
  {
    "name": "is_closed_map_smul_of_ne_zero",
    "statement": "theorem is_closed_map_smul_of_ne_zero {α : Type u_2} {G₀ : Type u_4} [topological_space α] [group_with_zero G₀] [mul_action G₀ α] [has_continuous_const_smul G₀ α] {c : G₀} (hc : c ≠ 0) : is_closed_map (λ (x : α), c • x)",
    "theorem": "{α : Type u_2} {G₀ : Type u_4} [topological_space α] [group_with_zero G₀] [mul_action G₀ α] [has_continuous_const_smul G₀ α] {c : G₀} (hc : c ≠ 0) : is_closed_map (λ (x : α), c • x)",
    "args": "{α : Type u_2} {G₀ : Type u_4} [topological_space α] [group_with_zero G₀] [mul_action G₀ α] [has_continuous_const_smul G₀ α] {c : G₀} (hc : c ≠ 0)",
    "doc_string": " `smul` is a closed map in the second argument.  The lemma that `smul` is a closed map in the first argument (for a normed space over a complete normed field) is `is_closed_map_smul_left` in `analysis.normed_space.finite_dimension`.",
    "type": "is_closed_map (λ (x : α), c • x)"
  },
  {
    "name": "has_sbtw.sbtw.btw",
    "statement": "theorem has_sbtw.sbtw.btw {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_btw.btw a b c",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_btw.btw a b c",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c)",
    "doc_string": "**Alias** of btw_of_sbtw`.",
    "type": "has_btw.btw a b c"
  },
  {
    "name": "set.Ioi_subset_Ici",
    "statement": "theorem set.Ioi_subset_Ici {α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Ioi b ⊆ set.Ici a",
    "theorem": "{α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Ioi b ⊆ set.Ici a",
    "args": "{α : Type u_1} [preorder α] {a b : α} (h : a ≤ b)",
    "doc_string": " If `a ≤ b`, then `(b, +∞) ⊆ [a, +∞)`. In preorders, this is just an implication. If you need the equivalence in dense linear orders, use `Ioi_subset_Ici_iff`.",
    "type": "set.Ioi b ⊆ set.Ici a"
  },
  {
    "name": "finsum_mem_zero",
    "statement": "theorem finsum_mem_zero {α : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set α) : finsum (λ (i : α), finsum (λ (H : i ∈ s), 0)) = 0",
    "theorem": "{α : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set α) : finsum (λ (i : α), finsum (λ (H : i ∈ s), 0)) = 0",
    "args": "{α : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set α)",
    "doc_string": "The product of the constant function `0` over any set equals `0`.",
    "type": "finsum (λ (i : α), finsum (λ (H : i ∈ s), 0)) = 0"
  },
  {
    "name": "finite_field.trace_to_zmod_nondegenerate",
    "statement": "theorem finite_field.trace_to_zmod_nondegenerate (F : Type u_1) [field F] [fintype F] {a : F} (ha : a ≠ 0) : ∃ (b : F), ⇑(algebra.trace (zmod (ring_char F)) F) (a * b) ≠ 0",
    "theorem": "(F : Type u_1) [field F] [fintype F] {a : F} (ha : a ≠ 0) : ∃ (b : F), ⇑(algebra.trace (zmod (ring_char F)) F) (a * b) ≠ 0",
    "args": "(F : Type u_1) [field F] [fintype F] {a : F} (ha : a ≠ 0)",
    "doc_string": "The trace map from a finite field to its prime field is nongedenerate.",
    "type": "∃ (b : F), ⇑(algebra.trace (zmod (ring_char F)) F) (a * b) ≠ 0"
  },
  {
    "name": "image_range_order_of",
    "statement": "theorem image_range_order_of {G : Type u} {x : G} [fintype G] [group G] [decidable_eq G] : finset.image (λ (i : ℕ), x ^ i) (finset.range (order_of x)) = ↑(subgroup.zpowers x).to_finset",
    "theorem": "{G : Type u} {x : G} [fintype G] [group G] [decidable_eq G] : finset.image (λ (i : ℕ), x ^ i) (finset.range (order_of x)) = ↑(subgroup.zpowers x).to_finset",
    "args": "{G : Type u} {x : G} [fintype G] [group G] [decidable_eq G]",
    "doc_string": "TODO: Generalise to `submonoid.powers`.",
    "type": "finset.image (λ (i : ℕ), x ^ i) (finset.range (order_of x)) = ↑(subgroup.zpowers x).to_finset"
  },
  {
    "name": "is_sup_closed_compact.is_Sup_finite_compact",
    "statement": "theorem is_sup_closed_compact.is_Sup_finite_compact (α : Type u_1) [complete_lattice α] : complete_lattice.is_sup_closed_compact α → complete_lattice.is_Sup_finite_compact α",
    "theorem": "(α : Type u_1) [complete_lattice α] : complete_lattice.is_sup_closed_compact α → complete_lattice.is_Sup_finite_compact α",
    "args": "(α : Type u_1) [complete_lattice α]",
    "doc_string": "**Alias** of the reverse direction of complete_lattice.is_Sup_finite_compact_iff_is_sup_closed_compact`.",
    "type": "complete_lattice.is_sup_closed_compact α → complete_lattice.is_Sup_finite_compact α"
  },
  {
    "name": "free_group.reduce.min",
    "statement": "theorem free_group.reduce.min {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red (free_group.reduce L₁) L₂) : free_group.reduce L₁ = L₂",
    "theorem": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red (free_group.reduce L₁) L₂) : free_group.reduce L₁ = L₂",
    "args": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red (free_group.reduce L₁) L₂)",
    "doc_string": " The second theorem that characterises the function `reduce`: the maximal reduction of a word only reduces to itself.",
    "type": "free_group.reduce L₁ = L₂"
  },
  {
    "name": "quaternion_group.card",
    "statement": "theorem quaternion_group.card {n : ℕ} [fact (0 < n)] : fintype.card (quaternion_group n) = 4 * n",
    "theorem": "{n : ℕ} [fact (0 < n)] : fintype.card (quaternion_group n) = 4 * n",
    "args": "{n : ℕ} [fact (0 < n)]",
    "doc_string": "If `0 < n`, then `quaternion_group n` has `4n` elements.",
    "type": "fintype.card (quaternion_group n) = 4 * n"
  },
  {
    "name": "subset_affine_span",
    "statement": "theorem subset_affine_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ⊆ ↑(affine_span k s)",
    "theorem": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ⊆ ↑(affine_span k s)",
    "args": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P)",
    "doc_string": "A set is contained in its affine span.",
    "type": "s ⊆ ↑(affine_span k s)"
  },
  {
    "name": "emetric.inf_edist_le_edist_of_mem",
    "statement": "theorem emetric.inf_edist_le_edist_of_mem {α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} (h : y ∈ s) : emetric.inf_edist x s ≤ has_edist.edist x y",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} (h : y ∈ s) : emetric.inf_edist x s ≤ has_edist.edist x y",
    "args": "{α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} (h : y ∈ s)",
    "doc_string": "The edist to a set is bounded above by the edist to any of its points",
    "type": "emetric.inf_edist x s ≤ has_edist.edist x y"
  },
  {
    "name": "is_complemented_of_is_atomistic",
    "statement": "theorem is_complemented_of_is_atomistic {α : Type u_1} [complete_lattice α] [is_modular_lattice α] [is_compactly_generated α] [is_atomistic α] : is_complemented α",
    "theorem": "{α : Type u_1} [complete_lattice α] [is_modular_lattice α] [is_compactly_generated α] [is_atomistic α] : is_complemented α",
    "args": "{α : Type u_1} [complete_lattice α] [is_modular_lattice α] [is_compactly_generated α] [is_atomistic α]",
    "doc_string": "See Theorem 6.6, Călugăreanu",
    "type": "is_complemented α"
  },
  {
    "name": "category_theory.over.over_has_terminal",
    "statement": "theorem category_theory.over.over_has_terminal {C : Type u} [category_theory.category C] (B : C) : category_theory.limits.has_terminal (category_theory.over B)",
    "theorem": "{C : Type u} [category_theory.category C] (B : C) : category_theory.limits.has_terminal (category_theory.over B)",
    "args": "{C : Type u} [category_theory.category C] (B : C)",
    "doc_string": "Construct terminal object in the over category. This isn't an instance as it's not typically the way we want to define terminal objects. (For instance, this gives a terminal object which is different from the generic one given by `over_product_of_wide_pullback` above.)",
    "type": "category_theory.limits.has_terminal (category_theory.over B)"
  },
  {
    "name": "category_theory.subobject.nontrivial_of_not_is_zero",
    "statement": "theorem category_theory.subobject.nontrivial_of_not_is_zero {C : Type u₁} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (h : ¬category_theory.limits.is_zero X) : nontrivial (category_theory.subobject X)",
    "theorem": "{C : Type u₁} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (h : ¬category_theory.limits.is_zero X) : nontrivial (category_theory.subobject X)",
    "args": "{C : Type u₁} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (h : ¬category_theory.limits.is_zero X)",
    "doc_string": "A nonzero object has nontrivial subobject lattice.",
    "type": "nontrivial (category_theory.subobject X)"
  },
  {
    "name": "int.exists_greatest_of_bdd",
    "statement": "theorem int.exists_greatest_of_bdd {P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → z ≤ b) (Hinh : ∃ (z : ℤ), P z) : ∃ (ub : ℤ), P ub ∧ ∀ (z : ℤ), P z → z ≤ ub",
    "theorem": "{P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → z ≤ b) (Hinh : ∃ (z : ℤ), P z) : ∃ (ub : ℤ), P ub ∧ ∀ (z : ℤ), P z → z ≤ ub",
    "args": "{P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → z ≤ b) (Hinh : ∃ (z : ℤ), P z)",
    "doc_string": " If `P : ℤ → Prop` is a predicate such that the set `{m : P m}` is bounded above and nonempty, then this set has the greatest element. This lemma uses classical logic to avoid assumption `[decidable_pred P]`. See `int.greatest_of_bdd` for a constructive counterpart.",
    "type": "∃ (ub : ℤ), P ub ∧ ∀ (z : ℤ), P z → z ≤ ub"
  },
  {
    "name": "polynomial.cyclotomic_zero",
    "statement": "theorem polynomial.cyclotomic_zero (R : Type u_1) [ring R] : polynomial.cyclotomic 0 R = 1",
    "theorem": "(R : Type u_1) [ring R] : polynomial.cyclotomic 0 R = 1",
    "args": "(R : Type u_1) [ring R]",
    "doc_string": "The zeroth cyclotomic polyomial is `1`.",
    "type": "polynomial.cyclotomic 0 R = 1"
  },
  {
    "name": "div_eq_mul_inv",
    "statement": "theorem div_eq_mul_inv {G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * b⁻¹",
    "theorem": "{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * b⁻¹",
    "args": "{G : Type u_1} [div_inv_monoid G] (a b : G)",
    "doc_string": " Dividing by an element is the same as multiplying by its inverse.  This is a duplicate of `div_inv_monoid.div_eq_mul_inv` ensuring that the types unfold better.",
    "type": "a / b = a * b⁻¹"
  },
  {
    "name": "category_theory.limits.has_zero_object_of_has_terminal_object",
    "statement": "theorem category_theory.limits.has_zero_object_of_has_terminal_object {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C]",
    "doc_string": "If there are zero morphisms, any terminal object is a zero object.",
    "type": "category_theory.limits.has_zero_object C"
  },
  {
    "name": "tendsto_pow_neg_at_top",
    "statement": "theorem tendsto_pow_neg_at_top {α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] {n : ℕ} (hn : 1 ≤ n) : filter.tendsto (λ (x : α), x ^ -↑n) filter.at_top (nhds 0)",
    "theorem": "{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] {n : ℕ} (hn : 1 ≤ n) : filter.tendsto (λ (x : α), x ^ -↑n) filter.at_top (nhds 0)",
    "args": "{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] {n : ℕ} (hn : 1 ≤ n)",
    "doc_string": " The function `x^(-n)` tends to `0` at `+∞` for any positive natural `n`. A version for positive real powers exists as `tendsto_rpow_neg_at_top`.",
    "type": "filter.tendsto (λ (x : α), x ^ -↑n) filter.at_top (nhds 0)"
  },
  {
    "name": "finite_field.pow_dichotomy",
    "statement": "theorem finite_field.pow_dichotomy {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) {a : F} (ha : a ≠ 0) : a ^ (fintype.card F / 2) = 1 ∨ a ^ (fintype.card F / 2) = -1",
    "theorem": "{F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) {a : F} (ha : a ≠ 0) : a ^ (fintype.card F / 2) = 1 ∨ a ^ (fintype.card F / 2) = -1",
    "args": "{F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) {a : F} (ha : a ≠ 0)",
    "doc_string": "If `F` has odd characteristic, then for nonzero `a : F`, we have that `a ^ (#F / 2) = ±1`.",
    "type": "a ^ (fintype.card F / 2) = 1 ∨ a ^ (fintype.card F / 2) = -1"
  },
  {
    "name": "not_is_left_regular_zero",
    "statement": "theorem not_is_left_regular_zero {R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : ¬is_left_regular 0",
    "theorem": "{R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : ¬is_left_regular 0",
    "args": "{R : Type u_1} [mul_zero_class R] [nR : nontrivial R]",
    "doc_string": "In a non-trivial ring, the element `0` is not left-regular -- with typeclasses.",
    "type": "¬is_left_regular 0"
  },
  {
    "name": "equiv.mul_right_symm_apply",
    "statement": "theorem equiv.mul_right_symm_apply {G : Type u_10} [group G] (a : G) : ⇑(equiv.symm (equiv.mul_right a)) = λ (x : G), x * a⁻¹",
    "theorem": "{G : Type u_10} [group G] (a : G) : ⇑(equiv.symm (equiv.mul_right a)) = λ (x : G), x * a⁻¹",
    "args": "{G : Type u_10} [group G] (a : G)",
    "doc_string": "Extra simp lemma that `dsimp` can use. `simp` will never use this.",
    "type": "⇑(equiv.symm (equiv.mul_right a)) = λ (x : G), x * a⁻¹"
  },
  {
    "name": "fin.monotone_iff_le_succ",
    "statement": "theorem fin.monotone_iff_le_succ {n : ℕ} {α : Type u_1} [preorder α] {f : fin (n + 1) → α} : monotone f ↔ ∀ (i : fin n), f (⇑fin.cast_succ i) ≤ f i.succ",
    "theorem": "{n : ℕ} {α : Type u_1} [preorder α] {f : fin (n + 1) → α} : monotone f ↔ ∀ (i : fin n), f (⇑fin.cast_succ i) ≤ f i.succ",
    "args": "{n : ℕ} {α : Type u_1} [preorder α] {f : fin (n + 1) → α}",
    "doc_string": "A function `f` on `fin (n + 1)` is monotone if and only if `f i ≤ f (i + 1)` for all `i`.",
    "type": "monotone f ↔ ∀ (i : fin n), f (⇑fin.cast_succ i) ≤ f i.succ"
  },
  {
    "name": "complex.linear_equiv_det_conj_ae",
    "statement": "theorem complex.linear_equiv_det_conj_ae  : ⇑linear_equiv.det complex.conj_ae.to_linear_equiv = -1",
    "theorem": " : ⇑linear_equiv.det complex.conj_ae.to_linear_equiv = -1",
    "args": "",
    "doc_string": "The determinant of `conj_ae`, as a linear equiv.",
    "type": "⇑linear_equiv.det complex.conj_ae.to_linear_equiv = -1"
  },
  {
    "name": "padic_val_nat.pow",
    "statement": "theorem padic_val_nat.pow (p q n : ℕ) [fact (nat.prime p)] (hq : q ≠ 0) : padic_val_nat p (q ^ n) = n * padic_val_nat p q",
    "theorem": "(p q n : ℕ) [fact (nat.prime p)] (hq : q ≠ 0) : padic_val_nat p (q ^ n) = n * padic_val_nat p q",
    "args": "(p q n : ℕ) [fact (nat.prime p)] (hq : q ≠ 0)",
    "doc_string": "A version of `padic_val_rat.pow` for `padic_val_nat`",
    "type": "padic_val_nat p (q ^ n) = n * padic_val_nat p q"
  },
  {
    "name": "metric.Hausdorff_dist_comm",
    "statement": "theorem metric.Hausdorff_dist_comm {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.Hausdorff_dist s t = metric.Hausdorff_dist t s",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s t : set α} : metric.Hausdorff_dist s t = metric.Hausdorff_dist t s",
    "args": "{α : Type u} [pseudo_metric_space α] {s t : set α}",
    "doc_string": "The Hausdorff distance from `s` to `t` and from `t` to `s` coincide",
    "type": "metric.Hausdorff_dist s t = metric.Hausdorff_dist t s"
  },
  {
    "name": "zmod.ring_char_zmod_n",
    "statement": "theorem zmod.ring_char_zmod_n (n : ℕ) : ring_char (zmod n) = n",
    "theorem": "(n : ℕ) : ring_char (zmod n) = n",
    "args": "(n : ℕ)",
    "doc_string": "We have that `ring_char (zmod n) = n`.",
    "type": "ring_char (zmod n) = n"
  },
  {
    "name": "strict_anti_on.dual_right",
    "statement": "theorem strict_anti_on.dual_right {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : strict_anti_on f s → strict_mono_on (⇑order_dual.to_dual ∘ f) s",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : strict_anti_on f s → strict_mono_on (⇑order_dual.to_dual ∘ f) s",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α}",
    "doc_string": "**Alias** of the reverse direction of strict_mono_on_to_dual_comp_iff`.",
    "type": "strict_anti_on f s → strict_mono_on (⇑order_dual.to_dual ∘ f) s"
  },
  {
    "name": "algebra.norm_algebra_map",
    "statement": "theorem algebra.norm_algebra_map {K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] (x : K) : ⇑(algebra.norm K) (⇑(algebra_map K L) x) = x ^ finite_dimensional.finrank K L",
    "theorem": "{K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] (x : K) : ⇑(algebra.norm K) (⇑(algebra_map K L) x) = x ^ finite_dimensional.finrank K L",
    "args": "{K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] (x : K)",
    "doc_string": " If `x` is in the base field `K`, then the norm is `x ^ [L : K]`.  (If `L` is not finite-dimensional over `K`, then `norm = 1 = x ^ 0 = x ^ (finrank L K)`.)",
    "type": "⇑(algebra.norm K) (⇑(algebra_map K L) x) = x ^ finite_dimensional.finrank K L"
  },
  {
    "name": "fin.cast_eq_cast'",
    "statement": "theorem fin.cast_eq_cast' {n m : ℕ} (h : fin n = fin m) : cast h = ⇑(fin.cast _)",
    "theorem": "{n m : ℕ} (h : fin n = fin m) : cast h = ⇑(fin.cast _)",
    "args": "{n m : ℕ} (h : fin n = fin m)",
    "doc_string": "A reversed version of `fin.cast_eq_cast` that is easier to rewrite with.",
    "type": "cast h = ⇑(fin.cast _)"
  },
  {
    "name": "nat.div_lt_self'",
    "statement": "theorem nat.div_lt_self' (n b : ℕ) : (n + 1) / (b + 2) < n + 1",
    "theorem": "(n b : ℕ) : (n + 1) / (b + 2) < n + 1",
    "args": "(n b : ℕ)",
    "doc_string": "A version of `nat.div_lt_self` using successors, rather than additional hypotheses.",
    "type": "(n + 1) / (b + 2) < n + 1"
  },
  {
    "name": "antilipschitz_with.subsingleton",
    "statement": "theorem antilipschitz_with.subsingleton {α : Type u_1} {β : Type u_2} [emetric_space α] [pseudo_emetric_space β] {f : α → β} (h : antilipschitz_with 0 f) : subsingleton α",
    "theorem": "{α : Type u_1} {β : Type u_2} [emetric_space α] [pseudo_emetric_space β] {f : α → β} (h : antilipschitz_with 0 f) : subsingleton α",
    "args": "{α : Type u_1} {β : Type u_2} [emetric_space α] [pseudo_emetric_space β] {f : α → β} (h : antilipschitz_with 0 f)",
    "doc_string": "If `f : α → β` is `0`-antilipschitz, then `α` is a `subsingleton`.",
    "type": "subsingleton α"
  },
  {
    "name": "mul_is_right_regular_iff",
    "statement": "theorem mul_is_right_regular_iff {R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_right_regular a) : is_right_regular (b * a) ↔ is_right_regular b",
    "theorem": "{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_right_regular a) : is_right_regular (b * a) ↔ is_right_regular b",
    "args": "{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_right_regular a)",
    "doc_string": "  An element is right-regular if and only if multiplying it on the right with a right-regular element is right-regular.",
    "type": "is_right_regular (b * a) ↔ is_right_regular b"
  },
  {
    "name": "sup_sdiff_inj_on",
    "statement": "theorem sup_sdiff_inj_on {α : Type u_1} [generalized_boolean_algebra α] (u v : α) : set.inj_on (λ (x : α), (x ⊔ u)  v) {x : α | disjoint u x ∧ v ≤ x}",
    "theorem": "{α : Type u_1} [generalized_boolean_algebra α] (u v : α) : set.inj_on (λ (x : α), (x ⊔ u)  v) {x : α | disjoint u x ∧ v ≤ x}",
    "args": "{α : Type u_1} [generalized_boolean_algebra α] (u v : α)",
    "doc_string": "UV-compression is injective on the elements it moves. See `uv.compress`.",
    "type": "set.inj_on (λ (x : α), (x ⊔ u)  v) {x : α | disjoint u x ∧ v ≤ x}"
  },
  {
    "name": "order.pred_lt_of_not_is_min",
    "statement": "theorem order.pred_lt_of_not_is_min {α : Type u_1} [preorder α] [pred_order α] {a : α} : ¬is_min a → order.pred a < a",
    "theorem": "{α : Type u_1} [preorder α] [pred_order α] {a : α} : ¬is_min a → order.pred a < a",
    "args": "{α : Type u_1} [preorder α] [pred_order α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of order.pred_lt_iff_not_is_min`.",
    "type": "¬is_min a → order.pred a < a"
  },
  {
    "name": "emetric.inf_edist_zero_of_mem",
    "statement": "theorem emetric.inf_edist_zero_of_mem {α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} (h : x ∈ s) : emetric.inf_edist x s = 0",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} (h : x ∈ s) : emetric.inf_edist x s = 0",
    "args": "{α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} (h : x ∈ s)",
    "doc_string": "If a point `x` belongs to `s`, then its edist to `s` vanishes",
    "type": "emetric.inf_edist x s = 0"
  },
  {
    "name": "is_smul_regular.zero_iff_subsingleton",
    "statement": "theorem is_smul_regular.zero_iff_subsingleton {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : is_smul_regular M 0 ↔ subsingleton M",
    "theorem": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : is_smul_regular M 0 ↔ subsingleton M",
    "args": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M]",
    "doc_string": "The element `0` is `M`-regular if and only if `M` is trivial.",
    "type": "is_smul_regular M 0 ↔ subsingleton M"
  },
  {
    "name": "order_of_pos_iff",
    "statement": "theorem order_of_pos_iff {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x",
    "theorem": "{G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x",
    "args": "{G : Type u} {x : G} [monoid G]",
    "doc_string": "A group element has finite order iff its order is positive.",
    "type": "0 < order_of x ↔ is_of_fin_order x"
  },
  {
    "name": "zmod.legendre_sym_sq_one",
    "statement": "theorem zmod.legendre_sym_sq_one (p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p a ^ 2 = 1",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p a ^ 2 = 1",
    "args": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0)",
    "doc_string": "The square of the symbol is 1 if `p ∤ a`.",
    "type": "zmod.legendre_sym p a ^ 2 = 1"
  },
  {
    "name": "has_lt.lt.trans_le'",
    "statement": "theorem has_lt.lt.trans_le' {α : Type u} [preorder α] {a b c : α} : b < c → a ≤ b → a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : b < c → a ≤ b → a < c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of lt_of_lt_of_le'`.",
    "type": "b < c → a ≤ b → a < c"
  },
  {
    "name": "is_left_regular.subsingleton",
    "statement": "theorem is_left_regular.subsingleton {R : Type u_1} [mul_zero_class R] (h : is_left_regular 0) : subsingleton R",
    "theorem": "{R : Type u_1} [mul_zero_class R] (h : is_left_regular 0) : subsingleton R",
    "args": "{R : Type u_1} [mul_zero_class R] (h : is_left_regular 0)",
    "doc_string": "The element `0` is left-regular if and only if `R` is trivial.",
    "type": "subsingleton R"
  },
  {
    "name": "monoid_algebra.finite_type_iff_group_fg",
    "statement": "theorem monoid_algebra.finite_type_iff_group_fg {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ↔ group.fg G",
    "theorem": "{R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ↔ group.fg G",
    "args": "{R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R]",
    "doc_string": "A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type.",
    "type": "algebra.finite_type R (monoid_algebra R G) ↔ group.fg G"
  },
  {
    "name": "tsub_eq_zero_of_le",
    "statement": "theorem tsub_eq_zero_of_le {α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} (h : a ≤ b) : a - b = 0",
    "theorem": "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} (h : a ≤ b) : a - b = 0",
    "args": "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} (h : a ≤ b)",
    "doc_string": "One direction of `tsub_eq_zero_iff_le`, as a `@[simp]`-lemma.",
    "type": "a - b = 0"
  },
  {
    "name": "monoid.not_is_torsion_iff",
    "statement": "theorem monoid.not_is_torsion_iff (G : Type u_1) [monoid G] : ¬monoid.is_torsion G ↔ ∃ (g : G), ¬is_of_fin_order g",
    "theorem": "(G : Type u_1) [monoid G] : ¬monoid.is_torsion G ↔ ∃ (g : G), ¬is_of_fin_order g",
    "args": "(G : Type u_1) [monoid G]",
    "doc_string": "A monoid is not a torsion monoid if it has an element of infinite order.",
    "type": "¬monoid.is_torsion G ↔ ∃ (g : G), ¬is_of_fin_order g"
  },
  {
    "name": "category_theory.has_finite_coproducts_of_has_binary_and_terminal",
    "statement": "theorem category_theory.has_finite_coproducts_of_has_binary_and_terminal {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] : category_theory.limits.has_finite_coproducts C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] : category_theory.limits.has_finite_coproducts C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C]",
    "doc_string": "If `C` has an initial object and binary coproducts, then it has finite coproducts.",
    "type": "category_theory.limits.has_finite_coproducts C"
  },
  {
    "name": "has_le.le.lt_of_ne'",
    "statement": "theorem has_le.le.lt_of_ne' {α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≠ a → a < b",
    "theorem": "{α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≠ a → a < b",
    "args": "{α : Type u} [partial_order α] {a b : α}",
    "doc_string": "**Alias** of lt_of_le_of_ne'`.",
    "type": "a ≤ b → b ≠ a → a < b"
  },
  {
    "name": "fin.coe_coe_of_lt",
    "statement": "theorem fin.coe_coe_of_lt {n a : ℕ} (h : a < n + 1) : ↑↑a = a",
    "theorem": "{n a : ℕ} (h : a < n + 1) : ↑↑a = a",
    "args": "{n a : ℕ} (h : a < n + 1)",
    "doc_string": " Coercing an in-range number to `fin (n + 1)`, and converting back to `ℕ`, results in that number.",
    "type": "↑↑a = a"
  },
  {
    "name": "ereal.le_neg_of_le_neg",
    "statement": "theorem ereal.le_neg_of_le_neg {a b : ereal} (h : a ≤ -b) : b ≤ -a",
    "theorem": "{a b : ereal} (h : a ≤ -b) : b ≤ -a",
    "args": "{a b : ereal} (h : a ≤ -b)",
    "doc_string": "`a ≤ -b → b ≤ -a` on ereal",
    "type": "b ≤ -a"
  },
  {
    "name": "exists_mem_Ico_zpow",
    "statement": "theorem exists_mem_Ico_zpow {α : Type u_1} [linear_ordered_field α] [archimedean α] {x y : α} (hx : 0 < x) (hy : 1 < y) : ∃ (n : ℤ), x ∈ set.Ico (y ^ n) (y ^ (n + 1))",
    "theorem": "{α : Type u_1} [linear_ordered_field α] [archimedean α] {x y : α} (hx : 0 < x) (hy : 1 < y) : ∃ (n : ℤ), x ∈ set.Ico (y ^ n) (y ^ (n + 1))",
    "args": "{α : Type u_1} [linear_ordered_field α] [archimedean α] {x y : α} (hx : 0 < x) (hy : 1 < y)",
    "doc_string": " Every positive `x` is between two successive integer powers of another `y` greater than one. This is the same as `exists_mem_Ioc_zpow`, but with ≤ and < the other way around.",
    "type": "∃ (n : ℤ), x ∈ set.Ico (y ^ n) (y ^ (n + 1))"
  },
  {
    "name": "order.le_of_pred_le_pred",
    "statement": "theorem order.le_of_pred_le_pred {α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : order.pred a ≤ order.pred b → a ≤ b",
    "theorem": "{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : order.pred a ≤ order.pred b → a ≤ b",
    "args": "{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α]",
    "doc_string": "**Alias** of the forward direction of order.pred_le_pred_iff`.",
    "type": "order.pred a ≤ order.pred b → a ≤ b"
  },
  {
    "name": "category_theory.grothendieck_topology.le_close",
    "statement": "theorem category_theory.grothendieck_topology.le_close {C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : S ≤ J₁.close S",
    "theorem": "{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : S ≤ J₁.close S",
    "args": "{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X)",
    "doc_string": "Any sieve is smaller than its closure.",
    "type": "S ≤ J₁.close S"
  },
  {
    "name": "topological_semiring.to_topological_ring",
    "statement": "theorem topological_semiring.to_topological_ring {α : Type u_1} [topological_space α] [non_assoc_ring α] (h : topological_semiring α) : topological_ring α",
    "theorem": "{α : Type u_1} [topological_space α] [non_assoc_ring α] (h : topological_semiring α) : topological_ring α",
    "args": "{α : Type u_1} [topological_space α] [non_assoc_ring α] (h : topological_semiring α)",
    "doc_string": " If `R` is a ring which is a topological semiring, then it is automatically a topological ring. This exists so that one can place a topological ring structure on `R` without explicitly proving `continuous_neg`.",
    "type": "topological_ring α"
  },
  {
    "name": "has_le.le.eq_or_lt",
    "statement": "theorem has_le.le.eq_or_lt {α : Type u} [partial_order α] {a b : α} (h : a ≤ b) : a = b ∨ a < b",
    "theorem": "{α : Type u} [partial_order α] {a b : α} (h : a ≤ b) : a = b ∨ a < b",
    "args": "{α : Type u} [partial_order α] {a b : α} (h : a ≤ b)",
    "doc_string": "**Alias** of eq_or_lt_of_le`.",
    "type": "a = b ∨ a < b"
  },
  {
    "name": "measure_theory.jordan_decomposition.to_signed_measure_injective",
    "statement": "theorem measure_theory.jordan_decomposition.to_signed_measure_injective {α : Type u_1} [measurable_space α] : function.injective measure_theory.jordan_decomposition.to_signed_measure",
    "theorem": "{α : Type u_1} [measurable_space α] : function.injective measure_theory.jordan_decomposition.to_signed_measure",
    "args": "{α : Type u_1} [measurable_space α]",
    "doc_string": "The Jordan decomposition of a signed measure is unique.",
    "type": "function.injective measure_theory.jordan_decomposition.to_signed_measure"
  },
  {
    "name": "is_add_submonoid.multiples_subset",
    "statement": "theorem is_add_submonoid.multiples_subset {M : Type u_1} [add_monoid M] {s : set M} {a : M} (hs : is_add_submonoid s) (h : a ∈ s) : multiples a ⊆ s",
    "theorem": "{M : Type u_1} [add_monoid M] {s : set M} {a : M} (hs : is_add_submonoid s) (h : a ∈ s) : multiples a ⊆ s",
    "args": "{M : Type u_1} [add_monoid M] {s : set M} {a : M} (hs : is_add_submonoid s) (h : a ∈ s)",
    "doc_string": "The set of natural number multiples of an element of an `add_submonoid` is a subset of the `add_submonoid`.",
    "type": "multiples a ⊆ s"
  },
  {
    "name": "has_lt.lt.trans_eq",
    "statement": "theorem has_lt.lt.trans_eq {α : Type u} [preorder α] {a b c : α} (hab : a < b) (hbc : b = c) : a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} (hab : a < b) (hbc : b = c) : a < c",
    "args": "{α : Type u} [preorder α] {a b c : α} (hab : a < b) (hbc : b = c)",
    "doc_string": "**Alias** of lt_of_lt_of_eq`.",
    "type": "a < c"
  },
  {
    "name": "cinfi_le",
    "statement": "theorem cinfi_le {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_below (set.range f)) (c : ι) : infi f ≤ f c",
    "theorem": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_below (set.range f)) (c : ι) : infi f ≤ f c",
    "args": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_below (set.range f)) (c : ι)",
    "doc_string": "The indexed infimum of a function is bounded above by the value taken at one point",
    "type": "infi f ≤ f c"
  },
  {
    "name": "fin.find_min",
    "statement": "theorem fin.find_min {n : ℕ} {p : fin n → Prop} [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p) {j : fin n} (hj : j < i) : ¬p j",
    "theorem": "{n : ℕ} {p : fin n → Prop} [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p) {j : fin n} (hj : j < i) : ¬p j",
    "args": "{n : ℕ} {p : fin n → Prop} [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p) {j : fin n} (hj : j < i)",
    "doc_string": " If `find p` returns `some i`, then `p j` does not hold for `j < i`, i.e., `i` is minimal among the indices where `p` holds.",
    "type": "¬p j"
  },
  {
    "name": "le_sub_right_of_add_le",
    "statement": "theorem le_sub_right_of_add_le {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α} : a + b ≤ c → a ≤ c - b",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α} : a + b ≤ c → a ≤ c - b",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of le_sub_iff_add_le`.",
    "type": "a + b ≤ c → a ≤ c - b"
  },
  {
    "name": "right.mul_lt_one",
    "statement": "theorem right.mul_lt_one {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.mul_lt_one`.",
    "type": "a * b < 1"
  },
  {
    "name": "euclidean_domain.gcd_eq_gcd_ab",
    "statement": "theorem euclidean_domain.gcd_eq_gcd_ab {R : Type u} [euclidean_domain R] [decidable_eq R] (a b : R) : euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b",
    "theorem": "{R : Type u} [euclidean_domain R] [decidable_eq R] (a b : R) : euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b",
    "args": "{R : Type u} [euclidean_domain R] [decidable_eq R] (a b : R)",
    "doc_string": "An explicit version of **Bézout's lemma** for Euclidean domains.",
    "type": "euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b"
  },
  {
    "name": "is_mul_hom.id",
    "statement": "theorem is_mul_hom.id {α : Type u} [has_mul α] : is_mul_hom id",
    "theorem": "{α : Type u} [has_mul α] : is_mul_hom id",
    "args": "{α : Type u} [has_mul α]",
    "doc_string": "The identity map preserves multiplication.",
    "type": "is_mul_hom id"
  },
  {
    "name": "is_semiring_hom.id",
    "statement": "theorem is_semiring_hom.id {α : Type u} [semiring α] : is_semiring_hom id",
    "theorem": "{α : Type u} [semiring α] : is_semiring_hom id",
    "args": "{α : Type u} [semiring α]",
    "doc_string": "The identity map is a semiring homomorphism.",
    "type": "is_semiring_hom id"
  },
  {
    "name": "minpoly.ne_one",
    "statement": "theorem minpoly.ne_one (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : minpoly A x ≠ 1",
    "theorem": "(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : minpoly A x ≠ 1",
    "args": "(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B]",
    "doc_string": "A minimal polynomial is not `1`.",
    "type": "minpoly A x ≠ 1"
  },
  {
    "name": "function.surjective.dense_range",
    "statement": "theorem function.surjective.dense_range {β : Type u_2} [topological_space β] {κ : Type u_5} {f : κ → β} (hf : function.surjective f) : dense_range f",
    "theorem": "{β : Type u_2} [topological_space β] {κ : Type u_5} {f : κ → β} (hf : function.surjective f) : dense_range f",
    "args": "{β : Type u_2} [topological_space β] {κ : Type u_5} {f : κ → β} (hf : function.surjective f)",
    "doc_string": "A surjective map has dense range.",
    "type": "dense_range f"
  },
  {
    "name": "basis.card_le_card_of_linear_independent_aux",
    "statement": "theorem basis.card_le_card_of_linear_independent_aux {R : Type u_1} [ring R] [strong_rank_condition R] (n : ℕ) {m : ℕ} (v : fin m → fin n → R) : linear_independent R v → m ≤ n",
    "theorem": "{R : Type u_1} [ring R] [strong_rank_condition R] (n : ℕ) {m : ℕ} (v : fin m → fin n → R) : linear_independent R v → m ≤ n",
    "args": "{R : Type u_1} [ring R] [strong_rank_condition R] (n : ℕ) {m : ℕ} (v : fin m → fin n → R)",
    "doc_string": "In an `n`-dimensional space, the rank is at most `m`.",
    "type": "linear_independent R v → m ≤ n"
  },
  {
    "name": "tendsto_sum_nat_add",
    "statement": "theorem tendsto_sum_nat_add {α : Type u_1} [add_comm_group α] [topological_space α] [topological_add_group α] [t2_space α] (f : ℕ → α) : filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)",
    "theorem": "{α : Type u_1} [add_comm_group α] [topological_space α] [topological_add_group α] [t2_space α] (f : ℕ → α) : filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)",
    "args": "{α : Type u_1} [add_comm_group α] [topological_space α] [topological_add_group α] [t2_space α] (f : ℕ → α)",
    "doc_string": " For `f : ℕ → α`, then `∑' k, f (k + i)` tends to zero. This does not require a summability assumption on `f`, as otherwise all sums are zero.",
    "type": "filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)"
  },
  {
    "name": "add_nonneg",
    "statement": "theorem add_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b)",
    "doc_string": "**Alias** of `left.add_nonneg`.",
    "type": "0 ≤ a + b"
  },
  {
    "name": "colex.singleton_lt_iff_lt",
    "statement": "theorem colex.singleton_lt_iff_lt {α : Type u_1} [linear_order α] {r s : α} : {r}.to_colex < {s}.to_colex ↔ r < s",
    "theorem": "{α : Type u_1} [linear_order α] {r s : α} : {r}.to_colex < {s}.to_colex ↔ r < s",
    "args": "{α : Type u_1} [linear_order α] {r s : α}",
    "doc_string": "Colex is an extension of the base ordering on α.",
    "type": "{r}.to_colex < {s}.to_colex ↔ r < s"
  },
  {
    "name": "is_compact.inter_left",
    "statement": "theorem is_compact.inter_left {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t)",
    "theorem": "{α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t)",
    "args": "{α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s)",
    "doc_string": "The intersection of a closed set and a compact set is a compact set.",
    "type": "is_compact (s ∩ t)"
  },
  {
    "name": "dihedral_group.card",
    "statement": "theorem dihedral_group.card {n : ℕ} [fact (0 < n)] : fintype.card (dihedral_group n) = 2 * n",
    "theorem": "{n : ℕ} [fact (0 < n)] : fintype.card (dihedral_group n) = 2 * n",
    "args": "{n : ℕ} [fact (0 < n)]",
    "doc_string": "If `0 < n`, then `dihedral_group n` has `2n` elements.",
    "type": "fintype.card (dihedral_group n) = 2 * n"
  },
  {
    "name": "exists_compact_superset",
    "statement": "theorem exists_compact_superset {α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K'",
    "theorem": "{α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K'",
    "args": "{α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K)",
    "doc_string": "In a locally compact space, every compact set is contained in the interior of a compact set.",
    "type": "∃ (K' : set α), is_compact K' ∧ K ⊆ interior K'"
  },
  {
    "name": "mul_nonneg_of_three",
    "statement": "theorem mul_nonneg_of_three {α : Type u} [linear_ordered_ring α] (a b c : α) : 0 ≤ a * b ∨ 0 ≤ b * c ∨ 0 ≤ c * a",
    "theorem": "{α : Type u} [linear_ordered_ring α] (a b c : α) : 0 ≤ a * b ∨ 0 ≤ b * c ∨ 0 ≤ c * a",
    "args": "{α : Type u} [linear_ordered_ring α] (a b c : α)",
    "doc_string": "Out of three elements of a `linear_ordered_ring`, two must have the same sign.",
    "type": "0 ≤ a * b ∨ 0 ≤ b * c ∨ 0 ≤ c * a"
  },
  {
    "name": "bdd_above.union",
    "statement": "theorem bdd_above.union {γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above s → bdd_above t → bdd_above (s ∪ t)",
    "theorem": "{γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above s → bdd_above t → bdd_above (s ∪ t)",
    "args": "{γ : Type w} [semilattice_sup γ] {s t : set γ}",
    "doc_string": "If `s` and `t` are bounded above sets in a `semilattice_sup`, then so is `s ∪ t`.",
    "type": "bdd_above s → bdd_above t → bdd_above (s ∪ t)"
  },
  {
    "name": "bdd_below_union",
    "statement": "theorem bdd_below_union {γ : Type w} [semilattice_inf γ] {s t : set γ} : bdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t",
    "theorem": "{γ : Type w} [semilattice_inf γ] {s t : set γ} : bdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t",
    "args": "{γ : Type w} [semilattice_inf γ] {s t : set γ}",
    "doc_string": "The union of two sets is bounded above if and only if each of the sets is.",
    "type": "bdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t"
  },
  {
    "name": "module.free.finrank_pi",
    "statement": "theorem module.free.finrank_pi (R : Type u) [ring R] [strong_rank_condition R] {ι : Type v} [fintype ι] : finite_dimensional.finrank R (ι → R) = fintype.card ι",
    "theorem": "(R : Type u) [ring R] [strong_rank_condition R] {ι : Type v} [fintype ι] : finite_dimensional.finrank R (ι → R) = fintype.card ι",
    "args": "(R : Type u) [ring R] [strong_rank_condition R] {ι : Type v} [fintype ι]",
    "doc_string": "The finrank of `(ι → R)` is `fintype.card ι`.",
    "type": "finite_dimensional.finrank R (ι → R) = fintype.card ι"
  },
  {
    "name": "category_theory.limits.limits_from_equalizers_and_products",
    "statement": "theorem category_theory.limits.limits_from_equalizers_and_products {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limits C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limits C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C]",
    "doc_string": "Any category with products and equalizers has all limits.  See <https://stacks.math.columbia.edu/tag/002N>.",
    "type": "category_theory.limits.has_limits C"
  },
  {
    "name": "subtype.forall'",
    "statement": "theorem subtype.forall' {α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop} : (∀ (x : α) (h : p x), q x h) ↔ ∀ (x : {a // p a}), q ↑x _",
    "theorem": "{α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop} : (∀ (x : α) (h : p x), q x h) ↔ ∀ (x : {a // p a}), q ↑x _",
    "args": "{α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop}",
    "doc_string": "An alternative version of `subtype.forall`. This one is useful if Lean cannot figure out `q`  when using `subtype.forall` from right to left.",
    "type": "(∀ (x : α) (h : p x), q x h) ↔ ∀ (x : {a // p a}), q ↑x _"
  },
  {
    "name": "is_of_fin_order_one",
    "statement": "theorem is_of_fin_order_one {G : Type u} [monoid G] : is_of_fin_order 1",
    "theorem": "{G : Type u} [monoid G] : is_of_fin_order 1",
    "args": "{G : Type u} [monoid G]",
    "doc_string": "1 is of finite order in any monoid.",
    "type": "is_of_fin_order 1"
  },
  {
    "name": "matrix.inv_eq_left_inv",
    "statement": "theorem matrix.inv_eq_left_inv {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : B.mul A = 1) : A⁻¹ = B",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : B.mul A = 1) : A⁻¹ = B",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : B.mul A = 1)",
    "doc_string": "If matrix A is left invertible, then its inverse equals its left inverse.",
    "type": "A⁻¹ = B"
  },
  {
    "name": "zero_mul_eq_const",
    "statement": "theorem zero_mul_eq_const {M₀ : Type u_1} [mul_zero_class M₀] : has_mul.mul 0 = function.const M₀ 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_class M₀] : has_mul.mul 0 = function.const M₀ 0",
    "args": "{M₀ : Type u_1} [mul_zero_class M₀]",
    "doc_string": "To match `one_mul_eq_id`.",
    "type": "has_mul.mul 0 = function.const M₀ 0"
  },
  {
    "name": "one_pos",
    "statement": "theorem one_pos {α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 1",
    "theorem": "{α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 1",
    "args": "{α : Type u} [ordered_semiring α] [nontrivial α]",
    "doc_string": "**Alias** of zero_lt_one`.",
    "type": "0 < 1"
  },
  {
    "name": "disjointed_unique",
    "statement": "theorem disjointed_unique {α : Type u_1} [generalized_boolean_algebra α] {f d : ℕ → α} (hdisj : pairwise (disjoint on d)) (hsups : partial_sups d = partial_sups f) : d = disjointed f",
    "theorem": "{α : Type u_1} [generalized_boolean_algebra α] {f d : ℕ → α} (hdisj : pairwise (disjoint on d)) (hsups : partial_sups d = partial_sups f) : d = disjointed f",
    "args": "{α : Type u_1} [generalized_boolean_algebra α] {f d : ℕ → α} (hdisj : pairwise (disjoint on d)) (hsups : partial_sups d = partial_sups f)",
    "doc_string": " `disjointed f` is the unique sequence that is pairwise disjoint and has the same partial sups as `f`.",
    "type": "d = disjointed f"
  },
  {
    "name": "zero_hom.congr_arg",
    "statement": "theorem zero_hom.congr_arg {M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] (f : zero_hom M N) {x y : M} (h : x = y) : ⇑f x = ⇑f y",
    "theorem": "{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] (f : zero_hom M N) {x y : M} (h : x = y) : ⇑f x = ⇑f y",
    "args": "{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] (f : zero_hom M N) {x y : M} (h : x = y)",
    "doc_string": "Deprecated: use `fun_like.congr_arg` instead.",
    "type": "⇑f x = ⇑f y"
  },
  {
    "name": "one_le_inv'",
    "statement": "theorem one_le_inv' {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α}",
    "doc_string": "**Alias** of left.one_le_inv_iff`.",
    "type": "1 ≤ a⁻¹ ↔ a ≤ 1"
  },
  {
    "name": "neg_lt_zero",
    "statement": "theorem neg_lt_zero {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 ↔ 0 < a",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 ↔ 0 < a",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α}",
    "doc_string": "**Alias** of left.inv_lt_one_iff`.",
    "type": "-a < 0 ↔ 0 < a"
  },
  {
    "name": "continuous_map.continuous_eval_const",
    "statement": "theorem continuous_map.continuous_eval_const {α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] (x : α) : continuous (λ (f : C(α, β)), ⇑f x)",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] (x : α) : continuous (λ (f : C(α, β)), ⇑f x)",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] (x : α)",
    "doc_string": "See also `continuous_map.continuous_eval_const`",
    "type": "continuous (λ (f : C(α, β)), ⇑f x)"
  },
  {
    "name": "is_left_regular_of_non_zero_divisor",
    "statement": "theorem is_left_regular_of_non_zero_divisor {α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), k * x = 0 → x = 0) : is_left_regular k",
    "theorem": "{α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), k * x = 0 → x = 0) : is_left_regular k",
    "args": "{α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), k * x = 0 → x = 0)",
    "doc_string": " Left `mul` by a `k : α` over `[ring α]` is injective, if `k` is not a zero divisor. The typeclass that restricts all terms of `α` to have this property is `no_zero_divisors`.",
    "type": "is_left_regular k"
  },
  {
    "name": "mul_action.to_perm_injective",
    "statement": "theorem mul_action.to_perm_injective {α : Type u} {β : Type v} [group α] [mul_action α β] [has_faithful_smul α β] : function.injective mul_action.to_perm",
    "theorem": "{α : Type u} {β : Type v} [group α] [mul_action α β] [has_faithful_smul α β] : function.injective mul_action.to_perm",
    "args": "{α : Type u} {β : Type v} [group α] [mul_action α β] [has_faithful_smul α β]",
    "doc_string": "`mul_action.to_perm` is injective on faithful actions.",
    "type": "function.injective mul_action.to_perm"
  },
  {
    "name": "filter.tendsto.le_comap",
    "statement": "theorem filter.tendsto.le_comap {α : Type u} {β : Type v} {f : α → β} {l₁ : filter α} {l₂ : filter β} : filter.tendsto f l₁ l₂ → l₁ ≤ filter.comap f l₂",
    "theorem": "{α : Type u} {β : Type v} {f : α → β} {l₁ : filter α} {l₂ : filter β} : filter.tendsto f l₁ l₂ → l₁ ≤ filter.comap f l₂",
    "args": "{α : Type u} {β : Type v} {f : α → β} {l₁ : filter α} {l₂ : filter β}",
    "doc_string": "**Alias** of the forward direction of filter.tendsto_iff_comap`.",
    "type": "filter.tendsto f l₁ l₂ → l₁ ≤ filter.comap f l₂"
  },
  {
    "name": "inv_mul_lt_of_lt_mul",
    "statement": "theorem inv_mul_lt_of_lt_mul {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : a < b * c → b⁻¹ * a < c",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : a < b * c → b⁻¹ * a < c",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of inv_mul_lt_iff_lt_mul`.",
    "type": "a < b * c → b⁻¹ * a < c"
  },
  {
    "name": "finite_dimensional.finrank_fintype_fun_eq_card",
    "statement": "theorem finite_dimensional.finrank_fintype_fun_eq_card (K : Type u) [division_ring K] {ι : Type v} [fintype ι] : finite_dimensional.finrank K (ι → K) = fintype.card ι",
    "theorem": "(K : Type u) [division_ring K] {ι : Type v} [fintype ι] : finite_dimensional.finrank K (ι → K) = fintype.card ι",
    "args": "(K : Type u) [division_ring K] {ι : Type v} [fintype ι]",
    "doc_string": "The vector space of functions on a fintype ι has finrank equal to the cardinality of ι.",
    "type": "finite_dimensional.finrank K (ι → K) = fintype.card ι"
  },
  {
    "name": "emetric.inf_edist_le_inf_edist_add_Hausdorff_edist",
    "statement": "theorem emetric.inf_edist_le_inf_edist_add_Hausdorff_edist {α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} : emetric.inf_edist x t ≤ emetric.inf_edist x s + emetric.Hausdorff_edist s t",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} : emetric.inf_edist x t ≤ emetric.inf_edist x s + emetric.Hausdorff_edist s t",
    "args": "{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α}",
    "doc_string": " The distance from `x` to `s` or `t` is controlled in terms of the Hausdorff distance between `s` and `t`",
    "type": "emetric.inf_edist x t ≤ emetric.inf_edist x s + emetric.Hausdorff_edist s t"
  },
  {
    "name": "witt_vector.frobenius_verschiebung",
    "statement": "theorem witt_vector.frobenius_verschiebung {p : ℕ} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x : witt_vector p R) : ⇑witt_vector.frobenius (⇑witt_vector.verschiebung x) = x * ↑p",
    "theorem": "{p : ℕ} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x : witt_vector p R) : ⇑witt_vector.frobenius (⇑witt_vector.verschiebung x) = x * ↑p",
    "args": "{p : ℕ} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x : witt_vector p R)",
    "doc_string": "The composition of Frobenius and Verschiebung is multiplication by `p`.",
    "type": "⇑witt_vector.frobenius (⇑witt_vector.verschiebung x) = x * ↑p"
  },
  {
    "name": "generalized_continued_fraction.int_fract_pair.nth_stream_fr_nonneg",
    "statement": "theorem generalized_continued_fraction.int_fract_pair.nth_stream_fr_nonneg {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 ≤ ifp_n.fr",
    "theorem": "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 ≤ ifp_n.fr",
    "args": "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n)",
    "doc_string": "Shows that the fractional parts of the stream are nonnegative.",
    "type": "0 ≤ ifp_n.fr"
  },
  {
    "name": "is_regular_of_ne_zero",
    "statement": "theorem is_regular_of_ne_zero {R : Type u_1} {a : R} [cancel_monoid_with_zero R] (a0 : a ≠ 0) : is_regular a",
    "theorem": "{R : Type u_1} {a : R} [cancel_monoid_with_zero R] (a0 : a ≠ 0) : is_regular a",
    "args": "{R : Type u_1} {a : R} [cancel_monoid_with_zero R] (a0 : a ≠ 0)",
    "doc_string": "Non-zero elements of an integral domain are regular.",
    "type": "is_regular a"
  },
  {
    "name": "nat.dvd_right_iff_eq",
    "statement": "theorem nat.dvd_right_iff_eq {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n",
    "theorem": "{m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n",
    "args": "{m n : ℕ}",
    "doc_string": "Two natural numbers are equal if and only if the have the same multiples.",
    "type": "(∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n"
  },
  {
    "name": "is_group_hom.id",
    "statement": "theorem is_group_hom.id {α : Type u} [group α] : is_group_hom id",
    "theorem": "{α : Type u} [group α] : is_group_hom id",
    "args": "{α : Type u} [group α]",
    "doc_string": "The identity is a group homomorphism.",
    "type": "is_group_hom id"
  },
  {
    "name": "function.injective.pairwise_ne",
    "statement": "theorem function.injective.pairwise_ne {α : Type u_1} {ι : Type u_2} {f : ι → α} : function.injective f → pairwise (ne on f)",
    "theorem": "{α : Type u_1} {ι : Type u_2} {f : ι → α} : function.injective f → pairwise (ne on f)",
    "args": "{α : Type u_1} {ι : Type u_2} {f : ι → α}",
    "doc_string": "**Alias** of the forward direction of function.injective_iff_pairwise_ne`.",
    "type": "function.injective f → pairwise (ne on f)"
  },
  {
    "name": "neg_dvd",
    "statement": "theorem neg_dvd {α : Type u} [semigroup α] [has_distrib_neg α] (a b : α) : -a ∣ b ↔ a ∣ b",
    "theorem": "{α : Type u} [semigroup α] [has_distrib_neg α] (a b : α) : -a ∣ b ↔ a ∣ b",
    "args": "{α : Type u} [semigroup α] [has_distrib_neg α] (a b : α)",
    "doc_string": " The negation of an element a of a semigroup with a distributive negation divides another element b iff a divides b.",
    "type": "-a ∣ b ↔ a ∣ b"
  },
  {
    "name": "eq.trans_ge",
    "statement": "theorem eq.trans_ge {α : Type u} [preorder α] {a b c : α} : b = c → a ≤ b → a ≤ c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : b = c → a ≤ b → a ≤ c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of le_of_eq_of_le'`.",
    "type": "b = c → a ≤ b → a ≤ c"
  },
  {
    "name": "matrix.is_unit_diagonal",
    "statement": "theorem matrix.is_unit_diagonal {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {v : n → α} : is_unit (matrix.diagonal v) ↔ is_unit v",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {v : n → α} : is_unit (matrix.diagonal v) ↔ is_unit v",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {v : n → α}",
    "doc_string": "When lowered to a prop, `matrix.diagonal_invertible_equiv_invertible` forms an `iff`.",
    "type": "is_unit (matrix.diagonal v) ↔ is_unit v"
  },
  {
    "name": "ordered_add_comm_group.lt_of_add_lt_add_left",
    "statement": "theorem ordered_add_comm_group.lt_of_add_lt_add_left {α : Type u_1} [has_add α] [has_lt α] [contravariant_class α α has_add.add has_lt.lt] {a b c : α} (bc : a + b < a + c) : b < c",
    "theorem": "{α : Type u_1} [has_add α] [has_lt α] [contravariant_class α α has_add.add has_lt.lt] {a b c : α} (bc : a + b < a + c) : b < c",
    "args": "{α : Type u_1} [has_add α] [has_lt α] [contravariant_class α α has_add.add has_lt.lt] {a b c : α} (bc : a + b < a + c)",
    "doc_string": "**Alias** of lt_of_mul_lt_mul_left'`.",
    "type": "b < c"
  },
  {
    "name": "complete_lattice.independent.pairwise_disjoint",
    "statement": "theorem complete_lattice.independent.pairwise_disjoint {α : Type u_1} {ι : Type u_3} [complete_lattice α] {t : ι → α} (ht : complete_lattice.independent t) : pairwise (disjoint on t)",
    "theorem": "{α : Type u_1} {ι : Type u_3} [complete_lattice α] {t : ι → α} (ht : complete_lattice.independent t) : pairwise (disjoint on t)",
    "args": "{α : Type u_1} {ι : Type u_3} [complete_lattice α] {t : ι → α} (ht : complete_lattice.independent t)",
    "doc_string": "If the elements of a set are independent, then any pair within that set is disjoint.",
    "type": "pairwise (disjoint on t)"
  },
  {
    "name": "nonempty_measurable_superset",
    "statement": "theorem nonempty_measurable_superset {α : Type u_1} {m : measurable_space α} (s : set α) : nonempty {t // s ⊆ t ∧ measurable_set t}",
    "theorem": "{α : Type u_1} {m : measurable_space α} (s : set α) : nonempty {t // s ⊆ t ∧ measurable_set t}",
    "args": "{α : Type u_1} {m : measurable_space α} (s : set α)",
    "doc_string": "Every set has a measurable superset. Declare this as local instance as needed.",
    "type": "nonempty {t // s ⊆ t ∧ measurable_set t}"
  },
  {
    "name": "dvd_add_self_right",
    "statement": "theorem dvd_add_self_right {α : Type u} [ring α] {a b : α} : a ∣ b + a ↔ a ∣ b",
    "theorem": "{α : Type u} [ring α] {a b : α} : a ∣ b + a ↔ a ∣ b",
    "args": "{α : Type u} [ring α] {a b : α}",
    "doc_string": "An element a divides the sum b + a if and only if a divides b.",
    "type": "a ∣ b + a ↔ a ∣ b"
  },
  {
    "name": "dense.inter_of_open_right",
    "statement": "theorem dense.inter_of_open_right {α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s ∩ t)",
    "theorem": "{α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s ∩ t)",
    "args": "{α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hto : is_open t)",
    "doc_string": "The intersection of a dense set with an open dense set is a dense set.",
    "type": "dense (s ∩ t)"
  },
  {
    "name": "left.add_nonpos",
    "statement": "theorem left.add_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_nonpos`.",
    "type": "a + b ≤ 0"
  },
  {
    "name": "is_fw_invariant.is_invariant",
    "statement": "theorem is_fw_invariant.is_invariant {τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α} (h : is_fw_invariant ϕ s) : is_invariant ϕ s",
    "theorem": "{τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α} (h : is_fw_invariant ϕ s) : is_invariant ϕ s",
    "args": "{τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α} (h : is_fw_invariant ϕ s)",
    "doc_string": " If `τ` is a `canonically_ordered_add_monoid` (e.g., `ℕ` or `ℝ≥0`), then the notions `is_fw_invariant` and `is_invariant` are equivalent.",
    "type": "is_invariant ϕ s"
  },
  {
    "name": "function.cantor_surjective",
    "statement": "theorem function.cantor_surjective {α : Type u_1} (f : α → set α) : ¬function.surjective f",
    "theorem": "{α : Type u_1} (f : α → set α) : ¬function.surjective f",
    "args": "{α : Type u_1} (f : α → set α)",
    "doc_string": " **Cantor's diagonal argument** implies that there are no surjective functions from `α` to `set α`.",
    "type": "¬function.surjective f"
  },
  {
    "name": "finite_dimensional.proper_is_R_or_C",
    "statement": "theorem finite_dimensional.proper_is_R_or_C (K : Type u_1) [is_R_or_C K] (E : Type u_2) [normed_group E] [normed_space K E] [finite_dimensional K E] : proper_space E",
    "theorem": "(K : Type u_1) [is_R_or_C K] (E : Type u_2) [normed_group E] [normed_space K E] [finite_dimensional K E] : proper_space E",
    "args": "(K : Type u_1) [is_R_or_C K] (E : Type u_2) [normed_group E] [normed_space K E] [finite_dimensional K E]",
    "doc_string": " A finite dimensional vector space Over an `is_R_or_C` is a proper metric space.  This is not an instance because it would cause a search for `finite_dimensional ?x E` before `is_R_or_C ?x`.",
    "type": "proper_space E"
  },
  {
    "name": "is_open.is_Gδ",
    "statement": "theorem is_open.is_Gδ {α : Type u_1} [topological_space α] {s : set α} (h : is_open s) : is_Gδ s",
    "theorem": "{α : Type u_1} [topological_space α] {s : set α} (h : is_open s) : is_Gδ s",
    "args": "{α : Type u_1} [topological_space α] {s : set α} (h : is_open s)",
    "doc_string": "An open set is a Gδ set.",
    "type": "is_Gδ s"
  },
  {
    "name": "list.exists_of_mem_map",
    "statement": "theorem list.exists_of_mem_map {α : Type u} {β : Type v} {f : α → β} {b : β} {l : list α} : b ∈ list.map f l → (∃ (a : α), a ∈ l ∧ f a = b)",
    "theorem": "{α : Type u} {β : Type v} {f : α → β} {b : β} {l : list α} : b ∈ list.map f l → (∃ (a : α), a ∈ l ∧ f a = b)",
    "args": "{α : Type u} {β : Type v} {f : α → β} {b : β} {l : list α}",
    "doc_string": "**Alias** of the forward direction of list.mem_map`.",
    "type": "b ∈ list.map f l → (∃ (a : α), a ∈ l ∧ f a = b)"
  },
  {
    "name": "is_add_right_regular.add",
    "statement": "theorem is_add_right_regular.add {R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b) : is_add_right_regular (a + b)",
    "theorem": "{R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b) : is_add_right_regular (a + b)",
    "args": "{R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b)",
    "doc_string": "In an additive semigroup, the sum of add-right-regular elements is add-right-regular.",
    "type": "is_add_right_regular (a + b)"
  },
  {
    "name": "filter.tendsto.germ_tendsto",
    "statement": "theorem filter.tendsto.germ_tendsto {α : Type u_1} {β : Type u_2} {l : filter α} {f : α → β} {lb : filter β} : filter.tendsto f l lb → ↑f.tendsto lb",
    "theorem": "{α : Type u_1} {β : Type u_2} {l : filter α} {f : α → β} {lb : filter β} : filter.tendsto f l lb → ↑f.tendsto lb",
    "args": "{α : Type u_1} {β : Type u_2} {l : filter α} {f : α → β} {lb : filter β}",
    "doc_string": "**Alias** of the reverse direction of filter.germ.coe_tendsto`.",
    "type": "filter.tendsto f l lb → ↑f.tendsto lb"
  },
  {
    "name": "add_tsub_le_right",
    "statement": "theorem add_tsub_le_right {α : Type u_1} [preorder α] [has_add α] [has_sub α] [has_ordered_sub α] {a b : α} : a + b - b ≤ a",
    "theorem": "{α : Type u_1} [preorder α] [has_add α] [has_sub α] [has_ordered_sub α] {a b : α} : a + b - b ≤ a",
    "args": "{α : Type u_1} [preorder α] [has_add α] [has_sub α] [has_ordered_sub α] {a b : α}",
    "doc_string": "See `add_tsub_cancel_right` for the equality if `contravariant_class α α (+) (≤)`.",
    "type": "a + b - b ≤ a"
  },
  {
    "name": "power_series.X_prime",
    "statement": "theorem power_series.X_prime {R : Type u_1} [comm_ring R] [is_domain R] : prime power_series.X",
    "theorem": "{R : Type u_1} [comm_ring R] [is_domain R] : prime power_series.X",
    "args": "{R : Type u_1} [comm_ring R] [is_domain R]",
    "doc_string": "The variable of the power series ring over an integral domain is prime.",
    "type": "prime power_series.X"
  },
  {
    "name": "fin.add_nat_cast",
    "statement": "theorem fin.add_nat_cast {n n' m : ℕ} (i : fin n') (h : n' = n) : ⇑(fin.add_nat m) (⇑(fin.cast h) i) = ⇑(fin.cast _) (⇑(fin.add_nat m) i)",
    "theorem": "{n n' m : ℕ} (i : fin n') (h : n' = n) : ⇑(fin.add_nat m) (⇑(fin.cast h) i) = ⇑(fin.cast _) (⇑(fin.add_nat m) i)",
    "args": "{n n' m : ℕ} (i : fin n') (h : n' = n)",
    "doc_string": "For rewriting in the reverse direction, see `fin.cast_add_nat_left`.",
    "type": "⇑(fin.add_nat m) (⇑(fin.cast h) i) = ⇑(fin.cast _) (⇑(fin.add_nat m) i)"
  },
  {
    "name": "exists_prime_order_of_dvd_card",
    "statement": "theorem exists_prime_order_of_dvd_card {G : Type u_1} [group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), order_of x = p",
    "theorem": "{G : Type u_1} [group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), order_of x = p",
    "args": "{G : Type u_1} [group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G)",
    "doc_string": " For every prime `p` dividing the order of a finite group `G` there exists an element of order `p` in `G`. This is known as Cauchy's theorem.",
    "type": "∃ (x : G), order_of x = p"
  },
  {
    "name": "lt_sub_right_of_add_lt",
    "statement": "theorem lt_sub_right_of_add_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a + b < c → a < c - b",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a + b < c → a < c - b",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of lt_sub_iff_add_lt`.",
    "type": "a + b < c → a < c - b"
  },
  {
    "name": "ordinal.eq_enum_ord",
    "statement": "theorem ordinal.eq_enum_ord {S : set ordinal} (f : ordinal → ordinal) (hS : set.unbounded has_lt.lt S) : strict_mono f ∧ set.range f = S ↔ f = ordinal.enum_ord S",
    "theorem": "{S : set ordinal} (f : ordinal → ordinal) (hS : set.unbounded has_lt.lt S) : strict_mono f ∧ set.range f = S ↔ f = ordinal.enum_ord S",
    "args": "{S : set ordinal} (f : ordinal → ordinal) (hS : set.unbounded has_lt.lt S)",
    "doc_string": "A characterization of `enum_ord`: it is the unique strict monotonic function with range `S`.",
    "type": "strict_mono f ∧ set.range f = S ↔ f = ordinal.enum_ord S"
  },
  {
    "name": "is_regular_mul_and_mul_iff",
    "statement": "theorem is_regular_mul_and_mul_iff {R : Type u_1} {a b : R} [semigroup R] : is_regular (a * b) ∧ is_regular (b * a) ↔ is_regular a ∧ is_regular b",
    "theorem": "{R : Type u_1} {a b : R} [semigroup R] : is_regular (a * b) ∧ is_regular (b * a) ↔ is_regular a ∧ is_regular b",
    "args": "{R : Type u_1} {a b : R} [semigroup R]",
    "doc_string": "  Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a` are regular.",
    "type": "is_regular (a * b) ∧ is_regular (b * a) ↔ is_regular a ∧ is_regular b"
  },
  {
    "name": "lt_mul_of_inv_mul_lt_left",
    "statement": "theorem lt_mul_of_inv_mul_lt_left {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b⁻¹ * a < c → a < b * c",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b⁻¹ * a < c → a < b * c",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of lt_mul_of_inv_mul_lt`.",
    "type": "b⁻¹ * a < c → a < b * c"
  },
  {
    "name": "finset.min'_lt_max'_of_card",
    "statement": "theorem finset.min'_lt_max'_of_card {α : Type u_1} [linear_order α] (s : finset α) (h₂ : 1 < s.card) : s.min' _ < s.max' _",
    "theorem": "{α : Type u_1} [linear_order α] (s : finset α) (h₂ : 1 < s.card) : s.min' _ < s.max' _",
    "args": "{α : Type u_1} [linear_order α] (s : finset α) (h₂ : 1 < s.card)",
    "doc_string": "If there's more than 1 element, the min' is less than the max'. An alternate version of `min'_lt_max'` which is sometimes more convenient.",
    "type": "s.min' _ < s.max' _"
  },
  {
    "name": "is_totally_disconnected_of_clopen_set",
    "statement": "theorem is_totally_disconnected_of_clopen_set {X : Type u_1} [topological_space X] (hX : ∀ {x y : X}, x ≠ y → (∃ (U : set X) (h_clopen : is_clopen U), x ∈ U ∧ y ∉ U)) : is_totally_disconnected set.univ",
    "theorem": "{X : Type u_1} [topological_space X] (hX : ∀ {x y : X}, x ≠ y → (∃ (U : set X) (h_clopen : is_clopen U), x ∈ U ∧ y ∉ U)) : is_totally_disconnected set.univ",
    "args": "{X : Type u_1} [topological_space X] (hX : ∀ {x y : X}, x ≠ y → (∃ (U : set X) (h_clopen : is_clopen U), x ∈ U ∧ y ∉ U))",
    "doc_string": "Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there  is some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected.",
    "type": "is_totally_disconnected set.univ"
  },
  {
    "name": "fin.succ_above_lt_ge",
    "statement": "theorem fin.succ_above_lt_ge {n : ℕ} (p : fin (n + 1)) (i : fin n) : ⇑fin.cast_succ i < p ∨ p ≤ ⇑fin.cast_succ i",
    "theorem": "{n : ℕ} (p : fin (n + 1)) (i : fin n) : ⇑fin.cast_succ i < p ∨ p ≤ ⇑fin.cast_succ i",
    "args": "{n : ℕ} (p : fin (n + 1)) (i : fin n)",
    "doc_string": "Embedding `i : fin n` into `fin (n + 1)` is always about some hole `p`.",
    "type": "⇑fin.cast_succ i < p ∨ p ≤ ⇑fin.cast_succ i"
  },
  {
    "name": "fin.cast_succ_pos",
    "statement": "theorem fin.cast_succ_pos {n : ℕ} {i : fin (n + 1)} (h : 0 < i) : 0 < ⇑fin.cast_succ i",
    "theorem": "{n : ℕ} {i : fin (n + 1)} (h : 0 < i) : 0 < ⇑fin.cast_succ i",
    "args": "{n : ℕ} {i : fin (n + 1)} (h : 0 < i)",
    "doc_string": "`cast_succ i` is positive when `i` is positive",
    "type": "0 < ⇑fin.cast_succ i"
  },
  {
    "name": "prime.dvd_prod_iff",
    "statement": "theorem prime.dvd_prod_iff {M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p) : p ∣ L.prod ↔ ∃ (a : M) (H : a ∈ L), p ∣ a",
    "theorem": "{M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p) : p ∣ L.prod ↔ ∃ (a : M) (H : a ∈ L), p ∣ a",
    "args": "{M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p)",
    "doc_string": "Prime `p` divides the product of a list `L` iff it divides some `a ∈ L`",
    "type": "p ∣ L.prod ↔ ∃ (a : M) (H : a ∈ L), p ∣ a"
  },
  {
    "name": "right.one_lt_mul_of_le_of_lt",
    "statement": "theorem right.one_lt_mul_of_le_of_lt {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 < b)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul_of_le_of_lt`.",
    "type": "1 < a * b"
  },
  {
    "name": "fin.cast_succ_eq",
    "statement": "theorem fin.cast_succ_eq {n n' : ℕ} (i : fin n) (h : n.succ = n'.succ) : ⇑(fin.cast h) i.succ = (⇑(fin.cast _) i).succ",
    "theorem": "{n n' : ℕ} (i : fin n) (h : n.succ = n'.succ) : ⇑(fin.cast h) i.succ = (⇑(fin.cast _) i).succ",
    "args": "{n n' : ℕ} (i : fin n) (h : n.succ = n'.succ)",
    "doc_string": " The cast of the successor is the succesor of the cast. See `fin.succ_cast_eq` for rewriting in the reverse direction.",
    "type": "⇑(fin.cast h) i.succ = (⇑(fin.cast _) i).succ"
  },
  {
    "name": "finite_field.even_card_iff_char_two",
    "statement": "theorem finite_field.even_card_iff_char_two {F : Type u_3} [field F] [fintype F] : ring_char F = 2 ↔ fintype.card F % 2 = 0",
    "theorem": "{F : Type u_3} [field F] [fintype F] : ring_char F = 2 ↔ fintype.card F % 2 = 0",
    "args": "{F : Type u_3} [field F] [fintype F]",
    "doc_string": "The finite field `F` has even cardinality iff it has characteristic `2`.",
    "type": "ring_char F = 2 ↔ fintype.card F % 2 = 0"
  },
  {
    "name": "char.quadratic_char_neg_one_iff_not_is_square",
    "statement": "theorem char.quadratic_char_neg_one_iff_not_is_square {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} : char.quadratic_char F a = -1 ↔ ¬is_square a",
    "theorem": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} : char.quadratic_char F a = -1 ↔ ¬is_square a",
    "args": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F}",
    "doc_string": "For `a : F`, `quadratic_char F a = -1 ↔ ¬ is_square a`.",
    "type": "char.quadratic_char F a = -1 ↔ ¬is_square a"
  },
  {
    "name": "decidable.em",
    "statement": "theorem decidable.em (p : Prop) [decidable p] : p ∨ ¬p",
    "theorem": "(p : Prop) [decidable p] : p ∨ ¬p",
    "args": "(p : Prop) [decidable p]",
    "doc_string": "Law of Excluded Middle.",
    "type": "p ∨ ¬p"
  },
  {
    "name": "exists_lt_of_cinfi_lt",
    "statement": "theorem exists_lt_of_cinfi_lt {α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {a : α} [nonempty ι] {f : ι → α} (h : infi f < a) : ∃ (i : ι), f i < a",
    "theorem": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {a : α} [nonempty ι] {f : ι → α} (h : infi f < a) : ∃ (i : ι), f i < a",
    "args": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {a : α} [nonempty ι] {f : ι → α} (h : infi f < a)",
    "doc_string": "Indexed version of the above lemma `exists_lt_of_cInf_lt` When `infi f < a`, there is an element `i` such that `f i < a`.",
    "type": "∃ (i : ι), f i < a"
  },
  {
    "name": "is_prime_pow_iff_pow_succ",
    "statement": "theorem is_prime_pow_iff_pow_succ {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ↔ ∃ (p : R) (k : ℕ), prime p ∧ p ^ (k + 1) = n",
    "theorem": "{R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ↔ ∃ (p : R) (k : ℕ), prime p ∧ p ^ (k + 1) = n",
    "args": "{R : Type u_1} [comm_monoid_with_zero R] (n : R)",
    "doc_string": " An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`.",
    "type": "is_prime_pow n ↔ ∃ (p : R) (k : ℕ), prime p ∧ p ^ (k + 1) = n"
  },
  {
    "name": "edist_triangle_left",
    "statement": "theorem edist_triangle_left {α : Type u} [pseudo_emetric_space α] (x y z : α) : has_edist.edist x y ≤ has_edist.edist z x + has_edist.edist z y",
    "theorem": "{α : Type u} [pseudo_emetric_space α] (x y z : α) : has_edist.edist x y ≤ has_edist.edist z x + has_edist.edist z y",
    "args": "{α : Type u} [pseudo_emetric_space α] (x y z : α)",
    "doc_string": "Triangle inequality for the extended distance",
    "type": "has_edist.edist x y ≤ has_edist.edist z x + has_edist.edist z y"
  },
  {
    "name": "mul_self_add_mul_self_eq_zero",
    "statement": "theorem mul_self_add_mul_self_eq_zero {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0",
    "theorem": "{α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0",
    "args": "{α : Type u} [linear_ordered_ring α] {x y : α}",
    "doc_string": "The sum of two squares is zero iff both elements are zero.",
    "type": "x * x + y * y = 0 ↔ x = 0 ∧ y = 0"
  },
  {
    "name": "right.add_neg'",
    "statement": "theorem right.add_neg' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a < 0) (hb : b < 0)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_neg'`.",
    "type": "a + b < 0"
  },
  {
    "name": "finset.card_le_one_of_subsingleton",
    "statement": "theorem finset.card_le_one_of_subsingleton {α : Type u_1} [subsingleton α] (s : finset α) : s.card ≤ 1",
    "theorem": "{α : Type u_1} [subsingleton α] (s : finset α) : s.card ≤ 1",
    "args": "{α : Type u_1} [subsingleton α] (s : finset α)",
    "doc_string": "A `finset` of a subsingleton type has cardinality at most one.",
    "type": "s.card ≤ 1"
  },
  {
    "name": "is_add_right_regular_of_add_eq_zero",
    "statement": "theorem is_add_right_regular_of_add_eq_zero {R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0) : is_add_right_regular a",
    "theorem": "{R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0) : is_add_right_regular a",
    "args": "{R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0)",
    "doc_string": "An element admitting a right additive opposite is add-right-regular.",
    "type": "is_add_right_regular a"
  },
  {
    "name": "is_torsion_free.not_torsion",
    "statement": "theorem is_torsion_free.not_torsion {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G",
    "theorem": "{G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G",
    "args": "{G : Type u_1} [group G] [hN : nontrivial G]",
    "doc_string": "A nontrivial torsion-free group is not torsion.",
    "type": "monoid.is_torsion_free G → ¬monoid.is_torsion G"
  },
  {
    "name": "generalized_continued_fraction.ext_iff",
    "statement": "theorem generalized_continued_fraction.ext_iff {α : Type u_1} {g g' : generalized_continued_fraction α} : g = g' ↔ g.h = g'.h ∧ g.s = g'.s",
    "theorem": "{α : Type u_1} {g g' : generalized_continued_fraction α} : g = g' ↔ g.h = g'.h ∧ g.s = g'.s",
    "args": "{α : Type u_1} {g g' : generalized_continued_fraction α}",
    "doc_string": "Two gcfs `g` and `g'` are equal if and only if their components are equal.",
    "type": "g = g' ↔ g.h = g'.h ∧ g.s = g'.s"
  },
  {
    "name": "formal_multilinear_series.id_apply_one",
    "statement": "theorem formal_multilinear_series.id_apply_one (𝕜 : Type u_1) (E : Type u_2) [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] (v : fin 1 → E) : ⇑(formal_multilinear_series.id 𝕜 E 1) v = v 0",
    "theorem": "(𝕜 : Type u_1) (E : Type u_2) [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] (v : fin 1 → E) : ⇑(formal_multilinear_series.id 𝕜 E 1) v = v 0",
    "args": "(𝕜 : Type u_1) (E : Type u_2) [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] (v : fin 1 → E)",
    "doc_string": "The first coefficient of `id 𝕜 E` is the identity.",
    "type": "⇑(formal_multilinear_series.id 𝕜 E 1) v = v 0"
  },
  {
    "name": "metric.diam_mono",
    "statement": "theorem metric.diam_mono {α : Type u} [pseudo_metric_space α] {s t : set α} (h : s ⊆ t) (ht : metric.bounded t) : metric.diam s ≤ metric.diam t",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s t : set α} (h : s ⊆ t) (ht : metric.bounded t) : metric.diam s ≤ metric.diam t",
    "args": "{α : Type u} [pseudo_metric_space α] {s t : set α} (h : s ⊆ t) (ht : metric.bounded t)",
    "doc_string": "If `s ⊆ t`, then the diameter of `s` is bounded by that of `t`, provided `t` is bounded.",
    "type": "metric.diam s ≤ metric.diam t"
  },
  {
    "name": "add_con.add",
    "statement": "theorem add_con.add {M : Type u_1} [has_add M] (c : add_con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w + y) (x + z)",
    "theorem": "{M : Type u_1} [has_add M] (c : add_con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w + y) (x + z)",
    "args": "{M : Type u_1} [has_add M] (c : add_con M) {w x y z : M}",
    "doc_string": "Additive congruence relations preserve addition.",
    "type": "⇑c w x → ⇑c y z → ⇑c (w + y) (x + z)"
  },
  {
    "name": "empty_wf",
    "statement": "theorem empty_wf {α : Sort u} : well_founded empty_relation",
    "theorem": "{α : Sort u} : well_founded empty_relation",
    "args": "{α : Sort u}",
    "doc_string": "Empty relation is well-founded",
    "type": "well_founded empty_relation"
  },
  {
    "name": "pnat.xgcd_type.step_v",
    "statement": "theorem pnat.xgcd_type.step_v (u : pnat.xgcd_type) (hr : u.r ≠ 0) : u.step.v = u.v.swap",
    "theorem": "(u : pnat.xgcd_type) (hr : u.r ≠ 0) : u.step.v = u.v.swap",
    "args": "(u : pnat.xgcd_type) (hr : u.r ≠ 0)",
    "doc_string": "The reduction step does not change the product vector.",
    "type": "u.step.v = u.v.swap"
  },
  {
    "name": "subset_span_points",
    "statement": "theorem subset_span_points (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ⊆ span_points k s",
    "theorem": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ⊆ span_points k s",
    "args": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P)",
    "doc_string": "A set is contained in its `span_points`.",
    "type": "s ⊆ span_points k s"
  },
  {
    "name": "order.lt_of_succ_lt_succ",
    "statement": "theorem order.lt_of_succ_lt_succ {α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : order.succ a < order.succ b → a < b",
    "theorem": "{α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : order.succ a < order.succ b → a < b",
    "args": "{α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α]",
    "doc_string": "**Alias** of the forward direction of order.succ_lt_succ_iff`.",
    "type": "order.succ a < order.succ b → a < b"
  },
  {
    "name": "sub_one_div_inv_le_two",
    "statement": "theorem sub_one_div_inv_le_two {α : Type u_1} [linear_ordered_field α] {a : α} (a2 : 2 ≤ a) : (1 - 1 / a)⁻¹ ≤ 2",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a : α} (a2 : 2 ≤ a) : (1 - 1 / a)⁻¹ ≤ 2",
    "args": "{α : Type u_1} [linear_ordered_field α] {a : α} (a2 : 2 ≤ a)",
    "doc_string": "An inequality involving `2`.",
    "type": "(1 - 1 / a)⁻¹ ≤ 2"
  },
  {
    "name": "formal_multilinear_series.id_apply_ne_one",
    "statement": "theorem formal_multilinear_series.id_apply_ne_one (𝕜 : Type u_1) (E : Type u_2) [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] {n : ℕ} (h : n ≠ 1) : formal_multilinear_series.id 𝕜 E n = 0",
    "theorem": "(𝕜 : Type u_1) (E : Type u_2) [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] {n : ℕ} (h : n ≠ 1) : formal_multilinear_series.id 𝕜 E n = 0",
    "args": "(𝕜 : Type u_1) (E : Type u_2) [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] {n : ℕ} (h : n ≠ 1)",
    "doc_string": "For `n ≠ 1`, the `n`-th coefficient of `id 𝕜 E` is zero, by definition.",
    "type": "formal_multilinear_series.id 𝕜 E n = 0"
  },
  {
    "name": "turing.list_blank.cons_head_tail",
    "statement": "theorem turing.list_blank.cons_head_tail {Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : turing.list_blank.cons l.head l.tail = l",
    "theorem": "{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : turing.list_blank.cons l.head l.tail = l",
    "args": "{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ)",
    "doc_string": " The `cons` and `head`/`tail` functions are mutually inverse, unlike in the case of `list` where this only holds for nonempty lists.",
    "type": "turing.list_blank.cons l.head l.tail = l"
  },
  {
    "name": "mul_opposite.op_pow",
    "statement": "theorem mul_opposite.op_pow {M : Type u} [monoid M] (x : M) (n : ℕ) : mul_opposite.op (x ^ n) = mul_opposite.op x ^ n",
    "theorem": "{M : Type u} [monoid M] (x : M) (n : ℕ) : mul_opposite.op (x ^ n) = mul_opposite.op x ^ n",
    "args": "{M : Type u} [monoid M] (x : M) (n : ℕ)",
    "doc_string": "Moving to the opposite monoid commutes with taking powers.",
    "type": "mul_opposite.op (x ^ n) = mul_opposite.op x ^ n"
  },
  {
    "name": "ordinal.opow_le_iff_le_log",
    "statement": "theorem ordinal.opow_le_iff_le_log {b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x) : b ^ c ≤ x ↔ c ≤ ordinal.log b x",
    "theorem": "{b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x) : b ^ c ≤ x ↔ c ≤ ordinal.log b x",
    "args": "{b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x)",
    "doc_string": "`opow b` and `log b` (almost) form a Galois connection.",
    "type": "b ^ c ≤ x ↔ c ≤ ordinal.log b x"
  },
  {
    "name": "fin_injective",
    "statement": "theorem fin_injective  : function.injective fin",
    "theorem": " : function.injective fin",
    "args": "",
    "doc_string": " `fin` as a map from `ℕ` to `Type` is injective. Note that since this is a statement about equality of types, using it should be avoided if possible.",
    "type": "function.injective fin"
  },
  {
    "name": "con.mk'_ker",
    "statement": "theorem con.mk'_ker {M : Type u_1} [mul_one_class M] (c : con M) : con.ker c.mk' = c",
    "theorem": "{M : Type u_1} [mul_one_class M] (c : con M) : con.ker c.mk' = c",
    "args": "{M : Type u_1} [mul_one_class M] (c : con M)",
    "doc_string": "The kernel of the natural homomorphism from a monoid to its quotient by a congruence    relation `c` equals `c`.",
    "type": "con.ker c.mk' = c"
  },
  {
    "name": "list.nat.mem_antidiagonal",
    "statement": "theorem list.nat.mem_antidiagonal {n : ℕ} {x : ℕ × ℕ} : x ∈ list.nat.antidiagonal n ↔ x.fst + x.snd = n",
    "theorem": "{n : ℕ} {x : ℕ × ℕ} : x ∈ list.nat.antidiagonal n ↔ x.fst + x.snd = n",
    "args": "{n : ℕ} {x : ℕ × ℕ}",
    "doc_string": "A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`.",
    "type": "x ∈ list.nat.antidiagonal n ↔ x.fst + x.snd = n"
  },
  {
    "name": "matrix.fin.circulant_ite",
    "statement": "theorem matrix.fin.circulant_ite (α : Type u_1) [has_zero α] [has_one α] (n : ℕ) : matrix.circulant (λ (i : fin n), ite (↑i = 0) 1 0) = 1",
    "theorem": "(α : Type u_1) [has_zero α] [has_one α] (n : ℕ) : matrix.circulant (λ (i : fin n), ite (↑i = 0) 1 0) = 1",
    "args": "(α : Type u_1) [has_zero α] [has_one α] (n : ℕ)",
    "doc_string": " Note we use `↑i = 0` instead of `i = 0` as `fin 0` has no `0`. This means that we cannot state this with `pi.single` as we did with `matrix.circulant_single`.",
    "type": "matrix.circulant (λ (i : fin n), ite (↑i = 0) 1 0) = 1"
  },
  {
    "name": "sq",
    "statement": "theorem sq {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a",
    "theorem": "{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a",
    "args": "{M : Type u} [monoid M] (a : M)",
    "doc_string": "**Alias** of pow_two`.",
    "type": "a ^ 2 = a * a"
  },
  {
    "name": "category_theory.limits.has_colimits_of_size_shrink",
    "statement": "theorem category_theory.limits.has_colimits_of_size_shrink (C : Type u) [category_theory.category C] [category_theory.limits.has_colimits_of_size C] : category_theory.limits.has_colimits_of_size C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits_of_size C] : category_theory.limits.has_colimits_of_size C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits_of_size C]",
    "doc_string": "`has_colimits_of_size_shrink.{v u} C` tries to obtain `has_colimits_of_size.{v u} C` from some other `has_colimits_of_size C`.",
    "type": "category_theory.limits.has_colimits_of_size C"
  },
  {
    "name": "nonpos_of_neg_nonneg",
    "statement": "theorem nonpos_of_neg_nonneg {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : 0 ≤ -a → a ≤ 0",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : 0 ≤ -a → a ≤ 0",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α}",
    "doc_string": "**Alias** of the forward direction of left.one_le_inv_iff`.",
    "type": "0 ≤ -a → a ≤ 0"
  },
  {
    "name": "fin.coe_cast",
    "statement": "theorem fin.coe_cast {n m : ℕ} (h : n = m) (i : fin n) : ↑(⇑(fin.cast h) i) = ↑i",
    "theorem": "{n m : ℕ} (h : n = m) (i : fin n) : ↑(⇑(fin.cast h) i) = ↑i",
    "args": "{n m : ℕ} (h : n = m) (i : fin n)",
    "doc_string": " While `fin.coe_order_iso_apply` is a more general case of this, we mark this `simp` anyway as it is eligible for `dsimp`.",
    "type": "↑(⇑(fin.cast h) i) = ↑i"
  },
  {
    "name": "affine_subspace.bot_coe",
    "statement": "theorem affine_subspace.bot_coe (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ↑⊥ = ∅",
    "theorem": "(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ↑⊥ = ∅",
    "args": "(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P]",
    "doc_string": "`⊥`, coerced to a set, is the empty set.",
    "type": "↑⊥ = ∅"
  },
  {
    "name": "dvd_of_mul_left_eq",
    "statement": "theorem dvd_of_mul_left_eq {α : Type u_1} [comm_semigroup α] {a b : α} (c : α) (h : c * a = b) : a ∣ b",
    "theorem": "{α : Type u_1} [comm_semigroup α] {a b : α} (c : α) (h : c * a = b) : a ∣ b",
    "args": "{α : Type u_1} [comm_semigroup α] {a b : α} (c : α) (h : c * a = b)",
    "doc_string": "**Alias** of dvd.intro_left`.",
    "type": "a ∣ b"
  },
  {
    "name": "semiconj_by.one_left",
    "statement": "theorem semiconj_by.one_left {M : Type u} [mul_one_class M] (x : M) : semiconj_by 1 x x",
    "theorem": "{M : Type u} [mul_one_class M] (x : M) : semiconj_by 1 x x",
    "args": "{M : Type u} [mul_one_class M] (x : M)",
    "doc_string": "One semiconjugates any element to itself.",
    "type": "semiconj_by 1 x x"
  },
  {
    "name": "zero_lt.right.mul_lt_one_of_le_of_lt",
    "statement": "theorem zero_lt.right.mul_lt_one_of_le_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b < 1) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "type": "a * b < 1"
  },
  {
    "name": "valuation.subgroups_basis",
    "statement": "theorem valuation.subgroups_basis {R : Type u} [ring R] {Γ₀ : Type v} [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) : ring_subgroups_basis (λ (γ : Γ₀ˣ), v.lt_add_subgroup γ)",
    "theorem": "{R : Type u} [ring R] {Γ₀ : Type v} [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) : ring_subgroups_basis (λ (γ : Γ₀ˣ), v.lt_add_subgroup γ)",
    "args": "{R : Type u} [ring R] {Γ₀ : Type v} [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀)",
    "doc_string": "The basis of open subgroups for the topology on a ring determined by a valuation.",
    "type": "ring_subgroups_basis (λ (γ : Γ₀ˣ), v.lt_add_subgroup γ)"
  },
  {
    "name": "inseparable.nhds_eq",
    "statement": "theorem inseparable.nhds_eq {X : Type u_1} [topological_space X] {x y : X} : inseparable x y → nhds x = nhds y",
    "theorem": "{X : Type u_1} [topological_space X] {x y : X} : inseparable x y → nhds x = nhds y",
    "args": "{X : Type u_1} [topological_space X] {x y : X}",
    "doc_string": "**Alias** of the forward direction of inseparable_iff_nhds_eq`.",
    "type": "inseparable x y → nhds x = nhds y"
  },
  {
    "name": "has_le.le.eq_or_lt_dec",
    "statement": "theorem has_le.le.eq_or_lt_dec {α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b) : a = b ∨ a < b",
    "theorem": "{α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b) : a = b ∨ a < b",
    "args": "{α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b)",
    "doc_string": "**Alias** of decidable.eq_or_lt_of_le`.",
    "type": "a = b ∨ a < b"
  },
  {
    "name": "zero_lt.left.mul_pos",
    "statement": "theorem zero_lt.left.mul_pos {α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 0 < a) (hb : 0 < b) : 0 < a * b",
    "theorem": "{α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 0 < a) (hb : 0 < b) : 0 < a * b",
    "args": "{α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "Assumes left covariance.",
    "type": "0 < a * b"
  },
  {
    "name": "orthonormal.linear_independent",
    "statement": "theorem orthonormal.linear_independent {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) : linear_independent 𝕜 v",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) : linear_independent 𝕜 v",
    "args": "{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v)",
    "doc_string": "An orthonormal set is linearly independent.",
    "type": "linear_independent 𝕜 v"
  },
  {
    "name": "dist_nndist",
    "statement": "theorem dist_nndist {α : Type u} [pseudo_metric_space α] (x y : α) : has_dist.dist x y = ↑(has_nndist.nndist x y)",
    "theorem": "{α : Type u} [pseudo_metric_space α] (x y : α) : has_dist.dist x y = ↑(has_nndist.nndist x y)",
    "args": "{α : Type u} [pseudo_metric_space α] (x y : α)",
    "doc_string": "Express `dist` in terms of `nndist`",
    "type": "has_dist.dist x y = ↑(has_nndist.nndist x y)"
  },
  {
    "name": "continuous_linear_map.lmul_left_right_is_bounded_bilinear",
    "statement": "theorem continuous_linear_map.lmul_left_right_is_bounded_bilinear (𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] (𝕜' : Type u_2) [normed_ring 𝕜'] [normed_algebra 𝕜 𝕜'] : is_bounded_bilinear_map 𝕜 (λ (p : 𝕜' × 𝕜'), ⇑(⇑(continuous_linear_map.lmul_left_right 𝕜 𝕜') p.fst) p.snd)",
    "theorem": "(𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] (𝕜' : Type u_2) [normed_ring 𝕜'] [normed_algebra 𝕜 𝕜'] : is_bounded_bilinear_map 𝕜 (λ (p : 𝕜' × 𝕜'), ⇑(⇑(continuous_linear_map.lmul_left_right 𝕜 𝕜') p.fst) p.snd)",
    "args": "(𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] (𝕜' : Type u_2) [normed_ring 𝕜'] [normed_algebra 𝕜 𝕜']",
    "doc_string": "The function `lmul_left_right : 𝕜' × 𝕜' → (𝕜' →L[𝕜] 𝕜')` is a bounded bilinear map.",
    "type": "is_bounded_bilinear_map 𝕜 (λ (p : 𝕜' × 𝕜'), ⇑(⇑(continuous_linear_map.lmul_left_right 𝕜 𝕜') p.fst) p.snd)"
  },
  {
    "name": "two_pos",
    "statement": "theorem two_pos {α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 2",
    "theorem": "{α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 2",
    "args": "{α : Type u} [ordered_semiring α] [nontrivial α]",
    "doc_string": "**Alias** of zero_lt_two`.",
    "type": "0 < 2"
  },
  {
    "name": "is_submonoid.inter",
    "statement": "theorem is_submonoid.inter {M : Type u_1} [monoid M] {s₁ s₂ : set M} (is₁ : is_submonoid s₁) (is₂ : is_submonoid s₂) : is_submonoid (s₁ ∩ s₂)",
    "theorem": "{M : Type u_1} [monoid M] {s₁ s₂ : set M} (is₁ : is_submonoid s₁) (is₂ : is_submonoid s₂) : is_submonoid (s₁ ∩ s₂)",
    "args": "{M : Type u_1} [monoid M] {s₁ s₂ : set M} (is₁ : is_submonoid s₁) (is₂ : is_submonoid s₂)",
    "doc_string": "The intersection of two submonoids of a monoid `M` is a submonoid of `M`.",
    "type": "is_submonoid (s₁ ∩ s₂)"
  },
  {
    "name": "minpoly.aeval",
    "statement": "theorem minpoly.aeval (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) : ⇑(polynomial.aeval x) (minpoly A x) = 0",
    "theorem": "(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) : ⇑(polynomial.aeval x) (minpoly A x) = 0",
    "args": "(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B)",
    "doc_string": "An element is a root of its minimal polynomial.",
    "type": "⇑(polynomial.aeval x) (minpoly A x) = 0"
  },
  {
    "name": "eq_zero_of_mul_eq_self_left",
    "statement": "theorem eq_zero_of_mul_eq_self_left {M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : b * a = a) : a = 0",
    "theorem": "{M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : b * a = a) : a = 0",
    "args": "{M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : b * a = a)",
    "doc_string": " An element of a `cancel_monoid_with_zero` fixed by left multiplication by an element other than one must be zero.",
    "type": "a = 0"
  },
  {
    "name": "right.inv_le_one_iff",
    "statement": "theorem right.inv_le_one_iff {α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α}",
    "doc_string": "Uses `right` co(ntra)variant.",
    "type": "a⁻¹ ≤ 1 ↔ 1 ≤ a"
  },
  {
    "name": "finite_dimensional.finrank_zero_iff",
    "statement": "theorem finite_dimensional.finrank_zero_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V = 0 ↔ subsingleton V",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V = 0 ↔ subsingleton V",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V]",
    "doc_string": " A finite dimensional space has zero `finrank` iff it is a subsingleton. This is the `finrank` version of `dim_zero_iff`.",
    "type": "finite_dimensional.finrank K V = 0 ↔ subsingleton V"
  },
  {
    "name": "monoid_algebra.fg_of_finite_type",
    "statement": "theorem monoid_algebra.fg_of_finite_type {R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] [h : algebra.finite_type R (monoid_algebra R M)] : monoid.fg M",
    "theorem": "{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] [h : algebra.finite_type R (monoid_algebra R M)] : monoid.fg M",
    "args": "{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] [h : algebra.finite_type R (monoid_algebra R M)]",
    "doc_string": "If `monoid_algebra R M` is of finite type then `M` is finitely generated.",
    "type": "monoid.fg M"
  },
  {
    "name": "right.add_pos",
    "statement": "theorem right.add_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_pos`.",
    "type": "0 < a + b"
  },
  {
    "name": "metric.inf_dist_zero_of_mem",
    "statement": "theorem metric.inf_dist_zero_of_mem {α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (h : x ∈ s) : metric.inf_dist x s = 0",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (h : x ∈ s) : metric.inf_dist x s = 0",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (h : x ∈ s)",
    "doc_string": "The minimal distance of a point to a set containing it vanishes",
    "type": "metric.inf_dist x s = 0"
  },
  {
    "name": "is_add_regular.and_of_add_of_add",
    "statement": "theorem is_add_regular.and_of_add_of_add {R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_regular (a + b)) (ba : is_add_regular (b + a)) : is_add_regular a ∧ is_add_regular b",
    "theorem": "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_regular (a + b)) (ba : is_add_regular (b + a)) : is_add_regular a ∧ is_add_regular b",
    "args": "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_regular (a + b)) (ba : is_add_regular (b + a))",
    "doc_string": "The \"most used\" implication of `add_and_add_iff`, with split hypotheses, instead of `∧`.",
    "type": "is_add_regular a ∧ is_add_regular b"
  },
  {
    "name": "multiset.well_founded_lt",
    "statement": "theorem multiset.well_founded_lt {α : Type u_1} : well_founded has_lt.lt",
    "theorem": "{α : Type u_1} : well_founded has_lt.lt",
    "args": "{α : Type u_1}",
    "doc_string": "Another way of expressing `strong_induction_on`: the `(<)` relation is well-founded.",
    "type": "well_founded has_lt.lt"
  },
  {
    "name": "add_con.trans",
    "statement": "theorem add_con.trans {M : Type u_1} [has_add M] (c : add_con M) {x y z : M} : ⇑c x y → ⇑c y z → ⇑c x z",
    "theorem": "{M : Type u_1} [has_add M] (c : add_con M) {x y z : M} : ⇑c x y → ⇑c y z → ⇑c x z",
    "args": "{M : Type u_1} [has_add M] (c : add_con M) {x y z : M}",
    "doc_string": "Additive congruence relations are transitive.",
    "type": "⇑c x y → ⇑c y z → ⇑c x z"
  },
  {
    "name": "polynomial.C_eq_algebra_map",
    "statement": "theorem polynomial.C_eq_algebra_map {R : Type u} [comm_semiring R] (r : R) : ⇑polynomial.C r = ⇑(algebra_map R (polynomial R)) r",
    "theorem": "{R : Type u} [comm_semiring R] (r : R) : ⇑polynomial.C r = ⇑(algebra_map R (polynomial R)) r",
    "args": "{R : Type u} [comm_semiring R] (r : R)",
    "doc_string": "When we have `[comm_semiring R]`, the function `C` is the same as `algebra_map R R[X]`.  (But note that `C` is defined when `R` is not necessarily commutative, in which case `algebra_map` is not available.)",
    "type": "⇑polynomial.C r = ⇑(algebra_map R (polynomial R)) r"
  },
  {
    "name": "not_bdd_below_iff'",
    "statement": "theorem not_bdd_below_iff' {α : Type u} [preorder α] {s : set α} : ¬bdd_below s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), ¬x ≤ y",
    "theorem": "{α : Type u} [preorder α] {s : set α} : ¬bdd_below s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), ¬x ≤ y",
    "args": "{α : Type u} [preorder α] {s : set α}",
    "doc_string": " A set `s` is not bounded below if and only if for each `x` there exists `y ∈ s` such that `x` is not less than or equal to `y`. This version only assumes `preorder` structure and uses `¬(x ≤ y)`. A version for linear orders is called `not_bdd_below_iff`.",
    "type": "¬bdd_below s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), ¬x ≤ y"
  },
  {
    "name": "con.coe_mul",
    "statement": "theorem con.coe_mul {M : Type u_1} [has_mul M] {c : con M} (x y : M) : ↑(x * y) = ↑x * ↑y",
    "theorem": "{M : Type u_1} [has_mul M] {c : con M} (x y : M) : ↑(x * y) = ↑x * ↑y",
    "args": "{M : Type u_1} [has_mul M] {c : con M} (x y : M)",
    "doc_string": "The coercion to the quotient of a congruence relation commutes with multiplication (by    definition).",
    "type": "↑(x * y) = ↑x * ↑y"
  },
  {
    "name": "bernoulli'_odd_eq_zero",
    "statement": "theorem bernoulli'_odd_eq_zero {n : ℕ} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0",
    "theorem": "{n : ℕ} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0",
    "args": "{n : ℕ} (h_odd : odd n) (hlt : 1 < n)",
    "doc_string": "Odd Bernoulli numbers (greater than 1) are zero.",
    "type": "bernoulli' n = 0"
  },
  {
    "name": "sub_pos_of_lt",
    "statement": "theorem sub_pos_of_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : b < a → 0 < a - b",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : b < a → 0 < a - b",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of sub_pos`.",
    "type": "b < a → 0 < a - b"
  },
  {
    "name": "metric.inf_dist_nonneg",
    "statement": "theorem metric.inf_dist_nonneg {α : Type u} [pseudo_metric_space α] {s : set α} {x : α} : 0 ≤ metric.inf_dist x s",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} {x : α} : 0 ≤ metric.inf_dist x s",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α} {x : α}",
    "doc_string": "the minimal distance is always nonnegative",
    "type": "0 ≤ metric.inf_dist x s"
  },
  {
    "name": "polish_space.exists_nat_nat_continuous_surjective",
    "statement": "theorem polish_space.exists_nat_nat_continuous_surjective (α : Type u_1) [topological_space α] [polish_space α] [nonempty α] : ∃ (f : (ℕ → ℕ) → α), continuous f ∧ function.surjective f",
    "theorem": "(α : Type u_1) [topological_space α] [polish_space α] [nonempty α] : ∃ (f : (ℕ → ℕ) → α), continuous f ∧ function.surjective f",
    "args": "(α : Type u_1) [topological_space α] [polish_space α] [nonempty α]",
    "doc_string": "Any nonempty Polish space is the continuous image of the fundamental space `ℕ → ℕ`.",
    "type": "∃ (f : (ℕ → ℕ) → α), continuous f ∧ function.surjective f"
  },
  {
    "name": "polynomial.mul_eq_sum_sum",
    "statement": "theorem polynomial.mul_eq_sum_sum {R : Type u} [semiring R] {p q : polynomial R} : p * q = p.support.sum (λ (i : ℕ), q.sum (λ (j : ℕ) (a : R), ⇑(polynomial.monomial (i + j)) (p.coeff i * a)))",
    "theorem": "{R : Type u} [semiring R] {p q : polynomial R} : p * q = p.support.sum (λ (i : ℕ), q.sum (λ (j : ℕ) (a : R), ⇑(polynomial.monomial (i + j)) (p.coeff i * a)))",
    "args": "{R : Type u} [semiring R] {p q : polynomial R}",
    "doc_string": "Expressing the product of two polynomials as a double sum.",
    "type": "p * q = p.support.sum (λ (i : ℕ), q.sum (λ (j : ℕ) (a : R), ⇑(polynomial.monomial (i + j)) (p.coeff i * a)))"
  },
  {
    "name": "int.not_is_field",
    "statement": "theorem int.not_is_field  : ¬is_field ℤ",
    "theorem": " : ¬is_field ℤ",
    "args": "",
    "doc_string": "`ℤ` with its usual ring structure is not a field.",
    "type": "¬is_field ℤ"
  },
  {
    "name": "category_theory.is_subterminal_of_mono_is_terminal_from",
    "statement": "theorem category_theory.is_subterminal_of_mono_is_terminal_from {C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A",
    "theorem": "{C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A",
    "args": "{C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)]",
    "doc_string": "If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_is_terminal_from`.",
    "type": "category_theory.is_subterminal A"
  },
  {
    "name": "left.one_lt_mul_of_lt_of_le",
    "statement": "theorem left.one_lt_mul_of_lt_of_le {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul_of_lt_of_le`.",
    "type": "1 < a * b"
  },
  {
    "name": "vector.last_def",
    "statement": "theorem vector.last_def {n : ℕ} {α : Type u_1} {v : vector α (n + 1)} : v.last = v.nth (fin.last n)",
    "theorem": "{n : ℕ} {α : Type u_1} {v : vector α (n + 1)} : v.last = v.nth (fin.last n)",
    "args": "{n : ℕ} {α : Type u_1} {v : vector α (n + 1)}",
    "doc_string": "The last element of a `vector`, given that the vector is at least one element.",
    "type": "v.last = v.nth (fin.last n)"
  },
  {
    "name": "list.Ico.trichotomy",
    "statement": "theorem list.Ico.trichotomy (n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b",
    "theorem": "(n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b",
    "args": "(n a b : ℕ)",
    "doc_string": "For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n ≥ b 3. n ∈ Ico a b",
    "type": "n < a ∨ b ≤ n ∨ n ∈ list.Ico a b"
  },
  {
    "name": "pseudo_metric_space.ext",
    "statement": "theorem pseudo_metric_space.ext {α : Type u_1} {m m' : pseudo_metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'",
    "theorem": "{α : Type u_1} {m m' : pseudo_metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'",
    "args": "{α : Type u_1} {m m' : pseudo_metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist)",
    "doc_string": "Two pseudo metric space structures with the same distance function coincide.",
    "type": "m = m'"
  },
  {
    "name": "category_theory.over.construct_products.over_finite_products_of_finite_wide_pullbacks",
    "statement": "theorem category_theory.over.construct_products.over_finite_products_of_finite_wide_pullbacks {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C} : category_theory.limits.has_finite_products (category_theory.over B)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C} : category_theory.limits.has_finite_products (category_theory.over B)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C}",
    "doc_string": "Given all finite wide pullbacks in `C`, construct finite products in `C/B`.",
    "type": "category_theory.limits.has_finite_products (category_theory.over B)"
  },
  {
    "name": "add_con.le_def",
    "statement": "theorem add_con.le_def {M : Type u_1} [has_add M] {c d : add_con M} : c ≤ d ↔ ∀ {x y : M}, ⇑c x y → ⇑d x y",
    "theorem": "{M : Type u_1} [has_add M] {c d : add_con M} : c ≤ d ↔ ∀ {x y : M}, ⇑c x y → ⇑d x y",
    "args": "{M : Type u_1} [has_add M] {c d : add_con M}",
    "doc_string": "Definition of `≤` for additive congruence relations.",
    "type": "c ≤ d ↔ ∀ {x y : M}, ⇑c x y → ⇑d x y"
  },
  {
    "name": "is_monoid_hom.id",
    "statement": "theorem is_monoid_hom.id {α : Type u} [mul_one_class α] : is_monoid_hom id",
    "theorem": "{α : Type u} [mul_one_class α] : is_monoid_hom id",
    "args": "{α : Type u} [mul_one_class α]",
    "doc_string": "The identity map is a monoid homomorphism.",
    "type": "is_monoid_hom id"
  },
  {
    "name": "laurent_polynomial.C_eq_algebra_map",
    "statement": "theorem laurent_polynomial.C_eq_algebra_map {R : Type u_1} [comm_semiring R] (r : R) : ⇑laurent_polynomial.C r = ⇑(algebra_map R (laurent_polynomial R)) r",
    "theorem": "{R : Type u_1} [comm_semiring R] (r : R) : ⇑laurent_polynomial.C r = ⇑(algebra_map R (laurent_polynomial R)) r",
    "args": "{R : Type u_1} [comm_semiring R] (r : R)",
    "doc_string": "When we have `[comm_semiring R]`, the function `C` is the same as `algebra_map R R[T;T⁻¹]`. (But note that `C` is defined when `R` is not necessarily commutative, in which case `algebra_map` is not available.)",
    "type": "⇑laurent_polynomial.C r = ⇑(algebra_map R (laurent_polynomial R)) r"
  },
  {
    "name": "left.mul_le_one",
    "statement": "theorem left.mul_le_one {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.mul_le_one`.",
    "type": "a * b ≤ 1"
  },
  {
    "name": "nat.prime.sq_add_sq",
    "statement": "theorem nat.prime.sq_add_sq {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p",
    "theorem": "{p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p",
    "args": "{p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1)",
    "doc_string": " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.",
    "type": "∃ (a b : ℕ), a ^ 2 + b ^ 2 = p"
  },
  {
    "name": "polynomial.map_alg_eq_map",
    "statement": "theorem polynomial.map_alg_eq_map {R : Type u} [comm_semiring R] {S : Type v} [semiring S] [algebra R S] (p : polynomial R) : ⇑(polynomial.map_alg R S) p = polynomial.map (algebra_map R S) p",
    "theorem": "{R : Type u} [comm_semiring R] {S : Type v} [semiring S] [algebra R S] (p : polynomial R) : ⇑(polynomial.map_alg R S) p = polynomial.map (algebra_map R S) p",
    "args": "{R : Type u} [comm_semiring R] {S : Type v} [semiring S] [algebra R S] (p : polynomial R)",
    "doc_string": "`map_alg` is the morphism induced by `R → S`.",
    "type": "⇑(polynomial.map_alg R S) p = polynomial.map (algebra_map R S) p"
  },
  {
    "name": "commute.symm",
    "statement": "theorem commute.symm {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a",
    "theorem": "{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a",
    "args": "{S : Type u_1} [has_mul S] {a b : S} (h : commute a b)",
    "doc_string": "If `a` commutes with `b`, then `b` commutes with `a`.",
    "type": "commute b a"
  },
  {
    "name": "measure_theory.is_clopenable_iff_measurable_set",
    "statement": "theorem measure_theory.is_clopenable_iff_measurable_set {γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {s : set γ} : polish_space.is_clopenable s ↔ measurable_set s",
    "theorem": "{γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {s : set γ} : polish_space.is_clopenable s ↔ measurable_set s",
    "args": "{γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {s : set γ}",
    "doc_string": "In a Polish space, a set is clopenable if and only if it is Borel-measurable.",
    "type": "polish_space.is_clopenable s ↔ measurable_set s"
  },
  {
    "name": "pos_of_neg_neg",
    "statement": "theorem pos_of_neg_neg {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 → 0 < a",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 → 0 < a",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α}",
    "doc_string": "**Alias** of the forward direction of left.inv_lt_one_iff`.",
    "type": "-a < 0 → 0 < a"
  },
  {
    "name": "monoid.subset_closure",
    "statement": "theorem monoid.subset_closure {M : Type u_1} [monoid M] {s : set M} : s ⊆ monoid.closure s",
    "theorem": "{M : Type u_1} [monoid M] {s : set M} : s ⊆ monoid.closure s",
    "args": "{M : Type u_1} [monoid M] {s : set M}",
    "doc_string": "A subset of a monoid is contained in the submonoid it generates.",
    "type": "s ⊆ monoid.closure s"
  },
  {
    "name": "category_theory.limits.colimits_from_coequalizers_and_coproducts",
    "statement": "theorem category_theory.limits.colimits_from_coequalizers_and_coproducts {C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimits C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimits C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C]",
    "doc_string": "Any category with coproducts and coequalizers has all colimits.  See <https://stacks.math.columbia.edu/tag/002P>.",
    "type": "category_theory.limits.has_colimits C"
  },
  {
    "name": "bdd_above_union",
    "statement": "theorem bdd_above_union {γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t",
    "theorem": "{γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t",
    "args": "{γ : Type w} [semilattice_sup γ] {s t : set γ}",
    "doc_string": "The union of two sets is bounded above if and only if each of the sets is.",
    "type": "bdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t"
  },
  {
    "name": "one_le_of_inv_le_one",
    "statement": "theorem one_le_of_inv_le_one {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 → 1 ≤ a",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 → 1 ≤ a",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α}",
    "doc_string": "**Alias** of the forward direction of left.inv_le_one_iff`.",
    "type": "a⁻¹ ≤ 1 → 1 ≤ a"
  },
  {
    "name": "list.eq_iff_join_eq",
    "statement": "theorem list.eq_iff_join_eq {α : Type u_1} (L L' : list (list α)) : L = L' ↔ L.join = L'.join ∧ list.map list.length L = list.map list.length L'",
    "theorem": "{α : Type u_1} (L L' : list (list α)) : L = L' ↔ L.join = L'.join ∧ list.map list.length L = list.map list.length L'",
    "args": "{α : Type u_1} (L L' : list (list α))",
    "doc_string": " Two lists of sublists are equal iff their joins coincide, as well as the lengths of the sublists.",
    "type": "L = L' ↔ L.join = L'.join ∧ list.map list.length L = list.map list.length L'"
  },
  {
    "name": "is_max_on.dual",
    "statement": "theorem is_max_on.dual {α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_max_on f s a → is_min_on (⇑order_dual.to_dual ∘ f) s a",
    "theorem": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_max_on f s a → is_min_on (⇑order_dual.to_dual ∘ f) s a",
    "args": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α}",
    "doc_string": "**Alias** of the reverse direction of is_min_on_dual_iff`.",
    "type": "is_max_on f s a → is_min_on (⇑order_dual.to_dual ∘ f) s a"
  },
  {
    "name": "uniform_space.completion.dist_eq",
    "statement": "theorem uniform_space.completion.dist_eq {α : Type u} [pseudo_metric_space α] (x y : α) : has_dist.dist ↑x ↑y = has_dist.dist x y",
    "theorem": "{α : Type u} [pseudo_metric_space α] (x y : α) : has_dist.dist ↑x ↑y = has_dist.dist x y",
    "args": "{α : Type u} [pseudo_metric_space α] (x y : α)",
    "doc_string": "The new distance is an extension of the original distance.",
    "type": "has_dist.dist ↑x ↑y = has_dist.dist x y"
  },
  {
    "name": "well_founded.game_add",
    "statement": "theorem well_founded.game_add {α : Type u_1} {β : Type u_2} {rα : α → α → Prop} {rβ : β → β → Prop} (hα : well_founded rα) (hβ : well_founded rβ) : well_founded (relation.game_add rα rβ)",
    "theorem": "{α : Type u_1} {β : Type u_2} {rα : α → α → Prop} {rβ : β → β → Prop} (hα : well_founded rα) (hβ : well_founded rβ) : well_founded (relation.game_add rα rβ)",
    "args": "{α : Type u_1} {β : Type u_2} {rα : α → α → Prop} {rβ : β → β → Prop} (hα : well_founded rα) (hβ : well_founded rβ)",
    "doc_string": "The sum of two well-founded games is well-founded.",
    "type": "well_founded (relation.game_add rα rβ)"
  },
  {
    "name": "polynomial.prod_cyclotomic_eq_X_pow_sub_one",
    "statement": "theorem polynomial.prod_cyclotomic_eq_X_pow_sub_one {n : ℕ} (hpos : 0 < n) (R : Type u_1) [comm_ring R] : n.divisors.prod (λ (i : ℕ), polynomial.cyclotomic i R) = polynomial.X ^ n - 1",
    "theorem": "{n : ℕ} (hpos : 0 < n) (R : Type u_1) [comm_ring R] : n.divisors.prod (λ (i : ℕ), polynomial.cyclotomic i R) = polynomial.X ^ n - 1",
    "args": "{n : ℕ} (hpos : 0 < n) (R : Type u_1) [comm_ring R]",
    "doc_string": "`∏ i in nat.divisors n, cyclotomic i R = X ^ n - 1`.",
    "type": "n.divisors.prod (λ (i : ℕ), polynomial.cyclotomic i R) = polynomial.X ^ n - 1"
  },
  {
    "name": "fin.tail_init_eq_init_tail",
    "statement": "theorem fin.tail_init_eq_init_tail {n : ℕ} {β : Type u_1} (q : fin (n + 2) → β) : fin.tail (fin.init q) = fin.init (fin.tail q)",
    "theorem": "{n : ℕ} {β : Type u_1} (q : fin (n + 2) → β) : fin.tail (fin.init q) = fin.init (fin.tail q)",
    "args": "{n : ℕ} {β : Type u_1} (q : fin (n + 2) → β)",
    "doc_string": " `tail` and `init` commute. We state this lemma in a non-dependent setting, as otherwise it would involve a cast to convince Lean that the two types are equal, making it harder to use.",
    "type": "fin.tail (fin.init q) = fin.init (fin.tail q)"
  },
  {
    "name": "has_deriv_at_exp_zero",
    "statement": "theorem has_deriv_at_exp_zero {𝕂 : Type u_1} [is_R_or_C 𝕂] : has_deriv_at (exp 𝕂) 1 0",
    "theorem": "{𝕂 : Type u_1} [is_R_or_C 𝕂] : has_deriv_at (exp 𝕂) 1 0",
    "args": "{𝕂 : Type u_1} [is_R_or_C 𝕂]",
    "doc_string": "The exponential map in `𝕂 = ℝ` or `𝕂 = ℂ` has derivative `1` at zero.",
    "type": "has_deriv_at (exp 𝕂) 1 0"
  },
  {
    "name": "cauchy_seq_tendsto_of_complete",
    "statement": "theorem cauchy_seq_tendsto_of_complete {α : Type u} {β : Type v} [uniform_space α] [semilattice_sup β] [complete_space α] {u : β → α} (H : cauchy_seq u) : ∃ (x : α), filter.tendsto u filter.at_top (nhds x)",
    "theorem": "{α : Type u} {β : Type v} [uniform_space α] [semilattice_sup β] [complete_space α] {u : β → α} (H : cauchy_seq u) : ∃ (x : α), filter.tendsto u filter.at_top (nhds x)",
    "args": "{α : Type u} {β : Type v} [uniform_space α] [semilattice_sup β] [complete_space α] {u : β → α} (H : cauchy_seq u)",
    "doc_string": "A Cauchy sequence in a complete space converges",
    "type": "∃ (x : α), filter.tendsto u filter.at_top (nhds x)"
  },
  {
    "name": "add_commute.add_right",
    "statement": "theorem add_commute.add_right {S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c)",
    "theorem": "{S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c)",
    "args": "{S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c)",
    "doc_string": "If `a` commutes with both `b` and `c`, then it commutes with their sum.",
    "type": "add_commute a (b + c)"
  },
  {
    "name": "real.sinh_surjective",
    "statement": "theorem real.sinh_surjective  : function.surjective real.sinh",
    "theorem": " : function.surjective real.sinh",
    "args": "",
    "doc_string": "`sinh` is surjective, `∀ b, ∃ a, sinh a = b`. In this case, we use `a = arsinh b`.",
    "type": "function.surjective real.sinh"
  },
  {
    "name": "tactic.ring_exp.prod_congr",
    "statement": "theorem tactic.ring_exp.prod_congr {α : Type u} [comm_semiring α] {p p' ps ps' : α} : p = p' → ps = ps' → p * ps = p' * ps'",
    "theorem": "{α : Type u} [comm_semiring α] {p p' ps ps' : α} : p = p' → ps = ps' → p * ps = p' * ps'",
    "args": "{α : Type u} [comm_semiring α] {p p' ps ps' : α}",
    "doc_string": "Congruence lemma for constructing `ex.prod`.",
    "type": "p = p' → ps = ps' → p * ps = p' * ps'"
  },
  {
    "name": "nat.cast_le_pow_sub_div_sub",
    "statement": "theorem nat.cast_le_pow_sub_div_sub {K : Type u_1} [linear_ordered_field K] {a : K} (H : 1 < a) (n : ℕ) : ↑n ≤ (a ^ n - 1) / (a - 1)",
    "theorem": "{K : Type u_1} [linear_ordered_field K] {a : K} (H : 1 < a) (n : ℕ) : ↑n ≤ (a ^ n - 1) / (a - 1)",
    "args": "{K : Type u_1} [linear_ordered_field K] {a : K} (H : 1 < a) (n : ℕ)",
    "doc_string": "Bernoulli's inequality reformulated to estimate `(n : K)`.",
    "type": "↑n ≤ (a ^ n - 1) / (a - 1)"
  },
  {
    "name": "sub_nonpos_of_le",
    "statement": "theorem sub_nonpos_of_le {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a ≤ b → a - b ≤ 0",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a ≤ b → a - b ≤ 0",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of sub_nonpos`.",
    "type": "a ≤ b → a - b ≤ 0"
  },
  {
    "name": "fintype.card_of_is_empty",
    "statement": "theorem fintype.card_of_is_empty {α : Type u_1} [is_empty α] : fintype.card α = 0",
    "theorem": "{α : Type u_1} [is_empty α] : fintype.card α = 0",
    "args": "{α : Type u_1} [is_empty α]",
    "doc_string": " Note: this lemma is specifically about `fintype.of_is_empty`. For a statement about arbitrary `fintype` instances, use `fintype.card_eq_zero_iff`.",
    "type": "fintype.card α = 0"
  },
  {
    "name": "card_class_group_eq_one",
    "statement": "theorem card_class_group_eq_one {R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype.card (class_group R K) = 1",
    "theorem": "{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype.card (class_group R K) = 1",
    "args": "{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R]",
    "doc_string": "The class number of a principal ideal domain is `1`.",
    "type": "fintype.card (class_group R K) = 1"
  },
  {
    "name": "con.zpow",
    "statement": "theorem con.zpow {M : Type u_1} [group M] (c : con M) (n : ℤ) {w x : M} : ⇑c w x → ⇑c (w ^ n) (x ^ n)",
    "theorem": "{M : Type u_1} [group M] (c : con M) (n : ℤ) {w x : M} : ⇑c w x → ⇑c (w ^ n) (x ^ n)",
    "args": "{M : Type u_1} [group M] (c : con M) (n : ℤ) {w x : M}",
    "doc_string": "Multiplicative congruence relations preserve integer powers.",
    "type": "⇑c w x → ⇑c (w ^ n) (x ^ n)"
  },
  {
    "name": "neg_ray_of_ne_zero",
    "statement": "theorem neg_ray_of_ne_zero (R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (v : M) (h : v ≠ 0) : -ray_of_ne_zero R v h = ray_of_ne_zero R (-v) _",
    "theorem": "(R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (v : M) (h : v ≠ 0) : -ray_of_ne_zero R v h = ray_of_ne_zero R (-v) _",
    "args": "(R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (v : M) (h : v ≠ 0)",
    "doc_string": "The ray given by the negation of a nonzero vector.",
    "type": "-ray_of_ne_zero R v h = ray_of_ne_zero R (-v) _"
  },
  {
    "name": "char.quadratic_char_one_iff_is_square",
    "statement": "theorem char.quadratic_char_one_iff_is_square {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a = 1 ↔ is_square a",
    "theorem": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a = 1 ↔ is_square a",
    "args": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0)",
    "doc_string": "For nonzero `a : F`, `quadratic_char F a = 1 ↔ is_square a`.",
    "type": "char.quadratic_char F a = 1 ↔ is_square a"
  },
  {
    "name": "is_add_unit.is_add_regular",
    "statement": "theorem is_add_unit.is_add_regular {R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a) : is_add_regular a",
    "theorem": "{R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a) : is_add_regular a",
    "args": "{R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a)",
    "doc_string": "An additive unit in an additive monoid is add-regular.",
    "type": "is_add_regular a"
  },
  {
    "name": "is_ring_hom.map_zero",
    "statement": "theorem is_ring_hom.map_zero {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f) : f 0 = 0",
    "theorem": "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f) : f 0 = 0",
    "args": "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f)",
    "doc_string": "Ring homomorphisms map zero to zero.",
    "type": "f 0 = 0"
  },
  {
    "name": "matrix.cons_val_one",
    "statement": "theorem matrix.cons_val_one {α : Type u} {m : ℕ} (x : α) (u : fin m.succ → α) : matrix.vec_cons x u 1 = matrix.vec_head u",
    "theorem": "{α : Type u} {m : ℕ} (x : α) (u : fin m.succ → α) : matrix.vec_cons x u 1 = matrix.vec_head u",
    "args": "{α : Type u} {m : ℕ} (x : α) (u : fin m.succ → α)",
    "doc_string": "`![a, b, ...] 1` is equal to `b`.   The simplifier needs a special lemma for length `≥ 2`, in addition to  `cons_val_succ`, because `1 : fin 1 = 0 : fin 1`.",
    "type": "matrix.vec_cons x u 1 = matrix.vec_head u"
  },
  {
    "name": "function.injective.nontrivial",
    "statement": "theorem function.injective.nontrivial {α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) : nontrivial β",
    "theorem": "{α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) : nontrivial β",
    "args": "{α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f)",
    "doc_string": "Pushforward a `nontrivial` instance along an injective function.",
    "type": "nontrivial β"
  },
  {
    "name": "nat.choose_le_middle",
    "statement": "theorem nat.choose_le_middle (r n : ℕ) : n.choose r ≤ n.choose (n / 2)",
    "theorem": "(r n : ℕ) : n.choose r ≤ n.choose (n / 2)",
    "args": "(r n : ℕ)",
    "doc_string": "`choose n r` is maximised when `r` is `n/2`.",
    "type": "n.choose r ≤ n.choose (n / 2)"
  },
  {
    "name": "local_ring.of_nonunits_add",
    "statement": "theorem local_ring.of_nonunits_add {R : Type u} [comm_semiring R] [nontrivial R] (h : ∀ (a b : R), a ∈ nonunits R → b ∈ nonunits R → a + b ∈ nonunits R) : local_ring R",
    "theorem": "{R : Type u} [comm_semiring R] [nontrivial R] (h : ∀ (a b : R), a ∈ nonunits R → b ∈ nonunits R → a + b ∈ nonunits R) : local_ring R",
    "args": "{R : Type u} [comm_semiring R] [nontrivial R] (h : ∀ (a b : R), a ∈ nonunits R → b ∈ nonunits R → a + b ∈ nonunits R)",
    "doc_string": "A semiring is local if it is nontrivial and the set of nonunits is closed under the addition.",
    "type": "local_ring R"
  },
  {
    "name": "is_add_monoid_hom.id",
    "statement": "theorem is_add_monoid_hom.id {α : Type u} [add_zero_class α] : is_add_monoid_hom id",
    "theorem": "{α : Type u} [add_zero_class α] : is_add_monoid_hom id",
    "args": "{α : Type u} [add_zero_class α]",
    "doc_string": "The identity map is an additive monoid homomorphism.",
    "type": "is_add_monoid_hom id"
  },
  {
    "name": "function.injective.nat_tendsto_at_top",
    "statement": "theorem function.injective.nat_tendsto_at_top {f : ℕ → ℕ} (hf : function.injective f) : filter.tendsto f filter.at_top filter.at_top",
    "theorem": "{f : ℕ → ℕ} (hf : function.injective f) : filter.tendsto f filter.at_top filter.at_top",
    "args": "{f : ℕ → ℕ} (hf : function.injective f)",
    "doc_string": "An injective sequence `f : ℕ → ℕ` tends to infinity at infinity.",
    "type": "filter.tendsto f filter.at_top filter.at_top"
  },
  {
    "name": "module.free.rank_eq_card_choose_basis_index",
    "statement": "theorem module.free.rank_eq_card_choose_basis_index (R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] : module.rank R M = cardinal.mk (module.free.choose_basis_index R M)",
    "theorem": "(R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] : module.rank R M = cardinal.mk (module.free.choose_basis_index R M)",
    "args": "(R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M]",
    "doc_string": "The rank of a free module `M` over `R` is the cardinality of `choose_basis_index R M`.",
    "type": "module.rank R M = cardinal.mk (module.free.choose_basis_index R M)"
  },
  {
    "name": "finite_dimensional.proper",
    "statement": "theorem finite_dimensional.proper (𝕜 : Type u) [nondiscrete_normed_field 𝕜] (E : Type v) [normed_group E] [normed_space 𝕜 E] [proper_space 𝕜] [finite_dimensional 𝕜 E] : proper_space E",
    "theorem": "(𝕜 : Type u) [nondiscrete_normed_field 𝕜] (E : Type v) [normed_group E] [normed_space 𝕜 E] [proper_space 𝕜] [finite_dimensional 𝕜 E] : proper_space E",
    "args": "(𝕜 : Type u) [nondiscrete_normed_field 𝕜] (E : Type v) [normed_group E] [normed_space 𝕜 E] [proper_space 𝕜] [finite_dimensional 𝕜 E]",
    "doc_string": " Any finite-dimensional vector space over a proper field is proper. We do not register this as an instance to avoid an instance loop when trying to prove the properness of `𝕜`, and the search for `𝕜` as an unknown metavariable. Declare the instance explicitly when needed.",
    "type": "proper_space E"
  },
  {
    "name": "is_add_regular_zero",
    "statement": "theorem is_add_regular_zero {R : Type u_1} [add_zero_class R] : is_add_regular 0",
    "theorem": "{R : Type u_1} [add_zero_class R] : is_add_regular 0",
    "args": "{R : Type u_1} [add_zero_class R]",
    "doc_string": "If adding `0` on either side is the identity, `0` is regular.",
    "type": "is_add_regular 0"
  },
  {
    "name": "not_is_regular_zero",
    "statement": "theorem not_is_regular_zero {R : Type u_1} [mul_zero_class R] [nontrivial R] : ¬is_regular 0",
    "theorem": "{R : Type u_1} [mul_zero_class R] [nontrivial R] : ¬is_regular 0",
    "args": "{R : Type u_1} [mul_zero_class R] [nontrivial R]",
    "doc_string": "In a non-trivial ring, the element `0` is not regular -- with typeclasses.",
    "type": "¬is_regular 0"
  },
  {
    "name": "left.add_pos_of_nonneg_of_pos",
    "statement": "theorem left.add_pos_of_nonneg_of_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_pos_of_nonneg_of_pos`.",
    "type": "0 < a + b"
  },
  {
    "name": "implies.trans",
    "statement": "theorem implies.trans {p q r : Prop} (h₁ : implies p q) (h₂ : implies q r) : implies p r",
    "theorem": "{p q r : Prop} (h₁ : implies p q) (h₂ : implies q r) : implies p r",
    "args": "{p q r : Prop} (h₁ : implies p q) (h₂ : implies q r)",
    "doc_string": "Implication `→` is transitive. If `P → Q` and `Q → R` then `P → R`.",
    "type": "implies p r"
  },
  {
    "name": "has_le.le.lt_or_eq_dec",
    "statement": "theorem has_le.le.lt_or_eq_dec {α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b) : a < b ∨ a = b",
    "theorem": "{α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b) : a < b ∨ a = b",
    "args": "{α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b)",
    "doc_string": "**Alias** of decidable.lt_or_eq_of_le`.",
    "type": "a < b ∨ a = b"
  },
  {
    "name": "lt_of_sub_neg",
    "statement": "theorem lt_of_sub_neg {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a - b < 0 → a < b",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a - b < 0 → a < b",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α}",
    "doc_string": "**Alias** of the forward direction of sub_neg`.",
    "type": "a - b < 0 → a < b"
  },
  {
    "name": "finset.centroid_weights_apply",
    "statement": "theorem finset.centroid_weights_apply (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) (i : ι) : finset.centroid_weights k s i = (↑(s.card))⁻¹",
    "theorem": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) (i : ι) : finset.centroid_weights k s i = (↑(s.card))⁻¹",
    "args": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) (i : ι)",
    "doc_string": "`centroid_weights` at any point.",
    "type": "finset.centroid_weights k s i = (↑(s.card))⁻¹"
  },
  {
    "name": "has_le.le.trans_eq",
    "statement": "theorem has_le.le.trans_eq {α : Type u} [preorder α] {a b c : α} (hab : a ≤ b) (hbc : b = c) : a ≤ c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} (hab : a ≤ b) (hbc : b = c) : a ≤ c",
    "args": "{α : Type u} [preorder α] {a b c : α} (hab : a ≤ b) (hbc : b = c)",
    "doc_string": "**Alias** of le_of_le_of_eq`.",
    "type": "a ≤ c"
  },
  {
    "name": "int.exists_lt_and_lt_iff_not_dvd",
    "statement": "theorem int.exists_lt_and_lt_iff_not_dvd (m : ℤ) {n : ℤ} (hn : 0 < n) : (∃ (k : ℤ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m",
    "theorem": "(m : ℤ) {n : ℤ} (hn : 0 < n) : (∃ (k : ℤ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m",
    "args": "(m : ℤ) {n : ℤ} (hn : 0 < n)",
    "doc_string": "If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`  for some `k`.",
    "type": "(∃ (k : ℤ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m"
  },
  {
    "name": "category_theory.limits.has_binary_biproduct.of_has_binary_coproduct",
    "statement": "theorem category_theory.limits.has_binary_biproduct.of_has_binary_coproduct {C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.has_binary_biproduct X Y",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.has_binary_biproduct X Y",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y]",
    "doc_string": "In a preadditive category, if the coproduct of `X` and `Y` exists, then the    binary biproduct of `X` and `Y` exists.",
    "type": "category_theory.limits.has_binary_biproduct X Y"
  },
  {
    "name": "category_theory.limits.has_binary_coproducts_of_has_colimit_pair",
    "statement": "theorem category_theory.limits.has_binary_coproducts_of_has_colimit_pair (C : Type u) [category_theory.category C] [∀ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_coproducts C",
    "theorem": "(C : Type u) [category_theory.category C] [∀ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_coproducts C",
    "args": "(C : Type u) [category_theory.category C] [∀ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)]",
    "doc_string": "If `C` has all colimits of diagrams `pair X Y`, then it has all binary coproducts",
    "type": "category_theory.limits.has_binary_coproducts C"
  },
  {
    "name": "quaternion_group.order_of_xa",
    "statement": "theorem quaternion_group.order_of_xa {n : ℕ} [hpos : fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.xa i) = 4",
    "theorem": "{n : ℕ} [hpos : fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.xa i) = 4",
    "args": "{n : ℕ} [hpos : fact (0 < n)] (i : zmod (2 * n))",
    "doc_string": "If `0 < n`, then `xa i` has order 4.",
    "type": "order_of (quaternion_group.xa i) = 4"
  },
  {
    "name": "is_add_regular_add_iff",
    "statement": "theorem is_add_regular_add_iff {R : Type u_1} {a b : R} [add_comm_semigroup R] : is_add_regular (a + b) ↔ is_add_regular a ∧ is_add_regular b",
    "theorem": "{R : Type u_1} {a b : R} [add_comm_semigroup R] : is_add_regular (a + b) ↔ is_add_regular a ∧ is_add_regular b",
    "args": "{R : Type u_1} {a b : R} [add_comm_semigroup R]",
    "doc_string": "A sum is add-regular if and only if the summands are.",
    "type": "is_add_regular (a + b) ↔ is_add_regular a ∧ is_add_regular b"
  },
  {
    "name": "left.one_lt_mul_of_le_of_lt",
    "statement": "theorem left.one_lt_mul_of_le_of_lt {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul_of_le_of_lt`.",
    "type": "1 < a * b"
  },
  {
    "name": "function.is_fixed_pt.left_of_comp",
    "statement": "theorem function.is_fixed_pt.left_of_comp {α : Type u} {f g : α → α} {x : α} (hfg : function.is_fixed_pt (f ∘ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x",
    "theorem": "{α : Type u} {f g : α → α} {x : α} (hfg : function.is_fixed_pt (f ∘ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x",
    "args": "{α : Type u} {f g : α → α} {x : α} (hfg : function.is_fixed_pt (f ∘ g) x) (hg : function.is_fixed_pt g x)",
    "doc_string": "If `x` is a fixed point of `f ∘ g` and `g`, then it is a fixed point of `f`.",
    "type": "function.is_fixed_pt f x"
  },
  {
    "name": "free_group.reduce.eq_of_red",
    "statement": "theorem free_group.reduce.eq_of_red {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂) : free_group.reduce L₁ = free_group.reduce L₂",
    "theorem": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂) : free_group.reduce L₁ = free_group.reduce L₂",
    "args": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂)",
    "doc_string": " If a word reduces to another word, then they have a common maximal reduction.",
    "type": "free_group.reduce L₁ = free_group.reduce L₂"
  },
  {
    "name": "nat.dvd_left_iff_eq",
    "statement": "theorem nat.dvd_left_iff_eq {m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n",
    "theorem": "{m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n",
    "args": "{m n : ℕ}",
    "doc_string": "Two natural numbers are equal if and only if the have the same divisors.",
    "type": "(∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n"
  },
  {
    "name": "embedding.metrizable_space",
    "statement": "theorem embedding.metrizable_space {X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.metrizable_space Y] {f : X → Y} (hf : embedding f) : topological_space.metrizable_space X",
    "theorem": "{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.metrizable_space Y] {f : X → Y} (hf : embedding f) : topological_space.metrizable_space X",
    "args": "{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.metrizable_space Y] {f : X → Y} (hf : embedding f)",
    "doc_string": " Given an embedding of a topological space into a metrizable space, the source space is also metrizable.",
    "type": "topological_space.metrizable_space X"
  },
  {
    "name": "vector.reverse_nth_zero",
    "statement": "theorem vector.reverse_nth_zero {n : ℕ} {α : Type u_1} {v : vector α (n + 1)} : v.reverse.head = v.last",
    "theorem": "{n : ℕ} {α : Type u_1} {v : vector α (n + 1)} : v.reverse.head = v.last",
    "args": "{n : ℕ} {α : Type u_1} {v : vector α (n + 1)}",
    "doc_string": "The `last` element of a vector is the `head` of the `reverse` vector.",
    "type": "v.reverse.head = v.last"
  },
  {
    "name": "has_le.le.trans",
    "statement": "theorem has_le.le.trans {α : Type u} [preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of le_trans`.",
    "type": "a ≤ b → b ≤ c → a ≤ c"
  },
  {
    "name": "is_add_group_hom.id",
    "statement": "theorem is_add_group_hom.id {α : Type u} [add_group α] : is_add_group_hom id",
    "theorem": "{α : Type u} [add_group α] : is_add_group_hom id",
    "args": "{α : Type u} [add_group α]",
    "doc_string": "The identity is an additive group homomorphism.",
    "type": "is_add_group_hom id"
  },
  {
    "name": "ordered_semiring.to_char_zero",
    "statement": "theorem ordered_semiring.to_char_zero {R : Type u_1} [ordered_semiring R] [nontrivial R] : char_zero R",
    "theorem": "{R : Type u_1} [ordered_semiring R] [nontrivial R] : char_zero R",
    "args": "{R : Type u_1} [ordered_semiring R] [nontrivial R]",
    "doc_string": " Note this is not an instance as `char_zero` implies `nontrivial`, and this would risk forming a loop.",
    "type": "char_zero R"
  },
  {
    "name": "zero_eq_mul",
    "statement": "theorem zero_eq_mul {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : 0 = a * b ↔ a = 0 ∨ b = 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : 0 = a * b ↔ a = 0 ∨ b = 0",
    "args": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀}",
    "doc_string": " If `α` has no zero divisors, then the product of two elements equals zero iff one of them equals zero.",
    "type": "0 = a * b ↔ a = 0 ∨ b = 0"
  },
  {
    "name": "dense_inducing_pure",
    "statement": "theorem dense_inducing_pure {α : Type u} : dense_inducing has_pure.pure",
    "theorem": "{α : Type u} : dense_inducing has_pure.pure",
    "args": "{α : Type u}",
    "doc_string": "`pure : α → ultrafilter α` defines a dense inducing of `α` in `ultrafilter α`.",
    "type": "dense_inducing has_pure.pure"
  },
  {
    "name": "exp_neg_inv_glue.f_aux_zero_eq",
    "statement": "theorem exp_neg_inv_glue.f_aux_zero_eq  : exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue",
    "theorem": " : exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue",
    "args": "",
    "doc_string": "The `0`-th auxiliary function `f_aux 0` coincides with `exp_neg_inv_glue`, by definition.",
    "type": "exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue"
  },
  {
    "name": "is_ring_hom.map_neg",
    "statement": "theorem is_ring_hom.map_neg {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x : α} (hf : is_ring_hom f) : f (-x) = -f x",
    "theorem": "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x : α} (hf : is_ring_hom f) : f (-x) = -f x",
    "args": "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x : α} (hf : is_ring_hom f)",
    "doc_string": "Ring homomorphisms preserve additive inverses.",
    "type": "f (-x) = -f x"
  },
  {
    "name": "set.sized.union",
    "statement": "theorem set.sized.union {α : Type u_1} {A B : set (finset α)} {r : ℕ} : set.sized r A ∧ set.sized r B → set.sized r (A ∪ B)",
    "theorem": "{α : Type u_1} {A B : set (finset α)} {r : ℕ} : set.sized r A ∧ set.sized r B → set.sized r (A ∪ B)",
    "args": "{α : Type u_1} {A B : set (finset α)} {r : ℕ}",
    "doc_string": "**Alias** of the reverse direction of set.sized_union`.",
    "type": "set.sized r A ∧ set.sized r B → set.sized r (A ∪ B)"
  },
  {
    "name": "dihedral_group.order_of_sr",
    "statement": "theorem dihedral_group.order_of_sr {n : ℕ} (i : zmod n) : order_of (dihedral_group.sr i) = 2",
    "theorem": "{n : ℕ} (i : zmod n) : order_of (dihedral_group.sr i) = 2",
    "args": "{n : ℕ} (i : zmod n)",
    "doc_string": "If `0 < n`, then `sr i` has order 2.",
    "type": "order_of (dihedral_group.sr i) = 2"
  },
  {
    "name": "equiv.coe_fn_injective",
    "statement": "theorem equiv.coe_fn_injective {α : Sort u} {β : Sort v} : function.injective coe_fn",
    "theorem": "{α : Sort u} {β : Sort v} : function.injective coe_fn",
    "args": "{α : Sort u} {β : Sort v}",
    "doc_string": "The map `coe_fn : (r ≃ s) → (r → s)` is injective.",
    "type": "function.injective coe_fn"
  },
  {
    "name": "topological_space.is_topological_basis.open_eq_sUnion'",
    "statement": "theorem topological_space.is_topological_basis.open_eq_sUnion' {α : Type u} [t : topological_space α] {B : set (set α)} (hB : topological_space.is_topological_basis B) {u : set α} (ou : is_open u) : u = ⋃₀{s ∈ B | s ⊆ u}",
    "theorem": "{α : Type u} [t : topological_space α] {B : set (set α)} (hB : topological_space.is_topological_basis B) {u : set α} (ou : is_open u) : u = ⋃₀{s ∈ B | s ⊆ u}",
    "args": "{α : Type u} [t : topological_space α] {B : set (set α)} (hB : topological_space.is_topological_basis B) {u : set α} (ou : is_open u)",
    "doc_string": "Any open set is the union of the basis sets contained in it.",
    "type": "u = ⋃₀{s ∈ B | s ⊆ u}"
  },
  {
    "name": "order.le_of_succ_le_succ",
    "statement": "theorem order.le_of_succ_le_succ {α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : order.succ a ≤ order.succ b → a ≤ b",
    "theorem": "{α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : order.succ a ≤ order.succ b → a ≤ b",
    "args": "{α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α]",
    "doc_string": "**Alias** of the forward direction of order.succ_le_succ_iff`.",
    "type": "order.succ a ≤ order.succ b → a ≤ b"
  },
  {
    "name": "nat.dvd_add_self_right",
    "statement": "theorem nat.dvd_add_self_right {m n : ℕ} : m ∣ n + m ↔ m ∣ n",
    "theorem": "{m n : ℕ} : m ∣ n + m ↔ m ∣ n",
    "args": "{m n : ℕ}",
    "doc_string": "A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.",
    "type": "m ∣ n + m ↔ m ∣ n"
  },
  {
    "name": "minpoly.prime",
    "statement": "theorem minpoly.prime {A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : prime (minpoly A x)",
    "theorem": "{A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : prime (minpoly A x)",
    "args": "{A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x)",
    "doc_string": "A minimal polynomial is prime.",
    "type": "prime (minpoly A x)"
  },
  {
    "name": "le_of_sub_nonneg",
    "statement": "theorem le_of_sub_nonneg {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : 0 ≤ a - b → b ≤ a",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : 0 ≤ a - b → b ≤ a",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α}",
    "doc_string": "**Alias** of the forward direction of sub_nonneg`.",
    "type": "0 ≤ a - b → b ≤ a"
  },
  {
    "name": "count_succ_eq_succ_count",
    "statement": "theorem count_succ_eq_succ_count {p : ℕ → Prop} [decidable_pred p] {n : ℕ} : p n → nat.count p (n + 1) = nat.count p n + 1",
    "theorem": "{p : ℕ → Prop} [decidable_pred p] {n : ℕ} : p n → nat.count p (n + 1) = nat.count p n + 1",
    "args": "{p : ℕ → Prop} [decidable_pred p] {n : ℕ}",
    "doc_string": "**Alias** of the reverse direction of nat.count_succ_eq_succ_count_iff`.",
    "type": "p n → nat.count p (n + 1) = nat.count p n + 1"
  },
  {
    "name": "nat.sub_succ'",
    "statement": "theorem nat.sub_succ' (a b : ℕ) : a - b.succ = a - b - 1",
    "theorem": "(a b : ℕ) : a - b.succ = a - b - 1",
    "args": "(a b : ℕ)",
    "doc_string": "A version of `nat.sub_succ` in the form `_ - 1` instead of `nat.pred _`.",
    "type": "a - b.succ = a - b - 1"
  },
  {
    "name": "function.involutive.eq_iff",
    "statement": "theorem function.involutive.eq_iff {α : Sort u} {f : α → α} (h : function.involutive f) {x y : α} : f x = y ↔ x = f y",
    "theorem": "{α : Sort u} {f : α → α} (h : function.involutive f) {x y : α} : f x = y ↔ x = f y",
    "args": "{α : Sort u} {f : α → α} (h : function.involutive f) {x y : α}",
    "doc_string": "An involution commutes across an equality. Compare to `function.injective.eq_iff`.",
    "type": "f x = y ↔ x = f y"
  },
  {
    "name": "zmod.nat_cast_zmod_val",
    "statement": "theorem zmod.nat_cast_zmod_val {n : ℕ} [fact (0 < n)] (a : zmod n) : ↑(a.val) = a",
    "theorem": "{n : ℕ} [fact (0 < n)] (a : zmod n) : ↑(a.val) = a",
    "args": "{n : ℕ} [fact (0 < n)] (a : zmod n)",
    "doc_string": " So-named because the coercion is `nat.cast` into `zmod`. For `nat.cast` into an arbitrary ring, see `zmod.nat_cast_val`.",
    "type": "↑(a.val) = a"
  },
  {
    "name": "list.prod_eq_zero_iff",
    "statement": "theorem list.prod_eq_zero_iff {M₀ : Type u_6} [monoid_with_zero M₀] [nontrivial M₀] [no_zero_divisors M₀] {L : list M₀} : L.prod = 0 ↔ 0 ∈ L",
    "theorem": "{M₀ : Type u_6} [monoid_with_zero M₀] [nontrivial M₀] [no_zero_divisors M₀] {L : list M₀} : L.prod = 0 ↔ 0 ∈ L",
    "args": "{M₀ : Type u_6} [monoid_with_zero M₀] [nontrivial M₀] [no_zero_divisors M₀] {L : list M₀}",
    "doc_string": " Product of elements of a list `L` equals zero if and only if `0 ∈ L`. See also `list.prod_eq_zero` for an implication that needs weaker typeclass assumptions.",
    "type": "L.prod = 0 ↔ 0 ∈ L"
  },
  {
    "name": "right.one_lt_mul'",
    "statement": "theorem right.one_lt_mul' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul'`.",
    "type": "1 < a * b"
  },
  {
    "name": "is_submonoid.pow_mem",
    "statement": "theorem is_submonoid.pow_mem {M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a ∈ s) {n : ℕ} : a ^ n ∈ s",
    "theorem": "{M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a ∈ s) {n : ℕ} : a ^ n ∈ s",
    "args": "{M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a ∈ s) {n : ℕ}",
    "doc_string": "Submonoids are closed under natural powers.",
    "type": "a ^ n ∈ s"
  },
  {
    "name": "is_right_regular_of_right_cancel_semigroup",
    "statement": "theorem is_right_regular_of_right_cancel_semigroup {R : Type u_1} [right_cancel_semigroup R] (g : R) : is_right_regular g",
    "theorem": "{R : Type u_1} [right_cancel_semigroup R] (g : R) : is_right_regular g",
    "args": "{R : Type u_1} [right_cancel_semigroup R] (g : R)",
    "doc_string": "Elements of a right cancel semigroup are right regular.",
    "type": "is_right_regular g"
  },
  {
    "name": "le_nhds_of_cauchy_adhp",
    "statement": "theorem le_nhds_of_cauchy_adhp {α : Type u} [uniform_space α] {f : filter α} {x : α} (hf : cauchy f) (adhs : cluster_pt x f) : f ≤ nhds x",
    "theorem": "{α : Type u} [uniform_space α] {f : filter α} {x : α} (hf : cauchy f) (adhs : cluster_pt x f) : f ≤ nhds x",
    "args": "{α : Type u} [uniform_space α] {f : filter α} {x : α} (hf : cauchy f) (adhs : cluster_pt x f)",
    "doc_string": " If `x` is an adherent (cluster) point for a Cauchy filter `f`, then it is a limit point for `f`.",
    "type": "f ≤ nhds x"
  },
  {
    "name": "equiv.perm.cycle_factors_finset_injective",
    "statement": "theorem equiv.perm.cycle_factors_finset_injective {α : Type u_1} [decidable_eq α] [fintype α] : function.injective equiv.perm.cycle_factors_finset",
    "theorem": "{α : Type u_1} [decidable_eq α] [fintype α] : function.injective equiv.perm.cycle_factors_finset",
    "args": "{α : Type u_1} [decidable_eq α] [fintype α]",
    "doc_string": "Two permutations `f g : perm α` have the same cycle factors iff they are the same.",
    "type": "function.injective equiv.perm.cycle_factors_finset"
  },
  {
    "name": "real.summable_one_div_nat_pow",
    "statement": "theorem real.summable_one_div_nat_pow {p : ℕ} : summable (λ (n : ℕ), 1 / ↑n ^ p) ↔ 1 < p",
    "theorem": "{p : ℕ} : summable (λ (n : ℕ), 1 / ↑n ^ p) ↔ 1 < p",
    "args": "{p : ℕ}",
    "doc_string": " Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, 1 / n ^ p` converges if and only if `1 < p`.",
    "type": "summable (λ (n : ℕ), 1 / ↑n ^ p) ↔ 1 < p"
  },
  {
    "name": "no_min_order.infinite",
    "statement": "theorem no_min_order.infinite {α : Type u_1} [preorder α] [nonempty α] [no_min_order α] : infinite α",
    "theorem": "{α : Type u_1} [preorder α] [nonempty α] [no_min_order α] : infinite α",
    "args": "{α : Type u_1} [preorder α] [nonempty α] [no_min_order α]",
    "doc_string": " A nonempty preorder with no minimal element is infinite. This is not an instance to avoid a cycle with `infinite α → nontrivial α → nonempty α`.",
    "type": "infinite α"
  },
  {
    "name": "con.ext_iff",
    "statement": "theorem con.ext_iff {M : Type u_1} [has_mul M] {c d : con M} : (∀ (x y : M), ⇑c x y ↔ ⇑d x y) ↔ c = d",
    "theorem": "{M : Type u_1} [has_mul M] {c d : con M} : (∀ (x y : M), ⇑c x y ↔ ⇑d x y) ↔ c = d",
    "args": "{M : Type u_1} [has_mul M] {c d : con M}",
    "doc_string": "Iff version of extensionality rule for congruence relations.",
    "type": "(∀ (x y : M), ⇑c x y ↔ ⇑d x y) ↔ c = d"
  },
  {
    "name": "same_ray.symm",
    "statement": "theorem same_ray.symm {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} (h : same_ray R x y) : same_ray R y x",
    "theorem": "{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} (h : same_ray R x y) : same_ray R y x",
    "args": "{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} (h : same_ray R x y)",
    "doc_string": "`same_ray` is symmetric.",
    "type": "same_ray R y x"
  },
  {
    "name": "one_div_lt_one_div",
    "statement": "theorem one_div_lt_one_div {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : 1 / a < 1 / b ↔ b < a",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : 1 / a < 1 / b ↔ b < a",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and  `lt_of_one_div_lt_one_div`",
    "type": "1 / a < 1 / b ↔ b < a"
  },
  {
    "name": "filter.at_top_le_cofinite",
    "statement": "theorem filter.at_top_le_cofinite {α : Type u_2} [preorder α] [no_max_order α] : filter.at_top ≤ filter.cofinite",
    "theorem": "{α : Type u_2} [preorder α] [no_max_order α] : filter.at_top ≤ filter.cofinite",
    "args": "{α : Type u_2} [preorder α] [no_max_order α]",
    "doc_string": "If `α` is a preorder with no maximal element, then `at_top ≤ cofinite`.",
    "type": "filter.at_top ≤ filter.cofinite"
  },
  {
    "name": "polynomial.taylor_coeff",
    "statement": "theorem polynomial.taylor_coeff {R : Type u_1} [semiring R] (r : R) (f : polynomial R) (n : ℕ) : (⇑(polynomial.taylor r) f).coeff n = polynomial.eval r (⇑(polynomial.hasse_deriv n) f)",
    "theorem": "{R : Type u_1} [semiring R] (r : R) (f : polynomial R) (n : ℕ) : (⇑(polynomial.taylor r) f).coeff n = polynomial.eval r (⇑(polynomial.hasse_deriv n) f)",
    "args": "{R : Type u_1} [semiring R] (r : R) (f : polynomial R) (n : ℕ)",
    "doc_string": "The `k`th coefficient of `polynomial.taylor r f` is `(polynomial.hasse_deriv k f).eval r`.",
    "type": "(⇑(polynomial.taylor r) f).coeff n = polynomial.eval r (⇑(polynomial.hasse_deriv n) f)"
  },
  {
    "name": "nat.upto.wf",
    "statement": "theorem nat.upto.wf {p : ℕ → Prop} : (∃ (x : ℕ), p x) → well_founded (nat.upto.gt p)",
    "theorem": "{p : ℕ → Prop} : (∃ (x : ℕ), p x) → well_founded (nat.upto.gt p)",
    "args": "{p : ℕ → Prop}",
    "doc_string": " The \"greater than\" relation on `upto p` is well founded if (and only if) there exists a value satisfying `p`.",
    "type": "(∃ (x : ℕ), p x) → well_founded (nat.upto.gt p)"
  },
  {
    "name": "finite_dimensional.of_fintype_basis",
    "statement": "theorem finite_dimensional.of_fintype_basis {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} [fintype ι] (h : basis ι K V) : finite_dimensional K V",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} [fintype ι] (h : basis ι K V) : finite_dimensional K V",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} [fintype ι] (h : basis ι K V)",
    "doc_string": "If a vector space has a finite basis, then it is finite-dimensional.",
    "type": "finite_dimensional K V"
  },
  {
    "name": "is_extr_filter.dual",
    "statement": "theorem is_extr_filter.dual {α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_extr_filter f l a → is_extr_filter (⇑order_dual.to_dual ∘ f) l a",
    "theorem": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_extr_filter f l a → is_extr_filter (⇑order_dual.to_dual ∘ f) l a",
    "args": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α}",
    "doc_string": "**Alias** of the reverse direction of is_extr_filter_dual_iff`.",
    "type": "is_extr_filter f l a → is_extr_filter (⇑order_dual.to_dual ∘ f) l a"
  },
  {
    "name": "char.quadratic_char_exists_neg_one",
    "statement": "theorem char.quadratic_char_exists_neg_one {F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2) : ∃ (a : F), char.quadratic_char F a = -1",
    "theorem": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2) : ∃ (a : F), char.quadratic_char F a = -1",
    "args": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2)",
    "doc_string": "If `F` has odd characteristic, then `quadratic_char F` takes the value `-1`.",
    "type": "∃ (a : F), char.quadratic_char F a = -1"
  },
  {
    "name": "dense_range_stone_cech_unit",
    "statement": "theorem dense_range_stone_cech_unit {α : Type u} [topological_space α] : dense_range stone_cech_unit",
    "theorem": "{α : Type u} [topological_space α] : dense_range stone_cech_unit",
    "args": "{α : Type u} [topological_space α]",
    "doc_string": "The image of stone_cech_unit is dense. (But stone_cech_unit need  not be an embedding, for example if α is not Hausdorff.)",
    "type": "dense_range stone_cech_unit"
  },
  {
    "name": "mv_polynomial.is_domain_fin",
    "statement": "theorem mv_polynomial.is_domain_fin (R : Type u) [comm_ring R] [is_domain R] (n : ℕ) : is_domain (mv_polynomial (fin n) R)",
    "theorem": "(R : Type u) [comm_ring R] [is_domain R] (n : ℕ) : is_domain (mv_polynomial (fin n) R)",
    "args": "(R : Type u) [comm_ring R] [is_domain R] (n : ℕ)",
    "doc_string": " Auxiliary lemma: Multivariate polynomials over an integral domain with variables indexed by `fin n` form an integral domain. This fact is proven inductively, and then used to prove the general case without any finiteness hypotheses. See `mv_polynomial.is_domain` for the general case.",
    "type": "is_domain (mv_polynomial (fin n) R)"
  },
  {
    "name": "category_theory.is_connected_zigzag",
    "statement": "theorem category_theory.is_connected_zigzag {J : Type u₁} [category_theory.category J] [category_theory.is_connected J] (j₁ j₂ : J) : category_theory.zigzag j₁ j₂",
    "theorem": "{J : Type u₁} [category_theory.category J] [category_theory.is_connected J] (j₁ j₂ : J) : category_theory.zigzag j₁ j₂",
    "args": "{J : Type u₁} [category_theory.category J] [category_theory.is_connected J] (j₁ j₂ : J)",
    "doc_string": "In a connected category, any two objects are related by `zigzag`.",
    "type": "category_theory.zigzag j₁ j₂"
  },
  {
    "name": "right.one_le_inv_iff",
    "statement": "theorem right.one_le_inv_iff {α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α}",
    "doc_string": "Uses `right` co(ntra)variant.",
    "type": "1 ≤ a⁻¹ ↔ a ≤ 1"
  },
  {
    "name": "subsingleton_floor_ring",
    "statement": "theorem subsingleton_floor_ring {α : Type u_1} [linear_ordered_ring α] : subsingleton (floor_ring α)",
    "theorem": "{α : Type u_1} [linear_ordered_ring α] : subsingleton (floor_ring α)",
    "args": "{α : Type u_1} [linear_ordered_ring α]",
    "doc_string": "There exists at most one `floor_ring` structure on a given linear ordered ring.",
    "type": "subsingleton (floor_ring α)"
  },
  {
    "name": "matrix.mul_nonsing_inv",
    "statement": "theorem matrix.mul_nonsing_inv {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (h : is_unit A.det) : A.mul A⁻¹ = 1",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (h : is_unit A.det) : A.mul A⁻¹ = 1",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (h : is_unit A.det)",
    "doc_string": "The `nonsing_inv` of `A` is a right inverse.",
    "type": "A.mul A⁻¹ = 1"
  },
  {
    "name": "submodule.finset_span_is_compact_element",
    "statement": "theorem submodule.finset_span_is_compact_element {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M) : complete_lattice.is_compact_element (submodule.span R ↑S)",
    "theorem": "{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M) : complete_lattice.is_compact_element (submodule.span R ↑S)",
    "args": "{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M)",
    "doc_string": "The span of a finite subset is compact in the lattice of submodules.",
    "type": "complete_lattice.is_compact_element (submodule.span R ↑S)"
  },
  {
    "name": "zero_lt.left.mul_lt_one_of_lt_of_lt",
    "statement": "theorem zero_lt.left.mul_lt_one_of_lt_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a < 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a < 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a < 1) (hb : b < 1) (a0 : 0 < a)",
    "doc_string": "Assumes left covariance.",
    "type": "a * b < 1"
  },
  {
    "name": "finset.order_emb_of_fin_singleton",
    "statement": "theorem finset.order_emb_of_fin_singleton {α : Type u_1} [linear_order α] (a : α) (i : fin 1) : ⇑({a}.order_emb_of_fin _) i = a",
    "theorem": "{α : Type u_1} [linear_order α] (a : α) (i : fin 1) : ⇑({a}.order_emb_of_fin _) i = a",
    "args": "{α : Type u_1} [linear_order α] (a : α) (i : fin 1)",
    "doc_string": "`order_emb_of_fin {a} h` sends any argument to `a`.",
    "type": "⇑({a}.order_emb_of_fin _) i = a"
  },
  {
    "name": "is_glb.bdd_below",
    "statement": "theorem is_glb.bdd_below {α : Type u} [preorder α] {s : set α} {a : α} (h : is_glb s a) : bdd_below s",
    "theorem": "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_glb s a) : bdd_below s",
    "args": "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_glb s a)",
    "doc_string": "If `s` has a greatest lower bound, then it is bounded below.",
    "type": "bdd_below s"
  },
  {
    "name": "padic_norm.one",
    "statement": "theorem padic_norm.one (p : ℕ) : padic_norm p 1 = 1",
    "theorem": "(p : ℕ) : padic_norm p 1 = 1",
    "args": "(p : ℕ)",
    "doc_string": "The p-adic norm of 1 is 1.",
    "type": "padic_norm p 1 = 1"
  },
  {
    "name": "sub_eq_add_neg",
    "statement": "theorem sub_eq_add_neg {G : Type u_1} [sub_neg_monoid G] (a b : G) : a - b = a + -b",
    "theorem": "{G : Type u_1} [sub_neg_monoid G] (a b : G) : a - b = a + -b",
    "args": "{G : Type u_1} [sub_neg_monoid G] (a b : G)",
    "doc_string": "Subtracting an element is the same as adding by its negative.  This is a duplicate of `sub_neg_monoid.sub_eq_mul_neg` ensuring that the types unfold better.",
    "type": "a - b = a + -b"
  },
  {
    "name": "psigma.subtype_ext",
    "statement": "theorem psigma.subtype_ext {α : Sort u_1} {β : Sort u_2} {p : α → β → Prop} {x₀ x₁ : Σ' (a : α), subtype (p a)} : x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {p : α → β → Prop} {x₀ x₁ : Σ' (a : α), subtype (p a)} : x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁",
    "args": "{α : Sort u_1} {β : Sort u_2} {p : α → β → Prop} {x₀ x₁ : Σ' (a : α), subtype (p a)}",
    "doc_string": "A specialized ext lemma for equality of psigma types over an indexed subtype.",
    "type": "x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁"
  },
  {
    "name": "category_theory.over.construct_products.over_binary_product_of_pullback",
    "statement": "theorem category_theory.over.construct_products.over_binary_product_of_pullback {C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C} : category_theory.limits.has_binary_products (category_theory.over B)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C} : category_theory.limits.has_binary_products (category_theory.over B)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C}",
    "doc_string": "Given a pullback in `C`, construct a binary product in `C/B`.",
    "type": "category_theory.limits.has_binary_products (category_theory.over B)"
  },
  {
    "name": "group_topology.continuous_inv'",
    "statement": "theorem group_topology.continuous_inv' {α : Type u} [group α] (g : group_topology α) : continuous has_inv.inv",
    "theorem": "{α : Type u} [group α] (g : group_topology α) : continuous has_inv.inv",
    "args": "{α : Type u} [group α] (g : group_topology α)",
    "doc_string": "A version of the global `continuous_inv` suitable for dot notation.",
    "type": "continuous has_inv.inv"
  },
  {
    "name": "add_pos_of_pos_of_nonneg",
    "statement": "theorem add_pos_of_pos_of_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b)",
    "doc_string": "**Alias** of `left.add_pos_of_pos_of_nonneg`.",
    "type": "0 < a + b"
  },
  {
    "name": "nat.eq_prime_pow_of_dvd_least_prime_pow",
    "statement": "theorem nat.eq_prime_pow_of_dvd_least_prime_pow {a p k : ℕ} (pp : nat.prime p) (h₁ : ¬a ∣ p ^ k) (h₂ : a ∣ p ^ (k + 1)) : a = p ^ (k + 1)",
    "theorem": "{a p k : ℕ} (pp : nat.prime p) (h₁ : ¬a ∣ p ^ k) (h₂ : a ∣ p ^ (k + 1)) : a = p ^ (k + 1)",
    "args": "{a p k : ℕ} (pp : nat.prime p) (h₁ : ¬a ∣ p ^ k) (h₂ : a ∣ p ^ (k + 1))",
    "doc_string": "If `p` is prime, and `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)` then `a = p^(k+1)`.",
    "type": "a = p ^ (k + 1)"
  },
  {
    "name": "one_hom.congr_fun",
    "statement": "theorem one_hom.congr_fun {M : Type u_3} {N : Type u_4} [has_one M] [has_one N] {f g : one_hom M N} (h : f = g) (x : M) : ⇑f x = ⇑g x",
    "theorem": "{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] {f g : one_hom M N} (h : f = g) (x : M) : ⇑f x = ⇑g x",
    "args": "{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] {f g : one_hom M N} (h : f = g) (x : M)",
    "doc_string": "Deprecated: use `fun_like.congr_fun` instead.",
    "type": "⇑f x = ⇑g x"
  },
  {
    "name": "zero_ne_one",
    "statement": "theorem zero_ne_one {M₀ : Type u_1} [mul_zero_one_class M₀] [nontrivial M₀] : 0 ≠ 1",
    "theorem": "{M₀ : Type u_1} [mul_zero_one_class M₀] [nontrivial M₀] : 0 ≠ 1",
    "args": "{M₀ : Type u_1} [mul_zero_one_class M₀] [nontrivial M₀]",
    "doc_string": "In a nontrivial monoid with zero, zero and one are different.",
    "type": "0 ≠ 1"
  },
  {
    "name": "finset.subtype_map",
    "statement": "theorem finset.subtype_map {α : Type u_1} {s : finset α} (p : α → Prop) [decidable_pred p] : finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s",
    "theorem": "{α : Type u_1} {s : finset α} (p : α → Prop) [decidable_pred p] : finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s",
    "args": "{α : Type u_1} {s : finset α} (p : α → Prop) [decidable_pred p]",
    "doc_string": " `s.subtype p` converts back to `s.filter p` with `embedding.subtype`.",
    "type": "finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s"
  },
  {
    "name": "is_pi_system_prod",
    "statement": "theorem is_pi_system_prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] : is_pi_system (set.image2 has_set_prod.prod {s : set α | measurable_set s} {t : set β | measurable_set t})",
    "theorem": "{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] : is_pi_system (set.image2 has_set_prod.prod {s : set α | measurable_set s} {t : set β | measurable_set t})",
    "args": "{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β]",
    "doc_string": "Rectangles form a π-system.",
    "type": "is_pi_system (set.image2 has_set_prod.prod {s : set α | measurable_set s} {t : set β | measurable_set t})"
  },
  {
    "name": "fin.succ_above_pos",
    "statement": "theorem fin.succ_above_pos {n : ℕ} (p : fin (n + 2)) (i : fin (n + 1)) (h : 0 < i) : 0 < ⇑(p.succ_above) i",
    "theorem": "{n : ℕ} (p : fin (n + 2)) (i : fin (n + 1)) (h : 0 < i) : 0 < ⇑(p.succ_above) i",
    "args": "{n : ℕ} (p : fin (n + 2)) (i : fin (n + 1)) (h : 0 < i)",
    "doc_string": "Embedding a positive `fin n` results in a positive fin (n + 1)`",
    "type": "0 < ⇑(p.succ_above) i"
  },
  {
    "name": "nat.le_pow_iff_clog_le",
    "statement": "theorem nat.le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ nat.clog b x ≤ y",
    "theorem": "{b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ nat.clog b x ≤ y",
    "args": "{b : ℕ} (hb : 1 < b) {x y : ℕ}",
    "doc_string": "`clog b` and `pow b` form a Galois connection.",
    "type": "x ≤ b ^ y ↔ nat.clog b x ≤ y"
  },
  {
    "name": "discrete_topology_iff_nhds",
    "statement": "theorem discrete_topology_iff_nhds {X : Type u_1} [topological_space X] : discrete_topology X ↔ nhds = has_pure.pure",
    "theorem": "{X : Type u_1} [topological_space X] : discrete_topology X ↔ nhds = has_pure.pure",
    "args": "{X : Type u_1} [topological_space X]",
    "doc_string": " This lemma characterizes discrete topological spaces as those whose singletons are neighbourhoods.",
    "type": "discrete_topology X ↔ nhds = has_pure.pure"
  },
  {
    "name": "uniform_inducing.uniform_embedding",
    "statement": "theorem uniform_inducing.uniform_embedding {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {f : α → β} (hf : uniform_inducing f) : uniform_embedding f",
    "theorem": "{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {f : α → β} (hf : uniform_inducing f) : uniform_embedding f",
    "args": "{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {f : α → β} (hf : uniform_inducing f)",
    "doc_string": " If the domain of a `uniform_inducing` map `f` is a `separated_space`, then `f` is injective, hence it is a `uniform_embedding`.",
    "type": "uniform_embedding f"
  },
  {
    "name": "is_max_filter.dual",
    "statement": "theorem is_max_filter.dual {α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_max_filter f l a → is_min_filter (⇑order_dual.to_dual ∘ f) l a",
    "theorem": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_max_filter f l a → is_min_filter (⇑order_dual.to_dual ∘ f) l a",
    "args": "{α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α}",
    "doc_string": "**Alias** of the reverse direction of is_min_filter_dual_iff`.",
    "type": "is_max_filter f l a → is_min_filter (⇑order_dual.to_dual ∘ f) l a"
  },
  {
    "name": "algebra.finite_presentation.self",
    "statement": "theorem algebra.finite_presentation.self (R : Type u_1) [comm_ring R] : algebra.finite_presentation R R",
    "theorem": "(R : Type u_1) [comm_ring R] : algebra.finite_presentation R R",
    "args": "(R : Type u_1) [comm_ring R]",
    "doc_string": "`R` is finitely presented as `R`-algebra.",
    "type": "algebra.finite_presentation R R"
  },
  {
    "name": "nat.exists_strict_mono",
    "statement": "theorem nat.exists_strict_mono (α : Type u) [preorder α] [nonempty α] [no_max_order α] : ∃ (f : ℕ → α), strict_mono f",
    "theorem": "(α : Type u) [preorder α] [nonempty α] [no_max_order α] : ∃ (f : ℕ → α), strict_mono f",
    "args": "(α : Type u) [preorder α] [nonempty α] [no_max_order α]",
    "doc_string": " If `α` is a nonempty preorder with no maximal elements, then there exists a strictly monotone function `ℕ → α`.",
    "type": "∃ (f : ℕ → α), strict_mono f"
  },
  {
    "name": "is_square.inv",
    "statement": "theorem is_square.inv {α : Type u_2} [division_monoid α] {a : α} : is_square a → is_square a⁻¹",
    "theorem": "{α : Type u_2} [division_monoid α] {a : α} : is_square a → is_square a⁻¹",
    "args": "{α : Type u_2} [division_monoid α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of is_square_inv`.",
    "type": "is_square a → is_square a⁻¹"
  },
  {
    "name": "padic_norm.zero",
    "statement": "theorem padic_norm.zero (p : ℕ) : padic_norm p 0 = 0",
    "theorem": "(p : ℕ) : padic_norm p 0 = 0",
    "args": "(p : ℕ)",
    "doc_string": "The p-adic norm of 0 is 0.",
    "type": "padic_norm p 0 = 0"
  },
  {
    "name": "fin.succ_above_left_injective",
    "statement": "theorem fin.succ_above_left_injective {n : ℕ} : function.injective fin.succ_above",
    "theorem": "{n : ℕ} : function.injective fin.succ_above",
    "args": "{n : ℕ}",
    "doc_string": "`succ_above` is injective at the pivot",
    "type": "function.injective fin.succ_above"
  },
  {
    "name": "has_sbtw.sbtw.cyclic_right",
    "statement": "theorem has_sbtw.sbtw.cyclic_right {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw c a b",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw c a b",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c)",
    "doc_string": "**Alias** of sbtw_cyclic_right`.",
    "type": "has_sbtw.sbtw c a b"
  },
  {
    "name": "measure_theory.strongly_measurable_const'",
    "statement": "theorem measure_theory.strongly_measurable_const' {α : Type u_1} {β : Type u_2} {m : measurable_space α} [topological_space β] {f : α → β} (hf : ∀ (x y : α), f x = f y) : measure_theory.strongly_measurable f",
    "theorem": "{α : Type u_1} {β : Type u_2} {m : measurable_space α} [topological_space β] {f : α → β} (hf : ∀ (x y : α), f x = f y) : measure_theory.strongly_measurable f",
    "args": "{α : Type u_1} {β : Type u_2} {m : measurable_space α} [topological_space β] {f : α → β} (hf : ∀ (x y : α), f x = f y)",
    "doc_string": " A version of `strongly_measurable_const` that assumes `f x = f y` for all `x, y`. This version works for functions between empty types.",
    "type": "measure_theory.strongly_measurable f"
  },
  {
    "name": "is_right_regular_of_mul_eq_one",
    "statement": "theorem is_right_regular_of_mul_eq_one {R : Type u_1} {a b : R} [monoid R] (h : a * b = 1) : is_right_regular a",
    "theorem": "{R : Type u_1} {a b : R} [monoid R] (h : a * b = 1) : is_right_regular a",
    "args": "{R : Type u_1} {a b : R} [monoid R] (h : a * b = 1)",
    "doc_string": "An element admitting a right inverse is right-regular.",
    "type": "is_right_regular a"
  },
  {
    "name": "measurable.le_map",
    "statement": "theorem measurable.le_map {α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable f → m₂ ≤ measurable_space.map f m₁",
    "theorem": "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable f → m₂ ≤ measurable_space.map f m₁",
    "args": "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β}",
    "doc_string": "**Alias** of the forward direction of measurable_iff_le_map`.",
    "type": "measurable f → m₂ ≤ measurable_space.map f m₁"
  },
  {
    "name": "is_right_regular_iff",
    "statement": "theorem is_right_regular_iff {R : Type u_1} [has_mul R] {a : R} : is_right_regular a ↔ is_smul_regular R (mul_opposite.op a)",
    "theorem": "{R : Type u_1} [has_mul R] {a : R} : is_right_regular a ↔ is_smul_regular R (mul_opposite.op a)",
    "args": "{R : Type u_1} [has_mul R] {a : R}",
    "doc_string": "Right-regular multiplication on `R` is equivalent to `Rᵐᵒᵖ`-regularity of `R` itself.",
    "type": "is_right_regular a ↔ is_smul_regular R (mul_opposite.op a)"
  },
  {
    "name": "add_con.eq",
    "statement": "theorem add_con.eq {M : Type u_1} [has_add M] (c : add_con M) {a b : M} : ↑a = ↑b ↔ ⇑c a b",
    "theorem": "{M : Type u_1} [has_add M] (c : add_con M) {a b : M} : ↑a = ↑b ↔ ⇑c a b",
    "args": "{M : Type u_1} [has_add M] (c : add_con M) {a b : M}",
    "doc_string": "Two elements are related by an additive congruence relation `c` iff they are represented by the same element of the quotient by `c`.",
    "type": "↑a = ↑b ↔ ⇑c a b"
  },
  {
    "name": "order_of_pos",
    "statement": "theorem order_of_pos {G : Type u} [fintype G] [left_cancel_monoid G] (x : G) : 0 < order_of x",
    "theorem": "{G : Type u} [fintype G] [left_cancel_monoid G] (x : G) : 0 < order_of x",
    "args": "{G : Type u} [fintype G] [left_cancel_monoid G] (x : G)",
    "doc_string": "This is the same as `order_of_pos' but with one fewer explicit assumption since this is  automatic in case of a finite cancellative monoid.",
    "type": "0 < order_of x"
  },
  {
    "name": "int.exists_least_of_bdd",
    "statement": "theorem int.exists_least_of_bdd {P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → b ≤ z) (Hinh : ∃ (z : ℤ), P z) : ∃ (lb : ℤ), P lb ∧ ∀ (z : ℤ), P z → lb ≤ z",
    "theorem": "{P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → b ≤ z) (Hinh : ∃ (z : ℤ), P z) : ∃ (lb : ℤ), P lb ∧ ∀ (z : ℤ), P z → lb ≤ z",
    "args": "{P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → b ≤ z) (Hinh : ∃ (z : ℤ), P z)",
    "doc_string": " If `P : ℤ → Prop` is a predicate such that the set `{m : P m}` is bounded below and nonempty, then this set has the least element. This lemma uses classical logic to avoid assumption `[decidable_pred P]`. See `int.least_of_bdd` for a constructive counterpart.",
    "type": "∃ (lb : ℤ), P lb ∧ ∀ (z : ℤ), P z → lb ≤ z"
  },
  {
    "name": "finset.bdd_below",
    "statement": "theorem finset.bdd_below {α : Type u} [semilattice_inf α] [nonempty α] (s : finset α) : bdd_below ↑s",
    "theorem": "{α : Type u} [semilattice_inf α] [nonempty α] (s : finset α) : bdd_below ↑s",
    "args": "{α : Type u} [semilattice_inf α] [nonempty α] (s : finset α)",
    "doc_string": "A finset is bounded below.",
    "type": "bdd_below ↑s"
  },
  {
    "name": "left.one_lt_mul'",
    "statement": "theorem left.one_lt_mul' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul'`.",
    "type": "1 < a * b"
  },
  {
    "name": "monotone.dual_right",
    "statement": "theorem monotone.dual_right {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : monotone f → antitone (⇑order_dual.to_dual ∘ f)",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : monotone f → antitone (⇑order_dual.to_dual ∘ f)",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β}",
    "doc_string": "**Alias** of the reverse direction of antitone_to_dual_comp_iff`.",
    "type": "monotone f → antitone (⇑order_dual.to_dual ∘ f)"
  },
  {
    "name": "lucas_primality",
    "statement": "theorem lucas_primality (p : ℕ) (a : zmod p) (ha : a ^ (p - 1) = 1) (hd : ∀ (q : ℕ), nat.prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) : nat.prime p",
    "theorem": "(p : ℕ) (a : zmod p) (ha : a ^ (p - 1) = 1) (hd : ∀ (q : ℕ), nat.prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) : nat.prime p",
    "args": "(p : ℕ) (a : zmod p) (ha : a ^ (p - 1) = 1) (hd : ∀ (q : ℕ), nat.prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1)",
    "doc_string": "If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p` is prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this group must itself have order `p-1`, which only happens when `p` is prime.",
    "type": "nat.prime p"
  },
  {
    "name": "metric.diam_eq_zero_of_unbounded",
    "statement": "theorem metric.diam_eq_zero_of_unbounded {α : Type u} [pseudo_metric_space α] {s : set α} (h : ¬metric.bounded s) : metric.diam s = 0",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} (h : ¬metric.bounded s) : metric.diam s = 0",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α} (h : ¬metric.bounded s)",
    "doc_string": " An unbounded set has zero diameter. If you would prefer to get the value ∞, use `emetric.diam`. This lemma makes it possible to avoid side conditions in some situations",
    "type": "metric.diam s = 0"
  },
  {
    "name": "strict_anti.dual_right",
    "statement": "theorem strict_anti.dual_right {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : strict_anti f → strict_mono (⇑order_dual.to_dual ∘ f)",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : strict_anti f → strict_mono (⇑order_dual.to_dual ∘ f)",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β}",
    "doc_string": "**Alias** of the reverse direction of strict_mono_to_dual_comp_iff`.",
    "type": "strict_anti f → strict_mono (⇑order_dual.to_dual ∘ f)"
  },
  {
    "name": "function.injective.cod_restrict",
    "statement": "theorem function.injective.cod_restrict {α : Type u} {β : Type v} {t : set β} {f : α → β} (h : ∀ (x : α), f x ∈ t) : function.injective f → function.injective (set.cod_restrict f t h)",
    "theorem": "{α : Type u} {β : Type v} {t : set β} {f : α → β} (h : ∀ (x : α), f x ∈ t) : function.injective f → function.injective (set.cod_restrict f t h)",
    "args": "{α : Type u} {β : Type v} {t : set β} {f : α → β} (h : ∀ (x : α), f x ∈ t)",
    "doc_string": "**Alias** of the reverse direction of set.injective_cod_restrict`.",
    "type": "function.injective f → function.injective (set.cod_restrict f t h)"
  },
  {
    "name": "pnat.xgcd_type.rq_eq",
    "statement": "theorem pnat.xgcd_type.rq_eq (u : pnat.xgcd_type) : u.r + (u.bp + 1) * u.q = u.ap + 1",
    "theorem": "(u : pnat.xgcd_type) : u.r + (u.bp + 1) * u.q = u.ap + 1",
    "args": "(u : pnat.xgcd_type)",
    "doc_string": "Properties of division with remainder for a / b.",
    "type": "u.r + (u.bp + 1) * u.q = u.ap + 1"
  },
  {
    "name": "is_smul_regular.one",
    "statement": "theorem is_smul_regular.one {R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] : is_smul_regular M 1",
    "theorem": "{R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] : is_smul_regular M 1",
    "args": "{R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M]",
    "doc_string": "One is `M`-regular always.",
    "type": "is_smul_regular M 1"
  },
  {
    "name": "reflexive_ne_imp_iff",
    "statement": "theorem reflexive_ne_imp_iff {α : Type u_1} {r : α → α → Prop} [is_refl α r] {x y : α} : x ≠ y → r x y ↔ r x y",
    "theorem": "{α : Type u_1} {r : α → α → Prop} [is_refl α r] {x y : α} : x ≠ y → r x y ↔ r x y",
    "args": "{α : Type u_1} {r : α → α → Prop} [is_refl α r] {x y : α}",
    "doc_string": " If a reflexive relation `r : α → α → Prop` holds over `x y : α`, then it holds whether or not `x ≠ y`. Unlike `reflexive.ne_imp_iff`, this uses `[is_refl α r]`.",
    "type": "x ≠ y → r x y ↔ r x y"
  },
  {
    "name": "fin.cons_injective2",
    "statement": "theorem fin.cons_injective2 {n : ℕ} {α : fin (n + 1) → Type u} : function.injective2 fin.cons",
    "theorem": "{n : ℕ} {α : fin (n + 1) → Type u} : function.injective2 fin.cons",
    "args": "{n : ℕ} {α : fin (n + 1) → Type u}",
    "doc_string": "As a binary function, `fin.cons` is injective.",
    "type": "function.injective2 fin.cons"
  },
  {
    "name": "div_eq_one_of_eq",
    "statement": "theorem div_eq_one_of_eq {G : Type u_2} [group G] {a b : G} : a = b → a / b = 1",
    "theorem": "{G : Type u_2} [group G] {a b : G} : a = b → a / b = 1",
    "args": "{G : Type u_2} [group G] {a b : G}",
    "doc_string": "**Alias** of the reverse direction of div_eq_one`.",
    "type": "a = b → a / b = 1"
  },
  {
    "name": "has_le.le.trans_lt",
    "statement": "theorem has_le.le.trans_lt {α : Type u} [preorder α] {a b c : α} : a ≤ b → b < c → a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : a ≤ b → b < c → a < c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of lt_of_le_of_lt`.",
    "type": "a ≤ b → b < c → a < c"
  },
  {
    "name": "lt_add_of_sub_left_lt",
    "statement": "theorem lt_add_of_sub_left_lt {α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a - b < c → a < b + c",
    "theorem": "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a - b < c → a < b + c",
    "args": "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of sub_lt_iff_lt_add'`.",
    "type": "a - b < c → a < b + c"
  },
  {
    "name": "dfinsupp.coe_fn_injective",
    "statement": "theorem dfinsupp.coe_fn_injective {ι : Type u} {β : ι → Type v} [Π (i : ι), has_zero (β i)] : function.injective coe_fn",
    "theorem": "{ι : Type u} {β : ι → Type v} [Π (i : ι), has_zero (β i)] : function.injective coe_fn",
    "args": "{ι : Type u} {β : ι → Type v} [Π (i : ι), has_zero (β i)]",
    "doc_string": "Deprecated. Use `fun_like.coe_injective` instead.",
    "type": "function.injective coe_fn"
  },
  {
    "name": "list.prod_eq_zero",
    "statement": "theorem list.prod_eq_zero {M₀ : Type u_6} [monoid_with_zero M₀] {L : list M₀} (h : 0 ∈ L) : L.prod = 0",
    "theorem": "{M₀ : Type u_6} [monoid_with_zero M₀] {L : list M₀} (h : 0 ∈ L) : L.prod = 0",
    "args": "{M₀ : Type u_6} [monoid_with_zero M₀] {L : list M₀} (h : 0 ∈ L)",
    "doc_string": " If zero is an element of a list `L`, then `list.prod L = 0`. If the domain is a nontrivial monoid with zero with no divisors, then this implication becomes an `iff`, see `list.prod_eq_zero_iff`.",
    "type": "L.prod = 0"
  },
  {
    "name": "con.symm",
    "statement": "theorem con.symm {M : Type u_1} [has_mul M] (c : con M) {x y : M} : ⇑c x y → ⇑c y x",
    "theorem": "{M : Type u_1} [has_mul M] (c : con M) {x y : M} : ⇑c x y → ⇑c y x",
    "args": "{M : Type u_1} [has_mul M] (c : con M) {x y : M}",
    "doc_string": "Congruence relations are symmetric.",
    "type": "⇑c x y → ⇑c y x"
  },
  {
    "name": "function.bij_on_fixed_pts_comp",
    "statement": "theorem function.bij_on_fixed_pts_comp {α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))",
    "args": "{α : Type u} {β : Type v} (f : α → β) (g : β → α)",
    "doc_string": " Given two maps `f : α → β` and `g : β → α`, `g` is a bijective map between the fixed points of `f ∘ g` and the fixed points of `g ∘ f`. The inverse map is `f`, see `inv_on_fixed_pts_comp`.",
    "type": "set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))"
  },
  {
    "name": "complex.conj_conj",
    "statement": "theorem complex.conj_conj {R : Type u} [comm_semiring R] [star_ring R] (x : R) : ⇑(star_ring_end R) (⇑(star_ring_end R) x) = x",
    "theorem": "{R : Type u} [comm_semiring R] [star_ring R] (x : R) : ⇑(star_ring_end R) (⇑(star_ring_end R) x) = x",
    "args": "{R : Type u} [comm_semiring R] [star_ring R] (x : R)",
    "doc_string": "**Alias** of star_ring_end_self_apply`.",
    "type": "⇑(star_ring_end R) (⇑(star_ring_end R) x) = x"
  },
  {
    "name": "category_theory.grothendieck_topology.superset_covering",
    "statement": "theorem category_theory.grothendieck_topology.superset_covering {C : Type u} [category_theory.category C] {X : C} {S R : category_theory.sieve X} (J : category_theory.grothendieck_topology C) (Hss : S ≤ R) (sjx : S ∈ ⇑J X) : R ∈ ⇑J X",
    "theorem": "{C : Type u} [category_theory.category C] {X : C} {S R : category_theory.sieve X} (J : category_theory.grothendieck_topology C) (Hss : S ≤ R) (sjx : S ∈ ⇑J X) : R ∈ ⇑J X",
    "args": "{C : Type u} [category_theory.category C] {X : C} {S R : category_theory.sieve X} (J : category_theory.grothendieck_topology C) (Hss : S ≤ R) (sjx : S ∈ ⇑J X)",
    "doc_string": "If `S` is a subset of `R`, and `S` is covering, then `R` is covering as well.  See <https://stacks.math.columbia.edu/tag/00Z5> (2), or discussion after [MM92] Chapter III, Section 2, Definition 1.",
    "type": "R ∈ ⇑J X"
  },
  {
    "name": "free_group.of_injective",
    "statement": "theorem free_group.of_injective {α : Type u} : function.injective free_group.of",
    "theorem": "{α : Type u} : function.injective free_group.of",
    "args": "{α : Type u}",
    "doc_string": "The canonical injection from the type to the free group is an injection.",
    "type": "function.injective free_group.of"
  },
  {
    "name": "mul_eq_zero_comm",
    "statement": "theorem mul_eq_zero_comm {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b = 0 ↔ b * a = 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b = 0 ↔ b * a = 0",
    "args": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀}",
    "doc_string": " If `α` has no zero divisors, then for elements `a, b : α`, `a * b` equals zero iff so is `b * a`.",
    "type": "a * b = 0 ↔ b * a = 0"
  },
  {
    "name": "is_unit.mul_right_dvd",
    "statement": "theorem is_unit.mul_right_dvd {α : Type u_1} [monoid α] {a b u : α} (hu : is_unit u) : a * u ∣ b ↔ a ∣ b",
    "theorem": "{α : Type u_1} [monoid α] {a b u : α} (hu : is_unit u) : a * u ∣ b ↔ a ∣ b",
    "args": "{α : Type u_1} [monoid α] {a b u : α} (hu : is_unit u)",
    "doc_string": "In a monoid, an element a divides an element b iff all associates of `a` divide `b`.",
    "type": "a * u ∣ b ↔ a ∣ b"
  },
  {
    "name": "is_smul_regular.pow",
    "statement": "theorem is_smul_regular.pow {R : Type u_1} {M : Type u_3} {a : R} [monoid R] [mul_action R M] (n : ℕ) (ra : is_smul_regular M a) : is_smul_regular M (a ^ n)",
    "theorem": "{R : Type u_1} {M : Type u_3} {a : R} [monoid R] [mul_action R M] (n : ℕ) (ra : is_smul_regular M a) : is_smul_regular M (a ^ n)",
    "args": "{R : Type u_1} {M : Type u_3} {a : R} [monoid R] [mul_action R M] (n : ℕ) (ra : is_smul_regular M a)",
    "doc_string": "Any power of an `M`-regular element is `M`-regular.",
    "type": "is_smul_regular M (a ^ n)"
  },
  {
    "name": "exp_char_one_iff_char_zero",
    "statement": "theorem exp_char_one_iff_char_zero (R : Type u) [semiring R] [nontrivial R] (p q : ℕ) [char_p R p] [exp_char R q] : q = 1 ↔ p = 0",
    "theorem": "(R : Type u) [semiring R] [nontrivial R] (p q : ℕ) [char_p R p] [exp_char R q] : q = 1 ↔ p = 0",
    "args": "(R : Type u) [semiring R] [nontrivial R] (p q : ℕ) [char_p R p] [exp_char R q]",
    "doc_string": "The exponential characteristic is one iff the characteristic is zero.",
    "type": "q = 1 ↔ p = 0"
  },
  {
    "name": "is_chain.exists_max_chain",
    "statement": "theorem is_chain.exists_max_chain {α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) : ∃ (M : set α), is_max_chain r M ∧ c ⊆ M",
    "theorem": "{α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) : ∃ (M : set α), is_max_chain r M ∧ c ⊆ M",
    "args": "{α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c)",
    "doc_string": "Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.",
    "type": "∃ (M : set α), is_max_chain r M ∧ c ⊆ M"
  },
  {
    "name": "interior_frontier",
    "statement": "theorem interior_frontier {α : Type u} [topological_space α] {s : set α} (h : is_closed s) : interior (frontier s) = ∅",
    "theorem": "{α : Type u} [topological_space α] {s : set α} (h : is_closed s) : interior (frontier s) = ∅",
    "args": "{α : Type u} [topological_space α] {s : set α} (h : is_closed s)",
    "doc_string": "The frontier of a closed set has no interior point.",
    "type": "interior (frontier s) = ∅"
  },
  {
    "name": "category_theory.limits.has_finite_biproducts.of_has_finite_products",
    "statement": "theorem category_theory.limits.has_finite_biproducts.of_has_finite_products {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C] : category_theory.limits.has_finite_biproducts C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C] : category_theory.limits.has_finite_biproducts C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C]",
    "doc_string": "A preadditive category with finite products has finite biproducts.",
    "type": "category_theory.limits.has_finite_biproducts C"
  },
  {
    "name": "metric.uniform_continuous_inf_dist_pt",
    "statement": "theorem metric.uniform_continuous_inf_dist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_dist x s)",
    "theorem": "{α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_dist x s)",
    "args": "{α : Type u} [pseudo_metric_space α] (s : set α)",
    "doc_string": "The minimal distance to a set is uniformly continuous in point",
    "type": "uniform_continuous (λ (x : α), metric.inf_dist x s)"
  },
  {
    "name": "ordinal.principal_mul_iff_le_two_or_omega_opow_opow",
    "statement": "theorem ordinal.principal_mul_iff_le_two_or_omega_opow_opow {o : ordinal} : ordinal.principal has_mul.mul o ↔ o ≤ 2 ∨ ∃ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a",
    "theorem": "{o : ordinal} : ordinal.principal has_mul.mul o ↔ o ≤ 2 ∨ ∃ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a",
    "args": "{o : ordinal}",
    "doc_string": "The main characterization theorem for multiplicative principal ordinals.",
    "type": "ordinal.principal has_mul.mul o ↔ o ≤ 2 ∨ ∃ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a"
  },
  {
    "name": "discrete_valuation_ring.exists_irreducible",
    "statement": "theorem discrete_valuation_ring.exists_irreducible (R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : ∃ (ϖ : R), irreducible ϖ",
    "theorem": "(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : ∃ (ϖ : R), irreducible ϖ",
    "args": "(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R]",
    "doc_string": "Uniformisers exist in a DVR",
    "type": "∃ (ϖ : R), irreducible ϖ"
  },
  {
    "name": "right.one_le_mul",
    "statement": "theorem right.one_le_mul {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.one_le_mul`.",
    "type": "1 ≤ a * b"
  },
  {
    "name": "zero_lt.left.mul_le_one_of_le_of_le",
    "statement": "theorem zero_lt.left.mul_le_one_of_le_of_le {α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 ≤ a) : a * b ≤ 1",
    "theorem": "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 ≤ a) : a * b ≤ 1",
    "args": "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 ≤ a)",
    "doc_string": "Assumes left covariance.",
    "type": "a * b ≤ 1"
  },
  {
    "name": "bounded_continuous_function.continuous_eval",
    "statement": "theorem bounded_continuous_function.continuous_eval {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] : continuous (λ (p : bounded_continuous_function α β × α), ⇑(p.fst) p.snd)",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] : continuous (λ (p : bounded_continuous_function α β × α), ⇑(p.fst) p.snd)",
    "args": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β]",
    "doc_string": "The evaluation map is continuous, as a joint function of `u` and `x`",
    "type": "continuous (λ (p : bounded_continuous_function α β × α), ⇑(p.fst) p.snd)"
  },
  {
    "name": "vector.map_id",
    "statement": "theorem vector.map_id {α : Type u_1} {n : ℕ} (v : vector α n) : vector.map id v = v",
    "theorem": "{α : Type u_1} {n : ℕ} (v : vector α n) : vector.map id v = v",
    "args": "{α : Type u_1} {n : ℕ} (v : vector α n)",
    "doc_string": "Mapping under `id` does not change a vector.",
    "type": "vector.map id v = v"
  },
  {
    "name": "is_submonoid.list_prod_mem",
    "statement": "theorem is_submonoid.list_prod_mem {M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M} : (∀ (x : M), x ∈ l → x ∈ s) → l.prod ∈ s",
    "theorem": "{M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M} : (∀ (x : M), x ∈ l → x ∈ s) → l.prod ∈ s",
    "args": "{M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M}",
    "doc_string": "The product of a list of elements of a submonoid is an element of the submonoid.",
    "type": "(∀ (x : M), x ∈ l → x ∈ s) → l.prod ∈ s"
  },
  {
    "name": "iterated_deriv_succ",
    "statement": "theorem iterated_deriv_succ {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} : iterated_deriv (n + 1) f = deriv (iterated_deriv n f)",
    "theorem": "{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} : iterated_deriv (n + 1) f = deriv (iterated_deriv n f)",
    "args": "{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F}",
    "doc_string": " The `n+1`-th iterated derivative can be obtained by differentiating the `n`-th iterated derivative.",
    "type": "iterated_deriv (n + 1) f = deriv (iterated_deriv n f)"
  },
  {
    "name": "is_group_hom.map_one",
    "statement": "theorem is_group_hom.map_one {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : f 1 = 1",
    "theorem": "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : f 1 = 1",
    "args": "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f)",
    "doc_string": "A group homomorphism sends 1 to 1.",
    "type": "f 1 = 1"
  },
  {
    "name": "nonneg_of_neg_nonpos",
    "statement": "theorem nonneg_of_neg_nonpos {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : -a ≤ 0 → 0 ≤ a",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : -a ≤ 0 → 0 ≤ a",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α}",
    "doc_string": "**Alias** of the forward direction of left.inv_le_one_iff`.",
    "type": "-a ≤ 0 → 0 ≤ a"
  },
  {
    "name": "ufm_of_gcd_of_wf_dvd_monoid",
    "statement": "theorem ufm_of_gcd_of_wf_dvd_monoid {α : Type u_1} [cancel_comm_monoid_with_zero α] [wf_dvd_monoid α] [gcd_monoid α] : unique_factorization_monoid α",
    "theorem": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [wf_dvd_monoid α] [gcd_monoid α] : unique_factorization_monoid α",
    "args": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [wf_dvd_monoid α] [gcd_monoid α]",
    "doc_string": "Can't be an instance because it would cause a loop `ufm → wf_dvd_monoid → ufm → ...`.",
    "type": "unique_factorization_monoid α"
  },
  {
    "name": "category_theory.essentially_small_iff",
    "statement": "theorem category_theory.essentially_small_iff (C : Type u) [category_theory.category C] : category_theory.essentially_small C ↔ small (category_theory.skeleton C) ∧ category_theory.locally_small C",
    "theorem": "(C : Type u) [category_theory.category C] : category_theory.essentially_small C ↔ small (category_theory.skeleton C) ∧ category_theory.locally_small C",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category is essentially small if and only if the underlying type of its skeleton (i.e. the \"set\" of isomorphism classes) is small, and it is locally small.",
    "type": "category_theory.essentially_small C ↔ small (category_theory.skeleton C) ∧ category_theory.locally_small C"
  },
  {
    "name": "lt_neg_add_of_add_lt",
    "statement": "theorem lt_neg_add_of_add_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a + b < c → b < -a + c",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a + b < c → b < -a + c",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of lt_inv_mul_iff_mul_lt`.",
    "type": "a + b < c → b < -a + c"
  },
  {
    "name": "btw_cyclic",
    "statement": "theorem btw_cyclic {α : Type u_1} [circular_preorder α] {a b c : α} : has_btw.btw a b c ↔ has_btw.btw c a b",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} : has_btw.btw a b c ↔ has_btw.btw c a b",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α}",
    "doc_string": " The order of the `↔` has been chosen so that `rw btw_cyclic` cycles to the right while `rw ←btw_cyclic` cycles to the left (thus following the prepended arrow).",
    "type": "has_btw.btw a b c ↔ has_btw.btw c a b"
  },
  {
    "name": "dihedral_group.order_of_r_one",
    "statement": "theorem dihedral_group.order_of_r_one {n : ℕ} : order_of (dihedral_group.r 1) = n",
    "theorem": "{n : ℕ} : order_of (dihedral_group.r 1) = n",
    "args": "{n : ℕ}",
    "doc_string": "If `0 < n`, then `r 1` has order `n`.",
    "type": "order_of (dihedral_group.r 1) = n"
  },
  {
    "name": "function.surjective.nontrivial",
    "statement": "theorem function.surjective.nontrivial {α : Type u_1} {β : Type u_2} [nontrivial β] {f : α → β} (hf : function.surjective f) : nontrivial α",
    "theorem": "{α : Type u_1} {β : Type u_2} [nontrivial β] {f : α → β} (hf : function.surjective f) : nontrivial α",
    "args": "{α : Type u_1} {β : Type u_2} [nontrivial β] {f : α → β} (hf : function.surjective f)",
    "doc_string": "Pullback a `nontrivial` instance along a surjective function.",
    "type": "nontrivial α"
  },
  {
    "name": "dense.closure",
    "statement": "theorem dense.closure {α : Type u} [topological_space α] {s : set α} : dense s → dense (closure s)",
    "theorem": "{α : Type u} [topological_space α] {s : set α} : dense s → dense (closure s)",
    "args": "{α : Type u} [topological_space α] {s : set α}",
    "doc_string": "**Alias** of the reverse direction of dense_closure`.",
    "type": "dense s → dense (closure s)"
  },
  {
    "name": "finset.card_powerset",
    "statement": "theorem finset.card_powerset {α : Type u_1} (s : finset α) : s.powerset.card = 2 ^ s.card",
    "theorem": "{α : Type u_1} (s : finset α) : s.powerset.card = 2 ^ s.card",
    "args": "{α : Type u_1} (s : finset α)",
    "doc_string": "**Number of Subsets of a Set**",
    "type": "s.powerset.card = 2 ^ s.card"
  },
  {
    "name": "is_unit.dvd",
    "statement": "theorem is_unit.dvd {α : Type u_1} [monoid α] {a u : α} (hu : is_unit u) : u ∣ a",
    "theorem": "{α : Type u_1} [monoid α] {a u : α} (hu : is_unit u) : u ∣ a",
    "args": "{α : Type u_1} [monoid α] {a u : α} (hu : is_unit u)",
    "doc_string": "Units of a monoid divide any element of the monoid.",
    "type": "u ∣ a"
  },
  {
    "name": "eq_zero_of_same_ray_self_neg",
    "statement": "theorem eq_zero_of_same_ray_self_neg {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x : M} [no_zero_smul_divisors R M] (h : same_ray R x (-x)) : x = 0",
    "theorem": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x : M} [no_zero_smul_divisors R M] (h : same_ray R x (-x)) : x = 0",
    "args": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x : M} [no_zero_smul_divisors R M] (h : same_ray R x (-x))",
    "doc_string": "If a vector is in the same ray as its negation, that vector is zero.",
    "type": "x = 0"
  },
  {
    "name": "fin.antitone_iff_succ_le",
    "statement": "theorem fin.antitone_iff_succ_le {n : ℕ} {α : Type u_1} [preorder α] {f : fin (n + 1) → α} : antitone f ↔ ∀ (i : fin n), f i.succ ≤ f (⇑fin.cast_succ i)",
    "theorem": "{n : ℕ} {α : Type u_1} [preorder α] {f : fin (n + 1) → α} : antitone f ↔ ∀ (i : fin n), f i.succ ≤ f (⇑fin.cast_succ i)",
    "args": "{n : ℕ} {α : Type u_1} [preorder α] {f : fin (n + 1) → α}",
    "doc_string": "A function `f` on `fin (n + 1)` is antitone if and only if `f (i + 1) ≤ f i` for all `i`.",
    "type": "antitone f ↔ ∀ (i : fin n), f i.succ ≤ f (⇑fin.cast_succ i)"
  },
  {
    "name": "is_square_zero",
    "statement": "theorem is_square_zero (M : Type u_1) [monoid_with_zero M] : is_square 0",
    "theorem": "(M : Type u_1) [monoid_with_zero M] : is_square 0",
    "args": "(M : Type u_1) [monoid_with_zero M]",
    "doc_string": "`0` is always a square (in a monoid with zero).",
    "type": "is_square 0"
  },
  {
    "name": "is_regular.pow_iff",
    "statement": "theorem is_regular.pow_iff {R : Type u_1} {a : R} [monoid R] {n : ℕ} (n0 : 0 < n) : is_regular (a ^ n) ↔ is_regular a",
    "theorem": "{R : Type u_1} {a : R} [monoid R] {n : ℕ} (n0 : 0 < n) : is_regular (a ^ n) ↔ is_regular a",
    "args": "{R : Type u_1} {a : R} [monoid R] {n : ℕ} (n0 : 0 < n)",
    "doc_string": "An element `a` is regular if and only if a positive power of `a` is regular.",
    "type": "is_regular (a ^ n) ↔ is_regular a"
  },
  {
    "name": "category_theory.is_subterminal_of_mono_terminal_from",
    "statement": "theorem category_theory.is_subterminal_of_mono_terminal_from {C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A",
    "theorem": "{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A",
    "args": "{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)]",
    "doc_string": "If the unique morphism from `A` to the terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_terminal_from`.",
    "type": "category_theory.is_subterminal A"
  },
  {
    "name": "linear_map.det_zero",
    "statement": "theorem linear_map.det_zero {𝕜 : Type u_1} [field 𝕜] {M : Type u_2} [add_comm_group M] [module 𝕜 M] : ⇑linear_map.det 0 = 0 ^ finite_dimensional.finrank 𝕜 M",
    "theorem": "{𝕜 : Type u_1} [field 𝕜] {M : Type u_2} [add_comm_group M] [module 𝕜 M] : ⇑linear_map.det 0 = 0 ^ finite_dimensional.finrank 𝕜 M",
    "args": "{𝕜 : Type u_1} [field 𝕜] {M : Type u_2} [add_comm_group M] [module 𝕜 M]",
    "doc_string": " In a finite-dimensional vector space, the zero map has determinant `1` in dimension `0`, and `0` otherwise. We give a formula that also works in infinite dimension, where we define the determinant to be `1`.",
    "type": "⇑linear_map.det 0 = 0 ^ finite_dimensional.finrank 𝕜 M"
  },
  {
    "name": "group.normal_closure.is_subgroup",
    "statement": "theorem group.normal_closure.is_subgroup {G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s)",
    "theorem": "{G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s)",
    "args": "{G : Type u_1} [group G] (s : set G)",
    "doc_string": "The normal closure of a set is a subgroup.",
    "type": "is_subgroup (group.normal_closure s)"
  },
  {
    "name": "nat.cast_le_pow_div_sub",
    "statement": "theorem nat.cast_le_pow_div_sub {K : Type u_1} [linear_ordered_field K] {a : K} (H : 1 < a) (n : ℕ) : ↑n ≤ a ^ n / (a - 1)",
    "theorem": "{K : Type u_1} [linear_ordered_field K] {a : K} (H : 1 < a) (n : ℕ) : ↑n ≤ a ^ n / (a - 1)",
    "args": "{K : Type u_1} [linear_ordered_field K] {a : K} (H : 1 < a) (n : ℕ)",
    "doc_string": " For any `a > 1` and a natural `n` we have `n ≤ a ^ n / (a - 1)`. See also `nat.cast_le_pow_sub_div_sub` for a stronger inequality with `a ^ n - 1` in the numerator.",
    "type": "↑n ≤ a ^ n / (a - 1)"
  },
  {
    "name": "real.cos_pi_div_three",
    "statement": "theorem real.cos_pi_div_three  : real.cos (real.pi / 3) = 1 / 2",
    "theorem": " : real.cos (real.pi / 3) = 1 / 2",
    "args": "",
    "doc_string": "The cosine of `π / 3` is `1 / 2`.",
    "type": "real.cos (real.pi / 3) = 1 / 2"
  },
  {
    "name": "nat.pow_two_sub_pow_two",
    "statement": "theorem nat.pow_two_sub_pow_two (a b : ℕ) : a ^ 2 - b ^ 2 = (a + b) * (a - b)",
    "theorem": "(a b : ℕ) : a ^ 2 - b ^ 2 = (a + b) * (a - b)",
    "args": "(a b : ℕ)",
    "doc_string": "**Alias** of nat.sq_sub_sq`.",
    "type": "a ^ 2 - b ^ 2 = (a + b) * (a - b)"
  },
  {
    "name": "category_theory.limits.has_pullbacks_of_has_binary_products_of_has_equalizers",
    "statement": "theorem category_theory.limits.has_pullbacks_of_has_binary_products_of_has_equalizers (C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_pullbacks C",
    "theorem": "(C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_pullbacks C",
    "args": "(C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C]",
    "doc_string": "If a category has all binary products and all equalizers, then it also has all pullbacks.    As usual, this is not an instance, since there may be a more direct way to construct    pullbacks.",
    "type": "category_theory.limits.has_pullbacks C"
  },
  {
    "name": "loc_compact_Haus_tot_disc_of_zero_dim",
    "statement": "theorem loc_compact_Haus_tot_disc_of_zero_dim {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s}",
    "theorem": "{H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s}",
    "args": "{H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H]",
    "doc_string": "A locally compact Hausdorff totally disconnected space has a basis with clopen elements.",
    "type": "topological_space.is_topological_basis {s : set H | is_clopen s}"
  },
  {
    "name": "bounded_continuous_function.dist_coe_le_dist",
    "statement": "theorem bounded_continuous_function.dist_coe_le_dist {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} (x : α) : has_dist.dist (⇑f x) (⇑g x) ≤ has_dist.dist f g",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} (x : α) : has_dist.dist (⇑f x) (⇑g x) ≤ has_dist.dist f g",
    "args": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} (x : α)",
    "doc_string": "The pointwise distance is controlled by the distance between functions, by definition.",
    "type": "has_dist.dist (⇑f x) (⇑g x) ≤ has_dist.dist f g"
  },
  {
    "name": "category_theory.limits.has_limits_of_size_shrink",
    "statement": "theorem category_theory.limits.has_limits_of_size_shrink (C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C]",
    "doc_string": "`has_limits_of_size_shrink.{v u} C` tries to obtain `has_limits_of_size.{v u} C` from some other `has_limits_of_size C`.",
    "type": "category_theory.limits.has_limits_of_size C"
  },
  {
    "name": "lt_tsub_iff_right",
    "statement": "theorem lt_tsub_iff_right {α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] : a < b - c ↔ a + c < b",
    "theorem": "{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] : a < b - c ↔ a + c < b",
    "args": "{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α]",
    "doc_string": "See `lt_tsub_iff_right_of_le` for a weaker statement in a partial order.",
    "type": "a < b - c ↔ a + c < b"
  },
  {
    "name": "con.refl",
    "statement": "theorem con.refl {M : Type u_1} [has_mul M] (c : con M) (x : M) : ⇑c x x",
    "theorem": "{M : Type u_1} [has_mul M] (c : con M) (x : M) : ⇑c x x",
    "args": "{M : Type u_1} [has_mul M] (c : con M) (x : M)",
    "doc_string": "Congruence relations are reflexive.",
    "type": "⇑c x x"
  },
  {
    "name": "finite_dimensional.fact_finite_dimensional_of_finrank_eq_succ",
    "statement": "theorem finite_dimensional.fact_finite_dimensional_of_finrank_eq_succ {K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] (n : ℕ) [fact (finite_dimensional.finrank K V = n + 1)] : finite_dimensional K V",
    "theorem": "{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] (n : ℕ) [fact (finite_dimensional.finrank K V = n + 1)] : finite_dimensional K V",
    "args": "{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] (n : ℕ) [fact (finite_dimensional.finrank K V = n + 1)]",
    "doc_string": " We can infer `finite_dimensional K V` in the presence of `[fact (finrank K V = n + 1)]`. Declare this as a local instance where needed.",
    "type": "finite_dimensional K V"
  },
  {
    "name": "has_lt.lt.le",
    "statement": "theorem has_lt.lt.le {α : Type u} [preorder α] {a b : α} : a < b → a ≤ b",
    "theorem": "{α : Type u} [preorder α] {a b : α} : a < b → a ≤ b",
    "args": "{α : Type u} [preorder α] {a b : α}",
    "doc_string": "**Alias** of le_of_lt`.",
    "type": "a < b → a ≤ b"
  },
  {
    "name": "is_add_regular_of_cancel_add_monoid",
    "statement": "theorem is_add_regular_of_cancel_add_monoid {R : Type u_1} [add_cancel_monoid R] (g : R) : is_add_regular g",
    "theorem": "{R : Type u_1} [add_cancel_monoid R] (g : R) : is_add_regular g",
    "args": "{R : Type u_1} [add_cancel_monoid R] (g : R)",
    "doc_string": "Elements of an add cancel monoid are regular.  Add cancel semigroups do not appear to exist.",
    "type": "is_add_regular g"
  },
  {
    "name": "zsmul_right_injective",
    "statement": "theorem zsmul_right_injective {α : Type u_1} [linear_ordered_add_comm_group α] {n : ℤ} (hn : n ≠ 0) : function.injective (λ (_x : α), n • _x)",
    "theorem": "{α : Type u_1} [linear_ordered_add_comm_group α] {n : ℤ} (hn : n ≠ 0) : function.injective (λ (_x : α), n • _x)",
    "args": "{α : Type u_1} [linear_ordered_add_comm_group α] {n : ℤ} (hn : n ≠ 0)",
    "doc_string": "See also `smul_right_injective`. TODO: provide a `no_zero_smul_divisors` instance. We can't do that here because importing that definition would create import cycles.",
    "type": "function.injective (λ (_x : α), n • _x)"
  },
  {
    "name": "right.add_neg_of_nonpos_of_neg",
    "statement": "theorem right.add_neg_of_nonpos_of_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b < 0)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_neg_of_nonpos_of_neg`.",
    "type": "a + b < 0"
  },
  {
    "name": "inv_of_one_lt_inv",
    "statement": "theorem inv_of_one_lt_inv {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ → a < 1",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ → a < 1",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α}",
    "doc_string": "**Alias** of the forward direction of left.one_lt_inv_iff`.",
    "type": "1 < a⁻¹ → a < 1"
  },
  {
    "name": "directed_on.directed_coe",
    "statement": "theorem directed_on.directed_coe {α : Type u} {r : α → α → Prop} {s : set α} : directed_on r s → directed r coe",
    "theorem": "{α : Type u} {r : α → α → Prop} {s : set α} : directed_on r s → directed r coe",
    "args": "{α : Type u} {r : α → α → Prop} {s : set α}",
    "doc_string": "**Alias** of the forward direction of directed_on_iff_directed`.",
    "type": "directed_on r s → directed r coe"
  },
  {
    "name": "is_right_regular_zero_iff_subsingleton",
    "statement": "theorem is_right_regular_zero_iff_subsingleton {R : Type u_1} [mul_zero_class R] : is_right_regular 0 ↔ subsingleton R",
    "theorem": "{R : Type u_1} [mul_zero_class R] : is_right_regular 0 ↔ subsingleton R",
    "args": "{R : Type u_1} [mul_zero_class R]",
    "doc_string": "The element `0` is right-regular if and only if `R` is trivial.",
    "type": "is_right_regular 0 ↔ subsingleton R"
  },
  {
    "name": "left.add_neg'",
    "statement": "theorem left.add_neg' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_neg'`.",
    "type": "a + b < 0"
  },
  {
    "name": "sub_mul_add_eq_of_mul_add_eq_mul_add",
    "statement": "theorem sub_mul_add_eq_of_mul_add_eq_mul_add {α : Type u} [non_unital_non_assoc_ring α] {a b c d e : α} : a * e + c = b * e + d → (a - b) * e + c = d",
    "theorem": "{α : Type u} [non_unital_non_assoc_ring α] {a b c d e : α} : a * e + c = b * e + d → (a - b) * e + c = d",
    "args": "{α : Type u} [non_unital_non_assoc_ring α] {a b c d e : α}",
    "doc_string": "A simplification of one side of an equation exploiting right distributivity in rings  and the definition of subtraction.",
    "type": "a * e + c = b * e + d → (a - b) * e + c = d"
  },
  {
    "name": "collinear_empty",
    "statement": "theorem collinear_empty (k : Type u_1) {V : Type u_2} (P : Type u_3) [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] : collinear k ∅",
    "theorem": "(k : Type u_1) {V : Type u_2} (P : Type u_3) [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] : collinear k ∅",
    "args": "(k : Type u_1) {V : Type u_2} (P : Type u_3) [division_ring k] [add_comm_group V] [module k V] [add_torsor V P]",
    "doc_string": "The empty set is collinear.",
    "type": "collinear k ∅"
  },
  {
    "name": "right.one_lt_mul",
    "statement": "theorem right.one_lt_mul {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul`.",
    "type": "1 < a * b"
  },
  {
    "name": "left.add_neg_of_neg_of_nonpos",
    "statement": "theorem left.add_neg_of_neg_of_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_neg_of_neg_of_nonpos`.",
    "type": "a + b < 0"
  },
  {
    "name": "category_theory.is_subterminal_of_is_iso_diag",
    "statement": "theorem category_theory.is_subterminal_of_is_iso_diag {C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)] : category_theory.is_subterminal A",
    "theorem": "{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)] : category_theory.is_subterminal A",
    "args": "{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)]",
    "doc_string": "If the diagonal morphism of `A` is an isomorphism, then it is subterminal. The converse of `is_subterminal.is_iso_diag`.",
    "type": "category_theory.is_subterminal A"
  },
  {
    "name": "category_theory.is_subterminal.is_iso_diag",
    "statement": "theorem category_theory.is_subterminal.is_iso_diag {C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A] : category_theory.is_iso (category_theory.limits.diag A)",
    "theorem": "{C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A] : category_theory.is_iso (category_theory.limits.diag A)",
    "args": "{C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A]",
    "doc_string": "If `A` is subterminal, its diagonal morphism is an isomorphism. The converse of `is_subterminal_of_is_iso_diag`.",
    "type": "category_theory.is_iso (category_theory.limits.diag A)"
  },
  {
    "name": "perfection_map.id",
    "statement": "theorem perfection_map.id (p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] [perfect_ring R p] : perfection_map p (ring_hom.id R)",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] [perfect_ring R p] : perfection_map p (ring_hom.id R)",
    "args": "(p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] [perfect_ring R p]",
    "doc_string": "For a perfect ring, it itself is the perfection.",
    "type": "perfection_map p (ring_hom.id R)"
  },
  {
    "name": "is_fraction_ring.char_zero_of_is_fraction_ring",
    "statement": "theorem is_fraction_ring.char_zero_of_is_fraction_ring (R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K",
    "theorem": "(R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K",
    "args": "(R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R]",
    "doc_string": "If `R` has characteristic `0`, then so does Frac(R).",
    "type": "char_zero K"
  },
  {
    "name": "one_lt_inv'",
    "statement": "theorem one_lt_inv' {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α}",
    "doc_string": "**Alias** of left.one_lt_inv_iff`.",
    "type": "1 < a⁻¹ ↔ a < 1"
  },
  {
    "name": "one_div_lt_one_div_of_neg",
    "statement": "theorem one_div_lt_one_div_of_neg {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : a < 0) (hb : b < 0) : 1 / a < 1 / b ↔ b < a",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : a < 0) (hb : b < 0) : 1 / a < 1 / b ↔ b < a",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : a < 0) (hb : b < 0)",
    "doc_string": "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and  `lt_of_one_div_lt_one_div`",
    "type": "1 / a < 1 / b ↔ b < a"
  },
  {
    "name": "convex_independent.injective",
    "statement": "theorem convex_independent.injective {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} (hc : convex_independent 𝕜 p) : function.injective p",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} (hc : convex_independent 𝕜 p) : function.injective p",
    "args": "{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} (hc : convex_independent 𝕜 p)",
    "doc_string": "A convex independent family is injective.",
    "type": "function.injective p"
  },
  {
    "name": "zero_lt.left.mul_lt_one_of_le_of_lt",
    "statement": "theorem zero_lt.left.mul_lt_one_of_le_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a ≤ 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a ≤ 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a ≤ 1) (hb : b < 1) (a0 : 0 < a)",
    "doc_string": "Assumes left covariance.",
    "type": "a * b < 1"
  },
  {
    "name": "is_min.to_dual",
    "statement": "theorem is_min.to_dual {α : Type u_1} [has_le α] {a : α} : is_min a → is_max (⇑order_dual.to_dual a)",
    "theorem": "{α : Type u_1} [has_le α] {a : α} : is_min a → is_max (⇑order_dual.to_dual a)",
    "args": "{α : Type u_1} [has_le α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of is_max_to_dual_iff`.",
    "type": "is_min a → is_max (⇑order_dual.to_dual a)"
  },
  {
    "name": "function.commute.right_bij_on_fixed_pts_comp",
    "statement": "theorem function.commute.right_bij_on_fixed_pts_comp {α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))",
    "theorem": "{α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))",
    "args": "{α : Type u} {f g : α → α} (h : function.commute f g)",
    "doc_string": " If self-maps `f` and `g` commute, then `g` is bijective on the set of fixed points of `f ∘ g`. This is a particular case of `function.bij_on_fixed_pts_comp`.",
    "type": "set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))"
  },
  {
    "name": "add_hom.congr_arg",
    "statement": "theorem add_hom.congr_arg {M : Type u_3} {N : Type u_4} [has_add M] [has_add N] (f : add_hom M N) {x y : M} (h : x = y) : ⇑f x = ⇑f y",
    "theorem": "{M : Type u_3} {N : Type u_4} [has_add M] [has_add N] (f : add_hom M N) {x y : M} (h : x = y) : ⇑f x = ⇑f y",
    "args": "{M : Type u_3} {N : Type u_4} [has_add M] [has_add N] (f : add_hom M N) {x y : M} (h : x = y)",
    "doc_string": "Deprecated: use `fun_like.congr_arg` instead.",
    "type": "⇑f x = ⇑f y"
  },
  {
    "name": "zmod.legendre_sym_neg_one",
    "statement": "theorem zmod.legendre_sym_neg_one (p : ℕ) [fact (nat.prime p)] (hp : p ≠ 2) : zmod.legendre_sym p (-1) = ⇑zmod.χ₄ ↑p",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (hp : p ≠ 2) : zmod.legendre_sym p (-1) = ⇑zmod.χ₄ ↑p",
    "args": "(p : ℕ) [fact (nat.prime p)] (hp : p ≠ 2)",
    "doc_string": "`legendre_sym p (-1)` is given by `χ₄ p`.",
    "type": "zmod.legendre_sym p (-1) = ⇑zmod.χ₄ ↑p"
  },
  {
    "name": "mul_neg_one",
    "statement": "theorem mul_neg_one {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : a * -1 = -a",
    "theorem": "{α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : a * -1 = -a",
    "args": "{α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α)",
    "doc_string": "An element of a ring multiplied by the additive inverse of one is the element's additive  inverse.",
    "type": "a * -1 = -a"
  },
  {
    "name": "three_pos",
    "statement": "theorem three_pos {α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 3",
    "theorem": "{α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 3",
    "args": "{α : Type u} [ordered_semiring α] [nontrivial α]",
    "doc_string": "**Alias** of zero_lt_three`.",
    "type": "0 < 3"
  },
  {
    "name": "finset.max'_singleton",
    "statement": "theorem finset.max'_singleton {α : Type u_1} [linear_order α] (a : α) : {a}.max' _ = a",
    "theorem": "{α : Type u_1} [linear_order α] (a : α) : {a}.max' _ = a",
    "args": "{α : Type u_1} [linear_order α] (a : α)",
    "doc_string": "`{a}.max' _` is `a`.",
    "type": "{a}.max' _ = a"
  },
  {
    "name": "continuous_map.continuous_eval'",
    "statement": "theorem continuous_map.continuous_eval' {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] : continuous (λ (p : C(α, β) × α), ⇑(p.fst) p.snd)",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] : continuous (λ (p : C(α, β) × α), ⇑(p.fst) p.snd)",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α]",
    "doc_string": " The evaluation map `C(α, β) × α → β` is continuous if `α` is locally compact.  See also `continuous_map.continuous_eval`",
    "type": "continuous (λ (p : C(α, β) × α), ⇑(p.fst) p.snd)"
  },
  {
    "name": "add_is_add_left_regular_iff",
    "statement": "theorem add_is_add_left_regular_iff {R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a) : is_add_left_regular (a + b) ↔ is_add_left_regular b",
    "theorem": "{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a) : is_add_left_regular (a + b) ↔ is_add_left_regular b",
    "args": "{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a)",
    "doc_string": "An element is add-left-regular if and only if adding to it on the left a add-left-regular element is add-left-regular.",
    "type": "is_add_left_regular (a + b) ↔ is_add_left_regular b"
  },
  {
    "name": "topological_group.continuous_conj",
    "statement": "theorem topological_group.continuous_conj {G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] (g : G) : continuous (λ (h : G), g * h * g⁻¹)",
    "theorem": "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] (g : G) : continuous (λ (h : G), g * h * g⁻¹)",
    "args": "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] (g : G)",
    "doc_string": "Conjugation by a fixed element is continuous when `mul` is continuous.",
    "type": "continuous (λ (h : G), g * h * g⁻¹)"
  },
  {
    "name": "neg_pow_two",
    "statement": "theorem neg_pow_two {R : Type u₁} [monoid R] [has_distrib_neg R] (a : R) : (-a) ^ 2 = a ^ 2",
    "theorem": "{R : Type u₁} [monoid R] [has_distrib_neg R] (a : R) : (-a) ^ 2 = a ^ 2",
    "args": "{R : Type u₁} [monoid R] [has_distrib_neg R] (a : R)",
    "doc_string": "**Alias** of neg_sq`.",
    "type": "(-a) ^ 2 = a ^ 2"
  },
  {
    "name": "continuous_map.continuous_uncurry",
    "statement": "theorem continuous_map.continuous_uncurry {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space α] [locally_compact_space β] : continuous continuous_map.uncurry",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space α] [locally_compact_space β] : continuous continuous_map.uncurry",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space α] [locally_compact_space β]",
    "doc_string": "The uncurrying process is a continuous map between function spaces.",
    "type": "continuous continuous_map.uncurry"
  },
  {
    "name": "monotone_on.dual_right",
    "statement": "theorem monotone_on.dual_right {α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : monotone_on f s → antitone_on (⇑order_dual.to_dual ∘ f) s",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : monotone_on f s → antitone_on (⇑order_dual.to_dual ∘ f) s",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α}",
    "doc_string": "**Alias** of the reverse direction of antitone_on_to_dual_comp_iff`.",
    "type": "monotone_on f s → antitone_on (⇑order_dual.to_dual ∘ f) s"
  },
  {
    "name": "finite_dimensional.finrank_fin_fun",
    "statement": "theorem finite_dimensional.finrank_fin_fun (K : Type u) [division_ring K] {n : ℕ} : finite_dimensional.finrank K (fin n → K) = n",
    "theorem": "(K : Type u) [division_ring K] {n : ℕ} : finite_dimensional.finrank K (fin n → K) = n",
    "args": "(K : Type u) [division_ring K] {n : ℕ}",
    "doc_string": "The vector space of functions on `fin n` has finrank equal to `n`.",
    "type": "finite_dimensional.finrank K (fin n → K) = n"
  },
  {
    "name": "multiples.add_mem",
    "statement": "theorem multiples.add_mem {M : Type u_1} [add_monoid M] {x y z : M} : y ∈ multiples x → z ∈ multiples x → y + z ∈ multiples x",
    "theorem": "{M : Type u_1} [add_monoid M] {x y z : M} : y ∈ multiples x → z ∈ multiples x → y + z ∈ multiples x",
    "args": "{M : Type u_1} [add_monoid M] {x y z : M}",
    "doc_string": "The set of natural number multiples of an element of an `add_monoid` is closed under addition.",
    "type": "y ∈ multiples x → z ∈ multiples x → y + z ∈ multiples x"
  },
  {
    "name": "left.one_le_inv_iff",
    "statement": "theorem left.one_le_inv_iff {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α}",
    "doc_string": "Uses `left` co(ntra)variant.",
    "type": "1 ≤ a⁻¹ ↔ a ≤ 1"
  },
  {
    "name": "metric.Hausdorff_dist_empty'",
    "statement": "theorem metric.Hausdorff_dist_empty' {α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist ∅ s = 0",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist ∅ s = 0",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α}",
    "doc_string": " The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable value ∞ instead, use `Hausdorff_edist`, which takes values in ℝ≥0∞)",
    "type": "metric.Hausdorff_dist ∅ s = 0"
  },
  {
    "name": "module.End.eigenspaces_independent",
    "statement": "theorem module.End.eigenspaces_independent {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) : complete_lattice.independent f.eigenspace",
    "theorem": "{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) : complete_lattice.independent f.eigenspace",
    "args": "{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V)",
    "doc_string": " The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is, any eigenspace has trivial intersection with the span of all the other eigenspaces.",
    "type": "complete_lattice.independent f.eigenspace"
  },
  {
    "name": "zero_lt.left.one_lt_mul_of_lt_of_lt",
    "statement": "theorem zero_lt.left.one_lt_mul_of_lt_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 < a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 < a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 < a) (hb : 1 < b) (a0 : 0 < a)",
    "doc_string": "Assumes left covariance.",
    "type": "1 < a * b"
  },
  {
    "name": "fin.cons_snoc_eq_snoc_cons",
    "statement": "theorem fin.cons_snoc_eq_snoc_cons {n : ℕ} {β : Type u_1} (a : β) (q : fin n → β) (b : β) : fin.cons a (fin.snoc q b) = fin.snoc (fin.cons a q) b",
    "theorem": "{n : ℕ} {β : Type u_1} (a : β) (q : fin n → β) (b : β) : fin.cons a (fin.snoc q b) = fin.snoc (fin.cons a q) b",
    "args": "{n : ℕ} {β : Type u_1} (a : β) (q : fin n → β) (b : β)",
    "doc_string": " `cons` and `snoc` commute. We state this lemma in a non-dependent setting, as otherwise it would involve a cast to convince Lean that the two types are equal, making it harder to use.",
    "type": "fin.cons a (fin.snoc q b) = fin.snoc (fin.cons a q) b"
  },
  {
    "name": "nat.squarefree_mul",
    "statement": "theorem nat.squarefree_mul {m n : ℕ} (hmn : m.coprime n) : squarefree (m * n) ↔ squarefree m ∧ squarefree n",
    "theorem": "{m n : ℕ} (hmn : m.coprime n) : squarefree (m * n) ↔ squarefree m ∧ squarefree n",
    "args": "{m n : ℕ} (hmn : m.coprime n)",
    "doc_string": " `squarefree` is multiplicative. Note that the → direction does not require `hmn` and generalizes to arbitrary commutative monoids. See `squarefree.of_mul_left` and `squarefree.of_mul_right` above for auxiliary lemmas.",
    "type": "squarefree (m * n) ↔ squarefree m ∧ squarefree n"
  },
  {
    "name": "category_theory.limits.has_finite_coproducts_of_has_coproducts",
    "statement": "theorem category_theory.limits.has_finite_coproducts_of_has_coproducts (C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.limits.has_finite_coproducts C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.limits.has_finite_coproducts C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C]",
    "doc_string": "If a category has all coproducts then in particular it has finite coproducts.",
    "type": "category_theory.limits.has_finite_coproducts C"
  },
  {
    "name": "seq.ge_stable",
    "statement": "theorem seq.ge_stable {α : Type u} (s : seq α) {aₙ : α} {n m : ℕ} (m_le_n : m ≤ n) (s_nth_eq_some : s.nth n = option.some aₙ) : ∃ (aₘ : α), s.nth m = option.some aₘ",
    "theorem": "{α : Type u} (s : seq α) {aₙ : α} {n m : ℕ} (m_le_n : m ≤ n) (s_nth_eq_some : s.nth n = option.some aₙ) : ∃ (aₘ : α), s.nth m = option.some aₘ",
    "args": "{α : Type u} (s : seq α) {aₙ : α} {n m : ℕ} (m_le_n : m ≤ n) (s_nth_eq_some : s.nth n = option.some aₙ)",
    "doc_string": "If `s.nth n = some aₙ` for some value `aₙ`, then there is also some value `aₘ` such that `s.nth = some aₘ` for `m ≤ n`.",
    "type": "∃ (aₘ : α), s.nth m = option.some aₘ"
  },
  {
    "name": "nat.not_exists_sq",
    "statement": "theorem nat.not_exists_sq {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n",
    "theorem": "{n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n",
    "args": "{n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1))",
    "doc_string": "There are no perfect squares strictly between m² and (m+1)²",
    "type": "¬∃ (t : ℕ), t * t = n"
  },
  {
    "name": "complete_space_of_is_complete_univ",
    "statement": "theorem complete_space_of_is_complete_univ {α : Type u} [uniform_space α] (h : is_complete set.univ) : complete_space α",
    "theorem": "{α : Type u} [uniform_space α] (h : is_complete set.univ) : complete_space α",
    "args": "{α : Type u} [uniform_space α] (h : is_complete set.univ)",
    "doc_string": "If `univ` is complete, the space is a complete space",
    "type": "complete_space α"
  },
  {
    "name": "multiset.Ico_eq_zero",
    "statement": "theorem multiset.Ico_eq_zero {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → multiset.Ico a b = 0",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → multiset.Ico a b = 0",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of multiset.Ico_eq_zero_iff`.",
    "type": "¬a < b → multiset.Ico a b = 0"
  },
  {
    "name": "finite_dimensional.finrank_pos_iff_exists_ne_zero",
    "statement": "theorem finite_dimensional.finrank_pos_iff_exists_ne_zero {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ ∃ (x : V), x ≠ 0",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ ∃ (x : V), x ≠ 0",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V]",
    "doc_string": "A finite dimensional space has positive `finrank` iff it has a nonzero element.",
    "type": "0 < finite_dimensional.finrank K V ↔ ∃ (x : V), x ≠ 0"
  },
  {
    "name": "padic_val_rat.finite_int_prime_iff",
    "statement": "theorem padic_val_rat.finite_int_prime_iff {p : ℕ} [p_prime : fact (nat.prime p)] {a : ℤ} : multiplicity.finite ↑p a ↔ a ≠ 0",
    "theorem": "{p : ℕ} [p_prime : fact (nat.prime p)] {a : ℤ} : multiplicity.finite ↑p a ↔ a ≠ 0",
    "args": "{p : ℕ} [p_prime : fact (nat.prime p)] {a : ℤ}",
    "doc_string": "The multiplicity of `p : ℕ` in `a : ℤ` is finite exactly when `a ≠ 0`.",
    "type": "multiplicity.finite ↑p a ↔ a ≠ 0"
  },
  {
    "name": "char.quadratic_char_sq_one",
    "statement": "theorem char.quadratic_char_sq_one {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a ^ 2 = 1",
    "theorem": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a ^ 2 = 1",
    "args": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0)",
    "doc_string": "The square of the quadratic character on nonzero arguments is `1`.",
    "type": "char.quadratic_char F a ^ 2 = 1"
  },
  {
    "name": "generalized_continued_fraction.int_fract_pair.nth_stream_fr_nonneg_lt_one",
    "statement": "theorem generalized_continued_fraction.int_fract_pair.nth_stream_fr_nonneg_lt_one {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 ≤ ifp_n.fr ∧ ifp_n.fr < 1",
    "theorem": "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 ≤ ifp_n.fr ∧ ifp_n.fr < 1",
    "args": "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n)",
    "doc_string": "Shows that the fractional parts of the stream are in `[0,1)`.",
    "type": "0 ≤ ifp_n.fr ∧ ifp_n.fr < 1"
  },
  {
    "name": "matrix.is_unit_iff_is_unit_det",
    "statement": "theorem matrix.is_unit_iff_is_unit_det {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) : is_unit A ↔ is_unit A.det",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) : is_unit A ↔ is_unit A.det",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α)",
    "doc_string": "When lowered to a prop, `matrix.invertible_equiv_det_invertible` forms an `iff`.",
    "type": "is_unit A ↔ is_unit A.det"
  },
  {
    "name": "function.cantor_injective",
    "statement": "theorem function.cantor_injective {α : Type u_1} (f : set α → α) : ¬function.injective f",
    "theorem": "{α : Type u_1} (f : set α → α) : ¬function.injective f",
    "args": "{α : Type u_1} (f : set α → α)",
    "doc_string": " **Cantor's diagonal argument** implies that there are no injective functions from `set α` to `α`.",
    "type": "¬function.injective f"
  },
  {
    "name": "order.lt_succ_of_not_is_max",
    "statement": "theorem order.lt_succ_of_not_is_max {α : Type u_1} [preorder α] [succ_order α] {a : α} : ¬is_max a → a < order.succ a",
    "theorem": "{α : Type u_1} [preorder α] [succ_order α] {a : α} : ¬is_max a → a < order.succ a",
    "args": "{α : Type u_1} [preorder α] [succ_order α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of order.lt_succ_iff_not_is_max`.",
    "type": "¬is_max a → a < order.succ a"
  },
  {
    "name": "seq_continuous.continuous",
    "statement": "theorem seq_continuous.continuous {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : seq_continuous f → continuous f",
    "theorem": "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : seq_continuous f → continuous f",
    "args": "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X]",
    "doc_string": "**Alias** of the reverse direction of continuous_iff_seq_continuous`.",
    "type": "seq_continuous f → continuous f"
  },
  {
    "name": "add_order_of_pos",
    "statement": "theorem add_order_of_pos {G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G) : 0 < add_order_of x",
    "theorem": "{G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G) : 0 < add_order_of x",
    "args": "{G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G)",
    "doc_string": "This is the same as `add_order_of_pos' but with one fewer explicit assumption since this is   automatic in case of a finite cancellative additive monoid.",
    "type": "0 < add_order_of x"
  },
  {
    "name": "right.add_nonpos",
    "statement": "theorem right.add_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_nonpos`.",
    "type": "a + b ≤ 0"
  },
  {
    "name": "padic_val_rat.zero",
    "statement": "theorem padic_val_rat.zero (m : ℕ) : padic_val_rat m 0 = 0",
    "theorem": "(m : ℕ) : padic_val_rat m 0 = 0",
    "args": "(m : ℕ)",
    "doc_string": "`padic_val_rat p 0` is 0 for any `p`.",
    "type": "padic_val_rat m 0 = 0"
  },
  {
    "name": "add_con.coe_add",
    "statement": "theorem add_con.coe_add {M : Type u_1} [has_add M] {c : add_con M} (x y : M) : ↑(x + y) = ↑x + ↑y",
    "theorem": "{M : Type u_1} [has_add M] {c : add_con M} (x y : M) : ↑(x + y) = ↑x + ↑y",
    "args": "{M : Type u_1} [has_add M] {c : add_con M} (x y : M)",
    "doc_string": "The coercion to the quotient of an additive congruence relation commutes with addition (by definition).",
    "type": "↑(x + y) = ↑x + ↑y"
  },
  {
    "name": "subtype.exists'",
    "statement": "theorem subtype.exists' {α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop} : (∃ (x : α) (h : p x), q x h) ↔ ∃ (x : {a // p a}), q ↑x _",
    "theorem": "{α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop} : (∃ (x : α) (h : p x), q x h) ↔ ∃ (x : {a // p a}), q ↑x _",
    "args": "{α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop}",
    "doc_string": "An alternative version of `subtype.exists`. This one is useful if Lean cannot figure out `q`  when using `subtype.exists` from right to left.",
    "type": "(∃ (x : α) (h : p x), q x h) ↔ ∃ (x : {a // p a}), q ↑x _"
  },
  {
    "name": "zmod.pow_card",
    "statement": "theorem zmod.pow_card {p : ℕ} [fact (nat.prime p)] (x : zmod p) : x ^ p = x",
    "theorem": "{p : ℕ} [fact (nat.prime p)] (x : zmod p) : x ^ p = x",
    "args": "{p : ℕ} [fact (nat.prime p)] (x : zmod p)",
    "doc_string": "A variation on Fermat's little theorem. See `zmod.pow_card_sub_one_eq_one`",
    "type": "x ^ p = x"
  },
  {
    "name": "add_con.refl",
    "statement": "theorem add_con.refl {M : Type u_1} [has_add M] (c : add_con M) (x : M) : ⇑c x x",
    "theorem": "{M : Type u_1} [has_add M] (c : add_con M) (x : M) : ⇑c x x",
    "args": "{M : Type u_1} [has_add M] (c : add_con M) (x : M)",
    "doc_string": "Additive congruence relations are reflexive.",
    "type": "⇑c x x"
  },
  {
    "name": "lt_of_tsub_lt_tsub_right_of_le",
    "statement": "theorem lt_of_tsub_lt_tsub_right_of_le {α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} (h : c ≤ b) (h2 : a - c < b - c) : a < b",
    "theorem": "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} (h : c ≤ b) (h2 : a - c < b - c) : a < b",
    "args": "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} (h : c ≤ b) (h2 : a - c < b - c)",
    "doc_string": "See `lt_of_tsub_lt_tsub_right` for a stronger statement in a linear order.",
    "type": "a < b"
  },
  {
    "name": "is_preconnected.subset_closure",
    "statement": "theorem is_preconnected.subset_closure {α : Type u} [topological_space α] {s t : set α} (H : is_preconnected s) (Kst : s ⊆ t) (Ktcs : t ⊆ closure s) : is_preconnected t",
    "theorem": "{α : Type u} [topological_space α] {s t : set α} (H : is_preconnected s) (Kst : s ⊆ t) (Ktcs : t ⊆ closure s) : is_preconnected t",
    "args": "{α : Type u} [topological_space α] {s t : set α} (H : is_preconnected s) (Kst : s ⊆ t) (Ktcs : t ⊆ closure s)",
    "doc_string": " Theorem of bark and tree : if a set is within a (pre)connected set and its closure, then it is (pre)connected as well.",
    "type": "is_preconnected t"
  },
  {
    "name": "is_add_group_hom.to_is_add_monoid_hom",
    "statement": "theorem is_add_group_hom.to_is_add_monoid_hom {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_monoid_hom f",
    "theorem": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_monoid_hom f",
    "args": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f)",
    "doc_string": "An additive group homomorphism is an additive monoid homomorphism.",
    "type": "is_add_monoid_hom f"
  },
  {
    "name": "category_theory.over.construct_products.over_product_of_wide_pullback",
    "statement": "theorem category_theory.over.construct_products.over_product_of_wide_pullback {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape (category_theory.limits.wide_pullback_shape J) C] {B : C} : category_theory.limits.has_limits_of_shape (category_theory.discrete J) (category_theory.over B)",
    "theorem": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape (category_theory.limits.wide_pullback_shape J) C] {B : C} : category_theory.limits.has_limits_of_shape (category_theory.discrete J) (category_theory.over B)",
    "args": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape (category_theory.limits.wide_pullback_shape J) C] {B : C}",
    "doc_string": "Given a wide pullback in `C`, construct a product in `C/B`.",
    "type": "category_theory.limits.has_limits_of_shape (category_theory.discrete J) (category_theory.over B)"
  },
  {
    "name": "measurable.of_le_map",
    "statement": "theorem measurable.of_le_map {α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : m₂ ≤ measurable_space.map f m₁ → measurable f",
    "theorem": "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : m₂ ≤ measurable_space.map f m₁ → measurable f",
    "args": "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β}",
    "doc_string": "**Alias** of the reverse direction of measurable_iff_le_map`.",
    "type": "m₂ ≤ measurable_space.map f m₁ → measurable f"
  },
  {
    "name": "le_of_sub_nonpos",
    "statement": "theorem le_of_sub_nonpos {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a - b ≤ 0 → a ≤ b",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a - b ≤ 0 → a ≤ b",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α}",
    "doc_string": "**Alias** of the forward direction of sub_nonpos`.",
    "type": "a - b ≤ 0 → a ≤ b"
  },
  {
    "name": "padic_val_rat.one",
    "statement": "theorem padic_val_rat.one {p : ℕ} : padic_val_rat p 1 = 0",
    "theorem": "{p : ℕ} : padic_val_rat p 1 = 0",
    "args": "{p : ℕ}",
    "doc_string": "`padic_val_rat p 1` is 0 for any `p`.",
    "type": "padic_val_rat p 1 = 0"
  },
  {
    "name": "function.injective2.right",
    "statement": "theorem function.injective2.right {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (a : α) : function.injective (f a)",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (a : α) : function.injective (f a)",
    "args": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (a : α)",
    "doc_string": "A binary injective function is injective when only the right argument varies.",
    "type": "function.injective (f a)"
  },
  {
    "name": "is_group_hom.to_is_monoid_hom",
    "statement": "theorem is_group_hom.to_is_monoid_hom {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : is_monoid_hom f",
    "theorem": "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : is_monoid_hom f",
    "args": "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f)",
    "doc_string": "A group homomorphism is a monoid homomorphism.",
    "type": "is_monoid_hom f"
  },
  {
    "name": "polynomial.is_noetherian_ring",
    "statement": "theorem polynomial.is_noetherian_ring {R : Type u} [comm_ring R] [is_noetherian_ring R] : is_noetherian_ring (polynomial R)",
    "theorem": "{R : Type u} [comm_ring R] [is_noetherian_ring R] : is_noetherian_ring (polynomial R)",
    "args": "{R : Type u} [comm_ring R] [is_noetherian_ring R]",
    "doc_string": "Hilbert basis theorem: a polynomial ring over a noetherian ring is a noetherian ring.",
    "type": "is_noetherian_ring (polynomial R)"
  },
  {
    "name": "is_left_regular_iff",
    "statement": "theorem is_left_regular_iff {R : Type u_1} [has_mul R] {a : R} : is_left_regular a ↔ is_smul_regular R a",
    "theorem": "{R : Type u_1} [has_mul R] {a : R} : is_left_regular a ↔ is_smul_regular R a",
    "args": "{R : Type u_1} [has_mul R] {a : R}",
    "doc_string": "Left-regular multiplication on `R` is equivalent to `R`-regularity of `R` itself.",
    "type": "is_left_regular a ↔ is_smul_regular R a"
  },
  {
    "name": "is_dedekind_domain_inv.is_dedekind_domain",
    "statement": "theorem is_dedekind_domain_inv.is_dedekind_domain {A : Type u_2} [comm_ring A] [is_domain A] (h : is_dedekind_domain_inv A) : is_dedekind_domain A",
    "theorem": "{A : Type u_2} [comm_ring A] [is_domain A] (h : is_dedekind_domain_inv A) : is_dedekind_domain A",
    "args": "{A : Type u_2} [comm_ring A] [is_domain A] (h : is_dedekind_domain_inv A)",
    "doc_string": " Showing one side of the equivalence between the definitions `is_dedekind_domain_inv` and `is_dedekind_domain` of Dedekind domains.",
    "type": "is_dedekind_domain A"
  },
  {
    "name": "four_pos",
    "statement": "theorem four_pos {α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 4",
    "theorem": "{α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 4",
    "args": "{α : Type u} [ordered_semiring α] [nontrivial α]",
    "doc_string": "**Alias** of zero_lt_four`.",
    "type": "0 < 4"
  },
  {
    "name": "nat.choose_two_right",
    "statement": "theorem nat.choose_two_right (n : ℕ) : n.choose 2 = n * (n - 1) / 2",
    "theorem": "(n : ℕ) : n.choose 2 = n * (n - 1) / 2",
    "args": "(n : ℕ)",
    "doc_string": "`choose n 2` is the `n`-th triangle number.",
    "type": "n.choose 2 = n * (n - 1) / 2"
  },
  {
    "name": "eq.trans_gt",
    "statement": "theorem eq.trans_gt {α : Type u} [preorder α] {a b c : α} : b = c → a < b → a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : b = c → a < b → a < c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of lt_of_eq_of_lt'`.",
    "type": "b = c → a < b → a < c"
  },
  {
    "name": "fin.snoc_init_self",
    "statement": "theorem fin.snoc_init_self {n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) : fin.snoc (fin.init q) (q (fin.last n)) = q",
    "theorem": "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) : fin.snoc (fin.init q) (q (fin.last n)) = q",
    "args": "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i)",
    "doc_string": "Concatenating the first element of a tuple with its tail gives back the original tuple",
    "type": "fin.snoc (fin.init q) (q (fin.last n)) = q"
  },
  {
    "name": "not_small_ordinal",
    "statement": "theorem not_small_ordinal  : ¬small ordinal",
    "theorem": " : ¬small ordinal",
    "args": "",
    "doc_string": " The type of ordinals in universe `u` is not `small.{u}`. This is the type-theoretic analog of the Burali-Forti paradox.",
    "type": "¬small ordinal"
  },
  {
    "name": "add_is_add_right_regular_iff",
    "statement": "theorem add_is_add_right_regular_iff {R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_right_regular a) : is_add_right_regular (b + a) ↔ is_add_right_regular b",
    "theorem": "{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_right_regular a) : is_add_right_regular (b + a) ↔ is_add_right_regular b",
    "args": "{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_right_regular a)",
    "doc_string": "An element is add-right-regular if and only if adding it on the right to a add-right-regular element is add-right-regular.",
    "type": "is_add_right_regular (b + a) ↔ is_add_right_regular b"
  },
  {
    "name": "summable.tendsto_cofinite_zero",
    "statement": "theorem summable.tendsto_cofinite_zero {α : Type u_1} {G : Type u_5} [topological_space G] [add_comm_group G] [topological_add_group G] {f : α → G} (hf : summable f) : filter.tendsto f filter.cofinite (nhds 0)",
    "theorem": "{α : Type u_1} {G : Type u_5} [topological_space G] [add_comm_group G] [topological_add_group G] {f : α → G} (hf : summable f) : filter.tendsto f filter.cofinite (nhds 0)",
    "args": "{α : Type u_1} {G : Type u_5} [topological_space G] [add_comm_group G] [topological_add_group G] {f : α → G} (hf : summable f)",
    "doc_string": " Series divergence test: if `f` is a convergent series, then `f x` tends to zero along `cofinite`.",
    "type": "filter.tendsto f filter.cofinite (nhds 0)"
  },
  {
    "name": "is_add_group_hom.injective_iff",
    "statement": "theorem is_add_group_hom.injective_iff {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0",
    "theorem": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0",
    "args": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f)",
    "doc_string": "An additive group homomorphism is injective if its kernel is trivial.",
    "type": "function.injective f ↔ ∀ (a : α), f a = 0 → a = 0"
  },
  {
    "name": "nat.exists_lt_and_lt_iff_not_dvd",
    "statement": "theorem nat.exists_lt_and_lt_iff_not_dvd (m : ℕ) {n : ℕ} (hn : 0 < n) : (∃ (k : ℕ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m",
    "theorem": "(m : ℕ) {n : ℕ} (hn : 0 < n) : (∃ (k : ℕ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m",
    "args": "(m : ℕ) {n : ℕ} (hn : 0 < n)",
    "doc_string": "`m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)` for some `k`.",
    "type": "(∃ (k : ℕ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m"
  },
  {
    "name": "polynomial.monic_X_pow_sub_C",
    "statement": "theorem polynomial.monic_X_pow_sub_C {R : Type u} [ring R] (a : R) {n : ℕ} (h : n ≠ 0) : (polynomial.X ^ n - ⇑polynomial.C a).monic",
    "theorem": "{R : Type u} [ring R] (a : R) {n : ℕ} (h : n ≠ 0) : (polynomial.X ^ n - ⇑polynomial.C a).monic",
    "args": "{R : Type u} [ring R] (a : R) {n : ℕ} (h : n ≠ 0)",
    "doc_string": "`X ^ n - a` is monic.",
    "type": "(polynomial.X ^ n - ⇑polynomial.C a).monic"
  },
  {
    "name": "real.coe_fib_eq'",
    "statement": "theorem real.coe_fib_eq'  : (λ (n : ℕ), ↑(nat.fib n)) = λ (n : ℕ), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5",
    "theorem": " : (λ (n : ℕ), ↑(nat.fib n)) = λ (n : ℕ), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5",
    "args": "",
    "doc_string": "Binet's formula as a function equality.",
    "type": "(λ (n : ℕ), ↑(nat.fib n)) = λ (n : ℕ), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5"
  },
  {
    "name": "inducing.is_open_map",
    "statement": "theorem inducing.is_open_map {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (hi : inducing f) (ho : is_open (set.range f)) : is_open_map f",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (hi : inducing f) (ho : is_open (set.range f)) : is_open_map f",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (hi : inducing f) (ho : is_open (set.range f))",
    "doc_string": "An inducing map with an open range is an open map.",
    "type": "is_open_map f"
  },
  {
    "name": "nat.fib_add_two_strict_mono",
    "statement": "theorem nat.fib_add_two_strict_mono  : strict_mono (λ (n : ℕ), nat.fib (n + 2))",
    "theorem": " : strict_mono (λ (n : ℕ), nat.fib (n + 2))",
    "args": "",
    "doc_string": "`fib (n + 2)` is strictly monotone.",
    "type": "strict_mono (λ (n : ℕ), nat.fib (n + 2))"
  },
  {
    "name": "int.zpow_le_iff_le_log",
    "statement": "theorem int.zpow_le_iff_le_log {R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : ↑b ^ x ≤ r ↔ x ≤ int.log b r",
    "theorem": "{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : ↑b ^ x ≤ r ↔ x ≤ int.log b r",
    "args": "{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r)",
    "doc_string": "`zpow b` and `int.log b` (almost) form a Galois connection.",
    "type": "↑b ^ x ≤ r ↔ x ≤ int.log b r"
  },
  {
    "name": "coe_coe",
    "statement": "theorem coe_coe {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} [has_coe α β] [has_coe_t β γ] (a : α) : ↑a = ↑↑a",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} [has_coe α β] [has_coe_t β γ] (a : α) : ↑a = ↑↑a",
    "args": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} [has_coe α β] [has_coe_t β γ] (a : α)",
    "doc_string": "Add an instance to \"undo\" coercion transitivity into a chain of coercions, because   most simp lemmas are stated with respect to simple coercions and will not match when   part of a chain.",
    "type": "↑a = ↑↑a"
  },
  {
    "name": "metric.inf_dist_empty",
    "statement": "theorem metric.inf_dist_empty {α : Type u} [pseudo_metric_space α] {x : α} : metric.inf_dist x ∅ = 0",
    "theorem": "{α : Type u} [pseudo_metric_space α] {x : α} : metric.inf_dist x ∅ = 0",
    "args": "{α : Type u} [pseudo_metric_space α] {x : α}",
    "doc_string": " the minimal distance to the empty set is 0 (if you want to have the more reasonable value ∞ instead, use `inf_edist`, which takes values in ℝ≥0∞)",
    "type": "metric.inf_dist x ∅ = 0"
  },
  {
    "name": "exists_nat_pow_near",
    "statement": "theorem exists_nat_pow_near {α : Type u_1} [linear_ordered_ring α] [archimedean α] {x y : α} (hx : 1 ≤ x) (hy : 1 < y) : ∃ (n : ℕ), y ^ n ≤ x ∧ x < y ^ (n + 1)",
    "theorem": "{α : Type u_1} [linear_ordered_ring α] [archimedean α] {x y : α} (hx : 1 ≤ x) (hy : 1 < y) : ∃ (n : ℕ), y ^ n ≤ x ∧ x < y ^ (n + 1)",
    "args": "{α : Type u_1} [linear_ordered_ring α] [archimedean α] {x y : α} (hx : 1 ≤ x) (hy : 1 < y)",
    "doc_string": " Every x greater than or equal to 1 is between two successive natural-number powers of every y greater than one.",
    "type": "∃ (n : ℕ), y ^ n ≤ x ∧ x < y ^ (n + 1)"
  },
  {
    "name": "order_bot.bdd_below",
    "statement": "theorem order_bot.bdd_below {γ : Type w} [preorder γ] [order_bot γ] (s : set γ) : bdd_below s",
    "theorem": "{γ : Type w} [preorder γ] [order_bot γ] (s : set γ) : bdd_below s",
    "args": "{γ : Type w} [preorder γ] [order_bot γ] (s : set γ)",
    "doc_string": "When there is a global minimum, every set is bounded below.",
    "type": "bdd_below s"
  },
  {
    "name": "subsingleton_of_zero_eq_one",
    "statement": "theorem subsingleton_of_zero_eq_one {M₀ : Type u_1} [mul_zero_one_class M₀] : 0 = 1 → subsingleton M₀",
    "theorem": "{M₀ : Type u_1} [mul_zero_one_class M₀] : 0 = 1 → subsingleton M₀",
    "args": "{M₀ : Type u_1} [mul_zero_one_class M₀]",
    "doc_string": "**Alias** of the forward direction of subsingleton_iff_zero_eq_one`.",
    "type": "0 = 1 → subsingleton M₀"
  },
  {
    "name": "nat.even_pow",
    "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0",
    "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0",
    "args": "{m n : ℕ}",
    "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.",
    "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"
  },
  {
    "name": "ring.neg_one_ne_one_of_char_ne_two",
    "statement": "theorem ring.neg_one_ne_one_of_char_ne_two {R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ≠ 2) : -1 ≠ 1",
    "theorem": "{R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ≠ 2) : -1 ≠ 1",
    "args": "{R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ≠ 2)",
    "doc_string": "Characteristic `≠ 2` and nontrivial implies that `-1 ≠ 1`.",
    "type": "-1 ≠ 1"
  },
  {
    "name": "left.inv_le_one_iff",
    "statement": "theorem left.inv_le_one_iff {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α}",
    "doc_string": "Uses `left` co(ntra)variant.",
    "type": "a⁻¹ ≤ 1 ↔ 1 ≤ a"
  },
  {
    "name": "zero_lt.right.mul_pos",
    "statement": "theorem zero_lt.right.mul_pos {α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 0 < a) (hb : 0 < b) : 0 < a * b",
    "theorem": "{α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 0 < a) (hb : 0 < b) : 0 < a * b",
    "args": "{α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "type": "0 < a * b"
  },
  {
    "name": "left.add_neg_of_nonpos_of_neg",
    "statement": "theorem left.add_neg_of_nonpos_of_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_neg_of_nonpos_of_neg`.",
    "type": "a + b < 0"
  },
  {
    "name": "cSup_singleton",
    "statement": "theorem cSup_singleton {α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Sup.Sup {a} = a",
    "theorem": "{α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Sup.Sup {a} = a",
    "args": "{α : Type u_1} [conditionally_complete_lattice α] (a : α)",
    "doc_string": "The supremum of a singleton is the element of the singleton",
    "type": "has_Sup.Sup {a} = a"
  },
  {
    "name": "matrix.det_unique",
    "statement": "theorem matrix.det_unique {R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R) : A.det = A inhabited.default inhabited.default",
    "theorem": "{R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R) : A.det = A inhabited.default inhabited.default",
    "args": "{R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R)",
    "doc_string": " If `n` has only one element, the determinant of an `n` by `n` matrix is just that element. Although `unique` implies `decidable_eq` and `fintype`, the instances might not be syntactically equal. Thus, we need to fill in the args explicitly.",
    "type": "A.det = A inhabited.default inhabited.default"
  },
  {
    "name": "ascending_central_series_le_upper",
    "statement": "theorem ascending_central_series_le_upper {G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_ascending_central_series H) (n : ℕ) : H n ≤ upper_central_series G n",
    "theorem": "{G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_ascending_central_series H) (n : ℕ) : H n ≤ upper_central_series G n",
    "args": "{G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_ascending_central_series H) (n : ℕ)",
    "doc_string": "Any ascending central series for a group is bounded above by the upper central series.",
    "type": "H n ≤ upper_central_series G n"
  },
  {
    "name": "category_theory.abelian.pseudo_equal_trans",
    "statement": "theorem category_theory.abelian.pseudo_equal_trans {C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : transitive (category_theory.abelian.pseudo_equal P)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : transitive (category_theory.abelian.pseudo_equal P)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C}",
    "doc_string": "Pseudoequality is transitive: Just take the pullback. The pullback morphisms will    be epimorphisms since in an abelian category, pullbacks of epimorphisms are epimorphisms.",
    "type": "transitive (category_theory.abelian.pseudo_equal P)"
  },
  {
    "name": "first_order.language.substructure.subset_closure",
    "statement": "theorem first_order.language.substructure.subset_closure {L : first_order.language} {M : Type w} [L.Structure M] {s : set M} : s ⊆ ↑(⇑(first_order.language.substructure.closure L) s)",
    "theorem": "{L : first_order.language} {M : Type w} [L.Structure M] {s : set M} : s ⊆ ↑(⇑(first_order.language.substructure.closure L) s)",
    "args": "{L : first_order.language} {M : Type w} [L.Structure M] {s : set M}",
    "doc_string": "The substructure generated by a set includes the set.",
    "type": "s ⊆ ↑(⇑(first_order.language.substructure.closure L) s)"
  },
  {
    "name": "is_dedekind_domain_iff_is_dedekind_domain_inv",
    "statement": "theorem is_dedekind_domain_iff_is_dedekind_domain_inv {A : Type u_2} [comm_ring A] [is_domain A] : is_dedekind_domain A ↔ is_dedekind_domain_inv A",
    "theorem": "{A : Type u_2} [comm_ring A] [is_domain A] : is_dedekind_domain A ↔ is_dedekind_domain_inv A",
    "args": "{A : Type u_2} [comm_ring A] [is_domain A]",
    "doc_string": " `is_dedekind_domain` and `is_dedekind_domain_inv` are equivalent ways to express that an integral domain is a Dedekind domain.",
    "type": "is_dedekind_domain A ↔ is_dedekind_domain_inv A"
  },
  {
    "name": "con.con_gen_mono",
    "statement": "theorem con.con_gen_mono {M : Type u_1} [has_mul M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y) : con_gen r ≤ con_gen s",
    "theorem": "{M : Type u_1} [has_mul M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y) : con_gen r ≤ con_gen s",
    "args": "{M : Type u_1} [has_mul M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y)",
    "doc_string": "Given binary relations `r, s` with `r` contained in `s`, the smallest congruence relation    containing `s` contains the smallest congruence relation containing `r`.",
    "type": "con_gen r ≤ con_gen s"
  },
  {
    "name": "zero_lt.right.one_le_mul_of_le_of_le",
    "statement": "theorem zero_lt.right.one_le_mul_of_le_of_le {α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 ≤ b) : 1 ≤ a * b",
    "theorem": "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 ≤ b) : 1 ≤ a * b",
    "args": "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 ≤ b)",
    "doc_string": "Assumes right covariance.",
    "type": "1 ≤ a * b"
  },
  {
    "name": "multiset.sub_le_iff_le_add",
    "statement": "theorem multiset.sub_le_iff_le_add {α : Type u_1} [decidable_eq α] {s t u : multiset α} : s - t ≤ u ↔ s ≤ u + t",
    "theorem": "{α : Type u_1} [decidable_eq α] {s t u : multiset α} : s - t ≤ u ↔ s ≤ u + t",
    "args": "{α : Type u_1} [decidable_eq α] {s t u : multiset α}",
    "doc_string": "This is a special case of `tsub_le_iff_right`, which should be used instead of this.  This is needed to prove `has_ordered_sub (multiset α)`.",
    "type": "s - t ≤ u ↔ s ≤ u + t"
  },
  {
    "name": "continuous_map.continuous_coe'",
    "statement": "theorem continuous_map.continuous_coe' {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] : continuous coe_fn",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] : continuous coe_fn",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α]",
    "doc_string": "See also `continuous_map.continuous_coe`",
    "type": "continuous coe_fn"
  },
  {
    "name": "has_dvd.dvd.mul_left",
    "statement": "theorem has_dvd.dvd.mul_left {α : Type u_1} [comm_semigroup α] {a b : α} (h : a ∣ b) (c : α) : a ∣ c * b",
    "theorem": "{α : Type u_1} [comm_semigroup α] {a b : α} (h : a ∣ b) (c : α) : a ∣ c * b",
    "args": "{α : Type u_1} [comm_semigroup α] {a b : α} (h : a ∣ b) (c : α)",
    "doc_string": "**Alias** of dvd_mul_of_dvd_right`.",
    "type": "a ∣ c * b"
  },
  {
    "name": "count_succ_eq_count",
    "statement": "theorem count_succ_eq_count {p : ℕ → Prop} [decidable_pred p] {n : ℕ} : ¬p n → nat.count p (n + 1) = nat.count p n",
    "theorem": "{p : ℕ → Prop} [decidable_pred p] {n : ℕ} : ¬p n → nat.count p (n + 1) = nat.count p n",
    "args": "{p : ℕ → Prop} [decidable_pred p] {n : ℕ}",
    "doc_string": "**Alias** of the reverse direction of nat.count_succ_eq_count_iff`.",
    "type": "¬p n → nat.count p (n + 1) = nat.count p n"
  },
  {
    "name": "con.div",
    "statement": "theorem con.div {M : Type u_1} [group M] (c : con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w / y) (x / z)",
    "theorem": "{M : Type u_1} [group M] (c : con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w / y) (x / z)",
    "args": "{M : Type u_1} [group M] (c : con M) {w x y z : M}",
    "doc_string": "Multiplicative congruence relations preserve division.",
    "type": "⇑c w x → ⇑c y z → ⇑c (w / y) (x / z)"
  },
  {
    "name": "neg.is_add_group_hom",
    "statement": "theorem neg.is_add_group_hom {α : Type u} [add_comm_group α] : is_add_group_hom has_neg.neg",
    "theorem": "{α : Type u} [add_comm_group α] : is_add_group_hom has_neg.neg",
    "args": "{α : Type u} [add_comm_group α]",
    "doc_string": "Negation is an `add_group` homomorphism if the `add_group` is commutative.",
    "type": "is_add_group_hom has_neg.neg"
  },
  {
    "name": "is_algebraic_iff_is_integral",
    "statement": "theorem is_algebraic_iff_is_integral {K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x ↔ is_integral K x",
    "theorem": "{K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x ↔ is_integral K x",
    "args": "{K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A}",
    "doc_string": "An element of an algebra over a field is algebraic if and only if it is integral.",
    "type": "is_algebraic K x ↔ is_integral K x"
  },
  {
    "name": "has_dvd.dvd.mul_right",
    "statement": "theorem has_dvd.dvd.mul_right {α : Type u_1} [semigroup α] {a b : α} (h : a ∣ b) (c : α) : a ∣ b * c",
    "theorem": "{α : Type u_1} [semigroup α] {a b : α} (h : a ∣ b) (c : α) : a ∣ b * c",
    "args": "{α : Type u_1} [semigroup α] {a b : α} (h : a ∣ b) (c : α)",
    "doc_string": "**Alias** of dvd_mul_of_dvd_left`.",
    "type": "a ∣ b * c"
  },
  {
    "name": "polynomial.map_cyclotomic_int",
    "statement": "theorem polynomial.map_cyclotomic_int (n : ℕ) (R : Type u_1) [ring R] : polynomial.map (int.cast_ring_hom R) (polynomial.cyclotomic n ℤ) = polynomial.cyclotomic n R",
    "theorem": "(n : ℕ) (R : Type u_1) [ring R] : polynomial.map (int.cast_ring_hom R) (polynomial.cyclotomic n ℤ) = polynomial.cyclotomic n R",
    "args": "(n : ℕ) (R : Type u_1) [ring R]",
    "doc_string": "`cyclotomic n R` comes from `cyclotomic n ℤ`.",
    "type": "polynomial.map (int.cast_ring_hom R) (polynomial.cyclotomic n ℤ) = polynomial.cyclotomic n R"
  },
  {
    "name": "char.quadratic_char_eq_one_of_char_two",
    "statement": "theorem char.quadratic_char_eq_one_of_char_two {F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F = 2) {a : F} (ha : a ≠ 0) : char.quadratic_char F a = 1",
    "theorem": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F = 2) {a : F} (ha : a ≠ 0) : char.quadratic_char F a = 1",
    "args": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F = 2) {a : F} (ha : a ≠ 0)",
    "doc_string": "If `ring_char F = 2`, then `quadratic_char F` takes the value `1` on nonzero elements.",
    "type": "char.quadratic_char F a = 1"
  },
  {
    "name": "matrix.aeval_self_charpoly",
    "statement": "theorem matrix.aeval_self_charpoly {R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : ⇑(polynomial.aeval M) M.charpoly = 0",
    "theorem": "{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : ⇑(polynomial.aeval M) M.charpoly = 0",
    "args": "{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R)",
    "doc_string": "The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix, applied to the matrix itself, is zero.  This holds over any commutative ring.  See `linear_map.aeval_self_charpoly` for the equivalent statement about endomorphisms.",
    "type": "⇑(polynomial.aeval M) M.charpoly = 0"
  },
  {
    "name": "polynomial.of_finsupp_inj",
    "statement": "theorem polynomial.of_finsupp_inj {R : Type u} [semiring R] {a b : add_monoid_algebra R ℕ} : {to_finsupp := a} = {to_finsupp := b} ↔ a = b",
    "theorem": "{R : Type u} [semiring R] {a b : add_monoid_algebra R ℕ} : {to_finsupp := a} = {to_finsupp := b} ↔ a = b",
    "args": "{R : Type u} [semiring R] {a b : add_monoid_algebra R ℕ}",
    "doc_string": "A more convenient spelling of `polynomial.of_finsupp.inj_eq` in terms of `iff`.",
    "type": "{to_finsupp := a} = {to_finsupp := b} ↔ a = b"
  },
  {
    "name": "nat.factorization_inj",
    "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}",
    "theorem": " : set.inj_on nat.factorization {x : ℕ | x ≠ 0}",
    "args": "",
    "doc_string": "Every nonzero natural number has a unique prime factorization",
    "type": "set.inj_on nat.factorization {x : ℕ | x ≠ 0}"
  },
  {
    "name": "list.sorted.insertion_sort_eq",
    "statement": "theorem list.sorted.insertion_sort_eq {α : Type uu} {r : α → α → Prop} [decidable_rel r] {l : list α} (h : list.sorted r l) : list.insertion_sort r l = l",
    "theorem": "{α : Type uu} {r : α → α → Prop} [decidable_rel r] {l : list α} (h : list.sorted r l) : list.insertion_sort r l = l",
    "args": "{α : Type uu} {r : α → α → Prop} [decidable_rel r] {l : list α} (h : list.sorted r l)",
    "doc_string": " If `l` is already `list.sorted` with respect to `r`, then `insertion_sort` does not change it.",
    "type": "list.insertion_sort r l = l"
  },
  {
    "name": "nat.pow_dvd_pow_iff_le_right",
    "statement": "theorem nat.pow_dvd_pow_iff_le_right {x k l : ℕ} (w : 1 < x) : x ^ k ∣ x ^ l ↔ k ≤ l",
    "theorem": "{x k l : ℕ} (w : 1 < x) : x ^ k ∣ x ^ l ↔ k ≤ l",
    "args": "{x k l : ℕ} (w : 1 < x)",
    "doc_string": "If `1 < x`, then `x^k` divides `x^l` if and only if `k` is at most `l`.",
    "type": "x ^ k ∣ x ^ l ↔ k ≤ l"
  },
  {
    "name": "fintype.univ_of_is_empty",
    "statement": "theorem fintype.univ_of_is_empty {α : Type u_1} [is_empty α] : finset.univ = ∅",
    "theorem": "{α : Type u_1} [is_empty α] : finset.univ = ∅",
    "args": "{α : Type u_1} [is_empty α]",
    "doc_string": " Note: this lemma is specifically about `fintype.of_is_empty`. For a statement about arbitrary `fintype` instances, use `finset.univ_eq_empty`.",
    "type": "finset.univ = ∅"
  },
  {
    "name": "is_topological_fiber_bundle.surjective_proj",
    "statement": "theorem is_topological_fiber_bundle.surjective_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : function.surjective proj",
    "theorem": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : function.surjective proj",
    "args": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj)",
    "doc_string": " The projection from a topological fiber bundle with a nonempty fiber to its base is a surjective map.",
    "type": "function.surjective proj"
  },
  {
    "name": "add_con.mk'_ker",
    "statement": "theorem add_con.mk'_ker {M : Type u_1} [add_zero_class M] (c : add_con M) : add_con.ker c.mk' = c",
    "theorem": "{M : Type u_1} [add_zero_class M] (c : add_con M) : add_con.ker c.mk' = c",
    "args": "{M : Type u_1} [add_zero_class M] (c : add_con M)",
    "doc_string": "The kernel of the natural homomorphism from an `add_monoid` to its quotient by an additive congruence relation `c` equals `c`.",
    "type": "add_con.ker c.mk' = c"
  },
  {
    "name": "is_topological_fiber_bundle.quotient_map_proj",
    "statement": "theorem is_topological_fiber_bundle.quotient_map_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : quotient_map proj",
    "theorem": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : quotient_map proj",
    "args": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj)",
    "doc_string": " The projection from a topological fiber bundle with a nonempty fiber to its base is a quotient map.",
    "type": "quotient_map proj"
  },
  {
    "name": "closure_Ioo",
    "statement": "theorem closure_Ioo {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ioo a b) = set.Icc a b",
    "theorem": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ioo a b) = set.Icc a b",
    "args": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b)",
    "doc_string": "The closure of the open interval `(a, b)` is the closed interval `[a, b]`.",
    "type": "closure (set.Ioo a b) = set.Icc a b"
  },
  {
    "name": "group_topology.continuous_mul'",
    "statement": "theorem group_topology.continuous_mul' {α : Type u} [group α] (g : group_topology α) : continuous (λ (p : α × α), p.fst * p.snd)",
    "theorem": "{α : Type u} [group α] (g : group_topology α) : continuous (λ (p : α × α), p.fst * p.snd)",
    "args": "{α : Type u} [group α] (g : group_topology α)",
    "doc_string": "A version of the global `continuous_mul` suitable for dot notation.",
    "type": "continuous (λ (p : α × α), p.fst * p.snd)"
  },
  {
    "name": "metric.bounded_union",
    "statement": "theorem metric.bounded_union {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s t : set α} : metric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t",
    "args": "{α : Type u} [pseudo_metric_space α] {s t : set α}",
    "doc_string": "The union of two sets is bounded iff each of the sets is bounded.",
    "type": "metric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t"
  },
  {
    "name": "is_regular.and_of_mul_of_mul",
    "statement": "theorem is_regular.and_of_mul_of_mul {R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a)) : is_regular a ∧ is_regular b",
    "theorem": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a)) : is_regular a ∧ is_regular b",
    "args": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a))",
    "doc_string": "The \"most used\" implication of `mul_and_mul_iff`, with split hypotheses, instead of `∧`.",
    "type": "is_regular a ∧ is_regular b"
  },
  {
    "name": "zero_lt.right.one_lt_mul_of_lt_of_lt",
    "statement": "theorem zero_lt.right.one_lt_mul_of_lt_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "type": "1 < a * b"
  },
  {
    "name": "has_lt.lt.dual",
    "statement": "theorem has_lt.lt.dual {α : Type u_1} [has_lt α] {a b : α} : b < a → ⇑order_dual.to_dual a < ⇑order_dual.to_dual b",
    "theorem": "{α : Type u_1} [has_lt α] {a b : α} : b < a → ⇑order_dual.to_dual a < ⇑order_dual.to_dual b",
    "args": "{α : Type u_1} [has_lt α] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of order_dual.to_dual_lt_to_dual`.",
    "type": "b < a → ⇑order_dual.to_dual a < ⇑order_dual.to_dual b"
  },
  {
    "name": "sub_neg_of_lt",
    "statement": "theorem sub_neg_of_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a < b → a - b < 0",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a < b → a - b < 0",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of sub_neg`.",
    "type": "a < b → a - b < 0"
  },
  {
    "name": "cardinal.mk_quaternion",
    "statement": "theorem cardinal.mk_quaternion (R : Type u_1) [has_one R] [has_neg R] : cardinal.mk (quaternion R) = cardinal.mk R ^ 4",
    "theorem": "(R : Type u_1) [has_one R] [has_neg R] : cardinal.mk (quaternion R) = cardinal.mk R ^ 4",
    "args": "(R : Type u_1) [has_one R] [has_neg R]",
    "doc_string": "The cardinality of the quaternions, as a type.",
    "type": "cardinal.mk (quaternion R) = cardinal.mk R ^ 4"
  },
  {
    "name": "mt",
    "statement": "theorem mt {a b : Prop} (h₁ : a → b) (h₂ : ¬b) : ¬a",
    "theorem": "{a b : Prop} (h₁ : a → b) (h₂ : ¬b) : ¬a",
    "args": "{a b : Prop} (h₁ : a → b) (h₂ : ¬b)",
    "doc_string": "Modus tollens. If an implication is true, then so is its contrapositive.",
    "type": "¬a"
  },
  {
    "name": "semiconj_by.one_right",
    "statement": "theorem semiconj_by.one_right {M : Type u} [mul_one_class M] (a : M) : semiconj_by a 1 1",
    "theorem": "{M : Type u} [mul_one_class M] (a : M) : semiconj_by a 1 1",
    "args": "{M : Type u} [mul_one_class M] (a : M)",
    "doc_string": "Any element semiconjugates `1` to `1`.",
    "type": "semiconj_by a 1 1"
  },
  {
    "name": "char.is_square_neg_one_iff",
    "statement": "theorem char.is_square_neg_one_iff {F : Type u_1} [field F] [fintype F] : is_square (-1) ↔ fintype.card F % 4 ≠ 3",
    "theorem": "{F : Type u_1} [field F] [fintype F] : is_square (-1) ↔ fintype.card F % 4 ≠ 3",
    "args": "{F : Type u_1} [field F] [fintype F]",
    "doc_string": "The interpretation in terms of whether `-1` is a square in `F`",
    "type": "is_square (-1) ↔ fintype.card F % 4 ≠ 3"
  },
  {
    "name": "le_neg_add_of_add_le",
    "statement": "theorem le_neg_add_of_add_le {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a + b ≤ c → b ≤ -a + c",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a + b ≤ c → b ≤ -a + c",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of le_inv_mul_iff_mul_le`.",
    "type": "a + b ≤ c → b ≤ -a + c"
  },
  {
    "name": "is_totally_separated.is_totally_disconnected",
    "statement": "theorem is_totally_separated.is_totally_disconnected {α : Type u} [topological_space α] {s : set α} (H : is_totally_separated s) : is_totally_disconnected s",
    "theorem": "{α : Type u} [topological_space α] {s : set α} (H : is_totally_separated s) : is_totally_disconnected s",
    "args": "{α : Type u} [topological_space α] {s : set α} (H : is_totally_separated s)",
    "doc_string": "**Alias** of is_totally_disconnected_of_is_totally_separated`.",
    "type": "is_totally_disconnected s"
  },
  {
    "name": "one_div_le_one_div_of_neg",
    "statement": "theorem one_div_le_one_div_of_neg {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : a < 0) (hb : b < 0) : 1 / a ≤ 1 / b ↔ b ≤ a",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : a < 0) (hb : b < 0) : 1 / a ≤ 1 / b ↔ b ≤ a",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : a < 0) (hb : b < 0)",
    "doc_string": "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_neg_of_lt` and  `lt_of_one_div_lt_one_div`",
    "type": "1 / a ≤ 1 / b ↔ b ≤ a"
  },
  {
    "name": "is_R_or_C.conj_conj",
    "statement": "theorem is_R_or_C.conj_conj {R : Type u} [comm_semiring R] [star_ring R] (x : R) : ⇑(star_ring_end R) (⇑(star_ring_end R) x) = x",
    "theorem": "{R : Type u} [comm_semiring R] [star_ring R] (x : R) : ⇑(star_ring_end R) (⇑(star_ring_end R) x) = x",
    "args": "{R : Type u} [comm_semiring R] [star_ring R] (x : R)",
    "doc_string": "**Alias** of star_ring_end_self_apply`.",
    "type": "⇑(star_ring_end R) (⇑(star_ring_end R) x) = x"
  },
  {
    "name": "lucas_lehmer.mersenne_coe_X",
    "statement": "theorem lucas_lehmer.mersenne_coe_X (p : ℕ) : ↑(mersenne p) = 0",
    "theorem": "(p : ℕ) : ↑(mersenne p) = 0",
    "args": "(p : ℕ)",
    "doc_string": "`q` is the minimum factor of `mersenne p`, so `M p = 0` in `X q`.",
    "type": "↑(mersenne p) = 0"
  },
  {
    "name": "isometry_id",
    "statement": "theorem isometry_id {α : Type u} [pseudo_emetric_space α] : isometry id",
    "theorem": "{α : Type u} [pseudo_emetric_space α] : isometry id",
    "args": "{α : Type u} [pseudo_emetric_space α]",
    "doc_string": "The identity is an isometry",
    "type": "isometry id"
  },
  {
    "name": "pnat.xgcd_type.step_wf",
    "statement": "theorem pnat.xgcd_type.step_wf (u : pnat.xgcd_type) (hr : u.r ≠ 0) : sizeof u.step < sizeof u",
    "theorem": "(u : pnat.xgcd_type) (hr : u.r ≠ 0) : sizeof u.step < sizeof u",
    "args": "(u : pnat.xgcd_type) (hr : u.r ≠ 0)",
    "doc_string": "We will apply the above step recursively.  The following result is used to ensure that the process terminates.",
    "type": "sizeof u.step < sizeof u"
  },
  {
    "name": "filter.tendsto_pow_at_top",
    "statement": "theorem filter.tendsto_pow_at_top {α : Type u_3} [ordered_semiring α] {n : ℕ} (hn : 1 ≤ n) : filter.tendsto (λ (x : α), x ^ n) filter.at_top filter.at_top",
    "theorem": "{α : Type u_3} [ordered_semiring α] {n : ℕ} (hn : 1 ≤ n) : filter.tendsto (λ (x : α), x ^ n) filter.at_top filter.at_top",
    "args": "{α : Type u_3} [ordered_semiring α] {n : ℕ} (hn : 1 ≤ n)",
    "doc_string": " The monomial function `x^n` tends to `+∞` at `+∞` for any positive natural `n`. A version for positive real powers exists as `tendsto_rpow_at_top`.",
    "type": "filter.tendsto (λ (x : α), x ^ n) filter.at_top filter.at_top"
  },
  {
    "name": "mul_eq_zero",
    "statement": "theorem mul_eq_zero {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b = 0 ↔ a = 0 ∨ b = 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b = 0 ↔ a = 0 ∨ b = 0",
    "args": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀}",
    "doc_string": " If `α` has no zero divisors, then the product of two elements equals zero iff one of them equals zero.",
    "type": "a * b = 0 ↔ a = 0 ∨ b = 0"
  },
  {
    "name": "list.length_pos_of_sum_pos",
    "statement": "theorem list.length_pos_of_sum_pos {M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum) : 0 < L.length",
    "theorem": "{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum) : 0 < L.length",
    "args": "{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum)",
    "doc_string": "A list with positive sum must have positive length.",
    "type": "0 < L.length"
  },
  {
    "name": "right.mul_lt_one'",
    "statement": "theorem right.mul_lt_one' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a < 1) (hb : b < 1)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.mul_lt_one'`.",
    "type": "a * b < 1"
  },
  {
    "name": "zero_lt.preorder.right.mul_le_one_of_le_of_le",
    "statement": "theorem zero_lt.preorder.right.mul_le_one_of_le_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b ≤ 1",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b ≤ 1",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "type": "a * b ≤ 1"
  },
  {
    "name": "char.quadratic_char_eq_zero_iff",
    "statement": "theorem char.quadratic_char_eq_zero_iff {F : Type u_1} [field F] [fintype F] [decidable_eq F] (a : F) : char.quadratic_char F a = 0 ↔ a = 0",
    "theorem": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (a : F) : char.quadratic_char F a = 0 ↔ a = 0",
    "args": "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (a : F)",
    "doc_string": "Some basic API lemmas",
    "type": "char.quadratic_char F a = 0 ↔ a = 0"
  },
  {
    "name": "dvd_of_mul_right_eq",
    "statement": "theorem dvd_of_mul_right_eq {α : Type u_1} [semigroup α] {a b : α} (c : α) (h : a * c = b) : a ∣ b",
    "theorem": "{α : Type u_1} [semigroup α] {a b : α} (c : α) (h : a * c = b) : a ∣ b",
    "args": "{α : Type u_1} [semigroup α] {a b : α} (c : α) (h : a * c = b)",
    "doc_string": "**Alias** of dvd.intro`.",
    "type": "a ∣ b"
  },
  {
    "name": "compact_of_is_closed_subset",
    "statement": "theorem compact_of_is_closed_subset {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t",
    "theorem": "{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t",
    "args": "{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s)",
    "doc_string": "A closed subset of a compact set is a compact set.",
    "type": "is_compact t"
  },
  {
    "name": "configuration.has_lines.card_le",
    "statement": "theorem configuration.has_lines.card_le (P L : Type u) [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L] : fintype.card P ≤ fintype.card L",
    "theorem": "(P L : Type u) [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L] : fintype.card P ≤ fintype.card L",
    "args": "(P L : Type u) [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L]",
    "doc_string": "If a nondegenerate configuration has a unique line through any two points, then `|P| ≤ |L|`.",
    "type": "fintype.card P ≤ fintype.card L"
  },
  {
    "name": "fintype.card_of_subsingleton",
    "statement": "theorem fintype.card_of_subsingleton {α : Type u_1} (a : α) [subsingleton α] : fintype.card α = 1",
    "theorem": "{α : Type u_1} (a : α) [subsingleton α] : fintype.card α = 1",
    "args": "{α : Type u_1} (a : α) [subsingleton α]",
    "doc_string": " Note: this lemma is specifically about `fintype.of_subsingleton`. For a statement about arbitrary `fintype` instances, use either `fintype.card_le_one_iff_subsingleton` or `fintype.card_unique`.",
    "type": "fintype.card α = 1"
  },
  {
    "name": "category_theory.over.construct_products.over_products_of_wide_pullbacks",
    "statement": "theorem category_theory.over.construct_products.over_products_of_wide_pullbacks {C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C} : category_theory.limits.has_products (category_theory.over B)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C} : category_theory.limits.has_products (category_theory.over B)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C}",
    "doc_string": "Given all wide pullbacks in `C`, construct products in `C/B`.",
    "type": "category_theory.limits.has_products (category_theory.over B)"
  },
  {
    "name": "is_of_fin_add_order.add",
    "statement": "theorem is_of_fin_add_order.add {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)",
    "theorem": "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)",
    "args": "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y)",
    "doc_string": "Elements of finite additive order are closed under addition.",
    "type": "is_of_fin_add_order (x + y)"
  },
  {
    "name": "minpoly.not_is_unit",
    "statement": "theorem minpoly.not_is_unit (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : ¬is_unit (minpoly A x)",
    "theorem": "(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : ¬is_unit (minpoly A x)",
    "args": "(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B]",
    "doc_string": "A minimal polynomial is not a unit.",
    "type": "¬is_unit (minpoly A x)"
  },
  {
    "name": "has_lt.lt.not_is_min",
    "statement": "theorem has_lt.lt.not_is_min {α : Type u_1} [preorder α] {a b : α} (h : b < a) : ¬is_min a",
    "theorem": "{α : Type u_1} [preorder α] {a b : α} (h : b < a) : ¬is_min a",
    "args": "{α : Type u_1} [preorder α] {a b : α} (h : b < a)",
    "doc_string": "**Alias** of not_is_min_of_lt`.",
    "type": "¬is_min a"
  },
  {
    "name": "sub_nonneg_of_le",
    "statement": "theorem sub_nonneg_of_le {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : b ≤ a → 0 ≤ a - b",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : b ≤ a → 0 ≤ a - b",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of sub_nonneg`.",
    "type": "b ≤ a → 0 ≤ a - b"
  },
  {
    "name": "path.truncate_continuous_family",
    "statement": "theorem path.truncate_continuous_family {X : Type u_1} [topological_space X] {a b : X} (γ : path a b) : continuous (λ (x : ℝ × ℝ × ↥unit_interval), ⇑(γ.truncate x.fst x.snd.fst) x.snd.snd)",
    "theorem": "{X : Type u_1} [topological_space X] {a b : X} (γ : path a b) : continuous (λ (x : ℝ × ℝ × ↥unit_interval), ⇑(γ.truncate x.fst x.snd.fst) x.snd.snd)",
    "args": "{X : Type u_1} [topological_space X] {a b : X} (γ : path a b)",
    "doc_string": "For a path `γ`, `γ.truncate` gives a \"continuous family of paths\", by which we  mean the uncurried function which maps `(t₀, t₁, s)` to `γ.truncate t₀ t₁ s` is continuous.",
    "type": "continuous (λ (x : ℝ × ℝ × ↥unit_interval), ⇑(γ.truncate x.fst x.snd.fst) x.snd.snd)"
  },
  {
    "name": "multiset.Icc_eq_zero",
    "statement": "theorem multiset.Icc_eq_zero {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a ≤ b → multiset.Icc a b = 0",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a ≤ b → multiset.Icc a b = 0",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of multiset.Icc_eq_zero_iff`.",
    "type": "¬a ≤ b → multiset.Icc a b = 0"
  },
  {
    "name": "pnat.factor_multiset_of_prime",
    "statement": "theorem pnat.factor_multiset_of_prime (p : nat.primes) : ↑p.factor_multiset = prime_multiset.of_prime p",
    "theorem": "(p : nat.primes) : ↑p.factor_multiset = prime_multiset.of_prime p",
    "args": "(p : nat.primes)",
    "doc_string": "Factoring a prime gives the corresponding one-element multiset.",
    "type": "↑p.factor_multiset = prime_multiset.of_prime p"
  },
  {
    "name": "power_basis.finite_dimensional",
    "statement": "theorem power_basis.finite_dimensional {S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] (pb : power_basis K S) : finite_dimensional K S",
    "theorem": "{S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] (pb : power_basis K S) : finite_dimensional K S",
    "args": "{S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] (pb : power_basis K S)",
    "doc_string": "Cannot be an instance because `power_basis` cannot be a class.",
    "type": "finite_dimensional K S"
  },
  {
    "name": "add_lt_of_lt_sub_left",
    "statement": "theorem add_lt_of_lt_sub_left {α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : b < c - a → a + b < c",
    "theorem": "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : b < c - a → a + b < c",
    "args": "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of lt_sub_iff_add_lt'`.",
    "type": "b < c - a → a + b < c"
  },
  {
    "name": "inv_lt",
    "statement": "theorem inv_lt {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b ↔ b⁻¹ < a",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b ↔ b⁻¹ < a",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": " In a linear ordered field, for positive `a` and `b` we have `a⁻¹ < b ↔ b⁻¹ < a`. See also `inv_lt_of_inv_lt` for a one-sided implication with one fewer assumption.",
    "type": "a⁻¹ < b ↔ b⁻¹ < a"
  },
  {
    "name": "not_is_left_regular_zero_iff",
    "statement": "theorem not_is_left_regular_zero_iff {R : Type u_1} [mul_zero_class R] : ¬is_left_regular 0 ↔ nontrivial R",
    "theorem": "{R : Type u_1} [mul_zero_class R] : ¬is_left_regular 0 ↔ nontrivial R",
    "args": "{R : Type u_1} [mul_zero_class R]",
    "doc_string": "In a non-trivial `mul_zero_class`, the `0` element is not left-regular.",
    "type": "¬is_left_regular 0 ↔ nontrivial R"
  },
  {
    "name": "dite_not",
    "statement": "theorem dite_not {α : Sort u_1} (P : Prop) [decidable P] (x : ¬P → α) (y : ¬¬P → α) : dite (¬P) x y = dite P (λ (h : P), y _) x",
    "theorem": "{α : Sort u_1} (P : Prop) [decidable P] (x : ¬P → α) (y : ¬¬P → α) : dite (¬P) x y = dite P (λ (h : P), y _) x",
    "args": "{α : Sort u_1} (P : Prop) [decidable P] (x : ¬P → α) (y : ¬¬P → α)",
    "doc_string": "Negation of the condition `P : Prop` in a `dite` is the same as swapping the branches.",
    "type": "dite (¬P) x y = dite P (λ (h : P), y _) x"
  },
  {
    "name": "well_founded.is_sup_closed_compact",
    "statement": "theorem well_founded.is_sup_closed_compact (α : Type u_1) [complete_lattice α] : well_founded gt → complete_lattice.is_sup_closed_compact α",
    "theorem": "(α : Type u_1) [complete_lattice α] : well_founded gt → complete_lattice.is_sup_closed_compact α",
    "args": "(α : Type u_1) [complete_lattice α]",
    "doc_string": "**Alias** of the reverse direction of complete_lattice.is_sup_closed_compact_iff_well_founded`.",
    "type": "well_founded gt → complete_lattice.is_sup_closed_compact α"
  },
  {
    "name": "finite_dimensional.nontrivial_of_finrank_pos",
    "statement": "theorem finite_dimensional.nontrivial_of_finrank_pos {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V) : nontrivial V",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V) : nontrivial V",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V)",
    "doc_string": "A finite dimensional space is nontrivial if it has positive `finrank`.",
    "type": "nontrivial V"
  },
  {
    "name": "ite_not",
    "statement": "theorem ite_not {α : Sort u_1} (P : Prop) [decidable P] (a b : α) : ite (¬P) a b = ite P b a",
    "theorem": "{α : Sort u_1} (P : Prop) [decidable P] (a b : α) : ite (¬P) a b = ite P b a",
    "args": "{α : Sort u_1} (P : Prop) [decidable P] (a b : α)",
    "doc_string": "Negation of the condition `P : Prop` in a `ite` is the same as swapping the branches.",
    "type": "ite (¬P) a b = ite P b a"
  },
  {
    "name": "is_chain.symm",
    "statement": "theorem is_chain.symm {α : Type u_1} {r : α → α → Prop} {s : set α} (h : is_chain r s) : is_chain (flip r) s",
    "theorem": "{α : Type u_1} {r : α → α → Prop} {s : set α} (h : is_chain r s) : is_chain (flip r) s",
    "args": "{α : Type u_1} {r : α → α → Prop} {s : set α} (h : is_chain r s)",
    "doc_string": "This can be used to turn `is_chain (≥)` into `is_chain (≤)` and vice-versa.",
    "type": "is_chain (flip r) s"
  },
  {
    "name": "affine_subspace.coe_injective",
    "statement": "theorem affine_subspace.coe_injective {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] : function.injective coe",
    "theorem": "{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] : function.injective coe",
    "args": "{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P]",
    "doc_string": "Two affine subspaces are equal if they have the same points.",
    "type": "function.injective coe"
  },
  {
    "name": "lt_mul_of_inv_mul_lt",
    "statement": "theorem lt_mul_of_inv_mul_lt {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b⁻¹ * a < c → a < b * c",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b⁻¹ * a < c → a < b * c",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of inv_mul_lt_iff_lt_mul`.",
    "type": "b⁻¹ * a < c → a < b * c"
  },
  {
    "name": "zero_lt.right.mul_lt_one_of_lt_of_le",
    "statement": "theorem zero_lt.right.mul_lt_one_of_lt_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b < 1",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b < 1",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b ≤ 1) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "type": "a * b < 1"
  },
  {
    "name": "dihedral_group.order_of_r",
    "statement": "theorem dihedral_group.order_of_r {n : ℕ} [fact (0 < n)] (i : zmod n) : order_of (dihedral_group.r i) = n / n.gcd i.val",
    "theorem": "{n : ℕ} [fact (0 < n)] (i : zmod n) : order_of (dihedral_group.r i) = n / n.gcd i.val",
    "args": "{n : ℕ} [fact (0 < n)] (i : zmod n)",
    "doc_string": "If `0 < n`, then `i : zmod n` has order `n / gcd n i`.",
    "type": "order_of (dihedral_group.r i) = n / n.gcd i.val"
  },
  {
    "name": "div_lt_div_of_mul_sub_mul_div_neg",
    "statement": "theorem div_lt_div_of_mul_sub_mul_div_neg {α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : (a * d - b * c) / (c * d) < 0 → a / c < b / d",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : (a * d - b * c) / (c * d) < 0 → a / c < b / d",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0)",
    "doc_string": "**Alias** of the forward direction of mul_sub_mul_div_mul_neg_iff`.",
    "type": "(a * d - b * c) / (c * d) < 0 → a / c < b / d"
  },
  {
    "name": "category_theory.limits.has_binary_biproducts.of_has_binary_coproducts",
    "statement": "theorem category_theory.limits.has_binary_biproducts.of_has_binary_coproducts {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C] : category_theory.limits.has_binary_biproducts C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C] : category_theory.limits.has_binary_biproducts C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C]",
    "doc_string": "In a preadditive category, if all binary coproducts exist, then all binary biproducts exist.",
    "type": "category_theory.limits.has_binary_biproducts C"
  },
  {
    "name": "prime_dvd_char_iff_dvd_card",
    "statement": "theorem prime_dvd_char_iff_dvd_card {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : p ∣ ring_char R ↔ p ∣ fintype.card R",
    "theorem": "{R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : p ∣ ring_char R ↔ p ∣ fintype.card R",
    "args": "{R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)]",
    "doc_string": " The prime divisors of the characteristic of a finite commutative ring are exactly the prime divisors of its cardinality.",
    "type": "p ∣ ring_char R ↔ p ∣ fintype.card R"
  },
  {
    "name": "same_ray.neg",
    "statement": "theorem same_ray.neg {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R x y → same_ray R (-x) (-y)",
    "theorem": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R x y → same_ray R (-x) (-y)",
    "args": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M}",
    "doc_string": "**Alias** of the reverse direction of same_ray_neg_iff`.",
    "type": "same_ray R x y → same_ray R (-x) (-y)"
  },
  {
    "name": "neg_nonneg",
    "statement": "theorem neg_nonneg {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : 0 ≤ -a ↔ a ≤ 0",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : 0 ≤ -a ↔ a ≤ 0",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α}",
    "doc_string": "**Alias** of left.one_le_inv_iff`.",
    "type": "0 ≤ -a ↔ a ≤ 0"
  },
  {
    "name": "is_add_hom.neg",
    "statement": "theorem is_add_hom.neg {α : Type u_1} {β : Type u_2} [has_add α] [add_comm_group β] {f : α → β} (hf : is_add_hom f) : is_add_hom (λ (a : α), -f a)",
    "theorem": "{α : Type u_1} {β : Type u_2} [has_add α] [add_comm_group β] {f : α → β} (hf : is_add_hom f) : is_add_hom (λ (a : α), -f a)",
    "args": "{α : Type u_1} {β : Type u_2} [has_add α] [add_comm_group β] {f : α → β} (hf : is_add_hom f)",
    "doc_string": "The negation of a map which preserves addition, preserves addition when the target is commutative.",
    "type": "is_add_hom (λ (a : α), -f a)"
  },
  {
    "name": "con.trans",
    "statement": "theorem con.trans {M : Type u_1} [has_mul M] (c : con M) {x y z : M} : ⇑c x y → ⇑c y z → ⇑c x z",
    "theorem": "{M : Type u_1} [has_mul M] (c : con M) {x y z : M} : ⇑c x y → ⇑c y z → ⇑c x z",
    "args": "{M : Type u_1} [has_mul M] (c : con M) {x y z : M}",
    "doc_string": "Congruence relations are transitive.",
    "type": "⇑c x y → ⇑c y z → ⇑c x z"
  },
  {
    "name": "order.pred_ne_pred",
    "statement": "theorem order.pred_ne_pred {α : Type u_1} [partial_order α] [pred_order α] {a b : α} [no_min_order α] : a ≠ b → order.pred a ≠ order.pred b",
    "theorem": "{α : Type u_1} [partial_order α] [pred_order α] {a b : α} [no_min_order α] : a ≠ b → order.pred a ≠ order.pred b",
    "args": "{α : Type u_1} [partial_order α] [pred_order α] {a b : α} [no_min_order α]",
    "doc_string": "**Alias** of the reverse direction of order.pred_ne_pred_iff`.",
    "type": "a ≠ b → order.pred a ≠ order.pred b"
  },
  {
    "name": "right_iff_left_not_left_of",
    "statement": "theorem right_iff_left_not_left_of {α : Type u} (r s : α → α → Prop) [is_nonstrict_strict_order α r s] {a b : α} : s a b ↔ r a b ∧ ¬r b a",
    "theorem": "{α : Type u} (r s : α → α → Prop) [is_nonstrict_strict_order α r s] {a b : α} : s a b ↔ r a b ∧ ¬r b a",
    "args": "{α : Type u} (r s : α → α → Prop) [is_nonstrict_strict_order α r s] {a b : α}",
    "doc_string": "A version of `right_iff_left_not_left` with explicit `r` and `s`.",
    "type": "s a b ↔ r a b ∧ ¬r b a"
  },
  {
    "name": "lt_sub_left_of_add_lt",
    "statement": "theorem lt_sub_left_of_add_lt {α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a + b < c → b < c - a",
    "theorem": "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a + b < c → b < c - a",
    "args": "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of lt_sub_iff_add_lt'`.",
    "type": "a + b < c → b < c - a"
  },
  {
    "name": "one_add_mul_le_pow'",
    "statement": "theorem one_add_mul_le_pow' {R : Type u₁} [ordered_semiring R] {a : R} (Hsq : 0 ≤ a * a) (Hsq' : 0 ≤ (1 + a) * (1 + a)) (H : 0 ≤ 2 + a) (n : ℕ) : 1 + ↑n * a ≤ (1 + a) ^ n",
    "theorem": "{R : Type u₁} [ordered_semiring R] {a : R} (Hsq : 0 ≤ a * a) (Hsq' : 0 ≤ (1 + a) * (1 + a)) (H : 0 ≤ 2 + a) (n : ℕ) : 1 + ↑n * a ≤ (1 + a) ^ n",
    "args": "{R : Type u₁} [ordered_semiring R] {a : R} (Hsq : 0 ≤ a * a) (Hsq' : 0 ≤ (1 + a) * (1 + a)) (H : 0 ≤ 2 + a) (n : ℕ)",
    "doc_string": " Bernoulli's inequality. This version works for semirings but requires additional hypotheses `0 ≤ a * a` and `0 ≤ (1 + a) * (1 + a)`.",
    "type": "1 + ↑n * a ≤ (1 + a) ^ n"
  },
  {
    "name": "volume_Union_set_of_liouville_with",
    "statement": "theorem volume_Union_set_of_liouville_with  : ⇑measure_theory.measure_space.volume (⋃ (p : ℝ) (hp : 2 < p), {x : ℝ | liouville_with p x}) = 0",
    "theorem": " : ⇑measure_theory.measure_space.volume (⋃ (p : ℝ) (hp : 2 < p), {x : ℝ | liouville_with p x}) = 0",
    "args": "",
    "doc_string": " The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue measure zero.",
    "type": "⇑measure_theory.measure_space.volume (⋃ (p : ℝ) (hp : 2 < p), {x : ℝ | liouville_with p x}) = 0"
  },
  {
    "name": "category_theory.indecomposable_of_simple",
    "statement": "theorem category_theory.indecomposable_of_simple {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X]",
    "doc_string": "Any simple object in a preadditive category is indecomposable.",
    "type": "category_theory.indecomposable X"
  },
  {
    "name": "is_add_right_regular_of_right_cancel_add_semigroup",
    "statement": "theorem is_add_right_regular_of_right_cancel_add_semigroup {R : Type u_1} [add_right_cancel_semigroup R] (g : R) : is_add_right_regular g",
    "theorem": "{R : Type u_1} [add_right_cancel_semigroup R] (g : R) : is_add_right_regular g",
    "args": "{R : Type u_1} [add_right_cancel_semigroup R] (g : R)",
    "doc_string": "Elements of an add right cancel semigroup are add-right-regular",
    "type": "is_add_right_regular g"
  },
  {
    "name": "div_le_of_nonneg_of_le_mul",
    "statement": "theorem div_le_of_nonneg_of_le_mul {α : Type u_1} [linear_ordered_field α] {a b c : α} (hb : 0 ≤ b) (hc : 0 ≤ c) (h : a ≤ c * b) : a / b ≤ c",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b c : α} (hb : 0 ≤ b) (hc : 0 ≤ c) (h : a ≤ c * b) : a / b ≤ c",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b c : α} (hb : 0 ≤ b) (hc : 0 ≤ c) (h : a ≤ c * b)",
    "doc_string": "One direction of `div_le_iff` where `b` is allowed to be `0` (but `c` must be nonnegative)",
    "type": "a / b ≤ c"
  },
  {
    "name": "nat.cast_div_le",
    "statement": "theorem nat.cast_div_le {α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n",
    "args": "{α : Type u_1} [linear_ordered_field α] {m n : ℕ}",
    "doc_string": "Natural division is always less than division in the field.",
    "type": "↑(m / n) ≤ ↑m / ↑n"
  },
  {
    "name": "finset.Ico_eq_empty",
    "statement": "theorem finset.Ico_eq_empty {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → finset.Ico a b = ∅",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → finset.Ico a b = ∅",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of finset.Ico_eq_empty_iff`.",
    "type": "¬a < b → finset.Ico a b = ∅"
  }
]