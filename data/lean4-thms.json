[{"type": "Injective f",
  "tactic-prompt":
  "example (X Y Z : Type)  (f : X → Y)  (g : Y → Z)  (H : Injective $ g ∘ f) : Injective f := by intros x x' h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros x x' h",
  "core-prompt":
  "(X Y Z : Type)  (f : X → Y)  (g : Y → Z)  (H : Injective $ g ∘ f) : Injective f",
  "args": "(X Y Z : Type)  (f : X → Y)  (g : Y → Z)  (H : Injective $ g ∘ f)"},
 {"type": "1 = 1",
  "tactic-prompt":
  "example (x : Int)  (h : x = 1) : 1 = 1 := by apply_fun (fun p => p) at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_fun (fun p => p) at h",
  "core-prompt": "(x : Int)  (h : x = 1) : 1 = 1",
  "args": "(x : Int)  (h : x = 1)"},
 {"type": "a + 1 = b + 1",
  "tactic-prompt":
  "example (a b : Int)  (h : a = b) : a + 1 = b + 1 := by apply_fun (fun n => n+1) at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_fun (fun n => n+1) at h",
  "core-prompt": "(a b : Int)  (h : a = b) : a + 1 = b + 1",
  "args": "(a b : Int)  (h : a = b)"},
 {"type": "True",
  "tactic-prompt":
  "example (P : Nat → Type)  (Q : (n : Nat) -> P n)  (a b : Nat)  (h : a = b) : True := by fail_if_success apply_fun Q at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success apply_fun Q at h",
  "core-prompt":
  "(P : Nat → Type)  (Q : (n : Nat) -> P n)  (a b : Nat)  (h : a = b) : True",
  "args": "(P : Nat → Type)  (Q : (n : Nat) -> P n)  (a b : Nat)  (h : a = b)"},
 {"type": "f a ≤ f b",
  "tactic-prompt":
  "example (f : ℕ → ℕ)  (a b : ℕ)  (monof : Monotone f)  (h : a ≤ b) : f a ≤ f b := by apply_fun f at h using monof; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_fun f at h using monof",
  "core-prompt":
  "(f : ℕ → ℕ)  (a b : ℕ)  (monof : Monotone f)  (h : a ≤ b) : f a ≤ f b",
  "args": "(f : ℕ → ℕ)  (a b : ℕ)  (monof : Monotone f)  (h : a ≤ b)"},
 {"type": "f a ≤ f b",
  "tactic-prompt":
  "example (f : ℕ → ℕ)  (a b : ℕ)  (monof : Monotone f)  (h : a ≤ b) : f a ≤ f b := by apply_fun f at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_fun f at h",
  "core-prompt":
  "(f : ℕ → ℕ)  (a b : ℕ)  (monof : Monotone f)  (h : a ≤ b) : f a ≤ f b",
  "args": "(f : ℕ → ℕ)  (a b : ℕ)  (monof : Monotone f)  (h : a ≤ b)"},
 {"type": "n ≠ m",
  "tactic-prompt":
  "example (n m : ℕ)  (f : ℕ → ℕ)  (h : f n ≠ f m) : n ≠ m := by apply_fun f; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_fun f",
  "core-prompt": "(n m : ℕ)  (f : ℕ → ℕ)  (h : f n ≠ f m) : n ≠ m",
  "args": "(n m : ℕ)  (f : ℕ → ℕ)  (h : f n ≠ f m)"},
 {"type": "n = m",
  "tactic-prompt":
  "example (n m : ℕ)  (f : ℕ → ℕ)  (w : Function.Injective f)  (h : f n = f m) : n = m := by apply_fun f; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_fun f",
  "core-prompt":
  "(n m : ℕ)  (f : ℕ → ℕ)  (w : Function.Injective f)  (h : f n = f m) : n = m",
  "args":
  "(n m : ℕ)  (f : ℕ → ℕ)  (w : Function.Injective f)  (h : f n = f m)"},
 {"type": "n = m",
  "tactic-prompt":
  "example (n m : ℕ)  (f : ℕ → ℕ)  (w : Function.Injective f)  (h : f n = f m) : n = m := by apply_fun f using w; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_fun f using w",
  "core-prompt":
  "(n m : ℕ)  (f : ℕ → ℕ)  (w : Function.Injective f)  (h : f n = f m) : n = m",
  "args":
  "(n m : ℕ)  (f : ℕ → ℕ)  (w : Function.Injective f)  (h : f n = f m)"},
 {"type": "n = m",
  "tactic-prompt":
  "example (n m : ℕ)  (f : ℕ → ℕ)  (w : Function.Injective f ∧ true)  (h : f n = f m) : n = m := by apply_fun f using w.1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_fun f using w.1",
  "core-prompt":
  "(n m : ℕ)  (f : ℕ → ℕ)  (w : Function.Injective f ∧ true)  (h : f n = f m) : n = m",
  "args":
  "(n m : ℕ)  (f : ℕ → ℕ)  (w : Function.Injective f ∧ true)  (h : f n = f m)"},
 {"type": "True",
  "tactic-prompt": "example  : True := by have h1 := forward; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have h1 := forward",
  "core-prompt": " : True",
  "args": ""},
 {"type": "Foo",
  "tactic-prompt": "example  : Foo := by fconstructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fconstructor",
  "core-prompt": " : Foo",
  "args": ""},
 {"type": "Foo",
  "tactic-prompt": "example  : Foo := by econstructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "econstructor",
  "core-prompt": " : Foo",
  "args": ""},
 {"type": "a < b",
  "tactic-prompt":
  "example (a b : ℕ)  (foo : False) : a < b := by by_contra'; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra'",
  "core-prompt": "(a b : ℕ)  (foo : False) : a < b",
  "args": "(a b : ℕ)  (foo : False)"},
 {"type": "a < b",
  "tactic-prompt":
  "example (a b : ℕ)  (h : False) : a < b := by by_contra' foo; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra' foo",
  "core-prompt": "(a b : ℕ)  (h : False) : a < b",
  "args": "(a b : ℕ)  (h : False)"},
 {"type": "a < b",
  "tactic-prompt":
  "example (a b : ℕ)  (h : False) : a < b := by by_contra' foo : ¬ a < b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra' foo : ¬ a < b",
  "core-prompt": "(a b : ℕ)  (h : False) : a < b",
  "args": "(a b : ℕ)  (h : False)"},
 {"type": "1 < 2",
  "tactic-prompt": "example  : 1 < 2 := by by_contra'; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra'",
  "core-prompt": " : 1 < 2",
  "args": ""},
 {"type": "¬ ¬ ¬ ¬ ¬ ¬ P",
  "tactic-prompt":
  "example (p : Prop)  (bar : False) : ¬ ¬ ¬ ¬ ¬ ¬ P := by by_contra' foo : ¬ ¬ ¬ P; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra' foo : ¬ ¬ ¬ P",
  "core-prompt": "(p : Prop)  (bar : False) : ¬ ¬ ¬ ¬ ¬ ¬ P",
  "args": "(p : Prop)  (bar : False)"},
 {"type": "¬ ¬ ¬ ¬ ¬ ¬ P",
  "tactic-prompt":
  "example (p : Prop)  (bar : False) : ¬ ¬ ¬ ¬ ¬ ¬ P := by by_contra' : ¬ ¬ ¬ P; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra' : ¬ ¬ ¬ P",
  "core-prompt": "(p : Prop)  (bar : False) : ¬ ¬ ¬ ¬ ¬ ¬ P",
  "args": "(p : Prop)  (bar : False)"},
 {"type":
  "(e.trans e').source = e.source ∩ Set.preimage e (e.target ∩ e'.source)",
  "tactic-prompt":
  "example (e : LocalEquiv α β)  (e' : LocalEquiv β γ) : (e.trans e').source = e.source ∩ Set.preimage e (e.target ∩ e'.source) := by mfld_set_tac; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mfld_set_tac",
  "core-prompt":
  "(e : LocalEquiv α β)  (e' : LocalEquiv β γ) : (e.trans e').source = e.source ∩ Set.preimage e (e.target ∩ e'.source)",
  "args": "(e : LocalEquiv α β)  (e' : LocalEquiv β γ)"},
 {"type": "(e.trans e.symm).source = e.source",
  "tactic-prompt":
  "example (e : LocalEquiv α β) : (e.trans e.symm).source = e.source := by mfld_set_tac; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mfld_set_tac",
  "core-prompt": "(e : LocalEquiv α β) : (e.trans e.symm).source = e.source",
  "args": "(e : LocalEquiv α β)"},
 {"type":
  "f.symm.toLocalEquiv.source ∩ (f.toLocalEquiv.target ∩ Set.preimage f.symm s)\n  = f.symm.toLocalEquiv.source ∩ Set.preimage f.symm s",
  "tactic-prompt":
  "example (s : Set α)  (f : LocalHomeomorph α β) : f.symm.toLocalEquiv.source ∩ (f.toLocalEquiv.target ∩ Set.preimage f.symm s)\n  = f.symm.toLocalEquiv.source ∩ Set.preimage f.symm s := by mfld_set_tac; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mfld_set_tac",
  "core-prompt":
  "(s : Set α)  (f : LocalHomeomorph α β) : f.symm.toLocalEquiv.source ∩ (f.toLocalEquiv.target ∩ Set.preimage f.symm s)\n  = f.symm.toLocalEquiv.source ∩ Set.preimage f.symm s",
  "args": "(s : Set α)  (f : LocalHomeomorph α β)"},
 {"type":
  "(Set.preimage (f ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm))\n      (e₂.toLocalEquiv.trans I'.toLocalEquiv).source) ⊆\n    {y : E |\n    ((e₃.toLocalEquiv.trans I''.toLocalEquiv) ∘\n          (g ∘ f) ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm)) y\n    = (((e₃.toLocalEquiv.trans I''.toLocalEquiv : M'' → E'') ∘\n             g ∘ ((e₂.toLocalEquiv.trans I'.toLocalEquiv).symm)) ∘\n          (e₂.toLocalEquiv.trans I'.toLocalEquiv : M' → E') ∘\n            f ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm)) y}",
  "tactic-prompt":
  "example {I : ModelWithCorners 𝕜 E H}    {I' : ModelWithCorners 𝕜 E' H'}    {I'' : ModelWithCorners 𝕜 E'' H''}    (e₁ : LocalHomeomorph M H)    (e₂ : LocalHomeomorph M' H')    (e₃ : LocalHomeomorph M'' H'')    {f : M → M'}    {g : M' → M''} : (Set.preimage (f ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm))\n      (e₂.toLocalEquiv.trans I'.toLocalEquiv).source) ⊆\n    {y : E |\n    ((e₃.toLocalEquiv.trans I''.toLocalEquiv) ∘\n          (g ∘ f) ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm)) y\n    = (((e₃.toLocalEquiv.trans I''.toLocalEquiv : M'' → E'') ∘\n             g ∘ ((e₂.toLocalEquiv.trans I'.toLocalEquiv).symm)) ∘\n          (e₂.toLocalEquiv.trans I'.toLocalEquiv : M' → E') ∘\n            f ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm)) y} := by mfld_set_tac; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mfld_set_tac",
  "core-prompt":
  "{I : ModelWithCorners 𝕜 E H}    {I' : ModelWithCorners 𝕜 E' H'}    {I'' : ModelWithCorners 𝕜 E'' H''}    (e₁ : LocalHomeomorph M H)    (e₂ : LocalHomeomorph M' H')    (e₃ : LocalHomeomorph M'' H'')    {f : M → M'}    {g : M' → M''} : (Set.preimage (f ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm))\n      (e₂.toLocalEquiv.trans I'.toLocalEquiv).source) ⊆\n    {y : E |\n    ((e₃.toLocalEquiv.trans I''.toLocalEquiv) ∘\n          (g ∘ f) ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm)) y\n    = (((e₃.toLocalEquiv.trans I''.toLocalEquiv : M'' → E'') ∘\n             g ∘ ((e₂.toLocalEquiv.trans I'.toLocalEquiv).symm)) ∘\n          (e₂.toLocalEquiv.trans I'.toLocalEquiv : M' → E') ∘\n            f ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm)) y}",
  "args":
  "{I : ModelWithCorners 𝕜 E H}    {I' : ModelWithCorners 𝕜 E' H'}    {I'' : ModelWithCorners 𝕜 E'' H''}    (e₁ : LocalHomeomorph M H)    (e₂ : LocalHomeomorph M' H')    (e₃ : LocalHomeomorph M'' H'')    {f : M → M'}    {g : M' → M''}"},
 {"type": "True",
  "tactic-prompt":
  "example {α : Type}  (h : ∀ n m : α, ∀ (h : n = m), ∃ i j : α, i ≠ j ∧ h = h) : True := by choose! i j _x _y using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose! i j _x _y using h",
  "core-prompt":
  "{α : Type}  (h : ∀ n m : α, ∀ (h : n = m), ∃ i j : α, i ≠ j ∧ h = h) : True",
  "args":
  "{α : Type}  (h : ∀ n m : α, ∀ (h : n = m), ∃ i j : α, i ≠ j ∧ h = h)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : ∀ n m : Nat, ∃ i j, m = n + i ∨ m + j = n) : True := by choose i j h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose i j h using h",
  "core-prompt": "(h : ∀ n m : Nat, ∃ i j, m = n + i ∨ m + j = n) : True",
  "args": "(h : ∀ n m : Nat, ∃ i j, m = n + i ∨ m + j = n)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : ∀ i : Nat, i < 7 → ∃ j, i < j ∧ j < i+i) : True := by choose! f h h' using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose! f h h' using h",
  "core-prompt": "(h : ∀ i : Nat, i < 7 → ∃ j, i < j ∧ j < i+i) : True",
  "args": "(h : ∀ i : Nat, i < 7 → ∃ j, i < j ∧ j < i+i)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : ∀ n m : Nat, n < m → ∃ i j, m = n + i ∨ m + j = n) : True := by choose i j h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose i j h using h",
  "core-prompt":
  "(h : ∀ n m : Nat, n < m → ∃ i j, m = n + i ∨ m + j = n) : True",
  "args": "(h : ∀ n m : Nat, n < m → ∃ i j, m = n + i ∨ m + j = n)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : ∀ n m : Nat, n < m → ∃ i j, m = n + i ∨ m + j = n) : True := by choose! i j h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose! i j h using h",
  "core-prompt":
  "(h : ∀ n m : Nat, n < m → ∃ i j, m = n + i ∨ m + j = n) : True",
  "args": "(h : ∀ n m : Nat, n < m → ∃ i j, m = n + i ∨ m + j = n)"},
 {"type": "(∀ m : Nat, ∃ i, ∀ n : Nat, ∃ j, m = n + i ∨ m + j = n) → True",
  "tactic-prompt":
  "example  : (∀ m : Nat, ∃ i, ∀ n : Nat, ∃ j, m = n + i ∨ m + j = n) → True := by choose i j h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose i j h",
  "core-prompt":
  " : (∀ m : Nat, ∃ i, ∀ n : Nat, ∃ j, m = n + i ∨ m + j = n) → True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (h : ∀ _n m : Nat, ∃ i, ∀ n:Nat, ∃ j, m = n + i ∨ m + j = n) : True := by choose i j h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose i j h using h",
  "core-prompt":
  "(h : ∀ _n m : Nat, ∃ i, ∀ n:Nat, ∃ j, m = n + i ∨ m + j = n) : True",
  "args": "(h : ∀ _n m : Nat, ∃ i, ∀ n:Nat, ∃ j, m = n + i ∨ m + j = n)"},
 {"type": "∀ _ : Nat, 1 = 1",
  "tactic-prompt":
  "example (h : ∀ n, ∃ k ≥ 0, n = k) : ∀ _ : Nat, 1 = 1 := by choose u hu using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose u hu using h",
  "core-prompt": "(h : ∀ n, ∃ k ≥ 0, n = k) : ∀ _ : Nat, 1 = 1",
  "args": "(h : ∀ n, ∃ k ≥ 0, n = k)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : ∀ i : Nat, ∃ j, i < j ∧ j < i+i) : True := by choose f h h' using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose f h h' using h",
  "core-prompt": "(h : ∀ i : Nat, ∃ j, i < j ∧ j < i+i) : True",
  "args": "(h : ∀ i : Nat, ∃ j, i < j ∧ j < i+i)"},
 {"type": "True",
  "tactic-prompt":
  "example {α : Type u}  (p : α → Prop)  (h : ∀ i : α, p i → ∃ j : α × α, p j.1) : True := by choose! f h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose! f h using h",
  "core-prompt":
  "{α : Type u}  (p : α → Prop)  (h : ∀ i : α, p i → ∃ j : α × α, p j.1) : True",
  "args":
  "{α : Type u}  (p : α → Prop)  (h : ∀ i : α, p i → ∃ j : α × α, p j.1)"},
 {"type": "(¬p ∧ ¬q) → ¬(p ∨ q)",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : (¬p ∧ ¬q) → ¬(p ∨ q) := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : (¬p ∧ ¬q) → ¬(p ∨ q)",
  "args": "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop}"},
 {"type": "¬(p ∧ q) → (p → ¬q)",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : ¬(p ∧ q) → (p → ¬q) := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : ¬(p ∧ q) → (p → ¬q)",
  "args": "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop}"},
 {"type": "(∀(x : α), ¬ p' x) → ¬ ∃(x : α), p' x",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : (∀(x : α), ¬ p' x) → ¬ ∃(x : α), p' x := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : (∀(x : α), ¬ p' x) → ¬ ∃(x : α), p' x",
  "args": "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop}"},
 {"type": "(¬ ∀(x : α), p' x) → (∃(x : α), ¬ p' x)",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : (¬ ∀(x : α), p' x) → (∃(x : α), ¬ p' x) := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : (¬ ∀(x : α), p' x) → (∃(x : α), ¬ p' x)",
  "args": "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop}"},
 {"type": "decide (¬ ¬ p) = p",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (p : Bool) : decide (¬ ¬ p) = p := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (p : Bool) : decide (¬ ¬ p) = p",
  "args":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (p : Bool)"},
 {"type": "((fun x => x+x) 1) = 2",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : ((fun x => x+x) 1) = 2 := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : ((fun x => x+x) 1) = 2",
  "args": "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop}"},
 {"type": "¬ ¬ p = p",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : ¬ ¬ p = p := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : ¬ ¬ p = p",
  "args": "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop}"},
 {"type": "¬(x ≤ y)",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (x y : β)  (h : y < x) : ¬(x ≤ y) := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (x y : β)  (h : y < x) : ¬(x ≤ y)",
  "args":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (x y : β)  (h : y < x)"},
 {"type": "¬ (x ≠ y)",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (x y : α)  (h : x = y) : ¬ (x ≠ y) := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (x y : α)  (h : x = y) : ¬ (x ≠ y)",
  "args":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (x y : α)  (h : x = y)"},
 {"type": "¬∃ (y : Unit), (y ≠ ())",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : ¬∃ (y : Unit), (y ≠ ()) := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : ¬∃ (y : Unit), (y ≠ ())",
  "args": "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop}"},
 {"type": "¬∀ (y : Nat), (y = 1)",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (h : ∃ y : Nat, ¬(y=1)) : ¬∀ (y : Nat), (y = 1) := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (h : ∃ y : Nat, ¬(y=1)) : ¬∀ (y : Nat), (y = 1)",
  "args":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (h : ∃ y : Nat, ¬(y=1))"},
 {"type": "¬¬¬ (x ≤ y)",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (x y : β)  (h : y < x) : ¬¬¬ (x ≤ y) := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (x y : β)  (h : y < x) : ¬¬¬ (x ≤ y)",
  "args":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (x y : β)  (h : y < x)"},
 {"type": "¬ ∀(x y : Nat), x = y",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (x y : β)  (h₁ : ¬¬¬(x < y))  (h₂ : ¬∃ (x y : Nat), x = y) : ¬ ∀(x y : Nat), x = y := by push_neg at *; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg at *",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (x y : β)  (h₁ : ¬¬¬(x < y))  (h₂ : ¬∃ (x y : Nat), x = y) : ¬ ∀(x y : Nat), x = y",
  "args":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (x y : β)  (h₁ : ¬¬¬(x < y))  (h₂ : ¬∃ (x y : Nat), x = y)"},
 {"type": "¬ ∀(x y : Nat), x = y",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (x y : β)  (h₁ : ¬¬¬(x < y))  (h₂ : ¬∃ (x y : Nat), x = y) : ¬ ∀(x y : Nat), x = y := by push_neg at h₁ h₂ ⊢; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg at h₁ h₂ ⊢",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (x y : β)  (h₁ : ¬¬¬(x < y))  (h₂ : ¬∃ (x y : Nat), x = y) : ¬ ∀(x y : Nat), x = y",
  "args":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (x y : β)  (h₁ : ¬¬¬(x < y))  (h₂ : ¬∃ (x y : Nat), x = y)"},
 {"type": "¬ (p ∧ q)",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (h : p → ¬ q) : ¬ (p ∧ q) := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (h : p → ¬ q) : ¬ (p ∧ q)",
  "args":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (h : p → ¬ q)"},
 {"type": "¬ ∀ x : β, x < a → ∃ y : β, (y < a) ∧ ∀ z : β, x = z",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (a : β) : ¬ ∀ x : β, x < a → ∃ y : β, (y < a) ∧ ∀ z : β, x = z := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (a : β) : ¬ ∀ x : β, x < a → ∃ y : β, (y < a) ∧ ∀ z : β, x = z",
  "args":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (a : β)"},
 {"type": "¬ (p ∧ q)",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (h : ¬ p ∨ ¬ q) : ¬ (p ∧ q) := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (h : ¬ p ∨ ¬ q) : ¬ (p ∧ q)",
  "args":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (h : ¬ p ∨ ¬ q)"},
 {"type": "p →  ¬ ¬ ¬ ¬ ¬ ¬ p",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : p →  ¬ ¬ ¬ ¬ ¬ ¬ p := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : p →  ¬ ¬ ¬ ¬ ¬ ¬ p",
  "args": "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop}"},
 {"type": "¬(x = 0 → y = 0)",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (h : x = 0 ∧ y ≠ 0) : ¬(x = 0 → y = 0) := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (h : x = 0 ∧ y ≠ 0) : ¬(x = 0 → y = 0)",
  "args":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} (h : x = 0 ∧ y ≠ 0)"},
 {"type": "True",
  "tactic-prompt": "example  : True := by triv; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "triv",
  "core-prompt": " : True",
  "args": ""},
 {"type": "2 + 2 = 4",
  "tactic-prompt": "example  : 2 + 2 = 4 := by triv; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "triv",
  "core-prompt": " : 2 + 2 = 4",
  "args": ""},
 {"type": "False",
  "tactic-prompt":
  "example (P : Prop)  (h1 : P)  (h2 : ¬ P) : False := by fail_if_success triv; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success triv",
  "core-prompt": "(P : Prop)  (h1 : P)  (h2 : ¬ P) : False",
  "args": "(P : Prop)  (h1 : P)  (h2 : ¬ P)"},
 {"type":
  "374 + (32 - (2 * 8123) : ℤ) - 61 * 50 = 86 + 32 * 32 - 4 * 5000\n      ∧ 43 ≤ 74 + (33 : ℤ)",
  "tactic-prompt":
  "example  : 374 + (32 - (2 * 8123) : ℤ) - 61 * 50 = 86 + 32 * 32 - 4 * 5000\n      ∧ 43 ≤ 74 + (33 : ℤ) := by norm_num1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num1",
  "core-prompt":
  " : 374 + (32 - (2 * 8123) : ℤ) - 61 * 50 = 86 + 32 * 32 - 4 * 5000\n      ∧ 43 ≤ 74 + (33 : ℤ)",
  "args": ""},
 {"type": "2 ^ 17 - 1 = 131071",
  "tactic-prompt": "example  : 2 ^ 17 - 1 = 131071 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 2 ^ 17 - 1 = 131071",
  "args": ""},
 {"type": "(5 / 2:ℕ) = 2",
  "tactic-prompt": "example  : (5 / 2:ℕ) = 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (5 / 2:ℕ) = 2",
  "args": ""},
 {"type": "(5 / -2:ℤ) < -1",
  "tactic-prompt": "example  : (5 / -2:ℤ) < -1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (5 / -2:ℤ) < -1",
  "args": ""},
 {"type": "(0 + 1) / 2 < 0 + 1",
  "tactic-prompt": "example  : (0 + 1) / 2 < 0 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (0 + 1) / 2 < 0 + 1",
  "args": ""},
 {"type": "Nat.succ (Nat.succ (2 ^ 3)) = 10",
  "tactic-prompt":
  "example  : Nat.succ (Nat.succ (2 ^ 3)) = 10 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : Nat.succ (Nat.succ (2 ^ 3)) = 10",
  "args": ""},
 {"type": "(12321 - 2 : ℤ) = 12319",
  "tactic-prompt": "example  : (12321 - 2 : ℤ) = 12319 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (12321 - 2 : ℤ) = 12319",
  "args": ""},
 {"type": "100 * 30 < x",
  "tactic-prompt":
  "example (x : ℤ)  (h : 1000 + 2000 < x) : 100 * 30 < x := by norm_num at *; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num at *",
  "core-prompt": "(x : ℤ)  (h : 1000 + 2000 < x) : 100 * 30 < x",
  "args": "(x : ℤ)  (h : 1000 + 2000 < x)"},
 {"type": "(1103 : ℤ) ≤ (2102 : ℤ)",
  "tactic-prompt": "example  : (1103 : ℤ) ≤ (2102 : ℤ) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (1103 : ℤ) ≤ (2102 : ℤ)",
  "args": ""},
 {"type": "(110474 : ℤ) ≤ (210485 : ℤ)",
  "tactic-prompt":
  "example  : (110474 : ℤ) ≤ (210485 : ℤ) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (110474 : ℤ) ≤ (210485 : ℤ)",
  "args": ""},
 {"type": "(11047462383473829263 : ℤ) ≤ (21048574677772382462 : ℤ)",
  "tactic-prompt":
  "example  : (11047462383473829263 : ℤ) ≤ (21048574677772382462 : ℤ) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (11047462383473829263 : ℤ) ≤ (21048574677772382462 : ℤ)",
  "args": ""},
 {"type": "(210485742382937847263 : ℤ) ≤ (1104857462382937847262 : ℤ)",
  "tactic-prompt":
  "example  : (210485742382937847263 : ℤ) ≤ (1104857462382937847262 : ℤ) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  " : (210485742382937847263 : ℤ) ≤ (1104857462382937847262 : ℤ)",
  "args": ""},
 {"type": "(210485987642382937847263 : ℕ) ≤ (11048512347462382937847262 : ℕ)",
  "tactic-prompt":
  "example  : (210485987642382937847263 : ℕ) ≤ (11048512347462382937847262 : ℕ) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  " : (210485987642382937847263 : ℕ) ≤ (11048512347462382937847262 : ℕ)",
  "args": ""},
 {"type": "(2 * 12868 + 25705) * 11621 ^ 2 ≤ 23235 ^ 2 * 12868",
  "tactic-prompt":
  "example  : (2 * 12868 + 25705) * 11621 ^ 2 ≤ 23235 ^ 2 * 12868 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (2 * 12868 + 25705) * 11621 ^ 2 ≤ 23235 ^ 2 * 12868",
  "args": ""},
 {"type": "true",
  "tactic-prompt": "example  : true := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : true",
  "args": ""},
 {"type": "true ∧ true",
  "tactic-prompt": "example  : true ∧ true := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : true ∧ true",
  "args": ""},
 {"type": "10 + 2 = 1 + 11",
  "tactic-prompt": "example  : 10 + 2 = 1 + 11 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 10 + 2 = 1 + 11",
  "args": ""},
 {"type": "10 - 1 = 9",
  "tactic-prompt": "example  : 10 - 1 = 9 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 10 - 1 = 9",
  "args": ""},
 {"type": "12 - 5 = 3 + 4",
  "tactic-prompt": "example  : 12 - 5 = 3 + 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 12 - 5 = 3 + 4",
  "args": ""},
 {"type": "5 - 20 = 0",
  "tactic-prompt": "example  : 5 - 20 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 5 - 20 = 0",
  "args": ""},
 {"type": "0 - 2 = 0",
  "tactic-prompt": "example  : 0 - 2 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 0 - 2 = 0",
  "args": ""},
 {"type": "4 - (5 - 10) = 2 + (3 - 1)",
  "tactic-prompt":
  "example  : 4 - (5 - 10) = 2 + (3 - 1) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 4 - (5 - 10) = 2 + (3 - 1)",
  "args": ""},
 {"type": "0 - 0 = 0",
  "tactic-prompt": "example  : 0 - 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 0 - 0 = 0",
  "args": ""},
 {"type": "100 - 100 = 0",
  "tactic-prompt": "example  : 100 - 100 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 100 - 100 = 0",
  "args": ""},
 {"type": "5 * (2 - 3) = 0",
  "tactic-prompt": "example  : 5 * (2 - 3) = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 5 * (2 - 3) = 0",
  "args": ""},
 {"type": "10 - 5 * 5 + (7 - 3) * 6 = 27 - 3",
  "tactic-prompt":
  "example  : 10 - 5 * 5 + (7 - 3) * 6 = 27 - 3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 10 - 5 * 5 + (7 - 3) * 6 = 27 - 3",
  "args": ""},
 {"type": "foo = 1",
  "tactic-prompt": "example  : foo = 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : foo = 1",
  "args": ""},
 {"type": "(1 + 0 : α) = (0 + 1 : α)",
  "tactic-prompt":
  "example (α : Type u)  [AddMonoidWithOne α] : (1 + 0 : α) = (0 + 1 : α) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  "(α : Type u)  [AddMonoidWithOne α] : (1 + 0 : α) = (0 + 1 : α)",
  "args": "(α : Type u)  [AddMonoidWithOne α]"},
 {"type": "(0 + (2 + 3) + 1 : α) = 6",
  "tactic-prompt":
  "example (α : Type u)  [AddMonoidWithOne α] : (0 + (2 + 3) + 1 : α) = 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  "(α : Type u)  [AddMonoidWithOne α] : (0 + (2 + 3) + 1 : α) = 6",
  "args": "(α : Type u)  [AddMonoidWithOne α]"},
 {"type": "(70 * (33 + 2) : α) = 2450",
  "tactic-prompt":
  "example (α : Type u)  [Semiring α] : (70 * (33 + 2) : α) = 2450 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "(α : Type u)  [Semiring α] : (70 * (33 + 2) : α) = 2450",
  "args": "(α : Type u)  [Semiring α]"},
 {"type": "(8 + 2 ^ 2 * 3 : α) = 20",
  "tactic-prompt":
  "example (α : Type u)  [Semiring α] : (8 + 2 ^ 2 * 3 : α) = 20 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "(α : Type u)  [Semiring α] : (8 + 2 ^ 2 * 3 : α) = 20",
  "args": "(α : Type u)  [Semiring α]"},
 {"type": "((2 * 1 + 1) ^ 2 : α) = (3 * 3 : α)",
  "tactic-prompt":
  "example (α : Type u)  [Semiring α] : ((2 * 1 + 1) ^ 2 : α) = (3 * 3 : α) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  "(α : Type u)  [Semiring α] : ((2 * 1 + 1) ^ 2 : α) = (3 * 3 : α)",
  "args": "(α : Type u)  [Semiring α]"},
 {"type": "(-1 : α) * 1 = -1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (-1 : α) * 1 = -1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (-1 : α) * 1 = -1",
  "args": "{α : Type} [Ring α]"},
 {"type": "(-2 : α) * 1 = -2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (-2 : α) * 1 = -2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (-2 : α) * 1 = -2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(-2 : α) * -1 = 2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (-2 : α) * -1 = 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (-2 : α) * -1 = 2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(-2 : α) * -2 = 4",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (-2 : α) * -2 = 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (-2 : α) * -2 = 4",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) * 0 = 0",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) * 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) * 0 = 0",
  "args": "{α : Type} [Ring α]"},
 {"type": "((1 : α) + 1) * 5 = 6 + 4",
  "tactic-prompt":
  "example {α : Type} [Ring α] : ((1 : α) + 1) * 5 = 6 + 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : ((1 : α) + 1) * 5 = 6 + 4",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) = 0 + 1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) = 0 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) = 0 + 1",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) = 1 + 0",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) = 1 + 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) = 1 + 0",
  "args": "{α : Type} [Ring α]"},
 {"type": "(2 : α) = 1 + 1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (2 : α) = 1 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (2 : α) = 1 + 1",
  "args": "{α : Type} [Ring α]"},
 {"type": "(2 : α) = 0 + 2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (2 : α) = 0 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (2 : α) = 0 + 2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(3 : α) = 1 + 2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (3 : α) = 1 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (3 : α) = 1 + 2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(3 : α) = 2 + 1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (3 : α) = 2 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (3 : α) = 2 + 1",
  "args": "{α : Type} [Ring α]"},
 {"type": "(4 : α) = 3 + 1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (4 : α) = 3 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (4 : α) = 3 + 1",
  "args": "{α : Type} [Ring α]"},
 {"type": "(4 : α) = 2 + 2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (4 : α) = 2 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (4 : α) = 2 + 2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(5 : α) = 4 + 1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (5 : α) = 4 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (5 : α) = 4 + 1",
  "args": "{α : Type} [Ring α]"},
 {"type": "(5 : α) = 3 + 2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (5 : α) = 3 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (5 : α) = 3 + 2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(5 : α) = 2 + 3",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (5 : α) = 2 + 3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (5 : α) = 2 + 3",
  "args": "{α : Type} [Ring α]"},
 {"type": "(6 : α) = 0 + 6",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (6 : α) = 0 + 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (6 : α) = 0 + 6",
  "args": "{α : Type} [Ring α]"},
 {"type": "(6 : α) = 3 + 3",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (6 : α) = 3 + 3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (6 : α) = 3 + 3",
  "args": "{α : Type} [Ring α]"},
 {"type": "(6 : α) = 4 + 2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (6 : α) = 4 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (6 : α) = 4 + 2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(6 : α) = 5 + 1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (6 : α) = 5 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (6 : α) = 5 + 1",
  "args": "{α : Type} [Ring α]"},
 {"type": "(7 : α) = 4 + 3",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (7 : α) = 4 + 3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (7 : α) = 4 + 3",
  "args": "{α : Type} [Ring α]"},
 {"type": "(7 : α) = 1 + 6",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (7 : α) = 1 + 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (7 : α) = 1 + 6",
  "args": "{α : Type} [Ring α]"},
 {"type": "(7 : α) = 6 + 1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (7 : α) = 6 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (7 : α) = 6 + 1",
  "args": "{α : Type} [Ring α]"},
 {"type": "33 = 5 + (28 : α)",
  "tactic-prompt":
  "example {α : Type} [Ring α] : 33 = 5 + (28 : α) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : 33 = 5 + (28 : α)",
  "args": "{α : Type} [Ring α]"},
 {"type": "(12 : α) = 0 + (2 + 3) + 7",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (12 : α) = 0 + (2 + 3) + 7 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (12 : α) = 0 + (2 + 3) + 7",
  "args": "{α : Type} [Ring α]"},
 {"type": "(105 : α) = 70 + (33 + 2)",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (105 : α) = 70 + (33 + 2) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (105 : α) = 70 + (33 + 2)",
  "args": "{α : Type} [Ring α]"},
 {"type": "(45000000000 : α) = 23000000000 + 22000000000",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (45000000000 : α) = 23000000000 + 22000000000 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  "{α : Type} [Ring α] : (45000000000 : α) = 23000000000 + 22000000000",
  "args": "{α : Type} [Ring α]"},
 {"type": "(0 : α) - 3 = -3",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (0 : α) - 3 = -3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (0 : α) - 3 = -3",
  "args": "{α : Type} [Ring α]"},
 {"type": "(0 : α) - 2 = -2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (0 : α) - 2 = -2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (0 : α) - 2 = -2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) - 3 = -2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) - 3 = -2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) - 3 = -2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) - 1 = 0",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) - 1 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) - 1 = 0",
  "args": "{α : Type} [Ring α]"},
 {"type": "(0 : α) - 3 = -3",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (0 : α) - 3 = -3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (0 : α) - 3 = -3",
  "args": "{α : Type} [Ring α]"},
 {"type": "(0 : α) - 3 = -3",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (0 : α) - 3 = -3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (0 : α) - 3 = -3",
  "args": "{α : Type} [Ring α]"},
 {"type": "(12 : α) - 4 - (5 + -2) = 5",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (12 : α) - 4 - (5 + -2) = 5 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (12 : α) - 4 - (5 + -2) = 5",
  "args": "{α : Type} [Ring α]"},
 {"type": "(12 : α) - 4 - (5 + -2) - 20 = -15",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (12 : α) - 4 - (5 + -2) - 20 = -15 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (12 : α) - 4 - (5 + -2) - 20 = -15",
  "args": "{α : Type} [Ring α]"},
 {"type": "(0 : α) * 0 = 0",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (0 : α) * 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (0 : α) * 0 = 0",
  "args": "{α : Type} [Ring α]"},
 {"type": "(0 : α) * 1 = 0",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (0 : α) * 1 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (0 : α) * 1 = 0",
  "args": "{α : Type} [Ring α]"},
 {"type": "(0 : α) * 2 = 0",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (0 : α) * 2 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (0 : α) * 2 = 0",
  "args": "{α : Type} [Ring α]"},
 {"type": "(2 : α) * 0 = 0",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (2 : α) * 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (2 : α) * 0 = 0",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) * 0 = 0",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) * 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) * 0 = 0",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) * 1 = 1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) * 1 = 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) * 1 = 1",
  "args": "{α : Type} [Ring α]"},
 {"type": "(2 : α) * 1 = 2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (2 : α) * 1 = 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (2 : α) * 1 = 2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) * 2 = 2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) * 2 = 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) * 2 = 2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(2 : α) * 2 = 4",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (2 : α) * 2 = 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (2 : α) * 2 = 4",
  "args": "{α : Type} [Ring α]"},
 {"type": "(3 : α) * 2 = 6",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (3 : α) * 2 = 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (3 : α) * 2 = 6",
  "args": "{α : Type} [Ring α]"},
 {"type": "(2 : α) * 3 = 6",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (2 : α) * 3 = 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (2 : α) * 3 = 6",
  "args": "{α : Type} [Ring α]"},
 {"type": "(4 : α) * 1 = 4",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (4 : α) * 1 = 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (4 : α) * 1 = 4",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) * 4 = 4",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) * 4 = 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) * 4 = 4",
  "args": "{α : Type} [Ring α]"},
 {"type": "(3 : α) * 3 = 9",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (3 : α) * 3 = 9 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (3 : α) * 3 = 9",
  "args": "{α : Type} [Ring α]"},
 {"type": "(3 : α) * 4 = 12",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (3 : α) * 4 = 12 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (3 : α) * 4 = 12",
  "args": "{α : Type} [Ring α]"},
 {"type": "(4 : α) * 4 = 16",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (4 : α) * 4 = 16 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (4 : α) * 4 = 16",
  "args": "{α : Type} [Ring α]"},
 {"type": "(11 : α) * 2 = 22",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (11 : α) * 2 = 22 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (11 : α) * 2 = 22",
  "args": "{α : Type} [Ring α]"},
 {"type": "(15 : α) * 6 = 90",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (15 : α) * 6 = 90 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (15 : α) * 6 = 90",
  "args": "{α : Type} [Ring α]"},
 {"type": "(123456 : α) * 123456 = 15241383936",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (123456 : α) * 123456 = 15241383936 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (123456 : α) * 123456 = 15241383936",
  "args": "{α : Type} [Ring α]"},
 {"type": "1 = 1",
  "tactic-prompt": "example  : 1 = 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 1 = 1",
  "args": ""},
 {"type": "x ≤ 57",
  "tactic-prompt":
  "example {x : Nat}  (h : x ∈ [0, 2, 37]) : x ≤ 57 := by fin_cases h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases h",
  "core-prompt": "{x : Nat}  (h : x ∈ [0, 2, 37]) : x ≤ 57",
  "args": "{x : Nat}  (h : x ∈ [0, 2, 37])"},
 {"type": "x = 0 ∨ x = 2 ∨ x = 37",
  "tactic-prompt":
  "example {x : Nat}  (h : x ∈ [0, 2, 37]) : x = 0 ∨ x = 2 ∨ x = 37 := by fin_cases h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases h",
  "core-prompt": "{x : Nat}  (h : x ∈ [0, 2, 37]) : x = 0 ∨ x = 2 ∨ x = 37",
  "args": "{x : Nat}  (h : x ∈ [0, 2, 37])"},
 {"type": "x ≤ 4",
  "tactic-prompt":
  "example {x : Nat}  (h : x ∈ List.range 5) : x ≤ 4 := by fin_cases h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases h",
  "core-prompt": "{x : Nat}  (h : x ∈ List.range 5) : x ≤ 4",
  "args": "{x : Nat}  (h : x ∈ List.range 5)"},
 {"type": "p i",
  "tactic-prompt":
  "example {p : Fin 4 → Prop}  (i : Fin 4)  (h : p i) : p i := by fin_cases i; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases i",
  "core-prompt": "{p : Fin 4 → Prop}  (i : Fin 4)  (h : p i) : p i",
  "args": "{p : Fin 4 → Prop}  (i : Fin 4)  (h : p i)"},
 {"type": "f p.val",
  "tactic-prompt":
  "example (f : Nat → Prop)  (p : Fin 3)  (h0 : f 0)  (h1 : f 1)  (h2 : f 2) : f p.val := by fin_cases p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases p",
  "core-prompt":
  "(f : Nat → Prop)  (p : Fin 3)  (h0 : f 0)  (h1 : f 1)  (h2 : f 2) : f p.val",
  "args": "(f : Nat → Prop)  (p : Fin 3)  (h0 : f 0)  (h1 : f 1)  (h2 : f 2)"},
 {"type": "f p.val",
  "tactic-prompt":
  "example (f : Nat → Prop)  (p : Fin 0) : f p.val := by fin_cases p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases p",
  "core-prompt": "(f : Nat → Prop)  (p : Fin 0) : f p.val",
  "args": "(f : Nat → Prop)  (p : Fin 0)"},
 {"type": "True",
  "tactic-prompt":
  "example (x2 : Fin 2)  (x3 : Fin 3) : True := by fin_cases x2, x3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases x2, x3",
  "core-prompt": "(x2 : Fin 2)  (x3 : Fin 3) : True",
  "args": "(x2 : Fin 2)  (x3 : Fin 3)"},
 {"type": "x2.val * x3.val = x3.val * x2.val",
  "tactic-prompt":
  "example (x2 : Fin 2)  (x3 : Fin 3)  (n : Nat)  (y : Fin n) : x2.val * x3.val = x3.val * x2.val := by fin_cases x2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases x2",
  "core-prompt":
  "(x2 : Fin 2)  (x3 : Fin 3)  (n : Nat)  (y : Fin n) : x2.val * x3.val = x3.val * x2.val",
  "args": "(x2 : Fin 2)  (x3 : Fin 3)  (n : Nat)  (y : Fin n)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∨ c ∧ d)  (h2 : e ∧ f) : True := by casesm* _∨_, _∧_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "casesm* _∨_, _∧_",
  "core-prompt": "(h : a ∧ b ∨ c ∧ d)  (h2 : e ∧ f) : True",
  "args": "(h : a ∧ b ∨ c ∧ d)  (h2 : e ∧ f)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∨ c ∧ d) : True := by casesm* _∧_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "casesm* _∧_",
  "core-prompt": "(h : a ∧ b ∨ c ∧ d) : True",
  "args": "(h : a ∧ b ∨ c ∧ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∨ c ∨ d) : True := by casesm* _∨_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "casesm* _∨_",
  "core-prompt": "(h : a ∧ b ∨ c ∨ d) : True",
  "args": "(h : a ∧ b ∨ c ∨ d)"},
 {"type": "True",
  "tactic-prompt": "example (h : a ∧ b ∨ c ∨ d) : True := by casesm _∨_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "casesm _∨_",
  "core-prompt": "(h : a ∧ b ∨ c ∨ d) : True",
  "args": "(h : a ∧ b ∨ c ∨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∨ c ∨ d) : True := by cases_type And Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type And Or",
  "core-prompt": "(h : a ∧ b ∨ c ∨ d) : True",
  "args": "(h : a ∧ b ∨ c ∨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∨ c ∨ d) : True := by cases_type And; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type And",
  "core-prompt": "(h : a ∧ b ∨ c ∨ d) : True",
  "args": "(h : a ∧ b ∨ c ∨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∨ c ∨ d) : True := by cases_type Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type Or",
  "core-prompt": "(h : a ∧ b ∨ c ∨ d) : True",
  "args": "(h : a ∧ b ∨ c ∨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∨ c ∨ d) : True := by cases_type* Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type* Or",
  "core-prompt": "(h : a ∧ b ∨ c ∨ d) : True",
  "args": "(h : a ∧ b ∨ c ∨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∨ c ∨ d) : True := by cases_type! And Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type! And Or",
  "core-prompt": "(h : a ∧ b ∨ c ∨ d) : True",
  "args": "(h : a ∧ b ∨ c ∨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∧ (c ∨ d)) : True := by cases_type! And Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type! And Or",
  "core-prompt": "(h : a ∧ b ∧ (c ∨ d)) : True",
  "args": "(h : a ∧ b ∧ (c ∨ d))"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∧ (c ∨ d)) : True := by cases_type!* And Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type!* And Or",
  "core-prompt": "(h : a ∧ b ∧ (c ∨ d)) : True",
  "args": "(h : a ∧ b ∧ (c ∨ d))"},
 {"type": "True ∧ True ∧ True",
  "tactic-prompt":
  "example  : True ∧ True ∧ True := by constructorm True, _∨_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructorm True, _∨_",
  "core-prompt": " : True ∧ True ∧ True",
  "args": ""},
 {"type": "p ∧ p",
  "tactic-prompt":
  "theorem {p q r : Prop} (h : p ∧ q ∨ p ∧ r)  -- Make sure that we don't try to work on auxiliary declarations. -- In this case, there will be an auxiliary recursive declaration for -- `foo` itself that `casesm (_ ∧ _)` could potentially match. : p ∧ p := by cases h; sorry",
  "name": "foo",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{p q r : Prop} (h : p ∧ q ∨ p ∧ r)  -- Make sure that we don't try to work on auxiliary declarations. -- In this case, there will be an auxiliary recursive declaration for -- `foo` itself that `casesm (_ ∧ _)` could potentially match. : p ∧ p",
  "args":
  "{p q r : Prop} (h : p ∧ q ∨ p ∧ r)  -- Make sure that we don't try to work on auxiliary declarations. -- In this case, there will be an auxiliary recursive declaration for -- `foo` itself that `casesm (_ ∧ _)` could potentially match."},
 {"type": "P",
  "tactic-prompt": "example (P : Prop)  (h : P) : P := by convert h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert h",
  "core-prompt": "(P : Prop)  (h : P) : P",
  "args": "(P : Prop)  (h : P)"},
 {"type": "α",
  "tactic-prompt":
  "example (α β : Type)  (h : α = β)  (b : β) : α := by convert b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert b",
  "core-prompt": "(α β : Type)  (h : α = β)  (b : β) : α",
  "args": "(α β : Type)  (h : α = β)  (b : β)"},
 {"type": "α",
  "tactic-prompt":
  "example (α β : Type)  (h : ∀ α β : Type, α = β)  (b : β) : α := by convert b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert b",
  "core-prompt": "(α β : Type)  (h : ∀ α β : Type, α = β)  (b : β) : α",
  "args": "(α β : Type)  (h : ∀ α β : Type, α = β)  (b : β)"},
 {"type": "Nat × α",
  "tactic-prompt":
  "example (α β : Type)  (h : α = β)  (b : β) : Nat × α := by convert (37, b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert (37, b)",
  "core-prompt": "(α β : Type)  (h : α = β)  (b : β) : Nat × α",
  "args": "(α β : Type)  (h : α = β)  (b : β)"},
 {"type": "Nat × α",
  "tactic-prompt":
  "example (α β : Type)  (h : β = α)  (b : β) : Nat × α := by convert ← (37, b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert ← (37, b)",
  "core-prompt": "(α β : Type)  (h : β = α)  (b : β) : Nat × α",
  "args": "(α β : Type)  (h : β = α)  (b : β)"},
 {"type": "Nat × Nat × Nat × α",
  "tactic-prompt":
  "example (α β : Type)  (h : α = β)  (b : β) : Nat × Nat × Nat × α := by convert (37, 57, 2, b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert (37, 57, 2, b)",
  "core-prompt": "(α β : Type)  (h : α = β)  (b : β) : Nat × Nat × Nat × α",
  "args": "(α β : Type)  (h : α = β)  (b : β)"},
 {"type": "Nat × Nat × Nat × α",
  "tactic-prompt":
  "example (α β : Type)  (h : α = β)  (b : β) : Nat × Nat × Nat × α := by convert (37, 57, 2, b) using 2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert (37, 57, 2, b) using 2",
  "core-prompt": "(α β : Type)  (h : α = β)  (b : β) : Nat × Nat × Nat × α",
  "args": "(α β : Type)  (h : α = β)  (b : β)"},
 {"type": "Nat × Nat × Nat × α",
  "tactic-prompt":
  "example (α β : Type)  (h : α = β)  (b : β) : Nat × Nat × Nat × α := by convert (37, 57, 2, b) using 3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert (37, 57, 2, b) using 3",
  "core-prompt": "(α β : Type)  (h : α = β)  (b : β) : Nat × Nat × Nat × α",
  "args": "(α β : Type)  (h : α = β)  (b : β)"},
 {"type": "bar0 3 4 = 7",
  "tactic-prompt": "theorem  : bar0 3 4 = 7 := by decide; sorry",
  "name": "bar0_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar0 3 4 = 7",
  "args": ""},
 {"type": "foo1 3 4 = Nat.pow 3 4",
  "tactic-prompt": "theorem  : foo1 3 4 = Nat.pow 3 4 := by decide; sorry",
  "name": "foo1_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : foo1 3 4 = Nat.pow 3 4",
  "args": ""},
 {"type": "bar1 3 4 = 3 * 4",
  "tactic-prompt": "theorem  : bar1 3 4 = 3 * 4 := by decide; sorry",
  "name": "bar1_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar1 3 4 = 3 * 4",
  "args": ""},
 {"type": "foo2 2 3 (PLift.up 2) = Nat.pow 2 5",
  "tactic-prompt":
  "theorem  : foo2 2 3 (PLift.up 2) = Nat.pow 2 5 := by decide; sorry",
  "name": "foo2_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : foo2 2 3 (PLift.up 2) = Nat.pow 2 5",
  "args": ""},
 {"type": "bar2 2 3 (PLift.up 2) =  2 * 5",
  "tactic-prompt":
  "theorem  : bar2 2 3 (PLift.up 2) =  2 * 5 := by decide; sorry",
  "name": "bar2_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar2 2 3 (PLift.up 2) =  2 * 5",
  "args": ""},
 {"type": "foo3 2 3 = Nat.pow 2 3",
  "tactic-prompt": "theorem  : foo3 2 3 = Nat.pow 2 3 := by decide; sorry",
  "name": "foo3_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : foo3 2 3 = Nat.pow 2 3",
  "args": ""},
 {"type": "bar3 2 3 =  2 * 3",
  "tactic-prompt": "theorem  : bar3 2 3 =  2 * 3 := by decide; sorry",
  "name": "bar3_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar3 2 3 =  2 * 3",
  "args": ""},
 {"type": "bar8 2 3 = 6",
  "tactic-prompt": "theorem  : bar8 2 3 = 6 := by decide; sorry",
  "name": "bar8_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar8 2 3 = 6",
  "args": ""},
 {"type": "bar9 = 1",
  "tactic-prompt": "theorem  : bar9 = 1 := by decide; sorry",
  "name": "bar9_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar9 = 1",
  "args": ""},
 {"type": "bar10 = foo10",
  "tactic-prompt": "theorem  : bar10 = foo10 := by rfl; sorry",
  "name": "bar10_works",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt": " : bar10 = foo10",
  "args": ""},
 {"type": "bar11 = foo11",
  "tactic-prompt": "theorem  : bar11 = foo11 := by rfl; sorry",
  "name": "bar11_works",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt": " : bar11 = foo11",
  "args": ""},
 {"type": "true",
  "tactic-prompt":
  "def {I J K : Type}  (n : ℕ)  {f : I → Type}  (L : Type)  [∀ i, One (f i)]    [Add I]  [Mul L] : true := by trivial; sorry",
  "name": "foo_mul",
  "kind": "def",
  "first-tactic": "trivial",
  "core-prompt":
  "{I J K : Type}  (n : ℕ)  {f : I → Type}  (L : Type)  [∀ i, One (f i)]    [Add I]  [Mul L] : true",
  "args":
  "{I J K : Type}  (n : ℕ)  {f : I → Type}  (L : Type)  [∀ i, One (f i)]    [Add I]  [Mul L]"},
 {"type": "One ((x : Nat) → α)",
  "tactic-prompt":
  "def {α : Type}  [One α] : One ((x : Nat) → α) := by infer_instance; sorry",
  "name": "nat_pi_has_one",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt": "{α : Type}  [One α] : One ((x : Nat) → α)",
  "args": "{α : Type}  [One α]"},
 {"type": "Bar.bar' = 2",
  "tactic-prompt": "theorem  : Bar.bar' = 2 := by decide; sorry",
  "name": "Bar.bar'_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : Bar.bar' = 2",
  "args": ""},
 {"type": "FooClass α",
  "tactic-prompt": "lemma [One α] : FooClass α := by infer_instance; sorry",
  "name": "one_fooClass",
  "kind": "lemma",
  "first-tactic": "infer_instance",
  "core-prompt": "[One α] : FooClass α",
  "args": "[One α]"},
 {"type": "FooClass α",
  "tactic-prompt": "lemma [Zero α] : FooClass α := by infer_instance; sorry",
  "name": "zero_fooClass",
  "kind": "lemma",
  "first-tactic": "infer_instance",
  "core-prompt": "[Zero α] : FooClass α",
  "args": "[Zero α]"},
 {"type": "IsUnit' a ↔ ∃ b, b * a = 1",
  "tactic-prompt":
  "theorem [CommMonoid M]  {a : M} : IsUnit' a ↔ ∃ b, b * a = 1 := by simp [isUnit'_iff_exists_inv]; sorry",
  "name": "isUnit'_iff_exists_inv'",
  "kind": "theorem",
  "first-tactic": "simp [isUnit'_iff_exists_inv]",
  "core-prompt": "[CommMonoid M]  {a : M} : IsUnit' a ↔ ∃ b, b * a = 1",
  "args": "[CommMonoid M]  {a : M}"},
 {"type": "true",
  "tactic-prompt": "example  : true := by guard_hyp_nums 1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "guard_hyp_nums 1",
  "core-prompt": " : true",
  "args": ""},
 {"type": "Int × Nat",
  "tactic-prompt":
  "example (a : Nat)  (b : Int) : Int × Nat := by rename' a => c, b => d; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rename' a => c, b => d",
  "core-prompt": "(a : Nat)  (b : Int) : Int × Nat",
  "args": "(a : Nat)  (b : Int)"},
 {"type": "Int × Nat",
  "tactic-prompt":
  "example (a : Nat)  (b : Int) : Int × Nat := by rename' a => b, b => a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rename' a => b, b => a",
  "core-prompt": "(a : Nat)  (b : Int) : Int × Nat",
  "args": "(a : Nat)  (b : Int)"},
 {"type": "False",
  "tactic-prompt":
  "example [LinearOrderedCommRing α]  {a b : α}  (h : a < b)  (w : b < a) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "[LinearOrderedCommRing α]  {a b : α}  (h : a < b)  (w : b < a) : False",
  "args": "[LinearOrderedCommRing α]  {a b : α}  (h : a < b)  (w : b < a)"},
 {"type": "0 < 1 - a",
  "tactic-prompt":
  "example {α : Type}  (_inst : (a : Prop) → Decidable a)  [LinearOrderedCommRing α]      {a b c : α}      (ha : a < 0)      (hb : ¬b = 0)      (hc' : c = 0)      (h : (1 - a) * (b * b) ≤ 0)      (hc : 0 ≤ 0)      (w : -(a * -b * -b + b * -b + 0) = (1 - a) * (b * b))      (h : (1 - a) * (b * b) ≤ 0) : 0 < 1 - a := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "{α : Type}  (_inst : (a : Prop) → Decidable a)  [LinearOrderedCommRing α]      {a b c : α}      (ha : a < 0)      (hb : ¬b = 0)      (hc' : c = 0)      (h : (1 - a) * (b * b) ≤ 0)      (hc : 0 ≤ 0)      (w : -(a * -b * -b + b * -b + 0) = (1 - a) * (b * b))      (h : (1 - a) * (b * b) ≤ 0) : 0 < 1 - a",
  "args":
  "{α : Type}  (_inst : (a : Prop) → Decidable a)  [LinearOrderedCommRing α]      {a b c : α}      (ha : a < 0)      (hb : ¬b = 0)      (hc' : c = 0)      (h : (1 - a) * (b * b) ≤ 0)      (hc : 0 ≤ 0)      (w : -(a * -b * -b + b * -b + 0) = (1 - a) * (b * b))      (h : (1 - a) * (b * b) ≤ 0)"},
 {"type": "v0 + 5 + (v1 - 3) + (c - 2) = 10",
  "tactic-prompt":
  "example (e b c a v0 v1 : Rat)  (h1 : v0 = 5*a)  (h2 : v1 = 3*b)  (h3 : v0 + v1 + c = 10) : v0 + 5 + (v1 - 3) + (c - 2) = 10 := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(e b c a v0 v1 : Rat)  (h1 : v0 = 5*a)  (h2 : v1 = 3*b)  (h3 : v0 + v1 + c = 10) : v0 + 5 + (v1 - 3) + (c - 2) = 10",
  "args":
  "(e b c a v0 v1 : Rat)  (h1 : v0 = 5*a)  (h2 : v1 = 3*b)  (h3 : v0 + v1 + c = 10)"},
 {"type": "v0 + 5 + (v1 - 3) + (c - 2) = 10",
  "tactic-prompt":
  "example [LinearOrderedCommRing α]  (e b c a v0 v1 : α)  (h1 : v0 = 5*a)  (h2 : v1 = 3*b)      (h3 : v0 + v1 + c = 10) : v0 + 5 + (v1 - 3) + (c - 2) = 10 := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "[LinearOrderedCommRing α]  (e b c a v0 v1 : α)  (h1 : v0 = 5*a)  (h2 : v1 = 3*b)      (h3 : v0 + v1 + c = 10) : v0 + 5 + (v1 - 3) + (c - 2) = 10",
  "args":
  "[LinearOrderedCommRing α]  (e b c a v0 v1 : α)  (h1 : v0 = 5*a)  (h2 : v1 = 3*b)      (h3 : v0 + v1 + c = 10)"},
 {"type": "(3 : ℤ) < 7",
  "tactic-prompt":
  "example (h : (1 : ℤ) < 0)  (g : ¬ (37 : ℤ) < 42)  (_k : True)  (l : (-7 : ℤ) < 5) : (3 : ℤ) < 7 := by linarith [(rfl : 0 = 0)]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith [(rfl : 0 = 0)]",
  "core-prompt":
  "(h : (1 : ℤ) < 0)  (g : ¬ (37 : ℤ) < 42)  (_k : True)  (l : (-7 : ℤ) < 5) : (3 : ℤ) < 7",
  "args":
  "(h : (1 : ℤ) < 0)  (g : ¬ (37 : ℤ) < 42)  (_k : True)  (l : (-7 : ℤ) < 5)"},
 {"type": "0 < (t*(r + v) + s)*3*u",
  "tactic-prompt":
  "example (u v r s t : Rat)  (h : 0 < u*(t*v + t*r + s)) : 0 < (t*(r + v) + s)*3*u := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(u v r s t : Rat)  (h : 0 < u*(t*v + t*r + s)) : 0 < (t*(r + v) + s)*3*u",
  "args": "(u v r s t : Rat)  (h : 0 < u*(t*v + t*r + s))"},
 {"type": "0 < 8*A*B",
  "tactic-prompt":
  "example (A B : Rat)  (h : 0 < A * B) : 0 < 8*A*B := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(A B : Rat)  (h : 0 < A * B) : 0 < 8*A*B",
  "args": "(A B : Rat)  (h : 0 < A * B)"},
 {"type": "0 < A*8*B",
  "tactic-prompt":
  "example (A B : Rat)  (h : 0 < A * B) : 0 < A*8*B := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(A B : Rat)  (h : 0 < A * B) : 0 < A*8*B",
  "args": "(A B : Rat)  (h : 0 < A * B)"},
 {"type": "False",
  "tactic-prompt":
  "example (a b c : Rat)  (h2 : b + 2 > 3 + b) : False := by linarith (config := {discharger := do Lean.Elab.Tactic.evalTactic (←`(tactic| ring))}); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "linarith (config := {discharger := do Lean.Elab.Tactic.evalTactic (←`(tactic| ring))})",
  "core-prompt": "(a b c : Rat)  (h2 : b + 2 > 3 + b) : False",
  "args": "(a b c : Rat)  (h2 : b + 2 > 3 + b)"},
 {"type": "False",
  "tactic-prompt":
  "example (a b c : Rat)  (h2 : b + 2 > 3 + b) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(a b c : Rat)  (h2 : b + 2 > 3 + b) : False",
  "args": "(a b c : Rat)  (h2 : b + 2 > 3 + b)"},
 {"type": "v ≤ V",
  "tactic-prompt":
  "example (g v V c h : Rat)  (h1 : h = 0)  (h2 : v = V)  (h3 : V > 0)  (h4 : g > 0)      (h5 : 0 ≤ c)  (h6 : c < 1) : v ≤ V := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(g v V c h : Rat)  (h1 : h = 0)  (h2 : v = V)  (h3 : V > 0)  (h4 : g > 0)      (h5 : 0 ≤ c)  (h6 : c < 1) : v ≤ V",
  "args":
  "(g v V c h : Rat)  (h1 : h = 0)  (h2 : v = V)  (h3 : V > 0)  (h4 : g > 0)      (h5 : 0 ≤ c)  (h6 : c < 1)"},
 {"type": "False",
  "tactic-prompt":
  "example (x y z : ℤ)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : 12*y - 4* z < 0) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y z : ℤ)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : 12*y - 4* z < 0) : False",
  "args":
  "(x y z : ℤ)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : 12*y - 4* z < 0)"},
 {"type": "False",
  "tactic-prompt":
  "example (x y z : ℤ)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : x*y < 5)  (h3 : 12*y - 4* z < 0) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y z : ℤ)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : x*y < 5)  (h3 : 12*y - 4* z < 0) : False",
  "args":
  "(x y z : ℤ)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : x*y < 5)  (h3 : 12*y - 4* z < 0)"},
 {"type": "False",
  "tactic-prompt":
  "example (a b c : Rat)  (h1 : a > 0)  (h2 : b > 5)  (h3 : c < -10)  (h4 : a + b - c < 3) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(a b c : Rat)  (h1 : a > 0)  (h2 : b > 5)  (h3 : c < -10)  (h4 : a + b - c < 3) : False",
  "args":
  "(a b c : Rat)  (h1 : a > 0)  (h2 : b > 5)  (h3 : c < -10)  (h4 : a + b - c < 3)"},
 {"type": "False",
  "tactic-prompt":
  "example (a b c : Rat)  (h2 : b > 0)  (h3 : ¬ b ≥ 0) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(a b c : Rat)  (h2 : b > 0)  (h3 : ¬ b ≥ 0) : False",
  "args": "(a b c : Rat)  (h2 : b > 0)  (h3 : ¬ b ≥ 0)"},
 {"type": "x = 3*y",
  "tactic-prompt":
  "example (x y z : Rat)  (hx : x ≤ 3*y)  (h2 : y ≤ 2*z)  (h3 : x ≥ 6*z) : x = 3*y := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y z : Rat)  (hx : x ≤ 3*y)  (h2 : y ≤ 2*z)  (h3 : x ≥ 6*z) : x = 3*y",
  "args": "(x y z : Rat)  (hx : x ≤ 3*y)  (h2 : y ≤ 2*z)  (h3 : x ≥ 6*z)"},
 {"type": "¬ 12*y - 4* z < 0",
  "tactic-prompt":
  "example (x y z : ℤ)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : x*y < 5) : ¬ 12*y - 4* z < 0 := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y z : ℤ)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : x*y < 5) : ¬ 12*y - 4* z < 0",
  "args":
  "(x y z : ℤ)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : x*y < 5)"},
 {"type": "x = 3*y",
  "tactic-prompt":
  "example (x y z : Rat)  (hx : ¬ x > 3*y)  (h2 : ¬ y > 2*z)  (h3 : x ≥ 6*z) : x = 3*y := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y z : Rat)  (hx : ¬ x > 3*y)  (h2 : ¬ y > 2*z)  (h3 : x ≥ 6*z) : x = 3*y",
  "args": "(x y z : Rat)  (hx : ¬ x > 3*y)  (h2 : ¬ y > 2*z)  (h3 : x ≥ 6*z)"},
 {"type": "False",
  "tactic-prompt":
  "example (x y : Rat)  (h : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3)  (h' : (x + 4) * x ≥ 0)      (h'' : (6 + 3 * y) * y ≥ 0) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y : Rat)  (h : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3)  (h' : (x + 4) * x ≥ 0)      (h'' : (6 + 3 * y) * y ≥ 0) : False",
  "args":
  "(x y : Rat)  (h : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3)  (h' : (x + 4) * x ≥ 0)      (h'' : (6 + 3 * y) * y ≥ 0)"},
 {"type": "0 * 0 ≤ 2 * a",
  "tactic-prompt":
  "example (a : Rat)  (ha : 0 ≤ a) : 0 * 0 ≤ 2 * a := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(a : Rat)  (ha : 0 ≤ a) : 0 * 0 ≤ 2 * a",
  "args": "(a : Rat)  (ha : 0 ≤ a)"},
 {"type": "x ≠ y",
  "tactic-prompt":
  "example (x y : Rat)  (h : x < y) : x ≠ y := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(x y : Rat)  (h : x < y) : x ≠ y",
  "args": "(x y : Rat)  (h : x < y)"},
 {"type": "¬ x = y",
  "tactic-prompt":
  "example (x y : Rat)  (h : x < y) : ¬ x = y := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(x y : Rat)  (h : x < y) : ¬ x = y",
  "args": "(x y : Rat)  (h : x < y)"},
 {"type": "id x ≥ x",
  "tactic-prompt":
  "example (x : Rat) : id x ≥ x := by fail_if_success\n    linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    linarith",
  "core-prompt": "(x : Rat) : id x ≥ x",
  "args": "(x : Rat)"},
 {"type": "False",
  "tactic-prompt":
  "example (x y z : Rat)  (h1 : 2*x + ((-3)*y) < 0)  (h2 : (-4)*x + 2*z < 0)  (h3 : 12*y + (-4)* z < 0)      (h4 : Nat.prime 7) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y z : Rat)  (h1 : 2*x + ((-3)*y) < 0)  (h2 : (-4)*x + 2*z < 0)  (h3 : 12*y + (-4)* z < 0)      (h4 : Nat.prime 7) : False",
  "args":
  "(x y z : Rat)  (h1 : 2*x + ((-3)*y) < 0)  (h2 : (-4)*x + 2*z < 0)  (h3 : 12*y + (-4)* z < 0)      (h4 : Nat.prime 7)"},
 {"type": "False",
  "tactic-prompt":
  "example (x y z : Rat)  (h1 : 2*1*x + (3)*(y*(-1)) < 0)  (h2 : (-2)*x*2 < -(z + z))      (h3 : 12*y + (-4)* z < 0)  (h4 : Nat.prime 7) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y z : Rat)  (h1 : 2*1*x + (3)*(y*(-1)) < 0)  (h2 : (-2)*x*2 < -(z + z))      (h3 : 12*y + (-4)* z < 0)  (h4 : Nat.prime 7) : False",
  "args":
  "(x y z : Rat)  (h1 : 2*1*x + (3)*(y*(-1)) < 0)  (h2 : (-2)*x*2 < -(z + z))      (h3 : 12*y + (-4)* z < 0)  (h4 : Nat.prime 7)"},
 {"type": "False",
  "tactic-prompt":
  "example (w x y z : ℤ)  (h1 : 4*x + (-3)*y + 6*w ≤ 0)  (h2 : (-1)*x < 0)  (h3 : y < 0)  (h4 : w ≥ 0)      (h5 : Nat.prime x.natAbs) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(w x y z : ℤ)  (h1 : 4*x + (-3)*y + 6*w ≤ 0)  (h2 : (-1)*x < 0)  (h3 : y < 0)  (h4 : w ≥ 0)      (h5 : Nat.prime x.natAbs) : False",
  "args":
  "(w x y z : ℤ)  (h1 : 4*x + (-3)*y + 6*w ≤ 0)  (h2 : (-1)*x < 0)  (h3 : y < 0)  (h4 : w ≥ 0)      (h5 : Nat.prime x.natAbs)"},
 {"type": "False",
  "tactic-prompt":
  "example (x : Rat)  (hx : x > 0)  (h : x.num < 0) : False := by linarith [Rat.num_pos_iff_pos.mpr hx]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith [Rat.num_pos_iff_pos.mpr hx]",
  "core-prompt": "(x : Rat)  (hx : x > 0)  (h : x.num < 0) : False",
  "args": "(x : Rat)  (hx : x > 0)  (h : x.num < 0)"},
 {"type": "False",
  "tactic-prompt":
  "example (x : Rat)  (hx : x > 0)  (h : x.num < 0) : False := by fail_if_success\n    linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    linarith",
  "core-prompt": "(x : Rat)  (hx : x > 0)  (h : x.num < 0) : False",
  "args": "(x : Rat)  (hx : x > 0)  (h : x.num < 0)"},
 {"type": "Nat.prime 10",
  "tactic-prompt":
  "example (a b c : Rat)  (h2 : b > 0)  (h3 : b < 0) : Nat.prime 10 := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(a b c : Rat)  (h2 : b > 0)  (h3 : b < 0) : Nat.prime 10",
  "args": "(a b c : Rat)  (h2 : b > 0)  (h3 : b < 0)"},
 {"type": "a + b - c ≥ 3",
  "tactic-prompt":
  "example (a b c : Rat)  (h2 : (2 : Rat) > 3) : a + b - c ≥ 3 := by linarith (config := {exfalso := false}); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith (config := {exfalso := false})",
  "core-prompt": "(a b c : Rat)  (h2 : (2 : Rat) > 3) : a + b - c ≥ 3",
  "args": "(a b c : Rat)  (h2 : (2 : Rat) > 3)"},
 {"type": "False",
  "tactic-prompt":
  "example (x y : Rat)      (h : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3 ∧ (x + 4) * x ≥ 0 ∧ (6 + 3 * y) * y ≥ 0) : False := by fail_if_success\n    linarith (config := {split_hypotheses := false}); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success\n    linarith (config := {split_hypotheses := false})",
  "core-prompt":
  "(x y : Rat)      (h : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3 ∧ (x + 4) * x ≥ 0 ∧ (6 + 3 * y) * y ≥ 0) : False",
  "args":
  "(x y : Rat)      (h : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3 ∧ (x + 4) * x ≥ 0 ∧ (6 + 3 * y) * y ≥ 0)"},
 {"type": "3 < 7",
  "tactic-prompt":
  "example (h : 1 < 0)  (g : ¬ 37 < 42)  (k : True)  (l : (-7 : ℤ) < 5) : 3 < 7 := by linarith [(rfl : 0 = 0)]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith [(rfl : 0 = 0)]",
  "core-prompt":
  "(h : 1 < 0)  (g : ¬ 37 < 42)  (k : True)  (l : (-7 : ℤ) < 5) : 3 < 7",
  "args": "(h : 1 < 0)  (g : ¬ 37 < 42)  (k : True)  (l : (-7 : ℤ) < 5)"},
 {"type": "3 = 7",
  "tactic-prompt":
  "example (h : 1 < 0) : 3 = 7 := by linarith [Int.zero_lt_one]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith [Int.zero_lt_one]",
  "core-prompt": "(h : 1 < 0) : 3 = 7",
  "args": "(h : 1 < 0)"},
 {"type": "False",
  "tactic-prompt": "example (h1 : (1 : ℕ) < 1) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(h1 : (1 : ℕ) < 1) : False",
  "args": "(h1 : (1 : ℕ) < 1)"},
 {"type": "a + b ≥ a",
  "tactic-prompt": "example (a b c : ℕ) : a + b ≥ a := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(a b c : ℕ) : a + b ≥ a",
  "args": "(a b c : ℕ)"},
 {"type": "False",
  "tactic-prompt":
  "example (a b i : ℕ)  (h1 :  ¬ a < i)  (h2 : b < i)  (h3 : a ≤ b) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(a b i : ℕ)  (h1 :  ¬ a < i)  (h2 : b < i)  (h3 : a ≤ b) : False",
  "args": "(a b i : ℕ)  (h1 :  ¬ a < i)  (h2 : b < i)  (h3 : a ≤ b)"},
 {"type": "True",
  "tactic-prompt":
  "example (x y : ℕ)  (h : x < 3 * y) : True := by zify at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "zify at h",
  "core-prompt": "(x y : ℕ)  (h : x < 3 * y) : True",
  "args": "(x y : ℕ)  (h : x < 3 * y)"},
 {"type": "x = 3*y",
  "tactic-prompt":
  "example (x y z : ℕ)  (hx : x ≤ 3*y)  (h2 : y ≤ 2*z)  (h3 : x ≥ 6*z) : x = 3*y := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y z : ℕ)  (hx : x ≤ 3*y)  (h2 : y ≤ 2*z)  (h3 : x ≥ 6*z) : x = 3*y",
  "args": "(x y z : ℕ)  (hx : x ≤ 3*y)  (h2 : y ≤ 2*z)  (h3 : x ≥ 6*z)"},
 {"type": "¬ a + b < a",
  "tactic-prompt": "example (a b c : ℕ) : ¬ a + b < a := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(a b c : ℕ) : ¬ a + b < a",
  "args": "(a b c : ℕ)"},
 {"type": "n = 3",
  "tactic-prompt":
  "example (n : ℕ)  (h1 : n ≤ 3)  (h2 : n > 2) : n = 3 := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(n : ℕ)  (h1 : n ≤ 3)  (h2 : n > 2) : n = 3",
  "args": "(n : ℕ)  (h1 : n ≤ 3)  (h2 : n > 2)"},
 {"type": "False",
  "tactic-prompt":
  "example (z : ℕ)  (hz : ¬ z ≥ 2)  (h2 : ¬ z + 1 ≤ 2) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(z : ℕ)  (hz : ¬ z ≥ 2)  (h2 : ¬ z + 1 ≤ 2) : False",
  "args": "(z : ℕ)  (hz : ¬ z ≥ 2)  (h2 : ¬ z + 1 ≤ 2)"},
 {"type": "z + 1 ≤ 2",
  "tactic-prompt":
  "example (z : ℕ)  (hz : ¬ z ≥ 2) : z + 1 ≤ 2 := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(z : ℕ)  (hz : ¬ z ≥ 2) : z + 1 ≤ 2",
  "args": "(z : ℕ)  (hz : ¬ z ≥ 2)"},
 {"type": "2 * i + 3 > 11",
  "tactic-prompt":
  "example (i : ℤ)  (hi : i > 5) : 2 * i + 3 > 11 := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(i : ℤ)  (hi : i > 5) : 2 * i + 3 > 11",
  "args": "(i : ℤ)  (hi : i > 5)"},
 {"type": "m * m + m + (2 * m + 2) = m * m + m + (m + 1) + (m + 1)",
  "tactic-prompt":
  "example (m : ℕ) : m * m + m + (2 * m + 2) = m * m + m + (m + 1) + (m + 1) := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(m : ℕ) : m * m + m + (2 * m + 2) = m * m + m + (m + 1) + (m + 1)",
  "args": "(m : ℕ)"},
 {"type":
  "mess S + (n * mess S + n * 2 + 1) < n * mess S + mess S + (n * 2 + 2)",
  "tactic-prompt":
  "example (mess : ℕ → ℕ)  (S n : ℕ) : mess S + (n * mess S + n * 2 + 1) < n * mess S + mess S + (n * 2 + 2) := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(mess : ℕ → ℕ)  (S n : ℕ) : mess S + (n * mess S + n * 2 + 1) < n * mess S + mess S + (n * 2 + 2)",
  "args": "(mess : ℕ → ℕ)  (S n : ℕ)"},
 {"type": "n + p' = n' + p",
  "tactic-prompt":
  "example (p n p' n' : ℕ)  (h : p + n' = p' + n) : n + p' = n' + p := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(p n p' n' : ℕ)  (h : p + n' = p' + n) : n + p' = n' + p",
  "args": "(p n p' n' : ℕ)  (h : p + n' = p' + n)"},
 {"type": "A < l + 1",
  "tactic-prompt":
  "example (N : ℕ)  (n : ℕ)  (Hirrelevant : n > N)  (A : Rat)  (l : Rat)  (h : A - l ≤ -(A - l))      (h_1 : ¬A ≤ -A)  (h_2 : ¬l ≤ -l)  (h_3 : -(A - l) < 1) : A < l + 1 := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(N : ℕ)  (n : ℕ)  (Hirrelevant : n > N)  (A : Rat)  (l : Rat)  (h : A - l ≤ -(A - l))      (h_1 : ¬A ≤ -A)  (h_2 : ¬l ≤ -l)  (h_3 : -(A - l) < 1) : A < l + 1",
  "args":
  "(N : ℕ)  (n : ℕ)  (Hirrelevant : n > N)  (A : Rat)  (l : Rat)  (h : A - l ≤ -(A - l))      (h_1 : ¬A ≤ -A)  (h_2 : ¬l ≤ -l)  (h_3 : -(A - l) < 1)"},
 {"type": "u * y + v * x + u * v < 3 * A * B",
  "tactic-prompt":
  "example (u v x y A B : ℚ)  (a : 0 < A)  (a_1 : 0 <= 1 - A)  (a_2 : 0 <= B - 1)  (a_3 : 0 <= B - x)  (a_4 : 0 <= B - y)  (a_5 : 0 <= u)  (a_6 : 0 <= v)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v) : u * y + v * x + u * v < 3 * A * B := by nlinarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nlinarith",
  "core-prompt":
  "(u v x y A B : ℚ)  (a : 0 < A)  (a_1 : 0 <= 1 - A)  (a_2 : 0 <= B - 1)  (a_3 : 0 <= B - x)  (a_4 : 0 <= B - y)  (a_5 : 0 <= u)  (a_6 : 0 <= v)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v) : u * y + v * x + u * v < 3 * A * B",
  "args":
  "(u v x y A B : ℚ)  (a : 0 < A)  (a_1 : 0 <= 1 - A)  (a_2 : 0 <= B - 1)  (a_3 : 0 <= B - x)  (a_4 : 0 <= B - y)  (a_5 : 0 <= u)  (a_6 : 0 <= v)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v)"},
 {"type":
  "(0 < A) → (A ≤ 1) → (1 ≤ B)\n→ (x ≤ B) → ( y ≤ B)\n→ (0 ≤ u ) → (0 ≤ v )\n→ (u < A) → ( v < A)\n→ (u * y + v * x + u * v < 3 * A * B)",
  "tactic-prompt":
  "example (u v x y A B : ℚ) : (0 < A) → (A ≤ 1) → (1 ≤ B)\n→ (x ≤ B) → ( y ≤ B)\n→ (0 ≤ u ) → (0 ≤ v )\n→ (u < A) → ( v < A)\n→ (u * y + v * x + u * v < 3 * A * B) := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt":
  "(u v x y A B : ℚ) : (0 < A) → (A ≤ 1) → (1 ≤ B)\n→ (x ≤ B) → ( y ≤ B)\n→ (0 ≤ u ) → (0 ≤ v )\n→ (u < A) → ( v < A)\n→ (u * y + v * x + u * v < 3 * A * B)",
  "args": "(u v x y A B : ℚ)"},
 {"type":
  "(0 <= A * (1 - A))\n-> (0 <= A * (B - 1))\n-> (0 < A * (A - u))\n-> (0 <= (B - 1) * (A - u))\n-> (0 <= (B - 1) * (A - v))\n-> (0 <= (B - x) * v)\n-> (0 <= (B - y) * u)\n-> (0 <= u * (A - v))\n->\n u * y + v * x + u * v < 3 * A * B",
  "tactic-prompt":
  "example (u v x y A B : Rat)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v) : (0 <= A * (1 - A))\n-> (0 <= A * (B - 1))\n-> (0 < A * (A - u))\n-> (0 <= (B - 1) * (A - u))\n-> (0 <= (B - 1) * (A - v))\n-> (0 <= (B - x) * v)\n-> (0 <= (B - y) * u)\n-> (0 <= u * (A - v))\n->\n u * y + v * x + u * v < 3 * A * B := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt":
  "(u v x y A B : Rat)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v) : (0 <= A * (1 - A))\n-> (0 <= A * (B - 1))\n-> (0 < A * (A - u))\n-> (0 <= (B - 1) * (A - u))\n-> (0 <= (B - 1) * (A - v))\n-> (0 <= (B - x) * v)\n-> (0 <= (B - y) * u)\n-> (0 <= u * (A - v))\n->\n u * y + v * x + u * v < 3 * A * B",
  "args": "(u v x y A B : Rat)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v)"},
 {"type":
  "(0 < A * A)\n-> (0 <= A * (1 - A))\n-> (0 <= A * (B - 1))\n-> (0 <= A * (B - x))\n-> (0 <= A * (B - y))\n-> (0 <= A * u)\n-> (0 <= A * v)\n-> (0 < A * (A - u))\n-> (0 < A * (A - v))\n-> (0 <= (1 - A) * A)\n-> (0 <= (1 - A) * (1 - A))\n-> (0 <= (1 - A) * (B - 1))\n-> (0 <= (1 - A) * (B - x))\n-> (0 <= (1 - A) * (B - y))\n-> (0 <= (1 - A) * u)\n-> (0 <= (1 - A) * v)\n-> (0 <= (1 - A) * (A - u))\n-> (0 <= (1 - A) * (A - v))\n-> (0 <= (B - 1) * A)\n-> (0 <= (B - 1) * (1 - A))\n-> (0 <= (B - 1) * (B - 1))\n-> (0 <= (B - 1) * (B - x))\n-> (0 <= (B - 1) * (B - y))\n-> (0 <= (B - 1) * u)\n-> (0 <= (B - 1) * v)\n-> (0 <= (B - 1) * (A - u))\n-> (0 <= (B - 1) * (A - v))\n-> (0 <= (B - x) * A)\n-> (0 <= (B - x) * (1 - A))\n-> (0 <= (B - x) * (B - 1))\n-> (0 <= (B - x) * (B - x))\n-> (0 <= (B - x) * (B - y))\n-> (0 <= (B - x) * u)\n-> (0 <= (B - x) * v)\n-> (0 <= (B - x) * (A - u))\n-> (0 <= (B - x) * (A - v))\n-> (0 <= (B - y) * A)\n-> (0 <= (B - y) * (1 - A))\n-> (0 <= (B - y) * (B - 1))\n-> (0 <= (B - y) * (B - x))\n-> (0 <= (B - y) * (B - y))\n-> (0 <= (B - y) * u)\n-> (0 <= (B - y) * v)\n-> (0 <= (B - y) * (A - u))\n-> (0 <= (B - y) * (A - v))\n-> (0 <= u * A)\n-> (0 <= u * (1 - A))\n-> (0 <= u * (B - 1))\n-> (0 <= u * (B - x))\n-> (0 <= u * (B - y))\n-> (0 <= u * u)\n-> (0 <= u * v)\n-> (0 <= u * (A - u))\n-> (0 <= u * (A - v))\n-> (0 <= v * A)\n-> (0 <= v * (1 - A))\n-> (0 <= v * (B - 1))\n-> (0 <= v * (B - x))\n-> (0 <= v * (B - y))\n-> (0 <= v * u)\n-> (0 <= v * v)\n-> (0 <= v * (A - u))\n-> (0 <= v * (A - v))\n-> (0 < (A - u) * A)\n-> (0 <= (A - u) * (1 - A))\n-> (0 <= (A - u) * (B - 1))\n-> (0 <= (A - u) * (B - x))\n-> (0 <= (A - u) * (B - y))\n-> (0 <= (A - u) * u)\n-> (0 <= (A - u) * v)\n-> (0 < (A - u) * (A - u))\n-> (0 < (A - u) * (A - v))\n-> (0 < (A - v) * A)\n-> (0 <= (A - v) * (1 - A))\n-> (0 <= (A - v) * (B - 1))\n-> (0 <= (A - v) * (B - x))\n-> (0 <= (A - v) * (B - y))\n-> (0 <= (A - v) * u)\n-> (0 <= (A - v) * v)\n-> (0 < (A - v) * (A - u))\n-> (0 < (A - v) * (A - v))\n->\n u * y + v * x + u * v < 3 * A * B",
  "tactic-prompt":
  "example (u v x y A B : Rat)  (a : 0 < A)  (a_1 : 0 <= 1 - A)  (a_2 : 0 <= B - 1)  (a_3 : 0 <= B - x)  (a_4 : 0 <= B - y)  (a_5 : 0 <= u)  (a_6 : 0 <= v)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v) : (0 < A * A)\n-> (0 <= A * (1 - A))\n-> (0 <= A * (B - 1))\n-> (0 <= A * (B - x))\n-> (0 <= A * (B - y))\n-> (0 <= A * u)\n-> (0 <= A * v)\n-> (0 < A * (A - u))\n-> (0 < A * (A - v))\n-> (0 <= (1 - A) * A)\n-> (0 <= (1 - A) * (1 - A))\n-> (0 <= (1 - A) * (B - 1))\n-> (0 <= (1 - A) * (B - x))\n-> (0 <= (1 - A) * (B - y))\n-> (0 <= (1 - A) * u)\n-> (0 <= (1 - A) * v)\n-> (0 <= (1 - A) * (A - u))\n-> (0 <= (1 - A) * (A - v))\n-> (0 <= (B - 1) * A)\n-> (0 <= (B - 1) * (1 - A))\n-> (0 <= (B - 1) * (B - 1))\n-> (0 <= (B - 1) * (B - x))\n-> (0 <= (B - 1) * (B - y))\n-> (0 <= (B - 1) * u)\n-> (0 <= (B - 1) * v)\n-> (0 <= (B - 1) * (A - u))\n-> (0 <= (B - 1) * (A - v))\n-> (0 <= (B - x) * A)\n-> (0 <= (B - x) * (1 - A))\n-> (0 <= (B - x) * (B - 1))\n-> (0 <= (B - x) * (B - x))\n-> (0 <= (B - x) * (B - y))\n-> (0 <= (B - x) * u)\n-> (0 <= (B - x) * v)\n-> (0 <= (B - x) * (A - u))\n-> (0 <= (B - x) * (A - v))\n-> (0 <= (B - y) * A)\n-> (0 <= (B - y) * (1 - A))\n-> (0 <= (B - y) * (B - 1))\n-> (0 <= (B - y) * (B - x))\n-> (0 <= (B - y) * (B - y))\n-> (0 <= (B - y) * u)\n-> (0 <= (B - y) * v)\n-> (0 <= (B - y) * (A - u))\n-> (0 <= (B - y) * (A - v))\n-> (0 <= u * A)\n-> (0 <= u * (1 - A))\n-> (0 <= u * (B - 1))\n-> (0 <= u * (B - x))\n-> (0 <= u * (B - y))\n-> (0 <= u * u)\n-> (0 <= u * v)\n-> (0 <= u * (A - u))\n-> (0 <= u * (A - v))\n-> (0 <= v * A)\n-> (0 <= v * (1 - A))\n-> (0 <= v * (B - 1))\n-> (0 <= v * (B - x))\n-> (0 <= v * (B - y))\n-> (0 <= v * u)\n-> (0 <= v * v)\n-> (0 <= v * (A - u))\n-> (0 <= v * (A - v))\n-> (0 < (A - u) * A)\n-> (0 <= (A - u) * (1 - A))\n-> (0 <= (A - u) * (B - 1))\n-> (0 <= (A - u) * (B - x))\n-> (0 <= (A - u) * (B - y))\n-> (0 <= (A - u) * u)\n-> (0 <= (A - u) * v)\n-> (0 < (A - u) * (A - u))\n-> (0 < (A - u) * (A - v))\n-> (0 < (A - v) * A)\n-> (0 <= (A - v) * (1 - A))\n-> (0 <= (A - v) * (B - 1))\n-> (0 <= (A - v) * (B - x))\n-> (0 <= (A - v) * (B - y))\n-> (0 <= (A - v) * u)\n-> (0 <= (A - v) * v)\n-> (0 < (A - v) * (A - u))\n-> (0 < (A - v) * (A - v))\n->\n u * y + v * x + u * v < 3 * A * B := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt":
  "(u v x y A B : Rat)  (a : 0 < A)  (a_1 : 0 <= 1 - A)  (a_2 : 0 <= B - 1)  (a_3 : 0 <= B - x)  (a_4 : 0 <= B - y)  (a_5 : 0 <= u)  (a_6 : 0 <= v)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v) : (0 < A * A)\n-> (0 <= A * (1 - A))\n-> (0 <= A * (B - 1))\n-> (0 <= A * (B - x))\n-> (0 <= A * (B - y))\n-> (0 <= A * u)\n-> (0 <= A * v)\n-> (0 < A * (A - u))\n-> (0 < A * (A - v))\n-> (0 <= (1 - A) * A)\n-> (0 <= (1 - A) * (1 - A))\n-> (0 <= (1 - A) * (B - 1))\n-> (0 <= (1 - A) * (B - x))\n-> (0 <= (1 - A) * (B - y))\n-> (0 <= (1 - A) * u)\n-> (0 <= (1 - A) * v)\n-> (0 <= (1 - A) * (A - u))\n-> (0 <= (1 - A) * (A - v))\n-> (0 <= (B - 1) * A)\n-> (0 <= (B - 1) * (1 - A))\n-> (0 <= (B - 1) * (B - 1))\n-> (0 <= (B - 1) * (B - x))\n-> (0 <= (B - 1) * (B - y))\n-> (0 <= (B - 1) * u)\n-> (0 <= (B - 1) * v)\n-> (0 <= (B - 1) * (A - u))\n-> (0 <= (B - 1) * (A - v))\n-> (0 <= (B - x) * A)\n-> (0 <= (B - x) * (1 - A))\n-> (0 <= (B - x) * (B - 1))\n-> (0 <= (B - x) * (B - x))\n-> (0 <= (B - x) * (B - y))\n-> (0 <= (B - x) * u)\n-> (0 <= (B - x) * v)\n-> (0 <= (B - x) * (A - u))\n-> (0 <= (B - x) * (A - v))\n-> (0 <= (B - y) * A)\n-> (0 <= (B - y) * (1 - A))\n-> (0 <= (B - y) * (B - 1))\n-> (0 <= (B - y) * (B - x))\n-> (0 <= (B - y) * (B - y))\n-> (0 <= (B - y) * u)\n-> (0 <= (B - y) * v)\n-> (0 <= (B - y) * (A - u))\n-> (0 <= (B - y) * (A - v))\n-> (0 <= u * A)\n-> (0 <= u * (1 - A))\n-> (0 <= u * (B - 1))\n-> (0 <= u * (B - x))\n-> (0 <= u * (B - y))\n-> (0 <= u * u)\n-> (0 <= u * v)\n-> (0 <= u * (A - u))\n-> (0 <= u * (A - v))\n-> (0 <= v * A)\n-> (0 <= v * (1 - A))\n-> (0 <= v * (B - 1))\n-> (0 <= v * (B - x))\n-> (0 <= v * (B - y))\n-> (0 <= v * u)\n-> (0 <= v * v)\n-> (0 <= v * (A - u))\n-> (0 <= v * (A - v))\n-> (0 < (A - u) * A)\n-> (0 <= (A - u) * (1 - A))\n-> (0 <= (A - u) * (B - 1))\n-> (0 <= (A - u) * (B - x))\n-> (0 <= (A - u) * (B - y))\n-> (0 <= (A - u) * u)\n-> (0 <= (A - u) * v)\n-> (0 < (A - u) * (A - u))\n-> (0 < (A - u) * (A - v))\n-> (0 < (A - v) * A)\n-> (0 <= (A - v) * (1 - A))\n-> (0 <= (A - v) * (B - 1))\n-> (0 <= (A - v) * (B - x))\n-> (0 <= (A - v) * (B - y))\n-> (0 <= (A - v) * u)\n-> (0 <= (A - v) * v)\n-> (0 < (A - v) * (A - u))\n-> (0 < (A - v) * (A - v))\n->\n u * y + v * x + u * v < 3 * A * B",
  "args":
  "(u v x y A B : Rat)  (a : 0 < A)  (a_1 : 0 <= 1 - A)  (a_2 : 0 <= B - 1)  (a_3 : 0 <= B - x)  (a_4 : 0 <= B - y)  (a_5 : 0 <= u)  (a_6 : 0 <= v)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v)"},
 {"type": "0 ≤ x ^2 + y ^2",
  "tactic-prompt": "example (x y : ℚ) : 0 ≤ x ^2 + y ^2 := by nlinarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nlinarith",
  "core-prompt": "(x y : ℚ) : 0 ≤ x ^2 + y ^2",
  "args": "(x y : ℚ)"},
 {"type": "0 ≤ x*x + y*y",
  "tactic-prompt": "example (x y : ℚ) : 0 ≤ x*x + y*y := by nlinarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nlinarith",
  "core-prompt": "(x y : ℚ) : 0 ≤ x*x + y*y",
  "args": "(x y : ℚ)"},
 {"type": "x = 0 → y = 0 → x*x + y*y = 0",
  "tactic-prompt":
  "example (x y : ℚ) : x = 0 → y = 0 → x*x + y*y = 0 := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(x y : ℚ) : x = 0 → y = 0 → x*x + y*y = 0",
  "args": "(x y : ℚ)"},
 {"type": "x * x + y * y = 0 ↔ x = 0 ∧ y = 0",
  "tactic-prompt":
  "lemma {x y : ℚ} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0 := by constructor; sorry",
  "name": "norm_eq_zero_iff",
  "kind": "lemma",
  "first-tactic": "constructor",
  "core-prompt": "{x y : ℚ} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0",
  "args": "{x y : ℚ}"},
 {"type": "x = 0",
  "tactic-prompt":
  "lemma {x y : ℚ}  (h1 : x * x + y * y = 0) : x = 0 := by nlinarith; sorry",
  "name": "norm_zero_left",
  "kind": "lemma",
  "first-tactic": "nlinarith",
  "core-prompt": "{x y : ℚ}  (h1 : x * x + y * y = 0) : x = 0",
  "args": "{x y : ℚ}  (h1 : x * x + y * y = 0)"},
 {"type": "y = 0",
  "tactic-prompt":
  "lemma {x y : ℚ}  (h1 : x * x + y * y ≤ 0) : y = 0 := by nlinarith; sorry",
  "name": "norm_nonpos_right",
  "kind": "lemma",
  "first-tactic": "nlinarith",
  "core-prompt": "{x y : ℚ}  (h1 : x * x + y * y ≤ 0) : y = 0",
  "args": "{x y : ℚ}  (h1 : x * x + y * y ≤ 0)"},
 {"type": "x = 0",
  "tactic-prompt":
  "lemma (x y : ℚ)  (h1 : x * x + y * y ≤ 0) : x = 0 := by nlinarith; sorry",
  "name": "norm_nonpos_left",
  "kind": "lemma",
  "first-tactic": "nlinarith",
  "core-prompt": "(x y : ℚ)  (h1 : x * x + y * y ≤ 0) : x = 0",
  "args": "(x y : ℚ)  (h1 : x * x + y * y ≤ 0)"},
 {"type": "1 ≤ 2",
  "tactic-prompt":
  "example {E : Type _}  [AddGroup E] (f : ℤ → E)  (h : 0 = f 0) : 1 ≤ 2 := by nlinarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nlinarith",
  "core-prompt":
  "{E : Type _}  [AddGroup E] (f : ℤ → E)  (h : 0 = f 0) : 1 ≤ 2",
  "args": "{E : Type _}  [AddGroup E] (f : ℤ → E)  (h : 0 = f 0)"},
 {"type": "1 ≤ 2",
  "tactic-prompt":
  "example {E : Type _}  [AddGroup E] (a : E)  (h : a = a) : 1 ≤ 2 := by nlinarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nlinarith",
  "core-prompt": "{E : Type _}  [AddGroup E] (a : E)  (h : a = a) : 1 ≤ 2",
  "args": "{E : Type _}  [AddGroup E] (a : E)  (h : a = a)"},
 {"type": "p * r + q * s + (t * w + u * v) = p * s + q * r + (t * v + u * w)",
  "tactic-prompt":
  "example {E : Type _}  [AddGroup E] (p q r s t u v w : ℕ)  (h1 : p + u = q + t)  (h2 : r + w = s + v) : p * r + q * s + (t * w + u * v) = p * s + q * r + (t * v + u * w) := by nlinarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nlinarith",
  "core-prompt":
  "{E : Type _}  [AddGroup E] (p q r s t u v w : ℕ)  (h1 : p + u = q + t)  (h2 : r + w = s + v) : p * r + q * s + (t * w + u * v) = p * s + q * r + (t * v + u * w)",
  "args":
  "{E : Type _}  [AddGroup E] (p q r s t u v w : ℕ)  (h1 : p + u = q + t)  (h2 : r + w = s + v)"},
 {"type": "y * x ≤ x * x",
  "tactic-prompt":
  "example {E : Type _}  [AddGroup E] (x y : ℚ)  (h₁ : 0 ≤ y)  (h₂ : y ≤ x) : y * x ≤ x * x := by nlinarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nlinarith",
  "core-prompt":
  "{E : Type _}  [AddGroup E] (x y : ℚ)  (h₁ : 0 ≤ y)  (h₂ : y ≤ x) : y * x ≤ x * x",
  "args": "{E : Type _}  [AddGroup E] (x y : ℚ)  (h₁ : 0 ≤ y)  (h₂ : y ≤ x)"},
 {"type": "y * x ≤ x ^ 2",
  "tactic-prompt":
  "example {E : Type _}  [AddGroup E] (x y : ℚ)  (h₁ : 0 ≤ y)  (h₂ : y ≤ x) : y * x ≤ x ^ 2 := by nlinarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nlinarith",
  "core-prompt":
  "{E : Type _}  [AddGroup E] (x y : ℚ)  (h₁ : 0 ≤ y)  (h₂ : y ≤ x) : y * x ≤ x ^ 2",
  "args": "{E : Type _}  [AddGroup E] (x y : ℚ)  (h₁ : 0 ≤ y)  (h₂ : y ≤ x)"},
 {"type": "1 ≤ y + x * x",
  "tactic-prompt":
  "lemma {E : Type _}  [AddGroup E] (x y: Int)  (h : 0 ≤ y ∧ 1 ≤ x) : 1 ≤ y + x * x := by linarith [foo h.2]; sorry",
  "name": "bar",
  "kind": "lemma",
  "first-tactic": "linarith [foo h.2]",
  "core-prompt":
  "{E : Type _}  [AddGroup E] (x y: Int)  (h : 0 ≤ y ∧ 1 ≤ x) : 1 ≤ y + x * x",
  "args": "{E : Type _}  [AddGroup E] (x y: Int)  (h : 0 ≤ y ∧ 1 ≤ x)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by run_tac\n    let t : Option Bool := (← Lean.MonadOptions.getOptions).get? `pp.all; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "run_tac\n    let t : Option Bool := (← Lean.MonadOptions.getOptions).get? `pp.all",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by run_tac\n    let t : Option Bool := (← Lean.MonadOptions.getOptions).get? `pp.all; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "run_tac\n    let t : Option Bool := (← Lean.MonadOptions.getOptions).get? `pp.all",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by run_tac\n    let t : Option Bool := (← Lean.MonadOptions.getOptions).get? `pp.all; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "run_tac\n    let t : Option Bool := (← Lean.MonadOptions.getOptions).get? `pp.all",
  "core-prompt": " : True",
  "args": ""},
 {"type": "False → α",
  "tactic-prompt": "example  : False → α := by intro.; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro.",
  "core-prompt": " : False → α",
  "args": ""},
 {"type": "¬ False",
  "tactic-prompt": "example  : ¬ False := by intro.; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro.",
  "core-prompt": " : ¬ False",
  "args": ""},
 {"type": "P ∧ Q",
  "tactic-prompt":
  "example {P Q : Prop}  (q : P)  (p : Q) : P ∧ Q := by swap_var p ↔ q; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "swap_var p ↔ q",
  "core-prompt": "{P Q : Prop}  (q : P)  (p : Q) : P ∧ Q",
  "args": "{P Q : Prop}  (q : P)  (p : Q)"},
 {"type": "a = b ∧ a = a",
  "tactic-prompt":
  "example {a b : Nat}  (h : a = b) : a = b ∧ a = a := by swap_var a ↔ b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "swap_var a ↔ b",
  "core-prompt": "{a b : Nat}  (h : a = b) : a = b ∧ a = a",
  "args": "{a b : Nat}  (h : a = b)"},
 {"type": "a = b ∧ c = d",
  "tactic-prompt":
  "example {a b c d : Nat}  (h : a = b ∧ c = d) : a = b ∧ c = d := by swap_var a ↔ b, b c; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "swap_var a ↔ b, b c",
  "core-prompt": "{a b c d : Nat}  (h : a = b ∧ c = d) : a = b ∧ c = d",
  "args": "{a b c d : Nat}  (h : a = b ∧ c = d)"},
 {"type": "frobnicate a 0 = a",
  "tactic-prompt":
  "example  : frobnicate a 0 = a := by simp [frobnicate_def]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp [frobnicate_def]",
  "core-prompt": " : frobnicate a 0 = a",
  "args": ""},
 {"type": "withUniv.{u, v} = (Type v, Type u)",
  "tactic-prompt":
  "example  : withUniv.{u, v} = (Type v, Type u) := by rw [withUniv_def]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rw [withUniv_def]",
  "core-prompt": " : withUniv.{u, v} = (Type v, Type u)",
  "args": ""},
 {"type": "0 < a",
  "tactic-prompt":
  "example {R : Type}  [OrderedRing R]  {a : R}  (h : 0 < a) : 0 < a := by nontriviality; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nontriviality",
  "core-prompt": "{R : Type}  [OrderedRing R]  {a : R}  (h : 0 < a) : 0 < a",
  "args": "{R : Type}  [OrderedRing R]  {a : R}  (h : 0 < a)"},
 {"type": "r * s = s * r",
  "tactic-prompt":
  "example {R : Type}  [CommRing R]  {r s : R} : r * s = s * r := by nontriviality; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nontriviality",
  "core-prompt": "{R : Type}  [CommRing R]  {r s : R} : r * s = s * r",
  "args": "{R : Type}  [CommRing R]  {r s : R}"},
 {"type": "0 ≤ (1 : R)",
  "tactic-prompt":
  "example {R : Type}  [OrderedRing R] : 0 ≤ (1 : R) := by nontriviality R; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nontriviality R",
  "core-prompt": "{R : Type}  [OrderedRing R] : 0 ≤ (1 : R)",
  "args": "{R : Type}  [OrderedRing R]"},
 {"type": "0 ≤ (1 : R)",
  "tactic-prompt":
  "example {R : Type}  [OrderedRing R] : 0 ≤ (1 : R) := by nontriviality ℕ; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nontriviality ℕ",
  "core-prompt": "{R : Type}  [OrderedRing R] : 0 ≤ (1 : R)",
  "args": "{R : Type}  [OrderedRing R]"},
 {"type": "0 ≤ (2 : R)",
  "tactic-prompt":
  "example {R : Type}  [OrderedRing R] : 0 ≤ (2 : R) := by fail_if_success nontriviality PUnit; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success nontriviality PUnit",
  "core-prompt": "{R : Type}  [OrderedRing R] : 0 ≤ (2 : R)",
  "args": "{R : Type}  [OrderedRing R]"},
 {"type": "2 ∣ 4",
  "tactic-prompt":
  "example {R : Type}  [OrderedRing R]  {a : R}  (h : 0 < a) : 2 ∣ 4 := by nontriviality R; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nontriviality R",
  "core-prompt": "{R : Type}  [OrderedRing R]  {a : R}  (h : 0 < a) : 2 ∣ 4",
  "args": "{R : Type}  [OrderedRing R]  {a : R}  (h : 0 < a)"},
 {"type": "EmptyOrUniv s",
  "tactic-prompt":
  "example {α : Type _}  (s : Set α)  (hs : s = ∅ ∪ Set.univ) : EmptyOrUniv s := by fail_if_success nontriviality α; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success nontriviality α",
  "core-prompt":
  "{α : Type _}  (s : Set α)  (hs : s = ∅ ∪ Set.univ) : EmptyOrUniv s",
  "args": "{α : Type _}  (s : Set α)  (hs : s = ∅ ∪ Set.univ)"},
 {"type": "EmptyOrUniv s",
  "tactic-prompt":
  "example {α : Type _}  (s : Set α)  (hs : s = ∅ ∪ Set.univ) : EmptyOrUniv s := by fail_if_success nontriviality α; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success nontriviality α",
  "core-prompt":
  "{α : Type _}  (s : Set α)  (hs : s = ∅ ∪ Set.univ) : EmptyOrUniv s",
  "args": "{α : Type _}  (s : Set α)  (hs : s = ∅ ∪ Set.univ)"},
 {"type": "EmptyOrUniv s",
  "tactic-prompt":
  "example {α : Type _}  (s : Set α)  (hs : s = ∅ ∪ Set.univ) : EmptyOrUniv s := by nontriviality α; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nontriviality α",
  "core-prompt":
  "{α : Type _}  (s : Set α)  (hs : s = ∅ ∪ Set.univ) : EmptyOrUniv s",
  "args": "{α : Type _}  (s : Set α)  (hs : s = ∅ ∪ Set.univ)"},
 {"type": "a = b",
  "tactic-prompt":
  "example (α : ℕ → Type)  (a b : α 0)  (h : a = b) : a = b := by nontriviality α 0 using Nat.zero_lt_one; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nontriviality α 0 using Nat.zero_lt_one",
  "core-prompt": "(α : ℕ → Type)  (a b : α 0)  (h : a = b) : a = b",
  "args": "(α : ℕ → Type)  (a b : α 0)  (h : a = b)"},
 {"type": "α",
  "tactic-prompt":
  "example (f : ∀ x : Nat, x = x → α) : α := by apply (config := {}) f; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply (config := {}) f",
  "core-prompt": "(f : ∀ x : Nat, x = x → α) : α",
  "args": "(f : ∀ x : Nat, x = x → α)"},
 {"type": "α",
  "tactic-prompt":
  "example (f : ∀ x : Nat, x = x → α) : α := by apply (config := { newGoals := .nonDependentOnly }) f; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply (config := { newGoals := .nonDependentOnly }) f",
  "core-prompt": "(f : ∀ x : Nat, x = x → α) : α",
  "args": "(f : ∀ x : Nat, x = x → α)"},
 {"type": "α",
  "tactic-prompt":
  "example (f : ∀ x : Nat, x = x → α) : α := by apply (config := { newGoals := .all }) f; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply (config := { newGoals := .all }) f",
  "core-prompt": "(f : ∀ x : Nat, x = x → α) : α",
  "args": "(f : ∀ x : Nat, x = x → α)"},
 {"type": "P",
  "tactic-prompt":
  "example (p : P) : P := by expect_failure_msg \"unknown identifier 'x'\" have h := x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "expect_failure_msg \"unknown identifier 'x'\" have h := x",
  "core-prompt": "(p : P) : P",
  "args": "(p : P)"},
 {"type": "x + 0 = y → x = y",
  "tactic-prompt": "example  : x + 0 = y → x = y := by simp_intro; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro",
  "core-prompt": " : x + 0 = y → x = y",
  "args": ""},
 {"type": "x + 0 = y → x = y",
  "tactic-prompt": "example  : x + 0 = y → x = y := by simp_intro h₁; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro h₁",
  "core-prompt": " : x + 0 = y → x = y",
  "args": ""},
 {"type": "x + 0 ≠ y → x ≠ y",
  "tactic-prompt": "example  : x + 0 ≠ y → x ≠ y := by simp_intro h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro h₁ h₂",
  "core-prompt": " : x + 0 ≠ y → x ≠ y",
  "args": ""},
 {"type": "x + 0 ≠ y → x ≠ y",
  "tactic-prompt":
  "example  : x + 0 ≠ y → x ≠ y := by simp_intro h₁ h₂ h₃; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro h₁ h₂ h₃",
  "core-prompt": " : x + 0 ≠ y → x ≠ y",
  "args": ""},
 {"type": "x + 0 = y → x = z",
  "tactic-prompt":
  "example (h : x = z) : x + 0 = y → x = z := by simp_intro [h]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro [h]",
  "core-prompt": "(h : x = z) : x + 0 = y → x = z",
  "args": "(h : x = z)"},
 {"type": "x + 0 = y → x = z",
  "tactic-prompt":
  "example (h : y = z) : x + 0 = y → x = z := by simp_intro; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro",
  "core-prompt": "(h : y = z) : x + 0 = y → x = z",
  "args": "(h : y = z)"},
 {"type": "x + 0 = y → x = z",
  "tactic-prompt":
  "example (h : y = z) : x + 0 = y → x = z := by simp_intro _; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro _",
  "core-prompt": "(h : y = z) : x + 0 = y → x = z",
  "args": "(h : y = z)"},
 {"type": "a + (b + a) = a + a + b",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommMonoid α] : a + (b + a) = a + a + b := by abel; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommMonoid α] : a + (b + a) = a + a + b",
  "args": "{α : Type _}  {a b : α} [AddCommMonoid α]"},
 {"type": "(a + b) - ((b + a) + a) = -a",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α] : (a + b) - ((b + a) + a) = -a := by abel; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α] : (a + b) - ((b + a) + a) = -a",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]"},
 {"type": "x - 0 = x",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α]  (x : α) : x - 0 = x := by abel; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α]  (x : α) : x - 0 = x",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]  (x : α)"},
 {"type": "(3 : ℕ) • a = a + (2 : ℕ) • a",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommMonoid α] : (3 : ℕ) • a = a + (2 : ℕ) • a := by abel; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommMonoid α] : (3 : ℕ) • a = a + (2 : ℕ) • a",
  "args": "{α : Type _}  {a b : α} [AddCommMonoid α]"},
 {"type": "(3 : ℤ) • a = a + (2 : ℤ) • a",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α] : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α] : (3 : ℤ) • a = a + (2 : ℤ) • a",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]"},
 {"type": "a-2•b = a -2•b",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α]  (a b : α) : a-2•b = a -2•b := by abel; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α]  (a b : α) : a-2•b = a -2•b",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]  (a b : α)"},
 {"type": "a + (b + a) = a + a + b",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommMonoid α]  (a b : α) : a + (b + a) = a + a + b := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommMonoid α]  (a b : α) : a + (b + a) = a + a + b",
  "args": "{α : Type _}  {a b : α} [AddCommMonoid α]  (a b : α)"},
 {"type": "(a + b) - ((b + a) + a) = -a",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α]  (a b : α) : (a + b) - ((b + a) + a) = -a := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α]  (a b : α) : (a + b) - ((b + a) + a) = -a",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]  (a b : α)"},
 {"type": "x - 0 = x",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α]  (x : α) : x - 0 = x := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α]  (x : α) : x - 0 = x",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]  (x : α)"},
 {"type": "(3 : ℕ) • a = a + (2 : ℕ) • a",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommMonoid α]  (a : α) : (3 : ℕ) • a = a + (2 : ℕ) • a := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommMonoid α]  (a : α) : (3 : ℕ) • a = a + (2 : ℕ) • a",
  "args": "{α : Type _}  {a b : α} [AddCommMonoid α]  (a : α)"},
 {"type": "(3 : ℤ) • a = a + (2 : ℤ) • a",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α]  (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α]  (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]  (a : α)"},
 {"type": "a - 2•b = a - 2•b",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α]  (a b : α) : a - 2•b = a - 2•b := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α]  (a b : α) : a - 2•b = a - 2•b",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]  (a b : α)"},
 {"type": "0 + a = a",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α]  (a : α) : 0 + a = a := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α]  (a : α) : 0 + a = a",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]  (a : α)"},
 {"type": "n • a = n • a",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α]  (n : ℕ)  (a : α) : n • a = n • a := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α]  (n : ℕ)  (a : α) : n • a = n • a",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]  (n : ℕ)  (a : α)"},
 {"type": "0 + n • a = n • a",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α]  (n : ℕ)  (a : α) : 0 + n • a = n • a := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α]  (n : ℕ)  (a : α) : 0 + n • a = n • a",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]  (n : ℕ)  (a : α)"},
 {"type": "a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 • a",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommMonoid α]  (a b c d e : α) : a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 • a := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommMonoid α]  (a b c d e : α) : a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 • a",
  "args": "{α : Type _}  {a b : α} [AddCommMonoid α]  (a b c d e : α)"},
 {"type": "a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 • a",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α]  (a b c d e : α) : a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 • a := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α]  (a b c d e : α) : a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 • a",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]  (a b c d e : α)"},
 {"type": "a + b + (c + d - a) = b + c + d",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α]  (a b c d : α) : a + b + (c + d - a) = b + c + d := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α]  (a b c d : α) : a + b + (c + d - a) = b + c + d",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]  (a b c d : α)"},
 {"type": "a + b + c + (c - a - a) = (-1)•a + b + 2•c",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α]  (a b c : α) : a + b + c + (c - a - a) = (-1)•a + b + 2•c := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α]  (a b c : α) : a + b + c + (c - a - a) = (-1)•a + b + 2•c",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]  (a b c : α)"},
 {"type":
  "a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 • a ∨ True",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommMonoid α]  (a b c d e : α) : a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 • a ∨ True := by fail_if_success\n    left; abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    left; abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommMonoid α]  (a b c d e : α) : a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 • a ∨ True",
  "args": "{α : Type _}  {a b : α} [AddCommMonoid α]  (a b c d e : α)"},
 {"type":
  "a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 • a ∨ True",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α]  (a b c d e : α) : a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 • a ∨ True := by fail_if_success\n    left; abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    left; abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α]  (a b c d e : α) : a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 • a ∨ True",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]  (a b c d e : α)"},
 {"type": "a + b + (c + d - a) = b + c - d ∨ True",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α]  (a b c d : α) : a + b + (c + d - a) = b + c - d ∨ True := by fail_if_success\n    left; abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    left; abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α]  (a b c d : α) : a + b + (c + d - a) = b + c - d ∨ True",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]  (a b c d : α)"},
 {"type": "a + b + c + (c - a - a) = (-1)•a + b + c ∨ True",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α]  (a b c : α) : a + b + c + (c - a - a) = (-1)•a + b + c ∨ True := by fail_if_success\n    left; abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    left; abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α]  (a b c : α) : a + b + c + (c - a - a) = (-1)•a + b + c ∨ True",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]  (a b c : α)"},
 {"type": "a + b - b - id' a = 0",
  "tactic-prompt":
  "example {α : Type _}  {a b : α} [AddCommGroup α]  (a b : α) : a + b - b - id' a = 0 := by fail_if_success\n    abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    abel1",
  "core-prompt":
  "{α : Type _}  {a b : α} [AddCommGroup α]  (a b : α) : a + b - b - id' a = 0",
  "args": "{α : Type _}  {a b : α} [AddCommGroup α]  (a b : α)"},
 {"type": "True",
  "tactic-prompt": "example  : True := by trace 2 + 2 + 3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "trace 2 + 2 + 3",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt": "example  : True := by trace \"hello\" ++ \" world\"; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "trace \"hello\" ++ \" world\"",
  "core-prompt": " : True",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example (_delete_this : Nat) : Nat := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt": "(_delete_this : Nat) : Nat",
  "args": "(_delete_this : Nat)"},
 {"type": "Inhabited Nat",
  "tactic-prompt":
  "example [_dont_delete_this : Inhabited Nat] : Inhabited Nat := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt": "[_dont_delete_this : Inhabited Nat] : Inhabited Nat",
  "args": "[_dont_delete_this : Inhabited Nat]"},
 {"type": "Nat",
  "tactic-prompt":
  "example (_delete_this : Nat)  (dont_delete_this : Int) : Nat := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt": "(_delete_this : Nat)  (dont_delete_this : Int) : Nat",
  "args": "(_delete_this : Nat)  (dont_delete_this : Int)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (_delete_this : Type)  (_delete_this_dep : _delete_this)  (_delete_this_rw : _delete_this = Nat)    (_delete_this_dep_dep : _delete_this_dep = _delete_this_dep) : Nat := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt":
  "(_delete_this : Type)  (_delete_this_dep : _delete_this)  (_delete_this_rw : _delete_this = Nat)    (_delete_this_dep_dep : _delete_this_dep = _delete_this_dep) : Nat",
  "args":
  "(_delete_this : Type)  (_delete_this_dep : _delete_this)  (_delete_this_rw : _delete_this = Nat)    (_delete_this_dep_dep : _delete_this_dep = _delete_this_dep)"},
 {"type": "_dont_delete_this",
  "tactic-prompt":
  "example (_dont_delete_this : Type)  (dep : _dont_delete_this) : _dont_delete_this := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt":
  "(_dont_delete_this : Type)  (dep : _dont_delete_this) : _dont_delete_this",
  "args": "(_dont_delete_this : Type)  (dep : _dont_delete_this)"},
 {"type": "_dont_delete_this = _dont_delete_this",
  "tactic-prompt":
  "example (_dont_delete_this : Type) : _dont_delete_this = _dont_delete_this := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt":
  "(_dont_delete_this : Type) : _dont_delete_this = _dont_delete_this",
  "args": "(_dont_delete_this : Type)"},
 {"type": "_dont_delete_this = _dont_delete_this",
  "tactic-prompt":
  "example (_dont_delete_this : Type)  (_delete_this : _dont_delete_this = _dont_delete_this) : _dont_delete_this = _dont_delete_this := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt":
  "(_dont_delete_this : Type)  (_delete_this : _dont_delete_this = _dont_delete_this) : _dont_delete_this = _dont_delete_this",
  "args":
  "(_dont_delete_this : Type)  (_delete_this : _dont_delete_this = _dont_delete_this)"},
 {"type": "∃ x : Nat, x = x",
  "tactic-prompt": "example  : ∃ x : Nat, x = x := by existsi 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "existsi 42",
  "core-prompt": " : ∃ x : Nat, x = x",
  "args": ""},
 {"type": "∃ x : Nat, ∃ y : Nat, x = y",
  "tactic-prompt":
  "example  : ∃ x : Nat, ∃ y : Nat, x = y := by existsi 42, 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "existsi 42, 42",
  "core-prompt": " : ∃ x : Nat, ∃ y : Nat, x = y",
  "args": ""},
 {"type": "∀ a b : Nat, a = b → b = a",
  "tactic-prompt":
  "example  : ∀ a b : Nat, a = b → b = a := by introv h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "introv h",
  "core-prompt": " : ∀ a b : Nat, a = b → b = a",
  "args": ""},
 {"type": "n = n",
  "tactic-prompt": "example (n : Nat) : n = n := by induction n; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction n",
  "core-prompt": "(n : Nat) : n = n",
  "args": "(n : Nat)"},
 {"type": "Nat",
  "tactic-prompt": "example (n : Nat) : Nat := by guard_hyp n : Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "guard_hyp n : Nat",
  "core-prompt": "(n : Nat) : Nat",
  "args": "(n : Nat)"},
 {"type": "a ≠ b → ¬ a = b",
  "tactic-prompt": "example (a b : Nat) : a ≠ b → ¬ a = b := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b : Nat) : a ≠ b → ¬ a = b",
  "args": "(a b : Nat)"},
 {"type": "¬¬ a = b → a = b",
  "tactic-prompt": "example (a b : Nat) : ¬¬ a = b → a = b := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b : Nat) : ¬¬ a = b → a = b",
  "args": "(a b : Nat)"},
 {"type": "¬¬ p → p",
  "tactic-prompt": "example (p _q : Prop) : ¬¬ p → p := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(p _q : Prop) : ¬¬ p → p",
  "args": "(p _q : Prop)"},
 {"type": "Unit",
  "tactic-prompt": "example (n m : Nat) : Unit := by cases n; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases n",
  "core-prompt": "(n m : Nat) : Unit",
  "args": "(n m : Nat)"},
 {"type": "Unit",
  "tactic-prompt": "example (n m : Nat) : Unit := by cases n; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases n",
  "core-prompt": "(n m : Nat) : Unit",
  "args": "(n m : Nat)"},
 {"type": "Nat",
  "tactic-prompt": "example (n : Nat) : Nat := by iterate exact (); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "iterate exact ()",
  "core-prompt": "(n : Nat) : Nat",
  "args": "(n : Nat)"},
 {"type": "p → q → r → s → (p ∧ q) ∧ (r ∧ s ∧ p) ∧ (p ∧ r ∧ q)",
  "tactic-prompt":
  "example (p q r s : Prop) : p → q → r → s → (p ∧ q) ∧ (r ∧ s ∧ p) ∧ (p ∧ r ∧ q) := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt":
  "(p q r s : Prop) : p → q → r → s → (p ∧ q) ∧ (r ∧ s ∧ p) ∧ (p ∧ r ∧ q)",
  "args": "(p q r s : Prop)"},
 {"type": "p → q → (p ∧ q) ∧ (p ∧ q ∧ p)",
  "tactic-prompt":
  "example (p q : Prop) : p → q → (p ∧ q) ∧ (p ∧ q ∧ p) := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(p q : Prop) : p → q → (p ∧ q) ∧ (p ∧ q ∧ p)",
  "args": "(p q : Prop)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (_delete_this : Nat)  (dont_delete_this : Int) : Nat := by clear * - dont_delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this",
  "core-prompt": "(_delete_this : Nat)  (dont_delete_this : Int) : Nat",
  "args": "(_delete_this : Nat)  (dont_delete_this : Int)"},
 {"type": "Inhabited Nat",
  "tactic-prompt":
  "example [dont_delete_this : Inhabited Nat]  (dont_delete_this2 : Prop) : Inhabited Nat := by clear * - dont_delete_this2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this2",
  "core-prompt":
  "[dont_delete_this : Inhabited Nat]  (dont_delete_this2 : Prop) : Inhabited Nat",
  "args": "[dont_delete_this : Inhabited Nat]  (dont_delete_this2 : Prop)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (_delete_this2 : delete_this = delete_this)  (dont_delete_this : Int) : Nat := by clear * - dont_delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this",
  "core-prompt":
  "(delete_this : Nat)  (_delete_this2 : delete_this = delete_this)  (dont_delete_this : Int) : Nat",
  "args":
  "(delete_this : Nat)  (_delete_this2 : delete_this = delete_this)  (dont_delete_this : Int)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (dont_delete_this : Nat)  (dont_delete_this2 : dont_delete_this = dont_delete_this) : Nat := by clear * - dont_delete_this2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this2",
  "core-prompt":
  "(dont_delete_this : Nat)  (dont_delete_this2 : dont_delete_this = dont_delete_this) : Nat",
  "args":
  "(dont_delete_this : Nat)  (dont_delete_this2 : dont_delete_this = dont_delete_this)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (_delete_this : Nat)  (dont_delete_this : Int)  (dont_delete_this2 : Int) : Nat := by clear * - dont_delete_this dont_delete_this2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this dont_delete_this2",
  "core-prompt":
  "(_delete_this : Nat)  (dont_delete_this : Int)  (dont_delete_this2 : Int) : Nat",
  "args":
  "(_delete_this : Nat)  (dont_delete_this : Int)  (dont_delete_this2 : Int)"},
 {"type": "(α : Type) × List α",
  "tactic-prompt": "example  : (α : Type) × List α := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : (α : Type) × List α",
  "args": ""},
 {"type": "Bool",
  "tactic-prompt":
  "def  : Bool := by fail_if_success have := ∀ p, decide p; sorry",
  "name": "foo",
  "kind": "def",
  "first-tactic": "fail_if_success have := ∀ p, decide p",
  "core-prompt": " : Bool",
  "args": ""},
 {"type": "Bool",
  "tactic-prompt":
  "def  : Bool := by fail_if_success have := ∀ p, decide p; sorry",
  "name": "bar",
  "kind": "def",
  "first-tactic": "fail_if_success have := ∀ p, decide p",
  "core-prompt": " : Bool",
  "args": ""},
 {"type": "Bool",
  "tactic-prompt":
  "def  : Bool := by fail_if_success have := ∀ p, decide p; sorry",
  "name": "bar'",
  "kind": "def",
  "first-tactic": "fail_if_success have := ∀ p, decide p",
  "core-prompt": " : Bool",
  "args": ""},
 {"type": "Bool",
  "tactic-prompt":
  "def  : Bool := by fail_if_success have := ∀ p, decide p; sorry",
  "name": "bar''",
  "kind": "def",
  "first-tactic": "fail_if_success have := ∀ p, decide p",
  "core-prompt": " : Bool",
  "args": ""},
 {"type": "3 ∣ n ^ 3 - n",
  "tactic-prompt":
  "example (n : ℤ) : 3 ∣ n ^ 3 - n := by mod_cases n % 3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mod_cases n % 3",
  "core-prompt": "(n : ℤ) : 3 ∣ n ^ 3 - n",
  "args": "(n : ℤ)"},
 {"type": "true ∧ true",
  "tactic-prompt": "example  : true ∧ true := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : true ∧ true",
  "args": ""},
 {"type": "(true ∧ true) ∧ (true ∧ true)",
  "tactic-prompt":
  "example  : (true ∧ true) ∧ (true ∧ true) := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : (true ∧ true) ∧ (true ∧ true)",
  "args": ""},
 {"type": "x = if p then x else x",
  "tactic-prompt":
  "example (x : Nat)  (p : Prop)  [Decidable p] : x = if p then x else x := by split_ifs with h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs with h1",
  "core-prompt":
  "(x : Nat)  (p : Prop)  [Decidable p] : x = if p then x else x",
  "args": "(x : Nat)  (p : Prop)  [Decidable p]"},
 {"type": "x = y",
  "tactic-prompt":
  "example (x y : Nat)  (p : Prop)  [Decidable p]  (h : if p then x = y else y = x) : x = y := by split_ifs at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs at h",
  "core-prompt":
  "(x y : Nat)  (p : Prop)  [Decidable p]  (h : if p then x = y else y = x) : x = y",
  "args":
  "(x y : Nat)  (p : Prop)  [Decidable p]  (h : if p then x = y else y = x)"},
 {"type": "x = if p then (if q then x else x) else x",
  "tactic-prompt":
  "example (x : Nat)  (p q : Prop)  [Decidable p]  [Decidable q] : x = if p then (if q then x else x) else x := by split_ifs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs",
  "core-prompt":
  "(x : Nat)  (p q : Prop)  [Decidable p]  [Decidable q] : x = if p then (if q then x else x) else x",
  "args": "(x : Nat)  (p q : Prop)  [Decidable p]  [Decidable q]"},
 {"type": "x = if (if p then False else True) then x else x",
  "tactic-prompt":
  "example (x : Nat)  (p : Prop)  [Decidable p] : x = if (if p then False else True) then x else x := by split_ifs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs",
  "core-prompt":
  "(x : Nat)  (p : Prop)  [Decidable p] : x = if (if p then False else True) then x else x",
  "args": "(x : Nat)  (p : Prop)  [Decidable p]"},
 {"type": "if if ¬p then p else True then p else ¬p",
  "tactic-prompt":
  "example (p : Prop)  [Decidable p] : if if ¬p then p else True then p else ¬p := by split_ifs with h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs with h",
  "core-prompt":
  "(p : Prop)  [Decidable p] : if if ¬p then p else True then p else ¬p",
  "args": "(p : Prop)  [Decidable p]"},
 {"type": "if if if p then ¬p else q then p else q then q else ¬p ∨ ¬q",
  "tactic-prompt":
  "example (p q : Prop)  [Decidable p]  [Decidable q] : if if if p then ¬p else q then p else q then q else ¬p ∨ ¬q := by split_ifs with h1 h2 h3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs with h1 h2 h3",
  "core-prompt":
  "(p q : Prop)  [Decidable p]  [Decidable q] : if if if p then ¬p else q then p else q then q else ¬p ∨ ¬q",
  "args": "(p q : Prop)  [Decidable p]  [Decidable q]"},
 {"type": "False",
  "tactic-prompt":
  "example (p : Prop)  [Decidable p]  (h : (if p then 1 else 2) > 3) : False := by split_ifs at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs at h",
  "core-prompt":
  "(p : Prop)  [Decidable p]  (h : (if p then 1 else 2) > 3) : False",
  "args": "(p : Prop)  [Decidable p]  (h : (if p then 1 else 2) > 3)"},
 {"type": "x < (if ¬p then 1 else 0) + 1",
  "tactic-prompt":
  "example (p : Prop)  [Decidable p]  (x : Nat)  (h : (if p then 1 else 2) > x) : x < (if ¬p then 1 else 0) + 1 := by split_ifs at *; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs at *",
  "core-prompt":
  "(p : Prop)  [Decidable p]  (x : Nat)  (h : (if p then 1 else 2) > x) : x < (if ¬p then 1 else 0) + 1",
  "args":
  "(p : Prop)  [Decidable p]  (x : Nat)  (h : (if p then 1 else 2) > x)"},
 {"type": "if if ¬p then p else True then p else ¬p",
  "tactic-prompt":
  "example (p : Prop)  [Decidable p] : if if ¬p then p else True then p else ¬p := by split_ifs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs",
  "core-prompt":
  "(p : Prop)  [Decidable p] : if if ¬p then p else True then p else ¬p",
  "args": "(p : Prop)  [Decidable p]"},
 {"type": "if if if p then ¬p else q then p else q then q else ¬p ∨ ¬q",
  "tactic-prompt":
  "example (p q : Prop)  [Decidable p]  [Decidable q] : if if if p then ¬p else q then p else q then q else ¬p ∨ ¬q := by split_ifs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs",
  "core-prompt":
  "(p q : Prop)  [Decidable p]  [Decidable q] : if if if p then ¬p else q then p else q then q else ¬p ∨ ¬q",
  "args": "(p q : Prop)  [Decidable p]  [Decidable q]"},
 {"type": "True",
  "tactic-prompt": "example  : True := by fail_if_success { split_ifs }; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success { split_ifs }",
  "core-prompt": " : True",
  "args": ""},
 {"type": "true",
  "tactic-prompt":
  "example (P Q : Prop)  (w : if P then (if Q then true else true) else true = true) : true := by split_ifs at w; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs at w",
  "core-prompt":
  "(P Q : Prop)  (w : if P then (if Q then true else true) else true = true) : true",
  "args":
  "(P Q : Prop)  (w : if P then (if Q then true else true) else true = true)"},
 {"type": "a + c * e + a + c + 0 ≤ b + d * e + b + d + e",
  "tactic-prompt":
  "example {a b c d e : Nat}  (h1 : a ≤ b)  (h2 : c ≤ d)  (h3 : 0 ≤ e) : a + c * e + a + c + 0 ≤ b + d * e + b + d + e := by apply_rules [add_le_add]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_rules [add_le_add]",
  "core-prompt":
  "{a b c d e : Nat}  (h1 : a ≤ b)  (h2 : c ≤ d)  (h3 : 0 ≤ e) : a + c * e + a + c + 0 ≤ b + d * e + b + d + e",
  "args": "{a b c d e : Nat}  (h1 : a ≤ b)  (h2 : c ≤ d)  (h3 : 0 ≤ e)"},
 {"type": "a + c * e + a + c + 0 ≤ b + d * e + b + d + e",
  "tactic-prompt":
  "example {a b c d e : Nat}  (h1 : a ≤ b)  (h2 : c ≤ d)  (h3 : 0 ≤ e) : a + c * e + a + c + 0 ≤ b + d * e + b + d + e := by apply_rules [add_le_add]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_rules [add_le_add]",
  "core-prompt":
  "{a b c d e : Nat}  (h1 : a ≤ b)  (h2 : c ≤ d)  (h3 : 0 ≤ e) : a + c * e + a + c + 0 ≤ b + d * e + b + d + e",
  "args": "{a b c d e : Nat}  (h1 : a ≤ b)  (h2 : c ≤ d)  (h3 : 0 ≤ e)"},
 {"type": "P 2",
  "tactic-prompt":
  "example (P : Nat → Type)  (f : {n : Nat} → P n → P (n + 1))  (g : P 0) : P 2 := by apply_rules [f]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_rules [f]",
  "core-prompt":
  "(P : Nat → Type)  (f : {n : Nat} → P n → P (n + 1))  (g : P 0) : P 2",
  "args": "(P : Nat → Type)  (f : {n : Nat} → P n → P (n + 1))  (g : P 0)"},
 {"type": "Int × Q",
  "tactic-prompt":
  "example (Q : Type)  (f : Nat → Q) : Int × Q := by apply_rules [Prod.mk]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_rules [Prod.mk]",
  "core-prompt": "(Q : Type)  (f : Nat → Q) : Int × Q",
  "args": "(Q : Type)  (f : Nat → Q)"},
 {"type": "Nat",
  "tactic-prompt": "def  : Nat := by left; sorry",
  "name": "zero",
  "kind": "def",
  "first-tactic": "left",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "def  : Nat := by right; sorry",
  "name": "two",
  "kind": "def",
  "first-tactic": "right",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Sum Nat (List Nat)",
  "tactic-prompt": "example  : Sum Nat (List Nat) := by left; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "left",
  "core-prompt": " : Sum Nat (List Nat)",
  "args": ""},
 {"type": "Sum Nat (List Nat)",
  "tactic-prompt": "example  : Sum Nat (List Nat) := by right; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "right",
  "core-prompt": " : Sum Nat (List Nat)",
  "args": ""},
 {"type": "(1 = 1) ∨ (2 = 3)",
  "tactic-prompt": "example  : (1 = 1) ∨ (2 = 3) := by left; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "left",
  "core-prompt": " : (1 = 1) ∨ (2 = 3)",
  "args": ""},
 {"type": "(1 = 2) ∨ (3 = 3)",
  "tactic-prompt": "example  : (1 = 2) ∨ (3 = 3) := by right; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "right",
  "core-prompt": " : (1 = 2) ∨ (3 = 3)",
  "args": ""},
 {"type": "c < a + 3*b",
  "tactic-prompt":
  "example (a b c x y z : ℕ)  (h : ¬ x*y*z < 0) : c < a + 3*b := by zify; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "zify",
  "core-prompt": "(a b c x y z : ℕ)  (h : ¬ x*y*z < 0) : c < a + 3*b",
  "args": "(a b c x y z : ℕ)  (h : ¬ x*y*z < 0)"},
 {"type": "a + 3*b > c",
  "tactic-prompt":
  "example (a b c x y z : ℕ)  (h : ¬ x*y*z < 0)  (h2 : (c : ℤ) < a + 3 * b) : a + 3*b > c := by zify at h ⊢; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "zify at h ⊢",
  "core-prompt":
  "(a b c x y z : ℕ)  (h : ¬ x*y*z < 0)  (h2 : (c : ℤ) < a + 3 * b) : a + 3*b > c",
  "args": "(a b c x y z : ℕ)  (h : ¬ x*y*z < 0)  (h2 : (c : ℤ) < a + 3 * b)"},
 {"type": "a ≤ b",
  "tactic-prompt":
  "example (a b : ℕ)  (h : (a : ℤ) ≤ b) : a ≤ b := by zify; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "zify",
  "core-prompt": "(a b : ℕ)  (h : (a : ℤ) ≤ b) : a ≤ b",
  "args": "(a b : ℕ)  (h : (a : ℤ) ≤ b)"},
 {"type": "True",
  "tactic-prompt":
  "example (a b c : ℕ)  (h : a - b < c)  (hab : b ≤ a) : True := by zify [hab] at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "zify [hab] at h",
  "core-prompt": "(a b c : ℕ)  (h : a - b < c)  (hab : b ≤ a) : True",
  "args": "(a b c : ℕ)  (h : a - b < c)  (hab : b ≤ a)"},
 {"type": "True",
  "tactic-prompt":
  "example (a b c : ℕ)  (h : a + b ≠ c) : True := by zify at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "zify at h",
  "core-prompt": "(a b c : ℕ)  (h : a + b ≠ c) : True",
  "args": "(a b c : ℕ)  (h : a + b ≠ c)"},
 {"type": "0 ≤ 2 + 2",
  "tactic-prompt":
  "example  : 0 ≤ 2 + 2 := by fail_if_success infer_param; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success infer_param",
  "core-prompt": " : 0 ≤ 2 + 2",
  "args": ""},
 {"type": "0 ≤ 2 + 2",
  "tactic-prompt": "example  : 0 ≤ 2 + 2 := by apply zero_le_add; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply zero_le_add",
  "core-prompt": " : 0 ≤ 2 + 2",
  "args": ""},
 {"type": "0 ≤ 2 + 2",
  "tactic-prompt": "example  : 0 ≤ 2 + 2 := by apply zero_le_add'; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply zero_le_add'",
  "core-prompt": " : 0 ≤ 2 + 2",
  "args": ""},
 {"type": "p → q",
  "tactic-prompt":
  "example (p q : Prop)  (h : ¬q → ¬p) : p → q := by contrapose; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "contrapose",
  "core-prompt": "(p q : Prop)  (h : ¬q → ¬p) : p → q",
  "args": "(p q : Prop)  (h : ¬q → ¬p)"},
 {"type": "q",
  "tactic-prompt":
  "example (p q : Prop)  (h : p)  (hpq : ¬q → ¬p) : q := by contrapose h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "contrapose h",
  "core-prompt": "(p q : Prop)  (h : p)  (hpq : ¬q → ¬p) : q",
  "args": "(p q : Prop)  (h : p)  (hpq : ¬q → ¬p)"},
 {"type": "q",
  "tactic-prompt":
  "example (p q : Prop)  (h : p)  (hpq : ¬q → ¬p) : q := by contrapose h with h'; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "contrapose h with h'",
  "core-prompt": "(p q : Prop)  (h : p)  (hpq : ¬q → ¬p) : q",
  "args": "(p q : Prop)  (h : p)  (hpq : ¬q → ¬p)"},
 {"type": "¬p → ¬q",
  "tactic-prompt":
  "example (p q : Prop)  (h : q → p) : ¬p → ¬q := by contrapose!; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "contrapose!",
  "core-prompt": "(p q : Prop)  (h : q → p) : ¬p → ¬q",
  "args": "(p q : Prop)  (h : q → p)"},
 {"type": "¬q",
  "tactic-prompt":
  "example (p q : Prop)  (h : ¬p)  (hpq : q → p) : ¬q := by contrapose! h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "contrapose! h",
  "core-prompt": "(p q : Prop)  (h : ¬p)  (hpq : q → p) : ¬q",
  "args": "(p q : Prop)  (h : ¬p)  (hpq : q → p)"},
 {"type": "¬q",
  "tactic-prompt":
  "example (p q : Prop)  (h : ¬p)  (hpq : q → p) : ¬q := by contrapose! h with h'; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "contrapose! h with h'",
  "core-prompt": "(p q : Prop)  (h : ¬p)  (hpq : q → p) : ¬q",
  "args": "(p q : Prop)  (h : ¬p)  (hpq : q → p)"},
 {"type": "p",
  "tactic-prompt":
  "example (p : Prop)  (h : p) : p := by fail_if_success { contrapose }; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success { contrapose }",
  "core-prompt": "(p : Prop)  (h : p) : p",
  "args": "(p : Prop)  (h : p)"},
 {"type": "p → q",
  "tactic-prompt":
  "example (p q : Type)  (h : p → q) : p → q := by fail_if_success { contrapose }; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success { contrapose }",
  "core-prompt": "(p q : Type)  (h : p → q) : p → q",
  "args": "(p q : Type)  (h : p → q)"},
 {"type": "a = b → b = a",
  "tactic-prompt": "example (a b : Nat) : a = b → b = a := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b : Nat) : a = b → b = a",
  "args": "(a b : Nat)"},
 {"type": "a = b → True → b = a",
  "tactic-prompt":
  "example (a b : Nat) : a = b → True → b = a := by intro h _; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h _",
  "core-prompt": "(a b : Nat) : a = b → True → b = a",
  "args": "(a b : Nat)"},
 {"type": "sameParity a b → sameParity b a",
  "tactic-prompt":
  "example (a b : Nat) : sameParity a b → sameParity b a := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b : Nat) : sameParity a b → sameParity b a",
  "args": "(a b : Nat)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by run_tac\n    evalApplyLikeTactic MVarId.apply (← `(True.intro)); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "run_tac\n    evalApplyLikeTactic MVarId.apply (← `(True.intro))",
  "core-prompt": " : True",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example (h : Nat) : Nat := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt": "(h : Nat) : Nat",
  "args": "(h : Nat)"},
 {"type": "β",
  "tactic-prompt":
  "example {α β : Type}  (f : α → β)  (a : α) : β := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt": "{α β : Type}  (f : α → β)  (a : α) : β",
  "args": "{α β : Type}  (f : α → β)  (a : α)"},
 {"type": "β",
  "tactic-prompt":
  "example {α β : Type}  (f : α → α → β)  (a : α) : β := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt": "{α β : Type}  (f : α → α → β)  (a : α) : β",
  "args": "{α β : Type}  (f : α → α → β)  (a : α)"},
 {"type": "γ",
  "tactic-prompt":
  "example {α β γ : Type}  (f : α → β)  (g : β → γ)  (a : α) : γ := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt": "{α β γ : Type}  (f : α → β)  (g : β → γ)  (a : α) : γ",
  "args": "{α β γ : Type}  (f : α → β)  (g : β → γ)  (a : α)"},
 {"type": "γ",
  "tactic-prompt":
  "example {α β γ : Type}  (_f : α → β)  (g : β → γ)  (b : β) : γ := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt": "{α β γ : Type}  (_f : α → β)  (g : β → γ)  (b : β) : γ",
  "args": "{α β γ : Type}  (_f : α → β)  (g : β → γ)  (b : β)"},
 {"type": "α 5",
  "tactic-prompt":
  "example {α : Nat → Type}  (f : (n : Nat) → α n → α (n+1))  (a : α 0) : α 5 := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt":
  "{α : Nat → Type}  (f : (n : Nat) → α n → α (n+1))  (a : α 0) : α 5",
  "args": "{α : Nat → Type}  (f : (n : Nat) → α n → α (n+1))  (a : α 0)"},
 {"type": "Nat",
  "tactic-prompt": "example (h : Nat) : Nat := by solve_by_elim []; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim []",
  "core-prompt": "(h : Nat) : Nat",
  "args": "(h : Nat)"},
 {"type": "β",
  "tactic-prompt":
  "example {α β : Type}  (f : α → β)  (a : α) : β := by solve_by_elim []; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim []",
  "core-prompt": "{α β : Type}  (f : α → β)  (a : α) : β",
  "args": "{α β : Type}  (f : α → β)  (a : α)"},
 {"type": "β",
  "tactic-prompt":
  "example {α β : Type}  (f : α → α → β)  (a : α) : β := by solve_by_elim []; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim []",
  "core-prompt": "{α β : Type}  (f : α → α → β)  (a : α) : β",
  "args": "{α β : Type}  (f : α → α → β)  (a : α)"},
 {"type": "γ",
  "tactic-prompt":
  "example {α β γ : Type}  (f : α → β)  (g : β → γ)  (a : α) : γ := by solve_by_elim []; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim []",
  "core-prompt": "{α β γ : Type}  (f : α → β)  (g : β → γ)  (a : α) : γ",
  "args": "{α β γ : Type}  (f : α → β)  (g : β → γ)  (a : α)"},
 {"type": "γ",
  "tactic-prompt":
  "example {α β γ : Type}  (_f : α → β)  (g : β → γ)  (b : β) : γ := by solve_by_elim []; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim []",
  "core-prompt": "{α β γ : Type}  (_f : α → β)  (g : β → γ)  (b : β) : γ",
  "args": "{α β γ : Type}  (_f : α → β)  (g : β → γ)  (b : β)"},
 {"type": "α 5",
  "tactic-prompt":
  "example {α : Nat → Type}  (f : (n : Nat) → α n → α (n+1))  (a : α 0) : α 5 := by solve_by_elim []; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim []",
  "core-prompt":
  "{α : Nat → Type}  (f : (n : Nat) → α n → α (n+1))  (a : α 0) : α 5",
  "args": "{α : Nat → Type}  (f : (n : Nat) → α n → α (n+1))  (a : α 0)"},
 {"type": "β",
  "tactic-prompt":
  "example {α β : Type}  (f : α → β)  (a : α) : β := by fail_if_success solve_by_elim only [f]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success solve_by_elim only [f]",
  "core-prompt": "{α β : Type}  (f : α → β)  (a : α) : β",
  "args": "{α β : Type}  (f : α → β)  (a : α)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (h : Nat) : Nat := by solve_by_elim only [h]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim only [h]",
  "core-prompt": "(h : Nat) : Nat",
  "args": "(h : Nat)"},
 {"type": "β",
  "tactic-prompt":
  "example {α β : Type}  (f : α → β)  (a : α) : β := by solve_by_elim only [f]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim only [f]",
  "core-prompt": "{α β : Type}  (f : α → β)  (a : α) : β",
  "args": "{α β : Type}  (f : α → β)  (a : α)"},
 {"type": "β",
  "tactic-prompt":
  "example {α β : Type}  (f : α → α → β)  (a : α) : β := by solve_by_elim only [f]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim only [f]",
  "core-prompt": "{α β : Type}  (f : α → α → β)  (a : α) : β",
  "args": "{α β : Type}  (f : α → α → β)  (a : α)"},
 {"type": "γ",
  "tactic-prompt":
  "example {α β γ : Type}  (f : α → β)  (g : β → γ)  (a : α) : γ := by solve_by_elim only [f]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim only [f]",
  "core-prompt": "{α β γ : Type}  (f : α → β)  (g : β → γ)  (a : α) : γ",
  "args": "{α β γ : Type}  (f : α → β)  (g : β → γ)  (a : α)"},
 {"type": "γ",
  "tactic-prompt":
  "example {α β γ : Type}  (_f : α → β)  (g : β → γ)  (b : β) : γ := by solve_by_elim only [g]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim only [g]",
  "core-prompt": "{α β γ : Type}  (_f : α → β)  (g : β → γ)  (b : β) : γ",
  "args": "{α β γ : Type}  (_f : α → β)  (g : β → γ)  (b : β)"},
 {"type": "α 5",
  "tactic-prompt":
  "example {α : Nat → Type}  (f : (n : Nat) → α n → α (n+1))  (a : α 0) : α 5 := by solve_by_elim only [f]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim only [f]",
  "core-prompt":
  "{α : Nat → Type}  (f : (n : Nat) → α n → α (n+1))  (a : α 0) : α 5",
  "args": "{α : Nat → Type}  (f : (n : Nat) → α n → α (n+1))  (a : α 0)"},
 {"type": "β",
  "tactic-prompt":
  "example (P₁ P₂ : α → Prop)  (f : ∀ (a : α), P₁ a → P₂ a → β)      (a : α)  (ha₁ : P₁ a)  (ha₂ : P₂ a) : β := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt":
  "(P₁ P₂ : α → Prop)  (f : ∀ (a : α), P₁ a → P₂ a → β)      (a : α)  (ha₁ : P₁ a)  (ha₂ : P₂ a) : β",
  "args":
  "(P₁ P₂ : α → Prop)  (f : ∀ (a : α), P₁ a → P₂ a → β)      (a : α)  (ha₁ : P₁ a)  (ha₂ : P₂ a)"},
 {"type": "x = x",
  "tactic-prompt":
  "example {X : Type}  (x : X) : x = x := by fail_if_success solve_by_elim only; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success solve_by_elim only",
  "core-prompt": "{X : Type}  (x : X) : x = x",
  "args": "{X : Type}  (x : X)"},
 {"type": "p",
  "tactic-prompt":
  "example {X : Type}  (x y : X)  (p : Prop)  (h : x = x → y = y → p) : p := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt":
  "{X : Type}  (x y : X)  (p : Prop)  (h : x = x → y = y → p) : p",
  "args": "{X : Type}  (x y : X)  (p : Prop)  (h : x = x → y = y → p)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by fail_if_success solve_by_elim only; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success solve_by_elim only",
  "core-prompt": " : True",
  "args": ""},
 {"type": "β",
  "tactic-prompt":
  "example (P₁ P₂ : α → Prop)  (f : ∀ (a: α), P₁ a → P₂ a → β)      (a : α)  (_ha₁ : P₁ a)      (a' : α)  (ha'₁ : P₁ a')  (ha'₂ : P₂ a') : β := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt":
  "(P₁ P₂ : α → Prop)  (f : ∀ (a: α), P₁ a → P₂ a → β)      (a : α)  (_ha₁ : P₁ a)      (a' : α)  (ha'₁ : P₁ a')  (ha'₂ : P₂ a') : β",
  "args":
  "(P₁ P₂ : α → Prop)  (f : ∀ (a: α), P₁ a → P₂ a → β)      (a : α)  (_ha₁ : P₁ a)      (a' : α)  (ha'₁ : P₁ a')  (ha'₂ : P₂ a')"},
 {"type": "b",
  "tactic-prompt":
  "example {a b : Type}  (h₀ : a → b)  (h₁ : a) : b := by apply_assumption; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_assumption",
  "core-prompt": "{a b : Type}  (h₀ : a → b)  (h₁ : a) : b",
  "args": "{a b : Type}  (h₀ : a → b)  (h₁ : a)"},
 {"type": "p y",
  "tactic-prompt":
  "example {α : Type}  {p : α → Prop}  (h₀ : ∀ x, p x)  (y : α) : p y := by apply_assumption; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_assumption",
  "core-prompt": "{α : Type}  {p : α → Prop}  (h₀ : ∀ x, p x)  (y : α) : p y",
  "args": "{α : Type}  {p : α → Prop}  (h₀ : ∀ x, p x)  (y : α)"},
 {"type": "x + y = y + x",
  "tactic-prompt":
  "example (x y : Nat) : x + y = y + x := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(x y : Nat) : x + y = y + x",
  "args": "(x y : Nat)"},
 {"type": "n ≤ m → n + k ≤ m + k",
  "tactic-prompt":
  "example (n m k : Nat) : n ≤ m → n + k ≤ m + k := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(n m k : Nat) : n ≤ m → n + k ≤ m + k",
  "args": "(n m k : Nat)"},
 {"type": "a * b ∣ a * c",
  "tactic-prompt":
  "example (ha : a > 0)  (w : b ∣ c) : a * b ∣ a * c := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(ha : a > 0)  (w : b ∣ c) : a * b ∣ a * c",
  "args": "(ha : a > 0)  (w : b ∣ c)"},
 {"type": "Int",
  "tactic-prompt": "example  : Int := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": " : Int",
  "args": ""},
 {"type": "P",
  "tactic-prompt":
  "example (P : Prop)  (p : P) : P := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(P : Prop)  (p : P) : P",
  "args": "(P : Prop)  (p : P)"},
 {"type": "false",
  "tactic-prompt":
  "example (P : Prop)  (p : P)  (np : ¬P) : false := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(P : Prop)  (p : P)  (np : ¬P) : false",
  "args": "(P : Prop)  (p : P)  (np : ¬P)"},
 {"type": "α → α",
  "tactic-prompt": "example (α : Prop) : α → α := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(α : Prop) : α → α",
  "args": "(α : Prop)"},
 {"type": "(¬¬p) → p",
  "tactic-prompt": "example (p : Prop) : (¬¬p) → p := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(p : Prop) : (¬¬p) → p",
  "args": "(p : Prop)"},
 {"type": "a + b = b + a",
  "tactic-prompt":
  "example (a b : ℕ) : a + b = b + a := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a b : ℕ) : a + b = b + a",
  "args": "(a b : ℕ)"},
 {"type": "n * (m - k) = n * m - n * k",
  "tactic-prompt":
  "example (n m k : ℕ) : n * (m - k) = n * m - n * k := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(n m k : ℕ) : n * (m - k) = n * m - n * k",
  "args": "(n m k : ℕ)"},
 {"type": "x = y ↔ y = x",
  "tactic-prompt":
  "example {α : Type}  (x y : α) : x = y ↔ y = x := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "{α : Type}  (x y : α) : x = y ↔ y = x",
  "args": "{α : Type}  (x y : α)"},
 {"type": "a ≤ b",
  "tactic-prompt":
  "example (a b : ℕ)  (h : a ∣ b)  (w : b > 0) : a ≤ b := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a b : ℕ)  (h : a ∣ b)  (w : b > 0) : a ≤ b",
  "args": "(a b : ℕ)  (h : a ∣ b)  (w : b > 0)"},
 {"type": "¬ (a < 0)",
  "tactic-prompt": "example (a : ℕ) : ¬ (a < 0) := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a : ℕ) : ¬ (a < 0)",
  "args": "(a : ℕ)"},
 {"type": "0 > a",
  "tactic-prompt": "theorem (a : ℕ)  (h : P a) : 0 > a := by cases h; sorry",
  "name": "lemma_with_gt_in_head",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt": "(a : ℕ)  (h : P a) : 0 > a",
  "args": "(a : ℕ)  (h : P a)"},
 {"type": "False",
  "tactic-prompt":
  "theorem (a b : ℕ)  (_h1 : a < b)  (h2 : P a) : False := by apply Nat.not_lt_zero; sorry",
  "name": "lemma_with_false_in_head",
  "kind": "theorem",
  "first-tactic": "apply Nat.not_lt_zero",
  "core-prompt": "(a b : ℕ)  (_h1 : a < b)  (h2 : P a) : False",
  "args": "(a b : ℕ)  (_h1 : a < b)  (h2 : P a)"},
 {"type": "0 > a",
  "tactic-prompt":
  "example (a : ℕ)  (h : P a) : 0 > a := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a : ℕ)  (h : P a) : 0 > a",
  "args": "(a : ℕ)  (h : P a)"},
 {"type": "∀ P : Prop, ¬(P ↔ ¬P)",
  "tactic-prompt":
  "example  : ∀ P : Prop, ¬(P ↔ ¬P) := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": " : ∀ P : Prop, ¬(P ↔ ¬P)",
  "args": ""},
 {"type": "α",
  "tactic-prompt":
  "example {α : Sort u}  (h : Empty) : α := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "{α : Sort u}  (h : Empty) : α",
  "args": "{α : Sort u}  (h : Empty)"},
 {"type": "α",
  "tactic-prompt":
  "example {α : Type _}  (h : Empty) : α := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "{α : Type _}  (h : Empty) : α",
  "args": "{α : Type _}  (h : Empty)"},
 {"type": "List ℕ",
  "tactic-prompt":
  "example (L _M : List (List ℕ)) : List ℕ := by library_search using L; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search using L",
  "core-prompt": "(L _M : List (List ℕ)) : List ℕ",
  "args": "(L _M : List (List ℕ))"},
 {"type": "List ℕ",
  "tactic-prompt":
  "example (P _Q : List ℕ)  (h : ℕ) : List ℕ := by library_search using h, P; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search using h, P",
  "core-prompt": "(P _Q : List ℕ)  (h : ℕ) : List ℕ",
  "args": "(P _Q : List ℕ)  (h : ℕ)"},
 {"type": "List.nthLe [1, 2] 1 (by simp) = 2",
  "tactic-prompt":
  "example  : List.nthLe [1, 2] 1 (by simp) = 2 := by generalize_proofs h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs h",
  "core-prompt": " : List.nthLe [1, 2] 1 (by simp) = 2",
  "args": ""},
 {"type": "Classical.choose (⟨x, h⟩ : ∃ x, x < 2) < 2",
  "tactic-prompt":
  "example (x : ℕ)  (h : x < 2) : Classical.choose (⟨x, h⟩ : ∃ x, x < 2) < 2 := by generalize_proofs a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs a",
  "core-prompt":
  "(x : ℕ)  (h : x < 2) : Classical.choose (⟨x, h⟩ : ∃ x, x < 2) < 2",
  "args": "(x : ℕ)  (h : x < 2)"},
 {"type":
  "Classical.choose (⟨x, h⟩ : ∃ x, x < 2) = Classical.choose (⟨x, h⟩ : ∃ x, x < 2)",
  "tactic-prompt":
  "example (x : ℕ)  (h : x < 2) : Classical.choose (⟨x, h⟩ : ∃ x, x < 2) = Classical.choose (⟨x, h⟩ : ∃ x, x < 2) := by generalize_proofs a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs a",
  "core-prompt":
  "(x : ℕ)  (h : x < 2) : Classical.choose (⟨x, h⟩ : ∃ x, x < 2) = Classical.choose (⟨x, h⟩ : ∃ x, x < 2)",
  "args": "(x : ℕ)  (h : x < 2)"},
 {"type":
  "Classical.choose (⟨x, h⟩ : ∃ x, x < 2) =\n  Classical.choose (⟨x, Nat.lt_succ_of_lt h⟩ : ∃ x, x < 3)",
  "tactic-prompt":
  "example (x : ℕ)  (h : x < 2) : Classical.choose (⟨x, h⟩ : ∃ x, x < 2) =\n  Classical.choose (⟨x, Nat.lt_succ_of_lt h⟩ : ∃ x, x < 3) := by generalize_proofs a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs a",
  "core-prompt":
  "(x : ℕ)  (h : x < 2) : Classical.choose (⟨x, h⟩ : ∃ x, x < 2) =\n  Classical.choose (⟨x, Nat.lt_succ_of_lt h⟩ : ∃ x, x < 3)",
  "args": "(x : ℕ)  (h : x < 2)"},
 {"type":
  "Classical.choose (⟨x, h⟩ : ∃ x, x < 2) =\n  Classical.choose (⟨x, Nat.lt_succ_of_lt h⟩ : ∃ x, x < 3)",
  "tactic-prompt":
  "example (x : ℕ)  (h : x < 2) : Classical.choose (⟨x, h⟩ : ∃ x, x < 2) =\n  Classical.choose (⟨x, Nat.lt_succ_of_lt h⟩ : ∃ x, x < 3) := by generalize_proofs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs",
  "core-prompt":
  "(x : ℕ)  (h : x < 2) : Classical.choose (⟨x, h⟩ : ∃ x, x < 2) =\n  Classical.choose (⟨x, Nat.lt_succ_of_lt h⟩ : ∃ x, x < 3)",
  "args": "(x : ℕ)  (h : x < 2)"},
 {"type":
  "Classical.choose (⟨x, h⟩ : ∃ x, x < 2) =\n  Classical.choose (⟨x, Nat.lt_succ_of_lt h⟩ : ∃ x, x < 3)",
  "tactic-prompt":
  "example (x : ℕ)  (h : x < 2) : Classical.choose (⟨x, h⟩ : ∃ x, x < 2) =\n  Classical.choose (⟨x, Nat.lt_succ_of_lt h⟩ : ∃ x, x < 3) := by generalize_proofs _ a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs _ a",
  "core-prompt":
  "(x : ℕ)  (h : x < 2) : Classical.choose (⟨x, h⟩ : ∃ x, x < 2) =\n  Classical.choose (⟨x, Nat.lt_succ_of_lt h⟩ : ∃ x, x < 3)",
  "args": "(x : ℕ)  (h : x < 2)"},
 {"type": "Classical.choose a < 2",
  "tactic-prompt":
  "example (a : ∃ x, x < 2) : Classical.choose a < 2 := by generalize_proofs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs",
  "core-prompt": "(a : ∃ x, x < 2) : Classical.choose a < 2",
  "args": "(a : ∃ x, x < 2)"},
 {"type": "Classical.choose a < 2",
  "tactic-prompt":
  "example (a : ∃ x, x < 2) : Classical.choose a < 2 := by generalize_proofs t; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs t",
  "core-prompt": "(a : ∃ x, x < 2) : Classical.choose a < 2",
  "args": "(a : ∃ x, x < 2)"},
 {"type": "Classical.choose (⟨x, h⟩ : ∃ x, x < 2) < 2",
  "tactic-prompt":
  "example (x : ℕ)  (h : x < 2)  (H : Classical.choose (⟨x, h⟩ : ∃ x, x < 2) < 2) : Classical.choose (⟨x, h⟩ : ∃ x, x < 2) < 2 := by generalize_proofs a at H ⊢; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs a at H ⊢",
  "core-prompt":
  "(x : ℕ)  (h : x < 2)  (H : Classical.choose (⟨x, h⟩ : ∃ x, x < 2) < 2) : Classical.choose (⟨x, h⟩ : ∃ x, x < 2) < 2",
  "args":
  "(x : ℕ)  (h : x < 2)  (H : Classical.choose (⟨x, h⟩ : ∃ x, x < 2) < 2)"},
 {"type": "(if h : ∃ (k : ℕ), k = 1 then Classical.choose h else 0) = 1",
  "tactic-prompt":
  "example (H : ∀ x, x = 1) : (if h : ∃ (k : ℕ), k = 1 then Classical.choose h else 0) = 1 := by rw [dif_pos]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rw [dif_pos]",
  "core-prompt":
  "(H : ∀ x, x = 1) : (if h : ∃ (k : ℕ), k = 1 then Classical.choose h else 0) = 1",
  "args": "(H : ∀ x, x = 1)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (_delete_this_dep : delete_this = delete_this) : Nat := by clear! delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this",
  "core-prompt":
  "(delete_this : Nat)  (_delete_this_dep : delete_this = delete_this) : Nat",
  "args":
  "(delete_this : Nat)  (_delete_this_dep : delete_this = delete_this)"},
 {"type": "Inhabited Nat",
  "tactic-prompt":
  "example [delete_this : Inhabited Nat] : Inhabited Nat := by clear! delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this",
  "core-prompt": "[delete_this : Inhabited Nat] : Inhabited Nat",
  "args": "[delete_this : Inhabited Nat]"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (delete_this2 : Nat)  (_delete_this_dep : delete_this = delete_this2) : Nat := by clear! delete_this delete_this2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this delete_this2",
  "core-prompt":
  "(delete_this : Nat)  (delete_this2 : Nat)  (_delete_this_dep : delete_this = delete_this2) : Nat",
  "args":
  "(delete_this : Nat)  (delete_this2 : Nat)  (_delete_this_dep : delete_this = delete_this2)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (dont_delete_this : Int) : Nat := by clear! delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this",
  "core-prompt": "(delete_this : Nat)  (dont_delete_this : Int) : Nat",
  "args": "(delete_this : Nat)  (dont_delete_this : Int)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (dont_delete_this : Nat)  (delete_this : dont_delete_this = dont_delete_this) : Nat := by clear! delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this",
  "core-prompt":
  "(dont_delete_this : Nat)  (delete_this : dont_delete_this = dont_delete_this) : Nat",
  "args":
  "(dont_delete_this : Nat)  (delete_this : dont_delete_this = dont_delete_this)"},
 {"type": "foo.rfl.toFun n = n",
  "tactic-prompt":
  "example (n : ℕ) : foo.rfl.toFun n = n := by rw [foo.rfl_toFun]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rw [foo.rfl_toFun]",
  "core-prompt": "(n : ℕ) : foo.rfl.toFun n = n",
  "args": "(n : ℕ)"},
 {"type": "foo.rfl.invFun n = n",
  "tactic-prompt":
  "example (n : ℕ) : foo.rfl.invFun n = n := by rw [foo.rfl_invFun]\n\n/- the declarations are `simp` lemmas -/; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "rw [foo.rfl_invFun]\n\n/- the declarations are `simp` lemmas -/",
  "core-prompt": "(n : ℕ) : foo.rfl.invFun n = n",
  "args": "(n : ℕ)"},
 {"type": "foo.1 = 1",
  "tactic-prompt": "example  : foo.1 = 1 := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": " : foo.1 = 1",
  "args": ""},
 {"type": "foo.1 = a",
  "tactic-prompt":
  "example {a : ℕ}  {h : 1 = a} : foo.1 = a := by rw [foo_fst]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rw [foo_fst]",
  "core-prompt": "{a : ℕ}  {h : 1 = a} : foo.1 = a",
  "args": "{a : ℕ}  {h : 1 = a}"},
 {"type": "foo.1 = a",
  "tactic-prompt": "example {a : ℕ}  {h : 1 = a} : foo.1 = a := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "{a : ℕ}  {h : 1 = a} : foo.1 = a",
  "args": "{a : ℕ}  {h : 1 = a}"},
 {"type": "foo.2 = a",
  "tactic-prompt": "example {a : ℤ}  {h : 2 = a} : foo.2 = a := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "{a : ℤ}  {h : 2 = a} : foo.2 = a",
  "args": "{a : ℤ}  {h : 2 = a}"},
 {"type": "foo.1 = a",
  "tactic-prompt":
  "example {a : ℕ}  {h : 1 = a} : foo.1 = a := by dsimp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp",
  "core-prompt": "{a : ℕ}  {h : 1 = a} : foo.1 = a",
  "args": "{a : ℕ}  {h : 1 = a}"},
 {"type": "foo.2 = a",
  "tactic-prompt":
  "example {a : ℤ}  {h : 2 = a} : foo.2 = a := by dsimp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp",
  "core-prompt": "{a : ℤ}  {h : 2 = a} : foo.2 = a",
  "args": "{a : ℤ}  {h : 2 = a}"},
 {"type": "(f.trans g).toFun x = z",
  "tactic-prompt":
  "example {α β γ : Type}  (f : α ≃ β)  (g : β ≃ γ)  (x : α)  {z : γ}  (h : g.toFun (f.toFun x) = z) : (f.trans g).toFun x = z := by dsimp only [Equiv'.trans_toFun]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Equiv'.trans_toFun]",
  "core-prompt":
  "{α β γ : Type}  (f : α ≃ β)  (g : β ≃ γ)  (x : α)  {z : γ}  (h : g.toFun (f.toFun x) = z) : (f.trans g).toFun x = z",
  "args":
  "{α β γ : Type}  (f : α ≃ β)  (g : β ≃ γ)  (x : α)  {z : γ}  (h : g.toFun (f.toFun x) = z)"},
 {"type": "myNatEquiv.toFun (myNatEquiv.toFun $ myNatEquiv.invFun n) = n",
  "tactic-prompt":
  "example (n : ℕ) : myNatEquiv.toFun (myNatEquiv.toFun $ myNatEquiv.invFun n) = n := by simp only [myNatEquiv_toFun]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [myNatEquiv_toFun]",
  "core-prompt":
  "(n : ℕ) : myNatEquiv.toFun (myNatEquiv.toFun $ myNatEquiv.invFun n) = n",
  "args": "(n : ℕ)"},
 {"type": "(X ⟶ X) = x",
  "tactic-prompt":
  "example (X : Type u)  {x : Type u}  (h : (X → X) = x) : (X ⟶ X) = x := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "(X : Type u)  {x : Type u}  (h : (X → X) = x) : (X ⟶ X) = x",
  "args": "(X : Type u)  {x : Type u}  (h : (X → X) = x)"},
 {"type": "𝟙 X = f",
  "tactic-prompt":
  "example (X : Type u)  {f : X → X}  (h : ∀ x, f x = x) : 𝟙 X = f := by ext; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ext",
  "core-prompt": "(X : Type u)  {f : X → X}  (h : ∀ x, f x = x) : 𝟙 X = f",
  "args": "(X : Type u)  {f : X → X}  (h : ∀ x, f x = x)"},
 {"type": "f ≫ g = k",
  "tactic-prompt":
  "example (X Y Z : Type u)  (f : X ⟶ Y)  (g : Y ⟶ Z)  {k : X → Z}  (h : ∀ x, g (f x) = k x) : f ≫ g = k := by ext; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ext",
  "core-prompt":
  "(X Y Z : Type u)  (f : X ⟶ Y)  (g : Y ⟶ Z)  {k : X → Z}  (h : ∀ x, g (f x) = k x) : f ≫ g = k",
  "args":
  "(X Y Z : Type u)  (f : X ⟶ Y)  (g : Y ⟶ Z)  {k : X → Z}  (h : ∀ x, g (f x) = k x)"},
 {"type": "foo = x",
  "tactic-prompt":
  "example {x : Type}  (h : ℕ = x) : foo = x := by simp only [foo_c]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [foo_c]",
  "core-prompt": "{x : Type}  (h : ℕ = x) : foo = x",
  "args": "{x : Type}  (h : ℕ = x)"},
 {"type": "foo.x = x",
  "tactic-prompt":
  "example {x : ℕ}  (h : (3 : ℕ) = x) : foo.x = x := by simp only [foo_x]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [foo_x]",
  "core-prompt": "{x : ℕ}  (h : (3 : ℕ) = x) : foo.x = x",
  "args": "{x : ℕ}  (h : (3 : ℕ) = x)"},
 {"type": "voo = x",
  "tactic-prompt":
  "example {x : Type}  (h : ℕ = x) : voo = x := by simp only [voo_c]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [voo_c]",
  "core-prompt": "{x : Type}  (h : ℕ = x) : voo = x",
  "args": "{x : Type}  (h : ℕ = x)"},
 {"type": "voo.x = x",
  "tactic-prompt":
  "example {x : ℕ}  (h : (3 : ℕ) = x) : voo.x = x := by simp only [voo_x]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [voo_x]",
  "core-prompt": "{x : ℕ}  (h : (3 : ℕ) = x) : voo.x = x",
  "args": "{x : ℕ}  (h : (3 : ℕ) = x)"},
 {"type": "x * - 0 ⊆ - x",
  "tactic-prompt": "example (x : ℕ) : x * - 0 ⊆ - x := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "(x : ℕ) : x * - 0 ⊆ - x",
  "args": "(x : ℕ)"},
 {"type": "x * - 0 ⊆ - x",
  "tactic-prompt": "example (x : ℕ) : x * - 0 ⊆ - x := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "(x : ℕ) : x * - 0 ⊆ - x",
  "args": "(x : ℕ)"},
 {"type": "Nat.SetPlus1.s = x",
  "tactic-prompt":
  "example {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x) : Nat.SetPlus1.s = x := by dsimp only [Nat.SetPlus1_s]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Nat.SetPlus1_s]",
  "core-prompt":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x) : Nat.SetPlus1.s = x",
  "args":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x)"},
 {"type": "Nat.SetPlus2.s = x",
  "tactic-prompt":
  "example {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x) : Nat.SetPlus2.s = x := by dsimp only [Nat.SetPlus2_s]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Nat.SetPlus2_s]",
  "core-prompt":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x) : Nat.SetPlus2.s = x",
  "args":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x)"},
 {"type": "Nat.SetPlus3.s = x",
  "tactic-prompt":
  "example {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x) : Nat.SetPlus3.s = x := by dsimp only [Nat.SetPlus3_s]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Nat.SetPlus3_s]",
  "core-prompt":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x) : Nat.SetPlus3.s = x",
  "args":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x)"},
 {"type": "(Equiv.symm2.invFun e).toFun = x",
  "tactic-prompt":
  "example {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} (e : α ≃ β)  {x : β → α}  (h : e.invFun = x) : (Equiv.symm2.invFun e).toFun = x := by dsimp only [Equiv.symm2_invFun_toFun]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Equiv.symm2_invFun_toFun]",
  "core-prompt":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} (e : α ≃ β)  {x : β → α}  (h : e.invFun = x) : (Equiv.symm2.invFun e).toFun = x",
  "args":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} (e : α ≃ β)  {x : β → α}  (h : e.invFun = x)"},
 {"type": "(foo α).symm x = z",
  "tactic-prompt":
  "example {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x z : α)  (h : x = z) : (foo α).symm x = z := by dsimp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp",
  "core-prompt":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x z : α)  (h : x = z) : (foo α).symm x = z",
  "args":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x z : α)  (h : x = z)"},
 {"type": "(foo2 α).toEquiv' x = z",
  "tactic-prompt":
  "example {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x z : α)  (h : foo.rfl x = z) : (foo2 α).toEquiv' x = z := by dsimp only [foo2_toEquiv']; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [foo2_toEquiv']",
  "core-prompt":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x z : α)  (h : foo.rfl x = z) : (foo2 α).toEquiv' x = z",
  "args":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x z : α)  (h : foo.rfl x = z)"},
 {"type": "(foo2 α).toEquiv' x = z",
  "tactic-prompt":
  "example {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x z : α)  (h : x = z) : (foo2 α).toEquiv' x = z := by dsimp only [foo2_apply]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [foo2_apply]",
  "core-prompt":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x z : α)  (h : x = z) : (foo2 α).toEquiv' x = z",
  "args":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x z : α)  (h : x = z)"},
 {"type": "foo2 α x = z",
  "tactic-prompt":
  "example {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x z : α)  (h : x = z) : foo2 α x = z := by dsimp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp",
  "core-prompt":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x z : α)  (h : x = z) : foo2 α x = z",
  "args":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x z : α)  (h : x = z)"},
 {"type": "(ffoo α).symm x = z",
  "tactic-prompt":
  "example {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x z : α)  (h : x = z) : (ffoo α).symm x = z := by dsimp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp",
  "core-prompt":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x z : α)  (h : x = z) : (ffoo α).symm x = z",
  "args":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x z : α)  (h : x = z)"},
 {"type": "(fffoo α).symm x = x",
  "tactic-prompt":
  "example {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x : α) : (fffoo α).symm x = x := by dsimp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp",
  "core-prompt":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x : α) : (fffoo α).symm x = x",
  "args":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _}  {α : Type}  (x : α)"},
 {"type": "Inhabited p",
  "tactic-prompt":
  "example {p : Prop}  [Nonempty p] : Inhabited p := by inhabit p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit p",
  "core-prompt": "{p : Prop}  [Nonempty p] : Inhabited p",
  "args": "{p : Prop}  [Nonempty p]"},
 {"type": "Inhabited α",
  "tactic-prompt":
  "example {α : Type}  [Nonempty α] : Inhabited α := by inhabit α; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit α",
  "core-prompt": "{α : Type}  [Nonempty α] : Inhabited α",
  "args": "{α : Type}  [Nonempty α]"},
 {"type": "Inhabited α",
  "tactic-prompt":
  "example {α : Type 3}  [Nonempty α] : Inhabited α := by inhabit α; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit α",
  "core-prompt": "{α : Type 3}  [Nonempty α] : Inhabited α",
  "args": "{α : Type 3}  [Nonempty α]"},
 {"type": "Nonempty α → Inhabited α",
  "tactic-prompt":
  "example {α : Type} : Nonempty α → Inhabited α := by intro nonempty_α; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro nonempty_α",
  "core-prompt": "{α : Type} : Nonempty α → Inhabited α",
  "args": "{α : Type}"},
 {"type": "Inhabited p",
  "tactic-prompt":
  "example {p : Prop}  [Nonempty p] : Inhabited p := by inhabit p_inhabited : p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit p_inhabited : p",
  "core-prompt": "{p : Prop}  [Nonempty p] : Inhabited p",
  "args": "{p : Prop}  [Nonempty p]"},
 {"type": "Unique α",
  "tactic-prompt":
  "example {α : Sort u}  [Subsingleton α]  [Nonempty α] : Unique α := by inhabit α; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit α",
  "core-prompt": "{α : Sort u}  [Subsingleton α]  [Nonempty α] : Unique α",
  "args": "{α : Sort u}  [Subsingleton α]  [Nonempty α]"},
 {"type": "Inhabited α",
  "tactic-prompt": "example  : Inhabited α := by inhabit α; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit α",
  "core-prompt": " : Inhabited α",
  "args": ""},
 {"type": "a = (a + 0)",
  "tactic-prompt":
  "example [AddZeroClass G]  {a : G}  (h : a = a) : a = (a + 0) := by nth_rewrite 2 [←add_zero a] at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nth_rewrite 2 [←add_zero a] at h",
  "core-prompt": "[AddZeroClass G]  {a : G}  (h : a = a) : a = (a + 0)",
  "args": "[AddZeroClass G]  {a : G}  (h : a = a)"},
 {"type": "a + a = a + (a + 0)",
  "tactic-prompt":
  "example [AddZeroClass G]  {a : G} : a + a = a + (a + 0) := by nth_rw 2 [←add_zero a]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nth_rw 2 [←add_zero a]",
  "core-prompt": "[AddZeroClass G]  {a : G} : a + a = a + (a + 0)",
  "args": "[AddZeroClass G]  {a : G}"},
 {"type": "True",
  "tactic-prompt": "example  : True := by type_check Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "type_check Nat",
  "core-prompt": " : True",
  "args": ""},
 {"type": "(an : ℤ) = bn → an = bn",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) = bn → an = bn := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) = bn → an = bn",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "an = bn → (an : ℤ) = bn",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : an = bn → (an : ℤ) = bn := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : an = bn → (an : ℤ) = bn",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "(an : ℤ) < bn ↔ an < bn",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) < bn ↔ an < bn := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) < bn ↔ an < bn",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "(an : ℤ) ≠ (bn : ℤ) ↔ an ≠ bn",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) ≠ (bn : ℤ) ↔ an ≠ bn := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) ≠ (bn : ℤ) ↔ an ≠ bn",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "az > (1 : ℕ) ↔ az > 1",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : az > (1 : ℕ) ↔ az > 1 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : az > (1 : ℕ) ↔ az > 1",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "az > (0 : ℕ) ↔ az > 0",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : az > (0 : ℕ) ↔ az > 0 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : az > (0 : ℕ) ↔ az > 0",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "(an : ℤ) ≠ 0 ↔ an ≠ 0",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) ≠ 0 ↔ an ≠ 0 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) ≠ 0 ↔ an ≠ 0",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "(an : ℤ) + bn = (an + bn : ℕ)",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) + bn = (an + bn : ℕ) := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) + bn = (an + bn : ℕ)",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "True",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h : ((an + bn : ℕ) : ℤ) = (an : ℤ) + (bn : ℤ)) : True := by push_cast at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_cast at h",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h : ((an + bn : ℕ) : ℤ) = (an : ℤ) + (bn : ℤ)) : True",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h : ((an + bn : ℕ) : ℤ) = (an : ℤ) + (bn : ℤ))"},
 {"type": "True",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h : ((an * bn : ℕ) : ℤ) = (an : ℤ) * (bn : ℤ)) : True := by push_cast at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_cast at h",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h : ((an * bn : ℕ) : ℤ) = (an : ℤ) * (bn : ℤ)) : True",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h : ((an * bn : ℕ) : ℤ) = (an : ℤ) * (bn : ℤ))"},
 {"type": "((42 : ℕ) : ℤ) = 42",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : ((42 : ℕ) : ℤ) = 42 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : ((42 : ℕ) : ℤ) = 42",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "p 42",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : p 42 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : p 42",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "an - bn = 1 ↔ (an - bn : ℤ) = 1",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h : bn ≤ an) : an - bn = 1 ↔ (an - bn : ℤ) = 1 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h : bn ≤ an) : an - bn = 1 ↔ (an - bn : ℤ) = 1",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h : bn ≤ an)"},
 {"type": "x * y = 1",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) [Mul α]  [One α]  (x y : α)  (h : (x : WithZero α) * y = 1) : x * y = 1 := by exact_mod_cast h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "exact_mod_cast h",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) [Mul α]  [One α]  (x y : α)  (h : (x : WithZero α) * y = 1) : x * y = 1",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) [Mul α]  [One α]  (x y : α)  (h : (x : WithZero α) * y = 1)"},
 {"type":
  "(x * x + y * y : ℤ) - ↑((x * y + 1) * k) = ↑y * ↑y - ↑k * ↑x * ↑y + (↑x * ↑x - ↑k)",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (k : ℕ)  {x y : ℕ} : (x * x + y * y : ℤ) - ↑((x * y + 1) * k) = ↑y * ↑y - ↑k * ↑x * ↑y + (↑x * ↑x - ↑k) := by push_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (k : ℕ)  {x y : ℕ} : (x * x + y * y : ℤ) - ↑((x * y + 1) * k) = ↑y * ↑y - ↑k * ↑x * ↑y + (↑x * ↑x - ↑k)",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (k : ℕ)  {x y : ℕ}"},
 {"type": "x + y + k = 0",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (k : ℕ)  {x y : ℕ}  (h : ((x + y + k : ℕ) : ℤ) = 0) : x + y + k = 0 := by push_cast at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_cast at h",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (k : ℕ)  {x y : ℕ}  (h : ((x + y + k : ℕ) : ℤ) = 0) : x + y + k = 0",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (k : ℕ)  {x y : ℕ}  (h : ((x + y + k : ℕ) : ℤ) = 0)"},
 {"type": "((a + b : ℕ) : ℤ) = 10",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (a b : ℕ)  (h2 : ((a + b + 0 : ℕ) : ℤ) = 10) : ((a + b : ℕ) : ℤ) = 10 := by push_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (a b : ℕ)  (h2 : ((a + b + 0 : ℕ) : ℤ) = 10) : ((a + b : ℕ) : ℤ) = 10",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (a b : ℕ)  (h2 : ((a + b + 0 : ℕ) : ℤ) = 10)"},
 {"type": "true ∧ true",
  "tactic-prompt":
  "lemma (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h g : true) : true ∧ true := by constructor; sorry",
  "name": "b",
  "kind": "lemma",
  "first-tactic": "constructor",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h g : true) : true ∧ true",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h g : true)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : α × β × γ) : True := by cases' x with a b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' x with a b",
  "core-prompt": "(x : α × β × γ) : True",
  "args": "(x : α × β × γ)"},
 {"type": "True",
  "tactic-prompt":
  "example {α β γ : Type u}  (x : α × β × γ) : True := by cases' h: x with a b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' h: x with a b",
  "core-prompt": "{α β γ : Type u}  (x : α × β × γ) : True",
  "args": "{α β γ : Type u}  (x : α × β × γ)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : ℕ) : True := by cases' h: x using my_rec with y; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' h: x using my_rec with y",
  "core-prompt": "(x : ℕ) : True",
  "args": "(x : ℕ)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : Foo α β) : True := by cases' x with a₀ a₁ _ a₂ b₂ c₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' x with a₀ a₁ _ a₂ b₂ c₂",
  "core-prompt": "(x : Foo α β) : True",
  "args": "(x : Foo α β)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : Bar 0) : True := by cases' x with a b c d h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' x with a b c d h",
  "core-prompt": "(x : Bar 0) : True",
  "args": "(x : Bar 0)"},
 {"type": "n = n",
  "tactic-prompt":
  "example (n : Nat) : n = n := by induction' n with n ih; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction' n with n ih",
  "core-prompt": "(n : Nat) : n = n",
  "args": "(n : Nat)"},
 {"type": "n = n",
  "tactic-prompt":
  "example (n : Nat)  (h : n < 5) : n = n := by induction' n with n ih; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction' n with n ih",
  "core-prompt": "(n : Nat)  (h : n < 5) : n = n",
  "args": "(n : Nat)  (h : n < 5)"},
 {"type": "n = n",
  "tactic-prompt":
  "example (n : Nat) : n = n := by induction' e : n with m ih; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction' e : n with m ih",
  "core-prompt": "(n : Nat) : n = n",
  "args": "(n : Nat)"},
 {"type": "n = n",
  "tactic-prompt":
  "example (n : Nat) : n = n := by induction' e : n using my_rec with m ih; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction' e : n using my_rec with m ih",
  "core-prompt": "(n : Nat) : n = n",
  "args": "(n : Nat)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : Foo α Nat) : True := by induction' x with a a' b' a'' b'' c'' ih; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction' x with a a' b' a'' b'' c'' ih",
  "core-prompt": "(x : Foo α Nat) : True",
  "args": "(x : Foo α Nat)"},
 {"type": "x = x",
  "tactic-prompt":
  "example (x : Bar n) : x = x := by induction' x with a b c d h ih; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction' x with a b c d h ih",
  "core-prompt": "(x : Bar n) : x = x",
  "args": "(x : Bar n)"},
 {"type": "3 < 4",
  "tactic-prompt": "example  : 3 < 4 := by recover decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "recover decide",
  "core-prompt": " : 3 < 4",
  "args": ""},
 {"type": "1 = 1",
  "tactic-prompt": "example  : 1 = 1 := by recover skip ; rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "recover skip ; rfl",
  "core-prompt": " : 1 = 1",
  "args": ""},
 {"type": "2 = 2",
  "tactic-prompt": "example  : 2 = 2 := by recover skip; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "recover skip",
  "core-prompt": " : 2 = 2",
  "args": ""},
 {"type": "p ∧ p",
  "tactic-prompt":
  "example (p q r : Prop) (h : p ∧ q ∨ p ∧ r) : p ∧ p := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q r : Prop) (h : p ∧ q ∨ p ∧ r) : p ∧ p",
  "args": "(p q r : Prop) (h : p ∧ q ∨ p ∧ r)"},
 {"type": "∃ x, p x",
  "tactic-prompt":
  "example (α : Type) (p q r : α → Prop) (h : (∃ x, p x ∧ q x) ∨ (∃ x, p x ∧ r x)) : ∃ x, p x := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt":
  "(α : Type) (p q r : α → Prop) (h : (∃ x, p x ∧ q x) ∨ (∃ x, p x ∧ r x)) : ∃ x, p x",
  "args":
  "(α : Type) (p q r : α → Prop) (h : (∃ x, p x ∧ q x) ∨ (∃ x, p x ∧ r x))"},
 {"type": "∃ x, r x",
  "tactic-prompt":
  "example (α : Type) (x : α) (p q r : α → Prop) (h₀ : (∀ x, p x → q x → r x) ∨ r x) (h₁ : p x) (h₂ : q x) : ∃ x, r x := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt":
  "(α : Type) (x : α) (p q r : α → Prop) (h₀ : (∀ x, p x → q x → r x) ∨ r x) (h₁ : p x) (h₂ : q x) : ∃ x, r x",
  "args":
  "(α : Type) (x : α) (p q r : α → Prop) (h₀ : (∀ x, p x → q x → r x) ∨ r x) (h₁ : p x) (h₂ : q x)"},
 {"type": "p ∧ True ↔ p",
  "tactic-prompt": "example (p : Prop) : p ∧ True ↔ p := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p : Prop) : p ∧ True ↔ p",
  "args": "(p : Prop)"},
 {"type": "p ∨ False ↔ p",
  "tactic-prompt": "example (p : Prop) : p ∨ False ↔ p := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p : Prop) : p ∨ False ↔ p",
  "args": "(p : Prop)"},
 {"type": "¬ p ↔ q",
  "tactic-prompt":
  "example (p q : Prop)  (h : p ≠ q) : ¬ p ↔ q := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q : Prop)  (h : p ≠ q) : ¬ p ↔ q",
  "args": "(p q : Prop)  (h : p ≠ q)"},
 {"type": "¬ p ↔ q",
  "tactic-prompt":
  "example (p q : Prop)  (h : ¬ p = q) : ¬ p ↔ q := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q : Prop)  (h : ¬ p = q) : ¬ p ↔ q",
  "args": "(p q : Prop)  (h : ¬ p = q)"},
 {"type": "p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (r ∨ p ∨ r)",
  "tactic-prompt":
  "example (p q r : Prop) : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (r ∨ p ∨ r) := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q r : Prop) : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (r ∨ p ∨ r)",
  "args": "(p q r : Prop)"},
 {"type": "p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (r ∨ p ∨ r)",
  "tactic-prompt":
  "example (p q r : Prop) : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (r ∨ p ∨ r) := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q r : Prop) : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (r ∨ p ∨ r)",
  "args": "(p q r : Prop)"},
 {"type": "q",
  "tactic-prompt":
  "example (p q : Prop)  (h : ¬ (p ↔ q))  (h' : ¬ p) : q := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q : Prop)  (h : ¬ (p ↔ q))  (h' : ¬ p) : q",
  "args": "(p q : Prop)  (h : ¬ (p ↔ q))  (h' : ¬ p)"},
 {"type": "¬ q",
  "tactic-prompt":
  "example (p q : Prop)  (h : ¬ (p ↔ q))  (h' : p) : ¬ q := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q : Prop)  (h : ¬ (p ↔ q))  (h' : p) : ¬ q",
  "args": "(p q : Prop)  (h : ¬ (p ↔ q))  (h' : p)"},
 {"type": "¬ p",
  "tactic-prompt":
  "example (p q : Prop)  (h : ¬ (p ↔ q))  (h' : q) : ¬ p := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q : Prop)  (h : ¬ (p ↔ q))  (h' : q) : ¬ p",
  "args": "(p q : Prop)  (h : ¬ (p ↔ q))  (h' : q)"},
 {"type": "p",
  "tactic-prompt":
  "example (p q : Prop)  (h : ¬ (p ↔ q))  (h' : ¬ q) : p := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q : Prop)  (h : ¬ (p ↔ q))  (h' : ¬ q) : p",
  "args": "(p q : Prop)  (h : ¬ (p ↔ q))  (h' : ¬ q)"},
 {"type": "False",
  "tactic-prompt":
  "example (p q : Prop)  (h : ¬ (p ↔ q))  (h' : ¬ q)  (h'' : ¬ p) : False := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt":
  "(p q : Prop)  (h : ¬ (p ↔ q))  (h' : ¬ q)  (h'' : ¬ p) : False",
  "args": "(p q : Prop)  (h : ¬ (p ↔ q))  (h' : ¬ q)  (h'' : ¬ p)"},
 {"type": "¬ p",
  "tactic-prompt":
  "example (p q r : Prop)  (h : p ↔ q)  (h' : r ↔ q)  (h'' : ¬ r) : ¬ p := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q r : Prop)  (h : p ↔ q)  (h' : r ↔ q)  (h'' : ¬ r) : ¬ p",
  "args": "(p q r : Prop)  (h : p ↔ q)  (h' : r ↔ q)  (h'' : ¬ r)"},
 {"type": "p ↔ r",
  "tactic-prompt":
  "example (p q r : Prop)  (h : p ↔ q)  (h' : r ↔ q) : p ↔ r := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q r : Prop)  (h : p ↔ q)  (h' : r ↔ q) : p ↔ r",
  "args": "(p q r : Prop)  (h : p ↔ q)  (h' : r ↔ q)"},
 {"type": "p ↔ ¬ r",
  "tactic-prompt":
  "example (p q r : Prop)  (h : ¬ p = q)  (h' : r = q) : p ↔ ¬ r := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q r : Prop)  (h : ¬ p = q)  (h' : r = q) : p ↔ ¬ r",
  "args": "(p q r : Prop)  (h : ¬ p = q)  (h' : r = q)"},
 {"type": "p → ¬ (p → ¬ p)",
  "tactic-prompt": "example (p : Prop) : p → ¬ (p → ¬ p) := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p : Prop) : p → ¬ (p → ¬ p)",
  "args": "(p : Prop)"},
 {"type": "¬ (p ↔ ¬ p)",
  "tactic-prompt":
  "example (p : Prop)  (em : p ∨ ¬ p) : ¬ (p ↔ ¬ p) := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p : Prop)  (em : p ∨ ¬ p) : ¬ (p ↔ ¬ p)",
  "args": "(p : Prop)  (em : p ∨ ¬ p)"},
 {"type": "P n → n = 7 ∨ n = 0 ∨ ¬ (n = 7 ∨ n = 0) ∧ P n",
  "tactic-prompt":
  "example (P : Nat → Prop)  (n : Nat) : P n → n = 7 ∨ n = 0 ∨ ¬ (n = 7 ∨ n = 0) ∧ P n := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt":
  "(P : Nat → Prop)  (n : Nat) : P n → n = 7 ∨ n = 0 ∨ ¬ (n = 7 ∨ n = 0) ∧ P n",
  "args": "(P : Nat → Prop)  (n : Nat)"},
 {"type": "x = y",
  "tactic-prompt":
  "example {x y : Nat}  (h : ¬x ≠ y) : x = y := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "{x y : Nat}  (h : ¬x ≠ y) : x = y",
  "args": "{x y : Nat}  (h : ¬x ≠ y)"},
 {"type": "3 * x + 2 * y = 10",
  "tactic-prompt":
  "example (x y : ℤ)  (h1 : 3 * x + 2 * y = 10) : 3 * x + 2 * y = 10 := by linear_combination 1 * h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 1 * h1",
  "core-prompt": "(x y : ℤ)  (h1 : 3 * x + 2 * y = 10) : 3 * x + 2 * y = 10",
  "args": "(x y : ℤ)  (h1 : 3 * x + 2 * y = 10)"},
 {"type": "3 * x + 2 * y = 10",
  "tactic-prompt":
  "example (x y : ℤ)  (h1 : 3 * x + 2 * y = 10) : 3 * x + 2 * y = 10 := by linear_combination h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination h1",
  "core-prompt": "(x y : ℤ)  (h1 : 3 * x + 2 * y = 10) : 3 * x + 2 * y = 10",
  "args": "(x y : ℤ)  (h1 : 3 * x + 2 * y = 10)"},
 {"type": "2 * x + 4 = -6",
  "tactic-prompt":
  "example (x y : ℤ)  (h1 : x + 2 = -3)  (_h2 : y = 10) : 2 * x + 4 = -6 := by linear_combination 2 * h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h1",
  "core-prompt":
  "(x y : ℤ)  (h1 : x + 2 = -3)  (_h2 : y = 10) : 2 * x + 4 = -6",
  "args": "(x y : ℤ)  (h1 : x + 2 = -3)  (_h2 : y = 10)"},
 {"type": "x * y = -2 * y + 1",
  "tactic-prompt":
  "example (x y : ℤ)  (h1 : x * y + 2 * x = 1)  (h2 : x = y) : x * y = -2 * y + 1 := by linear_combination 1 * h1 - 2 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 1 * h1 - 2 * h2",
  "core-prompt":
  "(x y : ℤ)  (h1 : x * y + 2 * x = 1)  (h2 : x = y) : x * y = -2 * y + 1",
  "args": "(x y : ℤ)  (h1 : x * y + 2 * x = 1)  (h2 : x = y)"},
 {"type": "x * y = -2 * y + 1",
  "tactic-prompt":
  "example (x y : ℤ)  (h1 : x * y + 2 * x = 1)  (h2 : x = y) : x * y = -2 * y + 1 := by linear_combination -2 * h2 + h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination -2 * h2 + h1",
  "core-prompt":
  "(x y : ℤ)  (h1 : x * y + 2 * x = 1)  (h2 : x = y) : x * y = -2 * y + 1",
  "args": "(x y : ℤ)  (h1 : x * y + 2 * x = 1)  (h2 : x = y)"},
 {"type": "2 * x + 4 - y = -16",
  "tactic-prompt":
  "example (x y : ℤ)  (h1 : x + 2 = -3)  (h2 : y = 10) : 2 * x + 4 - y = -16 := by linear_combination 2 * h1 + -1 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h1 + -1 * h2",
  "core-prompt":
  "(x y : ℤ)  (h1 : x + 2 = -3)  (h2 : y = 10) : 2 * x + 4 - y = -16",
  "args": "(x y : ℤ)  (h1 : x + 2 = -3)  (h2 : y = 10)"},
 {"type": "-y + 2 * x + 4 = -16",
  "tactic-prompt":
  "example (x y : ℤ)  (h1 : x + 2 = -3)  (h2 : y = 10) : -y + 2 * x + 4 = -16 := by linear_combination -h2 + 2 * h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination -h2 + 2 * h1",
  "core-prompt":
  "(x y : ℤ)  (h1 : x + 2 = -3)  (h2 : y = 10) : -y + 2 * x + 4 = -16",
  "args": "(x y : ℤ)  (h1 : x + 2 = -3)  (h2 : y = 10)"},
 {"type": "11 * y = -11",
  "tactic-prompt":
  "example (x y : ℤ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : 11 * y = -11 := by linear_combination -2 * h1 + 3 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination -2 * h1 + 3 * h2",
  "core-prompt":
  "(x y : ℤ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : 11 * y = -11",
  "args": "(x y : ℤ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3)"},
 {"type": "-11 * y = 11",
  "tactic-prompt":
  "example (x y : ℤ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y = 11 := by linear_combination 2 * h1 - 3 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h1 - 3 * h2",
  "core-prompt":
  "(x y : ℤ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y = 11",
  "args": "(x y : ℤ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3)"},
 {"type": "-11 * y = 11 + 1 - 1",
  "tactic-prompt":
  "example (x y : ℤ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y = 11 + 1 - 1 := by linear_combination 2 * h1 + -3 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h1 + -3 * h2",
  "core-prompt":
  "(x y : ℤ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y = 11 + 1 - 1",
  "args": "(x y : ℤ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3)"},
 {"type": "11 + 1 - 1 = -11 * y",
  "tactic-prompt":
  "example (x y : ℤ)  (h1 : 10 = 3 * x + 2 * y)  (h2 : 3 = 2 * x + 5 * y) : 11 + 1 - 1 = -11 * y := by linear_combination 2 * h1 - 3 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h1 - 3 * h2",
  "core-prompt":
  "(x y : ℤ)  (h1 : 10 = 3 * x + 2 * y)  (h2 : 3 = 2 * x + 5 * y) : 11 + 1 - 1 = -11 * y",
  "args": "(x y : ℤ)  (h1 : 10 = 3 * x + 2 * y)  (h2 : 3 = 2 * x + 5 * y)"},
 {"type": "-y + 2 * x + 4 = -16",
  "tactic-prompt":
  "example (x y : ℤ)  (h1 : x + 2 = -3)  (h2 : y = 10) : -y + 2 * x + 4 = -16 := by linear_combination 2 * h1 - h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h1 - h2",
  "core-prompt":
  "(x y : ℤ)  (h1 : x + 2 = -3)  (h2 : y = 10) : -y + 2 * x + 4 = -16",
  "args": "(x y : ℤ)  (h1 : x + 2 = -3)  (h2 : y = 10)"},
 {"type": "-11 * y + 1 = 11 + 1",
  "tactic-prompt":
  "example (x y : ℚ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y + 1 = 11 + 1 := by linear_combination 2 * h1 - 3 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h1 - 3 * h2",
  "core-prompt":
  "(x y : ℚ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y + 1 = 11 + 1",
  "args": "(x y : ℚ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3)"},
 {"type": "-3 * x - 3 * y - 4 * z = 2",
  "tactic-prompt":
  "example (x y z : ℝ)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2) : -3 * x - 3 * y - 4 * z = 2 := by linear_combination ha - hb - 2 * hc; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination ha - hb - 2 * hc",
  "core-prompt":
  "(x y z : ℝ)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2) : -3 * x - 3 * y - 4 * z = 2",
  "args":
  "(x y z : ℝ)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2)"},
 {"type": "6 * x = -10",
  "tactic-prompt":
  "example (x y z : ℝ)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2) : 6 * x = -10 := by linear_combination 1 * ha + 4 * hb - 3 * hc; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 1 * ha + 4 * hb - 3 * hc",
  "core-prompt":
  "(x y z : ℝ)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2) : 6 * x = -10",
  "args":
  "(x y z : ℝ)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2)"},
 {"type": "10 = 6 * -x",
  "tactic-prompt":
  "example (x y z : ℝ)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2) : 10 = 6 * -x := by linear_combination ha + 4 * hb - 3 * hc; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination ha + 4 * hb - 3 * hc",
  "core-prompt":
  "(x y z : ℝ)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2) : 10 = 6 * -x",
  "args":
  "(x y z : ℝ)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2)"},
 {"type": "2 * a - 3 + 9 * c + 3 * d = 8 - b + 3 * d - 3 * a",
  "tactic-prompt":
  "example (a b c d : ℚ)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a) : 2 * a - 3 + 9 * c + 3 * d = 8 - b + 3 * d - 3 * a := by linear_combination 2 * h1 - 1 * h2 + 3 * h3 - 3 * h4; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h1 - 1 * h2 + 3 * h3 - 3 * h4",
  "core-prompt":
  "(a b c d : ℚ)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a) : 2 * a - 3 + 9 * c + 3 * d = 8 - b + 3 * d - 3 * a",
  "args":
  "(a b c d : ℚ)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a)"},
 {"type": "6 - 3 * c + 3 * a + 3 * d = 2 * b - d + 12 - 3 * a",
  "tactic-prompt":
  "example (a b c d : ℚ)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a) : 6 - 3 * c + 3 * a + 3 * d = 2 * b - d + 12 - 3 * a := by linear_combination 2 * h2 - h3 + 3 * h1 - 3 * h4; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h2 - h3 + 3 * h1 - 3 * h4",
  "core-prompt":
  "(a b c d : ℚ)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a) : 6 - 3 * c + 3 * a + 3 * d = 2 * b - d + 12 - 3 * a",
  "args":
  "(a b c d : ℚ)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a)"},
 {"type": "3 * a + qc = 3 * b + 2 * qc",
  "tactic-prompt":
  "example (a b : ℚ)  (h : ∀ p q : ℚ, p = q) : 3 * a + qc = 3 * b + 2 * qc := by linear_combination 3 * h a b + hqc; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 3 * h a b + hqc",
  "core-prompt":
  "(a b : ℚ)  (h : ∀ p q : ℚ, p = q) : 3 * a + qc = 3 * b + 2 * qc",
  "args": "(a b : ℚ)  (h : ∀ p q : ℚ, p = q)"},
 {"type": "a + b ^ 3 = 0",
  "tactic-prompt":
  "example (a b : ℚ) : a + b ^ 3 = 0 := by linear_combination bad a + b * bad (b * b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination bad a + b * bad (b * b)",
  "core-prompt": "(a b : ℚ) : a + b ^ 3 = 0",
  "args": "(a b : ℚ)"},
 {"type": "a * a = a * b",
  "tactic-prompt":
  "example (a b : ℤ)  (h : a = b) : a * a = a * b := by linear_combination a * h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination a * h",
  "core-prompt": "(a b : ℤ)  (h : a = b) : a * a = a * b",
  "args": "(a b : ℤ)  (h : a = b)"},
 {"type": "a * c = b * c",
  "tactic-prompt":
  "example (a b c : ℤ)  (h : a = b) : a * c = b * c := by linear_combination c * h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination c * h",
  "core-prompt": "(a b c : ℤ)  (h : a = b) : a * c = b * c",
  "args": "(a b c : ℤ)  (h : a = b)"},
 {"type": "c * a + b = c * b + 1",
  "tactic-prompt":
  "example (a b c : ℤ)  (h1 : a = b)  (h2 : b = 1) : c * a + b = c * b + 1 := by linear_combination c * h1 + h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination c * h1 + h2",
  "core-prompt":
  "(a b c : ℤ)  (h1 : a = b)  (h2 : b = 1) : c * a + b = c * b + 1",
  "args": "(a b c : ℤ)  (h1 : a = b)  (h2 : b = 1)"},
 {"type": "x * x * y + y * x * y + 6 * x = 3 * x * y + 14",
  "tactic-prompt":
  "example (x y : ℚ)  (h1 : x + y = 3)  (h2 : 3 * x = 7) : x * x * y + y * x * y + 6 * x = 3 * x * y + 14 := by linear_combination x * y * h1 + 2 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination x * y * h1 + 2 * h2",
  "core-prompt":
  "(x y : ℚ)  (h1 : x + y = 3)  (h2 : 3 * x = 7) : x * x * y + y * x * y + 6 * x = 3 * x * y + 14",
  "args": "(x y : ℚ)  (h1 : x + y = 3)  (h2 : 3 * x = 7)"},
 {"type": "x * z + 2 * y * z = x * w + 2 * y * w",
  "tactic-prompt":
  "example (x y z w : ℚ)  (hzw : z = w) : x * z + 2 * y * z = x * w + 2 * y * w := by linear_combination (x + 2 * y) * hzw; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (x + 2 * y) * hzw",
  "core-prompt":
  "(x y z w : ℚ)  (hzw : z = w) : x * z + 2 * y * z = x * w + 2 * y * w",
  "args": "(x y z w : ℚ)  (hzw : z = w)"},
 {"type": "-11 * y + 1 = 11 + 1",
  "tactic-prompt":
  "example (x y : ℚ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y + 1 = 11 + 1 := by linear_combination (norm := ring) 2 * h1 - 3 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := ring) 2 * h1 - 3 * h2",
  "core-prompt":
  "(x y : ℚ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y + 1 = 11 + 1",
  "args": "(x y : ℚ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3)"},
 {"type": "-11 * y + 1 = 11 + 1",
  "tactic-prompt":
  "example (x y : ℚ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y + 1 = 11 + 1 := by linear_combination (norm := ring1) 2 * h1 + -3 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := ring1) 2 * h1 + -3 * h2",
  "core-prompt":
  "(x y : ℚ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y + 1 = 11 + 1",
  "args": "(x y : ℚ)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3)"},
 {"type": "3 * x + 2 * y = 10",
  "tactic-prompt":
  "example (x y : ℤ)  (h1 : 3 * x + 2 * y = 10) : 3 * x + 2 * y = 10 := by linear_combination (norm := simp) h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := simp) h1",
  "core-prompt": "(x y : ℤ)  (h1 : 3 * x + 2 * y = 10) : 3 * x + 2 * y = 10",
  "args": "(x y : ℤ)  (h1 : 3 * x + 2 * y = 10)"},
 {"type": "2 * x = -6",
  "tactic-prompt":
  "example (x y : ℤ)  (h1 : x = -3)  (_h2 : y = 10) : 2 * x = -6 := by linear_combination (norm := skip) 2 * h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := skip) 2 * h1",
  "core-prompt": "(x y : ℤ)  (h1 : x = -3)  (_h2 : y = 10) : 2 * x = -6",
  "args": "(x y : ℤ)  (h1 : x = -3)  (_h2 : y = 10)"},
 {"type": "z + w = w + z",
  "tactic-prompt":
  "example {x y z w : ℤ}  (_h₁ : 3 * x = 4 + y)  (_h₂ : x + 2 * y = 1) : z + w = w + z := by linear_combination; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination",
  "core-prompt":
  "{x y z w : ℤ}  (_h₁ : 3 * x = 4 + y)  (_h₂ : x + 2 * y = 1) : z + w = w + z",
  "args": "{x y z w : ℤ}  (_h₁ : 3 * x = 4 + y)  (_h₂ : x + 2 * y = 1)"},
 {"type": "z + w = w + z",
  "tactic-prompt":
  "example {x y z w : ℤ}  (_h₁ : 3 * x = 4 + y)  (_h₂ : x + 2 * y = 1) : z + w = w + z := by linear_combination (norm := skip); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := skip)",
  "core-prompt":
  "{x y z w : ℤ}  (_h₁ : 3 * x = 4 + y)  (_h₂ : x + 2 * y = 1) : z + w = w + z",
  "args": "{x y z w : ℤ}  (_h₁ : 3 * x = 4 + y)  (_h₂ : x + 2 * y = 1)"},
 {"type": "z + w = w + z",
  "tactic-prompt":
  "example {x y z w : ℤ}  (_h₁ : 3 * x = 4 + y)  (_h₂ : x + 2 * y = 1) : z + w = w + z := by linear_combination (norm := simp [add_comm]); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := simp [add_comm])",
  "core-prompt":
  "{x y z w : ℤ}  (_h₁ : 3 * x = 4 + y)  (_h₂ : x + 2 * y = 1) : z + w = w + z",
  "args": "{x y z w : ℤ}  (_h₁ : 3 * x = 4 + y)  (_h₂ : x + 2 * y = 1)"},
 {"type": "x * x * y + y * x * y + 6 * x = 3 * x * y + 14",
  "tactic-prompt":
  "example (x y : ℚ)  (h1 : x + y = 3)  (h2 : 3 * x = 7) : x * x * y + y * x * y + 6 * x = 3 * x * y + 14 := by linear_combination (norm := ring_nf) x * y * h1 + h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := ring_nf) x * y * h1 + h2",
  "core-prompt":
  "(x y : ℚ)  (h1 : x + y = 3)  (h2 : 3 * x = 7) : x * x * y + y * x * y + 6 * x = 3 * x * y + 14",
  "args": "(x y : ℚ)  (h1 : x + y = 3)  (h2 : 3 * x = 7)"},
 {"type": "6 - 3 * c + 3 * a + 3 * d = 2 * b - d + 12 - 3 * a",
  "tactic-prompt":
  "example (a b c d : ℚ)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a) : 6 - 3 * c + 3 * a + 3 * d = 2 * b - d + 12 - 3 * a := by linear_combination (norm := ring_nf) 2 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := ring_nf) 2 * h2",
  "core-prompt":
  "(a b c d : ℚ)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a) : 6 - 3 * c + 3 * a + 3 * d = 2 * b - d + 12 - 3 * a",
  "args":
  "(a b c d : ℚ)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a)"},
 {"type": "x * y = -2 * y + 1",
  "tactic-prompt":
  "example (x y : ℤ)  (h1 : x * y + 2 * x = 1)  (h2 : x = y) : x * y = -2 * y + 1 := by linear_combination (norm := ring_nf); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := ring_nf)",
  "core-prompt":
  "(x y : ℤ)  (h1 : x * y + 2 * x = 1)  (h2 : x = y) : x * y = -2 * y + 1",
  "args": "(x y : ℤ)  (h1 : x * y + 2 * x = 1)  (h2 : x = y)"},
 {"type": "x * y + 2 * x = 1",
  "tactic-prompt":
  "example (x y : ℤ)  (h1 : x * y + 2 * x = 1)  (h2 : x = y) : x * y + 2 * x = 1 := by fail_if_success linear_combination h1 + (0 : ℝ) * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success linear_combination h1 + (0 : ℝ) * h2",
  "core-prompt":
  "(x y : ℤ)  (h1 : x * y + 2 * x = 1)  (h2 : x = y) : x * y + 2 * x = 1",
  "args": "(x y : ℤ)  (h1 : x * y + 2 * x = 1)  (h2 : x = y)"},
 {"type": "a = 3",
  "tactic-prompt":
  "example (a _b : ℕ)  (h1 : a = 3) : a = 3 := by fail_if_success linear_combination h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success linear_combination h1",
  "core-prompt": "(a _b : ℕ)  (h1 : a = 3) : a = 3",
  "args": "(a _b : ℕ)  (h1 : a = 3)"},
 {"type": "2 * x = 2 * y",
  "tactic-prompt":
  "example (a b : ℤ)  (x y : ℝ)  (hab : a = b)  (hxy : x = y) : 2 * x = 2 * y := by fail_if_success linear_combination 2 * hab; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success linear_combination 2 * hab",
  "core-prompt":
  "(a b : ℤ)  (x y : ℝ)  (hab : a = b)  (hxy : x = y) : 2 * x = 2 * y",
  "args": "(a b : ℤ)  (x y : ℝ)  (hab : a = b)  (hxy : x = y)"},
 {"type": "x + y = y + x",
  "tactic-prompt": "example (x y : ℕ) : x + y = y + x := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(x y : ℕ) : x + y = y + x",
  "args": "(x y : ℕ)"},
 {"type": "x + y + y = 2 * y + x",
  "tactic-prompt":
  "example (x y : ℕ) : x + y + y = 2 * y + x := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(x y : ℕ) : x + y + y = 2 * y + x",
  "args": "(x y : ℕ)"},
 {"type": "x + id y = y + id x",
  "tactic-prompt": "example (x y : ℕ) : x + id y = y + id x := by ring!; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring!",
  "core-prompt": "(x y : ℕ) : x + id y = y + id x",
  "args": "(x y : ℕ)"},
 {"type": "x / 2 + x / 2 = x",
  "tactic-prompt": "example (x y : ℚ) : x / 2 + x / 2 = x := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(x y : ℚ) : x / 2 + x / 2 = x",
  "args": "(x y : ℚ)"},
 {"type": "(x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y)",
  "tactic-prompt":
  "example (x y : ℕ) : (x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y) := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt":
  "(x y : ℕ) : (x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y)",
  "args": "(x y : ℕ)"},
 {"type": "(n / 2) + (n / 2) = 2 * (n / 2)",
  "tactic-prompt":
  "example (n : ℕ) : (n / 2) + (n / 2) = 2 * (n / 2) := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(n : ℕ) : (n / 2) + (n / 2) = 2 * (n / 2)",
  "args": "(n : ℕ)"},
 {"type": "a * (n - s) = (n - s) * a",
  "tactic-prompt":
  "example (a n s: ℕ) : a * (n - s) = (n - s) * a := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(a n s: ℕ) : a * (n - s) = (n - s) * a",
  "args": "(a n s: ℕ)"},
 {"type": "(2 * A) ^ 2 = (2 * A) ^ 2",
  "tactic-prompt":
  "example (A : ℕ) : (2 * A) ^ 2 = (2 * A) ^ 2 := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(A : ℕ) : (2 * A) ^ 2 = (2 * A) ^ 2",
  "args": "(A : ℕ)"},
 {"type": "(876544 : ℤ) * -1 + (1000000 - 123456) = 0",
  "tactic-prompt":
  "example  : (876544 : ℤ) * -1 + (1000000 - 123456) = 0 := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": " : (876544 : ℤ) * -1 + (1000000 - 123456) = 0",
  "args": ""},
 {"type": "A * B = 2",
  "tactic-prompt":
  "example (A B : ℕ)  (H : B * A = 2) : A * B = 2 := by ring_nf at H ⊢; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring_nf at H ⊢",
  "core-prompt": "(A B : ℕ)  (H : B * A = 2) : A * B = 2",
  "args": "(A B : ℕ)  (H : B * A = 2)"},
 {"type":
  "2 + f (2 * f 3 * f 3) + f 3 = 1 + f (f 3 ^ 2 + f 3 * f 3) + 1 + f (2 + 1)",
  "tactic-prompt":
  "example (f : ℕ → ℕ) : 2 + f (2 * f 3 * f 3) + f 3 = 1 + f (f 3 ^ 2 + f 3 * f 3) + 1 + f (2 + 1) := by ring_nf; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring_nf",
  "core-prompt":
  "(f : ℕ → ℕ) : 2 + f (2 * f 3 * f 3) + f 3 = 1 + f (f 3 ^ 2 + f 3 * f 3) + 1 + f (2 + 1)",
  "args": "(f : ℕ → ℕ)"},
 {"type": "2^(n+1) * m = 2 * 2^n * m",
  "tactic-prompt":
  "example (n : ℕ)  (m : ℤ) : 2^(n+1) * m = 2 * 2^n * m := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(n : ℕ)  (m : ℤ) : 2^(n+1) * m = 2 * 2^n * m",
  "args": "(n : ℕ)  (m : ℤ)"},
 {"type": "(a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n",
  "tactic-prompt":
  "example (a b : ℤ)  (n : ℕ) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt":
  "(a b : ℤ)  (n : ℕ) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n",
  "args": "(a b : ℤ)  (n : ℕ)"},
 {"type": "x + id y = y + id x",
  "tactic-prompt": "example (x y : ℕ) : x + id y = y + id x := by ring!; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring!",
  "core-prompt": "(x y : ℕ) : x + id y = y + id x",
  "args": "(x y : ℕ)"},
 {"type": "22 + 7 * 4 + 3 * 8 = 0 + 7 * 4 + 46",
  "tactic-prompt":
  "example  : 22 + 7 * 4 + 3 * 8 = 0 + 7 * 4 + 46 := by conv => ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "conv => ring",
  "core-prompt": " : 22 + 7 * 4 + 3 * 8 = 0 + 7 * 4 + 46",
  "args": ""},
 {"type": "(22 + 7 * 4 + 3 * 8 = 0 + 7 * 4 + 47) = (74 = 75)",
  "tactic-prompt":
  "example  : (22 + 7 * 4 + 3 * 8 = 0 + 7 * 4 + 47) = (74 = 75) := by conv => ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "conv => ring",
  "core-prompt": " : (22 + 7 * 4 + 3 * 8 = 0 + 7 * 4 + 47) = (74 = 75)",
  "args": ""},
 {"type": "22 + 7 * x + 3 * 8 = 0 + 7 * x + 46",
  "tactic-prompt":
  "example (x : ℕ) : 22 + 7 * x + 3 * 8 = 0 + 7 * x + 46 := by conv => ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "conv => ring",
  "core-prompt": "(x : ℕ) : 22 + 7 * x + 3 * 8 = 0 + 7 * x + 46",
  "args": "(x : ℕ)"},
 {"type":
  "(22 + 7 * x + 3 * 8 = 0 + 7 * x + 46 + 1)\n                    = (7 * x + 46 = 7 * x + 47)",
  "tactic-prompt":
  "example (x : ℕ) : (22 + 7 * x + 3 * 8 = 0 + 7 * x + 46 + 1)\n                    = (7 * x + 46 = 7 * x + 47) := by conv => ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "conv => ring",
  "core-prompt":
  "(x : ℕ) : (22 + 7 * x + 3 * 8 = 0 + 7 * x + 46 + 1)\n                    = (7 * x + 46 = 7 * x + 47)",
  "args": "(x : ℕ)"},
 {"type": "nleq a b → nleq b c → nleq a c",
  "tactic-prompt":
  "example (a b c : Nat) : nleq a b → nleq b c → nleq a c := by intro h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h₁ h₂",
  "core-prompt": "(a b c : Nat) : nleq a b → nleq b c → nleq a c",
  "args": "(a b c : Nat)"},
 {"type": "nleq a b → nleq b c → nleq a c",
  "tactic-prompt":
  "example (a b c : Nat) : nleq a b → nleq b c → nleq a c := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b c : Nat) : nleq a b → nleq b c → nleq a c",
  "args": "(a b c : Nat)"},
 {"type": "a = b → b = c → a = c",
  "tactic-prompt":
  "def {a b c : α} : a = b → b = c → a = c := by intro h₁ h₂; sorry",
  "name": "eq_trans",
  "kind": "def",
  "first-tactic": "intro h₁ h₂",
  "core-prompt": "{a b c : α} : a = b → b = c → a = c",
  "args": "{a b c : α}"},
 {"type": "a = b → b = c → a = c",
  "tactic-prompt":
  "example (a b c : Nat) : a = b → b = c → a = c := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b c : Nat) : a = b → b = c → a = c",
  "args": "(a b c : Nat)"},
 {"type": "a = b → b = c → a = c",
  "tactic-prompt":
  "example (a b c : Nat) : a = b → b = c → a = c := by intro h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h₁ h₂",
  "core-prompt": "(a b c : Nat) : a = b → b = c → a = c",
  "args": "(a b c : Nat)"},
 {"type": "a ≤ b → b ≤ c → a ≤ c",
  "tactic-prompt":
  "example (a b c : Nat) : a ≤ b → b ≤ c → a ≤ c := by intros h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros h₁ h₂",
  "core-prompt": "(a b c : Nat) : a ≤ b → b ≤ c → a ≤ c",
  "args": "(a b c : Nat)"},
 {"type": "R a b → R b c → R a c",
  "tactic-prompt":
  "example (a b c : α)  (R : α → α → Prop)  [Trans R R R] : R a b → R b c → R a c := by intros h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros h₁ h₂",
  "core-prompt":
  "(a b c : α)  (R : α → α → Prop)  [Trans R R R] : R a b → R b c → R a c",
  "args": "(a b c : α)  (R : α → α → Prop)  [Trans R R R]"},
 {"type": "a ≤ b → b ≤ c → a ≤ c",
  "tactic-prompt":
  "example (a b c : Nat) : a ≤ b → b ≤ c → a ≤ c := by intros h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros h₁ h₂",
  "core-prompt": "(a b c : Nat) : a ≤ b → b ≤ c → a ≤ c",
  "args": "(a b c : Nat)"},
 {"type": "a ≤ b → b ≤ c → a ≤ c",
  "tactic-prompt":
  "example (a b c : Nat) : a ≤ b → b ≤ c → a ≤ c := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b c : Nat) : a ≤ b → b ≤ c → a ≤ c",
  "args": "(a b c : Nat)"},
 {"type": "a < b → b < c → a < c",
  "tactic-prompt":
  "example (a b c : Nat) : a < b → b < c → a < c := by intro h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h₁ h₂",
  "core-prompt": "(a b c : Nat) : a < b → b < c → a < c",
  "args": "(a b c : Nat)"},
 {"type": "a < b → b < c → a < c",
  "tactic-prompt":
  "example (a b c : Nat) : a < b → b < c → a < c := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b c : Nat) : a < b → b < c → a < c",
  "args": "(a b c : Nat)"},
 {"type": "n * p ≤ x",
  "tactic-prompt":
  "example (x n p : Nat)  (h₁ : n * Nat.succ p ≤ x) : n * p ≤ x := by trans; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "trans",
  "core-prompt": "(x n p : Nat)  (h₁ : n * Nat.succ p ≤ x) : n * p ≤ x",
  "args": "(x n p : Nat)  (h₁ : n * Nat.succ p ≤ x)"},
 {"type": "∀ b : β, HEq a b → HEq b c → HEq a c",
  "tactic-prompt":
  "example (a : α) (c : γ) : ∀ b : β, HEq a b → HEq b c → HEq a c := by intro b h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro b h₁ h₂",
  "core-prompt": "(a : α) (c : γ) : ∀ b : β, HEq a b → HEq b c → HEq a c",
  "args": "(a : α) (c : γ)"},
 {"type": "x = x",
  "tactic-prompt":
  "example (x : Nat)  (h : x = x) : x = x := by set! p := h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "set! p := h",
  "core-prompt": "(x : Nat)  (h : x = x) : x = x",
  "args": "(x : Nat)  (h : x = x)"},
 {"type": "x + x - x = 3",
  "tactic-prompt":
  "example (x : Nat)  (h : x + x - x = 3) : x + x - x = 3 := by set! y := x with ← h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "set! y := x with ← h2",
  "core-prompt": "(x : Nat)  (h : x + x - x = 3) : x + x - x = 3",
  "args": "(x : Nat)  (h : x + x - x = 3)"},
 {"type": "x = x",
  "tactic-prompt":
  "example (x : Nat)  (h : x - x = 0) : x = x := by set y : Nat := x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "set y : Nat := x",
  "core-prompt": "(x : Nat)  (h : x - x = 0) : x = x",
  "args": "(x : Nat)  (h : x - x = 0)"},
 {"type": "(λ (x y : Nat) => x + y) = (λ x y => y + x)",
  "tactic-prompt":
  "example  : (λ (x y : Nat) => x + y) = (λ x y => y + x) := by simp_rw [Nat.add_comm]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm]",
  "core-prompt": " : (λ (x y : Nat) => x + y) = (λ x y => y + x)",
  "args": ""},
 {"type": "a = c",
  "tactic-prompt":
  "example (f : Nat → Nat)  {a b c : Nat}  (ha : f b = a)  (hc : f b = c) : a = c := by simp_rw [← ha]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [← ha]",
  "core-prompt":
  "(f : Nat → Nat)  {a b c : Nat}  (ha : f b = a)  (hc : f b = c) : a = c",
  "args": "(f : Nat → Nat)  {a b c : Nat}  (ha : f b = a)  (hc : f b = c)"},
 {"type": "a + (b + (c + d)) = ((d + c) + b) + a",
  "tactic-prompt":
  "example (a b c d : Nat) : a + (b + (c + d)) = ((d + c) + b) + a := by simp_rw [Nat.add_comm]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm]",
  "core-prompt": "(a b c d : Nat) : a + (b + (c + d)) = ((d + c) + b) + a",
  "args": "(a b c d : Nat)"},
 {"type": "p (b + a)",
  "tactic-prompt":
  "example (p : Nat → Prop)  (a b : Nat)  (h : p (a + b)) : p (b + a) := by simp_rw [Nat.add_comm a b] at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm a b] at h",
  "core-prompt": "(p : Nat → Prop)  (a b : Nat)  (h : p (a + b)) : p (b + a)",
  "args": "(p : Nat → Prop)  (a b : Nat)  (h : p (a + b))"},
 {"type": "p (b + a)",
  "tactic-prompt":
  "example (p : Nat → Prop)  (a b : Nat)  (h₁ : p (b + a) → p (a + b))   (h₂ : p (a + b)) : p (b + a) := by simp_rw [Nat.add_comm a b] at h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm a b] at h₁ h₂",
  "core-prompt":
  "(p : Nat → Prop)  (a b : Nat)  (h₁ : p (b + a) → p (a + b))   (h₂ : p (a + b)) : p (b + a)",
  "args":
  "(p : Nat → Prop)  (a b : Nat)  (h₁ : p (b + a) → p (a + b))   (h₂ : p (a + b))"},
 {"type": "p (a + b)",
  "tactic-prompt":
  "example (p : Nat → Prop)  (a b : Nat)  (h₁ : p (b + a) → p (a + b))   (h₂ : p (a + b)) : p (a + b) := by simp_rw [Nat.add_comm a b] at *; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm a b] at *",
  "core-prompt":
  "(p : Nat → Prop)  (a b : Nat)  (h₁ : p (b + a) → p (a + b))   (h₂ : p (a + b)) : p (a + b)",
  "args":
  "(p : Nat → Prop)  (a b : Nat)  (h₁ : p (b + a) → p (a + b))   (h₂ : p (a + b))"},
 {"type": "(∀ b, a - 1 ≤ b) = ∀ b c : Nat, c < a → c < b + 1",
  "tactic-prompt":
  "example {a : Nat}    (h1 : ∀ a b : Nat, a - 1 ≤ b ↔ a ≤ b + 1)    (h2 : ∀ a b : Nat, a ≤ b ↔ ∀ c, c < a → c < b) : (∀ b, a - 1 ≤ b) = ∀ b c : Nat, c < a → c < b + 1 := by simp_rw [h1]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [h1]",
  "core-prompt":
  "{a : Nat}    (h1 : ∀ a b : Nat, a - 1 ≤ b ↔ a ≤ b + 1)    (h2 : ∀ a b : Nat, a ≤ b ↔ ∀ c, c < a → c < b) : (∀ b, a - 1 ≤ b) = ∀ b c : Nat, c < a → c < b + 1",
  "args":
  "{a : Nat}    (h1 : ∀ a b : Nat, a - 1 ≤ b ↔ a ≤ b + 1)    (h2 : ∀ a b : Nat, a ≤ b ↔ ∀ c, c < a → c < b)"},
 {"type": "p → q → r → p ∧ q ∧ r",
  "tactic-prompt":
  "example (p q r : Prop) : p → q → r → p ∧ q ∧ r := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(p q r : Prop) : p → q → r → p ∧ q ∧ r",
  "args": "(p q r : Prop)"},
 {"type": "p → q → r → p ∧ q ∧ r",
  "tactic-prompt":
  "example (p q r : Prop) : p → q → r → p ∧ q ∧ r := by intros a b c; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros a b c",
  "core-prompt": "(p q r : Prop) : p → q → r → p ∧ q ∧ r",
  "args": "(p q r : Prop)"},
 {"type": "p → q → p ∧ q",
  "tactic-prompt":
  "example (p q : Prop) : p → q → p ∧ q := by intros a b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros a b",
  "core-prompt": "(p q : Prop) : p → q → p ∧ q",
  "args": "(p q : Prop)"},
 {"type": "p → p",
  "tactic-prompt": "example (p : Prop) : p → p := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(p : Prop) : p → p",
  "args": "(p : Prop)"},
 {"type": "Nat",
  "tactic-prompt": "example (h : Int) : Nat := by replace h : Nat := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "replace h : Nat := 0",
  "core-prompt": "(h : Int) : Nat",
  "args": "(h : Int)"},
 {"type": "Nat",
  "tactic-prompt": "example (h : Nat) : Nat := by have h : Int := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have h : Int := 0",
  "core-prompt": "(h : Nat) : Nat",
  "args": "(h : Nat)"},
 {"type": "Nat",
  "tactic-prompt": "example (h : Nat) : Nat := by replace h : Int := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "replace h : Int := 0",
  "core-prompt": "(h : Nat) : Nat",
  "args": "(h : Nat)"},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have : Int := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : Int := 0",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have : Nat := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : Nat := 0",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have : Nat := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : Nat := 0",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "a = a",
  "tactic-prompt":
  "example {a : Nat} : a = a := by replace a : Int := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "replace a : Int := 0",
  "core-prompt": "{a : Nat} : a = a",
  "args": "{a : Nat}"},
 {"type": "Nat",
  "tactic-prompt": "example (z : Int) : Nat := by replace z : Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "replace z : Nat",
  "core-prompt": "(z : Int) : Nat",
  "args": "(z : Int)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by have : 1 + 1 = 2 := by simp_arith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : 1 + 1 = 2 := by simp_arith",
  "core-prompt": " : True",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have h : Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have h : Nat",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have : Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : Nat",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "a = a",
  "tactic-prompt": "example {a : Nat} : a = a := by have h : a = a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have h : a = a",
  "core-prompt": "{a : Nat} : a = a",
  "args": "{a : Nat}"},
 {"type": "a = a",
  "tactic-prompt": "example {a : Nat} : a = a := by have : a = a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : a = a",
  "core-prompt": "{a : Nat} : a = a",
  "args": "{a : Nat}"},
 {"type": "True",
  "tactic-prompt": "example  : True := by (let _N); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "(let _N)",
  "core-prompt": " : True",
  "args": ""},
 {"type": "∃ x : Nat, x = x",
  "tactic-prompt": "example  : ∃ x : Nat, x = x := by use 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use 42",
  "core-prompt": " : ∃ x : Nat, x = x",
  "args": ""},
 {"type": "∃ x : Nat, ∃ y : Nat, x = y",
  "tactic-prompt":
  "example  : ∃ x : Nat, ∃ y : Nat, x = y := by use 42, 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use 42, 42",
  "core-prompt": " : ∃ x : Nat, ∃ y : Nat, x = y",
  "args": ""},
 {"type": "∃ x : String × String, x.1 = x.2",
  "tactic-prompt":
  "example  : ∃ x : String × String, x.1 = x.2 := by use (\"a\", \"a\"); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use (\"a\", \"a\")",
  "core-prompt": " : ∃ x : String × String, x.1 = x.2",
  "args": ""},
 {"type": "∃ x : Nat, x = x",
  "tactic-prompt": "example  : ∃ x : Nat, x = x := by use ?_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use ?_",
  "core-prompt": " : ∃ x : Nat, x = x",
  "args": ""},
 {"type": "∃ S : List α, S = S",
  "tactic-prompt":
  "example (α : Type) : ∃ S : List α, S = S := by use ∅; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use ∅",
  "core-prompt": "(α : Type) : ∃ S : List α, S = S",
  "args": "(α : Type)"},
 {"type": "∃ x : Int, x = x",
  "tactic-prompt": "example  : ∃ x : Int, x = x := by use 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use 42",
  "core-prompt": " : ∃ x : Int, x = x",
  "args": ""},
 {"type": "∃ a b c : Int, a + b + c = 6",
  "tactic-prompt":
  "example  : ∃ a b c : Int, a + b + c = 6 := by use 1, 2, 3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use 1, 2, 3",
  "core-prompt": " : ∃ a b c : Int, a + b + c = 6",
  "args": ""},
 {"type": "∃ p : Int × Int, p.1 = 1",
  "tactic-prompt":
  "example  : ∃ p : Int × Int, p.1 = 1 := by use ⟨1, 42⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use ⟨1, 42⟩",
  "core-prompt": " : ∃ p : Int × Int, p.1 = 1",
  "args": ""},
 {"type": "a = a",
  "tactic-prompt": "example (a : Nat) : a = a := by rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rfl",
  "core-prompt": "(a : Nat) : a = a",
  "args": "(a : Nat)"},
 {"type": "a ≈ a",
  "tactic-prompt":
  "example {α : Sort u}  [Setoid α] (a : α) : a ≈ a := by rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rfl",
  "core-prompt": "{α : Sort u}  [Setoid α] (a : α) : a ≈ a",
  "args": "{α : Sort u}  [Setoid α] (a : α)"},
 {"type": "a ≤ a",
  "tactic-prompt":
  "example {α : Sort u}  [Setoid α] (a : Nat) : a ≤ a := by (fail_if_success rfl); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "(fail_if_success rfl)",
  "core-prompt": "{α : Sort u}  [Setoid α] (a : Nat) : a ≤ a",
  "args": "{α : Sort u}  [Setoid α] (a : Nat)"},
 {"type": "a ≤ a",
  "tactic-prompt":
  "example {α : Sort u}  [Setoid α] (a : Nat) : a ≤ a := by rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rfl",
  "core-prompt": "{α : Sort u}  [Setoid α] (a : Nat) : a ≤ a",
  "args": "{α : Sort u}  [Setoid α] (a : Nat)"},
 {"type": "a ≤ a",
  "tactic-prompt":
  "example {α : Sort u}  [Setoid α] (a : Foo) : a ≤ a := by apply Foo.le_refl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply Foo.le_refl",
  "core-prompt": "{α : Sort u}  [Setoid α] (a : Foo) : a ≤ a",
  "args": "{α : Sort u}  [Setoid α] (a : Foo)"},
 {"type": "a ≤ a",
  "tactic-prompt":
  "example {α : Sort u}  [Setoid α] (a : Foo) : a ≤ a := by rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rfl",
  "core-prompt": "{α : Sort u}  [Setoid α] (a : Foo) : a ≤ a",
  "args": "{α : Sort u}  [Setoid α] (a : Foo)"},
 {"type": "0 ≤ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ : 0 ≤ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt": "{ι α β : Type _}  /- ## Numeric goals -/ : 0 ≤ 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/"},
 {"type": "0 ≤ 3",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ : 0 ≤ 3 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt": "{ι α β : Type _}  /- ## Numeric goals -/ : 0 ≤ 3",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/"},
 {"type": "0 < 3",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ : 0 < 3 := by positivity\n\n/- ## Goals working directly from a hypothesis -/; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "positivity\n\n/- ## Goals working directly from a hypothesis -/",
  "core-prompt": "{ι α β : Type _}  /- ## Numeric goals -/ : 0 < 3",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/"},
 {"type": "0 < a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a) : 0 < a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a) : 0 < a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a)"},
 {"type": "0 ≤ a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a) : 0 ≤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a) : 0 ≤ a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a)"},
 {"type": "a ≠ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a) : a ≠ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a) : a ≠ 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a)"},
 {"type": "0 ≤ a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 ≤ a) : 0 ≤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 ≤ a) : 0 ≤ a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 ≤ a)"},
 {"type": "a ≠ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a ≠ 0) : a ≠ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a ≠ 0) : a ≠ 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a ≠ 0)"},
 {"type": "0 ≤ a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a = 0) : 0 ≤ a := by positivity\n\n/- ### Reversing hypotheses -/; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity\n\n/- ### Reversing hypotheses -/",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a = 0) : 0 ≤ a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a = 0)"},
 {"type": "0 < a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a > 0) : 0 < a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a > 0) : 0 < a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a > 0)"},
 {"type": "0 ≤ a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a > 0) : 0 ≤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a > 0) : 0 ≤ a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a > 0)"},
 {"type": "a ≠ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a > 0) : a ≠ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a > 0) : a ≠ 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a > 0)"},
 {"type": "0 ≤ a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a ≥ 0) : 0 ≤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a ≥ 0) : 0 ≤ a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a ≥ 0)"},
 {"type": "a ≠ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 ≠ a) : a ≠ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 ≠ a) : a ≠ 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 ≠ a)"},
 {"type": "a > 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a) : a > 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a) : a > 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a)"},
 {"type": "a ≥ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a) : a ≥ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a) : a ≥ 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a)"},
 {"type": "0 ≠ a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a) : 0 ≠ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a) : 0 ≠ a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a)"},
 {"type": "a ≥ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 ≤ a) : a ≥ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 ≤ a) : a ≥ 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 ≤ a)"},
 {"type": "0 ≠ a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a ≠ 0) : 0 ≠ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a ≠ 0) : 0 ≠ a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a ≠ 0)"},
 {"type": "a ≥ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a = 0) : a ≥ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a = 0) : a ≥ 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a = 0)"},
 {"type": "0 ≤ a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 = a) : 0 ≤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 = a) : 0 ≤ a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 = a)"},
 {"type": "a ≥ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 = a) : a ≥ 0 := by positivity\n\n/- ### Calling `norm_num` -/; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity\n\n/- ### Calling `norm_num` -/",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 = a) : a ≥ 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 = a)"},
 {"type": "0 ≤ a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 = a) : 0 ≤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 = a) : 0 ≤ a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 = a)"},
 {"type": "a ≠ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 = a) : a ≠ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 = a) : a ≠ 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 = a)"},
 {"type": "0 < a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 = a) : 0 < a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 = a) : 0 < a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 = a)"},
 {"type": "a ≠ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a = -1) : a ≠ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a = -1) : a ≠ 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a = -1)"},
 {"type": "0 ≤ a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 ≤ a) : 0 ≤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 ≤ a) : 0 ≤ a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 ≤ a)"},
 {"type": "a ≠ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 ≤ a) : a ≠ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 ≤ a) : a ≠ 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 ≤ a)"},
 {"type": "0 < a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 ≤ a) : 0 < a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 ≤ a) : 0 < a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 ≤ a)"},
 {"type": "0 ≤ a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a) : 0 ≤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a) : 0 ≤ a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a)"},
 {"type": "a ≠ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a) : a ≠ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a) : a ≠ 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a)"},
 {"type": "0 < a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a) : 0 < a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a) : 0 < a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a)"},
 {"type": "0 ≤ a + b",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a b : ℤ}  (h : 0 ≤ a + b) : 0 ≤ a + b := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℤ}  (h : 0 ≤ a + b) : 0 ≤ a + b",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℤ}  (h : 0 ≤ a + b)"},
 {"type": "0 < a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (hlt : 0 ≤ a)  (hne : a ≠ 0) : 0 < a := by positivity\n\n/- ## Tests of the @[positivity] plugin tactics (addition]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "positivity\n\n/- ## Tests of the @[positivity] plugin tactics (addition]",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (hlt : 0 ≤ a)  (hne : a ≠ 0) : 0 < a",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (hlt : 0 ≤ a)  (hne : a ≠ 0)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "0 ≤ a * b",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : 0 < a)  (hb : 0 ≤ b) : 0 ≤ a * b := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : 0 < a)  (hb : 0 ≤ b) : 0 ≤ a * b",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : 0 < a)  (hb : 0 ≤ b)"},
 {"type": "0 ≤ a * b",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : 0 ≤ a)  (hb : 0 < b) : 0 ≤ a * b := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : 0 ≤ a)  (hb : 0 < b) : 0 ≤ a * b",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : 0 ≤ a)  (hb : 0 < b)"},
 {"type": "a * b ≠ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : 0 < a)  (hb : b ≠ 0) : a * b ≠ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : 0 < a)  (hb : b ≠ 0) : a * b ≠ 0",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : 0 < a)  (hb : b ≠ 0)"},
 {"type": "a * b ≠ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : a ≠ 0)  (hb : 0 < b) : a * b ≠ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : a ≠ 0)  (hb : 0 < b) : a * b ≠ 0",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : a ≠ 0)  (hb : 0 < b)"},
 {"type": "a * b ≠ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : a ≠ 0)  (hb : b ≠ 0) : a * b ≠ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : a ≠ 0)  (hb : b ≠ 0) : a * b ≠ 0",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℚ}  (ha : a ≠ 0)  (hb : b ≠ 0)"},
 {"type": "0 < a ^ n",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℚ}  (n : ℕ)  (ha : 0 < a) : 0 < a ^ n := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℚ}  (n : ℕ)  (ha : 0 < a) : 0 < a ^ n",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℚ}  (n : ℕ)  (ha : 0 < a)"},
 {"type": "0 ≤ a ^ n",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℚ}  (n : ℕ)  (ha : 0 ≤ a) : 0 ≤ a ^ n := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℚ}  (n : ℕ)  (ha : 0 ≤ a) : 0 ≤ a ^ n",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℚ}  (n : ℕ)  (ha : 0 ≤ a)"},
 {"type": "a ^ n ≠ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℚ}  (n : ℕ)  (ha : a ≠ 0) : a ^ n ≠ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℚ}  (n : ℕ)  (ha : a ≠ 0) : a ^ n ≠ 0",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℚ}  (n : ℕ)  (ha : a ≠ 0)"},
 {"type": "0 ≤ a ^ 18",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℚ} : 0 ≤ a ^ 18 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℚ} : 0 ≤ a ^ 18",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℚ}"},
 {"type": "0 < a ^ 18",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℚ}  (ha : a ≠ 0) : 0 < a ^ 18 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℚ}  (ha : a ≠ 0) : 0 < a ^ 18",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℚ}  (ha : a ≠ 0)"},
 {"type": "0 ≤ a + a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a) : 0 ≤ a + a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a) : 0 ≤ a + a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a)"},
 {"type": "0 ≤ 3 + a + b + b + 14",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a b : ℤ}  (ha : 3 < a)  (hb : 4 ≤ b) : 0 ≤ 3 + a + b + b + 14 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℤ}  (ha : 3 < a)  (hb : 4 ≤ b) : 0 ≤ 3 + a + b + b + 14",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℤ}  (ha : 3 < a)  (hb : 4 ≤ b)"},
 {"type": "0 < a + a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a) : 0 < a + a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a) : 0 < a + a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a)"},
 {"type": "0 < a ^ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ [OrderedSemiring α]  [Nontrivial α]  (a : α) : 0 < a ^ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ [OrderedSemiring α]  [Nontrivial α]  (a : α) : 0 < a ^ 0",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ [OrderedSemiring α]  [Nontrivial α]  (a : α)"},
 {"type": "0 ≤ a ^ 18",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ [LinearOrderedRing α]  (a : α) : 0 ≤ a ^ 18 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ [LinearOrderedRing α]  (a : α) : 0 ≤ a ^ 18",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ [LinearOrderedRing α]  (a : α)"},
 {"type": "0 ≤ a ^ n",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ [OrderedSemiring α]  {a : α}  {n : ℕ}  (ha : 0 ≤ a) : 0 ≤ a ^ n := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ [OrderedSemiring α]  {a : α}  {n : ℕ}  (ha : 0 ≤ a) : 0 ≤ a ^ n",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ [OrderedSemiring α]  {a : α}  {n : ℕ}  (ha : 0 ≤ a)"},
 {"type": "0 < a ^ n",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ [StrictOrderedSemiring α]  {a : α}  {n : ℕ}  (ha : 0 < a) : 0 < a ^ n := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ [StrictOrderedSemiring α]  {a : α}  {n : ℕ}  (ha : 0 < a) : 0 < a ^ n",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ [StrictOrderedSemiring α]  {a : α}  {n : ℕ}  (ha : 0 < a)"},
 {"type": "0 ≤ a ^ 2 + a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a) : 0 ≤ a ^ 2 + a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a) : 0 ≤ a ^ 2 + a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a)"},
 {"type": "0 ≤ a ^ 3 + a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a) : 0 ≤ a ^ 3 + a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a) : 0 ≤ a ^ 3 + a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a)"},
 {"type": "0 < a ^ 2 + a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a) : 0 < a ^ 2 + a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a) : 0 < a ^ 2 + a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 3 < a)"},
 {"type": "0 ≤ 3 * a ^ 2 * b + b * 7 + 14",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a b : ℤ}  (ha : 3 < a)  (hb : b ≥ 4) : 0 ≤ 3 * a ^ 2 * b + b * 7 + 14 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℤ}  (ha : 3 < a)  (hb : b ≥ 4) : 0 ≤ 3 * a ^ 2 * b + b * 7 + 14",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℤ}  (ha : 3 < a)  (hb : b ≥ 4)"},
 {"type": "0 < 3 * a ^ 2 * b + b * 7 + 14",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a b : ℤ}  (ha : 3 < a)  (hb : b ≥ 4) : 0 < 3 * a ^ 2 * b + b * 7 + 14 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℤ}  (ha : 3 < a)  (hb : b ≥ 4) : 0 < 3 * a ^ 2 * b + b * 7 + 14",
  "args":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a b : ℤ}  (ha : 3 < a)  (hb : b ≥ 4)"},
 {"type": "0 ≤ max 3 4",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ : 0 ≤ max 3 4 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt": "{ι α β : Type _}  /- ## Numeric goals -/ : 0 ≤ max 3 4",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/"},
 {"type": "0 ≤ a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℕ} : 0 ≤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℕ} : 0 ≤ a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℕ}"},
 {"type": "0 ≤ a",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a > 0) : 0 ≤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a > 0) : 0 ≤ a",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a > 0)"},
 {"type": "a ≥ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a) : a ≥ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a) : a ≥ 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : 0 < a)"},
 {"type": "a ≥ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a > 0) : a ≥ 0 := by positivity\n\n/-\n## Test for meta-variable instantiation\n\nReported on\nhttps://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/300639970\n-/; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "positivity\n\n/-\n## Test for meta-variable instantiation\n\nReported on\nhttps://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/300639970\n-/",
  "core-prompt":
  "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a > 0) : a ≥ 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/ {a : ℤ}  (ha : a > 0)"},
 {"type": "0 ≤ 0",
  "tactic-prompt":
  "example {ι α β : Type _}  /- ## Numeric goals -/ : 0 ≤ 0 := by apply le_trans _ (le_refl _); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply le_trans _ (le_refl _)",
  "core-prompt": "{ι α β : Type _}  /- ## Numeric goals -/ : 0 ≤ 0",
  "args": "{ι α β : Type _}  /- ## Numeric goals -/"},
 {"type": "True",
  "tactic-prompt": "example  : True := by if 1 + 1 = 2 then _ else ?_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "if 1 + 1 = 2 then _ else ?_",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (p : Prop) : True := by if p then ?foo else trivial; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "if p then ?foo else trivial",
  "core-prompt": "(p : Prop) : True",
  "args": "(p : Prop)"},
 {"type": "unop x = unop y ↔ x = y",
  "tactic-prompt":
  "theorem {x y : αᵐᵒᵖ} : unop x = unop y ↔ x = y := by cases x; sorry",
  "name": "unop_inj",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": "{x y : αᵐᵒᵖ} : unop x = unop y ↔ x = y",
  "args": "{x y : αᵐᵒᵖ}"},
 {"type": "P",
  "tactic-prompt": "example {P : Prop}  (p : P) : P := by simpa; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simpa",
  "core-prompt": "{P : Prop}  (p : P) : P",
  "args": "{P : Prop}  (p : P)"},
 {"type": "P",
  "tactic-prompt": "example {P : Prop}  (p : False) : P := by simp at p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp at p",
  "core-prompt": "{P : Prop}  (p : False) : P",
  "args": "{P : Prop}  (p : False)"},
 {"type": "foo n = [n]",
  "tactic-prompt": "example  : foo n = [n] := by simpa only [foo]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simpa only [foo]",
  "core-prompt": " : foo n = [n]",
  "args": ""},
 {"type": "False",
  "tactic-prompt":
  "example (h : foo n ≠ [n]) : False := by simpa [foo] using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simpa [foo] using h",
  "core-prompt": "(h : foo n ≠ [n]) : False",
  "args": "(h : foo n ≠ [n])"},
 {"type": "p (b + a)",
  "tactic-prompt":
  "example (p : Nat → Prop)  (h : p (a + b)) : p (b + a) := by have : a + b = b + a := Nat.add_comm _ _; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : a + b = b + a := Nat.add_comm _ _",
  "core-prompt": "(p : Nat → Prop)  (h : p (a + b)) : p (b + a)",
  "args": "(p : Nat → Prop)  (h : p (a + b))"},
 {"type": "Injective fun a => a / b",
  "tactic-prompt":
  "theorem [Group G] (b : G) : Injective fun a => a / b := by simpa only [div_eq_mul_inv] using fun a a' h => mul_left_injective (Inv.inv b) h; sorry",
  "name": "div_left_injective",
  "kind": "theorem",
  "first-tactic":
  "simpa only [div_eq_mul_inv] using fun a a' h => mul_left_injective (Inv.inv b) h",
  "core-prompt": "[Group G] (b : G) : Injective fun a => a / b",
  "args": "[Group G] (b : G)"},
 {"type": "Injective (Prod.mk a : β → α × β)",
  "tactic-prompt":
  "theorem [Group G] {α β : Type _}  (a : α) : Injective (Prod.mk a : β → α × β) := by intro b₁ b₂ h; sorry",
  "name": "mk.inj_left",
  "kind": "theorem",
  "first-tactic": "intro b₁ b₂ h",
  "core-prompt":
  "[Group G] {α β : Type _}  (a : α) : Injective (Prod.mk a : β → α × β)",
  "args": "[Group G] {α β : Type _}  (a : α)"},
 {"type": "a = 2",
  "tactic-prompt":
  "theorem [Group G] (h : ∀ {x : Nat}, a = x) : a = 2 := by simpa using h; sorry",
  "name": "implicit_lambda",
  "kind": "theorem",
  "first-tactic": "simpa using h",
  "core-prompt": "[Group G] (h : ∀ {x : Nat}, a = x) : a = 2",
  "args": "[Group G] (h : ∀ {x : Nat}, a = x)"},
 {"type": "∀ {x : Nat}, a = 2",
  "tactic-prompt":
  "theorem [Group G] (h : a = 2) : ∀ {x : Nat}, a = 2 := by simpa using h; sorry",
  "name": "implicit_lambda2",
  "kind": "theorem",
  "first-tactic": "simpa using h",
  "core-prompt": "[Group G] (h : a = 2) : ∀ {x : Nat}, a = 2",
  "args": "[Group G] (h : a = 2)"},
 {"type": "∀ {x : Nat}, a = x",
  "tactic-prompt":
  "theorem [Group G] (h : ∀ {x : Nat}, a = x) : ∀ {x : Nat}, a = x := by simpa using @h; sorry",
  "name": "no_implicit_lambda",
  "kind": "theorem",
  "first-tactic": "simpa using @h",
  "core-prompt": "[Group G] (h : ∀ {x : Nat}, a = x) : ∀ {x : Nat}, a = x",
  "args": "[Group G] (h : ∀ {x : Nat}, a = x)"},
 {"type": "(b - c : Int) + (a - b) + a ≤ c",
  "tactic-prompt":
  "example [Group G] : (b - c : Int) + (a - b) + a ≤ c := by simpa only [thm] using thm2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simpa only [thm] using thm2",
  "core-prompt": "[Group G] : (b - c : Int) + (a - b) + a ≤ c",
  "args": "[Group G]"},
 {"type": "(b - c : Int) + (a - b) + a ≤ c",
  "tactic-prompt":
  "example [Group G] : (b - c : Int) + (a - b) + a ≤ c := by simpa only [thm] using @thm2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simpa only [thm] using @thm2",
  "core-prompt": "[Group G] : (b - c : Int) + (a - b) + a ≤ c",
  "args": "[Group G]"},
 {"type": "Nat × Nat",
  "tactic-prompt":
  "example (n : Nat) : Nat × Nat := by show_term\n    constructor\n    exact n\n    exact 37; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "show_term\n    constructor\n    exact n\n    exact 37",
  "core-prompt": "(n : Nat) : Nat × Nat",
  "args": "(n : Nat)"},
 {"type": "Nat × Nat",
  "tactic-prompt": "example  : Nat × Nat := by show_term constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "show_term constructor",
  "core-prompt": " : Nat × Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example (n : Nat) : Nat := by guard_hyp n :ₛ Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "guard_hyp n :ₛ Nat",
  "core-prompt": "(n : Nat) : Nat",
  "args": "(n : Nat)"},
 {"type": "P",
  "tactic-prompt": "def (P : Prop)  (x : P) : P := by by_contra h; sorry",
  "name": "nonDecid",
  "kind": "def",
  "first-tactic": "by_contra h",
  "core-prompt": "(P : Prop)  (x : P) : P",
  "args": "(P : Prop)  (x : P)"},
 {"type": "P",
  "tactic-prompt":
  "def (P : Prop)  [Decidable P]  (x : P) : P := by by_contra h; sorry",
  "name": "decid",
  "kind": "def",
  "first-tactic": "by_contra h",
  "core-prompt": "(P : Prop)  [Decidable P]  (x : P) : P",
  "args": "(P : Prop)  [Decidable P]  (x : P)"},
 {"type": "nonDecid P = decid P",
  "tactic-prompt":
  "example (P : Prop)  [Decidable P] : nonDecid P = decid P := by delta nonDecid nonDecid.proof_1 decid decid.proof_1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "delta nonDecid nonDecid.proof_1 decid decid.proof_1",
  "core-prompt": "(P : Prop)  [Decidable P] : nonDecid P = decid P",
  "args": "(P : Prop)  [Decidable P]"},
 {"type": "P → P",
  "tactic-prompt": "example (P : Prop) : P → P := by by_contra; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra",
  "core-prompt": "(P : Prop) : P → P",
  "args": "(P : Prop)"},
 {"type": "(True ∧ (∃ x : Nat, x = x)) ∧ True",
  "tactic-prompt":
  "example  : (True ∧ (∃ x : Nat, x = x)) ∧ True := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : (True ∧ (∃ x : Nat, x = x)) ∧ True",
  "args": ""},
 {"type": "((True ∧ True) ∧ (∃ x : Nat, x = x)) ∧ (True ∧ (∃ x : Nat, x = x))",
  "tactic-prompt":
  "example  : ((True ∧ True) ∧ (∃ x : Nat, x = x)) ∧ (True ∧ (∃ x : Nat, x = x)) := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt":
  " : ((True ∧ True) ∧ (∃ x : Nat, x = x)) ∧ (True ∧ (∃ x : Nat, x = x))",
  "args": ""},
 {"type": "(True ∧ (∃ x : Nat, x = x)) ∧ True",
  "tactic-prompt":
  "example  : (True ∧ (∃ x : Nat, x = x)) ∧ True := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : (True ∧ (∃ x : Nat, x = x)) ∧ True",
  "args": ""},
 {"type": "a = b ∨ True",
  "tactic-prompt":
  "example (a b : A n) : a = b ∨ True := by fail_if_success\n    apply Or.inl; ext; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    apply Or.inl; ext",
  "core-prompt": "(a b : A n) : a = b ∨ True",
  "args": "(a b : A n)"},
 {"type": "a = b",
  "tactic-prompt": "example (a b : C n) : a = b := by ext; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ext",
  "core-prompt": "(a b : C n) : a = b",
  "args": "(a b : C n)"},
 {"type": "f = g",
  "tactic-prompt":
  "example (f g : Nat × Nat → Nat) : f = g := by ext ⟨x, y⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt": "(f g : Nat × Nat → Nat) : f = g",
  "args": "(f g : Nat × Nat → Nat)"},
 {"type": "x + 1 = 1 + x",
  "tactic-prompt": "example  : x + 1 = 1 + x := by simp? [Nat.add_comm]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp? [Nat.add_comm]",
  "core-prompt": " : x + 1 = 1 + x",
  "args": ""},
 {"type": "1 + 1 = 2",
  "tactic-prompt": "example  : 1 + 1 = 2 := by dsimp?; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp?",
  "core-prompt": " : 1 + 1 = 2",
  "args": ""},
 {"type": "foo x y = 1 + y",
  "tactic-prompt": "example  : foo x y = 1 + y := by cases x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases x",
  "core-prompt": " : foo x y = 1 + y",
  "args": ""},
 {"type": "foo x y = 1 + y",
  "tactic-prompt":
  "example  : foo x y = 1 + y := by squeeze_scope\n    cases x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "squeeze_scope\n    cases x",
  "core-prompt": " : foo x y = 1 + y",
  "args": ""},
 {"type": "c x y z ↔ c x' y z'",
  "tactic-prompt":
  "example (c : Prop → Prop → Prop → Prop)  (x x' y z z' : Prop)      (h₀ : x ↔ x')  (h₁ : z ↔ z') : c x y z ↔ c x' y z' := by apply Iff.of_eq; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply Iff.of_eq",
  "core-prompt":
  "(c : Prop → Prop → Prop → Prop)  (x x' y z z' : Prop)      (h₀ : x ↔ x')  (h₁ : z ↔ z') : c x y z ↔ c x' y z'",
  "args":
  "(c : Prop → Prop → Prop → Prop)  (x x' y z z' : Prop)      (h₀ : x ↔ x')  (h₁ : z ↔ z')"},
 {"type": "f x = f y",
  "tactic-prompt":
  "example {α β : Type _}  {f : _ → β}  {x y : { x : { x : α // x = x } // x = x }}      (h : x.1 = y.1) : f x = f y := by congr with x : 1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "congr with x : 1",
  "core-prompt":
  "{α β : Type _}  {f : _ → β}  {x y : { x : { x : α // x = x } // x = x }}      (h : x.1 = y.1) : f x = f y",
  "args":
  "{α β : Type _}  {f : _ → β}  {x y : { x : { x : α // x = x } // x = x }}      (h : x.1 = y.1)"},
 {"type": "F f = F g",
  "tactic-prompt":
  "example {α β : Type _}  {F : _ → β}  {f g : { f : α → β // f = f }}      (h : ∀ x : α, (f : α → β) x = (g : α → β) x) : F f = F g := by rcongr x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcongr x",
  "core-prompt":
  "{α β : Type _}  {F : _ → β}  {f g : { f : α → β // f = f }}      (h : ∀ x : α, (f : α → β) x = (g : α → β) x) : F f = F g",
  "args":
  "{α β : Type _}  {F : _ → β}  {f g : { f : α → β // f = f }}      (h : ∀ x : α, (f : α → β) x = (g : α → β) x)"},
 {"type":
  "(ls.map fun x => (ls.map fun y => 1 + y).sum + 1) =\n    (ls.map fun x => (ls.map fun y => Nat.succ y).sum + 1)",
  "tactic-prompt":
  "example {ls : List Nat} : (ls.map fun x => (ls.map fun y => 1 + y).sum + 1) =\n    (ls.map fun x => (ls.map fun y => Nat.succ y).sum + 1) := by rcongr (_x y); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcongr (_x y)",
  "core-prompt":
  "{ls : List Nat} : (ls.map fun x => (ls.map fun y => 1 + y).sum + 1) =\n    (ls.map fun x => (ls.map fun y => Nat.succ y).sum + 1)",
  "args": "{ls : List Nat}"},
 {"type": "(ls.map fun x => f x + 3) = ls.map fun x => g x + 3",
  "tactic-prompt":
  "example {ls : List Nat}  {f g : Nat → Nat}  {h : ∀ x, f x = g x} : (ls.map fun x => f x + 3) = ls.map fun x => g x + 3 := by rcongr x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcongr x",
  "core-prompt":
  "{ls : List Nat}  {f g : Nat → Nat}  {h : ∀ x, f x = g x} : (ls.map fun x => f x + 3) = ls.map fun x => g x + 3",
  "args": "{ls : List Nat}  {f g : Nat → Nat}  {h : ∀ x, f x = g x}"},
 {"type": "() = ()",
  "tactic-prompt": "example  : () = () := by rcongr; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcongr",
  "core-prompt": " : () = ()",
  "args": ""},
 {"type": "0 = 0",
  "tactic-prompt": "example  : 0 = 0 := by rcongr; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcongr",
  "core-prompt": " : 0 = 0",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (x : α × β × γ) : True := by rcases x with ⟨a, b, c⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x with ⟨a, b, c⟩",
  "core-prompt": "(x : α × β × γ) : True",
  "args": "(x : α × β × γ)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : α × β × γ) : True := by rcases x with ⟨(a : α) : id α, -, c : id γ⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x with ⟨(a : α) : id α, -, c : id γ⟩",
  "core-prompt": "(x : α × β × γ) : True",
  "args": "(x : α × β × γ)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : (α × β) × γ) : True := by fail_if_success rcases x with ⟨_a, b, c⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success rcases x with ⟨_a, b, c⟩",
  "core-prompt": "(x : (α × β) × γ) : True",
  "args": "(x : (α × β) × γ)"},
 {"type": "@Inhabited.{1} α × Option β ⊕ γ → True",
  "tactic-prompt":
  "example  : @Inhabited.{1} α × Option β ⊕ γ → True := by rintro (⟨⟨a⟩, _ | b⟩ | c); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rintro (⟨⟨a⟩, _ | b⟩ | c)",
  "core-prompt": " : @Inhabited.{1} α × Option β ⊕ γ → True",
  "args": ""},
 {"type": "cond false Nat Int → cond true Int Nat → Nat ⊕ Unit → True",
  "tactic-prompt":
  "example  : cond false Nat Int → cond true Int Nat → Nat ⊕ Unit → True := by rintro (x y : Int) (z | u); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rintro (x y : Int) (z | u)",
  "core-prompt":
  " : cond false Nat Int → cond true Int Nat → Nat ⊕ Unit → True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (x y : Nat)  (h : x = y) : True := by rcases x with _|⟨⟩|z; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x with _|⟨⟩|z",
  "core-prompt": "(x y : Nat)  (h : x = y) : True",
  "args": "(x y : Nat)  (h : x = y)"},
 {"type": "x < 4",
  "tactic-prompt":
  "example (h : x = 3)  (h₂ : x < 4) : x < 4 := by rcases h with ⟨⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases h with ⟨⟩",
  "core-prompt": "(h : x = 3)  (h₂ : x < 4) : x < 4",
  "args": "(h : x = 3)  (h₂ : x < 4)"},
 {"type": "x < 4",
  "tactic-prompt":
  "example (h : x = 3)  (h₂ : x < 4) : x < 4 := by rcases h with rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases h with rfl",
  "core-prompt": "(h : x = 3)  (h₂ : x < 4) : x < 4",
  "args": "(h : x = 3)  (h₂ : x < 4)"},
 {"type": "x < 4",
  "tactic-prompt":
  "example (h : 3 = x)  (h₂ : x < 4) : x < 4 := by rcases h with ⟨⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases h with ⟨⟩",
  "core-prompt": "(h : 3 = x)  (h₂ : x < 4) : x < 4",
  "args": "(h : 3 = x)  (h₂ : x < 4)"},
 {"type": "x < 4",
  "tactic-prompt":
  "example (h : 3 = x)  (h₂ : x < 4) : x < 4 := by rcases h with rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases h with rfl",
  "core-prompt": "(h : 3 = x)  (h₂ : x < 4) : x < 4",
  "args": "(h : 3 = x)  (h₂ : x < 4)"},
 {"type": "True",
  "tactic-prompt":
  "example (s : α ⊕ Empty) : True := by rcases s with s|⟨⟨⟩⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases s with s|⟨⟨⟩⟩",
  "core-prompt": "(s : α ⊕ Empty) : True",
  "args": "(s : α ⊕ Empty)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by obtain ⟨n : Nat, _h : n = n, -⟩ : ∃ n : Nat, n = n ∧ True; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "obtain ⟨n : Nat, _h : n = n, -⟩ : ∃ n : Nat, n = n ∧ True",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by obtain (h : True) | ⟨⟨⟩⟩ : True ∨ False; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "obtain (h : True) | ⟨⟨⟩⟩ : True ∨ False",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by obtain h | ⟨⟨⟩⟩ : True ∨ False := Or.inl trivial; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "obtain h | ⟨⟨⟩⟩ : True ∨ False := Or.inl trivial",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by obtain ⟨h, h2⟩ := And.intro trivial trivial; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "obtain ⟨h, h2⟩ := And.intro trivial trivial",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by fail_if_success obtain ⟨h, h2⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success obtain ⟨h, h2⟩",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (x y : α × β) : True := by rcases x, y with ⟨⟨a, b⟩, c, d⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x, y with ⟨⟨a, b⟩, c, d⟩",
  "core-prompt": "(x y : α × β) : True",
  "args": "(x y : α × β)"},
 {"type": "True",
  "tactic-prompt":
  "example (x y : α ⊕ β) : True := by rcases x, y with ⟨a|b, c|d⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x, y with ⟨a|b, c|d⟩",
  "core-prompt": "(x y : α ⊕ β) : True",
  "args": "(x y : α ⊕ β)"},
 {"type": "(Σ' x, i ≤ x ∧ x ≤ j) → i ≤ j",
  "tactic-prompt":
  "example (i j : Nat) : (Σ' x, i ≤ x ∧ x ≤ j) → i ≤ j := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt": "(i j : Nat) : (Σ' x, i ≤ x ∧ x ≤ j) → i ≤ j",
  "args": "(i j : Nat)"},
 {"type": "x = x",
  "tactic-prompt":
  "example (x : Quot fun _ _ : α => True)  (h : x = x) : x = x := by rcases x with ⟨z⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x with ⟨z⟩",
  "core-prompt": "(x : Quot fun _ _ : α => True)  (h : x = x) : x = x",
  "args": "(x : Quot fun _ _ : α => True)  (h : x = x)"},
 {"type": "True",
  "tactic-prompt":
  "example (n : Nat) : True := by obtain _one_lt_n | _n_le_one : 1 < n + 1 ∨ n + 1 ≤ 1 := Nat.lt_or_ge 1 (n + 1); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "obtain _one_lt_n | _n_le_one : 1 < n + 1 ∨ n + 1 ≤ 1 := Nat.lt_or_ge 1 (n + 1)",
  "core-prompt": "(n : Nat) : True",
  "args": "(n : Nat)"},
 {"type": "True",
  "tactic-prompt":
  "example (n : Nat) : True := by obtain _one_lt_n | (_n_le_one : n + 1 ≤ 1) := Nat.lt_or_ge 1 (n + 1); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "obtain _one_lt_n | (_n_le_one : n + 1 ≤ 1) := Nat.lt_or_ge 1 (n + 1)",
  "core-prompt": "(n : Nat) : True",
  "args": "(n : Nat)"},
 {"type": "(b : Bool) → cond b False False → True",
  "tactic-prompt":
  "example  : (b : Bool) → cond b False False → True := by rintro ⟨⟩ ⟨⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rintro ⟨⟩ ⟨⟩",
  "core-prompt": " : (b : Bool) → cond b False False → True",
  "args": ""},
 {"type": "True",
  "tactic-prompt": "example  : True := by cases (); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases ()",
  "core-prompt": " : True",
  "args": ""},
 {"type": "a ∧ (b ∧ c) ↔ b ∧ (a ∧ c)",
  "tactic-prompt":
  "theorem  : a ∧ (b ∧ c) ↔ b ∧ (a ∧ c) := by rw [← and_assoc]; sorry",
  "name": "and_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [← and_assoc]",
  "core-prompt": " : a ∧ (b ∧ c) ↔ b ∧ (a ∧ c)",
  "args": ""},
 {"type": "(a ∧ b) ∧ c ↔ (a ∧ c) ∧ b",
  "tactic-prompt":
  "theorem  : (a ∧ b) ∧ c ↔ (a ∧ c) ∧ b := by simp only [and_left_comm]; sorry",
  "name": "and_right_comm",
  "kind": "theorem",
  "first-tactic": "simp only [and_left_comm]",
  "core-prompt": " : (a ∧ b) ∧ c ↔ (a ∧ c) ∧ b",
  "args": ""},
 {"type": "a ∧ b ∧ c ↔ b ∧ c ∧ a",
  "tactic-prompt":
  "theorem  : a ∧ b ∧ c ↔ b ∧ c ∧ a := by simp only [and_left_comm]; sorry",
  "name": "and_rotate",
  "kind": "theorem",
  "first-tactic": "simp only [and_left_comm]",
  "core-prompt": " : a ∧ b ∧ c ↔ b ∧ c ∧ a",
  "args": ""},
 {"type": "(a ∧ b) ∧ c ∧ d ↔ (a ∧ c) ∧ b ∧ d",
  "tactic-prompt":
  "theorem  : (a ∧ b) ∧ c ∧ d ↔ (a ∧ c) ∧ b ∧ d := by rw [← and_assoc]; sorry",
  "name": "and_and_and_comm",
  "kind": "theorem",
  "first-tactic": "rw [← and_assoc]",
  "core-prompt": " : (a ∧ b) ∧ c ∧ d ↔ (a ∧ c) ∧ b ∧ d",
  "args": ""},
 {"type": "a ∧ b ∧ c ↔ (a ∧ b) ∧ a ∧ c",
  "tactic-prompt":
  "theorem  : a ∧ b ∧ c ↔ (a ∧ b) ∧ a ∧ c := by rw [and_and_and_comm]; sorry",
  "name": "and_and_left",
  "kind": "theorem",
  "first-tactic": "rw [and_and_and_comm]",
  "core-prompt": " : a ∧ b ∧ c ↔ (a ∧ b) ∧ a ∧ c",
  "args": ""},
 {"type": "(a ∧ b) ∧ c ↔ (a ∧ c) ∧ b ∧ c",
  "tactic-prompt":
  "theorem  : (a ∧ b) ∧ c ↔ (a ∧ c) ∧ b ∧ c := by rw [and_and_and_comm]; sorry",
  "name": "and_and_right",
  "kind": "theorem",
  "first-tactic": "rw [and_and_and_comm]",
  "core-prompt": " : (a ∧ b) ∧ c ↔ (a ∧ c) ∧ b ∧ c",
  "args": ""},
 {"type": "(p ↔ p ∧ q) ↔ (p → q)",
  "tactic-prompt":
  "theorem  : (p ↔ p ∧ q) ↔ (p → q) := by rw [@Iff.comm p]; sorry",
  "name": "iff_self_and",
  "kind": "theorem",
  "first-tactic": "rw [@Iff.comm p]",
  "core-prompt": " : (p ↔ p ∧ q) ↔ (p → q)",
  "args": ""},
 {"type": "(p ↔ q ∧ p) ↔ (p → q)",
  "tactic-prompt":
  "theorem  : (p ↔ q ∧ p) ↔ (p → q) := by rw [and_comm]; sorry",
  "name": "iff_and_self",
  "kind": "theorem",
  "first-tactic": "rw [and_comm]",
  "core-prompt": " : (p ↔ q ∧ p) ↔ (p → q)",
  "args": ""},
 {"type": "(a ∧ c ↔ b ∧ c) ↔ c → (a ↔ b)",
  "tactic-prompt":
  "theorem  : (a ∧ c ↔ b ∧ c) ↔ c → (a ↔ b) := by simp only [and_comm]; sorry",
  "name": "and_congr_left_iff",
  "kind": "theorem",
  "first-tactic": "simp only [and_comm]",
  "core-prompt": " : (a ∧ c ↔ b ∧ c) ↔ c → (a ↔ b)",
  "args": ""},
 {"type": "a ∨ (b ∨ c) ↔ b ∨ (a ∨ c)",
  "tactic-prompt":
  "theorem  : a ∨ (b ∨ c) ↔ b ∨ (a ∨ c) := by rw [← or_assoc]; sorry",
  "name": "or_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [← or_assoc]",
  "core-prompt": " : a ∨ (b ∨ c) ↔ b ∨ (a ∨ c)",
  "args": ""},
 {"type": "(a ∨ b) ∨ c ↔ (a ∨ c) ∨ b",
  "tactic-prompt":
  "theorem  : (a ∨ b) ∨ c ↔ (a ∨ c) ∨ b := by rw [or_assoc]; sorry",
  "name": "or_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [or_assoc]",
  "core-prompt": " : (a ∨ b) ∨ c ↔ (a ∨ c) ∨ b",
  "args": ""},
 {"type": "(a ∨ b) ∨ c ∨ d ↔ (a ∨ c) ∨ b ∨ d",
  "tactic-prompt":
  "theorem  : (a ∨ b) ∨ c ∨ d ↔ (a ∨ c) ∨ b ∨ d := by rw [← or_assoc]; sorry",
  "name": "or_or_or_comm",
  "kind": "theorem",
  "first-tactic": "rw [← or_assoc]",
  "core-prompt": " : (a ∨ b) ∨ c ∨ d ↔ (a ∨ c) ∨ b ∨ d",
  "args": ""},
 {"type": "a ∨ b ∨ c ↔ (a ∨ b) ∨ a ∨ c",
  "tactic-prompt":
  "theorem  : a ∨ b ∨ c ↔ (a ∨ b) ∨ a ∨ c := by rw [or_or_or_comm]; sorry",
  "name": "or_or_distrib_left",
  "kind": "theorem",
  "first-tactic": "rw [or_or_or_comm]",
  "core-prompt": " : a ∨ b ∨ c ↔ (a ∨ b) ∨ a ∨ c",
  "args": ""},
 {"type": "(a ∨ b) ∨ c ↔ (a ∨ c) ∨ b ∨ c",
  "tactic-prompt":
  "theorem  : (a ∨ b) ∨ c ↔ (a ∨ c) ∨ b ∨ c := by rw [or_or_or_comm]; sorry",
  "name": "or_or_distrib_right",
  "kind": "theorem",
  "first-tactic": "rw [or_or_or_comm]",
  "core-prompt": " : (a ∨ b) ∨ c ↔ (a ∨ c) ∨ b ∨ c",
  "args": ""},
 {"type": "a ∨ b ∨ c ↔ b ∨ c ∨ a",
  "tactic-prompt":
  "theorem  : a ∨ b ∨ c ↔ b ∨ c ∨ a := by simp only [or_left_comm]; sorry",
  "name": "or_rotate",
  "kind": "theorem",
  "first-tactic": "simp only [or_left_comm]",
  "core-prompt": " : a ∨ b ∨ c ↔ b ∨ c ∨ a",
  "args": ""},
 {"type": "(a ∨ b ↔ b) ↔ (a → b)",
  "tactic-prompt": "theorem  : (a ∨ b ↔ b) ↔ (a → b) := by rw [or_comm]; sorry",
  "name": "or_iff_right_iff_imp",
  "kind": "theorem",
  "first-tactic": "rw [or_comm]",
  "core-prompt": " : (a ∨ b ↔ b) ↔ (a → b)",
  "args": ""},
 {"type": "(a ∨ b) ∧ c ↔ (a ∧ c) ∨ (b ∧ c)",
  "tactic-prompt":
  "theorem  : (a ∨ b) ∧ c ↔ (a ∧ c) ∨ (b ∧ c) := by simp [and_comm]; sorry",
  "name": "or_and_right",
  "kind": "theorem",
  "first-tactic": "simp [and_comm]",
  "core-prompt": " : (a ∨ b) ∧ c ↔ (a ∧ c) ∨ (b ∧ c)",
  "args": ""},
 {"type": "(a ∧ b) ∨ c ↔ (a ∨ c) ∧ (b ∨ c)",
  "tactic-prompt":
  "theorem  : (a ∧ b) ∨ c ↔ (a ∨ c) ∧ (b ∨ c) := by simp [or_comm]; sorry",
  "name": "and_or_right",
  "kind": "theorem",
  "first-tactic": "simp [or_comm]",
  "core-prompt": " : (a ∧ b) ∨ c ↔ (a ∨ c) ∧ (b ∨ c)",
  "args": ""},
 {"type": "(∀ a, a' = a → p a) ↔ p a'",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {a' : α} : (∀ a, a' = a → p a) ↔ p a' := by simp [@eq_comm _ a']; sorry",
  "name": "forall_eq'",
  "kind": "theorem",
  "first-tactic": "simp [@eq_comm _ a']",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {a' : α} : (∀ a, a' = a → p a) ↔ p a'",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {a' : α}"},
 {"type": "(∃ x, p x ∧ b) ↔ (∃ x, p x) ∧ b",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ x, p x ∧ b) ↔ (∃ x, p x) ∧ b := by simp [And.comm]; sorry",
  "name": "exists_and_right",
  "kind": "theorem",
  "first-tactic": "simp [And.comm]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ x, p x ∧ b) ↔ (∃ x, p x) ∧ b",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _}"},
 {"type": "(∃ a, a' = a ∧ p a) ↔ p a'",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ a, a' = a ∧ p a) ↔ p a' := by simp [@eq_comm _ a']; sorry",
  "name": "exists_eq_left'",
  "kind": "theorem",
  "first-tactic": "simp [@eq_comm _ a']",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ a, a' = a ∧ p a) ↔ p a'",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _}"},
 {"type": "(∀ a, a = a' ∨ q a → p a) ↔ p a' ∧ ∀ a, q a → p a",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∀ a, a = a' ∨ q a → p a) ↔ p a' ∧ ∀ a, q a → p a := by simp only [or_imp]; sorry",
  "name": "forall_eq_or_imp",
  "kind": "theorem",
  "first-tactic": "simp only [or_imp]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∀ a, a = a' ∨ q a → p a) ↔ p a' ∧ ∀ a, q a → p a",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _}"},
 {"type": "(∃ a, (a = a' ∨ q a) ∧ p a) ↔ p a' ∨ ∃ a, q a ∧ p a",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ a, (a = a' ∨ q a) ∧ p a) ↔ p a' ∨ ∃ a, q a ∧ p a := by simp only [or_and_right]; sorry",
  "name": "exists_eq_or_imp",
  "kind": "theorem",
  "first-tactic": "simp only [or_and_right]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ a, (a = a' ∨ q a) ∧ p a) ↔ p a' ∨ ∃ a, q a ∧ p a",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _}"},
 {"type": "(∃ (a : α), p a ∧ b ∧ a = a') ↔ p a' ∧ b",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ (a : α), p a ∧ b ∧ a = a') ↔ p a' ∧ b := by simp [← and_assoc]; sorry",
  "name": "exists_eq_right_right",
  "kind": "theorem",
  "first-tactic": "simp [← and_assoc]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ (a : α), p a ∧ b ∧ a = a') ↔ p a' ∧ b",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _}"},
 {"type": "(∃ (a : α), p a ∧ b ∧ a' = a) ↔ p a' ∧ b",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ (a : α), p a ∧ b ∧ a' = a) ↔ p a' ∧ b := by (conv in _=_ => rw [eq_comm]); sorry",
  "name": "exists_eq_right_right'",
  "kind": "theorem",
  "first-tactic": "(conv in _=_ => rw [eq_comm])",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ (a : α), p a ∧ b ∧ a' = a) ↔ p a' ∧ b",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _}"},
 {"type": "(decide p = true) ↔ p",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (p : Prop)  [Decidable p] : (decide p = true) ↔ p := by simp; sorry",
  "name": "decide_eq_true_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (p : Prop)  [Decidable p] : (decide p = true) ↔ p",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (p : Prop)  [Decidable p]"},
 {"type": "(¬a → a) ↔ a",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a] : (¬a → a) ↔ a := by have := @imp_not_self (¬a); sorry",
  "name": "Decidable.not_imp_self",
  "kind": "theorem",
  "first-tactic": "have := @imp_not_self (¬a)",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a] : (¬a → a) ↔ a",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]"},
 {"type": "(a → b ∨ c) ↔ (a → b) ∨ (a → c)",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a] : (a → b ∨ c) ↔ (a → b) ∨ (a → c) := by by_cases a; sorry",
  "name": "Decidable.imp_or",
  "kind": "theorem",
  "first-tactic": "by_cases a",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a] : (a → b ∨ c) ↔ (a → b) ∨ (a → c)",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]"},
 {"type": "(¬a ↔ ¬b) ↔ (a ↔ b)",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : (¬a ↔ ¬b) ↔ (a ↔ b) := by rw [@iff_def (¬a)]; sorry",
  "name": "Decidable.not_iff_not",
  "kind": "theorem",
  "first-tactic": "rw [@iff_def (¬a)]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : (¬a ↔ ¬b) ↔ (a ↔ b)",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b]"},
 {"type": "(¬a ↔ b) ↔ (¬b ↔ a)",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : (¬a ↔ b) ↔ (¬b ↔ a) := by rw [@iff_def (¬a)]; sorry",
  "name": "Decidable.not_iff_comm",
  "kind": "theorem",
  "first-tactic": "rw [@iff_def (¬a)]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : (¬a ↔ b) ↔ (¬b ↔ a)",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b]"},
 {"type": "¬(a ↔ b) ↔ (¬a ↔ b)",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable b] : ¬(a ↔ b) ↔ (¬a ↔ b) := by by_cases h : b; sorry",
  "name": "Decidable.not_iff",
  "kind": "theorem",
  "first-tactic": "by_cases h : b",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable b] : ¬(a ↔ b) ↔ (¬a ↔ b)",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable b]"},
 {"type": "(a ↔ ¬b) ↔ (b ↔ ¬a)",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : (a ↔ ¬b) ↔ (b ↔ ¬a) := by rw [@iff_def a]; sorry",
  "name": "Decidable.iff_not_comm",
  "kind": "theorem",
  "first-tactic": "rw [@iff_def a]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : (a ↔ ¬b) ↔ (b ↔ ¬a)",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b]"},
 {"type": "(a ↔ b) ↔ (¬a ∨ b) ∧ (a ∨ ¬b)",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : (a ↔ b) ↔ (¬a ∨ b) ∧ (a ∨ ¬b) := by rw [iff_iff_implies_and_implies a b]; sorry",
  "name": "Decidable.iff_iff_not_or_and_or_not",
  "kind": "theorem",
  "first-tactic": "rw [iff_iff_implies_and_implies a b]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : (a ↔ b) ↔ (¬a ∨ b) ∧ (a ∨ ¬b)",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b]"},
 {"type": "a ∨ b ↔ ¬(¬a ∧ ¬b)",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : a ∨ b ↔ ¬(¬a ∧ ¬b) := by rw [← not_or]; sorry",
  "name": "Decidable.or_iff_not_and_not",
  "kind": "theorem",
  "first-tactic": "rw [← not_or]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : a ∨ b ↔ ¬(¬a ∧ ¬b)",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b]"},
 {"type": "a ∧ b ↔ ¬(¬a ∨ ¬b)",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : a ∧ b ↔ ¬(¬a ∨ ¬b) := by rw [← not_and]; sorry",
  "name": "Decidable.and_iff_not_or_not",
  "kind": "theorem",
  "first-tactic": "rw [← not_and]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : a ∧ b ↔ ¬(¬a ∨ ¬b)",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b]"},
 {"type": "a ∨ c ↔ b ∨ c",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable c]  (h : ¬c → (a ↔ b)) : a ∨ c ↔ b ∨ c := by rw [or_iff_not_imp_right]; sorry",
  "name": "Decidable.or_congr_left'",
  "kind": "theorem",
  "first-tactic": "rw [or_iff_not_imp_right]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable c]  (h : ¬c → (a ↔ b)) : a ∨ c ↔ b ∨ c",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable c]  (h : ¬c → (a ↔ b))"},
 {"type": "a ∨ b ↔ a ∨ c",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  (h : ¬a → (b ↔ c)) : a ∨ b ↔ a ∨ c := by rw [or_iff_not_imp_left]; sorry",
  "name": "Decidable.or_congr_right'",
  "kind": "theorem",
  "first-tactic": "rw [or_iff_not_imp_left]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  (h : ¬a → (b ↔ c)) : a ∨ b ↔ a ∨ c",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  (h : ¬a → (b ↔ c))"},
 {"type": "HEq hp hq",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {p q : Prop}  (hp : p)  (hq : q) : HEq hp hq := by cases propext (iff_of_true hp hq); sorry",
  "name": "proof_irrel_heq",
  "kind": "theorem",
  "first-tactic": "cases propext (iff_of_true hp hq)",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {p q : Prop}  (hp : p)  (hq : q) : HEq hp hq",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {p q : Prop}  (hp : p)  (hq : q)"},
 {"type": "(@Eq.rec α a (fun α _ => β) y a' h) = y",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {α : Sort _}  {a a' : α}  {β : Sort _}  (y : β)  (h : a = a') : (@Eq.rec α a (fun α _ => β) y a' h) = y := by cases h; sorry",
  "name": "eq_rec_constant",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {α : Sort _}  {a a' : α}  {β : Sort _}  (y : β)  (h : a = a') : (@Eq.rec α a (fun α _ => β) y a' h) = y",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {α : Sort _}  {a a' : α}  {β : Sort _}  (y : β)  (h : a = a')"},
 {"type": "f x y = f x' y'",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (f : α → β → γ)  {x x' : α}  {y y' : β}      (hx : x = x')  (hy : y = y') : f x y = f x' y' := by subst hx hy; sorry",
  "name": "congrArg₂",
  "kind": "theorem",
  "first-tactic": "subst hx hy",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (f : α → β → γ)  {x x' : α}  {y y' : β}      (hx : x = x')  (hy : y = y') : f x y = f x' y'",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (f : α → β → γ)  {x x' : α}  {y y' : β}      (hx : x = x')  (hy : y = y')"},
 {"type": "f (dite P x y) = dite P (fun h => f (x h)) (fun h => f (y h))",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (f : α → β)  (P : Prop)  [Decidable P]  (x : P → α)  (y : ¬P → α) : f (dite P x y) = dite P (fun h => f (x h)) (fun h => f (y h)) := by by_cases h : P; sorry",
  "name": "apply_dite",
  "kind": "theorem",
  "first-tactic": "by_cases h : P",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (f : α → β)  (P : Prop)  [Decidable P]  (x : P → α)  (y : ¬P → α) : f (dite P x y) = dite P (fun h => f (x h)) (fun h => f (y h))",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (f : α → β)  (P : Prop)  [Decidable P]  (x : P → α)  (y : ¬P → α)"},
 {"type": "dite (¬P) x y = dite P (fun h => y (not_not_intro h)) x",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (P : Prop)  [Decidable P]   (x : ¬P → α)  (y : ¬¬P → α) : dite (¬P) x y = dite P (fun h => y (not_not_intro h)) x := by by_cases h : P; sorry",
  "name": "dite_not",
  "kind": "theorem",
  "first-tactic": "by_cases h : P",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (P : Prop)  [Decidable P]   (x : ¬P → α)  (y : ¬¬P → α) : dite (¬P) x y = dite P (fun h => y (not_not_intro h)) x",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (P : Prop)  [Decidable P]   (x : ¬P → α)  (y : ¬¬P → α)"},
 {"type": "(a == b) = false ↔ a ≠ b",
  "tactic-prompt":
  "theorem [BEq α]  [LawfulBEq α]      (a b : α) : (a == b) = false ↔ a ≠ b := by rw [ne_eq]; sorry",
  "name": "beq_eq_false_iff_ne",
  "kind": "theorem",
  "first-tactic": "rw [ne_eq]",
  "core-prompt":
  "[BEq α]  [LawfulBEq α]      (a b : α) : (a == b) = false ↔ a ≠ b",
  "args": "[BEq α]  [LawfulBEq α]      (a b : α)"},
 {"type": "SatisfiesM q (f <$> x)",
  "tactic-prompt":
  "theorem [Functor m]  [LawfulFunctor m]  {x : m α}      (hx : SatisfiesM p x)  (hf : ∀ {a}, p a → q (f a)) : SatisfiesM q (f <$> x) := by let ⟨x', hx⟩ := hx; sorry",
  "name": "map",
  "kind": "theorem",
  "first-tactic": "let ⟨x', hx⟩ := hx",
  "core-prompt":
  "[Functor m]  [LawfulFunctor m]  {x : m α}      (hx : SatisfiesM p x)  (hf : ∀ {a}, p a → q (f a)) : SatisfiesM q (f <$> x)",
  "args":
  "[Functor m]  [LawfulFunctor m]  {x : m α}      (hx : SatisfiesM p x)  (hf : ∀ {a}, p a → q (f a))"},
 {"type": "SatisfiesM q (f <*> x)",
  "tactic-prompt":
  "theorem [Applicative m]  [LawfulApplicative m]  {x : m α}      (hf : SatisfiesM p₁ f)  (hx : SatisfiesM p₂ x)      (H : ∀ {f a}, p₁ f → p₂ a → q (f a)) : SatisfiesM q (f <*> x) := by match f, x, hf, hx with | _, _, ⟨f, rfl⟩, ⟨x, rfl⟩ => ?_; sorry",
  "name": "seq",
  "kind": "theorem",
  "first-tactic": "match f, x, hf, hx with | _, _, ⟨f, rfl⟩, ⟨x, rfl⟩ => ?_",
  "core-prompt":
  "[Applicative m]  [LawfulApplicative m]  {x : m α}      (hf : SatisfiesM p₁ f)  (hx : SatisfiesM p₂ x)      (H : ∀ {f a}, p₁ f → p₂ a → q (f a)) : SatisfiesM q (f <*> x)",
  "args":
  "[Applicative m]  [LawfulApplicative m]  {x : m α}      (hf : SatisfiesM p₁ f)  (hx : SatisfiesM p₂ x)      (H : ∀ {f a}, p₁ f → p₂ a → q (f a))"},
 {"type": "SatisfiesM q (x >>= f)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  {f : α → m β}      (hx : SatisfiesM p x)  (hf : ∀ a, p a → SatisfiesM q (f a)) : SatisfiesM q (x >>= f) := by match x, hx with | _, ⟨x, rfl⟩ => ?_; sorry",
  "name": "bind",
  "kind": "theorem",
  "first-tactic": "match x, hx with | _, ⟨x, rfl⟩ => ?_",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  {f : α → m β}      (hx : SatisfiesM p x)  (hf : ∀ a, p a → SatisfiesM q (f a)) : SatisfiesM q (x >>= f)",
  "args":
  "[Monad m]  [LawfulMonad m]  {f : α → m β}      (hx : SatisfiesM p x)  (hf : ∀ a, p a → SatisfiesM q (f a))"},
 {"type": "SatisfiesM (m := StateRefT' ω σ m) p x ↔ ∀ s, SatisfiesM p (x s)",
  "tactic-prompt":
  "theorem [Monad m] : SatisfiesM (m := StateRefT' ω σ m) p x ↔ ∀ s, SatisfiesM p (x s) := by simp; sorry",
  "name": "SatisfiesM_StateRefT_eq",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "[Monad m] : SatisfiesM (m := StateRefT' ω σ m) p x ↔ ∀ s, SatisfiesM p (x s)",
  "args": "[Monad m]"},
 {"type":
  "SatisfiesM (m := StateT ρ m) (α := α) p x ↔ ∀ s, SatisfiesM (m := m) (p ·.1) (x s)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m] : SatisfiesM (m := StateT ρ m) (α := α) p x ↔ ∀ s, SatisfiesM (m := m) (p ·.1) (x s) := by refine .trans ⟨fun ⟨f, eq⟩ => eq ▸ ?_, fun ⟨f, h⟩ => ?_⟩ Classical.skolem.symm; sorry",
  "name": "SatisfiesM_StateT_eq",
  "kind": "theorem",
  "first-tactic":
  "refine .trans ⟨fun ⟨f, eq⟩ => eq ▸ ?_, fun ⟨f, h⟩ => ?_⟩ Classical.skolem.symm",
  "core-prompt":
  "[Monad m]  [LawfulMonad m] : SatisfiesM (m := StateT ρ m) (α := α) p x ↔ ∀ s, SatisfiesM (m := m) (p ·.1) (x s)",
  "args": "[Monad m]  [LawfulMonad m]"},
 {"type":
  "SatisfiesM (m := ExceptT ρ m) (α := α) p x ↔ SatisfiesM (m := m) (∀ a, · = .ok a → p a) x",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m] : SatisfiesM (m := ExceptT ρ m) (α := α) p x ↔ SatisfiesM (m := m) (∀ a, · = .ok a → p a) x := by refine ⟨fun ⟨f, eq⟩ => eq ▸ ?_, fun ⟨f, eq⟩ => eq ▸ ?_⟩; sorry",
  "name": "SatisfiesM_ExceptT_eq",
  "kind": "theorem",
  "first-tactic": "refine ⟨fun ⟨f, eq⟩ => eq ▸ ?_, fun ⟨f, eq⟩ => eq ▸ ?_⟩",
  "core-prompt":
  "[Monad m]  [LawfulMonad m] : SatisfiesM (m := ExceptT ρ m) (α := α) p x ↔ SatisfiesM (m := m) (∀ a, · = .ok a → p a) x",
  "args": "[Monad m]  [LawfulMonad m]"},
 {"type": "o.swap.swap = o",
  "tactic-prompt":
  "theorem {o : Ordering} : o.swap.swap = o := by cases o; sorry",
  "name": "Ordering.swap_swap",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": "{o : Ordering} : o.swap.swap = o",
  "args": "{o : Ordering}"},
 {"type": "cmp x y = .gt ↔ cmp y x = .lt",
  "tactic-prompt":
  "theorem [OrientedCmp cmp] : cmp x y = .gt ↔ cmp y x = .lt := by rw [← Ordering.swap_inj]; sorry",
  "name": "cmp_eq_gt",
  "kind": "theorem",
  "first-tactic": "rw [← Ordering.swap_inj]",
  "core-prompt": "[OrientedCmp cmp] : cmp x y = .gt ↔ cmp y x = .lt",
  "args": "[OrientedCmp cmp]"},
 {"type": "cmp x y = .eq ↔ cmp y x = .eq",
  "tactic-prompt":
  "theorem [OrientedCmp cmp] : cmp x y = .eq ↔ cmp y x = .eq := by rw [← Ordering.swap_inj]; sorry",
  "name": "cmp_eq_eq_symm",
  "kind": "theorem",
  "first-tactic": "rw [← Ordering.swap_inj]",
  "core-prompt": "[OrientedCmp cmp] : cmp x y = .eq ↔ cmp y x = .eq",
  "args": "[OrientedCmp cmp]"},
 {"type": "cmp x z ≠ .lt",
  "tactic-prompt":
  "theorem [TransCmp cmp] (h₁ : cmp x y ≠ .lt)  (h₂ : cmp y z ≠ .lt) : cmp x z ≠ .lt := by have := @TransCmp.le_trans _ cmp _ z y x; sorry",
  "name": "ge_trans",
  "kind": "theorem",
  "first-tactic": "have := @TransCmp.le_trans _ cmp _ z y x",
  "core-prompt":
  "[TransCmp cmp] (h₁ : cmp x y ≠ .lt)  (h₂ : cmp y z ≠ .lt) : cmp x z ≠ .lt",
  "args": "[TransCmp cmp] (h₁ : cmp x y ≠ .lt)  (h₂ : cmp y z ≠ .lt)"},
 {"type": "cmp x z = .gt",
  "tactic-prompt":
  "theorem [TransCmp cmp] (h₁ : cmp x y = .gt)  (h₂ : cmp y z = .gt) : cmp x z = .gt := by rw [cmp_eq_gt] at h₁ h₂ ⊢; sorry",
  "name": "gt_trans",
  "kind": "theorem",
  "first-tactic": "rw [cmp_eq_gt] at h₁ h₂ ⊢",
  "core-prompt":
  "[TransCmp cmp] (h₁ : cmp x y = .gt)  (h₂ : cmp y z = .gt) : cmp x z = .gt",
  "args": "[TransCmp cmp] (h₁ : cmp x y = .gt)  (h₂ : cmp y z = .gt)"},
 {"type": "cmp x y = cmp x z",
  "tactic-prompt":
  "theorem [TransCmp cmp] [TransCmp cmp]  (yz : cmp y z = .eq) : cmp x y = cmp x z := by rw [← Ordering.swap_inj]; sorry",
  "name": "cmp_congr_right",
  "kind": "theorem",
  "first-tactic": "rw [← Ordering.swap_inj]",
  "core-prompt":
  "[TransCmp cmp] [TransCmp cmp]  (yz : cmp y z = .eq) : cmp x y = cmp x z",
  "args": "[TransCmp cmp] [TransCmp cmp]  (yz : cmp y z = .eq)"},
 {"type": "WF (empty n : Imp α β)",
  "tactic-prompt":
  "theorem [BEq α]  [Hashable α] : WF (empty n : Imp α β) := by unfold empty; sorry",
  "name": "WF.empty",
  "kind": "theorem",
  "first-tactic": "unfold empty",
  "core-prompt": "[BEq α]  [Hashable α] : WF (empty n : Imp α β)",
  "args": "[BEq α]  [Hashable α]"},
 {"type": "(reinsertAux data a b).size = data.size.succ",
  "tactic-prompt":
  "theorem [Hashable α]  (data : Bucket α β)  (a : α)  (b : β) : (reinsertAux data a b).size = data.size.succ := by simp [Bucket.size_eq]; sorry",
  "name": "reinsertAux_size",
  "kind": "theorem",
  "first-tactic": "simp [Bucket.size_eq]",
  "core-prompt":
  "[Hashable α]  (data : Bucket α β)  (a : α)  (b : β) : (reinsertAux data a b).size = data.size.succ",
  "args": "[Hashable α]  (data : Bucket α β)  (a : α)  (b : β)"},
 {"type": "(expand sz buckets).buckets.size = buckets.size",
  "tactic-prompt":
  "theorem [Hashable α]  {buckets : Bucket α β} : (expand sz buckets).buckets.size = buckets.size := by rw [expand]; sorry",
  "name": "expand_size",
  "kind": "theorem",
  "first-tactic": "rw [expand]",
  "core-prompt":
  "[Hashable α]  {buckets : Bucket α β} : (expand sz buckets).buckets.size = buckets.size",
  "args": "[Hashable α]  {buckets : Bucket α β}"},
 {"type":
  "(l.foldl (fun d x => reinsertAux d x.1 x.2) target).WF ∧\n    ∀ bucket ∈ (l.foldl (fun d x => reinsertAux d x.1 x.2) target).1.data,\n      bucket.All fun k _ => rank k ≤ i",
  "tactic-prompt":
  "theorem [BEq α]  [Hashable α]  (rank : α → Nat)  {l : List (α × β)}  {i : Nat}      (hl₁ : ∀ [PartialEquivBEq α] [LawfulHashable α], l.Pairwise fun a b => ¬(a.1 == b.1))      (hl₂ : ∀ x ∈ l, rank x.1 = i)      {target : Bucket α β}  (ht₁ : target.WF)      (ht₂ : ∀ bucket ∈ target.1.data,       bucket.All fun k _ => rank k ≤ i ∧         ∀ [PartialEquivBEq α] [LawfulHashable α], ∀ x ∈ l, ¬(x.1 == k)) : (l.foldl (fun d x => reinsertAux d x.1 x.2) target).WF ∧\n    ∀ bucket ∈ (l.foldl (fun d x => reinsertAux d x.1 x.2) target).1.data,\n      bucket.All fun k _ => rank k ≤ i := by induction l generalizing target with\n  | nil => exact ⟨ht₁, fun _ h₁ _ h₂ => (ht₂ _ h₁ _ h₂).1⟩\n  | cons _ _ ih =>\n    simp at hl₁ hl₂ ht₂\n    refine ih hl₁.2 hl₂.2\n      (reinsertAux_WF ht₁ fun _ h => (ht₂ _ (Array.getElem_mem_data ..) _ h).2.1)\n      (fun _ h => ?_)\n    simp [reinsertAux, Bucket.update] at h\n    match List.mem_or_eq_of_mem_set h with\n    | .inl h =>\n      intro _ hf\n      have ⟨h₁, h₂⟩ := ht₂ _ h _ hf\n      exact ⟨h₁, h₂.2⟩\n    | .inr h => subst h; intro\n      | _, .head .. =>\n        exact ⟨hl₂.1 ▸ Nat.le_refl _, fun _ h h' => hl₁.1 _ h (PartialEquivBEq.symm h')⟩\n      | _, .tail _ h =>\n        have ⟨h₁, h₂⟩ := ht₂ _ (Array.getElem_mem_data ..) _ h\n        exact ⟨h₁, h₂.2⟩; sorry",
  "name": "expand_WF.foldl",
  "kind": "theorem",
  "first-tactic":
  "induction l generalizing target with\n  | nil => exact ⟨ht₁, fun _ h₁ _ h₂ => (ht₂ _ h₁ _ h₂).1⟩\n  | cons _ _ ih =>\n    simp at hl₁ hl₂ ht₂\n    refine ih hl₁.2 hl₂.2\n      (reinsertAux_WF ht₁ fun _ h => (ht₂ _ (Array.getElem_mem_data ..) _ h).2.1)\n      (fun _ h => ?_)\n    simp [reinsertAux, Bucket.update] at h\n    match List.mem_or_eq_of_mem_set h with\n    | .inl h =>\n      intro _ hf\n      have ⟨h₁, h₂⟩ := ht₂ _ h _ hf\n      exact ⟨h₁, h₂.2⟩\n    | .inr h => subst h; intro\n      | _, .head .. =>\n        exact ⟨hl₂.1 ▸ Nat.le_refl _, fun _ h h' => hl₁.1 _ h (PartialEquivBEq.symm h')⟩\n      | _, .tail _ h =>\n        have ⟨h₁, h₂⟩ := ht₂ _ (Array.getElem_mem_data ..) _ h\n        exact ⟨h₁, h₂.2⟩",
  "core-prompt":
  "[BEq α]  [Hashable α]  (rank : α → Nat)  {l : List (α × β)}  {i : Nat}      (hl₁ : ∀ [PartialEquivBEq α] [LawfulHashable α], l.Pairwise fun a b => ¬(a.1 == b.1))      (hl₂ : ∀ x ∈ l, rank x.1 = i)      {target : Bucket α β}  (ht₁ : target.WF)      (ht₂ : ∀ bucket ∈ target.1.data,       bucket.All fun k _ => rank k ≤ i ∧         ∀ [PartialEquivBEq α] [LawfulHashable α], ∀ x ∈ l, ¬(x.1 == k)) : (l.foldl (fun d x => reinsertAux d x.1 x.2) target).WF ∧\n    ∀ bucket ∈ (l.foldl (fun d x => reinsertAux d x.1 x.2) target).1.data,\n      bucket.All fun k _ => rank k ≤ i",
  "args":
  "[BEq α]  [Hashable α]  (rank : α → Nat)  {l : List (α × β)}  {i : Nat}      (hl₁ : ∀ [PartialEquivBEq α] [LawfulHashable α], l.Pairwise fun a b => ¬(a.1 == b.1))      (hl₂ : ∀ x ∈ l, rank x.1 = i)      {target : Bucket α β}  (ht₁ : target.WF)      (ht₂ : ∀ bucket ∈ target.1.data,       bucket.All fun k _ => rank k ≤ i ∧         ∀ [PartialEquivBEq α] [LawfulHashable α], ∀ x ∈ l, ¬(x.1 == k))"},
 {"type":
  "x ∈ (l.replaceF fun a => bif p a then some (k, v) else none) → x.1 = k ∨ x ∈ l",
  "tactic-prompt":
  "theorem {l : List (α × β)}  {x : α × β}  {p : α × β → Bool} : x ∈ (l.replaceF fun a => bif p a then some (k, v) else none) → x.1 = k ∨ x ∈ l := by induction l; sorry",
  "name": "mem_replaceF",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{l : List (α × β)}  {x : α × β}  {p : α × β → Bool} : x ∈ (l.replaceF fun a => bif p a then some (k, v) else none) → x.1 = k ∨ x ∈ l",
  "args": "{l : List (α × β)}  {x : α × β}  {p : α × β → Bool}"},
 {"type":
  "(l.replaceF fun a => bif a.fst == k then some (k, v) else none)\n      |>.Pairwise fun a b => ¬(a.fst == b.fst)",
  "tactic-prompt":
  "theorem [BEq α]  [PartialEquivBEq α]      {l : List (α × β)}  {x : α × β}  (hx₁ : x ∈ l)  (hx₂ : x.fst == k)      (H : l.Pairwise fun a b => ¬(a.fst == b.fst)) : (l.replaceF fun a => bif a.fst == k then some (k, v) else none)\n      |>.Pairwise fun a b => ¬(a.fst == b.fst) := by induction hx₁; sorry",
  "name": "pairwise_replaceF",
  "kind": "theorem",
  "first-tactic": "induction hx₁",
  "core-prompt":
  "[BEq α]  [PartialEquivBEq α]      {l : List (α × β)}  {x : α × β}  (hx₁ : x ∈ l)  (hx₂ : x.fst == k)      (H : l.Pairwise fun a b => ¬(a.fst == b.fst)) : (l.replaceF fun a => bif a.fst == k then some (k, v) else none)\n      |>.Pairwise fun a b => ¬(a.fst == b.fst)",
  "args":
  "[BEq α]  [PartialEquivBEq α]      {l : List (α × β)}  {x : α × β}  (hx₁ : x ∈ l)  (hx₂ : x.fst == k)      (H : l.Pairwise fun a b => ¬(a.fst == b.fst))"},
 {"type": "m.size = m.buckets.size ∧ m.buckets.WF",
  "tactic-prompt":
  "theorem [BEq α]  [Hashable α]  {m : Imp α β}  (h : m.WF) : m.size = m.buckets.size ∧ m.buckets.WF := by induction h; sorry",
  "name": "WF.out",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "[BEq α]  [Hashable α]  {m : Imp α β}  (h : m.WF) : m.size = m.buckets.size ∧ m.buckets.WF",
  "args": "[BEq α]  [Hashable α]  {m : Imp α β}  (h : m.WF)"},
 {"type": "s.realSize = s'.realSize + 1",
  "tactic-prompt":
  "theorem {s : Heap α}  (eq : s.deleteMin le = some (a, s')) : s.realSize = s'.realSize + 1 := by cases s; sorry",
  "name": "Heap.realSize_deleteMin",
  "kind": "theorem",
  "first-tactic": "cases s",
  "core-prompt":
  "{s : Heap α}  (eq : s.deleteMin le = some (a, s')) : s.realSize = s'.realSize + 1",
  "args": "{s : Heap α}  (eq : s.deleteMin le = some (a, s'))"},
 {"type": "s.tail? le = some s' →\n    s.realSize = s'.realSize + 1",
  "tactic-prompt":
  "theorem {s : Heap α} : s.tail? le = some s' →\n    s.realSize = s'.realSize + 1 := by simp only [Heap.tail?]; sorry",
  "name": "Heap.realSize_tail?",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail?]",
  "core-prompt":
  "{s : Heap α} : s.tail? le = some s' →\n    s.realSize = s'.realSize + 1",
  "args": "{s : Heap α}"},
 {"type":
  "(merge le s₁ s₂).WellFormed le n ∧\n    ((s₁.rankGT n ↔ s₂.rankGT n) → (merge le s₁ s₂).rankGT n)",
  "tactic-prompt":
  "theorem (h₁ : s₁.WellFormed le n)  (h₂ : s₂.WellFormed le n) : (merge le s₁ s₂).WellFormed le n ∧\n    ((s₁.rankGT n ↔ s₂.rankGT n) → (merge le s₁ s₂).rankGT n) := by unfold merge; sorry",
  "name": "Heap.WellFormed.merge'",
  "kind": "theorem",
  "first-tactic": "unfold merge",
  "core-prompt":
  "(h₁ : s₁.WellFormed le n)  (h₂ : s₂.WellFormed le n) : (merge le s₁ s₂).WellFormed le n ∧\n    ((s₁.rankGT n ↔ s₂.rankGT n) → (merge le s₁ s₂).rankGT n)",
  "args": "(h₁ : s₁.WellFormed le n)  (h₂ : s₂.WellFormed le n)"},
 {"type": "s.toHeap.WellFormed le 0",
  "tactic-prompt":
  "theorem {s : HeapNode α}      (h : s.WellFormed le a n) : s.toHeap.WellFormed le 0 := by rw [toHeap]; sorry",
  "name": "HeapNode.WellFormed.toHeap",
  "kind": "theorem",
  "first-tactic": "rw [toHeap]",
  "core-prompt":
  "{s : HeapNode α}      (h : s.WellFormed le a n) : s.toHeap.WellFormed le 0",
  "args": "{s : HeapNode α}      (h : s.WellFormed le a n)"},
 {"type": "s'.WellFormed le 0",
  "tactic-prompt":
  "theorem {s : Heap α}      (h : s.WellFormed le n)  (eq : s.deleteMin le = some (a, s')) : s'.WellFormed le 0 := by cases s; sorry",
  "name": "Heap.WellFormed.deleteMin",
  "kind": "theorem",
  "first-tactic": "cases s",
  "core-prompt":
  "{s : Heap α}      (h : s.WellFormed le n)  (eq : s.deleteMin le = some (a, s')) : s'.WellFormed le 0",
  "args":
  "{s : Heap α}      (h : s.WellFormed le n)  (eq : s.deleteMin le = some (a, s'))"},
 {"type": "s.tail? le = some tl →\n  tl.WellFormed le 0",
  "tactic-prompt":
  "theorem (hwf : (s : Heap α).WellFormed le n) : s.tail? le = some tl →\n  tl.WellFormed le 0 := by simp only [Heap.tail?]; sorry",
  "name": "Heap.WellFormed.tail?",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail?]",
  "core-prompt":
  "(hwf : (s : Heap α).WellFormed le n) : s.tail? le = some tl →\n  tl.WellFormed le 0",
  "args": "(hwf : (s : Heap α).WellFormed le n)"},
 {"type": "(s.tail le).WellFormed le 0",
  "tactic-prompt":
  "theorem (hwf : (s : Heap α).WellFormed le n) : (s.tail le).WellFormed le 0 := by simp only [Heap.tail]; sorry",
  "name": "Heap.WellFormed.tail",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail]",
  "core-prompt":
  "(hwf : (s : Heap α).WellFormed le n) : (s.tail le).WellFormed le 0",
  "args": "(hwf : (s : Heap α).WellFormed le n)"},
 {"type": "(gcd m n ∣ m) ∧ (gcd m n ∣ n)",
  "tactic-prompt":
  "theorem (m n : Nat) : (gcd m n ∣ m) ∧ (gcd m n ∣ n) := by induction m, n using gcd.induction with\n  | H0 n => rw [gcd_zero_left]; exact ⟨Nat.dvd_zero n, Nat.dvd_refl n⟩\n  | H1 m n _ IH => rw [← gcd_rec] at IH; exact ⟨IH.2, (dvd_mod_iff IH.2).1 IH.1⟩; sorry",
  "name": "gcd_dvd",
  "kind": "theorem",
  "first-tactic":
  "induction m, n using gcd.induction with\n  | H0 n => rw [gcd_zero_left]; exact ⟨Nat.dvd_zero n, Nat.dvd_refl n⟩\n  | H1 m n _ IH => rw [← gcd_rec] at IH; exact ⟨IH.2, (dvd_mod_iff IH.2).1 IH.1⟩",
  "core-prompt": "(m n : Nat) : (gcd m n ∣ m) ∧ (gcd m n ∣ n)",
  "args": "(m n : Nat)"},
 {"type": "k ∣ m → k ∣ n → k ∣ gcd m n",
  "tactic-prompt":
  "theorem  : k ∣ m → k ∣ n → k ∣ gcd m n := by induction m, n using gcd.induction with intro km kn\n  | H0 n => rw [gcd_zero_left]; exact kn\n  | H1 n m _ IH => rw [gcd_rec]; exact IH ((dvd_mod_iff km).2 kn) km; sorry",
  "name": "dvd_gcd",
  "kind": "theorem",
  "first-tactic":
  "induction m, n using gcd.induction with intro km kn\n  | H0 n => rw [gcd_zero_left]; exact kn\n  | H1 n m _ IH => rw [gcd_rec]; exact IH ((dvd_mod_iff km).2 kn) km",
  "core-prompt": " : k ∣ m → k ∣ n → k ∣ gcd m n",
  "args": ""},
 {"type": "m ∣ n ↔ gcd n m = m",
  "tactic-prompt": "theorem  : m ∣ n ↔ gcd n m = m := by rw [gcd_comm]; sorry",
  "name": "gcd_eq_right_iff_dvd",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": " : m ∣ n ↔ gcd n m = m",
  "args": ""},
 {"type": "gcd (m * n) (m * k) = m * gcd n k",
  "tactic-prompt":
  "theorem (m n k : Nat) : gcd (m * n) (m * k) = m * gcd n k := by induction n, k using gcd.induction with\n  | H0 k => simp\n  | H1 n k _ IH => rwa [← mul_mod_mul_left, ← gcd_rec, ← gcd_rec] at IH; sorry",
  "name": "gcd_mul_left",
  "kind": "theorem",
  "first-tactic":
  "induction n, k using gcd.induction with\n  | H0 k => simp\n  | H1 n k _ IH => rwa [← mul_mod_mul_left, ← gcd_rec, ← gcd_rec] at IH",
  "core-prompt": "(m n k : Nat) : gcd (m * n) (m * k) = m * gcd n k",
  "args": "(m n k : Nat)"},
 {"type": "gcd (m * n) (k * n) = gcd m k * n",
  "tactic-prompt":
  "theorem (m n k : Nat) : gcd (m * n) (k * n) = gcd m k * n := by rw [Nat.mul_comm m n]; sorry",
  "name": "gcd_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm m n]",
  "core-prompt": "(m n k : Nat) : gcd (m * n) (k * n) = gcd m k * n",
  "args": "(m n k : Nat)"},
 {"type": "n = 0",
  "tactic-prompt":
  "theorem {m n : Nat}  (H : gcd m n = 0) : n = 0 := by rw [gcd_comm] at H; sorry",
  "name": "eq_zero_of_gcd_eq_zero_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm] at H",
  "core-prompt": "{m n : Nat}  (H : gcd m n = 0) : n = 0",
  "args": "{m n : Nat}  (H : gcd m n = 0)"},
 {"type": "gcd m n = n",
  "tactic-prompt":
  "theorem {m n : Nat}  (H : n ∣ m) : gcd m n = n := by rw [gcd_comm]; sorry",
  "name": "gcd_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "{m n : Nat}  (H : n ∣ m) : gcd m n = n",
  "args": "{m n : Nat}  (H : n ∣ m)"},
 {"type": "gcd n (m * n) = n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd n (m * n) = n := by rw [gcd_comm]; sorry",
  "name": "gcd_mul_left_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n : Nat) : gcd n (m * n) = n",
  "args": "(m n : Nat)"},
 {"type": "gcd (n * m) n = n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd (n * m) n = n := by rw [Nat.mul_comm]; sorry",
  "name": "gcd_mul_right_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(m n : Nat) : gcd (n * m) n = n",
  "args": "(m n : Nat)"},
 {"type": "gcd n (n * m) = n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd n (n * m) = n := by rw [gcd_comm]; sorry",
  "name": "gcd_mul_right_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n : Nat) : gcd n (n * m) = n",
  "args": "(m n : Nat)"},
 {"type": "gcd m (gcd n m) = gcd n m",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd m (gcd n m) = gcd n m := by rw [gcd_comm n m]; sorry",
  "name": "gcd_gcd_self_right_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm n m]",
  "core-prompt": "(m n : Nat) : gcd m (gcd n m) = gcd n m",
  "args": "(m n : Nat)"},
 {"type": "gcd (gcd n m) m = gcd n m",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd (gcd n m) m = gcd n m := by rw [gcd_comm]; sorry",
  "name": "gcd_gcd_self_left_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n : Nat) : gcd (gcd n m) m = gcd n m",
  "args": "(m n : Nat)"},
 {"type": "gcd (gcd m n) m = gcd m n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd (gcd m n) m = gcd m n := by rw [gcd_comm m n]; sorry",
  "name": "gcd_gcd_self_left_left",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm m n]",
  "core-prompt": "(m n : Nat) : gcd (gcd m n) m = gcd m n",
  "args": "(m n : Nat)"},
 {"type": "gcd m (n + k * m) = gcd m n",
  "tactic-prompt":
  "theorem (m n k : Nat) : gcd m (n + k * m) = gcd m n := by simp [gcd_rec m (n + k * m)]; sorry",
  "name": "gcd_add_mul_self",
  "kind": "theorem",
  "first-tactic": "simp [gcd_rec m (n + k * m)]",
  "core-prompt": "(m n k : Nat) : gcd m (n + k * m) = gcd m n",
  "args": "(m n k : Nat)"},
 {"type": "lcm m n = lcm n m",
  "tactic-prompt":
  "theorem (m n : Nat) : lcm m n = lcm n m := by rw [lcm]; sorry",
  "name": "lcm_comm",
  "kind": "theorem",
  "first-tactic": "rw [lcm]",
  "core-prompt": "(m n : Nat) : lcm m n = lcm n m",
  "args": "(m n : Nat)"},
 {"type": "lcm 0 m = 0",
  "tactic-prompt": "theorem (m : Nat) : lcm 0 m = 0 := by simp [lcm]; sorry",
  "name": "lcm_zero_left",
  "kind": "theorem",
  "first-tactic": "simp [lcm]",
  "core-prompt": "(m : Nat) : lcm 0 m = 0",
  "args": "(m : Nat)"},
 {"type": "lcm m 0 = 0",
  "tactic-prompt": "theorem (m : Nat) : lcm m 0 = 0 := by simp [lcm]; sorry",
  "name": "lcm_zero_right",
  "kind": "theorem",
  "first-tactic": "simp [lcm]",
  "core-prompt": "(m : Nat) : lcm m 0 = 0",
  "args": "(m : Nat)"},
 {"type": "lcm 1 m = m",
  "tactic-prompt": "theorem (m : Nat) : lcm 1 m = m := by simp [lcm]; sorry",
  "name": "lcm_one_left",
  "kind": "theorem",
  "first-tactic": "simp [lcm]",
  "core-prompt": "(m : Nat) : lcm 1 m = m",
  "args": "(m : Nat)"},
 {"type": "lcm m 1 = m",
  "tactic-prompt": "theorem (m : Nat) : lcm m 1 = m := by simp [lcm]; sorry",
  "name": "lcm_one_right",
  "kind": "theorem",
  "first-tactic": "simp [lcm]",
  "core-prompt": "(m : Nat) : lcm m 1 = m",
  "args": "(m : Nat)"},
 {"type": "lcm m m = m",
  "tactic-prompt":
  "theorem (m : Nat) : lcm m m = m := by match eq_zero_or_pos m with\n  | .inl h => rw [h]; sorry",
  "name": "lcm_self",
  "kind": "theorem",
  "first-tactic": "match eq_zero_or_pos m with\n  | .inl h => rw [h]",
  "core-prompt": "(m : Nat) : lcm m m = m",
  "args": "(m : Nat)"},
 {"type": "gcd m n * lcm m n = m * n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd m n * lcm m n = m * n := by rw [lcm]; sorry",
  "name": "gcd_mul_lcm",
  "kind": "theorem",
  "first-tactic": "rw [lcm]",
  "core-prompt": "(m n : Nat) : gcd m n * lcm m n = m * n",
  "args": "(m n : Nat)"},
 {"type": "lcm m n ∣ k",
  "tactic-prompt":
  "theorem {m n k : Nat}  (H1 : m ∣ k)  (H2 : n ∣ k) : lcm m n ∣ k := by match eq_zero_or_pos k with\n  | .inl h => rw [h]; exact Nat.dvd_zero _\n  | .inr kpos =>\n    apply Nat.dvd_of_mul_dvd_mul_left (gcd_pos_of_pos_left n (pos_of_dvd_of_pos H1 kpos))\n    rw [gcd_mul_lcm]; sorry",
  "name": "lcm_dvd",
  "kind": "theorem",
  "first-tactic":
  "match eq_zero_or_pos k with\n  | .inl h => rw [h]; exact Nat.dvd_zero _\n  | .inr kpos =>\n    apply Nat.dvd_of_mul_dvd_mul_left (gcd_pos_of_pos_left n (pos_of_dvd_of_pos H1 kpos))\n    rw [gcd_mul_lcm]",
  "core-prompt": "{m n k : Nat}  (H1 : m ∣ k)  (H2 : n ∣ k) : lcm m n ∣ k",
  "args": "{m n k : Nat}  (H1 : m ∣ k)  (H2 : n ∣ k)"},
 {"type": "lcm m n ≠ 0",
  "tactic-prompt":
  "theorem (hm : m ≠ 0)  (hn : n ≠ 0) : lcm m n ≠ 0 := by intro h; sorry",
  "name": "lcm_ne_zero",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "(hm : m ≠ 0)  (hn : n ≠ 0) : lcm m n ≠ 0",
  "args": "(hm : m ≠ 0)  (hn : n ≠ 0)"},
 {"type": "k ∣ m",
  "tactic-prompt":
  "theorem (H1 : coprime k n)  (H2 : k ∣ m * n) : k ∣ m := by let t := dvd_gcd (Nat.dvd_mul_left k m) H2; sorry",
  "name": "coprime.dvd_of_dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "let t := dvd_gcd (Nat.dvd_mul_left k m) H2",
  "core-prompt": "(H1 : coprime k n)  (H2 : k ∣ m * n) : k ∣ m",
  "args": "(H1 : coprime k n)  (H2 : k ∣ m * n)"},
 {"type": "gcd (m * k) n = gcd m n",
  "tactic-prompt":
  "theorem (m : Nat)  (H : coprime k n) : gcd (m * k) n = gcd m n := by rw [Nat.mul_comm m k]; sorry",
  "name": "coprime.gcd_mul_right_cancel",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm m k]",
  "core-prompt": "(m : Nat)  (H : coprime k n) : gcd (m * k) n = gcd m n",
  "args": "(m : Nat)  (H : coprime k n)"},
 {"type": "gcd m (k * n) = gcd m n",
  "tactic-prompt":
  "theorem (n : Nat)      (H : coprime k m) : gcd m (k * n) = gcd m n := by rw [gcd_comm m n]; sorry",
  "name": "coprime.gcd_mul_left_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm m n]",
  "core-prompt": "(n : Nat)      (H : coprime k m) : gcd m (k * n) = gcd m n",
  "args": "(n : Nat)      (H : coprime k m)"},
 {"type": "gcd m (n * k) = gcd m n",
  "tactic-prompt":
  "theorem (n : Nat)      (H : coprime k m) : gcd m (n * k) = gcd m n := by rw [Nat.mul_comm n k]; sorry",
  "name": "coprime.gcd_mul_right_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm n k]",
  "core-prompt": "(n : Nat)      (H : coprime k m) : gcd m (n * k) = gcd m n",
  "args": "(n : Nat)      (H : coprime k m)"},
 {"type": "coprime (m / gcd m n) (n / gcd m n)",
  "tactic-prompt":
  "theorem (H : 0 < gcd m n) : coprime (m / gcd m n) (n / gcd m n) := by rw [coprime_iff_gcd_eq_one]; sorry",
  "name": "coprime_div_gcd_div_gcd",
  "kind": "theorem",
  "first-tactic": "rw [coprime_iff_gcd_eq_one]",
  "core-prompt": "(H : 0 < gcd m n) : coprime (m / gcd m n) (n / gcd m n)",
  "args": "(H : 0 < gcd m n)"},
 {"type": "coprime m n",
  "tactic-prompt":
  "theorem (H1 : m ∣ k)  (H2 : coprime k n) : coprime m n := by apply eq_one_of_dvd_one; sorry",
  "name": "coprime.coprime_dvd_left",
  "kind": "theorem",
  "first-tactic": "apply eq_one_of_dvd_one",
  "core-prompt": "(H1 : m ∣ k)  (H2 : coprime k n) : coprime m n",
  "args": "(H1 : m ∣ k)  (H2 : coprime k n)"},
 {"type": "coprime (m / a) n",
  "tactic-prompt":
  "theorem (cmn : coprime m n)  (dvd : a ∣ m) : coprime (m / a) n := by match eq_zero_or_pos a with\n  | .inl h0 =>\n    rw [h0] at dvd\n    rw [Nat.eq_zero_of_zero_dvd dvd] at cmn ⊢\n    simp; assumption\n  | .inr hpos =>\n    let ⟨k]; sorry",
  "name": "coprime.coprime_div_left",
  "kind": "theorem",
  "first-tactic":
  "match eq_zero_or_pos a with\n  | .inl h0 =>\n    rw [h0] at dvd\n    rw [Nat.eq_zero_of_zero_dvd dvd] at cmn ⊢\n    simp; assumption\n  | .inr hpos =>\n    let ⟨k]",
  "core-prompt": "(cmn : coprime m n)  (dvd : a ∣ m) : coprime (m / a) n",
  "args": "(cmn : coprime m n)  (dvd : a ∣ m)"},
 {"type": "coprime k (m * n) ↔ coprime k m ∧ coprime k n",
  "tactic-prompt":
  "theorem  : coprime k (m * n) ↔ coprime k m ∧ coprime k n := by rw [@coprime_comm k]; sorry",
  "name": "coprime_mul_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [@coprime_comm k]",
  "core-prompt": " : coprime k (m * n) ↔ coprime k m ∧ coprime k n",
  "args": ""},
 {"type": "coprime 0 n ↔ n = 1",
  "tactic-prompt":
  "theorem (n : Nat) : coprime 0 n ↔ n = 1 := by simp [coprime]; sorry",
  "name": "coprime_zero_left",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : Nat) : coprime 0 n ↔ n = 1",
  "args": "(n : Nat)"},
 {"type": "coprime n 0 ↔ n = 1",
  "tactic-prompt":
  "theorem (n : Nat) : coprime n 0 ↔ n = 1 := by simp [coprime]; sorry",
  "name": "coprime_zero_right",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : Nat) : coprime n 0 ↔ n = 1",
  "args": "(n : Nat)"},
 {"type": "coprime n n ↔ n = 1",
  "tactic-prompt":
  "theorem (n : Nat) : coprime n n ↔ n = 1 := by simp [coprime]; sorry",
  "name": "coprime_self",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : Nat) : coprime n n ↔ n = 1",
  "args": "(n : Nat)"},
 {"type": "coprime (m ^ n) k",
  "tactic-prompt":
  "theorem (n : Nat)  (H1 : coprime m k) : coprime (m ^ n) k := by induction n; sorry",
  "name": "coprime.pow_left",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "(n : Nat)  (H1 : coprime m k) : coprime (m ^ n) k",
  "args": "(n : Nat)  (H1 : coprime m k)"},
 {"type": "k = 1",
  "tactic-prompt":
  "theorem {k m : Nat}  (H : coprime k m)  (d : k ∣ m) : k = 1 := by rw [← H.gcd_eq_one]; sorry",
  "name": "coprime.eq_one_of_dvd",
  "kind": "theorem",
  "first-tactic": "rw [← H.gcd_eq_one]",
  "core-prompt": "{k m : Nat}  (H : coprime k m)  (d : k ∣ m) : k = 1",
  "args": "{k m : Nat}  (H : coprime k m)  (d : k ∣ m)"},
 {"type": "gcd k (m * n) ∣ gcd k m * gcd k n",
  "tactic-prompt":
  "theorem (k m n : Nat) : gcd k (m * n) ∣ gcd k m * gcd k n := by let ⟨⟨⟨m', hm'⟩, ⟨n', hn'⟩⟩, (h : gcd k (m * n) = m' * n')⟩ :=\n    prod_dvd_and_dvd_of_dvd_prod <| gcd_dvd_right k (m * n); sorry",
  "name": "gcd_mul_dvd_mul_gcd",
  "kind": "theorem",
  "first-tactic":
  "let ⟨⟨⟨m', hm'⟩, ⟨n', hn'⟩⟩, (h : gcd k (m * n) = m' * n')⟩ :=\n    prod_dvd_and_dvd_of_dvd_prod <| gcd_dvd_right k (m * n)",
  "core-prompt": "(k m n : Nat) : gcd k (m * n) ∣ gcd k m * gcd k n",
  "args": "(k m n : Nat)"},
 {"type": "a.gcd c * b.gcd c = c",
  "tactic-prompt":
  "theorem (cop : coprime c d)  (h : a * b = c * d) : a.gcd c * b.gcd c = c := by apply dvd_antisymm; sorry",
  "name": "gcd_mul_gcd_of_coprime_of_mul_eq_mul",
  "kind": "theorem",
  "first-tactic": "apply dvd_antisymm",
  "core-prompt":
  "(cop : coprime c d)  (h : a * b = c * d) : a.gcd c * b.gcd c = c",
  "args": "(cop : coprime c d)  (h : a * b = c * d)"},
 {"type": "n < k + n",
  "tactic-prompt":
  "theorem {n k : Nat}  (h : 0 < k) : n < k + n := by rw [Nat.add_comm]; sorry",
  "name": "lt_add_of_pos_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "{n k : Nat}  (h : 0 < k) : n < k + n",
  "args": "{n k : Nat}  (h : 0 < k)"},
 {"type": "x + k ≤ y ↔ x ≤ y - k",
  "tactic-prompt":
  "theorem (x : Nat)  {y k : Nat}  (h : k ≤ y) : x + k ≤ y ↔ x ≤ y - k := by rw [← Nat.add_sub_cancel x k]; sorry",
  "name": "add_le_to_le_sub",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.add_sub_cancel x k]",
  "core-prompt": "(x : Nat)  {y k : Nat}  (h : k ≤ y) : x + k ≤ y ↔ x ≤ y - k",
  "args": "(x : Nat)  {y k : Nat}  (h : k ≤ y)"},
 {"type": "min a b = min b a",
  "tactic-prompt":
  "theorem (a b : Nat) : min a b = min b a := by simp [Nat.min_def]; sorry",
  "name": "min_comm",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_def]",
  "core-prompt": "(a b : Nat) : min a b = min b a",
  "args": "(a b : Nat)"},
 {"type": "min a b ≤ b",
  "tactic-prompt":
  "theorem (a b : Nat) : min a b ≤ b := by rw [Nat.min_def]; sorry",
  "name": "min_le_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.min_def]",
  "core-prompt": "(a b : Nat) : min a b ≤ b",
  "args": "(a b : Nat)"},
 {"type": "min a b = a",
  "tactic-prompt":
  "theorem {a b : Nat}  (h : a ≤ b) : min a b = a := by simp [Nat.min_def]; sorry",
  "name": "min_eq_left",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_def]",
  "core-prompt": "{a b : Nat}  (h : a ≤ b) : min a b = a",
  "args": "{a b : Nat}  (h : a ≤ b)"},
 {"type": "min a b = b",
  "tactic-prompt":
  "theorem {a b : Nat}  (h : b ≤ a) : min a b = b := by rw [Nat.min_comm a b]; sorry",
  "name": "min_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.min_comm a b]",
  "core-prompt": "{a b : Nat}  (h : b ≤ a) : min a b = b",
  "args": "{a b : Nat}  (h : b ≤ a)"},
 {"type": "max a b = max b a",
  "tactic-prompt":
  "theorem (a b : Nat) : max a b = max b a := by simp only [Nat.max_def]; sorry",
  "name": "max_comm",
  "kind": "theorem",
  "first-tactic": "simp only [Nat.max_def]",
  "core-prompt": "(a b : Nat) : max a b = max b a",
  "args": "(a b : Nat)"},
 {"type": "a ≤ max a b",
  "tactic-prompt":
  "theorem (a b : Nat) : a ≤ max a b := by rw [Nat.max_def]; sorry",
  "name": "le_max_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.max_def]",
  "core-prompt": "(a b : Nat) : a ≤ max a b",
  "args": "(a b : Nat)"},
 {"type": "max a b = b",
  "tactic-prompt":
  "theorem {a b : Nat}  (h : a ≤ b) : max a b = b := by simp [Nat.max_def]; sorry",
  "name": "max_eq_right",
  "kind": "theorem",
  "first-tactic": "simp [Nat.max_def]",
  "core-prompt": "{a b : Nat}  (h : a ≤ b) : max a b = b",
  "args": "{a b : Nat}  (h : a ≤ b)"},
 {"type": "max a b = a",
  "tactic-prompt":
  "theorem {a b : Nat}  (h : b ≤ a) : max a b = a := by rw [← Nat.max_comm b a]; sorry",
  "name": "max_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.max_comm b a]",
  "core-prompt": "{a b : Nat}  (h : b ≤ a) : max a b = a",
  "args": "{a b : Nat}  (h : b ≤ a)"},
 {"type": "min (succ x) (succ y) = succ (min x y)",
  "tactic-prompt":
  "theorem (x y : Nat) : min (succ x) (succ y) = succ (min x y) := by simp [Nat.min_def]; sorry",
  "name": "min_succ_succ",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_def]",
  "core-prompt": "(x y : Nat) : min (succ x) (succ y) = succ (min x y)",
  "args": "(x y : Nat)"},
 {"type": "n - m = n - min n m",
  "tactic-prompt":
  "theorem (n m : Nat) : n - m = n - min n m := by rw [Nat.min_def]; sorry",
  "name": "sub_eq_sub_min",
  "kind": "theorem",
  "first-tactic": "rw [Nat.min_def]",
  "core-prompt": "(n m : Nat) : n - m = n - min n m",
  "args": "(n m : Nat)"},
 {"type": "n - m + min n m = n",
  "tactic-prompt":
  "theorem (n m : Nat) : n - m + min n m = n := by rw [sub_eq_sub_min]; sorry",
  "name": "sub_add_min_cancel",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_sub_min]",
  "core-prompt": "(n m : Nat) : n - m + min n m = n",
  "args": "(n m : Nat)"},
 {"type": "n * m * k = n * k * m",
  "tactic-prompt":
  "theorem (n m k : Nat) : n * m * k = n * k * m := by rw [Nat.mul_assoc]; sorry",
  "name": "mul_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_assoc]",
  "core-prompt": "(n m k : Nat) : n * m * k = n * k * m",
  "args": "(n m k : Nat)"},
 {"type": "n * 2 = n + n",
  "tactic-prompt":
  "theorem (n : Nat) : n * 2 = n + n := by simp [Nat.mul_succ]; sorry",
  "name": "mul_two",
  "kind": "theorem",
  "first-tactic": "simp [Nat.mul_succ]",
  "core-prompt": "(n : Nat) : n * 2 = n + n",
  "args": "(n : Nat)"},
 {"type": "2 * n = n + n",
  "tactic-prompt":
  "theorem (n : Nat) : 2 * n = n + n := by simp [Nat.succ_mul]\n\n/- mod -/; sorry",
  "name": "two_mul",
  "kind": "theorem",
  "first-tactic": "simp [Nat.succ_mul]\n\n/- mod -/",
  "core-prompt": "(n : Nat) : 2 * n = n + n",
  "args": "(n : Nat)"},
 {"type": "m % k + k * (m / k) = m",
  "tactic-prompt":
  "theorem (m k : Nat) : m % k + k * (m / k) = m := by induction m, k using mod.inductionOn with rw [div_eq, mod_eq]\n  | base x y h => simp [h]\n  | ind x y h IH => simp [h]; rw [Nat.mul_succ, ← Nat.add_assoc, IH, Nat.sub_add_cancel h.2]\n\n/- div -/; sorry",
  "name": "mod_add_div",
  "kind": "theorem",
  "first-tactic":
  "induction m, k using mod.inductionOn with rw [div_eq, mod_eq]\n  | base x y h => simp [h]\n  | ind x y h IH => simp [h]; rw [Nat.mul_succ, ← Nat.add_assoc, IH, Nat.sub_add_cancel h.2]\n\n/- div -/",
  "core-prompt": "(m k : Nat) : m % k + k * (m / k) = m",
  "args": "(m k : Nat)"},
 {"type": "n / 1 = n",
  "tactic-prompt":
  "theorem (n : Nat) : n / 1 = n := by have := mod_add_div n 1; sorry",
  "name": "div_one",
  "kind": "theorem",
  "first-tactic": "have := mod_add_div n 1",
  "core-prompt": "(n : Nat) : n / 1 = n",
  "args": "(n : Nat)"},
 {"type": "n / 0 = 0",
  "tactic-prompt": "theorem (n : Nat) : n / 0 = 0 := by rw [div_eq]; sorry",
  "name": "div_zero",
  "kind": "theorem",
  "first-tactic": "rw [div_eq]",
  "core-prompt": "(n : Nat) : n / 0 = 0",
  "args": "(n : Nat)"},
 {"type": "x ≤ y / k ↔ x * k ≤ y",
  "tactic-prompt":
  "theorem (k0 : 0 < k) : x ≤ y / k ↔ x * k ≤ y := by induction y, k using mod.inductionOn generalizing x with\n    (rw [div_eq]; simp [h]; cases x with simp [zero_le] | succ x => ?_)\n  | base y k h =>\n    simp [not_succ_le_zero x, succ_mul, Nat.add_comm]\n    refine Nat.lt_of_lt_of_le ?_ (Nat.le_add_right ..)\n    exact Nat.not_le.1 fun h' => h ⟨k0, h'⟩\n  | ind y k h IH =>\n    rw [← add_one, Nat.add_le_add_iff_le_right, IH k0, succ_mul,\n        ← Nat.add_sub_cancel (x*k) k, Nat.sub_le_sub_right_iff h.2, Nat.add_sub_cancel]; sorry",
  "name": "le_div_iff_mul_le",
  "kind": "theorem",
  "first-tactic":
  "induction y, k using mod.inductionOn generalizing x with\n    (rw [div_eq]; simp [h]; cases x with simp [zero_le] | succ x => ?_)\n  | base y k h =>\n    simp [not_succ_le_zero x, succ_mul, Nat.add_comm]\n    refine Nat.lt_of_lt_of_le ?_ (Nat.le_add_right ..)\n    exact Nat.not_le.1 fun h' => h ⟨k0, h'⟩\n  | ind y k h IH =>\n    rw [← add_one, Nat.add_le_add_iff_le_right, IH k0, succ_mul,\n        ← Nat.add_sub_cancel (x*k) k, Nat.sub_le_sub_right_iff h.2, Nat.add_sub_cancel]",
  "core-prompt": "(k0 : 0 < k) : x ≤ y / k ↔ x * k ≤ y",
  "args": "(k0 : 0 < k)"},
 {"type": "a / b = (a - b) / b + 1",
  "tactic-prompt":
  "theorem (h₁ : 0 < b)  (h₂ : b ≤ a) : a / b = (a - b) / b + 1 := by rw [div_eq a]; sorry",
  "name": "div_eq_sub_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq a]",
  "core-prompt": "(h₁ : 0 < b)  (h₂ : b ≤ a) : a / b = (a - b) / b + 1",
  "args": "(h₁ : 0 < b)  (h₂ : b ≤ a)"},
 {"type": "a / b = 0",
  "tactic-prompt":
  "theorem (h₀ : a < b) : a / b = 0 := by rw [div_eq a]; sorry",
  "name": "div_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [div_eq a]",
  "core-prompt": "(h₀ : a < b) : a / b = 0",
  "args": "(h₀ : a < b)"},
 {"type": "x / k < y ↔ x < y * k",
  "tactic-prompt":
  "theorem (Hk : 0 < k) : x / k < y ↔ x < y * k := by rw [← Nat.not_le]; sorry",
  "name": "div_lt_iff_lt_mul",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.not_le]",
  "core-prompt": "(Hk : 0 < k) : x / k < y ↔ x < y * k",
  "args": "(Hk : 0 < k)"},
 {"type": "n = 0 ∨ n = succ (pred n)",
  "tactic-prompt":
  "theorem (n : Nat) : n = 0 ∨ n = succ (pred n) := by cases n; sorry",
  "name": "eq_zero_or_eq_succ_pred",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n : Nat) : n = 0 ∨ n = succ (pred n)",
  "args": "(n : Nat)"},
 {"type": "n.succ = 1 + n",
  "tactic-prompt":
  "theorem (n : Nat) : n.succ = 1 + n := by rw [Nat.succ_eq_add_one]; sorry",
  "name": "succ_eq_one_add",
  "kind": "theorem",
  "first-tactic": "rw [Nat.succ_eq_add_one]",
  "core-prompt": "(n : Nat) : n.succ = 1 + n",
  "args": "(n : Nat)"},
 {"type": "succ n + m = n + succ m",
  "tactic-prompt":
  "theorem (n m : Nat) : succ n + m = n + succ m := by simp [succ_add]; sorry",
  "name": "succ_add_eq_succ_add",
  "kind": "theorem",
  "first-tactic": "simp [succ_add]",
  "core-prompt": "(n m : Nat) : succ n + m = n + succ m",
  "args": "(n m : Nat)"},
 {"type": "1 + n = succ n",
  "tactic-prompt":
  "theorem (n : Nat) : 1 + n = succ n := by simp [Nat.add_comm]; sorry",
  "name": "one_add",
  "kind": "theorem",
  "first-tactic": "simp [Nat.add_comm]",
  "core-prompt": "(n : Nat) : 1 + n = succ n",
  "args": "(n : Nat)"},
 {"type": "n * m ≠ 0 ↔ n ≠ 0 ∧ m ≠ 0",
  "tactic-prompt":
  "theorem  : n * m ≠ 0 ↔ n ≠ 0 ∧ m ≠ 0 := by simp [mul_eq_zero]; sorry",
  "name": "mul_ne_zero_iff",
  "kind": "theorem",
  "first-tactic": "simp [mul_eq_zero]",
  "core-prompt": " : n * m ≠ 0 ↔ n ≠ 0 ∧ m ≠ 0",
  "args": ""},
 {"type": "a - b + b = max a b",
  "tactic-prompt":
  "theorem {a b : Nat} : a - b + b = max a b := by match a.le_total b with\n  | .inl hl => rw [Nat.max_eq_right hl]; sorry",
  "name": "sub_add_eq_max",
  "kind": "theorem",
  "first-tactic":
  "match a.le_total b with\n  | .inl hl => rw [Nat.max_eq_right hl]",
  "core-prompt": "{a b : Nat} : a - b + b = max a b",
  "args": "{a b : Nat}"},
 {"type": "succ n - m - succ k = n - m - k",
  "tactic-prompt":
  "theorem (n m k : Nat) : succ n - m - succ k = n - m - k := by rw [Nat.sub_sub]; sorry",
  "name": "succ_sub_sub_succ",
  "kind": "theorem",
  "first-tactic": "rw [Nat.sub_sub]",
  "core-prompt": "(n m k : Nat) : succ n - m - succ k = n - m - k",
  "args": "(n m k : Nat)"},
 {"type": "m - n - k = m - k - n",
  "tactic-prompt":
  "theorem (m n k : Nat) : m - n - k = m - k - n := by rw [Nat.sub_sub]; sorry",
  "name": "sub.right_comm",
  "kind": "theorem",
  "first-tactic": "rw [Nat.sub_sub]",
  "core-prompt": "(m n k : Nat) : m - n - k = m - k - n",
  "args": "(m n k : Nat)"},
 {"type": "a * a - b * b = (a + b) * (a - b)",
  "tactic-prompt":
  "theorem (a b : Nat) : a * a - b * b = (a + b) * (a - b) := by rw [Nat.mul_sub_left_distrib]; sorry",
  "name": "mul_self_sub_mul_self_eq",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_sub_left_distrib]",
  "core-prompt": "(a b : Nat) : a * a - b * b = (a + b) * (a - b)",
  "args": "(a b : Nat)"},
 {"type": "succ a * succ b = a * b + a + b + 1",
  "tactic-prompt":
  "theorem (a b : Nat) : succ a * succ b = a * b + a + b + 1 := by rw [mul_succ]; sorry",
  "name": "succ_mul_succ_eq",
  "kind": "theorem",
  "first-tactic": "rw [mul_succ]",
  "core-prompt": "(a b : Nat) : succ a * succ b = a * b + a + b + 1",
  "args": "(a b : Nat)"},
 {"type": "succ m - n = succ (m - n)",
  "tactic-prompt":
  "theorem {m n : Nat}  (h : n ≤ m) : succ m - n = succ (m - n) := by let ⟨k, hk⟩ := Nat.le.dest h; sorry",
  "name": "succ_sub",
  "kind": "theorem",
  "first-tactic": "let ⟨k, hk⟩ := Nat.le.dest h",
  "core-prompt": "{m n : Nat}  (h : n ≤ m) : succ m - n = succ (m - n)",
  "args": "{m n : Nat}  (h : n ≤ m)"},
 {"type": "0 < n - m",
  "tactic-prompt":
  "theorem (h : m < n) : 0 < n - m := by apply Nat.lt_of_add_lt_add_right (b := m); sorry",
  "name": "sub_pos_of_lt",
  "kind": "theorem",
  "first-tactic": "apply Nat.lt_of_add_lt_add_right (b := m)",
  "core-prompt": "(h : m < n) : 0 < n - m",
  "args": "(h : m < n)"},
 {"type": "n + m - k = n - k + m",
  "tactic-prompt":
  "theorem {n m k : Nat}  (h : k ≤ n) : n + m - k = n - k + m := by rw [Nat.sub_eq_iff_eq_add (Nat.le_trans h (Nat.le_add_right ..))]; sorry",
  "name": "sub_add_comm",
  "kind": "theorem",
  "first-tactic":
  "rw [Nat.sub_eq_iff_eq_add (Nat.le_trans h (Nat.le_add_right ..))]",
  "core-prompt": "{n m k : Nat}  (h : k ≤ n) : n + m - k = n - k + m",
  "args": "{n m k : Nat}  (h : k ≤ n)"},
 {"type": "n - 1 - i < n",
  "tactic-prompt":
  "theorem (h : i < n) : n - 1 - i < n := by rw [Nat.sub_sub]; sorry",
  "name": "sub_one_sub_lt",
  "kind": "theorem",
  "first-tactic": "rw [Nat.sub_sub]",
  "core-prompt": "(h : i < n) : n - 1 - i < n",
  "args": "(h : i < n)"},
 {"type": "b - a < b",
  "tactic-prompt":
  "theorem {a b : Nat}  (h₀ : 0 < a)  (h₁ : a ≤ b) : b - a < b := by apply sub_lt _ h₀; sorry",
  "name": "sub_lt_self",
  "kind": "theorem",
  "first-tactic": "apply sub_lt _ h₀",
  "core-prompt": "{a b : Nat}  (h₀ : 0 < a)  (h₁ : a ≤ b) : b - a < b",
  "args": "{a b : Nat}  (h₀ : 0 < a)  (h₁ : a ≤ b)"},
 {"type": "m + (n - m) = n",
  "tactic-prompt":
  "theorem {n m : Nat}  (h : m ≤ n) : m + (n - m) = n := by rw [Nat.add_comm]; sorry",
  "name": "add_sub_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "{n m : Nat}  (h : m ≤ n) : m + (n - m) = n",
  "args": "{n m : Nat}  (h : m ≤ n)"},
 {"type": "k - n < m",
  "tactic-prompt":
  "theorem {n k m : Nat}  (H : n ≤ k)  (h : k < n + m) : k - n < m := by have := Nat.sub_le_sub_right (succ_le_of_lt h) n; sorry",
  "name": "sub_lt_left_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have := Nat.sub_le_sub_right (succ_le_of_lt h) n",
  "core-prompt": "{n k m : Nat}  (H : n ≤ k)  (h : k < n + m) : k - n < m",
  "args": "{n k m : Nat}  (H : n ≤ k)  (h : k < n + m)"},
 {"type": "x ≤ y - k ↔ x + k ≤ y",
  "tactic-prompt":
  "theorem {x y k : Nat}  (h : k ≤ y) : x ≤ y - k ↔ x + k ≤ y := by rw [← Nat.add_sub_cancel x k]; sorry",
  "name": "le_sub_iff_add_le",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.add_sub_cancel x k]",
  "core-prompt": "{x y k : Nat}  (h : k ≤ y) : x ≤ y - k ↔ x + k ≤ y",
  "args": "{x y k : Nat}  (h : k ≤ y)"},
 {"type": "(x + z) % z = x % z",
  "tactic-prompt":
  "theorem (x z : Nat) : (x + z) % z = x % z := by rw [mod_eq_sub_mod (Nat.le_add_left ..)]; sorry",
  "name": "add_mod_right",
  "kind": "theorem",
  "first-tactic": "rw [mod_eq_sub_mod (Nat.le_add_left ..)]",
  "core-prompt": "(x z : Nat) : (x + z) % z = x % z",
  "args": "(x z : Nat)"},
 {"type": "(x + z) % x = z % x",
  "tactic-prompt":
  "theorem (x z : Nat) : (x + z) % x = z % x := by rw [Nat.add_comm]; sorry",
  "name": "add_mod_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "(x z : Nat) : (x + z) % x = z % x",
  "args": "(x z : Nat)"},
 {"type": "(x + y * z) % y = x % y",
  "tactic-prompt":
  "theorem (x y z : Nat) : (x + y * z) % y = x % y := by match z with\n  | 0 => rw [Nat.mul_zero]; sorry",
  "name": "add_mul_mod_self_left",
  "kind": "theorem",
  "first-tactic": "match z with\n  | 0 => rw [Nat.mul_zero]",
  "core-prompt": "(x y z : Nat) : (x + y * z) % y = x % y",
  "args": "(x y z : Nat)"},
 {"type": "(x + y * z) % z = x % z",
  "tactic-prompt":
  "theorem (x y z : Nat) : (x + y * z) % z = x % z := by rw [Nat.mul_comm]; sorry",
  "name": "add_mul_mod_self_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(x y z : Nat) : (x + y * z) % z = x % z",
  "args": "(x y z : Nat)"},
 {"type": "(m * n) % m = 0",
  "tactic-prompt":
  "theorem (m n : Nat) : (m * n) % m = 0 := by rw [← Nat.zero_add (m * n)]; sorry",
  "name": "mul_mod_right",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.zero_add (m * n)]",
  "core-prompt": "(m n : Nat) : (m * n) % m = 0",
  "args": "(m n : Nat)"},
 {"type": "(m * n) % n = 0",
  "tactic-prompt":
  "theorem (m n : Nat) : (m * n) % n = 0 := by rw [Nat.mul_comm]; sorry",
  "name": "mul_mod_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(m n : Nat) : (m * n) % n = 0",
  "args": "(m n : Nat)"},
 {"type": "(x * z) % (y * z) = (x % y) * z",
  "tactic-prompt":
  "theorem (z x y : Nat) : (x * z) % (y * z) = (x % y) * z := by rw [Nat.mul_comm x z]; sorry",
  "name": "mul_mod_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm x z]",
  "core-prompt": "(z x y : Nat) : (x * z) % (y * z) = (x % y) * z",
  "args": "(z x y : Nat)"},
 {"type": "(x - n*k) % n = x % n",
  "tactic-prompt":
  "theorem {x k n : Nat}  (h₁ : n*k ≤ x) : (x - n*k) % n = x % n := by match k with\n  | 0 => rw [Nat.mul_zero]; sorry",
  "name": "sub_mul_mod",
  "kind": "theorem",
  "first-tactic": "match k with\n  | 0 => rw [Nat.mul_zero]",
  "core-prompt": "{x k n : Nat}  (h₁ : n*k ≤ x) : (x - n*k) % n = x % n",
  "args": "{x k n : Nat}  (h₁ : n*k ≤ x)"},
 {"type": "(x - n*p) / n = x / n - p",
  "tactic-prompt":
  "theorem (x n p : Nat)  (h₁ : n*p ≤ x) : (x - n*p) / n = x / n - p := by match eq_zero_or_pos n with\n  | .inl h₀ => rw [h₀]; sorry",
  "name": "sub_mul_div",
  "kind": "theorem",
  "first-tactic": "match eq_zero_or_pos n with\n  | .inl h₀ => rw [h₀]",
  "core-prompt": "(x n p : Nat)  (h₁ : n*p ≤ x) : (x - n*p) / n = x / n - p",
  "args": "(x n p : Nat)  (h₁ : n*p ≤ x)"},
 {"type": "(x + z) / z = succ (x / z)",
  "tactic-prompt":
  "theorem (x : Nat)  {z : Nat}  (H : 0 < z) : (x + z) / z = succ (x / z) := by rw [div_eq_sub_div H (Nat.le_add_left _ _)]; sorry",
  "name": "add_div_right",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_sub_div H (Nat.le_add_left _ _)]",
  "core-prompt":
  "(x : Nat)  {z : Nat}  (H : 0 < z) : (x + z) / z = succ (x / z)",
  "args": "(x : Nat)  {z : Nat}  (H : 0 < z)"},
 {"type": "(z + x) / z = succ (x / z)",
  "tactic-prompt":
  "theorem (x : Nat)  {z : Nat}  (H : 0 < z) : (z + x) / z = succ (x / z) := by rw [Nat.add_comm]; sorry",
  "name": "add_div_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt":
  "(x : Nat)  {z : Nat}  (H : 0 < z) : (z + x) / z = succ (x / z)",
  "args": "(x : Nat)  {z : Nat}  (H : 0 < z)"},
 {"type": "m * n / m = n",
  "tactic-prompt":
  "theorem (n : Nat)  {m : Nat}  (H : 0 < m) : m * n / m = n := by induction n; sorry",
  "name": "mul_div_right",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "(n : Nat)  {m : Nat}  (H : 0 < m) : m * n / m = n",
  "args": "(n : Nat)  {m : Nat}  (H : 0 < m)"},
 {"type": "m * n / n = m",
  "tactic-prompt":
  "theorem (m : Nat)  {n : Nat}  (H : 0 < n) : m * n / n = m := by rw [Nat.mul_comm]; sorry",
  "name": "mul_div_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(m : Nat)  {n : Nat}  (H : 0 < n) : m * n / n = m",
  "args": "(m : Nat)  {n : Nat}  (H : 0 < n)"},
 {"type": "n / n = 1",
  "tactic-prompt":
  "theorem (H : 0 < n) : n / n = 1 := by let t := add_div_right 0 H; sorry",
  "name": "div_self",
  "kind": "theorem",
  "first-tactic": "let t := add_div_right 0 H",
  "core-prompt": "(H : 0 < n) : n / n = 1",
  "args": "(H : 0 < n)"},
 {"type": "(x + y * z) / y = x / y + z",
  "tactic-prompt":
  "theorem (x z : Nat)  {y : Nat}  (H : 0 < y) : (x + y * z) / y = x / y + z := by induction z; sorry",
  "name": "add_mul_div_left",
  "kind": "theorem",
  "first-tactic": "induction z",
  "core-prompt":
  "(x z : Nat)  {y : Nat}  (H : 0 < y) : (x + y * z) / y = x / y + z",
  "args": "(x z : Nat)  {y : Nat}  (H : 0 < y)"},
 {"type": "(x + y * z) / z = x / z + y",
  "tactic-prompt":
  "theorem (x y : Nat)  {z : Nat}  (H : 0 < z) : (x + y * z) / z = x / z + y := by rw [Nat.mul_comm]; sorry",
  "name": "add_mul_div_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt":
  "(x y : Nat)  {z : Nat}  (H : 0 < z) : (x + y * z) / z = x / z + y",
  "args": "(x y : Nat)  {z : Nat}  (H : 0 < z)"},
 {"type": "m * n / n = m",
  "tactic-prompt":
  "theorem (m : Nat)  {n : Nat}  (H : 0 < n) : m * n / n = m := by let t := add_mul_div_right 0 m H; sorry",
  "name": "mul_div_cancel",
  "kind": "theorem",
  "first-tactic": "let t := add_mul_div_right 0 m H",
  "core-prompt": "(m : Nat)  {n : Nat}  (H : 0 < n) : m * n / n = m",
  "args": "(m : Nat)  {n : Nat}  (H : 0 < n)"},
 {"type": "n * m / n = m",
  "tactic-prompt":
  "theorem (m : Nat)  {n : Nat}  (H : 0 < n) : n * m / n = m := by rw [Nat.mul_comm]; sorry",
  "name": "mul_div_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(m : Nat)  {n : Nat}  (H : 0 < n) : n * m / n = m",
  "args": "(m : Nat)  {n : Nat}  (H : 0 < n)"},
 {"type": "m / n = k",
  "tactic-prompt":
  "theorem (H1 : 0 < n)  (H2 : m = k * n) : m / n = k := by rw [H2]; sorry",
  "name": "div_eq_of_eq_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [H2]",
  "core-prompt": "(H1 : 0 < n)  (H2 : m = k * n) : m / n = k",
  "args": "(H1 : 0 < n)  (H2 : m = k * n)"},
 {"type": "m / n = k",
  "tactic-prompt":
  "theorem (H1 : 0 < n)  (H2 : m = n * k) : m / n = k := by rw [H2]; sorry",
  "name": "div_eq_of_eq_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [H2]",
  "core-prompt": "(H1 : 0 < n)  (H2 : m = n * k) : m / n = k",
  "args": "(H1 : 0 < n)  (H2 : m = n * k)"},
 {"type": "(n * p - succ x) / n = p - succ (x / n)",
  "tactic-prompt":
  "theorem (x n p : Nat)  (h₁ : x < n*p) : (n * p - succ x) / n = p - succ (x / n) := by have npos : 0 < n := (eq_zero_or_pos _).resolve_left fun n0 => by\n    rw [n0]; sorry",
  "name": "mul_sub_div",
  "kind": "theorem",
  "first-tactic":
  "have npos : 0 < n := (eq_zero_or_pos _).resolve_left fun n0 => by\n    rw [n0]",
  "core-prompt":
  "(x n p : Nat)  (h₁ : x < n*p) : (n * p - succ x) / n = p - succ (x / n)",
  "args": "(x n p : Nat)  (h₁ : x < n*p)"},
 {"type": "m / n / k = m / (n * k)",
  "tactic-prompt":
  "theorem (m n k : Nat) : m / n / k = m / (n * k) := by cases eq_zero_or_pos k; sorry",
  "name": "div_div_eq_div_mul",
  "kind": "theorem",
  "first-tactic": "cases eq_zero_or_pos k",
  "core-prompt": "(m n k : Nat) : m / n / k = m / (n * k)",
  "args": "(m n k : Nat)"},
 {"type": "m * n / (m * k) = n / k",
  "tactic-prompt":
  "theorem {m : Nat}  (n k : Nat)  (H : 0 < m) : m * n / (m * k) = n / k := by rw [← Nat.div_div_eq_div_mul]; sorry",
  "name": "mul_div_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.div_div_eq_div_mul]",
  "core-prompt":
  "{m : Nat}  (n k : Nat)  (H : 0 < m) : m * n / (m * k) = n / k",
  "args": "{m : Nat}  (n k : Nat)  (H : 0 < m)"},
 {"type": "n * m / (k * m) = n / k",
  "tactic-prompt":
  "theorem {m : Nat}  (n k : Nat)  (H : 0 < m) : n * m / (k * m) = n / k := by rw [Nat.mul_comm]; sorry",
  "name": "mul_div_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt":
  "{m : Nat}  (n k : Nat)  (H : 0 < m) : n * m / (k * m) = n / k",
  "args": "{m : Nat}  (n k : Nat)  (H : 0 < m)"},
 {"type": "n * (m / n) ≤ m",
  "tactic-prompt":
  "theorem (m n : Nat) : n * (m / n) ≤ m := by match n, Nat.eq_zero_or_pos n with\n  | _, Or.inl rfl => rw [Nat.zero_mul]; exact m.zero_le\n  | n, Or.inr h => rw [Nat.mul_comm, ← Nat.le_div_iff_mul_le h]; exact Nat.le_refl _\n\n/- dvd -/; sorry",
  "name": "mul_div_le",
  "kind": "theorem",
  "first-tactic":
  "match n, Nat.eq_zero_or_pos n with\n  | _, Or.inl rfl => rw [Nat.zero_mul]; exact m.zero_le\n  | n, Or.inr h => rw [Nat.mul_comm, ← Nat.le_div_iff_mul_le h]; exact Nat.le_refl _\n\n/- dvd -/",
  "core-prompt": "(m n : Nat) : n * (m / n) ≤ m",
  "args": "(m n : Nat)"},
 {"type": "k ∣ m ↔ k ∣ m + n",
  "tactic-prompt":
  "theorem {k m n : Nat}  (h : k ∣ n) : k ∣ m ↔ k ∣ m + n := by rw [Nat.add_comm]; sorry",
  "name": "dvd_add_iff_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "{k m n : Nat}  (h : k ∣ n) : k ∣ m ↔ k ∣ m + n",
  "args": "{k m n : Nat}  (h : k ∣ n)"},
 {"type": "m ∣ n",
  "tactic-prompt":
  "theorem {m n : Nat}  (H : n % m = 0) : m ∣ n := by exists n / m; sorry",
  "name": "dvd_of_mod_eq_zero",
  "kind": "theorem",
  "first-tactic": "exists n / m",
  "core-prompt": "{m n : Nat}  (H : n % m = 0) : m ∣ n",
  "args": "{m n : Nat}  (H : n % m = 0)"},
 {"type": "n % m = 0",
  "tactic-prompt":
  "theorem {m n : Nat}  (H : m ∣ n) : n % m = 0 := by let ⟨z, H⟩ := H; sorry",
  "name": "mod_eq_zero_of_dvd",
  "kind": "theorem",
  "first-tactic": "let ⟨z, H⟩ := H",
  "core-prompt": "{m n : Nat}  (H : m ∣ n) : n % m = 0",
  "args": "{m n : Nat}  (H : m ∣ n)"},
 {"type": "n * (m / n) = m",
  "tactic-prompt":
  "theorem {n m : Nat}  (H : n ∣ m) : n * (m / n) = m := by have := mod_add_div m n; sorry",
  "name": "mul_div_cancel'",
  "kind": "theorem",
  "first-tactic": "have := mod_add_div m n",
  "core-prompt": "{n m : Nat}  (H : n ∣ m) : n * (m / n) = m",
  "args": "{n m : Nat}  (H : n ∣ m)"},
 {"type": "m / n * n = m",
  "tactic-prompt":
  "theorem {n m : Nat}  (H : n ∣ m) : m / n * n = m := by rw [Nat.mul_comm]; sorry",
  "name": "div_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "{n m : Nat}  (H : n ∣ m) : m / n * n = m",
  "args": "{n m : Nat}  (H : n ∣ m)"},
 {"type": "m * n / k = m * (n / k)",
  "tactic-prompt":
  "theorem (m : Nat)  (H : k ∣ n) : m * n / k = m * (n / k) := by match Nat.eq_zero_or_pos k with\n  | .inl h0 => rw [h0]; sorry",
  "name": "mul_div_assoc",
  "kind": "theorem",
  "first-tactic": "match Nat.eq_zero_or_pos k with\n  | .inl h0 => rw [h0]",
  "core-prompt": "(m : Nat)  (H : k ∣ n) : m * n / k = m * (n / k)",
  "args": "(m : Nat)  (H : k ∣ n)"},
 {"type": "m ∣ n",
  "tactic-prompt":
  "theorem (kpos : 0 < k)  (H : k * m ∣ k * n) : m ∣ n := by let ⟨l, H⟩ := H; sorry",
  "name": "dvd_of_mul_dvd_mul_left",
  "kind": "theorem",
  "first-tactic": "let ⟨l, H⟩ := H",
  "core-prompt": "(kpos : 0 < k)  (H : k * m ∣ k * n) : m ∣ n",
  "args": "(kpos : 0 < k)  (H : k * m ∣ k * n)"},
 {"type": "m ∣ n",
  "tactic-prompt":
  "theorem (kpos : 0 < k)  (H : m * k ∣ n * k) : m ∣ n := by rw [Nat.mul_comm m k]; sorry",
  "name": "dvd_of_mul_dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm m k]",
  "core-prompt": "(kpos : 0 < k)  (H : m * k ∣ n * k) : m ∣ n",
  "args": "(kpos : 0 < k)  (H : m * k ∣ n * k)"},
 {"type": "c * a ≤ c * b",
  "tactic-prompt":
  "theorem {a b c : Nat}  (h₁ : a ≤ b) : c * a ≤ c * b := by if hba : b ≤ a then simp [Nat.le_antisymm hba h₁] else\n  if hc0 : c ≤ 0 then simp [Nat.le_antisymm hc0 (zero_le c)]; sorry",
  "name": "mul_le_mul_of_nonneg_left",
  "kind": "theorem",
  "first-tactic":
  "if hba : b ≤ a then simp [Nat.le_antisymm hba h₁] else\n  if hc0 : c ≤ 0 then simp [Nat.le_antisymm hc0 (zero_le c)]",
  "core-prompt": "{a b c : Nat}  (h₁ : a ≤ b) : c * a ≤ c * b",
  "args": "{a b c : Nat}  (h₁ : a ≤ b)"},
 {"type": "a * c ≤ b * c",
  "tactic-prompt":
  "theorem {a b c : Nat}  (h₁ : a ≤ b) : a * c ≤ b * c := by if hba : b ≤ a then simp [Nat.le_antisymm hba h₁] else\n  if hc0 : c ≤ 0 then simp [Nat.le_antisymm hc0 (zero_le c)]; sorry",
  "name": "mul_le_mul_of_nonneg_right",
  "kind": "theorem",
  "first-tactic":
  "if hba : b ≤ a then simp [Nat.le_antisymm hba h₁] else\n  if hc0 : c ≤ 0 then simp [Nat.le_antisymm hc0 (zero_le c)]",
  "core-prompt": "{a b c : Nat}  (h₁ : a ≤ b) : a * c ≤ b * c",
  "args": "{a b c : Nat}  (h₁ : a ≤ b)"},
 {"type": "a * b % n = (a % n) * (b % n) % n",
  "tactic-prompt":
  "theorem (a b n : Nat) : a * b % n = (a % n) * (b % n) % n := by conv => lhs; rw [\n    ← mod_add_div a n]; sorry",
  "name": "mul_mod",
  "kind": "theorem",
  "first-tactic": "conv => lhs; rw [\n    ← mod_add_div a n]",
  "core-prompt": "(a b n : Nat) : a * b % n = (a % n) * (b % n) % n",
  "args": "(a b n : Nat)"},
 {"type": "(m % n + k) % n = (m + k) % n",
  "tactic-prompt":
  "theorem (m n k : Nat) : (m % n + k) % n = (m + k) % n := by have := (add_mul_mod_self_left (m % n + k) n (m / n)).symm; sorry",
  "name": "mod_add_mod",
  "kind": "theorem",
  "first-tactic": "have := (add_mul_mod_self_left (m % n + k) n (m / n)).symm",
  "core-prompt": "(m n k : Nat) : (m % n + k) % n = (m + k) % n",
  "args": "(m n k : Nat)"},
 {"type": "(m + n % k) % k = (m + n) % k",
  "tactic-prompt":
  "theorem (m n k : Nat) : (m + n % k) % k = (m + n) % k := by rw [Nat.add_comm]; sorry",
  "name": "add_mod_mod",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "(m n k : Nat) : (m + n % k) % k = (m + n) % k",
  "args": "(m n k : Nat)"},
 {"type": "(a + b) % n = ((a % n) + (b % n)) % n",
  "tactic-prompt":
  "theorem (a b n : Nat) : (a + b) % n = ((a % n) + (b % n)) % n := by rw [add_mod_mod]; sorry",
  "name": "add_mod",
  "kind": "theorem",
  "first-tactic": "rw [add_mod_mod]",
  "core-prompt": "(a b n : Nat) : (a + b) % n = ((a % n) + (b % n)) % n",
  "args": "(a b n : Nat)"},
 {"type": "m ^ n.succ = m * m ^ n",
  "tactic-prompt":
  "theorem {m n : Nat} : m ^ n.succ = m * m ^ n := by rw [Nat.pow_succ]; sorry",
  "name": "pow_succ'",
  "kind": "theorem",
  "first-tactic": "rw [Nat.pow_succ]",
  "core-prompt": "{m n : Nat} : m ^ n.succ = m * m ^ n",
  "args": "{m n : Nat}"},
 {"type": "1 <<< n = 2 ^ n",
  "tactic-prompt":
  "theorem (n : Nat) : 1 <<< n = 2 ^ n := by rw [shiftLeft_eq]; sorry",
  "name": "one_shiftLeft",
  "kind": "theorem",
  "first-tactic": "rw [shiftLeft_eq]",
  "core-prompt": "(n : Nat) : 1 <<< n = 2 ^ n",
  "args": "(n : Nat)"},
 {"type": "k ≤ n.log2 ↔ 2 ^ k ≤ n",
  "tactic-prompt":
  "theorem (h : n ≠ 0) : k ≤ n.log2 ↔ 2 ^ k ≤ n := by match k with\n  | 0 => simp [show 1 ≤ n from Nat.pos_of_ne_zero h]\n  | k+1 =>\n    rw [log2]; split\n    · have n0 : 0 < n / 2 := (Nat.le_div_iff_mul_le (by decide)).2 ‹_›\n      simp [Nat.add_le_add_iff_le_right]; sorry",
  "name": "le_log2",
  "kind": "theorem",
  "first-tactic":
  "match k with\n  | 0 => simp [show 1 ≤ n from Nat.pos_of_ne_zero h]\n  | k+1 =>\n    rw [log2]; split\n    · have n0 : 0 < n / 2 := (Nat.le_div_iff_mul_le (by decide)).2 ‹_›\n      simp [Nat.add_le_add_iff_le_right]",
  "core-prompt": "(h : n ≠ 0) : k ≤ n.log2 ↔ 2 ^ k ≤ n",
  "args": "(h : n ≠ 0)"},
 {"type": "n.log2 < k ↔ n < 2 ^ k",
  "tactic-prompt":
  "theorem (h : n ≠ 0) : n.log2 < k ↔ n < 2 ^ k := by rw [← Nat.not_le]; sorry",
  "name": "log2_lt",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.not_le]",
  "core-prompt": "(h : n ≠ 0) : n.log2 < k ↔ n < 2 ^ k",
  "args": "(h : n ≠ 0)"},
 {"type": "Nat.sum (l₁ ++ l₂) = Nat.sum l₁ + Nat.sum l₂",
  "tactic-prompt":
  "theorem  : Nat.sum (l₁ ++ l₂) = Nat.sum l₁ + Nat.sum l₂ := by induction l₁; sorry",
  "name": "sum_append",
  "kind": "theorem",
  "first-tactic": "induction l₁",
  "core-prompt": " : Nat.sum (l₁ ++ l₂) = Nat.sum l₁ + Nat.sum l₂",
  "args": ""},
 {"type": "fdiv 0 b = 0",
  "tactic-prompt": "theorem (b : Int) : fdiv 0 b = 0 := by cases b; sorry",
  "name": "zero_fdiv",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Int) : fdiv 0 b = 0",
  "args": "(b : Int)"},
 {"type": "(-a).div (-b) = a.div b",
  "tactic-prompt":
  "theorem (a b : Int) : (-a).div (-b) = a.div b := by simp [Int.div_neg]; sorry",
  "name": "neg_div_neg",
  "kind": "theorem",
  "first-tactic": "simp [Int.div_neg]",
  "core-prompt": "(a b : Int) : (-a).div (-b) = a.div b",
  "args": "(a b : Int)"},
 {"type": "(a + b) / c = a / c + b / c",
  "tactic-prompt":
  "theorem {a b c : Int}  (H : c ∣ a) : (a + b) / c = a / c + b / c := by rw [Int.add_comm]; sorry",
  "name": "add_ediv_of_dvd_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b c : Int}  (H : c ∣ a) : (a + b) / c = a / c + b / c",
  "args": "{a b c : Int}  (H : c ∣ a)"},
 {"type": "(a * b) / b = a",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (H : b ≠ 0) : (a * b) / b = a := by have := Int.add_mul_ediv_right 0 a H; sorry",
  "name": "mul_ediv_cancel",
  "kind": "theorem",
  "first-tactic": "have := Int.add_mul_ediv_right 0 a H",
  "core-prompt": "(a : Int)  {b : Int}  (H : b ≠ 0) : (a * b) / b = a",
  "args": "(a : Int)  {b : Int}  (H : b ≠ 0)"},
 {"type": "a.div a = 1",
  "tactic-prompt":
  "theorem {a : Int}  (H : a ≠ 0) : a.div a = 1 := by have := Int.mul_div_cancel 1 H; sorry",
  "name": "div_self",
  "kind": "theorem",
  "first-tactic": "have := Int.mul_div_cancel 1 H",
  "core-prompt": "{a : Int}  (H : a ≠ 0) : a.div a = 1",
  "args": "{a : Int}  (H : a ≠ 0)"},
 {"type": "a.fdiv a = 1",
  "tactic-prompt":
  "theorem {a : Int}  (H : a ≠ 0) : a.fdiv a = 1 := by have := Int.mul_fdiv_cancel 1 H; sorry",
  "name": "fdiv_self",
  "kind": "theorem",
  "first-tactic": "have := Int.mul_fdiv_cancel 1 H",
  "core-prompt": "{a : Int}  (H : a ≠ 0) : a.fdiv a = 1",
  "args": "{a : Int}  (H : a ≠ 0)"},
 {"type": "a / a = 1",
  "tactic-prompt":
  "theorem {a : Int}  (H : a ≠ 0) : a / a = 1 := by have := Int.mul_ediv_cancel 1 H; sorry",
  "name": "ediv_self",
  "kind": "theorem",
  "first-tactic": "have := Int.mul_ediv_cancel 1 H",
  "core-prompt": "{a : Int}  (H : a ≠ 0) : a / a = 1",
  "args": "{a : Int}  (H : a ≠ 0)"},
 {"type": "↑(m % n) = fmod m n",
  "tactic-prompt":
  "theorem (m n : Nat) : ↑(m % n) = fmod m n := by cases m; sorry",
  "name": "ofNat_fmod",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt": "(m n : Nat) : ↑(m % n) = fmod m n",
  "args": "(m n : Nat)"},
 {"type": "mod 0 b = 0",
  "tactic-prompt": "theorem (b : Int) : mod 0 b = 0 := by cases b; sorry",
  "name": "zero_mod",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Int) : mod 0 b = 0",
  "args": "(b : Int)"},
 {"type": "fmod 0 b = 0",
  "tactic-prompt": "theorem (b : Int) : fmod 0 b = 0 := by cases b; sorry",
  "name": "zero_fmod",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Int) : fmod 0 b = 0",
  "args": "(b : Int)"},
 {"type": "0 % b = 0",
  "tactic-prompt": "theorem (b : Int) : 0 % b = 0 := by simp [mod_def']; sorry",
  "name": "zero_emod",
  "kind": "theorem",
  "first-tactic": "simp [mod_def']",
  "core-prompt": "(b : Int) : 0 % b = 0",
  "args": "(b : Int)"},
 {"type": "mod a b = a - b * a.div b",
  "tactic-prompt":
  "theorem (a b : Int) : mod a b = a - b * a.div b := by rw [← Int.add_sub_cancel (mod a b)]; sorry",
  "name": "mod_def",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_sub_cancel (mod a b)]",
  "core-prompt": "(a b : Int) : mod a b = a - b * a.div b",
  "args": "(a b : Int)"},
 {"type": "a.fmod b = a - b * a.fdiv b",
  "tactic-prompt":
  "theorem (a b : Int) : a.fmod b = a - b * a.fdiv b := by rw [← Int.add_sub_cancel (a.fmod b)]; sorry",
  "name": "fmod_def",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_sub_cancel (a.fmod b)]",
  "core-prompt": "(a b : Int) : a.fmod b = a - b * a.fdiv b",
  "args": "(a b : Int)"},
 {"type": "a % b = a - b * (a / b)",
  "tactic-prompt":
  "theorem (a b : Int) : a % b = a - b * (a / b) := by rw [← Int.add_sub_cancel (a % b)]; sorry",
  "name": "emod_def",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_sub_cancel (a % b)]",
  "core-prompt": "(a b : Int) : a % b = a - b * (a / b)",
  "args": "(a b : Int)"},
 {"type": "fmod a b = a % b",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (hb : 0 ≤ b) : fmod a b = a % b := by simp [fmod_def]; sorry",
  "name": "fmod_eq_emod",
  "kind": "theorem",
  "first-tactic": "simp [fmod_def]",
  "core-prompt": "(a : Int)  {b : Int}  (hb : 0 ≤ b) : fmod a b = a % b",
  "args": "(a : Int)  {b : Int}  (hb : 0 ≤ b)"},
 {"type": "mod a b = a % b",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : 0 ≤ a)  (hb : 0 ≤ b) : mod a b = a % b := by simp [emod_def]; sorry",
  "name": "mod_eq_emod",
  "kind": "theorem",
  "first-tactic": "simp [emod_def]",
  "core-prompt": "{a b : Int}  (ha : 0 ≤ a)  (hb : 0 ≤ b) : mod a b = a % b",
  "args": "{a b : Int}  (ha : 0 ≤ a)  (hb : 0 ≤ b)"},
 {"type": "mod a (-b) = mod a b",
  "tactic-prompt":
  "theorem (a b : Int) : mod a (-b) = mod a b := by rw [mod_def]; sorry",
  "name": "mod_neg",
  "kind": "theorem",
  "first-tactic": "rw [mod_def]",
  "core-prompt": "(a b : Int) : mod a (-b) = mod a b",
  "args": "(a b : Int)"},
 {"type": "a % -b = a % b",
  "tactic-prompt":
  "theorem (a b : Int) : a % -b = a % b := by rw [emod_def]; sorry",
  "name": "emod_neg",
  "kind": "theorem",
  "first-tactic": "rw [emod_def]",
  "core-prompt": "(a b : Int) : a % -b = a % b",
  "args": "(a b : Int)"},
 {"type": "mod a 1 = 0",
  "tactic-prompt":
  "theorem (a : Int) : mod a 1 = 0 := by simp [mod_def]; sorry",
  "name": "mod_one",
  "kind": "theorem",
  "first-tactic": "simp [mod_def]",
  "core-prompt": "(a : Int) : mod a 1 = 0",
  "args": "(a : Int)"},
 {"type": "a % 1 = 0",
  "tactic-prompt": "theorem (a : Int) : a % 1 = 0 := by simp [emod_def]; sorry",
  "name": "emod_one",
  "kind": "theorem",
  "first-tactic": "simp [emod_def]",
  "core-prompt": "(a : Int) : a % 1 = 0",
  "args": "(a : Int)"},
 {"type": "a.fmod 1 = 0",
  "tactic-prompt":
  "theorem (a : Int) : a.fmod 1 = 0 := by simp [fmod_def]; sorry",
  "name": "fmod_one",
  "kind": "theorem",
  "first-tactic": "simp [fmod_def]",
  "core-prompt": "(a : Int) : a.fmod 1 = 0",
  "args": "(a : Int)"},
 {"type": "mod a b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H1 : 0 ≤ a)  (H2 : a < b) : mod a b = a := by rw [mod_eq_emod H1 (Int.le_trans H1 (Int.le_of_lt H2))]; sorry",
  "name": "mod_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [mod_eq_emod H1 (Int.le_trans H1 (Int.le_of_lt H2))]",
  "core-prompt": "{a b : Int}  (H1 : 0 ≤ a)  (H2 : a < b) : mod a b = a",
  "args": "{a b : Int}  (H1 : 0 ≤ a)  (H2 : a < b)"},
 {"type": "a.fmod b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H1 : 0 ≤ a)  (H2 : a < b) : a.fmod b = a := by rw [fmod_eq_emod _ (Int.le_trans H1 (Int.le_of_lt H2))]; sorry",
  "name": "fmod_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [fmod_eq_emod _ (Int.le_trans H1 (Int.le_of_lt H2))]",
  "core-prompt": "{a b : Int}  (H1 : 0 ≤ a)  (H2 : a < b) : a.fmod b = a",
  "args": "{a b : Int}  (H1 : 0 ≤ a)  (H2 : a < b)"},
 {"type": "mod m k + m.div k * k = m",
  "tactic-prompt":
  "theorem (m k : Int) : mod m k + m.div k * k = m := by rw [Int.mul_comm]; sorry",
  "name": "mod_add_div'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m k : Int) : mod m k + m.div k * k = m",
  "args": "(m k : Int)"},
 {"type": "m.div k * k + mod m k = m",
  "tactic-prompt":
  "theorem (m k : Int) : m.div k * k + mod m k = m := by rw [Int.mul_comm]; sorry",
  "name": "div_add_mod'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m k : Int) : m.div k * k + mod m k = m",
  "args": "(m k : Int)"},
 {"type": "m % k + m / k * k = m",
  "tactic-prompt":
  "theorem (m k : Int) : m % k + m / k * k = m := by rw [Int.mul_comm]; sorry",
  "name": "emod_add_ediv'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m k : Int) : m % k + m / k * k = m",
  "args": "(m k : Int)"},
 {"type": "m / k * k + m % k = m",
  "tactic-prompt":
  "theorem (m k : Int) : m / k * k + m % k = m := by rw [Int.mul_comm]; sorry",
  "name": "ediv_add_emod'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m k : Int) : m / k * k + m % k = m",
  "args": "(m k : Int)"},
 {"type": "(a + b * c) % b = a % b",
  "tactic-prompt":
  "theorem (a b c : Int) : (a + b * c) % b = a % b := by rw [Int.mul_comm]; sorry",
  "name": "add_mul_emod_self_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a b c : Int) : (a + b * c) % b = a % b",
  "args": "(a b c : Int)"},
 {"type": "(a + b) % b = a % b",
  "tactic-prompt":
  "theorem {a b : Int} : (a + b) % b = a % b := by have := add_mul_emod_self_left a b 1; sorry",
  "name": "add_emod_self",
  "kind": "theorem",
  "first-tactic": "have := add_mul_emod_self_left a b 1",
  "core-prompt": "{a b : Int} : (a + b) % b = a % b",
  "args": "{a b : Int}"},
 {"type": "(a + b) % a = b % a",
  "tactic-prompt":
  "theorem {a b : Int} : (a + b) % a = b % a := by rw [Int.add_comm]; sorry",
  "name": "add_emod_self_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b : Int} : (a + b) % a = b % a",
  "args": "{a b : Int}"},
 {"type": "(m % n + k) % n = (m + k) % n",
  "tactic-prompt":
  "theorem (m n k : Int) : (m % n + k) % n = (m + k) % n := by have := (add_mul_emod_self_left (m % n + k) n (m / n)).symm; sorry",
  "name": "emod_add_emod",
  "kind": "theorem",
  "first-tactic": "have := (add_mul_emod_self_left (m % n + k) n (m / n)).symm",
  "core-prompt": "(m n k : Int) : (m % n + k) % n = (m + k) % n",
  "args": "(m n k : Int)"},
 {"type": "(m + n % k) % k = (m + n) % k",
  "tactic-prompt":
  "theorem (m n k : Int) : (m + n % k) % k = (m + n) % k := by rw [Int.add_comm]; sorry",
  "name": "add_emod_emod",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "(m n k : Int) : (m + n % k) % k = (m + n) % k",
  "args": "(m n k : Int)"},
 {"type": "(a + b) % n = (a % n + b % n) % n",
  "tactic-prompt":
  "theorem (a b n : Int) : (a + b) % n = (a % n + b % n) % n := by rw [add_emod_emod]; sorry",
  "name": "add_emod",
  "kind": "theorem",
  "first-tactic": "rw [add_emod_emod]",
  "core-prompt": "(a b n : Int) : (a + b) % n = (a % n + b % n) % n",
  "args": "(a b n : Int)"},
 {"type": "(m + i) % n = (k + i) % n",
  "tactic-prompt":
  "theorem {m n k : Int}  (i : Int)      (H : m % n = k % n) : (m + i) % n = (k + i) % n := by rw [← emod_add_emod]; sorry",
  "name": "add_emod_eq_add_emod_right",
  "kind": "theorem",
  "first-tactic": "rw [← emod_add_emod]",
  "core-prompt":
  "{m n k : Int}  (i : Int)      (H : m % n = k % n) : (m + i) % n = (k + i) % n",
  "args": "{m n k : Int}  (i : Int)      (H : m % n = k % n)"},
 {"type": "(i + m) % n = (i + k) % n",
  "tactic-prompt":
  "theorem {m n k : Int}  (i : Int)      (H : m % n = k % n) : (i + m) % n = (i + k) % n := by rw [Int.add_comm]; sorry",
  "name": "add_emod_eq_add_emod_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt":
  "{m n k : Int}  (i : Int)      (H : m % n = k % n) : (i + m) % n = (i + k) % n",
  "args": "{m n k : Int}  (i : Int)      (H : m % n = k % n)"},
 {"type": "(i + m) % n = (i + k) % n ↔ m % n = k % n",
  "tactic-prompt":
  "theorem {m n k i : Int} : (i + m) % n = (i + k) % n ↔ m % n = k % n := by rw [Int.add_comm]; sorry",
  "name": "emod_add_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{m n k i : Int} : (i + m) % n = (i + k) % n ↔ m % n = k % n",
  "args": "{m n k i : Int}"},
 {"type": "(a * b) % b = 0",
  "tactic-prompt":
  "theorem (a b : Int) : (a * b) % b = 0 := by rw [← Int.zero_add (a * b)]; sorry",
  "name": "mul_emod_left",
  "kind": "theorem",
  "first-tactic": "rw [← Int.zero_add (a * b)]",
  "core-prompt": "(a b : Int) : (a * b) % b = 0",
  "args": "(a b : Int)"},
 {"type": "(a * b).mod a = 0",
  "tactic-prompt":
  "theorem (a b : Int) : (a * b).mod a = 0 := by rw [Int.mul_comm]; sorry",
  "name": "mul_mod_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a b : Int) : (a * b).mod a = 0",
  "args": "(a b : Int)"},
 {"type": "(a * b).fmod a = 0",
  "tactic-prompt":
  "theorem (a b : Int) : (a * b).fmod a = 0 := by rw [Int.mul_comm]; sorry",
  "name": "mul_fmod_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a b : Int) : (a * b).fmod a = 0",
  "args": "(a b : Int)"},
 {"type": "(a * b) % a = 0",
  "tactic-prompt":
  "theorem (a b : Int) : (a * b) % a = 0 := by rw [Int.mul_comm]; sorry",
  "name": "mul_emod_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a b : Int) : (a * b) % a = 0",
  "args": "(a b : Int)"},
 {"type": "(a * b) % n = (a % n) * (b % n) % n",
  "tactic-prompt":
  "theorem (a b n : Int) : (a * b) % n = (a % n) * (b % n) % n := by conv => lhs; rw [\n    ← emod_add_ediv a n]; sorry",
  "name": "mul_emod",
  "kind": "theorem",
  "first-tactic": "conv => lhs; rw [\n    ← emod_add_ediv a n]",
  "core-prompt": "(a b n : Int) : (a * b) % n = (a % n) * (b % n) % n",
  "args": "(a b n : Int)"},
 {"type": "a.mod a = 0",
  "tactic-prompt":
  "theorem {a : Int} : a.mod a = 0 := by have := mul_mod_left 1 a; sorry",
  "name": "mod_self",
  "kind": "theorem",
  "first-tactic": "have := mul_mod_left 1 a",
  "core-prompt": "{a : Int} : a.mod a = 0",
  "args": "{a : Int}"},
 {"type": "a.fmod a = 0",
  "tactic-prompt":
  "theorem {a : Int} : a.fmod a = 0 := by have := mul_fmod_left 1 a; sorry",
  "name": "fmod_self",
  "kind": "theorem",
  "first-tactic": "have := mul_fmod_left 1 a",
  "core-prompt": "{a : Int} : a.fmod a = 0",
  "args": "{a : Int}"},
 {"type": "a % a = 0",
  "tactic-prompt":
  "theorem {a : Int} : a % a = 0 := by have := mul_emod_left 1 a; sorry",
  "name": "emod_self",
  "kind": "theorem",
  "first-tactic": "have := mul_emod_left 1 a",
  "core-prompt": "{a : Int} : a % a = 0",
  "args": "{a : Int}"},
 {"type": "(n % k) % m = n % m",
  "tactic-prompt":
  "theorem (n : Int)  {m k : Int}      (h : m ∣ k) : (n % k) % m = n % m := by conv => rhs; rw [← emod_add_ediv n k]; sorry",
  "name": "emod_emod_of_dvd",
  "kind": "theorem",
  "first-tactic": "conv => rhs; rw [← emod_add_ediv n k]",
  "core-prompt":
  "(n : Int)  {m k : Int}      (h : m ∣ k) : (n % k) % m = n % m",
  "args": "(n : Int)  {m k : Int}      (h : m ∣ k)"},
 {"type": "(a % b) % b = a % b",
  "tactic-prompt":
  "theorem (a b : Int) : (a % b) % b = a % b := by conv => rhs; rw [← emod_add_ediv a b]; sorry",
  "name": "emod_emod",
  "kind": "theorem",
  "first-tactic": "conv => rhs; rw [← emod_add_ediv a b]",
  "core-prompt": "(a b : Int) : (a % b) % b = a % b",
  "args": "(a b : Int)"},
 {"type": "(a - b) % n = (a % n - b % n) % n",
  "tactic-prompt":
  "theorem (a b n : Int) : (a - b) % n = (a % n - b % n) % n := by apply (emod_add_cancel_right b).mp; sorry",
  "name": "sub_emod",
  "kind": "theorem",
  "first-tactic": "apply (emod_add_cancel_right b).mp",
  "core-prompt": "(a b n : Int) : (a - b) % n = (a % n - b % n) % n",
  "args": "(a b n : Int)"},
 {"type": "a / b = q ∧ a % b = r ↔ r + b * q = a ∧ 0 ≤ r ∧ r < b",
  "tactic-prompt":
  "theorem {a b r q : Int}  (h : 0 < b) : a / b = q ∧ a % b = r ↔ r + b * q = a ∧ 0 ≤ r ∧ r < b := by constructor; sorry",
  "name": "ediv_emod_unique",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{a b r q : Int}  (h : 0 < b) : a / b = q ∧ a % b = r ↔ r + b * q = a ∧ 0 ≤ r ∧ r < b",
  "args": "{a b r q : Int}  (h : 0 < b)"},
 {"type": "(a * b) / (c * b) = a / c",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (c : Int)  (H : 0 < b) : (a * b) / (c * b) = a / c := by rw [Int.mul_comm]; sorry",
  "name": "mul_ediv_mul_of_pos_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "(a : Int)  {b : Int}  (c : Int)  (H : 0 < b) : (a * b) / (c * b) = a / c",
  "args": "(a : Int)  {b : Int}  (c : Int)  (H : 0 < b)"},
 {"type": "(a * b) % (a * c) = a * (b % c)",
  "tactic-prompt":
  "theorem {a : Int}  (b c : Int)  (H : 0 < a) : (a * b) % (a * c) = a * (b % c) := by rw [emod_def]; sorry",
  "name": "mul_emod_mul_of_pos",
  "kind": "theorem",
  "first-tactic": "rw [emod_def]",
  "core-prompt":
  "{a : Int}  (b c : Int)  (H : 0 < a) : (a * b) % (a * c) = a * (b % c)",
  "args": "{a : Int}  (b c : Int)  (H : 0 < a)"},
 {"type": "a < (a.div b + 1) * b",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (H : 0 < b) : a < (a.div b + 1) * b := by rw [Int.add_mul]; sorry",
  "name": "lt_div_add_one_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_mul]",
  "core-prompt": "(a : Int)  {b : Int}  (H : 0 < b) : a < (a.div b + 1) * b",
  "args": "(a : Int)  {b : Int}  (H : 0 < b)"},
 {"type": "a < (a / b + 1) * b",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (H : 0 < b) : a < (a / b + 1) * b := by rw [Int.add_mul]; sorry",
  "name": "lt_ediv_add_one_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_mul]",
  "core-prompt": "(a : Int)  {b : Int}  (H : 0 < b) : a < (a / b + 1) * b",
  "args": "(a : Int)  {b : Int}  (H : 0 < b)"},
 {"type": "a / b ≤ a",
  "tactic-prompt":
  "theorem {a : Int}  (b : Int)  (Ha : 0 ≤ a) : a / b ≤ a := by have := Int.le_trans le_natAbs (ofNat_le.2 <| natAbs_div_le_natAbs a b); sorry",
  "name": "ediv_le_self",
  "kind": "theorem",
  "first-tactic":
  "have := Int.le_trans le_natAbs (ofNat_le.2 <| natAbs_div_le_natAbs a b)",
  "core-prompt": "{a : Int}  (b : Int)  (Ha : 0 ≤ a) : a / b ≤ a",
  "args": "{a : Int}  (b : Int)  (Ha : 0 ≤ a)"},
 {"type": "b * (a.div b) = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a.mod b = 0) : b * (a.div b) = a := by have := mod_add_div a b; sorry",
  "name": "mul_div_cancel_of_mod_eq_zero",
  "kind": "theorem",
  "first-tactic": "have := mod_add_div a b",
  "core-prompt": "{a b : Int}  (H : a.mod b = 0) : b * (a.div b) = a",
  "args": "{a b : Int}  (H : a.mod b = 0)"},
 {"type": "a.div b * b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a.mod b = 0) : a.div b * b = a := by rw [Int.mul_comm]; sorry",
  "name": "div_mul_cancel_of_mod_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "{a b : Int}  (H : a.mod b = 0) : a.div b * b = a",
  "args": "{a b : Int}  (H : a.mod b = 0)"},
 {"type": "b * (a / b) = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a % b = 0) : b * (a / b) = a := by have := emod_add_ediv a b; sorry",
  "name": "mul_ediv_cancel_of_emod_eq_zero",
  "kind": "theorem",
  "first-tactic": "have := emod_add_ediv a b",
  "core-prompt": "{a b : Int}  (H : a % b = 0) : b * (a / b) = a",
  "args": "{a b : Int}  (H : a % b = 0)"},
 {"type": "a / b * b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a % b = 0) : a / b * b = a := by rw [Int.mul_comm]; sorry",
  "name": "ediv_mul_cancel_of_emod_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "{a b : Int}  (H : a % b = 0) : a / b * b = a",
  "args": "{a b : Int}  (H : a % b = 0)"},
 {"type": "-a ∣ b ↔ a ∣ b",
  "tactic-prompt":
  "theorem {a b : Int} : -a ∣ b ↔ a ∣ b := by constructor; sorry",
  "name": "neg_dvd",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{a b : Int} : -a ∣ b ↔ a ∣ b",
  "args": "{a b : Int}"},
 {"type": "a ∣ -b ↔ a ∣ b",
  "tactic-prompt":
  "theorem {a b : Int} : a ∣ -b ↔ a ∣ b := by constructor; sorry",
  "name": "dvd_neg",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{a b : Int} : a ∣ -b ↔ a ∣ b",
  "args": "{a b : Int}"},
 {"type": "a ∣ b + c ↔ a ∣ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (H : a ∣ b) : a ∣ b + c ↔ a ∣ c := by rw [Int.add_comm]; sorry",
  "name": "dvd_add_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b c : Int}  (H : a ∣ b) : a ∣ b + c ↔ a ∣ c",
  "args": "{a b c : Int}  (H : a ∣ b)"},
 {"type": "a ∣ b ↔ a ∣ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (H : a ∣ b + c) : a ∣ b ↔ a ∣ c := by rw [← Int.sub_neg] at H; sorry",
  "name": "dvd_iff_dvd_of_dvd_add",
  "kind": "theorem",
  "first-tactic": "rw [← Int.sub_neg] at H",
  "core-prompt": "{a b c : Int}  (H : a ∣ b + c) : a ∣ b ↔ a ∣ c",
  "args": "{a b c : Int}  (H : a ∣ b + c)"},
 {"type": "(↑m : Int) ∣ ↑n ↔ m ∣ n",
  "tactic-prompt":
  "theorem {m n : Nat} : (↑m : Int) ∣ ↑n ↔ m ∣ n := by refine ⟨fun ⟨a, ae⟩ => ?_, fun ⟨k, e⟩ => ⟨k, by rw [e, Int.ofNat_mul]⟩⟩; sorry",
  "name": "ofNat_dvd",
  "kind": "theorem",
  "first-tactic":
  "refine ⟨fun ⟨a, ae⟩ => ?_, fun ⟨k, e⟩ => ⟨k, by rw [e, Int.ofNat_mul]⟩⟩",
  "core-prompt": "{m n : Nat} : (↑m : Int) ∣ ↑n ↔ m ∣ n",
  "args": "{m n : Nat}"},
 {"type": "natAbs a ∣ natAbs b ↔ a ∣ b",
  "tactic-prompt":
  "theorem {a b : Int} : natAbs a ∣ natAbs b ↔ a ∣ b := by refine ⟨fun ⟨k, hk⟩ => ?_, fun ⟨k, hk⟩ => ⟨natAbs k, hk.symm ▸ natAbs_mul a k⟩⟩; sorry",
  "name": "natAbs_dvd_natAbs",
  "kind": "theorem",
  "first-tactic":
  "refine ⟨fun ⟨k, hk⟩ => ?_, fun ⟨k, hk⟩ => ⟨natAbs k, hk.symm ▸ natAbs_mul a k⟩⟩",
  "core-prompt": "{a b : Int} : natAbs a ∣ natAbs b ↔ a ∣ b",
  "args": "{a b : Int}"},
 {"type": "(↑n : Int) ∣ z ↔ n ∣ z.natAbs",
  "tactic-prompt":
  "theorem {n : Nat}  {z : Int} : (↑n : Int) ∣ z ↔ n ∣ z.natAbs := by rw [← natAbs_dvd_natAbs]; sorry",
  "name": "ofNat_dvd_left",
  "kind": "theorem",
  "first-tactic": "rw [← natAbs_dvd_natAbs]",
  "core-prompt": "{n : Nat}  {z : Int} : (↑n : Int) ∣ z ↔ n ∣ z.natAbs",
  "args": "{n : Nat}  {z : Int}"},
 {"type": "z ∣ (↑n : Int) ↔ z.natAbs ∣ n",
  "tactic-prompt":
  "theorem {n : Nat}  {z : Int} : z ∣ (↑n : Int) ↔ z.natAbs ∣ n := by rw [← natAbs_dvd_natAbs]; sorry",
  "name": "ofNat_dvd_right",
  "kind": "theorem",
  "first-tactic": "rw [← natAbs_dvd_natAbs]",
  "core-prompt": "{n : Nat}  {z : Int} : z ∣ (↑n : Int) ↔ z.natAbs ∣ n",
  "args": "{n : Nat}  {z : Int}"},
 {"type": "a ∣ b → b ∣ a → a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (H1 : 0 ≤ a)  (H2 : 0 ≤ b) : a ∣ b → b ∣ a → a = b := by rw [← natAbs_of_nonneg H1]; sorry",
  "name": "dvd_antisymm",
  "kind": "theorem",
  "first-tactic": "rw [← natAbs_of_nonneg H1]",
  "core-prompt":
  "{a b : Int}  (H1 : 0 ≤ a)  (H2 : 0 ≤ b) : a ∣ b → b ∣ a → a = b",
  "args": "{a b : Int}  (H1 : 0 ≤ a)  (H2 : 0 ≤ b)"},
 {"type": "b ∣ a - c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a % b = c) : b ∣ a - c := by have hx : (a % b) % b = c % b := by\n    rw [h]; sorry",
  "name": "dvd_sub_of_emod_eq",
  "kind": "theorem",
  "first-tactic": "have hx : (a % b) % b = c % b := by\n    rw [h]",
  "core-prompt": "{a b c : Int}  (h : a % b = c) : b ∣ a - c",
  "args": "{a b c : Int}  (h : a % b = c)"},
 {"type": "a * b.div a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a ∣ b) : a * b.div a = b := by rw [Int.mul_comm]; sorry",
  "name": "mul_div_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "{a b : Int}  (H : a ∣ b) : a * b.div a = b",
  "args": "{a b : Int}  (H : a ∣ b)"},
 {"type": "a * (b / a) = b",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a ∣ b) : a * (b / a) = b := by rw [Int.mul_comm]; sorry",
  "name": "mul_ediv_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "{a b : Int}  (H : a ∣ b) : a * (b / a) = b",
  "args": "{a b : Int}  (H : a ∣ b)"},
 {"type": "(a * b).div c = a.div c * b",
  "tactic-prompt":
  "theorem (b : Int)  {a c : Int}  (h : c ∣ a) : (a * b).div c = a.div c * b := by rw [Int.mul_comm]; sorry",
  "name": "mul_div_assoc'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "(b : Int)  {a c : Int}  (h : c ∣ a) : (a * b).div c = a.div c * b",
  "args": "(b : Int)  {a c : Int}  (h : c ∣ a)"},
 {"type": "(a * b) / c = a / c * b",
  "tactic-prompt":
  "theorem (b : Int)  {a c : Int}      (h : c ∣ a) : (a * b) / c = a / c * b := by rw [Int.mul_comm]; sorry",
  "name": "mul_ediv_assoc'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "(b : Int)  {a c : Int}      (h : c ∣ a) : (a * b) / c = a / c * b",
  "args": "(b : Int)  {a c : Int}      (h : c ∣ a)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b ∣ a)  (H2 : a.div b = c) : a = b * c := by rw [← H2]; sorry",
  "name": "eq_mul_of_div_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [← H2]",
  "core-prompt":
  "{a b c : Int}      (H1 : b ∣ a)  (H2 : a.div b = c) : a = b * c",
  "args": "{a b c : Int}      (H1 : b ∣ a)  (H2 : a.div b = c)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b ∣ a)  (H2 : a / b = c) : a = b * c := by rw [← H2]; sorry",
  "name": "eq_mul_of_ediv_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [← H2]",
  "core-prompt":
  "{a b c : Int}      (H1 : b ∣ a)  (H2 : a / b = c) : a = b * c",
  "args": "{a b c : Int}      (H1 : b ∣ a)  (H2 : a / b = c)"},
 {"type": "a.div b = c",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b ≠ 0)  (H2 : a = b * c) : a.div b = c := by rw [H2]; sorry",
  "name": "div_eq_of_eq_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [H2]",
  "core-prompt":
  "{a b c : Int}      (H1 : b ≠ 0)  (H2 : a = b * c) : a.div b = c",
  "args": "{a b c : Int}      (H1 : b ≠ 0)  (H2 : a = b * c)"},
 {"type": "a / b = c",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b ≠ 0)  (H2 : a = b * c) : a / b = c := by rw [H2]; sorry",
  "name": "ediv_eq_of_eq_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [H2]",
  "core-prompt":
  "{a b c : Int}      (H1 : b ≠ 0)  (H2 : a = b * c) : a / b = c",
  "args": "{a b c : Int}      (H1 : b ≠ 0)  (H2 : a = b * c)"},
 {"type": "a.div b = c ↔ a = c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (H : b ≠ 0)  (H' : b ∣ a) : a.div b = c ↔ a = c * b := by rw [Int.mul_comm]; sorry",
  "name": "div_eq_iff_eq_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (H : b ≠ 0)  (H' : b ∣ a) : a.div b = c ↔ a = c * b",
  "args": "{a b c : Int}      (H : b ≠ 0)  (H' : b ∣ a)"},
 {"type": "a / b = c ↔ a = c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (H : b ≠ 0)  (H' : b ∣ a) : a / b = c ↔ a = c * b := by rw [Int.mul_comm]; sorry",
  "name": "ediv_eq_iff_eq_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (H : b ≠ 0)  (H' : b ∣ a) : a / b = c ↔ a = c * b",
  "args": "{a b c : Int}      (H : b ≠ 0)  (H' : b ∣ a)"},
 {"type": "a = c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b ∣ a)  (H2 : a.div b = c) : a = c * b := by rw [Int.mul_comm]; sorry",
  "name": "eq_mul_of_div_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (H1 : b ∣ a)  (H2 : a.div b = c) : a = c * b",
  "args": "{a b c : Int}      (H1 : b ∣ a)  (H2 : a.div b = c)"},
 {"type": "a = c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b ∣ a)  (H2 : a / b = c) : a = c * b := by rw [Int.mul_comm]; sorry",
  "name": "eq_mul_of_ediv_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (H1 : b ∣ a)  (H2 : a / b = c) : a = c * b",
  "args": "{a b c : Int}      (H1 : b ∣ a)  (H2 : a / b = c)"},
 {"type": "n = 0",
  "tactic-prompt":
  "theorem {d n : Int}  (h : d ∣ n)  (H : n.div d = 0) : n = 0 := by rw [← Int.mul_div_cancel' h]; sorry",
  "name": "eq_zero_of_div_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [← Int.mul_div_cancel' h]",
  "core-prompt": "{d n : Int}  (h : d ∣ n)  (H : n.div d = 0) : n = 0",
  "args": "{d n : Int}  (h : d ∣ n)  (H : n.div d = 0)"},
 {"type": "n = 0",
  "tactic-prompt":
  "theorem {d n : Int}  (h : d ∣ n)  (H : n / d = 0) : n = 0 := by rw [← Int.mul_ediv_cancel' h]; sorry",
  "name": "eq_zero_of_ediv_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [← Int.mul_ediv_cancel' h]",
  "core-prompt": "{d n : Int}  (h : d ∣ n)  (H : n / d = 0) : n = 0",
  "args": "{d n : Int}  (h : d ∣ n)  (H : n / d = 0)"},
 {"type": "a.div b = a / b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : b ∣ a) : a.div b = a / b := by if b0 : b = 0 then simp [b0]\n  else rw [Int.div_eq_iff_eq_mul_left b0 h]; sorry",
  "name": "div_eq_ediv_of_dvd",
  "kind": "theorem",
  "first-tactic":
  "if b0 : b = 0 then simp [b0]\n  else rw [Int.div_eq_iff_eq_mul_left b0 h]",
  "core-prompt": "{a b : Int}  (h : b ∣ a) : a.div b = a / b",
  "args": "{a b : Int}  (h : b ∣ a)"},
 {"type": "(a - b) / c = a / c - b / c",
  "tactic-prompt":
  "theorem (a : Int)  {b c : Int}      (hcb : c ∣ b) : (a - b) / c = a / c - b / c := by rw [Int.sub_eq_add_neg]; sorry",
  "name": "sub_ediv_of_dvd",
  "kind": "theorem",
  "first-tactic": "rw [Int.sub_eq_add_neg]",
  "core-prompt":
  "(a : Int)  {b c : Int}      (hcb : c ∣ b) : (a - b) / c = a / c - b / c",
  "args": "(a : Int)  {b c : Int}      (hcb : c ∣ b)"},
 {"type": "(a - b) / c = a / c - b / c",
  "tactic-prompt":
  "theorem {a b c : Int}      (hcab : c ∣ a - b) : (a - b) / c = a / c - b / c := by rw [← Int.add_sub_cancel ((a-b) / c)]; sorry",
  "name": "sub_ediv_of_dvd_sub",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_sub_cancel ((a-b) / c)]",
  "core-prompt":
  "{a b c : Int}      (hcab : c ∣ a - b) : (a - b) / c = a / c - b / c",
  "args": "{a b c : Int}      (hcab : c ∣ a - b)"},
 {"type": "a.div d = b.div d ↔ a = b",
  "tactic-prompt":
  "theorem {a b d : Int}      (hda : d ∣ a)  (hdb : d ∣ b) : a.div d = b.div d ↔ a = b := by refine ⟨fun h => ?_, congrArg (div · d)⟩; sorry",
  "name": "div_left_inj",
  "kind": "theorem",
  "first-tactic": "refine ⟨fun h => ?_, congrArg (div · d)⟩",
  "core-prompt":
  "{a b d : Int}      (hda : d ∣ a)  (hdb : d ∣ b) : a.div d = b.div d ↔ a = b",
  "args": "{a b d : Int}      (hda : d ∣ a)  (hdb : d ∣ b)"},
 {"type": "a / d = b / d ↔ a = b",
  "tactic-prompt":
  "theorem {a b d : Int}      (hda : d ∣ a)  (hdb : d ∣ b) : a / d = b / d ↔ a = b := by refine ⟨fun h => ?_, congrArg (ediv · d)⟩; sorry",
  "name": "ediv_left_inj",
  "kind": "theorem",
  "first-tactic": "refine ⟨fun h => ?_, congrArg (ediv · d)⟩",
  "core-prompt":
  "{a b d : Int}      (hda : d ∣ a)  (hdb : d ∣ b) : a / d = b / d ↔ a = b",
  "args": "{a b d : Int}      (hda : d ∣ a)  (hdb : d ∣ b)"},
 {"type": "a ≤ c * b",
  "tactic-prompt":
  "theorem {a b c : Int}  (H1 : 0 ≤ b)  (H2 : b ∣ a)  (H3 : a / b ≤ c) : a ≤ c * b := by rw [← Int.div_mul_cancel H2]; sorry",
  "name": "le_mul_of_div_le",
  "kind": "theorem",
  "first-tactic": "rw [← Int.div_mul_cancel H2]",
  "core-prompt":
  "{a b c : Int}  (H1 : 0 ≤ b)  (H2 : b ∣ a)  (H3 : a / b ≤ c) : a ≤ c * b",
  "args": "{a b c : Int}  (H1 : 0 ≤ b)  (H2 : b ∣ a)  (H3 : a / b ≤ c)"},
 {"type": "a = c / b * d",
  "tactic-prompt":
  "theorem {a b c d : Int}  (hb : b ≠ 0)  (hbc : b ∣ c)  (h : b * a = c * d) : a = c / b * d := by cases' hbc with k hk; sorry",
  "name": "eq_mul_div_of_mul_eq_mul_of_dvd_left",
  "kind": "theorem",
  "first-tactic": "cases' hbc with k hk",
  "core-prompt":
  "{a b c d : Int}  (hb : b ≠ 0)  (hbc : b ∣ c)  (h : b * a = c * d) : a = c / b * d",
  "args": "{a b c d : Int}  (hb : b ≠ 0)  (hbc : b ∣ c)  (h : b * a = c * d)"},
 {"type": "b = 0",
  "tactic-prompt":
  "theorem {a b : Int}  (w : a ∣ b)  (h : natAbs b < natAbs a) : b = 0 := by rw [← natAbs_dvd]; sorry",
  "name": "eq_zero_of_dvd_ofNatAbs_lt_natAbs",
  "kind": "theorem",
  "first-tactic": "rw [← natAbs_dvd]",
  "core-prompt": "{a b : Int}  (w : a ∣ b)  (h : natAbs b < natAbs a) : b = 0",
  "args": "{a b : Int}  (w : a ∣ b)  (h : natAbs b < natAbs a)"},
 {"type": "t / s ∣ t",
  "tactic-prompt":
  "theorem {s t : Int}  (hst : s ∣ t) : t / s ∣ t := by rcases eq_or_ne s 0 with (rfl | hs); sorry",
  "name": "div_dvd_of_dvd",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne s 0 with (rfl | hs)",
  "core-prompt": "{s t : Int}  (hst : s ∣ t) : t / s ∣ t",
  "args": "{s t : Int}  (hst : s ∣ t)"},
 {"type": "b ∣ c / a",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a * b ∣ c) : b ∣ c / a := by rcases eq_or_ne a 0 with (rfl | ha); sorry",
  "name": "dvd_div_of_mul_dvd",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne a 0 with (rfl | ha)",
  "core-prompt": "{a b c : Int}  (h : a * b ∣ c) : b ∣ c / a",
  "args": "{a b c : Int}  (h : a * b ∣ c)"},
 {"type": "subNatNat m n = ↑(m - n)",
  "tactic-prompt":
  "theorem {m n : Nat}  (h : n - m = 0) : subNatNat m n = ↑(m - n) := by rw [subNatNat]; sorry",
  "name": "subNatNat_of_sub_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [subNatNat]",
  "core-prompt": "{m n : Nat}  (h : n - m = 0) : subNatNat m n = ↑(m - n)",
  "args": "{m n : Nat}  (h : n - m = 0)"},
 {"type": "subNatNat (m + n) m = n",
  "tactic-prompt":
  "theorem  : subNatNat (m + n) m = n := by unfold subNatNat; sorry",
  "name": "subNatNat_add_left",
  "kind": "theorem",
  "first-tactic": "unfold subNatNat",
  "core-prompt": " : subNatNat (m + n) m = n",
  "args": ""},
 {"type": "subNatNat m (m + n + 1) = negSucc n",
  "tactic-prompt":
  "theorem  : subNatNat m (m + n + 1) = negSucc n := by simp [subNatNat]; sorry",
  "name": "subNatNat_add_right",
  "kind": "theorem",
  "first-tactic": "simp [subNatNat]",
  "core-prompt": " : subNatNat m (m + n + 1) = negSucc n",
  "args": ""},
 {"type": "subNatNat (m + k) (n + k) = subNatNat m n",
  "tactic-prompt":
  "theorem (m n k : Nat) : subNatNat (m + k) (n + k) = subNatNat m n := by apply subNatNat_elim m n (fun m n i => subNatNat (m + k) (n + k) = i); sorry",
  "name": "subNatNat_add_add",
  "kind": "theorem",
  "first-tactic":
  "apply subNatNat_elim m n (fun m n i => subNatNat (m + k) (n + k) = i)",
  "core-prompt": "(m n k : Nat) : subNatNat (m + k) (n + k) = subNatNat m n",
  "args": "(m n k : Nat)"},
 {"type": "0 < natAbs a ↔ a ≠ 0",
  "tactic-prompt":
  "theorem  : 0 < natAbs a ↔ a ≠ 0 := by rw [Nat.pos_iff_ne_zero]; sorry",
  "name": "natAbs_pos",
  "kind": "theorem",
  "first-tactic": "rw [Nat.pos_iff_ne_zero]",
  "core-prompt": " : 0 < natAbs a ↔ a ≠ 0",
  "args": ""},
 {"type": "natAbs (negOfNat n) = n",
  "tactic-prompt":
  "theorem (n : Nat) : natAbs (negOfNat n) = n := by cases n; sorry",
  "name": "natAbs_negOfNat",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n : Nat) : natAbs (negOfNat n) = n",
  "args": "(n : Nat)"},
 {"type": "natAbs (a * b) = natAbs a * natAbs b",
  "tactic-prompt":
  "theorem (a b : Int) : natAbs (a * b) = natAbs a * natAbs b := by cases a; sorry",
  "name": "natAbs_mul",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b : Int) : natAbs (a * b) = natAbs a * natAbs b",
  "args": "(a b : Int)"},
 {"type": "a.natAbs * b.natAbs = c",
  "tactic-prompt":
  "theorem {a b : Int}  {c : Nat}      (h : a * b = (c : Int)) : a.natAbs * b.natAbs = c := by rw [← natAbs_mul]; sorry",
  "name": "natAbs_mul_natAbs_eq",
  "kind": "theorem",
  "first-tactic": "rw [← natAbs_mul]",
  "core-prompt":
  "{a b : Int}  {c : Nat}      (h : a * b = (c : Int)) : a.natAbs * b.natAbs = c",
  "args": "{a b : Int}  {c : Nat}      (h : a * b = (c : Int))"},
 {"type": "(natAbs a * natAbs a : Int) = a * a",
  "tactic-prompt":
  "theorem (a : Int) : (natAbs a * natAbs a : Int) = a * a := by rw [← Int.ofNat_mul]; sorry",
  "name": "natAbs_mul_self'",
  "kind": "theorem",
  "first-tactic": "rw [← Int.ofNat_mul]",
  "core-prompt": "(a : Int) : (natAbs a * natAbs a : Int) = a * a",
  "args": "(a : Int)"},
 {"type": "a.natAbs = b.natAbs ↔ a = b ∨ a = -b",
  "tactic-prompt":
  "theorem {a b : Int} : a.natAbs = b.natAbs ↔ a = b ∨ a = -b := by constructor; sorry",
  "name": "natAbs_eq_natAbs_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{a b : Int} : a.natAbs = b.natAbs ↔ a = b ∨ a = -b",
  "args": "{a b : Int}"},
 {"type": "a.natAbs = n ↔ a = n ∨ a = -↑n",
  "tactic-prompt":
  "theorem {a : Int}  {n : Nat} : a.natAbs = n ↔ a = n ∨ a = -↑n := by rw [← Int.natAbs_eq_natAbs_iff]; sorry",
  "name": "natAbs_eq_iff",
  "kind": "theorem",
  "first-tactic": "rw [← Int.natAbs_eq_natAbs_iff]",
  "core-prompt": "{a : Int}  {n : Nat} : a.natAbs = n ↔ a = n ∨ a = -↑n",
  "args": "{a : Int}  {n : Nat}"},
 {"type": "z.sign.natAbs = 1",
  "tactic-prompt":
  "theorem {z : Int}  (hz : z ≠ 0) : z.sign.natAbs = 1 := by rw [Int.natAbs_sign]; sorry",
  "name": "natAbs_sign_of_nonzero",
  "kind": "theorem",
  "first-tactic": "rw [Int.natAbs_sign]",
  "core-prompt": "{z : Int}  (hz : z ≠ 0) : z.sign.natAbs = 1",
  "args": "{z : Int}  (hz : z ≠ 0)"},
 {"type": "subNatNat (m - n) k = subNatNat m (k + n)",
  "tactic-prompt":
  "theorem (h : n ≤ m)  (k : Nat) : subNatNat (m - n) k = subNatNat m (k + n) := by rwa [← subNatNat_add_add _ _ n]; sorry",
  "name": "subNatNat_sub",
  "kind": "theorem",
  "first-tactic": "rwa [← subNatNat_add_add _ _ n]",
  "core-prompt":
  "(h : n ≤ m)  (k : Nat) : subNatNat (m - n) k = subNatNat m (k + n)",
  "args": "(h : n ≤ m)  (k : Nat)"},
 {"type": "subNatNat (m + n) k = m + subNatNat n k",
  "tactic-prompt":
  "theorem (m n k : Nat) : subNatNat (m + n) k = m + subNatNat n k := by cases n.lt_or_ge k; sorry",
  "name": "subNatNat_add",
  "kind": "theorem",
  "first-tactic": "cases n.lt_or_ge k",
  "core-prompt": "(m n k : Nat) : subNatNat (m + n) k = m + subNatNat n k",
  "args": "(m n k : Nat)"},
 {"type": "a + (b + c) = b + (a + c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a + (b + c) = b + (a + c) := by rw [← Int.add_assoc]; sorry",
  "name": "add_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_assoc]",
  "core-prompt": "(a b c : Int) : a + (b + c) = b + (a + c)",
  "args": "(a b c : Int)"},
 {"type": "a + b + c = a + c + b",
  "tactic-prompt":
  "theorem (a b c : Int) : a + b + c = a + c + b := by rw [Int.add_assoc]; sorry",
  "name": "add_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_assoc]",
  "core-prompt": "(a b c : Int) : a + b + c = a + c + b",
  "args": "(a b c : Int)"},
 {"type": "a + -a = 0",
  "tactic-prompt":
  "theorem (a : Int) : a + -a = 0 := by rw [Int.add_comm]; sorry",
  "name": "add_right_neg",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "(a : Int) : a + -a = 0",
  "args": "(a : Int)"},
 {"type": "-a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a + b = 0) : -a = b := by rw [← Int.add_zero (-a)]; sorry",
  "name": "neg_eq_of_add_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_zero (-a)]",
  "core-prompt": "{a b : Int}  (h : a + b = 0) : -a = b",
  "args": "{a b : Int}  (h : a + b = 0)"},
 {"type": "b = -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a = -b) : b = -a := by rw [h]; sorry",
  "name": "eq_neg_of_eq_neg",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{a b : Int}  (h : a = -b) : b = -a",
  "args": "{a b : Int}  (h : a = -b)"},
 {"type": "-a = b ↔ -b = a",
  "tactic-prompt":
  "theorem {a b : Int} : -a = b ↔ -b = a := by rw [eq_comm]; sorry",
  "name": "neg_eq_comm",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt": "{a b : Int} : -a = b ↔ -b = a",
  "args": "{a b : Int}"},
 {"type": "-a + (a + b) = b",
  "tactic-prompt":
  "theorem (a b : Int) : -a + (a + b) = b := by rw [← Int.add_assoc]; sorry",
  "name": "neg_add_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_assoc]",
  "core-prompt": "(a b : Int) : -a + (a + b) = b",
  "args": "(a b : Int)"},
 {"type": "a + (-a + b) = b",
  "tactic-prompt":
  "theorem (a b : Int) : a + (-a + b) = b := by rw [← Int.add_assoc]; sorry",
  "name": "add_neg_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_assoc]",
  "core-prompt": "(a b : Int) : a + (-a + b) = b",
  "args": "(a b : Int)"},
 {"type": "a + b + -b = a",
  "tactic-prompt":
  "theorem (a b : Int) : a + b + -b = a := by rw [Int.add_assoc]; sorry",
  "name": "add_neg_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_assoc]",
  "core-prompt": "(a b : Int) : a + b + -b = a",
  "args": "(a b : Int)"},
 {"type": "a + -b + b = a",
  "tactic-prompt":
  "theorem (a b : Int) : a + -b + b = a := by rw [Int.add_assoc]; sorry",
  "name": "neg_add_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_assoc]",
  "core-prompt": "(a b : Int) : a + -b + b = a",
  "args": "(a b : Int)"},
 {"type": "b = c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b = a + c) : b = c := by have h₁ : -a + (a + b) = -a + (a + c) := by rw [h]; sorry",
  "name": "add_left_cancel",
  "kind": "theorem",
  "first-tactic": "have h₁ : -a + (a + b) = -a + (a + c) := by rw [h]",
  "core-prompt": "{a b c : Int}  (h : a + b = a + c) : b = c",
  "args": "{a b c : Int}  (h : a + b = a + c)"},
 {"type": "-(a + b) = -a + -b",
  "tactic-prompt":
  "theorem {a b : Int} : -(a + b) = -a + -b := by apply Int.add_left_cancel (a := a + b); sorry",
  "name": "neg_add",
  "kind": "theorem",
  "first-tactic": "apply Int.add_left_cancel (a := a + b)",
  "core-prompt": "{a b : Int} : -(a + b) = -a + -b",
  "args": "{a b : Int}"},
 {"type": "a - a = 0",
  "tactic-prompt":
  "theorem (a : Int) : a - a = 0 := by rw [Int.sub_eq_add_neg]; sorry",
  "name": "sub_self",
  "kind": "theorem",
  "first-tactic": "rw [Int.sub_eq_add_neg]",
  "core-prompt": "(a : Int) : a - a = 0",
  "args": "(a : Int)"},
 {"type": "a - 0 = a",
  "tactic-prompt":
  "theorem (a : Int) : a - 0 = a := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "sub_zero",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a : Int) : a - 0 = a",
  "args": "(a : Int)"},
 {"type": "0 - a = -a",
  "tactic-prompt":
  "theorem (a : Int) : 0 - a = -a := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "zero_sub",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a : Int) : 0 - a = -a",
  "args": "(a : Int)"},
 {"type": "a - b = 0",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a = b) : a - b = 0 := by rw [h]; sorry",
  "name": "sub_eq_zero_of_eq",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{a b : Int}  (h : a = b) : a - b = 0",
  "args": "{a b : Int}  (h : a = b)"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a - b = 0) : a = b := by have : 0 + b = b := by rw [Int.zero_add]; sorry",
  "name": "eq_of_sub_eq_zero",
  "kind": "theorem",
  "first-tactic": "have : 0 + b = b := by rw [Int.zero_add]",
  "core-prompt": "{a b : Int}  (h : a - b = 0) : a = b",
  "args": "{a b : Int}  (h : a - b = 0)"},
 {"type": "a - b - c = a - (b + c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a - b - c = a - (b + c) := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "sub_sub",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : Int) : a - b - c = a - (b + c)",
  "args": "(a b c : Int)"},
 {"type": "-(a - b) = b - a",
  "tactic-prompt":
  "theorem (a b : Int) : -(a - b) = b - a := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "neg_sub",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b : Int) : -(a - b) = b - a",
  "args": "(a b : Int)"},
 {"type": "a - (a - b) = b",
  "tactic-prompt":
  "theorem (a b : Int) : a - (a - b) = b := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "sub_sub_self",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b : Int) : a - (a - b) = b",
  "args": "(a b : Int)"},
 {"type": "a - -b = a + b",
  "tactic-prompt":
  "theorem (a b : Int) : a - -b = a + b := by simp [Int.sub_eq_add_neg]\n\n/- ## multiplication -/; sorry",
  "name": "sub_neg",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]\n\n/- ## multiplication -/",
  "core-prompt": "(a b : Int) : a - -b = a + b",
  "args": "(a b : Int)"},
 {"type": "a * b = b * a",
  "tactic-prompt": "theorem (a b : Int) : a * b = b * a := by cases a; sorry",
  "name": "mul_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b : Int) : a * b = b * a",
  "args": "(a b : Int)"},
 {"type": "(m : Nat) * negOfNat n = negOfNat (m * n)",
  "tactic-prompt":
  "theorem (m n : Nat) : (m : Nat) * negOfNat n = negOfNat (m * n) := by cases n; sorry",
  "name": "ofNat_mul_negOfNat",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(m n : Nat) : (m : Nat) * negOfNat n = negOfNat (m * n)",
  "args": "(m n : Nat)"},
 {"type": "negOfNat m * (n : Nat) = negOfNat (m * n)",
  "tactic-prompt":
  "theorem (m n : Nat) : negOfNat m * (n : Nat) = negOfNat (m * n) := by rw [Int.mul_comm]; sorry",
  "name": "negOfNat_mul_ofNat",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m n : Nat) : negOfNat m * (n : Nat) = negOfNat (m * n)",
  "args": "(m n : Nat)"},
 {"type": "a * b * c = a * (b * c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a * b * c = a * (b * c) := by cases a; sorry",
  "name": "mul_assoc",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : Int) : a * b * c = a * (b * c)",
  "args": "(a b c : Int)"},
 {"type": "a * (b * c) = b * (a * c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a * (b * c) = b * (a * c) := by rw [← Int.mul_assoc]; sorry",
  "name": "mul_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [← Int.mul_assoc]",
  "core-prompt": "(a b c : Int) : a * (b * c) = b * (a * c)",
  "args": "(a b c : Int)"},
 {"type": "a * b * c = a * c * b",
  "tactic-prompt":
  "theorem (a b c : Int) : a * b * c = a * c * b := by rw [Int.mul_assoc]; sorry",
  "name": "mul_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_assoc]",
  "core-prompt": "(a b c : Int) : a * b * c = a * c * b",
  "args": "(a b c : Int)"},
 {"type": "a * 0 = 0",
  "tactic-prompt": "theorem (a : Int) : a * 0 = 0 := by cases a; sorry",
  "name": "mul_zero",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a : Int) : a * 0 = 0",
  "args": "(a : Int)"},
 {"type": "m * subNatNat n k = subNatNat (m * n) (m * k)",
  "tactic-prompt":
  "theorem (m n k : Nat) : m * subNatNat n k = subNatNat (m * n) (m * k) := by cases m; sorry",
  "name": "ofNat_mul_subNatNat",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt":
  "(m n k : Nat) : m * subNatNat n k = subNatNat (m * n) (m * k)",
  "args": "(m n k : Nat)"},
 {"type": "negOfNat m + negOfNat n = negOfNat (m + n)",
  "tactic-prompt":
  "theorem (m n : Nat) : negOfNat m + negOfNat n = negOfNat (m + n) := by cases m; sorry",
  "name": "negOfNat_add",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt": "(m n : Nat) : negOfNat m + negOfNat n = negOfNat (m + n)",
  "args": "(m n : Nat)"},
 {"type": "(a + b) * c = a * c + b * c",
  "tactic-prompt":
  "theorem (a b c : Int) : (a + b) * c = a * c + b * c := by simp [Int.mul_comm]; sorry",
  "name": "add_mul",
  "kind": "theorem",
  "first-tactic": "simp [Int.mul_comm]",
  "core-prompt": "(a b c : Int) : (a + b) * c = a * c + b * c",
  "args": "(a b c : Int)"},
 {"type": "-a * -b = a * b",
  "tactic-prompt": "theorem (a b : Int) : -a * -b = a * b := by simp; sorry",
  "name": "neg_mul_neg",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : Int) : -a * -b = a * b",
  "args": "(a b : Int)"},
 {"type": "-a * b = a * -b",
  "tactic-prompt": "theorem (a b : Int) : -a * b = a * -b := by simp; sorry",
  "name": "neg_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : Int) : -a * b = a * -b",
  "args": "(a b : Int)"},
 {"type": "a * (b - c) = a * b - a * c",
  "tactic-prompt":
  "theorem (a b c : Int) : a * (b - c) = a * b - a * c := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "mul_sub",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : Int) : a * (b - c) = a * b - a * c",
  "args": "(a b c : Int)"},
 {"type": "(a - b) * c = a * c - b * c",
  "tactic-prompt":
  "theorem (a b c : Int) : (a - b) * c = a * c - b * c := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "sub_mul",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : Int) : (a - b) * c = a * c - b * c",
  "args": "(a b c : Int)"},
 {"type": "a + b - c = a + (b - c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a + b - c = a + (b - c) := by rw [Int.sub_eq_add_neg]; sorry",
  "name": "add_sub_assoc",
  "kind": "theorem",
  "first-tactic": "rw [Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : Int) : a + b - c = a + (b - c)",
  "args": "(a b c : Int)"},
 {"type": "((n - m : Nat) : Int) = n - m",
  "tactic-prompt":
  "theorem (h : m ≤ n) : ((n - m : Nat) : Int) = n - m := by match m with\n  | 0 => rfl\n  | succ m =>\n    show ofNat (n - succ m) = subNatNat n (succ m)\n    rw [subNatNat]; sorry",
  "name": "ofNat_sub",
  "kind": "theorem",
  "first-tactic":
  "match m with\n  | 0 => rfl\n  | succ m =>\n    show ofNat (n - succ m) = subNatNat n (succ m)\n    rw [subNatNat]",
  "core-prompt": "(h : m ≤ n) : ((n - m : Nat) : Int) = n - m",
  "args": "(h : m ≤ n)"},
 {"type": "subNatNat m n = ↑m - ↑n",
  "tactic-prompt":
  "theorem {m n : Nat} : subNatNat m n = ↑m - ↑n := by apply subNatNat_elim m n fun m n i => i = m - n; sorry",
  "name": "subNatNat_eq_coe",
  "kind": "theorem",
  "first-tactic": "apply subNatNat_elim m n fun m n i => i = m - n",
  "core-prompt": "{m n : Nat} : subNatNat m n = ↑m - ↑n",
  "args": "{m n : Nat}"},
 {"type": "toNat (m - n) = m - n",
  "tactic-prompt":
  "theorem (m n : Nat) : toNat (m - n) = m - n := by rw [← Int.subNatNat_eq_coe]; sorry",
  "name": "toNat_sub",
  "kind": "theorem",
  "first-tactic": "rw [← Int.subNatNat_eq_coe]",
  "core-prompt": "(m n : Nat) : toNat (m - n) = m - n",
  "args": "(m n : Nat)"},
 {"type": "a * 1 = a",
  "tactic-prompt":
  "theorem (a : Int) : a * 1 = a := by rw [Int.mul_comm]; sorry",
  "name": "mul_one",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a : Int) : a * 1 = a",
  "args": "(a : Int)"},
 {"type": "a * -1 = -a",
  "tactic-prompt":
  "theorem (a : Int) : a * -1 = -a := by rw [Int.mul_neg]; sorry",
  "name": "mul_neg_one",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_neg]",
  "core-prompt": "(a : Int) : a * -1 = -a",
  "args": "(a : Int)"},
 {"type": "a ≤ b",
  "tactic-prompt":
  "theorem {a b : Int}  (n : Nat)  (h : b - a = n) : a ≤ b := by simp [le_def]; sorry",
  "name": "le.intro_sub",
  "kind": "theorem",
  "first-tactic": "simp [le_def]",
  "core-prompt": "{a b : Int}  (n : Nat)  (h : b - a = n) : a ≤ b",
  "args": "{a b : Int}  (n : Nat)  (h : b - a = n)"},
 {"type": "∃ n : Nat, a = n",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 ≤ a) : ∃ n : Nat, a = n := by have t := le.dest_sub h; sorry",
  "name": "eq_ofNat_of_zero_le",
  "kind": "theorem",
  "first-tactic": "have t := le.dest_sub h",
  "core-prompt": "{a : Int}  (h : 0 ≤ a) : ∃ n : Nat, a = n",
  "args": "{a : Int}  (h : 0 ≤ a)"},
 {"type": "(↑n : Int) < ↑m ↔ n < m",
  "tactic-prompt":
  "theorem {n m : Nat} : (↑n : Int) < ↑m ↔ n < m := by rw [lt_iff_add_one_le]; sorry",
  "name": "ofNat_lt",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_add_one_le]",
  "core-prompt": "{n m : Nat} : (↑n : Int) < ↑m ↔ n < m",
  "args": "{n m : Nat}"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (h₁ : a ≤ b)  (h₂ : b ≤ a) : a = b := by let ⟨n, hn⟩ := le.dest h₁; sorry",
  "name": "le_antisymm",
  "kind": "theorem",
  "first-tactic": "let ⟨n, hn⟩ := le.dest h₁",
  "core-prompt": "{a b : Int}  (h₁ : a ≤ b)  (h₂ : b ≤ a) : a = b",
  "args": "{a b : Int}  (h₁ : a ≤ b)  (h₂ : b ≤ a)"},
 {"type": "a < b ↔ a ≤ b ∧ a ≠ b",
  "tactic-prompt":
  "theorem {a b : Int} : a < b ↔ a ≤ b ∧ a ≠ b := by refine ⟨fun h => ⟨Int.le_of_lt h, Int.ne_of_lt h⟩, fun ⟨aleb, aneb⟩ => ?_⟩; sorry",
  "name": "lt_iff_le_and_ne",
  "kind": "theorem",
  "first-tactic":
  "refine ⟨fun h => ⟨Int.le_of_lt h, Int.ne_of_lt h⟩, fun ⟨aleb, aneb⟩ => ?_⟩",
  "core-prompt": "{a b : Int} : a < b ↔ a ≤ b ∧ a ≠ b",
  "args": "{a b : Int}"},
 {"type": "0 ≤ a * b",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : 0 ≤ a)  (hb : 0 ≤ b) : 0 ≤ a * b := by let ⟨n, hn⟩ := eq_ofNat_of_zero_le ha; sorry",
  "name": "mul_nonneg",
  "kind": "theorem",
  "first-tactic": "let ⟨n, hn⟩ := eq_ofNat_of_zero_le ha",
  "core-prompt": "{a b : Int}  (ha : 0 ≤ a)  (hb : 0 ≤ b) : 0 ≤ a * b",
  "args": "{a b : Int}  (ha : 0 ≤ a)  (hb : 0 ≤ b)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b := by let ⟨n, hn⟩ := eq_succ_of_zero_lt ha; sorry",
  "name": "mul_pos",
  "kind": "theorem",
  "first-tactic": "let ⟨n, hn⟩ := eq_succ_of_zero_lt ha",
  "core-prompt": "{a b : Int}  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b",
  "args": "{a b : Int}  (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "tactic-prompt":
  "theorem {a b : Int} : a < b ↔ a ≤ b ∧ ¬b ≤ a := by rw [Int.lt_iff_le_and_ne]; sorry",
  "name": "lt_iff_le_not_le",
  "kind": "theorem",
  "first-tactic": "rw [Int.lt_iff_le_and_ne]",
  "core-prompt": "{a b : Int} : a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "args": "{a b : Int}"},
 {"type": "¬a < b ↔ b ≤ a",
  "tactic-prompt":
  "theorem {a b : Int} : ¬a < b ↔ b ≤ a := by rw [← Int.not_le]; sorry",
  "name": "not_lt",
  "kind": "theorem",
  "first-tactic": "rw [← Int.not_le]",
  "core-prompt": "{a b : Int} : ¬a < b ↔ b ≤ a",
  "args": "{a b : Int}"},
 {"type": "min a b = min b a",
  "tactic-prompt":
  "theorem (a b : Int) : min a b = min b a := by simp [Int.min_def]; sorry",
  "name": "min_comm",
  "kind": "theorem",
  "first-tactic": "simp [Int.min_def]",
  "core-prompt": "(a b : Int) : min a b = min b a",
  "args": "(a b : Int)"},
 {"type": "min a b ≤ b",
  "tactic-prompt":
  "theorem (a b : Int) : min a b ≤ b := by rw [Int.min_def]; sorry",
  "name": "min_le_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.min_def]",
  "core-prompt": "(a b : Int) : min a b ≤ b",
  "args": "(a b : Int)"},
 {"type": "min a b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a ≤ b) : min a b = a := by simp [Int.min_def]; sorry",
  "name": "min_eq_left",
  "kind": "theorem",
  "first-tactic": "simp [Int.min_def]",
  "core-prompt": "{a b : Int}  (h : a ≤ b) : min a b = a",
  "args": "{a b : Int}  (h : a ≤ b)"},
 {"type": "min a b = b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : b ≤ a) : min a b = b := by rw [Int.min_comm a b]; sorry",
  "name": "min_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.min_comm a b]",
  "core-prompt": "{a b : Int}  (h : b ≤ a) : min a b = b",
  "args": "{a b : Int}  (h : b ≤ a)"},
 {"type": "max a b = max b a",
  "tactic-prompt":
  "theorem (a b : Int) : max a b = max b a := by simp only [Int.max_def]; sorry",
  "name": "max_comm",
  "kind": "theorem",
  "first-tactic": "simp only [Int.max_def]",
  "core-prompt": "(a b : Int) : max a b = max b a",
  "args": "(a b : Int)"},
 {"type": "a ≤ max a b",
  "tactic-prompt":
  "theorem (a b : Int) : a ≤ max a b := by rw [Int.max_def]; sorry",
  "name": "le_max_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.max_def]",
  "core-prompt": "(a b : Int) : a ≤ max a b",
  "args": "(a b : Int)"},
 {"type": "max a b = b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a ≤ b) : max a b = b := by simp [Int.max_def]; sorry",
  "name": "max_eq_right",
  "kind": "theorem",
  "first-tactic": "simp [Int.max_def]",
  "core-prompt": "{a b : Int}  (h : a ≤ b) : max a b = b",
  "args": "{a b : Int}  (h : a ≤ b)"},
 {"type": "max a b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : b ≤ a) : max a b = a := by rw [← Int.max_comm b a]; sorry",
  "name": "max_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [← Int.max_comm b a]",
  "core-prompt": "{a b : Int}  (h : b ≤ a) : max a b = a",
  "args": "{a b : Int}  (h : b ≤ a)"},
 {"type": "a = natAbs a",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 ≤ a) : a = natAbs a := by let ⟨n, e⟩ := eq_ofNat_of_zero_le h; sorry",
  "name": "eq_natAbs_of_zero_le",
  "kind": "theorem",
  "first-tactic": "let ⟨n, e⟩ := eq_ofNat_of_zero_le h",
  "core-prompt": "{a : Int}  (h : 0 ≤ a) : a = natAbs a",
  "args": "{a : Int}  (h : 0 ≤ a)"},
 {"type": "b ≤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b ≤ a + c) : b ≤ c := by have : -a + (a + b) ≤ -a + (a + c) := Int.add_le_add_left h _; sorry",
  "name": "le_of_add_le_add_left",
  "kind": "theorem",
  "first-tactic":
  "have : -a + (a + b) ≤ -a + (a + c) := Int.add_le_add_left h _",
  "core-prompt": "{a b c : Int}  (h : a + b ≤ a + c) : b ≤ c",
  "args": "{a b c : Int}  (h : a + b ≤ a + c)"},
 {"type": "b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b < a + c) : b < c := by have : -a + (a + b) < -a + (a + c) := Int.add_lt_add_left h _; sorry",
  "name": "lt_of_add_lt_add_left",
  "kind": "theorem",
  "first-tactic":
  "have : -a + (a + b) < -a + (a + c) := Int.add_lt_add_left h _",
  "core-prompt": "{a b c : Int}  (h : a + b < a + c) : b < c",
  "args": "{a b c : Int}  (h : a + b < a + c)"},
 {"type": "a ≤ a + b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : 0 ≤ b) : a ≤ a + b := by have : a + b ≥ a + 0 := Int.add_le_add_left h a; sorry",
  "name": "le_add_of_nonneg_right",
  "kind": "theorem",
  "first-tactic": "have : a + b ≥ a + 0 := Int.add_le_add_left h a",
  "core-prompt": "{a b : Int}  (h : 0 ≤ b) : a ≤ a + b",
  "args": "{a b : Int}  (h : 0 ≤ b)"},
 {"type": "a ≤ b + a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : 0 ≤ b) : a ≤ b + a := by have : 0 + a ≤ b + a := Int.add_le_add_right h a; sorry",
  "name": "le_add_of_nonneg_left",
  "kind": "theorem",
  "first-tactic": "have : 0 + a ≤ b + a := Int.add_le_add_right h a",
  "core-prompt": "{a b : Int}  (h : 0 ≤ b) : a ≤ b + a",
  "args": "{a b : Int}  (h : 0 ≤ b)"},
 {"type": "a < a + b",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (h : 0 < b) : a < a + b := by have : a + 0 < a + b := Int.add_lt_add_left h a; sorry",
  "name": "lt_add_of_pos_right",
  "kind": "theorem",
  "first-tactic": "have : a + 0 < a + b := Int.add_lt_add_left h a",
  "core-prompt": "(a : Int)  {b : Int}  (h : 0 < b) : a < a + b",
  "args": "(a : Int)  {b : Int}  (h : 0 < b)"},
 {"type": "a < b + a",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (h : 0 < b) : a < b + a := by have : 0 + a < b + a := Int.add_lt_add_right h a; sorry",
  "name": "lt_add_of_pos_left",
  "kind": "theorem",
  "first-tactic": "have : 0 + a < b + a := Int.add_lt_add_right h a",
  "core-prompt": "(a : Int)  {b : Int}  (h : 0 < b) : a < b + a",
  "args": "(a : Int)  {b : Int}  (h : 0 < b)"},
 {"type": "-b ≤ -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a ≤ b) : -b ≤ -a := by have : 0 ≤ -a + b := Int.add_left_neg a ▸ Int.add_le_add_left h (-a); sorry",
  "name": "neg_le_neg",
  "kind": "theorem",
  "first-tactic":
  "have : 0 ≤ -a + b := Int.add_left_neg a ▸ Int.add_le_add_left h (-a)",
  "core-prompt": "{a b : Int}  (h : a ≤ b) : -b ≤ -a",
  "args": "{a b : Int}  (h : a ≤ b)"},
 {"type": "-a ≤ 0",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 ≤ a) : -a ≤ 0 := by have : -a ≤ -0 := Int.neg_le_neg h; sorry",
  "name": "neg_nonpos_of_nonneg",
  "kind": "theorem",
  "first-tactic": "have : -a ≤ -0 := Int.neg_le_neg h",
  "core-prompt": "{a : Int}  (h : 0 ≤ a) : -a ≤ 0",
  "args": "{a : Int}  (h : 0 ≤ a)"},
 {"type": "0 ≤ -a",
  "tactic-prompt":
  "theorem {a : Int}  (h : a ≤ 0) : 0 ≤ -a := by have : -0 ≤ -a := Int.neg_le_neg h; sorry",
  "name": "neg_nonneg_of_nonpos",
  "kind": "theorem",
  "first-tactic": "have : -0 ≤ -a := Int.neg_le_neg h",
  "core-prompt": "{a : Int}  (h : a ≤ 0) : 0 ≤ -a",
  "args": "{a : Int}  (h : a ≤ 0)"},
 {"type": "-b < -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a < b) : -b < -a := by have : 0 < -a + b := Int.add_left_neg a ▸ Int.add_lt_add_left h (-a); sorry",
  "name": "neg_lt_neg",
  "kind": "theorem",
  "first-tactic":
  "have : 0 < -a + b := Int.add_left_neg a ▸ Int.add_lt_add_left h (-a)",
  "core-prompt": "{a b : Int}  (h : a < b) : -b < -a",
  "args": "{a b : Int}  (h : a < b)"},
 {"type": "-a < 0",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 < a) : -a < 0 := by have : -a < -0 := Int.neg_lt_neg h; sorry",
  "name": "neg_neg_of_pos",
  "kind": "theorem",
  "first-tactic": "have : -a < -0 := Int.neg_lt_neg h",
  "core-prompt": "{a : Int}  (h : 0 < a) : -a < 0",
  "args": "{a : Int}  (h : 0 < a)"},
 {"type": "0 < -a",
  "tactic-prompt":
  "theorem {a : Int}  (h : a < 0) : 0 < -a := by have : -0 < -a := Int.neg_lt_neg h; sorry",
  "name": "neg_pos_of_neg",
  "kind": "theorem",
  "first-tactic": "have : -0 < -a := Int.neg_lt_neg h",
  "core-prompt": "{a : Int}  (h : a < 0) : 0 < -a",
  "args": "{a : Int}  (h : a < 0)"},
 {"type": "b ≤ -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a ≤ -b) : b ≤ -a := by have h := Int.neg_le_neg h; sorry",
  "name": "le_neg_of_le_neg",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_le_neg h",
  "core-prompt": "{a b : Int}  (h : a ≤ -b) : b ≤ -a",
  "args": "{a b : Int}  (h : a ≤ -b)"},
 {"type": "-b ≤ a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : -a ≤ b) : -b ≤ a := by have h := Int.neg_le_neg h; sorry",
  "name": "neg_le_of_neg_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_le_neg h",
  "core-prompt": "{a b : Int}  (h : -a ≤ b) : -b ≤ a",
  "args": "{a b : Int}  (h : -a ≤ b)"},
 {"type": "b < -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a < -b) : b < -a := by have h := Int.neg_lt_neg h; sorry",
  "name": "lt_neg_of_lt_neg",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_lt_neg h",
  "core-prompt": "{a b : Int}  (h : a < -b) : b < -a",
  "args": "{a b : Int}  (h : a < -b)"},
 {"type": "-b < a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : -a < b) : -b < a := by have h := Int.neg_lt_neg h; sorry",
  "name": "neg_lt_of_neg_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_lt_neg h",
  "core-prompt": "{a b : Int}  (h : -a < b) : -b < a",
  "args": "{a b : Int}  (h : -a < b)"},
 {"type": "0 ≤ a - b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : b ≤ a) : 0 ≤ a - b := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "sub_nonneg_of_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b : Int}  (h : b ≤ a) : 0 ≤ a - b",
  "args": "{a b : Int}  (h : b ≤ a)"},
 {"type": "b ≤ a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : 0 ≤ a - b) : b ≤ a := by have h := Int.add_le_add_right h b; sorry",
  "name": "le_of_sub_nonneg",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b : Int}  (h : 0 ≤ a - b) : b ≤ a",
  "args": "{a b : Int}  (h : 0 ≤ a - b)"},
 {"type": "a - b ≤ 0",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a ≤ b) : a - b ≤ 0 := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "sub_nonpos_of_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b : Int}  (h : a ≤ b) : a - b ≤ 0",
  "args": "{a b : Int}  (h : a ≤ b)"},
 {"type": "a ≤ b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a - b ≤ 0) : a ≤ b := by have h := Int.add_le_add_right h b; sorry",
  "name": "le_of_sub_nonpos",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b : Int}  (h : a - b ≤ 0) : a ≤ b",
  "args": "{a b : Int}  (h : a - b ≤ 0)"},
 {"type": "0 < a - b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : b < a) : 0 < a - b := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "sub_pos_of_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b : Int}  (h : b < a) : 0 < a - b",
  "args": "{a b : Int}  (h : b < a)"},
 {"type": "b < a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : 0 < a - b) : b < a := by have h := Int.add_lt_add_right h b; sorry",
  "name": "lt_of_sub_pos",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b : Int}  (h : 0 < a - b) : b < a",
  "args": "{a b : Int}  (h : 0 < a - b)"},
 {"type": "a - b < 0",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a < b) : a - b < 0 := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "sub_neg_of_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b : Int}  (h : a < b) : a - b < 0",
  "args": "{a b : Int}  (h : a < b)"},
 {"type": "a < b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a - b < 0) : a < b := by have h := Int.add_lt_add_right h b; sorry",
  "name": "lt_of_sub_neg",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b : Int}  (h : a - b < 0) : a < b",
  "args": "{a b : Int}  (h : a - b < 0)"},
 {"type": "a + b ≤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : b ≤ -a + c) : a + b ≤ c := by have h := Int.add_le_add_left h a; sorry",
  "name": "add_le_of_le_neg_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h a",
  "core-prompt": "{a b c : Int}  (h : b ≤ -a + c) : a + b ≤ c",
  "args": "{a b c : Int}  (h : b ≤ -a + c)"},
 {"type": "b ≤ -a + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b ≤ c) : b ≤ -a + c := by have h := Int.add_le_add_left h (-a); sorry",
  "name": "le_neg_add_of_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h (-a)",
  "core-prompt": "{a b c : Int}  (h : a + b ≤ c) : b ≤ -a + c",
  "args": "{a b c : Int}  (h : a + b ≤ c)"},
 {"type": "a + b ≤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : b ≤ c - a) : a + b ≤ c := by have h := Int.add_le_add_left h a; sorry",
  "name": "add_le_of_le_sub_left",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h a",
  "core-prompt": "{a b c : Int}  (h : b ≤ c - a) : a + b ≤ c",
  "args": "{a b c : Int}  (h : b ≤ c - a)"},
 {"type": "b ≤ c - a",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b ≤ c) : b ≤ c - a := by have h := Int.add_le_add_right h (-a); sorry",
  "name": "le_sub_left_of_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-a)",
  "core-prompt": "{a b c : Int}  (h : a + b ≤ c) : b ≤ c - a",
  "args": "{a b c : Int}  (h : a + b ≤ c)"},
 {"type": "a + b ≤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a ≤ c - b) : a + b ≤ c := by have h := Int.add_le_add_right h b; sorry",
  "name": "add_le_of_le_sub_right",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b c : Int}  (h : a ≤ c - b) : a + b ≤ c",
  "args": "{a b c : Int}  (h : a ≤ c - b)"},
 {"type": "a ≤ c - b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b ≤ c) : a ≤ c - b := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "le_sub_right_of_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b c : Int}  (h : a + b ≤ c) : a ≤ c - b",
  "args": "{a b c : Int}  (h : a + b ≤ c)"},
 {"type": "a ≤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -b + a ≤ c) : a ≤ b + c := by have h := Int.add_le_add_left h b; sorry",
  "name": "le_add_of_neg_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h b",
  "core-prompt": "{a b c : Int}  (h : -b + a ≤ c) : a ≤ b + c",
  "args": "{a b c : Int}  (h : -b + a ≤ c)"},
 {"type": "-b + a ≤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a ≤ b + c) : -b + a ≤ c := by have h := Int.add_le_add_left h (-b); sorry",
  "name": "neg_add_le_of_le_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h (-b)",
  "core-prompt": "{a b c : Int}  (h : a ≤ b + c) : -b + a ≤ c",
  "args": "{a b c : Int}  (h : a ≤ b + c)"},
 {"type": "a ≤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a - b ≤ c) : a ≤ b + c := by have h := Int.add_le_add_right h b; sorry",
  "name": "le_add_of_sub_left_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b c : Int}  (h : a - b ≤ c) : a ≤ b + c",
  "args": "{a b c : Int}  (h : a - b ≤ c)"},
 {"type": "a - b ≤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a ≤ b + c) : a - b ≤ c := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "sub_left_le_of_le_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b c : Int}  (h : a ≤ b + c) : a - b ≤ c",
  "args": "{a b c : Int}  (h : a ≤ b + c)"},
 {"type": "a ≤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a - c ≤ b) : a ≤ b + c := by have h := Int.add_le_add_right h c; sorry",
  "name": "le_add_of_sub_right_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h c",
  "core-prompt": "{a b c : Int}  (h : a - c ≤ b) : a ≤ b + c",
  "args": "{a b c : Int}  (h : a - c ≤ b)"},
 {"type": "a - c ≤ b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a ≤ b + c) : a - c ≤ b := by have h := Int.add_le_add_right h (-c); sorry",
  "name": "sub_right_le_of_le_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-c)",
  "core-prompt": "{a b c : Int}  (h : a ≤ b + c) : a - c ≤ b",
  "args": "{a b c : Int}  (h : a ≤ b + c)"},
 {"type": "a ≤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -b + a ≤ c) : a ≤ b + c := by rw [Int.add_comm] at h; sorry",
  "name": "le_add_of_neg_add_le_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : -b + a ≤ c) : a ≤ b + c",
  "args": "{a b c : Int}  (h : -b + a ≤ c)"},
 {"type": "-b + a ≤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a ≤ b + c) : -b + a ≤ c := by rw [Int.add_comm]; sorry",
  "name": "neg_add_le_left_of_le_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b c : Int}  (h : a ≤ b + c) : -b + a ≤ c",
  "args": "{a b c : Int}  (h : a ≤ b + c)"},
 {"type": "a ≤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -c + a ≤ b) : a ≤ b + c := by rw [Int.add_comm] at h; sorry",
  "name": "le_add_of_neg_add_le_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : -c + a ≤ b) : a ≤ b + c",
  "args": "{a b c : Int}  (h : -c + a ≤ b)"},
 {"type": "-c + a ≤ b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a ≤ b + c) : -c + a ≤ b := by rw [Int.add_comm] at h; sorry",
  "name": "neg_add_le_right_of_le_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : a ≤ b + c) : -c + a ≤ b",
  "args": "{a b c : Int}  (h : a ≤ b + c)"},
 {"type": "-a ≤ b - c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : c ≤ a + b) : -a ≤ b - c := by have h := Int.le_neg_add_of_add_le (Int.sub_left_le_of_le_add h); sorry",
  "name": "neg_le_sub_left_of_le_add",
  "kind": "theorem",
  "first-tactic":
  "have h := Int.le_neg_add_of_add_le (Int.sub_left_le_of_le_add h)",
  "core-prompt": "{a b c : Int}  (h : c ≤ a + b) : -a ≤ b - c",
  "args": "{a b c : Int}  (h : c ≤ a + b)"},
 {"type": "a + b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : b < -a + c) : a + b < c := by have h := Int.add_lt_add_left h a; sorry",
  "name": "add_lt_of_lt_neg_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h a",
  "core-prompt": "{a b c : Int}  (h : b < -a + c) : a + b < c",
  "args": "{a b c : Int}  (h : b < -a + c)"},
 {"type": "b < -a + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b < c) : b < -a + c := by have h := Int.add_lt_add_left h (-a); sorry",
  "name": "lt_neg_add_of_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h (-a)",
  "core-prompt": "{a b c : Int}  (h : a + b < c) : b < -a + c",
  "args": "{a b c : Int}  (h : a + b < c)"},
 {"type": "a + b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : b < c - a) : a + b < c := by have h := Int.add_lt_add_left h a; sorry",
  "name": "add_lt_of_lt_sub_left",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h a",
  "core-prompt": "{a b c : Int}  (h : b < c - a) : a + b < c",
  "args": "{a b c : Int}  (h : b < c - a)"},
 {"type": "b < c - a",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b < c) : b < c - a := by have h := Int.add_lt_add_right h (-a); sorry",
  "name": "lt_sub_left_of_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-a)",
  "core-prompt": "{a b c : Int}  (h : a + b < c) : b < c - a",
  "args": "{a b c : Int}  (h : a + b < c)"},
 {"type": "a + b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < c - b) : a + b < c := by have h := Int.add_lt_add_right h b; sorry",
  "name": "add_lt_of_lt_sub_right",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b c : Int}  (h : a < c - b) : a + b < c",
  "args": "{a b c : Int}  (h : a < c - b)"},
 {"type": "a < c - b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b < c) : a < c - b := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "lt_sub_right_of_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b c : Int}  (h : a + b < c) : a < c - b",
  "args": "{a b c : Int}  (h : a + b < c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -b + a < c) : a < b + c := by have h := Int.add_lt_add_left h b; sorry",
  "name": "lt_add_of_neg_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h b",
  "core-prompt": "{a b c : Int}  (h : -b + a < c) : a < b + c",
  "args": "{a b c : Int}  (h : -b + a < c)"},
 {"type": "-b + a < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : -b + a < c := by have h := Int.add_lt_add_left h (-b); sorry",
  "name": "neg_add_lt_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h (-b)",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : -b + a < c",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a - b < c) : a < b + c := by have h := Int.add_lt_add_right h b; sorry",
  "name": "lt_add_of_sub_left_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b c : Int}  (h : a - b < c) : a < b + c",
  "args": "{a b c : Int}  (h : a - b < c)"},
 {"type": "a - b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : a - b < c := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "sub_left_lt_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : a - b < c",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a - c < b) : a < b + c := by have h := Int.add_lt_add_right h c; sorry",
  "name": "lt_add_of_sub_right_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h c",
  "core-prompt": "{a b c : Int}  (h : a - c < b) : a < b + c",
  "args": "{a b c : Int}  (h : a - c < b)"},
 {"type": "a - c < b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : a - c < b := by have h := Int.add_lt_add_right h (-c); sorry",
  "name": "sub_right_lt_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-c)",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : a - c < b",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -b + a < c) : a < b + c := by rw [Int.add_comm] at h; sorry",
  "name": "lt_add_of_neg_add_lt_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : -b + a < c) : a < b + c",
  "args": "{a b c : Int}  (h : -b + a < c)"},
 {"type": "-b + a < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : -b + a < c := by rw [Int.add_comm]; sorry",
  "name": "neg_add_lt_left_of_lt_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : -b + a < c",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -c + a < b) : a < b + c := by rw [Int.add_comm] at h; sorry",
  "name": "lt_add_of_neg_add_lt_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : -c + a < b) : a < b + c",
  "args": "{a b c : Int}  (h : -c + a < b)"},
 {"type": "-c + a < b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : -c + a < b := by rw [Int.add_comm] at h; sorry",
  "name": "neg_add_lt_right_of_lt_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : -c + a < b",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "-a < b - c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : c < a + b) : -a < b - c := by have h := Int.lt_neg_add_of_add_lt (Int.sub_left_lt_of_lt_add h); sorry",
  "name": "neg_lt_sub_left_of_lt_add",
  "kind": "theorem",
  "first-tactic":
  "have h := Int.lt_neg_add_of_add_lt (Int.sub_left_lt_of_lt_add h)",
  "core-prompt": "{a b c : Int}  (h : c < a + b) : -a < b - c",
  "args": "{a b c : Int}  (h : c < a + b)"},
 {"type": "c * a < c * b",
  "tactic-prompt":
  "theorem {a b c : Int}    (h₁ : a < b)  (h₂ : 0 < c) : c * a < c * b := by have : 0 < c * (b - a) := Int.mul_pos h₂ (Int.sub_pos_of_lt h₁); sorry",
  "name": "mul_lt_mul_of_pos_left",
  "kind": "theorem",
  "first-tactic":
  "have : 0 < c * (b - a) := Int.mul_pos h₂ (Int.sub_pos_of_lt h₁)",
  "core-prompt": "{a b c : Int}    (h₁ : a < b)  (h₂ : 0 < c) : c * a < c * b",
  "args": "{a b c : Int}    (h₁ : a < b)  (h₂ : 0 < c)"},
 {"type": "a * c < b * c",
  "tactic-prompt":
  "theorem {a b c : Int}    (h₁ : a < b)  (h₂ : 0 < c) : a * c < b * c := by have : 0 < b - a := Int.sub_pos_of_lt h₁; sorry",
  "name": "mul_lt_mul_of_pos_right",
  "kind": "theorem",
  "first-tactic": "have : 0 < b - a := Int.sub_pos_of_lt h₁",
  "core-prompt": "{a b c : Int}    (h₁ : a < b)  (h₂ : 0 < c) : a * c < b * c",
  "args": "{a b c : Int}    (h₁ : a < b)  (h₂ : 0 < c)"},
 {"type": "c * a ≤ c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (h₁ : a ≤ b)  (h₂ : 0 ≤ c) : c * a ≤ c * b := by if hba : b ≤ a then rw [Int.le_antisymm hba h₁]; apply Int.le_refl else\n  if hc0 : c ≤ 0 then simp [Int.le_antisymm hc0 h₂]; sorry",
  "name": "mul_le_mul_of_nonneg_left",
  "kind": "theorem",
  "first-tactic":
  "if hba : b ≤ a then rw [Int.le_antisymm hba h₁]; apply Int.le_refl else\n  if hc0 : c ≤ 0 then simp [Int.le_antisymm hc0 h₂]",
  "core-prompt":
  "{a b c : Int}      (h₁ : a ≤ b)  (h₂ : 0 ≤ c) : c * a ≤ c * b",
  "args": "{a b c : Int}      (h₁ : a ≤ b)  (h₂ : 0 ≤ c)"},
 {"type": "a * c ≤ b * c",
  "tactic-prompt":
  "theorem {a b c : Int}      (h₁ : a ≤ b)  (h₂ : 0 ≤ c) : a * c ≤ b * c := by rw [Int.mul_comm]; sorry",
  "name": "mul_le_mul_of_nonneg_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (h₁ : a ≤ b)  (h₂ : 0 ≤ c) : a * c ≤ b * c",
  "args": "{a b c : Int}      (h₁ : a ≤ b)  (h₂ : 0 ≤ c)"},
 {"type": "a * b ≤ 0",
  "tactic-prompt":
  "theorem {a b : Int}    (ha : 0 ≤ a)  (hb : b ≤ 0) : a * b ≤ 0 := by have h : a * b ≤ a * 0 := Int.mul_le_mul_of_nonneg_left hb ha; sorry",
  "name": "mul_nonpos_of_nonneg_of_nonpos",
  "kind": "theorem",
  "first-tactic":
  "have h : a * b ≤ a * 0 := Int.mul_le_mul_of_nonneg_left hb ha",
  "core-prompt": "{a b : Int}    (ha : 0 ≤ a)  (hb : b ≤ 0) : a * b ≤ 0",
  "args": "{a b : Int}    (ha : 0 ≤ a)  (hb : b ≤ 0)"},
 {"type": "a * b ≤ 0",
  "tactic-prompt":
  "theorem {a b : Int}    (ha : a ≤ 0)  (hb : 0 ≤ b) : a * b ≤ 0 := by have h : a * b ≤ 0 * b := Int.mul_le_mul_of_nonneg_right ha hb; sorry",
  "name": "mul_nonpos_of_nonpos_of_nonneg",
  "kind": "theorem",
  "first-tactic":
  "have h : a * b ≤ 0 * b := Int.mul_le_mul_of_nonneg_right ha hb",
  "core-prompt": "{a b : Int}    (ha : a ≤ 0)  (hb : 0 ≤ b) : a * b ≤ 0",
  "args": "{a b : Int}    (ha : a ≤ 0)  (hb : 0 ≤ b)"},
 {"type": "a * b < 0",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : 0 < a)  (hb : b < 0) : a * b < 0 := by have h : a * b < a * 0 := Int.mul_lt_mul_of_pos_left hb ha; sorry",
  "name": "mul_neg_of_pos_of_neg",
  "kind": "theorem",
  "first-tactic": "have h : a * b < a * 0 := Int.mul_lt_mul_of_pos_left hb ha",
  "core-prompt": "{a b : Int}  (ha : 0 < a)  (hb : b < 0) : a * b < 0",
  "args": "{a b : Int}  (ha : 0 < a)  (hb : b < 0)"},
 {"type": "a * b < 0",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : a < 0)  (hb : 0 < b) : a * b < 0 := by have h : a * b < 0 * b := Int.mul_lt_mul_of_pos_right ha hb; sorry",
  "name": "mul_neg_of_neg_of_pos",
  "kind": "theorem",
  "first-tactic": "have h : a * b < 0 * b := Int.mul_lt_mul_of_pos_right ha hb",
  "core-prompt": "{a b : Int}  (ha : a < 0)  (hb : 0 < b) : a * b < 0",
  "args": "{a b : Int}  (ha : a < 0)  (hb : 0 < b)"},
 {"type": "0 ≤ a * b",
  "tactic-prompt":
  "theorem {a b : Int}    (ha : a ≤ 0)  (hb : b ≤ 0) : 0 ≤ a * b := by have : 0 * b ≤ a * b := Int.mul_le_mul_of_nonpos_right ha hb; sorry",
  "name": "mul_nonneg_of_nonpos_of_nonpos",
  "kind": "theorem",
  "first-tactic":
  "have : 0 * b ≤ a * b := Int.mul_le_mul_of_nonpos_right ha hb",
  "core-prompt": "{a b : Int}    (ha : a ≤ 0)  (hb : b ≤ 0) : 0 ≤ a * b",
  "args": "{a b : Int}    (ha : a ≤ 0)  (hb : b ≤ 0)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : a < 0)  (hb : b < 0) : 0 < a * b := by have : 0 * b < a * b := Int.mul_lt_mul_of_neg_right ha hb; sorry",
  "name": "mul_pos_of_neg_of_neg",
  "kind": "theorem",
  "first-tactic": "have : 0 * b < a * b := Int.mul_lt_mul_of_neg_right ha hb",
  "core-prompt": "{a b : Int}  (ha : a < 0)  (hb : b < 0) : 0 < a * b",
  "args": "{a b : Int}  (ha : a < 0)  (hb : b < 0)"},
 {"type": "(natAbs a : Int) = -a",
  "tactic-prompt":
  "theorem {a : Int}  (H : a ≤ 0) : (natAbs a : Int) = -a := by rw [← natAbs_neg]; sorry",
  "name": "ofNat_natAbs_of_nonpos",
  "kind": "theorem",
  "first-tactic": "rw [← natAbs_neg]",
  "core-prompt": "{a : Int}  (H : a ≤ 0) : (natAbs a : Int) = -a",
  "args": "{a : Int}  (H : a ≤ 0)"},
 {"type": "a * b = 0 ↔ a = 0 ∨ b = 0",
  "tactic-prompt":
  "theorem {a b : Int} : a * b = 0 ↔ a = 0 ∨ b = 0 := by refine ⟨fun h => ?_, fun h => h.elim (by simp [·, Int.zero_mul]) (by simp [·, Int.mul_zero])⟩; sorry",
  "name": "mul_eq_zero",
  "kind": "theorem",
  "first-tactic":
  "refine ⟨fun h => ?_, fun h => h.elim (by simp [·, Int.zero_mul]) (by simp [·, Int.mul_zero])⟩",
  "core-prompt": "{a b : Int} : a * b = 0 ↔ a = 0 ∨ b = 0",
  "args": "{a b : Int}"},
 {"type": "natAbs a = n ↔ (a - n) * (a + n) = 0",
  "tactic-prompt":
  "theorem  : natAbs a = n ↔ (a - n) * (a + n) = 0 := by rw [natAbs_eq_iff]; sorry",
  "name": "eq_natAbs_iff_mul_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [natAbs_eq_iff]",
  "core-prompt": " : natAbs a = n ↔ (a - n) * (a + n) = 0",
  "args": ""},
 {"type": "natAbs (a - b) ≤ natAbs a + natAbs b",
  "tactic-prompt":
  "theorem (a b : Int) : natAbs (a - b) ≤ natAbs a + natAbs b := by rw [← Int.natAbs_neg b]; sorry",
  "name": "natAbs_sub_le",
  "kind": "theorem",
  "first-tactic": "rw [← Int.natAbs_neg b]",
  "core-prompt": "(a b : Int) : natAbs (a - b) ≤ natAbs a + natAbs b",
  "args": "(a b : Int)"},
 {"type": "(toNat a : Int) = a",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 ≤ a) : (toNat a : Int) = a := by rw [toNat_eq_max]; sorry",
  "name": "toNat_of_nonneg",
  "kind": "theorem",
  "first-tactic": "rw [toNat_eq_max]",
  "core-prompt": "{a : Int}  (h : 0 ≤ a) : (toNat a : Int) = a",
  "args": "{a : Int}  (h : 0 ≤ a)"},
 {"type": "a ≤ toNat a",
  "tactic-prompt":
  "theorem (a : Int) : a ≤ toNat a := by rw [toNat_eq_max]; sorry",
  "name": "self_le_toNat",
  "kind": "theorem",
  "first-tactic": "rw [toNat_eq_max]",
  "core-prompt": "(a : Int) : a ≤ toNat a",
  "args": "(a : Int)"},
 {"type": "n ≤ z.toNat ↔ (n : Int) ≤ z",
  "tactic-prompt":
  "theorem {n : Nat}  {z : Int}  (h : 0 ≤ z) : n ≤ z.toNat ↔ (n : Int) ≤ z := by rw [← Int.ofNat_le]; sorry",
  "name": "le_toNat",
  "kind": "theorem",
  "first-tactic": "rw [← Int.ofNat_le]",
  "core-prompt":
  "{n : Nat}  {z : Int}  (h : 0 ≤ z) : n ≤ z.toNat ↔ (n : Int) ≤ z",
  "args": "{n : Nat}  {z : Int}  (h : 0 ≤ z)"},
 {"type": "z.toNat < n ↔ z < (n : Int)",
  "tactic-prompt":
  "theorem {n : Nat}  {z : Int}  (h : 0 ≤ z) : z.toNat < n ↔ z < (n : Int) := by rw [← Int.not_le]; sorry",
  "name": "toNat_lt",
  "kind": "theorem",
  "first-tactic": "rw [← Int.not_le]",
  "core-prompt":
  "{n : Nat}  {z : Int}  (h : 0 ≤ z) : z.toNat < n ↔ z < (n : Int)",
  "args": "{n : Nat}  {z : Int}  (h : 0 ≤ z)"},
 {"type": "(num / g).natAbs.coprime (den / g)",
  "tactic-prompt":
  "theorem {num : Int}  {den g : Nat}  (den_nz : den ≠ 0)      (e : g = num.natAbs.gcd den) : (num / g).natAbs.coprime (den / g) := by rw [← Int.div_eq_ediv_of_dvd (e ▸ Int.ofNat_dvd_left.2 (Nat.gcd_dvd_left ..))]; sorry",
  "name": "normalize.reduced'",
  "kind": "theorem",
  "first-tactic":
  "rw [← Int.div_eq_ediv_of_dvd (e ▸ Int.ofNat_dvd_left.2 (Nat.gcd_dvd_left ..))]",
  "core-prompt":
  "{num : Int}  {den g : Nat}  (den_nz : den ≠ 0)      (e : g = num.natAbs.gcd den) : (num / g).natAbs.coprime (den / g)",
  "args":
  "{num : Int}  {den g : Nat}  (den_nz : den ≠ 0)      (e : g = num.natAbs.gcd den)"},
 {"type":
  "normalize (↑a * n) (a * d) (Nat.mul_ne_zero a0 d0) = normalize n d d0",
  "tactic-prompt":
  "theorem {a : Nat}  (d0 : d ≠ 0)  (a0 : a ≠ 0) : normalize (↑a * n) (a * d) (Nat.mul_ne_zero a0 d0) = normalize n d d0 := by simp [normalize_eq]; sorry",
  "name": "normalize_mul_left",
  "kind": "theorem",
  "first-tactic": "simp [normalize_eq]",
  "core-prompt":
  "{a : Nat}  (d0 : d ≠ 0)  (a0 : a ≠ 0) : normalize (↑a * n) (a * d) (Nat.mul_ne_zero a0 d0) = normalize n d d0",
  "args": "{a : Nat}  (d0 : d ≠ 0)  (a0 : a ≠ 0)"},
 {"type":
  "normalize (n * a) (d * a) (Nat.mul_ne_zero d0 a0) = normalize n d d0",
  "tactic-prompt":
  "theorem {a : Nat}  (d0 : d ≠ 0)  (a0 : a ≠ 0) : normalize (n * a) (d * a) (Nat.mul_ne_zero d0 a0) = normalize n d d0 := by rw [← normalize_mul_left (d0 := d0) a0]; sorry",
  "name": "normalize_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [← normalize_mul_left (d0 := d0) a0]",
  "core-prompt":
  "{a : Nat}  (d0 : d ≠ 0)  (a0 : a ≠ 0) : normalize (n * a) (d * a) (Nat.mul_ne_zero d0 a0) = normalize n d d0",
  "args": "{a : Nat}  (d0 : d ≠ 0)  (a0 : a ≠ 0)"},
 {"type": "normalize n₁ d₁ z₁ = normalize n₂ d₂ z₂ ↔ n₁ * d₂ = n₂ * d₁",
  "tactic-prompt":
  "theorem (z₁ : d₁ ≠ 0)  (z₂ : d₂ ≠ 0) : normalize n₁ d₁ z₁ = normalize n₂ d₂ z₂ ↔ n₁ * d₂ = n₂ * d₁ := by constructor; sorry",
  "name": "normalize_eq_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "(z₁ : d₁ ≠ 0)  (z₂ : d₂ ≠ 0) : normalize n₁ d₁ z₁ = normalize n₂ d₂ z₂ ↔ n₁ * d₂ = n₂ * d₁",
  "args": "(z₁ : d₁ ≠ 0)  (z₂ : d₂ ≠ 0)"},
 {"type": "normalize n d d0 = 0 ↔ n = 0",
  "tactic-prompt":
  "theorem (d0 : d ≠ 0) : normalize n d d0 = 0 ↔ n = 0 := by have' := normalize_eq_iff d0 Nat.one_ne_zero; sorry",
  "name": "normalize_eq_zero",
  "kind": "theorem",
  "first-tactic": "have' := normalize_eq_iff d0 Nat.one_ne_zero",
  "core-prompt": "(d0 : d ≠ 0) : normalize n d d0 = 0 ↔ n = 0",
  "args": "(d0 : d ≠ 0)"},
 {"type": "∃ m : Nat, m ≠ 0 ∧ n = n' * m ∧ d = d' * m",
  "tactic-prompt":
  "theorem (h : normalize n d z = ⟨n', d', z', c⟩) : ∃ m : Nat, m ≠ 0 ∧ n = n' * m ∧ d = d' * m := by have := normalize_num_den' n d z; sorry",
  "name": "normalize_num_den",
  "kind": "theorem",
  "first-tactic": "have := normalize_num_den' n d z",
  "core-prompt":
  "(h : normalize n d z = ⟨n', d', z', c⟩) : ∃ m : Nat, m ≠ 0 ∧ n = n' * m ∧ d = d' * m",
  "args": "(h : normalize n d z = ⟨n', d', z', c⟩)"},
 {"type": "mkRat a.num a.den = a",
  "tactic-prompt":
  "theorem (a : Rat) : mkRat a.num a.den = a := by rw [← normalize_eq_mkRat a.den_nz]; sorry",
  "name": "mkRat_self",
  "kind": "theorem",
  "first-tactic": "rw [← normalize_eq_mkRat a.den_nz]",
  "core-prompt": "(a : Rat) : mkRat a.num a.den = a",
  "args": "(a : Rat)"},
 {"type": "mkRat n d = 0 ↔ n = 0",
  "tactic-prompt":
  "theorem (d0 : d ≠ 0) : mkRat n d = 0 ↔ n = 0 := by simp [mkRat_def]; sorry",
  "name": "mkRat_eq_zero",
  "kind": "theorem",
  "first-tactic": "simp [mkRat_def]",
  "core-prompt": "(d0 : d ≠ 0) : mkRat n d = 0 ↔ n = 0",
  "args": "(d0 : d ≠ 0)"},
 {"type": "mkRat (↑a * n) (a * d) = mkRat n d",
  "tactic-prompt":
  "theorem {a : Nat}  (a0 : a ≠ 0) : mkRat (↑a * n) (a * d) = mkRat n d := by if d0 : d = 0 then simp [d0] else\n  rw [← normalize_eq_mkRat d0]; sorry",
  "name": "mkRat_mul_left",
  "kind": "theorem",
  "first-tactic":
  "if d0 : d = 0 then simp [d0] else\n  rw [← normalize_eq_mkRat d0]",
  "core-prompt": "{a : Nat}  (a0 : a ≠ 0) : mkRat (↑a * n) (a * d) = mkRat n d",
  "args": "{a : Nat}  (a0 : a ≠ 0)"},
 {"type": "mkRat (n * a) (d * a) = mkRat n d",
  "tactic-prompt":
  "theorem {a : Nat}  (a0 : a ≠ 0) : mkRat (n * a) (d * a) = mkRat n d := by rw [← mkRat_mul_left (d := d) a0]; sorry",
  "name": "mkRat_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [← mkRat_mul_left (d := d) a0]",
  "core-prompt": "{a : Nat}  (a0 : a ≠ 0) : mkRat (n * a) (d * a) = mkRat n d",
  "args": "{a : Nat}  (a0 : a ≠ 0)"},
 {"type": "mkRat n₁ d₁ = mkRat n₂ d₂ ↔ n₁ * d₂ = n₂ * d₁",
  "tactic-prompt":
  "theorem (z₁ : d₁ ≠ 0)  (z₂ : d₂ ≠ 0) : mkRat n₁ d₁ = mkRat n₂ d₂ ↔ n₁ * d₂ = n₂ * d₁ := by rw [← normalize_eq_mkRat z₁]; sorry",
  "name": "mkRat_eq_iff",
  "kind": "theorem",
  "first-tactic": "rw [← normalize_eq_mkRat z₁]",
  "core-prompt":
  "(z₁ : d₁ ≠ 0)  (z₂ : d₂ ≠ 0) : mkRat n₁ d₁ = mkRat n₂ d₂ ↔ n₁ * d₂ = n₂ * d₁",
  "args": "(z₁ : d₁ ≠ 0)  (z₂ : d₂ ≠ 0)"},
 {"type": "a.num /. a.den = a",
  "tactic-prompt":
  "theorem (a : Rat) : a.num /. a.den = a := by rw [divInt_ofNat]; sorry",
  "name": "divInt_self",
  "kind": "theorem",
  "first-tactic": "rw [divInt_ofNat]",
  "core-prompt": "(a : Rat) : a.num /. a.den = a",
  "args": "(a : Rat)"},
 {"type": "n₁ /. d₁ = n₂ /. d₂ ↔ n₁ * d₂ = n₂ * d₁",
  "tactic-prompt":
  "theorem (z₁ : d₁ ≠ 0)  (z₂ : d₂ ≠ 0) : n₁ /. d₁ = n₂ /. d₂ ↔ n₁ * d₂ = n₂ * d₁ := by rcases Int.eq_nat_or_neg d₁ with ⟨_, rfl | rfl⟩; sorry",
  "name": "divInt_eq_iff",
  "kind": "theorem",
  "first-tactic": "rcases Int.eq_nat_or_neg d₁ with ⟨_, rfl | rfl⟩",
  "core-prompt":
  "(z₁ : d₁ ≠ 0)  (z₂ : d₂ ≠ 0) : n₁ /. d₁ = n₂ /. d₂ ↔ n₁ * d₂ = n₂ * d₁",
  "args": "(z₁ : d₁ ≠ 0)  (z₂ : d₂ ≠ 0)"},
 {"type": "(a * n) /. (a * d) = n /. d",
  "tactic-prompt":
  "theorem {a : Int}  (a0 : a ≠ 0) : (a * n) /. (a * d) = n /. d := by if d0 : d = 0 then simp [d0] else\n  simp [divInt_eq_iff (Int.mul_ne_zero a0 d0) d0]; sorry",
  "name": "divInt_mul_left",
  "kind": "theorem",
  "first-tactic":
  "if d0 : d = 0 then simp [d0] else\n  simp [divInt_eq_iff (Int.mul_ne_zero a0 d0) d0]",
  "core-prompt": "{a : Int}  (a0 : a ≠ 0) : (a * n) /. (a * d) = n /. d",
  "args": "{a : Int}  (a0 : a ≠ 0)"},
 {"type": "(n * a) /. (d * a) = n /. d",
  "tactic-prompt":
  "theorem {a : Int}  (a0 : a ≠ 0) : (n * a) /. (d * a) = n /. d := by simp [← divInt_mul_left (d := d) a0]; sorry",
  "name": "divInt_mul_right",
  "kind": "theorem",
  "first-tactic": "simp [← divInt_mul_left (d := d) a0]",
  "core-prompt": "{a : Int}  (a0 : a ≠ 0) : (n * a) /. (d * a) = n /. d",
  "args": "{a : Int}  (a0 : a ≠ 0)"},
 {"type": "∃ m, m ≠ 0 ∧ n = n' * m ∧ d = d' * m",
  "tactic-prompt":
  "theorem (z : d ≠ 0)  (h : n /. d = ⟨n', d', z', c⟩) : ∃ m, m ≠ 0 ∧ n = n' * m ∧ d = d' * m := by rcases Int.eq_nat_or_neg d with ⟨_, rfl | rfl⟩; sorry",
  "name": "divInt_num_den",
  "kind": "theorem",
  "first-tactic": "rcases Int.eq_nat_or_neg d with ⟨_, rfl | rfl⟩",
  "core-prompt":
  "(z : d ≠ 0)  (h : n /. d = ⟨n', d', z', c⟩) : ∃ m, m ≠ 0 ∧ n = n' * m ∧ d = d' * m",
  "args": "(z : d ≠ 0)  (h : n /. d = ⟨n', d', z', c⟩)"},
 {"type":
  "a + b = normalize (a.num * b.den + b.num * a.den) (a.den * b.den)\n      (Nat.mul_ne_zero a.den_nz b.den_nz)",
  "tactic-prompt":
  "theorem (a b : Rat) : a + b = normalize (a.num * b.den + b.num * a.den) (a.den * b.den)\n      (Nat.mul_ne_zero a.den_nz b.den_nz) := by show Rat.add .. = _; sorry",
  "name": "add_def",
  "kind": "theorem",
  "first-tactic": "show Rat.add .. = _",
  "core-prompt":
  "(a b : Rat) : a + b = normalize (a.num * b.den + b.num * a.den) (a.den * b.den)\n      (Nat.mul_ne_zero a.den_nz b.den_nz)",
  "args": "(a b : Rat)"},
 {"type": "a + b = mkRat (a.num * b.den + b.num * a.den) (a.den * b.den)",
  "tactic-prompt":
  "theorem (a b : Rat) : a + b = mkRat (a.num * b.den + b.num * a.den) (a.den * b.den) := by rw [add_def]; sorry",
  "name": "add_def'",
  "kind": "theorem",
  "first-tactic": "rw [add_def]",
  "core-prompt":
  "(a b : Rat) : a + b = mkRat (a.num * b.den + b.num * a.den) (a.den * b.den)",
  "args": "(a b : Rat)"},
 {"type":
  "a - b = normalize (a.num * b.den - b.num * a.den) (a.den * b.den)\n      (Nat.mul_ne_zero a.den_nz b.den_nz)",
  "tactic-prompt":
  "theorem (a b : Rat) : a - b = normalize (a.num * b.den - b.num * a.den) (a.den * b.den)\n      (Nat.mul_ne_zero a.den_nz b.den_nz) := by show Rat.sub .. = _; sorry",
  "name": "sub_def",
  "kind": "theorem",
  "first-tactic": "show Rat.sub .. = _",
  "core-prompt":
  "(a b : Rat) : a - b = normalize (a.num * b.den - b.num * a.den) (a.den * b.den)\n      (Nat.mul_ne_zero a.den_nz b.den_nz)",
  "args": "(a b : Rat)"},
 {"type": "a - b = mkRat (a.num * b.den - b.num * a.den) (a.den * b.den)",
  "tactic-prompt":
  "theorem (a b : Rat) : a - b = mkRat (a.num * b.den - b.num * a.den) (a.den * b.den) := by rw [sub_def]; sorry",
  "name": "sub_def'",
  "kind": "theorem",
  "first-tactic": "rw [sub_def]",
  "core-prompt":
  "(a b : Rat) : a - b = mkRat (a.num * b.den - b.num * a.den) (a.den * b.den)",
  "args": "(a b : Rat)"},
 {"type": "a - b = a + -b",
  "tactic-prompt":
  "theorem (a b : Rat) : a - b = a + -b := by simp [add_def]; sorry",
  "name": "sub_eq_add_neg",
  "kind": "theorem",
  "first-tactic": "simp [add_def]",
  "core-prompt": "(a b : Rat) : a - b = a + -b",
  "args": "(a b : Rat)"},
 {"type":
  "a * b = normalize (a.num * b.num) (a.den * b.den) (Nat.mul_ne_zero a.den_nz b.den_nz)",
  "tactic-prompt":
  "theorem (a b : Rat) : a * b = normalize (a.num * b.num) (a.den * b.den) (Nat.mul_ne_zero a.den_nz b.den_nz) := by show Rat.mul .. = _; sorry",
  "name": "mul_def",
  "kind": "theorem",
  "first-tactic": "show Rat.mul .. = _",
  "core-prompt":
  "(a b : Rat) : a * b = normalize (a.num * b.num) (a.den * b.den) (Nat.mul_ne_zero a.den_nz b.den_nz)",
  "args": "(a b : Rat)"},
 {"type": "a * b = b * a",
  "tactic-prompt":
  "theorem (a b : Rat) : a * b = b * a := by simp [mul_def]; sorry",
  "name": "mul_comm",
  "kind": "theorem",
  "first-tactic": "simp [mul_def]",
  "core-prompt": "(a b : Rat) : a * b = b * a",
  "args": "(a b : Rat)"},
 {"type": "0 * a = 0",
  "tactic-prompt": "theorem (a : Rat) : 0 * a = 0 := by simp [mul_def]; sorry",
  "name": "zero_mul",
  "kind": "theorem",
  "first-tactic": "simp [mul_def]",
  "core-prompt": "(a : Rat) : 0 * a = 0",
  "args": "(a : Rat)"},
 {"type": "a * 0 = 0",
  "tactic-prompt": "theorem (a : Rat) : a * 0 = 0 := by simp [mul_def]; sorry",
  "name": "mul_zero",
  "kind": "theorem",
  "first-tactic": "simp [mul_def]",
  "core-prompt": "(a : Rat) : a * 0 = 0",
  "args": "(a : Rat)"},
 {"type": "1 * a = a",
  "tactic-prompt": "theorem (a : Rat) : 1 * a = a := by simp [mul_def]; sorry",
  "name": "one_mul",
  "kind": "theorem",
  "first-tactic": "simp [mul_def]",
  "core-prompt": "(a : Rat) : 1 * a = a",
  "args": "(a : Rat)"},
 {"type": "a * 1 = a",
  "tactic-prompt": "theorem (a : Rat) : a * 1 = a := by simp [mul_def]; sorry",
  "name": "mul_one",
  "kind": "theorem",
  "first-tactic": "simp [mul_def]",
  "core-prompt": "(a : Rat) : a * 1 = a",
  "args": "(a : Rat)"},
 {"type": "a.inv = a.den /. a.num",
  "tactic-prompt":
  "theorem (a : Rat) : a.inv = a.den /. a.num := by unfold Rat.inv; sorry",
  "name": "inv_def",
  "kind": "theorem",
  "first-tactic": "unfold Rat.inv",
  "core-prompt": "(a : Rat) : a.inv = a.den /. a.num",
  "args": "(a : Rat)"},
 {"type": "(n /. d).inv = d /. n",
  "tactic-prompt":
  "theorem (n d : Int) : (n /. d).inv = d /. n := by if z : d = 0 then simp [z] else\n  cases e : n /. d; rcases divInt_num_den z e with ⟨g]; sorry",
  "name": "inv_divInt",
  "kind": "theorem",
  "first-tactic":
  "if z : d = 0 then simp [z] else\n  cases e : n /. d; rcases divInt_num_den z e with ⟨g]",
  "core-prompt": "(n d : Int) : (n /. d).inv = d /. n",
  "args": "(n d : Int)"},
 {"type": "as.toArray.size = as.length",
  "tactic-prompt":
  "theorem (as : List α) : as.toArray.size = as.length := by simp [size]; sorry",
  "name": "size_toArray",
  "kind": "theorem",
  "first-tactic": "simp [size]",
  "core-prompt": "(as : List α) : as.toArray.size = as.length",
  "args": "(as : List α)"},
 {"type": "(Array.mk as).size = as.length",
  "tactic-prompt":
  "theorem (as : List α) : (Array.mk as).size = as.length := by simp [size]; sorry",
  "name": "size_mk",
  "kind": "theorem",
  "first-tactic": "simp [size]",
  "core-prompt": "(as : List α) : (Array.mk as).size = as.length",
  "args": "(as : List α)"},
 {"type": "a[i] = a.data.get ⟨i, h⟩",
  "tactic-prompt":
  "theorem (a : Array α)  (h : i < a.size) : a[i] = a.data.get ⟨i, h⟩ := by by_cases i < a.size; sorry",
  "name": "getElem_eq_data_get",
  "kind": "theorem",
  "first-tactic": "by_cases i < a.size",
  "core-prompt": "(a : Array α)  (h : i < a.size) : a[i] = a.data.get ⟨i, h⟩",
  "args": "(a : Array α)  (h : i < a.size)"},
 {"type": "arr.foldlM f init = arr.data.foldlM f init",
  "tactic-prompt":
  "theorem [Monad m]      (f : β → α → m β)  (init : β)  (arr : Array α) : arr.foldlM f init = arr.data.foldlM f init := by simp [foldlM]; sorry",
  "name": "foldlM_eq_foldlM_data",
  "kind": "theorem",
  "first-tactic": "simp [foldlM]",
  "core-prompt":
  "[Monad m]      (f : β → α → m β)  (init : β)  (arr : Array α) : arr.foldlM f init = arr.data.foldlM f init",
  "args": "[Monad m]      (f : β → α → m β)  (init : β)  (arr : Array α)"},
 {"type": "arr.foldrM f init = arr.data.reverse.foldlM (fun x y => f y x) init",
  "tactic-prompt":
  "theorem [Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α) : arr.foldrM f init = arr.data.reverse.foldlM (fun x y => f y x) init := by have : arr = #[] ∨ 0 < arr.size :=\n    match arr with | ⟨[]⟩ => .inl rfl | ⟨a::l⟩ => .inr (Nat.zero_lt_succ _); sorry",
  "name": "foldrM_eq_reverse_foldlM_data",
  "kind": "theorem",
  "first-tactic":
  "have : arr = #[] ∨ 0 < arr.size :=\n    match arr with | ⟨[]⟩ => .inl rfl | ⟨a::l⟩ => .inr (Nat.zero_lt_succ _)",
  "core-prompt":
  "[Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α) : arr.foldrM f init = arr.data.reverse.foldlM (fun x y => f y x) init",
  "args": "[Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α)"},
 {"type": "arr.foldrM f init = arr.data.foldrM f init",
  "tactic-prompt":
  "theorem [Monad m]      (f : α → β → m β)  (init : β)  (arr : Array α) : arr.foldrM f init = arr.data.foldrM f init := by rw [foldrM_eq_reverse_foldlM_data]; sorry",
  "name": "foldrM_eq_foldrM_data",
  "kind": "theorem",
  "first-tactic": "rw [foldrM_eq_reverse_foldlM_data]",
  "core-prompt":
  "[Monad m]      (f : α → β → m β)  (init : β)  (arr : Array α) : arr.foldrM f init = arr.data.foldrM f init",
  "args": "[Monad m]      (f : α → β → m β)  (init : β)  (arr : Array α)"},
 {"type": "(arr.push a).data = arr.data ++ [a]",
  "tactic-prompt":
  "theorem (arr : Array α)  (a : α) : (arr.push a).data = arr.data ++ [a] := by simp [push]; sorry",
  "name": "push_data",
  "kind": "theorem",
  "first-tactic": "simp [push]",
  "core-prompt":
  "(arr : Array α)  (a : α) : (arr.push a).data = arr.data ++ [a]",
  "args": "(arr : Array α)  (a : α)"},
 {"type": "(arr.push a).foldrM f init = f a init >>= arr.foldrM f",
  "tactic-prompt":
  "theorem [Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α)  (a : α) : (arr.push a).foldrM f init = f a init >>= arr.foldrM f := by simp [foldrM_eq_reverse_foldlM_data]; sorry",
  "name": "foldrM_push",
  "kind": "theorem",
  "first-tactic": "simp [foldrM_eq_reverse_foldlM_data]",
  "core-prompt":
  "[Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α)  (a : α) : (arr.push a).foldrM f init = f a init >>= arr.foldrM f",
  "args": "[Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α)  (a : α)"},
 {"type":
  "(arr.push a).foldrM f init (start := arr.size + 1) = f a init >>= arr.foldrM f",
  "tactic-prompt":
  "theorem [Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α)  (a : α) : (arr.push a).foldrM f init (start := arr.size + 1) = f a init >>= arr.foldrM f := by simp [← foldrM_push]; sorry",
  "name": "foldrM_push'",
  "kind": "theorem",
  "first-tactic": "simp [← foldrM_push]",
  "core-prompt":
  "[Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α)  (a : α) : (arr.push a).foldrM f init (start := arr.size + 1) = f a init >>= arr.foldrM f",
  "args": "[Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α)  (a : α)"},
 {"type": "arr.toList = arr.data",
  "tactic-prompt":
  "theorem (arr : Array α) : arr.toList = arr.data := by simp [toList]; sorry",
  "name": "toList_eq",
  "kind": "theorem",
  "first-tactic": "simp [toList]",
  "core-prompt": "(arr : Array α) : arr.toList = arr.data",
  "args": "(arr : Array α)"},
 {"type": "arr.toListRev = arr.data.reverse",
  "tactic-prompt":
  "theorem (arr : Array α) : arr.toListRev = arr.data.reverse := by rw [toListRev]; sorry",
  "name": "toListRev_eq",
  "kind": "theorem",
  "first-tactic": "rw [toListRev]",
  "core-prompt": "(arr : Array α) : arr.toListRev = arr.data.reverse",
  "args": "(arr : Array α)"},
 {"type": "SatisfiesM (motive as.size) (as.foldlM f init)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]      {as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive 0 init)  {f : β → α → m β}      (hf : ∀ i : Fin as.size, ∀ b, motive i.1 b → SatisfiesM (motive (i.1 + 1)) (f b as[i])) : SatisfiesM (motive as.size) (as.foldlM f init) := by let rec go {i j b} (h₁ : j ≤ as.size) (h₂ : as.size ≤ i + j) (H : motive j b) :\n    SatisfiesM (motive as.size) (foldlM.loop f as as.size (Nat.le_refl _) i j b) := by\n    unfold foldlM.loop; split\n    · next hj =>\n      split\n      · cases Nat.not_le_of_gt (by simp [hj]) h₂\n      · exact (hf ⟨j]; sorry",
  "name": "SatisfiesM_foldlM",
  "kind": "theorem",
  "first-tactic":
  "let rec go {i j b} (h₁ : j ≤ as.size) (h₂ : as.size ≤ i + j) (H : motive j b) :\n    SatisfiesM (motive as.size) (foldlM.loop f as as.size (Nat.le_refl _) i j b) := by\n    unfold foldlM.loop; split\n    · next hj =>\n      split\n      · cases Nat.not_le_of_gt (by simp [hj]) h₂\n      · exact (hf ⟨j]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]      {as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive 0 init)  {f : β → α → m β}      (hf : ∀ i : Fin as.size, ∀ b, motive i.1 b → SatisfiesM (motive (i.1 + 1)) (f b as[i])) : SatisfiesM (motive as.size) (as.foldlM f init)",
  "args":
  "[Monad m]  [LawfulMonad m]      {as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive 0 init)  {f : β → α → m β}      (hf : ∀ i : Fin as.size, ∀ b, motive i.1 b → SatisfiesM (motive (i.1 + 1)) (f b as[i]))"},
 {"type": "motive as.size (as.foldl f init)",
  "tactic-prompt":
  "theorem {as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive 0 init)  {f : β → α → β}      (hf : ∀ i : Fin as.size, ∀ b, motive i.1 b → motive (i.1 + 1) (f b as[i])) : motive as.size (as.foldl f init) := by have := SatisfiesM_foldlM (m := Id) (as := as) (f := f) motive h0; sorry",
  "name": "foldl_induction",
  "kind": "theorem",
  "first-tactic":
  "have := SatisfiesM_foldlM (m := Id) (as := as) (f := f) motive h0",
  "core-prompt":
  "{as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive 0 init)  {f : β → α → β}      (hf : ∀ i : Fin as.size, ∀ b, motive i.1 b → motive (i.1 + 1) (f b as[i])) : motive as.size (as.foldl f init)",
  "args":
  "{as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive 0 init)  {f : β → α → β}      (hf : ∀ i : Fin as.size, ∀ b, motive i.1 b → motive (i.1 + 1) (f b as[i]))"},
 {"type":
  "haveI : i < (a.push x).size := by simp [*, Nat.lt_succ_of_le, Nat.le_of_lt]\n    (a.push x)[i] = a[i]",
  "tactic-prompt":
  "theorem (a : Array α)  (x : α)  (i : Nat)  (h : i < a.size) : haveI : i < (a.push x).size := by simp [*, Nat.lt_succ_of_le, Nat.le_of_lt]\n    (a.push x)[i] = a[i] := by simp only [push]; sorry",
  "name": "get_push_lt",
  "kind": "theorem",
  "first-tactic": "simp only [push]",
  "core-prompt":
  "(a : Array α)  (x : α)  (i : Nat)  (h : i < a.size) : haveI : i < (a.push x).size := by simp [*, Nat.lt_succ_of_le, Nat.le_of_lt]\n    (a.push x)[i] = a[i]",
  "args": "(a : Array α)  (x : α)  (i : Nat)  (h : i < a.size)"},
 {"type": "(a.push x)[a.size] = x",
  "tactic-prompt":
  "theorem (a : Array α)  (x : α) : (a.push x)[a.size] = x := by simp only [push]; sorry",
  "name": "get_push_eq",
  "kind": "theorem",
  "first-tactic": "simp only [push]",
  "core-prompt": "(a : Array α)  (x : α) : (a.push x)[a.size] = x",
  "args": "(a : Array α)  (x : α)"},
 {"type": "(a.push x)[i] = if h : i < a.size then a[i] else x",
  "tactic-prompt":
  "theorem (a : Array α)  (x : α)  (i : Nat)  (h : i < (a.push x).size) : (a.push x)[i] = if h : i < a.size then a[i] else x := by if h' : i < a.size then\n    simp [get_push_lt]; sorry",
  "name": "get_push",
  "kind": "theorem",
  "first-tactic": "if h' : i < a.size then\n    simp [get_push_lt]",
  "core-prompt":
  "(a : Array α)  (x : α)  (i : Nat)  (h : i < (a.push x).size) : (a.push x)[i] = if h : i < a.size then a[i] else x",
  "args": "(a : Array α)  (x : α)  (i : Nat)  (h : i < (a.push x).size)"},
 {"type":
  "SatisfiesM\n      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ (arr[i]'(eq ▸ h)))\n      (Array.mapM f as)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (as : Array α)  (f : α → m β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → SatisfiesM (p i · ∧ motive (i + 1)) (f as[i])) : SatisfiesM\n      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ (arr[i]'(eq ▸ h)))\n      (Array.mapM f as) := by unfold mapM; sorry",
  "name": "SatisfiesM_mapM",
  "kind": "theorem",
  "first-tactic": "unfold mapM",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (as : Array α)  (f : α → m β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → SatisfiesM (p i · ∧ motive (i + 1)) (f as[i])) : SatisfiesM\n      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ (arr[i]'(eq ▸ h)))\n      (Array.mapM f as)",
  "args":
  "[Monad m]  [LawfulMonad m]  (as : Array α)  (f : α → m β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → SatisfiesM (p i · ∧ motive (i + 1)) (f as[i]))"},
 {"type": "(arr.map f).data = arr.data.map f",
  "tactic-prompt":
  "theorem (f : α → β)  (arr : Array α) : (arr.map f).data = arr.data.map f := by apply congrArg data (foldl_eq_foldl_data (fun bs a => push bs (f a)) #[] arr) |>.trans; sorry",
  "name": "map_data",
  "kind": "theorem",
  "first-tactic":
  "apply congrArg data (foldl_eq_foldl_data (fun bs a => push bs (f a)) #[] arr) |>.trans",
  "core-prompt":
  "(f : α → β)  (arr : Array α) : (arr.map f).data = arr.data.map f",
  "args": "(f : α → β)  (arr : Array α)"},
 {"type": "(arr.map f).size = arr.size",
  "tactic-prompt":
  "theorem (f : α → β)  (arr : Array α) : (arr.map f).size = arr.size := by simp [size]; sorry",
  "name": "size_map",
  "kind": "theorem",
  "first-tactic": "simp [size]",
  "core-prompt": "(f : α → β)  (arr : Array α) : (arr.map f).size = arr.size",
  "args": "(f : α → β)  (arr : Array α)"},
 {"type": "(arr ++ arr').data = arr.data ++ arr'.data",
  "tactic-prompt":
  "theorem (arr arr' : Array α) : (arr ++ arr').data = arr.data ++ arr'.data := by rw [← append_eq_append]; sorry",
  "name": "append_data",
  "kind": "theorem",
  "first-tactic": "rw [← append_eq_append]",
  "core-prompt":
  "(arr arr' : Array α) : (arr ++ arr').data = arr.data ++ arr'.data",
  "args": "(arr arr' : Array α)"},
 {"type": "(arr ++ l).data = arr.data ++ l",
  "tactic-prompt":
  "theorem (arr : Array α)  (l : List α) : (arr ++ l).data = arr.data ++ l := by rw [← appendList_eq_append]; sorry",
  "name": "appendList_data",
  "kind": "theorem",
  "first-tactic": "rw [← appendList_eq_append]",
  "core-prompt":
  "(arr : Array α)  (l : List α) : (arr ++ l).data = arr.data ++ l",
  "args": "(arr : Array α)  (l : List α)"},
 {"type": "(l.foldl F acc).data = acc.data ++ l.bind G",
  "tactic-prompt":
  "theorem (l : List α)  (acc : Array β)      (F : Array β → α → Array β)  (G : α → List β)      (H : ∀ acc a, (F acc a).data = acc.data ++ G a) : (l.foldl F acc).data = acc.data ++ l.bind G := by induction l generalizing acc; sorry",
  "name": "foldl_data_eq_bind",
  "kind": "theorem",
  "first-tactic": "induction l generalizing acc",
  "core-prompt":
  "(l : List α)  (acc : Array β)      (F : Array β → α → Array β)  (G : α → List β)      (H : ∀ acc a, (F acc a).data = acc.data ++ G a) : (l.foldl F acc).data = acc.data ++ l.bind G",
  "args":
  "(l : List α)  (acc : Array β)      (F : Array β → α → Array β)  (G : α → List β)      (H : ∀ acc a, (F acc a).data = acc.data ++ G a)"},
 {"type":
  "(l.foldl (fun acc a => acc.push (G a)) acc).data = acc.data ++ l.map G",
  "tactic-prompt":
  "theorem (l : List α)  (acc : Array β)  (G : α → β) : (l.foldl (fun acc a => acc.push (G a)) acc).data = acc.data ++ l.map G := by induction l generalizing acc; sorry",
  "name": "foldl_data_eq_map",
  "kind": "theorem",
  "first-tactic": "induction l generalizing acc",
  "core-prompt":
  "(l : List α)  (acc : Array β)  (G : α → β) : (l.foldl (fun acc a => acc.push (G a)) acc).data = acc.data ++ l.map G",
  "args": "(l : List α)  (acc : Array β)  (G : α → β)"},
 {"type": "a[i]? = none",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Nat)  (h : a.size ≤ i) : a[i]? = none := by simp [getElem?_neg]; sorry",
  "name": "get?_len_le",
  "kind": "theorem",
  "first-tactic": "simp [getElem?_neg]",
  "core-prompt": "(a : Array α)  (i : Nat)  (h : a.size ≤ i) : a[i]? = none",
  "args": "(a : Array α)  (i : Nat)  (h : a.size ≤ i)"},
 {"type": "a[i] ∈ a.data",
  "tactic-prompt":
  "theorem (a : Array α)  (h : i < a.size) : a[i] ∈ a.data := by simp [getElem_eq_data_get]; sorry",
  "name": "getElem_mem_data",
  "kind": "theorem",
  "first-tactic": "simp [getElem_eq_data_get]",
  "core-prompt": "(a : Array α)  (h : i < a.size) : a[i] ∈ a.data",
  "args": "(a : Array α)  (h : i < a.size)"},
 {"type": "a[i]? = a.data.get? i",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Nat) : a[i]? = a.data.get? i := by by_cases i < a.size; sorry",
  "name": "getElem?_eq_data_get?",
  "kind": "theorem",
  "first-tactic": "by_cases i < a.size",
  "core-prompt": "(a : Array α)  (i : Nat) : a[i]? = a.data.get? i",
  "args": "(a : Array α)  (i : Nat)"},
 {"type": "a.get! n = (a.get? n).getD default",
  "tactic-prompt":
  "theorem [Inhabited α]  (a : Array α) : a.get! n = (a.get? n).getD default := by simp [get!_eq_getD]; sorry",
  "name": "get!_eq_get?",
  "kind": "theorem",
  "first-tactic": "simp [get!_eq_getD]",
  "core-prompt":
  "[Inhabited α]  (a : Array α) : a.get! n = (a.get? n).getD default",
  "args": "[Inhabited α]  (a : Array α)"},
 {"type": "a.back = a.back?.getD default",
  "tactic-prompt":
  "theorem [Inhabited α]  (a : Array α) : a.back = a.back?.getD default := by simp [back]; sorry",
  "name": "back_eq_back?",
  "kind": "theorem",
  "first-tactic": "simp [back]",
  "core-prompt": "[Inhabited α]  (a : Array α) : a.back = a.back?.getD default",
  "args": "[Inhabited α]  (a : Array α)"},
 {"type": "(a.push x).back? = some x",
  "tactic-prompt":
  "theorem (a : Array α) : (a.push x).back? = some x := by simp [back?]; sorry",
  "name": "back?_push",
  "kind": "theorem",
  "first-tactic": "simp [back?]",
  "core-prompt": "(a : Array α) : (a.push x).back? = some x",
  "args": "(a : Array α)"},
 {"type": "(a.push x).back = x",
  "tactic-prompt":
  "theorem [Inhabited α]  (a : Array α) : (a.push x).back = x := by simp; sorry",
  "name": "back_push",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "[Inhabited α]  (a : Array α) : (a.push x).back = x",
  "args": "[Inhabited α]  (a : Array α)"},
 {"type": "(a.push x)[i]? = some a[i]",
  "tactic-prompt":
  "theorem (a : Array α)  (x : α)  (i : Nat)  (h : i < a.size) : (a.push x)[i]? = some a[i] := by rw [getElem?_pos]; sorry",
  "name": "get?_push_lt",
  "kind": "theorem",
  "first-tactic": "rw [getElem?_pos]",
  "core-prompt":
  "(a : Array α)  (x : α)  (i : Nat)  (h : i < a.size) : (a.push x)[i]? = some a[i]",
  "args": "(a : Array α)  (x : α)  (i : Nat)  (h : i < a.size)"},
 {"type": "(a.push x)[a.size]? = some x",
  "tactic-prompt":
  "theorem (a : Array α)  (x : α) : (a.push x)[a.size]? = some x := by rw [getElem?_pos]; sorry",
  "name": "get?_push_eq",
  "kind": "theorem",
  "first-tactic": "rw [getElem?_pos]",
  "core-prompt": "(a : Array α)  (x : α) : (a.push x)[a.size]? = some x",
  "args": "(a : Array α)  (x : α)"},
 {"type": "(a.set i v)[i.1]'(by simp [i.2]) = v",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Fin a.size)  (v : α) : (a.set i v)[i.1]'(by simp [i.2]) = v := by simp only [set]; sorry",
  "name": "get_set_eq",
  "kind": "theorem",
  "first-tactic": "simp only [set]",
  "core-prompt":
  "(a : Array α)  (i : Fin a.size)  (v : α) : (a.set i v)[i.1]'(by simp [i.2]) = v",
  "args": "(a : Array α)  (i : Fin a.size)  (v : α)"},
 {"type": "(a.set i v)[j]'(by simp [*]) = a[j]",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Fin a.size)  {j : Nat}  (v : α)  (hj : j < a.size)      (h : i.1 ≠ j) : (a.set i v)[j]'(by simp [*]) = a[j] := by simp only [set]; sorry",
  "name": "get_set_ne",
  "kind": "theorem",
  "first-tactic": "simp only [set]",
  "core-prompt":
  "(a : Array α)  (i : Fin a.size)  {j : Nat}  (v : α)  (hj : j < a.size)      (h : i.1 ≠ j) : (a.set i v)[j]'(by simp [*]) = a[j]",
  "args":
  "(a : Array α)  (i : Fin a.size)  {j : Nat}  (v : α)  (hj : j < a.size)      (h : i.1 ≠ j)"},
 {"type": "(a.set i v)[i.1]? = v",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Fin a.size)  (v : α) : (a.set i v)[i.1]? = v := by simp [getElem?_pos]; sorry",
  "name": "get?_set_eq",
  "kind": "theorem",
  "first-tactic": "simp [getElem?_pos]",
  "core-prompt":
  "(a : Array α)  (i : Fin a.size)  (v : α) : (a.set i v)[i.1]? = v",
  "args": "(a : Array α)  (i : Fin a.size)  (v : α)"},
 {"type": "(a.set i v)[j]? = a[j]?",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Fin a.size)  {j : Nat}  (v : α)      (h : i.1 ≠ j) : (a.set i v)[j]? = a[j]? := by by_cases j < a.size; sorry",
  "name": "get?_set_ne",
  "kind": "theorem",
  "first-tactic": "by_cases j < a.size",
  "core-prompt":
  "(a : Array α)  (i : Fin a.size)  {j : Nat}  (v : α)      (h : i.1 ≠ j) : (a.set i v)[j]? = a[j]?",
  "args":
  "(a : Array α)  (i : Fin a.size)  {j : Nat}  (v : α)      (h : i.1 ≠ j)"},
 {"type": "(a.set i v)[j]? = if i.1 = j then some v else a[j]?",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Fin a.size)  (j : Nat)  (v : α) : (a.set i v)[j]? = if i.1 = j then some v else a[j]? := by if h : i.1 = j then subst j; simp [*] else simp [*]; sorry",
  "name": "get?_set",
  "kind": "theorem",
  "first-tactic": "if h : i.1 = j then subst j; simp [*] else simp [*]",
  "core-prompt":
  "(a : Array α)  (i : Fin a.size)  (j : Nat)  (v : α) : (a.set i v)[j]? = if i.1 = j then some v else a[j]?",
  "args": "(a : Array α)  (i : Fin a.size)  (j : Nat)  (v : α)"},
 {"type": "(a.set i v)[j]'(by simp [*]) = if i = j then v else a[j]",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Fin a.size)  (j : Nat)  (hj : j < a.size)  (v : α) : (a.set i v)[j]'(by simp [*]) = if i = j then v else a[j] := by if h : i.1 = j then subst j; simp [*] else simp [*]; sorry",
  "name": "get_set",
  "kind": "theorem",
  "first-tactic": "if h : i.1 = j then subst j; simp [*] else simp [*]",
  "core-prompt":
  "(a : Array α)  (i : Fin a.size)  (j : Nat)  (hj : j < a.size)  (v : α) : (a.set i v)[j]'(by simp [*]) = if i = j then v else a[j]",
  "args":
  "(a : Array α)  (i : Fin a.size)  (j : Nat)  (hj : j < a.size)  (v : α)"},
 {"type": "e ▸ i = ⟨i.1, e ▸ i.2⟩",
  "tactic-prompt":
  "theorem (e : n = n')  (i : Fin n) : e ▸ i = ⟨i.1, e ▸ i.2⟩ := by cases e; sorry",
  "name": "fin_cast_val",
  "kind": "theorem",
  "first-tactic": "cases e",
  "core-prompt": "(e : n = n')  (i : Fin n) : e ▸ i = ⟨i.1, e ▸ i.2⟩",
  "args": "(e : n = n')  (i : Fin n)"},
 {"type": "a.swap i j = (a.set i (a.get j)).set ⟨j.1, by simp [j.2]⟩ (a.get i)",
  "tactic-prompt":
  "theorem (a : Array α)  (i j : Fin a.size) : a.swap i j = (a.set i (a.get j)).set ⟨j.1, by simp [j.2]⟩ (a.get i) := by simp [swap]; sorry",
  "name": "swap_def",
  "kind": "theorem",
  "first-tactic": "simp [swap]",
  "core-prompt":
  "(a : Array α)  (i j : Fin a.size) : a.swap i j = (a.set i (a.get j)).set ⟨j.1, by simp [j.2]⟩ (a.get i)",
  "args": "(a : Array α)  (i j : Fin a.size)"},
 {"type": "(a.swap i j).data = (a.data.set i (a.get j)).set j (a.get i)",
  "tactic-prompt":
  "theorem (a : Array α)  (i j : Fin a.size) : (a.swap i j).data = (a.data.set i (a.get j)).set j (a.get i) := by simp [swap_def]; sorry",
  "name": "data_swap",
  "kind": "theorem",
  "first-tactic": "simp [swap_def]",
  "core-prompt":
  "(a : Array α)  (i j : Fin a.size) : (a.swap i j).data = (a.data.set i (a.get j)).set j (a.get i)",
  "args": "(a : Array α)  (i j : Fin a.size)"},
 {"type":
  "(a.swap i j)[k]? =\n    if j = k then some a[i.1] else if i = k then some a[j.1] else a[k]?",
  "tactic-prompt":
  "theorem (a : Array α)  (i j : Fin a.size)  (k : Nat) : (a.swap i j)[k]? =\n    if j = k then some a[i.1] else if i = k then some a[j.1] else a[k]? := by simp [swap_def]; sorry",
  "name": "get?_swap",
  "kind": "theorem",
  "first-tactic": "simp [swap_def]",
  "core-prompt":
  "(a : Array α)  (i j : Fin a.size)  (k : Nat) : (a.swap i j)[k]? =\n    if j = k then some a[i.1] else if i = k then some a[j.1] else a[k]?",
  "args": "(a : Array α)  (i j : Fin a.size)  (k : Nat)"},
 {"type": "a.swapAt! i v = (a[i], a.set ⟨i, h⟩ v)",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Nat)  (v : α)  (h : i < a.size) : a.swapAt! i v = (a[i], a.set ⟨i, h⟩ v) := by simp [swapAt!]; sorry",
  "name": "swapAt!_def",
  "kind": "theorem",
  "first-tactic": "simp [swapAt!]",
  "core-prompt":
  "(a : Array α)  (i : Nat)  (v : α)  (h : i < a.size) : a.swapAt! i v = (a[i], a.set ⟨i, h⟩ v)",
  "args": "(a : Array α)  (i : Nat)  (v : α)  (h : i < a.size)"},
 {"type": "a.pop.data = a.data.dropLast",
  "tactic-prompt":
  "theorem (a : Array α) : a.pop.data = a.data.dropLast := by simp [pop]; sorry",
  "name": "data_pop",
  "kind": "theorem",
  "first-tactic": "simp [pop]",
  "core-prompt": "(a : Array α) : a.pop.data = a.data.dropLast",
  "args": "(a : Array α)"},
 {"type": "(a.push x).pop = a",
  "tactic-prompt":
  "theorem (a : Array α) : (a.push x).pop = a := by simp [pop]; sorry",
  "name": "pop_push",
  "kind": "theorem",
  "first-tactic": "simp [pop]",
  "core-prompt": "(a : Array α) : (a.push x).pop = a",
  "args": "(a : Array α)"},
 {"type": "SatisfiesM (motive 0) (as.foldrM f init)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]      {as : Array α}  (motive : Nat → β → Prop)      {init : β}  (h0 : motive as.size init)  {f : α → β → m β}      (hf : ∀ i : Fin as.size, ∀ b, motive (i.1 + 1) b → SatisfiesM (motive i.1) (f as[i] b)) : SatisfiesM (motive 0) (as.foldrM f init) := by let rec go {i b} (hi : i ≤ as.size) (H : motive i b) :\n    SatisfiesM (motive 0) (foldrM.fold f as 0 i hi b) := by\n    unfold foldrM.fold; simp; split\n    · next hi => exact .pure (hi ▸ H)\n    · next hi =>\n      split; {simp at hi}\n      · next i hi' =>\n        exact (hf ⟨i, hi'⟩ b H).bind fun _ => go _; sorry",
  "name": "SatisfiesM_foldrM",
  "kind": "theorem",
  "first-tactic":
  "let rec go {i b} (hi : i ≤ as.size) (H : motive i b) :\n    SatisfiesM (motive 0) (foldrM.fold f as 0 i hi b) := by\n    unfold foldrM.fold; simp; split\n    · next hi => exact .pure (hi ▸ H)\n    · next hi =>\n      split; {simp at hi}\n      · next i hi' =>\n        exact (hf ⟨i, hi'⟩ b H).bind fun _ => go _",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]      {as : Array α}  (motive : Nat → β → Prop)      {init : β}  (h0 : motive as.size init)  {f : α → β → m β}      (hf : ∀ i : Fin as.size, ∀ b, motive (i.1 + 1) b → SatisfiesM (motive i.1) (f as[i] b)) : SatisfiesM (motive 0) (as.foldrM f init)",
  "args":
  "[Monad m]  [LawfulMonad m]      {as : Array α}  (motive : Nat → β → Prop)      {init : β}  (h0 : motive as.size init)  {f : α → β → m β}      (hf : ∀ i : Fin as.size, ∀ b, motive (i.1 + 1) b → SatisfiesM (motive i.1) (f as[i] b))"},
 {"type": "motive 0 (as.foldr f init)",
  "tactic-prompt":
  "theorem {as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive as.size init)  {f : α → β → β}      (hf : ∀ i : Fin as.size, ∀ b, motive (i.1 + 1) b → motive i.1 (f as[i] b)) : motive 0 (as.foldr f init) := by have := SatisfiesM_foldrM (m := Id) (as := as) (f := f) motive h0; sorry",
  "name": "foldr_induction",
  "kind": "theorem",
  "first-tactic":
  "have := SatisfiesM_foldrM (m := Id) (as := as) (f := f) motive h0",
  "core-prompt":
  "{as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive as.size init)  {f : α → β → β}      (hf : ∀ i : Fin as.size, ∀ b, motive (i.1 + 1) b → motive i.1 (f as[i] b)) : motive 0 (as.foldr f init)",
  "args":
  "{as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive as.size init)  {f : α → β → β}      (hf : ∀ i : Fin as.size, ∀ b, motive (i.1 + 1) b → motive i.1 (f as[i] b))"},
 {"type": "arr.mapM f = return mk (← arr.data.mapM f)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (f : α → m β)  (arr : Array α) : arr.mapM f = return mk (← arr.data.mapM f) := by rw [mapM]; sorry",
  "name": "mapM_eq_mapM_data",
  "kind": "theorem",
  "first-tactic": "rw [mapM]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (f : α → m β)  (arr : Array α) : arr.mapM f = return mk (← arr.data.mapM f)",
  "args": "[Monad m]  [LawfulMonad m]  (f : α → m β)  (arr : Array α)"},
 {"type":
  "SatisfiesM\n      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ (arr[i]'(eq ▸ h)))\n      (Array.mapIdxM as f)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (as : Array α)  (f : Fin as.size → α → m β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → SatisfiesM (p i · ∧ motive (i + 1)) (f i as[i])) : SatisfiesM\n      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ (arr[i]'(eq ▸ h)))\n      (Array.mapIdxM as f) := by let rec go {bs i j h} (h₁ : j = bs.size) (h₂ : ∀ i h h', p ⟨i, h⟩ bs[i]) (hm : motive j) :\n    SatisfiesM\n      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ (arr[i]'(eq ▸ h)))\n      (Array.mapIdxM.map as f i j h bs) := by\n    induction i generalizing j bs with simp [mapIdxM.map]\n    | zero =>\n      have := (Nat.zero_add _).symm.trans h\n      exact .pure ⟨this ▸ hm, h₁ ▸ this, fun _ _ => h₂ ..⟩\n    | succ i ih =>\n      refine (hs _ (by exact hm)).bind fun b hb => ih (by simp [h₁]) (fun i hi hi' => ?_) hb.2\n      simp at hi'; simp [get_push]; split\n      · next h => exact h₂ _ _ h\n      · next h => cases h₁.symm ▸ (Nat.le_or_eq_or_le_succ hi').resolve_left h; exact hb.1; sorry",
  "name": "SatisfiesM_mapIdxM",
  "kind": "theorem",
  "first-tactic":
  "let rec go {bs i j h} (h₁ : j = bs.size) (h₂ : ∀ i h h', p ⟨i, h⟩ bs[i]) (hm : motive j) :\n    SatisfiesM\n      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ (arr[i]'(eq ▸ h)))\n      (Array.mapIdxM.map as f i j h bs) := by\n    induction i generalizing j bs with simp [mapIdxM.map]\n    | zero =>\n      have := (Nat.zero_add _).symm.trans h\n      exact .pure ⟨this ▸ hm, h₁ ▸ this, fun _ _ => h₂ ..⟩\n    | succ i ih =>\n      refine (hs _ (by exact hm)).bind fun b hb => ih (by simp [h₁]) (fun i hi hi' => ?_) hb.2\n      simp at hi'; simp [get_push]; split\n      · next h => exact h₂ _ _ h\n      · next h => cases h₁.symm ▸ (Nat.le_or_eq_or_le_succ hi').resolve_left h; exact hb.1",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (as : Array α)  (f : Fin as.size → α → m β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → SatisfiesM (p i · ∧ motive (i + 1)) (f i as[i])) : SatisfiesM\n      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ (arr[i]'(eq ▸ h)))\n      (Array.mapIdxM as f)",
  "args":
  "[Monad m]  [LawfulMonad m]  (as : Array α)  (f : Fin as.size → α → m β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → SatisfiesM (p i · ∧ motive (i + 1)) (f i as[i]))"},
 {"type":
  "motive as.size ∧ ∃ eq : (Array.mapIdx as f).size = as.size,\n      ∀ i h, p ⟨i, h⟩ ((Array.mapIdx as f)[i]'(eq ▸ h))",
  "tactic-prompt":
  "theorem (as : Array α)  (f : Fin as.size → α → β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → p i (f i as[i]) ∧ motive (i + 1)) : motive as.size ∧ ∃ eq : (Array.mapIdx as f).size = as.size,\n      ∀ i h, p ⟨i, h⟩ ((Array.mapIdx as f)[i]'(eq ▸ h)) := by have := SatisfiesM_mapIdxM (m := Id) (as := as) (f := f) motive h0; sorry",
  "name": "mapIdx_induction",
  "kind": "theorem",
  "first-tactic":
  "have := SatisfiesM_mapIdxM (m := Id) (as := as) (f := f) motive h0",
  "core-prompt":
  "(as : Array α)  (f : Fin as.size → α → β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → p i (f i as[i]) ∧ motive (i + 1)) : motive as.size ∧ ∃ eq : (Array.mapIdx as f).size = as.size,\n      ∀ i h, p ⟨i, h⟩ ((Array.mapIdx as f)[i]'(eq ▸ h))",
  "args":
  "(as : Array α)  (f : Fin as.size → α → β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → p i (f i as[i]) ∧ motive (i + 1))"},
 {"type": "a.reverse.size = a.size",
  "tactic-prompt":
  "theorem (a : Array α) : a.reverse.size = a.size := by let rec go (as : Array α) (i j) : (reverse.loop as i j).size = as.size := by\n    rw [reverse.loop]\n    if h : i < j then\n      have := reverse.termination h\n      simp [(go · (i+1) ⟨j-1]; sorry",
  "name": "size_reverse",
  "kind": "theorem",
  "first-tactic":
  "let rec go (as : Array α) (i j) : (reverse.loop as i j).size = as.size := by\n    rw [reverse.loop]\n    if h : i < j then\n      have := reverse.termination h\n      simp [(go · (i+1) ⟨j-1]",
  "core-prompt": "(a : Array α) : a.reverse.size = a.size",
  "args": "(a : Array α)"},
 {"type": "a.reverse.data = a.data.reverse",
  "tactic-prompt":
  "theorem (a : Array α) : a.reverse.data = a.data.reverse := by let rec go (as : Array α) (i j hj)\n      (h : i + j + 1 = a.size) (h₂ : as.size = a.size)\n      (H : ∀ k, as.data.get? k = if i ≤ k ∧ k ≤ j then a.data.get? k else a.data.reverse.get? k)\n      (k) : (reverse.loop as i ⟨j, hj⟩).data.get? k = a.data.reverse.get? k := by\n    rw [reverse.loop]; dsimp; split; sorry",
  "name": "reverse_data",
  "kind": "theorem",
  "first-tactic":
  "let rec go (as : Array α) (i j hj)\n      (h : i + j + 1 = a.size) (h₂ : as.size = a.size)\n      (H : ∀ k, as.data.get? k = if i ≤ k ∧ k ≤ j then a.data.get? k else a.data.reverse.get? k)\n      (k) : (reverse.loop as i ⟨j, hj⟩).data.get? k = a.data.reverse.get? k := by\n    rw [reverse.loop]; dsimp; split",
  "core-prompt": "(a : Array α) : a.reverse.data = a.data.reverse",
  "args": "(a : Array α)"},
 {"type": "(ofFn f).size = n",
  "tactic-prompt":
  "theorem (f : Fin n → α) : (ofFn f).size = n := by simp [ofFn]; sorry",
  "name": "size_ofFn",
  "kind": "theorem",
  "first-tactic": "simp [ofFn]",
  "core-prompt": "(f : Fin n → α) : (ofFn f).size = n",
  "args": "(f : Fin n → α)"},
 {"type": "isEmpty l = l.toList.isEmpty",
  "tactic-prompt":
  "theorem (l : AssocList α β) : isEmpty l = l.toList.isEmpty := by cases l; sorry",
  "name": "isEmpty_eq",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "(l : AssocList α β) : isEmpty l = l.toList.isEmpty",
  "args": "(l : AssocList α β)"},
 {"type": "@toList = @toListTR",
  "tactic-prompt": "theorem  : @toList = @toListTR := by funext α β as; sorry",
  "name": "toList_eq_toListTR",
  "kind": "theorem",
  "first-tactic": "funext α β as",
  "core-prompt": " : @toList = @toListTR",
  "args": ""},
 {"type": "(mapKey f l).toList = l.toList.map (fun (a, b) => (f a, b))",
  "tactic-prompt":
  "theorem (f : α → δ)  (l : AssocList α β) : (mapKey f l).toList = l.toList.map (fun (a, b) => (f a, b)) := by induction l; sorry",
  "name": "mapKey_toList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : α → δ)  (l : AssocList α β) : (mapKey f l).toList = l.toList.map (fun (a, b) => (f a, b))",
  "args": "(f : α → δ)  (l : AssocList α β)"},
 {"type": "(mapVal f l).toList = l.toList.map (fun (a, b) => (a, f a b))",
  "tactic-prompt":
  "theorem (f : α → β → δ)  (l : AssocList α β) : (mapVal f l).toList = l.toList.map (fun (a, b) => (a, f a b)) := by induction l; sorry",
  "name": "mapVal_toList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : α → β → δ)  (l : AssocList α β) : (mapVal f l).toList = l.toList.map (fun (a, b) => (a, f a b))",
  "args": "(f : α → β → δ)  (l : AssocList α β)"},
 {"type": "findEntryP? p l = l.toList.find? fun (a, b) => p a b",
  "tactic-prompt":
  "theorem (p : α → β → Bool)  (l : AssocList α β) : findEntryP? p l = l.toList.find? fun (a, b) => p a b := by induction l; sorry",
  "name": "findEntryP?_eq",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(p : α → β → Bool)  (l : AssocList α β) : findEntryP? p l = l.toList.find? fun (a, b) => p a b",
  "args": "(p : α → β → Bool)  (l : AssocList α β)"},
 {"type": "find? a l = (l.findEntry? a).map (·.2)",
  "tactic-prompt":
  "theorem [BEq α]  (a : α)  (l : AssocList α β) : find? a l = (l.findEntry? a).map (·.2) := by induction l; sorry",
  "name": "find?_eq_findEntry?",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "[BEq α]  (a : α)  (l : AssocList α β) : find? a l = (l.findEntry? a).map (·.2)",
  "args": "[BEq α]  (a : α)  (l : AssocList α β)"},
 {"type": "find? a l = (l.toList.find? (·.1 == a)).map (·.2)",
  "tactic-prompt":
  "theorem [BEq α]  (a : α)  (l : AssocList α β) : find? a l = (l.toList.find? (·.1 == a)).map (·.2) := by simp [find?_eq_findEntry?]; sorry",
  "name": "find?_eq",
  "kind": "theorem",
  "first-tactic": "simp [find?_eq_findEntry?]",
  "core-prompt":
  "[BEq α]  (a : α)  (l : AssocList α β) : find? a l = (l.toList.find? (·.1 == a)).map (·.2)",
  "args": "[BEq α]  (a : α)  (l : AssocList α β)"},
 {"type": "any p l = l.toList.any fun (a, b) => p a b",
  "tactic-prompt":
  "theorem (p : α → β → Bool)  (l : AssocList α β) : any p l = l.toList.any fun (a, b) => p a b := by induction l; sorry",
  "name": "any_eq",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(p : α → β → Bool)  (l : AssocList α β) : any p l = l.toList.any fun (a, b) => p a b",
  "args": "(p : α → β → Bool)  (l : AssocList α β)"},
 {"type": "all p l = l.toList.all fun (a, b) => p a b",
  "tactic-prompt":
  "theorem (p : α → β → Bool)  (l : AssocList α β) : all p l = l.toList.all fun (a, b) => p a b := by induction l; sorry",
  "name": "all_eq",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(p : α → β → Bool)  (l : AssocList α β) : all p l = l.toList.all fun (a, b) => p a b",
  "args": "(p : α → β → Bool)  (l : AssocList α β)"},
 {"type": "contains a l = l.toList.any (·.1 == a)",
  "tactic-prompt":
  "theorem [BEq α]  (a : α)  (l : AssocList α β) : contains a l = l.toList.any (·.1 == a) := by induction l; sorry",
  "name": "contains_eq",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "[BEq α]  (a : α)  (l : AssocList α β) : contains a l = l.toList.any (·.1 == a)",
  "args": "[BEq α]  (a : α)  (l : AssocList α β)"},
 {"type":
  "(replace a b l).toList =\n    l.toList.replaceF (bif ·.1 == a then (a, b) else none)",
  "tactic-prompt":
  "theorem [BEq α]  (a : α)  (b : β)  (l : AssocList α β) : (replace a b l).toList =\n    l.toList.replaceF (bif ·.1 == a then (a, b) else none) := by induction l; sorry",
  "name": "replace_toList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "[BEq α]  (a : α)  (b : β)  (l : AssocList α β) : (replace a b l).toList =\n    l.toList.replaceF (bif ·.1 == a then (a, b) else none)",
  "args": "[BEq α]  (a : α)  (b : β)  (l : AssocList α β)"},
 {"type": "forIn l init f = forIn l.toList init f",
  "tactic-prompt":
  "theorem [Monad m]  (l : AssocList α β)  (init : δ)      (f : (α × β) → δ → m (ForInStep δ)) : forIn l init f = forIn l.toList init f := by simp [forIn]; sorry",
  "name": "forIn_eq",
  "kind": "theorem",
  "first-tactic": "simp [forIn]",
  "core-prompt":
  "[Monad m]  (l : AssocList α β)  (init : δ)      (f : (α × β) → δ → m (ForInStep δ)) : forIn l init f = forIn l.toList init f",
  "args":
  "[Monad m]  (l : AssocList α β)  (init : δ)      (f : (α × β) → δ → m (ForInStep δ))"},
 {"type": "l.toAssocList.toList = l",
  "tactic-prompt":
  "theorem (l : List (α × β)) : l.toAssocList.toList = l := by induction l; sorry",
  "name": "_root_.List.toAssocList_toList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List (α × β)) : l.toAssocList.toList = l",
  "args": "(l : List (α × β))"},
 {"type": "l.toList.toAssocList = l",
  "tactic-prompt":
  "theorem (l : AssocList α β) : l.toList.toAssocList = l := by induction l; sorry",
  "name": "toList_toAssocList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : AssocList α β) : l.toList.toAssocList = l",
  "args": "(l : AssocList α β)"},
 {"type": "fill' (zoom cut t path) = path.fill t",
  "tactic-prompt":
  "theorem (cut : α → Ordering)  (t : RBNode α)  (path : Path α) : fill' (zoom cut t path) = path.fill t := by induction t generalizing path with\n  | nil => rfl\n  | node _ _ _ _ iha ihb => unfold zoom; split; sorry",
  "name": "zoom_fill'",
  "kind": "theorem",
  "first-tactic":
  "induction t generalizing path with\n  | nil => rfl\n  | node _ _ _ _ iha ihb => unfold zoom; split",
  "core-prompt":
  "(cut : α → Ordering)  (t : RBNode α)  (path : Path α) : fill' (zoom cut t path) = path.fill t",
  "args": "(cut : α → Ordering)  (t : RBNode α)  (path : Path α)"},
 {"type":
  "t.zoom (cmp v) path = (t', path') →\n    path.ins (t.ins cmp v) = path'.ins (t'.setRoot v)",
  "tactic-prompt":
  "theorem {t : RBNode α}  {cmp : α → α → Ordering} : t.zoom (cmp v) path = (t', path') →\n    path.ins (t.ins cmp v) = path'.ins (t'.setRoot v) := by unfold RBNode.ins; sorry",
  "name": "zoom_ins",
  "kind": "theorem",
  "first-tactic": "unfold RBNode.ins",
  "core-prompt":
  "{t : RBNode α}  {cmp : α → α → Ordering} : t.zoom (cmp v) path = (t', path') →\n    path.ins (t.ins cmp v) = path'.ins (t'.setRoot v)",
  "args": "{t : RBNode α}  {cmp : α → α → Ordering}"},
 {"type":
  "t.zoom cut path = (t', path') →\n    path.del (t.del cut) (match t with | node c .. => c | _ => red) =\n    path'.del t'.delRoot (match t' with | node c .. => c | _ => red)",
  "tactic-prompt":
  "theorem {t : RBNode α} : t.zoom cut path = (t', path') →\n    path.del (t.del cut) (match t with | node c .. => c | _ => red) =\n    path'.del t'.delRoot (match t' with | node c .. => c | _ => red) := by unfold RBNode.del; sorry",
  "name": "zoom_del",
  "kind": "theorem",
  "first-tactic": "unfold RBNode.del",
  "core-prompt":
  "{t : RBNode α} : t.zoom cut path = (t', path') →\n    path.del (t.del cut) (match t with | node c .. => c | _ => red) =\n    path'.del t'.delRoot (match t' with | node c .. => c | _ => red)",
  "args": "{t : RBNode α}"},
 {"type": "∃ n, (path.ins t).Balanced black n",
  "tactic-prompt":
  "theorem (c₀ : RBColor)  (n₀ : Nat) {path : Path α}      (hp : path.Balanced c₀ n₀ c n)  (ht : t.RedRed (c = red) n) : ∃ n, (path.ins t).Balanced black n := by induction hp generalizing t with\n  | root => exact ht.setBlack\n  | redL hr hp ih => match ht with\n    | .balanced .nil => exact ih (.balanced (.red .nil hr))\n    | .balanced (.red ha hb) => exact ih (.redred rfl (.red ha hb) hr)\n    | .balanced (.black ha hb) => exact ih (.balanced (.red (.black ha hb) hr))\n  | redR hl hp ih => match ht with\n    | .balanced .nil => exact ih (.balanced (.red hl .nil))\n    | .balanced (.red ha hb) => exact ih (.redred rfl hl (.red ha hb))\n    | .balanced (.black ha hb) => exact ih (.balanced (.red hl (.black ha hb)))\n  | blackL hr hp ih => exact have ⟨c, h⟩ := ht.balance1 hr; ih (.balanced h)\n  | blackR hl hp ih => exact have ⟨c, h⟩ := ht.balance2 hl; ih (.balanced h); sorry",
  "name": "Balanced.ins",
  "kind": "theorem",
  "first-tactic":
  "induction hp generalizing t with\n  | root => exact ht.setBlack\n  | redL hr hp ih => match ht with\n    | .balanced .nil => exact ih (.balanced (.red .nil hr))\n    | .balanced (.red ha hb) => exact ih (.redred rfl (.red ha hb) hr)\n    | .balanced (.black ha hb) => exact ih (.balanced (.red (.black ha hb) hr))\n  | redR hl hp ih => match ht with\n    | .balanced .nil => exact ih (.balanced (.red hl .nil))\n    | .balanced (.red ha hb) => exact ih (.redred rfl hl (.red ha hb))\n    | .balanced (.black ha hb) => exact ih (.balanced (.red hl (.black ha hb)))\n  | blackL hr hp ih => exact have ⟨c, h⟩ := ht.balance1 hr; ih (.balanced h)\n  | blackR hl hp ih => exact have ⟨c, h⟩ := ht.balance2 hl; ih (.balanced h)",
  "core-prompt":
  "(c₀ : RBColor)  (n₀ : Nat) {path : Path α}      (hp : path.Balanced c₀ n₀ c n)  (ht : t.RedRed (c = red) n) : ∃ n, (path.ins t).Balanced black n",
  "args":
  "(c₀ : RBColor)  (n₀ : Nat) {path : Path α}      (hp : path.Balanced c₀ n₀ c n)  (ht : t.RedRed (c = red) n)"},
 {"type": "(path.insert t' v).setBlack = (t.insert cmp v).setBlack",
  "tactic-prompt":
  "theorem (c₀ : RBColor)  (n₀ : Nat) {path : Path α}  {t : RBNode α}  (ht : t.Balanced c n)      (H : zoom (cmp v) t = (t', path)) : (path.insert t' v).setBlack = (t.insert cmp v).setBlack := by have ⟨_, _, ht', hp'⟩ := ht.zoom .root H; sorry",
  "name": "zoom_insert",
  "kind": "theorem",
  "first-tactic": "have ⟨_, _, ht', hp'⟩ := ht.zoom .root H",
  "core-prompt":
  "(c₀ : RBColor)  (n₀ : Nat) {path : Path α}  {t : RBNode α}  (ht : t.Balanced c n)      (H : zoom (cmp v) t = (t', path)) : (path.insert t' v).setBlack = (t.insert cmp v).setBlack",
  "args":
  "(c₀ : RBColor)  (n₀ : Nat) {path : Path α}  {t : RBNode α}  (ht : t.Balanced c n)      (H : zoom (cmp v) t = (t', path))"},
 {"type": "∃ n, (path.del t c').Balanced black n",
  "tactic-prompt":
  "theorem (c₀ : RBColor)  (n₀ : Nat) {path : Path α}      (hp : path.Balanced c₀ n₀ c n)  (ht : t.DelProp c' n)  (hc : c = black → c' ≠ red) : ∃ n, (path.del t c').Balanced black n := by induction hp generalizing t c' with\n  | root => match c', ht with\n    | red, ⟨_, h⟩ | black, ⟨_, _, h⟩ => exact h.setBlack\n  | @redL _ n _ _ hb hp ih => match c', n, ht with\n    | red, _, _ => cases hc rfl rfl\n    | black, _, ⟨_, rfl, ha⟩ => exact ih ((hb.balLeft ha).of_false (fun.)) (fun.)\n  | @redR _ n _ _ ha hp ih => match c', n, ht with\n    | red, _, _ => cases hc rfl rfl\n    | black, _, ⟨_, rfl, hb⟩ => exact ih ((ha.balRight hb).of_false (fun.)) (fun.)\n  | @blackL _ _ n _ _ _ hb hp ih => match c', n, ht with\n    | red, _, ⟨_, ha⟩ => exact ih ⟨_, rfl, .redred ⟨⟩ ha hb⟩ (fun.)\n    | black, _, ⟨_, rfl, ha⟩ => exact ih ⟨_, rfl, (hb.balLeft ha).imp fun _ => ⟨⟩⟩ (fun.)\n  | @blackR _ _ n _ _ _ ha hp ih =>  match c', n, ht with\n    | red, _, ⟨_, hb⟩ => exact ih ⟨_, rfl, .redred ⟨⟩ ha hb⟩ (fun.)\n    | black, _, ⟨_, rfl, hb⟩ => exact ih ⟨_, rfl, (ha.balRight hb).imp fun _ => ⟨⟩⟩ (fun.); sorry",
  "name": "Balanced.del",
  "kind": "theorem",
  "first-tactic":
  "induction hp generalizing t c' with\n  | root => match c', ht with\n    | red, ⟨_, h⟩ | black, ⟨_, _, h⟩ => exact h.setBlack\n  | @redL _ n _ _ hb hp ih => match c', n, ht with\n    | red, _, _ => cases hc rfl rfl\n    | black, _, ⟨_, rfl, ha⟩ => exact ih ((hb.balLeft ha).of_false (fun.)) (fun.)\n  | @redR _ n _ _ ha hp ih => match c', n, ht with\n    | red, _, _ => cases hc rfl rfl\n    | black, _, ⟨_, rfl, hb⟩ => exact ih ((ha.balRight hb).of_false (fun.)) (fun.)\n  | @blackL _ _ n _ _ _ hb hp ih => match c', n, ht with\n    | red, _, ⟨_, ha⟩ => exact ih ⟨_, rfl, .redred ⟨⟩ ha hb⟩ (fun.)\n    | black, _, ⟨_, rfl, ha⟩ => exact ih ⟨_, rfl, (hb.balLeft ha).imp fun _ => ⟨⟩⟩ (fun.)\n  | @blackR _ _ n _ _ _ ha hp ih =>  match c', n, ht with\n    | red, _, ⟨_, hb⟩ => exact ih ⟨_, rfl, .redred ⟨⟩ ha hb⟩ (fun.)\n    | black, _, ⟨_, rfl, hb⟩ => exact ih ⟨_, rfl, (ha.balRight hb).imp fun _ => ⟨⟩⟩ (fun.)",
  "core-prompt":
  "(c₀ : RBColor)  (n₀ : Nat) {path : Path α}      (hp : path.Balanced c₀ n₀ c n)  (ht : t.DelProp c' n)  (hc : c = black → c' ≠ red) : ∃ n, (path.del t c').Balanced black n",
  "args":
  "(c₀ : RBColor)  (n₀ : Nat) {path : Path α}      (hp : path.Balanced c₀ n₀ c n)  (ht : t.DelProp c' n)  (hc : c = black → c' ≠ red)"},
 {"type": "(alter cut f t).Ordered cmp",
  "tactic-prompt":
  "theorem (c₀ : RBColor)  (n₀ : Nat) {t : RBNode α}      (H : ∀ {x t' p}, t.zoom cut = (t', p) → f t'.root? = some x →       p.RootOrdered cmp x ∧ t'.OnRoot (cmpEq cmp x))      (h : t.Ordered cmp) : (alter cut f t).Ordered cmp := by simp [alter]; sorry",
  "name": "Ordered.alter",
  "kind": "theorem",
  "first-tactic": "simp [alter]",
  "core-prompt":
  "(c₀ : RBColor)  (n₀ : Nat) {t : RBNode α}      (H : ∀ {x t' p}, t.zoom cut = (t', p) → f t'.root? = some x →       p.RootOrdered cmp x ∧ t'.OnRoot (cmpEq cmp x))      (h : t.Ordered cmp) : (alter cut f t).Ordered cmp",
  "args":
  "(c₀ : RBColor)  (n₀ : Nat) {t : RBNode α}      (H : ∀ {x t' p}, t.zoom cut = (t', p) → f t'.root? = some x →       p.RootOrdered cmp x ∧ t'.OnRoot (cmpEq cmp x))      (h : t.Ordered cmp)"},
 {"type": "∃ c n, (t.alter cut f).Balanced c n",
  "tactic-prompt":
  "theorem (c₀ : RBColor)  (n₀ : Nat) {t : RBNode α}      (h : t.Balanced c n) : ∃ c n, (t.alter cut f).Balanced c n := by simp [alter]; sorry",
  "name": "Balanced.alter",
  "kind": "theorem",
  "first-tactic": "simp [alter]",
  "core-prompt":
  "(c₀ : RBColor)  (n₀ : Nat) {t : RBNode α}      (h : t.Balanced c n) : ∃ c n, (t.alter cut f).Balanced c n",
  "args":
  "(c₀ : RBColor)  (n₀ : Nat) {t : RBNode α}      (h : t.Balanced c n)"},
 {"type": "t.modify cut f = t.alter cut (.map f)",
  "tactic-prompt":
  "theorem (c₀ : RBColor)  (n₀ : Nat) (t : RBNode α) : t.modify cut f = t.alter cut (.map f) := by simp [modify]; sorry",
  "name": "modify_eq_alter",
  "kind": "theorem",
  "first-tactic": "simp [modify]",
  "core-prompt":
  "(c₀ : RBColor)  (n₀ : Nat) (t : RBNode α) : t.modify cut f = t.alter cut (.map f)",
  "args": "(c₀ : RBColor)  (n₀ : Nat) (t : RBNode α)"},
 {"type": "ModifyWF t cut f",
  "tactic-prompt":
  "theorem (c₀ : RBColor)  (n₀ : Nat) {t : RBSet α cmp}      (H : ∀ {x}, RBNode.find? cut t.val = some x → cmpEq cmp (f x) x) : ModifyWF t cut f := by refine ⟨.modify ?_ t.2⟩; sorry",
  "name": "ModifyWF.of_eq",
  "kind": "theorem",
  "first-tactic": "refine ⟨.modify ?_ t.2⟩",
  "core-prompt":
  "(c₀ : RBColor)  (n₀ : Nat) {t : RBSet α cmp}      (H : ∀ {x}, RBNode.find? cut t.val = some x → cmpEq cmp (f x) x) : ModifyWF t cut f",
  "args":
  "(c₀ : RBColor)  (n₀ : Nat) {t : RBSet α cmp}      (H : ∀ {x}, RBNode.find? cut t.val = some x → cmpEq cmp (f x) x)"},
 {"type": "RBMap α β cmp",
  "tactic-prompt":
  "def (c₀ : RBColor)  (n₀ : Nat) (t : RBMap α β cmp)  (k : α)  (f : Option β → Option β) : RBMap α β cmp := by refine @RBSet.alterP _ _ t (cmp k ·.1) (alter.adapt k f) ⟨.alter (@fun _ t' p eq => ?_) t.2⟩; sorry",
  "name": "alter",
  "kind": "def",
  "first-tactic":
  "refine @RBSet.alterP _ _ t (cmp k ·.1) (alter.adapt k f) ⟨.alter (@fun _ t' p eq => ?_) t.2⟩",
  "core-prompt":
  "(c₀ : RBColor)  (n₀ : Nat) (t : RBMap α β cmp)  (k : α)  (f : Option β → Option β) : RBMap α β cmp",
  "args":
  "(c₀ : RBColor)  (n₀ : Nat) (t : RBMap α β cmp)  (k : α)  (f : Option β → Option β)"},
 {"type": "t.All (fun a => p a ∧ q a) ↔ t.All p ∧ t.All q",
  "tactic-prompt":
  "theorem {t : RBNode α} : t.All (fun a => p a ∧ q a) ↔ t.All p ∧ t.All q := by induction t; sorry",
  "name": "All_and",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "{t : RBNode α} : t.All (fun a => p a ∧ q a) ↔ t.All p ∧ t.All q",
  "args": "{t : RBNode α}"},
 {"type": "(balance1 l v r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLT cmp · v))  (vr : r.All (cmpLT cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balance1 l v r).Ordered cmp := by unfold balance1; sorry",
  "name": "Ordered.balance1",
  "kind": "theorem",
  "first-tactic": "unfold balance1",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLT cmp · v))  (vr : r.All (cmpLT cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balance1 l v r).Ordered cmp",
  "args":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLT cmp · v))  (vr : r.All (cmpLT cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(balance1 l v r).All p ↔ p v ∧ l.All p ∧ r.All p",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α} : (balance1 l v r).All p ↔ p v ∧ l.All p ∧ r.All p := by unfold balance1; sorry",
  "name": "balance1_All",
  "kind": "theorem",
  "first-tactic": "unfold balance1",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α} : (balance1 l v r).All p ↔ p v ∧ l.All p ∧ r.All p",
  "args": "{l : RBNode α}  {v : α}  {r : RBNode α}"},
 {"type": "(balance2 l v r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLT cmp · v))  (vr : r.All (cmpLT cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balance2 l v r).Ordered cmp := by unfold balance2; sorry",
  "name": "Ordered.balance2",
  "kind": "theorem",
  "first-tactic": "unfold balance2",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLT cmp · v))  (vr : r.All (cmpLT cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balance2 l v r).Ordered cmp",
  "args":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLT cmp · v))  (vr : r.All (cmpLT cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(balance2 l v r).All p ↔ p v ∧ l.All p ∧ r.All p",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α} : (balance2 l v r).All p ↔ p v ∧ l.All p ∧ r.All p := by unfold balance2; sorry",
  "name": "balance2_All",
  "kind": "theorem",
  "first-tactic": "unfold balance2",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α} : (balance2 l v r).All p ↔ p v ∧ l.All p ∧ r.All p",
  "args": "{l : RBNode α}  {v : α}  {r : RBNode α}"},
 {"type": "(setBlack t).Ordered cmp ↔ t.Ordered cmp",
  "tactic-prompt":
  "theorem {t : RBNode α} : (setBlack t).Ordered cmp ↔ t.Ordered cmp := by unfold setBlack; sorry",
  "name": "Ordered.setBlack",
  "kind": "theorem",
  "first-tactic": "unfold setBlack",
  "core-prompt": "{t : RBNode α} : (setBlack t).Ordered cmp ↔ t.Ordered cmp",
  "args": "{t : RBNode α}"},
 {"type": "t.setBlack.setBlack = t.setBlack",
  "tactic-prompt":
  "theorem {t : RBNode α} : t.setBlack.setBlack = t.setBlack := by cases t; sorry",
  "name": "setBlack_idem",
  "kind": "theorem",
  "first-tactic": "cases t",
  "core-prompt": "{t : RBNode α} : t.setBlack.setBlack = t.setBlack",
  "args": "{t : RBNode α}"},
 {"type": "(t.insert cmp v).setBlack = (t.ins cmp v).setBlack",
  "tactic-prompt":
  "theorem {t : RBNode α} : (t.insert cmp v).setBlack = (t.ins cmp v).setBlack := by unfold insert; sorry",
  "name": "insert_setBlack",
  "kind": "theorem",
  "first-tactic": "unfold insert",
  "core-prompt":
  "{t : RBNode α} : (t.insert cmp v).setBlack = (t.ins cmp v).setBlack",
  "args": "{t : RBNode α}"},
 {"type": "(ins cmp x t).All p",
  "tactic-prompt":
  "theorem {x : α}  {t : RBNode α}    (h₁ : p x)  (h₂ : t.All p) : (ins cmp x t).All p := by induction t; sorry",
  "name": "All.ins",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "{x : α}  {t : RBNode α}    (h₁ : p x)  (h₂ : t.All p) : (ins cmp x t).All p",
  "args": "{x : α}  {t : RBNode α}    (h₁ : p x)  (h₂ : t.All p)"},
 {"type": "(insert cmp t v).Ordered cmp",
  "tactic-prompt":
  "theorem (h : t.Ordered cmp) : (insert cmp t v).Ordered cmp := by unfold RBNode.insert; sorry",
  "name": "Ordered.insert",
  "kind": "theorem",
  "first-tactic": "unfold RBNode.insert",
  "core-prompt": "(h : t.Ordered cmp) : (insert cmp t v).Ordered cmp",
  "args": "(h : t.Ordered cmp)"},
 {"type": "∃ c, (balance1 l v r).Balanced c (n + 1)",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.RedRed p n)  (hr : r.Balanced c n) : ∃ c, (balance1 l v r).Balanced c (n + 1) := by unfold balance1; sorry",
  "name": "RedRed.balance1",
  "kind": "theorem",
  "first-tactic": "unfold balance1",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.RedRed p n)  (hr : r.Balanced c n) : ∃ c, (balance1 l v r).Balanced c (n + 1)",
  "args":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.RedRed p n)  (hr : r.Balanced c n)"},
 {"type": "∃ c, (balance2 l v r).Balanced c (n + 1)",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.Balanced c n)  (hr : r.RedRed p n) : ∃ c, (balance2 l v r).Balanced c (n + 1) := by unfold balance2; sorry",
  "name": "RedRed.balance2",
  "kind": "theorem",
  "first-tactic": "unfold balance2",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.Balanced c n)  (hr : r.RedRed p n) : ∃ c, (balance2 l v r).Balanced c (n + 1)",
  "args":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.Balanced c n)  (hr : r.RedRed p n)"},
 {"type": "balance1 l v r = node black l v r",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.Balanced c n) : balance1 l v r = node black l v r := by unfold balance1; sorry",
  "name": "balance1_eq",
  "kind": "theorem",
  "first-tactic": "unfold balance1",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.Balanced c n) : balance1 l v r = node black l v r",
  "args": "{l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.Balanced c n)"},
 {"type": "balance2 l v r = node black l v r",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (hr : r.Balanced c n) : balance2 l v r = node black l v r := by unfold balance2; sorry",
  "name": "balance2_eq",
  "kind": "theorem",
  "first-tactic": "unfold balance2",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (hr : r.Balanced c n) : balance2 l v r = node black l v r",
  "args": "{l : RBNode α}  {v : α}  {r : RBNode α}      (hr : r.Balanced c n)"},
 {"type": "∃ c' n', (insert cmp t v).Balanced c' n'",
  "tactic-prompt":
  "theorem {t : RBNode α}  (h : t.Balanced c n) : ∃ c' n', (insert cmp t v).Balanced c' n' := by unfold insert; sorry",
  "name": "Balanced.insert",
  "kind": "theorem",
  "first-tactic": "unfold insert",
  "core-prompt":
  "{t : RBNode α}  (h : t.Balanced c n) : ∃ c' n', (insert cmp t v).Balanced c' n'",
  "args": "{t : RBNode α}  (h : t.Balanced c n)"},
 {"type": "(setRed t).All p",
  "tactic-prompt":
  "theorem {t : RBNode α}  (h : t.All p) : (setRed t).All p := by unfold setRed; sorry",
  "name": "All.setRed",
  "kind": "theorem",
  "first-tactic": "unfold setRed",
  "core-prompt": "{t : RBNode α}  (h : t.All p) : (setRed t).All p",
  "args": "{t : RBNode α}  (h : t.All p)"},
 {"type": "(setRed t).Ordered cmp ↔ t.Ordered cmp",
  "tactic-prompt":
  "theorem {t : RBNode α} : (setRed t).Ordered cmp ↔ t.Ordered cmp := by unfold setRed; sorry",
  "name": "Ordered.setRed",
  "kind": "theorem",
  "first-tactic": "unfold setRed",
  "core-prompt": "{t : RBNode α} : (setRed t).Ordered cmp ↔ t.Ordered cmp",
  "args": "{t : RBNode α}"},
 {"type": "(balLeft l v r).All p",
  "tactic-prompt":
  "theorem (hl : l.All p)  (hv : p v)  (hr : r.All p) : (balLeft l v r).All p := by unfold balLeft; sorry",
  "name": "All.balLeft",
  "kind": "theorem",
  "first-tactic": "unfold balLeft",
  "core-prompt":
  "(hl : l.All p)  (hv : p v)  (hr : r.All p) : (balLeft l v r).All p",
  "args": "(hl : l.All p)  (hv : p v)  (hr : r.All p)"},
 {"type": "(balLeft l v r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLT cmp · v))  (vr : r.All (cmpLT cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balLeft l v r).Ordered cmp := by unfold balLeft; sorry",
  "name": "Ordered.balLeft",
  "kind": "theorem",
  "first-tactic": "unfold balLeft",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLT cmp · v))  (vr : r.All (cmpLT cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balLeft l v r).Ordered cmp",
  "args":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLT cmp · v))  (vr : r.All (cmpLT cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(balLeft l v r).RedRed (cr = red) (n + 1)",
  "tactic-prompt":
  "theorem (hl : l.RedRed True n)  (hr : r.Balanced cr (n + 1)) : (balLeft l v r).RedRed (cr = red) (n + 1) := by unfold balLeft; sorry",
  "name": "Balanced.balLeft",
  "kind": "theorem",
  "first-tactic": "unfold balLeft",
  "core-prompt":
  "(hl : l.RedRed True n)  (hr : r.Balanced cr (n + 1)) : (balLeft l v r).RedRed (cr = red) (n + 1)",
  "args": "(hl : l.RedRed True n)  (hr : r.Balanced cr (n + 1))"},
 {"type": "(balRight l v r).All p",
  "tactic-prompt":
  "theorem (hl : l.All p)  (hv : p v)  (hr : r.All p) : (balRight l v r).All p := by unfold balRight; sorry",
  "name": "All.balRight",
  "kind": "theorem",
  "first-tactic": "unfold balRight",
  "core-prompt":
  "(hl : l.All p)  (hv : p v)  (hr : r.All p) : (balRight l v r).All p",
  "args": "(hl : l.All p)  (hv : p v)  (hr : r.All p)"},
 {"type": "(balRight l v r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLT cmp · v))  (vr : r.All (cmpLT cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balRight l v r).Ordered cmp := by unfold balRight; sorry",
  "name": "Ordered.balRight",
  "kind": "theorem",
  "first-tactic": "unfold balRight",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLT cmp · v))  (vr : r.All (cmpLT cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balRight l v r).Ordered cmp",
  "args":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLT cmp · v))  (vr : r.All (cmpLT cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(balRight l v r).RedRed (cl = red) (n + 1)",
  "tactic-prompt":
  "theorem (hl : l.Balanced cl (n + 1))  (hr : r.RedRed True n) : (balRight l v r).RedRed (cl = red) (n + 1) := by unfold balRight; sorry",
  "name": "Balanced.balRight",
  "kind": "theorem",
  "first-tactic": "unfold balRight",
  "core-prompt":
  "(hl : l.Balanced cl (n + 1))  (hr : r.RedRed True n) : (balRight l v r).RedRed (cl = red) (n + 1)",
  "args": "(hl : l.Balanced cl (n + 1))  (hr : r.RedRed True n)"},
 {"type": "(append l r).All p",
  "tactic-prompt":
  "theorem (hl : l.All p)  (hr : r.All p) : (append l r).All p := by unfold append; sorry",
  "name": "All.append",
  "kind": "theorem",
  "first-tactic": "unfold append",
  "core-prompt": "(hl : l.All p)  (hr : r.All p) : (append l r).All p",
  "args": "(hl : l.All p)  (hr : r.All p)"},
 {"type": "(append l r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLT cmp · v))  (vr : r.All (cmpLT cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (append l r).Ordered cmp := by unfold append; sorry",
  "name": "Ordered.append",
  "kind": "theorem",
  "first-tactic": "unfold append",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLT cmp · v))  (vr : r.All (cmpLT cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (append l r).Ordered cmp",
  "args":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLT cmp · v))  (vr : r.All (cmpLT cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(l.append r).RedRed (c₁ = black → c₂ ≠ black) n",
  "tactic-prompt":
  "theorem {l r : RBNode α}      (hl : l.Balanced c₁ n)  (hr : r.Balanced c₂ n) : (l.append r).RedRed (c₁ = black → c₂ ≠ black) n := by unfold append; sorry",
  "name": "Balanced.append",
  "kind": "theorem",
  "first-tactic": "unfold append",
  "core-prompt":
  "{l r : RBNode α}      (hl : l.Balanced c₁ n)  (hr : r.Balanced c₂ n) : (l.append r).RedRed (c₁ = black → c₂ ≠ black) n",
  "args":
  "{l r : RBNode α}      (hl : l.Balanced c₁ n)  (hr : r.Balanced c₂ n)"},
 {"type": "∃ n', RedRed (c = black) t n'",
  "tactic-prompt":
  "theorem (h : DelProp c t n) : ∃ n', RedRed (c = black) t n' := by unfold DelProp at h; sorry",
  "name": "DelProp.redred",
  "kind": "theorem",
  "first-tactic": "unfold DelProp at h",
  "core-prompt": "(h : DelProp c t n) : ∃ n', RedRed (c = black) t n'",
  "args": "(h : DelProp c t n)"},
 {"type": "(t.del cut).DelProp t.isBlack n",
  "tactic-prompt":
  "theorem {t : RBNode α}  (h : t.Balanced c n) : (t.del cut).DelProp t.isBlack n := by induction h; sorry",
  "name": "Balanced.del",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{t : RBNode α}  (h : t.Balanced c n) : (t.del cut).DelProp t.isBlack n",
  "args": "{t : RBNode α}  (h : t.Balanced c n)"},
 {"type": "t.Ordered cmp ∧ ∃ c n, t.Balanced c n",
  "tactic-prompt":
  "theorem {t : RBNode α}  (h : t.WF cmp) : t.Ordered cmp ∧ ∃ c n, t.Balanced c n := by induction h; sorry",
  "name": "WF.out",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{t : RBNode α}  (h : t.WF cmp) : t.Ordered cmp ∧ ∃ c n, t.Balanced c n",
  "args": "{t : RBNode α}  (h : t.WF cmp)"},
 {"type": "t.All p ↔ ∀ x ∈ t, p x",
  "tactic-prompt":
  "theorem {t : RBNode α} : t.All p ↔ ∀ x ∈ t, p x := by induction t; sorry",
  "name": "All_def",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt": "{t : RBNode α} : t.All p ↔ ∀ x ∈ t, p x",
  "args": "{t : RBNode α}"},
 {"type": "t.Any p ↔ ∃ x ∈ t, p x",
  "tactic-prompt":
  "theorem {t : RBNode α} : t.Any p ↔ ∃ x ∈ t, p x := by induction t; sorry",
  "name": "Any_def",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt": "{t : RBNode α} : t.Any p ↔ ∃ x ∈ t, p x",
  "args": "{t : RBNode α}"},
 {"type": "cut x = cut y",
  "tactic-prompt":
  "theorem [IsCut cmp cut]  [TransCmp cmp]  (H : cmp x y = .eq) : cut x = cut y := by cases ey : cut y; sorry",
  "name": "IsCut.congr",
  "kind": "theorem",
  "first-tactic": "cases ey : cut y",
  "core-prompt":
  "[IsCut cmp cut]  [TransCmp cmp]  (H : cmp x y = .eq) : cut x = cut y",
  "args": "[IsCut cmp cut]  [TransCmp cmp]  (H : cmp x y = .eq)"},
 {"type": "x ∈ t.find? cut → cut x = .eq",
  "tactic-prompt":
  "theorem {t : RBNode α} : x ∈ t.find? cut → cut x = .eq := by induction t; sorry",
  "name": "find?_some_eq_eq",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt": "{t : RBNode α} : x ∈ t.find? cut → cut x = .eq",
  "args": "{t : RBNode α}"},
 {"type": "x ∈ t.find? cut → x ∈ t",
  "tactic-prompt":
  "theorem {t : RBNode α} : x ∈ t.find? cut → x ∈ t := by induction t; sorry",
  "name": "find?_some_mem",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt": "{t : RBNode α} : x ∈ t.find? cut → x ∈ t",
  "args": "{t : RBNode α}"},
 {"type": "MemP cut t ↔ ∃ x, x ∈ t.find? cut",
  "tactic-prompt":
  "theorem [@TransCmp α cmp]  [IsCut cmp cut]  (ht : Ordered cmp t) : MemP cut t ↔ ∃ x, x ∈ t.find? cut := by refine ⟨fun H => ?_, fun ⟨x, h⟩ => find?_some_memP h⟩; sorry",
  "name": "Ordered.memP_iff_find?",
  "kind": "theorem",
  "first-tactic": "refine ⟨fun H => ?_, fun ⟨x, h⟩ => find?_some_memP h⟩",
  "core-prompt":
  "[@TransCmp α cmp]  [IsCut cmp cut]  (ht : Ordered cmp t) : MemP cut t ↔ ∃ x, x ∈ t.find? cut",
  "args": "[@TransCmp α cmp]  [IsCut cmp cut]  (ht : Ordered cmp t)"},
 {"type": "x = y",
  "tactic-prompt":
  "theorem [@TransCmp α cmp]  (ht : Ordered cmp t)      (hx : x ∈ t)  (hy : y ∈ t)  (e : cmp x y = .eq) : x = y := by induction t; sorry",
  "name": "Ordered.unique",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "[@TransCmp α cmp]  (ht : Ordered cmp t)      (hx : x ∈ t)  (hy : y ∈ t)  (e : cmp x y = .eq) : x = y",
  "args":
  "[@TransCmp α cmp]  (ht : Ordered cmp t)      (hx : x ∈ t)  (hy : y ∈ t)  (e : cmp x y = .eq)"},
 {"type": "x ∈ t.find? cut ↔ x ∈ t ∧ cut x = .eq",
  "tactic-prompt":
  "theorem [@TransCmp α cmp]  [IsStrictCut cmp cut]  (ht : Ordered cmp t) : x ∈ t.find? cut ↔ x ∈ t ∧ cut x = .eq := by refine ⟨fun h => ⟨find?_some_mem h, find?_some_eq_eq h⟩, fun ⟨hx, e⟩ => ?_⟩; sorry",
  "name": "Ordered.mem_find?",
  "kind": "theorem",
  "first-tactic":
  "refine ⟨fun h => ⟨find?_some_mem h, find?_some_eq_eq h⟩, fun ⟨hx, e⟩ => ?_⟩",
  "core-prompt":
  "[@TransCmp α cmp]  [IsStrictCut cmp cut]  (ht : Ordered cmp t) : x ∈ t.find? cut ↔ x ∈ t ∧ cut x = .eq",
  "args": "[@TransCmp α cmp]  [IsStrictCut cmp cut]  (ht : Ordered cmp t)"},
 {"type": "x ∈ t.lowerBound? cut lb → cut x ≠ .lt",
  "tactic-prompt":
  "theorem {t : RBNode α}  (H : ∀ {x}, x ∈ lb → cut x ≠ .lt) : x ∈ t.lowerBound? cut lb → cut x ≠ .lt := by induction t generalizing lb with\n  | nil => exact H\n  | node _ _ _ _ ihl ihr =>\n    simp [lowerBound?]; split\n    · exact ihl H\n    · next hv => exact ihr fun | rfl]; sorry",
  "name": "lowerBound?_le'",
  "kind": "theorem",
  "first-tactic":
  "induction t generalizing lb with\n  | nil => exact H\n  | node _ _ _ _ ihl ihr =>\n    simp [lowerBound?]; split\n    · exact ihl H\n    · next hv => exact ihr fun | rfl]",
  "core-prompt":
  "{t : RBNode α}  (H : ∀ {x}, x ∈ lb → cut x ≠ .lt) : x ∈ t.lowerBound? cut lb → cut x ≠ .lt",
  "args": "{t : RBNode α}  (H : ∀ {x}, x ∈ lb → cut x ≠ .lt)"},
 {"type": "x ∈ t.lowerBound? cut lb → p x",
  "tactic-prompt":
  "theorem {t : RBNode α}  (hp : t.All p)  (H : ∀ {x}, x ∈ lb → p x) : x ∈ t.lowerBound? cut lb → p x := by induction t generalizing lb with\n  | nil => exact H\n  | node _ _ _ _ ihl ihr =>\n    simp [lowerBound?]; split\n    · exact ihl hp.2.1 H\n    · exact ihr hp.2.2 fun | rfl => hp.1\n    · exact fun | rfl => hp.1; sorry",
  "name": "All.lowerBound?_lb",
  "kind": "theorem",
  "first-tactic":
  "induction t generalizing lb with\n  | nil => exact H\n  | node _ _ _ _ ihl ihr =>\n    simp [lowerBound?]; split\n    · exact ihl hp.2.1 H\n    · exact ihr hp.2.2 fun | rfl => hp.1\n    · exact fun | rfl => hp.1",
  "core-prompt":
  "{t : RBNode α}  (hp : t.All p)  (H : ∀ {x}, x ∈ lb → p x) : x ∈ t.lowerBound? cut lb → p x",
  "args": "{t : RBNode α}  (hp : t.All p)  (H : ∀ {x}, x ∈ lb → p x)"},
 {"type": "∃ x, x ∈ t.lowerBound? cut (some y)",
  "tactic-prompt":
  "theorem {t : RBNode α} : ∃ x, x ∈ t.lowerBound? cut (some y) := by simp; sorry",
  "name": "lowerBound?_of_some",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "{t : RBNode α} : ∃ x, x ∈ t.lowerBound? cut (some y)",
  "args": "{t : RBNode α}"},
 {"type": "(∃ x, x ∈ t.lowerBound? cut none) ↔ ∃ x ∈ t, cut x ≠ .lt",
  "tactic-prompt":
  "theorem [@TransCmp α cmp]  [IsCut cmp cut]  (h : Ordered cmp t) : (∃ x, x ∈ t.lowerBound? cut none) ↔ ∃ x ∈ t, cut x ≠ .lt := by refine ⟨fun ⟨x, hx⟩ => ⟨_, lowerBound?_mem hx, lowerBound?_le hx⟩, fun H => ?_⟩; sorry",
  "name": "Ordered.lowerBound?_exists",
  "kind": "theorem",
  "first-tactic":
  "refine ⟨fun ⟨x, hx⟩ => ⟨_, lowerBound?_mem hx, lowerBound?_le hx⟩, fun H => ?_⟩",
  "core-prompt":
  "[@TransCmp α cmp]  [IsCut cmp cut]  (h : Ordered cmp t) : (∃ x, x ∈ t.lowerBound? cut none) ↔ ∃ x ∈ t, cut x ≠ .lt",
  "args": "[@TransCmp α cmp]  [IsCut cmp cut]  (h : Ordered cmp t)"},
 {"type":
  "x ∈ t.lowerBound? cut lb → y ∈ t → cut x = .gt → cmp x y = .lt → cut y = .lt",
  "tactic-prompt":
  "theorem [@TransCmp α cmp]  [IsCut cmp cut]  (h : Ordered cmp t)      (hlb : ∀ {x}, x ∈ lb → t.All (cmpLT cmp x ·)) : x ∈ t.lowerBound? cut lb → y ∈ t → cut x = .gt → cmp x y = .lt → cut y = .lt := by induction t generalizing lb with\n  | nil => intro.\n  | node _ _ _ _ ihl ihr =>\n    simp [lowerBound?]; split; sorry",
  "name": "Ordered.lowerBound?_least_lb",
  "kind": "theorem",
  "first-tactic":
  "induction t generalizing lb with\n  | nil => intro.\n  | node _ _ _ _ ihl ihr =>\n    simp [lowerBound?]; split",
  "core-prompt":
  "[@TransCmp α cmp]  [IsCut cmp cut]  (h : Ordered cmp t)      (hlb : ∀ {x}, x ∈ lb → t.All (cmpLT cmp x ·)) : x ∈ t.lowerBound? cut lb → y ∈ t → cut x = .gt → cmp x y = .lt → cut y = .lt",
  "args":
  "[@TransCmp α cmp]  [IsCut cmp cut]  (h : Ordered cmp t)      (hlb : ∀ {x}, x ∈ lb → t.All (cmpLT cmp x ·))"},
 {"type": "t.MemP cut ↔ ∃ x ∈ t.lowerBound? cut none, cut x = .eq",
  "tactic-prompt":
  "theorem [@TransCmp α cmp]  [IsCut cmp cut]  (ht : Ordered cmp t) : t.MemP cut ↔ ∃ x ∈ t.lowerBound? cut none, cut x = .eq := by refine memP_def.trans ⟨fun ⟨y, hy, ey⟩ => ?_, fun ⟨x, hx, e⟩ => ⟨_, lowerBound?_mem hx, e⟩⟩; sorry",
  "name": "Ordered.memP_iff_lowerBound?",
  "kind": "theorem",
  "first-tactic":
  "refine memP_def.trans ⟨fun ⟨y, hy, ey⟩ => ?_, fun ⟨x, hx, e⟩ => ⟨_, lowerBound?_mem hx, e⟩⟩",
  "core-prompt":
  "[@TransCmp α cmp]  [IsCut cmp cut]  (ht : Ordered cmp t) : t.MemP cut ↔ ∃ x ∈ t.lowerBound? cut none, cut x = .eq",
  "args": "[@TransCmp α cmp]  [IsCut cmp cut]  (ht : Ordered cmp t)"},
 {"type": "cmp x y = .lt ↔ cut y = .lt",
  "tactic-prompt":
  "theorem [@TransCmp α cmp]  [IsStrictCut cmp cut]  (ht : Ordered cmp t)      (H : x ∈ t.lowerBound? cut none)  (hy : y ∈ t) : cmp x y = .lt ↔ cut y = .lt := by refine ⟨fun h => ?_, fun h => OrientedCmp.cmp_eq_gt.1 ?_⟩; sorry",
  "name": "Ordered.lowerBound?_lt",
  "kind": "theorem",
  "first-tactic": "refine ⟨fun h => ?_, fun h => OrientedCmp.cmp_eq_gt.1 ?_⟩",
  "core-prompt":
  "[@TransCmp α cmp]  [IsStrictCut cmp cut]  (ht : Ordered cmp t)      (H : x ∈ t.lowerBound? cut none)  (hy : y ∈ t) : cmp x y = .lt ↔ cut y = .lt",
  "args":
  "[@TransCmp α cmp]  [IsStrictCut cmp cut]  (ht : Ordered cmp t)      (H : x ∈ t.lowerBound? cut none)  (hy : y ∈ t)"},
 {"type": "(.node c a x b : RBNode α).toList = a.toList ++ x :: b.toList",
  "tactic-prompt":
  "theorem  : (.node c a x b : RBNode α).toList = a.toList ++ x :: b.toList := by rw [toList]; sorry",
  "name": "toList_node",
  "kind": "theorem",
  "first-tactic": "rw [toList]",
  "core-prompt":
  " : (.node c a x b : RBNode α).toList = a.toList ++ x :: b.toList",
  "args": ""},
 {"type": "x ∈ t.toList ↔ x ∈ t",
  "tactic-prompt":
  "theorem {t : RBNode α} : x ∈ t.toList ↔ x ∈ t := by induction t; sorry",
  "name": "mem_toList",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt": "{t : RBNode α} : x ∈ t.toList ↔ x ∈ t",
  "args": "{t : RBNode α}"},
 {"type": "t.foldr f init = t.toList.foldr f init",
  "tactic-prompt":
  "theorem {t : RBNode α} : t.foldr f init = t.toList.foldr f init := by induction t generalizing init; sorry",
  "name": "foldr_eq_foldr_toList",
  "kind": "theorem",
  "first-tactic": "induction t generalizing init",
  "core-prompt": "{t : RBNode α} : t.foldr f init = t.toList.foldr f init",
  "args": "{t : RBNode α}"},
 {"type": "t.foldl f init = t.toList.foldl f init",
  "tactic-prompt":
  "theorem {t : RBNode α} : t.foldl f init = t.toList.foldl f init := by induction t generalizing init; sorry",
  "name": "foldl_eq_foldl_toList",
  "kind": "theorem",
  "first-tactic": "induction t generalizing init",
  "core-prompt": "{t : RBNode α} : t.foldl f init = t.toList.foldl f init",
  "args": "{t : RBNode α}"},
 {"type": "t.forM (m := m) f = t.toList.forM f",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  {t : RBNode α} : t.forM (m := m) f = t.toList.forM f := by induction t; sorry",
  "name": "forM_eq_forM_toList",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  {t : RBNode α} : t.forM (m := m) f = t.toList.forM f",
  "args": "[Monad m]  [LawfulMonad m]  {t : RBNode α}"},
 {"type": "t.foldlM (m := m) f init = t.toList.foldlM f init",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  {t : RBNode α} : t.foldlM (m := m) f init = t.toList.foldlM f init := by induction t generalizing init; sorry",
  "name": "foldlM_eq_foldlM_toList",
  "kind": "theorem",
  "first-tactic": "induction t generalizing init",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  {t : RBNode α} : t.foldlM (m := m) f init = t.toList.foldlM f init",
  "args": "[Monad m]  [LawfulMonad m]  {t : RBNode α}"},
 {"type":
  "forIn.visit (m := m) f t init = (ForInStep.yield init).bindList f t.toList",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  {t : RBNode α} : forIn.visit (m := m) f t init = (ForInStep.yield init).bindList f t.toList := by induction t generalizing init; sorry",
  "name": "forIn_visit_eq_bindList",
  "kind": "theorem",
  "first-tactic": "induction t generalizing init",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  {t : RBNode α} : forIn.visit (m := m) f t init = (ForInStep.yield init).bindList f t.toList",
  "args": "[Monad m]  [LawfulMonad m]  {t : RBNode α}"},
 {"type": "forIn (m := m) t init f = forIn t.toList init f",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  {t : RBNode α} : forIn (m := m) t init f = forIn t.toList init f := by simp [forIn]; sorry",
  "name": "forIn_eq_forIn_toList",
  "kind": "theorem",
  "first-tactic": "simp [forIn]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  {t : RBNode α} : forIn (m := m) t init f = forIn t.toList init f",
  "args": "[Monad m]  [LawfulMonad m]  {t : RBNode α}"},
 {"type": "(.cons x r s : RBNode.Stream α).toList = x :: r.toList ++ s.toList",
  "tactic-prompt":
  "theorem  : (.cons x r s : RBNode.Stream α).toList = x :: r.toList ++ s.toList := by rw [toList]; sorry",
  "name": "toList_cons",
  "kind": "theorem",
  "first-tactic": "rw [toList]",
  "core-prompt":
  " : (.cons x r s : RBNode.Stream α).toList = x :: r.toList ++ s.toList",
  "args": ""},
 {"type": "s.foldr f init = s.toList.foldr f init",
  "tactic-prompt":
  "theorem {s : RBNode.Stream α} : s.foldr f init = s.toList.foldr f init := by induction s; sorry",
  "name": "foldr_eq_foldr_toList",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{s : RBNode.Stream α} : s.foldr f init = s.toList.foldr f init",
  "args": "{s : RBNode.Stream α}"},
 {"type": "t.foldl f init = t.toList.foldl f init",
  "tactic-prompt":
  "theorem {t : RBNode.Stream α} : t.foldl f init = t.toList.foldl f init := by induction t generalizing init; sorry",
  "name": "foldl_eq_foldl_toList",
  "kind": "theorem",
  "first-tactic": "induction t generalizing init",
  "core-prompt":
  "{t : RBNode.Stream α} : t.foldl f init = t.toList.foldl f init",
  "args": "{t : RBNode.Stream α}"},
 {"type": "forIn (m := m) t init f = forIn t.toList init f",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  {t : RBNode α} : forIn (m := m) t init f = forIn t.toList init f := by simp [forIn]; sorry",
  "name": "forIn_eq_forIn_toList",
  "kind": "theorem",
  "first-tactic": "simp [forIn]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  {t : RBNode α} : forIn (m := m) t init f = forIn t.toList init f",
  "args": "[Monad m]  [LawfulMonad m]  {t : RBNode α}"},
 {"type": "t.toStream.toList = t.toList",
  "tactic-prompt":
  "theorem {t : RBNode α} : t.toStream.toList = t.toList := by simp [toStream_toList']; sorry",
  "name": "toStream_toList",
  "kind": "theorem",
  "first-tactic": "simp [toStream_toList']",
  "core-prompt": "{t : RBNode α} : t.toStream.toList = t.toList",
  "args": "{t : RBNode α}"},
 {"type": "(s.next?.map fun (a, b) => (a, b.toList)) = s.toList.next?",
  "tactic-prompt":
  "theorem {s : RBNode.Stream α} : (s.next?.map fun (a, b) => (a, b.toList)) = s.toList.next? := by cases s; sorry",
  "name": "Stream.next?_toList",
  "kind": "theorem",
  "first-tactic": "cases s",
  "core-prompt":
  "{s : RBNode.Stream α} : (s.next?.map fun (a, b) => (a, b.toList)) = s.toList.next?",
  "args": "{s : RBNode.Stream α}"},
 {"type": "t.Ordered cmp ↔ t.toList.Pairwise (cmpLT cmp)",
  "tactic-prompt":
  "theorem {t : RBNode α} : t.Ordered cmp ↔ t.toList.Pairwise (cmpLT cmp) := by induction t; sorry",
  "name": "ordered_iff",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "{t : RBNode α} : t.Ordered cmp ↔ t.toList.Pairwise (cmpLT cmp)",
  "args": "{t : RBNode α}"},
 {"type": "t.setBlack.toList = t.toList",
  "tactic-prompt":
  "theorem {t : RBNode α} : t.setBlack.toList = t.toList := by cases t; sorry",
  "name": "setBlack_toList",
  "kind": "theorem",
  "first-tactic": "cases t",
  "core-prompt": "{t : RBNode α} : t.setBlack.toList = t.toList",
  "args": "{t : RBNode α}"},
 {"type": "t.setRed.toList = t.toList",
  "tactic-prompt":
  "theorem {t : RBNode α} : t.setRed.toList = t.toList := by cases t; sorry",
  "name": "setRed_toList",
  "kind": "theorem",
  "first-tactic": "cases t",
  "core-prompt": "{t : RBNode α} : t.setRed.toList = t.toList",
  "args": "{t : RBNode α}"},
 {"type":
  "p.RootOrdered cmp v ↔ (∀ a ∈ p.listL, cmpLT cmp a v) ∧ (∀ a ∈ p.listR, cmpLT cmp v a)",
  "tactic-prompt":
  "theorem {p : Path α}  (hp : p.Ordered cmp) : p.RootOrdered cmp v ↔ (∀ a ∈ p.listL, cmpLT cmp a v) ∧ (∀ a ∈ p.listR, cmpLT cmp v a) := by induction p; sorry",
  "name": "rootOrdered_iff",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{p : Path α}  (hp : p.Ordered cmp) : p.RootOrdered cmp v ↔ (∀ a ∈ p.listL, cmpLT cmp a v) ∧ (∀ a ∈ p.listR, cmpLT cmp v a)",
  "args": "{p : Path α}  (hp : p.Ordered cmp)"},
 {"type":
  "p.Ordered cmp ↔ p.listL.Pairwise (cmpLT cmp) ∧ p.listR.Pairwise (cmpLT cmp) ∧\n      ∀ x ∈ p.listL, ∀ y ∈ p.listR, cmpLT cmp x y",
  "tactic-prompt":
  "theorem {p : Path α} : p.Ordered cmp ↔ p.listL.Pairwise (cmpLT cmp) ∧ p.listR.Pairwise (cmpLT cmp) ∧\n      ∀ x ∈ p.listL, ∀ y ∈ p.listR, cmpLT cmp x y := by induction p; sorry",
  "name": "ordered_iff",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{p : Path α} : p.Ordered cmp ↔ p.listL.Pairwise (cmpLT cmp) ∧ p.listR.Pairwise (cmpLT cmp) ∧\n      ∀ x ∈ p.listL, ∀ y ∈ p.listR, cmpLT cmp x y",
  "args": "{p : Path α}"},
 {"type": "(p.fill t).toList = p.withList t.toList",
  "tactic-prompt":
  "theorem {p : Path α} : (p.fill t).toList = p.withList t.toList := by induction p generalizing t; sorry",
  "name": "fill_toList",
  "kind": "theorem",
  "first-tactic": "induction p generalizing t",
  "core-prompt": "{p : Path α} : (p.fill t).toList = p.withList t.toList",
  "args": "{p : Path α}"},
 {"type": "p'.withList t'.toList = t.toList",
  "tactic-prompt":
  "theorem {t : RBNode α}  (eq : t.zoom cut = (t', p')) : p'.withList t'.toList = t.toList := by rw [← fill_toList]; sorry",
  "name": "_root_.Std.RBNode.zoom_toList",
  "kind": "theorem",
  "first-tactic": "rw [← fill_toList]",
  "core-prompt":
  "{t : RBNode α}  (eq : t.zoom cut = (t', p')) : p'.withList t'.toList = t.toList",
  "args": "{t : RBNode α}  (eq : t.zoom cut = (t', p'))"},
 {"type": "(p.ins t).toList = p.withList t.toList",
  "tactic-prompt":
  "theorem {p : Path α} : (p.ins t).toList = p.withList t.toList := by match p with\n  | .root | .left red .. | .right red .. | .left black .. | .right black .. =>\n    simp [ins]; sorry",
  "name": "ins_toList",
  "kind": "theorem",
  "first-tactic":
  "match p with\n  | .root | .left red .. | .right red .. | .left black .. | .right black .. =>\n    simp [ins]",
  "core-prompt": "{p : Path α} : (p.ins t).toList = p.withList t.toList",
  "args": "{p : Path α}"},
 {"type": "(p.insertNew v).toList = p.withList [v]",
  "tactic-prompt":
  "theorem {p : Path α} : (p.insertNew v).toList = p.withList [v] := by simp [insertNew]; sorry",
  "name": "insertNew_toList",
  "kind": "theorem",
  "first-tactic": "simp [insertNew]",
  "core-prompt": "{p : Path α} : (p.insertNew v).toList = p.withList [v]",
  "args": "{p : Path α}"},
 {"type": "(p.insert t v).toList = p.withList (t.setRoot v).toList",
  "tactic-prompt":
  "theorem {p : Path α} : (p.insert t v).toList = p.withList (t.setRoot v).toList := by simp [insert]; sorry",
  "name": "insert_toList",
  "kind": "theorem",
  "first-tactic": "simp [insert]",
  "core-prompt":
  "{p : Path α} : (p.insert t v).toList = p.withList (t.setRoot v).toList",
  "args": "{p : Path α}"},
 {"type": "∀ l₁ l₂, map f (l₁ ++ l₂) = map f l₁ ++ map f l₂",
  "tactic-prompt":
  "theorem (f : α → β) : ∀ l₁ l₂, map f (l₁ ++ l₂) = map f l₁ ++ map f l₂ := by intro l₁; sorry",
  "name": "map_append",
  "kind": "theorem",
  "first-tactic": "intro l₁",
  "core-prompt":
  "(f : α → β) : ∀ l₁ l₂, map f (l₁ ++ l₂) = map f l₁ ++ map f l₂",
  "args": "(f : α → β)"},
 {"type": "map id l = l",
  "tactic-prompt":
  "theorem (l : List α) : map id l = l := by induction l; sorry",
  "name": "map_id",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List α) : map id l = l",
  "args": "(l : List α)"},
 {"type": "map g (map f l) = map (g ∘ f) l",
  "tactic-prompt":
  "theorem (g : β → γ)  (f : α → β)  (l : List α) : map g (map f l) = map (g ∘ f) l := by induction l; sorry",
  "name": "map_map",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(g : β → γ)  (f : α → β)  (l : List α) : map g (map f l) = map (g ∘ f) l",
  "args": "(g : β → γ)  (f : α → β)  (l : List α)"},
 {"type": "List.bind [] f = []",
  "tactic-prompt":
  "theorem (f : α → List β) : List.bind [] f = [] := by simp [join]; sorry",
  "name": "nil_bind",
  "kind": "theorem",
  "first-tactic": "simp [join]",
  "core-prompt": "(f : α → List β) : List.bind [] f = []",
  "args": "(f : α → List β)"},
 {"type": "List.bind l id = l.join",
  "tactic-prompt":
  "theorem (l : List (List α)) : List.bind l id = l.join := by simp [List.bind]; sorry",
  "name": "bind_id",
  "kind": "theorem",
  "first-tactic": "simp [List.bind]",
  "core-prompt": "(l : List (List α)) : List.bind l id = l.join",
  "args": "(l : List (List α))"},
 {"type": "(l.map f).reverse = l.reverse.map f",
  "tactic-prompt":
  "theorem (f : α → β)  (l : List α) : (l.map f).reverse = l.reverse.map f := by induction l; sorry",
  "name": "reverse_map",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : α → β)  (l : List α) : (l.map f).reverse = l.reverse.map f",
  "args": "(f : α → β)  (l : List α)"},
 {"type": "take i l = l",
  "tactic-prompt":
  "theorem {l : List α}  (h : l.length ≤ i) : take i l = l := by have := take_append_drop i l; sorry",
  "name": "take_length_le",
  "kind": "theorem",
  "first-tactic": "have := take_append_drop i l",
  "core-prompt": "{l : List α}  (h : l.length ≤ i) : take i l = l",
  "args": "{l : List α}  (h : l.length ≤ i)"},
 {"type": "(l.concat a).reverse = a :: l.reverse",
  "tactic-prompt":
  "theorem (l : List α)  (a : α) : (l.concat a).reverse = a :: l.reverse := by rw [concat_eq_append]; sorry",
  "name": "reverse_concat",
  "kind": "theorem",
  "first-tactic": "rw [concat_eq_append]",
  "core-prompt":
  "(l : List α)  (a : α) : (l.concat a).reverse = a :: l.reverse",
  "args": "(l : List α)  (a : α)"},
 {"type": "l.foldr cons l' = l ++ l'",
  "tactic-prompt":
  "theorem (l : List α) : l.foldr cons l' = l ++ l' := by induction l; sorry",
  "name": "foldr_self_append",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List α) : l.foldr cons l' = l ++ l'",
  "args": "(l : List α)"},
 {"type": "l.foldr cons [] = l",
  "tactic-prompt":
  "theorem (l : List α) : l.foldr cons [] = l := by simp; sorry",
  "name": "foldr_self",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(l : List α) : l.foldr cons [] = l",
  "args": "(l : List α)"},
 {"type": "mapM' f l = mapM f l",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (f : α → m β)  (l : List α) : mapM' f l = mapM f l := by simp [go]; sorry",
  "name": "mapM'_eq_mapM",
  "kind": "theorem",
  "first-tactic": "simp [go]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (f : α → m β)  (l : List α) : mapM' f l = mapM f l",
  "args": "[Monad m]  [LawfulMonad m]  (f : α → m β)  (l : List α)"},
 {"type": "(a :: l).mapM f = (return (← f a) :: (← l.mapM f))",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (f : α → m β) : (a :: l).mapM f = (return (← f a) :: (← l.mapM f)) := by simp [← mapM'_eq_mapM]; sorry",
  "name": "mapM_cons",
  "kind": "theorem",
  "first-tactic": "simp [← mapM'_eq_mapM]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (f : α → m β) : (a :: l).mapM f = (return (← f a) :: (← l.mapM f))",
  "args": "[Monad m]  [LawfulMonad m]  (f : α → m β)"},
 {"type": "(l₁ ++ l₂).mapM f = (return (← l₁.mapM f) ++ (← l₂.mapM f))",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (f : α → m β)  {l₁ l₂ : List α} : (l₁ ++ l₂).mapM f = (return (← l₁.mapM f) ++ (← l₂.mapM f)) := by induction l₁; sorry",
  "name": "mapM_append",
  "kind": "theorem",
  "first-tactic": "induction l₁",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (f : α → m β)  {l₁ l₂ : List α} : (l₁ ++ l₂).mapM f = (return (← l₁.mapM f) ++ (← l₂.mapM f))",
  "args": "[Monad m]  [LawfulMonad m]  (f : α → m β)  {l₁ l₂ : List α}"},
 {"type": "@set = @setTR",
  "tactic-prompt": "theorem  : @set = @setTR := by funext α l n a; sorry",
  "name": "set_eq_setTR",
  "kind": "theorem",
  "first-tactic": "funext α l n a",
  "core-prompt": " : @set = @setTR",
  "args": ""},
 {"type": "@List.erase = @eraseTR",
  "tactic-prompt":
  "theorem  : @List.erase = @eraseTR := by funext α _ l a; sorry",
  "name": "erase_eq_eraseTR",
  "kind": "theorem",
  "first-tactic": "funext α _ l a",
  "core-prompt": " : @List.erase = @eraseTR",
  "args": ""},
 {"type": "@eraseIdx = @eraseIdxTR",
  "tactic-prompt":
  "theorem  : @eraseIdx = @eraseIdxTR := by funext α l n; sorry",
  "name": "eraseIdx_eq_eraseIdxTR",
  "kind": "theorem",
  "first-tactic": "funext α l n",
  "core-prompt": " : @eraseIdx = @eraseIdxTR",
  "args": ""},
 {"type": "@List.bind = @bindTR",
  "tactic-prompt":
  "theorem  : @List.bind = @bindTR := by funext α β as f; sorry",
  "name": "bind_eq_bindTR",
  "kind": "theorem",
  "first-tactic": "funext α β as f",
  "core-prompt": " : @List.bind = @bindTR",
  "args": ""},
 {"type": "@join = @joinTR",
  "tactic-prompt": "theorem  : @join = @joinTR := by funext α l; sorry",
  "name": "join_eq_joinTR",
  "kind": "theorem",
  "first-tactic": "funext α l",
  "core-prompt": " : @join = @joinTR",
  "args": ""},
 {"type": "@List.filterMap = @filterMapTR",
  "tactic-prompt":
  "theorem  : @List.filterMap = @filterMapTR := by funext α β f l; sorry",
  "name": "filterMap_eq_filterMapTR",
  "kind": "theorem",
  "first-tactic": "funext α β f l",
  "core-prompt": " : @List.filterMap = @filterMapTR",
  "args": ""},
 {"type": "@List.replace = @replaceTR",
  "tactic-prompt":
  "theorem  : @List.replace = @replaceTR := by funext α _ l b c; sorry",
  "name": "replace_eq_replaceTR",
  "kind": "theorem",
  "first-tactic": "funext α _ l b c",
  "core-prompt": " : @List.replace = @replaceTR",
  "args": ""},
 {"type": "@take = @takeTR",
  "tactic-prompt": "theorem  : @take = @takeTR := by funext α n l; sorry",
  "name": "take_eq_takeTR",
  "kind": "theorem",
  "first-tactic": "funext α n l",
  "core-prompt": " : @take = @takeTR",
  "args": ""},
 {"type": "@takeWhile = @takeWhileTR",
  "tactic-prompt":
  "theorem  : @takeWhile = @takeWhileTR := by funext α p l; sorry",
  "name": "takeWhile_eq_takeWhileTR",
  "kind": "theorem",
  "first-tactic": "funext α p l",
  "core-prompt": " : @takeWhile = @takeWhileTR",
  "args": ""},
 {"type": "@foldr = @foldrTR",
  "tactic-prompt":
  "theorem  : @foldr = @foldrTR := by funext α β f init l; sorry",
  "name": "foldr_eq_foldrTR",
  "kind": "theorem",
  "first-tactic": "funext α β f init l",
  "core-prompt": " : @foldr = @foldrTR",
  "args": ""},
 {"type": "@zipWith = @zipWithTR",
  "tactic-prompt":
  "theorem  : @zipWith = @zipWithTR := by funext α β γ f as bs; sorry",
  "name": "zipWith_eq_zipWithTR",
  "kind": "theorem",
  "first-tactic": "funext α β γ f as bs",
  "core-prompt": " : @zipWith = @zipWithTR",
  "args": ""},
 {"type": "@unzip = @unzipTR",
  "tactic-prompt": "theorem  : @unzip = @unzipTR := by funext α β l; sorry",
  "name": "unzip_eq_unzipTR",
  "kind": "theorem",
  "first-tactic": "funext α β l",
  "core-prompt": " : @unzip = @unzipTR",
  "args": ""},
 {"type": "@enumFrom = @enumFromTR",
  "tactic-prompt":
  "theorem  : @enumFrom = @enumFromTR := by funext α n l; sorry",
  "name": "enumFrom_eq_enumFromTR",
  "kind": "theorem",
  "first-tactic": "funext α n l",
  "core-prompt": " : @enumFrom = @enumFromTR",
  "args": ""},
 {"type": "@dropLast = @dropLastTR",
  "tactic-prompt": "theorem  : @dropLast = @dropLastTR := by funext α l; sorry",
  "name": "dropLast_eq_dropLastTR",
  "kind": "theorem",
  "first-tactic": "funext α l",
  "core-prompt": " : @dropLast = @dropLastTR",
  "args": ""},
 {"type": "@intersperse = @intersperseTR",
  "tactic-prompt":
  "theorem  : @intersperse = @intersperseTR := by funext α sep l; sorry",
  "name": "intersperse_eq_intersperseTR",
  "kind": "theorem",
  "first-tactic": "funext α sep l",
  "core-prompt": " : @intersperse = @intersperseTR",
  "args": ""},
 {"type": "@intercalate = @intercalateTR",
  "tactic-prompt":
  "theorem  : @intercalate = @intercalateTR := by funext α sep l; sorry",
  "name": "intercalate_eq_intercalateTR",
  "kind": "theorem",
  "first-tactic": "funext α sep l",
  "core-prompt": " : @intercalate = @intercalateTR",
  "args": ""},
 {"type": "@removeNth = @removeNthTR",
  "tactic-prompt":
  "theorem  : @removeNth = @removeNthTR := by funext α l n; sorry",
  "name": "removeNth_eq_removeNthTR",
  "kind": "theorem",
  "first-tactic": "funext α l n",
  "core-prompt": " : @removeNth = @removeNthTR",
  "args": ""},
 {"type": "@replaceF = @replaceFTR",
  "tactic-prompt":
  "theorem  : @replaceF = @replaceFTR := by funext α f l; sorry",
  "name": "replaceF_eq_replaceFTR",
  "kind": "theorem",
  "first-tactic": "funext α f l",
  "core-prompt": " : @replaceF = @replaceFTR",
  "args": ""},
 {"type": "@modifyNth = @modifyNthTR",
  "tactic-prompt":
  "theorem  : @modifyNth = @modifyNthTR := by funext α f n l; sorry",
  "name": "modifyNth_eq_modifyNthTR",
  "kind": "theorem",
  "first-tactic": "funext α f n l",
  "core-prompt": " : @modifyNth = @modifyNthTR",
  "args": ""},
 {"type": "@insertNth = @insertNthTR",
  "tactic-prompt":
  "theorem  : @insertNth = @insertNthTR := by funext α f n l; sorry",
  "name": "insertNth_eq_insertNthTR",
  "kind": "theorem",
  "first-tactic": "funext α f n l",
  "core-prompt": " : @insertNth = @insertNthTR",
  "args": ""},
 {"type": "@takeD = @takeDTR",
  "tactic-prompt": "theorem  : @takeD = @takeDTR := by funext α f n l; sorry",
  "name": "takeD_eq_takeDTR",
  "kind": "theorem",
  "first-tactic": "funext α f n l",
  "core-prompt": " : @takeD = @takeDTR",
  "args": ""},
 {"type": "@leftpad = @leftpadTR",
  "tactic-prompt":
  "theorem  : @leftpad = @leftpadTR := by funext α n a l; sorry",
  "name": "leftpad_eq_leftpadTR",
  "kind": "theorem",
  "first-tactic": "funext α n a l",
  "core-prompt": " : @leftpad = @leftpadTR",
  "args": ""},
 {"type": "@scanl = @scanlTR",
  "tactic-prompt": "theorem  : @scanl = @scanlTR := by funext α f n l; sorry",
  "name": "scanl_eq_scanlTR",
  "kind": "theorem",
  "first-tactic": "funext α f n l",
  "core-prompt": " : @scanl = @scanlTR",
  "args": ""},
 {"type": "@inits = @initsTR",
  "tactic-prompt": "theorem  : @inits = @initsTR := by funext α l; sorry",
  "name": "inits_eq_initsTR",
  "kind": "theorem",
  "first-tactic": "funext α l",
  "core-prompt": " : @inits = @initsTR",
  "args": ""},
 {"type": "@tails = @tailsTR",
  "tactic-prompt": "theorem  : @tails = @tailsTR := by funext α; sorry",
  "name": "tails_eq_tailsTR",
  "kind": "theorem",
  "first-tactic": "funext α",
  "core-prompt": " : @tails = @tailsTR",
  "args": ""},
 {"type": "@sections = @sectionsTR",
  "tactic-prompt": "theorem  : @sections = @sectionsTR := by funext α L; sorry",
  "name": "sections_eq_sectionsTR",
  "kind": "theorem",
  "first-tactic": "funext α L",
  "core-prompt": " : @sections = @sectionsTR",
  "args": ""},
 {"type": "@eraseP = @erasePTR",
  "tactic-prompt": "theorem  : @eraseP = @erasePTR := by funext α p l; sorry",
  "name": "eraseP_eq_erasePTR",
  "kind": "theorem",
  "first-tactic": "funext α p l",
  "core-prompt": " : @eraseP = @erasePTR",
  "args": ""},
 {"type": "@product = @productTR",
  "tactic-prompt":
  "theorem  : @product = @productTR := by funext α β l₁ l₂; sorry",
  "name": "product_eq_productTR",
  "kind": "theorem",
  "first-tactic": "funext α β l₁ l₂",
  "core-prompt": " : @product = @productTR",
  "args": ""},
 {"type": "@List.sigma = @sigmaTR",
  "tactic-prompt":
  "theorem  : @List.sigma = @sigmaTR := by funext α β l₁ l₂; sorry",
  "name": "sigma_eq_sigmaTR",
  "kind": "theorem",
  "first-tactic": "funext α β l₁ l₂",
  "core-prompt": " : @List.sigma = @sigmaTR",
  "args": ""},
 {"type": "@range' = @range'TR",
  "tactic-prompt": "theorem  : @range' = @range'TR := by funext s n; sorry",
  "name": "range'_eq_range'TR",
  "kind": "theorem",
  "first-tactic": "funext s n",
  "core-prompt": " : @range' = @range'TR",
  "args": ""},
 {"type": "@dropSlice = @dropSliceTR",
  "tactic-prompt":
  "theorem  : @dropSlice = @dropSliceTR := by funext α n m l; sorry",
  "name": "dropSlice_eq_dropSliceTR",
  "kind": "theorem",
  "first-tactic": "funext α n m l",
  "core-prompt": " : @dropSlice = @dropSliceTR",
  "args": ""},
 {"type": "@zipWithLeft' = @zipWithLeft'TR",
  "tactic-prompt":
  "theorem  : @zipWithLeft' = @zipWithLeft'TR := by funext α β γ f as bs; sorry",
  "name": "zipWithLeft'_eq_zipWithLeft'TR",
  "kind": "theorem",
  "first-tactic": "funext α β γ f as bs",
  "core-prompt": " : @zipWithLeft' = @zipWithLeft'TR",
  "args": ""},
 {"type": "@zipWithLeft = @zipWithLeftTR",
  "tactic-prompt":
  "theorem  : @zipWithLeft = @zipWithLeftTR := by funext α β γ f as bs; sorry",
  "name": "zipWithLeft_eq_zipWithLeftTR",
  "kind": "theorem",
  "first-tactic": "funext α β γ f as bs",
  "core-prompt": " : @zipWithLeft = @zipWithLeftTR",
  "args": ""},
 {"type": "@fillNones = @fillNonesTR",
  "tactic-prompt":
  "theorem  : @fillNones = @fillNonesTR := by funext α as as'; sorry",
  "name": "fillNones_eq_fillNonesTR",
  "kind": "theorem",
  "first-tactic": "funext α as as'",
  "core-prompt": " : @fillNones = @fillNonesTR",
  "args": ""},
 {"type": "@takeList = @takeListTR",
  "tactic-prompt":
  "theorem  : @takeList = @takeListTR := by funext α xs ns; sorry",
  "name": "takeList_eq_takeListTR",
  "kind": "theorem",
  "first-tactic": "funext α xs ns",
  "core-prompt": " : @takeList = @takeListTR",
  "args": ""},
 {"type": "a ∈ ([] : List α) ↔ False",
  "tactic-prompt":
  "theorem (a : α) : a ∈ ([] : List α) ↔ False := by simp; sorry",
  "name": "mem_nil_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a : α) : a ∈ ([] : List α) ↔ False",
  "args": "(a : α)"},
 {"type": "l ≠ []",
  "tactic-prompt":
  "theorem {a : α}  {l : List α}  (h : a ∈ l) : l ≠ [] := by cases h; sorry",
  "name": "ne_nil_of_mem",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt": "{a : α}  {l : List α}  (h : a ∈ l) : l ≠ []",
  "args": "{a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "p ++ q = [] ↔ p = [] ∧ q = []",
  "tactic-prompt":
  "theorem  : p ++ q = [] ↔ p = [] ∧ q = [] := by cases p; sorry",
  "name": "append_eq_nil",
  "kind": "theorem",
  "first-tactic": "cases p",
  "core-prompt": " : p ++ q = [] ↔ p = [] ∧ q = []",
  "args": ""},
 {"type": "s ≠ [] → s ++ t ≠ []",
  "tactic-prompt":
  "theorem (s t : List α) : s ≠ [] → s ++ t ≠ [] := by simp_all; sorry",
  "name": "append_ne_nil_of_ne_nil_left",
  "kind": "theorem",
  "first-tactic": "simp_all",
  "core-prompt": "(s t : List α) : s ≠ [] → s ++ t ≠ []",
  "args": "(s t : List α)"},
 {"type": "t ≠ [] → s ++ t ≠ []",
  "tactic-prompt":
  "theorem (s t : List α) : t ≠ [] → s ++ t ≠ [] := by simp_all; sorry",
  "name": "append_ne_nil_of_ne_nil_right",
  "kind": "theorem",
  "first-tactic": "simp_all",
  "core-prompt": "(s t : List α) : t ≠ [] → s ++ t ≠ []",
  "args": "(s t : List α)"},
 {"type": "[] = a ++ b ↔ a = [] ∧ b = []",
  "tactic-prompt":
  "theorem  : [] = a ++ b ↔ a = [] ∧ b = [] := by rw [eq_comm]; sorry",
  "name": "nil_eq_append",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt": " : [] = a ++ b ↔ a = [] ∧ b = []",
  "args": ""},
 {"type": "a ++ b ≠ []",
  "tactic-prompt":
  "theorem (a b : List α)  (h0 : a ≠ []) : a ++ b ≠ [] := by simp [*]; sorry",
  "name": "append_ne_nil_of_left_ne_nil",
  "kind": "theorem",
  "first-tactic": "simp [*]",
  "core-prompt": "(a b : List α)  (h0 : a ≠ []) : a ++ b ≠ []",
  "args": "(a b : List α)  (h0 : a ≠ [])"},
 {"type":
  "a ++ b = x :: c ↔ (a = [] ∧ b = x :: c) ∨ (∃ a', a = x :: a' ∧ c = a' ++ b)",
  "tactic-prompt":
  "theorem  : a ++ b = x :: c ↔ (a = [] ∧ b = x :: c) ∨ (∃ a', a = x :: a' ∧ c = a' ++ b) := by cases a; sorry",
  "name": "append_eq_cons",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  " : a ++ b = x :: c ↔ (a = [] ∧ b = x :: c) ∨ (∃ a', a = x :: a' ∧ c = a' ++ b)",
  "args": ""},
 {"type":
  "x :: c = a ++ b ↔ (a = [] ∧ b = x :: c) ∨ (∃ a', a = x :: a' ∧ c = a' ++ b)",
  "tactic-prompt":
  "theorem  : x :: c = a ++ b ↔ (a = [] ∧ b = x :: c) ∨ (∃ a', a = x :: a' ∧ c = a' ++ b) := by rw [eq_comm]; sorry",
  "name": "cons_eq_append",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt":
  " : x :: c = a ++ b ↔ (a = [] ∧ b = x :: c) ∨ (∃ a', a = x :: a' ∧ c = a' ++ b)",
  "args": ""},
 {"type":
  "a ++ b = c ++ d ↔ (∃ a', c = a ++ a' ∧ b = a' ++ d) ∨ ∃ c', a = c ++ c' ∧ d = c' ++ b",
  "tactic-prompt":
  "theorem {a b c d : List α} : a ++ b = c ++ d ↔ (∃ a', c = a ++ a' ∧ b = a' ++ d) ∨ ∃ c', a = c ++ c' ∧ d = c' ++ b := by induction a generalizing c with\n  | nil => simp; exact (or_iff_left_of_imp fun ⟨_, ⟨e, rfl⟩, h⟩ => e ▸ h.symm).symm\n  | cons a as ih => cases c; sorry",
  "name": "append_eq_append_iff",
  "kind": "theorem",
  "first-tactic":
  "induction a generalizing c with\n  | nil => simp; exact (or_iff_left_of_imp fun ⟨_, ⟨e, rfl⟩, h⟩ => e ▸ h.symm).symm\n  | cons a as ih => cases c",
  "core-prompt":
  "{a b c d : List α} : a ++ b = c ++ d ↔ (∃ a', c = a ++ a' ∧ b = a' ++ d) ∨ ∃ c', a = c ++ c' ∧ d = c' ++ b",
  "args": "{a b c d : List α}"},
 {"type": "a ∈ s ++ t ↔ a ∈ s ∨ a ∈ t",
  "tactic-prompt":
  "theorem {a : α}  {s t : List α} : a ∈ s ++ t ↔ a ∈ s ∨ a ∈ t := by induction s; sorry",
  "name": "mem_append",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt": "{a : α}  {s t : List α} : a ∈ s ++ t ↔ a ∈ s ∨ a ∈ t",
  "args": "{a : α}  {s t : List α}"},
 {"type": "(∀ i ∈ l.map f, P i) ↔ ∀ j ∈ l, P (f j)",
  "tactic-prompt":
  "theorem {f : α → β}  {l : List α}  {P : β → Prop} : (∀ i ∈ l.map f, P i) ↔ ∀ j ∈ l, P (f j) := by simp [mem_map]; sorry",
  "name": "forall_mem_map_iff",
  "kind": "theorem",
  "first-tactic": "simp [mem_map]",
  "core-prompt":
  "{f : α → β}  {l : List α}  {P : β → Prop} : (∀ i ∈ l.map f, P i) ↔ ∀ j ∈ l, P (f j)",
  "args": "{f : α → β}  {l : List α}  {P : β → Prop}"},
 {"type": "List.map f l = [] ↔ l = []",
  "tactic-prompt":
  "theorem {f : α → β}  {l : List α} : List.map f l = [] ↔ l = [] := by constructor; sorry",
  "name": "map_eq_nil",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{f : α → β}  {l : List α} : List.map f l = [] ↔ l = []",
  "args": "{f : α → β}  {l : List α}"},
 {"type": "(∃ x ∈ a :: l, p x) ↔ p a ∨ ∃ x ∈ l, p x",
  "tactic-prompt":
  "theorem {p : α → Prop}  {a : α}  {l : List α} : (∃ x ∈ a :: l, p x) ↔ p a ∨ ∃ x ∈ l, p x := by simp; sorry",
  "name": "exists_mem_cons",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{p : α → Prop}  {a : α}  {l : List α} : (∃ x ∈ a :: l, p x) ↔ p a ∨ ∃ x ∈ l, p x",
  "args": "{p : α → Prop}  {a : α}  {l : List α}"},
 {"type": "(∀ x ∈ a :: l, p x) ↔ p a ∧ ∀ x ∈ l, p x",
  "tactic-prompt":
  "theorem {p : α → Prop}  {a : α}  {l : List α} : (∀ x ∈ a :: l, p x) ↔ p a ∧ ∀ x ∈ l, p x := by simp; sorry",
  "name": "forall_mem_cons",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{p : α → Prop}  {a : α}  {l : List α} : (∀ x ∈ a :: l, p x) ↔ p a ∧ ∀ x ∈ l, p x",
  "args": "{p : α → Prop}  {a : α}  {l : List α}"},
 {"type": "(∀ x ∈ [a], p x) ↔ p a",
  "tactic-prompt":
  "theorem {p : α → Prop}  {a : α} : (∀ x ∈ [a], p x) ↔ p a := by simp only [mem_singleton]; sorry",
  "name": "forall_mem_singleton",
  "kind": "theorem",
  "first-tactic": "simp only [mem_singleton]",
  "core-prompt": "{p : α → Prop}  {a : α} : (∀ x ∈ [a], p x) ↔ p a",
  "args": "{p : α → Prop}  {a : α}"},
 {"type": "(∀ x ∈ l₁ ++ l₂, p x) ↔ (∀ x ∈ l₁, p x) ∧ (∀ x ∈ l₂, p x)",
  "tactic-prompt":
  "theorem {p : α → Prop}  {l₁ l₂ : List α} : (∀ x ∈ l₁ ++ l₂, p x) ↔ (∀ x ∈ l₁, p x) ∧ (∀ x ∈ l₂, p x) := by simp only [mem_append]; sorry",
  "name": "forall_mem_append",
  "kind": "theorem",
  "first-tactic": "simp only [mem_append]",
  "core-prompt":
  "{p : α → Prop}  {l₁ l₂ : List α} : (∀ x ∈ l₁ ++ l₂, p x) ↔ (∀ x ∈ l₁, p x) ∧ (∀ x ∈ l₂, p x)",
  "args": "{p : α → Prop}  {l₁ l₂ : List α}"},
 {"type": "a :: l ⊆ m ↔ a ∈ m ∧ l ⊆ m",
  "tactic-prompt":
  "theorem  : a :: l ⊆ m ↔ a ∈ m ∧ l ⊆ m := by simp only [subset_def]; sorry",
  "name": "cons_subset",
  "kind": "theorem",
  "first-tactic": "simp only [subset_def]",
  "core-prompt": " : a :: l ⊆ m ↔ a ∈ m ∧ l ⊆ m",
  "args": ""},
 {"type": "l₁ ++ l₂ ⊆ l ↔ l₁ ⊆ l ∧ l₂ ⊆ l",
  "tactic-prompt":
  "theorem {l₁ l₂ l : List α} : l₁ ++ l₂ ⊆ l ↔ l₁ ⊆ l ∧ l₂ ⊆ l := by simp [subset_def]; sorry",
  "name": "append_subset",
  "kind": "theorem",
  "first-tactic": "simp [subset_def]",
  "core-prompt": "{l₁ l₂ l : List α} : l₁ ++ l₂ ⊆ l ↔ l₁ ⊆ l ∧ l₂ ⊆ l",
  "args": "{l₁ l₂ l : List α}"},
 {"type":
  "∀ (h₁ : a :: l ≠ nil) (h₂ : l ≠ nil),\n  getLast (a :: l) h₁ = getLast l h₂",
  "tactic-prompt":
  "theorem {a : α}  {l : List α} : ∀ (h₁ : a :: l ≠ nil) (h₂ : l ≠ nil),\n  getLast (a :: l) h₁ = getLast l h₂ := by induction l; sorry",
  "name": "getLast_cons'",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : α}  {l : List α} : ∀ (h₁ : a :: l ≠ nil) (h₂ : l ≠ nil),\n  getLast (a :: l) h₁ = getLast l h₂",
  "args": "{a : α}  {l : List α}"},
 {"type": "tailD l l' = (tail? l).getD l'",
  "tactic-prompt":
  "theorem (l l' : List α) : tailD l l' = (tail? l).getD l' := by cases l; sorry",
  "name": "tailD_eq_tail?",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "(l l' : List α) : tailD l l' = (tail? l).getD l'",
  "args": "(l l' : List α)"},
 {"type": "@getLast! α _ (a::l) = getLastD l a",
  "tactic-prompt":
  "theorem [Inhabited α] : @getLast! α _ (a::l) = getLastD l a := by simp [getLast!]; sorry",
  "name": "getLast!_cons",
  "kind": "theorem",
  "first-tactic": "simp [getLast!]",
  "core-prompt": "[Inhabited α] : @getLast! α _ (a::l) = getLastD l a",
  "args": "[Inhabited α]"},
 {"type": "@getLast? α (a::l) = getLastD l a",
  "tactic-prompt":
  "theorem  : @getLast? α (a::l) = getLastD l a := by simp [getLast?]; sorry",
  "name": "getLast?_cons",
  "kind": "theorem",
  "first-tactic": "simp [getLast?]",
  "core-prompt": " : @getLast? α (a::l) = getLastD l a",
  "args": ""},
 {"type": "dropLast (l₁ ++ b::l₂) = l₁ ++ dropLast (b::l₂)",
  "tactic-prompt":
  "theorem  : dropLast (l₁ ++ b::l₂) = l₁ ++ dropLast (b::l₂) := by induction l₁; sorry",
  "name": "dropLast_append_cons",
  "kind": "theorem",
  "first-tactic": "induction l₁",
  "core-prompt": " : dropLast (l₁ ++ b::l₂) = l₁ ++ dropLast (b::l₂)",
  "args": ""},
 {"type": "dropLast (l₁ ++ [b]) = l₁",
  "tactic-prompt": "theorem  : dropLast (l₁ ++ [b]) = l₁ := by simp; sorry",
  "name": "dropLast_concat",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : dropLast (l₁ ++ [b]) = l₁",
  "args": ""},
 {"type": "l.get? 0 = l.head?",
  "tactic-prompt":
  "theorem (l : List α) : l.get? 0 = l.head? := by cases l; sorry",
  "name": "get?_zero",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "(l : List α) : l.get? 0 = l.head?",
  "args": "(l : List α)"},
 {"type": "l[i]? = l.get? i",
  "tactic-prompt":
  "theorem (l : List α)  (i : Nat) : l[i]? = l.get? i := by unfold getElem?; sorry",
  "name": "getElem?_eq_get?",
  "kind": "theorem",
  "first-tactic": "unfold getElem?",
  "core-prompt": "(l : List α)  (i : Nat) : l[i]? = l.get? i",
  "args": "(l : List α)  (i : Nat)"},
 {"type": "i = j",
  "tactic-prompt":
  "theorem (h₀ : i < xs.length)  (h₁ : Nodup xs)  (h₂ : xs.get? i = xs.get? j) : i = j := by induction xs generalizing i j with\n  | nil => cases h₀\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases h₁ with\n      | cons ha h₁ => exact ih (Nat.lt_of_succ_lt_succ h₀) h₁ h₂\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at h₂\n      cases h₁; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact ⟨_, h₂⟩; exact ⟨_ , h₂.symm⟩; sorry",
  "name": "get?_inj",
  "kind": "theorem",
  "first-tactic":
  "induction xs generalizing i j with\n  | nil => cases h₀\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases h₁ with\n      | cons ha h₁ => exact ih (Nat.lt_of_succ_lt_succ h₀) h₁ h₂\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at h₂\n      cases h₁; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact ⟨_, h₂⟩; exact ⟨_ , h₂.symm⟩",
  "core-prompt":
  "(h₀ : i < xs.length)  (h₁ : Nodup xs)  (h₂ : xs.get? i = xs.get? j) : i = j",
  "args":
  "(h₀ : i < xs.length)  (h₁ : Nodup xs)  (h₂ : xs.get? i = xs.get? j)"},
 {"type": "get l i = get l' ⟨i, h ▸ i.2⟩",
  "tactic-prompt":
  "theorem {l l' : List α}  (h : l = l')  (i : Fin l.length) : get l i = get l' ⟨i, h ▸ i.2⟩ := by cases h; sorry",
  "name": "get_of_eq",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{l l' : List α}  (h : l = l')  (i : Fin l.length) : get l i = get l' ⟨i, h ▸ i.2⟩",
  "args": "{l l' : List α}  (h : l = l')  (i : Fin l.length)"},
 {"type": "n - l₁.length < l₂.length",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  {n : Nat}    (h₁ : l₁.length ≤ n)  (h₂ : n < (l₁ ++ l₂).length) : n - l₁.length < l₂.length := by rw [length_append] at h₂; sorry",
  "name": "get_append_right_aux",
  "kind": "theorem",
  "first-tactic": "rw [length_append] at h₂",
  "core-prompt":
  "{l₁ l₂ : List α}  {n : Nat}    (h₁ : l₁.length ≤ n)  (h₂ : n < (l₁ ++ l₂).length) : n - l₁.length < l₂.length",
  "args":
  "{l₁ l₂ : List α}  {n : Nat}    (h₁ : l₁.length ≤ n)  (h₂ : n < (l₁ ++ l₂).length)"},
 {"type": "(l₁ ++ l₂).get? n = l₁.get? n",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  {n : Nat}  (hn : n < l₁.length) : (l₁ ++ l₂).get? n = l₁.get? n := by have hn' : n < (l₁ ++ l₂).length := Nat.lt_of_lt_of_le hn <|\n    length_append .. ▸ Nat.le_add_right ..; sorry",
  "name": "get?_append",
  "kind": "theorem",
  "first-tactic":
  "have hn' : n < (l₁ ++ l₂).length := Nat.lt_of_lt_of_le hn <|\n    length_append .. ▸ Nat.le_add_right ..",
  "core-prompt":
  "{l₁ l₂ : List α}  {n : Nat}  (hn : n < l₁.length) : (l₁ ++ l₂).get? n = l₁.get? n",
  "args": "{l₁ l₂ : List α}  {n : Nat}  (hn : n < l₁.length)"},
 {"type": "getLast? (l ++ [a]) = some a",
  "tactic-prompt":
  "theorem (l : List α) : getLast? (l ++ [a]) = some a := by simp [getLast?_eq_get?]; sorry",
  "name": "getLast?_concat",
  "kind": "theorem",
  "first-tactic": "simp [getLast?_eq_get?]",
  "core-prompt": "(l : List α) : getLast? (l ++ [a]) = some a",
  "args": "(l : List α)"},
 {"type":
  "(x :: xs).get ⟨n, by simp [h]⟩ = (x :: xs).getLast (cons_ne_nil x xs)",
  "tactic-prompt":
  "theorem (x : α)  (xs : List α)  (n : Nat)  (h : n = xs.length) : (x :: xs).get ⟨n, by simp [h]⟩ = (x :: xs).getLast (cons_ne_nil x xs) := by rw [getLast_eq_get]; sorry",
  "name": "get_cons_length",
  "kind": "theorem",
  "first-tactic": "rw [getLast_eq_get]",
  "core-prompt":
  "(x : α)  (xs : List α)  (n : Nat)  (h : n = xs.length) : (x :: xs).get ⟨n, by simp [h]⟩ = (x :: xs).getLast (cons_ne_nil x xs)",
  "args": "(x : α)  (xs : List α)  (n : Nat)  (h : n = xs.length)"},
 {"type": "length (take n l) = n",
  "tactic-prompt":
  "theorem (h : n ≤ length l) : length (take n l) = n := by simp [Nat.min_eq_left h]; sorry",
  "name": "length_take_of_le",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_eq_left h]",
  "core-prompt": "(h : n ≤ length l) : length (take n l) = n",
  "args": "(h : n ≤ length l)"},
 {"type": "∃ l₁ l₂, l = l₁ ++ l₂ ∧ map f l₁ = s₁ ∧ map f l₂ = s₂",
  "tactic-prompt":
  "theorem {f : α → β}  {l : List α}  {s₁ s₂ : List β}      (h : map f l = s₁ ++ s₂) : ∃ l₁ l₂, l = l₁ ++ l₂ ∧ map f l₁ = s₁ ∧ map f l₂ = s₂ := by have := h; sorry",
  "name": "map_eq_append_split",
  "kind": "theorem",
  "first-tactic": "have := h",
  "core-prompt":
  "{f : α → β}  {l : List α}  {s₁ s₂ : List β}      (h : map f l = s₁ ++ s₂) : ∃ l₁ l₂, l = l₁ ++ l₂ ∧ map f l₁ = s₁ ∧ map f l₂ = s₂",
  "args":
  "{f : α → β}  {l : List α}  {s₁ s₂ : List β}      (h : map f l = s₁ ++ s₂)"},
 {"type":
  "∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ l₁.length = n ∧ l.set n a' = l₁ ++ a' :: l₂",
  "tactic-prompt":
  "theorem {l : List α}  (h : n < l.length) : ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ l₁.length = n ∧ l.set n a' = l₁ ++ a' :: l₂ := by rw [set_eq_modifyNth]; sorry",
  "name": "exists_of_set",
  "kind": "theorem",
  "first-tactic": "rw [set_eq_modifyNth]",
  "core-prompt":
  "{l : List α}  (h : n < l.length) : ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ l₁.length = n ∧ l.set n a' = l₁ ++ a' :: l₂",
  "args": "{l : List α}  (h : n < l.length)"},
 {"type": "(l.set i a).get ⟨i, h⟩ = a",
  "tactic-prompt":
  "theorem (l : List α)  (i : Nat)  (a : α)  (h : i < (l.set i a).length) : (l.set i a).get ⟨i, h⟩ = a := by rw [← Option.some_inj]; sorry",
  "name": "get_set_eq",
  "kind": "theorem",
  "first-tactic": "rw [← Option.some_inj]",
  "core-prompt":
  "(l : List α)  (i : Nat)  (a : α)  (h : i < (l.set i a).length) : (l.set i a).get ⟨i, h⟩ = a",
  "args": "(l : List α)  (i : Nat)  (a : α)  (h : i < (l.set i a).length)"},
 {"type": "(l.set i a).get ⟨j, hj⟩ = l.get ⟨j, by simp at hj; exact hj⟩",
  "tactic-prompt":
  "theorem {l : List α}  {i j : Nat}  (h : i ≠ j)  (a : α)      (hj : j < (l.set i a).length) : (l.set i a).get ⟨j, hj⟩ = l.get ⟨j, by simp at hj; exact hj⟩ := by rw [← Option.some_inj]; sorry",
  "name": "get_set_ne",
  "kind": "theorem",
  "first-tactic": "rw [← Option.some_inj]",
  "core-prompt":
  "{l : List α}  {i j : Nat}  (h : i ≠ j)  (a : α)      (hj : j < (l.set i a).length) : (l.set i a).get ⟨j, hj⟩ = l.get ⟨j, by simp at hj; exact hj⟩",
  "args":
  "{l : List α}  {i j : Nat}  (h : i ≠ j)  (a : α)      (hj : j < (l.set i a).length)"},
 {"type": "length (tail l) = length l - 1",
  "tactic-prompt":
  "theorem (l : List α) : length (tail l) = length l - 1 := by cases l; sorry",
  "name": "length_tail",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "(l : List α) : length (tail l) = length l - 1",
  "args": "(l : List α)"},
 {"type": "l.all p ↔ ∀ x ∈ l, p x",
  "tactic-prompt":
  "theorem {l : List α} : l.all p ↔ ∀ x ∈ l, p x := by induction l; sorry",
  "name": "all_eq_true",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "{l : List α} : l.all p ↔ ∀ x ∈ l, p x",
  "args": "{l : List α}"},
 {"type": "l.any p ↔ ∃ x ∈ l, p x",
  "tactic-prompt":
  "theorem {l : List α} : l.any p ↔ ∃ x ∈ l, p x := by induction l; sorry",
  "name": "any_eq_true",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "{l : List α} : l.any p ↔ ∃ x ∈ l, p x",
  "args": "{l : List α}"},
 {"type": "x ∈ reverse as ↔ x ∈ as",
  "tactic-prompt":
  "theorem (x : α)  (as : List α) : x ∈ reverse as ↔ x ∈ as := by simp [reverse]; sorry",
  "name": "mem_reverse",
  "kind": "theorem",
  "first-tactic": "simp [reverse]",
  "core-prompt": "(x : α)  (as : List α) : x ∈ reverse as ↔ x ∈ as",
  "args": "(x : α)  (as : List α)"},
 {"type": "l.insert a = l",
  "tactic-prompt":
  "theorem [DecidableEq α] {l : List α}  (h : a ∈ l) : l.insert a = l := by simp only [List.insert]; sorry",
  "name": "insert_of_mem",
  "kind": "theorem",
  "first-tactic": "simp only [List.insert]",
  "core-prompt": "[DecidableEq α] {l : List α}  (h : a ∈ l) : l.insert a = l",
  "args": "[DecidableEq α] {l : List α}  (h : a ∈ l)"},
 {"type": "l.insert a = a :: l",
  "tactic-prompt":
  "theorem [DecidableEq α] {l : List α}  (h : a ∉ l) : l.insert a = a :: l := by simp only [List.insert]; sorry",
  "name": "insert_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp only [List.insert]",
  "core-prompt":
  "[DecidableEq α] {l : List α}  (h : a ∉ l) : l.insert a = a :: l",
  "args": "[DecidableEq α] {l : List α}  (h : a ∉ l)"},
 {"type": "a ∈ l.insert b ↔ a = b ∨ a ∈ l",
  "tactic-prompt":
  "theorem [DecidableEq α] {l : List α} : a ∈ l.insert b ↔ a = b ∨ a ∈ l := by if h : b ∈ l then\n    rw [insert_of_mem h]\n    constructor; {apply Or.inr}\n    intro\n    | Or.inl h' => rw [h']; exact h\n    | Or.inr h' => exact h'\n  else rw [insert_of_not_mem h]; sorry",
  "name": "mem_insert_iff",
  "kind": "theorem",
  "first-tactic":
  "if h : b ∈ l then\n    rw [insert_of_mem h]\n    constructor; {apply Or.inr}\n    intro\n    | Or.inl h' => rw [h']; exact h\n    | Or.inr h' => exact h'\n  else rw [insert_of_not_mem h]",
  "core-prompt":
  "[DecidableEq α] {l : List α} : a ∈ l.insert b ↔ a = b ∨ a ∈ l",
  "args": "[DecidableEq α] {l : List α}"},
 {"type": "length (l.insert a) = length l",
  "tactic-prompt":
  "theorem [DecidableEq α] {l : List α}  (h : a ∈ l) : length (l.insert a) = length l := by rw [insert_of_mem h]; sorry",
  "name": "length_insert_of_mem",
  "kind": "theorem",
  "first-tactic": "rw [insert_of_mem h]",
  "core-prompt":
  "[DecidableEq α] {l : List α}  (h : a ∈ l) : length (l.insert a) = length l",
  "args": "[DecidableEq α] {l : List α}  (h : a ∈ l)"},
 {"type": "length (l.insert a) = length l + 1",
  "tactic-prompt":
  "theorem [DecidableEq α] {l : List α}  (h : a ∉ l) : length (l.insert a) = length l + 1 := by rw [insert_of_not_mem h]; sorry",
  "name": "length_insert_of_not_mem",
  "kind": "theorem",
  "first-tactic": "rw [insert_of_not_mem h]",
  "core-prompt":
  "[DecidableEq α] {l : List α}  (h : a ∉ l) : length (l.insert a) = length l + 1",
  "args": "[DecidableEq α] {l : List α}  (h : a ∉ l)"},
 {"type": "l.eraseP p = l",
  "tactic-prompt":
  "theorem {l : List α}  (h : ∀ a, a ∈ l → ¬p a) : l.eraseP p = l := by induction l; sorry",
  "name": "eraseP_of_forall_not",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "{l : List α}  (h : ∀ a, a ∈ l → ¬p a) : l.eraseP p = l",
  "args": "{l : List α}  (h : ∀ a, a ∈ l → ¬p a)"},
 {"type": "length (l.eraseP p) = Nat.pred (length l)",
  "tactic-prompt":
  "theorem (al : a ∈ l)  (pa : p a) : length (l.eraseP p) = Nat.pred (length l) := by let ⟨_, l₁, l₂, _, _, e₁, e₂⟩ := exists_of_eraseP al pa; sorry",
  "name": "length_eraseP_of_mem",
  "kind": "theorem",
  "first-tactic": "let ⟨_, l₁, l₂, _, _, e₁, e₂⟩ := exists_of_eraseP al pa",
  "core-prompt":
  "(al : a ∈ l)  (pa : p a) : length (l.eraseP p) = Nat.pred (length l)",
  "args": "(al : a ∈ l)  (pa : p a)"},
 {"type": "a ∈ l.eraseP p ↔ a ∈ l",
  "tactic-prompt":
  "theorem {l : List α}  (pa : ¬p a) : a ∈ l.eraseP p ↔ a ∈ l := by refine ⟨mem_of_mem_eraseP, fun al => ?_⟩; sorry",
  "name": "mem_eraseP_of_neg",
  "kind": "theorem",
  "first-tactic": "refine ⟨mem_of_mem_eraseP, fun al => ?_⟩",
  "core-prompt": "{l : List α}  (pa : ¬p a) : a ∈ l.eraseP p ↔ a ∈ l",
  "args": "{l : List α}  (pa : ¬p a)"},
 {"type": "extractP p l = (find? p l, eraseP p l)",
  "tactic-prompt":
  "theorem (l : List α) : extractP p l = (find? p l, eraseP p l) := by let rec go (acc) : ∀ xs, l = acc.data ++ xs →\n    extractP.go p l xs acc = (xs.find? p, acc.data ++ xs.eraseP p)\n  | [] => fun h => by simp [extractP.go, find?, eraseP, h]\n  | x::xs => by\n    simp [extractP.go, find?, eraseP]; cases p x; sorry",
  "name": "extractP_eq_find?_eraseP",
  "kind": "theorem",
  "first-tactic":
  "let rec go (acc) : ∀ xs, l = acc.data ++ xs →\n    extractP.go p l xs acc = (xs.find? p, acc.data ++ xs.eraseP p)\n  | [] => fun h => by simp [extractP.go, find?, eraseP, h]\n  | x::xs => by\n    simp [extractP.go, find?, eraseP]; cases p x",
  "core-prompt": "(l : List α) : extractP p l = (find? p l, eraseP p l)",
  "args": "(l : List α)"},
 {"type": "(a :: l).erase a = l",
  "tactic-prompt":
  "theorem [DecidableEq α] (a : α)  (l : List α) : (a :: l).erase a = l := by simp [erase_cons]; sorry",
  "name": "erase_cons_head",
  "kind": "theorem",
  "first-tactic": "simp [erase_cons]",
  "core-prompt": "[DecidableEq α] (a : α)  (l : List α) : (a :: l).erase a = l",
  "args": "[DecidableEq α] (a : α)  (l : List α)"},
 {"type": "(b :: l).erase a = b :: l.erase a",
  "tactic-prompt":
  "theorem [DecidableEq α] {a b : α}  (l : List α)  (h : b ≠ a) : (b :: l).erase a = b :: l.erase a := by simp only [erase_cons]; sorry",
  "name": "erase_cons_tail",
  "kind": "theorem",
  "first-tactic": "simp only [erase_cons]",
  "core-prompt":
  "[DecidableEq α] {a b : α}  (l : List α)  (h : b ≠ a) : (b :: l).erase a = b :: l.erase a",
  "args": "[DecidableEq α] {a b : α}  (l : List α)  (h : b ≠ a)"},
 {"type": "∃ l₁ l₂, a ∉ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.erase a = l₁ ++ l₂",
  "tactic-prompt":
  "theorem [DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l) : ∃ l₁ l₂, a ∉ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.erase a = l₁ ++ l₂ := by let ⟨_, l₁, l₂, h₁, e, h₂, h₃⟩ := exists_of_eraseP h (beq_self_eq_true _); sorry",
  "name": "exists_erase_eq",
  "kind": "theorem",
  "first-tactic":
  "let ⟨_, l₁, l₂, h₁, e, h₂, h₃⟩ := exists_of_eraseP h (beq_self_eq_true _)",
  "core-prompt":
  "[DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l) : ∃ l₁ l₂, a ∉ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.erase a = l₁ ++ l₂",
  "args": "[DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "length (l.erase a) = Nat.pred (length l)",
  "tactic-prompt":
  "theorem [DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l) : length (l.erase a) = Nat.pred (length l) := by rw [erase_eq_eraseP]; sorry",
  "name": "length_erase_of_mem",
  "kind": "theorem",
  "first-tactic": "rw [erase_eq_eraseP]",
  "core-prompt":
  "[DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l) : length (l.erase a) = Nat.pred (length l)",
  "args": "[DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "(l₁ ++ l₂).erase a = (l₁ ++ l₂.erase a)",
  "tactic-prompt":
  "theorem [DecidableEq α] {a : α}  {l₁ : List α}  (l₂ : List α)  (h : a ∉ l₁) : (l₁ ++ l₂).erase a = (l₁ ++ l₂.erase a) := by rw [erase_eq_eraseP]; sorry",
  "name": "erase_append_right",
  "kind": "theorem",
  "first-tactic": "rw [erase_eq_eraseP]",
  "core-prompt":
  "[DecidableEq α] {a : α}  {l₁ : List α}  (l₂ : List α)  (h : a ∉ l₁) : (l₁ ++ l₂).erase a = (l₁ ++ l₂.erase a)",
  "args":
  "[DecidableEq α] {a : α}  {l₁ : List α}  (l₂ : List α)  (h : a ∉ l₁)"},
 {"type": "(l.erase a).erase b = (l.erase b).erase a",
  "tactic-prompt":
  "theorem [DecidableEq α] (a b : α)  (l : List α) : (l.erase a).erase b = (l.erase b).erase a := by if ab : a = b then rw [ab] else ?_; sorry",
  "name": "erase_comm",
  "kind": "theorem",
  "first-tactic": "if ab : a = b then rw [ab] else ?_",
  "core-prompt":
  "[DecidableEq α] (a b : α)  (l : List α) : (l.erase a).erase b = (l.erase b).erase a",
  "args": "[DecidableEq α] (a b : α)  (l : List α)"},
 {"type": "x ∈ filter p as ↔ x ∈ as ∧ p x",
  "tactic-prompt":
  "theorem  : x ∈ filter p as ↔ x ∈ as ∧ p x := by induction as; sorry",
  "name": "mem_filter",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt": " : x ∈ filter p as ↔ x ∈ as ∧ p x",
  "args": ""},
 {"type": "partition p l = (filter p l, filter (not ∘ p) l)",
  "tactic-prompt":
  "theorem (p : α → Bool)  (l : List α) : partition p l = (filter p l, filter (not ∘ p) l) := by simp [partition]; sorry",
  "name": "partition_eq_filter_filter",
  "kind": "theorem",
  "first-tactic": "simp [partition]",
  "core-prompt":
  "(p : α → Bool)  (l : List α) : partition p l = (filter p l, filter (not ∘ p) l)",
  "args": "(p : α → Bool)  (l : List α)"},
 {"type": "(l.map f).Pairwise R ↔ l.Pairwise (fun a b => R (f a) (f b))",
  "tactic-prompt":
  "theorem {l : List α} : (l.map f).Pairwise R ↔ l.Pairwise (fun a b => R (f a) (f b)) := by induction l; sorry",
  "name": "pairwise_map",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{l : List α} : (l.map f).Pairwise R ↔ l.Pairwise (fun a b => R (f a) (f b))",
  "args": "{l : List α}"},
 {"type":
  "(l₁ ++ l₂).Pairwise R ↔ l₁.Pairwise R ∧ l₂.Pairwise R ∧ ∀ a ∈ l₁, ∀ b ∈ l₂, R a b",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α} : (l₁ ++ l₂).Pairwise R ↔ l₁.Pairwise R ∧ l₂.Pairwise R ∧ ∀ a ∈ l₁, ∀ b ∈ l₂, R a b := by induction l₁; sorry",
  "name": "pairwise_append",
  "kind": "theorem",
  "first-tactic": "induction l₁",
  "core-prompt":
  "{l₁ l₂ : List α} : (l₁ ++ l₂).Pairwise R ↔ l₁.Pairwise R ∧ l₂.Pairwise R ∧ ∀ a ∈ l₁, ∀ b ∈ l₂, R a b",
  "args": "{l₁ l₂ : List α}"},
 {"type": "l.reverse.Pairwise R ↔ l.Pairwise (fun a b => R b a)",
  "tactic-prompt":
  "theorem {l : List α} : l.reverse.Pairwise R ↔ l.Pairwise (fun a b => R b a) := by induction l; sorry",
  "name": "pairwise_reverse",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{l : List α} : l.reverse.Pairwise R ↔ l.Pairwise (fun a b => R b a)",
  "args": "{l : List α}"},
 {"type": "length (replaceF f l) = length l",
  "tactic-prompt":
  "theorem  : length (replaceF f l) = length l := by induction l; sorry",
  "name": "length_replaceF",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": " : length (replaceF f l) = length l",
  "args": ""},
 {"type": "Disjoint l₁ l₂ ↔ ∀ ⦃a⦄, a ∈ l₁ → a ∉ l₂",
  "tactic-prompt":
  "theorem  : Disjoint l₁ l₂ ↔ ∀ ⦃a⦄, a ∈ l₁ → a ∉ l₂ := by simp [Disjoint]; sorry",
  "name": "disjoint_left",
  "kind": "theorem",
  "first-tactic": "simp [Disjoint]",
  "core-prompt": " : Disjoint l₁ l₂ ↔ ∀ ⦃a⦄, a ∈ l₁ → a ∉ l₂",
  "args": ""},
 {"type": "Disjoint l []",
  "tactic-prompt":
  "theorem (l : List α) : Disjoint l [] := by rw [disjoint_comm]; sorry",
  "name": "disjoint_nil_right",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_comm]",
  "core-prompt": "(l : List α) : Disjoint l []",
  "args": "(l : List α)"},
 {"type": "Disjoint [a] l ↔ a ∉ l",
  "tactic-prompt":
  "theorem  : Disjoint [a] l ↔ a ∉ l := by simp [Disjoint]; sorry",
  "name": "singleton_disjoint",
  "kind": "theorem",
  "first-tactic": "simp [Disjoint]",
  "core-prompt": " : Disjoint [a] l ↔ a ∉ l",
  "args": ""},
 {"type": "Disjoint l [a] ↔ a ∉ l",
  "tactic-prompt":
  "theorem  : Disjoint l [a] ↔ a ∉ l := by rw [disjoint_comm]; sorry",
  "name": "disjoint_singleton",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_comm]",
  "core-prompt": " : Disjoint l [a] ↔ a ∉ l",
  "args": ""},
 {"type": "Disjoint (l₁ ++ l₂) l ↔ Disjoint l₁ l ∧ Disjoint l₂ l",
  "tactic-prompt":
  "theorem  : Disjoint (l₁ ++ l₂) l ↔ Disjoint l₁ l ∧ Disjoint l₂ l := by simp [Disjoint]; sorry",
  "name": "disjoint_append_left",
  "kind": "theorem",
  "first-tactic": "simp [Disjoint]",
  "core-prompt": " : Disjoint (l₁ ++ l₂) l ↔ Disjoint l₁ l ∧ Disjoint l₂ l",
  "args": ""},
 {"type": "(l.map f).foldl g init = l.foldl (fun x y => g x (f y)) init",
  "tactic-prompt":
  "theorem (f : β₁ → β₂)  (g : α → β₂ → α)  (l : List β₁)  (init : α) : (l.map f).foldl g init = l.foldl (fun x y => g x (f y)) init := by induction l generalizing init; sorry",
  "name": "foldl_map",
  "kind": "theorem",
  "first-tactic": "induction l generalizing init",
  "core-prompt":
  "(f : β₁ → β₂)  (g : α → β₂ → α)  (l : List β₁)  (init : α) : (l.map f).foldl g init = l.foldl (fun x y => g x (f y)) init",
  "args": "(f : β₁ → β₂)  (g : α → β₂ → α)  (l : List β₁)  (init : α)"},
 {"type": "(l.map f).foldr g init = l.foldr (fun x y => g (f x) y) init",
  "tactic-prompt":
  "theorem (f : α₁ → α₂)  (g : α₂ → β → β)  (l : List α₁)  (init : β) : (l.map f).foldr g init = l.foldr (fun x y => g (f x) y) init := by induction l generalizing init; sorry",
  "name": "foldr_map",
  "kind": "theorem",
  "first-tactic": "induction l generalizing init",
  "core-prompt":
  "(f : α₁ → α₂)  (g : α₂ → β → β)  (l : List α₁)  (init : β) : (l.map f).foldr g init = l.foldr (fun x y => g (f x) y) init",
  "args": "(f : α₁ → α₂)  (g : α₂ → β → β)  (l : List α₁)  (init : β)"},
 {"type": "l.foldl g₂ (f init) = f (l.foldl g₁ init)",
  "tactic-prompt":
  "theorem (f : α₁ → α₂)  (g₁ : α₁ → β → α₁)  (g₂ : α₂ → β → α₂)  (l : List β)  (init : α₁)      (H : ∀ x y, g₂ (f x) y = f (g₁ x y)) : l.foldl g₂ (f init) = f (l.foldl g₁ init) := by induction l generalizing init; sorry",
  "name": "foldl_hom",
  "kind": "theorem",
  "first-tactic": "induction l generalizing init",
  "core-prompt":
  "(f : α₁ → α₂)  (g₁ : α₁ → β → α₁)  (g₂ : α₂ → β → α₂)  (l : List β)  (init : α₁)      (H : ∀ x y, g₂ (f x) y = f (g₁ x y)) : l.foldl g₂ (f init) = f (l.foldl g₁ init)",
  "args":
  "(f : α₁ → α₂)  (g₁ : α₁ → β → α₁)  (g₂ : α₂ → β → α₂)  (l : List β)  (init : α₁)      (H : ∀ x y, g₂ (f x) y = f (g₁ x y))"},
 {"type": "l.foldr g₂ (f init) = f (l.foldr g₁ init)",
  "tactic-prompt":
  "theorem (f : β₁ → β₂)  (g₁ : α → β₁ → β₁)  (g₂ : α → β₂ → β₂)  (l : List α)  (init : β₁)      (H : ∀ x y, g₂ x (f y) = f (g₁ x y)) : l.foldr g₂ (f init) = f (l.foldr g₁ init) := by induction l; sorry",
  "name": "foldr_hom",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : β₁ → β₂)  (g₁ : α → β₁ → β₁)  (g₂ : α → β₂ → β₂)  (l : List α)  (init : β₁)      (H : ∀ x y, g₂ x (f y) = f (g₁ x y)) : l.foldr g₂ (f init) = f (l.foldr g₁ init)",
  "args":
  "(f : β₁ → β₂)  (g₁ : α → β₁ → β₁)  (g₂ : α → β₂ → β₂)  (l : List α)  (init : β₁)      (H : ∀ x y, g₂ x (f y) = f (g₁ x y))"},
 {"type": "nil.union l = l",
  "tactic-prompt":
  "theorem [DecidableEq α] (l : List α) : nil.union l = l := by simp [List.union]; sorry",
  "name": "nil_union",
  "kind": "theorem",
  "first-tactic": "simp [List.union]",
  "core-prompt": "[DecidableEq α] (l : List α) : nil.union l = l",
  "args": "[DecidableEq α] (l : List α)"},
 {"type": "(a :: l₁).union l₂ = (l₁.union l₂).insert a",
  "tactic-prompt":
  "theorem [DecidableEq α] (a : α)  (l₁ l₂ : List α) : (a :: l₁).union l₂ = (l₁.union l₂).insert a := by simp [List.union]; sorry",
  "name": "cons_union",
  "kind": "theorem",
  "first-tactic": "simp [List.union]",
  "core-prompt":
  "[DecidableEq α] (a : α)  (l₁ l₂ : List α) : (a :: l₁).union l₂ = (l₁.union l₂).insert a",
  "args": "[DecidableEq α] (a : α)  (l₁ l₂ : List α)"},
 {"type": "x ∈ l₁.union l₂ ↔ x ∈ l₁ ∨ x ∈ l₂",
  "tactic-prompt":
  "theorem [DecidableEq α] [DecidableEq α]  {x : α}  {l₁ l₂ : List α} : x ∈ l₁.union l₂ ↔ x ∈ l₁ ∨ x ∈ l₂ := by induction l₁; sorry",
  "name": "mem_union_iff",
  "kind": "theorem",
  "first-tactic": "induction l₁",
  "core-prompt":
  "[DecidableEq α] [DecidableEq α]  {x : α}  {l₁ l₂ : List α} : x ∈ l₁.union l₂ ↔ x ∈ l₁ ∨ x ∈ l₂",
  "args": "[DecidableEq α] [DecidableEq α]  {x : α}  {l₁ l₂ : List α}"},
 {"type": "x ∈ l₁.inter l₂ ↔ x ∈ l₁ ∧ x ∈ l₂",
  "tactic-prompt":
  "theorem [DecidableEq α]  {x : α}  {l₁ l₂ : List α} : x ∈ l₁.inter l₂ ↔ x ∈ l₁ ∧ x ∈ l₂ := by cases l₁; sorry",
  "name": "mem_inter_iff",
  "kind": "theorem",
  "first-tactic": "cases l₁",
  "core-prompt":
  "[DecidableEq α]  {x : α}  {l₁ l₂ : List α} : x ∈ l₁.inter l₂ ↔ x ∈ l₁ ∧ x ∈ l₂",
  "args": "[DecidableEq α]  {x : α}  {l₁ l₂ : List α}"},
 {"type": "(x, y) ∈ product xs ys ↔ x ∈ xs ∧ y ∈ ys",
  "tactic-prompt":
  "theorem {xs : List α}  {ys : List β}  {x : α}  {y : β} : (x, y) ∈ product xs ys ↔ x ∈ xs ∧ y ∈ ys := by simp only [List.product]; sorry",
  "name": "pair_mem_product",
  "kind": "theorem",
  "first-tactic": "simp only [List.product]",
  "core-prompt":
  "{xs : List α}  {ys : List β}  {x : α}  {y : β} : (x, y) ∈ product xs ys ↔ x ∈ xs ∧ y ∈ ys",
  "args": "{xs : List α}  {ys : List β}  {x : α}  {y : β}"},
 {"type": "(leftpad n a l).length = max n l.length",
  "tactic-prompt":
  "theorem (n : Nat)  (a : α)  (l : List α) : (leftpad n a l).length = max n l.length := by simp only [leftpad]; sorry",
  "name": "leftpad_length",
  "kind": "theorem",
  "first-tactic": "simp only [leftpad]",
  "core-prompt":
  "(n : Nat)  (a : α)  (l : List α) : (leftpad n a l).length = max n l.length",
  "args": "(n : Nat)  (a : α)  (l : List α)"},
 {"type": "isPrefix (replicate (n - length l) a) (leftpad n a l)",
  "tactic-prompt":
  "theorem (n : Nat)  (a : α)  (l : List α) : isPrefix (replicate (n - length l) a) (leftpad n a l) := by simp only [isPrefix]; sorry",
  "name": "leftpad_prefix",
  "kind": "theorem",
  "first-tactic": "simp only [isPrefix]",
  "core-prompt":
  "(n : Nat)  (a : α)  (l : List α) : isPrefix (replicate (n - length l) a) (leftpad n a l)",
  "args": "(n : Nat)  (a : α)  (l : List α)"},
 {"type": "isSuffix l (leftpad n a l)",
  "tactic-prompt":
  "theorem (n : Nat)  (a : α)  (l : List α) : isSuffix l (leftpad n a l) := by simp only [isSuffix]; sorry",
  "name": "leftpad_suffix",
  "kind": "theorem",
  "first-tactic": "simp only [isSuffix]",
  "core-prompt":
  "(n : Nat)  (a : α)  (l : List α) : isSuffix l (leftpad n a l)",
  "args": "(n : Nat)  (a : α)  (l : List α)"},
 {"type":
  "forIn l init f = ForInStep.run <$> (ForInStep.yield init).bindList f l",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]      (f : α → β → m (ForInStep β))  (l : List α)  (init : β) : forIn l init f = ForInStep.run <$> (ForInStep.yield init).bindList f l := by induction l generalizing init; sorry",
  "name": "forIn_eq_bindList",
  "kind": "theorem",
  "first-tactic": "induction l generalizing init",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]      (f : α → β → m (ForInStep β))  (l : List α)  (init : β) : forIn l init f = ForInStep.run <$> (ForInStep.yield init).bindList f l",
  "args":
  "[Monad m]  [LawfulMonad m]      (f : α → β → m (ForInStep β))  (l : List α)  (init : β)"},
 {"type": "(l₁ ++ l₂).forM f = (do l₁.forM f; l₂.forM f)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (l₁ l₂ : List α)  (f : α → m PUnit) : (l₁ ++ l₂).forM f = (do l₁.forM f; l₂.forM f) := by induction l₁; sorry",
  "name": "forM_append",
  "kind": "theorem",
  "first-tactic": "induction l₁",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (l₁ l₂ : List α)  (f : α → m PUnit) : (l₁ ++ l₂).forM f = (do l₁.forM f; l₂.forM f)",
  "args": "[Monad m]  [LawfulMonad m]  (l₁ l₂ : List α)  (f : α → m PUnit)"},
 {"type": "some a = some b ↔ a = b",
  "tactic-prompt":
  "theorem {a b : α} : some a = some b ↔ a = b := by simp; sorry",
  "name": "some_inj",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "{a b : α} : some a = some b ↔ a = b",
  "args": "{a b : α}"},
 {"type": "some (x.getD y) = x",
  "tactic-prompt":
  "theorem {x : Option α}  (hx : x ≠ none)  (y : α) : some (x.getD y) = x := by cases x; sorry",
  "name": "getD_of_ne_none",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{x : Option α}  (hx : x ≠ none)  (y : α) : some (x.getD y) = x",
  "args": "{x : Option α}  (hx : x ≠ none)  (y : α)"},
 {"type": "isSome x ↔ ∃ a, x = some a",
  "tactic-prompt": "theorem  : isSome x ↔ ∃ a, x = some a := by cases x; sorry",
  "name": "isSome_iff_exists",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": " : isSome x ↔ ∃ a, x = some a",
  "args": ""},
 {"type": "isSome a = false ↔ a.isNone = true",
  "tactic-prompt":
  "theorem  : isSome a = false ↔ a.isNone = true := by cases a; sorry",
  "name": "not_isSome",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": " : isSome a = false ↔ a.isNone = true",
  "args": ""},
 {"type": "o = some a ↔ ∃ h : o.isSome, o.get h = a",
  "tactic-prompt":
  "theorem  : o = some a ↔ ∃ h : o.isSome, o.get h = a := by cases o; sorry",
  "name": "eq_some_iff_get_eq",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": " : o = some a ↔ ∃ h : o.isSome, o.get h = a",
  "args": ""},
 {"type": "¬o.isSome ↔ o = none",
  "tactic-prompt": "theorem  : ¬o.isSome ↔ o = none := by cases o; sorry",
  "name": "not_isSome_iff_eq_none",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": " : ¬o.isSome ↔ o = none",
  "args": ""},
 {"type": "o ≠ none ↔ o.isSome",
  "tactic-prompt": "theorem  : o ≠ none ↔ o.isSome := by cases o; sorry",
  "name": "ne_none_iff_isSome",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": " : o ≠ none ↔ o.isSome",
  "args": ""},
 {"type": "o ≠ none ↔ ∃ x, some x = o",
  "tactic-prompt": "theorem  : o ≠ none ↔ ∃ x, some x = o := by cases o; sorry",
  "name": "ne_none_iff_exists",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": " : o ≠ none ↔ ∃ x, some x = o",
  "args": ""},
 {"type": "x.bind some = x",
  "tactic-prompt":
  "theorem (x : Option α) : x.bind some = x := by cases x; sorry",
  "name": "bind_some",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": "(x : Option α) : x.bind some = x",
  "args": "(x : Option α)"},
 {"type": "x.bind f = some b ↔ ∃ a, x = some a ∧ f a = some b",
  "tactic-prompt":
  "theorem  : x.bind f = some b ↔ ∃ a, x = some a ∧ f a = some b := by cases x; sorry",
  "name": "bind_eq_some",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": " : x.bind f = some b ↔ ∃ a, x = some a ∧ f a = some b",
  "args": ""},
 {"type": "o.bind f = none ↔ ∀ b a, a ∈ o → b ∉ f a",
  "tactic-prompt":
  "theorem {o : Option α}  {f : α → Option β} : o.bind f = none ↔ ∀ b a, a ∈ o → b ∉ f a := by simp only [eq_none_iff_forall_not_mem]; sorry",
  "name": "bind_eq_none",
  "kind": "theorem",
  "first-tactic": "simp only [eq_none_iff_forall_not_mem]",
  "core-prompt":
  "{o : Option α}  {f : α → Option β} : o.bind f = none ↔ ∀ b a, a ∈ o → b ∉ f a",
  "args": "{o : Option α}  {f : α → Option β}"},
 {"type":
  "(a.bind fun x => b.bind (f x)) = b.bind fun y => a.bind fun x => f x y",
  "tactic-prompt":
  "theorem {f : α → β → Option γ}  (a : Option α)  (b : Option β) : (a.bind fun x => b.bind (f x)) = b.bind fun y => a.bind fun x => f x y := by cases a; sorry",
  "name": "bind_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → Option γ}  (a : Option α)  (b : Option β) : (a.bind fun x => b.bind (f x)) = b.bind fun y => a.bind fun x => f x y",
  "args": "{f : α → β → Option γ}  (a : Option α)  (b : Option β)"},
 {"type": "(x.bind f).bind g = x.bind fun y => (f y).bind g",
  "tactic-prompt":
  "theorem (x : Option α)  (f : α → Option β)  (g : β → Option γ) : (x.bind f).bind g = x.bind fun y => (f y).bind g := by cases x; sorry",
  "name": "bind_assoc",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "(x : Option α)  (f : α → Option β)  (g : β → Option γ) : (x.bind f).bind g = x.bind fun y => (f y).bind g",
  "args": "(x : Option α)  (f : α → Option β)  (g : β → Option γ)"},
 {"type": "x.join = some a ↔ x = some (some a)",
  "tactic-prompt":
  "theorem  : x.join = some a ↔ x = some (some a) := by simp; sorry",
  "name": "join_eq_some",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : x.join = some a ↔ x = some (some a)",
  "args": ""},
 {"type": "x.join ≠ none ↔ ∃ z, x = some (some z)",
  "tactic-prompt":
  "theorem  : x.join ≠ none ↔ ∃ z, x = some (some z) := by simp only [ne_none_iff_exists']; sorry",
  "name": "join_ne_none",
  "kind": "theorem",
  "first-tactic": "simp only [ne_none_iff_exists']",
  "core-prompt": " : x.join ≠ none ↔ ∃ z, x = some (some z)",
  "args": ""},
 {"type": "x.map f = some b ↔ ∃ a, x = some a ∧ f a = b",
  "tactic-prompt":
  "theorem  : x.map f = some b ↔ ∃ a, x = some a ∧ f a = b := by cases x; sorry",
  "name": "map_eq_some'",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": " : x.map f = some b ↔ ∃ a, x = some a ∧ f a = b",
  "args": ""},
 {"type": "x.map f = none ↔ x = none",
  "tactic-prompt": "theorem  : x.map f = none ↔ x = none := by cases x; sorry",
  "name": "map_eq_none'",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": " : x.map f = none ↔ x = none",
  "args": ""},
 {"type": "x.map f = x.map g",
  "tactic-prompt":
  "theorem {x : Option α}  (h : ∀ a ∈ x, f a = g a) : x.map f = x.map g := by cases x; sorry",
  "name": "map_congr",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": "{x : Option α}  (h : ∀ a ∈ x, f a = g a) : x.map f = x.map g",
  "args": "{x : Option α}  (h : ∀ a ∈ x, f a = g a)"},
 {"type": "(x.map g).map h = x.map (h ∘ g)",
  "tactic-prompt":
  "theorem (h : β → γ)  (g : α → β)  (x : Option α) : (x.map g).map h = x.map (h ∘ g) := by cases x; sorry",
  "name": "map_map",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "(h : β → γ)  (g : α → β)  (x : Option α) : (x.map g).map h = x.map (h ∘ g)",
  "args": "(h : β → γ)  (g : α → β)  (x : Option α)"},
 {"type": "Option.map g ∘ Option.map f = Option.map (g ∘ f)",
  "tactic-prompt":
  "theorem (f : α → β)  (g : β → γ) : Option.map g ∘ Option.map f = Option.map (g ∘ f) := by funext x; sorry",
  "name": "map_comp_map",
  "kind": "theorem",
  "first-tactic": "funext x",
  "core-prompt":
  "(f : α → β)  (g : β → γ) : Option.map g ∘ Option.map f = Option.map (g ∘ f)",
  "args": "(f : α → β)  (g : β → γ)"},
 {"type": "(x.map (Option.map f)).join = x.join.map f",
  "tactic-prompt":
  "theorem {f : α → β}  {x : Option (Option α)} : (x.map (Option.map f)).join = x.join.map f := by cases x; sorry",
  "name": "join_map_eq_map_join",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{f : α → β}  {x : Option (Option α)} : (x.map (Option.map f)).join = x.join.map f",
  "args": "{f : α → β}  {x : Option (Option α)}"},
 {"type": "x.join.join = (x.map join).join",
  "tactic-prompt":
  "theorem {x : Option (Option (Option α))} : x.join.join = (x.map join).join := by cases x; sorry",
  "name": "join_join",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{x : Option (Option (Option α))} : x.join.join = (x.map join).join",
  "args": "{x : Option (Option (Option α))}"},
 {"type": "(x <|> none) = x",
  "tactic-prompt":
  "theorem (x : Option α) : (x <|> none) = x := by cases x; sorry",
  "name": "orElse_none",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": "(x : Option α) : (x <|> none) = x",
  "args": "(x : Option α)"},
 {"type": "guard p a = some b ↔ a = b ∧ p a",
  "tactic-prompt":
  "theorem [DecidablePred p] : guard p a = some b ↔ a = b ∧ p a := by by_cases h : p a; sorry",
  "name": "guard_eq_some",
  "kind": "theorem",
  "first-tactic": "by_cases h : p a",
  "core-prompt": "[DecidablePred p] : guard p a = some b ↔ a = b ∧ p a",
  "args": "[DecidablePred p]"},
 {"type": "(o.map f).getD (f x) = f (getD o x)",
  "tactic-prompt":
  "theorem (f : α → β)  (x : α)  (o : Option α) : (o.map f).getD (f x) = f (getD o x) := by cases o; sorry",
  "name": "getD_map",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "(f : α → β)  (x : α)  (o : Option α) : (o.map f).getD (f x) = f (getD o x)",
  "args": "(f : α → β)  (x : α)  (o : Option α)"},
 {"type": "choice α = some a",
  "tactic-prompt":
  "theorem {α : Type _}  [Subsingleton α]  (a : α) : choice α = some a := by simp [choice]; sorry",
  "name": "choice_eq",
  "kind": "theorem",
  "first-tactic": "simp [choice]",
  "core-prompt": "{α : Type _}  [Subsingleton α]  (a : α) : choice α = some a",
  "args": "{α : Type _}  [Subsingleton α]  (a : α)"},
 {"type": "s'.NoSibling",
  "tactic-prompt":
  "theorem {s : Heap α}  (eq : s.deleteMin le = some (a, s')) : s'.NoSibling := by cases s; sorry",
  "name": "Heap.noSibling_deleteMin",
  "kind": "theorem",
  "first-tactic": "cases s",
  "core-prompt":
  "{s : Heap α}  (eq : s.deleteMin le = some (a, s')) : s'.NoSibling",
  "args": "{s : Heap α}  (eq : s.deleteMin le = some (a, s'))"},
 {"type": "s.tail? le = some s' →\n    s'.NoSibling",
  "tactic-prompt":
  "theorem {s : Heap α} : s.tail? le = some s' →\n    s'.NoSibling := by simp only [Heap.tail?]; sorry",
  "name": "Heap.noSibling_tail?",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail?]",
  "core-prompt": "{s : Heap α} : s.tail? le = some s' →\n    s'.NoSibling",
  "args": "{s : Heap α}"},
 {"type": "s.size = s'.size + 1",
  "tactic-prompt":
  "theorem {s : Heap α}  (h : s.NoSibling)  (eq : s.deleteMin le = some (a, s')) : s.size = s'.size + 1 := by cases h; sorry",
  "name": "Heap.size_deleteMin",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{s : Heap α}  (h : s.NoSibling)  (eq : s.deleteMin le = some (a, s')) : s.size = s'.size + 1",
  "args":
  "{s : Heap α}  (h : s.NoSibling)  (eq : s.deleteMin le = some (a, s'))"},
 {"type": "s.tail? le = some s' →\n    s.size = s'.size + 1",
  "tactic-prompt":
  "theorem {s : Heap α}  (h : s.NoSibling) : s.tail? le = some s' →\n    s.size = s'.size + 1 := by simp only [Heap.tail?]; sorry",
  "name": "Heap.size_tail?",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail?]",
  "core-prompt":
  "{s : Heap α}  (h : s.NoSibling) : s.tail? le = some s' →\n    s.size = s'.size + 1",
  "args": "{s : Heap α}  (h : s.NoSibling)"},
 {"type": "s'.size < s.size",
  "tactic-prompt":
  "theorem {s : Heap α}  (eq : s.deleteMin le = some (a, s')) : s'.size < s.size := by cases s; sorry",
  "name": "Heap.size_deleteMin_lt",
  "kind": "theorem",
  "first-tactic": "cases s",
  "core-prompt":
  "{s : Heap α}  (eq : s.deleteMin le = some (a, s')) : s'.size < s.size",
  "args": "{s : Heap α}  (eq : s.deleteMin le = some (a, s'))"},
 {"type": "s.tail? le = some s' →\n    s'.size < s.size",
  "tactic-prompt":
  "theorem {s : Heap α} : s.tail? le = some s' →\n    s'.size < s.size := by simp only [Heap.tail?]; sorry",
  "name": "Heap.size_tail?_lt",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail?]",
  "core-prompt": "{s : Heap α} : s.tail? le = some s' →\n    s'.size < s.size",
  "args": "{s : Heap α}"},
 {"type": "(merge le (.node a₁ c₁ s₁) (.node a₂ c₂ s₂)).WF le",
  "tactic-prompt":
  "theorem (h₁ : NodeWF le a₁ c₁)  (h₂ : NodeWF le a₂ c₂) : (merge le (.node a₁ c₁ s₁) (.node a₂ c₂ s₂)).WF le := by unfold merge; sorry",
  "name": "Heap.WF.merge_node",
  "kind": "theorem",
  "first-tactic": "unfold merge",
  "core-prompt":
  "(h₁ : NodeWF le a₁ c₁)  (h₂ : NodeWF le a₂ c₂) : (merge le (.node a₁ c₁ s₁) (.node a₂ c₂ s₂)).WF le",
  "args": "(h₁ : NodeWF le a₁ c₁)  (h₂ : NodeWF le a₂ c₂)"},
 {"type": "s'.WF le",
  "tactic-prompt":
  "theorem {s : Heap α}  (h : s.WF le)      (eq : s.deleteMin le = some (a, s')) : s'.WF le := by cases h; sorry",
  "name": "Heap.WF.deleteMin",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{s : Heap α}  (h : s.WF le)      (eq : s.deleteMin le = some (a, s')) : s'.WF le",
  "args":
  "{s : Heap α}  (h : s.WF le)      (eq : s.deleteMin le = some (a, s'))"},
 {"type": "s.tail? le = some tl →\n  tl.WF le",
  "tactic-prompt":
  "theorem (hwf : (s : Heap α).WF le) : s.tail? le = some tl →\n  tl.WF le := by simp only [Heap.tail?]; sorry",
  "name": "Heap.WF.tail?",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail?]",
  "core-prompt":
  "(hwf : (s : Heap α).WF le) : s.tail? le = some tl →\n  tl.WF le",
  "args": "(hwf : (s : Heap α).WF le)"},
 {"type": "(s.tail le).WF le",
  "tactic-prompt":
  "theorem (hwf : (s : Heap α).WF le) : (s.tail le).WF le := by simp only [Heap.tail]; sorry",
  "name": "Heap.WF.tail",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail]",
  "core-prompt": "(hwf : (s : Heap α).WF le) : (s.tail le).WF le",
  "args": "(hwf : (s : Heap α).WF le)"},
 {"type": "Inhabited RuleTac",
  "tactic-prompt": "instance  : Inhabited RuleTac := by unfold RuleTac; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "unfold RuleTac",
  "core-prompt": " : Inhabited RuleTac",
  "args": ""},
 {"type": "NatOrBool",
  "tactic-prompt":
  "def (b : Bool) : NatOrBool := by aesop (rule_sets [persistence1]); sorry",
  "name": "test",
  "kind": "def",
  "first-tactic": "aesop (rule_sets [persistence1])",
  "core-prompt": "(b : Bool) : NatOrBool",
  "args": "(b : Bool)"},
 {"type": "NatOrBool",
  "tactic-prompt":
  "example (b : Bool) : NatOrBool := by aesop (rule_sets [persistence1]); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (rule_sets [persistence1])",
  "core-prompt": "(b : Bool) : NatOrBool",
  "args": "(b : Bool)"},
 {"type": "∃ (i : Nat), T i",
  "tactic-prompt": "example  : ∃ (i : Nat), T i := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : ∃ (i : Nat), T i",
  "args": ""},
 {"type": "∃ i, U i ∧ i = 1",
  "tactic-prompt": "example  : ∃ i, U i ∧ i = 1 := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : ∃ i, U i ∧ i = 1",
  "args": ""},
 {"type": "I₁",
  "tactic-prompt": "example  : I₁ := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : I₁",
  "args": ""},
 {"type": "I₁",
  "tactic-prompt":
  "example  : I₁ := by aesop (options := { strategy := .bestFirst }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (options := { strategy := .bestFirst })",
  "core-prompt": " : I₁",
  "args": ""},
 {"type": "I₁",
  "tactic-prompt":
  "example  : I₁ := by aesop (options := { strategy := .breadthFirst }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (options := { strategy := .breadthFirst })",
  "core-prompt": " : I₁",
  "args": ""},
 {"type": "I₁",
  "tactic-prompt":
  "example  : I₁ := by fail_if_success\n    aesop (options :=\n      { strategy := .depthFirst,\n        maxRuleApplicationDepth := 0,\n        maxRuleApplications := 10,\n        terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success\n    aesop (options :=\n      { strategy := .depthFirst,\n        maxRuleApplicationDepth := 0,\n        maxRuleApplications := 10,\n        terminal := true })",
  "core-prompt": " : I₁",
  "args": ""},
 {"type": "Injective₁ (@id Nat)",
  "tactic-prompt":
  "example  : Injective₁ (@id Nat) := by fail_if_success aesop (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop (options := { terminal := true })",
  "core-prompt": " : Injective₁ (@id Nat)",
  "args": ""},
 {"type": "Injective₂ (@id Nat)",
  "tactic-prompt":
  "example  : Injective₂ (@id Nat) := by fail_if_success aesop (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop (options := { terminal := true })",
  "core-prompt": " : Injective₂ (@id Nat)",
  "args": ""},
 {"type": "Injective₂ (@id Nat)",
  "tactic-prompt":
  "example  : Injective₂ (@id Nat) := by aesop (options := { introsTransparency? := some .default }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (options := { introsTransparency? := some .default })",
  "core-prompt": " : Injective₂ (@id Nat)",
  "args": ""},
 {"type": "α",
  "tactic-prompt":
  "example (h : α) : α := by fail_if_success\n    aesop (rule_sets [-builtin]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    aesop (rule_sets [-builtin]",
  "core-prompt": "(h : α) : α",
  "args": "(h : α)"},
 {"type": "A",
  "tactic-prompt":
  "example  : A := by fail_if_success aesop (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop (options := { terminal := true })",
  "core-prompt": " : A",
  "args": ""},
 {"type": "B",
  "tactic-prompt": "example  : B := by aesop (rule_sets [A]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (rule_sets [A]",
  "core-prompt": " : B",
  "args": ""},
 {"type": "C",
  "tactic-prompt":
  "example  : C := by fail_if_success aesop (rule_sets [-default]) (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success aesop (rule_sets [-default]) (options := { terminal := true })",
  "core-prompt": " : C",
  "args": ""},
 {"type": "C",
  "tactic-prompt":
  "example  : C := by fail_if_success aesop (rule_sets [C]) (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success aesop (rule_sets [C]) (options := { terminal := true })",
  "core-prompt": " : C",
  "args": ""},
 {"type": "D",
  "tactic-prompt": "example  : D := by aesop (rule_sets [A]); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (rule_sets [A])",
  "core-prompt": " : D",
  "args": ""},
 {"type": "D",
  "tactic-prompt":
  "example  : D := by fail_if_success aesop (rule_sets [A]) (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success aesop (rule_sets [A]) (options := { terminal := true })",
  "core-prompt": " : D",
  "args": ""},
 {"type": "Σ (R : Ring), Morphism R R",
  "tactic-prompt": "example  : Σ (R : Ring), Morphism R R := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : Σ (R : Ring), Morphism R R",
  "args": ""},
 {"type": "∃ (R : Ring), domain R",
  "tactic-prompt": "example  : ∃ (R : Ring), domain R := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : ∃ (R : Ring), domain R",
  "args": ""},
 {"type": "MyTrue",
  "tactic-prompt":
  "example {P : α → Prop}  (h : All P (x :: xs)) : MyTrue := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "{P : α → Prop}  (h : All P (x :: xs)) : MyTrue",
  "args": "{P : α → Prop}  (h : All P (x :: xs))"},
 {"type": "α",
  "tactic-prompt":
  "example {α : Prop}  (h : α) : α := by aesop (rule_sets [-builtin]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (rule_sets [-builtin]",
  "core-prompt": "{α : Prop}  (h : α) : α",
  "args": "{α : Prop}  (h : α)"},
 {"type": "α ∨ γ",
  "tactic-prompt":
  "example (h : (α ∧ β) ∨ γ) : α ∨ γ := by aesop (add h norm simp); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (add h norm simp)",
  "core-prompt": "(h : (α ∧ β) ∨ γ) : α ∨ γ",
  "args": "(h : (α ∧ β) ∨ γ)"},
 {"type": "β",
  "tactic-prompt":
  "example {α β : Prop}  (ha : α)  (h : α → β) : β := by fail_if_success aesop (rule_sets [-builtin]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop (rule_sets [-builtin]",
  "core-prompt": "{α β : Prop}  (ha : α)  (h : α → β) : β",
  "args": "{α β : Prop}  (ha : α)  (h : α → β)"},
 {"type": "α",
  "tactic-prompt":
  "example {α : Prop}  (ha : α) : α := by fail_if_success aesop (rule_sets [-builtin]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop (rule_sets [-builtin]",
  "core-prompt": "{α : Prop}  (ha : α) : α",
  "args": "{α : Prop}  (ha : α)"},
 {"type": "T",
  "tactic-prompt": "example  : T := by aesop (rule_sets [-default]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (rule_sets [-default]",
  "core-prompt": " : T",
  "args": ""},
 {"type": "All P (x :: xs) ↔ (P x ∧ All P xs)",
  "tactic-prompt":
  "theorem (P : α → Prop)  (x : α)  (xs : List α) : All P (x :: xs) ↔ (P x ∧ All P xs) := by aesop; sorry",
  "name": "All.cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(P : α → Prop)  (x : α)  (xs : List α) : All P (x :: xs) ↔ (P x ∧ All P xs)",
  "args": "(P : α → Prop)  (x : α)  (xs : List α)"},
 {"type": "All P xs ↔ ∀ a : α, a ∈ xs → P a",
  "tactic-prompt":
  "theorem (P : α → Prop)  (xs : List α) : All P xs ↔ ∀ a : α, a ∈ xs → P a := by induction xs; sorry",
  "name": "mem",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt":
  "(P : α → Prop)  (xs : List α) : All P xs ↔ ∀ a : α, a ∈ xs → P a",
  "args": "(P : α → Prop)  (xs : List α)"},
 {"type": "All P xs ↔ ∀ a : α, a ∈ xs → P a",
  "tactic-prompt":
  "theorem (P : α → Prop)  (xs : List α) : All P xs ↔ ∀ a : α, a ∈ xs → P a := by induction xs; sorry",
  "name": "mem'",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt":
  "(P : α → Prop)  (xs : List α) : All P xs ↔ ∀ a : α, a ∈ xs → P a",
  "args": "(P : α → Prop)  (xs : List α)"},
 {"type": "EvenOrOdd 3",
  "tactic-prompt":
  "example  : EvenOrOdd 3 := by aesop\n    (add safe [Even.zero]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop\n    (add safe [Even.zero]",
  "core-prompt": " : EvenOrOdd 3",
  "args": ""},
 {"type": "EvenOrOdd 3",
  "tactic-prompt":
  "example  : EvenOrOdd 3 := by have h : ∀ n, Odd n → EvenOrOdd n := λ _ p => EvenOrOdd.odd p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "have h : ∀ n, Odd n → EvenOrOdd n := λ _ p => EvenOrOdd.odd p",
  "core-prompt": " : EvenOrOdd 3",
  "args": ""},
 {"type": "EvenOrOdd 2",
  "tactic-prompt":
  "example  : EvenOrOdd 2 := by fail_if_success aesop (add safe EvenOrOdd.even) (erase Even.zero)\n    (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success aesop (add safe EvenOrOdd.even) (erase Even.zero)\n    (options := { terminal := true })",
  "core-prompt": " : EvenOrOdd 2",
  "args": ""},
 {"type": "EvenOrOdd 2",
  "tactic-prompt":
  "example  : EvenOrOdd 2 := by have h : ∀ n, Even n → EvenOrOdd n := λ _ p => EvenOrOdd.even p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "have h : ∀ n, Even n → EvenOrOdd n := λ _ p => EvenOrOdd.even p",
  "core-prompt": " : EvenOrOdd 2",
  "args": ""},
 {"type": "id' n = n",
  "tactic-prompt": "example  : id' n = n := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : id' n = n",
  "args": ""},
 {"type": "n = m",
  "tactic-prompt": "example (h : MyEq n (id' m)) : n = m := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "(h : MyEq n (id' m)) : n = m",
  "args": "(h : MyEq n (id' m))"},
 {"type": "γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂",
  "tactic-prompt":
  "example (a : α)  (b : β)  (r₁ : (a : α) → (b : β) → γ₁ ∧ γ₂)      (r₂ : (a : α) → δ₁ ∧ δ₂) : γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂ := by aesop (add safe [forward r₁]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (add safe [forward r₁]",
  "core-prompt":
  "(a : α)  (b : β)  (r₁ : (a : α) → (b : β) → γ₁ ∧ γ₂)      (r₂ : (a : α) → δ₁ ∧ δ₂) : γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂",
  "args":
  "(a : α)  (b : β)  (r₁ : (a : α) → (b : β) → γ₁ ∧ γ₂)      (r₂ : (a : α) → δ₁ ∧ δ₂)"},
 {"type": "γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂",
  "tactic-prompt":
  "example (a : α)  (b : β)  (r₁ : (a : α) → (b : β) → γ₁ ∧ γ₂)      (r₂ : (a : α) → δ₁ ∧ δ₂) : γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂ := by fail_if_success\n    aesop (add safe [destruct r₁]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    aesop (add safe [destruct r₁]",
  "core-prompt":
  "(a : α)  (b : β)  (r₁ : (a : α) → (b : β) → γ₁ ∧ γ₂)      (r₂ : (a : α) → δ₁ ∧ δ₂) : γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂",
  "args":
  "(a : α)  (b : β)  (r₁ : (a : α) → (b : β) → γ₁ ∧ γ₂)      (r₂ : (a : α) → δ₁ ∧ δ₂)"},
 {"type": "Sig α (λ _ => β)",
  "tactic-prompt": "example (h : α ∧ β) : Sig α (λ _ => β) := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "(h : α ∧ β) : Sig α (λ _ => β)",
  "args": "(h : α ∧ β)"},
 {"type": "Sig α (λ _ => β)",
  "tactic-prompt": "example (h : α × β) : Sig α (λ _ => β) := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "(h : α × β) : Sig α (λ _ => β)",
  "args": "(h : α × β)"},
 {"type": "Sig α (λ _ => β)",
  "tactic-prompt":
  "example (h : PProd α β) : Sig α (λ _ => β) := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "(h : PProd α β) : Sig α (λ _ => β)",
  "args": "(h : PProd α β)"},
 {"type": "Sig α (λ _ => β)",
  "tactic-prompt":
  "example (h : MProd α β) : Sig α (λ _ => β) := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "(h : MProd α β) : Sig α (λ _ => β)",
  "args": "(h : MProd α β)"},
 {"type": "Ex α p",
  "tactic-prompt":
  "example {p : α → Prop}  (h : ∃ a, p a) : Ex α p := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "{p : α → Prop}  (h : ∃ a, p a) : Ex α p",
  "args": "{p : α → Prop}  (h : ∃ a, p a)"},
 {"type": "Sig α p",
  "tactic-prompt":
  "example {p : α → Prop}  (h : { a // p a }) : Sig α p := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "{p : α → Prop}  (h : { a // p a }) : Sig α p",
  "args": "{p : α → Prop}  (h : { a // p a })"},
 {"type": "Sig α p",
  "tactic-prompt":
  "example {p : α → Type}  (h : Σ a, p a) : Sig α p := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "{p : α → Type}  (h : Σ a, p a) : Sig α p",
  "args": "{p : α → Type}  (h : Σ a, p a)"},
 {"type": "Sig α p",
  "tactic-prompt":
  "example {p : α → Type}  (h : Σ' a, p a) : Sig α p := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "{p : α → Type}  (h : Σ' a, p a) : Sig α p",
  "args": "{p : α → Type}  (h : Σ' a, p a)"},
 {"type": "Even 4",
  "tactic-prompt":
  "example  : Even 4 := by aesop (add safe limitedEvenPlusTwo); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (add safe limitedEvenPlusTwo)",
  "core-prompt": " : Even 4",
  "args": ""},
 {"type": "Even 6",
  "tactic-prompt":
  "example  : Even 6 := by fail_if_success\n    aesop (add safe limitedEvenPlusTwo) (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success\n    aesop (add safe limitedEvenPlusTwo) (options := { terminal := true })",
  "core-prompt": " : Even 6",
  "args": ""},
 {"type": "False",
  "tactic-prompt": "example  : False := by aesop (add safe falso); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (add safe falso)",
  "core-prompt": " : False",
  "args": ""},
 {"type": "False",
  "tactic-prompt": "example  : False := by aesop (add safe falso₂); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (add safe falso₂)",
  "core-prompt": " : False",
  "args": ""},
 {"type": "∃ a, P a",
  "tactic-prompt":
  "example (P : α → Prop)  (a : α)  (h : P a) : ∃ a, P a := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "(P : α → Prop)  (a : α)  (h : P a) : ∃ a, P a",
  "args": "(P : α → Prop)  (a : α)  (h : P a)"},
 {"type": "∃ a b, P a b",
  "tactic-prompt":
  "example (P : α → β → Prop)  (a : α)  (b : β)  (h : P a b) : ∃ a b, P a b := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt":
  "(P : α → β → Prop)  (a : α)  (b : β)  (h : P a b) : ∃ a b, P a b",
  "args": "(P : α → β → Prop)  (a : α)  (b : β)  (h : P a b)"},
 {"type": "Σ a, P a",
  "tactic-prompt":
  "example (P : α → Type)  (a : α)  (h : P a) : Σ a, P a := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "(P : α → Type)  (a : α)  (h : P a) : Σ a, P a",
  "args": "(P : α → Type)  (a : α)  (h : P a)"},
 {"type": "Σ a b, P a b",
  "tactic-prompt":
  "example (P : α → β → Type)  (a : α)  (b : β)  (h : P a b) : Σ a b, P a b := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt":
  "(P : α → β → Type)  (a : α)  (b : β)  (h : P a b) : Σ a b, P a b",
  "args": "(P : α → β → Type)  (a : α)  (b : β)  (h : P a b)"},
 {"type": "∃ a, Q a",
  "tactic-prompt":
  "example (P Q : α → Prop)  (hPQ : ∀ a, P a → Q a)  (a : α)  (h : P a) : ∃ a, Q a := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt":
  "(P Q : α → Prop)  (hPQ : ∀ a, P a → Q a)  (a : α)  (h : P a) : ∃ a, Q a",
  "args": "(P Q : α → Prop)  (hPQ : ∀ a, P a → Q a)  (a : α)  (h : P a)"},
 {"type": "∃ a, R a",
  "tactic-prompt":
  "example (P Q Dead R : α → Prop)      (hPQ : ∀ a, P a → Q a)      (hDeadR : ∀ a, Dead a → R a)      (hQR : ∀ a, Q a → R a)      (a : α)  (h : P a) : ∃ a, R a := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt":
  "(P Q Dead R : α → Prop)      (hPQ : ∀ a, P a → Q a)      (hDeadR : ∀ a, Dead a → R a)      (hQR : ∀ a, Q a → R a)      (a : α)  (h : P a) : ∃ a, R a",
  "args":
  "(P Q Dead R : α → Prop)      (hPQ : ∀ a, P a → Q a)      (hDeadR : ∀ a, Dead a → R a)      (hQR : ∀ a, Q a → R a)      (a : α)  (h : P a)"},
 {"type": "List α",
  "tactic-prompt": "example  : List α := by aesop (add safe List.nil); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (add safe List.nil)",
  "core-prompt": " : List α",
  "args": ""},
 {"type": "List α",
  "tactic-prompt": "example  : List α := by aesop (add safe List.nil); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (add safe List.nil)",
  "core-prompt": " : List α",
  "args": ""},
 {"type": "List α",
  "tactic-prompt": "example  : List α := by aesop (add safe nil); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (add safe nil)",
  "core-prompt": " : List α",
  "args": ""},
 {"type": "EvenOrOdd' 3",
  "tactic-prompt": "example  : EvenOrOdd' 3 := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : EvenOrOdd' 3",
  "args": ""},
 {"type": "0 = 0",
  "tactic-prompt": "example  : 0 = 0 := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : 0 = 0",
  "args": ""},
 {"type": "α",
  "tactic-prompt":
  "example (h : α → α)  (h' : Wrap α) : α := by fail_if_success aesop (add safe h) (options := { maxRuleApplications := 20, maxGoals := 0, maxRuleApplicationDepth := 0 }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success aesop (add safe h) (options := { maxRuleApplications := 20, maxGoals := 0, maxRuleApplicationDepth := 0 })",
  "core-prompt": "(h : α → α)  (h' : Wrap α) : α",
  "args": "(h : α → α)  (h' : Wrap α)"},
 {"type": "Even 20",
  "tactic-prompt":
  "example (Even : Nat → Prop)  (zero : Even 0)      (plusTwo : ∀ n, Even n → Even (n + 2)) : Even 20 := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt":
  "(Even : Nat → Prop)  (zero : Even 0)      (plusTwo : ∀ n, Even n → Even (n + 2)) : Even 20",
  "args":
  "(Even : Nat → Prop)  (zero : Even 0)      (plusTwo : ∀ n, Even n → Even (n + 2))"},
 {"type": "Even 6",
  "tactic-prompt": "example  : Even 6 := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : Even 6",
  "args": ""},
 {"type": "f x ∈ xs.map f",
  "tactic-prompt":
  "theorem (f : α → β)  (x : α)  (xs : List α)  (h : x ∈ xs) : f x ∈ xs.map f := by induction h; sorry",
  "name": "Mem.map",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "(f : α → β)  (x : α)  (xs : List α)  (h : x ∈ xs) : f x ∈ xs.map f",
  "args": "(f : α → β)  (x : α)  (xs : List α)  (h : x ∈ xs)"},
 {"type": "Even 2",
  "tactic-prompt": "example  : Even 2 := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : Even 2",
  "args": ""},
 {"type": "Even 2",
  "tactic-prompt":
  "example  : Even 2 := by fail_if_success aesop (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop (options := { terminal := true })",
  "core-prompt": " : Even 2",
  "args": ""},
 {"type": "Even 2",
  "tactic-prompt": "example  : Even 2 := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : Even 2",
  "args": ""},
 {"type": "Even 2",
  "tactic-prompt":
  "example  : Even 2 := by fail_if_success aesop (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop (options := { terminal := true })",
  "core-prompt": " : Even 2",
  "args": ""},
 {"type": "xs = nil → ¬ NonEmpty xs",
  "tactic-prompt":
  "theorem (xs : MyList α) : xs = nil → ¬ NonEmpty xs := by aesop (add unsafe 10% cases MyList, norm unfold Not)\n    (rule_sets [MyList.NonEmpty]); sorry",
  "name": "nil_not_NonEmpty",
  "kind": "theorem",
  "first-tactic":
  "aesop (add unsafe 10% cases MyList, norm unfold Not)\n    (rule_sets [MyList.NonEmpty])",
  "core-prompt": "(xs : MyList α) : xs = nil → ¬ NonEmpty xs",
  "args": "(xs : MyList α)"},
 {"type": "xs ++ nil = xs",
  "tactic-prompt":
  "theorem {xs : MyList α} : xs ++ nil = xs := by induction xs; sorry",
  "name": "append_nil",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt": "{xs : MyList α} : xs ++ nil = xs",
  "args": "{xs : MyList α}"},
 {"type": "(xs ++ ys) ++ zs = xs ++ (ys ++ zs)",
  "tactic-prompt":
  "theorem {xs ys zs : MyList α} : (xs ++ ys) ++ zs = xs ++ (ys ++ zs) := by induction xs; sorry",
  "name": "append_assoc",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt": "{xs ys zs : MyList α} : (xs ++ ys) ++ zs = xs ++ (ys ++ zs)",
  "args": "{xs ys zs : MyList α}"},
 {"type": "All Q xs",
  "tactic-prompt":
  "theorem (P Q : α → Prop)  (wk : ∀ x, P x → Q x)  (xs : List α)  (h : All P xs) : All Q xs := by induction h; sorry",
  "name": "weaken",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "(P Q : α → Prop)  (wk : ∀ x, P x → Q x)  (xs : List α)  (h : All P xs) : All Q xs",
  "args":
  "(P Q : α → Prop)  (wk : ∀ x, P x → Q x)  (xs : List α)  (h : All P xs)"},
 {"type": "All (· ∈ xs) xs",
  "tactic-prompt":
  "theorem (xs : List α) : All (· ∈ xs) xs := by induction xs; sorry",
  "name": "in_self",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt": "(xs : List α) : All (· ∈ xs) xs",
  "args": "(xs : List α)"},
 {"type": "Even 500",
  "tactic-prompt":
  "example  : Even 500 := by aesop (options := { maxRuleApplications := 0, maxRuleApplicationDepth := 0 }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "aesop (options := { maxRuleApplications := 0, maxRuleApplicationDepth := 0 })",
  "core-prompt": " : Even 500",
  "args": ""},
 {"type": "n < k",
  "tactic-prompt":
  "example {n m k : Nat}  (h : n < m)  (h₂ : m < k) : n < k := by apply Nat.lt_trans; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply Nat.lt_trans",
  "core-prompt": "{n m k : Nat}  (h : n < m)  (h₂ : m < k) : n < k",
  "args": "{n m k : Nat}  (h : n < m)  (h₂ : m < k)"},
 {"type": "Unit",
  "tactic-prompt":
  "example  : Unit := by fail_if_success\n    aesop (rule_sets [-default]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    aesop (rule_sets [-default]",
  "core-prompt": " : Unit",
  "args": ""},
 {"type": "filter p (a :: as) = a :: filter p as",
  "tactic-prompt":
  "theorem {p : α → Prop}  [DecidablePred p]  {as bs : List α} (h : p a) : filter p (a :: as) = a :: filter p as := by simp [filter]; sorry",
  "name": "filter_cons_true",
  "kind": "theorem",
  "first-tactic": "simp [filter]",
  "core-prompt":
  "{p : α → Prop}  [DecidablePred p]  {as bs : List α} (h : p a) : filter p (a :: as) = a :: filter p as",
  "args": "{p : α → Prop}  [DecidablePred p]  {as bs : List α} (h : p a)"},
 {"type": "filter p (a :: as) = filter p as",
  "tactic-prompt":
  "theorem {p : α → Prop}  [DecidablePred p]  {as bs : List α} (h : ¬ p a) : filter p (a :: as) = filter p as := by simp [filter]; sorry",
  "name": "filter_cons_false",
  "kind": "theorem",
  "first-tactic": "simp [filter]",
  "core-prompt":
  "{p : α → Prop}  [DecidablePred p]  {as bs : List α} (h : ¬ p a) : filter p (a :: as) = filter p as",
  "args": "{p : α → Prop}  [DecidablePred p]  {as bs : List α} (h : ¬ p a)"},
 {"type": "a ∈ filter p as ↔ a ∈ as ∧ p a",
  "tactic-prompt":
  "theorem {p : α → Prop}  [DecidablePred p]  {as bs : List α} : a ∈ filter p as ↔ a ∈ as ∧ p a := by apply Iff.intro; sorry",
  "name": "mem_filter",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  "{p : α → Prop}  [DecidablePred p]  {as bs : List α} : a ∈ filter p as ↔ a ∈ as ∧ p a",
  "args": "{p : α → Prop}  [DecidablePred p]  {as bs : List α}"},
 {"type": "Even' 2",
  "tactic-prompt":
  "example  : Even' 2 := by fail_if_success aesop\n    (add safe [even'_of_false 0]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop\n    (add safe [even'_of_false 0]",
  "core-prompt": " : Even' 2",
  "args": ""},
 {"type": "x = y",
  "tactic-prompt":
  "example (h₁ : x = 5)  (h₂ : y = 5) : x = y := by fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true })",
  "core-prompt": "(h₁ : x = 5)  (h₂ : y = 5) : x = y",
  "args": "(h₁ : x = 5)  (h₂ : y = 5)"},
 {"type": "x = z",
  "tactic-prompt":
  "example (h₁ : x = y)  (h₂ : y = z) : x = z := by fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true })",
  "core-prompt": "(h₁ : x = y)  (h₂ : y = z) : x = z",
  "args": "(h₁ : x = y)  (h₂ : y = z)"},
 {"type": "x = y",
  "tactic-prompt":
  "example (P : ∀ x y, x = y → Prop)  (h₁ : x = y)  (h₂ : P x y h₁) : x = y := by fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst,\n             Aesop.BuiltinRules.assumption,\n             Aesop.BuiltinRules.applyHyps)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst,\n             Aesop.BuiltinRules.assumption,\n             Aesop.BuiltinRules.applyHyps)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true })",
  "core-prompt":
  "(P : ∀ x y, x = y → Prop)  (h₁ : x = y)  (h₂ : P x y h₁) : x = y",
  "args": "(P : ∀ x y, x = y → Prop)  (h₁ : x = y)  (h₂ : P x y h₁)"},
 {"type": "R",
  "tactic-prompt":
  "example (h₁ : P ↔ Q)  (h₂ : Q ↔ R)  (h₃ : P) : R := by fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true })",
  "core-prompt": "(h₁ : P ↔ Q)  (h₂ : Q ↔ R)  (h₃ : P) : R",
  "args": "(h₁ : P ↔ Q)  (h₂ : Q ↔ R)  (h₃ : P)"},
 {"type": "P z",
  "tactic-prompt":
  "example {P : α → Prop}  {x y z : α}  (h₁ : HEq x y)  (h₂ : HEq y z)  (h₃ : P x) : P z := by fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true })",
  "core-prompt":
  "{P : α → Prop}  {x y z : α}  (h₁ : HEq x y)  (h₂ : HEq y z)  (h₃ : P x) : P z",
  "args":
  "{P : α → Prop}  {x y z : α}  (h₁ : HEq x y)  (h₂ : HEq y z)  (h₃ : P x)"},
 {"type": "f x ∈ xs.map f",
  "tactic-prompt":
  "theorem {x : α}  {xs : List α}  (f : α → β)  (h : x ∈ xs) : f x ∈ xs.map f := by induction h; sorry",
  "name": "Mem.map",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{x : α}  {xs : List α}  (f : α → β)  (h : x ∈ xs) : f x ∈ xs.map f",
  "args": "{x : α}  {xs : List α}  (f : α → β)  (h : x ∈ xs)"},
 {"type": "∃ l r, xs = l ++ v :: r",
  "tactic-prompt":
  "theorem [DecidableEq α]  {xs : List α}  {v : α}  (h : v ∈ xs) : ∃ l r, xs = l ++ v :: r := by induction xs; sorry",
  "name": "Mem.split",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt":
  "[DecidableEq α]  {xs : List α}  {v : α}  (h : v ∈ xs) : ∃ l r, xs = l ++ v :: r",
  "args": "[DecidableEq α]  {xs : List α}  {v : α}  (h : v ∈ xs)"},
 {"type": "All P (x :: xs) ↔ (P x ∧ All P xs)",
  "tactic-prompt":
  "theorem (P : α → Prop)  (x : α)  (xs : List α) : All P (x :: xs) ↔ (P x ∧ All P xs) := by aesop; sorry",
  "name": "split_cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(P : α → Prop)  (x : α)  (xs : List α) : All P (x :: xs) ↔ (P x ∧ All P xs)",
  "args": "(P : α → Prop)  (x : α)  (xs : List α)"},
 {"type": "All P xs ↔ ∀ a : α, a ∈ xs → P a",
  "tactic-prompt":
  "theorem (P : α → Prop)  (xs : List α) : All P xs ↔ ∀ a : α, a ∈ xs → P a := by induction xs; sorry",
  "name": "mem",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt":
  "(P : α → Prop)  (xs : List α) : All P xs ↔ ∀ a : α, a ∈ xs → P a",
  "args": "(P : α → Prop)  (xs : List α)"},
 {"type": "All Q xs",
  "tactic-prompt":
  "theorem (P Q : α → Prop)  (wk : ∀ x, P x → Q x)  (xs : List α)  (h : All P xs) : All Q xs := by induction h; sorry",
  "name": "weaken",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "(P Q : α → Prop)  (wk : ∀ x, P x → Q x)  (xs : List α)  (h : All P xs) : All Q xs",
  "args":
  "(P Q : α → Prop)  (wk : ∀ x, P x → Q x)  (xs : List α)  (h : All P xs)"},
 {"type": "All (· ∈ xs) xs",
  "tactic-prompt":
  "theorem (xs : List α) : All (· ∈ xs) xs := by induction xs; sorry",
  "name": "in_self",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt": "(xs : List α) : All (· ∈ xs) xs",
  "args": "(xs : List α)"},
 {"type": "All P (xs.map f) ↔ All (fun x => P (f x)) xs",
  "tactic-prompt":
  "theorem (P : β → Prop)  (f : α → β)  (xs : List α) : All P (xs.map f) ↔ All (fun x => P (f x)) xs := by induction xs; sorry",
  "name": "map",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt":
  "(P : β → Prop)  (f : α → β)  (xs : List α) : All P (xs.map f) ↔ All (fun x => P (f x)) xs",
  "args": "(P : β → Prop)  (f : α → β)  (xs : List α)"},
 {"type": "Any P (x :: xs) ↔ (P x ∨ Any P xs)",
  "tactic-prompt":
  "theorem (P : α → Prop)  (x : α)  (xs : List α) : Any P (x :: xs) ↔ (P x ∨ Any P xs) := by aesop; sorry",
  "name": "cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(P : α → Prop)  (x : α)  (xs : List α) : Any P (x :: xs) ↔ (P x ∨ Any P xs)",
  "args": "(P : α → Prop)  (x : α)  (xs : List α)"},
 {"type": "Any P xs ↔ ∃ a : α, P a ∧ a ∈ xs",
  "tactic-prompt":
  "theorem (P : α → Prop)  (xs : List α) : Any P xs ↔ ∃ a : α, P a ∧ a ∈ xs := by apply Iff.intro; sorry",
  "name": "mem",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  "(P : α → Prop)  (xs : List α) : Any P xs ↔ ∃ a : α, P a ∧ a ∈ xs",
  "args": "(P : α → Prop)  (xs : List α)"},
 {"type": "Any P (xs.map f) ↔ Any (fun x => P (f x)) xs",
  "tactic-prompt":
  "theorem (P : β → Prop)  (f : α → β)  (xs : List α) : Any P (xs.map f) ↔ Any (fun x => P (f x)) xs := by induction xs; sorry",
  "name": "map",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt":
  "(P : β → Prop)  (f : α → β)  (xs : List α) : Any P (xs.map f) ↔ Any (fun x => P (f x)) xs",
  "args": "(P : β → Prop)  (f : α → β)  (xs : List α)"},
 {"type": "DecidablePred (Any P)",
  "tactic-prompt":
  "instance (P : α → Prop)  [d : DecidablePred P] : DecidablePred (Any P) := by intro xs; sorry",
  "name": "instDecidablePred",
  "kind": "instance",
  "first-tactic": "intro xs",
  "core-prompt":
  "(P : α → Prop)  [d : DecidablePred P] : DecidablePred (Any P)",
  "args": "(P : α → Prop)  [d : DecidablePred P]"},
 {"type": "∃ a : α, a ∈ xs ∧ a ∈ ys",
  "tactic-prompt":
  "theorem {xs ys : List α}  (h : Common xs ys) : ∃ a : α, a ∈ xs ∧ a ∈ ys := by induction h; sorry",
  "name": "mem",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{xs ys : List α}  (h : Common xs ys) : ∃ a : α, a ∈ xs ∧ a ∈ ys",
  "args": "{xs ys : List α}  (h : Common xs ys)"},
 {"type": "Common ys xs",
  "tactic-prompt":
  "theorem {xs ys : List α}  (h : Common xs ys) : Common ys xs := by have other : ∃ a, a ∈ ys ∧ a ∈ xs := Iff.mp (Any.mem (· ∈ ys) xs) h; sorry",
  "name": "sym",
  "kind": "theorem",
  "first-tactic":
  "have other : ∃ a, a ∈ ys ∧ a ∈ xs := Iff.mp (Any.mem (· ∈ ys) xs) h",
  "core-prompt": "{xs ys : List α}  (h : Common xs ys) : Common ys xs",
  "args": "{xs ys : List α}  (h : Common xs ys)"},
 {"type": "Decidable (Common xs ys)",
  "tactic-prompt":
  "instance [DecidableEq α]  (xs ys : List α) : Decidable (Common xs ys) := by apply Any.instDecidablePred; sorry",
  "name": "instDecidable",
  "kind": "instance",
  "first-tactic": "apply Any.instDecidablePred",
  "core-prompt": "[DecidableEq α]  (xs ys : List α) : Decidable (Common xs ys)",
  "args": "[DecidableEq α]  (xs ys : List α)"},
 {"type": "Proof Γ (δ :: Δ)",
  "tactic-prompt":
  "theorem (Γ Δ : List (Form Φ))  (prf : Proof Γ Δ)  (δ : Form Φ) : Proof Γ (δ :: Δ) := by induction prf; sorry",
  "name": "weaken",
  "kind": "theorem",
  "first-tactic": "induction prf",
  "core-prompt":
  "(Γ Δ : List (Form Φ))  (prf : Proof Γ Δ)  (δ : Form Φ) : Proof Γ (δ :: Δ)",
  "args": "(Γ Δ : List (Form Φ))  (prf : Proof Γ Δ)  (δ : Form Φ)"},
 {"type": "SC i Γ Δ",
  "tactic-prompt":
  "theorem (i : Φ → Prop)  [DecidablePred i]  (prf : Proof Γ Δ) : SC i Γ Δ := by induction prf; sorry",
  "name": "sound",
  "kind": "theorem",
  "first-tactic": "induction prf",
  "core-prompt":
  "(i : Φ → Prop)  [DecidablePred i]  (prf : Proof Γ Δ) : SC i Γ Δ",
  "args": "(i : Φ → Prop)  [DecidablePred i]  (prf : Proof Γ Δ)"},
 {"type": "Proof [] [φ] ↔ Valid φ",
  "tactic-prompt":
  "theorem [DecidableEq Φ]  (φ : Form Φ) : Proof [] [φ] ↔ Valid φ := by apply Iff.intro; sorry",
  "name": "Proof_sound_complete",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt": "[DecidableEq Φ]  (φ : Form Φ) : Proof [] [φ] ↔ Valid φ",
  "args": "[DecidableEq Φ]  (φ : Form Φ)"},
 {"type": "∃ (R : Ring) (_ : RingHom R R), True",
  "tactic-prompt":
  "example  : ∃ (R : Ring) (_ : RingHom R R), True := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : ∃ (R : Ring) (_ : RingHom R R), True",
  "args": ""},
 {"type": "a ∈ o ↔ o = some a",
  "tactic-prompt":
  "theorem {o : Option α} : a ∈ o ↔ o = some a := by aesop (add norm unfold Membership.mem); sorry",
  "name": "mem_spec",
  "kind": "theorem",
  "first-tactic": "aesop (add norm unfold Membership.mem)",
  "core-prompt": "{o : Option α} : a ∈ o ↔ o = some a",
  "args": "{o : Option α}"},
 {"type": "a ∈ none ↔ False",
  "tactic-prompt": "theorem  : a ∈ none ↔ False := by aesop; sorry",
  "name": "mem_none",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": " : a ∈ none ↔ False",
  "args": ""},
 {"type": "a ∈ some b ↔ a = b",
  "tactic-prompt": "theorem  : a ∈ some b ↔ a = b := by aesop; sorry",
  "name": "mem_some",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": " : a ∈ some b ↔ a = b",
  "args": ""},
 {"type": "l₁ ⊆ l₂ → l₂ ⊆ l₃ → l₁ ⊆ l₃",
  "tactic-prompt":
  "theorem {l₁ l₂ l₃ : List α} : l₁ ⊆ l₂ → l₂ ⊆ l₃ → l₁ ⊆ l₃ := by intro h₁ h₂ a ha; sorry",
  "name": "subset_trans",
  "kind": "theorem",
  "first-tactic": "intro h₁ h₂ a ha",
  "core-prompt": "{l₁ l₂ l₃ : List α} : l₁ ⊆ l₂ → l₂ ⊆ l₃ → l₁ ⊆ l₃",
  "args": "{l₁ l₂ l₃ : List α}"},
 {"type": "Unique (List α)",
  "tactic-prompt":
  "instance [IsEmpty α] : Unique (List α) := by aesop (add 1% cases List); sorry",
  "name": "unique_of_is_empty",
  "kind": "instance",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "[IsEmpty α] : Unique (List α)",
  "args": "[IsEmpty α]"},
 {"type": "a::l ≠ []",
  "tactic-prompt":
  "theorem (a : α)  (l : List α) : a::l ≠ [] := by aesop; sorry",
  "name": "X.cons_ne_nil",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(a : α)  (l : List α) : a::l ≠ []",
  "args": "(a : α)  (l : List α)"},
 {"type": "a::l ≠ l",
  "tactic-prompt":
  "theorem (a : α)  (l : List α) : a::l ≠ l := by aesop (add 1% cases Eq); sorry",
  "name": "X.cons_ne_self",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases Eq)",
  "core-prompt": "(a : α)  (l : List α) : a::l ≠ l",
  "args": "(a : α)  (l : List α)"},
 {"type": "(h₁::t₁) = (h₂::t₂) → h₁ = h₂",
  "tactic-prompt":
  "theorem {h₁ h₂ : α}  {t₁ t₂ : List α} : (h₁::t₁) = (h₂::t₂) → h₁ = h₂ := by aesop; sorry",
  "name": "X.head_eq_of_cons_eq",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{h₁ h₂ : α}  {t₁ t₂ : List α} : (h₁::t₁) = (h₂::t₂) → h₁ = h₂",
  "args": "{h₁ h₂ : α}  {t₁ t₂ : List α}"},
 {"type": "(h₁::t₁) = (h₂::t₂) → t₁ = t₂",
  "tactic-prompt":
  "theorem {h₁ h₂ : α}  {t₁ t₂ : List α} : (h₁::t₁) = (h₂::t₂) → t₁ = t₂ := by aesop; sorry",
  "name": "X.tail_eq_of_cons_eq",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{h₁ h₂ : α}  {t₁ t₂ : List α} : (h₁::t₁) = (h₂::t₂) → t₁ = t₂",
  "args": "{h₁ h₂ : α}  {t₁ t₂ : List α}"},
 {"type": "Injective (cons a)",
  "tactic-prompt": "theorem {a : α} : Injective (cons a) := by aesop; sorry",
  "name": "cons_injective",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a : α} : Injective (cons a)",
  "args": "{a : α}"},
 {"type": "a::l = a::l' ↔ l = l'",
  "tactic-prompt":
  "theorem (a : α)  {l l' : List α} : a::l = a::l' ↔ l = l' := by aesop; sorry",
  "name": "X.cons_inj",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(a : α)  {l l' : List α} : a::l = a::l' ↔ l = l'",
  "args": "(a : α)  {l l' : List α}"},
 {"type": "l ≠ nil → ∃ b L, l = b :: L",
  "tactic-prompt":
  "theorem  : l ≠ nil → ∃ b L, l = b :: L := by aesop (add 1% cases List); sorry",
  "name": "X.exists_cons_of_ne_nil",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": " : l ≠ nil → ∃ b L, l = b :: L",
  "args": ""},
 {"type": "a ∈ [a]",
  "tactic-prompt": "theorem (a : α) : a ∈ [a] := by aesop; sorry",
  "name": "X.mem_singleton_self",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(a : α) : a ∈ [a]",
  "args": "(a : α)"},
 {"type": "a ∈ [b] → a = b",
  "tactic-prompt": "theorem {a b : α} : a ∈ [b] → a = b := by aesop; sorry",
  "name": "X.eq_of_mem_singleton",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a b : α} : a ∈ [b] → a = b",
  "args": "{a b : α}"},
 {"type": "a ∈ [b] ↔ a = b",
  "tactic-prompt": "theorem {a b : α} : a ∈ [b] ↔ a = b := by aesop; sorry",
  "name": "X.mem_singleton",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a b : α} : a ∈ [b] ↔ a = b",
  "args": "{a b : α}"},
 {"type": "a ∈ b::l → b ∈ l → a ∈ l",
  "tactic-prompt":
  "theorem {a b : α}  {l : List α} : a ∈ b::l → b ∈ l → a ∈ l := by aesop; sorry",
  "name": "X.mem_of_mem_cons_of_mem",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a b : α}  {l : List α} : a ∈ b::l → b ∈ l → a ∈ l",
  "args": "{a b : α}  {l : List α}"},
 {"type": "a ∈ b :: l → a = b ∨ (a ≠ b ∧ a ∈ l)",
  "tactic-prompt":
  "theorem {a b : α}  {l : List α} : a ∈ b :: l → a = b ∨ (a ≠ b ∧ a ∈ l) := by open Classical in\n  aesop (add safe [decidable.list.eq_or_ne_mem_of_mem]); sorry",
  "name": "X.eq_or_ne_mem_of_mem",
  "kind": "theorem",
  "first-tactic":
  "open Classical in\n  aesop (add safe [decidable.list.eq_or_ne_mem_of_mem])",
  "core-prompt":
  "{a b : α}  {l : List α} : a ∈ b :: l → a = b ∨ (a ≠ b ∧ a ∈ l)",
  "args": "{a b : α}  {l : List α}"},
 {"type": "a ∉ s ++ t",
  "tactic-prompt":
  "theorem {a : α}  {s t : List α}  (h₁ : a ∉ s)  (h₂ : a ∉ t) : a ∉ s ++ t := by induction s; sorry",
  "name": "not_mem_append",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{a : α}  {s t : List α}  (h₁ : a ∉ s)  (h₂ : a ∉ t) : a ∉ s ++ t",
  "args": "{a : α}  {s t : List α}  (h₁ : a ∉ s)  (h₂ : a ∉ t)"},
 {"type": "l ≠ []",
  "tactic-prompt":
  "theorem {a : α}  {l : List α}  (h : a ∈ l) : l ≠ [] := by aesop; sorry",
  "name": "X.ne_nil_of_mem",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a : α}  {l : List α}  (h : a ∈ l) : l ≠ []",
  "args": "{a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "a ∈ l",
  "tactic-prompt":
  "theorem {a y : α}  {l : List α}  (h₁ : a ≠ y)  (h₂ : a ∈ y :: l) : a ∈ l := by aesop; sorry",
  "name": "mem_of_ne_of_mem",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{a y : α}  {l : List α}  (h₁ : a ≠ y)  (h₂ : a ∈ y :: l) : a ∈ l",
  "args": "{a y : α}  {l : List α}  (h₁ : a ≠ y)  (h₂ : a ∈ y :: l)"},
 {"type": "a ∉ b::l → a ≠ b",
  "tactic-prompt":
  "theorem {a b : α}  {l : List α} : a ∉ b::l → a ≠ b := by aesop; sorry",
  "name": "ne_of_not_mem_cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a b : α}  {l : List α} : a ∉ b::l → a ≠ b",
  "args": "{a b : α}  {l : List α}"},
 {"type": "a ∉ b::l → a ∉ l",
  "tactic-prompt":
  "theorem {a b : α}  {l : List α} : a ∉ b::l → a ∉ l := by aesop; sorry",
  "name": "not_mem_of_not_mem_cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a b : α}  {l : List α} : a ∉ b::l → a ∉ l",
  "args": "{a b : α}  {l : List α}"},
 {"type": "a ≠ y → a ∉ l → a ∉ y::l",
  "tactic-prompt":
  "theorem {a y : α}  {l : List α} : a ≠ y → a ∉ l → a ∉ y::l := by aesop; sorry",
  "name": "not_mem_cons_of_ne_of_not_mem",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a y : α}  {l : List α} : a ≠ y → a ∉ l → a ∉ y::l",
  "args": "{a y : α}  {l : List α}"},
 {"type": "a ∉ y::l → a ≠ y ∧ a ∉ l",
  "tactic-prompt":
  "theorem {a y : α}  {l : List α} : a ∉ y::l → a ≠ y ∧ a ∉ l := by aesop; sorry",
  "name": "ne_and_not_mem_of_not_mem_cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a y : α}  {l : List α} : a ∉ y::l → a ≠ y ∧ a ∉ l",
  "args": "{a y : α}  {l : List α}"},
 {"type": "b ∈ map f l ↔ ∃ a, a ∈ l ∧ f a = b",
  "tactic-prompt":
  "theorem {f : α → β}  {b : β}  {l : List α} : b ∈ map f l ↔ ∃ a, a ∈ l ∧ f a = b := by induction l; sorry",
  "name": "X.mem_map",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{f : α → β}  {b : β}  {l : List α} : b ∈ map f l ↔ ∃ a, a ∈ l ∧ f a = b",
  "args": "{f : α → β}  {b : β}  {l : List α}"},
 {"type": "f a ∈ map f l",
  "tactic-prompt":
  "theorem (f : α → β)  {a : α}  {l : List α}  (h : a ∈ l) : f a ∈ map f l := by aesop; sorry",
  "name": "X.mem_map_of_mem",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(f : α → β)  {a : α}  {l : List α}  (h : a ∈ l) : f a ∈ map f l",
  "args": "(f : α → β)  {a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "f a ∈ map f l ↔ a ∈ l",
  "tactic-prompt":
  "theorem {f : α → β}  (H : Injective f)  {a : α}  {l : List α} : f a ∈ map f l ↔ a ∈ l := by aesop; sorry",
  "name": "mem_map_of_injective",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{f : α → β}  (H : Injective f)  {a : α}  {l : List α} : f a ∈ map f l ↔ a ∈ l",
  "args": "{f : α → β}  (H : Injective f)  {a : α}  {l : List α}"},
 {"type": "(∃ (y : α), y ∈ l ∧ f y = x) ↔ f x ∈ l",
  "tactic-prompt":
  "theorem {f : α → α}    (hf : Involutive f)  (x : α)  (l : List α) : (∃ (y : α), y ∈ l ∧ f y = x) ↔ f x ∈ l := by aesop; sorry",
  "name": "_root_.function.involutive.exists_mem_and_apply_eq_iff",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{f : α → α}    (hf : Involutive f)  (x : α)  (l : List α) : (∃ (y : α), y ∈ l ∧ f y = x) ↔ f x ∈ l",
  "args": "{f : α → α}    (hf : Involutive f)  (x : α)  (l : List α)"},
 {"type": "a ∈ map f l ↔ f a ∈ l",
  "tactic-prompt":
  "theorem {f : α → α}  (hf : Involutive f)  {a : α}  {l : List α} : a ∈ map f l ↔ f a ∈ l := by aesop; sorry",
  "name": "mem_map_of_involutive",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{f : α → α}  (hf : Involutive f)  {a : α}  {l : List α} : a ∈ map f l ↔ f a ∈ l",
  "args": "{f : α → α}  (hf : Involutive f)  {a : α}  {l : List α}"},
 {"type": "(∀ i, i ∈ l.map f → P i) ↔ ∀ j, j ∈ l → P (f j)",
  "tactic-prompt":
  "theorem {f : α → β}  {l : List α}  {P : β → Prop} : (∀ i, i ∈ l.map f → P i) ↔ ∀ j, j ∈ l → P (f j) := by aesop; sorry",
  "name": "X.forall_mem_map_iff",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{f : α → β}  {l : List α}  {P : β → Prop} : (∀ i, i ∈ l.map f → P i) ↔ ∀ j, j ∈ l → P (f j)",
  "args": "{f : α → β}  {l : List α}  {P : β → Prop}"},
 {"type": "map f l = [] ↔ l = []",
  "tactic-prompt":
  "theorem {f : α → β}  {l : List α} : map f l = [] ↔ l = [] := by aesop (add 1% cases List); sorry",
  "name": "X.map_eq_nil",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "{f : α → β}  {l : List α} : map f l = [] ↔ l = []",
  "args": "{f : α → β}  {l : List α}"},
 {"type": "∀ {L : List (List α)}, a ∈ join L ↔ ∃ l, l ∈ L ∧ a ∈ l",
  "tactic-prompt":
  "theorem {a : α} : ∀ {L : List (List α)}, a ∈ join L ↔ ∃ l, l ∈ L ∧ a ∈ l := by intro L; sorry",
  "name": "X.mem_join",
  "kind": "theorem",
  "first-tactic": "intro L",
  "core-prompt":
  "{a : α} : ∀ {L : List (List α)}, a ∈ join L ↔ ∃ l, l ∈ L ∧ a ∈ l",
  "args": "{a : α}"},
 {"type": "a ∈ join L → ∃ l, l ∈ L ∧ a ∈ l",
  "tactic-prompt":
  "theorem {a : α}  {L : List (List α)} : a ∈ join L → ∃ l, l ∈ L ∧ a ∈ l := by aesop; sorry",
  "name": "X.exists_of_mem_join",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{a : α}  {L : List (List α)} : a ∈ join L → ∃ l, l ∈ L ∧ a ∈ l",
  "args": "{a : α}  {L : List (List α)}"},
 {"type": "b ∈ l.bind f ↔ ∃ a, a ∈ l ∧ b ∈ f a",
  "tactic-prompt":
  "theorem {b : β}  {l : List α}  {f : α → List β} : b ∈ l.bind f ↔ ∃ a, a ∈ l ∧ b ∈ f a := by induction l; sorry",
  "name": "X.mem_bind",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{b : β}  {l : List α}  {f : α → List β} : b ∈ l.bind f ↔ ∃ a, a ∈ l ∧ b ∈ f a",
  "args": "{b : β}  {l : List α}  {f : α → List β}"},
 {"type": "b ∈ l.bind f → ∃ a, a ∈ l ∧ b ∈ f a",
  "tactic-prompt":
  "theorem {l : List α} : b ∈ l.bind f → ∃ a, a ∈ l ∧ b ∈ f a := by aesop; sorry",
  "name": "X.exists_of_mem_bind",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{l : List α} : b ∈ l.bind f → ∃ a, a ∈ l ∧ b ∈ f a",
  "args": "{l : List α}"},
 {"type": "(∃ a, a ∈ l ∧ b ∈ f a) → b ∈ l.bind f",
  "tactic-prompt":
  "theorem {l : List α} : (∃ a, a ∈ l ∧ b ∈ f a) → b ∈ l.bind f := by induction l; sorry",
  "name": "X.mem_bind_of_mem",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "{l : List α} : (∃ a, a ∈ l ∧ b ∈ f a) → b ∈ l.bind f",
  "args": "{l : List α}"},
 {"type": "∀ l : List α, map f (l.bind g) = l.bind (λa => (g a).map f)",
  "tactic-prompt":
  "theorem {g : α → List β}  {f : β → γ} : ∀ l : List α, map f (l.bind g) = l.bind (λa => (g a).map f) := by intro l; sorry",
  "name": "X.bind_map",
  "kind": "theorem",
  "first-tactic": "intro l",
  "core-prompt":
  "{g : α → List β}  {f : β → γ} : ∀ l : List α, map f (l.bind g) = l.bind (λa => (g a).map f)",
  "args": "{g : α → List β}  {f : β → γ}"},
 {"type": "∀ l : List α, (map f l).bind g = l.bind (λ a => g (f a))",
  "tactic-prompt":
  "theorem (g : β → List γ)  (f : α → β) : ∀ l : List α, (map f l).bind g = l.bind (λ a => g (f a)) := by intro l; sorry",
  "name": "map_bind",
  "kind": "theorem",
  "first-tactic": "intro l",
  "core-prompt":
  "(g : β → List γ)  (f : α → β) : ∀ l : List α, (map f l).bind g = l.bind (λ a => g (f a))",
  "args": "(g : β → List γ)  (f : α → β)"},
 {"type": "length l = 0 ↔ l = []",
  "tactic-prompt":
  "theorem {l : List α} : length l = 0 ↔ l = [] := by aesop (add 1% cases List); sorry",
  "name": "X.length_eq_zero",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "{l : List α} : length l = 0 ↔ l = []",
  "args": "{l : List α}"},
 {"type": "∀ {l : List α}, a ∈ l → 0 < length l",
  "tactic-prompt":
  "theorem {a : α} : ∀ {l : List α}, a ∈ l → 0 < length l := by aesop (add 1% cases List) (simp_options := { arith := true }); sorry",
  "name": "X.length_pos_of_mem",
  "kind": "theorem",
  "first-tactic":
  "aesop (add 1% cases List) (simp_options := { arith := true })",
  "core-prompt": "{a : α} : ∀ {l : List α}, a ∈ l → 0 < length l",
  "args": "{a : α}"},
 {"type": "∀ {l : List α}, 0 < length l → ∃ a, a ∈ l",
  "tactic-prompt":
  "theorem  : ∀ {l : List α}, 0 < length l → ∃ a, a ∈ l := by aesop (add 1% cases List); sorry",
  "name": "X.exists_mem_of_length_pos",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": " : ∀ {l : List α}, 0 < length l → ∃ a, a ∈ l",
  "args": ""},
 {"type": "0 < length l ↔ ∃ a, a ∈ l",
  "tactic-prompt":
  "theorem {l : List α} : 0 < length l ↔ ∃ a, a ∈ l := by aesop (add unsafe [length_pos_of_mem]; sorry",
  "name": "X.length_pos_iff_exists_mem",
  "kind": "theorem",
  "first-tactic": "aesop (add unsafe [length_pos_of_mem]",
  "core-prompt": "{l : List α} : 0 < length l ↔ ∃ a, a ∈ l",
  "args": "{l : List α}"},
 {"type": "0 < length l → l ≠ []",
  "tactic-prompt":
  "theorem {l : List α} : 0 < length l → l ≠ [] := by aesop (add 1% cases List); sorry",
  "name": "ne_nil_of_length_pos",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "{l : List α} : 0 < length l → l ≠ []",
  "args": "{l : List α}"},
 {"type": "l ≠ [] → 0 < length l",
  "tactic-prompt":
  "theorem {l : List α} : l ≠ [] → 0 < length l := by aesop (add 1% cases List) (simp_options := { arith := true }); sorry",
  "name": "length_pos_of_ne_nil",
  "kind": "theorem",
  "first-tactic":
  "aesop (add 1% cases List) (simp_options := { arith := true })",
  "core-prompt": "{l : List α} : l ≠ [] → 0 < length l",
  "args": "{l : List α}"},
 {"type": "0 < length l ↔ l ≠ []",
  "tactic-prompt":
  "theorem {l : List α} : 0 < length l ↔ l ≠ [] := by aesop (add unsafe [ne_nil_of_length_pos]; sorry",
  "name": "length_pos_iff_ne_nil",
  "kind": "theorem",
  "first-tactic": "aesop (add unsafe [ne_nil_of_length_pos]",
  "core-prompt": "{l : List α} : 0 < length l ↔ l ≠ []",
  "args": "{l : List α}"},
 {"type": "∃ x, x ∈ l",
  "tactic-prompt":
  "theorem (l : List α)  (h : l ≠ []) : ∃ x, x ∈ l := by aesop (add 1% cases List); sorry",
  "name": "X.exists_mem_of_ne_nil",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "(l : List α)  (h : l ≠ []) : ∃ x, x ∈ l",
  "args": "(l : List α)  (h : l ≠ [])"},
 {"type": "length l = 1 ↔ ∃ a, l = [a]",
  "tactic-prompt":
  "theorem  : length l = 1 ↔ ∃ a, l = [a] := by aesop (add 1% cases List); sorry",
  "name": "X.length_eq_one",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": " : length l = 1 ↔ ∃ a, l = [a]",
  "args": ""},
 {"type": "Injective (length : List α → Nat)",
  "tactic-prompt":
  "theorem [Subsingleton α] : Injective (length : List α → Nat) := by aesop; sorry",
  "name": "length_injective",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "[Subsingleton α] : Injective (length : List α → Nat)",
  "args": "[Subsingleton α]"},
 {"type": "l.length = 2 ↔ ∃ a b, l = [a, b]",
  "tactic-prompt":
  "theorem {l : List α} : l.length = 2 ↔ ∃ a b, l = [a, b] := by aesop (add 50% cases List); sorry",
  "name": "length_eq_two",
  "kind": "theorem",
  "first-tactic": "aesop (add 50% cases List)",
  "core-prompt": "{l : List α} : l.length = 2 ↔ ∃ a b, l = [a, b]",
  "args": "{l : List α}"},
 {"type": "l.length = 3 ↔ ∃ a b c, l = [a, b, c]",
  "tactic-prompt":
  "theorem {l : List α} : l.length = 3 ↔ ∃ a b c, l = [a, b, c] := by aesop (add 50% cases List); sorry",
  "name": "length_eq_three",
  "kind": "theorem",
  "first-tactic": "aesop (add 50% cases List)",
  "core-prompt": "{l : List α} : l.length = 3 ↔ ∃ a b c, l = [a, b, c]",
  "args": "{l : List α}"},
 {"type": "∀ x, x ∈ @nil α → p x",
  "tactic-prompt":
  "theorem (p : α → Prop) : ∀ x, x ∈ @nil α → p x := by aesop; sorry",
  "name": "X.forall_mem_nil",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(p : α → Prop) : ∀ x, x ∈ @nil α → p x",
  "args": "(p : α → Prop)"},
 {"type":
  "∀ {p : α → Prop} {a : α} {l : List α},\n    (∀ x, x ∈ a :: l → p x) ↔ p a ∧ ∀ x, x ∈ l → p x",
  "tactic-prompt":
  "theorem  : ∀ {p : α → Prop} {a : α} {l : List α},\n    (∀ x, x ∈ a :: l → p x) ↔ p a ∧ ∀ x, x ∈ l → p x := by aesop; sorry",
  "name": "X.forall_mem_cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  " : ∀ {p : α → Prop} {a : α} {l : List α},\n    (∀ x, x ∈ a :: l → p x) ↔ p a ∧ ∀ x, x ∈ l → p x",
  "args": ""},
 {"type": "∀ x, x ∈ l → p x",
  "tactic-prompt":
  "theorem {p : α → Prop}  {a : α}  {l : List α}      (h : ∀ x, x ∈ a :: l → p x) : ∀ x, x ∈ l → p x := by aesop; sorry",
  "name": "forall_mem_of_forall_mem_cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{p : α → Prop}  {a : α}  {l : List α}      (h : ∀ x, x ∈ a :: l → p x) : ∀ x, x ∈ l → p x",
  "args":
  "{p : α → Prop}  {a : α}  {l : List α}      (h : ∀ x, x ∈ a :: l → p x)"},
 {"type": "(∀ x, x ∈ [a] → p x) ↔ p a",
  "tactic-prompt":
  "theorem {p : α → Prop}  {a : α} : (∀ x, x ∈ [a] → p x) ↔ p a := by aesop; sorry",
  "name": "X.forall_mem_singleton",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{p : α → Prop}  {a : α} : (∀ x, x ∈ [a] → p x) ↔ p a",
  "args": "{p : α → Prop}  {a : α}"},
 {"type":
  "(∀ x, x ∈ l₁ ++ l₂ → p x) ↔ (∀ x, x ∈ l₁ → p x) ∧ (∀ x, x ∈ l₂ → p x)",
  "tactic-prompt":
  "theorem {p : α → Prop}  {l₁ l₂ : List α} : (∀ x, x ∈ l₁ ++ l₂ → p x) ↔ (∀ x, x ∈ l₁ → p x) ∧ (∀ x, x ∈ l₂ → p x) := by aesop; sorry",
  "name": "X.forall_mem_append",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{p : α → Prop}  {l₁ l₂ : List α} : (∀ x, x ∈ l₁ ++ l₂ → p x) ↔ (∀ x, x ∈ l₁ → p x) ∧ (∀ x, x ∈ l₂ → p x)",
  "args": "{p : α → Prop}  {l₁ l₂ : List α}"},
 {"type": "¬ ∃ x, x ∈ @nil α ∧ p x",
  "tactic-prompt":
  "theorem (p : α → Prop) : ¬ ∃ x, x ∈ @nil α ∧ p x := by aesop; sorry",
  "name": "not_exists_mem_nil",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(p : α → Prop) : ¬ ∃ x, x ∈ @nil α ∧ p x",
  "args": "(p : α → Prop)"},
 {"type": "∃ x, x ∈ a :: l ∧ p x",
  "tactic-prompt":
  "theorem {p : α → Prop}  {a : α}  (l : List α)  (h : p a) : ∃ x, x ∈ a :: l ∧ p x := by aesop; sorry",
  "name": "exists_mem_cons_of",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{p : α → Prop}  {a : α}  (l : List α)  (h : p a) : ∃ x, x ∈ a :: l ∧ p x",
  "args": "{p : α → Prop}  {a : α}  (l : List α)  (h : p a)"},
 {"type": "∃ x, x ∈ a :: l ∧ p x",
  "tactic-prompt":
  "theorem {p : α → Prop}  {a : α}  {l : List α}  (h : ∃ x, x ∈ l ∧ p x) : ∃ x, x ∈ a :: l ∧ p x := by aesop; sorry",
  "name": "exists_mem_cons_of_exists",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{p : α → Prop}  {a : α}  {l : List α}  (h : ∃ x, x ∈ l ∧ p x) : ∃ x, x ∈ a :: l ∧ p x",
  "args": "{p : α → Prop}  {a : α}  {l : List α}  (h : ∃ x, x ∈ l ∧ p x)"},
 {"type": "p a ∨ ∃ x, x ∈ l ∧ p x",
  "tactic-prompt":
  "theorem {p : α → Prop}  {a : α}  {l : List α}  (h : ∃ x, x ∈ a :: l ∧ p x) : p a ∨ ∃ x, x ∈ l ∧ p x := by aesop; sorry",
  "name": "or_exists_of_exists_mem_cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{p : α → Prop}  {a : α}  {l : List α}  (h : ∃ x, x ∈ a :: l ∧ p x) : p a ∨ ∃ x, x ∈ l ∧ p x",
  "args": "{p : α → Prop}  {a : α}  {l : List α}  (h : ∃ x, x ∈ a :: l ∧ p x)"},
 {"type": "(∃ x, x ∈ a :: l ∧ p x) ↔ p a ∨ ∃ x, x ∈ l ∧ p x",
  "tactic-prompt":
  "theorem (p : α → Prop)  (a : α)  (l : List α) : (∃ x, x ∈ a :: l ∧ p x) ↔ p a ∨ ∃ x, x ∈ l ∧ p x := by aesop; sorry",
  "name": "exists_mem_cons_iff",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(p : α → Prop)  (a : α)  (l : List α) : (∃ x, x ∈ a :: l ∧ p x) ↔ p a ∨ ∃ x, x ∈ l ∧ p x",
  "args": "(p : α → Prop)  (a : α)  (l : List α)"},
 {"type": "l₁ ⊆ l₂ ↔ ∀ ⦃a : α⦄, a ∈ l₁ → a ∈ l₂",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α} : l₁ ⊆ l₂ ↔ ∀ ⦃a : α⦄, a ∈ l₁ → a ∈ l₂ := by aesop; sorry",
  "name": "X.subset_def",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{l₁ l₂ : List α} : l₁ ⊆ l₂ ↔ ∀ ⦃a : α⦄, a ∈ l₁ → a ∈ l₂",
  "args": "{l₁ l₂ : List α}"},
 {"type": "l ⊆ l₁ → l ⊆ l₁++l₂",
  "tactic-prompt":
  "theorem (l l₁ l₂ : List α) : l ⊆ l₁ → l ⊆ l₁++l₂ := by aesop (add 1% subset_trans); sorry",
  "name": "X.subset_append_of_subset_left",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% subset_trans)",
  "core-prompt": "(l l₁ l₂ : List α) : l ⊆ l₁ → l ⊆ l₁++l₂",
  "args": "(l l₁ l₂ : List α)"},
 {"type": "l ⊆ l₂ → l ⊆ l₁ ++ l₂",
  "tactic-prompt":
  "theorem (l l₁ l₂ : List α) : l ⊆ l₂ → l ⊆ l₁ ++ l₂ := by aesop (add 1% subset_trans); sorry",
  "name": "X.subset_append_of_subset_right",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% subset_trans)",
  "core-prompt": "(l l₁ l₂ : List α) : l ⊆ l₂ → l ⊆ l₁ ++ l₂",
  "args": "(l l₁ l₂ : List α)"},
 {"type": "a::l ⊆ m ↔ a ∈ m ∧ l ⊆ m",
  "tactic-prompt":
  "theorem {a : α}  {l m : List α} : a::l ⊆ m ↔ a ∈ m ∧ l ⊆ m := by set_option aesop.check.script false in; sorry",
  "name": "X.cons_subset",
  "kind": "theorem",
  "first-tactic": "set_option aesop.check.script false in",
  "core-prompt": "{a : α}  {l m : List α} : a::l ⊆ m ↔ a ∈ m ∧ l ⊆ m",
  "args": "{a : α}  {l m : List α}"},
 {"type": "a::l ⊆ m",
  "tactic-prompt":
  "theorem {a : α}  {l m : List α}      (ainm : a ∈ m)  (lsubm : l ⊆ m) : a::l ⊆ m := by aesop; sorry",
  "name": "cons_subset_of_subset_of_mem",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{a : α}  {l m : List α}      (ainm : a ∈ m)  (lsubm : l ⊆ m) : a::l ⊆ m",
  "args": "{a : α}  {l m : List α}      (ainm : a ∈ m)  (lsubm : l ⊆ m)"},
 {"type": "l₁ ++ l₂ ⊆ l",
  "tactic-prompt":
  "theorem {l₁ l₂ l : List α}  (l₁subl : l₁ ⊆ l)  (l₂subl : l₂ ⊆ l) : l₁ ++ l₂ ⊆ l := by set_option aesop.check.script false in; sorry",
  "name": "append_subset_of_subset_of_subset",
  "kind": "theorem",
  "first-tactic": "set_option aesop.check.script false in",
  "core-prompt":
  "{l₁ l₂ l : List α}  (l₁subl : l₁ ⊆ l)  (l₂subl : l₂ ⊆ l) : l₁ ++ l₂ ⊆ l",
  "args": "{l₁ l₂ l : List α}  (l₁subl : l₁ ⊆ l)  (l₂subl : l₂ ⊆ l)"},
 {"type": "l₁ ++ l₂ ⊆ l ↔ l₁ ⊆ l ∧ l₂ ⊆ l",
  "tactic-prompt":
  "theorem {l₁ l₂ l : List α} : l₁ ++ l₂ ⊆ l ↔ l₁ ⊆ l ∧ l₂ ⊆ l := by set_option aesop.check.script false in; sorry",
  "name": "append_subset_iff",
  "kind": "theorem",
  "first-tactic": "set_option aesop.check.script false in",
  "core-prompt": "{l₁ l₂ l : List α} : l₁ ++ l₂ ⊆ l ↔ l₁ ⊆ l ∧ l₂ ⊆ l",
  "args": "{l₁ l₂ l : List α}"},
 {"type": "l ⊆ [] → l = []",
  "tactic-prompt":
  "theorem {l : List α} : l ⊆ [] → l = [] := by aesop (add 1% cases List); sorry",
  "name": "eq_nil_of_subset_nil",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "{l : List α} : l ⊆ [] → l = []",
  "args": "{l : List α}"},
 {"type": "l = [] ↔ ∀ a, a ∉ l",
  "tactic-prompt":
  "theorem {l : List α} : l = [] ↔ ∀ a, a ∉ l := by aesop (add 1% cases List); sorry",
  "name": "X.eq_nil_iff_forall_not_mem",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "{l : List α} : l = [] ↔ ∀ a, a ∉ l",
  "args": "{l : List α}"},
 {"type": "map f l₁ ⊆ map f l₂",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  (f : α → β)  (H : l₁ ⊆ l₂) : map f l₁ ⊆ map f l₂ := by set_option aesop.check.script false in; sorry",
  "name": "X.map_subset",
  "kind": "theorem",
  "first-tactic": "set_option aesop.check.script false in",
  "core-prompt":
  "{l₁ l₂ : List α}  (f : α → β)  (H : l₁ ⊆ l₂) : map f l₁ ⊆ map f l₂",
  "args": "{l₁ l₂ : List α}  (f : α → β)  (H : l₁ ⊆ l₂)"},
 {"type": "map f l₁ ⊆ map f l₂ ↔ l₁ ⊆ l₂",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  (f : α → β)  (h : Injective f) : map f l₁ ⊆ map f l₂ ↔ l₁ ⊆ l₂ := by induction l₁; sorry",
  "name": "map_subset_iff",
  "kind": "theorem",
  "first-tactic": "induction l₁",
  "core-prompt":
  "{l₁ l₂ : List α}  (f : α → β)  (h : Injective f) : map f l₁ ⊆ map f l₂ ↔ l₁ ⊆ l₂",
  "args": "{l₁ l₂ : List α}  (f : α → β)  (h : Injective f)"},
 {"type": "s ≠ [] → s ++ t ≠ []",
  "tactic-prompt":
  "theorem (s t : List α) : s ≠ [] → s ++ t ≠ [] := by induction s; sorry",
  "name": "X.append_ne_nil_of_ne_nil_left",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt": "(s t : List α) : s ≠ [] → s ++ t ≠ []",
  "args": "(s t : List α)"},
 {"type": "t ≠ [] → s ++ t ≠ []",
  "tactic-prompt":
  "theorem (s t : List α) : t ≠ [] → s ++ t ≠ [] := by induction s; sorry",
  "name": "X.append_ne_nil_of_ne_nil_right",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt": "(s t : List α) : t ≠ [] → s ++ t ≠ []",
  "args": "(s t : List α)"},
 {"type": "(p ++ q) = [] ↔ p = [] ∧ q = []",
  "tactic-prompt":
  "theorem {p q : List α} : (p ++ q) = [] ↔ p = [] ∧ q = [] := by aesop (add 1% cases List); sorry",
  "name": "X.append_eq_nil",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "{p q : List α} : (p ++ q) = [] ↔ p = [] ∧ q = []",
  "args": "{p q : List α}"},
 {"type": "[] = a ++ b ↔ a = [] ∧ b = []",
  "tactic-prompt":
  "theorem {a b : List α} : [] = a ++ b ↔ a = [] ∧ b = [] := by induction a; sorry",
  "name": "nil_eq_append_iff",
  "kind": "theorem",
  "first-tactic": "induction a",
  "core-prompt": "{a b : List α} : [] = a ++ b ↔ a = [] ∧ b = []",
  "args": "{a b : List α}"},
 {"type":
  "a ++ b = x :: c ↔ (a = [] ∧ b = x :: c) ∨ (∃a', a = x :: a' ∧ c = a' ++ b)",
  "tactic-prompt":
  "theorem {a b c : List α}  {x : α} : a ++ b = x :: c ↔ (a = [] ∧ b = x :: c) ∨ (∃a', a = x :: a' ∧ c = a' ++ b) := by aesop (add 1% cases List); sorry",
  "name": "append_eq_cons_iff",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt":
  "{a b c : List α}  {x : α} : a ++ b = x :: c ↔ (a = [] ∧ b = x :: c) ∨ (∃a', a = x :: a' ∧ c = a' ++ b)",
  "args": "{a b c : List α}  {x : α}"},
 {"type":
  "(x :: c : List α) = a ++ b ↔ (a = [] ∧ b = x :: c) ∨ (∃a', a = x :: a' ∧ c = a' ++ b)",
  "tactic-prompt":
  "theorem {a b c : List α}  {x : α} : (x :: c : List α) = a ++ b ↔ (a = [] ∧ b = x :: c) ∨ (∃a', a = x :: a' ∧ c = a' ++ b) := by aesop (add norm simp [append_eq_cons_iff]; sorry",
  "name": "cons_eq_append_iff",
  "kind": "theorem",
  "first-tactic": "aesop (add norm simp [append_eq_cons_iff]",
  "core-prompt":
  "{a b c : List α}  {x : α} : (x :: c : List α) = a ++ b ↔ (a = [] ∧ b = x :: c) ∨ (∃a', a = x :: a' ∧ c = a' ++ b)",
  "args": "{a b c : List α}  {x : α}"},
 {"type": "t₁ = t₂",
  "tactic-prompt":
  "theorem {s₁ s₂ t₁ t₂ : List α}  (h : s₁ ++ t₁ = s₂ ++ t₂)      (hl : length s₁ = length s₂) : t₁ = t₂ := by aesop; sorry",
  "name": "X.append_inj_right",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{s₁ s₂ t₁ t₂ : List α}  (h : s₁ ++ t₁ = s₂ ++ t₂)      (hl : length s₁ = length s₂) : t₁ = t₂",
  "args":
  "{s₁ s₂ t₁ t₂ : List α}  (h : s₁ ++ t₁ = s₂ ++ t₂)      (hl : length s₁ = length s₂)"},
 {"type": "s₁ = s₂",
  "tactic-prompt":
  "theorem {s₁ s₂ t₁ t₂ : List α}  (h : s₁ ++ t₁ = s₂ ++ t₂)      (hl : length s₁ = length s₂) : s₁ = s₂ := by aesop; sorry",
  "name": "X.append_inj_left",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{s₁ s₂ t₁ t₂ : List α}  (h : s₁ ++ t₁ = s₂ ++ t₂)      (hl : length s₁ = length s₂) : s₁ = s₂",
  "args":
  "{s₁ s₂ t₁ t₂ : List α}  (h : s₁ ++ t₁ = s₂ ++ t₂)      (hl : length s₁ = length s₂)"},
 {"type": "s₁ = s₂ ∧ t₁ = t₂",
  "tactic-prompt":
  "theorem {s₁ s₂ t₁ t₂ : List α}  (h : s₁ ++ t₁ = s₂ ++ t₂)  (hl : length t₁ = length t₂) : s₁ = s₂ ∧ t₁ = t₂ := by induction s₁ generalizing s₂; sorry",
  "name": "X.append_inj'",
  "kind": "theorem",
  "first-tactic": "induction s₁ generalizing s₂",
  "core-prompt":
  "{s₁ s₂ t₁ t₂ : List α}  (h : s₁ ++ t₁ = s₂ ++ t₂)  (hl : length t₁ = length t₂) : s₁ = s₂ ∧ t₁ = t₂",
  "args":
  "{s₁ s₂ t₁ t₂ : List α}  (h : s₁ ++ t₁ = s₂ ++ t₂)  (hl : length t₁ = length t₂)"},
 {"type": "t₁ = t₂",
  "tactic-prompt":
  "theorem {s₁ s₂ t₁ t₂ : List α}  (h : s₁ ++ t₁ = s₂ ++ t₂)      (hl : length t₁ = length t₂) : t₁ = t₂ := by aesop; sorry",
  "name": "X.append_inj_right'",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{s₁ s₂ t₁ t₂ : List α}  (h : s₁ ++ t₁ = s₂ ++ t₂)      (hl : length t₁ = length t₂) : t₁ = t₂",
  "args":
  "{s₁ s₂ t₁ t₂ : List α}  (h : s₁ ++ t₁ = s₂ ++ t₂)      (hl : length t₁ = length t₂)"},
 {"type": "s₁ = s₂",
  "tactic-prompt":
  "theorem {s₁ s₂ t₁ t₂ : List α}  (h : s₁ ++ t₁ = s₂ ++ t₂)      (hl : length t₁ = length t₂) : s₁ = s₂ := by aesop; sorry",
  "name": "X.append_inj_left'",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{s₁ s₂ t₁ t₂ : List α}  (h : s₁ ++ t₁ = s₂ ++ t₂)      (hl : length t₁ = length t₂) : s₁ = s₂",
  "args":
  "{s₁ s₂ t₁ t₂ : List α}  (h : s₁ ++ t₁ = s₂ ++ t₂)      (hl : length t₁ = length t₂)"},
 {"type": "t₁ = t₂",
  "tactic-prompt":
  "theorem {s t₁ t₂ : List α}  (h : s ++ t₁ = s ++ t₂) : t₁ = t₂ := by aesop; sorry",
  "name": "append_left_cancel",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{s t₁ t₂ : List α}  (h : s ++ t₁ = s ++ t₂) : t₁ = t₂",
  "args": "{s t₁ t₂ : List α}  (h : s ++ t₁ = s ++ t₂)"},
 {"type": "s₁ = s₂",
  "tactic-prompt":
  "theorem {s₁ s₂ t : List α}  (h : s₁ ++ t = s₂ ++ t) : s₁ = s₂ := by aesop; sorry",
  "name": "append_right_cancel",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{s₁ s₂ t : List α}  (h : s₁ ++ t = s₂ ++ t) : s₁ = s₂",
  "args": "{s₁ s₂ t : List α}  (h : s₁ ++ t = s₂ ++ t)"},
 {"type": "Injective (λ t => s ++ t)",
  "tactic-prompt":
  "theorem (s : List α) : Injective (λ t => s ++ t) := by aesop; sorry",
  "name": "append_right_injective",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(s : List α) : Injective (λ t => s ++ t)",
  "args": "(s : List α)"},
 {"type": "Injective (λ s => s ++ t)",
  "tactic-prompt":
  "theorem (t : List α) : Injective (λ s => s ++ t) := by aesop; sorry",
  "name": "append_left_injective",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(t : List α) : Injective (λ s => s ++ t)",
  "args": "(t : List α)"},
 {"type": "(∀ b, b ∈ l → b = a) → l = replicate l.length a",
  "tactic-prompt":
  "theorem {a : α}  {l : List α} : (∀ b, b ∈ l → b = a) → l = replicate l.length a := by induction l; sorry",
  "name": "eq_replicate_of_mem",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : α}  {l : List α} : (∀ b, b ∈ l → b = a) → l = replicate l.length a",
  "args": "{a : α}  {l : List α}"},
 {"type": "l = replicate l.length a ↔ ∀ b, b ∈ l → b = a",
  "tactic-prompt":
  "theorem {a : α}  {l : List α} : l = replicate l.length a ↔ ∀ b, b ∈ l → b = a := by induction l; sorry",
  "name": "eq_replicate'",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : α}  {l : List α} : l = replicate l.length a ↔ ∀ b, b ∈ l → b = a",
  "args": "{a : α}  {l : List α}"},
 {"type": "map (λ _ => b) l = replicate l.length b",
  "tactic-prompt":
  "theorem (l : List α)  (b : β) : map (λ _ => b) l = replicate l.length b := by induction l; sorry",
  "name": "map_const",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(l : List α)  (b : β) : map (λ _ => b) l = replicate l.length b",
  "args": "(l : List α)  (b : β)"},
 {"type": "b₁ = b₂",
  "tactic-prompt":
  "theorem {b₁ b₂ : β}  {l : List α}  (h : b₁ ∈ map (λ _ => b₂) l) : b₁ = b₂ := by aesop; sorry",
  "name": "eq_of_mem_map_const",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{b₁ b₂ : β}  {l : List α}  (h : b₁ ∈ map (λ _ => b₂) l) : b₁ = b₂",
  "args": "{b₁ b₂ : β}  {l : List α}  (h : b₁ ∈ map (λ _ => b₂) l)"},
 {"type": "join (replicate n []) = @nil α",
  "tactic-prompt":
  "theorem (n : Nat) : join (replicate n []) = @nil α := by induction n; sorry",
  "name": "join_replicate_nil",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "(n : Nat) : join (replicate n []) = @nil α",
  "args": "(n : Nat)"},
 {"type": "Injective (λ a : α => replicate n a)",
  "tactic-prompt":
  "theorem {n : Nat}  (hn : n ≠ 0) : Injective (λ a : α => replicate n a) := by induction n; sorry",
  "name": "replicate_left_injective",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{n : Nat}  (hn : n ≠ 0) : Injective (λ a : α => replicate n a)",
  "args": "{n : Nat}  (hn : n ≠ 0)"},
 {"type": "∀ {n}, replicate n a = replicate n b ↔ n = 0 ∨ a = b",
  "tactic-prompt":
  "theorem {a b : α} : ∀ {n}, replicate n a = replicate n b ↔ n = 0 ∨ a = b := by intro n; sorry",
  "name": "replicate_left_inj'",
  "kind": "theorem",
  "first-tactic": "intro n",
  "core-prompt":
  "{a b : α} : ∀ {n}, replicate n a = replicate n b ↔ n = 0 ∨ a = b",
  "args": "{a b : α}"},
 {"type": "Injective (λ n => replicate n a)",
  "tactic-prompt":
  "theorem (a : α) : Injective (λ n => replicate n a) := by unfold Injective; sorry",
  "name": "replicate_right_injective",
  "kind": "theorem",
  "first-tactic": "unfold Injective",
  "core-prompt": "(a : α) : Injective (λ n => replicate n a)",
  "args": "(a : α)"},
 {"type": "replicate n a = replicate m a ↔ n = m",
  "tactic-prompt":
  "theorem {a : α}  {n m : Nat} : replicate n a = replicate m a ↔ n = m := by induction n generalizing m; sorry",
  "name": "replicate_right_inj",
  "kind": "theorem",
  "first-tactic": "induction n generalizing m",
  "core-prompt": "{a : α}  {n m : Nat} : replicate n a = replicate m a ↔ n = m",
  "args": "{a : α}  {n m : Nat}"},
 {"type": "(l₁ ++ l₂).bind f = l₁.bind f ++ l₂.bind f",
  "tactic-prompt":
  "theorem (f : α → List β)  (l₁ l₂ : List α) : (l₁ ++ l₂).bind f = l₁.bind f ++ l₂.bind f := by induction l₁; sorry",
  "name": "bind_append",
  "kind": "theorem",
  "first-tactic": "induction l₁",
  "core-prompt":
  "(f : α → List β)  (l₁ l₂ : List α) : (l₁ ++ l₂).bind f = l₁.bind f ++ l₂.bind f",
  "args": "(f : α → List β)  (l₁ l₂ : List α)"},
 {"type": "[x].bind f = f x",
  "tactic-prompt":
  "theorem (f : α → List β)  (x : α) : [x].bind f = f x := by aesop; sorry",
  "name": "bind_singleton",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(f : α → List β)  (x : α) : [x].bind f = f x",
  "args": "(f : α → List β)  (x : α)"},
 {"type": "l.bind (λ x => [x]) = l",
  "tactic-prompt":
  "theorem (l : List α) : l.bind (λ x => [x]) = l := by induction l; sorry",
  "name": "bind_singleton'",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List α) : l.bind (λ x => [x]) = l",
  "args": "(l : List α)"},
 {"type": "concat l a = l ++ [a]",
  "tactic-prompt":
  "theorem (a : α)  (l : List α) : concat l a = l ++ [a] := by induction l; sorry",
  "name": "X.concat_eq_append",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(a : α)  (l : List α) : concat l a = l ++ [a]",
  "args": "(a : α)  (l : List α)"},
 {"type": "concat l₁ a = concat l₂ a → l₁ = l₂",
  "tactic-prompt":
  "theorem {a : α}  {l₁ l₂ : List α} : concat l₁ a = concat l₂ a → l₁ = l₂ := by aesop; sorry",
  "name": "init_eq_of_concat_eq",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{a : α}  {l₁ l₂ : List α} : concat l₁ a = concat l₂ a → l₁ = l₂",
  "args": "{a : α}  {l₁ l₂ : List α}"},
 {"type": "concat l a = concat l b → a = b",
  "tactic-prompt":
  "theorem {a b : α}  {l : List α} : concat l a = concat l b → a = b := by aesop; sorry",
  "name": "last_eq_of_concat_eq",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a b : α}  {l : List α} : concat l a = concat l b → a = b",
  "args": "{a b : α}  {l : List α}"},
 {"type": "concat l a ≠ []",
  "tactic-prompt":
  "theorem (a : α)  (l : List α) : concat l a ≠ [] := by aesop; sorry",
  "name": "concat_ne_nil",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(a : α)  (l : List α) : concat l a ≠ []",
  "args": "(a : α)  (l : List α)"},
 {"type": "concat l₁ a ++ l₂ = l₁ ++ a :: l₂",
  "tactic-prompt":
  "theorem (a : α)  (l₁ l₂ : List α) : concat l₁ a ++ l₂ = l₁ ++ a :: l₂ := by aesop; sorry",
  "name": "concat_append",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(a : α)  (l₁ l₂ : List α) : concat l₁ a ++ l₂ = l₁ ++ a :: l₂",
  "args": "(a : α)  (l₁ l₂ : List α)"},
 {"type": "length (concat l a) = .succ (length l)",
  "tactic-prompt":
  "theorem (a : α)  (l : List α) : length (concat l a) = .succ (length l) := by aesop; sorry",
  "name": "X.length_concat",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(a : α)  (l : List α) : length (concat l a) = .succ (length l)",
  "args": "(a : α)  (l : List α)"},
 {"type": "l₁ ++ concat l₂ a = concat (l₁ ++ l₂) a",
  "tactic-prompt":
  "theorem (a : α)  (l₁ l₂ : List α) : l₁ ++ concat l₂ a = concat (l₁ ++ l₂) a := by aesop; sorry",
  "name": "append_concat",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(a : α)  (l₁ l₂ : List α) : l₁ ++ concat l₂ a = concat (l₁ ++ l₂) a",
  "args": "(a : α)  (l₁ l₂ : List α)"},
 {"type": "reverseAux l₁ l₂ = reverse l₁ ++ l₂",
  "tactic-prompt":
  "theorem (l₁ l₂ : List α) : reverseAux l₁ l₂ = reverse l₁ ++ l₂ := by induction l₁ generalizing l₂; sorry",
  "name": "reverse_core_eq",
  "kind": "theorem",
  "first-tactic": "induction l₁ generalizing l₂",
  "core-prompt": "(l₁ l₂ : List α) : reverseAux l₁ l₂ = reverse l₁ ++ l₂",
  "args": "(l₁ l₂ : List α)"},
 {"type": "reverse (a::l) = concat (reverse l) a",
  "tactic-prompt":
  "theorem (a : α)  (l : List α) : reverse (a::l) = concat (reverse l) a := by aesop; sorry",
  "name": "reverse_cons'",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(a : α)  (l : List α) : reverse (a::l) = concat (reverse l) a",
  "args": "(a : α)  (l : List α)"},
 {"type": "reverse (s ++ t) = (reverse t) ++ (reverse s)",
  "tactic-prompt":
  "theorem (s t : List α) : reverse (s ++ t) = (reverse t) ++ (reverse s) := by induction s; sorry",
  "name": "X.reverse_append",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "(s t : List α) : reverse (s ++ t) = (reverse t) ++ (reverse s)",
  "args": "(s t : List α)"},
 {"type": "reverse (concat l a) = a :: reverse l",
  "tactic-prompt":
  "theorem (l : List α)  (a : α) : reverse (concat l a) = a :: reverse l := by aesop; sorry",
  "name": "X.reverse_concat",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(l : List α)  (a : α) : reverse (concat l a) = a :: reverse l",
  "args": "(l : List α)  (a : α)"},
 {"type": "reverse (reverse l) = l",
  "tactic-prompt":
  "theorem (l : List α) : reverse (reverse l) = l := by induction l; sorry",
  "name": "X.reverse_reverse",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List α) : reverse (reverse l) = l",
  "args": "(l : List α)"},
 {"type": "Involutive (@reverse α)",
  "tactic-prompt": "theorem  : Involutive (@reverse α) := by aesop; sorry",
  "name": "reverse_involutive",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": " : Involutive (@reverse α)",
  "args": ""},
 {"type": "Injective (@reverse α)",
  "tactic-prompt":
  "theorem {α : Type u} : Injective (@reverse α) := by aesop; sorry",
  "name": "reverse_injective",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{α : Type u} : Injective (@reverse α)",
  "args": "{α : Type u}"},
 {"type": "Surjective (@reverse α)",
  "tactic-prompt":
  "theorem {α : Type u} : Surjective (@reverse α) := by aesop; sorry",
  "name": "reverse_surjective",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{α : Type u} : Surjective (@reverse α)",
  "args": "{α : Type u}"},
 {"type": "Bijective (@reverse α)",
  "tactic-prompt": "theorem  : Bijective (@reverse α) := by aesop; sorry",
  "name": "reverse_bijective",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": " : Bijective (@reverse α)",
  "args": ""},
 {"type": "reverse l₁ = reverse l₂ ↔ l₁ = l₂",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α} : reverse l₁ = reverse l₂ ↔ l₁ = l₂ := by aesop (add safe forward reverse_injective); sorry",
  "name": "reverse_inj",
  "kind": "theorem",
  "first-tactic": "aesop (add safe forward reverse_injective)",
  "core-prompt": "{l₁ l₂ : List α} : reverse l₁ = reverse l₂ ↔ l₁ = l₂",
  "args": "{l₁ l₂ : List α}"},
 {"type": "l.reverse = l' ↔ l = l'.reverse",
  "tactic-prompt":
  "theorem {l l' : List α} : l.reverse = l' ↔ l = l'.reverse := by aesop; sorry",
  "name": "reverse_eq_iff",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{l l' : List α} : l.reverse = l' ↔ l = l'.reverse",
  "args": "{l l' : List α}"},
 {"type": "reverse l = [] ↔ l = []",
  "tactic-prompt":
  "theorem {l : List α} : reverse l = [] ↔ l = [] := by aesop (add norm simp reverse_eq_iff); sorry",
  "name": "reverse_eq_nil",
  "kind": "theorem",
  "first-tactic": "aesop (add norm simp reverse_eq_iff)",
  "core-prompt": "{l : List α} : reverse l = [] ↔ l = []",
  "args": "{l : List α}"},
 {"type": "concat l a = reverse (a :: reverse l)",
  "tactic-prompt":
  "theorem (a : α)  (l : List α) : concat l a = reverse (a :: reverse l) := by induction l; sorry",
  "name": "concat_eq_reverse_cons",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(a : α)  (l : List α) : concat l a = reverse (a :: reverse l)",
  "args": "(a : α)  (l : List α)"},
 {"type": "length (reverse l) = length l",
  "tactic-prompt":
  "theorem (l : List α) : length (reverse l) = length l := by induction l; sorry",
  "name": "X.length_reverse",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List α) : length (reverse l) = length l",
  "args": "(l : List α)"},
 {"type": "map f (reverse l) = reverse (map f l)",
  "tactic-prompt":
  "theorem (f : α → β)  (l : List α) : map f (reverse l) = reverse (map f l) := by induction l; sorry",
  "name": "map_reverse",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : α → β)  (l : List α) : map f (reverse l) = reverse (map f l)",
  "args": "(f : α → β)  (l : List α)"},
 {"type": "map f (reverseAux l₁ l₂) = reverseAux (map f l₁) (map f l₂)",
  "tactic-prompt":
  "theorem (f : α → β)  (l₁ l₂ : List α) : map f (reverseAux l₁ l₂) = reverseAux (map f l₁) (map f l₂) := by aesop; sorry",
  "name": "map_reverse_core",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(f : α → β)  (l₁ l₂ : List α) : map f (reverseAux l₁ l₂) = reverseAux (map f l₁) (map f l₂)",
  "args": "(f : α → β)  (l₁ l₂ : List α)"},
 {"type": "a ∈ reverse l ↔ a ∈ l",
  "tactic-prompt":
  "theorem {a : α}  {l : List α} : a ∈ reverse l ↔ a ∈ l := by induction l; sorry",
  "name": "X.mem_reverse",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "{a : α}  {l : List α} : a ∈ reverse l ↔ a ∈ l",
  "args": "{a : α}  {l : List α}"},
 {"type": "Empty l ↔ l = []",
  "tactic-prompt": "theorem {l : List α} : Empty l ↔ l = [] := by aesop; sorry",
  "name": "empty_iff_eq_nil",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{l : List α} : Empty l ↔ l = []",
  "args": "{l : List α}"},
 {"type": "∀ (h : l ≠ nil), last (a :: l) (cons_ne_nil a l) = last l h",
  "tactic-prompt":
  "theorem {a : α}  {l : List α} : ∀ (h : l ≠ nil), last (a :: l) (cons_ne_nil a l) = last l h := by aesop (add 1% cases List); sorry",
  "name": "last_cons",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt":
  "{a : α}  {l : List α} : ∀ (h : l ≠ nil), last (a :: l) (cons_ne_nil a l) = last l h",
  "args": "{a : α}  {l : List α}"},
 {"type":
  "last (l ++ [a]) (append_ne_nil_of_ne_nil_right l _ (cons_ne_nil a _)) = a",
  "tactic-prompt":
  "theorem {a : α}  (l : List α) : last (l ++ [a]) (append_ne_nil_of_ne_nil_right l _ (cons_ne_nil a _)) = a := by induction l; sorry",
  "name": "last_append_singleton",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : α}  (l : List α) : last (l ++ [a]) (append_ne_nil_of_ne_nil_right l _ (cons_ne_nil a _)) = a",
  "args": "{a : α}  (l : List α)"},
 {"type": "last (l₁ ++ l₂) (append_ne_nil_of_ne_nil_right l₁ l₂ h) = last l₂ h",
  "tactic-prompt":
  "theorem (l₁ l₂ : List α)  (h : l₂ ≠ []) : last (l₁ ++ l₂) (append_ne_nil_of_ne_nil_right l₁ l₂ h) = last l₂ h := by induction l₁; sorry",
  "name": "last_append",
  "kind": "theorem",
  "first-tactic": "induction l₁",
  "core-prompt":
  "(l₁ l₂ : List α)  (h : l₂ ≠ []) : last (l₁ ++ l₂) (append_ne_nil_of_ne_nil_right l₁ l₂ h) = last l₂ h",
  "args": "(l₁ l₂ : List α)  (h : l₂ ≠ [])"},
 {"type": "last (concat l a) (concat_ne_nil a l) = a",
  "tactic-prompt":
  "theorem {a : α}  (l : List α) : last (concat l a) (concat_ne_nil a l) = a := by aesop; sorry",
  "name": "last_concat",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{a : α}  (l : List α) : last (concat l a) (concat_ne_nil a l) = a",
  "args": "{a : α}  (l : List α)"},
 {"type": "last l₁ h₁ = last l₂ h₂",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  (h₁ : l₁ ≠ [])  (h₂ : l₂ ≠ [])  (h₃ : l₁ = l₂) : last l₁ h₁ = last l₂ h₂ := by aesop; sorry",
  "name": "last_congr",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{l₁ l₂ : List α}  (h₁ : l₁ ≠ [])  (h₂ : l₂ ≠ [])  (h₃ : l₁ = l₂) : last l₁ h₁ = last l₂ h₂",
  "args": "{l₁ l₂ : List α}  (h₁ : l₁ ≠ [])  (h₂ : l₂ ≠ [])  (h₃ : l₁ = l₂)"},
 {"type": "∀ {l : List α} (h : l ≠ []), last l h ∈ l",
  "tactic-prompt":
  "theorem  : ∀ {l : List α} (h : l ≠ []), last l h ∈ l := by intro l; sorry",
  "name": "last_mem",
  "kind": "theorem",
  "first-tactic": "intro l",
  "core-prompt": " : ∀ {l : List α} (h : l ≠ []), last l h ∈ l",
  "args": ""},
 {"type":
  "(replicate m.succ a).last\n    (ne_nil_of_length_eq_succ\n      (show (replicate m.succ a).length = m.succ by rw [length_replicate])) =\n  a",
  "tactic-prompt":
  "theorem (a m : Nat) : (replicate m.succ a).last\n    (ne_nil_of_length_eq_succ\n      (show (replicate m.succ a).length = m.succ by rw [length_replicate])) =\n  a := by induction m; sorry",
  "name": "last_replicate_succ",
  "kind": "theorem",
  "first-tactic": "induction m",
  "core-prompt":
  "(a m : Nat) : (replicate m.succ a).last\n    (ne_nil_of_length_eq_succ\n      (show (replicate m.succ a).length = m.succ by rw [length_replicate])) =\n  a",
  "args": "(a m : Nat)"},
 {"type": "∀ {l : List α} (_ : x ∈ l.last'), x ∈ (y :: l).last'",
  "tactic-prompt":
  "theorem {x y : α} : ∀ {l : List α} (_ : x ∈ l.last'), x ∈ (y :: l).last' := by intro l; sorry",
  "name": "mem_last'_cons",
  "kind": "theorem",
  "first-tactic": "intro l",
  "core-prompt":
  "{x y : α} : ∀ {l : List α} (_ : x ∈ l.last'), x ∈ (y :: l).last'",
  "args": "{x y : α}"},
 {"type": "a ∈ l",
  "tactic-prompt":
  "theorem {l : List α}  {a : α}  (ha : a ∈ l.last') : a ∈ l := by match l with\n  | [] => aesop\n  | [_] => aesop\n  | x :: y :: zs =>\n    have ih := mem_of_mem_last' (l := y :: zs) (a := a)\n    aesop; sorry",
  "name": "mem_of_mem_last'",
  "kind": "theorem",
  "first-tactic":
  "match l with\n  | [] => aesop\n  | [_] => aesop\n  | x :: y :: zs =>\n    have ih := mem_of_mem_last' (l := y :: zs) (a := a)\n    aesop",
  "core-prompt": "{l : List α}  {a : α}  (ha : a ∈ l.last') : a ∈ l",
  "args": "{l : List α}  {a : α}  (ha : a ∈ l.last')"},
 {"type": "x ∈ (l₁ ++ l₂).last'",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  {x : α}  (h : x ∈ l₂.last') : x ∈ (l₁ ++ l₂).last' := by aesop (add 1% cases List); sorry",
  "name": "last'_append",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt":
  "{l₁ l₂ : List α}  {x : α}  (h : x ∈ l₂.last') : x ∈ (l₁ ++ l₂).last'",
  "args": "{l₁ l₂ : List α}  {x : α}  (h : x ∈ l₂.last')"},
 {"type": "ihead l = (head' l).iget",
  "tactic-prompt":
  "theorem [Inhabited α]  (l : List α) : ihead l = (head' l).iget := by aesop (add 1% cases List); sorry",
  "name": "head_eq_head'",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "[Inhabited α]  (l : List α) : ihead l = (head' l).iget",
  "args": "[Inhabited α]  (l : List α)"},
 {"type": "∀ {l : List α}, x ∈ l.head' → x ∈ l",
  "tactic-prompt":
  "theorem {x : α} : ∀ {l : List α}, x ∈ l.head' → x ∈ l := by intro l; sorry",
  "name": "mem_of_mem_head'",
  "kind": "theorem",
  "first-tactic": "intro l",
  "core-prompt": "{x : α} : ∀ {l : List α}, x ∈ l.head' → x ∈ l",
  "args": "{x : α}"},
 {"type": "ihead (s ++ t) = ihead s",
  "tactic-prompt":
  "theorem [Inhabited α]  (t : List α)  {s : List α}  (h : s ≠ []) : ihead (s ++ t) = ihead s := by aesop (add 1% cases List); sorry",
  "name": "head_append",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt":
  "[Inhabited α]  (t : List α)  {s : List α}  (h : s ≠ []) : ihead (s ++ t) = ihead s",
  "args": "[Inhabited α]  (t : List α)  {s : List α}  (h : s ≠ [])"},
 {"type": "x ∈ (s ++ t).head'",
  "tactic-prompt":
  "theorem {s t : List α}  {x : α}  (h : x ∈ s.head') : x ∈ (s ++ t).head' := by aesop (add 1% cases List); sorry",
  "name": "head'_append",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt":
  "{s t : List α}  {x : α}  (h : x ∈ s.head') : x ∈ (s ++ t).head'",
  "args": "{s t : List α}  {x : α}  (h : x ∈ s.head')"},
 {"type":
  "∀ (l₁ : List α) {l₂ : List α} (_ : l₁ ≠ []),\n  head' (l₁ ++ l₂) = head' l₁",
  "tactic-prompt":
  "theorem  : ∀ (l₁ : List α) {l₂ : List α} (_ : l₁ ≠ []),\n  head' (l₁ ++ l₂) = head' l₁ := by aesop (add 1% cases List); sorry",
  "name": "head'_append_of_ne_nil",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt":
  " : ∀ (l₁ : List α) {l₂ : List α} (_ : l₁ ≠ []),\n  head' (l₁ ++ l₂) = head' l₁",
  "args": ""},
 {"type": "tail (l ++ [a]) = tail l ++ [a]",
  "tactic-prompt":
  "theorem {a : α}  {l : List α}  (h : l ≠ nil) : tail (l ++ [a]) = tail l ++ [a] := by induction l; sorry",
  "name": "tail_append_singleton_of_ne_nil",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : α}  {l : List α}  (h : l ≠ nil) : tail (l ++ [a]) = tail l ++ [a]",
  "args": "{a : α}  {l : List α}  (h : l ≠ nil)"},
 {"type": "∀ {l : List α} {a : α} (_ : a ∈ head' l), a :: tail l = l",
  "tactic-prompt":
  "theorem  : ∀ {l : List α} {a : α} (_ : a ∈ head' l), a :: tail l = l := by aesop; sorry",
  "name": "cons_head'_tail",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": " : ∀ {l : List α} {a : α} (_ : a ∈ head' l), a :: tail l = l",
  "args": ""},
 {"type": "∀ {l : List α} (_ : l ≠ []), ihead l ∈ head' l",
  "tactic-prompt":
  "theorem [Inhabited α] : ∀ {l : List α} (_ : l ≠ []), ihead l ∈ head' l := by aesop; sorry",
  "name": "head_mem_head'",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "[Inhabited α] : ∀ {l : List α} (_ : l ≠ []), ihead l ∈ head' l",
  "args": "[Inhabited α]"},
 {"type": "(ihead l)::(tail l) = l",
  "tactic-prompt":
  "theorem [Inhabited α]  {l : List α}  (h : l ≠ []) : (ihead l)::(tail l) = l := by aesop; sorry",
  "name": "cons_head_tail",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "[Inhabited α]  {l : List α}  (h : l ≠ []) : (ihead l)::(tail l) = l",
  "args": "[Inhabited α]  {l : List α}  (h : l ≠ [])"},
 {"type": "MyTrue₃",
  "tactic-prompt": "example  : MyTrue₃ := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : MyTrue₃",
  "args": ""},
 {"type": "MyFalse",
  "tactic-prompt": "example  : MyFalse := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : MyFalse",
  "args": ""},
 {"type": "MyFalse",
  "tactic-prompt":
  "example  : MyFalse := by fail_if_success aesop (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop (options := { terminal := true })",
  "core-prompt": " : MyFalse",
  "args": ""},
 {"type": "MyFalse",
  "tactic-prompt":
  "example  : MyFalse := by aesop (options := { warnOnNonterminal := false }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (options := { warnOnNonterminal := false })",
  "core-prompt": " : MyFalse",
  "args": ""},
 {"type": "MyFalse₂",
  "tactic-prompt": "example  : MyFalse₂ := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : MyFalse₂",
  "args": ""},
 {"type": "α",
  "tactic-prompt": "example  : α := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : α",
  "args": ""},
 {"type": "∃ l r, xs = l ++ v :: r",
  "tactic-prompt":
  "theorem [DecidableEq α]  (xs : List α)  (v : α)  (h : v ∈ xs) : ∃ l r, xs = l ++ v :: r := by induction xs; sorry",
  "name": "Mem.split",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt":
  "[DecidableEq α]  (xs : List α)  (v : α)  (h : v ∈ xs) : ∃ l r, xs = l ++ v :: r",
  "args": "[DecidableEq α]  (xs : List α)  (v : α)  (h : v ∈ xs)"},
 {"type": "P x ∧ xs.all P",
  "tactic-prompt":
  "theorem (P : α → Bool)  (x : α)  (xs : List α)  (h : (x :: xs).all P) : P x ∧ xs.all P := by aesop; sorry",
  "name": "all_cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(P : α → Bool)  (x : α)  (xs : List α)  (h : (x :: xs).all P) : P x ∧ xs.all P",
  "args": "(P : α → Bool)  (x : α)  (xs : List α)  (h : (x :: xs).all P)"},
 {"type": "All (· ∈ []) (@List.nil α)",
  "tactic-prompt":
  "example  : All (· ∈ []) (@List.nil α) := by aesop (options := { maxRuleApplications := 50, terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "aesop (options := { maxRuleApplications := 50, terminal := true })",
  "core-prompt": " : All (· ∈ []) (@List.nil α)",
  "args": ""},
 {"type": "Any P xs → Any P ys",
  "tactic-prompt":
  "theorem {xs ys : List α}  (perm : Perm xs ys)  (P : α → Prop) : Any P xs → Any P ys := by induction perm; sorry",
  "name": "Perm.any",
  "kind": "theorem",
  "first-tactic": "induction perm",
  "core-prompt":
  "{xs ys : List α}  (perm : Perm xs ys)  (P : α → Prop) : Any P xs → Any P ys",
  "args": "{xs ys : List α}  (perm : Perm xs ys)  (P : α → Prop)"},
 {"type": "Any P Δ",
  "tactic-prompt":
  "theorem (P : Nat → Prop)  (Δ : List Nat) : Any P Δ := by aesop (add 50% [constructors Perm]; sorry",
  "name": "error",
  "kind": "theorem",
  "first-tactic": "aesop (add 50% [constructors Perm]",
  "core-prompt": "(P : Nat → Prop)  (Δ : List Nat) : Any P Δ",
  "args": "(P : Nat → Prop)  (Δ : List Nat)"},
 {"type": "Any P Δ",
  "tactic-prompt":
  "theorem (P : α → Prop)  (Δ : List α) : Any P Δ := by aesop (add unsafe [50% constructors Perm]; sorry",
  "name": "fine",
  "kind": "theorem",
  "first-tactic": "aesop (add unsafe [50% constructors Perm]",
  "core-prompt": "(P : α → Prop)  (Δ : List α) : Any P Δ",
  "args": "(P : α → Prop)  (Δ : List α)"},
 {"type": "Proof Γ (δ :: Δ)",
  "tactic-prompt":
  "theorem (Γ Δ : List Φ)  (prf : Proof Γ Δ)  (δ : Φ) : Proof Γ (δ :: Δ) := by induction prf; sorry",
  "name": "weaken",
  "kind": "theorem",
  "first-tactic": "induction prf",
  "core-prompt":
  "(Γ Δ : List Φ)  (prf : Proof Γ Δ)  (δ : Φ) : Proof Γ (δ :: Δ)",
  "args": "(Γ Δ : List Φ)  (prf : Proof Γ Δ)  (δ : Φ)"},
 {"type": "P x ∧ All P xs",
  "tactic-prompt":
  "theorem (P : α → Prop)  (x : α)  (xs : List α)  (h : All P (x :: xs)) : P x ∧ All P xs := by set_option trace.aesop.proof true in\n  aesop; sorry",
  "name": "All.split_cons",
  "kind": "theorem",
  "first-tactic": "set_option trace.aesop.proof true in\n  aesop",
  "core-prompt":
  "(P : α → Prop)  (x : α)  (xs : List α)  (h : All P (x :: xs)) : P x ∧ All P xs",
  "args": "(P : α → Prop)  (x : α)  (xs : List α)  (h : All P (x :: xs))"},
 {"type": "f = Function.const α (f default)",
  "tactic-prompt":
  "theorem [Unique α]  (f : α → β) : f = Function.const α (f default) := by ext x; sorry",
  "name": "eq_const_of_unique",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt": "[Unique α]  (f : α → β) : f = Function.const α (f default)",
  "args": "[Unique α]  (f : α → β)"},
 {"type": "∃ y, y ≠ x",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} [Nontrivial α]  [DecidableEq α]  (x : α) : ∃ y, y ≠ x := by rcases exists_pair_ne α with ⟨y, y', h⟩; sorry",
  "name": "Decidable.exists_ne",
  "kind": "theorem",
  "first-tactic": "rcases exists_pair_ne α with ⟨y, y', h⟩",
  "core-prompt":
  "{α : Type _}  {β : Type _} [Nontrivial α]  [DecidableEq α]  (x : α) : ∃ y, y ≠ x",
  "args":
  "{α : Type _}  {β : Type _} [Nontrivial α]  [DecidableEq α]  (x : α)"},
 {"type": "∃ y, y ≠ x",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} [Nontrivial α]  (x : α) : ∃ y, y ≠ x := by letI := Classical.decEq α; sorry",
  "name": "exists_ne",
  "kind": "theorem",
  "first-tactic": "letI := Classical.decEq α",
  "core-prompt":
  "{α : Type _}  {β : Type _} [Nontrivial α]  (x : α) : ∃ y, y ≠ x",
  "args": "{α : Type _}  {β : Type _} [Nontrivial α]  (x : α)"},
 {"type": "∃ x y : α, x < y",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} (α : Type _)  [Nontrivial α]  [LinearOrder α] : ∃ x y : α, x < y := by rcases exists_pair_ne α with ⟨x, y, hxy⟩; sorry",
  "name": "exists_pair_lt",
  "kind": "theorem",
  "first-tactic": "rcases exists_pair_ne α with ⟨x, y, hxy⟩",
  "core-prompt":
  "{α : Type _}  {β : Type _} (α : Type _)  [Nontrivial α]  [LinearOrder α] : ∃ x y : α, x < y",
  "args":
  "{α : Type _}  {β : Type _} (α : Type _)  [Nontrivial α]  [LinearOrder α]"},
 {"type": "Nontrivial (Subtype p) ↔ ∃ (y : α) (_ : p y), y ≠ x",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} (p : α → Prop)  (x : Subtype p) : Nontrivial (Subtype p) ↔ ∃ (y : α) (_ : p y), y ≠ x := by simp only [_root_.nontrivial_iff_exists_ne x]; sorry",
  "name": "Subtype.nontrivial_iff_exists_ne",
  "kind": "theorem",
  "first-tactic": "simp only [_root_.nontrivial_iff_exists_ne x]",
  "core-prompt":
  "{α : Type _}  {β : Type _} (p : α → Prop)  (x : Subtype p) : Nontrivial (Subtype p) ↔ ∃ (y : α) (_ : p y), y ≠ x",
  "args": "{α : Type _}  {β : Type _} (p : α → Prop)  (x : Subtype p)"},
 {"type": "¬Nontrivial α ↔ Subsingleton α",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} : ¬Nontrivial α ↔ Subsingleton α := by simp only [nontrivial_iff]; sorry",
  "name": "not_nontrivial_iff_subsingleton",
  "kind": "theorem",
  "first-tactic": "simp only [nontrivial_iff]",
  "core-prompt": "{α : Type _}  {β : Type _} : ¬Nontrivial α ↔ Subsingleton α",
  "args": "{α : Type _}  {β : Type _}"},
 {"type": "Subsingleton α ∨ Nontrivial α",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} (α : Type _) : Subsingleton α ∨ Nontrivial α := by rw [← not_nontrivial_iff_subsingleton]; sorry",
  "name": "subsingleton_or_nontrivial",
  "kind": "theorem",
  "first-tactic": "rw [← not_nontrivial_iff_subsingleton]",
  "core-prompt":
  "{α : Type _}  {β : Type _} (α : Type _) : Subsingleton α ∨ Nontrivial α",
  "args": "{α : Type _}  {β : Type _} (α : Type _)"},
 {"type": "Nontrivial (Option α)",
  "tactic-prompt":
  "instance {α : Type _}  {β : Type _} [Nonempty α] : Nontrivial (Option α) := by inhabit α; sorry",
  "name": "Option.nontrivial",
  "kind": "instance",
  "first-tactic": "inhabit α",
  "core-prompt":
  "{α : Type _}  {β : Type _} [Nonempty α] : Nontrivial (Option α)",
  "args": "{α : Type _}  {β : Type _} [Nonempty α]"},
 {"type": "Nontrivial α",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} [Nontrivial β]  {f : α → β}      (hf : Function.Surjective f) : Nontrivial α := by rcases exists_pair_ne β with ⟨x, y, h⟩; sorry",
  "name": "Function.Surjective.nontrivial",
  "kind": "theorem",
  "first-tactic": "rcases exists_pair_ne β with ⟨x, y, h⟩",
  "core-prompt":
  "{α : Type _}  {β : Type _} [Nontrivial β]  {f : α → β}      (hf : Function.Surjective f) : Nontrivial α",
  "args":
  "{α : Type _}  {β : Type _} [Nontrivial β]  {f : α → β}      (hf : Function.Surjective f)"},
 {"type": "∃ x, f x ≠ y",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} [Nontrivial α]  {f : α → β}      (hf : Function.Injective f)  (y : β) : ∃ x, f x ≠ y := by rcases exists_pair_ne α with ⟨x₁, x₂, hx⟩; sorry",
  "name": "Function.Injective.exists_ne",
  "kind": "theorem",
  "first-tactic": "rcases exists_pair_ne α with ⟨x₁, x₂, hx⟩",
  "core-prompt":
  "{α : Type _}  {β : Type _} [Nontrivial α]  {f : α → β}      (hf : Function.Injective f)  (y : β) : ∃ x, f x ≠ y",
  "args":
  "{α : Type _}  {β : Type _} [Nontrivial α]  {f : α → β}      (hf : Function.Injective f)  (y : β)"},
 {"type": "Nontrivial (∀ i : I, f i)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} {I : Type _}  {f : I → Type _} (i' : I)  [inst : ∀ i, Nonempty (f i)]  [Nontrivial (f i')] : Nontrivial (∀ i : I, f i) := by letI := Classical.decEq (∀ i : I, f i); sorry",
  "name": "nontrivial_at",
  "kind": "theorem",
  "first-tactic": "letI := Classical.decEq (∀ i : I, f i)",
  "core-prompt":
  "{α : Type _}  {β : Type _} {I : Type _}  {f : I → Type _} (i' : I)  [inst : ∀ i, Nonempty (f i)]  [Nontrivial (f i')] : Nontrivial (∀ i : I, f i)",
  "args":
  "{α : Type _}  {β : Type _} {I : Type _}  {f : I → Type _} (i' : I)  [inst : ∀ i, Nonempty (f i)]  [Nontrivial (f i')]"},
 {"type": "e.toEmbedding.trans e.symm.toEmbedding = Embedding.refl _",
  "tactic-prompt":
  "theorem {α β : Sort _}  (e : α ≃ β) : e.toEmbedding.trans e.symm.toEmbedding = Embedding.refl _ := by ext; sorry",
  "name": "equiv_toEmbedding_trans_symm_toEmbedding",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β : Sort _}  (e : α ≃ β) : e.toEmbedding.trans e.symm.toEmbedding = Embedding.refl _",
  "args": "{α β : Sort _}  (e : α ≃ β)"},
 {"type": "e.symm.toEmbedding.trans e.toEmbedding = Embedding.refl _",
  "tactic-prompt":
  "theorem {α β : Sort _}  (e : α ≃ β) : e.symm.toEmbedding.trans e.toEmbedding = Embedding.refl _ := by ext; sorry",
  "name": "equiv_symm_toEmbedding_trans_toEmbedding",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β : Sort _}  (e : α ≃ β) : e.symm.toEmbedding.trans e.toEmbedding = Embedding.refl _",
  "args": "{α β : Sort _}  (e : α ≃ β)"},
 {"type":
  "Equiv.embeddingCongr ea ec (f.trans g) =\n      (Equiv.embeddingCongr ea eb f).trans (Equiv.embeddingCongr eb ec g)",
  "tactic-prompt":
  "theorem {α₁ β₁ γ₁ α₂ β₂ γ₂ : Sort _}  (ea : α₁ ≃ α₂)  (eb : β₁ ≃ β₂)      (ec : γ₁ ≃ γ₂)  (f : α₁ ↪ β₁)  (g : β₁ ↪ γ₁) : Equiv.embeddingCongr ea ec (f.trans g) =\n      (Equiv.embeddingCongr ea eb f).trans (Equiv.embeddingCongr eb ec g) := by ext; sorry",
  "name": "embeddingCongr_apply_trans",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α₁ β₁ γ₁ α₂ β₂ γ₂ : Sort _}  (ea : α₁ ≃ α₂)  (eb : β₁ ≃ β₂)      (ec : γ₁ ≃ γ₂)  (f : α₁ ↪ β₁)  (g : β₁ ↪ γ₁) : Equiv.embeddingCongr ea ec (f.trans g) =\n      (Equiv.embeddingCongr ea eb f).trans (Equiv.embeddingCongr eb ec g)",
  "args":
  "{α₁ β₁ γ₁ α₂ β₂ γ₂ : Sort _}  (ea : α₁ ≃ α₂)  (eb : β₁ ≃ β₂)      (ec : γ₁ ≃ γ₂)  (f : α₁ ↪ β₁)  (g : β₁ ↪ γ₁)"},
 {"type": "(e : α → α) = id",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type _}  [Subsingleton α]  (e : Perm α) : (e : α → α) = id := by rw [Perm.subsingleton_eq_refl e]; sorry",
  "name": "Perm.coe_subsingleton",
  "kind": "theorem",
  "first-tactic": "rw [Perm.subsingleton_eq_refl e]",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type _}  [Subsingleton α]  (e : Perm α) : (e : α → α) = id",
  "args":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type _}  [Subsingleton α]  (e : Perm α)"},
 {"type": "f x = y ↔ x = f.symm y",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} (f : α ≃ β) : f x = y ↔ x = f.symm y := by conv_lhs => rw [← apply_symm_apply f y]; sorry",
  "name": "apply_eq_iff_eq_symm_apply",
  "kind": "theorem",
  "first-tactic": "conv_lhs => rw [← apply_symm_apply f y]",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} (f : α ≃ β) : f x = y ↔ x = f.symm y",
  "args": "{α : Sort u}  {β : Sort v}  {γ : Sort w} (f : α ≃ β)"},
 {"type": "e.symm.symm = e",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} (e : α ≃ β) : e.symm.symm = e := by cases e; sorry",
  "name": "symm_symm",
  "kind": "theorem",
  "first-tactic": "cases e",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} (e : α ≃ β) : e.symm.symm = e",
  "args": "{α : Sort u}  {β : Sort v}  {γ : Sort w} (e : α ≃ β)"},
 {"type": "e.trans (Equiv.refl β) = e",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} (e : α ≃ β) : e.trans (Equiv.refl β) = e := by cases e; sorry",
  "name": "trans_refl",
  "kind": "theorem",
  "first-tactic": "cases e",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} (e : α ≃ β) : e.trans (Equiv.refl β) = e",
  "args": "{α : Sort u}  {β : Sort v}  {γ : Sort w} (e : α ≃ β)"},
 {"type": "(Equiv.refl α).trans e = e",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} (e : α ≃ β) : (Equiv.refl α).trans e = e := by cases e; sorry",
  "name": "refl_trans",
  "kind": "theorem",
  "first-tactic": "cases e",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} (e : α ≃ β) : (Equiv.refl α).trans e = e",
  "args": "{α : Sort u}  {β : Sort v}  {γ : Sort w} (e : α ≃ β)"},
 {"type": "e.permCongr (Equiv.refl _) = Equiv.refl _",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w}  {α' β' : Type _}  (e : α' ≃ β') : e.permCongr (Equiv.refl _) = Equiv.refl _ := by simp [permCongr_def]; sorry",
  "name": "permCongr_refl",
  "kind": "theorem",
  "first-tactic": "simp [permCongr_def]",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w}  {α' β' : Type _}  (e : α' ≃ β') : e.permCongr (Equiv.refl _) = Equiv.refl _",
  "args":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w}  {α' β' : Type _}  (e : α' ≃ β')"},
 {"type": "(e.permCongr p).trans (e.permCongr p') = e.permCongr (p.trans p')",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w}  {α' β' : Type _}  (e : α' ≃ β') (p p' : Equiv.Perm α') : (e.permCongr p).trans (e.permCongr p') = e.permCongr (p.trans p') := by ext; sorry",
  "name": "permCongr_trans",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w}  {α' β' : Type _}  (e : α' ≃ β') (p p' : Equiv.Perm α') : (e.permCongr p).trans (e.permCongr p') = e.permCongr (p.trans p')",
  "args":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w}  {α' β' : Type _}  (e : α' ≃ β') (p p' : Equiv.Perm α')"},
 {"type": "arrowCongr ea ec (g ∘ f) = arrowCongr eb ec g ∘ arrowCongr ea eb f",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} {α₁ β₁ γ₁ α₂ β₂ γ₂ : Sort _}  (ea : α₁ ≃ α₂)  (eb : β₁ ≃ β₂)  (ec : γ₁ ≃ γ₂)      (f : α₁ → β₁)  (g : β₁ → γ₁) : arrowCongr ea ec (g ∘ f) = arrowCongr eb ec g ∘ arrowCongr ea eb f := by ext; sorry",
  "name": "arrowCongr_comp",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α₁ β₁ γ₁ α₂ β₂ γ₂ : Sort _}  (ea : α₁ ≃ α₂)  (eb : β₁ ≃ β₂)  (ec : γ₁ ≃ γ₂)      (f : α₁ → β₁)  (g : β₁ → γ₁) : arrowCongr ea ec (g ∘ f) = arrowCongr eb ec g ∘ arrowCongr ea eb f",
  "args":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α₁ β₁ γ₁ α₂ β₂ γ₂ : Sort _}  (ea : α₁ ≃ α₂)  (eb : β₁ ≃ β₂)  (ec : γ₁ ≃ γ₂)      (f : α₁ → β₁)  (g : β₁ → γ₁)"},
 {"type": "e.conj (f₁ ∘ f₂) = e.conj f₁ ∘ e.conj f₂",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} (e : α ≃ β)  (f₁ f₂ : α → α) : e.conj (f₁ ∘ f₂) = e.conj f₁ ∘ e.conj f₂ := by apply arrowCongr_comp; sorry",
  "name": "conj_comp",
  "kind": "theorem",
  "first-tactic": "apply arrowCongr_comp",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} (e : α ≃ β)  (f₁ f₂ : α → α) : e.conj (f₁ ∘ f₂) = e.conj f₁ ∘ e.conj f₂",
  "args":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} (e : α ≃ β)  (f₁ f₂ : α → α)"},
 {"type": "(∃! x, p x) ↔ ∃! y, q y",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} {p : α → Prop}  {q : β → Prop}      (f : α ≃ β)  (h : ∀ {x}, p x ↔ q (f x)) : (∃! x, p x) ↔ ∃! y, q y := by constructor; sorry",
  "name": "exists_unique_congr",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {p : α → Prop}  {q : β → Prop}      (f : α ≃ β)  (h : ∀ {x}, p x ↔ q (f x)) : (∃! x, p x) ↔ ∃! y, q y",
  "args":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {p : α → Prop}  {q : β → Prop}      (f : α ≃ β)  (h : ∀ {x}, p x ↔ q (f x))"},
 {"type": "(∀ x, p x) ↔ (∀ y, q y)",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} {p : α → Prop}  {q : β → Prop}  (f : α ≃ β)      (h : ∀ {x}, p x ↔ q (f x)) : (∀ x, p x) ↔ (∀ y, q y) := by constructor; sorry",
  "name": "forall_congr",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {p : α → Prop}  {q : β → Prop}  (f : α ≃ β)      (h : ∀ {x}, p x ↔ q (f x)) : (∀ x, p x) ↔ (∀ y, q y)",
  "args":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {p : α → Prop}  {q : β → Prop}  (f : α ≃ β)      (h : ∀ {x}, p x ↔ q (f x))"},
 {"type":
  "(Equiv.sumCongr e f).trans (Equiv.sumCongr g h) = Equiv.sumCongr (e.trans g) (f.trans h)",
  "tactic-prompt":
  "theorem (e : α₁ ≃ β₁)  (f : α₂ ≃ β₂)  (g : β₁ ≃ γ₁)  (h : β₂ ≃ γ₂) : (Equiv.sumCongr e f).trans (Equiv.sumCongr g h) = Equiv.sumCongr (e.trans g) (f.trans h) := by ext i; sorry",
  "name": "sumCongr_trans",
  "kind": "theorem",
  "first-tactic": "ext i",
  "core-prompt":
  "(e : α₁ ≃ β₁)  (f : α₂ ≃ β₂)  (g : β₁ ≃ γ₁)  (h : β₂ ≃ γ₂) : (Equiv.sumCongr e f).trans (Equiv.sumCongr g h) = Equiv.sumCongr (e.trans g) (f.trans h)",
  "args": "(e : α₁ ≃ β₁)  (f : α₂ ≃ β₂)  (g : β₁ ≃ γ₁)  (h : β₂ ≃ γ₂)"},
 {"type": "Equiv.sumCongr (Equiv.refl α) (Equiv.refl β) = Equiv.refl (Sum α β)",
  "tactic-prompt":
  "theorem  : Equiv.sumCongr (Equiv.refl α) (Equiv.refl β) = Equiv.refl (Sum α β) := by ext i; sorry",
  "name": "sumCongr_refl",
  "kind": "theorem",
  "first-tactic": "ext i",
  "core-prompt":
  " : Equiv.sumCongr (Equiv.refl α) (Equiv.refl β) = Equiv.refl (Sum α β)",
  "args": ""},
 {"type":
  "ep.subtypeCongr en a =\n    if h : p a then (ep ⟨a, h⟩ : ε) else en ⟨a, h⟩",
  "tactic-prompt":
  "theorem {p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a }) (a : ε) : ep.subtypeCongr en a =\n    if h : p a then (ep ⟨a, h⟩ : ε) else en ⟨a, h⟩ := by by_cases h : p a; sorry",
  "name": "Perm.subtypeCongr.apply",
  "kind": "theorem",
  "first-tactic": "by_cases h : p a",
  "core-prompt":
  "{p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a }) (a : ε) : ep.subtypeCongr en a =\n    if h : p a then (ep ⟨a, h⟩ : ε) else en ⟨a, h⟩",
  "args":
  "{p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a }) (a : ε)"},
 {"type": "ep.subtypeCongr en a = ep ⟨a, h⟩",
  "tactic-prompt":
  "theorem {p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a }) {a : ε}  (h : p a) : ep.subtypeCongr en a = ep ⟨a, h⟩ := by simp [Perm.subtypeCongr.apply]; sorry",
  "name": "Perm.subtypeCongr.left_apply",
  "kind": "theorem",
  "first-tactic": "simp [Perm.subtypeCongr.apply]",
  "core-prompt":
  "{p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a }) {a : ε}  (h : p a) : ep.subtypeCongr en a = ep ⟨a, h⟩",
  "args":
  "{p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a }) {a : ε}  (h : p a)"},
 {"type": "ep.subtypeCongr en a = en ⟨a, h⟩",
  "tactic-prompt":
  "theorem {p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a }) {a : ε}  (h : ¬p a) : ep.subtypeCongr en a = en ⟨a, h⟩ := by simp [Perm.subtypeCongr.apply]; sorry",
  "name": "Perm.subtypeCongr.right_apply",
  "kind": "theorem",
  "first-tactic": "simp [Perm.subtypeCongr.apply]",
  "core-prompt":
  "{p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a }) {a : ε}  (h : ¬p a) : ep.subtypeCongr en a = en ⟨a, h⟩",
  "args":
  "{p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a }) {a : ε}  (h : ¬p a)"},
 {"type":
  "Perm.subtypeCongr (Equiv.refl { a // p a }) (Equiv.refl { a // ¬p a }) = Equiv.refl ε",
  "tactic-prompt":
  "theorem {p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a }) : Perm.subtypeCongr (Equiv.refl { a // p a }) (Equiv.refl { a // ¬p a }) = Equiv.refl ε := by ext x; sorry",
  "name": "Perm.subtypeCongr.refl",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a }) : Perm.subtypeCongr (Equiv.refl { a // p a }) (Equiv.refl { a // ¬p a }) = Equiv.refl ε",
  "args":
  "{p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a })"},
 {"type": "(ep.subtypeCongr en).symm = Perm.subtypeCongr ep.symm en.symm",
  "tactic-prompt":
  "theorem {p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a }) : (ep.subtypeCongr en).symm = Perm.subtypeCongr ep.symm en.symm := by ext x; sorry",
  "name": "Perm.subtypeCongr.symm",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a }) : (ep.subtypeCongr en).symm = Perm.subtypeCongr ep.symm en.symm",
  "args":
  "{p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a })"},
 {"type":
  "(ep.subtypeCongr en).trans (ep'.subtypeCongr en')\n    = Perm.subtypeCongr (ep.trans ep') (en.trans en')",
  "tactic-prompt":
  "theorem {p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a }) : (ep.subtypeCongr en).trans (ep'.subtypeCongr en')\n    = Perm.subtypeCongr (ep.trans ep') (en.trans en') := by ext x; sorry",
  "name": "Perm.subtypeCongr.trans",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a }) : (ep.subtypeCongr en).trans (ep'.subtypeCongr en')\n    = Perm.subtypeCongr (ep.trans ep') (en.trans en')",
  "args":
  "{p : ε → Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // ¬p a })"},
 {"type": "prodCongr e (Equiv.refl α₁) = prodCongrLeft fun _ => e",
  "tactic-prompt":
  "theorem (e : α₁ → β₁ ≃ β₂) (e : β₁ ≃ β₂) : prodCongr e (Equiv.refl α₁) = prodCongrLeft fun _ => e := by ext ⟨a, b⟩ : 1; sorry",
  "name": "prodCongr_refl_right",
  "kind": "theorem",
  "first-tactic": "ext ⟨a, b⟩ : 1",
  "core-prompt":
  "(e : α₁ → β₁ ≃ β₂) (e : β₁ ≃ β₂) : prodCongr e (Equiv.refl α₁) = prodCongrLeft fun _ => e",
  "args": "(e : α₁ → β₁ ≃ β₂) (e : β₁ ≃ β₂)"},
 {"type": "prodCongr (Equiv.refl α₁) e = prodCongrRight fun _ => e",
  "tactic-prompt":
  "theorem (e : α₁ → β₁ ≃ β₂) (e : β₁ ≃ β₂) : prodCongr (Equiv.refl α₁) e = prodCongrRight fun _ => e := by ext ⟨a, b⟩ : 1; sorry",
  "name": "prodCongr_refl_left",
  "kind": "theorem",
  "first-tactic": "ext ⟨a, b⟩ : 1",
  "core-prompt":
  "(e : α₁ → β₁ ≃ β₂) (e : β₁ ≃ β₂) : prodCongr (Equiv.refl α₁) e = prodCongrRight fun _ => e",
  "args": "(e : α₁ → β₁ ≃ β₂) (e : β₁ ≃ β₂)"},
 {"type":
  "(prodCongrLeft e).trans (prodComm _ _) = (prodComm _ _).trans (prodCongrRight e)",
  "tactic-prompt":
  "theorem (e : α₁ → β₁ ≃ β₂) : (prodCongrLeft e).trans (prodComm _ _) = (prodComm _ _).trans (prodCongrRight e) := by ext ⟨a, b⟩ : 1; sorry",
  "name": "prodCongrLeft_trans_prodComm",
  "kind": "theorem",
  "first-tactic": "ext ⟨a, b⟩ : 1",
  "core-prompt":
  "(e : α₁ → β₁ ≃ β₂) : (prodCongrLeft e).trans (prodComm _ _) = (prodComm _ _).trans (prodCongrRight e)",
  "args": "(e : α₁ → β₁ ≃ β₂)"},
 {"type":
  "(prodCongrRight e).trans (prodComm _ _) = (prodComm _ _).trans (prodCongrLeft e)",
  "tactic-prompt":
  "theorem (e : α₁ → β₁ ≃ β₂) : (prodCongrRight e).trans (prodComm _ _) = (prodComm _ _).trans (prodCongrLeft e) := by ext ⟨a, b⟩ : 1; sorry",
  "name": "prodCongrRight_trans_prodComm",
  "kind": "theorem",
  "first-tactic": "ext ⟨a, b⟩ : 1",
  "core-prompt":
  "(e : α₁ → β₁ ≃ β₂) : (prodCongrRight e).trans (prodComm _ _) = (prodComm _ _).trans (prodCongrLeft e)",
  "args": "(e : α₁ → β₁ ≃ β₂)"},
 {"type":
  "(sigmaCongrRight e).trans (sigmaEquivProd α₁ β₂)\n    = (sigmaEquivProd α₁ β₁).trans (prodCongrRight e)",
  "tactic-prompt":
  "theorem (e : α₁ → β₁ ≃ β₂) : (sigmaCongrRight e).trans (sigmaEquivProd α₁ β₂)\n    = (sigmaEquivProd α₁ β₁).trans (prodCongrRight e) := by ext ⟨a, b⟩ : 1; sorry",
  "name": "sigmaCongrRight_sigmaEquivProd",
  "kind": "theorem",
  "first-tactic": "ext ⟨a, b⟩ : 1",
  "core-prompt":
  "(e : α₁ → β₁ ≃ β₂) : (sigmaCongrRight e).trans (sigmaEquivProd α₁ β₂)\n    = (sigmaEquivProd α₁ β₁).trans (prodCongrRight e)",
  "args": "(e : α₁ → β₁ ≃ β₂)"},
 {"type":
  "(sigmaEquivProd α₁ β₁).symm.trans (sigmaCongrRight e)\n    = (prodCongrRight e).trans (sigmaEquivProd α₁ β₂).symm",
  "tactic-prompt":
  "theorem (e : α₁ → β₁ ≃ β₂) : (sigmaEquivProd α₁ β₁).symm.trans (sigmaCongrRight e)\n    = (prodCongrRight e).trans (sigmaEquivProd α₁ β₂).symm := by ext ⟨a, b⟩ : 1; sorry",
  "name": "sigmaEquivProd_sigmaCongrRight",
  "kind": "theorem",
  "first-tactic": "ext ⟨a, b⟩ : 1",
  "core-prompt":
  "(e : α₁ → β₁ ≃ β₂) : (sigmaEquivProd α₁ β₁).symm.trans (sigmaCongrRight e)\n    = (prodCongrRight e).trans (sigmaEquivProd α₁ β₂).symm",
  "args": "(e : α₁ → β₁ ≃ β₂)"},
 {"type": "a' = a",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁) {e : Perm β₁}  {a a' : α₁}  {b : β₁}      (h : prodExtendRight a e (a', b) ≠ (a', b)) : a' = a := by contrapose! h; sorry",
  "name": "eq_of_prodExtendRight_ne",
  "kind": "theorem",
  "first-tactic": "contrapose! h",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁) {e : Perm β₁}  {a a' : α₁}  {b : β₁}      (h : prodExtendRight a e (a', b) ≠ (a', b)) : a' = a",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁) {e : Perm β₁}  {a a' : α₁}  {b : β₁}      (h : prodExtendRight a e (a', b) ≠ (a', b))"},
 {"type": "(prodExtendRight a e ab).fst = ab.fst",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁) (ab : α₁ × β₁) : (prodExtendRight a e ab).fst = ab.fst := by rw [prodExtendRight]; sorry",
  "name": "fst_prodExtendRight",
  "kind": "theorem",
  "first-tactic": "rw [prodExtendRight]",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁) (ab : α₁ × β₁) : (prodExtendRight a e ab).fst = ab.fst",
  "args": "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁) (ab : α₁ × β₁)"},
 {"type": "e.extendDomain f (f a) = f (e a)",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {α' β' : Type _}  (e : Perm α')  {p : β' → Prop}  [DecidablePred p]  (f : α' ≃ Subtype p) (a : α') : e.extendDomain f (f a) = f (e a) := by simp [Perm.extendDomain]; sorry",
  "name": "Perm.extendDomain_apply_image",
  "kind": "theorem",
  "first-tactic": "simp [Perm.extendDomain]",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {α' β' : Type _}  (e : Perm α')  {p : β' → Prop}  [DecidablePred p]  (f : α' ≃ Subtype p) (a : α') : e.extendDomain f (f a) = f (e a)",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {α' β' : Type _}  (e : Perm α')  {p : β' → Prop}  [DecidablePred p]  (f : α' ≃ Subtype p) (a : α')"},
 {"type": "e.extendDomain f b = f (e (f.symm ⟨b, h⟩))",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {α' β' : Type _}  (e : Perm α')  {p : β' → Prop}  [DecidablePred p]  (f : α' ≃ Subtype p) {b : β'}  (h : p b) : e.extendDomain f b = f (e (f.symm ⟨b, h⟩)) := by simp [Perm.extendDomain]; sorry",
  "name": "Perm.extendDomain_apply_subtype",
  "kind": "theorem",
  "first-tactic": "simp [Perm.extendDomain]",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {α' β' : Type _}  (e : Perm α')  {p : β' → Prop}  [DecidablePred p]  (f : α' ≃ Subtype p) {b : β'}  (h : p b) : e.extendDomain f b = f (e (f.symm ⟨b, h⟩))",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {α' β' : Type _}  (e : Perm α')  {p : β' → Prop}  [DecidablePred p]  (f : α' ≃ Subtype p) {b : β'}  (h : p b)"},
 {"type": "e.extendDomain f b = b",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {α' β' : Type _}  (e : Perm α')  {p : β' → Prop}  [DecidablePred p]  (f : α' ≃ Subtype p) {b : β'}  (h : ¬p b) : e.extendDomain f b = b := by simp [Perm.extendDomain]; sorry",
  "name": "Perm.extendDomain_apply_not_subtype",
  "kind": "theorem",
  "first-tactic": "simp [Perm.extendDomain]",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {α' β' : Type _}  (e : Perm α')  {p : β' → Prop}  [DecidablePred p]  (f : α' ≃ Subtype p) {b : β'}  (h : ¬p b) : e.extendDomain f b = b",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {α' β' : Type _}  (e : Perm α')  {p : β' → Prop}  [DecidablePred p]  (f : α' ≃ Subtype p) {b : β'}  (h : ¬p b)"},
 {"type": "Perm.extendDomain (Equiv.refl _) f = Equiv.refl _",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {α' β' : Type _}  (e : Perm α')  {p : β' → Prop}  [DecidablePred p]  (f : α' ≃ Subtype p) : Perm.extendDomain (Equiv.refl _) f = Equiv.refl _ := by simp [Perm.extendDomain]; sorry",
  "name": "Perm.extendDomain_refl",
  "kind": "theorem",
  "first-tactic": "simp [Perm.extendDomain]",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {α' β' : Type _}  (e : Perm α')  {p : β' → Prop}  [DecidablePred p]  (f : α' ≃ Subtype p) : Perm.extendDomain (Equiv.refl _) f = Equiv.refl _",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {α' β' : Type _}  (e : Perm α')  {p : β' → Prop}  [DecidablePred p]  (f : α' ≃ Subtype p)"},
 {"type":
  "(e.extendDomain f).trans (e'.extendDomain f) = Perm.extendDomain (e.trans e') f",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {α' β' : Type _}  (e : Perm α')  {p : β' → Prop}  [DecidablePred p]  (f : α' ≃ Subtype p) (e e' : Perm α') : (e.extendDomain f).trans (e'.extendDomain f) = Perm.extendDomain (e.trans e') f := by simp [Perm.extendDomain]; sorry",
  "name": "Perm.extendDomain_trans",
  "kind": "theorem",
  "first-tactic": "simp [Perm.extendDomain]",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {α' β' : Type _}  (e : Perm α')  {p : β' → Prop}  [DecidablePred p]  (f : α' ≃ Subtype p) (e e' : Perm α') : (e.extendDomain f).trans (e'.extendDomain f) = Perm.extendDomain (e.trans e') f",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {α' β' : Type _}  (e : Perm α')  {p : β' → Prop}  [DecidablePred p]  (f : α' ≃ Subtype p) (e e' : Perm α')"},
 {"type": "swapCore a a r = r",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (r a : α) : swapCore a a r = r := by unfold swapCore; sorry",
  "name": "swapCore_self",
  "kind": "theorem",
  "first-tactic": "unfold swapCore",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (r a : α) : swapCore a a r = r",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (r a : α)"},
 {"type": "swapCore a b (swapCore a b r) = r",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (r a b : α) : swapCore a b (swapCore a b r) = r := by unfold swapCore; sorry",
  "name": "swapCore_swapCore",
  "kind": "theorem",
  "first-tactic": "unfold swapCore",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (r a b : α) : swapCore a b (swapCore a b r) = r",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (r a b : α)"},
 {"type": "swapCore a b r = swapCore b a r",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (r a b : α) : swapCore a b r = swapCore b a r := by unfold swapCore; sorry",
  "name": "swapCore_comm",
  "kind": "theorem",
  "first-tactic": "unfold swapCore",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (r a b : α) : swapCore a b r = swapCore b a r",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (r a b : α)"},
 {"type": "swap a b b = a",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (a b : α) : swap a b b = a := by by_cases h:b = a; sorry",
  "name": "swap_apply_right",
  "kind": "theorem",
  "first-tactic": "by_cases h:b = a",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (a b : α) : swap a b b = a",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (a b : α)"},
 {"type": "x ≠ a → x ≠ b → swap a b x = x",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {a b x : α} : x ≠ a → x ≠ b → swap a b x = x := by simp (config := { contextual := true }) [swap_apply_def]; sorry",
  "name": "swap_apply_of_ne_of_ne",
  "kind": "theorem",
  "first-tactic": "simp (config := { contextual := true }) [swap_apply_def]",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {a b x : α} : x ≠ a → x ≠ b → swap a b x = x",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {a b x : α}"},
 {"type": "swap x y = Equiv.refl _ ↔ x = y",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {x y : α} : swap x y = Equiv.refl _ ↔ x = y := by refine' ⟨fun h => (Equiv.refl _).injective _, fun h => h ▸ swap_self _⟩; sorry",
  "name": "swap_eq_refl_iff",
  "kind": "theorem",
  "first-tactic":
  "refine' ⟨fun h => (Equiv.refl _).injective _, fun h => h ▸ swap_self _⟩",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {x y : α} : swap x y = Equiv.refl _ ↔ x = y",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {x y : α}"},
 {"type":
  "π.trans (swap a b) x = if π x = a then b else if π x = b then a else π x",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {a b x : α}  (π : Perm α) : π.trans (swap a b) x = if π x = a then b else if π x = b then a else π x := by cases π; sorry",
  "name": "swap_comp_apply",
  "kind": "theorem",
  "first-tactic": "cases π",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {a b x : α}  (π : Perm α) : π.trans (swap a b) x = if π x = a then b else if π x = b then a else π x",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {a b x : α}  (π : Perm α)"},
 {"type": "f ∘ Equiv.swap i j = update (update f j (f i)) i (f j)",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (i j : α)  (f : α → β) : f ∘ Equiv.swap i j = update (update f j (f i)) i (f j) := by rw [swap_eq_update]; sorry",
  "name": "comp_swap_eq_update",
  "kind": "theorem",
  "first-tactic": "rw [swap_eq_update]",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (i j : α)  (f : α → β) : f ∘ Equiv.swap i j = update (update f j (f i)) i (f j)",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (i j : α)  (f : α → β)"},
 {"type": "swap i j (swap i j a) = a",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (i j a : α) : swap i j (swap i j a) = a := by rw [← Equiv.trans_apply]; sorry",
  "name": "swap_apply_self",
  "kind": "theorem",
  "first-tactic": "rw [← Equiv.trans_apply]",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (i j a : α) : swap i j (swap i j a) = a",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (i j a : α)"},
 {"type": "v (swap i j k) = v k",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {v : α → β}  {i j : α}  (hv : v i = v j)  (k : α) : v (swap i j k) = v k := by by_cases hi : k = i; sorry",
  "name": "apply_swap_eq_self",
  "kind": "theorem",
  "first-tactic": "by_cases hi : k = i",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {v : α → β}  {i j : α}  (hv : v i = v j)  (k : α) : v (swap i j k) = v k",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {v : α → β}  {i j : α}  (hv : v i = v j)  (k : α)"},
 {"type": "swap x y z = w ↔ z = swap x y w",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {x y z w : α} : swap x y z = w ↔ z = swap x y w := by rw [apply_eq_iff_eq_symm_apply]; sorry",
  "name": "swap_apply_eq_iff",
  "kind": "theorem",
  "first-tactic": "rw [apply_eq_iff_eq_symm_apply]",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {x y z w : α} : swap x y z = w ↔ z = swap x y w",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {x y z w : α}"},
 {"type": "swap a b x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {a b x : α} : swap a b x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b) := by by_cases hab : a = b; sorry",
  "name": "swap_apply_ne_self_iff",
  "kind": "theorem",
  "first-tactic": "by_cases hab : a = b",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {a b x : α} : swap a b x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {a b x : α}"},
 {"type":
  "Equiv.Perm.sumCongr (Equiv.swap i j) (Equiv.refl β) = Equiv.swap (Sum.inl i) (Sum.inl j)",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {α β : Sort _}  [DecidableEq α]  [DecidableEq β]  (i j : α) : Equiv.Perm.sumCongr (Equiv.swap i j) (Equiv.refl β) = Equiv.swap (Sum.inl i) (Sum.inl j) := by ext x; sorry",
  "name": "sumCongr_swap_refl",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {α β : Sort _}  [DecidableEq α]  [DecidableEq β]  (i j : α) : Equiv.Perm.sumCongr (Equiv.swap i j) (Equiv.refl β) = Equiv.swap (Sum.inl i) (Sum.inl j)",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {α β : Sort _}  [DecidableEq α]  [DecidableEq β]  (i j : α)"},
 {"type":
  "Equiv.Perm.sumCongr (Equiv.refl α) (Equiv.swap i j) = Equiv.swap (Sum.inr i) (Sum.inr j)",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {α β : Sort _}  [DecidableEq α]  [DecidableEq β]  (i j : β) : Equiv.Perm.sumCongr (Equiv.refl α) (Equiv.swap i j) = Equiv.swap (Sum.inr i) (Sum.inr j) := by ext x; sorry",
  "name": "sumCongr_refl_swap",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {α β : Sort _}  [DecidableEq α]  [DecidableEq β]  (i j : β) : Equiv.Perm.sumCongr (Equiv.refl α) (Equiv.swap i j) = Equiv.swap (Sum.inr i) (Sum.inr j)",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] {α β : Sort _}  [DecidableEq α]  [DecidableEq β]  (i j : β)"},
 {"type": "setValue f a b a = b",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (f : α ≃ β)  (a : α)  (b : β) : setValue f a b a = b := by simp [setValue]; sorry",
  "name": "setValue_eq",
  "kind": "theorem",
  "first-tactic": "simp [setValue]",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (f : α ≃ β)  (a : α)  (b : β) : setValue f a b a = b",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  [DecidableEq α] (f : α ≃ β)  (a : α)  (b : β)"},
 {"type": "f (Equiv.swap x y z) = Equiv.swap (f x) (f y) (f z)",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁) [DecidableEq α]  [DecidableEq β]  {f : α → β}      (hf : Function.Injective f)  (x y z : α) : f (Equiv.swap x y z) = Equiv.swap (f x) (f y) (f z) := by conv_rhs => rw [Equiv.swap_apply_def]; sorry",
  "name": "Function.Injective.map_swap",
  "kind": "theorem",
  "first-tactic": "conv_rhs => rw [Equiv.swap_apply_def]",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁) [DecidableEq α]  [DecidableEq β]  {f : α → β}      (hf : Function.Injective f)  (x y z : α) : f (Equiv.swap x y z) = Equiv.swap (f x) (f y) (f z)",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁) [DecidableEq α]  [DecidableEq β]  {f : α → β}      (hf : Function.Injective f)  (x y z : α)"},
 {"type": "h₁.piCongr h₂ f (h₁ a) = h₂ a (f a)",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {W : α → Sort w}  {Z : β → Sort z}  (h₁ : α ≃ β)  (h₂ : ∀ a : α, W a ≃ Z (h₁ a)) (f : ∀ a, W a)  (a : α) : h₁.piCongr h₂ f (h₁ a) = h₂ a (f a) := by change Eq.ndrec _ _ = _; sorry",
  "name": "piCongr_apply_apply",
  "kind": "theorem",
  "first-tactic": "change Eq.ndrec _ _ = _",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {W : α → Sort w}  {Z : β → Sort z}  (h₁ : α ≃ β)  (h₂ : ∀ a : α, W a ≃ Z (h₁ a)) (f : ∀ a, W a)  (a : α) : h₁.piCongr h₂ f (h₁ a) = h₂ a (f a)",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {W : α → Sort w}  {Z : β → Sort z}  (h₁ : α ≃ β)  (h₂ : ∀ a : α, W a ≃ Z (h₁ a)) (f : ∀ a, W a)  (a : α)"},
 {"type": "(h₁.piCongr' h₂).symm f (h₁.symm b) = (h₂ b).symm (f b)",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {W : α → Sort w}  {Z : β → Sort z}  (h₁ : α ≃ β)  (h₂ : ∀ b : β, W (h₁.symm b) ≃ Z b) (f : ∀ b, Z b)  (b : β) : (h₁.piCongr' h₂).symm f (h₁.symm b) = (h₂ b).symm (f b) := by change Eq.ndrec _ _ = _; sorry",
  "name": "piCongr'_symm_apply_symm_apply",
  "kind": "theorem",
  "first-tactic": "change Eq.ndrec _ _ = _",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {W : α → Sort w}  {Z : β → Sort z}  (h₁ : α ≃ β)  (h₂ : ∀ b : β, W (h₁.symm b) ≃ Z b) (f : ∀ b, Z b)  (b : β) : (h₁.piCongr' h₂).symm f (h₁.symm b) = (h₂ b).symm (f b)",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁)  {W : α → Sort w}  {Z : β → Sort z}  (h₁ : α ≃ β)  (h₂ : ∀ b : β, W (h₁.symm b) ≃ Z b) (f : ∀ b, Z b)  (b : β)"},
 {"type": "Equiv.swap (f x) (f y) (f z) = f (Equiv.swap x y z)",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁) [DecidableEq α]  [DecidableEq β]  {f : α → β}  (hf : Function.Injective f)  (x y z : α) : Equiv.swap (f x) (f y) (f z) = f (Equiv.swap x y z) := by by_cases hx:z = x; sorry",
  "name": "Function.Injective.swap_apply",
  "kind": "theorem",
  "first-tactic": "by_cases hx:z = x",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁) [DecidableEq α]  [DecidableEq β]  {f : α → β}  (hf : Function.Injective f)  (x y z : α) : Equiv.swap (f x) (f y) (f z) = f (Equiv.swap x y z)",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁) [DecidableEq α]  [DecidableEq β]  {f : α → β}  (hf : Function.Injective f)  (x y z : α)"},
 {"type": "update f a v ∘ g = update (f ∘ g) (g.symm a) v",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁) [DecidableEq α']  [DecidableEq α]  (f : α → β)      (g : α' ≃ α)  (a : α)  (v : β) : update f a v ∘ g = update (f ∘ g) (g.symm a) v := by rw [← update_comp_eq_of_injective _ g.injective]; sorry",
  "name": "update_comp_equiv",
  "kind": "theorem",
  "first-tactic": "rw [← update_comp_eq_of_injective _ g.injective]",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁) [DecidableEq α']  [DecidableEq α]  (f : α → β)      (g : α' ≃ α)  (a : α)  (v : β) : update f a v ∘ g = update (f ∘ g) (g.symm a) v",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁) [DecidableEq α']  [DecidableEq α]  (f : α → β)      (g : α' ≃ α)  (a : α)  (v : β)"},
 {"type":
  "e.piCongrLeft' P (update f (e.symm b) x) = update (e.piCongrLeft' P f) b x",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁) [DecidableEq α]  [DecidableEq β]  (P : α → Sort _)  (e : α ≃ β)      (f : ∀ a, P a)  (b : β)  (x : P (e.symm b)) : e.piCongrLeft' P (update f (e.symm b) x) = update (e.piCongrLeft' P f) b x := by ext b'; sorry",
  "name": "piCongrLeft'_update",
  "kind": "theorem",
  "first-tactic": "ext b'",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁) [DecidableEq α]  [DecidableEq β]  (P : α → Sort _)  (e : α ≃ β)      (f : ∀ a, P a)  (b : β)  (x : P (e.symm b)) : e.piCongrLeft' P (update f (e.symm b) x) = update (e.piCongrLeft' P f) b x",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁) [DecidableEq α]  [DecidableEq β]  (P : α → Sort _)  (e : α ≃ β)      (f : ∀ a, P a)  (b : β)  (x : P (e.symm b))"},
 {"type":
  "(e.piCongrLeft' P).symm (update f b x) = update ((e.piCongrLeft' P).symm f) (e.symm b) x",
  "tactic-prompt":
  "theorem [DecidableEq α₁]  (a : α₁)  (e : Perm β₁) [DecidableEq α]  [DecidableEq β]  (P : α → Sort _)  (e : α ≃ β)      (f : ∀ b, P (e.symm b))  (b : β)  (x : P (e.symm b)) : (e.piCongrLeft' P).symm (update f b x) = update ((e.piCongrLeft' P).symm f) (e.symm b) x := by simp [(e.piCongrLeft' P).symm_apply_eq]; sorry",
  "name": "piCongrLeft'_symm_update",
  "kind": "theorem",
  "first-tactic": "simp [(e.piCongrLeft' P).symm_apply_eq]",
  "core-prompt":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁) [DecidableEq α]  [DecidableEq β]  (P : α → Sort _)  (e : α ≃ β)      (f : ∀ b, P (e.symm b))  (b : β)  (x : P (e.symm b)) : (e.piCongrLeft' P).symm (update f b x) = update ((e.piCongrLeft' P).symm f) (e.symm b) x",
  "args":
  "[DecidableEq α₁]  (a : α₁)  (e : Perm β₁) [DecidableEq α]  [DecidableEq β]  (P : α → Sort _)  (e : α ≃ β)      (f : ∀ b, P (e.symm b))  (b : β)  (x : P (e.symm b))"},
 {"type": "(Equiv.Set.sumCompl s).symm x = Sum.inl ⟨x, hx⟩",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type u}  {s : Set α}  [DecidablePred (· ∈ s)]  {x : α}      (hx : x ∈ s) : (Equiv.Set.sumCompl s).symm x = Sum.inl ⟨x, hx⟩ := by have : ((⟨x, Or.inl hx⟩ : (s ∪ sᶜ : Set α)) : α) ∈ s := hx; sorry",
  "name": "sumCompl_symm_apply_of_mem",
  "kind": "theorem",
  "first-tactic": "have : ((⟨x, Or.inl hx⟩ : (s ∪ sᶜ : Set α)) : α) ∈ s := hx",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type u}  {s : Set α}  [DecidablePred (· ∈ s)]  {x : α}      (hx : x ∈ s) : (Equiv.Set.sumCompl s).symm x = Sum.inl ⟨x, hx⟩",
  "args":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type u}  {s : Set α}  [DecidablePred (· ∈ s)]  {x : α}      (hx : x ∈ s)"},
 {"type": "(Equiv.Set.sumCompl s).symm x = Sum.inr ⟨x, hx⟩",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type u}  {s : Set α}  [DecidablePred (· ∈ s)]  {x : α}      (hx : x ∉ s) : (Equiv.Set.sumCompl s).symm x = Sum.inr ⟨x, hx⟩ := by have : ((⟨x, Or.inr hx⟩ : (s ∪ sᶜ : Set α)) : α) ∈ sᶜ := hx; sorry",
  "name": "sumCompl_symm_apply_of_not_mem",
  "kind": "theorem",
  "first-tactic": "have : ((⟨x, Or.inr hx⟩ : (s ∪ sᶜ : Set α)) : α) ∈ sᶜ := hx",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type u}  {s : Set α}  [DecidablePred (· ∈ s)]  {x : α}      (hx : x ∉ s) : (Equiv.Set.sumCompl s).symm x = Sum.inr ⟨x, hx⟩",
  "args":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type u}  {s : Set α}  [DecidablePred (· ∈ s)]  {x : α}      (hx : x ∉ s)"},
 {"type": "(Equiv.Set.sumCompl s).symm x = Sum.inl x",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type _}  {s : Set α}  [DecidablePred (· ∈ s)]  {x : s} : (Equiv.Set.sumCompl s).symm x = Sum.inl x := by cases' x with x hx; sorry",
  "name": "sumCompl_symm_apply",
  "kind": "theorem",
  "first-tactic": "cases' x with x hx",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type _}  {s : Set α}  [DecidablePred (· ∈ s)]  {x : s} : (Equiv.Set.sumCompl s).symm x = Sum.inl x",
  "args":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type _}  {s : Set α}  [DecidablePred (· ∈ s)]  {x : s}"},
 {"type": "(Equiv.Set.sumCompl s).symm x = Sum.inr x",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type _}  {s : Set α}  [DecidablePred (· ∈ s)]      {x : (sᶜ : Set α)} : (Equiv.Set.sumCompl s).symm x = Sum.inr x := by cases' x with x hx; sorry",
  "name": "sumCompl_symm_apply_compl",
  "kind": "theorem",
  "first-tactic": "cases' x with x hx",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type _}  {s : Set α}  [DecidablePred (· ∈ s)]      {x : (sᶜ : Set α)} : (Equiv.Set.sumCompl s).symm x = Sum.inr x",
  "args":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type _}  {s : Set α}  [DecidablePred (· ∈ s)]      {x : (sᶜ : Set α)}"},
 {"type":
  "ofLeftInverse f f_inv hf =\n      ofInjective f\n        ((em (Nonempty α)).elim (fun h => (hf h).injective) fun h _ _ _ => by\n          haveI : Subsingleton α := subsingleton_of_not_nonempty h\n          simp)",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} {α β : Type _}  (f : α → β)  (f_inv : Nonempty α → β → α)      (hf : ∀ h : Nonempty α, LeftInverse (f_inv h) f) : ofLeftInverse f f_inv hf =\n      ofInjective f\n        ((em (Nonempty α)).elim (fun h => (hf h).injective) fun h _ _ _ => by\n          haveI : Subsingleton α := subsingleton_of_not_nonempty h\n          simp) := by ext; sorry",
  "name": "ofLeftInverse_eq_ofInjective",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α β : Type _}  (f : α → β)  (f_inv : Nonempty α → β → α)      (hf : ∀ h : Nonempty α, LeftInverse (f_inv h) f) : ofLeftInverse f f_inv hf =\n      ofInjective f\n        ((em (Nonempty α)).elim (fun h => (hf h).injective) fun h _ _ _ => by\n          haveI : Subsingleton α := subsingleton_of_not_nonempty h\n          simp)",
  "args":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α β : Type _}  (f : α → β)  (f_inv : Nonempty α → β → α)      (hf : ∀ h : Nonempty α, LeftInverse (f_inv h) f)"},
 {"type": "ofLeftInverse' f f_inv hf = ofInjective f hf.injective",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} {α β : Type _}  (f : α → β)  (f_inv : β → α)      (hf : LeftInverse f_inv f) : ofLeftInverse' f f_inv hf = ofInjective f hf.injective := by ext; sorry",
  "name": "ofLeftInverse'_eq_ofInjective",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α β : Type _}  (f : α → β)  (f_inv : β → α)      (hf : LeftInverse f_inv f) : ofLeftInverse' f f_inv hf = ofInjective f hf.injective",
  "args":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α β : Type _}  (f : α → β)  (f_inv : β → α)      (hf : LeftInverse f_inv f)"},
 {"type":
  "(piEquivPiSubtypeProd p β).symm ⁻¹' pi univ s =\n      (pi univ fun i : { i // p i } => s i) ×ˢ pi univ fun i : { i // ¬p i } => s i",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type _}  {β : α → Type _}  (p : α → Prop)      [DecidablePred p]  (s : ∀ i, Set (β i)) : (piEquivPiSubtypeProd p β).symm ⁻¹' pi univ s =\n      (pi univ fun i : { i // p i } => s i) ×ˢ pi univ fun i : { i // ¬p i } => s i := by ext ⟨f, g⟩; sorry",
  "name": "preimage_piEquivPiSubtypeProd_symm_pi",
  "kind": "theorem",
  "first-tactic": "ext ⟨f, g⟩",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type _}  {β : α → Type _}  (p : α → Prop)      [DecidablePred p]  (s : ∀ i, Set (β i)) : (piEquivPiSubtypeProd p β).symm ⁻¹' pi univ s =\n      (pi univ fun i : { i // p i } => s i) ×ˢ pi univ fun i : { i // ¬p i } => s i",
  "args":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type _}  {β : α → Type _}  (p : α → Prop)      [DecidablePred p]  (s : ∀ i, Set (β i))"},
 {"type":
  "(fun i : α => if h : i ∈ s then (Function.update v j x) (e.symm ⟨i, h⟩) else w i) =\n      Function.update (fun i : α => if h : i ∈ s then v (e.symm ⟨i, h⟩) else w i) (e j) x",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type _}  {β : Sort _}  {γ : Sort _}  {s : Set α}  (e : β ≃ s)      (v : β → γ)  (w : α → γ)  (j : β)  (x : γ)  [DecidableEq β]  [DecidableEq α]      [∀ j, Decidable (j ∈ s)] : (fun i : α => if h : i ∈ s then (Function.update v j x) (e.symm ⟨i, h⟩) else w i) =\n      Function.update (fun i : α => if h : i ∈ s then v (e.symm ⟨i, h⟩) else w i) (e j) x := by ext i; sorry",
  "name": "dite_comp_equiv_update",
  "kind": "theorem",
  "first-tactic": "ext i",
  "core-prompt":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type _}  {β : Sort _}  {γ : Sort _}  {s : Set α}  (e : β ≃ s)      (v : β → γ)  (w : α → γ)  (j : β)  (x : γ)  [DecidableEq β]  [DecidableEq α]      [∀ j, Decidable (j ∈ s)] : (fun i : α => if h : i ∈ s then (Function.update v j x) (e.symm ⟨i, h⟩) else w i) =\n      Function.update (fun i : α => if h : i ∈ s then v (e.symm ⟨i, h⟩) else w i) (e j) x",
  "args":
  "{α : Sort u}  {β : Sort v}  {γ : Sort w} {α : Type _}  {β : Sort _}  {γ : Sort _}  {s : Set α}  (e : β ≃ s)      (v : β → γ)  (w : α → γ)  (j : β)  (x : γ)  [DecidableEq β]  [DecidableEq α]      [∀ j, Decidable (j ∈ s)]"},
 {"type": "some (removeNone_aux e x) = e (some x)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  (e : Option α ≃ Option β) {x : α}  (h : ∃ x', e (some x) = some x') : some (removeNone_aux e x) = e (some x) := by simp [removeNone_aux]; sorry",
  "name": "removeNone_aux_some",
  "kind": "theorem",
  "first-tactic": "simp [removeNone_aux]",
  "core-prompt":
  "{α β γ : Type _}  (e : Option α ≃ Option β) {x : α}  (h : ∃ x', e (some x) = some x') : some (removeNone_aux e x) = e (some x)",
  "args":
  "{α β γ : Type _}  (e : Option α ≃ Option β) {x : α}  (h : ∃ x', e (some x) = some x')"},
 {"type": "some (removeNone_aux e x) = e none",
  "tactic-prompt":
  "theorem {α β γ : Type _}  (e : Option α ≃ Option β) {x : α}  (h : e (some x) = none) : some (removeNone_aux e x) = e none := by simp [removeNone_aux]; sorry",
  "name": "removeNone_aux_none",
  "kind": "theorem",
  "first-tactic": "simp [removeNone_aux]",
  "core-prompt":
  "{α β γ : Type _}  (e : Option α ≃ Option β) {x : α}  (h : e (some x) = none) : some (removeNone_aux e x) = e none",
  "args":
  "{α β γ : Type _}  (e : Option α ≃ Option β) {x : α}  (h : e (some x) = none)"},
 {"type": "some (removeNone e x) = e none ↔ e.symm none = some x",
  "tactic-prompt":
  "theorem {α β γ : Type _}  (e : Option α ≃ Option β) {x : α} : some (removeNone e x) = e none ↔ e.symm none = some x := by cases' h : e (some x) with a; sorry",
  "name": "some_removeNone_iff",
  "kind": "theorem",
  "first-tactic": "cases' h : e (some x) with a",
  "core-prompt":
  "{α β γ : Type _}  (e : Option α ≃ Option β) {x : α} : some (removeNone e x) = e none ↔ e.symm none = some x",
  "args": "{α β γ : Type _}  (e : Option α ≃ Option β) {x : α}"},
 {"type": "↑((optionSubtype x e).symm b) = (e : Option α ≃ β).symm b",
  "tactic-prompt":
  "theorem {α β γ : Type _} [DecidableEq β]  (x : β)      (e : { e : Option α ≃ β // e none = x })      (b : { y : β // y ≠ x }) : ↑((optionSubtype x e).symm b) = (e : Option α ≃ β).symm b := by dsimp only [optionSubtype]; sorry",
  "name": "optionSubtype_apply_symm_apply",
  "kind": "theorem",
  "first-tactic": "dsimp only [optionSubtype]",
  "core-prompt":
  "{α β γ : Type _} [DecidableEq β]  (x : β)      (e : { e : Option α ≃ β // e none = x })      (b : { y : β // y ≠ x }) : ↑((optionSubtype x e).symm b) = (e : Option α ≃ β).symm b",
  "args":
  "{α β γ : Type _} [DecidableEq β]  (x : β)      (e : { e : Option α ≃ β // e none = x })      (b : { y : β // y ≠ x })"},
 {"type": "((optionSubtype x).symm e : Option α ≃ β).symm b = e.symm b",
  "tactic-prompt":
  "theorem {α β γ : Type _} [DecidableEq β]  (x : β)  (e : α ≃ { y : β // y ≠ x })      (b : { y : β // y ≠ x }) : ((optionSubtype x).symm e : Option α ≃ β).symm b = e.symm b := by simp only [optionSubtype]; sorry",
  "name": "optionSubtype_symm_apply_symm_apply",
  "kind": "theorem",
  "first-tactic": "simp only [optionSubtype]",
  "core-prompt":
  "{α β γ : Type _} [DecidableEq β]  (x : β)  (e : α ≃ { y : β // y ≠ x })      (b : { y : β // y ≠ x }) : ((optionSubtype x).symm e : Option α ≃ β).symm b = e.symm b",
  "args":
  "{α β γ : Type _} [DecidableEq β]  (x : β)  (e : α ≃ { y : β // y ≠ x })      (b : { y : β // y ≠ x })"},
 {"type": "IsEmpty (α → β)",
  "tactic-prompt":
  "example {α β γ : Sort _} [h : Nonempty α]  [IsEmpty β] : IsEmpty (α → β) := by infer_instance; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{α β γ : Sort _} [h : Nonempty α]  [IsEmpty β] : IsEmpty (α → β)",
  "args": "{α β γ : Sort _} [h : Nonempty α]  [IsEmpty β]"},
 {"type": "IsEmpty p ↔ ¬p",
  "tactic-prompt":
  "theorem {α β γ : Sort _} [IsEmpty α] {p : Prop} : IsEmpty p ↔ ¬p := by simp only [← not_nonempty_iff]; sorry",
  "name": "isEmpty_Prop",
  "kind": "theorem",
  "first-tactic": "simp only [← not_nonempty_iff]",
  "core-prompt": "{α β γ : Sort _} [IsEmpty α] {p : Prop} : IsEmpty p ↔ ¬p",
  "args": "{α β γ : Sort _} [IsEmpty α] {p : Prop}"},
 {"type": "IsEmpty (∀ a, π a) ↔ ∃ a, IsEmpty (π a)",
  "tactic-prompt":
  "theorem {α β γ : Sort _} [IsEmpty α] {π : α → Sort _} : IsEmpty (∀ a, π a) ↔ ∃ a, IsEmpty (π a) := by simp only [← not_nonempty_iff]; sorry",
  "name": "isEmpty_pi",
  "kind": "theorem",
  "first-tactic": "simp only [← not_nonempty_iff]",
  "core-prompt":
  "{α β γ : Sort _} [IsEmpty α] {π : α → Sort _} : IsEmpty (∀ a, π a) ↔ ∃ a, IsEmpty (π a)",
  "args": "{α β γ : Sort _} [IsEmpty α] {π : α → Sort _}"},
 {"type": "IsEmpty (Subtype p) ↔ ∀ x, ¬p x",
  "tactic-prompt":
  "theorem {α β γ : Sort _} [IsEmpty α] (p : α → Prop) : IsEmpty (Subtype p) ↔ ∀ x, ¬p x := by simp only [← not_nonempty_iff]; sorry",
  "name": "isEmpty_subtype",
  "kind": "theorem",
  "first-tactic": "simp only [← not_nonempty_iff]",
  "core-prompt":
  "{α β γ : Sort _} [IsEmpty α] (p : α → Prop) : IsEmpty (Subtype p) ↔ ∀ x, ¬p x",
  "args": "{α β γ : Sort _} [IsEmpty α] (p : α → Prop)"},
 {"type": "IsEmpty (α × β) ↔ IsEmpty α ∨ IsEmpty β",
  "tactic-prompt":
  "theorem {α β γ : Sort _} [IsEmpty α] {α β : Type _} : IsEmpty (α × β) ↔ IsEmpty α ∨ IsEmpty β := by simp only [← not_nonempty_iff]; sorry",
  "name": "isEmpty_prod",
  "kind": "theorem",
  "first-tactic": "simp only [← not_nonempty_iff]",
  "core-prompt":
  "{α β γ : Sort _} [IsEmpty α] {α β : Type _} : IsEmpty (α × β) ↔ IsEmpty α ∨ IsEmpty β",
  "args": "{α β γ : Sort _} [IsEmpty α] {α β : Type _}"},
 {"type": "IsEmpty (PProd α β) ↔ IsEmpty α ∨ IsEmpty β",
  "tactic-prompt":
  "theorem {α β γ : Sort _} [IsEmpty α] : IsEmpty (PProd α β) ↔ IsEmpty α ∨ IsEmpty β := by simp only [← not_nonempty_iff]; sorry",
  "name": "isEmpty_pprod",
  "kind": "theorem",
  "first-tactic": "simp only [← not_nonempty_iff]",
  "core-prompt":
  "{α β γ : Sort _} [IsEmpty α] : IsEmpty (PProd α β) ↔ IsEmpty α ∨ IsEmpty β",
  "args": "{α β γ : Sort _} [IsEmpty α]"},
 {"type": "(f^[m + n]) x = (f^[m]) ((f^[n]) x)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v} (f : α → α) (m n : ℕ)  (x : α) : (f^[m + n]) x = (f^[m]) ((f^[n]) x) := by rw [iterate_add f m n]; sorry",
  "name": "iterate_add_apply",
  "kind": "theorem",
  "first-tactic": "rw [iterate_add f m n]",
  "core-prompt":
  "{α : Type u}  {β : Type v} (f : α → α) (m n : ℕ)  (x : α) : (f^[m + n]) x = (f^[m]) ((f^[n]) x)",
  "args": "{α : Type u}  {β : Type v} (f : α → α) (m n : ℕ)  (x : α)"},
 {"type": "Semiconj (f^[n]) (g k) (g <| n + k)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v} (f : α → α) {g : ℕ → α → α}  (H : ∀ n, Semiconj f (g n) (g <| n + 1))  (n k : ℕ) : Semiconj (f^[n]) (g k) (g <| n + k) := by induction' n with n ihn generalizing k; sorry",
  "name": "iterate_left",
  "kind": "theorem",
  "first-tactic": "induction' n with n ihn generalizing k",
  "core-prompt":
  "{α : Type u}  {β : Type v} (f : α → α) {g : ℕ → α → α}  (H : ∀ n, Semiconj f (g n) (g <| n + 1))  (n k : ℕ) : Semiconj (f^[n]) (g k) (g <| n + k)",
  "args":
  "{α : Type u}  {β : Type v} (f : α → α) {g : ℕ → α → α}  (H : ∀ n, Semiconj f (g n) (g <| n + 1))  (n k : ℕ)"},
 {"type": "(f ∘ g)^[n] = f^[n] ∘ g^[n]",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v} (f : α → α) {g : α → α} (h : Commute f g)  (n : ℕ) : (f ∘ g)^[n] = f^[n] ∘ g^[n] := by induction' n with n ihn; sorry",
  "name": "comp_iterate",
  "kind": "theorem",
  "first-tactic": "induction' n with n ihn",
  "core-prompt":
  "{α : Type u}  {β : Type v} (f : α → α) {g : α → α} (h : Commute f g)  (n : ℕ) : (f ∘ g)^[n] = f^[n] ∘ g^[n]",
  "args":
  "{α : Type u}  {β : Type v} (f : α → α) {g : α → α} (h : Commute f g)  (n : ℕ)"},
 {"type": "f^[n.succ] = f ∘ f^[n]",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v} (f : α → α) {g : α → α} (n : ℕ) : f^[n.succ] = f ∘ f^[n] := by rw [iterate_succ]; sorry",
  "name": "iterate_succ'",
  "kind": "theorem",
  "first-tactic": "rw [iterate_succ]",
  "core-prompt":
  "{α : Type u}  {β : Type v} (f : α → α) {g : α → α} (n : ℕ) : f^[n.succ] = f ∘ f^[n]",
  "args": "{α : Type u}  {β : Type v} (f : α → α) {g : α → α} (n : ℕ)"},
 {"type": "(f^[n.succ]) x = f ((f^[n]) x)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v} (f : α → α) {g : α → α} (n : ℕ)  (x : α) : (f^[n.succ]) x = f ((f^[n]) x) := by rw [iterate_succ']; sorry",
  "name": "iterate_succ_apply'",
  "kind": "theorem",
  "first-tactic": "rw [iterate_succ']",
  "core-prompt":
  "{α : Type u}  {β : Type v} (f : α → α) {g : α → α} (n : ℕ)  (x : α) : (f^[n.succ]) x = f ((f^[n]) x)",
  "args":
  "{α : Type u}  {β : Type v} (f : α → α) {g : α → α} (n : ℕ)  (x : α)"},
 {"type": "f^[n.pred] ∘ f = f^[n]",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v} (f : α → α) {g : α → α} {n : ℕ}  (hn : 0 < n) : f^[n.pred] ∘ f = f^[n] := by rw [← iterate_succ]; sorry",
  "name": "iterate_pred_comp_of_pos",
  "kind": "theorem",
  "first-tactic": "rw [← iterate_succ]",
  "core-prompt":
  "{α : Type u}  {β : Type v} (f : α → α) {g : α → α} {n : ℕ}  (hn : 0 < n) : f^[n.pred] ∘ f = f^[n]",
  "args":
  "{α : Type u}  {β : Type v} (f : α → α) {g : α → α} {n : ℕ}  (hn : 0 < n)"},
 {"type": "f ∘ f^[n.pred] = f^[n]",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v} (f : α → α) {g : α → α} {n : ℕ}  (hn : 0 < n) : f ∘ f^[n.pred] = f^[n] := by rw [← iterate_succ']; sorry",
  "name": "comp_iterate_pred_of_pos",
  "kind": "theorem",
  "first-tactic": "rw [← iterate_succ']",
  "core-prompt":
  "{α : Type u}  {β : Type v} (f : α → α) {g : α → α} {n : ℕ}  (hn : 0 < n) : f ∘ f^[n.pred] = f^[n]",
  "args":
  "{α : Type u}  {β : Type v} (f : α → α) {g : α → α} {n : ℕ}  (hn : 0 < n)"},
 {"type": "l.foldl (fun b _ ↦ f b) a = (f^[l.length]) a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v} (f : α → α) {g : α → α} (f : α → α)  (a : α)  (l : List β) : l.foldl (fun b _ ↦ f b) a = (f^[l.length]) a := by induction' l with b l H generalizing a; sorry",
  "name": "foldl_const",
  "kind": "theorem",
  "first-tactic": "induction' l with b l H generalizing a",
  "core-prompt":
  "{α : Type u}  {β : Type v} (f : α → α) {g : α → α} (f : α → α)  (a : α)  (l : List β) : l.foldl (fun b _ ↦ f b) a = (f^[l.length]) a",
  "args":
  "{α : Type u}  {β : Type v} (f : α → α) {g : α → α} (f : α → α)  (a : α)  (l : List β)"},
 {"type": "HEq f f'",
  "tactic-prompt":
  "lemma {α β γ : Sort _}  {f : α → β} {α α': Sort u}  {β : α → Sort v}  {β' : α' → Sort v}  {f : ∀a, β a}  {f' : ∀a, β' a}    (hα : α = α')  (h : ∀a a', HEq a a' → HEq (f a) (f' a')) : HEq f f' := by subst hα; sorry",
  "name": "hfunext",
  "kind": "lemma",
  "first-tactic": "subst hα",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} {α α': Sort u}  {β : α → Sort v}  {β' : α' → Sort v}  {f : ∀a, β a}  {f' : ∀a, β' a}    (hα : α = α')  (h : ∀a a', HEq a a' → HEq (f a) (f' a')) : HEq f f'",
  "args":
  "{α β γ : Sort _}  {f : α → β} {α α': Sort u}  {β : α → Sort v}  {β' : α' → Sort v}  {f : ∀a, β a}  {f' : ∀a, β' a}    (hα : α = α')  (h : ∀a a', HEq a a' → HEq (f a) (f' a'))"},
 {"type": "Function.Injective (λ x => if h : p x then f ⟨x, h⟩ else f' ⟨x, h⟩)",
  "tactic-prompt":
  "lemma {α β γ : Sort _}  {f : α → β} (p : α → Prop)  [DecidablePred p]    {f : {a : α // p a} → β}  {f' : {a : α // ¬ p a} → β}    (hf : Injective f)  (hf' : Injective f')    (im_disj : ∀ {x x' : α} {hx : p x} {hx' : ¬ p x'}, f ⟨x, hx⟩ ≠ f' ⟨x', hx'⟩) : Function.Injective (λ x => if h : p x then f ⟨x, h⟩ else f' ⟨x, h⟩) := by intros x₁ x₂ h; sorry",
  "name": "Injective.dite",
  "kind": "lemma",
  "first-tactic": "intros x₁ x₂ h",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} (p : α → Prop)  [DecidablePred p]    {f : {a : α // p a} → β}  {f' : {a : α // ¬ p a} → β}    (hf : Injective f)  (hf' : Injective f')    (im_disj : ∀ {x x' : α} {hx : p x} {hx' : ¬ p x'}, f ⟨x, hx⟩ ≠ f' ⟨x', hx'⟩) : Function.Injective (λ x => if h : p x then f ⟨x, h⟩ else f' ⟨x, h⟩)",
  "args":
  "{α β γ : Sort _}  {f : α → β} (p : α → Prop)  [DecidablePred p]    {f : {a : α // p a} → β}  {f' : {a : α // ¬ p a} → β}    (hf : Injective f)  (hf' : Injective f')    (im_disj : ∀ {x x' : α} {hx : p x} {hx' : ¬ p x'}, f ⟨x, hx⟩ ≠ f' ⟨x', hx'⟩)"},
 {"type": "Surjective f",
  "tactic-prompt":
  "theorem {α β γ : Sort _}  {f : α → β} (h : ∀ g₁ g₂ : β → Prop, g₁ ∘ f = g₂ ∘ f → g₁ = g₂) : Surjective f := by specialize h (fun y ↦ ∃ x, f x = y) (fun _ ↦ True) (funext fun x ↦ eq_true ⟨_, rfl⟩); sorry",
  "name": "surjective_of_right_cancellable_Prop",
  "kind": "theorem",
  "first-tactic":
  "specialize h (fun y ↦ ∃ x, f x = y) (fun _ ↦ True) (funext fun x ↦ eq_true ⟨_, rfl⟩)",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} (h : ∀ g₁ g₂ : β → Prop, g₁ ∘ f = g₂ ∘ f → g₁ = g₂) : Surjective f",
  "args":
  "{α β γ : Sort _}  {f : α → β} (h : ∀ g₁ g₂ : β → Prop, g₁ ∘ f = g₂ ∘ f → g₁ = g₂)"},
 {"type": "¬Surjective f",
  "tactic-prompt":
  "theorem {α β γ : Sort _}  {f : α → β} {α : Type u}  (f : α → Type max u v) : ¬Surjective f := by intro hf; sorry",
  "name": "not_surjective_Type",
  "kind": "theorem",
  "first-tactic": "intro hf",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} {α : Type u}  (f : α → Type max u v) : ¬Surjective f",
  "args": "{α β γ : Sort _}  {f : α → β} {α : Type u}  (f : α → Type max u v)"},
 {"type": "f (invFun f b) = b",
  "tactic-prompt":
  "theorem {α β : Sort _}  [Nonempty α]  {f : α → β}  {a : α}  {b : β} (h : ∃ a, f a = b) : f (invFun f b) = b := by simp only [invFun]; sorry",
  "name": "invFun_eq",
  "kind": "theorem",
  "first-tactic": "simp only [invFun]",
  "core-prompt":
  "{α β : Sort _}  [Nonempty α]  {f : α → β}  {a : α}  {b : β} (h : ∃ a, f a = b) : f (invFun f b) = b",
  "args":
  "{α β : Sort _}  [Nonempty α]  {f : α → β}  {a : α}  {b : β} (h : ∃ a, f a = b)"},
 {"type": "update f a' b a = if a = a' then b else f a",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} {β : Sort _}  (f : α → β)  (a' : α)  (b : β)  (a : α) : update f a' b a = if a = a' then b else f a := by have h2 : (h : a = a') → Eq.rec (motive := λ _ _ => β) b h.symm = b :=\n     by intro h\n        rw [eq_rec_constant]; sorry",
  "name": "update_apply",
  "kind": "theorem",
  "first-tactic":
  "have h2 : (h : a = a') → Eq.rec (motive := λ _ _ => β) b h.symm = b :=\n     by intro h\n        rw [eq_rec_constant]",
  "core-prompt":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} {β : Sort _}  (f : α → β)  (a' : α)  (b : β)  (a : α) : update f a' b a = if a = a' then b else f a",
  "args":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} {β : Sort _}  (f : α → β)  (a' : α)  (b : β)  (a : α)"},
 {"type": "(∀ x, p x (update f a b x)) ↔ p a b ∧ ∀ x, x ≠ a → p x (f x)",
  "tactic-prompt":
  "lemma {α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} (f : ∀a, β a)  {a : α}  {b : β a}  (p : ∀a, β a → Prop) : (∀ x, p x (update f a b x)) ↔ p a b ∧ ∀ x, x ≠ a → p x (f x) := by rw [← and_forall_ne a]; sorry",
  "name": "forall_update_iff",
  "kind": "lemma",
  "first-tactic": "rw [← and_forall_ne a]",
  "core-prompt":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} (f : ∀a, β a)  {a : α}  {b : β a}  (p : ∀a, β a → Prop) : (∀ x, p x (update f a b x)) ↔ p a b ∧ ∀ x, x ≠ a → p x (f x)",
  "args":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} (f : ∀a, β a)  {a : α}  {b : β a}  (p : ∀a, β a → Prop)"},
 {"type":
  "(∃ x, p x (update f a b x)) ↔ p a b ∨ ∃ (x : _)(_ : x ≠ a), p x (f x)",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} (f : ∀ a, β a)  {a : α}  {b : β a}  (p : ∀ a, β a → Prop) : (∃ x, p x (update f a b x)) ↔ p a b ∨ ∃ (x : _)(_ : x ≠ a), p x (f x) := by rw [← not_forall_not]; sorry",
  "name": "exists_update_iff",
  "kind": "theorem",
  "first-tactic": "rw [← not_forall_not]",
  "core-prompt":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} (f : ∀ a, β a)  {a : α}  {b : β a}  (p : ∀ a, β a → Prop) : (∃ x, p x (update f a b x)) ↔ p a b ∨ ∃ (x : _)(_ : x ≠ a), p x (f x)",
  "args":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} (f : ∀ a, β a)  {a : α}  {b : β a}  (p : ∀ a, β a → Prop)"},
 {"type": "update f a b = f ↔ b = f a",
  "tactic-prompt":
  "lemma {α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} : update f a b = f ↔ b = f a := by simp [update_eq_iff]; sorry",
  "name": "update_eq_self_iff",
  "kind": "lemma",
  "first-tactic": "simp [update_eq_iff]",
  "core-prompt":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} : update f a b = f ↔ b = f a",
  "args":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a}"},
 {"type": "f = update f a b ↔ f a = b",
  "tactic-prompt":
  "lemma {α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} : f = update f a b ↔ f a = b := by simp [eq_update_iff]; sorry",
  "name": "eq_update_self_iff",
  "kind": "lemma",
  "first-tactic": "simp [eq_update_iff]",
  "core-prompt":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} : f = update f a b ↔ f a = b",
  "args":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a}"},
 {"type": "f j (update g i v j) = update (fun k ↦ f k (g k)) i (f i v) j",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} {ι : Sort _}  [DecidableEq ι]  {α β : ι → Sort _}  (f : ∀ i, α i → β i)      (g : ∀ i, α i)  (i : ι)  (v : α i)  (j : ι) : f j (update g i v j) = update (fun k ↦ f k (g k)) i (f i v) j := by by_cases h:j = i; sorry",
  "name": "apply_update",
  "kind": "theorem",
  "first-tactic": "by_cases h:j = i",
  "core-prompt":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} {ι : Sort _}  [DecidableEq ι]  {α β : ι → Sort _}  (f : ∀ i, α i → β i)      (g : ∀ i, α i)  (i : ι)  (v : α i)  (j : ι) : f j (update g i v j) = update (fun k ↦ f k (g k)) i (f i v) j",
  "args":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} {ι : Sort _}  [DecidableEq ι]  {α β : ι → Sort _}  (f : ∀ i, α i → β i)      (g : ∀ i, α i)  (i : ι)  (v : α i)  (j : ι)"},
 {"type":
  "f j (update g i v j) (update h i w j) = update (fun k ↦ f k (g k) (h k)) i (f i v w) j",
  "tactic-prompt":
  "theorem {α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} {ι : Sort _}  [DecidableEq ι]  {α β γ : ι → Sort _}  (f : ∀ i, α i → β i → γ i)      (g : ∀ i, α i)  (h : ∀ i, β i)  (i : ι)  (v : α i)  (w : β i)  (j : ι) : f j (update g i v j) (update h i w j) = update (fun k ↦ f k (g k) (h k)) i (f i v w) j := by by_cases h:j = i; sorry",
  "name": "apply_update₂",
  "kind": "theorem",
  "first-tactic": "by_cases h:j = i",
  "core-prompt":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} {ι : Sort _}  [DecidableEq ι]  {α β γ : ι → Sort _}  (f : ∀ i, α i → β i → γ i)      (g : ∀ i, α i)  (h : ∀ i, β i)  (i : ι)  (v : α i)  (w : β i)  (j : ι) : f j (update g i v j) (update h i w j) = update (fun k ↦ f k (g k) (h k)) i (f i v w) j",
  "args":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α']    {f g : (a : α) → β a}  {a : α}  {b : β a} {ι : Sort _}  [DecidableEq ι]  {α β γ : ι → Sort _}  (f : ∀ i, α i → β i → γ i)      (g : ∀ i, α i)  (h : ∀ i, β i)  (i : ι)  (v : α i)  (w : β i)  (j : ι)"},
 {"type":
  "extend f g e' b = if h : ∃ a, f a = b then g (Classical.choose h) else e' b",
  "tactic-prompt":
  "theorem {α β γ : Sort _}  {f : α → β} (f : α → β)  (g : α → γ)  (e' : β → γ)  (b : β)  [Decidable (∃ a, f a = b)] : extend f g e' b = if h : ∃ a, f a = b then g (Classical.choose h) else e' b := by unfold extend; sorry",
  "name": "extend_def",
  "kind": "theorem",
  "first-tactic": "unfold extend",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} (f : α → β)  (g : α → γ)  (e' : β → γ)  (b : β)  [Decidable (∃ a, f a = b)] : extend f g e' b = if h : ∃ a, f a = b then g (Classical.choose h) else e' b",
  "args":
  "{α β γ : Sort _}  {f : α → β} (f : α → β)  (g : α → γ)  (e' : β → γ)  (b : β)  [Decidable (∃ a, f a = b)]"},
 {"type": "extend f g e' (f a) = g a",
  "tactic-prompt":
  "lemma {α β γ : Sort _}  {f : α → β} {g : α → γ}  (hf : g.FactorsThrough f)  (e' : β → γ)  (a : α) : extend f g e' (f a) = g a := by simp only [extend_def]; sorry",
  "name": "FactorsThrough.extend_apply",
  "kind": "lemma",
  "first-tactic": "simp only [extend_def]",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} {g : α → γ}  (hf : g.FactorsThrough f)  (e' : β → γ)  (a : α) : extend f g e' (f a) = g a",
  "args":
  "{α β γ : Sort _}  {f : α → β} {g : α → γ}  (hf : g.FactorsThrough f)  (e' : β → γ)  (a : α)"},
 {"type": "extend f g e' b = e' b",
  "tactic-prompt":
  "theorem {α β γ : Sort _}  {f : α → β} (g : α → γ)  (e' : β → γ)  (b : β)  (hb : ¬∃ a, f a = b) : extend f g e' b = e' b := by simp [Function.extend_def]; sorry",
  "name": "extend_apply'",
  "kind": "theorem",
  "first-tactic": "simp [Function.extend_def]",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} (g : α → γ)  (e' : β → γ)  (b : β)  (hb : ¬∃ a, f a = b) : extend f g e' b = e' b",
  "args":
  "{α β γ : Sort _}  {f : α → β} (g : α → γ)  (e' : β → γ)  (b : β)  (hb : ¬∃ a, f a = b)"},
 {"type": "Injective fun g ↦ extend f g e'",
  "tactic-prompt":
  "theorem {α β γ : Sort _}  {f : α → β} (hf : Injective f)  (e' : β → γ) : Injective fun g ↦ extend f g e' := by intro g₁ g₂ hg; sorry",
  "name": "extend_injective",
  "kind": "theorem",
  "first-tactic": "intro g₁ g₂ hg",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} (hf : Injective f)  (e' : β → γ) : Injective fun g ↦ extend f g e'",
  "args": "{α β γ : Sort _}  {f : α → β} (hf : Injective f)  (e' : β → γ)"},
 {"type": "f (ite P x (f x)) = ite (¬P) x (f x)",
  "tactic-prompt":
  "theorem {α : Sort u}  {f : α → α}  (h : Involutive f) (P : Prop)  [Decidable P]  (x : α) : f (ite P x (f x)) = ite (¬P) x (f x) := by rw [apply_ite f]; sorry",
  "name": "ite_not",
  "kind": "theorem",
  "first-tactic": "rw [apply_ite f]",
  "core-prompt":
  "{α : Sort u}  {f : α → α}  (h : Involutive f) (P : Prop)  [Decidable P]  (x : α) : f (ite P x (f x)) = ite (¬P) x (f x)",
  "args":
  "{α : Sort u}  {f : α → α}  (h : Involutive f) (P : Prop)  [Decidable P]  (x : α)"},
 {"type": "Function.Bijective (Eq.mp h)",
  "tactic-prompt":
  "theorem {α : Sort u}  {f : α → α}  (h : Involutive f) {α β γ : Sort _}  {f : α → β → γ} {α β : Sort _}  (h : α = β) : Function.Bijective (Eq.mp h) := by cases h; sorry",
  "name": "eq_mp_bijective",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{α : Sort u}  {f : α → α}  (h : Involutive f) {α β γ : Sort _}  {f : α → β → γ} {α β : Sort _}  (h : α = β) : Function.Bijective (Eq.mp h)",
  "args":
  "{α : Sort u}  {f : α → α}  (h : Involutive f) {α β γ : Sort _}  {f : α → β → γ} {α β : Sort _}  (h : α = β)"},
 {"type": "Function.Bijective (Eq.mpr h)",
  "tactic-prompt":
  "theorem {α : Sort u}  {f : α → α}  (h : Involutive f) {α β γ : Sort _}  {f : α → β → γ} {α β : Sort _}  (h : α = β) : Function.Bijective (Eq.mpr h) := by cases h; sorry",
  "name": "eq_mpr_bijective",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{α : Sort u}  {f : α → α}  (h : Involutive f) {α β γ : Sort _}  {f : α → β → γ} {α β : Sort _}  (h : α = β) : Function.Bijective (Eq.mpr h)",
  "args":
  "{α : Sort u}  {f : α → α}  (h : Involutive f) {α β γ : Sort _}  {f : α → β → γ} {α β : Sort _}  (h : α = β)"},
 {"type": "Function.Bijective (cast h)",
  "tactic-prompt":
  "theorem {α : Sort u}  {f : α → α}  (h : Involutive f) {α β γ : Sort _}  {f : α → β → γ} {α β : Sort _}  (h : α = β) : Function.Bijective (cast h) := by cases h; sorry",
  "name": "cast_bijective",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{α : Sort u}  {f : α → α}  (h : Involutive f) {α β γ : Sort _}  {f : α → β → γ} {α β : Sort _}  (h : α = β) : Function.Bijective (cast h)",
  "args":
  "{α : Sort u}  {f : α → α}  (h : Involutive f) {α β γ : Sort _}  {f : α → β → γ} {α β : Sort _}  (h : α = β)"},
 {"type": "cast (congr_arg (fun a ↦ γ (f a)) (h a)) (C (g (f a))) = C a",
  "tactic-prompt":
  "theorem {α : Sort u}  {f : α → α}  (h : Involutive f) {α β γ : Sort _}  {f : α → β → γ} {α β : Sort _}  {γ : β → Sort v}  {f : α → β}  {g : β → α}      (h : Function.LeftInverse g f)  (C : ∀ a : α, γ (f a))  (a : α) : cast (congr_arg (fun a ↦ γ (f a)) (h a)) (C (g (f a))) = C a := by rw [cast_eq_iff_heq]; sorry",
  "name": "Function.LeftInverse.cast_eq",
  "kind": "theorem",
  "first-tactic": "rw [cast_eq_iff_heq]",
  "core-prompt":
  "{α : Sort u}  {f : α → α}  (h : Involutive f) {α β γ : Sort _}  {f : α → β → γ} {α β : Sort _}  {γ : β → Sort v}  {f : α → β}  {g : β → α}      (h : Function.LeftInverse g f)  (C : ∀ a : α, γ (f a))  (a : α) : cast (congr_arg (fun a ↦ γ (f a)) (h a)) (C (g (f a))) = C a",
  "args":
  "{α : Sort u}  {f : α → α}  (h : Involutive f) {α β γ : Sort _}  {f : α → β → γ} {α β : Sort _}  {γ : β → Sort v}  {f : α → β}  {g : β → α}      (h : Function.LeftInverse g f)  (C : ∀ a : α, γ (f a))  (a : α)"},
 {"type": "f x = g y",
  "tactic-prompt":
  "theorem {α β γ : Sort _}  {f : α → γ}  {g : β → γ}  {x : α}  {y : β}      (h₁ : HEq f g)  (h₂ : HEq x y) : f x = g y := by cases h₂; sorry",
  "name": "congr_heq",
  "kind": "theorem",
  "first-tactic": "cases h₂",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → γ}  {g : β → γ}  {x : α}  {y : β}      (h₁ : HEq f g)  (h₂ : HEq x y) : f x = g y",
  "args":
  "{α β γ : Sort _}  {f : α → γ}  {g : β → γ}  {x : α}  {y : β}      (h₁ : HEq f g)  (h₂ : HEq x y)"},
 {"type": "Eq True = id",
  "tactic-prompt": "theorem  : Eq True = id := by funext _; sorry",
  "name": "eq_true_eq_id",
  "kind": "theorem",
  "first-tactic": "funext _",
  "core-prompt": " : Eq True = id",
  "args": ""},
 {"type": "Xor' True = Not",
  "tactic-prompt": "theorem  : Xor' True = Not := by simp [Xor']; sorry",
  "name": "xor_true",
  "kind": "theorem",
  "first-tactic": "simp [Xor']",
  "core-prompt": " : Xor' True = Not",
  "args": ""},
 {"type": "Xor' False = id",
  "tactic-prompt": "theorem  : Xor' False = id := by ext; sorry",
  "name": "xor_false",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt": " : Xor' False = id",
  "args": ""},
 {"type": "Xor' a a = False",
  "tactic-prompt":
  "theorem (a : Prop) : Xor' a a = False := by simp [Xor']; sorry",
  "name": "xor_self",
  "kind": "theorem",
  "first-tactic": "simp [Xor']",
  "core-prompt": "(a : Prop) : Xor' a a = False",
  "args": "(a : Prop)"},
 {"type": "Xor' (¬a) b ↔ (a ↔ b)",
  "tactic-prompt": "theorem  : Xor' (¬a) b ↔ (a ↔ b) := by by_cases a; sorry",
  "name": "xor_not_left",
  "kind": "theorem",
  "first-tactic": "by_cases a",
  "core-prompt": " : Xor' (¬a) b ↔ (a ↔ b)",
  "args": ""},
 {"type": "Xor' a (¬b) ↔ (a ↔ b)",
  "tactic-prompt": "theorem  : Xor' a (¬b) ↔ (a ↔ b) := by by_cases a; sorry",
  "name": "xor_not_right",
  "kind": "theorem",
  "first-tactic": "by_cases a",
  "core-prompt": " : Xor' a (¬b) ↔ (a ↔ b)",
  "args": ""},
 {"type": "Xor' (¬a) (¬b) ↔ Xor' a b",
  "tactic-prompt":
  "theorem  : Xor' (¬a) (¬b) ↔ Xor' a b := by simp [Xor']; sorry",
  "name": "xor_not_not",
  "kind": "theorem",
  "first-tactic": "simp [Xor']",
  "core-prompt": " : Xor' (¬a) (¬b) ↔ Xor' a b",
  "args": ""},
 {"type": "p ∧ a = b ↔ p ∧ b = a",
  "tactic-prompt":
  "theorem (a b : α)  (p : Prop) : p ∧ a = b ↔ p ∧ b = a := by simp [eq_comm]; sorry",
  "name": "and_symm_right",
  "kind": "theorem",
  "first-tactic": "simp [eq_comm]",
  "core-prompt": "(a b : α)  (p : Prop) : p ∧ a = b ↔ p ∧ b = a",
  "args": "(a b : α)  (p : Prop)"},
 {"type": "a = b ∧ p ↔ b = a ∧ p",
  "tactic-prompt":
  "theorem (a b : α)  (p : Prop) : a = b ∧ p ↔ b = a ∧ p := by simp [eq_comm]; sorry",
  "name": "and_symm_left",
  "kind": "theorem",
  "first-tactic": "simp [eq_comm]",
  "core-prompt": "(a b : α)  (p : Prop) : a = b ∧ p ↔ b = a ∧ p",
  "args": "(a b : α)  (p : Prop)"},
 {"type": "¬Xor' P Q ↔ (P ↔ Q)",
  "tactic-prompt":
  "theorem (P Q : Prop) : ¬Xor' P Q ↔ (P ↔ Q) := by simp only [not_and]; sorry",
  "name": "not_xor",
  "kind": "theorem",
  "first-tactic": "simp only [not_and]",
  "core-prompt": "(P Q : Prop) : ¬Xor' P Q ↔ (P ↔ Q)",
  "args": "(P Q : Prop)"},
 {"type": "Xor' a b ↔ (a ↔ ¬b)",
  "tactic-prompt":
  "theorem  : Xor' a b ↔ (a ↔ ¬b) := by simp only [← @xor_not_right a]; sorry",
  "name": "xor_iff_iff_not",
  "kind": "theorem",
  "first-tactic": "simp only [← @xor_not_right a]",
  "core-prompt": " : Xor' a b ↔ (a ↔ ¬b)",
  "args": ""},
 {"type": "Xor' a b ↔ (¬a ↔ b)",
  "tactic-prompt":
  "theorem  : Xor' a b ↔ (¬a ↔ b) := by simp only [← @xor_not_left _ b]; sorry",
  "name": "xor_iff_not_iff'",
  "kind": "theorem",
  "first-tactic": "simp only [← @xor_not_left _ b]",
  "core-prompt": " : Xor' a b ↔ (¬a ↔ b)",
  "args": ""},
 {"type": "HEq (@Eq.ndrec α a C x b e) y",
  "tactic-prompt":
  "theorem {C : α → Sort _}  {x : C a}  {y : β}  (e : a = b)  (h : HEq x y) : HEq (@Eq.ndrec α a C x b e) y := by subst e; sorry",
  "name": "rec_heq_of_heq",
  "kind": "theorem",
  "first-tactic": "subst e",
  "core-prompt":
  "{C : α → Sort _}  {x : C a}  {y : β}  (e : a = b)  (h : HEq x y) : HEq (@Eq.ndrec α a C x b e) y",
  "args": "{C : α → Sort _}  {x : C a}  {y : β}  (e : a = b)  (h : HEq x y)"},
 {"type": "x₁ = x₂ ↔ y₁ = y₂",
  "tactic-prompt":
  "theorem (h₁ : x₁ = y₁)  (h₂ : x₂ = y₂) : x₁ = x₂ ↔ y₁ = y₂ := by subst h₁; sorry",
  "name": "Eq.congr",
  "kind": "theorem",
  "first-tactic": "subst h₁",
  "core-prompt": "(h₁ : x₁ = y₁)  (h₂ : x₂ = y₂) : x₁ = x₂ ↔ y₁ = y₂",
  "args": "(h₁ : x₁ = y₁)  (h₂ : x₂ = y₂)"},
 {"type": "x = z ↔ y = z",
  "tactic-prompt":
  "theorem {x y z : α}  (h : x = y) : x = z ↔ y = z := by rw [h]; sorry",
  "name": "Eq.congr_left",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{x y z : α}  (h : x = y) : x = z ↔ y = z",
  "args": "{x y z : α}  (h : x = y)"},
 {"type": "z = x ↔ z = y",
  "tactic-prompt":
  "theorem {x y z : α}  (h : x = y) : z = x ↔ z = y := by rw [h]; sorry",
  "name": "Eq.congr_right",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{x y z : α}  (h : x = y) : z = x ↔ z = y",
  "args": "{x y z : α}  (h : x = y)"},
 {"type": "(¬∃ x, ¬p x) ↔ ∀ x, p x",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} [∀ x, Decidable (p x)] : (¬∃ x, ¬p x) ↔ ∀ x, p x := by simp only [not_exists]; sorry",
  "name": "Decidable.not_exists_not",
  "kind": "theorem",
  "first-tactic": "simp only [not_exists]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} [∀ x, Decidable (p x)] : (¬∃ x, ¬p x) ↔ ∀ x, p x",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} [∀ x, Decidable (p x)]"},
 {"type": "(∀ x, p x) → b ↔ ∃ x, p x → b",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} [ha : Nonempty α] : (∀ x, p x) → b ↔ ∃ x, p x → b := by let ⟨a⟩ := ha; sorry",
  "name": "forall_imp_iff_exists_imp",
  "kind": "theorem",
  "first-tactic": "let ⟨a⟩ := ha",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} [ha : Nonempty α] : (∀ x, p x) → b ↔ ∃ x, p x → b",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} [ha : Nonempty α]"},
 {"type": "(∀ a, β a → True) ↔ True",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {β : α → Sort _} : (∀ a, β a → True) ↔ True := by simp; sorry",
  "name": "forall₂_true_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {β : α → Sort _} : (∀ a, β a → True) ↔ True",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {β : α → Sort _}"},
 {"type": "(∀ (a) (b : β a), γ a b → True) ↔ True",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {β : α → Sort _}  {γ : ∀ a, β a → Sort _} : (∀ (a) (b : β a), γ a b → True) ↔ True := by simp; sorry",
  "name": "forall₃_true_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {β : α → Sort _}  {γ : ∀ a, β a → Sort _} : (∀ (a) (b : β a), γ a b → True) ↔ True",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {β : α → Sort _}  {γ : ∀ a, β a → Sort _}"},
 {"type": "(p a ∧ ∀ (b) (_ : b ≠ a), p b) ↔ ∀ b, p b",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} (a : α) : (p a ∧ ∀ (b) (_ : b ≠ a), p b) ↔ ∀ b, p b := by simp only [← @forall_eq _ p a]; sorry",
  "name": "and_forall_ne",
  "kind": "theorem",
  "first-tactic": "simp only [← @forall_eq _ p a]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} (a : α) : (p a ∧ ∀ (b) (_ : b ≠ a), p b) ↔ ∀ b, p b",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} (a : α)"},
 {"type": "∃! a, a = a'",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α} : ∃! a, a = a' := by simp only [eq_comm]; sorry",
  "name": "exists_unique_eq",
  "kind": "theorem",
  "first-tactic": "simp only [eq_comm]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α} : ∃! a, a = a'",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α}"},
 {"type": "∃! a, a' = a",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α} : ∃! a, a' = a := by simp only [ExistsUnique]; sorry",
  "name": "exists_unique_eq'",
  "kind": "theorem",
  "first-tactic": "simp only [ExistsUnique]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α} : ∃! a, a' = a",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α}"},
 {"type": "(∀ a b, f a = b → p b) ↔ ∀ a, p (f a)",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop} : (∀ a b, f a = b → p b) ↔ ∀ a, p (f a) := by simp; sorry",
  "name": "forall_apply_eq_imp_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop} : (∀ a b, f a = b → p b) ↔ ∀ a, p (f a)",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop}"},
 {"type": "(∀ b a, f a = b → p b) ↔ ∀ a, p (f a)",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop} : (∀ b a, f a = b → p b) ↔ ∀ a, p (f a) := by simp [forall_swap]; sorry",
  "name": "forall_apply_eq_imp_iff'",
  "kind": "theorem",
  "first-tactic": "simp [forall_swap]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop} : (∀ b a, f a = b → p b) ↔ ∀ a, p (f a)",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop}"},
 {"type": "(∀ a b, b = f a → p b) ↔ ∀ a, p (f a)",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop} : (∀ a b, b = f a → p b) ↔ ∀ a, p (f a) := by simp; sorry",
  "name": "forall_eq_apply_imp_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop} : (∀ a b, b = f a → p b) ↔ ∀ a, p (f a)",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop}"},
 {"type": "(∀ b a, b = f a → p b) ↔ ∀ a, p (f a)",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop} : (∀ b a, b = f a → p b) ↔ ∀ a, p (f a) := by simp [forall_swap]; sorry",
  "name": "forall_eq_apply_imp_iff'",
  "kind": "theorem",
  "first-tactic": "simp [forall_swap]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop} : (∀ b a, b = f a → p b) ↔ ∀ a, p (f a)",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop}"},
 {"type": "(∃ a, p a ∧ a' = a) ↔ p a'",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α} : (∃ a, p a ∧ a' = a) ↔ p a' := by simp [@eq_comm _ a']; sorry",
  "name": "exists_eq_right'",
  "kind": "theorem",
  "first-tactic": "simp [@eq_comm _ a']",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α} : (∃ a, p a ∧ a' = a) ↔ p a'",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α}"},
 {"type": "(∃ i₁ j₁ i₂ j₂, p i₁ j₁ i₂ j₂) ↔ ∃ i₂ j₂ i₁ j₁, p i₁ j₁ i₂ j₂",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {κ₁ : ι₁ → Sort _}  {κ₂ : ι₂ → Sort _}  {p : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → Prop} : (∃ i₁ j₁ i₂ j₂, p i₁ j₁ i₂ j₂) ↔ ∃ i₂ j₂ i₁ j₁, p i₁ j₁ i₂ j₂ := by simp only [@exists_comm (κ₁ _)]; sorry",
  "name": "exists₂_comm",
  "kind": "theorem",
  "first-tactic": "simp only [@exists_comm (κ₁ _)]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {κ₁ : ι₁ → Sort _}  {κ₂ : ι₂ → Sort _}  {p : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → Prop} : (∃ i₁ j₁ i₂ j₂, p i₁ j₁ i₂ j₂) ↔ ∃ i₂ j₂ i₁ j₁, p i₁ j₁ i₂ j₂",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {κ₁ : ι₁ → Sort _}  {κ₂ : ι₂ → Sort _}  {p : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → Prop}"},
 {"type": "(∃! _ : p, q) ↔ p ∧ q",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {p q : Prop} : (∃! _ : p, q) ↔ p ∧ q := by simp; sorry",
  "name": "exists_unique_prop",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {p q : Prop} : (∃! _ : p, q) ↔ p ∧ q",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {p q : Prop}"},
 {"type": "b",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x) (_ : p x), Prop}  {b : Prop}  (h₂ : ∃! (x : _) (h : p x), q x h)      (h₁ : ∀ (x) (h : p x), q x h → (∀ (y) (hy : p y), q y hy → y = x) → b) : b := by simp only [exists_unique_iff_exists] at h₂; sorry",
  "name": "ExistsUnique.elim₂",
  "kind": "theorem",
  "first-tactic": "simp only [exists_unique_iff_exists] at h₂",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x) (_ : p x), Prop}  {b : Prop}  (h₂ : ∃! (x : _) (h : p x), q x h)      (h₁ : ∀ (x) (h : p x), q x h → (∀ (y) (hy : p y), q y hy → y = x) → b) : b",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x) (_ : p x), Prop}  {b : Prop}  (h₂ : ∃! (x : _) (h : p x), q x h)      (h₁ : ∀ (x) (h : p x), q x h → (∀ (y) (hy : p y), q y hy → y = x) → b)"},
 {"type": "∃! (x : _) (hx : p x), q x hx",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x : α) (_ : p x), Prop}  (w : α)  (hp : p w)  (hq : q w hp)      (H : ∀ (y) (hy : p y), q y hy → y = w) : ∃! (x : _) (hx : p x), q x hx := by simp only [exists_unique_iff_exists]; sorry",
  "name": "ExistsUnique.intro₂",
  "kind": "theorem",
  "first-tactic": "simp only [exists_unique_iff_exists]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x : α) (_ : p x), Prop}  (w : α)  (hp : p w)  (hq : q w hp)      (H : ∀ (y) (hy : p y), q y hy → y = w) : ∃! (x : _) (hx : p x), q x hx",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x : α) (_ : p x), Prop}  (w : α)  (hp : p w)  (hq : q w hp)      (H : ∀ (y) (hy : p y), q y hy → y = w)"},
 {"type": "y₁ = y₂",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x : α) (_ : p x), Prop}  (h : ∃! (x : _) (hx : p x), q x hx)  {y₁ y₂ : α}      (hpy₁ : p y₁)  (hqy₁ : q y₁ hpy₁)  (hpy₂ : p y₂)  (hqy₂ : q y₂ hpy₂) : y₁ = y₂ := by simp only [exists_unique_iff_exists] at h; sorry",
  "name": "ExistsUnique.unique₂",
  "kind": "theorem",
  "first-tactic": "simp only [exists_unique_iff_exists] at h",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x : α) (_ : p x), Prop}  (h : ∃! (x : _) (hx : p x), q x hx)  {y₁ y₂ : α}      (hpy₁ : p y₁)  (hqy₁ : q y₁ hpy₁)  (hpy₂ : p y₂)  (hqy₂ : q y₂ hpy₂) : y₁ = y₂",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x : α) (_ : p x), Prop}  (h : ∃! (x : _) (hx : p x), q x hx)  {y₁ y₂ : α}      (hpy₁ : p y₁)  (hqy₁ : q y₁ hpy₁)  (hpy₂ : p y₂)  (hqy₂ : q y₂ hpy₂)"},
 {"type": "Decidable p",
  "tactic-prompt":
  "def {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Prop) : Decidable p := by infer_instance; sorry",
  "name": "dec",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Prop) : Decidable p",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Prop)"},
 {"type": "DecidablePred p",
  "tactic-prompt":
  "def {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : α → Prop) : DecidablePred p := by infer_instance; sorry",
  "name": "decPred",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : α → Prop) : DecidablePred p",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : α → Prop)"},
 {"type": "DecidableRel p",
  "tactic-prompt":
  "def {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : α → α → Prop) : DecidableRel p := by infer_instance; sorry",
  "name": "decRel",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : α → α → Prop) : DecidableRel p",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : α → α → Prop)"},
 {"type": "DecidableEq α",
  "tactic-prompt":
  "def {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (α : Sort u) : DecidableEq α := by infer_instance; sorry",
  "name": "decEq",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (α : Sort u) : DecidableEq α",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (α : Sort u)"},
 {"type": "(∃ (x : _) (_ : x = a), p x) ↔ p a",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop} {a : α} : (∃ (x : _) (_ : x = a), p x) ↔ p a := by simp only [exists_prop]; sorry",
  "name": "bex_eq_left",
  "kind": "theorem",
  "first-tactic": "simp only [exists_prop]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop} {a : α} : (∃ (x : _) (_ : x = a), p x) ↔ p a",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop} {a : α}"},
 {"type": "(∃ x h, P x h) → b ↔ ∀ x h, P x h → b",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop} : (∃ x h, P x h) → b ↔ ∀ x h, P x h → b := by simp; sorry",
  "name": "bex_imp",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop} : (∃ x h, P x h) → b ↔ ∀ x h, P x h → b",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop}"},
 {"type":
  "(∃ (x : _) (_ : p x ∨ q x), r x) ↔ (∃ (x : _) (_ : p x), r x) ∨ ∃ (x : _) (_ : q x), r x",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop} : (∃ (x : _) (_ : p x ∨ q x), r x) ↔ (∃ (x : _) (_ : p x), r x) ∨ ∃ (x : _) (_ : q x), r x := by simp only [exists_prop]; sorry",
  "name": "bex_or_left",
  "kind": "theorem",
  "first-tactic": "simp only [exists_prop]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop} : (∃ (x : _) (_ : p x ∨ q x), r x) ↔ (∃ (x : _) (_ : p x), r x) ∨ ∃ (x : _) (_ : q x), r x",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop}"},
 {"type": "dite P A B = c ↔ (∃ h, A h = c) ∨ ∃ h, B h = c",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : dite P A B = c ↔ (∃ h, A h = c) ∨ ∃ h, B h = c := by by_cases P; sorry",
  "name": "dite_eq_iff",
  "kind": "theorem",
  "first-tactic": "by_cases P",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : dite P A B = c ↔ (∃ h, A h = c) ∨ ∃ h, B h = c",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α}"},
 {"type": "dite P (fun _ ↦ a) B = a ↔ ∀ h, B h = a",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : dite P (fun _ ↦ a) B = a ↔ ∀ h, B h = a := by by_cases P; sorry",
  "name": "dite_eq_left_iff",
  "kind": "theorem",
  "first-tactic": "by_cases P",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : dite P (fun _ ↦ a) B = a ↔ ∀ h, B h = a",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α}"},
 {"type": "(dite P A fun _ ↦ b) = b ↔ ∀ h, A h = b",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : (dite P A fun _ ↦ b) = b ↔ ∀ h, A h = b := by by_cases P; sorry",
  "name": "dite_eq_right_iff",
  "kind": "theorem",
  "first-tactic": "by_cases P",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : (dite P A fun _ ↦ b) = b ↔ ∀ h, A h = b",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α}"},
 {"type": "dite P (fun _ ↦ a) B ≠ a ↔ ∃ h, a ≠ B h",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : dite P (fun _ ↦ a) B ≠ a ↔ ∃ h, a ≠ B h := by rw [Ne.def]; sorry",
  "name": "dite_ne_left_iff",
  "kind": "theorem",
  "first-tactic": "rw [Ne.def]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : dite P (fun _ ↦ a) B ≠ a ↔ ∃ h, a ≠ B h",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α}"},
 {"type": "(dite P A fun _ ↦ b) ≠ b ↔ ∃ h, A h ≠ b",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : (dite P A fun _ ↦ b) ≠ b ↔ ∃ h, A h ≠ b := by simp only [Ne.def]; sorry",
  "name": "dite_ne_right_iff",
  "kind": "theorem",
  "first-tactic": "simp only [Ne.def]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : (dite P A fun _ ↦ b) ≠ b ↔ ∃ h, A h ≠ b",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α}"},
 {"type":
  "f (dite P a b) (dite P c d) = dite P (fun h ↦ f (a h) (c h)) fun h ↦ f (b h) (d h)",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} (f : α → β → γ)  (P : Prop)  [Decidable P]  (a : P → α)  (b : ¬P → α)      (c : P → β)  (d : ¬P → β) : f (dite P a b) (dite P c d) = dite P (fun h ↦ f (a h) (c h)) fun h ↦ f (b h) (d h) := by by_cases h : P; sorry",
  "name": "apply_dite₂",
  "kind": "theorem",
  "first-tactic": "by_cases h : P",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} (f : α → β → γ)  (P : Prop)  [Decidable P]  (a : P → α)  (b : ¬P → α)      (c : P → β)  (d : ¬P → β) : f (dite P a b) (dite P c d) = dite P (fun h ↦ f (a h) (c h)) fun h ↦ f (b h) (d h)",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} (f : α → β → γ)  (P : Prop)  [Decidable P]  (a : P → α)  (b : ¬P → α)      (c : P → β)  (d : ¬P → β)"},
 {"type": "(dite P f g) a = dite P (fun h ↦ f h a) fun h ↦ g h a",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} (f : P → ∀ a, σ a)  (g : ¬P → ∀ a, σ a)  (a : α) : (dite P f g) a = dite P (fun h ↦ f h a) fun h ↦ g h a := by by_cases h:P; sorry",
  "name": "dite_apply",
  "kind": "theorem",
  "first-tactic": "by_cases h:P",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} (f : P → ∀ a, σ a)  (g : ¬P → ∀ a, σ a)  (a : α) : (dite P f g) a = dite P (fun h ↦ f h a) fun h ↦ g h a",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} (f : P → ∀ a, σ a)  (g : ¬P → ∀ a, σ a)  (a : α)"},
 {"type": "ite (P ∧ Q) a b = ite P (ite Q a b) b",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : ite (P ∧ Q) a b = ite P (ite Q a b) b := by by_cases hp : P; sorry",
  "name": "ite_and",
  "kind": "theorem",
  "first-tactic": "by_cases hp : P",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : ite (P ∧ Q) a b = ite P (ite Q a b) b",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α}"},
 {"type": "r x y",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {r : α → α → Prop} (h : Reflexive r)  {x y : α}  (hr : x ≠ y → r x y) : r x y := by by_cases hxy : x = y; sorry",
  "name": "Reflexive.rel_of_ne_imp",
  "kind": "theorem",
  "first-tactic": "by_cases hxy : x = y",
  "core-prompt":
  "{α β γ δ : Type _}  {r : α → α → Prop} (h : Reflexive r)  {x y : α}  (hr : x ≠ y → r x y) : r x y",
  "args":
  "{α β γ δ : Type _}  {r : α → α → Prop} (h : Reflexive r)  {x y : α}  (hr : x ≠ y → r x y)"},
 {"type": "(· ↔ ·) ∘r r = r",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {r : α → β → Prop}  {p : β → γ → Prop}  {q : γ → δ → Prop} {r : Prop → α → Prop} : (· ↔ ·) ∘r r = r := by have : (· ↔ ·) = (· = ·) := by funext a b; exact iff_eq_eq; sorry",
  "name": "iff_comp",
  "kind": "theorem",
  "first-tactic": "have : (· ↔ ·) = (· = ·) := by funext a b; exact iff_eq_eq",
  "core-prompt":
  "{α β γ δ : Type _}  {r : α → β → Prop}  {p : β → γ → Prop}  {q : γ → δ → Prop} {r : Prop → α → Prop} : (· ↔ ·) ∘r r = r",
  "args":
  "{α β γ δ : Type _}  {r : α → β → Prop}  {p : β → γ → Prop}  {q : γ → δ → Prop} {r : Prop → α → Prop}"},
 {"type": "r ∘r (· ↔ ·) = r",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {r : α → β → Prop}  {p : β → γ → Prop}  {q : γ → δ → Prop} {r : α → Prop → Prop} : r ∘r (· ↔ ·) = r := by have : (· ↔ ·) = (· = ·) := by funext a b; exact iff_eq_eq; sorry",
  "name": "comp_iff",
  "kind": "theorem",
  "first-tactic": "have : (· ↔ ·) = (· = ·) := by funext a b; exact iff_eq_eq",
  "core-prompt":
  "{α β γ δ : Type _}  {r : α → β → Prop}  {p : β → γ → Prop}  {q : γ → δ → Prop} {r : α → Prop → Prop} : r ∘r (· ↔ ·) = r",
  "args":
  "{α β γ δ : Type _}  {r : α → β → Prop}  {p : β → γ → Prop}  {q : γ → δ → Prop} {r : α → Prop → Prop}"},
 {"type": "(r ∘r p) ∘r q = r ∘r p ∘r q",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {r : α → β → Prop}  {p : β → γ → Prop}  {q : γ → δ → Prop} : (r ∘r p) ∘r q = r ∘r p ∘r q := by funext a d; sorry",
  "name": "comp_assoc",
  "kind": "theorem",
  "first-tactic": "funext a d",
  "core-prompt":
  "{α β γ δ : Type _}  {r : α → β → Prop}  {p : β → γ → Prop}  {q : γ → δ → Prop} : (r ∘r p) ∘r q = r ∘r p ∘r q",
  "args":
  "{α β γ δ : Type _}  {r : α → β → Prop}  {p : β → γ → Prop}  {q : γ → δ → Prop}"},
 {"type": "flip (r ∘r p) = flip p ∘r flip r",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {r : α → β → Prop}  {p : β → γ → Prop}  {q : γ → δ → Prop} : flip (r ∘r p) = flip p ∘r flip r := by funext c a; sorry",
  "name": "flip_comp",
  "kind": "theorem",
  "first-tactic": "funext c a",
  "core-prompt":
  "{α β γ δ : Type _}  {r : α → β → Prop}  {p : β → γ → Prop}  {q : γ → δ → Prop} : flip (r ∘r p) = flip p ∘r flip r",
  "args":
  "{α β γ δ : Type _}  {r : α → β → Prop}  {p : β → γ → Prop}  {q : γ → δ → Prop}"},
 {"type": "ReflTransGen r a c",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (hab : ReflTransGen r a b)  (hbc : ReflTransGen r b c) : ReflTransGen r a c := by induction hbc; sorry",
  "name": "trans",
  "kind": "theorem",
  "first-tactic": "induction hbc",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (hab : ReflTransGen r a b)  (hbc : ReflTransGen r b c) : ReflTransGen r a c",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (hab : ReflTransGen r a b)  (hbc : ReflTransGen r b c)"},
 {"type": "ReflTransGen r a c",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (hab : r a b)  (hbc : ReflTransGen r b c) : ReflTransGen r a c := by induction hbc; sorry",
  "name": "head",
  "kind": "theorem",
  "first-tactic": "induction hbc",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (hab : r a b)  (hbc : ReflTransGen r b c) : ReflTransGen r a c",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (hab : r a b)  (hbc : ReflTransGen r b c)"},
 {"type": "Symmetric (ReflTransGen r)",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (h : Symmetric r) : Symmetric (ReflTransGen r) := by intro x y h; sorry",
  "name": "symmetric",
  "kind": "theorem",
  "first-tactic": "intro x y h",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (h : Symmetric r) : Symmetric (ReflTransGen r)",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (h : Symmetric r)"},
 {"type": "P a h",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} {P : ∀ a : α, ReflTransGen r a b → Prop}  {a : α}  (h : ReflTransGen r a b)      (refl : P b refl)      (head : ∀ {a c} (h' : r a c) (h : ReflTransGen r c b), P c h → P a (h.head h')) : P a h := by induction h; sorry",
  "name": "head_induction_on",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} {P : ∀ a : α, ReflTransGen r a b → Prop}  {a : α}  (h : ReflTransGen r a b)      (refl : P b refl)      (head : ∀ {a c} (h' : r a c) (h : ReflTransGen r c b), P c h → P a (h.head h')) : P a h",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} {P : ∀ a : α, ReflTransGen r a b → Prop}  {a : α}  (h : ReflTransGen r a b)      (refl : P b refl)      (head : ∀ {a c} (h' : r a c) (h : ReflTransGen r c b), P c h → P a (h.head h'))"},
 {"type": "P h",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} {P : ∀ {a b : α}, ReflTransGen r a b → Prop}  {a b : α}      (h : ReflTransGen r a b)  (ih₁ : ∀ a, @P a a refl)  (ih₂ : ∀ {a b} (h : r a b), P (single h))      (ih₃ : ∀ {a b c} (h₁ : ReflTransGen r a b) (h₂ : ReflTransGen r b c), P h₁ → P h₂ →      P (h₁.trans h₂)) : P h := by induction h; sorry",
  "name": "trans_induction_on",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} {P : ∀ {a b : α}, ReflTransGen r a b → Prop}  {a b : α}      (h : ReflTransGen r a b)  (ih₁ : ∀ a, @P a a refl)  (ih₂ : ∀ {a b} (h : r a b), P (single h))      (ih₃ : ∀ {a b c} (h₁ : ReflTransGen r a b) (h₂ : ReflTransGen r b c), P h₁ → P h₂ →      P (h₁.trans h₂)) : P h",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} {P : ∀ {a b : α}, ReflTransGen r a b → Prop}  {a b : α}      (h : ReflTransGen r a b)  (ih₁ : ∀ a, @P a a refl)  (ih₂ : ∀ {a b} (h : r a b), P (single h))      (ih₃ : ∀ {a b c} (h₁ : ReflTransGen r a b) (h₂ : ReflTransGen r b c), P h₁ → P h₂ →      P (h₁.trans h₂))"},
 {"type": "a = b ∨ ∃ c, r a c ∧ ReflTransGen r c b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (h : ReflTransGen r a b) : a = b ∨ ∃ c, r a c ∧ ReflTransGen r c b := by induction h using Relation.ReflTransGen.head_induction_on; sorry",
  "name": "cases_head",
  "kind": "theorem",
  "first-tactic": "induction h using Relation.ReflTransGen.head_induction_on",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (h : ReflTransGen r a b) : a = b ∨ ∃ c, r a c ∧ ReflTransGen r c b",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (h : ReflTransGen r a b)"},
 {"type": "ReflTransGen r a b ↔ a = b ∨ ∃ c, r a c ∧ ReflTransGen r c b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} : ReflTransGen r a b ↔ a = b ∨ ∃ c, r a c ∧ ReflTransGen r c b := by use cases_head; sorry",
  "name": "cases_head_iff",
  "kind": "theorem",
  "first-tactic": "use cases_head",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} : ReflTransGen r a b ↔ a = b ∨ ∃ c, r a c ∧ ReflTransGen r c b",
  "args": "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}"},
 {"type": "ReflTransGen r b c ∨ ReflTransGen r c b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (U : Relator.RightUnique r)  (ab : ReflTransGen r a b)      (ac : ReflTransGen r a c) : ReflTransGen r b c ∨ ReflTransGen r c b := by induction' ab with b d _ bd IH; sorry",
  "name": "total_of_right_unique",
  "kind": "theorem",
  "first-tactic": "induction' ab with b d _ bd IH",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (U : Relator.RightUnique r)  (ab : ReflTransGen r a b)      (ac : ReflTransGen r a c) : ReflTransGen r b c ∨ ReflTransGen r c b",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (U : Relator.RightUnique r)  (ab : ReflTransGen r a b)      (ac : ReflTransGen r a c)"},
 {"type": "TransGen r a c",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (hab : TransGen r a b)  (hbc : ReflTransGen r b c) : TransGen r a c := by induction hbc; sorry",
  "name": "trans_left",
  "kind": "theorem",
  "first-tactic": "induction hbc",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (hab : TransGen r a b)  (hbc : ReflTransGen r b c) : TransGen r a c",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (hab : TransGen r a b)  (hbc : ReflTransGen r b c)"},
 {"type": "TransGen r a c",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (hab : ReflTransGen r a b)  (hbc : r b c) : TransGen r a c := by induction hab generalizing c; sorry",
  "name": "tail'",
  "kind": "theorem",
  "first-tactic": "induction hab generalizing c",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (hab : ReflTransGen r a b)  (hbc : r b c) : TransGen r a c",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (hab : ReflTransGen r a b)  (hbc : r b c)"},
 {"type": "P a h",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} {P : ∀ a : α, TransGen r a b → Prop}  {a : α}  (h : TransGen r a b)      (base : ∀ {a} (h : r a b), P a (single h))      (ih : ∀ {a c} (h' : r a c) (h : TransGen r c b), P c h → P a (h.head h')) : P a h := by induction h; sorry",
  "name": "head_induction_on",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} {P : ∀ a : α, TransGen r a b → Prop}  {a : α}  (h : TransGen r a b)      (base : ∀ {a} (h : r a b), P a (single h))      (ih : ∀ {a c} (h' : r a c) (h : TransGen r c b), P c h → P a (h.head h')) : P a h",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} {P : ∀ a : α, TransGen r a b → Prop}  {a : α}  (h : TransGen r a b)      (base : ∀ {a} (h : r a b), P a (single h))      (ih : ∀ {a c} (h' : r a c) (h : TransGen r c b), P c h → P a (h.head h'))"},
 {"type": "P h",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} {P : ∀ {a b : α}, TransGen r a b → Prop}  {a b : α}  (h : TransGen r a b)      (base : ∀ {a b} (h : r a b), P (single h))      (ih : ∀ {a b c} (h₁ : TransGen r a b) (h₂ : TransGen r b c), P h₁ → P h₂ → P (h₁.trans h₂)) : P h := by induction h; sorry",
  "name": "trans_induction_on",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} {P : ∀ {a b : α}, TransGen r a b → Prop}  {a b : α}  (h : TransGen r a b)      (base : ∀ {a b} (h : r a b), P (single h))      (ih : ∀ {a b c} (h₁ : TransGen r a b) (h₂ : TransGen r b c), P h₁ → P h₂ → P (h₁.trans h₂)) : P h",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} {P : ∀ {a b : α}, TransGen r a b → Prop}  {a b : α}  (h : TransGen r a b)      (base : ∀ {a b} (h : r a b), P (single h))      (ih : ∀ {a b c} (h₁ : TransGen r a b) (h₂ : TransGen r b c), P h₁ → P h₂ → P (h₁.trans h₂))"},
 {"type": "TransGen r a c",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (hab : ReflTransGen r a b)  (hbc : TransGen r b c) : TransGen r a c := by induction hbc; sorry",
  "name": "trans_right",
  "kind": "theorem",
  "first-tactic": "induction hbc",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (hab : ReflTransGen r a b)  (hbc : TransGen r b c) : TransGen r a c",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (hab : ReflTransGen r a b)  (hbc : TransGen r b c)"},
 {"type": "TransGen r a c ↔ ∃ b, ReflTransGen r a b ∧ r b c",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} : TransGen r a c ↔ ∃ b, ReflTransGen r a b ∧ r b c := by refine' ⟨fun h ↦ _, fun ⟨b, hab, hbc⟩ ↦ tail' hab hbc⟩; sorry",
  "name": "tail'_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h ↦ _, fun ⟨b, hab, hbc⟩ ↦ tail' hab hbc⟩",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} : TransGen r a c ↔ ∃ b, ReflTransGen r a b ∧ r b c",
  "args": "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}"},
 {"type": "TransGen r a c ↔ ∃ b, r a b ∧ ReflTransGen r b c",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} : TransGen r a c ↔ ∃ b, r a b ∧ ReflTransGen r b c := by refine' ⟨fun h ↦ _, fun ⟨b, hab, hbc⟩ ↦ head' hab hbc⟩; sorry",
  "name": "head'_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h ↦ _, fun ⟨b, hab, hbc⟩ ↦ head' hab hbc⟩",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} : TransGen r a c ↔ ∃ b, r a b ∧ ReflTransGen r b c",
  "args": "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}"},
 {"type": "Acc (TransGen r) a",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (h : Acc r a) : Acc (TransGen r) a := by induction' h with x _ H; sorry",
  "name": "_root_.Acc.TransGen",
  "kind": "theorem",
  "first-tactic": "induction' h with x _ H",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (h : Acc r a) : Acc (TransGen r) a",
  "args": "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} (h : Acc r a)"},
 {"type": "TransGen p (f a) (f b)",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  {p : β → β → Prop}  {a b : α}  (f : α → β)  (h : ∀ a b, r a b → p (f a) (f b))      (hab : TransGen r a b) : TransGen p (f a) (f b) := by induction hab; sorry",
  "name": "TransGen.lift",
  "kind": "theorem",
  "first-tactic": "induction hab",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  {p : β → β → Prop}  {a b : α}  (f : α → β)  (h : ∀ a b, r a b → p (f a) (f b))      (hab : TransGen r a b) : TransGen p (f a) (f b)",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  {p : β → β → Prop}  {a b : α}  (f : α → β)  (h : ∀ a b, r a b → p (f a) (f b))      (hab : TransGen r a b)"},
 {"type": "TransGen p (f a) (f b)",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  {p : β → β → Prop}  {a b : α}  (f : α → β)      (h : ∀ a b, r a b → TransGen p (f a) (f b))  (hab : TransGen r a b) : TransGen p (f a) (f b) := by simpa [transGen_idem] using hab.lift f h; sorry",
  "name": "TransGen.lift'",
  "kind": "theorem",
  "first-tactic": "simpa [transGen_idem] using hab.lift f h",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  {p : β → β → Prop}  {a b : α}  (f : α → β)      (h : ∀ a b, r a b → TransGen p (f a) (f b))  (hab : TransGen r a b) : TransGen p (f a) (f b)",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  {p : β → β → Prop}  {a b : α}  (f : α → β)      (h : ∀ a b, r a b → TransGen p (f a) (f b))  (hab : TransGen r a b)"},
 {"type": "TransGen (swap r) a b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  (h : TransGen r b a) : TransGen (swap r) a b := by induction' h with b h b c _ hbc ih; sorry",
  "name": "TransGen.swap",
  "kind": "theorem",
  "first-tactic": "induction' h with b h b c _ hbc ih",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  (h : TransGen r b a) : TransGen (swap r) a b",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  (h : TransGen r b a)"},
 {"type": "ReflTransGen r a b ↔ b = a",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  (h : ∀ b, ¬r a b) : ReflTransGen r a b ↔ b = a := by rw [cases_head_iff]; sorry",
  "name": "reflTransGen_iff_eq",
  "kind": "theorem",
  "first-tactic": "rw [cases_head_iff]",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  (h : ∀ b, ¬r a b) : ReflTransGen r a b ↔ b = a",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  (h : ∀ b, ¬r a b)"},
 {"type": "ReflTransGen r a b ↔ b = a ∨ TransGen r a b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} : ReflTransGen r a b ↔ b = a ∨ TransGen r a b := by refine' ⟨fun h ↦ _, fun h ↦ _⟩; sorry",
  "name": "reflTransGen_iff_eq_or_transGen",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h ↦ _, fun h ↦ _⟩",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α} : ReflTransGen r a b ↔ b = a ∨ TransGen r a b",
  "args": "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}"},
 {"type": "ReflTransGen p (f a) (f b)",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  {p : β → β → Prop}  {a b : α}  (f : α → β)      (h : ∀ a b, r a b → ReflTransGen p (f a) (f b))      (hab : ReflTransGen r a b) : ReflTransGen p (f a) (f b) := by simpa [refl_trans_gen_idem] using hab.lift f h; sorry",
  "name": "ReflTransGen.lift'",
  "kind": "theorem",
  "first-tactic": "simpa [refl_trans_gen_idem] using hab.lift f h",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  {p : β → β → Prop}  {a b : α}  (f : α → β)      (h : ∀ a b, r a b → ReflTransGen p (f a) (f b))      (hab : ReflTransGen r a b) : ReflTransGen p (f a) (f b)",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  {p : β → β → Prop}  {a b : α}  (f : α → β)      (h : ∀ a b, r a b → ReflTransGen p (f a) (f b))      (hab : ReflTransGen r a b)"},
 {"type": "ReflTransGen (swap r) a b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  (h : ReflTransGen r b a) : ReflTransGen (swap r) a b := by induction' h with b c _ hbc ih; sorry",
  "name": "ReflTransGen.swap",
  "kind": "theorem",
  "first-tactic": "induction' h with b c _ hbc ih",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  (h : ReflTransGen r b a) : ReflTransGen (swap r) a b",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  (h : ReflTransGen r b a)"},
 {"type": "Join (ReflTransGen r) b c",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  (h : ∀ a b c, r a b → r a c → ∃ d, ReflGen r b d ∧ ReflTransGen r c d)      (hab : ReflTransGen r a b)  (hac : ReflTransGen r a c) : Join (ReflTransGen r) b c := by induction hab; sorry",
  "name": "church_rosser",
  "kind": "theorem",
  "first-tactic": "induction hab",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  (h : ∀ a b c, r a b → r a c → ∃ d, ReflGen r b d ∧ ReflTransGen r c d)      (hab : ReflTransGen r a b)  (hac : ReflTransGen r a c) : Join (ReflTransGen r) b c",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  (h : ∀ a b c, r a b → r a c → ∃ d, ReflGen r b d ∧ ReflTransGen r c d)      (hab : ReflTransGen r a b)  (hac : ReflTransGen r a c)"},
 {"type": "r a b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  {r' : α → α → Prop}  (hr : Reflexive r)      (ht : Transitive r)  (h : ∀ a b, r' a b → r a b)  (h' : ReflTransGen r' a b) : r a b := by induction' h' with b c _ hbc ih; sorry",
  "name": "reflTransGen_of_transitive_reflexive",
  "kind": "theorem",
  "first-tactic": "induction' h' with b c _ hbc ih",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  {r' : α → α → Prop}  (hr : Reflexive r)      (ht : Transitive r)  (h : ∀ a b, r' a b → r a b)  (h' : ReflTransGen r' a b) : r a b",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  {r' : α → α → Prop}  (hr : Reflexive r)      (ht : Transitive r)  (h : ∀ a b, r' a b → r a b)  (h' : ReflTransGen r' a b)"},
 {"type": "EqvGen p a b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  {r : α → α → Prop}  {a b : α} {r p : α → α → Prop}  (hrp : ∀ a b, r a b → p a b)  (h : EqvGen r a b) : EqvGen p a b := by induction h; sorry",
  "name": "EqvGen.mono",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  {r : α → α → Prop}  {a b : α} {r p : α → α → Prop}  (hrp : ∀ a b, r a b → p a b)  (h : EqvGen r a b) : EqvGen p a b",
  "args":
  "{α β γ δ : Type _} {r : α → α → Prop}  {a b c d : α}  {r : α → α → Prop}  {a b : α} {r p : α → α → Prop}  (hrp : ∀ a b, r a b → p a b)  (h : EqvGen r a b)"},
 {"type":
  "(dite p a fun hp ↦ dite q (b hp) (c hp)) =\n      dite q (fun hq ↦ (dite p a) fun hp ↦ b hp hq) fun hq ↦ (dite p a) fun hp ↦ c hp hq",
  "tactic-prompt":
  "theorem {α : Sort _}  {p q r : Prop}  [Decidable p]  [Decidable q]  {a b c : α} {a : p → α}  {b : ¬p → q → α}  {c : ¬p → ¬q → α} : (dite p a fun hp ↦ dite q (b hp) (c hp)) =\n      dite q (fun hq ↦ (dite p a) fun hp ↦ b hp hq) fun hq ↦ (dite p a) fun hp ↦ c hp hq := by split_ifs; sorry",
  "name": "dite_dite_distrib_left",
  "kind": "theorem",
  "first-tactic": "split_ifs",
  "core-prompt":
  "{α : Sort _}  {p q r : Prop}  [Decidable p]  [Decidable q]  {a b c : α} {a : p → α}  {b : ¬p → q → α}  {c : ¬p → ¬q → α} : (dite p a fun hp ↦ dite q (b hp) (c hp)) =\n      dite q (fun hq ↦ (dite p a) fun hp ↦ b hp hq) fun hq ↦ (dite p a) fun hp ↦ c hp hq",
  "args":
  "{α : Sort _}  {p q r : Prop}  [Decidable p]  [Decidable q]  {a b c : α} {a : p → α}  {b : ¬p → q → α}  {c : ¬p → ¬q → α}"},
 {"type":
  "dite p (fun hp ↦ dite q (a hp) (b hp)) c =\n      dite q (fun hq ↦ dite p (fun hp ↦ a hp hq) c) fun hq ↦ dite p (fun hp ↦ b hp hq) c",
  "tactic-prompt":
  "theorem {α : Sort _}  {p q r : Prop}  [Decidable p]  [Decidable q]  {a b c : α} {a : p → q → α}  {b : p → ¬q → α}  {c : ¬p → α} : dite p (fun hp ↦ dite q (a hp) (b hp)) c =\n      dite q (fun hq ↦ dite p (fun hp ↦ a hp hq) c) fun hq ↦ dite p (fun hp ↦ b hp hq) c := by split_ifs; sorry",
  "name": "dite_dite_distrib_right",
  "kind": "theorem",
  "first-tactic": "split_ifs",
  "core-prompt":
  "{α : Sort _}  {p q r : Prop}  [Decidable p]  [Decidable q]  {a b c : α} {a : p → q → α}  {b : p → ¬q → α}  {c : ¬p → α} : dite p (fun hp ↦ dite q (a hp) (b hp)) c =\n      dite q (fun hq ↦ dite p (fun hp ↦ a hp hq) c) fun hq ↦ dite p (fun hp ↦ b hp hq) c",
  "args":
  "{α : Sort _}  {p q r : Prop}  [Decidable p]  [Decidable q]  {a b c : α} {a : p → q → α}  {b : p → ¬q → α}  {c : ¬p → α}"},
 {"type": "p ≠ 0",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) [Nontrivial R]  {p : Fin 2 → R}  (h : IsCoprime (p 0) (p 1)) : p ≠ 0 := by rintro rfl; sorry",
  "name": "IsCoprime.ne_zero",
  "kind": "theorem",
  "first-tactic": "rintro rfl",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) [Nontrivial R]  {p : Fin 2 → R}  (h : IsCoprime (p 0) (p 1)) : p ≠ 0",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) [Nontrivial R]  {p : Fin 2 → R}  (h : IsCoprime (p 0) (p 1))"},
 {"type": "x ∣ y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x z)  (H2 : x ∣ y * z) : x ∣ y := by let ⟨a, b, H⟩ := H1; sorry",
  "name": "IsCoprime.dvd_of_dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "let ⟨a, b, H⟩ := H1",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x z)  (H2 : x ∣ y * z) : x ∣ y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x z)  (H2 : x ∣ y * z)"},
 {"type": "x ∣ z",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x y)  (H2 : x ∣ y * z) : x ∣ z := by let ⟨a, b, H⟩ := H1; sorry",
  "name": "IsCoprime.dvd_of_dvd_mul_left",
  "kind": "theorem",
  "first-tactic": "let ⟨a, b, H⟩ := H1",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x y)  (H2 : x ∣ y * z) : x ∣ z",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x y)  (H2 : x ∣ y * z)"},
 {"type": "IsCoprime x (y * z)",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x y)  (H2 : IsCoprime x z) : IsCoprime x (y * z) := by rw [isCoprime_comm] at H1 H2⊢; sorry",
  "name": "IsCoprime.mul_right",
  "kind": "theorem",
  "first-tactic": "rw [isCoprime_comm] at H1 H2⊢",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x y)  (H2 : IsCoprime x z) : IsCoprime x (y * z)",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x y)  (H2 : IsCoprime x z)"},
 {"type": "x * y ∣ z",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x y)  (H1 : x ∣ z)  (H2 : y ∣ z) : x * y ∣ z := by obtain ⟨a, b, h⟩ := H; sorry",
  "name": "IsCoprime.mul_dvd",
  "kind": "theorem",
  "first-tactic": "obtain ⟨a, b, h⟩ := H",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x y)  (H1 : x ∣ z)  (H2 : y ∣ z) : x * y ∣ z",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x y)  (H1 : x ∣ z)  (H2 : y ∣ z)"},
 {"type": "IsCoprime y z",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime (x * y) z) : IsCoprime y z := by rw [mul_comm] at H; sorry",
  "name": "IsCoprime.of_mul_left_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm] at H",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime (x * y) z) : IsCoprime y z",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime (x * y) z)"},
 {"type": "IsCoprime x y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x (y * z)) : IsCoprime x y := by rw [isCoprime_comm] at H⊢; sorry",
  "name": "IsCoprime.of_mul_right_left",
  "kind": "theorem",
  "first-tactic": "rw [isCoprime_comm] at H⊢",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x (y * z)) : IsCoprime x y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x (y * z))"},
 {"type": "IsCoprime x z",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x (y * z)) : IsCoprime x z := by rw [mul_comm] at H; sorry",
  "name": "IsCoprime.of_mul_right_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm] at H",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x (y * z)) : IsCoprime x z",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x (y * z))"},
 {"type": "IsCoprime x (y * z) ↔ IsCoprime x y ∧ IsCoprime x z",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) : IsCoprime x (y * z) ↔ IsCoprime x y ∧ IsCoprime x z := by rw [isCoprime_comm]; sorry",
  "name": "IsCoprime.mul_right_iff",
  "kind": "theorem",
  "first-tactic": "rw [isCoprime_comm]",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) : IsCoprime x (y * z) ↔ IsCoprime x y ∧ IsCoprime x z",
  "args": "{R : Type u}  [CommSemiring R]  (x y z : R)"},
 {"type": "IsCoprime x z",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime y z)  (hdvd : x ∣ y) : IsCoprime x z := by obtain ⟨d, rfl⟩ := hdvd; sorry",
  "name": "IsCoprime.of_isCoprime_of_dvd_left",
  "kind": "theorem",
  "first-tactic": "obtain ⟨d, rfl⟩ := hdvd",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime y z)  (hdvd : x ∣ y) : IsCoprime x z",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime y z)  (hdvd : x ∣ y)"},
 {"type": "IsCoprime x y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (x + z * y) y) : IsCoprime x y := by rw [mul_comm] at h; sorry",
  "name": "IsCoprime.of_add_mul_right_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm] at h",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (x + z * y) y) : IsCoprime x y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (x + z * y) y)"},
 {"type": "IsCoprime x y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (y + x * z)) : IsCoprime x y := by rw [isCoprime_comm] at h⊢; sorry",
  "name": "IsCoprime.of_add_mul_left_right",
  "kind": "theorem",
  "first-tactic": "rw [isCoprime_comm] at h⊢",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (y + x * z)) : IsCoprime x y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (y + x * z))"},
 {"type": "IsCoprime x y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (y + z * x)) : IsCoprime x y := by rw [mul_comm] at h; sorry",
  "name": "IsCoprime.of_add_mul_right_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm] at h",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (y + z * x)) : IsCoprime x y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (y + z * x))"},
 {"type": "IsCoprime x y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (y * z + x) y) : IsCoprime x y := by rw [add_comm] at h; sorry",
  "name": "IsCoprime.of_mul_add_left_left",
  "kind": "theorem",
  "first-tactic": "rw [add_comm] at h",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (y * z + x) y) : IsCoprime x y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (y * z + x) y)"},
 {"type": "IsCoprime x y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (z * y + x) y) : IsCoprime x y := by rw [add_comm] at h; sorry",
  "name": "IsCoprime.of_mul_add_right_left",
  "kind": "theorem",
  "first-tactic": "rw [add_comm] at h",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (z * y + x) y) : IsCoprime x y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (z * y + x) y)"},
 {"type": "IsCoprime x y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (x * z + y)) : IsCoprime x y := by rw [add_comm] at h; sorry",
  "name": "IsCoprime.of_mul_add_left_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm] at h",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (x * z + y)) : IsCoprime x y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (x * z + y))"},
 {"type": "IsCoprime x y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (z * x + y)) : IsCoprime x y := by rw [add_comm] at h; sorry",
  "name": "IsCoprime.of_mul_add_right_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm] at h",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (z * x + y)) : IsCoprime x y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (z * x + y))"},
 {"type": "IsCoprime (x + z * y) y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime (x + z * y) y := by rw [mul_comm]; sorry",
  "name": "add_mul_right_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime (x + z * y) y",
  "args": "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R)"},
 {"type": "IsCoprime x (y + x * z)",
  "tactic-prompt":
  "theorem {R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime x (y + x * z) := by rw [isCoprime_comm]; sorry",
  "name": "add_mul_left_right",
  "kind": "theorem",
  "first-tactic": "rw [isCoprime_comm]",
  "core-prompt":
  "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime x (y + x * z)",
  "args": "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R)"},
 {"type": "IsCoprime x (y + z * x)",
  "tactic-prompt":
  "theorem {R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime x (y + z * x) := by rw [isCoprime_comm]; sorry",
  "name": "add_mul_right_right",
  "kind": "theorem",
  "first-tactic": "rw [isCoprime_comm]",
  "core-prompt":
  "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime x (y + z * x)",
  "args": "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R)"},
 {"type": "IsCoprime (y * z + x) y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime (y * z + x) y := by rw [add_comm]; sorry",
  "name": "mul_add_left_left",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime (y * z + x) y",
  "args": "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R)"},
 {"type": "IsCoprime (z * y + x) y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime (z * y + x) y := by rw [add_comm]; sorry",
  "name": "mul_add_right_left",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime (z * y + x) y",
  "args": "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R)"},
 {"type": "IsCoprime x (x * z + y)",
  "tactic-prompt":
  "theorem {R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime x (x * z + y) := by rw [add_comm]; sorry",
  "name": "mul_add_left_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime x (x * z + y)",
  "args": "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R)"},
 {"type": "IsCoprime x (z * x + y)",
  "tactic-prompt":
  "theorem {R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime x (z * x + y) := by rw [add_comm]; sorry",
  "name": "mul_add_right_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime x (z * x + y)",
  "args": "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R)"},
 {"type": "IsCoprime (-x) y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y) : IsCoprime (-x) y := by obtain ⟨a, b, h⟩ := h; sorry",
  "name": "neg_left",
  "kind": "theorem",
  "first-tactic": "obtain ⟨a, b, h⟩ := h",
  "core-prompt":
  "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y) : IsCoprime (-x) y",
  "args": "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)"},
 {"type": "a ^ 2 + b ^ 2 ≠ 0",
  "tactic-prompt":
  "theorem {R : Type _}  [LinearOrderedCommRing R]  {a b : R}  (h : IsCoprime a b) : a ^ 2 + b ^ 2 ≠ 0 := by intro h'; sorry",
  "name": "sq_add_sq_ne_zero",
  "kind": "theorem",
  "first-tactic": "intro h'",
  "core-prompt":
  "{R : Type _}  [LinearOrderedCommRing R]  {a b : R}  (h : IsCoprime a b) : a ^ 2 + b ^ 2 ≠ 0",
  "args":
  "{R : Type _}  [LinearOrderedCommRing R]  {a b : R}  (h : IsCoprime a b)"},
 {"type": "reverse (reverse f) = f",
  "tactic-prompt":
  "theorem (U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}  (f : a ⟶ b) : reverse (reverse f) = f := by apply h.inv'; sorry",
  "name": "reverse_reverse",
  "kind": "theorem",
  "first-tactic": "apply h.inv'",
  "core-prompt":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}  (f : a ⟶ b) : reverse (reverse f) = f",
  "args":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}  (f : a ⟶ b)"},
 {"type": "reverse f = reverse g ↔ f = g",
  "tactic-prompt":
  "theorem (U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}      (f g : a ⟶ b) : reverse f = reverse g ↔ f = g := by constructor; sorry",
  "name": "reverse_inj",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}      (f g : a ⟶ b) : reverse f = reverse g ↔ f = g",
  "args":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}      (f g : a ⟶ b)"},
 {"type": "f = reverse g ↔ reverse f = g",
  "tactic-prompt":
  "theorem (U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}  (f : a ⟶ b)      (g : b ⟶ a) : f = reverse g ↔ reverse f = g := by rw [←reverse_inj]; sorry",
  "name": "eq_reverse_iff",
  "kind": "theorem",
  "first-tactic": "rw [←reverse_inj]",
  "core-prompt":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}  (f : a ⟶ b)      (g : b ⟶ a) : f = reverse g ↔ reverse f = g",
  "args":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}  (f : a ⟶ b)      (g : b ⟶ a)"},
 {"type": "(p.comp q).reverse = q.reverse.comp p.reverse",
  "tactic-prompt":
  "theorem (U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W]  [HasReverse V]  {a b c : V}  (p : Path a b)  (q : Path b c) : (p.comp q).reverse = q.reverse.comp p.reverse := by induction' q with _ _ _ _ h; sorry",
  "name": "Path.reverse_comp",
  "kind": "theorem",
  "first-tactic": "induction' q with _ _ _ _ h",
  "core-prompt":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W]  [HasReverse V]  {a b c : V}  (p : Path a b)  (q : Path b c) : (p.comp q).reverse = q.reverse.comp p.reverse",
  "args":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W]  [HasReverse V]  {a b c : V}  (p : Path a b)  (q : Path b c)"},
 {"type": "p.reverse.reverse = p",
  "tactic-prompt":
  "theorem (U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W]  [h : HasInvolutiveReverse V]  {a b : V}  (p : Path a b) : p.reverse.reverse = p := by induction' p with _ _ _ _ h; sorry",
  "name": "Path.reverse_reverse",
  "kind": "theorem",
  "first-tactic": "induction' p with _ _ _ _ h",
  "core-prompt":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W]  [h : HasInvolutiveReverse V]  {a b : V}  (p : Path a b) : p.reverse.reverse = p",
  "args":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W]  [h : HasInvolutiveReverse V]  {a b : V}  (p : Path a b)"},
 {"type": "Symmetrify.of.comp (Symmetrify.lift φ) = φ",
  "tactic-prompt":
  "theorem (U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [HasReverse V']  (φ : Prefunctor V V') : Symmetrify.of.comp (Symmetrify.lift φ) = φ := by fapply Prefunctor.ext; sorry",
  "name": "lift_spec",
  "kind": "theorem",
  "first-tactic": "fapply Prefunctor.ext",
  "core-prompt":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [HasReverse V']  (φ : Prefunctor V V') : Symmetrify.of.comp (Symmetrify.lift φ) = φ",
  "args":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [HasReverse V']  (φ : Prefunctor V V')"},
 {"type":
  "(Symmetrify.lift φ).map (Quiver.reverse f) = Quiver.reverse ((Symmetrify.lift φ).map f)",
  "tactic-prompt":
  "theorem (U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [h : HasInvolutiveReverse V']      (φ : Prefunctor V V')  {X Y : Symmetrify V}  (f : X ⟶ Y) : (Symmetrify.lift φ).map (Quiver.reverse f) = Quiver.reverse ((Symmetrify.lift φ).map f) := by dsimp [Symmetrify.lift]; sorry",
  "name": "lift_reverse",
  "kind": "theorem",
  "first-tactic": "dsimp [Symmetrify.lift]",
  "core-prompt":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [h : HasInvolutiveReverse V']      (φ : Prefunctor V V')  {X Y : Symmetrify V}  (f : X ⟶ Y) : (Symmetrify.lift φ).map (Quiver.reverse f) = Quiver.reverse ((Symmetrify.lift φ).map f)",
  "args":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [h : HasInvolutiveReverse V']      (φ : Prefunctor V V')  {X Y : Symmetrify V}  (f : X ⟶ Y)"},
 {"type": "Φ = Symmetrify.lift φ",
  "tactic-prompt":
  "theorem (U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [HasReverse V']  (φ : V ⥤q V')  (Φ : Symmetrify V ⥤q V')  (hΦ : (of ⋙q Φ) = φ)      (hΦinv : ∀ {X Y : Symmetrify V} (f : X ⟶ Y),       Φ.map (Quiver.reverse f) = Quiver.reverse (Φ.map f)) : Φ = Symmetrify.lift φ := by subst_vars; sorry",
  "name": "lift_unique",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [HasReverse V']  (φ : V ⥤q V')  (Φ : Symmetrify V ⥤q V')  (hΦ : (of ⋙q Φ) = φ)      (hΦinv : ∀ {X Y : Symmetrify V} (f : X ⟶ Y),       Φ.map (Quiver.reverse f) = Quiver.reverse (Φ.map f)) : Φ = Symmetrify.lift φ",
  "args":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [HasReverse V']  (φ : V ⥤q V')  (Φ : Symmetrify V ⥤q V')  (hΦ : (of ⋙q Φ) = φ)      (hΦinv : ∀ {X Y : Symmetrify V} (f : X ⟶ Y),       Φ.map (Quiver.reverse f) = Quiver.reverse (Φ.map f))"},
 {"type": "e.cast hu hv = _root_.cast (by {rw [hu, hv]}) e",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u ⟶ v) : e.cast hu hv = _root_.cast (by {rw [hu, hv]}) e := by subst_vars; sorry",
  "name": "Hom.cast_eq_cast",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u ⟶ v) : e.cast hu hv = _root_.cast (by {rw [hu, hv]}) e",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u ⟶ v)"},
 {"type": "(e.cast hu hv).cast hu' hv' = e.cast (hu.trans hu') (hv.trans hv')",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' u'' v'' : U}  (e : u ⟶ v)  (hu : u = u')  (hv : v = v')      (hu' : u' = u'')  (hv' : v' = v'') : (e.cast hu hv).cast hu' hv' = e.cast (hu.trans hu') (hv.trans hv') := by subst_vars; sorry",
  "name": "Hom.cast_cast",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' u'' v'' : U}  (e : u ⟶ v)  (hu : u = u')  (hv : v = v')      (hu' : u' = u'')  (hv' : v' = v'') : (e.cast hu hv).cast hu' hv' = e.cast (hu.trans hu') (hv.trans hv')",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' u'' v'' : U}  (e : u ⟶ v)  (hu : u = u')  (hv : v = v')      (hu' : u' = u'')  (hv' : v' = v'')"},
 {"type": "HEq (e.cast hu hv) e",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u ⟶ v) : HEq (e.cast hu hv) e := by subst_vars; sorry",
  "name": "Hom.cast_heq",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u ⟶ v) : HEq (e.cast hu hv) e",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u ⟶ v)"},
 {"type": "e.cast hu hv = e' ↔ HEq e e'",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u ⟶ v)  (e' : u' ⟶ v') : e.cast hu hv = e' ↔ HEq e e' := by rw [Hom.cast_eq_cast]; sorry",
  "name": "Hom.cast_eq_iff_heq",
  "kind": "theorem",
  "first-tactic": "rw [Hom.cast_eq_cast]",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u ⟶ v)  (e' : u' ⟶ v') : e.cast hu hv = e' ↔ HEq e e'",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u ⟶ v)  (e' : u' ⟶ v')"},
 {"type": "e' = e.cast hu hv ↔ HEq e' e",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u ⟶ v)  (e' : u' ⟶ v') : e' = e.cast hu hv ↔ HEq e' e := by rw [eq_comm]; sorry",
  "name": "Hom.eq_cast_iff_heq",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u ⟶ v)  (e' : u' ⟶ v') : e' = e.cast hu hv ↔ HEq e' e",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u ⟶ v)  (e' : u' ⟶ v')"},
 {"type": "p.cast hu hv = _root_.cast (by rw [hu, hv]) p",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v) : p.cast hu hv = _root_.cast (by rw [hu, hv]) p := by subst_vars; sorry",
  "name": "Path.cast_eq_cast",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v) : p.cast hu hv = _root_.cast (by rw [hu, hv]) p",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v)"},
 {"type": "(p.cast hu hv).cast hu' hv' = p.cast (hu.trans hu') (hv.trans hv')",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' u'' v'' : U}  (p : Path u v)  (hu : u = u')  (hv : v = v')      (hu' : u' = u'')  (hv' : v' = v'') : (p.cast hu hv).cast hu' hv' = p.cast (hu.trans hu') (hv.trans hv') := by subst_vars; sorry",
  "name": "Path.cast_cast",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' u'' v'' : U}  (p : Path u v)  (hu : u = u')  (hv : v = v')      (hu' : u' = u'')  (hv' : v' = v'') : (p.cast hu hv).cast hu' hv' = p.cast (hu.trans hu') (hv.trans hv')",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' u'' v'' : U}  (p : Path u v)  (hu : u = u')  (hv : v = v')      (hu' : u' = u'')  (hv' : v' = v'')"},
 {"type": "(Path.nil : Path u u).cast hu hu = Path.nil",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u u' : U}  (hu : u = u') : (Path.nil : Path u u).cast hu hu = Path.nil := by subst_vars; sorry",
  "name": "Path.cast_nil",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u u' : U}  (hu : u = u') : (Path.nil : Path u u).cast hu hu = Path.nil",
  "args": "{U : Type _}  [Quiver.{u + 1} U] {u u' : U}  (hu : u = u')"},
 {"type": "HEq (p.cast hu hv) p",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v) : HEq (p.cast hu hv) p := by rw [Path.cast_eq_cast]; sorry",
  "name": "Path.cast_heq",
  "kind": "theorem",
  "first-tactic": "rw [Path.cast_eq_cast]",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v) : HEq (p.cast hu hv) p",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v)"},
 {"type": "p.cast hu hv = p' ↔ HEq p p'",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v)      (p' : Path u' v') : p.cast hu hv = p' ↔ HEq p p' := by rw [Path.cast_eq_cast]; sorry",
  "name": "Path.cast_eq_iff_heq",
  "kind": "theorem",
  "first-tactic": "rw [Path.cast_eq_cast]",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v)      (p' : Path u' v') : p.cast hu hv = p' ↔ HEq p p'",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v)      (p' : Path u' v')"},
 {"type": "(p.cons e).cast hu hw = (p.cast hu rfl).cons (e.cast rfl hw)",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v w u' w' : U}  (p : Path u v)  (e : v ⟶ w)  (hu : u = u')  (hw : w = w') : (p.cons e).cast hu hw = (p.cast hu rfl).cons (e.cast rfl hw) := by subst_vars; sorry",
  "name": "Path.cast_cons",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v w u' w' : U}  (p : Path u v)  (e : v ⟶ w)  (hu : u = u')  (hw : w = w') : (p.cons e).cast hu hw = (p.cast hu rfl).cons (e.cast rfl hw)",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v w u' w' : U}  (p : Path u v)  (e : v ⟶ w)  (hu : u = u')  (hw : w = w')"},
 {"type": "p.cast rfl (obj_eq_of_cons_eq_cons h) = p'",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v v' w : U}  {p : Path u v}  {p' : Path u v'}  {e : v ⟶ w}      {e' : v' ⟶ w}  (h : p.cons e = p'.cons e') : p.cast rfl (obj_eq_of_cons_eq_cons h) = p' := by rw [Path.cast_eq_iff_heq]; sorry",
  "name": "cast_eq_of_cons_eq_cons",
  "kind": "theorem",
  "first-tactic": "rw [Path.cast_eq_iff_heq]",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v v' w : U}  {p : Path u v}  {p' : Path u v'}  {e : v ⟶ w}      {e' : v' ⟶ w}  (h : p.cons e = p'.cons e') : p.cast rfl (obj_eq_of_cons_eq_cons h) = p'",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v v' w : U}  {p : Path u v}  {p' : Path u v'}  {e : v ⟶ w}      {e' : v' ⟶ w}  (h : p.cons e = p'.cons e')"},
 {"type": "e.cast (obj_eq_of_cons_eq_cons h) rfl = e'",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v v' w : U}  {p : Path u v}  {p' : Path u v'}  {e : v ⟶ w}      {e' : v' ⟶ w}  (h : p.cons e = p'.cons e') : e.cast (obj_eq_of_cons_eq_cons h) rfl = e' := by rw [Hom.cast_eq_iff_heq]; sorry",
  "name": "hom_cast_eq_of_cons_eq_cons",
  "kind": "theorem",
  "first-tactic": "rw [Hom.cast_eq_iff_heq]",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v v' w : U}  {p : Path u v}  {p' : Path u v'}  {e : v ⟶ w}      {e' : v' ⟶ w}  (h : p.cons e = p'.cons e') : e.cast (obj_eq_of_cons_eq_cons h) rfl = e'",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v v' w : U}  {p : Path u v}  {p' : Path u v'}  {e : v ⟶ w}      {e' : v' ⟶ w}  (h : p.cons e = p'.cons e')"},
 {"type": "p.cast (eq_of_length_zero p hzero) rfl = Path.nil",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v : U}  (p : Path u v)  (hzero : p.length = 0) : p.cast (eq_of_length_zero p hzero) rfl = Path.nil := by cases p; sorry",
  "name": "eq_nil_of_length_zero",
  "kind": "theorem",
  "first-tactic": "cases p",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v : U}  (p : Path u v)  (hzero : p.length = 0) : p.cast (eq_of_length_zero p hzero) rfl = Path.nil",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v : U}  (p : Path u v)  (hzero : p.length = 0)"},
 {"type": "F = G",
  "tactic-prompt":
  "theorem {V : Type u}  [Quiver.{v₁} V]  {W : Type u₂}  [Quiver.{v₂} W]  {F G : Prefunctor V W}      (h_obj : ∀ X, F.obj X = G.obj X)      (h_map : ∀ (X Y : V) (f : X ⟶ Y),       F.map f = Eq.recOn (h_obj Y).symm (Eq.recOn (h_obj X).symm (G.map f))) : F = G := by cases' F with F_obj _; sorry",
  "name": "ext",
  "kind": "theorem",
  "first-tactic": "cases' F with F_obj _",
  "core-prompt":
  "{V : Type u}  [Quiver.{v₁} V]  {W : Type u₂}  [Quiver.{v₂} W]  {F G : Prefunctor V W}      (h_obj : ∀ X, F.obj X = G.obj X)      (h_map : ∀ (X Y : V) (f : X ⟶ Y),       F.map f = Eq.recOn (h_obj Y).symm (Eq.recOn (h_obj X).symm (G.map f))) : F = G",
  "args":
  "{V : Type u}  [Quiver.{v₁} V]  {W : Type u₂}  [Quiver.{v₂} W]  {F G : Prefunctor V W}      (h_obj : ∀ X, F.obj X = G.obj X)      (h_map : ∀ (X Y : V) (f : X ⟶ Y),       F.map f = Eq.recOn (h_obj Y).symm (Eq.recOn (h_obj X).symm (G.map f)))"},
 {"type": "(of σ ⋙q lift σ φ τ h) = φ",
  "tactic-prompt":
  "theorem {V : Type _}  [Quiver V]  {W : Type _}  (σ : V → W) {W' : Type _}  [Quiver W']  (φ : V ⥤q W')  (τ : W → W')  (h : ∀ x, φ.obj x = τ (σ x)) : (of σ ⋙q lift σ φ τ h) = φ := by fapply Prefunctor.ext; sorry",
  "name": "lift_comp",
  "kind": "theorem",
  "first-tactic": "fapply Prefunctor.ext",
  "core-prompt":
  "{V : Type _}  [Quiver V]  {W : Type _}  (σ : V → W) {W' : Type _}  [Quiver W']  (φ : V ⥤q W')  (τ : W → W')  (h : ∀ x, φ.obj x = τ (σ x)) : (of σ ⋙q lift σ φ τ h) = φ",
  "args":
  "{V : Type _}  [Quiver V]  {W : Type _}  (σ : V → W) {W' : Type _}  [Quiver W']  (φ : V ⥤q W')  (τ : W → W')  (h : ∀ x, φ.obj x = τ (σ x))"},
 {"type": "Φ = lift σ φ τ h",
  "tactic-prompt":
  "theorem {V : Type _}  [Quiver V]  {W : Type _}  (σ : V → W) {W' : Type _}  [Quiver W']  (φ : V ⥤q W')  (τ : W → W')  (h : ∀ x, φ.obj x = τ (σ x)) (Φ : Push σ ⥤q W')  (Φ₀ : Φ.obj = τ)  (Φcomp : (of σ ⋙q Φ) = φ) : Φ = lift σ φ τ h := by dsimp only [of]; sorry",
  "name": "lift_unique",
  "kind": "theorem",
  "first-tactic": "dsimp only [of]",
  "core-prompt":
  "{V : Type _}  [Quiver V]  {W : Type _}  (σ : V → W) {W' : Type _}  [Quiver W']  (φ : V ⥤q W')  (τ : W → W')  (h : ∀ x, φ.obj x = τ (σ x)) (Φ : Push σ ⥤q W')  (Φ₀ : Φ.obj = τ)  (Φcomp : (of σ ⋙q Φ) = φ) : Φ = lift σ φ τ h",
  "args":
  "{V : Type _}  [Quiver V]  {W : Type _}  (σ : V → W) {W' : Type _}  [Quiver W']  (φ : V ⥤q W')  (τ : W → W')  (h : ∀ x, φ.obj x = τ (σ x)) (Φ : Push σ ⥤q W')  (Φ₀ : Φ.obj = τ)  (Φcomp : (of σ ⋙q Φ) = φ)"},
 {"type": "b = c",
  "tactic-prompt":
  "lemma {V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b ⟶ d}  {e' : c ⟶ d}  (h : p.cons e = p'.cons e') : b = c := by injection h; sorry",
  "name": "obj_eq_of_cons_eq_cons",
  "kind": "lemma",
  "first-tactic": "injection h",
  "core-prompt":
  "{V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b ⟶ d}  {e' : c ⟶ d}  (h : p.cons e = p'.cons e') : b = c",
  "args":
  "{V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b ⟶ d}  {e' : c ⟶ d}  (h : p.cons e = p'.cons e')"},
 {"type": "HEq p p'",
  "tactic-prompt":
  "lemma {V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b ⟶ d}  {e' : c ⟶ d}  (h : p.cons e = p'.cons e') : HEq p p' := by injection h; sorry",
  "name": "heq_of_cons_eq_cons",
  "kind": "lemma",
  "first-tactic": "injection h",
  "core-prompt":
  "{V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b ⟶ d}  {e' : c ⟶ d}  (h : p.cons e = p'.cons e') : HEq p p'",
  "args":
  "{V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b ⟶ d}  {e' : c ⟶ d}  (h : p.cons e = p'.cons e')"},
 {"type": "HEq e e'",
  "tactic-prompt":
  "lemma {V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b ⟶ d}  {e' : c ⟶ d}  (h : p.cons e = p'.cons e') : HEq e e' := by injection h; sorry",
  "name": "hom_heq_of_cons_eq_cons",
  "kind": "lemma",
  "first-tactic": "injection h",
  "core-prompt":
  "{V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b ⟶ d}  {e' : c ⟶ d}  (h : p.cons e = p'.cons e') : HEq e e'",
  "args":
  "{V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b ⟶ d}  {e' : c ⟶ d}  (h : p.cons e = p'.cons e')"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {V : Type u}  [Quiver V]  {a b c d : V} (p : Path a b)  (hzero : p.length = 0) : a = b := by cases p; sorry",
  "name": "eq_of_length_zero",
  "kind": "theorem",
  "first-tactic": "cases p",
  "core-prompt":
  "{V : Type u}  [Quiver V]  {a b c d : V} (p : Path a b)  (hzero : p.length = 0) : a = b",
  "args":
  "{V : Type u}  [Quiver V]  {a b c d : V} (p : Path a b)  (hzero : p.length = 0)"},
 {"type": "p₁.comp q₁ = p₂.comp q₂ ↔ p₁ = p₂ ∧ q₁ = q₂",
  "tactic-prompt":
  "theorem {V : Type u}  [Quiver V]  {a b c d : V} {p₁ p₂ : Path a b}  {q₁ q₂ : Path b c}  (hq : q₁.length = q₂.length) : p₁.comp q₁ = p₂.comp q₂ ↔ p₁ = p₂ ∧ q₁ = q₂ := by refine' ⟨fun h => _, by rintro ⟨rfl, rfl⟩; rfl⟩; sorry",
  "name": "comp_inj",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, by rintro ⟨rfl, rfl⟩; rfl⟩",
  "core-prompt":
  "{V : Type u}  [Quiver V]  {a b c d : V} {p₁ p₂ : Path a b}  {q₁ q₂ : Path b c}  (hq : q₁.length = q₂.length) : p₁.comp q₁ = p₂.comp q₂ ↔ p₁ = p₂ ∧ q₁ = q₂",
  "args":
  "{V : Type u}  [Quiver V]  {a b c d : V} {p₁ p₂ : Path a b}  {q₁ q₂ : Path b c}  (hq : q₁.length = q₂.length)"},
 {"type": "decide True = true",
  "tactic-prompt":
  "theorem {a b c d : Prop} (h : Decidable True) : decide True = true := by simp; sorry",
  "name": "decide_True'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "{a b c d : Prop} (h : Decidable True) : decide True = true",
  "args": "{a b c d : Prop} (h : Decidable True)"},
 {"type": "decide False = false",
  "tactic-prompt":
  "theorem {a b c d : Prop} (h : Decidable False) : decide False = false := by simp; sorry",
  "name": "decide_False'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{a b c d : Prop} (h : Decidable False) : decide False = false",
  "args": "{a b c d : Prop} (h : Decidable False)"},
 {"type": "t",
  "tactic-prompt":
  "theorem {a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hc : c) : t := by have := if_pos hc ▸ h; sorry",
  "name": "imp_of_if_pos",
  "kind": "theorem",
  "first-tactic": "have := if_pos hc ▸ h",
  "core-prompt":
  "{a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hc : c) : t",
  "args":
  "{a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hc : c)"},
 {"type": "e",
  "tactic-prompt":
  "theorem {a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hnc : ¬c) : e := by have := if_neg hnc ▸ h; sorry",
  "name": "imp_of_if_neg",
  "kind": "theorem",
  "first-tactic": "have := if_neg hnc ▸ h",
  "core-prompt":
  "{a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hnc : ¬c) : e",
  "args":
  "{a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hnc : ¬c)"},
 {"type": "HEq (let x : α := a₁; b x) (let x : α := a₂; b x)",
  "tactic-prompt":
  "theorem {a b c d : Prop} {α : Sort v}  {β : α → Sort u}  {a₁ a₂ : α}  (b : ∀ x : α, β x)      (h : a₁ = a₂) : HEq (let x : α := a₁; b x) (let x : α := a₂; b x) := by cases h; sorry",
  "name": "let_value_heq",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{a b c d : Prop} {α : Sort v}  {β : α → Sort u}  {a₁ a₂ : α}  (b : ∀ x : α, β x)      (h : a₁ = a₂) : HEq (let x : α := a₁; b x) (let x : α := a₂; b x)",
  "args":
  "{a b c d : Prop} {α : Sort v}  {β : α → Sort u}  {a₁ a₂ : α}  (b : ∀ x : α, β x)      (h : a₁ = a₂)"},
 {"type": "(let x : α := a; b₁ x) = (let x : α := a; b₂ x)",
  "tactic-prompt":
  "theorem {a b c d : Prop} {α : Sort v}  {β : α → Sort u}  (a : α)  {b₁ b₂ : ∀ x : α, β x}      (h : ∀ x, b₁ x = b₂ x) : (let x : α := a; b₁ x) = (let x : α := a; b₂ x) := by exact h _ ▸ rfl; sorry",
  "name": "let_body_eq",
  "kind": "theorem",
  "first-tactic": "exact h _ ▸ rfl",
  "core-prompt":
  "{a b c d : Prop} {α : Sort v}  {β : α → Sort u}  (a : α)  {b₁ b₂ : ∀ x : α, β x}      (h : ∀ x, b₁ x = b₂ x) : (let x : α := a; b₁ x) = (let x : α := a; b₂ x)",
  "args":
  "{a b c d : Prop} {α : Sort v}  {β : α → Sort u}  (a : α)  {b₁ b₂ : ∀ x : α, β x}      (h : ∀ x, b₁ x = b₂ x)"},
 {"type": "(let x : α := a₁; b₁ x) = (let x : α := a₂; b₂ x)",
  "tactic-prompt":
  "theorem {a b c d : Prop} {α : Sort v}  {β : Sort u}  {a₁ a₂ : α}  {b₁ b₂ : α → β}      (h₁ : a₁ = a₂)  (h₂ : ∀ x, b₁ x = b₂ x) : (let x : α := a₁; b₁ x) = (let x : α := a₂; b₂ x) := by simp [h₁]; sorry",
  "name": "let_eq",
  "kind": "theorem",
  "first-tactic": "simp [h₁]",
  "core-prompt":
  "{a b c d : Prop} {α : Sort v}  {β : Sort u}  {a₁ a₂ : α}  {b₁ b₂ : α → β}      (h₁ : a₁ = a₂)  (h₂ : ∀ x, b₁ x = b₂ x) : (let x : α := a₁; b₁ x) = (let x : α := a₂; b₂ x)",
  "args":
  "{a b c d : Prop} {α : Sort v}  {β : Sort u}  {a₁ a₂ : α}  {b₁ b₂ : α → β}      (h₁ : a₁ = a₂)  (h₂ : ∀ x, b₁ x = b₂ x)"},
 {"type": "min a b ≤ a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a b : α) : min a b ≤ a := by if h : a ≤ b\n  then simp [min_def]; sorry",
  "name": "min_le_left",
  "kind": "lemma",
  "first-tactic": "if h : a ≤ b\n  then simp [min_def]",
  "core-prompt": "{α : Type u}  [LinearOrder α] (a b : α) : min a b ≤ a",
  "args": "{α : Type u}  [LinearOrder α] (a b : α)"},
 {"type": "min a b ≤ b",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a b : α) : min a b ≤ b := by if h : a ≤ b\n  then simp [min_def]; sorry",
  "name": "min_le_right",
  "kind": "lemma",
  "first-tactic": "if h : a ≤ b\n  then simp [min_def]",
  "core-prompt": "{α : Type u}  [LinearOrder α] (a b : α) : min a b ≤ b",
  "args": "{α : Type u}  [LinearOrder α] (a b : α)"},
 {"type": "c ≤ min a b",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b c : α}  (h₁ : c ≤ a)  (h₂ : c ≤ b) : c ≤ min a b := by if h : a ≤ b\n  then simp [min_def]; sorry",
  "name": "le_min",
  "kind": "lemma",
  "first-tactic": "if h : a ≤ b\n  then simp [min_def]",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b c : α}  (h₁ : c ≤ a)  (h₂ : c ≤ b) : c ≤ min a b",
  "args":
  "{α : Type u}  [LinearOrder α] {a b c : α}  (h₁ : c ≤ a)  (h₂ : c ≤ b)"},
 {"type": "a ≤ max a b",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a b : α) : a ≤ max a b := by if h : a ≤ b\n  then simp [max_def]; sorry",
  "name": "le_max_left",
  "kind": "lemma",
  "first-tactic": "if h : a ≤ b\n  then simp [max_def]",
  "core-prompt": "{α : Type u}  [LinearOrder α] (a b : α) : a ≤ max a b",
  "args": "{α : Type u}  [LinearOrder α] (a b : α)"},
 {"type": "b ≤ max a b",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a b : α) : b ≤ max a b := by if h : a ≤ b\n  then simp [max_def]; sorry",
  "name": "le_max_right",
  "kind": "lemma",
  "first-tactic": "if h : a ≤ b\n  then simp [max_def]",
  "core-prompt": "{α : Type u}  [LinearOrder α] (a b : α) : b ≤ max a b",
  "args": "{α : Type u}  [LinearOrder α] (a b : α)"},
 {"type": "max a b ≤ c",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b c : α}  (h₁ : a ≤ c)  (h₂ : b ≤ c) : max a b ≤ c := by if h : a ≤ b\n  then simp [max_def]; sorry",
  "name": "max_le",
  "kind": "lemma",
  "first-tactic": "if h : a ≤ b\n  then simp [max_def]",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b c : α}  (h₁ : a ≤ c)  (h₂ : b ≤ c) : max a b ≤ c",
  "args":
  "{α : Type u}  [LinearOrder α] {a b c : α}  (h₁ : a ≤ c)  (h₂ : b ≤ c)"},
 {"type": "min (min a b) c = min a (min b c)",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a b c : α) : min (min a b) c = min a (min b c) := by apply eq_min; sorry",
  "name": "min_assoc",
  "kind": "lemma",
  "first-tactic": "apply eq_min",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] (a b c : α) : min (min a b) c = min a (min b c)",
  "args": "{α : Type u}  [LinearOrder α] (a b c : α)"},
 {"type": "min a a = a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a : α) : min a a = a := by simp [min_def]; sorry",
  "name": "min_self",
  "kind": "lemma",
  "first-tactic": "simp [min_def]",
  "core-prompt": "{α : Type u}  [LinearOrder α] (a : α) : min a a = a",
  "args": "{α : Type u}  [LinearOrder α] (a : α)"},
 {"type": "min a b = a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b) : min a b = a := by apply Eq.symm; sorry",
  "name": "min_eq_left",
  "kind": "lemma",
  "first-tactic": "apply Eq.symm",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b) : min a b = a",
  "args": "{α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b)"},
 {"type": "min a b = b",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a) : min a b = b := by rw [min_comm]; sorry",
  "name": "min_eq_right",
  "kind": "lemma",
  "first-tactic": "rw [min_comm]",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a) : min a b = b",
  "args": "{α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a)"},
 {"type": "max (max a b) c = max a (max b c)",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a b c : α) : max (max a b) c = max a (max b c) := by apply eq_max; sorry",
  "name": "max_assoc",
  "kind": "lemma",
  "first-tactic": "apply eq_max",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] (a b c : α) : max (max a b) c = max a (max b c)",
  "args": "{α : Type u}  [LinearOrder α] (a b c : α)"},
 {"type": "max a a = a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a : α) : max a a = a := by simp [max_def]; sorry",
  "name": "max_self",
  "kind": "lemma",
  "first-tactic": "simp [max_def]",
  "core-prompt": "{α : Type u}  [LinearOrder α] (a : α) : max a a = a",
  "args": "{α : Type u}  [LinearOrder α] (a : α)"},
 {"type": "max a b = a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a) : max a b = a := by apply Eq.symm; sorry",
  "name": "max_eq_left",
  "kind": "lemma",
  "first-tactic": "apply Eq.symm",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a) : max a b = a",
  "args": "{α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a)"},
 {"type": "max a b = b",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b) : max a b = b := by rw [←max_comm b a]; sorry",
  "name": "max_eq_right",
  "kind": "lemma",
  "first-tactic": "rw [←max_comm b a]",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b) : max a b = b",
  "args": "{α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b)"},
 {"type": "∀ a b, min a b = if a ≤ b then a else b",
  "tactic-prompt":
  "def {α : Type u}  -- set_option auto_param.check_exists false : ∀ a b, min a b = if a ≤ b then a else b := by intros; sorry",
  "name": "",
  "kind": "def",
  "first-tactic": "intros",
  "core-prompt":
  "{α : Type u}  -- set_option auto_param.check_exists false : ∀ a b, min a b = if a ≤ b then a else b",
  "args": "{α : Type u}  -- set_option auto_param.check_exists false"},
 {"type": "∀ a b, max a b = if a ≤ b then b else a",
  "tactic-prompt":
  "def {α : Type u}  -- set_option auto_param.check_exists false : ∀ a b, max a b = if a ≤ b then b else a := by intros; sorry",
  "name": "",
  "kind": "def",
  "first-tactic": "intros",
  "core-prompt":
  "{α : Type u}  -- set_option auto_param.check_exists false : ∀ a b, max a b = if a ≤ b then b else a",
  "args": "{α : Type u}  -- set_option auto_param.check_exists false"},
 {"type": "bodd (succ n) = not (bodd n)",
  "tactic-prompt":
  "theorem (n : ℕ) : bodd (succ n) = not (bodd n) := by simp only [bodd]; sorry",
  "name": "bodd_succ",
  "kind": "theorem",
  "first-tactic": "simp only [bodd]",
  "core-prompt": "(n : ℕ) : bodd (succ n) = not (bodd n)",
  "args": "(n : ℕ)"},
 {"type": "bodd (m + n) = bxor (bodd m) (bodd n)",
  "tactic-prompt":
  "theorem (m n : ℕ) : bodd (m + n) = bxor (bodd m) (bodd n) := by induction' n with n IH; sorry",
  "name": "bodd_add",
  "kind": "theorem",
  "first-tactic": "induction' n with n IH",
  "core-prompt": "(m n : ℕ) : bodd (m + n) = bxor (bodd m) (bodd n)",
  "args": "(m n : ℕ)"},
 {"type": "bodd (m * n) = (bodd m && bodd n)",
  "tactic-prompt":
  "theorem (m n : ℕ) : bodd (m * n) = (bodd m && bodd n) := by induction' n with n IH; sorry",
  "name": "bodd_mul",
  "kind": "theorem",
  "first-tactic": "induction' n with n IH",
  "core-prompt": "(m n : ℕ) : bodd (m * n) = (bodd m && bodd n)",
  "args": "(m n : ℕ)"},
 {"type": "n % 2 = cond (bodd n) 1 0",
  "tactic-prompt":
  "theorem (n : ℕ) : n % 2 = cond (bodd n) 1 0 := by have := congr_arg bodd (mod_add_div n 2); sorry",
  "name": "mod_two_of_bodd",
  "kind": "theorem",
  "first-tactic": "have := congr_arg bodd (mod_add_div n 2)",
  "core-prompt": "(n : ℕ) : n % 2 = cond (bodd n) 1 0",
  "args": "(n : ℕ)"},
 {"type": "div2 (succ n) = cond (bodd n) (succ (div2 n)) (div2 n)",
  "tactic-prompt":
  "theorem (n : ℕ) : div2 (succ n) = cond (bodd n) (succ (div2 n)) (div2 n) := by simp only [bodd]; sorry",
  "name": "div2_succ",
  "kind": "theorem",
  "first-tactic": "simp only [bodd]",
  "core-prompt":
  "(n : ℕ) : div2 (succ n) = cond (bodd n) (succ (div2 n)) (div2 n)",
  "args": "(n : ℕ)"},
 {"type": "∀ n, shiftr 0 n = 0",
  "tactic-prompt": "theorem  : ∀ n, shiftr 0 n = 0 := by intros; sorry",
  "name": "shiftr_zero",
  "kind": "theorem",
  "first-tactic": "intros",
  "core-prompt": " : ∀ n, shiftr 0 n = 0",
  "args": ""},
 {"type": "div2 n < n",
  "tactic-prompt": "lemma (h : n ≠ 0) : div2 n < n := by rw [div2_val]; sorry",
  "name": "binaryRec_decreasing",
  "kind": "lemma",
  "first-tactic": "rw [div2_val]",
  "core-prompt": "(h : n ≠ 0) : div2 n < n",
  "args": "(h : n ≠ 0)"},
 {"type": "binaryRec z f 0 = z",
  "tactic-prompt":
  "theorem {C : Nat → Sort u}  (z : C 0)  (f : ∀ b n, C n → C (bit b n)) : binaryRec z f 0 = z := by rw [binaryRec]; sorry",
  "name": "binary_rec_zero",
  "kind": "theorem",
  "first-tactic": "rw [binaryRec]",
  "core-prompt":
  "{C : Nat → Sort u}  (z : C 0)  (f : ∀ b n, C n → C (bit b n)) : binaryRec z f 0 = z",
  "args": "{C : Nat → Sort u}  (z : C 0)  (f : ∀ b n, C n → C (bit b n))"},
 {"type":
  "(@binaryRec (fun _ => ℕ) (cond (f true false) (bit false 0) 0) fun b n _ =>\n        bit (f false b) (cond (f false true) n 0)) =\n      fun n : ℕ => cond (f false true) n 0",
  "tactic-prompt":
  "theorem {f : Bool → Bool → Bool}  (h : f false false = false) : (@binaryRec (fun _ => ℕ) (cond (f true false) (bit false 0) 0) fun b n _ =>\n        bit (f false b) (cond (f false true) n 0)) =\n      fun n : ℕ => cond (f false true) n 0 := by funext n; sorry",
  "name": "bitwise'_bit_aux",
  "kind": "theorem",
  "first-tactic": "funext n",
  "core-prompt":
  "{f : Bool → Bool → Bool}  (h : f false false = false) : (@binaryRec (fun _ => ℕ) (cond (f true false) (bit false 0) 0) fun b n _ =>\n        bit (f false b) (cond (f false true) n 0)) =\n      fun n : ℕ => cond (f false true) n 0",
  "args": "{f : Bool → Bool → Bool}  (h : f false false = false)"},
 {"type": "bitwise' f 0 0 = 0",
  "tactic-prompt":
  "theorem (f : Bool → Bool → Bool) : bitwise' f 0 0 = 0 := by rw [bitwise'_zero_left]; sorry",
  "name": "bitwise'_zero",
  "kind": "theorem",
  "first-tactic": "rw [bitwise'_zero_left]",
  "core-prompt": "(f : Bool → Bool → Bool) : bitwise' f 0 0 = 0",
  "args": "(f : Bool → Bool → Bool)"},
 {"type": "bitwise' (Function.swap f) = Function.swap (bitwise' f)",
  "tactic-prompt":
  "theorem {f : Bool → Bool → Bool}  (h : f false false = false) : bitwise' (Function.swap f) = Function.swap (bitwise' f) := by funext m n; sorry",
  "name": "bitwise'_swap",
  "kind": "theorem",
  "first-tactic": "funext m n",
  "core-prompt":
  "{f : Bool → Bool → Bool}  (h : f false false = false) : bitwise' (Function.swap f) = Function.swap (bitwise' f)",
  "args": "{f : Bool → Bool → Bool}  (h : f false false = false)"},
 {"type": "WellFounded (lbp p)",
  "tactic-prompt":
  "def (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) : WellFounded (lbp p) := by refine ⟨let ⟨n, pn⟩ := H; ?_⟩; sorry",
  "name": "wf_lbp",
  "kind": "def",
  "first-tactic": "refine ⟨let ⟨n, pn⟩ := H; ?_⟩",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) : WellFounded (lbp p)",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n)"},
 {"type":
  "∀ (n : Nat) (l1 l2 : List Char), l1.length = l2.length →\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat) : ∀ (n : Nat) (l1 l2 : List Char), l1.length = l2.length →\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length := by induction f; sorry",
  "name": "to_digits_core_lens_eq_aux",
  "kind": "lemma",
  "first-tactic": "induction f",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat) : ∀ (n : Nat) (l1 l2 : List Char), l1.length = l2.length →\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat)"},
 {"type":
  "∀ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat) : ∀ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1 := by induction f; sorry",
  "name": "to_digits_core_lens_eq",
  "kind": "lemma",
  "first-tactic": "induction f",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat) : ∀ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat)"},
 {"type": "n < b ^ e.succ → n / b < b ^ e",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n b e : Nat)  (h_b_pos : 0 < b) : n < b ^ e.succ → n / b < b ^ e := by simp only [Nat.pow_succ]; sorry",
  "name": "nat_repr_len_aux",
  "kind": "lemma",
  "first-tactic": "simp only [Nat.pow_succ]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n b e : Nat)  (h_b_pos : 0 < b) : n < b ^ e.succ → n / b < b ^ e",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n b e : Nat)  (h_b_pos : 0 < b)"},
 {"type": "(Nat.toDigitsCore b f n []).length <= e",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b : Nat)  (h : 2 <= b)  (f n e : Nat)      (hlt : n < b ^ e)  (h_e_pos: 0 < e) : (Nat.toDigitsCore b f n []).length <= e := by induction f generalizing n e hlt h_e_pos with\n    simp only [Nat.toDigitsCore]; sorry",
  "name": "to_digits_core_length",
  "kind": "lemma",
  "first-tactic":
  "induction f generalizing n e hlt h_e_pos with\n    simp only [Nat.toDigitsCore]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b : Nat)  (h : 2 <= b)  (f n e : Nat)      (hlt : n < b ^ e)  (h_e_pos: 0 < e) : (Nat.toDigitsCore b f n []).length <= e",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b : Nat)  (h : 2 <= b)  (f n e : Nat)      (hlt : n < b ^ e)  (h_e_pos: 0 < e)"},
 {"type": "0 < e → n < 10 ^ e → (Nat.repr n).length <= e",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n e : Nat) : 0 < e → n < 10 ^ e → (Nat.repr n).length <= e := by cases n; sorry",
  "name": "repr_length",
  "kind": "lemma",
  "first-tactic": "cases n",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n e : Nat) : 0 < e → n < 10 ^ e → (Nat.repr n).length <= e",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n e : Nat)"},
 {"type": "xor b b = false",
  "tactic-prompt": "theorem (b : Bool) : xor b b = false := by cases b; sorry",
  "name": "xor_self",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Bool) : xor b b = false",
  "args": "(b : Bool)"},
 {"type": "xor b true = not b",
  "tactic-prompt":
  "theorem (b : Bool) : xor b true = not b := by cases b; sorry",
  "name": "xor_true",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Bool) : xor b true = not b",
  "args": "(b : Bool)"},
 {"type": "xor b false = b",
  "tactic-prompt": "theorem (b : Bool) : xor b false = b := by cases b; sorry",
  "name": "xor_false",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Bool) : xor b false = b",
  "args": "(b : Bool)"},
 {"type": "xor true b = not b",
  "tactic-prompt":
  "theorem (b : Bool) : xor true b = not b := by cases b; sorry",
  "name": "true_xor",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Bool) : xor true b = not b",
  "args": "(b : Bool)"},
 {"type": "xor false b = b",
  "tactic-prompt": "theorem (b : Bool) : xor false b = b := by cases b; sorry",
  "name": "false_xor",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Bool) : xor false b = b",
  "args": "(b : Bool)"},
 {"type": "¬true = false",
  "tactic-prompt": "theorem  : ¬true = false := by decide; sorry",
  "name": "true_eq_false_eq_False",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ¬true = false",
  "args": ""},
 {"type": "¬false = true",
  "tactic-prompt": "theorem  : ¬false = true := by decide; sorry",
  "name": "false_eq_true_eq_False",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ¬false = true",
  "args": ""},
 {"type": "(¬b = true) = (b = false)",
  "tactic-prompt":
  "theorem (b : Bool) : (¬b = true) = (b = false) := by simp; sorry",
  "name": "eq_false_eq_not_eq_true",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(b : Bool) : (¬b = true) = (b = false)",
  "args": "(b : Bool)"},
 {"type": "(¬b = false) = (b = true)",
  "tactic-prompt":
  "theorem (b : Bool) : (¬b = false) = (b = true) := by simp; sorry",
  "name": "eq_true_eq_not_eq_false",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(b : Bool) : (¬b = false) = (b = true)",
  "args": "(b : Bool)"},
 {"type": "((a && b) = true) = (a = true ∧ b = true)",
  "tactic-prompt":
  "theorem (a b : Bool) : ((a && b) = true) = (a = true ∧ b = true) := by simp; sorry",
  "name": "and_eq_true_eq_eq_true_and_eq_true",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : Bool) : ((a && b) = true) = (a = true ∧ b = true)",
  "args": "(a b : Bool)"},
 {"type": "((a || b) = true) = (a = true ∨ b = true)",
  "tactic-prompt":
  "theorem (a b : Bool) : ((a || b) = true) = (a = true ∨ b = true) := by simp; sorry",
  "name": "or_eq_true_eq_eq_true_or_eq_true",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : Bool) : ((a || b) = true) = (a = true ∨ b = true)",
  "args": "(a b : Bool)"},
 {"type": "(not a = true) = (a = false)",
  "tactic-prompt":
  "theorem (a : Bool) : (not a = true) = (a = false) := by cases a; sorry",
  "name": "not_eq_true_eq_eq_false",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a : Bool) : (not a = true) = (a = false)",
  "args": "(a : Bool)"},
 {"type": "((a && b) = false) = (a = false ∨ b = false)",
  "tactic-prompt":
  "theorem (a b : Bool) : ((a && b) = false) = (a = false ∨ b = false) := by cases a; sorry",
  "name": "and_eq_false_eq_eq_false_or_eq_false",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b : Bool) : ((a && b) = false) = (a = false ∨ b = false)",
  "args": "(a b : Bool)"},
 {"type": "((a || b) = false) = (a = false ∧ b = false)",
  "tactic-prompt":
  "theorem (a b : Bool) : ((a || b) = false) = (a = false ∧ b = false) := by cases a; sorry",
  "name": "or_eq_false_eq_eq_false_and_eq_false",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b : Bool) : ((a || b) = false) = (a = false ∧ b = false)",
  "args": "(a b : Bool)"},
 {"type": "(not a = false) = (a = true)",
  "tactic-prompt":
  "theorem (a : Bool) : (not a = false) = (a = true) := by cases a; sorry",
  "name": "not_eq_false_eq_eq_true",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a : Bool) : (not a = false) = (a = true)",
  "args": "(a : Bool)"},
 {"type": "↑false = False",
  "tactic-prompt": "theorem  : ↑false = False := by simp; sorry",
  "name": "coe_false",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : ↑false = False",
  "args": ""},
 {"type": "↑true = True",
  "tactic-prompt": "theorem  : ↑true = True := by simp; sorry",
  "name": "coe_true",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : ↑true = True",
  "args": ""},
 {"type": "(↥false : Prop) = False",
  "tactic-prompt": "theorem  : (↥false : Prop) = False := by simp; sorry",
  "name": "coe_sort_false",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : (↥false : Prop) = False",
  "args": ""},
 {"type": "(↥true : Prop) = True",
  "tactic-prompt": "theorem  : (↥true : Prop) = True := by simp; sorry",
  "name": "coe_sort_true",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : (↥true : Prop) = True",
  "args": ""},
 {"type": "decide p = true ↔ p",
  "tactic-prompt":
  "theorem (p : Prop)  [d : Decidable p] : decide p = true ↔ p := by simp; sorry",
  "name": "decide_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(p : Prop)  [d : Decidable p] : decide p = true ↔ p",
  "args": "(p : Prop)  [d : Decidable p]"},
 {"type": "¬b ↔ b = false",
  "tactic-prompt": "theorem {b : Bool} : ¬b ↔ b = false := by cases b; sorry",
  "name": "bool_iff_false",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "{b : Bool} : ¬b ↔ b = false",
  "args": "{b : Bool}"},
 {"type": "decide p = decide q",
  "tactic-prompt":
  "theorem {p q : Prop}  [Decidable p]  [Decidable q]  (h : p ↔ q) : decide p = decide q := by cases h' : decide q; sorry",
  "name": "decide_congr",
  "kind": "theorem",
  "first-tactic": "cases h' : decide q",
  "core-prompt":
  "{p q : Prop}  [Decidable p]  [Decidable q]  (h : p ↔ q) : decide p = decide q",
  "args": "{p q : Prop}  [Decidable p]  [Decidable q]  (h : p ↔ q)"},
 {"type": "a || b ↔ a ∨ b",
  "tactic-prompt": "theorem (a b : Bool) : a || b ↔ a ∨ b := by simp; sorry",
  "name": "or_coe_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : Bool) : a || b ↔ a ∨ b",
  "args": "(a b : Bool)"},
 {"type": "a && b ↔ a ∧ b",
  "tactic-prompt": "theorem (a b : Bool) : a && b ↔ a ∧ b := by simp; sorry",
  "name": "and_coe_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : Bool) : a && b ↔ a ∧ b",
  "args": "(a b : Bool)"},
 {"type": "xor a b ↔ Xor' (a = true) (b = true)",
  "tactic-prompt":
  "theorem (a b : Bool) : xor a b ↔ Xor' (a = true) (b = true) := by cases a; sorry",
  "name": "xor_coe_iff",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b : Bool) : xor a b ↔ Xor' (a = true) (b = true)",
  "args": "(a b : Bool)"},
 {"type": "((if c then a else b) = true) = if c then a = true else b = true",
  "tactic-prompt":
  "theorem (c : Prop)  [Decidable c]  (a b : Bool) : ((if c then a else b) = true) = if c then a = true else b = true := by by_cases c; sorry",
  "name": "ite_eq_true_distrib",
  "kind": "theorem",
  "first-tactic": "by_cases c",
  "core-prompt":
  "(c : Prop)  [Decidable c]  (a b : Bool) : ((if c then a else b) = true) = if c then a = true else b = true",
  "args": "(c : Prop)  [Decidable c]  (a b : Bool)"},
 {"type": "((if c then a else b) = false) = if c then a = false else b = false",
  "tactic-prompt":
  "theorem (c : Prop)  [Decidable c]  (a b : Bool) : ((if c then a else b) = false) = if c then a = false else b = false := by by_cases c; sorry",
  "name": "ite_eq_false_distrib",
  "kind": "theorem",
  "first-tactic": "by_cases c",
  "core-prompt":
  "(c : Prop)  [Decidable c]  (a b : Bool) : ((if c then a else b) = false) = if c then a = false else b = false",
  "args": "(c : Prop)  [Decidable c]  (a b : Bool)"},
 {"type": "length («repeat»  a n) = n",
  "tactic-prompt":
  "theorem (a : α)  (n : ℕ) : length («repeat»  a n) = n := by induction n; sorry",
  "name": "length_repeat",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "(a : α)  (n : ℕ) : length («repeat»  a n) = n",
  "args": "(a : α)  (n : ℕ)"},
 {"type": "(σ ^ m) ((σ ^ n) x) = (σ ^ n) ((σ ^ m) x)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v} {α : Type _}  (σ : Perm α)  (m n : ℤ)  {x : α} : (σ ^ m) ((σ ^ n) x) = (σ ^ n) ((σ ^ m) x) := by rw [← Equiv.Perm.mul_apply]; sorry",
  "name": "zpow_apply_comm",
  "kind": "theorem",
  "first-tactic": "rw [← Equiv.Perm.mul_apply]",
  "core-prompt":
  "{α : Type u}  {β : Type v} {α : Type _}  (σ : Perm α)  (m n : ℤ)  {x : α} : (σ ^ m) ((σ ^ n) x) = (σ ^ n) ((σ ^ m) x)",
  "args":
  "{α : Type u}  {β : Type v} {α : Type _}  (σ : Perm α)  (m n : ℤ)  {x : α}"},
 {"type": "Function.Injective (sumCongrHom α β)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v} {α β : Type _} : Function.Injective (sumCongrHom α β) := by rintro ⟨⟩ ⟨⟩ h; sorry",
  "name": "sumCongrHom_injective",
  "kind": "theorem",
  "first-tactic": "rintro ⟨⟩ ⟨⟩ h",
  "core-prompt":
  "{α : Type u}  {β : Type v} {α β : Type _} : Function.Injective (sumCongrHom α β)",
  "args": "{α : Type u}  {β : Type v} {α β : Type _}"},
 {"type": "Function.Injective (sigmaCongrRightHom β)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v} {α : Type _}  {β : α → Type _} : Function.Injective (sigmaCongrRightHom β) := by intro x y h; sorry",
  "name": "sigmaCongrRightHom_injective",
  "kind": "theorem",
  "first-tactic": "intro x y h",
  "core-prompt":
  "{α : Type u}  {β : Type v} {α : Type _}  {β : α → Type _} : Function.Injective (sigmaCongrRightHom β)",
  "args": "{α : Type u}  {β : Type v} {α : Type _}  {β : α → Type _}"},
 {"type": "Function.Injective (subtypeCongrHom p)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v} (p : α → Prop)  [DecidablePred p] : Function.Injective (subtypeCongrHom p) := by rintro ⟨⟩ ⟨⟩ h; sorry",
  "name": "subtypeCongrHom_injective",
  "kind": "theorem",
  "first-tactic": "rintro ⟨⟩ ⟨⟩ h",
  "core-prompt":
  "{α : Type u}  {β : Type v} (p : α → Prop)  [DecidablePred p] : Function.Injective (subtypeCongrHom p)",
  "args": "{α : Type u}  {β : Type v} (p : α → Prop)  [DecidablePred p]"},
 {"type": "f * swap x y = swap (f x) (f y) * f",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [DecidableEq α] (f : Perm α)  (x y : α) : f * swap x y = swap (f x) (f y) * f := by rw [swap_mul_eq_mul_swap]; sorry",
  "name": "mul_swap_eq_swap_mul",
  "kind": "theorem",
  "first-tactic": "rw [swap_mul_eq_mul_swap]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [DecidableEq α] (f : Perm α)  (x y : α) : f * swap x y = swap (f x) (f y) * f",
  "args":
  "{α : Type u}  {β : Type v}  [DecidableEq α] (f : Perm α)  (x y : α)"},
 {"type": "swap (f x) (f y) = f * swap x y * f⁻¹",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [DecidableEq α] (f : Perm α)  (x y : α) : swap (f x) (f y) = f * swap x y * f⁻¹ := by rw [mul_swap_eq_swap_mul]; sorry",
  "name": "swap_apply_apply",
  "kind": "theorem",
  "first-tactic": "rw [mul_swap_eq_swap_mul]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [DecidableEq α] (f : Perm α)  (x y : α) : swap (f x) (f y) = f * swap x y * f⁻¹",
  "args":
  "{α : Type u}  {β : Type v}  [DecidableEq α] (f : Perm α)  (x y : α)"},
 {"type": "Equiv.swap i j * (Equiv.swap i j * σ) = σ",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [DecidableEq α] (i j : α)  (σ : Perm α) : Equiv.swap i j * (Equiv.swap i j * σ) = σ := by rw [← mul_assoc]; sorry",
  "name": "swap_mul_self_mul",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [DecidableEq α] (i j : α)  (σ : Perm α) : Equiv.swap i j * (Equiv.swap i j * σ) = σ",
  "args":
  "{α : Type u}  {β : Type v}  [DecidableEq α] (i j : α)  (σ : Perm α)"},
 {"type": "σ * Equiv.swap i j * Equiv.swap i j = σ",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [DecidableEq α] (i j : α)  (σ : Perm α) : σ * Equiv.swap i j * Equiv.swap i j = σ := by rw [mul_assoc]; sorry",
  "name": "mul_swap_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [DecidableEq α] (i j : α)  (σ : Perm α) : σ * Equiv.swap i j * Equiv.swap i j = σ",
  "args":
  "{α : Type u}  {β : Type v}  [DecidableEq α] (i j : α)  (σ : Perm α)"},
 {"type": "e₁ = e₂",
  "tactic-prompt":
  "theorem {X : Type u} {m₁ m₂ : X → X → X}  {e₁ e₂ : X} (h₁ : IsUnital m₁ e₁)  (h₂ : IsUnital m₂ e₂) : e₁ = e₂ := by simpa only [h₁.left_id]; sorry",
  "name": "one",
  "kind": "theorem",
  "first-tactic": "simpa only [h₁.left_id]",
  "core-prompt":
  "{X : Type u} {m₁ m₂ : X → X → X}  {e₁ e₂ : X} (h₁ : IsUnital m₁ e₁)  (h₂ : IsUnital m₂ e₂) : e₁ = e₂",
  "args":
  "{X : Type u} {m₁ m₂ : X → X → X}  {e₁ e₂ : X} (h₁ : IsUnital m₁ e₁)  (h₂ : IsUnital m₂ e₂)"},
 {"type": "m₁ = m₂",
  "tactic-prompt":
  "theorem {X : Type u} {m₁ m₂ : X → X → X}  {e₁ e₂ : X} (h₁ : IsUnital m₁ e₁)  (h₂ : IsUnital m₂ e₂) : m₁ = m₂ := by funext a b; sorry",
  "name": "mul",
  "kind": "theorem",
  "first-tactic": "funext a b",
  "core-prompt":
  "{X : Type u} {m₁ m₂ : X → X → X}  {e₁ e₂ : X} (h₁ : IsUnital m₁ e₁)  (h₂ : IsUnital m₂ e₂) : m₁ = m₂",
  "args":
  "{X : Type u} {m₁ m₂ : X → X → X}  {e₁ e₂ : X} (h₁ : IsUnital m₁ e₁)  (h₂ : IsUnital m₂ e₂)"},
 {"type": "(a • b) • c • d = (a • c) • b • d",
  "tactic-prompt":
  "theorem {M N G A B α β γ δ : Type _} [SMul M α]  [SMul α β]  [SMul α γ]  [SMul β δ]  [SMul α δ]  [SMul γ δ]      [IsScalarTower α β δ]  [IsScalarTower α γ δ]  [SMulCommClass β γ δ]  (a : α)  (b : β)  (c : γ)      (d : δ) : (a • b) • c • d = (a • c) • b • d := by rw [smul_assoc]; sorry",
  "name": "smul_smul_smul_comm",
  "kind": "theorem",
  "first-tactic": "rw [smul_assoc]",
  "core-prompt":
  "{M N G A B α β γ δ : Type _} [SMul M α]  [SMul α β]  [SMul α γ]  [SMul β δ]  [SMul α δ]  [SMul γ δ]      [IsScalarTower α β δ]  [IsScalarTower α γ δ]  [SMulCommClass β γ δ]  (a : α)  (b : β)  (c : γ)      (d : δ) : (a • b) • c • d = (a • c) • b • d",
  "args":
  "{M N G A B α β γ δ : Type _} [SMul M α]  [SMul α β]  [SMul α γ]  [SMul β δ]  [SMul α δ]  [SMul γ δ]      [IsScalarTower α β δ]  [IsScalarTower α γ δ]  [SMulCommClass β γ δ]  (a : α)  (b : β)  (c : γ)      (d : δ)"},
 {"type": "ite p a₁ a₂ • b = ite p (a₁ • b) (a₂ • b)",
  "tactic-prompt":
  "theorem {M N G A B α β γ δ : Type _} [SMul M α]  [SMul M α]  (p : Prop)  [Decidable p] (a₁ a₂ : M)  (b : α) : ite p a₁ a₂ • b = ite p (a₁ • b) (a₂ • b) := by split_ifs; sorry",
  "name": "ite_smul",
  "kind": "theorem",
  "first-tactic": "split_ifs",
  "core-prompt":
  "{M N G A B α β γ δ : Type _} [SMul M α]  [SMul M α]  (p : Prop)  [Decidable p] (a₁ a₂ : M)  (b : α) : ite p a₁ a₂ • b = ite p (a₁ • b) (a₂ • b)",
  "args":
  "{M N G A B α β γ δ : Type _} [SMul M α]  [SMul M α]  (p : Prop)  [Decidable p] (a₁ a₂ : M)  (b : α)"},
 {"type": "a • ite p b₁ b₂ = ite p (a • b₁) (a • b₂)",
  "tactic-prompt":
  "theorem {M N G A B α β γ δ : Type _} [SMul M α]  [SMul M α]  (p : Prop)  [Decidable p] (a : M)  (b₁ b₂ : α) : a • ite p b₁ b₂ = ite p (a • b₁) (a • b₂) := by split_ifs; sorry",
  "name": "smul_ite",
  "kind": "theorem",
  "first-tactic": "split_ifs",
  "core-prompt":
  "{M N G A B α β γ δ : Type _} [SMul M α]  [SMul M α]  (p : Prop)  [Decidable p] (a : M)  (b₁ b₂ : α) : a • ite p b₁ b₂ = ite p (a • b₁) (a • b₂)",
  "args":
  "{M N G A B α β γ δ : Type _} [SMul M α]  [SMul M α]  (p : Prop)  [Decidable p] (a : M)  (b₁ b₂ : α)"},
 {"type": "r • x * s • y = (r * s) • (x * y)",
  "tactic-prompt":
  "theorem {M N G A B α β γ δ : Type _} [SMul M α]  [Monoid M]  [MulAction M α]  [Mul α]  (r s : M)  (x y : α)  [IsScalarTower M α α]  [SMulCommClass M α α] : r • x * s • y = (r * s) • (x * y) := by rw [smul_mul_assoc]; sorry",
  "name": "smul_mul_smul",
  "kind": "theorem",
  "first-tactic": "rw [smul_mul_assoc]",
  "core-prompt":
  "{M N G A B α β γ δ : Type _} [SMul M α]  [Monoid M]  [MulAction M α]  [Mul α]  (r s : M)  (x y : α)  [IsScalarTower M α α]  [SMulCommClass M α α] : r • x * s • y = (r * s) • (x * y)",
  "args":
  "{M N G A B α β γ δ : Type _} [SMul M α]  [Monoid M]  [MulAction M α]  [Mul α]  (r s : M)  (x y : α)  [IsScalarTower M α α]  [SMulCommClass M α α]"},
 {"type": "r • (x - y) = r • x - r • y",
  "tactic-prompt":
  "theorem {M N G A B α β γ δ : Type _} [SMul M α]  [Monoid M]  [AddGroup A]  [DistribMulAction M A] (r : M)  (x y : A) : r • (x - y) = r • x - r • y := by rw [sub_eq_add_neg]; sorry",
  "name": "smul_sub",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{M N G A B α β γ δ : Type _} [SMul M α]  [Monoid M]  [AddGroup A]  [DistribMulAction M A] (r : M)  (x y : A) : r • (x - y) = r • x - r • y",
  "args":
  "{M N G A B α β γ δ : Type _} [SMul M α]  [Monoid M]  [AddGroup A]  [DistribMulAction M A] (r : M)  (x y : A)"},
 {"type": "c⁻¹ • c • x = x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}   [Group α]  [MulAction α β] (c : α)  (x : β) : c⁻¹ • c • x = x := by rw [smul_smul]; sorry",
  "name": "inv_smul_smul",
  "kind": "theorem",
  "first-tactic": "rw [smul_smul]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}   [Group α]  [MulAction α β] (c : α)  (x : β) : c⁻¹ • c • x = x",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}   [Group α]  [MulAction α β] (c : α)  (x : β)"},
 {"type": "c • c⁻¹ • x = x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}   [Group α]  [MulAction α β] (c : α)  (x : β) : c • c⁻¹ • x = x := by rw [smul_smul]; sorry",
  "name": "smul_inv_smul",
  "kind": "theorem",
  "first-tactic": "rw [smul_smul]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}   [Group α]  [MulAction α β] (c : α)  (x : β) : c • c⁻¹ • x = x",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}   [Group α]  [MulAction α β] (c : α)  (x : β)"},
 {"type": "(c • x)⁻¹ = c⁻¹ • x⁻¹",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}   [Group α]  [MulAction α β] [Group β]  [SMulCommClass α β β]  [IsScalarTower α β β]  (c : α)  (x : β) : (c • x)⁻¹ = c⁻¹ • x⁻¹ := by rw [inv_eq_iff_mul_eq_one]; sorry",
  "name": "smul_inv",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_iff_mul_eq_one]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}   [Group α]  [MulAction α β] [Group β]  [SMulCommClass α β β]  [IsScalarTower α β β]  (c : α)  (x : β) : (c • x)⁻¹ = c⁻¹ • x⁻¹",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}   [Group α]  [MulAction α β] [Group β]  [SMulCommClass α β β]  [IsScalarTower α β β]  (c : α)  (x : β)"},
 {"type": "(c • x) ^ p = c ^ p • x ^ p",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}   [Group α]  [MulAction α β] [Group β]  [SMulCommClass α β β]  [IsScalarTower α β β]  (c : α)  (x : β)  (p : ℤ) : (c • x) ^ p = c ^ p • x ^ p := by cases p; sorry",
  "name": "smul_zpow",
  "kind": "theorem",
  "first-tactic": "cases p",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}   [Group α]  [MulAction α β] [Group β]  [SMulCommClass α β β]  [IsScalarTower α β β]  (c : α)  (x : β)  (p : ℤ) : (c • x) ^ p = c ^ p • x ^ p",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}   [Group α]  [MulAction α β] [Group β]  [SMulCommClass α β β]  [IsScalarTower α β β]  (c : α)  (x : β)  (p : ℤ)"},
 {"type": "Commute (r • a) b ↔ Commute a b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}   [Group α]  [MulAction α β] [Mul β]  [SMulCommClass α β β]  [IsScalarTower α β β]  {a b : β}      (r : α) : Commute (r • a) b ↔ Commute a b := by rw [Commute.symm_iff]; sorry",
  "name": "Commute.smul_left_iff",
  "kind": "theorem",
  "first-tactic": "rw [Commute.symm_iff]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}   [Group α]  [MulAction α β] [Mul β]  [SMulCommClass α β β]  [IsScalarTower α β β]  {a b : β}      (r : α) : Commute (r • a) b ↔ Commute a b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}   [Group α]  [MulAction α β] [Mul β]  [SMulCommClass α β β]  [IsScalarTower α β β]  {a b : β}      (r : α)"},
 {"type": "IsUnit (r • (1 : β) - a) ↔ IsUnit (1 - r⁻¹ • a)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  [Group α]  [Monoid β] [AddGroup β]  [DistribMulAction α β]  [IsScalarTower α β β]      [SMulCommClass α β β]  (r : α)  (a : β) : IsUnit (r • (1 : β) - a) ↔ IsUnit (1 - r⁻¹ • a) := by rw [← is_unit_smul_iff r (1 - r⁻¹ • a)]; sorry",
  "name": "IsUnit.smul_sub_iff_sub_inv_smul",
  "kind": "theorem",
  "first-tactic": "rw [← is_unit_smul_iff r (1 - r⁻¹ • a)]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  [Group α]  [Monoid β] [AddGroup β]  [DistribMulAction α β]  [IsScalarTower α β β]      [SMulCommClass α β β]  (r : α)  (a : β) : IsUnit (r • (1 : β) - a) ↔ IsUnit (1 - r⁻¹ • a)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  [Group α]  [Monoid β] [AddGroup β]  [DistribMulAction α β]  [IsScalarTower α β β]      [SMulCommClass α β β]  (r : α)  (a : β)"},
 {"type": "a • ((0 : α), c) = (0, a • c)",
  "tactic-prompt":
  "theorem {M N P E α β : Type _}  [SMul M α]  [SMul M β]  [SMul N α]  [SMul N β]  (a : M)  (x : α × β) {α : Type _}  [Monoid M]  [AddMonoid α]  [DistribMulAction M α]  (a : M)  (c : β) : a • ((0 : α), c) = (0, a • c) := by rw [Prod.smul_mk]; sorry",
  "name": "smul_zero_mk",
  "kind": "theorem",
  "first-tactic": "rw [Prod.smul_mk]",
  "core-prompt":
  "{M N P E α β : Type _}  [SMul M α]  [SMul M β]  [SMul N α]  [SMul N β]  (a : M)  (x : α × β) {α : Type _}  [Monoid M]  [AddMonoid α]  [DistribMulAction M α]  (a : M)  (c : β) : a • ((0 : α), c) = (0, a • c)",
  "args":
  "{M N P E α β : Type _}  [SMul M α]  [SMul M β]  [SMul N α]  [SMul N β]  (a : M)  (x : α × β) {α : Type _}  [Monoid M]  [AddMonoid α]  [DistribMulAction M α]  (a : M)  (c : β)"},
 {"type": "a • (b, (0 : β)) = (a • b, 0)",
  "tactic-prompt":
  "theorem {M N P E α β : Type _}  [SMul M α]  [SMul M β]  [SMul N α]  [SMul N β]  (a : M)  (x : α × β) {β : Type _}  [Monoid M]  [AddMonoid β]  [DistribMulAction M β]  (a : M)  (b : α) : a • (b, (0 : β)) = (a • b, 0) := by rw [Prod.smul_mk]; sorry",
  "name": "smul_mk_zero",
  "kind": "theorem",
  "first-tactic": "rw [Prod.smul_mk]",
  "core-prompt":
  "{M N P E α β : Type _}  [SMul M α]  [SMul M β]  [SMul N α]  [SMul N β]  (a : M)  (x : α × β) {β : Type _}  [Monoid M]  [AddMonoid β]  [DistribMulAction M β]  (a : M)  (b : α) : a • (b, (0 : β)) = (a • b, 0)",
  "args":
  "{M N P E α β : Type _}  [SMul M α]  [SMul M β]  [SMul N α]  [SMul N β]  (a : M)  (x : α × β) {β : Type _}  [Monoid M]  [AddMonoid β]  [DistribMulAction M β]  (a : M)  (b : α)"},
 {"type": "(a • x).swap = a • x.swap",
  "tactic-prompt":
  "theorem {M N P α β γ : Type _}  [SMul M α]  [SMul M β]  [SMul N α]  [SMul N β]  (a : M)  (b : α)  (c : β)    (x : Sum α β) : (a • x).swap = a • x.swap := by cases x; sorry",
  "name": "smul_swap",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{M N P α β γ : Type _}  [SMul M α]  [SMul M β]  [SMul N α]  [SMul N β]  (a : M)  (b : α)  (c : β)    (x : Sum α β) : (a • x).swap = a • x.swap",
  "args":
  "{M N P α β γ : Type _}  [SMul M α]  [SMul M β]  [SMul N α]  [SMul N β]  (a : M)  (b : α)  (c : β)    (x : Sum α β)"},
 {"type": "(c • x)⁻¹ = c⁻¹ • x⁻¹",
  "tactic-prompt":
  "theorem {R R' M M' : Type _}  {α β : Type _}  [GroupWithZero α]  [GroupWithZero β]  [MulActionWithZero α β] [SMulCommClass α β β]  [IsScalarTower α β β]  (c : α)  (x : β) : (c • x)⁻¹ = c⁻¹ • x⁻¹ := by obtain rfl | hc := eq_or_ne c 0; sorry",
  "name": "smul_inv₀",
  "kind": "theorem",
  "first-tactic": "obtain rfl | hc := eq_or_ne c 0",
  "core-prompt":
  "{R R' M M' : Type _}  {α β : Type _}  [GroupWithZero α]  [GroupWithZero β]  [MulActionWithZero α β] [SMulCommClass α β β]  [IsScalarTower α β β]  (c : α)  (x : β) : (c • x)⁻¹ = c⁻¹ • x⁻¹",
  "args":
  "{R R' M M' : Type _}  {α β : Type _}  [GroupWithZero α]  [GroupWithZero β]  [MulActionWithZero α β] [SMulCommClass α β β]  [IsScalarTower α β β]  (c : α)  (x : β)"},
 {"type": "(n : R) = 0 ↔ n = 0",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R]  [CharZero R] {n : ℕ} : (n : R) = 0 ↔ n = 0 := by rw [← cast_zero]; sorry",
  "name": "cast_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [← cast_zero]",
  "core-prompt":
  "[AddMonoidWithOne R]  [CharZero R] {n : ℕ} : (n : R) = 0 ↔ n = 0",
  "args": "[AddMonoidWithOne R]  [CharZero R] {n : ℕ}"},
 {"type": "(n + 1 : R) ≠ 0",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R]  [CharZero R] (n : ℕ) : (n + 1 : R) ≠ 0 := by norm_cast; sorry",
  "name": "cast_add_one_ne_zero",
  "kind": "theorem",
  "first-tactic": "norm_cast",
  "core-prompt": "[AddMonoidWithOne R]  [CharZero R] (n : ℕ) : (n + 1 : R) ≠ 0",
  "args": "[AddMonoidWithOne R]  [CharZero R] (n : ℕ)"},
 {"type": "(n : R) = 1 ↔ n = 1",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R]  [CharZero R] {n : ℕ} : (n : R) = 1 ↔ n = 1 := by rw [← cast_one]; sorry",
  "name": "cast_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [← cast_one]",
  "core-prompt":
  "[AddMonoidWithOne R]  [CharZero R] {n : ℕ} : (n : R) = 1 ↔ n = 1",
  "args": "[AddMonoidWithOne R]  [CharZero R] {n : ℕ}"},
 {"type": "((· * a)^[n]) 1 = a ^ n",
  "tactic-prompt":
  "theorem {M : Type _}  {N : Type _}  {G : Type _}  {H : Type _} [Monoid M]  [Monoid N]  [Group G]  [Group H] [AddMonoid M]  [AddGroup G] {R : Type _}  [Ring R]  (f : R →+* R)  (n : ℕ)  (x y : R)  [Monoid G]  (a : G)  (n : ℕ) : ((· * a)^[n]) 1 = a ^ n := by simp [mul_right_iterate]; sorry",
  "name": "mul_right_iterate_apply_one",
  "kind": "theorem",
  "first-tactic": "simp [mul_right_iterate]",
  "core-prompt":
  "{M : Type _}  {N : Type _}  {G : Type _}  {H : Type _} [Monoid M]  [Monoid N]  [Group G]  [Group H] [AddMonoid M]  [AddGroup G] {R : Type _}  [Ring R]  (f : R →+* R)  (n : ℕ)  (x y : R)  [Monoid G]  (a : G)  (n : ℕ) : ((· * a)^[n]) 1 = a ^ n",
  "args":
  "{M : Type _}  {N : Type _}  {G : Type _}  {H : Type _} [Monoid M]  [Monoid N]  [Group G]  [Group H] [AddMonoid M]  [AddGroup G] {R : Type _}  [Ring R]  (f : R →+* R)  (n : ℕ)  (x y : R)  [Monoid G]  (a : G)  (n : ℕ)"},
 {"type": "α →ₙ+* α",
  "tactic-prompt":
  "def {F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (α : Type _)  [NonUnitalNonAssocSemiring α] : α →ₙ+* α := by refine' { toFun := id.. }; sorry",
  "name": "id",
  "kind": "def",
  "first-tactic": "refine' { toFun := id.. }",
  "core-prompt":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (α : Type _)  [NonUnitalNonAssocSemiring α] : α →ₙ+* α",
  "args":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (α : Type _)  [NonUnitalNonAssocSemiring α]"},
 {"type": "g.comp (0 : α →ₙ+* β) = 0",
  "tactic-prompt":
  "theorem {F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β) (g : β →ₙ+* γ) : g.comp (0 : α →ₙ+* β) = 0 := by ext; sorry",
  "name": "comp_zero",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β) (g : β →ₙ+* γ) : g.comp (0 : α →ₙ+* β) = 0",
  "args":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β) (g : β →ₙ+* γ)"},
 {"type": "(0 : β →ₙ+* γ).comp f = 0",
  "tactic-prompt":
  "theorem {F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β) (f : α →ₙ+* β) : (0 : β →ₙ+* γ).comp f = 0 := by ext; sorry",
  "name": "zero_comp",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β) (f : α →ₙ+* β) : (0 : β →ₙ+* γ).comp f = 0",
  "args":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β) (f : α →ₙ+* β)"},
 {"type": "(f.toMonoidWithZeroHom : α → β) = f",
  "tactic-prompt":
  "theorem {F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β)  (f : α →+* β) : (f.toMonoidWithZeroHom : α → β) = f := by rfl; sorry",
  "name": "toMonoidWithZeroHom_eq_coe",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β)  (f : α →+* β) : (f.toMonoidWithZeroHom : α → β) = f",
  "args":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β)  (f : α →+* β)"},
 {"type": "f (ite p 0 1) = ite p 0 1",
  "tactic-prompt":
  "theorem {F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β)  {F : Type _}  [RingHomClass F α β]  (f : F)  (p : Prop)  [Decidable p] : f (ite p 0 1) = ite p 0 1 := by split_ifs with h; sorry",
  "name": "map_ite_zero_one",
  "kind": "theorem",
  "first-tactic": "split_ifs with h",
  "core-prompt":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β)  {F : Type _}  [RingHomClass F α β]  (f : F)  (p : Prop)  [Decidable p] : f (ite p 0 1) = ite p 0 1",
  "args":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β)  {F : Type _}  [RingHomClass F α β]  (f : F)  (p : Prop)  [Decidable p]"},
 {"type": "f (ite p 1 0) = ite p 1 0",
  "tactic-prompt":
  "theorem {F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β)  {F : Type _}  [RingHomClass F α β]  (f : F)  (p : Prop)  [Decidable p] : f (ite p 1 0) = ite p 1 0 := by split_ifs with h; sorry",
  "name": "map_ite_one_zero",
  "kind": "theorem",
  "first-tactic": "split_ifs with h",
  "core-prompt":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β)  {F : Type _}  [RingHomClass F α β]  (f : F)  (p : Prop)  [Decidable p] : f (ite p 1 0) = ite p 1 0",
  "args":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β)  {F : Type _}  [RingHomClass F α β]  (f : F)  (p : Prop)  [Decidable p]"},
 {"type": "(0 : β) = 1 ↔ f 1 = 0",
  "tactic-prompt":
  "theorem {F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β) : (0 : β) = 1 ↔ f 1 = 0 := by rw [map_one]; sorry",
  "name": "codomain_trivial_iff_map_one_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [map_one]",
  "core-prompt":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β) : (0 : β) = 1 ↔ f 1 = 0",
  "args":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β)"},
 {"type": "α →+* α",
  "tactic-prompt":
  "def {F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β) (α : Type _)  [NonAssocSemiring α] : α →+* α := by refine' { toFun := _root_.id.. }; sorry",
  "name": "id",
  "kind": "def",
  "first-tactic": "refine' { toFun := _root_.id.. }",
  "core-prompt":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β) (α : Type _)  [NonAssocSemiring α] : α →+* α",
  "args":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β) (α : Type _)  [NonAssocSemiring α]"},
 {"type": "IsDomain β",
  "tactic-prompt":
  "theorem {F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β) [Ring α]  [IsDomain α]  [Ring β]  (f : β →+* α)      (hf : Injective f) : IsDomain β := by haveI := pullback_nonzero f f.map_zero f.map_one; sorry",
  "name": "Function.Injective.isDomain",
  "kind": "theorem",
  "first-tactic": "haveI := pullback_nonzero f f.map_zero f.map_one",
  "core-prompt":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β) [Ring α]  [IsDomain α]  [Ring β]  (f : β →+* α)      (hf : Injective f) : IsDomain β",
  "args":
  "{F α β γ : Type _} [NonUnitalNonAssocSemiring α]  [NonUnitalNonAssocSemiring β] (g : β →ₙ+* γ)  (f : α →ₙ+* β) [Ring α]  [IsDomain α]  [Ring β]  (f : β →+* α)      (hf : Injective f)"},
 {"type": "Group (MulAut M)",
  "tactic-prompt":
  "instance {A : Type _}  {M : Type _}  {G : Type _} : Group (MulAut M) := by refine'\n            { mul := fun g h => MulEquiv.trans h g\n              one := MulEquiv.refl M\n              inv := MulEquiv.symm\n              div := fun g h => MulEquiv.trans h.symm g\n              npow := @npowRec _ ⟨MulEquiv.refl M⟩ ⟨fun g h => MulEquiv.trans h g⟩\n              zpow := @zpowRec _ ⟨MulEquiv.refl M⟩ ⟨fun g h => MulEquiv.trans h g⟩ ⟨MulEquiv.symm⟩\n              .. }; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic":
  "refine'\n            { mul := fun g h => MulEquiv.trans h g\n              one := MulEquiv.refl M\n              inv := MulEquiv.symm\n              div := fun g h => MulEquiv.trans h.symm g\n              npow := @npowRec _ ⟨MulEquiv.refl M⟩ ⟨fun g h => MulEquiv.trans h g⟩\n              zpow := @zpowRec _ ⟨MulEquiv.refl M⟩ ⟨fun g h => MulEquiv.trans h g⟩ ⟨MulEquiv.symm⟩\n              .. }",
  "core-prompt": "{A : Type _}  {M : Type _}  {G : Type _} : Group (MulAut M)",
  "args": "{A : Type _}  {M : Type _}  {G : Type _}"},
 {"type": "MulAut M →* Equiv.Perm M",
  "tactic-prompt":
  "def {A : Type _}  {M : Type _}  {G : Type _} : MulAut M →* Equiv.Perm M := by refine' { toFun := MulEquiv.toEquiv, ..}; sorry",
  "name": "toPerm",
  "kind": "def",
  "first-tactic": "refine' { toFun := MulEquiv.toEquiv, ..}",
  "core-prompt":
  "{A : Type _}  {M : Type _}  {G : Type _} : MulAut M →* Equiv.Perm M",
  "args": "{A : Type _}  {M : Type _}  {G : Type _}"},
 {"type": "Group (AddAut A)",
  "tactic-prompt":
  "instance {A : Type _}  {M : Type _}  {G : Type _} : Group (AddAut A) := by refine'\n            { mul := fun g h => AddEquiv.trans h g\n              one := AddEquiv.refl A\n              inv := AddEquiv.symm\n              div := fun g h => AddEquiv.trans h.symm g\n              npow := @npowRec _ ⟨AddEquiv.refl A⟩ ⟨fun g h => AddEquiv.trans h g⟩\n              zpow := @zpowRec _ ⟨AddEquiv.refl A⟩ ⟨fun g h => AddEquiv.trans h g⟩ ⟨AddEquiv.symm⟩\n              .. }; sorry",
  "name": "group",
  "kind": "instance",
  "first-tactic":
  "refine'\n            { mul := fun g h => AddEquiv.trans h g\n              one := AddEquiv.refl A\n              inv := AddEquiv.symm\n              div := fun g h => AddEquiv.trans h.symm g\n              npow := @npowRec _ ⟨AddEquiv.refl A⟩ ⟨fun g h => AddEquiv.trans h g⟩\n              zpow := @zpowRec _ ⟨AddEquiv.refl A⟩ ⟨fun g h => AddEquiv.trans h g⟩ ⟨AddEquiv.symm⟩\n              .. }",
  "core-prompt": "{A : Type _}  {M : Type _}  {G : Type _} : Group (AddAut A)",
  "args": "{A : Type _}  {M : Type _}  {G : Type _}"},
 {"type": "AddAut A →* Equiv.Perm A",
  "tactic-prompt":
  "def {A : Type _}  {M : Type _}  {G : Type _} : AddAut A →* Equiv.Perm A := by refine' { toFun := AddEquiv.toEquiv, .. }; sorry",
  "name": "toPerm",
  "kind": "def",
  "first-tactic": "refine' { toFun := AddEquiv.toEquiv, .. }",
  "core-prompt":
  "{A : Type _}  {M : Type _}  {G : Type _} : AddAut A →* Equiv.Perm A",
  "args": "{A : Type _}  {M : Type _}  {G : Type _}"},
 {"type": "SemiconjBy (f a) (f x) (f y)",
  "tactic-prompt":
  "theorem {F M N : Type _}  [Mul M]  [Mul N]  {a x y : M} [MulHomClass F M N]  (h : SemiconjBy a x y)  (f : F) : SemiconjBy (f a) (f x) (f y) := by simpa only [SemiconjBy]; sorry",
  "name": "SemiconjBy.map",
  "kind": "theorem",
  "first-tactic": "simpa only [SemiconjBy]",
  "core-prompt":
  "{F M N : Type _}  [Mul M]  [Mul N]  {a x y : M} [MulHomClass F M N]  (h : SemiconjBy a x y)  (f : F) : SemiconjBy (f a) (f x) (f y)",
  "args":
  "{F M N : Type _}  [Mul M]  [Mul N]  {a x y : M} [MulHomClass F M N]  (h : SemiconjBy a x y)  (f : F)"},
 {"type": "map (MonoidHom.id M) = MonoidHom.id Mˣ",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] : map (MonoidHom.id M) = MonoidHom.id Mˣ := by ext; sorry",
  "name": "map_id",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] : map (MonoidHom.id M) = MonoidHom.id Mˣ",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P]"},
 {"type": "a /ₚ u = a / u",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P]  [DivisionMonoid α] (a : α)  (u : αˣ) : a /ₚ u = a / u := by rw [div_eq_mul_inv]; sorry",
  "name": "_root_.divp_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P]  [DivisionMonoid α] (a : α)  (u : αˣ) : a /ₚ u = a / u",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P]  [DivisionMonoid α] (a : α)  (u : αˣ)"},
 {"type": "IsUnit (f x)",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [Monoid M]  [Monoid N] [MonoidHomClass F M N]  (f : F)  {x : M}  (h : IsUnit x) : IsUnit (f x) := by rcases h with ⟨y, rfl⟩; sorry",
  "name": "map",
  "kind": "theorem",
  "first-tactic": "rcases h with ⟨y, rfl⟩",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [Monoid M]  [Monoid N] [MonoidHomClass F M N]  (f : F)  {x : M}  (h : IsUnit x) : IsUnit (f x)",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [Monoid M]  [Monoid N] [MonoidHomClass F M N]  (f : F)  {x : M}  (h : IsUnit x)"},
 {"type": "IsUnit x",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [Monoid M]  [Monoid N] [MonoidHomClass F M N]  [MonoidHomClass G N M]  {f : F}  {x : M}  (g : G)    (hfg : Function.LeftInverse g f)  (h : IsUnit (f x)) : IsUnit x := by simpa only [hfg x] using h.map g; sorry",
  "name": "of_leftInverse",
  "kind": "theorem",
  "first-tactic": "simpa only [hfg x] using h.map g",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [Monoid M]  [Monoid N] [MonoidHomClass F M N]  [MonoidHomClass G N M]  {f : F}  {x : M}  (g : G)    (hfg : Function.LeftInverse g f)  (h : IsUnit (f x)) : IsUnit x",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [Monoid M]  [Monoid N] [MonoidHomClass F M N]  [MonoidHomClass G N M]  {f : F}  {x : M}  (g : G)    (hfg : Function.LeftInverse g f)  (h : IsUnit (f x))"},
 {"type": "a / a = 1",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit a) : a / a = 1 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_self",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit a) : a / a = 1",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit a)"},
 {"type": "a / b * b = a",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit b)  (a : α) : a / b * b = a := by rw [div_eq_mul_inv]; sorry",
  "name": "div_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit b)  (a : α) : a / b * b = a",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit b)  (a : α)"},
 {"type": "a * b / b = a",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit b)  (a : α) : a * b / b = a := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_div_cancel",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit b)  (a : α) : a * b / b = a",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit b)  (a : α)"},
 {"type": "a * (1 / a) = 1",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit a) : a * (1 / a) = 1 := by simp [h]; sorry",
  "name": "mul_one_div_cancel",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit a) : a * (1 / a) = 1",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit a)"},
 {"type": "1 / a * a = 1",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit a) : 1 / a * a = 1 := by simp [h]; sorry",
  "name": "one_div_mul_cancel",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit a) : 1 / a * a = 1",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit a)"},
 {"type": "IsUnit a⁻¹",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit a) : IsUnit a⁻¹ := by rcases h with ⟨u, hu⟩; sorry",
  "name": "inv",
  "kind": "theorem",
  "first-tactic": "rcases h with ⟨u, hu⟩",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit a) : IsUnit a⁻¹",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit a)"},
 {"type": "IsUnit (a / b)",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (ha : IsUnit a)  (hb : IsUnit b) : IsUnit (a / b) := by rw [div_eq_mul_inv]; sorry",
  "name": "div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (ha : IsUnit a)  (hb : IsUnit b) : IsUnit (a / b)",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (ha : IsUnit a)  (hb : IsUnit b)"},
 {"type": "a / c = b / c ↔ a = b",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit c) : a / c = b / c ↔ a = b := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_left_inj",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit c) : a / c = b / c ↔ a = b",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit c)"},
 {"type": "a / b = c ↔ a = c * b",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit b) : a / b = c ↔ a = c * b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_iff",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit b) : a / b = c ↔ a = c * b",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit b)"},
 {"type": "a = b / c ↔ a * c = b",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit c) : a = b / c ↔ a * c = b := by rw [div_eq_mul_inv]; sorry",
  "name": "eq_div_iff",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit c) : a = b / c ↔ a * c = b",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit c)"},
 {"type": "b / (a * b) = 1 / a",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit b) : b / (a * b) = 1 / a := by rw [div_eq_mul_inv]; sorry",
  "name": "div_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit b) : b / (a * b) = 1 / a",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit b)"},
 {"type": "a * c / (b * c) = a / b",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit c)  (a b : α) : a * c / (b * c) = a / b := by simp only [div_eq_mul_inv]; sorry",
  "name": "mul_div_mul_right",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit c)  (a b : α) : a * c / (b * c) = a / b",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (h : IsUnit c)  (a b : α)"},
 {"type": "a * b * (1 / b) = a",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (a : α)  (h : IsUnit b) : a * b * (1 / b) = a := by simp [h]; sorry",
  "name": "mul_mul_div",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (a : α)  (h : IsUnit b) : a * b * (1 / b) = a",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionMonoid α]  {a b c : α} (a : α)  (h : IsUnit b)"},
 {"type": "a / (a * b) = 1 / b",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (h : IsUnit a)  (b : α) : a / (a * b) = 1 / b := by rw [mul_comm]; sorry",
  "name": "div_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (h : IsUnit a)  (b : α) : a / (a * b) = 1 / b",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (h : IsUnit a)  (b : α)"},
 {"type": "a * b / a = b",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (h : IsUnit a)  (b : α) : a * b / a = b := by rw [mul_comm]; sorry",
  "name": "mul_div_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (h : IsUnit a)  (b : α) : a * b / a = b",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (h : IsUnit a)  (b : α)"},
 {"type": "a * (b / a) = b",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (h : IsUnit a)  (b : α) : a * (b / a) = b := by rw [mul_comm]; sorry",
  "name": "mul_div_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (h : IsUnit a)  (b : α) : a * (b / a) = b",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (h : IsUnit a)  (b : α)"},
 {"type": "c * a / (c * b) = a / b",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (h : IsUnit c)  (a b : α) : c * a / (c * b) = a / b := by rw [mul_comm c]; sorry",
  "name": "mul_div_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm c]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (h : IsUnit c)  (a b : α) : c * a / (c * b) = a / b",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (h : IsUnit c)  (a b : α)"},
 {"type": "a * d = c * b",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (hb : IsUnit b)  (hd : IsUnit d)    (a c : α)  (h : a / b = c / d) : a * d = c * b := by rw [← mul_one a]; sorry",
  "name": "mul_eq_mul_of_div_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [← mul_one a]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (hb : IsUnit b)  (hd : IsUnit d)    (a c : α)  (h : a / b = c / d) : a * d = c * b",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (hb : IsUnit b)  (hd : IsUnit d)    (a c : α)  (h : a / b = c / d)"},
 {"type": "a / b = c / d ↔ a * d = c * b",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (hb : IsUnit b)  (hd : IsUnit d) : a / b = c / d ↔ a * d = c * b := by rw [← (hb.mul hd).mul_left_inj]; sorry",
  "name": "div_eq_div_iff",
  "kind": "theorem",
  "first-tactic": "rw [← (hb.mul hd).mul_left_inj]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (hb : IsUnit b)  (hd : IsUnit d) : a / b = c / d ↔ a * d = c * b",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (hb : IsUnit b)  (hd : IsUnit d)"},
 {"type": "a / (a / b) = b",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (h : IsUnit a) : a / (a / b) = b := by rw [div_div_eq_mul_div]; sorry",
  "name": "div_div_cancel",
  "kind": "theorem",
  "first-tactic": "rw [div_div_eq_mul_div]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (h : IsUnit a) : a / (a / b) = b",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G α M N : Type _}  [DivisionCommMonoid α]  {a b c d : α} (h : IsUnit a)"},
 {"type": "f a * f b = 1",
  "tactic-prompt":
  "theorem {α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [MonoidHomClass F M N]  (f : F)  {a b : M}  (h : a * b = 1) : f a * f b = 1 := by rw [← map_mul]; sorry",
  "name": "map_mul_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [← map_mul]",
  "core-prompt":
  "{α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [MonoidHomClass F M N]  (f : F)  {a b : M}  (h : a * b = 1) : f a * f b = 1",
  "args":
  "{α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [MonoidHomClass F M N]  (f : F)  {a b : M}  (h : a * b = 1)"},
 {"type": "f (a / b) = f a / f b",
  "tactic-prompt":
  "theorem {α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [DivInvMonoid G]  [DivInvMonoid H]  [MonoidHomClass F G H]    (f : F)  (hf : ∀ a, f a⁻¹ = (f a)⁻¹)  (a b : G) : f (a / b) = f a / f b := by rw [div_eq_mul_inv]; sorry",
  "name": "map_div'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [DivInvMonoid G]  [DivInvMonoid H]  [MonoidHomClass F G H]    (f : F)  (hf : ∀ a, f a⁻¹ = (f a)⁻¹)  (a b : G) : f (a / b) = f a / f b",
  "args":
  "{α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [DivInvMonoid G]  [DivInvMonoid H]  [MonoidHomClass F G H]    (f : F)  (hf : ∀ a, f a⁻¹ = (f a)⁻¹)  (a b : G)"},
 {"type": "f (a * b⁻¹) = f a * (f b)⁻¹",
  "tactic-prompt":
  "theorem {α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [Group G]  [DivisionMonoid H]  [MonoidHomClass F G H]  (f : F)  (a b : G) : f (a * b⁻¹) = f a * (f b)⁻¹ := by rw [map_mul]; sorry",
  "name": "map_mul_inv",
  "kind": "theorem",
  "first-tactic": "rw [map_mul]",
  "core-prompt":
  "{α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [Group G]  [DivisionMonoid H]  [MonoidHomClass F G H]  (f : F)  (a b : G) : f (a * b⁻¹) = f a * (f b)⁻¹",
  "args":
  "{α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [Group G]  [DivisionMonoid H]  [MonoidHomClass F G H]  (f : F)  (a b : G)"},
 {"type": "f.comp (1 : OneHom M N) = 1",
  "tactic-prompt":
  "theorem {α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [One M]  [One N]  [One P]  (f : OneHom N P) : f.comp (1 : OneHom M N) = 1 := by ext; sorry",
  "name": "OneHom.comp_one",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [One M]  [One N]  [One P]  (f : OneHom N P) : f.comp (1 : OneHom M N) = 1",
  "args":
  "{α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [One M]  [One N]  [One P]  (f : OneHom N P)"},
 {"type": "g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂",
  "tactic-prompt":
  "theorem {α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Mul M]  [CommSemigroup N]  [CommSemigroup P]  (g : N →ₙ* P)  (f₁ f₂ : M →ₙ* N) : g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂ := by ext; sorry",
  "name": "comp_mul",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Mul M]  [CommSemigroup N]  [CommSemigroup P]  (g : N →ₙ* P)  (f₁ f₂ : M →ₙ* N) : g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂",
  "args":
  "{α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Mul M]  [CommSemigroup N]  [CommSemigroup P]  (g : N →ₙ* P)  (f₁ f₂ : M →ₙ* N)"},
 {"type": "f.comp (1 : M →* N) = 1",
  "tactic-prompt":
  "theorem {α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [MulOneClass M]  [MulOneClass N]  [MulOneClass P]  (f : N →* P) : f.comp (1 : M →* N) = 1 := by ext; sorry",
  "name": "comp_one",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [MulOneClass M]  [MulOneClass N]  [MulOneClass P]  (f : N →* P) : f.comp (1 : M →* N) = 1",
  "args":
  "{α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [MulOneClass M]  [MulOneClass N]  [MulOneClass P]  (f : N →* P)"},
 {"type": "g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂",
  "tactic-prompt":
  "theorem {α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [MulOneClass M]  [CommMonoid N]  [CommMonoid P]  (g : N →* P)  (f₁ f₂ : M →* N) : g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂ := by ext; sorry",
  "name": "comp_mul",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [MulOneClass M]  [CommMonoid N]  [CommMonoid P]  (g : N →* P)  (f₁ f₂ : M →* N) : g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂",
  "args":
  "{α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [MulOneClass M]  [CommMonoid N]  [CommMonoid P]  (g : N →* P)  (f₁ f₂ : M →* N)"},
 {"type": "f (g * h⁻¹) = f g * (f h)⁻¹",
  "tactic-prompt":
  "theorem {α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [Group α]  [DivisionMonoid β]  (f : α →* β)  (g h : α) : f (g * h⁻¹) = f g * (f h)⁻¹ := by simp; sorry",
  "name": "map_mul_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [Group α]  [DivisionMonoid β]  (f : α →* β)  (g h : α) : f (g * h⁻¹) = f g * (f h)⁻¹",
  "args":
  "{α β M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [Group α]  [DivisionMonoid β]  (f : α →* β)  (g h : α)"},
 {"type": "mulLeftEmbedding g = mulRightEmbedding g",
  "tactic-prompt":
  "theorem {R : Type _}  {G : Type _}  [CancelCommMonoid G]  (g : G) : mulLeftEmbedding g = mulRightEmbedding g := by ext; sorry",
  "name": "mul_left_embedding_eq_mul_right_embedding",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{R : Type _}  {G : Type _}  [CancelCommMonoid G]  (g : G) : mulLeftEmbedding g = mulRightEmbedding g",
  "args": "{R : Type _}  {G : Type _}  [CancelCommMonoid G]  (g : G)"},
 {"type": "IsRightRegular b",
  "tactic-prompt":
  "theorem {R : Type _}  [Semigroup R]  {a b : R} (ab : IsRightRegular (b * a)) : IsRightRegular b := by refine' fun x y xy => ab (_ : x * (b * a) = y * (b * a)); sorry",
  "name": "IsRightRegular.of_mul",
  "kind": "theorem",
  "first-tactic": "refine' fun x y xy => ab (_ : x * (b * a) = y * (b * a))",
  "core-prompt":
  "{R : Type _}  [Semigroup R]  {a b : R} (ab : IsRightRegular (b * a)) : IsRightRegular b",
  "args":
  "{R : Type _}  [Semigroup R]  {a b : R} (ab : IsRightRegular (b * a))"},
 {"type": "IsRegular (a * b) ∧ IsRegular (b * a) ↔ IsRegular a ∧ IsRegular b",
  "tactic-prompt":
  "theorem {R : Type _}  [Semigroup R]  {a b : R} : IsRegular (a * b) ∧ IsRegular (b * a) ↔ IsRegular a ∧ IsRegular b := by refine' ⟨_, _⟩; sorry",
  "name": "isRegular_mul_and_mul_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨_, _⟩",
  "core-prompt":
  "{R : Type _}  [Semigroup R]  {a b : R} : IsRegular (a * b) ∧ IsRegular (b * a) ↔ IsRegular a ∧ IsRegular b",
  "args": "{R : Type _}  [Semigroup R]  {a b : R}"},
 {"type": "¬IsLeftRegular (0 : R) ↔ Nontrivial R",
  "tactic-prompt":
  "theorem {R : Type _}  [MulZeroClass R]  {a b : R} : ¬IsLeftRegular (0 : R) ↔ Nontrivial R := by rw [nontrivial_iff]; sorry",
  "name": "not_isLeftRegular_zero_iff",
  "kind": "theorem",
  "first-tactic": "rw [nontrivial_iff]",
  "core-prompt":
  "{R : Type _}  [MulZeroClass R]  {a b : R} : ¬IsLeftRegular (0 : R) ↔ Nontrivial R",
  "args": "{R : Type _}  [MulZeroClass R]  {a b : R}"},
 {"type": "¬IsRightRegular (0 : R) ↔ Nontrivial R",
  "tactic-prompt":
  "theorem {R : Type _}  [MulZeroClass R]  {a b : R} : ¬IsRightRegular (0 : R) ↔ Nontrivial R := by rw [nontrivial_iff]; sorry",
  "name": "not_isRightRegular_zero_iff",
  "kind": "theorem",
  "first-tactic": "rw [nontrivial_iff]",
  "core-prompt":
  "{R : Type _}  [MulZeroClass R]  {a b : R} : ¬IsRightRegular (0 : R) ↔ Nontrivial R",
  "args": "{R : Type _}  [MulZeroClass R]  {a b : R}"},
 {"type": "a ≠ 0",
  "tactic-prompt":
  "theorem {R : Type _}  [MulZeroClass R]  {a b : R} [Nontrivial R]  (la : IsLeftRegular a) : a ≠ 0 := by rintro rfl; sorry",
  "name": "IsLeftRegular.ne_zero",
  "kind": "theorem",
  "first-tactic": "rintro rfl",
  "core-prompt":
  "{R : Type _}  [MulZeroClass R]  {a b : R} [Nontrivial R]  (la : IsLeftRegular a) : a ≠ 0",
  "args":
  "{R : Type _}  [MulZeroClass R]  {a b : R} [Nontrivial R]  (la : IsLeftRegular a)"},
 {"type": "a ≠ 0",
  "tactic-prompt":
  "theorem {R : Type _}  [MulZeroClass R]  {a b : R} [Nontrivial R]  (ra : IsRightRegular a) : a ≠ 0 := by rintro rfl; sorry",
  "name": "IsRightRegular.ne_zero",
  "kind": "theorem",
  "first-tactic": "rintro rfl",
  "core-prompt":
  "{R : Type _}  [MulZeroClass R]  {a b : R} [Nontrivial R]  (ra : IsRightRegular a) : a ≠ 0",
  "args":
  "{R : Type _}  [MulZeroClass R]  {a b : R} [Nontrivial R]  (ra : IsRightRegular a)"},
 {"type": "IsRegular (a * b) ↔ IsRegular a ∧ IsRegular b",
  "tactic-prompt":
  "theorem {R : Type _}  [CommSemigroup R]  {a b : R} : IsRegular (a * b) ↔ IsRegular a ∧ IsRegular b := by refine' Iff.trans _ isRegular_mul_and_mul_iff; sorry",
  "name": "isRegular_mul_iff",
  "kind": "theorem",
  "first-tactic": "refine' Iff.trans _ isRegular_mul_and_mul_iff",
  "core-prompt":
  "{R : Type _}  [CommSemigroup R]  {a b : R} : IsRegular (a * b) ↔ IsRegular a ∧ IsRegular b",
  "args": "{R : Type _}  [CommSemigroup R]  {a b : R}"},
 {"type": "IsRegular a",
  "tactic-prompt":
  "theorem {R : Type _}  [Monoid R]  {a b : R} (ua : IsUnit a) : IsRegular a := by rcases ua with ⟨a, rfl⟩; sorry",
  "name": "IsUnit.isRegular",
  "kind": "theorem",
  "first-tactic": "rcases ua with ⟨a, rfl⟩",
  "core-prompt":
  "{R : Type _}  [Monoid R]  {a b : R} (ua : IsUnit a) : IsRegular a",
  "args": "{R : Type _}  [Monoid R]  {a b : R} (ua : IsUnit a)"},
 {"type": "IsSMulRegular M b",
  "tactic-prompt":
  "theorem {R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [SMul R M]  [SMul R S]  [SMul S M]  [IsScalarTower R S M] [Mul R]  [IsScalarTower R R M]  (ab : IsSMulRegular M (a * b)) : IsSMulRegular M b := by rw [← smul_eq_mul] at ab; sorry",
  "name": "of_mul",
  "kind": "theorem",
  "first-tactic": "rw [← smul_eq_mul] at ab",
  "core-prompt":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [SMul R M]  [SMul R S]  [SMul S M]  [IsScalarTower R S M] [Mul R]  [IsScalarTower R R M]  (ab : IsSMulRegular M (a * b)) : IsSMulRegular M b",
  "args":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [SMul R M]  [SMul R S]  [SMul S M]  [IsScalarTower R S M] [Mul R]  [IsScalarTower R R M]  (ab : IsSMulRegular M (a * b))"},
 {"type":
  "IsSMulRegular M (a * b) ∧ IsSMulRegular M (b * a) ↔ IsSMulRegular M a ∧ IsSMulRegular M b",
  "tactic-prompt":
  "theorem {R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [SMul R M]  [SMul R S]  [SMul S M]  [IsScalarTower R S M] [Mul R]  [IsScalarTower R R M] : IsSMulRegular M (a * b) ∧ IsSMulRegular M (b * a) ↔ IsSMulRegular M a ∧ IsSMulRegular M b := by refine' ⟨_, _⟩; sorry",
  "name": "mul_and_mul_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨_, _⟩",
  "core-prompt":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [SMul R M]  [SMul R S]  [SMul S M]  [IsScalarTower R S M] [Mul R]  [IsScalarTower R R M] : IsSMulRegular M (a * b) ∧ IsSMulRegular M (b * a) ↔ IsSMulRegular M a ∧ IsSMulRegular M b",
  "args":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [SMul R M]  [SMul R S]  [SMul S M]  [IsScalarTower R S M] [Mul R]  [IsScalarTower R R M]"},
 {"type": "IsSMulRegular M (a ^ n)",
  "tactic-prompt":
  "theorem {R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] (n : ℕ)  (ra : IsSMulRegular M a) : IsSMulRegular M (a ^ n) := by induction' n with n hn; sorry",
  "name": "pow",
  "kind": "theorem",
  "first-tactic": "induction' n with n hn",
  "core-prompt":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] (n : ℕ)  (ra : IsSMulRegular M a) : IsSMulRegular M (a ^ n)",
  "args":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] (n : ℕ)  (ra : IsSMulRegular M a)"},
 {"type": "IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a",
  "tactic-prompt":
  "theorem {R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] {n : ℕ}  (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by refine' ⟨_, pow n⟩; sorry",
  "name": "pow_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨_, pow n⟩",
  "core-prompt":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] {n : ℕ}  (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a",
  "args":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] {n : ℕ}  (n0 : 0 < n)"},
 {"type": "¬IsSMulRegular M (0 : R) ↔ Nontrivial M",
  "tactic-prompt":
  "theorem {R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [MonoidWithZero R]  [MonoidWithZero S]  [Zero M]  [MulActionWithZero R M]    [MulActionWithZero R S]  [MulActionWithZero S M]  [IsScalarTower R S M] : ¬IsSMulRegular M (0 : R) ↔ Nontrivial M := by rw [nontrivial_iff]; sorry",
  "name": "not_zero_iff",
  "kind": "theorem",
  "first-tactic": "rw [nontrivial_iff]",
  "core-prompt":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [MonoidWithZero R]  [MonoidWithZero S]  [Zero M]  [MulActionWithZero R M]    [MulActionWithZero R S]  [MulActionWithZero S M]  [IsScalarTower R S M] : ¬IsSMulRegular M (0 : R) ↔ Nontrivial M",
  "args":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [MonoidWithZero R]  [MonoidWithZero S]  [Zero M]  [MulActionWithZero R M]    [MulActionWithZero R S]  [MulActionWithZero S M]  [IsScalarTower R S M]"},
 {"type": "IsSMulRegular M (a * b) ↔ IsSMulRegular M a ∧ IsSMulRegular M b",
  "tactic-prompt":
  "theorem {R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [CommSemigroup R]  [SMul R M]  [IsScalarTower R R M] : IsSMulRegular M (a * b) ↔ IsSMulRegular M a ∧ IsSMulRegular M b := by rw [← mul_and_mul_iff]; sorry",
  "name": "mul_iff",
  "kind": "theorem",
  "first-tactic": "rw [← mul_and_mul_iff]",
  "core-prompt":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [CommSemigroup R]  [SMul R M]  [IsScalarTower R R M] : IsSMulRegular M (a * b) ↔ IsSMulRegular M a ∧ IsSMulRegular M b",
  "args":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [CommSemigroup R]  [SMul R M]  [IsScalarTower R R M]"},
 {"type": "IsSMulRegular R g",
  "tactic-prompt":
  "theorem {R S : Type _}  (M : Type _)  {a b : R}  {s : S}  {G : Type _}  [Group G] [MulAction G R]  (g : G) : IsSMulRegular R g := by intro x y h; sorry",
  "name": "isSMulRegular_of_group",
  "kind": "theorem",
  "first-tactic": "intro x y h",
  "core-prompt":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  {G : Type _}  [Group G] [MulAction G R]  (g : G) : IsSMulRegular R g",
  "args":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  {G : Type _}  [Group G] [MulAction G R]  (g : G)"},
 {"type": "IsSMulRegular M a",
  "tactic-prompt":
  "theorem {R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] (ua : IsUnit a) : IsSMulRegular M a := by rcases ua with ⟨a, rfl⟩; sorry",
  "name": "IsUnit.isSMulRegular",
  "kind": "theorem",
  "first-tactic": "rcases ua with ⟨a, rfl⟩",
  "core-prompt":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] (ua : IsUnit a) : IsSMulRegular M a",
  "args":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] (ua : IsUnit a)"},
 {"type": "(a + b + c) * d = a * d + b * d + c * d",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [Mul R]  [Add R]  [RightDistribClass R]  (a b c d : R) : (a + b + c) * d = a * d + b * d + c * d := by simp [right_distrib]; sorry",
  "name": "distrib_three_right",
  "kind": "theorem",
  "first-tactic": "simp [right_distrib]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [Mul R]  [Add R]  [RightDistribClass R]  (a b c d : R) : (a + b + c) * d = a * d + b * d + c * d",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [Mul R]  [Add R]  [RightDistribClass R]  (a b c d : R)"},
 {"type": "(a + 1) * b = a * b + b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Add α]  [MulOneClass α] [RightDistribClass α]  (a b : α) : (a + 1) * b = a * b + b := by rw [add_mul]; sorry",
  "name": "add_one_mul",
  "kind": "theorem",
  "first-tactic": "rw [add_mul]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Add α]  [MulOneClass α] [RightDistribClass α]  (a b : α) : (a + 1) * b = a * b + b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Add α]  [MulOneClass α] [RightDistribClass α]  (a b : α)"},
 {"type": "a * (b + 1) = a * b + a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Add α]  [MulOneClass α] [LeftDistribClass α]  (a b : α) : a * (b + 1) = a * b + a := by rw [mul_add]; sorry",
  "name": "mul_add_one",
  "kind": "theorem",
  "first-tactic": "rw [mul_add]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Add α]  [MulOneClass α] [LeftDistribClass α]  (a b : α) : a * (b + 1) = a * b + a",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Add α]  [MulOneClass α] [LeftDistribClass α]  (a b : α)"},
 {"type": "(1 + a) * b = b + a * b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Add α]  [MulOneClass α] [RightDistribClass α]  (a b : α) : (1 + a) * b = b + a * b := by rw [add_mul]; sorry",
  "name": "one_add_mul",
  "kind": "theorem",
  "first-tactic": "rw [add_mul]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Add α]  [MulOneClass α] [RightDistribClass α]  (a b : α) : (1 + a) * b = b + a * b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Add α]  [MulOneClass α] [RightDistribClass α]  (a b : α)"},
 {"type": "a * (1 + b) = a + a * b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Add α]  [MulOneClass α] [LeftDistribClass α]  (a b : α) : a * (1 + b) = a + a * b := by rw [mul_add]; sorry",
  "name": "mul_one_add",
  "kind": "theorem",
  "first-tactic": "rw [mul_add]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Add α]  [MulOneClass α] [LeftDistribClass α]  (a b : α) : a * (1 + b) = a + a * b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Add α]  [MulOneClass α] [LeftDistribClass α]  (a b : α)"},
 {"type": "ite P (a * b) 0 = ite P a 0 * b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} {α : Type _}  [MulZeroClass α]  (P : Prop)  [Decidable P]  (a b : α) : ite P (a * b) 0 = ite P a 0 * b := by by_cases h : P; sorry",
  "name": "ite_mul_zero_left",
  "kind": "theorem",
  "first-tactic": "by_cases h : P",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} {α : Type _}  [MulZeroClass α]  (P : Prop)  [Decidable P]  (a b : α) : ite P (a * b) 0 = ite P a 0 * b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} {α : Type _}  [MulZeroClass α]  (P : Prop)  [Decidable P]  (a b : α)"},
 {"type": "ite P (a * b) 0 = a * ite P b 0",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} {α : Type _}  [MulZeroClass α]  (P : Prop)  [Decidable P]  (a b : α) : ite P (a * b) 0 = a * ite P b 0 := by by_cases h : P; sorry",
  "name": "ite_mul_zero_right",
  "kind": "theorem",
  "first-tactic": "by_cases h : P",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} {α : Type _}  [MulZeroClass α]  (P : Prop)  [Decidable P]  (a b : α) : ite P (a * b) 0 = a * ite P b 0",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} {α : Type _}  [MulZeroClass α]  (P : Prop)  [Decidable P]  (a b : α)"},
 {"type": "ite (P ∧ Q) (a * b) 0 = ite P a 0 * ite Q b 0",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} {α : Type _}  [MulZeroClass α]  (P Q : Prop)  [Decidable P]  [Decidable Q]      (a b : α) : ite (P ∧ Q) (a * b) 0 = ite P a 0 * ite Q b 0 := by simp only [← ite_and]; sorry",
  "name": "ite_and_mul_zero",
  "kind": "theorem",
  "first-tactic": "simp only [← ite_and]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} {α : Type _}  [MulZeroClass α]  (P Q : Prop)  [Decidable P]  [Decidable Q]      (a b : α) : ite (P ∧ Q) (a * b) 0 = ite P a 0 * ite Q b 0",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} {α : Type _}  [MulZeroClass α]  (P Q : Prop)  [Decidable P]  [Decidable Q]      (a b : α)"},
 {"type": "(a + b) * (a + b) = a * a + 2 * a * b + b * b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [CommSemiring α]  {a b c : α} (a b : α) : (a + b) * (a + b) = a * a + 2 * a * b + b * b := by simp only [two_mul]; sorry",
  "name": "add_mul_self_eq",
  "kind": "theorem",
  "first-tactic": "simp only [two_mul]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [CommSemiring α]  {a b c : α} (a b : α) : (a + b) * (a + b) = a * a + 2 * a * b + b * b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [CommSemiring α]  {a b c : α} (a b : α)"},
 {"type": "-a * -b = a * b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}   [Mul α]  [HasDistribNeg α] (a b : α) : -a * -b = a * b := by simp; sorry",
  "name": "neg_mul_neg",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}   [Mul α]  [HasDistribNeg α] (a b : α) : -a * -b = a * b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}   [Mul α]  [HasDistribNeg α] (a b : α)"},
 {"type": "-a * b = a * -b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}   [Mul α]  [HasDistribNeg α] (a b : α) : -a * b = a * -b := by simp; sorry",
  "name": "neg_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}   [Mul α]  [HasDistribNeg α] (a b : α) : -a * b = a * -b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}   [Mul α]  [HasDistribNeg α] (a b : α)"},
 {"type": "-a = -1 * a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}   [MulOneClass α]  [HasDistribNeg α] (a : α) : -a = -1 * a := by simp; sorry",
  "name": "neg_eq_neg_one_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}   [MulOneClass α]  [HasDistribNeg α] (a : α) : -a = -1 * a",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}   [MulOneClass α]  [HasDistribNeg α] (a : α)"},
 {"type": "a * -1 = -a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}   [MulOneClass α]  [HasDistribNeg α] (a : α) : a * -1 = -a := by simp; sorry",
  "name": "mul_neg_one",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}   [MulOneClass α]  [HasDistribNeg α] (a : α) : a * -1 = -a",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}   [MulOneClass α]  [HasDistribNeg α] (a : α)"},
 {"type": "-1 * a = -a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}   [MulOneClass α]  [HasDistribNeg α] (a : α) : -1 * a = -a := by simp; sorry",
  "name": "neg_one_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}   [MulOneClass α]  [HasDistribNeg α] (a : α) : -1 * a = -a",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}   [MulOneClass α]  [HasDistribNeg α] (a : α)"},
 {"type": "a * (b - c) = a * b - a * c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonUnitalNonAssocRing α] (a b c : α) : a * (b - c) = a * b - a * c := by simpa only [sub_eq_add_neg]; sorry",
  "name": "mul_sub_left_distrib",
  "kind": "theorem",
  "first-tactic": "simpa only [sub_eq_add_neg]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonUnitalNonAssocRing α] (a b c : α) : a * (b - c) = a * b - a * c",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonUnitalNonAssocRing α] (a b c : α)"},
 {"type": "(a - b) * c = a * c - b * c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonUnitalNonAssocRing α] (a b c : α) : (a - b) * c = a * c - b * c := by simpa only [sub_eq_add_neg]; sorry",
  "name": "mul_sub_right_distrib",
  "kind": "theorem",
  "first-tactic": "simpa only [sub_eq_add_neg]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonUnitalNonAssocRing α] (a b c : α) : (a - b) * c = a * c - b * c",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonUnitalNonAssocRing α] (a b c : α)"},
 {"type": "(a - 1) * b = a * b - b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonAssocRing α] (a b : α) : (a - 1) * b = a * b - b := by rw [sub_mul]; sorry",
  "name": "sub_one_mul",
  "kind": "theorem",
  "first-tactic": "rw [sub_mul]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonAssocRing α] (a b : α) : (a - 1) * b = a * b - b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonAssocRing α] (a b : α)"},
 {"type": "a * (b - 1) = a * b - a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonAssocRing α] (a b : α) : a * (b - 1) = a * b - a := by rw [mul_sub]; sorry",
  "name": "mul_sub_one",
  "kind": "theorem",
  "first-tactic": "rw [mul_sub]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonAssocRing α] (a b : α) : a * (b - 1) = a * b - a",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonAssocRing α] (a b : α)"},
 {"type": "(1 - a) * b = b - a * b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonAssocRing α] (a b : α) : (1 - a) * b = b - a * b := by rw [sub_mul]; sorry",
  "name": "one_sub_mul",
  "kind": "theorem",
  "first-tactic": "rw [sub_mul]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonAssocRing α] (a b : α) : (1 - a) * b = b - a * b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonAssocRing α] (a b : α)"},
 {"type": "a * (1 - b) = a - a * b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonAssocRing α] (a b : α) : a * (1 - b) = a - a * b := by rw [mul_sub]; sorry",
  "name": "mul_one_sub",
  "kind": "theorem",
  "first-tactic": "rw [mul_sub]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonAssocRing α] (a b : α) : a * (1 - b) = a - a * b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonAssocRing α] (a b : α)"},
 {"type": "IsIdempotentElem (p * q)",
  "tactic-prompt":
  "theorem {M N S M₀ M₁ R G G₀ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass M₀]  [MulOneClass M₁]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero G₀] {p q : S}  (h : Commute p q)  (h₁ : IsIdempotentElem p)      (h₂ : IsIdempotentElem q) : IsIdempotentElem (p * q) := by rw [IsIdempotentElem]; sorry",
  "name": "mul_of_commute",
  "kind": "theorem",
  "first-tactic": "rw [IsIdempotentElem]",
  "core-prompt":
  "{M N S M₀ M₁ R G G₀ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass M₀]  [MulOneClass M₁]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero G₀] {p q : S}  (h : Commute p q)  (h₁ : IsIdempotentElem p)      (h₂ : IsIdempotentElem q) : IsIdempotentElem (p * q)",
  "args":
  "{M N S M₀ M₁ R G G₀ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass M₀]  [MulOneClass M₁]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero G₀] {p q : S}  (h : Commute p q)  (h₁ : IsIdempotentElem p)      (h₂ : IsIdempotentElem q)"},
 {"type": "IsIdempotentElem (1 - p)",
  "tactic-prompt":
  "theorem {M N S M₀ M₁ R G G₀ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass M₀]  [MulOneClass M₁]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero G₀] {p : R}  (h : IsIdempotentElem p) : IsIdempotentElem (1 - p) := by rw [IsIdempotentElem]; sorry",
  "name": "one_sub",
  "kind": "theorem",
  "first-tactic": "rw [IsIdempotentElem]",
  "core-prompt":
  "{M N S M₀ M₁ R G G₀ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass M₀]  [MulOneClass M₁]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero G₀] {p : R}  (h : IsIdempotentElem p) : IsIdempotentElem (1 - p)",
  "args":
  "{M N S M₀ M₁ R G G₀ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass M₀]  [MulOneClass M₁]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero G₀] {p : R}  (h : IsIdempotentElem p)"},
 {"type": "IsIdempotentElem p ↔ p = 0 ∨ p = 1",
  "tactic-prompt":
  "theorem {M N S M₀ M₁ R G G₀ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass M₀]  [MulOneClass M₁]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero G₀] {p : G₀} : IsIdempotentElem p ↔ p = 0 ∨ p = 1 := by refine'\n    Iff.intro (fun h => or_iff_not_imp_left.mpr fun hp => _) fun h =>\n      h.elim (fun hp => hp.symm ▸ zero) fun hp => hp.symm ▸ one; sorry",
  "name": "iff_eq_zero_or_one",
  "kind": "theorem",
  "first-tactic":
  "refine'\n    Iff.intro (fun h => or_iff_not_imp_left.mpr fun hp => _) fun h =>\n      h.elim (fun hp => hp.symm ▸ zero) fun hp => hp.symm ▸ one",
  "core-prompt":
  "{M N S M₀ M₁ R G G₀ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass M₀]  [MulOneClass M₁]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero G₀] {p : G₀} : IsIdempotentElem p ↔ p = 0 ∨ p = 1",
  "args":
  "{M N S M₀ M₁ R G G₀ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass M₀]  [MulOneClass M₁]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero G₀] {p : G₀}"},
 {"type": "SemiconjBy a (x + x') (y + y')",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [Distrib R]  {a x y x' y' : R}  (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x + x') (y + y') := by simp only [SemiconjBy]; sorry",
  "name": "add_right",
  "kind": "theorem",
  "first-tactic": "simp only [SemiconjBy]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [Distrib R]  {a x y x' y' : R}  (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x + x') (y + y')",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [Distrib R]  {a x y x' y' : R}  (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y')"},
 {"type": "SemiconjBy (a + b) x y",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [Distrib R]  {a b x y : R}  (ha : SemiconjBy a x y)  (hb : SemiconjBy b x y) : SemiconjBy (a + b) x y := by simp only [SemiconjBy]; sorry",
  "name": "add_left",
  "kind": "theorem",
  "first-tactic": "simp only [SemiconjBy]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [Distrib R]  {a b x y : R}  (ha : SemiconjBy a x y)  (hb : SemiconjBy b x y) : SemiconjBy (a + b) x y",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [Distrib R]  {a b x y : R}  (ha : SemiconjBy a x y)  (hb : SemiconjBy b x y)"},
 {"type": "SemiconjBy a (-x) (-y)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Mul R]  [HasDistribNeg R]  {a x y : R} (h : SemiconjBy a x y) : SemiconjBy a (-x) (-y) := by simp only [SemiconjBy]; sorry",
  "name": "neg_right",
  "kind": "theorem",
  "first-tactic": "simp only [SemiconjBy]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Mul R]  [HasDistribNeg R]  {a x y : R} (h : SemiconjBy a x y) : SemiconjBy a (-x) (-y)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Mul R]  [HasDistribNeg R]  {a x y : R} (h : SemiconjBy a x y)"},
 {"type": "SemiconjBy (-a) x y",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Mul R]  [HasDistribNeg R]  {a x y : R} (h : SemiconjBy a x y) : SemiconjBy (-a) x y := by simp only [SemiconjBy]; sorry",
  "name": "neg_left",
  "kind": "theorem",
  "first-tactic": "simp only [SemiconjBy]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Mul R]  [HasDistribNeg R]  {a x y : R} (h : SemiconjBy a x y) : SemiconjBy (-a) x y",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Mul R]  [HasDistribNeg R]  {a x y : R} (h : SemiconjBy a x y)"},
 {"type": "SemiconjBy a (x - x') (y - y')",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonUnitalNonAssocRing R]  {a b x y x' y' : R} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x - x') (y - y') := by simpa only [sub_eq_add_neg] using h.add_right h'.neg_right; sorry",
  "name": "sub_right",
  "kind": "theorem",
  "first-tactic": "simpa only [sub_eq_add_neg] using h.add_right h'.neg_right",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonUnitalNonAssocRing R]  {a b x y x' y' : R} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x - x') (y - y')",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonUnitalNonAssocRing R]  {a b x y x' y' : R} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y')"},
 {"type": "SemiconjBy (a - b) x y",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonUnitalNonAssocRing R]  {a b x y x' y' : R} (ha : SemiconjBy a x y)  (hb : SemiconjBy b x y) : SemiconjBy (a - b) x y := by simpa only [sub_eq_add_neg] using ha.add_left hb.neg_left; sorry",
  "name": "sub_left",
  "kind": "theorem",
  "first-tactic": "simpa only [sub_eq_add_neg] using ha.add_left hb.neg_left",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonUnitalNonAssocRing R]  {a b x y x' y' : R} (ha : SemiconjBy a x y)  (hb : SemiconjBy b x y) : SemiconjBy (a - b) x y",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [NonUnitalNonAssocRing R]  {a b x y x' y' : R} (ha : SemiconjBy a x y)  (hb : SemiconjBy b x y)"},
 {"type": "a ∣ b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Semigroup α]  [HasDistribNeg α]  {a b c : α} (h : a ∣ -b) : a ∣ b := by let t := dvd_neg_of_dvd h; sorry",
  "name": "dvd_of_dvd_neg",
  "kind": "theorem",
  "first-tactic": "let t := dvd_neg_of_dvd h",
  "core-prompt":
  "{α β : Type _}  [Semigroup α]  [HasDistribNeg α]  {a b c : α} (h : a ∣ -b) : a ∣ b",
  "args":
  "{α β : Type _}  [Semigroup α]  [HasDistribNeg α]  {a b c : α} (h : a ∣ -b)"},
 {"type": "a ∣ b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Semigroup α]  [HasDistribNeg α]  {a b c : α} (h : -a ∣ b) : a ∣ b := by let t := neg_dvd_of_dvd h; sorry",
  "name": "dvd_of_neg_dvd",
  "kind": "theorem",
  "first-tactic": "let t := neg_dvd_of_dvd h",
  "core-prompt":
  "{α β : Type _}  [Semigroup α]  [HasDistribNeg α]  {a b c : α} (h : -a ∣ b) : a ∣ b",
  "args":
  "{α β : Type _}  [Semigroup α]  [HasDistribNeg α]  {a b c : α} (h : -a ∣ b)"},
 {"type": "a ∣ b - c",
  "tactic-prompt":
  "theorem {α β : Type _}  [NonUnitalRing α]  {a b c : α} (h₁ : a ∣ b)  (h₂ : a ∣ c) : a ∣ b - c := by rw [sub_eq_add_neg]; sorry",
  "name": "dvd_sub",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{α β : Type _}  [NonUnitalRing α]  {a b c : α} (h₁ : a ∣ b)  (h₂ : a ∣ c) : a ∣ b - c",
  "args":
  "{α β : Type _}  [NonUnitalRing α]  {a b c : α} (h₁ : a ∣ b)  (h₂ : a ∣ c)"},
 {"type": "a ∣ c ↔ a ∣ b + c",
  "tactic-prompt":
  "theorem {α β : Type _}  [NonUnitalRing α]  {a b c : α} (h : a ∣ b) : a ∣ c ↔ a ∣ b + c := by rw [add_comm]; sorry",
  "name": "dvd_add_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{α β : Type _}  [NonUnitalRing α]  {a b c : α} (h : a ∣ b) : a ∣ c ↔ a ∣ b + c",
  "args": "{α β : Type _}  [NonUnitalRing α]  {a b c : α} (h : a ∣ b)"},
 {"type": "a ∣ b ↔ a ∣ c",
  "tactic-prompt":
  "theorem {α β : Type _}  [NonUnitalRing α]  {a b c : α} {a b c : α}  (h : a ∣ b - c) : a ∣ b ↔ a ∣ c := by constructor; sorry",
  "name": "dvd_iff_dvd_of_dvd_sub",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α β : Type _}  [NonUnitalRing α]  {a b c : α} {a b c : α}  (h : a ∣ b - c) : a ∣ b ↔ a ∣ c",
  "args":
  "{α β : Type _}  [NonUnitalRing α]  {a b c : α} {a b c : α}  (h : a ∣ b - c)"},
 {"type": "k ∣ a * x - b * y",
  "tactic-prompt":
  "theorem {α β : Type _}  [NonUnitalCommRing α]  {a b c : α} {k a b x y : α}  (hab : k ∣ a - b)  (hxy : k ∣ x - y) : k ∣ a * x - b * y := by convert dvd_add (hxy.mul_left a) (hab.mul_right y); sorry",
  "name": "dvd_mul_sub_mul",
  "kind": "theorem",
  "first-tactic": "convert dvd_add (hxy.mul_left a) (hab.mul_right y)",
  "core-prompt":
  "{α β : Type _}  [NonUnitalCommRing α]  {a b c : α} {k a b x y : α}  (hab : k ∣ a - b)  (hxy : k ∣ x - y) : k ∣ a * x - b * y",
  "args":
  "{α β : Type _}  [NonUnitalCommRing α]  {a b c : α} {k a b x y : α}  (hab : k ∣ a - b)  (hxy : k ∣ x - y)"},
 {"type": "a * a - b * b = (a + b) * (a - b)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  {a b : R}  (h : Commute a b) : a * a - b * b = (a + b) * (a - b) := by rw [add_mul]; sorry",
  "name": "mul_self_sub_mul_self_eq",
  "kind": "theorem",
  "first-tactic": "rw [add_mul]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  {a b : R}  (h : Commute a b) : a * a - b * b = (a + b) * (a - b)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  {a b : R}  (h : Commute a b)"},
 {"type": "a * a - b * b = (a - b) * (a + b)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  {a b : R}  (h : Commute a b) : a * a - b * b = (a - b) * (a + b) := by rw [mul_add]; sorry",
  "name": "mul_self_sub_mul_self_eq'",
  "kind": "theorem",
  "first-tactic": "rw [mul_add]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  {a b : R}  (h : Commute a b) : a * a - b * b = (a - b) * (a + b)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  {a b : R}  (h : Commute a b)"},
 {"type": "a * a = b * b ↔ a = b ∨ a = -b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  [NoZeroDivisors R]  {a b : R}      (h : Commute a b) : a * a = b * b ↔ a = b ∨ a = -b := by rw [← sub_eq_zero]; sorry",
  "name": "mul_self_eq_mul_self_iff",
  "kind": "theorem",
  "first-tactic": "rw [← sub_eq_zero]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  [NoZeroDivisors R]  {a b : R}      (h : Commute a b) : a * a = b * b ↔ a = b ∨ a = -b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  [NoZeroDivisors R]  {a b : R}      (h : Commute a b)"},
 {"type": "a * a - 1 = (a + 1) * (a - 1)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [NonAssocRing R]  (a : R) : a * a - 1 = (a + 1) * (a - 1) := by rw [← (Commute.one_right a).mul_self_sub_mul_self_eq]; sorry",
  "name": "mul_self_sub_one",
  "kind": "theorem",
  "first-tactic": "rw [← (Commute.one_right a).mul_self_sub_mul_self_eq]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [NonAssocRing R]  (a : R) : a * a - 1 = (a + 1) * (a - 1)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [NonAssocRing R]  (a : R)"},
 {"type": "a * a = 1 ↔ a = 1 ∨ a = -1",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [NonAssocRing R]  [NoZeroDivisors R]  {a : R} : a * a = 1 ↔ a = 1 ∨ a = -1 := by rw [← (Commute.one_right a).mul_self_eq_mul_self_iff]; sorry",
  "name": "mul_self_eq_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [← (Commute.one_right a).mul_self_eq_mul_self_iff]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [NonAssocRing R]  [NoZeroDivisors R]  {a : R} : a * a = 1 ↔ a = 1 ∨ a = -1",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [NonAssocRing R]  [NoZeroDivisors R]  {a : R}"},
 {"type": "u⁻¹ = u ↔ u = 1 ∨ u = -1",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [Ring R]  [NoZeroDivisors R]  (u : Rˣ) : u⁻¹ = u ↔ u = 1 ∨ u = -1 := by rw [inv_eq_iff_mul_eq_one]; sorry",
  "name": "inv_eq_self_iff",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_iff_mul_eq_one]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [Ring R]  [NoZeroDivisors R]  (u : Rˣ) : u⁻¹ = u ↔ u = 1 ∨ u = -1",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [Ring R]  [NoZeroDivisors R]  (u : Rˣ)"},
 {"type": "(-a)⁻¹ = -a⁻¹",
  "tactic-prompt":
  "theorem [Group α]  [HasDistribNeg α] (a : α) : (-a)⁻¹ = -a⁻¹ := by rw [eq_comm]; sorry",
  "name": "inv_neg'",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt": "[Group α]  [HasDistribNeg α] (a : α) : (-a)⁻¹ = -a⁻¹",
  "args": "[Group α]  [HasDistribNeg α] (a : α)"},
 {"type": "∃ y : α, y * y - b * y + c = 0 ∧ x + y = b ∧ x * y = c",
  "tactic-prompt":
  "theorem [NonUnitalCommRing α]  {a b c : α} {b c x : α}  (h : x * x - b * x + c = 0) : ∃ y : α, y * y - b * y + c = 0 ∧ x + y = b ∧ x * y = c := by have : c = x * (b - x) := (eq_neg_of_add_eq_zero_right h).trans (by simp [mul_sub]; sorry",
  "name": "Vieta_formula_quadratic",
  "kind": "theorem",
  "first-tactic":
  "have : c = x * (b - x) := (eq_neg_of_add_eq_zero_right h).trans (by simp [mul_sub]",
  "core-prompt":
  "[NonUnitalCommRing α]  {a b c : α} {b c x : α}  (h : x * x - b * x + c = 0) : ∃ y : α, y * y - b * y + c = 0 ∧ x + y = b ∧ x * y = c",
  "args":
  "[NonUnitalCommRing α]  {a b c : α} {b c x : α}  (h : x * x - b * x + c = 0)"},
 {"type": "-(a /ₚ u) = -a /ₚ u",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Monoid α]  [HasDistribNeg α]  {a b : α} (a : α)  (u : αˣ) : -(a /ₚ u) = -a /ₚ u := by simp only [divp]; sorry",
  "name": "neg_divp",
  "kind": "theorem",
  "first-tactic": "simp only [divp]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Monoid α]  [HasDistribNeg α]  {a b : α} (a : α)  (u : αˣ) : -(a /ₚ u) = -a /ₚ u",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Monoid α]  [HasDistribNeg α]  {a b : α} (a : α)  (u : αˣ)"},
 {"type": "a /ₚ u + b /ₚ u = (a + b) /ₚ u",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ) : a /ₚ u + b /ₚ u = (a + b) /ₚ u := by simp only [divp]; sorry",
  "name": "divp_add_divp_same",
  "kind": "theorem",
  "first-tactic": "simp only [divp]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ) : a /ₚ u + b /ₚ u = (a + b) /ₚ u",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ)"},
 {"type": "a /ₚ u - b /ₚ u = (a - b) /ₚ u",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ) : a /ₚ u - b /ₚ u = (a - b) /ₚ u := by rw [sub_eq_add_neg]; sorry",
  "name": "divp_sub_divp_same",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ) : a /ₚ u - b /ₚ u = (a - b) /ₚ u",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ)"},
 {"type": "a + b /ₚ u = (a * u + b) /ₚ u",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ) : a + b /ₚ u = (a * u + b) /ₚ u := by simp only [divp]; sorry",
  "name": "add_divp",
  "kind": "theorem",
  "first-tactic": "simp only [divp]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ) : a + b /ₚ u = (a * u + b) /ₚ u",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ)"},
 {"type": "a - b /ₚ u = (a * u - b) /ₚ u",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ) : a - b /ₚ u = (a * u - b) /ₚ u := by simp only [divp]; sorry",
  "name": "sub_divp",
  "kind": "theorem",
  "first-tactic": "simp only [divp]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ) : a - b /ₚ u = (a * u - b) /ₚ u",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ)"},
 {"type": "a /ₚ u + b = (a + b * u) /ₚ u",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ) : a /ₚ u + b = (a + b * u) /ₚ u := by simp only [divp]; sorry",
  "name": "divp_add",
  "kind": "theorem",
  "first-tactic": "simp only [divp]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ) : a /ₚ u + b = (a + b * u) /ₚ u",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ)"},
 {"type": "a /ₚ u - b = (a - b * u) /ₚ u",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ) : a /ₚ u - b = (a - b * u) /ₚ u := by simp only [divp]; sorry",
  "name": "divp_sub",
  "kind": "theorem",
  "first-tactic": "simp only [divp]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ) : a /ₚ u - b = (a - b * u) /ₚ u",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x}  [Ring α]  {a b : α} (a b : α)  (u : αˣ)"},
 {"type": "a /ₚ u₁ + b /ₚ u₂ = (a * u₂ + u₁ * b) /ₚ (u₁ * u₂)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [CommRing α]  (a b : α)  (u₁ u₂ : αˣ) : a /ₚ u₁ + b /ₚ u₂ = (a * u₂ + u₁ * b) /ₚ (u₁ * u₂) := by simp only [divp]; sorry",
  "name": "divp_add_divp",
  "kind": "theorem",
  "first-tactic": "simp only [divp]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [CommRing α]  (a b : α)  (u₁ u₂ : αˣ) : a /ₚ u₁ + b /ₚ u₂ = (a * u₂ + u₁ * b) /ₚ (u₁ * u₂)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [CommRing α]  (a b : α)  (u₁ u₂ : αˣ)"},
 {"type": "a /ₚ u₁ - b /ₚ u₂ = (a * u₂ - u₁ * b) /ₚ (u₁ * u₂)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [CommRing α]  (a b : α)  (u₁ u₂ : αˣ) : a /ₚ u₁ - b /ₚ u₂ = (a * u₂ - u₁ * b) /ₚ (u₁ * u₂) := by simp only [sub_eq_add_neg]; sorry",
  "name": "divp_sub_divp",
  "kind": "theorem",
  "first-tactic": "simp only [sub_eq_add_neg]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [CommRing α]  (a b : α)  (u₁ u₂ : αˣ) : a /ₚ u₁ - b /ₚ u₂ = (a * u₂ - u₁ * b) /ₚ (u₁ * u₂)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {R : Type x} [CommRing α]  (a b : α)  (u₁ u₂ : αˣ)"},
 {"type": "IsLeftRegular k",
  "tactic-prompt":
  "theorem {α : Type _} [NonUnitalNonAssocRing α]  (k : α)      (h : ∀ x : α, k * x = 0 → x = 0) : IsLeftRegular k := by refine' fun x y (h' : k * x = k * y) => sub_eq_zero.mp (h _ _); sorry",
  "name": "isLeftRegular_of_non_zero_divisor",
  "kind": "theorem",
  "first-tactic":
  "refine' fun x y (h' : k * x = k * y) => sub_eq_zero.mp (h _ _)",
  "core-prompt":
  "{α : Type _} [NonUnitalNonAssocRing α]  (k : α)      (h : ∀ x : α, k * x = 0 → x = 0) : IsLeftRegular k",
  "args":
  "{α : Type _} [NonUnitalNonAssocRing α]  (k : α)      (h : ∀ x : α, k * x = 0 → x = 0)"},
 {"type": "IsRightRegular k",
  "tactic-prompt":
  "theorem {α : Type _} [NonUnitalNonAssocRing α]  (k : α)      (h : ∀ x : α, x * k = 0 → x = 0) : IsRightRegular k := by refine' fun x y (h' : x * k = y * k) => sub_eq_zero.mp (h _ _); sorry",
  "name": "isRightRegular_of_non_zero_divisor",
  "kind": "theorem",
  "first-tactic":
  "refine' fun x y (h' : x * k = y * k) => sub_eq_zero.mp (h _ _)",
  "core-prompt":
  "{α : Type _} [NonUnitalNonAssocRing α]  (k : α)      (h : ∀ x : α, x * k = 0 → x = 0) : IsRightRegular k",
  "args":
  "{α : Type _} [NonUnitalNonAssocRing α]  (k : α)      (h : ∀ x : α, x * k = 0 → x = 0)"},
 {"type": "∀ x : R, x ≠ 0 → ∃! y : R, x * y = 1",
  "tactic-prompt":
  "theorem {α β K : Type _}  (R : Type u)  [Ring R]  (hf : IsField R) : ∀ x : R, x ≠ 0 → ∃! y : R, x * y = 1 := by intro x hx; sorry",
  "name": "uniq_inv_of_is_field",
  "kind": "theorem",
  "first-tactic": "intro x hx",
  "core-prompt":
  "{α β K : Type _}  (R : Type u)  [Ring R]  (hf : IsField R) : ∀ x : R, x ≠ 0 → ∃! y : R, x * y = 1",
  "args": "{α β K : Type _}  (R : Type u)  [Ring R]  (hf : IsField R)"},
 {"type": "(a + b) / c = a / c + b / c",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionSemiring α]  {a b c : α} (a b c : α) : (a + b) / c = a / c + b / c := by simp_rw [div_eq_mul_inv]; sorry",
  "name": "add_div",
  "kind": "theorem",
  "first-tactic": "simp_rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β K : Type _}  [DivisionSemiring α]  {a b c : α} (a b c : α) : (a + b) / c = a / c + b / c",
  "args": "{α β K : Type _}  [DivisionSemiring α]  {a b c : α} (a b c : α)"},
 {"type": "(b + a) / b = 1 + a / b",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionSemiring α]  {a b c : α} (h : b ≠ 0) : (b + a) / b = 1 + a / b := by rw [← div_self h]; sorry",
  "name": "same_add_div",
  "kind": "theorem",
  "first-tactic": "rw [← div_self h]",
  "core-prompt":
  "{α β K : Type _}  [DivisionSemiring α]  {a b c : α} (h : b ≠ 0) : (b + a) / b = 1 + a / b",
  "args": "{α β K : Type _}  [DivisionSemiring α]  {a b c : α} (h : b ≠ 0)"},
 {"type": "(a + b) / b = a / b + 1",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionSemiring α]  {a b c : α} (h : b ≠ 0) : (a + b) / b = a / b + 1 := by rw [← div_self h]; sorry",
  "name": "div_add_same",
  "kind": "theorem",
  "first-tactic": "rw [← div_self h]",
  "core-prompt":
  "{α β K : Type _}  [DivisionSemiring α]  {a b c : α} (h : b ≠ 0) : (a + b) / b = a / b + 1",
  "args": "{α β K : Type _}  [DivisionSemiring α]  {a b c : α} (h : b ≠ 0)"},
 {"type": "1 / a * (a + b) * (1 / b) = 1 / a + 1 / b",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionSemiring α]  {a b c : α} (ha : a ≠ 0)  (hb : b ≠ 0) : 1 / a * (a + b) * (1 / b) = 1 / a + 1 / b := by rw [mul_add]; sorry",
  "name": "one_div_mul_add_mul_one_div_eq_one_div_add_one_div",
  "kind": "theorem",
  "first-tactic": "rw [mul_add]",
  "core-prompt":
  "{α β K : Type _}  [DivisionSemiring α]  {a b c : α} (ha : a ≠ 0)  (hb : b ≠ 0) : 1 / a * (a + b) * (1 / b) = 1 / a + 1 / b",
  "args":
  "{α β K : Type _}  [DivisionSemiring α]  {a b c : α} (ha : a ≠ 0)  (hb : b ≠ 0)"},
 {"type": "b + a / c = (b * c + a) / c",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionSemiring α]  {a b c : α} (a b c : α)  (hc : c ≠ 0) : b + a / c = (b * c + a) / c := by rw [add_div]; sorry",
  "name": "add_div'",
  "kind": "theorem",
  "first-tactic": "rw [add_div]",
  "core-prompt":
  "{α β K : Type _}  [DivisionSemiring α]  {a b c : α} (a b c : α)  (hc : c ≠ 0) : b + a / c = (b * c + a) / c",
  "args":
  "{α β K : Type _}  [DivisionSemiring α]  {a b c : α} (a b c : α)  (hc : c ≠ 0)"},
 {"type": "a / c + b = (a + b * c) / c",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionSemiring α]  {a b c : α} (a b c : α)  (hc : c ≠ 0) : a / c + b = (a + b * c) / c := by rwa [add_comm]; sorry",
  "name": "div_add'",
  "kind": "theorem",
  "first-tactic": "rwa [add_comm]",
  "core-prompt":
  "{α β K : Type _}  [DivisionSemiring α]  {a b c : α} (a b c : α)  (hc : c ≠ 0) : a / c + b = (a + b * c) / c",
  "args":
  "{α β K : Type _}  [DivisionSemiring α]  {a b c : α} (a b c : α)  (hc : c ≠ 0)"},
 {"type": "-b / a = -(b / a)",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K) : -b / a = -(b / a) := by rw [neg_eq_neg_one_mul]; sorry",
  "name": "neg_div",
  "kind": "theorem",
  "first-tactic": "rw [neg_eq_neg_one_mul]",
  "core-prompt":
  "{α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K) : -b / a = -(b / a)",
  "args":
  "{α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K)"},
 {"type": "-(b / a) = -b / a",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K) : -(b / a) = -b / a := by simp [neg_div]; sorry",
  "name": "neg_div'",
  "kind": "theorem",
  "first-tactic": "simp [neg_div]",
  "core-prompt":
  "{α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K) : -(b / a) = -b / a",
  "args":
  "{α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K)"},
 {"type": "-a / -b = a / b",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K) : -a / -b = a / b := by rw [div_neg_eq_neg_div]; sorry",
  "name": "neg_div_neg_eq",
  "kind": "theorem",
  "first-tactic": "rw [div_neg_eq_neg_div]",
  "core-prompt":
  "{α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K) : -a / -b = a / b",
  "args":
  "{α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K)"},
 {"type": "-a⁻¹ = (-a)⁻¹",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} : -a⁻¹ = (-a)⁻¹ := by rw [inv_eq_one_div]; sorry",
  "name": "neg_inv",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} : -a⁻¹ = (-a)⁻¹",
  "args": "{α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K}"},
 {"type": "a / -b = -(a / b)",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a : K) : a / -b = -(a / b) := by rw [← div_neg_eq_neg_div]; sorry",
  "name": "div_neg",
  "kind": "theorem",
  "first-tactic": "rw [← div_neg_eq_neg_div]",
  "core-prompt":
  "{α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a : K) : a / -b = -(a / b)",
  "args":
  "{α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a : K)"},
 {"type": "(-a)⁻¹ = -a⁻¹",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} : (-a)⁻¹ = -a⁻¹ := by rw [neg_inv]; sorry",
  "name": "inv_neg",
  "kind": "theorem",
  "first-tactic": "rw [neg_inv]",
  "core-prompt":
  "{α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} : (-a)⁻¹ = -a⁻¹",
  "args": "{α β K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K}"},
 {"type": "a / -a = -1",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionRing K]  {a b : K} {a : K}  (h : a ≠ 0) : a / -a = -1 := by rw [div_neg_eq_neg_div]; sorry",
  "name": "div_neg_self",
  "kind": "theorem",
  "first-tactic": "rw [div_neg_eq_neg_div]",
  "core-prompt":
  "{α β K : Type _}  [DivisionRing K]  {a b : K} {a : K}  (h : a ≠ 0) : a / -a = -1",
  "args": "{α β K : Type _}  [DivisionRing K]  {a b : K} {a : K}  (h : a ≠ 0)"},
 {"type": "-a / a = -1",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionRing K]  {a b : K} {a : K}  (h : a ≠ 0) : -a / a = -1 := by rw [neg_div]; sorry",
  "name": "neg_div_self",
  "kind": "theorem",
  "first-tactic": "rw [neg_div]",
  "core-prompt":
  "{α β K : Type _}  [DivisionRing K]  {a b : K} {a : K}  (h : a ≠ 0) : -a / a = -1",
  "args": "{α β K : Type _}  [DivisionRing K]  {a b : K} {a : K}  (h : a ≠ 0)"},
 {"type": "a / c - b / c = (a - b) / c",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionRing K]  {a b : K} (a b c : K) : a / c - b / c = (a - b) / c := by rw [sub_eq_add_neg]; sorry",
  "name": "div_sub_div_same",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{α β K : Type _}  [DivisionRing K]  {a b : K} (a b c : K) : a / c - b / c = (a - b) / c",
  "args": "{α β K : Type _}  [DivisionRing K]  {a b : K} (a b c : K)"},
 {"type": "(b - a) / b = 1 - a / b",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (h : b ≠ 0) : (b - a) / b = 1 - a / b := by simpa only [← @div_self _ _ b h] using (div_sub_div_same b a b).symm; sorry",
  "name": "same_sub_div",
  "kind": "theorem",
  "first-tactic":
  "simpa only [← @div_self _ _ b h] using (div_sub_div_same b a b).symm",
  "core-prompt":
  "{α β K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (h : b ≠ 0) : (b - a) / b = 1 - a / b",
  "args":
  "{α β K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (h : b ≠ 0)"},
 {"type": "(a - b) / b = a / b - 1",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (h : b ≠ 0) : (a - b) / b = a / b - 1 := by simpa only [← @div_self _ _ b h] using (div_sub_div_same a b b).symm; sorry",
  "name": "div_sub_same",
  "kind": "theorem",
  "first-tactic":
  "simpa only [← @div_self _ _ b h] using (div_sub_div_same a b b).symm",
  "core-prompt":
  "{α β K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (h : b ≠ 0) : (a - b) / b = a / b - 1",
  "args":
  "{α β K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (h : b ≠ 0)"},
 {"type": "a⁻¹ - b⁻¹ = a⁻¹ * (b - a) * b⁻¹",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (ha : a ≠ 0)  (hb : b ≠ 0) : a⁻¹ - b⁻¹ = a⁻¹ * (b - a) * b⁻¹ := by rw [mul_sub]; sorry",
  "name": "inv_sub_inv'",
  "kind": "theorem",
  "first-tactic": "rw [mul_sub]",
  "core-prompt":
  "{α β K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (ha : a ≠ 0)  (hb : b ≠ 0) : a⁻¹ - b⁻¹ = a⁻¹ * (b - a) * b⁻¹",
  "args":
  "{α β K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (ha : a ≠ 0)  (hb : b ≠ 0)"},
 {"type": "1 / a * (b - a) * (1 / b) = 1 / a - 1 / b",
  "tactic-prompt":
  "theorem {α β K : Type _}  [DivisionRing K]  {a b : K} (ha : a ≠ 0)  (hb : b ≠ 0) : 1 / a * (b - a) * (1 / b) = 1 / a - 1 / b := by rw [mul_sub_left_distrib (1 / a)]; sorry",
  "name": "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div",
  "kind": "theorem",
  "first-tactic": "rw [mul_sub_left_distrib (1 / a)]",
  "core-prompt":
  "{α β K : Type _}  [DivisionRing K]  {a b : K} (ha : a ≠ 0)  (hb : b ≠ 0) : 1 / a * (b - a) * (1 / b) = 1 / a - 1 / b",
  "args":
  "{α β K : Type _}  [DivisionRing K]  {a b : K} (ha : a ≠ 0)  (hb : b ≠ 0)"},
 {"type": "a / b + c / d = (a * d + b * c) / (b * d)",
  "tactic-prompt":
  "theorem {α β K : Type _}  [Semifield α]  {a b c d : α} (a : α)  (c : α)  (hb : b ≠ 0)  (hd : d ≠ 0) : a / b + c / d = (a * d + b * c) / (b * d) := by rw [← mul_div_mul_right _ b hd]; sorry",
  "name": "div_add_div",
  "kind": "theorem",
  "first-tactic": "rw [← mul_div_mul_right _ b hd]",
  "core-prompt":
  "{α β K : Type _}  [Semifield α]  {a b c d : α} (a : α)  (c : α)  (hb : b ≠ 0)  (hd : d ≠ 0) : a / b + c / d = (a * d + b * c) / (b * d)",
  "args":
  "{α β K : Type _}  [Semifield α]  {a b c d : α} (a : α)  (c : α)  (hb : b ≠ 0)  (hd : d ≠ 0)"},
 {"type": "1 / a + 1 / b = (a + b) / (a * b)",
  "tactic-prompt":
  "theorem {α β K : Type _}  [Semifield α]  {a b c d : α} (ha : a ≠ 0)  (hb : b ≠ 0) : 1 / a + 1 / b = (a + b) / (a * b) := by rw [div_add_div _ _ ha hb]; sorry",
  "name": "one_div_add_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_add_div _ _ ha hb]",
  "core-prompt":
  "{α β K : Type _}  [Semifield α]  {a b c d : α} (ha : a ≠ 0)  (hb : b ≠ 0) : 1 / a + 1 / b = (a + b) / (a * b)",
  "args":
  "{α β K : Type _}  [Semifield α]  {a b c d : α} (ha : a ≠ 0)  (hb : b ≠ 0)"},
 {"type": "a⁻¹ + b⁻¹ = (a + b) / (a * b)",
  "tactic-prompt":
  "theorem {α β K : Type _}  [Semifield α]  {a b c d : α} (ha : a ≠ 0)  (hb : b ≠ 0) : a⁻¹ + b⁻¹ = (a + b) / (a * b) := by rw [inv_eq_one_div]; sorry",
  "name": "inv_add_inv",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{α β K : Type _}  [Semifield α]  {a b c d : α} (ha : a ≠ 0)  (hb : b ≠ 0) : a⁻¹ + b⁻¹ = (a + b) / (a * b)",
  "args":
  "{α β K : Type _}  [Semifield α]  {a b c d : α} (ha : a ≠ 0)  (hb : b ≠ 0)"},
 {"type": "a / b - c / d = (a * d - b * c) / (b * d)",
  "tactic-prompt":
  "theorem {α β K : Type _}  [Field K] (a : K)  {b : K}  (c : K)  {d : K}  (hb : b ≠ 0)  (hd : d ≠ 0) : a / b - c / d = (a * d - b * c) / (b * d) := by simp [sub_eq_add_neg]; sorry",
  "name": "div_sub_div",
  "kind": "theorem",
  "first-tactic": "simp [sub_eq_add_neg]",
  "core-prompt":
  "{α β K : Type _}  [Field K] (a : K)  {b : K}  (c : K)  {d : K}  (hb : b ≠ 0)  (hd : d ≠ 0) : a / b - c / d = (a * d - b * c) / (b * d)",
  "args":
  "{α β K : Type _}  [Field K] (a : K)  {b : K}  (c : K)  {d : K}  (hb : b ≠ 0)  (hd : d ≠ 0)"},
 {"type": "a⁻¹ - b⁻¹ = (b - a) / (a * b)",
  "tactic-prompt":
  "theorem {α β K : Type _}  [Field K] {a b : K}  (ha : a ≠ 0)  (hb : b ≠ 0) : a⁻¹ - b⁻¹ = (b - a) / (a * b) := by rw [inv_eq_one_div]; sorry",
  "name": "inv_sub_inv",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{α β K : Type _}  [Field K] {a b : K}  (ha : a ≠ 0)  (hb : b ≠ 0) : a⁻¹ - b⁻¹ = (b - a) / (a * b)",
  "args": "{α β K : Type _}  [Field K] {a b : K}  (ha : a ≠ 0)  (hb : b ≠ 0)"},
 {"type": "b - a / c = (b * c - a) / c",
  "tactic-prompt":
  "theorem {α β K : Type _}  [Field K] (a b c : K)  (hc : c ≠ 0) : b - a / c = (b * c - a) / c := by simpa using div_sub_div b a one_ne_zero hc; sorry",
  "name": "sub_div'",
  "kind": "theorem",
  "first-tactic": "simpa using div_sub_div b a one_ne_zero hc",
  "core-prompt":
  "{α β K : Type _}  [Field K] (a b c : K)  (hc : c ≠ 0) : b - a / c = (b * c - a) / c",
  "args": "{α β K : Type _}  [Field K] (a b c : K)  (hc : c ≠ 0)"},
 {"type": "a / c - b = (a - c * b) / c",
  "tactic-prompt":
  "theorem {α β K : Type _}  [Field K] (a b c : K)  (hc : c ≠ 0) : a / c - b = (a - c * b) / c := by simpa using div_sub_div a b hc one_ne_zero; sorry",
  "name": "div_sub'",
  "kind": "theorem",
  "first-tactic": "simpa using div_sub_div a b hc one_ne_zero",
  "core-prompt":
  "{α β K : Type _}  [Field K] (a b c : K)  (hc : c ≠ 0) : a / c - b = (a - c * b) / c",
  "args": "{α β K : Type _}  [Field K] (a b c : K)  (hc : c ≠ 0)"},
 {"type": "(a * b * a⁻¹) ^ i = a * b ^ i * a⁻¹",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [Group α] {i : ℕ}  {a b : α} : (a * b * a⁻¹) ^ i = a * b ^ i * a⁻¹ := by induction' i with i hi; sorry",
  "name": "conj_pow",
  "kind": "theorem",
  "first-tactic": "induction' i with i hi",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [Group α] {i : ℕ}  {a b : α} : (a * b * a⁻¹) ^ i = a * b ^ i * a⁻¹",
  "args": "{α : Type u}  {β : Type v}  [Group α] {i : ℕ}  {a b : α}"},
 {"type": "(a * b * a⁻¹) ^ i = a * b ^ i * a⁻¹",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [Group α] {i : ℤ}  {a b : α} : (a * b * a⁻¹) ^ i = a * b ^ i * a⁻¹ := by induction' i; sorry",
  "name": "conj_zpow",
  "kind": "theorem",
  "first-tactic": "induction' i",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [Group α] {i : ℤ}  {a b : α} : (a * b * a⁻¹) ^ i = a * b ^ i * a⁻¹",
  "args": "{α : Type u}  {β : Type v}  [Group α] {i : ℤ}  {a b : α}"},
 {"type": "Function.Surjective (ConjClasses.map f)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [Monoid α]  [Monoid β] {f : α →* β}  (hf : Function.Surjective f) : Function.Surjective (ConjClasses.map f) := by intro b; sorry",
  "name": "map_surjective",
  "kind": "theorem",
  "first-tactic": "intro b",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [Monoid α]  [Monoid β] {f : α →* β}  (hf : Function.Surjective f) : Function.Surjective (ConjClasses.map f)",
  "args":
  "{α : Type u}  {β : Type v}  [Monoid α]  [Monoid β] {f : α →* β}  (hf : Function.Surjective f)"},
 {"type": "a ∈ carrier b ↔ ConjClasses.mk a = b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v} [Monoid α] {a : α}  {b : ConjClasses α} : a ∈ carrier b ↔ ConjClasses.mk a = b := by revert b; sorry",
  "name": "mem_carrier_iff_mk_eq",
  "kind": "theorem",
  "first-tactic": "revert b",
  "core-prompt":
  "{α : Type u}  {β : Type v} [Monoid α] {a : α}  {b : ConjClasses α} : a ∈ carrier b ↔ ConjClasses.mk a = b",
  "args": "{α : Type u}  {β : Type v} [Monoid α] {a : α}  {b : ConjClasses α}"},
 {"type": "∀ ⦃m₁ m₂ : MulOneClass M⦄, m₁.mul = m₂.mul → m₁ = m₂",
  "tactic-prompt":
  "theorem {G : Type _} {M : Type u} : ∀ ⦃m₁ m₂ : MulOneClass M⦄, m₁.mul = m₂.mul → m₁ = m₂ := by rintro @⟨⟨one₁⟩, ⟨mul₁⟩, one_mul₁, mul_one₁⟩ @⟨⟨one₂⟩, ⟨mul₂⟩, one_mul₂, mul_one₂⟩ ⟨rfl⟩; sorry",
  "name": "MulOneClass.ext",
  "kind": "theorem",
  "first-tactic":
  "rintro @⟨⟨one₁⟩, ⟨mul₁⟩, one_mul₁, mul_one₁⟩ @⟨⟨one₂⟩, ⟨mul₂⟩, one_mul₂, mul_one₂⟩ ⟨rfl⟩",
  "core-prompt":
  "{G : Type _} {M : Type u} : ∀ ⦃m₁ m₂ : MulOneClass M⦄, m₁.mul = m₂.mul → m₁ = m₂",
  "args": "{G : Type _} {M : Type u}"},
 {"type": "b = c",
  "tactic-prompt":
  "theorem {G : Type _}  {M : Type u}  [Monoid M] {a b c : M}  (hba : b * a = 1)  (hac : a * c = 1) : b = c := by rw [← one_mul c]; sorry",
  "name": "left_inv_eq_right_inv",
  "kind": "theorem",
  "first-tactic": "rw [← one_mul c]",
  "core-prompt":
  "{G : Type _}  {M : Type u}  [Monoid M] {a b c : M}  (hba : b * a = 1)  (hac : a * c = 1) : b = c",
  "args":
  "{G : Type _}  {M : Type u}  [Monoid M] {a b c : M}  (hba : b * a = 1)  (hac : a * c = 1)"},
 {"type": "a ^ (Int.negSucc n) = (a ^ (n + 1))⁻¹",
  "tactic-prompt":
  "theorem {G : Type _}  [DivInvMonoid G]  {a b : G} (a : G)  (n : ℕ) : a ^ (Int.negSucc n) = (a ^ (n + 1))⁻¹ := by rw [← zpow_ofNat]; sorry",
  "name": "zpow_negSucc",
  "kind": "theorem",
  "first-tactic": "rw [← zpow_ofNat]",
  "core-prompt":
  "{G : Type _}  [DivInvMonoid G]  {a b : G} (a : G)  (n : ℕ) : a ^ (Int.negSucc n) = (a ^ (n + 1))⁻¹",
  "args": "{G : Type _}  [DivInvMonoid G]  {a b : G} (a : G)  (n : ℕ)"},
 {"type": "a * a⁻¹ = 1",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a : G) : a * a⁻¹ = 1 := by rw [← mul_left_inv a⁻¹]; sorry",
  "name": "mul_right_inv",
  "kind": "theorem",
  "first-tactic": "rw [← mul_left_inv a⁻¹]",
  "core-prompt": "{G : Type _}  [Group G]  {a b c : G} (a : G) : a * a⁻¹ = 1",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a : G)"},
 {"type": "a⁻¹ * (a * b) = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a⁻¹ * (a * b) = b := by rw [← mul_assoc]; sorry",
  "name": "inv_mul_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a⁻¹ * (a * b) = b",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "a * (a⁻¹ * b) = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a * (a⁻¹ * b) = b := by rw [← mul_assoc]; sorry",
  "name": "mul_inv_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a * (a⁻¹ * b) = b",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "a * b * b⁻¹ = a",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a * b * b⁻¹ = a := by rw [mul_assoc]; sorry",
  "name": "mul_inv_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a * b * b⁻¹ = a",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "a * b⁻¹ * b = a",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a * b⁻¹ * b = a := by rw [mul_assoc]; sorry",
  "name": "inv_mul_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a * b⁻¹ * b = a",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "Function.Injective (@Group.toDivInvMonoid G)",
  "tactic-prompt":
  "theorem {G : Type _} {G : Type _} : Function.Injective (@Group.toDivInvMonoid G) := by rintro ⟨⟩ ⟨⟩ ⟨⟩; sorry",
  "name": "Group.toDivInvMonoid_injective",
  "kind": "theorem",
  "first-tactic": "rintro ⟨⟩ ⟨⟩ ⟨⟩",
  "core-prompt":
  "{G : Type _} {G : Type _} : Function.Injective (@Group.toDivInvMonoid G)",
  "args": "{G : Type _} {G : Type _}"},
 {"type": "Function.Injective (@CommGroup.toGroup G)",
  "tactic-prompt":
  "theorem {G : Type _} {G : Type u} : Function.Injective (@CommGroup.toGroup G) := by rintro ⟨⟩ ⟨⟩ ⟨⟩; sorry",
  "name": "CommGroup.toGroup_injective",
  "kind": "theorem",
  "first-tactic": "rintro ⟨⟩ ⟨⟩ ⟨⟩",
  "core-prompt":
  "{G : Type _} {G : Type u} : Function.Injective (@CommGroup.toGroup G)",
  "args": "{G : Type _} {G : Type u}"},
 {"type": "SemiconjBy a (x * x') (y * y')",
  "tactic-prompt":
  "theorem [Semigroup S]  {a b x y z x' y' : S} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x * x') (y * y') := by unfold SemiconjBy; sorry",
  "name": "mul_right",
  "kind": "theorem",
  "first-tactic": "unfold SemiconjBy",
  "core-prompt":
  "[Semigroup S]  {a b x y z x' y' : S} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x * x') (y * y')",
  "args":
  "[Semigroup S]  {a b x y z x' y' : S} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y')"},
 {"type": "SemiconjBy (a * b) x z",
  "tactic-prompt":
  "theorem [Semigroup S]  {a b x y z x' y' : S} (ha : SemiconjBy a y z)  (hb : SemiconjBy b x y) : SemiconjBy (a * b) x z := by unfold SemiconjBy; sorry",
  "name": "mul_left",
  "kind": "theorem",
  "first-tactic": "unfold SemiconjBy",
  "core-prompt":
  "[Semigroup S]  {a b x y z x' y' : S} (ha : SemiconjBy a y z)  (hb : SemiconjBy b x y) : SemiconjBy (a * b) x z",
  "args":
  "[Semigroup S]  {a b x y z x' y' : S} (ha : SemiconjBy a y z)  (hb : SemiconjBy b x y)"},
 {"type": "SemiconjBy a 1 1",
  "tactic-prompt":
  "theorem [MulOneClass M] (a : M) : SemiconjBy a 1 1 := by rw [SemiconjBy]; sorry",
  "name": "one_right",
  "kind": "theorem",
  "first-tactic": "rw [SemiconjBy]",
  "core-prompt": "[MulOneClass M] (a : M) : SemiconjBy a 1 1",
  "args": "[MulOneClass M] (a : M)"},
 {"type": "SemiconjBy a (x ^ n) (y ^ n)",
  "tactic-prompt":
  "theorem [Monoid M] {a x y : M}  (h : SemiconjBy a x y)  (n : ℕ) : SemiconjBy a (x ^ n) (y ^ n) := by induction' n with n ih; sorry",
  "name": "pow_right",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "[Monoid M] {a x y : M}  (h : SemiconjBy a x y)  (n : ℕ) : SemiconjBy a (x ^ n) (y ^ n)",
  "args": "[Monoid M] {a x y : M}  (h : SemiconjBy a x y)  (n : ℕ)"},
 {"type": "SemiconjBy a x (a * x * a⁻¹)",
  "tactic-prompt":
  "theorem [Group G]  {a x y : G} (a x : G) : SemiconjBy a x (a * x * a⁻¹) := by unfold SemiconjBy; sorry",
  "name": "conj_mk",
  "kind": "theorem",
  "first-tactic": "unfold SemiconjBy",
  "core-prompt":
  "[Group G]  {a x y : G} (a x : G) : SemiconjBy a x (a * x * a⁻¹)",
  "args": "[Group G]  {a x y : G} (a x : G)"},
 {"type": "SemiconjBy (↑u) x (u * x * ↑u⁻¹)",
  "tactic-prompt":
  "theorem [Monoid M]  (u : Mˣ)  (x : M) : SemiconjBy (↑u) x (u * x * ↑u⁻¹) := by unfold SemiconjBy; sorry",
  "name": "Units.mk_semiconjBy",
  "kind": "theorem",
  "first-tactic": "unfold SemiconjBy",
  "core-prompt":
  "[Monoid M]  (u : Mˣ)  (x : M) : SemiconjBy (↑u) x (u * x * ↑u⁻¹)",
  "args": "[Monoid M]  (u : Mˣ)  (x : M)"},
 {"type":
  "Pairwise fun i j => ∀ (x : f i) (y : f j), Commute (mulSingle i x) (mulSingle j y)",
  "tactic-prompt":
  "theorem {ι α : Type _} {I : Type u}  -- The indexing type {f : I → Type v}  -- The family of types already equipped with instances (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, MulOneClass <| f i] : Pairwise fun i j => ∀ (x : f i) (y : f j), Commute (mulSingle i x) (mulSingle j y) := by intro i j hij x y; sorry",
  "name": "Pi.mulSingle_commute",
  "kind": "theorem",
  "first-tactic": "intro i j hij x y",
  "core-prompt":
  "{ι α : Type _} {I : Type u}  -- The indexing type {f : I → Type v}  -- The family of types already equipped with instances (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, MulOneClass <| f i] : Pairwise fun i j => ∀ (x : f i) (y : f j), Commute (mulSingle i x) (mulSingle j y)",
  "args":
  "{ι α : Type _} {I : Type u}  -- The indexing type {f : I → Type v}  -- The family of types already equipped with instances (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, MulOneClass <| f i]"},
 {"type": "Commute (mulSingle i (x i)) (mulSingle j (x j))",
  "tactic-prompt":
  "theorem {ι α : Type _} {I : Type u}  -- The indexing type {f : I → Type v}  -- The family of types already equipped with instances (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, MulOneClass <| f i]  (x : ∀ i, f i)  (i j : I) : Commute (mulSingle i (x i)) (mulSingle j (x j)) := by obtain rfl | hij := Decidable.eq_or_ne i j; sorry",
  "name": "Pi.mulSingle_apply_commute",
  "kind": "theorem",
  "first-tactic": "obtain rfl | hij := Decidable.eq_or_ne i j",
  "core-prompt":
  "{ι α : Type _} {I : Type u}  -- The indexing type {f : I → Type v}  -- The family of types already equipped with instances (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, MulOneClass <| f i]  (x : ∀ i, f i)  (i j : I) : Commute (mulSingle i (x i)) (mulSingle j (x j))",
  "args":
  "{ι α : Type _} {I : Type u}  -- The indexing type {f : I → Type v}  -- The family of types already equipped with instances (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, MulOneClass <| f i]  (x : ∀ i, f i)  (i j : I)"},
 {"type": "Function.update g i x = g / mulSingle i (g i) * mulSingle i x",
  "tactic-prompt":
  "theorem {ι α : Type _} {I : Type u}  -- The indexing type {f : I → Type v}  -- The family of types already equipped with instances (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, Group <| f i]  (g : ∀ i : I, f i)  (x : f i) : Function.update g i x = g / mulSingle i (g i) * mulSingle i x := by ext j; sorry",
  "name": "Pi.update_eq_div_mul_mulSingle",
  "kind": "theorem",
  "first-tactic": "ext j",
  "core-prompt":
  "{ι α : Type _} {I : Type u}  -- The indexing type {f : I → Type v}  -- The family of types already equipped with instances (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, Group <| f i]  (g : ∀ i : I, f i)  (x : f i) : Function.update g i x = g / mulSingle i (g i) * mulSingle i x",
  "args":
  "{ι α : Type _} {I : Type u}  -- The indexing type {f : I → Type v}  -- The family of types already equipped with instances (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, Group <| f i]  (g : ∀ i : I, f i)  (x : f i)"},
 {"type":
  "(mulSingle k u : I → M) * mulSingle l v = mulSingle m u * mulSingle n v ↔\n      k = m ∧ l = n ∨ u = v ∧ k = n ∧ l = m ∨ u * v = 1 ∧ k = l ∧ m = n",
  "tactic-prompt":
  "theorem {ι α : Type _} {I : Type u}  -- The indexing type {f : I → Type v}  -- The family of types already equipped with instances (x y : ∀ i, f i)  (i : I)  [DecidableEq I] {M : Type _}  [CommMonoid M]      {k l m n : I}  {u v : M}  (hu : u ≠ 1)  (hv : v ≠ 1) : (mulSingle k u : I → M) * mulSingle l v = mulSingle m u * mulSingle n v ↔\n      k = m ∧ l = n ∨ u = v ∧ k = n ∧ l = m ∨ u * v = 1 ∧ k = l ∧ m = n := by refine' ⟨fun h => _, _⟩; sorry",
  "name": "Pi.mulSingle_mul_mulSingle_eq_mulSingle_mul_mulSingle",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, _⟩",
  "core-prompt":
  "{ι α : Type _} {I : Type u}  -- The indexing type {f : I → Type v}  -- The family of types already equipped with instances (x y : ∀ i, f i)  (i : I)  [DecidableEq I] {M : Type _}  [CommMonoid M]      {k l m n : I}  {u v : M}  (hu : u ≠ 1)  (hv : v ≠ 1) : (mulSingle k u : I → M) * mulSingle l v = mulSingle m u * mulSingle n v ↔\n      k = m ∧ l = n ∨ u = v ∧ k = n ∧ l = m ∨ u * v = 1 ∧ k = l ∧ m = n",
  "args":
  "{ι α : Type _} {I : Type u}  -- The indexing type {f : I → Type v}  -- The family of types already equipped with instances (x y : ∀ i, f i)  (i : I)  [DecidableEq I] {M : Type _}  [CommMonoid M]      {k l m n : I}  {u v : M}  (hu : u ≠ 1)  (hv : v ≠ 1)"},
 {"type": "a * b * c = a * c * b",
  "tactic-prompt":
  "theorem {G : Type _}  {S : Type _}  [Semigroup S]  {a b c : S} (h : Commute b c)  (a : S) : a * b * c = a * c * b := by simp only [mul_assoc]; sorry",
  "name": "right_comm",
  "kind": "theorem",
  "first-tactic": "simp only [mul_assoc]",
  "core-prompt":
  "{G : Type _}  {S : Type _}  [Semigroup S]  {a b c : S} (h : Commute b c)  (a : S) : a * b * c = a * c * b",
  "args":
  "{G : Type _}  {S : Type _}  [Semigroup S]  {a b c : S} (h : Commute b c)  (a : S)"},
 {"type": "a⁻¹ * b * a = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b : G} (h : Commute a b) : a⁻¹ * b * a = b := by rw [h.inv_left.eq]; sorry",
  "name": "inv_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rw [h.inv_left.eq]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b : G} (h : Commute a b) : a⁻¹ * b * a = b",
  "args": "{G : Type _}  [Group G]  {a b : G} (h : Commute a b)"},
 {"type": "a⁻¹ * (b * a) = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b : G} (h : Commute a b) : a⁻¹ * (b * a) = b := by rw [← mul_assoc]; sorry",
  "name": "inv_mul_cancel_assoc",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b : G} (h : Commute a b) : a⁻¹ * (b * a) = b",
  "args": "{G : Type _}  [Group G]  {a b : G} (h : Commute a b)"},
 {"type": "a * b * a⁻¹ = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b : G} (h : Commute a b) : a * b * a⁻¹ = b := by rw [h.eq]; sorry",
  "name": "mul_inv_cancel",
  "kind": "theorem",
  "first-tactic": "rw [h.eq]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b : G} (h : Commute a b) : a * b * a⁻¹ = b",
  "args": "{G : Type _}  [Group G]  {a b : G} (h : Commute a b)"},
 {"type": "a * (b * a⁻¹) = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b : G} (h : Commute a b) : a * (b * a⁻¹) = b := by rw [← mul_assoc]; sorry",
  "name": "mul_inv_cancel_assoc",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b : G} (h : Commute a b) : a * (b * a⁻¹) = b",
  "args": "{G : Type _}  [Group G]  {a b : G} (h : Commute a b)"},
 {"type": "(x * ·) ∘ (y * ·) = (x * y * ·)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Semigroup α]  (x y : α) : (x * ·) ∘ (y * ·) = (x * y * ·) := by ext z; sorry",
  "name": "comp_mul_left",
  "kind": "theorem",
  "first-tactic": "ext z",
  "core-prompt":
  "{α β G : Type _}  [Semigroup α]  (x y : α) : (x * ·) ∘ (y * ·) = (x * y * ·)",
  "args": "{α β G : Type _}  [Semigroup α]  (x y : α)"},
 {"type": "(· * x) ∘ (· * y) = (· * (y * x))",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Semigroup α]  (x y : α) : (· * x) ∘ (· * y) = (· * (y * x)) := by ext z; sorry",
  "name": "comp_mul_right",
  "kind": "theorem",
  "first-tactic": "ext z",
  "core-prompt":
  "{α β G : Type _}  [Semigroup α]  (x y : α) : (· * x) ∘ (· * y) = (· * (y * x))",
  "args": "{α β G : Type _}  [Semigroup α]  (x y : α)"},
 {"type": "ite P (a * b) 1 = ite P a 1 * ite P b 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P (a * b) 1 = ite P a 1 * ite P b 1 := by by_cases h:P; sorry",
  "name": "ite_mul_one",
  "kind": "theorem",
  "first-tactic": "by_cases h:P",
  "core-prompt":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P (a * b) 1 = ite P a 1 * ite P b 1",
  "args":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M}"},
 {"type": "ite P 1 (a * b) = ite P 1 a * ite P 1 b",
  "tactic-prompt":
  "theorem {α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P 1 (a * b) = ite P 1 a * ite P 1 b := by by_cases h:P; sorry",
  "name": "ite_one_mul",
  "kind": "theorem",
  "first-tactic": "by_cases h:P",
  "core-prompt":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P 1 (a * b) = ite P 1 a * ite P 1 b",
  "args":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M}"},
 {"type": "a = 1 ↔ b = 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  {M : Type u}  [MulOneClass M] {a b : M}  (h : a * b = 1) : a = 1 ↔ b = 1 := by constructor; sorry",
  "name": "eq_one_iff_eq_one_of_mul_eq_one",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {a b : M}  (h : a * b = 1) : a = 1 ↔ b = 1",
  "args":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {a b : M}  (h : a * b = 1)"},
 {"type": "a * b * (c * d) = a * c * (b * d)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommSemigroup G] (a b c d : G) : a * b * (c * d) = a * c * (b * d) := by simp only [mul_left_comm]; sorry",
  "name": "mul_mul_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp only [mul_left_comm]",
  "core-prompt":
  "{α β G : Type _}  [CommSemigroup G] (a b c d : G) : a * b * (c * d) = a * c * (b * d)",
  "args": "{α β G : Type _}  [CommSemigroup G] (a b c d : G)"},
 {"type": "a * b * c = b * c * a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommSemigroup G] (a b c : G) : a * b * c = b * c * a := by simp only [mul_left_comm]; sorry",
  "name": "mul_rotate",
  "kind": "theorem",
  "first-tactic": "simp only [mul_left_comm]",
  "core-prompt":
  "{α β G : Type _}  [CommSemigroup G] (a b c : G) : a * b * c = b * c * a",
  "args": "{α β G : Type _}  [CommSemigroup G] (a b c : G)"},
 {"type": "a * (b * c) = b * (c * a)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommSemigroup G] (a b c : G) : a * (b * c) = b * (c * a) := by simp only [mul_left_comm]; sorry",
  "name": "mul_rotate'",
  "kind": "theorem",
  "first-tactic": "simp only [mul_left_comm]",
  "core-prompt":
  "{α β G : Type _}  [CommSemigroup G] (a b c : G) : a * (b * c) = b * (c * a)",
  "args": "{α β G : Type _}  [CommSemigroup G] (a b c : G)"},
 {"type": "bit1 (a + b) = bit1 a + bit0 b",
  "tactic-prompt":
  "theorem {α β G : Type _}  {M : Type u}  [AddCommSemigroup M] [One M]  (a b : M) : bit1 (a + b) = bit1 a + bit0 b := by rw [add_comm]; sorry",
  "name": "bit1_add'",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{α β G : Type _}  {M : Type u}  [AddCommSemigroup M] [One M]  (a b : M) : bit1 (a + b) = bit1 a + bit0 b",
  "args":
  "{α β G : Type _}  {M : Type u}  [AddCommSemigroup M] [One M]  (a b : M)"},
 {"type": "bit1 (0 : M) = 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  {M : Type u}  [AddMonoid M]  {a b c : M} [One M] : bit1 (0 : M) = 1 := by rw [bit1]; sorry",
  "name": "bit1_zero",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "{α β G : Type _}  {M : Type u}  [AddMonoid M]  {a b c : M} [One M] : bit1 (0 : M) = 1",
  "args": "{α β G : Type _}  {M : Type u}  [AddMonoid M]  {a b c : M} [One M]"},
 {"type": "b = a⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [InvolutiveInv G]  {a b : G} (h : a = b⁻¹) : b = a⁻¹ := by simp [h]; sorry",
  "name": "eq_inv_of_eq_inv",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [InvolutiveInv G]  {a b : G} (h : a = b⁻¹) : b = a⁻¹",
  "args": "{α β G : Type _}  [InvolutiveInv G]  {a b : G} (h : a = b⁻¹)"},
 {"type": "x⁻¹ = 1 / x",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x : G) : x⁻¹ = 1 / x := by rw [div_eq_mul_inv]; sorry",
  "name": "inv_eq_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x : G) : x⁻¹ = 1 / x",
  "args": "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x : G)"},
 {"type": "x * (1 / y) = x / y",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x y : G) : x * (1 / y) = x / y := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x y : G) : x * (1 / y) = x / y",
  "args": "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x y : G)"},
 {"type": "a * b / c = a * (b / c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * b / c = a * (b / c) := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_div_assoc",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * b / c = a * (b / c)",
  "args": "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G)"},
 {"type": "a * (b / c) = a * b / c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * (b / c) = a * b / c := by simp only [mul_assoc]; sorry",
  "name": "mul_div",
  "kind": "theorem",
  "first-tactic": "simp only [mul_assoc]",
  "core-prompt":
  "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * (b / c) = a * b / c",
  "args": "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G)"},
 {"type": "a / b = a * (1 / b)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b : G) : a / b = a * (1 / b) := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_mul_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b : G) : a / b = a * (1 / b)",
  "args": "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b : G)"},
 {"type": "a / 1 = a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvOneMonoid G] (a : G) : a / 1 = a := by simp [div_eq_mul_inv]; sorry",
  "name": "div_one",
  "kind": "theorem",
  "first-tactic": "simp [div_eq_mul_inv]",
  "core-prompt": "{α β G : Type _}  [DivInvOneMonoid G] (a : G) : a / 1 = a",
  "args": "{α β G : Type _}  [DivInvOneMonoid G] (a : G)"},
 {"type": "b⁻¹ = a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1) : b⁻¹ = a := by rw [← inv_eq_of_mul_eq_one_right h]; sorry",
  "name": "inv_eq_of_mul_eq_one_left",
  "kind": "theorem",
  "first-tactic": "rw [← inv_eq_of_mul_eq_one_right h]",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1) : b⁻¹ = a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1)"},
 {"type": "b = 1 / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : b * a = 1) : b = 1 / a := by rw [eq_inv_of_mul_eq_one_left h]; sorry",
  "name": "eq_one_div_of_mul_eq_one_left",
  "kind": "theorem",
  "first-tactic": "rw [eq_inv_of_mul_eq_one_left h]",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : b * a = 1) : b = 1 / a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : b * a = 1)"},
 {"type": "b = 1 / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1) : b = 1 / a := by rw [eq_inv_of_mul_eq_one_right h]; sorry",
  "name": "eq_one_div_of_mul_eq_one_right",
  "kind": "theorem",
  "first-tactic": "rw [eq_inv_of_mul_eq_one_right h]",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1) : b = 1 / a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1)"},
 {"type": "1 / a * (1 / b) = 1 / (b * a)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / a * (1 / b) = 1 / (b * a) := by simp; sorry",
  "name": "one_div_mul_one_div_rev",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / a * (1 / b) = 1 / (b * a)",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "a⁻¹ / b = (b * a)⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a⁻¹ / b = (b * a)⁻¹ := by simp; sorry",
  "name": "inv_div_left",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a⁻¹ / b = (b * a)⁻¹",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "(a / b)⁻¹ = b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : (a / b)⁻¹ = b / a := by simp; sorry",
  "name": "inv_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : (a / b)⁻¹ = b / a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "1 / (a / b) = b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / (a / b) = b / a := by simp; sorry",
  "name": "one_div_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / (a / b) = b / a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "1 / (1 / a) = a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / (1 / a) = a := by simp; sorry",
  "name": "one_div_one_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / (1 / a) = a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : 1 / a = 1 / b) : a = b := by rw [← one_div_one_div a]; sorry",
  "name": "eq_of_one_div_eq_one_div",
  "kind": "theorem",
  "first-tactic": "rw [← one_div_one_div a]",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : 1 / a = 1 / b) : a = b",
  "args":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : 1 / a = 1 / b)"},
 {"type": "a / (b / c) = a * c / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / (b / c) = a * c / b := by simp; sorry",
  "name": "div_div_eq_mul_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / (b / c) = a * c / b",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "a / b⁻¹ = a * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / b⁻¹ = a * b := by simp; sorry",
  "name": "div_inv_eq_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / b⁻¹ = a * b",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "a / (b * c) = a / c / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / (b * c) = a / c / b := by simp only [mul_assoc]; sorry",
  "name": "div_mul_eq_div_div_swap",
  "kind": "theorem",
  "first-tactic": "simp only [mul_assoc]",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / (b * c) = a / c / b",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "(a * b)⁻¹ = a⁻¹ * b⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a * b)⁻¹ = a⁻¹ * b⁻¹ := by simp; sorry",
  "name": "mul_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a * b)⁻¹ = a⁻¹ * b⁻¹",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "(a / b)⁻¹ = a⁻¹ / b⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a / b)⁻¹ = a⁻¹ / b⁻¹ := by simp; sorry",
  "name": "inv_div'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a / b)⁻¹ = a⁻¹ / b⁻¹",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b = b⁻¹ * a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b = b⁻¹ * a := by simp; sorry",
  "name": "div_eq_inv_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b = b⁻¹ * a",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a⁻¹ * b = b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a⁻¹ * b = b / a := by simp; sorry",
  "name": "inv_mul_eq_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a⁻¹ * b = b / a",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "(a * b)⁻¹ = a⁻¹ / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a * b)⁻¹ = a⁻¹ / b := by simp; sorry",
  "name": "inv_mul'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a * b)⁻¹ = a⁻¹ / b",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a⁻¹ / b⁻¹ = b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a⁻¹ / b⁻¹ = b / a := by simp; sorry",
  "name": "inv_div_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a⁻¹ / b⁻¹ = b / a",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "(a⁻¹ / b⁻¹)⁻¹ = a / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a⁻¹ / b⁻¹)⁻¹ = a / b := by simp; sorry",
  "name": "inv_inv_div_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a⁻¹ / b⁻¹)⁻¹ = a / b",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "1 / a * (1 / b) = 1 / (a * b)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : 1 / a * (1 / b) = 1 / (a * b) := by simp; sorry",
  "name": "one_div_mul_one_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : 1 / a * (1 / b) = 1 / (a * b)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b / c = a / c / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / c = a / c / b := by simp; sorry",
  "name": "div_right_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / c = a / c / b",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b / c = a / (b * c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / c = a / (b * c) := by simp; sorry",
  "name": "div_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / c = a / (b * c)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b * c = a / (b / c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a / (b / c) := by simp; sorry",
  "name": "div_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a / (b / c)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a * (b / c) = b * (a / c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * (b / c) = b * (a / c) := by simp; sorry",
  "name": "mul_div_left_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * (b / c) = b * (a / c)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a * b / c = a / c * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * b / c = a / c * b := by simp; sorry",
  "name": "mul_div_right_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * b / c = a / c * b",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / (b * c) = a / b / c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / (b * c) = a / b / c := by simp; sorry",
  "name": "div_mul_eq_div_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / (b * c) = a / b / c",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b * c = a * c / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a * c / b := by simp; sorry",
  "name": "div_mul_eq_mul_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a * c / b",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b * c = a * (c / b)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a * (c / b) := by simp; sorry",
  "name": "mul_comm_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a * (c / b)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b * c = c / b * a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = c / b * a := by simp; sorry",
  "name": "div_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = c / b * a",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / (b * c) = a / b * (1 / c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / (b * c) = a / b * (1 / c) := by simp; sorry",
  "name": "div_mul_eq_div_mul_one_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / (b * c) = a / b * (1 / c)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b / (c / d) = a * d / (b * c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / (c / d) = a * d / (b * c) := by simp; sorry",
  "name": "div_div_div_eq",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / (c / d) = a * d / (b * c)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b / (c / d) = a / c / (b / d)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / (c / d) = a / c / (b / d) := by simp; sorry",
  "name": "div_div_div_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / (c / d) = a / c / (b / d)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b * (c / d) = a * c / (b * d)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * (c / d) = a * c / (b * d) := by simp; sorry",
  "name": "div_mul_div_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * (c / d) = a * c / (b * d)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a * b / (c * d) = a / c * (b / d)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * b / (c * d) = a / c * (b / d) := by simp; sorry",
  "name": "mul_div_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * b / (c * d) = a / c * (b / d)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b = b⁻¹ ↔ a = 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a / b = b⁻¹ ↔ a = 1 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_inv_self",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a / b = b⁻¹ ↔ a = 1",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a = b * c⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b * c⁻¹ := by simp [h.symm]; sorry",
  "name": "eq_mul_inv_of_mul_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b * c⁻¹",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b)"},
 {"type": "a = b⁻¹ * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : b * a = c) : a = b⁻¹ * c := by simp [h.symm]; sorry",
  "name": "eq_inv_mul_of_mul_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : b * a = c) : a = b⁻¹ * c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : b * a = c)"},
 {"type": "a⁻¹ * b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : b = a * c) : a⁻¹ * b = c := by simp [h]; sorry",
  "name": "inv_mul_eq_of_eq_mul",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : b = a * c) : a⁻¹ * b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : b = a * c)"},
 {"type": "a * b⁻¹ = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a * b⁻¹ = c := by simp [h]; sorry",
  "name": "mul_inv_eq_of_eq_mul",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a * b⁻¹ = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a * c⁻¹ = b) : a = b * c := by simp [h.symm]; sorry",
  "name": "eq_mul_of_mul_inv_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c⁻¹ = b) : a = b * c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c⁻¹ = b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : b⁻¹ * a = c) : a = b * c := by simp [h.symm]; sorry",
  "name": "eq_mul_of_inv_mul_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : b⁻¹ * a = c) : a = b * c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : b⁻¹ * a = c)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : b = a⁻¹ * c) : a * b = c := by rw [h]; sorry",
  "name": "mul_eq_of_eq_inv_mul",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : b = a⁻¹ * c) : a * b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : b = a⁻¹ * c)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b⁻¹) : a * b = c := by simp [h]; sorry",
  "name": "mul_eq_of_eq_mul_inv",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b⁻¹) : a * b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b⁻¹)"},
 {"type": "a * b = 1 ↔ a⁻¹ = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a * b = 1 ↔ a⁻¹ = b := by rw [mul_eq_one_iff_eq_inv]; sorry",
  "name": "mul_eq_one_iff_inv_eq",
  "kind": "theorem",
  "first-tactic": "rw [mul_eq_one_iff_eq_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a * b = 1 ↔ a⁻¹ = b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a * b⁻¹ = 1 ↔ a = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a * b⁻¹ = 1 ↔ a = b := by rw [mul_eq_one_iff_eq_inv]; sorry",
  "name": "mul_inv_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [mul_eq_one_iff_eq_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a * b⁻¹ = 1 ↔ a = b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a⁻¹ * b = 1 ↔ a = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a⁻¹ * b = 1 ↔ a = b := by rw [mul_eq_one_iff_eq_inv]; sorry",
  "name": "inv_mul_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [mul_eq_one_iff_eq_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a⁻¹ * b = 1 ↔ a = b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "Function.Injective fun a ↦ a / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : Function.Injective fun a ↦ a / b := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_left_injective",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : Function.Injective fun a ↦ a / b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "Function.Injective fun a ↦ b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : Function.Injective fun a ↦ b / a := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_right_injective",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : Function.Injective fun a ↦ b / a",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a / b * b = a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a b : G) : a / b * b = a := by rw [div_eq_mul_inv]; sorry",
  "name": "div_mul_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a b : G) : a / b * b = a",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a b : G)"},
 {"type": "a / a = 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a : G) : a / a = 1 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_self'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a : G) : a / a = 1",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a : G)"},
 {"type": "a * b / b = a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a b : G) : a * b / b = a := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_div_cancel''",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a b : G) : a * b / b = a",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a b : G)"},
 {"type": "a * c / (b * c) = a / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a * c / (b * c) = a / b := by rw [div_mul_eq_div_div_swap]; sorry",
  "name": "mul_div_mul_right_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [div_mul_eq_div_div_swap]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a * c / (b * c) = a / b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G)"},
 {"type": "a = b / c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b / c := by simp [← h]; sorry",
  "name": "eq_div_of_mul_eq'",
  "kind": "theorem",
  "first-tactic": "simp [← h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b / c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b)"},
 {"type": "a / b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a / b = c := by simp [h]; sorry",
  "name": "div_eq_of_eq_mul''",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a / b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a / c = b) : a = b * c := by simp [← h]; sorry",
  "name": "eq_mul_of_div_eq",
  "kind": "theorem",
  "first-tactic": "simp [← h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a / c = b) : a = b * c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a / c = b)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a = c / b) : a * b = c := by simp [h]; sorry",
  "name": "mul_eq_of_eq_div",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c / b) : a * b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c / b)"},
 {"type": "b / a = c / a ↔ b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : b / a = c / a ↔ b = c := by rw [div_eq_mul_inv]; sorry",
  "name": "div_left_inj",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : b / a = c / a ↔ b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a / b * (b / c) = a / c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / b * (b / c) = a / c := by rw [← mul_div_assoc]; sorry",
  "name": "div_mul_div_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [← mul_div_assoc]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / b * (b / c) = a / c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G)"},
 {"type": "a / c / (b / c) = a / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / c / (b / c) = a / b := by rw [← inv_div c b]; sorry",
  "name": "div_div_div_cancel_right'",
  "kind": "theorem",
  "first-tactic": "rw [← inv_div c b]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / c / (b / c) = a / b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b = a ↔ b = 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a / b = a ↔ b = 1 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_self",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a / b = a ↔ b = 1",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a = b / c ↔ a * c = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a = b / c ↔ a * c = b := by rw [div_eq_mul_inv]; sorry",
  "name": "eq_div_iff_mul_eq'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a = b / c ↔ a * c = b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a / b = c ↔ a = c * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a / b = c ↔ a = c * b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_iff_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a / b = c ↔ a = c * b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a = b ↔ c = d",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (H : a / b = c / d) : a = b ↔ c = d := by rw [← div_eq_one]; sorry",
  "name": "eq_iff_eq_of_div_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [← div_eq_one]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (H : a / b = c / d) : a = b ↔ c = d",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (H : a / b = c / d)"},
 {"type": "∃ n : ℕ, 0 < n ∧ x ^ n = 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} {n : ℤ}  (hn : n ≠ 0)  {x : G}  (h : x ^ n = 1) : ∃ n : ℕ, 0 < n ∧ x ^ n = 1 := by cases' n with n n; sorry",
  "name": "exists_npow_eq_one_of_zpow_eq_one",
  "kind": "theorem",
  "first-tactic": "cases' n with n n",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} {n : ℤ}  (hn : n ≠ 0)  {x : G}  (h : x ^ n = 1) : ∃ n : ℕ, 0 < n ∧ x ^ n = 1",
  "args":
  "{α β G : Type _}  [Group G]  {a b c d : G} {n : ℤ}  (hn : n ≠ 0)  {x : G}  (h : x ^ n = 1)"},
 {"type": "a / b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} {a b c : G}  (h : a = b * c) : a / b = c := by rw [h]; sorry",
  "name": "div_eq_of_eq_mul'",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} {a b c : G}  (h : a = b * c) : a / b = c",
  "args":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} {a b c : G}  (h : a = b * c)"},
 {"type": "c * a / (c * b) = a / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c * a / (c * b) = a / b := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_div_mul_left_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c * a / (c * b) = a / b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a = b / c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (h : c * a = b) : a = b / c := by simp [h.symm]; sorry",
  "name": "eq_div_of_mul_eq''",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : c * a = b) : a = b / c",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : c * a = b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (h : a / b = c) : a = b * c := by simp [h.symm]; sorry",
  "name": "eq_mul_of_div_eq'",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : a / b = c) : a = b * c",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : a / b = c)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (h : b = c / a) : a * b = c := by simp [h]; sorry",
  "name": "mul_eq_of_eq_div'",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : b = c / a) : a * b = c",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : b = c / a)"},
 {"type": "a / (a / b) = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a / b) = b := by simpa using mul_inv_cancel_left a b; sorry",
  "name": "div_div_self'",
  "kind": "theorem",
  "first-tactic": "simpa using mul_inv_cancel_left a b",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a / b) = b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a / b = c / b * (a / c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b = c / b * (a / c) := by simp [mul_left_comm c]; sorry",
  "name": "div_eq_div_mul_div",
  "kind": "theorem",
  "first-tactic": "simp [mul_left_comm c]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b = c / b * (a / c)",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b / a = b⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / b / a = b⁻¹ := by simp; sorry",
  "name": "div_div_cancel_left",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / b / a = b⁻¹",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a = b / c ↔ c * a = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} : a = b / c ↔ c * a = b := by rw [eq_div_iff_mul_eq']; sorry",
  "name": "eq_div_iff_mul_eq''",
  "kind": "theorem",
  "first-tactic": "rw [eq_div_iff_mul_eq']",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} : a = b / c ↔ c * a = b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "a / b = c ↔ a = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c ↔ a = b * c := by rw [div_eq_iff_eq_mul]; sorry",
  "name": "div_eq_iff_eq_mul'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_iff_eq_mul]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c ↔ a = b * c",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "a * b / a = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * b / a = b := by rw [div_eq_inv_mul]; sorry",
  "name": "mul_div_cancel'''",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_inv_mul]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * b / a = b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a * (b / a) = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b / a) = b := by rw [← mul_div_assoc]; sorry",
  "name": "mul_div_cancel'_right",
  "kind": "theorem",
  "first-tactic": "rw [← mul_div_assoc]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b / a) = b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a / (a * b) = b⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a * b) = b⁻¹ := by rw [← inv_div]; sorry",
  "name": "div_mul_cancel''",
  "kind": "theorem",
  "first-tactic": "rw [← inv_div]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a * b) = b⁻¹",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a * (b * a⁻¹) = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b * a⁻¹) = b := by rw [← div_eq_mul_inv]; sorry",
  "name": "mul_mul_inv_cancel'_right",
  "kind": "theorem",
  "first-tactic": "rw [← div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b * a⁻¹) = b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a * c * (b / c) = a * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * c * (b / c) = a * b := by rw [mul_assoc]; sorry",
  "name": "mul_mul_div_cancel",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * c * (b / c) = a * b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / c * (b * c) = a * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / c * (b * c) = a * b := by rw [mul_left_comm]; sorry",
  "name": "div_mul_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rw [mul_left_comm]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / c * (b * c) = a * b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b * (c / a) = c / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b * (c / a) = c / b := by rw [mul_comm]; sorry",
  "name": "div_mul_div_cancel''",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b * (c / a) = c / b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a * b / (a / c) = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * b / (a / c) = b * c := by rw [← div_mul]; sorry",
  "name": "mul_div_div_cancel",
  "kind": "theorem",
  "first-tactic": "rw [← div_mul]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * b / (a / c) = b * c",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "c / a / (c / b) = b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c / a / (c / b) = b / a := by rw [← inv_div b c]; sorry",
  "name": "div_div_div_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← inv_div b c]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c / a / (c / b) = b / a",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b = c / d ↔ a * d = c * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d ↔ a * d = c * b := by rw [div_eq_iff_eq_mul]; sorry",
  "name": "div_eq_div_iff_mul_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_iff_eq_mul]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d ↔ a * d = c * b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "a / b = c / d ↔ a / c = b / d",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d ↔ a / c = b / d := by rw [div_eq_iff_eq_mul]; sorry",
  "name": "div_eq_div_iff_div_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_iff_eq_mul]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d ↔ a / c = b / d",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "(a : α) = 1 ↔ a = 1",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} {a : αˣ} : (a : α) = 1 ↔ a = 1 := by rw [← Units.val_one]; sorry",
  "name": "val_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [← Units.val_one]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} {a : αˣ} : (a : α) = 1 ↔ a = 1",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} {a : αˣ}"},
 {"type": "↑u⁻¹ * a = 1",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} {a : α}  (h : ↑u = a) : ↑u⁻¹ * a = 1 := by rw [← h]; sorry",
  "name": "inv_mul_of_eq",
  "kind": "theorem",
  "first-tactic": "rw [← h]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} {a : α}  (h : ↑u = a) : ↑u⁻¹ * a = 1",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} {a : α}  (h : ↑u = a)"},
 {"type": "a * ↑u⁻¹ = 1",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} {a : α}  (h : ↑u = a) : a * ↑u⁻¹ = 1 := by rw [← h]; sorry",
  "name": "mul_inv_of_eq",
  "kind": "theorem",
  "first-tactic": "rw [← h]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} {a : α}  (h : ↑u = a) : a * ↑u⁻¹ = 1",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} {a : α}  (h : ↑u = a)"},
 {"type": "(a : α) * (↑a⁻¹ * b) = b",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} (a : αˣ)  (b : α) : (a : α) * (↑a⁻¹ * b) = b := by rw [← mul_assoc]; sorry",
  "name": "mul_inv_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} (a : αˣ)  (b : α) : (a : α) * (↑a⁻¹ * b) = b",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} (a : αˣ)  (b : α)"},
 {"type": "(↑a⁻¹ : α) * (a * b) = b",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} (a : αˣ)  (b : α) : (↑a⁻¹ : α) * (a * b) = b := by rw [← mul_assoc]; sorry",
  "name": "inv_mul_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} (a : αˣ)  (b : α) : (↑a⁻¹ : α) * (a * b) = b",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} (a : αˣ)  (b : α)"},
 {"type": "a * b * ↑b⁻¹ = a",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} (a : α)  (b : αˣ) : a * b * ↑b⁻¹ = a := by rw [mul_assoc]; sorry",
  "name": "mul_inv_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} (a : α)  (b : αˣ) : a * b * ↑b⁻¹ = a",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} (a : α)  (b : αˣ)"},
 {"type": "a * ↑b⁻¹ * b = a",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} (a : α)  (b : αˣ) : a * ↑b⁻¹ * b = a := by rw [mul_assoc]; sorry",
  "name": "inv_mul_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} (a : α)  (b : αˣ) : a * ↑b⁻¹ * b = a",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} (a : α)  (b : αˣ)"},
 {"type": "a * u = 1 ↔ a = ↑u⁻¹",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} {a : α} : a * u = 1 ↔ a = ↑u⁻¹ := by rw [← mul_inv_eq_one]; sorry",
  "name": "mul_eq_one_iff_eq_inv",
  "kind": "theorem",
  "first-tactic": "rw [← mul_inv_eq_one]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} {a : α} : a * u = 1 ↔ a = ↑u⁻¹",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} {a : α}"},
 {"type": "↑u * a = 1 ↔ ↑u⁻¹ = a",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} {a : α} : ↑u * a = 1 ↔ ↑u⁻¹ = a := by rw [← inv_mul_eq_one]; sorry",
  "name": "mul_eq_one_iff_inv_eq",
  "kind": "theorem",
  "first-tactic": "rw [← inv_mul_eq_one]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} {a : α} : ↑u * a = 1 ↔ ↑u⁻¹ = a",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ} {a : α}"},
 {"type": "x /ₚ u₁ /ₚ u₂ = x /ₚ (u₂ * u₁)",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [Monoid α]  {a b c : α} (x : α)  (u₁ u₂ : αˣ) : x /ₚ u₁ /ₚ u₂ = x /ₚ (u₂ * u₁) := by simp only [divp]; sorry",
  "name": "divp_divp_eq_divp_mul",
  "kind": "theorem",
  "first-tactic": "simp only [divp]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [Monoid α]  {a b c : α} (x : α)  (u₁ u₂ : αˣ) : x /ₚ u₁ /ₚ u₂ = x /ₚ (u₂ * u₁)",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [Monoid α]  {a b c : α} (x : α)  (u₁ u₂ : αˣ)"},
 {"type": "x = y /ₚ u ↔ x * u = y",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [Monoid α]  {a b c : α} {x : α}  {u : αˣ}  {y : α} : x = y /ₚ u ↔ x * u = y := by rw [eq_comm]; sorry",
  "name": "eq_divp_iff_mul_eq",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [Monoid α]  {a b c : α} {x : α}  {u : αˣ}  {y : α} : x = y /ₚ u ↔ x * u = y",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [Monoid α]  {a b c : α} {x : α}  {u : αˣ}  {y : α}"},
 {"type": "↑u⁻¹ = 1 /ₚ u",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [Monoid α]  {a b c : α} (u : αˣ) : ↑u⁻¹ = 1 /ₚ u := by rw [one_divp]; sorry",
  "name": "inv_eq_one_divp",
  "kind": "theorem",
  "first-tactic": "rw [one_divp]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [Monoid α]  {a b c : α} (u : αˣ) : ↑u⁻¹ = 1 /ₚ u",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [Monoid α]  {a b c : α} (u : αˣ)"},
 {"type": "((1 / u : αˣ) : α) = 1 /ₚ u",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [Monoid α]  {a b c : α} (u : αˣ) : ((1 / u : αˣ) : α) = 1 /ₚ u := by rw [one_div]; sorry",
  "name": "inv_eq_one_divp'",
  "kind": "theorem",
  "first-tactic": "rw [one_div]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [Monoid α]  {a b c : α} (u : αˣ) : ((1 / u : αˣ) : α) = 1 /ₚ u",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [Monoid α]  {a b c : α} (u : αˣ)"},
 {"type": "↑(u₁ / u₂) = ↑u₁ /ₚ u₂",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [Monoid α]  {a b c : α} (u₁ u₂ : αˣ) : ↑(u₁ / u₂) = ↑u₁ /ₚ u₂ := by rw [divp]; sorry",
  "name": "val_div_eq_divp",
  "kind": "theorem",
  "first-tactic": "rw [divp]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [Monoid α]  {a b c : α} (u₁ u₂ : αˣ) : ↑(u₁ / u₂) = ↑u₁ /ₚ u₂",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [Monoid α]  {a b c : α} (u₁ u₂ : αˣ)"},
 {"type": "x /ₚ u * y = x * y /ₚ u",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [CommMonoid α] (x y : α)  (u : αˣ) : x /ₚ u * y = x * y /ₚ u := by rw [divp]; sorry",
  "name": "divp_mul_eq_mul_divp",
  "kind": "theorem",
  "first-tactic": "rw [divp]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [CommMonoid α] (x y : α)  (u : αˣ) : x /ₚ u * y = x * y /ₚ u",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [CommMonoid α] (x y : α)  (u : αˣ)"},
 {"type": "x /ₚ ux = y /ₚ uy ↔ x * uy = y * ux",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [CommMonoid α] {x y : α}  {ux uy : αˣ} : x /ₚ ux = y /ₚ uy ↔ x * uy = y * ux := by rw [divp_eq_iff_mul_eq]; sorry",
  "name": "divp_eq_divp_iff",
  "kind": "theorem",
  "first-tactic": "rw [divp_eq_iff_mul_eq]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [CommMonoid α] {x y : α}  {ux uy : αˣ} : x /ₚ ux = y /ₚ uy ↔ x * uy = y * ux",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [CommMonoid α] {x y : α}  {ux uy : αˣ}"},
 {"type": "x /ₚ ux * (y /ₚ uy) = x * y /ₚ (ux * uy)",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [CommMonoid α] (x y : α)  (ux uy : αˣ) : x /ₚ ux * (y /ₚ uy) = x * y /ₚ (ux * uy) := by rw [divp_mul_eq_mul_divp]; sorry",
  "name": "divp_mul_divp",
  "kind": "theorem",
  "first-tactic": "rw [divp_mul_eq_mul_divp]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [CommMonoid α] (x y : α)  (ux uy : αˣ) : x /ₚ ux * (y /ₚ uy) = x * y /ₚ (ux * uy)",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  [CommMonoid α] (x y : α)  (ux uy : αˣ)"},
 {"type": "∃ b, a * b = 1",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [Monoid M]  {a : M}  (h : IsUnit a) : ∃ b, a * b = 1 := by rcases h with ⟨⟨a, b, hab, _⟩, rfl⟩; sorry",
  "name": "IsUnit.exists_right_inv",
  "kind": "theorem",
  "first-tactic": "rcases h with ⟨⟨a, b, hab, _⟩, rfl⟩",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [Monoid M]  {a : M}  (h : IsUnit a) : ∃ b, a * b = 1",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [Monoid M]  {a : M}  (h : IsUnit a)"},
 {"type": "∃ b, b * a = 1",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [Monoid M]  {a : M}  (h : IsUnit a) : ∃ b, b * a = 1 := by rcases h with ⟨⟨a, b, _, hba⟩, rfl⟩; sorry",
  "name": "IsUnit.exists_left_inv",
  "kind": "theorem",
  "first-tactic": "rcases h with ⟨⟨a, b, _, hba⟩, rfl⟩",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [Monoid M]  {a : M}  (h : IsUnit a) : ∃ b, b * a = 1",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [Monoid M]  {a : M}  (h : IsUnit a)"},
 {"type": "IsUnit a ↔ ∃ b, b * a = 1",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [CommMonoid M]  {a : M} : IsUnit a ↔ ∃ b, b * a = 1 := by rw [isUnit_iff_exists_inv]; sorry",
  "name": "isUnit_iff_exists_inv'",
  "kind": "theorem",
  "first-tactic": "rw [isUnit_iff_exists_inv]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [CommMonoid M]  {a : M} : IsUnit a ↔ ∃ b, b * a = 1",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [CommMonoid M]  {a : M}"},
 {"type": "IsUnit x → IsUnit y → IsUnit (x * y)",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [Monoid M]  {x y : M} : IsUnit x → IsUnit y → IsUnit (x * y) := by rintro ⟨x, rfl⟩ ⟨y, rfl⟩; sorry",
  "name": "IsUnit.mul",
  "kind": "theorem",
  "first-tactic": "rintro ⟨x, rfl⟩ ⟨y, rfl⟩",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [Monoid M]  {x y : M} : IsUnit x → IsUnit y → IsUnit (x * y)",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [Monoid M]  {x y : M}"},
 {"type": "a * ↑h.unit⁻¹ = 1",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _}  [Monoid M]  {a b c : M} (h : IsUnit a) : a * ↑h.unit⁻¹ = 1 := by rw [←h.unit.mul_inv]; sorry",
  "name": "mul_val_inv",
  "kind": "theorem",
  "first-tactic": "rw [←h.unit.mul_inv]",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _}  [Monoid M]  {a b c : M} (h : IsUnit a) : a * ↑h.unit⁻¹ = 1",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _}  [Monoid M]  {a b c : M} (h : IsUnit a)"},
 {"type": "IsUnit a → a⁻¹ * a = 1",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [DivisionMonoid M]  {a : M} : IsUnit a → a⁻¹ * a = 1 := by rintro ⟨u, rfl⟩; sorry",
  "name": "inv_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rintro ⟨u, rfl⟩",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [DivisionMonoid M]  {a : M} : IsUnit a → a⁻¹ * a = 1",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [DivisionMonoid M]  {a : M}"},
 {"type": "IsUnit a → a * a⁻¹ = 1",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [DivisionMonoid M]  {a : M} : IsUnit a → a * a⁻¹ = 1 := by rintro ⟨u, rfl⟩; sorry",
  "name": "mul_inv_cancel",
  "kind": "theorem",
  "first-tactic": "rintro ⟨u, rfl⟩",
  "core-prompt":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [DivisionMonoid M]  {a : M} : IsUnit a → a * a⁻¹ = 1",
  "args":
  "{α : Type u} [Monoid α]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : αˣ)  {u : αˣ}  {M : Type _}  {N : Type _} [DivisionMonoid M]  {a : M}"},
 {"type": "a * 0 = 0",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w} {α : Type u}  [Mul α]  (a : WithZero α) : a * 0 = 0 := by cases a; sorry",
  "name": "mul_zero",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w} {α : Type u}  [Mul α]  (a : WithZero α) : a * 0 = 0",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w} {α : Type u}  [Mul α]  (a : WithZero α)"},
 {"type": "map (MulHom.id α) = MonoidHom.id (WithOne α)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  [Mul α]  [MulOneClass β] (f : α →ₙ* β)  [Mul α]  [Mul β]  [Mul γ] : map (MulHom.id α) = MonoidHom.id (WithOne α) := by ext x; sorry",
  "name": "map_id",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  [Mul α]  [MulOneClass β] (f : α →ₙ* β)  [Mul α]  [Mul β]  [Mul γ] : map (MulHom.id α) = MonoidHom.id (WithOne α)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  [Mul α]  [MulOneClass β] (f : α →ₙ* β)  [Mul α]  [Mul β]  [Mul γ]"},
 {"type": "((1 : M), b₁) * (1, b₂) = (1, b₁ * b₂)",
  "tactic-prompt":
  "theorem {A : Type _}  {B : Type _}  {G : Type _}  {H : Type _}  {M : Type _}  {N : Type _}  {P : Type _} [Monoid M]  [Mul N]  (b₁ b₂ : N) : ((1 : M), b₁) * (1, b₂) = (1, b₁ * b₂) := by rw [mk_mul_mk]; sorry",
  "name": "one_mk_mul_one_mk",
  "kind": "theorem",
  "first-tactic": "rw [mk_mul_mk]",
  "core-prompt":
  "{A : Type _}  {B : Type _}  {G : Type _}  {H : Type _}  {M : Type _}  {N : Type _}  {P : Type _} [Monoid M]  [Mul N]  (b₁ b₂ : N) : ((1 : M), b₁) * (1, b₂) = (1, b₁ * b₂)",
  "args":
  "{A : Type _}  {B : Type _}  {G : Type _}  {H : Type _}  {M : Type _}  {N : Type _}  {P : Type _} [Monoid M]  [Mul N]  (b₁ b₂ : N)"},
 {"type": "(a₁, (1 : N)) * (a₂, 1) = (a₁ * a₂, 1)",
  "tactic-prompt":
  "theorem {A : Type _}  {B : Type _}  {G : Type _}  {H : Type _}  {M : Type _}  {N : Type _}  {P : Type _} [Mul M]  [Monoid N]  (a₁ a₂ : M) : (a₁, (1 : N)) * (a₂, 1) = (a₁ * a₂, 1) := by rw [mk_mul_mk]; sorry",
  "name": "mk_one_mul_mk_one",
  "kind": "theorem",
  "first-tactic": "rw [mk_mul_mk]",
  "core-prompt":
  "{A : Type _}  {B : Type _}  {G : Type _}  {H : Type _}  {M : Type _}  {N : Type _}  {P : Type _} [Mul M]  [Monoid N]  (a₁ a₂ : M) : (a₁, (1 : N)) * (a₂, 1) = (a₁ * a₂, 1)",
  "args":
  "{A : Type _}  {B : Type _}  {G : Type _}  {H : Type _}  {M : Type _}  {N : Type _}  {P : Type _} [Mul M]  [Monoid N]  (a₁ a₂ : M)"},
 {"type": "Function.Injective (@CommMonoid.toMonoid M)",
  "tactic-prompt":
  "theorem {M : Type u} : Function.Injective (@CommMonoid.toMonoid M) := by rintro ⟨⟩ ⟨⟩ h; sorry",
  "name": "CommMonoid.toMonoid_injective",
  "kind": "theorem",
  "first-tactic": "rintro ⟨⟩ ⟨⟩ h",
  "core-prompt": "{M : Type u} : Function.Injective (@CommMonoid.toMonoid M)",
  "args": "{M : Type u}"},
 {"type": "Function.Injective (@LeftCancelMonoid.toMonoid M)",
  "tactic-prompt":
  "theorem {M : Type u} : Function.Injective (@LeftCancelMonoid.toMonoid M) := by rintro @⟨@⟨⟩⟩ @⟨@⟨⟩⟩ h; sorry",
  "name": "LeftCancelMonoid.toMonoid_injective",
  "kind": "theorem",
  "first-tactic": "rintro @⟨@⟨⟩⟩ @⟨@⟨⟩⟩ h",
  "core-prompt":
  "{M : Type u} : Function.Injective (@LeftCancelMonoid.toMonoid M)",
  "args": "{M : Type u}"},
 {"type": "Function.Injective (@RightCancelMonoid.toMonoid M)",
  "tactic-prompt":
  "theorem {M : Type u} : Function.Injective (@RightCancelMonoid.toMonoid M) := by rintro @⟨@⟨⟩⟩ @⟨@⟨⟩⟩ h; sorry",
  "name": "RightCancelMonoid.toMonoid_injective",
  "kind": "theorem",
  "first-tactic": "rintro @⟨@⟨⟩⟩ @⟨@⟨⟩⟩ h",
  "core-prompt":
  "{M : Type u} : Function.Injective (@RightCancelMonoid.toMonoid M)",
  "args": "{M : Type u}"},
 {"type": "Function.Injective (@CancelMonoid.toLeftCancelMonoid M)",
  "tactic-prompt":
  "theorem {M : Type u} : Function.Injective (@CancelMonoid.toLeftCancelMonoid M) := by rintro ⟨⟩ ⟨⟩ h; sorry",
  "name": "CancelMonoid.toLeftCancelMonoid_injective",
  "kind": "theorem",
  "first-tactic": "rintro ⟨⟩ ⟨⟩ h",
  "core-prompt":
  "{M : Type u} : Function.Injective (@CancelMonoid.toLeftCancelMonoid M)",
  "args": "{M : Type u}"},
 {"type": "Function.Injective (@CancelCommMonoid.toCommMonoid M)",
  "tactic-prompt":
  "theorem {M : Type u} : Function.Injective (@CancelCommMonoid.toCommMonoid M) := by rintro @⟨@⟨@⟨⟩⟩⟩ @⟨@⟨@⟨⟩⟩⟩ h; sorry",
  "name": "CancelCommMonoid.toCommMonoid_injective",
  "kind": "theorem",
  "first-tactic": "rintro @⟨@⟨@⟨⟩⟩⟩ @⟨@⟨@⟨⟩⟩⟩ h",
  "core-prompt":
  "{M : Type u} : Function.Injective (@CancelCommMonoid.toCommMonoid M)",
  "args": "{M : Type u}"},
 {"type": "op (x / y) = (op y)⁻¹ * op x",
  "tactic-prompt":
  "theorem (α : Type u) [DivInvMonoid α]  (x y : α) : op (x / y) = (op y)⁻¹ * op x := by simp [div_eq_mul_inv]; sorry",
  "name": "op_div",
  "kind": "theorem",
  "first-tactic": "simp [div_eq_mul_inv]",
  "core-prompt":
  "(α : Type u) [DivInvMonoid α]  (x y : α) : op (x / y) = (op y)⁻¹ * op x",
  "args": "(α : Type u) [DivInvMonoid α]  (x y : α)"},
 {"type": "SemiconjBy (op a) (op y) (op x) ↔ SemiconjBy a x y",
  "tactic-prompt":
  "theorem (α : Type u) [Mul α]  {a x y : α} : SemiconjBy (op a) (op y) (op x) ↔ SemiconjBy a x y := by simp only [SemiconjBy]; sorry",
  "name": "semiconjBy_op",
  "kind": "theorem",
  "first-tactic": "simp only [SemiconjBy]",
  "core-prompt":
  "(α : Type u) [Mul α]  {a x y : α} : SemiconjBy (op a) (op y) (op x) ↔ SemiconjBy a x y",
  "args": "(α : Type u) [Mul α]  {a x y : α}"},
 {"type": "SemiconjBy (unop a) (unop y) (unop x) ↔ SemiconjBy a x y",
  "tactic-prompt":
  "theorem (α : Type u) [Mul α]  {a x y : αᵐᵒᵖ} : SemiconjBy (unop a) (unop y) (unop x) ↔ SemiconjBy a x y := by conv_rhs => rw [← op_unop a]; sorry",
  "name": "semiconjBy_unop",
  "kind": "theorem",
  "first-tactic": "conv_rhs => rw [← op_unop a]",
  "core-prompt":
  "(α : Type u) [Mul α]  {a x y : αᵐᵒᵖ} : SemiconjBy (unop a) (unop y) (unop x) ↔ SemiconjBy a x y",
  "args": "(α : Type u) [Mul α]  {a x y : αᵐᵒᵖ}"},
 {"type": "Covariant N N (· * ·) r ↔ Contravariant N N (· * ·) r",
  "tactic-prompt":
  "theorem {M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [Group N] : Covariant N N (· * ·) r ↔ Contravariant N N (· * ·) r := by refine ⟨fun h a b c bc ↦ ?_, fun h a b c bc ↦ ?_⟩; sorry",
  "name": "Group.covariant_iff_contravariant",
  "kind": "theorem",
  "first-tactic": "refine ⟨fun h a b c bc ↦ ?_, fun h a b c bc ↦ ?_⟩",
  "core-prompt":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [Group N] : Covariant N N (· * ·) r ↔ Contravariant N N (· * ·) r",
  "args": "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [Group N]"},
 {"type": "Covariant N N (swap (· * ·)) r ↔ Contravariant N N (swap (· * ·)) r",
  "tactic-prompt":
  "theorem {M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [Group N] : Covariant N N (swap (· * ·)) r ↔ Contravariant N N (swap (· * ·)) r := by refine ⟨fun h a b c bc ↦ ?_, fun h a b c bc ↦ ?_⟩; sorry",
  "name": "Group.covariant_swap_iff_contravariant_swap",
  "kind": "theorem",
  "first-tactic": "refine ⟨fun h a b c bc ↦ ?_, fun h a b c bc ↦ ?_⟩",
  "core-prompt":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [Group N] : Covariant N N (swap (· * ·)) r ↔ Contravariant N N (swap (· * ·)) r",
  "args": "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [Group N]"},
 {"type": "Covariant M N μ (· < ·) → Covariant M N μ (· ≤ ·)",
  "tactic-prompt":
  "theorem {M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [PartialOrder N] : Covariant M N μ (· < ·) → Covariant M N μ (· ≤ ·) := by intro h a b c bc; sorry",
  "name": "covariant_le_of_covariant_lt",
  "kind": "theorem",
  "first-tactic": "intro h a b c bc",
  "core-prompt":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [PartialOrder N] : Covariant M N μ (· < ·) → Covariant M N μ (· ≤ ·)",
  "args":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [PartialOrder N]"},
 {"type": "Contravariant M N μ (· ≤ ·) → Contravariant M N μ (· < ·)",
  "tactic-prompt":
  "theorem {M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [PartialOrder N] : Contravariant M N μ (· ≤ ·) → Contravariant M N μ (· < ·) := by refine fun h a b c bc ↦ lt_iff_le_and_ne.mpr ⟨h a bc.le, ?_⟩; sorry",
  "name": "contravariant_lt_of_contravariant_le",
  "kind": "theorem",
  "first-tactic":
  "refine fun h a b c bc ↦ lt_iff_le_and_ne.mpr ⟨h a bc.le, ?_⟩",
  "core-prompt":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [PartialOrder N] : Contravariant M N μ (· ≤ ·) → Contravariant M N μ (· < ·)",
  "args":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [PartialOrder N]"},
 {"type": "Covariant N N (flip (· * ·)) r ↔ Covariant N N (· * ·) r",
  "tactic-prompt":
  "theorem {M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [CommSemigroup N] : Covariant N N (flip (· * ·)) r ↔ Covariant N N (· * ·) r := by rw [flip_mul]; sorry",
  "name": "covariant_flip_mul_iff",
  "kind": "theorem",
  "first-tactic": "rw [flip_mul]",
  "core-prompt":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [CommSemigroup N] : Covariant N N (flip (· * ·)) r ↔ Covariant N N (· * ·) r",
  "args":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [CommSemigroup N]"},
 {"type": "Contravariant N N (flip (· * ·)) r ↔ Contravariant N N (· * ·) r",
  "tactic-prompt":
  "theorem {M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [CommSemigroup N] : Contravariant N N (flip (· * ·)) r ↔ Contravariant N N (· * ·) r := by rw [flip_mul]; sorry",
  "name": "contravariant_flip_mul_iff",
  "kind": "theorem",
  "first-tactic": "rw [flip_mul]",
  "core-prompt":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [CommSemigroup N] : Contravariant N N (flip (· * ·)) r ↔ Contravariant N N (· * ·) r",
  "args":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [CommSemigroup N]"},
 {"type": "p ∣ a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] {p : α}  (hp : Prime p) (hp : Prime p)  {a : α}  {n : ℕ}  (h : p ∣ a ^ n) : p ∣ a := by induction' n with n ih; sorry",
  "name": "dvd_of_dvd_pow",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] {p : α}  (hp : Prime p) (hp : Prime p)  {a : α}  {n : ℕ}  (h : p ∣ a ^ n) : p ∣ a",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] {p : α}  (hp : Prime p) (hp : Prime p)  {a : α}  {n : ℕ}  (h : p ∣ a ^ n)"},
 {"type": "a ∣ p * b → p ∣ a ∨ a ∣ b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [CancelCommMonoidWithZero α]  {p : α}  (hp : Prime p)      {a b : α} : a ∣ p * b → p ∣ a ∨ a ∣ b := by rintro ⟨c, hc⟩; sorry",
  "name": "Prime.left_dvd_or_dvd_right_of_dvd_mul",
  "kind": "theorem",
  "first-tactic": "rintro ⟨c, hc⟩",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [CancelCommMonoidWithZero α]  {p : α}  (hp : Prime p)      {a b : α} : a ∣ p * b → p ∣ a ∨ a ∣ b",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [CancelCommMonoidWithZero α]  {p : α}  (hp : Prime p)      {a b : α}"},
 {"type": "p ^ n ∣ b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [CancelCommMonoidWithZero α]  {p a b : α}  (hp : Prime p)      (n : ℕ)  (h : ¬p ∣ a)  (h' : p ^ n ∣ a * b) : p ^ n ∣ b := by induction' n with n ih; sorry",
  "name": "Prime.pow_dvd_of_dvd_mul_left",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [CancelCommMonoidWithZero α]  {p a b : α}  (hp : Prime p)      (n : ℕ)  (h : ¬p ∣ a)  (h' : p ^ n ∣ a * b) : p ^ n ∣ b",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [CancelCommMonoidWithZero α]  {p a b : α}  (hp : Prime p)      (n : ℕ)  (h : ¬p ∣ a)  (h' : p ^ n ∣ a * b)"},
 {"type": "p ^ n ∣ a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [CancelCommMonoidWithZero α]  {p a b : α}  (hp : Prime p)      (n : ℕ)  (h : ¬p ∣ b)  (h' : p ^ n ∣ a * b) : p ^ n ∣ a := by rw [mul_comm] at h'; sorry",
  "name": "Prime.pow_dvd_of_dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm] at h'",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [CancelCommMonoidWithZero α]  {p a b : α}  (hp : Prime p)      (n : ℕ)  (h : ¬p ∣ b)  (h' : p ^ n ∣ a * b) : p ^ n ∣ a",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [CancelCommMonoidWithZero α]  {p a b : α}  (hp : Prime p)      (n : ℕ)  (h : ¬p ∣ b)  (h' : p ^ n ∣ a * b)"},
 {"type": "p ∣ a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [CancelCommMonoidWithZero α]  {p a b : α}      {n : ℕ}  (hp : Prime p)  (hpow : p ^ n.succ ∣ a ^ n.succ * b ^ n)  (hb : ¬p ^ 2 ∣ b) : p ∣ a := by cases' hp.dvd_or_dvd ((dvd_pow_self p (Nat.succ_ne_zero n)).trans hpow) with H hbdiv; sorry",
  "name": "Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd",
  "kind": "theorem",
  "first-tactic":
  "cases' hp.dvd_or_dvd ((dvd_pow_self p (Nat.succ_ne_zero n)).trans hpow) with H hbdiv",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [CancelCommMonoidWithZero α]  {p a b : α}      {n : ℕ}  (hp : Prime p)  (hpow : p ^ n.succ ∣ a ^ n.succ * b ^ n)  (hb : ¬p ^ 2 ∣ b) : p ∣ a",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [CancelCommMonoidWithZero α]  {p a b : α}      {n : ℕ}  (hp : Prime p)  (hpow : p ^ n.succ ∣ a ^ n.succ * b ^ n)  (hb : ¬p ^ 2 ∣ b)"},
 {"type": "p ^ (i + 1) ∣ x ∨ p ∣ y",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {α : Type _}  [CancelCommMonoidWithZero α]  {p x y : α}  (h : Prime p)      {i : ℕ}  (hxy : p ^ (i + 1) ∣ x * y) : p ^ (i + 1) ∣ x ∨ p ∣ y := by rw [or_iff_not_imp_right]; sorry",
  "name": "prime_pow_succ_dvd_mul",
  "kind": "theorem",
  "first-tactic": "rw [or_iff_not_imp_right]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {α : Type _}  [CancelCommMonoidWithZero α]  {p x y : α}  (h : Prime p)      {i : ℕ}  (hxy : p ^ (i + 1) ∣ x * y) : p ^ (i + 1) ∣ x ∨ p ∣ y",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {α : Type _}  [CancelCommMonoidWithZero α]  {p x y : α}  (h : Prime p)      {i : ℕ}  (hxy : p ^ (i + 1) ∣ x * y)"},
 {"type": "¬Irreducible (1 : α)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [Monoid α] : ¬Irreducible (1 : α) := by simp [irreducible_iff]; sorry",
  "name": "not_irreducible_one",
  "kind": "theorem",
  "first-tactic": "simp [irreducible_iff]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [Monoid α] : ¬Irreducible (1 : α)",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [Monoid α]"},
 {"type": "p ∣ q → q ∣ p",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [Monoid α]  {p q : α}  (hp : Irreducible p)  (hq : Irreducible q) : p ∣ q → q ∣ p := by rintro ⟨q', rfl⟩; sorry",
  "name": "Irreducible.dvd_symm",
  "kind": "theorem",
  "first-tactic": "rintro ⟨q', rfl⟩",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [Monoid α]  {p q : α}  (hp : Irreducible p)  (hq : Irreducible q) : p ∣ q → q ∣ p",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} [Monoid α]  {p q : α}  (hp : Irreducible p)  (hq : Irreducible q)"},
 {"type": "Irreducible (↑a * b) ↔ Irreducible b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [Monoid α] (a : αˣ)  (b : α) : Irreducible (↑a * b) ↔ Irreducible b := by simp only [irreducible_iff]; sorry",
  "name": "irreducible_units_mul",
  "kind": "theorem",
  "first-tactic": "simp only [irreducible_iff]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [Monoid α] (a : αˣ)  (b : α) : Irreducible (↑a * b) ↔ Irreducible b",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [Monoid α] (a : αˣ)  (b : α)"},
 {"type": "Irreducible (b * ↑a) ↔ Irreducible b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [Monoid α] (a : αˣ)  (b : α) : Irreducible (b * ↑a) ↔ Irreducible b := by simp only [irreducible_iff]; sorry",
  "name": "irreducible_mul_units",
  "kind": "theorem",
  "first-tactic": "simp only [irreducible_iff]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [Monoid α] (a : αˣ)  (b : α) : Irreducible (b * ↑a) ↔ Irreducible b",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [Monoid α] (a : αˣ)  (b : α)"},
 {"type":
  "Irreducible (a * b) ↔ Irreducible a ∧ IsUnit b ∨ Irreducible b ∧ IsUnit a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [Monoid α] {a b : α} : Irreducible (a * b) ↔ Irreducible a ∧ IsUnit b ∨ Irreducible b ∧ IsUnit a := by constructor; sorry",
  "name": "irreducible_mul_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [Monoid α] {a b : α} : Irreducible (a * b) ↔ Irreducible a ∧ IsUnit b ∨ Irreducible b ∧ IsUnit a",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [Monoid α] {a b : α}"},
 {"type": "¬IsSquare a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoid α]  {a : α} (ha : Irreducible a) : ¬IsSquare a := by rintro ⟨b, rfl⟩; sorry",
  "name": "Irreducible.not_square",
  "kind": "theorem",
  "first-tactic": "rintro ⟨b, rfl⟩",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoid α]  {a : α} (ha : Irreducible a) : ¬IsSquare a",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoid α]  {a : α} (ha : Irreducible a)"},
 {"type": "Associated (u * a) a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {β : Type _}  [CommMonoid β]  (a u : β)  (hu : IsUnit u) : Associated (u * a) a := by rw [mul_comm]; sorry",
  "name": "associated_unit_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {β : Type _}  [CommMonoid β]  (a u : β)  (hu : IsUnit u) : Associated (u * a) a",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {β : Type _}  [CommMonoid β]  (a u : β)  (hu : IsUnit u)"},
 {"type": "Associated (u * a) b ↔ Associated a b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {β : Type _}  [CommMonoid β]  {u a b : β}  (hu : IsUnit u) : Associated (u * a) b ↔ Associated a b := by rw [mul_comm]; sorry",
  "name": "associated_isUnit_mul_left_iff",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {β : Type _}  [CommMonoid β]  {u a b : β}  (hu : IsUnit u) : Associated (u * a) b ↔ Associated a b",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {β : Type _}  [CommMonoid β]  {u a b : β}  (hu : IsUnit u)"},
 {"type": "(Associated : α → α → Prop) = Eq",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [Monoid α]  [Unique αˣ] : (Associated : α → α → Prop) = Eq := by ext; sorry",
  "name": "associated_eq_eq",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [Monoid α]  [Unique αˣ] : (Associated : α → α → Prop) = Eq",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [Monoid α]  [Unique αˣ]"},
 {"type": "p ∣ q ↔ p = q",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [Monoid α]  [Unique αˣ] {M : Type _}  [CancelCommMonoidWithZero M]  [Unique Mˣ]  {p q : M}      (pp : Prime p)  (qp : Prime q) : p ∣ q ↔ p = q := by rw [pp.dvd_prime_iff_associated qp]; sorry",
  "name": "prime_dvd_prime_iff_eq",
  "kind": "theorem",
  "first-tactic": "rw [pp.dvd_prime_iff_associated qp]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [Monoid α]  [Unique αˣ] {M : Type _}  [CancelCommMonoidWithZero M]  [Unique Mˣ]  {p q : M}      (pp : Prime p)  (qp : Prime q) : p ∣ q ↔ p = q",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [Monoid α]  [Unique αˣ] {M : Type _}  [CancelCommMonoidWithZero M]  [Unique Mˣ]  {p q : M}      (pp : Prime p)  (qp : Prime q)"},
 {"type": "p₁ = p₂",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  {R : Type _}  [CancelCommMonoidWithZero R]  [Unique Rˣ]  {p₁ p₂ : R}  {k₁ k₂ : ℕ} (hp₁ : Prime p₁)  (hp₂ : Prime p₂)  (hk₁ : 0 < k₁)      (h : p₁ ^ k₁ = p₂ ^ k₂) : p₁ = p₂ := by rw [← associated_iff_eq] at h⊢; sorry",
  "name": "eq_of_prime_pow_eq",
  "kind": "theorem",
  "first-tactic": "rw [← associated_iff_eq] at h⊢",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  {R : Type _}  [CancelCommMonoidWithZero R]  [Unique Rˣ]  {p₁ p₂ : R}  {k₁ k₂ : ℕ} (hp₁ : Prime p₁)  (hp₂ : Prime p₂)  (hk₁ : 0 < k₁)      (h : p₁ ^ k₁ = p₂ ^ k₂) : p₁ = p₂",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  {R : Type _}  [CancelCommMonoidWithZero R]  [Unique Rˣ]  {p₁ p₂ : R}  {k₁ k₂ : ℕ} (hp₁ : Prime p₁)  (hp₂ : Prime p₂)  (hk₁ : 0 < k₁)      (h : p₁ ^ k₁ = p₂ ^ k₂)"},
 {"type": "p₁ = p₂",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  {R : Type _}  [CancelCommMonoidWithZero R]  [Unique Rˣ]  {p₁ p₂ : R}  {k₁ k₂ : ℕ} (hp₁ : Prime p₁)  (hp₂ : Prime p₂)  (hk₁ : 0 < k₂)      (h : p₁ ^ k₁ = p₂ ^ k₂) : p₁ = p₂ := by rw [← associated_iff_eq] at h⊢; sorry",
  "name": "eq_of_prime_pow_eq'",
  "kind": "theorem",
  "first-tactic": "rw [← associated_iff_eq] at h⊢",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  {R : Type _}  [CancelCommMonoidWithZero R]  [Unique Rˣ]  {p₁ p₂ : R}  {k₁ k₂ : ℕ} (hp₁ : Prime p₁)  (hp₂ : Prime p₂)  (hk₁ : 0 < k₂)      (h : p₁ ^ k₁ = p₂ ^ k₂) : p₁ = p₂",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  {R : Type _}  [CancelCommMonoidWithZero R]  [Unique Rˣ]  {p₁ p₂ : R}  {k₁ k₂ : ℕ} (hp₁ : Prime p₁)  (hp₂ : Prime p₂)  (hk₁ : 0 < k₂)      (h : p₁ ^ k₁ = p₂ ^ k₂)"},
 {"type": "Associates.mk (a ^ n) = Associates.mk a ^ n",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoid α] (a : α)  (n : ℕ) : Associates.mk (a ^ n) = Associates.mk a ^ n := by induction n; sorry",
  "name": "mk_pow",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoid α] (a : α)  (n : ℕ) : Associates.mk (a ^ n) = Associates.mk a ^ n",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoid α] (a : α)  (n : ℕ)"},
 {"type": "(u : Associates α) = 1",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoid α] (u : (Associates α)ˣ) : (u : Associates α) = 1 := by simp; sorry",
  "name": "coe_unit_eq_one",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoid α] (u : (Associates α)ˣ) : (u : Associates α) = 1",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoid α] (u : (Associates α)ˣ)"},
 {"type": "IsUnit a ↔ a = ⊥",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoid α] {a : Associates α} : IsUnit a ↔ a = ⊥ := by rw [Associates.isUnit_iff_eq_one]; sorry",
  "name": "isUnit_iff_eq_bot",
  "kind": "theorem",
  "first-tactic": "rw [Associates.isUnit_iff_eq_one]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoid α] {a : Associates α} : IsUnit a ↔ a = ⊥",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoid α] {a : Associates α}"},
 {"type": "a ≤ b * a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoid α]  {a b : Associates α} : a ≤ b * a := by rw [mul_comm]; sorry",
  "name": "le_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoid α]  {a b : Associates α} : a ≤ b * a",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoid α]  {a b : Associates α}"},
 {"type": "Prime (Associates.mk p) ↔ Prime p",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] (p : α) : Prime (Associates.mk p) ↔ Prime p := by rw [Prime]; sorry",
  "name": "prime_mk",
  "kind": "theorem",
  "first-tactic": "rw [Prime]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] (p : α) : Prime (Associates.mk p) ↔ Prime p",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] (p : α)"},
 {"type": "Irreducible (Associates.mk a) ↔ Irreducible a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] (a : α) : Irreducible (Associates.mk a) ↔ Irreducible a := by simp only [irreducible_iff]; sorry",
  "name": "irreducible_mk",
  "kind": "theorem",
  "first-tactic": "simp only [irreducible_iff]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] (a : α) : Irreducible (Associates.mk a) ↔ Irreducible a",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] (a : α)"},
 {"type": "DvdNotUnit (Associates.mk a) (Associates.mk b) ↔ DvdNotUnit a b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] {a b : α} : DvdNotUnit (Associates.mk a) (Associates.mk b) ↔ DvdNotUnit a b := by rw [DvdNotUnit]; sorry",
  "name": "mk_dvdNotUnit_mk_iff",
  "kind": "theorem",
  "first-tactic": "rw [DvdNotUnit]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] {a b : α} : DvdNotUnit (Associates.mk a) (Associates.mk b) ↔ DvdNotUnit a b",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] {a b : α}"},
 {"type": "DvdNotUnit a b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] {a b : Associates α}  (hlt : a < b) : DvdNotUnit a b := by constructor; sorry",
  "name": "dvdNotUnit_of_lt",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] {a b : Associates α}  (hlt : a < b) : DvdNotUnit a b",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] {a b : Associates α}  (hlt : a < b)"},
 {"type":
  "(∀ a : α, Irreducible a ↔ Prime a) ↔ ∀ a : Associates α, Irreducible a ↔ Prime a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] : (∀ a : α, Irreducible a ↔ Prime a) ↔ ∀ a : Associates α, Irreducible a ↔ Prime a := by simp_rw [forall_associated]; sorry",
  "name": "irreducible_iff_prime_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [forall_associated]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α] : (∀ a : α, Irreducible a ↔ Prime a) ↔ ∀ a : Associates α, Irreducible a ↔ Prime a",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α]"},
 {"type": "∀ a b c : Associates α, a ≠ 0 → a * b = a * c → b = c",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α] : ∀ a b c : Associates α, a ≠ 0 → a * b = a * c → b = c := by rintro ⟨a⟩ ⟨b⟩ ⟨c⟩ ha h; sorry",
  "name": "eq_of_mul_eq_mul_left",
  "kind": "theorem",
  "first-tactic": "rintro ⟨a⟩ ⟨b⟩ ⟨c⟩ ha h",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α] : ∀ a b c : Associates α, a ≠ 0 → a * b = a * c → b = c",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α]"},
 {"type": "p ≤ 1 ↔ p = 1",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α] {p : Associates α} : p ≤ 1 ↔ p = 1 := by rw [← Associates.bot_eq_one]; sorry",
  "name": "le_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [← Associates.bot_eq_one]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α] {p : Associates α} : p ≤ 1 ↔ p = 1",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α] {p : Associates α}"},
 {"type": "IsUnit p",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α]  {p q : α}      (h : DvdNotUnit p q)  (hq : Irreducible q) : IsUnit p := by obtain ⟨_, x, hx, hx'⟩ := h; sorry",
  "name": "DvdNotUnit.isUnit_of_irreducible_right",
  "kind": "theorem",
  "first-tactic": "obtain ⟨_, x, hx, hx'⟩ := h",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α]  {p q : α}      (h : DvdNotUnit p q)  (hq : Irreducible q) : IsUnit p",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α]  {p q : α}      (h : DvdNotUnit p q)  (hq : Irreducible q)"},
 {"type": "¬IsUnit q",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α]  {p q : α}  (hp : DvdNotUnit p q) : ¬IsUnit q := by obtain ⟨-, x, hx, rfl⟩ := hp; sorry",
  "name": "DvdNotUnit.not_unit",
  "kind": "theorem",
  "first-tactic": "obtain ⟨-, x, hx, rfl⟩ := hp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α]  {p q : α}  (hp : DvdNotUnit p q) : ¬IsUnit q",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α]  {p q : α}  (hp : DvdNotUnit p q)"},
 {"type": "DvdNotUnit p r",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α]  [Nontrivial α]  {p q r : α}      (h : DvdNotUnit p q)  (h' : Associated q r) : DvdNotUnit p r := by obtain ⟨u, rfl⟩ := Associated.symm h'; sorry",
  "name": "dvdNotUnit_of_dvdNotUnit_associated",
  "kind": "theorem",
  "first-tactic": "obtain ⟨u, rfl⟩ := Associated.symm h'",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α]  [Nontrivial α]  {p q r : α}      (h : DvdNotUnit p q)  (h' : Associated q r) : DvdNotUnit p r",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CommMonoidWithZero α]  [Nontrivial α]  {p q r : α}      (h : DvdNotUnit p q)  (h' : Associated q r)"},
 {"type": "IsUnit b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α]  {p b : α}  (h : Associated (p * b) p)      (hp : p ≠ 0) : IsUnit b := by cases' h with a ha; sorry",
  "name": "isUnit_of_associated_mul",
  "kind": "theorem",
  "first-tactic": "cases' h with a ha",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α]  {p b : α}  (h : Associated (p * b) p)      (hp : p ≠ 0) : IsUnit b",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α]  {p b : α}  (h : Associated (p * b) p)      (hp : p ≠ 0)"},
 {"type": "¬Associated p q",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α]  {p q : α}  (h : DvdNotUnit p q) : ¬Associated p q := by rintro ⟨a, rfl⟩; sorry",
  "name": "DvdNotUnit.not_associated",
  "kind": "theorem",
  "first-tactic": "rintro ⟨a, rfl⟩",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α]  {p q : α}  (h : DvdNotUnit p q) : ¬Associated p q",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α]  {p q : α}  (h : DvdNotUnit p q)"},
 {"type": "p ≠ q",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α]  {p q : α}  (h : DvdNotUnit p q) : p ≠ q := by by_contra hcontra; sorry",
  "name": "DvdNotUnit.ne",
  "kind": "theorem",
  "first-tactic": "by_contra hcontra",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α]  {p q : α}  (h : DvdNotUnit p q) : p ≠ q",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α]  {p q : α}  (h : DvdNotUnit p q)"},
 {"type": "Function.Injective fun n : ℕ => q ^ n",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α]  {q : α}  (hq : ¬IsUnit q)      (hq' : q ≠ 0) : Function.Injective fun n : ℕ => q ^ n := by refine' injective_of_lt_imp_ne fun n m h => DvdNotUnit.ne ⟨pow_ne_zero n hq', q ^ (m - n), _, _⟩; sorry",
  "name": "pow_injective_of_not_unit",
  "kind": "theorem",
  "first-tactic":
  "refine' injective_of_lt_imp_ne fun n m h => DvdNotUnit.ne ⟨pow_ne_zero n hq', q ^ (m - n), _, _⟩",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α]  {q : α}  (hq : ¬IsUnit q)      (hq' : q ≠ 0) : Function.Injective fun n : ℕ => q ^ n",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α]  {q : α}  (hq : ¬IsUnit q)      (hq' : q ≠ 0)"},
 {"type": "q ∣ p ^ n ↔ ∃ i ≤ n, Associated q (p ^ i)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α]  {p q : α}  (hp : Prime p)  (n : ℕ) : q ∣ p ^ n ↔ ∃ i ≤ n, Associated q (p ^ i) := by induction' n with n ih generalizing q; sorry",
  "name": "dvd_prime_pow",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih generalizing q",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α]  {p q : α}  (hp : Prime p)  (n : ℕ) : q ∣ p ^ n ↔ ∃ i ≤ n, Associated q (p ^ i)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _}  [CancelCommMonoidWithZero α]  {p q : α}  (hp : Prime p)  (n : ℕ)"},
 {"type": "¬NeZero n ↔ n = 0",
  "tactic-prompt":
  "theorem {R : Type _}  [Zero R]  {n : R} : ¬NeZero n ↔ n = 0 := by simp [neZero_iff]; sorry",
  "name": "not_neZero",
  "kind": "theorem",
  "first-tactic": "simp [neZero_iff]",
  "core-prompt": "{R : Type _}  [Zero R]  {n : R} : ¬NeZero n ↔ n = 0",
  "args": "{R : Type _}  [Zero R]  {n : R}"},
 {"type": "(0 : M) ^ n = if n = 0 then 1 else 0",
  "tactic-prompt":
  "theorem {R S M : Type _}  [MonoidWithZero M] (n : ℕ) : (0 : M) ^ n = if n = 0 then 1 else 0 := by split_ifs with h; sorry",
  "name": "zero_pow_eq",
  "kind": "theorem",
  "first-tactic": "split_ifs with h",
  "core-prompt":
  "{R S M : Type _}  [MonoidWithZero M] (n : ℕ) : (0 : M) ^ n = if n = 0 then 1 else 0",
  "args": "{R S M : Type _}  [MonoidWithZero M] (n : ℕ)"},
 {"type": "x ^ m = 0",
  "tactic-prompt":
  "theorem {R S M : Type _}  [MonoidWithZero M] {x : M}  {n m : ℕ}  (hn : n ≤ m)  (hx : x ^ n = 0) : x ^ m = 0 := by rw [← tsub_add_cancel_of_le hn]; sorry",
  "name": "pow_eq_zero_of_le",
  "kind": "theorem",
  "first-tactic": "rw [← tsub_add_cancel_of_le hn]",
  "core-prompt":
  "{R S M : Type _}  [MonoidWithZero M] {x : M}  {n m : ℕ}  (hn : n ≤ m)  (hx : x ^ n = 0) : x ^ m = 0",
  "args":
  "{R S M : Type _}  [MonoidWithZero M] {x : M}  {n m : ℕ}  (hn : n ≤ m)  (hx : x ^ n = 0)"},
 {"type": "x = 0",
  "tactic-prompt":
  "theorem {R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  {x : M}  {n : ℕ}  (H : x ^ n = 0) : x = 0 := by induction' n with n ih; sorry",
  "name": "pow_eq_zero",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  {x : M}  {n : ℕ}  (H : x ^ n = 0) : x = 0",
  "args":
  "{R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  {x : M}  {n : ℕ}  (H : x ^ n = 0)"},
 {"type": "a ^ n = 0 ↔ a = 0",
  "tactic-prompt":
  "theorem {R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  {a : M}  {n : ℕ}  (hn : 0 < n) : a ^ n = 0 ↔ a = 0 := by refine' ⟨pow_eq_zero, _⟩; sorry",
  "name": "pow_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨pow_eq_zero, _⟩",
  "core-prompt":
  "{R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  {a : M}  {n : ℕ}  (hn : 0 < n) : a ^ n = 0 ↔ a = 0",
  "args":
  "{R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  {a : M}  {n : ℕ}  (hn : 0 < n)"},
 {"type": "a ^ n = 0 ↔ a = 0 ∧ n ≠ 0",
  "tactic-prompt":
  "theorem {R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  [Nontrivial M]  {a : M}  {n : ℕ} : a ^ n = 0 ↔ a = 0 ∧ n ≠ 0 := by cases (zero_le n).eq_or_gt; sorry",
  "name": "pow_eq_zero_iff'",
  "kind": "theorem",
  "first-tactic": "cases (zero_le n).eq_or_gt",
  "core-prompt":
  "{R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  [Nontrivial M]  {a : M}  {n : ℕ} : a ^ n = 0 ↔ a = 0 ∧ n ≠ 0",
  "args":
  "{R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  [Nontrivial M]  {a : M}  {n : ℕ}"},
 {"type": "a ^ n ≠ 0 → a ≠ 0",
  "tactic-prompt":
  "theorem {R S M : Type _}  [MonoidWithZero M] {a : M}  {n : ℕ}  (hn : n ≠ 0) : a ^ n ≠ 0 → a ≠ 0 := by contrapose!; sorry",
  "name": "ne_zero_pow",
  "kind": "theorem",
  "first-tactic": "contrapose!",
  "core-prompt":
  "{R S M : Type _}  [MonoidWithZero M] {a : M}  {n : ℕ}  (hn : n ≠ 0) : a ^ n ≠ 0 → a ≠ 0",
  "args":
  "{R S M : Type _}  [MonoidWithZero M] {a : M}  {n : ℕ}  (hn : n ≠ 0)"},
 {"type": "(0 : M) ^ n = 0 ↔ 0 < n",
  "tactic-prompt":
  "theorem {R S M : Type _}  [MonoidWithZero M] [Nontrivial M]  {n : ℕ} : (0 : M) ^ n = 0 ↔ 0 < n := by constructor; sorry",
  "name": "zero_pow_eq_zero",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{R S M : Type _}  [MonoidWithZero M] [Nontrivial M]  {n : ℕ} : (0 : M) ^ n = 0 ↔ 0 < n",
  "args": "{R S M : Type _}  [MonoidWithZero M] [Nontrivial M]  {n : ℕ}"},
 {"type": "x ^ n ∣ x ^ m ↔ n ≤ m",
  "tactic-prompt":
  "theorem {R S M : Type _} [CancelCommMonoidWithZero R]  {x : R}  {n m : ℕ}  (h0 : x ≠ 0)      (h1 : ¬IsUnit x) : x ^ n ∣ x ^ m ↔ n ≤ m := by constructor; sorry",
  "name": "pow_dvd_pow_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{R S M : Type _} [CancelCommMonoidWithZero R]  {x : R}  {n m : ℕ}  (h0 : x ≠ 0)      (h1 : ¬IsUnit x) : x ^ n ∣ x ^ m ↔ n ≤ m",
  "args":
  "{R S M : Type _} [CancelCommMonoidWithZero R]  {x : R}  {n m : ℕ}  (h0 : x ≠ 0)      (h1 : ¬IsUnit x)"},
 {"type": "c ^ min n m ∣ a + b",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Semiring R]  [Semiring S] {n m : ℕ}  {a b c : R}  (ha : c ^ n ∣ a)  (hb : c ^ m ∣ b) : c ^ min n m ∣ a + b := by replace ha := (pow_dvd_pow c (min_le_left n m)).trans ha; sorry",
  "name": "min_pow_dvd_add",
  "kind": "theorem",
  "first-tactic": "replace ha := (pow_dvd_pow c (min_le_left n m)).trans ha",
  "core-prompt":
  "{R S M : Type _}  [Semiring R]  [Semiring S] {n m : ℕ}  {a b c : R}  (ha : c ^ n ∣ a)  (hb : c ^ m ∣ b) : c ^ min n m ∣ a + b",
  "args":
  "{R S M : Type _}  [Semiring R]  [Semiring S] {n m : ℕ}  {a b c : R}  (ha : c ^ n ∣ a)  (hb : c ^ m ∣ b)"},
 {"type": "(a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2",
  "tactic-prompt":
  "theorem {R S M : Type _}  [CommSemiring R] (a b : R) : (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2 := by simp only [sq]; sorry",
  "name": "add_sq",
  "kind": "theorem",
  "first-tactic": "simp only [sq]",
  "core-prompt":
  "{R S M : Type _}  [CommSemiring R] (a b : R) : (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2",
  "args": "{R S M : Type _}  [CommSemiring R] (a b : R)"},
 {"type": "(a + b) ^ 2 = a ^ 2 + b ^ 2 + 2 * a * b",
  "tactic-prompt":
  "theorem {R S M : Type _}  [CommSemiring R] (a b : R) : (a + b) ^ 2 = a ^ 2 + b ^ 2 + 2 * a * b := by rw [add_sq]; sorry",
  "name": "add_sq'",
  "kind": "theorem",
  "first-tactic": "rw [add_sq]",
  "core-prompt":
  "{R S M : Type _}  [CommSemiring R] (a b : R) : (a + b) ^ 2 = a ^ 2 + b ^ 2 + 2 * a * b",
  "args": "{R S M : Type _}  [CommSemiring R] (a b : R)"},
 {"type": "(-a) ^ bit0 n = a ^ bit0 n",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  (a : R)  (n : ℕ) : (-a) ^ bit0 n = a ^ bit0 n := by rw [pow_bit0']; sorry",
  "name": "neg_pow_bit0",
  "kind": "theorem",
  "first-tactic": "rw [pow_bit0']",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  (a : R)  (n : ℕ) : (-a) ^ bit0 n = a ^ bit0 n",
  "args": "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  (a : R)  (n : ℕ)"},
 {"type": "(-a) ^ bit1 n = -a ^ bit1 n",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  (a : R)  (n : ℕ) : (-a) ^ bit1 n = -a ^ bit1 n := by simp only [bit1]; sorry",
  "name": "neg_pow_bit1",
  "kind": "theorem",
  "first-tactic": "simp only [bit1]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  (a : R)  (n : ℕ) : (-a) ^ bit1 n = -a ^ bit1 n",
  "args": "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  (a : R)  (n : ℕ)"},
 {"type": "(-a) ^ 2 = a ^ 2",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R] (a : R) : (-a) ^ 2 = a ^ 2 := by simp [sq]; sorry",
  "name": "neg_sq",
  "kind": "theorem",
  "first-tactic": "simp [sq]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R] (a : R) : (-a) ^ 2 = a ^ 2",
  "args": "{R S M : Type _}  [Monoid R]  [HasDistribNeg R] (a : R)"},
 {"type": "(-1 : R) ^ 2 = 1",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R] : (-1 : R) ^ 2 = 1 := by simp [neg_sq]; sorry",
  "name": "neg_one_sq",
  "kind": "theorem",
  "first-tactic": "simp [neg_sq]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R] : (-1 : R) ^ 2 = 1",
  "args": "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]"},
 {"type": "a ^ 2 - b ^ 2 = (a + b) * (a - b)",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} (h : Commute a b) : a ^ 2 - b ^ 2 = (a + b) * (a - b) := by rw [sq]; sorry",
  "name": "Commute.sq_sub_sq",
  "kind": "theorem",
  "first-tactic": "rw [sq]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} (h : Commute a b) : a ^ 2 - b ^ 2 = (a + b) * (a - b)",
  "args":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} (h : Commute a b)"},
 {"type": "(-1) ^ n * r = 0 ↔ r = 0",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} {n : ℕ}  {r : R} : (-1) ^ n * r = 0 ↔ r = 0 := by rcases neg_one_pow_eq_or R n with h | h; sorry",
  "name": "neg_one_pow_mul_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "rcases neg_one_pow_eq_or R n with h | h",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} {n : ℕ}  {r : R} : (-1) ^ n * r = 0 ↔ r = 0",
  "args":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} {n : ℕ}  {r : R}"},
 {"type": "r * (-1) ^ n = 0 ↔ r = 0",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} {n : ℕ}  {r : R} : r * (-1) ^ n = 0 ↔ r = 0 := by rcases neg_one_pow_eq_or R n with h | h; sorry",
  "name": "mul_neg_one_pow_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "rcases neg_one_pow_eq_or R n with h | h",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} {n : ℕ}  {r : R} : r * (-1) ^ n = 0 ↔ r = 0",
  "args":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} {n : ℕ}  {r : R}"},
 {"type": "a ^ 2 = b ^ 2 ↔ a = b ∨ a = -b",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} [NoZeroDivisors R] (h : Commute a b) : a ^ 2 = b ^ 2 ↔ a = b ∨ a = -b := by rw [← sub_eq_zero]; sorry",
  "name": "Commute.sq_eq_sq_iff_eq_or_eq_neg",
  "kind": "theorem",
  "first-tactic": "rw [← sub_eq_zero]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} [NoZeroDivisors R] (h : Commute a b) : a ^ 2 = b ^ 2 ↔ a = b ∨ a = -b",
  "args":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} [NoZeroDivisors R] (h : Commute a b)"},
 {"type": "a ^ 2 = 1 ↔ a = 1 ∨ a = -1",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} [NoZeroDivisors R] : a ^ 2 = 1 ↔ a = 1 ∨ a = -1 := by rw [← (Commute.one_right a).sq_eq_sq_iff_eq_or_eq_neg]; sorry",
  "name": "sq_eq_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [← (Commute.one_right a).sq_eq_sq_iff_eq_or_eq_neg]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} [NoZeroDivisors R] : a ^ 2 = 1 ↔ a = 1 ∨ a = -1",
  "args":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} [NoZeroDivisors R]"},
 {"type": "(a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] (a b : R) : (a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2 := by rw [sub_eq_add_neg]; sorry",
  "name": "sub_sq",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] (a b : R) : (a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2",
  "args":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] (a b : R)"},
 {"type": "(a - b) ^ 2 = a ^ 2 + b ^ 2 - 2 * a * b",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] (a b : R) : (a - b) ^ 2 = a ^ 2 + b ^ 2 - 2 * a * b := by rw [sub_eq_add_neg]; sorry",
  "name": "sub_sq'",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] (a b : R) : (a - b) ^ 2 = a ^ 2 + b ^ 2 - 2 * a * b",
  "args":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] (a b : R)"},
 {"type": "a ^ 2 = b ^ 2 ↔ a = b ∨ a = -b",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] [NoZeroDivisors R]  {a b : R} {a b : Rˣ} : a ^ 2 = b ^ 2 ↔ a = b ∨ a = -b := by simp_rw [ext_iff]; sorry",
  "name": "sq_eq_sq_iff_eq_or_eq_neg",
  "kind": "theorem",
  "first-tactic": "simp_rw [ext_iff]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] [NoZeroDivisors R]  {a b : R} {a b : Rˣ} : a ^ 2 = b ^ 2 ↔ a = b ∨ a = -b",
  "args":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] [NoZeroDivisors R]  {a b : R} {a b : Rˣ}"},
 {"type": "(a ^ if P then b else c) = if P then a ^ b else a ^ c",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Pow M ℕ] (P : Prop)  [Decidable P]  (a : M)  (b c : ℕ) : (a ^ if P then b else c) = if P then a ^ b else a ^ c := by split_ifs; sorry",
  "name": "pow_ite",
  "kind": "theorem",
  "first-tactic": "split_ifs",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Pow M ℕ] (P : Prop)  [Decidable P]  (a : M)  (b c : ℕ) : (a ^ if P then b else c) = if P then a ^ b else a ^ c",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Pow M ℕ] (P : Prop)  [Decidable P]  (a : M)  (b c : ℕ)"},
 {"type": "(if P then a else b) ^ c = if P then a ^ c else b ^ c",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Pow M ℕ] (P : Prop)  [Decidable P]  (a b : M)  (c : ℕ) : (if P then a else b) ^ c = if P then a ^ c else b ^ c := by split_ifs; sorry",
  "name": "ite_pow",
  "kind": "theorem",
  "first-tactic": "split_ifs",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Pow M ℕ] (P : Prop)  [Decidable P]  (a b : M)  (c : ℕ) : (if P then a else b) ^ c = if P then a ^ c else b ^ c",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Pow M ℕ] (P : Prop)  [Decidable P]  (a b : M)  (c : ℕ)"},
 {"type": "n • (0 : A) = 0",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (n : ℕ) : n • (0 : A) = 0 := by induction' n with n ih; sorry",
  "name": "nsmul_zero",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (n : ℕ) : n • (0 : A) = 0",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (n : ℕ)"},
 {"type": "1 • a = a",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : A) : 1 • a = a := by rw [succ_nsmul]; sorry",
  "name": "one_nsmul",
  "kind": "theorem",
  "first-tactic": "rw [succ_nsmul]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : A) : 1 • a = a",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : A)"},
 {"type": "(m + n) • a = m • a + n • a",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : A)  (m n : ℕ) : (m + n) • a = m • a + n • a := by induction m; sorry",
  "name": "add_nsmul",
  "kind": "theorem",
  "first-tactic": "induction m",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : A)  (m n : ℕ) : (m + n) • a = m • a + n • a",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : A)  (m n : ℕ)"},
 {"type": "(1 : M) ^ n = 1",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (n : ℕ) : (1 : M) ^ n = 1 := by induction' n with n ih; sorry",
  "name": "one_pow",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (n : ℕ) : (1 : M) ^ n = 1",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (n : ℕ)"},
 {"type": "a ^ 1 = a",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M) : a ^ 1 = a := by rw [pow_succ]; sorry",
  "name": "pow_one",
  "kind": "theorem",
  "first-tactic": "rw [pow_succ]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M) : a ^ 1 = a",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)"},
 {"type": "a ^ 2 = a * a",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M) : a ^ 2 = a * a := by rw [pow_succ]; sorry",
  "name": "pow_two",
  "kind": "theorem",
  "first-tactic": "rw [pow_succ]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M) : a ^ 2 = a * a",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)"},
 {"type": "a ^ 3 = a * a * a",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M) : a ^ 3 = a * a * a := by rw [pow_succ']; sorry",
  "name": "pow_three'",
  "kind": "theorem",
  "first-tactic": "rw [pow_succ']",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M) : a ^ 3 = a * a * a",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)"},
 {"type": "a ^ 3 = a * (a * a)",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M) : a ^ 3 = a * (a * a) := by rw [pow_succ]; sorry",
  "name": "pow_three",
  "kind": "theorem",
  "first-tactic": "rw [pow_succ]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M) : a ^ 3 = a * (a * a)",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)"},
 {"type": "a ^ (m + n) = a ^ m * a ^ n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  (m n : ℕ) : a ^ (m + n) = a ^ m * a ^ n := by induction' n with n ih; sorry",
  "name": "pow_add",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  (m n : ℕ) : a ^ (m + n) = a ^ m * a ^ n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  (m n : ℕ)"},
 {"type": "a ^ (m * n) = (a ^ m) ^ n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  (m n : ℕ) : a ^ (m * n) = (a ^ m) ^ n := by induction' n with n ih; sorry",
  "name": "pow_mul",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  (m n : ℕ) : a ^ (m * n) = (a ^ m) ^ n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  (m n : ℕ)"},
 {"type": "a ^ (m * n) = (a ^ n) ^ m",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  (m n : ℕ) : a ^ (m * n) = (a ^ n) ^ m := by rw [Nat.mul_comm]; sorry",
  "name": "pow_mul'",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  (m n : ℕ) : a ^ (m * n) = (a ^ n) ^ m",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  (m n : ℕ)"},
 {"type": "(a * b) ^ n = a ^ n * b ^ n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] {a b : M}  (h : Commute a b)  (n : ℕ) : (a * b) ^ n = a ^ n * b ^ n := by induction' n with n ih; sorry",
  "name": "Commute.mul_pow",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] {a b : M}  (h : Commute a b)  (n : ℕ) : (a * b) ^ n = a ^ n * b ^ n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] {a b : M}  (h : Commute a b)  (n : ℕ)"},
 {"type": "(a ^ if P then 1 else 0) = if P then a else 1",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (P : Prop)  [Decidable P]  (a : M) : (a ^ if P then 1 else 0) = if P then a else 1 := by simp; sorry",
  "name": "pow_boole",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (P : Prop)  [Decidable P]  (a : M) : (a ^ if P then 1 else 0) = if P then a else 1",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (P : Prop)  [Decidable P]  (a : M)"},
 {"type": "(a ^ m) ^ n = (a ^ n) ^ m",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  (m n : ℕ) : (a ^ m) ^ n = (a ^ n) ^ m := by rw [← pow_mul]; sorry",
  "name": "pow_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [← pow_mul]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  (m n : ℕ) : (a ^ m) ^ n = (a ^ n) ^ m",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  (m n : ℕ)"},
 {"type": "a ^ m * a ^ (n - m) = a ^ n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  {m n : ℕ}  (h : m ≤ n) : a ^ m * a ^ (n - m) = a ^ n := by rw [← pow_add]; sorry",
  "name": "pow_mul_pow_sub",
  "kind": "theorem",
  "first-tactic": "rw [← pow_add]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  {m n : ℕ}  (h : m ≤ n) : a ^ m * a ^ (n - m) = a ^ n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  {m n : ℕ}  (h : m ≤ n)"},
 {"type": "a ^ (n - m) * a ^ m = a ^ n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  {m n : ℕ}  (h : m ≤ n) : a ^ (n - m) * a ^ m = a ^ n := by rw [← pow_add]; sorry",
  "name": "pow_sub_mul_pow",
  "kind": "theorem",
  "first-tactic": "rw [← pow_add]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  {m n : ℕ}  (h : m ≤ n) : a ^ (n - m) * a ^ m = a ^ n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] (a : M)  {m n : ℕ}  (h : m ≤ n)"},
 {"type": "x ^ m = x ^ (m % n)",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] {M : Type _}  [Monoid M]  {x : M}  (m : ℕ)  {n : ℕ}  (h : x ^ n = 1) : x ^ m = x ^ (m % n) := by have t : x ^ m = x ^ (n * (m / n) + m % n) :=\n    congr_arg (fun a => x ^ a) ((Nat.add_comm _ _).trans (Nat.mod_add_div _ _)).symm; sorry",
  "name": "pow_eq_pow_mod",
  "kind": "theorem",
  "first-tactic":
  "have t : x ^ m = x ^ (n * (m / n) + m % n) :=\n    congr_arg (fun a => x ^ a) ((Nat.add_comm _ _).trans (Nat.mod_add_div _ _)).symm",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] {M : Type _}  [Monoid M]  {x : M}  (m : ℕ)  {n : ℕ}  (h : x ^ n = 1) : x ^ m = x ^ (m % n)",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] {M : Type _}  [Monoid M]  {x : M}  (m : ℕ)  {n : ℕ}  (h : x ^ n = 1)"},
 {"type": "a ^ bit1 n = a ^ n * a ^ n * a",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A]  (a : M)  (n : ℕ) : a ^ bit1 n = a ^ n * a ^ n * a := by rw [bit1]; sorry",
  "name": "pow_bit1",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A]  (a : M)  (n : ℕ) : a ^ bit1 n = a ^ n * a ^ n * a",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A]  (a : M)  (n : ℕ)"},
 {"type": "a ^ bit0 n = (a * a) ^ n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A]  (a : M)  (n : ℕ) : a ^ bit0 n = (a * a) ^ n := by rw [pow_bit0]; sorry",
  "name": "pow_bit0'",
  "kind": "theorem",
  "first-tactic": "rw [pow_bit0]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A]  (a : M)  (n : ℕ) : a ^ bit0 n = (a * a) ^ n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A]  (a : M)  (n : ℕ)"},
 {"type": "a ^ bit1 n = (a * a) ^ n * a",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A]  (a : M)  (n : ℕ) : a ^ bit1 n = (a * a) ^ n * a := by rw [bit1]; sorry",
  "name": "pow_bit1'",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A]  (a : M)  (n : ℕ) : a ^ bit1 n = (a * a) ^ n * a",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A]  (a : M)  (n : ℕ)"},
 {"type": "a ^ n * b ^ n = 1",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] {a b : M}  (n : ℕ)  (h : a * b = 1) : a ^ n * b ^ n = 1 := by induction' n with n hn; sorry",
  "name": "pow_mul_pow_eq_one",
  "kind": "theorem",
  "first-tactic": "induction' n with n hn",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] {a b : M}  (n : ℕ)  (h : a * b = 1) : a ^ n * b ^ n = 1",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [AddMonoid A] {a b : M}  (n : ℕ)  (h : a * b = 1)"},
 {"type": "a ^ (1 : ℤ) = a",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivInvMonoid G] (a : G) : a ^ (1 : ℤ) = a := by convert pow_one a using 1; sorry",
  "name": "zpow_one",
  "kind": "theorem",
  "first-tactic": "convert pow_one a using 1",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivInvMonoid G] (a : G) : a ^ (1 : ℤ) = a",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivInvMonoid G] (a : G)"},
 {"type": "a ^ (2 : ℤ) = a * a",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivInvMonoid G] (a : G) : a ^ (2 : ℤ) = a * a := by convert pow_two a using 1; sorry",
  "name": "zpow_two",
  "kind": "theorem",
  "first-tactic": "convert pow_two a using 1",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivInvMonoid G] (a : G) : a ^ (2 : ℤ) = a * a",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivInvMonoid G] (a : G)"},
 {"type": "(a * b) ^ (-1 : ℤ) = b ^ (-1 : ℤ) * a ^ (-1 : ℤ)",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  {a b : α} (a b : α) : (a * b) ^ (-1 : ℤ) = b ^ (-1 : ℤ) * a ^ (-1 : ℤ) := by simp only [zpow_neg]; sorry",
  "name": "mul_zpow_neg_one",
  "kind": "theorem",
  "first-tactic": "simp only [zpow_neg]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  {a b : α} (a b : α) : (a * b) ^ (-1 : ℤ) = b ^ (-1 : ℤ) * a ^ (-1 : ℤ)",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  {a b : α} (a b : α)"},
 {"type": "a⁻¹ ^ n = a ^ (-n)",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  {a b : α} (a : α)  (n : ℤ) : a⁻¹ ^ n = a ^ (-n) := by rw [inv_zpow]; sorry",
  "name": "inv_zpow'",
  "kind": "theorem",
  "first-tactic": "rw [inv_zpow]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  {a b : α} (a : α)  (n : ℤ) : a⁻¹ ^ n = a ^ (-n)",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  {a b : α} (a : α)  (n : ℤ)"},
 {"type": "(1 / a) ^ n = 1 / a ^ n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  {a b : α} (a : α)  (n : ℕ) : (1 / a) ^ n = 1 / a ^ n := by simp only [one_div]; sorry",
  "name": "one_div_pow",
  "kind": "theorem",
  "first-tactic": "simp only [one_div]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  {a b : α} (a : α)  (n : ℕ) : (1 / a) ^ n = 1 / a ^ n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  {a b : α} (a : α)  (n : ℕ)"},
 {"type": "(1 / a) ^ n = 1 / a ^ n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  {a b : α} (a : α)  (n : ℤ) : (1 / a) ^ n = 1 / a ^ n := by simp only [one_div]; sorry",
  "name": "one_div_zpow",
  "kind": "theorem",
  "first-tactic": "simp only [one_div]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  {a b : α} (a : α)  (n : ℤ) : (1 / a) ^ n = 1 / a ^ n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  {a b : α} (a : α)  (n : ℤ)"},
 {"type": "(a / b) ^ n = a ^ n / b ^ n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionCommMonoid α] (a b : α)  (n : ℕ) : (a / b) ^ n = a ^ n / b ^ n := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_pow",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionCommMonoid α] (a b : α)  (n : ℕ) : (a / b) ^ n = a ^ n / b ^ n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionCommMonoid α] (a b : α)  (n : ℕ)"},
 {"type": "(a / b) ^ n = a ^ n / b ^ n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionCommMonoid α] (a b : α)  (n : ℤ) : (a / b) ^ n = a ^ n / b ^ n := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_zpow",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionCommMonoid α] (a b : α)  (n : ℤ) : (a / b) ^ n = a ^ n / b ^ n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionCommMonoid α] (a b : α)  (n : ℤ)"},
 {"type": "a⁻¹ ^ (m - n) = (a ^ m)⁻¹ * a ^ n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G]  [Group H]  [AddGroup A]  [AddGroup B] (a : G)  {m n : ℕ}  (h : n ≤ m) : a⁻¹ ^ (m - n) = (a ^ m)⁻¹ * a ^ n := by rw [pow_sub a⁻¹ h]; sorry",
  "name": "inv_pow_sub",
  "kind": "theorem",
  "first-tactic": "rw [pow_sub a⁻¹ h]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G]  [Group H]  [AddGroup A]  [AddGroup B] (a : G)  {m n : ℕ}  (h : n ≤ m) : a⁻¹ ^ (m - n) = (a ^ m)⁻¹ * a ^ n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G]  [Group H]  [AddGroup A]  [AddGroup B] (a : G)  {m n : ℕ}  (h : n ≤ m)"},
 {"type":
  "(x₁ ^ 2 + x₂ ^ 2) * (y₁ ^ 2 + y₂ ^ 2) = (x₁ * y₁ - x₂ * y₂) ^ 2 + (x₁ * y₂ + x₂ * y₁) ^ 2",
  "tactic-prompt":
  "theorem {R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R} : (x₁ ^ 2 + x₂ ^ 2) * (y₁ ^ 2 + y₂ ^ 2) = (x₁ * y₁ - x₂ * y₂) ^ 2 + (x₁ * y₂ + x₂ * y₁) ^ 2 := by ring; sorry",
  "name": "sq_add_sq_mul_sq_add_sq",
  "kind": "theorem",
  "first-tactic": "ring",
  "core-prompt":
  "{R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R} : (x₁ ^ 2 + x₂ ^ 2) * (y₁ ^ 2 + y₂ ^ 2) = (x₁ * y₁ - x₂ * y₂) ^ 2 + (x₁ * y₂ + x₂ * y₁) ^ 2",
  "args":
  "{R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R}"},
 {"type":
  "(x₁ ^ 2 + n * x₂ ^ 2) * (y₁ ^ 2 + n * y₂ ^ 2) =\n    (x₁ * y₁ - n * x₂ * y₂) ^ 2 + n * (x₁ * y₂ + x₂ * y₁) ^ 2",
  "tactic-prompt":
  "theorem {R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R} : (x₁ ^ 2 + n * x₂ ^ 2) * (y₁ ^ 2 + n * y₂ ^ 2) =\n    (x₁ * y₁ - n * x₂ * y₂) ^ 2 + n * (x₁ * y₂ + x₂ * y₁) ^ 2 := by ring; sorry",
  "name": "sq_add_mul_sq_mul_sq_add_mul_sq",
  "kind": "theorem",
  "first-tactic": "ring",
  "core-prompt":
  "{R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R} : (x₁ ^ 2 + n * x₂ ^ 2) * (y₁ ^ 2 + n * y₂ ^ 2) =\n    (x₁ * y₁ - n * x₂ * y₂) ^ 2 + n * (x₁ * y₂ + x₂ * y₁) ^ 2",
  "args":
  "{R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R}"},
 {"type": "a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)",
  "tactic-prompt":
  "theorem {R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2) := by ring; sorry",
  "name": "pow_four_add_four_mul_pow_four",
  "kind": "theorem",
  "first-tactic": "ring",
  "core-prompt":
  "{R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)",
  "args":
  "{R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R}"},
 {"type":
  "a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)",
  "tactic-prompt":
  "theorem {R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R} : a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2) := by ring; sorry",
  "name": "pow_four_add_four_mul_pow_four'",
  "kind": "theorem",
  "first-tactic": "ring",
  "core-prompt":
  "{R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R} : a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)",
  "args":
  "{R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R}"},
 {"type":
  "(x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2) * (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2) =\n      (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄) ^ 2 + (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃) ^ 2 +\n          (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂) ^ 2 +\n        (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁) ^ 2",
  "tactic-prompt":
  "theorem {R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R} : (x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2) * (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2) =\n      (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄) ^ 2 + (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃) ^ 2 +\n          (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂) ^ 2 +\n        (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁) ^ 2 := by ring; sorry",
  "name": "sum_four_sq_mul_sum_four_sq",
  "kind": "theorem",
  "first-tactic": "ring",
  "core-prompt":
  "{R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R} : (x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2) * (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2) =\n      (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄) ^ 2 + (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃) ^ 2 +\n          (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂) ^ 2 +\n        (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁) ^ 2",
  "args":
  "{R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R}"},
 {"type":
  "(x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 + x₅ ^ 2 + x₆ ^ 2 + x₇ ^ 2 + x₈ ^ 2) *\n      (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 + y₅ ^ 2 + y₆ ^ 2 + y₇ ^ 2 + y₈ ^ 2) =\n    (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄ - x₅ * y₅ - x₆ * y₆ - x₇ * y₇ - x₈ * y₈) ^ 2 +\n      (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃ + x₅ * y₆ - x₆ * y₅ - x₇ * y₈ + x₈ * y₇) ^ 2 +\n      (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂ + x₅ * y₇ + x₆ * y₈ - x₇ * y₅ - x₈ * y₆) ^ 2 +\n      (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁ + x₅ * y₈ - x₆ * y₇ + x₇ * y₆ - x₈ * y₅) ^ 2 +\n      (x₁ * y₅ - x₂ * y₆ - x₃ * y₇ - x₄ * y₈ + x₅ * y₁ + x₆ * y₂ + x₇ * y₃ + x₈ * y₄) ^ 2 +\n      (x₁ * y₆ + x₂ * y₅ - x₃ * y₈ + x₄ * y₇ - x₅ * y₂ + x₆ * y₁ - x₇ * y₄ + x₈ * y₃) ^ 2 +\n      (x₁ * y₇ + x₂ * y₈ + x₃ * y₅ - x₄ * y₆ - x₅ * y₃ + x₆ * y₄ + x₇ * y₁ - x₈ * y₂) ^ 2 +\n      (x₁ * y₈ - x₂ * y₇ + x₃ * y₆ + x₄ * y₅ - x₅ * y₄ - x₆ * y₃ + x₇ * y₂ + x₈ * y₁) ^ 2",
  "tactic-prompt":
  "theorem {R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R} : (x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 + x₅ ^ 2 + x₆ ^ 2 + x₇ ^ 2 + x₈ ^ 2) *\n      (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 + y₅ ^ 2 + y₆ ^ 2 + y₇ ^ 2 + y₈ ^ 2) =\n    (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄ - x₅ * y₅ - x₆ * y₆ - x₇ * y₇ - x₈ * y₈) ^ 2 +\n      (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃ + x₅ * y₆ - x₆ * y₅ - x₇ * y₈ + x₈ * y₇) ^ 2 +\n      (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂ + x₅ * y₇ + x₆ * y₈ - x₇ * y₅ - x₈ * y₆) ^ 2 +\n      (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁ + x₅ * y₈ - x₆ * y₇ + x₇ * y₆ - x₈ * y₅) ^ 2 +\n      (x₁ * y₅ - x₂ * y₆ - x₃ * y₇ - x₄ * y₈ + x₅ * y₁ + x₆ * y₂ + x₇ * y₃ + x₈ * y₄) ^ 2 +\n      (x₁ * y₆ + x₂ * y₅ - x₃ * y₈ + x₄ * y₇ - x₅ * y₂ + x₆ * y₁ - x₇ * y₄ + x₈ * y₃) ^ 2 +\n      (x₁ * y₇ + x₂ * y₈ + x₃ * y₅ - x₄ * y₆ - x₅ * y₃ + x₆ * y₄ + x₇ * y₁ - x₈ * y₂) ^ 2 +\n      (x₁ * y₈ - x₂ * y₇ + x₃ * y₆ + x₄ * y₅ - x₅ * y₄ - x₆ * y₃ + x₇ * y₂ + x₈ * y₁) ^ 2 := by ring; sorry",
  "name": "sum_eight_sq_mul_sum_eight_sq",
  "kind": "theorem",
  "first-tactic": "ring",
  "core-prompt":
  "{R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R} : (x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 + x₅ ^ 2 + x₆ ^ 2 + x₇ ^ 2 + x₈ ^ 2) *\n      (y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 + y₅ ^ 2 + y₆ ^ 2 + y₇ ^ 2 + y₈ ^ 2) =\n    (x₁ * y₁ - x₂ * y₂ - x₃ * y₃ - x₄ * y₄ - x₅ * y₅ - x₆ * y₆ - x₇ * y₇ - x₈ * y₈) ^ 2 +\n      (x₁ * y₂ + x₂ * y₁ + x₃ * y₄ - x₄ * y₃ + x₅ * y₆ - x₆ * y₅ - x₇ * y₈ + x₈ * y₇) ^ 2 +\n      (x₁ * y₃ - x₂ * y₄ + x₃ * y₁ + x₄ * y₂ + x₅ * y₇ + x₆ * y₈ - x₇ * y₅ - x₈ * y₆) ^ 2 +\n      (x₁ * y₄ + x₂ * y₃ - x₃ * y₂ + x₄ * y₁ + x₅ * y₈ - x₆ * y₇ + x₇ * y₆ - x₈ * y₅) ^ 2 +\n      (x₁ * y₅ - x₂ * y₆ - x₃ * y₇ - x₄ * y₈ + x₅ * y₁ + x₆ * y₂ + x₇ * y₃ + x₈ * y₄) ^ 2 +\n      (x₁ * y₆ + x₂ * y₅ - x₃ * y₈ + x₄ * y₇ - x₅ * y₂ + x₆ * y₁ - x₇ * y₄ + x₈ * y₃) ^ 2 +\n      (x₁ * y₇ + x₂ * y₈ + x₃ * y₅ - x₄ * y₆ - x₅ * y₃ + x₆ * y₄ + x₇ * y₁ - x₈ * y₂) ^ 2 +\n      (x₁ * y₈ - x₂ * y₇ + x₃ * y₆ + x₄ * y₅ - x₅ * y₄ - x₆ * y₃ + x₇ * y₂ + x₈ * y₁) ^ 2",
  "args":
  "{R : Type _}  [CommRing R]  {a b x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ y₁ y₂ y₃ y₄ y₅ y₆ y₇ y₈ n : R}"},
 {"type": "∀ n : ℕ, n • (1 : A) = n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [AddMonoidWithOne A] : ∀ n : ℕ, n • (1 : A) = n := by let f : ℕ →+ A :=\n  { toFun := fun n ↦ n • (1 : A),\n    map_zero' := by simp [zero_nsmul],\n    map_add' := by simp [add_nsmul] }; sorry",
  "name": "nsmul_one",
  "kind": "theorem",
  "first-tactic":
  "let f : ℕ →+ A :=\n  { toFun := fun n ↦ n • (1 : A),\n    map_zero' := by simp [zero_nsmul],\n    map_add' := by simp [add_nsmul] }",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [AddMonoidWithOne A] : ∀ n : ℕ, n • (1 : A) = n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [AddMonoidWithOne A]"},
 {"type": "(k • x) ^ p = k ^ p • x ^ p",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [Monoid N]  [AddMonoid A]  [AddMonoid B] [MulAction M N]  [IsScalarTower M N N]  [SMulCommClass M N N]  (k : M)  (x : N)      (p : ℕ) : (k • x) ^ p = k ^ p • x ^ p := by induction' p with p IH; sorry",
  "name": "smul_pow",
  "kind": "theorem",
  "first-tactic": "induction' p with p IH",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [Monoid N]  [AddMonoid A]  [AddMonoid B] [MulAction M N]  [IsScalarTower M N N]  [SMulCommClass M N N]  (k : M)  (x : N)      (p : ℕ) : (k • x) ^ p = k ^ p • x ^ p",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [Monoid N]  [AddMonoid A]  [AddMonoid B] [MulAction M N]  [IsScalarTower M N N]  [SMulCommClass M N N]  (k : M)  (x : N)      (p : ℕ)"},
 {"type": "x • m ^ n = (x • m) ^ n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [Monoid N]  [AddMonoid A]  [AddMonoid B] [MulDistribMulAction M N]  (x : M)  (m : N)  (n : ℕ) : x • m ^ n = (x • m) ^ n := by induction' n with n ih; sorry",
  "name": "smul_pow'",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [Monoid N]  [AddMonoid A]  [AddMonoid B] [MulDistribMulAction M N]  (x : M)  (m : N)  (n : ℕ) : x • m ^ n = (x • m) ^ n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Monoid M]  [Monoid N]  [AddMonoid A]  [AddMonoid B] [MulDistribMulAction M N]  (x : M)  (m : N)  (n : ℕ)"},
 {"type": "n • (1 : A) = n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [AddGroupWithOne A]  (n : ℤ) : n • (1 : A) = n := by cases n; sorry",
  "name": "zsmul_one",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [AddGroupWithOne A]  (n : ℤ) : n • (1 : A) = n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [AddGroupWithOne A]  (n : ℤ)"},
 {"type": "a ^ (m * n) = (a ^ n) ^ m",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  -- Note that `mul_zsmul` and `zpow_mul` have the primes swapped -- when additivised since their argument order, -- and therefore the more \"natural\" choice of lemma, is reversed. (a : α)  (m n : ℤ) : a ^ (m * n) = (a ^ n) ^ m := by rw [mul_comm]; sorry",
  "name": "zpow_mul'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  -- Note that `mul_zsmul` and `zpow_mul` have the primes swapped -- when additivised since their argument order, -- and therefore the more \"natural\" choice of lemma, is reversed. (a : α)  (m n : ℤ) : a ^ (m * n) = (a ^ n) ^ m",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  -- Note that `mul_zsmul` and `zpow_mul` have the primes swapped -- when additivised since their argument order, -- and therefore the more \"natural\" choice of lemma, is reversed. (a : α)  (m n : ℤ)"},
 {"type": "(-x) ^ bit0 n = x ^ bit0 n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  -- Note that `mul_zsmul` and `zpow_mul` have the primes swapped -- when additivised since their argument order, -- and therefore the more \"natural\" choice of lemma, is reversed.  [HasDistribNeg α]  (x : α)  (n : ℤ) : (-x) ^ bit0 n = x ^ bit0 n := by rw [zpow_bit0']; sorry",
  "name": "zpow_bit0_neg",
  "kind": "theorem",
  "first-tactic": "rw [zpow_bit0']",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  -- Note that `mul_zsmul` and `zpow_mul` have the primes swapped -- when additivised since their argument order, -- and therefore the more \"natural\" choice of lemma, is reversed.  [HasDistribNeg α]  (x : α)  (n : ℤ) : (-x) ^ bit0 n = x ^ bit0 n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [DivisionMonoid α]  -- Note that `mul_zsmul` and `zpow_mul` have the primes swapped -- when additivised since their argument order, -- and therefore the more \"natural\" choice of lemma, is reversed.  [HasDistribNeg α]  (x : α)  (n : ℤ)"},
 {"type": "a ^ (m + n) = a ^ m * a ^ n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G] (a : G)  (m n : ℤ) : a ^ (m + n) = a ^ m * a ^ n := by induction' n using Int.induction_on with n ihn n ihn; sorry",
  "name": "zpow_add",
  "kind": "theorem",
  "first-tactic": "induction' n using Int.induction_on with n ihn n ihn",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G] (a : G)  (m n : ℤ) : a ^ (m + n) = a ^ m * a ^ n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G] (a : G)  (m n : ℤ)"},
 {"type": "b * b ^ m = b ^ (m + 1)",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G] (b : G)  (m : ℤ) : b * b ^ m = b ^ (m + 1) := by conv_lhs =>\n    congr\n    rw [← zpow_one b]; sorry",
  "name": "mul_self_zpow",
  "kind": "theorem",
  "first-tactic": "conv_lhs =>\n    congr\n    rw [← zpow_one b]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G] (b : G)  (m : ℤ) : b * b ^ m = b ^ (m + 1)",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G] (b : G)  (m : ℤ)"},
 {"type": "b ^ m * b = b ^ (m + 1)",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G] (b : G)  (m : ℤ) : b ^ m * b = b ^ (m + 1) := by conv_lhs =>\n    congr\n    · skip\n    rw [← zpow_one b]; sorry",
  "name": "mul_zpow_self",
  "kind": "theorem",
  "first-tactic": "conv_lhs =>\n    congr\n    · skip\n    rw [← zpow_one b]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G] (b : G)  (m : ℤ) : b ^ m * b = b ^ (m + 1)",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G] (b : G)  (m : ℤ)"},
 {"type": "a ^ (m - n) = a ^ m * (a ^ n)⁻¹",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G] (a : G)  (m n : ℤ) : a ^ (m - n) = a ^ m * (a ^ n)⁻¹ := by rw [sub_eq_add_neg]; sorry",
  "name": "zpow_sub",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G] (a : G)  (m n : ℤ) : a ^ (m - n) = a ^ m * (a ^ n)⁻¹",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G] (a : G)  (m n : ℤ)"},
 {"type": "a ^ (1 + i) = a * a ^ i",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G] (a : G)  (i : ℤ) : a ^ (1 + i) = a * a ^ i := by rw [zpow_add]; sorry",
  "name": "zpow_one_add",
  "kind": "theorem",
  "first-tactic": "rw [zpow_add]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G] (a : G)  (i : ℤ) : a ^ (1 + i) = a * a ^ i",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G] (a : G)  (i : ℤ)"},
 {"type": "a ^ bit1 n = a ^ n * a ^ n * a",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G]  (a : G)  (n : ℤ) : a ^ bit1 n = a ^ n * a ^ n * a := by rw [bit1]; sorry",
  "name": "zpow_bit1",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G]  (a : G)  (n : ℤ) : a ^ bit1 n = a ^ n * a ^ n * a",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [Group G]  (a : G)  (n : ℤ)"},
 {"type": "1 < a ^ k",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [OrderedCommGroup α]  {m n : ℤ}  {a b : α} (ha : 1 < a)  {k : ℤ}  (hk : (0 : ℤ) < k) : 1 < a ^ k := by obtain ⟨n, hn⟩ := Int.eq_ofNat_of_zero_le hk.le; sorry",
  "name": "one_lt_zpow'",
  "kind": "theorem",
  "first-tactic": "obtain ⟨n, hn⟩ := Int.eq_ofNat_of_zero_le hk.le",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [OrderedCommGroup α]  {m n : ℤ}  {a b : α} (ha : 1 < a)  {k : ℤ}  (hk : (0 : ℤ) < k) : 1 < a ^ k",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [OrderedCommGroup α]  {m n : ℤ}  {a b : α} (ha : 1 < a)  {k : ℤ}  (hk : (0 : ℤ) < k)"},
 {"type": "Function.Injective ((· ^ n) : α → α)",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedCommGroup α]  {n : ℤ}  {a b : α} (hn : n ≠ 0) : Function.Injective ((· ^ n) : α → α) := by rcases hn.symm.lt_or_lt with (h | h); sorry",
  "name": "zpow_left_injective",
  "kind": "theorem",
  "first-tactic": "rcases hn.symm.lt_or_lt with (h | h)",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedCommGroup α]  {n : ℤ}  {a b : α} (hn : n ≠ 0) : Function.Injective ((· ^ n) : α → α)",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedCommGroup α]  {n : ℤ}  {a b : α} (hn : n ≠ 0)"},
 {"type": "|n • a| = n • |a|",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedAddCommGroup α]  {a b : α} (n : ℕ)  (a : α) : |n • a| = n • |a| := by cases' le_total a 0 with hneg hpos; sorry",
  "name": "abs_nsmul",
  "kind": "theorem",
  "first-tactic": "cases' le_total a 0 with hneg hpos",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedAddCommGroup α]  {a b : α} (n : ℕ)  (a : α) : |n • a| = n • |a|",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedAddCommGroup α]  {a b : α} (n : ℕ)  (a : α)"},
 {"type": "|n • a| = |n| • |a|",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedAddCommGroup α]  {a b : α} (n : ℤ)  (a : α) : |n • a| = |n| • |a| := by obtain n0 | n0 := le_total 0 n; sorry",
  "name": "abs_zsmul",
  "kind": "theorem",
  "first-tactic": "obtain n0 | n0 := le_total 0 n",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedAddCommGroup α]  {a b : α} (n : ℤ)  (a : α) : |n • a| = |n| • |a|",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedAddCommGroup α]  {a b : α} (n : ℤ)  (a : α)"},
 {"type": "|a + b| = |a| + |b| ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedAddCommGroup α]  {a b : α} (hle : a ≤ b) : |a + b| = |a| + |b| ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0 := by obtain a0 | a0 := le_or_lt 0 a; sorry",
  "name": "abs_add_eq_add_abs_le",
  "kind": "theorem",
  "first-tactic": "obtain a0 | a0 := le_or_lt 0 a",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedAddCommGroup α]  {a b : α} (hle : a ≤ b) : |a + b| = |a| + |b| ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedAddCommGroup α]  {a b : α} (hle : a ≤ b)"},
 {"type": "|a + b| = |a| + |b| ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedAddCommGroup α]  {a b : α} (a b : α) : |a + b| = |a| + |b| ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0 := by obtain ab | ab := le_total a b; sorry",
  "name": "abs_add_eq_add_abs_iff",
  "kind": "theorem",
  "first-tactic": "obtain ab | ab := le_total a b",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedAddCommGroup α]  {a b : α} (a b : α) : |a + b| = |a| + |b| ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedAddCommGroup α]  {a b : α} (a b : α)"},
 {"type": "n • a = n * a",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [NonAssocSemiring R]  (n : ℕ)  (a : R) : n • a = n * a := by rw [nsmul_eq_mul']; sorry",
  "name": "nsmul_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [nsmul_eq_mul']",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [NonAssocSemiring R]  (n : ℕ)  (a : R) : n • a = n * a",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [NonAssocSemiring R]  (n : ℕ)  (a : R)"},
 {"type": "(↑(n ^ m) : R) = (↑n : R) ^ m",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Semiring R]  (n m : ℕ) : (↑(n ^ m) : R) = (↑n : R) ^ m := by induction' m with m ih; sorry",
  "name": "Nat.cast_pow",
  "kind": "theorem",
  "first-tactic": "induction' m with m ih",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Semiring R]  (n m : ℕ) : (↑(n ^ m) : R) = (↑n : R) ^ m",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Semiring R]  (n m : ℕ)"},
 {"type": "((n ^ m : ℕ) : ℤ) = (n : ℤ) ^ m",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (n m : ℕ) : ((n ^ m : ℕ) : ℤ) = (n : ℤ) ^ m := by induction' m with m _; sorry",
  "name": "Int.coe_nat_pow",
  "kind": "theorem",
  "first-tactic": "induction' m with m _",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (n m : ℕ) : ((n ^ m : ℕ) : ℤ) = (n : ℤ) ^ m",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (n m : ℕ)"},
 {"type": "bit0 n * r = (2 : ℤ) • (n * r)",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [NonUnitalNonAssocRing R]  {n r : R} : bit0 n * r = (2 : ℤ) • (n * r) := by dsimp [bit0]; sorry",
  "name": "bit0_mul",
  "kind": "theorem",
  "first-tactic": "dsimp [bit0]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [NonUnitalNonAssocRing R]  {n r : R} : bit0 n * r = (2 : ℤ) • (n * r)",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [NonUnitalNonAssocRing R]  {n r : R}"},
 {"type": "r * bit0 n = (2 : ℤ) • (r * n)",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [NonUnitalNonAssocRing R]  {n r : R} : r * bit0 n = (2 : ℤ) • (r * n) := by dsimp [bit0]; sorry",
  "name": "mul_bit0",
  "kind": "theorem",
  "first-tactic": "dsimp [bit0]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [NonUnitalNonAssocRing R]  {n r : R} : r * bit0 n = (2 : ℤ) • (r * n)",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [NonUnitalNonAssocRing R]  {n r : R}"},
 {"type": "bit1 n * r = (2 : ℤ) • (n * r) + r",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [NonAssocRing R]  {n r : R} : bit1 n * r = (2 : ℤ) • (n * r) + r := by dsimp [bit1]; sorry",
  "name": "bit1_mul",
  "kind": "theorem",
  "first-tactic": "dsimp [bit1]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [NonAssocRing R]  {n r : R} : bit1 n * r = (2 : ℤ) • (n * r) + r",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [NonAssocRing R]  {n r : R}"},
 {"type": "r * bit1 n = (2 : ℤ) • (r * n) + r",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [NonAssocRing R]  {n r : R} : r * bit1 n = (2 : ℤ) • (r * n) + r := by dsimp [bit1]; sorry",
  "name": "mul_bit1",
  "kind": "theorem",
  "first-tactic": "dsimp [bit1]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [NonAssocRing R]  {n r : R} : r * bit1 n = (2 : ℤ) • (r * n) + r",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [NonAssocRing R]  {n r : R}"},
 {"type": "n • a = a * n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Ring R]  (a : R)  (n : ℤ) : n • a = a * n := by rw [zsmul_eq_mul]; sorry",
  "name": "zsmul_eq_mul'",
  "kind": "theorem",
  "first-tactic": "rw [zsmul_eq_mul]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Ring R]  (a : R)  (n : ℤ) : n • a = a * n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Ring R]  (a : R)  (n : ℤ)"},
 {"type": "a • b = a * b",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (a b : ℤ) : a • b = a * b := by simp; sorry",
  "name": "zsmul_int_int",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (a b : ℤ) : a • b = a * b",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (a b : ℤ)"},
 {"type": "n • (1 : ℤ) = n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (n : ℤ) : n • (1 : ℤ) = n := by simp; sorry",
  "name": "zsmul_int_one",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (n : ℤ) : n • (1 : ℤ) = n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (n : ℤ)"},
 {"type": "(↑(n ^ m) : R) = (↑n : R) ^ m",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Ring R]  (n : ℤ)  (m : ℕ) : (↑(n ^ m) : R) = (↑n : R) ^ m := by induction' m with m ih; sorry",
  "name": "Int.cast_pow",
  "kind": "theorem",
  "first-tactic": "induction' m with m ih",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Ring R]  (n : ℤ)  (m : ℕ) : (↑(n ^ m) : R) = (↑n : R) ^ m",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Ring R]  (n : ℤ)  (m : ℕ)"},
 {"type": "(-1 : R) ^ n = (-1) ^ (n % 2)",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Ring R]  {n : ℕ} : (-1 : R) ^ n = (-1) ^ (n % 2) := by rw [← Nat.mod_add_div n 2]; sorry",
  "name": "neg_one_pow_eq_pow_mod_two",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.mod_add_div n 2]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Ring R]  {n : ℕ} : (-1 : R) ^ n = (-1) ^ (n % 2)",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Ring R]  {n : ℕ}"},
 {"type": "a ^ j ≤ a ^ i",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [StrictOrderedSemiring R]  {a : R} (h : 0 ≤ a)  (ha : a ≤ 1)  {i j : ℕ}  (hij : i ≤ j) : a ^ j ≤ a ^ i := by let ⟨k, hk⟩ := Nat.exists_eq_add_of_le hij; sorry",
  "name": "pow_le_pow_of_le_one",
  "kind": "theorem",
  "first-tactic": "let ⟨k, hk⟩ := Nat.exists_eq_add_of_le hij",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [StrictOrderedSemiring R]  {a : R} (h : 0 ≤ a)  (ha : a ≤ 1)  {i j : ℕ}  (hij : i ≤ j) : a ^ j ≤ a ^ i",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [StrictOrderedSemiring R]  {a : R} (h : 0 ≤ a)  (ha : a ≤ 1)  {i j : ℕ}  (hij : i ≤ j)"},
 {"type": "C = 0 ∨ 0 < C ∧ 0 ≤ r",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedSemiring R] {C r : R}  (h : ∀ n : ℕ, 0 ≤ C * r ^ n) : C = 0 ∨ 0 < C ∧ 0 ≤ r := by have : 0 ≤ C := by simpa only [pow_zero]; sorry",
  "name": "sign_cases_of_C_mul_pow_nonneg",
  "kind": "theorem",
  "first-tactic": "have : 0 ≤ C := by simpa only [pow_zero]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedSemiring R] {C r : R}  (h : ∀ n : ℕ, 0 ≤ C * r ^ n) : C = 0 ∨ 0 < C ∧ 0 ≤ r",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedSemiring R] {C r : R}  (h : ∀ n : ℕ, 0 ≤ C * r ^ n)"},
 {"type": "a ^ bit1 n ≤ 0 ↔ a ≤ 0",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedRing R]  {a : R}  {n : ℕ} : a ^ bit1 n ≤ 0 ↔ a ≤ 0 := by simp only [le_iff_lt_or_eq]; sorry",
  "name": "pow_bit1_nonpos_iff",
  "kind": "theorem",
  "first-tactic": "simp only [le_iff_lt_or_eq]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedRing R]  {a : R}  {n : ℕ} : a ^ bit1 n ≤ 0 ↔ a ≤ 0",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedRing R]  {a : R}  {n : ℕ}"},
 {"type": "StrictMono fun a : R => a ^ bit1 n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedRing R]  {a : R}  {n : ℕ}  (n : ℕ) : StrictMono fun a : R => a ^ bit1 n := by intro a b hab; sorry",
  "name": "strictMono_pow_bit1",
  "kind": "theorem",
  "first-tactic": "intro a b hab",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedRing R]  {a : R}  {n : ℕ}  (n : ℕ) : StrictMono fun a : R => a ^ bit1 n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedRing R]  {a : R}  {n : ℕ}  (n : ℕ)"},
 {"type": "1 + (n : R) * (a - 1) ≤ a ^ n",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (H : -1 ≤ a)  (n : ℕ) : 1 + (n : R) * (a - 1) ≤ a ^ n := by have : -2 ≤ a - 1 := by\n    rwa [← one_add_one_eq_two]; sorry",
  "name": "one_add_mul_sub_le_pow",
  "kind": "theorem",
  "first-tactic": "have : -2 ≤ a - 1 := by\n    rwa [← one_add_one_eq_two]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (H : -1 ≤ a)  (n : ℕ) : 1 + (n : R) * (a - 1) ≤ a ^ n",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (H : -1 ≤ a)  (n : ℕ)"},
 {"type": "↑(x.natAbs ^ 2) = x ^ 2",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (x : ℤ) : ↑(x.natAbs ^ 2) = x ^ 2 := by rw [sq]; sorry",
  "name": "natAbs_sq",
  "kind": "theorem",
  "first-tactic": "rw [sq]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (x : ℤ) : ↑(x.natAbs ^ 2) = x ^ 2",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (x : ℤ)"},
 {"type": "(x.natAbs: ℤ) ^ 2 = x ^ 2",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (x : ℤ) : (x.natAbs: ℤ) ^ 2 = x ^ 2 := by have l : (x.natAbs: ℤ) ^ 2 = ↑(x.natAbs ^ 2) := by simp; sorry",
  "name": "natAbs_sq'",
  "kind": "theorem",
  "first-tactic": "have l : (x.natAbs: ℤ) ^ 2 = ↑(x.natAbs ^ 2) := by simp",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (x : ℤ) : (x.natAbs: ℤ) ^ 2 = x ^ 2",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (x : ℤ)"},
 {"type": "(Int.natAbs a : ℤ) ≤ a ^ 2",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (a : ℤ) : (Int.natAbs a : ℤ) ≤ a ^ 2 := by rw [← Int.natAbs_sq a]; sorry",
  "name": "natAbs_le_self_sq",
  "kind": "theorem",
  "first-tactic": "rw [← Int.natAbs_sq a]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (a : ℤ) : (Int.natAbs a : ℤ) ≤ a ^ 2",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} (a : ℤ)"},
 {"type": "Function.Injective ((· ^ ·) x : ℕ → ℤ)",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} {x : ℤ}  (h : 1 < x.natAbs) : Function.Injective ((· ^ ·) x : ℕ → ℤ) := by suffices Function.Injective (natAbs ∘ ((· ^ ·) x : ℕ → ℤ)) by\n    exact Function.Injective.of_comp this; sorry",
  "name": "pow_right_injective",
  "kind": "theorem",
  "first-tactic":
  "suffices Function.Injective (natAbs ∘ ((· ^ ·) x : ℕ → ℤ)) by\n    exact Function.Injective.of_comp this",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} {x : ℤ}  (h : 1 < x.natAbs) : Function.Injective ((· ^ ·) x : ℕ → ℤ)",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} {x : ℤ}  (h : 1 < x.natAbs)"},
 {"type": "f n = f (Multiplicative.ofAdd 1) ^ (Multiplicative.toAdd n)",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Monoid M]  (f : Multiplicative ℕ →* M)  (n : Multiplicative ℕ) : f n = f (Multiplicative.ofAdd 1) ^ (Multiplicative.toAdd n) := by rw [← powersHom_symm_apply]; sorry",
  "name": "MonoidHom.apply_mnat",
  "kind": "theorem",
  "first-tactic": "rw [← powersHom_symm_apply]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Monoid M]  (f : Multiplicative ℕ →* M)  (n : Multiplicative ℕ) : f n = f (Multiplicative.ofAdd 1) ^ (Multiplicative.toAdd n)",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Monoid M]  (f : Multiplicative ℕ →* M)  (n : Multiplicative ℕ)"},
 {"type": "f n = f (Multiplicative.ofAdd 1) ^ (Multiplicative.toAdd n)",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Group M]  (f : Multiplicative ℤ →* M)  (n : Multiplicative ℤ) : f n = f (Multiplicative.ofAdd 1) ^ (Multiplicative.toAdd n) := by rw [← zpowersHom_symm_apply]; sorry",
  "name": "MonoidHom.apply_mint",
  "kind": "theorem",
  "first-tactic": "rw [← zpowersHom_symm_apply]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Group M]  (f : Multiplicative ℤ →* M)  (n : Multiplicative ℤ) : f n = f (Multiplicative.ofAdd 1) ^ (Multiplicative.toAdd n)",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Group M]  (f : Multiplicative ℤ →* M)  (n : Multiplicative ℤ)"},
 {"type": "f n = n • f 1",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [AddMonoid M]  (f : ℕ →+ M)  (n : ℕ) : f n = n • f 1 := by rw [← multiplesHom_symm_apply]; sorry",
  "name": "AddMonoidHom.apply_nat",
  "kind": "theorem",
  "first-tactic": "rw [← multiplesHom_symm_apply]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [AddMonoid M]  (f : ℕ →+ M)  (n : ℕ) : f n = n • f 1",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [AddMonoid M]  (f : ℕ →+ M)  (n : ℕ)"},
 {"type": "f n = n • f 1",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [AddGroup M]  (f : ℤ →+ M)  (n : ℤ) : f n = n • f 1 := by rw [← zmultiplesHom_symm_apply]; sorry",
  "name": "AddMonoidHom.apply_int",
  "kind": "theorem",
  "first-tactic": "rw [← zmultiplesHom_symm_apply]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [AddGroup M]  (f : ℤ →+ M)  (n : ℤ) : f n = n • f 1",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [AddGroup M]  (f : ℤ →+ M)  (n : ℤ)"},
 {"type": "Commute (m : R) a",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R} : Commute (m : R) a := by rw [← mul_one (m : R)]; sorry",
  "name": "cast_int_left",
  "kind": "theorem",
  "first-tactic": "rw [← mul_one (m : R)]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R} : Commute (m : R) a",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R}"},
 {"type": "Commute a m",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R} : Commute a m := by rw [← mul_one (m : R)]; sorry",
  "name": "cast_int_right",
  "kind": "theorem",
  "first-tactic": "rw [← mul_one (m : R)]",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R} : Commute a m",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R}"},
 {"type": "toAdd (a ^ b) = toAdd a * b",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R}  (a : Multiplicative ℕ)  (b : ℕ) : toAdd (a ^ b) = toAdd a * b := by induction' b with b ihs; sorry",
  "name": "Nat.to_add_pow",
  "kind": "theorem",
  "first-tactic": "induction' b with b ihs",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R}  (a : Multiplicative ℕ)  (b : ℕ) : toAdd (a ^ b) = toAdd a * b",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R}  (a : Multiplicative ℕ)  (b : ℕ)"},
 {"type": "toAdd (a ^ b) = toAdd a * b",
  "tactic-prompt":
  "theorem {α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R}  (a : Multiplicative ℤ)  (b : ℕ) : toAdd (a ^ b) = toAdd a * b := by induction b; sorry",
  "name": "Int.to_add_pow",
  "kind": "theorem",
  "first-tactic": "induction b",
  "core-prompt":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R}  (a : Multiplicative ℤ)  (b : ℕ) : toAdd (a ^ b) = toAdd a * b",
  "args":
  "{α : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type u₁}  {S : Type u₂} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R}  (a : Multiplicative ℤ)  (b : ℕ)"},
 {"type": "1 < a ^ k",
  "tactic-prompt":
  "theorem {A G M R : Type _}  [Monoid M]  [Preorder M]  [CovariantClass M M (· * ·) (· ≤ ·)]  {x : M}  -- Porting note: removed `mono` attribute, not implemented yet. {a : M}  (ha : 1 < a)  {k : ℕ}  (hk : k ≠ 0) : 1 < a ^ k := by rcases Nat.exists_eq_succ_of_ne_zero hk with ⟨l, rfl⟩; sorry",
  "name": "one_lt_pow'",
  "kind": "theorem",
  "first-tactic": "rcases Nat.exists_eq_succ_of_ne_zero hk with ⟨l, rfl⟩",
  "core-prompt":
  "{A G M R : Type _}  [Monoid M]  [Preorder M]  [CovariantClass M M (· * ·) (· ≤ ·)]  {x : M}  -- Porting note: removed `mono` attribute, not implemented yet. {a : M}  (ha : 1 < a)  {k : ℕ}  (hk : k ≠ 0) : 1 < a ^ k",
  "args":
  "{A G M R : Type _}  [Monoid M]  [Preorder M]  [CovariantClass M M (· * ·) (· ≤ ·)]  {x : M}  -- Porting note: removed `mono` attribute, not implemented yet. {a : M}  (ha : 1 < a)  {k : ℕ}  (hk : k ≠ 0)"},
 {"type": "a ^ n < a ^ m",
  "tactic-prompt":
  "theorem {A G M R : Type _}  [Monoid M]  [Preorder M]  [CovariantClass M M (· * ·) (· ≤ ·)]  {x : M}  -- Porting note: removed `mono` attribute, not implemented yet. [CovariantClass M M (· * ·) (· < ·)]  {a : M}  {n m : ℕ}  (ha : 1 < a)      (h : n < m) : a ^ n < a ^ m := by rcases Nat.le.dest h with ⟨k, rfl⟩; sorry",
  "name": "pow_lt_pow'",
  "kind": "theorem",
  "first-tactic": "rcases Nat.le.dest h with ⟨k, rfl⟩",
  "core-prompt":
  "{A G M R : Type _}  [Monoid M]  [Preorder M]  [CovariantClass M M (· * ·) (· ≤ ·)]  {x : M}  -- Porting note: removed `mono` attribute, not implemented yet. [CovariantClass M M (· * ·) (· < ·)]  {a : M}  {n m : ℕ}  (ha : 1 < a)      (h : n < m) : a ^ n < a ^ m",
  "args":
  "{A G M R : Type _}  [Monoid M]  [Preorder M]  [CovariantClass M M (· * ·) (· ≤ ·)]  {x : M}  -- Porting note: removed `mono` attribute, not implemented yet. [CovariantClass M M (· * ·) (· < ·)]  {a : M}  {n m : ℕ}  (ha : 1 < a)      (h : n < m)"},
 {"type": "x ^ n = 1 ↔ x = 1",
  "tactic-prompt":
  "theorem {A G M R : Type _}  [Monoid M]  [LinearOrder M]  [CovariantClass M M (· * ·) (· ≤ ·)] {x : M}  {n : ℕ}  (hn : n ≠ 0) : x ^ n = 1 ↔ x = 1 := by simp only [le_antisymm_iff]; sorry",
  "name": "pow_eq_one_iff",
  "kind": "theorem",
  "first-tactic": "simp only [le_antisymm_iff]",
  "core-prompt":
  "{A G M R : Type _}  [Monoid M]  [LinearOrder M]  [CovariantClass M M (· * ·) (· ≤ ·)] {x : M}  {n : ℕ}  (hn : n ≠ 0) : x ^ n = 1 ↔ x = 1",
  "args":
  "{A G M R : Type _}  [Monoid M]  [LinearOrder M]  [CovariantClass M M (· * ·) (· ≤ ·)] {x : M}  {n : ℕ}  (hn : n ≠ 0)"},
 {"type": "1 ≤ x ^ n",
  "tactic-prompt":
  "theorem {A G M R : Type _}  [DivInvMonoid G]  [Preorder G]  [CovariantClass G G (· * ·) (· ≤ ·)]  -- porting note: expanded for missing lift {x : G}  (H : 1 ≤ x)  {n : ℤ}  (hn : 0 ≤ n) : 1 ≤ x ^ n := by let n' := n.natAbs; sorry",
  "name": "one_le_zpow",
  "kind": "theorem",
  "first-tactic": "let n' := n.natAbs",
  "core-prompt":
  "{A G M R : Type _}  [DivInvMonoid G]  [Preorder G]  [CovariantClass G G (· * ·) (· ≤ ·)]  -- porting note: expanded for missing lift {x : G}  (H : 1 ≤ x)  {n : ℤ}  (hn : 0 ≤ n) : 1 ≤ x ^ n",
  "args":
  "{A G M R : Type _}  [DivInvMonoid G]  [Preorder G]  [CovariantClass G G (· * ·) (· ≤ ·)]  -- porting note: expanded for missing lift {x : G}  (H : 1 ≤ x)  {n : ℤ}  (hn : 0 ≤ n)"},
 {"type": "x ^ n + y ^ n ≤ (x + y) ^ n",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [OrderedSemiring R]  {a x y : R}  {n m : ℕ} (hx : 0 ≤ x)  (hy : 0 ≤ y)  (hn : n ≠ 0) : x ^ n + y ^ n ≤ (x + y) ^ n := by rcases Nat.exists_eq_succ_of_ne_zero hn with ⟨k, rfl⟩; sorry",
  "name": "pow_add_pow_le",
  "kind": "theorem",
  "first-tactic": "rcases Nat.exists_eq_succ_of_ne_zero hn with ⟨k, rfl⟩",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [OrderedSemiring R]  {a x y : R}  {n m : ℕ} (hx : 0 ≤ x)  (hy : 0 ≤ y)  (hn : n ≠ 0) : x ^ n + y ^ n ≤ (x + y) ^ n",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [OrderedSemiring R]  {a x y : R}  {n m : ℕ} (hx : 0 ≤ x)  (hy : 0 ≤ y)  (hn : n ≠ 0)"},
 {"type": "∀ i : ℕ, a ^ i ≤ b ^ i",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [OrderedSemiring R]  {a x y : R}  {n m : ℕ} {a b : R}  (ha : 0 ≤ a)  (hab : a ≤ b) : ∀ i : ℕ, a ^ i ≤ b ^ i := by intro i; sorry",
  "name": "pow_le_pow_of_le_left",
  "kind": "theorem",
  "first-tactic": "intro i",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [OrderedSemiring R]  {a x y : R}  {n m : ℕ} {a b : R}  (ha : 0 ≤ a)  (hab : a ≤ b) : ∀ i : ℕ, a ^ i ≤ b ^ i",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [OrderedSemiring R]  {a x y : R}  {n m : ℕ} {a b : R}  (ha : 0 ≤ a)  (hab : a ≤ b)"},
 {"type": "0 < a ^ 2",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedSemiring R]  {a x y : R}  {n m : ℕ} (ha : 0 < a) : 0 < a ^ 2 := by rw [sq]; sorry",
  "name": "sq_pos_of_pos",
  "kind": "theorem",
  "first-tactic": "rw [sq]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedSemiring R]  {a x y : R}  {n m : ℕ} (ha : 0 < a) : 0 < a ^ 2",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedSemiring R]  {a x y : R}  {n m : ℕ} (ha : 0 < a)"},
 {"type": "0 < a ^ bit0 n",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedRing R]  {a : R} (ha : a < 0)  (n : ℕ) : 0 < a ^ bit0 n := by rw [pow_bit0']; sorry",
  "name": "pow_bit0_pos_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [pow_bit0']",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedRing R]  {a : R} (ha : a < 0)  (n : ℕ) : 0 < a ^ bit0 n",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedRing R]  {a : R} (ha : a < 0)  (n : ℕ)"},
 {"type": "a ^ bit1 n < 0",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedRing R]  {a : R} (ha : a < 0)  (n : ℕ) : a ^ bit1 n < 0 := by rw [bit1]; sorry",
  "name": "pow_bit1_neg",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedRing R]  {a : R} (ha : a < 0)  (n : ℕ) : a ^ bit1 n < 0",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedRing R]  {a : R} (ha : a < 0)  (n : ℕ)"},
 {"type": "a ^ n ≤ 1 ↔ a ≤ 1",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} {a : R}  (ha : 0 ≤ a)  {n : ℕ}  (hn : n ≠ 0) : a ^ n ≤ 1 ↔ a ≤ 1 := by refine' ⟨_, pow_le_one n ha⟩; sorry",
  "name": "pow_le_one_iff_of_nonneg",
  "kind": "theorem",
  "first-tactic": "refine' ⟨_, pow_le_one n ha⟩",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} {a : R}  (ha : 0 ≤ a)  {n : ℕ}  (hn : n ≠ 0) : a ^ n ≤ 1 ↔ a ≤ 1",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} {a : R}  (ha : 0 ≤ a)  {n : ℕ}  (hn : n ≠ 0)"},
 {"type": "1 ≤ a ^ n ↔ 1 ≤ a",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} {a : R}  (ha : 0 ≤ a)  {n : ℕ}  (hn : n ≠ 0) : 1 ≤ a ^ n ↔ 1 ≤ a := by refine' ⟨_, fun h => one_le_pow_of_one_le h n⟩; sorry",
  "name": "one_le_pow_iff_of_nonneg",
  "kind": "theorem",
  "first-tactic": "refine' ⟨_, fun h => one_le_pow_of_one_le h n⟩",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} {a : R}  (ha : 0 ≤ a)  {n : ℕ}  (hn : n ≠ 0) : 1 ≤ a ^ n ↔ 1 ≤ a",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} {a : R}  (ha : 0 ≤ a)  {n : ℕ}  (hn : n ≠ 0)"},
 {"type": "a * a < b * b → a < b",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} (hb : 0 ≤ b) : a * a < b * b → a < b := by simp_rw [← sq]; sorry",
  "name": "lt_of_mul_self_lt_mul_self",
  "kind": "theorem",
  "first-tactic": "simp_rw [← sq]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} (hb : 0 ≤ b) : a * a < b * b → a < b",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} (hb : 0 ≤ b)"},
 {"type": "|(-1 : R) ^ n| = 1",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] (n : ℕ) : |(-1 : R) ^ n| = 1 := by rw [← pow_abs]; sorry",
  "name": "abs_neg_one_pow",
  "kind": "theorem",
  "first-tactic": "rw [← pow_abs]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] (n : ℕ) : |(-1 : R) ^ n| = 1",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] (n : ℕ)"},
 {"type": "0 ≤ a ^ bit0 n",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R]  (a : R)  (n : ℕ) : 0 ≤ a ^ bit0 n := by rw [pow_bit0]; sorry",
  "name": "pow_bit0_nonneg",
  "kind": "theorem",
  "first-tactic": "rw [pow_bit0]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R]  (a : R)  (n : ℕ) : 0 ≤ a ^ bit0 n",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R]  (a : R)  (n : ℕ)"},
 {"type": "0 < a ^ bit0 n ↔ a ≠ 0",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R]  (a : R)  {n : ℕ}  (hn : n ≠ 0) : 0 < a ^ bit0 n ↔ a ≠ 0 := by refine' ⟨fun h => _, fun h => pow_bit0_pos h n⟩; sorry",
  "name": "pow_bit0_pos_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, fun h => pow_bit0_pos h n⟩",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R]  (a : R)  {n : ℕ}  (hn : n ≠ 0) : 0 < a ^ bit0 n ↔ a ≠ 0",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R]  (a : R)  {n : ℕ}  (hn : n ≠ 0)"},
 {"type": "|x| ^ 2 = x ^ 2",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : |x| ^ 2 = x ^ 2 := by simpa only [sq] using abs_mul_abs_self x; sorry",
  "name": "sq_abs",
  "kind": "theorem",
  "first-tactic": "simpa only [sq] using abs_mul_abs_self x",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : |x| ^ 2 = x ^ 2",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R)"},
 {"type": "|x ^ 2| = x ^ 2",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : |x ^ 2| = x ^ 2 := by simpa only [sq] using abs_mul_self x; sorry",
  "name": "abs_sq",
  "kind": "theorem",
  "first-tactic": "simpa only [sq] using abs_mul_self x",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : |x ^ 2| = x ^ 2",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R)"},
 {"type": "x ^ 2 < y ^ 2 ↔ |x| < |y|",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} : x ^ 2 < y ^ 2 ↔ |x| < |y| := by simpa only [sq_abs] using\n    (@strictMonoOn_pow R _ _ two_pos).lt_iff_lt (abs_nonneg x) (abs_nonneg y); sorry",
  "name": "sq_lt_sq",
  "kind": "theorem",
  "first-tactic":
  "simpa only [sq_abs] using\n    (@strictMonoOn_pow R _ _ two_pos).lt_iff_lt (abs_nonneg x) (abs_nonneg y)",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} : x ^ 2 < y ^ 2 ↔ |x| < |y|",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}"},
 {"type": "x ^ 2 ≤ y ^ 2 ↔ |x| ≤ |y|",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} : x ^ 2 ≤ y ^ 2 ↔ |x| ≤ |y| := by simpa only [sq_abs] using\n    (@strictMonoOn_pow R _ _ two_pos).le_iff_le (abs_nonneg x) (abs_nonneg y); sorry",
  "name": "sq_le_sq",
  "kind": "theorem",
  "first-tactic":
  "simpa only [sq_abs] using\n    (@strictMonoOn_pow R _ _ two_pos).le_iff_le (abs_nonneg x) (abs_nonneg y)",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} : x ^ 2 ≤ y ^ 2 ↔ |x| ≤ |y|",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}"},
 {"type": "|x| < y",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (h : x ^ 2 < y ^ 2)  (hy : 0 ≤ y) : |x| < y := by rwa [← abs_of_nonneg hy]; sorry",
  "name": "abs_lt_of_sq_lt_sq",
  "kind": "theorem",
  "first-tactic": "rwa [← abs_of_nonneg hy]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (h : x ^ 2 < y ^ 2)  (hy : 0 ≤ y) : |x| < y",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (h : x ^ 2 < y ^ 2)  (hy : 0 ≤ y)"},
 {"type": "|x| ≤ y",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (h : x ^ 2 ≤ y ^ 2)  (hy : 0 ≤ y) : |x| ≤ y := by rwa [← abs_of_nonneg hy]; sorry",
  "name": "abs_le_of_sq_le_sq",
  "kind": "theorem",
  "first-tactic": "rwa [← abs_of_nonneg hy]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (h : x ^ 2 ≤ y ^ 2)  (hy : 0 ≤ y) : |x| ≤ y",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (h : x ^ 2 ≤ y ^ 2)  (hy : 0 ≤ y)"},
 {"type": "x ^ 2 = y ^ 2 ↔ |x| = |y|",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x y : R) : x ^ 2 = y ^ 2 ↔ |x| = |y| := by simp only [le_antisymm_iff]; sorry",
  "name": "sq_eq_sq_iff_abs_eq_abs",
  "kind": "theorem",
  "first-tactic": "simp only [le_antisymm_iff]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x y : R) : x ^ 2 = y ^ 2 ↔ |x| = |y|",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x y : R)"},
 {"type": "x ^ 2 ≤ 1 ↔ |x| ≤ 1",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : x ^ 2 ≤ 1 ↔ |x| ≤ 1 := by simpa only [one_pow]; sorry",
  "name": "sq_le_one_iff_abs_le_one",
  "kind": "theorem",
  "first-tactic": "simpa only [one_pow]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : x ^ 2 ≤ 1 ↔ |x| ≤ 1",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R)"},
 {"type": "x ^ 2 < 1 ↔ |x| < 1",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : x ^ 2 < 1 ↔ |x| < 1 := by simpa only [one_pow]; sorry",
  "name": "sq_lt_one_iff_abs_lt_one",
  "kind": "theorem",
  "first-tactic": "simpa only [one_pow]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : x ^ 2 < 1 ↔ |x| < 1",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R)"},
 {"type": "1 ≤ x ^ 2 ↔ 1 ≤ |x|",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : 1 ≤ x ^ 2 ↔ 1 ≤ |x| := by simpa only [one_pow]; sorry",
  "name": "one_le_sq_iff_one_le_abs",
  "kind": "theorem",
  "first-tactic": "simpa only [one_pow]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : 1 ≤ x ^ 2 ↔ 1 ≤ |x|",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R)"},
 {"type": "1 < x ^ 2 ↔ 1 < |x|",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : 1 < x ^ 2 ↔ 1 < |x| := by simpa only [one_pow]; sorry",
  "name": "one_lt_sq_iff_one_lt_abs",
  "kind": "theorem",
  "first-tactic": "simpa only [one_pow]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : 1 < x ^ 2 ↔ 1 < |x|",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R)"},
 {"type": "0 < a ^ n ↔ 0 < a",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommMonoidWithZero M]  [NoZeroDivisors M]  {a : M}  {n : ℕ} (hn : 0 < n) : 0 < a ^ n ↔ 0 < a := by simp_rw [zero_lt_iff]; sorry",
  "name": "pow_pos_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [zero_lt_iff]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommMonoidWithZero M]  [NoZeroDivisors M]  {a : M}  {n : ℕ} (hn : 0 < n) : 0 < a ^ n ↔ 0 < a",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommMonoidWithZero M]  [NoZeroDivisors M]  {a : M}  {n : ℕ} (hn : 0 < n)"},
 {"type": "a ^ n < a ^ n.succ",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommGroupWithZero M]  {a : M}  {m n : ℕ} (ha : 1 < a) : a ^ n < a ^ n.succ := by rw [← one_mul (a ^ n)]; sorry",
  "name": "pow_lt_pow_succ",
  "kind": "theorem",
  "first-tactic": "rw [← one_mul (a ^ n)]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommGroupWithZero M]  {a : M}  {m n : ℕ} (ha : 1 < a) : a ^ n < a ^ n.succ",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommGroupWithZero M]  {a : M}  {m n : ℕ} (ha : 1 < a)"},
 {"type": "a ^ m < a ^ n",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommGroupWithZero M]  {a : M}  {m n : ℕ} (ha : 1 < a)  (hmn : m < n) : a ^ m < a ^ n := by induction' hmn with n _ ih; sorry",
  "name": "pow_lt_pow₀",
  "kind": "theorem",
  "first-tactic": "induction' hmn with n _ ih",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommGroupWithZero M]  {a : M}  {m n : ℕ} (ha : 1 < a)  (hmn : m < n) : a ^ m < a ^ n",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommGroupWithZero M]  {a : M}  {m n : ℕ} (ha : 1 < a)  (hmn : m < n)"},
 {"type": "f (-x) = f x",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} [Ring R]  [Monoid M]  [LinearOrder M]  [CovariantClass M M (· * ·) (· ≤ ·)]  (f : R →* M) (x : R) : f (-x) = f x := by rw [← neg_one_mul]; sorry",
  "name": "map_neg",
  "kind": "theorem",
  "first-tactic": "rw [← neg_one_mul]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} [Ring R]  [Monoid M]  [LinearOrder M]  [CovariantClass M M (· * ·) (· ≤ ·)]  (f : R →* M) (x : R) : f (-x) = f x",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} [Ring R]  [Monoid M]  [LinearOrder M]  [CovariantClass M M (· * ·) (· ≤ ·)]  (f : R →* M) (x : R)"},
 {"type": "f (x - y) = f (y - x)",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} [Ring R]  [Monoid M]  [LinearOrder M]  [CovariantClass M M (· * ·) (· ≤ ·)]  (f : R →* M) (x y : R) : f (x - y) = f (y - x) := by rw [← map_neg]; sorry",
  "name": "map_sub_swap",
  "kind": "theorem",
  "first-tactic": "rw [← map_neg]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} [Ring R]  [Monoid M]  [LinearOrder M]  [CovariantClass M M (· * ·) (· ≤ ·)]  (f : R →* M) (x y : R) : f (x - y) = f (y - x)",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} [Ring R]  [Monoid M]  [LinearOrder M]  [CovariantClass M M (· * ·) (· ≤ ·)]  (f : R →* M) (x y : R)"},
 {"type": "⅟ a * (a * b) = b",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  (a b : α)  [Invertible a] : ⅟ a * (a * b) = b := by rw [← mul_assoc]; sorry",
  "name": "invOf_mul_self_assoc",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{α : Type u} [Monoid α]  (a b : α)  [Invertible a] : ⅟ a * (a * b) = b",
  "args": "{α : Type u} [Monoid α]  (a b : α)  [Invertible a]"},
 {"type": "a * (⅟ a * b) = b",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  (a b : α)  [Invertible a] : a * (⅟ a * b) = b := by rw [← mul_assoc]; sorry",
  "name": "mul_invOf_self_assoc",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{α : Type u} [Monoid α]  (a b : α)  [Invertible a] : a * (⅟ a * b) = b",
  "args": "{α : Type u} [Monoid α]  (a b : α)  [Invertible a]"},
 {"type": "a * ⅟ b * b = a",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  (a b : α)  [Invertible b] : a * ⅟ b * b = a := by simp [mul_assoc]; sorry",
  "name": "mul_invOf_mul_self_cancel",
  "kind": "theorem",
  "first-tactic": "simp [mul_assoc]",
  "core-prompt":
  "{α : Type u} [Monoid α]  (a b : α)  [Invertible b] : a * ⅟ b * b = a",
  "args": "{α : Type u} [Monoid α]  (a b : α)  [Invertible b]"},
 {"type": "a * b * ⅟ b = a",
  "tactic-prompt":
  "theorem {α : Type u} [Monoid α]  (a b : α)  [Invertible b] : a * b * ⅟ b = a := by simp [mul_assoc]; sorry",
  "name": "mul_mul_invOf_self_cancel",
  "kind": "theorem",
  "first-tactic": "simp [mul_assoc]",
  "core-prompt":
  "{α : Type u} [Monoid α]  (a b : α)  [Invertible b] : a * b * ⅟ b = a",
  "args": "{α : Type u} [Monoid α]  (a b : α)  [Invertible b]"},
 {"type": "⅟ a = ⅟ b",
  "tactic-prompt":
  "theorem {α : Type u} {α : Type u}  [Monoid α]  (a b : α)  [Invertible a]  [Invertible b]      (h : a = b) : ⅟ a = ⅟ b := by apply invOf_eq_right_inv; sorry",
  "name": "invertible_unique",
  "kind": "theorem",
  "first-tactic": "apply invOf_eq_right_inv",
  "core-prompt":
  "{α : Type u} {α : Type u}  [Monoid α]  (a b : α)  [Invertible a]  [Invertible b]      (h : a = b) : ⅟ a = ⅟ b",
  "args":
  "{α : Type u} {α : Type u}  [Monoid α]  (a b : α)  [Invertible a]  [Invertible b]      (h : a = b)"},
 {"type": "(⅟ 2 : α) + (⅟ 2 : α) = 1",
  "tactic-prompt":
  "theorem {α : Type u} [NonAssocSemiring α]  [Invertible (2 : α)] : (⅟ 2 : α) + (⅟ 2 : α) = 1 := by rw [← two_mul]; sorry",
  "name": "invOf_two_add_invOf_two",
  "kind": "theorem",
  "first-tactic": "rw [← two_mul]",
  "core-prompt":
  "{α : Type u} [NonAssocSemiring α]  [Invertible (2 : α)] : (⅟ 2 : α) + (⅟ 2 : α) = 1",
  "args": "{α : Type u} [NonAssocSemiring α]  [Invertible (2 : α)]"},
 {"type": "op x = op y ↔ x = y",
  "tactic-prompt": "theorem {x y : α} : op x = op y ↔ x = y := by simp; sorry",
  "name": "op_inj",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "{x y : α} : op x = op y ↔ x = y",
  "args": "{x y : α}"},
 {"type": "a - ⊤ = 0",
  "tactic-prompt":
  "theorem {α β : Type _}  [Sub α]  [Zero α] {a : WithTop α} : a - ⊤ = 0 := by cases a; sorry",
  "name": "sub_top",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{α β : Type _}  [Sub α]  [Zero α] {a : WithTop α} : a - ⊤ = 0",
  "args": "{α β : Type _}  [Sub α]  [Zero α] {a : WithTop α}"},
 {"type": "OrderedSub (WithTop α)",
  "tactic-prompt":
  "instance {α β : Type _} [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α] : OrderedSub (WithTop α) := by constructor; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "constructor",
  "core-prompt":
  "{α β : Type _} [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α] : OrderedSub (WithTop α)",
  "args":
  "{α β : Type _} [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α]"},
 {"type": "a - b ≤ c ↔ a ≤ b + c",
  "tactic-prompt":
  "theorem {α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a - b ≤ c ↔ a ≤ b + c := by rw [tsub_le_iff_right]; sorry",
  "name": "tsub_le_iff_left",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_right]",
  "core-prompt":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a - b ≤ c ↔ a ≤ b + c",
  "args":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}"},
 {"type": "a - b ≤ c ↔ a - c ≤ b",
  "tactic-prompt":
  "theorem {α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a - b ≤ c ↔ a - c ≤ b := by rw [tsub_le_iff_left]; sorry",
  "name": "tsub_le_iff_tsub_le",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_left]",
  "core-prompt":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a - b ≤ c ↔ a - c ≤ b",
  "args":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}"},
 {"type": "a + b - c ≤ a + (b - c)",
  "tactic-prompt":
  "theorem {α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : a + b - c ≤ a + (b - c) := by rw [tsub_le_iff_left]; sorry",
  "name": "add_tsub_le_assoc",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_left]",
  "core-prompt":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : a + b - c ≤ a + (b - c)",
  "args":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)]"},
 {"type": "a + b - c ≤ a - c + b",
  "tactic-prompt":
  "theorem {α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : a + b - c ≤ a - c + b := by rw [add_comm]; sorry",
  "name": "add_tsub_le_tsub_add",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : a + b - c ≤ a - c + b",
  "args":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)]"},
 {"type": "a + b ≤ a + c + (b - c)",
  "tactic-prompt":
  "theorem {α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : a + b ≤ a + c + (b - c) := by rw [add_assoc]; sorry",
  "name": "add_le_add_add_tsub",
  "kind": "theorem",
  "first-tactic": "rw [add_assoc]",
  "core-prompt":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : a + b ≤ a + c + (b - c)",
  "args":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)]"},
 {"type": "a + b ≤ a - c + (b + c)",
  "tactic-prompt":
  "theorem {α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : a + b ≤ a - c + (b + c) := by rw [add_comm a]; sorry",
  "name": "le_tsub_add_add",
  "kind": "theorem",
  "first-tactic": "rw [add_comm a]",
  "core-prompt":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : a + b ≤ a - c + (b + c)",
  "args":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)]"},
 {"type": "a - c ≤ a - b + (b - c)",
  "tactic-prompt":
  "theorem {α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : a - c ≤ a - b + (b - c) := by rw [tsub_le_iff_left]; sorry",
  "name": "tsub_le_tsub_add_tsub",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_left]",
  "core-prompt":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : a - c ≤ a - b + (b - c)",
  "args":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)]"},
 {"type": "c - a - (c - b) ≤ b - a",
  "tactic-prompt":
  "theorem {α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : c - a - (c - b) ≤ b - a := by rw [tsub_le_iff_left]; sorry",
  "name": "tsub_tsub_tsub_le_tsub",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_left]",
  "core-prompt":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : c - a - (c - b) ≤ b - a",
  "args":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)]"},
 {"type": "a + b - (c + d) ≤ a - c + (b - d)",
  "tactic-prompt":
  "theorem {α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : a + b - (c + d) ≤ a - c + (b - d) := by rw [add_comm c]; sorry",
  "name": "add_tsub_add_le_tsub_add_tsub",
  "kind": "theorem",
  "first-tactic": "rw [add_comm c]",
  "core-prompt":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : a + b - (c + d) ≤ a - c + (b - d)",
  "args":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)]"},
 {"type": "a + b - (a + c) ≤ b - c",
  "tactic-prompt":
  "theorem {α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : a + b - (a + c) ≤ b - c := by rw [tsub_le_iff_left]; sorry",
  "name": "add_tsub_add_le_tsub_left",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_left]",
  "core-prompt":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : a + b - (a + c) ≤ b - c",
  "args":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)]"},
 {"type": "a + c - (b + c) ≤ a - b",
  "tactic-prompt":
  "theorem {α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : a + c - (b + c) ≤ a - b := by rw [tsub_le_iff_left]; sorry",
  "name": "add_tsub_add_le_tsub_right",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_left]",
  "core-prompt":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)] : a + c - (b + c) ≤ a - b",
  "args":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)]"},
 {"type": "a ≤ a + b - b",
  "tactic-prompt":
  "theorem {α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b) : a ≤ a + b - b := by rw [add_comm]; sorry",
  "name": "le_add_tsub",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b) : a ≤ a + b - b",
  "args":
  "{α β : Type _}   [Preorder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)"},
 {"type": "a - b ≤ 0 ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α β : Type _}   [Preorder α] [AddCommMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a - b ≤ 0 ↔ a ≤ b := by rw [tsub_le_iff_left]; sorry",
  "name": "tsub_nonpos",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_left]",
  "core-prompt":
  "{α β : Type _}   [Preorder α] [AddCommMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a - b ≤ 0 ↔ a ≤ b",
  "args":
  "{α β : Type _}   [Preorder α] [AddCommMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α}"},
 {"type": "b - a - c = b - (a + c)",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} (b a c : α) : b - a - c = b - (a + c) := by apply le_antisymm; sorry",
  "name": "tsub_tsub",
  "kind": "theorem",
  "first-tactic": "apply le_antisymm",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} (b a c : α) : b - a - c = b - (a + c)",
  "args":
  "{α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} (b a c : α)"},
 {"type": "a - (b + c) = a - c - b",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} (a b c : α) : a - (b + c) = a - c - b := by rw [add_comm]; sorry",
  "name": "tsub_add_eq_tsub_tsub_swap",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} (a b c : α) : a - (b + c) = a - c - b",
  "args":
  "{α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} (a b c : α)"},
 {"type": "a - b - c = a - c - b",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a - b - c = a - c - b := by rw [←tsub_add_eq_tsub_tsub]; sorry",
  "name": "tsub_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [←tsub_add_eq_tsub_tsub]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a - b - c = a - c - b",
  "args":
  "{α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (h : a - b < c) : a < b + c := by rw [lt_iff_le_and_ne]; sorry",
  "name": "lt_add_of_tsub_lt_left",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_le_and_ne]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (h : a - b < c) : a < b + c",
  "args":
  "{α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (h : a - b < c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : a - c < b) : a < b + c := by rw [lt_iff_le_and_ne]; sorry",
  "name": "lt_add_of_tsub_lt_right",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_le_and_ne]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : a - c < b) : a < b + c",
  "args":
  "{α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : a - c < b)"},
 {"type": "a + c - (b + c) = a - b",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)]  [ContravariantClass α α (· + ·) (· ≤ ·)] (a c b : α) : a + c - (b + c) = a - b := by refine' add_tsub_add_le_tsub_right.antisymm (tsub_le_iff_right.2 <| le_of_add_le_add_right _); sorry",
  "name": "add_tsub_add_eq_tsub_right",
  "kind": "theorem",
  "first-tactic":
  "refine' add_tsub_add_le_tsub_right.antisymm (tsub_le_iff_right.2 <| le_of_add_le_add_right _)",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)]  [ContravariantClass α α (· + ·) (· ≤ ·)] (a c b : α) : a + c - (b + c) = a - b",
  "args":
  "{α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)]  [ContravariantClass α α (· + ·) (· ≤ ·)] (a c b : α)"},
 {"type": "a + b - (a + c) = b - c",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)]  [ContravariantClass α α (· + ·) (· ≤ ·)] (a b c : α) : a + b - (a + c) = b - c := by rw [add_comm a b]; sorry",
  "name": "add_tsub_add_eq_tsub_left",
  "kind": "theorem",
  "first-tactic": "rw [add_comm a b]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)]  [ContravariantClass α α (· + ·) (· ≤ ·)] (a b c : α) : a + b - (a + c) = b - c",
  "args":
  "{α β : Type _}  [PartialOrder α]  [AddCommSemigroup α]  [Sub α]  [OrderedSub α]  {a b c d : α}  [CovariantClass α α (· + ·) (· ≤ ·)]  [ContravariantClass α α (· + ·) (· ≤ ·)] (a b c : α)"},
 {"type": "a + (b - a) = b",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h : a ≤ b) : a + (b - a) = b := by refine' le_antisymm _ le_add_tsub; sorry",
  "name": "add_tsub_cancel_of_le",
  "kind": "theorem",
  "first-tactic": "refine' le_antisymm _ le_add_tsub",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h : a ≤ b) : a + (b - a) = b",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h : a ≤ b)"},
 {"type": "b - a + a = b",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h : a ≤ b) : b - a + a = b := by rw [add_comm]; sorry",
  "name": "tsub_add_cancel_of_le",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h : a ≤ b) : b - a + a = b",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h : a ≤ b)"},
 {"type": "a - c ≤ b - c ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h : c ≤ b) : a - c ≤ b - c ↔ a ≤ b := by rw [tsub_le_iff_right]; sorry",
  "name": "tsub_le_tsub_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_right]",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h : c ≤ b) : a - c ≤ b - c ↔ a ≤ b",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h : c ≤ b)"},
 {"type": "a - c = b - c ↔ a = b",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h1 : c ≤ a)  (h2 : c ≤ b) : a - c = b - c ↔ a = b := by simp_rw [le_antisymm_iff]; sorry",
  "name": "tsub_left_inj",
  "kind": "theorem",
  "first-tactic": "simp_rw [le_antisymm_iff]",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h1 : c ≤ a)  (h2 : c ≤ b) : a - c = b - c ↔ a = b",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h1 : c ≤ a)  (h2 : c ≤ b)"},
 {"type": "a < b",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h : c ≤ b)  (h2 : a - c < b - c) : a < b := by refine' ((tsub_le_tsub_iff_right h).mp h2.le).lt_of_ne _; sorry",
  "name": "lt_of_tsub_lt_tsub_right_of_le",
  "kind": "theorem",
  "first-tactic": "refine' ((tsub_le_tsub_iff_right h).mp h2.le).lt_of_ne _",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h : c ≤ b)  (h2 : a - c < b - c) : a < b",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h : c ≤ b)  (h2 : a - c < b - c)"},
 {"type": "a - b + (b - c) = a - c",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hab : b ≤ a)  (hcb : c ≤ b) : a - b + (b - c) = a - c := by convert tsub_add_cancel_of_le (tsub_le_tsub_right hab c) using 2; sorry",
  "name": "tsub_add_tsub_cancel",
  "kind": "theorem",
  "first-tactic":
  "convert tsub_add_cancel_of_le (tsub_le_tsub_right hab c) using 2",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hab : b ≤ a)  (hcb : c ≤ b) : a - b + (b - c) = a - c",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hab : b ≤ a)  (hcb : c ≤ b)"},
 {"type": "a - c - (b - c) = a - b",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h : c ≤ b) : a - c - (b - c) = a - b := by rw [tsub_tsub]; sorry",
  "name": "tsub_tsub_tsub_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [tsub_tsub]",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h : c ≤ b) : a - c - (b - c) = a - b",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (h : c ≤ b)"},
 {"type": "a - b = c ↔ a = c + b",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (h : b ≤ a) : a - b = c ↔ a = c + b := by rw [eq_comm]; sorry",
  "name": "tsub_eq_iff_eq_add_of_le",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (h : b ≤ a) : a - b = c ↔ a = c + b",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (h : b ≤ a)"},
 {"type": "a + b - c = a + (b - c)",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : c ≤ b)  (a : α) : a + b - c = a + (b - c) := by conv_lhs => rw [← add_tsub_cancel_of_le h]; sorry",
  "name": "add_tsub_assoc_of_le",
  "kind": "theorem",
  "first-tactic": "conv_lhs => rw [← add_tsub_cancel_of_le h]",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : c ≤ b)  (a : α) : a + b - c = a + (b - c)",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : c ≤ b)  (a : α)"},
 {"type": "a - b + c = a + c - b",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (h : b ≤ a) : a - b + c = a + c - b := by rw [add_comm a]; sorry",
  "name": "tsub_add_eq_add_tsub",
  "kind": "theorem",
  "first-tactic": "rw [add_comm a]",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (h : b ≤ a) : a - b + c = a + c - b",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (h : b ≤ a)"},
 {"type": "a - b + (c - d) = a + c - (b + d)",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (hd : AddLECancellable d)      (hba : b ≤ a)  (hdc : d ≤ c) : a - b + (c - d) = a + c - (b + d) := by rw [hb.tsub_add_eq_add_tsub hba]; sorry",
  "name": "tsub_add_tsub_comm",
  "kind": "theorem",
  "first-tactic": "rw [hb.tsub_add_eq_add_tsub hba]",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (hd : AddLECancellable d)      (hba : b ≤ a)  (hdc : d ≤ c) : a - b + (c - d) = a + c - (b + d)",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (hd : AddLECancellable d)      (hba : b ≤ a)  (hdc : d ≤ c)"},
 {"type": "b ≤ c - a ↔ b + a ≤ c",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a)  (h : a ≤ c) : b ≤ c - a ↔ b + a ≤ c := by rw [add_comm]; sorry",
  "name": "le_tsub_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a)  (h : a ≤ c) : b ≤ c - a ↔ b + a ≤ c",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a)  (h : a ≤ c)"},
 {"type": "a - b < c ↔ a < b + c",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (hba : b ≤ a) : a - b < c ↔ a < b + c := by refine' ⟨hb.lt_add_of_tsub_lt_left, _⟩; sorry",
  "name": "tsub_lt_iff_left",
  "kind": "theorem",
  "first-tactic": "refine' ⟨hb.lt_add_of_tsub_lt_left, _⟩",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (hba : b ≤ a) : a - b < c ↔ a < b + c",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (hba : b ≤ a)"},
 {"type": "a - b < c ↔ a < c + b",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (hba : b ≤ a) : a - b < c ↔ a < c + b := by rw [add_comm]; sorry",
  "name": "tsub_lt_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (hba : b ≤ a) : a - b < c ↔ a < c + b",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (hba : b ≤ a)"},
 {"type": "a - b < c ↔ a - c < b",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (hc : AddLECancellable c)      (h₁ : b ≤ a)  (h₂ : c ≤ a) : a - b < c ↔ a - c < b := by rw [hb.tsub_lt_iff_left h₁]; sorry",
  "name": "tsub_lt_iff_tsub_lt",
  "kind": "theorem",
  "first-tactic": "rw [hb.tsub_lt_iff_left h₁]",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (hc : AddLECancellable c)      (h₁ : b ≤ a)  (h₂ : c ≤ a) : a - b < c ↔ a - c < b",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hb : AddLECancellable b)  (hc : AddLECancellable c)      (h₁ : b ≤ a)  (h₂ : c ≤ a)"},
 {"type": "a ≤ b - c ↔ c ≤ b - a",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a)  (hc : AddLECancellable c)      (h₁ : a ≤ b)  (h₂ : c ≤ b) : a ≤ b - c ↔ c ≤ b - a := by rw [ha.le_tsub_iff_left h₁]; sorry",
  "name": "le_tsub_iff_le_tsub",
  "kind": "theorem",
  "first-tactic": "rw [ha.le_tsub_iff_left h₁]",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a)  (hc : AddLECancellable c)      (h₁ : a ≤ b)  (h₂ : c ≤ b) : a ≤ b - c ↔ c ≤ b - a",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a)  (hc : AddLECancellable c)      (h₁ : a ≤ b)  (h₂ : c ≤ b)"},
 {"type": "a < b - c ↔ a + c < b",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : c ≤ b) : a < b - c ↔ a + c < b := by refine' ⟨fun h' => (add_le_of_le_tsub_right_of_le h h'.le).lt_of_ne _, hc.lt_tsub_of_add_lt_right⟩; sorry",
  "name": "lt_tsub_iff_right_of_le",
  "kind": "theorem",
  "first-tactic":
  "refine' ⟨fun h' => (add_le_of_le_tsub_right_of_le h h'.le).lt_of_ne _, hc.lt_tsub_of_add_lt_right⟩",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : c ≤ b) : a < b - c ↔ a + c < b",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : c ≤ b)"},
 {"type": "a < b - c ↔ c + a < b",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : c ≤ b) : a < b - c ↔ c + a < b := by rw [add_comm]; sorry",
  "name": "lt_tsub_iff_left_of_le",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : c ≤ b) : a < b - c ↔ c + a < b",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : c ≤ b)"},
 {"type": "b = c",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hab : AddLECancellable (a - b))  (h₁ : b ≤ a)  (h₂ : c ≤ a)      (h₃ : a - b = a - c) : b = c := by rw [← hab.inj]; sorry",
  "name": "tsub_inj_right",
  "kind": "theorem",
  "first-tactic": "rw [← hab.inj]",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hab : AddLECancellable (a - b))  (h₁ : b ≤ a)  (h₂ : c ≤ a)      (h₃ : a - b = a - c) : b = c",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hab : AddLECancellable (a - b))  (h₁ : b ≤ a)  (h₂ : c ≤ a)      (h₃ : a - b = a - c)"},
 {"type": "c < b",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} [ContravariantClass α α (· + ·) (· < ·)]      (hb : AddLECancellable b)  (hca : c ≤ a)  (h : a - b < a - c) : c < b := by conv_lhs at h => rw [← tsub_add_cancel_of_le hca]; sorry",
  "name": "lt_of_tsub_lt_tsub_left_of_le",
  "kind": "theorem",
  "first-tactic": "conv_lhs at h => rw [← tsub_add_cancel_of_le hca]",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} [ContravariantClass α α (· + ·) (· < ·)]      (hb : AddLECancellable b)  (hca : c ≤ a)  (h : a - b < a - c) : c < b",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} [ContravariantClass α α (· + ·) (· < ·)]      (hb : AddLECancellable b)  (hca : c ≤ a)  (h : a - b < a - c)"},
 {"type": "a - c < b - c",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : c ≤ a)  (h2 : a < b) : a - c < b - c := by apply hc.lt_tsub_of_add_lt_left; sorry",
  "name": "tsub_lt_tsub_right_of_le",
  "kind": "theorem",
  "first-tactic": "apply hc.lt_tsub_of_add_lt_left",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : c ≤ a)  (h2 : a < b) : a - c < b - c",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : c ≤ a)  (h2 : a < b)"},
 {"type": "a - c - (a - b) = b - c",
  "tactic-prompt":
  "theorem {α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hab : AddLECancellable (a - b))  (h : b ≤ a) : a - c - (a - b) = b - c := by rw [tsub_right_comm]; sorry",
  "name": "tsub_tsub_tsub_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [tsub_right_comm]",
  "core-prompt":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hab : AddLECancellable (a - b))  (h : b ≤ a) : a - c - (a - b) = b - c",
  "args":
  "{α : Type _}  [AddCommSemigroup α]  [PartialOrder α]  [ExistsAddOfLE α]    [CovariantClass α α (· + ·) (· ≤ ·)]  [Sub α]  [OrderedSub α]  {a b c d : α} (hab : AddLECancellable (a - b))  (h : b ≤ a)"},
 {"type": "b - a + a = b ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α : Type _}  [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : b - a + a = b ↔ a ≤ b := by rw [add_comm]; sorry",
  "name": "tsub_add_cancel_iff_le",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{α : Type _}  [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : b - a + a = b ↔ a ≤ b",
  "args":
  "{α : Type _}  [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α}"},
 {"type": "a - b = 0 ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α : Type _}  [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a - b = 0 ↔ a ≤ b := by rw [← nonpos_iff_eq_zero]; sorry",
  "name": "tsub_eq_zero_iff_le",
  "kind": "theorem",
  "first-tactic": "rw [← nonpos_iff_eq_zero]",
  "core-prompt":
  "{α : Type _}  [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a - b = 0 ↔ a ≤ b",
  "args":
  "{α : Type _}  [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α}"},
 {"type": "0 < a - b ↔ ¬a ≤ b",
  "tactic-prompt":
  "theorem {α : Type _}  [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : 0 < a - b ↔ ¬a ≤ b := by rw [pos_iff_ne_zero]; sorry",
  "name": "tsub_pos_iff_not_le",
  "kind": "theorem",
  "first-tactic": "rw [pos_iff_ne_zero]",
  "core-prompt":
  "{α : Type _}  [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : 0 < a - b ↔ ¬a ≤ b",
  "args":
  "{α : Type _}  [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α}"},
 {"type": "a - b ≤ a - c ↔ c ≤ b",
  "tactic-prompt":
  "theorem {α : Type _}  [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a)  (hc : AddLECancellable c)      (h : c ≤ a) : a - b ≤ a - c ↔ c ≤ b := by refine' ⟨_, fun h => tsub_le_tsub_left h a⟩; sorry",
  "name": "tsub_le_tsub_iff_left",
  "kind": "theorem",
  "first-tactic": "refine' ⟨_, fun h => tsub_le_tsub_left h a⟩",
  "core-prompt":
  "{α : Type _}  [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a)  (hc : AddLECancellable c)      (h : c ≤ a) : a - b ≤ a - c ↔ c ≤ b",
  "args":
  "{α : Type _}  [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a)  (hc : AddLECancellable c)      (h : c ≤ a)"},
 {"type": "a - b = a - c ↔ b = c",
  "tactic-prompt":
  "theorem {α : Type _}  [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a)  (hb : AddLECancellable b)      (hc : AddLECancellable c)  (hba : b ≤ a)  (hca : c ≤ a) : a - b = a - c ↔ b = c := by simp_rw [le_antisymm_iff]; sorry",
  "name": "tsub_right_inj",
  "kind": "theorem",
  "first-tactic": "simp_rw [le_antisymm_iff]",
  "core-prompt":
  "{α : Type _}  [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a)  (hb : AddLECancellable b)      (hc : AddLECancellable c)  (hba : b ≤ a)  (hca : c ≤ a) : a - b = a - c ↔ b = c",
  "args":
  "{α : Type _}  [CanonicallyOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a)  (hb : AddLECancellable b)      (hc : AddLECancellable c)  (hba : b ≤ a)  (hca : c ≤ a)"},
 {"type": "0 < a - b ↔ b < a",
  "tactic-prompt":
  "theorem {α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : 0 < a - b ↔ b < a := by rw [tsub_pos_iff_not_le]; sorry",
  "name": "tsub_pos_iff_lt",
  "kind": "theorem",
  "first-tactic": "rw [tsub_pos_iff_not_le]",
  "core-prompt":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : 0 < a - b ↔ b < a",
  "args":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α}"},
 {"type": "a - b = a - min a b",
  "tactic-prompt":
  "theorem {α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (a b : α) : a - b = a - min a b := by cases' le_total a b with h h; sorry",
  "name": "tsub_eq_tsub_min",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with h h",
  "core-prompt":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (a b : α) : a - b = a - min a b",
  "args":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (a b : α)"},
 {"type": "a - c < b - c ↔ a < b",
  "tactic-prompt":
  "theorem {α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : c ≤ a) : a - c < b - c ↔ a < b := by rw [hc.lt_tsub_iff_left]; sorry",
  "name": "tsub_lt_tsub_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [hc.lt_tsub_iff_left]",
  "core-prompt":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : c ≤ a) : a - c < b - c ↔ a < b",
  "args":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (hc : AddLECancellable c)  (h : c ≤ a)"},
 {"type": "a - b < a",
  "tactic-prompt":
  "theorem {α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a)  (h₁ : 0 < a)  (h₂ : 0 < b) : a - b < a := by refine' tsub_le_self.lt_of_ne fun h => _; sorry",
  "name": "tsub_lt_self",
  "kind": "theorem",
  "first-tactic": "refine' tsub_le_self.lt_of_ne fun h => _",
  "core-prompt":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a)  (h₁ : 0 < a)  (h₂ : 0 < b) : a - b < a",
  "args":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a)  (h₁ : 0 < a)  (h₂ : 0 < b)"},
 {"type": "a - b < a ↔ 0 < a ∧ 0 < b",
  "tactic-prompt":
  "theorem {α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a) : a - b < a ↔ 0 < a ∧ 0 < b := by refine'\n    ⟨fun h => ⟨(zero_le _).trans_lt h, (zero_le b).lt_of_ne _⟩, fun h => ha.tsub_lt_self h.1 h.2⟩; sorry",
  "name": "tsub_lt_self_iff",
  "kind": "theorem",
  "first-tactic":
  "refine'\n    ⟨fun h => ⟨(zero_le _).trans_lt h, (zero_le b).lt_of_ne _⟩, fun h => ha.tsub_lt_self h.1 h.2⟩",
  "core-prompt":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a) : a - b < a ↔ 0 < a ∧ 0 < b",
  "args":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} (ha : AddLECancellable a)"},
 {"type": "a - b + b = max a b",
  "tactic-prompt":
  "theorem {α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a - b + b = max a b := by cases' le_total a b with h h; sorry",
  "name": "tsub_add_eq_max",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with h h",
  "core-prompt":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a - b + b = max a b",
  "args":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α}"},
 {"type": "a + (b - a) = max a b",
  "tactic-prompt":
  "theorem {α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a + (b - a) = max a b := by rw [add_comm]; sorry",
  "name": "add_tsub_eq_max",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a + (b - a) = max a b",
  "args":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α}"},
 {"type": "a - min a b = a - b",
  "tactic-prompt":
  "theorem {α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a - min a b = a - b := by cases' le_total a b with h h; sorry",
  "name": "tsub_min",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with h h",
  "core-prompt":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a - min a b = a - b",
  "args":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α}"},
 {"type": "a - b + min a b = a",
  "tactic-prompt":
  "theorem {α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a - b + min a b = a := by rw [← tsub_min]; sorry",
  "name": "tsub_add_min",
  "kind": "theorem",
  "first-tactic": "rw [← tsub_min]",
  "core-prompt":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α} : a - b + min a b = a",
  "args":
  "{α : Type _}  [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]  {a b c d : α}"},
 {"type": "f a - f b ≤ f (a - b)",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  [Add α]  [Sub α]  [OrderedSub α]  {a b c d : α} [Preorder β]  [Add β]  [Sub β]  [OrderedSub β]  (f : AddHom α β)      (hf : Monotone f)  (a b : α) : f a - f b ≤ f (a - b) := by rw [tsub_le_iff_right]; sorry",
  "name": "AddHom.le_map_tsub",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_right]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  [Add α]  [Sub α]  [OrderedSub α]  {a b c d : α} [Preorder β]  [Add β]  [Sub β]  [OrderedSub β]  (f : AddHom α β)      (hf : Monotone f)  (a b : α) : f a - f b ≤ f (a - b)",
  "args":
  "{α β : Type _}  [Preorder α]  [Add α]  [Sub α]  [OrderedSub α]  {a b c d : α} [Preorder β]  [Add β]  [Sub β]  [OrderedSub β]  (f : AddHom α β)      (hf : Monotone f)  (a b : α)"},
 {"type": "a * c - b * c ≤ (a - b) * c",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  [Add α]  [Sub α]  [OrderedSub α]  {a b c d : α} {R : Type _}  [CommSemiring R]  [Preorder R]  [Sub R]  [OrderedSub R]      [CovariantClass R R (· * ·) (· ≤ ·)]  {a b c : R} : a * c - b * c ≤ (a - b) * c := by simpa only [mul_comm _ c] using le_mul_tsub; sorry",
  "name": "le_tsub_mul",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_comm _ c] using le_mul_tsub",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  [Add α]  [Sub α]  [OrderedSub α]  {a b c d : α} {R : Type _}  [CommSemiring R]  [Preorder R]  [Sub R]  [OrderedSub R]      [CovariantClass R R (· * ·) (· ≤ ·)]  {a b c : R} : a * c - b * c ≤ (a - b) * c",
  "args":
  "{α β : Type _}  [Preorder α]  [Add α]  [Sub α]  [OrderedSub α]  {a b c d : α} {R : Type _}  [CommSemiring R]  [Preorder R]  [Sub R]  [OrderedSub R]      [CovariantClass R R (· * ·) (· ≤ ·)]  {a b c : R}"},
 {"type": "e (a - b) = e a - e b",
  "tactic-prompt":
  "theorem {α β : Type _} {M N : Type _}  [Preorder M]  [Add M]  [Sub M]  [OrderedSub M]      [PartialOrder N]  [Add N]  [Sub N]  [OrderedSub N]  (e : M ≃o N)      (h_add : ∀ a b, e (a + b) = e a + e b)  (a b : M) : e (a - b) = e a - e b := by let e_add : M ≃+ N := { e with map_add' := h_add }; sorry",
  "name": "OrderIso.map_tsub",
  "kind": "theorem",
  "first-tactic": "let e_add : M ≃+ N := { e with map_add' := h_add }",
  "core-prompt":
  "{α β : Type _} {M N : Type _}  [Preorder M]  [Add M]  [Sub M]  [OrderedSub M]      [PartialOrder N]  [Add N]  [Sub N]  [OrderedSub N]  (e : M ≃o N)      (h_add : ∀ a b, e (a + b) = e a + e b)  (a b : M) : e (a - b) = e a - e b",
  "args":
  "{α β : Type _} {M N : Type _}  [Preorder M]  [Add M]  [Sub M]  [OrderedSub M]      [PartialOrder N]  [Add N]  [Sub N]  [OrderedSub N]  (e : M ≃o N)      (h_add : ∀ a b, e (a + b) = e a + e b)  (a b : M)"},
 {"type": "0 ≤ f a",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  [OrderedAddCommMonoid α]  [OrderedAddCommMonoid β]  [OrderAddMonoidHomClass F α β]  (f : F)    {a : α} (ha : 0 ≤ a) : 0 ≤ f a := by rw [← map_zero f]; sorry",
  "name": "map_nonneg",
  "kind": "theorem",
  "first-tactic": "rw [← map_zero f]",
  "core-prompt":
  "{F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  [OrderedAddCommMonoid α]  [OrderedAddCommMonoid β]  [OrderAddMonoidHomClass F α β]  (f : F)    {a : α} (ha : 0 ≤ a) : 0 ≤ f a",
  "args":
  "{F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  [OrderedAddCommMonoid α]  [OrderedAddCommMonoid β]  [OrderAddMonoidHomClass F α β]  (f : F)    {a : α} (ha : 0 ≤ a)"},
 {"type": "f a ≤ 0",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  [OrderedAddCommMonoid α]  [OrderedAddCommMonoid β]  [OrderAddMonoidHomClass F α β]  (f : F)    {a : α} (ha : a ≤ 0) : f a ≤ 0 := by rw [← map_zero f]; sorry",
  "name": "map_nonpos",
  "kind": "theorem",
  "first-tactic": "rw [← map_zero f]",
  "core-prompt":
  "{F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  [OrderedAddCommMonoid α]  [OrderedAddCommMonoid β]  [OrderAddMonoidHomClass F α β]  (f : F)    {a : α} (ha : a ≤ 0) : f a ≤ 0",
  "args":
  "{F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  [OrderedAddCommMonoid α]  [OrderedAddCommMonoid β]  [OrderAddMonoidHomClass F α β]  (f : F)    {a : α} (ha : a ≤ 0)"},
 {"type": "StrictMono (f : α → β) ↔ ∀ a, 0 < a → 0 < f a",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  [OrderedAddCommGroup α]  [OrderedAddCommMonoid β]  [AddMonoidHomClass F α β]  (f : F) [CovariantClass β β (· + ·) (· < ·)] : StrictMono (f : α → β) ↔ ∀ a, 0 < a → 0 < f a := by refine ⟨fun h a => ?_, fun h a b hl => ?_⟩; sorry",
  "name": "strictMono_iff_map_pos",
  "kind": "theorem",
  "first-tactic": "refine ⟨fun h a => ?_, fun h a b hl => ?_⟩",
  "core-prompt":
  "{F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  [OrderedAddCommGroup α]  [OrderedAddCommMonoid β]  [AddMonoidHomClass F α β]  (f : F) [CovariantClass β β (· + ·) (· < ·)] : StrictMono (f : α → β) ↔ ∀ a, 0 < a → 0 < f a",
  "args":
  "{F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  [OrderedAddCommGroup α]  [OrderedAddCommMonoid β]  [AddMonoidHomClass F α β]  (f : F) [CovariantClass β β (· + ·) (· < ·)]"},
 {"type": "f.comp (1 : α →*o β) = 1",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ]  [MulOneClass α]  [MulOneClass β]    [MulOneClass γ]  [MulOneClass δ]  {f g : α →*o β} (f : β →*o γ) : f.comp (1 : α →*o β) = 1 := by ext; sorry",
  "name": "comp_one",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ]  [MulOneClass α]  [MulOneClass β]    [MulOneClass γ]  [MulOneClass δ]  {f g : α →*o β} (f : β →*o γ) : f.comp (1 : α →*o β) = 1",
  "args":
  "{F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ]  [MulOneClass α]  [MulOneClass β]    [MulOneClass γ]  [MulOneClass δ]  {f g : α →*o β} (f : β →*o γ)"},
 {"type": "g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  [OrderedCommMonoid α]  [OrderedCommMonoid β]  [OrderedCommMonoid γ] (g : β →*o γ)  (f₁ f₂ : α →*o β) : g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂ := by ext; sorry",
  "name": "comp_mul",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  [OrderedCommMonoid α]  [OrderedCommMonoid β]  [OrderedCommMonoid γ] (g : β →*o γ)  (f₁ f₂ : α →*o β) : g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂",
  "args":
  "{F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  [OrderedCommMonoid α]  [OrderedCommMonoid β]  [OrderedCommMonoid γ] (g : β →*o γ)  (f₁ f₂ : α →*o β)"},
 {"type": "f.toMonoidHom = f",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  {hα : OrderedCommMonoid α}  {hβ : OrderedCommMonoid β} (f : α →*o β) : f.toMonoidHom = f := by ext; sorry",
  "name": "toMonoidHom_eq_coe",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  {hα : OrderedCommMonoid α}  {hβ : OrderedCommMonoid β} (f : α →*o β) : f.toMonoidHom = f",
  "args":
  "{F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  {hα : OrderedCommMonoid α}  {hβ : OrderedCommMonoid β} (f : α →*o β)"},
 {"type": "f.toMonoidWithZeroHom = f",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  {hα : Preorder α}  {hα' : MulZeroOneClass α}  {hβ : Preorder β}  {hβ' : MulZeroOneClass β} (f : α →*₀o β) : f.toMonoidWithZeroHom = f := by ext; sorry",
  "name": "toMonoidWithZeroHom_eq_coe",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  {hα : Preorder α}  {hα' : MulZeroOneClass α}  {hβ : Preorder β}  {hβ' : MulZeroOneClass β} (f : α →*₀o β) : f.toMonoidWithZeroHom = f",
  "args":
  "{F α β γ δ : Type _}    [Preorder α]  [Preorder β]  [MulZeroOneClass α]  [MulZeroOneClass β]  {hα : Preorder α}  {hα' : MulZeroOneClass α}  {hβ : Preorder β}  {hβ' : MulZeroOneClass β} (f : α →*₀o β)"},
 {"type": "f a ≤ f b * f (a / b)",
  "tactic-prompt":
  "theorem {ι F α β γ δ : Type _} [Group α]  [CommSemigroup β]  [LE β]  [SubMultiplicativeHomClass F α β]      (f : F)  (a b : α) : f a ≤ f b * f (a / b) := by simpa only [mul_comm]; sorry",
  "name": "le_map_mul_map_div",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_comm]",
  "core-prompt":
  "{ι F α β γ δ : Type _} [Group α]  [CommSemigroup β]  [LE β]  [SubMultiplicativeHomClass F α β]      (f : F)  (a b : α) : f a ≤ f b * f (a / b)",
  "args":
  "{ι F α β γ δ : Type _} [Group α]  [CommSemigroup β]  [LE β]  [SubMultiplicativeHomClass F α β]      (f : F)  (a b : α)"},
 {"type": "f a ≤ f b + f (a / b)",
  "tactic-prompt":
  "theorem {ι F α β γ δ : Type _} [Group α]  [AddCommSemigroup β]  [LE β]  [MulLEAddHomClass F α β]  (f : F)      (a b : α) : f a ≤ f b + f (a / b) := by simpa only [add_comm]; sorry",
  "name": "le_map_add_map_div",
  "kind": "theorem",
  "first-tactic": "simpa only [add_comm]",
  "core-prompt":
  "{ι F α β γ δ : Type _} [Group α]  [AddCommSemigroup β]  [LE β]  [MulLEAddHomClass F α β]  (f : F)      (a b : α) : f a ≤ f b + f (a / b)",
  "args":
  "{ι F α β γ δ : Type _} [Group α]  [AddCommSemigroup β]  [LE β]  [MulLEAddHomClass F α β]  (f : F)      (a b : α)"},
 {"type": "f (a / c) ≤ f (a / b) * f (b / c)",
  "tactic-prompt":
  "theorem {ι F α β γ δ : Type _} [Group α]  [CommSemigroup β]  [LE β]  [SubMultiplicativeHomClass F α β]      (f : F)  (a b c : α) : f (a / c) ≤ f (a / b) * f (b / c) := by simpa only [div_mul_div_cancel'] using map_mul_le_mul f (a / b) (b / c); sorry",
  "name": "le_map_div_mul_map_div",
  "kind": "theorem",
  "first-tactic":
  "simpa only [div_mul_div_cancel'] using map_mul_le_mul f (a / b) (b / c)",
  "core-prompt":
  "{ι F α β γ δ : Type _} [Group α]  [CommSemigroup β]  [LE β]  [SubMultiplicativeHomClass F α β]      (f : F)  (a b c : α) : f (a / c) ≤ f (a / b) * f (b / c)",
  "args":
  "{ι F α β γ δ : Type _} [Group α]  [CommSemigroup β]  [LE β]  [SubMultiplicativeHomClass F α β]      (f : F)  (a b c : α)"},
 {"type": "f (a / c) ≤ f (a / b) + f (b / c)",
  "tactic-prompt":
  "theorem {ι F α β γ δ : Type _} [Group α]  [AddCommSemigroup β]  [LE β]  [MulLEAddHomClass F α β]      (f : F)  (a b c : α) : f (a / c) ≤ f (a / b) + f (b / c) := by simpa only [div_mul_div_cancel'] using map_mul_le_add f (a / b) (b / c); sorry",
  "name": "le_map_div_add_map_div",
  "kind": "theorem",
  "first-tactic":
  "simpa only [div_mul_div_cancel'] using map_mul_le_add f (a / b) (b / c)",
  "core-prompt":
  "{ι F α β γ δ : Type _} [Group α]  [AddCommSemigroup β]  [LE β]  [MulLEAddHomClass F α β]      (f : F)  (a b c : α) : f (a / c) ≤ f (a / b) + f (b / c)",
  "args":
  "{ι F α β γ δ : Type _} [Group α]  [AddCommSemigroup β]  [LE β]  [MulLEAddHomClass F α β]      (f : F)  (a b c : α)"},
 {"type": "0 < bit1 a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  (h : 0 < a) : 0 < bit1 a := by nontriviality; sorry",
  "name": "bit1_pos'",
  "kind": "theorem",
  "first-tactic": "nontriviality",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  (h : 0 < a) : 0 < bit1 a",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  (h : 0 < a)"},
 {"type": "c * a ≤ c * b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [OrderedRing α]  {a b c d : α}  -- see Note [lower instance priority] (h : b ≤ a)  (hc : c ≤ 0) : c * a ≤ c * b := by simpa only [neg_mul]; sorry",
  "name": "mul_le_mul_of_nonpos_left",
  "kind": "theorem",
  "first-tactic": "simpa only [neg_mul]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [OrderedRing α]  {a b c d : α}  -- see Note [lower instance priority] (h : b ≤ a)  (hc : c ≤ 0) : c * a ≤ c * b",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [OrderedRing α]  {a b c d : α}  -- see Note [lower instance priority] (h : b ≤ a)  (hc : c ≤ 0)"},
 {"type": "a * c ≤ b * c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [OrderedRing α]  {a b c d : α}  -- see Note [lower instance priority] (h : b ≤ a)  (hc : c ≤ 0) : a * c ≤ b * c := by simpa only [mul_neg]; sorry",
  "name": "mul_le_mul_of_nonpos_right",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_neg]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [OrderedRing α]  {a b c d : α}  -- see Note [lower instance priority] (h : b ≤ a)  (hc : c ≤ 0) : a * c ≤ b * c",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [OrderedRing α]  {a b c d : α}  -- see Note [lower instance priority] (h : b ≤ a)  (hc : c ≤ 0)"},
 {"type": "0 ≤ a * b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [OrderedRing α]  {a b c d : α}  -- see Note [lower instance priority] (ha : a ≤ 0)  (hb : b ≤ 0) : 0 ≤ a * b := by simpa only [zero_mul] using mul_le_mul_of_nonpos_right ha hb; sorry",
  "name": "mul_nonneg_of_nonpos_of_nonpos",
  "kind": "theorem",
  "first-tactic":
  "simpa only [zero_mul] using mul_le_mul_of_nonpos_right ha hb",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [OrderedRing α]  {a b c d : α}  -- see Note [lower instance priority] (ha : a ≤ 0)  (hb : b ≤ 0) : 0 ≤ a * b",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [OrderedRing α]  {a b c d : α}  -- see Note [lower instance priority] (ha : a ≤ 0)  (hb : b ≤ 0)"},
 {"type": "a < c → b < d → 0 ≤ a → 0 ≤ b → a * b < c * d",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] : a < c → b < d → 0 ≤ a → 0 ≤ b → a * b < c * d := by classical\n  exact Decidable.mul_lt_mul''; sorry",
  "name": "mul_lt_mul''",
  "kind": "theorem",
  "first-tactic": "classical\n  exact Decidable.mul_lt_mul''",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] : a < c → b < d → 0 ≤ a → 0 ≤ b → a * b < c * d",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]"},
 {"type": "a < b * a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] (hn : 0 < a)  (hm : 1 < b) : a < b * a := by convert mul_lt_mul_of_pos_right hm hn; sorry",
  "name": "lt_mul_left",
  "kind": "theorem",
  "first-tactic": "convert mul_lt_mul_of_pos_right hm hn",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] (hn : 0 < a)  (hm : 1 < b) : a < b * a",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] (hn : 0 < a)  (hm : 1 < b)"},
 {"type": "a < a * b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] (hn : 0 < a)  (hm : 1 < b) : a < a * b := by convert mul_lt_mul_of_pos_left hm hn; sorry",
  "name": "lt_mul_right",
  "kind": "theorem",
  "first-tactic": "convert mul_lt_mul_of_pos_left hm hn",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] (hn : 0 < a)  (hm : 1 < b) : a < a * b",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] (hn : 0 < a)  (hm : 1 < b)"},
 {"type": "c * a < c * b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedRing α]  {a b c : α}  -- see Note [lower instance priority] (h : b < a)  (hc : c < 0) : c * a < c * b := by simpa only [neg_mul]; sorry",
  "name": "mul_lt_mul_of_neg_left",
  "kind": "theorem",
  "first-tactic": "simpa only [neg_mul]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedRing α]  {a b c : α}  -- see Note [lower instance priority] (h : b < a)  (hc : c < 0) : c * a < c * b",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedRing α]  {a b c : α}  -- see Note [lower instance priority] (h : b < a)  (hc : c < 0)"},
 {"type": "a * c < b * c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedRing α]  {a b c : α}  -- see Note [lower instance priority] (h : b < a)  (hc : c < 0) : a * c < b * c := by simpa only [mul_neg]; sorry",
  "name": "mul_lt_mul_of_neg_right",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_neg]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedRing α]  {a b c : α}  -- see Note [lower instance priority] (h : b < a)  (hc : c < 0) : a * c < b * c",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedRing α]  {a b c : α}  -- see Note [lower instance priority] (h : b < a)  (hc : c < 0)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedRing α]  {a b c : α}  -- see Note [lower instance priority] {a b : α}  (ha : a < 0)  (hb : b < 0) : 0 < a * b := by simpa only [zero_mul] using mul_lt_mul_of_neg_right ha hb; sorry",
  "name": "mul_pos_of_neg_of_neg",
  "kind": "theorem",
  "first-tactic": "simpa only [zero_mul] using mul_lt_mul_of_neg_right ha hb",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedRing α]  {a b c : α}  -- see Note [lower instance priority] {a b : α}  (ha : a < 0)  (hb : b < 0) : 0 < a * b",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [StrictOrderedRing α]  {a b c : α}  -- see Note [lower instance priority] {a b : α}  (ha : a < 0)  (hb : b < 0)"},
 {"type": "0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] (hab : 0 ≤ a * b) : 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0 := by refine' Decidable.or_iff_not_and_not.2 _; sorry",
  "name": "nonneg_and_nonneg_or_nonpos_and_nonpos_of_mul_nnonneg",
  "kind": "theorem",
  "first-tactic": "refine' Decidable.or_iff_not_and_not.2 _",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] (hab : 0 ≤ a * b) : 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] (hab : 0 ≤ a * b)"},
 {"type": "0 ≤ c * b ↔ 0 ≤ b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] (h : 0 < c) : 0 ≤ c * b ↔ 0 ≤ b := by simpa using (mul_le_mul_left h : c * 0 ≤ c * b ↔ 0 ≤ b); sorry",
  "name": "zero_le_mul_left",
  "kind": "theorem",
  "first-tactic": "simpa using (mul_le_mul_left h : c * 0 ≤ c * b ↔ 0 ≤ b)",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] (h : 0 < c) : 0 ≤ c * b ↔ 0 ≤ b",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] (h : 0 < c)"},
 {"type": "0 ≤ b * c ↔ 0 ≤ b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] (h : 0 < c) : 0 ≤ b * c ↔ 0 ≤ b := by simpa using (mul_le_mul_right h : 0 * c ≤ b * c ↔ 0 ≤ b); sorry",
  "name": "zero_le_mul_right",
  "kind": "theorem",
  "first-tactic": "simpa using (mul_le_mul_right h : 0 * c ≤ b * c ↔ 0 ≤ b)",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] (h : 0 < c) : 0 ≤ b * c ↔ 0 ≤ b",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] (h : 0 < c)"},
 {"type": "bit0 a ≤ bit0 b ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] : bit0 a ≤ bit0 b ↔ a ≤ b := by rw [bit0]; sorry",
  "name": "bit0_le_bit0",
  "kind": "theorem",
  "first-tactic": "rw [bit0]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] : bit0 a ≤ bit0 b ↔ a ≤ b",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]"},
 {"type": "bit0 a < bit0 b ↔ a < b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] : bit0 a < bit0 b ↔ a < b := by rw [bit0]; sorry",
  "name": "bit0_lt_bit0",
  "kind": "theorem",
  "first-tactic": "rw [bit0]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] : bit0 a < bit0 b ↔ a < b",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]"},
 {"type": "(1 : α) ≤ bit1 a ↔ 0 ≤ a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] : (1 : α) ≤ bit1 a ↔ 0 ≤ a := by rw [bit1]; sorry",
  "name": "one_le_bit1",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] : (1 : α) ≤ bit1 a ↔ 0 ≤ a",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]"},
 {"type": "(1 : α) < bit1 a ↔ 0 < a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] : (1 : α) < bit1 a ↔ 0 < a := by rw [bit1]; sorry",
  "name": "one_lt_bit1",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] : (1 : α) < bit1 a ↔ 0 < a",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]"},
 {"type": "(0 : α) ≤ bit0 a ↔ 0 ≤ a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] : (0 : α) ≤ bit0 a ↔ 0 ≤ a := by rw [bit0]; sorry",
  "name": "zero_le_bit0",
  "kind": "theorem",
  "first-tactic": "rw [bit0]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] : (0 : α) ≤ bit0 a ↔ 0 ≤ a",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]"},
 {"type": "(0 : α) < bit0 a ↔ 0 < a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] : (0 : α) < bit0 a ↔ 0 < a := by rw [bit0]; sorry",
  "name": "zero_lt_bit0",
  "kind": "theorem",
  "first-tactic": "rw [bit0]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority] : (0 : α) < bit0 a ↔ 0 < a",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]"},
 {"type": "a * b < 0 ↔ 0 < a ∧ b < 0 ∨ a < 0 ∧ 0 < b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} : a * b < 0 ↔ 0 < a ∧ b < 0 ∨ a < 0 ∧ 0 < b := by rw [← neg_pos]; sorry",
  "name": "mul_neg_iff",
  "kind": "theorem",
  "first-tactic": "rw [← neg_pos]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} : a * b < 0 ↔ 0 < a ∧ b < 0 ∨ a < 0 ∧ 0 < b",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α}"},
 {"type": "0 ≤ a * b ∨ 0 ≤ b * c ∨ 0 ≤ c * a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} (a b c : α) : 0 ≤ a * b ∨ 0 ≤ b * c ∨ 0 ≤ c * a := by iterate 3 rw [mul_nonneg_iff]; sorry",
  "name": "mul_nonneg_of_three",
  "kind": "theorem",
  "first-tactic": "iterate 3 rw [mul_nonneg_iff]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} (a b c : α) : 0 ≤ a * b ∨ 0 ≤ b * c ∨ 0 ≤ c * a",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} (a b c : α)"},
 {"type": "a * b ≤ 0 ↔ 0 ≤ a ∧ b ≤ 0 ∨ a ≤ 0 ∧ 0 ≤ b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} : a * b ≤ 0 ↔ 0 ≤ a ∧ b ≤ 0 ∨ a ≤ 0 ∧ 0 ≤ b := by rw [← neg_nonneg]; sorry",
  "name": "mul_nonpos_iff",
  "kind": "theorem",
  "first-tactic": "rw [← neg_nonneg]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} : a * b ≤ 0 ↔ 0 ≤ a ∧ b ≤ 0 ∨ a ≤ 0 ∧ 0 ≤ b",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α}"},
 {"type": "-a ≤ a ↔ 0 ≤ a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} : -a ≤ a ↔ 0 ≤ a := by simp [neg_le_iff_add_nonneg]; sorry",
  "name": "neg_le_self_iff",
  "kind": "theorem",
  "first-tactic": "simp [neg_le_iff_add_nonneg]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} : -a ≤ a ↔ 0 ≤ a",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α}"},
 {"type": "-a < a ↔ 0 < a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} : -a < a ↔ 0 < a := by simp [neg_lt_iff_pos_add]; sorry",
  "name": "neg_lt_self_iff",
  "kind": "theorem",
  "first-tactic": "simp [neg_lt_iff_pos_add]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} : -a < a ↔ 0 < a",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α}"},
 {"type": "0 < a * a ↔ a ≠ 0",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} {a : α} : 0 < a * a ↔ a ≠ 0 := by constructor; sorry",
  "name": "mul_self_pos",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} {a : α} : 0 < a * a ↔ a ≠ 0",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} {a : α}"},
 {"type": "x * x + y * y = 0 ↔ x = 0 ∧ y = 0",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0 := by rw [add_eq_zero_iff']; sorry",
  "name": "mul_self_add_mul_self_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [add_eq_zero_iff']",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0",
  "args":
  "{α : Type u}  {β : Type _}  [OrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedSemiring α]  {a b c d : α}  -- see Note [lower instance priority]  [LinearOrderedRing α]  {a b c : α} {x y : α}"},
 {"type": "a * d + b * c ≤ a * c + b * d",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [StrictOrderedSemiring α]  {a b c d : α}  [ExistsAddOfLE α] (hab : a ≤ b)  (hcd : c ≤ d) : a * d + b * c ≤ a * c + b * d := by obtain ⟨b, rfl⟩ := exists_add_of_le hab; sorry",
  "name": "mul_add_mul_le_mul_add_mul",
  "kind": "theorem",
  "first-tactic": "obtain ⟨b, rfl⟩ := exists_add_of_le hab",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [StrictOrderedSemiring α]  {a b c d : α}  [ExistsAddOfLE α] (hab : a ≤ b)  (hcd : c ≤ d) : a * d + b * c ≤ a * c + b * d",
  "args":
  "{α : Type u}  {β : Type _}  [StrictOrderedSemiring α]  {a b c d : α}  [ExistsAddOfLE α] (hab : a ≤ b)  (hcd : c ≤ d)"},
 {"type": "a • d + b • c ≤ a • c + b • d",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [StrictOrderedSemiring α]  {a b c d : α}  [ExistsAddOfLE α] (hba : b ≤ a)  (hdc : d ≤ c) : a • d + b • c ≤ a • c + b • d := by rw [add_comm (a • d)]; sorry",
  "name": "mul_add_mul_le_mul_add_mul'",
  "kind": "theorem",
  "first-tactic": "rw [add_comm (a • d)]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [StrictOrderedSemiring α]  {a b c d : α}  [ExistsAddOfLE α] (hba : b ≤ a)  (hdc : d ≤ c) : a • d + b • c ≤ a • c + b • d",
  "args":
  "{α : Type u}  {β : Type _}  [StrictOrderedSemiring α]  {a b c d : α}  [ExistsAddOfLE α] (hba : b ≤ a)  (hdc : d ≤ c)"},
 {"type": "a * d + b * c < a * c + b * d",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [StrictOrderedSemiring α]  {a b c d : α}  [ExistsAddOfLE α] (hab : a < b)  (hcd : c < d) : a * d + b * c < a * c + b * d := by obtain ⟨b, rfl⟩ := exists_add_of_le hab.le; sorry",
  "name": "mul_add_mul_lt_mul_add_mul",
  "kind": "theorem",
  "first-tactic": "obtain ⟨b, rfl⟩ := exists_add_of_le hab.le",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [StrictOrderedSemiring α]  {a b c d : α}  [ExistsAddOfLE α] (hab : a < b)  (hcd : c < d) : a * d + b * c < a * c + b * d",
  "args":
  "{α : Type u}  {β : Type _}  [StrictOrderedSemiring α]  {a b c d : α}  [ExistsAddOfLE α] (hab : a < b)  (hcd : c < d)"},
 {"type": "a • d + b • c < a • c + b • d",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  [StrictOrderedSemiring α]  {a b c d : α}  [ExistsAddOfLE α] (hba : b < a)  (hdc : d < c) : a • d + b • c < a • c + b • d := by rw [add_comm (a • d)]; sorry",
  "name": "mul_add_mul_lt_mul_add_mul'",
  "kind": "theorem",
  "first-tactic": "rw [add_comm (a • d)]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  [StrictOrderedSemiring α]  {a b c d : α}  [ExistsAddOfLE α] (hba : b < a)  (hdc : d < c) : a • d + b • c < a • c + b • d",
  "args":
  "{α : Type u}  {β : Type _}  [StrictOrderedSemiring α]  {a b c d : α}  [ExistsAddOfLE α] (hba : b < a)  (hdc : d < c)"},
 {"type": "0 < a * b ↔ 0 < a ∧ 0 < b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _} [CanonicallyOrderedCommSemiring α]  {a b : α}  -- see Note [lower instance priority] : 0 < a * b ↔ 0 < a ∧ 0 < b := by simp only [pos_iff_ne_zero]; sorry",
  "name": "mul_pos",
  "kind": "theorem",
  "first-tactic": "simp only [pos_iff_ne_zero]",
  "core-prompt":
  "{α : Type u}  {β : Type _} [CanonicallyOrderedCommSemiring α]  {a b : α}  -- see Note [lower instance priority] : 0 < a * b ↔ 0 < a ∧ 0 < b",
  "args":
  "{α : Type u}  {β : Type _} [CanonicallyOrderedCommSemiring α]  {a b : α}  -- see Note [lower instance priority]"},
 {"type": "a * (b - c) = a * b - a * c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _} [CanonicallyOrderedCommSemiring α]  {a b : α}  -- see Note [lower instance priority]  [CanonicallyOrderedCommSemiring α]  {a b c : α} [Sub α]  [OrderedSub α] [IsTotal α (· ≤ ·)] (h : AddLECancellable (a * c)) : a * (b - c) = a * b - a * c := by cases' total_of (· ≤ ·) b c with hbc hcb; sorry",
  "name": "mul_tsub",
  "kind": "theorem",
  "first-tactic": "cases' total_of (· ≤ ·) b c with hbc hcb",
  "core-prompt":
  "{α : Type u}  {β : Type _} [CanonicallyOrderedCommSemiring α]  {a b : α}  -- see Note [lower instance priority]  [CanonicallyOrderedCommSemiring α]  {a b c : α} [Sub α]  [OrderedSub α] [IsTotal α (· ≤ ·)] (h : AddLECancellable (a * c)) : a * (b - c) = a * b - a * c",
  "args":
  "{α : Type u}  {β : Type _} [CanonicallyOrderedCommSemiring α]  {a b : α}  -- see Note [lower instance priority]  [CanonicallyOrderedCommSemiring α]  {a b c : α} [Sub α]  [OrderedSub α] [IsTotal α (· ≤ ·)] (h : AddLECancellable (a * c))"},
 {"type": "(a - b) * c = a * c - b * c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _} [CanonicallyOrderedCommSemiring α]  {a b : α}  -- see Note [lower instance priority]  [CanonicallyOrderedCommSemiring α]  {a b c : α} [Sub α]  [OrderedSub α] [IsTotal α (· ≤ ·)] (h : AddLECancellable (b * c)) : (a - b) * c = a * c - b * c := by simp only [mul_comm _ c] at *; sorry",
  "name": "tsub_mul",
  "kind": "theorem",
  "first-tactic": "simp only [mul_comm _ c] at *",
  "core-prompt":
  "{α : Type u}  {β : Type _} [CanonicallyOrderedCommSemiring α]  {a b : α}  -- see Note [lower instance priority]  [CanonicallyOrderedCommSemiring α]  {a b c : α} [Sub α]  [OrderedSub α] [IsTotal α (· ≤ ·)] (h : AddLECancellable (b * c)) : (a - b) * c = a * c - b * c",
  "args":
  "{α : Type u}  {β : Type _} [CanonicallyOrderedCommSemiring α]  {a b : α}  -- see Note [lower instance priority]  [CanonicallyOrderedCommSemiring α]  {a b c : α} [Sub α]  [OrderedSub α] [IsTotal α (· ≤ ·)] (h : AddLECancellable (b * c))"},
 {"type": "|a * b| = |a| * |b|",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedRing α]  {a b c : α} (a b : α) : |a * b| = |a| * |b| := by rw [abs_eq (mul_nonneg (abs_nonneg a) (abs_nonneg b))]; sorry",
  "name": "abs_mul",
  "kind": "theorem",
  "first-tactic": "rw [abs_eq (mul_nonneg (abs_nonneg a) (abs_nonneg b))]",
  "core-prompt":
  "{α : Type _}  [LinearOrderedRing α]  {a b c : α} (a b : α) : |a * b| = |a| * |b|",
  "args": "{α : Type _}  [LinearOrderedRing α]  {a b c : α} (a b : α)"},
 {"type": "|a * a| = a * a",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedRing α]  {a b c : α} (a : α) : |a * a| = a * a := by rw [abs_mul]; sorry",
  "name": "abs_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [abs_mul]",
  "core-prompt":
  "{α : Type _}  [LinearOrderedRing α]  {a b c : α} (a : α) : |a * a| = a * a",
  "args": "{α : Type _}  [LinearOrderedRing α]  {a b c : α} (a : α)"},
 {"type": "|a| = a ↔ 0 ≤ a",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedRing α]  {a b c : α} : |a| = a ↔ 0 ≤ a := by simp [abs_eq_max_neg]; sorry",
  "name": "abs_eq_self",
  "kind": "theorem",
  "first-tactic": "simp [abs_eq_max_neg]",
  "core-prompt":
  "{α : Type _}  [LinearOrderedRing α]  {a b c : α} : |a| = a ↔ 0 ≤ a",
  "args": "{α : Type _}  [LinearOrderedRing α]  {a b c : α}"},
 {"type": "|a| = -a ↔ a ≤ 0",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedRing α]  {a b c : α} : |a| = -a ↔ a ≤ 0 := by simp [abs_eq_max_neg]; sorry",
  "name": "abs_eq_neg_self",
  "kind": "theorem",
  "first-tactic": "simp [abs_eq_max_neg]",
  "core-prompt":
  "{α : Type _}  [LinearOrderedRing α]  {a b c : α} : |a| = -a ↔ a ≤ 0",
  "args": "{α : Type _}  [LinearOrderedRing α]  {a b c : α}"},
 {"type": "|a| = a ∧ 0 ≤ a ∨ |a| = -a ∧ a < 0",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedRing α]  {a b c : α} (a : α) : |a| = a ∧ 0 ≤ a ∨ |a| = -a ∧ a < 0 := by by_cases h : 0 ≤ a; sorry",
  "name": "abs_cases",
  "kind": "theorem",
  "first-tactic": "by_cases h : 0 ≤ a",
  "core-prompt":
  "{α : Type _}  [LinearOrderedRing α]  {a b c : α} (a : α) : |a| = a ∧ 0 ≤ a ∨ |a| = -a ∧ a < 0",
  "args": "{α : Type _}  [LinearOrderedRing α]  {a b c : α} (a : α)"},
 {"type": "max a 0 + max (-a) 0 = |a|",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedRing α]  {a b c : α} (a : α) : max a 0 + max (-a) 0 = |a| := by symm; sorry",
  "name": "max_zero_add_max_neg_zero_eq_abs_self",
  "kind": "theorem",
  "first-tactic": "symm",
  "core-prompt":
  "{α : Type _}  [LinearOrderedRing α]  {a b c : α} (a : α) : max a 0 + max (-a) 0 = |a|",
  "args": "{α : Type _}  [LinearOrderedRing α]  {a b c : α} (a : α)"},
 {"type": "|a| = |b| ↔ a * a = b * b",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedRing α]  {a b c : α} : |a| = |b| ↔ a * a = b * b := by rw [← abs_mul_abs_self]; sorry",
  "name": "abs_eq_iff_mul_self_eq",
  "kind": "theorem",
  "first-tactic": "rw [← abs_mul_abs_self]",
  "core-prompt":
  "{α : Type _}  [LinearOrderedRing α]  {a b c : α} : |a| = |b| ↔ a * a = b * b",
  "args": "{α : Type _}  [LinearOrderedRing α]  {a b c : α}"},
 {"type": "|a| < |b| ↔ a * a < b * b",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedRing α]  {a b c : α} : |a| < |b| ↔ a * a < b * b := by rw [← abs_mul_abs_self]; sorry",
  "name": "abs_lt_iff_mul_self_lt",
  "kind": "theorem",
  "first-tactic": "rw [← abs_mul_abs_self]",
  "core-prompt":
  "{α : Type _}  [LinearOrderedRing α]  {a b c : α} : |a| < |b| ↔ a * a < b * b",
  "args": "{α : Type _}  [LinearOrderedRing α]  {a b c : α}"},
 {"type": "|a| ≤ |b| ↔ a * a ≤ b * b",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedRing α]  {a b c : α} : |a| ≤ |b| ↔ a * a ≤ b * b := by rw [← abs_mul_abs_self]; sorry",
  "name": "abs_le_iff_mul_self_le",
  "kind": "theorem",
  "first-tactic": "rw [← abs_mul_abs_self]",
  "core-prompt":
  "{α : Type _}  [LinearOrderedRing α]  {a b c : α} : |a| ≤ |b| ↔ a * a ≤ b * b",
  "args": "{α : Type _}  [LinearOrderedRing α]  {a b c : α}"},
 {"type": "|a| ≤ 1 ↔ a * a ≤ 1",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedRing α]  {a b c : α} : |a| ≤ 1 ↔ a * a ≤ 1 := by simpa only [abs_one]; sorry",
  "name": "abs_le_one_iff_mul_self_le_one",
  "kind": "theorem",
  "first-tactic": "simpa only [abs_one]",
  "core-prompt":
  "{α : Type _}  [LinearOrderedRing α]  {a b c : α} : |a| ≤ 1 ↔ a * a ≤ 1",
  "args": "{α : Type _}  [LinearOrderedRing α]  {a b c : α}"},
 {"type": "|a - b| * |a - b| = a * a + b * b - (1 + 1) * a * b",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedCommRing α]  {a b c d : α} (a b : α) : |a - b| * |a - b| = a * a + b * b - (1 + 1) * a * b := by rw [abs_mul_abs_self]; sorry",
  "name": "abs_sub_sq",
  "kind": "theorem",
  "first-tactic": "rw [abs_mul_abs_self]",
  "core-prompt":
  "{α : Type _}  [LinearOrderedCommRing α]  {a b c d : α} (a b : α) : |a - b| * |a - b| = a * a + b * b - (1 + 1) * a * b",
  "args": "{α : Type _}  [LinearOrderedCommRing α]  {a b c d : α} (a b : α)"},
 {"type": "|a| ∣ b ↔ a ∣ b",
  "tactic-prompt":
  "theorem {α : Type _}  [Ring α]  [LinearOrder α]  {a b : α} (a b : α) : |a| ∣ b ↔ a ∣ b := by cases' abs_choice a with h h; sorry",
  "name": "abs_dvd",
  "kind": "theorem",
  "first-tactic": "cases' abs_choice a with h h",
  "core-prompt":
  "{α : Type _}  [Ring α]  [LinearOrder α]  {a b : α} (a b : α) : |a| ∣ b ↔ a ∣ b",
  "args": "{α : Type _}  [Ring α]  [LinearOrder α]  {a b : α} (a b : α)"},
 {"type": "a ∣ |b| ↔ a ∣ b",
  "tactic-prompt":
  "theorem {α : Type _}  [Ring α]  [LinearOrder α]  {a b : α} (a b : α) : a ∣ |b| ↔ a ∣ b := by cases' abs_choice b with h h; sorry",
  "name": "dvd_abs",
  "kind": "theorem",
  "first-tactic": "cases' abs_choice b with h h",
  "core-prompt":
  "{α : Type _}  [Ring α]  [LinearOrder α]  {a b : α} (a b : α) : a ∣ |b| ↔ a ∣ b",
  "args": "{α : Type _}  [Ring α]  [LinearOrder α]  {a b : α} (a b : α)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [PosMulStrictMono α]  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b := by simpa only [mul_zero] using mul_lt_mul_of_pos_left hb ha; sorry",
  "name": "Left.mul_pos",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_zero] using mul_lt_mul_of_pos_left hb ha",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [PosMulStrictMono α]  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [PosMulStrictMono α]  (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a * b < 0",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [PosMulStrictMono α]  (ha : 0 < a)  (hb : b < 0) : a * b < 0 := by simpa only [mul_zero] using mul_lt_mul_of_pos_left hb ha; sorry",
  "name": "mul_neg_of_pos_of_neg",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_zero] using mul_lt_mul_of_pos_left hb ha",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [PosMulStrictMono α]  (ha : 0 < a)  (hb : b < 0) : a * b < 0",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [PosMulStrictMono α]  (ha : 0 < a)  (hb : b < 0)"},
 {"type": "0 < c * b ↔ 0 < b",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [PosMulStrictMono α]  [PosMulReflectLT α]  (h : 0 < c) : 0 < c * b ↔ 0 < b := by rw [←mul_zero c]; sorry",
  "name": "zero_lt_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [←mul_zero c]",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [PosMulStrictMono α]  [PosMulReflectLT α]  (h : 0 < c) : 0 < c * b ↔ 0 < b",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [PosMulStrictMono α]  [PosMulReflectLT α]  (h : 0 < c)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [MulPosStrictMono α]  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b := by simpa only [zero_mul] using mul_lt_mul_of_pos_right ha hb; sorry",
  "name": "Right.mul_pos",
  "kind": "theorem",
  "first-tactic": "simpa only [zero_mul] using mul_lt_mul_of_pos_right ha hb",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [MulPosStrictMono α]  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [MulPosStrictMono α]  (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a * b < 0",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [MulPosStrictMono α]  (ha : a < 0)  (hb : 0 < b) : a * b < 0 := by simpa only [zero_mul] using mul_lt_mul_of_pos_right ha hb; sorry",
  "name": "mul_neg_of_neg_of_pos",
  "kind": "theorem",
  "first-tactic": "simpa only [zero_mul] using mul_lt_mul_of_pos_right ha hb",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [MulPosStrictMono α]  (ha : a < 0)  (hb : 0 < b) : a * b < 0",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [MulPosStrictMono α]  (ha : a < 0)  (hb : 0 < b)"},
 {"type": "0 < b * c ↔ 0 < b",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [MulPosStrictMono α]  [MulPosReflectLT α]  (h : 0 < c) : 0 < b * c ↔ 0 < b := by rw [←zero_mul c]; sorry",
  "name": "zero_lt_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [←zero_mul c]",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [MulPosStrictMono α]  [MulPosReflectLT α]  (h : 0 < c) : 0 < b * c ↔ 0 < b",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [MulPosStrictMono α]  [MulPosReflectLT α]  (h : 0 < c)"},
 {"type": "0 ≤ a * b",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [PosMulMono α]  (ha : 0 ≤ a)  (hb : 0 ≤ b) : 0 ≤ a * b := by simpa only [mul_zero] using mul_le_mul_of_nonneg_left hb ha; sorry",
  "name": "Left.mul_nonneg",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_zero] using mul_le_mul_of_nonneg_left hb ha",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [PosMulMono α]  (ha : 0 ≤ a)  (hb : 0 ≤ b) : 0 ≤ a * b",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [PosMulMono α]  (ha : 0 ≤ a)  (hb : 0 ≤ b)"},
 {"type": "a * b ≤ 0",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [PosMulMono α]  (ha : 0 ≤ a)  (hb : b ≤ 0) : a * b ≤ 0 := by simpa only [mul_zero] using mul_le_mul_of_nonneg_left hb ha; sorry",
  "name": "mul_nonpos_of_nonneg_of_nonpos",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_zero] using mul_le_mul_of_nonneg_left hb ha",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [PosMulMono α]  (ha : 0 ≤ a)  (hb : b ≤ 0) : a * b ≤ 0",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [PosMulMono α]  (ha : 0 ≤ a)  (hb : b ≤ 0)"},
 {"type": "0 ≤ a * b",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [MulPosMono α]  (ha : 0 ≤ a)  (hb : 0 ≤ b) : 0 ≤ a * b := by simpa only [zero_mul] using mul_le_mul_of_nonneg_right ha hb; sorry",
  "name": "Right.mul_nonneg",
  "kind": "theorem",
  "first-tactic":
  "simpa only [zero_mul] using mul_le_mul_of_nonneg_right ha hb",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [MulPosMono α]  (ha : 0 ≤ a)  (hb : 0 ≤ b) : 0 ≤ a * b",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [MulPosMono α]  (ha : 0 ≤ a)  (hb : 0 ≤ b)"},
 {"type": "a * b ≤ 0",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [MulPosMono α]  (ha : a ≤ 0)  (hb : 0 ≤ b) : a * b ≤ 0 := by simpa only [zero_mul] using mul_le_mul_of_nonneg_right ha hb; sorry",
  "name": "mul_nonpos_of_nonpos_of_nonneg",
  "kind": "theorem",
  "first-tactic":
  "simpa only [zero_mul] using mul_le_mul_of_nonneg_right ha hb",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [MulPosMono α]  (ha : a ≤ 0)  (hb : 0 ≤ b) : a * b ≤ 0",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [Preorder α] [MulPosMono α]  (ha : a ≤ 0)  (hb : 0 ≤ b)"},
 {"type": "a * c = b * d ↔ a = b ∧ c = d",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [PartialOrder α] [PosMulStrictMono α]  [MulPosStrictMono α]  [PosMulMonoRev α]      [MulPosMonoRev α]  (hac : a ≤ b)  (hbd : c ≤ d)  (a0 : 0 < a)  (d0 : 0 < d) : a * c = b * d ↔ a = b ∧ c = d := by refine' ⟨fun h => _, fun h => congr_arg₂ (· * ·) h.1 h.2⟩; sorry",
  "name": "mul_eq_mul_iff_eq_and_eq_of_pos",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, fun h => congr_arg₂ (· * ·) h.1 h.2⟩",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [PartialOrder α] [PosMulStrictMono α]  [MulPosStrictMono α]  [PosMulMonoRev α]      [MulPosMonoRev α]  (hac : a ≤ b)  (hbd : c ≤ d)  (a0 : 0 < a)  (d0 : 0 < d) : a * c = b * d ↔ a = b ∧ c = d",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [PartialOrder α] [PosMulStrictMono α]  [MulPosStrictMono α]  [PosMulMonoRev α]      [MulPosMonoRev α]  (hac : a ≤ b)  (hbd : c ≤ d)  (a0 : 0 < a)  (d0 : 0 < d)"},
 {"type": "a * c = b * d ↔ a = b ∧ c = d",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [PartialOrder α] [PosMulStrictMono α]  [MulPosStrictMono α]  [PosMulMonoRev α]      [MulPosMonoRev α]  (hac : a ≤ b)  (hbd : c ≤ d)  (b0 : 0 < b)  (c0 : 0 < c) : a * c = b * d ↔ a = b ∧ c = d := by refine' ⟨fun h => _, fun h => congr_arg₂ (· * ·) h.1 h.2⟩; sorry",
  "name": "mul_eq_mul_iff_eq_and_eq_of_pos'",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, fun h => congr_arg₂ (· * ·) h.1 h.2⟩",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [PartialOrder α] [PosMulStrictMono α]  [MulPosStrictMono α]  [PosMulMonoRev α]      [MulPosMonoRev α]  (hac : a ≤ b)  (hbd : c ≤ d)  (b0 : 0 < b)  (c0 : 0 < c) : a * c = b * d ↔ a = b ∧ c = d",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [PartialOrder α] [PosMulStrictMono α]  [MulPosStrictMono α]  [PosMulMonoRev α]      [MulPosMonoRev α]  (hac : a ≤ b)  (hbd : c ≤ d)  (b0 : 0 < b)  (c0 : 0 < c)"},
 {"type": "0 < a ∧ 0 < b ∨ a < 0 ∧ b < 0",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [LinearOrder α] [PosMulMono α]  [MulPosMono α]  (hab : 0 < a * b) : 0 < a ∧ 0 < b ∨ a < 0 ∧ b < 0 := by rcases lt_trichotomy a 0 with (ha | rfl | ha); sorry",
  "name": "pos_and_pos_or_neg_and_neg_of_mul_pos",
  "kind": "theorem",
  "first-tactic": "rcases lt_trichotomy a 0 with (ha | rfl | ha)",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [LinearOrder α] [PosMulMono α]  [MulPosMono α]  (hab : 0 < a * b) : 0 < a ∧ 0 < b ∨ a < 0 ∧ b < 0",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass α]  [LinearOrder α] [PosMulMono α]  [MulPosMono α]  (hab : 0 < a * b)"},
 {"type": "a * b ≤ b",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [MulPosMono α]  (hb : 0 ≤ b)  (h : a ≤ 1) : a * b ≤ b := by simpa only [one_mul] using mul_le_mul_of_nonneg_right h hb; sorry",
  "name": "mul_le_of_le_one_left",
  "kind": "theorem",
  "first-tactic": "simpa only [one_mul] using mul_le_mul_of_nonneg_right h hb",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [MulPosMono α]  (hb : 0 ≤ b)  (h : a ≤ 1) : a * b ≤ b",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [MulPosMono α]  (hb : 0 ≤ b)  (h : a ≤ 1)"},
 {"type": "b ≤ a * b",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [MulPosMono α]  (hb : 0 ≤ b)  (h : 1 ≤ a) : b ≤ a * b := by simpa only [one_mul] using mul_le_mul_of_nonneg_right h hb; sorry",
  "name": "le_mul_of_one_le_left",
  "kind": "theorem",
  "first-tactic": "simpa only [one_mul] using mul_le_mul_of_nonneg_right h hb",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [MulPosMono α]  (hb : 0 ≤ b)  (h : 1 ≤ a) : b ≤ a * b",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [MulPosMono α]  (hb : 0 ≤ b)  (h : 1 ≤ a)"},
 {"type": "a * b ≤ a",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [PosMulMono α]  (ha : 0 ≤ a)  (h : b ≤ 1) : a * b ≤ a := by simpa only [mul_one] using mul_le_mul_of_nonneg_left h ha; sorry",
  "name": "mul_le_of_le_one_right",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_one] using mul_le_mul_of_nonneg_left h ha",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [PosMulMono α]  (ha : 0 ≤ a)  (h : b ≤ 1) : a * b ≤ a",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [PosMulMono α]  (ha : 0 ≤ a)  (h : b ≤ 1)"},
 {"type": "a ≤ a * b",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [PosMulMono α]  (ha : 0 ≤ a)  (h : 1 ≤ b) : a ≤ a * b := by simpa only [mul_one] using mul_le_mul_of_nonneg_left h ha; sorry",
  "name": "le_mul_of_one_le_right",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_one] using mul_le_mul_of_nonneg_left h ha",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [PosMulMono α]  (ha : 0 ≤ a)  (h : 1 ≤ b) : a ≤ a * b",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [PosMulMono α]  (ha : 0 ≤ a)  (h : 1 ≤ b)"},
 {"type": "a * b < b",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [MulPosStrictMono α]  (hb : 0 < b)  (h : a < 1) : a * b < b := by simpa only [one_mul] using mul_lt_mul_of_pos_right h hb; sorry",
  "name": "mul_lt_of_lt_one_left",
  "kind": "theorem",
  "first-tactic": "simpa only [one_mul] using mul_lt_mul_of_pos_right h hb",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [MulPosStrictMono α]  (hb : 0 < b)  (h : a < 1) : a * b < b",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [MulPosStrictMono α]  (hb : 0 < b)  (h : a < 1)"},
 {"type": "b < a * b",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [MulPosStrictMono α]  (hb : 0 < b)  (h : 1 < a) : b < a * b := by simpa only [one_mul] using mul_lt_mul_of_pos_right h hb; sorry",
  "name": "lt_mul_of_one_lt_left",
  "kind": "theorem",
  "first-tactic": "simpa only [one_mul] using mul_lt_mul_of_pos_right h hb",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [MulPosStrictMono α]  (hb : 0 < b)  (h : 1 < a) : b < a * b",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [MulPosStrictMono α]  (hb : 0 < b)  (h : 1 < a)"},
 {"type": "a * b < a",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [PosMulStrictMono α]  (ha : 0 < a)  (h : b < 1) : a * b < a := by simpa only [mul_one] using mul_lt_mul_of_pos_left h ha; sorry",
  "name": "mul_lt_of_lt_one_right",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_one] using mul_lt_mul_of_pos_left h ha",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [PosMulStrictMono α]  (ha : 0 < a)  (h : b < 1) : a * b < a",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [PosMulStrictMono α]  (ha : 0 < a)  (h : b < 1)"},
 {"type": "a < a * b",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [PosMulStrictMono α]  (ha : 0 < a)  (h : 1 < b) : a < a * b := by simpa only [mul_one] using mul_lt_mul_of_pos_left h ha; sorry",
  "name": "lt_mul_of_one_lt_right",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_one] using mul_lt_mul_of_pos_left h ha",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [PosMulStrictMono α]  (ha : 0 < a)  (h : 1 < b) : a < a * b",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [Preorder α] [PosMulStrictMono α]  (ha : 0 < a)  (h : 1 < b)"},
 {"type": "∃ b : α, b * b ≤ a",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [LinearOrder α]  -- Yaël: What's the point of this lemma? If we have `0 * 0 = 0`, then we can just take `b = 0`. -- proven with `a0 : 0 ≤ a` as `exists_square_le` [PosMulStrictMono α]  (a0 : 0 < a) : ∃ b : α, b * b ≤ a := by obtain ha | ha := lt_or_le a 1; sorry",
  "name": "exists_square_le'",
  "kind": "theorem",
  "first-tactic": "obtain ha | ha := lt_or_le a 1",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [LinearOrder α]  -- Yaël: What's the point of this lemma? If we have `0 * 0 = 0`, then we can just take `b = 0`. -- proven with `a0 : 0 ≤ a` as `exists_square_le` [PosMulStrictMono α]  (a0 : 0 < a) : ∃ b : α, b * b ≤ a",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass α]  [Zero α]  [LinearOrder α]  -- Yaël: What's the point of this lemma? If we have `0 * 0 = 0`, then we can just take `b = 0`. -- proven with `a0 : 0 ≤ a` as `exists_square_le` [PosMulStrictMono α]  (a0 : 0 < a)"},
 {"type": "PosMulStrictMono α ↔ MulPosStrictMono α",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup α]  [Zero α]  [Preorder α] : PosMulStrictMono α ↔ MulPosStrictMono α := by simp only [PosMulStrictMono]; sorry",
  "name": "posMulStrictMono_iff_mulPosStrictMono",
  "kind": "theorem",
  "first-tactic": "simp only [PosMulStrictMono]",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup α]  [Zero α]  [Preorder α] : PosMulStrictMono α ↔ MulPosStrictMono α",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup α]  [Zero α]  [Preorder α]"},
 {"type": "PosMulReflectLT α ↔ MulPosReflectLT α",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup α]  [Zero α]  [Preorder α] : PosMulReflectLT α ↔ MulPosReflectLT α := by simp only [PosMulReflectLT]; sorry",
  "name": "posMulReflectLT_iff_mulPosReflectLT",
  "kind": "theorem",
  "first-tactic": "simp only [PosMulReflectLT]",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup α]  [Zero α]  [Preorder α] : PosMulReflectLT α ↔ MulPosReflectLT α",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup α]  [Zero α]  [Preorder α]"},
 {"type": "PosMulMono α ↔ MulPosMono α",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup α]  [Zero α]  [Preorder α] : PosMulMono α ↔ MulPosMono α := by simp only [PosMulMono]; sorry",
  "name": "posMulMono_iff_mulPosMono",
  "kind": "theorem",
  "first-tactic": "simp only [PosMulMono]",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup α]  [Zero α]  [Preorder α] : PosMulMono α ↔ MulPosMono α",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup α]  [Zero α]  [Preorder α]"},
 {"type": "PosMulMonoRev α ↔ MulPosMonoRev α",
  "tactic-prompt":
  "theorem (α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup α]  [Zero α]  [Preorder α] : PosMulMonoRev α ↔ MulPosMonoRev α := by simp only [PosMulMonoRev]; sorry",
  "name": "posMulMonoRev_iff_mulPosMonoRev",
  "kind": "theorem",
  "first-tactic": "simp only [PosMulMonoRev]",
  "core-prompt":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup α]  [Zero α]  [Preorder α] : PosMulMonoRev α ↔ MulPosMonoRev α",
  "args":
  "(α : Type _)  -- mathport name: «exprα≥0» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup α]  [Zero α]  [Preorder α]"},
 {"type": "0 ≤ a⁻¹ ↔ 0 ≤ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} : 0 ≤ a⁻¹ ↔ 0 ≤ a := by simp only [le_iff_eq_or_lt]; sorry",
  "name": "inv_nonneg",
  "kind": "theorem",
  "first-tactic": "simp only [le_iff_eq_or_lt]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} : 0 ≤ a⁻¹ ↔ 0 ≤ a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ}"},
 {"type": "a⁻¹ < 0 ↔ a < 0",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} : a⁻¹ < 0 ↔ a < 0 := by simp only [← not_le]; sorry",
  "name": "inv_lt_zero",
  "kind": "theorem",
  "first-tactic": "simp only [← not_le]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} : a⁻¹ < 0 ↔ a < 0",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ}"},
 {"type": "a⁻¹ ≤ 0 ↔ a ≤ 0",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} : a⁻¹ ≤ 0 ↔ a ≤ 0 := by simp only [← not_lt]; sorry",
  "name": "inv_nonpos",
  "kind": "theorem",
  "first-tactic": "simp only [← not_lt]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} : a⁻¹ ≤ 0 ↔ a ≤ 0",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ}"},
 {"type": "0 < a / b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b) : 0 < a / b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_pos",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b) : 0 < a / b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "0 ≤ a / b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 ≤ a)  (hb : 0 ≤ b) : 0 ≤ a / b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_nonneg",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 ≤ a)  (hb : 0 ≤ b) : 0 ≤ a / b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 ≤ a)  (hb : 0 ≤ b)"},
 {"type": "a / b ≤ 0",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : a ≤ 0)  (hb : 0 ≤ b) : a / b ≤ 0 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_nonpos_of_nonpos_of_nonneg",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : a ≤ 0)  (hb : 0 ≤ b) : a / b ≤ 0",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : a ≤ 0)  (hb : 0 ≤ b)"},
 {"type": "a / b ≤ 0",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 ≤ a)  (hb : b ≤ 0) : a / b ≤ 0 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_nonpos_of_nonneg_of_nonpos",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 ≤ a)  (hb : b ≤ 0) : a / b ≤ 0",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 ≤ a)  (hb : b ≤ 0)"},
 {"type": "a ≤ b / c ↔ c * a ≤ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 < c) : a ≤ b / c ↔ c * a ≤ b := by rw [mul_comm]; sorry",
  "name": "le_div_iff'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 < c) : a ≤ b / c ↔ c * a ≤ b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 < c)"},
 {"type": "a / b ≤ c ↔ a ≤ b * c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 < b) : a / b ≤ c ↔ a ≤ b * c := by rw [mul_comm]; sorry",
  "name": "div_le_iff'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 < b) : a / b ≤ c ↔ a ≤ b * c",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 < b)"},
 {"type": "a < b / c ↔ c * a < b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 < c) : a < b / c ↔ c * a < b := by rw [mul_comm]; sorry",
  "name": "lt_div_iff'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 < c) : a < b / c ↔ c * a < b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 < c)"},
 {"type": "b / c < a ↔ b < c * a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 < c) : b / c < a ↔ b < c * a := by rw [mul_comm]; sorry",
  "name": "div_lt_iff'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 < c) : b / c < a ↔ b < c * a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 < c)"},
 {"type": "b⁻¹ * a ≤ c ↔ a ≤ b * c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b) : b⁻¹ * a ≤ c ↔ a ≤ b * c := by rw [inv_eq_one_div]; sorry",
  "name": "inv_mul_le_iff",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b) : b⁻¹ * a ≤ c ↔ a ≤ b * c",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b)"},
 {"type": "b⁻¹ * a ≤ c ↔ a ≤ c * b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b) : b⁻¹ * a ≤ c ↔ a ≤ c * b := by rw [inv_mul_le_iff h]; sorry",
  "name": "inv_mul_le_iff'",
  "kind": "theorem",
  "first-tactic": "rw [inv_mul_le_iff h]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b) : b⁻¹ * a ≤ c ↔ a ≤ c * b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b)"},
 {"type": "a * b⁻¹ ≤ c ↔ a ≤ b * c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b) : a * b⁻¹ ≤ c ↔ a ≤ b * c := by rw [mul_comm]; sorry",
  "name": "mul_inv_le_iff",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b) : a * b⁻¹ ≤ c ↔ a ≤ b * c",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b)"},
 {"type": "a * b⁻¹ ≤ c ↔ a ≤ c * b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b) : a * b⁻¹ ≤ c ↔ a ≤ c * b := by rw [mul_comm]; sorry",
  "name": "mul_inv_le_iff'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b) : a * b⁻¹ ≤ c ↔ a ≤ c * b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b)"},
 {"type": "b⁻¹ * a < c ↔ a < b * c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b) : b⁻¹ * a < c ↔ a < b * c := by rw [inv_eq_one_div]; sorry",
  "name": "inv_mul_lt_iff",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b) : b⁻¹ * a < c ↔ a < b * c",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b)"},
 {"type": "b⁻¹ * a < c ↔ a < c * b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b) : b⁻¹ * a < c ↔ a < c * b := by rw [inv_mul_lt_iff h]; sorry",
  "name": "inv_mul_lt_iff'",
  "kind": "theorem",
  "first-tactic": "rw [inv_mul_lt_iff h]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b) : b⁻¹ * a < c ↔ a < c * b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b)"},
 {"type": "a * b⁻¹ < c ↔ a < b * c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b) : a * b⁻¹ < c ↔ a < b * c := by rw [mul_comm]; sorry",
  "name": "mul_inv_lt_iff",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b) : a * b⁻¹ < c ↔ a < b * c",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b)"},
 {"type": "a * b⁻¹ < c ↔ a < c * b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b) : a * b⁻¹ < c ↔ a < c * b := by rw [mul_comm]; sorry",
  "name": "mul_inv_lt_iff'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b) : a * b⁻¹ < c ↔ a < c * b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < b)"},
 {"type": "a⁻¹ ≤ b ↔ 1 ≤ b * a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a) : a⁻¹ ≤ b ↔ 1 ≤ b * a := by rw [inv_eq_one_div]; sorry",
  "name": "inv_pos_le_iff_one_le_mul",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a) : a⁻¹ ≤ b ↔ 1 ≤ b * a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)"},
 {"type": "a⁻¹ ≤ b ↔ 1 ≤ a * b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a) : a⁻¹ ≤ b ↔ 1 ≤ a * b := by rw [inv_eq_one_div]; sorry",
  "name": "inv_pos_le_iff_one_le_mul'",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a) : a⁻¹ ≤ b ↔ 1 ≤ a * b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)"},
 {"type": "a⁻¹ < b ↔ 1 < b * a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a) : a⁻¹ < b ↔ 1 < b * a := by rw [inv_eq_one_div]; sorry",
  "name": "inv_pos_lt_iff_one_lt_mul",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a) : a⁻¹ < b ↔ 1 < b * a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)"},
 {"type": "a⁻¹ < b ↔ 1 < a * b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a) : a⁻¹ < b ↔ 1 < a * b := by rw [inv_eq_one_div]; sorry",
  "name": "inv_pos_lt_iff_one_lt_mul'",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a) : a⁻¹ < b ↔ 1 < a * b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)"},
 {"type": "a / b ≤ c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 ≤ b)  (hc : 0 ≤ c)  (h : a ≤ c * b) : a / b ≤ c := by rcases eq_or_lt_of_le hb with (rfl | hb'); sorry",
  "name": "div_le_of_nonneg_of_le_mul",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_lt_of_le hb with (rfl | hb')",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 ≤ b)  (hc : 0 ≤ c)  (h : a ≤ c * b) : a / b ≤ c",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 ≤ b)  (hc : 0 ≤ c)  (h : a ≤ c * b)"},
 {"type": "b⁻¹ ≤ a⁻¹",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (h : a ≤ b) : b⁻¹ ≤ a⁻¹ := by rwa [← one_div a]; sorry",
  "name": "inv_le_inv_of_le",
  "kind": "theorem",
  "first-tactic": "rwa [← one_div a]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (h : a ≤ b) : b⁻¹ ≤ a⁻¹",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (h : a ≤ b)"},
 {"type": "a⁻¹ ≤ b⁻¹ ↔ b ≤ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a := by rw [← one_div]; sorry",
  "name": "inv_le_inv",
  "kind": "theorem",
  "first-tactic": "rw [← one_div]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a⁻¹ ≤ b ↔ b⁻¹ ≤ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b) : a⁻¹ ≤ b ↔ b⁻¹ ≤ a := by rw [← inv_le_inv hb (inv_pos.2 ha)]; sorry",
  "name": "inv_le",
  "kind": "theorem",
  "first-tactic": "rw [← inv_le_inv hb (inv_pos.2 ha)]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b) : a⁻¹ ≤ b ↔ b⁻¹ ≤ a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a ≤ b⁻¹ ↔ b ≤ a⁻¹",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b) : a ≤ b⁻¹ ↔ b ≤ a⁻¹ := by rw [← inv_le_inv (inv_pos.2 hb) ha]; sorry",
  "name": "le_inv",
  "kind": "theorem",
  "first-tactic": "rw [← inv_le_inv (inv_pos.2 hb) ha]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b) : a ≤ b⁻¹ ↔ b ≤ a⁻¹",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a⁻¹ < 1",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 1 < a) : a⁻¹ < 1 := by rwa [inv_lt (zero_lt_one.trans ha) zero_lt_one]; sorry",
  "name": "inv_lt_one",
  "kind": "theorem",
  "first-tactic": "rwa [inv_lt (zero_lt_one.trans ha) zero_lt_one]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 1 < a) : a⁻¹ < 1",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 1 < a)"},
 {"type": "1 < a⁻¹",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h₁ : 0 < a)  (h₂ : a < 1) : 1 < a⁻¹ := by rwa [lt_inv (@zero_lt_one α _ _ _ _ _) h₁]; sorry",
  "name": "one_lt_inv",
  "kind": "theorem",
  "first-tactic": "rwa [lt_inv (@zero_lt_one α _ _ _ _ _) h₁]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h₁ : 0 < a)  (h₂ : a < 1) : 1 < a⁻¹",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h₁ : 0 < a)  (h₂ : a < 1)"},
 {"type": "a⁻¹ ≤ 1",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 1 ≤ a) : a⁻¹ ≤ 1 := by rwa [inv_le (zero_lt_one.trans_le ha) zero_lt_one]; sorry",
  "name": "inv_le_one",
  "kind": "theorem",
  "first-tactic": "rwa [inv_le (zero_lt_one.trans_le ha) zero_lt_one]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 1 ≤ a) : a⁻¹ ≤ 1",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 1 ≤ a)"},
 {"type": "1 ≤ a⁻¹",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h₁ : 0 < a)  (h₂ : a ≤ 1) : 1 ≤ a⁻¹ := by rwa [le_inv (@zero_lt_one α _ _ _ _ _) h₁]; sorry",
  "name": "one_le_inv",
  "kind": "theorem",
  "first-tactic": "rwa [le_inv (@zero_lt_one α _ _ _ _ _) h₁]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h₁ : 0 < a)  (h₂ : a ≤ 1) : 1 ≤ a⁻¹",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h₁ : 0 < a)  (h₂ : a ≤ 1)"},
 {"type": "a⁻¹ < 1 ↔ a ≤ 0 ∨ 1 < a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} : a⁻¹ < 1 ↔ a ≤ 0 ∨ 1 < a := by cases' le_or_lt a 0 with ha ha; sorry",
  "name": "inv_lt_one_iff",
  "kind": "theorem",
  "first-tactic": "cases' le_or_lt a 0 with ha ha",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} : a⁻¹ < 1 ↔ a ≤ 0 ∨ 1 < a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ}"},
 {"type": "a⁻¹ ≤ 1 ↔ a ≤ 0 ∨ 1 ≤ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} : a⁻¹ ≤ 1 ↔ a ≤ 0 ∨ 1 ≤ a := by rcases em (a = 1) with (rfl | ha); sorry",
  "name": "inv_le_one_iff",
  "kind": "theorem",
  "first-tactic": "rcases em (a = 1) with (rfl | ha)",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} : a⁻¹ ≤ 1 ↔ a ≤ 0 ∨ 1 ≤ a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ}"},
 {"type": "a / c ≤ b / c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 ≤ c)  (h : a ≤ b) : a / c ≤ b / c := by rw [div_eq_mul_one_div a c]; sorry",
  "name": "div_le_div_of_le",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_one_div a c]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 ≤ c)  (h : a ≤ b) : a / c ≤ b / c",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 ≤ c)  (h : a ≤ b)"},
 {"type": "a / b ≤ a / c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 ≤ a)  (hc : 0 < c)  (h : c ≤ b) : a / b ≤ a / c := by rw [div_eq_mul_inv]; sorry",
  "name": "div_le_div_of_le_left",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 ≤ a)  (hc : 0 < c)  (h : c ≤ b) : a / b ≤ a / c",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 ≤ a)  (hc : 0 < c)  (h : c ≤ b)"},
 {"type": "a / c < b / c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 < c)  (h : a < b) : a / c < b / c := by rw [div_eq_mul_one_div a c]; sorry",
  "name": "div_lt_div_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_one_div a c]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 < c)  (h : a < b) : a / c < b / c",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 < c)  (h : a < b)"},
 {"type": "a / b < a / c ↔ c < b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b)  (hc : 0 < c) : a / b < a / c ↔ c < b := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_lt_div_left",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b)  (hc : 0 < c) : a / b < a / c ↔ c < b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b)  (hc : 0 < c)"},
 {"type": "a / b < c / d ↔ a * d < c * b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (b0 : 0 < b)  (d0 : 0 < d) : a / b < c / d ↔ a * d < c * b := by rw [lt_div_iff d0]; sorry",
  "name": "div_lt_div_iff",
  "kind": "theorem",
  "first-tactic": "rw [lt_div_iff d0]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (b0 : 0 < b)  (d0 : 0 < d) : a / b < c / d ↔ a * d < c * b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (b0 : 0 < b)  (d0 : 0 < d)"},
 {"type": "a / b ≤ c / d ↔ a * d ≤ c * b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (b0 : 0 < b)  (d0 : 0 < d) : a / b ≤ c / d ↔ a * d ≤ c * b := by rw [le_div_iff d0]; sorry",
  "name": "div_le_div_iff",
  "kind": "theorem",
  "first-tactic": "rw [le_div_iff d0]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (b0 : 0 < b)  (d0 : 0 < d) : a / b ≤ c / d ↔ a * d ≤ c * b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (b0 : 0 < b)  (d0 : 0 < d)"},
 {"type": "a / b ≤ c / d",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 ≤ c)  (hac : a ≤ c)  (hd : 0 < d)  (hbd : d ≤ b) : a / b ≤ c / d := by rw [div_le_div_iff (hd.trans_le hbd) hd]; sorry",
  "name": "div_le_div",
  "kind": "theorem",
  "first-tactic": "rw [div_le_div_iff (hd.trans_le hbd) hd]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 ≤ c)  (hac : a ≤ c)  (hd : 0 < d)  (hbd : d ≤ b) : a / b ≤ c / d",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hc : 0 ≤ c)  (hac : a ≤ c)  (hd : 0 < d)  (hbd : d ≤ b)"},
 {"type": "a / b ≤ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 ≤ a)  (hb : 1 ≤ b) : a / b ≤ a := by simpa only [div_one] using div_le_div_of_le_left ha zero_lt_one hb; sorry",
  "name": "div_le_self",
  "kind": "theorem",
  "first-tactic":
  "simpa only [div_one] using div_le_div_of_le_left ha zero_lt_one hb",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 ≤ a)  (hb : 1 ≤ b) : a / b ≤ a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 ≤ a)  (hb : 1 ≤ b)"},
 {"type": "a / b < a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 1 < b) : a / b < a := by simpa only [div_one] using div_lt_div_of_lt_left ha zero_lt_one hb; sorry",
  "name": "div_lt_self",
  "kind": "theorem",
  "first-tactic":
  "simpa only [div_one] using div_lt_div_of_lt_left ha zero_lt_one hb",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 1 < b) : a / b < a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 1 < b)"},
 {"type": "a ≤ a / b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 ≤ a)  (hb₀ : 0 < b)  (hb₁ : b ≤ 1) : a ≤ a / b := by simpa only [div_one] using div_le_div_of_le_left ha hb₀ hb₁; sorry",
  "name": "le_div_self",
  "kind": "theorem",
  "first-tactic": "simpa only [div_one] using div_le_div_of_le_left ha hb₀ hb₁",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 ≤ a)  (hb₀ : 0 < b)  (hb₁ : b ≤ 1) : a ≤ a / b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 ≤ a)  (hb₀ : 0 < b)  (hb₁ : b ≤ 1)"},
 {"type": "1 ≤ a / b ↔ b ≤ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 < b) : 1 ≤ a / b ↔ b ≤ a := by rw [le_div_iff hb]; sorry",
  "name": "one_le_div",
  "kind": "theorem",
  "first-tactic": "rw [le_div_iff hb]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 < b) : 1 ≤ a / b ↔ b ≤ a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 < b)"},
 {"type": "a / b ≤ 1 ↔ a ≤ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 < b) : a / b ≤ 1 ↔ a ≤ b := by rw [div_le_iff hb]; sorry",
  "name": "div_le_one",
  "kind": "theorem",
  "first-tactic": "rw [div_le_iff hb]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 < b) : a / b ≤ 1 ↔ a ≤ b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 < b)"},
 {"type": "1 < a / b ↔ b < a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 < b) : 1 < a / b ↔ b < a := by rw [lt_div_iff hb]; sorry",
  "name": "one_lt_div",
  "kind": "theorem",
  "first-tactic": "rw [lt_div_iff hb]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 < b) : 1 < a / b ↔ b < a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 < b)"},
 {"type": "a / b < 1 ↔ a < b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 < b) : a / b < 1 ↔ a < b := by rw [div_lt_iff hb]; sorry",
  "name": "div_lt_one",
  "kind": "theorem",
  "first-tactic": "rw [div_lt_iff hb]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 < b) : a / b < 1 ↔ a < b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (hb : 0 < b)"},
 {"type": "1 / a ≤ b ↔ 1 / b ≤ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b) : 1 / a ≤ b ↔ 1 / b ≤ a := by simpa using inv_le ha hb; sorry",
  "name": "one_div_le",
  "kind": "theorem",
  "first-tactic": "simpa using inv_le ha hb",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b) : 1 / a ≤ b ↔ 1 / b ≤ a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "1 / a < b ↔ 1 / b < a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b) : 1 / a < b ↔ 1 / b < a := by simpa using inv_lt ha hb; sorry",
  "name": "one_div_lt",
  "kind": "theorem",
  "first-tactic": "simpa using inv_lt ha hb",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b) : 1 / a < b ↔ 1 / b < a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a ≤ 1 / b ↔ b ≤ 1 / a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b) : a ≤ 1 / b ↔ b ≤ 1 / a := by simpa using le_inv ha hb; sorry",
  "name": "le_one_div",
  "kind": "theorem",
  "first-tactic": "simpa using le_inv ha hb",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b) : a ≤ 1 / b ↔ b ≤ 1 / a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a < 1 / b ↔ b < 1 / a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b) : a < 1 / b ↔ b < 1 / a := by simpa using lt_inv ha hb; sorry",
  "name": "lt_one_div",
  "kind": "theorem",
  "first-tactic": "simpa using lt_inv ha hb",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b) : a < 1 / b ↔ b < 1 / a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "1 / b ≤ 1 / a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (h : a ≤ b) : 1 / b ≤ 1 / a := by simpa using inv_le_inv_of_le ha h; sorry",
  "name": "one_div_le_one_div_of_le",
  "kind": "theorem",
  "first-tactic": "simpa using inv_le_inv_of_le ha h",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (h : a ≤ b) : 1 / b ≤ 1 / a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (h : a ≤ b)"},
 {"type": "1 / b < 1 / a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (h : a < b) : 1 / b < 1 / a := by rwa [lt_div_iff' ha]; sorry",
  "name": "one_div_lt_one_div_of_lt",
  "kind": "theorem",
  "first-tactic": "rwa [lt_div_iff' ha]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (h : a < b) : 1 / b < 1 / a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha : 0 < a)  (h : a < b)"},
 {"type": "1 < 1 / a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h1 : 0 < a)  (h2 : a < 1) : 1 < 1 / a := by rwa [lt_one_div (@zero_lt_one α _ _ _ _ _) h1]; sorry",
  "name": "one_lt_one_div",
  "kind": "theorem",
  "first-tactic": "rwa [lt_one_div (@zero_lt_one α _ _ _ _ _) h1]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h1 : 0 < a)  (h2 : a < 1) : 1 < 1 / a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h1 : 0 < a)  (h2 : a < 1)"},
 {"type": "1 ≤ 1 / a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h1 : 0 < a)  (h2 : a ≤ 1) : 1 ≤ 1 / a := by rwa [le_one_div (@zero_lt_one α _ _ _ _ _) h1]; sorry",
  "name": "one_le_one_div",
  "kind": "theorem",
  "first-tactic": "rwa [le_one_div (@zero_lt_one α _ _ _ _ _) h1]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h1 : 0 < a)  (h2 : a ≤ 1) : 1 ≤ 1 / a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h1 : 0 < a)  (h2 : a ≤ 1)"},
 {"type": "a / 2 + a / 2 = a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a : α) : a / 2 + a / 2 = a := by rw [div_add_div_same]; sorry",
  "name": "add_halves",
  "kind": "theorem",
  "first-tactic": "rw [div_add_div_same]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a : α) : a / 2 + a / 2 = a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a : α)"},
 {"type": "(a + a) / 2 = a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a : α) : (a + a) / 2 = a := by rw [← mul_two]; sorry",
  "name": "add_self_div_two",
  "kind": "theorem",
  "first-tactic": "rw [← mul_two]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a : α) : (a + a) / 2 = a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a : α)"},
 {"type": "a / 2 < a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < a) : a / 2 < a := by rw [div_lt_iff (zero_lt_two' α)]; sorry",
  "name": "div_two_lt_of_pos",
  "kind": "theorem",
  "first-tactic": "rw [div_lt_iff (zero_lt_two' α)]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < a) : a / 2 < a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : 0 < a)"},
 {"type": "a / 2 ≤ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha_nonneg : 0 ≤ a) : a / 2 ≤ a := by by_cases h0 : a = 0; sorry",
  "name": "half_le_self",
  "kind": "theorem",
  "first-tactic": "by_cases h0 : a = 0",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha_nonneg : 0 ≤ a) : a / 2 ≤ a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (ha_nonneg : 0 ≤ a)"},
 {"type": "a < (a + b) / 2 ↔ a < b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} : a < (a + b) / 2 ↔ a < b := by simp [lt_div_iff]; sorry",
  "name": "left_lt_add_div_two",
  "kind": "theorem",
  "first-tactic": "simp [lt_div_iff]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} : a < (a + b) / 2 ↔ a < b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ}"},
 {"type": "(a + b) / 2 < b ↔ a < b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} : (a + b) / 2 < b ↔ a < b := by simp [div_lt_iff]; sorry",
  "name": "add_div_two_lt_right",
  "kind": "theorem",
  "first-tactic": "simp [div_lt_iff]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} : (a + b) / 2 < b ↔ a < b",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ}"},
 {"type": "b * a ≤ d * c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : a * (b / c) ≤ d)  (hc : 0 < c) : b * a ≤ d * c := by rw [← mul_div_assoc] at h; sorry",
  "name": "mul_le_mul_of_mul_div_le",
  "kind": "theorem",
  "first-tactic": "rw [← mul_div_assoc] at h",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : a * (b / c) ≤ d)  (hc : 0 < c) : b * a ≤ d * c",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : a * (b / c) ≤ d)  (hc : 0 < c)"},
 {"type": "a / (b * e) ≤ c / (d * e)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : a / b ≤ c / d)  (he : 0 ≤ e) : a / (b * e) ≤ c / (d * e) := by rw [div_mul_eq_div_mul_one_div]; sorry",
  "name": "div_mul_le_div_mul_of_div_le_div",
  "kind": "theorem",
  "first-tactic": "rw [div_mul_eq_div_mul_one_div]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : a / b ≤ c / d)  (he : 0 ≤ e) : a / (b * e) ≤ c / (d * e)",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (h : a / b ≤ c / d)  (he : 0 ≤ e)"},
 {"type": "∃ c : α, 0 < c ∧ b * c < a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} {a : α}  (h : 0 < a)  (b : α) : ∃ c : α, 0 < c ∧ b * c < a := by have : 0 < a / max (b + 1) 1 := div_pos h (lt_max_iff.2 (Or.inr zero_lt_one)); sorry",
  "name": "exists_pos_mul_lt",
  "kind": "theorem",
  "first-tactic":
  "have : 0 < a / max (b + 1) 1 := div_pos h (lt_max_iff.2 (Or.inr zero_lt_one))",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} {a : α}  (h : 0 < a)  (b : α) : ∃ c : α, 0 < c ∧ b * c < a",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} {a : α}  (h : 0 < a)  (b : α)"},
 {"type": "Monotone fun x => f x / c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} {β : Type _}  [Preorder β]  {f : β → α}  (hf : Monotone f)  {c : α}      (hc : 0 ≤ c) : Monotone fun x => f x / c := by haveI := @LinearOrder.decidable_le α _; sorry",
  "name": "Monotone.div_const",
  "kind": "theorem",
  "first-tactic": "haveI := @LinearOrder.decidable_le α _",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} {β : Type _}  [Preorder β]  {f : β → α}  (hf : Monotone f)  {c : α}      (hc : 0 ≤ c) : Monotone fun x => f x / c",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} {β : Type _}  [Preorder β]  {f : β → α}  (hf : Monotone f)  {c : α}      (hc : 0 ≤ c)"},
 {"type": "StrictMono fun x => f x / c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} {β : Type _}  [Preorder β]  {f : β → α}  (hf : StrictMono f)  {c : α}      (hc : 0 < c) : StrictMono fun x => f x / c := by simpa only [div_eq_mul_inv] using hf.mul_const (inv_pos.2 hc); sorry",
  "name": "StrictMono.div_const",
  "kind": "theorem",
  "first-tactic":
  "simpa only [div_eq_mul_inv] using hf.mul_const (inv_pos.2 hc)",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} {β : Type _}  [Preorder β]  {f : β → α}  (hf : StrictMono f)  {c : α}      (hc : 0 < c) : StrictMono fun x => f x / c",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} {β : Type _}  [Preorder β]  {f : β → α}  (hf : StrictMono f)  {c : α}      (hc : 0 < c)"},
 {"type": "1 / a ^ n ≤ 1 / a ^ m",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a1 : 1 ≤ a)  {m n : ℕ}  (mn : m ≤ n) : 1 / a ^ n ≤ 1 / a ^ m := by refine' (one_div_le_one_div _ _).mpr (pow_le_pow a1 mn); sorry",
  "name": "one_div_pow_le_one_div_pow_of_le",
  "kind": "theorem",
  "first-tactic": "refine' (one_div_le_one_div _ _).mpr (pow_le_pow a1 mn)",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a1 : 1 ≤ a)  {m n : ℕ}  (mn : m ≤ n) : 1 / a ^ n ≤ 1 / a ^ m",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a1 : 1 ≤ a)  {m n : ℕ}  (mn : m ≤ n)"},
 {"type": "1 / a ^ n < 1 / a ^ m",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a1 : 1 < a)  {m n : ℕ}  (mn : m < n) : 1 / a ^ n < 1 / a ^ m := by refine' (one_div_lt_one_div _ _).mpr (pow_lt_pow a1 mn); sorry",
  "name": "one_div_pow_lt_one_div_pow_of_lt",
  "kind": "theorem",
  "first-tactic": "refine' (one_div_lt_one_div _ _).mpr (pow_lt_pow a1 mn)",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a1 : 1 < a)  {m n : ℕ}  (mn : m < n) : 1 / a ^ n < 1 / a ^ m",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a1 : 1 < a)  {m n : ℕ}  (mn : m < n)"},
 {"type": "(a ^ n)⁻¹ ≤ (a ^ m)⁻¹",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a1 : 1 ≤ a)  {m n : ℕ}  (mn : m ≤ n) : (a ^ n)⁻¹ ≤ (a ^ m)⁻¹ := by convert one_div_pow_le_one_div_pow_of_le a1 mn; sorry",
  "name": "inv_pow_le_inv_pow_of_le",
  "kind": "theorem",
  "first-tactic": "convert one_div_pow_le_one_div_pow_of_le a1 mn",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a1 : 1 ≤ a)  {m n : ℕ}  (mn : m ≤ n) : (a ^ n)⁻¹ ≤ (a ^ m)⁻¹",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a1 : 1 ≤ a)  {m n : ℕ}  (mn : m ≤ n)"},
 {"type": "(a ^ n)⁻¹ < (a ^ m)⁻¹",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a1 : 1 < a)  {m n : ℕ}  (mn : m < n) : (a ^ n)⁻¹ < (a ^ m)⁻¹ := by convert one_div_pow_lt_one_div_pow_of_lt a1 mn; sorry",
  "name": "inv_pow_lt_inv_pow_of_lt",
  "kind": "theorem",
  "first-tactic": "convert one_div_pow_lt_one_div_pow_of_lt a1 mn",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a1 : 1 < a)  {m n : ℕ}  (mn : m < n) : (a ^ n)⁻¹ < (a ^ m)⁻¹",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} (a1 : 1 < a)  {m n : ℕ}  (mn : m < n)"},
 {"type": "IsGLB ((fun b => a * b) '' s) (a * b)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} {s : Set α}  (ha : 0 ≤ a)  (hs : IsGLB s b) : IsGLB ((fun b => a * b) '' s) (a * b) := by rcases lt_or_eq_of_le ha with (ha | rfl); sorry",
  "name": "IsGLB.mul_left",
  "kind": "theorem",
  "first-tactic": "rcases lt_or_eq_of_le ha with (ha | rfl)",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} {s : Set α}  (ha : 0 ≤ a)  (hs : IsGLB s b) : IsGLB ((fun b => a * b) '' s) (a * b)",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} {s : Set α}  (ha : 0 ≤ a)  (hs : IsGLB s b)"},
 {"type": "IsGLB ((fun b => b * a) '' s) (b * a)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} {s : Set α}  (ha : 0 ≤ a)  (hs : IsGLB s b) : IsGLB ((fun b => b * a) '' s) (b * a) := by simpa [mul_comm] using hs.mul_left ha; sorry",
  "name": "IsGLB.mul_right",
  "kind": "theorem",
  "first-tactic": "simpa [mul_comm] using hs.mul_left ha",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} {s : Set α}  (ha : 0 ≤ a)  (hs : IsGLB s b) : IsGLB ((fun b => b * a) '' s) (b * a)",
  "args":
  "{ι α β : Type _}  [LinearOrderedSemifield α]  {a b c d e : α}  {m n : ℤ} {s : Set α}  (ha : 0 ≤ a)  (hs : IsGLB s b)"},
 {"type": "0 < a / b ↔ 0 < a ∧ 0 < b ∨ a < 0 ∧ b < 0",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : 0 < a / b ↔ 0 < a ∧ 0 < b ∨ a < 0 ∧ b < 0 := by simp only [division_def]; sorry",
  "name": "div_pos_iff",
  "kind": "theorem",
  "first-tactic": "simp only [division_def]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : 0 < a / b ↔ 0 < a ∧ 0 < b ∨ a < 0 ∧ b < 0",
  "args": "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ}"},
 {"type": "a / b < 0 ↔ 0 < a ∧ b < 0 ∨ a < 0 ∧ 0 < b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : a / b < 0 ↔ 0 < a ∧ b < 0 ∨ a < 0 ∧ 0 < b := by simp [division_def]; sorry",
  "name": "div_neg_iff",
  "kind": "theorem",
  "first-tactic": "simp [division_def]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : a / b < 0 ↔ 0 < a ∧ b < 0 ∨ a < 0 ∧ 0 < b",
  "args": "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ}"},
 {"type": "0 ≤ a / b ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : 0 ≤ a / b ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0 := by simp [division_def]; sorry",
  "name": "div_nonneg_iff",
  "kind": "theorem",
  "first-tactic": "simp [division_def]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : 0 ≤ a / b ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0",
  "args": "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ}"},
 {"type": "a / b ≤ 0 ↔ 0 ≤ a ∧ b ≤ 0 ∨ a ≤ 0 ∧ 0 ≤ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : a / b ≤ 0 ↔ 0 ≤ a ∧ b ≤ 0 ∨ a ≤ 0 ∧ 0 ≤ b := by simp [division_def]; sorry",
  "name": "div_nonpos_iff",
  "kind": "theorem",
  "first-tactic": "simp [division_def]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : a / b ≤ 0 ↔ 0 ≤ a ∧ b ≤ 0 ∨ a ≤ 0 ∧ 0 ≤ b",
  "args": "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ}"},
 {"type": "b / c ≤ a ↔ c * a ≤ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0) : b / c ≤ a ↔ c * a ≤ b := by rw [mul_comm]; sorry",
  "name": "div_le_iff_of_neg'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0) : b / c ≤ a ↔ c * a ≤ b",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0)"},
 {"type": "a ≤ b / c ↔ b ≤ a * c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0) : a ≤ b / c ↔ b ≤ a * c := by rw [← neg_neg c]; sorry",
  "name": "le_div_iff_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [← neg_neg c]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0) : a ≤ b / c ↔ b ≤ a * c",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0)"},
 {"type": "a ≤ b / c ↔ b ≤ c * a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0) : a ≤ b / c ↔ b ≤ c * a := by rw [mul_comm]; sorry",
  "name": "le_div_iff_of_neg'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0) : a ≤ b / c ↔ b ≤ c * a",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0)"},
 {"type": "b / c < a ↔ c * a < b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0) : b / c < a ↔ c * a < b := by rw [mul_comm]; sorry",
  "name": "div_lt_iff_of_neg'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0) : b / c < a ↔ c * a < b",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0)"},
 {"type": "a < b / c ↔ b < c * a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0) : a < b / c ↔ b < c * a := by rw [mul_comm]; sorry",
  "name": "lt_div_iff_of_neg'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0) : a < b / c ↔ b < c * a",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0)"},
 {"type": "a⁻¹ ≤ b⁻¹ ↔ b ≤ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a := by rw [← one_div]; sorry",
  "name": "inv_le_inv_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [← one_div]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0)"},
 {"type": "a⁻¹ ≤ b ↔ b⁻¹ ≤ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0) : a⁻¹ ≤ b ↔ b⁻¹ ≤ a := by rw [← inv_le_inv_of_neg hb (inv_lt_zero.2 ha)]; sorry",
  "name": "inv_le_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [← inv_le_inv_of_neg hb (inv_lt_zero.2 ha)]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0) : a⁻¹ ≤ b ↔ b⁻¹ ≤ a",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0)"},
 {"type": "a ≤ b⁻¹ ↔ b ≤ a⁻¹",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0) : a ≤ b⁻¹ ↔ b ≤ a⁻¹ := by rw [← inv_le_inv_of_neg (inv_lt_zero.2 hb) ha]; sorry",
  "name": "le_inv_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [← inv_le_inv_of_neg (inv_lt_zero.2 hb) ha]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0) : a ≤ b⁻¹ ↔ b ≤ a⁻¹",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0)"},
 {"type": "a / c ≤ b / c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c ≤ 0)  (h : b ≤ a) : a / c ≤ b / c := by rw [div_eq_mul_one_div a c]; sorry",
  "name": "div_le_div_of_nonpos_of_le",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_one_div a c]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c ≤ 0)  (h : b ≤ a) : a / c ≤ b / c",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c ≤ 0)  (h : b ≤ a)"},
 {"type": "a / c < b / c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0)  (h : b < a) : a / c < b / c := by rw [div_eq_mul_one_div a c]; sorry",
  "name": "div_lt_div_of_neg_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_one_div a c]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0)  (h : b < a) : a / c < b / c",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c < 0)  (h : b < a)"},
 {"type": "1 ≤ a / b ↔ a ≤ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0) : 1 ≤ a / b ↔ a ≤ b := by rw [le_div_iff_of_neg hb]; sorry",
  "name": "one_le_div_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [le_div_iff_of_neg hb]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0) : 1 ≤ a / b ↔ a ≤ b",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0)"},
 {"type": "a / b ≤ 1 ↔ b ≤ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0) : a / b ≤ 1 ↔ b ≤ a := by rw [div_le_iff_of_neg hb]; sorry",
  "name": "div_le_one_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [div_le_iff_of_neg hb]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0) : a / b ≤ 1 ↔ b ≤ a",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0)"},
 {"type": "1 < a / b ↔ a < b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0) : 1 < a / b ↔ a < b := by rw [lt_div_iff_of_neg hb]; sorry",
  "name": "one_lt_div_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [lt_div_iff_of_neg hb]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0) : 1 < a / b ↔ a < b",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0)"},
 {"type": "a / b < 1 ↔ b < a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0) : a / b < 1 ↔ b < a := by rw [div_lt_iff_of_neg hb]; sorry",
  "name": "div_lt_one_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [div_lt_iff_of_neg hb]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0) : a / b < 1 ↔ b < a",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0)"},
 {"type": "1 / a ≤ b ↔ 1 / b ≤ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0) : 1 / a ≤ b ↔ 1 / b ≤ a := by simpa using inv_le_of_neg ha hb; sorry",
  "name": "one_div_le_of_neg",
  "kind": "theorem",
  "first-tactic": "simpa using inv_le_of_neg ha hb",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0) : 1 / a ≤ b ↔ 1 / b ≤ a",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0)"},
 {"type": "1 / a < b ↔ 1 / b < a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0) : 1 / a < b ↔ 1 / b < a := by simpa using inv_lt_of_neg ha hb; sorry",
  "name": "one_div_lt_of_neg",
  "kind": "theorem",
  "first-tactic": "simpa using inv_lt_of_neg ha hb",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0) : 1 / a < b ↔ 1 / b < a",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0)"},
 {"type": "a ≤ 1 / b ↔ b ≤ 1 / a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0) : a ≤ 1 / b ↔ b ≤ 1 / a := by simpa using le_inv_of_neg ha hb; sorry",
  "name": "le_one_div_of_neg",
  "kind": "theorem",
  "first-tactic": "simpa using le_inv_of_neg ha hb",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0) : a ≤ 1 / b ↔ b ≤ 1 / a",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0)"},
 {"type": "a < 1 / b ↔ b < 1 / a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0) : a < 1 / b ↔ b < 1 / a := by simpa using lt_inv_of_neg ha hb; sorry",
  "name": "lt_one_div_of_neg",
  "kind": "theorem",
  "first-tactic": "simpa using lt_inv_of_neg ha hb",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0) : a < 1 / b ↔ b < 1 / a",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0)"},
 {"type": "1 < a / b ↔ 0 < b ∧ b < a ∨ b < 0 ∧ a < b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : 1 < a / b ↔ 0 < b ∧ b < a ∨ b < 0 ∧ a < b := by rcases lt_trichotomy b 0 with (hb | rfl | hb); sorry",
  "name": "one_lt_div_iff",
  "kind": "theorem",
  "first-tactic": "rcases lt_trichotomy b 0 with (hb | rfl | hb)",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : 1 < a / b ↔ 0 < b ∧ b < a ∨ b < 0 ∧ a < b",
  "args": "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ}"},
 {"type": "1 ≤ a / b ↔ 0 < b ∧ b ≤ a ∨ b < 0 ∧ a ≤ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : 1 ≤ a / b ↔ 0 < b ∧ b ≤ a ∨ b < 0 ∧ a ≤ b := by rcases lt_trichotomy b 0 with (hb | rfl | hb); sorry",
  "name": "one_le_div_iff",
  "kind": "theorem",
  "first-tactic": "rcases lt_trichotomy b 0 with (hb | rfl | hb)",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : 1 ≤ a / b ↔ 0 < b ∧ b ≤ a ∨ b < 0 ∧ a ≤ b",
  "args": "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ}"},
 {"type": "a / b < 1 ↔ 0 < b ∧ a < b ∨ b = 0 ∨ b < 0 ∧ b < a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : a / b < 1 ↔ 0 < b ∧ a < b ∨ b = 0 ∨ b < 0 ∧ b < a := by rcases lt_trichotomy b 0 with (hb | rfl | hb); sorry",
  "name": "div_lt_one_iff",
  "kind": "theorem",
  "first-tactic": "rcases lt_trichotomy b 0 with (hb | rfl | hb)",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : a / b < 1 ↔ 0 < b ∧ a < b ∨ b = 0 ∨ b < 0 ∧ b < a",
  "args": "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ}"},
 {"type": "a / b ≤ 1 ↔ 0 < b ∧ a ≤ b ∨ b = 0 ∨ b < 0 ∧ b ≤ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : a / b ≤ 1 ↔ 0 < b ∧ a ≤ b ∨ b = 0 ∨ b < 0 ∧ b ≤ a := by rcases lt_trichotomy b 0 with (hb | rfl | hb); sorry",
  "name": "div_le_one_iff",
  "kind": "theorem",
  "first-tactic": "rcases lt_trichotomy b 0 with (hb | rfl | hb)",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : a / b ≤ 1 ↔ 0 < b ∧ a ≤ b ∨ b = 0 ∨ b < 0 ∧ b ≤ a",
  "args": "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ}"},
 {"type": "1 / b ≤ 1 / a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0)  (h : a ≤ b) : 1 / b ≤ 1 / a := by rwa [div_le_iff_of_neg' hb]; sorry",
  "name": "one_div_le_one_div_of_neg_of_le",
  "kind": "theorem",
  "first-tactic": "rwa [div_le_iff_of_neg' hb]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0)  (h : a ≤ b) : 1 / b ≤ 1 / a",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0)  (h : a ≤ b)"},
 {"type": "1 / b < 1 / a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0)  (h : a < b) : 1 / b < 1 / a := by rwa [div_lt_iff_of_neg' hb]; sorry",
  "name": "one_div_lt_one_div_of_neg_of_lt",
  "kind": "theorem",
  "first-tactic": "rwa [div_lt_iff_of_neg' hb]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0)  (h : a < b) : 1 / b < 1 / a",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hb : b < 0)  (h : a < b)"},
 {"type": "1 / a ≤ 1 / b ↔ b ≤ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0) : 1 / a ≤ 1 / b ↔ b ≤ a := by simpa [one_div] using inv_le_inv_of_neg ha hb; sorry",
  "name": "one_div_le_one_div_of_neg",
  "kind": "theorem",
  "first-tactic": "simpa [one_div] using inv_le_inv_of_neg ha hb",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0) : 1 / a ≤ 1 / b ↔ b ≤ a",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (ha : a < 0)  (hb : b < 0)"},
 {"type": "a - a / 2 = a / 2",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (a : α) : a - a / 2 = a / 2 := by suffices a / 2 + a / 2 - a / 2 = a / 2 by rwa [add_halves] at this; sorry",
  "name": "sub_self_div_two",
  "kind": "theorem",
  "first-tactic":
  "suffices a / 2 + a / 2 - a / 2 = a / 2 by rwa [add_halves] at this",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (a : α) : a - a / 2 = a / 2",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (a : α)"},
 {"type": "a / 2 - a = -(a / 2)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (a : α) : a / 2 - a = -(a / 2) := by suffices a / 2 - (a / 2 + a / 2) = -(a / 2) by rwa [add_halves] at this; sorry",
  "name": "div_two_sub_self",
  "kind": "theorem",
  "first-tactic":
  "suffices a / 2 - (a / 2 + a / 2) = -(a / 2) by rwa [add_halves] at this",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (a : α) : a / 2 - a = -(a / 2)",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (a : α)"},
 {"type": "a + (b - a) / 2 < b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (h : a < b) : a + (b - a) / 2 < b := by rwa [← div_sub_div_same]; sorry",
  "name": "add_sub_div_two_lt",
  "kind": "theorem",
  "first-tactic": "rwa [← div_sub_div_same]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (h : a < b) : a + (b - a) / 2 < b",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (h : a < b)"},
 {"type": "(1 - 1 / a)⁻¹ ≤ 2",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (a2 : 2 ≤ a) : (1 - 1 / a)⁻¹ ≤ 2 := by refine' (inv_le_inv_of_le (inv_pos.2 <| zero_lt_two' α) _).trans_eq (inv_inv (2 : α)); sorry",
  "name": "sub_one_div_inv_le_two",
  "kind": "theorem",
  "first-tactic":
  "refine' (inv_le_inv_of_le (inv_pos.2 <| zero_lt_two' α) _).trans_eq (inv_inv (2 : α))",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (a2 : 2 ≤ a) : (1 - 1 / a)⁻¹ ≤ 2",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (a2 : 2 ≤ a)"},
 {"type": "IsLUB ((fun b => a * b) '' s) (a * b)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} {s : Set α}  (ha : 0 ≤ a)  (hs : IsLUB s b) : IsLUB ((fun b => a * b) '' s) (a * b) := by rcases lt_or_eq_of_le ha with (ha | rfl); sorry",
  "name": "IsLUB.mul_left",
  "kind": "theorem",
  "first-tactic": "rcases lt_or_eq_of_le ha with (ha | rfl)",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} {s : Set α}  (ha : 0 ≤ a)  (hs : IsLUB s b) : IsLUB ((fun b => a * b) '' s) (a * b)",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} {s : Set α}  (ha : 0 ≤ a)  (hs : IsLUB s b)"},
 {"type": "IsLUB ((fun b => b * a) '' s) (b * a)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} {s : Set α}  (ha : 0 ≤ a)  (hs : IsLUB s b) : IsLUB ((fun b => b * a) '' s) (b * a) := by simpa [mul_comm] using hs.mul_left ha; sorry",
  "name": "IsLUB.mul_right",
  "kind": "theorem",
  "first-tactic": "simpa [mul_comm] using hs.mul_left ha",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} {s : Set α}  (ha : 0 ≤ a)  (hs : IsLUB s b) : IsLUB ((fun b => b * a) '' s) (b * a)",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} {s : Set α}  (ha : 0 ≤ a)  (hs : IsLUB s b)"},
 {"type": "(a * d - b * c) / (c * d) < 0 ↔ a / c < b / d",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c ≠ 0)  (hd : d ≠ 0) : (a * d - b * c) / (c * d) < 0 ↔ a / c < b / d := by rw [mul_comm b c]; sorry",
  "name": "mul_sub_mul_div_mul_neg_iff",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm b c]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c ≠ 0)  (hd : d ≠ 0) : (a * d - b * c) / (c * d) < 0 ↔ a / c < b / d",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c ≠ 0)  (hd : d ≠ 0)"},
 {"type": "(a * d - b * c) / (c * d) ≤ 0 ↔ a / c ≤ b / d",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c ≠ 0)  (hd : d ≠ 0) : (a * d - b * c) / (c * d) ≤ 0 ↔ a / c ≤ b / d := by rw [mul_comm b c]; sorry",
  "name": "mul_sub_mul_div_mul_nonpos_iff",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm b c]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c ≠ 0)  (hd : d ≠ 0) : (a * d - b * c) / (c * d) ≤ 0 ↔ a / c ≤ b / d",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (hc : c ≠ 0)  (hd : d ≠ 0)"},
 {"type": "b ≤ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (h : ∀ ε > 0, b - ε ≤ a) : b ≤ a := by contrapose! h; sorry",
  "name": "le_of_forall_sub_le",
  "kind": "theorem",
  "first-tactic": "contrapose! h",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (h : ∀ ε > 0, b - ε ≤ a) : b ≤ a",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (h : ∀ ε > 0, b - ε ≤ a)"},
 {"type": "|1 / a| = 1 / |a|",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (a : α) : |1 / a| = 1 / |a| := by rw [abs_div]; sorry",
  "name": "abs_one_div",
  "kind": "theorem",
  "first-tactic": "rw [abs_div]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (a : α) : |1 / a| = 1 / |a|",
  "args":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} (a : α)"},
 {"type": "0 ≤ a ^ (-2 : ℤ)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : 0 ≤ a ^ (-2 : ℤ) := by simp only [inv_nonneg]; sorry",
  "name": "pow_minus_two_nonneg",
  "kind": "theorem",
  "first-tactic": "simp only [inv_nonneg]",
  "core-prompt":
  "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ} : 0 ≤ a ^ (-2 : ℤ)",
  "args": "{ι α β : Type _}  [LinearOrderedField α]  {a b c d : α}  {n : ℤ}"},
 {"type": "(a - b) / c = a / c - b / c",
  "tactic-prompt":
  "theorem {α : Type _}  [CanonicallyLinearOrderedSemifield α]  [Sub α]  [OrderedSub α] (a b c : α) : (a - b) / c = a / c - b / c := by simp_rw [div_eq_mul_inv]; sorry",
  "name": "tsub_div",
  "kind": "theorem",
  "first-tactic": "simp_rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _}  [CanonicallyLinearOrderedSemifield α]  [Sub α]  [OrderedSub α] (a b c : α) : (a - b) / c = a / c - b / c",
  "args":
  "{α : Type _}  [CanonicallyLinearOrderedSemifield α]  [Sub α]  [OrderedSub α] (a b c : α)"},
 {"type": "a⁻¹ ≤ 1 ↔ 1 ≤ a",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a := by rw [← mul_le_mul_iff_left a]; sorry",
  "name": "Left.inv_le_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [← mul_le_mul_iff_left a]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α}"},
 {"type": "1 ≤ a⁻¹ ↔ a ≤ 1",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : 1 ≤ a⁻¹ ↔ a ≤ 1 := by rw [← mul_le_mul_iff_left a]; sorry",
  "name": "Left.one_le_inv_iff",
  "kind": "theorem",
  "first-tactic": "rw [← mul_le_mul_iff_left a]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : 1 ≤ a⁻¹ ↔ a ≤ 1",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α}"},
 {"type": "b ≤ a⁻¹ * c ↔ a * b ≤ c",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : b ≤ a⁻¹ * c ↔ a * b ≤ c := by rw [← mul_le_mul_iff_left a]; sorry",
  "name": "le_inv_mul_iff_mul_le",
  "kind": "theorem",
  "first-tactic": "rw [← mul_le_mul_iff_left a]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : b ≤ a⁻¹ * c ↔ a * b ≤ c",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α}"},
 {"type": "b⁻¹ * a ≤ c ↔ a ≤ b * c",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : b⁻¹ * a ≤ c ↔ a ≤ b * c := by rw [← mul_le_mul_iff_left b]; sorry",
  "name": "inv_mul_le_iff_le_mul",
  "kind": "theorem",
  "first-tactic": "rw [← mul_le_mul_iff_left b]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : b⁻¹ * a ≤ c ↔ a ≤ b * c",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α}"},
 {"type": "1 ≤ b⁻¹ * a ↔ b ≤ a",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : 1 ≤ b⁻¹ * a ↔ b ≤ a := by rw [← mul_le_mul_iff_left b]; sorry",
  "name": "le_inv_mul_iff_le",
  "kind": "theorem",
  "first-tactic": "rw [← mul_le_mul_iff_left b]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : 1 ≤ b⁻¹ * a ↔ b ≤ a",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α}"},
 {"type": "1 < a⁻¹ ↔ a < 1",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α} : 1 < a⁻¹ ↔ a < 1 := by rw [← mul_lt_mul_iff_left a]; sorry",
  "name": "Left.one_lt_inv_iff",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_left a]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α} : 1 < a⁻¹ ↔ a < 1",
  "args":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α}"},
 {"type": "a⁻¹ < 1 ↔ 1 < a",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α} : a⁻¹ < 1 ↔ 1 < a := by rw [← mul_lt_mul_iff_left a]; sorry",
  "name": "Left.inv_lt_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_left a]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α} : a⁻¹ < 1 ↔ 1 < a",
  "args":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α}"},
 {"type": "b < a⁻¹ * c ↔ a * b < c",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α} : b < a⁻¹ * c ↔ a * b < c := by rw [← mul_lt_mul_iff_left a]; sorry",
  "name": "lt_inv_mul_iff_mul_lt",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_left a]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α} : b < a⁻¹ * c ↔ a * b < c",
  "args":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α}"},
 {"type": "b⁻¹ * a < c ↔ a < b * c",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α} : b⁻¹ * a < c ↔ a < b * c := by rw [← mul_lt_mul_iff_left b]; sorry",
  "name": "inv_mul_lt_iff_lt_mul",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_left b]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α} : b⁻¹ * a < c ↔ a < b * c",
  "args":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α}"},
 {"type": "1 < b⁻¹ * a ↔ b < a",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α} : 1 < b⁻¹ * a ↔ b < a := by rw [← mul_lt_mul_iff_left b]; sorry",
  "name": "lt_inv_mul_iff_lt",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_left b]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α} : 1 < b⁻¹ * a ↔ b < a",
  "args":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α}"},
 {"type": "a⁻¹ ≤ 1 ↔ 1 ≤ a",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a := by rw [← mul_le_mul_iff_right a]; sorry",
  "name": "Right.inv_le_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [← mul_le_mul_iff_right a]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c : α}"},
 {"type": "1 ≤ a⁻¹ ↔ a ≤ 1",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c : α} : 1 ≤ a⁻¹ ↔ a ≤ 1 := by rw [← mul_le_mul_iff_right a]; sorry",
  "name": "Right.one_le_inv_iff",
  "kind": "theorem",
  "first-tactic": "rw [← mul_le_mul_iff_right a]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c : α} : 1 ≤ a⁻¹ ↔ a ≤ 1",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c : α}"},
 {"type": "1 ≤ a * b⁻¹ ↔ b ≤ a",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c : α} : 1 ≤ a * b⁻¹ ↔ b ≤ a := by rw [← mul_le_mul_iff_right b]; sorry",
  "name": "le_mul_inv_iff_le",
  "kind": "theorem",
  "first-tactic": "rw [← mul_le_mul_iff_right b]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c : α} : 1 ≤ a * b⁻¹ ↔ b ≤ a",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c : α}"},
 {"type": "a⁻¹ < 1 ↔ 1 < a",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c : α} : a⁻¹ < 1 ↔ 1 < a := by rw [← mul_lt_mul_iff_right a]; sorry",
  "name": "Right.inv_lt_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_right a]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c : α} : a⁻¹ < 1 ↔ 1 < a",
  "args":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c : α}"},
 {"type": "1 < a⁻¹ ↔ a < 1",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c : α} : 1 < a⁻¹ ↔ a < 1 := by rw [← mul_lt_mul_iff_right a]; sorry",
  "name": "Right.one_lt_inv_iff",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_right a]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c : α} : 1 < a⁻¹ ↔ a < 1",
  "args":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c : α}"},
 {"type": "a * b⁻¹ < c ↔ a < c * b",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c : α} : a * b⁻¹ < c ↔ a < c * b := by rw [← mul_lt_mul_iff_right b]; sorry",
  "name": "mul_inv_lt_iff_lt_mul",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_right b]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c : α} : a * b⁻¹ < c ↔ a < c * b",
  "args":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c : α}"},
 {"type": "a * b⁻¹ < 1 ↔ a < b",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c : α} : a * b⁻¹ < 1 ↔ a < b := by rw [← mul_lt_mul_iff_right b]; sorry",
  "name": "inv_mul_lt_one_iff_lt",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_right b]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c : α} : a * b⁻¹ < 1 ↔ a < b",
  "args":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c : α}"},
 {"type": "1 < a * b⁻¹ ↔ b < a",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c : α} : 1 < a * b⁻¹ ↔ b < a := by rw [← mul_lt_mul_iff_right b]; sorry",
  "name": "lt_mul_inv_iff_lt",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_right b]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c : α} : 1 < a * b⁻¹ ↔ b < a",
  "args":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c : α}"},
 {"type": "a⁻¹ ≤ b⁻¹ ↔ b ≤ a",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α} : a⁻¹ ≤ b⁻¹ ↔ b ≤ a := by rw [← mul_le_mul_iff_left a]; sorry",
  "name": "inv_le_inv_iff",
  "kind": "theorem",
  "first-tactic": "rw [← mul_le_mul_iff_left a]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α} : a⁻¹ ≤ b⁻¹ ↔ b ≤ a",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α}"},
 {"type": "a * b⁻¹ ≤ d⁻¹ * c ↔ d * a ≤ c * b",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α} : a * b⁻¹ ≤ d⁻¹ * c ↔ d * a ≤ c * b := by rw [← mul_le_mul_iff_left d]; sorry",
  "name": "mul_inv_le_inv_mul_iff",
  "kind": "theorem",
  "first-tactic": "rw [← mul_le_mul_iff_left d]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α} : a * b⁻¹ ≤ d⁻¹ * c ↔ d * a ≤ c * b",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α}"},
 {"type": "a / b ≤ a ↔ 1 ≤ b",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α} (a : α)  {b : α} : a / b ≤ a ↔ 1 ≤ b := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_le_self_iff",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α} (a : α)  {b : α} : a / b ≤ a ↔ 1 ≤ b",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α} (a : α)  {b : α}"},
 {"type": "a ≤ a / b ↔ b ≤ 1",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α} (a : α)  {b : α} : a ≤ a / b ↔ b ≤ 1 := by simp only [div_eq_mul_inv]; sorry",
  "name": "le_div_self_iff",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α} (a : α)  {b : α} : a ≤ a / b ↔ b ≤ 1",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α} (a : α)  {b : α}"},
 {"type": "a⁻¹ < b⁻¹ ↔ b < a",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c d : α} : a⁻¹ < b⁻¹ ↔ b < a := by rw [← mul_lt_mul_iff_left a]; sorry",
  "name": "inv_lt_inv_iff",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_left a]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c d : α} : a⁻¹ < b⁻¹ ↔ b < a",
  "args":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c d : α}"},
 {"type": "a⁻¹ < b ↔ b⁻¹ < a",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c d : α} : a⁻¹ < b ↔ b⁻¹ < a := by rw [← inv_lt_inv_iff]; sorry",
  "name": "inv_lt'",
  "kind": "theorem",
  "first-tactic": "rw [← inv_lt_inv_iff]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c d : α} : a⁻¹ < b ↔ b⁻¹ < a",
  "args":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c d : α}"},
 {"type": "a < b⁻¹ ↔ b < a⁻¹",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c d : α} : a < b⁻¹ ↔ b < a⁻¹ := by rw [← inv_lt_inv_iff]; sorry",
  "name": "lt_inv'",
  "kind": "theorem",
  "first-tactic": "rw [← inv_lt_inv_iff]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c d : α} : a < b⁻¹ ↔ b < a⁻¹",
  "args":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c d : α}"},
 {"type": "a * b⁻¹ < d⁻¹ * c ↔ d * a < c * b",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c d : α} : a * b⁻¹ < d⁻¹ * c ↔ d * a < c * b := by rw [← mul_lt_mul_iff_left d]; sorry",
  "name": "mul_inv_lt_inv_mul_iff",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_left d]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c d : α} : a * b⁻¹ < d⁻¹ * c ↔ d * a < c * b",
  "args":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c d : α}"},
 {"type": "a / b < a ↔ 1 < b",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c d : α} (a : α)  {b : α} : a / b < a ↔ 1 < b := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_lt_self_iff",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c d : α} (a : α)  {b : α} : a / b < a ↔ 1 < b",
  "args":
  "{α : Type u}  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c d : α} (a : α)  {b : α}"},
 {"type": "c⁻¹ * a ≤ b ↔ a ≤ b * c",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : c⁻¹ * a ≤ b ↔ a ≤ b * c := by rw [inv_mul_le_iff_le_mul]; sorry",
  "name": "inv_mul_le_iff_le_mul'",
  "kind": "theorem",
  "first-tactic": "rw [inv_mul_le_iff_le_mul]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : c⁻¹ * a ≤ b ↔ a ≤ b * c",
  "args":
  "{α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α}"},
 {"type": "a * b⁻¹ ≤ c ↔ a ≤ b * c",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : a * b⁻¹ ≤ c ↔ a ≤ b * c := by rw [← inv_mul_le_iff_le_mul]; sorry",
  "name": "mul_inv_le_iff_le_mul'",
  "kind": "theorem",
  "first-tactic": "rw [← inv_mul_le_iff_le_mul]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : a * b⁻¹ ≤ c ↔ a ≤ b * c",
  "args":
  "{α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α}"},
 {"type": "a * b⁻¹ ≤ c * d⁻¹ ↔ a * d ≤ c * b",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : a * b⁻¹ ≤ c * d⁻¹ ↔ a * d ≤ c * b := by rw [mul_comm c]; sorry",
  "name": "mul_inv_le_mul_inv_iff'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm c]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : a * b⁻¹ ≤ c * d⁻¹ ↔ a * d ≤ c * b",
  "args":
  "{α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α}"},
 {"type": "c⁻¹ * a < b ↔ a < b * c",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α} : c⁻¹ * a < b ↔ a < b * c := by rw [inv_mul_lt_iff_lt_mul]; sorry",
  "name": "inv_mul_lt_iff_lt_mul'",
  "kind": "theorem",
  "first-tactic": "rw [inv_mul_lt_iff_lt_mul]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α} : c⁻¹ * a < b ↔ a < b * c",
  "args":
  "{α : Type u}  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α}"},
 {"type": "a * b⁻¹ < c ↔ a < b * c",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α} : a * b⁻¹ < c ↔ a < b * c := by rw [← inv_mul_lt_iff_lt_mul]; sorry",
  "name": "mul_inv_lt_iff_le_mul'",
  "kind": "theorem",
  "first-tactic": "rw [← inv_mul_lt_iff_lt_mul]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α} : a * b⁻¹ < c ↔ a < b * c",
  "args":
  "{α : Type u}  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α}"},
 {"type": "a * b⁻¹ < c * d⁻¹ ↔ a * d < c * b",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α} : a * b⁻¹ < c * d⁻¹ ↔ a * d < c * b := by rw [mul_comm c]; sorry",
  "name": "mul_inv_lt_mul_inv_iff'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm c]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α} : a * b⁻¹ < c * d⁻¹ ↔ a * d < c * b",
  "args":
  "{α : Type u}  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α}"},
 {"type": "a / c ≤ b / c ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α} (c : α) : a / c ≤ b / c ↔ a ≤ b := by simpa only [div_eq_mul_inv] using mul_le_mul_iff_right _; sorry",
  "name": "div_le_div_iff_right",
  "kind": "theorem",
  "first-tactic": "simpa only [div_eq_mul_inv] using mul_le_mul_iff_right _",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α} (c : α) : a / c ≤ b / c ↔ a ≤ b",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α} (c : α)"},
 {"type": "1 ≤ a / b ↔ b ≤ a",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α} : 1 ≤ a / b ↔ b ≤ a := by rw [← mul_le_mul_iff_right b]; sorry",
  "name": "one_le_div'",
  "kind": "theorem",
  "first-tactic": "rw [← mul_le_mul_iff_right b]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α} : 1 ≤ a / b ↔ b ≤ a",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α}"},
 {"type": "a / b ≤ 1 ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α} : a / b ≤ 1 ↔ a ≤ b := by rw [← mul_le_mul_iff_right b]; sorry",
  "name": "div_le_one'",
  "kind": "theorem",
  "first-tactic": "rw [← mul_le_mul_iff_right b]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α} : a / b ≤ 1 ↔ a ≤ b",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α}"},
 {"type": "a ≤ c / b ↔ a * b ≤ c",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α} : a ≤ c / b ↔ a * b ≤ c := by rw [← mul_le_mul_iff_right b]; sorry",
  "name": "le_div_iff_mul_le",
  "kind": "theorem",
  "first-tactic": "rw [← mul_le_mul_iff_right b]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α} : a ≤ c / b ↔ a * b ≤ c",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α}"},
 {"type": "a / c ≤ b ↔ a ≤ b * c",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α} : a / c ≤ b ↔ a ≤ b * c := by rw [← mul_le_mul_iff_right c]; sorry",
  "name": "div_le_iff_le_mul",
  "kind": "theorem",
  "first-tactic": "rw [← mul_le_mul_iff_right c]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α} : a / c ≤ b ↔ a ≤ b * c",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α}"},
 {"type": "a / b ≤ a / c ↔ c ≤ b",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)] [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c : α} (a : α) : a / b ≤ a / c ↔ c ≤ b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_le_div_iff_left",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)] [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c : α} (a : α) : a / b ≤ a / c ↔ c ≤ b",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)] [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c : α} (a : α)"},
 {"type": "a / b ≤ c / d ↔ a * d ≤ c * b",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : a / b ≤ c / d ↔ a * d ≤ c * b := by simpa only [div_eq_mul_inv] using mul_inv_le_mul_inv_iff'; sorry",
  "name": "div_le_div_iff'",
  "kind": "theorem",
  "first-tactic": "simpa only [div_eq_mul_inv] using mul_inv_le_mul_inv_iff'",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : a / b ≤ c / d ↔ a * d ≤ c * b",
  "args":
  "{α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α}"},
 {"type": "b ≤ c / a ↔ a * b ≤ c",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : b ≤ c / a ↔ a * b ≤ c := by rw [le_div_iff_mul_le]; sorry",
  "name": "le_div_iff_mul_le'",
  "kind": "theorem",
  "first-tactic": "rw [le_div_iff_mul_le]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : b ≤ c / a ↔ a * b ≤ c",
  "args":
  "{α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α}"},
 {"type": "a / b ≤ c ↔ a ≤ b * c",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : a / b ≤ c ↔ a ≤ b * c := by rw [div_le_iff_le_mul]; sorry",
  "name": "div_le_iff_le_mul'",
  "kind": "theorem",
  "first-tactic": "rw [div_le_iff_le_mul]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : a / b ≤ c ↔ a ≤ b * c",
  "args":
  "{α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α}"},
 {"type": "a⁻¹ ≤ b / c ↔ c ≤ a * b",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : a⁻¹ ≤ b / c ↔ c ≤ a * b := by rw [inv_le_div_iff_le_mul]; sorry",
  "name": "inv_le_div_iff_le_mul'",
  "kind": "theorem",
  "first-tactic": "rw [inv_le_div_iff_le_mul]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} : a⁻¹ ≤ b / c ↔ c ≤ a * b",
  "args":
  "{α : Type u}  [CommGroup α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α}"},
 {"type": "a / d ≤ b / c",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [Preorder α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} (hab : a ≤ b)  (hcd : c ≤ d) : a / d ≤ b / c := by rw [div_eq_mul_inv]; sorry",
  "name": "div_le_div''",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [Preorder α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} (hab : a ≤ b)  (hcd : c ≤ d) : a / d ≤ b / c",
  "args":
  "{α : Type u}  [CommGroup α]  [Preorder α]  [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c d : α} (hab : a ≤ b)  (hcd : c ≤ d)"},
 {"type": "a / c < b / c ↔ a < b",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α} (c : α) : a / c < b / c ↔ a < b := by simpa only [div_eq_mul_inv] using mul_lt_mul_iff_right _; sorry",
  "name": "div_lt_div_iff_right",
  "kind": "theorem",
  "first-tactic": "simpa only [div_eq_mul_inv] using mul_lt_mul_iff_right _",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α} (c : α) : a / c < b / c ↔ a < b",
  "args":
  "{α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α} (c : α)"},
 {"type": "1 < a / b ↔ b < a",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α} : 1 < a / b ↔ b < a := by rw [← mul_lt_mul_iff_right b]; sorry",
  "name": "one_lt_div'",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_right b]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α} : 1 < a / b ↔ b < a",
  "args":
  "{α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α}"},
 {"type": "a / b < 1 ↔ a < b",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α} : a / b < 1 ↔ a < b := by rw [← mul_lt_mul_iff_right b]; sorry",
  "name": "div_lt_one'",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_right b]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α} : a / b < 1 ↔ a < b",
  "args":
  "{α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α}"},
 {"type": "a < c / b ↔ a * b < c",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α} : a < c / b ↔ a * b < c := by rw [← mul_lt_mul_iff_right b]; sorry",
  "name": "lt_div_iff_mul_lt",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_right b]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α} : a < c / b ↔ a * b < c",
  "args":
  "{α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α}"},
 {"type": "a / c < b ↔ a < b * c",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α} : a / c < b ↔ a < b * c := by rw [← mul_lt_mul_iff_right c]; sorry",
  "name": "div_lt_iff_lt_mul",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_right c]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α} : a / c < b ↔ a < b * c",
  "args":
  "{α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α}"},
 {"type": "a / b < a / c ↔ c < b",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c : α} (a : α) : a / b < a / c ↔ c < b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_lt_div_iff_left",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c : α} (a : α) : a / b < a / c ↔ c < b",
  "args":
  "{α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c : α} (a : α)"},
 {"type": "a⁻¹ < b / c ↔ c < a * b",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c : α} : a⁻¹ < b / c ↔ c < a * b := by rw [div_eq_mul_inv]; sorry",
  "name": "inv_lt_div_iff_lt_mul",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c : α} : a⁻¹ < b / c ↔ c < a * b",
  "args":
  "{α : Type u}  [CommGroup α]  [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]    {a b c : α}"},
 {"type": "a / b < c / d ↔ a * d < c * b",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α} : a / b < c / d ↔ a * d < c * b := by simpa only [div_eq_mul_inv] using mul_inv_lt_mul_inv_iff'; sorry",
  "name": "div_lt_div_iff'",
  "kind": "theorem",
  "first-tactic": "simpa only [div_eq_mul_inv] using mul_inv_lt_mul_inv_iff'",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α} : a / b < c / d ↔ a * d < c * b",
  "args":
  "{α : Type u}  [CommGroup α]  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α}"},
 {"type": "b < c / a ↔ a * b < c",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α} : b < c / a ↔ a * b < c := by rw [lt_div_iff_mul_lt]; sorry",
  "name": "lt_div_iff_mul_lt'",
  "kind": "theorem",
  "first-tactic": "rw [lt_div_iff_mul_lt]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α} : b < c / a ↔ a * b < c",
  "args":
  "{α : Type u}  [CommGroup α]  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α}"},
 {"type": "a / b < c ↔ a < b * c",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α} : a / b < c ↔ a < b * c := by rw [div_lt_iff_lt_mul]; sorry",
  "name": "div_lt_iff_lt_mul'",
  "kind": "theorem",
  "first-tactic": "rw [div_lt_iff_lt_mul]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α} : a / b < c ↔ a < b * c",
  "args":
  "{α : Type u}  [CommGroup α]  [CommGroup α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α}"},
 {"type": "a / d < b / c",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [CommGroup α]  [Preorder α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α} (hab : a < b)  (hcd : c < d) : a / d < b / c := by rw [div_eq_mul_inv]; sorry",
  "name": "div_lt_div''",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [CommGroup α]  [Preorder α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α} (hab : a < b)  (hcd : c < d) : a / d < b / c",
  "args":
  "{α : Type u}  [CommGroup α]  [CommGroup α]  [Preorder α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c d : α} (hab : a < b)  (hcd : c < d)"},
 {"type": "cmp (a / b) 1 = cmp a b",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [Group α]  [LinearOrder α] [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  (a b : α) : cmp (a / b) 1 = cmp a b := by rw [← cmp_mul_right' _ _ b]; sorry",
  "name": "cmp_div_one'",
  "kind": "theorem",
  "first-tactic": "rw [← cmp_mul_right' _ _ b]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [Group α]  [LinearOrder α] [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  (a b : α) : cmp (a / b) 1 = cmp a b",
  "args":
  "{α : Type u}  [CommGroup α]  [Group α]  [LinearOrder α] [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  (a b : α)"},
 {"type": "a / b ≤ a⁻¹ * b ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [Group α]  [LinearOrder α] [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c : α} [CovariantClass α α (swap (· * ·)) (· ≤ ·)] : a / b ≤ a⁻¹ * b ↔ a ≤ b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_le_inv_mul_iff",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [Group α]  [LinearOrder α] [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c : α} [CovariantClass α α (swap (· * ·)) (· ≤ ·)] : a / b ≤ a⁻¹ * b ↔ a ≤ b",
  "args":
  "{α : Type u}  [CommGroup α]  [Group α]  [LinearOrder α] [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c : α} [CovariantClass α α (swap (· * ·)) (· ≤ ·)]"},
 {"type": "a / b ≤ b / a ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [Group α]  [LinearOrder α] [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c : α} {α : Type _}  [CommGroup α]  [LinearOrder α]      [CovariantClass α α (· * ·) (· ≤ ·)]  {a b : α} : a / b ≤ b / a ↔ a ≤ b := by rw [div_eq_mul_inv b]; sorry",
  "name": "div_le_div_flip",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv b]",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [Group α]  [LinearOrder α] [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c : α} {α : Type _}  [CommGroup α]  [LinearOrder α]      [CovariantClass α α (· * ·) (· ≤ ·)]  {a b : α} : a / b ≤ b / a ↔ a ≤ b",
  "args":
  "{α : Type u}  [CommGroup α]  [Group α]  [LinearOrder α] [CovariantClass α α (· * ·) (· ≤ ·)]  {a b c : α} {α : Type _}  [CommGroup α]  [LinearOrder α]      [CovariantClass α α (· * ·) (· ≤ ·)]  {a b : α}"},
 {"type": "∃ a : α, 1 < a",
  "tactic-prompt":
  "theorem {α : Type u}  [CommGroup α]  [LinearOrderedCommGroup α]  {a b c : α} [Nontrivial α] : ∃ a : α, 1 < a := by obtain ⟨y, hy⟩ := Decidable.exists_ne (1 : α); sorry",
  "name": "exists_one_lt'",
  "kind": "theorem",
  "first-tactic": "obtain ⟨y, hy⟩ := Decidable.exists_ne (1 : α)",
  "core-prompt":
  "{α : Type u}  [CommGroup α]  [LinearOrderedCommGroup α]  {a b c : α} [Nontrivial α] : ∃ a : α, 1 < a",
  "args":
  "{α : Type u}  [CommGroup α]  [LinearOrderedCommGroup α]  {a b c : α} [Nontrivial α]"},
 {"type": "|(-a)| = |a|",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] (a : α) : |(-a)| = |a| := by rw [abs_eq_max_neg]; sorry",
  "name": "abs_neg",
  "kind": "theorem",
  "first-tactic": "rw [abs_eq_max_neg]",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] (a : α) : |(-a)| = |a|",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] (a : α)"},
 {"type": "a = b ∨ a = -b",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] {a b : α}  (h : |a| = b) : a = b ∨ a = -b := by simpa only [← h]; sorry",
  "name": "eq_or_eq_neg_of_abs_eq",
  "kind": "theorem",
  "first-tactic": "simpa only [← h]",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] {a b : α}  (h : |a| = b) : a = b ∨ a = -b",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] {a b : α}  (h : |a| = b)"},
 {"type": "|a| = |b| ↔ a = b ∨ a = -b",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] {a b : α} : |a| = |b| ↔ a = b ∨ a = -b := by refine' ⟨fun h => _, fun h => _⟩; sorry",
  "name": "abs_eq_abs",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, fun h => _⟩",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] {a b : α} : |a| = |b| ↔ a = b ∨ a = -b",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] {a b : α}"},
 {"type": "|a| ≤ |b|",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} (ha : 0 ≤ a)  (hab : a ≤ b) : |a| ≤ |b| := by rwa [abs_of_nonneg ha]; sorry",
  "name": "abs_le_abs_of_nonneg",
  "kind": "theorem",
  "first-tactic": "rwa [abs_of_nonneg ha]",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} (ha : 0 ≤ a)  (hab : a ≤ b) : |a| ≤ |b|",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} (ha : 0 ≤ a)  (hab : a ≤ b)"},
 {"type": "0 < |a| ↔ a ≠ 0",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} : 0 < |a| ↔ a ≠ 0 := by rcases lt_trichotomy a 0 with (ha | rfl | ha); sorry",
  "name": "abs_pos",
  "kind": "theorem",
  "first-tactic": "rcases lt_trichotomy a 0 with (ha | rfl | ha)",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} : 0 < |a| ↔ a ≠ 0",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α}"},
 {"type": "-|a| ≤ a",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} (a : α) : -|a| ≤ a := by cases' le_total 0 a with h h; sorry",
  "name": "neg_abs_le_self",
  "kind": "theorem",
  "first-tactic": "cases' le_total 0 a with h h",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} (a : α) : -|a| ≤ a",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} (a : α)"},
 {"type": "0 ≤ a + |a|",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} (a : α) : 0 ≤ a + |a| := by rw [← add_right_neg a]; sorry",
  "name": "add_abs_nonneg",
  "kind": "theorem",
  "first-tactic": "rw [← add_right_neg a]",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} (a : α) : 0 ≤ a + |a|",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} (a : α)"},
 {"type": "-|a| ≤ -a",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} (a : α) : -|a| ≤ -a := by simpa using neg_abs_le_self (-a); sorry",
  "name": "neg_abs_le_neg",
  "kind": "theorem",
  "first-tactic": "simpa using neg_abs_le_self (-a)",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} (a : α) : -|a| ≤ -a",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} (a : α)"},
 {"type": "|a| ≤ |b|",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} [CovariantClass α α (swap (· + ·)) (· ≤ ·)] (ha : a ≤ 0)  (hab : b ≤ a) : |a| ≤ |b| := by rw [abs_of_nonpos ha]; sorry",
  "name": "abs_le_abs_of_nonpos",
  "kind": "theorem",
  "first-tactic": "rw [abs_of_nonpos ha]",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} [CovariantClass α α (swap (· + ·)) (· ≤ ·)] (ha : a ≤ 0)  (hab : b ≤ a) : |a| ≤ |b|",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} [CovariantClass α α (swap (· + ·)) (· ≤ ·)] (ha : a ≤ 0)  (hab : b ≤ a)"},
 {"type": "max a b - min a b = |a - b|",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} [CovariantClass α α (swap (· + ·)) (· ≤ ·)] (a b : α) : max a b - min a b = |a - b| := by cases' le_total a b with ab ba; sorry",
  "name": "max_sub_min_eq_abs'",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with ab ba",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} [CovariantClass α α (swap (· + ·)) (· ≤ ·)] (a b : α) : max a b - min a b = |a - b|",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} [CovariantClass α α (swap (· + ·)) (· ≤ ·)] (a b : α)"},
 {"type": "max a b - min a b = |b - a|",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} [CovariantClass α α (swap (· + ·)) (· ≤ ·)] (a b : α) : max a b - min a b = |b - a| := by rw [abs_sub_comm]; sorry",
  "name": "max_sub_min_eq_abs",
  "kind": "theorem",
  "first-tactic": "rw [abs_sub_comm]",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} [CovariantClass α α (swap (· + ·)) (· ≤ ·)] (a b : α) : max a b - min a b = |b - a|",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [AddGroup α]  [LinearOrder α] [CovariantClass α α (· + ·) (· ≤ ·)]  {a b c : α} [CovariantClass α α (swap (· + ·)) (· ≤ ·)] (a b : α)"},
 {"type": "|a| ≤ b ↔ -b ≤ a ∧ a ≤ b",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. : |a| ≤ b ↔ -b ≤ a ∧ a ≤ b := by rw [abs_le']; sorry",
  "name": "abs_le",
  "kind": "theorem",
  "first-tactic": "rw [abs_le']",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. : |a| ≤ b ↔ -b ≤ a ∧ a ≤ b",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`."},
 {"type": "a ≤ |b| ↔ b ≤ -a ∨ a ≤ b",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. : a ≤ |b| ↔ b ≤ -a ∨ a ≤ b := by rw [le_abs]; sorry",
  "name": "le_abs'",
  "kind": "theorem",
  "first-tactic": "rw [le_abs]",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. : a ≤ |b| ↔ b ≤ -a ∨ a ≤ b",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`."},
 {"type": "|a| ≤ |b| + |b + a|",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. (a b : α) : |a| ≤ |b| + |b + a| := by simpa using abs_add (-b) (b + a); sorry",
  "name": "abs_add'",
  "kind": "theorem",
  "first-tactic": "simpa using abs_add (-b) (b + a)",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. (a b : α) : |a| ≤ |b| + |b + a|",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. (a b : α)"},
 {"type": "|a - b| ≤ |a| + |b|",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. (a b : α) : |a - b| ≤ |a| + |b| := by rw [sub_eq_add_neg]; sorry",
  "name": "abs_sub",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. (a b : α) : |a - b| ≤ |a| + |b|",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. (a b : α)"},
 {"type": "|a - b| ≤ c ↔ a - b ≤ c ∧ b - a ≤ c",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. : |a - b| ≤ c ↔ a - b ≤ c ∧ b - a ≤ c := by rw [abs_le]; sorry",
  "name": "abs_sub_le_iff",
  "kind": "theorem",
  "first-tactic": "rw [abs_le]",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. : |a - b| ≤ c ↔ a - b ≤ c ∧ b - a ≤ c",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`."},
 {"type": "|a - b| < c ↔ a - b < c ∧ b - a < c",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. : |a - b| < c ↔ a - b < c ∧ b - a < c := by rw [@abs_lt α]; sorry",
  "name": "abs_sub_lt_iff",
  "kind": "theorem",
  "first-tactic": "rw [@abs_lt α]",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. : |a - b| < c ↔ a - b < c ∧ b - a < c",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`."},
 {"type": "|a| = b ↔ a = b ∨ a = -b",
  "tactic-prompt":
  "theorem {α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. (hb : 0 ≤ b) : |a| = b ↔ a = b ∨ a = -b := by refine' ⟨eq_or_eq_neg_of_abs_eq, _⟩; sorry",
  "name": "abs_eq",
  "kind": "theorem",
  "first-tactic": "refine' ⟨eq_or_eq_neg_of_abs_eq, _⟩",
  "core-prompt":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. (hb : 0 ≤ b) : |a| = b ↔ a = b ∨ a = -b",
  "args":
  "{α : Type _}   [Neg α]  [LinearOrder α]  {a b : α}  [LinearOrderedAddCommGroup α]  {a b c d : α}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `α`. (hb : 0 ≤ b)"},
 {"type": "max a 1 / max a⁻¹ 1 = a",
  "tactic-prompt":
  "theorem {α : Type _}  [Group α]  [LinearOrder α]  [CovariantClass α α (. * .) (. ≤ .)] (a : α) : max a 1 / max a⁻¹ 1 = a := by rcases le_total a 1 with (h | h); sorry",
  "name": "max_one_div_max_inv_one_eq_self",
  "kind": "theorem",
  "first-tactic": "rcases le_total a 1 with (h | h)",
  "core-prompt":
  "{α : Type _}  [Group α]  [LinearOrder α]  [CovariantClass α α (. * .) (. ≤ .)] (a : α) : max a 1 / max a⁻¹ 1 = a",
  "args":
  "{α : Type _}  [Group α]  [LinearOrder α]  [CovariantClass α α (. * .) (. ≤ .)] (a : α)"},
 {"type": "min (a / c) (b / c) = min a b / c",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedCommGroup α]  {a b c : α} (a b c : α) : min (a / c) (b / c) = min a b / c := by simpa only [div_eq_mul_inv] using min_mul_mul_right a b c⁻¹; sorry",
  "name": "min_div_div_right'",
  "kind": "theorem",
  "first-tactic": "simpa only [div_eq_mul_inv] using min_mul_mul_right a b c⁻¹",
  "core-prompt":
  "{α : Type _}  [LinearOrderedCommGroup α]  {a b c : α} (a b c : α) : min (a / c) (b / c) = min a b / c",
  "args": "{α : Type _}  [LinearOrderedCommGroup α]  {a b c : α} (a b c : α)"},
 {"type": "max (a / c) (b / c) = max a b / c",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedCommGroup α]  {a b c : α} (a b c : α) : max (a / c) (b / c) = max a b / c := by simpa only [div_eq_mul_inv] using max_mul_mul_right a b c⁻¹; sorry",
  "name": "max_div_div_right'",
  "kind": "theorem",
  "first-tactic": "simpa only [div_eq_mul_inv] using max_mul_mul_right a b c⁻¹",
  "core-prompt":
  "{α : Type _}  [LinearOrderedCommGroup α]  {a b c : α} (a b c : α) : max (a / c) (b / c) = max a b / c",
  "args": "{α : Type _}  [LinearOrderedCommGroup α]  {a b c : α} (a b c : α)"},
 {"type": "min (a / b) (a / c) = a / max b c",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedCommGroup α]  {a b c : α} (a b c : α) : min (a / b) (a / c) = a / max b c := by simp only [div_eq_mul_inv]; sorry",
  "name": "min_div_div_left'",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _}  [LinearOrderedCommGroup α]  {a b c : α} (a b c : α) : min (a / b) (a / c) = a / max b c",
  "args": "{α : Type _}  [LinearOrderedCommGroup α]  {a b c : α} (a b c : α)"},
 {"type": "max (a / b) (a / c) = a / min b c",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedCommGroup α]  {a b c : α} (a b c : α) : max (a / b) (a / c) = a / min b c := by simp only [div_eq_mul_inv]; sorry",
  "name": "max_div_div_left'",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _}  [LinearOrderedCommGroup α]  {a b c : α} (a b c : α) : max (a / b) (a / c) = a / min b c",
  "args": "{α : Type _}  [LinearOrderedCommGroup α]  {a b c : α} (a b c : α)"},
 {"type": "max a b - max c d ≤ max (a - c) (b - d)",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedAddCommGroup α]  {a b c : α} (a b c d : α) : max a b - max c d ≤ max (a - c) (b - d) := by simp only [sub_le_iff_le_add]; sorry",
  "name": "max_sub_max_le_max",
  "kind": "theorem",
  "first-tactic": "simp only [sub_le_iff_le_add]",
  "core-prompt":
  "{α : Type _}  [LinearOrderedAddCommGroup α]  {a b c : α} (a b c d : α) : max a b - max c d ≤ max (a - c) (b - d)",
  "args":
  "{α : Type _}  [LinearOrderedAddCommGroup α]  {a b c : α} (a b c d : α)"},
 {"type": "|max a b - max c d| ≤ max (|a - c|) (|b - d|)",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedAddCommGroup α]  {a b c : α} (a b c d : α) : |max a b - max c d| ≤ max (|a - c|) (|b - d|) := by refine' abs_sub_le_iff.2 ⟨_, _⟩; sorry",
  "name": "abs_max_sub_max_le_max",
  "kind": "theorem",
  "first-tactic": "refine' abs_sub_le_iff.2 ⟨_, _⟩",
  "core-prompt":
  "{α : Type _}  [LinearOrderedAddCommGroup α]  {a b c : α} (a b c d : α) : |max a b - max c d| ≤ max (|a - c|) (|b - d|)",
  "args":
  "{α : Type _}  [LinearOrderedAddCommGroup α]  {a b c : α} (a b c d : α)"},
 {"type": "|min a b - min c d| ≤ max (|a - c|) (|b - d|)",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedAddCommGroup α]  {a b c : α} (a b c d : α) : |min a b - min c d| ≤ max (|a - c|) (|b - d|) := by simpa only [max_neg_neg]; sorry",
  "name": "abs_min_sub_min_le_max",
  "kind": "theorem",
  "first-tactic": "simpa only [max_neg_neg]",
  "core-prompt":
  "{α : Type _}  [LinearOrderedAddCommGroup α]  {a b c : α} (a b c d : α) : |min a b - min c d| ≤ max (|a - c|) (|b - d|)",
  "args":
  "{α : Type _}  [LinearOrderedAddCommGroup α]  {a b c : α} (a b c d : α)"},
 {"type": "|max a c - max b c| ≤ |a - b|",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedAddCommGroup α]  {a b c : α} (a b c : α) : |max a c - max b c| ≤ |a - b| := by simpa only [sub_self]; sorry",
  "name": "abs_max_sub_max_le_abs",
  "kind": "theorem",
  "first-tactic": "simpa only [sub_self]",
  "core-prompt":
  "{α : Type _}  [LinearOrderedAddCommGroup α]  {a b c : α} (a b c : α) : |max a c - max b c| ≤ |a - b|",
  "args":
  "{α : Type _}  [LinearOrderedAddCommGroup α]  {a b c : α} (a b c : α)"},
 {"type": "(OrderIso.mulRight a).symm = OrderIso.mulRight a⁻¹",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α} (a : α) : (OrderIso.mulRight a).symm = OrderIso.mulRight a⁻¹ := by ext x; sorry",
  "name": "OrderIso.mulRight_symm",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α} (a : α) : (OrderIso.mulRight a).symm = OrderIso.mulRight a⁻¹",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α}  [Group α]  [LE α]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α} (a : α)"},
 {"type": "(OrderIso.mulLeft a).symm = OrderIso.mulLeft a⁻¹",
  "tactic-prompt":
  "theorem {α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)] (a : α) : (OrderIso.mulLeft a).symm = OrderIso.mulLeft a⁻¹ := by ext x; sorry",
  "name": "OrderIso.mulLeft_symm",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)] (a : α) : (OrderIso.mulLeft a).symm = OrderIso.mulLeft a⁻¹",
  "args":
  "{α : Type u}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· ≤ ·)]    {a b c d : α}  [Group α]  [LE α]  [CovariantClass α α (· * ·) (· ≤ ·)] (a : α)"},
 {"type": "abv (a - c) ≤ abv (a - b) + abv (b - c)",
  "tactic-prompt":
  "theorem {R S : Type _}  [Ring R]  [OrderedSemiring S]  (abv : AbsoluteValue R S) (a b c : R) : abv (a - c) ≤ abv (a - b) + abv (b - c) := by simpa [sub_eq_add_neg]; sorry",
  "name": "sub_le",
  "kind": "theorem",
  "first-tactic": "simpa [sub_eq_add_neg]",
  "core-prompt":
  "{R S : Type _}  [Ring R]  [OrderedSemiring S]  (abv : AbsoluteValue R S) (a b c : R) : abv (a - c) ≤ abv (a - b) + abv (b - c)",
  "args":
  "{R S : Type _}  [Ring R]  [OrderedSemiring S]  (abv : AbsoluteValue R S) (a b c : R)"},
 {"type": "abv (-a) = abv a",
  "tactic-prompt":
  "theorem {R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {R S : Type _}  [Ring R]  [OrderedCommRing S]  (abv : AbsoluteValue R S) [NoZeroDivisors S] (a : R) : abv (-a) = abv a := by by_cases ha : a = 0; sorry",
  "name": "map_neg",
  "kind": "theorem",
  "first-tactic": "by_cases ha : a = 0",
  "core-prompt":
  "{R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {R S : Type _}  [Ring R]  [OrderedCommRing S]  (abv : AbsoluteValue R S) [NoZeroDivisors S] (a : R) : abv (-a) = abv a",
  "args":
  "{R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {R S : Type _}  [Ring R]  [OrderedCommRing S]  (abv : AbsoluteValue R S) [NoZeroDivisors S] (a : R)"},
 {"type": "abv (a - b) = abv (b - a)",
  "tactic-prompt":
  "theorem {R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {R S : Type _}  [Ring R]  [OrderedCommRing S]  (abv : AbsoluteValue R S) [NoZeroDivisors S] (a b : R) : abv (a - b) = abv (b - a) := by rw [← neg_sub]; sorry",
  "name": "map_sub",
  "kind": "theorem",
  "first-tactic": "rw [← neg_sub]",
  "core-prompt":
  "{R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {R S : Type _}  [Ring R]  [OrderedCommRing S]  (abv : AbsoluteValue R S) [NoZeroDivisors S] (a b : R) : abv (a - b) = abv (b - a)",
  "args":
  "{R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {R S : Type _}  [Ring R]  [OrderedCommRing S]  (abv : AbsoluteValue R S) [NoZeroDivisors S] (a b : R)"},
 {"type": "abv (a - c) ≤ abv (a - b) + abv (b - c)",
  "tactic-prompt":
  "theorem {R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {S : Type _}  [OrderedRing S]  {R : Type _}  [Ring R]  (abv : R → S)  [IsAbsoluteValue abv] (a b c : R) : abv (a - c) ≤ abv (a - b) + abv (b - c) := by simpa [sub_eq_add_neg]; sorry",
  "name": "abv_sub_le",
  "kind": "theorem",
  "first-tactic": "simpa [sub_eq_add_neg]",
  "core-prompt":
  "{R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {S : Type _}  [OrderedRing S]  {R : Type _}  [Ring R]  (abv : R → S)  [IsAbsoluteValue abv] (a b c : R) : abv (a - c) ≤ abv (a - b) + abv (b - c)",
  "args":
  "{R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {S : Type _}  [OrderedRing S]  {R : Type _}  [Ring R]  (abv : R → S)  [IsAbsoluteValue abv] (a b c : R)"},
 {"type": "0 ≤ a",
  "tactic-prompt":
  "theorem {α : Type _} {a b c d x y z : α}  [LinearOrderedCommMonoidWithZero α]  /- The following facts are true more generally in a (linearly) ordered commutative monoid. -/ : 0 ≤ a := by simpa only [mul_zero]; sorry",
  "name": "zero_le'",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_zero]",
  "core-prompt":
  "{α : Type _} {a b c d x y z : α}  [LinearOrderedCommMonoidWithZero α]  /- The following facts are true more generally in a (linearly) ordered commutative monoid. -/ : 0 ≤ a",
  "args":
  "{α : Type _} {a b c d x y z : α}  [LinearOrderedCommMonoidWithZero α]  /- The following facts are true more generally in a (linearly) ordered commutative monoid. -/"},
 {"type": "a ≤ b",
  "tactic-prompt":
  "theorem {α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (h : c ≠ 0)  (hab : a * c ≤ b * c) : a ≤ b := by simpa only [mul_inv_cancel_right₀ h] using mul_le_mul_right' hab c⁻¹; sorry",
  "name": "le_of_le_mul_right",
  "kind": "theorem",
  "first-tactic":
  "simpa only [mul_inv_cancel_right₀ h] using mul_le_mul_right' hab c⁻¹",
  "core-prompt":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (h : c ≠ 0)  (hab : a * c ≤ b * c) : a ≤ b",
  "args":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (h : c ≠ 0)  (hab : a * c ≤ b * c)"},
 {"type": "a * c⁻¹ ≤ b",
  "tactic-prompt":
  "theorem {α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (hab : a ≤ b * c) : a * c⁻¹ ≤ b := by by_cases h : c = 0; sorry",
  "name": "mul_inv_le_of_le_mul",
  "kind": "theorem",
  "first-tactic": "by_cases h : c = 0",
  "core-prompt":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (hab : a ≤ b * c) : a * c⁻¹ ≤ b",
  "args":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (hab : a ≤ b * c)"},
 {"type": "x * z⁻¹ < y",
  "tactic-prompt":
  "theorem {α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (h : x < y * z) : x * z⁻¹ < y := by contrapose! h; sorry",
  "name": "mul_inv_lt_of_lt_mul₀",
  "kind": "theorem",
  "first-tactic": "contrapose! h",
  "core-prompt":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (h : x < y * z) : x * z⁻¹ < y",
  "args":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (h : x < y * z)"},
 {"type": "y⁻¹ * x < z",
  "tactic-prompt":
  "theorem {α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (h : x < y * z) : y⁻¹ * x < z := by rw [mul_comm] at *; sorry",
  "name": "inv_mul_lt_of_lt_mul₀",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm] at *",
  "core-prompt":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (h : x < y * z) : y⁻¹ * x < z",
  "args":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (h : x < y * z)"},
 {"type": "a * c < b * c",
  "tactic-prompt":
  "theorem {α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (c : α)  (h : a < b)  (hc : c ≠ 0) : a * c < b * c := by contrapose! h; sorry",
  "name": "mul_lt_right₀",
  "kind": "theorem",
  "first-tactic": "contrapose! h",
  "core-prompt":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (c : α)  (h : a < b)  (hc : c ≠ 0) : a * c < b * c",
  "args":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (c : α)  (h : a < b)  (hc : c ≠ 0)"},
 {"type": "b < d",
  "tactic-prompt":
  "theorem {α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (h : a * b < c * d)  (hc : 0 < c)  (hh : c ≤ a) : b < d := by have ha : a ≠ 0 := ne_of_gt (lt_of_lt_of_le hc hh); sorry",
  "name": "lt_of_mul_lt_mul_of_le₀",
  "kind": "theorem",
  "first-tactic": "have ha : a ≠ 0 := ne_of_gt (lt_of_lt_of_le hc hh)",
  "core-prompt":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (h : a * b < c * d)  (hc : 0 < c)  (hh : c ≤ a) : b < d",
  "args":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (h : a * b < c * d)  (hc : 0 < c)  (hh : c ≤ a)"},
 {"type": "a * b ≤ a * c ↔ b ≤ c",
  "tactic-prompt":
  "theorem {α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (ha : a ≠ 0) : a * b ≤ a * c ↔ b ≤ c := by simp only [mul_comm a]; sorry",
  "name": "mul_le_mul_left₀",
  "kind": "theorem",
  "first-tactic": "simp only [mul_comm a]",
  "core-prompt":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (ha : a ≠ 0) : a * b ≤ a * c ↔ b ≤ c",
  "args":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (ha : a ≠ 0)"},
 {"type": "a / c ≤ b / c ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (hc : c ≠ 0) : a / c ≤ b / c ↔ a ≤ b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_le_div_right₀",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (hc : c ≠ 0) : a / c ≤ b / c ↔ a ≤ b",
  "args":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (hc : c ≠ 0)"},
 {"type": "a / b ≤ a / c ↔ c ≤ b",
  "tactic-prompt":
  "theorem {α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (ha : a ≠ 0)  (hb : b ≠ 0)  (hc : c ≠ 0) : a / b ≤ a / c ↔ c ≤ b := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_le_div_left₀",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (ha : a ≠ 0)  (hb : b ≠ 0)  (hc : c ≠ 0) : a / b ≤ a / c ↔ c ≤ b",
  "args":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (ha : a ≠ 0)  (hb : b ≠ 0)  (hc : c ≠ 0)"},
 {"type": "a ≤ b / c ↔ a * c ≤ b",
  "tactic-prompt":
  "theorem {α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (hc : c ≠ 0) : a ≤ b / c ↔ a * c ≤ b := by rw [div_eq_mul_inv]; sorry",
  "name": "le_div_iff₀",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (hc : c ≠ 0) : a ≤ b / c ↔ a * c ≤ b",
  "args":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (hc : c ≠ 0)"},
 {"type": "a / c ≤ b ↔ a ≤ b * c",
  "tactic-prompt":
  "theorem {α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (hc : c ≠ 0) : a / c ≤ b ↔ a ≤ b * c := by rw [div_eq_mul_inv]; sorry",
  "name": "div_le_iff₀",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (hc : c ≠ 0) : a / c ≤ b ↔ a ≤ b * c",
  "args":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? (hc : c ≠ 0)"},
 {"type": "(OrderIso.mulLeft₀' ha).symm = OrderIso.mulLeft₀' (inv_ne_zero ha)",
  "tactic-prompt":
  "theorem {α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? {a : α}  (ha : a ≠ 0) : (OrderIso.mulLeft₀' ha).symm = OrderIso.mulLeft₀' (inv_ne_zero ha) := by ext; sorry",
  "name": "OrderIso.mulLeft₀'_symm",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? {a : α}  (ha : a ≠ 0) : (OrderIso.mulLeft₀' ha).symm = OrderIso.mulLeft₀' (inv_ne_zero ha)",
  "args":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? {a : α}  (ha : a ≠ 0)"},
 {"type":
  "(OrderIso.mulRight₀' ha).symm = OrderIso.mulRight₀' (inv_ne_zero ha)",
  "tactic-prompt":
  "theorem {α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? {a : α}  (ha : a ≠ 0) : (OrderIso.mulRight₀' ha).symm = OrderIso.mulRight₀' (inv_ne_zero ha) := by ext; sorry",
  "name": "OrderIso.mulRight₀'_symm",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? {a : α}  (ha : a ≠ 0) : (OrderIso.mulRight₀' ha).symm = OrderIso.mulRight₀' (inv_ne_zero ha)",
  "args":
  "{α : Type _} {a b c d x y z : α} [LinearOrderedCommGroupWithZero α]  -- TODO: Do we really need the following two? {a : α}  (ha : a ≠ 0)"},
 {"type": "⅟ a ≤ 0 ↔ a ≤ 0",
  "tactic-prompt":
  "theorem [LinearOrderedSemiring α]  {a : α} [Invertible a] : ⅟ a ≤ 0 ↔ a ≤ 0 := by simp only [← not_lt]; sorry",
  "name": "invOf_nonpos",
  "kind": "theorem",
  "first-tactic": "simp only [← not_lt]",
  "core-prompt":
  "[LinearOrderedSemiring α]  {a : α} [Invertible a] : ⅟ a ≤ 0 ↔ a ≤ 0",
  "args": "[LinearOrderedSemiring α]  {a : α} [Invertible a]"},
 {"type": "⅟ a < 0 ↔ a < 0",
  "tactic-prompt":
  "theorem [LinearOrderedSemiring α]  {a : α} [Invertible a] : ⅟ a < 0 ↔ a < 0 := by simp only [← not_le]; sorry",
  "name": "invOf_lt_zero",
  "kind": "theorem",
  "first-tactic": "simp only [← not_le]",
  "core-prompt":
  "[LinearOrderedSemiring α]  {a : α} [Invertible a] : ⅟ a < 0 ↔ a < 0",
  "args": "[LinearOrderedSemiring α]  {a : α} [Invertible a]"},
 {"type": "a + ⊤ = ⊤",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  (a : WithTop α) : a + ⊤ = ⊤ := by cases a; sorry",
  "name": "add_top",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  (a : WithTop α) : a + ⊤ = ⊤",
  "args":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  (a : WithTop α)"},
 {"type": "a + b = ⊤ ↔ a = ⊤ ∨ b = ⊤",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α} : a + b = ⊤ ↔ a = ⊤ ∨ b = ⊤ := by cases a; sorry",
  "name": "add_eq_top",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α} : a + b = ⊤ ↔ a = ⊤ ∨ b = ⊤",
  "args":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}"},
 {"type": "a + b < ⊤ ↔ a < ⊤ ∧ b < ⊤",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  [PartialOrder α]  {a b : WithTop α} : a + b < ⊤ ↔ a < ⊤ ∧ b < ⊤ := by simp_rw [lt_top_iff_ne_top]; sorry",
  "name": "add_lt_top",
  "kind": "theorem",
  "first-tactic": "simp_rw [lt_top_iff_ne_top]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  [PartialOrder α]  {a b : WithTop α} : a + b < ⊤ ↔ a < ⊤ ∧ b < ⊤",
  "args":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  [PartialOrder α]  {a b : WithTop α}"},
 {"type": "x + y = ⊤ ↔ x = ⊤",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  {x : WithTop α}  {y : α} : x + y = ⊤ ↔ x = ⊤ := by induction x using WithTop.recTopCoe; sorry",
  "name": "add_coe_eq_top_iff",
  "kind": "theorem",
  "first-tactic": "induction x using WithTop.recTopCoe",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  {x : WithTop α}  {y : α} : x + y = ⊤ ↔ x = ⊤",
  "args":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  {x : WithTop α}  {y : α}"},
 {"type": "↑x + y = ⊤ ↔ y = ⊤",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  {y : WithTop α} : ↑x + y = ⊤ ↔ y = ⊤ := by induction y using WithTop.recTopCoe; sorry",
  "name": "coe_add_eq_top_iff",
  "kind": "theorem",
  "first-tactic": "induction y using WithTop.recTopCoe",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  {y : WithTop α} : ↑x + y = ⊤ ↔ y = ⊤",
  "args":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  {y : WithTop α}"},
 {"type": "b ≤ c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  [LE α]  [ContravariantClass α α (· + ·) (· ≤ ·)]  (ha : a ≠ ⊤)      (h : a + b ≤ a + c) : b ≤ c := by induction a using WithTop.recTopCoe; sorry",
  "name": "le_of_add_le_add_left",
  "kind": "theorem",
  "first-tactic": "induction a using WithTop.recTopCoe",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  [LE α]  [ContravariantClass α α (· + ·) (· ≤ ·)]  (ha : a ≠ ⊤)      (h : a + b ≤ a + c) : b ≤ c",
  "args":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  [LE α]  [ContravariantClass α α (· + ·) (· ≤ ·)]  (ha : a ≠ ⊤)      (h : a + b ≤ a + c)"},
 {"type": "b ≤ c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  [LE α]  [ContravariantClass α α (swap (· + ·)) (· ≤ ·)]      (ha : a ≠ ⊤)  (h : b + a ≤ c + a) : b ≤ c := by induction a using WithTop.recTopCoe; sorry",
  "name": "le_of_add_le_add_right",
  "kind": "theorem",
  "first-tactic": "induction a using WithTop.recTopCoe",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  [LE α]  [ContravariantClass α α (swap (· + ·)) (· ≤ ·)]      (ha : a ≠ ⊤)  (h : b + a ≤ c + a) : b ≤ c",
  "args":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  [LE α]  [ContravariantClass α α (swap (· + ·)) (· ≤ ·)]      (ha : a ≠ ⊤)  (h : b + a ≤ c + a)"},
 {"type": "a + b < a + c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  [LT α]  [CovariantClass α α (· + ·) (· < ·)]  (ha : a ≠ ⊤)      (h : b < c) : a + b < a + c := by induction a using WithTop.recTopCoe; sorry",
  "name": "add_lt_add_left",
  "kind": "theorem",
  "first-tactic": "induction a using WithTop.recTopCoe",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  [LT α]  [CovariantClass α α (· + ·) (· < ·)]  (ha : a ≠ ⊤)      (h : b < c) : a + b < a + c",
  "args":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  [LT α]  [CovariantClass α α (· + ·) (· < ·)]  (ha : a ≠ ⊤)      (h : b < c)"},
 {"type": "b + a < c + a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  [LT α]  [CovariantClass α α (swap (· + ·)) (· < ·)]  (ha : a ≠ ⊤)      (h : b < c) : b + a < c + a := by induction a using WithTop.recTopCoe; sorry",
  "name": "add_lt_add_right",
  "kind": "theorem",
  "first-tactic": "induction a using WithTop.recTopCoe",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  [LT α]  [CovariantClass α α (swap (· + ·)) (· < ·)]  (ha : a ≠ ⊤)      (h : b < c) : b + a < c + a",
  "args":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}  [LT α]  [CovariantClass α α (swap (· + ·)) (· < ·)]  (ha : a ≠ ⊤)      (h : b < c)"},
 {"type": "a + ⊥ = ⊥",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}   [Add α]  {a b c d : WithBot α}  {x y : α}  -- `norm_cast` proves those lemmas, because `with_top`/`with_bot` are reducible  (a : WithBot α) : a + ⊥ = ⊥ := by cases a; sorry",
  "name": "add_bot",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}   [Add α]  {a b c d : WithBot α}  {x y : α}  -- `norm_cast` proves those lemmas, because `with_top`/`with_bot` are reducible  (a : WithBot α) : a + ⊥ = ⊥",
  "args":
  "{α : Type u}  {β : Type v}  [Add α]  {a b c d : WithTop α}  {x y : α}   [Add α]  {a b c d : WithBot α}  {x y : α}  -- `norm_cast` proves those lemmas, because `with_top`/`with_bot` are reducible  (a : WithBot α)"},
 {"type": "(0 : α) ≤ 2",
  "tactic-prompt":
  "lemma {α : Type _} [AddMonoidWithOne α] [Preorder α]  [ZeroLEOneClass α]  [CovariantClass α α (·+·) (·≤·)] : (0 : α) ≤ 2 := by rw [← one_add_one_eq_two]; sorry",
  "name": "zero_le_two",
  "kind": "lemma",
  "first-tactic": "rw [← one_add_one_eq_two]",
  "core-prompt":
  "{α : Type _} [AddMonoidWithOne α] [Preorder α]  [ZeroLEOneClass α]  [CovariantClass α α (·+·) (·≤·)] : (0 : α) ≤ 2",
  "args":
  "{α : Type _} [AddMonoidWithOne α] [Preorder α]  [ZeroLEOneClass α]  [CovariantClass α α (·+·) (·≤·)]"},
 {"type": "(0 : α) ≤ 3",
  "tactic-prompt":
  "lemma {α : Type _} [AddMonoidWithOne α] [Preorder α]  [ZeroLEOneClass α]  [CovariantClass α α (·+·) (·≤·)] : (0 : α) ≤ 3 := by rw [← two_add_one_eq_three]; sorry",
  "name": "zero_le_three",
  "kind": "lemma",
  "first-tactic": "rw [← two_add_one_eq_three]",
  "core-prompt":
  "{α : Type _} [AddMonoidWithOne α] [Preorder α]  [ZeroLEOneClass α]  [CovariantClass α α (·+·) (·≤·)] : (0 : α) ≤ 3",
  "args":
  "{α : Type _} [AddMonoidWithOne α] [Preorder α]  [ZeroLEOneClass α]  [CovariantClass α α (·+·) (·≤·)]"},
 {"type": "(0 : α) ≤ 4",
  "tactic-prompt":
  "lemma {α : Type _} [AddMonoidWithOne α] [Preorder α]  [ZeroLEOneClass α]  [CovariantClass α α (·+·) (·≤·)] : (0 : α) ≤ 4 := by rw [← three_add_one_eq_four]; sorry",
  "name": "zero_le_four",
  "kind": "lemma",
  "first-tactic": "rw [← three_add_one_eq_four]",
  "core-prompt":
  "{α : Type _} [AddMonoidWithOne α] [Preorder α]  [ZeroLEOneClass α]  [CovariantClass α α (·+·) (·≤·)] : (0 : α) ≤ 4",
  "args":
  "{α : Type _} [AddMonoidWithOne α] [Preorder α]  [ZeroLEOneClass α]  [CovariantClass α α (·+·) (·≤·)]"},
 {"type": "(0 : α) < 3",
  "tactic-prompt":
  "lemma {α : Type _} [AddMonoidWithOne α]  [PartialOrder α]  [ZeroLEOneClass α]  [NeZero (1 : α)]  [CovariantClass α α (·+·) (·≤·)] : (0 : α) < 3 := by rw [← two_add_one_eq_three]; sorry",
  "name": "zero_lt_three",
  "kind": "lemma",
  "first-tactic": "rw [← two_add_one_eq_three]",
  "core-prompt":
  "{α : Type _} [AddMonoidWithOne α]  [PartialOrder α]  [ZeroLEOneClass α]  [NeZero (1 : α)]  [CovariantClass α α (·+·) (·≤·)] : (0 : α) < 3",
  "args":
  "{α : Type _} [AddMonoidWithOne α]  [PartialOrder α]  [ZeroLEOneClass α]  [NeZero (1 : α)]  [CovariantClass α α (·+·) (·≤·)]"},
 {"type": "(0 : α) < 4",
  "tactic-prompt":
  "lemma {α : Type _} [AddMonoidWithOne α]  [PartialOrder α]  [ZeroLEOneClass α]  [NeZero (1 : α)]  [CovariantClass α α (·+·) (·≤·)] : (0 : α) < 4 := by rw [← three_add_one_eq_four]; sorry",
  "name": "zero_lt_four",
  "kind": "lemma",
  "first-tactic": "rw [← three_add_one_eq_four]",
  "core-prompt":
  "{α : Type _} [AddMonoidWithOne α]  [PartialOrder α]  [ZeroLEOneClass α]  [NeZero (1 : α)]  [CovariantClass α α (·+·) (·≤·)] : (0 : α) < 4",
  "args":
  "{α : Type _} [AddMonoidWithOne α]  [PartialOrder α]  [ZeroLEOneClass α]  [NeZero (1 : α)]  [CovariantClass α α (·+·) (·≤·)]"},
 {"type": "(1 : α) < 2",
  "tactic-prompt":
  "lemma {α : Type _} [AddMonoidWithOne α]  [PartialOrder α]  [ZeroLEOneClass α]  [NeZero (1 : α)] [CovariantClass α α (·+·) (·<·)] : (1 : α) < 2 := by rw [← one_add_one_eq_two]; sorry",
  "name": "one_lt_two",
  "kind": "lemma",
  "first-tactic": "rw [← one_add_one_eq_two]",
  "core-prompt":
  "{α : Type _} [AddMonoidWithOne α]  [PartialOrder α]  [ZeroLEOneClass α]  [NeZero (1 : α)] [CovariantClass α α (·+·) (·<·)] : (1 : α) < 2",
  "args":
  "{α : Type _} [AddMonoidWithOne α]  [PartialOrder α]  [ZeroLEOneClass α]  [NeZero (1 : α)] [CovariantClass α α (·+·) (·<·)]"},
 {"type": "CovariantClass (WithZero α) (WithZero α) (· * ·) (· ≤ ·)",
  "tactic-prompt":
  "instance {α : Type u} [Mul α]  [Preorder α]      [CovariantClass α α (· * ·) (· ≤ ·)] : CovariantClass (WithZero α) (WithZero α) (· * ·) (· ≤ ·) := by refine ⟨fun a b c hbc => ?_⟩; sorry",
  "name": "covariantClass_mul_le",
  "kind": "instance",
  "first-tactic": "refine ⟨fun a b c hbc => ?_⟩",
  "core-prompt":
  "{α : Type u} [Mul α]  [Preorder α]      [CovariantClass α α (· * ·) (· ≤ ·)] : CovariantClass (WithZero α) (WithZero α) (· * ·) (· ≤ ·)",
  "args":
  "{α : Type u} [Mul α]  [Preorder α]      [CovariantClass α α (· * ·) (· ≤ ·)]"},
 {"type": "CovariantClass (WithZero α) (WithZero α) (· + ·) (· ≤ ·)",
  "tactic-prompt":
  "theorem {α : Type u} [AddZeroClass α]  [Preorder α]      [CovariantClass α α (· + ·) (· ≤ ·)]  (h : ∀ a : α, 0 ≤ a) : CovariantClass (WithZero α) (WithZero α) (· + ·) (· ≤ ·) := by refine ⟨fun a b c hbc => ?_⟩; sorry",
  "name": "covariantClass_add_le",
  "kind": "theorem",
  "first-tactic": "refine ⟨fun a b c hbc => ?_⟩",
  "core-prompt":
  "{α : Type u} [AddZeroClass α]  [Preorder α]      [CovariantClass α α (· + ·) (· ≤ ·)]  (h : ∀ a : α, 0 ≤ a) : CovariantClass (WithZero α) (WithZero α) (· + ·) (· ≤ ·)",
  "args":
  "{α : Type u} [AddZeroClass α]  [Preorder α]      [CovariantClass α α (· + ·) (· ≤ ·)]  (h : ∀ a : α, 0 ≤ a)"},
 {"type": "ContravariantClass (WithZero α) (WithZero α) (· * ·) (· < ·)",
  "tactic-prompt":
  "instance {α : Type u} [Mul α]  [PartialOrder α]      [ContravariantClass α α (· * ·) (· < ·)] : ContravariantClass (WithZero α) (WithZero α) (· * ·) (· < ·) := by refine ⟨fun a b c h => ?_⟩; sorry",
  "name": "contravariantClass_mul_lt",
  "kind": "instance",
  "first-tactic": "refine ⟨fun a b c h => ?_⟩",
  "core-prompt":
  "{α : Type u} [Mul α]  [PartialOrder α]      [ContravariantClass α α (· * ·) (· < ·)] : ContravariantClass (WithZero α) (WithZero α) (· * ·) (· < ·)",
  "args":
  "{α : Type u} [Mul α]  [PartialOrder α]      [ContravariantClass α α (· * ·) (· < ·)]"},
 {"type": "∃ c, 1 < c ∧ a * c = b",
  "tactic-prompt":
  "theorem {α : Type u}  [MulOneClass α]  [Preorder α]  [ContravariantClass α α (· * ·) (· < ·)]  [ExistsMulOfLE α]    {a b : α} (h : a < b) : ∃ c, 1 < c ∧ a * c = b := by obtain ⟨c, rfl⟩ := exists_mul_of_le h.le; sorry",
  "name": "exists_one_lt_mul_of_lt'",
  "kind": "theorem",
  "first-tactic": "obtain ⟨c, rfl⟩ := exists_mul_of_le h.le",
  "core-prompt":
  "{α : Type u}  [MulOneClass α]  [Preorder α]  [ContravariantClass α α (· * ·) (· < ·)]  [ExistsMulOfLE α]    {a b : α} (h : a < b) : ∃ c, 1 < c ∧ a * c = b",
  "args":
  "{α : Type u}  [MulOneClass α]  [Preorder α]  [ContravariantClass α α (· * ·) (· < ·)]  [ExistsMulOfLE α]    {a b : α} (h : a < b)"},
 {"type": "a ≤ b * a",
  "tactic-prompt":
  "theorem {α : Type u}  [CanonicallyOrderedMonoid α]  {a b c d : α} : a ≤ b * a := by rw [mul_comm]; sorry",
  "name": "le_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α : Type u}  [CanonicallyOrderedMonoid α]  {a b c d : α} : a ≤ b * a",
  "args": "{α : Type u}  [CanonicallyOrderedMonoid α]  {a b c d : α}"},
 {"type": "a ≤ b ↔ ∃ c, b = c * a",
  "tactic-prompt":
  "theorem {α : Type u}  [CanonicallyOrderedMonoid α]  {a b c d : α} : a ≤ b ↔ ∃ c, b = c * a := by simp only [mul_comm _ a]; sorry",
  "name": "le_iff_exists_mul'",
  "kind": "theorem",
  "first-tactic": "simp only [mul_comm _ a]",
  "core-prompt":
  "{α : Type u}  [CanonicallyOrderedMonoid α]  {a b c d : α} : a ≤ b ↔ ∃ c, b = c * a",
  "args": "{α : Type u}  [CanonicallyOrderedMonoid α]  {a b c d : α}"},
 {"type": "1 < a * b ↔ 1 < a ∨ 1 < b",
  "tactic-prompt":
  "theorem {α : Type u}  [CanonicallyOrderedMonoid α]  {a b c d : α} : 1 < a * b ↔ 1 < a ∨ 1 < b := by simp only [one_lt_iff_ne_one]; sorry",
  "name": "one_lt_mul_iff",
  "kind": "theorem",
  "first-tactic": "simp only [one_lt_iff_ne_one]",
  "core-prompt":
  "{α : Type u}  [CanonicallyOrderedMonoid α]  {a b c d : α} : 1 < a * b ↔ 1 < a ∨ 1 < b",
  "args": "{α : Type u}  [CanonicallyOrderedMonoid α]  {a b c d : α}"},
 {"type": "∃ (c : _) (_ : 1 < c), a * c = b",
  "tactic-prompt":
  "theorem {α : Type u}  [CanonicallyOrderedMonoid α]  {a b c d : α} (h : a < b) : ∃ (c : _) (_ : 1 < c), a * c = b := by obtain ⟨c, hc⟩ := le_iff_exists_mul.1 h.le; sorry",
  "name": "exists_one_lt_mul_of_lt",
  "kind": "theorem",
  "first-tactic": "obtain ⟨c, hc⟩ := le_iff_exists_mul.1 h.le",
  "core-prompt":
  "{α : Type u}  [CanonicallyOrderedMonoid α]  {a b c d : α} (h : a < b) : ∃ (c : _) (_ : 1 < c), a * c = b",
  "args":
  "{α : Type u}  [CanonicallyOrderedMonoid α]  {a b c d : α} (h : a < b)"},
 {"type": "a < b ↔ ∃ c > 1, b = a * c",
  "tactic-prompt":
  "theorem {α : Type u}  [CanonicallyOrderedMonoid α]  {a b c d : α} [CovariantClass α α (· * ·) (· < ·)] : a < b ↔ ∃ c > 1, b = a * c := by rw [lt_iff_le_and_ne]; sorry",
  "name": "lt_iff_exists_mul",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_le_and_ne]",
  "core-prompt":
  "{α : Type u}  [CanonicallyOrderedMonoid α]  {a b c d : α} [CovariantClass α α (· * ·) (· < ·)] : a < b ↔ ∃ c > 1, b = a * c",
  "args":
  "{α : Type u}  [CanonicallyOrderedMonoid α]  {a b c d : α} [CovariantClass α α (· * ·) (· < ·)]"},
 {"type": "min a (b * c) = min a (min a b * min a c)",
  "tactic-prompt":
  "theorem {α : Type u}  [CanonicallyLinearOrderedMonoid α]  -- see Note [lower instance priority] (a b c : α) : min a (b * c) = min a (min a b * min a c) := by cases' le_total a b with hb hb; sorry",
  "name": "min_mul_distrib",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with hb hb",
  "core-prompt":
  "{α : Type u}  [CanonicallyLinearOrderedMonoid α]  -- see Note [lower instance priority] (a b c : α) : min a (b * c) = min a (min a b * min a c)",
  "args":
  "{α : Type u}  [CanonicallyLinearOrderedMonoid α]  -- see Note [lower instance priority] (a b c : α)"},
 {"type": "min (a * b) c = min (min a c * min b c) c",
  "tactic-prompt":
  "theorem {α : Type u}  [CanonicallyLinearOrderedMonoid α]  -- see Note [lower instance priority] (a b c : α) : min (a * b) c = min (min a c * min b c) c := by simpa [min_comm _ c] using min_mul_distrib c a b; sorry",
  "name": "min_mul_distrib'",
  "kind": "theorem",
  "first-tactic": "simpa [min_comm _ c] using min_mul_distrib c a b",
  "core-prompt":
  "{α : Type u}  [CanonicallyLinearOrderedMonoid α]  -- see Note [lower instance priority] (a b c : α) : min (a * b) c = min (min a c * min b c) c",
  "args":
  "{α : Type u}  [CanonicallyLinearOrderedMonoid α]  -- see Note [lower instance priority] (a b c : α)"},
 {"type": "f (min n m) * f (max n m) = f n * f m",
  "tactic-prompt":
  "theorem {α β : Type _} [LinearOrder α]  [CommSemigroup β]  (f : α → β)  (n m : α) : f (min n m) * f (max n m) = f n * f m := by cases' le_total n m with h h; sorry",
  "name": "fn_min_mul_fn_max",
  "kind": "theorem",
  "first-tactic": "cases' le_total n m with h h",
  "core-prompt":
  "{α β : Type _} [LinearOrder α]  [CommSemigroup β]  (f : α → β)  (n m : α) : f (min n m) * f (max n m) = f n * f m",
  "args":
  "{α β : Type _} [LinearOrder α]  [CommSemigroup β]  (f : α → β)  (n m : α)"},
 {"type": "m < a ∨ n < b",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [Mul α]  [CovariantClass α α (· * ·) (· ≤ ·)] [CovariantClass α α (Function.swap (· * ·)) (· ≤ ·)]  {a b m n : α}      (h : m * n < a * b) : m < a ∨ n < b := by contrapose! h; sorry",
  "name": "lt_or_lt_of_mul_lt_mul",
  "kind": "theorem",
  "first-tactic": "contrapose! h",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [Mul α]  [CovariantClass α α (· * ·) (· ≤ ·)] [CovariantClass α α (Function.swap (· * ·)) (· ≤ ·)]  {a b m n : α}      (h : m * n < a * b) : m < a ∨ n < b",
  "args":
  "{α β : Type _}  [LinearOrder α]  [Mul α]  [CovariantClass α α (· * ·) (· ≤ ·)] [CovariantClass α α (Function.swap (· * ·)) (· ≤ ·)]  {a b m n : α}      (h : m * n < a * b)"},
 {"type": "a * b < c * d ↔ a < c ∨ b < d",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [Mul α]  [CovariantClass α α (· * ·) (· ≤ ·)] [CovariantClass α α (Function.swap (· * ·)) (· < ·)]      [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (Function.swap (· * ·)) (· ≤ ·)]      {a b c d : α}  (ac : a ≤ c)  (bd : b ≤ d) : a * b < c * d ↔ a < c ∨ b < d := by refine' ⟨lt_or_lt_of_mul_lt_mul, fun h => _⟩; sorry",
  "name": "mul_lt_mul_iff_of_le_of_le",
  "kind": "theorem",
  "first-tactic": "refine' ⟨lt_or_lt_of_mul_lt_mul, fun h => _⟩",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [Mul α]  [CovariantClass α α (· * ·) (· ≤ ·)] [CovariantClass α α (Function.swap (· * ·)) (· < ·)]      [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (Function.swap (· * ·)) (· ≤ ·)]      {a b c d : α}  (ac : a ≤ c)  (bd : b ≤ d) : a * b < c * d ↔ a < c ∨ b < d",
  "args":
  "{α β : Type _}  [LinearOrder α]  [Mul α]  [CovariantClass α α (· * ·) (· ≤ ·)] [CovariantClass α α (Function.swap (· * ·)) (· < ·)]      [CovariantClass α α (· * ·) (· < ·)]  [CovariantClass α α (Function.swap (· * ·)) (· ≤ ·)]      {a b c d : α}  (ac : a ≤ c)  (bd : b ≤ d)"},
 {"type": "min a b ≤ max c d",
  "tactic-prompt":
  "lemma {α β : Type _}  [Mul α]  [LinearOrder α]  {a b c d : α}  [CovariantClass α α (· * ·) (· < ·)]    [CovariantClass α α (swap (· * ·)) (· < ·)] (h : a * b ≤ c * d) : min a b ≤ max c d := by simp_rw [min_le_iff]; sorry",
  "name": "min_le_max_of_mul_le_mul",
  "kind": "lemma",
  "first-tactic": "simp_rw [min_le_iff]",
  "core-prompt":
  "{α β : Type _}  [Mul α]  [LinearOrder α]  {a b c d : α}  [CovariantClass α α (· * ·) (· < ·)]    [CovariantClass α α (swap (· * ·)) (· < ·)] (h : a * b ≤ c * d) : min a b ≤ max c d",
  "args":
  "{α β : Type _}  [Mul α]  [LinearOrder α]  {a b c d : α}  [CovariantClass α α (· * ·) (· < ·)]    [CovariantClass α α (swap (· * ·)) (· < ·)] (h : a * b ≤ c * d)"},
 {"type": "a₂ * b₂ ≤ a₁ * b₁ ↔ a₁ = a₂ ∧ b₁ = b₂",
  "tactic-prompt":
  "lemma {α β : Type _}  [Mul α]  [MulOneClass α]  [PartialOrder α] [CovariantClass α α (· * ·) (· ≤ ·)]    [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  [CovariantClass α α (· * ·) (· < ·)]    [CovariantClass α α (swap (· * ·)) (· < ·)]  {a₁ a₂ b₁ b₂ : α}  (ha : a₁ ≤ a₂)  (hb : b₁ ≤ b₂) : a₂ * b₂ ≤ a₁ * b₁ ↔ a₁ = a₂ ∧ b₁ = b₂ := by refine' ⟨fun h ↦ _, by rintro ⟨rfl, rfl⟩; rfl⟩; sorry",
  "name": "mul_le_mul_iff_of_ge",
  "kind": "lemma",
  "first-tactic": "refine' ⟨fun h ↦ _, by rintro ⟨rfl, rfl⟩; rfl⟩",
  "core-prompt":
  "{α β : Type _}  [Mul α]  [MulOneClass α]  [PartialOrder α] [CovariantClass α α (· * ·) (· ≤ ·)]    [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  [CovariantClass α α (· * ·) (· < ·)]    [CovariantClass α α (swap (· * ·)) (· < ·)]  {a₁ a₂ b₁ b₂ : α}  (ha : a₁ ≤ a₂)  (hb : b₁ ≤ b₂) : a₂ * b₂ ≤ a₁ * b₁ ↔ a₁ = a₂ ∧ b₁ = b₂",
  "args":
  "{α β : Type _}  [Mul α]  [MulOneClass α]  [PartialOrder α] [CovariantClass α α (· * ·) (· ≤ ·)]    [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  [CovariantClass α α (· * ·) (· < ·)]    [CovariantClass α α (swap (· * ·)) (· < ·)]  {a₁ a₂ b₁ b₂ : α}  (ha : a₁ ≤ a₂)  (hb : b₁ ≤ b₂)"},
 {"type": "∃ b : α, b * b ≤ a",
  "tactic-prompt":
  "theorem {α β : Type _}  [Mul α]  [MulOneClass α]  [LinearOrder α] [CovariantClass α α (· * ·) (· < ·)]  (a : α) : ∃ b : α, b * b ≤ a := by by_cases h:a < 1; sorry",
  "name": "exists_square_le",
  "kind": "theorem",
  "first-tactic": "by_cases h:a < 1",
  "core-prompt":
  "{α β : Type _}  [Mul α]  [MulOneClass α]  [LinearOrder α] [CovariantClass α α (· * ·) (· < ·)]  (a : α) : ∃ b : α, b * b ≤ a",
  "args":
  "{α β : Type _}  [Mul α]  [MulOneClass α]  [LinearOrder α] [CovariantClass α α (· * ·) (· < ·)]  (a : α)"},
 {"type": "a * b = c * d ↔ a = c ∧ b = d",
  "tactic-prompt":
  "theorem {α β : Type _}  [Mul α]  [Semigroup α]  [PartialOrder α]  /- This is not instance, since we want to have an instance from `LeftCancelSemigroup`s to the appropriate `CovariantClass`. -/ [CovariantClass α α (· * ·) (· < ·)]      [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  [ContravariantClass α α (· * ·) (· ≤ ·)]      [ContravariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α}  (hac : a ≤ c)  (hbd : b ≤ d) : a * b = c * d ↔ a = c ∧ b = d := by refine' ⟨fun h => _, fun h => congr_arg₂ (· * ·) h.1 h.2⟩; sorry",
  "name": "Left.mul_eq_mul_iff_eq_and_eq",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, fun h => congr_arg₂ (· * ·) h.1 h.2⟩",
  "core-prompt":
  "{α β : Type _}  [Mul α]  [Semigroup α]  [PartialOrder α]  /- This is not instance, since we want to have an instance from `LeftCancelSemigroup`s to the appropriate `CovariantClass`. -/ [CovariantClass α α (· * ·) (· < ·)]      [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  [ContravariantClass α α (· * ·) (· ≤ ·)]      [ContravariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α}  (hac : a ≤ c)  (hbd : b ≤ d) : a * b = c * d ↔ a = c ∧ b = d",
  "args":
  "{α β : Type _}  [Mul α]  [Semigroup α]  [PartialOrder α]  /- This is not instance, since we want to have an instance from `LeftCancelSemigroup`s to the appropriate `CovariantClass`. -/ [CovariantClass α α (· * ·) (· < ·)]      [CovariantClass α α (swap (· * ·)) (· ≤ ·)]  [ContravariantClass α α (· * ·) (· ≤ ·)]      [ContravariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α}  (hac : a ≤ c)  (hbd : b ≤ d)"},
 {"type": "a * b = c * d ↔ a = c ∧ b = d",
  "tactic-prompt":
  "theorem {α β : Type _}  [Mul α]  [Semigroup α]  [PartialOrder α]  /- This is not instance, since we want to have an instance from `LeftCancelSemigroup`s to the appropriate `CovariantClass`. -/ [CovariantClass α α (· * ·) (· ≤ ·)]      [ContravariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]      [ContravariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α}  (hac : a ≤ c)  (hbd : b ≤ d) : a * b = c * d ↔ a = c ∧ b = d := by refine' ⟨fun h => _, fun h => congr_arg₂ (· * ·) h.1 h.2⟩; sorry",
  "name": "Right.mul_eq_mul_iff_eq_and_eq",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, fun h => congr_arg₂ (· * ·) h.1 h.2⟩",
  "core-prompt":
  "{α β : Type _}  [Mul α]  [Semigroup α]  [PartialOrder α]  /- This is not instance, since we want to have an instance from `LeftCancelSemigroup`s to the appropriate `CovariantClass`. -/ [CovariantClass α α (· * ·) (· ≤ ·)]      [ContravariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]      [ContravariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α}  (hac : a ≤ c)  (hbd : b ≤ d) : a * b = c * d ↔ a = c ∧ b = d",
  "args":
  "{α β : Type _}  [Mul α]  [Semigroup α]  [PartialOrder α]  /- This is not instance, since we want to have an instance from `LeftCancelSemigroup`s to the appropriate `CovariantClass`. -/ [CovariantClass α α (· * ·) (· ≤ ·)]      [ContravariantClass α α (· * ·) (· ≤ ·)]  [CovariantClass α α (swap (· * ·)) (· < ·)]      [ContravariantClass α α (swap (· * ·)) (· ≤ ·)]  {a b c d : α}  (hac : a ≤ c)  (hbd : b ≤ d)"},
 {"type": "b * a ≤ c * a ↔ b ≤ c",
  "tactic-prompt":
  "theorem {α β : Type _}  [Mul α] [LE α] [CommSemigroup α]  [CovariantClass α α (· * ·) (· ≤ ·)]      {a b c : α}  (ha : MulLECancellable a) : b * a ≤ c * a ↔ b ≤ c := by rw [mul_comm b]; sorry",
  "name": "mul_le_mul_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm b]",
  "core-prompt":
  "{α β : Type _}  [Mul α] [LE α] [CommSemigroup α]  [CovariantClass α α (· * ·) (· ≤ ·)]      {a b c : α}  (ha : MulLECancellable a) : b * a ≤ c * a ↔ b ≤ c",
  "args":
  "{α β : Type _}  [Mul α] [LE α] [CommSemigroup α]  [CovariantClass α α (· * ·) (· ≤ ·)]      {a b c : α}  (ha : MulLECancellable a)"},
 {"type": "a ≤ b * a ↔ 1 ≤ b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Mul α] [LE α] [CommMonoid α]  [CovariantClass α α (· * ·) (· ≤ ·)]      {a b : α}  (ha : MulLECancellable a) : a ≤ b * a ↔ 1 ≤ b := by rw [mul_comm]; sorry",
  "name": "le_mul_iff_one_le_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α β : Type _}  [Mul α] [LE α] [CommMonoid α]  [CovariantClass α α (· * ·) (· ≤ ·)]      {a b : α}  (ha : MulLECancellable a) : a ≤ b * a ↔ 1 ≤ b",
  "args":
  "{α β : Type _}  [Mul α] [LE α] [CommMonoid α]  [CovariantClass α α (· * ·) (· ≤ ·)]      {a b : α}  (ha : MulLECancellable a)"},
 {"type": "b * a ≤ a ↔ b ≤ 1",
  "tactic-prompt":
  "theorem {α β : Type _}  [Mul α] [LE α] [CommMonoid α]  [CovariantClass α α (· * ·) (· ≤ ·)]      {a b : α}  (ha : MulLECancellable a) : b * a ≤ a ↔ b ≤ 1 := by rw [mul_comm]; sorry",
  "name": "mul_le_iff_le_one_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α β : Type _}  [Mul α] [LE α] [CommMonoid α]  [CovariantClass α α (· * ·) (· ≤ ·)]      {a b : α}  (ha : MulLECancellable a) : b * a ≤ a ↔ b ≤ 1",
  "args":
  "{α β : Type _}  [Mul α] [LE α] [CommMonoid α]  [CovariantClass α α (· * ·) (· ≤ ·)]      {a b : α}  (ha : MulLECancellable a)"},
 {"type": "m % k + m / k * k = m",
  "tactic-prompt":
  "theorem {R : Type u}  [EuclideanDomain R] (m k : R) : m % k + m / k * k = m := by rw [mul_comm]; sorry",
  "name": "mod_add_div'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{R : Type u}  [EuclideanDomain R] (m k : R) : m % k + m / k * k = m",
  "args": "{R : Type u}  [EuclideanDomain R] (m k : R)"},
 {"type": "m / k * k + m % k = m",
  "tactic-prompt":
  "theorem {R : Type u}  [EuclideanDomain R] (m k : R) : m / k * k + m % k = m := by rw [mul_comm]; sorry",
  "name": "div_add_mod'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{R : Type u}  [EuclideanDomain R] (m k : R) : m / k * k + m % k = m",
  "args": "{R : Type u}  [EuclideanDomain R] (m k : R)"},
 {"type": "a % 0 = a",
  "tactic-prompt":
  "theorem {R : Type u}  [EuclideanDomain R] (a : R) : a % 0 = a := by simpa only [zero_mul]; sorry",
  "name": "mod_zero",
  "kind": "theorem",
  "first-tactic": "simpa only [zero_mul]",
  "core-prompt": "{R : Type u}  [EuclideanDomain R] (a : R) : a % 0 = a",
  "args": "{R : Type u}  [EuclideanDomain R] (a : R)"},
 {"type": "gcd 0 a = a",
  "tactic-prompt":
  "theorem {R : Type u}  [EuclideanDomain R]  [DecidableEq R] (a : R) : gcd 0 a = a := by rw [gcd]; sorry",
  "name": "gcd_zero_left",
  "kind": "theorem",
  "first-tactic": "rw [gcd]",
  "core-prompt":
  "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] (a : R) : gcd 0 a = a",
  "args": "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] (a : R)"},
 {"type": "xgcdAux 0 s t r' s' t' = (r', s', t')",
  "tactic-prompt":
  "theorem {R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s t r' s' t' : R} : xgcdAux 0 s t r' s' t' = (r', s', t') := by unfold xgcdAux; sorry",
  "name": "xgcd_zero_left",
  "kind": "theorem",
  "first-tactic": "unfold xgcdAux",
  "core-prompt":
  "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s t r' s' t' : R} : xgcdAux 0 s t r' s' t' = (r', s', t')",
  "args":
  "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s t r' s' t' : R}"},
 {"type":
  "xgcdAux r s t r' s' t' = xgcdAux (r' % r) (s' - r' / r * s) (t' - r' / r * t) r s t",
  "tactic-prompt":
  "theorem {R : Type u}  [EuclideanDomain R]  [DecidableEq R] {r s t r' s' t' : R}  (h : r ≠ 0) : xgcdAux r s t r' s' t' = xgcdAux (r' % r) (s' - r' / r * s) (t' - r' / r * t) r s t := by conv =>\n    lhs\n    rw [xgcdAux]; sorry",
  "name": "xgcdAux_rec",
  "kind": "theorem",
  "first-tactic": "conv =>\n    lhs\n    rw [xgcdAux]",
  "core-prompt":
  "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] {r s t r' s' t' : R}  (h : r ≠ 0) : xgcdAux r s t r' s' t' = xgcdAux (r' % r) (s' - r' / r * s) (t' - r' / r * t) r s t",
  "args":
  "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] {r s t r' s' t' : R}  (h : r ≠ 0)"},
 {"type": "gcdA 0 s = 0",
  "tactic-prompt":
  "theorem {R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s : R} : gcdA 0 s = 0 := by unfold gcdA; sorry",
  "name": "gcdA_zero_left",
  "kind": "theorem",
  "first-tactic": "unfold gcdA",
  "core-prompt":
  "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s : R} : gcdA 0 s = 0",
  "args": "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s : R}"},
 {"type": "gcdB 0 s = 1",
  "tactic-prompt":
  "theorem {R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s : R} : gcdB 0 s = 1 := by unfold gcdB; sorry",
  "name": "gcdB_zero_left",
  "kind": "theorem",
  "first-tactic": "unfold gcdB",
  "core-prompt":
  "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s : R} : gcdB 0 s = 1",
  "args": "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s : R}"},
 {"type": "c ∣ a % b ↔ c ∣ a",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R] {a b c : R}  (h : c ∣ b) : c ∣ a % b ↔ c ∣ a := by rw [dvd_add_iff_right (h.mul_right _)]; sorry",
  "name": "dvd_mod_iff",
  "kind": "theorem",
  "first-tactic": "rw [dvd_add_iff_right (h.mul_right _)]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R] {a b c : R}  (h : c ∣ b) : c ∣ a % b ↔ c ∣ a",
  "args": "{R : Type u} [EuclideanDomain R] {a b c : R}  (h : c ∣ b)"},
 {"type": "a / a = 1",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R] {a : R}  (a0 : a ≠ 0) : a / a = 1 := by simpa only [one_mul] using mul_div_cancel 1 a0; sorry",
  "name": "div_self",
  "kind": "theorem",
  "first-tactic": "simpa only [one_mul] using mul_div_cancel 1 a0",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R] {a : R}  (a0 : a ≠ 0) : a / a = 1",
  "args": "{R : Type u} [EuclideanDomain R] {a : R}  (a0 : a ≠ 0)"},
 {"type": "a = c / b",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R] {a b c : R}  (hb : b ≠ 0)  (h : a * b = c) : a = c / b := by rw [← h]; sorry",
  "name": "eq_div_of_mul_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [← h]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R] {a b c : R}  (hb : b ≠ 0)  (h : a * b = c) : a = c / b",
  "args":
  "{R : Type u} [EuclideanDomain R] {a b c : R}  (hb : b ≠ 0)  (h : a * b = c)"},
 {"type": "b = c / a",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R] {a b c : R}  (ha : a ≠ 0)  (h : a * b = c) : b = c / a := by rw [← h]; sorry",
  "name": "eq_div_of_mul_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [← h]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R] {a b c : R}  (ha : a ≠ 0)  (h : a * b = c) : b = c / a",
  "args":
  "{R : Type u} [EuclideanDomain R] {a b c : R}  (ha : a ≠ 0)  (h : a * b = c)"},
 {"type": "x * y / z = x * (y / z)",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R] (x : R)  {y z : R}  (h : z ∣ y) : x * y / z = x * (y / z) := by by_cases hz : z = 0; sorry",
  "name": "mul_div_assoc",
  "kind": "theorem",
  "first-tactic": "by_cases hz : z = 0",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R] (x : R)  {y z : R}  (h : z ∣ y) : x * y / z = x * (y / z)",
  "args": "{R : Type u} [EuclideanDomain R] (x : R)  {y z : R}  (h : z ∣ y)"},
 {"type": "p / q ∣ p",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R] {p q : R}  (hpq : q ∣ p) : p / q ∣ p := by by_cases hq : q = 0; sorry",
  "name": "div_dvd_of_dvd",
  "kind": "theorem",
  "first-tactic": "by_cases hq : q = 0",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R] {p q : R}  (hpq : q ∣ p) : p / q ∣ p",
  "args": "{R : Type u} [EuclideanDomain R] {p q : R}  (hpq : q ∣ p)"},
 {"type": "b ∣ c / a",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R] {a b c : R}  (h : a * b ∣ c) : b ∣ c / a := by rcases eq_or_ne a 0 with (rfl | ha); sorry",
  "name": "dvd_div_of_mul_dvd",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne a 0 with (rfl | ha)",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R] {a b c : R}  (h : a * b ∣ c) : b ∣ c / a",
  "args": "{R : Type u} [EuclideanDomain R] {a b c : R}  (h : a * b ∣ c)"},
 {"type": "gcd a 0 = a",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] (a : R) : gcd a 0 = a := by rw [gcd]; sorry",
  "name": "gcd_zero_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (a : R) : gcd a 0 = a",
  "args": "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (a : R)"},
 {"type": "gcd a b = gcd (b % a) a",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] (a b : R) : gcd a b = gcd (b % a) a := by rw [gcd]; sorry",
  "name": "gcd_val",
  "kind": "theorem",
  "first-tactic": "rw [gcd]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (a b : R) : gcd a b = gcd (b % a) a",
  "args": "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (a b : R)"},
 {"type": "xgcdAux x 1 0 y 0 1 = (gcd x y, xgcd x y)",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] (x y : R) : xgcdAux x 1 0 y 0 1 = (gcd x y, xgcd x y) := by rw [xgcd]; sorry",
  "name": "xgcdAux_val",
  "kind": "theorem",
  "first-tactic": "rw [xgcd]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (x y : R) : xgcdAux x 1 0 y 0 1 = (gcd x y, xgcd x y)",
  "args": "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (x y : R)"},
 {"type": "(gcd a b : R) = a * gcdA a b + b * gcdB a b",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] (a b : R) : (gcd a b : R) = a * gcdA a b + b * gcdB a b := by have :=\n    @xgcdAux_P _ _ _ a b a b 1 0 0 1 (by dsimp [P]; rw [mul_one]; sorry",
  "name": "gcd_eq_gcd_ab",
  "kind": "theorem",
  "first-tactic":
  "have :=\n    @xgcdAux_P _ _ _ a b a b 1 0 0 1 (by dsimp [P]; rw [mul_one]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (a b : R) : (gcd a b : R) = a * gcdA a b + b * gcdB a b",
  "args": "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (a b : R)"},
 {"type": "lcm x y ∣ z",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] {x y z : R}  (hxz : x ∣ z)  (hyz : y ∣ z) : lcm x y ∣ z := by rw [lcm]; sorry",
  "name": "lcm_dvd",
  "kind": "theorem",
  "first-tactic": "rw [lcm]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] {x y z : R}  (hxz : x ∣ z)  (hyz : y ∣ z) : lcm x y ∣ z",
  "args":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] {x y z : R}  (hxz : x ∣ z)  (hyz : y ∣ z)"},
 {"type": "lcm 0 x = 0",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] (x : R) : lcm 0 x = 0 := by rw [lcm]; sorry",
  "name": "lcm_zero_left",
  "kind": "theorem",
  "first-tactic": "rw [lcm]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (x : R) : lcm 0 x = 0",
  "args": "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (x : R)"},
 {"type": "lcm x 0 = 0",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] (x : R) : lcm x 0 = 0 := by rw [lcm]; sorry",
  "name": "lcm_zero_right",
  "kind": "theorem",
  "first-tactic": "rw [lcm]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (x : R) : lcm x 0 = 0",
  "args": "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (x : R)"},
 {"type": "lcm x y = 0 ↔ x = 0 ∨ y = 0",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] {x y : R} : lcm x y = 0 ↔ x = 0 ∨ y = 0 := by constructor; sorry",
  "name": "lcm_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] {x y : R} : lcm x y = 0 ↔ x = 0 ∨ y = 0",
  "args": "{R : Type u} [EuclideanDomain R]  [DecidableEq R] {x y : R}"},
 {"type": "gcd x y * lcm x y = x * y",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] (x y : R) : gcd x y * lcm x y = x * y := by rw [lcm]; sorry",
  "name": "gcd_mul_lcm",
  "kind": "theorem",
  "first-tactic": "rw [lcm]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (x y : R) : gcd x y * lcm x y = x * y",
  "args": "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (x y : R)"},
 {"type": "a * b / (a * c) = b / c",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  {a b c : R}  (ha : a ≠ 0)  (hcb : c ∣ b) : a * b / (a * c) = b / c := by by_cases hc : c = 0; sorry",
  "name": "mul_div_mul_cancel",
  "kind": "theorem",
  "first-tactic": "by_cases hc : c = 0",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  {a b c : R}  (ha : a ≠ 0)  (hcb : c ∣ b) : a * b / (a * c) = b / c",
  "args":
  "{R : Type u} [EuclideanDomain R]  {a b c : R}  (ha : a ≠ 0)  (hcb : c ∣ b)"},
 {"type": "a * b / (c * d) = a / c * (b / d)",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  {a b c d : R}  (hac : c ∣ a)  (hbd : d ∣ b) : a * b / (c * d) = a / c * (b / d) := by rcases eq_or_ne c 0 with (rfl | hc0); sorry",
  "name": "mul_div_mul_comm_of_dvd_dvd",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne c 0 with (rfl | hc0)",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  {a b c d : R}  (hac : c ∣ a)  (hbd : d ∣ b) : a * b / (c * d) = a / c * (b / d)",
  "args":
  "{R : Type u} [EuclideanDomain R]  {a b c d : R}  (hac : c ∣ a)  (hbd : d ∣ b)"},
 {"type": "c.symm.symm = c",
  "tactic-prompt":
  "theorem {ι : Type _} (c : ComplexShape ι) : c.symm.symm = c := by ext; sorry",
  "name": "symm_symm",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt": "{ι : Type _} (c : ComplexShape ι) : c.symm.symm = c",
  "args": "{ι : Type _} (c : ComplexShape ι)"},
 {"type": "Subsingleton { j // c.Rel i j }",
  "tactic-prompt":
  "instance {ι : Type _} (c : ComplexShape ι)  (i : ι) : Subsingleton { j // c.Rel i j } := by constructor; sorry",
  "name": "subsingleton_next",
  "kind": "instance",
  "first-tactic": "constructor",
  "core-prompt":
  "{ι : Type _} (c : ComplexShape ι)  (i : ι) : Subsingleton { j // c.Rel i j }",
  "args": "{ι : Type _} (c : ComplexShape ι)  (i : ι)"},
 {"type": "Subsingleton { i // c.Rel i j }",
  "tactic-prompt":
  "instance {ι : Type _} (c : ComplexShape ι)  (j : ι) : Subsingleton { i // c.Rel i j } := by constructor; sorry",
  "name": "subsingleton_prev",
  "kind": "instance",
  "first-tactic": "constructor",
  "core-prompt":
  "{ι : Type _} (c : ComplexShape ι)  (j : ι) : Subsingleton { i // c.Rel i j }",
  "args": "{ι : Type _} (c : ComplexShape ι)  (j : ι)"},
 {"type": "c.next i = j",
  "tactic-prompt":
  "theorem {ι : Type _} (c : ComplexShape ι)  {i j : ι}  (h : c.Rel i j) : c.next i = j := by apply c.next_eq _ h; sorry",
  "name": "next_eq'",
  "kind": "theorem",
  "first-tactic": "apply c.next_eq _ h",
  "core-prompt":
  "{ι : Type _} (c : ComplexShape ι)  {i j : ι}  (h : c.Rel i j) : c.next i = j",
  "args": "{ι : Type _} (c : ComplexShape ι)  {i j : ι}  (h : c.Rel i j)"},
 {"type": "c.prev j = i",
  "tactic-prompt":
  "theorem {ι : Type _} (c : ComplexShape ι)  {i j : ι}  (h : c.Rel i j) : c.prev j = i := by apply c.prev_eq _ h; sorry",
  "name": "prev_eq'",
  "kind": "theorem",
  "first-tactic": "apply c.prev_eq _ h",
  "core-prompt":
  "{ι : Type _} (c : ComplexShape ι)  {i j : ι}  (h : c.Rel i j) : c.prev j = i",
  "args": "{ι : Type _} (c : ComplexShape ι)  {i j : ι}  (h : c.Rel i j)"},
 {"type": "IsSquare m → IsSquare (f m)",
  "tactic-prompt":
  "theorem {F α β R : Type _} [MulOneClass α]  [MulOneClass β]  [MonoidHomClass F α β]  {m : α}  (f : F) : IsSquare m → IsSquare (f m) := by rintro ⟨m, rfl⟩; sorry",
  "name": "IsSquare.map",
  "kind": "theorem",
  "first-tactic": "rintro ⟨m, rfl⟩",
  "core-prompt":
  "{F α β R : Type _} [MulOneClass α]  [MulOneClass β]  [MonoidHomClass F α β]  {m : α}  (f : F) : IsSquare m → IsSquare (f m)",
  "args":
  "{F α β R : Type _} [MulOneClass α]  [MulOneClass β]  [MonoidHomClass F α β]  {m : α}  (f : F)"},
 {"type": "IsSquare m ↔ ∃ c, m = c ^ 2",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Monoid α]  {n : ℕ}  {a : α} (m : α) : IsSquare m ↔ ∃ c, m = c ^ 2 := by simp [IsSquare]; sorry",
  "name": "isSquare_iff_exists_sq",
  "kind": "theorem",
  "first-tactic": "simp [IsSquare]",
  "core-prompt":
  "{F α β R : Type _}  [Monoid α]  {n : ℕ}  {a : α} (m : α) : IsSquare m ↔ ∃ c, m = c ^ 2",
  "args": "{F α β R : Type _}  [Monoid α]  {n : ℕ}  {a : α} (m : α)"},
 {"type": "IsSquare a → IsSquare (a ^ n)",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Monoid α]  {n : ℕ}  {a : α} (n : ℕ) : IsSquare a → IsSquare (a ^ n) := by rintro ⟨a, rfl⟩; sorry",
  "name": "IsSquare.pow",
  "kind": "theorem",
  "first-tactic": "rintro ⟨a, rfl⟩",
  "core-prompt":
  "{F α β R : Type _}  [Monoid α]  {n : ℕ}  {a : α} (n : ℕ) : IsSquare a → IsSquare (a ^ n)",
  "args": "{F α β R : Type _}  [Monoid α]  {n : ℕ}  {a : α} (n : ℕ)"},
 {"type": "Even n → ∀ a : α, IsSquare (a ^ n)",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Monoid α]  {n : ℕ}  {a : α} : Even n → ∀ a : α, IsSquare (a ^ n) := by rintro ⟨n, rfl⟩ a; sorry",
  "name": "Even.isSquare_pow",
  "kind": "theorem",
  "first-tactic": "rintro ⟨n, rfl⟩ a",
  "core-prompt":
  "{F α β R : Type _}  [Monoid α]  {n : ℕ}  {a : α} : Even n → ∀ a : α, IsSquare (a ^ n)",
  "args": "{F α β R : Type _}  [Monoid α]  {n : ℕ}  {a : α}"},
 {"type": "Even n → ∀ a : α, (-a) ^ n = a ^ n",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Monoid α]  {n : ℕ}  {a : α} [HasDistribNeg α] : Even n → ∀ a : α, (-a) ^ n = a ^ n := by rintro ⟨c, rfl⟩ a; sorry",
  "name": "Even.neg_pow",
  "kind": "theorem",
  "first-tactic": "rintro ⟨c, rfl⟩ a",
  "core-prompt":
  "{F α β R : Type _}  [Monoid α]  {n : ℕ}  {a : α} [HasDistribNeg α] : Even n → ∀ a : α, (-a) ^ n = a ^ n",
  "args": "{F α β R : Type _}  [Monoid α]  {n : ℕ}  {a : α} [HasDistribNeg α]"},
 {"type": "(-1 : α) ^ n = 1",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Monoid α]  {n : ℕ}  {a : α} [HasDistribNeg α] (h : Even n) : (-1 : α) ^ n = 1 := by rw [h.neg_pow]; sorry",
  "name": "Even.neg_one_pow",
  "kind": "theorem",
  "first-tactic": "rw [h.neg_pow]",
  "core-prompt":
  "{F α β R : Type _}  [Monoid α]  {n : ℕ}  {a : α} [HasDistribNeg α] (h : Even n) : (-1 : α) ^ n = 1",
  "args":
  "{F α β R : Type _}  [Monoid α]  {n : ℕ}  {a : α} [HasDistribNeg α] (h : Even n)"},
 {"type": "IsSquare a → IsSquare b → IsSquare (a * b)",
  "tactic-prompt":
  "theorem {F α β R : Type _} [CommSemigroup α]  {a b : α} : IsSquare a → IsSquare b → IsSquare (a * b) := by rintro ⟨a, rfl⟩ ⟨b, rfl⟩; sorry",
  "name": "IsSquare.mul",
  "kind": "theorem",
  "first-tactic": "rintro ⟨a, rfl⟩ ⟨b, rfl⟩",
  "core-prompt":
  "{F α β R : Type _} [CommSemigroup α]  {a b : α} : IsSquare a → IsSquare b → IsSquare (a * b)",
  "args": "{F α β R : Type _} [CommSemigroup α]  {a b : α}"},
 {"type": "IsSquare a⁻¹ ↔ IsSquare a",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [DivisionMonoid α]  {a : α} : IsSquare a⁻¹ ↔ IsSquare a := by refine' ⟨fun h => _, fun h => _⟩; sorry",
  "name": "isSquare_inv",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, fun h => _⟩",
  "core-prompt":
  "{F α β R : Type _}  [DivisionMonoid α]  {a : α} : IsSquare a⁻¹ ↔ IsSquare a",
  "args": "{F α β R : Type _}  [DivisionMonoid α]  {a : α}"},
 {"type": "IsSquare a → IsSquare (a ^ n)",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [DivisionMonoid α]  {a : α} (n : ℤ) : IsSquare a → IsSquare (a ^ n) := by rintro ⟨a, rfl⟩; sorry",
  "name": "IsSquare.zpow",
  "kind": "theorem",
  "first-tactic": "rintro ⟨a, rfl⟩",
  "core-prompt":
  "{F α β R : Type _}  [DivisionMonoid α]  {a : α} (n : ℤ) : IsSquare a → IsSquare (a ^ n)",
  "args": "{F α β R : Type _}  [DivisionMonoid α]  {a : α} (n : ℤ)"},
 {"type": "Even n → ∀ a : α, (-a) ^ n = a ^ n",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [DivisionMonoid α]  {a : α} [HasDistribNeg α]  {n : ℤ} : Even n → ∀ a : α, (-a) ^ n = a ^ n := by rintro ⟨c, rfl⟩ a; sorry",
  "name": "Even.neg_zpow",
  "kind": "theorem",
  "first-tactic": "rintro ⟨c, rfl⟩ a",
  "core-prompt":
  "{F α β R : Type _}  [DivisionMonoid α]  {a : α} [HasDistribNeg α]  {n : ℤ} : Even n → ∀ a : α, (-a) ^ n = a ^ n",
  "args":
  "{F α β R : Type _}  [DivisionMonoid α]  {a : α} [HasDistribNeg α]  {n : ℤ}"},
 {"type": "(-1 : α) ^ n = 1",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [DivisionMonoid α]  {a : α} [HasDistribNeg α]  {n : ℤ} (h : Even n) : (-1 : α) ^ n = 1 := by rw [h.neg_zpow]; sorry",
  "name": "Even.neg_one_zpow",
  "kind": "theorem",
  "first-tactic": "rw [h.neg_zpow]",
  "core-prompt":
  "{F α β R : Type _}  [DivisionMonoid α]  {a : α} [HasDistribNeg α]  {n : ℤ} (h : Even n) : (-1 : α) ^ n = 1",
  "args":
  "{F α β R : Type _}  [DivisionMonoid α]  {a : α} [HasDistribNeg α]  {n : ℤ} (h : Even n)"},
 {"type": "Even (|a|) ↔ Even a",
  "tactic-prompt":
  "theorem {F α β R : Type _} [SubtractionMonoid α]  [LinearOrder α]  {a : α} : Even (|a|) ↔ Even a := by cases abs_choice a; sorry",
  "name": "even_abs",
  "kind": "theorem",
  "first-tactic": "cases abs_choice a",
  "core-prompt":
  "{F α β R : Type _} [SubtractionMonoid α]  [LinearOrder α]  {a : α} : Even (|a|) ↔ Even a",
  "args": "{F α β R : Type _} [SubtractionMonoid α]  [LinearOrder α]  {a : α}"},
 {"type": "IsSquare (a / b)",
  "tactic-prompt":
  "theorem {F α β R : Type _} [DivisionCommMonoid α]  {a b : α}  (ha : IsSquare a)  (hb : IsSquare b) : IsSquare (a / b) := by rw [div_eq_mul_inv]; sorry",
  "name": "IsSquare.div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{F α β R : Type _} [DivisionCommMonoid α]  {a b : α}  (ha : IsSquare a)  (hb : IsSquare b) : IsSquare (a / b)",
  "args":
  "{F α β R : Type _} [DivisionCommMonoid α]  {a b : α}  (ha : IsSquare a)  (hb : IsSquare b)"},
 {"type": "Even n → ∀ a : α, IsSquare (a ^ n)",
  "tactic-prompt":
  "theorem {F α β R : Type _} [Group α]  {n : ℤ} : Even n → ∀ a : α, IsSquare (a ^ n) := by rintro ⟨n, rfl⟩ a; sorry",
  "name": "Even.isSquare_zpow",
  "kind": "theorem",
  "first-tactic": "rintro ⟨n, rfl⟩ a",
  "core-prompt":
  "{F α β R : Type _} [Group α]  {n : ℤ} : Even n → ∀ a : α, IsSquare (a ^ n)",
  "args": "{F α β R : Type _} [Group α]  {n : ℤ}"},
 {"type": "Even (m - n)",
  "tactic-prompt":
  "theorem {F α β R : Type _} [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]      [ContravariantClass α α (· + ·) (· ≤ ·)]  {m n : α}  (hm : Even m)  (hn : Even n) : Even (m - n) := by obtain ⟨a, rfl⟩ := hm; sorry",
  "name": "Even.tsub",
  "kind": "theorem",
  "first-tactic": "obtain ⟨a, rfl⟩ := hm",
  "core-prompt":
  "{F α β R : Type _} [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]      [ContravariantClass α α (· + ·) (· ≤ ·)]  {m n : α}  (hm : Even m)  (hn : Even n) : Even (m - n)",
  "args":
  "{F α β R : Type _} [CanonicallyLinearOrderedAddMonoid α]  [Sub α]  [OrderedSub α]      [ContravariantClass α α (· + ·) (· ≤ ·)]  {m n : α}  (hm : Even m)  (hn : Even n)"},
 {"type": "Even m ↔ ∃ c, m = 2 * c",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α} (m : α) : Even m ↔ ∃ c, m = 2 * c := by simp [even_iff_exists_two_nsmul]; sorry",
  "name": "even_iff_exists_two_mul",
  "kind": "theorem",
  "first-tactic": "simp [even_iff_exists_two_nsmul]",
  "core-prompt":
  "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α} (m : α) : Even m ↔ ∃ c, m = 2 * c",
  "args": "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α} (m : α)"},
 {"type": "Even a ↔ 2 ∣ a",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α} {a : α} : Even a ↔ 2 ∣ a := by simp [Even]; sorry",
  "name": "even_iff_two_dvd",
  "kind": "theorem",
  "first-tactic": "simp [Even]",
  "core-prompt":
  "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α} {a : α} : Even a ↔ 2 ∣ a",
  "args": "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α} {a : α}"},
 {"type": "(Set.range fun x : α => 2 * x) = { a | Even a }",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α} (α : Type _)  [Semiring α] : (Set.range fun x : α => 2 * x) = { a | Even a } := by ext x; sorry",
  "name": "range_two_mul",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α} (α : Type _)  [Semiring α] : (Set.range fun x : α => 2 * x) = { a | Even a }",
  "args":
  "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α} (α : Type _)  [Semiring α]"},
 {"type": "(Set.range fun x : α => 2 * x + 1) = { a | Odd a }",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α}  (α : Type _)  [Semiring α] : (Set.range fun x : α => 2 * x + 1) = { a | Odd a } := by ext x; sorry",
  "name": "range_two_mul_add_one",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α}  (α : Type _)  [Semiring α] : (Set.range fun x : α => 2 * x + 1) = { a | Odd a }",
  "args":
  "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α}  (α : Type _)  [Semiring α]"},
 {"type": "Even m → Odd n → Odd (m + n)",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α} : Even m → Odd n → Odd (m + n) := by rintro ⟨m, rfl⟩ ⟨n, rfl⟩; sorry",
  "name": "Even.add_odd",
  "kind": "theorem",
  "first-tactic": "rintro ⟨m, rfl⟩ ⟨n, rfl⟩",
  "core-prompt":
  "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α} : Even m → Odd n → Odd (m + n)",
  "args": "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α}"},
 {"type": "Odd (m + n)",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α}  (hm : Odd m)  (hn : Even n) : Odd (m + n) := by rw [add_comm]; sorry",
  "name": "Odd.add_even",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α}  (hm : Odd m)  (hn : Even n) : Odd (m + n)",
  "args":
  "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α}  (hm : Odd m)  (hn : Even n)"},
 {"type": "Odd m → Odd n → Even (m + n)",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α} : Odd m → Odd n → Even (m + n) := by rintro ⟨m, rfl⟩ ⟨n, rfl⟩; sorry",
  "name": "Odd.add_odd",
  "kind": "theorem",
  "first-tactic": "rintro ⟨m, rfl⟩ ⟨n, rfl⟩",
  "core-prompt":
  "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α} : Odd m → Odd n → Even (m + n)",
  "args": "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α}"},
 {"type": "Odd m → Odd (f m)",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α}  [RingHomClass F α β]  (f : F) : Odd m → Odd (f m) := by rintro ⟨m, rfl⟩; sorry",
  "name": "Odd.map",
  "kind": "theorem",
  "first-tactic": "rintro ⟨m, rfl⟩",
  "core-prompt":
  "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α}  [RingHomClass F α β]  (f : F) : Odd m → Odd (f m)",
  "args":
  "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α}  [RingHomClass F α β]  (f : F)"},
 {"type": "Odd m → Odd n → Odd (m * n)",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α} : Odd m → Odd n → Odd (m * n) := by rintro ⟨m, rfl⟩ ⟨n, rfl⟩; sorry",
  "name": "Odd.mul",
  "kind": "theorem",
  "first-tactic": "rintro ⟨m, rfl⟩ ⟨n, rfl⟩",
  "core-prompt":
  "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α} : Odd m → Odd n → Odd (m * n)",
  "args": "{F α β R : Type _}  [Semiring α]  [Semiring β]  {m n : α}"},
 {"type": "Odd n → ∀ a : α, (-a) ^ n = -a ^ n",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Monoid α]  [HasDistribNeg α]  {a : α}  {n : ℕ} : Odd n → ∀ a : α, (-a) ^ n = -a ^ n := by rintro ⟨c, rfl⟩ a; sorry",
  "name": "Odd.neg_pow",
  "kind": "theorem",
  "first-tactic": "rintro ⟨c, rfl⟩ a",
  "core-prompt":
  "{F α β R : Type _}  [Monoid α]  [HasDistribNeg α]  {a : α}  {n : ℕ} : Odd n → ∀ a : α, (-a) ^ n = -a ^ n",
  "args":
  "{F α β R : Type _}  [Monoid α]  [HasDistribNeg α]  {a : α}  {n : ℕ}"},
 {"type": "(-1 : α) ^ n = -1",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Monoid α]  [HasDistribNeg α]  {a : α}  {n : ℕ} (h : Odd n) : (-1 : α) ^ n = -1 := by rw [h.neg_pow]; sorry",
  "name": "Odd.neg_one_pow",
  "kind": "theorem",
  "first-tactic": "rw [h.neg_pow]",
  "core-prompt":
  "{F α β R : Type _}  [Monoid α]  [HasDistribNeg α]  {a : α}  {n : ℕ} (h : Odd n) : (-1 : α) ^ n = -1",
  "args":
  "{F α β R : Type _}  [Monoid α]  [HasDistribNeg α]  {a : α}  {n : ℕ} (h : Odd n)"},
 {"type": "0 < n",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [CanonicallyOrderedCommSemiring α]  -- this holds more generally in a `CanonicallyOrderedAddMonoid` if we refactor `Odd` to use -- either `2 • t` or `t + t` instead of `2 * t`. [Nontrivial α]  {n : α}  (hn : Odd n) : 0 < n := by obtain ⟨k, rfl⟩ := hn; sorry",
  "name": "Odd.pos",
  "kind": "theorem",
  "first-tactic": "obtain ⟨k, rfl⟩ := hn",
  "core-prompt":
  "{F α β R : Type _}  [CanonicallyOrderedCommSemiring α]  -- this holds more generally in a `CanonicallyOrderedAddMonoid` if we refactor `Odd` to use -- either `2 • t` or `t + t` instead of `2 * t`. [Nontrivial α]  {n : α}  (hn : Odd n) : 0 < n",
  "args":
  "{F α β R : Type _}  [CanonicallyOrderedCommSemiring α]  -- this holds more generally in a `CanonicallyOrderedAddMonoid` if we refactor `Odd` to use -- either `2 • t` or `t + t` instead of `2 * t`. [Nontrivial α]  {n : α}  (hn : Odd n)"},
 {"type": "Even (-2 : α)",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] : Even (-2 : α) := by simp only [even_neg]; sorry",
  "name": "even_neg_two",
  "kind": "theorem",
  "first-tactic": "simp only [even_neg]",
  "core-prompt":
  "{F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] : Even (-2 : α)",
  "args":
  "{F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp]"},
 {"type": "Odd (-a)",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (hp : Odd a) : Odd (-a) := by obtain ⟨k, hk⟩ := hp; sorry",
  "name": "Odd.neg",
  "kind": "theorem",
  "first-tactic": "obtain ⟨k, hk⟩ := hp",
  "core-prompt":
  "{F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (hp : Odd a) : Odd (-a)",
  "args":
  "{F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (hp : Odd a)"},
 {"type": "Odd (-1 : α)",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] : Odd (-1 : α) := by simp; sorry",
  "name": "odd_neg_one",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] : Odd (-1 : α)",
  "args":
  "{F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp]"},
 {"type": "Odd (a - b)",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Odd a)  (hb : Even b) : Odd (a - b) := by rw [sub_eq_add_neg]; sorry",
  "name": "Odd.sub_even",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Odd a)  (hb : Even b) : Odd (a - b)",
  "args":
  "{F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Odd a)  (hb : Even b)"},
 {"type": "Odd (a - b)",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Even a)  (hb : Odd b) : Odd (a - b) := by rw [sub_eq_add_neg]; sorry",
  "name": "Even.sub_odd",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Even a)  (hb : Odd b) : Odd (a - b)",
  "args":
  "{F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Even a)  (hb : Odd b)"},
 {"type": "Even (a - b)",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Odd a)  (hb : Odd b) : Even (a - b) := by rw [sub_eq_add_neg]; sorry",
  "name": "Odd.sub_odd",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Odd a)  (hb : Odd b) : Even (a - b)",
  "args":
  "{F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Odd a)  (hb : Odd b)"},
 {"type": "Odd (abs a) ↔ Odd a",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] [LinearOrder α] : Odd (abs a) ↔ Odd a := by cases' abs_choice a with h h; sorry",
  "name": "odd_abs",
  "kind": "theorem",
  "first-tactic": "cases' abs_choice a with h h",
  "core-prompt":
  "{F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] [LinearOrder α] : Odd (abs a) ↔ Odd a",
  "args":
  "{F α β R : Type _}  [Ring α]  {a b : α}  {n : ℕ}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] [LinearOrder α]"},
 {"type": "0 ≤ a ^ n",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (hn : Even n)  (a : R) : 0 ≤ a ^ n := by cases' hn with k hk; sorry",
  "name": "Even.pow_nonneg",
  "kind": "theorem",
  "first-tactic": "cases' hn with k hk",
  "core-prompt":
  "{F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (hn : Even n)  (a : R) : 0 ≤ a ^ n",
  "args":
  "{F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (hn : Even n)  (a : R)"},
 {"type": "0 < a ^ n",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (hn : Even n)  (ha : a ≠ 0) : 0 < a ^ n := by cases' hn with k hk; sorry",
  "name": "Even.pow_pos",
  "kind": "theorem",
  "first-tactic": "cases' hn with k hk",
  "core-prompt":
  "{F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (hn : Even n)  (ha : a ≠ 0) : 0 < a ^ n",
  "args":
  "{F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (hn : Even n)  (ha : a ≠ 0)"},
 {"type": "a ^ n ≤ 0",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (hn : Odd n)  (ha : a ≤ 0) : a ^ n ≤ 0 := by cases' hn with k hk; sorry",
  "name": "Odd.pow_nonpos",
  "kind": "theorem",
  "first-tactic": "cases' hn with k hk",
  "core-prompt":
  "{F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (hn : Odd n)  (ha : a ≤ 0) : a ^ n ≤ 0",
  "args":
  "{F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (hn : Odd n)  (ha : a ≤ 0)"},
 {"type": "a ^ n < 0",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (hn : Odd n)  (ha : a < 0) : a ^ n < 0 := by cases' hn with k hk; sorry",
  "name": "Odd.pow_neg",
  "kind": "theorem",
  "first-tactic": "cases' hn with k hk",
  "core-prompt":
  "{F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (hn : Odd n)  (ha : a < 0) : a ^ n < 0",
  "args":
  "{F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (hn : Odd n)  (ha : a < 0)"},
 {"type": "|a| ^ p = a ^ p",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} {p : ℕ}  (hp : Even p)  (a : R) : |a| ^ p = a ^ p := by rw [← abs_pow]; sorry",
  "name": "Even.pow_abs",
  "kind": "theorem",
  "first-tactic": "rw [← abs_pow]",
  "core-prompt":
  "{F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} {p : ℕ}  (hp : Even p)  (a : R) : |a| ^ p = a ^ p",
  "args":
  "{F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} {p : ℕ}  (hp : Even p)  (a : R)"},
 {"type": "StrictMono fun a : R => a ^ n",
  "tactic-prompt":
  "theorem {F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (hn : Odd n) : StrictMono fun a : R => a ^ n := by cases' hn with k hk; sorry",
  "name": "Odd.strictMono_pow",
  "kind": "theorem",
  "first-tactic": "cases' hn with k hk",
  "core-prompt":
  "{F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (hn : Odd n) : StrictMono fun a : R => a ^ n",
  "args":
  "{F α β R : Type _}  [LinearOrderedRing R]  {a : R}  {n : ℕ} (hn : Odd n)"},
 {"type": "0 = a * b ↔ a = 0 ∨ b = 0",
  "tactic-prompt":
  "theorem {G₀ : Type u}  {M₀ M₀' G₀' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero M₀]  [MulZeroClass M₀] [NoZeroDivisors M₀]  {a b : M₀} : 0 = a * b ↔ a = 0 ∨ b = 0 := by rw [eq_comm]; sorry",
  "name": "zero_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt":
  "{G₀ : Type u}  {M₀ M₀' G₀' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero M₀]  [MulZeroClass M₀] [NoZeroDivisors M₀]  {a b : M₀} : 0 = a * b ↔ a = 0 ∨ b = 0",
  "args":
  "{G₀ : Type u}  {M₀ M₀' G₀' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero M₀]  [MulZeroClass M₀] [NoZeroDivisors M₀]  {a b : M₀}"},
 {"type": "a * a = 0 ↔ a = 0",
  "tactic-prompt":
  "theorem {G₀ : Type u}  {M₀ M₀' G₀' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero M₀]  [MulZeroClass M₀] [NoZeroDivisors M₀]  {a b : M₀} : a * a = 0 ↔ a = 0 := by simp; sorry",
  "name": "mul_self_eq_zero",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{G₀ : Type u}  {M₀ M₀' G₀' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero M₀]  [MulZeroClass M₀] [NoZeroDivisors M₀]  {a b : M₀} : a * a = 0 ↔ a = 0",
  "args":
  "{G₀ : Type u}  {M₀ M₀' G₀' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero M₀]  [MulZeroClass M₀] [NoZeroDivisors M₀]  {a b : M₀}"},
 {"type": "0 = a * a ↔ a = 0",
  "tactic-prompt":
  "theorem {G₀ : Type u}  {M₀ M₀' G₀' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero M₀]  [MulZeroClass M₀] [NoZeroDivisors M₀]  {a b : M₀} : 0 = a * a ↔ a = 0 := by simp; sorry",
  "name": "zero_eq_mul_self",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{G₀ : Type u}  {M₀ M₀' G₀' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero M₀]  [MulZeroClass M₀] [NoZeroDivisors M₀]  {a b : M₀} : 0 = a * a ↔ a = 0",
  "args":
  "{G₀ : Type u}  {M₀ M₀' G₀' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero M₀]  [MulZeroClass M₀] [NoZeroDivisors M₀]  {a b : M₀}"},
 {"type": "SemiconjBy a 0 0",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MulZeroClass G₀]  (a : G₀) : SemiconjBy a 0 0 := by simp only [SemiconjBy]; sorry",
  "name": "zero_right",
  "kind": "theorem",
  "first-tactic": "simp only [SemiconjBy]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MulZeroClass G₀]  (a : G₀) : SemiconjBy a 0 0",
  "args": "{α M₀ G₀ M₀' G₀' F F' : Type _} [MulZeroClass G₀]  (a : G₀)"},
 {"type": "SemiconjBy 0 x y",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MulZeroClass G₀]  (x y : G₀) : SemiconjBy 0 x y := by simp only [SemiconjBy]; sorry",
  "name": "zero_left",
  "kind": "theorem",
  "first-tactic": "simp only [SemiconjBy]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MulZeroClass G₀]  (x y : G₀) : SemiconjBy 0 x y",
  "args": "{α M₀ G₀ M₀' G₀' F F' : Type _} [MulZeroClass G₀]  (x y : G₀)"},
 {"type": "SemiconjBy a x⁻¹ y⁻¹",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [GroupWithZero G₀]  {a x y x' y' : G₀} (h : SemiconjBy a x y) : SemiconjBy a x⁻¹ y⁻¹ := by by_cases ha : a = 0; sorry",
  "name": "inv_right₀",
  "kind": "theorem",
  "first-tactic": "by_cases ha : a = 0",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [GroupWithZero G₀]  {a x y x' y' : G₀} (h : SemiconjBy a x y) : SemiconjBy a x⁻¹ y⁻¹",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [GroupWithZero G₀]  {a x y x' y' : G₀} (h : SemiconjBy a x y)"},
 {"type": "SemiconjBy a (x / x') (y / y')",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [GroupWithZero G₀]  {a x y x' y' : G₀} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x / x') (y / y') := by rw [div_eq_mul_inv]; sorry",
  "name": "div_right",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [GroupWithZero G₀]  {a x y x' y' : G₀} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x / x') (y / y')",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [GroupWithZero G₀]  {a x y x' y' : G₀} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y')"},
 {"type": "DvdNotUnit a b",
  "tactic-prompt":
  "theorem {α : Type _}  [CommMonoidWithZero α] {a b : α}  (hd : a ∣ b)  (hnd : ¬b ∣ a) : DvdNotUnit a b := by constructor; sorry",
  "name": "dvdNotUnit_of_dvd_of_not_dvd",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α : Type _}  [CommMonoidWithZero α] {a b : α}  (hd : a ∣ b)  (hnd : ¬b ∣ a) : DvdNotUnit a b",
  "args":
  "{α : Type _}  [CommMonoidWithZero α] {a b : α}  (hd : a ∣ b)  (hnd : ¬b ∣ a)"},
 {"type": "p ≠ 0",
  "tactic-prompt":
  "theorem {α : Type _}  [MonoidWithZero α] {p q : α}  (h₁ : q ≠ 0)  (h₂ : p ∣ q) : p ≠ 0 := by rcases h₂ with ⟨u, rfl⟩; sorry",
  "name": "ne_zero_of_dvd_ne_zero",
  "kind": "theorem",
  "first-tactic": "rcases h₂ with ⟨u, rfl⟩",
  "core-prompt":
  "{α : Type _}  [MonoidWithZero α] {p q : α}  (h₁ : q ≠ 0)  (h₂ : p ∣ q) : p ≠ 0",
  "args":
  "{α : Type _}  [MonoidWithZero α] {p q : α}  (h₁ : q ≠ 0)  (h₂ : p ∣ q)"},
 {"type": "inverse (a * b) = inverse b * inverse a",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] {a b : M₀}  (h : Commute a b) : inverse (a * b) = inverse b * inverse a := by by_cases hab : IsUnit (a * b); sorry",
  "name": "mul_inverse_rev'",
  "kind": "theorem",
  "first-tactic": "by_cases hab : IsUnit (a * b)",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] {a b : M₀}  (h : Commute a b) : inverse (a * b) = inverse b * inverse a",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] {a b : M₀}  (h : Commute a b)"},
 {"type": "Commute (a / b) c",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀]  {a b c : G₀} (hac : Commute a c)  (hbc : Commute b c) : Commute (a / b) c := by rw [div_eq_mul_inv]; sorry",
  "name": "div_left",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀]  {a b c : G₀} (hac : Commute a c)  (hbc : Commute b c) : Commute (a / b) c",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀]  {a b c : G₀} (hac : Commute a c)  (hbc : Commute b c)"},
 {"type": "a = 0",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _}  [MulZeroOneClass M₀] (h : (0 : M₀) = 1)  (a : M₀) : a = 0 := by rw [← mul_one a]; sorry",
  "name": "eq_zero_of_zero_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [← mul_one a]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [MulZeroOneClass M₀] (h : (0 : M₀) = 1)  (a : M₀) : a = 0",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [MulZeroOneClass M₀] (h : (0 : M₀) = 1)  (a : M₀)"},
 {"type": "a⁻¹ = b",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c g h x : G₀} (h : a * b = 1) : a⁻¹ = b := by rw [← inv_mul_cancel_left₀ (left_ne_zero_of_mul_eq_one h) b]; sorry",
  "name": "inv_eq_of_mul",
  "kind": "theorem",
  "first-tactic":
  "rw [← inv_mul_cancel_left₀ (left_ne_zero_of_mul_eq_one h) b]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c g h x : G₀} (h : a * b = 1) : a⁻¹ = b",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c g h x : G₀} (h : a * b = 1)"},
 {"type": "0 / a = 0",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : 0 / a = 0 := by rw [div_eq_mul_inv]; sorry",
  "name": "zero_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : 0 / a = 0",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀)"},
 {"type": "a / 0 = 0",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : a / 0 = 0 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_zero",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : a / 0 = 0",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀)"},
 {"type": "a * a * a⁻¹ = a",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : a * a * a⁻¹ = a := by by_cases h : a = 0; sorry",
  "name": "mul_self_mul_inv",
  "kind": "theorem",
  "first-tactic": "by_cases h : a = 0",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : a * a * a⁻¹ = a",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀)"},
 {"type": "a * a⁻¹ * a = a",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : a * a⁻¹ * a = a := by by_cases h : a = 0; sorry",
  "name": "mul_inv_mul_self",
  "kind": "theorem",
  "first-tactic": "by_cases h : a = 0",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : a * a⁻¹ * a = a",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀)"},
 {"type": "a⁻¹ * a * a = a",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : a⁻¹ * a * a = a := by by_cases h : a = 0; sorry",
  "name": "inv_mul_mul_self",
  "kind": "theorem",
  "first-tactic": "by_cases h : a = 0",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : a⁻¹ * a * a = a",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀)"},
 {"type": "a * a / a = a",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : a * a / a = a := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_self_div_self",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : a * a / a = a",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀)"},
 {"type": "a / a * a = a",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : a / a * a = a := by rw [div_eq_mul_inv]; sorry",
  "name": "div_self_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : a / a * a = a",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀)"},
 {"type": "1 / a ≠ 0",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} {a : G₀}  (h : a ≠ 0) : 1 / a ≠ 0 := by simpa only [one_div] using inv_ne_zero h; sorry",
  "name": "one_div_ne_zero",
  "kind": "theorem",
  "first-tactic": "simpa only [one_div] using inv_ne_zero h",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} {a : G₀}  (h : a ≠ 0) : 1 / a ≠ 0",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} {a : G₀}  (h : a ≠ 0)"},
 {"type": "a⁻¹ = 0 ↔ a = 0",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} {a : G₀} : a⁻¹ = 0 ↔ a = 0 := by rw [inv_eq_iff_inv_eq]; sorry",
  "name": "inv_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_iff_inv_eq]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} {a : G₀} : a⁻¹ = 0 ↔ a = 0",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} {a : G₀}"},
 {"type": "a / (a / a) = a",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : a / (a / a) = a := by rw [div_div_eq_mul_div]; sorry",
  "name": "div_div_self",
  "kind": "theorem",
  "first-tactic": "rw [div_div_eq_mul_div]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : a / (a / a) = a",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀)"},
 {"type": "a / c * b = a * b / c",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _}  [CommGroupWithZero G₀]  {a b c d : G₀} (a b c : G₀) : a / c * b = a * b / c := by simp_rw [div_eq_mul_inv]; sorry",
  "name": "div_mul_eq_mul_div₀",
  "kind": "theorem",
  "first-tactic": "simp_rw [div_eq_mul_inv]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [CommGroupWithZero G₀]  {a b c d : G₀} (a b c : G₀) : a / c * b = a * b / c",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _}  [CommGroupWithZero G₀]  {a b c d : G₀} (a b c : G₀)"},
 {"type": "inverse (u : M₀) = (u⁻¹ : M₀ˣ)",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (u : M₀ˣ) : inverse (u : M₀) = (u⁻¹ : M₀ˣ) := by simp only [Units.isUnit]; sorry",
  "name": "inverse_unit",
  "kind": "theorem",
  "first-tactic": "simp only [Units.isUnit]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (u : M₀ˣ) : inverse (u : M₀) = (u⁻¹ : M₀ˣ)",
  "args": "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (u : M₀ˣ)"},
 {"type": "x * inverse x = 1",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x : M₀)  (h : IsUnit x) : x * inverse x = 1 := by rcases h with ⟨u, rfl⟩; sorry",
  "name": "mul_inverse_cancel",
  "kind": "theorem",
  "first-tactic": "rcases h with ⟨u, rfl⟩",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x : M₀)  (h : IsUnit x) : x * inverse x = 1",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x : M₀)  (h : IsUnit x)"},
 {"type": "inverse x * x = 1",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x : M₀)  (h : IsUnit x) : inverse x * x = 1 := by rcases h with ⟨u, rfl⟩; sorry",
  "name": "inverse_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rcases h with ⟨u, rfl⟩",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x : M₀)  (h : IsUnit x) : inverse x * x = 1",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x : M₀)  (h : IsUnit x)"},
 {"type": "y * x * inverse x = y",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x y : M₀)  (h : IsUnit x) : y * x * inverse x = y := by rw [mul_assoc]; sorry",
  "name": "mul_inverse_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x y : M₀)  (h : IsUnit x) : y * x * inverse x = y",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x y : M₀)  (h : IsUnit x)"},
 {"type": "y * inverse x * x = y",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x y : M₀)  (h : IsUnit x) : y * inverse x * x = y := by rw [mul_assoc]; sorry",
  "name": "inverse_mul_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x y : M₀)  (h : IsUnit x) : y * inverse x * x = y",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x y : M₀)  (h : IsUnit x)"},
 {"type": "x * (inverse x * y) = y",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x y : M₀)  (h : IsUnit x) : x * (inverse x * y) = y := by rw [← mul_assoc]; sorry",
  "name": "mul_inverse_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x y : M₀)  (h : IsUnit x) : x * (inverse x * y) = y",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x y : M₀)  (h : IsUnit x)"},
 {"type": "inverse x * (x * y) = y",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x y : M₀)  (h : IsUnit x) : inverse x * (x * y) = y := by rw [← mul_assoc]; sorry",
  "name": "inverse_mul_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x y : M₀)  (h : IsUnit x) : inverse x * (x * y) = y",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] (x y : M₀)  (h : IsUnit x)"},
 {"type": "inverse (0 : M₀) = 0",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] : inverse (0 : M₀) = 0 := by nontriviality; sorry",
  "name": "inverse_zero",
  "kind": "theorem",
  "first-tactic": "nontriviality",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] : inverse (0 : M₀) = 0",
  "args": "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]"},
 {"type": "(∃ u : G₀ˣ, ↑u = x) ↔ x ≠ 0",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀] {a b : G₀} {x : G₀} : (∃ u : G₀ˣ, ↑u = x) ↔ x ≠ 0 := by simp [exists0]; sorry",
  "name": "exists_iff_ne_zero",
  "kind": "theorem",
  "first-tactic": "simp [exists0]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀] {a b : G₀} {x : G₀} : (∃ u : G₀ˣ, ↑u = x) ↔ x ≠ 0",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀] {a b : G₀} {x : G₀}"},
 {"type": "a = 0 ∨ ∃ u : G₀ˣ, a = u",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀] {a b : G₀} (a : G₀) : a = 0 ∨ ∃ u : G₀ˣ, a = u := by by_cases h : a = 0; sorry",
  "name": "_root_.GroupWithZero.eq_zero_or_unit",
  "kind": "theorem",
  "first-tactic": "by_cases h : a = 0",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀] {a b : G₀} (a : G₀) : a = 0 ∨ ∃ u : G₀ˣ, a = u",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀] {a b : G₀} (a : G₀)"},
 {"type": "a / b ≠ 0",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀] {a b : G₀}  [GroupWithZero G₀]  {a b c : G₀} (ha : a ≠ 0)  (hb : b ≠ 0) : a / b ≠ 0 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_ne_zero",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀] {a b : G₀}  [GroupWithZero G₀]  {a b c : G₀} (ha : a ≠ 0)  (hb : b ≠ 0) : a / b ≠ 0",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀] {a b : G₀}  [GroupWithZero G₀]  {a b c : G₀} (ha : a ≠ 0)  (hb : b ≠ 0)"},
 {"type": "a / b = 0 ↔ a = 0 ∨ b = 0",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀] {a b : G₀}  [GroupWithZero G₀]  {a b c : G₀} : a / b = 0 ↔ a = 0 ∨ b = 0 := by simp [div_eq_mul_inv]; sorry",
  "name": "div_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "simp [div_eq_mul_inv]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀] {a b : G₀}  [GroupWithZero G₀]  {a b c : G₀} : a / b = 0 ↔ a = 0 ∨ b = 0",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀] {a b : G₀}  [GroupWithZero G₀]  {a b c : G₀}"},
 {"type": "Ring.inverse a = a⁻¹",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀] {a b : G₀}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : Ring.inverse a = a⁻¹ := by obtain rfl | ha := eq_or_ne a 0; sorry",
  "name": "Ring.inverse_eq_inv",
  "kind": "theorem",
  "first-tactic": "obtain rfl | ha := eq_or_ne a 0",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀] {a b : G₀}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀) : Ring.inverse a = a⁻¹",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀] [GroupWithZero G₀] {a b : G₀}  [GroupWithZero G₀]  {a b c : G₀} (a : G₀)"},
 {"type": "a / c / (b / c) = a / b",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [GroupWithZero G₀]  {a b c : G₀} (a : G₀)  (hc : c ≠ 0) : a / c / (b / c) = a / b := by rw [div_div_eq_mul_div]; sorry",
  "name": "div_div_div_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [div_div_eq_mul_div]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [GroupWithZero G₀]  {a b c : G₀} (a : G₀)  (hc : c ≠ 0) : a / c / (b / c) = a / b",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [GroupWithZero G₀]  {a b c : G₀} (a : G₀)  (hc : c ≠ 0)"},
 {"type": "a / c * (c / b) = a / b",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [GroupWithZero G₀]  {a b c : G₀} (a : G₀)  (hc : c ≠ 0) : a / c * (c / b) = a / b := by rw [← mul_div_assoc]; sorry",
  "name": "div_mul_div_cancel",
  "kind": "theorem",
  "first-tactic": "rw [← mul_div_assoc]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [GroupWithZero G₀]  {a b c : G₀} (a : G₀)  (hc : c ≠ 0) : a / c * (c / b) = a / b",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [GroupWithZero G₀]  {a b c : G₀} (a : G₀)  (hc : c ≠ 0)"},
 {"type": "a * b / a = b",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀} {a b : G₀}  (h : a = 0 → b = 0) : a * b / a = b := by rw [mul_comm]; sorry",
  "name": "mul_div_cancel_left_of_imp",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀} {a b : G₀}  (h : a = 0 → b = 0) : a * b / a = b",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀} {a b : G₀}  (h : a = 0 → b = 0)"},
 {"type": "b * (a / b) = a",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀} {a b : G₀}  (h : b = 0 → a = 0) : b * (a / b) = a := by rw [mul_comm]; sorry",
  "name": "mul_div_cancel_of_imp'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀} {a b : G₀}  (h : b = 0 → a = 0) : b * (a / b) = a",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀} {a b : G₀}  (h : b = 0 → a = 0)"},
 {"type": "a * d = c * b",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀} (a : G₀)  {b : G₀}  (c : G₀)  {d : G₀}  (hb : b ≠ 0)  (hd : d ≠ 0)      (h : a / b = c / d) : a * d = c * b := by rw [← mul_one a]; sorry",
  "name": "mul_eq_mul_of_div_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [← mul_one a]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀} (a : G₀)  {b : G₀}  (c : G₀)  {d : G₀}  (hb : b ≠ 0)  (hd : d ≠ 0)      (h : a / b = c / d) : a * d = c * b",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀} (a : G₀)  {b : G₀}  (c : G₀)  {d : G₀}  (hb : b ≠ 0)  (hd : d ≠ 0)      (h : a / b = c / d)"},
 {"type": "1 / (a * b) * a = 1 / b",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀} (b : G₀)  (h : a ≠ 0) : 1 / (a * b) * a = 1 / b := by rw [div_mul_eq_mul_div]; sorry",
  "name": "div_helper",
  "kind": "theorem",
  "first-tactic": "rw [div_mul_eq_mul_div]",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀} (b : G₀)  (h : a ≠ 0) : 1 / (a * b) * a = 1 / b",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀} (b : G₀)  (h : a ≠ 0)"},
 {"type": "f a⁻¹ = g a⁻¹",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀}  [GroupWithZero G₀]  [Nontrivial M₀]  [MonoidWithZero M₀']  [MonoidWithZeroHomClass F G₀ M₀]    [MonoidWithZeroHomClass F' G₀ M₀']  (f : F)  {a : G₀} (f g : F')  (h : f a = g a) : f a⁻¹ = g a⁻¹ := by rcases eq_or_ne a 0 with (rfl | ha); sorry",
  "name": "eq_on_inv₀",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne a 0 with (rfl | ha)",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀}  [GroupWithZero G₀]  [Nontrivial M₀]  [MonoidWithZero M₀']  [MonoidWithZeroHomClass F G₀ M₀]    [MonoidWithZeroHomClass F' G₀ M₀']  (f : F)  {a : G₀} (f g : F')  (h : f a = g a) : f a⁻¹ = g a⁻¹",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀}  [GroupWithZero G₀]  [Nontrivial M₀]  [MonoidWithZero M₀']  [MonoidWithZeroHomClass F G₀ M₀]    [MonoidWithZeroHomClass F' G₀ M₀']  (f : F)  {a : G₀} (f g : F')  (h : f a = g a)"},
 {"type": "f a⁻¹ = (f a)⁻¹",
  "tactic-prompt":
  "theorem {α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀}  [GroupWithZero G₀]  [GroupWithZero G₀']  [MonoidWithZeroHomClass F G₀ G₀']  (f : F)  (a b : G₀) : f a⁻¹ = (f a)⁻¹ := by by_cases h : a = 0; sorry",
  "name": "map_inv₀",
  "kind": "theorem",
  "first-tactic": "by_cases h : a = 0",
  "core-prompt":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀}  [GroupWithZero G₀]  [GroupWithZero G₀']  [MonoidWithZeroHomClass F G₀ G₀']  (f : F)  (a b : G₀) : f a⁻¹ = (f a)⁻¹",
  "args":
  "{α M₀ G₀ M₀' G₀' F F' : Type _} [MonoidWithZero M₀]  [CommGroupWithZero G₀]  {a b c d : G₀}  [GroupWithZero G₀]  [GroupWithZero G₀']  [MonoidWithZeroHomClass F G₀ G₀']  (f : F)  (a b : G₀)"},
 {"type": "a ∣ c * b",
  "tactic-prompt":
  "theorem {α : Type _}  [CommSemigroup α]  {a b c : α} (h : a ∣ b)  (c : α) : a ∣ c * b := by rw [mul_comm]; sorry",
  "name": "dvd_mul_of_dvd_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α : Type _}  [CommSemigroup α]  {a b c : α} (h : a ∣ b)  (c : α) : a ∣ c * b",
  "args": "{α : Type _}  [CommSemigroup α]  {a b c : α} (h : a ∣ b)  (c : α)"},
 {"type": "a ∣ u * b ↔ a ∣ b",
  "tactic-prompt":
  "theorem {α : Type _}  [CommMonoid α]  {a b : α}  {u : αˣ} : a ∣ u * b ↔ a ∣ b := by rw [mul_comm]; sorry",
  "name": "dvd_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α : Type _}  [CommMonoid α]  {a b : α}  {u : αˣ} : a ∣ u * b ↔ a ∣ b",
  "args": "{α : Type _}  [CommMonoid α]  {a b : α}  {u : αˣ}"},
 {"type": "↑u * a ∣ b ↔ a ∣ b",
  "tactic-prompt":
  "theorem {α : Type _}  [CommMonoid α]  {a b : α}  {u : αˣ} : ↑u * a ∣ b ↔ a ∣ b := by rw [mul_comm]; sorry",
  "name": "mul_left_dvd",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α : Type _}  [CommMonoid α]  {a b : α}  {u : αˣ} : ↑u * a ∣ b ↔ a ∣ b",
  "args": "{α : Type _}  [CommMonoid α]  {a b : α}  {u : αˣ}"},
 {"type": "u ∣ a",
  "tactic-prompt":
  "theorem {α : Type _}  [Monoid α]  {a b u : α}  (hu : IsUnit u) : u ∣ a := by rcases hu with ⟨u, rfl⟩; sorry",
  "name": "dvd",
  "kind": "theorem",
  "first-tactic": "rcases hu with ⟨u, rfl⟩",
  "core-prompt":
  "{α : Type _}  [Monoid α]  {a b u : α}  (hu : IsUnit u) : u ∣ a",
  "args": "{α : Type _}  [Monoid α]  {a b u : α}  (hu : IsUnit u)"},
 {"type": "a ∣ b * u ↔ a ∣ b",
  "tactic-prompt":
  "theorem {α : Type _}  [Monoid α]  {a b u : α}  (hu : IsUnit u) : a ∣ b * u ↔ a ∣ b := by rcases hu with ⟨u, rfl⟩; sorry",
  "name": "dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "rcases hu with ⟨u, rfl⟩",
  "core-prompt":
  "{α : Type _}  [Monoid α]  {a b u : α}  (hu : IsUnit u) : a ∣ b * u ↔ a ∣ b",
  "args": "{α : Type _}  [Monoid α]  {a b u : α}  (hu : IsUnit u)"},
 {"type": "a * u ∣ b ↔ a ∣ b",
  "tactic-prompt":
  "theorem {α : Type _}  [Monoid α]  {a b u : α}  (hu : IsUnit u) : a * u ∣ b ↔ a ∣ b := by rcases hu with ⟨u, rfl⟩; sorry",
  "name": "mul_right_dvd",
  "kind": "theorem",
  "first-tactic": "rcases hu with ⟨u, rfl⟩",
  "core-prompt":
  "{α : Type _}  [Monoid α]  {a b u : α}  (hu : IsUnit u) : a * u ∣ b ↔ a ∣ b",
  "args": "{α : Type _}  [Monoid α]  {a b u : α}  (hu : IsUnit u)"},
 {"type": "a ∣ u * b ↔ a ∣ b",
  "tactic-prompt":
  "theorem {α : Type _}  [CommMonoid α]  (a b u : α)  (hu : IsUnit u) : a ∣ u * b ↔ a ∣ b := by rcases hu with ⟨u, rfl⟩; sorry",
  "name": "dvd_mul_left",
  "kind": "theorem",
  "first-tactic": "rcases hu with ⟨u, rfl⟩",
  "core-prompt":
  "{α : Type _}  [CommMonoid α]  (a b u : α)  (hu : IsUnit u) : a ∣ u * b ↔ a ∣ b",
  "args": "{α : Type _}  [CommMonoid α]  (a b u : α)  (hu : IsUnit u)"},
 {"type": "u * a ∣ b ↔ a ∣ b",
  "tactic-prompt":
  "theorem {α : Type _}  [CommMonoid α]  (a b u : α)  (hu : IsUnit u) : u * a ∣ b ↔ a ∣ b := by rcases hu with ⟨u, rfl⟩; sorry",
  "name": "mul_left_dvd",
  "kind": "theorem",
  "first-tactic": "rcases hu with ⟨u, rfl⟩",
  "core-prompt":
  "{α : Type _}  [CommMonoid α]  (a b u : α)  (hu : IsUnit u) : u * a ∣ b ↔ a ∣ b",
  "args": "{α : Type _}  [CommMonoid α]  (a b u : α)  (hu : IsUnit u)"},
 {"type": "f <$> x <*> g <$> y = (flip (· ∘ ·) g ∘ f) <$> x <*> y",
  "tactic-prompt":
  "theorem {F : Type u → Type v} [Applicative F]  [LawfulApplicative F] {α β γ σ : Type u} (f : α → β → γ)  (g : σ → β)  (x : F α)  (y : F σ) : f <$> x <*> g <$> y = (flip (· ∘ ·) g ∘ f) <$> x <*> y := by simp [flip]; sorry",
  "name": "Applicative.map_seq_map",
  "kind": "theorem",
  "first-tactic": "simp [flip]",
  "core-prompt":
  "{F : Type u → Type v} [Applicative F]  [LawfulApplicative F] {α β γ σ : Type u} (f : α → β → γ)  (g : σ → β)  (x : F α)  (y : F σ) : f <$> x <*> g <$> y = (flip (· ∘ ·) g ∘ f) <$> x <*> y",
  "args":
  "{F : Type u → Type v} [Applicative F]  [LawfulApplicative F] {α β γ σ : Type u} (f : α → β → γ)  (g : σ → β)  (x : F α)  (y : F σ)"},
 {"type": "(· <*> ·) (pure f : F (α → β)) = (· <$> ·) f",
  "tactic-prompt":
  "theorem {F : Type u → Type v} [Applicative F]  [LawfulApplicative F] {α β γ σ : Type u} (f : α → β) : (· <*> ·) (pure f : F (α → β)) = (· <$> ·) f := by ext; sorry",
  "name": "Applicative.pure_seq_eq_map'",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F : Type u → Type v} [Applicative F]  [LawfulApplicative F] {α β γ σ : Type u} (f : α → β) : (· <*> ·) (pure f : F (α → β)) = (· <$> ·) f",
  "args":
  "{F : Type u → Type v} [Applicative F]  [LawfulApplicative F] {α β γ σ : Type u} (f : α → β)"},
 {"type": "CommApplicative Id",
  "tactic-prompt":
  "instance {F : Type u → Type v} [Applicative F]  [LawfulApplicative F] {α β γ σ : Type u} : CommApplicative Id := by refine' { .. }; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "refine' { .. }",
  "core-prompt":
  "{F : Type u → Type v} [Applicative F]  [LawfulApplicative F] {α β γ σ : Type u} : CommApplicative Id",
  "args":
  "{F : Type u → Type v} [Applicative F]  [LawfulApplicative F] {α β γ σ : Type u}"},
 {"type": "CommApplicative (Comp f g)",
  "tactic-prompt":
  "instance {F : Type u → Type v} [Applicative F]  [LawfulApplicative F] {α β γ σ : Type u} {F : Type u → Type w}  {G : Type v → Type u} [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] {α β γ : Type v} {f : Type u → Type w}  {g : Type v → Type u}  [Applicative f]  [Applicative g]      [CommApplicative f]  [CommApplicative g] : CommApplicative (Comp f g) := by refine' { @instLawfulApplicativeCompInstApplicativeComp f g _ _ _ _ with .. }; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic":
  "refine' { @instLawfulApplicativeCompInstApplicativeComp f g _ _ _ _ with .. }",
  "core-prompt":
  "{F : Type u → Type v} [Applicative F]  [LawfulApplicative F] {α β γ σ : Type u} {F : Type u → Type w}  {G : Type v → Type u} [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] {α β γ : Type v} {f : Type u → Type w}  {g : Type v → Type u}  [Applicative f]  [Applicative g]      [CommApplicative f]  [CommApplicative g] : CommApplicative (Comp f g)",
  "args":
  "{F : Type u → Type v} [Applicative F]  [LawfulApplicative F] {α β γ σ : Type u} {F : Type u → Type w}  {G : Type v → Type u} [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] {α β γ : Type v} {f : Type u → Type w}  {g : Type v → Type u}  [Applicative f]  [Applicative g]      [CommApplicative f]  [CommApplicative g]"},
 {"type": "x <*> f <$> y = (· ∘ f) <$> x <*> y",
  "tactic-prompt":
  "theorem {α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F] (x : F (α → β))  (f : γ → α)  (y : F γ) : x <*> f <$> y = (· ∘ f) <$> x <*> y := by simp [← pure_seq]; sorry",
  "name": "seq_map_assoc",
  "kind": "theorem",
  "first-tactic": "simp [← pure_seq]",
  "core-prompt":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F] (x : F (α → β))  (f : γ → α)  (y : F γ) : x <*> f <$> y = (· ∘ f) <$> x <*> y",
  "args":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F] (x : F (α → β))  (f : γ → α)  (y : F γ)"},
 {"type": "f <$> (x <*> y) = (f ∘ ·) <$> x <*> y",
  "tactic-prompt":
  "theorem {α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F] (f : β → γ)  (x : F (α → β))  (y : F α) : f <$> (x <*> y) = (f ∘ ·) <$> x <*> y := by simp only [← pure_seq]; sorry",
  "name": "map_seq",
  "kind": "theorem",
  "first-tactic": "simp only [← pure_seq]",
  "core-prompt":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F] (f : β → γ)  (x : F (α → β))  (y : F α) : f <$> (x <*> y) = (f ∘ ·) <$> x <*> y",
  "args":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F] (f : β → γ)  (x : F (α → β))  (y : F α)"},
 {"type": "f <$> (x >>= g) = x >>= fun a => f <$> g a",
  "tactic-prompt":
  "theorem {α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u → Type v}  [Monad m]  [LawfulMonad m] (x : m α)  {g : α → m β}  {f : β → γ} : f <$> (x >>= g) = x >>= fun a => f <$> g a := by rw [← bind_pure_comp]; sorry",
  "name": "map_bind",
  "kind": "theorem",
  "first-tactic": "rw [← bind_pure_comp]",
  "core-prompt":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u → Type v}  [Monad m]  [LawfulMonad m] (x : m α)  {g : α → m β}  {f : β → γ} : f <$> (x >>= g) = x >>= fun a => f <$> g a",
  "args":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u → Type v}  [Monad m]  [LawfulMonad m] (x : m α)  {g : α → m β}  {f : β → γ}"},
 {"type": "joinM (Functor.map f <$> a) = f <$> joinM a",
  "tactic-prompt":
  "theorem {α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u → Type u}  [Monad m]  [LawfulMonad m] {α β : Type u}  (f : α → β)  (a : m (m α)) : joinM (Functor.map f <$> a) = f <$> joinM a := by simp only [joinM]; sorry",
  "name": "joinM_map_map",
  "kind": "theorem",
  "first-tactic": "simp only [joinM]",
  "core-prompt":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u → Type u}  [Monad m]  [LawfulMonad m] {α β : Type u}  (f : α → β)  (a : m (m α)) : joinM (Functor.map f <$> a) = f <$> joinM a",
  "args":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u → Type u}  [Monad m]  [LawfulMonad m] {α β : Type u}  (f : α → β)  (a : m (m α))"},
 {"type": "joinM (joinM <$> a) = joinM (joinM a)",
  "tactic-prompt":
  "theorem {α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u → Type u}  [Monad m]  [LawfulMonad m] {α : Type u}  (a : m (m (m α))) : joinM (joinM <$> a) = joinM (joinM a) := by simp only [joinM]; sorry",
  "name": "joinM_map_joinM",
  "kind": "theorem",
  "first-tactic": "simp only [joinM]",
  "core-prompt":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u → Type u}  [Monad m]  [LawfulMonad m] {α : Type u}  (a : m (m (m α))) : joinM (joinM <$> a) = joinM (joinM a)",
  "args":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u → Type u}  [Monad m]  [LawfulMonad m] {α : Type u}  (a : m (m (m α)))"},
 {"type": "joinM (pure <$> a) = a",
  "tactic-prompt":
  "theorem {α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u → Type u}  [Monad m]  [LawfulMonad m] {α : Type u}  (a : m α) : joinM (pure <$> a) = a := by simp only [joinM]; sorry",
  "name": "joinM_map_pure",
  "kind": "theorem",
  "first-tactic": "simp only [joinM]",
  "core-prompt":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u → Type u}  [Monad m]  [LawfulMonad m] {α : Type u}  (a : m α) : joinM (pure <$> a) = a",
  "args":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u → Type u}  [Monad m]  [LawfulMonad m] {α : Type u}  (a : m α)"},
 {"type": "@guard F _ True h = pure ()",
  "tactic-prompt":
  "theorem {α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {F : Type → Type v}  [Alternative F]  -- [todo] add notation for `Functor.mapConst` and port `functor.map_const_rev` {h : Decidable True} : @guard F _ True h = pure () := by simp [guard]; sorry",
  "name": "guard_true",
  "kind": "theorem",
  "first-tactic": "simp [guard]",
  "core-prompt":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {F : Type → Type v}  [Alternative F]  -- [todo] add notation for `Functor.mapConst` and port `functor.map_const_rev` {h : Decidable True} : @guard F _ True h = pure ()",
  "args":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {F : Type → Type v}  [Alternative F]  -- [todo] add notation for `Functor.mapConst` and port `functor.map_const_rev` {h : Decidable True}"},
 {"type": "@guard F _ False h = failure",
  "tactic-prompt":
  "theorem {α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {F : Type → Type v}  [Alternative F]  -- [todo] add notation for `Functor.mapConst` and port `functor.map_const_rev` {h : Decidable False} : @guard F _ False h = failure := by simp [guard]; sorry",
  "name": "guard_false",
  "kind": "theorem",
  "first-tactic": "simp [guard]",
  "core-prompt":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {F : Type → Type v}  [Alternative F]  -- [todo] add notation for `Functor.mapConst` and port `functor.map_const_rev` {h : Decidable False} : @guard F _ False h = failure",
  "args":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F]  {F : Type → Type v}  [Alternative F]  -- [todo] add notation for `Functor.mapConst` and port `functor.map_const_rev` {h : Decidable False}"},
 {"type": "LawfulFunctor (Sum.{v, u} e)",
  "tactic-prompt":
  "instance {α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F] {e : Type v} : LawfulFunctor (Sum.{v, u} e) := by refine' { .. }; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "refine' { .. }",
  "core-prompt":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F] {e : Type v} : LawfulFunctor (Sum.{v, u} e)",
  "args":
  "{α β γ : Type u}  {F : Type u → Type v}  [Applicative F] [LawfulApplicative F] {e : Type v}"},
 {"type": "(· <$> ·) id = (id : F α → F α)",
  "tactic-prompt":
  "theorem {F : Type u → Type v} {α β γ : Type u} [Functor F]  [LawfulFunctor F] : (· <$> ·) id = (id : F α → F α) := by apply funext; sorry",
  "name": "Functor.map_id",
  "kind": "theorem",
  "first-tactic": "apply funext",
  "core-prompt":
  "{F : Type u → Type v} {α β γ : Type u} [Functor F]  [LawfulFunctor F] : (· <$> ·) id = (id : F α → F α)",
  "args":
  "{F : Type u → Type v} {α β γ : Type u} [Functor F]  [LawfulFunctor F]"},
 {"type": "Equiv.map eqv id x = x",
  "tactic-prompt":
  "theorem {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t] {α : Type u}  (x : t' α) : Equiv.map eqv id x = x := by simp [Equiv.map]; sorry",
  "name": "id_map",
  "kind": "theorem",
  "first-tactic": "simp [Equiv.map]",
  "core-prompt":
  "{t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t] {α : Type u}  (x : t' α) : Equiv.map eqv id x = x",
  "args":
  "{t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t] {α : Type u}  (x : t' α)"},
 {"type": "Equiv.map eqv (h ∘ g) x = Equiv.map eqv h (Equiv.map eqv g x)",
  "tactic-prompt":
  "theorem {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t] {α β γ : Type u}  (g : α → β)  (h : β → γ)  (x : t' α) : Equiv.map eqv (h ∘ g) x = Equiv.map eqv h (Equiv.map eqv g x) := by simp [Equiv.map]; sorry",
  "name": "comp_map",
  "kind": "theorem",
  "first-tactic": "simp [Equiv.map]",
  "core-prompt":
  "{t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t] {α β γ : Type u}  (g : α → β)  (h : β → γ)  (x : t' α) : Equiv.map eqv (h ∘ g) x = Equiv.map eqv h (Equiv.map eqv g x)",
  "args":
  "{t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t] {α β γ : Type u}  (g : α → β)  (h : β → γ)  (x : t' α)"},
 {"type": "Equiv.traverse eqv (pure : α → Id α) x = x",
  "tactic-prompt":
  "theorem {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t]  {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u → Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (η : ApplicativeTransformation F G) {α β γ : Type u} (x : t' α) : Equiv.traverse eqv (pure : α → Id α) x = x := by simp [Equiv.traverse]; sorry",
  "name": "id_traverse",
  "kind": "theorem",
  "first-tactic": "simp [Equiv.traverse]",
  "core-prompt":
  "{t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t]  {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u → Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (η : ApplicativeTransformation F G) {α β γ : Type u} (x : t' α) : Equiv.traverse eqv (pure : α → Id α) x = x",
  "args":
  "{t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t]  {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u → Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (η : ApplicativeTransformation F G) {α β γ : Type u} (x : t' α)"},
 {"type":
  "Equiv.traverse eqv ((pure : β → Id β) ∘ f) x = pure (Equiv.map eqv f x)",
  "tactic-prompt":
  "theorem {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t]  {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u → Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (η : ApplicativeTransformation F G) {α β γ : Type u} (f : α → β)  (x : t' α) : Equiv.traverse eqv ((pure : β → Id β) ∘ f) x = pure (Equiv.map eqv f x) := by simp [Equiv.traverse]; sorry",
  "name": "traverse_eq_map_id",
  "kind": "theorem",
  "first-tactic": "simp [Equiv.traverse]",
  "core-prompt":
  "{t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t]  {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u → Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (η : ApplicativeTransformation F G) {α β γ : Type u} (f : α → β)  (x : t' α) : Equiv.traverse eqv ((pure : β → Id β) ∘ f) x = pure (Equiv.map eqv f x)",
  "args":
  "{t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t]  {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u → Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (η : ApplicativeTransformation F G) {α β γ : Type u} (f : α → β)  (x : t' α)"},
 {"type":
  "Equiv.traverse eqv (Comp.mk ∘ Functor.map f ∘ g) x =\n      Comp.mk (Equiv.traverse eqv f <$> Equiv.traverse eqv g x)",
  "tactic-prompt":
  "theorem {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t]  {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u → Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (η : ApplicativeTransformation F G) {α β γ : Type u} (f : β → F γ)  (g : α → G β)  (x : t' α) : Equiv.traverse eqv (Comp.mk ∘ Functor.map f ∘ g) x =\n      Comp.mk (Equiv.traverse eqv f <$> Equiv.traverse eqv g x) := by simp [Equiv.traverse]; sorry",
  "name": "comp_traverse",
  "kind": "theorem",
  "first-tactic": "simp [Equiv.traverse]",
  "core-prompt":
  "{t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t]  {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u → Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (η : ApplicativeTransformation F G) {α β γ : Type u} (f : β → F γ)  (g : α → G β)  (x : t' α) : Equiv.traverse eqv (Comp.mk ∘ Functor.map f ∘ g) x =\n      Comp.mk (Equiv.traverse eqv f <$> Equiv.traverse eqv g x)",
  "args":
  "{t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t]  {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u → Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (η : ApplicativeTransformation F G) {α β γ : Type u} (f : β → F γ)  (g : α → G β)  (x : t' α)"},
 {"type": "η (Equiv.traverse eqv f x) = Equiv.traverse eqv (@η _ ∘ f) x",
  "tactic-prompt":
  "theorem {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t]  {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u → Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (η : ApplicativeTransformation F G) {α β γ : Type u} (f : α → F β)  (x : t' α) : η (Equiv.traverse eqv f x) = Equiv.traverse eqv (@η _ ∘ f) x := by simp only [Equiv.traverse]; sorry",
  "name": "naturality",
  "kind": "theorem",
  "first-tactic": "simp only [Equiv.traverse]",
  "core-prompt":
  "{t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t]  {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u → Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (η : ApplicativeTransformation F G) {α β γ : Type u} (f : α → F β)  (x : t' α) : η (Equiv.traverse eqv f x) = Equiv.traverse eqv (@η _ ∘ f) x",
  "args":
  "{t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t]  {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u → Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (η : ApplicativeTransformation F G) {α β γ : Type u} (f : α → F β)  (x : t' α)"},
 {"type": "IsLawfulTraversable t'",
  "tactic-prompt":
  "def {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t]  {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u → Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (η : ApplicativeTransformation F G) {α β γ : Type u}  [Traversable t']      (h₀ : ∀ {α β} (f : α → β), map f = Equiv.map eqv f)      (h₁ : ∀ {α β} (f : β), mapConst f = (Equiv.map eqv ∘ Function.const α) f)      (h₂ :       ∀ {F : Type u → Type u} [Applicative F],         ∀ [LawfulApplicative F] {α β} (f : α → F β), traverse f = Equiv.traverse eqv f) : IsLawfulTraversable t' := by refine' { toLawfulFunctor := Equiv.lawfulFunctor' eqv @h₀ @h₁.. }; sorry",
  "name": "isLawfulTraversable'",
  "kind": "def",
  "first-tactic":
  "refine' { toLawfulFunctor := Equiv.lawfulFunctor' eqv @h₀ @h₁.. }",
  "core-prompt":
  "{t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t]  {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u → Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (η : ApplicativeTransformation F G) {α β γ : Type u}  [Traversable t']      (h₀ : ∀ {α β} (f : α → β), map f = Equiv.map eqv f)      (h₁ : ∀ {α β} (f : β), mapConst f = (Equiv.map eqv ∘ Function.const α) f)      (h₂ :       ∀ {F : Type u → Type u} [Applicative F],         ∀ [LawfulApplicative F] {α β} (f : α → F β), traverse f = Equiv.traverse eqv f) : IsLawfulTraversable t'",
  "args":
  "{t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α) [Functor t] [LawfulFunctor t]  {t t' : Type u → Type u}  (eqv : ∀ α, t α ≃ t' α)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u → Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (η : ApplicativeTransformation F G) {α β γ : Type u}  [Traversable t']      (h₀ : ∀ {α β} (f : α → β), map f = Equiv.map eqv f)      (h₁ : ∀ {α β} (f : β), mapConst f = (Equiv.map eqv ∘ Function.const α) f)      (h₂ :       ∀ {F : Type u → Type u} [Applicative F],         ∀ [LawfulApplicative F] {α β} (f : α → F β), traverse f = Equiv.traverse eqv f)"},
 {"type": "IsLawfulTraversable Id",
  "tactic-prompt":
  "instance (F : Type u → Type v)  [Applicative F]  [LawfulApplicative F] (G : Type u → Type w)  [Applicative G]  [LawfulApplicative G] {H : Type u → Type s}  [Applicative H]  [LawfulApplicative H] : IsLawfulTraversable Id := by refine' { .. }; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "refine' { .. }",
  "core-prompt":
  "(F : Type u → Type v)  [Applicative F]  [LawfulApplicative F] (G : Type u → Type w)  [Applicative G]  [LawfulApplicative G] {H : Type u → Type s}  [Applicative H]  [LawfulApplicative H] : IsLawfulTraversable Id",
  "args":
  "(F : Type u → Type v)  [Applicative F]  [LawfulApplicative F] (G : Type u → Type w)  [Applicative G]  [LawfulApplicative G] {H : Type u → Type s}  [Applicative H]  [LawfulApplicative H]"},
 {"type": "map f <$> traverse g x = traverse (map f ∘ g) x",
  "tactic-prompt":
  "theorem {t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (x : t α) : map f <$> traverse g x = traverse (map f ∘ g) x := by rw [map_eq_traverse_id f]; sorry",
  "name": "map_traverse",
  "kind": "theorem",
  "first-tactic": "rw [map_eq_traverse_id f]",
  "core-prompt":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (x : t α) : map f <$> traverse g x = traverse (map f ∘ g) x",
  "args":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (x : t α)"},
 {"type": "traverse f (g <$> x) = traverse (f ∘ g) x",
  "tactic-prompt":
  "theorem {t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (f : β → F γ)  (g : α → β)  (x : t α) : traverse f (g <$> x) = traverse (f ∘ g) x := by rw [@map_eq_traverse_id t _ _ _ _ g]; sorry",
  "name": "traverse_map",
  "kind": "theorem",
  "first-tactic": "rw [@map_eq_traverse_id t _ _ _ _ g]",
  "core-prompt":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (f : β → F γ)  (g : α → β)  (x : t α) : traverse f (g <$> x) = traverse (f ∘ g) x",
  "args":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (f : β → F γ)  (g : α → β)  (x : t α)"},
 {"type": "traverse pure x = (pure x : F (t α))",
  "tactic-prompt":
  "theorem {t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (x : t α) : traverse pure x = (pure x : F (t α)) := by have : traverse pure x = pure (traverse (m := Id) pure x) :=\n      (naturality (PureTransformation F) pure x).symm; sorry",
  "name": "pure_traverse",
  "kind": "theorem",
  "first-tactic":
  "have : traverse pure x = pure (traverse (m := Id) pure x) :=\n      (naturality (PureTransformation F) pure x).symm",
  "core-prompt":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (x : t α) : traverse pure x = (pure x : F (t α))",
  "args":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (x : t α)"},
 {"type": "sequence (f := Id) (pure <$> x) = pure x",
  "tactic-prompt":
  "theorem {t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (x : t α) : sequence (f := Id) (pure <$> x) = pure x := by simp [sequence]; sorry",
  "name": "id_sequence",
  "kind": "theorem",
  "first-tactic": "simp [sequence]",
  "core-prompt":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (x : t α) : sequence (f := Id) (pure <$> x) = pure x",
  "args":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (x : t α)"},
 {"type": "sequence (Comp.mk <$> x) = Comp.mk (sequence <$> sequence x)",
  "tactic-prompt":
  "theorem {t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (x : t (F (G α))) : sequence (Comp.mk <$> x) = Comp.mk (sequence <$> sequence x) := by simp [sequence]; sorry",
  "name": "comp_sequence",
  "kind": "theorem",
  "first-tactic": "simp [sequence]",
  "core-prompt":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (x : t (F (G α))) : sequence (Comp.mk <$> x) = Comp.mk (sequence <$> sequence x)",
  "args":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (x : t (F (G α)))"},
 {"type": "η (sequence x) = sequence (@η _ <$> x)",
  "tactic-prompt":
  "theorem {t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (η : ApplicativeTransformation F G)  (x : t (F α)) : η (sequence x) = sequence (@η _ <$> x) := by simp [sequence]; sorry",
  "name": "naturality'",
  "kind": "theorem",
  "first-tactic": "simp [sequence]",
  "core-prompt":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (η : ApplicativeTransformation F G)  (x : t (F α)) : η (sequence x) = sequence (@η _ <$> x)",
  "args":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (η : ApplicativeTransformation F G)  (x : t (F α))"},
 {"type": "traverse pure = (pure : t α → Id (t α))",
  "tactic-prompt":
  "theorem {t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) : traverse pure = (pure : t α → Id (t α)) := by ext; sorry",
  "name": "traverse_id",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) : traverse pure = (pure : t α → Id (t α))",
  "args":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ)"},
 {"type":
  "traverse (Comp.mk ∘ map h ∘ g) =\n      (Comp.mk ∘ map (traverse h) ∘ traverse g : t α → Comp F G (t γ))",
  "tactic-prompt":
  "theorem {t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (g : α → F β)  (h : β → G γ) : traverse (Comp.mk ∘ map h ∘ g) =\n      (Comp.mk ∘ map (traverse h) ∘ traverse g : t α → Comp F G (t γ)) := by ext; sorry",
  "name": "traverse_comp",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (g : α → F β)  (h : β → G γ) : traverse (Comp.mk ∘ map h ∘ g) =\n      (Comp.mk ∘ map (traverse h) ∘ traverse g : t α → Comp F G (t γ))",
  "args":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (g : α → F β)  (h : β → G γ)"},
 {"type": "traverse (m := Id) (pure ∘ f) = pure ∘ (map f : t β → t γ)",
  "tactic-prompt":
  "theorem {t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (f : β → γ) : traverse (m := Id) (pure ∘ f) = pure ∘ (map f : t β → t γ) := by ext; sorry",
  "name": "traverse_eq_map_id'",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (f : β → γ) : traverse (m := Id) (pure ∘ f) = pure ∘ (map f : t β → t γ)",
  "args":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (f : β → γ)"},
 {"type": "traverse (h ∘ g) = (traverse h ∘ map g : t α → G (t γ))",
  "tactic-prompt":
  "theorem {t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (g : α → β)  (h : β → G γ) : traverse (h ∘ g) = (traverse h ∘ map g : t α → G (t γ)) := by ext; sorry",
  "name": "traverse_map'",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (g : α → β)  (h : β → G γ) : traverse (h ∘ g) = (traverse h ∘ map g : t α → G (t γ))",
  "args":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (g : α → β)  (h : β → G γ)"},
 {"type": "traverse (map h ∘ g) = (map (map h) ∘ traverse g : t α → G (t γ))",
  "tactic-prompt":
  "theorem {t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (g : α → G β)  (h : β → γ) : traverse (map h ∘ g) = (map (map h) ∘ traverse g : t α → G (t γ)) := by ext; sorry",
  "name": "map_traverse'",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (g : α → G β)  (h : β → γ) : traverse (map h ∘ g) = (map (map h) ∘ traverse g : t α → G (t γ))",
  "args":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (g : α → G β)  (h : β → γ)"},
 {"type": "traverse (@η _ ∘ f) = @η _ ∘ (traverse f : t α → F (t β))",
  "tactic-prompt":
  "theorem {t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (η : ApplicativeTransformation F G)  (f : α → F β) : traverse (@η _ ∘ f) = @η _ ∘ (traverse f : t α → F (t β)) := by ext; sorry",
  "name": "naturality_pf",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (η : ApplicativeTransformation F G)  (f : α → F β) : traverse (@η _ ∘ f) = @η _ ∘ (traverse f : t α → F (t β))",
  "args":
  "{t : Type u → Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u → Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {α β γ : Type u} (g : α → F β) (h : β → G γ) (f : β → γ) (η : ApplicativeTransformation F G)  (f : α → F β)"},
 {"type": "f ≫ h = g ≫ h",
  "tactic-prompt":
  "theorem {C : Type _}  [Category C] {X Y : C}  {f g : X ⟶ Y}  (w : f = g)  {Z : C}  (h : Y ⟶ Z) : f ≫ h = g ≫ h := by rw [w]; sorry",
  "name": "eq_whisker'",
  "kind": "theorem",
  "first-tactic": "rw [w]",
  "core-prompt":
  "{C : Type _}  [Category C] {X Y : C}  {f g : X ⟶ Y}  (w : f = g)  {Z : C}  (h : Y ⟶ Z) : f ≫ h = g ≫ h",
  "args":
  "{C : Type _}  [Category C] {X Y : C}  {f g : X ⟶ Y}  (w : f = g)  {Z : C}  (h : Y ⟶ Z)"},
 {"type": "0 + b = b",
  "tactic-prompt": "theorem (b : R) : 0 + b = b := by simp; sorry",
  "name": "add_pf_zero_add",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(b : R) : 0 + b = b",
  "args": "(b : R)"},
 {"type": "a + 0 = a",
  "tactic-prompt": "theorem (a : R) : a + 0 = a := by simp; sorry",
  "name": "add_pf_add_zero",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a : R) : a + 0 = a",
  "args": "(a : R)"},
 {"type": "(a₁ + a₂ : R) + (b₁ + b₂) = c",
  "tactic-prompt":
  "theorem (h : IsNat (a₁ + b₁) (nat_lit 0))  (h₄ : a₂ + b₂ = c) : (a₁ + a₂ : R) + (b₁ + b₂) = c := by subst_vars; sorry",
  "name": "add_pf_add_overlap_zero",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "(h : IsNat (a₁ + b₁) (nat_lit 0))  (h₄ : a₂ + b₂ = c) : (a₁ + a₂ : R) + (b₁ + b₂) = c",
  "args": "(h : IsNat (a₁ + b₁) (nat_lit 0))  (h₄ : a₂ + b₂ = c)"},
 {"type": "(nat_lit 1).rawCast * a = a",
  "tactic-prompt":
  "theorem (a : R) : (nat_lit 1).rawCast * a = a := by simp [Nat.rawCast]; sorry",
  "name": "one_mul",
  "kind": "theorem",
  "first-tactic": "simp [Nat.rawCast]",
  "core-prompt": "(a : R) : (nat_lit 1).rawCast * a = a",
  "args": "(a : R)"},
 {"type": "a * (nat_lit 1).rawCast = a",
  "tactic-prompt":
  "theorem (a : R) : a * (nat_lit 1).rawCast = a := by simp [Nat.rawCast]; sorry",
  "name": "mul_one",
  "kind": "theorem",
  "first-tactic": "simp [Nat.rawCast]",
  "core-prompt": "(a : R) : a * (nat_lit 1).rawCast = a",
  "args": "(a : R)"},
 {"type": "a * 0 = 0",
  "tactic-prompt": "theorem (a : R) : a * 0 = 0 := by simp; sorry",
  "name": "mul_zero",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a : R) : a * 0 = 0",
  "args": "(a : R)"},
 {"type": "0 * b = 0",
  "tactic-prompt": "theorem (b : R) : 0 * b = 0 := by simp; sorry",
  "name": "zero_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(b : R) : 0 * b = 0",
  "args": "(b : R)"},
 {"type": "a ^ nat_lit 1 = a",
  "tactic-prompt": "theorem (a : R) : a ^ nat_lit 1 = a := by simp; sorry",
  "name": "pow_one",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a : R) : a ^ nat_lit 1 = a",
  "args": "(a : R)"},
 {"type": "((nat_lit 1).rawCast : R) ^ b = (nat_lit 1).rawCast",
  "tactic-prompt":
  "theorem (b : ℕ) : ((nat_lit 1).rawCast : R) ^ b = (nat_lit 1).rawCast := by simp; sorry",
  "name": "one_pow",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "(b : ℕ) : ((nat_lit 1).rawCast : R) ^ b = (nat_lit 1).rawCast",
  "args": "(b : ℕ)"},
 {"type": "k.rawCast = (nat_lit 1).rawCast * k",
  "tactic-prompt":
  "theorem (k : ℕ) : k.rawCast = (nat_lit 1).rawCast * k := by simp; sorry",
  "name": "coeff_one",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(k : ℕ) : k.rawCast = (nat_lit 1).rawCast * k",
  "args": "(k : ℕ)"},
 {"type": "a ^ (nat_lit 1).rawCast = a",
  "tactic-prompt":
  "theorem (a : R) : a ^ (nat_lit 1).rawCast = a := by simp; sorry",
  "name": "pow_one_cast",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a : R) : a ^ (nat_lit 1).rawCast = a",
  "args": "(a : R)"},
 {"type": "a ^ 0 = (nat_lit 1).rawCast + 0",
  "tactic-prompt":
  "theorem (a : R) : a ^ 0 = (nat_lit 1).rawCast + 0 := by simp; sorry",
  "name": "pow_zero",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a : R) : a ^ 0 = (nat_lit 1).rawCast + 0",
  "args": "(a : R)"},
 {"type": "a = a ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast + 0",
  "tactic-prompt":
  "theorem (a : R) : a = a ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast + 0 := by simp; sorry",
  "name": "atom_pf",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "(a : R) : a = a ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast + 0",
  "args": "(a : R)"},
 {"type": "a = a' ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast + 0",
  "tactic-prompt":
  "theorem (p : (a : R) = a') : a = a' ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast + 0 := by simp [*]; sorry",
  "name": "atom_pf'",
  "kind": "theorem",
  "first-tactic": "simp [*]",
  "core-prompt":
  "(p : (a : R) = a') : a = a' ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast + 0",
  "args": "(p : (a : R) = a')"},
 {"type": "(Nat.rawCast 0 : R) = 0",
  "tactic-prompt":
  "theorem [CommSemiring R] : (Nat.rawCast 0 : R) = 0 := by simp; sorry",
  "name": "nat_rawCast_0",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "[CommSemiring R] : (Nat.rawCast 0 : R) = 0",
  "args": "[CommSemiring R]"},
 {"type": "(Nat.rawCast 1 : R) = 1",
  "tactic-prompt":
  "theorem [CommSemiring R] : (Nat.rawCast 1 : R) = 1 := by simp; sorry",
  "name": "nat_rawCast_1",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "[CommSemiring R] : (Nat.rawCast 1 : R) = 1",
  "args": "[CommSemiring R]"},
 {"type": "Fmla.reify v (f₁.and f₂) (a ∨ b)",
  "tactic-prompt":
  "theorem (h₁ : Fmla.reify v f₁ a)  (h₂ : Fmla.reify v f₂ b) : Fmla.reify v (f₁.and f₂) (a ∨ b) := by refine ⟨fun H ↦ by_contra fun hn ↦ H ⟨fun c h ↦ by_contra fun hn' ↦ ?_⟩⟩; sorry",
  "name": "Fmla.reify_or",
  "kind": "theorem",
  "first-tactic":
  "refine ⟨fun H ↦ by_contra fun hn ↦ H ⟨fun c h ↦ by_contra fun hn' ↦ ?_⟩⟩",
  "core-prompt":
  "(h₁ : Fmla.reify v f₁ a)  (h₂ : Fmla.reify v f₂ b) : Fmla.reify v (f₁.and f₂) (a ∨ b)",
  "args": "(h₁ : Fmla.reify v f₁ a)  (h₂ : Fmla.reify v f₂ b)"},
 {"type": "a ≠ b ↔ (a : ℤ) ≠ (b : ℤ)",
  "tactic-prompt":
  "lemma (a b : ℕ) : a ≠ b ↔ (a : ℤ) ≠ (b : ℤ) := by simp only [ne_eq]; sorry",
  "name": "nat_cast_ne",
  "kind": "lemma",
  "first-tactic": "simp only [ne_eq]",
  "core-prompt": "(a b : ℕ) : a ≠ b ↔ (a : ℤ) ≠ (b : ℤ)",
  "args": "(a b : ℕ)"},
 {"type": "True",
  "tactic-prompt": "example  : True := by find; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "find",
  "core-prompt": " : True",
  "args": ""},
 {"type": "a' = b'",
  "tactic-prompt":
  "theorem [AddGroup α]  (p : (a:α) = b)  (H : (a' - b') - (a - b) = 0) : a' = b' := by rw [← sub_eq_zero] at p ⊢; sorry",
  "name": "eq_of_add",
  "kind": "theorem",
  "first-tactic": "rw [← sub_eq_zero] at p ⊢",
  "core-prompt":
  "[AddGroup α]  (p : (a:α) = b)  (H : (a' - b') - (a - b) = 0) : a' = b'",
  "args": "[AddGroup α]  (p : (a:α) = b)  (H : (a' - b') - (a - b) = 0)"},
 {"type": "F.map (preimage F f) = f",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C} (F : C ⥤ D)  [Full F]  {X Y : C}  (f : F.obj X ⟶ F.obj Y) : F.map (preimage F f) = f := by unfold preimage; sorry",
  "name": "image_preimage",
  "kind": "theorem",
  "first-tactic": "unfold preimage",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C} (F : C ⥤ D)  [Full F]  {X Y : C}  (f : F.obj X ⟶ F.obj Y) : F.map (preimage F f) = f",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C} (F : C ⥤ D)  [Full F]  {X Y : C}  (f : F.obj X ⟶ F.obj Y)"},
 {"type": "Full F",
  "tactic-prompt":
  "def {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C} (F : C ⥤ D)      (h : ∀ (X Y : C) (f : F.obj X ⟶ F.obj Y), ∃ p, F.map p = f) : Full F := by choose p hp using h; sorry",
  "name": "fullOfExists",
  "kind": "def",
  "first-tactic": "choose p hp using h",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C} (F : C ⥤ D)      (h : ∀ (X Y : C) (f : F.obj X ⟶ F.obj Y), ∃ p, F.map p = f) : Full F",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C} (F : C ⥤ D)      (h : ∀ (X Y : C) (f : F.obj X ⟶ F.obj Y), ∃ p, F.map p = f)"},
 {"type": "F.preimageIso (F.mapIso f) = f",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C}  {F : C ⥤ D}  [Full F]  [Faithful F]  {X Y Z : C} (f : X ≅ Y) : F.preimageIso (F.mapIso f) = f := by ext; sorry",
  "name": "preimageIso_mapIso",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C}  {F : C ⥤ D}  [Full F]  [Faithful F]  {X Y Z : C} (f : X ≅ Y) : F.preimageIso (F.mapIso f) = f",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C}  {F : C ⥤ D}  [Full F]  [Faithful F]  {X Y Z : C} (f : X ≅ Y)"},
 {"type":
  "(natIsoOfCompFullyFaithful H i).hom = natTransOfCompFullyFaithful H i.hom",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C}  {E : Type _}  [Category E]  {F G : C ⥤ D}  (H : D ⥤ E)  [Full H]  [Faithful H] (i : F ⋙ H ≅ G ⋙ H) : (natIsoOfCompFullyFaithful H i).hom = natTransOfCompFullyFaithful H i.hom := by ext; sorry",
  "name": "natIsoOfCompFullyFaithful_hom",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C}  {E : Type _}  [Category E]  {F G : C ⥤ D}  (H : D ⥤ E)  [Full H]  [Faithful H] (i : F ⋙ H ≅ G ⋙ H) : (natIsoOfCompFullyFaithful H i).hom = natTransOfCompFullyFaithful H i.hom",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C}  {E : Type _}  [Category E]  {F G : C ⥤ D}  (H : D ⥤ E)  [Full H]  [Faithful H] (i : F ⋙ H ≅ G ⋙ H)"},
 {"type":
  "(natIsoOfCompFullyFaithful H i).inv = natTransOfCompFullyFaithful H i.inv",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C}  {E : Type _}  [Category E]  {F G : C ⥤ D}  (H : D ⥤ E)  [Full H]  [Faithful H] (i : F ⋙ H ≅ G ⋙ H) : (natIsoOfCompFullyFaithful H i).inv = natTransOfCompFullyFaithful H i.inv := by ext; sorry",
  "name": "natIsoOfCompFullyFaithful_inv",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C}  {E : Type _}  [Category E]  {F G : C ⥤ D}  (H : D ⥤ E)  [Full H]  [Faithful H] (i : F ⋙ H ≅ G ⋙ H) : (natIsoOfCompFullyFaithful H i).inv = natTransOfCompFullyFaithful H i.inv",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C}  {E : Type _}  [Category E]  {F G : C ⥤ D}  (H : D ⥤ E)  [Full H]  [Faithful H] (i : F ⋙ H ≅ G ⋙ H)"},
 {"type": "Faithful.div F G obj @h_obj @map @h_map ⋙ G = F",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C} {C : Type u₁}  [Category.{v₁} C] {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}  [Category.{v₃} E] (F F' : C ⥤ D)  (G : D ⥤ E) (F : C ⥤ E)  [Faithful F]  (G : D ⥤ E)  [Faithful G]  (obj : C → D)      (h_obj : ∀ X, G.obj (obj X) = F.obj X)  (map : ∀ {X Y}, (X ⟶ Y) → (obj X ⟶ obj Y))      (h_map : ∀ {X Y} {f : X ⟶ Y}, HEq (G.map (map f)) (F.map f)) : Faithful.div F G obj @h_obj @map @h_map ⋙ G = F := by cases' F with F_pre _ _; sorry",
  "name": "Faithful.div_comp",
  "kind": "theorem",
  "first-tactic": "cases' F with F_pre _ _",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C} {C : Type u₁}  [Category.{v₁} C] {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}  [Category.{v₃} E] (F F' : C ⥤ D)  (G : D ⥤ E) (F : C ⥤ E)  [Faithful F]  (G : D ⥤ E)  [Faithful G]  (obj : C → D)      (h_obj : ∀ X, G.obj (obj X) = F.obj X)  (map : ∀ {X Y}, (X ⟶ Y) → (obj X ⟶ obj Y))      (h_map : ∀ {X Y} {f : X ⟶ Y}, HEq (G.map (map f)) (F.map f)) : Faithful.div F G obj @h_obj @map @h_map ⋙ G = F",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {X Y : C} {C : Type u₁}  [Category.{v₁} C] {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}  [Category.{v₃} E] (F F' : C ⥤ D)  (G : D ⥤ E) (F : C ⥤ E)  [Faithful F]  (G : D ⥤ E)  [Faithful G]  (obj : C → D)      (h_obj : ∀ X, G.obj (obj X) = F.obj X)  (map : ∀ {X Y}, (X ⟶ Y) → (obj X ⟶ obj Y))      (h_map : ∀ {X Y} {f : X ⟶ Y}, HEq (G.map (map f)) (F.map f))"},
 {"type": "F ⋙ 𝟭 D = F",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]    {E : Type u₃}  [Category.{v₃} E] (F : C ⥤ D) : F ⋙ 𝟭 D = F := by cases F; sorry",
  "name": "comp_id",
  "kind": "theorem",
  "first-tactic": "cases F",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]    {E : Type u₃}  [Category.{v₃} E] (F : C ⥤ D) : F ⋙ 𝟭 D = F",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]    {E : Type u₃}  [Category.{v₃} E] (F : C ⥤ D)"},
 {"type": "𝟭 C ⋙ F = F",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]    {E : Type u₃}  [Category.{v₃} E] (F : C ⥤ D) : 𝟭 C ⋙ F = F := by cases F; sorry",
  "name": "id_comp",
  "kind": "theorem",
  "first-tactic": "cases F",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]    {E : Type u₃}  [Category.{v₃} E] (F : C ⥤ D) : 𝟭 C ⋙ F = F",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]    {E : Type u₃}  [Category.{v₃} E] (F : C ⥤ D)"},
 {"type":
  "F.map (if h : P then f h else g h) = if h : P then F.map (f h) else F.map (g h)",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]    {E : Type u₃}  [Category.{v₃} E] (F : C ⥤ D)  {X Y : C}  {P : Prop}  [Decidable P]      (f : P → (X ⟶ Y))  (g : ¬P → (X ⟶ Y)) : F.map (if h : P then f h else g h) = if h : P then F.map (f h) else F.map (g h) := by aesop_cat; sorry",
  "name": "map_dite",
  "kind": "theorem",
  "first-tactic": "aesop_cat",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]    {E : Type u₃}  [Category.{v₃} E] (F : C ⥤ D)  {X Y : C}  {P : Prop}  [Decidable P]      (f : P → (X ⟶ Y))  (g : ¬P → (X ⟶ Y)) : F.map (if h : P then f h else g h) = if h : P then F.map (f h) else F.map (g h)",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]    {E : Type u₃}  [Category.{v₃} E] (F : C ⥤ D)  {X Y : C}  {P : Prop}  [Decidable P]      (f : P → (X ⟶ Y))  (g : ¬P → (X ⟶ Y))"},
 {"type": "α.app X = β.app X",
  "tactic-prompt":
  "theorem (C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} {α β : F ⟶ G}  (h : α = β)  (X : C) : α.app X = β.app X := by rw [h]; sorry",
  "name": "congr_app",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt":
  "(C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} {α β : F ⟶ G}  (h : α = β)  (X : C) : α.app X = β.app X",
  "args":
  "(C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} {α β : F ⟶ G}  (h : α = β)  (X : C)"},
 {"type": "(α ◫ 𝟙 H).app X = H.map (α.app X)",
  "tactic-prompt":
  "theorem (C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} {H : D ⥤ E}  (α : F ⟶ G)  (X : C) : (α ◫ 𝟙 H).app X = H.map (α.app X) := by simp; sorry",
  "name": "hcomp_id_app",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "(C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} {H : D ⥤ E}  (α : F ⟶ G)  (X : C) : (α ◫ 𝟙 H).app X = H.map (α.app X)",
  "args":
  "(C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} {H : D ⥤ E}  (α : F ⟶ G)  (X : C)"},
 {"type": "(𝟙 H ◫ α).app X = α.app _",
  "tactic-prompt":
  "theorem (C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} {H : E ⥤ C}  (α : F ⟶ G)  (X : E) : (𝟙 H ◫ α).app X = α.app _ := by simp; sorry",
  "name": "id_hcomp_app",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "(C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} {H : E ⥤ C}  (α : F ⟶ G)  (X : E) : (𝟙 H ◫ α).app X = α.app _",
  "args":
  "(C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} {H : E ⥤ C}  (α : F ⟶ G)  (X : E)"},
 {"type": "(α ≫ β) ◫ (γ ≫ δ) = (α ◫ γ) ≫ β ◫ δ",
  "tactic-prompt":
  "theorem (C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} {I J K : D ⥤ E}  (α : F ⟶ G)  (β : G ⟶ H)  (γ : I ⟶ J)  (δ : J ⟶ K) : (α ≫ β) ◫ (γ ≫ δ) = (α ◫ γ) ≫ β ◫ δ := by aesop_cat; sorry",
  "name": "exchange",
  "kind": "theorem",
  "first-tactic": "aesop_cat",
  "core-prompt":
  "(C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} {I J K : D ⥤ E}  (α : F ⟶ G)  (β : G ⟶ H)  (γ : I ⟶ J)  (δ : J ⟶ K) : (α ≫ β) ◫ (γ ≫ δ) = (α ◫ γ) ≫ β ◫ δ",
  "args":
  "(C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} {I J K : D ⥤ E}  (α : F ⟶ G)  (β : G ⟶ H)  (γ : I ⟶ J)  (δ : J ⟶ K)"},
 {"type": "(F.map e.hom).app Z ≫ (F.map e.inv).app Z = 𝟙 _",
  "tactic-prompt":
  "theorem (C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} (F : C ⥤ D ⥤ E)  {X Y : C}  (e : X ≅ Y)  (Z : D) : (F.map e.hom).app Z ≫ (F.map e.inv).app Z = 𝟙 _ := by simp [← NatTrans.comp_app]; sorry",
  "name": "map_hom_inv_app",
  "kind": "theorem",
  "first-tactic": "simp [← NatTrans.comp_app]",
  "core-prompt":
  "(C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} (F : C ⥤ D ⥤ E)  {X Y : C}  (e : X ≅ Y)  (Z : D) : (F.map e.hom).app Z ≫ (F.map e.inv).app Z = 𝟙 _",
  "args":
  "(C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} (F : C ⥤ D ⥤ E)  {X Y : C}  (e : X ≅ Y)  (Z : D)"},
 {"type": "(F.map e.inv).app Z ≫ (F.map e.hom).app Z = 𝟙 _",
  "tactic-prompt":
  "theorem (C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} (F : C ⥤ D ⥤ E)  {X Y : C}  (e : X ≅ Y)  (Z : D) : (F.map e.inv).app Z ≫ (F.map e.hom).app Z = 𝟙 _ := by simp [← NatTrans.comp_app]; sorry",
  "name": "map_inv_hom_app",
  "kind": "theorem",
  "first-tactic": "simp [← NatTrans.comp_app]",
  "core-prompt":
  "(C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} (F : C ⥤ D ⥤ E)  {X Y : C}  (e : X ≅ Y)  (Z : D) : (F.map e.inv).app Z ≫ (F.map e.hom).app Z = 𝟙 _",
  "args":
  "(C : Type u₁)  [Category.{v₁} C]  (D : Type u₂)  [Category.{v₂} D] {F G H I : C ⥤ D} (F : C ⥤ D ⥤ E)  {X Y : C}  (e : X ≅ Y)  (Z : D)"},
 {"type": "α.hom.app X ≫ g = α.hom.app X ≫ g' ↔ g = g'",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {X : C}  {Z : D}  (g g' : G.obj X ⟶ Z) : α.hom.app X ≫ g = α.hom.app X ≫ g' ↔ g = g' := by simp only [cancel_epi]; sorry",
  "name": "cancel_natIso_hom_left",
  "kind": "theorem",
  "first-tactic": "simp only [cancel_epi]",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {X : C}  {Z : D}  (g g' : G.obj X ⟶ Z) : α.hom.app X ≫ g = α.hom.app X ≫ g' ↔ g = g'",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {X : C}  {Z : D}  (g g' : G.obj X ⟶ Z)"},
 {"type": "α.inv.app X ≫ g = α.inv.app X ≫ g' ↔ g = g'",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {X : C}  {Z : D}  (g g' : F.obj X ⟶ Z) : α.inv.app X ≫ g = α.inv.app X ≫ g' ↔ g = g' := by simp only [cancel_epi]; sorry",
  "name": "cancel_natIso_inv_left",
  "kind": "theorem",
  "first-tactic": "simp only [cancel_epi]",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {X : C}  {Z : D}  (g g' : F.obj X ⟶ Z) : α.inv.app X ≫ g = α.inv.app X ≫ g' ↔ g = g'",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {X : C}  {Z : D}  (g g' : F.obj X ⟶ Z)"},
 {"type": "f ≫ α.hom.app Y = f' ≫ α.hom.app Y ↔ f = f'",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {X : D}  {Y : C}  (f f' : X ⟶ F.obj Y) : f ≫ α.hom.app Y = f' ≫ α.hom.app Y ↔ f = f' := by simp only [cancel_mono]; sorry",
  "name": "cancel_natIso_hom_right",
  "kind": "theorem",
  "first-tactic": "simp only [cancel_mono]",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {X : D}  {Y : C}  (f f' : X ⟶ F.obj Y) : f ≫ α.hom.app Y = f' ≫ α.hom.app Y ↔ f = f'",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {X : D}  {Y : C}  (f f' : X ⟶ F.obj Y)"},
 {"type": "f ≫ α.inv.app Y = f' ≫ α.inv.app Y ↔ f = f'",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {X : D}  {Y : C}  (f f' : X ⟶ G.obj Y) : f ≫ α.inv.app Y = f' ≫ α.inv.app Y ↔ f = f' := by simp only [cancel_mono]; sorry",
  "name": "cancel_natIso_inv_right",
  "kind": "theorem",
  "first-tactic": "simp only [cancel_mono]",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {X : D}  {Y : C}  (f f' : X ⟶ G.obj Y) : f ≫ α.inv.app Y = f' ≫ α.inv.app Y ↔ f = f'",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {X : D}  {Y : C}  (f f' : X ⟶ G.obj Y)"},
 {"type": "f ≫ g ≫ α.hom.app Y = f' ≫ g' ≫ α.hom.app Y ↔ f ≫ g = f' ≫ g'",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {W X X' : D}  {Y : C}  (f : W ⟶ X)  (g : X ⟶ F.obj Y)      (f' : W ⟶ X')  (g' : X' ⟶ F.obj Y) : f ≫ g ≫ α.hom.app Y = f' ≫ g' ≫ α.hom.app Y ↔ f ≫ g = f' ≫ g' := by simp only [← Category.assoc]; sorry",
  "name": "cancel_natIso_hom_right_assoc",
  "kind": "theorem",
  "first-tactic": "simp only [← Category.assoc]",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {W X X' : D}  {Y : C}  (f : W ⟶ X)  (g : X ⟶ F.obj Y)      (f' : W ⟶ X')  (g' : X' ⟶ F.obj Y) : f ≫ g ≫ α.hom.app Y = f' ≫ g' ≫ α.hom.app Y ↔ f ≫ g = f' ≫ g'",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {W X X' : D}  {Y : C}  (f : W ⟶ X)  (g : X ⟶ F.obj Y)      (f' : W ⟶ X')  (g' : X' ⟶ F.obj Y)"},
 {"type": "f ≫ g ≫ α.inv.app Y = f' ≫ g' ≫ α.inv.app Y ↔ f ≫ g = f' ≫ g'",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {W X X' : D}  {Y : C}  (f : W ⟶ X)  (g : X ⟶ G.obj Y)      (f' : W ⟶ X')  (g' : X' ⟶ G.obj Y) : f ≫ g ≫ α.inv.app Y = f' ≫ g' ≫ α.inv.app Y ↔ f ≫ g = f' ≫ g' := by simp only [← Category.assoc]; sorry",
  "name": "cancel_natIso_inv_right_assoc",
  "kind": "theorem",
  "first-tactic": "simp only [← Category.assoc]",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {W X X' : D}  {Y : C}  (f : W ⟶ X)  (g : X ⟶ G.obj Y)      (f' : W ⟶ X')  (g' : X' ⟶ G.obj Y) : f ≫ g ≫ α.inv.app Y = f' ≫ g' ≫ α.inv.app Y ↔ f ≫ g = f' ≫ g'",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {W X X' : D}  {Y : C}  (f : W ⟶ X)  (g : X ⟶ G.obj Y)      (f' : W ⟶ X')  (g' : X' ⟶ G.obj Y)"},
 {"type": "inv (e.inv.app X) = e.hom.app X",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {F G : C ⥤ D}  (e : F ≅ G)  (X : C) : inv (e.inv.app X) = e.hom.app X := by aesop_cat; sorry",
  "name": "inv_inv_app",
  "kind": "theorem",
  "first-tactic": "aesop_cat",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {F G : C ⥤ D}  (e : F ≅ G)  (X : C) : inv (e.inv.app X) = e.hom.app X",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D}  (α : F ≅ G) {F G : C ⥤ D}  (e : F ≅ G)  (X : C)"},
 {"type": "α.inv.app X ≫ F.map f ≫ α.hom.app Y = G.map f",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} (α : F ≅ G)  (f : X ⟶ Y) : α.inv.app X ≫ F.map f ≫ α.hom.app Y = G.map f := by simp; sorry",
  "name": "naturality_1",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} (α : F ≅ G)  (f : X ⟶ Y) : α.inv.app X ≫ F.map f ≫ α.hom.app Y = G.map f",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} (α : F ≅ G)  (f : X ⟶ Y)"},
 {"type": "α.hom.app X ≫ G.map f ≫ α.inv.app Y = F.map f",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} (α : F ≅ G)  (f : X ⟶ Y) : α.hom.app X ≫ G.map f ≫ α.inv.app Y = F.map f := by simp; sorry",
  "name": "naturality_2",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} (α : F ≅ G)  (f : X ⟶ Y) : α.hom.app X ≫ G.map f ≫ α.inv.app Y = F.map f",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} (α : F ≅ G)  (f : X ⟶ Y)"},
 {"type": "inv (α.app X) ≫ F.map f ≫ α.app Y = G.map f",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} (α : F ⟶ G)  (f : X ⟶ Y)  [IsIso (α.app X)] : inv (α.app X) ≫ F.map f ≫ α.app Y = G.map f := by simp; sorry",
  "name": "naturality_1'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} (α : F ⟶ G)  (f : X ⟶ Y)  [IsIso (α.app X)] : inv (α.app X) ≫ F.map f ≫ α.app Y = G.map f",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} (α : F ⟶ G)  (f : X ⟶ Y)  [IsIso (α.app X)]"},
 {"type": "α.app X ≫ G.map f ≫ inv (α.app Y) = F.map f",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} (α : F ⟶ G)  (f : X ⟶ Y)  [IsIso (α.app Y)] : α.app X ≫ G.map f ≫ inv (α.app Y) = F.map f := by rw [← Category.assoc]; sorry",
  "name": "naturality_2'",
  "kind": "theorem",
  "first-tactic": "rw [← Category.assoc]",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} (α : F ⟶ G)  (f : X ⟶ Y)  [IsIso (α.app Y)] : α.app X ≫ G.map f ≫ inv (α.app Y) = F.map f",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} (α : F ⟶ G)  (f : X ⟶ Y)  [IsIso (α.app Y)]"},
 {"type": "inv ((F.map e.inv).app Z) = (F.map e.hom).app Z",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} (F : C ⥤ D ⥤ E)  {X Y : C}  (e : X ≅ Y)  (Z : D) : inv ((F.map e.inv).app Z) = (F.map e.hom).app Z := by aesop_cat; sorry",
  "name": "inv_map_inv_app",
  "kind": "theorem",
  "first-tactic": "aesop_cat",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} (F : C ⥤ D ⥤ E)  {X Y : C}  (e : X ≅ Y)  (Z : D) : inv ((F.map e.inv).app Z) = (F.map e.hom).app Z",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} (F : C ⥤ D ⥤ E)  {X Y : C}  (e : X ≅ Y)  (Z : D)"},
 {"type": "F ⋙ H ≅ G ⋙ I",
  "tactic-prompt":
  "def {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} {F G : C ⥤ D}  {H I : D ⥤ E}  (α : F ≅ G)  (β : H ≅ I) : F ⋙ H ≅ G ⋙ I := by refine' ⟨α.hom ◫ β.hom, α.inv ◫ β.inv, _, _⟩; sorry",
  "name": "hcomp",
  "kind": "def",
  "first-tactic": "refine' ⟨α.hom ◫ β.hom, α.inv ◫ β.inv, _, _⟩",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} {F G : C ⥤ D}  {H I : D ⥤ E}  (α : F ≅ G)  (β : H ≅ I) : F ⋙ H ≅ G ⋙ I",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} {F G : C ⥤ D}  {H I : D ⥤ E}  (α : F ≅ G)  (β : H ≅ I)"},
 {"type": "IsIso (F₁.map f) ↔ IsIso (F₂.map f)",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} {F₁ F₂ : C ⥤ D}  (e : F₁ ≅ F₂)  {X Y : C}  (f : X ⟶ Y) : IsIso (F₁.map f) ↔ IsIso (F₂.map f) := by revert F₁ F₂; sorry",
  "name": "isIso_map_iff",
  "kind": "theorem",
  "first-tactic": "revert F₁ F₂",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} {F₁ F₂ : C ⥤ D}  (e : F₁ ≅ F₂)  {X Y : C}  (f : X ⟶ Y) : IsIso (F₁.map f) ↔ IsIso (F₂.map f)",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D]  {E : Type u₃}    [Category.{v₃} E] {F G : C ⥤ D} {X Y : C} {F₁ F₂ : C ⥤ D}  (e : F₁ ≅ F₂)  {X Y : C}  (f : X ⟶ Y)"},
 {"type": "α.app X = β.app X",
  "tactic-prompt":
  "theorem {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {F G : C ⥤ D}  {α β : NatTrans F G}  (h : α = β)  (X : C) : α.app X = β.app X := by aesop_cat; sorry",
  "name": "congr_app",
  "kind": "theorem",
  "first-tactic": "aesop_cat",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {F G : C ⥤ D}  {α β : NatTrans F G}  (h : α = β)  (X : C) : α.app X = β.app X",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {F G : C ⥤ D}  {α β : NatTrans F G}  (h : α = β)  (X : C)"},
 {"type":
  "α.app X ≫ G.map f ≫ G.map g ≫ G.map h = F.map f ≫ F.map g ≫ F.map h ≫ α.app V",
  "tactic-prompt":
  "example {C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {F G : C ⥤ D}  (α : NatTrans F G)  {X Y U V : C}  (f : X ⟶ Y)  (g : Y ⟶ U)  (h : U ⟶ V) : α.app X ≫ G.map f ≫ G.map g ≫ G.map h = F.map f ≫ F.map g ≫ F.map h ≫ α.app V := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {F G : C ⥤ D}  (α : NatTrans F G)  {X Y U V : C}  (f : X ⟶ Y)  (g : Y ⟶ U)  (h : U ⟶ V) : α.app X ≫ G.map f ≫ G.map g ≫ G.map h = F.map f ≫ F.map g ≫ F.map h ≫ α.app V",
  "args":
  "{C : Type u₁}  [Category.{v₁} C]  {D : Type u₂}  [Category.{v₂} D] {F G : C ⥤ D}  (α : NatTrans F G)  {X Y U V : C}  (f : X ⟶ Y)  (g : Y ⟶ U)  (h : U ⟶ V)"},
 {"type":
  "(associator F (𝟭 B) G).hom ≫ whiskerLeft F (leftUnitor G).hom =\n      whiskerRight (rightUnitor F).hom G",
  "tactic-prompt":
  "theorem {A : Type u₁}  [Category.{v₁} A] {B : Type u₂}  [Category.{v₂} B] {C : Type u₃}  [Category.{v₃} C] {D : Type u₄}  [Category.{v₄} D] (F : A ⥤ B)  (G : B ⥤ C) : (associator F (𝟭 B) G).hom ≫ whiskerLeft F (leftUnitor G).hom =\n      whiskerRight (rightUnitor F).hom G := by aesop_cat; sorry",
  "name": "triangle",
  "kind": "theorem",
  "first-tactic": "aesop_cat",
  "core-prompt":
  "{A : Type u₁}  [Category.{v₁} A] {B : Type u₂}  [Category.{v₂} B] {C : Type u₃}  [Category.{v₃} C] {D : Type u₄}  [Category.{v₄} D] (F : A ⥤ B)  (G : B ⥤ C) : (associator F (𝟭 B) G).hom ≫ whiskerLeft F (leftUnitor G).hom =\n      whiskerRight (rightUnitor F).hom G",
  "args":
  "{A : Type u₁}  [Category.{v₁} A] {B : Type u₂}  [Category.{v₂} B] {C : Type u₃}  [Category.{v₃} C] {D : Type u₄}  [Category.{v₄} D] (F : A ⥤ B)  (G : B ⥤ C)"},
 {"type":
  "whiskerRight (associator F G H).hom K ≫\n        (associator F (G ⋙ H) K).hom ≫ whiskerLeft F (associator G H K).hom =\n      (associator (F ⋙ G) H K).hom ≫ (associator F G (H ⋙ K)).hom",
  "tactic-prompt":
  "theorem {A : Type u₁}  [Category.{v₁} A] {B : Type u₂}  [Category.{v₂} B] {C : Type u₃}  [Category.{v₃} C] {D : Type u₄}  [Category.{v₄} D] {E : Type u₅}  [Category.{v₅} E] (F : A ⥤ B)  (G : B ⥤ C)  (H : C ⥤ D)  (K : D ⥤ E) : whiskerRight (associator F G H).hom K ≫\n        (associator F (G ⋙ H) K).hom ≫ whiskerLeft F (associator G H K).hom =\n      (associator (F ⋙ G) H K).hom ≫ (associator F G (H ⋙ K)).hom := by aesop_cat; sorry",
  "name": "pentagon",
  "kind": "theorem",
  "first-tactic": "aesop_cat",
  "core-prompt":
  "{A : Type u₁}  [Category.{v₁} A] {B : Type u₂}  [Category.{v₂} B] {C : Type u₃}  [Category.{v₃} C] {D : Type u₄}  [Category.{v₄} D] {E : Type u₅}  [Category.{v₅} E] (F : A ⥤ B)  (G : B ⥤ C)  (H : C ⥤ D)  (K : D ⥤ E) : whiskerRight (associator F G H).hom K ≫\n        (associator F (G ⋙ H) K).hom ≫ whiskerLeft F (associator G H K).hom =\n      (associator (F ⋙ G) H K).hom ≫ (associator F G (H ⋙ K)).hom",
  "args":
  "{A : Type u₁}  [Category.{v₁} A] {B : Type u₂}  [Category.{v₂} B] {C : Type u₃}  [Category.{v₃} C] {D : Type u₄}  [Category.{v₄} D] {E : Type u₅}  [Category.{v₅} E] (F : A ⥤ B)  (G : B ⥤ C)  (H : C ⥤ D)  (K : D ⥤ E)"},
 {"type": "α.symm.symm = α",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y : C}  (α : X ≅ Y) : α.symm.symm = α := by cases α; sorry",
  "name": "symm_symm_eq",
  "kind": "theorem",
  "first-tactic": "cases α",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y : C}  (α : X ≅ Y) : α.symm.symm = α",
  "args": "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y : C}  (α : X ≅ Y)"},
 {"type": "(α ≪≫ β) ≪≫ γ = α ≪≫ β ≪≫ γ",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {Z' : C}  (α : X ≅ Y)  (β : Y ≅ Z)  (γ : Z ≅ Z') : (α ≪≫ β) ≪≫ γ = α ≪≫ β ≪≫ γ := by ext; sorry",
  "name": "trans_assoc",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {Z' : C}  (α : X ≅ Y)  (β : Y ≅ Z)  (γ : Z ≅ Z') : (α ≪≫ β) ≪≫ γ = α ≪≫ β ≪≫ γ",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {Z' : C}  (α : X ≅ Y)  (β : Y ≅ Z)  (γ : Z ≅ Z')"},
 {"type": "Iso.refl X ≪≫ α = α",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y) : Iso.refl X ≪≫ α = α := by ext; sorry",
  "name": "refl_trans",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y) : Iso.refl X ≪≫ α = α",
  "args": "{C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)"},
 {"type": "α ≪≫ Iso.refl Y = α",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y) : α ≪≫ Iso.refl Y = α := by ext; sorry",
  "name": "trans_refl",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y) : α ≪≫ Iso.refl Y = α",
  "args": "{C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)"},
 {"type": "α.symm ≪≫ α ≪≫ β = β",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)  (β : Y ≅ Z) : α.symm ≪≫ α ≪≫ β = β := by rw [← trans_assoc]; sorry",
  "name": "symm_self_id_assoc",
  "kind": "theorem",
  "first-tactic": "rw [← trans_assoc]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)  (β : Y ≅ Z) : α.symm ≪≫ α ≪≫ β = β",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)  (β : Y ≅ Z)"},
 {"type": "α ≪≫ α.symm ≪≫ β = β",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)  (β : X ≅ Z) : α ≪≫ α.symm ≪≫ β = β := by rw [← trans_assoc]; sorry",
  "name": "self_symm_id_assoc",
  "kind": "theorem",
  "first-tactic": "rw [← trans_assoc]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)  (β : X ≅ Z) : α ≪≫ α.symm ≪≫ β = β",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)  (β : X ≅ Z)"},
 {"type": "α.hom ≫ f = 𝟙 X ↔ f = α.inv",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)  {f : Y ⟶ X} : α.hom ≫ f = 𝟙 X ↔ f = α.inv := by rw [← eq_inv_comp]; sorry",
  "name": "hom_comp_eq_id",
  "kind": "theorem",
  "first-tactic": "rw [← eq_inv_comp]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)  {f : Y ⟶ X} : α.hom ≫ f = 𝟙 X ↔ f = α.inv",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)  {f : Y ⟶ X}"},
 {"type": "f ≫ α.hom = 𝟙 Y ↔ f = α.inv",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)  {f : Y ⟶ X} : f ≫ α.hom = 𝟙 Y ↔ f = α.inv := by rw [← eq_comp_inv]; sorry",
  "name": "comp_hom_eq_id",
  "kind": "theorem",
  "first-tactic": "rw [← eq_comp_inv]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)  {f : Y ⟶ X} : f ≫ α.hom = 𝟙 Y ↔ f = α.inv",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)  {f : Y ⟶ X}"},
 {"type": "α.hom = β.inv ↔ β.hom = α.inv",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)  (β : Y ≅ X) : α.hom = β.inv ↔ β.hom = α.inv := by erw [inv_eq_inv α.symm β]; sorry",
  "name": "hom_eq_inv",
  "kind": "theorem",
  "first-tactic": "erw [inv_eq_inv α.symm β]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)  (β : Y ≅ X) : α.hom = β.inv ↔ β.hom = α.inv",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (α : X ≅ Y)  (β : Y ≅ X)"},
 {"type": "inv f = g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f : X ⟶ Y}  [IsIso f]  {g : Y ⟶ X}  (hom_inv_id : f ≫ g = 𝟙 X) : inv f = g := by apply (cancel_epi f).mp; sorry",
  "name": "inv_eq_of_hom_inv_id",
  "kind": "theorem",
  "first-tactic": "apply (cancel_epi f).mp",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f : X ⟶ Y}  [IsIso f]  {g : Y ⟶ X}  (hom_inv_id : f ≫ g = 𝟙 X) : inv f = g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f : X ⟶ Y}  [IsIso f]  {g : Y ⟶ X}  (hom_inv_id : f ≫ g = 𝟙 X)"},
 {"type": "inv f = g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f : X ⟶ Y}  [IsIso f]  {g : Y ⟶ X}  (inv_hom_id : g ≫ f = 𝟙 Y) : inv f = g := by apply (cancel_mono f).mp; sorry",
  "name": "inv_eq_of_inv_hom_id",
  "kind": "theorem",
  "first-tactic": "apply (cancel_mono f).mp",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f : X ⟶ Y}  [IsIso f]  {g : Y ⟶ X}  (inv_hom_id : g ≫ f = 𝟙 Y) : inv f = g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f : X ⟶ Y}  [IsIso f]  {g : Y ⟶ X}  (inv_hom_id : g ≫ f = 𝟙 Y)"},
 {"type": "inv (𝟙 X) = 𝟙 X",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} : inv (𝟙 X) = 𝟙 X := by apply inv_eq_of_hom_inv_id; sorry",
  "name": "inv_id",
  "kind": "theorem",
  "first-tactic": "apply inv_eq_of_hom_inv_id",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} : inv (𝟙 X) = 𝟙 X",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z}"},
 {"type": "inv (f ≫ h) = inv h ≫ inv f",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} [IsIso f]  [IsIso h] : inv (f ≫ h) = inv h ≫ inv f := by apply inv_eq_of_hom_inv_id; sorry",
  "name": "inv_comp",
  "kind": "theorem",
  "first-tactic": "apply inv_eq_of_hom_inv_id",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} [IsIso f]  [IsIso h] : inv (f ≫ h) = inv h ≫ inv f",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} [IsIso f]  [IsIso h]"},
 {"type": "inv (inv f) = f",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} [IsIso f] : inv (inv f) = f := by apply inv_eq_of_hom_inv_id; sorry",
  "name": "inv_inv",
  "kind": "theorem",
  "first-tactic": "apply inv_eq_of_hom_inv_id",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} [IsIso f] : inv (inv f) = f",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} [IsIso f]"},
 {"type": "inv f.inv = f.hom",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} (f : X ≅ Y) : inv f.inv = f.hom := by apply inv_eq_of_hom_inv_id; sorry",
  "name": "Iso.inv_inv",
  "kind": "theorem",
  "first-tactic": "apply inv_eq_of_hom_inv_id",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} (f : X ≅ Y) : inv f.inv = f.hom",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} (f : X ≅ Y)"},
 {"type": "inv f.hom = f.inv",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} (f : X ≅ Y) : inv f.hom = f.inv := by apply inv_eq_of_hom_inv_id; sorry",
  "name": "Iso.inv_hom",
  "kind": "theorem",
  "first-tactic": "apply inv_eq_of_hom_inv_id",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} (f : X ≅ Y) : inv f.hom = f.inv",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} (f : X ≅ Y)"},
 {"type": "IsIso g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f : X ⟶ Y)  (g : Y ⟶ Z)  [IsIso f]  [IsIso (f ≫ g)] : IsIso g := by rw [← id_comp g]; sorry",
  "name": "of_isIso_comp_left",
  "kind": "theorem",
  "first-tactic": "rw [← id_comp g]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f : X ⟶ Y)  (g : Y ⟶ Z)  [IsIso f]  [IsIso (f ≫ g)] : IsIso g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f : X ⟶ Y)  (g : Y ⟶ Z)  [IsIso f]  [IsIso (f ≫ g)]"},
 {"type": "IsIso f",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f : X ⟶ Y)  (g : Y ⟶ Z)  [IsIso g]  [IsIso (f ≫ g)] : IsIso f := by rw [← comp_id f]; sorry",
  "name": "of_isIso_comp_right",
  "kind": "theorem",
  "first-tactic": "rw [← comp_id f]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f : X ⟶ Y)  (g : Y ⟶ Z)  [IsIso g]  [IsIso (f ≫ g)] : IsIso f",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f : X ⟶ Y)  (g : Y ⟶ Z)  [IsIso g]  [IsIso (f ≫ g)]"},
 {"type": "IsIso g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  {f : X ⟶ Y}  {g : Y ⟶ Z}  {h : X ⟶ Z}  [IsIso f]      [hh : IsIso h]  (w : f ≫ g = h) : IsIso g := by rw [← w] at hh; sorry",
  "name": "of_isIso_fac_left",
  "kind": "theorem",
  "first-tactic": "rw [← w] at hh",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  {f : X ⟶ Y}  {g : Y ⟶ Z}  {h : X ⟶ Z}  [IsIso f]      [hh : IsIso h]  (w : f ≫ g = h) : IsIso g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  {f : X ⟶ Y}  {g : Y ⟶ Z}  {h : X ⟶ Z}  [IsIso f]      [hh : IsIso h]  (w : f ≫ g = h)"},
 {"type": "IsIso f",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  {f : X ⟶ Y}  {g : Y ⟶ Z}  {h : X ⟶ Z}  [IsIso g]      [hh : IsIso h]  (w : f ≫ g = h) : IsIso f := by rw [← w] at hh; sorry",
  "name": "of_isIso_fac_right",
  "kind": "theorem",
  "first-tactic": "rw [← w] at hh",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  {f : X ⟶ Y}  {g : Y ⟶ Z}  {h : X ⟶ Z}  [IsIso g]      [hh : IsIso h]  (w : f ≫ g = h) : IsIso f",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  {f : X ⟶ Y}  {g : Y ⟶ Z}  {h : X ⟶ Z}  [IsIso g]      [hh : IsIso h]  (w : f ≫ g = h)"},
 {"type": "f = g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {f g : X ⟶ Y}  [IsIso f]  [IsIso g]  (p : inv f = inv g) : f = g := by apply (cancel_epi (inv f)).1; sorry",
  "name": "eq_of_inv_eq_inv",
  "kind": "theorem",
  "first-tactic": "apply (cancel_epi (inv f)).1",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {f g : X ⟶ Y}  [IsIso f]  [IsIso g]  (p : inv f = inv g) : f = g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {f g : X ⟶ Y}  [IsIso f]  [IsIso g]  (p : inv f = inv g)"},
 {"type": "IsIso f",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} (g : X ⟶ Y)  [IsIso g]  {f : Y ⟶ X}  (h : g ≫ f = 𝟙 X) : IsIso f := by rw [(hom_comp_eq_id _).mp h]; sorry",
  "name": "isIso_of_hom_comp_eq_id",
  "kind": "theorem",
  "first-tactic": "rw [(hom_comp_eq_id _).mp h]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} (g : X ⟶ Y)  [IsIso g]  {f : Y ⟶ X}  (h : g ≫ f = 𝟙 X) : IsIso f",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} (g : X ⟶ Y)  [IsIso g]  {f : Y ⟶ X}  (h : g ≫ f = 𝟙 X)"},
 {"type": "IsIso f",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} (g : X ⟶ Y)  [IsIso g]  {f : Y ⟶ X}  (h : f ≫ g = 𝟙 Y) : IsIso f := by rw [(comp_hom_eq_id _).mp h]; sorry",
  "name": "isIso_of_comp_hom_eq_id",
  "kind": "theorem",
  "first-tactic": "rw [(comp_hom_eq_id _).mp h]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} (g : X ⟶ Y)  [IsIso g]  {f : Y ⟶ X}  (h : f ≫ g = 𝟙 Y) : IsIso f",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} (g : X ⟶ Y)  [IsIso g]  {f : Y ⟶ X}  (h : f ≫ g = 𝟙 Y)"},
 {"type": "f.hom ≫ g = f.hom ≫ g' ↔ g = g'",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f : X ≅ Y)  (g g' : Y ⟶ Z) : f.hom ≫ g = f.hom ≫ g' ↔ g = g' := by simp only [cancel_epi]; sorry",
  "name": "cancel_iso_hom_left",
  "kind": "theorem",
  "first-tactic": "simp only [cancel_epi]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f : X ≅ Y)  (g g' : Y ⟶ Z) : f.hom ≫ g = f.hom ≫ g' ↔ g = g'",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f : X ≅ Y)  (g g' : Y ⟶ Z)"},
 {"type": "f.inv ≫ g = f.inv ≫ g' ↔ g = g'",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f : Y ≅ X)  (g g' : Y ⟶ Z) : f.inv ≫ g = f.inv ≫ g' ↔ g = g' := by simp only [cancel_epi]; sorry",
  "name": "cancel_iso_inv_left",
  "kind": "theorem",
  "first-tactic": "simp only [cancel_epi]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f : Y ≅ X)  (g g' : Y ⟶ Z) : f.inv ≫ g = f.inv ≫ g' ↔ g = g'",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f : Y ≅ X)  (g g' : Y ⟶ Z)"},
 {"type": "f ≫ g.hom = f' ≫ g.hom ↔ f = f'",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f f' : X ⟶ Y)  (g : Y ≅ Z) : f ≫ g.hom = f' ≫ g.hom ↔ f = f' := by simp only [cancel_mono]; sorry",
  "name": "cancel_iso_hom_right",
  "kind": "theorem",
  "first-tactic": "simp only [cancel_mono]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f f' : X ⟶ Y)  (g : Y ≅ Z) : f ≫ g.hom = f' ≫ g.hom ↔ f = f'",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f f' : X ⟶ Y)  (g : Y ≅ Z)"},
 {"type": "f ≫ g.inv = f' ≫ g.inv ↔ f = f'",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f f' : X ⟶ Y)  (g : Z ≅ Y) : f ≫ g.inv = f' ≫ g.inv ↔ f = f' := by simp only [cancel_mono]; sorry",
  "name": "cancel_iso_inv_right",
  "kind": "theorem",
  "first-tactic": "simp only [cancel_mono]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f f' : X ⟶ Y)  (g : Z ≅ Y) : f ≫ g.inv = f' ≫ g.inv ↔ f = f'",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {X Y Z : C}  (f f' : X ⟶ Y)  (g : Z ≅ Y)"},
 {"type": "f ≫ g ≫ h.hom = f' ≫ g' ≫ h.hom ↔ f ≫ g = f' ≫ g'",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {W X X' Y Z : C}  (f : W ⟶ X)  (g : X ⟶ Y)  (f' : W ⟶ X')      (g' : X' ⟶ Y)  (h : Y ≅ Z) : f ≫ g ≫ h.hom = f' ≫ g' ≫ h.hom ↔ f ≫ g = f' ≫ g' := by simp only [← Category.assoc]; sorry",
  "name": "cancel_iso_hom_right_assoc",
  "kind": "theorem",
  "first-tactic": "simp only [← Category.assoc]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {W X X' Y Z : C}  (f : W ⟶ X)  (g : X ⟶ Y)  (f' : W ⟶ X')      (g' : X' ⟶ Y)  (h : Y ≅ Z) : f ≫ g ≫ h.hom = f' ≫ g' ≫ h.hom ↔ f ≫ g = f' ≫ g'",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {W X X' Y Z : C}  (f : W ⟶ X)  (g : X ⟶ Y)  (f' : W ⟶ X')      (g' : X' ⟶ Y)  (h : Y ≅ Z)"},
 {"type": "f ≫ g ≫ h.inv = f' ≫ g' ≫ h.inv ↔ f ≫ g = f' ≫ g'",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {W X X' Y Z : C}  (f : W ⟶ X)  (g : X ⟶ Y)  (f' : W ⟶ X')      (g' : X' ⟶ Y)  (h : Z ≅ Y) : f ≫ g ≫ h.inv = f' ≫ g' ≫ h.inv ↔ f ≫ g = f' ≫ g' := by simp only [← Category.assoc]; sorry",
  "name": "cancel_iso_inv_right_assoc",
  "kind": "theorem",
  "first-tactic": "simp only [← Category.assoc]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {W X X' Y Z : C}  (f : W ⟶ X)  (g : X ⟶ Y)  (f' : W ⟶ X')      (g' : X' ⟶ Y)  (h : Z ≅ Y) : f ≫ g ≫ h.inv = f' ≫ g' ≫ h.inv ↔ f ≫ g = f' ≫ g'",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {W X X' Y Z : C}  (f : W ⟶ X)  (g : X ⟶ Y)  (f' : W ⟶ X')      (g' : X' ⟶ Y)  (h : Z ≅ Y)"},
 {"type": "F.mapIso (i ≪≫ j) = F.mapIso i ≪≫ F.mapIso j",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {D : Type u₂} [Category.{v₂} D] (F : C ⥤ D)  {X Y Z : C}  (i : X ≅ Y)  (j : Y ≅ Z) : F.mapIso (i ≪≫ j) = F.mapIso i ≪≫ F.mapIso j := by ext; sorry",
  "name": "mapIso_trans",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {D : Type u₂} [Category.{v₂} D] (F : C ⥤ D)  {X Y Z : C}  (i : X ≅ Y)  (j : Y ≅ Z) : F.mapIso (i ≪≫ j) = F.mapIso i ≪≫ F.mapIso j",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {D : Type u₂} [Category.{v₂} D] (F : C ⥤ D)  {X Y Z : C}  (i : X ≅ Y)  (j : Y ≅ Z)"},
 {"type": "F.map (inv f) = inv (F.map f)",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {D : Type u₂} [Category.{v₂} D] (F : C ⥤ D)  {X Y : C}  (f : X ⟶ Y)  [IsIso f] : F.map (inv f) = inv (F.map f) := by apply eq_inv_of_hom_inv_id; sorry",
  "name": "map_inv",
  "kind": "theorem",
  "first-tactic": "apply eq_inv_of_hom_inv_id",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {D : Type u₂} [Category.{v₂} D] (F : C ⥤ D)  {X Y : C}  (f : X ⟶ Y)  [IsIso f] : F.map (inv f) = inv (F.map f)",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {D : Type u₂} [Category.{v₂} D] (F : C ⥤ D)  {X Y : C}  (f : X ⟶ Y)  [IsIso f]"},
 {"type": "F.map f ≫ F.map (inv f) = 𝟙 (F.obj X)",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {D : Type u₂} [Category.{v₂} D] (F : C ⥤ D)  {X Y : C}  (f : X ⟶ Y)  [IsIso f] : F.map f ≫ F.map (inv f) = 𝟙 (F.obj X) := by simp; sorry",
  "name": "map_hom_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {D : Type u₂} [Category.{v₂} D] (F : C ⥤ D)  {X Y : C}  (f : X ⟶ Y)  [IsIso f] : F.map f ≫ F.map (inv f) = 𝟙 (F.obj X)",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {D : Type u₂} [Category.{v₂} D] (F : C ⥤ D)  {X Y : C}  (f : X ⟶ Y)  [IsIso f]"},
 {"type": "F.map (inv f) ≫ F.map f = 𝟙 (F.obj Y)",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {D : Type u₂} [Category.{v₂} D] (F : C ⥤ D)  {X Y : C}  (f : X ⟶ Y)  [IsIso f] : F.map (inv f) ≫ F.map f = 𝟙 (F.obj Y) := by simp; sorry",
  "name": "map_inv_hom",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {D : Type u₂} [Category.{v₂} D] (F : C ⥤ D)  {X Y : C}  (f : X ⟶ Y)  [IsIso f] : F.map (inv f) ≫ F.map f = 𝟙 (F.obj Y)",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  {h : Y ⟶ Z} {D : Type u₂} [Category.{v₂} D] (F : C ⥤ D)  {X Y : C}  (f : X ⟶ Y)  [IsIso f]"},
 {"type": "f ≫ h = g ≫ h",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  (w : f = g)  (h : Y ⟶ Z) : f ≫ h = g ≫ h := by rw [w]; sorry",
  "name": "eq_whisker",
  "kind": "theorem",
  "first-tactic": "rw [w]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  (w : f = g)  (h : Y ⟶ Z) : f ≫ h = g ≫ h",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  (w : f = g)  (h : Y ⟶ Z)"},
 {"type": "f ≫ g = f ≫ h",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X ⟶ Y)  {g h : Y ⟶ Z}  (w : g = h) : f ≫ g = f ≫ h := by rw [w]; sorry",
  "name": "whisker_eq",
  "kind": "theorem",
  "first-tactic": "rw [w]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X ⟶ Y)  {g h : Y ⟶ Z}  (w : g = h) : f ≫ g = f ≫ h",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X ⟶ Y)  {g h : Y ⟶ Z}  (w : g = h)"},
 {"type": "f = g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  (w : ∀ {Z : C} (h : Y ⟶ Z), f ≫ h = g ≫ h) : f = g := by convert w (𝟙 Y); sorry",
  "name": "eq_of_comp_left_eq",
  "kind": "theorem",
  "first-tactic": "convert w (𝟙 Y)",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  (w : ∀ {Z : C} (h : Y ⟶ Z), f ≫ h = g ≫ h) : f = g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X ⟶ Y}  (w : ∀ {Z : C} (h : Y ⟶ Z), f ≫ h = g ≫ h)"},
 {"type": "f = g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : Y ⟶ Z}  (w : ∀ {X : C} (h : X ⟶ Y), h ≫ f = h ≫ g) : f = g := by convert w (𝟙 Y); sorry",
  "name": "eq_of_comp_right_eq",
  "kind": "theorem",
  "first-tactic": "convert w (𝟙 Y)",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : Y ⟶ Z}  (w : ∀ {X : C} (h : X ⟶ Y), h ≫ f = h ≫ g) : f = g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : Y ⟶ Z}  (w : ∀ {X : C} (h : X ⟶ Y), h ≫ f = h ≫ g)"},
 {"type": "f = 𝟙 X",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X ⟶ X)  (w : ∀ {Y : C} (g : X ⟶ Y), f ≫ g = g) : f = 𝟙 X := by convert w (𝟙 X); sorry",
  "name": "id_of_comp_left_id",
  "kind": "theorem",
  "first-tactic": "convert w (𝟙 X)",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X ⟶ X)  (w : ∀ {Y : C} (g : X ⟶ Y), f ≫ g = g) : f = 𝟙 X",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X ⟶ X)  (w : ∀ {Y : C} (g : X ⟶ Y), f ≫ g = g)"},
 {"type": "f = 𝟙 X",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X ⟶ X)  (w : ∀ {Y : C} (g : Y ⟶ X), g ≫ f = g) : f = 𝟙 X := by convert w (𝟙 X); sorry",
  "name": "id_of_comp_right_id",
  "kind": "theorem",
  "first-tactic": "convert w (𝟙 X)",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X ⟶ X)  (w : ∀ {Y : C} (g : Y ⟶ X), g ≫ f = g) : f = 𝟙 X",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X ⟶ X)  (w : ∀ {Y : C} (g : Y ⟶ X), g ≫ f = g)"},
 {"type": "(f ≫ if P then g else g') = if P then f ≫ g else f ≫ g'",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]  {X Y Z : C}  (f : X ⟶ Y)  (g g' : Y ⟶ Z) : (f ≫ if P then g else g') = if P then f ≫ g else f ≫ g' := by aesop; sorry",
  "name": "comp_ite",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]  {X Y Z : C}  (f : X ⟶ Y)  (g g' : Y ⟶ Z) : (f ≫ if P then g else g') = if P then f ≫ g else f ≫ g'",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]  {X Y Z : C}  (f : X ⟶ Y)  (g g' : Y ⟶ Z)"},
 {"type": "(if P then f else f') ≫ g = if P then f ≫ g else f' ≫ g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]  {X Y Z : C}  (f f' : X ⟶ Y)  (g : Y ⟶ Z) : (if P then f else f') ≫ g = if P then f ≫ g else f' ≫ g := by aesop; sorry",
  "name": "ite_comp",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]  {X Y Z : C}  (f f' : X ⟶ Y)  (g : Y ⟶ Z) : (if P then f else f') ≫ g = if P then f ≫ g else f' ≫ g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]  {X Y Z : C}  (f f' : X ⟶ Y)  (g : Y ⟶ Z)"},
 {"type":
  "(f ≫ if h : P then g h else g' h) = if h : P then f ≫ g h else f ≫ g' h",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]      {X Y Z : C}  (f : X ⟶ Y)  (g : P → (Y ⟶ Z))  (g' : ¬P → (Y ⟶ Z)) : (f ≫ if h : P then g h else g' h) = if h : P then f ≫ g h else f ≫ g' h := by aesop; sorry",
  "name": "comp_dite",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]      {X Y Z : C}  (f : X ⟶ Y)  (g : P → (Y ⟶ Z))  (g' : ¬P → (Y ⟶ Z)) : (f ≫ if h : P then g h else g' h) = if h : P then f ≫ g h else f ≫ g' h",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]      {X Y Z : C}  (f : X ⟶ Y)  (g : P → (Y ⟶ Z))  (g' : ¬P → (Y ⟶ Z))"},
 {"type":
  "(if h : P then f h else f' h) ≫ g = if h : P then f h ≫ g else f' h ≫ g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]      {X Y Z : C}  (f : P → (X ⟶ Y))  (f' : ¬P → (X ⟶ Y))  (g : Y ⟶ Z) : (if h : P then f h else f' h) ≫ g = if h : P then f h ≫ g else f' h ≫ g := by aesop; sorry",
  "name": "dite_comp",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]      {X Y Z : C}  (f : P → (X ⟶ Y))  (f' : ¬P → (X ⟶ Y))  (g : Y ⟶ Z) : (if h : P then f h else f' h) ≫ g = if h : P then f h ≫ g else f' h ≫ g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]      {X Y Z : C}  (f : P → (X ⟶ Y))  (f' : ¬P → (X ⟶ Y))  (g : Y ⟶ Z)"},
 {"type": "f ≫ h = f ↔ h = 𝟙 Y",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X ⟶ Y)  [Epi f]  {h : Y ⟶ Y} : f ≫ h = f ↔ h = 𝟙 Y := by convert @cancel_epi _ _ _ _ _ f _ h (𝟙 Y); sorry",
  "name": "cancel_epi_id",
  "kind": "theorem",
  "first-tactic": "convert @cancel_epi _ _ _ _ _ f _ h (𝟙 Y)",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X ⟶ Y)  [Epi f]  {h : Y ⟶ Y} : f ≫ h = f ↔ h = 𝟙 Y",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X ⟶ Y)  [Epi f]  {h : Y ⟶ Y}"},
 {"type": "g ≫ f = f ↔ g = 𝟙 X",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X ⟶ Y)  [Mono f]  {g : X ⟶ X} : g ≫ f = f ↔ g = 𝟙 X := by convert @cancel_mono _ _ _ _ _ f _ g (𝟙 X); sorry",
  "name": "cancel_mono_id",
  "kind": "theorem",
  "first-tactic": "convert @cancel_mono _ _ _ _ _ f _ g (𝟙 X)",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X ⟶ Y)  [Mono f]  {g : X ⟶ X} : g ≫ f = f ↔ g = 𝟙 X",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X ⟶ Y)  [Mono f]  {g : X ⟶ X}"},
 {"type": "Epi (f ≫ g)",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X ⟶ Y)  [Epi f]  (g : Y ⟶ Z)  [Epi g] : Epi (f ≫ g) := by constructor; sorry",
  "name": "epi_comp",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X ⟶ Y)  [Epi f]  (g : Y ⟶ Z)  [Epi g] : Epi (f ≫ g)",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X ⟶ Y)  [Epi f]  (g : Y ⟶ Z)  [Epi g]"},
 {"type": "Mono (f ≫ g)",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X ⟶ Y)  [Mono f]  (g : Y ⟶ Z)  [Mono g] : Mono (f ≫ g) := by constructor; sorry",
  "name": "mono_comp",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X ⟶ Y)  [Mono f]  (g : Y ⟶ Z)  [Mono g] : Mono (f ≫ g)",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X ⟶ Y)  [Mono f]  (g : Y ⟶ Z)  [Mono g]"},
 {"type": "Mono f",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X ⟶ Y)  (g : Y ⟶ Z)  [Mono (f ≫ g)] : Mono f := by constructor; sorry",
  "name": "mono_of_mono",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X ⟶ Y)  (g : Y ⟶ Z)  [Mono (f ≫ g)] : Mono f",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X ⟶ Y)  (g : Y ⟶ Z)  [Mono (f ≫ g)]"},
 {"type": "Mono f",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  {f : X ⟶ Y}  {g : Y ⟶ Z}  {h : X ⟶ Z}  [Mono h]      (w : f ≫ g = h) : Mono f := by subst h; sorry",
  "name": "mono_of_mono_fac",
  "kind": "theorem",
  "first-tactic": "subst h",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  {f : X ⟶ Y}  {g : Y ⟶ Z}  {h : X ⟶ Z}  [Mono h]      (w : f ≫ g = h) : Mono f",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  {f : X ⟶ Y}  {g : Y ⟶ Z}  {h : X ⟶ Z}  [Mono h]      (w : f ≫ g = h)"},
 {"type": "Epi g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X ⟶ Y)  (g : Y ⟶ Z)  [Epi (f ≫ g)] : Epi g := by constructor; sorry",
  "name": "epi_of_epi",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X ⟶ Y)  (g : Y ⟶ Z)  [Epi (f ≫ g)] : Epi g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X ⟶ Y)  (g : Y ⟶ Z)  [Epi (f ≫ g)]"},
 {"type": "Epi g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  {f : X ⟶ Y}  {g : Y ⟶ Z}  {h : X ⟶ Z}  [Epi h]      (w : f ≫ g = h) : Epi g := by subst h; sorry",
  "name": "epi_of_epi_fac",
  "kind": "theorem",
  "first-tactic": "subst h",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  {f : X ⟶ Y}  {g : Y ⟶ Z}  {h : X ⟶ Z}  [Epi h]      (w : f ≫ g = h) : Epi g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  {f : X ⟶ Y}  {g : Y ⟶ Z}  {h : X ⟶ Z}  [Epi h]      (w : f ≫ g = h)"},
 {"type": "LargeCategory (ULift.{u + 1} D)",
  "tactic-prompt":
  "example (C : Type u) [Category.{v} C] (D : Type u)  [SmallCategory D] : LargeCategory (ULift.{u + 1} D) := by infer_instance; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(C : Type u) [Category.{v} C] (D : Type u)  [SmallCategory D] : LargeCategory (ULift.{u + 1} D)",
  "args": "(C : Type u) [Category.{v} C] (D : Type u)  [SmallCategory D]"},
 {"type": "Inhabited RelCat",
  "tactic-prompt": "instance  : Inhabited RelCat := by unfold RelCat; sorry",
  "name": "RelCat.inhabited",
  "kind": "instance",
  "first-tactic": "unfold RelCat",
  "core-prompt": " : Inhabited RelCat",
  "args": ""},
 {"type": "HEq a b ↔ HEq (a : α) (b : β)",
  "tactic-prompt":
  "lemma {α β γ : Sort _}  {p q : α → Prop} {α β : Sort _}  {p : α → Prop}  {q : β → Prop}  {a : {x // p x}}      {b : {y // q y}}  (h : α = β)  (h' : HEq p q) : HEq a b ↔ HEq (a : α) (b : β) := by subst h; sorry",
  "name": "heq_iff_coe_heq",
  "kind": "lemma",
  "first-tactic": "subst h",
  "core-prompt":
  "{α β γ : Sort _}  {p q : α → Prop} {α β : Sort _}  {p : α → Prop}  {q : β → Prop}  {a : {x // p x}}      {b : {y // q y}}  (h : α = β)  (h' : HEq p q) : HEq a b ↔ HEq (a : α) (b : β)",
  "args":
  "{α β γ : Sort _}  {p q : α → Prop} {α β : Sort _}  {p : α → Prop}  {q : β → Prop}  {a : {x // p x}}      {b : {y // q y}}  (h : α = β)  (h' : HEq p q)"},
 {"type": "(∃ h : p b, Subtype.mk b h = a) ↔ b = a",
  "tactic-prompt":
  "theorem {α β γ : Sort _}  {p q : α → Prop} {a : Subtype p}  {b : α} : (∃ h : p b, Subtype.mk b h = a) ↔ b = a := by simp only [@eq_comm _ b]; sorry",
  "name": "_root_.exists_subtype_mk_eq_iff",
  "kind": "theorem",
  "first-tactic": "simp only [@eq_comm _ b]",
  "core-prompt":
  "{α β γ : Sort _}  {p q : α → Prop} {a : Subtype p}  {b : α} : (∃ h : p b, Subtype.mk b h = a) ↔ b = a",
  "args": "{α β γ : Sort _}  {p q : α → Prop} {a : Subtype p}  {b : α}"},
 {"type":
  "(mod m k : ℕ) = ite ((m : ℕ) % (k : ℕ) = 0) (k : ℕ) ((m : ℕ) % (k : ℕ))",
  "tactic-prompt":
  "theorem (m k : ℕ+) : (mod m k : ℕ) = ite ((m : ℕ) % (k : ℕ) = 0) (k : ℕ) ((m : ℕ) % (k : ℕ)) := by dsimp [mod]; sorry",
  "name": "mod_coe",
  "kind": "theorem",
  "first-tactic": "dsimp [mod]",
  "core-prompt":
  "(m k : ℕ+) : (mod m k : ℕ) = ite ((m : ℕ) % (k : ℕ) = 0) (k : ℕ) ((m : ℕ) % (k : ℕ))",
  "args": "(m k : ℕ+)"},
 {"type":
  "(div m k : ℕ) = ite ((m : ℕ) % (k : ℕ) = 0) ((m : ℕ) / (k : ℕ)).pred ((m : ℕ) / (k : ℕ))",
  "tactic-prompt":
  "theorem (m k : ℕ+) : (div m k : ℕ) = ite ((m : ℕ) % (k : ℕ) = 0) ((m : ℕ) / (k : ℕ)).pred ((m : ℕ) / (k : ℕ)) := by dsimp [div]; sorry",
  "name": "div_coe",
  "kind": "theorem",
  "first-tactic": "dsimp [div]",
  "core-prompt":
  "(m k : ℕ+) : (div m k : ℕ) = ite ((m : ℕ) % (k : ℕ) = 0) ((m : ℕ) / (k : ℕ)).pred ((m : ℕ) / (k : ℕ))",
  "args": "(m k : ℕ+)"},
 {"type": "Finite β",
  "tactic-prompt":
  "theorem {α β : Sort _} (α : Sort _)  [h : Finite α]  (f : α ≃ β) : Finite β := by cases' h with n e; sorry",
  "name": "Finite.of_equiv",
  "kind": "theorem",
  "first-tactic": "cases' h with n e",
  "core-prompt":
  "{α β : Sort _} (α : Sort _)  [h : Finite α]  (f : α ≃ β) : Finite β",
  "args": "{α β : Sort _} (α : Sort _)  [h : Finite α]  (f : α ≃ β)"},
 {"type": "(infₛ s).Rel = infₛ (Rel '' s)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} {s : Set (Setoid α)} : (infₛ s).Rel = infₛ (Rel '' s) := by ext; sorry",
  "name": "infₛ_def",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Type _}  {β : Type _} {s : Set (Setoid α)} : (infₛ s).Rel = infₛ (Rel '' s)",
  "args": "{α : Type _}  {β : Type _} {s : Set (Setoid α)}"},
 {"type": "s = (⊤ : Setoid α) ↔ ∀ x y : α, s.Rel x y",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} {s : Setoid α} : s = (⊤ : Setoid α) ↔ ∀ x y : α, s.Rel x y := by rw [_root_.eq_top_iff]; sorry",
  "name": "eq_top_iff",
  "kind": "theorem",
  "first-tactic": "rw [_root_.eq_top_iff]",
  "core-prompt":
  "{α : Type _}  {β : Type _} {s : Setoid α} : s = (⊤ : Setoid α) ↔ ∀ x y : α, s.Rel x y",
  "args": "{α : Type _}  {β : Type _} {s : Setoid α}"},
 {"type": "r ⊔ s = EqvGen.Setoid fun x y => r.Rel x y ∨ s.Rel x y",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} (r s : Setoid α) : r ⊔ s = EqvGen.Setoid fun x y => r.Rel x y ∨ s.Rel x y := by rw [eqvGen_eq]; sorry",
  "name": "sup_eq_eqvGen",
  "kind": "theorem",
  "first-tactic": "rw [eqvGen_eq]",
  "core-prompt":
  "{α : Type _}  {β : Type _} (r s : Setoid α) : r ⊔ s = EqvGen.Setoid fun x y => r.Rel x y ∨ s.Rel x y",
  "args": "{α : Type _}  {β : Type _} (r s : Setoid α)"},
 {"type": "r ⊔ s = EqvGen.Setoid (r.Rel ⊔ s.Rel)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} {r s : Setoid α} : r ⊔ s = EqvGen.Setoid (r.Rel ⊔ s.Rel) := by rw [sup_eq_eqvGen]; sorry",
  "name": "sup_def",
  "kind": "theorem",
  "first-tactic": "rw [sup_eq_eqvGen]",
  "core-prompt":
  "{α : Type _}  {β : Type _} {r s : Setoid α} : r ⊔ s = EqvGen.Setoid (r.Rel ⊔ s.Rel)",
  "args": "{α : Type _}  {β : Type _} {r s : Setoid α}"},
 {"type": "supₛ S = EqvGen.Setoid fun x y => ∃ r : Setoid α, r ∈ S ∧ r.Rel x y",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} (S : Set (Setoid α)) : supₛ S = EqvGen.Setoid fun x y => ∃ r : Setoid α, r ∈ S ∧ r.Rel x y := by rw [eqvGen_eq]; sorry",
  "name": "supₛ_eq_eqvGen",
  "kind": "theorem",
  "first-tactic": "rw [eqvGen_eq]",
  "core-prompt":
  "{α : Type _}  {β : Type _} (S : Set (Setoid α)) : supₛ S = EqvGen.Setoid fun x y => ∃ r : Setoid α, r ∈ S ∧ r.Rel x y",
  "args": "{α : Type _}  {β : Type _} (S : Set (Setoid α))"},
 {"type": "supₛ s = EqvGen.Setoid (supₛ (Rel '' s))",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} {s : Set (Setoid α)} : supₛ s = EqvGen.Setoid (supₛ (Rel '' s)) := by rw [supₛ_eq_eqvGen]; sorry",
  "name": "supₛ_def",
  "kind": "theorem",
  "first-tactic": "rw [supₛ_eq_eqvGen]",
  "core-prompt":
  "{α : Type _}  {β : Type _} {s : Set (Setoid α)} : supₛ s = EqvGen.Setoid (supₛ (Rel '' s))",
  "args": "{α : Type _}  {β : Type _} {s : Set (Setoid α)}"},
 {"type": "EqvGen.Setoid r ≤ s",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} {r : α → α → Prop}  {s : Setoid α}  (h : ∀ x y, r x y → s.Rel x y) : EqvGen.Setoid r ≤ s := by rw [eqvGen_eq]; sorry",
  "name": "eqvGen_le",
  "kind": "theorem",
  "first-tactic": "rw [eqvGen_eq]",
  "core-prompt":
  "{α : Type _}  {β : Type _} {r : α → α → Prop}  {s : Setoid α}  (h : ∀ x y, r x y → s.Rel x y) : EqvGen.Setoid r ≤ s",
  "args":
  "{α : Type _}  {β : Type _} {r : α → α → Prop}  {s : Setoid α}  (h : ∀ x y, r x y → s.Rel x y)"},
 {"type": "Quotient.lift f H = g",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} {r : Setoid α}  {f : α → β}  (H : r ≤ ker f)  (g : Quotient r → β)      (Hg : f = g ∘ Quotient.mk'') : Quotient.lift f H = g := by ext ⟨x⟩; sorry",
  "name": "lift_unique",
  "kind": "theorem",
  "first-tactic": "ext ⟨x⟩",
  "core-prompt":
  "{α : Type _}  {β : Type _} {r : Setoid α}  {f : α → β}  (H : r ≤ ker f)  (g : Quotient r → β)      (Hg : f = g ∘ Quotient.mk'') : Quotient.lift f H = g",
  "args":
  "{α : Type _}  {β : Type _} {r : Setoid α}  {f : α → β}  (H : r ≤ ker f)  (g : Quotient r → β)      (Hg : f = g ∘ Quotient.mk'')"},
 {"type": "map r f = mapOfSurjective r f h hf",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} (r : Setoid α)  (f : α → β) (h : ker f ≤ r)  (hf : Surjective f) : map r f = mapOfSurjective r f h hf := by rw [← eqvGen_of_setoid (mapOfSurjective r f h hf)]; sorry",
  "name": "mapOfSurjective_eq_map",
  "kind": "theorem",
  "first-tactic": "rw [← eqvGen_of_setoid (mapOfSurjective r f h hf)]",
  "core-prompt":
  "{α : Type _}  {β : Type _} (r : Setoid α)  (f : α → β) (h : ker f ≤ r)  (hf : Surjective f) : map r f = mapOfSurjective r f h hf",
  "args":
  "{α : Type _}  {β : Type _} (r : Setoid α)  (f : α → β) (h : ker f ≤ r)  (hf : Surjective f)"},
 {"type": "Subsingleton (Quotient s) ↔ s = ⊤",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} (r : Setoid α)  (f : α → β) {s : Setoid α} : Subsingleton (Quotient s) ↔ s = ⊤ := by simp only [_root_.subsingleton_iff]; sorry",
  "name": "Quotient.subsingleton_iff",
  "kind": "theorem",
  "first-tactic": "simp only [_root_.subsingleton_iff]",
  "core-prompt":
  "{α : Type _}  {β : Type _} (r : Setoid α)  (f : α → β) {s : Setoid α} : Subsingleton (Quotient s) ↔ s = ⊤",
  "args":
  "{α : Type _}  {β : Type _} (r : Setoid α)  (f : α → β) {s : Setoid α}"},
 {"type": "Subsingleton (Quot r) ↔ EqvGen r = ⊤",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} (r : Setoid α)  (f : α → β) (r : α → α → Prop) : Subsingleton (Quot r) ↔ EqvGen r = ⊤ := by simp only [_root_.subsingleton_iff]; sorry",
  "name": "Quot.subsingleton_iff",
  "kind": "theorem",
  "first-tactic": "simp only [_root_.subsingleton_iff]",
  "core-prompt":
  "{α : Type _}  {β : Type _} (r : Setoid α)  (f : α → β) (r : α → α → Prop) : Subsingleton (Quot r) ↔ EqvGen r = ⊤",
  "args":
  "{α : Type _}  {β : Type _} (r : Setoid α)  (f : α → β) (r : α → α → Prop)"},
 {"type":
  "(n - k) * (n - k).ascFactorial k = (n - (k + 1)).ascFactorial (k + 1)",
  "tactic-prompt":
  "theorem {n k : ℕ}  (h : k < n) : (n - k) * (n - k).ascFactorial k = (n - (k + 1)).ascFactorial (k + 1) := by let t := n - k.succ; sorry",
  "name": "ascFactorial_of_sub",
  "kind": "theorem",
  "first-tactic": "let t := n - k.succ",
  "core-prompt":
  "{n k : ℕ}  (h : k < n) : (n - k) * (n - k).ascFactorial k = (n - (k + 1)).ascFactorial (k + 1)",
  "args": "{n k : ℕ}  (h : k < n)"},
 {"type": "(n + 1) ^ (k + 2) < n.ascFactorial (k + 2)",
  "tactic-prompt":
  "theorem (n k : ℕ) : (n + 1) ^ (k + 2) < n.ascFactorial (k + 2) := by rw [pow_succ]; sorry",
  "name": "pow_lt_ascFactorial'",
  "kind": "theorem",
  "first-tactic": "rw [pow_succ]",
  "core-prompt": "(n k : ℕ) : (n + 1) ^ (k + 2) < n.ascFactorial (k + 2)",
  "args": "(n k : ℕ)"},
 {"type": "(0 : ℕ).descFactorial k.succ = 0",
  "tactic-prompt":
  "theorem (k : ℕ) : (0 : ℕ).descFactorial k.succ = 0 := by rw [descFactorial_succ]; sorry",
  "name": "zero_descFactorial_succ",
  "kind": "theorem",
  "first-tactic": "rw [descFactorial_succ]",
  "core-prompt": "(k : ℕ) : (0 : ℕ).descFactorial k.succ = 0",
  "args": "(k : ℕ)"},
 {"type": "n.descFactorial 1 = n",
  "tactic-prompt":
  "theorem (n : ℕ) : n.descFactorial 1 = n := by rw [descFactorial_succ]; sorry",
  "name": "descFactorial_one",
  "kind": "theorem",
  "first-tactic": "rw [descFactorial_succ]",
  "core-prompt": "(n : ℕ) : n.descFactorial 1 = n",
  "args": "(n : ℕ)"},
 {"type": "dist n m = dist m n",
  "tactic-prompt":
  "theorem (n m : ℕ) : dist n m = dist m n := by simp [dist.def]; sorry",
  "name": "dist_comm",
  "kind": "theorem",
  "first-tactic": "simp [dist.def]",
  "core-prompt": "(n m : ℕ) : dist n m = dist m n",
  "args": "(n m : ℕ)"},
 {"type": "dist n n = 0",
  "tactic-prompt":
  "theorem (n : ℕ) : dist n n = 0 := by simp [dist.def]; sorry",
  "name": "dist_self",
  "kind": "theorem",
  "first-tactic": "simp [dist.def]",
  "core-prompt": "(n : ℕ) : dist n n = 0",
  "args": "(n : ℕ)"},
 {"type": "dist n m = 0",
  "tactic-prompt":
  "theorem {n m : ℕ}  (h : n = m) : dist n m = 0 := by rw [h]; sorry",
  "name": "dist_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{n m : ℕ}  (h : n = m) : dist n m = 0",
  "args": "{n m : ℕ}  (h : n = m)"},
 {"type": "dist n m = m - n",
  "tactic-prompt":
  "theorem {n m : ℕ}  (h : n ≤ m) : dist n m = m - n := by rw [dist.def]; sorry",
  "name": "dist_eq_sub_of_le",
  "kind": "theorem",
  "first-tactic": "rw [dist.def]",
  "core-prompt": "{n m : ℕ}  (h : n ≤ m) : dist n m = m - n",
  "args": "{n m : ℕ}  (h : n ≤ m)"},
 {"type": "dist n m = n - m",
  "tactic-prompt":
  "theorem {n m : ℕ}  (h : m ≤ n) : dist n m = n - m := by rw [dist_comm]; sorry",
  "name": "dist_eq_sub_of_le_right",
  "kind": "theorem",
  "first-tactic": "rw [dist_comm]",
  "core-prompt": "{n m : ℕ}  (h : m ≤ n) : dist n m = n - m",
  "args": "{n m : ℕ}  (h : m ≤ n)"},
 {"type": "m ≤ n + dist n m",
  "tactic-prompt":
  "theorem (n m : ℕ) : m ≤ n + dist n m := by rw [add_comm]; sorry",
  "name": "dist_tri_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt": "(n m : ℕ) : m ≤ n + dist n m",
  "args": "(n m : ℕ)"},
 {"type": "n ≤ dist n m + m",
  "tactic-prompt":
  "theorem (n m : ℕ) : n ≤ dist n m + m := by rw [dist_comm]; sorry",
  "name": "dist_tri_left'",
  "kind": "theorem",
  "first-tactic": "rw [dist_comm]",
  "core-prompt": "(n m : ℕ) : n ≤ dist n m + m",
  "args": "(n m : ℕ)"},
 {"type": "n ≤ m + dist n m",
  "tactic-prompt":
  "theorem (n m : ℕ) : n ≤ m + dist n m := by rw [dist_comm]; sorry",
  "name": "dist_tri_right'",
  "kind": "theorem",
  "first-tactic": "rw [dist_comm]",
  "core-prompt": "(n m : ℕ) : n ≤ m + dist n m",
  "args": "(n m : ℕ)"},
 {"type": "dist (k + n) (k + m) = dist n m",
  "tactic-prompt":
  "theorem (k n m : ℕ) : dist (k + n) (k + m) = dist n m := by rw [add_comm k n]; sorry",
  "name": "dist_add_add_left",
  "kind": "theorem",
  "first-tactic": "rw [add_comm k n]",
  "core-prompt": "(k n m : ℕ) : dist (k + n) (k + m) = dist n m",
  "args": "(k n m : ℕ)"},
 {"type": "dist n k ≤ dist n m + dist m k",
  "tactic-prompt":
  "theorem (n m k : ℕ) : dist n k ≤ dist n m + dist m k := by have : dist n m + dist m k = n - m + (m - k) + (k - m + (m - n)) := by\n    simp [dist.def]; sorry",
  "name": "dist.triangle_inequality",
  "kind": "theorem",
  "first-tactic":
  "have : dist n m + dist m k = n - m + (m - k) + (k - m + (m - n)) := by\n    simp [dist.def]",
  "core-prompt": "(n m k : ℕ) : dist n k ≤ dist n m + dist m k",
  "args": "(n m k : ℕ)"},
 {"type": "dist (n * k) (m * k) = dist n m * k",
  "tactic-prompt":
  "theorem (n k m : ℕ) : dist (n * k) (m * k) = dist n m * k := by rw [dist.def]; sorry",
  "name": "dist_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [dist.def]",
  "core-prompt": "(n k m : ℕ) : dist (n * k) (m * k) = dist n m * k",
  "args": "(n k m : ℕ)"},
 {"type": "dist (k * n) (k * m) = k * dist n m",
  "tactic-prompt":
  "theorem (k n m : ℕ) : dist (k * n) (k * m) = k * dist n m := by rw [mul_comm k n]; sorry",
  "name": "dist_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm k n]",
  "core-prompt": "(k n m : ℕ) : dist (k * n) (k * m) = k * dist n m",
  "args": "(k n m : ℕ)"},
 {"type": "dist (succ i) (succ j) = dist i j",
  "tactic-prompt":
  "theorem {i j : Nat} : dist (succ i) (succ j) = dist i j := by simp [dist.def]; sorry",
  "name": "dist_succ_succ",
  "kind": "theorem",
  "first-tactic": "simp [dist.def]",
  "core-prompt": "{i j : Nat} : dist (succ i) (succ j) = dist i j",
  "args": "{i j : Nat}"},
 {"type": "size 0 = 0",
  "tactic-prompt": "theorem  : size 0 = 0 := by simp [size]; sorry",
  "name": "size_zero",
  "kind": "theorem",
  "first-tactic": "simp [size]",
  "core-prompt": " : size 0 = 0",
  "args": ""},
 {"type": "n < 2 ^ size n",
  "tactic-prompt":
  "theorem (n : ℕ) : n < 2 ^ size n := by rw [← one_shiftl]; sorry",
  "name": "lt_size_self",
  "kind": "theorem",
  "first-tactic": "rw [← one_shiftl]",
  "core-prompt": "(n : ℕ) : n < 2 ^ size n",
  "args": "(n : ℕ)"},
 {"type": "m < size n ↔ 2 ^ m ≤ n",
  "tactic-prompt":
  "theorem {m n : ℕ} : m < size n ↔ 2 ^ m ≤ n := by rw [← not_lt]; sorry",
  "name": "lt_size",
  "kind": "theorem",
  "first-tactic": "rw [← not_lt]",
  "core-prompt": "{m n : ℕ} : m < size n ↔ 2 ^ m ≤ n",
  "args": "{m n : ℕ}"},
 {"type": "0 < size n ↔ 0 < n",
  "tactic-prompt":
  "theorem {n : ℕ} : 0 < size n ↔ 0 < n := by rw [lt_size]; sorry",
  "name": "size_pos",
  "kind": "theorem",
  "first-tactic": "rw [lt_size]",
  "core-prompt": "{n : ℕ} : 0 < size n ↔ 0 < n",
  "args": "{n : ℕ}"},
 {"type": "size n = 0 ↔ n = 0",
  "tactic-prompt":
  "theorem {n : ℕ} : size n = 0 ↔ n = 0 := by have := @size_pos n; sorry",
  "name": "size_eq_zero",
  "kind": "theorem",
  "first-tactic": "have := @size_pos n",
  "core-prompt": "{n : ℕ} : size n = 0 ↔ n = 0",
  "args": "{n : ℕ}"},
 {"type": "n.bits.length = n.size",
  "tactic-prompt":
  "theorem (n : ℕ) : n.bits.length = n.size := by induction' n using Nat.binaryRec' with b n h ih; sorry",
  "name": "size_eq_bits_len",
  "kind": "theorem",
  "first-tactic": "induction' n using Nat.binaryRec' with b n h ih",
  "core-prompt": "(n : ℕ) : n.bits.length = n.size",
  "args": "(n : ℕ)"},
 {"type": "choose n 0 = 1",
  "tactic-prompt": "theorem (n : ℕ) : choose n 0 = 1 := by cases n; sorry",
  "name": "choose_zero_right",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n : ℕ) : choose n 0 = 1",
  "args": "(n : ℕ)"},
 {"type": "choose n n = 1",
  "tactic-prompt": "theorem (n : ℕ) : choose n n = 1 := by induction n; sorry",
  "name": "choose_self",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "(n : ℕ) : choose n n = 1",
  "args": "(n : ℕ)"},
 {"type": "choose n 1 = n",
  "tactic-prompt": "theorem (n : ℕ) : choose n 1 = n := by induction n; sorry",
  "name": "choose_one_right",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "(n : ℕ) : choose n 1 = n",
  "args": "(n : ℕ)"},
 {"type": "(n + 1) * (n + 1 - 1) / 2 = n * (n - 1) / 2 + n",
  "tactic-prompt":
  "theorem (n : ℕ) : (n + 1) * (n + 1 - 1) / 2 = n * (n - 1) / 2 + n := by rw [← add_mul_div_left]; sorry",
  "name": "triangle_succ",
  "kind": "theorem",
  "first-tactic": "rw [← add_mul_div_left]",
  "core-prompt": "(n : ℕ) : (n + 1) * (n + 1 - 1) / 2 = n * (n - 1) / 2 + n",
  "args": "(n : ℕ)"},
 {"type": "choose n 2 = n * (n - 1) / 2",
  "tactic-prompt":
  "theorem (n : ℕ) : choose n 2 = n * (n - 1) / 2 := by induction' n with n ih; sorry",
  "name": "choose_two_right",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt": "(n : ℕ) : choose n 2 = n * (n - 1) / 2",
  "args": "(n : ℕ)"},
 {"type": "n.choose k * k.choose s = n.choose s * (n - s).choose (k - s)",
  "tactic-prompt":
  "theorem {n k s : ℕ}  (hkn : k ≤ n)  (hsk : s ≤ k) : n.choose k * k.choose s = n.choose s * (n - s).choose (k - s) := by have h : 0 < (n - k); sorry",
  "name": "choose_mul",
  "kind": "theorem",
  "first-tactic": "have h : 0 < (n - k)",
  "core-prompt":
  "{n k s : ℕ}  (hkn : k ≤ n)  (hsk : s ≤ k) : n.choose k * k.choose s = n.choose s * (n - s).choose (k - s)",
  "args": "{n k s : ℕ}  (hkn : k ≤ n)  (hsk : s ≤ k)"},
 {"type": "choose n (n - k) = choose n k",
  "tactic-prompt":
  "theorem {n k : ℕ}  (hk : k ≤ n) : choose n (n - k) = choose n k := by rw [choose_eq_factorial_div_factorial hk]; sorry",
  "name": "choose_symm",
  "kind": "theorem",
  "first-tactic": "rw [choose_eq_factorial_div_factorial hk]",
  "core-prompt": "{n k : ℕ}  (hk : k ≤ n) : choose n (n - k) = choose n k",
  "args": "{n k : ℕ}  (hk : k ≤ n)"},
 {"type": "Nat.choose n a = Nat.choose n b",
  "tactic-prompt":
  "theorem {n a b : ℕ}  (h : n = a + b) : Nat.choose n a = Nat.choose n b := by suffices : choose n (n - b) = choose n b; sorry",
  "name": "choose_symm_of_eq_add",
  "kind": "theorem",
  "first-tactic": "suffices : choose n (n - b) = choose n b",
  "core-prompt":
  "{n a b : ℕ}  (h : n = a + b) : Nat.choose n a = Nat.choose n b",
  "args": "{n a b : ℕ}  (h : n = a + b)"},
 {"type": "choose (2 * m + 1) (m + 1) = choose (2 * m + 1) m",
  "tactic-prompt":
  "theorem (m : ℕ) : choose (2 * m + 1) (m + 1) = choose (2 * m + 1) m := by apply choose_symm_of_eq_add; sorry",
  "name": "choose_symm_half",
  "kind": "theorem",
  "first-tactic": "apply choose_symm_of_eq_add",
  "core-prompt": "(m : ℕ) : choose (2 * m + 1) (m + 1) = choose (2 * m + 1) m",
  "args": "(m : ℕ)"},
 {"type": "choose n (k + 1) * (k + 1) = choose n k * (n - k)",
  "tactic-prompt":
  "theorem (n k : ℕ) : choose n (k + 1) * (k + 1) = choose n k * (n - k) := by have e : (n + 1) * choose n k = choose n k * (k + 1) + choose n (k + 1) * (k + 1); sorry",
  "name": "choose_succ_right_eq",
  "kind": "theorem",
  "first-tactic":
  "have e : (n + 1) * choose n k = choose n k * (k + 1) + choose n (k + 1) * (k + 1)",
  "core-prompt":
  "(n k : ℕ) : choose n (k + 1) * (k + 1) = choose n k * (n - k)",
  "args": "(n k : ℕ)"},
 {"type": "n.choose k * (n + 1) = (n + 1).choose k * (n + 1 - k)",
  "tactic-prompt":
  "theorem (n k : ℕ) : n.choose k * (n + 1) = (n + 1).choose k * (n + 1 - k) := by induction' k with k _; sorry",
  "name": "choose_mul_succ_eq",
  "kind": "theorem",
  "first-tactic": "induction' k with k _",
  "core-prompt":
  "(n k : ℕ) : n.choose k * (n + 1) = (n + 1).choose k * (n + 1 - k)",
  "args": "(n k : ℕ)"},
 {"type": "choose n r ≤ choose n (r + 1)",
  "tactic-prompt":
  "theorem {r n : ℕ}  (h : r < n / 2) : choose n r ≤ choose n (r + 1) := by refine' le_of_mul_le_mul_right _ (lt_tsub_iff_left.mpr (lt_of_lt_of_le h (n.div_le_self 2))); sorry",
  "name": "choose_le_succ_of_lt_half_left",
  "kind": "theorem",
  "first-tactic":
  "refine' le_of_mul_le_mul_right _ (lt_tsub_iff_left.mpr (lt_of_lt_of_le h (n.div_le_self 2)))",
  "core-prompt": "{r n : ℕ}  (h : r < n / 2) : choose n r ≤ choose n (r + 1)",
  "args": "{r n : ℕ}  (h : r < n / 2)"},
 {"type": "choose n r ≤ choose n (n / 2)",
  "tactic-prompt":
  "theorem (r n : ℕ) : choose n r ≤ choose n (n / 2) := by cases' le_or_gt r n with b b; sorry",
  "name": "choose_le_middle",
  "kind": "theorem",
  "first-tactic": "cases' le_or_gt r n with b b",
  "core-prompt": "(r n : ℕ) : choose n r ≤ choose n (n / 2)",
  "args": "(r n : ℕ)"},
 {"type": "choose a c ≤ choose a.succ c",
  "tactic-prompt":
  "theorem (a c : ℕ) : choose a c ≤ choose a.succ c := by cases c; sorry",
  "name": "choose_le_succ",
  "kind": "theorem",
  "first-tactic": "cases c",
  "core-prompt": "(a c : ℕ) : choose a c ≤ choose a.succ c",
  "args": "(a c : ℕ)"},
 {"type": "choose a c ≤ choose (a + b) c",
  "tactic-prompt":
  "theorem (a b c : ℕ) : choose a c ≤ choose (a + b) c := by induction' b with b_n b_ih; sorry",
  "name": "choose_le_add",
  "kind": "theorem",
  "first-tactic": "induction' b with b_n b_ih",
  "core-prompt": "(a b c : ℕ) : choose a c ≤ choose (a + b) c",
  "args": "(a b c : ℕ)"},
 {"type": "multichoose n 0 = 1",
  "tactic-prompt": "theorem (n : ℕ) : multichoose n 0 = 1 := by cases n; sorry",
  "name": "multichoose_zero_right",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n : ℕ) : multichoose n 0 = 1",
  "args": "(n : ℕ)"},
 {"type": "multichoose 0 (k + 1) = 0",
  "tactic-prompt":
  "theorem (k : ℕ) : multichoose 0 (k + 1) = 0 := by simp [multichoose]; sorry",
  "name": "multichoose_zero_succ",
  "kind": "theorem",
  "first-tactic": "simp [multichoose]",
  "core-prompt": "(k : ℕ) : multichoose 0 (k + 1) = 0",
  "args": "(k : ℕ)"},
 {"type":
  "multichoose (n + 1) (k + 1) = multichoose n (k + 1) + multichoose (n + 1) k",
  "tactic-prompt":
  "theorem (n k : ℕ) : multichoose (n + 1) (k + 1) = multichoose n (k + 1) + multichoose (n + 1) k := by simp [multichoose]; sorry",
  "name": "multichoose_succ_succ",
  "kind": "theorem",
  "first-tactic": "simp [multichoose]",
  "core-prompt":
  "(n k : ℕ) : multichoose (n + 1) (k + 1) = multichoose n (k + 1) + multichoose (n + 1) k",
  "args": "(n k : ℕ)"},
 {"type": "multichoose 1 k = 1",
  "tactic-prompt":
  "theorem (k : ℕ) : multichoose 1 k = 1 := by induction' k with k IH; sorry",
  "name": "multichoose_one",
  "kind": "theorem",
  "first-tactic": "induction' k with k IH",
  "core-prompt": "(k : ℕ) : multichoose 1 k = 1",
  "args": "(k : ℕ)"},
 {"type": "multichoose 2 k = k + 1",
  "tactic-prompt":
  "theorem (k : ℕ) : multichoose 2 k = k + 1 := by induction' k with k IH; sorry",
  "name": "multichoose_two",
  "kind": "theorem",
  "first-tactic": "induction' k with k IH",
  "core-prompt": "(k : ℕ) : multichoose 2 k = k + 1",
  "args": "(k : ℕ)"},
 {"type": "multichoose n 1 = n",
  "tactic-prompt":
  "theorem (n : ℕ) : multichoose n 1 = n := by induction' n with n IH; sorry",
  "name": "multichoose_one_right",
  "kind": "theorem",
  "first-tactic": "induction' n with n IH",
  "core-prompt": "(n : ℕ) : multichoose n 1 = n",
  "args": "(n : ℕ)"},
 {"type": "gcd m (n + k * m) = gcd m n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : gcd m (n + k * m) = gcd m n := by simp [gcd_rec m (n + k * m)]; sorry",
  "name": "gcd_add_mul_right_right",
  "kind": "theorem",
  "first-tactic": "simp [gcd_rec m (n + k * m)]",
  "core-prompt": "(m n k : ℕ) : gcd m (n + k * m) = gcd m n",
  "args": "(m n k : ℕ)"},
 {"type": "gcd m (n + m * k) = gcd m n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : gcd m (n + m * k) = gcd m n := by simp [gcd_rec m (n + m * k)]; sorry",
  "name": "gcd_add_mul_left_right",
  "kind": "theorem",
  "first-tactic": "simp [gcd_rec m (n + m * k)]",
  "core-prompt": "(m n k : ℕ) : gcd m (n + m * k) = gcd m n",
  "args": "(m n k : ℕ)"},
 {"type": "gcd m (k * m + n) = gcd m n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : gcd m (k * m + n) = gcd m n := by simp [add_comm _ n]; sorry",
  "name": "gcd_mul_right_add_right",
  "kind": "theorem",
  "first-tactic": "simp [add_comm _ n]",
  "core-prompt": "(m n k : ℕ) : gcd m (k * m + n) = gcd m n",
  "args": "(m n k : ℕ)"},
 {"type": "gcd m (m * k + n) = gcd m n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : gcd m (m * k + n) = gcd m n := by simp [add_comm _ n]; sorry",
  "name": "gcd_mul_left_add_right",
  "kind": "theorem",
  "first-tactic": "simp [add_comm _ n]",
  "core-prompt": "(m n k : ℕ) : gcd m (m * k + n) = gcd m n",
  "args": "(m n k : ℕ)"},
 {"type": "gcd (m + k * n) n = gcd m n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : gcd (m + k * n) n = gcd m n := by rw [gcd_comm]; sorry",
  "name": "gcd_add_mul_right_left",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n k : ℕ) : gcd (m + k * n) n = gcd m n",
  "args": "(m n k : ℕ)"},
 {"type": "gcd (m + n * k) n = gcd m n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : gcd (m + n * k) n = gcd m n := by rw [gcd_comm]; sorry",
  "name": "gcd_add_mul_left_left",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n k : ℕ) : gcd (m + n * k) n = gcd m n",
  "args": "(m n k : ℕ)"},
 {"type": "gcd (k * n + m) n = gcd m n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : gcd (k * n + m) n = gcd m n := by rw [gcd_comm]; sorry",
  "name": "gcd_mul_right_add_left",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n k : ℕ) : gcd (k * n + m) n = gcd m n",
  "args": "(m n k : ℕ)"},
 {"type": "gcd (n * k + m) n = gcd m n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : gcd (n * k + m) n = gcd m n := by rw [gcd_comm]; sorry",
  "name": "gcd_mul_left_add_left",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n k : ℕ) : gcd (n * k + m) n = gcd m n",
  "args": "(m n k : ℕ)"},
 {"type": "gcd (m + n) n = gcd m n",
  "tactic-prompt":
  "theorem (m n : ℕ) : gcd (m + n) n = gcd m n := by rw [gcd_comm]; sorry",
  "name": "gcd_add_self_left",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n : ℕ) : gcd (m + n) n = gcd m n",
  "args": "(m n : ℕ)"},
 {"type": "gcd (m + n) m = gcd n m",
  "tactic-prompt":
  "theorem (m n : ℕ) : gcd (m + n) m = gcd n m := by rw [add_comm]; sorry",
  "name": "gcd_self_add_left",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt": "(m n : ℕ) : gcd (m + n) m = gcd n m",
  "args": "(m n : ℕ)"},
 {"type": "gcd m (m + n) = gcd m n",
  "tactic-prompt":
  "theorem (m n : ℕ) : gcd m (m + n) = gcd m n := by rw [add_comm]; sorry",
  "name": "gcd_self_add_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt": "(m n : ℕ) : gcd m (m + n) = gcd m n",
  "args": "(m n : ℕ)"},
 {"type": "Decidable (coprime m n)",
  "tactic-prompt":
  "instance (m n : ℕ) : Decidable (coprime m n) := by unfold coprime; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "unfold coprime",
  "core-prompt": "(m n : ℕ) : Decidable (coprime m n)",
  "args": "(m n : ℕ)"},
 {"type": "lcm m n = m * n",
  "tactic-prompt":
  "theorem {m n : ℕ}  (h : coprime m n) : lcm m n = m * n := by rw [← one_mul (lcm m n)]; sorry",
  "name": "coprime.lcm_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [← one_mul (lcm m n)]",
  "core-prompt": "{m n : ℕ}  (h : coprime m n) : lcm m n = m * n",
  "args": "{m n : ℕ}  (h : coprime m n)"},
 {"type": "coprime m (n + m) ↔ coprime m n",
  "tactic-prompt":
  "theorem {m n : ℕ} : coprime m (n + m) ↔ coprime m n := by rw [coprime]; sorry",
  "name": "coprime_add_self_right",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "{m n : ℕ} : coprime m (n + m) ↔ coprime m n",
  "args": "{m n : ℕ}"},
 {"type": "coprime m (m + n) ↔ coprime m n",
  "tactic-prompt":
  "theorem {m n : ℕ} : coprime m (m + n) ↔ coprime m n := by rw [add_comm]; sorry",
  "name": "coprime_self_add_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt": "{m n : ℕ} : coprime m (m + n) ↔ coprime m n",
  "args": "{m n : ℕ}"},
 {"type": "coprime (m + n) n ↔ coprime m n",
  "tactic-prompt":
  "theorem {m n : ℕ} : coprime (m + n) n ↔ coprime m n := by rw [coprime]; sorry",
  "name": "coprime_add_self_left",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "{m n : ℕ} : coprime (m + n) n ↔ coprime m n",
  "args": "{m n : ℕ}"},
 {"type": "coprime (m + n) m ↔ coprime n m",
  "tactic-prompt":
  "theorem {m n : ℕ} : coprime (m + n) m ↔ coprime n m := by rw [coprime]; sorry",
  "name": "coprime_self_add_left",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "{m n : ℕ} : coprime (m + n) m ↔ coprime n m",
  "args": "{m n : ℕ}"},
 {"type": "coprime m (n + k * m) ↔ coprime m n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : coprime m (n + k * m) ↔ coprime m n := by rw [coprime]; sorry",
  "name": "coprime_add_mul_right_right",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "(m n k : ℕ) : coprime m (n + k * m) ↔ coprime m n",
  "args": "(m n k : ℕ)"},
 {"type": "coprime m (n + m * k) ↔ coprime m n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : coprime m (n + m * k) ↔ coprime m n := by rw [coprime]; sorry",
  "name": "coprime_add_mul_left_right",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "(m n k : ℕ) : coprime m (n + m * k) ↔ coprime m n",
  "args": "(m n k : ℕ)"},
 {"type": "coprime m (k * m + n) ↔ coprime m n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : coprime m (k * m + n) ↔ coprime m n := by rw [coprime]; sorry",
  "name": "coprime_mul_right_add_right",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "(m n k : ℕ) : coprime m (k * m + n) ↔ coprime m n",
  "args": "(m n k : ℕ)"},
 {"type": "coprime m (m * k + n) ↔ coprime m n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : coprime m (m * k + n) ↔ coprime m n := by rw [coprime]; sorry",
  "name": "coprime_mul_left_add_right",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "(m n k : ℕ) : coprime m (m * k + n) ↔ coprime m n",
  "args": "(m n k : ℕ)"},
 {"type": "coprime (m + k * n) n ↔ coprime m n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : coprime (m + k * n) n ↔ coprime m n := by rw [coprime]; sorry",
  "name": "coprime_add_mul_right_left",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "(m n k : ℕ) : coprime (m + k * n) n ↔ coprime m n",
  "args": "(m n k : ℕ)"},
 {"type": "coprime (m + n * k) n ↔ coprime m n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : coprime (m + n * k) n ↔ coprime m n := by rw [coprime]; sorry",
  "name": "coprime_add_mul_left_left",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "(m n k : ℕ) : coprime (m + n * k) n ↔ coprime m n",
  "args": "(m n k : ℕ)"},
 {"type": "coprime (k * n + m) n ↔ coprime m n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : coprime (k * n + m) n ↔ coprime m n := by rw [coprime]; sorry",
  "name": "coprime_mul_right_add_left",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "(m n k : ℕ) : coprime (k * n + m) n ↔ coprime m n",
  "args": "(m n k : ℕ)"},
 {"type": "coprime (n * k + m) n ↔ coprime m n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : coprime (n * k + m) n ↔ coprime m n := by rw [coprime]; sorry",
  "name": "coprime_mul_left_add_left",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "(m n k : ℕ) : coprime (n * k + m) n ↔ coprime m n",
  "args": "(m n k : ℕ)"},
 {"type": "Nat.coprime (a ^ n) b ↔ Nat.coprime a b",
  "tactic-prompt":
  "theorem {n : ℕ}  (hn : 0 < n)  (a b : ℕ) : Nat.coprime (a ^ n) b ↔ Nat.coprime a b := by obtain ⟨n, rfl⟩ := exists_eq_succ_of_ne_zero hn.ne'; sorry",
  "name": "coprime_pow_left_iff",
  "kind": "theorem",
  "first-tactic": "obtain ⟨n, rfl⟩ := exists_eq_succ_of_ne_zero hn.ne'",
  "core-prompt":
  "{n : ℕ}  (hn : 0 < n)  (a b : ℕ) : Nat.coprime (a ^ n) b ↔ Nat.coprime a b",
  "args": "{n : ℕ}  (hn : 0 < n)  (a b : ℕ)"},
 {"type": "Nat.coprime a (b ^ n) ↔ Nat.coprime a b",
  "tactic-prompt":
  "theorem {n : ℕ}  (hn : 0 < n)  (a b : ℕ) : Nat.coprime a (b ^ n) ↔ Nat.coprime a b := by rw [Nat.coprime_comm]; sorry",
  "name": "coprime_pow_right_iff",
  "kind": "theorem",
  "first-tactic": "rw [Nat.coprime_comm]",
  "core-prompt":
  "{n : ℕ}  (hn : 0 < n)  (a b : ℕ) : Nat.coprime a (b ^ n) ↔ Nat.coprime a b",
  "args": "{n : ℕ}  (hn : 0 < n)  (a b : ℕ)"},
 {"type": "¬coprime 0 0",
  "tactic-prompt": "theorem  : ¬coprime 0 0 := by simp; sorry",
  "name": "not_coprime_zero_zero",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : ¬coprime 0 0",
  "args": ""},
 {"type": "coprime 1 n ↔ True",
  "tactic-prompt":
  "theorem (n : ℕ) : coprime 1 n ↔ True := by simp [coprime]; sorry",
  "name": "coprime_one_left_iff",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : ℕ) : coprime 1 n ↔ True",
  "args": "(n : ℕ)"},
 {"type": "coprime n 1 ↔ True",
  "tactic-prompt":
  "theorem (n : ℕ) : coprime n 1 ↔ True := by simp [coprime]; sorry",
  "name": "coprime_one_right_iff",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : ℕ) : coprime n 1 ↔ True",
  "args": "(n : ℕ)"},
 {"type": "gcd (a * b) c = b",
  "tactic-prompt":
  "theorem {a b c : ℕ}  (hac : coprime a c)  (b_dvd_c : b ∣ c) : gcd (a * b) c = b := by rcases exists_eq_mul_left_of_dvd b_dvd_c with ⟨d, rfl⟩; sorry",
  "name": "gcd_mul_of_coprime_of_dvd",
  "kind": "theorem",
  "first-tactic": "rcases exists_eq_mul_left_of_dvd b_dvd_c with ⟨d, rfl⟩",
  "core-prompt":
  "{a b c : ℕ}  (hac : coprime a c)  (b_dvd_c : b ∣ c) : gcd (a * b) c = b",
  "args": "{a b c : ℕ}  (hac : coprime a c)  (b_dvd_c : b ∣ c)"},
 {"type": "{ d : { m' // m' ∣ m } × { n' // n' ∣ n } // k = d.1 * d.2 }",
  "tactic-prompt":
  "def {m n k : ℕ}  (H : k ∣ m * n) : { d : { m' // m' ∣ m } × { n' // n' ∣ n } // k = d.1 * d.2 } := by cases h0 : gcd k m; sorry",
  "name": "prodDvdAndDvdOfDvdProd",
  "kind": "def",
  "first-tactic": "cases h0 : gcd k m",
  "core-prompt":
  "{m n k : ℕ}  (H : k ∣ m * n) : { d : { m' // m' ∣ m } × { n' // n' ∣ n } // k = d.1 * d.2 }",
  "args": "{m n k : ℕ}  (H : k ∣ m * n)"},
 {"type": "x ∣ m * n ↔ ∃ y z, y ∣ m ∧ z ∣ n ∧ y * z = x",
  "tactic-prompt":
  "theorem {x m n : ℕ} : x ∣ m * n ↔ ∃ y z, y ∣ m ∧ z ∣ n ∧ y * z = x := by constructor; sorry",
  "name": "dvd_mul",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{x m n : ℕ} : x ∣ m * n ↔ ∃ y z, y ∣ m ∧ z ∣ n ∧ y * z = x",
  "args": "{x m n : ℕ}"},
 {"type": "a ^ n ∣ b ^ n ↔ a ∣ b",
  "tactic-prompt":
  "theorem {a b n : ℕ}  (n0 : 0 < n) : a ^ n ∣ b ^ n ↔ a ∣ b := by refine' ⟨fun h => _, fun h => pow_dvd_pow_of_dvd h _⟩; sorry",
  "name": "pow_dvd_pow_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, fun h => pow_dvd_pow_of_dvd h _⟩",
  "core-prompt": "{a b n : ℕ}  (n0 : 0 < n) : a ^ n ∣ b ^ n ↔ a ∣ b",
  "args": "{a b n : ℕ}  (n0 : 0 < n)"},
 {"type": "k = 1",
  "tactic-prompt":
  "theorem {a b k : ℕ}  (h_ab_coprime : coprime a b)  (hka : k ∣ a)      (hkb : k ∣ b) : k = 1 := by rw [coprime_iff_gcd_eq_one] at h_ab_coprime; sorry",
  "name": "eq_one_of_dvd_coprimes",
  "kind": "theorem",
  "first-tactic": "rw [coprime_iff_gcd_eq_one] at h_ab_coprime",
  "core-prompt":
  "{a b k : ℕ}  (h_ab_coprime : coprime a b)  (hka : k ∣ a)      (hkb : k ∣ b) : k = 1",
  "args":
  "{a b k : ℕ}  (h_ab_coprime : coprime a b)  (hka : k ∣ a)      (hkb : k ∣ b)"},
 {"type": "a * m + b * n ≠ m * n",
  "tactic-prompt":
  "theorem {m n a b : ℕ}  (cop : coprime m n)  (ha : a ≠ 0)  (hb : b ≠ 0) : a * m + b * n ≠ m * n := by intro h; sorry",
  "name": "coprime.mul_add_mul_ne_mul",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{m n a b : ℕ}  (cop : coprime m n)  (ha : a ≠ 0)  (hb : b ≠ 0) : a * m + b * n ≠ m * n",
  "args": "{m n a b : ℕ}  (cop : coprime m n)  (ha : a ≠ 0)  (hb : b ≠ 0)"},
 {"type": "((m / n : ℕ) : α) = m / n",
  "tactic-prompt":
  "theorem {α : Type _} [Field α]  {m n : ℕ}  (n_dvd : n ∣ m)  (n_nonzero : (n : α) ≠ 0) : ((m / n : ℕ) : α) = m / n := by rcases n_dvd with ⟨k, rfl⟩; sorry",
  "name": "cast_div",
  "kind": "theorem",
  "first-tactic": "rcases n_dvd with ⟨k, rfl⟩",
  "core-prompt":
  "{α : Type _} [Field α]  {m n : ℕ}  (n_dvd : n ∣ m)  (n_nonzero : (n : α) ≠ 0) : ((m / n : ℕ) : α) = m / n",
  "args":
  "{α : Type _} [Field α]  {m n : ℕ}  (n_dvd : n ∣ m)  (n_nonzero : (n : α) ≠ 0)"},
 {"type": "(↑(m / d) : α) / (↑(n / d) : α) = (m : α) / n",
  "tactic-prompt":
  "theorem {α : Type _} [Field α]  [CharZero α]  {m n d : ℕ}  (hn : d ∣ n)  (hm : d ∣ m) : (↑(m / d) : α) / (↑(n / d) : α) = (m : α) / n := by rcases eq_or_ne d 0 with (rfl | hd); sorry",
  "name": "cast_div_div_div_cancel_right",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne d 0 with (rfl | hd)",
  "core-prompt":
  "{α : Type _} [Field α]  [CharZero α]  {m n d : ℕ}  (hn : d ∣ n)  (hm : d ∣ m) : (↑(m / d) : α) / (↑(n / d) : α) = (m : α) / n",
  "args":
  "{α : Type _} [Field α]  [CharZero α]  {m n d : ℕ}  (hn : d ∣ n)  (hm : d ∣ m)"},
 {"type": "((m / n : ℕ) : α) ≤ m / n",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedSemifield α] {m n : ℕ} : ((m / n : ℕ) : α) ≤ m / n := by cases n; sorry",
  "name": "cast_div_le",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{α : Type _}  [LinearOrderedSemifield α] {m n : ℕ} : ((m / n : ℕ) : α) ≤ m / n",
  "args": "{α : Type _}  [LinearOrderedSemifield α] {m n : ℕ}"},
 {"type": "0 < 1 / ((n : α) + 1)",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedSemifield α] {n : ℕ} : 0 < 1 / ((n : α) + 1) := by rw [one_div]; sorry",
  "name": "one_div_pos_of_nat",
  "kind": "theorem",
  "first-tactic": "rw [one_div]",
  "core-prompt":
  "{α : Type _}  [LinearOrderedSemifield α] {n : ℕ} : 0 < 1 / ((n : α) + 1)",
  "args": "{α : Type _}  [LinearOrderedSemifield α] {n : ℕ}"},
 {"type": "1 / ((m : α) + 1) ≤ 1 / ((n : α) + 1)",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedSemifield α] {n m : ℕ}  (h : n ≤ m) : 1 / ((m : α) + 1) ≤ 1 / ((n : α) + 1) := by refine' one_div_le_one_div_of_le _ _; sorry",
  "name": "one_div_le_one_div",
  "kind": "theorem",
  "first-tactic": "refine' one_div_le_one_div_of_le _ _",
  "core-prompt":
  "{α : Type _}  [LinearOrderedSemifield α] {n m : ℕ}  (h : n ≤ m) : 1 / ((m : α) + 1) ≤ 1 / ((n : α) + 1)",
  "args": "{α : Type _}  [LinearOrderedSemifield α] {n m : ℕ}  (h : n ≤ m)"},
 {"type": "1 / ((m : α) + 1) < 1 / ((n : α) + 1)",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedSemifield α] {n m : ℕ}  (h : n < m) : 1 / ((m : α) + 1) < 1 / ((n : α) + 1) := by refine' one_div_lt_one_div_of_lt _ _; sorry",
  "name": "one_div_lt_one_div",
  "kind": "theorem",
  "first-tactic": "refine' one_div_lt_one_div_of_lt _ _",
  "core-prompt":
  "{α : Type _}  [LinearOrderedSemifield α] {n m : ℕ}  (h : n < m) : 1 / ((m : α) + 1) < 1 / ((n : α) + 1)",
  "args": "{α : Type _}  [LinearOrderedSemifield α] {n m : ℕ}  (h : n < m)"},
 {"type": "((ite P m n : ℕ) : R) = ite P (m : R) (n : R)",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] (P : Prop)  [Decidable P]  (m n : ℕ) : ((ite P m n : ℕ) : R) = ite P (m : R) (n : R) := by split_ifs; sorry",
  "name": "cast_ite",
  "kind": "theorem",
  "first-tactic": "split_ifs",
  "core-prompt":
  "[AddMonoidWithOne R] (P : Prop)  [Decidable P]  (m n : ℕ) : ((ite P m n : ℕ) : R) = ite P (m : R) (n : R)",
  "args": "[AddMonoidWithOne R] (P : Prop)  [Decidable P]  (m n : ℕ)"},
 {"type": "((1 : ℕ) : R) = 1",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] [AddMonoidWithOne R] : ((1 : ℕ) : R) = 1 := by rw [cast_succ]; sorry",
  "name": "cast_one",
  "kind": "theorem",
  "first-tactic": "rw [cast_succ]",
  "core-prompt":
  "[AddMonoidWithOne R] [AddMonoidWithOne R] : ((1 : ℕ) : R) = 1",
  "args": "[AddMonoidWithOne R] [AddMonoidWithOne R]"},
 {"type": "((m + n : ℕ) : R) = m + n",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] [AddMonoidWithOne R]  (m n : ℕ) : ((m + n : ℕ) : R) = m + n := by induction n; sorry",
  "name": "cast_add",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "[AddMonoidWithOne R] [AddMonoidWithOne R]  (m n : ℕ) : ((m + n : ℕ) : R) = m + n",
  "args": "[AddMonoidWithOne R] [AddMonoidWithOne R]  (m n : ℕ)"},
 {"type": "(Nat.binCast n : R) = ((n : ℕ) : R)",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] [AddMonoidWithOne R]  (n : ℕ) : (Nat.binCast n : R) = ((n : ℕ) : R) := by apply Nat.strongInductionOn n; sorry",
  "name": "binCast_eq",
  "kind": "theorem",
  "first-tactic": "apply Nat.strongInductionOn n",
  "core-prompt":
  "[AddMonoidWithOne R] [AddMonoidWithOne R]  (n : ℕ) : (Nat.binCast n : R) = ((n : ℕ) : R)",
  "args": "[AddMonoidWithOne R] [AddMonoidWithOne R]  (n : ℕ)"},
 {"type": "((bit1 n : ℕ) : R) = bit1 (n : R)",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R]  [AddMonoidWithOne R]  (n : ℕ) : ((bit1 n : ℕ) : R) = bit1 (n : R) := by rw [bit1]; sorry",
  "name": "cast_bit1",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "[AddMonoidWithOne R]  [AddMonoidWithOne R]  (n : ℕ) : ((bit1 n : ℕ) : R) = bit1 (n : R)",
  "args": "[AddMonoidWithOne R]  [AddMonoidWithOne R]  (n : ℕ)"},
 {"type": "1 + 1 = (2 : α)",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] [AddMonoidWithOne α] : 1 + 1 = (2 : α) := by rw [←Nat.cast_one]; sorry",
  "name": "one_add_one_eq_two",
  "kind": "theorem",
  "first-tactic": "rw [←Nat.cast_one]",
  "core-prompt": "[AddMonoidWithOne R] [AddMonoidWithOne α] : 1 + 1 = (2 : α)",
  "args": "[AddMonoidWithOne R] [AddMonoidWithOne α]"},
 {"type": "2 + 1 = (3 : α)",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] [AddMonoidWithOne α] : 2 + 1 = (3 : α) := by rw [←one_add_one_eq_two]; sorry",
  "name": "two_add_one_eq_three",
  "kind": "theorem",
  "first-tactic": "rw [←one_add_one_eq_two]",
  "core-prompt": "[AddMonoidWithOne R] [AddMonoidWithOne α] : 2 + 1 = (3 : α)",
  "args": "[AddMonoidWithOne R] [AddMonoidWithOne α]"},
 {"type": "3 + 1 = (4 : α)",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] [AddMonoidWithOne α] : 3 + 1 = (4 : α) := by rw [←two_add_one_eq_three]; sorry",
  "name": "three_add_one_eq_four",
  "kind": "theorem",
  "first-tactic": "rw [←two_add_one_eq_three]",
  "core-prompt": "[AddMonoidWithOne R] [AddMonoidWithOne α] : 3 + 1 = (4 : α)",
  "args": "[AddMonoidWithOne R] [AddMonoidWithOne α]"},
 {"type": "((m * n : ℕ) : α) = m * n",
  "tactic-prompt":
  "theorem {α β : Type _} [NonAssocSemiring α]  (m n : ℕ) : ((m * n : ℕ) : α) = m * n := by induction n; sorry",
  "name": "cast_mul",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{α β : Type _} [NonAssocSemiring α]  (m n : ℕ) : ((m * n : ℕ) : α) = m * n",
  "args": "{α β : Type _} [NonAssocSemiring α]  (m n : ℕ)"},
 {"type": "Commute (n : α) x",
  "tactic-prompt":
  "theorem {α β : Type _} [NonAssocSemiring α]  (n : ℕ)  (x : α) : Commute (n : α) x := by induction n; sorry",
  "name": "cast_commute",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{α β : Type _} [NonAssocSemiring α]  (n : ℕ)  (x : α) : Commute (n : α) x",
  "args": "{α β : Type _} [NonAssocSemiring α]  (n : ℕ)  (x : α)"},
 {"type": "(0 : α) < n ↔ 0 < n",
  "tactic-prompt":
  "theorem {α β : Type _}  [OrderedSemiring α]  -- porting note: missing mono attribute -- @[mono]  [Nontrivial α] {n : ℕ} : (0 : α) < n ↔ 0 < n := by cases n; sorry",
  "name": "cast_pos",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{α β : Type _}  [OrderedSemiring α]  -- porting note: missing mono attribute -- @[mono]  [Nontrivial α] {n : ℕ} : (0 : α) < n ↔ 0 < n",
  "args":
  "{α β : Type _}  [OrderedSemiring α]  -- porting note: missing mono attribute -- @[mono]  [Nontrivial α] {n : ℕ}"},
 {"type": "1 < (n : α) ↔ 1 < n",
  "tactic-prompt":
  "theorem {α β : Type _}  [OrderedSemiring α]  -- porting note: missing mono attribute -- @[mono] [CharZero α]  {m n : ℕ} : 1 < (n : α) ↔ 1 < n := by rw [← cast_one]; sorry",
  "name": "one_lt_cast",
  "kind": "theorem",
  "first-tactic": "rw [← cast_one]",
  "core-prompt":
  "{α β : Type _}  [OrderedSemiring α]  -- porting note: missing mono attribute -- @[mono] [CharZero α]  {m n : ℕ} : 1 < (n : α) ↔ 1 < n",
  "args":
  "{α β : Type _}  [OrderedSemiring α]  -- porting note: missing mono attribute -- @[mono] [CharZero α]  {m n : ℕ}"},
 {"type": "1 ≤ (n : α) ↔ 1 ≤ n",
  "tactic-prompt":
  "theorem {α β : Type _}  [OrderedSemiring α]  -- porting note: missing mono attribute -- @[mono] [CharZero α]  {m n : ℕ} : 1 ≤ (n : α) ↔ 1 ≤ n := by rw [← cast_one]; sorry",
  "name": "one_le_cast",
  "kind": "theorem",
  "first-tactic": "rw [← cast_one]",
  "core-prompt":
  "{α β : Type _}  [OrderedSemiring α]  -- porting note: missing mono attribute -- @[mono] [CharZero α]  {m n : ℕ} : 1 ≤ (n : α) ↔ 1 ≤ n",
  "args":
  "{α β : Type _}  [OrderedSemiring α]  -- porting note: missing mono attribute -- @[mono] [CharZero α]  {m n : ℕ}"},
 {"type": "(n : α) < 1 ↔ n = 0",
  "tactic-prompt":
  "theorem {α β : Type _}  [OrderedSemiring α]  -- porting note: missing mono attribute -- @[mono] [CharZero α]  {m n : ℕ} : (n : α) < 1 ↔ n = 0 := by rw [← cast_one]; sorry",
  "name": "cast_lt_one",
  "kind": "theorem",
  "first-tactic": "rw [← cast_one]",
  "core-prompt":
  "{α β : Type _}  [OrderedSemiring α]  -- porting note: missing mono attribute -- @[mono] [CharZero α]  {m n : ℕ} : (n : α) < 1 ↔ n = 0",
  "args":
  "{α β : Type _}  [OrderedSemiring α]  -- porting note: missing mono attribute -- @[mono] [CharZero α]  {m n : ℕ}"},
 {"type": "(n : α) ≤ 1 ↔ n ≤ 1",
  "tactic-prompt":
  "theorem {α β : Type _}  [OrderedSemiring α]  -- porting note: missing mono attribute -- @[mono] [CharZero α]  {m n : ℕ} : (n : α) ≤ 1 ↔ n ≤ 1 := by rw [← cast_one]; sorry",
  "name": "cast_le_one",
  "kind": "theorem",
  "first-tactic": "rw [← cast_one]",
  "core-prompt":
  "{α β : Type _}  [OrderedSemiring α]  -- porting note: missing mono attribute -- @[mono] [CharZero α]  {m n : ℕ} : (n : α) ≤ 1 ↔ n ≤ 1",
  "args":
  "{α β : Type _}  [OrderedSemiring α]  -- porting note: missing mono attribute -- @[mono] [CharZero α]  {m n : ℕ}"},
 {"type": "↑(m - n) = (m - n : α)",
  "tactic-prompt":
  "theorem {α β : Type _} [CanonicallyOrderedCommSemiring α]  [Sub α]  [OrderedSub α]      [ContravariantClass α α (· + ·) (· ≤ ·)]  (m n : ℕ) : ↑(m - n) = (m - n : α) := by cases' le_total m n with h h; sorry",
  "name": "cast_tsub",
  "kind": "theorem",
  "first-tactic": "cases' le_total m n with h h",
  "core-prompt":
  "{α β : Type _} [CanonicallyOrderedCommSemiring α]  [Sub α]  [OrderedSub α]      [ContravariantClass α α (· + ·) (· ≤ ·)]  (m n : ℕ) : ↑(m - n) = (m - n : α)",
  "args":
  "{α β : Type _} [CanonicallyOrderedCommSemiring α]  [Sub α]  [OrderedSub α]      [ContravariantClass α α (· + ·) (· ≤ ·)]  (m n : ℕ)"},
 {"type": "f = g",
  "tactic-prompt":
  "theorem {α β : Type _}  {A F : Type _}  [MulZeroOneClass A] [MonoidWithZeroHomClass F ℕ A]  (f g : F)  (h_pos : ∀ {n : ℕ}, 0 < n → f n = g n) : f = g := by apply FunLike.ext; sorry",
  "name": "ext_nat''",
  "kind": "theorem",
  "first-tactic": "apply FunLike.ext",
  "core-prompt":
  "{α β : Type _}  {A F : Type _}  [MulZeroOneClass A] [MonoidWithZeroHomClass F ℕ A]  (f g : F)  (h_pos : ∀ {n : ℕ}, 0 < n → f n = g n) : f = g",
  "args":
  "{α β : Type _}  {A F : Type _}  [MulZeroOneClass A] [MonoidWithZeroHomClass F ℕ A]  (f g : F)  (h_pos : ∀ {n : ℕ}, 0 < n → f n = g n)"},
 {"type": "(n : α × β).fst = n",
  "tactic-prompt":
  "theorem {α β : Type _} [AddMonoidWithOne α]  [AddMonoidWithOne β] (n : ℕ) : (n : α × β).fst = n := by induction n; sorry",
  "name": "fst_natCast",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{α β : Type _} [AddMonoidWithOne α]  [AddMonoidWithOne β] (n : ℕ) : (n : α × β).fst = n",
  "args": "{α β : Type _} [AddMonoidWithOne α]  [AddMonoidWithOne β] (n : ℕ)"},
 {"type": "(n : α × β).snd = n",
  "tactic-prompt":
  "theorem {α β : Type _} [AddMonoidWithOne α]  [AddMonoidWithOne β] (n : ℕ) : (n : α × β).snd = n := by induction n; sorry",
  "name": "snd_natCast",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{α β : Type _} [AddMonoidWithOne α]  [AddMonoidWithOne β] (n : ℕ) : (n : α × β).snd = n",
  "args": "{α β : Type _} [AddMonoidWithOne α]  [AddMonoidWithOne β] (n : ℕ)"},
 {"type": "log b n = 0 ↔ n < b ∨ b ≤ 1",
  "tactic-prompt":
  "theorem {b n : ℕ} : log b n = 0 ↔ n < b ∨ b ≤ 1 := by rw [log]; sorry",
  "name": "log_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "rw [log]",
  "core-prompt": "{b n : ℕ} : log b n = 0 ↔ n < b ∨ b ≤ 1",
  "args": "{b n : ℕ}"},
 {"type": "0 < log b n ↔ b ≤ n ∧ 1 < b",
  "tactic-prompt":
  "theorem {b n : ℕ} : 0 < log b n ↔ b ≤ n ∧ 1 < b := by rw [pos_iff_ne_zero]; sorry",
  "name": "log_pos_iff",
  "kind": "theorem",
  "first-tactic": "rw [pos_iff_ne_zero]",
  "core-prompt": "{b n : ℕ} : 0 < log b n ↔ b ≤ n ∧ 1 < b",
  "args": "{b n : ℕ}"},
 {"type": "log b n = log b (n / b) + 1",
  "tactic-prompt":
  "theorem {b n : ℕ}  (h : 1 < b)  (hn : b ≤ n) : log b n = log b (n / b) + 1 := by rw [log]; sorry",
  "name": "log_of_one_lt_of_le",
  "kind": "theorem",
  "first-tactic": "rw [log]",
  "core-prompt":
  "{b n : ℕ}  (h : 1 < b)  (hn : b ≤ n) : log b n = log b (n / b) + 1",
  "args": "{b n : ℕ}  (h : 1 < b)  (hn : b ≤ n)"},
 {"type": "b ^ x ≤ y ↔ x ≤ log b y",
  "tactic-prompt":
  "theorem {b : ℕ}  (hb : 1 < b)  {x y : ℕ}  (hy : y ≠ 0) : b ^ x ≤ y ↔ x ≤ log b y := by induction' y using Nat.strong_induction_on with y ih generalizing x; sorry",
  "name": "pow_le_iff_le_log",
  "kind": "theorem",
  "first-tactic":
  "induction' y using Nat.strong_induction_on with y ih generalizing x",
  "core-prompt":
  "{b : ℕ}  (hb : 1 < b)  {x y : ℕ}  (hy : y ≠ 0) : b ^ x ≤ y ↔ x ≤ log b y",
  "args": "{b : ℕ}  (hb : 1 < b)  {x y : ℕ}  (hy : y ≠ 0)"},
 {"type": "b ^ x ≤ y",
  "tactic-prompt":
  "theorem {b x y : ℕ}  (hy : y ≠ 0)  (h : x ≤ log b y) : b ^ x ≤ y := by refine' (le_or_lt b 1).elim (fun hb => _) fun hb => (pow_le_iff_le_log hb hy).2 h; sorry",
  "name": "pow_le_of_le_log",
  "kind": "theorem",
  "first-tactic":
  "refine' (le_or_lt b 1).elim (fun hb => _) fun hb => (pow_le_iff_le_log hb hy).2 h",
  "core-prompt": "{b x y : ℕ}  (hy : y ≠ 0)  (h : x ≤ log b y) : b ^ x ≤ y",
  "args": "{b x y : ℕ}  (hy : y ≠ 0)  (h : x ≤ log b y)"},
 {"type": "x ≤ log b y",
  "tactic-prompt":
  "theorem {b x y : ℕ}  (hb : 1 < b)  (h : b ^ x ≤ y) : x ≤ log b y := by rcases ne_or_eq y 0 with (hy | rfl); sorry",
  "name": "le_log_of_pow_le",
  "kind": "theorem",
  "first-tactic": "rcases ne_or_eq y 0 with (hy | rfl)",
  "core-prompt": "{b x y : ℕ}  (hb : 1 < b)  (h : b ^ x ≤ y) : x ≤ log b y",
  "args": "{b x y : ℕ}  (hb : 1 < b)  (h : b ^ x ≤ y)"},
 {"type": "log b n = m ↔ b ^ m ≤ n ∧ n < b ^ (m + 1)",
  "tactic-prompt":
  "theorem {b m n : ℕ}  (h : m ≠ 0 ∨ 1 < b ∧ n ≠ 0) : log b n = m ↔ b ^ m ≤ n ∧ n < b ^ (m + 1) := by rcases em (1 < b ∧ n ≠ 0) with (⟨hb, hn⟩ | hbn); sorry",
  "name": "log_eq_iff",
  "kind": "theorem",
  "first-tactic": "rcases em (1 < b ∧ n ≠ 0) with (⟨hb, hn⟩ | hbn)",
  "core-prompt":
  "{b m n : ℕ}  (h : m ≠ 0 ∨ 1 < b ∧ n ≠ 0) : log b n = m ↔ b ^ m ≤ n ∧ n < b ^ (m + 1)",
  "args": "{b m n : ℕ}  (h : m ≠ 0 ∨ 1 < b ∧ n ≠ 0)"},
 {"type": "log b n = m",
  "tactic-prompt":
  "theorem {b m n : ℕ}  (h₁ : b ^ m ≤ n)  (h₂ : n < b ^ (m + 1)) : log b n = m := by rcases eq_or_ne m 0 with (rfl | hm); sorry",
  "name": "log_eq_of_pow_le_of_lt_pow",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne m 0 with (rfl | hm)",
  "core-prompt":
  "{b m n : ℕ}  (h₁ : b ^ m ≤ n)  (h₂ : n < b ^ (m + 1)) : log b n = m",
  "args": "{b m n : ℕ}  (h₁ : b ^ m ≤ n)  (h₂ : n < b ^ (m + 1))"},
 {"type": "log b n = 1 ↔ b ≤ n ∧ n < b * b",
  "tactic-prompt":
  "theorem {b n : ℕ} : log b n = 1 ↔ b ≤ n ∧ n < b * b := by rw [log_eq_iff (Or.inl one_ne_zero)]; sorry",
  "name": "log_eq_one_iff'",
  "kind": "theorem",
  "first-tactic": "rw [log_eq_iff (Or.inl one_ne_zero)]",
  "core-prompt": "{b n : ℕ} : log b n = 1 ↔ b ≤ n ∧ n < b * b",
  "args": "{b n : ℕ}"},
 {"type": "log b (n * b) = log b n + 1",
  "tactic-prompt":
  "theorem {b n : ℕ}  (hb : 1 < b)  (hn : n ≠ 0) : log b (n * b) = log b n + 1 := by apply log_eq_of_pow_le_of_lt_pow; sorry",
  "name": "log_mul_base",
  "kind": "theorem",
  "first-tactic": "apply log_eq_of_pow_le_of_lt_pow",
  "core-prompt":
  "{b n : ℕ}  (hb : 1 < b)  (hn : n ≠ 0) : log b (n * b) = log b n + 1",
  "args": "{b n : ℕ}  (hb : 1 < b)  (hn : n ≠ 0)"},
 {"type": "Monotone (log b)",
  "tactic-prompt":
  "theorem {b : ℕ} : Monotone (log b) := by refine' monotone_nat_of_le_succ fun n => _; sorry",
  "name": "log_monotone",
  "kind": "theorem",
  "first-tactic": "refine' monotone_nat_of_le_succ fun n => _",
  "core-prompt": "{b : ℕ} : Monotone (log b)",
  "args": "{b : ℕ}"},
 {"type": "log b n ≤ log c n",
  "tactic-prompt":
  "theorem {b c n : ℕ}  (hc : 1 < c)  (hb : c ≤ b) : log b n ≤ log c n := by rcases eq_or_ne n 0 with (rfl | hn); sorry",
  "name": "log_anti_left",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne n 0 with (rfl | hn)",
  "core-prompt": "{b c n : ℕ}  (hc : 1 < c)  (hb : c ≤ b) : log b n ≤ log c n",
  "args": "{b c n : ℕ}  (hc : 1 < c)  (hb : c ≤ b)"},
 {"type": "log b (n / b) = log b n - 1",
  "tactic-prompt":
  "theorem (b n : ℕ) : log b (n / b) = log b n - 1 := by cases' le_or_lt b 1 with hb hb; sorry",
  "name": "log_div_base",
  "kind": "theorem",
  "first-tactic": "cases' le_or_lt b 1 with hb hb",
  "core-prompt": "(b n : ℕ) : log b (n / b) = log b n - 1",
  "args": "(b n : ℕ)"},
 {"type": "log b (n / b * b) = log b n",
  "tactic-prompt":
  "theorem (b n : ℕ) : log b (n / b * b) = log b n := by cases' le_or_lt b 1 with hb hb; sorry",
  "name": "log_div_mul_self",
  "kind": "theorem",
  "first-tactic": "cases' le_or_lt b 1 with hb hb",
  "core-prompt": "(b n : ℕ) : log b (n / b * b) = log b n",
  "args": "(b n : ℕ)"},
 {"type": "(n + b - 1) / b < n",
  "tactic-prompt":
  "theorem {b n : ℕ}  (hb : 1 < b)  (hn : 2 ≤ n) : (n + b - 1) / b < n := by rw [div_lt_iff_lt_mul (zero_lt_one.trans hb)]; sorry",
  "name": "add_pred_div_lt",
  "kind": "theorem",
  "first-tactic": "rw [div_lt_iff_lt_mul (zero_lt_one.trans hb)]",
  "core-prompt": "{b n : ℕ}  (hb : 1 < b)  (hn : 2 ≤ n) : (n + b - 1) / b < n",
  "args": "{b n : ℕ}  (hb : 1 < b)  (hn : 2 ≤ n)"},
 {"type": "clog b n = 0",
  "tactic-prompt":
  "theorem {b : ℕ}  (hb : b ≤ 1)  (n : ℕ) : clog b n = 0 := by rw [clog]; sorry",
  "name": "clog_of_left_le_one",
  "kind": "theorem",
  "first-tactic": "rw [clog]",
  "core-prompt": "{b : ℕ}  (hb : b ≤ 1)  (n : ℕ) : clog b n = 0",
  "args": "{b : ℕ}  (hb : b ≤ 1)  (n : ℕ)"},
 {"type": "clog b n = 0",
  "tactic-prompt":
  "theorem {n : ℕ}  (hn : n ≤ 1)  (b : ℕ) : clog b n = 0 := by rw [clog]; sorry",
  "name": "clog_of_right_le_one",
  "kind": "theorem",
  "first-tactic": "rw [clog]",
  "core-prompt": "{n : ℕ}  (hn : n ≤ 1)  (b : ℕ) : clog b n = 0",
  "args": "{n : ℕ}  (hn : n ≤ 1)  (b : ℕ)"},
 {"type": "clog b n = clog b ((n + b - 1) / b) + 1",
  "tactic-prompt":
  "theorem {b n : ℕ}  (hb : 1 < b)  (hn : 2 ≤ n) : clog b n = clog b ((n + b - 1) / b) + 1 := by rw [clog]; sorry",
  "name": "clog_of_two_le",
  "kind": "theorem",
  "first-tactic": "rw [clog]",
  "core-prompt":
  "{b n : ℕ}  (hb : 1 < b)  (hn : 2 ≤ n) : clog b n = clog b ((n + b - 1) / b) + 1",
  "args": "{b n : ℕ}  (hb : 1 < b)  (hn : 2 ≤ n)"},
 {"type": "0 < clog b n",
  "tactic-prompt":
  "theorem {b n : ℕ}  (hb : 1 < b)  (hn : 2 ≤ n) : 0 < clog b n := by rw [clog_of_two_le hb hn]; sorry",
  "name": "clog_pos",
  "kind": "theorem",
  "first-tactic": "rw [clog_of_two_le hb hn]",
  "core-prompt": "{b n : ℕ}  (hb : 1 < b)  (hn : 2 ≤ n) : 0 < clog b n",
  "args": "{b n : ℕ}  (hb : 1 < b)  (hn : 2 ≤ n)"},
 {"type": "clog b n = 1",
  "tactic-prompt":
  "theorem {b n : ℕ}  (hn : 2 ≤ n)  (h : n ≤ b) : clog b n = 1 := by rw [clog_of_two_le (hn.trans h) hn]; sorry",
  "name": "clog_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [clog_of_two_le (hn.trans h) hn]",
  "core-prompt": "{b n : ℕ}  (hn : 2 ≤ n)  (h : n ≤ b) : clog b n = 1",
  "args": "{b n : ℕ}  (hn : 2 ≤ n)  (h : n ≤ b)"},
 {"type": "x ≤ b ^ y ↔ clog b x ≤ y",
  "tactic-prompt":
  "theorem {b : ℕ}  (hb : 1 < b)  {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by induction' x using Nat.strong_induction_on with x ih generalizing y; sorry",
  "name": "le_pow_iff_clog_le",
  "kind": "theorem",
  "first-tactic":
  "induction' x using Nat.strong_induction_on with x ih generalizing y",
  "core-prompt": "{b : ℕ}  (hb : 1 < b)  {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y",
  "args": "{b : ℕ}  (hb : 1 < b)  {x y : ℕ}"},
 {"type": "b ^ (clog b x).pred < x",
  "tactic-prompt":
  "theorem {b : ℕ}  (hb : 1 < b)  {x : ℕ}  (hx : 1 < x) : b ^ (clog b x).pred < x := by rw [← not_le]; sorry",
  "name": "pow_pred_clog_lt_self",
  "kind": "theorem",
  "first-tactic": "rw [← not_le]",
  "core-prompt":
  "{b : ℕ}  (hb : 1 < b)  {x : ℕ}  (hx : 1 < x) : b ^ (clog b x).pred < x",
  "args": "{b : ℕ}  (hb : 1 < b)  {x : ℕ}  (hx : 1 < x)"},
 {"type": "clog b n ≤ clog b m",
  "tactic-prompt":
  "theorem (b : ℕ)  {n m : ℕ}  (h : n ≤ m) : clog b n ≤ clog b m := by cases' le_or_lt b 1 with hb hb; sorry",
  "name": "clog_mono_right",
  "kind": "theorem",
  "first-tactic": "cases' le_or_lt b 1 with hb hb",
  "core-prompt": "(b : ℕ)  {n m : ℕ}  (h : n ≤ m) : clog b n ≤ clog b m",
  "args": "(b : ℕ)  {n m : ℕ}  (h : n ≤ m)"},
 {"type": "clog b n ≤ clog c n",
  "tactic-prompt":
  "theorem {b c n : ℕ}  (hc : 1 < c)  (hb : c ≤ b) : clog b n ≤ clog c n := by rw [← le_pow_iff_clog_le (lt_of_lt_of_le hc hb)]; sorry",
  "name": "clog_anti_left",
  "kind": "theorem",
  "first-tactic": "rw [← le_pow_iff_clog_le (lt_of_lt_of_le hc hb)]",
  "core-prompt":
  "{b c n : ℕ}  (hc : 1 < c)  (hb : c ≤ b) : clog b n ≤ clog c n",
  "args": "{b c n : ℕ}  (hc : 1 < c)  (hb : c ≤ b)"},
 {"type": "log b n ≤ clog b n",
  "tactic-prompt":
  "theorem (b n : ℕ) : log b n ≤ clog b n := by obtain hb | hb := le_or_lt b 1; sorry",
  "name": "log_le_clog",
  "kind": "theorem",
  "first-tactic": "obtain hb | hb := le_or_lt b 1",
  "core-prompt": "(b n : ℕ) : log b n ≤ clog b n",
  "args": "(b n : ℕ)"},
 {"type": "boddDiv2 n = (bodd n, div2 n)",
  "tactic-prompt":
  "theorem {n : ℕ} (n : ℕ) : boddDiv2 n = (bodd n, div2 n) := by unfold bodd div2; sorry",
  "name": "boddDiv2_eq",
  "kind": "theorem",
  "first-tactic": "unfold bodd div2",
  "core-prompt": "{n : ℕ} (n : ℕ) : boddDiv2 n = (bodd n, div2 n)",
  "args": "{n : ℕ} (n : ℕ)"},
 {"type": "bit0 n % 2 = 0",
  "tactic-prompt":
  "theorem {n : ℕ} : bit0 n % 2 = 0 := by rw [Nat.mod_two_of_bodd]; sorry",
  "name": "bit0_mod_two",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mod_two_of_bodd]",
  "core-prompt": "{n : ℕ} : bit0 n % 2 = 0",
  "args": "{n : ℕ}"},
 {"type": "bit1 n % 2 = 1",
  "tactic-prompt":
  "theorem {n : ℕ} : bit1 n % 2 = 1 := by rw [Nat.mod_two_of_bodd]; sorry",
  "name": "bit1_mod_two",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mod_two_of_bodd]",
  "core-prompt": "{n : ℕ} : bit1 n % 2 = 1",
  "args": "{n : ℕ}"},
 {"type": "0 < n",
  "tactic-prompt":
  "theorem {n : ℕ} {n : ℕ}  (h : 0 < bit0 n) : 0 < n := by cases n; sorry",
  "name": "pos_of_bit0_pos",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "{n : ℕ} {n : ℕ}  (h : 0 < bit0 n) : 0 < n",
  "args": "{n : ℕ} {n : ℕ}  (h : 0 < bit0 n)"},
 {"type":
  "Function.Injective fun H : ∀ b n, C (bit b n) => fun n => bitCasesOn n H",
  "tactic-prompt":
  "theorem {n : ℕ} {C : ℕ → Sort u} : Function.Injective fun H : ∀ b n, C (bit b n) => fun n => bitCasesOn n H := by intro H₁ H₂ h; sorry",
  "name": "bit_cases_on_injective",
  "kind": "theorem",
  "first-tactic": "intro H₁ H₂ h",
  "core-prompt":
  "{n : ℕ} {C : ℕ → Sort u} : Function.Injective fun H : ∀ b n, C (bit b n) => fun n => bitCasesOn n H",
  "args": "{n : ℕ} {C : ℕ → Sort u}"},
 {"type": "bit b n = 0 ↔ n = 0 ∧ b = false",
  "tactic-prompt":
  "theorem {n : ℕ} {n : ℕ}  {b : Bool} : bit b n = 0 ↔ n = 0 ∧ b = false := by constructor; sorry",
  "name": "bit_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{n : ℕ} {n : ℕ}  {b : Bool} : bit b n = 0 ↔ n = 0 ∧ b = false",
  "args": "{n : ℕ} {n : ℕ}  {b : Bool}"},
 {"type": "bits 0 = []",
  "tactic-prompt": "theorem {n : ℕ} : bits 0 = [] := by simp [Nat.bits]; sorry",
  "name": "zero_bits",
  "kind": "theorem",
  "first-tactic": "simp [Nat.bits]",
  "core-prompt": "{n : ℕ} : bits 0 = []",
  "args": "{n : ℕ}"},
 {"type": "(bit b n).bits = b :: n.bits",
  "tactic-prompt":
  "theorem {n : ℕ} (n : ℕ)  (b : Bool)  (hn : n = 0 → b = true) : (bit b n).bits = b :: n.bits := by rw [Nat.bits]; sorry",
  "name": "bits_append_bit",
  "kind": "theorem",
  "first-tactic": "rw [Nat.bits]",
  "core-prompt":
  "{n : ℕ} (n : ℕ)  (b : Bool)  (hn : n = 0 → b = true) : (bit b n).bits = b :: n.bits",
  "args": "{n : ℕ} (n : ℕ)  (b : Bool)  (hn : n = 0 → b = true)"},
 {"type": "Nat.bits 1 = [true]",
  "tactic-prompt":
  "theorem {n : ℕ} : Nat.bits 1 = [true] := by convert bit1_bits 0; sorry",
  "name": "one_bits",
  "kind": "theorem",
  "first-tactic": "convert bit1_bits 0",
  "core-prompt": "{n : ℕ} : Nat.bits 1 = [true]",
  "args": "{n : ℕ}"},
 {"type": "n.bodd = n.bits.headI",
  "tactic-prompt":
  "theorem {n : ℕ} (n : ℕ) : n.bodd = n.bits.headI := by induction' n using Nat.binaryRec' with b n h _; sorry",
  "name": "bodd_eq_bits_head",
  "kind": "theorem",
  "first-tactic": "induction' n using Nat.binaryRec' with b n h _",
  "core-prompt": "{n : ℕ} (n : ℕ) : n.bodd = n.bits.headI",
  "args": "{n : ℕ} (n : ℕ)"},
 {"type": "n.div2.bits = n.bits.tail",
  "tactic-prompt":
  "theorem {n : ℕ} (n : ℕ) : n.div2.bits = n.bits.tail := by induction' n using Nat.binaryRec' with b n h _; sorry",
  "name": "div2_bits_eq_tail",
  "kind": "theorem",
  "first-tactic": "induction' n using Nat.binaryRec' with b n h _",
  "core-prompt": "{n : ℕ} (n : ℕ) : n.div2.bits = n.bits.tail",
  "args": "{n : ℕ} (n : ℕ)"},
 {"type": "max (succ m) (succ n) = succ (max m n)",
  "tactic-prompt":
  "theorem {m n k : ℕ} {m n : ℕ} : max (succ m) (succ n) = succ (max m n) := by by_cases h1 : m ≤ n; sorry",
  "name": "max_succ_succ",
  "kind": "theorem",
  "first-tactic": "by_cases h1 : m ≤ n",
  "core-prompt":
  "{m n k : ℕ} {m n : ℕ} : max (succ m) (succ n) = succ (max m n)",
  "args": "{m n k : ℕ} {m n : ℕ}"},
 {"type": "m < n ↔ m + 1 ≤ n",
  "tactic-prompt":
  "theorem {m n k : ℕ} {m n : ℕ} : m < n ↔ m + 1 ≤ n := by rw [succ_le_iff]; sorry",
  "name": "lt_iff_add_one_le",
  "kind": "theorem",
  "first-tactic": "rw [succ_le_iff]",
  "core-prompt": "{m n k : ℕ} {m n : ℕ} : m < n ↔ m + 1 ≤ n",
  "args": "{m n k : ℕ} {m n : ℕ}"},
 {"type": "a < 1 + b ↔ a ≤ b",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b : ℕ} : a < 1 + b ↔ a ≤ b := by simp only [add_comm]; sorry",
  "name": "lt_one_add_iff",
  "kind": "theorem",
  "first-tactic": "simp only [add_comm]",
  "core-prompt": "{m n k : ℕ} {a b : ℕ} : a < 1 + b ↔ a ≤ b",
  "args": "{m n k : ℕ} {a b : ℕ}"},
 {"type": "1 + a ≤ b ↔ a < b",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b : ℕ} : 1 + a ≤ b ↔ a < b := by simp only [add_comm]; sorry",
  "name": "one_add_le_iff",
  "kind": "theorem",
  "first-tactic": "simp only [add_comm]",
  "core-prompt": "{m n k : ℕ} {a b : ℕ} : 1 + a ≤ b ↔ a < b",
  "args": "{m n k : ℕ} {a b : ℕ}"},
 {"type": "m / n ≤ k ↔ m ≤ n * k + (n - 1)",
  "tactic-prompt":
  "theorem {m n k : ℕ} {m n k : ℕ}  (n0 : 0 < n) : m / n ≤ k ↔ m ≤ n * k + (n - 1) := by rw [← lt_succ_iff]; sorry",
  "name": "div_le_iff_le_mul_add_pred",
  "kind": "theorem",
  "first-tactic": "rw [← lt_succ_iff]",
  "core-prompt":
  "{m n k : ℕ} {m n k : ℕ}  (n0 : 0 < n) : m / n ≤ k ↔ m ≤ n * k + (n - 1)",
  "args": "{m n k : ℕ} {m n k : ℕ}  (n0 : 0 < n)"},
 {"type": "(∀ m < n + 1, P m) ↔ (∀ m < n, P m) ∧ P n",
  "tactic-prompt":
  "theorem {m n k : ℕ} {P : ℕ → Prop}  {n : ℕ} : (∀ m < n + 1, P m) ↔ (∀ m < n, P m) ∧ P n := by simp only [lt_succ_iff]; sorry",
  "name": "forall_lt_succ",
  "kind": "theorem",
  "first-tactic": "simp only [lt_succ_iff]",
  "core-prompt":
  "{m n k : ℕ} {P : ℕ → Prop}  {n : ℕ} : (∀ m < n + 1, P m) ↔ (∀ m < n, P m) ∧ P n",
  "args": "{m n k : ℕ} {P : ℕ → Prop}  {n : ℕ}"},
 {"type": "(∃ m < n + 1, P m) ↔ (∃ m < n, P m) ∨ P n",
  "tactic-prompt":
  "theorem {m n k : ℕ} {P : ℕ → Prop}  {n : ℕ} : (∃ m < n + 1, P m) ↔ (∃ m < n, P m) ∨ P n := by rw [← not_iff_not]; sorry",
  "name": "exists_lt_succ",
  "kind": "theorem",
  "first-tactic": "rw [← not_iff_not]",
  "core-prompt":
  "{m n k : ℕ} {P : ℕ → Prop}  {n : ℕ} : (∃ m < n + 1, P m) ↔ (∃ m < n, P m) ∨ P n",
  "args": "{m n k : ℕ} {P : ℕ → Prop}  {n : ℕ}"},
 {"type": "n + succ m - 1 = n + m",
  "tactic-prompt":
  "theorem {m n k : ℕ} (n m : ℕ) : n + succ m - 1 = n + m := by rw [add_succ]; sorry",
  "name": "add_succ_sub_one",
  "kind": "theorem",
  "first-tactic": "rw [add_succ]",
  "core-prompt": "{m n k : ℕ} (n m : ℕ) : n + succ m - 1 = n + m",
  "args": "{m n k : ℕ} (n m : ℕ)"},
 {"type": "succ n + m - 1 = n + m",
  "tactic-prompt":
  "theorem {m n k : ℕ} (n m : ℕ) : succ n + m - 1 = n + m := by rw [succ_add]; sorry",
  "name": "succ_add_sub_one",
  "kind": "theorem",
  "first-tactic": "rw [succ_add]",
  "core-prompt": "{m n k : ℕ} (n m : ℕ) : succ n + m - 1 = n + m",
  "args": "{m n k : ℕ} (n m : ℕ)"},
 {"type": "m.pred = n",
  "tactic-prompt":
  "theorem {m n k : ℕ} {m n : ℕ}  (H : m = n.succ) : m.pred = n := by simp [H]; sorry",
  "name": "pred_eq_of_eq_succ",
  "kind": "theorem",
  "first-tactic": "simp [H]",
  "core-prompt": "{m n k : ℕ} {m n : ℕ}  (H : m = n.succ) : m.pred = n",
  "args": "{m n k : ℕ} {m n : ℕ}  (H : m = n.succ)"},
 {"type": "pred n = succ m ↔ n = m + 2",
  "tactic-prompt":
  "theorem {m n k : ℕ} {n m : ℕ} : pred n = succ m ↔ n = m + 2 := by cases n; sorry",
  "name": "pred_eq_succ_iff",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "{m n k : ℕ} {n m : ℕ} : pred n = succ m ↔ n = m + 2",
  "args": "{m n k : ℕ} {n m : ℕ}"},
 {"type": "pred n - m = pred (n - m)",
  "tactic-prompt":
  "theorem {m n k : ℕ} (n m : ℕ) : pred n - m = pred (n - m) := by rw [← Nat.sub_one]; sorry",
  "name": "pred_sub",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.sub_one]",
  "core-prompt": "{m n k : ℕ} (n m : ℕ) : pred n - m = pred (n - m)",
  "args": "{m n k : ℕ} (n m : ℕ)"},
 {"type": "pred (1 + n) = n",
  "tactic-prompt":
  "theorem {m n k : ℕ} (n : ℕ) : pred (1 + n) = n := by rw [add_comm]; sorry",
  "name": "pred_one_add",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt": "{m n k : ℕ} (n : ℕ) : pred (1 + n) = n",
  "args": "{m n k : ℕ} (n : ℕ)"},
 {"type": "a * b = b ↔ a = 1",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b : ℕ}  (hb : 0 < b) : a * b = b ↔ a = 1 := by rw [mul_comm]; sorry",
  "name": "mul_left_eq_self_iff",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt": "{m n k : ℕ} {a b : ℕ}  (hb : 0 < b) : a * b = b ↔ a = 1",
  "args": "{m n k : ℕ} {a b : ℕ}  (hb : 0 < b)"},
 {"type": "(decreasingInduction h nn hP : P n) = hP",
  "tactic-prompt":
  "theorem {m n k : ℕ} {P : ℕ → Sort _}  (h : ∀ n, P (n + 1) → P n)  {n : ℕ}  (nn : n ≤ n)      (hP : P n) : (decreasingInduction h nn hP : P n) = hP := by dsimp only [decreasingInduction]; sorry",
  "name": "decreasingInduction_self",
  "kind": "theorem",
  "first-tactic": "dsimp only [decreasingInduction]",
  "core-prompt":
  "{m n k : ℕ} {P : ℕ → Sort _}  (h : ∀ n, P (n + 1) → P n)  {n : ℕ}  (nn : n ≤ n)      (hP : P n) : (decreasingInduction h nn hP : P n) = hP",
  "args":
  "{m n k : ℕ} {P : ℕ → Sort _}  (h : ∀ n, P (n + 1) → P n)  {n : ℕ}  (nn : n ≤ n)      (hP : P n)"},
 {"type":
  "(decreasingInduction h msn hP : P m) = decreasingInduction h mn (h n hP)",
  "tactic-prompt":
  "theorem {m n k : ℕ} {P : ℕ → Sort _}  (h : ∀ n, P (n + 1) → P n)  {m n : ℕ}  (mn : m ≤ n)      (msn : m ≤ n + 1)  (hP : P (n + 1)) : (decreasingInduction h msn hP : P m) = decreasingInduction h mn (h n hP) := by dsimp only [decreasingInduction]; sorry",
  "name": "decreasingInduction_succ",
  "kind": "theorem",
  "first-tactic": "dsimp only [decreasingInduction]",
  "core-prompt":
  "{m n k : ℕ} {P : ℕ → Sort _}  (h : ∀ n, P (n + 1) → P n)  {m n : ℕ}  (mn : m ≤ n)      (msn : m ≤ n + 1)  (hP : P (n + 1)) : (decreasingInduction h msn hP : P m) = decreasingInduction h mn (h n hP)",
  "args":
  "{m n k : ℕ} {P : ℕ → Sort _}  (h : ∀ n, P (n + 1) → P n)  {m n : ℕ}  (mn : m ≤ n)      (msn : m ≤ n + 1)  (hP : P (n + 1))"},
 {"type": "(decreasingInduction h msm hP : P m) = h m hP",
  "tactic-prompt":
  "theorem {m n k : ℕ} {P : ℕ → Sort _}  (h : ∀ n, P (n + 1) → P n)  {m : ℕ}      (msm : m ≤ m + 1)  (hP : P (m + 1)) : (decreasingInduction h msm hP : P m) = h m hP := by dsimp only [decreasingInduction]; sorry",
  "name": "decreasingInduction_succ'",
  "kind": "theorem",
  "first-tactic": "dsimp only [decreasingInduction]",
  "core-prompt":
  "{m n k : ℕ} {P : ℕ → Sort _}  (h : ∀ n, P (n + 1) → P n)  {m : ℕ}      (msm : m ≤ m + 1)  (hP : P (m + 1)) : (decreasingInduction h msm hP : P m) = h m hP",
  "args":
  "{m n k : ℕ} {P : ℕ → Sort _}  (h : ∀ n, P (n + 1) → P n)  {m : ℕ}      (msm : m ≤ m + 1)  (hP : P (m + 1))"},
 {"type":
  "(decreasingInduction h (le_trans mn nk) hP : P m) =\n    decreasingInduction h mn (decreasingInduction h nk hP)",
  "tactic-prompt":
  "theorem {m n k : ℕ} {P : ℕ → Sort _}  (h : ∀ n, P (n + 1) → P n)  {m n k : ℕ}      (mn : m ≤ n)  (nk : n ≤ k)  (hP : P k) : (decreasingInduction h (le_trans mn nk) hP : P m) =\n    decreasingInduction h mn (decreasingInduction h nk hP) := by induction' nk with k nk ih; sorry",
  "name": "decreasingInduction_trans",
  "kind": "theorem",
  "first-tactic": "induction' nk with k nk ih",
  "core-prompt":
  "{m n k : ℕ} {P : ℕ → Sort _}  (h : ∀ n, P (n + 1) → P n)  {m n k : ℕ}      (mn : m ≤ n)  (nk : n ≤ k)  (hP : P k) : (decreasingInduction h (le_trans mn nk) hP : P m) =\n    decreasingInduction h mn (decreasingInduction h nk hP)",
  "args":
  "{m n k : ℕ} {P : ℕ → Sort _}  (h : ∀ n, P (n + 1) → P n)  {m n k : ℕ}      (mn : m ≤ n)  (nk : n ≤ k)  (hP : P k)"},
 {"type":
  "(decreasingInduction h mn hP : P m) = h m (decreasingInduction h smn hP)",
  "tactic-prompt":
  "theorem {m n k : ℕ} {P : ℕ → Sort _}  (h : ∀ n, P (n + 1) → P n)  {m n : ℕ}      (smn : m + 1 ≤ n)  (mn : m ≤ n)  (hP : P n) : (decreasingInduction h mn hP : P m) = h m (decreasingInduction h smn hP) := by rw [Subsingleton.elim mn (le_trans (le_succ m) smn)]; sorry",
  "name": "decreasingInduction_succ_left",
  "kind": "theorem",
  "first-tactic": "rw [Subsingleton.elim mn (le_trans (le_succ m) smn)]",
  "core-prompt":
  "{m n k : ℕ} {P : ℕ → Sort _}  (h : ∀ n, P (n + 1) → P n)  {m n : ℕ}      (smn : m + 1 ≤ n)  (mn : m ≤ n)  (hP : P n) : (decreasingInduction h mn hP : P m) = h m (decreasingInduction h smn hP)",
  "args":
  "{m n k : ℕ} {P : ℕ → Sort _}  (h : ∀ n, P (n + 1) → P n)  {m n : ℕ}      (smn : m + 1 ≤ n)  (mn : m ≤ n)  (hP : P n)"},
 {"type": "P m",
  "tactic-prompt":
  "def {m n k : ℕ} {P : ℕ → Sort _}  {m n : ℕ}  (h : ∀ k < n, m ≤ k → P (k + 1) → P k)      (mn : m ≤ n)  (hP : P n) : P m := by revert h hP; sorry",
  "name": "decreasingInduction'",
  "kind": "def",
  "first-tactic": "revert h hP",
  "core-prompt":
  "{m n k : ℕ} {P : ℕ → Sort _}  {m n : ℕ}  (h : ∀ k < n, m ≤ k → P (k + 1) → P k)      (mn : m ≤ n)  (hP : P n) : P m",
  "args":
  "{m n k : ℕ} {P : ℕ → Sort _}  {m n : ℕ}  (h : ∀ k < n, m ≤ k → P (k + 1) → P k)      (mn : m ≤ n)  (hP : P n)"},
 {"type": "1 ≤ a / b ↔ b ≤ a",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b : ℕ}  (hb : 0 < b) : 1 ≤ a / b ↔ b ≤ a := by rw [le_div_iff_mul_le hb]; sorry",
  "name": "one_le_div_iff",
  "kind": "theorem",
  "first-tactic": "rw [le_div_iff_mul_le hb]",
  "core-prompt": "{m n k : ℕ} {a b : ℕ}  (hb : 0 < b) : 1 ≤ a / b ↔ b ≤ a",
  "args": "{m n k : ℕ} {a b : ℕ}  (hb : 0 < b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b c : ℕ}  (H1 : b ∣ a)  (H2 : a / b = c) : a = b * c := by rw [← H2]; sorry",
  "name": "eq_mul_of_div_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [← H2]",
  "core-prompt":
  "{m n k : ℕ} {a b c : ℕ}  (H1 : b ∣ a)  (H2 : a / b = c) : a = b * c",
  "args": "{m n k : ℕ} {a b c : ℕ}  (H1 : b ∣ a)  (H2 : a / b = c)"},
 {"type": "a / b = c ↔ a = c * b",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b c : ℕ}  (H : 0 < b)  (H' : b ∣ a) : a / b = c ↔ a = c * b := by rw [mul_comm]; sorry",
  "name": "div_eq_iff_eq_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{m n k : ℕ} {a b c : ℕ}  (H : 0 < b)  (H' : b ∣ a) : a / b = c ↔ a = c * b",
  "args": "{m n k : ℕ} {a b c : ℕ}  (H : 0 < b)  (H' : b ∣ a)"},
 {"type": "a = c * b",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b c : ℕ}  (H1 : b ∣ a)  (H2 : a / b = c) : a = c * b := by rw [mul_comm]; sorry",
  "name": "eq_mul_of_div_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{m n k : ℕ} {a b c : ℕ}  (H1 : b ∣ a)  (H2 : a / b = c) : a = c * b",
  "args": "{m n k : ℕ} {a b c : ℕ}  (H1 : b ∣ a)  (H2 : a / b = c)"},
 {"type": "a * (b / a) = b",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b : ℕ}  (Hd : a ∣ b) : a * (b / a) = b := by rw [mul_comm]; sorry",
  "name": "mul_div_cancel_left'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt": "{m n k : ℕ} {a b : ℕ}  (Hd : a ∣ b) : a * (b / a) = b",
  "args": "{m n k : ℕ} {a b : ℕ}  (Hd : a ∣ b)"},
 {"type": "a < a / b * b + b",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b : ℕ}  (hb : 0 < b) : a < a / b * b + b := by rw [← Nat.succ_mul]; sorry",
  "name": "lt_div_mul_add",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.succ_mul]",
  "core-prompt": "{m n k : ℕ} {a b : ℕ}  (hb : 0 < b) : a < a / b * b + b",
  "args": "{m n k : ℕ} {a b : ℕ}  (hb : 0 < b)"},
 {"type": "a / d = b / d ↔ a = b",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b d : ℕ}  (hda : d ∣ a)  (hdb : d ∣ b) : a / d = b / d ↔ a = b := by refine ⟨fun h => ?_, congr_arg fun n => n / d⟩; sorry",
  "name": "div_left_inj",
  "kind": "theorem",
  "first-tactic": "refine ⟨fun h => ?_, congr_arg fun n => n / d⟩",
  "core-prompt":
  "{m n k : ℕ} {a b d : ℕ}  (hda : d ∣ a)  (hdb : d ∣ b) : a / d = b / d ↔ a = b",
  "args": "{m n k : ℕ} {a b d : ℕ}  (hda : d ∣ a)  (hdb : d ∣ b)"},
 {"type": "a % b = a ↔ a < b",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b : ℕ}  (h : b ≠ 0) : a % b = a ↔ a < b := by cases b; sorry",
  "name": "mod_eq_iff_lt",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "{m n k : ℕ} {a b : ℕ}  (h : b ≠ 0) : a % b = a ↔ a < b",
  "args": "{m n k : ℕ} {a b : ℕ}  (h : b ≠ 0)"},
 {"type": "m % k + m / k * k = m",
  "tactic-prompt":
  "theorem {m n k : ℕ} (m k : ℕ) : m % k + m / k * k = m := by rw [mul_comm]; sorry",
  "name": "mod_add_div'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt": "{m n k : ℕ} (m k : ℕ) : m % k + m / k * k = m",
  "args": "{m n k : ℕ} (m k : ℕ)"},
 {"type": "m / k * k + m % k = m",
  "tactic-prompt":
  "theorem {m n k : ℕ} (m k : ℕ) : m / k * k + m % k = m := by rw [mul_comm]; sorry",
  "name": "div_add_mod'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt": "{m n k : ℕ} (m k : ℕ) : m / k * k + m % k = m",
  "args": "{m n k : ℕ} (m k : ℕ)"},
 {"type": "n % k % m = n % m",
  "tactic-prompt":
  "theorem {m n k : ℕ} (n : Nat)  {m k : Nat}  (h : m ∣ k) : n % k % m = n % m := by conv =>\n  rhs\n  rw [← mod_add_div n k]; sorry",
  "name": "mod_mod_of_dvd",
  "kind": "theorem",
  "first-tactic": "conv =>\n  rhs\n  rw [← mod_add_div n k]",
  "core-prompt":
  "{m n k : ℕ} (n : Nat)  {m k : Nat}  (h : m ∣ k) : n % k % m = n % m",
  "args": "{m n k : ℕ} (n : Nat)  {m k : Nat}  (h : m ∣ k)"},
 {"type": "(m + i) % n = (k + i) % n",
  "tactic-prompt":
  "theorem {m n k : ℕ} {m n k : ℕ}  (i : ℕ)  (H : m % n = k % n) : (m + i) % n = (k + i) % n := by rw [← mod_add_mod]; sorry",
  "name": "add_mod_eq_add_mod_right",
  "kind": "theorem",
  "first-tactic": "rw [← mod_add_mod]",
  "core-prompt":
  "{m n k : ℕ} {m n k : ℕ}  (i : ℕ)  (H : m % n = k % n) : (m + i) % n = (k + i) % n",
  "args": "{m n k : ℕ} {m n k : ℕ}  (i : ℕ)  (H : m % n = k % n)"},
 {"type": "(i + m) % n = (i + k) % n",
  "tactic-prompt":
  "theorem {m n k : ℕ} {m n k : ℕ}  (i : ℕ)  (H : m % n = k % n) : (i + m) % n = (i + k) % n := by rw [add_comm]; sorry",
  "name": "add_mod_eq_add_mod_left",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{m n k : ℕ} {m n k : ℕ}  (i : ℕ)  (H : m % n = k % n) : (i + m) % n = (i + k) % n",
  "args": "{m n k : ℕ} {m n k : ℕ}  (i : ℕ)  (H : m % n = k % n)"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b : ℕ}  (w : a ∣ b)  (h : b / a = 1) : a = b := by rw [← Nat.div_mul_cancel w]; sorry",
  "name": "eq_of_dvd_of_div_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.div_mul_cancel w]",
  "core-prompt": "{m n k : ℕ} {a b : ℕ}  (w : a ∣ b)  (h : b / a = 1) : a = b",
  "args": "{m n k : ℕ} {a b : ℕ}  (w : a ∣ b)  (h : b / a = 1)"},
 {"type": "b = 0",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b : ℕ}  (w : a ∣ b)  (h : b / a = 0) : b = 0 := by rw [← Nat.div_mul_cancel w]; sorry",
  "name": "eq_zero_of_dvd_of_div_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.div_mul_cancel w]",
  "core-prompt": "{m n k : ℕ} {a b : ℕ}  (w : a ∣ b)  (h : b / a = 0) : b = 0",
  "args": "{m n k : ℕ} {a b : ℕ}  (w : a ∣ b)  (h : b / a = 0)"},
 {"type": "m < n * (m / n + 1)",
  "tactic-prompt":
  "theorem {m n k : ℕ} (m : ℕ)  {n : ℕ}  (n0 : 0 < n) : m < n * (m / n + 1) := by rw [mul_comm]; sorry",
  "name": "lt_mul_div_succ",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{m n k : ℕ} (m : ℕ)  {n : ℕ}  (n0 : 0 < n) : m < n * (m / n + 1)",
  "args": "{m n k : ℕ} (m : ℕ)  {n : ℕ}  (n0 : 0 < n)"},
 {"type": "(a * b + c) % b = c % b",
  "tactic-prompt":
  "theorem {m n k : ℕ} (a b c : ℕ) : (a * b + c) % b = c % b := by simp [Nat.add_mod]; sorry",
  "name": "mul_add_mod",
  "kind": "theorem",
  "first-tactic": "simp [Nat.add_mod]",
  "core-prompt": "{m n k : ℕ} (a b c : ℕ) : (a * b + c) % b = c % b",
  "args": "{m n k : ℕ} (a b c : ℕ)"},
 {"type": "(a * b + c) % b = c",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b c : ℕ}  (h : c < b) : (a * b + c) % b = c := by rw [Nat.mul_add_mod]; sorry",
  "name": "mul_add_mod_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_add_mod]",
  "core-prompt": "{m n k : ℕ} {a b c : ℕ}  (h : c < b) : (a * b + c) % b = c",
  "args": "{m n k : ℕ} {a b c : ℕ}  (h : c < b)"},
 {"type": "n.pred = n ↔ n = 0",
  "tactic-prompt":
  "theorem {m n k : ℕ} {n : ℕ} : n.pred = n ↔ n = 0 := by cases n; sorry",
  "name": "pred_eq_self_iff",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "{m n k : ℕ} {n : ℕ} : n.pred = n ↔ n = 0",
  "args": "{m n k : ℕ} {n : ℕ}"},
 {"type": "Nat.find h = m ↔ p m ∧ ∀ n < m, ¬p n",
  "tactic-prompt":
  "theorem {m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h : ∃ n : ℕ, p n) : Nat.find h = m ↔ p m ∧ ∀ n < m, ¬p n := by constructor; sorry",
  "name": "find_eq_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h : ∃ n : ℕ, p n) : Nat.find h = m ↔ p m ∧ ∀ n < m, ¬p n",
  "args":
  "{m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h : ∃ n : ℕ, p n)"},
 {"type": "Nat.find h ≤ n ↔ ∃ m ≤ n, p m",
  "tactic-prompt":
  "theorem {m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h : ∃ n : ℕ, p n)  (n : ℕ) : Nat.find h ≤ n ↔ ∃ m ≤ n, p m := by simp only [exists_prop]; sorry",
  "name": "find_le_iff",
  "kind": "theorem",
  "first-tactic": "simp only [exists_prop]",
  "core-prompt":
  "{m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h : ∃ n : ℕ, p n)  (n : ℕ) : Nat.find h ≤ n ↔ ∃ m ≤ n, p m",
  "args":
  "{m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h : ∃ n : ℕ, p n)  (n : ℕ)"},
 {"type": "n ≤ Nat.find h ↔ ∀ m < n, ¬p m",
  "tactic-prompt":
  "theorem {m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h : ∃ n : ℕ, p n)  (n : ℕ) : n ≤ Nat.find h ↔ ∀ m < n, ¬p m := by simp_rw [← not_lt]; sorry",
  "name": "le_find_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [← not_lt]",
  "core-prompt":
  "{m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h : ∃ n : ℕ, p n)  (n : ℕ) : n ≤ Nat.find h ↔ ∀ m < n, ¬p m",
  "args":
  "{m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h : ∃ n : ℕ, p n)  (n : ℕ)"},
 {"type": "n < Nat.find h ↔ ∀ m ≤ n, ¬p m",
  "tactic-prompt":
  "theorem {m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h : ∃ n : ℕ, p n)  (n : ℕ) : n < Nat.find h ↔ ∀ m ≤ n, ¬p m := by simp only [← succ_le_iff]; sorry",
  "name": "lt_find_iff",
  "kind": "theorem",
  "first-tactic": "simp only [← succ_le_iff]",
  "core-prompt":
  "{m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h : ∃ n : ℕ, p n)  (n : ℕ) : n < Nat.find h ↔ ∀ m ≤ n, ¬p m",
  "args":
  "{m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h : ∃ n : ℕ, p n)  (n : ℕ)"},
 {"type": "Nat.find h = 0 ↔ p 0",
  "tactic-prompt":
  "theorem {m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h : ∃ n : ℕ, p n) : Nat.find h = 0 ↔ p 0 := by simp [find_eq_iff]; sorry",
  "name": "find_eq_zero",
  "kind": "theorem",
  "first-tactic": "simp [find_eq_iff]",
  "core-prompt":
  "{m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h : ∃ n : ℕ, p n) : Nat.find h = 0 ↔ p 0",
  "args":
  "{m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h : ∃ n : ℕ, p n)"},
 {"type": "Nat.find h₁ = Nat.find h₂ + 1",
  "tactic-prompt":
  "theorem {m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h₁ : ∃ n, p n)  (h₂ : ∃ n, p (n + 1))  (h0 : ¬p 0) : Nat.find h₁ = Nat.find h₂ + 1 := by refine' (find_eq_iff _).2 ⟨Nat.find_spec h₂, fun n hn => _⟩; sorry",
  "name": "find_comp_succ",
  "kind": "theorem",
  "first-tactic": "refine' (find_eq_iff _).2 ⟨Nat.find_spec h₂, fun n hn => _⟩",
  "core-prompt":
  "{m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h₁ : ∃ n, p n)  (h₂ : ∃ n, p (n + 1))  (h0 : ¬p 0) : Nat.find h₁ = Nat.find h₂ + 1",
  "args":
  "{m n k : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q] (h₁ : ∃ n, p n)  (h₂ : ∃ n, p (n + 1))  (h0 : ¬p 0)"},
 {"type": "Nat.findGreatest P (b + 1) = Nat.findGreatest P b",
  "tactic-prompt":
  "theorem {m n k : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P]  {b : ℕ} (h : ¬P (b + 1)) : Nat.findGreatest P (b + 1) = Nat.findGreatest P b := by simp [Nat.findGreatest]; sorry",
  "name": "findGreatest_of_not",
  "kind": "theorem",
  "first-tactic": "simp [Nat.findGreatest]",
  "core-prompt":
  "{m n k : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P]  {b : ℕ} (h : ¬P (b + 1)) : Nat.findGreatest P (b + 1) = Nat.findGreatest P b",
  "args":
  "{m n k : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P]  {b : ℕ} (h : ¬P (b + 1))"},
 {"type": "IsSqrt n (sqrt n)",
  "tactic-prompt":
  "theorem (n : ℕ) : IsSqrt n (sqrt n) := by match n with\n  | 0 => simp [IsSqrt]\n  | 1 => simp [IsSqrt]\n  | n + 2 =>\n    have h : ¬ (n + 2) ≤ 1 := by simp\n    simp only [IsSqrt]; sorry",
  "name": "sqrt_isSqrt",
  "kind": "theorem",
  "first-tactic":
  "match n with\n  | 0 => simp [IsSqrt]\n  | 1 => simp [IsSqrt]\n  | n + 2 =>\n    have h : ¬ (n + 2) ≤ 1 := by simp\n    simp only [IsSqrt]",
  "core-prompt": "(n : ℕ) : IsSqrt n (sqrt n)",
  "args": "(n : ℕ)"},
 {"type": "n ≤ sqrt n * sqrt n + sqrt n + sqrt n",
  "tactic-prompt":
  "theorem (n : ℕ) : n ≤ sqrt n * sqrt n + sqrt n + sqrt n := by rw [← succ_mul]; sorry",
  "name": "sqrt_le_add",
  "kind": "theorem",
  "first-tactic": "rw [← succ_mul]",
  "core-prompt": "(n : ℕ) : n ≤ sqrt n * sqrt n + sqrt n + sqrt n",
  "args": "(n : ℕ)"},
 {"type": "m ≤ sqrt n ↔ m ^ 2 ≤ n",
  "tactic-prompt":
  "theorem {m n : ℕ} : m ≤ sqrt n ↔ m ^ 2 ≤ n := by simpa only [pow_two] using le_sqrt; sorry",
  "name": "le_sqrt'",
  "kind": "theorem",
  "first-tactic": "simpa only [pow_two] using le_sqrt",
  "core-prompt": "{m n : ℕ} : m ≤ sqrt n ↔ m ^ 2 ≤ n",
  "args": "{m n : ℕ}"},
 {"type": "(∃ n, n ^ 2 = x) ↔ sqrt x ^ 2 = x",
  "tactic-prompt":
  "theorem (x : ℕ) : (∃ n, n ^ 2 = x) ↔ sqrt x ^ 2 = x := by simpa only [pow_two] using exists_mul_self x; sorry",
  "name": "exists_mul_self'",
  "kind": "theorem",
  "first-tactic": "simpa only [pow_two] using exists_mul_self x",
  "core-prompt": "(x : ℕ) : (∃ n, n ^ 2 = x) ↔ sqrt x ^ 2 = x",
  "args": "(x : ℕ)"},
 {"type": "¬∃ t, t * t = n",
  "tactic-prompt":
  "theorem {n m : ℕ}  (hl : m * m < n)  (hr : n < (m + 1) * (m + 1)) : ¬∃ t, t * t = n := by rintro ⟨t, rfl⟩; sorry",
  "name": "not_exists_sq",
  "kind": "theorem",
  "first-tactic": "rintro ⟨t, rfl⟩",
  "core-prompt":
  "{n m : ℕ}  (hl : m * m < n)  (hr : n < (m + 1) * (m + 1)) : ¬∃ t, t * t = n",
  "args": "{n m : ℕ}  (hl : m * m < n)  (hr : n < (m + 1) * (m + 1))"},
 {"type": "¬∃ t, t ^ 2 = n",
  "tactic-prompt":
  "theorem {n m : ℕ}  (hl : m ^ 2 < n)  (hr : n < (m + 1) ^ 2) : ¬∃ t, t ^ 2 = n := by simpa only [pow_two] using\n    not_exists_sq (by simpa only [pow_two] using hl) (by simpa only [pow_two] using hr); sorry",
  "name": "not_exists_sq'",
  "kind": "theorem",
  "first-tactic":
  "simpa only [pow_two] using\n    not_exists_sq (by simpa only [pow_two] using hl) (by simpa only [pow_two] using hr)",
  "core-prompt":
  "{n m : ℕ}  (hl : m ^ 2 < n)  (hr : n < (m + 1) ^ 2) : ¬∃ t, t ^ 2 = n",
  "args": "{n m : ℕ}  (hl : m ^ 2 < n)  (hr : n < (m + 1) ^ 2)"},
 {"type": "m = 1 ∨ m = p",
  "tactic-prompt":
  "theorem {p : ℕ}  (pp : p.Prime)  (m : ℕ)  (hm : m ∣ p) : m = 1 ∨ m = p := by obtain ⟨n, hn⟩ := hm; sorry",
  "name": "Prime.eq_one_or_self_of_dvd",
  "kind": "theorem",
  "first-tactic": "obtain ⟨n, hn⟩ := hm",
  "core-prompt":
  "{p : ℕ}  (pp : p.Prime)  (m : ℕ)  (hm : m ∣ p) : m = 1 ∨ m = p",
  "args": "{p : ℕ}  (pp : p.Prime)  (m : ℕ)  (hm : m ∣ p)"},
 {"type": "Prime p ↔ 2 ≤ p ∧ ∀ (m) (_ : m ∣ p), m = 1 ∨ m = p",
  "tactic-prompt":
  "theorem {p : ℕ} : Prime p ↔ 2 ≤ p ∧ ∀ (m) (_ : m ∣ p), m = 1 ∨ m = p := by refine' ⟨fun h => ⟨h.two_le, h.eq_one_or_self_of_dvd⟩, fun h => _⟩; sorry",
  "name": "prime_def_lt''",
  "kind": "theorem",
  "first-tactic":
  "refine' ⟨fun h => ⟨h.two_le, h.eq_one_or_self_of_dvd⟩, fun h => _⟩",
  "core-prompt": "{p : ℕ} : Prime p ↔ 2 ≤ p ∧ ∀ (m) (_ : m ∣ p), m = 1 ∨ m = p",
  "args": "{p : ℕ}"},
 {"type": "Prime n",
  "tactic-prompt":
  "theorem (n : ℕ)  (h1 : 1 < n)  (h : ∀ m < n, m ≠ 0 → n.coprime m) : Prime n := by refine' prime_def_lt.mpr ⟨h1, fun m mlt mdvd => _⟩; sorry",
  "name": "prime_of_coprime",
  "kind": "theorem",
  "first-tactic": "refine' prime_def_lt.mpr ⟨h1, fun m mlt mdvd => _⟩",
  "core-prompt":
  "(n : ℕ)  (h1 : 1 < n)  (h : ∀ m < n, m ≠ 0 → n.coprime m) : Prime n",
  "args": "(n : ℕ)  (h1 : 1 < n)  (h : ∀ m < n, m ≠ 0 → n.coprime m)"},
 {"type": "Prime 2",
  "tactic-prompt": "theorem  : Prime 2 := by decide; sorry",
  "name": "prime_two",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : Prime 2",
  "args": ""},
 {"type": "Prime 3",
  "tactic-prompt": "theorem  : Prime 3 := by decide; sorry",
  "name": "prime_three",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : Prime 3",
  "args": ""},
 {"type": "5 ≤ p",
  "tactic-prompt":
  "theorem {p : ℕ}  (hp : p.Prime)  (h_two : p ≠ 2)      (h_three : p ≠ 3) : 5 ≤ p := by by_contra' h; sorry",
  "name": "Prime.five_le_of_ne_two_of_ne_three",
  "kind": "theorem",
  "first-tactic": "by_contra' h",
  "core-prompt":
  "{p : ℕ}  (hp : p.Prime)  (h_two : p ≠ 2)      (h_three : p ≠ 3) : 5 ≤ p",
  "args": "{p : ℕ}  (hp : p.Prime)  (h_two : p ≠ 2)      (h_three : p ≠ 3)"},
 {"type": "¬Prime n",
  "tactic-prompt":
  "theorem {a b n : ℕ}  (h : a * b = n)  (h₁ : 1 < a)  (h₂ : 1 < b) : ¬Prime n := by rw [← h]; sorry",
  "name": "not_prime_mul'",
  "kind": "theorem",
  "first-tactic": "rw [← h]",
  "core-prompt":
  "{a b n : ℕ}  (h : a * b = n)  (h₁ : 1 < a)  (h₂ : 1 < b) : ¬Prime n",
  "args": "{a b n : ℕ}  (h : a * b = n)  (h₁ : 1 < a)  (h₂ : 1 < b)"},
 {"type": "Nat.Prime (a * b) ↔ a.Prime ∧ b = 1 ∨ b.Prime ∧ a = 1",
  "tactic-prompt":
  "theorem {a b : ℕ} : Nat.Prime (a * b) ↔ a.Prime ∧ b = 1 ∨ b.Prime ∧ a = 1 := by simp only [iff_self_iff]; sorry",
  "name": "prime_mul_iff",
  "kind": "theorem",
  "first-tactic": "simp only [iff_self_iff]",
  "core-prompt":
  "{a b : ℕ} : Nat.Prime (a * b) ↔ a.Prime ∧ b = 1 ∨ b.Prime ∧ a = 1",
  "args": "{a b : ℕ}"},
 {"type": "a ∣ p ↔ p = a",
  "tactic-prompt":
  "theorem {p a : ℕ}  (hp : p.Prime)  (a1 : a ≠ 1) : a ∣ p ↔ p = a := by refine'\n    ⟨_, by\n      rintro rfl\n      rfl⟩; sorry",
  "name": "Prime.dvd_iff_eq",
  "kind": "theorem",
  "first-tactic": "refine'\n    ⟨_, by\n      rintro rfl\n      rfl⟩",
  "core-prompt": "{p a : ℕ}  (hp : p.Prime)  (a1 : a ≠ 1) : a ∣ p ↔ p = a",
  "args": "{p a : ℕ}  (hp : p.Prime)  (a1 : a ≠ 1)"},
 {"type": "minFacProp n (minFac n)",
  "tactic-prompt":
  "theorem {n : ℕ}  (n1 : n ≠ 1) : minFacProp n (minFac n) := by by_cases n0 : n = 0; sorry",
  "name": "minFac_has_prop",
  "kind": "theorem",
  "first-tactic": "by_cases n0 : n = 0",
  "core-prompt": "{n : ℕ}  (n1 : n ≠ 1) : minFacProp n (minFac n)",
  "args": "{n : ℕ}  (n1 : n ≠ 1)"},
 {"type": "∀ {m : ℕ}, 2 ≤ m → m ∣ n → minFac n ≤ m",
  "tactic-prompt":
  "theorem {n : ℕ} : ∀ {m : ℕ}, 2 ≤ m → m ∣ n → minFac n ≤ m := by by_cases n1 : n = 1; sorry",
  "name": "minFac_le_of_dvd",
  "kind": "theorem",
  "first-tactic": "by_cases n1 : n = 1",
  "core-prompt": "{n : ℕ} : ∀ {m : ℕ}, 2 ≤ m → m ∣ n → minFac n ≤ m",
  "args": "{n : ℕ}"},
 {"type": "0 < minFac n",
  "tactic-prompt":
  "theorem (n : ℕ) : 0 < minFac n := by by_cases n1 : n = 1; sorry",
  "name": "minFac_pos",
  "kind": "theorem",
  "first-tactic": "by_cases n1 : n = 1",
  "core-prompt": "(n : ℕ) : 0 < minFac n",
  "args": "(n : ℕ)"},
 {"type": "minFac n = 1 ↔ n = 1",
  "tactic-prompt":
  "theorem {n : ℕ} : minFac n = 1 ↔ n = 1 := by constructor; sorry",
  "name": "minFac_eq_one_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{n : ℕ} : minFac n = 1 ↔ n = 1",
  "args": "{n : ℕ}"},
 {"type": "minFac n = 2 ↔ 2 ∣ n",
  "tactic-prompt":
  "theorem (n : ℕ) : minFac n = 2 ↔ 2 ∣ n := by constructor; sorry",
  "name": "minFac_eq_two_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "(n : ℕ) : minFac n = 2 ↔ 2 ∣ n",
  "args": "(n : ℕ)"},
 {"type": "a ∣ b",
  "tactic-prompt":
  "theorem {a b : ℕ}      (hdvd : ∀ p : ℕ, p.Prime → p ∣ a → p * a ∣ b) : a ∣ b := by obtain rfl | ha := eq_or_ne a 1; sorry",
  "name": "dvd_of_forall_prime_mul_dvd",
  "kind": "theorem",
  "first-tactic": "obtain rfl | ha := eq_or_ne a 1",
  "core-prompt":
  "{a b : ℕ}      (hdvd : ∀ p : ℕ, p.Prime → p ∣ a → p * a ∣ b) : a ∣ b",
  "args": "{a b : ℕ}      (hdvd : ∀ p : ℕ, p.Prime → p ∣ a → p * a ∣ b)"},
 {"type": "¬BddAbove { p | Prime p }",
  "tactic-prompt":
  "theorem  : ¬BddAbove { p | Prime p } := by rw [not_bddAbove_iff]; sorry",
  "name": "not_bddAbove_setOf_prime",
  "kind": "theorem",
  "first-tactic": "rw [not_bddAbove_iff]",
  "core-prompt": " : ¬BddAbove { p | Prime p }",
  "args": ""},
 {"type": "Even p ↔ p = 2",
  "tactic-prompt":
  "theorem {p : ℕ}  (hp : Prime p) : Even p ↔ p = 2 := by rw [even_iff_two_dvd]; sorry",
  "name": "Prime.even_iff",
  "kind": "theorem",
  "first-tactic": "rw [even_iff_two_dvd]",
  "core-prompt": "{p : ℕ}  (hp : Prime p) : Even p ↔ p = 2",
  "args": "{p : ℕ}  (hp : Prime p)"},
 {"type": "p % 2 = 1 ↔ p ≠ 2",
  "tactic-prompt":
  "theorem {p : ℕ}  [Fact p.Prime] : p % 2 = 1 ↔ p ≠ 2 := by refine' ⟨fun h hf => _, (Nat.Prime.eq_two_or_odd <| @Fact.out p.Prime _).resolve_left⟩; sorry",
  "name": "Prime.mod_two_eq_one_iff_ne_two",
  "kind": "theorem",
  "first-tactic":
  "refine' ⟨fun h hf => _, (Nat.Prime.eq_two_or_odd <| @Fact.out p.Prime _).resolve_left⟩",
  "core-prompt": "{p : ℕ}  [Fact p.Prime] : p % 2 = 1 ↔ p ≠ 2",
  "args": "{p : ℕ}  [Fact p.Prime]"},
 {"type": "coprime m n",
  "tactic-prompt":
  "theorem {m n : ℕ}  (H : ∀ k, Prime k → k ∣ m → ¬k ∣ n) : coprime m n := by rw [coprime_iff_gcd_eq_one]; sorry",
  "name": "coprime_of_dvd",
  "kind": "theorem",
  "first-tactic": "rw [coprime_iff_gcd_eq_one]",
  "core-prompt": "{m n : ℕ}  (H : ∀ k, Prime k → k ∣ m → ¬k ∣ n) : coprime m n",
  "args": "{m n : ℕ}  (H : ∀ k, Prime k → k ∣ m → ¬k ∣ n)"},
 {"type": "¬coprime m n ↔ ∃ p, Prime p ∧ p ∣ m ∧ p ∣ n",
  "tactic-prompt":
  "theorem {m n : ℕ} : ¬coprime m n ↔ ∃ p, Prime p ∧ p ∣ m ∧ p ∣ n := by apply Iff.intro; sorry",
  "name": "Prime.not_coprime_iff_dvd",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt": "{m n : ℕ} : ¬coprime m n ↔ ∃ p, Prime p ∧ p ∣ m ∧ p ∣ n",
  "args": "{m n : ℕ}"},
 {"type": "p ∣ m",
  "tactic-prompt":
  "theorem {p m n : ℕ}  (pp : Prime p)  (h : p ∣ m ^ n) : p ∣ m := by induction' n with n IH; sorry",
  "name": "Prime.dvd_of_dvd_pow",
  "kind": "theorem",
  "first-tactic": "induction' n with n IH",
  "core-prompt": "{p m n : ℕ}  (pp : Prime p)  (h : p ∣ m ^ n) : p ∣ m",
  "args": "{p m n : ℕ}  (pp : Prime p)  (h : p ∣ m ^ n)"},
 {"type": "a ^ k = p ↔ a = p ∧ k = 1",
  "tactic-prompt":
  "theorem {p a k : ℕ}  (hp : p.Prime) : a ^ k = p ↔ a = p ∧ k = 1 := by refine' ⟨fun h => _, fun h => by rw [h.1, h.2, pow_one]⟩; sorry",
  "name": "Prime.pow_eq_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, fun h => by rw [h.1, h.2, pow_one]⟩",
  "core-prompt": "{p a k : ℕ}  (hp : p.Prime) : a ^ k = p ↔ a = p ∧ k = 1",
  "args": "{p a k : ℕ}  (hp : p.Prime)"},
 {"type": "(n ^ k).minFac = n.minFac",
  "tactic-prompt":
  "theorem {n k : ℕ}  (hk : k ≠ 0) : (n ^ k).minFac = n.minFac := by rcases eq_or_ne n 1 with (rfl | hn); sorry",
  "name": "pow_minFac",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne n 1 with (rfl | hn)",
  "core-prompt": "{n k : ℕ}  (hk : k ≠ 0) : (n ^ k).minFac = n.minFac",
  "args": "{n k : ℕ}  (hk : k ≠ 0)"},
 {"type": "(p ^ k).minFac = p",
  "tactic-prompt":
  "theorem {p k : ℕ}  (hp : p.Prime)  (hk : k ≠ 0) : (p ^ k).minFac = p := by rw [Nat.pow_minFac hk]; sorry",
  "name": "Prime.pow_minFac",
  "kind": "theorem",
  "first-tactic": "rw [Nat.pow_minFac hk]",
  "core-prompt": "{p k : ℕ}  (hp : p.Prime)  (hk : k ≠ 0) : (p ^ k).minFac = p",
  "args": "{p k : ℕ}  (hp : p.Prime)  (hk : k ≠ 0)"},
 {"type": "i ∣ p ^ m ↔ ∃ k ≤ m, i = p ^ k",
  "tactic-prompt":
  "theorem {p : ℕ}  (pp : Prime p)  {m i : ℕ} : i ∣ p ^ m ↔ ∃ k ≤ m, i = p ^ k := by simp_rw [_root_.dvd_prime_pow  (prime_iff.mp pp)  m]; sorry",
  "name": "dvd_prime_pow",
  "kind": "theorem",
  "first-tactic": "simp_rw [_root_.dvd_prime_pow  (prime_iff.mp pp)  m]",
  "core-prompt":
  "{p : ℕ}  (pp : Prime p)  {m i : ℕ} : i ∣ p ^ m ↔ ∃ k ≤ m, i = p ^ k",
  "args": "{p : ℕ}  (pp : Prime p)  {m i : ℕ}"},
 {"type": "a = p ^ (k + 1)",
  "tactic-prompt":
  "theorem {a p k : ℕ}  (pp : Prime p)  (h₁ : ¬a ∣ p ^ k)      (h₂ : a ∣ p ^ (k + 1)) : a = p ^ (k + 1) := by obtain ⟨l, ⟨h, rfl⟩⟩ := (dvd_prime_pow pp).1 h₂; sorry",
  "name": "eq_prime_pow_of_dvd_least_prime_pow",
  "kind": "theorem",
  "first-tactic": "obtain ⟨l, ⟨h, rfl⟩⟩ := (dvd_prime_pow pp).1 h₂",
  "core-prompt":
  "{a p k : ℕ}  (pp : Prime p)  (h₁ : ¬a ∣ p ^ k)      (h₂ : a ∣ p ^ (k + 1)) : a = p ^ (k + 1)",
  "args":
  "{a p k : ℕ}  (pp : Prime p)  (h₁ : ¬a ∣ p ^ k)      (h₂ : a ∣ p ^ (k + 1))"},
 {"type": "n = 1 ↔ ∀ p : ℕ, p.Prime → ¬p ∣ n",
  "tactic-prompt":
  "theorem {n : ℕ} : n = 1 ↔ ∀ p : ℕ, p.Prime → ¬p ∣ n := by simpa using not_iff_not.mpr ne_one_iff_exists_prime_dvd; sorry",
  "name": "eq_one_iff_not_exists_prime_dvd",
  "kind": "theorem",
  "first-tactic": "simpa using not_iff_not.mpr ne_one_iff_exists_prime_dvd",
  "core-prompt": "{n : ℕ} : n = 1 ↔ ∀ p : ℕ, p.Prime → ¬p ∣ n",
  "args": "{n : ℕ}"},
 {"type": "p ^ (k + 1) ∣ m ∨ p ^ (l + 1) ∣ n",
  "tactic-prompt":
  "theorem {p : ℕ}  (p_prime : Prime p)  {m n k l : ℕ}      (hpm : p ^ k ∣ m)  (hpn : p ^ l ∣ n)  (hpmn : p ^ (k + l + 1) ∣ m * n) : p ^ (k + 1) ∣ m ∨ p ^ (l + 1) ∣ n := by have hpd : p ^ (k + l) * p ∣ m * n := by\n      let hpmn' : p ^ (succ (k + l)) ∣ m * n := hpmn\n      rwa [pow_succ'] at hpmn'; sorry",
  "name": "succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul",
  "kind": "theorem",
  "first-tactic":
  "have hpd : p ^ (k + l) * p ∣ m * n := by\n      let hpmn' : p ^ (succ (k + l)) ∣ m * n := hpmn\n      rwa [pow_succ'] at hpmn'",
  "core-prompt":
  "{p : ℕ}  (p_prime : Prime p)  {m n k l : ℕ}      (hpm : p ^ k ∣ m)  (hpn : p ^ l ∣ n)  (hpmn : p ^ (k + l + 1) ∣ m * n) : p ^ (k + 1) ∣ m ∨ p ^ (l + 1) ∣ n",
  "args":
  "{p : ℕ}  (p_prime : Prime p)  {m n k l : ℕ}      (hpm : p ^ k ∣ m)  (hpn : p ^ l ∣ n)  (hpmn : p ^ (k + l + 1) ∣ m * n)"},
 {"type": "pred n = (ppred n).getD 0",
  "tactic-prompt":
  "theorem (n : ℕ) : pred n = (ppred n).getD 0 := by cases n; sorry",
  "name": "pred_eq_ppred",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n : ℕ) : pred n = (ppred n).getD 0",
  "args": "(n : ℕ)"},
 {"type": "psub m n = none ↔ m < n",
  "tactic-prompt":
  "theorem {m n : ℕ} : psub m n = none ↔ m < n := by cases s : psub m n; sorry",
  "name": "psub_eq_none",
  "kind": "theorem",
  "first-tactic": "cases s : psub m n",
  "core-prompt": "{m n : ℕ} : psub m n = none ↔ m < n",
  "args": "{m n : ℕ}"},
 {"type": "0 = m * n ↔ m = 0 ∨ n = 0",
  "tactic-prompt":
  "theorem {m n k l : ℕ} : 0 = m * n ↔ m = 0 ∨ n = 0 := by rw [eq_comm]; sorry",
  "name": "zero_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt": "{m n k l : ℕ} : 0 = m * n ↔ m = 0 ∨ n = 0",
  "args": "{m n k l : ℕ}"},
 {"type": "min m n = 0 ↔ m = 0 ∨ n = 0",
  "tactic-prompt":
  "theorem {m n k l : ℕ} : min m n = 0 ↔ m = 0 ∨ n = 0 := by constructor; sorry",
  "name": "min_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{m n k l : ℕ} : min m n = 0 ↔ m = 0 ∨ n = 0",
  "args": "{m n k l : ℕ}"},
 {"type": "max m n = 0 ↔ m = 0 ∧ n = 0",
  "tactic-prompt":
  "theorem {m n k l : ℕ} : max m n = 0 ↔ m = 0 ∧ n = 0 := by constructor; sorry",
  "name": "max_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{m n k l : ℕ} : max m n = 0 ↔ m = 0 ∧ n = 0",
  "args": "{m n k l : ℕ}"},
 {"type": "m + n = max m n ↔ m = 0 ∨ n = 0",
  "tactic-prompt":
  "theorem {m n k l : ℕ} : m + n = max m n ↔ m = 0 ∨ n = 0 := by rw [← min_eq_zero_iff]; sorry",
  "name": "add_eq_max_iff",
  "kind": "theorem",
  "first-tactic": "rw [← min_eq_zero_iff]",
  "core-prompt": "{m n k l : ℕ} : m + n = max m n ↔ m = 0 ∨ n = 0",
  "args": "{m n k l : ℕ}"},
 {"type": "m + n = min m n ↔ m = 0 ∧ n = 0",
  "tactic-prompt":
  "theorem {m n k l : ℕ} : m + n = min m n ↔ m = 0 ∧ n = 0 := by rw [← max_eq_zero_iff]; sorry",
  "name": "add_eq_min_iff",
  "kind": "theorem",
  "first-tactic": "rw [← max_eq_zero_iff]",
  "core-prompt": "{m n k l : ℕ} : m + n = min m n ↔ m = 0 ∧ n = 0",
  "args": "{m n k l : ℕ}"},
 {"type": "0 < m + n",
  "tactic-prompt":
  "theorem {m n k l : ℕ} (m : ℕ)  {n : ℕ}  (h : 0 < n) : 0 < m + n := by rw [add_comm]; sorry",
  "name": "add_pos_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt": "{m n k l : ℕ} (m : ℕ)  {n : ℕ}  (h : 0 < n) : 0 < m + n",
  "args": "{m n k l : ℕ} (m : ℕ)  {n : ℕ}  (h : 0 < n)"},
 {"type": "m + n = 1 ↔ m = 0 ∧ n = 1 ∨ m = 1 ∧ n = 0",
  "tactic-prompt":
  "theorem {m n k l : ℕ} : m + n = 1 ↔ m = 0 ∧ n = 1 ∨ m = 1 ∧ n = 0 := by cases n; sorry",
  "name": "add_eq_one_iff",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "{m n k l : ℕ} : m + n = 1 ↔ m = 0 ∧ n = 1 ∨ m = 1 ∧ n = 0",
  "args": "{m n k l : ℕ}"},
 {"type": "m + n = 2 ↔ m = 0 ∧ n = 2 ∨ m = 1 ∧ n = 1 ∨ m = 2 ∧ n = 0",
  "tactic-prompt":
  "theorem {m n k l : ℕ} : m + n = 2 ↔ m = 0 ∧ n = 2 ∨ m = 1 ∧ n = 1 ∨ m = 2 ∧ n = 0 := by cases n; sorry",
  "name": "add_eq_two_iff",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{m n k l : ℕ} : m + n = 2 ↔ m = 0 ∧ n = 2 ∨ m = 1 ∧ n = 1 ∨ m = 2 ∧ n = 0",
  "args": "{m n k l : ℕ}"},
 {"type":
  "m + n = 3 ↔ m = 0 ∧ n = 3 ∨ m = 1 ∧ n = 2 ∨ m = 2 ∧ n = 1 ∨ m = 3 ∧ n = 0",
  "tactic-prompt":
  "theorem {m n k l : ℕ} : m + n = 3 ↔ m = 0 ∧ n = 3 ∨ m = 1 ∧ n = 2 ∨ m = 2 ∧ n = 1 ∨ m = 3 ∧ n = 0 := by cases n; sorry",
  "name": "add_eq_three_iff",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{m n k l : ℕ} : m + n = 3 ↔ m = 0 ∧ n = 3 ∨ m = 1 ∧ n = 2 ∨ m = 2 ∧ n = 1 ∨ m = 3 ∧ n = 0",
  "args": "{m n k l : ℕ}"},
 {"type": "n ≤ m ∧ m ≤ n + 1 ↔ m = n ∨ m = n + 1",
  "tactic-prompt":
  "theorem {m n k l : ℕ} : n ≤ m ∧ m ≤ n + 1 ↔ m = n ∨ m = n + 1 := by rw [le_add_one_iff]; sorry",
  "name": "le_and_le_add_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [le_add_one_iff]",
  "core-prompt": "{m n k l : ℕ} : n ≤ m ∧ m ≤ n + 1 ↔ m = n ∨ m = n + 1",
  "args": "{m n k l : ℕ}"},
 {"type": "m + k + 1 < n + l",
  "tactic-prompt":
  "theorem {m n k l : ℕ} (hab : m < n)  (hcd : k < l) : m + k + 1 < n + l := by rw [add_assoc]; sorry",
  "name": "add_succ_lt_add",
  "kind": "theorem",
  "first-tactic": "rw [add_assoc]",
  "core-prompt":
  "{m n k l : ℕ} (hab : m < n)  (hcd : k < l) : m + k + 1 < n + l",
  "args": "{m n k l : ℕ} (hab : m < n)  (hcd : k < l)"},
 {"type": "OrderedSub ℕ",
  "tactic-prompt":
  "instance {m n k l : ℕ} : OrderedSub ℕ := by constructor; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "constructor",
  "core-prompt": "{m n k l : ℕ} : OrderedSub ℕ",
  "args": "{m n k l : ℕ}"},
 {"type": "m ≤ k ∨ n ≤ l",
  "tactic-prompt":
  "theorem {m n k l : ℕ} (h : k + l = m + n - 1) : m ≤ k ∨ n ≤ l := by cases' le_or_lt m k with h' h'; sorry",
  "name": "le_or_le_of_add_eq_add_pred",
  "kind": "theorem",
  "first-tactic": "cases' le_or_lt m k with h' h'",
  "core-prompt": "{m n k l : ℕ} (h : k + l = m + n - 1) : m ≤ k ∨ n ≤ l",
  "args": "{m n k l : ℕ} (h : k + l = m + n - 1)"},
 {"type": "m ≤ n * m",
  "tactic-prompt":
  "theorem {m n k l : ℕ} (h : 0 < n) : m ≤ n * m := by conv =>\n    lhs\n    rw [← one_mul m]; sorry",
  "name": "le_mul_of_pos_left",
  "kind": "theorem",
  "first-tactic": "conv =>\n    lhs\n    rw [← one_mul m]",
  "core-prompt": "{m n k l : ℕ} (h : 0 < n) : m ≤ n * m",
  "args": "{m n k l : ℕ} (h : 0 < n)"},
 {"type": "m ≤ m * n",
  "tactic-prompt":
  "theorem {m n k l : ℕ} (h : 0 < n) : m ≤ m * n := by conv =>\n    lhs\n    rw [← mul_one m]; sorry",
  "name": "le_mul_of_pos_right",
  "kind": "theorem",
  "first-tactic": "conv =>\n    lhs\n    rw [← mul_one m]",
  "core-prompt": "{m n k l : ℕ} (h : 0 < n) : m ≤ m * n",
  "args": "{m n k l : ℕ} (h : 0 < n)"},
 {"type": "n ≤ i + (n - 1)",
  "tactic-prompt":
  "theorem {m n k l : ℕ} (n : ℕ)  {i : ℕ}  (hi : i ≠ 0) : n ≤ i + (n - 1) := by refine le_trans ?_ add_tsub_le_assoc; sorry",
  "name": "le_add_pred_of_pos",
  "kind": "theorem",
  "first-tactic": "refine le_trans ?_ add_tsub_le_assoc",
  "core-prompt":
  "{m n k l : ℕ} (n : ℕ)  {i : ℕ}  (hi : i ≠ 0) : n ≤ i + (n - 1)",
  "args": "{m n k l : ℕ} (n : ℕ)  {i : ℕ}  (hi : i ≠ 0)"},
 {"type": "m * n / (k * l) = m / k * (n / l)",
  "tactic-prompt":
  "theorem {m n k l : ℕ} (hmk : k ∣ m)  (hnl : l ∣ n) : m * n / (k * l) = m / k * (n / l) := by rcases k.eq_zero_or_pos with (rfl | hk0); sorry",
  "name": "mul_div_mul_comm_of_dvd_dvd",
  "kind": "theorem",
  "first-tactic": "rcases k.eq_zero_or_pos with (rfl | hk0)",
  "core-prompt":
  "{m n k l : ℕ} (hmk : k ∣ m)  (hnl : l ∣ n) : m * n / (k * l) = m / k * (n / l)",
  "args": "{m n k l : ℕ} (hmk : k ∣ m)  (hnl : l ∣ n)"},
 {"type": "2 * (n / 2) = n - 1",
  "tactic-prompt":
  "theorem {m n k l : ℕ} (hn : n % 2 = 1) : 2 * (n / 2) = n - 1 := by conv =>\n    rhs\n    rw [← Nat.mod_add_div n 2]; sorry",
  "name": "two_mul_odd_div_two",
  "kind": "theorem",
  "first-tactic": "conv =>\n    rhs\n    rw [← Nat.mod_add_div n 2]",
  "core-prompt": "{m n k l : ℕ} (hn : n % 2 = 1) : 2 * (n / 2) = n - 1",
  "args": "{m n k l : ℕ} (hn : n % 2 = 1)"},
 {"type": "m / (m / n) = n",
  "tactic-prompt":
  "theorem {m n k l : ℕ} (h : n ∣ m)  (hm : m ≠ 0) : m / (m / n) = n := by rcases h with ⟨_, rfl⟩; sorry",
  "name": "div_div_self",
  "kind": "theorem",
  "first-tactic": "rcases h with ⟨_, rfl⟩",
  "core-prompt": "{m n k l : ℕ} (h : n ∣ m)  (hm : m ≠ 0) : m / (m / n) = n",
  "args": "{m n k l : ℕ} (h : n ∣ m)  (hm : m ≠ 0)"},
 {"type": "m % (n * k) / n = m / n % k",
  "tactic-prompt":
  "theorem {m n k l : ℕ} (m n k : ℕ) : m % (n * k) / n = m / n % k := by rcases Nat.eq_zero_or_pos n with (rfl | hn); sorry",
  "name": "mod_mul_right_div_self",
  "kind": "theorem",
  "first-tactic": "rcases Nat.eq_zero_or_pos n with (rfl | hn)",
  "core-prompt": "{m n k l : ℕ} (m n k : ℕ) : m % (n * k) / n = m / n % k",
  "args": "{m n k l : ℕ} (m n k : ℕ)"},
 {"type": "m % (k * n) / n = m / n % k",
  "tactic-prompt":
  "theorem {m n k l : ℕ} (m n k : ℕ) : m % (k * n) / n = m / n % k := by rw [mul_comm k]; sorry",
  "name": "mod_mul_left_div_self",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm k]",
  "core-prompt": "{m n k l : ℕ} (m n k : ℕ) : m % (k * n) / n = m / n % k",
  "args": "{m n k l : ℕ} (m n k : ℕ)"},
 {"type": "¬m ∣ n",
  "tactic-prompt":
  "theorem {m n k l : ℕ} (h1 : 0 < n)  (h2 : n < m) : ¬m ∣ n := by rintro ⟨k, rfl⟩; sorry",
  "name": "not_dvd_of_pos_of_lt",
  "kind": "theorem",
  "first-tactic": "rintro ⟨k, rfl⟩",
  "core-prompt": "{m n k l : ℕ} (h1 : 0 < n)  (h2 : n < m) : ¬m ∣ n",
  "args": "{m n k l : ℕ} (h1 : 0 < n)  (h2 : n < m)"},
 {"type": "(m - n) % k = 0",
  "tactic-prompt":
  "theorem {m n k l : ℕ} (h : m % k = n % k) : (m - n) % k = 0 := by rw [← Nat.mod_add_div m k]; sorry",
  "name": "sub_mod_eq_zero_of_mod_eq",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.mod_add_div m k]",
  "core-prompt": "{m n k l : ℕ} (h : m % k = n % k) : (m - n) % k = 0",
  "args": "{m n k l : ℕ} (h : m % k = n % k)"},
 {"type":
  "(m + n) % k = if k ≤ m % k + n % k then m % k + n % k - k else m % k + n % k",
  "tactic-prompt":
  "theorem {m n k l : ℕ} : (m + n) % k = if k ≤ m % k + n % k then m % k + n % k - k else m % k + n % k := by cases k; sorry",
  "name": "add_mod_eq_ite",
  "kind": "theorem",
  "first-tactic": "cases k",
  "core-prompt":
  "{m n k l : ℕ} : (m + n) % k = if k ≤ m % k + n % k then m % k + n % k - k else m % k + n % k",
  "args": "{m n k l : ℕ}"},
 {"type": "m / n = m ↔ m = 0 ∨ n = 1",
  "tactic-prompt":
  "theorem {m n k l : ℕ} : m / n = m ↔ m = 0 ∨ n = 1 := by constructor; sorry",
  "name": "div_eq_self",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{m n k l : ℕ} : m / n = m ↔ m = 0 ∨ n = 1",
  "args": "{m n k l : ℕ}"},
 {"type": "m / n = (m - m % n) / n",
  "tactic-prompt":
  "theorem {m n k l : ℕ} : m / n = (m - m % n) / n := by by_cases n0 : n = 0; sorry",
  "name": "div_eq_sub_mod_div",
  "kind": "theorem",
  "first-tactic": "by_cases n0 : n = 0",
  "core-prompt": "{m n k l : ℕ} : m / n = (m - m % n) / n",
  "args": "{m n k l : ℕ}"},
 {"type": "¬n ∣ m",
  "tactic-prompt":
  "theorem {m n k l : ℕ} (h1 : n * k < m)  (h2 : m < n * (k + 1)) : ¬n ∣ m := by rintro ⟨d, rfl⟩; sorry",
  "name": "not_dvd_of_between_consec_multiples",
  "kind": "theorem",
  "first-tactic": "rintro ⟨d, rfl⟩",
  "core-prompt":
  "{m n k l : ℕ} (h1 : n * k < m)  (h2 : m < n * (k + 1)) : ¬n ∣ m",
  "args": "{m n k l : ℕ} (h1 : n * k < m)  (h2 : m < n * (k + 1))"},
 {"type": "0 < Nat.find h ↔ ¬p 0",
  "tactic-prompt":
  "theorem {m n k l : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q]  --Porting note: removing `simp` attribute as `simp` can prove it (h : ∃ n : ℕ, p n) : 0 < Nat.find h ↔ ¬p 0 := by rw [pos_iff_ne_zero]; sorry",
  "name": "find_pos",
  "kind": "theorem",
  "first-tactic": "rw [pos_iff_ne_zero]",
  "core-prompt":
  "{m n k l : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q]  --Porting note: removing `simp` attribute as `simp` can prove it (h : ∃ n : ℕ, p n) : 0 < Nat.find h ↔ ¬p 0",
  "args":
  "{m n k l : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q]  --Porting note: removing `simp` attribute as `simp` can prove it (h : ∃ n : ℕ, p n)"},
 {"type": "Nat.find hₘ + n = Nat.find hₙ",
  "tactic-prompt":
  "theorem {m n k l : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q]  --Porting note: removing `simp` attribute as `simp` can prove it {hₘ : ∃ m, p (m + n)}  {hₙ : ∃ n, p n}  (hn : n ≤ Nat.find hₙ) : Nat.find hₘ + n = Nat.find hₙ := by refine ((le_find_iff _ _).2 fun m hm hpm => hm.not_le ?_).antisymm ?_; sorry",
  "name": "find_add",
  "kind": "theorem",
  "first-tactic":
  "refine ((le_find_iff _ _).2 fun m hm hpm => hm.not_le ?_).antisymm ?_",
  "core-prompt":
  "{m n k l : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q]  --Porting note: removing `simp` attribute as `simp` can prove it {hₘ : ∃ m, p (m + n)}  {hₙ : ∃ n, p n}  (hn : n ≤ Nat.find hₙ) : Nat.find hₘ + n = Nat.find hₙ",
  "args":
  "{m n k l : ℕ}  {p q : ℕ → Prop}  [DecidablePred p]  [DecidablePred q]  --Porting note: removing `simp` attribute as `simp` can prove it {hₘ : ∃ m, p (m + n)}  {hₙ : ∃ n, p n}  (hn : n ≤ Nat.find hₙ)"},
 {"type":
  "Nat.findGreatest P k = m ↔ m ≤ k ∧ (m ≠ 0 → P m) ∧ ∀ ⦃n⦄, m < n → n ≤ k → ¬P n",
  "tactic-prompt":
  "theorem {m n k l : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P] : Nat.findGreatest P k = m ↔ m ≤ k ∧ (m ≠ 0 → P m) ∧ ∀ ⦃n⦄, m < n → n ≤ k → ¬P n := by induction' k with k ihk generalizing m; sorry",
  "name": "findGreatest_eq_iff",
  "kind": "theorem",
  "first-tactic": "induction' k with k ihk generalizing m",
  "core-prompt":
  "{m n k l : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P] : Nat.findGreatest P k = m ↔ m ≤ k ∧ (m ≠ 0 → P m) ∧ ∀ ⦃n⦄, m < n → n ≤ k → ¬P n",
  "args": "{m n k l : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P]"},
 {"type": "Nat.findGreatest P k = 0 ↔ ∀ ⦃n⦄, 0 < n → n ≤ k → ¬P n",
  "tactic-prompt":
  "theorem {m n k l : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P] : Nat.findGreatest P k = 0 ↔ ∀ ⦃n⦄, 0 < n → n ≤ k → ¬P n := by simp [findGreatest_eq_iff]; sorry",
  "name": "findGreatest_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "simp [findGreatest_eq_iff]",
  "core-prompt":
  "{m n k l : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P] : Nat.findGreatest P k = 0 ↔ ∀ ⦃n⦄, 0 < n → n ≤ k → ¬P n",
  "args": "{m n k l : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P]"},
 {"type": "P (Nat.findGreatest P n)",
  "tactic-prompt":
  "theorem {m n k l : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P] (hmb : m ≤ n)  (hm : P m) : P (Nat.findGreatest P n) := by by_cases h : Nat.findGreatest P n = 0; sorry",
  "name": "findGreatest_spec",
  "kind": "theorem",
  "first-tactic": "by_cases h : Nat.findGreatest P n = 0",
  "core-prompt":
  "{m n k l : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P] (hmb : m ≤ n)  (hm : P m) : P (Nat.findGreatest P n)",
  "args":
  "{m n k l : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P] (hmb : m ≤ n)  (hm : P m)"},
 {"type": "Monotone (Nat.findGreatest P)",
  "tactic-prompt":
  "theorem {m n k l : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P] (P : ℕ → Prop)  [DecidablePred P] : Monotone (Nat.findGreatest P) := by refine monotone_nat_of_le_succ fun n => ?_; sorry",
  "name": "findGreatest_mono_right",
  "kind": "theorem",
  "first-tactic": "refine monotone_nat_of_le_succ fun n => ?_",
  "core-prompt":
  "{m n k l : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P] (P : ℕ → Prop)  [DecidablePred P] : Monotone (Nat.findGreatest P)",
  "args":
  "{m n k l : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P] (P : ℕ → Prop)  [DecidablePred P]"},
 {"type": "Nat.findGreatest P ≤ Nat.findGreatest Q",
  "tactic-prompt":
  "theorem {m n k l : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P] [DecidablePred Q]  (hPQ : P ≤ Q) : Nat.findGreatest P ≤ Nat.findGreatest Q := by intro n; sorry",
  "name": "findGreatest_mono_left",
  "kind": "theorem",
  "first-tactic": "intro n",
  "core-prompt":
  "{m n k l : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P] [DecidablePred Q]  (hPQ : P ≤ Q) : Nat.findGreatest P ≤ Nat.findGreatest Q",
  "args":
  "{m n k l : ℕ}  {P Q : ℕ → Prop}  [DecidablePred P] [DecidablePred Q]  (hPQ : P ≤ Q)"},
 {"type": "a < n / d ↔ d * a < n",
  "tactic-prompt":
  "theorem {m n k : ℕ} {n d : ℕ}  (hnd : d ∣ n)  (a : ℕ) : a < n / d ↔ d * a < n := by rcases d.eq_zero_or_pos with (rfl | hd0); sorry",
  "name": "lt_div_iff_mul_lt",
  "kind": "theorem",
  "first-tactic": "rcases d.eq_zero_or_pos with (rfl | hd0)",
  "core-prompt":
  "{m n k : ℕ} {n d : ℕ}  (hnd : d ∣ n)  (a : ℕ) : a < n / d ↔ d * a < n",
  "args": "{m n k : ℕ} {n d : ℕ}  (hnd : d ∣ n)  (a : ℕ)"},
 {"type": "n / x = n / y ↔ x = y",
  "tactic-prompt":
  "theorem {m n k : ℕ} {n x y : ℕ}  (hn : n ≠ 0)  (hx : x ∣ n)  (hy : y ∣ n) : n / x = n / y ↔ x = y := by constructor; sorry",
  "name": "div_eq_iff_eq_of_dvd_dvd",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{m n k : ℕ} {n x y : ℕ}  (hn : n ≠ 0)  (hx : x ∣ n)  (hy : y ∣ n) : n / x = n / y ↔ x = y",
  "args": "{m n k : ℕ} {n x y : ℕ}  (hn : n ≠ 0)  (hx : x ∣ n)  (hy : y ∣ n)"},
 {"type": "¬2 ∣ bit1 n",
  "tactic-prompt":
  "theorem {m n k : ℕ} (n : ℕ) : ¬2 ∣ bit1 n := by rw [bit1]; sorry",
  "name": "not_two_dvd_bit1",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt": "{m n k : ℕ} (n : ℕ) : ¬2 ∣ bit1 n",
  "args": "{m n k : ℕ} (n : ℕ)"},
 {"type": "k ∣ m - n",
  "tactic-prompt":
  "theorem {m n k : ℕ} {k m n : ℕ}  (h₁ : k ∣ m)  (h₂ : k ∣ n) : k ∣ m - n := by cases' le_total n m with H H; sorry",
  "name": "dvd_sub'",
  "kind": "theorem",
  "first-tactic": "cases' le_total n m with H H",
  "core-prompt":
  "{m n k : ℕ} {k m n : ℕ}  (h₁ : k ∣ m)  (h₂ : k ∣ n) : k ∣ m - n",
  "args": "{m n k : ℕ} {k m n : ℕ}  (h₁ : k ∣ m)  (h₂ : k ∣ n)"},
 {"type": "(a + 1) / b = a / b + 1",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b : ℕ}  (hba : b ∣ a + 1) : (a + 1) / b = a / b + 1 := by rw [succ_div]; sorry",
  "name": "succ_div_of_dvd",
  "kind": "theorem",
  "first-tactic": "rw [succ_div]",
  "core-prompt":
  "{m n k : ℕ} {a b : ℕ}  (hba : b ∣ a + 1) : (a + 1) / b = a / b + 1",
  "args": "{m n k : ℕ} {a b : ℕ}  (hba : b ∣ a + 1)"},
 {"type": "(a + 1) / b = a / b",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b : ℕ}  (hba : ¬b ∣ a + 1) : (a + 1) / b = a / b := by rw [succ_div]; sorry",
  "name": "succ_div_of_not_dvd",
  "kind": "theorem",
  "first-tactic": "rw [succ_div]",
  "core-prompt":
  "{m n k : ℕ} {a b : ℕ}  (hba : ¬b ∣ a + 1) : (a + 1) / b = a / b",
  "args": "{m n k : ℕ} {a b : ℕ}  (hba : ¬b ∣ a + 1)"},
 {"type": "m % n / n = 0",
  "tactic-prompt":
  "theorem {m n k : ℕ} (m n : ℕ) : m % n / n = 0 := by cases n; sorry",
  "name": "mod_div_self",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "{m n k : ℕ} (m n : ℕ) : m % n / n = 0",
  "args": "{m n k : ℕ} (m n : ℕ)"},
 {"type": "(∃ k : ℕ, a * k < n ∧ n < a * (k + 1)) ↔ ¬a ∣ n",
  "tactic-prompt":
  "theorem {m n k : ℕ} (n : ℕ)  {a : ℕ}  (ha : 0 < a) : (∃ k : ℕ, a * k < n ∧ n < a * (k + 1)) ↔ ¬a ∣ n := by refine'\n    ⟨fun ⟨k, hk1, hk2⟩ => not_dvd_of_between_consec_multiples hk1 hk2, fun han =>\n      ⟨n / a, ⟨lt_of_le_of_ne (mul_div_le n a) _, lt_mul_div_succ _ ha⟩⟩⟩; sorry",
  "name": "not_dvd_iff_between_consec_multiples",
  "kind": "theorem",
  "first-tactic":
  "refine'\n    ⟨fun ⟨k, hk1, hk2⟩ => not_dvd_of_between_consec_multiples hk1 hk2, fun han =>\n      ⟨n / a, ⟨lt_of_le_of_ne (mul_div_le n a) _, lt_mul_div_succ _ ha⟩⟩⟩",
  "core-prompt":
  "{m n k : ℕ} (n : ℕ)  {a : ℕ}  (ha : 0 < a) : (∃ k : ℕ, a * k < n ∧ n < a * (k + 1)) ↔ ¬a ∣ n",
  "args": "{m n k : ℕ} (n : ℕ)  {a : ℕ}  (ha : 0 < a)"},
 {"type": "a / d < b / d",
  "tactic-prompt":
  "theorem {m n k : ℕ} {a b d : ℕ}  (hdb : d ∣ b)  (h : a < b) : a / d < b / d := by rw [Nat.lt_div_iff_mul_lt hdb]; sorry",
  "name": "div_lt_div_of_lt_of_dvd",
  "kind": "theorem",
  "first-tactic": "rw [Nat.lt_div_iff_mul_lt hdb]",
  "core-prompt":
  "{m n k : ℕ} {a b d : ℕ}  (hdb : d ∣ b)  (h : a < b) : a / d < b / d",
  "args": "{m n k : ℕ} {a b d : ℕ}  (hdb : d ∣ b)  (h : a < b)"},
 {"type": "{0} ∪ range succ = univ",
  "tactic-prompt": "theorem  : {0} ∪ range succ = univ := by ext n; sorry",
  "name": "zero_union_range_succ",
  "kind": "theorem",
  "first-tactic": "ext n",
  "core-prompt": " : {0} ∪ range succ = univ",
  "args": ""},
 {"type": "range succ = { i | 0 < i }",
  "tactic-prompt":
  "theorem  : range succ = { i | 0 < i } := by ext (_ | i); sorry",
  "name": "range_succ",
  "kind": "theorem",
  "first-tactic": "ext (_ | i)",
  "core-prompt": " : range succ = { i | 0 < i }",
  "args": ""},
 {"type": "{f 0} ∪ range (f ∘ succ) = range f",
  "tactic-prompt":
  "theorem {α : Type _} (f : ℕ → α) : {f 0} ∪ range (f ∘ succ) = range f := by rw [← image_singleton]; sorry",
  "name": "range_of_succ",
  "kind": "theorem",
  "first-tactic": "rw [← image_singleton]",
  "core-prompt":
  "{α : Type _} (f : ℕ → α) : {f 0} ∪ range (f ∘ succ) = range f",
  "args": "{α : Type _} (f : ℕ → α)"},
 {"type":
  "(Set.range fun n => Nat.rec x f n : Set α) =\n      {x} ∪ Set.range fun n => Nat.rec (f 0 x) (f ∘ succ) n",
  "tactic-prompt":
  "theorem {α : Type _} {α : Type _}  (x : α)  (f : ℕ → α → α) : (Set.range fun n => Nat.rec x f n : Set α) =\n      {x} ∪ Set.range fun n => Nat.rec (f 0 x) (f ∘ succ) n := by convert (range_of_succ (fun n => Nat.rec x f n : ℕ → α)).symm; sorry",
  "name": "range_rec",
  "kind": "theorem",
  "first-tactic":
  "convert (range_of_succ (fun n => Nat.rec x f n : ℕ → α)).symm",
  "core-prompt":
  "{α : Type _} {α : Type _}  (x : α)  (f : ℕ → α → α) : (Set.range fun n => Nat.rec x f n : Set α) =\n      {x} ∪ Set.range fun n => Nat.rec (f 0 x) (f ∘ succ) n",
  "args": "{α : Type _} {α : Type _}  (x : α)  (f : ℕ → α → α)"},
 {"type": "1 ≤ m ^ n",
  "tactic-prompt":
  "theorem (n m : ℕ)  (h : 0 < m) : 1 ≤ m ^ n := by rw [← one_pow n]; sorry",
  "name": "one_le_pow",
  "kind": "theorem",
  "first-tactic": "rw [← one_pow n]",
  "core-prompt": "(n m : ℕ)  (h : 0 < m) : 1 ≤ m ^ n",
  "args": "(n m : ℕ)  (h : 0 < m)"},
 {"type": "1 < m ^ n",
  "tactic-prompt":
  "theorem (n m : ℕ)  (h₀ : 0 < n)  (h₁ : 1 < m) : 1 < m ^ n := by rw [← one_pow n]; sorry",
  "name": "one_lt_pow",
  "kind": "theorem",
  "first-tactic": "rw [← one_pow n]",
  "core-prompt": "(n m : ℕ)  (h₀ : 0 < n)  (h₁ : 1 < m) : 1 < m ^ n",
  "args": "(n m : ℕ)  (h₀ : 0 < n)  (h₁ : 1 < m)"},
 {"type": "1 < n ^ k ↔ 1 < n",
  "tactic-prompt":
  "theorem {k n : ℕ}  (h : 0 ≠ k) : 1 < n ^ k ↔ 1 < n := by rcases n with (rfl | n); sorry",
  "name": "one_lt_pow_iff",
  "kind": "theorem",
  "first-tactic": "rcases n with (rfl | n)",
  "core-prompt": "{k n : ℕ}  (h : 0 ≠ k) : 1 < n ^ k ↔ 1 < n",
  "args": "{k n : ℕ}  (h : 0 ≠ k)"},
 {"type": "n * q < a * q ^ (n + 1)",
  "tactic-prompt":
  "theorem {n a q : ℕ}  (a0 : 0 < a)  (q1 : 1 < q) : n * q < a * q ^ (n + 1) := by rw [pow_succ]; sorry",
  "name": "mul_lt_mul_pow_succ",
  "kind": "theorem",
  "first-tactic": "rw [pow_succ]",
  "core-prompt":
  "{n a q : ℕ}  (a0 : 0 < a)  (q1 : 1 < q) : n * q < a * q ^ (n + 1)",
  "args": "{n a q : ℕ}  (a0 : 0 < a)  (q1 : 1 < q)"},
 {"type": "a ^ 2 - b ^ 2 = (a + b) * (a - b)",
  "tactic-prompt":
  "theorem (a b : ℕ) : a ^ 2 - b ^ 2 = (a + b) * (a - b) := by rw [sq]; sorry",
  "name": "sq_sub_sq",
  "kind": "theorem",
  "first-tactic": "rw [sq]",
  "core-prompt": "(a b : ℕ) : a ^ 2 - b ^ 2 = (a + b) * (a - b)",
  "args": "(a b : ℕ)"},
 {"type": "a ^ b % n = (a % n) ^ b % n",
  "tactic-prompt":
  "theorem (a b n : ℕ) : a ^ b % n = (a % n) ^ b % n := by induction' b with b ih; sorry",
  "name": "pow_mod",
  "kind": "theorem",
  "first-tactic": "induction' b with b ih",
  "core-prompt": "(a b n : ℕ) : a ^ b % n = (a % n) ^ b % n",
  "args": "(a b n : ℕ)"},
 {"type": "m % b ^ succ w = b * (m / b % b ^ w) + m % b",
  "tactic-prompt":
  "theorem {b : ℕ}  (w m : ℕ) : m % b ^ succ w = b * (m / b % b ^ w) + m % b := by by_cases b_h : b = 0; sorry",
  "name": "mod_pow_succ",
  "kind": "theorem",
  "first-tactic": "by_cases b_h : b = 0",
  "core-prompt":
  "{b : ℕ}  (w m : ℕ) : m % b ^ succ w = b * (m / b % b ^ w) + m % b",
  "args": "{b : ℕ}  (w m : ℕ)"},
 {"type": "x ^ k ∣ x ^ l ↔ k ≤ l",
  "tactic-prompt":
  "theorem {x k l : ℕ}  (w : 1 < x) : x ^ k ∣ x ^ l ↔ k ≤ l := by rw [pow_dvd_pow_iff_pow_le_pow (lt_of_succ_lt w)]; sorry",
  "name": "pow_dvd_pow_iff_le_right",
  "kind": "theorem",
  "first-tactic": "rw [pow_dvd_pow_iff_pow_le_pow (lt_of_succ_lt w)]",
  "core-prompt": "{x k l : ℕ}  (w : 1 < x) : x ^ k ∣ x ^ l ↔ k ≤ l",
  "args": "{x k l : ℕ}  (w : 1 < x)"},
 {"type": "p ∣ m",
  "tactic-prompt":
  "theorem {p k m : ℕ}  (hk : 1 ≤ k)  (hpk : p ^ k ∣ m) : p ∣ m := by rw [← pow_one p]; sorry",
  "name": "dvd_of_pow_dvd",
  "kind": "theorem",
  "first-tactic": "rw [← pow_one p]",
  "core-prompt": "{p k m : ℕ}  (hk : 1 ≤ k)  (hpk : p ^ k ∣ m) : p ∣ m",
  "args": "{p k m : ℕ}  (hk : 1 ≤ k)  (hpk : p ^ k ∣ m)"},
 {"type": "x ^ m / x ^ n = x ^ (m - n)",
  "tactic-prompt":
  "theorem {x m n : ℕ}  (h : n ≤ m)  (hx : 0 < x) : x ^ m / x ^ n = x ^ (m - n) := by rw [Nat.div_eq_iff_eq_mul_left (pow_pos hx n) (pow_dvd_pow _ h)]; sorry",
  "name": "pow_div",
  "kind": "theorem",
  "first-tactic":
  "rw [Nat.div_eq_iff_eq_mul_left (pow_pos hx n) (pow_dvd_pow _ h)]",
  "core-prompt":
  "{x m n : ℕ}  (h : n ≤ m)  (hx : 0 < x) : x ^ m / x ^ n = x ^ (m - n)",
  "args": "{x m n : ℕ}  (h : n ≤ m)  (hx : 0 < x)"},
 {"type": "i < n",
  "tactic-prompt":
  "theorem {p i n : ℕ}  (hn : n ≠ 0)  (hp : 2 ≤ p)  (h : p ^ i ∣ n) : i < n := by rw [← pow_lt_iff_lt_right hp]; sorry",
  "name": "lt_of_pow_dvd_right",
  "kind": "theorem",
  "first-tactic": "rw [← pow_lt_iff_lt_right hp]",
  "core-prompt":
  "{p i n : ℕ}  (hn : n ≠ 0)  (hp : 2 ≤ p)  (h : p ^ i ∣ n) : i < n",
  "args": "{p i n : ℕ}  (hn : n ≠ 0)  (hp : 2 ≤ p)  (h : p ^ i ∣ n)"},
 {"type": "x * k ≤ y",
  "tactic-prompt":
  "lemma (k x y : ℕ)  (h : x ≤ y / k) : x * k ≤ y := by by_cases hk : k = 0; sorry",
  "name": "mul_le_of_le_div",
  "kind": "lemma",
  "first-tactic": "by_cases hk : k = 0",
  "core-prompt": "(k x y : ℕ)  (h : x ≤ y / k) : x * k ≤ y",
  "args": "(k x y : ℕ)  (h : x ≤ y / k)"},
 {"type": "(a / b) * (c / d) ≤ (a * c) / (b * d)",
  "tactic-prompt":
  "lemma (a b c d : ℕ) : (a / b) * (c / d) ≤ (a * c) / (b * d) := by by_cases hb : b = 0; sorry",
  "name": "div_mul_div_le",
  "kind": "lemma",
  "first-tactic": "by_cases hb : b = 0",
  "core-prompt": "(a b c d : ℕ) : (a / b) * (c / d) ≤ (a * c) / (b * d)",
  "args": "(a b c d : ℕ)"},
 {"type":
  "let iter_next (n guess : ℕ) := (guess + n / guess) / 2;\n  sqrt.iter n k ≤ iter_next n (sqrt.iter n k)",
  "tactic-prompt":
  "lemma (n k : ℕ) : let iter_next (n guess : ℕ) := (guess + n / guess) / 2;\n  sqrt.iter n k ≤ iter_next n (sqrt.iter n k) := by intro iter_next; sorry",
  "name": "iter_fp_bound",
  "kind": "lemma",
  "first-tactic": "intro iter_next",
  "core-prompt":
  "(n k : ℕ) : let iter_next (n guess : ℕ) := (guess + n / guess) / 2;\n  sqrt.iter n k ≤ iter_next n (sqrt.iter n k)",
  "args": "(n k : ℕ)"},
 {"type": "sqrt.iter n guess * sqrt.iter n guess ≤ n",
  "tactic-prompt":
  "lemma (n guess : ℕ) : sqrt.iter n guess * sqrt.iter n guess ≤ n := by unfold sqrt.iter; sorry",
  "name": "sqrt.iter_sq_le",
  "kind": "lemma",
  "first-tactic": "unfold sqrt.iter",
  "core-prompt": "(n guess : ℕ) : sqrt.iter n guess * sqrt.iter n guess ≤ n",
  "args": "(n guess : ℕ)"},
 {"type": "n < (sqrt.iter n guess + 1) * (sqrt.iter n guess + 1)",
  "tactic-prompt":
  "lemma (n guess : ℕ)  (hn : n < (guess + 1) * (guess + 1)) : n < (sqrt.iter n guess + 1) * (sqrt.iter n guess + 1) := by unfold sqrt.iter; sorry",
  "name": "sqrt.lt_iter_succ_sq",
  "kind": "lemma",
  "first-tactic": "unfold sqrt.iter",
  "core-prompt":
  "(n guess : ℕ)  (hn : n < (guess + 1) * (guess + 1)) : n < (sqrt.iter n guess + 1) * (sqrt.iter n guess + 1)",
  "args": "(n guess : ℕ)  (hn : n < (guess + 1) * (guess + 1))"},
 {"type": "tail (map f s) = map f (tail s)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w}  (f : α → β) (s : Stream' α) : tail (map f s) = map f (tail s) := by rw [tail_eq_drop]; sorry",
  "name": "tail_map",
  "kind": "theorem",
  "first-tactic": "rw [tail_eq_drop]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w}  (f : α → β) (s : Stream' α) : tail (map f s) = map f (tail s)",
  "args":
  "{α : Type u}  {β : Type v}  {δ : Type w}  (f : α → β) (s : Stream' α)"},
 {"type": "map f s = f (head s)::map f (tail s)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w}  (f : α → β) (s : Stream' α) : map f s = f (head s)::map f (tail s) := by rw [← Stream'.eta (map f s)]; sorry",
  "name": "map_eq",
  "kind": "theorem",
  "first-tactic": "rw [← Stream'.eta (map f s)]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w}  (f : α → β) (s : Stream' α) : map f s = f (head s)::map f (tail s)",
  "args":
  "{α : Type u}  {β : Type v}  {δ : Type w}  (f : α → β) (s : Stream' α)"},
 {"type": "map f (a::s) = f a::map f s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w}  (f : α → β) (a : α)  (s : Stream' α) : map f (a::s) = f a::map f s := by rw [← Stream'.eta (map f (a::s))]; sorry",
  "name": "map_cons",
  "kind": "theorem",
  "first-tactic": "rw [← Stream'.eta (map f (a::s))]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w}  (f : α → β) (a : α)  (s : Stream' α) : map f (a::s) = f a::map f s",
  "args":
  "{α : Type u}  {β : Type v}  {δ : Type w}  (f : α → β) (a : α)  (s : Stream' α)"},
 {"type": "zip f s₁ s₂ = f (head s₁) (head s₂)::zip f (tail s₁) (tail s₂)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w}  (f : α → β → δ) (s₁ : Stream' α)  (s₂ : Stream' β) : zip f s₁ s₂ = f (head s₁) (head s₂)::zip f (tail s₁) (tail s₂) := by rw [← Stream'.eta (zip f s₁ s₂)]; sorry",
  "name": "zip_eq",
  "kind": "theorem",
  "first-tactic": "rw [← Stream'.eta (zip f s₁ s₂)]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w}  (f : α → β → δ) (s₁ : Stream' α)  (s₂ : Stream' β) : zip f s₁ s₂ = f (head s₁) (head s₂)::zip f (tail s₁) (tail s₂)",
  "args":
  "{α : Type u}  {β : Type v}  {δ : Type w}  (f : α → β → δ) (s₁ : Stream' α)  (s₂ : Stream' β)"},
 {"type": "const a = a::const a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (a : α) : const a = a::const a := by apply Stream'.ext; sorry",
  "name": "const_eq",
  "kind": "theorem",
  "first-tactic": "apply Stream'.ext",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (a : α) : const a = a::const a",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w} (a : α)"},
 {"type": "tail (iterate f a) = iterate f (f a)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (f : α → α)  (a : α) : tail (iterate f a) = iterate f (f a) := by funext n; sorry",
  "name": "tail_iterate",
  "kind": "theorem",
  "first-tactic": "funext n",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (f : α → α)  (a : α) : tail (iterate f a) = iterate f (f a)",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w} (f : α → α)  (a : α)"},
 {"type": "iterate f a = a::iterate f (f a)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (f : α → α)  (a : α) : iterate f a = a::iterate f (f a) := by rw [← Stream'.eta (iterate f a)]; sorry",
  "name": "iterate_eq",
  "kind": "theorem",
  "first-tactic": "rw [← Stream'.eta (iterate f a)]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (f : α → α)  (a : α) : iterate f a = a::iterate f (f a)",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w} (f : α → α)  (a : α)"},
 {"type": "nth (iterate f a) (succ n) = nth (iterate f (f a)) n",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (n : Nat)  (f : α → α)  (a : α) : nth (iterate f a) (succ n) = nth (iterate f (f a)) n := by rw [nth_succ]; sorry",
  "name": "nth_succ_iterate",
  "kind": "theorem",
  "first-tactic": "rw [nth_succ]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (n : Nat)  (f : α → α)  (a : α) : nth (iterate f a) (succ n) = nth (iterate f (f a)) n",
  "args":
  "{α : Type u}  {β : Type v}  {δ : Type w} (n : Nat)  (f : α → α)  (a : α)"},
 {"type": "iterate f (f a) = map f (iterate f a)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (f : α → α)  (a : α) : iterate f (f a) = map f (iterate f a) := by funext n; sorry",
  "name": "map_iterate",
  "kind": "theorem",
  "first-tactic": "funext n",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (f : α → α)  (a : α) : iterate f (f a) = map f (iterate f a)",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w} (f : α → α)  (a : α)"},
 {"type": "corec f g a = f a::corec f g (g a)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w}  (f : α → β)  (g : α → α)  (a : α) : corec f g a = f a::corec f g (g a) := by rw [corec_def]; sorry",
  "name": "corec_eq",
  "kind": "theorem",
  "first-tactic": "rw [corec_def]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w}  (f : α → β)  (g : α → α)  (a : α) : corec f g a = f a::corec f g (g a)",
  "args":
  "{α : Type u}  {β : Type v}  {δ : Type w}  (f : α → β)  (g : α → α)  (a : α)"},
 {"type": "corec id id a = const a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w}  (a : α) : corec id id a = const a := by rw [corec_def]; sorry",
  "name": "corec_id_id_eq_const",
  "kind": "theorem",
  "first-tactic": "rw [corec_def]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w}  (a : α) : corec id id a = const a",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w}  (a : α)"},
 {"type": "unfolds g f a = g a::unfolds g f (f a)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (g : α → β)  (f : α → α)  (a : α) : unfolds g f a = g a::unfolds g f (f a) := by unfold unfolds; sorry",
  "name": "unfolds_eq",
  "kind": "theorem",
  "first-tactic": "unfold unfolds",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (g : α → β)  (f : α → α)  (a : α) : unfolds g f a = g a::unfolds g f (f a)",
  "args":
  "{α : Type u}  {β : Type v}  {δ : Type w} (g : α → β)  (f : α → α)  (a : α)"},
 {"type":
  "∀ (n : Nat) (s : Stream' α),\n    nth (unfolds head tail s) n = nth s n",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} : ∀ (n : Nat) (s : Stream' α),\n    nth (unfolds head tail s) n = nth s n := by intro n; sorry",
  "name": "nth_unfolds_head_tail",
  "kind": "theorem",
  "first-tactic": "intro n",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} : ∀ (n : Nat) (s : Stream' α),\n    nth (unfolds head tail s) n = nth s n",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w}"},
 {"type": "s₁ ⋈ s₂ = head s₁::head s₂::(tail s₁ ⋈ tail s₂)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (s₁ s₂ : Stream' α) : s₁ ⋈ s₂ = head s₁::head s₂::(tail s₁ ⋈ tail s₂) := by let t := tail s₁ ⋈ tail s₂; sorry",
  "name": "interleave_eq",
  "kind": "theorem",
  "first-tactic": "let t := tail s₁ ⋈ tail s₂",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (s₁ s₂ : Stream' α) : s₁ ⋈ s₂ = head s₁::head s₂::(tail s₁ ⋈ tail s₂)",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w} (s₁ s₂ : Stream' α)"},
 {"type": "tail (s₁ ⋈ s₂) = s₂ ⋈ tail s₁",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (s₁ s₂ : Stream' α) : tail (s₁ ⋈ s₂) = s₂ ⋈ tail s₁ := by unfold interleave corecOn; sorry",
  "name": "tail_interleave",
  "kind": "theorem",
  "first-tactic": "unfold interleave corecOn",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (s₁ s₂ : Stream' α) : tail (s₁ ⋈ s₂) = s₂ ⋈ tail s₁",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w} (s₁ s₂ : Stream' α)"},
 {"type": "tail s₁ ⋈ tail s₂ = tail (tail (s₁ ⋈ s₂))",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (s₁ s₂ : Stream' α) : tail s₁ ⋈ tail s₂ = tail (tail (s₁ ⋈ s₂)) := by rw [interleave_eq s₁ s₂]; sorry",
  "name": "interleave_tail_tail",
  "kind": "theorem",
  "first-tactic": "rw [interleave_eq s₁ s₂]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (s₁ s₂ : Stream' α) : tail s₁ ⋈ tail s₂ = tail (tail (s₁ ⋈ s₂))",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w} (s₁ s₂ : Stream' α)"},
 {"type": "tail (even s) = even (tail (tail s))",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α) : tail (even s) = even (tail (tail s)) := by unfold even; sorry",
  "name": "tail_even",
  "kind": "theorem",
  "first-tactic": "unfold even",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α) : tail (even s) = even (tail (tail s))",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α)"},
 {"type": "even (a₁::a₂::s) = a₁::even s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (a₁ a₂ : α)  (s : Stream' α) : even (a₁::a₂::s) = a₁::even s := by unfold even; sorry",
  "name": "even_cons_cons",
  "kind": "theorem",
  "first-tactic": "unfold even",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (a₁ a₂ : α)  (s : Stream' α) : even (a₁::a₂::s) = a₁::even s",
  "args":
  "{α : Type u}  {β : Type v}  {δ : Type w} (a₁ a₂ : α)  (s : Stream' α)"},
 {"type": "[head s] ++ₛ tail s = s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α) : [head s] ++ₛ tail s = s := by rw [cons_append_stream]; sorry",
  "name": "append_stream_head_tail",
  "kind": "theorem",
  "first-tactic": "rw [cons_append_stream]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α) : [head s] ++ₛ tail s = s",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α)"},
 {"type": "(take n s).length = n",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (n : ℕ)  (s : Stream' α) : (take n s).length = n := by induction n generalizing s; sorry",
  "name": "length_take",
  "kind": "theorem",
  "first-tactic": "induction n generalizing s",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (n : ℕ)  (s : Stream' α) : (take n s).length = n",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w} (n : ℕ)  (s : Stream' α)"},
 {"type":
  "∀ (n : Nat) (s : Stream' α),\n    appendStream' (take n s) (drop n s) = s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} : ∀ (n : Nat) (s : Stream' α),\n    appendStream' (take n s) (drop n s) = s := by intro n; sorry",
  "name": "append_take_drop",
  "kind": "theorem",
  "first-tactic": "intro n",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} : ∀ (n : Nat) (s : Stream' α),\n    appendStream' (take n s) (drop n s) = s",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w}"},
 {"type": "(∀ n : Nat, take n s₁ = take n s₂) → s₁ = s₂",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (s₁ s₂ : Stream' α) : (∀ n : Nat, take n s₁ = take n s₂) → s₁ = s₂ := by intro h; sorry",
  "name": "take_theorem",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (s₁ s₂ : Stream' α) : (∀ n : Nat, take n s₁ = take n s₂) → s₁ = s₂",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w} (s₁ s₂ : Stream' α)"},
 {"type": "tails s = tail s::tails (tail s)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α) : tails s = tail s::tails (tail s) := by unfold tails; sorry",
  "name": "tails_eq",
  "kind": "theorem",
  "first-tactic": "unfold tails",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α) : tails s = tail s::tails (tail s)",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α)"},
 {"type": "∀ (n : Nat) (s : Stream' α), nth (tails s) n = drop n (tail s)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} : ∀ (n : Nat) (s : Stream' α), nth (tails s) n = drop n (tail s) := by intro n; sorry",
  "name": "nth_tails",
  "kind": "theorem",
  "first-tactic": "intro n",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} : ∀ (n : Nat) (s : Stream' α), nth (tails s) n = drop n (tail s)",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w}"},
 {"type": "initsCore l s = l::initsCore (l ++ [head s]) (tail s)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (l : List α)  (s : Stream' α) : initsCore l s = l::initsCore (l ++ [head s]) (tail s) := by unfold initsCore corecOn; sorry",
  "name": "inits_core_eq",
  "kind": "theorem",
  "first-tactic": "unfold initsCore corecOn",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (l : List α)  (s : Stream' α) : initsCore l s = l::initsCore (l ++ [head s]) (tail s)",
  "args":
  "{α : Type u}  {β : Type v}  {δ : Type w} (l : List α)  (s : Stream' α)"},
 {"type": "tail (inits s) = initsCore [head s, head (tail s)] (tail (tail s))",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α) : tail (inits s) = initsCore [head s, head (tail s)] (tail (tail s)) := by unfold inits; sorry",
  "name": "tail_inits",
  "kind": "theorem",
  "first-tactic": "unfold inits",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α) : tail (inits s) = initsCore [head s, head (tail s)] (tail (tail s))",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α)"},
 {"type":
  "∀ (a : α) (n : Nat) (l : List α) (s : Stream' α),\n      (a::nth (initsCore l s) n) = nth (initsCore (a::l) s) n",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} : ∀ (a : α) (n : Nat) (l : List α) (s : Stream' α),\n      (a::nth (initsCore l s) n) = nth (initsCore (a::l) s) n := by intro a n; sorry",
  "name": "cons_nth_inits_core",
  "kind": "theorem",
  "first-tactic": "intro a n",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} : ∀ (a : α) (n : Nat) (l : List α) (s : Stream' α),\n      (a::nth (initsCore l s) n) = nth (initsCore (a::l) s) n",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w}"},
 {"type": "∀ (n : Nat) (s : Stream' α), nth (inits s) n = take (succ n) s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} : ∀ (n : Nat) (s : Stream' α), nth (inits s) n = take (succ n) s := by intro n; sorry",
  "name": "nth_inits",
  "kind": "theorem",
  "first-tactic": "intro n",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} : ∀ (n : Nat) (s : Stream' α), nth (inits s) n = take (succ n) s",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w}"},
 {"type": "inits s = [head s]::map (List.cons (head s)) (inits (tail s))",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α) : inits s = [head s]::map (List.cons (head s)) (inits (tail s)) := by apply Stream'.ext; sorry",
  "name": "inits_eq",
  "kind": "theorem",
  "first-tactic": "apply Stream'.ext",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α) : inits s = [head s]::map (List.cons (head s)) (inits (tail s))",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α)"},
 {"type": "zip appendStream' (inits s) (tails s) = const s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α) : zip appendStream' (inits s) (tails s) = const s := by apply Stream'.ext; sorry",
  "name": "zip_inits_tails",
  "kind": "theorem",
  "first-tactic": "apply Stream'.ext",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α) : zip appendStream' (inits s) (tails s) = const s",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w} (s : Stream' α)"},
 {"type": "nats = cons 0 (map succ nats)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {δ : Type w} : nats = cons 0 (map succ nats) := by apply Stream'.ext; sorry",
  "name": "nats_eq",
  "kind": "theorem",
  "first-tactic": "apply Stream'.ext",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {δ : Type w} : nats = cons 0 (map succ nats)",
  "args": "{α : Type u}  {β : Type v}  {δ : Type w}"},
 {"type": "∃ lb : ℤ , P lb ∧ ∀ z : ℤ , P z → lb ≤ z",
  "tactic-prompt":
  "theorem {P : ℤ → Prop}      [DecidablePred P]      (Hbdd : ∃ b : ℤ , ∀ z : ℤ , P z → b ≤ z)      (Hinh : ∃ z : ℤ , P z) : ∃ lb : ℤ , P lb ∧ ∀ z : ℤ , P z → lb ≤ z := by let ⟨b , Hb⟩ := Hbdd; sorry",
  "name": "exists_least_of_bdd",
  "kind": "theorem",
  "first-tactic": "let ⟨b , Hb⟩ := Hbdd",
  "core-prompt":
  "{P : ℤ → Prop}      [DecidablePred P]      (Hbdd : ∃ b : ℤ , ∀ z : ℤ , P z → b ≤ z)      (Hinh : ∃ z : ℤ , P z) : ∃ lb : ℤ , P lb ∧ ∀ z : ℤ , P z → lb ≤ z",
  "args":
  "{P : ℤ → Prop}      [DecidablePred P]      (Hbdd : ∃ b : ℤ , ∀ z : ℤ , P z → b ≤ z)      (Hinh : ∃ z : ℤ , P z)"},
 {"type": "(leastOfBdd b Hb Hinh : ℤ) = leastOfBdd b' Hb' Hinh",
  "tactic-prompt":
  "theorem {P : ℤ → Prop}  [DecidablePred P]  {b b' : ℤ}  (Hb : ∀ z : ℤ, P z → b ≤ z)      (Hb' : ∀ z : ℤ, P z → b' ≤ z)  (Hinh : ∃ z : ℤ, P z) : (leastOfBdd b Hb Hinh : ℤ) = leastOfBdd b' Hb' Hinh := by rcases leastOfBdd b Hb Hinh with ⟨n, hn, h2n⟩; sorry",
  "name": "coe_leastOfBdd_eq",
  "kind": "theorem",
  "first-tactic": "rcases leastOfBdd b Hb Hinh with ⟨n, hn, h2n⟩",
  "core-prompt":
  "{P : ℤ → Prop}  [DecidablePred P]  {b b' : ℤ}  (Hb : ∀ z : ℤ, P z → b ≤ z)      (Hb' : ∀ z : ℤ, P z → b' ≤ z)  (Hinh : ∃ z : ℤ, P z) : (leastOfBdd b Hb Hinh : ℤ) = leastOfBdd b' Hb' Hinh",
  "args":
  "{P : ℤ → Prop}  [DecidablePred P]  {b b' : ℤ}  (Hb : ∀ z : ℤ, P z → b ≤ z)      (Hb' : ∀ z : ℤ, P z → b' ≤ z)  (Hinh : ∃ z : ℤ, P z)"},
 {"type": "∃ ub : ℤ , P ub ∧ ∀ z : ℤ , P z → z ≤ ub",
  "tactic-prompt":
  "theorem {P : ℤ → Prop}      [DecidablePred P]      (Hbdd : ∃ b : ℤ , ∀ z : ℤ , P z → z ≤ b)      (Hinh : ∃ z : ℤ , P z) : ∃ ub : ℤ , P ub ∧ ∀ z : ℤ , P z → z ≤ ub := by let ⟨ b , Hb ⟩ := Hbdd; sorry",
  "name": "exists_greatest_of_bdd",
  "kind": "theorem",
  "first-tactic": "let ⟨ b , Hb ⟩ := Hbdd",
  "core-prompt":
  "{P : ℤ → Prop}      [DecidablePred P]      (Hbdd : ∃ b : ℤ , ∀ z : ℤ , P z → z ≤ b)      (Hinh : ∃ z : ℤ , P z) : ∃ ub : ℤ , P ub ∧ ∀ z : ℤ , P z → z ≤ ub",
  "args":
  "{P : ℤ → Prop}      [DecidablePred P]      (Hbdd : ∃ b : ℤ , ∀ z : ℤ , P z → z ≤ b)      (Hinh : ∃ z : ℤ , P z)"},
 {"type": "(greatestOfBdd b Hb Hinh : ℤ) = greatestOfBdd b' Hb' Hinh",
  "tactic-prompt":
  "theorem {P : ℤ → Prop}  [DecidablePred P]  {b b' : ℤ}      (Hb : ∀ z : ℤ, P z → z ≤ b)  (Hb' : ∀ z : ℤ, P z → z ≤ b')  (Hinh : ∃ z : ℤ, P z) : (greatestOfBdd b Hb Hinh : ℤ) = greatestOfBdd b' Hb' Hinh := by rcases greatestOfBdd b Hb Hinh with ⟨n, hn, h2n⟩; sorry",
  "name": "coe_greatestOfBdd_eq",
  "kind": "theorem",
  "first-tactic": "rcases greatestOfBdd b Hb Hinh with ⟨n, hn, h2n⟩",
  "core-prompt":
  "{P : ℤ → Prop}  [DecidablePred P]  {b b' : ℤ}      (Hb : ∀ z : ℤ, P z → z ≤ b)  (Hb' : ∀ z : ℤ, P z → z ≤ b')  (Hinh : ∃ z : ℤ, P z) : (greatestOfBdd b Hb Hinh : ℤ) = greatestOfBdd b' Hb' Hinh",
  "args":
  "{P : ℤ → Prop}  [DecidablePred P]  {b b' : ℤ}      (Hb : ∀ z : ℤ, P z → z ≤ b)  (Hb' : ∀ z : ℤ, P z → z ≤ b')  (Hinh : ∃ z : ℤ, P z)"},
 {"type": "((m / n : ℤ) : α) = m / n",
  "tactic-prompt":
  "theorem {α : Type _} [Field α]  {m n : ℤ}  (n_dvd : n ∣ m)  (n_nonzero : (n : α) ≠ 0) : ((m / n : ℤ) : α) = m / n := by rcases n_dvd with ⟨k, rfl⟩; sorry",
  "name": "cast_div",
  "kind": "theorem",
  "first-tactic": "rcases n_dvd with ⟨k, rfl⟩",
  "core-prompt":
  "{α : Type _} [Field α]  {m n : ℤ}  (n_dvd : n ∣ m)  (n_nonzero : (n : α) ≠ 0) : ((m / n : ℤ) : α) = m / n",
  "args":
  "{α : Type _} [Field α]  {m n : ℤ}  (n_dvd : n ∣ m)  (n_nonzero : (n : α) ≠ 0)"},
 {"type": "((1 : ℤ) : R) = 1",
  "tactic-prompt":
  "theorem {R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R] : ((1 : ℤ) : R) = 1 := by erw [cast_ofNat]; sorry",
  "name": "cast_one",
  "kind": "theorem",
  "first-tactic": "erw [cast_ofNat]",
  "core-prompt":
  "{R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R] : ((1 : ℤ) : R) = 1",
  "args":
  "{R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R]"},
 {"type": "((negOfNat n : ℤ) : R) = -n",
  "tactic-prompt":
  "theorem {R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R] (n : ℕ) : ((negOfNat n : ℤ) : R) = -n := by simp [Int.cast_neg]; sorry",
  "name": "cast_negOfNat",
  "kind": "theorem",
  "first-tactic": "simp [Int.cast_neg]",
  "core-prompt":
  "{R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R] (n : ℕ) : ((negOfNat n : ℤ) : R) = -n",
  "args":
  "{R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R] (n : ℕ)"},
 {"type": "((bit1 n : ℤ) : R) = bit1 (n : R)",
  "tactic-prompt":
  "theorem {R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R]  (n : ℤ) : ((bit1 n : ℤ) : R) = bit1 (n : R) := by rw [bit1]; sorry",
  "name": "cast_bit1",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "{R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R]  (n : ℤ) : ((bit1 n : ℤ) : R) = bit1 (n : R)",
  "args":
  "{R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R]  (n : ℤ)"},
 {"type": "Monotone (fun x : ℤ => (x : α))",
  "tactic-prompt":
  "theorem {F ι α β : Type _}  [OrderedRing α] : Monotone (fun x : ℤ => (x : α)) := by intro m n h; sorry",
  "name": "cast_mono",
  "kind": "theorem",
  "first-tactic": "intro m n h",
  "core-prompt":
  "{F ι α β : Type _}  [OrderedRing α] : Monotone (fun x : ℤ => (x : α))",
  "args": "{F ι α β : Type _}  [OrderedRing α]"},
 {"type": "(m : α) ≤ n ↔ m ≤ n",
  "tactic-prompt":
  "theorem {F ι α β : Type _}  [OrderedRing α]  [Nontrivial α]  {m n : ℤ} : (m : α) ≤ n ↔ m ≤ n := by rw [← sub_nonneg]; sorry",
  "name": "cast_le",
  "kind": "theorem",
  "first-tactic": "rw [← sub_nonneg]",
  "core-prompt":
  "{F ι α β : Type _}  [OrderedRing α]  [Nontrivial α]  {m n : ℤ} : (m : α) ≤ n ↔ m ≤ n",
  "args": "{F ι α β : Type _}  [OrderedRing α]  [Nontrivial α]  {m n : ℤ}"},
 {"type": "(n : α) ≤ 0 ↔ n ≤ 0",
  "tactic-prompt":
  "theorem {F ι α β : Type _}  [OrderedRing α]  [Nontrivial α]  {n : ℤ} : (n : α) ≤ 0 ↔ n ≤ 0 := by rw [← cast_zero]; sorry",
  "name": "cast_nonpos",
  "kind": "theorem",
  "first-tactic": "rw [← cast_zero]",
  "core-prompt":
  "{F ι α β : Type _}  [OrderedRing α]  [Nontrivial α]  {n : ℤ} : (n : α) ≤ 0 ↔ n ≤ 0",
  "args": "{F ι α β : Type _}  [OrderedRing α]  [Nontrivial α]  {n : ℤ}"},
 {"type": "(0 : α) < n ↔ 0 < n",
  "tactic-prompt":
  "theorem {F ι α β : Type _}  [OrderedRing α]  [Nontrivial α]  {n : ℤ} : (0 : α) < n ↔ 0 < n := by rw [← cast_zero]; sorry",
  "name": "cast_pos",
  "kind": "theorem",
  "first-tactic": "rw [← cast_zero]",
  "core-prompt":
  "{F ι α β : Type _}  [OrderedRing α]  [Nontrivial α]  {n : ℤ} : (0 : α) < n ↔ 0 < n",
  "args": "{F ι α β : Type _}  [OrderedRing α]  [Nontrivial α]  {n : ℤ}"},
 {"type": "(n : α) < 0 ↔ n < 0",
  "tactic-prompt":
  "theorem {F ι α β : Type _}  [OrderedRing α]  [Nontrivial α]  {n : ℤ} : (n : α) < 0 ↔ n < 0 := by rw [← cast_zero]; sorry",
  "name": "cast_lt_zero",
  "kind": "theorem",
  "first-tactic": "rw [← cast_zero]",
  "core-prompt":
  "{F ι α β : Type _}  [OrderedRing α]  [Nontrivial α]  {n : ℤ} : (n : α) < 0 ↔ n < 0",
  "args": "{F ι α β : Type _}  [OrderedRing α]  [Nontrivial α]  {n : ℤ}"},
 {"type": "((|a| : ℤ) : α) = |(a : α)|",
  "tactic-prompt":
  "theorem {F ι α β : Type _}   [LinearOrderedRing α]  {a b : ℤ}  (n : ℤ) : ((|a| : ℤ) : α) = |(a : α)| := by simp [abs_eq_max_neg]; sorry",
  "name": "cast_abs",
  "kind": "theorem",
  "first-tactic": "simp [abs_eq_max_neg]",
  "core-prompt":
  "{F ι α β : Type _}   [LinearOrderedRing α]  {a b : ℤ}  (n : ℤ) : ((|a| : ℤ) : α) = |(a : α)|",
  "args": "{F ι α β : Type _}   [LinearOrderedRing α]  {a b : ℤ}  (n : ℤ)"},
 {"type": "(1 : α) ≤ a",
  "tactic-prompt":
  "theorem {F ι α β : Type _}   [LinearOrderedRing α]  {a b : ℤ}  (n : ℤ) (h : 0 < a) : (1 : α) ≤ a := by exact_mod_cast Int.add_one_le_of_lt h; sorry",
  "name": "cast_one_le_of_pos",
  "kind": "theorem",
  "first-tactic": "exact_mod_cast Int.add_one_le_of_lt h",
  "core-prompt":
  "{F ι α β : Type _}   [LinearOrderedRing α]  {a b : ℤ}  (n : ℤ) (h : 0 < a) : (1 : α) ≤ a",
  "args":
  "{F ι α β : Type _}   [LinearOrderedRing α]  {a b : ℤ}  (n : ℤ) (h : 0 < a)"},
 {"type": "(a : α) ≤ -1",
  "tactic-prompt":
  "theorem {F ι α β : Type _}   [LinearOrderedRing α]  {a b : ℤ}  (n : ℤ) (h : a < 0) : (a : α) ≤ -1 := by rw [← Int.cast_one]; sorry",
  "name": "cast_le_neg_one_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [← Int.cast_one]",
  "core-prompt":
  "{F ι α β : Type _}   [LinearOrderedRing α]  {a b : ℤ}  (n : ℤ) (h : a < 0) : (a : α) ≤ -1",
  "args":
  "{F ι α β : Type _}   [LinearOrderedRing α]  {a b : ℤ}  (n : ℤ) (h : a < 0)"},
 {"type": "(0 : α) ≤ n * x + n * n",
  "tactic-prompt":
  "theorem {F ι α β : Type _}   [LinearOrderedRing α]  {a b : ℤ}  (n : ℤ) {x : α}  (hx : |x| ≤ 1) : (0 : α) ≤ n * x + n * n := by have hnx : 0 < n → 0 ≤ x + n := fun hn => by\n    have := _root_.add_le_add (neg_le_of_abs_le hx) (cast_one_le_of_pos hn)\n    rwa [add_left_neg] at this; sorry",
  "name": "nneg_mul_add_sq_of_abs_le_one",
  "kind": "theorem",
  "first-tactic":
  "have hnx : 0 < n → 0 ≤ x + n := fun hn => by\n    have := _root_.add_le_add (neg_le_of_abs_le hx) (cast_one_le_of_pos hn)\n    rwa [add_left_neg] at this",
  "core-prompt":
  "{F ι α β : Type _}   [LinearOrderedRing α]  {a b : ℤ}  (n : ℤ) {x : α}  (hx : |x| ≤ 1) : (0 : α) ≤ n * x + n * n",
  "args":
  "{F ι α β : Type _}   [LinearOrderedRing α]  {a b : ℤ}  (n : ℤ) {x : α}  (hx : |x| ≤ 1)"},
 {"type": "(n.natAbs : α) = |n|",
  "tactic-prompt":
  "theorem {F ι α β : Type _}   [LinearOrderedRing α]  {a b : ℤ}  (n : ℤ) : (n.natAbs : α) = |n| := by cases n; sorry",
  "name": "cast_natAbs",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{F ι α β : Type _}   [LinearOrderedRing α]  {a b : ℤ}  (n : ℤ) : (n.natAbs : α) = |n|",
  "args": "{F ι α β : Type _}   [LinearOrderedRing α]  {a b : ℤ}  (n : ℤ)"},
 {"type": "f = g",
  "tactic-prompt":
  "theorem {F ι α β : Type _} {A : Type _} [AddGroupWithOne A] {M : Type _}  [Monoid M] {f g : ℤ →* M}  (h_neg_one : f (-1) = g (-1))      (h_nat : f.comp Int.ofNatHom.toMonoidHom = g.comp Int.ofNatHom.toMonoidHom) : f = g := by ext (x | x); sorry",
  "name": "ext_int",
  "kind": "theorem",
  "first-tactic": "ext (x | x)",
  "core-prompt":
  "{F ι α β : Type _} {A : Type _} [AddGroupWithOne A] {M : Type _}  [Monoid M] {f g : ℤ →* M}  (h_neg_one : f (-1) = g (-1))      (h_nat : f.comp Int.ofNatHom.toMonoidHom = g.comp Int.ofNatHom.toMonoidHom) : f = g",
  "args":
  "{F ι α β : Type _} {A : Type _} [AddGroupWithOne A] {M : Type _}  [Monoid M] {f g : ℤ →* M}  (h_neg_one : f (-1) = g (-1))      (h_nat : f.comp Int.ofNatHom.toMonoidHom = g.comp Int.ofNatHom.toMonoidHom)"},
 {"type": "a = c / b * d",
  "tactic-prompt":
  "theorem {a b c d : ℤ}  (hb : b ≠ 0)  (hbc : b ∣ c)      (h : b * a = c * d) : a = c / b * d := by cases' hbc with k hk; sorry",
  "name": "eq_mul_div_of_mul_eq_mul_of_dvd_left",
  "kind": "theorem",
  "first-tactic": "cases' hbc with k hk",
  "core-prompt":
  "{a b c d : ℤ}  (hb : b ≠ 0)  (hbc : b ∣ c)      (h : b * a = c * d) : a = c / b * d",
  "args":
  "{a b c d : ℤ}  (hb : b ≠ 0)  (hbc : b ∣ c)      (h : b * a = c * d)"},
 {"type": "b = 0",
  "tactic-prompt":
  "theorem {a b : ℤ}  (w : a ∣ b)  (h : natAbs b < natAbs a) : b = 0 := by rw [← natAbs_dvd]; sorry",
  "name": "eq_zero_of_dvd_of_natAbs_lt_natAbs",
  "kind": "theorem",
  "first-tactic": "rw [← natAbs_dvd]",
  "core-prompt": "{a b : ℤ}  (w : a ∣ b)  (h : natAbs b < natAbs a) : b = 0",
  "args": "{a b : ℤ}  (w : a ∣ b)  (h : natAbs b < natAbs a)"},
 {"type": "(↑n : ℤ) ∣ z ↔ n ∣ z.natAbs",
  "tactic-prompt":
  "theorem {n : ℕ}  {z : ℤ} : (↑n : ℤ) ∣ z ↔ n ∣ z.natAbs := by rcases natAbs_eq z with (eq | eq); sorry",
  "name": "coe_nat_dvd_left",
  "kind": "theorem",
  "first-tactic": "rcases natAbs_eq z with (eq | eq)",
  "core-prompt": "{n : ℕ}  {z : ℤ} : (↑n : ℤ) ∣ z ↔ n ∣ z.natAbs",
  "args": "{n : ℕ}  {z : ℤ}"},
 {"type": "z ∣ (↑n : ℤ) ↔ z.natAbs ∣ n",
  "tactic-prompt":
  "theorem {n : ℕ}  {z : ℤ} : z ∣ (↑n : ℤ) ↔ z.natAbs ∣ n := by rcases natAbs_eq z with (eq | eq); sorry",
  "name": "coe_nat_dvd_right",
  "kind": "theorem",
  "first-tactic": "rcases natAbs_eq z with (eq | eq)",
  "core-prompt": "{n : ℕ}  {z : ℤ} : z ∣ (↑n : ℤ) ↔ z.natAbs ∣ n",
  "args": "{n : ℕ}  {z : ℤ}"},
 {"type": "↑(p ^ m) ∣ k",
  "tactic-prompt":
  "theorem {p m n : ℕ}  {k : ℤ}  (hmn : m ≤ n)  (hdiv : ↑(p ^ n) ∣ k) : ↑(p ^ m) ∣ k := by induction k; sorry",
  "name": "pow_dvd_of_le_of_pow_dvd",
  "kind": "theorem",
  "first-tactic": "induction k",
  "core-prompt":
  "{p m n : ℕ}  {k : ℤ}  (hmn : m ≤ n)  (hdiv : ↑(p ^ n) ∣ k) : ↑(p ^ m) ∣ k",
  "args": "{p m n : ℕ}  {k : ℤ}  (hmn : m ≤ n)  (hdiv : ↑(p ^ n) ∣ k)"},
 {"type": "↑p ∣ m",
  "tactic-prompt":
  "theorem {p k : ℕ}  {m : ℤ}  (hk : 1 ≤ k)  (hpk : ↑(p ^ k) ∣ m) : ↑p ∣ m := by rw [← pow_one p]; sorry",
  "name": "dvd_of_pow_dvd",
  "kind": "theorem",
  "first-tactic": "rw [← pow_one p]",
  "core-prompt":
  "{p k : ℕ}  {m : ℤ}  (hk : 1 ≤ k)  (hpk : ↑(p ^ k) ∣ m) : ↑p ∣ m",
  "args": "{p k : ℕ}  {m : ℤ}  (hk : 1 ≤ k)  (hpk : ↑(p ^ k) ∣ m)"},
 {"type": "AddCommMonoid ℤ",
  "tactic-prompt": "instance  : AddCommMonoid ℤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : AddCommMonoid ℤ",
  "args": ""},
 {"type": "AddMonoid ℤ",
  "tactic-prompt": "instance  : AddMonoid ℤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : AddMonoid ℤ",
  "args": ""},
 {"type": "Monoid ℤ",
  "tactic-prompt": "instance  : Monoid ℤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : Monoid ℤ",
  "args": ""},
 {"type": "CommMonoid ℤ",
  "tactic-prompt": "instance  : CommMonoid ℤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : CommMonoid ℤ",
  "args": ""},
 {"type": "CommSemigroup ℤ",
  "tactic-prompt": "instance  : CommSemigroup ℤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : CommSemigroup ℤ",
  "args": ""},
 {"type": "Semigroup ℤ",
  "tactic-prompt": "instance  : Semigroup ℤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : Semigroup ℤ",
  "args": ""},
 {"type": "AddCommGroup ℤ",
  "tactic-prompt": "instance  : AddCommGroup ℤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : AddCommGroup ℤ",
  "args": ""},
 {"type": "AddGroup ℤ",
  "tactic-prompt": "instance  : AddGroup ℤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : AddGroup ℤ",
  "args": ""},
 {"type": "AddCommSemigroup ℤ",
  "tactic-prompt": "instance  : AddCommSemigroup ℤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : AddCommSemigroup ℤ",
  "args": ""},
 {"type": "AddSemigroup ℤ",
  "tactic-prompt": "instance  : AddSemigroup ℤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : AddSemigroup ℤ",
  "args": ""},
 {"type": "CommSemiring ℤ",
  "tactic-prompt": "instance  : CommSemiring ℤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : CommSemiring ℤ",
  "args": ""},
 {"type": "Semiring ℤ",
  "tactic-prompt": "instance  : Semiring ℤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : Semiring ℤ",
  "args": ""},
 {"type": "Ring ℤ",
  "tactic-prompt": "instance  : Ring ℤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : Ring ℤ",
  "args": ""},
 {"type": "Distrib ℤ",
  "tactic-prompt": "instance  : Distrib ℤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : Distrib ℤ",
  "args": ""},
 {"type": "succ (-succ a) = -a",
  "tactic-prompt":
  "theorem (a : ℤ) : succ (-succ a) = -a := by rw [neg_succ]; sorry",
  "name": "succ_neg_succ",
  "kind": "theorem",
  "first-tactic": "rw [neg_succ]",
  "core-prompt": "(a : ℤ) : succ (-succ a) = -a",
  "args": "(a : ℤ)"},
 {"type": "-pred a = succ (-a)",
  "tactic-prompt":
  "theorem (a : ℤ) : -pred a = succ (-a) := by rw [eq_neg_of_eq_neg (neg_succ (-a)).symm]; sorry",
  "name": "neg_pred",
  "kind": "theorem",
  "first-tactic": "rw [eq_neg_of_eq_neg (neg_succ (-a)).symm]",
  "core-prompt": "(a : ℤ) : -pred a = succ (-a)",
  "args": "(a : ℤ)"},
 {"type": "pred (-pred a) = -a",
  "tactic-prompt":
  "theorem (a : ℤ) : pred (-pred a) = -a := by rw [neg_pred]; sorry",
  "name": "pred_neg_pred",
  "kind": "theorem",
  "first-tactic": "rw [neg_pred]",
  "core-prompt": "(a : ℤ) : pred (-pred a) = -a",
  "args": "(a : ℤ)"},
 {"type": "((n - 1 : ℕ) : ℤ) = (n : ℤ) - 1",
  "tactic-prompt":
  "theorem {n : ℕ}  (h : 0 < n) : ((n - 1 : ℕ) : ℤ) = (n : ℤ) - 1 := by cases n; sorry",
  "name": "coe_pred_of_pos",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "{n : ℕ}  (h : 0 < n) : ((n - 1 : ℕ) : ℤ) = (n : ℤ) - 1",
  "args": "{n : ℕ}  (h : 0 < n)"},
 {"type": "p i",
  "tactic-prompt":
  "theorem {p : ℤ → Prop}  (i : ℤ)      (hz : p 0)  (hp : ∀ i : ℕ, p i → p (i + 1))  (hn : ∀ i : ℕ, p (-i) → p (-i - 1)) : p i := by induction i; sorry",
  "name": "induction_on",
  "kind": "theorem",
  "first-tactic": "induction i",
  "core-prompt":
  "{p : ℤ → Prop}  (i : ℤ)      (hz : p 0)  (hp : ∀ i : ℕ, p i → p (i + 1))  (hn : ∀ i : ℕ, p (-i) → p (-i - 1)) : p i",
  "args":
  "{p : ℤ → Prop}  (i : ℤ)      (hz : p 0)  (hp : ∀ i : ℕ, p i → p (i + 1))  (hn : ∀ i : ℕ, p (-i) → p (-i - 1))"},
 {"type": "u = 1 ∨ u = -1",
  "tactic-prompt":
  "theorem (u : ℤˣ) : u = 1 ∨ u = -1 := by simpa only [Units.ext_iff]; sorry",
  "name": "units_eq_one_or",
  "kind": "theorem",
  "first-tactic": "simpa only [Units.ext_iff]",
  "core-prompt": "(u : ℤˣ) : u = 1 ∨ u = -1",
  "args": "(u : ℤˣ)"},
 {"type": "IsUnit a ↔ a = 1 ∨ a = -1",
  "tactic-prompt":
  "theorem {a : ℤ} : IsUnit a ↔ a = 1 ∨ a = -1 := by refine' ⟨fun h ↦ is_unit_eq_one_or h, fun h ↦ _⟩; sorry",
  "name": "is_unit_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h ↦ is_unit_eq_one_or h, fun h ↦ _⟩",
  "core-prompt": "{a : ℤ} : IsUnit a ↔ a = 1 ∨ a = -1",
  "args": "{a : ℤ}"},
 {"type": "a = b ∨ a = -b",
  "tactic-prompt":
  "theorem {a b : ℤ}  (ha : IsUnit a)  (hb : IsUnit b) : a = b ∨ a = -b := by rcases is_unit_eq_one_or hb with (rfl | rfl); sorry",
  "name": "is_unit_eq_or_eq_neg",
  "kind": "theorem",
  "first-tactic": "rcases is_unit_eq_one_or hb with (rfl | rfl)",
  "core-prompt": "{a b : ℤ}  (ha : IsUnit a)  (hb : IsUnit b) : a = b ∨ a = -b",
  "args": "{a b : ℤ}  (ha : IsUnit a)  (hb : IsUnit b)"},
 {"type": "z = 1 ∧ w = 1 ∨ z = -1 ∧ w = -1",
  "tactic-prompt":
  "theorem {z w : ℤ}  (h : z * w = 1) : z = 1 ∧ w = 1 ∨ z = -1 ∧ w = -1 := by have h' : w * z = 1 := mul_comm z w ▸ h; sorry",
  "name": "eq_one_or_neg_one_of_mul_eq_one'",
  "kind": "theorem",
  "first-tactic": "have h' : w * z = 1 := mul_comm z w ▸ h",
  "core-prompt": "{z w : ℤ}  (h : z * w = 1) : z = 1 ∧ w = 1 ∨ z = -1 ∧ w = -1",
  "args": "{z w : ℤ}  (h : z * w = 1)"},
 {"type": "IsUnit n ↔ n.natAbs = 1",
  "tactic-prompt":
  "theorem {n : ℤ} : IsUnit n ↔ n.natAbs = 1 := by simp [nat_abs_eq_iff]; sorry",
  "name": "is_unit_iff_nat_abs_eq",
  "kind": "theorem",
  "first-tactic": "simp [nat_abs_eq_iff]",
  "core-prompt": "{n : ℤ} : IsUnit n ↔ n.natAbs = 1",
  "args": "{n : ℤ}"},
 {"type": "IsUnit (n : ℤ) ↔ IsUnit n",
  "tactic-prompt":
  "theorem {n : ℕ} : IsUnit (n : ℤ) ↔ IsUnit n := by rw [Nat.is_unit_iff]; sorry",
  "name": "of_nat_is_unit",
  "kind": "theorem",
  "first-tactic": "rw [Nat.is_unit_iff]",
  "core-prompt": "{n : ℕ} : IsUnit (n : ℤ) ↔ IsUnit n",
  "args": "{n : ℕ}"},
 {"type": "a + b = c + d ↔ a = c ∧ b = d ∨ a = d ∧ b = c",
  "tactic-prompt":
  "theorem {a b c d : ℤ}  (ha : IsUnit a)  (hb : IsUnit b)  (hc : IsUnit c)      (hd : IsUnit d) : a + b = c + d ↔ a = c ∧ b = d ∨ a = d ∧ b = c := by rw [is_unit_iff] at ha hb hc hd; sorry",
  "name": "is_unit_add_is_unit_eq_is_unit_add_is_unit",
  "kind": "theorem",
  "first-tactic": "rw [is_unit_iff] at ha hb hc hd",
  "core-prompt":
  "{a b c d : ℤ}  (ha : IsUnit a)  (hb : IsUnit b)  (hc : IsUnit c)      (hd : IsUnit d) : a + b = c + d ↔ a = c ∧ b = d ∨ a = d ∧ b = c",
  "args":
  "{a b c d : ℤ}  (ha : IsUnit a)  (hb : IsUnit b)  (hc : IsUnit c)      (hd : IsUnit d)"},
 {"type": "sqrt (n * n) = n.natAbs",
  "tactic-prompt":
  "theorem (n : ℤ) : sqrt (n * n) = n.natAbs := by rw [sqrt]; sorry",
  "name": "sqrt_eq",
  "kind": "theorem",
  "first-tactic": "rw [sqrt]",
  "core-prompt": "(n : ℤ) : sqrt (n * n) = n.natAbs",
  "args": "(n : ℤ)"},
 {"type": "u = 1 ∨ u = -1",
  "tactic-prompt":
  "theorem (u : ℤˣ) : u = 1 ∨ u = -1 := by simpa only [Units.ext_iff]; sorry",
  "name": "units_eq_one_or",
  "kind": "theorem",
  "first-tactic": "simpa only [Units.ext_iff]",
  "core-prompt": "(u : ℤˣ) : u = 1 ∨ u = -1",
  "args": "(u : ℤˣ)"},
 {"type": "IsUnit a ↔ a = 1 ∨ a = -1",
  "tactic-prompt":
  "theorem {a : ℤ} : IsUnit a ↔ a = 1 ∨ a = -1 := by refine' ⟨fun h => isUnit_eq_one_or h, fun h => _⟩; sorry",
  "name": "isUnit_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => isUnit_eq_one_or h, fun h => _⟩",
  "core-prompt": "{a : ℤ} : IsUnit a ↔ a = 1 ∨ a = -1",
  "args": "{a : ℤ}"},
 {"type": "a = b ∨ a = -b",
  "tactic-prompt":
  "theorem {a b : ℤ}  (ha : IsUnit a)  (hb : IsUnit b) : a = b ∨ a = -b := by rcases isUnit_eq_one_or hb with (rfl | rfl); sorry",
  "name": "isUnit_eq_or_eq_neg",
  "kind": "theorem",
  "first-tactic": "rcases isUnit_eq_one_or hb with (rfl | rfl)",
  "core-prompt": "{a b : ℤ}  (ha : IsUnit a)  (hb : IsUnit b) : a = b ∨ a = -b",
  "args": "{a b : ℤ}  (ha : IsUnit a)  (hb : IsUnit b)"},
 {"type": "z = 1 ∧ w = 1 ∨ z = -1 ∧ w = -1",
  "tactic-prompt":
  "theorem {z w : ℤ}  (h : z * w = 1) : z = 1 ∧ w = 1 ∨ z = -1 ∧ w = -1 := by have h' : w * z = 1 := mul_comm z w ▸ h; sorry",
  "name": "eq_one_or_neg_one_of_mul_eq_one'",
  "kind": "theorem",
  "first-tactic": "have h' : w * z = 1 := mul_comm z w ▸ h",
  "core-prompt": "{z w : ℤ}  (h : z * w = 1) : z = 1 ∧ w = 1 ∨ z = -1 ∧ w = -1",
  "args": "{z w : ℤ}  (h : z * w = 1)"},
 {"type": "z * w = 1 ↔ z = 1 ∧ w = 1 ∨ z = -1 ∧ w = -1",
  "tactic-prompt":
  "theorem {z w : ℤ} : z * w = 1 ↔ z = 1 ∧ w = 1 ∨ z = -1 ∧ w = -1 := by refine' ⟨eq_one_or_neg_one_of_mul_eq_one', fun h => Or.elim h (fun H => _) fun H => _⟩; sorry",
  "name": "mul_eq_one_iff_eq_one_or_neg_one",
  "kind": "theorem",
  "first-tactic":
  "refine' ⟨eq_one_or_neg_one_of_mul_eq_one', fun h => Or.elim h (fun H => _) fun H => _⟩",
  "core-prompt": "{z w : ℤ} : z * w = 1 ↔ z = 1 ∧ w = 1 ∨ z = -1 ∧ w = -1",
  "args": "{z w : ℤ}"},
 {"type": "z = 1 ∧ w = -1 ∨ z = -1 ∧ w = 1",
  "tactic-prompt":
  "theorem {z w : ℤ}  (h : z * w = -1) : z = 1 ∧ w = -1 ∨ z = -1 ∧ w = 1 := by rcases isUnit_eq_one_or (IsUnit.mul_iff.mp (Int.isUnit_iff.mpr (Or.inr h))).1 with (rfl | rfl); sorry",
  "name": "eq_one_or_neg_one_of_mul_eq_neg_one'",
  "kind": "theorem",
  "first-tactic":
  "rcases isUnit_eq_one_or (IsUnit.mul_iff.mp (Int.isUnit_iff.mpr (Or.inr h))).1 with (rfl | rfl)",
  "core-prompt":
  "{z w : ℤ}  (h : z * w = -1) : z = 1 ∧ w = -1 ∨ z = -1 ∧ w = 1",
  "args": "{z w : ℤ}  (h : z * w = -1)"},
 {"type": "z * w = -1 ↔ z = 1 ∧ w = -1 ∨ z = -1 ∧ w = 1",
  "tactic-prompt":
  "theorem {z w : ℤ} : z * w = -1 ↔ z = 1 ∧ w = -1 ∨ z = -1 ∧ w = 1 := by refine' ⟨eq_one_or_neg_one_of_mul_eq_neg_one', fun h => Or.elim h (fun H => _) fun H => _⟩; sorry",
  "name": "mul_eq_neg_one_iff_eq_one_or_neg_one",
  "kind": "theorem",
  "first-tactic":
  "refine' ⟨eq_one_or_neg_one_of_mul_eq_neg_one', fun h => Or.elim h (fun H => _) fun H => _⟩",
  "core-prompt": "{z w : ℤ} : z * w = -1 ↔ z = 1 ∧ w = -1 ∨ z = -1 ∧ w = 1",
  "args": "{z w : ℤ}"},
 {"type": "IsUnit n ↔ n.natAbs = 1",
  "tactic-prompt":
  "theorem {n : ℤ} : IsUnit n ↔ n.natAbs = 1 := by simp [natAbs_eq_iff]; sorry",
  "name": "isUnit_iff_natAbs_eq",
  "kind": "theorem",
  "first-tactic": "simp [natAbs_eq_iff]",
  "core-prompt": "{n : ℤ} : IsUnit n ↔ n.natAbs = 1",
  "args": "{n : ℤ}"},
 {"type": "IsUnit (n : ℤ) ↔ IsUnit n",
  "tactic-prompt":
  "theorem {n : ℕ} : IsUnit (n : ℤ) ↔ IsUnit n := by simp [isUnit_iff_natAbs_eq]; sorry",
  "name": "ofNat_isUnit",
  "kind": "theorem",
  "first-tactic": "simp [isUnit_iff_natAbs_eq]",
  "core-prompt": "{n : ℕ} : IsUnit (n : ℤ) ↔ IsUnit n",
  "args": "{n : ℕ}"},
 {"type": "a + b = c + d ↔ a = c ∧ b = d ∨ a = d ∧ b = c",
  "tactic-prompt":
  "theorem {a b c d : ℤ}  (ha : IsUnit a)  (hb : IsUnit b)      (hc : IsUnit c)  (hd : IsUnit d) : a + b = c + d ↔ a = c ∧ b = d ∨ a = d ∧ b = c := by rw [isUnit_iff] at ha hb hc hd; sorry",
  "name": "isUnit_add_isUnit_eq_isUnit_add_isUnit",
  "kind": "theorem",
  "first-tactic": "rw [isUnit_iff] at ha hb hc hd",
  "core-prompt":
  "{a b c d : ℤ}  (ha : IsUnit a)  (hb : IsUnit b)      (hc : IsUnit c)  (hd : IsUnit d) : a + b = c + d ↔ a = c ∧ b = d ∨ a = d ∧ b = c",
  "args":
  "{a b c d : ℤ}  (ha : IsUnit a)  (hb : IsUnit b)      (hc : IsUnit c)  (hd : IsUnit d)"},
 {"type": "LinearOrderedAddCommGroup ℤ",
  "tactic-prompt":
  "instance  : LinearOrderedAddCommGroup ℤ := by infer_instance; sorry",
  "name": "linearOrderedAddCommGroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : LinearOrderedAddCommGroup ℤ",
  "args": ""},
 {"type": "natAbs (|a|) = natAbs a",
  "tactic-prompt":
  "theorem (a : ℤ) : natAbs (|a|) = natAbs a := by rw [abs_eq_natAbs]; sorry",
  "name": "natAbs_abs",
  "kind": "theorem",
  "first-tactic": "rw [abs_eq_natAbs]",
  "core-prompt": "(a : ℤ) : natAbs (|a|) = natAbs a",
  "args": "(a : ℤ)"},
 {"type": "sign a * |a| = a",
  "tactic-prompt":
  "theorem (a : ℤ) : sign a * |a| = a := by rw [abs_eq_natAbs]; sorry",
  "name": "sign_mul_abs",
  "kind": "theorem",
  "first-tactic": "rw [abs_eq_natAbs]",
  "core-prompt": "(a : ℤ) : sign a * |a| = a",
  "args": "(a : ℤ)"},
 {"type": "(n : ℤ) ≠ 0 ↔ n ≠ 0",
  "tactic-prompt": "theorem {n : ℕ} : (n : ℤ) ≠ 0 ↔ n ≠ 0 := by simp; sorry",
  "name": "coe_nat_ne_zero",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "{n : ℕ} : (n : ℤ) ≠ 0 ↔ n ≠ 0",
  "args": "{n : ℕ}"},
 {"type": "|a| ≤ 1 ↔ a = 0 ∨ a = 1 ∨ a = -1",
  "tactic-prompt":
  "theorem {a : ℤ} : |a| ≤ 1 ↔ a = 0 ∨ a = 1 ∨ a = -1 := by rw [le_iff_lt_or_eq]; sorry",
  "name": "abs_le_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [le_iff_lt_or_eq]",
  "core-prompt": "{a : ℤ} : |a| ≤ 1 ↔ a = 0 ∨ a = 1 ∨ a = -1",
  "args": "{a : ℤ}"},
 {"type": "C z",
  "tactic-prompt":
  "def {C : ℤ → Sort _}      (z : ℤ)  (b : ℤ)  (H0 : C b)  (Hs : ∀ k, b ≤ k → C k → C (k + 1))      (Hp : ∀ k ≤ b, C k → C (k - 1)) : C z := by rw [← sub_add_cancel (G := ℤ) z b]; sorry",
  "name": "inductionOn'",
  "kind": "def",
  "first-tactic": "rw [← sub_add_cancel (G := ℤ) z b]",
  "core-prompt":
  "{C : ℤ → Sort _}      (z : ℤ)  (b : ℤ)  (H0 : C b)  (Hs : ∀ k, b ≤ k → C k → C (k + 1))      (Hp : ∀ k ≤ b, C k → C (k - 1)) : C z",
  "args":
  "{C : ℤ → Sort _}      (z : ℤ)  (b : ℤ)  (H0 : C b)  (Hs : ∀ k, b ≤ k → C k → C (k + 1))      (Hp : ∀ k ≤ b, C k → C (k - 1))"},
 {"type": "m ≤ n → P n",
  "tactic-prompt":
  "theorem {P : ℤ → Prop}  {m : ℤ}  (h0 : P m)      (h1 : ∀ n : ℤ, m ≤ n → P n → P (n + 1))  (n : ℤ) : m ≤ n → P n := by refine Int.inductionOn' n m ?_ ?_ ?_; sorry",
  "name": "le_induction",
  "kind": "theorem",
  "first-tactic": "refine Int.inductionOn' n m ?_ ?_ ?_",
  "core-prompt":
  "{P : ℤ → Prop}  {m : ℤ}  (h0 : P m)      (h1 : ∀ n : ℤ, m ≤ n → P n → P (n + 1))  (n : ℤ) : m ≤ n → P n",
  "args":
  "{P : ℤ → Prop}  {m : ℤ}  (h0 : P m)      (h1 : ∀ n : ℤ, m ≤ n → P n → P (n + 1))  (n : ℤ)"},
 {"type": "n ≤ m → P n",
  "tactic-prompt":
  "theorem {P : ℤ → Prop}  {m : ℤ}  (h0 : P m)      (h1 : ∀ n : ℤ, n ≤ m → P n → P (n - 1))  (n : ℤ) : n ≤ m → P n := by refine Int.inductionOn' n m ?_ ?_ ?_; sorry",
  "name": "le_induction_down",
  "kind": "theorem",
  "first-tactic": "refine Int.inductionOn' n m ?_ ?_ ?_",
  "core-prompt":
  "{P : ℤ → Prop}  {m : ℤ}  (h0 : P m)      (h1 : ∀ n : ℤ, n ≤ m → P n → P (n - 1))  (n : ℤ) : n ≤ m → P n",
  "args":
  "{P : ℤ → Prop}  {m : ℤ}  (h0 : P m)      (h1 : ∀ n : ℤ, n ≤ m → P n → P (n - 1))  (n : ℤ)"},
 {"type": "a % b < |b|",
  "tactic-prompt":
  "theorem {a b : ℤ}  {n : ℕ} (a : ℤ)  {b : ℤ}  (H : b ≠ 0) : a % b < |b| := by rw [← emod_abs]; sorry",
  "name": "emod_lt",
  "kind": "theorem",
  "first-tactic": "rw [← emod_abs]",
  "core-prompt":
  "{a b : ℤ}  {n : ℕ} (a : ℤ)  {b : ℤ}  (H : b ≠ 0) : a % b < |b|",
  "args": "{a b : ℤ}  {n : ℕ} (a : ℤ)  {b : ℤ}  (H : b ≠ 0)"},
 {"type": "(m + i) % n = (k + i) % n",
  "tactic-prompt":
  "theorem {a b : ℤ}  {n : ℕ} {m n k : ℤ}  (i : ℤ)  (H : m % n = k % n) : (m + i) % n = (k + i) % n := by rw [← emod_add_emod]; sorry",
  "name": "add_emod_eq_add_mod_right",
  "kind": "theorem",
  "first-tactic": "rw [← emod_add_emod]",
  "core-prompt":
  "{a b : ℤ}  {n : ℕ} {m n k : ℤ}  (i : ℤ)  (H : m % n = k % n) : (m + i) % n = (k + i) % n",
  "args": "{a b : ℤ}  {n : ℕ} {m n k : ℤ}  (i : ℤ)  (H : m % n = k % n)"},
 {"type": "-i % 2 = i % 2",
  "tactic-prompt":
  "theorem {a b : ℤ}  {n : ℕ} (i : ℤ) : -i % 2 = i % 2 := by apply Int.emod_eq_emod_iff_emod_sub_eq_zero.mpr; sorry",
  "name": "neg_emod_two",
  "kind": "theorem",
  "first-tactic": "apply Int.emod_eq_emod_iff_emod_sub_eq_zero.mpr",
  "core-prompt": "{a b : ℤ}  {n : ℕ} (i : ℤ) : -i % 2 = i % 2",
  "args": "{a b : ℤ}  {n : ℕ} (i : ℤ)"},
 {"type": "|z.sign| = 1",
  "tactic-prompt":
  "theorem {a b : ℤ}  {n : ℕ} {z : ℤ}  (hz : z ≠ 0) : |z.sign| = 1 := by rw [abs_eq_natAbs]; sorry",
  "name": "abs_sign_of_nonzero",
  "kind": "theorem",
  "first-tactic": "rw [abs_eq_natAbs]",
  "core-prompt": "{a b : ℤ}  {n : ℕ} {z : ℤ}  (hz : z ≠ 0) : |z.sign| = 1",
  "args": "{a b : ℤ}  {n : ℕ} {z : ℤ}  (hz : z ≠ 0)"},
 {"type": "(∃ k, n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m",
  "tactic-prompt":
  "theorem {a b : ℤ}  {n : ℕ} (m : ℤ)  {n : ℤ}  (hn : 0 < n) : (∃ k, n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m := by constructor; sorry",
  "name": "exists_lt_and_lt_iff_not_dvd",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{a b : ℤ}  {n : ℕ} (m : ℤ)  {n : ℤ}  (hn : 0 < n) : (∃ k, n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m",
  "args": "{a b : ℤ}  {n : ℕ} (m : ℤ)  {n : ℤ}  (hn : 0 < n)"},
 {"type": "a ≤ c * b",
  "tactic-prompt":
  "theorem {a b : ℤ}  {n : ℕ} {a b c : ℤ}  (H1 : 0 ≤ b)  (H2 : b ∣ a)  (H3 : a / b ≤ c) : a ≤ c * b := by rw [← Int.ediv_mul_cancel H2]; sorry",
  "name": "le_mul_of_ediv_le",
  "kind": "theorem",
  "first-tactic": "rw [← Int.ediv_mul_cancel H2]",
  "core-prompt":
  "{a b : ℤ}  {n : ℕ} {a b c : ℤ}  (H1 : 0 ≤ b)  (H2 : b ∣ a)  (H3 : a / b ≤ c) : a ≤ c * b",
  "args":
  "{a b : ℤ}  {n : ℕ} {a b c : ℤ}  (H1 : 0 ≤ b)  (H2 : b ∣ a)  (H3 : a / b ≤ c)"},
 {"type": "t / s ∣ t",
  "tactic-prompt":
  "theorem {a b : ℤ}  {n : ℕ} {s t : ℤ}  (hst : s ∣ t) : t / s ∣ t := by rcases eq_or_ne s 0 with (rfl | hs); sorry",
  "name": "ediv_dvd_of_dvd",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne s 0 with (rfl | hs)",
  "core-prompt": "{a b : ℤ}  {n : ℕ} {s t : ℤ}  (hst : s ∣ t) : t / s ∣ t",
  "args": "{a b : ℤ}  {n : ℕ} {s t : ℤ}  (hst : s ∣ t)"},
 {"type": "toNat a ≤ n ↔ a ≤ n",
  "tactic-prompt":
  "theorem {a b : ℤ}  {n : ℕ} {a : ℤ}  {n : ℕ} : toNat a ≤ n ↔ a ≤ n := by rw [ofNat_le.symm]; sorry",
  "name": "toNat_le",
  "kind": "theorem",
  "first-tactic": "rw [ofNat_le.symm]",
  "core-prompt": "{a b : ℤ}  {n : ℕ} {a : ℤ}  {n : ℕ} : toNat a ≤ n ↔ a ≤ n",
  "args": "{a b : ℤ}  {n : ℕ} {a : ℤ}  {n : ℕ}"},
 {"type": "toNat a ≤ toNat b",
  "tactic-prompt":
  "theorem {a b : ℤ}  {n : ℕ} {a b : ℤ}  (h : a ≤ b) : toNat a ≤ toNat b := by rw [toNat_le]; sorry",
  "name": "toNat_le_toNat",
  "kind": "theorem",
  "first-tactic": "rw [toNat_le]",
  "core-prompt":
  "{a b : ℤ}  {n : ℕ} {a b : ℤ}  (h : a ≤ b) : toNat a ≤ toNat b",
  "args": "{a b : ℤ}  {n : ℕ} {a b : ℤ}  (h : a ≤ b)"},
 {"type": "((i.toNat - 1 : ℕ) : ℤ) = i - 1",
  "tactic-prompt":
  "theorem {a b : ℤ}  {n : ℕ} {i : ℤ}  (h : 0 < i) : ((i.toNat - 1 : ℕ) : ℤ) = i - 1 := by simp [h]; sorry",
  "name": "toNat_pred_coe_of_pos",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{a b : ℤ}  {n : ℕ} {i : ℤ}  (h : 0 < i) : ((i.toNat - 1 : ℕ) : ℤ) = i - 1",
  "args": "{a b : ℤ}  {n : ℕ} {i : ℤ}  (h : 0 < i)"},
 {"type": "IsUnit x ↔ abs x = 1",
  "tactic-prompt":
  "theorem {x : ℤ} : IsUnit x ↔ abs x = 1 := by rw [isUnit_iff_natAbs_eq]; sorry",
  "name": "isUnit_iff_abs_eq",
  "kind": "theorem",
  "first-tactic": "rw [isUnit_iff_natAbs_eq]",
  "core-prompt": "{x : ℤ} : IsUnit x ↔ abs x = 1",
  "args": "{x : ℤ}"},
 {"type": "a ^ 2 = 1",
  "tactic-prompt":
  "theorem {a : ℤ}  (ha : IsUnit a) : a ^ 2 = 1 := by rw [sq]; sorry",
  "name": "isUnit_sq",
  "kind": "theorem",
  "first-tactic": "rw [sq]",
  "core-prompt": "{a : ℤ}  (ha : IsUnit a) : a ^ 2 = 1",
  "args": "{a : ℤ}  (ha : IsUnit a)"},
 {"type": "u ^ 2 = 1",
  "tactic-prompt":
  "theorem (u : ℤˣ) : u ^ 2 = 1 := by rw [Units.ext_iff]; sorry",
  "name": "units_sq",
  "kind": "theorem",
  "first-tactic": "rw [Units.ext_iff]",
  "core-prompt": "(u : ℤˣ) : u ^ 2 = 1",
  "args": "(u : ℤˣ)"},
 {"type": "u * u = 1",
  "tactic-prompt": "theorem (u : ℤˣ) : u * u = 1 := by rw [← sq]; sorry",
  "name": "units_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [← sq]",
  "core-prompt": "(u : ℤˣ) : u * u = 1",
  "args": "(u : ℤˣ)"},
 {"type": "u⁻¹ = u",
  "tactic-prompt":
  "theorem (u : ℤˣ) : u⁻¹ = u := by rw [inv_eq_iff_mul_eq_one]; sorry",
  "name": "units_inv_eq_self",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_iff_mul_eq_one]",
  "core-prompt": "(u : ℤˣ) : u⁻¹ = u",
  "args": "(u : ℤˣ)"},
 {"type": "(u * u : ℤ) = 1",
  "tactic-prompt":
  "theorem (u : ℤˣ) : (u * u : ℤ) = 1 := by rw [← Units.val_mul]; sorry",
  "name": "units_coe_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [← Units.val_mul]",
  "core-prompt": "(u : ℤˣ) : (u * u : ℤ) = 1",
  "args": "(u : ℤˣ)"},
 {"type": "u ^ n = u ^ (n % 2)",
  "tactic-prompt":
  "theorem (u : ℤˣ)  (n : ℕ) : u ^ n = u ^ (n % 2) := by conv =>\n      lhs\n      rw [← Nat.mod_add_div n 2];\n      rw [pow_add]; sorry",
  "name": "units_pow_eq_pow_mod_two",
  "kind": "theorem",
  "first-tactic":
  "conv =>\n      lhs\n      rw [← Nat.mod_add_div n 2];\n      rw [pow_add]",
  "core-prompt": "(u : ℤˣ)  (n : ℕ) : u ^ n = u ^ (n % 2)",
  "args": "(u : ℤˣ)  (n : ℕ)"},
 {"type": "a.natAbs = b.natAbs ↔ a * a = b * b",
  "tactic-prompt":
  "theorem {a b : ℤ}  {n : ℕ} {a b : ℤ} : a.natAbs = b.natAbs ↔ a * a = b * b := by rw [← abs_eq_iff_mul_self_eq]; sorry",
  "name": "natAbs_eq_iff_mul_self_eq",
  "kind": "theorem",
  "first-tactic": "rw [← abs_eq_iff_mul_self_eq]",
  "core-prompt":
  "{a b : ℤ}  {n : ℕ} {a b : ℤ} : a.natAbs = b.natAbs ↔ a * a = b * b",
  "args": "{a b : ℤ}  {n : ℕ} {a b : ℤ}"},
 {"type": "a.natAbs < b.natAbs ↔ a * a < b * b",
  "tactic-prompt":
  "theorem {a b : ℤ}  {n : ℕ} {a b : ℤ} : a.natAbs < b.natAbs ↔ a * a < b * b := by rw [← abs_lt_iff_mul_self_lt]; sorry",
  "name": "natAbs_lt_iff_mul_self_lt",
  "kind": "theorem",
  "first-tactic": "rw [← abs_lt_iff_mul_self_lt]",
  "core-prompt":
  "{a b : ℤ}  {n : ℕ} {a b : ℤ} : a.natAbs < b.natAbs ↔ a * a < b * b",
  "args": "{a b : ℤ}  {n : ℕ} {a b : ℤ}"},
 {"type": "a.natAbs ≤ b.natAbs ↔ a * a ≤ b * b",
  "tactic-prompt":
  "theorem {a b : ℤ}  {n : ℕ} {a b : ℤ} : a.natAbs ≤ b.natAbs ↔ a * a ≤ b * b := by rw [← abs_le_iff_mul_self_le]; sorry",
  "name": "natAbs_le_iff_mul_self_le",
  "kind": "theorem",
  "first-tactic": "rw [← abs_le_iff_mul_self_le]",
  "core-prompt":
  "{a b : ℤ}  {n : ℕ} {a b : ℤ} : a.natAbs ≤ b.natAbs ↔ a * a ≤ b * b",
  "args": "{a b : ℤ}  {n : ℕ} {a b : ℤ}"},
 {"type": "b ∣ c / a",
  "tactic-prompt":
  "theorem {a b : ℤ}  {n : ℕ} {a b c : ℤ}  (h : a * b ∣ c) : b ∣ c / a := by rcases eq_or_ne a 0 with (rfl | ha); sorry",
  "name": "dvd_div_of_mul_dvd",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne a 0 with (rfl | ha)",
  "core-prompt": "{a b : ℤ}  {n : ℕ} {a b c : ℤ}  (h : a * b ∣ c) : b ∣ c / a",
  "args": "{a b : ℤ}  {n : ℕ} {a b c : ℤ}  (h : a * b ∣ c)"},
 {"type": "x = 0",
  "tactic-prompt":
  "theorem {a b : ℤ}  {n : ℕ} {m x : ℤ}  (h1 : m ∣ x)  (h2 : |x| < m) : x = 0 := by by_cases hm : m = 0; sorry",
  "name": "eq_zero_of_abs_lt_dvd",
  "kind": "theorem",
  "first-tactic": "by_cases hm : m = 0",
  "core-prompt":
  "{a b : ℤ}  {n : ℕ} {m x : ℤ}  (h1 : m ∣ x)  (h2 : |x| < m) : x = 0",
  "args": "{a b : ℤ}  {n : ℕ} {m x : ℤ}  (h1 : m ∣ x)  (h2 : |x| < m)"},
 {"type": "gcdA 0 s = 0",
  "tactic-prompt": "theorem {s : ℕ} : gcdA 0 s = 0 := by unfold gcdA; sorry",
  "name": "gcdA_zero_left",
  "kind": "theorem",
  "first-tactic": "unfold gcdA",
  "core-prompt": "{s : ℕ} : gcdA 0 s = 0",
  "args": "{s : ℕ}"},
 {"type": "gcdB 0 s = 1",
  "tactic-prompt": "theorem {s : ℕ} : gcdB 0 s = 1 := by unfold gcdB; sorry",
  "name": "gcdB_zero_left",
  "kind": "theorem",
  "first-tactic": "unfold gcdB",
  "core-prompt": "{s : ℕ} : gcdB 0 s = 1",
  "args": "{s : ℕ}"},
 {"type": "gcdA s 0 = 1",
  "tactic-prompt":
  "theorem {s : ℕ}  (h : s ≠ 0) : gcdA s 0 = 1 := by unfold gcdA xgcd; sorry",
  "name": "gcdA_zero_right",
  "kind": "theorem",
  "first-tactic": "unfold gcdA xgcd",
  "core-prompt": "{s : ℕ}  (h : s ≠ 0) : gcdA s 0 = 1",
  "args": "{s : ℕ}  (h : s ≠ 0)"},
 {"type": "gcdB s 0 = 0",
  "tactic-prompt":
  "theorem {s : ℕ}  (h : s ≠ 0) : gcdB s 0 = 0 := by unfold gcdB xgcd; sorry",
  "name": "gcdB_zero_right",
  "kind": "theorem",
  "first-tactic": "unfold gcdB xgcd",
  "core-prompt": "{s : ℕ}  (h : s ≠ 0) : gcdB s 0 = 0",
  "args": "{s : ℕ}  (h : s ≠ 0)"},
 {"type": "(gcd x y : ℤ) = x * gcdA x y + y * gcdB x y",
  "tactic-prompt":
  "theorem (x y : ℕ) : (gcd x y : ℤ) = x * gcdA x y + y * gcdB x y := by have := @xgcd_aux_P x y x y 1 0 0 1 (by simp [P]) (by simp [P]); sorry",
  "name": "gcd_eq_gcd_ab",
  "kind": "theorem",
  "first-tactic":
  "have := @xgcd_aux_P x y x y 1 0 0 1 (by simp [P]) (by simp [P])",
  "core-prompt": "(x y : ℕ) : (gcd x y : ℤ) = x * gcdA x y + y * gcdB x y",
  "args": "(x y : ℕ)"},
 {"type": "∃ m, n * m % k = gcd n k",
  "tactic-prompt":
  "theorem {k n : ℕ}  (hk : gcd n k < k) : ∃ m, n * m % k = gcd n k := by have hk' := Int.ofNat_ne_zero.2 (ne_of_gt (lt_of_le_of_lt (zero_le (gcd n k)) hk)); sorry",
  "name": "exists_mul_emod_eq_gcd",
  "kind": "theorem",
  "first-tactic":
  "have hk' := Int.ofNat_ne_zero.2 (ne_of_gt (lt_of_le_of_lt (zero_le (gcd n k)) hk))",
  "core-prompt": "{k n : ℕ}  (hk : gcd n k < k) : ∃ m, n * m % k = gcd n k",
  "args": "{k n : ℕ}  (hk : gcd n k < k)"},
 {"type": "natAbs (a / b) = natAbs a / natAbs b",
  "tactic-prompt":
  "theorem (a b : ℤ)  (H : b ∣ a) : natAbs (a / b) = natAbs a / natAbs b := by rcases Nat.eq_zero_or_pos (natAbs b) with (h | h); sorry",
  "name": "natAbs_ediv",
  "kind": "theorem",
  "first-tactic": "rcases Nat.eq_zero_or_pos (natAbs b) with (h | h)",
  "core-prompt":
  "(a b : ℤ)  (H : b ∣ a) : natAbs (a / b) = natAbs a / natAbs b",
  "args": "(a b : ℤ)  (H : b ∣ a)"},
 {"type": "i ∣ j",
  "tactic-prompt":
  "theorem {i j k : ℤ}  (k_non_zero : k ≠ 0)  (H : i * k ∣ j * k) : i ∣ j := by rw [mul_comm i k]; sorry",
  "name": "dvd_of_mul_dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm i k]",
  "core-prompt":
  "{i j k : ℤ}  (k_non_zero : k ≠ 0)  (H : i * k ∣ j * k) : i ∣ j",
  "args": "{i j k : ℤ}  (k_non_zero : k ≠ 0)  (H : i * k ∣ j * k)"},
 {"type": "gcd i j * lcm i j = natAbs (i * j)",
  "tactic-prompt":
  "theorem (i j : ℤ) : gcd i j * lcm i j = natAbs (i * j) := by rw [Int.gcd]; sorry",
  "name": "gcd_mul_lcm",
  "kind": "theorem",
  "first-tactic": "rw [Int.gcd]",
  "core-prompt": "(i j : ℤ) : gcd i j * lcm i j = natAbs (i * j)",
  "args": "(i j : ℤ)"},
 {"type": "gcd i i = natAbs i",
  "tactic-prompt":
  "theorem (i : ℤ) : gcd i i = natAbs i := by simp [gcd]; sorry",
  "name": "gcd_self",
  "kind": "theorem",
  "first-tactic": "simp [gcd]",
  "core-prompt": "(i : ℤ) : gcd i i = natAbs i",
  "args": "(i : ℤ)"},
 {"type": "gcd 0 i = natAbs i",
  "tactic-prompt":
  "theorem (i : ℤ) : gcd 0 i = natAbs i := by simp [gcd]; sorry",
  "name": "gcd_zero_left",
  "kind": "theorem",
  "first-tactic": "simp [gcd]",
  "core-prompt": "(i : ℤ) : gcd 0 i = natAbs i",
  "args": "(i : ℤ)"},
 {"type": "gcd i 0 = natAbs i",
  "tactic-prompt":
  "theorem (i : ℤ) : gcd i 0 = natAbs i := by simp [gcd]; sorry",
  "name": "gcd_zero_right",
  "kind": "theorem",
  "first-tactic": "simp [gcd]",
  "core-prompt": "(i : ℤ) : gcd i 0 = natAbs i",
  "args": "(i : ℤ)"},
 {"type": "gcd x (-y) = gcd x y",
  "tactic-prompt":
  "theorem {x y : ℤ} : gcd x (-y) = gcd x y := by rw [Int.gcd]; sorry",
  "name": "gcd_neg_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.gcd]",
  "core-prompt": "{x y : ℤ} : gcd x (-y) = gcd x y",
  "args": "{x y : ℤ}"},
 {"type": "gcd (-x) y = gcd x y",
  "tactic-prompt":
  "theorem {x y : ℤ} : gcd (-x) y = gcd x y := by rw [Int.gcd]; sorry",
  "name": "gcd_neg_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.gcd]",
  "core-prompt": "{x y : ℤ} : gcd (-x) y = gcd x y",
  "args": "{x y : ℤ}"},
 {"type": "gcd (i * j) (i * k) = natAbs i * gcd j k",
  "tactic-prompt":
  "theorem (i j k : ℤ) : gcd (i * j) (i * k) = natAbs i * gcd j k := by rw [Int.gcd]; sorry",
  "name": "gcd_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.gcd]",
  "core-prompt": "(i j k : ℤ) : gcd (i * j) (i * k) = natAbs i * gcd j k",
  "args": "(i j k : ℤ)"},
 {"type": "gcd (i * j) (k * j) = gcd i k * natAbs j",
  "tactic-prompt":
  "theorem (i j k : ℤ) : gcd (i * j) (k * j) = gcd i k * natAbs j := by rw [Int.gcd]; sorry",
  "name": "gcd_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.gcd]",
  "core-prompt": "(i j k : ℤ) : gcd (i * j) (k * j) = gcd i k * natAbs j",
  "args": "(i j k : ℤ)"},
 {"type": "gcd i j = 0 ↔ i = 0 ∧ j = 0",
  "tactic-prompt":
  "theorem {i j : ℤ} : gcd i j = 0 ↔ i = 0 ∧ j = 0 := by rw [Int.gcd]; sorry",
  "name": "gcd_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "rw [Int.gcd]",
  "core-prompt": "{i j : ℤ} : gcd i j = 0 ↔ i = 0 ∧ j = 0",
  "args": "{i j : ℤ}"},
 {"type": "gcd (i / k) (j / k) = gcd i j / natAbs k",
  "tactic-prompt":
  "theorem {i j k : ℤ}  (H1 : k ∣ i)  (H2 : k ∣ j) : gcd (i / k) (j / k) = gcd i j / natAbs k := by rw [gcd]; sorry",
  "name": "gcd_div",
  "kind": "theorem",
  "first-tactic": "rw [gcd]",
  "core-prompt":
  "{i j k : ℤ}  (H1 : k ∣ i)  (H2 : k ∣ j) : gcd (i / k) (j / k) = gcd i j / natAbs k",
  "args": "{i j k : ℤ}  (H1 : k ∣ i)  (H2 : k ∣ j)"},
 {"type": "gcd (i / gcd i j) (j / gcd i j) = 1",
  "tactic-prompt":
  "theorem {i j : ℤ}  (H : 0 < gcd i j) : gcd (i / gcd i j) (j / gcd i j) = 1 := by rw [gcd_div (gcd_dvd_left i j) (gcd_dvd_right i j)]; sorry",
  "name": "gcd_div_gcd_div_gcd",
  "kind": "theorem",
  "first-tactic": "rw [gcd_div (gcd_dvd_left i j) (gcd_dvd_right i j)]",
  "core-prompt":
  "{i j : ℤ}  (H : 0 < gcd i j) : gcd (i / gcd i j) (j / gcd i j) = 1",
  "args": "{i j : ℤ}  (H : 0 < gcd i j)"},
 {"type": "gcd i j = natAbs j",
  "tactic-prompt":
  "theorem {i j : ℤ}  (H : j ∣ i) : gcd i j = natAbs j := by rw [gcd_comm]; sorry",
  "name": "gcd_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "{i j : ℤ}  (H : j ∣ i) : gcd i j = natAbs j",
  "args": "{i j : ℤ}  (H : j ∣ i)"},
 {"type": "x ≠ 0 ∨ y ≠ 0",
  "tactic-prompt":
  "theorem {x y : ℤ}  (hc : gcd x y ≠ 0) : x ≠ 0 ∨ y ≠ 0 := by contrapose! hc; sorry",
  "name": "ne_zero_of_gcd",
  "kind": "theorem",
  "first-tactic": "contrapose! hc",
  "core-prompt": "{x y : ℤ}  (hc : gcd x y ≠ 0) : x ≠ 0 ∨ y ≠ 0",
  "args": "{x y : ℤ}  (hc : gcd x y ≠ 0)"},
 {"type": "m ^ k ∣ n ^ k ↔ m ∣ n",
  "tactic-prompt":
  "theorem {m n : ℤ}  {k : ℕ}  (k0 : 0 < k) : m ^ k ∣ n ^ k ↔ m ∣ n := by refine' ⟨fun h => _, fun h => pow_dvd_pow_of_dvd h _⟩; sorry",
  "name": "pow_dvd_pow_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, fun h => pow_dvd_pow_of_dvd h _⟩",
  "core-prompt": "{m n : ℤ}  {k : ℕ}  (k0 : 0 < k) : m ^ k ∣ n ^ k ↔ m ∣ n",
  "args": "{m n : ℤ}  {k : ℕ}  (k0 : 0 < k)"},
 {"type": "gcd a b ∣ n ↔ ∃ x y : ℤ, ↑n = a * x + b * y",
  "tactic-prompt":
  "theorem {a b : ℤ}  {n : ℕ} : gcd a b ∣ n ↔ ∃ x y : ℤ, ↑n = a * x + b * y := by constructor; sorry",
  "name": "gcd_dvd_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{a b : ℤ}  {n : ℕ} : gcd a b ∣ n ↔ ∃ x y : ℤ, ↑n = a * x + b * y",
  "args": "{a b : ℤ}  {n : ℕ}"},
 {"type": "a ∣ b",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (habc : a ∣ b * c)  (hab : gcd a c = 1) : a ∣ b := by have := gcd_eq_gcd_ab a c; sorry",
  "name": "dvd_of_dvd_mul_left_of_gcd_one",
  "kind": "theorem",
  "first-tactic": "have := gcd_eq_gcd_ab a c",
  "core-prompt": "{a b c : ℤ}  (habc : a ∣ b * c)  (hab : gcd a c = 1) : a ∣ b",
  "args": "{a b c : ℤ}  (habc : a ∣ b * c)  (hab : gcd a c = 1)"},
 {"type": "a ∣ c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (habc : a ∣ b * c)  (hab : gcd a b = 1) : a ∣ c := by rw [mul_comm] at habc; sorry",
  "name": "dvd_of_dvd_mul_right_of_gcd_one",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm] at habc",
  "core-prompt": "{a b c : ℤ}  (habc : a ∣ b * c)  (hab : gcd a b = 1) : a ∣ c",
  "args": "{a b c : ℤ}  (habc : a ∣ b * c)  (hab : gcd a b = 1)"},
 {"type": "IsLeast { n : ℕ | 0 < n ∧ ∃ x y : ℤ, ↑n = a * x + b * y } (a.gcd b)",
  "tactic-prompt":
  "theorem {a b : ℤ}  (ha : a ≠ 0) : IsLeast { n : ℕ | 0 < n ∧ ∃ x y : ℤ, ↑n = a * x + b * y } (a.gcd b) := by simp_rw [← gcd_dvd_iff]; sorry",
  "name": "gcd_least_linear",
  "kind": "theorem",
  "first-tactic": "simp_rw [← gcd_dvd_iff]",
  "core-prompt":
  "{a b : ℤ}  (ha : a ≠ 0) : IsLeast { n : ℕ | 0 < n ∧ ∃ x y : ℤ, ↑n = a * x + b * y } (a.gcd b)",
  "args": "{a b : ℤ}  (ha : a ≠ 0)"},
 {"type": "lcm i j = lcm j i",
  "tactic-prompt":
  "theorem (i j : ℤ) : lcm i j = lcm j i := by rw [Int.lcm]; sorry",
  "name": "lcm_comm",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i j : ℤ) : lcm i j = lcm j i",
  "args": "(i j : ℤ)"},
 {"type": "lcm (lcm i j) k = lcm i (lcm j k)",
  "tactic-prompt":
  "theorem (i j k : ℤ) : lcm (lcm i j) k = lcm i (lcm j k) := by rw [Int.lcm]; sorry",
  "name": "lcm_assoc",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i j k : ℤ) : lcm (lcm i j) k = lcm i (lcm j k)",
  "args": "(i j k : ℤ)"},
 {"type": "lcm 0 i = 0",
  "tactic-prompt": "theorem (i : ℤ) : lcm 0 i = 0 := by rw [Int.lcm]; sorry",
  "name": "lcm_zero_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i : ℤ) : lcm 0 i = 0",
  "args": "(i : ℤ)"},
 {"type": "lcm i 0 = 0",
  "tactic-prompt": "theorem (i : ℤ) : lcm i 0 = 0 := by rw [Int.lcm]; sorry",
  "name": "lcm_zero_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i : ℤ) : lcm i 0 = 0",
  "args": "(i : ℤ)"},
 {"type": "lcm 1 i = natAbs i",
  "tactic-prompt":
  "theorem (i : ℤ) : lcm 1 i = natAbs i := by rw [Int.lcm]; sorry",
  "name": "lcm_one_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i : ℤ) : lcm 1 i = natAbs i",
  "args": "(i : ℤ)"},
 {"type": "lcm i 1 = natAbs i",
  "tactic-prompt":
  "theorem (i : ℤ) : lcm i 1 = natAbs i := by rw [Int.lcm]; sorry",
  "name": "lcm_one_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i : ℤ) : lcm i 1 = natAbs i",
  "args": "(i : ℤ)"},
 {"type": "lcm i i = natAbs i",
  "tactic-prompt":
  "theorem (i : ℤ) : lcm i i = natAbs i := by rw [Int.lcm]; sorry",
  "name": "lcm_self",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i : ℤ) : lcm i i = natAbs i",
  "args": "(i : ℤ)"},
 {"type": "i ∣ lcm i j",
  "tactic-prompt": "theorem (i j : ℤ) : i ∣ lcm i j := by rw [Int.lcm]; sorry",
  "name": "dvd_lcm_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i j : ℤ) : i ∣ lcm i j",
  "args": "(i j : ℤ)"},
 {"type": "j ∣ lcm i j",
  "tactic-prompt": "theorem (i j : ℤ) : j ∣ lcm i j := by rw [Int.lcm]; sorry",
  "name": "dvd_lcm_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i j : ℤ) : j ∣ lcm i j",
  "args": "(i j : ℤ)"},
 {"type": "i ∣ k → j ∣ k → (lcm i j : ℤ) ∣ k",
  "tactic-prompt":
  "theorem {i j k : ℤ} : i ∣ k → j ∣ k → (lcm i j : ℤ) ∣ k := by rw [Int.lcm]; sorry",
  "name": "lcm_dvd",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "{i j k : ℤ} : i ∣ k → j ∣ k → (lcm i j : ℤ) ∣ k",
  "args": "{i j k : ℤ}"},
 {"type": "x ^ m.gcd n = 1",
  "tactic-prompt":
  "theorem {M : Type _}  [Monoid M]  (x : M)  {m n : ℕ}  (hm : x ^ m = 1)  (hn : x ^ n = 1) : x ^ m.gcd n = 1 := by rcases m with (rfl | m); sorry",
  "name": "pow_gcd_eq_one",
  "kind": "theorem",
  "first-tactic": "rcases m with (rfl | m)",
  "core-prompt":
  "{M : Type _}  [Monoid M]  (x : M)  {m n : ℕ}  (hm : x ^ m = 1)  (hn : x ^ n = 1) : x ^ m.gcd n = 1",
  "args":
  "{M : Type _}  [Monoid M]  (x : M)  {m n : ℕ}  (hm : x ^ m = 1)  (hn : x ^ n = 1)"},
 {"type": "m.gcd n • x = 0",
  "tactic-prompt":
  "theorem {M : Type _}  [AddMonoid M]  (x : M)  {m n : ℕ}  (hm : m • x = 0)      (hn : n • x = 0) : m.gcd n • x = 0 := by apply Multiplicative.ofAdd.injective; sorry",
  "name": "gcd_nsmul_eq_zero",
  "kind": "theorem",
  "first-tactic": "apply Multiplicative.ofAdd.injective",
  "core-prompt":
  "{M : Type _}  [AddMonoid M]  (x : M)  {m n : ℕ}  (hm : m • x = 0)      (hn : n • x = 0) : m.gcd n • x = 0",
  "args":
  "{M : Type _}  [AddMonoid M]  (x : M)  {m n : ℕ}  (hm : m • x = 0)      (hn : n • x = 0)"},
 {"type": "(m : α) = n ↔ m = n",
  "tactic-prompt":
  "theorem {α : Type _} [AddGroupWithOne α]  [CharZero α]  {m n : ℤ} : (m : α) = n ↔ m = n := by rw [← sub_eq_zero]; sorry",
  "name": "cast_inj",
  "kind": "theorem",
  "first-tactic": "rw [← sub_eq_zero]",
  "core-prompt":
  "{α : Type _} [AddGroupWithOne α]  [CharZero α]  {m n : ℤ} : (m : α) = n ↔ m = n",
  "args": "{α : Type _} [AddGroupWithOne α]  [CharZero α]  {m n : ℤ}"},
 {"type": "((m / n : ℤ) : k) = m / n",
  "tactic-prompt":
  "theorem {α : Type _} {k : Type _}  [Field k]  [CharZero k]  {m n : ℤ}  (n_dvd : n ∣ m) : ((m / n : ℤ) : k) = m / n := by rcases eq_or_ne n 0 with (rfl | hn); sorry",
  "name": "cast_div_charZero",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne n 0 with (rfl | hn)",
  "core-prompt":
  "{α : Type _} {k : Type _}  [Field k]  [CharZero k]  {m n : ℤ}  (n_dvd : n ∣ m) : ((m / n : ℤ) : k) = m / n",
  "args":
  "{α : Type _} {k : Type _}  [Field k]  [CharZero k]  {m n : ℤ}  (n_dvd : n ∣ m)"},
 {"type": "f.symm.symm = f",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β) : f.symm.symm = f := by cases f; sorry",
  "name": "symm_symm",
  "kind": "theorem",
  "first-tactic": "cases f",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β) : f.symm.symm = f",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β)"},
 {"type": "f.trans g a = none ↔ ∀ b c, b ∉ f a ∨ c ∉ g b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β)  (g : β ≃. γ)  (a : α) : f.trans g a = none ↔ ∀ b c, b ∉ f a ∨ c ∉ g b := by simp only [eq_none_iff_forall_not_mem]; sorry",
  "name": "trans_eq_none",
  "kind": "theorem",
  "first-tactic": "simp only [eq_none_iff_forall_not_mem]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β)  (g : β ≃. γ)  (a : α) : f.trans g a = none ↔ ∀ b c, b ∉ f a ∨ c ∉ g b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β)  (g : β ≃. γ)  (a : α)"},
 {"type": "(PEquiv.refl α).trans f = f",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β) : (PEquiv.refl α).trans f = f := by ext; sorry",
  "name": "refl_trans",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β) : (PEquiv.refl α).trans f = f",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β)"},
 {"type": "f.trans (PEquiv.refl β) = f",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β) : f.trans (PEquiv.refl β) = f := by ext; sorry",
  "name": "trans_refl",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β) : f.trans (PEquiv.refl β) = f",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β)"},
 {"type": "a₁ = a₂",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β)  {a₁ a₂ : α}  {b : β}  (h₁ : b ∈ f a₁)  (h₂ : b ∈ f a₂) : a₁ = a₂ := by rw [← mem_iff_mem] at *; sorry",
  "name": "inj",
  "kind": "theorem",
  "first-tactic": "rw [← mem_iff_mem] at *",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β)  {a₁ a₂ : α}  {b : β}  (h₁ : b ∈ f a₁)  (h₂ : b ∈ f a₂) : a₁ = a₂",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β)  {a₁ a₂ : α}  {b : β}  (h₁ : b ∈ f a₁)  (h₂ : b ∈ f a₂)"},
 {"type": "a ∈ ofSet s a ↔ a ∈ s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  (s : Set α)  [DecidablePred (· ∈ s)] {s : Set α}  [DecidablePred (· ∈ s)]  {a : α} : a ∈ ofSet s a ↔ a ∈ s := by dsimp [ofSet]; sorry",
  "name": "mem_ofSet_self_iff",
  "kind": "theorem",
  "first-tactic": "dsimp [ofSet]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  (s : Set α)  [DecidablePred (· ∈ s)] {s : Set α}  [DecidablePred (· ∈ s)]  {a : α} : a ∈ ofSet s a ↔ a ∈ s",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  (s : Set α)  [DecidablePred (· ∈ s)] {s : Set α}  [DecidablePred (· ∈ s)]  {a : α}"},
 {"type": "a ∈ ofSet s b ↔ a = b ∧ a ∈ s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  (s : Set α)  [DecidablePred (· ∈ s)] {s : Set α}  [DecidablePred (· ∈ s)]  {a b : α} : a ∈ ofSet s b ↔ a = b ∧ a ∈ s := by dsimp [ofSet]; sorry",
  "name": "mem_ofSet_iff",
  "kind": "theorem",
  "first-tactic": "dsimp [ofSet]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  (s : Set α)  [DecidablePred (· ∈ s)] {s : Set α}  [DecidablePred (· ∈ s)]  {a b : α} : a ∈ ofSet s b ↔ a = b ∧ a ∈ s",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  (s : Set α)  [DecidablePred (· ∈ s)] {s : Set α}  [DecidablePred (· ∈ s)]  {a b : α}"},
 {"type": "f.trans f.symm = ofSet { a | (f a).isSome }",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β) : f.trans f.symm = ofSet { a | (f a).isSome } := by ext; sorry",
  "name": "self_trans_symm",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β) : f.trans f.symm = ofSet { a | (f a).isSome }",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β)"},
 {"type": "f.trans f.symm = PEquiv.refl α ↔ ∀ a, isSome (f a)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} {f : α ≃. β} : f.trans f.symm = PEquiv.refl α ↔ ∀ a, isSome (f a) := by rw [self_trans_symm]; sorry",
  "name": "trans_symm_eq_iff_forall_is_some",
  "kind": "theorem",
  "first-tactic": "rw [self_trans_symm]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} {f : α ≃. β} : f.trans f.symm = PEquiv.refl α ↔ ∀ a, isSome (f a)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} {f : α ≃. β}"},
 {"type": "f.trans (⊥ : β ≃. γ) = ⊥",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β) : f.trans (⊥ : β ≃. γ) = ⊥ := by ext; sorry",
  "name": "trans_bot",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β) : f.trans (⊥ : β ≃. γ) = ⊥",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : α ≃. β)"},
 {"type": "(⊥ : α ≃. β).trans f = ⊥",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : β ≃. γ) : (⊥ : α ≃. β).trans f = ⊥ := by ext; sorry",
  "name": "bot_trans",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : β ≃. γ) : (⊥ : α ≃. β).trans f = ⊥",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x} (f : β ≃. γ)"},
 {"type": "b₁ ∈ single a₂ b₂ a₁ ↔ a₁ = a₂ ∧ b₁ = b₂",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  [DecidableEq α]  [DecidableEq β]  [DecidableEq γ] (a₁ a₂ : α)  (b₁ b₂ : β) : b₁ ∈ single a₂ b₂ a₁ ↔ a₁ = a₂ ∧ b₁ = b₂ := by dsimp [single]; sorry",
  "name": "mem_single_iff",
  "kind": "theorem",
  "first-tactic": "dsimp [single]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  [DecidableEq α]  [DecidableEq β]  [DecidableEq γ] (a₁ a₂ : α)  (b₁ b₂ : β) : b₁ ∈ single a₂ b₂ a₁ ↔ a₁ = a₂ ∧ b₁ = b₂",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  [DecidableEq α]  [DecidableEq β]  [DecidableEq γ] (a₁ a₂ : α)  (b₁ b₂ : β)"},
 {"type": "(single a b).trans f = single a c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  [DecidableEq α]  [DecidableEq β]  [DecidableEq γ] (a : α)  {b : β}  {c : γ}  {f : β ≃. γ}  (h : c ∈ f b) : (single a b).trans f = single a c := by ext; sorry",
  "name": "single_trans_of_mem",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  [DecidableEq α]  [DecidableEq β]  [DecidableEq γ] (a : α)  {b : β}  {c : γ}  {f : β ≃. γ}  (h : c ∈ f b) : (single a b).trans f = single a c",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  [DecidableEq α]  [DecidableEq β]  [DecidableEq γ] (a : α)  {b : β}  {c : γ}  {f : β ≃. γ}  (h : c ∈ f b)"},
 {"type": "single a b = PEquiv.refl α",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  [DecidableEq α]  [DecidableEq β]  [DecidableEq γ] [Subsingleton α]  (a b : α) : single a b = PEquiv.refl α := by ext (i j); sorry",
  "name": "single_subsingleton_eq_refl",
  "kind": "theorem",
  "first-tactic": "ext (i j)",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  [DecidableEq α]  [DecidableEq β]  [DecidableEq γ] [Subsingleton α]  (a b : α) : single a b = PEquiv.refl α",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  [DecidableEq α]  [DecidableEq β]  [DecidableEq γ] [Subsingleton α]  (a b : α)"},
 {"type": "f.trans (single b c) = ⊥",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  [DecidableEq α]  [DecidableEq β]  [DecidableEq γ] {b : β}  (c : γ)  {f : δ ≃. β}  (h : f.symm b = none) : f.trans (single b c) = ⊥ := by ext; sorry",
  "name": "trans_single_of_eq_none",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  [DecidableEq α]  [DecidableEq β]  [DecidableEq γ] {b : β}  (c : γ)  {f : δ ≃. β}  (h : f.symm b = none) : f.trans (single b c) = ⊥",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type x}  [DecidableEq α]  [DecidableEq β]  [DecidableEq γ] {b : β}  (c : γ)  {f : δ ≃. β}  (h : f.symm b = none)"},
 {"type": "x₀ = x₁",
  "tactic-prompt":
  "theorem {α α₁ α₂ : Type _}  {β : α → Type _}  {β₁ : α₁ → Type _}  {β₂ : α₂ → Type _} {x₀ x₁ : Sigma β}  (h₀ : x₀.1 = x₁.1)  (h₁ : HEq x₀.2 x₁.2) : x₀ = x₁ := by cases x₀; sorry",
  "name": "ext",
  "kind": "theorem",
  "first-tactic": "cases x₀",
  "core-prompt":
  "{α α₁ α₂ : Type _}  {β : α → Type _}  {β₁ : α₁ → Type _}  {β₂ : α₂ → Type _} {x₀ x₁ : Sigma β}  (h₀ : x₀.1 = x₁.1)  (h₁ : HEq x₀.2 x₁.2) : x₀ = x₁",
  "args":
  "{α α₁ α₂ : Type _}  {β : α → Type _}  {β₁ : α₁ → Type _}  {β₂ : α₂ → Type _} {x₀ x₁ : Sigma β}  (h₀ : x₀.1 = x₁.1)  (h₁ : HEq x₀.2 x₁.2)"},
 {"type": "x₀ = x₁ ↔ x₀.1 = x₁.1 ∧ HEq x₀.2 x₁.2",
  "tactic-prompt":
  "theorem {α α₁ α₂ : Type _}  {β : α → Type _}  {β₁ : α₁ → Type _}  {β₂ : α₂ → Type _} {x₀ x₁ : Sigma β} : x₀ = x₁ ↔ x₀.1 = x₁.1 ∧ HEq x₀.2 x₁.2 := by cases x₀; sorry",
  "name": "ext_iff",
  "kind": "theorem",
  "first-tactic": "cases x₀",
  "core-prompt":
  "{α α₁ α₂ : Type _}  {β : α → Type _}  {β₁ : α₁ → Type _}  {β₂ : α₂ → Type _} {x₀ x₁ : Sigma β} : x₀ = x₁ ↔ x₀.1 = x₁.1 ∧ HEq x₀.2 x₁.2",
  "args":
  "{α α₁ α₂ : Type _}  {β : α → Type _}  {β₁ : α₁ → Type _}  {β₂ : α₂ → Type _} {x₀ x₁ : Sigma β}"},
 {"type": "Function.Surjective (Sigma.map f₁ f₂)",
  "tactic-prompt":
  "theorem {f₁ : α₁ → α₂}  {f₂ : ∀ a, β₁ a → β₂ (f₁ a)}    (h₁ : Function.Surjective f₁)  (h₂ : ∀ a, Function.Surjective (f₂ a)) : Function.Surjective (Sigma.map f₁ f₂) := by simp only [Function.Surjective]; sorry",
  "name": "Function.Surjective.sigma_map",
  "kind": "theorem",
  "first-tactic": "simp only [Function.Surjective]",
  "core-prompt":
  "{f₁ : α₁ → α₂}  {f₂ : ∀ a, β₁ a → β₂ (f₁ a)}    (h₁ : Function.Surjective f₁)  (h₂ : ∀ a, Function.Surjective (f₂ a)) : Function.Surjective (Sigma.map f₁ f₂)",
  "args":
  "{f₁ : α₁ → α₂}  {f₂ : ∀ a, β₁ a → β₂ (f₁ a)}    (h₁ : Function.Surjective f₁)  (h₂ : ∀ a, Function.Surjective (f₂ a))"},
 {"type": "x₀ = x₁",
  "tactic-prompt":
  "theorem {α : Sort _}  {β : α → Sort _} {x₀ x₁ : PSigma β}  (h₀ : x₀.1 = x₁.1)  (h₁ : HEq x₀.2 x₁.2) : x₀ = x₁ := by cases x₀; sorry",
  "name": "ext",
  "kind": "theorem",
  "first-tactic": "cases x₀",
  "core-prompt":
  "{α : Sort _}  {β : α → Sort _} {x₀ x₁ : PSigma β}  (h₀ : x₀.1 = x₁.1)  (h₁ : HEq x₀.2 x₁.2) : x₀ = x₁",
  "args":
  "{α : Sort _}  {β : α → Sort _} {x₀ x₁ : PSigma β}  (h₀ : x₀.1 = x₁.1)  (h₁ : HEq x₀.2 x₁.2)"},
 {"type": "x₀ = x₁ ↔ x₀.1 = x₁.1 ∧ HEq x₀.2 x₁.2",
  "tactic-prompt":
  "theorem {α : Sort _}  {β : α → Sort _} {x₀ x₁ : PSigma β} : x₀ = x₁ ↔ x₀.1 = x₁.1 ∧ HEq x₀.2 x₁.2 := by cases x₀; sorry",
  "name": "ext_iff",
  "kind": "theorem",
  "first-tactic": "cases x₀",
  "core-prompt":
  "{α : Sort _}  {β : α → Sort _} {x₀ x₁ : PSigma β} : x₀ = x₁ ↔ x₀.1 = x₁.1 ∧ HEq x₀.2 x₁.2",
  "args": "{α : Sort _}  {β : α → Sort _} {x₀ x₁ : PSigma β}"},
 {"type": "Lex r s a b ↔ r a.1 b.1 ∨ ∃ h : a.1 = b.1, s b.1 (h.rec a.2) b.2",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : ι → Type _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop}    {a b : Σ i, α i} : Lex r s a b ↔ r a.1 b.1 ∨ ∃ h : a.1 = b.1, s b.1 (h.rec a.2) b.2 := by constructor; sorry",
  "name": "lex_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{ι : Type _}  {α : ι → Type _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop}    {a b : Σ i, α i} : Lex r s a b ↔ r a.1 b.1 ∨ ∃ h : a.1 = b.1, s b.1 (h.rec a.2) b.2",
  "args":
  "{ι : Type _}  {α : ι → Type _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop}    {a b : Σ i, α i}"},
 {"type": "Lex r₂ s₂ a b",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : ι → Type _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop}    {a b : Σ i, α i} (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ i a b, s₁ i a b → s₂ i a b)  {a b : Σ i, α i}      (h : Lex r₁ s₁ a b) : Lex r₂ s₂ a b := by obtain ⟨a, b, hij⟩ | ⟨a, b, hab⟩ := h; sorry",
  "name": "Lex.mono",
  "kind": "theorem",
  "first-tactic": "obtain ⟨a, b, hij⟩ | ⟨a, b, hab⟩ := h",
  "core-prompt":
  "{ι : Type _}  {α : ι → Type _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop}    {a b : Σ i, α i} (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ i a b, s₁ i a b → s₂ i a b)  {a b : Σ i, α i}      (h : Lex r₁ s₁ a b) : Lex r₂ s₂ a b",
  "args":
  "{ι : Type _}  {α : ι → Type _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop}    {a b : Σ i, α i} (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ i a b, s₁ i a b → s₂ i a b)  {a b : Σ i, α i}      (h : Lex r₁ s₁ a b)"},
 {"type":
  "Lex (Function.swap r) s a b ↔ Lex r (fun i => Function.swap (s i)) b a",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : ι → Type _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop}    {a b : Σ i, α i} : Lex (Function.swap r) s a b ↔ Lex r (fun i => Function.swap (s i)) b a := by constructor; sorry",
  "name": "lex_swap",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{ι : Type _}  {α : ι → Type _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop}    {a b : Σ i, α i} : Lex (Function.swap r) s a b ↔ Lex r (fun i => Function.swap (s i)) b a",
  "args":
  "{ι : Type _}  {α : ι → Type _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop}    {a b : Σ i, α i}"},
 {"type": "Lex r s a b ↔ r a.1 b.1 ∨ ∃ h : a.1 = b.1, s b.1 (h.rec a.2) b.2",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : ι → Type _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop}    {a b : Σ i, α i} {ι : Sort _}  {α : ι → Sort _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop} {a b : Σ' i, α i} : Lex r s a b ↔ r a.1 b.1 ∨ ∃ h : a.1 = b.1, s b.1 (h.rec a.2) b.2 := by constructor; sorry",
  "name": "lex_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{ι : Type _}  {α : ι → Type _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop}    {a b : Σ i, α i} {ι : Sort _}  {α : ι → Sort _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop} {a b : Σ' i, α i} : Lex r s a b ↔ r a.1 b.1 ∨ ∃ h : a.1 = b.1, s b.1 (h.rec a.2) b.2",
  "args":
  "{ι : Type _}  {α : ι → Type _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop}    {a b : Σ i, α i} {ι : Sort _}  {α : ι → Sort _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop} {a b : Σ' i, α i}"},
 {"type": "Lex r₂ s₂ a b",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : ι → Type _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop}    {a b : Σ i, α i} {ι : Sort _}  {α : ι → Sort _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop} {r₁ r₂ : ι → ι → Prop}  {s₁ s₂ : ∀ i, α i → α i → Prop}    (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ i a b, s₁ i a b → s₂ i a b)  {a b : Σ' i, α i}      (h : Lex r₁ s₁ a b) : Lex r₂ s₂ a b := by obtain ⟨a, b, hij⟩ | ⟨i, hab⟩ := h; sorry",
  "name": "Lex.mono",
  "kind": "theorem",
  "first-tactic": "obtain ⟨a, b, hij⟩ | ⟨i, hab⟩ := h",
  "core-prompt":
  "{ι : Type _}  {α : ι → Type _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop}    {a b : Σ i, α i} {ι : Sort _}  {α : ι → Sort _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop} {r₁ r₂ : ι → ι → Prop}  {s₁ s₂ : ∀ i, α i → α i → Prop}    (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ i a b, s₁ i a b → s₂ i a b)  {a b : Σ' i, α i}      (h : Lex r₁ s₁ a b) : Lex r₂ s₂ a b",
  "args":
  "{ι : Type _}  {α : ι → Type _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop}    {a b : Σ i, α i} {ι : Sort _}  {α : ι → Sort _}  {r r₁ r₂ : ι → ι → Prop}  {s s₁ s₂ : ∀ i, α i → α i → Prop} {r₁ r₂ : ι → ι → Prop}  {s₁ s₂ : ∀ i, α i → α i → Prop}    (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ i a b, s₁ i a b → s₂ i a b)  {a b : Σ' i, α i}      (h : Lex r₁ s₁ a b)"},
 {"type": "a ≤ b ↔ ∃ h : a.1 = b.1, h.rec a.2 ≤ b.2",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : ι → Type _} [∀ i, LE (α i)]  {a b : Σi, α i} : a ≤ b ↔ ∃ h : a.1 = b.1, h.rec a.2 ≤ b.2 := by constructor; sorry",
  "name": "le_def",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{ι : Type _}  {α : ι → Type _} [∀ i, LE (α i)]  {a b : Σi, α i} : a ≤ b ↔ ∃ h : a.1 = b.1, h.rec a.2 ≤ b.2",
  "args": "{ι : Type _}  {α : ι → Type _} [∀ i, LE (α i)]  {a b : Σi, α i}"},
 {"type": "a < b ↔ ∃ h : a.1 = b.1, h.rec a.2 < b.2",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : ι → Type _} [∀ i, LT (α i)]  {a b : Σi, α i} : a < b ↔ ∃ h : a.1 = b.1, h.rec a.2 < b.2 := by constructor; sorry",
  "name": "lt_def",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{ι : Type _}  {α : ι → Type _} [∀ i, LT (α i)]  {a b : Σi, α i} : a < b ↔ ∃ h : a.1 = b.1, h.rec a.2 < b.2",
  "args": "{ι : Type _}  {α : ι → Type _} [∀ i, LT (α i)]  {a b : Σi, α i}"},
 {"type": "some x ≠ none",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} (x : α) : some x ≠ none := by intro h; sorry",
  "name": "some_ne_none",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} (x : α) : some x ≠ none",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _} (x : α)"},
 {"type": "o ≠ none ↔ ∃ x, o = some x",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {o : Part α} : o ≠ none ↔ ∃ x, o = some x := by constructor; sorry",
  "name": "ne_none_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {o : Part α} : o ≠ none ↔ ∃ x, o = some x",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _} {o : Part α}"},
 {"type": "a.get ha = b.get (h ▸ ha)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} (a : Part α)  (ha : a.Dom)  {b : Part α}  (h : a = b) : a.get ha = b.get (h ▸ ha) := by congr; sorry",
  "name": "get_eq_get_of_eq",
  "kind": "theorem",
  "first-tactic": "congr",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} (a : Part α)  (ha : a.Dom)  {b : Part α}  (h : a = b) : a.get ha = b.get (h ▸ ha)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} (a : Part α)  (ha : a.Dom)  {b : Part α}  (h : a = b)"},
 {"type": "a ∈ toOption o ↔ a ∈ o",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {o : Part α}  [Decidable o.Dom]  {a : α} : a ∈ toOption o ↔ a ∈ o := by unfold toOption; sorry",
  "name": "mem_toOption",
  "kind": "theorem",
  "first-tactic": "unfold toOption",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {o : Part α}  [Decidable o.Dom]  {a : α} : a ∈ toOption o ↔ a ∈ o",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {o : Part α}  [Decidable o.Dom]  {a : α}"},
 {"type": "toOption o = Option.some a ↔ a ∈ o",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {o : Part α}  [Decidable o.Dom]  {a : α} : toOption o = Option.some a ↔ a ∈ o := by rw [← Option.mem_def]; sorry",
  "name": "toOption_eq_some_iff",
  "kind": "theorem",
  "first-tactic": "rw [← Option.mem_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {o : Part α}  [Decidable o.Dom]  {a : α} : toOption o = Option.some a ↔ a ∈ o",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {o : Part α}  [Decidable o.Dom]  {a : α}"},
 {"type": "a.toOption.elim b f = if h : a.Dom then f (a.get h) else b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {α β : Type _}  (a : Part α)  [Decidable a.Dom]  (b : β)  (f : α → β) : a.toOption.elim b f = if h : a.Dom then f (a.get h) else b := by split_ifs with h; sorry",
  "name": "elim_toOption",
  "kind": "theorem",
  "first-tactic": "split_ifs with h",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {α β : Type _}  (a : Part α)  [Decidable a.Dom]  (b : β)  (f : α → β) : a.toOption.elim b f = if h : a.Dom then f (a.get h) else b",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {α β : Type _}  (a : Part α)  [Decidable a.Dom]  (b : β)  (f : α → β)"},
 {"type": "toOption (ofOption o) = o",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} (o : Option α) : toOption (ofOption o) = o := by cases o; sorry",
  "name": "to_ofOption",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} (o : Option α) : toOption (ofOption o) = o",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _} (o : Option α)"},
 {"type": "x ≤ y ∨ y ≤ x",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {x y : Part α}  (z : Part α)  (hx : x ≤ z)  (hy : y ≤ z) : x ≤ y ∨ y ≤ x := by rcases Part.eq_none_or_eq_some x with (h | ⟨b, h₀⟩); sorry",
  "name": "le_total_of_le_of_le",
  "kind": "theorem",
  "first-tactic": "rcases Part.eq_none_or_eq_some x with (h | ⟨b, h₀⟩)",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {x y : Part α}  (z : Part α)  (hx : x ≤ z)  (hy : y ≤ z) : x ≤ y ∨ y ≤ x",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {x y : Part α}  (z : Part α)  (hx : x ≤ z)  (hy : y ≤ z)"},
 {"type": "assert p f = f h",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {p : Prop}  {f : p → Part α}  (h : p) : assert p f = f h := by dsimp [assert]; sorry",
  "name": "assert_pos",
  "kind": "theorem",
  "first-tactic": "dsimp [assert]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {p : Prop}  {f : p → Part α}  (h : p) : assert p f = f h",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {p : Prop}  {f : p → Part α}  (h : p)"},
 {"type": "assert p f = none",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {p : Prop}  {f : p → Part α}  (h : ¬p) : assert p f = none := by dsimp [assert]; sorry",
  "name": "assert_neg",
  "kind": "theorem",
  "first-tactic": "dsimp [assert]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {p : Prop}  {f : p → Part α}  (h : ¬p) : assert p f = none",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {p : Prop}  {f : p → Part α}  (h : ¬p)"},
 {"type": "o.bind f = f (o.get h)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {o : Part α}  (h : o.Dom)  (f : α → Part β) : o.bind f = f (o.get h) := by ext b; sorry",
  "name": "Dom.bind",
  "kind": "theorem",
  "first-tactic": "ext b",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {o : Part α}  (h : o.Dom)  (f : α → Part β) : o.bind f = f (o.get h)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {o : Part α}  (h : o.Dom)  (f : α → Part β)"},
 {"type": "o.bind f = f a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {o : Part α}  {a : α}  (h : a ∈ o)  (f : α → Part β) : o.bind f = f a := by rw [eq_some_iff.2 h]; sorry",
  "name": "bind_of_mem",
  "kind": "theorem",
  "first-tactic": "rw [eq_some_iff.2 h]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {o : Part α}  {a : α}  (h : a ∈ o)  (f : α → Part β) : o.bind f = f a",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {o : Part α}  {a : α}  (h : a ∈ o)  (f : α → Part β)"},
 {"type":
  "(o.bind f).toOption = o.toOption.elim Option.none fun a => (f a).toOption",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} (f : α → Part β)  (o : Part α)  [Decidable o.Dom]  [∀ a, Decidable (f a).Dom]      [Decidable (o.bind f).Dom] : (o.bind f).toOption = o.toOption.elim Option.none fun a => (f a).toOption := by by_cases o.Dom; sorry",
  "name": "bind_toOption",
  "kind": "theorem",
  "first-tactic": "by_cases o.Dom",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} (f : α → Part β)  (o : Part α)  [Decidable o.Dom]  [∀ a, Decidable (f a).Dom]      [Decidable (o.bind f).Dom] : (o.bind f).toOption = o.toOption.elim Option.none fun a => (f a).toOption",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} (f : α → Part β)  (o : Part α)  [Decidable o.Dom]  [∀ a, Decidable (f a).Dom]      [Decidable (o.bind f).Dom]"},
 {"type": "map g (map f o) = map (g ∘ f) o",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} (g : β → γ)  (f : α → β)  (o : Part α) : map g (map f o) = map (g ∘ f) o := by erw [← bind_some_eq_map]; sorry",
  "name": "map_map",
  "kind": "theorem",
  "first-tactic": "erw [← bind_some_eq_map]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} (g : β → γ)  (f : α → β)  (o : Part α) : map g (map f o) = map (g ∘ f) o",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} (g : β → γ)  (f : α → β)  (o : Part α)"},
 {"type": "x.bind some = x",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} (x : Part α) : x.bind some = x := by erw [bind_some_eq_map]; sorry",
  "name": "bind_some_right",
  "kind": "theorem",
  "first-tactic": "erw [bind_some_eq_map]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} (x : Part α) : x.bind some = x",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _} (x : Part α)"},
 {"type": "a ∈ restrict p o h ↔ p ∧ a ∈ o",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} (p : Prop)  (o : Part α)  (h : p → o.Dom)  (a : α) : a ∈ restrict p o h ↔ p ∧ a ∈ o := by dsimp [restrict]; sorry",
  "name": "mem_restrict",
  "kind": "theorem",
  "first-tactic": "dsimp [restrict]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} (p : Prop)  (o : Part α)  (h : p → o.Dom)  (a : α) : a ∈ restrict p o h ↔ p ∧ a ∈ o",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} (p : Prop)  (o : Part α)  (h : p → o.Dom)  (a : α)"},
 {"type": "some a * some b = some (a * b)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Mul α]  (a b : α) : some a * some b = some (a * b) := by simp [mul_def]; sorry",
  "name": "some_mul_some",
  "kind": "theorem",
  "first-tactic": "simp [mul_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Mul α]  (a b : α) : some a * some b = some (a * b)",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _}  [Mul α]  (a b : α)"},
 {"type": "ma⁻¹ ∈ a⁻¹",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Inv α]  (a : Part α)  (ma : α)  (ha : ma ∈ a) : ma⁻¹ ∈ a⁻¹ := by simp [inv_def]; sorry",
  "name": "inv_mem_inv",
  "kind": "theorem",
  "first-tactic": "simp [inv_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Inv α]  (a : Part α)  (ma : α)  (ha : ma ∈ a) : ma⁻¹ ∈ a⁻¹",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Inv α]  (a : Part α)  (ma : α)  (ha : ma ∈ a)"},
 {"type": "ma / mb ∈ a / b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Div α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b) : ma / mb ∈ a / b := by simp [div_def]; sorry",
  "name": "div_mem_div",
  "kind": "theorem",
  "first-tactic": "simp [div_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Div α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b) : ma / mb ∈ a / b",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Div α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b)"},
 {"type":
  "(a / b).get hab = a.get (left_dom_of_div_dom hab) / b.get (right_dom_of_div_dom hab)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Div α]  (a b : Part α)  (hab : Dom (a / b)) : (a / b).get hab = a.get (left_dom_of_div_dom hab) / b.get (right_dom_of_div_dom hab) := by simp [div_def]; sorry",
  "name": "div_get_eq",
  "kind": "theorem",
  "first-tactic": "simp [div_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Div α]  (a b : Part α)  (hab : Dom (a / b)) : (a / b).get hab = a.get (left_dom_of_div_dom hab) / b.get (right_dom_of_div_dom hab)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Div α]  (a b : Part α)  (hab : Dom (a / b))"},
 {"type": "some a / some b = some (a / b)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Div α]  (a b : α) : some a / some b = some (a / b) := by simp [div_def]; sorry",
  "name": "some_div_some",
  "kind": "theorem",
  "first-tactic": "simp [div_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Div α]  (a b : α) : some a / some b = some (a / b)",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _}  [Div α]  (a b : α)"},
 {"type": "ma % mb ∈ a % b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Mod α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b) : ma % mb ∈ a % b := by simp [mod_def]; sorry",
  "name": "mod_mem_mod",
  "kind": "theorem",
  "first-tactic": "simp [mod_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Mod α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b) : ma % mb ∈ a % b",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Mod α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b)"},
 {"type":
  "(a % b).get hab = a.get (left_dom_of_mod_dom hab) % b.get (right_dom_of_mod_dom hab)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Mod α]  (a b : Part α)  (hab : Dom (a % b)) : (a % b).get hab = a.get (left_dom_of_mod_dom hab) % b.get (right_dom_of_mod_dom hab) := by simp [mod_def]; sorry",
  "name": "mod_get_eq",
  "kind": "theorem",
  "first-tactic": "simp [mod_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Mod α]  (a b : Part α)  (hab : Dom (a % b)) : (a % b).get hab = a.get (left_dom_of_mod_dom hab) % b.get (right_dom_of_mod_dom hab)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Mod α]  (a b : Part α)  (hab : Dom (a % b))"},
 {"type": "some a % some b = some (a % b)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Mod α]  (a b : α) : some a % some b = some (a % b) := by simp [mod_def]; sorry",
  "name": "some_mod_some",
  "kind": "theorem",
  "first-tactic": "simp [mod_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Mod α]  (a b : α) : some a % some b = some (a % b)",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _}  [Mod α]  (a b : α)"},
 {"type": "ma ++ mb ∈ a ++ b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Append α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b) : ma ++ mb ∈ a ++ b := by simp [append_def]; sorry",
  "name": "append_mem_append",
  "kind": "theorem",
  "first-tactic": "simp [append_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Append α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b) : ma ++ mb ∈ a ++ b",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Append α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b)"},
 {"type":
  "(a ++ b).get hab = a.get (left_dom_of_append_dom hab) ++ b.get (right_dom_of_append_dom hab)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Append α]  (a b : Part α)  (hab : Dom (a ++ b)) : (a ++ b).get hab = a.get (left_dom_of_append_dom hab) ++ b.get (right_dom_of_append_dom hab) := by simp [append_def]; sorry",
  "name": "append_get_eq",
  "kind": "theorem",
  "first-tactic": "simp [append_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Append α]  (a b : Part α)  (hab : Dom (a ++ b)) : (a ++ b).get hab = a.get (left_dom_of_append_dom hab) ++ b.get (right_dom_of_append_dom hab)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Append α]  (a b : Part α)  (hab : Dom (a ++ b))"},
 {"type": "some a ++ some b = some (a ++ b)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Append α]  (a b : α) : some a ++ some b = some (a ++ b) := by simp [append_def]; sorry",
  "name": "some_append_some",
  "kind": "theorem",
  "first-tactic": "simp [append_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Append α]  (a b : α) : some a ++ some b = some (a ++ b)",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _}  [Append α]  (a b : α)"},
 {"type": "ma ∩ mb ∈ a ∩ b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Inter α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b) : ma ∩ mb ∈ a ∩ b := by simp [inter_def]; sorry",
  "name": "inter_mem_inter",
  "kind": "theorem",
  "first-tactic": "simp [inter_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Inter α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b) : ma ∩ mb ∈ a ∩ b",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Inter α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b)"},
 {"type":
  "(a ∩ b).get hab = a.get (left_dom_of_inter_dom hab) ∩ b.get (right_dom_of_inter_dom hab)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Inter α]  (a b : Part α)  (hab : Dom (a ∩ b)) : (a ∩ b).get hab = a.get (left_dom_of_inter_dom hab) ∩ b.get (right_dom_of_inter_dom hab) := by simp [inter_def]; sorry",
  "name": "inter_get_eq",
  "kind": "theorem",
  "first-tactic": "simp [inter_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Inter α]  (a b : Part α)  (hab : Dom (a ∩ b)) : (a ∩ b).get hab = a.get (left_dom_of_inter_dom hab) ∩ b.get (right_dom_of_inter_dom hab)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Inter α]  (a b : Part α)  (hab : Dom (a ∩ b))"},
 {"type": "some a ∩ some b = some (a ∩ b)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Inter α]  (a b : α) : some a ∩ some b = some (a ∩ b) := by simp [inter_def]; sorry",
  "name": "some_inter_some",
  "kind": "theorem",
  "first-tactic": "simp [inter_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Inter α]  (a b : α) : some a ∩ some b = some (a ∩ b)",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _}  [Inter α]  (a b : α)"},
 {"type": "ma ∪ mb ∈ a ∪ b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Union α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b) : ma ∪ mb ∈ a ∪ b := by simp [union_def]; sorry",
  "name": "union_mem_union",
  "kind": "theorem",
  "first-tactic": "simp [union_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Union α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b) : ma ∪ mb ∈ a ∪ b",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Union α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b)"},
 {"type":
  "(a ∪ b).get hab = a.get (left_dom_of_union_dom hab) ∪ b.get (right_dom_of_union_dom hab)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Union α]  (a b : Part α)  (hab : Dom (a ∪ b)) : (a ∪ b).get hab = a.get (left_dom_of_union_dom hab) ∪ b.get (right_dom_of_union_dom hab) := by simp [union_def]; sorry",
  "name": "union_get_eq",
  "kind": "theorem",
  "first-tactic": "simp [union_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Union α]  (a b : Part α)  (hab : Dom (a ∪ b)) : (a ∪ b).get hab = a.get (left_dom_of_union_dom hab) ∪ b.get (right_dom_of_union_dom hab)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Union α]  (a b : Part α)  (hab : Dom (a ∪ b))"},
 {"type": "some a ∪ some b = some (a ∪ b)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [Union α]  (a b : α) : some a ∪ some b = some (a ∪ b) := by simp [union_def]; sorry",
  "name": "some_union_some",
  "kind": "theorem",
  "first-tactic": "simp [union_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [Union α]  (a b : α) : some a ∪ some b = some (a ∪ b)",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _}  [Union α]  (a b : α)"},
 {"type": "ma \\ mb ∈ a \\ b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [SDiff α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b) : ma \\ mb ∈ a \\ b := by simp [sdiff_def]; sorry",
  "name": "sdiff_mem_sdiff",
  "kind": "theorem",
  "first-tactic": "simp [sdiff_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [SDiff α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b) : ma \\ mb ∈ a \\ b",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [SDiff α]  (a b : Part α)  (ma mb : α)  (ha : ma ∈ a)  (hb : mb ∈ b)"},
 {"type":
  "(a \\ b).get hab = a.get (left_dom_of_sdiff_dom hab) \\ b.get (right_dom_of_sdiff_dom hab)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [SDiff α]  (a b : Part α)  (hab : Dom (a \\ b)) : (a \\ b).get hab = a.get (left_dom_of_sdiff_dom hab) \\ b.get (right_dom_of_sdiff_dom hab) := by simp [sdiff_def]; sorry",
  "name": "sdiff_get_eq",
  "kind": "theorem",
  "first-tactic": "simp [sdiff_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [SDiff α]  (a b : Part α)  (hab : Dom (a \\ b)) : (a \\ b).get hab = a.get (left_dom_of_sdiff_dom hab) \\ b.get (right_dom_of_sdiff_dom hab)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [SDiff α]  (a b : Part α)  (hab : Dom (a \\ b))"},
 {"type": "some a \\ some b = some (a \\ b)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  [SDiff α]  (a b : α) : some a \\ some b = some (a \\ b) := by simp [sdiff_def]; sorry",
  "name": "some_sdiff_some",
  "kind": "theorem",
  "first-tactic": "simp [sdiff_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  [SDiff α]  (a b : α) : some a \\ some b = some (a \\ b)",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _}  [SDiff α]  (a b : α)"},
 {"type": "a /. b = 0 ↔ a = 0",
  "tactic-prompt":
  "theorem {a b : ℤ}  (b0 : b ≠ 0) : a /. b = 0 ↔ a = 0 := by rw [←zero_divInt b]; sorry",
  "name": "divInt_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [←zero_divInt b]",
  "core-prompt": "{a b : ℤ}  (b0 : b ≠ 0) : a /. b = 0 ↔ a = 0",
  "args": "{a b : ℤ}  (b0 : b ≠ 0)"},
 {"type": "f (a /. b) (c /. d) = f₁ a b c d /. f₂ a b c d",
  "tactic-prompt":
  "theorem (f : ℚ → ℚ → ℚ)  (f₁ : ℤ → ℤ → ℤ → ℤ → ℤ)  (f₂ : ℤ → ℤ → ℤ → ℤ → ℤ)      (fv :       ∀ {n₁ d₁ h₁ c₁ n₂ d₂ h₂ c₂},         f ⟨n₁, d₁, h₁, c₁⟩ ⟨n₂, d₂, h₂, c₂⟩ = f₁ n₁ d₁ n₂ d₂ /. f₂ n₁ d₁ n₂ d₂)      (f0 : ∀ {n₁ d₁ n₂ d₂}, d₁ ≠ 0 → d₂ ≠ 0 → f₂ n₁ d₁ n₂ d₂ ≠ 0)  (a b c d : ℤ)      (b0 : b ≠ 0)  (d0 : d ≠ 0)      (H :       ∀ {n₁ d₁ n₂ d₂}, a * d₁ = n₁ * b → c * d₂ = n₂ * d →         f₁ n₁ d₁ n₂ d₂ * f₂ a b c d = f₁ a b c d * f₂ n₁ d₁ n₂ d₂) : f (a /. b) (c /. d) = f₁ a b c d /. f₂ a b c d := by generalize ha : a /. b = x; sorry",
  "name": "lift_binop_eq",
  "kind": "theorem",
  "first-tactic": "generalize ha : a /. b = x",
  "core-prompt":
  "(f : ℚ → ℚ → ℚ)  (f₁ : ℤ → ℤ → ℤ → ℤ → ℤ)  (f₂ : ℤ → ℤ → ℤ → ℤ → ℤ)      (fv :       ∀ {n₁ d₁ h₁ c₁ n₂ d₂ h₂ c₂},         f ⟨n₁, d₁, h₁, c₁⟩ ⟨n₂, d₂, h₂, c₂⟩ = f₁ n₁ d₁ n₂ d₂ /. f₂ n₁ d₁ n₂ d₂)      (f0 : ∀ {n₁ d₁ n₂ d₂}, d₁ ≠ 0 → d₂ ≠ 0 → f₂ n₁ d₁ n₂ d₂ ≠ 0)  (a b c d : ℤ)      (b0 : b ≠ 0)  (d0 : d ≠ 0)      (H :       ∀ {n₁ d₁ n₂ d₂}, a * d₁ = n₁ * b → c * d₂ = n₂ * d →         f₁ n₁ d₁ n₂ d₂ * f₂ a b c d = f₁ a b c d * f₂ n₁ d₁ n₂ d₂) : f (a /. b) (c /. d) = f₁ a b c d /. f₂ a b c d",
  "args":
  "(f : ℚ → ℚ → ℚ)  (f₁ : ℤ → ℤ → ℤ → ℤ → ℤ)  (f₂ : ℤ → ℤ → ℤ → ℤ → ℤ)      (fv :       ∀ {n₁ d₁ h₁ c₁ n₂ d₂ h₂ c₂},         f ⟨n₁, d₁, h₁, c₁⟩ ⟨n₂, d₂, h₂, c₂⟩ = f₁ n₁ d₁ n₂ d₂ /. f₂ n₁ d₁ n₂ d₂)      (f0 : ∀ {n₁ d₁ n₂ d₂}, d₁ ≠ 0 → d₂ ≠ 0 → f₂ n₁ d₁ n₂ d₂ ≠ 0)  (a b c d : ℤ)      (b0 : b ≠ 0)  (d0 : d ≠ 0)      (H :       ∀ {n₁ d₁ n₂ d₂}, a * d₁ = n₁ * b → c * d₂ = n₂ * d →         f₁ n₁ d₁ n₂ d₂ * f₂ a b c d = f₁ a b c d * f₂ n₁ d₁ n₂ d₂)"},
 {"type": "a * (b + c) = a * b + a * c",
  "tactic-prompt":
  "theorem (a b c : ℚ)  -- Porting note: TODO this is a workaround. : a * (b + c) = a * b + a * c := by rw [Rat.mul_comm]; sorry",
  "name": "mul_add",
  "kind": "theorem",
  "first-tactic": "rw [Rat.mul_comm]",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : a * (b + c) = a * b + a * c",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "0 ≠ (1 : ℚ)",
  "tactic-prompt":
  "theorem (a b c : ℚ)  -- Porting note: TODO this is a workaround. : 0 ≠ (1 : ℚ) := by rw [ne_comm]; sorry",
  "name": "zero_ne_one",
  "kind": "theorem",
  "first-tactic": "rw [ne_comm]",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : 0 ≠ (1 : ℚ)",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "Nontrivial ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ)  -- Porting note: TODO this is a workaround. : Nontrivial ℚ := by infer_instance; sorry",
  "name": "nontrivial",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : Nontrivial ℚ",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "CommSemiring ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ)  -- Porting note: TODO this is a workaround. : CommSemiring ℚ := by infer_instance; sorry",
  "name": "commSemiring",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : CommSemiring ℚ",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "Semiring ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ)  -- Porting note: TODO this is a workaround. : Semiring ℚ := by infer_instance; sorry",
  "name": "semiring",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : Semiring ℚ",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "AddCommGroup ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ)  -- Porting note: TODO this is a workaround. : AddCommGroup ℚ := by infer_instance; sorry",
  "name": "addCommGroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : AddCommGroup ℚ",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "AddGroup ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ)  -- Porting note: TODO this is a workaround. : AddGroup ℚ := by infer_instance; sorry",
  "name": "addGroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : AddGroup ℚ",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "AddCommMonoid ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ)  -- Porting note: TODO this is a workaround. : AddCommMonoid ℚ := by infer_instance; sorry",
  "name": "addCommMonoid",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : AddCommMonoid ℚ",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "AddMonoid ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ)  -- Porting note: TODO this is a workaround. : AddMonoid ℚ := by infer_instance; sorry",
  "name": "addMonoid",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : AddMonoid ℚ",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "AddLeftCancelSemigroup ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ)  -- Porting note: TODO this is a workaround. : AddLeftCancelSemigroup ℚ := by infer_instance; sorry",
  "name": "addLeftCancelSemigroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : AddLeftCancelSemigroup ℚ",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "AddRightCancelSemigroup ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ)  -- Porting note: TODO this is a workaround. : AddRightCancelSemigroup ℚ := by infer_instance; sorry",
  "name": "addRightCancelSemigroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : AddRightCancelSemigroup ℚ",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "AddCommSemigroup ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ)  -- Porting note: TODO this is a workaround. : AddCommSemigroup ℚ := by infer_instance; sorry",
  "name": "addCommSemigroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : AddCommSemigroup ℚ",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "AddSemigroup ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ)  -- Porting note: TODO this is a workaround. : AddSemigroup ℚ := by infer_instance; sorry",
  "name": "addSemigroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : AddSemigroup ℚ",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "CommMonoid ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ)  -- Porting note: TODO this is a workaround. : CommMonoid ℚ := by infer_instance; sorry",
  "name": "commMonoid",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : CommMonoid ℚ",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "Monoid ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ)  -- Porting note: TODO this is a workaround. : Monoid ℚ := by infer_instance; sorry",
  "name": "monoid",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : Monoid ℚ",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "CommSemigroup ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ)  -- Porting note: TODO this is a workaround. : CommSemigroup ℚ := by infer_instance; sorry",
  "name": "commSemigroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : CommSemigroup ℚ",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "Semigroup ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ)  -- Porting note: TODO this is a workaround. : Semigroup ℚ := by infer_instance; sorry",
  "name": "semigroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. : Semigroup ℚ",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround."},
 {"type": "p = q ↔ p.num * q.den = q.num * p.den",
  "tactic-prompt":
  "theorem (a b c : ℚ)  -- Porting note: TODO this is a workaround. {p q : ℚ} : p = q ↔ p.num * q.den = q.num * p.den := by conv =>\n    lhs\n    rw [← @num_den p]; sorry",
  "name": "eq_iff_mul_eq_mul",
  "kind": "theorem",
  "first-tactic": "conv =>\n    lhs\n    rw [← @num_den p]",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. {p q : ℚ} : p = q ↔ p.num * q.den = q.num * p.den",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround. {p q : ℚ}"},
 {"type": "q = 0",
  "tactic-prompt":
  "theorem (a b c : ℚ)  -- Porting note: TODO this is a workaround. {q : ℚ}  (hq : q.num = 0) : q = 0 := by have : q = q.num /. q.den := num_den.symm; sorry",
  "name": "zero_of_num_zero",
  "kind": "theorem",
  "first-tactic": "have : q = q.num /. q.den := num_den.symm",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. {q : ℚ}  (hq : q.num = 0) : q = 0",
  "args":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. {q : ℚ}  (hq : q.num = 0)"},
 {"type": "q * r = q.num * r.num /. ↑(q.den * r.den)",
  "tactic-prompt":
  "theorem (a b c : ℚ)  -- Porting note: TODO this is a workaround. (q r : ℚ) : q * r = q.num * r.num /. ↑(q.den * r.den) := by have hq' : (↑q.den : ℤ) ≠ 0 := by have := den_nz q; simpa; sorry",
  "name": "mul_num_den",
  "kind": "theorem",
  "first-tactic": "have hq' : (↑q.den : ℤ) ≠ 0 := by have := den_nz q; simpa",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround. (q r : ℚ) : q * r = q.num * r.num /. ↑(q.den * r.den)",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround. (q r : ℚ)"},
 {"type": "n /. d = (n : ℚ) / d",
  "tactic-prompt":
  "theorem (a b c : ℚ)  -- Porting note: TODO this is a workaround.  (n d : ℤ) : n /. d = (n : ℚ) / d := by by_cases d0 : d = 0; sorry",
  "name": "divInt_eq_div",
  "kind": "theorem",
  "first-tactic": "by_cases d0 : d = 0",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  (n d : ℤ) : n /. d = (n : ℚ) / d",
  "args":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  (n d : ℤ)"},
 {"type": "n /. x * (x /. d) = n /. d",
  "tactic-prompt":
  "theorem (a b c : ℚ)  -- Porting note: TODO this is a workaround.  {x : ℤ}  (hx : x ≠ 0)  (n d : ℤ) : n /. x * (x /. d) = n /. d := by by_cases hd : d = 0; sorry",
  "name": "divInt_mul_divInt_cancel",
  "kind": "theorem",
  "first-tactic": "by_cases hd : d = 0",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  {x : ℤ}  (hx : x ≠ 0)  (n d : ℤ) : n /. x * (x /. d) = n /. d",
  "args":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  {x : ℤ}  (hx : x ≠ 0)  (n d : ℤ)"},
 {"type": "n /. x / (d /. x) = n /. d",
  "tactic-prompt":
  "theorem (a b c : ℚ)  -- Porting note: TODO this is a workaround.  {x : ℤ}  (hx : x ≠ 0)  (n d : ℤ) : n /. x / (d /. x) = n /. d := by rw [div_eq_mul_inv]; sorry",
  "name": "divInt_div_divInt_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  {x : ℤ}  (hx : x ≠ 0)  (n d : ℤ) : n /. x / (d /. x) = n /. d",
  "args":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  {x : ℤ}  (hx : x ≠ 0)  (n d : ℤ)"},
 {"type": "x /. n / (x /. d) = d /. n",
  "tactic-prompt":
  "theorem (a b c : ℚ)  -- Porting note: TODO this is a workaround.  {x : ℤ}  (hx : x ≠ 0)  (n d : ℤ) : x /. n / (x /. d) = d /. n := by rw [div_eq_mul_inv]; sorry",
  "name": "divInt_div_divInt_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  {x : ℤ}  (hx : x ≠ 0)  (n d : ℤ) : x /. n / (x /. d) = d /. n",
  "args":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  {x : ℤ}  (hx : x ≠ 0)  (n d : ℤ)"},
 {"type": "(n : ℚ) / (d) = n /. d",
  "tactic-prompt":
  "theorem (a b c : ℚ)  -- Porting note: TODO this is a workaround.  {n d : ℤ} : (n : ℚ) / (d) = n /. d := by repeat' rw [coe_int_eq_divInt]; sorry",
  "name": "coe_int_div_eq_divInt",
  "kind": "theorem",
  "first-tactic": "repeat' rw [coe_int_eq_divInt]",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  {n d : ℤ} : (n : ℚ) / (d) = n /. d",
  "args":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  {n d : ℤ}"},
 {"type": "(r.num : ℚ) / (r.den : ℚ) = r",
  "tactic-prompt":
  "theorem (a b c : ℚ)  -- Porting note: TODO this is a workaround.  (r : ℚ) : (r.num : ℚ) / (r.den : ℚ) = r := by rw [← Int.cast_ofNat]; sorry",
  "name": "num_div_den",
  "kind": "theorem",
  "first-tactic": "rw [← Int.cast_ofNat]",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  (r : ℚ) : (r.num : ℚ) / (r.den : ℚ) = r",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  (r : ℚ)"},
 {"type": "(q.num : ℚ) = q",
  "tactic-prompt":
  "theorem (a b c : ℚ)  -- Porting note: TODO this is a workaround.  {q : ℚ}  (hq : q.den = 1) : (q.num : ℚ) = q := by conv_rhs => rw [← @num_den q]; sorry",
  "name": "coe_int_num_of_den_eq_one",
  "kind": "theorem",
  "first-tactic": "conv_rhs => rw [← @num_den q]",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  {q : ℚ}  (hq : q.den = 1) : (q.num : ℚ) = q",
  "args":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  {q : ℚ}  (hq : q.den = 1)"},
 {"type": "↑n = n /. 1",
  "tactic-prompt":
  "theorem (a b c : ℚ)  -- Porting note: TODO this is a workaround.  (n : ℕ) : ↑n = n /. 1 := by rw [← Int.cast_ofNat]; sorry",
  "name": "coe_nat_eq_divInt",
  "kind": "theorem",
  "first-tactic": "rw [← Int.cast_ofNat]",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  (n : ℕ) : ↑n = n /. 1",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  (n : ℕ)"},
 {"type": "(n : ℚ).num = n",
  "tactic-prompt":
  "theorem (a b c : ℚ)  -- Porting note: TODO this is a workaround.  (n : ℕ) : (n : ℚ).num = n := by rw [← Int.cast_ofNat]; sorry",
  "name": "coe_nat_num",
  "kind": "theorem",
  "first-tactic": "rw [← Int.cast_ofNat]",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  (n : ℕ) : (n : ℚ).num = n",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  (n : ℕ)"},
 {"type": "(n : ℚ).den = 1",
  "tactic-prompt":
  "theorem (a b c : ℚ)  -- Porting note: TODO this is a workaround.  (n : ℕ) : (n : ℚ).den = 1 := by rw [← Int.cast_ofNat]; sorry",
  "name": "coe_nat_den",
  "kind": "theorem",
  "first-tactic": "rw [← Int.cast_ofNat]",
  "core-prompt":
  "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  (n : ℕ) : (n : ℚ).den = 1",
  "args": "(a b c : ℚ)  -- Porting note: TODO this is a workaround.  (n : ℕ)"},
 {"type": "DivisionRing ℚ",
  "tactic-prompt": "instance  : DivisionRing ℚ := by infer_instance; sorry",
  "name": "divisionRing",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : DivisionRing ℚ",
  "args": ""},
 {"type": "(a /. b).Nonneg ↔ 0 ≤ a",
  "tactic-prompt":
  "theorem (a b c : ℚ) (a : ℤ)  {b : ℤ}  (h : 0 < b) : (a /. b).Nonneg ↔ 0 ≤ a := by generalize ha : a /. b = x; sorry",
  "name": "divInt_nonneg",
  "kind": "theorem",
  "first-tactic": "generalize ha : a /. b = x",
  "core-prompt":
  "(a b c : ℚ) (a : ℤ)  {b : ℤ}  (h : 0 < b) : (a /. b).Nonneg ↔ 0 ≤ a",
  "args": "(a b c : ℚ) (a : ℤ)  {b : ℤ}  (h : 0 < b)"},
 {"type": "Rat.Nonneg a ∨ Rat.Nonneg (-a)",
  "tactic-prompt":
  "theorem (a b c : ℚ) : Rat.Nonneg a ∨ Rat.Nonneg (-a) := by cases' a with n; sorry",
  "name": "nonneg_total",
  "kind": "theorem",
  "first-tactic": "cases' a with n",
  "core-prompt": "(a b c : ℚ) : Rat.Nonneg a ∨ Rat.Nonneg (-a)",
  "args": "(a b c : ℚ)"},
 {"type": "Decidable (Rat.Nonneg a)",
  "tactic-prompt":
  "instance (a b c : ℚ) : Decidable (Rat.Nonneg a) := by cases a; sorry",
  "name": "decidableNonneg",
  "kind": "instance",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : ℚ) : Decidable (Rat.Nonneg a)",
  "args": "(a b c : ℚ)"},
 {"type": "a /. b ≤ c /. d ↔ a * d ≤ c * b",
  "tactic-prompt":
  "theorem (a b c : ℚ) {a b c d : ℤ}  (b0 : 0 < b)  (d0 : 0 < d) : a /. b ≤ c /. d ↔ a * d ≤ c * b := by rw [Rat.le_iff_Nonneg]; sorry",
  "name": "le_def",
  "kind": "theorem",
  "first-tactic": "rw [Rat.le_iff_Nonneg]",
  "core-prompt":
  "(a b c : ℚ) {a b c d : ℤ}  (b0 : 0 < b)  (d0 : 0 < d) : a /. b ≤ c /. d ↔ a * d ≤ c * b",
  "args": "(a b c : ℚ) {a b c d : ℤ}  (b0 : 0 < b)  (d0 : 0 < d)"},
 {"type": "a ≤ a",
  "tactic-prompt":
  "theorem (a b c : ℚ) : a ≤ a := by rw [Rat.le_iff_Nonneg]; sorry",
  "name": "le_refl",
  "kind": "theorem",
  "first-tactic": "rw [Rat.le_iff_Nonneg]",
  "core-prompt": "(a b c : ℚ) : a ≤ a",
  "args": "(a b c : ℚ)"},
 {"type": "a ≤ b ∨ b ≤ a",
  "tactic-prompt":
  "theorem (a b c : ℚ) : a ≤ b ∨ b ≤ a := by have := Rat.nonneg_total (b - a); sorry",
  "name": "le_total",
  "kind": "theorem",
  "first-tactic": "have := Rat.nonneg_total (b - a)",
  "core-prompt": "(a b c : ℚ) : a ≤ b ∨ b ≤ a",
  "args": "(a b c : ℚ)"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem (a b c : ℚ) {a b : ℚ}  (hab : a ≤ b)  (hba : b ≤ a) : a = b := by rw [Rat.le_iff_Nonneg] at hab hba; sorry",
  "name": "le_antisymm",
  "kind": "theorem",
  "first-tactic": "rw [Rat.le_iff_Nonneg] at hab hba",
  "core-prompt": "(a b c : ℚ) {a b : ℚ}  (hab : a ≤ b)  (hba : b ≤ a) : a = b",
  "args": "(a b c : ℚ) {a b : ℚ}  (hab : a ≤ b)  (hba : b ≤ a)"},
 {"type": "a ≤ c",
  "tactic-prompt":
  "theorem (a b c : ℚ) {a b c : ℚ}  (hab : a ≤ b)  (hbc : b ≤ c) : a ≤ c := by rw [Rat.le_iff_Nonneg] at hab hbc; sorry",
  "name": "le_trans",
  "kind": "theorem",
  "first-tactic": "rw [Rat.le_iff_Nonneg] at hab hbc",
  "core-prompt":
  "(a b c : ℚ) {a b c : ℚ}  (hab : a ≤ b)  (hbc : b ≤ c) : a ≤ c",
  "args": "(a b c : ℚ) {a b c : ℚ}  (hab : a ≤ b)  (hbc : b ≤ c)"},
 {"type": "LT ℚ",
  "tactic-prompt": "instance (a b c : ℚ) : LT ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : LT ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "DistribLattice ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : DistribLattice ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : DistribLattice ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "Lattice ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : Lattice ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : Lattice ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "SemilatticeInf ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : SemilatticeInf ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : SemilatticeInf ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "SemilatticeSup ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : SemilatticeSup ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : SemilatticeSup ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "HasInf ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : HasInf ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : HasInf ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "HasSup ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : HasSup ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : HasSup ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "PartialOrder ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : PartialOrder ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : PartialOrder ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "Preorder ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : Preorder ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : Preorder ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "p ≤ q ↔ p.num * q.den ≤ q.num * p.den",
  "tactic-prompt":
  "theorem (a b c : ℚ) {p q : ℚ} : p ≤ q ↔ p.num * q.den ≤ q.num * p.den := by rw [← @num_den q]; sorry",
  "name": "le_def'",
  "kind": "theorem",
  "first-tactic": "rw [← @num_den q]",
  "core-prompt":
  "(a b c : ℚ) {p q : ℚ} : p ≤ q ↔ p.num * q.den ≤ q.num * p.den",
  "args": "(a b c : ℚ) {p q : ℚ}"},
 {"type": "p < q ↔ p.num * q.den < q.num * p.den",
  "tactic-prompt":
  "theorem (a b c : ℚ) {p q : ℚ} : p < q ↔ p.num * q.den < q.num * p.den := by rw [lt_iff_le_and_ne]; sorry",
  "name": "lt_def",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_le_and_ne]",
  "core-prompt":
  "(a b c : ℚ) {p q : ℚ} : p < q ↔ p.num * q.den < q.num * p.den",
  "args": "(a b c : ℚ) {p q : ℚ}"},
 {"type": "c + a ≤ c + b ↔ a ≤ b",
  "tactic-prompt":
  "theorem (a b c : ℚ) {a b c : ℚ} : c + a ≤ c + b ↔ a ≤ b := by rw [Rat.le_iff_Nonneg]; sorry",
  "name": "add_le_add_left",
  "kind": "theorem",
  "first-tactic": "rw [Rat.le_iff_Nonneg]",
  "core-prompt": "(a b c : ℚ) {a b c : ℚ} : c + a ≤ c + b ↔ a ≤ b",
  "args": "(a b c : ℚ) {a b c : ℚ}"},
 {"type": "0 ≤ a * b",
  "tactic-prompt":
  "theorem (a b c : ℚ) {a b : ℚ}  (ha : 0 ≤ a)  (hb : 0 ≤ b) : 0 ≤ a * b := by rw [← nonneg_iff_zero_le] at ha hb⊢; sorry",
  "name": "mul_nonneg",
  "kind": "theorem",
  "first-tactic": "rw [← nonneg_iff_zero_le] at ha hb⊢",
  "core-prompt":
  "(a b c : ℚ) {a b : ℚ}  (ha : 0 ≤ a)  (hb : 0 ≤ b) : 0 ≤ a * b",
  "args": "(a b c : ℚ) {a b : ℚ}  (ha : 0 ≤ a)  (hb : 0 ≤ b)"},
 {"type": "LinearOrderedCommRing ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : LinearOrderedCommRing ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : LinearOrderedCommRing ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "LinearOrderedRing ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : LinearOrderedRing ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : LinearOrderedRing ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "OrderedRing ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : OrderedRing ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : OrderedRing ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "LinearOrderedSemiring ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : LinearOrderedSemiring ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : LinearOrderedSemiring ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "OrderedSemiring ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : OrderedSemiring ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : OrderedSemiring ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "LinearOrderedAddCommGroup ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : LinearOrderedAddCommGroup ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : LinearOrderedAddCommGroup ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "OrderedAddCommGroup ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : OrderedAddCommGroup ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : OrderedAddCommGroup ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "OrderedCancelAddCommMonoid ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : OrderedCancelAddCommMonoid ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : OrderedCancelAddCommMonoid ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "OrderedAddCommMonoid ℚ",
  "tactic-prompt":
  "instance (a b c : ℚ) : OrderedAddCommMonoid ℚ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : ℚ) : OrderedAddCommMonoid ℚ",
  "args": "(a b c : ℚ)"},
 {"type": "(a : ℚ) / b < c / d ↔ a * d < c * b",
  "tactic-prompt":
  "theorem (a b c : ℚ) {a b c d : ℤ}  (b_pos : 0 < b)  (d_pos : 0 < d) : (a : ℚ) / b < c / d ↔ a * d < c * b := by simp only [lt_iff_le_not_le]; sorry",
  "name": "div_lt_div_iff_mul_lt_mul",
  "kind": "theorem",
  "first-tactic": "simp only [lt_iff_le_not_le]",
  "core-prompt":
  "(a b c : ℚ) {a b c d : ℤ}  (b_pos : 0 < b)  (d_pos : 0 < d) : (a : ℚ) / b < c / d ↔ a * d < c * b",
  "args": "(a b c : ℚ) {a b c d : ℤ}  (b_pos : 0 < b)  (d_pos : 0 < d)"},
 {"type": "q < 1 ↔ q.num < q.den",
  "tactic-prompt":
  "theorem (a b c : ℚ) {q : ℚ} : q < 1 ↔ q.num < q.den := by simp [Rat.lt_def]; sorry",
  "name": "lt_one_iff_num_lt_denom",
  "kind": "theorem",
  "first-tactic": "simp [Rat.lt_def]",
  "core-prompt": "(a b c : ℚ) {q : ℚ} : q < 1 ↔ q.num < q.den",
  "args": "(a b c : ℚ) {q : ℚ}"},
 {"type": "|q| = q.num.natAbs /. q.den",
  "tactic-prompt":
  "theorem (a b c : ℚ) (q : ℚ) : |q| = q.num.natAbs /. q.den := by cases' le_total q 0 with hq hq; sorry",
  "name": "abs_def",
  "kind": "theorem",
  "first-tactic": "cases' le_total q 0 with hq hq",
  "core-prompt": "(a b c : ℚ) (q : ℚ) : |q| = q.num.natAbs /. q.den",
  "args": "(a b c : ℚ) (q : ℚ)"},
 {"type": "n = arr.size",
  "tactic-prompt":
  "theorem {arr : Array α}  {m : Fin n → β}  (H : Agrees arr f m) : n = arr.size := by cases H; sorry",
  "name": "size_eq",
  "kind": "theorem",
  "first-tactic": "cases H",
  "core-prompt":
  "{arr : Array α}  {m : Fin n → β}  (H : Agrees arr f m) : n = arr.size",
  "args": "{arr : Array α}  {m : Fin n → β}  (H : Agrees arr f m)"},
 {"type": "∃ (m : UFModel self.arr.size), m.Models self.arr",
  "tactic-prompt":
  "theorem (self : UnionFind α) : ∃ (m : UFModel self.arr.size), m.Models self.arr := by let ⟨n, m, hm⟩ := self.model; sorry",
  "name": "model'",
  "kind": "theorem",
  "first-tactic": "let ⟨n, m, hm⟩ := self.model",
  "core-prompt":
  "(self : UnionFind α) : ∃ (m : UFModel self.arr.size), m.Models self.arr",
  "args": "(self : UnionFind α)"},
 {"type": "self.rank i < self.rankMax",
  "tactic-prompt":
  "theorem (self : UnionFind α)  (i : Nat) : self.rank i < self.rankMax := by simp [rank]; sorry",
  "name": "lt_rankMax",
  "kind": "theorem",
  "first-tactic": "simp [rank]",
  "core-prompt": "(self : UnionFind α)  (i : Nat) : self.rank i < self.rankMax",
  "args": "(self : UnionFind α)  (i : Nat)"},
 {"type":
  "(s : Array (UFNode α)) ×' (root : Fin s.size) ×'\n    ∃ n, ∃ (m : UFModel n) (m' : UFModel n),\n      m.Models self.arr ∧ m'.Models s ∧ m'.rank = m.rank ∧\n      (∃ hr, (m'.parent ⟨root, hr⟩).1 = root) ∧\n      m.rank x ≤ m.rank root",
  "tactic-prompt":
  "def (self : UnionFind α)  (x : Fin self.size) : (s : Array (UFNode α)) ×' (root : Fin s.size) ×'\n    ∃ n, ∃ (m : UFModel n) (m' : UFModel n),\n      m.Models self.arr ∧ m'.Models s ∧ m'.rank = m.rank ∧\n      (∃ hr, (m'.parent ⟨root, hr⟩).1 = root) ∧\n      m.rank x ≤ m.rank root := by let y := self.arr[x].parent; sorry",
  "name": "findAux",
  "kind": "def",
  "first-tactic": "let y := self.arr[x].parent",
  "core-prompt":
  "(self : UnionFind α)  (x : Fin self.size) : (s : Array (UFNode α)) ×' (root : Fin s.size) ×'\n    ∃ n, ∃ (m : UFModel n) (m' : UFModel n),\n      m.Models self.arr ∧ m'.Models s ∧ m'.rank = m.rank ∧\n      (∃ hr, (m'.parent ⟨root, hr⟩).1 = root) ∧\n      m.rank x ≤ m.rank root",
  "args": "(self : UnionFind α)  (x : Fin self.size)"},
 {"type": "UnionFind α",
  "tactic-prompt":
  "def (self : UnionFind α)  (x y : Fin self.size)    (yroot : (self.arr.get y).parent = y) : UnionFind α := by refine if ne : x.1 = y then self else\n    let nx := self.arr[x]\n    let ny := self.arr[y]\n    if h : ny.rank < nx.rank then\n      ⟨self.arr.set y {ny with parent := x}]; sorry",
  "name": "link",
  "kind": "def",
  "first-tactic":
  "refine if ne : x.1 = y then self else\n    let nx := self.arr[x]\n    let ny := self.arr[y]\n    if h : ny.rank < nx.rank then\n      ⟨self.arr.set y {ny with parent := x}]",
  "core-prompt":
  "(self : UnionFind α)  (x y : Fin self.size)    (yroot : (self.arr.get y).parent = y) : UnionFind α",
  "args":
  "(self : UnionFind α)  (x y : Fin self.size)    (yroot : (self.arr.get y).parent = y)"},
 {"type": "x.getLeft = none ↔ x.isRight",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : x.getLeft = none ↔ x.isRight := by cases x; sorry",
  "name": "getLeft_eq_none_iff",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : x.getLeft = none ↔ x.isRight",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β}"},
 {"type": "x.getRight = none ↔ x.isLeft",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : x.getRight = none ↔ x.isLeft := by cases x; sorry",
  "name": "getRight_eq_none_iff",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : x.getRight = none ↔ x.isLeft",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β}"},
 {"type": "not x.isLeft = x.isRight",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} (x : Sum α β) : not x.isLeft = x.isRight := by cases x; sorry",
  "name": "not_isLeft",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} (x : Sum α β) : not x.isLeft = x.isRight",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} (x : Sum α β)"},
 {"type": "x.isLeft = false ↔ x.isRight",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : x.isLeft = false ↔ x.isRight := by cases x; sorry",
  "name": "isLeft_eq_false",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : x.isLeft = false ↔ x.isRight",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β}"},
 {"type": "¬x.isLeft ↔ x.isRight",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : ¬x.isLeft ↔ x.isRight := by simp; sorry",
  "name": "Not_isLeft",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : ¬x.isLeft ↔ x.isRight",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β}"},
 {"type": "!x.isRight = x.isLeft",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} (x : Sum α β) : !x.isRight = x.isLeft := by cases x; sorry",
  "name": "not_isRight",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} (x : Sum α β) : !x.isRight = x.isLeft",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} (x : Sum α β)"},
 {"type": "x.isRight = false ↔ x.isLeft",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : x.isRight = false ↔ x.isLeft := by cases x; sorry",
  "name": "isRight_eq_false",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : x.isRight = false ↔ x.isLeft",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β}"},
 {"type": "¬x.isRight ↔ x.isLeft",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : ¬x.isRight ↔ x.isLeft := by simp; sorry",
  "name": "Not_isRight",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : ¬x.isRight ↔ x.isLeft",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β}"},
 {"type": "x.isLeft ↔ ∃ y, x = Sum.inl y",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : x.isLeft ↔ ∃ y, x = Sum.inl y := by cases x; sorry",
  "name": "isLeft_iff",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : x.isLeft ↔ ∃ y, x = Sum.inl y",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β}"},
 {"type": "x.isRight ↔ ∃ y, x = Sum.inr y",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : x.isRight ↔ ∃ y, x = Sum.inr y := by cases x; sorry",
  "name": "isRight_iff",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : x.isRight ↔ ∃ y, x = Sum.inr y",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β}"},
 {"type": "Sum.elim f₂ g₂ ∘ Sum.map f₁ g₁ = Sum.elim (f₂ ∘ f₁) (g₂ ∘ g₁)",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} {α β γ δ ε : Sort _}  {f₁ : α → β}  {f₂ : β → ε}  {g₁ : γ → δ}  {g₂ : δ → ε} : Sum.elim f₂ g₂ ∘ Sum.map f₁ g₁ = Sum.elim (f₂ ∘ f₁) (g₂ ∘ g₁) := by ext (_ | _); sorry",
  "name": "elim_comp_map",
  "kind": "theorem",
  "first-tactic": "ext (_ | _)",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} {α β γ δ ε : Sort _}  {f₁ : α → β}  {f₂ : β → ε}  {g₁ : γ → δ}  {g₂ : δ → ε} : Sum.elim f₂ g₂ ∘ Sum.map f₁ g₁ = Sum.elim (f₂ ∘ f₁) (g₂ ∘ g₁)",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} {α β γ δ ε : Sort _}  {f₁ : α → β}  {f₂ : β → ε}  {g₁ : γ → δ}  {g₂ : δ → ε}"},
 {"type": "isLeft (x.map f g) = isLeft x",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (f : α → β)  (g : γ → δ)  (x : Sum α γ) : isLeft (x.map f g) = isLeft x := by cases x; sorry",
  "name": "isLeft_map",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (f : α → β)  (g : γ → δ)  (x : Sum α γ) : isLeft (x.map f g) = isLeft x",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (f : α → β)  (g : γ → δ)  (x : Sum α γ)"},
 {"type": "isRight (x.map f g) = isRight x",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (f : α → β)  (g : γ → δ)  (x : Sum α γ) : isRight (x.map f g) = isRight x := by cases x; sorry",
  "name": "isRight_map",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (f : α → β)  (g : γ → δ)  (x : Sum α γ) : isRight (x.map f g) = isRight x",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (f : α → β)  (g : γ → δ)  (x : Sum α γ)"},
 {"type": "(x.map f g).getLeft = x.getLeft.map f",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (f : α → β)  (g : γ → δ)  (x : Sum α γ) : (x.map f g).getLeft = x.getLeft.map f := by cases x; sorry",
  "name": "getLeft_map",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (f : α → β)  (g : γ → δ)  (x : Sum α γ) : (x.map f g).getLeft = x.getLeft.map f",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (f : α → β)  (g : γ → δ)  (x : Sum α γ)"},
 {"type": "(x.map f g).getRight = x.getRight.map g",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (f : α → β)  (g : γ → δ)  (x : α ⊕ γ) : (x.map f g).getRight = x.getRight.map g := by cases x; sorry",
  "name": "getRight_map",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (f : α → β)  (g : γ → δ)  (x : α ⊕ γ) : (x.map f g).getRight = x.getRight.map g",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (f : α → β)  (g : γ → δ)  (x : α ⊕ γ)"},
 {"type": "update f (inl i) x (inl j) = update (f ∘ inl) i x j",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq (Sum α β)]  {f : Sum α β → γ}  {i j : α}      {x : γ} : update f (inl i) x (inl j) = update (f ∘ inl) i x j := by rw [← update_inl_comp_inl]; sorry",
  "name": "update_inl_apply_inl",
  "kind": "theorem",
  "first-tactic": "rw [← update_inl_comp_inl]",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq (Sum α β)]  {f : Sum α β → γ}  {i j : α}      {x : γ} : update f (inl i) x (inl j) = update (f ∘ inl) i x j",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq (Sum α β)]  {f : Sum α β → γ}  {i j : α}      {x : γ}"},
 {"type": "update f (inr i) x (inr j) = update (f ∘ inr) i x j",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq β]  [DecidableEq (Sum α β)]  {f : Sum α β → γ}  {i j : β}      {x : γ} : update f (inr i) x (inr j) = update (f ∘ inr) i x j := by rw [← update_inr_comp_inr]; sorry",
  "name": "update_inr_apply_inr",
  "kind": "theorem",
  "first-tactic": "rw [← update_inr_comp_inr]",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq β]  [DecidableEq (Sum α β)]  {f : Sum α β → γ}  {i j : β}      {x : γ} : update f (inr i) x (inr j) = update (f ∘ inr) i x j",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq β]  [DecidableEq (Sum α β)]  {f : Sum α β → γ}  {i j : β}      {x : γ}"},
 {"type": "swap (swap x) = x",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β) : swap (swap x) = x := by cases x; sorry",
  "name": "swap_swap",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β) : swap (swap x) = x",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β)"},
 {"type": "x.swap.isLeft = x.isRight",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β) : x.swap.isLeft = x.isRight := by cases x; sorry",
  "name": "isLeft_swap",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β) : x.swap.isLeft = x.isRight",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β)"},
 {"type": "x.swap.isRight = x.isLeft",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β) : x.swap.isRight = x.isLeft := by cases x; sorry",
  "name": "isRight_swap",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β) : x.swap.isRight = x.isLeft",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β)"},
 {"type": "x.swap.getLeft = x.getRight",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β) : x.swap.getLeft = x.getRight := by cases x; sorry",
  "name": "getLeft_swap",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β) : x.swap.getLeft = x.getRight",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β)"},
 {"type": "x.swap.getRight = x.getLeft",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β) : x.swap.getRight = x.getLeft := by cases x; sorry",
  "name": "getRight_swap",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β) : x.swap.getRight = x.getLeft",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β)"},
 {"type": "LiftRel r₂ s₂ x y",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → γ → Prop}  {s s₁ s₂ : β → δ → Prop}  {a : α}  {b : β}  {c : γ}  {d : δ}    {x : Sum α β}  {y : Sum γ δ} (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ a b, s₁ a b → s₂ a b)    (h : LiftRel r₁ s₁ x y) : LiftRel r₂ s₂ x y := by cases h; sorry",
  "name": "LiftRel.mono",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → γ → Prop}  {s s₁ s₂ : β → δ → Prop}  {a : α}  {b : β}  {c : γ}  {d : δ}    {x : Sum α β}  {y : Sum γ δ} (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ a b, s₁ a b → s₂ a b)    (h : LiftRel r₁ s₁ x y) : LiftRel r₂ s₂ x y",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → γ → Prop}  {s s₁ s₂ : β → δ → Prop}  {a : α}  {b : β}  {c : γ}  {d : δ}    {x : Sum α β}  {y : Sum γ δ} (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ a b, s₁ a b → s₂ a b)    (h : LiftRel r₁ s₁ x y)"},
 {"type": "LiftRel s r x.swap y.swap",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → γ → Prop}  {s s₁ s₂ : β → δ → Prop}  {a : α}  {b : β}  {c : γ}  {d : δ}    {x : Sum α β}  {y : Sum γ δ} (h : LiftRel r s x y) : LiftRel s r x.swap y.swap := by cases h; sorry",
  "name": "LiftRel.swap",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → γ → Prop}  {s s₁ s₂ : β → δ → Prop}  {a : α}  {b : β}  {c : γ}  {d : δ}    {x : Sum α β}  {y : Sum γ δ} (h : LiftRel r s x y) : LiftRel s r x.swap y.swap",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → γ → Prop}  {s s₁ s₂ : β → δ → Prop}  {a : α}  {b : β}  {c : γ}  {d : δ}    {x : Sum α β}  {y : Sum γ δ} (h : LiftRel r s x y)"},
 {"type": "Lex r s a b",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → α → Prop}  {s s₁ s₂ : β → β → Prop}  {a a₁ a₂ : α}  {b b₁ b₂ : β}    {x y : Sum α β} {a b : Sum α β}  (h : LiftRel r s a b) : Lex r s a b := by cases h; sorry",
  "name": "LiftRel.lex",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → α → Prop}  {s s₁ s₂ : β → β → Prop}  {a a₁ a₂ : α}  {b b₁ b₂ : β}    {x y : Sum α β} {a b : Sum α β}  (h : LiftRel r s a b) : Lex r s a b",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → α → Prop}  {s s₁ s₂ : β → β → Prop}  {a a₁ a₂ : α}  {b b₁ b₂ : β}    {x y : Sum α β} {a b : Sum α β}  (h : LiftRel r s a b)"},
 {"type": "Lex r₂ s₂ x y",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → α → Prop}  {s s₁ s₂ : β → β → Prop}  {a a₁ a₂ : α}  {b b₁ b₂ : β}    {x y : Sum α β} (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ a b, s₁ a b → s₂ a b)  (h : Lex r₁ s₁ x y) : Lex r₂ s₂ x y := by cases h; sorry",
  "name": "Lex.mono",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → α → Prop}  {s s₁ s₂ : β → β → Prop}  {a a₁ a₂ : α}  {b b₁ b₂ : β}    {x y : Sum α β} (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ a b, s₁ a b → s₂ a b)  (h : Lex r₁ s₁ x y) : Lex r₂ s₂ x y",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → α → Prop}  {s s₁ s₂ : β → β → Prop}  {a a₁ a₂ : α}  {b b₁ b₂ : β}    {x y : Sum α β} (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ a b, s₁ a b → s₂ a b)  (h : Lex r₁ s₁ x y)"},
 {"type": "Sum.elim (const _ c : α → γ) (const _ c : β → γ) = const _ c",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (c : γ) : Sum.elim (const _ c : α → γ) (const _ c : β → γ) = const _ c := by ext x; sorry",
  "name": "elim_const_const",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (c : γ) : Sum.elim (const _ c : α → γ) (const _ c : β → γ) = const _ c",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (c : γ)"},
 {"type":
  "Sum.elim (Function.update f i c) g = Function.update (Sum.elim f g) (inl i) c",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq β]  (f : α → γ)  (g : β → γ)  (i : α)  (c : γ) : Sum.elim (Function.update f i c) g = Function.update (Sum.elim f g) (inl i) c := by ext x; sorry",
  "name": "elim_update_left",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq β]  (f : α → γ)  (g : β → γ)  (i : α)  (c : γ) : Sum.elim (Function.update f i c) g = Function.update (Sum.elim f g) (inl i) c",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq β]  (f : α → γ)  (g : β → γ)  (i : α)  (c : γ)"},
 {"type":
  "Sum.elim f (Function.update g i c) = Function.update (Sum.elim f g) (inr i) c",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq β]  (f : α → γ)  (g : β → γ)  (i : β)  (c : γ) : Sum.elim f (Function.update g i c) = Function.update (Sum.elim f g) (inr i) c := by ext x; sorry",
  "name": "elim_update_right",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq β]  (f : α → γ)  (g : β → γ)  (i : β)  (c : γ) : Sum.elim f (Function.update g i c) = Function.update (Sum.elim f g) (inr i) c",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq β]  (f : α → γ)  (g : β → γ)  (i : β)  (c : γ)"},
 {"type": "BijOn (· + d) (Ici a) (Ici (a + d))",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (· + d) (Ici a) (Ici (a + d)) := by refine'\n    ⟨fun x h => add_le_add_right (mem_Ici.mp h) _, (add_left_injective d).injOn _, fun _ h => _⟩; sorry",
  "name": "Ici_add_bij",
  "kind": "theorem",
  "first-tactic":
  "refine'\n    ⟨fun x h => add_le_add_right (mem_Ici.mp h) _, (add_left_injective d).injOn _, fun _ h => _⟩",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (· + d) (Ici a) (Ici (a + d))",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "BijOn (· + d) (Ioi a) (Ioi (a + d))",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (· + d) (Ioi a) (Ioi (a + d)) := by refine'\n    ⟨fun x h => add_lt_add_right (mem_Ioi.mp h) _, fun _ _ _ _ h => add_right_cancel h, fun _ h =>\n      _⟩; sorry",
  "name": "Ioi_add_bij",
  "kind": "theorem",
  "first-tactic":
  "refine'\n    ⟨fun x h => add_lt_add_right (mem_Ioi.mp h) _, fun _ _ _ _ h => add_right_cancel h, fun _ h =>\n      _⟩",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (· + d) (Ioi a) (Ioi (a + d))",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "BijOn (· + d) (Icc a b) (Icc (a + d) (b + d))",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (· + d) (Icc a b) (Icc (a + d) (b + d)) := by rw [← Ici_inter_Iic]; sorry",
  "name": "Icc_add_bij",
  "kind": "theorem",
  "first-tactic": "rw [← Ici_inter_Iic]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (· + d) (Icc a b) (Icc (a + d) (b + d))",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "BijOn (· + d) (Ioo a b) (Ioo (a + d) (b + d))",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (· + d) (Ioo a b) (Ioo (a + d) (b + d)) := by rw [← Ioi_inter_Iio]; sorry",
  "name": "Ioo_add_bij",
  "kind": "theorem",
  "first-tactic": "rw [← Ioi_inter_Iio]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (· + d) (Ioo a b) (Ioo (a + d) (b + d))",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "BijOn (· + d) (Ioc a b) (Ioc (a + d) (b + d))",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (· + d) (Ioc a b) (Ioc (a + d) (b + d)) := by rw [← Ioi_inter_Iic]; sorry",
  "name": "Ioc_add_bij",
  "kind": "theorem",
  "first-tactic": "rw [← Ioi_inter_Iic]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (· + d) (Ioc a b) (Ioc (a + d) (b + d))",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "BijOn (· + d) (Ico a b) (Ico (a + d) (b + d))",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (· + d) (Ico a b) (Ico (a + d) (b + d)) := by rw [← Ici_inter_Iio]; sorry",
  "name": "Ico_add_bij",
  "kind": "theorem",
  "first-tactic": "rw [← Ici_inter_Iio]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (· + d) (Ico a b) (Ico (a + d) (b + d))",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "(fun x => a + x) '' Ici b = Ici (a + b)",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ici b = Ici (a + b) := by simp only [add_comm a]; sorry",
  "name": "image_const_add_Ici",
  "kind": "theorem",
  "first-tactic": "simp only [add_comm a]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ici b = Ici (a + b)",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "(fun x => a + x) '' Ioi b = Ioi (a + b)",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ioi b = Ioi (a + b) := by simp only [add_comm a]; sorry",
  "name": "image_const_add_Ioi",
  "kind": "theorem",
  "first-tactic": "simp only [add_comm a]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ioi b = Ioi (a + b)",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "(fun x => a + x) '' Icc b c = Icc (a + b) (a + c)",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Icc b c = Icc (a + b) (a + c) := by simp only [add_comm a]; sorry",
  "name": "image_const_add_Icc",
  "kind": "theorem",
  "first-tactic": "simp only [add_comm a]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Icc b c = Icc (a + b) (a + c)",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "(fun x => a + x) '' Ico b c = Ico (a + b) (a + c)",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ico b c = Ico (a + b) (a + c) := by simp only [add_comm a]; sorry",
  "name": "image_const_add_Ico",
  "kind": "theorem",
  "first-tactic": "simp only [add_comm a]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ico b c = Ico (a + b) (a + c)",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "(fun x => a + x) '' Ioc b c = Ioc (a + b) (a + c)",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ioc b c = Ioc (a + b) (a + c) := by simp only [add_comm a]; sorry",
  "name": "image_const_add_Ioc",
  "kind": "theorem",
  "first-tactic": "simp only [add_comm a]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ioc b c = Ioc (a + b) (a + c)",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "(fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c)",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) := by simp only [add_comm a]; sorry",
  "name": "image_const_add_Ioo",
  "kind": "theorem",
  "first-tactic": "simp only [add_comm a]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c)",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "SurjOn f (Ioo a b) (Ioo (f a) (f b))",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : α) : SurjOn f (Ioo a b) (Ioo (f a) (f b)) := by intro p hp; sorry",
  "name": "surjOn_Ioo_of_monotone_surjective",
  "kind": "theorem",
  "first-tactic": "intro p hp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : α) : SurjOn f (Ioo a b) (Ioo (f a) (f b))",
  "args":
  "{α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : α)"},
 {"type": "SurjOn f (Ico a b) (Ico (f a) (f b))",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : α) : SurjOn f (Ico a b) (Ico (f a) (f b)) := by obtain hab | hab := lt_or_le a b; sorry",
  "name": "surjOn_Ico_of_monotone_surjective",
  "kind": "theorem",
  "first-tactic": "obtain hab | hab := lt_or_le a b",
  "core-prompt":
  "{α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : α) : SurjOn f (Ico a b) (Ico (f a) (f b))",
  "args":
  "{α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : α)"},
 {"type": "SurjOn f (Ioc a b) (Ioc (f a) (f b))",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : α) : SurjOn f (Ioc a b) (Ioc (f a) (f b)) := by simpa using surjOn_Ico_of_monotone_surjective h_mono.dual h_surj (toDual b) (toDual a); sorry",
  "name": "surjOn_Ioc_of_monotone_surjective",
  "kind": "theorem",
  "first-tactic":
  "simpa using surjOn_Ico_of_monotone_surjective h_mono.dual h_surj (toDual b) (toDual a)",
  "core-prompt":
  "{α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : α) : SurjOn f (Ioc a b) (Ioc (f a) (f b))",
  "args":
  "{α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : α)"},
 {"type": "SurjOn f (Icc a b) (Icc (f a) (f b))",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      {a b : α}  (hab : a ≤ b) : SurjOn f (Icc a b) (Icc (f a) (f b)) := by intro p hp; sorry",
  "name": "surjOn_Icc_of_monotone_surjective",
  "kind": "theorem",
  "first-tactic": "intro p hp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      {a b : α}  (hab : a ≤ b) : SurjOn f (Icc a b) (Icc (f a) (f b))",
  "args":
  "{α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      {a b : α}  (hab : a ≤ b)"},
 {"type": "SurjOn f (Ioi a) (Ioi (f a))",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a : α) : SurjOn f (Ioi a) (Ioi (f a)) := by rw [← compl_Iic]; sorry",
  "name": "surjOn_Ioi_of_monotone_surjective",
  "kind": "theorem",
  "first-tactic": "rw [← compl_Iic]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a : α) : SurjOn f (Ioi a) (Ioi (f a))",
  "args":
  "{α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a : α)"},
 {"type": "SurjOn f (Ici a) (Ici (f a))",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a : α) : SurjOn f (Ici a) (Ici (f a)) := by rw [← Ioi_union_left]; sorry",
  "name": "surjOn_Ici_of_monotone_surjective",
  "kind": "theorem",
  "first-tactic": "rw [← Ioi_union_left]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a : α) : SurjOn f (Ici a) (Ici (f a))",
  "args":
  "{α : Type _}  {β : Type _}  [LinearOrder α]  [PartialOrder β]  {f : α → β} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a : α)"},
 {"type": "Decidable (x ∈ Ioo a b)",
  "tactic-prompt":
  "instance {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a < x ∧ x < b)] : Decidable (x ∈ Ioo a b) := by assumption; sorry",
  "name": "decidableMemIoo",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a < x ∧ x < b)] : Decidable (x ∈ Ioo a b)",
  "args":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a < x ∧ x < b)]"},
 {"type": "Decidable (x ∈ Ico a b)",
  "tactic-prompt":
  "instance {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a ≤ x ∧ x < b)] : Decidable (x ∈ Ico a b) := by assumption; sorry",
  "name": "decidableMemIco",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a ≤ x ∧ x < b)] : Decidable (x ∈ Ico a b)",
  "args":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a ≤ x ∧ x < b)]"},
 {"type": "Decidable (x ∈ Iio b)",
  "tactic-prompt":
  "instance {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (x < b)] : Decidable (x ∈ Iio b) := by assumption; sorry",
  "name": "decidableMemIio",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (x < b)] : Decidable (x ∈ Iio b)",
  "args":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (x < b)]"},
 {"type": "Decidable (x ∈ Icc a b)",
  "tactic-prompt":
  "instance {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a ≤ x ∧ x ≤ b)] : Decidable (x ∈ Icc a b) := by assumption; sorry",
  "name": "decidableMemIcc",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a ≤ x ∧ x ≤ b)] : Decidable (x ∈ Icc a b)",
  "args":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a ≤ x ∧ x ≤ b)]"},
 {"type": "Decidable (x ∈ Iic b)",
  "tactic-prompt":
  "instance {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (x ≤ b)] : Decidable (x ∈ Iic b) := by assumption; sorry",
  "name": "decidableMemIic",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (x ≤ b)] : Decidable (x ∈ Iic b)",
  "args":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (x ≤ b)]"},
 {"type": "Decidable (x ∈ Ioc a b)",
  "tactic-prompt":
  "instance {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a < x ∧ x ≤ b)] : Decidable (x ∈ Ioc a b) := by assumption; sorry",
  "name": "decidableMemIoc",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a < x ∧ x ≤ b)] : Decidable (x ∈ Ioc a b)",
  "args":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a < x ∧ x ≤ b)]"},
 {"type": "Decidable (x ∈ Ici a)",
  "tactic-prompt":
  "instance {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a ≤ x)] : Decidable (x ∈ Ici a) := by assumption; sorry",
  "name": "decidableMemIci",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a ≤ x)] : Decidable (x ∈ Ici a)",
  "args":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a ≤ x)]"},
 {"type": "Decidable (x ∈ Ioi a)",
  "tactic-prompt":
  "instance {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a < x)] : Decidable (x ∈ Ioi a) := by assumption; sorry",
  "name": "decidableMemIoi",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a < x)] : Decidable (x ∈ Ioi a)",
  "args":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [Decidable (a < x)]"},
 {"type": "a ∈ Ioo a b ↔ False",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Ioo a b ↔ False := by simp [lt_irrefl]; sorry",
  "name": "left_mem_Ioo",
  "kind": "theorem",
  "first-tactic": "simp [lt_irrefl]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Ioo a b ↔ False",
  "args": "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "a ∈ Ico a b ↔ a < b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Ico a b ↔ a < b := by simp [le_refl]; sorry",
  "name": "left_mem_Ico",
  "kind": "theorem",
  "first-tactic": "simp [le_refl]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Ico a b ↔ a < b",
  "args": "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "a ∈ Icc a b ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Icc a b ↔ a ≤ b := by simp [le_refl]; sorry",
  "name": "left_mem_Icc",
  "kind": "theorem",
  "first-tactic": "simp [le_refl]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Icc a b ↔ a ≤ b",
  "args": "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "a ∈ Ioc a b ↔ False",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Ioc a b ↔ False := by simp [lt_irrefl]; sorry",
  "name": "left_mem_Ioc",
  "kind": "theorem",
  "first-tactic": "simp [lt_irrefl]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Ioc a b ↔ False",
  "args": "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "a ∈ Ici a",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Ici a := by simp; sorry",
  "name": "left_mem_Ici",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Ici a",
  "args": "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "b ∈ Ioo a b ↔ False",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : b ∈ Ioo a b ↔ False := by simp [lt_irrefl]; sorry",
  "name": "right_mem_Ioo",
  "kind": "theorem",
  "first-tactic": "simp [lt_irrefl]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : b ∈ Ioo a b ↔ False",
  "args": "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "b ∈ Ico a b ↔ False",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : b ∈ Ico a b ↔ False := by simp [lt_irrefl]; sorry",
  "name": "right_mem_Ico",
  "kind": "theorem",
  "first-tactic": "simp [lt_irrefl]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : b ∈ Ico a b ↔ False",
  "args": "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "b ∈ Icc a b ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : b ∈ Icc a b ↔ a ≤ b := by simp [le_refl]; sorry",
  "name": "right_mem_Icc",
  "kind": "theorem",
  "first-tactic": "simp [le_refl]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : b ∈ Icc a b ↔ a ≤ b",
  "args": "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "b ∈ Ioc a b ↔ a < b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : b ∈ Ioc a b ↔ a < b := by simp [le_refl]; sorry",
  "name": "right_mem_Ioc",
  "kind": "theorem",
  "first-tactic": "simp [le_refl]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : b ∈ Ioc a b ↔ a < b",
  "args": "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "a ∈ Iic a",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Iic a := by simp; sorry",
  "name": "right_mem_Iic",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Iic a",
  "args": "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "Icc a b = ∅ ↔ ¬a ≤ b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : Icc a b = ∅ ↔ ¬a ≤ b := by rw [← not_nonempty_iff_eq_empty]; sorry",
  "name": "Icc_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "rw [← not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : Icc a b = ∅ ↔ ¬a ≤ b",
  "args": "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "Ico a b = ∅ ↔ ¬a < b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : Ico a b = ∅ ↔ ¬a < b := by rw [← not_nonempty_iff_eq_empty]; sorry",
  "name": "Ico_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "rw [← not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : Ico a b = ∅ ↔ ¬a < b",
  "args": "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "Ioc a b = ∅ ↔ ¬a < b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : Ioc a b = ∅ ↔ ¬a < b := by rw [← not_nonempty_iff_eq_empty]; sorry",
  "name": "Ioc_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "rw [← not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} : Ioc a b = ∅ ↔ ¬a < b",
  "args": "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "Ioo a b = ∅ ↔ ¬a < b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [DenselyOrdered α] : Ioo a b = ∅ ↔ ¬a < b := by rw [← not_nonempty_iff_eq_empty]; sorry",
  "name": "Ioo_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "rw [← not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [DenselyOrdered α] : Ioo a b = ∅ ↔ ¬a < b",
  "args":
  "{α β : Type _}  [Preorder α]  {a a₁ a₂ b b₁ b₂ c x : α} [DenselyOrdered α]"},
 {"type": "Icc a b = {c} ↔ a = c ∧ b = c",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} : Icc a b = {c} ↔ a = c ∧ b = c := by refine' ⟨fun h => _, _⟩; sorry",
  "name": "Icc_eq_singleton_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, _⟩",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} : Icc a b = {c} ↔ a = c ∧ b = c",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α}"},
 {"type": "Icc a b \\ {a, b} = Ioo a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} : Icc a b \\ {a, b} = Ioo a b := by rw [insert_eq]; sorry",
  "name": "Icc_diff_both",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} : Icc a b \\ {a, b} = Ioo a b",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α}"},
 {"type": "Ico a b \\ Ioo a b = {a}",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} (h : a < b) : Ico a b \\ Ioo a b = {a} := by rw [← Ico_diff_left]; sorry",
  "name": "Ico_diff_Ioo_same",
  "kind": "theorem",
  "first-tactic": "rw [← Ico_diff_left]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a < b) : Ico a b \\ Ioo a b = {a}",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a < b)"},
 {"type": "Ioc a b \\ Ioo a b = {b}",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} (h : a < b) : Ioc a b \\ Ioo a b = {b} := by rw [← Ioc_diff_right]; sorry",
  "name": "Ioc_diff_Ioo_same",
  "kind": "theorem",
  "first-tactic": "rw [← Ioc_diff_right]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a < b) : Ioc a b \\ Ioo a b = {b}",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a < b)"},
 {"type": "Icc a b \\ Ico a b = {b}",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} (h : a ≤ b) : Icc a b \\ Ico a b = {b} := by rw [← Icc_diff_right]; sorry",
  "name": "Icc_diff_Ico_same",
  "kind": "theorem",
  "first-tactic": "rw [← Icc_diff_right]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a ≤ b) : Icc a b \\ Ico a b = {b}",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a ≤ b)"},
 {"type": "Icc a b \\ Ioc a b = {a}",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} (h : a ≤ b) : Icc a b \\ Ioc a b = {a} := by rw [← Icc_diff_left]; sorry",
  "name": "Icc_diff_Ioc_same",
  "kind": "theorem",
  "first-tactic": "rw [← Icc_diff_left]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a ≤ b) : Icc a b \\ Ioc a b = {a}",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a ≤ b)"},
 {"type": "Icc a b \\ Ioo a b = {a, b}",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} (h : a ≤ b) : Icc a b \\ Ioo a b = {a, b} := by rw [← Icc_diff_both]; sorry",
  "name": "Icc_diff_Ioo_same",
  "kind": "theorem",
  "first-tactic": "rw [← Icc_diff_both]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a ≤ b) : Icc a b \\ Ioo a b = {a, b}",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a ≤ b)"},
 {"type": "Ici a \\ Ioi a = {a}",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} : Ici a \\ Ioi a = {a} := by rw [← Ici_diff_left]; sorry",
  "name": "Ici_diff_Ioi_same",
  "kind": "theorem",
  "first-tactic": "rw [← Ici_diff_left]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} : Ici a \\ Ioi a = {a}",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α}"},
 {"type": "Iic a \\ Iio a = {a}",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} : Iic a \\ Iio a = {a} := by rw [← Iic_diff_right]; sorry",
  "name": "Iic_diff_Iio_same",
  "kind": "theorem",
  "first-tactic": "rw [← Iic_diff_right]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} : Iic a \\ Iio a = {a}",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α}"},
 {"type": "Ioo a b ∪ {a} = Ico a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} (hab : a < b) : Ioo a b ∪ {a} = Ico a b := by rw [← Ico_diff_left]; sorry",
  "name": "Ioo_union_left",
  "kind": "theorem",
  "first-tactic": "rw [← Ico_diff_left]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} (hab : a < b) : Ioo a b ∪ {a} = Ico a b",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α} (hab : a < b)"},
 {"type": "Ioo a b ∪ {b} = Ioc a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} (hab : a < b) : Ioo a b ∪ {b} = Ioc a b := by simpa only [dual_Ioo]; sorry",
  "name": "Ioo_union_right",
  "kind": "theorem",
  "first-tactic": "simpa only [dual_Ioo]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} (hab : a < b) : Ioo a b ∪ {b} = Ioc a b",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α} (hab : a < b)"},
 {"type": "Ioc a b ∪ {a} = Icc a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} (hab : a ≤ b) : Ioc a b ∪ {a} = Icc a b := by rw [← Icc_diff_left]; sorry",
  "name": "Ioc_union_left",
  "kind": "theorem",
  "first-tactic": "rw [← Icc_diff_left]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} (hab : a ≤ b) : Ioc a b ∪ {a} = Icc a b",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α} (hab : a ≤ b)"},
 {"type": "Ico a b ∪ {b} = Icc a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} (hab : a ≤ b) : Ico a b ∪ {b} = Icc a b := by simpa only [dual_Ioc]; sorry",
  "name": "Ico_union_right",
  "kind": "theorem",
  "first-tactic": "simpa only [dual_Ioc]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} (hab : a ≤ b) : Ico a b ∪ {b} = Icc a b",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α} (hab : a ≤ b)"},
 {"type": "insert b (Ico a b) = Icc a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} (h : a ≤ b) : insert b (Ico a b) = Icc a b := by rw [insert_eq]; sorry",
  "name": "Ico_insert_right",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a ≤ b) : insert b (Ico a b) = Icc a b",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a ≤ b)"},
 {"type": "insert a (Ioc a b) = Icc a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} (h : a ≤ b) : insert a (Ioc a b) = Icc a b := by rw [insert_eq]; sorry",
  "name": "Ioc_insert_left",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a ≤ b) : insert a (Ioc a b) = Icc a b",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a ≤ b)"},
 {"type": "insert a (Ioo a b) = Ico a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} (h : a < b) : insert a (Ioo a b) = Ico a b := by rw [insert_eq]; sorry",
  "name": "Ioo_insert_left",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a < b) : insert a (Ioo a b) = Ico a b",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a < b)"},
 {"type": "insert b (Ioo a b) = Ioc a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} (h : a < b) : insert b (Ioo a b) = Ioc a b := by rw [insert_eq]; sorry",
  "name": "Ioo_insert_right",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a < b) : insert b (Ioo a b) = Ioc a b",
  "args": "{α β : Type _}  [PartialOrder α]  {a b c : α} (h : a < b)"},
 {"type": "s ∈ ({Icc a b, Ico a b, Ioc a b, Ioo a b} : Set (Set α))",
  "tactic-prompt":
  "theorem {α β : Type _}  [PartialOrder α]  {a b c : α} {s : Set α}  (ho : Ioo a b ⊆ s)  (hc : s ⊆ Icc a b) : s ∈ ({Icc a b, Ico a b, Ioc a b, Ioo a b} : Set (Set α)) := by classical\n    by_cases ha : a ∈ s; sorry",
  "name": "mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset",
  "kind": "theorem",
  "first-tactic": "classical\n    by_cases ha : a ∈ s",
  "core-prompt":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} {s : Set α}  (ho : Ioo a b ⊆ s)  (hc : s ⊆ Icc a b) : s ∈ ({Icc a b, Ico a b, Ioc a b, Ioo a b} : Set (Set α))",
  "args":
  "{α β : Type _}  [PartialOrder α]  {a b c : α} {s : Set α}  (ho : Ioo a b ⊆ s)  (hc : s ⊆ Icc a b)"},
 {"type": "Icc a ⊤ = Ici a",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  [OrderTop α]  {a : α} : Icc a ⊤ = Ici a := by simp [← Ici_inter_Iic]; sorry",
  "name": "Icc_top",
  "kind": "theorem",
  "first-tactic": "simp [← Ici_inter_Iic]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  [OrderTop α]  {a : α} : Icc a ⊤ = Ici a",
  "args": "{α β : Type _}  [Preorder α]  [OrderTop α]  {a : α}"},
 {"type": "Ioc a ⊤ = Ioi a",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  [OrderTop α]  {a : α} : Ioc a ⊤ = Ioi a := by simp [← Ioi_inter_Iic]; sorry",
  "name": "Ioc_top",
  "kind": "theorem",
  "first-tactic": "simp [← Ioi_inter_Iic]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  [OrderTop α]  {a : α} : Ioc a ⊤ = Ioi a",
  "args": "{α β : Type _}  [Preorder α]  [OrderTop α]  {a : α}"},
 {"type": "Icc ⊥ a = Iic a",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  [OrderBot α]  {a : α} : Icc ⊥ a = Iic a := by simp [← Ici_inter_Iic]; sorry",
  "name": "Icc_bot",
  "kind": "theorem",
  "first-tactic": "simp [← Ici_inter_Iic]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  [OrderBot α]  {a : α} : Icc ⊥ a = Iic a",
  "args": "{α β : Type _}  [Preorder α]  [OrderBot α]  {a : α}"},
 {"type": "Ico ⊥ a = Iio a",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  [OrderBot α]  {a : α} : Ico ⊥ a = Iio a := by simp [← Ici_inter_Iio]; sorry",
  "name": "Ico_bot",
  "kind": "theorem",
  "first-tactic": "simp [← Ici_inter_Iio]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  [OrderBot α]  {a : α} : Ico ⊥ a = Iio a",
  "args": "{α β : Type _}  [Preorder α]  [OrderBot α]  {a : α}"},
 {"type": "Icc (⊥ : α) ⊤ = univ",
  "tactic-prompt":
  "theorem {α β : Type _} [PartialOrder α]  [BoundedOrder α] : Icc (⊥ : α) ⊤ = univ := by simp; sorry",
  "name": "Icc_bot_top",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β : Type _} [PartialOrder α]  [BoundedOrder α] : Icc (⊥ : α) ⊤ = univ",
  "args": "{α β : Type _} [PartialOrder α]  [BoundedOrder α]"},
 {"type": "Ici a \\ Ici b = Ico a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Ici a \\ Ici b = Ico a b := by rw [diff_eq]; sorry",
  "name": "Ici_diff_Ici",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Ici a \\ Ici b = Ico a b",
  "args": "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Ici a \\ Ioi b = Icc a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Ici a \\ Ioi b = Icc a b := by rw [diff_eq]; sorry",
  "name": "Ici_diff_Ioi",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Ici a \\ Ioi b = Icc a b",
  "args": "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Ioi a \\ Ioi b = Ioc a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Ioi a \\ Ioi b = Ioc a b := by rw [diff_eq]; sorry",
  "name": "Ioi_diff_Ioi",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Ioi a \\ Ioi b = Ioc a b",
  "args": "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Ioi a \\ Ici b = Ioo a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Ioi a \\ Ici b = Ioo a b := by rw [diff_eq]; sorry",
  "name": "Ioi_diff_Ici",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Ioi a \\ Ici b = Ioo a b",
  "args": "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Iic b \\ Iic a = Ioc a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Iic b \\ Iic a = Ioc a b := by rw [diff_eq]; sorry",
  "name": "Iic_diff_Iic",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Iic b \\ Iic a = Ioc a b",
  "args": "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Iio b \\ Iic a = Ioo a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Iio b \\ Iic a = Ioo a b := by rw [diff_eq]; sorry",
  "name": "Iio_diff_Iic",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Iio b \\ Iic a = Ioo a b",
  "args": "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Iic b \\ Iio a = Icc a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Iic b \\ Iio a = Icc a b := by rw [diff_eq]; sorry",
  "name": "Iic_diff_Iio",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Iic b \\ Iio a = Icc a b",
  "args": "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Iio b \\ Iio a = Ico a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Iio b \\ Iio a = Ico a b := by rw [diff_eq]; sorry",
  "name": "Iio_diff_Iio",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Iio b \\ Iio a = Ico a b",
  "args": "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Ioc a₁ b₁ ⊆ Ioc a₂ b₂ ↔ b₁ ≤ b₂ ∧ a₂ ≤ a₁",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : a₁ < b₁) : Ioc a₁ b₁ ⊆ Ioc a₂ b₂ ↔ b₁ ≤ b₂ ∧ a₂ ≤ a₁ := by convert @Ico_subset_Ico_iff αᵒᵈ _ b₁ b₂ a₁ a₂ h₁; sorry",
  "name": "Ioc_subset_Ioc_iff",
  "kind": "theorem",
  "first-tactic": "convert @Ico_subset_Ico_iff αᵒᵈ _ b₁ b₂ a₁ a₂ h₁",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : a₁ < b₁) : Ioc a₁ b₁ ⊆ Ioc a₂ b₂ ↔ b₁ ≤ b₂ ∧ a₂ ≤ a₁",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : a₁ < b₁)"},
 {"type": "Ioi b ⊆ Ioi a ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Ioi b ⊆ Ioi a ↔ a ≤ b := by refine' ⟨fun h => _, fun h => Ioi_subset_Ioi h⟩; sorry",
  "name": "Ioi_subset_Ioi_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, fun h => Ioi_subset_Ioi h⟩",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Ioi b ⊆ Ioi a ↔ a ≤ b",
  "args": "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Ioi b ⊆ Ici a ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} [DenselyOrdered α] : Ioi b ⊆ Ici a ↔ a ≤ b := by refine' ⟨fun h => _, fun h => Ioi_subset_Ici h⟩; sorry",
  "name": "Ioi_subset_Ici_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, fun h => Ioi_subset_Ici h⟩",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} [DenselyOrdered α] : Ioi b ⊆ Ici a ↔ a ≤ b",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} [DenselyOrdered α]"},
 {"type": "Iio a ⊆ Iio b ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Iio a ⊆ Iio b ↔ a ≤ b := by refine' ⟨fun h => _, fun h => Iio_subset_Iio h⟩; sorry",
  "name": "Iio_subset_Iio_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, fun h => Iio_subset_Iio h⟩",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} : Iio a ⊆ Iio b ↔ a ≤ b",
  "args": "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Iio a ⊆ Iic b ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} [DenselyOrdered α] : Iio a ⊆ Iic b ↔ a ≤ b := by rw [← diff_eq_empty]; sorry",
  "name": "Iio_subset_Iic_iff",
  "kind": "theorem",
  "first-tactic": "rw [← diff_eq_empty]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} [DenselyOrdered α] : Iio a ⊆ Iic b ↔ a ≤ b",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} [DenselyOrdered α]"},
 {"type": "Ioo a b ∪ Ioi c = Ioi (min a c)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c < b) : Ioo a b ∪ Ioi c = Ioi (min a c) := by ext1 x; sorry",
  "name": "Ioo_union_Ioi'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c < b) : Ioo a b ∪ Ioi c = Ioi (min a c)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c < b)"},
 {"type": "Ioo a b ∪ Ioi c = Ioi (min a c)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : c < max a b) : Ioo a b ∪ Ioi c = Ioi (min a c) := by cases' le_total a b with hab hab; sorry",
  "name": "Ioo_union_Ioi",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with hab hab",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : c < max a b) : Ioo a b ∪ Ioi c = Ioi (min a c)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : c < max a b)"},
 {"type": "Ico a b ∪ Ici c = Ici (min a c)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b) : Ico a b ∪ Ici c = Ici (min a c) := by ext1 x; sorry",
  "name": "Ico_union_Ici'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b) : Ico a b ∪ Ici c = Ici (min a c)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b)"},
 {"type": "Ico a b ∪ Ici c = Ici (min a c)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : c ≤ max a b) : Ico a b ∪ Ici c = Ici (min a c) := by cases' le_total a b with hab hab; sorry",
  "name": "Ico_union_Ici",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with hab hab",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : c ≤ max a b) : Ico a b ∪ Ici c = Ici (min a c)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : c ≤ max a b)"},
 {"type": "Ioc a b ∪ Ioi c = Ioi (min a c)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b) : Ioc a b ∪ Ioi c = Ioi (min a c) := by ext1 x; sorry",
  "name": "Ioc_union_Ioi'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b) : Ioc a b ∪ Ioi c = Ioi (min a c)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b)"},
 {"type": "Ioc a b ∪ Ioi c = Ioi (min a c)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : c ≤ max a b) : Ioc a b ∪ Ioi c = Ioi (min a c) := by cases' le_total a b with hab hab; sorry",
  "name": "Ioc_union_Ioi",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with hab hab",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : c ≤ max a b) : Ioc a b ∪ Ioi c = Ioi (min a c)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : c ≤ max a b)"},
 {"type": "Icc a b ∪ Ici c = Ici (min a c)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b) : Icc a b ∪ Ici c = Ici (min a c) := by ext1 x; sorry",
  "name": "Icc_union_Ici'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b) : Icc a b ∪ Ici c = Ici (min a c)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b)"},
 {"type": "Icc a b ∪ Ici c = Ici (min a c)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : c ≤ max a b) : Icc a b ∪ Ici c = Ici (min a c) := by cases' le_or_lt a b with hab hab; sorry",
  "name": "Icc_union_Ici",
  "kind": "theorem",
  "first-tactic": "cases' le_or_lt a b with hab hab",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : c ≤ max a b) : Icc a b ∪ Ici c = Ici (min a c)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : c ≤ max a b)"},
 {"type": "Iio b ∪ Ico c d = Iio (max b d)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b) : Iio b ∪ Ico c d = Iio (max b d) := by ext1 x; sorry",
  "name": "Iio_union_Ico'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b) : Iio b ∪ Ico c d = Iio (max b d)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b)"},
 {"type": "Iio b ∪ Ico c d = Iio (max b d)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : min c d ≤ b) : Iio b ∪ Ico c d = Iio (max b d) := by cases' le_total c d with hcd hcd; sorry",
  "name": "Iio_union_Ico",
  "kind": "theorem",
  "first-tactic": "cases' le_total c d with hcd hcd",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : min c d ≤ b) : Iio b ∪ Ico c d = Iio (max b d)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : min c d ≤ b)"},
 {"type": "Iic b ∪ Ioc c d = Iic (max b d)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c < b) : Iic b ∪ Ioc c d = Iic (max b d) := by ext1 x; sorry",
  "name": "Iic_union_Ioc'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c < b) : Iic b ∪ Ioc c d = Iic (max b d)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c < b)"},
 {"type": "Iic b ∪ Ioc c d = Iic (max b d)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : min c d < b) : Iic b ∪ Ioc c d = Iic (max b d) := by cases' le_total c d with hcd hcd; sorry",
  "name": "Iic_union_Ioc",
  "kind": "theorem",
  "first-tactic": "cases' le_total c d with hcd hcd",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : min c d < b) : Iic b ∪ Ioc c d = Iic (max b d)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : min c d < b)"},
 {"type": "Iio b ∪ Ioo c d = Iio (max b d)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c < b) : Iio b ∪ Ioo c d = Iio (max b d) := by ext x; sorry",
  "name": "Iio_union_Ioo'",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c < b) : Iio b ∪ Ioo c d = Iio (max b d)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c < b)"},
 {"type": "Iio b ∪ Ioo c d = Iio (max b d)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : min c d < b) : Iio b ∪ Ioo c d = Iio (max b d) := by cases' le_total c d with hcd hcd; sorry",
  "name": "Iio_union_Ioo",
  "kind": "theorem",
  "first-tactic": "cases' le_total c d with hcd hcd",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : min c d < b) : Iio b ∪ Ioo c d = Iio (max b d)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : min c d < b)"},
 {"type": "Iic b ∪ Icc c d = Iic (max b d)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b) : Iic b ∪ Icc c d = Iic (max b d) := by ext1 x; sorry",
  "name": "Iic_union_Icc'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b) : Iic b ∪ Icc c d = Iic (max b d)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b)"},
 {"type": "Iic b ∪ Icc c d = Iic (max b d)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : min c d ≤ b) : Iic b ∪ Icc c d = Iic (max b d) := by cases' le_or_lt c d with hcd hcd; sorry",
  "name": "Iic_union_Icc",
  "kind": "theorem",
  "first-tactic": "cases' le_or_lt c d with hcd hcd",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : min c d ≤ b) : Iic b ∪ Icc c d = Iic (max b d)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h : min c d ≤ b)"},
 {"type": "Ico a b ∪ Ico c d = Ico (min a c) (max b d)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b)  (h₂ : a ≤ d) : Ico a b ∪ Ico c d = Ico (min a c) (max b d) := by ext1 x; sorry",
  "name": "Ico_union_Ico'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b)  (h₂ : a ≤ d) : Ico a b ∪ Ico c d = Ico (min a c) (max b d)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b)  (h₂ : a ≤ d)"},
 {"type": "Ico a b ∪ Ico c d = Ico (min a c) (max b d)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : min a b ≤ max c d)  (h₂ : min c d ≤ max a b) : Ico a b ∪ Ico c d = Ico (min a c) (max b d) := by cases' le_total a b with hab hab; sorry",
  "name": "Ico_union_Ico",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with hab hab",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : min a b ≤ max c d)  (h₂ : min c d ≤ max a b) : Ico a b ∪ Ico c d = Ico (min a c) (max b d)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : min a b ≤ max c d)  (h₂ : min c d ≤ max a b)"},
 {"type": "Ioc a b ∪ Ioc c d = Ioc (min a c) (max b d)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b)  (h₂ : a ≤ d) : Ioc a b ∪ Ioc c d = Ioc (min a c) (max b d) := by ext1 x; sorry",
  "name": "Ioc_union_Ioc'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b)  (h₂ : a ≤ d) : Ioc a b ∪ Ioc c d = Ioc (min a c) (max b d)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b)  (h₂ : a ≤ d)"},
 {"type": "Ioc a b ∪ Ioc c d = Ioc (min a c) (max b d)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : min a b ≤ max c d)  (h₂ : min c d ≤ max a b) : Ioc a b ∪ Ioc c d = Ioc (min a c) (max b d) := by cases' le_total a b with hab hab; sorry",
  "name": "Ioc_union_Ioc",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with hab hab",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : min a b ≤ max c d)  (h₂ : min c d ≤ max a b) : Ioc a b ∪ Ioc c d = Ioc (min a c) (max b d)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : min a b ≤ max c d)  (h₂ : min c d ≤ max a b)"},
 {"type": "Icc a b ∪ Icc c d = Icc (min a c) (max b d)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b)  (h₂ : a ≤ d) : Icc a b ∪ Icc c d = Icc (min a c) (max b d) := by ext1 x; sorry",
  "name": "Icc_union_Icc'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b)  (h₂ : a ≤ d) : Icc a b ∪ Icc c d = Icc (min a c) (max b d)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c ≤ b)  (h₂ : a ≤ d)"},
 {"type": "Icc a b ∪ Icc c d = Icc (min a c) (max b d)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : min a b < max c d)  (h₂ : min c d < max a b) : Icc a b ∪ Icc c d = Icc (min a c) (max b d) := by cases' le_or_lt a b with hab hab; sorry",
  "name": "Icc_union_Icc",
  "kind": "theorem",
  "first-tactic": "cases' le_or_lt a b with hab hab",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : min a b < max c d)  (h₂ : min c d < max a b) : Icc a b ∪ Icc c d = Icc (min a c) (max b d)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : min a b < max c d)  (h₂ : min c d < max a b)"},
 {"type": "Ioo a b ∪ Ioo c d = Ioo (min a c) (max b d)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c < b)  (h₂ : a < d) : Ioo a b ∪ Ioo c d = Ioo (min a c) (max b d) := by ext1 x; sorry",
  "name": "Ioo_union_Ioo'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c < b)  (h₂ : a < d) : Ioo a b ∪ Ioo c d = Ioo (min a c) (max b d)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : c < b)  (h₂ : a < d)"},
 {"type": "Ioo a b ∪ Ioo c d = Ioo (min a c) (max b d)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : min a b < max c d)  (h₂ : min c d < max a b) : Ioo a b ∪ Ioo c d = Ioo (min a c) (max b d) := by cases' le_total a b with hab hab; sorry",
  "name": "Ioo_union_Ioo",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with hab hab",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : min a b < max c d)  (h₂ : min c d < max a b) : Ioo a b ∪ Ioo c d = Ioo (min a c) (max b d)",
  "args":
  "{α β : Type _}  [LinearOrder α]  {a a₁ a₂ b b₁ b₂ c d : α} (h₁ : min a b < max c d)  (h₂ : min c d < max a b)"},
 {"type": "Iic a ∩ Iic b = Iic (a ⊓ b)",
  "tactic-prompt":
  "theorem {α β : Type _}   [SemilatticeInf α] {a b : α} : Iic a ∩ Iic b = Iic (a ⊓ b) := by ext x; sorry",
  "name": "Iic_inter_Iic",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β : Type _}   [SemilatticeInf α] {a b : α} : Iic a ∩ Iic b = Iic (a ⊓ b)",
  "args": "{α β : Type _}   [SemilatticeInf α] {a b : α}"},
 {"type": "Ioc a b ∩ Iic c = Ioc a (b ⊓ c)",
  "tactic-prompt":
  "theorem {α β : Type _}   [SemilatticeInf α] (a b c : α) : Ioc a b ∩ Iic c = Ioc a (b ⊓ c) := by rw [← Ioi_inter_Iic]; sorry",
  "name": "Ioc_inter_Iic",
  "kind": "theorem",
  "first-tactic": "rw [← Ioi_inter_Iic]",
  "core-prompt":
  "{α β : Type _}   [SemilatticeInf α] (a b c : α) : Ioc a b ∩ Iic c = Ioc a (b ⊓ c)",
  "args": "{α β : Type _}   [SemilatticeInf α] (a b c : α)"},
 {"type": "Ici a ∩ Ici b = Ici (a ⊔ b)",
  "tactic-prompt":
  "theorem {α β : Type _}   [SemilatticeSup α] {a b : α} : Ici a ∩ Ici b = Ici (a ⊔ b) := by ext x; sorry",
  "name": "Ici_inter_Ici",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β : Type _}   [SemilatticeSup α] {a b : α} : Ici a ∩ Ici b = Ici (a ⊔ b)",
  "args": "{α β : Type _}   [SemilatticeSup α] {a b : α}"},
 {"type": "Ico a b ∩ Ici c = Ico (a ⊔ c) b",
  "tactic-prompt":
  "theorem {α β : Type _}   [SemilatticeSup α] (a b c : α) : Ico a b ∩ Ici c = Ico (a ⊔ c) b := by rw [← Ici_inter_Iio]; sorry",
  "name": "Ico_inter_Ici",
  "kind": "theorem",
  "first-tactic": "rw [← Ici_inter_Iio]",
  "core-prompt":
  "{α β : Type _}   [SemilatticeSup α] (a b c : α) : Ico a b ∩ Ici c = Ico (a ⊔ c) b",
  "args": "{α β : Type _}   [SemilatticeSup α] (a b c : α)"},
 {"type": "Icc a₁ b₁ ∩ Icc a₂ b₂ = Icc (a₁ ⊔ a₂) (b₁ ⊓ b₂)",
  "tactic-prompt":
  "theorem {α β : Type _}   [Lattice α]  {a b c a₁ a₂ b₁ b₂ : α} : Icc a₁ b₁ ∩ Icc a₂ b₂ = Icc (a₁ ⊔ a₂) (b₁ ⊓ b₂) := by simp only [Ici_inter_Iic.symm]; sorry",
  "name": "Icc_inter_Icc",
  "kind": "theorem",
  "first-tactic": "simp only [Ici_inter_Iic.symm]",
  "core-prompt":
  "{α β : Type _}   [Lattice α]  {a b c a₁ a₂ b₁ b₂ : α} : Icc a₁ b₁ ∩ Icc a₂ b₂ = Icc (a₁ ⊔ a₂) (b₁ ⊓ b₂)",
  "args": "{α β : Type _}   [Lattice α]  {a b c a₁ a₂ b₁ b₂ : α}"},
 {"type": "Icc a b ∩ Icc b c = {b}",
  "tactic-prompt":
  "theorem {α β : Type _}   [Lattice α]  {a b c a₁ a₂ b₁ b₂ : α} (hab : a ≤ b)  (hbc : b ≤ c) : Icc a b ∩ Icc b c = {b} := by rw [Icc_inter_Icc]; sorry",
  "name": "Icc_inter_Icc_eq_singleton",
  "kind": "theorem",
  "first-tactic": "rw [Icc_inter_Icc]",
  "core-prompt":
  "{α β : Type _}   [Lattice α]  {a b c a₁ a₂ b₁ b₂ : α} (hab : a ≤ b)  (hbc : b ≤ c) : Icc a b ∩ Icc b c = {b}",
  "args":
  "{α β : Type _}   [Lattice α]  {a b c a₁ a₂ b₁ b₂ : α} (hab : a ≤ b)  (hbc : b ≤ c)"},
 {"type": "Ico a₁ b₁ ∩ Ico a₂ b₂ = Ico (a₁ ⊔ a₂) (b₁ ⊓ b₂)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ico a₁ b₁ ∩ Ico a₂ b₂ = Ico (a₁ ⊔ a₂) (b₁ ⊓ b₂) := by simp only [Ici_inter_Iio.symm]; sorry",
  "name": "Ico_inter_Ico",
  "kind": "theorem",
  "first-tactic": "simp only [Ici_inter_Iio.symm]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ico a₁ b₁ ∩ Ico a₂ b₂ = Ico (a₁ ⊔ a₂) (b₁ ⊓ b₂)",
  "args":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Ioc a₁ b₁ ∩ Ioc a₂ b₂ = Ioc (a₁ ⊔ a₂) (b₁ ⊓ b₂)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ioc a₁ b₁ ∩ Ioc a₂ b₂ = Ioc (a₁ ⊔ a₂) (b₁ ⊓ b₂) := by simp only [Ioi_inter_Iic.symm]; sorry",
  "name": "Ioc_inter_Ioc",
  "kind": "theorem",
  "first-tactic": "simp only [Ioi_inter_Iic.symm]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ioc a₁ b₁ ∩ Ioc a₂ b₂ = Ioc (a₁ ⊔ a₂) (b₁ ⊓ b₂)",
  "args":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Ioo a₁ b₁ ∩ Ioo a₂ b₂ = Ioo (a₁ ⊔ a₂) (b₁ ⊓ b₂)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ioo a₁ b₁ ∩ Ioo a₂ b₂ = Ioo (a₁ ⊔ a₂) (b₁ ⊓ b₂) := by simp only [Ioi_inter_Iio.symm]; sorry",
  "name": "Ioo_inter_Ioo",
  "kind": "theorem",
  "first-tactic": "simp only [Ioi_inter_Iio.symm]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ioo a₁ b₁ ∩ Ioo a₂ b₂ = Ioo (a₁ ⊔ a₂) (b₁ ⊓ b₂)",
  "args":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Ioo a₁ b₁ ∩ Ioc a₂ b₂ = Ioo (max a₁ a₂) b₁",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} (h : b₁ ≤ b₂) : Ioo a₁ b₁ ∩ Ioc a₂ b₂ = Ioo (max a₁ a₂) b₁ := by rw [inter_comm]; sorry",
  "name": "Ioo_inter_Ioc_of_left_le",
  "kind": "theorem",
  "first-tactic": "rw [inter_comm]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} (h : b₁ ≤ b₂) : Ioo a₁ b₁ ∩ Ioc a₂ b₂ = Ioo (max a₁ a₂) b₁",
  "args":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} (h : b₁ ≤ b₂)"},
 {"type": "Ioo a₁ b₁ ∩ Ioc a₂ b₂ = Ioc (max a₁ a₂) b₂",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} (h : b₂ < b₁) : Ioo a₁ b₁ ∩ Ioc a₂ b₂ = Ioc (max a₁ a₂) b₂ := by rw [inter_comm]; sorry",
  "name": "Ioo_inter_Ioc_of_right_lt",
  "kind": "theorem",
  "first-tactic": "rw [inter_comm]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} (h : b₂ < b₁) : Ioo a₁ b₁ ∩ Ioc a₂ b₂ = Ioc (max a₁ a₂) b₂",
  "args":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} (h : b₂ < b₁)"},
 {"type": "Ico a b \\ Iio c = Ico (max a c) b",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ico a b \\ Iio c = Ico (max a c) b := by rw [diff_eq]; sorry",
  "name": "Ico_diff_Iio",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ico a b \\ Iio c = Ico (max a c) b",
  "args":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Ioc a b ∩ Ioi c = Ioc (a ⊔ c) b",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ioc a b ∩ Ioi c = Ioc (a ⊔ c) b := by rw [← Ioi_inter_Iic]; sorry",
  "name": "Ioc_inter_Ioi",
  "kind": "theorem",
  "first-tactic": "rw [← Ioi_inter_Iic]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ioc a b ∩ Ioi c = Ioc (a ⊔ c) b",
  "args":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Ioc a b \\ Iic c = Ioc (max a c) b",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ioc a b \\ Iic c = Ioc (max a c) b := by rw [diff_eq]; sorry",
  "name": "Ioc_diff_Iic",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ioc a b \\ Iic c = Ioc (max a c) b",
  "args":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Ioc a b ∪ Ioc a c = Ioc a (max b c)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ioc a b ∪ Ioc a c = Ioc a (max b c) := by rw [Ioc_union_Ioc]; sorry",
  "name": "Ioc_union_Ioc_right",
  "kind": "theorem",
  "first-tactic": "rw [Ioc_union_Ioc]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ioc a b ∪ Ioc a c = Ioc a (max b c)",
  "args":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Ioc a c ∪ Ioc b c = Ioc (min a b) c",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ioc a c ∪ Ioc b c = Ioc (min a b) c := by rw [Ioc_union_Ioc]; sorry",
  "name": "Ioc_union_Ioc_left",
  "kind": "theorem",
  "first-tactic": "rw [Ioc_union_Ioc]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ioc a c ∪ Ioc b c = Ioc (min a b) c",
  "args":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Ioc a b ∪ Ioc b a = Ioc (min a b) (max a b)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ioc a b ∪ Ioc b a = Ioc (min a b) (max a b) := by rw [max_comm]; sorry",
  "name": "Ioc_union_Ioc_symm",
  "kind": "theorem",
  "first-tactic": "rw [max_comm]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ioc a b ∪ Ioc b a = Ioc (min a b) (max a b)",
  "args":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type":
  "Ioc a b ∪ Ioc b c ∪ Ioc c a = Ioc (min a (min b c)) (max a (max b c))",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ioc a b ∪ Ioc b c ∪ Ioc c a = Ioc (min a (min b c)) (max a (max b c)) := by rw [Ioc_union_Ioc]; sorry",
  "name": "Ioc_union_Ioc_union_Ioc_cycle",
  "kind": "theorem",
  "first-tactic": "rw [Ioc_union_Ioc]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α} : Ioc a b ∪ Ioc b c ∪ Ioc c a = Ioc (min a (min b c)) (max a (max b c))",
  "args":
  "{α β : Type _}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {a a₁ a₂ b b₁ b₂ c d : α}"},
 {"type": "Icc a₁ a₂ ×ˢ Icc b₁ b₂ = Icc (a₁, b₁) (a₂, b₂)",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  [Preorder β] (a₁ a₂ : α)  (b₁ b₂ : β) : Icc a₁ a₂ ×ˢ Icc b₁ b₂ = Icc (a₁, b₁) (a₂, b₂) := by ext ⟨x, y⟩; sorry",
  "name": "Icc_prod_Icc",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  [Preorder β] (a₁ a₂ : α)  (b₁ b₂ : β) : Icc a₁ a₂ ×ˢ Icc b₁ b₂ = Icc (a₁, b₁) (a₂, b₂)",
  "args":
  "{α β : Type _}  [Preorder α]  [Preorder β] (a₁ a₂ : α)  (b₁ b₂ : β)"},
 {"type": "Icc a b = Icc a.1 b.1 ×ˢ Icc a.2 b.2",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  [Preorder β] (a b : α × β) : Icc a b = Icc a.1 b.1 ×ˢ Icc a.2 b.2 := by simp; sorry",
  "name": "Icc_prod_eq",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  [Preorder β] (a b : α × β) : Icc a b = Icc a.1 b.1 ×ˢ Icc a.2 b.2",
  "args": "{α β : Type _}  [Preorder α]  [Preorder β] (a b : α × β)"},
 {"type": "Nonempty ↑(Ico x (x + dx) \\ Ico y (y + dy))",
  "tactic-prompt":
  "theorem {α : Type _}  [LinearOrderedAddCommGroup α] {x dx y dy : α}  (h : dy < dx)  (hx : 0 < dx) : Nonempty ↑(Ico x (x + dx) \\ Ico y (y + dy)) := by cases' lt_or_le x y with h' h'; sorry",
  "name": "nonempty_Ico_sdiff",
  "kind": "theorem",
  "first-tactic": "cases' lt_or_le x y with h' h'",
  "core-prompt":
  "{α : Type _}  [LinearOrderedAddCommGroup α] {x dx y dy : α}  (h : dy < dx)  (hx : 0 < dx) : Nonempty ↑(Ico x (x + dx) \\ Ico y (y + dy))",
  "args":
  "{α : Type _}  [LinearOrderedAddCommGroup α] {x dx y dy : α}  (h : dy < dx)  (hx : 0 < dx)"},
 {"type": "[[a, b]] = Icc a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α} (h : a ≤ b) : [[a, b]] = Icc a b := by rw [interval]; sorry",
  "name": "interval_of_le",
  "kind": "theorem",
  "first-tactic": "rw [interval]",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α} (h : a ≤ b) : [[a, b]] = Icc a b",
  "args": "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α} (h : a ≤ b)"},
 {"type": "[[a, b]] = Icc b a",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α} (h : b ≤ a) : [[a, b]] = Icc b a := by rw [interval]; sorry",
  "name": "interval_of_ge",
  "kind": "theorem",
  "first-tactic": "rw [interval]",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α} (h : b ≤ a) : [[a, b]] = Icc b a",
  "args": "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α} (h : b ≤ a)"},
 {"type": "[[a, b]] = [[b, a]]",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α} (a b : α) : [[a, b]] = [[b, a]] := by simp_rw [interval]; sorry",
  "name": "interval_swap",
  "kind": "theorem",
  "first-tactic": "simp_rw [interval]",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α} (a b : α) : [[a, b]] = [[b, a]]",
  "args": "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α} (a b : α)"},
 {"type": "[[a, a]] = {a}",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α} : [[a, a]] = {a} := by simp [interval]; sorry",
  "name": "interval_self",
  "kind": "theorem",
  "first-tactic": "simp [interval]",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α} : [[a, a]] = {a}",
  "args": "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "b ∈ [[a, c]] → c ∈ [[a, b]] → b = c",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [DistribLattice α]  {a a₁ a₂ b b₁ b₂ c x : α} : b ∈ [[a, c]] → c ∈ [[a, b]] → b = c := by simpa only [interval_swap a] using eq_of_mem_interval_of_mem_interval; sorry",
  "name": "eq_of_mem_interval_of_mem_interval'",
  "kind": "theorem",
  "first-tactic":
  "simpa only [interval_swap a] using eq_of_mem_interval_of_mem_interval",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [DistribLattice α]  {a a₁ a₂ b b₁ b₂ c x : α} : b ∈ [[a, c]] → c ∈ [[a, b]] → b = c",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [DistribLattice α]  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "Injective (interval a)",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [DistribLattice α]  {a a₁ a₂ b b₁ b₂ c x : α} (a : α) : Injective (interval a) := by simpa only [interval_swap] using interval_injective_right a; sorry",
  "name": "interval_injective_left",
  "kind": "theorem",
  "first-tactic": "simpa only [interval_swap] using interval_injective_right a",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [DistribLattice α]  {a a₁ a₂ b b₁ b₂ c x : α} (a : α) : Injective (interval a)",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [DistribLattice α]  {a a₁ a₂ b b₁ b₂ c x : α} (a : α)"},
 {"type": "[[a, b]] = Icc a b ∪ Icc b a",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : [[a, b]] = Icc a b ∪ Icc b a := by rw [Icc_union_Icc']; sorry",
  "name": "interval_eq_union",
  "kind": "theorem",
  "first-tactic": "rw [Icc_union_Icc']",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : [[a, b]] = Icc a b ∪ Icc b a",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "a ∈ [[b, c]] ↔ b ≤ a ∧ a ≤ c ∨ c ≤ a ∧ a ≤ b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ [[b, c]] ↔ b ≤ a ∧ a ≤ c ∨ c ≤ a ∧ a ≤ b := by simp [interval_eq_union]; sorry",
  "name": "mem_interval",
  "kind": "theorem",
  "first-tactic": "simp [interval_eq_union]",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ [[b, c]] ↔ b ≤ a ∧ a ≤ c ∨ c ≤ a ∧ a ≤ b",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type":
  "Monotone f ∨ Antitone f ↔ ∀ a b c, c ∈ [[a, b]] → f c ∈ [[f a, f b]]",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : Monotone f ∨ Antitone f ↔ ∀ a b c, c ∈ [[a, b]] → f c ∈ [[f a, f b]] := by constructor; sorry",
  "name": "monotone_or_antitone_iff_interval",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : Monotone f ∨ Antitone f ↔ ∀ a b c, c ∈ [[a, b]] → f c ∈ [[f a, f b]]",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type":
  "MonotoneOn f s ∨ AntitoneOn f s ↔\n      ∀ (a) (_ : a ∈ s) (b) (_ : b ∈ s) (c) (_ : c ∈ s), c ∈ [[a, b]] → f c ∈ [[f a, f b]]",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : MonotoneOn f s ∨ AntitoneOn f s ↔\n      ∀ (a) (_ : a ∈ s) (b) (_ : b ∈ s) (c) (_ : c ∈ s), c ∈ [[a, b]] → f c ∈ [[f a, f b]] := by simp [monotoneOn_iff_monotone]; sorry",
  "name": "monotoneOn_or_antitoneOn_iff_interval",
  "kind": "theorem",
  "first-tactic": "simp [monotoneOn_iff_monotone]",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : MonotoneOn f s ∨ AntitoneOn f s ↔\n      ∀ (a) (_ : a ∈ s) (b) (_ : b ∈ s) (c) (_ : c ∈ s), c ∈ [[a, b]] → f c ∈ [[f a, f b]]",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "Ι a b = Ioc a b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (h : a ≤ b) : Ι a b = Ioc a b := by simp [intervalOC]; sorry",
  "name": "intervalOC_of_le",
  "kind": "theorem",
  "first-tactic": "simp [intervalOC]",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (h : a ≤ b) : Ι a b = Ioc a b",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (h : a ≤ b)"},
 {"type": "Ι a b = Ioc b a",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (h : b < a) : Ι a b = Ioc b a := by simp [intervalOC]; sorry",
  "name": "intervalOC_of_lt",
  "kind": "theorem",
  "first-tactic": "simp [intervalOC]",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (h : b < a) : Ι a b = Ioc b a",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (h : b < a)"},
 {"type": "Ι a b = Ioc a b ∪ Ioc b a",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : Ι a b = Ioc a b ∪ Ioc b a := by cases le_total a b; sorry",
  "name": "intervalOC_eq_union",
  "kind": "theorem",
  "first-tactic": "cases le_total a b",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : Ι a b = Ioc a b ∪ Ioc b a",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "a ∈ Ι b c ↔ b < a ∧ a ≤ c ∨ c < a ∧ a ≤ b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Ι b c ↔ b < a ∧ a ≤ c ∨ c < a ∧ a ≤ b := by rw [intervalOC_eq_union]; sorry",
  "name": "mem_intervalOC",
  "kind": "theorem",
  "first-tactic": "rw [intervalOC_eq_union]",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Ι b c ↔ b < a ∧ a ≤ c ∨ c < a ∧ a ≤ b",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "a ∉ Ι b c ↔ a ≤ b ∧ a ≤ c ∨ c < a ∧ b < a",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : a ∉ Ι b c ↔ a ≤ b ∧ a ≤ c ∨ c < a ∧ b < a := by rw [intervalOC_eq_union]; sorry",
  "name": "not_mem_intervalOC",
  "kind": "theorem",
  "first-tactic": "rw [intervalOC_eq_union]",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : a ∉ Ι b c ↔ a ≤ b ∧ a ≤ c ∨ c < a ∧ b < a",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "a ∈ Ι a b ↔ b < a",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Ι a b ↔ b < a := by simp [mem_intervalOC]; sorry",
  "name": "left_mem_intervalOC",
  "kind": "theorem",
  "first-tactic": "simp [mem_intervalOC]",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Ι a b ↔ b < a",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "b ∈ Ι a b ↔ a < b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : b ∈ Ι a b ↔ a < b := by simp [mem_intervalOC]; sorry",
  "name": "right_mem_intervalOC",
  "kind": "theorem",
  "first-tactic": "simp [mem_intervalOC]",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : b ∈ Ι a b ↔ a < b",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "(∀ x ∈ Ι a b, P x) ↔ (∀ x ∈ Ioc a b, P x) ∧ ∀ x ∈ Ioc b a, P x",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} {P : α → Prop} : (∀ x ∈ Ι a b, P x) ↔ (∀ x ∈ Ioc a b, P x) ∧ ∀ x ∈ Ioc b a, P x := by simp only [intervalOC_eq_union]; sorry",
  "name": "forall_intervalOC_iff",
  "kind": "theorem",
  "first-tactic": "simp only [intervalOC_eq_union]",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} {P : α → Prop} : (∀ x ∈ Ι a b, P x) ↔ (∀ x ∈ Ioc a b, P x) ∧ ∀ x ∈ Ioc b a, P x",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} {P : α → Prop}"},
 {"type": "Ι a b = Ι b a",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (a b : α) : Ι a b = Ι b a := by simp only [intervalOC]; sorry",
  "name": "intervalOC_swap",
  "kind": "theorem",
  "first-tactic": "simp only [intervalOC]",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (a b : α) : Ι a b = Ι b a",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (a b : α)"},
 {"type": "a ∈ Ι b c → b ∈ Ι a c → a = b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Ι b c → b ∈ Ι a c → a = b := by simp_rw [mem_intervalOC]; sorry",
  "name": "eq_of_mem_intervalOC_of_mem_intervalOC",
  "kind": "theorem",
  "first-tactic": "simp_rw [mem_intervalOC]",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : a ∈ Ι b c → b ∈ Ι a c → a = b",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "b ∈ Ι a c → c ∈ Ι a b → b = c",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : b ∈ Ι a c → c ∈ Ι a b → b = c := by simpa only [intervalOC_swap a] using eq_of_mem_intervalOC_of_mem_intervalOC; sorry",
  "name": "eq_of_mem_intervalOC_of_mem_intervalOC'",
  "kind": "theorem",
  "first-tactic":
  "simpa only [intervalOC_swap a] using eq_of_mem_intervalOC_of_mem_intervalOC",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} : b ∈ Ι a c → c ∈ Ι a b → b = c",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α}"},
 {"type": "a ∉ Ι b c → b ∉ Ι a c → a = b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (ha : a ≤ c)  (hb : b ≤ c) : a ∉ Ι b c → b ∉ Ι a c → a = b := by simp_rw [not_mem_intervalOC]; sorry",
  "name": "eq_of_not_mem_intervalOC_of_not_mem_intervalOC",
  "kind": "theorem",
  "first-tactic": "simp_rw [not_mem_intervalOC]",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (ha : a ≤ c)  (hb : b ≤ c) : a ∉ Ι b c → b ∉ Ι a c → a = b",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (ha : a ≤ c)  (hb : b ≤ c)"},
 {"type": "Injective fun b => Ι b a",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (a : α) : Injective fun b => Ι b a := by rintro b c h; sorry",
  "name": "intervalOC_injective_right",
  "kind": "theorem",
  "first-tactic": "rintro b c h",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (a : α) : Injective fun b => Ι b a",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (a : α)"},
 {"type": "Injective (Ι a)",
  "tactic-prompt":
  "theorem {α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (a : α) : Injective (Ι a) := by simpa only [intervalOC_swap] using intervalOC_injective_right a; sorry",
  "name": "intervalOC_injective_left",
  "kind": "theorem",
  "first-tactic":
  "simpa only [intervalOC_swap] using intervalOC_injective_right a",
  "core-prompt":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (a : α) : Injective (Ι a)",
  "args":
  "{α β : Type _}  [Lattice α]  {a a₁ a₂ b b₁ b₂ c x : α}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a a₁ a₂ b b₁ b₂ c x : α} (a : α)"},
 {"type": "projIcc a b h x = ⟨a, left_mem_Icc.2 h⟩",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (hx : x ≤ a) : projIcc a b h x = ⟨a, left_mem_Icc.2 h⟩ := by simp [projIcc]; sorry",
  "name": "projIcc_of_le_left",
  "kind": "theorem",
  "first-tactic": "simp [projIcc]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (hx : x ≤ a) : projIcc a b h x = ⟨a, left_mem_Icc.2 h⟩",
  "args":
  "{α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (hx : x ≤ a)"},
 {"type": "projIcc a b h x = ⟨b, right_mem_Icc.2 h⟩",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (hx : b ≤ x) : projIcc a b h x = ⟨b, right_mem_Icc.2 h⟩ := by simp [projIcc]; sorry",
  "name": "projIcc_of_right_le",
  "kind": "theorem",
  "first-tactic": "simp [projIcc]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (hx : b ≤ x) : projIcc a b h x = ⟨b, right_mem_Icc.2 h⟩",
  "args":
  "{α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (hx : b ≤ x)"},
 {"type": "projIcc a b h.le x = ⟨a, left_mem_Icc.mpr h.le⟩ ↔ x ≤ a",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (h : a < b) : projIcc a b h.le x = ⟨a, left_mem_Icc.mpr h.le⟩ ↔ x ≤ a := by refine' ⟨fun h' => _, projIcc_of_le_left _⟩; sorry",
  "name": "projIcc_eq_left",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h' => _, projIcc_of_le_left _⟩",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (h : a < b) : projIcc a b h.le x = ⟨a, left_mem_Icc.mpr h.le⟩ ↔ x ≤ a",
  "args":
  "{α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (h : a < b)"},
 {"type": "projIcc a b h.le x = ⟨b, right_mem_Icc.mpr h.le⟩ ↔ b ≤ x",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (h : a < b) : projIcc a b h.le x = ⟨b, right_mem_Icc.mpr h.le⟩ ↔ b ≤ x := by refine' ⟨fun h' => _, projIcc_of_right_le _⟩; sorry",
  "name": "projIcc_eq_right",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h' => _, projIcc_of_right_le _⟩",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (h : a < b) : projIcc a b h.le x = ⟨b, right_mem_Icc.mpr h.le⟩ ↔ b ≤ x",
  "args":
  "{α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (h : a < b)"},
 {"type": "projIcc a b h x = ⟨x, hx⟩",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (hx : x ∈ Icc a b) : projIcc a b h x = ⟨x, hx⟩ := by simp [projIcc]; sorry",
  "name": "projIcc_of_mem",
  "kind": "theorem",
  "first-tactic": "simp [projIcc]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (hx : x ∈ Icc a b) : projIcc a b h x = ⟨x, hx⟩",
  "args":
  "{α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (hx : x ∈ Icc a b)"},
 {"type": "projIcc a b h x = x",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (x : Icc a b) : projIcc a b h x = x := by cases x; sorry",
  "name": "projIcc_val",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (x : Icc a b) : projIcc a b h x = x",
  "args":
  "{α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (x : Icc a b)"},
 {"type": "range (IccExtend h f) = range f",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (f : Icc a b → β) : range (IccExtend h f) = range f := by simp only [IccExtend]; sorry",
  "name": "IccExtend_range",
  "kind": "theorem",
  "first-tactic": "simp only [IccExtend]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (f : Icc a b → β) : range (IccExtend h f) = range f",
  "args":
  "{α β : Type _}  [LinearOrder α] {a b : α}  (h : a ≤ b)  {x : α} (f : Icc a b → β)"},
 {"type": "e ⁻¹' Iic b = Iic (e.symm b)",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β] (e : α ≃o β)  (b : β) : e ⁻¹' Iic b = Iic (e.symm b) := by ext x; sorry",
  "name": "preimage_Iic",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "[Preorder α]  [Preorder β] (e : α ≃o β)  (b : β) : e ⁻¹' Iic b = Iic (e.symm b)",
  "args": "[Preorder α]  [Preorder β] (e : α ≃o β)  (b : β)"},
 {"type": "e ⁻¹' Ici b = Ici (e.symm b)",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β] (e : α ≃o β)  (b : β) : e ⁻¹' Ici b = Ici (e.symm b) := by ext x; sorry",
  "name": "preimage_Ici",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "[Preorder α]  [Preorder β] (e : α ≃o β)  (b : β) : e ⁻¹' Ici b = Ici (e.symm b)",
  "args": "[Preorder α]  [Preorder β] (e : α ≃o β)  (b : β)"},
 {"type": "e ⁻¹' Iio b = Iio (e.symm b)",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β] (e : α ≃o β)  (b : β) : e ⁻¹' Iio b = Iio (e.symm b) := by ext x; sorry",
  "name": "preimage_Iio",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "[Preorder α]  [Preorder β] (e : α ≃o β)  (b : β) : e ⁻¹' Iio b = Iio (e.symm b)",
  "args": "[Preorder α]  [Preorder β] (e : α ≃o β)  (b : β)"},
 {"type": "e ⁻¹' Ioi b = Ioi (e.symm b)",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β] (e : α ≃o β)  (b : β) : e ⁻¹' Ioi b = Ioi (e.symm b) := by ext x; sorry",
  "name": "preimage_Ioi",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "[Preorder α]  [Preorder β] (e : α ≃o β)  (b : β) : e ⁻¹' Ioi b = Ioi (e.symm b)",
  "args": "[Preorder α]  [Preorder β] (e : α ≃o β)  (b : β)"},
 {"type": "e ⁻¹' Icc a b = Icc (e.symm a) (e.symm b)",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β] (e : α ≃o β)  (a b : β) : e ⁻¹' Icc a b = Icc (e.symm a) (e.symm b) := by simp [← Ici_inter_Iic]; sorry",
  "name": "preimage_Icc",
  "kind": "theorem",
  "first-tactic": "simp [← Ici_inter_Iic]",
  "core-prompt":
  "[Preorder α]  [Preorder β] (e : α ≃o β)  (a b : β) : e ⁻¹' Icc a b = Icc (e.symm a) (e.symm b)",
  "args": "[Preorder α]  [Preorder β] (e : α ≃o β)  (a b : β)"},
 {"type": "e ⁻¹' Ico a b = Ico (e.symm a) (e.symm b)",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β] (e : α ≃o β)  (a b : β) : e ⁻¹' Ico a b = Ico (e.symm a) (e.symm b) := by simp [← Ici_inter_Iio]; sorry",
  "name": "preimage_Ico",
  "kind": "theorem",
  "first-tactic": "simp [← Ici_inter_Iio]",
  "core-prompt":
  "[Preorder α]  [Preorder β] (e : α ≃o β)  (a b : β) : e ⁻¹' Ico a b = Ico (e.symm a) (e.symm b)",
  "args": "[Preorder α]  [Preorder β] (e : α ≃o β)  (a b : β)"},
 {"type": "e ⁻¹' Ioc a b = Ioc (e.symm a) (e.symm b)",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β] (e : α ≃o β)  (a b : β) : e ⁻¹' Ioc a b = Ioc (e.symm a) (e.symm b) := by simp [← Ioi_inter_Iic]; sorry",
  "name": "preimage_Ioc",
  "kind": "theorem",
  "first-tactic": "simp [← Ioi_inter_Iic]",
  "core-prompt":
  "[Preorder α]  [Preorder β] (e : α ≃o β)  (a b : β) : e ⁻¹' Ioc a b = Ioc (e.symm a) (e.symm b)",
  "args": "[Preorder α]  [Preorder β] (e : α ≃o β)  (a b : β)"},
 {"type": "e ⁻¹' Ioo a b = Ioo (e.symm a) (e.symm b)",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β] (e : α ≃o β)  (a b : β) : e ⁻¹' Ioo a b = Ioo (e.symm a) (e.symm b) := by simp [← Ioi_inter_Iio]; sorry",
  "name": "preimage_Ioo",
  "kind": "theorem",
  "first-tactic": "simp [← Ioi_inter_Iio]",
  "core-prompt":
  "[Preorder α]  [Preorder β] (e : α ≃o β)  (a b : β) : e ⁻¹' Ioo a b = Ioo (e.symm a) (e.symm b)",
  "args": "[Preorder α]  [Preorder β] (e : α ≃o β)  (a b : β)"},
 {"type": "e '' Iic a = Iic (e a)",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β] (e : α ≃o β)  (a : α) : e '' Iic a = Iic (e a) := by rw [e.image_eq_preimage]; sorry",
  "name": "image_Iic",
  "kind": "theorem",
  "first-tactic": "rw [e.image_eq_preimage]",
  "core-prompt":
  "[Preorder α]  [Preorder β] (e : α ≃o β)  (a : α) : e '' Iic a = Iic (e a)",
  "args": "[Preorder α]  [Preorder β] (e : α ≃o β)  (a : α)"},
 {"type": "e '' Iio a = Iio (e a)",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β] (e : α ≃o β)  (a : α) : e '' Iio a = Iio (e a) := by rw [e.image_eq_preimage]; sorry",
  "name": "image_Iio",
  "kind": "theorem",
  "first-tactic": "rw [e.image_eq_preimage]",
  "core-prompt":
  "[Preorder α]  [Preorder β] (e : α ≃o β)  (a : α) : e '' Iio a = Iio (e a)",
  "args": "[Preorder α]  [Preorder β] (e : α ≃o β)  (a : α)"},
 {"type": "e '' Ioo a b = Ioo (e a) (e b)",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β] (e : α ≃o β)  (a b : α) : e '' Ioo a b = Ioo (e a) (e b) := by rw [e.image_eq_preimage]; sorry",
  "name": "image_Ioo",
  "kind": "theorem",
  "first-tactic": "rw [e.image_eq_preimage]",
  "core-prompt":
  "[Preorder α]  [Preorder β] (e : α ≃o β)  (a b : α) : e '' Ioo a b = Ioo (e a) (e b)",
  "args": "[Preorder α]  [Preorder β] (e : α ≃o β)  (a b : α)"},
 {"type": "e '' Ioc a b = Ioc (e a) (e b)",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β] (e : α ≃o β)  (a b : α) : e '' Ioc a b = Ioc (e a) (e b) := by rw [e.image_eq_preimage]; sorry",
  "name": "image_Ioc",
  "kind": "theorem",
  "first-tactic": "rw [e.image_eq_preimage]",
  "core-prompt":
  "[Preorder α]  [Preorder β] (e : α ≃o β)  (a b : α) : e '' Ioc a b = Ioc (e a) (e b)",
  "args": "[Preorder α]  [Preorder β] (e : α ≃o β)  (a b : α)"},
 {"type": "e '' Ico a b = Ico (e a) (e b)",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β] (e : α ≃o β)  (a b : α) : e '' Ico a b = Ico (e a) (e b) := by rw [e.image_eq_preimage]; sorry",
  "name": "image_Ico",
  "kind": "theorem",
  "first-tactic": "rw [e.image_eq_preimage]",
  "core-prompt":
  "[Preorder α]  [Preorder β] (e : α ≃o β)  (a b : α) : e '' Ico a b = Ico (e a) (e b)",
  "args": "[Preorder α]  [Preorder β] (e : α ≃o β)  (a b : α)"},
 {"type": "e '' Icc a b = Icc (e a) (e b)",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β] (e : α ≃o β)  (a b : α) : e '' Icc a b = Icc (e a) (e b) := by rw [e.image_eq_preimage]; sorry",
  "name": "image_Icc",
  "kind": "theorem",
  "first-tactic": "rw [e.image_eq_preimage]",
  "core-prompt":
  "[Preorder α]  [Preorder β] (e : α ≃o β)  (a b : α) : e '' Icc a b = Icc (e a) (e b)",
  "args": "[Preorder α]  [Preorder β] (e : α ≃o β)  (a b : α)"},
 {"type": "range (some : α → WithTop α) = Iio ⊤",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} : range (some : α → WithTop α) = Iio ⊤ := by ext x; sorry",
  "name": "range_coe",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "[PartialOrder α]  {a b : α} : range (some : α → WithTop α) = Iio ⊤",
  "args": "[PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithTop α) ⁻¹' Icc a b = Icc a b",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} : (some : α → WithTop α) ⁻¹' Icc a b = Icc a b := by simp [← Ici_inter_Iic]; sorry",
  "name": "preimage_coe_Icc",
  "kind": "theorem",
  "first-tactic": "simp [← Ici_inter_Iic]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} : (some : α → WithTop α) ⁻¹' Icc a b = Icc a b",
  "args": "[PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithTop α) ⁻¹' Ico a b = Ico a b",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} : (some : α → WithTop α) ⁻¹' Ico a b = Ico a b := by simp [← Ici_inter_Iio]; sorry",
  "name": "preimage_coe_Ico",
  "kind": "theorem",
  "first-tactic": "simp [← Ici_inter_Iio]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} : (some : α → WithTop α) ⁻¹' Ico a b = Ico a b",
  "args": "[PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithTop α) ⁻¹' Ioc a b = Ioc a b",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} : (some : α → WithTop α) ⁻¹' Ioc a b = Ioc a b := by simp [← Ioi_inter_Iic]; sorry",
  "name": "preimage_coe_Ioc",
  "kind": "theorem",
  "first-tactic": "simp [← Ioi_inter_Iic]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} : (some : α → WithTop α) ⁻¹' Ioc a b = Ioc a b",
  "args": "[PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithTop α) ⁻¹' Ioo a b = Ioo a b",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} : (some : α → WithTop α) ⁻¹' Ioo a b = Ioo a b := by simp [← Ioi_inter_Iio]; sorry",
  "name": "preimage_coe_Ioo",
  "kind": "theorem",
  "first-tactic": "simp [← Ioi_inter_Iio]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} : (some : α → WithTop α) ⁻¹' Ioo a b = Ioo a b",
  "args": "[PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithTop α) ⁻¹' Iio ⊤ = univ",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} : (some : α → WithTop α) ⁻¹' Iio ⊤ = univ := by rw [← range_coe]; sorry",
  "name": "preimage_coe_Iio_top",
  "kind": "theorem",
  "first-tactic": "rw [← range_coe]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} : (some : α → WithTop α) ⁻¹' Iio ⊤ = univ",
  "args": "[PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithTop α) ⁻¹' Ico a ⊤ = Ici a",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} : (some : α → WithTop α) ⁻¹' Ico a ⊤ = Ici a := by simp [← Ici_inter_Iio]; sorry",
  "name": "preimage_coe_Ico_top",
  "kind": "theorem",
  "first-tactic": "simp [← Ici_inter_Iio]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} : (some : α → WithTop α) ⁻¹' Ico a ⊤ = Ici a",
  "args": "[PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithTop α) ⁻¹' Ioo a ⊤ = Ioi a",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} : (some : α → WithTop α) ⁻¹' Ioo a ⊤ = Ioi a := by simp [← Ioi_inter_Iio]; sorry",
  "name": "preimage_coe_Ioo_top",
  "kind": "theorem",
  "first-tactic": "simp [← Ioi_inter_Iio]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} : (some : α → WithTop α) ⁻¹' Ioo a ⊤ = Ioi a",
  "args": "[PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithTop α) '' Ioi a = Ioo (a : WithTop α) ⊤",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} : (some : α → WithTop α) '' Ioi a = Ioo (a : WithTop α) ⊤ := by rw [← preimage_coe_Ioi]; sorry",
  "name": "image_coe_Ioi",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_coe_Ioi]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} : (some : α → WithTop α) '' Ioi a = Ioo (a : WithTop α) ⊤",
  "args": "[PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithTop α) '' Ici a = Ico (a : WithTop α) ⊤",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} : (some : α → WithTop α) '' Ici a = Ico (a : WithTop α) ⊤ := by rw [← preimage_coe_Ici]; sorry",
  "name": "image_coe_Ici",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_coe_Ici]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} : (some : α → WithTop α) '' Ici a = Ico (a : WithTop α) ⊤",
  "args": "[PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithTop α) '' Iio a = Iio (a : WithTop α)",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} : (some : α → WithTop α) '' Iio a = Iio (a : WithTop α) := by rw [← preimage_coe_Iio]; sorry",
  "name": "image_coe_Iio",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_coe_Iio]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} : (some : α → WithTop α) '' Iio a = Iio (a : WithTop α)",
  "args": "[PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithTop α) '' Iic a = Iic (a : WithTop α)",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} : (some : α → WithTop α) '' Iic a = Iic (a : WithTop α) := by rw [← preimage_coe_Iic]; sorry",
  "name": "image_coe_Iic",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_coe_Iic]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} : (some : α → WithTop α) '' Iic a = Iic (a : WithTop α)",
  "args": "[PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithTop α) '' Icc a b = Icc (a : WithTop α) b",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} : (some : α → WithTop α) '' Icc a b = Icc (a : WithTop α) b := by rw [← preimage_coe_Icc]; sorry",
  "name": "image_coe_Icc",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_coe_Icc]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} : (some : α → WithTop α) '' Icc a b = Icc (a : WithTop α) b",
  "args": "[PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithTop α) '' Ico a b = Ico (a : WithTop α) b",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} : (some : α → WithTop α) '' Ico a b = Ico (a : WithTop α) b := by rw [← preimage_coe_Ico]; sorry",
  "name": "image_coe_Ico",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_coe_Ico]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} : (some : α → WithTop α) '' Ico a b = Ico (a : WithTop α) b",
  "args": "[PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithTop α) '' Ioc a b = Ioc (a : WithTop α) b",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} : (some : α → WithTop α) '' Ioc a b = Ioc (a : WithTop α) b := by rw [← preimage_coe_Ioc]; sorry",
  "name": "image_coe_Ioc",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_coe_Ioc]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} : (some : α → WithTop α) '' Ioc a b = Ioc (a : WithTop α) b",
  "args": "[PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithTop α) '' Ioo a b = Ioo (a : WithTop α) b",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} : (some : α → WithTop α) '' Ioo a b = Ioo (a : WithTop α) b := by rw [← preimage_coe_Ioo]; sorry",
  "name": "image_coe_Ioo",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_coe_Ioo]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} : (some : α → WithTop α) '' Ioo a b = Ioo (a : WithTop α) b",
  "args": "[PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithBot α) ⁻¹' Icc a b = Icc a b",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) ⁻¹' Icc a b = Icc a b := by simp [← Ici_inter_Iic]; sorry",
  "name": "preimage_coe_Icc",
  "kind": "theorem",
  "first-tactic": "simp [← Ici_inter_Iic]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) ⁻¹' Icc a b = Icc a b",
  "args": "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithBot α) ⁻¹' Ico a b = Ico a b",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) ⁻¹' Ico a b = Ico a b := by simp [← Ici_inter_Iio]; sorry",
  "name": "preimage_coe_Ico",
  "kind": "theorem",
  "first-tactic": "simp [← Ici_inter_Iio]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) ⁻¹' Ico a b = Ico a b",
  "args": "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithBot α) ⁻¹' Ioc a b = Ioc a b",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) ⁻¹' Ioc a b = Ioc a b := by simp [← Ioi_inter_Iic]; sorry",
  "name": "preimage_coe_Ioc",
  "kind": "theorem",
  "first-tactic": "simp [← Ioi_inter_Iic]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) ⁻¹' Ioc a b = Ioc a b",
  "args": "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithBot α) ⁻¹' Ioo a b = Ioo a b",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) ⁻¹' Ioo a b = Ioo a b := by simp [← Ioi_inter_Iio]; sorry",
  "name": "preimage_coe_Ioo",
  "kind": "theorem",
  "first-tactic": "simp [← Ioi_inter_Iio]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) ⁻¹' Ioo a b = Ioo a b",
  "args": "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithBot α) ⁻¹' Ioi ⊥ = univ",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) ⁻¹' Ioi ⊥ = univ := by rw [← range_coe]; sorry",
  "name": "preimage_coe_Ioi_bot",
  "kind": "theorem",
  "first-tactic": "rw [← range_coe]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) ⁻¹' Ioi ⊥ = univ",
  "args": "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithBot α) ⁻¹' Ioc ⊥ a = Iic a",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) ⁻¹' Ioc ⊥ a = Iic a := by simp [← Ioi_inter_Iic]; sorry",
  "name": "preimage_coe_Ioc_bot",
  "kind": "theorem",
  "first-tactic": "simp [← Ioi_inter_Iic]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) ⁻¹' Ioc ⊥ a = Iic a",
  "args": "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithBot α) ⁻¹' Ioo ⊥ a = Iio a",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) ⁻¹' Ioo ⊥ a = Iio a := by simp [← Ioi_inter_Iio]; sorry",
  "name": "preimage_coe_Ioo_bot",
  "kind": "theorem",
  "first-tactic": "simp [← Ioi_inter_Iio]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) ⁻¹' Ioo ⊥ a = Iio a",
  "args": "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithBot α) '' Iio a = Ioo (⊥ : WithBot α) a",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) '' Iio a = Ioo (⊥ : WithBot α) a := by rw [← preimage_coe_Iio]; sorry",
  "name": "image_coe_Iio",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_coe_Iio]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) '' Iio a = Ioo (⊥ : WithBot α) a",
  "args": "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithBot α) '' Iic a = Ioc (⊥ : WithBot α) a",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) '' Iic a = Ioc (⊥ : WithBot α) a := by rw [← preimage_coe_Iic]; sorry",
  "name": "image_coe_Iic",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_coe_Iic]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) '' Iic a = Ioc (⊥ : WithBot α) a",
  "args": "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithBot α) '' Ioi a = Ioi (a : WithBot α)",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) '' Ioi a = Ioi (a : WithBot α) := by rw [← preimage_coe_Ioi]; sorry",
  "name": "image_coe_Ioi",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_coe_Ioi]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) '' Ioi a = Ioi (a : WithBot α)",
  "args": "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithBot α) '' Ici a = Ici (a : WithBot α)",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) '' Ici a = Ici (a : WithBot α) := by rw [← preimage_coe_Ici]; sorry",
  "name": "image_coe_Ici",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_coe_Ici]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) '' Ici a = Ici (a : WithBot α)",
  "args": "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithBot α) '' Icc a b = Icc (a : WithBot α) b",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) '' Icc a b = Icc (a : WithBot α) b := by rw [← preimage_coe_Icc]; sorry",
  "name": "image_coe_Icc",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_coe_Icc]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) '' Icc a b = Icc (a : WithBot α) b",
  "args": "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithBot α) '' Ioc a b = Ioc (a : WithBot α) b",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) '' Ioc a b = Ioc (a : WithBot α) b := by rw [← preimage_coe_Ioc]; sorry",
  "name": "image_coe_Ioc",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_coe_Ioc]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) '' Ioc a b = Ioc (a : WithBot α) b",
  "args": "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithBot α) '' Ico a b = Ico (a : WithBot α) b",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) '' Ico a b = Ico (a : WithBot α) b := by rw [← preimage_coe_Ico]; sorry",
  "name": "image_coe_Ico",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_coe_Ico]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) '' Ico a b = Ico (a : WithBot α) b",
  "args": "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α}"},
 {"type": "(some : α → WithBot α) '' Ioo a b = Ioo (a : WithBot α) b",
  "tactic-prompt":
  "theorem [PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) '' Ioo a b = Ioo (a : WithBot α) b := by rw [← preimage_coe_Ioo]; sorry",
  "name": "image_coe_Ioo",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_coe_Ioo]",
  "core-prompt":
  "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α} : (some : α → WithBot α) '' Ioo a b = Ioo (a : WithBot α) b",
  "args": "[PartialOrder α]  {a b : α} [PartialOrder α]  {a b : α}"},
 {"type": "image2 f s t ⊆ image2 f s' t'",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (hs : s ⊆ s')  (ht : t ⊆ t') : image2 f s t ⊆ image2 f s' t' := by rintro _ ⟨a, b, ha, hb, rfl⟩; sorry",
  "name": "image2_subset",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨a, b, ha, hb, rfl⟩",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (hs : s ⊆ s')  (ht : t ⊆ t') : image2 f s t ⊆ image2 f s' t'",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (hs : s ⊆ s')  (ht : t ⊆ t')"},
 {"type": "image2 (fun a b ↦ f (a, b)) s t = f '' s ×ˢ t",
  "tactic-prompt":
  "lemma {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : α × β → γ)  (s : Set α)  (t : Set β) : image2 (fun a b ↦ f (a, b)) s t = f '' s ×ˢ t := by simp [←image_uncurry_prod]; sorry",
  "name": "image2_curry",
  "kind": "lemma",
  "first-tactic": "simp [←image_uncurry_prod]",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : α × β → γ)  (s : Set α)  (t : Set β) : image2 (fun a b ↦ f (a, b)) s t = f '' s ×ˢ t",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : α × β → γ)  (s : Set α)  (t : Set β)"},
 {"type": "image2 f (s ∪ s') t = image2 f s t ∪ image2 f s' t",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} : image2 f (s ∪ s') t = image2 f s t ∪ image2 f s' t := by ext c; sorry",
  "name": "image2_union_left",
  "kind": "theorem",
  "first-tactic": "ext c",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} : image2 f (s ∪ s') t = image2 f s t ∪ image2 f s' t",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ}"},
 {"type": "image2 f s (t ∪ t') = image2 f s t ∪ image2 f s t'",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} : image2 f s (t ∪ t') = image2 f s t ∪ image2 f s t' := by ext c; sorry",
  "name": "image2_union_right",
  "kind": "theorem",
  "first-tactic": "ext c",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} : image2 f s (t ∪ t') = image2 f s t ∪ image2 f s t'",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ}"},
 {"type": "image2 f (s ∩ s') t = image2 f s t ∩ image2 f s' t",
  "tactic-prompt":
  "lemma {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (hf : Injective2 f) : image2 f (s ∩ s') t = image2 f s t ∩ image2 f s' t := by simp_rw [←image_uncurry_prod]; sorry",
  "name": "image2_inter_left",
  "kind": "lemma",
  "first-tactic": "simp_rw [←image_uncurry_prod]",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (hf : Injective2 f) : image2 f (s ∩ s') t = image2 f s t ∩ image2 f s' t",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (hf : Injective2 f)"},
 {"type": "image2 f s (t ∩ t') = image2 f s t ∩ image2 f s t'",
  "tactic-prompt":
  "lemma {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (hf : Injective2 f) : image2 f s (t ∩ t') = image2 f s t ∩ image2 f s t' := by simp_rw [←image_uncurry_prod]; sorry",
  "name": "image2_inter_right",
  "kind": "lemma",
  "first-tactic": "simp_rw [←image_uncurry_prod]",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (hf : Injective2 f) : image2 f s (t ∩ t') = image2 f s t ∩ image2 f s t'",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (hf : Injective2 f)"},
 {"type": "image2 f s t = ∅ ↔ s = ∅ ∨ t = ∅",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} : image2 f s t = ∅ ↔ s = ∅ ∨ t = ∅ := by rw [← not_nonempty_iff_eq_empty]; sorry",
  "name": "image2_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "rw [← not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} : image2 f s t = ∅ ↔ s = ∅ ∨ t = ∅",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ}"},
 {"type": "image2 f (s ∩ s') t ⊆ image2 f s t ∩ image2 f s' t",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} : image2 f (s ∩ s') t ⊆ image2 f s t ∩ image2 f s' t := by rintro _ ⟨a, b, ⟨h1a, h2a⟩, hb, rfl⟩; sorry",
  "name": "image2_inter_subset_left",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨a, b, ⟨h1a, h2a⟩, hb, rfl⟩",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} : image2 f (s ∩ s') t ⊆ image2 f s t ∩ image2 f s' t",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ}"},
 {"type": "image2 f s (t ∩ t') ⊆ image2 f s t ∩ image2 f s t'",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} : image2 f s (t ∩ t') ⊆ image2 f s t ∩ image2 f s t' := by rintro _ ⟨a, b, ha, ⟨h1b, h2b⟩, rfl⟩; sorry",
  "name": "image2_inter_subset_right",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨a, b, ha, ⟨h1b, h2b⟩, rfl⟩",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} : image2 f s (t ∩ t') ⊆ image2 f s t ∩ image2 f s t'",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ}"},
 {"type": "image2 f {a} {b} = {f a b}",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} : image2 f {a} {b} = {f a b} := by simp; sorry",
  "name": "image2_singleton",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} : image2 f {a} {b} = {f a b}",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ}"},
 {"type": "image2 f s t = image2 f' s t",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image2 f s t = image2 f' s t := by ext; sorry",
  "name": "image2_congr",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image2 f s t = image2 f' s t",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b)"},
 {"type": "image3 g s t u = image3 g' s t u",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (h : ∀ a ∈ s, ∀ b ∈ t, ∀ c ∈ u, g a b c = g' a b c) : image3 g s t u = image3 g' s t u := by ext x; sorry",
  "name": "image3_congr",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (h : ∀ a ∈ s, ∀ b ∈ t, ∀ c ∈ u, g a b c = g' a b c) : image3 g s t u = image3 g' s t u",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (h : ∀ a ∈ s, ∀ b ∈ t, ∀ c ∈ u, g a b c = g' a b c)"},
 {"type": "image2 f (image2 g s t) u = image3 (fun a b c => f (g a b) c) s t u",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : δ → γ → ε)  (g : α → β → δ) : image2 f (image2 g s t) u = image3 (fun a b c => f (g a b) c) s t u := by ext; sorry",
  "name": "image2_image2_left",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : δ → γ → ε)  (g : α → β → δ) : image2 f (image2 g s t) u = image3 (fun a b c => f (g a b) c) s t u",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : δ → γ → ε)  (g : α → β → δ)"},
 {"type": "image2 f s (image2 g t u) = image3 (fun a b c => f a (g b c)) s t u",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : α → δ → ε)  (g : β → γ → δ) : image2 f s (image2 g t u) = image3 (fun a b c => f a (g b c)) s t u := by ext; sorry",
  "name": "image2_image2_right",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : α → δ → ε)  (g : β → γ → δ) : image2 f s (image2 g t u) = image3 (fun a b c => f a (g b c)) s t u",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : α → δ → ε)  (g : β → γ → δ)"},
 {"type": "g '' image2 f s t = image2 (fun a b => g (f a b)) s t",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : α → β → γ)  (g : γ → δ) : g '' image2 f s t = image2 (fun a b => g (f a b)) s t := by ext; sorry",
  "name": "image_image2",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : α → β → γ)  (g : γ → δ) : g '' image2 f s t = image2 (fun a b => g (f a b)) s t",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : α → β → γ)  (g : γ → δ)"},
 {"type": "image2 f (g '' s) t = image2 (fun a b => f (g a) b) s t",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : γ → β → δ)  (g : α → γ) : image2 f (g '' s) t = image2 (fun a b => f (g a) b) s t := by ext; sorry",
  "name": "image2_image_left",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : γ → β → δ)  (g : α → γ) : image2 f (g '' s) t = image2 (fun a b => f (g a) b) s t",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : γ → β → δ)  (g : α → γ)"},
 {"type": "image2 f s (g '' t) = image2 (fun a b => f a (g b)) s t",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : α → γ → δ)  (g : β → γ) : image2 f s (g '' t) = image2 (fun a b => f a (g b)) s t := by ext; sorry",
  "name": "image2_image_right",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : α → γ → δ)  (g : β → γ) : image2 f s (g '' t) = image2 (fun a b => f a (g b)) s t",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : α → γ → δ)  (g : β → γ)"},
 {"type": "image2 f s t = image2 (fun a b => f b a) t s",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : α → β → γ)  (s : Set α)  (t : Set β) : image2 f s t = image2 (fun a b => f b a) t s := by ext; sorry",
  "name": "image2_swap",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : α → β → γ)  (s : Set α)  (t : Set β) : image2 f s t = image2 (fun a b => f b a) t s",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (f : α → β → γ)  (s : Set α)  (t : Set β)"},
 {"type": "image2 (fun x _ => x) s t = s",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (h : t.Nonempty) : image2 (fun x _ => x) s t = s := by simp [nonempty_def.mp h]; sorry",
  "name": "image2_left",
  "kind": "theorem",
  "first-tactic": "simp [nonempty_def.mp h]",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (h : t.Nonempty) : image2 (fun x _ => x) s t = s",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (h : t.Nonempty)"},
 {"type": "image2 (fun _ y => y) s t = t",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (h : s.Nonempty) : image2 (fun _ y => y) s t = t := by simp [nonempty_def.mp h]; sorry",
  "name": "image2_right",
  "kind": "theorem",
  "first-tactic": "simp [nonempty_def.mp h]",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (h : s.Nonempty) : image2 (fun _ y => y) s t = t",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} (h : s.Nonempty)"},
 {"type": "image2 f (image2 g s t) u = image2 f' s (image2 g' t u)",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {f : δ → γ → ε}  {g : α → β → δ}  {f' : α → ε' → ε}  {g' : β → γ → ε'}      (h_assoc : ∀ a b c, f (g a b) c = f' a (g' b c)) : image2 f (image2 g s t) u = image2 f' s (image2 g' t u) := by simp only [image2_image2_left]; sorry",
  "name": "image2_assoc",
  "kind": "theorem",
  "first-tactic": "simp only [image2_image2_left]",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {f : δ → γ → ε}  {g : α → β → δ}  {f' : α → ε' → ε}  {g' : β → γ → ε'}      (h_assoc : ∀ a b c, f (g a b) c = f' a (g' b c)) : image2 f (image2 g s t) u = image2 f' s (image2 g' t u)",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {f : δ → γ → ε}  {g : α → β → δ}  {f' : α → ε' → ε}  {g' : β → γ → ε'}      (h_assoc : ∀ a b c, f (g a b) c = f' a (g' b c))"},
 {"type": "image2 f s (image2 g t u) = image2 g' t (image2 f' s u)",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {f : α → δ → ε}  {g : β → γ → δ}  {f' : α → γ → δ'}  {g' : β → δ' → ε}      (h_left_comm : ∀ a b c, f a (g b c) = g' b (f' a c)) : image2 f s (image2 g t u) = image2 g' t (image2 f' s u) := by rw [image2_swap f']; sorry",
  "name": "image2_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [image2_swap f']",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {f : α → δ → ε}  {g : β → γ → δ}  {f' : α → γ → δ'}  {g' : β → δ' → ε}      (h_left_comm : ∀ a b c, f a (g b c) = g' b (f' a c)) : image2 f s (image2 g t u) = image2 g' t (image2 f' s u)",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {f : α → δ → ε}  {g : β → γ → δ}  {f' : α → γ → δ'}  {g' : β → δ' → ε}      (h_left_comm : ∀ a b c, f a (g b c) = g' b (f' a c))"},
 {"type": "image2 f (image2 g s t) u = image2 g' (image2 f' s u) t",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {f : δ → γ → ε}  {g : α → β → δ}  {f' : α → γ → δ'}  {g' : δ' → β → ε}      (h_right_comm : ∀ a b c, f (g a b) c = g' (f' a c) b) : image2 f (image2 g s t) u = image2 g' (image2 f' s u) t := by rw [image2_swap g]; sorry",
  "name": "image2_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [image2_swap g]",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {f : δ → γ → ε}  {g : α → β → δ}  {f' : α → γ → δ'}  {g' : δ' → β → ε}      (h_right_comm : ∀ a b c, f (g a b) c = g' (f' a c) b) : image2 f (image2 g s t) u = image2 g' (image2 f' s u) t",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {f : δ → γ → ε}  {g : α → β → δ}  {f' : α → γ → δ'}  {g' : δ' → β → ε}      (h_right_comm : ∀ a b c, f (g a b) c = g' (f' a c) b)"},
 {"type": "(image2 f s t).image g = image2 f' (s.image g₁) (t.image g₂)",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {g : γ → δ}  {f' : α' → β' → δ}  {g₁ : α → α'}  {g₂ : β → β'}      (h_distrib : ∀ a b, g (f a b) = f' (g₁ a) (g₂ b)) : (image2 f s t).image g = image2 f' (s.image g₁) (t.image g₂) := by simp_rw [image_image2]; sorry",
  "name": "image_image2_distrib",
  "kind": "theorem",
  "first-tactic": "simp_rw [image_image2]",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {g : γ → δ}  {f' : α' → β' → δ}  {g₁ : α → α'}  {g₂ : β → β'}      (h_distrib : ∀ a b, g (f a b) = f' (g₁ a) (g₂ b)) : (image2 f s t).image g = image2 f' (s.image g₁) (t.image g₂)",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {g : γ → δ}  {f' : α' → β' → δ}  {g₁ : α → α'}  {g₂ : β → β'}      (h_distrib : ∀ a b, g (f a b) = f' (g₁ a) (g₂ b))"},
 {"type":
  "image2 f s (image2 g t u) ⊆ image2 g' (image2 f₁ s t) (image2 f₂ s u)",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {f : α → δ → ε}  {g : β → γ → δ}  {f₁ : α → β → β'}      {f₂ : α → γ → γ'}  {g' : β' → γ' → ε}  (h_distrib : ∀ a b c, f a (g b c) = g' (f₁ a b) (f₂ a c)) : image2 f s (image2 g t u) ⊆ image2 g' (image2 f₁ s t) (image2 f₂ s u) := by rintro _ ⟨a, _, ha, ⟨b, c, hb, hc, rfl⟩, rfl⟩; sorry",
  "name": "image2_distrib_subset_left",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨a, _, ha, ⟨b, c, hb, hc, rfl⟩, rfl⟩",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {f : α → δ → ε}  {g : β → γ → δ}  {f₁ : α → β → β'}      {f₂ : α → γ → γ'}  {g' : β' → γ' → ε}  (h_distrib : ∀ a b c, f a (g b c) = g' (f₁ a b) (f₂ a c)) : image2 f s (image2 g t u) ⊆ image2 g' (image2 f₁ s t) (image2 f₂ s u)",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {f : α → δ → ε}  {g : β → γ → δ}  {f₁ : α → β → β'}      {f₂ : α → γ → γ'}  {g' : β' → γ' → ε}  (h_distrib : ∀ a b c, f a (g b c) = g' (f₁ a b) (f₂ a c))"},
 {"type":
  "image2 f (image2 g s t) u ⊆ image2 g' (image2 f₁ s u) (image2 f₂ t u)",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {f : δ → γ → ε}  {g : α → β → δ}  {f₁ : α → γ → α'}      {f₂ : β → γ → β'}  {g' : α' → β' → ε}  (h_distrib : ∀ a b c, f (g a b) c = g' (f₁ a c) (f₂ b c)) : image2 f (image2 g s t) u ⊆ image2 g' (image2 f₁ s u) (image2 f₂ t u) := by rintro _ ⟨_, c, ⟨a, b, ha, hb, rfl⟩, hc, rfl⟩; sorry",
  "name": "image2_distrib_subset_right",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨_, c, ⟨a, b, ha, hb, rfl⟩, hc, rfl⟩",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {f : δ → γ → ε}  {g : α → β → δ}  {f₁ : α → γ → α'}      {f₂ : β → γ → β'}  {g' : α' → β' → ε}  (h_distrib : ∀ a b c, f (g a b) c = g' (f₁ a c) (f₂ b c)) : image2 f (image2 g s t) u ⊆ image2 g' (image2 f₁ s u) (image2 f₂ t u)",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {f : δ → γ → ε}  {g : α → β → δ}  {f₁ : α → γ → α'}      {f₂ : β → γ → β'}  {g' : α' → β' → ε}  (h_distrib : ∀ a b c, f (g a b) c = g' (f₁ a c) (f₂ b c))"},
 {"type": "(image2 f s t).image g = image2 f' (t.image g₁) (s.image g₂)",
  "tactic-prompt":
  "theorem {α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {g : γ → δ}  {f' : β' → α' → δ}  {g₁ : β → β'}  {g₂ : α → α'}      (h_antidistrib : ∀ a b, g (f a b) = f' (g₁ b) (g₂ a)) : (image2 f s t).image g = image2 f' (t.image g₁) (s.image g₂) := by rw [image2_swap f]; sorry",
  "name": "image_image2_antidistrib",
  "kind": "theorem",
  "first-tactic": "rw [image2_swap f]",
  "core-prompt":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {g : γ → δ}  {f' : β' → α' → δ}  {g₁ : β → β'}  {g₂ : α → α'}      (h_antidistrib : ∀ a b, g (f a b) = f' (g₁ b) (g₂ a)) : (image2 f s t).image g = image2 f' (t.image g₁) (s.image g₂)",
  "args":
  "{α α' β β' γ γ' δ δ' ε ε' : Type _}  {f f' : α → β → γ}  {g g' : α → β → γ → δ} {s s' : Set α}  {t t' : Set β}  {u u' : Set γ}  {a a' : α}  {b b' : β}  {c c' : γ}  {d d' : δ} {g : γ → δ}  {f' : β' → α' → δ}  {g₁ : β → β'}  {g₂ : α → α'}      (h_antidistrib : ∀ a b, g (f a b) = f' (g₁ b) (g₂ a))"},
 {"type": "x ∈ s ↔ s.boolIndicator x = true",
  "tactic-prompt":
  "theorem {α : Type _}  (s : Set α) (x : α) : x ∈ s ↔ s.boolIndicator x = true := by unfold boolIndicator; sorry",
  "name": "mem_iff_boolIndicator",
  "kind": "theorem",
  "first-tactic": "unfold boolIndicator",
  "core-prompt":
  "{α : Type _}  (s : Set α) (x : α) : x ∈ s ↔ s.boolIndicator x = true",
  "args": "{α : Type _}  (s : Set α) (x : α)"},
 {"type": "x ∉ s ↔ s.boolIndicator x = false",
  "tactic-prompt":
  "theorem {α : Type _}  (s : Set α) (x : α) : x ∉ s ↔ s.boolIndicator x = false := by unfold boolIndicator; sorry",
  "name": "not_mem_iff_boolIndicator",
  "kind": "theorem",
  "first-tactic": "unfold boolIndicator",
  "core-prompt":
  "{α : Type _}  (s : Set α) (x : α) : x ∉ s ↔ s.boolIndicator x = false",
  "args": "{α : Type _}  (s : Set α) (x : α)"},
 {"type":
  "s.boolIndicator ⁻¹' t = (if true ∈ t then s else ∅) ∪ if false ∈ t then sᶜ else ∅",
  "tactic-prompt":
  "theorem {α : Type _}  (s : Set α) (t : Set Bool) : s.boolIndicator ⁻¹' t = (if true ∈ t then s else ∅) ∪ if false ∈ t then sᶜ else ∅ := by ext x; sorry",
  "name": "preimage_boolIndicator_eq_union",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α : Type _}  (s : Set α) (t : Set Bool) : s.boolIndicator ⁻¹' t = (if true ∈ t then s else ∅) ∪ if false ∈ t then sᶜ else ∅",
  "args": "{α : Type _}  (s : Set α) (t : Set Bool)"},
 {"type":
  "s.boolIndicator ⁻¹' t = univ ∨\n      s.boolIndicator ⁻¹' t = s ∨ s.boolIndicator ⁻¹' t = sᶜ ∨ s.boolIndicator ⁻¹' t = ∅",
  "tactic-prompt":
  "theorem {α : Type _}  (s : Set α) (t : Set Bool) : s.boolIndicator ⁻¹' t = univ ∨\n      s.boolIndicator ⁻¹' t = s ∨ s.boolIndicator ⁻¹' t = sᶜ ∨ s.boolIndicator ⁻¹' t = ∅ := by simp only [preimage_boolIndicator_eq_union]; sorry",
  "name": "preimage_boolIndicator",
  "kind": "theorem",
  "first-tactic": "simp only [preimage_boolIndicator_eq_union]",
  "core-prompt":
  "{α : Type _}  (s : Set α) (t : Set Bool) : s.boolIndicator ⁻¹' t = univ ∨\n      s.boolIndicator ⁻¹' t = s ∨ s.boolIndicator ⁻¹' t = sᶜ ∨ s.boolIndicator ⁻¹' t = ∅",
  "args": "{α : Type _}  (s : Set α) (t : Set Bool)"},
 {"type": "range (Sigma.mk i : α i → Sigma α) = Sigma.fst ⁻¹' {i}",
  "tactic-prompt":
  "theorem {ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} (i : ι) : range (Sigma.mk i : α i → Sigma α) = Sigma.fst ⁻¹' {i} := by apply Subset.antisymm; sorry",
  "name": "range_sigmaMk",
  "kind": "theorem",
  "first-tactic": "apply Subset.antisymm",
  "core-prompt":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} (i : ι) : range (Sigma.mk i : α i → Sigma α) = Sigma.fst ⁻¹' {i}",
  "args":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} (i : ι)"},
 {"type": "Sigma.mk i ⁻¹' (Sigma.mk j '' s) = ∅",
  "tactic-prompt":
  "theorem {ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} (h : i ≠ j)  (s : Set (α j)) : Sigma.mk i ⁻¹' (Sigma.mk j '' s) = ∅ := by ext x; sorry",
  "name": "preimage_image_sigmaMk_of_ne",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} (h : i ≠ j)  (s : Set (α j)) : Sigma.mk i ⁻¹' (Sigma.mk j '' s) = ∅",
  "args":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} (h : i ≠ j)  (s : Set (α j))"},
 {"type": "Sigma.mk i '' (g i ⁻¹' s) = Sigma.map f g ⁻¹' (Sigma.mk (f i) '' s)",
  "tactic-prompt":
  "theorem {ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} {β : ι' → Type _}  {f : ι → ι'}  (hf : Function.Injective f)      (g : ∀ i, α i → β (f i))  (i : ι)  (s : Set (β (f i))) : Sigma.mk i '' (g i ⁻¹' s) = Sigma.map f g ⁻¹' (Sigma.mk (f i) '' s) := by refine' (image_sigmaMk_preimage_sigmaMap_subset f g i s).antisymm _; sorry",
  "name": "image_sigmaMk_preimage_sigmaMap",
  "kind": "theorem",
  "first-tactic":
  "refine' (image_sigmaMk_preimage_sigmaMap_subset f g i s).antisymm _",
  "core-prompt":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} {β : ι' → Type _}  {f : ι → ι'}  (hf : Function.Injective f)      (g : ∀ i, α i → β (f i))  (i : ι)  (s : Set (β (f i))) : Sigma.mk i '' (g i ⁻¹' s) = Sigma.map f g ⁻¹' (Sigma.mk (f i) '' s)",
  "args":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} {β : ι' → Type _}  {f : ι → ι'}  (hf : Function.Injective f)      (g : ∀ i, α i → β (f i))  (i : ι)  (s : Set (β (f i)))"},
 {"type":
  "(s.Sigma fun i ↦ ({a i} : Set (α i))) = (fun i ↦ Sigma.mk i <| a i) '' s",
  "tactic-prompt":
  "theorem {ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} {a : ∀ i, α i} : (s.Sigma fun i ↦ ({a i} : Set (α i))) = (fun i ↦ Sigma.mk i <| a i) '' s := by ext ⟨x, y⟩; sorry",
  "name": "sigma_singleton",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} {a : ∀ i, α i} : (s.Sigma fun i ↦ ({a i} : Set (α i))) = (fun i ↦ Sigma.mk i <| a i) '' s",
  "args":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} {a : ∀ i, α i}"},
 {"type": "(({i} : Set ι).Sigma fun i ↦ ({a i} : Set (α i))) = {⟨i, a i⟩}",
  "tactic-prompt":
  "theorem {ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} {a : ∀ i, α i} : (({i} : Set ι).Sigma fun i ↦ ({a i} : Set (α i))) = {⟨i, a i⟩} := by rw [sigma_singleton]; sorry",
  "name": "singleton_sigma_singleton",
  "kind": "theorem",
  "first-tactic": "rw [sigma_singleton]",
  "core-prompt":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} {a : ∀ i, α i} : (({i} : Set ι).Sigma fun i ↦ ({a i} : Set (α i))) = {⟨i, a i⟩}",
  "args":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} {a : ∀ i, α i}"},
 {"type": "s₁.Sigma t₁ ∩ s₂.Sigma t₂ = (s₁ ∩ s₂).Sigma fun i ↦ t₁ i ∩ t₂ i",
  "tactic-prompt":
  "theorem {ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} : s₁.Sigma t₁ ∩ s₂.Sigma t₂ = (s₁ ∩ s₂).Sigma fun i ↦ t₁ i ∩ t₂ i := by ext ⟨x, y⟩; sorry",
  "name": "sigma_inter_sigma",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} : s₁.Sigma t₁ ∩ s₂.Sigma t₂ = (s₁ ∩ s₂).Sigma fun i ↦ t₁ i ∩ t₂ i",
  "args":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i}"},
 {"type": "(insert i s).Sigma t = Sigma.mk i '' t i ∪ s.Sigma t",
  "tactic-prompt":
  "theorem {ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} : (insert i s).Sigma t = Sigma.mk i '' t i ∪ s.Sigma t := by rw [insert_eq]; sorry",
  "name": "insert_sigma",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} : (insert i s).Sigma t = Sigma.mk i '' t i ∪ s.Sigma t",
  "args":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i}"},
 {"type":
  "(s.Sigma fun i ↦ insert (a i) (t i)) = (fun i ↦ ⟨i, a i⟩) '' s ∪ s.Sigma t",
  "tactic-prompt":
  "theorem {ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} {a : ∀ i, α i} : (s.Sigma fun i ↦ insert (a i) (t i)) = (fun i ↦ ⟨i, a i⟩) '' s ∪ s.Sigma t := by simp_rw [insert_eq]; sorry",
  "name": "sigma_insert",
  "kind": "theorem",
  "first-tactic": "simp_rw [insert_eq]",
  "core-prompt":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} {a : ∀ i, α i} : (s.Sigma fun i ↦ insert (a i) (t i)) = (fun i ↦ ⟨i, a i⟩) '' s ∪ s.Sigma t",
  "args":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} {a : ∀ i, α i}"},
 {"type": "Sigma.mk i ⁻¹' s.Sigma t = if i ∈ s then t i else ∅",
  "tactic-prompt":
  "theorem {ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} [DecidablePred (· ∈ s)] : Sigma.mk i ⁻¹' s.Sigma t = if i ∈ s then t i else ∅ := by split_ifs; sorry",
  "name": "mk_preimage_sigma_eq_if",
  "kind": "theorem",
  "first-tactic": "split_ifs",
  "core-prompt":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} [DecidablePred (· ∈ s)] : Sigma.mk i ⁻¹' s.Sigma t = if i ∈ s then t i else ∅",
  "args":
  "{ι ι' : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}    {u : Set (Σ i, α i)}  {x : Σ i, α i}  {i j : ι}  {a : α i} [DecidablePred (· ∈ s)]"},
 {"type": "(∀ a ∈ s, ∀ (b), p a b) ↔ ∀ (b), ∀ a ∈ s, p a b",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {p : α → β → Prop} : (∀ a ∈ s, ∀ (b), p a b) ↔ ∀ (b), ∀ a ∈ s, p a b := by tauto; sorry",
  "name": "forall_in_swap",
  "kind": "theorem",
  "first-tactic": "tauto",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {p : α → β → Prop} : (∀ a ∈ s, ∀ (b), p a b) ↔ ∀ (b), ∀ a ∈ s, p a b",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {p : α → β → Prop}"},
 {"type": "¬s ⊆ t ↔ ∃ a ∈ s, a ∉ t",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : ¬s ⊆ t ↔ ∃ a ∈ s, a ∉ t := by simp only [subset_def]; sorry",
  "name": "not_subset",
  "kind": "theorem",
  "first-tactic": "simp only [subset_def]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : ¬s ⊆ t ↔ ∃ a ∈ s, a ∉ t",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later"},
 {"type": "(s ∩ t).Nonempty ↔ ∃ x ∈ s, x ∈ t",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : (s ∩ t).Nonempty ↔ ∃ x ∈ s, x ∈ t := by simp_rw [inter_nonempty]; sorry",
  "name": "inter_nonempty_iff_exists_left",
  "kind": "theorem",
  "first-tactic": "simp_rw [inter_nonempty]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : (s ∩ t).Nonempty ↔ ∃ x ∈ s, x ∈ t",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later"},
 {"type": "(s ∩ t).Nonempty ↔ ∃ x ∈ t, x ∈ s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : (s ∩ t).Nonempty ↔ ∃ x ∈ t, x ∈ s := by simp_rw [inter_nonempty]; sorry",
  "name": "inter_nonempty_iff_exists_right",
  "kind": "theorem",
  "first-tactic": "simp_rw [inter_nonempty]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : (s ∩ t).Nonempty ↔ ∃ x ∈ t, x ∈ s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later"},
 {"type": "¬s.Nonempty ↔ s = ∅",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s : Set α} : ¬s.Nonempty ↔ s = ∅ := by simp only [Set.Nonempty]; sorry",
  "name": "not_nonempty_iff_eq_empty",
  "kind": "theorem",
  "first-tactic": "simp only [Set.Nonempty]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s : Set α} : ¬s.Nonempty ↔ s = ∅",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s : Set α}"},
 {"type": "s.Nonempty → s = univ",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later [Subsingleton α] : s.Nonempty → s = univ := by rintro ⟨x, hx⟩; sorry",
  "name": "Nonempty.eq_univ",
  "kind": "theorem",
  "first-tactic": "rintro ⟨x, hx⟩",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later [Subsingleton α] : s.Nonempty → s = univ",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later [Subsingleton α]"},
 {"type": "s ≠ univ ↔ ∃ a, a ∉ s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {α : Type _}  (s : Set α) : s ≠ univ ↔ ∃ a, a ∉ s := by rw [← not_forall]; sorry",
  "name": "ne_univ_iff_exists_not_mem",
  "kind": "theorem",
  "first-tactic": "rw [← not_forall]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {α : Type _}  (s : Set α) : s ≠ univ ↔ ∃ a, a ∉ s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {α : Type _}  (s : Set α)"},
 {"type": "¬s ⊆ t ↔ ∃ x, x ∈ s ∧ x ∉ t",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {α : Type _}  {s t : Set α} : ¬s ⊆ t ↔ ∃ x, x ∈ s ∧ x ∉ t := by simp [subset_def]; sorry",
  "name": "not_subset_iff_exists_mem_not_mem",
  "kind": "theorem",
  "first-tactic": "simp [subset_def]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {α : Type _}  {s t : Set α} : ¬s ⊆ t ↔ ∃ x, x ∈ s ∧ x ∉ t",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {α : Type _}  {s t : Set α}"},
 {"type": "s ∪ t = ∅ ↔ s = ∅ ∧ t = ∅",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s t : Set α} : s ∪ t = ∅ ↔ s = ∅ ∧ t = ∅ := by simp only [← subset_empty_iff]; sorry",
  "name": "union_empty_iff",
  "kind": "theorem",
  "first-tactic": "simp only [← subset_empty_iff]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s t : Set α} : s ∪ t = ∅ ↔ s = ∅ ∧ t = ∅",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s t : Set α}"},
 {"type": "insert a s ⊆ t ↔ a ∈ t ∧ s ⊆ t",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : insert a s ⊆ t ↔ a ∈ t ∧ s ⊆ t := by simp only [subset_def]; sorry",
  "name": "insert_subset",
  "kind": "theorem",
  "first-tactic": "simp only [subset_def]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : insert a s ⊆ t ↔ a ∈ t ∧ s ⊆ t",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later"},
 {"type": "insert a s ⊆ insert a t ↔ s ⊆ t",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (ha : a ∉ s) : insert a s ⊆ insert a t ↔ s ⊆ t := by refine' ⟨fun h x hx => _, insert_subset_insert⟩; sorry",
  "name": "insert_subset_insert_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h x hx => _, insert_subset_insert⟩",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (ha : a ∉ s) : insert a s ⊆ insert a t ↔ s ⊆ t",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (ha : a ∉ s)"},
 {"type": "s ⊂ t ↔ ∃ (a : α) (_ : a ∉ s), insert a s ⊆ t",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s t : Set α} : s ⊂ t ↔ ∃ (a : α) (_ : a ∉ s), insert a s ⊆ t := by simp only [insert_subset]; sorry",
  "name": "ssubset_iff_insert",
  "kind": "theorem",
  "first-tactic": "simp only [insert_subset]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s t : Set α} : s ⊂ t ↔ ∃ (a : α) (_ : a ∉ s), insert a s ⊆ t",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s t : Set α}"},
 {"type": "(∃ x ∈ insert a s, P x) ↔ (P a ∨ ∃ x ∈ s, P x)",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {P : α → Prop}  {a : α}  {s : Set α} : (∃ x ∈ insert a s, P x) ↔ (P a ∨ ∃ x ∈ s, P x) := by simp [mem_insert_iff]; sorry",
  "name": "bex_insert_iff",
  "kind": "theorem",
  "first-tactic": "simp [mem_insert_iff]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {P : α → Prop}  {a : α}  {s : Set α} : (∃ x ∈ insert a s, P x) ↔ (P a ∨ ∃ x ∈ s, P x)",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {P : α → Prop}  {a : α}  {s : Set α}"},
 {"type": "({a} ∩ s).Nonempty ↔ a ∈ s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : ({a} ∩ s).Nonempty ↔ a ∈ s := by simp only [Set.Nonempty]; sorry",
  "name": "singleton_inter_nonempty",
  "kind": "theorem",
  "first-tactic": "simp only [Set.Nonempty]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : ({a} ∩ s).Nonempty ↔ a ∈ s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later"},
 {"type": "(s ∩ {a}).Nonempty ↔ a ∈ s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : (s ∩ {a}).Nonempty ↔ a ∈ s := by rw [inter_comm]; sorry",
  "name": "inter_singleton_nonempty",
  "kind": "theorem",
  "first-tactic": "rw [inter_comm]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : (s ∩ {a}).Nonempty ↔ a ∈ s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later"},
 {"type": "s ∩ {a} = ∅ ↔ a ∉ s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : s ∩ {a} = ∅ ↔ a ∉ s := by rw [inter_comm]; sorry",
  "name": "inter_singleton_eq_empty",
  "kind": "theorem",
  "first-tactic": "rw [inter_comm]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : s ∩ {a} = ∅ ↔ a ∉ s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later"},
 {"type": "({x, y} : Set α) = {z, w} ↔ x = z ∧ y = w ∨ x = w ∧ y = z",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {x y z w : α} : ({x, y} : Set α) = {z, w} ↔ x = z ∧ y = w ∨ x = w ∧ y = z := by simp only [Set.Subset.antisymm_iff]; sorry",
  "name": "pair_eq_pair_iff",
  "kind": "theorem",
  "first-tactic": "simp only [Set.Subset.antisymm_iff]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {x y z w : α} : ({x, y} : Set α) = {z, w} ↔ x = z ∧ y = w ∨ x = w ∧ y = z",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {x y z w : α}"},
 {"type": "{ x ∈ s | p x } = { x ∈ s | q x } ↔ ∀ x ∈ s, p x ↔ q x",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  {p q : α → Prop}  {x : α} : { x ∈ s | p x } = { x ∈ s | q x } ↔ ∀ x ∈ s, p x ↔ q x := by simp_rw [ext_iff]; sorry",
  "name": "sep_ext_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [ext_iff]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  {p q : α → Prop}  {x : α} : { x ∈ s | p x } = { x ∈ s | q x } ↔ ∀ x ∈ s, p x ↔ q x",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  {p q : α → Prop}  {x : α}"},
 {"type": "{ x ∈ s | p x } = s ↔ ∀ x ∈ s, p x",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  {p q : α → Prop}  {x : α} : { x ∈ s | p x } = s ↔ ∀ x ∈ s, p x := by simp_rw [ext_iff]; sorry",
  "name": "sep_eq_self_iff_mem_true",
  "kind": "theorem",
  "first-tactic": "simp_rw [ext_iff]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  {p q : α → Prop}  {x : α} : { x ∈ s | p x } = s ↔ ∀ x ∈ s, p x",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  {p q : α → Prop}  {x : α}"},
 {"type": "{ x ∈ s | p x } = ∅ ↔ ∀ x ∈ s, ¬p x",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  {p q : α → Prop}  {x : α} : { x ∈ s | p x } = ∅ ↔ ∀ x ∈ s, ¬p x := by simp_rw [ext_iff]; sorry",
  "name": "sep_eq_empty_iff_mem_false",
  "kind": "theorem",
  "first-tactic": "simp_rw [ext_iff]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  {p q : α → Prop}  {x : α} : { x ∈ s | p x } = ∅ ↔ ∀ x ∈ s, ¬p x",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  {p q : α → Prop}  {x : α}"},
 {"type": "s ⊆ {x} ↔ s = ∅ ∨ s = {x}",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s : Set α}  {x : α} : s ⊆ {x} ↔ s = ∅ ∨ s = {x} := by obtain rfl | hs := s.eq_empty_or_nonempty; sorry",
  "name": "subset_singleton_iff_eq",
  "kind": "theorem",
  "first-tactic": "obtain rfl | hs := s.eq_empty_or_nonempty",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s : Set α}  {x : α} : s ⊆ {x} ↔ s = ∅ ∨ s = {x}",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s : Set α}  {x : α}"},
 {"type": "s ⊂ {x} ↔ s = ∅",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s : Set α}  {x : α} : s ⊂ {x} ↔ s = ∅ := by rw [ssubset_iff_subset_ne]; sorry",
  "name": "ssubset_singleton_iff",
  "kind": "theorem",
  "first-tactic": "rw [ssubset_iff_subset_ne]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s : Set α}  {x : α} : s ⊂ {x} ↔ s = ∅",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s : Set α}  {x : α}"},
 {"type": "Disjoint s t ↔ ∀ ⦃a⦄, a ∈ t → a ∉ s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : Disjoint s t ↔ ∀ ⦃a⦄, a ∈ t → a ∉ s := by rw [Disjoint.comm]; sorry",
  "name": "disjoint_right",
  "kind": "theorem",
  "first-tactic": "rw [Disjoint.comm]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : Disjoint s t ↔ ∀ ⦃a⦄, a ∈ t → a ∉ s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later"},
 {"type": "sᶜ ∪ s = univ",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s : Set α) : sᶜ ∪ s = univ := by rw [union_comm]; sorry",
  "name": "compl_union_self",
  "kind": "theorem",
  "first-tactic": "rw [union_comm]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s : Set α) : sᶜ ∪ s = univ",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s : Set α)"},
 {"type": "s \\ t = tᶜ ∩ s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s t : Set α} : s \\ t = tᶜ ∩ s := by rw [diff_eq]; sorry",
  "name": "diff_eq_compl_inter",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s t : Set α} : s \\ t = tᶜ ∩ s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s t : Set α}"},
 {"type": "s \\ t ∪ s ∩ t = s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s t : Set α) : s \\ t ∪ s ∩ t = s := by rw [union_comm]; sorry",
  "name": "diff_union_inter",
  "kind": "theorem",
  "first-tactic": "rw [union_comm]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s t : Set α) : s \\ t ∪ s ∩ t = s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s t : Set α)"},
 {"type": "s \\ {x} ⊆ t ↔ s ⊆ insert x t",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {x : α}  {s t : Set α} : s \\ {x} ⊆ t ↔ s ⊆ insert x t := by rw [← union_singleton]; sorry",
  "name": "diff_singleton_subset_iff",
  "kind": "theorem",
  "first-tactic": "rw [← union_singleton]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {x : α}  {s t : Set α} : s \\ {x} ⊆ t ↔ s ⊆ insert x t",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {x : α}  {s t : Set α}"},
 {"type": "s ⊆ insert x (s \\ {x})",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (x : α)  (s : Set α) : s ⊆ insert x (s \\ {x}) := by rw [← diff_singleton_subset_iff]; sorry",
  "name": "subset_insert_diff_singleton",
  "kind": "theorem",
  "first-tactic": "rw [← diff_singleton_subset_iff]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (x : α)  (s : Set α) : s ⊆ insert x (s \\ {x})",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (x : α)  (s : Set α)"},
 {"type": "insert a s \\ {a} = s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {a : α}  {s : Set α}  (h : a ∉ s) : insert a s \\ {a} = s := by ext x; sorry",
  "name": "insert_diff_self_of_not_mem",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {a : α}  {s : Set α}  (h : a ∉ s) : insert a s \\ {a} = s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {a : α}  {s : Set α}  (h : a ∉ s)"},
 {"type": "insert a s \\ s = {a}",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {a : α}  {s : Set α}  (h : a ∉ s) : insert a s \\ s = {a} := by ext; sorry",
  "name": "insert_diff_eq_singleton",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {a : α}  {s : Set α}  (h : a ∉ s) : insert a s \\ s = {a}",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {a : α}  {s : Set α}  (h : a ∉ s)"},
 {"type": "s ∩ insert a t = insert a (s ∩ t)",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (h : a ∈ s) : s ∩ insert a t = insert a (s ∩ t) := by rw [insert_inter_distrib]; sorry",
  "name": "inter_insert_of_mem",
  "kind": "theorem",
  "first-tactic": "rw [insert_inter_distrib]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (h : a ∈ s) : s ∩ insert a t = insert a (s ∩ t)",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (h : a ∈ s)"},
 {"type": "insert a s ∩ t = insert a (s ∩ t)",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (h : a ∈ t) : insert a s ∩ t = insert a (s ∩ t) := by rw [insert_inter_distrib]; sorry",
  "name": "insert_inter_of_mem",
  "kind": "theorem",
  "first-tactic": "rw [insert_inter_distrib]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (h : a ∈ t) : insert a s ∩ t = insert a (s ∩ t)",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (h : a ∈ t)"},
 {"type": "insert a (s \\ {a}) = insert a s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {a : α}  {s : Set α} : insert a (s \\ {a}) = insert a s := by simp [insert_eq]; sorry",
  "name": "insert_diff_singleton",
  "kind": "theorem",
  "first-tactic": "simp [insert_eq]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {a : α}  {s : Set α} : insert a (s \\ {a}) = insert a s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {a : α}  {s : Set α}"},
 {"type":
  "(x ∈ if h : p then s h else t h) ↔ (∀ h : p, x ∈ s h) ∧ ∀ h : ¬p, x ∈ t h",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (s : p → Set α)  (t : ¬ p → Set α)  (x : α) : (x ∈ if h : p then s h else t h) ↔ (∀ h : p, x ∈ s h) ∧ ∀ h : ¬p, x ∈ t h := by split_ifs with hp; sorry",
  "name": "mem_dite",
  "kind": "theorem",
  "first-tactic": "split_ifs with hp",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (s : p → Set α)  (t : ¬ p → Set α)  (x : α) : (x ∈ if h : p then s h else t h) ↔ (∀ h : p, x ∈ s h) ∧ ∀ h : ¬p, x ∈ t h",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (s : p → Set α)  (t : ¬ p → Set α)  (x : α)"},
 {"type": "(x ∈ if h : p then t h else univ) ↔ ∀ h : p, x ∈ t h",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : p → Set α)  (x : α) : (x ∈ if h : p then t h else univ) ↔ ∀ h : p, x ∈ t h := by simp [mem_dite]; sorry",
  "name": "mem_dite_univ_right",
  "kind": "theorem",
  "first-tactic": "simp [mem_dite]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : p → Set α)  (x : α) : (x ∈ if h : p then t h else univ) ↔ ∀ h : p, x ∈ t h",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : p → Set α)  (x : α)"},
 {"type": "(x ∈ if h : p then univ else t h) ↔ ∀ h : ¬p, x ∈ t h",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : ¬p → Set α)  (x : α) : (x ∈ if h : p then univ else t h) ↔ ∀ h : ¬p, x ∈ t h := by simp [mem_dite]; sorry",
  "name": "mem_dite_univ_left",
  "kind": "theorem",
  "first-tactic": "simp [mem_dite]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : ¬p → Set α)  (x : α) : (x ∈ if h : p then univ else t h) ↔ ∀ h : ¬p, x ∈ t h",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : ¬p → Set α)  (x : α)"},
 {"type": "(x ∈ if h : p then t h else ∅) ↔ ∃ h : p, x ∈ t h",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : p → Set α)  (x : α) : (x ∈ if h : p then t h else ∅) ↔ ∃ h : p, x ∈ t h := by simp only [mem_dite]; sorry",
  "name": "mem_dite_empty_right",
  "kind": "theorem",
  "first-tactic": "simp only [mem_dite]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : p → Set α)  (x : α) : (x ∈ if h : p then t h else ∅) ↔ ∃ h : p, x ∈ t h",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : p → Set α)  (x : α)"},
 {"type": "(x ∈ if h : p then ∅ else t h) ↔ ∃ h : ¬p, x ∈ t h",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : ¬p → Set α)  (x : α) : (x ∈ if h : p then ∅ else t h) ↔ ∃ h : ¬p, x ∈ t h := by simp only [mem_dite]; sorry",
  "name": "mem_dite_empty_left",
  "kind": "theorem",
  "first-tactic": "simp only [mem_dite]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : ¬p → Set α)  (x : α) : (x ∈ if h : p then ∅ else t h) ↔ ∃ h : ¬p, x ∈ t h",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : ¬p → Set α)  (x : α)"},
 {"type": "t.ite s s' ∩ t = s ∩ t",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s s' : Set α) : t.ite s s' ∩ t = s ∩ t := by rw [Set.ite]; sorry",
  "name": "ite_inter_self",
  "kind": "theorem",
  "first-tactic": "rw [Set.ite]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s s' : Set α) : t.ite s s' ∩ t = s ∩ t",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s s' : Set α)"},
 {"type": "tᶜ.ite s s' = t.ite s' s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s s' : Set α) : tᶜ.ite s s' = t.ite s' s := by rw [Set.ite]; sorry",
  "name": "ite_compl",
  "kind": "theorem",
  "first-tactic": "rw [Set.ite]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s s' : Set α) : tᶜ.ite s s' = t.ite s' s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s s' : Set α)"},
 {"type": "t.ite s s' ∩ tᶜ = s' ∩ tᶜ",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s s' : Set α) : t.ite s s' ∩ tᶜ = s' ∩ tᶜ := by rw [← ite_compl]; sorry",
  "name": "ite_inter_compl_self",
  "kind": "theorem",
  "first-tactic": "rw [← ite_compl]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s s' : Set α) : t.ite s s' ∩ tᶜ = s' ∩ tᶜ",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s s' : Set α)"},
 {"type": "s.ite s t = s ∪ t",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s t : Set α) : s.ite s t = s ∪ t := by simp [Set.ite]; sorry",
  "name": "ite_left",
  "kind": "theorem",
  "first-tactic": "simp [Set.ite]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s t : Set α) : s.ite s t = s ∪ t",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s t : Set α)"},
 {"type": "s.ite t s = t ∩ s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s t : Set α) : s.ite t s = t ∩ s := by simp [Set.ite]; sorry",
  "name": "ite_right",
  "kind": "theorem",
  "first-tactic": "simp [Set.ite]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s t : Set α) : s.ite t s = t ∩ s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s t : Set α)"},
 {"type": "Set.ite ∅ s s' = s'",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s s' : Set α) : Set.ite ∅ s s' = s' := by simp [Set.ite]; sorry",
  "name": "ite_empty",
  "kind": "theorem",
  "first-tactic": "simp [Set.ite]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s s' : Set α) : Set.ite ∅ s s' = s'",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s s' : Set α)"},
 {"type": "Set.ite univ s s' = s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s s' : Set α) : Set.ite univ s s' = s := by simp [Set.ite]; sorry",
  "name": "ite_univ",
  "kind": "theorem",
  "first-tactic": "simp [Set.ite]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s s' : Set α) : Set.ite univ s s' = s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s s' : Set α)"},
 {"type": "t.ite ∅ s = s \\ t",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s : Set α) : t.ite ∅ s = s \\ t := by simp [Set.ite]; sorry",
  "name": "ite_empty_left",
  "kind": "theorem",
  "first-tactic": "simp [Set.ite]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s : Set α) : t.ite ∅ s = s \\ t",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s : Set α)"},
 {"type": "t.ite s ∅ = s ∩ t",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s : Set α) : t.ite s ∅ = s ∩ t := by simp [Set.ite]; sorry",
  "name": "ite_empty_right",
  "kind": "theorem",
  "first-tactic": "simp [Set.ite]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s : Set α) : t.ite s ∅ = s ∩ t",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s : Set α)"},
 {"type": "t.ite (s₁ ∩ s₂) (s₁' ∩ s₂') = t.ite s₁ s₁' ∩ t.ite s₂ s₂'",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s₁ s₂ s₁' s₂' : Set α) : t.ite (s₁ ∩ s₂) (s₁' ∩ s₂') = t.ite s₁ s₁' ∩ t.ite s₂ s₂' := by ext x; sorry",
  "name": "ite_inter_inter",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s₁ s₂ s₁' s₂' : Set α) : t.ite (s₁ ∩ s₂) (s₁' ∩ s₂') = t.ite s₁ s₁' ∩ t.ite s₂ s₂'",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s₁ s₂ s₁' s₂' : Set α)"},
 {"type": "t.ite (s₁ ∩ s) (s₂ ∩ s) = t.ite s₁ s₂ ∩ s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s₁ s₂ s : Set α) : t.ite (s₁ ∩ s) (s₂ ∩ s) = t.ite s₁ s₂ ∩ s := by rw [ite_inter_inter]; sorry",
  "name": "ite_inter",
  "kind": "theorem",
  "first-tactic": "rw [ite_inter_inter]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s₁ s₂ s : Set α) : t.ite (s₁ ∩ s) (s₂ ∩ s) = t.ite s₁ s₂ ∩ s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t s₁ s₂ s : Set α)"},
 {"type": "t.ite s₁ s₂ ∩ s = s₁ ∩ s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t : Set α)  {s₁ s₂ s : Set α}  (h : s₁ ∩ s = s₂ ∩ s) : t.ite s₁ s₂ ∩ s = s₁ ∩ s := by rw [← ite_inter]; sorry",
  "name": "ite_inter_of_inter_eq",
  "kind": "theorem",
  "first-tactic": "rw [← ite_inter]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t : Set α)  {s₁ s₂ s : Set α}  (h : s₁ ∩ s = s₂ ∩ s) : t.ite s₁ s₂ ∩ s = s₁ ∩ s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (t : Set α)  {s₁ s₂ s : Set α}  (h : s₁ ∩ s = s₂ ∩ s)"},
 {"type": "u ⊆ t.ite s s' ↔ u ∩ t ⊆ s ∧ u \\ t ⊆ s'",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {t s s' u : Set α} : u ⊆ t.ite s s' ↔ u ∩ t ⊆ s ∧ u \\ t ⊆ s' := by simp only [subset_def]; sorry",
  "name": "subset_ite",
  "kind": "theorem",
  "first-tactic": "simp only [subset_def]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {t s s' u : Set α} : u ⊆ t.ite s s' ↔ u ∩ t ⊆ s ∧ u \\ t ⊆ s'",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {t s s' u : Set α}"},
 {"type": "p s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {p : Set α → Prop}  (hs : s.Subsingleton)  (he : p ∅)      (h₁ : ∀ x, p {x}) : p s := by rcases hs.eq_empty_or_singleton with (rfl | ⟨x, rfl⟩); sorry",
  "name": "Subsingleton.induction_on",
  "kind": "theorem",
  "first-tactic": "rcases hs.eq_empty_or_singleton with (rfl | ⟨x, rfl⟩)",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {p : Set α → Prop}  (hs : s.Subsingleton)  (he : p ∅)      (h₁ : ∀ x, p {x}) : p s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {p : Set α → Prop}  (hs : s.Subsingleton)  (he : p ∅)      (h₁ : ∀ x, p {x})"},
 {"type": "(∃ a : α, s = {a}) ↔ s.Nonempty ∧ s.Subsingleton",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : (∃ a : α, s = {a}) ↔ s.Nonempty ∧ s.Subsingleton := by refine' ⟨_, fun h => _⟩; sorry",
  "name": "exists_eq_singleton_iff_nonempty_subsingleton",
  "kind": "theorem",
  "first-tactic": "refine' ⟨_, fun h => _⟩",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : (∃ a : α, s = {a}) ↔ s.Nonempty ∧ s.Subsingleton",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later"},
 {"type": "Subsingleton s ↔ s.Subsingleton",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s : Set α) : Subsingleton s ↔ s.Subsingleton := by constructor; sorry",
  "name": "subsingleton_coe",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s : Set α) : Subsingleton s ↔ s.Subsingleton",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later (s : Set α)"},
 {"type": "Subsingleton s",
  "tactic-prompt":
  "instance {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later [Subsingleton α]  {s : Set α} : Subsingleton s := by rw [s.subsingleton_coe]; sorry",
  "name": "subsingleton_coe_of_subsingleton",
  "kind": "instance",
  "first-tactic": "rw [s.subsingleton_coe]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later [Subsingleton α]  {s : Set α} : Subsingleton s",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later [Subsingleton α]  {s : Set α}"},
 {"type": "Nontrivial s ↔ s.Nontrivial",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s : Set α} : Nontrivial s ↔ s.Nontrivial := by rw [← nontrivial_univ_iff]; sorry",
  "name": "nontrivial_coe_sort",
  "kind": "theorem",
  "first-tactic": "rw [← nontrivial_univ_iff]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s : Set α} : Nontrivial s ↔ s.Nontrivial",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {s : Set α}"},
 {"type": "¬s.Subsingleton ↔ s.Nontrivial",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : ¬s.Subsingleton ↔ s.Nontrivial := by simp_rw [Set.Subsingleton]; sorry",
  "name": "not_subsingleton_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [Set.Subsingleton]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later : ¬s.Subsingleton ↔ s.Nontrivial",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later"},
 {"type": "MonotoneOn f s ↔\n    Monotone fun a : s => f a",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [Preorder α]  [Preorder β]  {f : α → β}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (↑s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas. : MonotoneOn f s ↔\n    Monotone fun a : s => f a := by simp [Monotone]; sorry",
  "name": "monotoneOn_iff_monotone",
  "kind": "theorem",
  "first-tactic": "simp [Monotone]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [Preorder α]  [Preorder β]  {f : α → β}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (↑s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas. : MonotoneOn f s ↔\n    Monotone fun a : s => f a",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [Preorder α]  [Preorder β]  {f : α → β}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (↑s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas."},
 {"type": "AntitoneOn f s ↔\n    Antitone fun a : s => f a",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [Preorder α]  [Preorder β]  {f : α → β}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (↑s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas. : AntitoneOn f s ↔\n    Antitone fun a : s => f a := by simp [Antitone]; sorry",
  "name": "antitoneOn_iff_antitone",
  "kind": "theorem",
  "first-tactic": "simp [Antitone]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [Preorder α]  [Preorder β]  {f : α → β}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (↑s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas. : AntitoneOn f s ↔\n    Antitone fun a : s => f a",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [Preorder α]  [Preorder β]  {f : α → β}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (↑s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas."},
 {"type": "StrictMonoOn f s ↔\n    StrictMono fun a : s => f a",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [Preorder α]  [Preorder β]  {f : α → β}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (↑s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas. : StrictMonoOn f s ↔\n    StrictMono fun a : s => f a := by simp [StrictMono]; sorry",
  "name": "strictMonoOn_iff_strictMono",
  "kind": "theorem",
  "first-tactic": "simp [StrictMono]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [Preorder α]  [Preorder β]  {f : α → β}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (↑s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas. : StrictMonoOn f s ↔\n    StrictMono fun a : s => f a",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [Preorder α]  [Preorder β]  {f : α → β}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (↑s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas."},
 {"type": "StrictAntiOn f s ↔\n    StrictAnti fun a : s => f a",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [Preorder α]  [Preorder β]  {f : α → β}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (↑s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas. : StrictAntiOn f s ↔\n    StrictAnti fun a : s => f a := by simp [StrictAnti]; sorry",
  "name": "strictAntiOn_iff_strictAnti",
  "kind": "theorem",
  "first-tactic": "simp [StrictAnti]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [Preorder α]  [Preorder β]  {f : α → β}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (↑s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas. : StrictAntiOn f s ↔\n    StrictAnti fun a : s => f a",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [Preorder α]  [Preorder β]  {f : α → β}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (↑s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas."},
 {"type":
  "¬MonotoneOn f s ∧ ¬AntitoneOn f s ↔\n      ∃ (a : α) (_ : a ∈ s) (b : α) (_ : b ∈ s) (c : α) (_ : c ∈ s),\n        a ≤ b ∧ b ≤ c ∧ (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c)",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [LinearOrder α]  [LinearOrder β]  {f : α → β} : ¬MonotoneOn f s ∧ ¬AntitoneOn f s ↔\n      ∃ (a : α) (_ : a ∈ s) (b : α) (_ : b ∈ s) (c : α) (_ : c ∈ s),\n        a ≤ b ∧ b ≤ c ∧ (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c) := by simp [monotoneOn_iff_monotone]; sorry",
  "name": "not_monotoneOn_not_antitoneOn_iff_exists_le_le",
  "kind": "theorem",
  "first-tactic": "simp [monotoneOn_iff_monotone]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [LinearOrder α]  [LinearOrder β]  {f : α → β} : ¬MonotoneOn f s ∧ ¬AntitoneOn f s ↔\n      ∃ (a : α) (_ : a ∈ s) (b : α) (_ : b ∈ s) (c : α) (_ : c ∈ s),\n        a ≤ b ∧ b ≤ c ∧ (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c)",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [LinearOrder α]  [LinearOrder β]  {f : α → β}"},
 {"type":
  "¬MonotoneOn f s ∧ ¬AntitoneOn f s ↔\n      ∃ (a : α) (_ : a ∈ s) (b : α) (_ : b ∈ s) (c : α) (_ : c ∈ s),\n        a < b ∧ b < c ∧ (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c)",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [LinearOrder α]  [LinearOrder β]  {f : α → β} : ¬MonotoneOn f s ∧ ¬AntitoneOn f s ↔\n      ∃ (a : α) (_ : a ∈ s) (b : α) (_ : b ∈ s) (c : α) (_ : c ∈ s),\n        a < b ∧ b < c ∧ (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c) := by simp [monotoneOn_iff_monotone]; sorry",
  "name": "not_monotoneOn_not_antitoneOn_iff_exists_lt_lt",
  "kind": "theorem",
  "first-tactic": "simp [monotoneOn_iff_monotone]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [LinearOrder α]  [LinearOrder β]  {f : α → β} : ¬MonotoneOn f s ∧ ¬AntitoneOn f s ↔\n      ∃ (a : α) (_ : a ∈ s) (b : α) (_ : b ∈ s) (c : α) (_ : c ∈ s),\n        a < b ∧ b < c ∧ (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c)",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later  [LinearOrder α]  [LinearOrder β]  {f : α → β}"},
 {"type": "(f s).Nonempty ↔ s.Nonempty",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {f : Set α → Set β}  (hf : Injective f)  (h2 : f ∅ = ∅)      {s : Set α} : (f s).Nonempty ↔ s.Nonempty := by rw [nonempty_iff_ne_empty]; sorry",
  "name": "Injective.nonempty_apply_iff",
  "kind": "theorem",
  "first-tactic": "rw [nonempty_iff_ne_empty]",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {f : Set α → Set β}  (hf : Injective f)  (h2 : f ∅ = ∅)      {s : Set α} : (f s).Nonempty ↔ s.Nonempty",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {f : Set α → Set β}  (hf : Injective f)  (h2 : f ∅ = ∅)      {s : Set α}"},
 {"type": "inclusion Subset.rfl x = x",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β}  {α : Type _}  {s t u : Set α} (x : s) : inclusion Subset.rfl x = x := by cases x; sorry",
  "name": "inclusion_self",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β}  {α : Type _}  {s t u : Set α} (x : s) : inclusion Subset.rfl x = x",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β}  {α : Type _}  {s t u : Set α} (x : s)"},
 {"type": "inclusion h ⟨x, m⟩ = x",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β}  {α : Type _}  {s t u : Set α} (h : s ⊆ t)  (x : t)  (m : (x : α) ∈ s) : inclusion h ⟨x, m⟩ = x := by cases x; sorry",
  "name": "inclusion_right",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β}  {α : Type _}  {s t u : Set α} (h : s ⊆ t)  (x : t)  (m : (x : α) ∈ s) : inclusion h ⟨x, m⟩ = x",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β}  {α : Type _}  {s t u : Set α} (h : s ⊆ t)  (x : t)  (m : (x : α) ∈ s)"},
 {"type": "inclusion htu (inclusion hst x) = inclusion (hst.trans htu) x",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β}  {α : Type _}  {s t u : Set α} (hst : s ⊆ t)  (htu : t ⊆ u)  (x : s) : inclusion htu (inclusion hst x) = inclusion (hst.trans htu) x := by cases x; sorry",
  "name": "inclusion_inclusion",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β}  {α : Type _}  {s t u : Set α} (hst : s ⊆ t)  (htu : t ⊆ u)  (x : s) : inclusion htu (inclusion hst x) = inclusion (hst.trans htu) x",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β}  {α : Type _}  {s t u : Set α} (hst : s ⊆ t)  (htu : t ⊆ u)  (x : s)"},
 {"type": "s = t",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β}  {α : Type _}  {s t u : Set α} {s t : Set α}  {h : s ⊆ t}      (h_surj : Function.Surjective (inclusion h)) : s = t := by refine' Set.Subset.antisymm h (fun x hx => _); sorry",
  "name": "eq_of_inclusion_surjective",
  "kind": "theorem",
  "first-tactic": "refine' Set.Subset.antisymm h (fun x hx => _)",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β}  {α : Type _}  {s t u : Set α} {s t : Set α}  {h : s ⊆ t}      (h_surj : Function.Surjective (inclusion h)) : s = t",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β}  {α : Type _}  {s t u : Set α} {s t : Set α}  {h : s ⊆ t}      (h_surj : Function.Surjective (inclusion h))"},
 {"type": "Decidable (a ∈ { a | p a })",
  "tactic-prompt":
  "instance {α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _}  [Subsingleton α] {α : Type u}  (s t : Set α)  (a : α) (p : α → Prop)  [Decidable (p a)] : Decidable (a ∈ { a | p a }) := by assumption; sorry",
  "name": "decidableSetOf",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _}  [Subsingleton α] {α : Type u}  (s t : Set α)  (a : α) (p : α → Prop)  [Decidable (p a)] : Decidable (a ∈ { a | p a })",
  "args":
  "{α : Type _}  {s t : Set α} {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {a b : α}  {s t u : Set α}  -- Porting note: remove `noncomputable` later {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _}  [Subsingleton α] {α : Type u}  (s t : Set α)  (a : α) (p : α → Prop)  [Decidable (p a)]"},
 {"type": "s.restrict f '' (Subtype.val ⁻¹' t) = f '' (t ∩ s)",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} (f : α → β)  (s t : Set α) : s.restrict f '' (Subtype.val ⁻¹' t) = f '' (t ∩ s) := by rw [restrict_eq]; sorry",
  "name": "image_restrict",
  "kind": "theorem",
  "first-tactic": "rw [restrict_eq]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} (f : α → β)  (s t : Set α) : s.restrict f '' (Subtype.val ⁻¹' t) = f '' (t ∩ s)",
  "args": "{α β γ ι : Type _}  {π : α → Type _} (f : α → β)  (s t : Set α)"},
 {"type": "(range f).restrict (extend f g g') = fun x => g x.coe_prop.choose",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} (f : α → β)  (g : α → γ)  (g' : β → γ) : (range f).restrict (extend f g g') = fun x => g x.coe_prop.choose := by classical\n  exact restrict_dite _ _; sorry",
  "name": "restrict_extend_range",
  "kind": "theorem",
  "first-tactic": "classical\n  exact restrict_dite _ _",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} (f : α → β)  (g : α → γ)  (g' : β → γ) : (range f).restrict (extend f g g') = fun x => g x.coe_prop.choose",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} (f : α → β)  (g : α → γ)  (g' : β → γ)"},
 {"type": "range fᶜ.restrict (extend f g g') = g' ∘ Subtype.val",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} (f : α → β)  (g : α → γ)  (g' : β → γ) : range fᶜ.restrict (extend f g g') = g' ∘ Subtype.val := by classical\n  exact restrict_dite_compl _ _; sorry",
  "name": "restrict_extend_compl_range",
  "kind": "theorem",
  "first-tactic": "classical\n  exact restrict_dite_compl _ _",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} (f : α → β)  (g : α → γ)  (g' : β → γ) : range fᶜ.restrict (extend f g g') = g' ∘ Subtype.val",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} (f : α → β)  (g : α → γ)  (g' : β → γ)"},
 {"type": "range (extend f g g') ⊆ range g ∪ g' '' range fᶜ",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} (f : α → β)  (g : α → γ)  (g' : β → γ) : range (extend f g g') ⊆ range g ∪ g' '' range fᶜ := by classical\n  rintro _ ⟨y, rfl⟩\n  rw [extend_def]\n  split_ifs with h\n  exacts[Or.inl (mem_range_self _), Or.inr (mem_image_of_mem _ h)]; sorry",
  "name": "range_extend_subset",
  "kind": "theorem",
  "first-tactic":
  "classical\n  rintro _ ⟨y, rfl⟩\n  rw [extend_def]\n  split_ifs with h\n  exacts[Or.inl (mem_range_self _), Or.inr (mem_image_of_mem _ h)]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} (f : α → β)  (g : α → γ)  (g' : β → γ) : range (extend f g g') ⊆ range g ∪ g' '' range fᶜ",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} (f : α → β)  (g : α → γ)  (g' : β → γ)"},
 {"type": "range (extend f g g') = range g ∪ g' '' range fᶜ",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {f : α → β}  (hf : Injective f)  (g : α → γ)  (g' : β → γ) : range (extend f g g') = range g ∪ g' '' range fᶜ := by refine' (range_extend_subset _ _ _).antisymm _; sorry",
  "name": "range_extend",
  "kind": "theorem",
  "first-tactic": "refine' (range_extend_subset _ _ _).antisymm _",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {f : α → β}  (hf : Injective f)  (g : α → γ)  (g' : β → γ) : range (extend f g g') = range g ∪ g' '' range fᶜ",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {f : α → β}  (hf : Injective f)  (g : α → γ)  (g' : β → γ)"},
 {"type": "Injective (codRestrict f s h) ↔ Injective f",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {f : ι → α}  {s : Set α}  (h : ∀ x, f x ∈ s) : Injective (codRestrict f s h) ↔ Injective f := by simp only [Injective]; sorry",
  "name": "injective_codRestrict",
  "kind": "theorem",
  "first-tactic": "simp only [Injective]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {f : ι → α}  {s : Set α}  (h : ∀ x, f x ∈ s) : Injective (codRestrict f s h) ↔ Injective f",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {f : ι → α}  {s : Set α}  (h : ∀ x, f x ∈ s)"},
 {"type": "MonotoneOn f₂ s",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Preorder α]  [Preorder β] (h₁ : MonotoneOn f₁ s)  (h : s.EqOn f₁ f₂) : MonotoneOn f₂ s := by intro a ha b hb hab; sorry",
  "name": "_root_.MonotoneOn.congr",
  "kind": "theorem",
  "first-tactic": "intro a ha b hb hab",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Preorder α]  [Preorder β] (h₁ : MonotoneOn f₁ s)  (h : s.EqOn f₁ f₂) : MonotoneOn f₂ s",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Preorder α]  [Preorder β] (h₁ : MonotoneOn f₁ s)  (h : s.EqOn f₁ f₂)"},
 {"type": "StrictMonoOn f₂ s",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Preorder α]  [Preorder β] (h₁ : StrictMonoOn f₁ s)  (h : s.EqOn f₁ f₂) : StrictMonoOn f₂ s := by intro a ha b hb hab; sorry",
  "name": "_root_.StrictMonoOn.congr",
  "kind": "theorem",
  "first-tactic": "intro a ha b hb hab",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Preorder α]  [Preorder β] (h₁ : StrictMonoOn f₁ s)  (h : s.EqOn f₁ f₂) : StrictMonoOn f₂ s",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Preorder α]  [Preorder β] (h₁ : StrictMonoOn f₁ s)  (h : s.EqOn f₁ f₂)"},
 {"type": "h.restrict f s s^[n] = (h.iterate n).restrict _ _ _",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} {f : α → α}  {s : Set α}  (h : MapsTo f s s)  (n : ℕ) : h.restrict f s s^[n] = (h.iterate n).restrict _ _ _ := by funext x; sorry",
  "name": "MapsTo.iterate_restrict",
  "kind": "theorem",
  "first-tactic": "funext x",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} {f : α → α}  {s : Set α}  (h : MapsTo f s s)  (n : ℕ) : h.restrict f s s^[n] = (h.iterate n).restrict _ _ _",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} {f : α → α}  {s : Set α}  (h : MapsTo f s s)  (n : ℕ)"},
 {"type": "MapsTo f s (f '' s)",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} (f : α → β)  (s : Set α) : MapsTo f s (f '' s) := by rw [mapsTo']; sorry",
  "name": "mapsTo_image",
  "kind": "theorem",
  "first-tactic": "rw [mapsTo']",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} (f : α → β)  (s : Set α) : MapsTo f s (f '' s)",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} (f : α → β)  (s : Set α)"},
 {"type": "MapsTo f (range g) s ↔ MapsTo (f ∘ g) univ s",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} (f : α → β)  (g : γ → α)  (s : Set β) : MapsTo f (range g) s ↔ MapsTo (f ∘ g) univ s := by rw [← image_univ]; sorry",
  "name": "maps_range_to",
  "kind": "theorem",
  "first-tactic": "rw [← image_univ]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} (f : α → β)  (g : γ → α)  (s : Set β) : MapsTo f (range g) s ↔ MapsTo (f ∘ g) univ s",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} (f : α → β)  (g : γ → α)  (s : Set β)"},
 {"type": "range (t.restrictPreimage f) = Subtype.val ⁻¹' range f",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} : range (t.restrictPreimage f) = Subtype.val ⁻¹' range f := by delta Set.restrictPreimage; sorry",
  "name": "range_restrictPreimage",
  "kind": "theorem",
  "first-tactic": "delta Set.restrictPreimage",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} : range (t.restrictPreimage f) = Subtype.val ⁻¹' range f",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}"},
 {"type":
  "InjOn f (s₁ ∪ s₂) ↔ InjOn f s₁ ∧ InjOn f s₂ ∧ ∀ x ∈ s₁, ∀ y ∈ s₂, f x ≠ f y",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} (h : Disjoint s₁ s₂) : InjOn f (s₁ ∪ s₂) ↔ InjOn f s₁ ∧ InjOn f s₂ ∧ ∀ x ∈ s₁, ∀ y ∈ s₂, f x ≠ f y := by refine' ⟨fun H => ⟨H.mono <| subset_union_left _ _, H.mono <| subset_union_right _ _, _⟩, _⟩; sorry",
  "name": "injOn_union",
  "kind": "theorem",
  "first-tactic":
  "refine' ⟨fun H => ⟨H.mono <| subset_union_left _ _, H.mono <| subset_union_right _ _, _⟩, _⟩",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} (h : Disjoint s₁ s₂) : InjOn f (s₁ ∪ s₂) ↔ InjOn f s₁ ∧ InjOn f s₂ ∧ ∀ x ∈ s₁, ∀ y ∈ s₂, f x ≠ f y",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} (h : Disjoint s₁ s₂)"},
 {"type": "Set.InjOn f (insert a s) ↔ Set.InjOn f s ∧ f a ∉ f '' s",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} {f : α → β}  {s : Set α}  {a : α}  (has : a ∉ s) : Set.InjOn f (insert a s) ↔ Set.InjOn f s ∧ f a ∉ f '' s := by have : Disjoint s {a} := disjoint_iff_inf_le.mpr fun x ⟨hxs, (hxa : x = a)⟩ => has (hxa ▸ hxs); sorry",
  "name": "injOn_insert",
  "kind": "theorem",
  "first-tactic":
  "have : Disjoint s {a} := disjoint_iff_inf_le.mpr fun x ⟨hxs, (hxa : x = a)⟩ => has (hxa ▸ hxs)",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} {f : α → β}  {s : Set α}  {a : α}  (has : a ∉ s) : Set.InjOn f (insert a s) ↔ Set.InjOn f s ∧ f a ∉ f '' s",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} {f : α → β}  {s : Set α}  {a : α}  (has : a ∉ s)"},
 {"type": "InjOn g (range f)",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} (h : Injective (g ∘ f)) : InjOn g (range f) := by rintro _ ⟨x, rfl⟩ _ ⟨y, rfl⟩ H; sorry",
  "name": "_root_.Function.Injective.injOn_range",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨x, rfl⟩ _ ⟨y, rfl⟩ H",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} (h : Injective (g ∘ f)) : InjOn g (range f)",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} (h : Injective (g ∘ f))"},
 {"type": "Injective (h.restrict f s t) ↔ InjOn f s",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} (h : MapsTo f s t) : Injective (h.restrict f s t) ↔ InjOn f s := by rw [h.restrict_eq_codRestrict]; sorry",
  "name": "MapsTo.restrict_inj",
  "kind": "theorem",
  "first-tactic": "rw [h.restrict_eq_codRestrict]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} (h : MapsTo f s t) : Injective (h.restrict f s t) ↔ InjOn f s",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} (h : MapsTo f s t)"},
 {"type": "(∃ f : α → β, InjOn f s) ↔ ∃ f : s → β, Injective f",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} [Nonempty β] : (∃ f : α → β, InjOn f s) ↔ ∃ f : s → β, Injective f := by classical\n  refine ⟨fun ⟨f, hf⟩ => ⟨_, hf.injective⟩, fun ⟨f, hf⟩ => ?_⟩\n  refine ⟨fun x => if h : x ∈ s then f ⟨x, h⟩ else _root_.Nonempty.some ‹_›, ?_⟩\n  refine injOn_iff_injective.2 ?_\n  rw [Set.restrict_dite]\n  exact hf; sorry",
  "name": "exists_injOn_iff_injective",
  "kind": "theorem",
  "first-tactic":
  "classical\n  refine ⟨fun ⟨f, hf⟩ => ⟨_, hf.injective⟩, fun ⟨f, hf⟩ => ?_⟩\n  refine ⟨fun x => if h : x ∈ s then f ⟨x, h⟩ else _root_.Nonempty.some ‹_›, ?_⟩\n  refine injOn_iff_injective.2 ?_\n  rw [Set.restrict_dite]\n  exact hf",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} [Nonempty β] : (∃ f : α → β, InjOn f s) ↔ ∃ f : s → β, Injective f",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} [Nonempty β]"},
 {"type": "SurjOn f₂ s t",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (h : SurjOn f₁ s t)  (H : EqOn f₁ f₂ s) : SurjOn f₂ s t := by rwa [SurjOn]; sorry",
  "name": "SurjOn.congr",
  "kind": "theorem",
  "first-tactic": "rwa [SurjOn]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (h : SurjOn f₁ s t)  (H : EqOn f₁ f₂ s) : SurjOn f₂ s t",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (h : SurjOn f₁ s t)  (H : EqOn f₁ f₂ s)"},
 {"type": "SurjOn f (s₁ ∩ s₂) (t₁ ∩ t₂)",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (h₁ : SurjOn f s₁ t₁)  (h₂ : SurjOn f s₂ t₂)  (h : InjOn f (s₁ ∪ s₂)) : SurjOn f (s₁ ∩ s₂) (t₁ ∩ t₂) := by intro y hy; sorry",
  "name": "SurjOn.inter_inter",
  "kind": "theorem",
  "first-tactic": "intro y hy",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (h₁ : SurjOn f s₁ t₁)  (h₂ : SurjOn f s₂ t₂)  (h : InjOn f (s₁ ∪ s₂)) : SurjOn f (s₁ ∩ s₂) (t₁ ∩ t₂)",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (h₁ : SurjOn f s₁ t₁)  (h₂ : SurjOn f s₂ t₂)  (h : InjOn f (s₁ ∪ s₂))"},
 {"type": "Surjective f ↔ SurjOn f univ univ",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} : Surjective f ↔ SurjOn f univ univ := by simp [Surjective]; sorry",
  "name": "surjective_iff_surjOn_univ",
  "kind": "theorem",
  "first-tactic": "simp [Surjective]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} : Surjective f ↔ SurjOn f univ univ",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}"},
 {"type": "f '' s = t ↔ s.SurjOn f t ∧ s.MapsTo f t",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} : f '' s = t ↔ s.SurjOn f t ∧ s.MapsTo f t := by refine' ⟨_, fun h => h.1.image_eq_of_mapsTo h.2⟩; sorry",
  "name": "image_eq_iff_surjOn_mapsTo",
  "kind": "theorem",
  "first-tactic": "refine' ⟨_, fun h => h.1.image_eq_of_mapsTo h.2⟩",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β} : f '' s = t ↔ s.SurjOn f t ∧ s.MapsTo f t",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}"},
 {"type": "t.EqOn g₁ g₂",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (hf : s.EqOn (g₁ ∘ f) (g₂ ∘ f))  (hf' : s.SurjOn f t) : t.EqOn g₁ g₂ := by intro b hb; sorry",
  "name": "EqOn.cancel_right",
  "kind": "theorem",
  "first-tactic": "intro b hb",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (hf : s.EqOn (g₁ ∘ f) (g₂ ∘ f))  (hf' : s.SurjOn f t) : t.EqOn g₁ g₂",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (hf : s.EqOn (g₁ ∘ f) (g₂ ∘ f))  (hf' : s.SurjOn f t)"},
 {"type": "f '' (s₁ ∩ s) = f' ⁻¹' s₁ ∩ f '' s",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (hf : LeftInvOn f' f s) : f '' (s₁ ∩ s) = f' ⁻¹' s₁ ∩ f '' s := by apply Subset.antisymm; sorry",
  "name": "LeftInvOn.image_inter'",
  "kind": "theorem",
  "first-tactic": "apply Subset.antisymm",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (hf : LeftInvOn f' f s) : f '' (s₁ ∩ s) = f' ⁻¹' s₁ ∩ f '' s",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (hf : LeftInvOn f' f s)"},
 {"type": "f '' (s₁ ∩ s) = f' ⁻¹' (s₁ ∩ s) ∩ f '' s",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (hf : LeftInvOn f' f s) : f '' (s₁ ∩ s) = f' ⁻¹' (s₁ ∩ s) ∩ f '' s := by rw [hf.image_inter']; sorry",
  "name": "LeftInvOn.image_inter",
  "kind": "theorem",
  "first-tactic": "rw [hf.image_inter']",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (hf : LeftInvOn f' f s) : f '' (s₁ ∩ s) = f' ⁻¹' (s₁ ∩ s) ∩ f '' s",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (hf : LeftInvOn f' f s)"},
 {"type": "f' '' (f '' s) = s",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (hf : LeftInvOn f' f s) : f' '' (f '' s) = s := by rw [Set.image_image]; sorry",
  "name": "LeftInvOn.image_image",
  "kind": "theorem",
  "first-tactic": "rw [Set.image_image]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (hf : LeftInvOn f' f s) : f' '' (f '' s) = s",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  (hf : LeftInvOn f' f s)"},
 {"type": "invFunOn f s b ∈ s ∧ f (invFunOn f s b) = b",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} (h : ∃ a ∈ s, f a = b) : invFunOn f s b ∈ s ∧ f (invFunOn f s b) = b := by rw [invFunOn]; sorry",
  "name": "invFunOn_pos",
  "kind": "theorem",
  "first-tactic": "rw [invFunOn]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} (h : ∃ a ∈ s, f a = b) : invFunOn f s b ∈ s ∧ f (invFunOn f s b) = b",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} (h : ∃ a ∈ s, f a = b)"},
 {"type": "invFunOn f s b = Classical.choice ‹Nonempty α›",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} (h : ¬∃ a ∈ s, f a = b) : invFunOn f s b = Classical.choice ‹Nonempty α› := by rw [invFunOn]; sorry",
  "name": "invFunOn_neg",
  "kind": "theorem",
  "first-tactic": "rw [invFunOn]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} (h : ¬∃ a ∈ s, f a = b) : invFunOn f s b = Classical.choice ‹Nonempty α›",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} (h : ¬∃ a ∈ s, f a = b)"},
 {"type": "InvOn (invFunOn f s) f (invFunOn f s '' t) t",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Nonempty α]  (h : SurjOn f s t) : InvOn (invFunOn f s) f (invFunOn f s '' t) t := by refine' ⟨_, h.rightInvOn_invFunOn⟩; sorry",
  "name": "SurjOn.invOn_invFunOn",
  "kind": "theorem",
  "first-tactic": "refine' ⟨_, h.rightInvOn_invFunOn⟩",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Nonempty α]  (h : SurjOn f s t) : InvOn (invFunOn f s) f (invFunOn f s '' t) t",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Nonempty α]  (h : SurjOn f s t)"},
 {"type": "BijOn f (invFunOn f s '' t) t",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Nonempty α]  (h : SurjOn f s t) : BijOn f (invFunOn f s '' t) t := by refine' h.invOn_invFunOn.bijOn _ (mapsTo_image _ _); sorry",
  "name": "SurjOn.bijOn_subset",
  "kind": "theorem",
  "first-tactic": "refine' h.invOn_invFunOn.bijOn _ (mapsTo_image _ _)",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Nonempty α]  (h : SurjOn f s t) : BijOn f (invFunOn f s '' t) t",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Nonempty α]  (h : SurjOn f s t)"},
 {"type": "SurjOn f s t ↔ ∃ (s' : _)(_ : s' ⊆ s), BijOn f s' t",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} : SurjOn f s t ↔ ∃ (s' : _)(_ : s' ⊆ s), BijOn f s' t := by constructor; sorry",
  "name": "surjOn_iff_exists_bijOn_subset",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} : SurjOn f s t ↔ ∃ (s' : _)(_ : s' ⊆ s), BijOn f s' t",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β}"},
 {"type": "invFun f ⁻¹' s = f '' s ∪ range fᶜ",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [n : Nonempty α]  {f : α → β}  (hf : Injective f)  {s : Set α}      (h : Classical.choice n ∈ s) : invFun f ⁻¹' s = f '' s ∪ range fᶜ := by ext x; sorry",
  "name": "preimage_invFun_of_mem",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [n : Nonempty α]  {f : α → β}  (hf : Injective f)  {s : Set α}      (h : Classical.choice n ∈ s) : invFun f ⁻¹' s = f '' s ∪ range fᶜ",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [n : Nonempty α]  {f : α → β}  (hf : Injective f)  {s : Set α}      (h : Classical.choice n ∈ s)"},
 {"type": "invFun f ⁻¹' s = f '' s",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [n : Nonempty α]  {f : α → β}  (hf : Injective f)  {s : Set α}      (h : Classical.choice n ∉ s) : invFun f ⁻¹' s = f '' s := by ext x; sorry",
  "name": "preimage_invFun_of_not_mem",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [n : Nonempty α]  {f : α → β}  (hf : Injective f)  {s : Set α}      (h : Classical.choice n ∉ s) : invFun f ⁻¹' s = f '' s",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [n : Nonempty α]  {f : α → β}  (hf : Injective f)  {s : Set α}      (h : Classical.choice n ∉ s)"},
 {"type": "piecewise ∅ f g = g",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ i : α, Decidable (i ∈ (∅ : Set α))] : piecewise ∅ f g = g := by ext i; sorry",
  "name": "piecewise_empty",
  "kind": "theorem",
  "first-tactic": "ext i",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ i : α, Decidable (i ∈ (∅ : Set α))] : piecewise ∅ f g = g",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ i : α, Decidable (i ∈ (∅ : Set α))]"},
 {"type": "piecewise Set.univ f g = f",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ i : α, Decidable (i ∈ (Set.univ : Set α))] : piecewise Set.univ f g = f := by ext i; sorry",
  "name": "piecewise_univ",
  "kind": "theorem",
  "first-tactic": "ext i",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ i : α, Decidable (i ∈ (Set.univ : Set α))] : piecewise Set.univ f g = f",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ i : α, Decidable (i ∈ (Set.univ : Set α))]"},
 {"type": "(insert j s).piecewise f g j = f j",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) {j : α}  [∀ i, Decidable (i ∈ insert j s)] : (insert j s).piecewise f g j = f j := by simp [piecewise]; sorry",
  "name": "piecewise_insert_self",
  "kind": "theorem",
  "first-tactic": "simp [piecewise]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) {j : α}  [∀ i, Decidable (i ∈ insert j s)] : (insert j s).piecewise f g j = f j",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) {j : α}  [∀ i, Decidable (i ∈ insert j s)]"},
 {"type":
  "(insert j s).piecewise f g = Function.update (s.piecewise f g) j (f j)",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] [DecidableEq α]  (j : α)  [∀ i, Decidable (i ∈ insert j s)] : (insert j s).piecewise f g = Function.update (s.piecewise f g) j (f j) := by simp [piecewise]; sorry",
  "name": "piecewise_insert",
  "kind": "theorem",
  "first-tactic": "simp [piecewise]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] [DecidableEq α]  (j : α)  [∀ i, Decidable (i ∈ insert j s)] : (insert j s).piecewise f g = Function.update (s.piecewise f g) j (f j)",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] [DecidableEq α]  (j : α)  [∀ i, Decidable (i ∈ insert j s)]"},
 {"type": "piecewise {x} f g = Function.update g x (f x)",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] (x : α)  [∀ y, Decidable (y ∈ ({x} : Set α))]  [DecidableEq α]      (f g : α → β) : piecewise {x} f g = Function.update g x (f x) := by ext y; sorry",
  "name": "piecewise_singleton",
  "kind": "theorem",
  "first-tactic": "ext y",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] (x : α)  [∀ y, Decidable (y ∈ ({x} : Set α))]  [DecidableEq α]      (f g : α → β) : piecewise {x} f g = Function.update g x (f x)",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] (x : α)  [∀ y, Decidable (y ∈ ({x} : Set α))]  [DecidableEq α]      (f g : α → β)"},
 {"type": "s.piecewise f₁ f₂ ≤ s.piecewise g₁ g₂",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {δ : α → Type _}  [∀ i, Preorder (δ i)]  {s : Set α}      [∀ j, Decidable (j ∈ s)]  {f₁ f₂ g₁ g₂ : ∀ i, δ i}  (h₁ : ∀ i ∈ s, f₁ i ≤ g₁ i)      (h₂ : ∀ (i) (_ : i ∉ s), f₂ i ≤ g₂ i) : s.piecewise f₁ f₂ ≤ s.piecewise g₁ g₂ := by apply piecewise_le; sorry",
  "name": "piecewise_le_piecewise",
  "kind": "theorem",
  "first-tactic": "apply piecewise_le",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {δ : α → Type _}  [∀ i, Preorder (δ i)]  {s : Set α}      [∀ j, Decidable (j ∈ s)]  {f₁ f₂ g₁ g₂ : ∀ i, δ i}  (h₁ : ∀ i ∈ s, f₁ i ≤ g₁ i)      (h₂ : ∀ (i) (_ : i ∉ s), f₂ i ≤ g₂ i) : s.piecewise f₁ f₂ ≤ s.piecewise g₁ g₂",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {δ : α → Type _}  [∀ i, Preorder (δ i)]  {s : Set α}      [∀ j, Decidable (j ∈ s)]  {f₁ f₂ g₁ g₂ : ∀ i, δ i}  (h₁ : ∀ i ∈ s, f₁ i ≤ g₁ i)      (h₂ : ∀ (i) (_ : i ∉ s), f₂ i ≤ g₂ i)"},
 {"type": "(insert j s).piecewise f g i = s.piecewise f g i",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {i j : α}  (h : i ≠ j)  [∀ i, Decidable (i ∈ insert j s)] : (insert j s).piecewise f g i = s.piecewise f g i := by simp [piecewise]; sorry",
  "name": "piecewise_insert_of_ne",
  "kind": "theorem",
  "first-tactic": "simp [piecewise]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {i j : α}  (h : i ≠ j)  [∀ i, Decidable (i ∈ insert j s)] : (insert j s).piecewise f g i = s.piecewise f g i",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {i j : α}  (h : i ≠ j)  [∀ i, Decidable (i ∈ insert j s)]"},
 {"type": "MapsTo (s.piecewise f₁ f₂) (s.ite s₁ s₂) (t.ite t₁ t₂)",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {f₁ f₂ : α → β}      [∀ i, Decidable (i ∈ s)]  (h₁ : MapsTo f₁ (s₁ ∩ s) (t₁ ∩ t))      (h₂ : MapsTo f₂ (s₂ ∩ sᶜ) (t₂ ∩ tᶜ)) : MapsTo (s.piecewise f₁ f₂) (s.ite s₁ s₂) (t.ite t₁ t₂) := by refine' (h₁.congr _).union_union (h₂.congr _); sorry",
  "name": "MapsTo.piecewise_ite",
  "kind": "theorem",
  "first-tactic": "refine' (h₁.congr _).union_union (h₂.congr _)",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {f₁ f₂ : α → β}      [∀ i, Decidable (i ∈ s)]  (h₁ : MapsTo f₁ (s₁ ∩ s) (t₁ ∩ t))      (h₂ : MapsTo f₂ (s₂ ∩ sᶜ) (t₂ ∩ tᶜ)) : MapsTo (s.piecewise f₁ f₂) (s.ite s₁ s₂) (t.ite t₁ t₂)",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {f₁ f₂ : α → β}      [∀ i, Decidable (i ∈ s)]  (h₁ : MapsTo f₁ (s₁ ∩ s) (t₁ ∩ t))      (h₂ : MapsTo f₂ (s₂ ∩ sᶜ) (t₂ ∩ tᶜ))"},
 {"type":
  "h x (s.piecewise f g x) = s.piecewise (fun x => h x (f x)) (fun x => h x (g x)) x",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {δ' : α → Sort _}  (h : ∀ i, δ i → δ' i)  {x : α} : h x (s.piecewise f g x) = s.piecewise (fun x => h x (f x)) (fun x => h x (g x)) x := by by_cases hx : x ∈ s; sorry",
  "name": "apply_piecewise",
  "kind": "theorem",
  "first-tactic": "by_cases hx : x ∈ s",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {δ' : α → Sort _}  (h : ∀ i, δ i → δ' i)  {x : α} : h x (s.piecewise f g x) = s.piecewise (fun x => h x (f x)) (fun x => h x (g x)) x",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {δ' : α → Sort _}  (h : ∀ i, δ i → δ' i)  {x : α}"},
 {"type":
  "h x (s.piecewise f g x) (s.piecewise f' g' x) =\n      s.piecewise (fun x => h x (f x) (f' x)) (fun x => h x (g x) (g' x)) x",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {δ' δ'' : α → Sort _}  (f' g' : ∀ i, δ' i)  (h : ∀ i, δ i → δ' i → δ'' i)      {x : α} : h x (s.piecewise f g x) (s.piecewise f' g' x) =\n      s.piecewise (fun x => h x (f x) (f' x)) (fun x => h x (g x) (g' x)) x := by by_cases hx : x ∈ s; sorry",
  "name": "apply_piecewise₂",
  "kind": "theorem",
  "first-tactic": "by_cases hx : x ∈ s",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {δ' δ'' : α → Sort _}  (f' g' : ∀ i, δ' i)  (h : ∀ i, δ i → δ' i → δ'' i)      {x : α} : h x (s.piecewise f g x) (s.piecewise f' g' x) =\n      s.piecewise (fun x => h x (f x) (f' x)) (fun x => h x (g x) (g' x)) x",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {δ' δ'' : α → Sort _}  (f' g' : ∀ i, δ' i)  (h : ∀ i, δ i → δ' i → δ'' i)      {x : α}"},
 {"type": "s.piecewise f f = f",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] : s.piecewise f f = f := by ext x; sorry",
  "name": "piecewise_same",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] : s.piecewise f f = f",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)]"},
 {"type": "range (s.piecewise f g) = f '' s ∪ g '' sᶜ",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] (f g : α → β) : range (s.piecewise f g) = f '' s ∪ g '' sᶜ := by ext y; sorry",
  "name": "range_piecewise",
  "kind": "theorem",
  "first-tactic": "ext y",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] (f g : α → β) : range (s.piecewise f g) = f '' s ∪ g '' sᶜ",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] (f g : α → β)"},
 {"type":
  "Injective (s.piecewise f g) ↔\n      InjOn f s ∧ InjOn g (sᶜ) ∧ ∀ x ∈ s, ∀ (y) (_ : y ∉ s), f x ≠ g y",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {f g : α → β} : Injective (s.piecewise f g) ↔\n      InjOn f s ∧ InjOn g (sᶜ) ∧ ∀ x ∈ s, ∀ (y) (_ : y ∉ s), f x ≠ g y := by rw [injective_iff_injOn_univ]; sorry",
  "name": "injective_piecewise_iff",
  "kind": "theorem",
  "first-tactic": "rw [injective_iff_injOn_univ]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {f g : α → β} : Injective (s.piecewise f g) ↔\n      InjOn f s ∧ InjOn g (sᶜ) ∧ ∀ x ∈ s, ∀ (y) (_ : y ∉ s), f x ≠ g y",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {f g : α → β}"},
 {"type": "pi s (s'.piecewise t t') = pi (s ∩ s') t ∩ pi (s \\ s') t'",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {ι : Type _}  {α : ι → Type _}  (s s' : Set ι)  (t t' : ∀ i, Set (α i))      [∀ x, Decidable (x ∈ s')] : pi s (s'.piecewise t t') = pi (s ∩ s') t ∩ pi (s \\ s') t' := by ext x; sorry",
  "name": "pi_piecewise",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {ι : Type _}  {α : ι → Type _}  (s s' : Set ι)  (t t' : ∀ i, Set (α i))      [∀ x, Decidable (x ∈ s')] : pi s (s'.piecewise t t') = pi (s ∩ s') t ∩ pi (s \\ s') t'",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {ι : Type _}  {α : ι → Type _}  (s s' : Set ι)  (t t' : ∀ i, Set (α i))      [∀ x, Decidable (x ∈ s')]"},
 {"type": "pi univ (s.piecewise t fun _ => univ) = pi s t",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {ι : Type _}  {α : ι → Type _}  (s : Set ι)  (t : ∀ i, Set (α i))      [∀ x, Decidable (x ∈ s)] : pi univ (s.piecewise t fun _ => univ) = pi s t := by simp; sorry",
  "name": "univ_pi_piecewise",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {ι : Type _}  {α : ι → Type _}  (s : Set ι)  (t : ∀ i, Set (α i))      [∀ x, Decidable (x ∈ s)] : pi univ (s.piecewise t fun _ => univ) = pi s t",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {ι : Type _}  {α : ι → Type _}  (s : Set ι)  (t : ∀ i, Set (α i))      [∀ x, Decidable (x ∈ s)]"},
 {"type": "StrictMono (s.restrict f) ↔ StrictMonoOn f s",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] [Preorder α]  [Preorder β]  {f : α → β}  {s : Set α} : StrictMono (s.restrict f) ↔ StrictMonoOn f s := by simp [Set.restrict]; sorry",
  "name": "strictMono_restrict",
  "kind": "theorem",
  "first-tactic": "simp [Set.restrict]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] [Preorder α]  [Preorder β]  {f : α → β}  {s : Set α} : StrictMono (s.restrict f) ↔ StrictMonoOn f s",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] [Preorder α]  [Preorder β]  {f : α → β}  {s : Set α}"},
 {"type": "SurjOn fb (f '' s) (f '' t)",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  (ha : SurjOn fa s t) : SurjOn fb (f '' s) (f '' t) := by rintro y ⟨x, hxt, rfl⟩; sorry",
  "name": "surjOn_image",
  "kind": "theorem",
  "first-tactic": "rintro y ⟨x, hxt, rfl⟩",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  (ha : SurjOn fa s t) : SurjOn fb (f '' s) (f '' t)",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  (ha : SurjOn fa s t)"},
 {"type": "SurjOn fb (range f) (range f)",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  (ha : Surjective fa) : SurjOn fb (range f) (range f) := by rw [← image_univ]; sorry",
  "name": "surjOn_range",
  "kind": "theorem",
  "first-tactic": "rw [← image_univ]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  (ha : Surjective fa) : SurjOn fb (range f) (range f)",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  (ha : Surjective fa)"},
 {"type": "InjOn fb (f '' s)",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  (ha : InjOn fa s)  (hf : InjOn f (fa '' s)) : InjOn fb (f '' s) := by rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩ H; sorry",
  "name": "injOn_image",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩ H",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  (ha : InjOn fa s)  (hf : InjOn f (fa '' s)) : InjOn fb (f '' s)",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  (ha : InjOn fa s)  (hf : InjOn f (fa '' s))"},
 {"type": "InjOn fb (range f)",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  (ha : Injective fa)  (hf : InjOn f (range fa)) : InjOn fb (range f) := by rw [← image_univ] at *; sorry",
  "name": "injOn_range",
  "kind": "theorem",
  "first-tactic": "rw [← image_univ] at *",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  (ha : Injective fa)  (hf : InjOn f (range fa)) : InjOn fb (range f)",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  (ha : Injective fa)  (hf : InjOn f (range fa))"},
 {"type": "BijOn fb (range f) (range f)",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  (ha : Bijective fa)  (hf : Injective f) : BijOn fb (range f) (range f) := by rw [← image_univ]; sorry",
  "name": "bijOn_range",
  "kind": "theorem",
  "first-tactic": "rw [← image_univ]",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  (ha : Bijective fa)  (hf : Injective f) : BijOn fb (range f) (range f)",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  (ha : Bijective fa)  (hf : Injective f)"},
 {"type": "InjOn fa (f ⁻¹' s)",
  "tactic-prompt":
  "theorem {α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  {s : Set β}  (hb : InjOn fb s)      (hf : InjOn f (f ⁻¹' s)) : InjOn fa (f ⁻¹' s) := by intro x hx y hy H; sorry",
  "name": "injOn_preimage",
  "kind": "theorem",
  "first-tactic": "intro x hx y hy H",
  "core-prompt":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  {s : Set β}  (hb : InjOn fb s)      (hf : InjOn f (f ⁻¹' s)) : InjOn fa (f ⁻¹' s)",
  "args":
  "{α β γ ι : Type _}  {π : α → Type _} {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {p : Set γ}  {f f₁ f₂ f₃ : α → β}  {g g₁ g₂ : β → γ}    {f' f₁' f₂' : β → α}  {g' : γ → β}  [Nonempty α]  {s : Set α}  {f : α → β}  {a : α}  {b : β} {s s₁ s₂ : Set α}  {t : Set β}  {f : α → β} [Preorder α]  [Preorder β]  {f : α → β} {δ : α → Sort y}  (s : Set α)  (f g : ∀ i, δ i) [∀ j, Decidable (j ∈ s)] {fa : α → α}  {fb : β → β}  {f : α → β}  {g : β → γ}  {s t : Set α} (h : Semiconj f fa fb)  {s : Set β}  (hb : InjOn fb s)      (hf : InjOn f (f ⁻¹' s))"},
 {"type": "n₁ = n₂",
  "tactic-prompt":
  "theorem {α : Type _}  (sel : Set α → Option α) {n₁ n₂ : ℕ}  {a : α}  {s : Set α}  (h_sel : ∀ s a, sel s = some a → a ∈ s)      (h₁ : enumerate sel s n₁ = some a)  (h₂ : enumerate sel s n₂ = some a) : n₁ = n₂ := by rcases le_total n₁ n₂ with (hn|hn); sorry",
  "name": "enumerate_inj",
  "kind": "theorem",
  "first-tactic": "rcases le_total n₁ n₂ with (hn|hn)",
  "core-prompt":
  "{α : Type _}  (sel : Set α → Option α) {n₁ n₂ : ℕ}  {a : α}  {s : Set α}  (h_sel : ∀ s a, sel s = some a → a ∈ s)      (h₁ : enumerate sel s n₁ = some a)  (h₂ : enumerate sel s n₂ = some a) : n₁ = n₂",
  "args":
  "{α : Type _}  (sel : Set α → Option α) {n₁ n₂ : ℕ}  {a : α}  {s : Set α}  (h_sel : ∀ s a, sel s = some a → a ∈ s)      (h₁ : enumerate sel s n₁ = some a)  (h₂ : enumerate sel s n₂ = some a)"},
 {"type": "(x ∈ ⋃ (i) (j), s i j) ↔ ∃ i j, x ∈ s i j",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {x : γ}  {s : ∀ i, κ i → Set γ} : (x ∈ ⋃ (i) (j), s i j) ↔ ∃ i j, x ∈ s i j := by simp_rw [mem_unionᵢ]; sorry",
  "name": "mem_unionᵢ₂",
  "kind": "theorem",
  "first-tactic": "simp_rw [mem_unionᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {x : γ}  {s : ∀ i, κ i → Set γ} : (x ∈ ⋃ (i) (j), s i j) ↔ ∃ i j, x ∈ s i j",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {x : γ}  {s : ∀ i, κ i → Set γ}"},
 {"type": "(x ∈ ⋂ (i) (j), s i j) ↔ ∀ i j, x ∈ s i j",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {x : γ}  {s : ∀ i, κ i → Set γ} : (x ∈ ⋂ (i) (j), s i j) ↔ ∀ i j, x ∈ s i j := by simp_rw [mem_interᵢ]; sorry",
  "name": "mem_interᵢ₂",
  "kind": "theorem",
  "first-tactic": "simp_rw [mem_interᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {x : γ}  {s : ∀ i, κ i → Set γ} : (x ∈ ⋂ (i) (j), s i j) ↔ ∀ i j, x ∈ s i j",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {x : γ}  {s : ∀ i, κ i → Set γ}"},
 {"type": "∃ i ∈ t, x ∈ s i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι : Type _}  (t : Set ι)  (s : ι → Set β)      (w : (⋃ i ∈ t, s i) = ⊤)  (x : β) : ∃ i ∈ t, x ∈ s i := by have p : x ∈ ⊤ := Set.mem_univ x; sorry",
  "name": "exists_set_mem_of_union_eq_top",
  "kind": "theorem",
  "first-tactic": "have p : x ∈ ⊤ := Set.mem_univ x",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι : Type _}  (t : Set ι)  (s : ι → Set β)      (w : (⋃ i ∈ t, s i) = ⊤)  (x : β) : ∃ i ∈ t, x ∈ s i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι : Type _}  (t : Set ι)  (s : ι → Set β)      (w : (⋃ i ∈ t, s i) = ⊤)  (x : β)"},
 {"type": "t.Nonempty",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι : Type _}  (t : Set ι)  (s : ι → Set α)      (H : Nonempty α)  (w : (⋃ i ∈ t, s i) = ⊤) : t.Nonempty := by obtain ⟨x, m, -⟩ := exists_set_mem_of_union_eq_top t s w H.some; sorry",
  "name": "nonempty_of_union_eq_top_of_nonempty",
  "kind": "theorem",
  "first-tactic":
  "obtain ⟨x, m, -⟩ := exists_set_mem_of_union_eq_top t s w H.some",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι : Type _}  (t : Set ι)  (s : ι → Set α)      (H : Nonempty α)  (w : (⋃ i ∈ t, s i) = ⊤) : t.Nonempty",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι : Type _}  (t : Set ι)  (s : ι → Set α)      (H : Nonempty α)  (w : (⋃ i ∈ t, s i) = ⊤)"},
 {"type": "(⋃ (i) (j), s i j) ⊆ t ↔ ∀ i j, s i j ⊆ t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : ∀ i, κ i → Set α}  {t : Set α} : (⋃ (i) (j), s i j) ⊆ t ↔ ∀ i j, s i j ⊆ t := by simp_rw [unionᵢ_subset_iff]; sorry",
  "name": "unionᵢ₂_subset_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [unionᵢ_subset_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : ∀ i, κ i → Set α}  {t : Set α} : (⋃ (i) (j), s i j) ⊆ t ↔ ∀ i j, s i j ⊆ t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : ∀ i, κ i → Set α}  {t : Set α}"},
 {"type": "(s ⊆ ⋂ (i) (j), t i j) ↔ ∀ i j, s ⊆ t i j",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set α}  {t : ∀ i, κ i → Set α} : (s ⊆ ⋂ (i) (j), t i j) ↔ ∀ i j, s ⊆ t i j := by simp_rw [subset_interᵢ_iff]; sorry",
  "name": "subset_interᵢ₂_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [subset_interᵢ_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set α}  {t : ∀ i, κ i → Set α} : (s ⊆ ⋂ (i) (j), t i j) ↔ ∀ i j, s ⊆ t i j",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set α}  {t : ∀ i, κ i → Set α}"},
 {"type": "(⋃ i, { x : α | P i x }) = { x : α | ∃ i, P i x }",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (P : ι → α → Prop) : (⋃ i, { x : α | P i x }) = { x : α | ∃ i, P i x } := by ext; sorry",
  "name": "unionᵢ_setOf",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (P : ι → α → Prop) : (⋃ i, { x : α | P i x }) = { x : α | ∃ i, P i x }",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (P : ι → α → Prop)"},
 {"type": "(⋂ i, { x : α | P i x }) = { x : α | ∀ i, P i x }",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (P : ι → α → Prop) : (⋂ i, { x : α | P i x }) = { x : α | ∀ i, P i x } := by ext; sorry",
  "name": "interᵢ_setOf",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (P : ι → α → Prop) : (⋂ i, { x : α | P i x }) = { x : α | ∀ i, P i x }",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (P : ι → α → Prop)"},
 {"type": "(⋃ (i) (j), s i j)ᶜ = ⋂ (i) (j), s i jᶜ",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ∀ i, κ i → Set α) : (⋃ (i) (j), s i j)ᶜ = ⋂ (i) (j), s i jᶜ := by simp_rw [compl_unionᵢ]; sorry",
  "name": "compl_unionᵢ₂",
  "kind": "theorem",
  "first-tactic": "simp_rw [compl_unionᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ∀ i, κ i → Set α) : (⋃ (i) (j), s i j)ᶜ = ⋂ (i) (j), s i jᶜ",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ∀ i, κ i → Set α)"},
 {"type": "(⋂ (i) (j), s i j)ᶜ = ⋃ (i) (j), s i jᶜ",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ∀ i, κ i → Set α) : (⋂ (i) (j), s i j)ᶜ = ⋃ (i) (j), s i jᶜ := by simp_rw [compl_interᵢ]; sorry",
  "name": "compl_interᵢ₂",
  "kind": "theorem",
  "first-tactic": "simp_rw [compl_interᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ∀ i, κ i → Set α) : (⋂ (i) (j), s i j)ᶜ = ⋃ (i) (j), s i jᶜ",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ∀ i, κ i → Set α)"},
 {"type": "(⋃ i, s i) = (⋂ i, s iᶜ)ᶜ",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set β) : (⋃ i, s i) = (⋂ i, s iᶜ)ᶜ := by simp only [compl_interᵢ]; sorry",
  "name": "unionᵢ_eq_compl_interᵢ_compl",
  "kind": "theorem",
  "first-tactic": "simp only [compl_interᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set β) : (⋃ i, s i) = (⋂ i, s iᶜ)ᶜ",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set β)"},
 {"type": "(⋂ i, s i) = (⋃ i, s iᶜ)ᶜ",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set β) : (⋂ i, s i) = (⋃ i, s iᶜ)ᶜ := by simp only [compl_unionᵢ]; sorry",
  "name": "interᵢ_eq_compl_unionᵢ_compl",
  "kind": "theorem",
  "first-tactic": "simp only [compl_unionᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set β) : (⋂ i, s i) = (⋃ i, s iᶜ)ᶜ",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set β)"},
 {"type": "(s \\ ⋃ i, t i) = ⋂ i, s \\ t i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} [Nonempty ι]  (s : Set β)  (t : ι → Set β) : (s \\ ⋃ i, t i) = ⋂ i, s \\ t i := by rw [diff_eq]; sorry",
  "name": "diff_unionᵢ",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} [Nonempty ι]  (s : Set β)  (t : ι → Set β) : (s \\ ⋃ i, t i) = ⋂ i, s \\ t i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} [Nonempty ι]  (s : Set β)  (t : ι → Set β)"},
 {"type": "(s \\ ⋂ i, t i) = ⋃ i, s \\ t i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set β)  (t : ι → Set β) : (s \\ ⋂ i, t i) = ⋃ i, s \\ t i := by rw [diff_eq]; sorry",
  "name": "diff_interᵢ",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set β)  (t : ι → Set β) : (s \\ ⋂ i, t i) = ⋃ i, s \\ t i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set β)  (t : ι → Set β)"},
 {"type":
  "((fun x : ∀ i : ι, α i => x i) '' ⋂ k, (fun x : ∀ j : ι, α j => x k) ⁻¹' v k) = v i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι : Type _}  {α : ι → Type _}  {v : ∀ i : ι, Set (α i)}      (hv : (pi univ v).Nonempty)  (i : ι) : ((fun x : ∀ i : ι, α i => x i) '' ⋂ k, (fun x : ∀ j : ι, α j => x k) ⁻¹' v k) = v i := by classical\n    apply Subset.antisymm\n    · simp [interᵢ_subset]\n    · intro y y_in\n      simp only [mem_image]; sorry",
  "name": "image_projection_prod",
  "kind": "theorem",
  "first-tactic":
  "classical\n    apply Subset.antisymm\n    · simp [interᵢ_subset]\n    · intro y y_in\n      simp only [mem_image]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι : Type _}  {α : ι → Type _}  {v : ∀ i : ι, Set (α i)}      (hv : (pi univ v).Nonempty)  (i : ι) : ((fun x : ∀ i : ι, α i => x i) '' ⋂ k, (fun x : ∀ j : ι, α j => x k) ⁻¹' v k) = v i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι : Type _}  {α : ι → Type _}  {v : ∀ i : ι, Set (α i)}      (hv : (pi univ v).Nonempty)  (i : ι)"},
 {"type": "(⋃ i, s i).Nonempty ↔ ∃ i, (s i).Nonempty",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {s : ι → Set α} : (⋃ i, s i).Nonempty ↔ ∃ i, (s i).Nonempty := by simp [nonempty_iff_ne_empty]; sorry",
  "name": "nonempty_unionᵢ",
  "kind": "theorem",
  "first-tactic": "simp [nonempty_iff_ne_empty]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {s : ι → Set α} : (⋃ i, s i).Nonempty ↔ ∃ i, (s i).Nonempty",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {s : ι → Set α}"},
 {"type": "(⋃ i ∈ t, s i).Nonempty ↔ ∃ i ∈ t, (s i).Nonempty",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {s : ι → Set α} {t : Set α}  {s : α → Set β} : (⋃ i ∈ t, s i).Nonempty ↔ ∃ i ∈ t, (s i).Nonempty := by simp; sorry",
  "name": "nonempty_bunionᵢ",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {s : ι → Set α} {t : Set α}  {s : α → Set β} : (⋃ i ∈ t, s i).Nonempty ↔ ∃ i ∈ t, (s i).Nonempty",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {s : ι → Set α} {t : Set α}  {s : α → Set β}"},
 {"type":
  "(⋃ (x : ι) (y : ι') (h : p x ∧ q x y), s x y h) =\n      ⋃ (x : ι) (hx : p x) (y : ι') (hy : q x y), s x y ⟨hx, hy⟩",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (p : ι → Prop)  (q : ι → ι' → Prop)  (s : ∀ x y, p x ∧ q x y → Set α) : (⋃ (x : ι) (y : ι') (h : p x ∧ q x y), s x y h) =\n      ⋃ (x : ι) (hx : p x) (y : ι') (hy : q x y), s x y ⟨hx, hy⟩ := by simp only [unionᵢ_and]; sorry",
  "name": "bunionᵢ_and",
  "kind": "theorem",
  "first-tactic": "simp only [unionᵢ_and]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (p : ι → Prop)  (q : ι → ι' → Prop)  (s : ∀ x y, p x ∧ q x y → Set α) : (⋃ (x : ι) (y : ι') (h : p x ∧ q x y), s x y h) =\n      ⋃ (x : ι) (hx : p x) (y : ι') (hy : q x y), s x y ⟨hx, hy⟩",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (p : ι → Prop)  (q : ι → ι' → Prop)  (s : ∀ x y, p x ∧ q x y → Set α)"},
 {"type":
  "(⋃ (x : ι) (y : ι') (h : p y ∧ q x y), s x y h) =\n      ⋃ (y : ι') (hy : p y) (x : ι) (hx : q x y), s x y ⟨hy, hx⟩",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (p : ι' → Prop)  (q : ι → ι' → Prop)  (s : ∀ x y, p y ∧ q x y → Set α) : (⋃ (x : ι) (y : ι') (h : p y ∧ q x y), s x y h) =\n      ⋃ (y : ι') (hy : p y) (x : ι) (hx : q x y), s x y ⟨hy, hx⟩ := by simp only [unionᵢ_and]; sorry",
  "name": "bunionᵢ_and'",
  "kind": "theorem",
  "first-tactic": "simp only [unionᵢ_and]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (p : ι' → Prop)  (q : ι → ι' → Prop)  (s : ∀ x y, p y ∧ q x y → Set α) : (⋃ (x : ι) (y : ι') (h : p y ∧ q x y), s x y h) =\n      ⋃ (y : ι') (hy : p y) (x : ι) (hx : q x y), s x y ⟨hy, hx⟩",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (p : ι' → Prop)  (q : ι → ι' → Prop)  (s : ∀ x y, p y ∧ q x y → Set α)"},
 {"type":
  "(⋂ (x : ι) (y : ι') (h : p x ∧ q x y), s x y h) =\n      ⋂ (x : ι) (hx : p x) (y : ι') (hy : q x y), s x y ⟨hx, hy⟩",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (p : ι → Prop)  (q : ι → ι' → Prop)  (s : ∀ x y, p x ∧ q x y → Set α) : (⋂ (x : ι) (y : ι') (h : p x ∧ q x y), s x y h) =\n      ⋂ (x : ι) (hx : p x) (y : ι') (hy : q x y), s x y ⟨hx, hy⟩ := by simp only [interᵢ_and]; sorry",
  "name": "binterᵢ_and",
  "kind": "theorem",
  "first-tactic": "simp only [interᵢ_and]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (p : ι → Prop)  (q : ι → ι' → Prop)  (s : ∀ x y, p x ∧ q x y → Set α) : (⋂ (x : ι) (y : ι') (h : p x ∧ q x y), s x y h) =\n      ⋂ (x : ι) (hx : p x) (y : ι') (hy : q x y), s x y ⟨hx, hy⟩",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (p : ι → Prop)  (q : ι → ι' → Prop)  (s : ∀ x y, p x ∧ q x y → Set α)"},
 {"type":
  "(⋂ (x : ι) (y : ι') (h : p y ∧ q x y), s x y h) =\n      ⋂ (y : ι') (hy : p y) (x : ι) (hx : q x y), s x y ⟨hy, hx⟩",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (p : ι' → Prop)  (q : ι → ι' → Prop)  (s : ∀ x y, p y ∧ q x y → Set α) : (⋂ (x : ι) (y : ι') (h : p y ∧ q x y), s x y h) =\n      ⋂ (y : ι') (hy : p y) (x : ι) (hx : q x y), s x y ⟨hy, hx⟩ := by simp only [interᵢ_and]; sorry",
  "name": "binterᵢ_and'",
  "kind": "theorem",
  "first-tactic": "simp only [interᵢ_and]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (p : ι' → Prop)  (q : ι → ι' → Prop)  (s : ∀ x y, p y ∧ q x y → Set α) : (⋂ (x : ι) (y : ι') (h : p y ∧ q x y), s x y h) =\n      ⋂ (y : ι') (hy : p y) (x : ι) (hx : q x y), s x y ⟨hy, hx⟩",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (p : ι' → Prop)  (q : ι → ι' → Prop)  (s : ∀ x y, p y ∧ q x y → Set α)"},
 {"type":
  "(⋃ (x) (h), s x h) = s b (Or.inl rfl) ∪ ⋃ (x) (h : p x), s x (Or.inr h)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {b : β}  {p : β → Prop}  {s : ∀ x : β, x = b ∨ p x → Set α} : (⋃ (x) (h), s x h) = s b (Or.inl rfl) ∪ ⋃ (x) (h : p x), s x (Or.inr h) := by simp only [unionᵢ_or]; sorry",
  "name": "unionᵢ_unionᵢ_eq_or_left",
  "kind": "theorem",
  "first-tactic": "simp only [unionᵢ_or]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {b : β}  {p : β → Prop}  {s : ∀ x : β, x = b ∨ p x → Set α} : (⋃ (x) (h), s x h) = s b (Or.inl rfl) ∪ ⋃ (x) (h : p x), s x (Or.inr h)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {b : β}  {p : β → Prop}  {s : ∀ x : β, x = b ∨ p x → Set α}"},
 {"type":
  "(⋂ (x) (h), s x h) = s b (Or.inl rfl) ∩ ⋂ (x) (h : p x), s x (Or.inr h)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {b : β}  {p : β → Prop}  {s : ∀ x : β, x = b ∨ p x → Set α} : (⋂ (x) (h), s x h) = s b (Or.inl rfl) ∩ ⋂ (x) (h : p x), s x (Or.inr h) := by simp only [interᵢ_or]; sorry",
  "name": "interᵢ_interᵢ_eq_or_left",
  "kind": "theorem",
  "first-tactic": "simp only [interᵢ_or]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {b : β}  {p : β → Prop}  {s : ∀ x : β, x = b ∨ p x → Set α} : (⋂ (x) (h), s x h) = s b (Or.inl rfl) ∩ ⋂ (x) (h : p x), s x (Or.inr h)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {b : β}  {p : β → Prop}  {s : ∀ x : β, x = b ∨ p x → Set α}"},
 {"type": "(⋃ _h : s.Nonempty, s) = s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set α) : (⋃ _h : s.Nonempty, s) = s := by rw [unionᵢ_nonempty_index]; sorry",
  "name": "unionᵢ_nonempty_self",
  "kind": "theorem",
  "first-tactic": "rw [unionᵢ_nonempty_index]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set α) : (⋃ _h : s.Nonempty, s) = s",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set α)"},
 {"type": "(⋂ x ∈ insert a s, t x) = t a ∩ ⋂ x ∈ s, t x",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (a : α)  (s : Set α)  (t : α → Set β) : (⋂ x ∈ insert a s, t x) = t a ∩ ⋂ x ∈ s, t x := by simp; sorry",
  "name": "binterᵢ_insert",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (a : α)  (s : Set α)  (t : α → Set β) : (⋂ x ∈ insert a s, t x) = t a ∩ ⋂ x ∈ s, t x",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (a : α)  (s : Set α)  (t : α → Set β)"},
 {"type": "(⋂ x ∈ ({a, b} : Set α), s x) = s a ∩ s b",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (a b : α)  (s : α → Set β) : (⋂ x ∈ ({a, b} : Set α), s x) = s a ∩ s b := by rw [binterᵢ_insert]; sorry",
  "name": "binterᵢ_pair",
  "kind": "theorem",
  "first-tactic": "rw [binterᵢ_insert]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (a b : α)  (s : α → Set β) : (⋂ x ∈ ({a, b} : Set α), s x) = s a ∩ s b",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (a b : α)  (s : α → Set β)"},
 {"type": "(⋂ i ∈ s, f i ∩ t) = (⋂ i ∈ s, f i) ∩ t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι α : Type _}  {s : Set ι}  (hs : s.Nonempty)  (f : ι → Set α)  (t : Set α) : (⋂ i ∈ s, f i ∩ t) = (⋂ i ∈ s, f i) ∩ t := by haveI : Nonempty s := hs.to_subtype; sorry",
  "name": "binterᵢ_inter",
  "kind": "theorem",
  "first-tactic": "haveI : Nonempty s := hs.to_subtype",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι α : Type _}  {s : Set ι}  (hs : s.Nonempty)  (f : ι → Set α)  (t : Set α) : (⋂ i ∈ s, f i ∩ t) = (⋂ i ∈ s, f i) ∩ t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι α : Type _}  {s : Set ι}  (hs : s.Nonempty)  (f : ι → Set α)  (t : Set α)"},
 {"type": "(⋂ i ∈ s, t ∩ f i) = t ∩ ⋂ i ∈ s, f i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι α : Type _}  {s : Set ι}  (hs : s.Nonempty)  (f : ι → Set α)  (t : Set α) : (⋂ i ∈ s, t ∩ f i) = t ∩ ⋂ i ∈ s, f i := by rw [inter_comm]; sorry",
  "name": "inter_binterᵢ",
  "kind": "theorem",
  "first-tactic": "rw [inter_comm]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι α : Type _}  {s : Set ι}  (hs : s.Nonempty)  (f : ι → Set α)  (t : Set α) : (⋂ i ∈ s, t ∩ f i) = t ∩ ⋂ i ∈ s, f i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι α : Type _}  {s : Set ι}  (hs : s.Nonempty)  (f : ι → Set α)  (t : Set α)"},
 {"type": "(⋃ x ∈ insert a s, t x) = t a ∪ ⋃ x ∈ s, t x",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (a : α)  (s : Set α)  (t : α → Set β) : (⋃ x ∈ insert a s, t x) = t a ∪ ⋃ x ∈ s, t x := by simp; sorry",
  "name": "bunionᵢ_insert",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (a : α)  (s : Set α)  (t : α → Set β) : (⋃ x ∈ insert a s, t x) = t a ∪ ⋃ x ∈ s, t x",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (a : α)  (s : Set α)  (t : α → Set β)"},
 {"type": "(⋃ x ∈ ({a, b} : Set α), s x) = s a ∪ s b",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (a b : α)  (s : α → Set β) : (⋃ x ∈ ({a, b} : Set α), s x) = s a ∪ s b := by simp; sorry",
  "name": "bunionᵢ_pair",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (a b : α)  (s : α → Set β) : (⋃ x ∈ ({a, b} : Set α), s x) = s a ∪ s b",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (a b : α)  (s : α → Set β)"},
 {"type": "(s ∩ ⋃ (i) (j), t i j) = ⋃ (i) (j), s ∩ t i j",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set α)  (t : ∀ i, κ i → Set α) : (s ∩ ⋃ (i) (j), t i j) = ⋃ (i) (j), s ∩ t i j := by simp only [inter_unionᵢ]; sorry",
  "name": "inter_unionᵢ₂",
  "kind": "theorem",
  "first-tactic": "simp only [inter_unionᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set α)  (t : ∀ i, κ i → Set α) : (s ∩ ⋃ (i) (j), t i j) = ⋃ (i) (j), s ∩ t i j",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set α)  (t : ∀ i, κ i → Set α)"},
 {"type": "(⋃ (i) (j), s i j) ∩ t = ⋃ (i) (j), s i j ∩ t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ∀ i, κ i → Set α)  (t : Set α) : (⋃ (i) (j), s i j) ∩ t = ⋃ (i) (j), s i j ∩ t := by simp_rw [unionᵢ_inter]; sorry",
  "name": "unionᵢ₂_inter",
  "kind": "theorem",
  "first-tactic": "simp_rw [unionᵢ_inter]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ∀ i, κ i → Set α)  (t : Set α) : (⋃ (i) (j), s i j) ∩ t = ⋃ (i) (j), s i j ∩ t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ∀ i, κ i → Set α)  (t : Set α)"},
 {"type": "(s ∪ ⋂ (i) (j), t i j) = ⋂ (i) (j), s ∪ t i j",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set α)  (t : ∀ i, κ i → Set α) : (s ∪ ⋂ (i) (j), t i j) = ⋂ (i) (j), s ∪ t i j := by simp_rw [union_interᵢ]; sorry",
  "name": "union_interᵢ₂",
  "kind": "theorem",
  "first-tactic": "simp_rw [union_interᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set α)  (t : ∀ i, κ i → Set α) : (s ∪ ⋂ (i) (j), t i j) = ⋂ (i) (j), s ∪ t i j",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set α)  (t : ∀ i, κ i → Set α)"},
 {"type": "(⋂ (i) (j), s i j) ∪ t = ⋂ (i) (j), s i j ∪ t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ∀ i, κ i → Set α)  (t : Set α) : (⋂ (i) (j), s i j) ∪ t = ⋂ (i) (j), s i j ∪ t := by simp_rw [interᵢ_union]; sorry",
  "name": "interᵢ₂_union",
  "kind": "theorem",
  "first-tactic": "simp_rw [interᵢ_union]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ∀ i, κ i → Set α)  (t : Set α) : (⋂ (i) (j), s i j) ∪ t = ⋂ (i) (j), s i j ∪ t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ∀ i, κ i → Set α)  (t : Set α)"},
 {"type": "(⋃₀S).Nonempty ↔ ∃ s ∈ S, Set.Nonempty s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {S : Set (Set α)} : (⋃₀S).Nonempty ↔ ∃ s ∈ S, Set.Nonempty s := by simp [nonempty_iff_ne_empty]; sorry",
  "name": "nonempty_unionₛ",
  "kind": "theorem",
  "first-tactic": "simp [nonempty_iff_ne_empty]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {S : Set (Set α)} : (⋃₀S).Nonempty ↔ ∃ s ∈ S, Set.Nonempty s",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {S : Set (Set α)}"},
 {"type": "(⋃ i, f i) = univ ↔ ∀ x, ∃ i, x ∈ f i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {f : ι → Set α} : (⋃ i, f i) = univ ↔ ∀ x, ∃ i, x ∈ f i := by simp only [eq_univ_iff_forall]; sorry",
  "name": "unionᵢ_eq_univ_iff",
  "kind": "theorem",
  "first-tactic": "simp only [eq_univ_iff_forall]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {f : ι → Set α} : (⋃ i, f i) = univ ↔ ∀ x, ∃ i, x ∈ f i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {f : ι → Set α}"},
 {"type": "(⋃ (i) (j), s i j) = univ ↔ ∀ a, ∃ i j, a ∈ s i j",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : ∀ i, κ i → Set α} : (⋃ (i) (j), s i j) = univ ↔ ∀ a, ∃ i j, a ∈ s i j := by simp only [unionᵢ_eq_univ_iff]; sorry",
  "name": "unionᵢ₂_eq_univ_iff",
  "kind": "theorem",
  "first-tactic": "simp only [unionᵢ_eq_univ_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : ∀ i, κ i → Set α} : (⋃ (i) (j), s i j) = univ ↔ ∀ a, ∃ i j, a ∈ s i j",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : ∀ i, κ i → Set α}"},
 {"type": "⋃₀c = univ ↔ ∀ a, ∃ b ∈ c, a ∈ b",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {c : Set (Set α)} : ⋃₀c = univ ↔ ∀ a, ∃ b ∈ c, a ∈ b := by simp only [eq_univ_iff_forall]; sorry",
  "name": "unionₛ_eq_univ_iff",
  "kind": "theorem",
  "first-tactic": "simp only [eq_univ_iff_forall]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {c : Set (Set α)} : ⋃₀c = univ ↔ ∀ a, ∃ b ∈ c, a ∈ b",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {c : Set (Set α)}"},
 {"type": "(⋂ i, f i) = ∅ ↔ ∀ x, ∃ i, x ∉ f i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {f : ι → Set α} : (⋂ i, f i) = ∅ ↔ ∀ x, ∃ i, x ∉ f i := by simp [Set.eq_empty_iff_forall_not_mem]; sorry",
  "name": "interᵢ_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "simp [Set.eq_empty_iff_forall_not_mem]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {f : ι → Set α} : (⋂ i, f i) = ∅ ↔ ∀ x, ∃ i, x ∉ f i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {f : ι → Set α}"},
 {"type": "(⋂ (i) (j), s i j) = ∅ ↔ ∀ a, ∃ i j, a ∉ s i j",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : ∀ i, κ i → Set α} : (⋂ (i) (j), s i j) = ∅ ↔ ∀ a, ∃ i j, a ∉ s i j := by simp only [eq_empty_iff_forall_not_mem]; sorry",
  "name": "interᵢ₂_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "simp only [eq_empty_iff_forall_not_mem]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : ∀ i, κ i → Set α} : (⋂ (i) (j), s i j) = ∅ ↔ ∀ a, ∃ i j, a ∉ s i j",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : ∀ i, κ i → Set α}"},
 {"type": "⋂₀ c = ∅ ↔ ∀ a, ∃ b ∈ c, a ∉ b",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {c : Set (Set α)} : ⋂₀ c = ∅ ↔ ∀ a, ∃ b ∈ c, a ∉ b := by simp [Set.eq_empty_iff_forall_not_mem]; sorry",
  "name": "interₛ_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "simp [Set.eq_empty_iff_forall_not_mem]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {c : Set (Set α)} : ⋂₀ c = ∅ ↔ ∀ a, ∃ b ∈ c, a ∉ b",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {c : Set (Set α)}"},
 {"type": "(⋂ i, f i).Nonempty ↔ ∃ x, ∀ i, x ∈ f i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {f : ι → Set α} : (⋂ i, f i).Nonempty ↔ ∃ x, ∀ i, x ∈ f i := by simp [nonempty_iff_ne_empty]; sorry",
  "name": "nonempty_interᵢ",
  "kind": "theorem",
  "first-tactic": "simp [nonempty_iff_ne_empty]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {f : ι → Set α} : (⋂ i, f i).Nonempty ↔ ∃ x, ∀ i, x ∈ f i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {f : ι → Set α}"},
 {"type": "(⋂ (i) (j), s i j).Nonempty ↔ ∃ a, ∀ i j, a ∈ s i j",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : ∀ i, κ i → Set α} : (⋂ (i) (j), s i j).Nonempty ↔ ∃ a, ∀ i j, a ∈ s i j := by simp; sorry",
  "name": "nonempty_interᵢ₂",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : ∀ i, κ i → Set α} : (⋂ (i) (j), s i j).Nonempty ↔ ∃ a, ∀ i j, a ∈ s i j",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : ∀ i, κ i → Set α}"},
 {"type": "(⋂₀ c).Nonempty ↔ ∃ a, ∀ b ∈ c, a ∈ b",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {c : Set (Set α)} : (⋂₀ c).Nonempty ↔ ∃ a, ∀ b ∈ c, a ∈ b := by simp [nonempty_iff_ne_empty]; sorry",
  "name": "nonempty_interₛ",
  "kind": "theorem",
  "first-tactic": "simp [nonempty_iff_ne_empty]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {c : Set (Set α)} : (⋂₀ c).Nonempty ↔ ∃ a, ∀ b ∈ c, a ∈ b",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {c : Set (Set α)}"},
 {"type": "⋃₀S = (⋂₀ (compl '' S))ᶜ",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (S : Set (Set α)) : ⋃₀S = (⋂₀ (compl '' S))ᶜ := by rw [← compl_compl (⋃₀S)]; sorry",
  "name": "unionₛ_eq_compl_interₛ_compl",
  "kind": "theorem",
  "first-tactic": "rw [← compl_compl (⋃₀S)]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (S : Set (Set α)) : ⋃₀S = (⋂₀ (compl '' S))ᶜ",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (S : Set (Set α))"},
 {"type": "(⋂₀ S)ᶜ = ⋃₀(compl '' S)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (S : Set (Set α)) : (⋂₀ S)ᶜ = ⋃₀(compl '' S) := by rw [unionₛ_eq_compl_interₛ_compl]; sorry",
  "name": "compl_interₛ",
  "kind": "theorem",
  "first-tactic": "rw [unionₛ_eq_compl_interₛ_compl]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (S : Set (Set α)) : (⋂₀ S)ᶜ = ⋃₀(compl '' S)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (S : Set (Set α))"},
 {"type": "⋂₀ S = (⋃₀(compl '' S))ᶜ",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (S : Set (Set α)) : ⋂₀ S = (⋃₀(compl '' S))ᶜ := by rw [← compl_compl (⋂₀ S)]; sorry",
  "name": "interₛ_eq_compl_unionₛ_compl",
  "kind": "theorem",
  "first-tactic": "rw [← compl_compl (⋂₀ S)]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (S : Set (Set α)) : ⋂₀ S = (⋃₀(compl '' S))ᶜ",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (S : Set (Set α))"},
 {"type": "(⋃ i, s i) = range fun a : Σi, s i => a.2",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : α → Set β) : (⋃ i, s i) = range fun a : Σi, s i => a.2 := by simp [Set.ext_iff]; sorry",
  "name": "unionᵢ_eq_range_sigma",
  "kind": "theorem",
  "first-tactic": "simp [Set.ext_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : α → Set β) : (⋃ i, s i) = range fun a : Σi, s i => a.2",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : α → Set β)"},
 {"type": "(⋃ i, s i) = range fun a : Σ'i, s i => a.2",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set β) : (⋃ i, s i) = range fun a : Σ'i, s i => a.2 := by simp [Set.ext_iff]; sorry",
  "name": "unionᵢ_eq_range_psigma",
  "kind": "theorem",
  "first-tactic": "simp [Set.ext_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set β) : (⋃ i, s i) = range fun a : Σ'i, s i => a.2",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set β)"},
 {"type": "(⋃ i, Sigma.mk i '' (Sigma.mk i ⁻¹' s)) = s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι : Type _}  {σ : ι → Type _}  (s : Set (Sigma σ)) : (⋃ i, Sigma.mk i '' (Sigma.mk i ⁻¹' s)) = s := by ext x; sorry",
  "name": "unionᵢ_image_preimage_sigma_mk_eq_self",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι : Type _}  {σ : ι → Type _}  (s : Set (Sigma σ)) : (⋃ i, Sigma.mk i '' (Sigma.mk i ⁻¹' s)) = s",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {ι : Type _}  {σ : ι → Type _}  (s : Set (Sigma σ))"},
 {"type": "(⋃ x : α, {f x}) = range f",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {α β : Type _}  (f : α → β) : (⋃ x : α, {f x}) = range f := by ext x; sorry",
  "name": "unionᵢ_singleton_eq_range",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {α β : Type _}  (f : α → β) : (⋃ x : α, {f x}) = range f",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {α β : Type _}  (f : α → β)"},
 {"type": "(⋃ x, {x} : Set α) = univ",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (α : Type _) : (⋃ x, {x} : Set α) = univ := by simp [Set.ext_iff]; sorry",
  "name": "unionᵢ_of_singleton",
  "kind": "theorem",
  "first-tactic": "simp [Set.ext_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (α : Type _) : (⋃ x, {x} : Set α) = univ",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (α : Type _)"},
 {"type": "(⋃ i : s, ({(i : α)} : Set α)) = s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set α) : (⋃ i : s, ({(i : α)} : Set α)) = s := by simp; sorry",
  "name": "unionᵢ_of_singleton_coe",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set α) : (⋃ i : s, ({(i : α)} : Set α)) = s",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set α)"},
 {"type": "⋃₀s = ⋃ (i : Set α) (_h : i ∈ s), i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set (Set α)} : ⋃₀s = ⋃ (i : Set α) (_h : i ∈ s), i := by rw [← unionₛ_image]; sorry",
  "name": "unionₛ_eq_bunionᵢ",
  "kind": "theorem",
  "first-tactic": "rw [← unionₛ_image]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set (Set α)} : ⋃₀s = ⋃ (i : Set α) (_h : i ∈ s), i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set (Set α)}"},
 {"type": "⋂₀ s = ⋂ (i : Set α) (_h : i ∈ s), i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set (Set α)} : ⋂₀ s = ⋂ (i : Set α) (_h : i ∈ s), i := by rw [← interₛ_image]; sorry",
  "name": "interₛ_eq_binterᵢ",
  "kind": "theorem",
  "first-tactic": "rw [← interₛ_image]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set (Set α)} : ⋂₀ s = ⋂ (i : Set α) (_h : i ∈ s), i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set (Set α)}"},
 {"type": "⋃₀s = ⋃ i : s, i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set (Set α)} : ⋃₀s = ⋃ i : s, i := by simp only [← unionₛ_range]; sorry",
  "name": "unionₛ_eq_unionᵢ",
  "kind": "theorem",
  "first-tactic": "simp only [← unionₛ_range]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set (Set α)} : ⋃₀s = ⋃ i : s, i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set (Set α)}"},
 {"type": "⋂₀ s = ⋂ i : s, i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set (Set α)} : ⋂₀ s = ⋂ i : s, i := by simp only [← interₛ_range]; sorry",
  "name": "interₛ_eq_interᵢ",
  "kind": "theorem",
  "first-tactic": "simp only [← interₛ_range]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set (Set α)} : ⋂₀ s = ⋂ i : s, i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set (Set α)}"},
 {"type": "(⋃ x ∈ ⋃ i, s i, t x) = ⋃ (i) (x ∈ s i), t x",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set α)  (t : α → Set β) : (⋃ x ∈ ⋃ i, s i, t x) = ⋃ (i) (x ∈ s i), t x := by simp [@unionᵢ_comm _ ι]; sorry",
  "name": "bunionᵢ_unionᵢ",
  "kind": "theorem",
  "first-tactic": "simp [@unionᵢ_comm _ ι]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set α)  (t : α → Set β) : (⋃ x ∈ ⋃ i, s i, t x) = ⋃ (i) (x ∈ s i), t x",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set α)  (t : α → Set β)"},
 {"type": "(⋂ x ∈ ⋃ i, s i, t x) = ⋂ (i) (x ∈ s i), t x",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set α)  (t : α → Set β) : (⋂ x ∈ ⋃ i, s i, t x) = ⋂ (i) (x ∈ s i), t x := by simp [@interᵢ_comm _ ι]; sorry",
  "name": "binterᵢ_unionᵢ",
  "kind": "theorem",
  "first-tactic": "simp [@interᵢ_comm _ ι]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set α)  (t : α → Set β) : (⋂ x ∈ ⋃ i, s i, t x) = ⋂ (i) (x ∈ s i), t x",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set α)  (t : α → Set β)"},
 {"type": "(⋃₀⋃ i, s i) = ⋃ i, ⋃₀s i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set (Set α)) : (⋃₀⋃ i, s i) = ⋃ i, ⋃₀s i := by simp only [unionₛ_eq_bunionᵢ]; sorry",
  "name": "unionₛ_unionᵢ",
  "kind": "theorem",
  "first-tactic": "simp only [unionₛ_eq_bunionᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set (Set α)) : (⋃₀⋃ i, s i) = ⋃ i, ⋃₀s i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set (Set α))"},
 {"type": "(⋂₀ ⋃ i, s i) = ⋂ i, ⋂₀ s i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set (Set α)) : (⋂₀ ⋃ i, s i) = ⋂ i, ⋂₀ s i := by simp only [interₛ_eq_binterᵢ]; sorry",
  "name": "interₛ_unionᵢ",
  "kind": "theorem",
  "first-tactic": "simp only [interₛ_eq_binterᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set (Set α)) : (⋂₀ ⋃ i, s i) = ⋂ i, ⋂₀ s i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ι → Set (Set α))"},
 {"type": "(⋃ y : β, range fun s : C => (f s y).val) = ⋃₀C",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {α β : Type _}  (C : Set (Set α))  {f : ∀ s : C, β → (s : Type _)}      (hf : ∀ s : C, Surjective (f s)) : (⋃ y : β, range fun s : C => (f s y).val) = ⋃₀C := by ext x; sorry",
  "name": "unionᵢ_range_eq_unionₛ",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {α β : Type _}  (C : Set (Set α))  {f : ∀ s : C, β → (s : Type _)}      (hf : ∀ s : C, Surjective (f s)) : (⋃ y : β, range fun s : C => (f s y).val) = ⋃₀C",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} {α β : Type _}  (C : Set (Set α))  {f : ∀ s : C, β → (s : Type _)}      (hf : ∀ s : C, Surjective (f s))"},
 {"type": "(⋃ y : β, range fun x : ι => (f x y).val) = ⋃ x, C x",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (C : ι → Set α)  {f : ∀ x : ι, β → C x}      (hf : ∀ x : ι, Surjective (f x)) : (⋃ y : β, range fun x : ι => (f x y).val) = ⋃ x, C x := by ext x; sorry",
  "name": "unionᵢ_range_eq_unionᵢ",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (C : ι → Set α)  {f : ∀ x : ι, β → C x}      (hf : ∀ x : ι, Surjective (f x)) : (⋃ y : β, range fun x : ι => (f x y).val) = ⋃ x, C x",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (C : ι → Set α)  {f : ∀ x : ι, β → C x}      (hf : ∀ x : ι, Surjective (f x))"},
 {"type": "(s ∪ ⋂ (i) (j), t i j) = ⋂ (i) (j), s ∪ t i j",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set α)  (t : ∀ i, κ i → Set α) : (s ∪ ⋂ (i) (j), t i j) = ⋂ (i) (j), s ∪ t i j := by simp_rw [union_distrib_interᵢ_left]; sorry",
  "name": "union_distrib_interᵢ₂_left",
  "kind": "theorem",
  "first-tactic": "simp_rw [union_distrib_interᵢ_left]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set α)  (t : ∀ i, κ i → Set α) : (s ∪ ⋂ (i) (j), t i j) = ⋂ (i) (j), s ∪ t i j",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : Set α)  (t : ∀ i, κ i → Set α)"},
 {"type": "(⋂ (i) (j), s i j) ∪ t = ⋂ (i) (j), s i j ∪ t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ∀ i, κ i → Set α)  (t : Set α) : (⋂ (i) (j), s i j) ∪ t = ⋂ (i) (j), s i j ∪ t := by simp_rw [union_distrib_interᵢ_right]; sorry",
  "name": "union_distrib_interᵢ₂_right",
  "kind": "theorem",
  "first-tactic": "simp_rw [union_distrib_interᵢ_right]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ∀ i, κ i → Set α)  (t : Set α) : (⋂ (i) (j), s i j) ∪ t = ⋂ (i) (j), s i j ∪ t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} (s : ∀ i, κ i → Set α)  (t : Set α)"},
 {"type": "f '' ⋂₀ S ⊆ ⋂ s ∈ S, f '' s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  (S : Set (Set α))  (f : α → β) : f '' ⋂₀ S ⊆ ⋂ s ∈ S, f '' s := by rw [interₛ_eq_binterᵢ]; sorry",
  "name": "image_interₛ_subset",
  "kind": "theorem",
  "first-tactic": "rw [interₛ_eq_binterᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  (S : Set (Set α))  (f : α → β) : f '' ⋂₀ S ⊆ ⋂ s ∈ S, f '' s",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  (S : Set (Set α))  (f : α → β)"},
 {"type": "Injective f ↔ ∀ i, Injective ((U i).restrictPreimage f)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (s : Set β)  {f : α → β}  {U : ι → Set β}  (hU : unionᵢ U = univ) : Injective f ↔ ∀ i, Injective ((U i).restrictPreimage f) := by refine' ⟨fun H i => (U i).restrictPreimage_injective H, fun H x y e => _⟩; sorry",
  "name": "injective_iff_injective_of_unionᵢ_eq_univ",
  "kind": "theorem",
  "first-tactic":
  "refine' ⟨fun H i => (U i).restrictPreimage_injective H, fun H x y e => _⟩",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (s : Set β)  {f : α → β}  {U : ι → Set β}  (hU : unionᵢ U = univ) : Injective f ↔ ∀ i, Injective ((U i).restrictPreimage f)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (s : Set β)  {f : α → β}  {U : ι → Set β}  (hU : unionᵢ U = univ)"},
 {"type": "Surjective f ↔ ∀ i, Surjective ((U i).restrictPreimage f)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (s : Set β)  {f : α → β}  {U : ι → Set β}  (hU : unionᵢ U = univ) : Surjective f ↔ ∀ i, Surjective ((U i).restrictPreimage f) := by refine' ⟨fun H i => (U i).restrictPreimage_surjective H, fun H x => _⟩; sorry",
  "name": "surjective_iff_surjective_of_unionᵢ_eq_univ",
  "kind": "theorem",
  "first-tactic":
  "refine' ⟨fun H i => (U i).restrictPreimage_surjective H, fun H x => _⟩",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (s : Set β)  {f : α → β}  {U : ι → Set β}  (hU : unionᵢ U = univ) : Surjective f ↔ ∀ i, Surjective ((U i).restrictPreimage f)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (s : Set β)  {f : α → β}  {U : ι → Set β}  (hU : unionᵢ U = univ)"},
 {"type": "Bijective f ↔ ∀ i, Bijective ((U i).restrictPreimage f)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (s : Set β)  {f : α → β}  {U : ι → Set β}  (hU : unionᵢ U = univ) : Bijective f ↔ ∀ i, Bijective ((U i).restrictPreimage f) := by rw [Bijective]; sorry",
  "name": "bijective_iff_bijective_of_unionᵢ_eq_univ",
  "kind": "theorem",
  "first-tactic": "rw [Bijective]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (s : Set β)  {f : α → β}  {U : ι → Set β}  (hU : unionᵢ U = univ) : Bijective f ↔ ∀ i, Bijective ((U i).restrictPreimage f)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (s : Set β)  {f : α → β}  {U : ι → Set β}  (hU : unionᵢ U = univ)"},
 {"type": "f '' (s ∩ t) = f '' s ∩ f '' t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {f : α → β}  {s t u : Set α}  (hf : InjOn f u)  (hs : s ⊆ u)  (ht : t ⊆ u) : f '' (s ∩ t) = f '' s ∩ f '' t := by apply Subset.antisymm (image_inter_subset _ _ _); sorry",
  "name": "InjOn.image_inter",
  "kind": "theorem",
  "first-tactic": "apply Subset.antisymm (image_inter_subset _ _ _)",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {f : α → β}  {s t u : Set α}  (hf : InjOn f u)  (hs : s ⊆ u)  (ht : t ⊆ u) : f '' (s ∩ t) = f '' s ∩ f '' t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {f : α → β}  {s t u : Set α}  (hf : InjOn f u)  (hs : s ⊆ u)  (ht : t ⊆ u)"},
 {"type": "(f '' ⋂ i, s i) = ⋂ i, f '' s i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  [Nonempty ι]  {s : ι → Set α}  {f : α → β}  (h : InjOn f (⋃ i, s i)) : (f '' ⋂ i, s i) = ⋂ i, f '' s i := by inhabit ι; sorry",
  "name": "InjOn.image_interᵢ_eq",
  "kind": "theorem",
  "first-tactic": "inhabit ι",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  [Nonempty ι]  {s : ι → Set α}  {f : α → β}  (h : InjOn f (⋃ i, s i)) : (f '' ⋂ i, s i) = ⋂ i, f '' s i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  [Nonempty ι]  {s : ι → Set α}  {f : α → β}  (h : InjOn f (⋃ i, s i))"},
 {"type": "(f '' ⋂ (i) (hi), s i hi) = ⋂ (i) (hi), f '' s i hi",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {p : ι → Prop}  {s : ∀ (i) (_ : p i), Set α}  (hp : ∃ i, p i)      {f : α → β}  (h : InjOn f (⋃ (i) (hi), s i hi)) : (f '' ⋂ (i) (hi), s i hi) = ⋂ (i) (hi), f '' s i hi := by simp only [interᵢ]; sorry",
  "name": "InjOn.image_binterᵢ_eq",
  "kind": "theorem",
  "first-tactic": "simp only [interᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {p : ι → Prop}  {s : ∀ (i) (_ : p i), Set α}  (hp : ∃ i, p i)      {f : α → β}  (h : InjOn f (⋃ (i) (hi), s i hi)) : (f '' ⋂ (i) (hi), s i hi) = ⋂ (i) (hi), f '' s i hi",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {p : ι → Prop}  {s : ∀ (i) (_ : p i), Set α}  (hp : ∃ i, p i)      {f : α → β}  (h : InjOn f (⋃ (i) (hi), s i hi))"},
 {"type": "(f '' ⋂ i, s i) = ⋂ i, f '' s i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {f : α → β}  (hf : Bijective f)  (s : ι → Set α) : (f '' ⋂ i, s i) = ⋂ i, f '' s i := by cases isEmpty_or_nonempty ι; sorry",
  "name": "image_interᵢ",
  "kind": "theorem",
  "first-tactic": "cases isEmpty_or_nonempty ι",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {f : α → β}  (hf : Bijective f)  (s : ι → Set α) : (f '' ⋂ i, s i) = ⋂ i, f '' s i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {f : α → β}  (hf : Bijective f)  (s : ι → Set α)"},
 {"type": "(f '' ⋂ (i) (j), s i j) = ⋂ (i) (j), f '' s i j",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {f : α → β}  (hf : Bijective f)  (s : ∀ i, κ i → Set α) : (f '' ⋂ (i) (j), s i j) = ⋂ (i) (j), f '' s i j := by simp_rw [image_interᵢ hf]; sorry",
  "name": "image_interᵢ₂",
  "kind": "theorem",
  "first-tactic": "simp_rw [image_interᵢ hf]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {f : α → β}  (hf : Bijective f)  (s : ∀ i, κ i → Set α) : (f '' ⋂ (i) (j), s i j) = ⋂ (i) (j), f '' s i j",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {f : α → β}  (hf : Bijective f)  (s : ∀ i, κ i → Set α)"},
 {"type": "InjOn f (⋃ i, s i)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {s : ι → Set α}  (hs : Directed (· ⊆ ·) s)  {f : α → β}      (hf : ∀ i, InjOn f (s i)) : InjOn f (⋃ i, s i) := by intro x hx y hy hxy; sorry",
  "name": "inj_on_unionᵢ_of_directed",
  "kind": "theorem",
  "first-tactic": "intro x hx y hy hxy",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {s : ι → Set α}  (hs : Directed (· ⊆ ·) s)  {f : α → β}      (hf : ∀ i, InjOn f (s i)) : InjOn f (⋃ i, s i)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  {s : ι → Set α}  (hs : Directed (· ⊆ ·) s)  {f : α → β}      (hf : ∀ i, InjOn f (s i))"},
 {"type": "SurjOn f (⋂ i, s i) t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  [Nonempty ι]  {s : ι → Set α}  {t : Set β}  {f : α → β}      (H : ∀ i, SurjOn f (s i) t)  (Hinj : InjOn f (⋃ i, s i)) : SurjOn f (⋂ i, s i) t := by intro y hy; sorry",
  "name": "surjOn_interᵢ",
  "kind": "theorem",
  "first-tactic": "intro y hy",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  [Nonempty ι]  {s : ι → Set α}  {t : Set β}  {f : α → β}      (H : ∀ i, SurjOn f (s i) t)  (Hinj : InjOn f (⋃ i, s i)) : SurjOn f (⋂ i, s i) t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}  [Nonempty ι]  {s : ι → Set α}  {t : Set β}  {f : α → β}      (H : ∀ i, SurjOn f (s i) t)  (Hinj : InjOn f (⋃ i, s i))"},
 {"type": "(f '' ⋃ i, s i) = ⋃ i, f '' s i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : ι → Set α} : (f '' ⋃ i, s i) = ⋃ i, f '' s i := by ext1 x; sorry",
  "name": "image_unionᵢ",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : ι → Set α} : (f '' ⋃ i, s i) = ⋃ i, f '' s i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : ι → Set α}"},
 {"type": "(f '' ⋃ (i) (j), s i j) = ⋃ (i) (j), f '' s i j",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (f : α → β)  (s : ∀ i, κ i → Set α) : (f '' ⋃ (i) (j), s i j) = ⋃ (i) (j), f '' s i j := by simp_rw [image_unionᵢ]; sorry",
  "name": "image_unionᵢ₂",
  "kind": "theorem",
  "first-tactic": "simp_rw [image_unionᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (f : α → β)  (s : ∀ i, κ i → Set α) : (f '' ⋃ (i) (j), s i j) = ⋃ (i) (j), f '' s i j",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (f : α → β)  (s : ∀ i, κ i → Set α)"},
 {"type": "(⋃ (x) (y) (_h : f y = x), g x) = ⋃ y, g (f y)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : ι → α}  {g : α → Set β} : (⋃ (x) (y) (_h : f y = x), g x) = ⋃ y, g (f y) := by simpa using bunionᵢ_range; sorry",
  "name": "unionᵢ_unionᵢ_eq'",
  "kind": "theorem",
  "first-tactic": "simpa using bunionᵢ_range",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : ι → α}  {g : α → Set β} : (⋃ (x) (y) (_h : f y = x), g x) = ⋃ y, g (f y)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : ι → α}  {g : α → Set β}"},
 {"type": "(⋂ (x) (y) (_h : f y = x), g x) = ⋂ y, g (f y)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : ι → α}  {g : α → Set β} : (⋂ (x) (y) (_h : f y = x), g x) = ⋂ y, g (f y) := by simpa using binterᵢ_range; sorry",
  "name": "interᵢ_interᵢ_eq'",
  "kind": "theorem",
  "first-tactic": "simpa using binterᵢ_range",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : ι → α}  {g : α → Set β} : (⋂ (x) (y) (_h : f y = x), g x) = ⋂ y, g (f y)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : ι → α}  {g : α → Set β}"},
 {"type": "(f ⁻¹' ⋃ (i) (j), s i j) = ⋃ (i) (j), f ⁻¹' s i j",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : ∀ i, κ i → Set β} : (f ⁻¹' ⋃ (i) (j), s i j) = ⋃ (i) (j), f ⁻¹' s i j := by simp_rw [preimage_unionᵢ]; sorry",
  "name": "preimage_unionᵢ₂",
  "kind": "theorem",
  "first-tactic": "simp_rw [preimage_unionᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : ∀ i, κ i → Set β} : (f ⁻¹' ⋃ (i) (j), s i j) = ⋃ (i) (j), f ⁻¹' s i j",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : ∀ i, κ i → Set β}"},
 {"type": "f ⁻¹' ⋃₀s = ⋃ t ∈ s, f ⁻¹' t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : Set (Set β)} : f ⁻¹' ⋃₀s = ⋃ t ∈ s, f ⁻¹' t := by rw [unionₛ_eq_bunionᵢ]; sorry",
  "name": "preimage_unionₛ",
  "kind": "theorem",
  "first-tactic": "rw [unionₛ_eq_bunionᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : Set (Set β)} : f ⁻¹' ⋃₀s = ⋃ t ∈ s, f ⁻¹' t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : Set (Set β)}"},
 {"type": "(f ⁻¹' ⋂ i, s i) = ⋂ i, f ⁻¹' s i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : ι → Set β} : (f ⁻¹' ⋂ i, s i) = ⋂ i, f ⁻¹' s i := by ext; sorry",
  "name": "preimage_interᵢ",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : ι → Set β} : (f ⁻¹' ⋂ i, s i) = ⋂ i, f ⁻¹' s i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : ι → Set β}"},
 {"type": "(f ⁻¹' ⋂ (i) (j), s i j) = ⋂ (i) (j), f ⁻¹' s i j",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : ∀ i, κ i → Set β} : (f ⁻¹' ⋂ (i) (j), s i j) = ⋂ (i) (j), f ⁻¹' s i j := by simp_rw [preimage_interᵢ]; sorry",
  "name": "preimage_interᵢ₂",
  "kind": "theorem",
  "first-tactic": "simp_rw [preimage_interᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : ∀ i, κ i → Set β} : (f ⁻¹' ⋂ (i) (j), s i j) = ⋂ (i) (j), f ⁻¹' s i j",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : ∀ i, κ i → Set β}"},
 {"type": "f ⁻¹' ⋂₀ s = ⋂ t ∈ s, f ⁻¹' t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : Set (Set β)} : f ⁻¹' ⋂₀ s = ⋂ t ∈ s, f ⁻¹' t := by rw [interₛ_eq_binterᵢ]; sorry",
  "name": "preimage_interₛ",
  "kind": "theorem",
  "first-tactic": "rw [interₛ_eq_binterᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : Set (Set β)} : f ⁻¹' ⋂₀ s = ⋂ t ∈ s, f ⁻¹' t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : Set (Set β)}"},
 {"type": "(⋃ y ∈ s, f ⁻¹' {y}) = f ⁻¹' s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (f : α → β)  (s : Set β) : (⋃ y ∈ s, f ⁻¹' {y}) = f ⁻¹' s := by rw [← preimage_unionᵢ₂]; sorry",
  "name": "bunionᵢ_preimage_singleton",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_unionᵢ₂]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (f : α → β)  (s : Set β) : (⋃ y ∈ s, f ⁻¹' {y}) = f ⁻¹' s",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (f : α → β)  (s : Set β)"},
 {"type": "(⋃ y ∈ range f, f ⁻¹' {y}) = univ",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (f : α → β) : (⋃ y ∈ range f, f ⁻¹' {y}) = univ := by rw [bunionᵢ_preimage_singleton]; sorry",
  "name": "bunionᵢ_range_preimage_singleton",
  "kind": "theorem",
  "first-tactic": "rw [bunionᵢ_preimage_singleton]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (f : α → β) : (⋃ y ∈ range f, f ⁻¹' {y}) = univ",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (f : α → β)"},
 {"type": "(s ×ˢ ⋃ i, t i) = ⋃ i, s ×ˢ t i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s : Set α}  {t : ι → Set β} : (s ×ˢ ⋃ i, t i) = ⋃ i, s ×ˢ t i := by ext; sorry",
  "name": "prod_unionᵢ",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s : Set α}  {t : ι → Set β} : (s ×ˢ ⋃ i, t i) = ⋃ i, s ×ˢ t i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s : Set α}  {t : ι → Set β}"},
 {"type": "(s ×ˢ ⋃ (i) (j), t i j) = ⋃ (i) (j), s ×ˢ t i j",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s : Set α}  {t : ∀ i, κ i → Set β} : (s ×ˢ ⋃ (i) (j), t i j) = ⋃ (i) (j), s ×ˢ t i j := by simp_rw [prod_unionᵢ]; sorry",
  "name": "prod_unionᵢ₂",
  "kind": "theorem",
  "first-tactic": "simp_rw [prod_unionᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s : Set α}  {t : ∀ i, κ i → Set β} : (s ×ˢ ⋃ (i) (j), t i j) = ⋃ (i) (j), s ×ˢ t i j",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s : Set α}  {t : ∀ i, κ i → Set β}"},
 {"type": "s ×ˢ ⋃₀C = ⋃₀((fun t => s ×ˢ t) '' C)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s : Set α}  {C : Set (Set β)} : s ×ˢ ⋃₀C = ⋃₀((fun t => s ×ˢ t) '' C) := by simp_rw [unionₛ_eq_bunionᵢ]; sorry",
  "name": "prod_unionₛ",
  "kind": "theorem",
  "first-tactic": "simp_rw [unionₛ_eq_bunionᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s : Set α}  {C : Set (Set β)} : s ×ˢ ⋃₀C = ⋃₀((fun t => s ×ˢ t) '' C)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s : Set α}  {C : Set (Set β)}"},
 {"type": "(⋃ i, s i) ×ˢ t = ⋃ i, s i ×ˢ t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s : ι → Set α}  {t : Set β} : (⋃ i, s i) ×ˢ t = ⋃ i, s i ×ˢ t := by ext; sorry",
  "name": "unionᵢ_prod_const",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s : ι → Set α}  {t : Set β} : (⋃ i, s i) ×ˢ t = ⋃ i, s i ×ˢ t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s : ι → Set α}  {t : Set β}"},
 {"type": "(⋃ (i) (j), s i j) ×ˢ t = ⋃ (i) (j), s i j ×ˢ t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s : ∀ i, κ i → Set α}  {t : Set β} : (⋃ (i) (j), s i j) ×ˢ t = ⋃ (i) (j), s i j ×ˢ t := by simp_rw [unionᵢ_prod_const]; sorry",
  "name": "unionᵢ₂_prod_const",
  "kind": "theorem",
  "first-tactic": "simp_rw [unionᵢ_prod_const]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s : ∀ i, κ i → Set α}  {t : Set β} : (⋃ (i) (j), s i j) ×ˢ t = ⋃ (i) (j), s i j ×ˢ t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s : ∀ i, κ i → Set α}  {t : Set β}"},
 {"type": "⋃₀C ×ˢ t = ⋃₀((fun s : Set α => s ×ˢ t) '' C)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {C : Set (Set α)}  {t : Set β} : ⋃₀C ×ˢ t = ⋃₀((fun s : Set α => s ×ˢ t) '' C) := by simp only [unionₛ_eq_bunionᵢ]; sorry",
  "name": "unionₛ_prod_const",
  "kind": "theorem",
  "first-tactic": "simp only [unionₛ_eq_bunionᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {C : Set (Set α)}  {t : Set β} : ⋃₀C ×ˢ t = ⋃₀((fun s : Set α => s ×ˢ t) '' C)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {C : Set (Set α)}  {t : Set β}"},
 {"type": "(⋃ x, s x ×ˢ t x) = (⋃ x, s x) ×ˢ ⋃ x, t x",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [SemilatticeSup α]  {s : α → Set β}  {t : α → Set γ}  (hs : Monotone s)      (ht : Monotone t) : (⋃ x, s x ×ˢ t x) = (⋃ x, s x) ×ˢ ⋃ x, t x := by ext ⟨z, w⟩; sorry",
  "name": "unionᵢ_prod_of_monotone",
  "kind": "theorem",
  "first-tactic": "ext ⟨z, w⟩",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [SemilatticeSup α]  {s : α → Set β}  {t : α → Set γ}  (hs : Monotone s)      (ht : Monotone t) : (⋃ x, s x ×ˢ t x) = (⋃ x, s x) ×ˢ ⋃ x, t x",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [SemilatticeSup α]  {s : α → Set β}  {t : α → Set γ}  (hs : Monotone s)      (ht : Monotone t)"},
 {"type": "⋂₀ S ×ˢ ⋂₀ T = ⋂ r ∈ S ×ˢ T, r.1 ×ˢ r.2",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {S : Set (Set α)}  {T : Set (Set β)}  (hS : S.Nonempty)  (hT : T.Nonempty) : ⋂₀ S ×ˢ ⋂₀ T = ⋂ r ∈ S ×ˢ T, r.1 ×ˢ r.2 := by obtain ⟨s₁, h₁⟩ := hS; sorry",
  "name": "interₛ_prod_interₛ",
  "kind": "theorem",
  "first-tactic": "obtain ⟨s₁, h₁⟩ := hS",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {S : Set (Set α)}  {T : Set (Set β)}  (hS : S.Nonempty)  (hT : T.Nonempty) : ⋂₀ S ×ˢ ⋂₀ T = ⋂ r ∈ S ×ˢ T, r.1 ×ˢ r.2",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {S : Set (Set α)}  {T : Set (Set β)}  (hS : S.Nonempty)  (hT : T.Nonempty)"},
 {"type": "⋂₀ S ×ˢ t = ⋂ s ∈ S, s ×ˢ t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {S : Set (Set α)}  (hS : S.Nonempty)  (t : Set β) : ⋂₀ S ×ˢ t = ⋂ s ∈ S, s ×ˢ t := by rw [← interₛ_singleton t]; sorry",
  "name": "interₛ_prod",
  "kind": "theorem",
  "first-tactic": "rw [← interₛ_singleton t]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {S : Set (Set α)}  (hS : S.Nonempty)  (t : Set β) : ⋂₀ S ×ˢ t = ⋂ s ∈ S, s ×ˢ t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {S : Set (Set α)}  (hS : S.Nonempty)  (t : Set β)"},
 {"type": "s ×ˢ ⋂₀ T = ⋂ t ∈ T, s ×ˢ t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {T : Set (Set β)}  (hT : T.Nonempty)  (s : Set α) : s ×ˢ ⋂₀ T = ⋂ t ∈ T, s ×ˢ t := by rw [← interₛ_singleton s]; sorry",
  "name": "prod_interₛ",
  "kind": "theorem",
  "first-tactic": "rw [← interₛ_singleton s]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {T : Set (Set β)}  (hT : T.Nonempty)  (s : Set α) : s ×ˢ ⋂₀ T = ⋂ t ∈ T, s ×ˢ t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {T : Set (Set β)}  (hT : T.Nonempty)  (s : Set α)"},
 {"type": "(⋃ a ∈ s, f a '' t) = image2 f s t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} : (⋃ a ∈ s, f a '' t) = image2 f s t := by ext y; sorry",
  "name": "unionᵢ_image_left",
  "kind": "theorem",
  "first-tactic": "ext y",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} : (⋃ a ∈ s, f a '' t) = image2 f s t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β}"},
 {"type": "(⋃ b ∈ t, (fun a => f a b) '' s) = image2 f s t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} : (⋃ b ∈ t, (fun a => f a b) '' s) = image2 f s t := by ext y; sorry",
  "name": "unionᵢ_image_right",
  "kind": "theorem",
  "first-tactic": "ext y",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} : (⋃ b ∈ t, (fun a => f a b) '' s) = image2 f s t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β}"},
 {"type": "image2 f (⋃ i, s i) t = ⋃ i, image2 f (s i) t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : ι → Set α)  (t : Set β) : image2 f (⋃ i, s i) t = ⋃ i, image2 f (s i) t := by simp only [← image_prod]; sorry",
  "name": "image2_unionᵢ_left",
  "kind": "theorem",
  "first-tactic": "simp only [← image_prod]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : ι → Set α)  (t : Set β) : image2 f (⋃ i, s i) t = ⋃ i, image2 f (s i) t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : ι → Set α)  (t : Set β)"},
 {"type": "image2 f s (⋃ i, t i) = ⋃ i, image2 f s (t i)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : Set α)  (t : ι → Set β) : image2 f s (⋃ i, t i) = ⋃ i, image2 f s (t i) := by simp only [← image_prod]; sorry",
  "name": "image2_unionᵢ_right",
  "kind": "theorem",
  "first-tactic": "simp only [← image_prod]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : Set α)  (t : ι → Set β) : image2 f s (⋃ i, t i) = ⋃ i, image2 f s (t i)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : Set α)  (t : ι → Set β)"},
 {"type": "image2 f (⋃ (i) (j), s i j) t = ⋃ (i) (j), image2 f (s i j) t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : ∀ i, κ i → Set α)  (t : Set β) : image2 f (⋃ (i) (j), s i j) t = ⋃ (i) (j), image2 f (s i j) t := by simp_rw [image2_unionᵢ_left]; sorry",
  "name": "image2_unionᵢ₂_left",
  "kind": "theorem",
  "first-tactic": "simp_rw [image2_unionᵢ_left]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : ∀ i, κ i → Set α)  (t : Set β) : image2 f (⋃ (i) (j), s i j) t = ⋃ (i) (j), image2 f (s i j) t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : ∀ i, κ i → Set α)  (t : Set β)"},
 {"type": "image2 f s (⋃ (i) (j), t i j) = ⋃ (i) (j), image2 f s (t i j)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : Set α)  (t : ∀ i, κ i → Set β) : image2 f s (⋃ (i) (j), t i j) = ⋃ (i) (j), image2 f s (t i j) := by simp_rw [image2_unionᵢ_right]; sorry",
  "name": "image2_unionᵢ₂_right",
  "kind": "theorem",
  "first-tactic": "simp_rw [image2_unionᵢ_right]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : Set α)  (t : ∀ i, κ i → Set β) : image2 f s (⋃ (i) (j), t i j) = ⋃ (i) (j), image2 f s (t i j)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : Set α)  (t : ∀ i, κ i → Set β)"},
 {"type": "image2 f (⋂ i, s i) t ⊆ ⋂ i, image2 f (s i) t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : ι → Set α)  (t : Set β) : image2 f (⋂ i, s i) t ⊆ ⋂ i, image2 f (s i) t := by simp_rw [image2_subset_iff]; sorry",
  "name": "image2_interᵢ_subset_left",
  "kind": "theorem",
  "first-tactic": "simp_rw [image2_subset_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : ι → Set α)  (t : Set β) : image2 f (⋂ i, s i) t ⊆ ⋂ i, image2 f (s i) t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : ι → Set α)  (t : Set β)"},
 {"type": "image2 f s (⋂ i, t i) ⊆ ⋂ i, image2 f s (t i)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : Set α)  (t : ι → Set β) : image2 f s (⋂ i, t i) ⊆ ⋂ i, image2 f s (t i) := by simp_rw [image2_subset_iff]; sorry",
  "name": "image2_interᵢ_subset_right",
  "kind": "theorem",
  "first-tactic": "simp_rw [image2_subset_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : Set α)  (t : ι → Set β) : image2 f s (⋂ i, t i) ⊆ ⋂ i, image2 f s (t i)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : Set α)  (t : ι → Set β)"},
 {"type": "image2 f (⋂ (i) (j), s i j) t ⊆ ⋂ (i) (j), image2 f (s i j) t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : ∀ i, κ i → Set α)  (t : Set β) : image2 f (⋂ (i) (j), s i j) t ⊆ ⋂ (i) (j), image2 f (s i j) t := by simp_rw [image2_subset_iff]; sorry",
  "name": "image2_interᵢ₂_subset_left",
  "kind": "theorem",
  "first-tactic": "simp_rw [image2_subset_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : ∀ i, κ i → Set α)  (t : Set β) : image2 f (⋂ (i) (j), s i j) t ⊆ ⋂ (i) (j), image2 f (s i j) t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : ∀ i, κ i → Set α)  (t : Set β)"},
 {"type": "image2 f s (⋂ (i) (j), t i j) ⊆ ⋂ (i) (j), image2 f s (t i j)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : Set α)  (t : ∀ i, κ i → Set β) : image2 f s (⋂ (i) (j), t i j) ⊆ ⋂ (i) (j), image2 f s (t i j) := by simp_rw [image2_subset_iff]; sorry",
  "name": "image2_interᵢ₂_subset_right",
  "kind": "theorem",
  "first-tactic": "simp_rw [image2_subset_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : Set α)  (t : ∀ i, κ i → Set β) : image2 f s (⋂ (i) (j), t i j) ⊆ ⋂ (i) (j), image2 f s (t i j)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : Set α)  (t : ∀ i, κ i → Set β)"},
 {"type": "image2 f s t = ⋃ (i ∈ s) (j ∈ t), {f i j}",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : Set α)  (t : Set β) : image2 f s t = ⋃ (i ∈ s) (j ∈ t), {f i j} := by simp_rw [← image_eq_unionᵢ]; sorry",
  "name": "image2_eq_unionᵢ",
  "kind": "theorem",
  "first-tactic": "simp_rw [← image_eq_unionᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : Set α)  (t : Set β) : image2 f s t = ⋃ (i ∈ s) (j ∈ t), {f i j}",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} (s : Set α)  (t : Set β)"},
 {"type": "s ×ˢ t = ⋃ a ∈ s, (fun b => (a, b)) '' t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} : s ×ˢ t = ⋃ a ∈ s, (fun b => (a, b)) '' t := by rw [unionᵢ_image_left]; sorry",
  "name": "prod_eq_bunionᵢ_left",
  "kind": "theorem",
  "first-tactic": "rw [unionᵢ_image_left]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} : s ×ˢ t = ⋃ a ∈ s, (fun b => (a, b)) '' t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β}"},
 {"type": "s ×ˢ t = ⋃ b ∈ t, (fun a => (a, b)) '' s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} : s ×ˢ t = ⋃ b ∈ t, (fun a => (a, b)) '' s := by rw [unionᵢ_image_right]; sorry",
  "name": "prod_eq_bunionᵢ_right",
  "kind": "theorem",
  "first-tactic": "rw [unionᵢ_image_right]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β} : s ×ˢ t = ⋃ b ∈ t, (fun a => (a, b)) '' s",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  {s : Set α}  {t : Set β}"},
 {"type": "seq s (seq t u) = seq (seq ((· ∘ ·) '' s) t) u",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {s : Set (β → γ)}  {t : Set (α → β)}  {u : Set α} : seq s (seq t u) = seq (seq ((· ∘ ·) '' s) t) u := by refine' Set.ext fun c => Iff.intro _ _; sorry",
  "name": "seq_seq",
  "kind": "theorem",
  "first-tactic": "refine' Set.ext fun c => Iff.intro _ _",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {s : Set (β → γ)}  {t : Set (α → β)}  {u : Set α} : seq s (seq t u) = seq (seq ((· ∘ ·) '' s) t) u",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {s : Set (β → γ)}  {t : Set (α → β)}  {u : Set α}"},
 {"type": "f '' seq s t = seq ((· ∘ ·) f '' s) t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {f : β → γ}  {s : Set (α → β)}  {t : Set α} : f '' seq s t = seq ((· ∘ ·) f '' s) t := by rw [← singleton_seq]; sorry",
  "name": "image_seq",
  "kind": "theorem",
  "first-tactic": "rw [← singleton_seq]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {f : β → γ}  {s : Set (α → β)}  {t : Set α} : f '' seq s t = seq ((· ∘ ·) f '' s) t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {f : β → γ}  {s : Set (α → β)}  {t : Set α}"},
 {"type": "s ×ˢ t = (Prod.mk '' s).seq t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {s : Set α}  {t : Set β} : s ×ˢ t = (Prod.mk '' s).seq t := by ext ⟨a, b⟩; sorry",
  "name": "prod_eq_seq",
  "kind": "theorem",
  "first-tactic": "ext ⟨a, b⟩",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {s : Set α}  {t : Set β} : s ×ˢ t = (Prod.mk '' s).seq t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {s : Set α}  {t : Set β}"},
 {"type": "(Prod.mk '' s).seq t = seq ((fun b a => (a, b)) '' t) s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (s : Set α)  (t : Set β) : (Prod.mk '' s).seq t = seq ((fun b a => (a, b)) '' t) s := by rw [← prod_eq_seq]; sorry",
  "name": "prod_image_seq_comm",
  "kind": "theorem",
  "first-tactic": "rw [← prod_eq_seq]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (s : Set α)  (t : Set β) : (Prod.mk '' s).seq t = seq ((fun b a => (a, b)) '' t) s",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (s : Set α)  (t : Set β)"},
 {"type": "image2 f s t = seq (f '' s) t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  (s : Set α)  (t : Set β) : image2 f s t = seq (f '' s) t := by ext; sorry",
  "name": "image2_eq_seq",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  (s : Set α)  (t : Set β) : image2 f s t = seq (f '' s) t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    (f : α → β → γ)  (s : Set α)  (t : Set β)"},
 {"type": "pi i s = ⋂ a ∈ i, eval a ⁻¹' s a",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {π : α → Type _} (i : Set α)  (s : ∀ a, Set (π a)) : pi i s = ⋂ a ∈ i, eval a ⁻¹' s a := by ext; sorry",
  "name": "pi_def",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {π : α → Type _} (i : Set α)  (s : ∀ a, Set (π a)) : pi i s = ⋂ a ∈ i, eval a ⁻¹' s a",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {π : α → Type _} (i : Set α)  (s : ∀ a, Set (π a))"},
 {"type": "pi univ t = ⋂ i, eval i ⁻¹' t i",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {π : α → Type _} (t : ∀ i, Set (π i)) : pi univ t = ⋂ i, eval i ⁻¹' t i := by simp only [pi_def]; sorry",
  "name": "univ_pi_eq_interᵢ",
  "kind": "theorem",
  "first-tactic": "simp only [pi_def]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {π : α → Type _} (t : ∀ i, Set (π i)) : pi univ t = ⋂ i, eval i ⁻¹' t i",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {π : α → Type _} (t : ∀ i, Set (π i))"},
 {"type": "pi i s \\ pi i t ⊆ ⋃ a ∈ i, eval a ⁻¹' (s a \\ t a)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {π : α → Type _} (i : Set α)  (s t : ∀ a, Set (π a)) : pi i s \\ pi i t ⊆ ⋃ a ∈ i, eval a ⁻¹' (s a \\ t a) := by refine' diff_subset_comm.2 fun x hx a ha => _; sorry",
  "name": "pi_diff_pi_subset",
  "kind": "theorem",
  "first-tactic": "refine' diff_subset_comm.2 fun x hx a ha => _",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {π : α → Type _} (i : Set α)  (s t : ∀ a, Set (π a)) : pi i s \\ pi i t ⊆ ⋃ a ∈ i, eval a ⁻¹' (s a \\ t a)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {π : α → Type _} (i : Set α)  (s t : ∀ a, Set (π a))"},
 {"type":
  "(⋃ x : α → ι, pi univ fun i => t i (x i)) = pi univ fun i => ⋃ j : ι, t i j",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {π : α → Type _} (t : ∀ i, ι → Set (π i)) : (⋃ x : α → ι, pi univ fun i => t i (x i)) = pi univ fun i => ⋃ j : ι, t i j := by ext; sorry",
  "name": "unionᵢ_univ_pi",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {π : α → Type _} (t : ∀ i, ι → Set (π i)) : (⋃ x : α → ι, pi univ fun i => t i (x i)) = pi univ fun i => ⋃ j : ι, t i j",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}    {π : α → Type _} (t : ∀ i, ι → Set (π i))"},
 {"type": "Disjoint s t ↔ ∀ x ∈ s, ∀ y ∈ t, x ≠ y",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} : Disjoint s t ↔ ∀ x ∈ s, ∀ y ∈ t, x ≠ y := by simp only [Ne.def]; sorry",
  "name": "disjoint_iff_forall_ne",
  "kind": "theorem",
  "first-tactic": "simp only [Ne.def]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _} : Disjoint s t ↔ ∀ x ∈ s, ∀ y ∈ t, x ≠ y",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}"},
 {"type": "Disjoint {a} s ↔ a ∉ s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {a : α}  {s : Set α} : Disjoint {a} s ↔ a ∉ s := by simp [Set.disjoint_iff]; sorry",
  "name": "disjoint_singleton_left",
  "kind": "theorem",
  "first-tactic": "simp [Set.disjoint_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {a : α}  {s : Set α} : Disjoint {a} s ↔ a ∉ s",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {a : α}  {s : Set α}"},
 {"type": "Disjoint s {a} ↔ a ∉ s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {a : α}  {s : Set α} : Disjoint s {a} ↔ a ∉ s := by rw [Disjoint.comm]; sorry",
  "name": "disjoint_singleton_right",
  "kind": "theorem",
  "first-tactic": "rw [Disjoint.comm]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {a : α}  {s : Set α} : Disjoint s {a} ↔ a ∉ s",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {a : α}  {s : Set α}"},
 {"type": "Disjoint ({a} : Set α) {b} ↔ a ≠ b",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {a b : α} : Disjoint ({a} : Set α) {b} ↔ a ≠ b := by rw [disjoint_singleton_left]; sorry",
  "name": "disjoint_singleton",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_singleton_left]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {a b : α} : Disjoint ({a} : Set α) {b} ↔ a ≠ b",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {a b : α}"},
 {"type": "Disjoint s t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (hf : Surjective f)  {s t : Set β}      (h : Disjoint (f ⁻¹' s) (f ⁻¹' t)) : Disjoint s t := by rw [disjoint_iff_inter_eq_empty]; sorry",
  "name": "_root_.Disjoint.of_preimage",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_iff_inter_eq_empty]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (hf : Surjective f)  {s t : Set β}      (h : Disjoint (f ⁻¹' s) (f ⁻¹' t)) : Disjoint s t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   (hf : Surjective f)  {s t : Set β}      (h : Disjoint (f ⁻¹' s) (f ⁻¹' t))"},
 {"type": "f ⁻¹' s = ∅",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : Set β}  (h : Disjoint s (range f)) : f ⁻¹' s = ∅ := by simpa using h.preimage f; sorry",
  "name": "preimage_eq_empty",
  "kind": "theorem",
  "first-tactic": "simpa using h.preimage f",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : Set β}  (h : Disjoint s (range f)) : f ⁻¹' s = ∅",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {f : α → β}  {s : Set β}  (h : Disjoint s (range f))"},
 {"type": "Disjoint (f '' s) (f '' t)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s t u : Set α}  {f : α → β}  (h : Disjoint s t)  (hf : InjOn f u)      (hs : s ⊆ u)  (ht : t ⊆ u) : Disjoint (f '' s) (f '' t) := by rw [disjoint_iff_inter_eq_empty] at h⊢; sorry",
  "name": "_root_.Disjoint.image",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_iff_inter_eq_empty] at h⊢",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s t u : Set α}  {f : α → β}  (h : Disjoint s t)  (hf : InjOn f u)      (hs : s ⊆ u)  (ht : t ⊆ u) : Disjoint (f '' s) (f '' t)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   {s t u : Set α}  {f : α → β}  (h : Disjoint s t)  (hf : InjOn f u)      (hs : s ⊆ u)  (ht : t ⊆ u)"},
 {"type": "Ici (⨆ (i) (j), f i j) = ⋂ (i) (j), Ici (f i j)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (f : ∀ i, κ i → α) : Ici (⨆ (i) (j), f i j) = ⋂ (i) (j), Ici (f i j) := by simp_rw [Ici_supᵢ]; sorry",
  "name": "Ici_supᵢ₂",
  "kind": "theorem",
  "first-tactic": "simp_rw [Ici_supᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (f : ∀ i, κ i → α) : Ici (⨆ (i) (j), f i j) = ⋂ (i) (j), Ici (f i j)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (f : ∀ i, κ i → α)"},
 {"type": "Iic (⨅ (i) (j), f i j) = ⋂ (i) (j), Iic (f i j)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (f : ∀ i, κ i → α) : Iic (⨅ (i) (j), f i j) = ⋂ (i) (j), Iic (f i j) := by simp_rw [Iic_infᵢ]; sorry",
  "name": "Iic_infᵢ₂",
  "kind": "theorem",
  "first-tactic": "simp_rw [Iic_infᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (f : ∀ i, κ i → α) : Iic (⨅ (i) (j), f i j) = ⋂ (i) (j), Iic (f i j)",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (f : ∀ i, κ i → α)"},
 {"type": "Ici (supₛ s) = ⋂ a ∈ s, Ici a",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (s : Set α) : Ici (supₛ s) = ⋂ a ∈ s, Ici a := by rw [supₛ_eq_supᵢ]; sorry",
  "name": "Ici_supₛ",
  "kind": "theorem",
  "first-tactic": "rw [supₛ_eq_supᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (s : Set α) : Ici (supₛ s) = ⋂ a ∈ s, Ici a",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (s : Set α)"},
 {"type": "Iic (infₛ s) = ⋂ a ∈ s, Iic a",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (s : Set α) : Iic (infₛ s) = ⋂ a ∈ s, Iic a := by rw [infₛ_eq_infᵢ]; sorry",
  "name": "Iic_infₛ",
  "kind": "theorem",
  "first-tactic": "rw [infₛ_eq_infᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (s : Set α) : Iic (infₛ s) = ⋂ a ∈ s, Iic a",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (s : Set α)"},
 {"type": "((⋃ x ∈ s₁, t x) \\ ⋃ x ∈ s₂, t x) ⊆ ⋃ x ∈ s₁ \\ s₂, t x",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (t : α → Set β) (s₁ s₂ : Set α) : ((⋃ x ∈ s₁, t x) \\ ⋃ x ∈ s₂, t x) ⊆ ⋃ x ∈ s₁ \\ s₂, t x := by simp only [diff_subset_iff]; sorry",
  "name": "bunionᵢ_diff_bunionᵢ_subset",
  "kind": "theorem",
  "first-tactic": "simp only [diff_subset_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (t : α → Set β) (s₁ s₂ : Set α) : ((⋃ x ∈ s₁, t x) \\ ⋃ x ∈ s₂, t x) ⊆ ⋃ x ∈ s₁ \\ s₂, t x",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (t : α → Set β) (s₁ s₂ : Set α)"},
 {"type": "(⨆ a ∈ ⋃ i, s i, f a) = ⨆ (i) (a ∈ s i), f a",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (t : α → Set β) [CompleteLattice β] (s : ι → Set α)  (f : α → β) : (⨆ a ∈ ⋃ i, s i, f a) = ⨆ (i) (a ∈ s i), f a := by rw [supᵢ_comm]; sorry",
  "name": "supᵢ_unionᵢ",
  "kind": "theorem",
  "first-tactic": "rw [supᵢ_comm]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (t : α → Set β) [CompleteLattice β] (s : ι → Set α)  (f : α → β) : (⨆ a ∈ ⋃ i, s i, f a) = ⨆ (i) (a ∈ s i), f a",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (t : α → Set β) [CompleteLattice β] (s : ι → Set α)  (f : α → β)"},
 {"type": "supₛ (⋃₀s) = ⨆ t ∈ s, supₛ t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (t : α → Set β) [CompleteLattice β] (s : Set (Set β)) : supₛ (⋃₀s) = ⨆ t ∈ s, supₛ t := by simp only [unionₛ_eq_bunionᵢ]; sorry",
  "name": "supₛ_unionₛ",
  "kind": "theorem",
  "first-tactic": "simp only [unionₛ_eq_bunionᵢ]",
  "core-prompt":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (t : α → Set β) [CompleteLattice β] (s : Set (Set β)) : supₛ (⋃₀s) = ⨆ t ∈ s, supₛ t",
  "args":
  "{α β γ : Type _}  {ι ι' ι₂ : Sort _}  {κ κ₁ κ₂ : ι → Sort _}  {κ' : ι' → Sort _}   [CompleteLattice α] (t : α → Set β) [CompleteLattice β] (s : Set (Set β))"},
 {"type": "(∃ x ∈ s ×ˢ t, p x) ↔ ∃ x ∈ s, ∃ y ∈ t, p (x, y)",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} {p : α × β → Prop} : (∃ x ∈ s ×ˢ t, p x) ↔ ∃ x ∈ s, ∃ y ∈ t, p (x, y) := by simp [and_assoc]; sorry",
  "name": "exists_prod_set",
  "kind": "theorem",
  "first-tactic": "simp [and_assoc]",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} {p : α × β → Prop} : (∃ x ∈ s ×ˢ t, p x) ↔ ∃ x ∈ s, ∃ y ∈ t, p (x, y)",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} {p : α × β → Prop}"},
 {"type": "s ×ˢ (∅ : Set β) = ∅",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ (∅ : Set β) = ∅ := by ext; sorry",
  "name": "prod_empty",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ (∅ : Set β) = ∅",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "(∅ : Set α) ×ˢ t = ∅",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : (∅ : Set α) ×ˢ t = ∅ := by ext; sorry",
  "name": "empty_prod",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : (∅ : Set α) ×ˢ t = ∅",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "@univ α ×ˢ @univ β = univ",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : @univ α ×ˢ @univ β = univ := by ext; sorry",
  "name": "univ_prod_univ",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : @univ α ×ˢ @univ β = univ",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "(univ : Set α) ×ˢ t = Prod.snd ⁻¹' t",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} {t : Set β} : (univ : Set α) ×ˢ t = Prod.snd ⁻¹' t := by simp [prod_eq]; sorry",
  "name": "univ_prod",
  "kind": "theorem",
  "first-tactic": "simp [prod_eq]",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} {t : Set β} : (univ : Set α) ×ˢ t = Prod.snd ⁻¹' t",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} {t : Set β}"},
 {"type": "s ×ˢ (univ : Set β) = Prod.fst ⁻¹' s",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} {s : Set α} : s ×ˢ (univ : Set β) = Prod.fst ⁻¹' s := by simp [prod_eq]; sorry",
  "name": "prod_univ",
  "kind": "theorem",
  "first-tactic": "simp [prod_eq]",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} {s : Set α} : s ×ˢ (univ : Set β) = Prod.fst ⁻¹' s",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} {s : Set α}"},
 {"type": "({a} : Set α) ×ˢ t = Prod.mk a '' t",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : ({a} : Set α) ×ˢ t = Prod.mk a '' t := by ext ⟨x, y⟩; sorry",
  "name": "singleton_prod",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : ({a} : Set α) ×ˢ t = Prod.mk a '' t",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "s ×ˢ ({b} : Set β) = (fun a => (a, b)) '' s",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ ({b} : Set β) = (fun a => (a, b)) '' s := by ext ⟨x, y⟩; sorry",
  "name": "prod_singleton",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ ({b} : Set β) = (fun a => (a, b)) '' s",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "({a} : Set α) ×ˢ ({b} : Set β) = {(a, b)}",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : ({a} : Set α) ×ˢ ({b} : Set β) = {(a, b)} := by simp; sorry",
  "name": "singleton_prod_singleton",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : ({a} : Set α) ×ˢ ({b} : Set β) = {(a, b)}",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "(s₁ ∪ s₂) ×ˢ t = s₁ ×ˢ t ∪ s₂ ×ˢ t",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : (s₁ ∪ s₂) ×ˢ t = s₁ ×ˢ t ∪ s₂ ×ˢ t := by ext ⟨x, y⟩; sorry",
  "name": "union_prod",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : (s₁ ∪ s₂) ×ˢ t = s₁ ×ˢ t ∪ s₂ ×ˢ t",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "s ×ˢ (t₁ ∪ t₂) = s ×ˢ t₁ ∪ s ×ˢ t₂",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ (t₁ ∪ t₂) = s ×ˢ t₁ ∪ s ×ˢ t₂ := by ext ⟨x, y⟩; sorry",
  "name": "prod_union",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ (t₁ ∪ t₂) = s ×ˢ t₁ ∪ s ×ˢ t₂",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "(s₁ ∩ s₂) ×ˢ t = s₁ ×ˢ t ∩ s₂ ×ˢ t",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : (s₁ ∩ s₂) ×ˢ t = s₁ ×ˢ t ∩ s₂ ×ˢ t := by ext ⟨x, y⟩; sorry",
  "name": "inter_prod",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : (s₁ ∩ s₂) ×ˢ t = s₁ ×ˢ t ∩ s₂ ×ˢ t",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "s ×ˢ (t₁ ∩ t₂) = s ×ˢ t₁ ∩ s ×ˢ t₂",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ (t₁ ∩ t₂) = s ×ˢ t₁ ∩ s ×ˢ t₂ := by ext ⟨x, y⟩; sorry",
  "name": "prod_inter",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ (t₁ ∩ t₂) = s ×ˢ t₁ ∩ s ×ˢ t₂",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "s₁ ×ˢ t₁ ∩ s₂ ×ˢ t₂ = (s₁ ∩ s₂) ×ˢ (t₁ ∩ t₂)",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s₁ ×ˢ t₁ ∩ s₂ ×ˢ t₂ = (s₁ ∩ s₂) ×ˢ (t₁ ∩ t₂) := by ext ⟨x, y⟩; sorry",
  "name": "prod_inter_prod",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s₁ ×ˢ t₁ ∩ s₂ ×ˢ t₂ = (s₁ ∩ s₂) ×ˢ (t₁ ∩ t₂)",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "Disjoint (s₁ ×ˢ t₁) (s₂ ×ˢ t₂) ↔ Disjoint s₁ s₂ ∨ Disjoint t₁ t₂",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : Disjoint (s₁ ×ˢ t₁) (s₂ ×ˢ t₂) ↔ Disjoint s₁ s₂ ∨ Disjoint t₁ t₂ := by simp_rw [disjoint_left]; sorry",
  "name": "disjoint_prod",
  "kind": "theorem",
  "first-tactic": "simp_rw [disjoint_left]",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : Disjoint (s₁ ×ˢ t₁) (s₂ ×ˢ t₂) ↔ Disjoint s₁ s₂ ∨ Disjoint t₁ t₂",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "insert a s ×ˢ t = Prod.mk a '' t ∪ s ×ˢ t",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : insert a s ×ˢ t = Prod.mk a '' t ∪ s ×ˢ t := by ext ⟨x, y⟩; sorry",
  "name": "insert_prod",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : insert a s ×ˢ t = Prod.mk a '' t ∪ s ×ˢ t",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "s ×ˢ insert b t = (fun a => (a, b)) '' s ∪ s ×ˢ t",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ insert b t = (fun a => (a, b)) '' s ∪ s ×ˢ t := by ext ⟨x, y⟩; sorry",
  "name": "prod_insert",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ insert b t = (fun a => (a, b)) '' s ∪ s ×ˢ t",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "(fun a => (a, b)) ⁻¹' s ×ˢ t = s",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (hb : b ∈ t) : (fun a => (a, b)) ⁻¹' s ×ˢ t = s := by ext a; sorry",
  "name": "mk_preimage_prod_left",
  "kind": "theorem",
  "first-tactic": "ext a",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (hb : b ∈ t) : (fun a => (a, b)) ⁻¹' s ×ˢ t = s",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (hb : b ∈ t)"},
 {"type": "Prod.mk a ⁻¹' s ×ˢ t = t",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (ha : a ∈ s) : Prod.mk a ⁻¹' s ×ˢ t = t := by ext b; sorry",
  "name": "mk_preimage_prod_right",
  "kind": "theorem",
  "first-tactic": "ext b",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (ha : a ∈ s) : Prod.mk a ⁻¹' s ×ˢ t = t",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (ha : a ∈ s)"},
 {"type": "(fun a => (a, b)) ⁻¹' s ×ˢ t = ∅",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (hb : b ∉ t) : (fun a => (a, b)) ⁻¹' s ×ˢ t = ∅ := by ext a; sorry",
  "name": "mk_preimage_prod_left_eq_empty",
  "kind": "theorem",
  "first-tactic": "ext a",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (hb : b ∉ t) : (fun a => (a, b)) ⁻¹' s ×ˢ t = ∅",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (hb : b ∉ t)"},
 {"type": "Prod.mk a ⁻¹' s ×ˢ t = ∅",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (ha : a ∉ s) : Prod.mk a ⁻¹' s ×ˢ t = ∅ := by ext b; sorry",
  "name": "mk_preimage_prod_right_eq_empty",
  "kind": "theorem",
  "first-tactic": "ext b",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (ha : a ∉ s) : Prod.mk a ⁻¹' s ×ˢ t = ∅",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (ha : a ∉ s)"},
 {"type": "(fun a => (a, b)) ⁻¹' s ×ˢ t = if b ∈ t then s else ∅",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} [DecidablePred (· ∈ t)] : (fun a => (a, b)) ⁻¹' s ×ˢ t = if b ∈ t then s else ∅ := by split_ifs with h; sorry",
  "name": "mk_preimage_prod_left_eq_if",
  "kind": "theorem",
  "first-tactic": "split_ifs with h",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} [DecidablePred (· ∈ t)] : (fun a => (a, b)) ⁻¹' s ×ˢ t = if b ∈ t then s else ∅",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} [DecidablePred (· ∈ t)]"},
 {"type": "Prod.mk a ⁻¹' s ×ˢ t = if a ∈ s then t else ∅",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} [DecidablePred (· ∈ s)] : Prod.mk a ⁻¹' s ×ˢ t = if a ∈ s then t else ∅ := by split_ifs with h; sorry",
  "name": "mk_preimage_prod_right_eq_if",
  "kind": "theorem",
  "first-tactic": "split_ifs with h",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} [DecidablePred (· ∈ s)] : Prod.mk a ⁻¹' s ×ˢ t = if a ∈ s then t else ∅",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} [DecidablePred (· ∈ s)]"},
 {"type": "(fun a => (f a, b)) ⁻¹' s ×ˢ t = if b ∈ t then f ⁻¹' s else ∅",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} [DecidablePred (· ∈ t)]  (f : γ → α) : (fun a => (f a, b)) ⁻¹' s ×ˢ t = if b ∈ t then f ⁻¹' s else ∅ := by rw [← mk_preimage_prod_left_eq_if]; sorry",
  "name": "mk_preimage_prod_left_fn_eq_if",
  "kind": "theorem",
  "first-tactic": "rw [← mk_preimage_prod_left_eq_if]",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} [DecidablePred (· ∈ t)]  (f : γ → α) : (fun a => (f a, b)) ⁻¹' s ×ˢ t = if b ∈ t then f ⁻¹' s else ∅",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} [DecidablePred (· ∈ t)]  (f : γ → α)"},
 {"type": "(fun b => (a, g b)) ⁻¹' s ×ˢ t = if a ∈ s then g ⁻¹' t else ∅",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} [DecidablePred (· ∈ s)]  (g : δ → β) : (fun b => (a, g b)) ⁻¹' s ×ˢ t = if a ∈ s then g ⁻¹' t else ∅ := by rw [← mk_preimage_prod_right_eq_if]; sorry",
  "name": "mk_preimage_prod_right_fn_eq_if",
  "kind": "theorem",
  "first-tactic": "rw [← mk_preimage_prod_right_eq_if]",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} [DecidablePred (· ∈ s)]  (g : δ → β) : (fun b => (a, g b)) ⁻¹' s ×ˢ t = if a ∈ s then g ⁻¹' t else ∅",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} [DecidablePred (· ∈ s)]  (g : δ → β)"},
 {"type": "Prod.swap ⁻¹' s ×ˢ t = t ×ˢ s",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (s : Set α)  (t : Set β) : Prod.swap ⁻¹' s ×ˢ t = t ×ˢ s := by ext ⟨x, y⟩; sorry",
  "name": "preimage_swap_prod",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (s : Set α)  (t : Set β) : Prod.swap ⁻¹' s ×ˢ t = t ×ˢ s",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (s : Set α)  (t : Set β)"},
 {"type": "Prod.swap '' s ×ˢ t = t ×ˢ s",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (s : Set α)  (t : Set β) : Prod.swap '' s ×ˢ t = t ×ˢ s := by rw [image_swap_eq_preimage_swap]; sorry",
  "name": "image_swap_prod",
  "kind": "theorem",
  "first-tactic": "rw [image_swap_eq_preimage_swap]",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (s : Set α)  (t : Set β) : Prod.swap '' s ×ˢ t = t ×ˢ s",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (s : Set α)  (t : Set β)"},
 {"type": "(range fun x => (f x, g x)) ⊆ range f ×ˢ range g",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (f : α → β)  (g : α → γ) : (range fun x => (f x, g x)) ⊆ range f ×ˢ range g := by have : (fun x => (f x, g x)) = Prod.map f g ∘ fun x => (x, x) := funext fun x => rfl; sorry",
  "name": "range_pair_subset",
  "kind": "theorem",
  "first-tactic":
  "have : (fun x => (f x, g x)) = Prod.map f g ∘ fun x => (x, x) := funext fun x => rfl",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (f : α → β)  (g : α → γ) : (range fun x => (f x, g x)) ⊆ range f ×ˢ range g",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (f : α → β)  (g : α → γ)"},
 {"type": "s ×ˢ t = ∅ ↔ s = ∅ ∨ t = ∅",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ t = ∅ ↔ s = ∅ ∨ t = ∅ := by simp only [not_nonempty_iff_eq_empty.symm]; sorry",
  "name": "prod_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "simp only [not_nonempty_iff_eq_empty.symm]",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ t = ∅ ↔ s = ∅ ∨ t = ∅",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "s ×ˢ t ⊆ f ⁻¹' W ↔ ∀ a b, a ∈ s → b ∈ t → f (a, b) ∈ W",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} {W : Set γ}  {f : α × β → γ} : s ×ˢ t ⊆ f ⁻¹' W ↔ ∀ a b, a ∈ s → b ∈ t → f (a, b) ∈ W := by simp [subset_def]; sorry",
  "name": "prod_sub_preimage_iff",
  "kind": "theorem",
  "first-tactic": "simp [subset_def]",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} {W : Set γ}  {f : α × β → γ} : s ×ˢ t ⊆ f ⁻¹' W ↔ ∀ a b, a ∈ s → b ∈ t → f (a, b) ∈ W",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} {W : Set γ}  {f : α × β → γ}"},
 {"type": "(fun x => (f x, g x)) '' s ⊆ (f '' s) ×ˢ (g '' s)",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} {f : α → β}  {g : α → γ}  {s : Set α} : (fun x => (f x, g x)) '' s ⊆ (f '' s) ×ˢ (g '' s) := by rintro _ ⟨x, hx, rfl⟩; sorry",
  "name": "image_prod_mk_subset_prod",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨x, hx, rfl⟩",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} {f : α → β}  {g : α → γ}  {s : Set α} : (fun x => (f x, g x)) '' s ⊆ (f '' s) ×ˢ (g '' s)",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} {f : α → β}  {g : α → γ}  {s : Set α}"},
 {"type": "(fun a => (a, b)) '' s ⊆ s ×ˢ t",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (hb : b ∈ t) : (fun a => (a, b)) '' s ⊆ s ×ˢ t := by rintro _ ⟨a, ha, rfl⟩; sorry",
  "name": "image_prod_mk_subset_prod_left",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨a, ha, rfl⟩",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (hb : b ∈ t) : (fun a => (a, b)) '' s ⊆ s ×ˢ t",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (hb : b ∈ t)"},
 {"type": "Prod.mk a '' t ⊆ s ×ˢ t",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (ha : a ∈ s) : Prod.mk a '' t ⊆ s ×ˢ t := by rintro _ ⟨b, hb, rfl⟩; sorry",
  "name": "image_prod_mk_subset_prod_right",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨b, hb, rfl⟩",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (ha : a ∈ s) : Prod.mk a '' t ⊆ s ×ˢ t",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (ha : a ∈ s)"},
 {"type": "s ×ˢ t \\ s₁ ×ˢ t₁ = s ×ˢ (t \\ t₁) ∪ (s \\ s₁) ×ˢ t",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ t \\ s₁ ×ˢ t₁ = s ×ˢ (t \\ t₁) ∪ (s \\ s₁) ×ˢ t := by ext x; sorry",
  "name": "prod_diff_prod",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ t \\ s₁ ×ˢ t₁ = s ×ˢ (t \\ t₁) ∪ (s \\ s₁) ×ˢ t",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "s ×ˢ t ⊆ s₁ ×ˢ t₁ ↔ s ⊆ s₁ ∧ t ⊆ t₁ ∨ s = ∅ ∨ t = ∅",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ t ⊆ s₁ ×ˢ t₁ ↔ s ⊆ s₁ ∧ t ⊆ t₁ ∨ s = ∅ ∨ t = ∅ := by cases' (s ×ˢ t).eq_empty_or_nonempty with h h; sorry",
  "name": "prod_subset_prod_iff",
  "kind": "theorem",
  "first-tactic": "cases' (s ×ˢ t).eq_empty_or_nonempty with h h",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ t ⊆ s₁ ×ˢ t₁ ↔ s ⊆ s₁ ∧ t ⊆ t₁ ∨ s = ∅ ∨ t = ∅",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "s ×ˢ t = s₁ ×ˢ t₁ ↔ s = s₁ ∧ t = t₁",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (h : (s ×ˢ t).Nonempty) : s ×ˢ t = s₁ ×ˢ t₁ ↔ s = s₁ ∧ t = t₁ := by constructor; sorry",
  "name": "prod_eq_prod_iff_of_nonempty",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (h : (s ×ˢ t).Nonempty) : s ×ˢ t = s₁ ×ˢ t₁ ↔ s = s₁ ∧ t = t₁",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (h : (s ×ˢ t).Nonempty)"},
 {"type":
  "s ×ˢ t = s₁ ×ˢ t₁ ↔ s = s₁ ∧ t = t₁ ∨ (s = ∅ ∨ t = ∅) ∧ (s₁ = ∅ ∨ t₁ = ∅)",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ t = s₁ ×ˢ t₁ ↔ s = s₁ ∧ t = t₁ ∨ (s = ∅ ∨ t = ∅) ∧ (s₁ = ∅ ∨ t₁ = ∅) := by symm; sorry",
  "name": "prod_eq_prod_iff",
  "kind": "theorem",
  "first-tactic": "symm",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} : s ×ˢ t = s₁ ×ˢ t₁ ↔ s = s₁ ∧ t = t₁ ∨ (s = ∅ ∨ t = ∅) ∧ (s₁ = ∅ ∨ t₁ = ∅)",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β}"},
 {"type": "s ×ˢ t = s₁ ×ˢ t ↔ s = s₁",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (ht : t.Nonempty) : s ×ˢ t = s₁ ×ˢ t ↔ s = s₁ := by simp_rw [prod_eq_prod_iff]; sorry",
  "name": "prod_eq_iff_eq",
  "kind": "theorem",
  "first-tactic": "simp_rw [prod_eq_prod_iff]",
  "core-prompt":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (ht : t.Nonempty) : s ×ˢ t = s₁ ×ˢ t ↔ s = s₁",
  "args":
  "{α β γ δ : Type _}  {s s₁ s₂ : Set α}  {t t₁ t₂ : Set β}  {a : α}  {b : β} (ht : t.Nonempty)"},
 {"type": "(x, x) ∈ diagonal α",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} (x : α) : (x, x) ∈ diagonal α := by simp [diagonal]; sorry",
  "name": "mem_diagonal",
  "kind": "theorem",
  "first-tactic": "simp [diagonal]",
  "core-prompt": "{α : Type _}  {s t : Set α} (x : α) : (x, x) ∈ diagonal α",
  "args": "{α : Type _}  {s t : Set α} (x : α)"},
 {"type":
  "Prod.map (fun x : s => (x : α)) (fun x : s => (x : α)) ⁻¹' diagonal α = diagonal s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} (s : Set α) : Prod.map (fun x : s => (x : α)) (fun x : s => (x : α)) ⁻¹' diagonal α = diagonal s := by ext ⟨⟨x, hx⟩, ⟨y, hy⟩⟩; sorry",
  "name": "preimage_coe_coe_diagonal",
  "kind": "theorem",
  "first-tactic": "ext ⟨⟨x, hx⟩, ⟨y, hy⟩⟩",
  "core-prompt":
  "{α : Type _}  {s t : Set α} (s : Set α) : Prod.map (fun x : s => (x : α)) (fun x : s => (x : α)) ⁻¹' diagonal α = diagonal s",
  "args": "{α : Type _}  {s t : Set α} (s : Set α)"},
 {"type": "(range fun x => (x, x)) = diagonal α",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α} : (range fun x => (x, x)) = diagonal α := by ext ⟨x, y⟩; sorry",
  "name": "range_diag",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "{α : Type _}  {s t : Set α} : (range fun x => (x, x)) = diagonal α",
  "args": "{α : Type _}  {s t : Set α}"},
 {"type": "s.offDiag.Nonempty ↔ s.Nontrivial",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α}  {x : α × α}  {a : α} : s.offDiag.Nonempty ↔ s.Nontrivial := by simp [offDiag]; sorry",
  "name": "offDiag_nonempty",
  "kind": "theorem",
  "first-tactic": "simp [offDiag]",
  "core-prompt":
  "{α : Type _}  {s t : Set α}  {x : α × α}  {a : α} : s.offDiag.Nonempty ↔ s.Nontrivial",
  "args": "{α : Type _}  {s t : Set α}  {x : α × α}  {a : α}"},
 {"type": "s.offDiag = ∅ ↔ s.Subsingleton",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α}  {x : α × α}  {a : α} : s.offDiag = ∅ ↔ s.Subsingleton := by rw [← not_nonempty_iff_eq_empty]; sorry",
  "name": "offDiag_eq_empty",
  "kind": "theorem",
  "first-tactic": "rw [← not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{α : Type _}  {s t : Set α}  {x : α × α}  {a : α} : s.offDiag = ∅ ↔ s.Subsingleton",
  "args": "{α : Type _}  {s t : Set α}  {x : α × α}  {a : α}"},
 {"type": "(∅ : Set α).offDiag = ∅",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α}  {x : α × α}  {a : α} : (∅ : Set α).offDiag = ∅ := by simp; sorry",
  "name": "offDiag_empty",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {s t : Set α}  {x : α × α}  {a : α} : (∅ : Set α).offDiag = ∅",
  "args": "{α : Type _}  {s t : Set α}  {x : α × α}  {a : α}"},
 {"type": "({a} : Set α).offDiag = ∅",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α}  {x : α × α}  {a : α} (a : α) : ({a} : Set α).offDiag = ∅ := by simp; sorry",
  "name": "offDiag_singleton",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {s t : Set α}  {x : α × α}  {a : α} (a : α) : ({a} : Set α).offDiag = ∅",
  "args": "{α : Type _}  {s t : Set α}  {x : α × α}  {a : α} (a : α)"},
 {"type": "(s ∪ t).offDiag = s.offDiag ∪ t.offDiag ∪ s ×ˢ t ∪ t ×ˢ s",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α}  {x : α × α}  {a : α} (h : Disjoint s t) : (s ∪ t).offDiag = s.offDiag ∪ t.offDiag ∪ s ×ˢ t ∪ t ×ˢ s := by ext x; sorry",
  "name": "offDiag_union",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α : Type _}  {s t : Set α}  {x : α × α}  {a : α} (h : Disjoint s t) : (s ∪ t).offDiag = s.offDiag ∪ t.offDiag ∪ s ×ˢ t ∪ t ×ˢ s",
  "args":
  "{α : Type _}  {s t : Set α}  {x : α × α}  {a : α} (h : Disjoint s t)"},
 {"type": "(insert a s).offDiag = s.offDiag ∪ {a} ×ˢ s ∪ s ×ˢ {a}",
  "tactic-prompt":
  "theorem {α : Type _}  {s t : Set α}  {x : α × α}  {a : α} (ha : a ∉ s) : (insert a s).offDiag = s.offDiag ∪ {a} ×ˢ s ∪ s ×ˢ {a} := by rw [insert_eq]; sorry",
  "name": "offDiag_insert",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{α : Type _}  {s t : Set α}  {x : α × α}  {a : α} (ha : a ∉ s) : (insert a s).offDiag = s.offDiag ∪ {a} ×ˢ s ∪ s ×ˢ {a}",
  "args": "{α : Type _}  {s t : Set α}  {x : α × α}  {a : α} (ha : a ∉ s)"},
 {"type": "f ∈ pi univ t ↔ ∀ i, f i ∈ t i",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} {f : ∀ i, α i} : f ∈ pi univ t ↔ ∀ i, f i ∈ t i := by simp; sorry",
  "name": "mem_univ_pi",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} {f : ∀ i, α i} : f ∈ pi univ t ↔ ∀ i, f i ∈ t i",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} {f : ∀ i, α i}"},
 {"type": "pi ∅ s = univ",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (s : ∀ i, Set (α i)) : pi ∅ s = univ := by ext; sorry",
  "name": "empty_pi",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (s : ∀ i, Set (α i)) : pi ∅ s = univ",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (s : ∀ i, Set (α i))"},
 {"type": "s.pi t = ∅",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (hs : i ∈ s)  (ht : t i = ∅) : s.pi t = ∅ := by ext f; sorry",
  "name": "pi_eq_empty",
  "kind": "theorem",
  "first-tactic": "ext f",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (hs : i ∈ s)  (ht : t i = ∅) : s.pi t = ∅",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (hs : i ∈ s)  (ht : t i = ∅)"},
 {"type": "(s.pi t).Nonempty ↔ ∀ i, ∃ x, i ∈ s → x ∈ t i",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} : (s.pi t).Nonempty ↔ ∀ i, ∃ x, i ∈ s → x ∈ t i := by simp [Classical.skolem]; sorry",
  "name": "pi_nonempty_iff",
  "kind": "theorem",
  "first-tactic": "simp [Classical.skolem]",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} : (s.pi t).Nonempty ↔ ∀ i, ∃ x, i ∈ s → x ∈ t i",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι}"},
 {"type": "(pi univ t).Nonempty ↔ ∀ i, (t i).Nonempty",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} : (pi univ t).Nonempty ↔ ∀ i, (t i).Nonempty := by simp [Classical.skolem]; sorry",
  "name": "univ_pi_nonempty_iff",
  "kind": "theorem",
  "first-tactic": "simp [Classical.skolem]",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} : (pi univ t).Nonempty ↔ ∀ i, (t i).Nonempty",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι}"},
 {"type": "s.pi t = ∅ ↔ ∃ i, IsEmpty (α i) ∨ i ∈ s ∧ t i = ∅",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} : s.pi t = ∅ ↔ ∃ i, IsEmpty (α i) ∨ i ∈ s ∧ t i = ∅ := by rw [← not_nonempty_iff_eq_empty]; sorry",
  "name": "pi_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "rw [← not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} : s.pi t = ∅ ↔ ∃ i, IsEmpty (α i) ∨ i ∈ s ∧ t i = ∅",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι}"},
 {"type": "pi univ t = ∅ ↔ ∃ i, t i = ∅",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} : pi univ t = ∅ ↔ ∃ i, t i = ∅ := by simp [← not_nonempty_iff_eq_empty]; sorry",
  "name": "univ_pi_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "simp [← not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} : pi univ t = ∅ ↔ ∃ i, t i = ∅",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι}"},
 {"type": "Disjoint (pi univ t₁) (pi univ t₂) ↔ ∃ i, Disjoint (t₁ i) (t₂ i)",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} : Disjoint (pi univ t₁) (pi univ t₂) ↔ ∃ i, Disjoint (t₁ i) (t₂ i) := by simp only [disjoint_iff_inter_eq_empty]; sorry",
  "name": "disjoint_univ_pi",
  "kind": "theorem",
  "first-tactic": "simp only [disjoint_iff_inter_eq_empty]",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} : Disjoint (pi univ t₁) (pi univ t₂) ↔ ∃ i, Disjoint (t₁ i) (t₂ i)",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι}"},
 {"type":
  "(range fun g : ∀ i, α i => fun i => f i (g i)) = pi univ fun i => range (f i)",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (f : ∀ i, α i → β i) : (range fun g : ∀ i, α i => fun i => f i (g i)) = pi univ fun i => range (f i) := by refine Subset.antisymm ?_ fun x hx => ?_; sorry",
  "name": "range_dcomp",
  "kind": "theorem",
  "first-tactic": "refine Subset.antisymm ?_ fun x hx => ?_",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (f : ∀ i, α i → β i) : (range fun g : ∀ i, α i => fun i => f i (g i)) = pi univ fun i => range (f i)",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (f : ∀ i, α i → β i)"},
 {"type": "pi (insert i s) t = eval i ⁻¹' t i ∩ pi s t",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (i : ι)  (s : Set ι)  (t : ∀ i, Set (α i)) : pi (insert i s) t = eval i ⁻¹' t i ∩ pi s t := by ext; sorry",
  "name": "insert_pi",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (i : ι)  (s : Set ι)  (t : ∀ i, Set (α i)) : pi (insert i s) t = eval i ⁻¹' t i ∩ pi s t",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (i : ι)  (s : Set ι)  (t : ∀ i, Set (α i))"},
 {"type": "pi {i} t = eval i ⁻¹' t i",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (i : ι)  (t : ∀ i, Set (α i)) : pi {i} t = eval i ⁻¹' t i := by ext; sorry",
  "name": "singleton_pi",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (i : ι)  (t : ∀ i, Set (α i)) : pi {i} t = eval i ⁻¹' t i",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (i : ι)  (t : ∀ i, Set (α i))"},
 {"type":
  "(pi s fun i => if p i then t₁ i else t₂ i) =\n      pi ({ i ∈ s | p i }) t₁ ∩ pi ({ i ∈ s | ¬p i }) t₂",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} {p : ι → Prop}  [h : DecidablePred p]  (s : Set ι)  (t₁ t₂ : ∀ i, Set (α i)) : (pi s fun i => if p i then t₁ i else t₂ i) =\n      pi ({ i ∈ s | p i }) t₁ ∩ pi ({ i ∈ s | ¬p i }) t₂ := by ext f; sorry",
  "name": "pi_if",
  "kind": "theorem",
  "first-tactic": "ext f",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} {p : ι → Prop}  [h : DecidablePred p]  (s : Set ι)  (t₁ t₂ : ∀ i, Set (α i)) : (pi s fun i => if p i then t₁ i else t₂ i) =\n      pi ({ i ∈ s | p i }) t₁ ∩ pi ({ i ∈ s | ¬p i }) t₂",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} {p : ι → Prop}  [h : DecidablePred p]  (s : Set ι)  (t₁ t₂ : ∀ i, Set (α i))"},
 {"type": "(s₁ ∪ s₂).pi t = s₁.pi t ∩ s₂.pi t",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} : (s₁ ∪ s₂).pi t = s₁.pi t ∩ s₂.pi t := by simp [pi]; sorry",
  "name": "union_pi",
  "kind": "theorem",
  "first-tactic": "simp [pi]",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} : (s₁ ∪ s₂).pi t = s₁.pi t ∩ s₂.pi t",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι}"},
 {"type": "pi s t ∩ pi (sᶜ) t = pi univ t",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (s : Set ι) : pi s t ∩ pi (sᶜ) t = pi univ t := by rw [← union_pi]; sorry",
  "name": "pi_inter_compl",
  "kind": "theorem",
  "first-tactic": "rw [← union_pi]",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (s : Set ι) : pi s t ∩ pi (sᶜ) t = pi univ t",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (s : Set ι)"},
 {"type":
  "(pi univ fun j => t j (update f i a j)) = { x | x i ∈ t i a } ∩ pi ({i}ᶜ) fun j => t j (f j)",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} [DecidableEq ι]  {β : ∀ _, Type _}  (i : ι)  (f : ∀ j, α j)  (a : α i)      (t : ∀ j, α j → Set (β j)) : (pi univ fun j => t j (update f i a j)) = { x | x i ∈ t i a } ∩ pi ({i}ᶜ) fun j => t j (f j) := by rw [compl_eq_univ_diff]; sorry",
  "name": "univ_pi_update",
  "kind": "theorem",
  "first-tactic": "rw [compl_eq_univ_diff]",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} [DecidableEq ι]  {β : ∀ _, Type _}  (i : ι)  (f : ∀ j, α j)  (a : α i)      (t : ∀ j, α j → Set (β j)) : (pi univ fun j => t j (update f i a j)) = { x | x i ∈ t i a } ∩ pi ({i}ᶜ) fun j => t j (f j)",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} [DecidableEq ι]  {β : ∀ _, Type _}  (i : ι)  (f : ∀ j, α j)  (a : α i)      (t : ∀ j, α j → Set (β j))"},
 {"type":
  "pi univ (update (fun j : ι => (univ : Set (α j))) i s) = eval i ⁻¹' s",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} [DecidableEq ι]  (i : ι)  (s : Set (α i)) : pi univ (update (fun j : ι => (univ : Set (α j))) i s) = eval i ⁻¹' s := by rw [univ_pi_update i (fun j => (univ : Set (α j))) s fun j t => t]; sorry",
  "name": "univ_pi_update_univ",
  "kind": "theorem",
  "first-tactic":
  "rw [univ_pi_update i (fun j => (univ : Set (α j))) s fun j t => t]",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} [DecidableEq ι]  (i : ι)  (s : Set (α i)) : pi univ (update (fun j : ι => (univ : Set (α j))) i s) = eval i ⁻¹' s",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} [DecidableEq ι]  (i : ι)  (s : Set (α i))"},
 {"type": "t i ⊆ eval i '' s.pi t",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (ht : (s.pi t).Nonempty)  (i : ι) : t i ⊆ eval i '' s.pi t := by classical\n  obtain ⟨f, hf⟩ := ht\n  refine' fun y hy => ⟨update f i y, fun j hj => _, update_same _ _ _⟩\n  obtain rfl | hji := eq_or_ne j i; sorry",
  "name": "subset_eval_image_pi",
  "kind": "theorem",
  "first-tactic":
  "classical\n  obtain ⟨f, hf⟩ := ht\n  refine' fun y hy => ⟨update f i y, fun j hj => _, update_same _ _ _⟩\n  obtain rfl | hji := eq_or_ne j i",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (ht : (s.pi t).Nonempty)  (i : ι) : t i ⊆ eval i '' s.pi t",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (ht : (s.pi t).Nonempty)  (i : ι)"},
 {"type": "pi s t₁ ⊆ pi s t₂ ↔ (∀ i ∈ s, t₁ i ⊆ t₂ i) ∨ pi s t₁ = ∅",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} : pi s t₁ ⊆ pi s t₂ ↔ (∀ i ∈ s, t₁ i ⊆ t₂ i) ∨ pi s t₁ = ∅ := by refine'\n    ⟨fun h => or_iff_not_imp_right.2 _, fun h => h.elim pi_mono fun h' => h'.symm ▸ empty_subset _⟩; sorry",
  "name": "pi_subset_pi_iff",
  "kind": "theorem",
  "first-tactic":
  "refine'\n    ⟨fun h => or_iff_not_imp_right.2 _, fun h => h.elim pi_mono fun h' => h'.symm ▸ empty_subset _⟩",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} : pi s t₁ ⊆ pi s t₂ ↔ (∀ i ∈ s, t₁ i ⊆ t₂ i) ∨ pi s t₁ = ∅",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι}"},
 {"type": "pi univ t₁ ⊆ pi univ t₂ ↔ (∀ i, t₁ i ⊆ t₂ i) ∨ ∃ i, t₁ i = ∅",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} : pi univ t₁ ⊆ pi univ t₂ ↔ (∀ i, t₁ i ⊆ t₂ i) ∨ ∃ i, t₁ i = ∅ := by simp [pi_subset_pi_iff]; sorry",
  "name": "univ_pi_subset_univ_pi_iff",
  "kind": "theorem",
  "first-tactic": "simp [pi_subset_pi_iff]",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} : pi univ t₁ ⊆ pi univ t₂ ↔ (∀ i, t₁ i ⊆ t₂ i) ∨ ∃ i, t₁ i = ∅",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι}"},
 {"type": "eval i ⁻¹' s = pi univ (update (fun i => univ) i s)",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} [DecidableEq ι]  {s : Set (α i)} : eval i ⁻¹' s = pi univ (update (fun i => univ) i s) := by ext x; sorry",
  "name": "eval_preimage",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} [DecidableEq ι]  {s : Set (α i)} : eval i ⁻¹' s = pi univ (update (fun i => univ) i s)",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} [DecidableEq ι]  {s : Set (α i)}"},
 {"type": "eval i ⁻¹' s = pi {i} (update (fun i => univ) i s)",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} [DecidableEq ι]  {s : Set (α i)} : eval i ⁻¹' s = pi {i} (update (fun i => univ) i s) := by ext; sorry",
  "name": "eval_preimage'",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} [DecidableEq ι]  {s : Set (α i)} : eval i ⁻¹' s = pi {i} (update (fun i => univ) i s)",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} [DecidableEq ι]  {s : Set (α i)}"},
 {"type": "update f i ⁻¹' s.pi t = t i",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} [DecidableEq ι]  {f : ∀ i, α i}  (hi : i ∈ s)      (hf : ∀ j ∈ s, j ≠ i → f j ∈ t j) : update f i ⁻¹' s.pi t = t i := by ext x; sorry",
  "name": "update_preimage_pi",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} [DecidableEq ι]  {f : ∀ i, α i}  (hi : i ∈ s)      (hf : ∀ j ∈ s, j ≠ i → f j ∈ t j) : update f i ⁻¹' s.pi t = t i",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} [DecidableEq ι]  {f : ∀ i, α i}  (hi : i ∈ s)      (hf : ∀ j ∈ s, j ≠ i → f j ∈ t j)"},
 {"type": "(pi univ fun i => if i ∈ s then t i else univ) = s.pi t",
  "tactic-prompt":
  "theorem {ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (s : Set ι)  [DecidablePred (· ∈ s)]  (t : ∀ i, Set (α i)) : (pi univ fun i => if i ∈ s then t i else univ) = s.pi t := by ext; sorry",
  "name": "univ_pi_ite",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (s : Set ι)  [DecidablePred (· ∈ s)]  (t : ∀ i, Set (α i)) : (pi univ fun i => if i ∈ s then t i else univ) = s.pi t",
  "args":
  "{ι : Type _}  {α β : ι → Type _}  {s s₁ s₂ : Set ι}  {t t₁ t₂ : ∀ i, Set (α i)}  {i : ι} (s : Set ι)  [DecidablePred (· ∈ s)]  (t : ∀ i, Set (α i))"},
 {"type": "op a ∈ s.op ↔ a ∈ s",
  "tactic-prompt":
  "theorem {α : Type _} {s : Set α}  {a : α} : op a ∈ s.op ↔ a ∈ s := by rfl; sorry",
  "name": "op_mem_op",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt": "{α : Type _} {s : Set α}  {a : α} : op a ∈ s.op ↔ a ∈ s",
  "args": "{α : Type _} {s : Set α}  {a : α}"},
 {"type": "unop a ∈ s.unop ↔ a ∈ s",
  "tactic-prompt":
  "theorem {α : Type _} {s : Set αᵒᵖ}  {a : αᵒᵖ} : unop a ∈ s.unop ↔ a ∈ s := by rfl; sorry",
  "name": "unop_mem_unop",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "{α : Type _} {s : Set αᵒᵖ}  {a : αᵒᵖ} : unop a ∈ s.unop ↔ a ∈ s",
  "args": "{α : Type _} {s : Set αᵒᵖ}  {a : αᵒᵖ}"},
 {"type": "f ⁻¹' s = g ⁻¹' s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {g : β → γ} {f g : α → β}  {s : Set β}  (h : ∀ x : α, f x = g x) : f ⁻¹' s = g ⁻¹' s := by congr with x; sorry",
  "name": "preimage_congr",
  "kind": "theorem",
  "first-tactic": "congr with x",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {g : β → γ} {f g : α → β}  {s : Set β}  (h : ∀ x : α, f x = g x) : f ⁻¹' s = g ⁻¹' s",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {g : β → γ} {f g : α → β}  {s : Set β}  (h : ∀ x : α, f x = g x)"},
 {"type": "(fun _ : α => b) ⁻¹' s = if b ∈ s then univ else ∅",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {g : β → γ} (b : β)  (s : Set β)  [Decidable (b ∈ s)] : (fun _ : α => b) ⁻¹' s = if b ∈ s then univ else ∅ := by split_ifs with hb; sorry",
  "name": "preimage_const",
  "kind": "theorem",
  "first-tactic": "split_ifs with hb",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {g : β → γ} (b : β)  (s : Set β)  [Decidable (b ∈ s)] : (fun _ : α => b) ⁻¹' s = if b ∈ s then univ else ∅",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {g : β → γ} (b : β)  (s : Set β)  [Decidable (b ∈ s)]"},
 {"type": "Set.preimage (f^[n]) = Set.preimage f^[n]",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {g : β → γ} {f : α → α}  {n : ℕ} : Set.preimage (f^[n]) = Set.preimage f^[n] := by induction' n with n ih; sorry",
  "name": "preimage_iterate_eq",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {g : β → γ} {f : α → α}  {n : ℕ} : Set.preimage (f^[n]) = Set.preimage f^[n]",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {g : β → γ} {f : α → α}  {n : ℕ}"},
 {"type": "(fun x : s => (x : α)) ⁻¹' u = ((fun x : s => (x : α)) ⁻¹' v)ᶜ",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {g : β → γ} {α : Type _}  {s u v : Set α}  (hsuv : s ⊆ u ∪ v)      (H : s ∩ (u ∩ v) = ∅) : (fun x : s => (x : α)) ⁻¹' u = ((fun x : s => (x : α)) ⁻¹' v)ᶜ := by ext ⟨x, x_in_s⟩; sorry",
  "name": "preimage_subtype_coe_eq_compl",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, x_in_s⟩",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {g : β → γ} {α : Type _}  {s u v : Set α}  (hsuv : s ⊆ u ∪ v)      (H : s ∩ (u ∩ v) = ∅) : (fun x : s => (x : α)) ⁻¹' u = ((fun x : s => (x : α)) ⁻¹' v)ᶜ",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {g : β → γ} {α : Type _}  {s u v : Set α}  (hsuv : s ⊆ u ∪ v)      (H : s ∩ (u ∩ v) = ∅)"},
 {"type": "(∀ y ∈ f '' s, p y) ↔ ∀ x ∈ s, p (f x)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {s : Set α}  {p : β → Prop} : (∀ y ∈ f '' s, p y) ↔ ∀ x ∈ s, p (f x) := by simp; sorry",
  "name": "ball_image_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {s : Set α}  {p : β → Prop} : (∀ y ∈ f '' s, p y) ↔ ∀ x ∈ s, p (f x)",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {s : Set α}  {p : β → Prop}"},
 {"type": "(∃ y ∈ f '' s, p y) ↔ ∃ x ∈ s, p (f x)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {s : Set α}  {p : β → Prop} : (∃ y ∈ f '' s, p y) ↔ ∃ x ∈ s, p (f x) := by simp; sorry",
  "name": "bex_image_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {s : Set α}  {p : β → Prop} : (∃ y ∈ f '' s, p y) ↔ ∃ x ∈ s, p (f x)",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {s : Set α}  {p : β → Prop}"},
 {"type": "f '' s = g '' s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f g : α → β}  {s : Set α}  (h : ∀ a ∈ s, f a = g a) : f '' s = g '' s := by ext x; sorry",
  "name": "image_congr",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f g : α → β}  {s : Set α}  (h : ∀ a ∈ s, f a = g a) : f '' s = g '' s",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f g : α → β}  {s : Set α}  (h : ∀ a ∈ s, f a = g a)"},
 {"type": "f '' a ⊆ f '' b",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {a b : Set α}  (f : α → β)  (h : a ⊆ b) : f '' a ⊆ f '' b := by simp only [subset_def]; sorry",
  "name": "image_subset",
  "kind": "theorem",
  "first-tactic": "simp only [subset_def]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {a b : Set α}  (f : α → β)  (h : a ⊆ b) : f '' a ⊆ f '' b",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {a b : Set α}  (f : α → β)  (h : a ⊆ b)"},
 {"type": "f '' ∅ = ∅",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : α → β) : f '' ∅ = ∅ := by ext; sorry",
  "name": "image_empty",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : α → β) : f '' ∅ = ∅",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : α → β)"},
 {"type": "f '' {a} = {f a}",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {a : α} : f '' {a} = {f a} := by ext; sorry",
  "name": "image_singleton",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {a : α} : f '' {a} = {f a}",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {a : α}"},
 {"type": "t ∈ HasCompl.compl '' S ↔ tᶜ ∈ S",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` [BooleanAlgebra α]  (t : α)  (S : Set α) : t ∈ HasCompl.compl '' S ↔ tᶜ ∈ S := by simp [← preimage_compl_eq_image_compl]; sorry",
  "name": "mem_compl_image",
  "kind": "theorem",
  "first-tactic": "simp [← preimage_compl_eq_image_compl]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` [BooleanAlgebra α]  (t : α)  (S : Set α) : t ∈ HasCompl.compl '' S ↔ tᶜ ∈ S",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` [BooleanAlgebra α]  (t : α)  (S : Set α)"},
 {"type": "(fun x => x) '' s = s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (s : Set α) : (fun x => x) '' s = s := by ext; sorry",
  "name": "image_id'",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (s : Set α) : (fun x => x) '' s = s",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (s : Set α)"},
 {"type": "id '' s = s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (s : Set α) : id '' s = s := by simp; sorry",
  "name": "image_id",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (s : Set α) : id '' s = s",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (s : Set α)"},
 {"type": "HasCompl.compl '' (HasCompl.compl '' S) = S",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` [BooleanAlgebra α]  (S : Set α) : HasCompl.compl '' (HasCompl.compl '' S) = S := by rw [← image_comp]; sorry",
  "name": "compl_compl_image",
  "kind": "theorem",
  "first-tactic": "rw [← image_comp]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` [BooleanAlgebra α]  (S : Set α) : HasCompl.compl '' (HasCompl.compl '' S) = S",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` [BooleanAlgebra α]  (S : Set α)"},
 {"type": "f '' insert a s = insert (f a) (f '' s)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {a : α}  {s : Set α} : f '' insert a s = insert (f a) (f '' s) := by ext; sorry",
  "name": "image_insert_eq",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {a : α}  {s : Set α} : f '' insert a s = insert (f a) (f '' s)",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {a : α}  {s : Set α}"},
 {"type": "f '' {a, b} = {f a, f b}",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : α → β)  (a b : α) : f '' {a, b} = {f a, f b} := by simp only [image_insert_eq]; sorry",
  "name": "image_pair",
  "kind": "theorem",
  "first-tactic": "simp only [image_insert_eq]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : α → β)  (a b : α) : f '' {a, b} = {f a, f b}",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : α → β)  (a b : α)"},
 {"type": "b ∈ f '' s ↔ g b ∈ s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {g : β → α}  {b : β}  {s : Set α}  (h₁ : LeftInverse g f)      (h₂ : RightInverse g f) : b ∈ f '' s ↔ g b ∈ s := by rw [image_eq_preimage_of_inverse h₁ h₂]; sorry",
  "name": "mem_image_iff_of_inverse",
  "kind": "theorem",
  "first-tactic": "rw [image_eq_preimage_of_inverse h₁ h₂]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {g : β → α}  {b : β}  {s : Set α}  (h₁ : LeftInverse g f)      (h₂ : RightInverse g f) : b ∈ f '' s ↔ g b ∈ s",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {g : β → α}  {b : β}  {s : Set α}  (h₁ : LeftInverse g f)      (h₂ : RightInverse g f)"},
 {"type": "f '' s \\ f '' t ⊆ f '' (s \\ t)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : α → β)  (s t : Set α) : f '' s \\ f '' t ⊆ f '' (s \\ t) := by rw [diff_subset_iff]; sorry",
  "name": "subset_image_diff",
  "kind": "theorem",
  "first-tactic": "rw [diff_subset_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : α → β)  (s t : Set α) : f '' s \\ f '' t ⊆ f '' (s \\ t)",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : α → β)  (s t : Set α)"},
 {"type": "f '' s ∆ t = (f '' s) ∆ (f '' t)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (hf : Injective f)  (s t : Set α) : f '' s ∆ t = (f '' s) ∆ (f '' t) := by simp_rw [Set.symmDiff_def]; sorry",
  "name": "image_symm_diff",
  "kind": "theorem",
  "first-tactic": "simp_rw [Set.symmDiff_def]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (hf : Injective f)  (s t : Set α) : f '' s ∆ t = (f '' s) ∆ (f '' t)",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (hf : Injective f)  (s t : Set α)"},
 {"type": "f '' (s ∩ f ⁻¹' t) = f '' s ∩ t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : α → β)  (s : Set α)  (t : Set β) : f '' (s ∩ f ⁻¹' t) = f '' s ∩ t := by apply Subset.antisymm; sorry",
  "name": "image_inter_preimage",
  "kind": "theorem",
  "first-tactic": "apply Subset.antisymm",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : α → β)  (s : Set α)  (t : Set β) : f '' (s ∩ f ⁻¹' t) = f '' s ∩ t",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : α → β)  (s : Set α)  (t : Set β)"},
 {"type": "f '' (f ⁻¹' t ∩ s) = t ∩ f '' s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : α → β)  (s : Set α)  (t : Set β) : f '' (f ⁻¹' t ∩ s) = t ∩ f '' s := by simp only [inter_comm]; sorry",
  "name": "image_preimage_inter",
  "kind": "theorem",
  "first-tactic": "simp only [inter_comm]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : α → β)  (s : Set α)  (t : Set β) : f '' (f ⁻¹' t ∩ s) = t ∩ f '' s",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : α → β)  (s : Set α)  (t : Set β)"},
 {"type": "(f '' s ∩ t).Nonempty ↔ (s ∩ f ⁻¹' t).Nonempty",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {s : Set α}  {t : Set β} : (f '' s ∩ t).Nonempty ↔ (s ∩ f ⁻¹' t).Nonempty := by rw [← image_inter_preimage]; sorry",
  "name": "image_inter_nonempty_iff",
  "kind": "theorem",
  "first-tactic": "rw [← image_inter_preimage]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {s : Set α}  {t : Set β} : (f '' s ∩ t).Nonempty ↔ (s ∩ f ⁻¹' t).Nonempty",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {s : Set α}  {t : Set β}"},
 {"type": "f '' (s \\ f ⁻¹' t) = f '' s \\ t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {s : Set α}  {t : Set β} : f '' (s \\ f ⁻¹' t) = f '' s \\ t := by simp_rw [diff_eq]; sorry",
  "name": "image_diff_preimage",
  "kind": "theorem",
  "first-tactic": "simp_rw [diff_eq]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {s : Set α}  {t : Set β} : f '' (s \\ f ⁻¹' t) = f '' s \\ t",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  {s : Set α}  {t : Set β}"},
 {"type": "f '' s ⊆ f '' t ↔ s ⊆ t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  (hf : Injective f) : f '' s ⊆ f '' t ↔ s ⊆ t := by refine' Iff.symm <| (Iff.intro (image_subset f)) fun h => _; sorry",
  "name": "image_subset_image_iff",
  "kind": "theorem",
  "first-tactic": "refine' Iff.symm <| (Iff.intro (image_subset f)) fun h => _",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  (hf : Injective f) : f '' s ⊆ f '' t ↔ s ⊆ t",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : α → β}  (hf : Injective f)"},
 {"type": "σ '' s = s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {s : Set α}  {σ : Equiv.Perm α}  (hs : { a : α | σ a ≠ a } ⊆ s) : σ '' s = s := by ext i; sorry",
  "name": "image_perm",
  "kind": "theorem",
  "first-tactic": "ext i",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {s : Set α}  {σ : Equiv.Perm α}  (hs : { a : α | σ a ≠ a } ⊆ s) : σ '' s = s",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : α → β}  {s t : Set α}  -- Porting note: `Set.image` is already defined in `Init.Set` {s : Set α}  {σ : Equiv.Perm α}  (hs : { a : α | σ a ≠ a } ⊆ s)"},
 {"type": "(∀ a ∈ range f, p a) ↔ ∀ i, p (f i)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : α → Prop} : (∀ a ∈ range f, p a) ↔ ∀ i, p (f i) := by simp; sorry",
  "name": "forall_range_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : α → Prop} : (∀ a ∈ range f, p a) ↔ ∀ i, p (f i)",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : α → Prop}"},
 {"type": "(∃ a ∈ range f, p a) ↔ ∃ i, p (f i)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : α → Prop} : (∃ a ∈ range f, p a) ↔ ∃ i, p (f i) := by simp; sorry",
  "name": "exists_range_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : α → Prop} : (∃ a ∈ range f, p a) ↔ ∃ i, p (f i)",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : α → Prop}"},
 {"type": "(∃ a, a ∈ range f ∧ p a) ↔ ∃ i, p (f i)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : α → Prop} : (∃ a, a ∈ range f ∧ p a) ↔ ∃ i, p (f i) := by simpa only [exists_prop] using exists_range_iff; sorry",
  "name": "exists_range_iff'",
  "kind": "theorem",
  "first-tactic": "simpa only [exists_prop] using exists_range_iff",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : α → Prop} : (∃ a, a ∈ range f ∧ p a) ↔ ∃ i, p (f i)",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : α → Prop}"},
 {"type": "f '' univ = range f",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β} : f '' univ = range f := by ext; sorry",
  "name": "image_univ",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β} : f '' univ = range f",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β}"},
 {"type": "range f = s ↔ (∀ a, f a ∈ s) ∧ ∀ b ∈ s, ∃ a, f a = b",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (f : α → β)  (s : Set β) : range f = s ↔ (∀ a, f a ∈ s) ∧ ∀ b ∈ s, ∃ a, f a = b := by rw [← range_subset_iff]; sorry",
  "name": "range_eq_iff",
  "kind": "theorem",
  "first-tactic": "rw [← range_subset_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (f : α → β)  (s : Set β) : range f = s ↔ (∀ a, f a ∈ s) ∧ ∀ b ∈ s, ∃ a, f a = b",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (f : α → β)  (s : Set β)"},
 {"type": "range (g ∘ f) ⊆ range g",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (f : α → β)  (g : β → γ) : range (g ∘ f) ⊆ range g := by rw [range_comp]; sorry",
  "name": "range_comp_subset_range",
  "kind": "theorem",
  "first-tactic": "rw [range_comp]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (f : α → β)  (g : β → γ) : range (g ∘ f) ⊆ range g",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (f : α → β)  (g : β → γ)"},
 {"type": "range f = ∅ ↔ IsEmpty ι",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : ι → α} : range f = ∅ ↔ IsEmpty ι := by rw [← not_nonempty_iff]; sorry",
  "name": "range_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "rw [← not_nonempty_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : ι → α} : range f = ∅ ↔ IsEmpty ι",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : ι → α}"},
 {"type": "f '' s ∪ f '' sᶜ = range f",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (f : α → β) : f '' s ∪ f '' sᶜ = range f := by rw [← image_union]; sorry",
  "name": "image_union_image_compl_eq_range",
  "kind": "theorem",
  "first-tactic": "rw [← image_union]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (f : α → β) : f '' s ∪ f '' sᶜ = range f",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (f : α → β)"},
 {"type": "insert (f x) (f '' {x}ᶜ) = range f",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (f : α → β)  (x : α) : insert (f x) (f '' {x}ᶜ) = range f := by ext y; sorry",
  "name": "insert_image_compl_eq_range",
  "kind": "theorem",
  "first-tactic": "ext y",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (f : α → β)  (x : α) : insert (f x) (f '' {x}ᶜ) = range f",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (f : α → β)  (x : α)"},
 {"type": "f '' (f ⁻¹' s) = s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β}  {s : Set β}  (hs : s ⊆ range f) : f '' (f ⁻¹' s) = s := by rw [image_preimage_eq_inter_range]; sorry",
  "name": "image_preimage_eq_of_subset",
  "kind": "theorem",
  "first-tactic": "rw [image_preimage_eq_inter_range]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β}  {s : Set β}  (hs : s ⊆ range f) : f '' (f ⁻¹' s) = s",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β}  {s : Set β}  (hs : s ⊆ range f)"},
 {"type": "(∃ (s : _) (_ : s ⊆ range f), p s) ↔ ∃ s, p (f '' s)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β}  {p : Set β → Prop} : (∃ (s : _) (_ : s ⊆ range f), p s) ↔ ∃ s, p (f '' s) := by simp; sorry",
  "name": "exists_subset_range_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β}  {p : Set β → Prop} : (∃ (s : _) (_ : s ⊆ range f), p s) ↔ ∃ s, p (f '' s)",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β}  {p : Set β → Prop}"},
 {"type": "f ⁻¹' s ⊆ f ⁻¹' t ↔ s ⊆ t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {s t : Set α}  {f : β → α}  (hs : s ⊆ range f) : f ⁻¹' s ⊆ f ⁻¹' t ↔ s ⊆ t := by constructor; sorry",
  "name": "preimage_subset_preimage_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {s t : Set α}  {f : β → α}  (hs : s ⊆ range f) : f ⁻¹' s ⊆ f ⁻¹' t ↔ s ⊆ t",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {s t : Set α}  {f : β → α}  (hs : s ⊆ range f)"},
 {"type": "f ⁻¹' s = f ⁻¹' t ↔ s = t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {s t : Set α}  {f : β → α}  (hs : s ⊆ range f)  (ht : t ⊆ range f) : f ⁻¹' s = f ⁻¹' t ↔ s = t := by constructor; sorry",
  "name": "preimage_eq_preimage'",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {s t : Set α}  {f : β → α}  (hs : s ⊆ range f)  (ht : t ⊆ range f) : f ⁻¹' s = f ⁻¹' t ↔ s = t",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {s t : Set α}  {f : β → α}  (hs : s ⊆ range f)  (ht : t ⊆ range f)"},
 {"type": "f ⁻¹' (range f ∩ s) = f ⁻¹' s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β}  {s : Set β} : f ⁻¹' (range f ∩ s) = f ⁻¹' s := by rw [inter_comm]; sorry",
  "name": "preimage_range_inter",
  "kind": "theorem",
  "first-tactic": "rw [inter_comm]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β}  {s : Set β} : f ⁻¹' (range f ∩ s) = f ⁻¹' s",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β}  {s : Set β}"},
 {"type": "f ⁻¹' (f '' (f ⁻¹' s)) = f ⁻¹' s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β}  {s : Set β} : f ⁻¹' (f '' (f ⁻¹' s)) = f ⁻¹' s := by rw [image_preimage_eq_inter_range]; sorry",
  "name": "preimage_image_preimage",
  "kind": "theorem",
  "first-tactic": "rw [image_preimage_eq_inter_range]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β}  {s : Set β} : f ⁻¹' (f '' (f ⁻¹' s)) = f ⁻¹' s",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β}  {s : Set β}"},
 {"type": "Sum.inl ⁻¹' (@Sum.inr α β '' s) = ∅",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (s : Set β) : Sum.inl ⁻¹' (@Sum.inr α β '' s) = ∅ := by ext; sorry",
  "name": "preimage_inl_image_inr",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (s : Set β) : Sum.inl ⁻¹' (@Sum.inr α β '' s) = ∅",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (s : Set β)"},
 {"type": "Sum.inr ⁻¹' (@Sum.inl α β '' s) = ∅",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (s : Set α) : Sum.inr ⁻¹' (@Sum.inl α β '' s) = ∅ := by ext; sorry",
  "name": "preimage_inr_image_inl",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (s : Set α) : Sum.inr ⁻¹' (@Sum.inl α β '' s) = ∅",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (s : Set α)"},
 {"type": "Sum.inl ⁻¹' range (Sum.inr : β → Sum α β) = ∅",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} : Sum.inl ⁻¹' range (Sum.inr : β → Sum α β) = ∅ := by rw [← image_univ]; sorry",
  "name": "preimage_inl_range_inr",
  "kind": "theorem",
  "first-tactic": "rw [← image_univ]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} : Sum.inl ⁻¹' range (Sum.inr : β → Sum α β) = ∅",
  "args": "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α}"},
 {"type": "Sum.inr ⁻¹' range (Sum.inl : α → Sum α β) = ∅",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} : Sum.inr ⁻¹' range (Sum.inl : α → Sum α β) = ∅ := by rw [← image_univ]; sorry",
  "name": "preimage_inr_range_inl",
  "kind": "theorem",
  "first-tactic": "rw [← image_univ]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} : Sum.inr ⁻¹' range (Sum.inl : α → Sum α β) = ∅",
  "args": "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α}"},
 {"type": "Sum.inl '' (Sum.inl ⁻¹' s) ∪ Sum.inr '' (Sum.inr ⁻¹' s) = s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (s : Set (Sum α β)) : Sum.inl '' (Sum.inl ⁻¹' s) ∪ Sum.inr '' (Sum.inr ⁻¹' s) = s := by rw [image_preimage_eq_inter_range]; sorry",
  "name": "image_preimage_inl_union_image_preimage_inr",
  "kind": "theorem",
  "first-tactic": "rw [image_preimage_eq_inter_range]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (s : Set (Sum α β)) : Sum.inl '' (Sum.inl ⁻¹' s) ∪ Sum.inr '' (Sum.inr ⁻¹' s) = s",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (s : Set (Sum α β))"},
 {"type":
  "range (Subtype.map f h) = (fun x : Subtype q => (x : β)) ⁻¹' (f '' { x | p x })",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : α → Prop}  {q : β → Prop}  (f : α → β)  (h : ∀ x, p x → q (f x)) : range (Subtype.map f h) = (fun x : Subtype q => (x : β)) ⁻¹' (f '' { x | p x }) := by ext ⟨x, hx⟩; sorry",
  "name": "range_subtype_map",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, hx⟩",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : α → Prop}  {q : β → Prop}  (f : α → β)  (h : ∀ x, p x → q (f x)) : range (Subtype.map f h) = (fun x : Subtype q => (x : β)) ⁻¹' (f '' { x | p x })",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : α → Prop}  {q : β → Prop}  (f : α → β)  (h : ∀ x, p x → q (f x))"},
 {"type": "range f ⊆ {x} ↔ f = const ι x",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : ι → α}  {x : α} : range f ⊆ {x} ↔ f = const ι x := by simp [range_subset_iff]; sorry",
  "name": "range_subset_singleton",
  "kind": "theorem",
  "first-tactic": "simp [range_subset_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : ι → α}  {x : α} : range f ⊆ {x} ↔ f = const ι x",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : ι → α}  {x : α}"},
 {"type": "f '' (f ⁻¹' s)ᶜ = range f \\ s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β}  {s : Set β} : f '' (f ⁻¹' s)ᶜ = range f \\ s := by rw [compl_eq_univ_diff]; sorry",
  "name": "image_compl_preimage",
  "kind": "theorem",
  "first-tactic": "rw [compl_eq_univ_diff]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β}  {s : Set β} : f '' (f ⁻¹' s)ᶜ = range f \\ s",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {f : α → β}  {s : Set β}"},
 {"type": "f '' s = range fun x : s => f x",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (f : α → β)  (s : Set α) : f '' s = range fun x : s => f x := by ext; sorry",
  "name": "image_eq_range",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (f : α → β)  (s : Set α) : f '' s = range fun x : s => f x",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (f : α → β)  (s : Set α)"},
 {"type": "range (if p then f else g) ⊆ range f ∪ range g",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : Prop}  [Decidable p]  {f g : α → β} : range (if p then f else g) ⊆ range f ∪ range g := by by_cases h : p; sorry",
  "name": "range_ite_subset'",
  "kind": "theorem",
  "first-tactic": "by_cases h : p",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : Prop}  [Decidable p]  {f g : α → β} : range (if p then f else g) ⊆ range f ∪ range g",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : Prop}  [Decidable p]  {f g : α → β}"},
 {"type": "(range fun x => if p x then f x else g x) ⊆ range f ∪ range g",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : α → Prop}  [DecidablePred p]  {f g : α → β} : (range fun x => if p x then f x else g x) ⊆ range f ∪ range g := by rw [range_subset_iff]; sorry",
  "name": "range_ite_subset",
  "kind": "theorem",
  "first-tactic": "rw [range_subset_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : α → Prop}  [DecidablePred p]  {f g : α → β} : (range fun x => if p x then f x else g x) ⊆ range f ∪ range g",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} {p : α → Prop}  [DecidablePred p]  {f g : α → β}"},
 {"type": "range f = {f default}",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} [h : Unique ι] : range f = {f default} := by ext x; sorry",
  "name": "range_unique",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} [h : Unique ι] : range f = {f default}",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} [h : Unique ι]"},
 {"type": "range (inclusion h) = { x : t | (x : α) ∈ s }",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (h : s ⊆ t) : range (inclusion h) = { x : t | (x : α) ∈ s } := by ext ⟨x, hx⟩; sorry",
  "name": "range_inclusion",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, hx⟩",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (h : s ⊆ t) : range (inclusion h) = { x : t | (x : α) ∈ s }",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α} (h : s ⊆ t)"},
 {"type": "f ∘ rangeSplitting f = (fun x : ↥(range f) => (x : β))",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α}  (f : α → β) : f ∘ rangeSplitting f = (fun x : ↥(range f) => (x : β)) := by ext; sorry",
  "name": "comp_rangeSplitting",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α}  (f : α → β) : f ∘ rangeSplitting f = (fun x : ↥(range f) => (x : β))",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {f : ι → α}  {s t : Set α}  (f : α → β)"},
 {"type": "(f ⁻¹' s).Nontrivial",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _}  {s : Set α} {s : Set β}  (hs : s.Nontrivial)  {f : α → β}      (hf : Function.Surjective f) : (f ⁻¹' s).Nontrivial := by rcases hs with ⟨fx, hx, fy, hy, hxy⟩; sorry",
  "name": "Nontrivial.preimage",
  "kind": "theorem",
  "first-tactic": "rcases hs with ⟨fx, hx, fy, hy, hxy⟩",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _}  {s : Set α} {s : Set β}  (hs : s.Nontrivial)  {f : α → β}      (hf : Function.Surjective f) : (f ⁻¹' s).Nontrivial",
  "args":
  "{α β γ : Type _}  {ι : Sort _}  {s : Set α} {s : Set β}  (hs : s.Nontrivial)  {f : α → β}      (hf : Function.Surjective f)"},
 {"type": "Surjective (preimage f)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} (hf : Injective f) : Surjective (preimage f) := by intro s; sorry",
  "name": "Injective.preimage_surjective",
  "kind": "theorem",
  "first-tactic": "intro s",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} (hf : Injective f) : Surjective (preimage f)",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} (hf : Injective f)"},
 {"type": "Surjective (image f)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} (hf : Surjective f) : Surjective (image f) := by intro s; sorry",
  "name": "Surjective.image_surjective",
  "kind": "theorem",
  "first-tactic": "intro s",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} (hf : Surjective f) : Surjective (image f)",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} (hf : Surjective f)"},
 {"type": "(f ⁻¹' s).Nonempty ↔ s.Nonempty",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} (hf : Surjective f)  {s : Set β} : (f ⁻¹' s).Nonempty ↔ s.Nonempty := by rw [← nonempty_image_iff]; sorry",
  "name": "Surjective.nonempty_preimage",
  "kind": "theorem",
  "first-tactic": "rw [← nonempty_image_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} (hf : Surjective f)  {s : Set β} : (f ⁻¹' s).Nonempty ↔ s.Nonempty",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} (hf : Surjective f)  {s : Set β}"},
 {"type": "Injective (image f)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} (hf : Injective f) : Injective (image f) := by intro s t h; sorry",
  "name": "Injective.image_injective",
  "kind": "theorem",
  "first-tactic": "intro s t h",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} (hf : Injective f) : Injective (image f)",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} (hf : Injective f)"},
 {"type": "f ⁻¹' s ⊆ f ⁻¹' t ↔ s ⊆ t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {s t : Set β}  (hf : Surjective f) : f ⁻¹' s ⊆ f ⁻¹' t ↔ s ⊆ t := by apply Set.preimage_subset_preimage_iff; sorry",
  "name": "Surjective.preimage_subset_preimage_iff",
  "kind": "theorem",
  "first-tactic": "apply Set.preimage_subset_preimage_iff",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {s t : Set β}  (hf : Surjective f) : f ⁻¹' s ⊆ f ⁻¹' t ↔ s ⊆ t",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {s t : Set β}  (hf : Surjective f)"},
 {"type": "(f '' s)ᶜ = f '' sᶜ ∪ range fᶜ",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} (hf : Injective f)  (s : Set α) : (f '' s)ᶜ = f '' sᶜ ∪ range fᶜ := by ext y; sorry",
  "name": "Injective.compl_image_eq",
  "kind": "theorem",
  "first-tactic": "ext y",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} (hf : Injective f)  (s : Set α) : (f '' s)ᶜ = f '' sᶜ ∪ range fᶜ",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} (hf : Injective f)  (s : Set α)"},
 {"type": "g '' (f '' s) = s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {g : β → α}  (h : LeftInverse g f)  (s : Set α) : g '' (f '' s) = s := by rw [← image_comp]; sorry",
  "name": "LeftInverse.image_image",
  "kind": "theorem",
  "first-tactic": "rw [← image_comp]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {g : β → α}  (h : LeftInverse g f)  (s : Set α) : g '' (f '' s) = s",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {g : β → α}  (h : LeftInverse g f)  (s : Set α)"},
 {"type": "f ⁻¹' (g ⁻¹' s) = s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {g : β → α}  (h : LeftInverse g f)  (s : Set α) : f ⁻¹' (g ⁻¹' s) = s := by rw [← preimage_comp]; sorry",
  "name": "LeftInverse.preimage_preimage",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_comp]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {g : β → α}  (h : LeftInverse g f)  (s : Set α) : f ⁻¹' (g ⁻¹' s) = s",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {g : β → α}  (h : LeftInverse g f)  (s : Set α)"},
 {"type": "(fun x : s => (x : α)) '' { x : ↥s | ↑x ∈ t } = t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {s t : Set α}  (h : t ⊆ s) : (fun x : s => (x : α)) '' { x : ↥s | ↑x ∈ t } = t := by ext x; sorry",
  "name": "coe_image_of_subset",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {s t : Set α}  (h : t ⊆ s) : (fun x : s => (x : α)) '' { x : ↥s | ↑x ∈ t } = t",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {s t : Set α}  (h : t ⊆ s)"},
 {"type": "range (fun x : s => (x : α)) = s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {s : Set α} : range (fun x : s => (x : α)) = s := by rw [← Set.image_univ]; sorry",
  "name": "range_coe",
  "kind": "theorem",
  "first-tactic": "rw [← Set.image_univ]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {s : Set α} : range (fun x : s => (x : α)) = s",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {s : Set α}"},
 {"type": "(fun x : s => (x : α)) ⁻¹' s = univ",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} (s : Set α) : (fun x : s => (x : α)) ⁻¹' s = univ := by rw [← preimage_range]; sorry",
  "name": "coe_preimage_self",
  "kind": "theorem",
  "first-tactic": "rw [← preimage_range]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} (s : Set α) : (fun x : s => (x : α)) ⁻¹' s = univ",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} (s : Set α)"},
 {"type":
  "(fun x : s => (x : α)) ⁻¹' t = (fun x : s => (x : α)) ⁻¹' u ↔ t ∩ s = u ∩ s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {s t u : Set α} : (fun x : s => (x : α)) ⁻¹' t = (fun x : s => (x : α)) ⁻¹' u ↔ t ∩ s = u ∩ s := by rw [← image_preimage_coe]; sorry",
  "name": "preimage_coe_eq_preimage_coe_iff",
  "kind": "theorem",
  "first-tactic": "rw [← image_preimage_coe]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {s t u : Set α} : (fun x : s => (x : α)) ⁻¹' t = (fun x : s => (x : α)) ⁻¹' u ↔ t ∩ s = u ∩ s",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {s t u : Set α}"},
 {"type": "(fun x : s => (x : α)) ⁻¹' (t ∩ s) = (fun x : s => (x : α)) ⁻¹' t",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} (s t : Set α) : (fun x : s => (x : α)) ⁻¹' (t ∩ s) = (fun x : s => (x : α)) ⁻¹' t := by rw [preimage_coe_eq_preimage_coe_iff]; sorry",
  "name": "preimage_coe_inter_self",
  "kind": "theorem",
  "first-tactic": "rw [preimage_coe_eq_preimage_coe_iff]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} (s t : Set α) : (fun x : s => (x : α)) ⁻¹' (t ∩ s) = (fun x : s => (x : α)) ⁻¹' t",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} (s t : Set α)"},
 {"type":
  "(∃ s : Set t, p ((fun x : t => (x : α)) '' s)) ↔ ∃ s : Set α, s ⊆ t ∧ p s",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {t : Set α}  (p : Set α → Prop) : (∃ s : Set t, p ((fun x : t => (x : α)) '' s)) ↔ ∃ s : Set α, s ⊆ t ∧ p s := by constructor; sorry",
  "name": "exists_set_subtype",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {t : Set α}  (p : Set α → Prop) : (∃ s : Set t, p ((fun x : t => (x : α)) '' s)) ↔ ∃ s : Set α, s ⊆ t ∧ p s",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {t : Set α}  (p : Set α → Prop)"},
 {"type": "((fun x : s => (x : α)) ⁻¹' t).Nonempty ↔ (s ∩ t).Nonempty",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {s t : Set α} : ((fun x : s => (x : α)) ⁻¹' t).Nonempty ↔ (s ∩ t).Nonempty := by rw [inter_comm]; sorry",
  "name": "preimage_coe_nonempty",
  "kind": "theorem",
  "first-tactic": "rw [inter_comm]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {s t : Set α} : ((fun x : s => (x : α)) ⁻¹' t).Nonempty ↔ (s ∩ t).Nonempty",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {s t : Set α}"},
 {"type": "(fun x : s => (x : α)) ⁻¹' t = ∅ ↔ s ∩ t = ∅",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {s t : Set α} : (fun x : s => (x : α)) ⁻¹' t = ∅ ↔ s ∩ t = ∅ := by simp [← not_nonempty_iff_eq_empty]; sorry",
  "name": "preimage_coe_eq_empty",
  "kind": "theorem",
  "first-tactic": "simp [← not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {s t : Set α} : (fun x : s => (x : α)) ⁻¹' t = ∅ ↔ s ∩ t = ∅",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _} {s t : Set α}"},
 {"type": "Injective (preimage f) ↔ Surjective f",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _}  {α : Type u}  {β : Type v}  {f : α → β} : Injective (preimage f) ↔ Surjective f := by refine' ⟨fun h y => _, Surjective.preimage_injective⟩; sorry",
  "name": "preimage_injective",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h y => _, Surjective.preimage_injective⟩",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _}  {α : Type u}  {β : Type v}  {f : α → β} : Injective (preimage f) ↔ Surjective f",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _}  {α : Type u}  {β : Type v}  {f : α → β}"},
 {"type": "Surjective (preimage f) ↔ Injective f",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _}  {α : Type u}  {β : Type v}  {f : α → β} : Surjective (preimage f) ↔ Injective f := by refine' ⟨fun h x x' hx => _, Injective.preimage_surjective⟩; sorry",
  "name": "preimage_surjective",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h x x' hx => _, Injective.preimage_surjective⟩",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _}  {α : Type u}  {β : Type v}  {f : α → β} : Surjective (preimage f) ↔ Injective f",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _}  {α : Type u}  {β : Type v}  {f : α → β}"},
 {"type": "Surjective (image f) ↔ Surjective f",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _}  {α : Type u}  {β : Type v}  {f : α → β} : Surjective (image f) ↔ Surjective f := by refine' ⟨fun h y => _, Surjective.image_surjective⟩; sorry",
  "name": "image_surjective",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h y => _, Surjective.image_surjective⟩",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _}  {α : Type u}  {β : Type v}  {f : α → β} : Surjective (image f) ↔ Surjective f",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _}  {α : Type u}  {β : Type v}  {f : α → β}"},
 {"type": "Injective (image f) ↔ Injective f",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _}  {α : Type u}  {β : Type v}  {f : α → β} : Injective (image f) ↔ Injective f := by refine' ⟨fun h x x' hx => _, Injective.image_injective⟩; sorry",
  "name": "image_injective",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h x x' hx => _, Injective.image_injective⟩",
  "core-prompt":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _}  {α : Type u}  {β : Type v}  {f : α → β} : Injective (image f) ↔ Injective f",
  "args":
  "{α β γ : Type _}  {ι : Sort _} {ι : Sort _}  {α : Type _}  {β : Type _}  {f : α → β} {α : Type _}  {α : Type u}  {β : Type v}  {f : α → β}"},
 {"type": "a.val = b.val → a = b",
  "tactic-prompt":
  "lemma {a b : Fin n} : a.val = b.val → a = b := by cases a; sorry",
  "name": "Fin.ext",
  "kind": "lemma",
  "first-tactic": "cases a",
  "core-prompt": "{a b : Fin n} : a.val = b.val → a = b",
  "args": "{a b : Fin n}"},
 {"type": "(⟨(a : ℕ), h⟩ : Fin n) = a",
  "tactic-prompt":
  "theorem (a : Fin n)  (h : (a : ℕ) < n) : (⟨(a : ℕ), h⟩ : Fin n) = a := by cases a; sorry",
  "name": "Fin.eta",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a : Fin n)  (h : (a : ℕ) < n) : (⟨(a : ℕ), h⟩ : Fin n) = a",
  "args": "(a : Fin n)  (h : (a : ℕ) < n)"},
 {"type": "(Fin.ofNat' a (zero_lt_of_lt h)).val = a",
  "tactic-prompt":
  "lemma {n a : Nat}  (h : a < n) : (Fin.ofNat' a (zero_lt_of_lt h)).val = a := by simp only [Fin.ofNat']; sorry",
  "name": "Fin.val_eq_of_lt",
  "kind": "lemma",
  "first-tactic": "simp only [Fin.ofNat']",
  "core-prompt":
  "{n a : Nat}  (h : a < n) : (Fin.ofNat' a (zero_lt_of_lt h)).val = a",
  "args": "{n a : Nat}  (h : a < n)"},
 {"type": "(1 : Fin (n + 2)).val = 1",
  "tactic-prompt":
  "lemma  : (1 : Fin (n + 2)).val = 1 := by simp only [OfNat.ofNat]; sorry",
  "name": "Fin.one_val",
  "kind": "lemma",
  "first-tactic": "simp only [OfNat.ofNat]",
  "core-prompt": " : (1 : Fin (n + 2)).val = 1",
  "args": ""},
 {"type": "a % b = a",
  "tactic-prompt":
  "theorem {a b : Fin n}  (h : a < b) : a % b = a := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mod_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt": "{a b : Fin n}  (h : a < b) : a % b = a",
  "args": "{a b : Fin n}  (h : a < b)"},
 {"type": "(Fin.checkedAdd a b).isSome = true ↔ a.val + b.val < n",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedAdd a b).isSome = true ↔ a.val + b.val < n := by by_cases n <= a.val + b.val; sorry",
  "name": "Fin.checked_add_spec",
  "kind": "lemma",
  "first-tactic": "by_cases n <= a.val + b.val",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedAdd a b).isSome = true ↔ a.val + b.val < n",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "(Fin.checkedMul a b).isSome = true ↔ a.val * b.val < n",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedMul a b).isSome = true ↔ a.val * b.val < n := by simp only [checkedMul]; sorry",
  "name": "Fin.checked_mul_spec",
  "kind": "lemma",
  "first-tactic": "simp only [checkedMul]",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedMul a b).isSome = true ↔ a.val * b.val < n",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "(Fin.checkedSub a b).isSome = true ↔ b.val <= a.val",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedSub a b).isSome = true ↔ b.val <= a.val := by simp only [checkedSub]; sorry",
  "name": "Fin.checked_sub_spec",
  "kind": "lemma",
  "first-tactic": "simp only [checkedSub]",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedSub a b).isSome = true ↔ b.val <= a.val",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "a * 1 = a",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a : Fin n) : a * 1 = a := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mul_one",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n) : a * 1 = a",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n)"},
 {"type": "a * (b + c) = a * b + a * c",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a b c : Fin n) : a * (b + c) = a * b + a * c := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mul_add",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b c : Fin n) : a * (b + c) = a * b + a * c",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b c : Fin n)"},
 {"type": "∀ (a b : Fin n), a - b = a + -b",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] : ∀ (a b : Fin n), a - b = a + -b := by simp [Fin.add_def]; sorry",
  "name": "Fin.sub_eq_add_neg",
  "kind": "theorem",
  "first-tactic": "simp [Fin.add_def]",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] : ∀ (a b : Fin n), a - b = a + -b",
  "args": "{n : Nat}  [Nonempty (Fin n)]"},
 {"type": "-a + a = 0",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a : Fin n) : -a + a = 0 := by rw [add_comm]; sorry",
  "name": "Fin.add_left_neg",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n) : -a + a = 0",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n)"},
 {"type": "a ≤ b → b ≤ a → a = b",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : a ≤ b → b ≤ a → a = b := by intro h1 h2; sorry",
  "name": "Fin.le_antisymm",
  "kind": "lemma",
  "first-tactic": "intro h1 h2",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : a ≤ b → b ≤ a → a = b",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "(mulSingle i x : I → β) i' = (mulSingle i' x : I → β) i",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, One (f i)]  [∀ i, One (g i)]  [∀ i, One (h i)] [One β]  (i : I)  (x : β)  (i' : I) : (mulSingle i x : I → β) i' = (mulSingle i' x : I → β) i := by simp [mulSingle_apply]; sorry",
  "name": "mulSingle_comm",
  "kind": "theorem",
  "first-tactic": "simp [mulSingle_apply]",
  "core-prompt":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, One (f i)]  [∀ i, One (g i)]  [∀ i, One (h i)] [One β]  (i : I)  (x : β)  (i' : I) : (mulSingle i x : I → β) i' = (mulSingle i' x : I → β) i",
  "args":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, One (f i)]  [∀ i, One (g i)]  [∀ i, One (h i)] [One β]  (i : I)  (x : β)  (i' : I)"},
 {"type": "f' j (mulSingle i x j) = mulSingle i (f' i x) j",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, One (f i)]  [∀ i, One (g i)]  [∀ i, One (h i)] (f' : ∀ i, f i → g i)  (hf' : ∀ i, f' i 1 = 1)  (i : I)  (x : f i)  (j : I) : f' j (mulSingle i x j) = mulSingle i (f' i x) j := by simpa only [Pi.one_apply]; sorry",
  "name": "apply_mulSingle",
  "kind": "theorem",
  "first-tactic": "simpa only [Pi.one_apply]",
  "core-prompt":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, One (f i)]  [∀ i, One (g i)]  [∀ i, One (h i)] (f' : ∀ i, f i → g i)  (hf' : ∀ i, f' i 1 = 1)  (i : I)  (x : f i)  (j : I) : f' j (mulSingle i x j) = mulSingle i (f' i x) j",
  "args":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, One (f i)]  [∀ i, One (g i)]  [∀ i, One (h i)] (f' : ∀ i, f i → g i)  (hf' : ∀ i, f' i 1 = 1)  (i : I)  (x : f i)  (j : I)"},
 {"type": "f' j (mulSingle i x j) (mulSingle i y j) = mulSingle i (f' i x y) j",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, One (f i)]  [∀ i, One (g i)]  [∀ i, One (h i)] (f' : ∀ i, f i → g i → h i)  (hf' : ∀ i, f' i 1 1 = 1)  (i : I)      (x : f i)  (y : g i)  (j : I) : f' j (mulSingle i x j) (mulSingle i y j) = mulSingle i (f' i x y) j := by by_cases h : j = i; sorry",
  "name": "apply_mulSingle₂",
  "kind": "theorem",
  "first-tactic": "by_cases h : j = i",
  "core-prompt":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, One (f i)]  [∀ i, One (g i)]  [∀ i, One (h i)] (f' : ∀ i, f i → g i → h i)  (hf' : ∀ i, f' i 1 1 = 1)  (i : I)      (x : f i)  (y : g i)  (j : I) : f' j (mulSingle i x j) (mulSingle i y j) = mulSingle i (f' i x y) j",
  "args":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [DecidableEq I] [∀ i, One (f i)]  [∀ i, One (g i)]  [∀ i, One (h i)] (f' : ∀ i, f i → g i → h i)  (hf' : ∀ i, f' i 1 1 = 1)  (i : I)      (x : f i)  (y : g i)  (j : I)"},
 {"type":
  "Function.extend f (g₁ * g₂) (e₁ * e₂) = Function.extend f g₁ e₁ * Function.extend f g₂ e₂",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [Mul γ]  (f : α → β)  (g₁ g₂ : α → γ)  (e₁ e₂ : β → γ) : Function.extend f (g₁ * g₂) (e₁ * e₂) = Function.extend f g₁ e₁ * Function.extend f g₂ e₂ := by classical\n  funext x\n  simp only [not_exists]; sorry",
  "name": "extend_mul",
  "kind": "theorem",
  "first-tactic": "classical\n  funext x\n  simp only [not_exists]",
  "core-prompt":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [Mul γ]  (f : α → β)  (g₁ g₂ : α → γ)  (e₁ e₂ : β → γ) : Function.extend f (g₁ * g₂) (e₁ * e₂) = Function.extend f g₁ e₁ * Function.extend f g₂ e₂",
  "args":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [Mul γ]  (f : α → β)  (g₁ g₂ : α → γ)  (e₁ e₂ : β → γ)"},
 {"type": "Function.extend f g⁻¹ e⁻¹ = (Function.extend f g e)⁻¹",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [Inv γ]  (f : α → β)  (g : α → γ)  (e : β → γ) : Function.extend f g⁻¹ e⁻¹ = (Function.extend f g e)⁻¹ := by classical\n  funext x\n  simp only [not_exists]; sorry",
  "name": "extend_inv",
  "kind": "theorem",
  "first-tactic": "classical\n  funext x\n  simp only [not_exists]",
  "core-prompt":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [Inv γ]  (f : α → β)  (g : α → γ)  (e : β → γ) : Function.extend f g⁻¹ e⁻¹ = (Function.extend f g e)⁻¹",
  "args":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [Inv γ]  (f : α → β)  (g : α → γ)  (e : β → γ)"},
 {"type":
  "Function.extend f (g₁ / g₂) (e₁ / e₂) = Function.extend f g₁ e₁ / Function.extend f g₂ e₂",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [Div γ]  (f : α → β)  (g₁ g₂ : α → γ)  (e₁ e₂ : β → γ) : Function.extend f (g₁ / g₂) (e₁ / e₂) = Function.extend f g₁ e₁ / Function.extend f g₂ e₂ := by classical\n  funext x\n  simp [Function.extend_def]; sorry",
  "name": "extend_div",
  "kind": "theorem",
  "first-tactic": "classical\n  funext x\n  simp [Function.extend_def]",
  "core-prompt":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [Div γ]  (f : α → β)  (g₁ g₂ : α → γ)  (e₁ e₂ : β → γ) : Function.extend f (g₁ / g₂) (e₁ / e₂) = Function.extend f g₁ e₁ / Function.extend f g₂ e₂",
  "args":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I)  [Div γ]  (f : α → β)  (g₁ g₂ : α → γ)  (e₁ e₂ : β → γ)"},
 {"type":
  "Sum.elim (Pi.mulSingle i c) (1 : β → γ) = Pi.mulSingle (Sum.inl i) c",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I) (a a' : α → γ)  (b b' : β → γ) [DecidableEq α]  [DecidableEq β]  [One γ]  (i : α)  (c : γ) : Sum.elim (Pi.mulSingle i c) (1 : β → γ) = Pi.mulSingle (Sum.inl i) c := by simp only [Pi.mulSingle]; sorry",
  "name": "elim_mulSingle_one",
  "kind": "theorem",
  "first-tactic": "simp only [Pi.mulSingle]",
  "core-prompt":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I) (a a' : α → γ)  (b b' : β → γ) [DecidableEq α]  [DecidableEq β]  [One γ]  (i : α)  (c : γ) : Sum.elim (Pi.mulSingle i c) (1 : β → γ) = Pi.mulSingle (Sum.inl i) c",
  "args":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I) (a a' : α → γ)  (b b' : β → γ) [DecidableEq α]  [DecidableEq β]  [One γ]  (i : α)  (c : γ)"},
 {"type":
  "Sum.elim (1 : α → γ) (Pi.mulSingle i c) = Pi.mulSingle (Sum.inr i) c",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I) (a a' : α → γ)  (b b' : β → γ) [DecidableEq α]  [DecidableEq β]  [One γ]  (i : β)  (c : γ) : Sum.elim (1 : α → γ) (Pi.mulSingle i c) = Pi.mulSingle (Sum.inr i) c := by simp only [Pi.mulSingle]; sorry",
  "name": "elim_one_mulSingle",
  "kind": "theorem",
  "first-tactic": "simp only [Pi.mulSingle]",
  "core-prompt":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I) (a a' : α → γ)  (b b' : β → γ) [DecidableEq α]  [DecidableEq β]  [One γ]  (i : β)  (c : γ) : Sum.elim (1 : α → γ) (Pi.mulSingle i c) = Pi.mulSingle (Sum.inr i) c",
  "args":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I) (a a' : α → γ)  (b b' : β → γ) [DecidableEq α]  [DecidableEq β]  [One γ]  (i : β)  (c : γ)"},
 {"type": "Sum.elim (a * a') (b * b') = Sum.elim a b * Sum.elim a' b'",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I) (a a' : α → γ)  (b b' : β → γ) [Mul γ] : Sum.elim (a * a') (b * b') = Sum.elim a b * Sum.elim a' b' := by ext x; sorry",
  "name": "elim_mul_mul",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I) (a a' : α → γ)  (b b' : β → γ) [Mul γ] : Sum.elim (a * a') (b * b') = Sum.elim a b * Sum.elim a' b'",
  "args":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I) (a a' : α → γ)  (b b' : β → γ) [Mul γ]"},
 {"type": "Sum.elim (a / a') (b / b') = Sum.elim a b / Sum.elim a' b'",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I) (a a' : α → γ)  (b b' : β → γ) [Div γ] : Sum.elim (a / a') (b / b') = Sum.elim a b / Sum.elim a' b' := by ext x; sorry",
  "name": "elim_div_div",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I) (a a' : α → γ)  (b b' : β → γ) [Div γ] : Sum.elim (a / a') (b / b') = Sum.elim a b / Sum.elim a' b'",
  "args":
  "{I : Type u}  -- The indexing type {α β γ : Type _}  -- The families of types already equipped with instances {f : I → Type v₁}  {g : I → Type v₂}  {h : I → Type v₃} (x y : ∀ i, f i)  (i : I) (a a' : α → γ)  (b b' : β → γ) [Div γ]"},
 {"type": "toLex x < toLex (update x i a) ↔ x i < a",
  "tactic-prompt":
  "theorem {ι : Type _}  {β : ι → Type _}  (r : ι → ι → Prop)  (s : ∀ {i}, β i → β i → Prop)  [LinearOrder ι]  [IsWellOrder ι (· < ·)]  [∀ i, PartialOrder (β i)]  {x y : ∀ i, β i}  {i : ι}    {a : β i} : toLex x < toLex (update x i a) ↔ x i < a := by refine' ⟨_, fun h => toLex_strictMono <| lt_update_self_iff.2 h⟩; sorry",
  "name": "lt_toLex_update_self_iff",
  "kind": "theorem",
  "first-tactic":
  "refine' ⟨_, fun h => toLex_strictMono <| lt_update_self_iff.2 h⟩",
  "core-prompt":
  "{ι : Type _}  {β : ι → Type _}  (r : ι → ι → Prop)  (s : ∀ {i}, β i → β i → Prop)  [LinearOrder ι]  [IsWellOrder ι (· < ·)]  [∀ i, PartialOrder (β i)]  {x y : ∀ i, β i}  {i : ι}    {a : β i} : toLex x < toLex (update x i a) ↔ x i < a",
  "args":
  "{ι : Type _}  {β : ι → Type _}  (r : ι → ι → Prop)  (s : ∀ {i}, β i → β i → Prop)  [LinearOrder ι]  [IsWellOrder ι (· < ·)]  [∀ i, PartialOrder (β i)]  {x y : ∀ i, β i}  {i : ι}    {a : β i}"},
 {"type": "toLex (update x i a) < toLex x ↔ a < x i",
  "tactic-prompt":
  "theorem {ι : Type _}  {β : ι → Type _}  (r : ι → ι → Prop)  (s : ∀ {i}, β i → β i → Prop)  [LinearOrder ι]  [IsWellOrder ι (· < ·)]  [∀ i, PartialOrder (β i)]  {x y : ∀ i, β i}  {i : ι}    {a : β i} : toLex (update x i a) < toLex x ↔ a < x i := by refine' ⟨_, fun h => toLex_strictMono <| update_lt_self_iff.2 h⟩; sorry",
  "name": "toLex_update_lt_self_iff",
  "kind": "theorem",
  "first-tactic":
  "refine' ⟨_, fun h => toLex_strictMono <| update_lt_self_iff.2 h⟩",
  "core-prompt":
  "{ι : Type _}  {β : ι → Type _}  (r : ι → ι → Prop)  (s : ∀ {i}, β i → β i → Prop)  [LinearOrder ι]  [IsWellOrder ι (· < ·)]  [∀ i, PartialOrder (β i)]  {x y : ∀ i, β i}  {i : ι}    {a : β i} : toLex (update x i a) < toLex x ↔ a < x i",
  "args":
  "{ι : Type _}  {β : ι → Type _}  (r : ι → ι → Prop)  (s : ∀ {i}, β i → β i → Prop)  [LinearOrder ι]  [IsWellOrder ι (· < ·)]  [∀ i, PartialOrder (β i)]  {x y : ∀ i, β i}  {i : ι}    {a : β i}"},
 {"type": "toLex x ≤ toLex (update x i a) ↔ x i ≤ a",
  "tactic-prompt":
  "theorem {ι : Type _}  {β : ι → Type _}  (r : ι → ι → Prop)  (s : ∀ {i}, β i → β i → Prop)  [LinearOrder ι]  [IsWellOrder ι (· < ·)]  [∀ i, PartialOrder (β i)]  {x y : ∀ i, β i}  {i : ι}    {a : β i} : toLex x ≤ toLex (update x i a) ↔ x i ≤ a := by simp_rw [le_iff_lt_or_eq]; sorry",
  "name": "le_toLex_update_self_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [le_iff_lt_or_eq]",
  "core-prompt":
  "{ι : Type _}  {β : ι → Type _}  (r : ι → ι → Prop)  (s : ∀ {i}, β i → β i → Prop)  [LinearOrder ι]  [IsWellOrder ι (· < ·)]  [∀ i, PartialOrder (β i)]  {x y : ∀ i, β i}  {i : ι}    {a : β i} : toLex x ≤ toLex (update x i a) ↔ x i ≤ a",
  "args":
  "{ι : Type _}  {β : ι → Type _}  (r : ι → ι → Prop)  (s : ∀ {i}, β i → β i → Prop)  [LinearOrder ι]  [IsWellOrder ι (· < ·)]  [∀ i, PartialOrder (β i)]  {x y : ∀ i, β i}  {i : ι}    {a : β i}"},
 {"type": "toLex (update x i a) ≤ toLex x ↔ a ≤ x i",
  "tactic-prompt":
  "theorem {ι : Type _}  {β : ι → Type _}  (r : ι → ι → Prop)  (s : ∀ {i}, β i → β i → Prop)  [LinearOrder ι]  [IsWellOrder ι (· < ·)]  [∀ i, PartialOrder (β i)]  {x y : ∀ i, β i}  {i : ι}    {a : β i} : toLex (update x i a) ≤ toLex x ↔ a ≤ x i := by simp_rw [le_iff_lt_or_eq]; sorry",
  "name": "toLex_update_le_self_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [le_iff_lt_or_eq]",
  "core-prompt":
  "{ι : Type _}  {β : ι → Type _}  (r : ι → ι → Prop)  (s : ∀ {i}, β i → β i → Prop)  [LinearOrder ι]  [IsWellOrder ι (· < ·)]  [∀ i, PartialOrder (β i)]  {x y : ∀ i, β i}  {i : ι}    {a : β i} : toLex (update x i a) ≤ toLex x ↔ a ≤ x i",
  "args":
  "{ι : Type _}  {β : ι → Type _}  (r : ι → ι → Prop)  (s : ∀ {i}, β i → β i → Prop)  [LinearOrder ι]  [IsWellOrder ι (· < ·)]  [∀ i, PartialOrder (β i)]  {x y : ∀ i, β i}  {i : ι}    {a : β i}"},
 {"type": "inv (inv r) = r",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. : inv (inv r) = r := by ext (x y); sorry",
  "name": "inv_inv",
  "kind": "theorem",
  "first-tactic": "ext (x y)",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. : inv (inv r) = r",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems."},
 {"type": "r.inv.codom = r.dom",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. : r.inv.codom = r.dom := by ext (x y); sorry",
  "name": "codom_inv",
  "kind": "theorem",
  "first-tactic": "ext (x y)",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. : r.inv.codom = r.dom",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems."},
 {"type": "r.inv.dom = r.codom",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. : r.inv.dom = r.codom := by ext (x y); sorry",
  "name": "dom_inv",
  "kind": "theorem",
  "first-tactic": "ext (x y)",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. : r.inv.dom = r.codom",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems."},
 {"type": "(r • s) • t = r • (s • t)",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (r : Rel α β)  (s : Rel β γ)  (t : Rel γ δ) : (r • s) • t = r • (s • t) := by unfold comp; sorry",
  "name": "comp_assoc",
  "kind": "theorem",
  "first-tactic": "unfold comp",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (r : Rel α β)  (s : Rel β γ)  (t : Rel γ δ) : (r • s) • t = r • (s • t)",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (r : Rel α β)  (s : Rel β γ)  (t : Rel γ δ)"},
 {"type": "r • @Eq β = r",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (r : Rel α β) : r • @Eq β = r := by unfold comp; sorry",
  "name": "comp_right_id",
  "kind": "theorem",
  "first-tactic": "unfold comp",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (r : Rel α β) : r • @Eq β = r",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (r : Rel α β)"},
 {"type": "@Eq α • r = r",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (r : Rel α β) : @Eq α • r = r := by unfold comp; sorry",
  "name": "comp_left_id",
  "kind": "theorem",
  "first-tactic": "unfold comp",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (r : Rel α β) : @Eq α • r = r",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (r : Rel α β)"},
 {"type": "inv (@Eq α) = @Eq α",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. : inv (@Eq α) = @Eq α := by ext (x y); sorry",
  "name": "inv_id",
  "kind": "theorem",
  "first-tactic": "ext (x y)",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. : inv (@Eq α) = @Eq α",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems."},
 {"type": "inv (r • s) = inv s • inv r",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (r : Rel α β)  (s : Rel β γ) : inv (r • s) = inv s • inv r := by ext (x z); sorry",
  "name": "inv_comp",
  "kind": "theorem",
  "first-tactic": "ext (x z)",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (r : Rel α β)  (s : Rel β γ) : inv (r • s) = inv s • inv r",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (r : Rel α β)  (s : Rel β γ)"},
 {"type": "image (@Eq α) s = s",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Set α) : image (@Eq α) s = s := by ext x; sorry",
  "name": "image_id",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Set α) : image (@Eq α) s = s",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Set α)"},
 {"type": "image (r • s) t = image s (image r t)",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Rel β γ)  (t : Set α) : image (r • s) t = image s (image r t) := by ext z; sorry",
  "name": "image_comp",
  "kind": "theorem",
  "first-tactic": "ext z",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Rel β γ)  (t : Set α) : image (r • s) t = image s (image r t)",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Rel β γ)  (t : Set α)"},
 {"type": "r.image Set.univ = r.codom",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. : r.image Set.univ = r.codom := by ext y; sorry",
  "name": "image_univ",
  "kind": "theorem",
  "first-tactic": "ext y",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. : r.image Set.univ = r.codom",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems."},
 {"type": "preimage (@Eq α) s = s",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Set α) : preimage (@Eq α) s = s := by simp only [preimage]; sorry",
  "name": "preimage_id",
  "kind": "theorem",
  "first-tactic": "simp only [preimage]",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Set α) : preimage (@Eq α) s = s",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Set α)"},
 {"type": "preimage (r • s) t = preimage r (preimage s t)",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Rel β γ)  (t : Set γ) : preimage (r • s) t = preimage r (preimage s t) := by simp only [preimage]; sorry",
  "name": "preimage_comp",
  "kind": "theorem",
  "first-tactic": "simp only [preimage]",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Rel β γ)  (t : Set γ) : preimage (r • s) t = preimage r (preimage s t)",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Rel β γ)  (t : Set γ)"},
 {"type": "r.preimage Set.univ = r.dom",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. : r.preimage Set.univ = r.dom := by rw [preimage]; sorry",
  "name": "preimage_univ",
  "kind": "theorem",
  "first-tactic": "rw [preimage]",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. : r.preimage Set.univ = r.dom",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems."},
 {"type": "core (@Eq α) s = s",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Set α) : core (@Eq α) s = s := by simp [core]; sorry",
  "name": "core_id",
  "kind": "theorem",
  "first-tactic": "simp [core]",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Set α) : core (@Eq α) s = s",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Set α)"},
 {"type": "core (r • s) t = core r (core s t)",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Rel β γ)  (t : Set γ) : core (r • s) t = core r (core s t) := by ext x; sorry",
  "name": "core_comp",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Rel β γ)  (t : Set γ) : core (r • s) t = core r (core s t)",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (s : Rel β γ)  (t : Set γ)"},
 {"type": "f '' s = (Function.graph f).image s",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (f : α → β)  (s : Set α) : f '' s = (Function.graph f).image s := by simp [Set.image]; sorry",
  "name": "image_eq",
  "kind": "theorem",
  "first-tactic": "simp [Set.image]",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (f : α → β)  (s : Set α) : f '' s = (Function.graph f).image s",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (f : α → β)  (s : Set α)"},
 {"type": "f ⁻¹' s = (Function.graph f).preimage s",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (f : α → β)  (s : Set β) : f ⁻¹' s = (Function.graph f).preimage s := by simp [Set.preimage]; sorry",
  "name": "preimage_eq",
  "kind": "theorem",
  "first-tactic": "simp [Set.preimage]",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (f : α → β)  (s : Set β) : f ⁻¹' s = (Function.graph f).preimage s",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (f : α → β)  (s : Set β)"},
 {"type": "f ⁻¹' s = (Function.graph f).core s",
  "tactic-prompt":
  "theorem {α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (f : α → β)  (s : Set β) : f ⁻¹' s = (Function.graph f).core s := by simp [Set.preimage]; sorry",
  "name": "preimage_eq_core",
  "kind": "theorem",
  "first-tactic": "simp [Set.preimage]",
  "core-prompt":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (f : α → β)  (s : Set β) : f ⁻¹' s = (Function.graph f).core s",
  "args":
  "{α β γ : Type _} (r : Rel α β)  -- Porting note: required for later theorems. (f : α → β)  (s : Set β)"},
 {"type": "⟦x⟧ = y ↔ x ≈ Quotient.out y",
  "tactic-prompt":
  "theorem {α : Sort _}  {β : Sort _} {ra : α → α → Prop}  {rb : β → β → Prop}  {φ : Quot ra → Quot rb → Sort _}  -- mathport name: mk {γ : Sort _}  {r : α → α → Prop}  {s : β → β → Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : γ → γ → Prop} [sa : Setoid α]  [sb : Setoid β] {φ : Quotient sa → Quotient sb → Sort _} {γ : Sort _}  [sc : Setoid γ] [s : Setoid α]  {x : α}  {y : Quotient s} : ⟦x⟧ = y ↔ x ≈ Quotient.out y := by refine' Iff.trans _ Quotient.eq; sorry",
  "name": "Quotient.mk_eq_iff_out",
  "kind": "theorem",
  "first-tactic": "refine' Iff.trans _ Quotient.eq",
  "core-prompt":
  "{α : Sort _}  {β : Sort _} {ra : α → α → Prop}  {rb : β → β → Prop}  {φ : Quot ra → Quot rb → Sort _}  -- mathport name: mk {γ : Sort _}  {r : α → α → Prop}  {s : β → β → Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : γ → γ → Prop} [sa : Setoid α]  [sb : Setoid β] {φ : Quotient sa → Quotient sb → Sort _} {γ : Sort _}  [sc : Setoid γ] [s : Setoid α]  {x : α}  {y : Quotient s} : ⟦x⟧ = y ↔ x ≈ Quotient.out y",
  "args":
  "{α : Sort _}  {β : Sort _} {ra : α → α → Prop}  {rb : β → β → Prop}  {φ : Quot ra → Quot rb → Sort _}  -- mathport name: mk {γ : Sort _}  {r : α → α → Prop}  {s : β → β → Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : γ → γ → Prop} [sa : Setoid α]  [sb : Setoid β] {φ : Quotient sa → Quotient sb → Sort _} {γ : Sort _}  [sc : Setoid γ] [s : Setoid α]  {x : α}  {y : Quotient s}"},
 {"type": "x = ⟦y⟧ ↔ Quotient.out x ≈ y",
  "tactic-prompt":
  "theorem {α : Sort _}  {β : Sort _} {ra : α → α → Prop}  {rb : β → β → Prop}  {φ : Quot ra → Quot rb → Sort _}  -- mathport name: mk {γ : Sort _}  {r : α → α → Prop}  {s : β → β → Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : γ → γ → Prop} [sa : Setoid α]  [sb : Setoid β] {φ : Quotient sa → Quotient sb → Sort _} {γ : Sort _}  [sc : Setoid γ] [s : Setoid α]  {x : Quotient s}  {y : α} : x = ⟦y⟧ ↔ Quotient.out x ≈ y := by refine' Iff.trans _ Quotient.eq; sorry",
  "name": "Quotient.eq_mk_iff_out",
  "kind": "theorem",
  "first-tactic": "refine' Iff.trans _ Quotient.eq",
  "core-prompt":
  "{α : Sort _}  {β : Sort _} {ra : α → α → Prop}  {rb : β → β → Prop}  {φ : Quot ra → Quot rb → Sort _}  -- mathport name: mk {γ : Sort _}  {r : α → α → Prop}  {s : β → β → Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : γ → γ → Prop} [sa : Setoid α]  [sb : Setoid β] {φ : Quotient sa → Quotient sb → Sort _} {γ : Sort _}  [sc : Setoid γ] [s : Setoid α]  {x : Quotient s}  {y : α} : x = ⟦y⟧ ↔ Quotient.out x ≈ y",
  "args":
  "{α : Sort _}  {β : Sort _} {ra : α → α → Prop}  {rb : β → β → Prop}  {φ : Quot ra → Quot rb → Sort _}  -- mathport name: mk {γ : Sort _}  {r : α → α → Prop}  {s : β → β → Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : γ → γ → Prop} [sa : Setoid α]  [sb : Setoid β] {φ : Quotient sa → Quotient sb → Sort _} {γ : Sort _}  [sc : Setoid γ] [s : Setoid α]  {x : Quotient s}  {y : α}"},
 {"type": "x.out ≈ y.out ↔ x = y",
  "tactic-prompt":
  "theorem {α : Sort _}  {β : Sort _} {ra : α → α → Prop}  {rb : β → β → Prop}  {φ : Quot ra → Quot rb → Sort _}  -- mathport name: mk {γ : Sort _}  {r : α → α → Prop}  {s : β → β → Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : γ → γ → Prop} [sa : Setoid α]  [sb : Setoid β] {φ : Quotient sa → Quotient sb → Sort _} {γ : Sort _}  [sc : Setoid γ] {s : Setoid α}  {x y : Quotient s} : x.out ≈ y.out ↔ x = y := by rw [← Quotient.eq_mk_iff_out]; sorry",
  "name": "Quotient.out_equiv_out",
  "kind": "theorem",
  "first-tactic": "rw [← Quotient.eq_mk_iff_out]",
  "core-prompt":
  "{α : Sort _}  {β : Sort _} {ra : α → α → Prop}  {rb : β → β → Prop}  {φ : Quot ra → Quot rb → Sort _}  -- mathport name: mk {γ : Sort _}  {r : α → α → Prop}  {s : β → β → Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : γ → γ → Prop} [sa : Setoid α]  [sb : Setoid β] {φ : Quotient sa → Quotient sb → Sort _} {γ : Sort _}  [sc : Setoid γ] {s : Setoid α}  {x y : Quotient s} : x.out ≈ y.out ↔ x = y",
  "args":
  "{α : Sort _}  {β : Sort _} {ra : α → α → Prop}  {rb : β → β → Prop}  {φ : Quot ra → Quot rb → Sort _}  -- mathport name: mk {γ : Sort _}  {r : α → α → Prop}  {s : β → β → Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : γ → γ → Prop} [sa : Setoid α]  [sb : Setoid β] {φ : Quotient sa → Quotient sb → Sort _} {γ : Sort _}  [sc : Setoid γ] {s : Setoid α}  {x y : Quotient s}"},
 {"type": "p f",
  "tactic-prompt":
  "theorem {α : Sort _}  {β : Sort _} {ra : α → α → Prop}  {rb : β → β → Prop}  {φ : Quot ra → Quot rb → Sort _}  -- mathport name: mk {γ : Sort _}  {r : α → α → Prop}  {s : β → β → Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : γ → γ → Prop} [sa : Setoid α]  [sb : Setoid β] {φ : Quotient sa → Quotient sb → Sort _} {γ : Sort _}  [sc : Setoid γ]  {ι : Type _}  {α : ι → Sort _}  [s : ∀ i, Setoid (α i)]      {p : (∀ i, Quotient (s i)) → Prop}  (f : ∀ i, Quotient (s i))      (h : ∀ a : ∀ i, α i, p fun i ↦ ⟦a i⟧) : p f := by rw [← (funext fun i ↦ Quotient.out_eq (f i) : (fun i ↦ ⟦(f i).out⟧) = f)]; sorry",
  "name": "Quotient.induction_on_pi",
  "kind": "theorem",
  "first-tactic":
  "rw [← (funext fun i ↦ Quotient.out_eq (f i) : (fun i ↦ ⟦(f i).out⟧) = f)]",
  "core-prompt":
  "{α : Sort _}  {β : Sort _} {ra : α → α → Prop}  {rb : β → β → Prop}  {φ : Quot ra → Quot rb → Sort _}  -- mathport name: mk {γ : Sort _}  {r : α → α → Prop}  {s : β → β → Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : γ → γ → Prop} [sa : Setoid α]  [sb : Setoid β] {φ : Quotient sa → Quotient sb → Sort _} {γ : Sort _}  [sc : Setoid γ]  {ι : Type _}  {α : ι → Sort _}  [s : ∀ i, Setoid (α i)]      {p : (∀ i, Quotient (s i)) → Prop}  (f : ∀ i, Quotient (s i))      (h : ∀ a : ∀ i, α i, p fun i ↦ ⟦a i⟧) : p f",
  "args":
  "{α : Sort _}  {β : Sort _} {ra : α → α → Prop}  {rb : β → β → Prop}  {φ : Quot ra → Quot rb → Sort _}  -- mathport name: mk {γ : Sort _}  {r : α → α → Prop}  {s : β → β → Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : γ → γ → Prop} [sa : Setoid α]  [sb : Setoid β] {φ : Quotient sa → Quotient sb → Sort _} {γ : Sort _}  [sc : Setoid γ]  {ι : Type _}  {α : ι → Sort _}  [s : ∀ i, Setoid (α i)]      {p : (∀ i, Quotient (s i)) → Prop}  (f : ∀ i, Quotient (s i))      (h : ∀ a : ∀ i, α i, p fun i ↦ ⟦a i⟧)"},
 {"type": "DecidableEq (Vector α n)",
  "tactic-prompt":
  "instance {α : Type u}  {β : Type v}  {φ : Type w} {n : ℕ} [DecidableEq α] : DecidableEq (Vector α n) := by unfold Vector; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "unfold Vector",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {φ : Type w} {n : ℕ} [DecidableEq α] : DecidableEq (Vector α n)",
  "args": "{α : Type u}  {β : Type v}  {φ : Type w} {n : ℕ} [DecidableEq α]"},
 {"type": "toList (cons a v) = a :: toList v",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {φ : Type w} {n : ℕ} (a : α)  (v : Vector α n) : toList (cons a v) = a :: toList v := by cases v; sorry",
  "name": "toList_cons",
  "kind": "theorem",
  "first-tactic": "cases v",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {φ : Type w} {n : ℕ} (a : α)  (v : Vector α n) : toList (cons a v) = a :: toList v",
  "args":
  "{α : Type u}  {β : Type v}  {φ : Type w} {n : ℕ} (a : α)  (v : Vector α n)"},
 {"type": "toList (append v w) = toList v ++ toList w",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {φ : Type w} {n : ℕ} {n m : ℕ}  (v : Vector α n)  (w : Vector α m) : toList (append v w) = toList v ++ toList w := by cases v; sorry",
  "name": "toList_append",
  "kind": "theorem",
  "first-tactic": "cases v",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {φ : Type w} {n : ℕ} {n m : ℕ}  (v : Vector α n)  (w : Vector α m) : toList (append v w) = toList v ++ toList w",
  "args":
  "{α : Type u}  {β : Type v}  {φ : Type w} {n : ℕ} {n m : ℕ}  (v : Vector α n)  (w : Vector α m)"},
 {"type": "toList (drop n v) = List.drop n (toList v)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {φ : Type w} {n : ℕ} {n m : ℕ}  (v : Vector α m) : toList (drop n v) = List.drop n (toList v) := by cases v; sorry",
  "name": "toList_drop",
  "kind": "theorem",
  "first-tactic": "cases v",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {φ : Type w} {n : ℕ} {n m : ℕ}  (v : Vector α m) : toList (drop n v) = List.drop n (toList v)",
  "args":
  "{α : Type u}  {β : Type v}  {φ : Type w} {n : ℕ} {n m : ℕ}  (v : Vector α m)"},
 {"type": "toList (take n v) = List.take n (toList v)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {φ : Type w} {n : ℕ} {n m : ℕ}  (v : Vector α m) : toList (take n v) = List.take n (toList v) := by cases v; sorry",
  "name": "toList_take",
  "kind": "theorem",
  "first-tactic": "cases v",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {φ : Type w} {n : ℕ} {n m : ℕ}  (v : Vector α m) : toList (take n v) = List.take n (toList v)",
  "args":
  "{α : Type u}  {β : Type v}  {φ : Type w} {n : ℕ} {n m : ℕ}  (v : Vector α m)"},
 {"type": "(replicate n c).length = n",
  "tactic-prompt":
  "lemma (n : ℕ)  (c : Char) : (replicate n c).length = n := by simp only [String.length]; sorry",
  "name": "length_replicate",
  "kind": "lemma",
  "first-tactic": "simp only [String.length]",
  "core-prompt": "(n : ℕ)  (c : Char) : (replicate n c).length = n",
  "args": "(n : ℕ)  (c : Char)"},
 {"type": "(String.mk l).length = l.length",
  "tactic-prompt":
  "lemma (l : List Char) : (String.mk l).length = l.length := by simp only [String.length]; sorry",
  "name": "length_eq_list_length",
  "kind": "lemma",
  "first-tactic": "simp only [String.length]",
  "core-prompt": "(l : List Char) : (String.mk l).length = l.length",
  "args": "(l : List Char)"},
 {"type": "Function.Injective (Prod.mk a : β → α × β)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {α β : Type _}  (a : α) : Function.Injective (Prod.mk a : β → α × β) := by intro b₁ b₂ h; sorry",
  "name": "mk.inj_left",
  "kind": "theorem",
  "first-tactic": "intro b₁ b₂ h",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {α β : Type _}  (a : α) : Function.Injective (Prod.mk a : β → α × β)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {α β : Type _}  (a : α)"},
 {"type": "Function.Injective (fun a ↦ Prod.mk a b : α → α × β)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {α β : Type _}  (b : β) : Function.Injective (fun a ↦ Prod.mk a b : α → α × β) := by intro b₁ b₂ h; sorry",
  "name": "mk.inj_right",
  "kind": "theorem",
  "first-tactic": "intro b₁ b₂ h",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {α β : Type _}  (b : β) : Function.Injective (fun a ↦ Prod.mk a b : α → α × β)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {α β : Type _}  (b : β)"},
 {"type": "p = q ↔ p.1 = q.1 ∧ p.2 = q.2",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {p q : α × β} : p = q ↔ p.1 = q.1 ∧ p.2 = q.2 := by rw [← @mk.eta _ _ p]; sorry",
  "name": "ext_iff",
  "kind": "theorem",
  "first-tactic": "rw [← @mk.eta _ _ p]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {p q : α × β} : p = q ↔ p.1 = q.1 ∧ p.2 = q.2",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {p q : α × β}"},
 {"type": "@Monotone _ _ _ (Prod.Lex.preorder α β) (toLex : α × β → α ×ₗ β)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  [PartialOrder α]  [Preorder β]  -- porting note: type class search sees right through the type synonrm for `α ×ₗ β` and uses the -- `Preorder` structure for `α × β` instead -- This is hopefully the same problems as in https://github.com/leanprover/lean4/issues/1891 -- and will be fixed in nightly-2022-11-30 : @Monotone _ _ _ (Prod.Lex.preorder α β) (toLex : α × β → α ×ₗ β) := by rintro ⟨a₁, b₁⟩ ⟨a₂, b₂⟩ ⟨ha, hb⟩; sorry",
  "name": "toLex_mono",
  "kind": "theorem",
  "first-tactic": "rintro ⟨a₁, b₁⟩ ⟨a₂, b₂⟩ ⟨ha, hb⟩",
  "core-prompt":
  "{α β γ : Type _}  [PartialOrder α]  [Preorder β]  -- porting note: type class search sees right through the type synonrm for `α ×ₗ β` and uses the -- `Preorder` structure for `α × β` instead -- This is hopefully the same problems as in https://github.com/leanprover/lean4/issues/1891 -- and will be fixed in nightly-2022-11-30 : @Monotone _ _ _ (Prod.Lex.preorder α β) (toLex : α × β → α ×ₗ β)",
  "args":
  "{α β γ : Type _}  [PartialOrder α]  [Preorder β]  -- porting note: type class search sees right through the type synonrm for `α ×ₗ β` and uses the -- `Preorder` structure for `α × β` instead -- This is hopefully the same problems as in https://github.com/leanprover/lean4/issues/1891 -- and will be fixed in nightly-2022-11-30"},
 {"type": "@StrictMono _ _ _ (Prod.Lex.preorder α β) (toLex : α × β → α ×ₗ β)",
  "tactic-prompt":
  "theorem {α β γ : Type _}  [PartialOrder α]  [Preorder β]  -- porting note: type class search sees right through the type synonrm for `α ×ₗ β` and uses the -- `Preorder` structure for `α × β` instead -- This is hopefully the same problems as in https://github.com/leanprover/lean4/issues/1891 -- and will be fixed in nightly-2022-11-30 : @StrictMono _ _ _ (Prod.Lex.preorder α β) (toLex : α × β → α ×ₗ β) := by rintro ⟨a₁, b₁⟩ ⟨a₂, b₂⟩ h; sorry",
  "name": "toLex_strictMono",
  "kind": "theorem",
  "first-tactic": "rintro ⟨a₁, b₁⟩ ⟨a₂, b₂⟩ h",
  "core-prompt":
  "{α β γ : Type _}  [PartialOrder α]  [Preorder β]  -- porting note: type class search sees right through the type synonrm for `α ×ₗ β` and uses the -- `Preorder` structure for `α × β` instead -- This is hopefully the same problems as in https://github.com/leanprover/lean4/issues/1891 -- and will be fixed in nightly-2022-11-30 : @StrictMono _ _ _ (Prod.Lex.preorder α β) (toLex : α × β → α ×ₗ β)",
  "args":
  "{α β γ : Type _}  [PartialOrder α]  [Preorder β]  -- porting note: type class search sees right through the type synonrm for `α ×ₗ β` and uses the -- `Preorder` structure for `α × β` instead -- This is hopefully the same problems as in https://github.com/leanprover/lean4/issues/1891 -- and will be fixed in nightly-2022-11-30"},
 {"type": "0 < UInt8.size",
  "tactic-prompt": "lemma  : 0 < UInt8.size := by decide; sorry",
  "name": "UInt8.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt8.size",
  "args": ""},
 {"type": "0 < UInt16.size",
  "tactic-prompt": "lemma  : 0 < UInt16.size := by decide; sorry",
  "name": "UInt16.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt16.size",
  "args": ""},
 {"type": "0 < UInt32.size",
  "tactic-prompt": "lemma  : 0 < UInt32.size := by decide; sorry",
  "name": "UInt32.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt32.size",
  "args": ""},
 {"type": "0 < UInt64.size",
  "tactic-prompt": "lemma  : 0 < UInt64.size := by decide; sorry",
  "name": "UInt64.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt64.size",
  "args": ""},
 {"type": "Nat.isValidChar (UInt32.ofNat n).1",
  "tactic-prompt":
  "theorem (n : Nat)  (h : n < size) : Nat.isValidChar (UInt32.ofNat n).1 := by rw [UInt32.val_eq_of_lt]; sorry",
  "name": "toChar_aux",
  "kind": "theorem",
  "first-tactic": "rw [UInt32.val_eq_of_lt]",
  "core-prompt":
  "(n : Nat)  (h : n < size) : Nat.isValidChar (UInt32.ofNat n).1",
  "args": "(n : Nat)  (h : n < size)"},
 {"type": "0 < c.utf8Size",
  "tactic-prompt":
  "theorem (c : Char) : 0 < c.utf8Size := by simp only [utf8Size]; sorry",
  "name": "Char.utf8Size_pos",
  "kind": "theorem",
  "first-tactic": "simp only [utf8Size]",
  "core-prompt": "(c : Char) : 0 < c.utf8Size",
  "args": "(c : Char)"},
 {"type": "Char.ofNat c.toNat = c",
  "tactic-prompt":
  "theorem {c : Char}  (h : isValidCharNat c.toNat) : Char.ofNat c.toNat = c := by rw [Char.ofNat]; sorry",
  "name": "Char.ofNat_toNat",
  "kind": "theorem",
  "first-tactic": "rw [Char.ofNat]",
  "core-prompt":
  "{c : Char}  (h : isValidCharNat c.toNat) : Char.ofNat c.toNat = c",
  "args": "{c : Char}  (h : isValidCharNat c.toNat)"},
 {"type": "(decide ¬p) = !(decide p)",
  "tactic-prompt":
  "theorem (p : Prop)  [Decidable p] : (decide ¬p) = !(decide p) := by by_cases p; sorry",
  "name": "decide_not",
  "kind": "theorem",
  "first-tactic": "by_cases p",
  "core-prompt": "(p : Prop)  [Decidable p] : (decide ¬p) = !(decide p)",
  "args": "(p : Prop)  [Decidable p]"},
 {"type": "decide (p ∧ q) = (p && q)",
  "tactic-prompt":
  "theorem (p q : Prop)  [Decidable p]  [Decidable q] : decide (p ∧ q) = (p && q) := by by_cases p; sorry",
  "name": "decide_and",
  "kind": "theorem",
  "first-tactic": "by_cases p",
  "core-prompt":
  "(p q : Prop)  [Decidable p]  [Decidable q] : decide (p ∧ q) = (p && q)",
  "args": "(p q : Prop)  [Decidable p]  [Decidable q]"},
 {"type": "decide (p ∨ q) = (p || q)",
  "tactic-prompt":
  "theorem (p q : Prop)  [Decidable p]  [Decidable q] : decide (p ∨ q) = (p || q) := by by_cases p; sorry",
  "name": "decide_or",
  "kind": "theorem",
  "first-tactic": "by_cases p",
  "core-prompt":
  "(p q : Prop)  [Decidable p]  [Decidable q] : decide (p ∨ q) = (p || q)",
  "args": "(p q : Prop)  [Decidable p]  [Decidable q]"},
 {"type": "b = false ∨ b = true",
  "tactic-prompt":
  "theorem (b : Bool) : b = false ∨ b = true := by cases b; sorry",
  "name": "dichotomy",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Bool) : b = false ∨ b = true",
  "args": "(b : Bool)"},
 {"type": "∀ {a b : Bool}, (a ↔ b) ↔ a = b",
  "tactic-prompt":
  "theorem  : ∀ {a b : Bool}, (a ↔ b) ↔ a = b := by decide; sorry",
  "name": "coe_bool_iff",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ {a b : Bool}, (a ↔ b) ↔ a = b",
  "args": ""},
 {"type": "∀ {a : Bool}, a ≠ false → a = true",
  "tactic-prompt":
  "theorem  : ∀ {a : Bool}, a ≠ false → a = true := by decide; sorry",
  "name": "eq_true_of_ne_false",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ {a : Bool}, a ≠ false → a = true",
  "args": ""},
 {"type": "∀ {a : Bool}, a ≠ true → a = false",
  "tactic-prompt":
  "theorem  : ∀ {a : Bool}, a ≠ true → a = false := by decide; sorry",
  "name": "eq_false_of_ne_true",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ {a : Bool}, a ≠ true → a = false",
  "args": ""},
 {"type": "∀ a b, (a || b) = (b || a)",
  "tactic-prompt": "theorem  : ∀ a b, (a || b) = (b || a) := by decide; sorry",
  "name": "or_comm",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ a b, (a || b) = (b || a)",
  "args": ""},
 {"type": "∀ a b c, (a || (b || c)) = (b || (a || c))",
  "tactic-prompt":
  "theorem  : ∀ a b c, (a || (b || c)) = (b || (a || c)) := by decide; sorry",
  "name": "or_left_comm",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ a b c, (a || (b || c)) = (b || (a || c))",
  "args": ""},
 {"type": "a || b",
  "tactic-prompt":
  "theorem {a b : Bool}  (H : a) : a || b := by simp [H]; sorry",
  "name": "or_inl",
  "kind": "theorem",
  "first-tactic": "simp [H]",
  "core-prompt": "{a b : Bool}  (H : a) : a || b",
  "args": "{a b : Bool}  (H : a)"},
 {"type": "a || b",
  "tactic-prompt":
  "theorem {a b : Bool}  (H : b) : a || b := by cases a; sorry",
  "name": "or_inr",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "{a b : Bool}  (H : b) : a || b",
  "args": "{a b : Bool}  (H : b)"},
 {"type": "∀ a b, (a && b) = (b && a)",
  "tactic-prompt": "theorem  : ∀ a b, (a && b) = (b && a) := by decide; sorry",
  "name": "and_comm",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ a b, (a && b) = (b && a)",
  "args": ""},
 {"type": "∀ a b c, (a && (b && c)) = (b && (a && c))",
  "tactic-prompt":
  "theorem  : ∀ a b c, (a && (b && c)) = (b && (a && c)) := by decide; sorry",
  "name": "and_left_comm",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ a b c, (a && (b && c)) = (b && (a && c))",
  "args": ""},
 {"type": "∀ {a b : Bool}, a && b → a",
  "tactic-prompt": "theorem  : ∀ {a b : Bool}, a && b → a := by decide; sorry",
  "name": "and_elim_left",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ {a b : Bool}, a && b → a",
  "args": ""},
 {"type": "∀ {a b : Bool}, a → b → a && b",
  "tactic-prompt":
  "theorem  : ∀ {a b : Bool}, a → b → a && b := by decide; sorry",
  "name": "and_intro",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ {a b : Bool}, a → b → a && b",
  "args": ""},
 {"type": "∀ {a b : Bool}, a && b → b",
  "tactic-prompt": "theorem  : ∀ {a b : Bool}, a && b → b := by decide; sorry",
  "name": "and_elim_right",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ {a b : Bool}, a && b → b",
  "args": ""},
 {"type": "(a && (b || c)) = (a && b || a && c)",
  "tactic-prompt":
  "theorem (a b c : Bool) : (a && (b || c)) = (a && b || a && c) := by cases a; sorry",
  "name": "and_or_distrib_left",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : Bool) : (a && (b || c)) = (a && b || a && c)",
  "args": "(a b c : Bool)"},
 {"type": "((a || b) && c) = (a && c || b && c)",
  "tactic-prompt":
  "theorem (a b c : Bool) : ((a || b) && c) = (a && c || b && c) := by cases a; sorry",
  "name": "and_or_distrib_right",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : Bool) : ((a || b) && c) = (a && c || b && c)",
  "args": "(a b c : Bool)"},
 {"type": "(a || b && c) = ((a || b) && (a || c))",
  "tactic-prompt":
  "theorem (a b c : Bool) : (a || b && c) = ((a || b) && (a || c)) := by cases a; sorry",
  "name": "or_and_distrib_left",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : Bool) : (a || b && c) = ((a || b) && (a || c))",
  "args": "(a b c : Bool)"},
 {"type": "(a && b || c) = ((a || c) && (b || c))",
  "tactic-prompt":
  "theorem (a b c : Bool) : (a && b || c) = ((a || c) && (b || c)) := by cases a; sorry",
  "name": "or_and_distrib_right",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : Bool) : (a && b || c) = ((a || c) && (b || c))",
  "args": "(a b c : Bool)"},
 {"type": "∀ {a b : Bool}, a = !b ↔ a ≠ b",
  "tactic-prompt":
  "lemma  : ∀ {a b : Bool}, a = !b ↔ a ≠ b := by decide; sorry",
  "name": "eq_not_iff",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : ∀ {a b : Bool}, a = !b ↔ a ≠ b",
  "args": ""},
 {"type": "∀ {a b : Bool}, !a = b ↔ a ≠ b",
  "tactic-prompt":
  "lemma  : ∀ {a b : Bool}, !a = b ↔ a ≠ b := by decide; sorry",
  "name": "not_eq_iff",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : ∀ {a b : Bool}, !a = b ↔ a ≠ b",
  "args": ""},
 {"type": "∀ {a b : Bool}, ¬a = !b ↔ a = b",
  "tactic-prompt":
  "theorem  : ∀ {a b : Bool}, ¬a = !b ↔ a = b := by decide; sorry",
  "name": "not_eq_not",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ {a b : Bool}, ¬a = !b ↔ a = b",
  "args": ""},
 {"type": "∀ {a b : Bool}, ¬(!a) = b ↔ a = b",
  "tactic-prompt":
  "theorem  : ∀ {a b : Bool}, ¬(!a) = b ↔ a = b := by decide; sorry",
  "name": "not_not_eq",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ {a b : Bool}, ¬(!a) = b ↔ a = b",
  "args": ""},
 {"type": "∀ b : Bool, !b ≠ b",
  "tactic-prompt": "lemma  : ∀ b : Bool, !b ≠ b := by decide; sorry",
  "name": "not_ne_self",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : ∀ b : Bool, !b ≠ b",
  "args": ""},
 {"type": "∀ b : Bool, b ≠ !b",
  "tactic-prompt": "lemma  : ∀ b : Bool, b ≠ !b := by decide; sorry",
  "name": "self_ne_not",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : ∀ b : Bool, b ≠ !b",
  "args": ""},
 {"type": "∀ a b, a = b ∨ a = !b",
  "tactic-prompt": "lemma  : ∀ a b, a = b ∨ a = !b := by decide; sorry",
  "name": "eq_or_eq_not",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : ∀ a b, a = b ∨ a = !b",
  "args": ""},
 {"type": "∀ {b : Bool}, !b ↔ ¬b",
  "tactic-prompt": "theorem  : ∀ {b : Bool}, !b ↔ ¬b := by simp; sorry",
  "name": "not_iff_not",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : ∀ {b : Bool}, !b ↔ ¬b",
  "args": ""},
 {"type": "!a = false → a = true",
  "tactic-prompt":
  "theorem {a : Bool} : !a = false → a = true := by cases a; sorry",
  "name": "eq_true_of_not_eq_false'",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "{a : Bool} : !a = false → a = true",
  "args": "{a : Bool}"},
 {"type": "!a = true → a = false",
  "tactic-prompt":
  "theorem {a : Bool} : !a = true → a = false := by cases a; sorry",
  "name": "eq_false_of_not_eq_true'",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "{a : Bool} : !a = true → a = false",
  "args": "{a : Bool}"},
 {"type": "∀ x, (x && !x) = false",
  "tactic-prompt": "theorem  : ∀ x, (x && !x) = false := by decide; sorry",
  "name": "and_not_self",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x, (x && !x) = false",
  "args": ""},
 {"type": "∀ x, (!x && x) = false",
  "tactic-prompt": "theorem  : ∀ x, (!x && x) = false := by decide; sorry",
  "name": "not_and_self",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x, (!x && x) = false",
  "args": ""},
 {"type": "∀ x, (x || !x) = true",
  "tactic-prompt": "theorem  : ∀ x, (x || !x) = true := by decide; sorry",
  "name": "or_not_self",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x, (x || !x) = true",
  "args": ""},
 {"type": "∀ x, (!x || x) = true",
  "tactic-prompt": "theorem  : ∀ x, (!x || x) = true := by decide; sorry",
  "name": "not_or_self",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x, (!x || x) = true",
  "args": ""},
 {"type": "∀ a b, xor a b = xor b a",
  "tactic-prompt": "theorem  : ∀ a b, xor a b = xor b a := by decide; sorry",
  "name": "xor_comm",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ a b, xor a b = xor b a",
  "args": ""},
 {"type": "∀ a b c, xor (xor a b) c = xor a (xor b c)",
  "tactic-prompt":
  "theorem  : ∀ a b c, xor (xor a b) c = xor a (xor b c) := by decide; sorry",
  "name": "xor_assoc",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ a b c, xor (xor a b) c = xor a (xor b c)",
  "args": ""},
 {"type": "∀ a b c, xor a (xor b c) = xor b (xor a c)",
  "tactic-prompt":
  "theorem  : ∀ a b c, xor a (xor b c) = xor b (xor a c) := by decide; sorry",
  "name": "xor_left_comm",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ a b c, xor a (xor b c) = xor b (xor a c)",
  "args": ""},
 {"type": "∀ a, xor (!a) a = true",
  "tactic-prompt": "theorem  : ∀ a, xor (!a) a = true := by decide; sorry",
  "name": "xor_not_left",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ a, xor (!a) a = true",
  "args": ""},
 {"type": "∀ a, xor a (!a) = true",
  "tactic-prompt": "theorem  : ∀ a, xor a (!a) = true := by decide; sorry",
  "name": "xor_not_right",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ a, xor a (!a) = true",
  "args": ""},
 {"type": "∀ a b, xor (!a) (!b) = xor a b",
  "tactic-prompt":
  "theorem  : ∀ a b, xor (!a) (!b) = xor a b := by decide; sorry",
  "name": "xor_not_not",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ a b, xor (!a) (!b) = xor a b",
  "args": ""},
 {"type": "∀ a, xor false a = a",
  "tactic-prompt": "theorem  : ∀ a, xor false a = a := by decide; sorry",
  "name": "xor_false_left",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ a, xor false a = a",
  "args": ""},
 {"type": "∀ a, xor a false = a",
  "tactic-prompt": "theorem  : ∀ a, xor a false = a := by decide; sorry",
  "name": "xor_false_right",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ a, xor a false = a",
  "args": ""},
 {"type": "(a && xor b c) = xor (a && b) (a && c)",
  "tactic-prompt":
  "theorem (a b c : Bool) : (a && xor b c) = xor (a && b) (a && c) := by cases a; sorry",
  "name": "and_xor_distrib_left",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : Bool) : (a && xor b c) = xor (a && b) (a && c)",
  "args": "(a b c : Bool)"},
 {"type": "(xor a b && c) = xor (a && c) (b && c)",
  "tactic-prompt":
  "theorem (a b c : Bool) : (xor a b && c) = xor (a && c) (b && c) := by cases a; sorry",
  "name": "and_xor_distrib_right",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : Bool) : (xor a b && c) = xor (a && c) (b && c)",
  "args": "(a b c : Bool)"},
 {"type": "∀ {x y : Bool}, xor x y = true ↔ x ≠ y",
  "tactic-prompt":
  "theorem  : ∀ {x y : Bool}, xor x y = true ↔ x ≠ y := by decide; sorry",
  "name": "xor_iff_ne",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ {x y : Bool}, xor x y = true ↔ x ≠ y",
  "args": ""},
 {"type": "∀ a b : Bool, !(a && b) = (!a || !b)",
  "tactic-prompt":
  "theorem  : ∀ a b : Bool, !(a && b) = (!a || !b) := by decide; sorry",
  "name": "not_and",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ a b : Bool, !(a && b) = (!a || !b)",
  "args": ""},
 {"type": "∀ a b : Bool, !(a || b) = (!a && !b)",
  "tactic-prompt":
  "theorem  : ∀ a b : Bool, !(a || b) = (!a && !b) := by decide; sorry",
  "name": "not_or",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ a b : Bool, !(a || b) = (!a && !b)",
  "args": ""},
 {"type": "∀ {a b : Bool}, !a = !b → a = b",
  "tactic-prompt":
  "theorem  : ∀ {a b : Bool}, !a = !b → a = b := by decide; sorry",
  "name": "not_inj",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ {a b : Bool}, !a = !b → a = b",
  "args": ""},
 {"type": "∀ {x y : Bool}, x < y ↔ x = false ∧ y = true",
  "tactic-prompt":
  "theorem  : ∀ {x y : Bool}, x < y ↔ x = false ∧ y = true := by decide; sorry",
  "name": "lt_iff",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ {x y : Bool}, x < y ↔ x = false ∧ y = true",
  "args": ""},
 {"type": "∀ {x y : Bool}, x ≤ y ↔ x → y",
  "tactic-prompt":
  "theorem  : ∀ {x y : Bool}, x ≤ y ↔ x → y := by decide; sorry",
  "name": "le_iff_imp",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ {x y : Bool}, x ≤ y ↔ x → y",
  "args": ""},
 {"type": "∀ x y : Bool, (x && y) ≤ x",
  "tactic-prompt": "theorem  : ∀ x y : Bool, (x && y) ≤ x := by decide; sorry",
  "name": "and_le_left",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x y : Bool, (x && y) ≤ x",
  "args": ""},
 {"type": "∀ x y : Bool, (x && y) ≤ y",
  "tactic-prompt": "theorem  : ∀ x y : Bool, (x && y) ≤ y := by decide; sorry",
  "name": "and_le_right",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x y : Bool, (x && y) ≤ y",
  "args": ""},
 {"type": "∀ {x y z : Bool}, x ≤ y → x ≤ z → x ≤ (y && z)",
  "tactic-prompt":
  "theorem  : ∀ {x y z : Bool}, x ≤ y → x ≤ z → x ≤ (y && z) := by decide; sorry",
  "name": "le_and",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ {x y z : Bool}, x ≤ y → x ≤ z → x ≤ (y && z)",
  "args": ""},
 {"type": "∀ x y : Bool, x ≤ (x || y)",
  "tactic-prompt": "theorem  : ∀ x y : Bool, x ≤ (x || y) := by decide; sorry",
  "name": "left_le_or",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x y : Bool, x ≤ (x || y)",
  "args": ""},
 {"type": "∀ x y : Bool, y ≤ (x || y)",
  "tactic-prompt": "theorem  : ∀ x y : Bool, y ≤ (x || y) := by decide; sorry",
  "name": "right_le_or",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x y : Bool, y ≤ (x || y)",
  "args": ""},
 {"type": "∀ {x y z}, x ≤ z → y ≤ z → (x || y) ≤ z",
  "tactic-prompt":
  "theorem  : ∀ {x y z}, x ≤ z → y ≤ z → (x || y) ≤ z := by decide; sorry",
  "name": "or_le",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ {x y z}, x ≤ z → y ≤ z → (x || y) ≤ z",
  "args": ""},
 {"type": "ofNat n ≤ ofNat m",
  "tactic-prompt":
  "theorem {n m : Nat}  (h : n ≤ m) : ofNat n ≤ ofNat m := by simp only [ofNat]; sorry",
  "name": "ofNat_le_ofNat",
  "kind": "theorem",
  "first-tactic": "simp only [ofNat]",
  "core-prompt": "{n m : Nat}  (h : n ≤ m) : ofNat n ≤ ofNat m",
  "args": "{n m : Nat}  (h : n ≤ m)"},
 {"type": "toNat b₀ ≤ toNat b₁",
  "tactic-prompt":
  "theorem {b₀ b₁ : Bool}  (h : b₀ ≤ b₁) : toNat b₀ ≤ toNat b₁ := by cases h; sorry",
  "name": "toNat_le_toNat",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt": "{b₀ b₁ : Bool}  (h : b₀ ≤ b₁) : toNat b₀ ≤ toNat b₁",
  "args": "{b₀ b₁ : Bool}  (h : b₀ ≤ b₁)"},
 {"type": "ofNat (toNat b) = b",
  "tactic-prompt":
  "theorem (b : Bool) : ofNat (toNat b) = b := by cases b; sorry",
  "name": "ofNat_toNat",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Bool) : ofNat (toNat b) = b",
  "args": "(b : Bool)"},
 {"type": "f (f (f x)) = f x",
  "tactic-prompt":
  "theorem (f : Bool → Bool)  (x : Bool) : f (f (f x)) = f x := by cases x; sorry",
  "name": "apply_apply_apply",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": "(f : Bool → Bool)  (x : Bool) : f (f (f x)) = f x",
  "args": "(f : Bool → Bool)  (x : Bool)"},
 {"type": "range f = {f false, f true}",
  "tactic-prompt":
  "theorem {α : Type _}  (f : Bool → α) : range f = {f false, f true} := by rw [← image_univ]; sorry",
  "name": "range_eq",
  "kind": "theorem",
  "first-tactic": "rw [← image_univ]",
  "core-prompt": "{α : Type _}  (f : Bool → α) : range f = {f false, f true}",
  "args": "{α : Type _}  (f : Bool → α)"},
 {"type": "Decidable (Chain R a l)",
  "tactic-prompt":
  "instance {α β γ δ ε ζ : Type _}  {m : Type v → Type w}  [Monad m]  [DecidableRel R]  (a : α)  (l : List α) : Decidable (Chain R a l) := by induction l generalizing a with\n  | nil => simp only [List.Chain.nil]; infer_instance\n  | cons a as ih => haveI := ih; simp only [List.chain_cons]; infer_instance; sorry",
  "name": "decidableChain",
  "kind": "instance",
  "first-tactic":
  "induction l generalizing a with\n  | nil => simp only [List.Chain.nil]; infer_instance\n  | cons a as ih => haveI := ih; simp only [List.chain_cons]; infer_instance",
  "core-prompt":
  "{α β γ δ ε ζ : Type _}  {m : Type v → Type w}  [Monad m]  [DecidableRel R]  (a : α)  (l : List α) : Decidable (Chain R a l)",
  "args":
  "{α β γ δ ε ζ : Type _}  {m : Type v → Type w}  [Monad m]  [DecidableRel R]  (a : α)  (l : List α)"},
 {"type": "Decidable (Chain' R l)",
  "tactic-prompt":
  "instance {α β γ δ ε ζ : Type _}  {m : Type v → Type w}  [Monad m]  [DecidableRel R]  (l : List α) : Decidable (Chain' R l) := by cases l; sorry",
  "name": "decidableChain'",
  "kind": "instance",
  "first-tactic": "cases l",
  "core-prompt":
  "{α β γ δ ε ζ : Type _}  {m : Type v → Type w}  [Monad m]  [DecidableRel R]  (l : List α) : Decidable (Chain' R l)",
  "args":
  "{α β γ δ ε ζ : Type _}  {m : Type v → Type w}  [Monad m]  [DecidableRel R]  (l : List α)"},
 {"type": "(get k [] : α) = default",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] {k : ℕ} : (get k [] : α) = default := by cases k; sorry",
  "name": "get_nil",
  "kind": "theorem",
  "first-tactic": "cases k",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] {k : ℕ} : (get k [] : α) = default",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] {k : ℕ}"},
 {"type": "f default = default → get n (as.map f) = f (get n as)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] {f : α → β}  {n : ℕ}  {as : List α} : f default = default → get n (as.map f) = f (get n as) := by intro h1; sorry",
  "name": "get_map'",
  "kind": "theorem",
  "first-tactic": "intro h1",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] {f : α → β}  {n : ℕ}  {as : List α} : f default = default → get n (as.map f) = f (get n as)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] {f : α → β}  {n : ℕ}  {as : List α}"},
 {"type": "p default → (∀ x ∈ as, p x) → ∀ n, p (get n as)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] {as : List α}  {p : α → Prop} : p default → (∀ x ∈ as, p x) → ∀ n, p (get n as) := by intro h1 h2 n; sorry",
  "name": "forall_val_of_forall_mem",
  "kind": "theorem",
  "first-tactic": "intro h1 h2 n",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] {as : List α}  {p : α → Prop} : p default → (∀ x ∈ as, p x) → ∀ n, p (get n as)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] {as : List α}  {p : α → Prop}"},
 {"type": "as1 = as2 → Equiv as1 as2",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] : as1 = as2 → Equiv as1 as2 := by intro h1; sorry",
  "name": "equiv_of_eq",
  "kind": "theorem",
  "first-tactic": "intro h1",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] : as1 = as2 → Equiv as1 as2",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β]"},
 {"type": "@get α ⟨0⟩ k (neg as) = -@get α ⟨0⟩ k as",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [AddGroup α]  {k : ℕ}  {as : List α} : @get α ⟨0⟩ k (neg as) = -@get α ⟨0⟩ k as := by unfold neg; sorry",
  "name": "get_neg",
  "kind": "theorem",
  "first-tactic": "unfold neg",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [AddGroup α]  {k : ℕ}  {as : List α} : @get α ⟨0⟩ k (neg as) = -@get α ⟨0⟩ k as",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [AddGroup α]  {k : ℕ}  {as : List α}"},
 {"type": "(neg as).length = as.length",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Neg α]  (as : List α) : (neg as).length = as.length := by simp only [neg]; sorry",
  "name": "length_neg",
  "kind": "theorem",
  "first-tactic": "simp only [neg]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Neg α]  (as : List α) : (neg as).length = as.length",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Neg α]  (as : List α)"},
 {"type": "@get α ⟨0⟩ k (add xs ys) = @get α ⟨0⟩ k xs + @get α ⟨0⟩ k ys",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type u}  [AddMonoid α]  {k : ℕ}  {xs ys : List α} : @get α ⟨0⟩ k (add xs ys) = @get α ⟨0⟩ k xs + @get α ⟨0⟩ k ys := by apply @get_pointwise _ _ _ ⟨0⟩ ⟨0⟩ ⟨0⟩; sorry",
  "name": "get_add",
  "kind": "theorem",
  "first-tactic": "apply @get_pointwise _ _ _ ⟨0⟩ ⟨0⟩ ⟨0⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type u}  [AddMonoid α]  {k : ℕ}  {xs ys : List α} : @get α ⟨0⟩ k (add xs ys) = @get α ⟨0⟩ k xs + @get α ⟨0⟩ k ys",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type u}  [AddMonoid α]  {k : ℕ}  {xs ys : List α}"},
 {"type": "add [] as = as",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type u}  [AddMonoid α]  (as : List α) : add [] as = as := by rw [add]; sorry",
  "name": "nil_add",
  "kind": "theorem",
  "first-tactic": "rw [add]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type u}  [AddMonoid α]  (as : List α) : add [] as = as",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type u}  [AddMonoid α]  (as : List α)"},
 {"type": "add as [] = as",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type u}  [AddMonoid α]  (as : List α) : add as [] = as := by rw [add]; sorry",
  "name": "add_nil",
  "kind": "theorem",
  "first-tactic": "rw [add]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type u}  [AddMonoid α]  (as : List α) : add as [] = as",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type u}  [AddMonoid α]  (as : List α)"},
 {"type": "add (as.map f) (as.map g) = as.map fun x ↦ f x + g x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type u}  [AddMonoid α]  (f g : α → α)  {as : List α} : add (as.map f) (as.map g) = as.map fun x ↦ f x + g x := by apply @eq_of_equiv _ (⟨0⟩ : Inhabited α); sorry",
  "name": "map_add_map",
  "kind": "theorem",
  "first-tactic": "apply @eq_of_equiv _ (⟨0⟩ : Inhabited α)",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type u}  [AddMonoid α]  (f g : α → α)  {as : List α} : add (as.map f) (as.map g) = as.map fun x ↦ f x + g x",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type u}  [AddMonoid α]  (f g : α → α)  {as : List α}"},
 {"type": "@get α ⟨0⟩ k (sub xs ys) = @get α ⟨0⟩ k xs - @get α ⟨0⟩ k ys",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type u}  [AddGroup α]  {k : ℕ}  {xs ys : List α} : @get α ⟨0⟩ k (sub xs ys) = @get α ⟨0⟩ k xs - @get α ⟨0⟩ k ys := by apply @get_pointwise _ _ _ ⟨0⟩ ⟨0⟩ ⟨0⟩; sorry",
  "name": "get_sub",
  "kind": "theorem",
  "first-tactic": "apply @get_pointwise _ _ _ ⟨0⟩ ⟨0⟩ ⟨0⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type u}  [AddGroup α]  {k : ℕ}  {xs ys : List α} : @get α ⟨0⟩ k (sub xs ys) = @get α ⟨0⟩ k xs - @get α ⟨0⟩ k ys",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type u}  [AddGroup α]  {k : ℕ}  {xs ys : List α}"},
 {"type": "sub [] as = neg as",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type}  [AddGroup α]  (as : List α) : sub [] as = neg as := by rw [sub]; sorry",
  "name": "nil_sub",
  "kind": "theorem",
  "first-tactic": "rw [sub]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type}  [AddGroup α]  (as : List α) : sub [] as = neg as",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type}  [AddGroup α]  (as : List α)"},
 {"type": "sub as [] = as",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type}  [AddGroup α]  (as : List α) : sub as [] = as := by rw [sub]; sorry",
  "name": "sub_nil",
  "kind": "theorem",
  "first-tactic": "rw [sub]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type}  [AddGroup α]  (as : List α) : sub as [] = as",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w} {a : α} {as as1 as2 as3 : List α} [Inhabited α]  [Inhabited β] [Inhabited α]  [Inhabited β]  -- pointwise {α : Type}  [AddGroup α]  (as : List α)"},
 {"type": "m ∈ range n ↔ m < n",
  "tactic-prompt":
  "theorem {m n : ℕ} : m ∈ range n ↔ m < n := by simp only [range_eq_range']; sorry",
  "name": "mem_range",
  "kind": "theorem",
  "first-tactic": "simp only [range_eq_range']",
  "core-prompt": "{m n : ℕ} : m ∈ range n ↔ m < n",
  "args": "{m n : ℕ}"},
 {"type": "Nodup (range n)",
  "tactic-prompt":
  "theorem (n : ℕ) : Nodup (range n) := by simp only [range_eq_range']; sorry",
  "name": "nodup_range",
  "kind": "theorem",
  "first-tactic": "simp only [range_eq_range']",
  "core-prompt": "(n : ℕ) : Nodup (range n)",
  "args": "(n : ℕ)"},
 {"type": "∃ s t : List α, l = s ++ a :: t",
  "tactic-prompt":
  "theorem {a : α}  {l : List α}  (h : a ∈ l) : ∃ s t : List α, l = s ++ a :: t := by induction l; sorry",
  "name": "mem_split",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : α}  {l : List α}  (h : a ∈ l) : ∃ s t : List α, l = s ++ a :: t",
  "args": "{a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "Injective (List.length : List α → ℕ) ↔ Subsingleton α",
  "tactic-prompt":
  "lemma  : Injective (List.length : List α → ℕ) ↔ Subsingleton α := by constructor; sorry",
  "name": "length_injective_iff",
  "kind": "lemma",
  "first-tactic": "constructor",
  "core-prompt": " : Injective (List.length : List α → ℕ) ↔ Subsingleton α",
  "args": ""},
 {"type": "i = j",
  "tactic-prompt":
  "theorem {α : Type u}  {xs : List α}  {i j : ℕ}    (h₀ : i < xs.length)    (h₁ : Nodup xs)    (h₂ : xs.get? i = xs.get? j) : i = j := by induction xs generalizing i j with\n  | nil => cases h₀\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases h₁ with\n      | cons ha h₁ => exact ih (Nat.lt_of_succ_lt_succ h₀) h₁ h₂\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at h₂\n      cases h₁; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact ⟨_, h₂⟩; exact ⟨_ , h₂.symm⟩; sorry",
  "name": "get?_injective",
  "kind": "theorem",
  "first-tactic":
  "induction xs generalizing i j with\n  | nil => cases h₀\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases h₁ with\n      | cons ha h₁ => exact ih (Nat.lt_of_succ_lt_succ h₀) h₁ h₂\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at h₂\n      cases h₁; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact ⟨_, h₂⟩; exact ⟨_ , h₂.symm⟩",
  "core-prompt":
  "{α : Type u}  {xs : List α}  {i j : ℕ}    (h₀ : i < xs.length)    (h₁ : Nodup xs)    (h₂ : xs.get? i = xs.get? j) : i = j",
  "args":
  "{α : Type u}  {xs : List α}  {i j : ℕ}    (h₀ : i < xs.length)    (h₁ : Nodup xs)    (h₂ : xs.get? i = xs.get? j)"},
 {"type": "(x, y) ∈ product xs ys ↔ x ∈ xs ∧ y ∈ ys",
  "tactic-prompt":
  "theorem (xs : List α)  (ys : List β)  (x : α)  (y : β) : (x, y) ∈ product xs ys ↔ x ∈ xs ∧ y ∈ ys := by constructor; sorry",
  "name": "product_spec",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "(xs : List α)  (ys : List β)  (x : α)  (y : β) : (x, y) ∈ product xs ys ↔ x ∈ xs ∧ y ∈ ys",
  "args": "(xs : List α)  (ys : List β)  (x : α)  (y : β)"},
 {"type": "l.attach.map Subtype.val = l",
  "tactic-prompt":
  "theorem (l : List α) : l.attach.map Subtype.val = l := by rw [attach]; sorry",
  "name": "attach_map_val",
  "kind": "theorem",
  "first-tactic": "rw [attach]",
  "core-prompt": "(l : List α) : l.attach.map Subtype.val = l",
  "args": "(l : List α)"},
 {"type": "l₂ ~ l₁",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  (p : l₁ ~ l₂) : l₂ ~ l₁ := by induction p; sorry",
  "name": "Perm.symm",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{l₁ l₂ : List α}  (p : l₁ ~ l₂) : l₂ ~ l₁",
  "args": "{l₁ l₂ : List α}  (p : l₁ ~ l₂)"},
 {"type": "l₁ ⊆ l₂",
  "tactic-prompt":
  "theorem {α : Type u}  {l₁ l₂ : List α}  (p : l₁ ~ l₂) : l₁ ⊆ l₂ := by induction p; sorry",
  "name": "Perm.subset",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{α : Type u}  {l₁ l₂ : List α}  (p : l₁ ~ l₂) : l₁ ⊆ l₂",
  "args": "{α : Type u}  {l₁ l₂ : List α}  (p : l₁ ~ l₂)"},
 {"type": "l₁ ++ a :: r₁ ~ l₂ ++ a :: r₂ → l₁ ++ r₁ ~ l₂ ++ r₂",
  "tactic-prompt":
  "theorem {a : α}  {l₁ l₂ r₁ r₂ : List α} : l₁ ++ a :: r₁ ~ l₂ ++ a :: r₂ → l₁ ++ r₁ ~ l₂ ++ r₂ := by generalize e₁ : l₁ ++ a :: r₁ = s₁; sorry",
  "name": "perm_inv_core",
  "kind": "theorem",
  "first-tactic": "generalize e₁ : l₁ ++ a :: r₁ = s₁",
  "core-prompt":
  "{a : α}  {l₁ l₂ r₁ r₂ : List α} : l₁ ++ a :: r₁ ~ l₂ ++ a :: r₂ → l₁ ++ r₁ ~ l₂ ++ r₂",
  "args": "{a : α}  {l₁ l₂ r₁ r₂ : List α}"},
 {"type": "length l₁ = length l₂",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  (p : l₁ ~ l₂) : length l₁ = length l₂ := by induction p; sorry",
  "name": "Perm.length_eq",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{l₁ l₂ : List α}  (p : l₁ ~ l₂) : length l₁ = length l₂",
  "args": "{l₁ l₂ : List α}  (p : l₁ ~ l₂)"},
 {"type": "∀ {l₁ l₂ : List α}, l₁ ~ l₂ → (Pairwise R l₁ ↔ Pairwise R l₂)",
  "tactic-prompt":
  "theorem {R : α → α → Prop}  (S : Symmetric R) : ∀ {l₁ l₂ : List α}, l₁ ~ l₂ → (Pairwise R l₁ ↔ Pairwise R l₂) := by suffices ∀ {l₁ l₂}, l₁ ~ l₂ → Pairwise R l₁ → Pairwise R l₂ from\n    fun l₁ l₂ p ↦ ⟨this p, this p.symm⟩; sorry",
  "name": "Perm.pairwise_iff",
  "kind": "theorem",
  "first-tactic":
  "suffices ∀ {l₁ l₂}, l₁ ~ l₂ → Pairwise R l₁ → Pairwise R l₂ from\n    fun l₁ l₂ p ↦ ⟨this p, this p.symm⟩",
  "core-prompt":
  "{R : α → α → Prop}  (S : Symmetric R) : ∀ {l₁ l₂ : List α}, l₁ ~ l₂ → (Pairwise R l₁ ↔ Pairwise R l₂)",
  "args": "{R : α → α → Prop}  (S : Symmetric R)"},
 {"type": "Pairwise R (l₁ ++ l₂) ↔ Pairwise R (l₂ ++ l₁)",
  "tactic-prompt":
  "theorem {α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} (s : Symmetric R)  {l₁ l₂ : List α} : Pairwise R (l₁ ++ l₂) ↔ Pairwise R (l₂ ++ l₁) := by have : ∀ l₁ l₂ : List α, (∀ x : α, x ∈ l₁ → ∀ y : α, y ∈ l₂ → R x y) →\n    ∀ x : α, x ∈ l₂ → ∀ y : α, y ∈ l₁ → R x y := fun l₁ l₂ a x xm y ym ↦ s (a y ym x xm); sorry",
  "name": "pairwise_append_comm",
  "kind": "theorem",
  "first-tactic":
  "have : ∀ l₁ l₂ : List α, (∀ x : α, x ∈ l₁ → ∀ y : α, y ∈ l₂ → R x y) →\n    ∀ x : α, x ∈ l₂ → ∀ y : α, y ∈ l₁ → R x y := fun l₁ l₂ a x xm y ym ↦ s (a y ym x xm)",
  "core-prompt":
  "{α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} (s : Symmetric R)  {l₁ l₂ : List α} : Pairwise R (l₁ ++ l₂) ↔ Pairwise R (l₂ ++ l₁)",
  "args":
  "{α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} (s : Symmetric R)  {l₁ l₂ : List α}"},
 {"type": "Pairwise S l",
  "tactic-prompt":
  "theorem {α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} {S : α → α → Prop}  {l : List α}      (H : ∀ {a b}, a ∈ l → b ∈ l → R a b → S a b)  (p : Pairwise R l) : Pairwise S l := by induction p; sorry",
  "name": "Pairwise.imp_of_mem",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} {S : α → α → Prop}  {l : List α}      (H : ∀ {a b}, a ∈ l → b ∈ l → R a b → S a b)  (p : Pairwise R l) : Pairwise S l",
  "args":
  "{α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} {S : α → α → Prop}  {l : List α}      (H : ∀ {a b}, a ∈ l → b ∈ l → R a b → S a b)  (p : Pairwise R l)"},
 {"type": "b ∈ remove a as ↔ b ∈ as ∧ b ≠ a",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α} : b ∈ remove a as ↔ b ∈ as ∧ b ≠ a := by induction as; sorry",
  "name": "mem_remove_iff",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α} : b ∈ remove a as ↔ b ∈ as ∧ b ≠ a",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α}"},
 {"type": "b ∈ as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α}  (h : b ∈ remove a as) : b ∈ as := by rw [mem_remove_iff] at h; sorry",
  "name": "mem_of_mem_remove",
  "kind": "theorem",
  "first-tactic": "rw [mem_remove_iff] at h",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α}  (h : b ∈ remove a as) : b ∈ as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α}  (h : b ∈ remove a as)"},
 {"type": "card (a :: as) = card as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as) : card (a :: as) = card as := by simp [card]; sorry",
  "name": "card_cons_of_mem",
  "kind": "theorem",
  "first-tactic": "simp [card]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as) : card (a :: as) = card as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as)"},
 {"type": "card (a :: as) = card as + 1",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as) : card (a :: as) = card as + 1 := by simp [card]; sorry",
  "name": "card_cons_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp [card]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as) : card (a :: as) = card as + 1",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as)"},
 {"type": "card as ≤ card (a :: as)",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ (a : α)  (as : List α) : card as ≤ card (a :: as) := by cases Decidable.em (a ∈ as); sorry",
  "name": "card_le_card_cons",
  "kind": "theorem",
  "first-tactic": "cases Decidable.em (a ∈ as)",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ (a : α)  (as : List α) : card as ≤ card (a :: as)",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ (a : α)  (as : List α)"},
 {"type": "card (as.insert a) = card as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as) : card (as.insert a) = card as := by simp [h]; sorry",
  "name": "card_insert_of_mem",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as) : card (as.insert a) = card as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as)"},
 {"type": "card (as.insert a) = card as + 1",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as) : card (as.insert a) = card as + 1 := by simp [h]; sorry",
  "name": "card_insert_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as) : card (as.insert a) = card as + 1",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as)"},
 {"type": "card (as.map f) ≤ card as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ (f : α → β)  (as : List α) : card (as.map f) ≤ card as := by induction as; sorry",
  "name": "card_map_le",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ (f : α → β)  (as : List α) : card (as.map f) ≤ card as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ (f : α → β)  (as : List α)"},
 {"type": "inj_on f as →  card (as.map f) = card as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {f : α → β}  {as : List α} : inj_on f as →  card (as.map f) = card as := by induction as; sorry",
  "name": "card_map_eq_of_inj_on",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {f : α → β}  {as : List α} : inj_on f as →  card (as.map f) = card as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {f : α → β}  {as : List α}"},
 {"type": "card (as.union bs) = card as + card bs",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {as bs : List α}  (h : Disjoint as bs) : card (as.union bs) = card as + card bs := by rw [card_eq_of_equiv (union_equiv_append as bs)]; sorry",
  "name": "card_union_disjoint",
  "kind": "theorem",
  "first-tactic": "rw [card_eq_of_equiv (union_equiv_append as bs)]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {as bs : List α}  (h : Disjoint as bs) : card (as.union bs) = card as + card bs",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {as bs : List α}  (h : Disjoint as bs)"},
 {"type": "Lex (· ≠ ·) l₁ l₂ ↔ l₁ ≠ l₂",
  "tactic-prompt":
  "theorem {α : Type u} {l₁ l₂ : List α}  (H : length l₁ ≤ length l₂) : Lex (· ≠ ·) l₁ l₂ ↔ l₁ ≠ l₂ := by classical\n  exact Decidable.List.Lex.ne_iff H; sorry",
  "name": "ne_iff",
  "kind": "theorem",
  "first-tactic": "classical\n  exact Decidable.List.Lex.ne_iff H",
  "core-prompt":
  "{α : Type u} {l₁ l₂ : List α}  (H : length l₁ ≤ length l₂) : Lex (· ≠ ·) l₁ l₂ ↔ l₁ ≠ l₂",
  "args": "{α : Type u} {l₁ l₂ : List α}  (H : length l₁ ≤ length l₂)"},
 {"type": "Chain S b l",
  "tactic-prompt":
  "theorem {R S : α → α → Prop}  (HRS : ∀ ⦃a b⦄, R a b → S a b)  {a b : α}      (Hab : ∀ ⦃c⦄, R a c → S b c)  {l : List α}  (p : Chain R a l) : Chain S b l := by induction p generalizing b with\n  | nil => constructor\n  | cons r _ ih =>\n    constructor\n    · exact Hab r\n    · exact ih (@HRS _); sorry",
  "name": "Chain.imp'",
  "kind": "theorem",
  "first-tactic":
  "induction p generalizing b with\n  | nil => constructor\n  | cons r _ ih =>\n    constructor\n    · exact Hab r\n    · exact ih (@HRS _)",
  "core-prompt":
  "{R S : α → α → Prop}  (HRS : ∀ ⦃a b⦄, R a b → S a b)  {a b : α}      (Hab : ∀ ⦃c⦄, R a c → S b c)  {l : List α}  (p : Chain R a l) : Chain S b l",
  "args":
  "{R S : α → α → Prop}  (HRS : ∀ ⦃a b⦄, R a b → S a b)  {a b : α}      (Hab : ∀ ⦃c⦄, R a c → S b c)  {l : List α}  (p : Chain R a l)"},
 {"type": "Chain R a l",
  "tactic-prompt":
  "theorem (p : Pairwise R (a :: l)) : Chain R a l := by rcases pairwise_cons.1 p with ⟨r,p'⟩; sorry",
  "name": "Pairwise.chain",
  "kind": "theorem",
  "first-tactic": "rcases pairwise_cons.1 p with ⟨r,p'⟩",
  "core-prompt": "(p : Pairwise R (a :: l)) : Chain R a l",
  "args": "(p : Pairwise R (a :: l))"},
 {"type": "a ∈ some b ↔ b = a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {α : Type _}  {a b : α} : a ∈ some b ↔ b = a := by simp; sorry",
  "name": "mem_some_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {α : Type _}  {a b : α} : a ∈ some b ↔ b = a",
  "args":
  "{α : Type _}  {β : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {α : Type _}  {a b : α}"},
 {"type": "a ∈ toList o ↔ a ∈ o",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {a : α}  {o : Option α} : a ∈ toList o ↔ a ∈ o := by cases o; sorry",
  "name": "mem_toList",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{α : Type _}  {β : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {a : α}  {o : Option α} : a ∈ toList o ↔ a ∈ o",
  "args":
  "{α : Type _}  {β : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {a : α}  {o : Option α}"},
 {"type": "map₂ f a b = f <$> a <*> b",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {α β γ : Type _}  (f : α → β → γ)  (a : Option α)  (b : Option β) : map₂ f a b = f <$> a <*> b := by cases a; sorry",
  "name": "map₂_def",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {α β γ : Type _}  (f : α → β → γ)  (a : Option α)  (b : Option β) : map₂ f a b = f <$> a <*> b",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {α β γ : Type _}  (f : α → β → γ)  (a : Option α)  (b : Option β)"},
 {"type": "map₂ f a none = none",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → β → γ)  (a : Option α) : map₂ f a none = none := by cases a; sorry",
  "name": "map₂_none_right",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → β → γ)  (a : Option α) : map₂ f a none = none",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → β → γ)  (a : Option α)"},
 {"type": "map₂ f a b = a.map fun a => f a b",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → β → γ)  (a : Option α)  (b : β) : map₂ f a b = a.map fun a => f a b := by cases a; sorry",
  "name": "map₂_coe_right",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → β → γ)  (a : Option α)  (b : β) : map₂ f a b = a.map fun a => f a b",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → β → γ)  (a : Option α)  (b : β)"},
 {"type": "c ∈ map₂ f a b ↔ ∃ a' b', a' ∈ a ∧ b' ∈ b ∧ f a' b' = c",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {c : γ} : c ∈ map₂ f a b ↔ ∃ a' b', a' ∈ a ∧ b' ∈ b ∧ f a' b' = c := by simp [map₂]; sorry",
  "name": "mem_map₂_iff",
  "kind": "theorem",
  "first-tactic": "simp [map₂]",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {c : γ} : c ∈ map₂ f a b ↔ ∃ a' b', a' ∈ a ∧ b' ∈ b ∧ f a' b' = c",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {c : γ}"},
 {"type": "map₂ f a b = none ↔ a = none ∨ b = none",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} : map₂ f a b = none ↔ a = none ∨ b = none := by cases a; sorry",
  "name": "map₂_eq_none_iff",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} : map₂ f a b = none ↔ a = none ∨ b = none",
  "args": "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ}"},
 {"type": "map₂ f a b = map₂ (fun a b => f b a) b a",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → β → γ)  (a : Option α)  (b : Option β) : map₂ f a b = map₂ (fun a b => f b a) b a := by cases a; sorry",
  "name": "map₂_swap",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → β → γ)  (a : Option α)  (b : Option β) : map₂ f a b = map₂ (fun a b => f b a) b a",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → β → γ)  (a : Option α)  (b : Option β)"},
 {"type": "(map₂ f a b).map g = map₂ (fun a b => g (f a b)) a b",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → β → γ)  (g : γ → δ) : (map₂ f a b).map g = map₂ (fun a b => g (f a b)) a b := by cases a; sorry",
  "name": "map_map₂",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → β → γ)  (g : γ → δ) : (map₂ f a b).map g = map₂ (fun a b => g (f a b)) a b",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → β → γ)  (g : γ → δ)"},
 {"type": "map₂ f (a.map g) b = map₂ (fun a b => f (g a) b) a b",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : γ → β → δ)  (g : α → γ) : map₂ f (a.map g) b = map₂ (fun a b => f (g a) b) a b := by cases a; sorry",
  "name": "map₂_map_left",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : γ → β → δ)  (g : α → γ) : map₂ f (a.map g) b = map₂ (fun a b => f (g a) b) a b",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : γ → β → δ)  (g : α → γ)"},
 {"type": "map₂ f a (b.map g) = map₂ (fun a b => f a (g b)) a b",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → γ → δ)  (g : β → γ) : map₂ f a (b.map g) = map₂ (fun a b => f a (g b)) a b := by cases b; sorry",
  "name": "map₂_map_right",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → γ → δ)  (g : β → γ) : map₂ f a (b.map g) = map₂ (fun a b => f a (g b)) a b",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → γ → δ)  (g : β → γ)"},
 {"type": "x.map (uncurry f) = map₂ f (x.map Prod.fst) (x.map Prod.snd)",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → β → γ)  (x : Option (α × β)) : x.map (uncurry f) = map₂ f (x.map Prod.fst) (x.map Prod.snd) := by cases x; sorry",
  "name": "map_uncurry",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → β → γ)  (x : Option (α × β)) : x.map (uncurry f) = map₂ f (x.map Prod.fst) (x.map Prod.snd)",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} (f : α → β → γ)  (x : Option (α × β))"},
 {"type": "map₂ f (map₂ g a b) c = map₂ f' a (map₂ g' b c)",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : δ → γ → ε}  {g : α → β → δ}  {f' : α → ε' → ε}  {g' : β → γ → ε'}      (h_assoc : ∀ a b c, f (g a b) c = f' a (g' b c)) : map₂ f (map₂ g a b) c = map₂ f' a (map₂ g' b c) := by cases a; sorry",
  "name": "map₂_assoc",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : δ → γ → ε}  {g : α → β → δ}  {f' : α → ε' → ε}  {g' : β → γ → ε'}      (h_assoc : ∀ a b c, f (g a b) c = f' a (g' b c)) : map₂ f (map₂ g a b) c = map₂ f' a (map₂ g' b c)",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : δ → γ → ε}  {g : α → β → δ}  {f' : α → ε' → ε}  {g' : β → γ → ε'}      (h_assoc : ∀ a b c, f (g a b) c = f' a (g' b c))"},
 {"type": "map₂ f a b = map₂ g b a",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : β → α → γ}  (h_comm : ∀ a b, f a b = g b a) : map₂ f a b = map₂ g b a := by cases a; sorry",
  "name": "map₂_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : β → α → γ}  (h_comm : ∀ a b, f a b = g b a) : map₂ f a b = map₂ g b a",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : β → α → γ}  (h_comm : ∀ a b, f a b = g b a)"},
 {"type": "map₂ f a (map₂ g b c) = map₂ g' b (map₂ f' a c)",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : α → δ → ε}  {g : β → γ → δ}  {f' : α → γ → δ'}  {g' : β → δ' → ε}      (h_left_comm : ∀ a b c, f a (g b c) = g' b (f' a c)) : map₂ f a (map₂ g b c) = map₂ g' b (map₂ f' a c) := by cases a; sorry",
  "name": "map₂_left_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : α → δ → ε}  {g : β → γ → δ}  {f' : α → γ → δ'}  {g' : β → δ' → ε}      (h_left_comm : ∀ a b c, f a (g b c) = g' b (f' a c)) : map₂ f a (map₂ g b c) = map₂ g' b (map₂ f' a c)",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : α → δ → ε}  {g : β → γ → δ}  {f' : α → γ → δ'}  {g' : β → δ' → ε}      (h_left_comm : ∀ a b c, f a (g b c) = g' b (f' a c))"},
 {"type": "map₂ f (map₂ g a b) c = map₂ g' (map₂ f' a c) b",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : δ → γ → ε}  {g : α → β → δ}  {f' : α → γ → δ'}  {g' : δ' → β → ε}      (h_right_comm : ∀ a b c, f (g a b) c = g' (f' a c) b) : map₂ f (map₂ g a b) c = map₂ g' (map₂ f' a c) b := by cases a; sorry",
  "name": "map₂_right_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : δ → γ → ε}  {g : α → β → δ}  {f' : α → γ → δ'}  {g' : δ' → β → ε}      (h_right_comm : ∀ a b c, f (g a b) c = g' (f' a c) b) : map₂ f (map₂ g a b) c = map₂ g' (map₂ f' a c) b",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : δ → γ → ε}  {g : α → β → δ}  {f' : α → γ → δ'}  {g' : δ' → β → ε}      (h_right_comm : ∀ a b c, f (g a b) c = g' (f' a c) b)"},
 {"type": "(map₂ f a b).map g = map₂ f' (a.map g₁) (b.map g₂)",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : α' → β' → δ}  {g₁ : α → α'}  {g₂ : β → β'}      (h_distrib : ∀ a b, g (f a b) = f' (g₁ a) (g₂ b)) : (map₂ f a b).map g = map₂ f' (a.map g₁) (b.map g₂) := by cases a; sorry",
  "name": "map_map₂_distrib",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : α' → β' → δ}  {g₁ : α → α'}  {g₂ : β → β'}      (h_distrib : ∀ a b, g (f a b) = f' (g₁ a) (g₂ b)) : (map₂ f a b).map g = map₂ f' (a.map g₁) (b.map g₂)",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : α' → β' → δ}  {g₁ : α → α'}  {g₂ : β → β'}      (h_distrib : ∀ a b, g (f a b) = f' (g₁ a) (g₂ b))"},
 {"type": "(map₂ f a b).map g = map₂ f' (a.map g') b",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : α' → β → δ}  {g' : α → α'}      (h_distrib : ∀ a b, g (f a b) = f' (g' a) b) : (map₂ f a b).map g = map₂ f' (a.map g') b := by cases a; sorry",
  "name": "map_map₂_distrib_left",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : α' → β → δ}  {g' : α → α'}      (h_distrib : ∀ a b, g (f a b) = f' (g' a) b) : (map₂ f a b).map g = map₂ f' (a.map g') b",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : α' → β → δ}  {g' : α → α'}      (h_distrib : ∀ a b, g (f a b) = f' (g' a) b)"},
 {"type": "(map₂ f a b).map g = map₂ f' a (b.map g')",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : α → β' → δ}  {g' : β → β'}      (h_distrib : ∀ a b, g (f a b) = f' a (g' b)) : (map₂ f a b).map g = map₂ f' a (b.map g') := by cases a; sorry",
  "name": "map_map₂_distrib_right",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : α → β' → δ}  {g' : β → β'}      (h_distrib : ∀ a b, g (f a b) = f' a (g' b)) : (map₂ f a b).map g = map₂ f' a (b.map g')",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : α → β' → δ}  {g' : β → β'}      (h_distrib : ∀ a b, g (f a b) = f' a (g' b))"},
 {"type": "map₂ f (a.map g) b = (map₂ f' a b).map g'",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : α' → β → γ}  {g : α → α'}  {f' : α → β → δ}  {g' : δ → γ}      (h_left_comm : ∀ a b, f (g a) b = g' (f' a b)) : map₂ f (a.map g) b = (map₂ f' a b).map g' := by cases a; sorry",
  "name": "map₂_map_left_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : α' → β → γ}  {g : α → α'}  {f' : α → β → δ}  {g' : δ → γ}      (h_left_comm : ∀ a b, f (g a) b = g' (f' a b)) : map₂ f (a.map g) b = (map₂ f' a b).map g'",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : α' → β → γ}  {g : α → α'}  {f' : α → β → δ}  {g' : δ → γ}      (h_left_comm : ∀ a b, f (g a) b = g' (f' a b))"},
 {"type": "map₂ f a (b.map g) = (map₂ f' a b).map g'",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : α → β' → γ}  {g : β → β'}  {f' : α → β → δ}  {g' : δ → γ}      (h_right_comm : ∀ a b, f a (g b) = g' (f' a b)) : map₂ f a (b.map g) = (map₂ f' a b).map g' := by cases a; sorry",
  "name": "map_map₂_right_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : α → β' → γ}  {g : β → β'}  {f' : α → β → δ}  {g' : δ → γ}      (h_right_comm : ∀ a b, f a (g b) = g' (f' a b)) : map₂ f a (b.map g) = (map₂ f' a b).map g'",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : α → β' → γ}  {g : β → β'}  {f' : α → β → δ}  {g' : δ → γ}      (h_right_comm : ∀ a b, f a (g b) = g' (f' a b))"},
 {"type": "(map₂ f a b).map g = map₂ f' (b.map g₁) (a.map g₂)",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : β' → α' → δ}  {g₁ : β → β'}  {g₂ : α → α'}      (h_antidistrib : ∀ a b, g (f a b) = f' (g₁ b) (g₂ a)) : (map₂ f a b).map g = map₂ f' (b.map g₁) (a.map g₂) := by cases a; sorry",
  "name": "map_map₂_antidistrib",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : β' → α' → δ}  {g₁ : β → β'}  {g₂ : α → α'}      (h_antidistrib : ∀ a b, g (f a b) = f' (g₁ b) (g₂ a)) : (map₂ f a b).map g = map₂ f' (b.map g₁) (a.map g₂)",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : β' → α' → δ}  {g₁ : β → β'}  {g₂ : α → α'}      (h_antidistrib : ∀ a b, g (f a b) = f' (g₁ b) (g₂ a))"},
 {"type": "(map₂ f a b).map g = map₂ f' (b.map g') a",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : β' → α → δ}  {g' : β → β'}      (h_antidistrib : ∀ a b, g (f a b) = f' (g' b) a) : (map₂ f a b).map g = map₂ f' (b.map g') a := by cases a; sorry",
  "name": "map_map₂_antidistrib_left",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : β' → α → δ}  {g' : β → β'}      (h_antidistrib : ∀ a b, g (f a b) = f' (g' b) a) : (map₂ f a b).map g = map₂ f' (b.map g') a",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : β' → α → δ}  {g' : β → β'}      (h_antidistrib : ∀ a b, g (f a b) = f' (g' b) a)"},
 {"type": "(map₂ f a b).map g = map₂ f' b (a.map g')",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : β → α' → δ}  {g' : α → α'}      (h_antidistrib : ∀ a b, g (f a b) = f' b (g' a)) : (map₂ f a b).map g = map₂ f' b (a.map g') := by cases a; sorry",
  "name": "map_map₂_antidistrib_right",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : β → α' → δ}  {g' : α → α'}      (h_antidistrib : ∀ a b, g (f a b) = f' b (g' a)) : (map₂ f a b).map g = map₂ f' b (a.map g')",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {g : γ → δ}  {f' : β → α' → δ}  {g' : α → α'}      (h_antidistrib : ∀ a b, g (f a b) = f' b (g' a))"},
 {"type": "map₂ f (a.map g) b = (map₂ f' b a).map g'",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : α' → β → γ}  {g : α → α'}  {f' : β → α → δ}  {g' : δ → γ}      (h_left_anticomm : ∀ a b, f (g a) b = g' (f' b a)) : map₂ f (a.map g) b = (map₂ f' b a).map g' := by cases a; sorry",
  "name": "map₂_map_left_anticomm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : α' → β → γ}  {g : α → α'}  {f' : β → α → δ}  {g' : δ → γ}      (h_left_anticomm : ∀ a b, f (g a) b = g' (f' b a)) : map₂ f (a.map g) b = (map₂ f' b a).map g'",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : α' → β → γ}  {g : α → α'}  {f' : β → α → δ}  {g' : δ → γ}      (h_left_anticomm : ∀ a b, f (g a) b = g' (f' b a))"},
 {"type": "map₂ f a (b.map g) = (map₂ f' b a).map g'",
  "tactic-prompt":
  "theorem {f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : α → β' → γ}  {g : β → β'}  {f' : β → α → δ}  {g' : δ → γ}      (h_right_anticomm : ∀ a b, f a (g b) = g' (f' b a)) : map₂ f a (b.map g) = (map₂ f' b a).map g' := by cases a; sorry",
  "name": "map_map₂_right_anticomm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : α → β' → γ}  {g : β → β'}  {f' : β → α → δ}  {g' : δ → γ}      (h_right_anticomm : ∀ a b, f a (g b) = g' (f' b a)) : map₂ f a (b.map g) = (map₂ f' b a).map g'",
  "args":
  "{f : α → β → γ}  {a : Option α}  {b : Option β}  {c : Option γ} {f : α → β' → γ}  {g : β → β'}  {f' : β → α → δ}  {g' : δ → γ}      (h_right_anticomm : ∀ a b, f a (g b) = g' (f' b a))"},
 {"type": "x.bind f = some b ↔ ∃ a, x = some a ∧ f a = some b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {x : Option α}  {f : α → Option β}  {b : β} : x.bind f = some b ↔ ∃ a, x = some a ∧ f a = some b := by cases x; sorry",
  "name": "bind_eq_some'",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α β γ δ : Type _} {x : Option α}  {f : α → Option β}  {b : β} : x.bind f = some b ↔ ∃ a, x = some a ∧ f a = some b",
  "args": "{α β γ δ : Type _} {x : Option α}  {f : α → Option β}  {b : β}"},
 {"type": "o.bind f = none ↔ ∀ b a, a ∈ o → b ∉ f a",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {o : Option α}  {f : α → Option β} : o.bind f = none ↔ ∀ b a, a ∈ o → b ∉ f a := by simp only [eq_none_iff_forall_not_mem]; sorry",
  "name": "bind_eq_none'",
  "kind": "theorem",
  "first-tactic": "simp only [eq_none_iff_forall_not_mem]",
  "core-prompt":
  "{α β γ δ : Type _} {o : Option α}  {f : α → Option β} : o.bind f = none ↔ ∀ b a, a ∈ o → b ∉ f a",
  "args": "{α β γ δ : Type _} {o : Option α}  {f : α → Option β}"},
 {"type": "(Option.map f₁ a).map g₁ = (Option.map f₂ a).map g₂",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {f₁ : α → β}  {f₂ : α → γ}  {g₁ : β → δ}  {g₂ : γ → δ}  (h : g₁ ∘ f₁ = g₂ ∘ f₂)    (a : α) : (Option.map f₁ a).map g₁ = (Option.map f₂ a).map g₂ := by rw [map_map]; sorry",
  "name": "map_comm",
  "kind": "theorem",
  "first-tactic": "rw [map_map]",
  "core-prompt":
  "{α β γ δ : Type _} {f₁ : α → β}  {f₂ : α → γ}  {g₁ : β → δ}  {g₂ : γ → δ}  (h : g₁ ∘ f₁ = g₂ ∘ f₂)    (a : α) : (Option.map f₁ a).map g₁ = (Option.map f₂ a).map g₂",
  "args":
  "{α β γ δ : Type _} {f₁ : α → β}  {f₂ : α → γ}  {g₁ : β → δ}  {g₂ : γ → δ}  (h : g₁ ∘ f₁ = g₂ ∘ f₂)    (a : α)"},
 {"type": "(x.pbind fun a _ ↦ f a) = x.bind f",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : α → Option β)  (x : Option α) : (x.pbind fun a _ ↦ f a) = x.bind f := by cases x; sorry",
  "name": "pbind_eq_bind",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : α → Option β)  (x : Option α) : (x.pbind fun a _ ↦ f a) = x.bind f",
  "args":
  "{α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : α → Option β)  (x : Option α)"},
 {"type": "Option.map f (x.bind g) = x.bind fun a ↦ Option.map f (g a)",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : β → γ)  (x : Option α)  (g : α → Option β) : Option.map f (x.bind g) = x.bind fun a ↦ Option.map f (g a) := by cases x; sorry",
  "name": "map_bind'",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : β → γ)  (x : Option α)  (g : α → Option β) : Option.map f (x.bind g) = x.bind fun a ↦ Option.map f (g a)",
  "args":
  "{α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : β → γ)  (x : Option α)  (g : α → Option β)"},
 {"type": "Option.map f (x.pbind g) = x.pbind fun a H ↦ Option.map f (g a H)",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : β → γ)  (x : Option α)  (g : ∀ a, a ∈ x → Option β) : Option.map f (x.pbind g) = x.pbind fun a H ↦ Option.map f (g a H) := by cases x; sorry",
  "name": "map_pbind",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : β → γ)  (x : Option α)  (g : ∀ a, a ∈ x → Option β) : Option.map f (x.pbind g) = x.pbind fun a H ↦ Option.map f (g a H)",
  "args":
  "{α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : β → γ)  (x : Option α)  (g : ∀ a, a ∈ x → Option β)"},
 {"type":
  "pbind (Option.map f x) g = x.pbind fun a h ↦ g (f a) (mem_map_of_mem _ h)",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : α → β)  (x : Option α)  (g : ∀ b : β, b ∈ x.map f → Option γ) : pbind (Option.map f x) g = x.pbind fun a h ↦ g (f a) (mem_map_of_mem _ h) := by cases x; sorry",
  "name": "pbind_map",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : α → β)  (x : Option α)  (g : ∀ b : β, b ∈ x.map f → Option γ) : pbind (Option.map f x) g = x.pbind fun a h ↦ g (f a) (mem_map_of_mem _ h)",
  "args":
  "{α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : α → β)  (x : Option α)  (g : ∀ b : β, b ∈ x.map f → Option γ)"},
 {"type": "f a (h a ha) ∈ pmap f x h",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {a : α}  (h : ∀ a ∈ x, p a)  (ha : a ∈ x) : f a (h a ha) ∈ pmap f x h := by rw [mem_def] at ha ⊢; sorry",
  "name": "mem_pmem",
  "kind": "theorem",
  "first-tactic": "rw [mem_def] at ha ⊢",
  "core-prompt":
  "{α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {a : α}  (h : ∀ a ∈ x, p a)  (ha : a ∈ x) : f a (h a ha) ∈ pmap f x h",
  "args":
  "{α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {a : α}  (h : ∀ a ∈ x, p a)  (ha : a ∈ x)"},
 {"type": "x.pbind f = none ↔ x = none",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {f : ∀ a : α, a ∈ x → Option β}      (h' : ∀ a (H : a ∈ x), f a H = none → x = none) : x.pbind f = none ↔ x = none := by cases x; sorry",
  "name": "pbind_eq_none",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {f : ∀ a : α, a ∈ x → Option β}      (h' : ∀ a (H : a ∈ x), f a H = none → x = none) : x.pbind f = none ↔ x = none",
  "args":
  "{α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {f : ∀ a : α, a ∈ x → Option β}      (h' : ∀ a (H : a ∈ x), f a H = none → x = none)"},
 {"type": "x.pbind f = some y ↔ ∃ (z : α) (H : z ∈ x), f z H = some y",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {f : ∀ a : α, a ∈ x → Option β}  {y : β} : x.pbind f = some y ↔ ∃ (z : α) (H : z ∈ x), f z H = some y := by rcases x with (_|x); sorry",
  "name": "pbind_eq_some",
  "kind": "theorem",
  "first-tactic": "rcases x with (_|x)",
  "core-prompt":
  "{α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {f : ∀ a : α, a ∈ x → Option β}  {y : β} : x.pbind f = some y ↔ ∃ (z : α) (H : z ∈ x), f z H = some y",
  "args":
  "{α β γ δ : Type _}  {p : α → Prop}  (f : ∀ a : α, p a → β)  (x : Option α)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {f : ∀ a : α, a ∈ x → Option β}  {y : β}"},
 {"type": "none.orElse (fun _ ↦ x) = x",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} (x : Option α) : none.orElse (fun _ ↦ x) = x := by cases x; sorry",
  "name": "none_orElse'",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α β γ δ : Type _} (x : Option α) : none.orElse (fun _ ↦ x) = x",
  "args": "{α β γ δ : Type _} (x : Option α)"},
 {"type": "x.orElse (fun _ ↦ none) = x",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} (x : Option α) : x.orElse (fun _ ↦ none) = x := by cases x; sorry",
  "name": "orElse_none'",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α β γ δ : Type _} (x : Option α) : x.orElse (fun _ ↦ none) = x",
  "args": "{α β γ δ : Type _} (x : Option α)"},
 {"type": "o.getD default = o.iget",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} [Inhabited α]  (o : Option α) : o.getD default = o.iget := by cases o; sorry",
  "name": "getD_default_eq_iget",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{α β γ δ : Type _} [Inhabited α]  (o : Option α) : o.getD default = o.iget",
  "args": "{α β γ δ : Type _} [Inhabited α]  (o : Option α)"},
 {"type": "casesOn' o (f none) (f ∘ (fun a ↦ ↑a)) = f o",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} (f : Option α → β)  (o : Option α) : casesOn' o (f none) (f ∘ (fun a ↦ ↑a)) = f o := by cases o; sorry",
  "name": "casesOn'_none_coe",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{α β γ δ : Type _} (f : Option α → β)  (o : Option α) : casesOn' o (f none) (f ∘ (fun a ↦ ↑a)) = f o",
  "args": "{α β γ δ : Type _} (f : Option α → β)  (o : Option α)"},
 {"type": "(o <|> o') = some x ↔ o = some x ∨ o = none ∧ o' = some x",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} (o o' : Option α)  (x : α) : (o <|> o') = some x ↔ o = some x ∨ o = none ∧ o' = some x := by cases o; sorry",
  "name": "orElse_eq_some",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{α β γ δ : Type _} (o o' : Option α)  (x : α) : (o <|> o') = some x ↔ o = some x ∨ o = none ∧ o' = some x",
  "args": "{α β γ δ : Type _} (o o' : Option α)  (x : α)"},
 {"type": "(o <|> o') = none ↔ o = none ∧ o' = none",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} (o o' : Option α) : (o <|> o') = none ↔ o = none ∧ o' = none := by cases o; sorry",
  "name": "orElse_eq_none",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{α β γ δ : Type _} (o o' : Option α) : (o <|> o') = none ↔ o = none ∧ o' = none",
  "args": "{α β γ δ : Type _} (o o' : Option α)"},
 {"type": "p < q ↔ p ≤ q ∧ ∃ x ∈ q, x ∉ p",
  "tactic-prompt":
  "theorem {A : Type _}  {B : Type _}  [i : SetLike A B] (p q : A) : p < q ↔ p ≤ q ∧ ∃ x ∈ q, x ∉ p := by rw [lt_iff_le_not_le]; sorry",
  "name": "lt_iff_le_and_exists",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_le_not_le]",
  "core-prompt":
  "{A : Type _}  {B : Type _}  [i : SetLike A B] (p q : A) : p < q ↔ p ≤ q ∧ ∃ x ∈ q, x ∉ p",
  "args": "{A : Type _}  {B : Type _}  [i : SetLike A B] (p q : A)"},
 {"type": "Acc (Prod.GameAdd rα rβ) (a, b)",
  "tactic-prompt":
  "theorem (rα : α → α → Prop)  (rβ : β → β → Prop) (ha : Acc rα a)  (hb : Acc rβ b) : Acc (Prod.GameAdd rα rβ) (a, b) := by induction' ha with a _ iha generalizing b; sorry",
  "name": "Acc.prod_gameAdd",
  "kind": "theorem",
  "first-tactic": "induction' ha with a _ iha generalizing b",
  "core-prompt":
  "(rα : α → α → Prop)  (rβ : β → β → Prop) (ha : Acc rα a)  (hb : Acc rβ b) : Acc (Prod.GameAdd rα rβ) (a, b)",
  "args":
  "(rα : α → α → Prop)  (rβ : β → β → Prop) (ha : Acc rα a)  (hb : Acc rβ b)"},
 {"type": "Injective f",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β] [LinearOrder α]  {f : α → β}  (h : ∀ x y, x < y → f x ≠ f y) : Injective f := by intro x y hf; sorry",
  "name": "injective_of_lt_imp_ne",
  "kind": "theorem",
  "first-tactic": "intro x y hf",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β] [LinearOrder α]  {f : α → β}  (h : ∀ x y, x < y → f x ≠ f y) : Injective f",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β] [LinearOrder α]  {f : α → β}  (h : ∀ x y, x < y → f x ≠ f y)"},
 {"type": "StrictMono fun x ↦ if p x then f x else g x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α]  [Preorder β]  {f g : α → β}  {a : α} (hf : StrictMono f)  (hg : StrictMono g)  {p : α → Prop}      [DecidablePred p]      (hp : ∀ ⦃x y⦄, x < y → p y → p x)  (hfg : ∀ ⦃x y⦄, p x → ¬p y → x < y → f x < g y) : StrictMono fun x ↦ if p x then f x else g x := by intro x y h; sorry",
  "name": "StrictMono.ite'",
  "kind": "theorem",
  "first-tactic": "intro x y h",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α]  [Preorder β]  {f g : α → β}  {a : α} (hf : StrictMono f)  (hg : StrictMono g)  {p : α → Prop}      [DecidablePred p]      (hp : ∀ ⦃x y⦄, x < y → p y → p x)  (hfg : ∀ ⦃x y⦄, p x → ¬p y → x < y → f x < g y) : StrictMono fun x ↦ if p x then f x else g x",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α]  [Preorder β]  {f g : α → β}  {a : α} (hf : StrictMono f)  (hg : StrictMono g)  {p : α → Prop}      [DecidablePred p]      (hp : ∀ ⦃x y⦄, x < y → p y → p x)  (hfg : ∀ ⦃x y⦄, p x → ¬p y → x < y → f x < g y)"},
 {"type": "f a < f b ↔ a < b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [LinearOrder α]  [Preorder β]  {f : α → β}  {s : Set α} (hf : StrictMonoOn f s)  {a b : α}  (ha : a ∈ s)  (hb : b ∈ s) : f a < f b ↔ a < b := by rw [lt_iff_le_not_le]; sorry",
  "name": "StrictMonoOn.lt_iff_lt",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_le_not_le]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [LinearOrder α]  [Preorder β]  {f : α → β}  {s : Set α} (hf : StrictMonoOn f s)  {a b : α}  (ha : a ∈ s)  (hb : b ∈ s) : f a < f b ↔ a < b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [LinearOrder α]  [Preorder β]  {f : α → β}  {s : Set α} (hf : StrictMonoOn f s)  {a b : α}  (ha : a ∈ s)  (hb : b ∈ s)"},
 {"type":
  "¬ Monotone f ∧ ¬ Antitone f ↔ ∃ a b c, a ≤ b ∧ b ≤ c ∧\n    (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c)",
  "tactic-prompt":
  "lemma {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [LinearOrder α] [LinearOrder β]  {f : α → β}  {s : Set α}  {x y : α} : ¬ Monotone f ∧ ¬ Antitone f ↔ ∃ a b c, a ≤ b ∧ b ≤ c ∧\n    (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c) := by simp_rw [Monotone]; sorry",
  "name": "not_monotone_not_antitone_iff_exists_le_le",
  "kind": "lemma",
  "first-tactic": "simp_rw [Monotone]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [LinearOrder α] [LinearOrder β]  {f : α → β}  {s : Set α}  {x y : α} : ¬ Monotone f ∧ ¬ Antitone f ↔ ∃ a b c, a ≤ b ∧ b ≤ c ∧\n    (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [LinearOrder α] [LinearOrder β]  {f : α → β}  {s : Set α}  {x y : α}"},
 {"type":
  "¬ Monotone f ∧ ¬ Antitone f ↔ ∃ a b c, a < b ∧ b < c ∧\n    (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c)",
  "tactic-prompt":
  "lemma {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [LinearOrder α] [LinearOrder β]  {f : α → β}  {s : Set α}  {x y : α} : ¬ Monotone f ∧ ¬ Antitone f ↔ ∃ a b c, a < b ∧ b < c ∧\n    (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c) := by simp_rw [not_monotone_not_antitone_iff_exists_le_le]; sorry",
  "name": "not_monotone_not_antitone_iff_exists_lt_lt",
  "kind": "lemma",
  "first-tactic": "simp_rw [not_monotone_not_antitone_iff_exists_le_le]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [LinearOrder α] [LinearOrder β]  {f : α → β}  {s : Set α}  {x y : α} : ¬ Monotone f ∧ ¬ Antitone f ↔ ∃ a b c, a < b ∧ b < c ∧\n    (f a < f b ∧ f c < f b ∨ f b < f a ∧ f b < f c)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [LinearOrder α] [LinearOrder β]  {f : α → β}  {s : Set α}  {x y : α}"},
 {"type": "∃ f : ℕ → α, StrictMono f ∧ f 0 = a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] [NoMaxOrder α]  (a : α) : ∃ f : ℕ → α, StrictMono f ∧ f 0 = a := by choose g hg using fun x : α ↦ exists_gt x; sorry",
  "name": "exists_strictMono'",
  "kind": "theorem",
  "first-tactic": "choose g hg using fun x : α ↦ exists_gt x",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] [NoMaxOrder α]  (a : α) : ∃ f : ℕ → α, StrictMono f ∧ f 0 = a",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] [NoMaxOrder α]  (a : α)"},
 {"type": "∃ f : ℤ → α, StrictMono f",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] : ∃ f : ℤ → α, StrictMono f := by inhabit α; sorry",
  "name": "exists_strictMono",
  "kind": "theorem",
  "first-tactic": "inhabit α",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] : ∃ f : ℤ → α, StrictMono f",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α]"},
 {"type": "f a ≠ x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] {f : ℕ → α}  (hf : Monotone f)  (n : ℕ)  {x : α}  (h1 : f n < x)      (h2 : x < f (n + 1))  (a : ℕ) : f a ≠ x := by rintro rfl; sorry",
  "name": "Monotone.ne_of_lt_of_lt_nat",
  "kind": "theorem",
  "first-tactic": "rintro rfl",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] {f : ℕ → α}  (hf : Monotone f)  (n : ℕ)  {x : α}  (h1 : f n < x)      (h2 : x < f (n + 1))  (a : ℕ) : f a ≠ x",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] {f : ℕ → α}  (hf : Monotone f)  (n : ℕ)  {x : α}  (h1 : f n < x)      (h2 : x < f (n + 1))  (a : ℕ)"},
 {"type": "f a ≠ x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] {f : ℕ → α}  (hf : Antitone f)  (n : ℕ)  {x : α}      (h1 : f (n + 1) < x)  (h2 : x < f n)  (a : ℕ) : f a ≠ x := by rintro rfl; sorry",
  "name": "Antitone.ne_of_lt_of_lt_nat",
  "kind": "theorem",
  "first-tactic": "rintro rfl",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] {f : ℕ → α}  (hf : Antitone f)  (n : ℕ)  {x : α}      (h1 : f (n + 1) < x)  (h2 : x < f n)  (a : ℕ) : f a ≠ x",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] {f : ℕ → α}  (hf : Antitone f)  (n : ℕ)  {x : α}      (h1 : f (n + 1) < x)  (h2 : x < f n)  (a : ℕ)"},
 {"type": "f a ≠ x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] {f : ℤ → α}  (hf : Monotone f)  (n : ℤ)  {x : α}  (h1 : f n < x)      (h2 : x < f (n + 1))  (a : ℤ) : f a ≠ x := by rintro rfl; sorry",
  "name": "Monotone.ne_of_lt_of_lt_int",
  "kind": "theorem",
  "first-tactic": "rintro rfl",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] {f : ℤ → α}  (hf : Monotone f)  (n : ℤ)  {x : α}  (h1 : f n < x)      (h2 : x < f (n + 1))  (a : ℤ) : f a ≠ x",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] {f : ℤ → α}  (hf : Monotone f)  (n : ℤ)  {x : α}  (h1 : f n < x)      (h2 : x < f (n + 1))  (a : ℤ)"},
 {"type": "f a ≠ x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] {f : ℤ → α}  (hf : Antitone f)  (n : ℤ)  {x : α}      (h1 : f (n + 1) < x)  (h2 : x < f n)  (a : ℤ) : f a ≠ x := by rintro rfl; sorry",
  "name": "Antitone.ne_of_lt_of_lt_int",
  "kind": "theorem",
  "first-tactic": "rintro rfl",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] {f : ℤ → α}  (hf : Antitone f)  (n : ℤ)  {x : α}      (h1 : f (n + 1) < x)  (h2 : x < f n)  (a : ℤ) : f a ≠ x",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {δ : Type _}  {r : α → α → Prop} [Preorder α]  [Preorder β]  [Preorder α] {f : ℤ → α}  (hf : Antitone f)  (n : ℤ)  {x : α}      (h1 : f (n + 1) < x)  (h2 : x < f n)  (a : ℤ)"},
 {"type": "StrictMono f",
  "tactic-prompt":
  "theorem {G H : Type _}  [LinearOrderedAddCommGroup G]  [OrderedAddCommGroup H] {f : G → H}  (h₁ : ∀ x, f (-x) = -f x)      (h₂ : StrictMonoOn f (Ici 0)) : StrictMono f := by refine' StrictMonoOn.Iic_union_Ici (fun x hx y hy hxy => neg_lt_neg_iff.1 _) h₂; sorry",
  "name": "strictMono_of_odd_strictMono_on_nonneg",
  "kind": "theorem",
  "first-tactic":
  "refine' StrictMonoOn.Iic_union_Ici (fun x hx y hy hxy => neg_lt_neg_iff.1 _) h₂",
  "core-prompt":
  "{G H : Type _}  [LinearOrderedAddCommGroup G]  [OrderedAddCommGroup H] {f : G → H}  (h₁ : ∀ x, f (-x) = -f x)      (h₂ : StrictMonoOn f (Ici 0)) : StrictMono f",
  "args":
  "{G H : Type _}  [LinearOrderedAddCommGroup G]  [OrderedAddCommGroup H] {f : G → H}  (h₁ : ∀ x, f (-x) = -f x)      (h₂ : StrictMonoOn f (Ici 0))"},
 {"type": "Monotone f",
  "tactic-prompt":
  "theorem {G H : Type _}  [LinearOrderedAddCommGroup G]  [OrderedAddCommGroup H] {f : G → H}  (h₁ : ∀ x, f (-x) = -f x)      (h₂ : MonotoneOn f (Ici 0)) : Monotone f := by refine' MonotoneOn.Iic_union_Ici (fun x hx y hy hxy => neg_le_neg_iff.1 _) h₂; sorry",
  "name": "monotone_of_odd_of_monotone_on_nonneg",
  "kind": "theorem",
  "first-tactic":
  "refine' MonotoneOn.Iic_union_Ici (fun x hx y hy hxy => neg_le_neg_iff.1 _) h₂",
  "core-prompt":
  "{G H : Type _}  [LinearOrderedAddCommGroup G]  [OrderedAddCommGroup H] {f : G → H}  (h₁ : ∀ x, f (-x) = -f x)      (h₂ : MonotoneOn f (Ici 0)) : Monotone f",
  "args":
  "{G H : Type _}  [LinearOrderedAddCommGroup G]  [OrderedAddCommGroup H] {f : G → H}  (h₁ : ∀ x, f (-x) = -f x)      (h₂ : MonotoneOn f (Ici 0))"},
 {"type": "StrictMonoOn f (s ∪ t)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [Preorder β]  {a : α}  {f : α → β} {s t : Set α}  {c : α}  (h₁ : StrictMonoOn f s)      (h₂ : StrictMonoOn f t)  (hs : IsGreatest s c)  (ht : IsLeast t c) : StrictMonoOn f (s ∪ t) := by have A : ∀ x, x ∈ s ∪ t → x ≤ c → x ∈ s := by\n    intro x hx hxc\n    cases hx\n    · assumption\n    rcases eq_or_lt_of_le hxc with (rfl | h'x)\n    · exact hs.1\n    exact (lt_irrefl _ (h'x.trans_le (ht.2 (by assumption)))).elim; sorry",
  "name": "StrictMonoOn.union",
  "kind": "theorem",
  "first-tactic":
  "have A : ∀ x, x ∈ s ∪ t → x ≤ c → x ∈ s := by\n    intro x hx hxc\n    cases hx\n    · assumption\n    rcases eq_or_lt_of_le hxc with (rfl | h'x)\n    · exact hs.1\n    exact (lt_irrefl _ (h'x.trans_le (ht.2 (by assumption)))).elim",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [Preorder β]  {a : α}  {f : α → β} {s t : Set α}  {c : α}  (h₁ : StrictMonoOn f s)      (h₂ : StrictMonoOn f t)  (hs : IsGreatest s c)  (ht : IsLeast t c) : StrictMonoOn f (s ∪ t)",
  "args":
  "{α β : Type _}  [LinearOrder α]  [Preorder β]  {a : α}  {f : α → β} {s t : Set α}  {c : α}  (h₁ : StrictMonoOn f s)      (h₂ : StrictMonoOn f t)  (hs : IsGreatest s c)  (ht : IsLeast t c)"},
 {"type": "StrictMono f",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [Preorder β]  {a : α}  {f : α → β} (h₁ : StrictMonoOn f (Iic a))      (h₂ : StrictMonoOn f (Ici a)) : StrictMono f := by rw [← strictMonoOn_univ]; sorry",
  "name": "StrictMonoOn.Iic_union_Ici",
  "kind": "theorem",
  "first-tactic": "rw [← strictMonoOn_univ]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [Preorder β]  {a : α}  {f : α → β} (h₁ : StrictMonoOn f (Iic a))      (h₂ : StrictMonoOn f (Ici a)) : StrictMono f",
  "args":
  "{α β : Type _}  [LinearOrder α]  [Preorder β]  {a : α}  {f : α → β} (h₁ : StrictMonoOn f (Iic a))      (h₂ : StrictMonoOn f (Ici a))"},
 {"type": "MonotoneOn f (s ∪ t)",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [Preorder β]  {a : α}  {f : α → β} {s t : Set α}  {c : α}  (h₁ : MonotoneOn f s)      (h₂ : MonotoneOn f t)  (hs : IsGreatest s c)  (ht : IsLeast t c) : MonotoneOn f (s ∪ t) := by have A : ∀ x, x ∈ s ∪ t → x ≤ c → x ∈ s := by\n    intro x hx hxc\n    cases hx\n    · assumption\n    rcases eq_or_lt_of_le hxc with (rfl | h'x)\n    · exact hs.1\n    exact (lt_irrefl _ (h'x.trans_le (ht.2 (by assumption)))).elim; sorry",
  "name": "MonotoneOn.union_right",
  "kind": "theorem",
  "first-tactic":
  "have A : ∀ x, x ∈ s ∪ t → x ≤ c → x ∈ s := by\n    intro x hx hxc\n    cases hx\n    · assumption\n    rcases eq_or_lt_of_le hxc with (rfl | h'x)\n    · exact hs.1\n    exact (lt_irrefl _ (h'x.trans_le (ht.2 (by assumption)))).elim",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [Preorder β]  {a : α}  {f : α → β} {s t : Set α}  {c : α}  (h₁ : MonotoneOn f s)      (h₂ : MonotoneOn f t)  (hs : IsGreatest s c)  (ht : IsLeast t c) : MonotoneOn f (s ∪ t)",
  "args":
  "{α β : Type _}  [LinearOrder α]  [Preorder β]  {a : α}  {f : α → β} {s t : Set α}  {c : α}  (h₁ : MonotoneOn f s)      (h₂ : MonotoneOn f t)  (hs : IsGreatest s c)  (ht : IsLeast t c)"},
 {"type": "Monotone f",
  "tactic-prompt":
  "theorem {α β : Type _}  [LinearOrder α]  [Preorder β]  {a : α}  {f : α → β} (h₁ : MonotoneOn f (Iic a))  (h₂ : MonotoneOn f (Ici a)) : Monotone f := by rw [← monotoneOn_univ]; sorry",
  "name": "MonotoneOn.Iic_union_Ici",
  "kind": "theorem",
  "first-tactic": "rw [← monotoneOn_univ]",
  "core-prompt":
  "{α β : Type _}  [LinearOrder α]  [Preorder β]  {a : α}  {f : α → β} (h₁ : MonotoneOn f (Iic a))  (h₂ : MonotoneOn f (Ici a)) : Monotone f",
  "args":
  "{α β : Type _}  [LinearOrder α]  [Preorder β]  {a : α}  {f : α → β} (h₁ : MonotoneOn f (Iic a))  (h₂ : MonotoneOn f (Ici a))"},
 {"type": "x n ≤ y n",
  "tactic-prompt":
  "theorem [Preorder α]  {f : α → α}  {x y : ℕ → α} (hf : Monotone f)  (n : ℕ)  (h₀ : x 0 ≤ y 0)  (hx : ∀ k < n, x (k + 1) ≤ f (x k))      (hy : ∀ k < n, f (y k) ≤ y (k + 1)) : x n ≤ y n := by induction' n with n ihn; sorry",
  "name": "seq_le_seq",
  "kind": "theorem",
  "first-tactic": "induction' n with n ihn",
  "core-prompt":
  "[Preorder α]  {f : α → α}  {x y : ℕ → α} (hf : Monotone f)  (n : ℕ)  (h₀ : x 0 ≤ y 0)  (hx : ∀ k < n, x (k + 1) ≤ f (x k))      (hy : ∀ k < n, f (y k) ≤ y (k + 1)) : x n ≤ y n",
  "args":
  "[Preorder α]  {f : α → α}  {x y : ℕ → α} (hf : Monotone f)  (n : ℕ)  (h₀ : x 0 ≤ y 0)  (hx : ∀ k < n, x (k + 1) ≤ f (x k))      (hy : ∀ k < n, f (y k) ≤ y (k + 1))"},
 {"type": "x n < y n",
  "tactic-prompt":
  "theorem [Preorder α]  {f : α → α}  {x y : ℕ → α} (hf : Monotone f)  {n : ℕ}  (hn : 0 < n)  (h₀ : x 0 ≤ y 0)      (hx : ∀ k < n, x (k + 1) < f (x k))  (hy : ∀ k < n, f (y k) ≤ y (k + 1)) : x n < y n := by induction' n with n ihn; sorry",
  "name": "seq_pos_lt_seq_of_lt_of_le",
  "kind": "theorem",
  "first-tactic": "induction' n with n ihn",
  "core-prompt":
  "[Preorder α]  {f : α → α}  {x y : ℕ → α} (hf : Monotone f)  {n : ℕ}  (hn : 0 < n)  (h₀ : x 0 ≤ y 0)      (hx : ∀ k < n, x (k + 1) < f (x k))  (hy : ∀ k < n, f (y k) ≤ y (k + 1)) : x n < y n",
  "args":
  "[Preorder α]  {f : α → α}  {x y : ℕ → α} (hf : Monotone f)  {n : ℕ}  (hn : 0 < n)  (h₀ : x 0 ≤ y 0)      (hx : ∀ k < n, x (k + 1) < f (x k))  (hy : ∀ k < n, f (y k) ≤ y (k + 1))"},
 {"type": "x n < y n",
  "tactic-prompt":
  "theorem [Preorder α]  {f : α → α}  {x y : ℕ → α} (hf : Monotone f)  (n : ℕ)  (h₀ : x 0 < y 0)      (hx : ∀ k < n, x (k + 1) < f (x k))  (hy : ∀ k < n, f (y k) ≤ y (k + 1)) : x n < y n := by cases n; sorry",
  "name": "seq_lt_seq_of_lt_of_le",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "[Preorder α]  {f : α → α}  {x y : ℕ → α} (hf : Monotone f)  (n : ℕ)  (h₀ : x 0 < y 0)      (hx : ∀ k < n, x (k + 1) < f (x k))  (hy : ∀ k < n, f (y k) ≤ y (k + 1)) : x n < y n",
  "args":
  "[Preorder α]  {f : α → α}  {x y : ℕ → α} (hf : Monotone f)  (n : ℕ)  (h₀ : x 0 < y 0)      (hx : ∀ k < n, x (k + 1) < f (x k))  (hy : ∀ k < n, f (y k) ≤ y (k + 1))"},
 {"type": "id ≤ f^[n]",
  "tactic-prompt":
  "theorem [Preorder α]  {f : α → α}  {x y : ℕ → α} {g : β → β}  {h : β → α}  [Preorder α]  {f : α → α} (h : id ≤ f)  (n : ℕ) : id ≤ f^[n] := by simpa only [iterate_id] using monotone_id.iterate_le_of_le h n; sorry",
  "name": "id_le_iterate_of_id_le",
  "kind": "theorem",
  "first-tactic":
  "simpa only [iterate_id] using monotone_id.iterate_le_of_le h n",
  "core-prompt":
  "[Preorder α]  {f : α → α}  {x y : ℕ → α} {g : β → β}  {h : β → α}  [Preorder α]  {f : α → α} (h : id ≤ f)  (n : ℕ) : id ≤ f^[n]",
  "args":
  "[Preorder α]  {f : α → α}  {x y : ℕ → α} {g : β → β}  {h : β → α}  [Preorder α]  {f : α → α} (h : id ≤ f)  (n : ℕ)"},
 {"type": "DirectedOn r (f '' s) ↔ DirectedOn (f ⁻¹'o r) s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop) {s : Set β}  {f : β → α} : DirectedOn r (f '' s) ↔ DirectedOn (f ⁻¹'o r) s := by simp only [DirectedOn]; sorry",
  "name": "directedOn_image",
  "kind": "theorem",
  "first-tactic": "simp only [DirectedOn]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop) {s : Set β}  {f : β → α} : DirectedOn r (f '' s) ↔ DirectedOn (f ⁻¹'o r) s",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop) {s : Set β}  {f : β → α}"},
 {"type": "Directed (· ≤ ·) (Function.extend e f ⊥)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop) [Preorder α]  [OrderBot α]  {e : ι → β}  {f : ι → α}      (hf : Directed (· ≤ ·) f)  (he : Function.Injective e) : Directed (· ≤ ·) (Function.extend e f ⊥) := by intro a b; sorry",
  "name": "Directed.extend_bot",
  "kind": "theorem",
  "first-tactic": "intro a b",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop) [Preorder α]  [OrderBot α]  {e : ι → β}  {f : ι → α}      (hf : Directed (· ≤ ·) f)  (he : Function.Injective e) : Directed (· ≤ ·) (Function.extend e f ⊥)",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop) [Preorder α]  [OrderBot α]  {e : ι → β}  {f : ι → α}      (hf : Directed (· ≤ ·) f)  (he : Function.Injective e)"},
 {"type": "Directed r id",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop) [IsDirected α r] : Directed r id := by convert directed_of r; sorry",
  "name": "directed_id",
  "kind": "theorem",
  "first-tactic": "convert directed_of r",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop) [IsDirected α r] : Directed r id",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop) [IsDirected α r]"},
 {"type": "IsDirected αᵒᵈ (· ≥ ·)",
  "tactic-prompt":
  "instance {α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop) [LE α]  [IsDirected α (· ≤ ·)] : IsDirected αᵒᵈ (· ≥ ·) := by assumption; sorry",
  "name": "OrderDual.isDirected_ge",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop) [LE α]  [IsDirected α (· ≤ ·)] : IsDirected αᵒᵈ (· ≥ ·)",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop) [LE α]  [IsDirected α (· ≤ ·)]"},
 {"type": "IsDirected αᵒᵈ (· ≤ ·)",
  "tactic-prompt":
  "instance {α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop) [LE α]  [IsDirected α (· ≥ ·)] : IsDirected αᵒᵈ (· ≤ ·) := by assumption; sorry",
  "name": "OrderDual.isDirected_le",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop) [LE α]  [IsDirected α (· ≥ ·)] : IsDirected αᵒᵈ (· ≤ ·)",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop) [LE α]  [IsDirected α (· ≥ ·)]"},
 {"type": "∃ a b : β, a < b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop)  [Preorder α]  {a : α} [IsDirected β (· ≥ ·)]  [Nontrivial β] : ∃ a b : β, a < b := by rcases exists_pair_ne β with ⟨a, b, hne⟩; sorry",
  "name": "exists_lt_of_directed_ge",
  "kind": "theorem",
  "first-tactic": "rcases exists_pair_ne β with ⟨a, b, hne⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop)  [Preorder α]  {a : α} [IsDirected β (· ≥ ·)]  [Nontrivial β] : ∃ a b : β, a < b",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  (r r' s : α → α → Prop)  [Preorder α]  {a : α} [IsDirected β (· ≥ ·)]  [Nontrivial β]"},
 {"type": "a ≤ supᵢ s ↔ ∀ b, (∀ i, s i ≤ b) → a ≤ b",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteSemilatticeSup α]  {s t : Set α}  {a b : α}  -- --@[ematch] Porting note: attribute removed {s : ι → α} : a ≤ supᵢ s ↔ ∀ b, (∀ i, s i ≤ b) → a ≤ b := by simp [supᵢ]; sorry",
  "name": "le_supᵢ_iff",
  "kind": "theorem",
  "first-tactic": "simp [supᵢ]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteSemilatticeSup α]  {s t : Set α}  {a b : α}  -- --@[ematch] Porting note: attribute removed {s : ι → α} : a ≤ supᵢ s ↔ ∀ b, (∀ i, s i ≤ b) → a ≤ b",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteSemilatticeSup α]  {s t : Set α}  {a b : α}  -- --@[ematch] Porting note: attribute removed {s : ι → α}"},
 {"type": "infᵢ s ≤ a ↔ ∀ b, (∀ i, b ≤ s i) → b ≤ a",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteSemilatticeInf α]  {s t : Set α}  {a b : α}  -- --@[ematch] Porting note: attribute removed {s : ι → α} : infᵢ s ≤ a ↔ ∀ b, (∀ i, b ≤ s i) → b ≤ a := by simp [infᵢ]; sorry",
  "name": "infᵢ_le_iff",
  "kind": "theorem",
  "first-tactic": "simp [infᵢ]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteSemilatticeInf α]  {s t : Set α}  {a b : α}  -- --@[ematch] Porting note: attribute removed {s : ι → α} : infᵢ s ≤ a ↔ ∀ b, (∀ i, b ≤ s i) → b ≤ a",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteSemilatticeInf α]  {s t : Set α}  {a b : α}  -- --@[ematch] Porting note: attribute removed {s : ι → α}"},
 {"type": "s = {⊥}",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLattice α]  {s t : Set α}  {a b : α} {s : Set α}  (h_sup : supₛ s = ⊥)      (hne : s.Nonempty) : s = {⊥} := by rw [Set.eq_singleton_iff_nonempty_unique_mem]; sorry",
  "name": "eq_singleton_bot_of_supₛ_eq_bot_of_nonempty",
  "kind": "theorem",
  "first-tactic": "rw [Set.eq_singleton_iff_nonempty_unique_mem]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLattice α]  {s t : Set α}  {a b : α} {s : Set α}  (h_sup : supₛ s = ⊥)      (hne : s.Nonempty) : s = {⊥}",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLattice α]  {s t : Set α}  {a b : α} {s : Set α}  (h_sup : supₛ s = ⊥)      (hne : s.Nonempty)"},
 {"type": "supₛ s = ⨆ a : s, (a : α)",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} (s : Set α) : supₛ s = ⨆ a : s, (a : α) := by rw [supᵢ]; sorry",
  "name": "supₛ_eq_supᵢ'",
  "kind": "theorem",
  "first-tactic": "rw [supᵢ]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} (s : Set α) : supₛ s = ⨆ a : s, (a : α)",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} (s : Set α)"},
 {"type": "(⨆ x, g (f x)) = ⨆ y, g y",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} {f : ι → ι'}  (hf : Surjective f)  (g : ι' → α) : (⨆ x, g (f x)) = ⨆ y, g y := by simp [supᵢ]; sorry",
  "name": "Function.Surjective.supᵢ_comp",
  "kind": "theorem",
  "first-tactic": "simp [supᵢ]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} {f : ι → ι'}  (hf : Surjective f)  (g : ι' → α) : (⨆ x, g (f x)) = ⨆ y, g y",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} {f : ι → ι'}  (hf : Surjective f)  (g : ι' → α)"},
 {"type": "(⨆ x, f x) = ⨆ y, g y",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} {g : ι' → α}  (h : ι → ι')  (h1 : Surjective h)      (h2 : ∀ x, g (h x) = f x) : (⨆ x, f x) = ⨆ y, g y := by convert h1.supᵢ_comp g; sorry",
  "name": "Function.Surjective.supᵢ_congr",
  "kind": "theorem",
  "first-tactic": "convert h1.supᵢ_comp g",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} {g : ι' → α}  (h : ι → ι')  (h1 : Surjective h)      (h2 : ∀ x, g (h x) = f x) : (⨆ x, f x) = ⨆ y, g y",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} {g : ι' → α}  (h : ι → ι')  (h1 : Surjective h)      (h2 : ∀ x, g (h x) = f x)"},
 {"type": "supᵢ f₁ = supᵢ f₂",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} {p q : Prop}  {f₁ : p → α}  {f₂ : q → α}  (pq : p ↔ q)      (f : ∀ x, f₁ (pq.mpr x) = f₂ x) : supᵢ f₁ = supᵢ f₂ := by obtain rfl := propext pq; sorry",
  "name": "supᵢ_congr_Prop",
  "kind": "theorem",
  "first-tactic": "obtain rfl := propext pq",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} {p q : Prop}  {f₁ : p → α}  {f₂ : q → α}  (pq : p ↔ q)      (f : ∀ x, f₁ (pq.mpr x) = f₂ x) : supᵢ f₁ = supᵢ f₂",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} {p q : Prop}  {f₁ : p → α}  {f₂ : q → α}  (pq : p ↔ q)      (f : ∀ x, f₁ (pq.mpr x) = f₂ x)"},
 {"type": "(⨆ b : range f, g b) = ⨆ i, g (f i)",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} (g : β → α)  (f : ι → β) : (⨆ b : range f, g b) = ⨆ i, g (f i) := by rw [supᵢ]; sorry",
  "name": "supᵢ_range'",
  "kind": "theorem",
  "first-tactic": "rw [supᵢ]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} (g : β → α)  (f : ι → β) : (⨆ b : range f, g b) = ⨆ i, g (f i)",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} (g : β → α)  (f : ι → β)"},
 {"type": "supₛ (f '' s) = ⨆ a : s, f a",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} {s : Set β}  {f : β → α} : supₛ (f '' s) = ⨆ a : s, f a := by rw [supᵢ]; sorry",
  "name": "supₛ_image'",
  "kind": "theorem",
  "first-tactic": "rw [supᵢ]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} {s : Set β}  {f : β → α} : supₛ (f '' s) = ⨆ a : s, f a",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [SupSet α]  {f g : ι → α} {s : Set β}  {f : β → α}"},
 {"type": "(⨆ (i) (j), f i j) ≤ a ↔ ∀ i j, f i j ≤ a",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : ∀ i, κ i → α} : (⨆ (i) (j), f i j) ≤ a ↔ ∀ i j, f i j ≤ a := by simp_rw [supᵢ_le_iff]; sorry",
  "name": "supᵢ₂_le_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [supᵢ_le_iff]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : ∀ i, κ i → α} : (⨆ (i) (j), f i j) ≤ a ↔ ∀ i j, f i j ≤ a",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : ∀ i, κ i → α}"},
 {"type": "(a ≤ ⨅ (i) (j), f i j) ↔ ∀ i j, a ≤ f i j",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : ∀ i, κ i → α} : (a ≤ ⨅ (i) (j), f i j) ↔ ∀ i j, a ≤ f i j := by simp_rw [le_infᵢ_iff]; sorry",
  "name": "le_infᵢ₂_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [le_infᵢ_iff]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : ∀ i, κ i → α} : (a ≤ ⨅ (i) (j), f i j) ↔ ∀ i j, a ≤ f i j",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : ∀ i, κ i → α}"},
 {"type": "(⨆ a ∈ s, f a) ≤ f (supₛ s)",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice β]  {s : Set α}  {f : α → β}  (hf : Monotone f) : (⨆ a ∈ s, f a) ≤ f (supₛ s) := by rw [supₛ_eq_supᵢ]; sorry",
  "name": "Monotone.le_map_supₛ",
  "kind": "theorem",
  "first-tactic": "rw [supₛ_eq_supᵢ]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice β]  {s : Set α}  {f : α → β}  (hf : Monotone f) : (⨆ a ∈ s, f a) ≤ f (supₛ s)",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice β]  {s : Set α}  {f : α → β}  (hf : Monotone f)"},
 {"type": "f (supₛ s) = ⨆ a ∈ s, f a",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice β]  (f : α ≃o β)  (s : Set α) : f (supₛ s) = ⨆ a ∈ s, f a := by simp only [supₛ_eq_supᵢ]; sorry",
  "name": "OrderIso.map_supₛ",
  "kind": "theorem",
  "first-tactic": "simp only [supₛ_eq_supᵢ]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice β]  (f : α ≃o β)  (s : Set α) : f (supₛ s) = ⨆ a ∈ s, f a",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice β]  (f : α ≃o β)  (s : Set α)"},
 {"type": "f (supₛ s) ≤ ⨅ a ∈ s, f a",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice β]  {s : Set α}  {f : α → β}  (hf : Antitone f) : f (supₛ s) ≤ ⨅ a ∈ s, f a := by rw [supₛ_eq_supᵢ]; sorry",
  "name": "Antitone.map_supₛ_le",
  "kind": "theorem",
  "first-tactic": "rw [supₛ_eq_supᵢ]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice β]  {s : Set α}  {f : α → β}  (hf : Antitone f) : f (supₛ s) ≤ ⨅ a ∈ s, f a",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice β]  {s : Set α}  {f : α → β}  (hf : Antitone f)"},
 {"type": "(⨆ _b : ι, a) = a",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [Nonempty ι] : (⨆ _b : ι, a) = a := by rw [supᵢ]; sorry",
  "name": "supᵢ_const",
  "kind": "theorem",
  "first-tactic": "rw [supᵢ]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [Nonempty ι] : (⨆ _b : ι, a) = a",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [Nonempty ι]"},
 {"type": "(⨆ (i) (j), f i j) = ⊥ ↔ ∀ i j, f i j = ⊥",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : ∀ i, κ i → α} : (⨆ (i) (j), f i j) = ⊥ ↔ ∀ i j, f i j = ⊥ := by simp; sorry",
  "name": "supᵢ₂_eq_bot",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : ∀ i, κ i → α} : (⨆ (i) (j), f i j) = ⊥ ↔ ∀ i j, f i j = ⊥",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : ∀ i, κ i → α}"},
 {"type": "(⨅ (i) (j), f i j) = ⊤ ↔ ∀ i j, f i j = ⊤",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : ∀ i, κ i → α} : (⨅ (i) (j), f i j) = ⊤ ↔ ∀ i j, f i j = ⊤ := by simp; sorry",
  "name": "infᵢ₂_eq_top",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : ∀ i, κ i → α} : (⨅ (i) (j), f i j) = ⊤ ↔ ∀ i j, f i j = ⊤",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : ∀ i, κ i → α}"},
 {"type": "(⨆ h : p, a h) = if h : p then a h else ⊥",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {p : Prop}  [Decidable p]  (a : p → α) : (⨆ h : p, a h) = if h : p then a h else ⊥ := by by_cases p; sorry",
  "name": "supᵢ_eq_dif",
  "kind": "theorem",
  "first-tactic": "by_cases p",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {p : Prop}  [Decidable p]  (a : p → α) : (⨆ h : p, a h) = if h : p then a h else ⊥",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {p : Prop}  [Decidable p]  (a : p → α)"},
 {"type":
  "(⨆ (i₁) (j₁) (i₂) (j₂), f i₁ j₁ i₂ j₂) = ⨆ (i₂) (j₂) (i₁) (j₁), f i₁ j₁ i₂ j₂",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {ι₁ ι₂ : Sort _}  {κ₁ : ι₁ → Sort _}  {κ₂ : ι₂ → Sort _}      (f : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → α) : (⨆ (i₁) (j₁) (i₂) (j₂), f i₁ j₁ i₂ j₂) = ⨆ (i₂) (j₂) (i₁) (j₁), f i₁ j₁ i₂ j₂ := by simp only [@supᵢ_comm _ (κ₁ _)]; sorry",
  "name": "supᵢ₂_comm",
  "kind": "theorem",
  "first-tactic": "simp only [@supᵢ_comm _ (κ₁ _)]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {ι₁ ι₂ : Sort _}  {κ₁ : ι₁ → Sort _}  {κ₂ : ι₂ → Sort _}      (f : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → α) : (⨆ (i₁) (j₁) (i₂) (j₂), f i₁ j₁ i₂ j₂) = ⨆ (i₂) (j₂) (i₁) (j₁), f i₁ j₁ i₂ j₂",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {ι₁ ι₂ : Sort _}  {κ₁ : ι₁ → Sort _}  {κ₂ : ι₂ → Sort _}      (f : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → α)"},
 {"type":
  "(⨅ (i₁) (j₁) (i₂) (j₂), f i₁ j₁ i₂ j₂) = ⨅ (i₂) (j₂) (i₁) (j₁), f i₁ j₁ i₂ j₂",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {ι₁ ι₂ : Sort _}  {κ₁ : ι₁ → Sort _}  {κ₂ : ι₂ → Sort _}      (f : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → α) : (⨅ (i₁) (j₁) (i₂) (j₂), f i₁ j₁ i₂ j₂) = ⨅ (i₂) (j₂) (i₁) (j₁), f i₁ j₁ i₂ j₂ := by simp only [@infᵢ_comm _ (κ₁ _)]; sorry",
  "name": "infᵢ₂_comm",
  "kind": "theorem",
  "first-tactic": "simp only [@infᵢ_comm _ (κ₁ _)]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {ι₁ ι₂ : Sort _}  {κ₁ : ι₁ → Sort _}  {κ₂ : ι₂ → Sort _}      (f : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → α) : (⨅ (i₁) (j₁) (i₂) (j₂), f i₁ j₁ i₂ j₂) = ⨅ (i₂) (j₂) (i₁) (j₁), f i₁ j₁ i₂ j₂",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  [CompleteLinearOrder α]  {s t : Set α}  {a b : α}  [CompleteLattice α]  {f g s t : ι → α}  {a b : α}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {ι₁ ι₂ : Sort _}  {κ₁ : ι₁ → Sort _}  {κ₂ : ι₂ → Sort _}      (f : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → α)"},
 {"type": "(⨆ i ∈ s, a) = a",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {ι : Sort _}  {a : α}  {s : Set ι}  (hs : s.Nonempty) : (⨆ i ∈ s, a) = a := by haveI : Nonempty s := Set.nonempty_coe_sort.mpr hs; sorry",
  "name": "bsupᵢ_const",
  "kind": "theorem",
  "first-tactic": "haveI : Nonempty s := Set.nonempty_coe_sort.mpr hs",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {ι : Sort _}  {a : α}  {s : Set ι}  (hs : s.Nonempty) : (⨆ i ∈ s, a) = a",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {ι : Sort _}  {a : α}  {s : Set ι}  (hs : s.Nonempty)"},
 {"type": "(⨆ x, f x) ⊔ a = ⨆ x, f x ⊔ a",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} [Nonempty ι]  {f : ι → α}  {a : α} : (⨆ x, f x) ⊔ a = ⨆ x, f x ⊔ a := by rw [supᵢ_sup_eq]; sorry",
  "name": "supᵢ_sup",
  "kind": "theorem",
  "first-tactic": "rw [supᵢ_sup_eq]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} [Nonempty ι]  {f : ι → α}  {a : α} : (⨆ x, f x) ⊔ a = ⨆ x, f x ⊔ a",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} [Nonempty ι]  {f : ι → α}  {a : α}"},
 {"type": "(⨅ x, f x) ⊓ a = ⨅ x, f x ⊓ a",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} [Nonempty ι]  {f : ι → α}  {a : α} : (⨅ x, f x) ⊓ a = ⨅ x, f x ⊓ a := by rw [infᵢ_inf_eq]; sorry",
  "name": "infᵢ_inf",
  "kind": "theorem",
  "first-tactic": "rw [infᵢ_inf_eq]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} [Nonempty ι]  {f : ι → α}  {a : α} : (⨅ x, f x) ⊓ a = ⨅ x, f x ⊓ a",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} [Nonempty ι]  {f : ι → α}  {a : α}"},
 {"type": "(a ⊔ ⨆ x, f x) = ⨆ x, a ⊔ f x",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} [Nonempty ι]  {f : ι → α}  {a : α} : (a ⊔ ⨆ x, f x) = ⨆ x, a ⊔ f x := by rw [supᵢ_sup_eq]; sorry",
  "name": "sup_supᵢ",
  "kind": "theorem",
  "first-tactic": "rw [supᵢ_sup_eq]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} [Nonempty ι]  {f : ι → α}  {a : α} : (a ⊔ ⨆ x, f x) = ⨆ x, a ⊔ f x",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} [Nonempty ι]  {f : ι → α}  {a : α}"},
 {"type": "(a ⊓ ⨅ x, f x) = ⨅ x, a ⊓ f x",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} [Nonempty ι]  {f : ι → α}  {a : α} : (a ⊓ ⨅ x, f x) = ⨅ x, a ⊓ f x := by rw [infᵢ_inf_eq]; sorry",
  "name": "inf_infᵢ",
  "kind": "theorem",
  "first-tactic": "rw [infᵢ_inf_eq]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} [Nonempty ι]  {f : ι → α}  {a : α} : (a ⊓ ⨅ x, f x) = ⨅ x, a ⊓ f x",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} [Nonempty ι]  {f : ι → α}  {a : α}"},
 {"type": "(⨆ (i) (h : p i), f i h) ⊔ a = ⨆ (i) (h : p i), f i h ⊔ a",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {p : ι → Prop}  {f : ∀ i, p i → α}  {a : α}  (h : ∃ i, p i) : (⨆ (i) (h : p i), f i h) ⊔ a = ⨆ (i) (h : p i), f i h ⊔ a := by haveI : Nonempty { i // p i } :=\n      let ⟨i, hi⟩ := h\n      ⟨⟨i, hi⟩⟩; sorry",
  "name": "bsupᵢ_sup",
  "kind": "theorem",
  "first-tactic":
  "haveI : Nonempty { i // p i } :=\n      let ⟨i, hi⟩ := h\n      ⟨⟨i, hi⟩⟩",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {p : ι → Prop}  {f : ∀ i, p i → α}  {a : α}  (h : ∃ i, p i) : (⨆ (i) (h : p i), f i h) ⊔ a = ⨆ (i) (h : p i), f i h ⊔ a",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {p : ι → Prop}  {f : ∀ i, p i → α}  {a : α}  (h : ∃ i, p i)"},
 {"type": "(a ⊔ ⨆ (i) (h : p i), f i h) = ⨆ (i) (h : p i), a ⊔ f i h",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {p : ι → Prop}  {f : ∀ i, p i → α}  {a : α}  (h : ∃ i, p i) : (a ⊔ ⨆ (i) (h : p i), f i h) = ⨆ (i) (h : p i), a ⊔ f i h := by simpa only [sup_comm] using @bsupᵢ_sup α _ _ p _ _ h; sorry",
  "name": "sup_bsupᵢ",
  "kind": "theorem",
  "first-tactic": "simpa only [sup_comm] using @bsupᵢ_sup α _ _ p _ _ h",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {p : ι → Prop}  {f : ∀ i, p i → α}  {a : α}  (h : ∃ i, p i) : (a ⊔ ⨆ (i) (h : p i), f i h) = ⨆ (i) (h : p i), a ⊔ f i h",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {p : ι → Prop}  {f : ∀ i, p i → α}  {a : α}  (h : ∃ i, p i)"},
 {"type": "supᵢ s = ⊥",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {s : False → α} : supᵢ s = ⊥ := by simp; sorry",
  "name": "supᵢ_false",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {s : False → α} : supᵢ s = ⊥",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {s : False → α}"},
 {"type": "infᵢ s = ⊤",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {s : False → α} : infᵢ s = ⊤ := by simp; sorry",
  "name": "infᵢ_false",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {s : False → α} : infᵢ s = ⊤",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {s : False → α}"},
 {"type":
  "(⨆ i, if h : p i then f i h else g i h) = (⨆ (i) (h : p i), f i h) ⊔ ⨆ (i) (h : ¬p i), g i h",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  (p : ι → Prop)  [DecidablePred p] (f : ∀ i, p i → α)  (g : ∀ i, ¬p i → α) : (⨆ i, if h : p i then f i h else g i h) = (⨆ (i) (h : p i), f i h) ⊔ ⨆ (i) (h : ¬p i), g i h := by rw [← supᵢ_sup_eq]; sorry",
  "name": "supᵢ_dite",
  "kind": "theorem",
  "first-tactic": "rw [← supᵢ_sup_eq]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  (p : ι → Prop)  [DecidablePred p] (f : ∀ i, p i → α)  (g : ∀ i, ¬p i → α) : (⨆ i, if h : p i then f i h else g i h) = (⨆ (i) (h : p i), f i h) ⊔ ⨆ (i) (h : ¬p i), g i h",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _}  (p : ι → Prop)  [DecidablePred p] (f : ∀ i, p i → α)  (g : ∀ i, ¬p i → α)"},
 {"type": "(⨆ b ∈ range f, g b) = ⨆ i, g (f i)",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {g : β → α}  {f : ι → β} : (⨆ b ∈ range f, g b) = ⨆ i, g (f i) := by rw [← supᵢ_subtype'']; sorry",
  "name": "supᵢ_range",
  "kind": "theorem",
  "first-tactic": "rw [← supᵢ_subtype'']",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {g : β → α}  {f : ι → β} : (⨆ b ∈ range f, g b) = ⨆ i, g (f i)",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {g : β → α}  {f : ι → β}"},
 {"type": "supₛ (f '' s) = ⨆ a ∈ s, f a",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set β}  {f : β → α} : supₛ (f '' s) = ⨆ a ∈ s, f a := by rw [← supᵢ_subtype'']; sorry",
  "name": "supₛ_image",
  "kind": "theorem",
  "first-tactic": "rw [← supᵢ_subtype'']",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set β}  {f : β → α} : supₛ (f '' s) = ⨆ a ∈ s, f a",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set β}  {f : β → α}"},
 {"type": "(⨆ x ∈ (∅ : Set β), f x) = ⊥",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α} : (⨆ x ∈ (∅ : Set β), f x) = ⊥ := by simp; sorry",
  "name": "supᵢ_emptyset",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α} : (⨆ x ∈ (∅ : Set β), f x) = ⊥",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}"},
 {"type": "(⨅ x ∈ (∅ : Set β), f x) = ⊤",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α} : (⨅ x ∈ (∅ : Set β), f x) = ⊤ := by simp; sorry",
  "name": "infᵢ_emptyset",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α} : (⨅ x ∈ (∅ : Set β), f x) = ⊤",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}"},
 {"type": "(⨆ x ∈ (univ : Set β), f x) = ⨆ x, f x",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α} : (⨆ x ∈ (univ : Set β), f x) = ⨆ x, f x := by simp; sorry",
  "name": "supᵢ_univ",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α} : (⨆ x ∈ (univ : Set β), f x) = ⨆ x, f x",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}"},
 {"type": "(⨅ x ∈ (univ : Set β), f x) = ⨅ x, f x",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α} : (⨅ x ∈ (univ : Set β), f x) = ⨅ x, f x := by simp; sorry",
  "name": "infᵢ_univ",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α} : (⨅ x ∈ (univ : Set β), f x) = ⨅ x, f x",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}"},
 {"type": "(⨆ x ∈ s ∪ t, f x) = (⨆ x ∈ s, f x) ⊔ ⨆ x ∈ t, f x",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}  {s t : Set β} : (⨆ x ∈ s ∪ t, f x) = (⨆ x ∈ s, f x) ⊔ ⨆ x ∈ t, f x := by simp_rw [mem_union]; sorry",
  "name": "supᵢ_union",
  "kind": "theorem",
  "first-tactic": "simp_rw [mem_union]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}  {s t : Set β} : (⨆ x ∈ s ∪ t, f x) = (⨆ x ∈ s, f x) ⊔ ⨆ x ∈ t, f x",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}  {s t : Set β}"},
 {"type": "(⨆ i, f i) = (⨆ (i) (_h : p i), f i) ⊔ ⨆ (i) (_h : ¬p i), f i",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (f : β → α)  (p : β → Prop) : (⨆ i, f i) = (⨆ (i) (_h : p i), f i) ⊔ ⨆ (i) (_h : ¬p i), f i := by simpa [Classical.em] using @supᵢ_union _ _ _ f { i | p i } { i | ¬p i }; sorry",
  "name": "supᵢ_split",
  "kind": "theorem",
  "first-tactic":
  "simpa [Classical.em] using @supᵢ_union _ _ _ f { i | p i } { i | ¬p i }",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (f : β → α)  (p : β → Prop) : (⨆ i, f i) = (⨆ (i) (_h : p i), f i) ⊔ ⨆ (i) (_h : ¬p i), f i",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (f : β → α)  (p : β → Prop)"},
 {"type": "(⨆ i, f i) = f i₀ ⊔ ⨆ (i) (_h : i ≠ i₀), f i",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (f : β → α)  (i₀ : β) : (⨆ i, f i) = f i₀ ⊔ ⨆ (i) (_h : i ≠ i₀), f i := by convert supᵢ_split f (fun i => i = i₀); sorry",
  "name": "supᵢ_split_single",
  "kind": "theorem",
  "first-tactic": "convert supᵢ_split f (fun i => i = i₀)",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (f : β → α)  (i₀ : β) : (⨆ i, f i) = f i₀ ⊔ ⨆ (i) (_h : i ≠ i₀), f i",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (f : β → α)  (i₀ : β)"},
 {"type": "(⨆ x ∈ (singleton b : Set β), f x) = f b",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}  {b : β} : (⨆ x ∈ (singleton b : Set β), f x) = f b := by simp; sorry",
  "name": "supᵢ_singleton",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}  {b : β} : (⨆ x ∈ (singleton b : Set β), f x) = f b",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}  {b : β}"},
 {"type": "(⨅ x ∈ (singleton b : Set β), f x) = f b",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}  {b : β} : (⨅ x ∈ (singleton b : Set β), f x) = f b := by simp; sorry",
  "name": "infᵢ_singleton",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}  {b : β} : (⨅ x ∈ (singleton b : Set β), f x) = f b",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}  {b : β}"},
 {"type": "(⨆ x ∈ ({a, b} : Set β), f x) = f a ⊔ f b",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}  {a b : β} : (⨆ x ∈ ({a, b} : Set β), f x) = f a ⊔ f b := by rw [supᵢ_insert]; sorry",
  "name": "supᵢ_pair",
  "kind": "theorem",
  "first-tactic": "rw [supᵢ_insert]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}  {a b : β} : (⨆ x ∈ ({a, b} : Set β), f x) = f a ⊔ f b",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}  {a b : β}"},
 {"type": "(⨅ x ∈ ({a, b} : Set β), f x) = f a ⊓ f b",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}  {a b : β} : (⨅ x ∈ ({a, b} : Set β), f x) = f a ⊓ f b := by rw [infᵢ_insert]; sorry",
  "name": "infᵢ_pair",
  "kind": "theorem",
  "first-tactic": "rw [infᵢ_insert]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}  {a b : β} : (⨅ x ∈ ({a, b} : Set β), f x) = f a ⊓ f b",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → α}  {a b : β}"},
 {"type": "(⨆ j, extend e f ⊥ j) = ⨆ i, f i",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {e : ι → β}  (he : Injective e)  (f : ι → α) : (⨆ j, extend e f ⊥ j) = ⨆ i, f i := by rw [supᵢ_split _ fun j => ∃ i]; sorry",
  "name": "supᵢ_extend_bot",
  "kind": "theorem",
  "first-tactic": "rw [supᵢ_split _ fun j => ∃ i]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {e : ι → β}  (he : Injective e)  (f : ι → α) : (⨆ j, extend e f ⊥ j) = ⨆ i, f i",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {e : ι → β}  (he : Injective e)  (f : ι → α)"},
 {"type": "(⨆ b : Bool, f b) = f true ⊔ f false",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : Bool → α} : (⨆ b : Bool, f b) = f true ⊔ f false := by rw [supᵢ]; sorry",
  "name": "supᵢ_bool_eq",
  "kind": "theorem",
  "first-tactic": "rw [supᵢ]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : Bool → α} : (⨆ b : Bool, f b) = f true ⊔ f false",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : Bool → α}"},
 {"type": "x ⊔ y = ⨆ b : Bool, cond b x y",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (x y : α) : x ⊔ y = ⨆ b : Bool, cond b x y := by rw [supᵢ_bool_eq]; sorry",
  "name": "sup_eq_supᵢ",
  "kind": "theorem",
  "first-tactic": "rw [supᵢ_bool_eq]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (x y : α) : x ⊔ y = ⨆ b : Bool, cond b x y",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (x y : α)"},
 {"type": "IsGLB (f '' s) (⨅ x ∈ s, f x)",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set β}  {f : β → α} : IsGLB (f '' s) (⨅ x ∈ s, f x) := by simpa only [range_comp]; sorry",
  "name": "isGLB_binfᵢ",
  "kind": "theorem",
  "first-tactic": "simpa only [range_comp]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set β}  {f : β → α} : IsGLB (f '' s) (⨅ x ∈ s, f x)",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set β}  {f : β → α}"},
 {"type": "IsLUB (f '' s) (⨆ x ∈ s, f x)",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set β}  {f : β → α} : IsLUB (f '' s) (⨆ x ∈ s, f x) := by simpa only [range_comp]; sorry",
  "name": "isLUB_bsupᵢ",
  "kind": "theorem",
  "first-tactic": "simpa only [range_comp]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set β}  {f : β → α} : IsLUB (f '' s) (⨆ x ∈ s, f x)",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {s : Set β}  {f : β → α}"},
 {"type": "(⨆ x ∈ s ×ˢ t, f x) = ⨆ (a ∈ s) (b ∈ t), f (a, b)",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β × γ → α}  {s : Set β}  {t : Set γ} : (⨆ x ∈ s ×ˢ t, f x) = ⨆ (a ∈ s) (b ∈ t), f (a, b) := by simp_rw [supᵢ_prod]; sorry",
  "name": "bsupᵢ_prod",
  "kind": "theorem",
  "first-tactic": "simp_rw [supᵢ_prod]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β × γ → α}  {s : Set β}  {t : Set γ} : (⨆ x ∈ s ×ˢ t, f x) = ⨆ (a ∈ s) (b ∈ t), f (a, b)",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β × γ → α}  {s : Set β}  {t : Set γ}"},
 {"type": "(⨆ o : Option β, o.elim a f) = a ⊔ ⨆ b, f b",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (a : α)  (f : β → α) : (⨆ o : Option β, o.elim a f) = a ⊔ ⨆ b, f b := by simp [supᵢ_option]; sorry",
  "name": "supᵢ_option_elim",
  "kind": "theorem",
  "first-tactic": "simp [supᵢ_option]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (a : α)  (f : β → α) : (⨆ o : Option β, o.elim a f) = a ⊔ ⨆ b, f b",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (a : α)  (f : β → α)"},
 {"type": "(⨆ i : { i // f i ≠ ⊥ }, f i) = ⨆ i, f i",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (f : ι → α) : (⨆ i : { i // f i ≠ ⊥ }, f i) = ⨆ i, f i := by by_cases htriv : ∀ i, f i = ⊥; sorry",
  "name": "supᵢ_ne_bot_subtype",
  "kind": "theorem",
  "first-tactic": "by_cases htriv : ∀ i, f i = ⊥",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (f : ι → α) : (⨆ i : { i // f i ≠ ⊥ }, f i) = ⨆ i, f i",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (f : ι → α)"},
 {"type": "supₛ (image2 f s t) = ⨆ (a ∈ s) (b ∈ t), f a b",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → γ → α}  {s : Set β}  {t : Set γ} : supₛ (image2 f s t) = ⨆ (a ∈ s) (b ∈ t), f a b := by rw [← image_prod]; sorry",
  "name": "supₛ_image2",
  "kind": "theorem",
  "first-tactic": "rw [← image_prod]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → γ → α}  {s : Set β}  {t : Set γ} : supₛ (image2 f s t) = ⨆ (a ∈ s) (b ∈ t), f a b",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → γ → α}  {s : Set β}  {t : Set γ}"},
 {"type": "infₛ (image2 f s t) = ⨅ (a ∈ s) (b ∈ t), f a b",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → γ → α}  {s : Set β}  {t : Set γ} : infₛ (image2 f s t) = ⨅ (a ∈ s) (b ∈ t), f a b := by rw [← image_prod]; sorry",
  "name": "infₛ_image2",
  "kind": "theorem",
  "first-tactic": "rw [← image_prod]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → γ → α}  {s : Set β}  {t : Set γ} : infₛ (image2 f s t) = ⨅ (a ∈ s) (b ∈ t), f a b",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} {f : β → γ → α}  {s : Set β}  {t : Set γ}"},
 {"type": "(⨆ i ≥ n, u i) = ⨆ i, u (i + n)",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (u : ℕ → α)  (n : ℕ) : (⨆ i ≥ n, u i) = ⨆ i, u (i + n) := by apply le_antisymm; sorry",
  "name": "supᵢ_ge_eq_supᵢ_nat_add",
  "kind": "theorem",
  "first-tactic": "apply le_antisymm",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (u : ℕ → α)  (n : ℕ) : (⨆ i ≥ n, u i) = ⨆ i, u (i + n)",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (u : ℕ → α)  (n : ℕ)"},
 {"type": "(⨆ n, ⨅ i ≥ n, f (i + k)) = ⨆ n, ⨅ i ≥ n, f i",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (f : ℕ → α)  (k : ℕ) : (⨆ n, ⨅ i ≥ n, f (i + k)) = ⨆ n, ⨅ i ≥ n, f i := by have hf : Monotone fun n => ⨅ i ≥ n, f i := fun n m h => binfᵢ_mono fun i => h.trans; sorry",
  "name": "supᵢ_infᵢ_ge_nat_add",
  "kind": "theorem",
  "first-tactic":
  "have hf : Monotone fun n => ⨅ i ≥ n, f i := fun n m h => binfᵢ_mono fun i => h.trans",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (f : ℕ → α)  (k : ℕ) : (⨆ n, ⨅ i ≥ n, f (i + k)) = ⨆ n, ⨅ i ≥ n, f i",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (f : ℕ → α)  (k : ℕ)"},
 {"type": "(⨅ i > 0, f i) = ⨅ i, f (i + 1)",
  "tactic-prompt":
  "theorem {α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (f : ℕ → α) : (⨅ i > 0, f i) = ⨅ i, f (i + 1) := by rw [← infᵢ_range]; sorry",
  "name": "infᵢ_nat_gt_zero_eq",
  "kind": "theorem",
  "first-tactic": "rw [← infᵢ_range]",
  "core-prompt":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (f : ℕ → α) : (⨅ i > 0, f i) = ⨅ i, f (i + 1)",
  "args":
  "{α β β₂ γ : Type _}  {ι ι' : Sort _}  {κ : ι → Sort _}  {κ' : ι' → Sort _} (f : ℕ → α)"},
 {"type": "supᵢ f = ⊤ ↔ ∀ b < ⊤, ∃ i, b < f i",
  "tactic-prompt":
  "theorem [CompleteLinearOrder α] (f : ι → α) : supᵢ f = ⊤ ↔ ∀ b < ⊤, ∃ i, b < f i := by simp only [← supₛ_range]; sorry",
  "name": "supᵢ_eq_top",
  "kind": "theorem",
  "first-tactic": "simp only [← supₛ_range]",
  "core-prompt":
  "[CompleteLinearOrder α] (f : ι → α) : supᵢ f = ⊤ ↔ ∀ b < ⊤, ∃ i, b < f i",
  "args": "[CompleteLinearOrder α] (f : ι → α)"},
 {"type": "infᵢ f = ⊥ ↔ ∀ b > ⊥, ∃ i, f i < b",
  "tactic-prompt":
  "theorem [CompleteLinearOrder α] (f : ι → α) : infᵢ f = ⊥ ↔ ∀ b > ⊥, ∃ i, f i < b := by simp only [← infₛ_range]; sorry",
  "name": "infᵢ_eq_bot",
  "kind": "theorem",
  "first-tactic": "simp only [← infₛ_range]",
  "core-prompt":
  "[CompleteLinearOrder α] (f : ι → α) : infᵢ f = ⊥ ↔ ∀ b > ⊥, ∃ i, f i < b",
  "args": "[CompleteLinearOrder α] (f : ι → α)"},
 {"type": "(⨆ i, f i) a = ⨆ i, f i a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : α → Type _}  {ι : Sort _}  [∀ i, SupSet (β i)]  {f : ι → ∀ a, β a}      {a : α} : (⨆ i, f i) a = ⨆ i, f i a := by rw [supᵢ]; sorry",
  "name": "supᵢ_apply",
  "kind": "theorem",
  "first-tactic": "rw [supᵢ]",
  "core-prompt":
  "{α : Type _}  {β : α → Type _}  {ι : Sort _}  [∀ i, SupSet (β i)]  {f : ι → ∀ a, β a}      {a : α} : (⨆ i, f i) a = ⨆ i, f i a",
  "args":
  "{α : Type _}  {β : α → Type _}  {ι : Sort _}  [∀ i, SupSet (β i)]  {f : ι → ∀ a, β a}      {a : α}"},
 {"type": "supₛ s a ↔ ∃ r : α → Prop, r ∈ s ∧ r a",
  "tactic-prompt":
  "theorem {α : Type _}  (s : Set (α → Prop))  {a : α} : supₛ s a ↔ ∃ r : α → Prop, r ∈ s ∧ r a := by rw [supₛ_apply]; sorry",
  "name": "unary_relation_supₛ_iff",
  "kind": "theorem",
  "first-tactic": "rw [supₛ_apply]",
  "core-prompt":
  "{α : Type _}  (s : Set (α → Prop))  {a : α} : supₛ s a ↔ ∃ r : α → Prop, r ∈ s ∧ r a",
  "args": "{α : Type _}  (s : Set (α → Prop))  {a : α}"},
 {"type": "infₛ s a ↔ ∀ r : α → Prop, r ∈ s → r a",
  "tactic-prompt":
  "theorem {α : Type _}  (s : Set (α → Prop))  {a : α} : infₛ s a ↔ ∀ r : α → Prop, r ∈ s → r a := by rw [infₛ_apply]; sorry",
  "name": "unary_relation_infₛ_iff",
  "kind": "theorem",
  "first-tactic": "rw [infₛ_apply]",
  "core-prompt":
  "{α : Type _}  (s : Set (α → Prop))  {a : α} : infₛ s a ↔ ∀ r : α → Prop, r ∈ s → r a",
  "args": "{α : Type _}  (s : Set (α → Prop))  {a : α}"},
 {"type": "supₛ s a b ↔ ∃ r : α → β → Prop, r ∈ s ∧ r a b",
  "tactic-prompt":
  "theorem {α β : Type _}  (s : Set (α → β → Prop))  {a : α}  {b : β} : supₛ s a b ↔ ∃ r : α → β → Prop, r ∈ s ∧ r a b := by rw [supₛ_apply]; sorry",
  "name": "binary_relation_supₛ_iff",
  "kind": "theorem",
  "first-tactic": "rw [supₛ_apply]",
  "core-prompt":
  "{α β : Type _}  (s : Set (α → β → Prop))  {a : α}  {b : β} : supₛ s a b ↔ ∃ r : α → β → Prop, r ∈ s ∧ r a b",
  "args": "{α β : Type _}  (s : Set (α → β → Prop))  {a : α}  {b : β}"},
 {"type": "infₛ s a b ↔ ∀ r : α → β → Prop, r ∈ s → r a b",
  "tactic-prompt":
  "theorem {α β : Type _}  (s : Set (α → β → Prop))  {a : α}  {b : β} : infₛ s a b ↔ ∀ r : α → β → Prop, r ∈ s → r a b := by rw [infₛ_apply]; sorry",
  "name": "binary_relation_infₛ_iff",
  "kind": "theorem",
  "first-tactic": "rw [infₛ_apply]",
  "core-prompt":
  "{α β : Type _}  (s : Set (α → β → Prop))  {a : α}  {b : β} : infₛ s a b ↔ ∀ r : α → β → Prop, r ∈ s → r a b",
  "args": "{α β : Type _}  (s : Set (α → β → Prop))  {a : α}  {b : β}"},
 {"type": "Acc s (f a) → Acc r a",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop}  {u : δ → δ → Prop} {F : Type _} [RelHomClass F r s]  (f : F)  (a : α) : Acc s (f a) → Acc r a := by generalize h : f a = b; sorry",
  "name": "acc",
  "kind": "theorem",
  "first-tactic": "generalize h : f a = b",
  "core-prompt":
  "{α β γ δ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop}  {u : δ → δ → Prop} {F : Type _} [RelHomClass F r s]  (f : F)  (a : α) : Acc s (f a) → Acc r a",
  "args":
  "{α β γ δ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop}  {u : δ → δ → Prop} {F : Type _} [RelHomClass F r s]  (f : F)  (a : α)"},
 {"type": "Injective f",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop}  {u : δ → δ → Prop} {F : Type _} (r : α → α → Prop)  (s : β → β → Prop)  [IsTrichotomous α r]      [IsIrrefl β s]  (f : α → β)  (hf : ∀ {x y}, r x y → s (f x) (f y)) : Injective f := by intro x y hxy; sorry",
  "name": "injective_of_increasing",
  "kind": "theorem",
  "first-tactic": "intro x y hxy",
  "core-prompt":
  "{α β γ δ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop}  {u : δ → δ → Prop} {F : Type _} (r : α → α → Prop)  (s : β → β → Prop)  [IsTrichotomous α r]      [IsIrrefl β s]  (f : α → β)  (hf : ∀ {x y}, r x y → s (f x) (f y)) : Injective f",
  "args":
  "{α β γ δ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop}  {u : δ → δ → Prop} {F : Type _} (r : α → α → Prop)  (s : β → β → Prop)  [IsTrichotomous α r]      [IsIrrefl β s]  (f : α → β)  (hf : ∀ {x y}, r x y → s (f x) (f y))"},
 {"type": "r = f ⁻¹'o s",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop}  {u : δ → δ → Prop} {F : Type _} (f : r ↪r s) : r = f ⁻¹'o s := by ext (a b); sorry",
  "name": "eq_preimage",
  "kind": "theorem",
  "first-tactic": "ext (a b)",
  "core-prompt":
  "{α β γ δ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop}  {u : δ → δ → Prop} {F : Type _} (f : r ↪r s) : r = f ⁻¹'o s",
  "args":
  "{α β γ δ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop}  {u : δ → δ → Prop} {F : Type _} (f : r ↪r s)"},
 {"type": "Acc s (f a) → Acc r a",
  "tactic-prompt":
  "theorem {α β γ δ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop}  {u : δ → δ → Prop} {F : Type _} (f : r ↪r s)  (a : α) : Acc s (f a) → Acc r a := by generalize h : f a = b; sorry",
  "name": "acc",
  "kind": "theorem",
  "first-tactic": "generalize h : f a = b",
  "core-prompt":
  "{α β γ δ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop}  {u : δ → δ → Prop} {F : Type _} (f : r ↪r s)  (a : α) : Acc s (f a) → Acc r a",
  "args":
  "{α β γ δ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop}  {u : δ → δ → Prop} {F : Type _} (f : r ↪r s)  (a : α)"},
 {"type": "r ↪r s",
  "tactic-prompt":
  "def {α β γ δ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop}  {u : δ → δ → Prop} {F : Type _} [IsTrichotomous α r]  [IsAsymm β s]  (f : α → β)  (H : ∀ a b, r a b → s (f a) (f b)) : r ↪r s := by haveI := @IsAsymm.isIrrefl β s _; sorry",
  "name": "ofMonotone",
  "kind": "def",
  "first-tactic": "haveI := @IsAsymm.isIrrefl β s _",
  "core-prompt":
  "{α β γ δ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop}  {u : δ → δ → Prop} {F : Type _} [IsTrichotomous α r]  [IsAsymm β s]  (f : α → β)  (H : ∀ a b, r a b → s (f a) (f b)) : r ↪r s",
  "args":
  "{α β γ δ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop}  {u : δ → δ → Prop} {F : Type _} [IsTrichotomous α r]  [IsAsymm β s]  (f : α → β)  (H : ∀ a b, r a b → s (f a) (f b))"},
 {"type": "EquivLike.inv f b ≤ a ↔ b ≤ f a",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β]   [LE α]  [LE β]  [OrderIsoClass F α β]  -- Porting note: needed to add explicit arguments to map_le_map_iff (f : F)  {a : α}  {b : β} : EquivLike.inv f b ≤ a ↔ b ≤ f a := by convert (@map_le_map_iff _ _ _ _ _ _ f (EquivLike.inv f b) a).symm; sorry",
  "name": "map_inv_le_iff",
  "kind": "theorem",
  "first-tactic":
  "convert (@map_le_map_iff _ _ _ _ _ _ f (EquivLike.inv f b) a).symm",
  "core-prompt":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β]   [LE α]  [LE β]  [OrderIsoClass F α β]  -- Porting note: needed to add explicit arguments to map_le_map_iff (f : F)  {a : α}  {b : β} : EquivLike.inv f b ≤ a ↔ b ≤ f a",
  "args":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β]   [LE α]  [LE β]  [OrderIsoClass F α β]  -- Porting note: needed to add explicit arguments to map_le_map_iff (f : F)  {a : α}  {b : β}"},
 {"type": "a ≤ EquivLike.inv f b ↔ f a ≤ b",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β]   [LE α]  [LE β]  [OrderIsoClass F α β]  -- Porting note: needed to add explicit arguments to map_le_map_iff (f : F)  {a : α}  {b : β} : a ≤ EquivLike.inv f b ↔ f a ≤ b := by convert (@map_le_map_iff _ _ _ _ _ _ f a (EquivLike.inv f b)).symm; sorry",
  "name": "le_map_inv_iff",
  "kind": "theorem",
  "first-tactic":
  "convert (@map_le_map_iff _ _ _ _ _ _ f a (EquivLike.inv f b)).symm",
  "core-prompt":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β]   [LE α]  [LE β]  [OrderIsoClass F α β]  -- Porting note: needed to add explicit arguments to map_le_map_iff (f : F)  {a : α}  {b : β} : a ≤ EquivLike.inv f b ↔ f a ≤ b",
  "args":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β]   [LE α]  [LE β]  [OrderIsoClass F α β]  -- Porting note: needed to add explicit arguments to map_le_map_iff (f : F)  {a : α}  {b : β}"},
 {"type": "EquivLike.inv f b < a ↔ b < f a",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β]  [Preorder α]  [Preorder β]  [OrderIsoClass F α β] (f : F)  {a : α}  {b : β} : EquivLike.inv f b < a ↔ b < f a := by rw [← map_lt_map_iff f]; sorry",
  "name": "map_inv_lt_iff",
  "kind": "theorem",
  "first-tactic": "rw [← map_lt_map_iff f]",
  "core-prompt":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β]  [Preorder α]  [Preorder β]  [OrderIsoClass F α β] (f : F)  {a : α}  {b : β} : EquivLike.inv f b < a ↔ b < f a",
  "args":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β]  [Preorder α]  [Preorder β]  [OrderIsoClass F α β] (f : F)  {a : α}  {b : β}"},
 {"type": "a < EquivLike.inv f b ↔ f a < b",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β]  [Preorder α]  [Preorder β]  [OrderIsoClass F α β] (f : F)  {a : α}  {b : β} : a < EquivLike.inv f b ↔ f a < b := by rw [← map_lt_map_iff f]; sorry",
  "name": "lt_map_inv_iff",
  "kind": "theorem",
  "first-tactic": "rw [← map_lt_map_iff f]",
  "core-prompt":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β]  [Preorder α]  [Preorder β]  [OrderIsoClass F α β] (f : F)  {a : α}  {b : β} : a < EquivLike.inv f b ↔ f a < b",
  "args":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β]  [Preorder α]  [Preorder β]  [OrderIsoClass F α β] (f : F)  {a : α}  {b : β}"},
 {"type": "comp f id = f",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] (f : α →o β) : comp f id = f := by ext; sorry",
  "name": "comp_id",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] (f : α →o β) : comp f id = f",
  "args":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] (f : α →o β)"},
 {"type": "comp id f = f",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] (f : α →o β) : comp id f = f := by ext; sorry",
  "name": "id_comp",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] (f : α →o β) : comp id f = f",
  "args":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] (f : α →o β)"},
 {"type": "(fst : α × β →o α).prod snd = id",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] : (fst : α × β →o α).prod snd = id := by ext ⟨x, y⟩ : 2; sorry",
  "name": "fst_prod_snd",
  "kind": "theorem",
  "first-tactic": "ext ⟨x, y⟩ : 2",
  "core-prompt":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] : (fst : α × β →o α).prod snd = id",
  "args":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ]"},
 {"type": "e.symm.symm = e",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β)  [LE α]  [LE β]  [LE γ] (e : α ≃o β) : e.symm.symm = e := by ext; sorry",
  "name": "symm_symm",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β)  [LE α]  [LE β]  [LE γ] (e : α ≃o β) : e.symm.symm = e",
  "args":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β)  [LE α]  [LE β]  [LE γ] (e : α ≃o β)"},
 {"type": "(refl α).trans e = e",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β)  [LE α]  [LE β]  [LE γ] (e : α ≃o β) : (refl α).trans e = e := by ext x; sorry",
  "name": "refl_trans",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β)  [LE α]  [LE β]  [LE γ] (e : α ≃o β) : (refl α).trans e = e",
  "args":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β)  [LE α]  [LE β]  [LE γ] (e : α ≃o β)"},
 {"type": "e.trans (refl β) = e",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β)  [LE α]  [LE β]  [LE γ] (e : α ≃o β) : e.trans (refl β) = e := by ext x; sorry",
  "name": "trans_refl",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β)  [LE α]  [LE β]  [LE γ] (e : α ≃o β) : e.trans (refl β) = e",
  "args":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β)  [LE α]  [LE β]  [LE γ] (e : α ≃o β)"},
 {"type": "f x = y",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β) [Preorder α]  [Preorder β]  [Preorder γ] [Preorder α]  [Preorder β] [LinearOrder α]  [Preorder β] (f : α → β)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [LE α]  [PartialOrder β]  (f : α ≃o β)  {x : α}  {y : β}  (hx : ∀ x', x ≤ x')      (hy : ∀ y', y ≤ y') : f x = y := by refine' le_antisymm _ (hy _); sorry",
  "name": "OrderIso.map_bot'",
  "kind": "theorem",
  "first-tactic": "refine' le_antisymm _ (hy _)",
  "core-prompt":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β) [Preorder α]  [Preorder β]  [Preorder γ] [Preorder α]  [Preorder β] [LinearOrder α]  [Preorder β] (f : α → β)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [LE α]  [PartialOrder β]  (f : α ≃o β)  {x : α}  {y : β}  (hx : ∀ x', x ≤ x')      (hy : ∀ y', y ≤ y') : f x = y",
  "args":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β) [Preorder α]  [Preorder β]  [Preorder γ] [Preorder α]  [Preorder β] [LinearOrder α]  [Preorder β] (f : α → β)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [LE α]  [PartialOrder β]  (f : α ≃o β)  {x : α}  {y : β}  (hx : ∀ x', x ≤ x')      (hy : ∀ y', y ≤ y')"},
 {"type": "f (x ⊓ y) = f x ⊓ f y",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β) [Preorder α]  [Preorder β]  [Preorder γ] [Preorder α]  [Preorder β] [LinearOrder α]  [Preorder β] (f : α → β)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeInf α]  [SemilatticeInf β]  (f : α ≃o β)  (x y : α) : f (x ⊓ y) = f x ⊓ f y := by refine' (f.toOrderEmbedding.map_inf_le x y).antisymm _; sorry",
  "name": "OrderIso.map_inf",
  "kind": "theorem",
  "first-tactic": "refine' (f.toOrderEmbedding.map_inf_le x y).antisymm _",
  "core-prompt":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β) [Preorder α]  [Preorder β]  [Preorder γ] [Preorder α]  [Preorder β] [LinearOrder α]  [Preorder β] (f : α → β)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeInf α]  [SemilatticeInf β]  (f : α ≃o β)  (x y : α) : f (x ⊓ y) = f x ⊓ f y",
  "args":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β) [Preorder α]  [Preorder β]  [Preorder γ] [Preorder α]  [Preorder β] [LinearOrder α]  [Preorder β] (f : α → β)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeInf α]  [SemilatticeInf β]  (f : α ≃o β)  (x y : α)"},
 {"type": "Disjoint (f a) (f b)",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β) [Preorder α]  [Preorder β]  [Preorder γ] [Preorder α]  [Preorder β] [LinearOrder α]  [Preorder β] (f : α → β)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeInf α]  [OrderBot α]  [SemilatticeInf β]  [OrderBot β]      {a b : α}  (f : α ≃o β)  (ha : Disjoint a b) : Disjoint (f a) (f b) := by rw [disjoint_iff_inf_le]; sorry",
  "name": "Disjoint.map_orderIso",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_iff_inf_le]",
  "core-prompt":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β) [Preorder α]  [Preorder β]  [Preorder γ] [Preorder α]  [Preorder β] [LinearOrder α]  [Preorder β] (f : α → β)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeInf α]  [OrderBot α]  [SemilatticeInf β]  [OrderBot β]      {a b : α}  (f : α ≃o β)  (ha : Disjoint a b) : Disjoint (f a) (f b)",
  "args":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β) [Preorder α]  [Preorder β]  [Preorder γ] [Preorder α]  [Preorder β] [LinearOrder α]  [Preorder β] (f : α → β)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeInf α]  [OrderBot α]  [SemilatticeInf β]  [OrderBot β]      {a b : α}  (f : α ≃o β)  (ha : Disjoint a b)"},
 {"type": "Codisjoint (f a) (f b)",
  "tactic-prompt":
  "theorem {F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β) [Preorder α]  [Preorder β]  [Preorder γ] [Preorder α]  [Preorder β] [LinearOrder α]  [Preorder β] (f : α → β)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeSup α]  [OrderTop α]  [SemilatticeSup β]  [OrderTop β]      {a b : α}  (f : α ≃o β)  (ha : Codisjoint a b) : Codisjoint (f a) (f b) := by rw [codisjoint_iff_le_sup]; sorry",
  "name": "Codisjoint.map_orderIso",
  "kind": "theorem",
  "first-tactic": "rw [codisjoint_iff_le_sup]",
  "core-prompt":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β) [Preorder α]  [Preorder β]  [Preorder γ] [Preorder α]  [Preorder β] [LinearOrder α]  [Preorder β] (f : α → β)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeSup α]  [OrderTop α]  [SemilatticeSup β]  [OrderTop β]      {a b : α}  (f : α ≃o β)  (ha : Codisjoint a b) : Codisjoint (f a) (f b)",
  "args":
  "{F α β γ δ : Type _} [Preorder α]  [Preorder β]  [OrderHomClass F α β] [Preorder α]  [Preorder β]  [Preorder γ]  [Preorder δ] {ι : Type _}  {π : ι → Type _}  [∀ i, Preorder (π i)] [Preorder α]  [Preorder β]  (f : α ↪o β) [Preorder α]  [Preorder β]  [Preorder γ] [Preorder α]  [Preorder β] [LinearOrder α]  [Preorder β] (f : α → β)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeSup α]  [OrderTop α]  [SemilatticeSup β]  [OrderTop β]      {a b : α}  (f : α ≃o β)  (ha : Codisjoint a b)"},
 {"type": "((⨅ i, f i : α →o β) : α → β) = ⨅ i, (f i : α → β)",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α] {ι : Sort _}  [CompleteLattice β]  (f : ι → α →o β) : ((⨅ i, f i : α →o β) : α → β) = ⨅ i, (f i : α → β) := by funext x; sorry",
  "name": "coe_infᵢ",
  "kind": "theorem",
  "first-tactic": "funext x",
  "core-prompt":
  "{α β : Type _}  [Preorder α] {ι : Sort _}  [CompleteLattice β]  (f : ι → α →o β) : ((⨅ i, f i : α →o β) : α → β) = ⨅ i, (f i : α → β)",
  "args":
  "{α β : Type _}  [Preorder α] {ι : Sort _}  [CompleteLattice β]  (f : ι → α →o β)"},
 {"type": "((⨆ i, f i : α →o β) : α → β) = ⨆ i, (f i : α → β)",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α] {ι : Sort _}  [CompleteLattice β]  (f : ι → α →o β) : ((⨆ i, f i : α →o β) : α → β) = ⨆ i, (f i : α → β) := by funext x; sorry",
  "name": "coe_supᵢ",
  "kind": "theorem",
  "first-tactic": "funext x",
  "core-prompt":
  "{α β : Type _}  [Preorder α] {ι : Sort _}  [CompleteLattice β]  (f : ι → α →o β) : ((⨆ i, f i : α →o β) : α → β) = ⨆ i, (f i : α → β)",
  "args":
  "{α β : Type _}  [Preorder α] {ι : Sort _}  [CompleteLattice β]  (f : ι → α →o β)"},
 {"type":
  "(∀ n₁ n₂ a₁ a₂, (f^[n₁ + n₂]) (a₁ ⊔ a₂) ≤ (f^[n₁]) a₁ ⊔ (f^[n₂]) a₂) ↔\n      ∀ a₁ a₂, f (a₁ ⊔ a₂) ≤ f a₁ ⊔ a₂",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α] {α : Type _}  [SemilatticeSup α]  (f : α →o α) : (∀ n₁ n₂ a₁ a₂, (f^[n₁ + n₂]) (a₁ ⊔ a₂) ≤ (f^[n₁]) a₁ ⊔ (f^[n₂]) a₂) ↔\n      ∀ a₁ a₂, f (a₁ ⊔ a₂) ≤ f a₁ ⊔ a₂ := by constructor; sorry",
  "name": "iterate_sup_le_sup_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α β : Type _}  [Preorder α] {α : Type _}  [SemilatticeSup α]  (f : α →o α) : (∀ n₁ n₂ a₁ a₂, (f^[n₁ + n₂]) (a₁ ⊔ a₂) ≤ (f^[n₁]) a₁ ⊔ (f^[n₂]) a₂) ↔\n      ∀ a₁ a₂, f (a₁ ⊔ a₂) ≤ f a₁ ⊔ a₂",
  "args":
  "{α β : Type _}  [Preorder α] {α : Type _}  [SemilatticeSup α]  (f : α →o α)"},
 {"type": "(x.unbot h : WithBot α) = x",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {a b : α} (x : WithBot α)  (h : x ≠ ⊥) : (x.unbot h : WithBot α) = x := by cases x; sorry",
  "name": "coe_unbot",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α β γ δ : Type _} {a b : α} (x : WithBot α)  (h : x ≠ ⊥) : (x.unbot h : WithBot α) = x",
  "args": "{α β γ δ : Type _} {a b : α} (x : WithBot α)  (h : x ≠ ⊥)"},
 {"type": "@LE.le (WithBot α) _ (Option.some a) (Option.some b) ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {a b : α}  [LE α] : @LE.le (WithBot α) _ (Option.some a) (Option.some b) ↔ a ≤ b := by simp [LE.le]; sorry",
  "name": "some_le_some",
  "kind": "theorem",
  "first-tactic": "simp [LE.le]",
  "core-prompt":
  "{α β γ δ : Type _} {a b : α}  [LE α] : @LE.le (WithBot α) _ (Option.some a) (Option.some b) ↔ a ≤ b",
  "args": "{α β γ δ : Type _} {a b : α}  [LE α]"},
 {"type": "@LT.lt (WithBot α) _ (Option.some a) (Option.some b) ↔ a < b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {a b : α}  [LT α] : @LT.lt (WithBot α) _ (Option.some a) (Option.some b) ↔ a < b := by simp [LT.lt]; sorry",
  "name": "some_lt_some",
  "kind": "theorem",
  "first-tactic": "simp [LT.lt]",
  "core-prompt":
  "{α β γ δ : Type _} {a b : α}  [LT α] : @LT.lt (WithBot α) _ (Option.some a) (Option.some b) ↔ a < b",
  "args": "{α β γ δ : Type _} {a b : α}  [LT α]"},
 {"type": "a.unbot' ⊥ ≤ b ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {a b : α} [LE α]  [OrderBot α]  {a : WithBot α}  {b : α} : a.unbot' ⊥ ≤ b ↔ a ≤ b := by cases a; sorry",
  "name": "unbot'_bot_le_iff",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{α β γ δ : Type _} {a b : α} [LE α]  [OrderBot α]  {a : WithBot α}  {b : α} : a.unbot' ⊥ ≤ b ↔ a ≤ b",
  "args":
  "{α β γ δ : Type _} {a b : α} [LE α]  [OrderBot α]  {a : WithBot α}  {b : α}"},
 {"type": "a.unbot' b < c ↔ a < c",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {a b : α} [LT α]  {a : WithBot α}  {b c : α}  (ha : a ≠ ⊥) : a.unbot' b < c ↔ a < c := by cases a; sorry",
  "name": "unbot'_lt_iff",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{α β γ δ : Type _} {a b : α} [LT α]  {a : WithBot α}  {b c : α}  (ha : a ≠ ⊥) : a.unbot' b < c ↔ a < c",
  "args":
  "{α β γ δ : Type _} {a b : α} [LT α]  {a : WithBot α}  {b c : α}  (ha : a ≠ ⊥)"},
 {"type": "(a : WithTop α) ≤ b ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {a b : α} {a b : α}  [LE α] : (a : WithTop α) ≤ b ↔ a ≤ b := by simp only [← toDual_le_toDual_iff]; sorry",
  "name": "coe_le_coe",
  "kind": "theorem",
  "first-tactic": "simp only [← toDual_le_toDual_iff]",
  "core-prompt":
  "{α β γ δ : Type _} {a b : α} {a b : α}  [LE α] : (a : WithTop α) ≤ b ↔ a ≤ b",
  "args": "{α β γ δ : Type _} {a b : α} {a b : α}  [LE α]"},
 {"type": "IsMin (a : WithTop α)",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {a b : α} {a b : α}  [LE α] (h : IsMin a) : IsMin (a : WithTop α) := by intro _ hb; sorry",
  "name": "_root_.IsMin.withTop",
  "kind": "theorem",
  "first-tactic": "intro _ hb",
  "core-prompt":
  "{α β γ δ : Type _} {a b : α} {a b : α}  [LE α] (h : IsMin a) : IsMin (a : WithTop α)",
  "args": "{α β γ δ : Type _} {a b : α} {a b : α}  [LE α] (h : IsMin a)"},
 {"type": "(a : WithTop α) < b ↔ a < b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {a b : α} {a b : α}  [LT α]  {a b : α} : (a : WithTop α) < b ↔ a < b := by simp only [← toDual_lt_toDual_iff]; sorry",
  "name": "coe_lt_coe",
  "kind": "theorem",
  "first-tactic": "simp only [← toDual_lt_toDual_iff]",
  "core-prompt":
  "{α β γ δ : Type _} {a b : α} {a b : α}  [LT α]  {a b : α} : (a : WithTop α) < b ↔ a < b",
  "args": "{α β γ δ : Type _} {a b : α} {a b : α}  [LT α]  {a b : α}"},
 {"type": "(a : WithTop α) < ⊤",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {a b : α} {a b : α}  [LT α]  {a b : α} (a : α) : (a : WithTop α) < ⊤ := by simp [← toDual_lt_toDual_iff]; sorry",
  "name": "coe_lt_top",
  "kind": "theorem",
  "first-tactic": "simp [← toDual_lt_toDual_iff]",
  "core-prompt":
  "{α β γ δ : Type _} {a b : α} {a b : α}  [LT α]  {a b : α} (a : α) : (a : WithTop α) < ⊤",
  "args": "{α β γ δ : Type _} {a b : α} {a b : α}  [LT α]  {a b : α} (a : α)"},
 {"type": "¬@LT.lt (WithTop α) _ none a",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {a b : α} {a b : α}  [LT α]  {a b : α} (a : WithTop α) : ¬@LT.lt (WithTop α) _ none a := by rw [← toDual_lt_toDual_iff]; sorry",
  "name": "not_none_lt",
  "kind": "theorem",
  "first-tactic": "rw [← toDual_lt_toDual_iff]",
  "core-prompt":
  "{α β γ δ : Type _} {a b : α} {a b : α}  [LT α]  {a b : α} (a : WithTop α) : ¬@LT.lt (WithTop α) _ none a",
  "args":
  "{α β γ δ : Type _} {a b : α} {a b : α}  [LT α]  {a b : α} (a : WithTop α)"},
 {"type": "a < b ↔ ∃ p : α, a = p ∧ ↑p < b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {a b : α} {a b : α}  [LT α]  {a b : α} {a b : WithTop α} : a < b ↔ ∃ p : α, a = p ∧ ↑p < b := by rw [← toDual_lt_toDual_iff]; sorry",
  "name": "lt_iff_exists_coe",
  "kind": "theorem",
  "first-tactic": "rw [← toDual_lt_toDual_iff]",
  "core-prompt":
  "{α β γ δ : Type _} {a b : α} {a b : α}  [LT α]  {a b : α} {a b : WithTop α} : a < b ↔ ∃ p : α, a = p ∧ ↑p < b",
  "args":
  "{α β γ δ : Type _} {a b : α} {a b : α}  [LT α]  {a b : α} {a b : WithTop α}"},
 {"type": "↑a < x ↔ ∀ b, x = ↑b → a < b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {a b : α} {a b : α}  [LT α]  {a b : α} {x : WithTop α} : ↑a < x ↔ ∀ b, x = ↑b → a < b := by simp; sorry",
  "name": "coe_lt_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β γ δ : Type _} {a b : α} {a b : α}  [LT α]  {a b : α} {x : WithTop α} : ↑a < x ↔ ∀ b, x = ↑b → a < b",
  "args":
  "{α β γ δ : Type _} {a b : α} {a b : α}  [LT α]  {a b : α} {x : WithTop α}"},
 {"type": "a.map f ≤ b.map f ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α β γ δ : Type _} {a b : α} {a b : α} [Preorder α]  [Preorder β]  (f : α → β)  (a b : WithTop α)      (mono_iff : ∀ {a b}, f a ≤ f b ↔ a ≤ b) : a.map f ≤ b.map f ↔ a ≤ b := by erw [← toDual_le_toDual_iff]; sorry",
  "name": "map_le_iff",
  "kind": "theorem",
  "first-tactic": "erw [← toDual_le_toDual_iff]",
  "core-prompt":
  "{α β γ δ : Type _} {a b : α} {a b : α} [Preorder α]  [Preorder β]  (f : α → β)  (a b : WithTop α)      (mono_iff : ∀ {a b}, f a ≤ f b ↔ a ≤ b) : a.map f ≤ b.map f ↔ a ≤ b",
  "args":
  "{α β γ δ : Type _} {a b : α} {a b : α} [Preorder α]  [Preorder β]  (f : α → β)  (a b : WithTop α)      (mono_iff : ∀ {a b}, f a ≤ f b ↔ a ≤ b)"},
 {"type": "WellFounded r ↔ ∀ s : Set α, s.Nonempty → ∃ m ∈ s, ∀ x ∈ s, ¬r x m",
  "tactic-prompt":
  "theorem {α : Type _} {r : α → α → Prop} : WellFounded r ↔ ∀ s : Set α, s.Nonempty → ∃ m ∈ s, ∀ x ∈ s, ¬r x m := by refine ⟨fun h => h.has_min, fun h => ⟨fun x => ?_⟩⟩; sorry",
  "name": "wellFounded_iff_has_min",
  "kind": "theorem",
  "first-tactic": "refine ⟨fun h => h.has_min, fun h => ⟨fun x => ?_⟩⟩",
  "core-prompt":
  "{α : Type _} {r : α → α → Prop} : WellFounded r ↔ ∀ s : Set α, s.Nonempty → ∃ m ∈ s, ∀ x ∈ s, ¬r x m",
  "args": "{α : Type _} {r : α → α → Prop}"},
 {"type":
  "WellFounded ((· > ·) : α → α → Prop) ↔\n      ∀ p : Set α, p.Nonempty → ∃ m ∈ p, ∀ x ∈ p, m ≤ x → x = m",
  "tactic-prompt":
  "theorem {α : Type _} [PartialOrder α] : WellFounded ((· > ·) : α → α → Prop) ↔\n      ∀ p : Set α, p.Nonempty → ∃ m ∈ p, ∀ x ∈ p, m ≤ x → x = m := by simp [eq_iff_not_lt_of_le]; sorry",
  "name": "wellFounded_iff_has_max'",
  "kind": "theorem",
  "first-tactic": "simp [eq_iff_not_lt_of_le]",
  "core-prompt":
  "{α : Type _} [PartialOrder α] : WellFounded ((· > ·) : α → α → Prop) ↔\n      ∀ p : Set α, p.Nonempty → ∃ m ∈ p, ∀ x ∈ p, m ≤ x → x = m",
  "args": "{α : Type _} [PartialOrder α]"},
 {"type": "r x (wf.succ x)",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  (wf : WellFounded r)  {x : α}  (h : ∃ y, r x y) : r x (wf.succ x) := by rw [WellFounded.succ]; sorry",
  "name": "lt_succ",
  "kind": "theorem",
  "first-tactic": "rw [WellFounded.succ]",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  (wf : WellFounded r)  {x : α}  (h : ∃ y, r x y) : r x (wf.succ x)",
  "args":
  "{α : Type _}  {r : α → α → Prop}  (wf : WellFounded r)  {x : α}  (h : ∃ y, r x y)"},
 {"type": "r y (wo.wf.succ x) ↔ r y x ∨ y = x",
  "tactic-prompt":
  "theorem {α : Type _} {r : α → α → Prop}  [wo : IsWellOrder α r]  {x : α}  (h : ∃ y, r x y)      (y : α) : r y (wo.wf.succ x) ↔ r y x ∨ y = x := by constructor; sorry",
  "name": "lt_succ_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α : Type _} {r : α → α → Prop}  [wo : IsWellOrder α r]  {x : α}  (h : ∃ y, r x y)      (y : α) : r y (wo.wf.succ x) ↔ r y x ∨ y = x",
  "args":
  "{α : Type _} {r : α → α → Prop}  [wo : IsWellOrder α r]  {x : α}  (h : ∃ y, r x y)      (y : α)"},
 {"type": "f b ≤ g b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  [LinearOrder β]  (h : WellFounded ((· < ·) : β → β → Prop))  {γ : Type _}    [PartialOrder γ] {f g : β → γ}  (hf : StrictMono f)      (hg : StrictMono g)  (hfg : Set.range f = Set.range g)  {b : β}  (H : ∀ a < b, f a = g a) : f b ≤ g b := by obtain ⟨c, hc⟩ : g b ∈ Set.range f := by\n    rw [hfg]\n    exact Set.mem_range_self b; sorry",
  "name": "eq_strictMono_iff_eq_range_aux",
  "kind": "theorem",
  "first-tactic":
  "obtain ⟨c, hc⟩ : g b ∈ Set.range f := by\n    rw [hfg]\n    exact Set.mem_range_self b",
  "core-prompt":
  "{α : Type _}  {β : Type _}  [LinearOrder β]  (h : WellFounded ((· < ·) : β → β → Prop))  {γ : Type _}    [PartialOrder γ] {f g : β → γ}  (hf : StrictMono f)      (hg : StrictMono g)  (hfg : Set.range f = Set.range g)  {b : β}  (H : ∀ a < b, f a = g a) : f b ≤ g b",
  "args":
  "{α : Type _}  {β : Type _}  [LinearOrder β]  (h : WellFounded ((· < ·) : β → β → Prop))  {γ : Type _}    [PartialOrder γ] {f g : β → γ}  (hf : StrictMono f)      (hg : StrictMono g)  (hfg : Set.range f = Set.range g)  {b : β}  (H : ∀ a < b, f a = g a)"},
 {"type": "∀ n, n ≤ f n",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  [LinearOrder β]  (h : WellFounded ((· < ·) : β → β → Prop))  {γ : Type _}    [PartialOrder γ] {f : β → β}  (hf : StrictMono f) : ∀ n, n ≤ f n := by by_contra' h₁; sorry",
  "name": "self_le_of_strictMono",
  "kind": "theorem",
  "first-tactic": "by_contra' h₁",
  "core-prompt":
  "{α : Type _}  {β : Type _}  [LinearOrder β]  (h : WellFounded ((· < ·) : β → β → Prop))  {γ : Type _}    [PartialOrder γ] {f : β → β}  (hf : StrictMono f) : ∀ n, n ≤ f n",
  "args":
  "{α : Type _}  {β : Type _}  [LinearOrder β]  (h : WellFounded ((· < ·) : β → β → Prop))  {γ : Type _}    [PartialOrder γ] {f : β → β}  (hf : StrictMono f)"},
 {"type": "supₛ s ⊓ b = ⨆ a ∈ s, a ⊓ b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} : supₛ s ⊓ b = ⨆ a ∈ s, a ⊓ b := by simpa only [inf_comm] using @inf_supₛ_eq α _ s b; sorry",
  "name": "supₛ_inf_eq",
  "kind": "theorem",
  "first-tactic": "simpa only [inf_comm] using @inf_supₛ_eq α _ s b",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} : supₛ s ⊓ b = ⨆ a ∈ s, a ⊓ b",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α}"},
 {"type": "(⨆ i, f i) ⊓ a = ⨆ i, f i ⊓ a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} (f : ι → α)  (a : α) : (⨆ i, f i) ⊓ a = ⨆ i, f i ⊓ a := by rw [supᵢ]; sorry",
  "name": "supᵢ_inf_eq",
  "kind": "theorem",
  "first-tactic": "rw [supᵢ]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} (f : ι → α)  (a : α) : (⨆ i, f i) ⊓ a = ⨆ i, f i ⊓ a",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} (f : ι → α)  (a : α)"},
 {"type": "(a ⊓ ⨆ i, f i) = ⨆ i, a ⊓ f i",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} (a : α)  (f : ι → α) : (a ⊓ ⨆ i, f i) = ⨆ i, a ⊓ f i := by simpa only [inf_comm] using supᵢ_inf_eq f a; sorry",
  "name": "inf_supᵢ_eq",
  "kind": "theorem",
  "first-tactic": "simpa only [inf_comm] using supᵢ_inf_eq f a",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} (a : α)  (f : ι → α) : (a ⊓ ⨆ i, f i) = ⨆ i, a ⊓ f i",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} (a : α)  (f : ι → α)"},
 {"type": "(⨆ (i) (j), f i j) ⊓ a = ⨆ (i) (j), f i j ⊓ a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ∀ i, κ i → α}  (a : α) : (⨆ (i) (j), f i j) ⊓ a = ⨆ (i) (j), f i j ⊓ a := by simp only [supᵢ_inf_eq]; sorry",
  "name": "supᵢ₂_inf_eq",
  "kind": "theorem",
  "first-tactic": "simp only [supᵢ_inf_eq]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ∀ i, κ i → α}  (a : α) : (⨆ (i) (j), f i j) ⊓ a = ⨆ (i) (j), f i j ⊓ a",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ∀ i, κ i → α}  (a : α)"},
 {"type": "(a ⊓ ⨆ (i) (j), f i j) = ⨆ (i) (j), a ⊓ f i j",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ∀ i, κ i → α}  (a : α) : (a ⊓ ⨆ (i) (j), f i j) = ⨆ (i) (j), a ⊓ f i j := by simp only [inf_supᵢ_eq]; sorry",
  "name": "inf_supᵢ₂_eq",
  "kind": "theorem",
  "first-tactic": "simp only [inf_supᵢ_eq]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ∀ i, κ i → α}  (a : α) : (a ⊓ ⨆ (i) (j), f i j) = ⨆ (i) (j), a ⊓ f i j",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ∀ i, κ i → α}  (a : α)"},
 {"type": "((⨆ i, f i) ⊓ ⨆ j, g j) = ⨆ i : ι × ι', f i.1 ⊓ g i.2",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {ι ι' : Type _}  {f : ι → α}  {g : ι' → α} : ((⨆ i, f i) ⊓ ⨆ j, g j) = ⨆ i : ι × ι', f i.1 ⊓ g i.2 := by simp_rw [supᵢ_inf_eq]; sorry",
  "name": "supᵢ_inf_supᵢ",
  "kind": "theorem",
  "first-tactic": "simp_rw [supᵢ_inf_eq]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {ι ι' : Type _}  {f : ι → α}  {g : ι' → α} : ((⨆ i, f i) ⊓ ⨆ j, g j) = ⨆ i : ι × ι', f i.1 ⊓ g i.2",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {ι ι' : Type _}  {f : ι → α}  {g : ι' → α}"},
 {"type":
  "((⨆ i ∈ s, f i) ⊓ ⨆ j ∈ t, g j) = ⨆ p ∈ s ×ˢ t, f (p : ι × ι').1 ⊓ g p.2",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {ι ι' : Type _}  {f : ι → α}  {g : ι' → α}  {s : Set ι}  {t : Set ι'} : ((⨆ i ∈ s, f i) ⊓ ⨆ j ∈ t, g j) = ⨆ p ∈ s ×ˢ t, f (p : ι × ι').1 ⊓ g p.2 := by simp only [supᵢ_subtype']; sorry",
  "name": "bsupᵢ_inf_bsupᵢ",
  "kind": "theorem",
  "first-tactic": "simp only [supᵢ_subtype']",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {ι ι' : Type _}  {f : ι → α}  {g : ι' → α}  {s : Set ι}  {t : Set ι'} : ((⨆ i ∈ s, f i) ⊓ ⨆ j ∈ t, g j) = ⨆ p ∈ s ×ˢ t, f (p : ι × ι').1 ⊓ g p.2",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {ι ι' : Type _}  {f : ι → α}  {g : ι' → α}  {s : Set ι}  {t : Set ι'}"},
 {"type": "supₛ s ⊓ supₛ t = ⨆ p ∈ s ×ˢ t, (p : α × α).1 ⊓ p.2",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} : supₛ s ⊓ supₛ t = ⨆ p ∈ s ×ˢ t, (p : α × α).1 ⊓ p.2 := by simp only [supₛ_eq_supᵢ]; sorry",
  "name": "supₛ_inf_supₛ",
  "kind": "theorem",
  "first-tactic": "simp only [supₛ_eq_supᵢ]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} : supₛ s ⊓ supₛ t = ⨆ p ∈ s ×ˢ t, (p : α × α).1 ⊓ p.2",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α}"},
 {"type": "Disjoint (⨆ i, f i) a ↔ ∀ i, Disjoint (f i) a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ι → α} : Disjoint (⨆ i, f i) a ↔ ∀ i, Disjoint (f i) a := by simp only [disjoint_iff]; sorry",
  "name": "supᵢ_disjoint_iff",
  "kind": "theorem",
  "first-tactic": "simp only [disjoint_iff]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ι → α} : Disjoint (⨆ i, f i) a ↔ ∀ i, Disjoint (f i) a",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ι → α}"},
 {"type": "Disjoint a (⨆ i, f i) ↔ ∀ i, Disjoint a (f i)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ι → α} : Disjoint a (⨆ i, f i) ↔ ∀ i, Disjoint a (f i) := by simpa only [Disjoint.comm] using @supᵢ_disjoint_iff; sorry",
  "name": "disjoint_supᵢ_iff",
  "kind": "theorem",
  "first-tactic": "simpa only [Disjoint.comm] using @supᵢ_disjoint_iff",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ι → α} : Disjoint a (⨆ i, f i) ↔ ∀ i, Disjoint a (f i)",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ι → α}"},
 {"type": "Disjoint (⨆ (i) (j), f i j) a ↔ ∀ i j, Disjoint (f i j) a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ∀ i, κ i → α} : Disjoint (⨆ (i) (j), f i j) a ↔ ∀ i j, Disjoint (f i j) a := by simp_rw [supᵢ_disjoint_iff]; sorry",
  "name": "supᵢ₂_disjoint_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [supᵢ_disjoint_iff]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ∀ i, κ i → α} : Disjoint (⨆ (i) (j), f i j) a ↔ ∀ i j, Disjoint (f i j) a",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ∀ i, κ i → α}"},
 {"type": "Disjoint a (⨆ (i) (j), f i j) ↔ ∀ i j, Disjoint a (f i j)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ∀ i, κ i → α} : Disjoint a (⨆ (i) (j), f i j) ↔ ∀ i j, Disjoint a (f i j) := by simp_rw [disjoint_supᵢ_iff]; sorry",
  "name": "disjoint_supᵢ₂_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [disjoint_supᵢ_iff]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ∀ i, κ i → α} : Disjoint a (⨆ (i) (j), f i j) ↔ ∀ i j, Disjoint a (f i j)",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {f : ∀ i, κ i → α}"},
 {"type": "Disjoint (supₛ s) a ↔ ∀ b ∈ s, Disjoint b a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {s : Set α} : Disjoint (supₛ s) a ↔ ∀ b ∈ s, Disjoint b a := by simp only [disjoint_iff]; sorry",
  "name": "supₛ_disjoint_iff",
  "kind": "theorem",
  "first-tactic": "simp only [disjoint_iff]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {s : Set α} : Disjoint (supₛ s) a ↔ ∀ b ∈ s, Disjoint b a",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {s : Set α}"},
 {"type": "Disjoint a (supₛ s) ↔ ∀ b ∈ s, Disjoint a b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {s : Set α} : Disjoint a (supₛ s) ↔ ∀ b ∈ s, Disjoint a b := by simpa only [Disjoint.comm] using @supₛ_disjoint_iff; sorry",
  "name": "disjoint_supₛ_iff",
  "kind": "theorem",
  "first-tactic": "simpa only [Disjoint.comm] using @supₛ_disjoint_iff",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {s : Set α} : Disjoint a (supₛ s) ↔ ∀ b ∈ s, Disjoint a b",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {s : Set α}"},
 {"type": "(⨆ i, f i ⊓ g i) = (⨆ i, f i) ⊓ ⨆ i, g i",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {ι : Type _}  [Preorder ι]  [IsDirected ι (· ≤ ·)]  {f g : ι → α}      (hf : Monotone f)  (hg : Monotone g) : (⨆ i, f i ⊓ g i) = (⨆ i, f i) ⊓ ⨆ i, g i := by refine' (le_supᵢ_inf_supᵢ f g).antisymm _; sorry",
  "name": "supᵢ_inf_of_monotone",
  "kind": "theorem",
  "first-tactic": "refine' (le_supᵢ_inf_supᵢ f g).antisymm _",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {ι : Type _}  [Preorder ι]  [IsDirected ι (· ≤ ·)]  {f g : ι → α}      (hf : Monotone f)  (hg : Monotone g) : (⨆ i, f i ⊓ g i) = (⨆ i, f i) ⊓ ⨆ i, g i",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [Frame α]  {s t : Set α}  {a b : α} {ι : Type _}  [Preorder ι]  [IsDirected ι (· ≤ ·)]  {f g : ι → α}      (hf : Monotone f)  (hg : Monotone g)"},
 {"type": "infₛ sᶜ = ⨆ i ∈ s, iᶜ",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [CompleteBooleanAlgebra α]  {a b : α}  {s : Set α}  {f : ι → α} : infₛ sᶜ = ⨆ i ∈ s, iᶜ := by simp only [infₛ_eq_infᵢ]; sorry",
  "name": "compl_infₛ",
  "kind": "theorem",
  "first-tactic": "simp only [infₛ_eq_infᵢ]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [CompleteBooleanAlgebra α]  {a b : α}  {s : Set α}  {f : ι → α} : infₛ sᶜ = ⨆ i ∈ s, iᶜ",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [CompleteBooleanAlgebra α]  {a b : α}  {s : Set α}  {f : ι → α}"},
 {"type": "supₛ sᶜ = ⨅ i ∈ s, iᶜ",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [CompleteBooleanAlgebra α]  {a b : α}  {s : Set α}  {f : ι → α} : supₛ sᶜ = ⨅ i ∈ s, iᶜ := by simp only [supₛ_eq_supᵢ]; sorry",
  "name": "compl_supₛ",
  "kind": "theorem",
  "first-tactic": "simp only [supₛ_eq_supᵢ]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [CompleteBooleanAlgebra α]  {a b : α}  {s : Set α}  {f : ι → α} : supₛ sᶜ = ⨅ i ∈ s, iᶜ",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  [CompleteBooleanAlgebra α]  {a b : α}  {s : Set α}  {f : ι → α}"},
 {"type": "CompleteBooleanAlgebra PUnit",
  "tactic-prompt":
  "instance {α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  (s : Set PUnit.{u + 1})  (x y : PUnit.{u + 1})  -- Porting note: we don't have `refine_struct` ported yet, so we do it by hand : CompleteBooleanAlgebra PUnit := by refine'\n    { PUnit.booleanAlgebra with\n      supₛ := fun _ => unit\n      infₛ := fun _ => unit\n      .. }; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic":
  "refine'\n    { PUnit.booleanAlgebra with\n      supₛ := fun _ => unit\n      infₛ := fun _ => unit\n      .. }",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  (s : Set PUnit.{u + 1})  (x y : PUnit.{u + 1})  -- Porting note: we don't have `refine_struct` ported yet, so we do it by hand : CompleteBooleanAlgebra PUnit",
  "args":
  "{α : Type u}  {β : Type v}  {ι : Sort w}  {κ : ι → Sort _}  (s : Set PUnit.{u + 1})  (x y : PUnit.{u + 1})  -- Porting note: we don't have `refine_struct` ported yet, so we do it by hand"},
 {"type": "Inhabited (Antisymmetrization α r)",
  "tactic-prompt":
  "instance {α β : Type _}  [Inhabited α] : Inhabited (Antisymmetrization α r) := by unfold Antisymmetrization; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "unfold Antisymmetrization",
  "core-prompt":
  "{α β : Type _}  [Inhabited α] : Inhabited (Antisymmetrization α r)",
  "args": "{α β : Type _}  [Inhabited α]"},
 {"type":
  "Relation.Fibration (· < ·) (· < ·) (@toAntisymmetrization α (· ≤ ·) _)",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  [Preorder β]  {a b : α} : Relation.Fibration (· < ·) (· < ·) (@toAntisymmetrization α (· ≤ ·) _) := by rintro a ⟨b⟩ h; sorry",
  "name": "antisymmetrization_fibration",
  "kind": "theorem",
  "first-tactic": "rintro a ⟨b⟩ h",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  [Preorder β]  {a b : α} : Relation.Fibration (· < ·) (· < ·) (@toAntisymmetrization α (· ≤ ·) _)",
  "args": "{α β : Type _}  [Preorder α]  [Preorder β]  {a b : α}"},
 {"type":
  "ofAntisymmetrization (· ≤ ·) a ≤ ofAntisymmetrization (· ≤ ·) b ↔ a ≤ b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  [Preorder β]  {a b : α} {a b : Antisymmetrization α (· ≤ ·)} : ofAntisymmetrization (· ≤ ·) a ≤ ofAntisymmetrization (· ≤ ·) b ↔ a ≤ b := by rw [← toAntisymmetrization_le_toAntisymmetrization_iff]; sorry",
  "name": "ofAntisymmetrization_le_ofAntisymmetrization_iff",
  "kind": "theorem",
  "first-tactic": "rw [← toAntisymmetrization_le_toAntisymmetrization_iff]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  [Preorder β]  {a b : α} {a b : Antisymmetrization α (· ≤ ·)} : ofAntisymmetrization (· ≤ ·) a ≤ ofAntisymmetrization (· ≤ ·) b ↔ a ≤ b",
  "args":
  "{α β : Type _}  [Preorder α]  [Preorder β]  {a b : α} {a b : Antisymmetrization α (· ≤ ·)}"},
 {"type":
  "ofAntisymmetrization (· ≤ ·) a < ofAntisymmetrization (· ≤ ·) b ↔ a < b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  [Preorder β]  {a b : α} {a b : Antisymmetrization α (· ≤ ·)} : ofAntisymmetrization (· ≤ ·) a < ofAntisymmetrization (· ≤ ·) b ↔ a < b := by rw [← toAntisymmetrization_lt_toAntisymmetrization_iff]; sorry",
  "name": "ofAntisymmetrization_lt_ofAntisymmetrization_iff",
  "kind": "theorem",
  "first-tactic": "rw [← toAntisymmetrization_lt_toAntisymmetrization_iff]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  [Preorder β]  {a b : α} {a b : Antisymmetrization α (· ≤ ·)} : ofAntisymmetrization (· ≤ ·) a < ofAntisymmetrization (· ≤ ·) b ↔ a < b",
  "args":
  "{α β : Type _}  [Preorder α]  [Preorder β]  {a b : α} {a b : Antisymmetrization α (· ≤ ·)}"},
 {"type": "Unbounded (· ≤ ·) s ↔ ∀ a, ∃ b ∈ s, a < b",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α] : Unbounded (· ≤ ·) s ↔ ∀ a, ∃ b ∈ s, a < b := by simp only [Unbounded]; sorry",
  "name": "unbounded_le_iff",
  "kind": "theorem",
  "first-tactic": "simp only [Unbounded]",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α] : Unbounded (· ≤ ·) s ↔ ∀ a, ∃ b ∈ s, a < b",
  "args": "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]"},
 {"type": "Unbounded (· < ·) s ↔ ∀ a, ∃ b ∈ s, a ≤ b",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α] : Unbounded (· < ·) s ↔ ∀ a, ∃ b ∈ s, a ≤ b := by simp only [Unbounded]; sorry",
  "name": "unbounded_lt_iff",
  "kind": "theorem",
  "first-tactic": "simp only [Unbounded]",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α] : Unbounded (· < ·) s ↔ ∀ a, ∃ b ∈ s, a ≤ b",
  "args": "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]"},
 {"type": "Bounded (· ≤ ·) s ↔ Bounded (· < ·) s",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} [Preorder α]  [NoMaxOrder α] : Bounded (· ≤ ·) s ↔ Bounded (· < ·) s := by refine' ⟨fun h => _, bounded_le_of_bounded_lt⟩; sorry",
  "name": "bounded_le_iff_bounded_lt",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, bounded_le_of_bounded_lt⟩",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [Preorder α]  [NoMaxOrder α] : Bounded (· ≤ ·) s ↔ Bounded (· < ·) s",
  "args":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [Preorder α]  [NoMaxOrder α]"},
 {"type": "Unbounded (· < ·) s ↔ Unbounded (· ≤ ·) s",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} [Preorder α]  [NoMaxOrder α] : Unbounded (· < ·) s ↔ Unbounded (· ≤ ·) s := by simp_rw [← not_bounded_iff]; sorry",
  "name": "unbounded_lt_iff_unbounded_le",
  "kind": "theorem",
  "first-tactic": "simp_rw [← not_bounded_iff]",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [Preorder α]  [NoMaxOrder α] : Unbounded (· < ·) s ↔ Unbounded (· ≤ ·) s",
  "args":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [Preorder α]  [NoMaxOrder α]"},
 {"type": "Bounded (· < ·) (Iic a)",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} [Preorder α]  [NoMaxOrder α]  (a : α) : Bounded (· < ·) (Iic a) := by simp only [← bounded_le_iff_bounded_lt]; sorry",
  "name": "bounded_lt_Iic",
  "kind": "theorem",
  "first-tactic": "simp only [← bounded_le_iff_bounded_lt]",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [Preorder α]  [NoMaxOrder α]  (a : α) : Bounded (· < ·) (Iic a)",
  "args":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [Preorder α]  [NoMaxOrder α]  (a : α)"},
 {"type": "Bounded (· > ·) (Ici a)",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} [Preorder α]  [NoMinOrder α]  (a : α) : Bounded (· > ·) (Ici a) := by simp only [← bounded_ge_iff_bounded_gt]; sorry",
  "name": "bounded_gt_Ici",
  "kind": "theorem",
  "first-tactic": "simp only [← bounded_ge_iff_bounded_gt]",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [Preorder α]  [NoMinOrder α]  (a : α) : Bounded (· > ·) (Ici a)",
  "args":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [Preorder α]  [NoMinOrder α]  (a : α)"},
 {"type": "Bounded r (s ∩ { b | ¬r b a }) ↔ Bounded r s",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} (H : ∀ a b, ∃ m, ∀ c, r c a ∨ r c b → r c m)  (a : α) : Bounded r (s ∩ { b | ¬r b a }) ↔ Bounded r s := by refine' ⟨_, Bounded.mono (Set.inter_subset_left s _)⟩; sorry",
  "name": "bounded_inter_not",
  "kind": "theorem",
  "first-tactic": "refine' ⟨_, Bounded.mono (Set.inter_subset_left s _)⟩",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} (H : ∀ a b, ∃ m, ∀ c, r c a ∨ r c b → r c m)  (a : α) : Bounded r (s ∩ { b | ¬r b a }) ↔ Bounded r s",
  "args":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} (H : ∀ a b, ∃ m, ∀ c, r c a ∨ r c b → r c m)  (a : α)"},
 {"type": "Unbounded r (s ∩ { b | ¬r b a }) ↔ Unbounded r s",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} (H : ∀ a b, ∃ m, ∀ c, r c a ∨ r c b → r c m)  (a : α) : Unbounded r (s ∩ { b | ¬r b a }) ↔ Unbounded r s := by simp_rw [← not_bounded_iff]; sorry",
  "name": "unbounded_inter_not",
  "kind": "theorem",
  "first-tactic": "simp_rw [← not_bounded_iff]",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} (H : ∀ a b, ∃ m, ∀ c, r c a ∨ r c b → r c m)  (a : α) : Unbounded r (s ∩ { b | ¬r b a }) ↔ Unbounded r s",
  "args":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} (H : ∀ a b, ∃ m, ∀ c, r c a ∨ r c b → r c m)  (a : α)"},
 {"type": "Unbounded (· ≤ ·) (s ∩ { b | ¬b ≤ a }) ↔ Unbounded (· ≤ ·) s",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} [SemilatticeSup α]  (a : α) : Unbounded (· ≤ ·) (s ∩ { b | ¬b ≤ a }) ↔ Unbounded (· ≤ ·) s := by rw [← not_bounded_iff]; sorry",
  "name": "unbounded_le_inter_not_le",
  "kind": "theorem",
  "first-tactic": "rw [← not_bounded_iff]",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [SemilatticeSup α]  (a : α) : Unbounded (· ≤ ·) (s ∩ { b | ¬b ≤ a }) ↔ Unbounded (· ≤ ·) s",
  "args":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [SemilatticeSup α]  (a : α)"},
 {"type": "Bounded (· ≤ ·) (s ∩ { b | a < b }) ↔ Bounded (· ≤ ·) s",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α) : Bounded (· ≤ ·) (s ∩ { b | a < b }) ↔ Bounded (· ≤ ·) s := by simp_rw [← not_le]; sorry",
  "name": "bounded_le_inter_lt",
  "kind": "theorem",
  "first-tactic": "simp_rw [← not_le]",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α) : Bounded (· ≤ ·) (s ∩ { b | a < b }) ↔ Bounded (· ≤ ·) s",
  "args":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α)"},
 {"type": "Unbounded (· ≤ ·) (s ∩ { b | a < b }) ↔ Unbounded (· ≤ ·) s",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α) : Unbounded (· ≤ ·) (s ∩ { b | a < b }) ↔ Unbounded (· ≤ ·) s := by convert @unbounded_le_inter_not_le _ s _ a; sorry",
  "name": "unbounded_le_inter_lt",
  "kind": "theorem",
  "first-tactic": "convert @unbounded_le_inter_not_le _ s _ a",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α) : Unbounded (· ≤ ·) (s ∩ { b | a < b }) ↔ Unbounded (· ≤ ·) s",
  "args":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α)"},
 {"type": "Bounded (· ≤ ·) (s ∩ { b | a ≤ b }) ↔ Bounded (· ≤ ·) s",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α) : Bounded (· ≤ ·) (s ∩ { b | a ≤ b }) ↔ Bounded (· ≤ ·) s := by refine' ⟨_, Bounded.mono (Set.inter_subset_left s _)⟩; sorry",
  "name": "bounded_le_inter_le",
  "kind": "theorem",
  "first-tactic": "refine' ⟨_, Bounded.mono (Set.inter_subset_left s _)⟩",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α) : Bounded (· ≤ ·) (s ∩ { b | a ≤ b }) ↔ Bounded (· ≤ ·) s",
  "args":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α)"},
 {"type": "Unbounded (· ≤ ·) (s ∩ { b | a ≤ b }) ↔ Unbounded (· ≤ ·) s",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α) : Unbounded (· ≤ ·) (s ∩ { b | a ≤ b }) ↔ Unbounded (· ≤ ·) s := by rw [← not_bounded_iff]; sorry",
  "name": "unbounded_le_inter_le",
  "kind": "theorem",
  "first-tactic": "rw [← not_bounded_iff]",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α) : Unbounded (· ≤ ·) (s ∩ { b | a ≤ b }) ↔ Unbounded (· ≤ ·) s",
  "args":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α)"},
 {"type": "Unbounded (· < ·) (s ∩ { b | ¬b < a }) ↔ Unbounded (· < ·) s",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} [SemilatticeSup α]  (a : α) : Unbounded (· < ·) (s ∩ { b | ¬b < a }) ↔ Unbounded (· < ·) s := by rw [← not_bounded_iff]; sorry",
  "name": "unbounded_lt_inter_not_lt",
  "kind": "theorem",
  "first-tactic": "rw [← not_bounded_iff]",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [SemilatticeSup α]  (a : α) : Unbounded (· < ·) (s ∩ { b | ¬b < a }) ↔ Unbounded (· < ·) s",
  "args":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [SemilatticeSup α]  (a : α)"},
 {"type": "Bounded (· < ·) (s ∩ { b | a ≤ b }) ↔ Bounded (· < ·) s",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α) : Bounded (· < ·) (s ∩ { b | a ≤ b }) ↔ Bounded (· < ·) s := by convert @bounded_lt_inter_not_lt _ s _ a; sorry",
  "name": "bounded_lt_inter_le",
  "kind": "theorem",
  "first-tactic": "convert @bounded_lt_inter_not_lt _ s _ a",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α) : Bounded (· < ·) (s ∩ { b | a ≤ b }) ↔ Bounded (· < ·) s",
  "args":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α)"},
 {"type": "Unbounded (· < ·) (s ∩ { b | a ≤ b }) ↔ Unbounded (· < ·) s",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α) : Unbounded (· < ·) (s ∩ { b | a ≤ b }) ↔ Unbounded (· < ·) s := by convert @unbounded_lt_inter_not_lt _ s _ a; sorry",
  "name": "unbounded_lt_inter_le",
  "kind": "theorem",
  "first-tactic": "convert @unbounded_lt_inter_not_lt _ s _ a",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α) : Unbounded (· < ·) (s ∩ { b | a ≤ b }) ↔ Unbounded (· < ·) s",
  "args":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  (a : α)"},
 {"type": "Bounded (· < ·) (s ∩ { b | a < b }) ↔ Bounded (· < ·) s",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  [NoMaxOrder α]  (a : α) : Bounded (· < ·) (s ∩ { b | a < b }) ↔ Bounded (· < ·) s := by rw [← bounded_le_iff_bounded_lt]; sorry",
  "name": "bounded_lt_inter_lt",
  "kind": "theorem",
  "first-tactic": "rw [← bounded_le_iff_bounded_lt]",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  [NoMaxOrder α]  (a : α) : Bounded (· < ·) (s ∩ { b | a < b }) ↔ Bounded (· < ·) s",
  "args":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  [NoMaxOrder α]  (a : α)"},
 {"type": "Unbounded (· < ·) (s ∩ { b | a < b }) ↔ Unbounded (· < ·) s",
  "tactic-prompt":
  "theorem {α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  [NoMaxOrder α]  (a : α) : Unbounded (· < ·) (s ∩ { b | a < b }) ↔ Unbounded (· < ·) s := by rw [← not_bounded_iff]; sorry",
  "name": "unbounded_lt_inter_lt",
  "kind": "theorem",
  "first-tactic": "rw [← not_bounded_iff]",
  "core-prompt":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  [NoMaxOrder α]  (a : α) : Unbounded (· < ·) (s ∩ { b | a < b }) ↔ Unbounded (· < ·) s",
  "args":
  "{α : Type _}  {r : α → α → Prop}  {s t : Set α} [LinearOrder α]  [NoMaxOrder α]  (a : α)"},
 {"type": "Disjoint (a ⊓ b) c ↔ Disjoint a (b ⊓ c)",
  "tactic-prompt":
  "theorem {α : Type _}   [SemilatticeInf α]  [OrderBot α]  {a b c d : α} : Disjoint (a ⊓ b) c ↔ Disjoint a (b ⊓ c) := by rw [disjoint_iff_inf_le]; sorry",
  "name": "disjoint_assoc",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_iff_inf_le]",
  "core-prompt":
  "{α : Type _}   [SemilatticeInf α]  [OrderBot α]  {a b c d : α} : Disjoint (a ⊓ b) c ↔ Disjoint a (b ⊓ c)",
  "args": "{α : Type _}   [SemilatticeInf α]  [OrderBot α]  {a b c d : α}"},
 {"type": "Disjoint a (b ⊓ c) ↔ Disjoint b (a ⊓ c)",
  "tactic-prompt":
  "theorem {α : Type _}   [SemilatticeInf α]  [OrderBot α]  {a b c d : α} : Disjoint a (b ⊓ c) ↔ Disjoint b (a ⊓ c) := by simp_rw [disjoint_iff_inf_le]; sorry",
  "name": "disjoint_left_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [disjoint_iff_inf_le]",
  "core-prompt":
  "{α : Type _}   [SemilatticeInf α]  [OrderBot α]  {a b c d : α} : Disjoint a (b ⊓ c) ↔ Disjoint b (a ⊓ c)",
  "args": "{α : Type _}   [SemilatticeInf α]  [OrderBot α]  {a b c d : α}"},
 {"type": "Disjoint (a ⊓ b) c ↔ Disjoint (a ⊓ c) b",
  "tactic-prompt":
  "theorem {α : Type _}   [SemilatticeInf α]  [OrderBot α]  {a b c d : α} : Disjoint (a ⊓ b) c ↔ Disjoint (a ⊓ c) b := by simp_rw [disjoint_iff_inf_le]; sorry",
  "name": "disjoint_right_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [disjoint_iff_inf_le]",
  "core-prompt":
  "{α : Type _}   [SemilatticeInf α]  [OrderBot α]  {a b c d : α} : Disjoint (a ⊓ b) c ↔ Disjoint (a ⊓ c) b",
  "args": "{α : Type _}   [SemilatticeInf α]  [OrderBot α]  {a b c d : α}"},
 {"type": "Disjoint (a ⊔ b) c ↔ Disjoint a c ∧ Disjoint b c",
  "tactic-prompt":
  "theorem {α : Type _}   [DistribLattice α]  [OrderBot α]  {a b c : α} : Disjoint (a ⊔ b) c ↔ Disjoint a c ∧ Disjoint b c := by simp only [disjoint_iff]; sorry",
  "name": "disjoint_sup_left",
  "kind": "theorem",
  "first-tactic": "simp only [disjoint_iff]",
  "core-prompt":
  "{α : Type _}   [DistribLattice α]  [OrderBot α]  {a b c : α} : Disjoint (a ⊔ b) c ↔ Disjoint a c ∧ Disjoint b c",
  "args": "{α : Type _}   [DistribLattice α]  [OrderBot α]  {a b c : α}"},
 {"type": "Disjoint a (b ⊔ c) ↔ Disjoint a b ∧ Disjoint a c",
  "tactic-prompt":
  "theorem {α : Type _}   [DistribLattice α]  [OrderBot α]  {a b c : α} : Disjoint a (b ⊔ c) ↔ Disjoint a b ∧ Disjoint a c := by simp only [disjoint_iff]; sorry",
  "name": "disjoint_sup_right",
  "kind": "theorem",
  "first-tactic": "simp only [disjoint_iff]",
  "core-prompt":
  "{α : Type _}   [DistribLattice α]  [OrderBot α]  {a b c : α} : Disjoint a (b ⊔ c) ↔ Disjoint a b ∧ Disjoint a c",
  "args": "{α : Type _}   [DistribLattice α]  [OrderBot α]  {a b c : α}"},
 {"type": "Codisjoint (a ⊓ b) c ↔ Codisjoint a c ∧ Codisjoint b c",
  "tactic-prompt":
  "theorem {α : Type _}   [DistribLattice α]  [OrderTop α]  {a b c : α} : Codisjoint (a ⊓ b) c ↔ Codisjoint a c ∧ Codisjoint b c := by simp only [codisjoint_iff]; sorry",
  "name": "codisjoint_inf_left",
  "kind": "theorem",
  "first-tactic": "simp only [codisjoint_iff]",
  "core-prompt":
  "{α : Type _}   [DistribLattice α]  [OrderTop α]  {a b c : α} : Codisjoint (a ⊓ b) c ↔ Codisjoint a c ∧ Codisjoint b c",
  "args": "{α : Type _}   [DistribLattice α]  [OrderTop α]  {a b c : α}"},
 {"type": "Codisjoint a (b ⊓ c) ↔ Codisjoint a b ∧ Codisjoint a c",
  "tactic-prompt":
  "theorem {α : Type _}   [DistribLattice α]  [OrderTop α]  {a b c : α} : Codisjoint a (b ⊓ c) ↔ Codisjoint a b ∧ Codisjoint a c := by simp only [codisjoint_iff]; sorry",
  "name": "codisjoint_inf_right",
  "kind": "theorem",
  "first-tactic": "simp only [codisjoint_iff]",
  "core-prompt":
  "{α : Type _}   [DistribLattice α]  [OrderTop α]  {a b c : α} : Codisjoint a (b ⊓ c) ↔ Codisjoint a b ∧ Codisjoint a c",
  "args": "{α : Type _}   [DistribLattice α]  [OrderTop α]  {a b c : α}"},
 {"type": "a ≤ c",
  "tactic-prompt":
  "theorem {α : Type _}  [DistribLattice α]  [BoundedOrder α]  {a b c : α} (hab : Disjoint a b)  (hbc : Codisjoint b c) : a ≤ c := by rw [← @inf_top_eq _ _ _ a]; sorry",
  "name": "Disjoint.le_of_codisjoint",
  "kind": "theorem",
  "first-tactic": "rw [← @inf_top_eq _ _ _ a]",
  "core-prompt":
  "{α : Type _}  [DistribLattice α]  [BoundedOrder α]  {a b c : α} (hab : Disjoint a b)  (hbc : Codisjoint b c) : a ≤ c",
  "args":
  "{α : Type _}  [DistribLattice α]  [BoundedOrder α]  {a b c : α} (hab : Disjoint a b)  (hbc : Codisjoint b c)"},
 {"type": "x ⊓ y = ⊥ ↔ x ≤ z",
  "tactic-prompt":
  "theorem {α : Type _}  [DistribLattice α]  [BoundedOrder α]  {a b x y z : α} (h : IsCompl y z) : x ⊓ y = ⊥ ↔ x ≤ z := by rw [← le_bot_iff]; sorry",
  "name": "inf_left_eq_bot_iff",
  "kind": "theorem",
  "first-tactic": "rw [← le_bot_iff]",
  "core-prompt":
  "{α : Type _}  [DistribLattice α]  [BoundedOrder α]  {a b x y z : α} (h : IsCompl y z) : x ⊓ y = ⊥ ↔ x ≤ z",
  "args":
  "{α : Type _}  [DistribLattice α]  [BoundedOrder α]  {a b x y z : α} (h : IsCompl y z)"},
 {"type": "Disjoint x y ↔ x ≤ z",
  "tactic-prompt":
  "theorem {α : Type _}  [DistribLattice α]  [BoundedOrder α]  {a b x y z : α} (h : IsCompl y z) : Disjoint x y ↔ x ≤ z := by rw [disjoint_iff]; sorry",
  "name": "disjoint_left_iff",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_iff]",
  "core-prompt":
  "{α : Type _}  [DistribLattice α]  [BoundedOrder α]  {a b x y z : α} (h : IsCompl y z) : Disjoint x y ↔ x ≤ z",
  "args":
  "{α : Type _}  [DistribLattice α]  [BoundedOrder α]  {a b x y z : α} (h : IsCompl y z)"},
 {"type": "Disjoint x y ↔ Disjoint x.1 y.1 ∧ Disjoint x.2 y.2",
  "tactic-prompt":
  "theorem {α : Type _} {β : Type _}  [PartialOrder α]  [PartialOrder β] [OrderBot α]  [OrderBot β]  {x y : α × β} : Disjoint x y ↔ Disjoint x.1 y.1 ∧ Disjoint x.2 y.2 := by constructor; sorry",
  "name": "disjoint_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α : Type _} {β : Type _}  [PartialOrder α]  [PartialOrder β] [OrderBot α]  [OrderBot β]  {x y : α × β} : Disjoint x y ↔ Disjoint x.1 y.1 ∧ Disjoint x.2 y.2",
  "args":
  "{α : Type _} {β : Type _}  [PartialOrder α]  [PartialOrder β] [OrderBot α]  [OrderBot β]  {x y : α × β}"},
 {"type": "IsCompl x y ↔ IsCompl x.1 y.1 ∧ IsCompl x.2 y.2",
  "tactic-prompt":
  "theorem {α : Type _} {β : Type _}  [PartialOrder α]  [PartialOrder β] [BoundedOrder α]  [BoundedOrder β]  {x y : α × β} : IsCompl x y ↔ IsCompl x.1 y.1 ∧ IsCompl x.2 y.2 := by simp_rw [isCompl_iff]; sorry",
  "name": "isCompl_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [isCompl_iff]",
  "core-prompt":
  "{α : Type _} {β : Type _}  [PartialOrder α]  [PartialOrder β] [BoundedOrder α]  [BoundedOrder β]  {x y : α × β} : IsCompl x y ↔ IsCompl x.1 y.1 ∧ IsCompl x.2 y.2",
  "args":
  "{α : Type _} {β : Type _}  [PartialOrder α]  [PartialOrder β] [BoundedOrder α]  [BoundedOrder β]  {x y : α × β}"},
 {"type": "LinearOrder Prop",
  "tactic-prompt":
  "instance  : LinearOrder Prop := by classical\n  exact Lattice.toLinearOrder Prop; sorry",
  "name": "Prop.linearOrder",
  "kind": "instance",
  "first-tactic": "classical\n  exact Lattice.toLinearOrder Prop",
  "core-prompt": " : LinearOrder Prop",
  "args": ""},
 {"type": "Disjoint f g ↔ ∀ i, Disjoint (f i) (g i)",
  "tactic-prompt":
  "theorem {ι : Type _}  {α' : ι → Type _}  [∀ i, PartialOrder (α' i)] [∀ i, OrderBot (α' i)]  {f g : ∀ i, α' i} : Disjoint f g ↔ ∀ i, Disjoint (f i) (g i) := by classical\n  constructor\n  · intro h i x hf hg\n    refine' (update_le_iff.mp <| h (update_le_iff.mpr ⟨hf, fun _ _ => _⟩)\n      (update_le_iff.mpr ⟨hg, fun _ _ => _⟩)).1\n    · exact bot_le\n    · exact bot_le\n  · intro h x hf hg i\n    apply h i (hf i) (hg i); sorry",
  "name": "disjoint_iff",
  "kind": "theorem",
  "first-tactic":
  "classical\n  constructor\n  · intro h i x hf hg\n    refine' (update_le_iff.mp <| h (update_le_iff.mpr ⟨hf, fun _ _ => _⟩)\n      (update_le_iff.mpr ⟨hg, fun _ _ => _⟩)).1\n    · exact bot_le\n    · exact bot_le\n  · intro h x hf hg i\n    apply h i (hf i) (hg i)",
  "core-prompt":
  "{ι : Type _}  {α' : ι → Type _}  [∀ i, PartialOrder (α' i)] [∀ i, OrderBot (α' i)]  {f g : ∀ i, α' i} : Disjoint f g ↔ ∀ i, Disjoint (f i) (g i)",
  "args":
  "{ι : Type _}  {α' : ι → Type _}  [∀ i, PartialOrder (α' i)] [∀ i, OrderBot (α' i)]  {f g : ∀ i, α' i}"},
 {"type": "IsCompl f g ↔ ∀ i, IsCompl (f i) (g i)",
  "tactic-prompt":
  "theorem {ι : Type _}  {α' : ι → Type _}  [∀ i, PartialOrder (α' i)] [∀ i, BoundedOrder (α' i)]  {f g : ∀ i, α' i} : IsCompl f g ↔ ∀ i, IsCompl (f i) (g i) := by simp_rw [_root_.isCompl_iff]; sorry",
  "name": "isCompl_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [_root_.isCompl_iff]",
  "core-prompt":
  "{ι : Type _}  {α' : ι → Type _}  [∀ i, PartialOrder (α' i)] [∀ i, BoundedOrder (α' i)]  {f g : ∀ i, α' i} : IsCompl f g ↔ ∀ i, IsCompl (f i) (g i)",
  "args":
  "{ι : Type _}  {α' : ι → Type _}  [∀ i, PartialOrder (α' i)] [∀ i, BoundedOrder (α' i)]  {f g : ∀ i, α' i}"},
 {"type": "IsCompl P Q ↔ ¬(P ↔ Q)",
  "tactic-prompt":
  "theorem {ι : Type _}  {α' : ι → Type _}  [∀ i, PartialOrder (α' i)] {P Q : Prop} : IsCompl P Q ↔ ¬(P ↔ Q) := by rw [_root_.isCompl_iff]; sorry",
  "name": "Prop.isCompl_iff",
  "kind": "theorem",
  "first-tactic": "rw [_root_.isCompl_iff]",
  "core-prompt":
  "{ι : Type _}  {α' : ι → Type _}  [∀ i, PartialOrder (α' i)] {P Q : Prop} : IsCompl P Q ↔ ¬(P ↔ Q)",
  "args":
  "{ι : Type _}  {α' : ι → Type _}  [∀ i, PartialOrder (α' i)] {P Q : Prop}"},
 {"type": "min a b = if b ≤ a then b else a",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [LinearOrder α]  (a b : α) : min a b = if b ≤ a then b else a := by rw [min_def]; sorry",
  "name": "min_def'",
  "kind": "theorem",
  "first-tactic": "rw [min_def]",
  "core-prompt":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [LinearOrder α]  (a b : α) : min a b = if b ≤ a then b else a",
  "args":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [LinearOrder α]  (a b : α)"},
 {"type": "max a b = if b ≤ a then a else b",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [LinearOrder α]  (a b : α) : max a b = if b ≤ a then a else b := by rw [max_def]; sorry",
  "name": "max_def'",
  "kind": "theorem",
  "first-tactic": "rw [max_def]",
  "core-prompt":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [LinearOrder α]  (a b : α) : max a b = if b ≤ a then a else b",
  "args":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [LinearOrder α]  (a b : α)"},
 {"type": "x < y ↔ x ≤ y ∧ ∃ i, x i < y i",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} {ι : Type u}  {α : ι → Type v}  [∀ i, Preorder (α i)]  {x y : ∀ i, α i} : x < y ↔ x ≤ y ∧ ∃ i, x i < y i := by simp (config := { contextual := true }) [lt_iff_le_not_le]; sorry",
  "name": "Pi.lt_def",
  "kind": "theorem",
  "first-tactic": "simp (config := { contextual := true }) [lt_iff_le_not_le]",
  "core-prompt":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} {ι : Type u}  {α : ι → Type v}  [∀ i, Preorder (α i)]  {x y : ∀ i, α i} : x < y ↔ x ≤ y ∧ ∃ i, x i < y i",
  "args":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} {ι : Type u}  {α : ι → Type v}  [∀ i, Preorder (α i)]  {x y : ∀ i, α i}"},
 {"type":
  "Function.update x i a ≤ Function.update y i b ↔ a ≤ b ∧ ∀ (j) (_ : j ≠ i), x j ≤ y j",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [DecidableEq ι]  [∀ i, Preorder (π i)]  {x y : ∀ i, π i}  {i : ι}  {a b : π i} : Function.update x i a ≤ Function.update y i b ↔ a ≤ b ∧ ∀ (j) (_ : j ≠ i), x j ≤ y j := by simp (config := { contextual := true }) [update_le_iff]; sorry",
  "name": "update_le_update_iff",
  "kind": "theorem",
  "first-tactic": "simp (config := { contextual := true }) [update_le_iff]",
  "core-prompt":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [DecidableEq ι]  [∀ i, Preorder (π i)]  {x y : ∀ i, π i}  {i : ι}  {a b : π i} : Function.update x i a ≤ Function.update y i b ↔ a ≤ b ∧ ∀ (j) (_ : j ≠ i), x j ≤ y j",
  "args":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [DecidableEq ι]  [∀ i, Preorder (π i)]  {x y : ∀ i, π i}  {i : ι}  {a b : π i}"},
 {"type": "x ≤ update x i a ↔ x i ≤ a",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [DecidableEq ι]  [∀ i, Preorder (π i)]  {x y : ∀ i, π i}  {i : ι}  {a b : π i} : x ≤ update x i a ↔ x i ≤ a := by simp [le_update_iff]; sorry",
  "name": "le_update_self_iff",
  "kind": "theorem",
  "first-tactic": "simp [le_update_iff]",
  "core-prompt":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [DecidableEq ι]  [∀ i, Preorder (π i)]  {x y : ∀ i, π i}  {i : ι}  {a b : π i} : x ≤ update x i a ↔ x i ≤ a",
  "args":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [DecidableEq ι]  [∀ i, Preorder (π i)]  {x y : ∀ i, π i}  {i : ι}  {a b : π i}"},
 {"type": "update x i a ≤ x ↔ a ≤ x i",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [DecidableEq ι]  [∀ i, Preorder (π i)]  {x y : ∀ i, π i}  {i : ι}  {a b : π i} : update x i a ≤ x ↔ a ≤ x i := by simp [update_le_iff]; sorry",
  "name": "update_le_self_iff",
  "kind": "theorem",
  "first-tactic": "simp [update_le_iff]",
  "core-prompt":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [DecidableEq ι]  [∀ i, Preorder (π i)]  {x y : ∀ i, π i}  {i : ι}  {a b : π i} : update x i a ≤ x ↔ a ≤ x i",
  "args":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [DecidableEq ι]  [∀ i, Preorder (π i)]  {x y : ∀ i, π i}  {i : ι}  {a b : π i}"},
 {"type": "x < update x i a ↔ x i < a",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [DecidableEq ι]  [∀ i, Preorder (π i)]  {x y : ∀ i, π i}  {i : ι}  {a b : π i} : x < update x i a ↔ x i < a := by simp [lt_iff_le_not_le]; sorry",
  "name": "lt_update_self_iff",
  "kind": "theorem",
  "first-tactic": "simp [lt_iff_le_not_le]",
  "core-prompt":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [DecidableEq ι]  [∀ i, Preorder (π i)]  {x y : ∀ i, π i}  {i : ι}  {a b : π i} : x < update x i a ↔ x i < a",
  "args":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [DecidableEq ι]  [∀ i, Preorder (π i)]  {x y : ∀ i, π i}  {i : ι}  {a b : π i}"},
 {"type": "update x i a < x ↔ a < x i",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [DecidableEq ι]  [∀ i, Preorder (π i)]  {x y : ∀ i, π i}  {i : ι}  {a b : π i} : update x i a < x ↔ a < x i := by simp [lt_iff_le_not_le]; sorry",
  "name": "update_lt_self_iff",
  "kind": "theorem",
  "first-tactic": "simp [lt_iff_le_not_le]",
  "core-prompt":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [DecidableEq ι]  [∀ i, Preorder (π i)]  {x y : ∀ i, π i}  {i : ι}  {a b : π i} : update x i a < x ↔ a < x i",
  "args":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [DecidableEq ι]  [∀ i, Preorder (π i)]  {x y : ∀ i, π i}  {i : ι}  {a b : π i}"},
 {"type": "const β a ≤ const β b ↔ a ≤ b",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [Preorder α]  [Nonempty β]  {a b : α} : const β a ≤ const β b ↔ a ≤ b := by simp [Pi.le_def]; sorry",
  "name": "const_le_const",
  "kind": "theorem",
  "first-tactic": "simp [Pi.le_def]",
  "core-prompt":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [Preorder α]  [Nonempty β]  {a b : α} : const β a ≤ const β b ↔ a ≤ b",
  "args":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [Preorder α]  [Nonempty β]  {a b : α}"},
 {"type": "const β a < const β b ↔ a < b",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [Preorder α]  [Nonempty β]  {a b : α} : const β a < const β b ↔ a < b := by simpa [Pi.lt_def] using le_of_lt; sorry",
  "name": "const_lt_const",
  "kind": "theorem",
  "first-tactic": "simpa [Pi.lt_def] using le_of_lt",
  "core-prompt":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [Preorder α]  [Nonempty β]  {a b : α} : const β a < const β b ↔ a < b",
  "args":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [Preorder α]  [Nonempty β]  {a b : α}"},
 {"type": "min x y = if x < y then x else y",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [Preorder α]  [Nonempty β]  {a b : α}  [LinearOrder α]  {p : α → Prop}  {x y : α} (x y : α) : min x y = if x < y then x else y := by rw [min_comm]; sorry",
  "name": "min_def_lt",
  "kind": "theorem",
  "first-tactic": "rw [min_comm]",
  "core-prompt":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [Preorder α]  [Nonempty β]  {a b : α}  [LinearOrder α]  {p : α → Prop}  {x y : α} (x y : α) : min x y = if x < y then x else y",
  "args":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [Preorder α]  [Nonempty β]  {a b : α}  [LinearOrder α]  {p : α → Prop}  {x y : α} (x y : α)"},
 {"type": "max x y = if x < y then y else x",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [Preorder α]  [Nonempty β]  {a b : α}  [LinearOrder α]  {p : α → Prop}  {x y : α} (x y : α) : max x y = if x < y then y else x := by rw [max_comm]; sorry",
  "name": "max_def_lt",
  "kind": "theorem",
  "first-tactic": "rw [max_comm]",
  "core-prompt":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [Preorder α]  [Nonempty β]  {a b : α}  [LinearOrder α]  {p : α → Prop}  {x y : α} (x y : α) : max x y = if x < y then y else x",
  "args":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [Preorder α]  [Nonempty β]  {a b : α}  [LinearOrder α]  {p : α → Prop}  {x y : α} (x y : α)"},
 {"type": "x < y ↔ x.1 < y.1 ∧ x.2 ≤ y.2 ∨ x.1 ≤ y.1 ∧ x.2 < y.2",
  "tactic-prompt":
  "theorem {ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [Preorder α]  [Nonempty β]  {a b : α}  [Preorder α]  [Preorder β]  {a a₁ a₂ : α}  {b b₁ b₂ : β}  {x y : α × β} : x < y ↔ x.1 < y.1 ∧ x.2 ≤ y.2 ∨ x.1 ≤ y.1 ∧ x.2 < y.2 := by refine' ⟨fun h ↦ _, _⟩; sorry",
  "name": "lt_iff",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h ↦ _, _⟩",
  "core-prompt":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [Preorder α]  [Nonempty β]  {a b : α}  [Preorder α]  [Preorder β]  {a a₁ a₂ : α}  {b b₁ b₂ : β}  {x y : α × β} : x < y ↔ x.1 < y.1 ∧ x.2 ≤ y.2 ∨ x.1 ≤ y.1 ∧ x.2 < y.2",
  "args":
  "{ι : Type _}  {α : Type u}  {β : Type v}  {γ : Type w}  {π : ι → Type _}  {r : α → α → Prop} [Preorder α]  {x y z : α} [Preorder α]  [Nonempty β]  {a b : α}  [Preorder α]  [Preorder β]  {a a₁ a₂ : α}  {b b₁ b₂ : β}  {x y : α × β}"},
 {"type": "o.swap.Compares a b ↔ o.Compares b a",
  "tactic-prompt":
  "theorem {α β : Type _} [LT α]  {a b : α}  {o : Ordering} : o.swap.Compares a b ↔ o.Compares b a := by cases o; sorry",
  "name": "compares_swap",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{α β : Type _} [LT α]  {a b : α}  {o : Ordering} : o.swap.Compares a b ↔ o.Compares b a",
  "args": "{α β : Type _} [LT α]  {a b : α}  {o : Ordering}"},
 {"type": "o.swap = o' ↔ o = o'.swap",
  "tactic-prompt":
  "theorem {α β : Type _} {o o' : Ordering} : o.swap = o' ↔ o = o'.swap := by rw [← swap_inj]; sorry",
  "name": "swap_eq_iff_eq_swap",
  "kind": "theorem",
  "first-tactic": "rw [← swap_inj]",
  "core-prompt": "{α β : Type _} {o o' : Ordering} : o.swap = o' ↔ o = o'.swap",
  "args": "{α β : Type _} {o o' : Ordering}"},
 {"type": "Compares o (toDual a) (toDual b) ↔ Compares o b a",
  "tactic-prompt":
  "theorem {α β : Type _} [LT α]  {a b : α}  {o : Ordering} : Compares o (toDual a) (toDual b) ↔ Compares o b a := by cases o; sorry",
  "name": "toDual_compares_toDual",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{α β : Type _} [LT α]  {a b : α}  {o : Ordering} : Compares o (toDual a) (toDual b) ↔ Compares o b a",
  "args": "{α β : Type _} [LT α]  {a b : α}  {o : Ordering}"},
 {"type": "Compares o (ofDual a) (ofDual b) ↔ Compares o b a",
  "tactic-prompt":
  "theorem {α β : Type _} [LT α]  {a b : αᵒᵈ}  {o : Ordering} : Compares o (ofDual a) (ofDual b) ↔ Compares o b a := by cases o; sorry",
  "name": "ofDual_compares_ofDual",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{α β : Type _} [LT α]  {a b : αᵒᵈ}  {o : Ordering} : Compares o (ofDual a) (ofDual b) ↔ Compares o b a",
  "args": "{α β : Type _} [LT α]  {a b : αᵒᵈ}  {o : Ordering}"},
 {"type": "(cmp a b).Compares a b",
  "tactic-prompt":
  "theorem {α β : Type _} [LinearOrder α]  (a b : α) : (cmp a b).Compares a b := by obtain h | h | h := lt_trichotomy a b; sorry",
  "name": "cmp_compares",
  "kind": "theorem",
  "first-tactic": "obtain h | h | h := lt_trichotomy a b",
  "core-prompt":
  "{α β : Type _} [LinearOrder α]  (a b : α) : (cmp a b).Compares a b",
  "args": "{α β : Type _} [LinearOrder α]  (a b : α)"},
 {"type": "(cmp a b).swap = cmp b a",
  "tactic-prompt":
  "theorem {α β : Type _} [Preorder α]  [@DecidableRel α (· < ·)]  (a b : α) : (cmp a b).swap = cmp b a := by unfold cmp cmpUsing; sorry",
  "name": "cmp_swap",
  "kind": "theorem",
  "first-tactic": "unfold cmp cmpUsing",
  "core-prompt":
  "{α β : Type _} [Preorder α]  [@DecidableRel α (· < ·)]  (a b : α) : (cmp a b).swap = cmp b a",
  "args": "{α β : Type _} [Preorder α]  [@DecidableRel α (· < ·)]  (a b : α)"},
 {"type": "cmp x x = Ordering.eq",
  "tactic-prompt":
  "theorem {α β : Type _} [LinearOrder α]  (x y : α) : cmp x x = Ordering.eq := by rw [cmp_eq_eq_iff]; sorry",
  "name": "cmp_self_eq_eq",
  "kind": "theorem",
  "first-tactic": "rw [cmp_eq_eq_iff]",
  "core-prompt":
  "{α β : Type _} [LinearOrder α]  (x y : α) : cmp x x = Ordering.eq",
  "args": "{α β : Type _} [LinearOrder α]  (x y : α)"},
 {"type": "x < y ↔ x' < y'",
  "tactic-prompt":
  "theorem {α β : Type _} [LinearOrder α]  (x y : α) (h : cmp x y = cmp x' y') : x < y ↔ x' < y' := by rw [← cmp_eq_lt_iff]; sorry",
  "name": "lt_iff_lt_of_cmp_eq_cmp",
  "kind": "theorem",
  "first-tactic": "rw [← cmp_eq_lt_iff]",
  "core-prompt":
  "{α β : Type _} [LinearOrder α]  (x y : α) (h : cmp x y = cmp x' y') : x < y ↔ x' < y'",
  "args":
  "{α β : Type _} [LinearOrder α]  (x y : α) (h : cmp x y = cmp x' y')"},
 {"type": "x ≤ y ↔ x' ≤ y'",
  "tactic-prompt":
  "theorem {α β : Type _} [LinearOrder α]  (x y : α) (h : cmp x y = cmp x' y') : x ≤ y ↔ x' ≤ y' := by rw [← not_lt]; sorry",
  "name": "le_iff_le_of_cmp_eq_cmp",
  "kind": "theorem",
  "first-tactic": "rw [← not_lt]",
  "core-prompt":
  "{α β : Type _} [LinearOrder α]  (x y : α) (h : cmp x y = cmp x' y') : x ≤ y ↔ x' ≤ y'",
  "args":
  "{α β : Type _} [LinearOrder α]  (x y : α) (h : cmp x y = cmp x' y')"},
 {"type": "x = y ↔ x' = y'",
  "tactic-prompt":
  "theorem {α β : Type _} [LinearOrder α]  (x y : α) (h : cmp x y = cmp x' y') : x = y ↔ x' = y' := by rw [le_antisymm_iff]; sorry",
  "name": "eq_iff_eq_of_cmp_eq_cmp",
  "kind": "theorem",
  "first-tactic": "rw [le_antisymm_iff]",
  "core-prompt":
  "{α β : Type _} [LinearOrder α]  (x y : α) (h : cmp x y = cmp x' y') : x = y ↔ x' = y'",
  "args":
  "{α β : Type _} [LinearOrder α]  (x y : α) (h : cmp x y = cmp x' y')"},
 {"type": "x \\ y ⊔ x ⊓ y = x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (x y : α) : x \\ y ⊔ x ⊓ y = x := by rw [sup_comm]; sorry",
  "name": "sup_sdiff_inf",
  "kind": "theorem",
  "first-tactic": "rw [sup_comm]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (x y : α) : x \\ y ⊔ x ⊓ y = x",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (x y : α)"},
 {"type": "x \\ y ⊓ (x ⊓ y) = ⊥",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (x y : α) : x \\ y ⊓ (x ⊓ y) = ⊥ := by rw [inf_comm]; sorry",
  "name": "inf_sdiff_inf",
  "kind": "theorem",
  "first-tactic": "rw [inf_comm]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (x y : α) : x \\ y ⊓ (x ⊓ y) = ⊥",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (x y : α)"},
 {"type": "x \\ y = z",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (s : x ⊓ y ⊔ z = x)  (i : x ⊓ y ⊓ z = ⊥) : x \\ y = z := by conv_rhs at s => rw [← sup_inf_sdiff x y]; sorry",
  "name": "sdiff_unique",
  "kind": "theorem",
  "first-tactic": "conv_rhs at s => rw [← sup_inf_sdiff x y]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (s : x ⊓ y ⊔ z = x)  (i : x ⊓ y ⊓ z = ⊥) : x \\ y = z",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (s : x ⊓ y ⊔ z = x)  (i : x ⊓ y ⊓ z = ⊥)"},
 {"type": "y \\ x ⊓ x = ⊥",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] : y \\ x ⊓ x = ⊥ := by rw [inf_comm]; sorry",
  "name": "inf_sdiff_self_left",
  "kind": "theorem",
  "first-tactic": "rw [inf_comm]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] : y \\ x ⊓ x = ⊥",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α]"},
 {"type": "z ⊓ y \\ x = ⊥ ↔ z ≤ x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (hz : z ≤ y)  (hx : x ≤ y) : z ⊓ y \\ x = ⊥ ↔ z ≤ x := by rw [← disjoint_iff]; sorry",
  "name": "inf_sdiff_eq_bot_iff",
  "kind": "theorem",
  "first-tactic": "rw [← disjoint_iff]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (hz : z ≤ y)  (hx : x ≤ y) : z ⊓ y \\ x = ⊥ ↔ z ≤ x",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (hz : z ≤ y)  (hx : x ≤ y)"},
 {"type": "x \\ y = x ↔ Disjoint x y",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] : x \\ y = x ↔ Disjoint x y := by rw [sdiff_eq_self_iff_disjoint]; sorry",
  "name": "sdiff_eq_self_iff_disjoint'",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_eq_self_iff_disjoint]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] : x \\ y = x ↔ Disjoint x y",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α]"},
 {"type": "x \\ y < x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (hx : y ≤ x)  (hy : y ≠ ⊥) : x \\ y < x := by refine' sdiff_le.lt_of_ne fun h => hy _; sorry",
  "name": "sdiff_lt",
  "kind": "theorem",
  "first-tactic": "refine' sdiff_le.lt_of_ne fun h => hy _",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (hx : y ≤ x)  (hy : y ≠ ⊥) : x \\ y < x",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (hx : y ≤ x)  (hy : y ≠ ⊥)"},
 {"type": "x \\ (y \\ z) = x \\ y ⊔ x ⊓ y ⊓ z",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] : x \\ (y \\ z) = x \\ y ⊔ x ⊓ y ⊓ z := by rw [sup_comm]; sorry",
  "name": "sdiff_sdiff_right",
  "kind": "theorem",
  "first-tactic": "rw [sup_comm]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] : x \\ (y \\ z) = x \\ y ⊔ x ⊓ y ⊓ z",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α]"},
 {"type": "x \\ (y \\ z) = x \\ y ⊔ z",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (h : z ≤ x) : x \\ (y \\ z) = x \\ y ⊔ z := by rw [sdiff_sdiff_right']; sorry",
  "name": "sdiff_sdiff_eq_sdiff_sup",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_sdiff_right']",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (h : z ≤ x) : x \\ (y \\ z) = x \\ y ⊔ z",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (h : z ≤ x)"},
 {"type": "x \\ (x \\ y) = x ⊓ y",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] : x \\ (x \\ y) = x ⊓ y := by rw [sdiff_sdiff_right]; sorry",
  "name": "sdiff_sdiff_right_self",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_sdiff_right]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] : x \\ (x \\ y) = x ⊓ y",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α]"},
 {"type": "x \\ (x \\ y) = y",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (h : y ≤ x) : x \\ (x \\ y) = y := by rw [sdiff_sdiff_right_self]; sorry",
  "name": "sdiff_sdiff_eq_self",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_sdiff_right_self]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (h : y ≤ x) : x \\ (x \\ y) = y",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (h : y ≤ x)"},
 {"type": "x \\ z = y",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (hy : y ≤ x)  (h : x \\ y = z) : x \\ z = y := by rw [← h]; sorry",
  "name": "sdiff_eq_symm",
  "kind": "theorem",
  "first-tactic": "rw [← h]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (hy : y ≤ x)  (h : x \\ y = z) : x \\ z = y",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (hy : y ≤ x)  (h : x \\ y = z)"},
 {"type": "x = y",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (hxz : x ≤ z)  (hyz : y ≤ z)  (h : z \\ x = z \\ y) : x = y := by rw [← sdiff_sdiff_eq_self hxz]; sorry",
  "name": "eq_of_sdiff_eq_sdiff",
  "kind": "theorem",
  "first-tactic": "rw [← sdiff_sdiff_eq_self hxz]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (hxz : x ≤ z)  (hyz : y ≤ z)  (h : z \\ x = z \\ y) : x = y",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (hxz : x ≤ z)  (hyz : y ≤ z)  (h : z \\ x = z \\ y)"},
 {"type": "(x \\ y) \\ z = x \\ y ⊓ x \\ z",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] : (x \\ y) \\ z = x \\ y ⊓ x \\ z := by rw [sdiff_sdiff_left]; sorry",
  "name": "sdiff_sdiff_left'",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_sdiff_left]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] : (x \\ y) \\ z = x \\ y ⊓ x \\ z",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α]"},
 {"type": "x \\ z ⊓ y = (x ⊓ y) \\ z",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] : x \\ z ⊓ y = (x ⊓ y) \\ z := by rw [@inf_comm _ _ x]; sorry",
  "name": "inf_sdiff_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [@inf_comm _ _ x]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] : x \\ z ⊓ y = (x ⊓ y) \\ z",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α]"},
 {"type": "a ⊓ b \\ c = (a ⊓ b) \\ (a ⊓ c)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (a b c : α) : a ⊓ b \\ c = (a ⊓ b) \\ (a ⊓ c) := by rw [sdiff_inf]; sorry",
  "name": "inf_sdiff_distrib_left",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_inf]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (a b c : α) : a ⊓ b \\ c = (a ⊓ b) \\ (a ⊓ c)",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (a b c : α)"},
 {"type": "a \\ b ⊓ c = (a ⊓ c) \\ (b ⊓ c)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (a b c : α) : a \\ b ⊓ c = (a ⊓ c) \\ (b ⊓ c) := by simp_rw [@inf_comm _ _ _ c]; sorry",
  "name": "inf_sdiff_distrib_right",
  "kind": "theorem",
  "first-tactic": "simp_rw [@inf_comm _ _ _ c]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (a b c : α) : a \\ b ⊓ c = (a ⊓ c) \\ (b ⊓ c)",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (a b c : α)"},
 {"type": "x ⊔ y < z",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (h : y < z \\ x)  (hxz : x ≤ z) : x ⊔ y < z := by rw [← sup_sdiff_cancel_right hxz]; sorry",
  "name": "sup_lt_of_lt_sdiff_left",
  "kind": "theorem",
  "first-tactic": "rw [← sup_sdiff_cancel_right hxz]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (h : y < z \\ x)  (hxz : x ≤ z) : x ⊔ y < z",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (h : y < z \\ x)  (hxz : x ≤ z)"},
 {"type": "x ⊔ y < z",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (h : x < z \\ y)  (hyz : y ≤ z) : x ⊔ y < z := by rw [← sdiff_sup_cancel hyz]; sorry",
  "name": "sup_lt_of_lt_sdiff_right",
  "kind": "theorem",
  "first-tactic": "rw [← sdiff_sup_cancel hyz]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (h : x < z \\ y)  (hyz : y ≤ z) : x ⊔ y < z",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [GeneralizedBooleanAlgebra α] (h : x < z \\ y)  (hyz : y ≤ z)"},
 {"type": "xᶜ = y ↔ yᶜ = x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] : xᶜ = y ↔ yᶜ = x := by rw [eq_comm]; sorry",
  "name": "compl_eq_comm",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] : xᶜ = y ↔ yᶜ = x",
  "args": "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α]"},
 {"type": "x = yᶜ ↔ y = xᶜ",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] : x = yᶜ ↔ y = xᶜ := by rw [eq_comm]; sorry",
  "name": "eq_compl_comm",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] : x = yᶜ ↔ y = xᶜ",
  "args": "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α]"},
 {"type": "xᶜ ≤ y",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] (h : yᶜ ≤ x) : xᶜ ≤ y := by simpa only [compl_compl] using compl_le_compl h; sorry",
  "name": "compl_le_of_compl_le",
  "kind": "theorem",
  "first-tactic": "simpa only [compl_compl] using compl_le_compl h",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] (h : yᶜ ≤ x) : xᶜ ≤ y",
  "args":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] (h : yᶜ ≤ x)"},
 {"type": "x \\ yᶜ = x ⊓ y",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] : x \\ yᶜ = x ⊓ y := by rw [sdiff_eq]; sorry",
  "name": "sdiff_compl",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_eq]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] : x \\ yᶜ = x ⊓ y",
  "args": "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α]"},
 {"type": "x ⊓ y ⊔ x ⊓ yᶜ = x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] : x ⊓ y ⊔ x ⊓ yᶜ = x := by rw [← sdiff_eq]; sorry",
  "name": "sup_inf_inf_compl",
  "kind": "theorem",
  "first-tactic": "rw [← sdiff_eq]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] : x ⊓ y ⊔ x ⊓ yᶜ = x",
  "args": "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α]"},
 {"type": "(x \\ y)ᶜ = x ⇨ y",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] : (x \\ y)ᶜ = x ⇨ y := by rw [sdiff_eq]; sorry",
  "name": "compl_sdiff",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_eq]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] : (x \\ y)ᶜ = x ⇨ y",
  "args": "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α]"},
 {"type": "xᶜ \\ yᶜ = y \\ x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] : xᶜ \\ yᶜ = y \\ x := by rw [sdiff_compl]; sorry",
  "name": "compl_sdiff_compl",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_compl]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] : xᶜ \\ yᶜ = y \\ x",
  "args": "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α]"},
 {"type": "Disjoint (xᶜ) y ↔ y ≤ x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] : Disjoint (xᶜ) y ↔ y ≤ x := by rw [← le_compl_iff_disjoint_left]; sorry",
  "name": "disjoint_compl_left_iff",
  "kind": "theorem",
  "first-tactic": "rw [← le_compl_iff_disjoint_left]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] : Disjoint (xᶜ) y ↔ y ≤ x",
  "args": "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α]"},
 {"type": "Disjoint x (yᶜ) ↔ x ≤ y",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] : Disjoint x (yᶜ) ↔ x ≤ y := by rw [← le_compl_iff_disjoint_right]; sorry",
  "name": "disjoint_compl_right_iff",
  "kind": "theorem",
  "first-tactic": "rw [← le_compl_iff_disjoint_right]",
  "core-prompt":
  "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α] : Disjoint x (yᶜ) ↔ x ≤ y",
  "args": "{α : Type u}  {β : Type _}  {w x y z : α}  [BooleanAlgebra α]"},
 {"type": "¬IsMin a ↔ ∃ b, b < a",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  {a b : α} : ¬IsMin a ↔ ∃ b, b < a := by simp [lt_iff_le_not_le]; sorry",
  "name": "not_isMin_iff",
  "kind": "theorem",
  "first-tactic": "simp [lt_iff_le_not_le]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a b : α} : ¬IsMin a ↔ ∃ b, b < a",
  "args": "{α β : Type _}  [Preorder α]  {a b : α}"},
 {"type": "¬IsMax a ↔ ∃ b, a < b",
  "tactic-prompt":
  "theorem {α β : Type _}  [Preorder α]  {a b : α} : ¬IsMax a ↔ ∃ b, a < b := by simp [lt_iff_le_not_le]; sorry",
  "name": "not_isMax_iff",
  "kind": "theorem",
  "first-tactic": "simp [lt_iff_le_not_le]",
  "core-prompt":
  "{α β : Type _}  [Preorder α]  {a b : α} : ¬IsMax a ↔ ∃ b, a < b",
  "args": "{α β : Type _}  [Preorder α]  {a b : α}"},
 {"type": "a ≤ b ↔ ∃ c, b = a ⊔ c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} : a ≤ b ↔ ∃ c, b = a ⊔ c := by constructor; sorry",
  "name": "le_iff_exists_sup",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} : a ≤ b ↔ ∃ c, b = a ⊔ c",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α}"},
 {"type": "a ⊔ a = a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} : a ⊔ a = a := by simp; sorry",
  "name": "sup_idem",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} : a ⊔ a = a",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α}"},
 {"type": "a ⊔ b = b ⊔ a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} : a ⊔ b = b ⊔ a := by apply le_antisymm; sorry",
  "name": "sup_comm",
  "kind": "theorem",
  "first-tactic": "apply le_antisymm",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} : a ⊔ b = b ⊔ a",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α}"},
 {"type": "a ⊔ b ⊔ c = c ⊔ b ⊔ a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c : α) : a ⊔ b ⊔ c = c ⊔ b ⊔ a := by rw [sup_comm]; sorry",
  "name": "sup_left_right_swap",
  "kind": "theorem",
  "first-tactic": "rw [sup_comm]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c : α) : a ⊔ b ⊔ c = c ⊔ b ⊔ a",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c : α)"},
 {"type": "a ⊔ (a ⊔ b) = a ⊔ b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} : a ⊔ (a ⊔ b) = a ⊔ b := by simp; sorry",
  "name": "sup_left_idem",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} : a ⊔ (a ⊔ b) = a ⊔ b",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α}"},
 {"type": "a ⊔ b ⊔ b = a ⊔ b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} : a ⊔ b ⊔ b = a ⊔ b := by simp; sorry",
  "name": "sup_right_idem",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} : a ⊔ b ⊔ b = a ⊔ b",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α}"},
 {"type": "a ⊔ (b ⊔ c) = b ⊔ (a ⊔ c)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c : α) : a ⊔ (b ⊔ c) = b ⊔ (a ⊔ c) := by rw [← sup_assoc]; sorry",
  "name": "sup_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [← sup_assoc]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c : α) : a ⊔ (b ⊔ c) = b ⊔ (a ⊔ c)",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c : α)"},
 {"type": "a ⊔ b ⊔ c = a ⊔ c ⊔ b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c : α) : a ⊔ b ⊔ c = a ⊔ c ⊔ b := by rw [sup_assoc]; sorry",
  "name": "sup_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [sup_assoc]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c : α) : a ⊔ b ⊔ c = a ⊔ c ⊔ b",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c : α)"},
 {"type": "a ⊔ b ⊔ (c ⊔ d) = a ⊔ c ⊔ (b ⊔ d)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c d : α) : a ⊔ b ⊔ (c ⊔ d) = a ⊔ c ⊔ (b ⊔ d) := by rw [sup_assoc]; sorry",
  "name": "sup_sup_sup_comm",
  "kind": "theorem",
  "first-tactic": "rw [sup_assoc]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c d : α) : a ⊔ b ⊔ (c ⊔ d) = a ⊔ c ⊔ (b ⊔ d)",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c d : α)"},
 {"type": "a ⊔ (b ⊔ c) = a ⊔ b ⊔ (a ⊔ c)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c : α) : a ⊔ (b ⊔ c) = a ⊔ b ⊔ (a ⊔ c) := by rw [sup_sup_sup_comm]; sorry",
  "name": "sup_sup_distrib_left",
  "kind": "theorem",
  "first-tactic": "rw [sup_sup_sup_comm]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c : α) : a ⊔ (b ⊔ c) = a ⊔ b ⊔ (a ⊔ c)",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c : α)"},
 {"type": "a ⊔ b ⊔ c = a ⊔ c ⊔ (b ⊔ c)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c : α) : a ⊔ b ⊔ c = a ⊔ c ⊔ (b ⊔ c) := by rw [sup_sup_sup_comm]; sorry",
  "name": "sup_sup_distrib_right",
  "kind": "theorem",
  "first-tactic": "rw [sup_sup_sup_comm]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c : α) : a ⊔ b ⊔ c = a ⊔ c ⊔ (b ⊔ c)",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup α]  {a b c d : α} (a b c : α)"},
 {"type": "SemilatticeInf α",
  "tactic-prompt":
  "def {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans {α : Type _}  [HasInf α]  (inf_comm : ∀ a b : α, a ⊓ b = b ⊓ a)      (inf_assoc : ∀ a b c : α, a ⊓ b ⊓ c = a ⊓ (b ⊓ c))  (inf_idem : ∀ a : α, a ⊓ a = a) : SemilatticeInf α := by haveI : SemilatticeSup αᵒᵈ := SemilatticeSup.mk' inf_comm inf_assoc inf_idem; sorry",
  "name": "SemilatticeInf.mk'",
  "kind": "def",
  "first-tactic":
  "haveI : SemilatticeSup αᵒᵈ := SemilatticeSup.mk' inf_comm inf_assoc inf_idem",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans {α : Type _}  [HasInf α]  (inf_comm : ∀ a b : α, a ⊓ b = b ⊓ a)      (inf_assoc : ∀ a b c : α, a ⊓ b ⊓ c = a ⊓ (b ⊓ c))  (inf_idem : ∀ a : α, a ⊓ a = a) : SemilatticeInf α",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans {α : Type _}  [HasInf α]  (inf_comm : ∀ a b : α, a ⊓ b = b ⊓ a)      (inf_assoc : ∀ a b c : α, a ⊓ b ⊓ c = a ⊓ (b ⊓ c))  (inf_idem : ∀ a : α, a ⊓ a = a)"},
 {"type": "a ⊓ b < a ⊔ b ↔ a ≠ b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice α]  {a b c d : α} : a ⊓ b < a ⊔ b ↔ a ≠ b := by constructor; sorry",
  "name": "inf_lt_sup",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice α]  {a b c d : α} : a ⊓ b < a ⊔ b ↔ a ≠ b",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice α]  {a b c d : α}"},
 {"type": "a ⊔ b ≤ a ⊓ b ↔ a = b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice α]  {a b c d : α} : a ⊔ b ≤ a ⊓ b ↔ a = b := by simp [le_antisymm_iff]; sorry",
  "name": "sup_le_inf",
  "kind": "theorem",
  "first-tactic": "simp [le_antisymm_iff]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice α]  {a b c d : α} : a ⊔ b ≤ a ⊓ b ↔ a = b",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice α]  {a b c d : α}"},
 {"type": "a ⊓ (a ⊔ b) = a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice α]  {a b c d : α} : a ⊓ (a ⊔ b) = a := by simp; sorry",
  "name": "inf_sup_self",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice α]  {a b c d : α} : a ⊓ (a ⊔ b) = a",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice α]  {a b c d : α}"},
 {"type": "a ⊔ a ⊓ b = a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice α]  {a b c d : α} : a ⊔ a ⊓ b = a := by simp; sorry",
  "name": "sup_inf_self",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice α]  {a b c d : α} : a ⊔ a ⊓ b = a",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice α]  {a b c d : α}"},
 {"type": "a ⊔ b = b ↔ a ⊓ b = a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice α]  {a b c d : α} : a ⊔ b = b ↔ a ⊓ b = a := by rw [sup_eq_right]; sorry",
  "name": "sup_eq_iff_inf_eq",
  "kind": "theorem",
  "first-tactic": "rw [sup_eq_right]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice α]  {a b c d : α} : a ⊔ b = b ↔ a ⊓ b = a",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice α]  {a b c d : α}"},
 {"type": "y ⊓ z ⊔ x = (y ⊔ x) ⊓ (z ⊔ x)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [DistribLattice α]  {x y z : α} : y ⊓ z ⊔ x = (y ⊔ x) ⊓ (z ⊔ x) := by simp only [sup_inf_left]; sorry",
  "name": "sup_inf_right",
  "kind": "theorem",
  "first-tactic": "simp only [sup_inf_left]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [DistribLattice α]  {x y z : α} : y ⊓ z ⊔ x = (y ⊔ x) ⊓ (z ⊔ x)",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [DistribLattice α]  {x y z : α}"},
 {"type": "(y ⊔ z) ⊓ x = y ⊓ x ⊔ z ⊓ x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [DistribLattice α]  {x y z : α} : (y ⊔ z) ⊓ x = y ⊓ x ⊔ z ⊓ x := by simp only [inf_sup_left]; sorry",
  "name": "inf_sup_right",
  "kind": "theorem",
  "first-tactic": "simp only [inf_sup_left]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [DistribLattice α]  {x y z : α} : (y ⊔ z) ⊓ x = y ⊓ x ⊔ z ⊓ x",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [DistribLattice α]  {x y z : α}"},
 {"type": "a ≤ b ⊔ c ↔ a ≤ b ∨ a ≤ c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [LinearOrder α]  {a b c d : α} : a ≤ b ⊔ c ↔ a ≤ b ∨ a ≤ c := by exact ⟨fun h =>\n    (le_total c b).imp\n      (fun bc => by rwa [sup_eq_left.2 bc] at h)\n      (fun bc => by rwa [sup_eq_right.2 bc] at h)]; sorry",
  "name": "le_sup_iff",
  "kind": "theorem",
  "first-tactic":
  "exact ⟨fun h =>\n    (le_total c b).imp\n      (fun bc => by rwa [sup_eq_left.2 bc] at h)\n      (fun bc => by rwa [sup_eq_right.2 bc] at h)]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [LinearOrder α]  {a b c d : α} : a ≤ b ⊔ c ↔ a ≤ b ∨ a ≤ c",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [LinearOrder α]  {a b c d : α}"},
 {"type": "a < b ⊔ c ↔ a < b ∨ a < c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [LinearOrder α]  {a b c d : α} : a < b ⊔ c ↔ a < b ∨ a < c := by exact ⟨fun h =>\n    (le_total c b).imp\n      (fun bc => by rwa [sup_eq_left.2 bc] at h)\n      (fun bc => by rwa [sup_eq_right.2 bc] at h)]; sorry",
  "name": "lt_sup_iff",
  "kind": "theorem",
  "first-tactic":
  "exact ⟨fun h =>\n    (le_total c b).imp\n      (fun bc => by rwa [sup_eq_left.2 bc] at h)\n      (fun bc => by rwa [sup_eq_right.2 bc] at h)]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [LinearOrder α]  {a b c d : α} : a < b ⊔ c ↔ a < b ∨ a < c",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [LinearOrder α]  {a b c d : α}"},
 {"type": "(· ⊔ ·) = (maxDefault : α → α → α)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans [SemilatticeSup α]  [DecidableRel ((· ≤ ·) : α → α → Prop)]      [IsTotal α (· ≤ ·)] : (· ⊔ ·) = (maxDefault : α → α → α) := by ext (x y); sorry",
  "name": "sup_eq_maxDefault",
  "kind": "theorem",
  "first-tactic": "ext (x y)",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans [SemilatticeSup α]  [DecidableRel ((· ≤ ·) : α → α → Prop)]      [IsTotal α (· ≤ ·)] : (· ⊔ ·) = (maxDefault : α → α → α)",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans [SemilatticeSup α]  [DecidableRel ((· ≤ ·) : α → α → Prop)]      [IsTotal α (· ≤ ·)]"},
 {"type": "(· ⊓ ·) = (minDefault : α → α → α)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans [SemilatticeInf α]  [DecidableRel ((· ≤ ·) : α → α → Prop)]      [IsTotal α (· ≤ ·)] : (· ⊓ ·) = (minDefault : α → α → α) := by ext (x y); sorry",
  "name": "inf_eq_minDefault",
  "kind": "theorem",
  "first-tactic": "ext (x y)",
  "core-prompt":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans [SemilatticeInf α]  [DecidableRel ((· ≤ ·) : α → α → Prop)]      [IsTotal α (· ≤ ·)] : (· ⊓ ·) = (minDefault : α → α → α)",
  "args":
  "{α : Type u}  {β : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans [SemilatticeInf α]  [DecidableRel ((· ≤ ·) : α → α → Prop)]      [IsTotal α (· ≤ ·)]"},
 {"type": "u y = z ↔ ∀ x, x ≤ z ↔ l x ≤ y",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [PartialOrder α]  [Preorder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) {z : α}  {y : β} : u y = z ↔ ∀ x, x ≤ z ↔ l x ≤ y := by constructor; sorry",
  "name": "u_eq",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [PartialOrder α]  [Preorder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) {z : α}  {y : β} : u y = z ↔ ∀ x, x ≤ z ↔ l x ≤ y",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [PartialOrder α]  [Preorder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) {z : α}  {y : β}"},
 {"type": "l x = z ↔ ∀ y, z ≤ y ↔ x ≤ u y",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [Preorder α]  [PartialOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) {x : α}  {z : β} : l x = z ↔ ∀ y, z ≤ y ↔ x ≤ u y := by constructor; sorry",
  "name": "l_eq",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [Preorder α]  [PartialOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) {x : α}  {z : β} : l x = z ↔ ∀ y, z ≤ y ↔ x ≤ u y",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [Preorder α]  [PartialOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) {x : α}  {z : β}"},
 {"type": "l (⨆ (i) (j), f i j) = ⨆ (i) (j), l (f i j)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [CompleteLattice α]  [CompleteLattice β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) {f : ∀ i, κ i → α} : l (⨆ (i) (j), f i j) = ⨆ (i) (j), l (f i j) := by simp_rw [gc.l_supᵢ]; sorry",
  "name": "l_supᵢ₂",
  "kind": "theorem",
  "first-tactic": "simp_rw [gc.l_supᵢ]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [CompleteLattice α]  [CompleteLattice β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) {f : ∀ i, κ i → α} : l (⨆ (i) (j), f i j) = ⨆ (i) (j), l (f i j)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [CompleteLattice α]  [CompleteLattice β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) {f : ∀ i, κ i → α}"},
 {"type": "l (supₛ s) = ⨆ a ∈ s, l a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [CompleteLattice α]  [CompleteLattice β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) {s : Set α} : l (supₛ s) = ⨆ a ∈ s, l a := by simp only [supₛ_eq_supᵢ]; sorry",
  "name": "l_supₛ",
  "kind": "theorem",
  "first-tactic": "simp only [supₛ_eq_supᵢ]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [CompleteLattice α]  [CompleteLattice β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) {s : Set α} : l (supₛ s) = ⨆ a ∈ s, l a",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [CompleteLattice α]  [CompleteLattice β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) {s : Set α}"},
 {"type": "GaloisConnection (l2 ∘ l1) (u1 ∘ u2)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u)  [Preorder α]  [Preorder β]  [Preorder γ]  {l1 : α → β}  {u1 : β → α}      {l2 : β → γ}  {u2 : γ → β}  (gc1 : GaloisConnection l1 u1)  (gc2 : GaloisConnection l2 u2) : GaloisConnection (l2 ∘ l1) (u1 ∘ u2) := by intro a b; sorry",
  "name": "compose",
  "kind": "theorem",
  "first-tactic": "intro a b",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u)  [Preorder α]  [Preorder β]  [Preorder γ]  {l1 : α → β}  {u1 : β → α}      {l2 : β → γ}  {u2 : γ → β}  (gc1 : GaloisConnection l1 u1)  (gc2 : GaloisConnection l2 u2) : GaloisConnection (l2 ∘ l1) (u1 ∘ u2)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u)  [Preorder α]  [Preorder β]  [Preorder γ]  {l1 : α → β}  {u1 : β → α}      {l2 : β → γ}  {u2 : γ → β}  (gc1 : GaloisConnection l1 u1)  (gc2 : GaloisConnection l2 u2)"},
 {"type": "supₛ (image2 l s t) = l (supₛ s) (supₛ t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u)  [CompleteLattice α]  [CompleteLattice β]  [CompleteLattice γ]  {f : α → β → γ}  {s : Set α}    {t : Set β}  {l u : α → β → γ}  {l₁ u₁ : β → γ → α}  {l₂ u₂ : α → γ → β} (h₁ : ∀ b, GaloisConnection (swap l b) (u₁ b))      (h₂ : ∀ a, GaloisConnection (l a) (u₂ a)) : supₛ (image2 l s t) = l (supₛ s) (supₛ t) := by simp_rw [supₛ_image2]; sorry",
  "name": "supₛ_image2_eq_supₛ_supₛ",
  "kind": "theorem",
  "first-tactic": "simp_rw [supₛ_image2]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u)  [CompleteLattice α]  [CompleteLattice β]  [CompleteLattice γ]  {f : α → β → γ}  {s : Set α}    {t : Set β}  {l u : α → β → γ}  {l₁ u₁ : β → γ → α}  {l₂ u₂ : α → γ → β} (h₁ : ∀ b, GaloisConnection (swap l b) (u₁ b))      (h₂ : ∀ a, GaloisConnection (l a) (u₂ a)) : supₛ (image2 l s t) = l (supₛ s) (supₛ t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u)  [CompleteLattice α]  [CompleteLattice β]  [CompleteLattice γ]  {f : α → β → γ}  {s : Set α}    {t : Set β}  {l u : α → β → γ}  {l₁ u₁ : β → γ → α}  {l₂ u₂ : α → γ → β} (h₁ : ∀ b, GaloisConnection (swap l b) (u₁ b))      (h₂ : ∀ a, GaloisConnection (l a) (u₂ a))"},
 {"type": "infₛ (image2 u s t) = u (infₛ s) (infₛ t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u)  [CompleteLattice α]  [CompleteLattice β]  [CompleteLattice γ]  {f : α → β → γ}  {s : Set α}    {t : Set β}  {l u : α → β → γ}  {l₁ u₁ : β → γ → α}  {l₂ u₂ : α → γ → β} (h₁ : ∀ b, GaloisConnection (l₁ b) (swap u b))      (h₂ : ∀ a, GaloisConnection (l₂ a) (u a)) : infₛ (image2 u s t) = u (infₛ s) (infₛ t) := by simp_rw [infₛ_image2]; sorry",
  "name": "infₛ_image2_eq_infₛ_infₛ",
  "kind": "theorem",
  "first-tactic": "simp_rw [infₛ_image2]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u)  [CompleteLattice α]  [CompleteLattice β]  [CompleteLattice γ]  {f : α → β → γ}  {s : Set α}    {t : Set β}  {l u : α → β → γ}  {l₁ u₁ : β → γ → α}  {l₂ u₂ : α → γ → β} (h₁ : ∀ b, GaloisConnection (l₁ b) (swap u b))      (h₂ : ∀ a, GaloisConnection (l₂ a) (u a)) : infₛ (image2 u s t) = u (infₛ s) (infₛ t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u)  [CompleteLattice α]  [CompleteLattice β]  [CompleteLattice γ]  {f : α → β → γ}  {s : Set α}    {t : Set β}  {l u : α → β → γ}  {l₁ u₁ : β → γ → α}  {l₂ u₂ : α → γ → β} (h₁ : ∀ b, GaloisConnection (l₁ b) (swap u b))      (h₂ : ∀ a, GaloisConnection (l₂ a) (u a))"},
 {"type": "BddAbove (e ⁻¹' s) ↔ BddAbove s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] (e : α ≃o β)  {s : Set β} : BddAbove (e ⁻¹' s) ↔ BddAbove s := by rw [← e.bddAbove_image]; sorry",
  "name": "bddAbove_preimage",
  "kind": "theorem",
  "first-tactic": "rw [← e.bddAbove_image]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] (e : α ≃o β)  {s : Set β} : BddAbove (e ⁻¹' s) ↔ BddAbove s",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] (e : α ≃o β)  {s : Set β}"},
 {"type": "BddBelow (e ⁻¹' s) ↔ BddBelow s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] (e : α ≃o β)  {s : Set β} : BddBelow (e ⁻¹' s) ↔ BddBelow s := by rw [← e.bddBelow_image]; sorry",
  "name": "bddBelow_preimage",
  "kind": "theorem",
  "first-tactic": "rw [← e.bddBelow_image]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] (e : α ≃o β)  {s : Set β} : BddBelow (e ⁻¹' s) ↔ BddBelow s",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] (e : α ≃o β)  {s : Set β}"},
 {"type": "l (⨆ (i) (hi), u (f i hi)) = ⨆ (i) (hi), f i hi",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] {l : α → β}  {u : β → α} [CompleteLattice α]  [CompleteLattice β]  (gi : GaloisInsertion l u)  {ι : Sort x}      {p : ι → Prop}  (f : ∀ (i) (_ : p i), β) : l (⨆ (i) (hi), u (f i hi)) = ⨆ (i) (hi), f i hi := by simp only [supᵢ_subtype']; sorry",
  "name": "l_bsupᵢ_u",
  "kind": "theorem",
  "first-tactic": "simp only [supᵢ_subtype']",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] {l : α → β}  {u : β → α} [CompleteLattice α]  [CompleteLattice β]  (gi : GaloisInsertion l u)  {ι : Sort x}      {p : ι → Prop}  (f : ∀ (i) (_ : p i), β) : l (⨆ (i) (hi), u (f i hi)) = ⨆ (i) (hi), f i hi",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] {l : α → β}  {u : β → α} [CompleteLattice α]  [CompleteLattice β]  (gi : GaloisInsertion l u)  {ι : Sort x}      {p : ι → Prop}  (f : ∀ (i) (_ : p i), β)"},
 {"type": "l (supₛ (u '' s)) = supₛ s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] {l : α → β}  {u : β → α} [CompleteLattice α]  [CompleteLattice β]  (gi : GaloisInsertion l u)      (s : Set β) : l (supₛ (u '' s)) = supₛ s := by rw [supₛ_image]; sorry",
  "name": "l_supₛ_u_image",
  "kind": "theorem",
  "first-tactic": "rw [supₛ_image]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] {l : α → β}  {u : β → α} [CompleteLattice α]  [CompleteLattice β]  (gi : GaloisInsertion l u)      (s : Set β) : l (supₛ (u '' s)) = supₛ s",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] {l : α → β}  {u : β → α} [CompleteLattice α]  [CompleteLattice β]  (gi : GaloisInsertion l u)      (s : Set β)"},
 {"type": "l (⨅ (i) (hi), u (f i hi)) = ⨅ (i) (hi), f i hi",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] {l : α → β}  {u : β → α} [CompleteLattice α]  [CompleteLattice β]  (gi : GaloisInsertion l u)  {ι : Sort x}      {p : ι → Prop}  (f : ∀ (i) (_ : p i), β) : l (⨅ (i) (hi), u (f i hi)) = ⨅ (i) (hi), f i hi := by simp only [infᵢ_subtype']; sorry",
  "name": "l_binfᵢ_u",
  "kind": "theorem",
  "first-tactic": "simp only [infᵢ_subtype']",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] {l : α → β}  {u : β → α} [CompleteLattice α]  [CompleteLattice β]  (gi : GaloisInsertion l u)  {ι : Sort x}      {p : ι → Prop}  (f : ∀ (i) (_ : p i), β) : l (⨅ (i) (hi), u (f i hi)) = ⨅ (i) (hi), f i hi",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] {l : α → β}  {u : β → α} [CompleteLattice α]  [CompleteLattice β]  (gi : GaloisInsertion l u)  {ι : Sort x}      {p : ι → Prop}  (f : ∀ (i) (_ : p i), β)"},
 {"type": "l (infₛ (u '' s)) = infₛ s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] {l : α → β}  {u : β → α} [CompleteLattice α]  [CompleteLattice β]  (gi : GaloisInsertion l u)      (s : Set β) : l (infₛ (u '' s)) = infₛ s := by rw [infₛ_image]; sorry",
  "name": "l_infₛ_u_image",
  "kind": "theorem",
  "first-tactic": "rw [infₛ_image]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] {l : α → β}  {u : β → α} [CompleteLattice α]  [CompleteLattice β]  (gi : GaloisInsertion l u)      (s : Set β) : l (infₛ (u '' s)) = infₛ s",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] {l : α → β}  {u : β → α} [CompleteLattice α]  [CompleteLattice β]  (gi : GaloisInsertion l u)      (s : Set β)"},
 {"type": "l (⨅ (i) (hi), f i hi) = ⨅ (i) (hi), l (f i hi)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] {l : α → β}  {u : β → α} [CompleteLattice α]  [CompleteLattice β]  (gi : GaloisInsertion l u)      {ι : Sort x}  {p : ι → Prop}  (f : ∀ (i) (_ : p i), α)  (hf : ∀ i hi, u (l (f i hi)) = f i hi) : l (⨅ (i) (hi), f i hi) = ⨅ (i) (hi), l (f i hi) := by rw [infᵢ_subtype']; sorry",
  "name": "l_binfᵢ_of_ul_eq_self",
  "kind": "theorem",
  "first-tactic": "rw [infᵢ_subtype']",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] {l : α → β}  {u : β → α} [CompleteLattice α]  [CompleteLattice β]  (gi : GaloisInsertion l u)      {ι : Sort x}  {p : ι → Prop}  (f : ∀ (i) (_ : p i), α)  (hf : ∀ i hi, u (l (f i hi)) = f i hi) : l (⨅ (i) (hi), f i hi) = ⨅ (i) (hi), l (f i hi)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  {κ : ι → Sort _}  {a a₁ a₂ : α}    {b b₁ b₂ : β}  [LinearOrder α]  [LinearOrder β]  {l : α → β}  {u : β → α}  (gc : GaloisConnection l u) [Preorder α]  [Preorder β] {l : α → β}  {u : β → α} [CompleteLattice α]  [CompleteLattice β]  (gi : GaloisInsertion l u)      {ι : Sort x}  {p : ι → Prop}  (f : ∀ (i) (_ : p i), α)  (hf : ∀ i hi, u (l (f i hi)) = f i hi)"},
 {"type": "¬BddAbove s ↔ ∀ x, ∃ y ∈ s, ¬y ≤ x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} : ¬BddAbove s ↔ ∀ x, ∃ y ∈ s, ¬y ≤ x := by simp [BddAbove]; sorry",
  "name": "not_bddAbove_iff'",
  "kind": "theorem",
  "first-tactic": "simp [BddAbove]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} : ¬BddAbove s ↔ ∀ x, ∃ y ∈ s, ¬y ≤ x",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α}"},
 {"type": "¬BddAbove s ↔ ∀ x, ∃ y ∈ s, x < y",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} {α : Type _}  [LinearOrder α]  {s : Set α} : ¬BddAbove s ↔ ∀ x, ∃ y ∈ s, x < y := by simp only [not_bddAbove_iff']; sorry",
  "name": "not_bddAbove_iff",
  "kind": "theorem",
  "first-tactic": "simp only [not_bddAbove_iff']",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} {α : Type _}  [LinearOrder α]  {s : Set α} : ¬BddAbove s ↔ ∀ x, ∃ y ∈ s, x < y",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} {α : Type _}  [LinearOrder α]  {s : Set α}"},
 {"type": "a ≤ b ↔ b ∈ upperBounds s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} (h : IsLUB s a) : a ≤ b ↔ b ∈ upperBounds s := by rw [h.upperBounds_eq]; sorry",
  "name": "isLUB_le_iff",
  "kind": "theorem",
  "first-tactic": "rw [h.upperBounds_eq]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} (h : IsLUB s a) : a ≤ b ↔ b ∈ upperBounds s",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} (h : IsLUB s a)"},
 {"type": "b ≤ a ↔ b ∈ lowerBounds s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} (h : IsGLB s a) : b ≤ a ↔ b ∈ lowerBounds s := by rw [h.lowerBounds_eq]; sorry",
  "name": "le_isGLB_iff",
  "kind": "theorem",
  "first-tactic": "rw [h.lowerBounds_eq]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} (h : IsGLB s a) : b ≤ a ↔ b ∈ lowerBounds s",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} (h : IsGLB s a)"},
 {"type":
  "IsLeast (s ∪ t) a ↔ IsLeast s a ∧ a ∈ lowerBounds t ∨ a ∈ lowerBounds s ∧ IsLeast t a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} {a : α}  {s t : Set α} : IsLeast (s ∪ t) a ↔ IsLeast s a ∧ a ∈ lowerBounds t ∨ a ∈ lowerBounds s ∧ IsLeast t a := by simp [IsLeast]; sorry",
  "name": "isLeast_union_iff",
  "kind": "theorem",
  "first-tactic": "simp [IsLeast]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} {a : α}  {s t : Set α} : IsLeast (s ∪ t) a ↔ IsLeast s a ∧ a ∈ lowerBounds t ∨ a ∈ lowerBounds s ∧ IsLeast t a",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} {a : α}  {s t : Set α}"},
 {"type": "BddAbove s → BddAbove t → BddAbove (s ∪ t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [SemilatticeSup γ]  {s t : Set γ} : BddAbove s → BddAbove t → BddAbove (s ∪ t) := by rintro ⟨bs, hs⟩ ⟨bt, ht⟩; sorry",
  "name": "BddAbove.union",
  "kind": "theorem",
  "first-tactic": "rintro ⟨bs, hs⟩ ⟨bt, ht⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [SemilatticeSup γ]  {s t : Set γ} : BddAbove s → BddAbove t → BddAbove (s ∪ t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [SemilatticeSup γ]  {s t : Set γ}"},
 {"type": "BddAbove s ↔ ∃ x, x₀ ≤ x ∧ ∀ y ∈ s, y ≤ x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [SemilatticeSup γ]  {s : Set γ}  (x₀ : γ) : BddAbove s ↔ ∃ x, x₀ ≤ x ∧ ∀ y ∈ s, y ≤ x := by rw [bddAbove_def]; sorry",
  "name": "bddAbove_iff_exists_ge",
  "kind": "theorem",
  "first-tactic": "rw [bddAbove_def]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [SemilatticeSup γ]  {s : Set γ}  (x₀ : γ) : BddAbove s ↔ ∃ x, x₀ ≤ x ∧ ∀ y ∈ s, y ≤ x",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [SemilatticeSup γ]  {s : Set γ}  (x₀ : γ)"},
 {"type": "j = i ∨ Iio i = Iic j",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [PartialOrder γ]  {j : γ}  (i : γ)  (hj : IsLUB (Iio i) j) : j = i ∨ Iio i = Iic j := by cases' eq_or_lt_of_le (lub_Iio_le i hj) with hj_eq_i hj_lt_i; sorry",
  "name": "lub_Iio_eq_self_or_Iio_eq_Iic",
  "kind": "theorem",
  "first-tactic":
  "cases' eq_or_lt_of_le (lub_Iio_le i hj) with hj_eq_i hj_lt_i",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [PartialOrder γ]  {j : γ}  (i : γ)  (hj : IsLUB (Iio i) j) : j = i ∨ Iio i = Iic j",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [PartialOrder γ]  {j : γ}  (i : γ)  (hj : IsLUB (Iio i) j)"},
 {"type": "∃ j, IsLUB (Iio i) j",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α}  [LinearOrder γ] (i : γ) : ∃ j, IsLUB (Iio i) j := by by_cases h_exists_lt : ∃ j, j ∈ upperBounds (Iio i) ∧ j < i; sorry",
  "name": "exists_lub_Iio",
  "kind": "theorem",
  "first-tactic": "by_cases h_exists_lt : ∃ j, j ∈ upperBounds (Iio i) ∧ j < i",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α}  [LinearOrder γ] (i : γ) : ∃ j, IsLUB (Iio i) j",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α}  [LinearOrder γ] (i : γ)"},
 {"type": "IsLUB (Ioo a b) b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α}  [SemilatticeInf γ]  [DenselyOrdered γ] {a b : γ}  (hab : a < b) : IsLUB (Ioo a b) b := by simpa only [dual_Ioo] using isGLB_Ioo hab.dual; sorry",
  "name": "isLUB_Ioo",
  "kind": "theorem",
  "first-tactic": "simpa only [dual_Ioo] using isGLB_Ioo hab.dual",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α}  [SemilatticeInf γ]  [DenselyOrdered γ] {a b : γ}  (hab : a < b) : IsLUB (Ioo a b) b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α}  [SemilatticeInf γ]  [DenselyOrdered γ] {a b : γ}  (hab : a < b)"},
 {"type": "IsLUB (Ico a b) b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α}  [SemilatticeInf γ]  [DenselyOrdered γ] {a b : γ}  (hab : a < b) : IsLUB (Ico a b) b := by simpa only [dual_Ioc] using isGLB_Ioc hab.dual; sorry",
  "name": "isLUB_Ico",
  "kind": "theorem",
  "first-tactic": "simpa only [dual_Ioc] using isGLB_Ioc hab.dual",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α}  [SemilatticeInf γ]  [DenselyOrdered γ] {a b : γ}  (hab : a < b) : IsLUB (Ico a b) b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α}  [SemilatticeInf γ]  [DenselyOrdered γ] {a b : γ}  (hab : a < b)"},
 {"type": "BddBelow s ∧ BddAbove s ↔ ∃ a b, s ⊆ Icc a b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} : BddBelow s ∧ BddAbove s ↔ ∃ a b, s ⊆ Icc a b := by simp [Ici_inter_Iic.symm]; sorry",
  "name": "bddBelow_bddAbove_iff_subset_Icc",
  "kind": "theorem",
  "first-tactic": "simp [Ici_inter_Iic.symm]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} : BddBelow s ∧ BddAbove s ↔ ∃ a b, s ⊆ Icc a b",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α}"},
 {"type": "upperBounds (univ : Set γ) = {⊤}",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [PartialOrder γ]  [OrderTop γ] : upperBounds (univ : Set γ) = {⊤} := by rw [isGreatest_univ.upperBounds_eq]; sorry",
  "name": "OrderTop.upperBounds_univ",
  "kind": "theorem",
  "first-tactic": "rw [isGreatest_univ.upperBounds_eq]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [PartialOrder γ]  [OrderTop γ] : upperBounds (univ : Set γ) = {⊤}",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [PartialOrder γ]  [OrderTop γ]"},
 {"type": "¬BddAbove (univ : Set α)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [NoMaxOrder α] : ¬BddAbove (univ : Set α) := by simp [BddAbove]; sorry",
  "name": "not_bddAbove_univ",
  "kind": "theorem",
  "first-tactic": "simp [BddAbove]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [NoMaxOrder α] : ¬BddAbove (univ : Set α)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [NoMaxOrder α]"},
 {"type": "upperBounds (∅ : Set α) = univ",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} : upperBounds (∅ : Set α) = univ := by simp only [upperBounds]; sorry",
  "name": "upperBounds_empty",
  "kind": "theorem",
  "first-tactic": "simp only [upperBounds]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} : upperBounds (∅ : Set α) = univ",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α}"},
 {"type": "BddAbove (∅ : Set α)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [Nonempty α] : BddAbove (∅ : Set α) := by simp only [BddAbove]; sorry",
  "name": "bddAbove_empty",
  "kind": "theorem",
  "first-tactic": "simp only [BddAbove]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [Nonempty α] : BddAbove (∅ : Set α)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [Nonempty α]"},
 {"type": "BddBelow (∅ : Set α)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [Nonempty α] : BddBelow (∅ : Set α) := by simp only [BddBelow]; sorry",
  "name": "bddBelow_empty",
  "kind": "theorem",
  "first-tactic": "simp only [BddBelow]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [Nonempty α] : BddBelow (∅ : Set α)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [Nonempty α]"},
 {"type": "IsGLB ∅ (⊤ : γ)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [Preorder γ]  [OrderTop γ] : IsGLB ∅ (⊤ : γ) := by simp only [IsGLB]; sorry",
  "name": "isGLB_empty",
  "kind": "theorem",
  "first-tactic": "simp only [IsGLB]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [Preorder γ]  [OrderTop γ] : IsGLB ∅ (⊤ : γ)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [Preorder γ]  [OrderTop γ]"},
 {"type": "BddAbove (insert a s) ↔ BddAbove s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [SemilatticeSup γ]  (a : γ)  {s : Set γ} : BddAbove (insert a s) ↔ BddAbove s := by simp_rw [insert_eq]; sorry",
  "name": "bddAbove_insert",
  "kind": "theorem",
  "first-tactic": "simp_rw [insert_eq]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [SemilatticeSup γ]  (a : γ)  {s : Set γ} : BddAbove (insert a s) ↔ BddAbove s",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [SemilatticeSup γ]  (a : γ)  {s : Set γ}"},
 {"type": "BddBelow (insert a s) ↔ BddBelow s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [SemilatticeInf γ]  (a : γ)  {s : Set γ} : BddBelow (insert a s) ↔ BddBelow s := by simp_rw [insert_eq]; sorry",
  "name": "bddBelow_insert",
  "kind": "theorem",
  "first-tactic": "simp_rw [insert_eq]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [SemilatticeInf γ]  (a : γ)  {s : Set γ} : BddBelow (insert a s) ↔ BddBelow s",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} [SemilatticeInf γ]  (a : γ)  {s : Set γ}"},
 {"type": "upperBounds (insert a s) = Ici a ∩ upperBounds s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} (a : α)  (s : Set α) : upperBounds (insert a s) = Ici a ∩ upperBounds s := by rw [insert_eq]; sorry",
  "name": "upperBounds_insert",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} (a : α)  (s : Set α) : upperBounds (insert a s) = Ici a ∩ upperBounds s",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} (a : α)  (s : Set α)"},
 {"type": "lowerBounds (insert a s) = Iic a ∩ lowerBounds s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} (a : α)  (s : Set α) : lowerBounds (insert a s) = Iic a ∩ lowerBounds s := by rw [insert_eq]; sorry",
  "name": "lowerBounds_insert",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} (a : α)  (s : Set α) : lowerBounds (insert a s) = Iic a ∩ lowerBounds s",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [Preorder α]  [Preorder β]  {s t : Set α}  {a b : α} (a : α)  (s : Set α)"},
 {"type": "b < a ↔ ∃ c ∈ s, b < c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [LinearOrder α]  {s : Set α}  {a b : α} (h : IsLUB s a) : b < a ↔ ∃ c ∈ s, b < c := by simp_rw [← not_le]; sorry",
  "name": "lt_isLUB_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [← not_le]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [LinearOrder α]  {s : Set α}  {a b : α} (h : IsLUB s a) : b < a ↔ ∃ c ∈ s, b < c",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x}  [LinearOrder α]  {s : Set α}  {a b : α} (h : IsLUB s a)"},
 {"type": "f '' (upperBounds s ∩ t) ⊆ upperBounds (f '' s)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) (Hst : s ⊆ t) : f '' (upperBounds s ∩ t) ⊆ upperBounds (f '' s) := by rintro _ ⟨a, ha, rfl⟩; sorry",
  "name": "image_upperBounds_subset_upperBounds_image",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨a, ha, rfl⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) (Hst : s ⊆ t) : f '' (upperBounds s ∩ t) ⊆ upperBounds (f '' s)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) (Hst : s ⊆ t)"},
 {"type": "f '' upperBounds s ⊆ upperBounds (f '' s)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} : f '' upperBounds s ⊆ upperBounds (f '' s) := by rintro _ ⟨a, ha, rfl⟩; sorry",
  "name": "image_upperBounds_subset_upperBounds_image",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨a, ha, rfl⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} : f '' upperBounds s ⊆ upperBounds (f '' s)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α}"},
 {"type":
  "image2 f (upperBounds s) (upperBounds t) ⊆ upperBounds (image2 f s t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Monotone (f a)) : image2 f (upperBounds s) (upperBounds t) ⊆ upperBounds (image2 f s t) := by rintro _ ⟨a, b, ha, hb, rfl⟩; sorry",
  "name": "image2_upperBounds_upperBounds_subset",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨a, b, ha, hb, rfl⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Monotone (f a)) : image2 f (upperBounds s) (upperBounds t) ⊆ upperBounds (image2 f s t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Monotone (f a))"},
 {"type":
  "image2 f (lowerBounds s) (lowerBounds t) ⊆ lowerBounds (image2 f s t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Monotone (f a)) : image2 f (lowerBounds s) (lowerBounds t) ⊆ lowerBounds (image2 f s t) := by rintro _ ⟨a, b, ha, hb, rfl⟩; sorry",
  "name": "image2_lowerBounds_lowerBounds_subset",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨a, b, ha, hb, rfl⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Monotone (f a)) : image2 f (lowerBounds s) (lowerBounds t) ⊆ lowerBounds (image2 f s t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Monotone (f a))"},
 {"type": "BddAbove s → BddAbove t → BddAbove (image2 f s t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Monotone (f a)) : BddAbove s → BddAbove t → BddAbove (image2 f s t) := by rintro ⟨a, ha⟩ ⟨b, hb⟩; sorry",
  "name": "BddAbove.image2",
  "kind": "theorem",
  "first-tactic": "rintro ⟨a, ha⟩ ⟨b, hb⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Monotone (f a)) : BddAbove s → BddAbove t → BddAbove (image2 f s t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Monotone (f a))"},
 {"type": "BddBelow s → BddBelow t → BddBelow (image2 f s t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Monotone (f a)) : BddBelow s → BddBelow t → BddBelow (image2 f s t) := by rintro ⟨a, ha⟩ ⟨b, hb⟩; sorry",
  "name": "BddBelow.image2",
  "kind": "theorem",
  "first-tactic": "rintro ⟨a, ha⟩ ⟨b, hb⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Monotone (f a)) : BddBelow s → BddBelow t → BddBelow (image2 f s t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Monotone (f a))"},
 {"type":
  "image2 f (upperBounds s) (lowerBounds t) ⊆ upperBounds (image2 f s t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Antitone (f a)) : image2 f (upperBounds s) (lowerBounds t) ⊆ upperBounds (image2 f s t) := by rintro _ ⟨a, b, ha, hb, rfl⟩; sorry",
  "name": "image2_upperBounds_lowerBounds_subset_upperBounds_image2",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨a, b, ha, hb, rfl⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Antitone (f a)) : image2 f (upperBounds s) (lowerBounds t) ⊆ upperBounds (image2 f s t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Antitone (f a))"},
 {"type":
  "image2 f (lowerBounds s) (upperBounds t) ⊆ lowerBounds (image2 f s t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Antitone (f a)) : image2 f (lowerBounds s) (upperBounds t) ⊆ lowerBounds (image2 f s t) := by rintro _ ⟨a, b, ha, hb, rfl⟩; sorry",
  "name": "image2_lowerBounds_upperBounds_subset_lowerBounds_image2",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨a, b, ha, hb, rfl⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Antitone (f a)) : image2 f (lowerBounds s) (upperBounds t) ⊆ lowerBounds (image2 f s t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Antitone (f a))"},
 {"type": "BddAbove s → BddBelow t → BddAbove (Set.image2 f s t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Antitone (f a)) : BddAbove s → BddBelow t → BddAbove (Set.image2 f s t) := by rintro ⟨a, ha⟩ ⟨b, hb⟩; sorry",
  "name": "BddAbove.bddAbove_image2_of_bddBelow",
  "kind": "theorem",
  "first-tactic": "rintro ⟨a, ha⟩ ⟨b, hb⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Antitone (f a)) : BddAbove s → BddBelow t → BddAbove (Set.image2 f s t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Antitone (f a))"},
 {"type": "BddBelow s → BddAbove t → BddBelow (Set.image2 f s t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Antitone (f a)) : BddBelow s → BddAbove t → BddBelow (Set.image2 f s t) := by rintro ⟨a, ha⟩ ⟨b, hb⟩; sorry",
  "name": "BddBelow.bddBelow_image2_of_bddAbove",
  "kind": "theorem",
  "first-tactic": "rintro ⟨a, ha⟩ ⟨b, hb⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Antitone (f a)) : BddBelow s → BddAbove t → BddBelow (Set.image2 f s t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Monotone (swap f b))  (h₁ : ∀ a, Antitone (f a))"},
 {"type":
  "image2 f (lowerBounds s) (lowerBounds t) ⊆ upperBounds (image2 f s t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Antitone (f a)) : image2 f (lowerBounds s) (lowerBounds t) ⊆ upperBounds (image2 f s t) := by rintro _ ⟨a, b, ha, hb, rfl⟩; sorry",
  "name": "image2_upperBounds_upperBounds_subset_upperBounds_image2",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨a, b, ha, hb, rfl⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Antitone (f a)) : image2 f (lowerBounds s) (lowerBounds t) ⊆ upperBounds (image2 f s t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Antitone (f a))"},
 {"type":
  "image2 f (upperBounds s) (upperBounds t) ⊆ lowerBounds (image2 f s t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Antitone (f a)) : image2 f (upperBounds s) (upperBounds t) ⊆ lowerBounds (image2 f s t) := by rintro _ ⟨a, b, ha, hb, rfl⟩; sorry",
  "name": "image2_lowerBounds_lowerBounds_subset_lowerBounds_image2",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨a, b, ha, hb, rfl⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Antitone (f a)) : image2 f (upperBounds s) (upperBounds t) ⊆ lowerBounds (image2 f s t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Antitone (f a))"},
 {"type": "BddBelow s → BddBelow t → BddAbove (Set.image2 f s t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Antitone (f a)) : BddBelow s → BddBelow t → BddAbove (Set.image2 f s t) := by rintro ⟨a, ha⟩ ⟨b, hb⟩; sorry",
  "name": "BddBelow.image2_bddAbove",
  "kind": "theorem",
  "first-tactic": "rintro ⟨a, ha⟩ ⟨b, hb⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Antitone (f a)) : BddBelow s → BddBelow t → BddAbove (Set.image2 f s t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Antitone (f a))"},
 {"type": "BddAbove s → BddAbove t → BddBelow (Set.image2 f s t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Antitone (f a)) : BddAbove s → BddAbove t → BddBelow (Set.image2 f s t) := by rintro ⟨a, ha⟩ ⟨b, hb⟩; sorry",
  "name": "BddAbove.image2_bddBelow",
  "kind": "theorem",
  "first-tactic": "rintro ⟨a, ha⟩ ⟨b, hb⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Antitone (f a)) : BddAbove s → BddAbove t → BddBelow (Set.image2 f s t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Antitone (f a))"},
 {"type":
  "image2 f (lowerBounds s) (upperBounds t) ⊆ upperBounds (image2 f s t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Monotone (f a)) : image2 f (lowerBounds s) (upperBounds t) ⊆ upperBounds (image2 f s t) := by rintro _ ⟨a, b, ha, hb, rfl⟩; sorry",
  "name": "image2_lowerBounds_upperBounds_subset_upperBounds_image2",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨a, b, ha, hb, rfl⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Monotone (f a)) : image2 f (lowerBounds s) (upperBounds t) ⊆ upperBounds (image2 f s t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Monotone (f a))"},
 {"type":
  "image2 f (upperBounds s) (lowerBounds t) ⊆ lowerBounds (image2 f s t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Monotone (f a)) : image2 f (upperBounds s) (lowerBounds t) ⊆ lowerBounds (image2 f s t) := by rintro _ ⟨a, b, ha, hb, rfl⟩; sorry",
  "name": "image2_upperBounds_lowerBounds_subset_lowerBounds_image2",
  "kind": "theorem",
  "first-tactic": "rintro _ ⟨a, b, ha, hb, rfl⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Monotone (f a)) : image2 f (upperBounds s) (lowerBounds t) ⊆ lowerBounds (image2 f s t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Monotone (f a))"},
 {"type": "BddBelow s → BddAbove t → BddAbove (Set.image2 f s t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Monotone (f a)) : BddBelow s → BddAbove t → BddAbove (Set.image2 f s t) := by rintro ⟨a, ha⟩ ⟨b, hb⟩; sorry",
  "name": "BddBelow.bddAbove_image2_of_bddAbove",
  "kind": "theorem",
  "first-tactic": "rintro ⟨a, ha⟩ ⟨b, hb⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Monotone (f a)) : BddBelow s → BddAbove t → BddAbove (Set.image2 f s t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Monotone (f a))"},
 {"type": "BddAbove s → BddBelow t → BddBelow (Set.image2 f s t)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Monotone (f a)) : BddAbove s → BddBelow t → BddBelow (Set.image2 f s t) := by rintro ⟨a, ha⟩ ⟨b, hb⟩; sorry",
  "name": "BddAbove.bddBelow_image2_of_bddAbove",
  "kind": "theorem",
  "first-tactic": "rintro ⟨a, ha⟩ ⟨b, hb⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Monotone (f a)) : BddAbove s → BddBelow t → BddBelow (Set.image2 f s t)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α}  [Preorder α]  [Preorder β]  [Preorder γ]  {f : α → β → γ}  {s : Set α}  {t : Set β}  {a : α}    {b : β}  (h₀ : ∀ b, Antitone (swap f b))  (h₁ : ∀ a, Monotone (f a))"},
 {"type": "IsLUB s f ↔ ∀ a, IsLUB (Function.eval a '' s) (f a)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α} {π : α → Type _}  [∀ a, Preorder (π a)]  {s : Set (∀ a, π a)}  {f : ∀ a, π a} : IsLUB s f ↔ ∀ a, IsLUB (Function.eval a '' s) (f a) := by classical\n    refine'\n      ⟨fun H a => ⟨(Function.monotone_eval a).mem_upperBounds_image H.1, fun b hb => _⟩, fun H =>\n        ⟨_, _⟩⟩\n    · suffices h : Function.update f a b ∈ upperBounds s from Function.update_same a b f ▸ H.2 h a\n      refine' fun g hg => le_update_iff.2 ⟨hb <| mem_image_of_mem _ hg, fun i _ => H.1 hg i⟩\n    · exact fun g hg a => (H a).1 (mem_image_of_mem _ hg)\n    · exact fun g hg a => (H a).2 ((Function.monotone_eval a).mem_upperBounds_image hg); sorry",
  "name": "isLUB_pi",
  "kind": "theorem",
  "first-tactic":
  "classical\n    refine'\n      ⟨fun H a => ⟨(Function.monotone_eval a).mem_upperBounds_image H.1, fun b hb => _⟩, fun H =>\n        ⟨_, _⟩⟩\n    · suffices h : Function.update f a b ∈ upperBounds s from Function.update_same a b f ▸ H.2 h a\n      refine' fun g hg => le_update_iff.2 ⟨hb <| mem_image_of_mem _ hg, fun i _ => H.1 hg i⟩\n    · exact fun g hg a => (H a).1 (mem_image_of_mem _ hg)\n    · exact fun g hg a => (H a).2 ((Function.monotone_eval a).mem_upperBounds_image hg)",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α} {π : α → Type _}  [∀ a, Preorder (π a)]  {s : Set (∀ a, π a)}  {f : ∀ a, π a} : IsLUB s f ↔ ∀ a, IsLUB (Function.eval a '' s) (f a)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α} {π : α → Type _}  [∀ a, Preorder (π a)]  {s : Set (∀ a, π a)}  {f : ∀ a, π a}"},
 {"type": "IsLUB s p ↔ IsLUB (Prod.fst '' s) p.1 ∧ IsLUB (Prod.snd '' s) p.2",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {s : Set (α × β)}  (p : α × β) : IsLUB s p ↔ IsLUB (Prod.fst '' s) p.1 ∧ IsLUB (Prod.snd '' s) p.2 := by refine'\n    ⟨fun H =>\n      ⟨⟨monotone_fst.mem_upperBounds_image H.1, fun a ha => _⟩,\n        ⟨monotone_snd.mem_upperBounds_image H.1, fun a ha => _⟩⟩,\n      fun H => ⟨_, _⟩⟩; sorry",
  "name": "isLUB_prod",
  "kind": "theorem",
  "first-tactic":
  "refine'\n    ⟨fun H =>\n      ⟨⟨monotone_fst.mem_upperBounds_image H.1, fun a ha => _⟩,\n        ⟨monotone_snd.mem_upperBounds_image H.1, fun a ha => _⟩⟩,\n      fun H => ⟨_, _⟩⟩",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {s : Set (α × β)}  (p : α × β) : IsLUB s p ↔ IsLUB (Prod.fst '' s) p.1 ∧ IsLUB (Prod.snd '' s) p.2",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {ι : Sort x} [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : MonotoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  {s t : Set α}  (Hf : AntitoneOn f t)  {a : α}    (Hst : s ⊆ t) [Preorder α]  [Preorder β]  {f : α → β}  (Hf : Monotone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {f : α → β}  (hf : Antitone f)  {a : α}  {s : Set α} [Preorder α]  [Preorder β]  {s : Set (α × β)}  (p : α × β)"},
 {"type": "IsLUB (f '' s) (f x) ↔ IsLUB s x",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β]  (f : α ≃o β) {s : Set α}  {x : α} : IsLUB (f '' s) (f x) ↔ IsLUB s x := by rw [isLUB_image]; sorry",
  "name": "isLUB_image'",
  "kind": "theorem",
  "first-tactic": "rw [isLUB_image]",
  "core-prompt":
  "[Preorder α]  [Preorder β]  (f : α ≃o β) {s : Set α}  {x : α} : IsLUB (f '' s) (f x) ↔ IsLUB s x",
  "args": "[Preorder α]  [Preorder β]  (f : α ≃o β) {s : Set α}  {x : α}"},
 {"type": "IsLUB (f ⁻¹' s) x ↔ IsLUB s (f x)",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β]  (f : α ≃o β) {s : Set β}  {x : α} : IsLUB (f ⁻¹' s) x ↔ IsLUB s (f x) := by rw [← f.symm_symm]; sorry",
  "name": "isLUB_preimage",
  "kind": "theorem",
  "first-tactic": "rw [← f.symm_symm]",
  "core-prompt":
  "[Preorder α]  [Preorder β]  (f : α ≃o β) {s : Set β}  {x : α} : IsLUB (f ⁻¹' s) x ↔ IsLUB s (f x)",
  "args": "[Preorder α]  [Preorder β]  (f : α ≃o β) {s : Set β}  {x : α}"},
 {"type": "IsLUB (f ⁻¹' s) (f.symm x) ↔ IsLUB s x",
  "tactic-prompt":
  "theorem [Preorder α]  [Preorder β]  (f : α ≃o β) {s : Set β}  {x : β} : IsLUB (f ⁻¹' s) (f.symm x) ↔ IsLUB s x := by rw [isLUB_preimage]; sorry",
  "name": "isLUB_preimage'",
  "kind": "theorem",
  "first-tactic": "rw [isLUB_preimage]",
  "core-prompt":
  "[Preorder α]  [Preorder β]  (f : α ≃o β) {s : Set β}  {x : β} : IsLUB (f ⁻¹' s) (f.symm x) ↔ IsLUB s x",
  "args": "[Preorder α]  [Preorder β]  (f : α ≃o β) {s : Set β}  {x : β}"},
 {"type": "PSum (OrderTop α) (NoTopOrder α)",
  "tactic-prompt":
  "def {α : Type u}  {β : Type v}  {γ δ : Type _}  (α : Type _)  [LE α] : PSum (OrderTop α) (NoTopOrder α) := by by_cases H : ∀ a : α, ∃ b, ¬b ≤ a; sorry",
  "name": "topOrderOrNoTopOrder",
  "kind": "def",
  "first-tactic": "by_cases H : ∀ a : α, ∃ b, ¬b ≤ a",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ δ : Type _}  (α : Type _)  [LE α] : PSum (OrderTop α) (NoTopOrder α)",
  "args": "{α : Type u}  {β : Type v}  {γ δ : Type _}  (α : Type _)  [LE α]"},
 {"type": "PSum (OrderBot α) (NoBotOrder α)",
  "tactic-prompt":
  "def {α : Type u}  {β : Type v}  {γ δ : Type _}  (α : Type _)  [LE α] : PSum (OrderBot α) (NoBotOrder α) := by by_cases H : ∀ a : α, ∃ b, ¬a ≤ b; sorry",
  "name": "botOrderOrNoBotOrder",
  "kind": "def",
  "first-tactic": "by_cases H : ∀ a : α, ∃ b, ¬a ≤ b",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ δ : Type _}  (α : Type _)  [LE α] : PSum (OrderBot α) (NoBotOrder α)",
  "args": "{α : Type u}  {β : Type v}  {γ δ : Type _}  (α : Type _)  [LE α]"},
 {"type": "a ⊔ b = ⊥ ↔ a = ⊥ ∧ b = ⊥",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ δ : Type _}  [SemilatticeSup α]  [OrderBot α]  {a b : α}  -- Porting note: Not simp because simp can prove it : a ⊔ b = ⊥ ↔ a = ⊥ ∧ b = ⊥ := by rw [eq_bot_iff]; sorry",
  "name": "sup_eq_bot_iff",
  "kind": "theorem",
  "first-tactic": "rw [eq_bot_iff]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ δ : Type _}  [SemilatticeSup α]  [OrderBot α]  {a b : α}  -- Porting note: Not simp because simp can prove it : a ⊔ b = ⊥ ↔ a = ⊥ ∧ b = ⊥",
  "args":
  "{α : Type u}  {β : Type v}  {γ δ : Type _}  [SemilatticeSup α]  [OrderBot α]  {a b : α}  -- Porting note: Not simp because simp can prove it"},
 {"type": "(x : α) = ⊥ ↔ x = ⊥",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ δ : Type _} {ι : Type _}  {α' : ι → Type _}  {p : α → Prop}  -- See note [reducible non-instances] [PartialOrder α] [OrderBot α]  [OrderBot (Subtype p)]  (hbot : p ⊥)  {x : { x // p x }} : (x : α) = ⊥ ↔ x = ⊥ := by rw [← coe_bot hbot]; sorry",
  "name": "coe_eq_bot_iff",
  "kind": "theorem",
  "first-tactic": "rw [← coe_bot hbot]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ δ : Type _} {ι : Type _}  {α' : ι → Type _}  {p : α → Prop}  -- See note [reducible non-instances] [PartialOrder α] [OrderBot α]  [OrderBot (Subtype p)]  (hbot : p ⊥)  {x : { x // p x }} : (x : α) = ⊥ ↔ x = ⊥",
  "args":
  "{α : Type u}  {β : Type v}  {γ δ : Type _} {ι : Type _}  {α' : ι → Type _}  {p : α → Prop}  -- See note [reducible non-instances] [PartialOrder α] [OrderBot α]  [OrderBot (Subtype p)]  (hbot : p ⊥)  {x : { x // p x }}"},
 {"type": "(x : α) = ⊤ ↔ x = ⊤",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ δ : Type _} {ι : Type _}  {α' : ι → Type _}  {p : α → Prop}  -- See note [reducible non-instances] [PartialOrder α] [OrderTop α]  [OrderTop (Subtype p)]  (htop : p ⊤)  {x : { x // p x }} : (x : α) = ⊤ ↔ x = ⊤ := by rw [← coe_top htop]; sorry",
  "name": "coe_eq_top_iff",
  "kind": "theorem",
  "first-tactic": "rw [← coe_top htop]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ δ : Type _} {ι : Type _}  {α' : ι → Type _}  {p : α → Prop}  -- See note [reducible non-instances] [PartialOrder α] [OrderTop α]  [OrderTop (Subtype p)]  (htop : p ⊤)  {x : { x // p x }} : (x : α) = ⊤ ↔ x = ⊤",
  "args":
  "{α : Type u}  {β : Type v}  {γ δ : Type _} {ι : Type _}  {α' : ι → Type _}  {p : α → Prop}  -- See note [reducible non-instances] [PartialOrder α] [OrderTop α]  [OrderTop (Subtype p)]  (htop : p ⊤)  {x : { x // p x }}"},
 {"type": "min a b = ⊥ ↔ a = ⊥ ∨ b = ⊥",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ δ : Type _} {ι : Type _}  {α' : ι → Type _}  {p : α → Prop}  -- See note [reducible non-instances] [PartialOrder α]  [LinearOrder α]  -- `simp` can prove these, so they shouldn't be simp-lemmas. [OrderBot α]  {a b : α} : min a b = ⊥ ↔ a = ⊥ ∨ b = ⊥ := by simp only [← inf_eq_min]; sorry",
  "name": "min_eq_bot",
  "kind": "theorem",
  "first-tactic": "simp only [← inf_eq_min]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ δ : Type _} {ι : Type _}  {α' : ι → Type _}  {p : α → Prop}  -- See note [reducible non-instances] [PartialOrder α]  [LinearOrder α]  -- `simp` can prove these, so they shouldn't be simp-lemmas. [OrderBot α]  {a b : α} : min a b = ⊥ ↔ a = ⊥ ∨ b = ⊥",
  "args":
  "{α : Type u}  {β : Type v}  {γ δ : Type _} {ι : Type _}  {α' : ι → Type _}  {p : α → Prop}  -- See note [reducible non-instances] [PartialOrder α]  [LinearOrder α]  -- `simp` can prove these, so they shouldn't be simp-lemmas. [OrderBot α]  {a b : α}"},
 {"type": "False",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop} {r : α → α → Prop}  [IsWellOrder α r]  (f : r ≺i r) : False := by have h := f.lt_top f.top; sorry",
  "name": "irrefl",
  "kind": "theorem",
  "first-tactic": "have h := f.lt_top f.top",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop} {r : α → α → Prop}  [IsWellOrder α r]  (f : r ≺i r) : False",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop} {r : α → α → Prop}  [IsWellOrder α r]  (f : r ≺i r)"},
 {"type": "f.top = g.top",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop} [IsWellOrder γ t]  (e : r ≃r s)  (f : r ≺i t)  (g : s ≺i t) : f.top = g.top := by rw [Subsingleton.elim f (PrincipalSeg.equivLt e g)]; sorry",
  "name": "top_eq",
  "kind": "theorem",
  "first-tactic": "rw [Subsingleton.elim f (PrincipalSeg.equivLt e g)]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop} [IsWellOrder γ t]  (e : r ≃r s)  (f : r ≺i t)  (g : s ≺i t) : f.top = g.top",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop} [IsWellOrder γ t]  (e : r ≃r s)  (f : r ≺i t)  (g : s ≺i t)"},
 {"type": "t h.top g.top",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop} {r : α → α → Prop}  {s : β → β → Prop}  {t : γ → γ → Prop}  [IsWellOrder γ t]      (f : PrincipalSeg r s)  (g : PrincipalSeg s t)  (h : PrincipalSeg r t) : t h.top g.top := by rw [Subsingleton.elim h (f.trans g)]; sorry",
  "name": "topLtTop",
  "kind": "theorem",
  "first-tactic": "rw [Subsingleton.elim h (f.trans g)]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop} {r : α → α → Prop}  {s : β → β → Prop}  {t : γ → γ → Prop}  [IsWellOrder γ t]      (f : PrincipalSeg r s)  (g : PrincipalSeg s t)  (h : PrincipalSeg r t) : t h.top g.top",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop} {r : α → α → Prop}  {s : β → β → Prop}  {t : γ → γ → Prop}  [IsWellOrder γ t]      (f : PrincipalSeg r s)  (g : PrincipalSeg s t)  (h : PrincipalSeg r t)"},
 {"type": "Sum (r ≺i s) (r ≃r s)",
  "tactic-prompt":
  "def {α : Type _}  {β : Type _}  {γ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop} [IsWellOrder β s]  (f : r ≼i s) : Sum (r ≺i s) (r ≃r s) := by by_cases h : Surjective f; sorry",
  "name": "InitialSeg.ltOrEq",
  "kind": "def",
  "first-tactic": "by_cases h : Surjective f",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop} [IsWellOrder β s]  (f : r ≼i s) : Sum (r ≺i s) (r ≃r s)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop} [IsWellOrder β s]  (f : r ≼i s)"},
 {"type": "(f.leLt g) a = g (f a)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop} [IsWellOrder β s]  [IsTrans γ t]  (f : r ≼i s)  (g : s ≺i t)  (a : α) : (f.leLt g) a = g (f a) := by delta InitialSeg.leLt; sorry",
  "name": "InitialSeg.leLt_apply",
  "kind": "theorem",
  "first-tactic": "delta InitialSeg.leLt",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop} [IsWellOrder β s]  [IsTrans γ t]  (f : r ≼i s)  (g : s ≺i t)  (a : α) : (f.leLt g) a = g (f a)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {r : α → α → Prop}  {s : β → β → Prop}    {t : γ → γ → Prop} [IsWellOrder β s]  [IsTrans γ t]  (f : r ≼i s)  (g : s ≺i t)  (a : α)"},
 {"type": "¬r b a → r b c → r a c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [IsTrans α r]  [IsTrichotomous α r]  {a b c : α} : ¬r b a → r b c → r a c := by intro h₁ h₂; sorry",
  "name": "trans_trichotomous_left",
  "kind": "theorem",
  "first-tactic": "intro h₁ h₂",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [IsTrans α r]  [IsTrichotomous α r]  {a b c : α} : ¬r b a → r b c → r a c",
  "args":
  "{α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [IsTrans α r]  [IsTrichotomous α r]  {a b c : α}"},
 {"type": "r a b → ¬r c b → r a c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [IsTrans α r]  [IsTrichotomous α r]  {a b c : α} : r a b → ¬r c b → r a c := by intro h₁ h₂; sorry",
  "name": "trans_trichotomous_right",
  "kind": "theorem",
  "first-tactic": "intro h₁ h₂",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [IsTrans α r]  [IsTrichotomous α r]  {a b c : α} : r a b → ¬r c b → r a c",
  "args":
  "{α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [IsTrans α r]  [IsTrichotomous α r]  {a b c : α}"},
 {"type": "¬Bounded r s ↔ Unbounded r s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [LT α]  [WellFoundedLt α] [LT α]  [WellFoundedGt α] {r : α → α → Prop}  (s : Set α) : ¬Bounded r s ↔ Unbounded r s := by simp only [Bounded]; sorry",
  "name": "not_bounded_iff",
  "kind": "theorem",
  "first-tactic": "simp only [Bounded]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [LT α]  [WellFoundedLt α] [LT α]  [WellFoundedGt α] {r : α → α → Prop}  (s : Set α) : ¬Bounded r s ↔ Unbounded r s",
  "args":
  "{α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [LT α]  [WellFoundedLt α] [LT α]  [WellFoundedGt α] {r : α → α → Prop}  (s : Set α)"},
 {"type": "¬Unbounded r s ↔ Bounded r s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [LT α]  [WellFoundedLt α] [LT α]  [WellFoundedGt α] {r : α → α → Prop}  (s : Set α) : ¬Unbounded r s ↔ Bounded r s := by rw [not_iff_comm]; sorry",
  "name": "not_unbounded_iff",
  "kind": "theorem",
  "first-tactic": "rw [not_iff_comm]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [LT α]  [WellFoundedLt α] [LT α]  [WellFoundedGt α] {r : α → α → Prop}  (s : Set α) : ¬Unbounded r s ↔ Bounded r s",
  "args":
  "{α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [LT α]  [WellFoundedLt α] [LT α]  [WellFoundedGt α] {r : α → α → Prop}  (s : Set α)"},
 {"type": "IsOrderConnected α (· < ·)",
  "tactic-prompt":
  "instance {α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [LT α]  [WellFoundedLt α] [LT α]  [WellFoundedGt α] [LinearOrder α] : IsOrderConnected α (· < ·) := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [LT α]  [WellFoundedLt α] [LT α]  [WellFoundedGt α] [LinearOrder α] : IsOrderConnected α (· < ·)",
  "args":
  "{α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [LT α]  [WellFoundedLt α] [LT α]  [WellFoundedGt α] [LinearOrder α]"},
 {"type": "IsIncompTrans α (· < ·)",
  "tactic-prompt":
  "instance {α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [LT α]  [WellFoundedLt α] [LT α]  [WellFoundedGt α] [LinearOrder α] : IsIncompTrans α (· < ·) := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [LT α]  [WellFoundedLt α] [LT α]  [WellFoundedGt α] [LinearOrder α] : IsIncompTrans α (· < ·)",
  "args":
  "{α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [LT α]  [WellFoundedLt α] [LT α]  [WellFoundedGt α] [LinearOrder α]"},
 {"type": "IsStrictWeakOrder α (· < ·)",
  "tactic-prompt":
  "instance {α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [LT α]  [WellFoundedLt α] [LT α]  [WellFoundedGt α] [LinearOrder α] : IsStrictWeakOrder α (· < ·) := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [LT α]  [WellFoundedLt α] [LT α]  [WellFoundedGt α] [LinearOrder α] : IsStrictWeakOrder α (· < ·)",
  "args":
  "{α : Type u}  {β : Type v}  {r : α → α → Prop}  {s : β → β → Prop} [LT α]  [WellFoundedLt α] [LT α]  [WellFoundedGt α] [LinearOrder α]"},
 {"type": "min a b = a ∧ a ≤ b ∨ min a b = b ∧ b < a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) (a b : α) : min a b = a ∧ a ≤ b ∨ min a b = b ∧ b < a := by by_cases a ≤ b; sorry",
  "name": "min_cases",
  "kind": "theorem",
  "first-tactic": "by_cases a ≤ b",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) (a b : α) : min a b = a ∧ a ≤ b ∨ min a b = b ∧ b < a",
  "args":
  "{α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) (a b : α)"},
 {"type": "min a b = c ↔ a = c ∧ a ≤ b ∨ b = c ∧ b ≤ a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) : min a b = c ↔ a = c ∧ a ≤ b ∨ b = c ∧ b ≤ a := by constructor; sorry",
  "name": "min_eq_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) : min a b = c ↔ a = c ∧ a ≤ b ∨ b = c ∧ b ≤ a",
  "args":
  "{α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min)"},
 {"type": "min a c < min b c ↔ a < b ∧ a < c",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) : min a c < min b c ↔ a < b ∧ a < c := by simp_rw [lt_min_iff]; sorry",
  "name": "min_lt_min_left_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [lt_min_iff]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) : min a c < min b c ↔ a < b ∧ a < c",
  "args":
  "{α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min)"},
 {"type": "min a b < min a c ↔ b < c ∧ b < a",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) : min a b < min a c ↔ b < c ∧ b < a := by simp_rw [min_comm a]; sorry",
  "name": "min_lt_min_right_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [min_comm a]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) : min a b < min a c ↔ b < c ∧ b < a",
  "args":
  "{α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min)"},
 {"type": "f (max a b) =\n    max (f a) (f b)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) (hf : MonotoneOn f s)  (ha : a ∈ s)  (hb : b ∈ s) : f (max a b) =\n    max (f a) (f b) := by cases le_total a b; sorry",
  "name": "MonotoneOn.map_max",
  "kind": "theorem",
  "first-tactic": "cases le_total a b",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) (hf : MonotoneOn f s)  (ha : a ∈ s)  (hb : b ∈ s) : f (max a b) =\n    max (f a) (f b)",
  "args":
  "{α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) (hf : MonotoneOn f s)  (ha : a ∈ s)  (hb : b ∈ s)"},
 {"type": "f (max a b) = max (f a) (f b)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) (hf : Monotone f) : f (max a b) = max (f a) (f b) := by cases le_total a b; sorry",
  "name": "Monotone.map_max",
  "kind": "theorem",
  "first-tactic": "cases le_total a b",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) (hf : Monotone f) : f (max a b) = max (f a) (f b)",
  "args":
  "{α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) (hf : Monotone f)"},
 {"type": "f (max a b) = min (f a) (f b)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) (hf : Antitone f) : f (max a b) = min (f a) (f b) := by cases le_total a b; sorry",
  "name": "Antitone.map_max",
  "kind": "theorem",
  "first-tactic": "cases le_total a b",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) (hf : Antitone f) : f (max a b) = min (f a) (f b)",
  "args":
  "{α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) (hf : Antitone f)"},
 {"type": "min a b = a ∨ min a b = b",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) (a b : α) : min a b = a ∨ min a b = b := by cases le_total a b; sorry",
  "name": "min_choice",
  "kind": "theorem",
  "first-tactic": "cases le_total a b",
  "core-prompt":
  "{α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) (a b : α) : min a b = a ∨ min a b = b",
  "args":
  "{α : Type u}  {β : Type v}  [LinearOrder α]  [LinearOrder β]  {f : α → β}  {s : Set α}  {a b c d : α}  -- translate from lattices to linear orders (sup → max, inf → min) (a b : α)"},
 {"type": "∀ p q : Bool, p ∆ q = xor p q",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _} : ∀ p q : Bool, p ∆ q = xor p q := by decide; sorry",
  "name": "Bool.symmDiff_eq_xor",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _} : ∀ p q : Bool, p ∆ q = xor p q",
  "args": "{ι α β : Type _}  {π : ι → Type _}"},
 {"type": "a ∆ b = b ∆ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ b = b ∆ a := by simp only [symmDiff]; sorry",
  "name": "symmDiff_comm",
  "kind": "theorem",
  "first-tactic": "simp only [symmDiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ b = b ∆ a",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ a = ⊥",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ a = ⊥ := by rw [symmDiff]; sorry",
  "name": "symmDiff_self",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ a = ⊥",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ ⊥ = a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ ⊥ = a := by rw [symmDiff]; sorry",
  "name": "symmDiff_bot",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ ⊥ = a",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α)"},
 {"type": "⊥ ∆ a = a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : ⊥ ∆ a = a := by rw [symmDiff_comm]; sorry",
  "name": "bot_symmDiff",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : ⊥ ∆ a = a",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ b = ⊥ ↔ a = b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) {a b : α} : a ∆ b = ⊥ ↔ a = b := by simp_rw [symmDiff]; sorry",
  "name": "symmDiff_eq_bot",
  "kind": "theorem",
  "first-tactic": "simp_rw [symmDiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) {a b : α} : a ∆ b = ⊥ ↔ a = b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) {a b : α}"},
 {"type": "a ∆ b = b \\ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) {a b : α}  (h : a ≤ b) : a ∆ b = b \\ a := by rw [symmDiff]; sorry",
  "name": "symmDiff_of_le",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) {a b : α}  (h : a ≤ b) : a ∆ b = b \\ a",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) {a b : α}  (h : a ≤ b)"},
 {"type": "a ∆ b = a \\ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) {a b : α}  (h : b ≤ a) : a ∆ b = a \\ b := by rw [symmDiff]; sorry",
  "name": "symmDiff_of_ge",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) {a b : α}  (h : b ≤ a) : a ∆ b = a \\ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) {a b : α}  (h : b ≤ a)"},
 {"type": "a ∆ b ≤ c ↔ a ≤ b ⊔ c ∧ b ≤ a ⊔ c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) {a b c : α} : a ∆ b ≤ c ↔ a ≤ b ⊔ c ∧ b ≤ a ⊔ c := by simp_rw [symmDiff]; sorry",
  "name": "symmDiff_le_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [symmDiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) {a b c : α} : a ∆ b ≤ c ↔ a ≤ b ⊔ c ∧ b ≤ a ⊔ c",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) {a b c : α}"},
 {"type": "a ∆ b = (a ⊔ b) \\ (a ⊓ b)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ b = (a ⊔ b) \\ (a ⊓ b) := by simp [sup_sdiff]; sorry",
  "name": "symmDiff_eq_sup_sdiff_inf",
  "kind": "theorem",
  "first-tactic": "simp [sup_sdiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ b = (a ⊔ b) \\ (a ⊓ b)",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ b = a ⊔ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) {a b : α}  (h : Disjoint a b) : a ∆ b = a ⊔ b := by rw [symmDiff]; sorry",
  "name": "Disjoint.symmDiff_eq_sup",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) {a b : α}  (h : Disjoint a b) : a ∆ b = a ⊔ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) {a b : α}  (h : Disjoint a b)"},
 {"type": "a ∆ b \\ c = a \\ (b ⊔ c) ⊔ b \\ (a ⊔ c)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ b \\ c = a \\ (b ⊔ c) ⊔ b \\ (a ⊔ c) := by rw [symmDiff]; sorry",
  "name": "symmDiff_sdiff",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ b \\ c = a \\ (b ⊔ c) ⊔ b \\ (a ⊔ c)",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ b \\ (a ⊓ b) = a ∆ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ b \\ (a ⊓ b) = a ∆ b := by rw [symmDiff_sdiff]; sorry",
  "name": "symmDiff_sdiff_inf",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_sdiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ b \\ (a ⊓ b) = a ∆ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ (b \\ a) = a ⊔ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ (b \\ a) = a ⊔ b := by rw [symmDiff]; sorry",
  "name": "symmDiff_sdiff_eq_sup",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ (b \\ a) = a ⊔ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α)"},
 {"type": "(a \\ b) ∆ b = a ⊔ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : (a \\ b) ∆ b = a ⊔ b := by rw [symmDiff_comm]; sorry",
  "name": "sdiff_symmDiff_eq_sup",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : (a \\ b) ∆ b = a ⊔ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ b ⊔ a ⊓ b = a ⊔ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ b ⊔ a ⊓ b = a ⊔ b := by refine' le_antisymm (sup_le symmDiff_le_sup inf_le_sup) _; sorry",
  "name": "symmDiff_sup_inf",
  "kind": "theorem",
  "first-tactic": "refine' le_antisymm (sup_le symmDiff_le_sup inf_le_sup) _",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ b ⊔ a ⊓ b = a ⊔ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α)"},
 {"type": "a ⊓ b ⊔ a ∆ b = a ⊔ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ⊓ b ⊔ a ∆ b = a ⊔ b := by rw [sup_comm]; sorry",
  "name": "inf_sup_symmDiff",
  "kind": "theorem",
  "first-tactic": "rw [sup_comm]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ⊓ b ⊔ a ∆ b = a ⊔ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ b ∆ (a ⊓ b) = a ⊔ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ b ∆ (a ⊓ b) = a ⊔ b := by rw [← symmDiff_sdiff_inf a]; sorry",
  "name": "symmDiff_symmDiff_inf",
  "kind": "theorem",
  "first-tactic": "rw [← symmDiff_sdiff_inf a]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ b ∆ (a ⊓ b) = a ⊔ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α)"},
 {"type": "(a ⊓ b) ∆ (a ∆ b) = a ⊔ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : (a ⊓ b) ∆ (a ∆ b) = a ⊔ b := by rw [symmDiff_comm]; sorry",
  "name": "inf_symmDiff_symmDiff",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : (a ⊓ b) ∆ (a ∆ b) = a ⊔ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ c ≤ a ∆ b ⊔ b ∆ c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ c ≤ a ∆ b ⊔ b ∆ c := by refine' (sup_le_sup (sdiff_triangle a b c) <| sdiff_triangle _ b _).trans_eq _; sorry",
  "name": "symmDiff_triangle",
  "kind": "theorem",
  "first-tactic":
  "refine' (sup_le_sup (sdiff_triangle a b c) <| sdiff_triangle _ b _).trans_eq _",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α) : a ∆ c ≤ a ∆ b ⊔ b ∆ c",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  (a b c d : α)"},
 {"type": "a ⇔ b = b ⇔ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) : a ⇔ b = b ⇔ a := by simp only [(· ⇔ ·)]; sorry",
  "name": "bihimp_comm",
  "kind": "theorem",
  "first-tactic": "simp only [(· ⇔ ·)]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) : a ⇔ b = b ⇔ a",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α)"},
 {"type": "a ⇔ a = ⊤",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) : a ⇔ a = ⊤ := by rw [bihimp]; sorry",
  "name": "bihimp_self",
  "kind": "theorem",
  "first-tactic": "rw [bihimp]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) : a ⇔ a = ⊤",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α)"},
 {"type": "a ⇔ ⊤ = a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) : a ⇔ ⊤ = a := by rw [bihimp]; sorry",
  "name": "bihimp_top",
  "kind": "theorem",
  "first-tactic": "rw [bihimp]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) : a ⇔ ⊤ = a",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α)"},
 {"type": "⊤ ⇔ a = a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) : ⊤ ⇔ a = a := by rw [bihimp_comm]; sorry",
  "name": "top_bihimp",
  "kind": "theorem",
  "first-tactic": "rw [bihimp_comm]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) : ⊤ ⇔ a = a",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α)"},
 {"type": "a ⇔ b = b ⇨ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) {a b : α}  (h : a ≤ b) : a ⇔ b = b ⇨ a := by rw [bihimp]; sorry",
  "name": "bihimp_of_le",
  "kind": "theorem",
  "first-tactic": "rw [bihimp]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) {a b : α}  (h : a ≤ b) : a ⇔ b = b ⇨ a",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) {a b : α}  (h : a ≤ b)"},
 {"type": "a ⇔ b = a ⇨ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) {a b : α}  (h : b ≤ a) : a ⇔ b = a ⇨ b := by rw [bihimp]; sorry",
  "name": "bihimp_of_ge",
  "kind": "theorem",
  "first-tactic": "rw [bihimp]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) {a b : α}  (h : b ≤ a) : a ⇔ b = a ⇨ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) {a b : α}  (h : b ≤ a)"},
 {"type": "a ≤ b ⇔ c ↔ a ⊓ b ≤ c ∧ a ⊓ c ≤ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) {a b c : α} : a ≤ b ⇔ c ↔ a ⊓ b ≤ c ∧ a ⊓ c ≤ b := by simp_rw [bihimp]; sorry",
  "name": "le_bihimp_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [bihimp]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) {a b c : α} : a ≤ b ⇔ c ↔ a ⊓ b ≤ c ∧ a ⊓ c ≤ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) {a b c : α}"},
 {"type": "a ⇔ b = a ⊔ b ⇨ a ⊓ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) : a ⇔ b = a ⊔ b ⇨ a ⊓ b := by simp [himp_inf_distrib]; sorry",
  "name": "bihimp_eq_inf_himp_inf",
  "kind": "theorem",
  "first-tactic": "simp [himp_inf_distrib]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) : a ⇔ b = a ⊔ b ⇨ a ⊓ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α)"},
 {"type": "a ⇔ b = a ⊓ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) {a b : α}  (h : Codisjoint a b) : a ⇔ b = a ⊓ b := by rw [bihimp]; sorry",
  "name": "Codisjoint.bihimp_eq_inf",
  "kind": "theorem",
  "first-tactic": "rw [bihimp]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) {a b : α}  (h : Codisjoint a b) : a ⇔ b = a ⊓ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) {a b : α}  (h : Codisjoint a b)"},
 {"type": "a ⇨ b ⇔ c = (a ⊓ c ⇨ b) ⊓ (a ⊓ b ⇨ c)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) : a ⇨ b ⇔ c = (a ⊓ c ⇨ b) ⊓ (a ⊓ b ⇨ c) := by rw [bihimp]; sorry",
  "name": "himp_bihimp",
  "kind": "theorem",
  "first-tactic": "rw [bihimp]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) : a ⇨ b ⇔ c = (a ⊓ c ⇨ b) ⊓ (a ⊓ b ⇨ c)",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α)"},
 {"type": "a ⊔ b ⇨ a ⇔ b = a ⇔ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) : a ⊔ b ⇨ a ⇔ b = a ⇔ b := by rw [himp_bihimp]; sorry",
  "name": "sup_himp_bihimp",
  "kind": "theorem",
  "first-tactic": "rw [himp_bihimp]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α) : a ⊔ b ⇨ a ⇔ b = a ⇔ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ ⊤ = ￢a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [CoheytingAlgebra α]  (a : α) : a ∆ ⊤ = ￢a := by simp [symmDiff]; sorry",
  "name": "symmDiff_top'",
  "kind": "theorem",
  "first-tactic": "simp [symmDiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [CoheytingAlgebra α]  (a : α) : a ∆ ⊤ = ￢a",
  "args": "{ι α β : Type _}  {π : ι → Type _}  [CoheytingAlgebra α]  (a : α)"},
 {"type": "⊤ ∆ a = ￢a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [CoheytingAlgebra α]  (a : α) : ⊤ ∆ a = ￢a := by simp [symmDiff]; sorry",
  "name": "top_symmDiff'",
  "kind": "theorem",
  "first-tactic": "simp [symmDiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [CoheytingAlgebra α]  (a : α) : ⊤ ∆ a = ￢a",
  "args": "{ι α β : Type _}  {π : ι → Type _}  [CoheytingAlgebra α]  (a : α)"},
 {"type": "(￢a) ∆ a = ⊤",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [CoheytingAlgebra α]  (a : α) : (￢a) ∆ a = ⊤ := by rw [eq_top_iff]; sorry",
  "name": "hnot_symmDiff_self",
  "kind": "theorem",
  "first-tactic": "rw [eq_top_iff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [CoheytingAlgebra α]  (a : α) : (￢a) ∆ a = ⊤",
  "args": "{ι α β : Type _}  {π : ι → Type _}  [CoheytingAlgebra α]  (a : α)"},
 {"type": "a ∆ (￢a) = ⊤",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [CoheytingAlgebra α]  (a : α) : a ∆ (￢a) = ⊤ := by rw [symmDiff_comm]; sorry",
  "name": "symmDiff_hnot_self",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [CoheytingAlgebra α]  (a : α) : a ∆ (￢a) = ⊤",
  "args": "{ι α β : Type _}  {π : ι → Type _}  [CoheytingAlgebra α]  (a : α)"},
 {"type": "a ∆ b = ⊤",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [CoheytingAlgebra α]  (a : α) {a b : α}  (h : IsCompl a b) : a ∆ b = ⊤ := by rw [h.eq_hnot]; sorry",
  "name": "IsCompl.symmDiff_eq_top",
  "kind": "theorem",
  "first-tactic": "rw [h.eq_hnot]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [CoheytingAlgebra α]  (a : α) {a b : α}  (h : IsCompl a b) : a ∆ b = ⊤",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [CoheytingAlgebra α]  (a : α) {a b : α}  (h : IsCompl a b)"},
 {"type": "a ⇔ ⊥ = aᶜ",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [HeytingAlgebra α]  (a : α) : a ⇔ ⊥ = aᶜ := by simp [bihimp]; sorry",
  "name": "bihimp_bot",
  "kind": "theorem",
  "first-tactic": "simp [bihimp]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [HeytingAlgebra α]  (a : α) : a ⇔ ⊥ = aᶜ",
  "args": "{ι α β : Type _}  {π : ι → Type _}  [HeytingAlgebra α]  (a : α)"},
 {"type": "⊥ ⇔ a = aᶜ",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [HeytingAlgebra α]  (a : α) : ⊥ ⇔ a = aᶜ := by simp [bihimp]; sorry",
  "name": "bot_bihimp",
  "kind": "theorem",
  "first-tactic": "simp [bihimp]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [HeytingAlgebra α]  (a : α) : ⊥ ⇔ a = aᶜ",
  "args": "{ι α β : Type _}  {π : ι → Type _}  [HeytingAlgebra α]  (a : α)"},
 {"type": "a ⇔ b = ⊥",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [HeytingAlgebra α]  (a : α) {a b : α}  (h : IsCompl a b) : a ⇔ b = ⊥ := by rw [h.eq_compl]; sorry",
  "name": "IsCompl.bihimp_eq_bot",
  "kind": "theorem",
  "first-tactic": "rw [h.eq_compl]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [HeytingAlgebra α]  (a : α) {a b : α}  (h : IsCompl a b) : a ⇔ b = ⊥",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [HeytingAlgebra α]  (a : α) {a b : α}  (h : IsCompl a b)"},
 {"type": "Disjoint (a ∆ b) (a ⊓ b)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : Disjoint (a ∆ b) (a ⊓ b) := by rw [symmDiff_eq_sup_sdiff_inf]; sorry",
  "name": "disjoint_symmDiff_inf",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_eq_sup_sdiff_inf]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : Disjoint (a ∆ b) (a ⊓ b)",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "a ⊓ b ∆ c = (a ⊓ b) ∆ (a ⊓ c)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ⊓ b ∆ c = (a ⊓ b) ∆ (a ⊓ c) := by rw [symmDiff_eq_sup_sdiff_inf]; sorry",
  "name": "inf_symmDiff_distrib_left",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_eq_sup_sdiff_inf]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ⊓ b ∆ c = (a ⊓ b) ∆ (a ⊓ c)",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ b ⊓ c = (a ⊓ c) ∆ (b ⊓ c)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b ⊓ c = (a ⊓ c) ∆ (b ⊓ c) := by simp_rw [@inf_comm _ _ _ c]; sorry",
  "name": "inf_symmDiff_distrib_right",
  "kind": "theorem",
  "first-tactic": "simp_rw [@inf_comm _ _ _ c]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b ⊓ c = (a ⊓ c) ∆ (b ⊓ c)",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "c \\ a ∆ b = c ⊓ a ⊓ b ⊔ c \\ a ⊓ c \\ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : c \\ a ∆ b = c ⊓ a ⊓ b ⊔ c \\ a ⊓ c \\ b := by simp only [(· ∆ ·)]; sorry",
  "name": "sdiff_symmDiff",
  "kind": "theorem",
  "first-tactic": "simp only [(· ∆ ·)]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : c \\ a ∆ b = c ⊓ a ⊓ b ⊔ c \\ a ⊓ c \\ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "c \\ a ∆ b = c ⊓ a ⊓ b ⊔ c \\ (a ⊔ b)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : c \\ a ∆ b = c ⊓ a ⊓ b ⊔ c \\ (a ⊔ b) := by rw [sdiff_symmDiff]; sorry",
  "name": "sdiff_symmDiff'",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_symmDiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : c \\ a ∆ b = c ⊓ a ⊓ b ⊔ c \\ (a ⊔ b)",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ b \\ a = b \\ a",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b \\ a = b \\ a := by rw [symmDiff_def]; sorry",
  "name": "symmDiff_sdiff_left",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_def]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b \\ a = b \\ a",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ b \\ b = a \\ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b \\ b = a \\ b := by rw [symmDiff_comm]; sorry",
  "name": "symmDiff_sdiff_right",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b \\ b = a \\ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "a \\ a ∆ b = a ⊓ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a \\ a ∆ b = a ⊓ b := by simp [sdiff_symmDiff]; sorry",
  "name": "sdiff_symmDiff_left",
  "kind": "theorem",
  "first-tactic": "simp [sdiff_symmDiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a \\ a ∆ b = a ⊓ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "b \\ a ∆ b = a ⊓ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : b \\ a ∆ b = a ⊓ b := by rw [symmDiff_comm]; sorry",
  "name": "sdiff_symmDiff_right",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : b \\ a ∆ b = a ⊓ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ b = a ⊔ b ↔ Disjoint a b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b = a ⊔ b ↔ Disjoint a b := by refine' ⟨fun h => _, Disjoint.symmDiff_eq_sup⟩; sorry",
  "name": "symmDiff_eq_sup",
  "kind": "theorem",
  "first-tactic": "refine' ⟨fun h => _, Disjoint.symmDiff_eq_sup⟩",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b = a ⊔ b ↔ Disjoint a b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "a ≤ a ∆ b ↔ Disjoint a b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ≤ a ∆ b ↔ Disjoint a b := by refine' ⟨fun h => _, fun h => h.symmDiff_eq_sup.symm ▸ le_sup_left⟩; sorry",
  "name": "le_symmDiff_iff_left",
  "kind": "theorem",
  "first-tactic":
  "refine' ⟨fun h => _, fun h => h.symmDiff_eq_sup.symm ▸ le_sup_left⟩",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ≤ a ∆ b ↔ Disjoint a b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "b ≤ a ∆ b ↔ Disjoint a b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : b ≤ a ∆ b ↔ Disjoint a b := by rw [symmDiff_comm]; sorry",
  "name": "le_symmDiff_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : b ≤ a ∆ b ↔ Disjoint a b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ b ∆ c = a ∆ (b ∆ c)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b ∆ c = a ∆ (b ∆ c) := by rw [symmDiff_symmDiff_left]; sorry",
  "name": "symmDiff_assoc",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_symmDiff_left]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b ∆ c = a ∆ (b ∆ c)",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ (b ∆ c) = b ∆ (a ∆ c)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ (b ∆ c) = b ∆ (a ∆ c) := by simp_rw [← symmDiff_assoc]; sorry",
  "name": "symmDiff_left_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [← symmDiff_assoc]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ (b ∆ c) = b ∆ (a ∆ c)",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ b ∆ c = a ∆ c ∆ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b ∆ c = a ∆ c ∆ b := by simp_rw [symmDiff_assoc]; sorry",
  "name": "symmDiff_right_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [symmDiff_assoc]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b ∆ c = a ∆ c ∆ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ b ∆ (c ∆ d) = a ∆ c ∆ (b ∆ d)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b ∆ (c ∆ d) = a ∆ c ∆ (b ∆ d) := by simp_rw [symmDiff_assoc]; sorry",
  "name": "symmDiff_symmDiff_symmDiff_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [symmDiff_assoc]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b ∆ (c ∆ d) = a ∆ c ∆ (b ∆ d)",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ (a ∆ b) = b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ (a ∆ b) = b := by simp [← symmDiff_assoc]; sorry",
  "name": "symmDiff_symmDiff_cancel_left",
  "kind": "theorem",
  "first-tactic": "simp [← symmDiff_assoc]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ (a ∆ b) = b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "b ∆ a ∆ a = b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : b ∆ a ∆ a = b := by simp [symmDiff_assoc]; sorry",
  "name": "symmDiff_symmDiff_cancel_right",
  "kind": "theorem",
  "first-tactic": "simp [symmDiff_assoc]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : b ∆ a ∆ a = b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ b ∆ a = b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b ∆ a = b := by rw [symmDiff_comm]; sorry",
  "name": "symmDiff_symmDiff_self'",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b ∆ a = b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "a ∆ b = b ↔ a = ⊥",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b = b ↔ a = ⊥ := by rw [symmDiff_comm]; sorry",
  "name": "symmDiff_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) : a ∆ b = b ↔ a = ⊥",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α)"},
 {"type": "Disjoint (a ∆ b) c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) (ha : Disjoint a c)  (hb : Disjoint b c) : Disjoint (a ∆ b) c := by rw [symmDiff_eq_sup_sdiff_inf]; sorry",
  "name": "Disjoint.symmDiff_left",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_eq_sup_sdiff_inf]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) (ha : Disjoint a c)  (hb : Disjoint b c) : Disjoint (a ∆ b) c",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) (ha : Disjoint a c)  (hb : Disjoint b c)"},
 {"type": "a ∆ b = c ↔ c \\ a = b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) (ha : a ≤ c) : a ∆ b = c ↔ c \\ a = b := by rw [← symmDiff_of_le ha]; sorry",
  "name": "symmDiff_eq_iff_sdiff_eq",
  "kind": "theorem",
  "first-tactic": "rw [← symmDiff_of_le ha]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) (ha : a ≤ c) : a ∆ b = c ↔ c \\ a = b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [GeneralizedBooleanAlgebra α]  (a b c d : α) (ha : a ≤ c)"},
 {"type": "a ⇔ (b ⇔ c) = b ⇔ (a ⇔ c)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ⇔ (b ⇔ c) = b ⇔ (a ⇔ c) := by simp_rw [← bihimp_assoc]; sorry",
  "name": "bihimp_left_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [← bihimp_assoc]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ⇔ (b ⇔ c) = b ⇔ (a ⇔ c)",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a ⇔ b ⇔ c = a ⇔ c ⇔ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ⇔ b ⇔ c = a ⇔ c ⇔ b := by simp_rw [bihimp_assoc]; sorry",
  "name": "bihimp_right_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [bihimp_assoc]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ⇔ b ⇔ c = a ⇔ c ⇔ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a ⇔ b ⇔ (c ⇔ d) = a ⇔ c ⇔ (b ⇔ d)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ⇔ b ⇔ (c ⇔ d) = a ⇔ c ⇔ (b ⇔ d) := by simp_rw [bihimp_assoc]; sorry",
  "name": "bihimp_bihimp_bihimp_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [bihimp_assoc]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ⇔ b ⇔ (c ⇔ d) = a ⇔ c ⇔ (b ⇔ d)",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a ⇔ (a ⇔ b) = b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ⇔ (a ⇔ b) = b := by simp [← bihimp_assoc]; sorry",
  "name": "bihimp_bihimp_cancel_left",
  "kind": "theorem",
  "first-tactic": "simp [← bihimp_assoc]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ⇔ (a ⇔ b) = b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "b ⇔ a ⇔ a = b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : b ⇔ a ⇔ a = b := by simp [bihimp_assoc]; sorry",
  "name": "bihimp_bihimp_cancel_right",
  "kind": "theorem",
  "first-tactic": "simp [bihimp_assoc]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : b ⇔ a ⇔ a = b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a ⇔ b ⇔ a = b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ⇔ b ⇔ a = b := by rw [bihimp_comm]; sorry",
  "name": "bihimp_bihimp_self",
  "kind": "theorem",
  "first-tactic": "rw [bihimp_comm]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ⇔ b ⇔ a = b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a ∆ b = a ⊓ bᶜ ⊔ b ⊓ aᶜ",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ∆ b = a ⊓ bᶜ ⊔ b ⊓ aᶜ := by simp only [(· ∆ ·)]; sorry",
  "name": "symmDiff_eq",
  "kind": "theorem",
  "first-tactic": "simp only [(· ∆ ·)]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ∆ b = a ⊓ bᶜ ⊔ b ⊓ aᶜ",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a ⇔ b = (a ⊔ bᶜ) ⊓ (b ⊔ aᶜ)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ⇔ b = (a ⊔ bᶜ) ⊓ (b ⊔ aᶜ) := by simp only [(· ⇔ ·)]; sorry",
  "name": "bihimp_eq",
  "kind": "theorem",
  "first-tactic": "simp only [(· ⇔ ·)]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ⇔ b = (a ⊔ bᶜ) ⊓ (b ⊔ aᶜ)",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a ∆ b = (a ⊔ b) ⊓ (aᶜ ⊔ bᶜ)",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ∆ b = (a ⊔ b) ⊓ (aᶜ ⊔ bᶜ) := by rw [symmDiff_eq_sup_sdiff_inf]; sorry",
  "name": "symmDiff_eq'",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_eq_sup_sdiff_inf]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ∆ b = (a ⊔ b) ⊓ (aᶜ ⊔ bᶜ)",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "(a ∆ b)ᶜ = a ⇔ b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : (a ∆ b)ᶜ = a ⇔ b := by simp_rw [symmDiff]; sorry",
  "name": "compl_symmDiff",
  "kind": "theorem",
  "first-tactic": "simp_rw [symmDiff]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : (a ∆ b)ᶜ = a ⇔ b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a ∆ b = ⊤ ↔ IsCompl a b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ∆ b = ⊤ ↔ IsCompl a b := by rw [symmDiff_eq']; sorry",
  "name": "symmDiff_eq_top",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_eq']",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ∆ b = ⊤ ↔ IsCompl a b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a ⇔ b = ⊥ ↔ IsCompl a b",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ⇔ b = ⊥ ↔ IsCompl a b := by rw [bihimp_eq']; sorry",
  "name": "bihimp_eq_bot",
  "kind": "theorem",
  "first-tactic": "rw [bihimp_eq']",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a ⇔ b = ⊥ ↔ IsCompl a b",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "c ≤ a ∆ c ⊔ b ∆ c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ (h : Disjoint a b) : c ≤ a ∆ c ⊔ b ∆ c := by trans c \\ (a ⊓ b); sorry",
  "name": "Disjoint.le_symmDiff_sup_symmDiff_left",
  "kind": "theorem",
  "first-tactic": "trans c \\ (a ⊓ b)",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ (h : Disjoint a b) : c ≤ a ∆ c ⊔ b ∆ c",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ (h : Disjoint a b)"},
 {"type": "a ≤ a ∆ b ⊔ a ∆ c",
  "tactic-prompt":
  "theorem {ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ (h : Disjoint b c) : a ≤ a ∆ b ⊔ a ∆ c := by simp_rw [symmDiff_comm a]; sorry",
  "name": "Disjoint.le_symmDiff_sup_symmDiff_right",
  "kind": "theorem",
  "first-tactic": "simp_rw [symmDiff_comm a]",
  "core-prompt":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ (h : Disjoint b c) : a ≤ a ∆ b ⊔ a ∆ c",
  "args":
  "{ι α β : Type _}  {π : ι → Type _}  [BooleanAlgebra α]  (a b c d : α)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ (h : Disjoint b c)"},
 {"type": "a ≤ b ⇨ c ↔ b ⊓ a ≤ c",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` : a ≤ b ⇨ c ↔ b ⊓ a ≤ c := by rw [le_himp_iff]; sorry",
  "name": "le_himp_iff'",
  "kind": "theorem",
  "first-tactic": "rw [le_himp_iff]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` : a ≤ b ⇨ c ↔ b ⊓ a ≤ c",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r`"},
 {"type": "a ≤ b ⇨ c ↔ b ≤ a ⇨ c",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` : a ≤ b ⇨ c ↔ b ≤ a ⇨ c := by rw [le_himp_iff]; sorry",
  "name": "le_himp_comm",
  "kind": "theorem",
  "first-tactic": "rw [le_himp_iff]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` : a ≤ b ⇨ c ↔ b ≤ a ⇨ c",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r`"},
 {"type": "a ≤ a ⇨ b ↔ a ≤ b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` : a ≤ a ⇨ b ↔ a ≤ b := by rw [le_himp_iff]; sorry",
  "name": "le_himp_iff_left",
  "kind": "theorem",
  "first-tactic": "rw [le_himp_iff]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` : a ≤ a ⇨ b ↔ a ≤ b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r`"},
 {"type": "a ⊓ (a ⇨ b) ≤ b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` : a ⊓ (a ⇨ b) ≤ b := by rw [inf_comm]; sorry",
  "name": "inf_himp_le",
  "kind": "theorem",
  "first-tactic": "rw [inf_comm]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` : a ⊓ (a ⇨ b) ≤ b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r`"},
 {"type": "(a ⇨ b) ⊓ a = b ⊓ a",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (a b : α) : (a ⇨ b) ⊓ a = b ⊓ a := by rw [inf_comm]; sorry",
  "name": "himp_inf_self",
  "kind": "theorem",
  "first-tactic": "rw [inf_comm]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (a b : α) : (a ⇨ b) ⊓ a = b ⊓ a",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (a b : α)"},
 {"type": "a ⇨ b = ⊤ ↔ a ≤ b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` : a ⇨ b = ⊤ ↔ a ≤ b := by rw [← top_le_iff]; sorry",
  "name": "himp_eq_top_iff",
  "kind": "theorem",
  "first-tactic": "rw [← top_le_iff]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` : a ⇨ b = ⊤ ↔ a ≤ b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r`"},
 {"type": "b ⇨ c ≤ (a ⇨ b) ⇨ a ⇨ c",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` : b ⇨ c ≤ (a ⇨ b) ⇨ a ⇨ c := by rw [le_himp_iff]; sorry",
  "name": "himp_le_himp_himp_himp",
  "kind": "theorem",
  "first-tactic": "rw [le_himp_iff]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` : b ⇨ c ≤ (a ⇨ b) ⇨ a ⇨ c",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r`"},
 {"type": "(b ⇨ c) ⊓ (a ⇨ b) ⊓ a ≤ c",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` : (b ⇨ c) ⊓ (a ⇨ b) ⊓ a ≤ c := by simpa using @himp_le_himp_himp_himp; sorry",
  "name": "himp_inf_himp_inf_le",
  "kind": "theorem",
  "first-tactic": "simpa using @himp_le_himp_himp_himp",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` : (b ⇨ c) ⊓ (a ⇨ b) ⊓ a ≤ c",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r`"},
 {"type": "a ⇨ b ⇨ c = b ⇨ a ⇨ c",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (a b c : α) : a ⇨ b ⇨ c = b ⇨ a ⇨ c := by simp_rw [himp_himp]; sorry",
  "name": "himp_left_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [himp_himp]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (a b c : α) : a ⇨ b ⇨ c = b ⇨ a ⇨ c",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (a b c : α)"},
 {"type": "b ⇨ b ⇨ a = b ⇨ a",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` : b ⇨ b ⇨ a = b ⇨ a := by rw [himp_himp]; sorry",
  "name": "himp_idem",
  "kind": "theorem",
  "first-tactic": "rw [himp_himp]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` : b ⇨ b ⇨ a = b ⇨ a",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r`"},
 {"type": "a ⊔ b ⇨ a = b ⇨ a",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (a b : α) : a ⊔ b ⇨ a = b ⇨ a := by rw [sup_himp_distrib]; sorry",
  "name": "sup_himp_self_left",
  "kind": "theorem",
  "first-tactic": "rw [sup_himp_distrib]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (a b : α) : a ⊔ b ⇨ a = b ⇨ a",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (a b : α)"},
 {"type": "a ⊔ b ⇨ b = a ⇨ b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (a b : α) : a ⊔ b ⇨ b = a ⇨ b := by rw [sup_himp_distrib]; sorry",
  "name": "sup_himp_self_right",
  "kind": "theorem",
  "first-tactic": "rw [sup_himp_distrib]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (a b : α) : a ⊔ b ⇨ b = a ⇨ b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (a b : α)"},
 {"type": "b ⇨ a = a",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (h : Codisjoint a b) : b ⇨ a = a := by conv_rhs => rw [← @top_himp _ _ a]; sorry",
  "name": "Codisjoint.himp_eq_right",
  "kind": "theorem",
  "first-tactic": "conv_rhs => rw [← @top_himp _ _ a]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (h : Codisjoint a b) : b ⇨ a = a",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (h : Codisjoint a b)"},
 {"type": "a ⇨ a ⊓ b = b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (h : Codisjoint a b) : a ⇨ a ⊓ b = b := by rw [himp_inf_distrib]; sorry",
  "name": "Codisjoint.himp_inf_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [himp_inf_distrib]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (h : Codisjoint a b) : a ⇨ a ⊓ b = b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (h : Codisjoint a b)"},
 {"type": "b ⇨ a ⊓ b = a",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (h : Codisjoint a b) : b ⇨ a ⊓ b = a := by rw [himp_inf_distrib]; sorry",
  "name": "Codisjoint.himp_inf_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [himp_inf_distrib]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (h : Codisjoint a b) : b ⇨ a ⊓ b = a",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (h : Codisjoint a b)"},
 {"type": "(a ⇨ b) ⊓ (b ⇨ c) ≤ a ⇨ c",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (a b c : α) : (a ⇨ b) ⊓ (b ⇨ c) ≤ a ⇨ c := by rw [le_himp_iff]; sorry",
  "name": "himp_triangle",
  "kind": "theorem",
  "first-tactic": "rw [le_himp_iff]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (a b c : α) : (a ⇨ b) ⊓ (b ⇨ c) ≤ a ⇨ c",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedHeytingAlgebra α]  {a b c d : α}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `≤` can be interpreted as \"validates\", `⇨` as \"implies\", `⊓` as \"and\", `⊔` as \"or\", `⊥` as \"false\" and `⊤` as \"true\". Note that we confuse `→` and `⊢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p → q → r ↔ p ∧ q → r` (a b c : α)"},
 {"type": "a \\ b ≤ c ↔ a ≤ c ⊔ b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : a \\ b ≤ c ↔ a ≤ c ⊔ b := by rw [sdiff_le_iff]; sorry",
  "name": "sdiff_le_iff'",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_le_iff]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : a \\ b ≤ c ↔ a ≤ c ⊔ b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α}"},
 {"type": "a \\ b ≤ c ↔ a \\ c ≤ b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : a \\ b ≤ c ↔ a \\ c ≤ b := by rw [sdiff_le_iff]; sorry",
  "name": "sdiff_le_comm",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_le_iff]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : a \\ b ≤ c ↔ a \\ c ≤ b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α}"},
 {"type": "a \\ b ≤ b ↔ a ≤ b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : a \\ b ≤ b ↔ a ≤ b := by rw [sdiff_le_iff]; sorry",
  "name": "sdiff_le_iff_left",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_le_iff]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : a \\ b ≤ b ↔ a ≤ b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α}"},
 {"type": "a ≤ a \\ b ⊔ b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : a ≤ a \\ b ⊔ b := by rw [sup_comm]; sorry",
  "name": "le_sdiff_sup",
  "kind": "theorem",
  "first-tactic": "rw [sup_comm]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : a ≤ a \\ b ⊔ b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α}"},
 {"type": "b \\ a ⊔ a = b ⊔ a",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (a b : α) : b \\ a ⊔ a = b ⊔ a := by rw [sup_comm]; sorry",
  "name": "sdiff_sup_self",
  "kind": "theorem",
  "first-tactic": "rw [sup_comm]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (a b : α) : b \\ a ⊔ a = b ⊔ a",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (a b : α)"},
 {"type": "b ⊔ c \\ a = c",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (hab : a ≤ b)  (hbc : b ≤ c) : b ⊔ c \\ a = c := by rw [sup_sdiff_eq_sup hab]; sorry",
  "name": "sup_sdiff_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [sup_sdiff_eq_sup hab]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (hab : a ≤ b)  (hbc : b ≤ c) : b ⊔ c \\ a = c",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (hab : a ≤ b)  (hbc : b ≤ c)"},
 {"type": "a \\ b ⊔ b = a",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : b ≤ a) : a \\ b ⊔ b = a := by rw [sup_comm]; sorry",
  "name": "sdiff_sup_cancel",
  "kind": "theorem",
  "first-tactic": "rw [sup_comm]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : b ≤ a) : a \\ b ⊔ b = a",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : b ≤ a)"},
 {"type": "a \\ b = ⊥ ↔ a ≤ b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : a \\ b = ⊥ ↔ a ≤ b := by rw [← le_bot_iff]; sorry",
  "name": "sdiff_eq_bot_iff",
  "kind": "theorem",
  "first-tactic": "rw [← le_bot_iff]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : a \\ b = ⊥ ↔ a ≤ b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α}"},
 {"type": "(a \\ b) \\ (a \\ c) ≤ c \\ b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : (a \\ b) \\ (a \\ c) ≤ c \\ b := by rw [sdiff_le_iff]; sorry",
  "name": "sdiff_sdiff_sdiff_le_sdiff",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_le_iff]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : (a \\ b) \\ (a \\ c) ≤ c \\ b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α}"},
 {"type": "a ≤ b ⊔ (a \\ c ⊔ c \\ b)",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : a ≤ b ⊔ (a \\ c ⊔ c \\ b) := by simpa using @sdiff_sdiff_sdiff_le_sdiff; sorry",
  "name": "le_sup_sdiff_sup_sdiff",
  "kind": "theorem",
  "first-tactic": "simpa using @sdiff_sdiff_sdiff_le_sdiff",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : a ≤ b ⊔ (a \\ c ⊔ c \\ b)",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α}"},
 {"type": "(a \\ b) \\ c = (a \\ c) \\ b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (a b c : α) : (a \\ b) \\ c = (a \\ c) \\ b := by simp_rw [sdiff_sdiff]; sorry",
  "name": "sdiff_right_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [sdiff_sdiff]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (a b c : α) : (a \\ b) \\ c = (a \\ c) \\ b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (a b c : α)"},
 {"type": "(a \\ b) \\ b = a \\ b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : (a \\ b) \\ b = a \\ b := by rw [sdiff_sdiff_left]; sorry",
  "name": "sdiff_idem",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_sdiff_left]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : (a \\ b) \\ b = a \\ b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α}"},
 {"type": "(a \\ b) \\ a = ⊥",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : (a \\ b) \\ a = ⊥ := by rw [sdiff_sdiff_comm]; sorry",
  "name": "sdiff_sdiff_self",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_sdiff_comm]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : (a \\ b) \\ a = ⊥",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α}"},
 {"type": "(a ⊔ b) \\ b = a \\ b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : (a ⊔ b) \\ b = a \\ b := by rw [sup_sdiff]; sorry",
  "name": "sup_sdiff_right_self",
  "kind": "theorem",
  "first-tactic": "rw [sup_sdiff]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : (a ⊔ b) \\ b = a \\ b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α}"},
 {"type": "(a ⊔ b) \\ a = b \\ a",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : (a ⊔ b) \\ a = b \\ a := by rw [sup_comm]; sorry",
  "name": "sup_sdiff_left_self",
  "kind": "theorem",
  "first-tactic": "rw [sup_comm]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} : (a ⊔ b) \\ a = b \\ a",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α}"},
 {"type": "a \\ (a ⊓ b) = a \\ b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (a b : α) : a \\ (a ⊓ b) = a \\ b := by rw [sdiff_inf]; sorry",
  "name": "sdiff_inf_self_left",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_inf]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (a b : α) : a \\ (a ⊓ b) = a \\ b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (a b : α)"},
 {"type": "b \\ (a ⊓ b) = b \\ a",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (a b : α) : b \\ (a ⊓ b) = b \\ a := by rw [sdiff_inf]; sorry",
  "name": "sdiff_inf_self_right",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_inf]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (a b : α) : b \\ (a ⊓ b) = b \\ a",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (a b : α)"},
 {"type": "a \\ b = a",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : Disjoint a b) : a \\ b = a := by conv_rhs => rw [← @sdiff_bot _ _ a]; sorry",
  "name": "Disjoint.sdiff_eq_left",
  "kind": "theorem",
  "first-tactic": "conv_rhs => rw [← @sdiff_bot _ _ a]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : Disjoint a b) : a \\ b = a",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : Disjoint a b)"},
 {"type": "(a ⊔ b) \\ a = b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : Disjoint a b) : (a ⊔ b) \\ a = b := by rw [sup_sdiff]; sorry",
  "name": "Disjoint.sup_sdiff_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [sup_sdiff]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : Disjoint a b) : (a ⊔ b) \\ a = b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : Disjoint a b)"},
 {"type": "(a ⊔ b) \\ b = a",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : Disjoint a b) : (a ⊔ b) \\ b = a := by rw [sup_sdiff]; sorry",
  "name": "Disjoint.sup_sdiff_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [sup_sdiff]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : Disjoint a b) : (a ⊔ b) \\ b = a",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : Disjoint a b)"},
 {"type": "a \\ c ≤ a \\ b ⊔ b \\ c",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (a b c : α) : a \\ c ≤ a \\ b ⊔ b \\ c := by rw [sdiff_le_iff]; sorry",
  "name": "sdiff_triangle",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_le_iff]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (a b c : α) : a \\ c ≤ a \\ b ⊔ b \\ c",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (a b c : α)"},
 {"type": "a \\ c ≤ b \\ c",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : c ⊔ a ≤ c ⊔ b) : a \\ c ≤ b \\ c := by rw [← sup_sdiff_left_self]; sorry",
  "name": "sdiff_le_sdiff_of_sup_le_sup_left",
  "kind": "theorem",
  "first-tactic": "rw [← sup_sdiff_left_self]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : c ⊔ a ≤ c ⊔ b) : a \\ c ≤ b \\ c",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : c ⊔ a ≤ c ⊔ b)"},
 {"type": "a \\ c ≤ b \\ c",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : a ⊔ c ≤ b ⊔ c) : a \\ c ≤ b \\ c := by rw [← sup_sdiff_right_self]; sorry",
  "name": "sdiff_le_sdiff_of_sup_le_sup_right",
  "kind": "theorem",
  "first-tactic": "rw [← sup_sdiff_right_self]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : a ⊔ c ≤ b ⊔ c) : a \\ c ≤ b \\ c",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [GeneralizedCoheytingAlgebra α]  {a b c d : α} (h : a ⊔ c ≤ b ⊔ c)"},
 {"type": "(a ⊔ b)ᶜ = aᶜ ⊓ bᶜ",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} (a b : α) : (a ⊔ b)ᶜ = aᶜ ⊓ bᶜ := by simp_rw [← himp_bot]; sorry",
  "name": "compl_sup_distrib",
  "kind": "theorem",
  "first-tactic": "simp_rw [← himp_bot]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} (a b : α) : (a ⊔ b)ᶜ = aᶜ ⊓ bᶜ",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} (a b : α)"},
 {"type": "a ⇨ aᶜ = aᶜ",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} (a : α) : a ⇨ aᶜ = aᶜ := by rw [← himp_bot]; sorry",
  "name": "himp_compl",
  "kind": "theorem",
  "first-tactic": "rw [← himp_bot]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} (a : α) : a ⇨ aᶜ = aᶜ",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} (a : α)"},
 {"type": "a ⇨ bᶜ = b ⇨ aᶜ",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} (a b : α) : a ⇨ bᶜ = b ⇨ aᶜ := by simp_rw [← himp_bot]; sorry",
  "name": "himp_compl_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [← himp_bot]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} (a b : α) : a ⇨ bᶜ = b ⇨ aᶜ",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} (a b : α)"},
 {"type": "a ≤ bᶜ ↔ Disjoint a b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} : a ≤ bᶜ ↔ Disjoint a b := by rw [← himp_bot]; sorry",
  "name": "le_compl_iff_disjoint_right",
  "kind": "theorem",
  "first-tactic": "rw [← himp_bot]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} : a ≤ bᶜ ↔ Disjoint a b",
  "args": "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α}"},
 {"type": "a ≤ bᶜ ↔ b ≤ aᶜ",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} : a ≤ bᶜ ↔ b ≤ aᶜ := by rw [le_compl_iff_disjoint_right]; sorry",
  "name": "le_compl_comm",
  "kind": "theorem",
  "first-tactic": "rw [le_compl_iff_disjoint_right]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} : a ≤ bᶜ ↔ b ≤ aᶜ",
  "args": "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α}"},
 {"type": "(⊥ : α)ᶜ = ⊤",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} : (⊥ : α)ᶜ = ⊤ := by rw [← himp_bot]; sorry",
  "name": "compl_bot",
  "kind": "theorem",
  "first-tactic": "rw [← himp_bot]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} : (⊥ : α)ᶜ = ⊤",
  "args": "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α}"},
 {"type": "Disjoint (aᶜᶜ) b ↔ Disjoint a b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} : Disjoint (aᶜᶜ) b ↔ Disjoint a b := by simp_rw [← le_compl_iff_disjoint_left]; sorry",
  "name": "disjoint_compl_compl_left_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [← le_compl_iff_disjoint_left]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} : Disjoint (aᶜᶜ) b ↔ Disjoint a b",
  "args": "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α}"},
 {"type": "Disjoint a (bᶜᶜ) ↔ Disjoint a b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} : Disjoint a (bᶜᶜ) ↔ Disjoint a b := by simp_rw [← le_compl_iff_disjoint_right]; sorry",
  "name": "disjoint_compl_compl_right_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [← le_compl_iff_disjoint_right]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} : Disjoint a (bᶜᶜ) ↔ Disjoint a b",
  "args": "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α}"},
 {"type": "(a ⊓ b)ᶜᶜ = aᶜᶜ ⊓ bᶜᶜ",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} (a b : α) : (a ⊓ b)ᶜᶜ = aᶜᶜ ⊓ bᶜᶜ := by refine' ((compl_anti compl_sup_compl_le).trans (compl_sup_distrib _ _).le).antisymm _; sorry",
  "name": "compl_compl_inf_distrib",
  "kind": "theorem",
  "first-tactic":
  "refine' ((compl_anti compl_sup_compl_le).trans (compl_sup_distrib _ _).le).antisymm _",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} (a b : α) : (a ⊓ b)ᶜᶜ = aᶜᶜ ⊓ bᶜᶜ",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} (a b : α)"},
 {"type": "(a ⇨ b)ᶜᶜ = aᶜᶜ ⇨ bᶜᶜ",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} (a b : α) : (a ⇨ b)ᶜᶜ = aᶜᶜ ⇨ bᶜᶜ := by refine' le_antisymm _ _; sorry",
  "name": "compl_compl_himp_distrib",
  "kind": "theorem",
  "first-tactic": "refine' le_antisymm _ _",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} (a b : α) : (a ⇨ b)ᶜᶜ = aᶜᶜ ⇨ bᶜᶜ",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [HeytingAlgebra α]  {a b c : α} (a b : α)"},
 {"type": "￢(a ⊓ b) = ￢a ⊔ ￢b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} (a b : α) : ￢(a ⊓ b) = ￢a ⊔ ￢b := by simp_rw [← top_sdiff']; sorry",
  "name": "hnot_inf_distrib",
  "kind": "theorem",
  "first-tactic": "simp_rw [← top_sdiff']",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} (a b : α) : ￢(a ⊓ b) = ￢a ⊔ ￢b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} (a b : α)"},
 {"type": "￢a \\ a = ￢a",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} (a : α) : ￢a \\ a = ￢a := by rw [← top_sdiff']; sorry",
  "name": "hnot_sdiff",
  "kind": "theorem",
  "first-tactic": "rw [← top_sdiff']",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} (a : α) : ￢a \\ a = ￢a",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} (a : α)"},
 {"type": "￢a \\ b = ￢b \\ a",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} (a b : α) : ￢a \\ b = ￢b \\ a := by simp_rw [← top_sdiff']; sorry",
  "name": "hnot_sdiff_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [← top_sdiff']",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} (a b : α) : ￢a \\ b = ￢b \\ a",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} (a b : α)"},
 {"type": "￢a ≤ b ↔ Codisjoint a b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} : ￢a ≤ b ↔ Codisjoint a b := by rw [← top_sdiff']; sorry",
  "name": "hnot_le_iff_codisjoint_right",
  "kind": "theorem",
  "first-tactic": "rw [← top_sdiff']",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} : ￢a ≤ b ↔ Codisjoint a b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α}"},
 {"type": "￢a ≤ b ↔ ￢b ≤ a",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} : ￢a ≤ b ↔ ￢b ≤ a := by rw [hnot_le_iff_codisjoint_right]; sorry",
  "name": "hnot_le_comm",
  "kind": "theorem",
  "first-tactic": "rw [hnot_le_iff_codisjoint_right]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} : ￢a ≤ b ↔ ￢b ≤ a",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α}"},
 {"type": "￢(⊤ : α) = ⊥",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} : ￢(⊤ : α) = ⊥ := by rw [← top_sdiff']; sorry",
  "name": "hnot_top",
  "kind": "theorem",
  "first-tactic": "rw [← top_sdiff']",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} : ￢(⊤ : α) = ⊥",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α}"},
 {"type": "Codisjoint (￢￢a) b ↔ Codisjoint a b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} : Codisjoint (￢￢a) b ↔ Codisjoint a b := by simp_rw [← hnot_le_iff_codisjoint_right]; sorry",
  "name": "codisjoint_hnot_hnot_left_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [← hnot_le_iff_codisjoint_right]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} : Codisjoint (￢￢a) b ↔ Codisjoint a b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α}"},
 {"type": "Codisjoint a (￢￢b) ↔ Codisjoint a b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} : Codisjoint a (￢￢b) ↔ Codisjoint a b := by simp_rw [← hnot_le_iff_codisjoint_left]; sorry",
  "name": "codisjoint_hnot_hnot_right_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [← hnot_le_iff_codisjoint_left]",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} : Codisjoint a (￢￢b) ↔ Codisjoint a b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α}"},
 {"type": "￢￢(a ⊔ b) = ￢￢a ⊔ ￢￢b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} (a b : α) : ￢￢(a ⊔ b) = ￢￢a ⊔ ￢￢b := by refine' ((hnot_inf_distrib _ _).ge.trans <| hnot_anti le_hnot_inf_hnot).antisymm' _; sorry",
  "name": "hnot_hnot_sup_distrib",
  "kind": "theorem",
  "first-tactic":
  "refine' ((hnot_inf_distrib _ _).ge.trans <| hnot_anti le_hnot_inf_hnot).antisymm' _",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} (a b : α) : ￢￢(a ⊔ b) = ￢￢a ⊔ ￢￢b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} (a b : α)"},
 {"type": "￢￢(a \\ b) = ￢￢a \\ ￢￢b",
  "tactic-prompt":
  "theorem {ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} (a b : α) : ￢￢(a \\ b) = ￢￢a \\ ￢￢b := by refine' le_antisymm _ _; sorry",
  "name": "hnot_hnot_sdiff_distrib",
  "kind": "theorem",
  "first-tactic": "refine' le_antisymm _ _",
  "core-prompt":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} (a b : α) : ￢￢(a \\ b) = ￢￢a \\ ￢￢b",
  "args":
  "{ι α β : Type _} {π : ι → Type _}  [CoheytingAlgebra α]  {a b c : α} (a b : α)"},
 {"type": "(a ∧ b ∨ ¬(a ∧ b)) ∧ ((a ∨ b) ∨ ¬(a ∨ b)) → a ∨ ¬a",
  "tactic-prompt":
  "example {α : Type _} [CoheytingAlgebra α]  {a b : α} (a b : Prop) : (a ∧ b ∨ ¬(a ∧ b)) ∧ ((a ∨ b) ∨ ¬(a ∨ b)) → a ∨ ¬a := by rintro ⟨⟨ha, _⟩ | hnab, (ha | hb) | hnab⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rintro ⟨⟨ha, _⟩ | hnab, (ha | hb) | hnab⟩",
  "core-prompt":
  "{α : Type _} [CoheytingAlgebra α]  {a b : α} (a b : Prop) : (a ∧ b ∨ ¬(a ∧ b)) ∧ ((a ∨ b) ∨ ¬(a ∨ b)) → a ∨ ¬a",
  "args": "{α : Type _} [CoheytingAlgebra α]  {a b : α} (a b : Prop)"},
 {"type": "IsFixedPt f (f x)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} {x : α}  (hx : IsFixedPt f x) : IsFixedPt f (f x) := by convert hx; sorry",
  "name": "apply",
  "kind": "theorem",
  "first-tactic": "convert hx",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} {x : α}  (hx : IsFixedPt f x) : IsFixedPt f (f x)",
  "args":
  "{α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} {x : α}  (hx : IsFixedPt f x)"},
 {"type": "IsFixedPt (Set.preimage (f^[n])) s",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} {s : Set α}  (h : IsFixedPt (Set.preimage f) s)  (n : ℕ) : IsFixedPt (Set.preimage (f^[n])) s := by rw [Set.preimage_iterate_eq]; sorry",
  "name": "preimage_iterate",
  "kind": "theorem",
  "first-tactic": "rw [Set.preimage_iterate_eq]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} {s : Set α}  (h : IsFixedPt (Set.preimage f) s)  (n : ℕ) : IsFixedPt (Set.preimage (f^[n])) s",
  "args":
  "{α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} {s : Set α}  (h : IsFixedPt (Set.preimage f) s)  (n : ℕ)"},
 {"type": "IsFixedPt (⇑(e ^ n)) x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} (h : IsFixedPt e x)  (n : ℕ) : IsFixedPt (⇑(e ^ n)) x := by rw [← Equiv.Perm.iterate_eq_pow]; sorry",
  "name": "perm_pow",
  "kind": "theorem",
  "first-tactic": "rw [← Equiv.Perm.iterate_eq_pow]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} (h : IsFixedPt e x)  (n : ℕ) : IsFixedPt (⇑(e ^ n)) x",
  "args":
  "{α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} (h : IsFixedPt e x)  (n : ℕ)"},
 {"type": "x ∈ fixedPoints f ↔ f x = x",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} {α : Type _}  {f : α → α}  {x : α} : x ∈ fixedPoints f ↔ f x = x := by rfl; sorry",
  "name": "mem_fixedPoints_iff",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} {α : Type _}  {f : α → α}  {x : α} : x ∈ fixedPoints f ↔ f x = x",
  "args":
  "{α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} {α : Type _}  {f : α → α}  {x : α}"},
 {"type": "Set.InvOn f g (fixedPoints <| f ∘ g) (fixedPoints <| f ∘ g)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} (h : Commute f g) : Set.InvOn f g (fixedPoints <| f ∘ g) (fixedPoints <| f ∘ g) := by simpa only [h.comp_eq] using Function.invOn_fixedPoints_comp f g; sorry",
  "name": "Commute.invOn_fixedPoints_comp",
  "kind": "theorem",
  "first-tactic":
  "simpa only [h.comp_eq] using Function.invOn_fixedPoints_comp f g",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} (h : Commute f g) : Set.InvOn f g (fixedPoints <| f ∘ g) (fixedPoints <| f ∘ g)",
  "args":
  "{α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} (h : Commute f g)"},
 {"type": "Set.BijOn f (fixedPoints <| f ∘ g) (fixedPoints <| f ∘ g)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} (h : Commute f g) : Set.BijOn f (fixedPoints <| f ∘ g) (fixedPoints <| f ∘ g) := by simpa only [h.comp_eq] using bijOn_fixedPoints_comp g f; sorry",
  "name": "Commute.left_bijOn_fixedPoints_comp",
  "kind": "theorem",
  "first-tactic": "simpa only [h.comp_eq] using bijOn_fixedPoints_comp g f",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} (h : Commute f g) : Set.BijOn f (fixedPoints <| f ∘ g) (fixedPoints <| f ∘ g)",
  "args":
  "{α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} (h : Commute f g)"},
 {"type": "Set.BijOn g (fixedPoints <| f ∘ g) (fixedPoints <| f ∘ g)",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} (h : Commute f g) : Set.BijOn g (fixedPoints <| f ∘ g) (fixedPoints <| f ∘ g) := by simpa only [h.comp_eq] using bijOn_fixedPoints_comp f g; sorry",
  "name": "Commute.right_bijOn_fixedPoints_comp",
  "kind": "theorem",
  "first-tactic": "simpa only [h.comp_eq] using bijOn_fixedPoints_comp f g",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} (h : Commute f g) : Set.BijOn g (fixedPoints <| f ∘ g) (fixedPoints <| f ∘ g)",
  "args":
  "{α : Type u}  {β : Type v}  {f fa g : α → α}  {x y : α}  {fb : β → β}  {m n k : ℕ}  {e : Perm α} (h : Commute f g)"},
 {"type": "P ∨ Q",
  "tactic-prompt": "example (h : P) : P ∨ Q := by apply .inl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply .inl",
  "core-prompt": "(h : P) : P ∨ Q",
  "args": "(h : P)"},
 {"type": "p (let_fun x := 0; x + 1)",
  "tactic-prompt":
  "theorem  : p (let_fun x := 0; x + 1) := by apply p_of_q; sorry",
  "name": "pletfun",
  "kind": "theorem",
  "first-tactic": "apply p_of_q",
  "core-prompt": " : p (let_fun x := 0; x + 1)",
  "args": ""},
 {"type": "(image (Nat.succ ∘ Nat.succ) Γ) = (image (fun a => a.succ.succ) Γ)",
  "tactic-prompt":
  "example {Γ: Set Nat} : (image (Nat.succ ∘ Nat.succ) Γ) = (image (fun a => a.succ.succ) Γ) := by simp only [Function.comp_apply]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [Function.comp_apply]",
  "core-prompt":
  "{Γ: Set Nat} : (image (Nat.succ ∘ Nat.succ) Γ) = (image (fun a => a.succ.succ) Γ)",
  "args": "{Γ: Set Nat}"},
 {"type": "r.toFun x = y",
  "tactic-prompt":
  "example (x y : α)  (h : x = y) : r.toFun x = y := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "(x y : α)  (h : x = y) : r.toFun x = y",
  "args": "(x y : α)  (h : x = y)"},
 {"type": "p ≤ p",
  "tactic-prompt": "theorem (p : Phase) : p ≤ p := by cases p; sorry",
  "name": "Phase.le_refl",
  "kind": "theorem",
  "first-tactic": "cases p",
  "core-prompt": "(p : Phase) : p ≤ p",
  "args": "(p : Phase)"},
 {"type":
  "open SemanticTokenType in\n    names[v.toNat]?.map (toString <| toJson ·) = some (toString <| toJson v)",
  "tactic-prompt":
  "example {v : SemanticTokenType} : open SemanticTokenType in\n    names[v.toNat]?.map (toString <| toJson ·) = some (toString <| toJson v) := by cases v; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases v",
  "core-prompt":
  "{v : SemanticTokenType} : open SemanticTokenType in\n    names[v.toNat]?.map (toString <| toJson ·) = some (toString <| toJson v)",
  "args": "{v : SemanticTokenType}"},
 {"type":
  "open SemanticTokenModifier in\n    names[v.toNat]?.map (toString <| toJson ·) = some (toString <| toJson v)",
  "tactic-prompt":
  "example {v : SemanticTokenModifier} : open SemanticTokenModifier in\n    names[v.toNat]?.map (toString <| toJson ·) = some (toString <| toJson v) := by cases v; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases v",
  "core-prompt":
  "{v : SemanticTokenModifier} : open SemanticTokenModifier in\n    names[v.toNat]?.map (toString <| toJson ·) = some (toString <| toJson v)",
  "args": "{v : SemanticTokenModifier}"},
 {"type": "(ks.set i k).size = (vs.set j v).size",
  "tactic-prompt":
  "theorem {ks : Array α}  {vs : Array β}  (h : ks.size = vs.size)  (i : Fin ks.size)  (j : Fin vs.size)  (k : α)  (v : β) : (ks.set i k).size = (vs.set j v).size := by simp [h]; sorry",
  "name": "size_set",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{ks : Array α}  {vs : Array β}  (h : ks.size = vs.size)  (i : Fin ks.size)  (j : Fin vs.size)  (k : α)  (v : β) : (ks.set i k).size = (vs.set j v).size",
  "args":
  "{ks : Array α}  {vs : Array β}  (h : ks.size = vs.size)  (i : Fin ks.size)  (j : Fin vs.size)  (k : α)  (v : β)"},
 {"type": "(ks.push k).size = (vs.push v).size",
  "tactic-prompt":
  "theorem {ks : Array α}  {vs : Array β}  (h : ks.size = vs.size)  (k : α)  (v : β) : (ks.push k).size = (vs.push v).size := by simp [h]; sorry",
  "name": "size_push",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{ks : Array α}  {vs : Array β}  (h : ks.size = vs.size)  (k : α)  (v : β) : (ks.push k).size = (vs.push v).size",
  "args":
  "{ks : Array α}  {vs : Array β}  (h : ks.size = vs.size)  (k : α)  (v : β)"},
 {"type": "{a : ℤ} → ¬(a + a + 1 = 0)",
  "tactic-prompt": "lemma  : {a : ℤ} → ¬(a + a + 1 = 0) := by intro a h; sorry",
  "name": "odd_ne_zero",
  "kind": "lemma",
  "first-tactic": "intro a h",
  "core-prompt": " : {a : ℤ} → ¬(a + a + 1 = 0)",
  "args": ""},
 {"type": "∀ g : P, g ^ 2 = 1 → g = 1",
  "tactic-prompt":
  "theorem  : ∀ g : P, g ^ 2 = 1 → g = 1 := by intro ⟨(p, q, r), x⟩; sorry",
  "name": "square_free",
  "kind": "theorem",
  "first-tactic": "intro ⟨(p, q, r), x⟩",
  "core-prompt": " : ∀ g : P, g ^ 2 = 1 → g = 1",
  "args": ""},
 {"type": "∀ {q : Q}, c 0 q = (0 : K)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ {q : Q}, c 0 q = (0 : K) := by intro q; sorry",
  "name": "leftId",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ {q : Q}, c 0 q = (0 : K)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ {q : Q}, c q 0 = (0 : K)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ {q : Q}, c q 0 = (0 : K) := by intro q; sorry",
  "name": "rightId",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ {q : Q}, c q 0 = (0 : K)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ q : Q, c q (-q) = q • (c (-q) q)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ q : Q, c q (-q) = q • (c (-q) q) := by intro q; sorry",
  "name": "invRel",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ q : Q, c q (-q) = q • (c (-q) q)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ q : Q, c (-q) q = (-q) • (c q (-q))",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ q : Q, c (-q) q = (-q) • (c q (-q)) := by intro q; sorry",
  "name": "invRel'",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ q : Q, c (-q) q = (-q) • (c q (-q))",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ k k' : Metabelian.Kernel Q K, k * k' = k' * k",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]  /- The multiplication operation defined using the cocycle. The cocycle condition is crucially used in showing associativity and other properties. -/  (Q K : Type _)  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ k k' : Metabelian.Kernel Q K, k * k' = k' * k := by intro ⟨⟨ka, 0⟩, rfl⟩; sorry",
  "name": "Metabelian.Kernel.mul_comm",
  "kind": "theorem",
  "first-tactic": "intro ⟨⟨ka, 0⟩, rfl⟩",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]  /- The multiplication operation defined using the cocycle. The cocycle condition is crucially used in showing associativity and other properties. -/  (Q K : Type _)  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ k k' : Metabelian.Kernel Q K, k * k' = k' * k",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]  /- The multiplication operation defined using the cocycle. The cocycle condition is crucially used in showing associativity and other properties. -/  (Q K : Type _)  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ {a : A}, a • (0 : B) = (0 : B)",
  "tactic-prompt":
  "theorem (A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, a • (0 : B) = (0 : B) := by intro; sorry",
  "name": "act_zero",
  "kind": "theorem",
  "first-tactic": "intro",
  "core-prompt":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, a • (0 : B) = (0 : B)",
  "args":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α]"},
 {"type": "∀ {a : A}, ∀ {b b' : B}, a • (b + b') = a • b + a • b'",
  "tactic-prompt":
  "theorem (A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, ∀ {b b' : B}, a • (b + b') = a • b + a • b' := by intro; sorry",
  "name": "add_dist",
  "kind": "theorem",
  "first-tactic": "intro",
  "core-prompt":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, ∀ {b b' : B}, a • (b + b') = a • b + a • b'",
  "args":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α]"},
 {"type": "∀ {a : A}, ∀ {b : B}, a • (-b) = - (a • b)",
  "tactic-prompt":
  "theorem (A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, ∀ {b : B}, a • (-b) = - (a • b) := by intros; sorry",
  "name": "neg_push",
  "kind": "theorem",
  "first-tactic": "intros",
  "core-prompt":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, ∀ {b : B}, a • (-b) = - (a • b)",
  "args":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α]"},
 {"type": "∀ x : Fin 3, x + 0 = x",
  "tactic-prompt": "example  : ∀ x : Fin 3, x + 0 = x := by decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x : Fin 3, x + 0 = x",
  "args": ""},
 {"type": "∀ x y : Fin 3, x + y = y + x",
  "tactic-prompt":
  "example  : ∀ x y : Fin 3, x + y = y + x := by decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x y : Fin 3, x + y = y + x",
  "args": ""},
 {"type": "∀ x y z : Fin 3, (x + y) + z = x + (y + z)",
  "tactic-prompt":
  "theorem  : ∀ x y z : Fin 3, (x + y) + z = x + (y + z) := by decide; sorry",
  "name": "Zmod3.assoc",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x y z : Fin 3, (x + y) + z = x + (y + z)",
  "args": ""},
 {"type":
  "∀ xy : (Fin 3) × (Fin 2), \n      xy.1.val + xy.2.val  = xy.2.val + xy.1.val",
  "tactic-prompt":
  "example  : ∀ xy : (Fin 3) × (Fin 2), \n      xy.1.val + xy.2.val  = xy.2.val + xy.1.val := by decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "decide",
  "core-prompt":
  " : ∀ xy : (Fin 3) × (Fin 2), \n      xy.1.val + xy.2.val  = xy.2.val + xy.1.val",
  "args": ""},
 {"type": "ys = fst ++ [x⁻¹] ++ snd → x :: ys = fst^x ++ snd",
  "tactic-prompt":
  "theorem (x: Letter)  (ys fst snd: Word) : ys = fst ++ [x⁻¹] ++ snd → x :: ys = fst^x ++ snd := by intro hyp; sorry",
  "name": "conj_split",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(x: Letter)  (ys fst snd: Word) : ys = fst ++ [x⁻¹] ++ snd → x :: ys = fst^x ++ snd",
  "args": "(x: Letter)  (ys fst snd: Word)"},
 {"type": "ps.fst.length + 1 ≤ w.length",
  "tactic-prompt":
  "theorem {l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.fst.length + 1 ≤ w.length := by let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append; sorry",
  "name": "splitFirst",
  "kind": "theorem",
  "first-tactic":
  "let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append",
  "core-prompt":
  "{l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.fst.length + 1 ≤ w.length",
  "args": "{l: Letter} {w: Word} (ps: ProvedSplit l w)"},
 {"type": "ps.snd.length + 1 ≤ w.length",
  "tactic-prompt":
  "theorem {l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.snd.length + 1 ≤ w.length := by let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append; sorry",
  "name": "splitSecond",
  "kind": "theorem",
  "first-tactic":
  "let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append",
  "core-prompt":
  "{l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.snd.length + 1 ≤ w.length",
  "args": "{l: Letter} {w: Word} (ps: ProvedSplit l w)"},
 {"type": "ProofTree fst → ProofTree snd → ProofTree (x :: ys)",
  "tactic-prompt":
  "def (x: Letter) (ys fst snd: Word)    (eqn : ys = fst ++ [x⁻¹] ++ snd) : ProofTree fst → ProofTree snd → ProofTree (x :: ys) := by intros pt1 pt2; sorry",
  "name": "ProofTree.headMatches",
  "kind": "def",
  "first-tactic": "intros pt1 pt2",
  "core-prompt":
  "(x: Letter) (ys fst snd: Word)    (eqn : ys = fst ++ [x⁻¹] ++ snd) : ProofTree fst → ProofTree snd → ProofTree (x :: ys)",
  "args": "(x: Letter) (ys fst snd: Word)    (eqn : ys = fst ++ [x⁻¹] ++ snd)"},
 {"type": "ProofTree (x :: w)",
  "tactic-prompt":
  "def {w : Word}  (x: Letter)           (pt: ProofTree w) : ProofTree (x :: w) := by have exp : x :: w = [x] ++ w := by rfl; sorry",
  "name": "ProofTree.prepend",
  "kind": "def",
  "first-tactic": "have exp : x :: w = [x] ++ w := by rfl",
  "core-prompt":
  "{w : Word}  (x: Letter)           (pt: ProofTree w) : ProofTree (x :: w)",
  "args": "{w : Word}  (x: Letter)           (pt: ProofTree w)"},
 {"type":
  "∀ g h : K × Q, MetabelianGroup.mul trivial_cocycle g h = MetabelianGroup.mul trivial_cocycle h g",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] : ∀ g h : K × Q, MetabelianGroup.mul trivial_cocycle g h = MetabelianGroup.mul trivial_cocycle h g := by intro (k, q); sorry",
  "name": "product_comm",
  "kind": "theorem",
  "first-tactic": "intro (k, q)",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] : ∀ g h : K × Q, MetabelianGroup.mul trivial_cocycle g h = MetabelianGroup.mul trivial_cocycle h g",
  "args": "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K]"},
 {"type": "(a, b) = (c, d) ↔ (a = c) ∧ (b = d)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] {α β : Type _}  (a c : α)  (b d : β) : (a, b) = (c, d) ↔ (a = c) ∧ (b = d) := by apply Iff.intro; sorry",
  "name": "prod_eq",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] {α β : Type _}  (a c : α)  (b d : β) : (a, b) = (c, d) ↔ (a = c) ∧ (b = d)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] {α β : Type _}  (a c : α)  (b d : β)"},
 {"type":
  "MetabelianGroup.mul trivial_cocycle (a, b) (a', b') = (a + a', b + b')",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] {a a' : A}  {b b' : B} : MetabelianGroup.mul trivial_cocycle (a, b) (a', b') = (a + a', b + b') := by show (a + a' + 0, b + b') = _; sorry",
  "name": "mul",
  "kind": "theorem",
  "first-tactic": "show (a + a' + 0, b + b') = _",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] {a a' : A}  {b b' : B} : MetabelianGroup.mul trivial_cocycle (a, b) (a', b') = (a + a', b + b')",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] {a a' : A}  {b b' : B}"},
 {"type": "(a, b) + (a', b') = (a + a', b + b')",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] (a a' : A)  (b b' : B) : (a, b) + (a', b') = (a + a', b + b') := by simp only [HAdd.hAdd]; sorry",
  "name": "add",
  "kind": "theorem",
  "first-tactic": "simp only [HAdd.hAdd]",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] (a a' : A)  (b b' : B) : (a, b) + (a', b') = (a + a', b + b')",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] (a a' : A)  (b b' : B)"},
 {"type": "zsmul (n+1) x = x + zsmul n x",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (n: ℤ)  (x : A) : zsmul (n+1) x = x + zsmul n x := by cases n; sorry",
  "name": "zsmul_succ",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (n: ℤ)  (x : A) : zsmul (n+1) x = x + zsmul n x",
  "args": "{A : Type}  [abg : AddCommGroup A] (n: ℤ)  (x : A)"},
 {"type": "zhom x (n + m) = zhom x n + zhom x m",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x : A)  (n : ℤ)  (m: Nat) : zhom x (n + m) = zhom x n + zhom x m := by induction m; sorry",
  "name": "isHom₁",
  "kind": "theorem",
  "first-tactic": "induction m",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (x : A)  (n : ℤ)  (m: Nat) : zhom x (n + m) = zhom x n + zhom x m",
  "args": "{A : Type}  [abg : AddCommGroup A] (x : A)  (n : ℤ)  (m: Nat)"},
 {"type":
  "zhom x ((Int.negSucc n) + (Int.negSucc m)) =\n          zhom x (Int.negSucc m) + zhom x (Int.negSucc n)",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x : A)  (n m : Nat) : zhom x ((Int.negSucc n) + (Int.negSucc m)) =\n          zhom x (Int.negSucc m) + zhom x (Int.negSucc n) := by simp [zhom]; sorry",
  "name": "isHom₂",
  "kind": "theorem",
  "first-tactic": "simp [zhom]",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (x : A)  (n m : Nat) : zhom x ((Int.negSucc n) + (Int.negSucc m)) =\n          zhom x (Int.negSucc m) + zhom x (Int.negSucc n)",
  "args": "{A : Type}  [abg : AddCommGroup A] (x : A)  (n m : Nat)"},
 {"type": "zhom x (n + m) = zhom x n + zhom x m",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x: A)  (n m : ℤ) : zhom x (n + m) = zhom x n + zhom x m := by cases m; sorry",
  "name": "zhom_is_hom",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (x: A)  (n m : ℤ) : zhom x (n + m) = zhom x n + zhom x m",
  "args": "{A : Type}  [abg : AddCommGroup A] (x: A)  (n m : ℤ)"},
 {"type": "zhom x 1 = x",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x : A) : zhom x 1 = x := by simp [zhom]; sorry",
  "name": "zhom_one",
  "kind": "theorem",
  "first-tactic": "simp [zhom]",
  "core-prompt": "{A : Type}  [abg : AddCommGroup A] (x : A) : zhom x 1 = x",
  "args": "{A : Type}  [abg : AddCommGroup A] (x : A)"},
 {"type": "f 1 = g 1  → ∀ n: ℕ, f (n + 1) = g (n + 1)",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  → ∀ n: ℕ, f (n + 1) = g (n + 1) := by intro hyp; sorry",
  "name": "unique_morphism_nat",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  → ∀ n: ℕ, f (n + 1) = g (n + 1)",
  "args":
  "{A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g]"},
 {"type": "f 1 = g 1  → f = g",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  → f = g := by intro hyp; sorry",
  "name": "unique_morphism",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  → f = g",
  "args":
  "{A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g]"},
 {"type": "F → A",
  "tactic-prompt":
  "def {F: Type} [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]  (f: X → A) : F → A := by apply fag.inducedMap; sorry",
  "name": "fromBasis",
  "kind": "def",
  "first-tactic": "apply fag.inducedMap",
  "core-prompt":
  "{F: Type} [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]  (f: X → A) : F → A",
  "args":
  "{F: Type} [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]  (f: X → A)"},
 {"type":
  "@AddCommGroup.Homomorphism F A _ _\n    (@fromBasis F _ X  fag A _ f)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A} : @AddCommGroup.Homomorphism F A _ _\n    (@fromBasis F _ X  fag A _ f) := by apply fag.induced_hom; sorry",
  "name": "fromBasisHom",
  "kind": "instance",
  "first-tactic": "apply fag.induced_hom",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A} : @AddCommGroup.Homomorphism F A _ _\n    (@fromBasis F _ X  fag A _ f)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A}"},
 {"type": "D →  F → A",
  "tactic-prompt":
  "def (F: Type) [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] (D: Type) (f: D → X → A) : D →  F → A := by intro p; sorry",
  "name": "fromBasisFamily",
  "kind": "def",
  "first-tactic": "intro p",
  "core-prompt":
  "(F: Type) [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] (D: Type) (f: D → X → A) : D →  F → A",
  "args":
  "(F: Type) [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] (D: Type) (f: D → X → A)"},
 {"type":
  "@AddCommGroup.Homomorphism F A _ _\n    ((@fromBasisFamily F _ X  fag A _ D f) p)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] {D : Type}    {f: D → X → A} {p : D} : @AddCommGroup.Homomorphism F A _ _\n    ((@fromBasisFamily F _ X  fag A _ D f) p) := by apply fag.induced_hom; sorry",
  "name": "fromBasisFamilyHom",
  "kind": "instance",
  "first-tactic": "apply fag.induced_hom",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] {D : Type}    {f: D → X → A} {p : D} : @AddCommGroup.Homomorphism F A _ _\n    ((@fromBasisFamily F _ X  fag A _ D f) p)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] {D : Type}    {f: D → X → A} {p : D}"},
 {"type": "@AddCommGroup.Homomorphism F A _ _\n    (fag.inducedMap A f)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A} : @AddCommGroup.Homomorphism F A _ _\n    (fag.inducedMap A f) := by apply fag.induced_hom; sorry",
  "name": "fromBasisHom'",
  "kind": "instance",
  "first-tactic": "apply fag.induced_hom",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A} : @AddCommGroup.Homomorphism F A _ _\n    (fag.inducedMap A f)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A}"},
 {"type": "Decidable (f = g)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fgp : FreeAbelianGroup F X]    {A: Type} [AddCommGroup A] [DecidableEq A] [DecideForall X]      (f g : F → A) [AddCommGroup.Homomorphism f] [AddCommGroup.Homomorphism g] : Decidable (f = g) := by apply decideHomsEqual X; sorry",
  "name": "decHomsEqual",
  "kind": "instance",
  "first-tactic": "apply decideHomsEqual X",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fgp : FreeAbelianGroup F X]    {A: Type} [AddCommGroup A] [DecidableEq A] [DecideForall X]      (f g : F → A) [AddCommGroup.Homomorphism f] [AddCommGroup.Homomorphism g] : Decidable (f = g)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fgp : FreeAbelianGroup F X]    {A: Type} [AddCommGroup A] [DecidableEq A] [DecideForall X]      (f g : F → A) [AddCommGroup.Homomorphism f] [AddCommGroup.Homomorphism g]"},
 {"type":
  "∀ (x y: Fin 2),\n  (egAction' x) ∘ (egAction' y) = egAction' (x + y)",
  "tactic-prompt":
  "theorem  : ∀ (x y: Fin 2),\n  (egAction' x) ∘ (egAction' y) = egAction' (x + y) := by decide; sorry",
  "name": "egIsAction",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt":
  " : ∀ (x y: Fin 2),\n  (egAction' x) ∘ (egAction' y) = egAction' (x + y)",
  "args": ""},
 {"type":
  "(FreeAbelianGroup.inducedMap G f) ∘ (ι₁ : A → A × B) = (FAb_A.inducedMap G (f ∘ Sum.inl))",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G) : (FreeAbelianGroup.inducedMap G f) ∘ (ι₁ : A → A × B) = (FAb_A.inducedMap G (f ∘ Sum.inl)) := by apply funext; sorry",
  "name": "FreeAbelianGroup.induced_left",
  "kind": "theorem",
  "first-tactic": "apply funext",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G) : (FreeAbelianGroup.inducedMap G f) ∘ (ι₁ : A → A × B) = (FAb_A.inducedMap G (f ∘ Sum.inl))",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G)"},
 {"type":
  "(FreeAbelianGroup.inducedMap G f) ∘ (ι₂ : B → A × B) = (FAb_B.inducedMap G (f ∘ Sum.inr))",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G) : (FreeAbelianGroup.inducedMap G f) ∘ (ι₂ : B → A × B) = (FAb_B.inducedMap G (f ∘ Sum.inr)) := by apply funext; sorry",
  "name": "FreeAbelianGroup.induced_right",
  "kind": "theorem",
  "first-tactic": "apply funext",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G) : (FreeAbelianGroup.inducedMap G f) ∘ (ι₂ : B → A × B) = (FAb_B.inducedMap G (f ∘ Sum.inr))",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G)"},
 {"type":
  "FreeAbelianGroup.i ((Sum.inl xa) : X_A ⊕ X_B) = (FAb_A.i xa, (0 : B))",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xa : X_A) : FreeAbelianGroup.i ((Sum.inl xa) : X_A ⊕ X_B) = (FAb_A.i xa, (0 : B)) := by simp [i]; sorry",
  "name": "FreeAbelianGroup.left_incl",
  "kind": "theorem",
  "first-tactic": "simp [i]",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xa : X_A) : FreeAbelianGroup.i ((Sum.inl xa) : X_A ⊕ X_B) = (FAb_A.i xa, (0 : B))",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xa : X_A)"},
 {"type":
  "FreeAbelianGroup.i ((Sum.inr xb) : X_A ⊕ X_B) = ((0 : A), FAb_B.i xb)",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xb : X_B) : FreeAbelianGroup.i ((Sum.inr xb) : X_A ⊕ X_B) = ((0 : A), FAb_B.i xb) := by simp [i]; sorry",
  "name": "FreeAbelianGroup.right_incl",
  "kind": "theorem",
  "first-tactic": "simp [i]",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xb : X_B) : FreeAbelianGroup.i ((Sum.inr xb) : X_A ⊕ X_B) = ((0 : A), FAb_B.i xb)",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xb : X_B)"},
 {"type": "AddCommGroup.Homomorphism (action q)",
  "tactic-prompt":
  "instance (q : Q) : AddCommGroup.Homomorphism (action q) := by revert q; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "revert q",
  "core-prompt": "(q : Q) : AddCommGroup.Homomorphism (action q)",
  "args": "(q : Q)"},
 {"type": "¬ (trivial_element α)",
  "tactic-prompt": "theorem  : ¬ (trivial_element α) := by intro contra; sorry",
  "name": "α_non_trivial",
  "kind": "theorem",
  "first-tactic": "intro contra",
  "core-prompt": " : ¬ (trivial_element α)",
  "args": ""},
 {"type": "coords (mulMonom 0 g s) x₀ = 0",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (g x₀: G) (s: FormalSum R G) : coords (mulMonom 0 g s) x₀ = 0 := by induction s; sorry",
  "name": "mul_monom_zero",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (g x₀: G) (s: FormalSum R G) : coords (mulMonom 0 g s) x₀ = 0",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (g x₀: G) (s: FormalSum R G)"},
 {"type":
  "coords (mulMonom b h (s₁  ++ s₂)) x₀ = coords (mulMonom b h s₁) x₀ + coords (mulMonom b h s₂) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G) : coords (mulMonom b h (s₁  ++ s₂)) x₀ = coords (mulMonom b h s₁) x₀ + coords (mulMonom b h s₂) x₀ := by induction s₁; sorry",
  "name": "mul_monom_dist",
  "kind": "theorem",
  "first-tactic": "induction s₁",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G) : coords (mulMonom b h (s₁  ++ s₂)) x₀ = coords (mulMonom b h s₁) x₀ + coords (mulMonom b h s₂) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G)"},
 {"type":
  "coords (mul s₁ (s₂  ++ s₃)) x₀ = coords (mul s₁ s₂) x₀ + coords (mul s₁ s₃) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (x₀ : G) (s₁ s₂ s₃: FormalSum R G) : coords (mul s₁ (s₂  ++ s₃)) x₀ = coords (mul s₁ s₂) x₀ + coords (mul s₁ s₃) x₀ := by induction s₂; sorry",
  "name": "mul_dist",
  "kind": "theorem",
  "first-tactic": "induction s₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (x₀ : G) (s₁ s₂ s₃: FormalSum R G) : coords (mul s₁ (s₂  ++ s₃)) x₀ = coords (mul s₁ s₂) x₀ + coords (mul s₁ s₃) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (x₀ : G) (s₁ s₂ s₃: FormalSum R G)"},
 {"type":
  "coords (mulMonom b h (mulMonom a x s)) x₀ = \n    coords (mulMonom (a * b) (x * h) s) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (a b : R) (h x₀ : G) (s : FormalSum R G) : coords (mulMonom b h (mulMonom a x s)) x₀ = \n    coords (mulMonom (a * b) (x * h) s) x₀ := by induction s; sorry",
  "name": "mul_monom_monom_assoc",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (a b : R) (h x₀ : G) (s : FormalSum R G) : coords (mulMonom b h (mulMonom a x s)) x₀ = \n    coords (mulMonom (a * b) (x * h) s) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (a b : R) (h x₀ : G) (s : FormalSum R G)"},
 {"type":
  "coords (mulMonom b h (mul s₁ s₂)) x₀ = \n    coords (mul s₁ (mulMonom b h s₂)) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G) : coords (mulMonom b h (mul s₁ s₂)) x₀ = \n    coords (mul s₁ (mulMonom b h s₂)) x₀ := by induction s₂; sorry",
  "name": "mul_monom_assoc",
  "kind": "theorem",
  "first-tactic": "induction s₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G) : coords (mulMonom b h (mul s₁ s₂)) x₀ = \n    coords (mul s₁ (mulMonom b h s₂)) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G)"},
 {"type":
  "coords (mulMonom (b₁ + b₂) h s) x₀ = coords (mulMonom b₁ h s) x₀ + coords (mulMonom b₂ h s) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b₁ b₂ : R) (h x₀ : G) (s: FormalSum R G) : coords (mulMonom (b₁ + b₂) h s) x₀ = coords (mulMonom b₁ h s) x₀ + coords (mulMonom b₂ h s) x₀ := by induction s; sorry",
  "name": "mul_monom_add",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b₁ b₂ : R) (h x₀ : G) (s: FormalSum R G) : coords (mulMonom (b₁ + b₂) h s) x₀ = coords (mulMonom b₁ h s) x₀ + coords (mulMonom b₂ h s) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b₁ b₂ : R) (h x₀ : G) (s: FormalSum R G)"},
 {"type": "mul s ((0, h) :: t) ≈  mul s t",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s t : FormalSum R G) (g: G) : mul s ((0, h) :: t) ≈  mul s t := by induction s; sorry",
  "name": "mul_zero_cons",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s t : FormalSum R G) (g: G) : mul s ((0, h) :: t) ≈  mul s t",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s t : FormalSum R G) (g: G)"},
 {"type": "FormalSum R G → FreeModule R G → FreeModule R G",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FormalSum R G → FreeModule R G → FreeModule R G := by intro s; sorry",
  "name": "mulAux",
  "kind": "def",
  "first-tactic": "intro s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FormalSum R G → FreeModule R G → FreeModule R G",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G]"},
 {"type": "coords (mulMonom b h s₁) x₀ = coords (mulMonom b h s₂) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂ : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂) : coords (mulMonom b h s₁) x₀ = coords (mulMonom b h s₂) x₀ := by induction rel; sorry",
  "name": "mul_monom_invariant",
  "kind": "theorem",
  "first-tactic": "induction rel",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂ : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂) : coords (mulMonom b h s₁) x₀ = coords (mulMonom b h s₂) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂ : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂)"},
 {"type": "FormalSum.mul s₁ t ≈  FormalSum.mul s₂ t",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s₁ s₂ t : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂) : FormalSum.mul s₁ t ≈  FormalSum.mul s₂ t := by cases t; sorry",
  "name": "first_arg_invariant",
  "kind": "theorem",
  "first-tactic": "cases t",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s₁ s₂ t : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂) : FormalSum.mul s₁ t ≈  FormalSum.mul s₂ t",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s₁ s₂ t : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂)"},
 {"type": "FreeModule R G → FreeModule R G → FreeModule R G",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FreeModule R G → FreeModule R G → FreeModule R G := by let f  := fun (s : FormalSum R G) => \n    fun  (t : FreeModule R G) => mulAux  s t; sorry",
  "name": "mul",
  "kind": "def",
  "first-tactic":
  "let f  := fun (s : FormalSum R G) => \n    fun  (t : FreeModule R G) => mulAux  s t",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FreeModule R G → FreeModule R G → FreeModule R G",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G]"},
 {"type":
  "monomCoeff R X x₀ (a + b, x) = monomCoeff R X x₀ (a, x) + monomCoeff R X x₀ (b, x)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X)  (a b : R) : monomCoeff R X x₀ (a + b, x) = monomCoeff R X x₀ (a, x) + monomCoeff R X x₀ (b, x) := by repeat\n    (\n      rw [monomCoeff]); sorry",
  "name": "monom_coords_hom",
  "kind": "theorem",
  "first-tactic": "repeat\n    (\n      rw [monomCoeff])",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X)  (a b : R) : monomCoeff R X x₀ (a + b, x) = monomCoeff R X x₀ (a, x) + monomCoeff R X x₀ (b, x)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X)  (a b : R)"},
 {"type": "monomCoeff R X x₀ (a * b, x) = a * monomCoeff R X x₀ (b, x)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (a b : R) : monomCoeff R X x₀ (a * b, x) = a * monomCoeff R X x₀ (b, x) := by repeat\n    (\n      rw [monomCoeff]); sorry",
  "name": "monom_coords_mul",
  "kind": "theorem",
  "first-tactic": "repeat\n    (\n      rw [monomCoeff])",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (a b : R) : monomCoeff R X x₀ (a * b, x) = a * monomCoeff R X x₀ (b, x)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (a b : R)"},
 {"type": "monomCoeff R X x₀ (0, x) = 0",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X) : monomCoeff R X x₀ (0, x) = 0 := by rw [monomCoeff]; sorry",
  "name": "monom_coords_at_zero",
  "kind": "theorem",
  "first-tactic": "rw [monomCoeff]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X) : monomCoeff R X x₀ (0, x) = 0",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X)"},
 {"type": "f = g → equalOnSupport l f g",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (l : List X)  (f g : X → R) : f = g → equalOnSupport l f g := by intro hyp; sorry",
  "name": "equal_on_support_of_equal",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (l : List X)  (f g : X → R) : f = g → equalOnSupport l f g",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (l : List X)  (f g : X → R)"},
 {"type": "eqlCoords R X s s",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s : FormalSum R X) : eqlCoords R X s s := by rfl; sorry",
  "name": "refl",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s : FormalSum R X) : eqlCoords R X s s",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s : FormalSum R X)"},
 {"type": "eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₁",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ : FormalSum R X} : eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₁ := by intro hyp; sorry",
  "name": "symm",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ : FormalSum R X} : eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₁",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ : FormalSum R X}"},
 {"type": "eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₃ → eqlCoords R X s₁ s₃",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ s₃ : FormalSum R X} : eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₃ → eqlCoords R X s₁ s₃ := by intro hyp₁ hyp₂; sorry",
  "name": "trans",
  "kind": "theorem",
  "first-tactic": "intro hyp₁ hyp₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ s₃ : FormalSum R X} : eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₃ → eqlCoords R X s₁ s₃",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ s₃ : FormalSum R X}"},
 {"type": "beqOnSupport l f g = true → equalOnSupport l f g",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {l : List X}  {f g : X → R} : beqOnSupport l f g = true → equalOnSupport l f g := by intro hyp; sorry",
  "name": "eql_on_support_of_true",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {l : List X}  {f g : X → R} : beqOnSupport l f g = true → equalOnSupport l f g",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {l : List X}  {f g : X → R}"},
 {"type": "⟦s₁⟧ = ⟦s₂⟧",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) (c₁ : beqOnSupport s₁.support s₁.coords s₂.coords) (c₂ : beqOnSupport s₂.support s₁.coords s₂.coords) : ⟦s₁⟧ = ⟦s₂⟧ := by let ch₁ := eql_on_support_of_true c₁; sorry",
  "name": "eqlquot_of_beq_support",
  "kind": "theorem",
  "first-tactic": "let ch₁ := eql_on_support_of_true c₁",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) (c₁ : beqOnSupport s₁.support s₁.coords s₂.coords) (c₂ : beqOnSupport s₂.support s₁.coords s₂.coords) : ⟦s₁⟧ = ⟦s₂⟧",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) (c₁ : beqOnSupport s₁.support s₁.coords s₂.coords) (c₂ : beqOnSupport s₂.support s₁.coords s₂.coords)"},
 {"type": "Bool",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : Bool := by apply Quotient.lift₂ (fun (s₁ s₂ : FormalSum R X) => decide (⟦s₁⟧ = ⟦s₂⟧)); sorry",
  "name": "beq_quot",
  "kind": "def",
  "first-tactic":
  "apply Quotient.lift₂ (fun (s₁ s₂ : FormalSum R X) => decide (⟦s₁⟧ = ⟦s₂⟧))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : Bool",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X)"},
 {"type": "∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = true → x₁ = x₂",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : ∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = true → x₁ = x₂ := by let f :=\n    @Quotient.ind₂ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (x₁ x₂ : FreeModule R X) => x₁.beq_quot x₂ = true → x₁ = x₂); sorry",
  "name": "eq_of_beq_true",
  "kind": "def",
  "first-tactic":
  "let f :=\n    @Quotient.ind₂ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (x₁ x₂ : FreeModule R X) => x₁.beq_quot x₂ = true → x₁ = x₂)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : ∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = true → x₁ = x₂",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = false → Not (x₁ = x₂)",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : ∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = false → Not (x₁ = x₂) := by let f :=\n    @Quotient.ind₂ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (x₁ x₂ : FreeModule R X) => x₁.beq_quot x₂ = false → Not (x₁ = x₂)); sorry",
  "name": "neq_of_beq_false",
  "kind": "def",
  "first-tactic":
  "let f :=\n    @Quotient.ind₂ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (x₁ x₂ : FreeModule R X) => x₁.beq_quot x₂ = false → Not (x₁ = x₂))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : ∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = false → Not (x₁ = x₂)",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "Decidable (x₁ = x₂)",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : Decidable (x₁ = x₂) := by match p : x₁.beq_quot x₂ with\n  | true =>\n    apply Decidable.isTrue\n    apply FreeModule.eq_of_beq_true\n    assumption\n  | false =>\n    apply Decidable.isFalse\n    apply FreeModule.neq_of_beq_false\n    assumption; sorry",
  "name": "decEq",
  "kind": "def",
  "first-tactic":
  "match p : x₁.beq_quot x₂ with\n  | true =>\n    apply Decidable.isTrue\n    apply FreeModule.eq_of_beq_true\n    assumption\n  | false =>\n    apply Decidable.isFalse\n    apply FreeModule.neq_of_beq_false\n    assumption",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : Decidable (x₁ = x₂)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X)"},
 {"type": "s₁ ≈ s₂ → s₁.coords = s₂.coords",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) : s₁ ≈ s₂ → s₁.coords = s₂.coords := by intro hyp; sorry",
  "name": "equal_coords_of_approx",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) : s₁ ≈ s₂ → s₁.coords = s₂.coords",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)"},
 {"type": "FreeModule R X →  R",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) : FreeModule R X →  R := by apply Quotient.lift (fun s : FormalSum R X => s.coords x₀); sorry",
  "name": "coordinates",
  "kind": "def",
  "first-tactic": "apply Quotient.lift (fun s : FormalSum R X => s.coords x₀)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) : FreeModule R X →  R",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)"},
 {"type": "(r * s.coords x₀) = (s.scmul r).coords x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (r : R)  (s : FormalSum R X)  (x₀ : X) : (r * s.coords x₀) = (s.scmul r).coords x₀ := by induction s; sorry",
  "name": "scmul_coords",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (r : R)  (s : FormalSum R X)  (x₀ : X) : (r * s.coords x₀) = (s.scmul r).coords x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (r : R)  (s : FormalSum R X)  (x₀ : X)"},
 {"type": "R → FreeModule R X → FreeModule R X",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : R → FreeModule R X → FreeModule R X := by intro r; sorry",
  "name": "FreeModule.scmul",
  "kind": "def",
  "first-tactic": "intro r",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : R → FreeModule R X → FreeModule R X",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "(s₁.coords x₀) + (s₂.coords x₀) = (s₁ ++ s₂).coords x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (x₀ : X) : (s₁.coords x₀) + (s₂.coords x₀) = (s₁ ++ s₂).coords x₀ := by induction s₁; sorry",
  "name": "append_coords",
  "kind": "theorem",
  "first-tactic": "induction s₁",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (x₀ : X) : (s₁.coords x₀) + (s₂.coords x₀) = (s₁ ++ s₂).coords x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (x₀ : X)"},
 {"type": "(s₁ ≈ s₂) → (t₁ ≈ t₂) → s₁ ++ t₁ ≈ s₂ ++ t₂",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ t₁ t₂ : FormalSum R X) : (s₁ ≈ s₂) → (t₁ ≈ t₂) → s₁ ++ t₁ ≈ s₂ ++ t₂ := by intro eqv₁ eqv₂; sorry",
  "name": "append_equiv",
  "kind": "theorem",
  "first-tactic": "intro eqv₁ eqv₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ t₁ t₂ : FormalSum R X) : (s₁ ≈ s₂) → (t₁ ≈ t₂) → s₁ ++ t₁ ≈ s₂ ++ t₂",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ t₁ t₂ : FormalSum R X)"},
 {"type": "FreeModule R X → FreeModule R X → FreeModule R X",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : FreeModule R X → FreeModule R X → FreeModule R X := by let f : FormalSum R X → FormalSum R X → FreeModule R X := fun s₁ s₂ => ⟦s₁ ++ s₂⟧; sorry",
  "name": "FreeModule.add",
  "kind": "def",
  "first-tactic":
  "let f : FormalSum R X → FormalSum R X → FreeModule R X := fun s₁ s₂ => ⟦s₁ ++ s₂⟧",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : FreeModule R X → FreeModule R X → FreeModule R X",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "(s.scmul b).scmul a = s.scmul (a * b)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul b).scmul a = s.scmul (a * b) := by induction s; sorry",
  "name": "action",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul b).scmul a = s.scmul (a * b)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X)"},
 {"type": "(s.scmul a) ++ (s.scmul b) ≈  s.scmul (a + b)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul a) ++ (s.scmul b) ≈  s.scmul (a + b) := by induction s; sorry",
  "name": "act_sum",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul a) ++ (s.scmul b) ≈  s.scmul (a + b)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X)"},
 {"type": "a • (b • x) = (a * b) • x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (x : FreeModule R X) : a • (b • x) = (a * b) • x := by apply @Quotient.ind (motive := fun x : FreeModule R X => a • (b • x) = (a * b) • x); sorry",
  "name": "module_action",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => a • (b • x) = (a * b) • x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (x : FreeModule R X) : a • (b • x) = (a * b) • x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (x : FreeModule R X)"},
 {"type": "x₁ + x₂ = x₂ + x₁",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : x₁ + x₂ = x₂ + x₁ := by apply @Quotient.ind₂ (motive := fun x₁ x₂ : FreeModule R X => x₁ + x₂ = x₂ + x₁); sorry",
  "name": "addn_comm",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind₂ (motive := fun x₁ x₂ : FreeModule R X => x₁ + x₂ = x₂ + x₁)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : x₁ + x₂ = x₂ + x₁",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X)"},
 {"type": "(⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ : FormalSum R X)  (x₂ x₃ : FreeModule R X) : (⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃) := by apply @Quotient.ind₂ (motive := fun x₂ x₃ : FreeModule R X => (⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃)); sorry",
  "name": "add_assoc_aux",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind₂ (motive := fun x₂ x₃ : FreeModule R X => (⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ : FormalSum R X)  (x₂ x₃ : FreeModule R X) : (⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ : FormalSum R X)  (x₂ x₃ : FreeModule R X)"},
 {"type": "(x₁ + x₂) + x₃ = x₁ + (x₂ + x₃)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ x₃ : FreeModule R X) : (x₁ + x₂) + x₃ = x₁ + (x₂ + x₃) := by apply @Quotient.ind (motive := fun x₁ : FreeModule R X => (x₁ + x₂) + x₃ = x₁ + (x₂ + x₃)); sorry",
  "name": "addn_assoc",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x₁ : FreeModule R X => (x₁ + x₂) + x₃ = x₁ + (x₂ + x₃))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ x₃ : FreeModule R X) : (x₁ + x₂) + x₃ = x₁ + (x₂ + x₃)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ x₃ : FreeModule R X)"},
 {"type": "x + zero = x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : x + zero = x := by apply @Quotient.ind (motive := fun x : FreeModule R X => x + zero = x); sorry",
  "name": "addn_zero",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => x + zero = x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : x + zero = x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "zero + x = x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : zero + x = x := by apply @Quotient.ind (motive := fun x : FreeModule R X => zero + x = x); sorry",
  "name": "zero_addn",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => zero + x = x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : zero + x = x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "a • (x₁ + x₂) = a • x₁ + a • x₂",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a : R)  (x₁ x₂ : FreeModule R X) : a • (x₁ + x₂) = a • x₁ + a • x₂ := by apply @Quotient.ind₂ (motive := fun x₁ x₂ : FreeModule R X => a • (x₁ + x₂) = a • x₁ + a • x₂); sorry",
  "name": "elem_distrib",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind₂ (motive := fun x₁ x₂ : FreeModule R X => a • (x₁ + x₂) = a • x₁ + a • x₂)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a : R)  (x₁ x₂ : FreeModule R X) : a • (x₁ + x₂) = a • x₁ + a • x₂",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a : R)  (x₁ x₂ : FreeModule R X)"},
 {"type": "a • x + b • x = (a + b) • x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b: R) (x: FreeModule R X) : a • x + b • x = (a + b) • x := by apply @Quotient.ind (motive := fun x : FreeModule R X => \n    a • x + b • x = (a + b) • x); sorry",
  "name": "coeffs_distrib",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => \n    a • x + b • x = (a + b) • x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b: R) (x: FreeModule R X) : a • x + b • x = (a + b) • x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b: R) (x: FreeModule R X)"},
 {"type": "(1 : R) • x =  x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (1 : R) • x =  x := by apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (1 : R) • x =  x); sorry",
  "name": "unit_coeffs",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (1 : R) • x =  x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (1 : R) • x =  x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "(0 : R) • x =  ⟦ [] ⟧",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (0 : R) • x =  ⟦ [] ⟧ := by apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (0 : R) • x =  ⟦ [] ⟧); sorry",
  "name": "zero_coeffs",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (0 : R) • x =  ⟦ [] ⟧)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (0 : R) • x =  ⟦ [] ⟧",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "coords s₁ x₀ = coords s₂ x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (s₁ s₂ : FormalSum R X)  (h : ElementaryMove R X s₁ s₂) : coords s₁ x₀ = coords s₂ x₀ := by induction h; sorry",
  "name": "coords_move_invariant",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (s₁ s₂ : FormalSum R X)  (h : ElementaryMove R X s₁ s₂) : coords s₁ x₀ = coords s₂ x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (s₁ s₂ : FormalSum R X)  (h : ElementaryMove R X s₁ s₂)"},
 {"type": "FreeModuleAux.coeff  x (sum s) = s.coords x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s : FormalSum R X) : FreeModuleAux.coeff  x (sum s) = s.coords x := by simp [FreeModuleAux.coeff]; sorry",
  "name": "coeff_factors",
  "kind": "theorem",
  "first-tactic": "simp [FreeModuleAux.coeff]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s : FormalSum R X) : FreeModuleAux.coeff  x (sum s) = s.coords x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s : FormalSum R X)"},
 {"type": "s₁ ≃ s₂ → s₁.coords x = s₂.coords x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s₁ s₂ : FormalSum R X) : s₁ ≃ s₂ → s₁.coords x = s₂.coords x := by intro hyp; sorry",
  "name": "coords_well_defined",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s₁ s₂ : FormalSum R X) : s₁ ≃ s₂ → s₁.coords x = s₂.coords x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s₁ s₂ : FormalSum R X)"},
 {"type": "s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (a : R)  (x : X) : s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂ := by intro h; sorry",
  "name": "cons_equiv_of_equiv",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (a : R)  (x : X) : s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (a : R)  (x : X)"},
 {"type":
  "0 ≠ s.coords x₀ → (∃ ys : FormalSum R X, (((s.coords x₀, x₀) :: ys) ≃ s) ∧ (List.length ys < s.length))",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) (s : FormalSum R X) : 0 ≠ s.coords x₀ → (∃ ys : FormalSum R X, (((s.coords x₀, x₀) :: ys) ≃ s) ∧ (List.length ys < s.length)) := by induction s; sorry",
  "name": "nonzero_coeff_has_complement",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) (s : FormalSum R X) : 0 ≠ s.coords x₀ → (∃ ys : FormalSum R X, (((s.coords x₀, x₀) :: ys) ≃ s) ∧ (List.length ys < s.length))",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) (s : FormalSum R X)"},
 {"type":
  "(∀ s₁ s₂ : FormalSum R X, ElementaryMove R X s₁ s₂ → f s₁ = f s₂) → (∀ s₁ s₂ : FormalSum R X, s₁ ≈ s₂ → f s₁ = f s₂)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {β : Sort u}  (f : FormalSum R X → β) : (∀ s₁ s₂ : FormalSum R X, ElementaryMove R X s₁ s₂ → f s₁ = f s₂) → (∀ s₁ s₂ : FormalSum R X, s₁ ≈ s₂ → f s₁ = f s₂) := by intro hyp; sorry",
  "name": "func_eql_of_move_equiv",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {β : Sort u}  (f : FormalSum R X → β) : (∀ s₁ s₂ : FormalSum R X, ElementaryMove R X s₁ s₂ → f s₁ = f s₂) → (∀ s₁ s₂ : FormalSum R X, s₁ ≈ s₂ → f s₁ = f s₂)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {β : Sort u}  (f : FormalSum R X → β)"},
 {"type": "a ≤ max a b",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : a ≤ max a b := by simp [max]; sorry",
  "name": "fst_le_max",
  "kind": "theorem",
  "first-tactic": "simp [max]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : a ≤ max a b",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat)"},
 {"type": "b ≤ max a b",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : b ≤ max a b := by simp [max]; sorry",
  "name": "snd_le_max",
  "kind": "theorem",
  "first-tactic": "simp [max]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : b ≤ max a b",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat)"},
 {"type": "(max a b = a) ∨ (max a b = b)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : (max a b = a) ∨ (max a b = b) := by simp [max]; sorry",
  "name": "eq_fst_or_snd_of_max",
  "kind": "theorem",
  "first-tactic": "simp [max]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : (max a b = a) ∨ (max a b = b)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat)"},
 {"type":
  "maxNormSuccOnSupp norm crds s > 0 → \n  ∃ x : X, crds x ≠ 0 ∧ maxNormSuccOnSupp norm crds s = norm x + 1",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X) : maxNormSuccOnSupp norm crds s > 0 → \n  ∃ x : X, crds x ≠ 0 ∧ maxNormSuccOnSupp norm crds s = norm x + 1 := by intro h; sorry",
  "name": "max_in_support",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X) : maxNormSuccOnSupp norm crds s > 0 → \n  ∃ x : X, crds x ≠ 0 ∧ maxNormSuccOnSupp norm crds s = norm x + 1",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X)"},
 {"type":
  "(x: X) → x ∈ s →  crds x ≠ 0 → norm x + 1 ≤ maxNormSuccOnSupp norm crds s",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X) : (x: X) → x ∈ s →  crds x ≠ 0 → norm x + 1 ≤ maxNormSuccOnSupp norm crds s := by intro x h₁ h₂; sorry",
  "name": "supp_below_max",
  "kind": "theorem",
  "first-tactic": "intro x h₁ h₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X) : (x: X) → x ∈ s →  crds x ≠ 0 → norm x + 1 ≤ maxNormSuccOnSupp norm crds s",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X)"},
 {"type": "s₁.normSucc norm = s₂.normSucc norm",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm : X → Nat) (s₁ s₂: FormalSum R X) (eql : s₁ ≈ s₂) : s₁.normSucc norm = s₂.normSucc norm := by apply Nat.le_antisymm; sorry",
  "name": "norm_succ_eq",
  "kind": "theorem",
  "first-tactic": "apply Nat.le_antisymm",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm : X → Nat) (s₁ s₂: FormalSum R X) (eql : s₁ ≈ s₂) : s₁.normSucc norm = s₂.normSucc norm",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm : X → Nat) (s₁ s₂: FormalSum R X) (eql : s₁ ≈ s₂)"},
 {"type": "Nat",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) [nx : NormCube X] : Nat := by let f : FormalSum R X → Nat := fun s => s.normSucc (nx.norm); sorry",
  "name": "FreeModule.normBound",
  "kind": "def",
  "first-tactic":
  "let f : FormalSum R X → Nat := fun s => s.normSucc (nx.norm)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) [nx : NormCube X] : Nat",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) [nx : NormCube X]"},
 {"type": ".append p .nil = p",
  "tactic-prompt":
  "theorem {V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B) : .append p .nil = p := by induction p; sorry",
  "name": "append_nil",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B) : .append p .nil = p",
  "args": "{V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)"},
 {"type": "snoc (cons e p) e' = cons e (snoc p e')",
  "tactic-prompt":
  "theorem {V : Sort _}  [Quiver V]  {A B C D : V} (e : A ⟶ B)  (p : Path B C)  (e' : C ⟶ D) : snoc (cons e p) e' = cons e (snoc p e') := by cases p; sorry",
  "name": "snoc_cons",
  "kind": "theorem",
  "first-tactic": "cases p",
  "core-prompt":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (e : A ⟶ B)  (p : Path B C)  (e' : C ⟶ D) : snoc (cons e p) e' = cons e (snoc p e')",
  "args":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (e : A ⟶ B)  (p : Path B C)  (e' : C ⟶ D)"},
 {"type": "append p (snoc p' e) = snoc (append p p') e",
  "tactic-prompt":
  "theorem {V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (p' : Path B C)  (e : C ⟶ D) : append p (snoc p' e) = snoc (append p p') e := by induction p; sorry",
  "name": "append_snoc",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (p' : Path B C)  (e : C ⟶ D) : append p (snoc p' e) = snoc (append p p') e",
  "args":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (p' : Path B C)  (e : C ⟶ D)"},
 {"type": "append p (cons e p') = append (snoc p e) p'",
  "tactic-prompt":
  "theorem {V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (e : B ⟶ C)  (p' : Path C D) : append p (cons e p') = append (snoc p e) p' := by induction p; sorry",
  "name": "append_cons",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (e : B ⟶ C)  (p' : Path C D) : append p (cons e p') = append (snoc p e) p'",
  "args":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (e : B ⟶ C)  (p' : Path C D)"},
 {"type": "append (append p q) r = append p (append q r)",
  "tactic-prompt":
  "theorem {V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (q : Path B C)  (r : Path C D) : append (append p q) r = append p (append q r) := by induction p; sorry",
  "name": "append_assoc",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (q : Path B C)  (r : Path C D) : append (append p q) r = append p (append q r)",
  "args":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (q : Path B C)  (r : Path C D)"},
 {"type": "NullHomotopy (.append p (.append l q)) → NullHomotopy (.append p q)",
  "tactic-prompt":
  "def {V : Sort _}  [C : CombinatorialTwoComplex V]  {u v w : V}  (l l' : Loop v) {u v : V}  {p : Path u v}  {l : Loop v}  (rel : NullHomotopy l)  {q : Path v u} : NullHomotopy (.append p (.append l q)) → NullHomotopy (.append p q) := by intro r; sorry",
  "name": "contract",
  "kind": "def",
  "first-tactic": "intro r",
  "core-prompt":
  "{V : Sort _}  [C : CombinatorialTwoComplex V]  {u v w : V}  (l l' : Loop v) {u v : V}  {p : Path u v}  {l : Loop v}  (rel : NullHomotopy l)  {q : Path v u} : NullHomotopy (.append p (.append l q)) → NullHomotopy (.append p q)",
  "args":
  "{V : Sort _}  [C : CombinatorialTwoComplex V]  {u v w : V}  (l l' : Loop v) {u v : V}  {p : Path u v}  {l : Loop v}  (rel : NullHomotopy l)  {q : Path v u}"},
 {"type": "NullHomotopy (.append p q) → NullHomotopy (.append p (.append l q))",
  "tactic-prompt":
  "def {V : Sort _}  [C : CombinatorialTwoComplex V]  {u v w : V}  (l l' : Loop v) {u v : V}  {p : Path u v}  {l : Loop v}  (rel : NullHomotopy l)  {q : Path v u} : NullHomotopy (.append p q) → NullHomotopy (.append p (.append l q)) := by intro r; sorry",
  "name": "splice",
  "kind": "def",
  "first-tactic": "intro r",
  "core-prompt":
  "{V : Sort _}  [C : CombinatorialTwoComplex V]  {u v w : V}  (l l' : Loop v) {u v : V}  {p : Path u v}  {l : Loop v}  (rel : NullHomotopy l)  {q : Path v u} : NullHomotopy (.append p q) → NullHomotopy (.append p (.append l q))",
  "args":
  "{V : Sort _}  [C : CombinatorialTwoComplex V]  {u v w : V}  (l l' : Loop v) {u v : V}  {p : Path u v}  {l : Loop v}  (rel : NullHomotopy l)  {q : Path v u}"},
 {"type": "(p : Path A B) → p.last = p.inverse.first",
  "tactic-prompt":
  "theorem {V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) : (p : Path A B) → p.last = p.inverse.first := by intro p; sorry",
  "name": "last_eq_inv_first",
  "kind": "theorem",
  "first-tactic": "intro p",
  "core-prompt":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) : (p : Path A B) → p.last = p.inverse.first",
  "args": "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B)"},
 {"type": "l.inv.inv = l",
  "tactic-prompt":
  "theorem {V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : l.inv.inv = l := by simp; sorry",
  "name": "inv_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : l.inv.inv = l",
  "args":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A)"},
 {"type": "(rotate A l.inv).inv = rotate' A l",
  "tactic-prompt":
  "theorem {V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : (rotate A l.inv).inv = rotate' A l := by simp [rotate']; sorry",
  "name": "inv_rotate_inv",
  "kind": "theorem",
  "first-tactic": "simp [rotate']",
  "core-prompt":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : (rotate A l.inv).inv = rotate' A l",
  "args":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A)"},
 {"type": "(prev A l.inv) = next A l",
  "tactic-prompt":
  "theorem {V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : (prev A l.inv) = next A l := by simp [prev]; sorry",
  "name": "prev_inv",
  "kind": "theorem",
  "first-tactic": "simp [prev]",
  "core-prompt":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : (prev A l.inv) = next A l",
  "args":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A)"},
 {"type": "(next A l.inv) = prev A l",
  "tactic-prompt":
  "theorem {V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : (next A l.inv) = prev A l := by simp; sorry",
  "name": "next_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : (next A l.inv) = prev A l",
  "args":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A)"},
 {"type": "(l.rotate' A).next _ = A",
  "tactic-prompt":
  "theorem {V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : (l.rotate' A).next _ = A := by show prev _ (rotate _ l.inv) = A; sorry",
  "name": "rotate'_next",
  "kind": "theorem",
  "first-tactic": "show prev _ (rotate _ l.inv) = A",
  "core-prompt":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : (l.rotate' A).next _ = A",
  "args":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A)"},
 {"type": "HEq (rotate' A l.inv) (rotate A l).inv",
  "tactic-prompt":
  "theorem {V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : HEq (rotate' A l.inv) (rotate A l).inv := by rw [← inv_rotate_inv A l.inv]; sorry",
  "name": "rotate'_inv_heq",
  "kind": "theorem",
  "first-tactic": "rw [← inv_rotate_inv A l.inv]",
  "core-prompt":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : HEq (rotate' A l.inv) (rotate A l).inv",
  "args":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A)"},
 {"type": "HEq (rotate A l.inv) (rotate' A l).inv",
  "tactic-prompt":
  "theorem {V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : HEq (rotate A l.inv) (rotate' A l).inv := by rw [rotate']; sorry",
  "name": "rotate_inv_heq",
  "kind": "theorem",
  "first-tactic": "rw [rotate']",
  "core-prompt":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : HEq (rotate A l.inv) (rotate' A l).inv",
  "args":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A)"},
 {"type": "g⁻¹ ≫ (g ≫ h) = h",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) : g⁻¹ ≫ (g ≫ h) = h := by rw [← comp_assoc]; sorry",
  "name": "left_inv_cancel",
  "kind": "theorem",
  "first-tactic": "rw [← comp_assoc]",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) : g⁻¹ ≫ (g ≫ h) = h",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z)"},
 {"type": "(𝟙 X)⁻¹ = 𝟙 X",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) : (𝟙 X)⁻¹ = 𝟙 X := by have := left_inv_cancel (𝟙 X) (𝟙 X); sorry",
  "name": "id_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (𝟙 X) (𝟙 X)",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) : (𝟙 X)⁻¹ = 𝟙 X",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z)"},
 {"type": "(g⁻¹)⁻¹ = g",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) : (g⁻¹)⁻¹ = g := by have := left_inv_cancel (g⁻¹) g; sorry",
  "name": "inv_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (g⁻¹) g",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) : (g⁻¹)⁻¹ = g",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z)"},
 {"type": "g ≫ (g⁻¹ ≫ h) = h",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) (h : X ⟶ Z) : g ≫ (g⁻¹ ≫ h) = h := by have := left_inv_cancel g⁻¹ h; sorry",
  "name": "left_cancel_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel g⁻¹ h",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) (h : X ⟶ Z) : g ≫ (g⁻¹ ≫ h) = h",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) (h : X ⟶ Z)"},
 {"type": "(g ≫ h)⁻¹ = h⁻¹ ≫ g⁻¹",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) : (g ≫ h)⁻¹ = h⁻¹ ≫ g⁻¹ := by have := left_cancel_inv (g ≫ h)⁻¹ (h⁻¹ ≫ g⁻¹); sorry",
  "name": "inv_comp",
  "kind": "theorem",
  "first-tactic": "have := left_cancel_inv (g ≫ h)⁻¹ (h⁻¹ ≫ g⁻¹)",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) : (g ≫ h)⁻¹ = h⁻¹ ≫ g⁻¹",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z)"},
 {"type": "(g = g ≫ e) ↔ 𝟙 Y = e",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) : (g = g ≫ e) ↔ 𝟙 Y = e := by have := left_cancel g (𝟙 _) e; sorry",
  "name": "left_cancel_id",
  "kind": "theorem",
  "first-tactic": "have := left_cancel g (𝟙 _) e",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) : (g = g ≫ e) ↔ 𝟙 Y = e",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z)"},
 {"type": "(g ≫ e = g) ↔ e = 𝟙 Y",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) : (g ≫ e = g) ↔ e = 𝟙 Y := by have := left_cancel g e (𝟙 Y); sorry",
  "name": "left_cancel_id'",
  "kind": "theorem",
  "first-tactic": "have := left_cancel g e (𝟙 Y)",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) : (g ≫ e = g) ↔ e = 𝟙 Y",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z)"},
 {"type": "(g = e ≫ g) ↔ 𝟙 X = e",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) : (g = e ≫ g) ↔ 𝟙 X = e := by have := right_cancel (𝟙 X) e g; sorry",
  "name": "right_cancel_id",
  "kind": "theorem",
  "first-tactic": "have := right_cancel (𝟙 X) e g",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) : (g = e ≫ g) ↔ 𝟙 X = e",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z)"},
 {"type": "(e ≫ g = g) ↔ e = 𝟙 X",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) : (e ≫ g = g) ↔ e = 𝟙 X := by have := right_cancel e (𝟙 X) g; sorry",
  "name": "right_cancel_id'",
  "kind": "theorem",
  "first-tactic": "have := right_cancel e (𝟙 X) g",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) : (e ≫ g = g) ↔ e = 𝟙 X",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z)"},
 {"type": "Φ.map (𝟙 X) = 𝟙 (Φ.obj X)",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) {R S T : Sort _}  [F : Groupoid R]  [G : Groupoid S]  [H : Groupoid T] (Ψ : Groupoid.Functor F G)  (Φ : Groupoid.Functor G H) {X : S} : Φ.map (𝟙 X) = 𝟙 (Φ.obj X) := by have := Φ.map_comp (𝟙 X) (𝟙 X); sorry",
  "name": "map_id'",
  "kind": "theorem",
  "first-tactic": "have := Φ.map_comp (𝟙 X) (𝟙 X)",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) {R S T : Sort _}  [F : Groupoid R]  [G : Groupoid S]  [H : Groupoid T] (Ψ : Groupoid.Functor F G)  (Φ : Groupoid.Functor G H) {X : S} : Φ.map (𝟙 X) = 𝟙 (Φ.obj X)",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) {R S T : Sort _}  [F : Groupoid R]  [G : Groupoid S]  [H : Groupoid T] (Ψ : Groupoid.Functor F G)  (Φ : Groupoid.Functor G H) {X : S}"},
 {"type": "Φ.map g⁻¹ = (Φ.map g)⁻¹",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) {R S T : Sort _}  [F : Groupoid R]  [G : Groupoid S]  [H : Groupoid T] (Ψ : Groupoid.Functor F G)  (Φ : Groupoid.Functor G H) {X Y : S}  (g : X ⟶ Y) : Φ.map g⁻¹ = (Φ.map g)⁻¹ := by apply (Groupoid.left_cancel (Φ.map g) _ _).mp; sorry",
  "name": "map_inv",
  "kind": "theorem",
  "first-tactic": "apply (Groupoid.left_cancel (Φ.map g) _ _).mp",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) {R S T : Sort _}  [F : Groupoid R]  [G : Groupoid S]  [H : Groupoid T] (Ψ : Groupoid.Functor F G)  (Φ : Groupoid.Functor G H) {X Y : S}  (g : X ⟶ Y) : Φ.map g⁻¹ = (Φ.map g)⁻¹",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X ⟶ Y)  (h h' : Y ⟶ Z) {R S T : Sort _}  [F : Groupoid R]  [G : Groupoid S]  [H : Groupoid T] (Ψ : Groupoid.Functor F G)  (Φ : Groupoid.Functor G H) {X Y : S}  (g : X ⟶ Y)"},
 {"type": "(EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z) := by intro p q; sorry",
  "name": "multiply",
  "kind": "def",
  "first-tactic": "intro p q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}"},
 {"type": "G.init e = x → (term G (G.bar e) = x)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x) := by intro h; sorry",
  "name": "term_bar_equals_init",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} {e : E}"},
 {"type": "(term G e = x) → G.init (G.bar e) = x",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x :V}  {e : E} : (term G e = x) → G.init (G.bar e) = x := by intro hyp; sorry",
  "name": "init_bar_equals_term",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x :V}  {e : E} : (term G e = x) → G.init (G.bar e) = x",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x :V}  {e : E}"},
 {"type": "(multiply (multiply p q) r) = (multiply p (multiply q r))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r)) := by induction p; sorry",
  "name": "mult_assoc",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z)"},
 {"type": "(multiply p (single y)) = p",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p := by induction p; sorry",
  "name": "mult_const",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {p : EdgePath G x y}"},
 {"type": "{ rp : EdgePath G x z // rp.length ≤ (cons ex h₁ h₂ exy).length}",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : { rp : EdgePath G x z // rp.length ≤ (cons ex h₁ h₂ exy).length} := by cases exy; sorry",
  "name": "reducePathAux",
  "kind": "def",
  "first-tactic": "cases exy",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : { rp : EdgePath G x z // rp.length ≤ (cons ex h₁ h₂ exy).length}",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z)"},
 {"type": "homotopy p q → homotopy q r → homotopy p r",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y) : homotopy p q → homotopy q r → homotopy p r := by intro h₁ h₂; sorry",
  "name": "homotopy_trans",
  "kind": "theorem",
  "first-tactic": "intro h₁ h₂",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y) : homotopy p q → homotopy q r → homotopy p r",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y)"},
 {"type":
  "(p q : EdgePath G y z) → homotopy p q → (ex : E) →(h1 : G.init ex = x) → ( h : term G ex = y)→ homotopy (cons ex h1 h p) (cons ex h1 h q)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (p q : EdgePath G y z) → homotopy p q → (ex : E) →(h1 : G.init ex = x) → ( h : term G ex = y)→ homotopy (cons ex h1 h p) (cons ex h1 h q) := by intro p q h ex h1 h2; sorry",
  "name": "homotopy_left_mult_edge",
  "kind": "theorem",
  "first-tactic": "intro p q h ex h1 h2",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (p q : EdgePath G y z) → homotopy p q → (ex : E) →(h1 : G.init ex = x) → ( h : term G ex = y)→ homotopy (cons ex h1 h p) (cons ex h1 h q)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}"},
 {"type": "(homotopy (multiply q p1) (multiply q p2))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2)) := by induction q; sorry",
  "name": "homotopy_left_mult",
  "kind": "theorem",
  "first-tactic": "induction q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2)"},
 {"type": "ht G y z →  ht G x z",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y) : ht G y z →  ht G x z := by let func: EdgePath G y z → ht G x z := by intro p ; exact htclass (multiply p₁ p); sorry",
  "name": "homotopy_left_multiplication",
  "kind": "def",
  "first-tactic":
  "let func: EdgePath G y z → ht G x z := by intro p ; exact htclass (multiply p₁ p)",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y) : ht G y z →  ht G x z",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)"},
 {"type":
  "homotopy_left_multiplication p₁ (htclass p₂) = htclass (multiply p₁ p₂)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)  (p₂ : EdgePath G y z) : homotopy_left_multiplication p₁ (htclass p₂) = htclass (multiply p₁ p₂) := by simp[htclass]; sorry",
  "name": "homotopy_left_multiplication_class",
  "kind": "theorem",
  "first-tactic": "simp[htclass]",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)  (p₂ : EdgePath G y z) : homotopy_left_multiplication p₁ (htclass p₂) = htclass (multiply p₁ p₂)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)  (p₂ : EdgePath G y z)"},
 {"type": "homotopy p₁ (reducePath p₁)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ : EdgePath G x y) : homotopy p₁ (reducePath p₁) := by induction p₁; sorry",
  "name": "homotopy_reducePath",
  "kind": "theorem",
  "first-tactic": "induction p₁",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ : EdgePath G x y) : homotopy p₁ (reducePath p₁)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ : EdgePath G x y)"},
 {"type": "(succ n) * (succ m) =\n          succ ((succ n) * m + n)",
  "tactic-prompt":
  "theorem (n m: Nat) : (succ n) * (succ m) =\n          succ ((succ n) * m + n) := by rfl; sorry",
  "name": "mul_succ_succ",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (succ n) * (succ m) =\n          succ ((succ n) * m + n)",
  "args": "(n m: Nat)"},
 {"type": "n * m = 0 → n = 0 ∨ m = 0",
  "tactic-prompt":
  "theorem (n m: Nat) : n * m = 0 → n = 0 ∨ m = 0 := by cases n; sorry",
  "name": "nat_domain",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n m: Nat) : n * m = 0 → n = 0 ∨ m = 0",
  "args": "(n m: Nat)"},
 {"type":
  "(Int.ofNat (succ n)) * (Int.ofNat (succ m)) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "tactic-prompt":
  "theorem (n m: Nat) : (Int.ofNat (succ n)) * (Int.ofNat (succ m)) =\n         Int.ofNat (succ ((succ n) * m + n)) := by rfl; sorry",
  "name": "int_mul_succ_succ",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (Int.ofNat (succ n)) * (Int.ofNat (succ m)) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "args": "(n m: Nat)"},
 {"type":
  "(Int.ofNat (succ n)) * (Int.negSucc m) =\n         Int.negSucc ((succ n) * m + n)",
  "tactic-prompt":
  "theorem (n m: Nat) : (Int.ofNat (succ n)) * (Int.negSucc m) =\n         Int.negSucc ((succ n) * m + n) := by rfl; sorry",
  "name": "int_mul_succ_negsucc",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (Int.ofNat (succ n)) * (Int.negSucc m) =\n         Int.negSucc ((succ n) * m + n)",
  "args": "(n m: Nat)"},
 {"type":
  "(Int.negSucc n) * (Int.negSucc m) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "tactic-prompt":
  "theorem (n m: Nat) : (Int.negSucc n) * (Int.negSucc m) =\n         Int.ofNat (succ ((succ n) * m + n)) := by rfl; sorry",
  "name": "int_mul_negsucc_negsucc",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (Int.negSucc n) * (Int.negSucc m) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "args": "(n m: Nat)"},
 {"type": "n' * m' = 0 → n' = 0 ∨ m' = 0",
  "tactic-prompt":
  "theorem (n' m': Int) : n' * m' = 0 → n' = 0 ∨ m' = 0 := by cases n'; sorry",
  "name": "int_domain",
  "kind": "theorem",
  "first-tactic": "cases n'",
  "core-prompt": "(n' m': Int) : n' * m' = 0 → n' = 0 ∨ m' = 0",
  "args": "(n' m': Int)"},
 {"type": "m • n = m * n",
  "tactic-prompt": "lemma (m n : ℤ) : m • n = m * n := by induction m; sorry",
  "name": "zsmul_int",
  "kind": "lemma",
  "first-tactic": "induction m",
  "core-prompt": "(m n : ℤ) : m • n = m * n",
  "args": "(m n : ℤ)"},
 {"type": "a * b = a * c → b = c",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : a * b = a * c → b = c := by intro h; sorry",
  "name": "Group.mul_left_cancel",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : a * b = a * c → b = c",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "b * a = c * a → b = c",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : b * a = c * a → b = c := by intro h; sorry",
  "name": "Group.mul_right_cancel",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : b * a = c * a → b = c",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "(1 : G)⁻¹ = 1",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} {G : Type _}  [Group G] : (1 : G)⁻¹ = 1 := by have : (1 : G)⁻¹ * 1 = 1 := mul_left_inv 1; sorry",
  "name": "one_inv",
  "kind": "theorem",
  "first-tactic": "have : (1 : G)⁻¹ * 1 = 1 := mul_left_inv 1",
  "core-prompt":
  "{G : Type u}  [Group G]  {a b c : G} {G : Type _}  [Group G] : (1 : G)⁻¹ = 1",
  "args": "{G : Type u}  [Group G]  {a b c : G} {G : Type _}  [Group G]"},
 {"type": "a * b = a ↔ b = 1",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : a * b = a ↔ b = 1 := by apply Iff.intro; sorry",
  "name": "mul_left_eq_cancel",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : a * b = a ↔ b = 1",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "b * a = a ↔ b = 1",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : b * a = a ↔ b = 1 := by apply Iff.intro; sorry",
  "name": "mul_right_eq_cancel",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : b * a = a ↔ b = 1",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "a + b = a ↔ b = 0",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {a b c : A} : a + b = a ↔ b = 0 := by apply Iff.intro; sorry",
  "name": "add_left_eq_cancel",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c : A} : a + b = a ↔ b = 0",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c : A}"},
 {"type": "b + a = a ↔ b = 0",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {a b c : A} : b + a = a ↔ b = 0 := by rw [add_comm]; sorry",
  "name": "add_right_eq_cancel",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c : A} : b + a = a ↔ b = 0",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c : A}"},
 {"type": "ϕ 1 = 1",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] : ϕ 1 = 1 := by have : (ϕ 1) * (ϕ 1) = (ϕ 1) * 1 := by rw [← Homomorphism.mul_distrib]; sorry",
  "name": "one_image",
  "kind": "theorem",
  "first-tactic":
  "have : (ϕ 1) * (ϕ 1) = (ϕ 1) * 1 := by rw [← Homomorphism.mul_distrib]",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] : ϕ 1 = 1",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]"},
 {"type": "(ϕ g)⁻¹ = ϕ g⁻¹",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G} : (ϕ g)⁻¹ = ϕ g⁻¹ := by have : ϕ g * ϕ g⁻¹ = ϕ g * (ϕ g)⁻¹ := by rw [← Homomorphism.mul_distrib]; simp; sorry",
  "name": "hom_inv",
  "kind": "theorem",
  "first-tactic":
  "have : ϕ g * ϕ g⁻¹ = ϕ g * (ϕ g)⁻¹ := by rw [← Homomorphism.mul_distrib]; simp",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G} : (ϕ g)⁻¹ = ϕ g⁻¹",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G}"},
 {"type": "(ϕ g) ^ n = ϕ (g ^ n)",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G}  {n : ℕ} : (ϕ g) ^ n = ϕ (g ^ n) := by induction n; sorry",
  "name": "hom_pow",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G}  {n : ℕ} : (ϕ g) ^ n = ϕ (g ^ n)",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G}  {n : ℕ}"},
 {"type": "SubNegMonoid.zsmul (↑(n) + 1) a = a + SubNegMonoid.zsmul (↑ n) a",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) (n : ℕ) : SubNegMonoid.zsmul (↑(n) + 1) a = a + SubNegMonoid.zsmul (↑ n) a := by rw [← Int.cast_ofNat]; sorry",
  "name": "SubNegMonoid.zsmul_succ'_",
  "kind": "theorem",
  "first-tactic": "rw [← Int.cast_ofNat]",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) (n : ℕ) : SubNegMonoid.zsmul (↑(n) + 1) a = a + SubNegMonoid.zsmul (↑ n) a",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) (n : ℕ)"},
 {"type": "SubNegMonoid.zsmul 1 a = a",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) : SubNegMonoid.zsmul 1 a = a := by rw [← Int.ofNat_one]; sorry",
  "name": "SubNegMonoid.zsmul_one",
  "kind": "theorem",
  "first-tactic": "rw [← Int.ofNat_one]",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) : SubNegMonoid.zsmul 1 a = a",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A)"},
 {"type": "ϕ (0 : A) = (0 : B)",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ϕ (0 : A) = (0 : B) := by have : ϕ 0 + ϕ 0 = ϕ 0 + 0 := by rw [← add_dist]; simp; sorry",
  "name": "zero_image",
  "kind": "theorem",
  "first-tactic": "have : ϕ 0 + ϕ 0 = ϕ 0 + 0 := by rw [← add_dist]; simp",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ϕ (0 : A) = (0 : B)",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "∀ a : A, ϕ (-a) = -ϕ a",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a : A, ϕ (-a) = -ϕ a := by intro a; sorry",
  "name": "neg_push",
  "kind": "theorem",
  "first-tactic": "intro a",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a : A, ϕ (-a) = -ϕ a",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "∀ a a' : A, ϕ (a - a') = ϕ a - ϕ a'",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a a' : A, ϕ (a - a') = ϕ a - ϕ a' := by intros; sorry",
  "name": "neg_dist",
  "kind": "theorem",
  "first-tactic": "intros",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a a' : A, ϕ (a - a') = ϕ a - ϕ a'",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "∀ a : A, ∀ n : ℕ, n • (ϕ a) = ϕ (n • a)",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a : A, ∀ n : ℕ, n • (ϕ a) = ϕ (n • a) := by intro a n; sorry",
  "name": "hom_mul",
  "kind": "theorem",
  "first-tactic": "intro a n",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a : A, ∀ n : ℕ, n • (ϕ a) = ϕ (n • a)",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "∀ a a' : A, -(a + a') = -a + -a'",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a a' : A, -(a + a') = -a + -a' := by intro a a'; sorry",
  "name": "neg_hom",
  "kind": "theorem",
  "first-tactic": "intro a a'",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a a' : A, -(a + a') = -a + -a'",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "AddCommGroup.Isomorphism A A",
  "tactic-prompt":
  "instance {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  (A B C : Type _)  [AddCommGroup A]  [AddCommGroup B]  [AddCommGroup C] [AddCommGroup.Isomorphism A A] : AddCommGroup.Isomorphism A A := by assumption; sorry",
  "name": "reflMorph",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  (A B C : Type _)  [AddCommGroup A]  [AddCommGroup B]  [AddCommGroup C] [AddCommGroup.Isomorphism A A] : AddCommGroup.Isomorphism A A",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  (A B C : Type _)  [AddCommGroup A]  [AddCommGroup B]  [AddCommGroup C] [AddCommGroup.Isomorphism A A]"},
 {"type": "x + x + y - x - y + z - x = z",
  "tactic-prompt":
  "example {x y z : ℤ} : x + x + y - x - y + z - x = z := by have p := freeGroupEq; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq",
  "core-prompt": "{x y z : ℤ} : x + x + y - x - y + z - x = z",
  "args": "{x y z : ℤ}"},
 {"type": "(a + b) - (b - a) - a = a",
  "tactic-prompt":
  "example {A : Type _}  [AddCommGroup A]  {a b : A} : (a + b) - (b - a) - a = a := by have p := freeGroupEq; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b : A} : (a + b) - (b - a) - a = a",
  "args": "{A : Type _}  [AddCommGroup A]  {a b : A}"},
 {"type": "a + b - a - b = b - b + a - a",
  "tactic-prompt":
  "example {a b : ℤ} : a + b - a - b = b - b + a - a := by have pₗ := freeGroupEq; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have pₗ := freeGroupEq",
  "core-prompt": "{a b : ℤ} : a + b - a - b = b - b + a - a",
  "args": "{a b : ℤ}"},
 {"type": "a + b - c - d + e - a + b + c - a - e + a - b + d - b = 0",
  "tactic-prompt":
  "example {A : Type _}  [AddCommGroup A]  {a b c d e : A} : a + b - c - d + e - a + b + c - a - e + a - b + d - b = 0 := by have p := freeGroupEq; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c d e : A} : a + b - c - d + e - a + b + c - a - e + a - b + d - b = 0",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c d e : A}"},
 {"type": "arr.getIdx? a = some i → arr.size > 0",
  "tactic-prompt":
  "lemma {α : Type _}  [DecidableEq α]  {arr : Array α}  {a : α}  {i : ℕ} : arr.getIdx? a = some i → arr.size > 0 := by rw [getIdx?]; sorry",
  "name": "Array.size_pos_if_index",
  "kind": "lemma",
  "first-tactic": "rw [getIdx?]",
  "core-prompt":
  "{α : Type _}  [DecidableEq α]  {arr : Array α}  {a : α}  {i : ℕ} : arr.getIdx? a = some i → arr.size > 0",
  "args": "{α : Type _}  [DecidableEq α]  {arr : Array α}  {a : α}  {i : ℕ}"},
 {"type": "(arr.push a).size > 0",
  "tactic-prompt":
  "lemma {α : Type _}  (arr : Array α)  (a : α) : (arr.push a).size > 0 := by match arr with\n    | ⟨l⟩ =>\n      simp only [push]; sorry",
  "name": "Array.push_size_pos",
  "kind": "lemma",
  "first-tactic": "match arr with\n    | ⟨l⟩ =>\n      simp only [push]",
  "core-prompt":
  "{α : Type _}  (arr : Array α)  (a : α) : (arr.push a).size > 0",
  "args": "{α : Type _}  (arr : Array α)  (a : α)"},
 {"type": "(arr : Array α) → (t.indexTree arr).2.size > 0",
  "tactic-prompt":
  "theorem {α : Type _} [Repr α] [DecidableEq α]  (t: AddTree α) : (arr : Array α) → (t.indexTree arr).2.size > 0 := by induction t; sorry",
  "name": "pos_size",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "{α : Type _} [Repr α] [DecidableEq α]  (t: AddTree α) : (arr : Array α) → (t.indexTree arr).2.size > 0",
  "args": "{α : Type _} [Repr α] [DecidableEq α]  (t: AddTree α)"},
 {"type": "egIndMap x y = x + y + x - y",
  "tactic-prompt":
  "theorem {α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α]     (x y: α) : egIndMap x y = x + y + x - y := by simp; sorry",
  "name": "egIndMapInv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α]     (x y: α) : egIndMap x y = x + y + x - y",
  "args":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α]     (x y: α)"},
 {"type": "egIndMap'' x y = x + y + x - y",
  "tactic-prompt":
  "theorem {α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]     (x y: α) : egIndMap'' x y = x + y + x - y := by simp; sorry",
  "name": "egIndMapInv''",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]     (x y: α) : egIndMap'' x y = x + y + x - y",
  "args":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]     (x y: α)"},
 {"type": "x⁻¹ * (x * y) = y",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x⁻¹ * (x * y) = y := by rw [← mul_assoc]; sorry",
  "name": "left_inv_cancel",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x⁻¹ * (x * y) = y",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "(1 : G)⁻¹ = (1 : G)",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (1 : G)⁻¹ = (1 : G) := by have := left_inv_cancel (1 : G) (1 : G); sorry",
  "name": "one_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (1 : G) (1 : G)",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (1 : G)⁻¹ = (1 : G)",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "(x⁻¹)⁻¹ = x",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x⁻¹)⁻¹ = x := by have := left_inv_cancel (x⁻¹) x; sorry",
  "name": "inv_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (x⁻¹) x",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x⁻¹)⁻¹ = x",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "x * x⁻¹ = 1",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * x⁻¹ = 1 := by have := left_inv_cancel (x⁻¹) (1 : G); sorry",
  "name": "mul_right_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (x⁻¹) (1 : G)",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * x⁻¹ = 1",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "x * (x⁻¹ * y) = y",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * (x⁻¹ * y) = y := by have := left_inv_cancel (x⁻¹) y; sorry",
  "name": "left_cancel_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (x⁻¹) y",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * (x⁻¹ * y) = y",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "(x * y)⁻¹ = y⁻¹ * x⁻¹",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x * y)⁻¹ = y⁻¹ * x⁻¹ := by have := left_cancel_inv (x * y)⁻¹ (y⁻¹ * x⁻¹); sorry",
  "name": "prod_inv",
  "kind": "theorem",
  "first-tactic": "have := left_cancel_inv (x * y)⁻¹ (y⁻¹ * x⁻¹)",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x * y)⁻¹ = y⁻¹ * x⁻¹",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "((a⁻¹ * a) * (b * b⁻¹))⁻¹ = (1 : G)",
  "tactic-prompt":
  "example {G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : ((a⁻¹ * a) * (b * b⁻¹))⁻¹ = (1 : G) := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : ((a⁻¹ * a) * (b * b⁻¹))⁻¹ = (1 : G)",
  "args":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G)"},
 {"type": "b * ((a * b)⁻¹ * a) = 1",
  "tactic-prompt":
  "example {G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : b * ((a * b)⁻¹ * a) = 1 := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : b * ((a * b)⁻¹ * a) = 1",
  "args":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G)"},
 {"type": "a * (c⁻¹ * b) * (((b⁻¹ * c) * b) * (a * b)⁻¹) = (1 : G)",
  "tactic-prompt":
  "example {G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : a * (c⁻¹ * b) * (((b⁻¹ * c) * b) * (a * b)⁻¹) = (1 : G) := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : a * (c⁻¹ * b) * (((b⁻¹ * c) * b) * (a * b)⁻¹) = (1 : G)",
  "args":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G)"},
 {"type":
  "(∀ (A : Type) [AddCommGroup A], ∀ x y z : A, (ν A x y z)) ↔ (ν (ℤ × ℤ × ℤ) (1, 0, 0) (0, 1, 0) (0, 0, 1))",
  "tactic-prompt":
  "theorem  : (∀ (A : Type) [AddCommGroup A], ∀ x y z : A, (ν A x y z)) ↔ (ν (ℤ × ℤ × ℤ) (1, 0, 0) (0, 1, 0) (0, 0, 1)) := by apply Iff.intro; sorry",
  "name": "eqn_iff_free_basis",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  " : (∀ (A : Type) [AddCommGroup A], ∀ x y z : A, (ν A x y z)) ↔ (ν (ℤ × ℤ × ℤ) (1, 0, 0) (0, 1, 0) (0, 0, 1))",
  "args": ""},
 {"type": "∀ l' : List α, List.toArrayAux l {data := l'} = {data := l' ++ l}",
  "tactic-prompt":
  "lemma {α : Type _}  (l : List α) : ∀ l' : List α, List.toArrayAux l {data := l'} = {data := l' ++ l} := by induction l; sorry",
  "name": "List.aux_append",
  "kind": "lemma",
  "first-tactic": "induction l",
  "core-prompt":
  "{α : Type _}  (l : List α) : ∀ l' : List α, List.toArrayAux l {data := l'} = {data := l' ++ l}",
  "args": "{α : Type _}  (l : List α)"},
 {"type": "l.toArray.data = l",
  "tactic-prompt":
  "theorem {A : Type _}  (l : List A) : l.toArray.data = l := by rw [toArray]; sorry",
  "name": "List.arraydata",
  "kind": "theorem",
  "first-tactic": "rw [toArray]",
  "core-prompt": "{A : Type _}  (l : List A) : l.toArray.data = l",
  "args": "{A : Type _}  (l : List A)"},
 {"type": "l.toArray.size = l.length",
  "tactic-prompt":
  "theorem {α : Type _}  (l : List α) : l.toArray.size = l.length := by rw [Array.size]; sorry",
  "name": "List.arraysize",
  "kind": "theorem",
  "first-tactic": "rw [Array.size]",
  "core-prompt": "{α : Type _}  (l : List α) : l.toArray.size = l.length",
  "args": "{α : Type _}  (l : List α)"},
 {"type": "List.length (h :: tl) = Nat.succ m → List.length tl = m",
  "tactic-prompt":
  "theorem  : List.length (h :: tl) = Nat.succ m → List.length tl = m := by intro hyp; sorry",
  "name": "List.cons_len_eq_succ",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt": " : List.length (h :: tl) = Nat.succ m → List.length tl = m",
  "args": ""},
 {"type":
  "IndexAddTree.foldMap t l.toArray (by simp [h, hpos]) =\n                         (inducedFreeMap l h) (IndexAddTree.foldMap t (ℤbasis n).toArray (by simp [hpos]))",
  "tactic-prompt":
  "theorem (t : IndexAddTree) {A : Type _}  [AddCommGroup A]  [Repr A] {n : ℕ}  (l : List A)  (h : l.length = n)  (hpos : n > 0) -- basisImages  -- a few helper results and lemmas : IndexAddTree.foldMap t l.toArray (by simp [h, hpos]) =\n                         (inducedFreeMap l h) (IndexAddTree.foldMap t (ℤbasis n).toArray (by simp [hpos])) := by induction t; sorry",
  "name": "IndexAddTree.fold_tree_freegroup_eq",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "(t : IndexAddTree) {A : Type _}  [AddCommGroup A]  [Repr A] {n : ℕ}  (l : List A)  (h : l.length = n)  (hpos : n > 0) -- basisImages  -- a few helper results and lemmas : IndexAddTree.foldMap t l.toArray (by simp [h, hpos]) =\n                         (inducedFreeMap l h) (IndexAddTree.foldMap t (ℤbasis n).toArray (by simp [hpos]))",
  "args":
  "(t : IndexAddTree) {A : Type _}  [AddCommGroup A]  [Repr A] {n : ℕ}  (l : List A)  (h : l.length = n)  (hpos : n > 0) -- basisImages  -- a few helper results and lemmas"},
 {"type": "s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]  (s₁ s₂ : FormalSum X)  (a: Nat)  (x: X) : s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂ := by intro h; sorry",
  "name": "cons_equiv_of_equiv",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]  (s₁ s₂ : FormalSum X)  (a: Nat)  (x: X) : s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]  (s₁ s₂ : FormalSum X)  (a: Nat)  (x: X)"},
 {"type":
  "monomCoeff x₀ (a + b, x) = monomCoeff x₀ (a, x) + monomCoeff x₀ (b, x)",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x₀ x : X) (a b : Nat) : monomCoeff x₀ (a + b, x) = monomCoeff x₀ (a, x) + monomCoeff x₀ (b, x) := by repeat (rw [monomCoeff]); sorry",
  "name": "monom_coeff_hom",
  "kind": "theorem",
  "first-tactic": "repeat (rw [monomCoeff])",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x₀ x : X) (a b : Nat) : monomCoeff x₀ (a + b, x) = monomCoeff x₀ (a, x) + monomCoeff x₀ (b, x)",
  "args": "(X: Type) [DecidableEq X] (x₀ x : X) (a b : Nat)"},
 {"type": "monomCoeff x₀ (0, x) = 0",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x₀ x : X) : monomCoeff x₀ (0, x) = 0 := by rw [monomCoeff]; sorry",
  "name": "monom_coeff_at_zero",
  "kind": "theorem",
  "first-tactic": "rw [monomCoeff]",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x₀ x : X) : monomCoeff x₀ (0, x) = 0",
  "args": "(X: Type) [DecidableEq X] (x₀ x : X)"},
 {"type": "coeff  x₀  s₁ = coeff  x₀ s₂",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x₀ : X) (s₁ s₂: FormalSum X) (h: BasicRel X s₁ s₂) : coeff  x₀  s₁ = coeff  x₀ s₂ := by induction h; sorry",
  "name": "coeff_move_invariant",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x₀ : X) (s₁ s₂: FormalSum X) (h: BasicRel X s₁ s₂) : coeff  x₀  s₁ = coeff  x₀ s₂",
  "args":
  "(X: Type) [DecidableEq X] (x₀ : X) (s₁ s₂: FormalSum X) (h: BasicRel X s₁ s₂)"},
 {"type": "FreeNatModuleAux.coeff X x (sum s) = coeff x s",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x: X) (s: FormalSum X) : FreeNatModuleAux.coeff X x (sum s) = coeff x s := by simp [FreeNatModuleAux.coeff]; sorry",
  "name": "coeff_factors",
  "kind": "theorem",
  "first-tactic": "simp [FreeNatModuleAux.coeff]",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x: X) (s: FormalSum X) : FreeNatModuleAux.coeff X x (sum s) = coeff x s",
  "args": "(X: Type) [DecidableEq X] (x: X) (s: FormalSum X)"},
 {"type": "s₁ ≃ s₂ → (coeff x s₁) = (coeff x s₂)",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x: X) (s₁ s₂: FormalSum X) : s₁ ≃ s₂ → (coeff x s₁) = (coeff x s₂) := by intro hyp; sorry",
  "name": "coeff_well_defined",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x: X) (s₁ s₂: FormalSum X) : s₁ ≃ s₂ → (coeff x s₁) = (coeff x s₂)",
  "args": "(X: Type) [DecidableEq X] (x: X) (s₁ s₂: FormalSum X)"},
 {"type":
  "0 < s.coeff x₀  → \n          (∃ ys: FormalSum X, \n            (((s.coeff x₀, x₀) :: ys) ≃ s) ∧ \n            (List.length ys < s.length))",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x₀ : X) (s : FormalSum X) : 0 < s.coeff x₀  → \n          (∃ ys: FormalSum X, \n            (((s.coeff x₀, x₀) :: ys) ≃ s) ∧ \n            (List.length ys < s.length)) := by induction s; sorry",
  "name": "pos_coeff_has_complement",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x₀ : X) (s : FormalSum X) : 0 < s.coeff x₀  → \n          (∃ ys: FormalSum X, \n            (((s.coeff x₀, x₀) :: ys) ≃ s) ∧ \n            (List.length ys < s.length))",
  "args": "(X: Type) [DecidableEq X] (x₀ : X) (s : FormalSum X)"},
 {"type": "f = g → equalOnSupport l f g",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]    (l: List X) (f g : X → Nat) : f = g → equalOnSupport l f g := by intro hyp; sorry",
  "name": "equal_on_support_of_equal",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]    (l: List X) (f g : X → Nat) : f = g → equalOnSupport l f g",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]    (l: List X) (f g : X → Nat)"},
 {"type": "eqlCoords X s s",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (s: FormalSum X) : eqlCoords X s s := by rfl; sorry",
  "name": "refl",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (s: FormalSum X) : eqlCoords X s s",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (s: FormalSum X)"},
 {"type": "eqlCoords X s₁ s₂ → eqlCoords X s₂ s₁",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ : FormalSum X} : eqlCoords X s₁ s₂ → eqlCoords X s₂ s₁ := by intro hyp; sorry",
  "name": "symm",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ : FormalSum X} : eqlCoords X s₁ s₂ → eqlCoords X s₂ s₁",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ : FormalSum X}"},
 {"type": "eqlCoords X s₁ s₂ → eqlCoords X s₂ s₃ → eqlCoords X s₁ s₃",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ s₃ : FormalSum X} : eqlCoords X s₁ s₂ → eqlCoords X s₂ s₃ → eqlCoords X s₁ s₃ := by intro hyp₁ hyp₂; sorry",
  "name": "trans",
  "kind": "theorem",
  "first-tactic": "intro hyp₁ hyp₂",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ s₃ : FormalSum X} : eqlCoords X s₁ s₂ → eqlCoords X s₂ s₃ → eqlCoords X s₁ s₃",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ s₃ : FormalSum X}"},
 {"type":
  "(∀ s₁ s₂ : FormalSum X, ∀ mv : BasicRel X s₁ s₂, f s₁ = f s₂) → \n  (∀ s₁ s₂ : FormalSum X, s₁ ≈ s₂ →  f s₁ = f s₂)",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {β : Sort u}    (f : FormalSum X → β) : (∀ s₁ s₂ : FormalSum X, ∀ mv : BasicRel X s₁ s₂, f s₁ = f s₂) → \n  (∀ s₁ s₂ : FormalSum X, s₁ ≈ s₂ →  f s₁ = f s₂) := by intro hyp; sorry",
  "name": "func_eql_of_move_equiv",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {β : Sort u}    (f : FormalSum X → β) : (∀ s₁ s₂ : FormalSum X, ∀ mv : BasicRel X s₁ s₂, f s₁ = f s₂) → \n  (∀ s₁ s₂ : FormalSum X, s₁ ≈ s₂ →  f s₁ = f s₂)",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {β : Sort u}    (f : FormalSum X → β)"},
 {"type": "FreeNatModule X → Nat",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (f₀ : X → Nat) : FreeNatModule X → Nat := by apply Quotient.lift (linear_extension f₀); sorry",
  "name": "miniUniversalProperty",
  "kind": "def",
  "first-tactic": "apply Quotient.lift (linear_extension f₀)",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (f₀ : X → Nat) : FreeNatModule X → Nat",
  "args": "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (f₀ : X → Nat)"},
 {"type": "Bool",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X) : Bool := by apply Quotient.lift₂ (fun (s₁ s₂ : FormalSum X) => \n          decide ( ⟦ s₁ ⟧ = ⟦ s₂ ⟧)); sorry",
  "name": "FreeNatModule.beq?",
  "kind": "def",
  "first-tactic":
  "apply Quotient.lift₂ (fun (s₁ s₂ : FormalSum X) => \n          decide ( ⟦ s₁ ⟧ = ⟦ s₂ ⟧))",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X) : Bool",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X)"},
 {"type": "∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = true → x₁ = x₂",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : ∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = true → x₁ = x₂ := by let f := @Quotient.ind₂ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (x₁ x₂ : FreeNatModule X) =>   x₁.beq? x₂ = true → x₁ = x₂); sorry",
  "name": "FreeNatModule.eq_of_beq_true",
  "kind": "def",
  "first-tactic":
  "let f := @Quotient.ind₂ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (x₁ x₂ : FreeNatModule X) =>   x₁.beq? x₂ = true → x₁ = x₂)",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : ∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = true → x₁ = x₂",
  "args": "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]"},
 {"type": "∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = false → Not (x₁ = x₂)",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : ∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = false → Not (x₁ = x₂) := by let f := @Quotient.ind₂ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (x₁ x₂ : FreeNatModule X) =>   x₁.beq? x₂ = false →\n                Not (x₁ = x₂)); sorry",
  "name": "FreeNatModule.neq_of_beq_false",
  "kind": "def",
  "first-tactic":
  "let f := @Quotient.ind₂ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (x₁ x₂ : FreeNatModule X) =>   x₁.beq? x₂ = false →\n                Not (x₁ = x₂))",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : ∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = false → Not (x₁ = x₂)",
  "args": "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]"},
 {"type": "Decidable (x₁ = x₂)",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X) : Decidable (x₁ = x₂) := by match p:x₁.beq? x₂ with\n    | true => \n      apply Decidable.isTrue\n      apply FreeNatModule.eq_of_beq_true\n      assumption\n    | false => \n      apply Decidable.isFalse\n      apply FreeNatModule.neq_of_beq_false\n      assumption; sorry",
  "name": "FreeNatModule.decEq",
  "kind": "def",
  "first-tactic":
  "match p:x₁.beq? x₂ with\n    | true => \n      apply Decidable.isTrue\n      apply FreeNatModule.eq_of_beq_true\n      assumption\n    | false => \n      apply Decidable.isFalse\n      apply FreeNatModule.neq_of_beq_false\n      assumption",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X) : Decidable (x₁ = x₂)",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X)"},
 {"type": "(EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z) := by intro p q; sorry",
  "name": "multiply",
  "kind": "def",
  "first-tactic": "intro p q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}"},
 {"type": "G.init e = x → (term G (G.bar e) = x)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x) := by intro h; sorry",
  "name": "lemma1",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x : V} {e : E}"},
 {"type": "(multiply (multiply p q) r) = (multiply p (multiply q r))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r)) := by induction p; sorry",
  "name": "mult_assoc",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z)"},
 {"type": "(multiply p (single y)) = p",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p := by induction p; sorry",
  "name": "mult_const",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {p : EdgePath G x y}"},
 {"type": "(homotopy (multiply q p1) (multiply q p2))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2)) := by induction q; sorry",
  "name": "homotopy_left_mult",
  "kind": "theorem",
  "first-tactic": "induction q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2)"},
 {"type": "(inducedFreeMap l h) (ℤbasisElem n k) = l.get ⟨k, h ▸ hk⟩",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {n : ℕ}  (l : List A)  (h : l.length = n)  (k: ℕ)  (hk : k < n) : (inducedFreeMap l h) (ℤbasisElem n k) = l.get ⟨k, h ▸ hk⟩ := by rw [ℤbasisElem]; sorry",
  "name": "induced_free_map_at",
  "kind": "theorem",
  "first-tactic": "rw [ℤbasisElem]",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {n : ℕ}  (l : List A)  (h : l.length = n)  (k: ℕ)  (hk : k < n) : (inducedFreeMap l h) (ℤbasisElem n k) = l.get ⟨k, h ▸ hk⟩",
  "args":
  "{A : Type _}  [AddCommGroup A]  {n : ℕ}  (l : List A)  (h : l.length = n)  (k: ℕ)  (hk : k < n)"},
 {"type": "x + x + y - x - y + z - x = z",
  "tactic-prompt":
  "example {x y z : ℤ} : x + x + y - x - y + z - x = z := by have p := freeGroupEq; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq",
  "core-prompt": "{x y z : ℤ} : x + x + y - x - y + z - x = z",
  "args": "{x y z : ℤ}"},
 {"type": "Graph Unit Bool",
  "tactic-prompt": "example  : Graph Unit Bool := by apply Graph.mk; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply Graph.mk",
  "core-prompt": " : Graph Unit Bool",
  "args": ""},
 {"type": "True",
  "tactic-prompt": "example  : True := by if 1 + 1 = 2 then _ else ?_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "if 1 + 1 = 2 then _ else ?_",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (p : Prop) : True := by if p then ?foo else trivial; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "if p then ?foo else trivial",
  "core-prompt": "(p : Prop) : True",
  "args": "(p : Prop)"},
 {"type": "P",
  "tactic-prompt": "example {P : Prop}  (p : P) : P := by simpa; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simpa",
  "core-prompt": "{P : Prop}  (p : P) : P",
  "args": "{P : Prop}  (p : P)"},
 {"type": "P",
  "tactic-prompt": "example {P : Prop}  (p : P) : P := by simpa using p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simpa using p",
  "core-prompt": "{P : Prop}  (p : P) : P",
  "args": "{P : Prop}  (p : P)"},
 {"type": "foo n = [n]",
  "tactic-prompt":
  "example  : foo n = [n] := by fail_if_success simpa only [foo]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success simpa only [foo]",
  "core-prompt": " : foo n = [n]",
  "args": ""},
 {"type": "p (b + a)",
  "tactic-prompt":
  "example (p : Nat → Prop)  (h : p (a + b)) : p (b + a) := by have : a + b = b + a := Nat.add_comm _ _; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : a + b = b + a := Nat.add_comm _ _",
  "core-prompt": "(p : Nat → Prop)  (h : p (a + b)) : p (b + a)",
  "args": "(p : Nat → Prop)  (h : p (a + b))"},
 {"type": "injective fun a => a / b",
  "tactic-prompt":
  "theorem [Group G] (b : G) : injective fun a => a / b := by simpa only [div_eq_mul_inv] using fun a a' h => mul_left_injective (Inv.inv b) h; sorry",
  "name": "div_left_injective",
  "kind": "theorem",
  "first-tactic":
  "simpa only [div_eq_mul_inv] using fun a a' h => mul_left_injective (Inv.inv b) h",
  "core-prompt": "[Group G] (b : G) : injective fun a => a / b",
  "args": "[Group G] (b : G)"},
 {"type": "Nat × Nat",
  "tactic-prompt":
  "example (n : Nat) : Nat × Nat := by show_term\n    constructor\n    exact n\n    exact 37; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "show_term\n    constructor\n    exact n\n    exact 37",
  "core-prompt": "(n : Nat) : Nat × Nat",
  "args": "(n : Nat)"},
 {"type": "Nat × Nat",
  "tactic-prompt":
  "example (n : Nat) : Nat × Nat := by show_term constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "show_term constructor",
  "core-prompt": "(n : Nat) : Nat × Nat",
  "args": "(n : Nat)"},
 {"type": "P → P",
  "tactic-prompt": "example (P : Prop) : P → P := by by_contra; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra",
  "core-prompt": "(P : Prop) : P → P",
  "args": "(P : Prop)"},
 {"type": "a ∧ (b ∧ c) ↔ b ∧ (a ∧ c)",
  "tactic-prompt":
  "theorem  : a ∧ (b ∧ c) ↔ b ∧ (a ∧ c) := by rw [← and_assoc]; sorry",
  "name": "and_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [← and_assoc]",
  "core-prompt": " : a ∧ (b ∧ c) ↔ b ∧ (a ∧ c)",
  "args": ""},
 {"type": "(a ∧ b) ∧ c ↔ (a ∧ c) ∧ b",
  "tactic-prompt":
  "theorem  : (a ∧ b) ∧ c ↔ (a ∧ c) ∧ b := by simp only [and_left_comm]; sorry",
  "name": "and_right_comm",
  "kind": "theorem",
  "first-tactic": "simp only [and_left_comm]",
  "core-prompt": " : (a ∧ b) ∧ c ↔ (a ∧ c) ∧ b",
  "args": ""},
 {"type": "a ∧ b ∧ c ↔ b ∧ c ∧ a",
  "tactic-prompt":
  "theorem  : a ∧ b ∧ c ↔ b ∧ c ∧ a := by simp only [and_left_comm]; sorry",
  "name": "and_rotate",
  "kind": "theorem",
  "first-tactic": "simp only [and_left_comm]",
  "core-prompt": " : a ∧ b ∧ c ↔ b ∧ c ∧ a",
  "args": ""},
 {"type": "(a ∧ b) ∧ c ∧ d ↔ (a ∧ c) ∧ b ∧ d",
  "tactic-prompt":
  "theorem  : (a ∧ b) ∧ c ∧ d ↔ (a ∧ c) ∧ b ∧ d := by rw [← and_assoc]; sorry",
  "name": "and_and_and_comm",
  "kind": "theorem",
  "first-tactic": "rw [← and_assoc]",
  "core-prompt": " : (a ∧ b) ∧ c ∧ d ↔ (a ∧ c) ∧ b ∧ d",
  "args": ""},
 {"type": "a ∧ b ∧ c ↔ (a ∧ b) ∧ a ∧ c",
  "tactic-prompt":
  "theorem  : a ∧ b ∧ c ↔ (a ∧ b) ∧ a ∧ c := by rw [and_and_and_comm]; sorry",
  "name": "and_and_left",
  "kind": "theorem",
  "first-tactic": "rw [and_and_and_comm]",
  "core-prompt": " : a ∧ b ∧ c ↔ (a ∧ b) ∧ a ∧ c",
  "args": ""},
 {"type": "(a ∧ b) ∧ c ↔ (a ∧ c) ∧ b ∧ c",
  "tactic-prompt":
  "theorem  : (a ∧ b) ∧ c ↔ (a ∧ c) ∧ b ∧ c := by rw [and_and_and_comm]; sorry",
  "name": "and_and_right",
  "kind": "theorem",
  "first-tactic": "rw [and_and_and_comm]",
  "core-prompt": " : (a ∧ b) ∧ c ↔ (a ∧ c) ∧ b ∧ c",
  "args": ""},
 {"type": "(p ↔ p ∧ q) ↔ (p → q)",
  "tactic-prompt":
  "theorem  : (p ↔ p ∧ q) ↔ (p → q) := by rw [@Iff.comm p]; sorry",
  "name": "iff_self_and",
  "kind": "theorem",
  "first-tactic": "rw [@Iff.comm p]",
  "core-prompt": " : (p ↔ p ∧ q) ↔ (p → q)",
  "args": ""},
 {"type": "(p ↔ q ∧ p) ↔ (p → q)",
  "tactic-prompt":
  "theorem  : (p ↔ q ∧ p) ↔ (p → q) := by rw [and_comm]; sorry",
  "name": "iff_and_self",
  "kind": "theorem",
  "first-tactic": "rw [and_comm]",
  "core-prompt": " : (p ↔ q ∧ p) ↔ (p → q)",
  "args": ""},
 {"type": "(a ∧ c ↔ b ∧ c) ↔ c → (a ↔ b)",
  "tactic-prompt":
  "theorem  : (a ∧ c ↔ b ∧ c) ↔ c → (a ↔ b) := by simp only [and_comm]; sorry",
  "name": "and_congr_left_iff",
  "kind": "theorem",
  "first-tactic": "simp only [and_comm]",
  "core-prompt": " : (a ∧ c ↔ b ∧ c) ↔ c → (a ↔ b)",
  "args": ""},
 {"type": "a ∨ (b ∨ c) ↔ b ∨ (a ∨ c)",
  "tactic-prompt":
  "theorem  : a ∨ (b ∨ c) ↔ b ∨ (a ∨ c) := by rw [← or_assoc]; sorry",
  "name": "or_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [← or_assoc]",
  "core-prompt": " : a ∨ (b ∨ c) ↔ b ∨ (a ∨ c)",
  "args": ""},
 {"type": "(a ∨ b) ∨ c ↔ (a ∨ c) ∨ b",
  "tactic-prompt":
  "theorem  : (a ∨ b) ∨ c ↔ (a ∨ c) ∨ b := by rw [or_assoc]; sorry",
  "name": "or_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [or_assoc]",
  "core-prompt": " : (a ∨ b) ∨ c ↔ (a ∨ c) ∨ b",
  "args": ""},
 {"type": "(a ∨ b) ∨ c ∨ d ↔ (a ∨ c) ∨ b ∨ d",
  "tactic-prompt":
  "theorem  : (a ∨ b) ∨ c ∨ d ↔ (a ∨ c) ∨ b ∨ d := by rw [← or_assoc]; sorry",
  "name": "or_or_or_comm",
  "kind": "theorem",
  "first-tactic": "rw [← or_assoc]",
  "core-prompt": " : (a ∨ b) ∨ c ∨ d ↔ (a ∨ c) ∨ b ∨ d",
  "args": ""},
 {"type": "a ∨ b ∨ c ↔ (a ∨ b) ∨ a ∨ c",
  "tactic-prompt":
  "theorem  : a ∨ b ∨ c ↔ (a ∨ b) ∨ a ∨ c := by rw [or_or_or_comm]; sorry",
  "name": "or_or_distrib_left",
  "kind": "theorem",
  "first-tactic": "rw [or_or_or_comm]",
  "core-prompt": " : a ∨ b ∨ c ↔ (a ∨ b) ∨ a ∨ c",
  "args": ""},
 {"type": "(a ∨ b) ∨ c ↔ (a ∨ c) ∨ b ∨ c",
  "tactic-prompt":
  "theorem  : (a ∨ b) ∨ c ↔ (a ∨ c) ∨ b ∨ c := by rw [or_or_or_comm]; sorry",
  "name": "or_or_distrib_right",
  "kind": "theorem",
  "first-tactic": "rw [or_or_or_comm]",
  "core-prompt": " : (a ∨ b) ∨ c ↔ (a ∨ c) ∨ b ∨ c",
  "args": ""},
 {"type": "a ∨ b ∨ c ↔ b ∨ c ∨ a",
  "tactic-prompt":
  "theorem  : a ∨ b ∨ c ↔ b ∨ c ∨ a := by simp only [or_left_comm]; sorry",
  "name": "or_rotate",
  "kind": "theorem",
  "first-tactic": "simp only [or_left_comm]",
  "core-prompt": " : a ∨ b ∨ c ↔ b ∨ c ∨ a",
  "args": ""},
 {"type": "(a ∨ b ↔ b) ↔ (a → b)",
  "tactic-prompt": "theorem  : (a ∨ b ↔ b) ↔ (a → b) := by rw [or_comm]; sorry",
  "name": "or_iff_right_iff_imp",
  "kind": "theorem",
  "first-tactic": "rw [or_comm]",
  "core-prompt": " : (a ∨ b ↔ b) ↔ (a → b)",
  "args": ""},
 {"type": "(a ∨ b) ∧ c ↔ (a ∧ c) ∨ (b ∧ c)",
  "tactic-prompt":
  "theorem  : (a ∨ b) ∧ c ↔ (a ∧ c) ∨ (b ∧ c) := by simp [and_comm]; sorry",
  "name": "or_and_right",
  "kind": "theorem",
  "first-tactic": "simp [and_comm]",
  "core-prompt": " : (a ∨ b) ∧ c ↔ (a ∧ c) ∨ (b ∧ c)",
  "args": ""},
 {"type": "(a ∧ b) ∨ c ↔ (a ∨ c) ∧ (b ∨ c)",
  "tactic-prompt":
  "theorem  : (a ∧ b) ∨ c ↔ (a ∨ c) ∧ (b ∨ c) := by simp [or_comm]; sorry",
  "name": "and_or_right",
  "kind": "theorem",
  "first-tactic": "simp [or_comm]",
  "core-prompt": " : (a ∧ b) ∨ c ↔ (a ∨ c) ∧ (b ∨ c)",
  "args": ""},
 {"type": "(∀ a, a' = a → p a) ↔ p a'",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {a' : α} : (∀ a, a' = a → p a) ↔ p a' := by simp [@eq_comm _ a']; sorry",
  "name": "forall_eq'",
  "kind": "theorem",
  "first-tactic": "simp [@eq_comm _ a']",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {a' : α} : (∀ a, a' = a → p a) ↔ p a'",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {a' : α}"},
 {"type": "(∃ x, p x ∧ b) ↔ (∃ x, p x) ∧ b",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ x, p x ∧ b) ↔ (∃ x, p x) ∧ b := by simp [And.comm]; sorry",
  "name": "exists_and_right",
  "kind": "theorem",
  "first-tactic": "simp [And.comm]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ x, p x ∧ b) ↔ (∃ x, p x) ∧ b",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _}"},
 {"type": "(∃ a, a' = a ∧ p a) ↔ p a'",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ a, a' = a ∧ p a) ↔ p a' := by simp [@eq_comm _ a']; sorry",
  "name": "exists_eq_left'",
  "kind": "theorem",
  "first-tactic": "simp [@eq_comm _ a']",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ a, a' = a ∧ p a) ↔ p a'",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _}"},
 {"type": "(∀ a, a = a' ∨ q a → p a) ↔ p a' ∧ ∀ a, q a → p a",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∀ a, a = a' ∨ q a → p a) ↔ p a' ∧ ∀ a, q a → p a := by simp only [or_imp]; sorry",
  "name": "forall_eq_or_imp",
  "kind": "theorem",
  "first-tactic": "simp only [or_imp]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∀ a, a = a' ∨ q a → p a) ↔ p a' ∧ ∀ a, q a → p a",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _}"},
 {"type": "(∃ a, (a = a' ∨ q a) ∧ p a) ↔ p a' ∨ ∃ a, q a ∧ p a",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ a, (a = a' ∨ q a) ∧ p a) ↔ p a' ∨ ∃ a, q a ∧ p a := by simp only [or_and_right]; sorry",
  "name": "exists_eq_or_imp",
  "kind": "theorem",
  "first-tactic": "simp only [or_and_right]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ a, (a = a' ∨ q a) ∧ p a) ↔ p a' ∨ ∃ a, q a ∧ p a",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _}"},
 {"type": "(∃ (a : α), p a ∧ b ∧ a = a') ↔ p a' ∧ b",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ (a : α), p a ∧ b ∧ a = a') ↔ p a' ∧ b := by simp [← and_assoc]; sorry",
  "name": "exists_eq_right_right",
  "kind": "theorem",
  "first-tactic": "simp [← and_assoc]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ (a : α), p a ∧ b ∧ a = a') ↔ p a' ∧ b",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _}"},
 {"type": "(∃ (a : α), p a ∧ b ∧ a' = a) ↔ p a' ∧ b",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ (a : α), p a ∧ b ∧ a' = a) ↔ p a' ∧ b := by (conv in _=_ => rw [eq_comm]); sorry",
  "name": "exists_eq_right_right'",
  "kind": "theorem",
  "first-tactic": "(conv in _=_ => rw [eq_comm])",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} : (∃ (a : α), p a ∧ b ∧ a' = a) ↔ p a' ∧ b",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _}"},
 {"type": "(decide p = true) ↔ p",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (p : Prop)  [Decidable p] : (decide p = true) ↔ p := by simp; sorry",
  "name": "decide_eq_true_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (p : Prop)  [Decidable p] : (decide p = true) ↔ p",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (p : Prop)  [Decidable p]"},
 {"type": "(¬a → a) ↔ a",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a] : (¬a → a) ↔ a := by have := @imp_not_self (¬a); sorry",
  "name": "Decidable.not_imp_self",
  "kind": "theorem",
  "first-tactic": "have := @imp_not_self (¬a)",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a] : (¬a → a) ↔ a",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]"},
 {"type": "(a → b ∨ c) ↔ (a → b) ∨ (a → c)",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a] : (a → b ∨ c) ↔ (a → b) ∨ (a → c) := by by_cases a; sorry",
  "name": "Decidable.imp_or",
  "kind": "theorem",
  "first-tactic": "by_cases a",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a] : (a → b ∨ c) ↔ (a → b) ∨ (a → c)",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]"},
 {"type": "(¬a ↔ ¬b) ↔ (a ↔ b)",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : (¬a ↔ ¬b) ↔ (a ↔ b) := by rw [@iff_def (¬a)]; sorry",
  "name": "Decidable.not_iff_not",
  "kind": "theorem",
  "first-tactic": "rw [@iff_def (¬a)]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : (¬a ↔ ¬b) ↔ (a ↔ b)",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b]"},
 {"type": "(¬a ↔ b) ↔ (¬b ↔ a)",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : (¬a ↔ b) ↔ (¬b ↔ a) := by rw [@iff_def (¬a)]; sorry",
  "name": "Decidable.not_iff_comm",
  "kind": "theorem",
  "first-tactic": "rw [@iff_def (¬a)]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : (¬a ↔ b) ↔ (¬b ↔ a)",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b]"},
 {"type": "¬(a ↔ b) ↔ (¬a ↔ b)",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable b] : ¬(a ↔ b) ↔ (¬a ↔ b) := by by_cases h : b; sorry",
  "name": "Decidable.not_iff",
  "kind": "theorem",
  "first-tactic": "by_cases h : b",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable b] : ¬(a ↔ b) ↔ (¬a ↔ b)",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable b]"},
 {"type": "(a ↔ ¬b) ↔ (b ↔ ¬a)",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : (a ↔ ¬b) ↔ (b ↔ ¬a) := by rw [@iff_def a]; sorry",
  "name": "Decidable.iff_not_comm",
  "kind": "theorem",
  "first-tactic": "rw [@iff_def a]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : (a ↔ ¬b) ↔ (b ↔ ¬a)",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b]"},
 {"type": "(a ↔ b) ↔ (¬a ∨ b) ∧ (a ∨ ¬b)",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : (a ↔ b) ↔ (¬a ∨ b) ∧ (a ∨ ¬b) := by rw [iff_iff_implies_and_implies a b]; sorry",
  "name": "Decidable.iff_iff_not_or_and_or_not",
  "kind": "theorem",
  "first-tactic": "rw [iff_iff_implies_and_implies a b]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : (a ↔ b) ↔ (¬a ∨ b) ∧ (a ∨ ¬b)",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b]"},
 {"type": "a ∨ b ↔ ¬(¬a ∧ ¬b)",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : a ∨ b ↔ ¬(¬a ∧ ¬b) := by rw [← not_or]; sorry",
  "name": "Decidable.or_iff_not_and_not",
  "kind": "theorem",
  "first-tactic": "rw [← not_or]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : a ∨ b ↔ ¬(¬a ∧ ¬b)",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b]"},
 {"type": "a ∧ b ↔ ¬(¬a ∨ ¬b)",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : a ∧ b ↔ ¬(¬a ∨ ¬b) := by rw [← not_and]; sorry",
  "name": "Decidable.and_iff_not_or_not",
  "kind": "theorem",
  "first-tactic": "rw [← not_and]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b] : a ∧ b ↔ ¬(¬a ∨ ¬b)",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  [Decidable b]"},
 {"type": "a ∨ c ↔ b ∨ c",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable c]  (h : ¬c → (a ↔ b)) : a ∨ c ↔ b ∨ c := by rw [or_iff_not_imp_right]; sorry",
  "name": "Decidable.or_congr_left'",
  "kind": "theorem",
  "first-tactic": "rw [or_iff_not_imp_right]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable c]  (h : ¬c → (a ↔ b)) : a ∨ c ↔ b ∨ c",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable c]  (h : ¬c → (a ↔ b))"},
 {"type": "a ∨ b ↔ a ∨ c",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  (h : ¬a → (b ↔ c)) : a ∨ b ↔ a ∨ c := by rw [or_iff_not_imp_left]; sorry",
  "name": "Decidable.or_congr_right'",
  "kind": "theorem",
  "first-tactic": "rw [or_iff_not_imp_left]",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  (h : ¬a → (b ↔ c)) : a ∨ b ↔ a ∨ c",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} [Decidable a]  (h : ¬a → (b ↔ c))"},
 {"type": "HEq hp hq",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {p q : Prop}  (hp : p)  (hq : q) : HEq hp hq := by cases propext (iff_of_true hp hq); sorry",
  "name": "proof_irrel_heq",
  "kind": "theorem",
  "first-tactic": "cases propext (iff_of_true hp hq)",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {p q : Prop}  (hp : p)  (hq : q) : HEq hp hq",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {p q : Prop}  (hp : p)  (hq : q)"},
 {"type": "(@Eq.rec α a (fun α _ => β) y a' h) = y",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {α : Sort _}  {a a' : α}  {β : Sort _}  (y : β)  (h : a = a') : (@Eq.rec α a (fun α _ => β) y a' h) = y := by cases h; sorry",
  "name": "eq_rec_constant",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {α : Sort _}  {a a' : α}  {β : Sort _}  (y : β)  (h : a = a') : (@Eq.rec α a (fun α _ => β) y a' h) = y",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} {α : Sort _}  {a a' : α}  {β : Sort _}  (y : β)  (h : a = a')"},
 {"type": "f x y = f x' y'",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (f : α → β → γ)  {x x' : α}  {y y' : β}      (hx : x = x')  (hy : y = y') : f x y = f x' y' := by subst hx hy; sorry",
  "name": "congrArg₂",
  "kind": "theorem",
  "first-tactic": "subst hx hy",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (f : α → β → γ)  {x x' : α}  {y y' : β}      (hx : x = x')  (hy : y = y') : f x y = f x' y'",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (f : α → β → γ)  {x x' : α}  {y y' : β}      (hx : x = x')  (hy : y = y')"},
 {"type": "f (dite P x y) = dite P (fun h => f (x h)) (fun h => f (y h))",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (f : α → β)  (P : Prop)  [Decidable P]  (x : P → α)  (y : ¬P → α) : f (dite P x y) = dite P (fun h => f (x h)) (fun h => f (y h)) := by by_cases h : P; sorry",
  "name": "apply_dite",
  "kind": "theorem",
  "first-tactic": "by_cases h : P",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (f : α → β)  (P : Prop)  [Decidable P]  (x : P → α)  (y : ¬P → α) : f (dite P x y) = dite P (fun h => f (x h)) (fun h => f (y h))",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (f : α → β)  (P : Prop)  [Decidable P]  (x : P → α)  (y : ¬P → α)"},
 {"type": "dite (¬P) x y = dite P (fun h => y (not_not_intro h)) x",
  "tactic-prompt":
  "theorem {p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (P : Prop)  [Decidable P]   (x : ¬P → α)  (y : ¬¬P → α) : dite (¬P) x y = dite P (fun h => y (not_not_intro h)) x := by by_cases h : P; sorry",
  "name": "dite_not",
  "kind": "theorem",
  "first-tactic": "by_cases h : P",
  "core-prompt":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (P : Prop)  [Decidable P]   (x : ¬P → α)  (y : ¬¬P → α) : dite (¬P) x y = dite P (fun h => y (not_not_intro h)) x",
  "args":
  "{p q : α → Prop}  {b : Prop}  {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _} {ε : ∀ a b c, δ a b c → Sort _} (P : Prop)  [Decidable P]   (x : ¬P → α)  (y : ¬¬P → α)"},
 {"type": "(a == b) = false ↔ a ≠ b",
  "tactic-prompt":
  "theorem [BEq α]  [LawfulBEq α]      (a b : α) : (a == b) = false ↔ a ≠ b := by rw [ne_eq]; sorry",
  "name": "beq_eq_false_iff_ne",
  "kind": "theorem",
  "first-tactic": "rw [ne_eq]",
  "core-prompt":
  "[BEq α]  [LawfulBEq α]      (a b : α) : (a == b) = false ↔ a ≠ b",
  "args": "[BEq α]  [LawfulBEq α]      (a b : α)"},
 {"type": "SatisfiesM q (f <$> x)",
  "tactic-prompt":
  "theorem [Functor m]  [LawfulFunctor m]  {x : m α}      (hx : SatisfiesM p x)  (hf : ∀ {a}, p a → q (f a)) : SatisfiesM q (f <$> x) := by let ⟨x', hx⟩ := hx; sorry",
  "name": "map",
  "kind": "theorem",
  "first-tactic": "let ⟨x', hx⟩ := hx",
  "core-prompt":
  "[Functor m]  [LawfulFunctor m]  {x : m α}      (hx : SatisfiesM p x)  (hf : ∀ {a}, p a → q (f a)) : SatisfiesM q (f <$> x)",
  "args":
  "[Functor m]  [LawfulFunctor m]  {x : m α}      (hx : SatisfiesM p x)  (hf : ∀ {a}, p a → q (f a))"},
 {"type": "SatisfiesM q (f <*> x)",
  "tactic-prompt":
  "theorem [Applicative m]  [LawfulApplicative m]  {x : m α}      (hf : SatisfiesM p₁ f)  (hx : SatisfiesM p₂ x)      (H : ∀ {f a}, p₁ f → p₂ a → q (f a)) : SatisfiesM q (f <*> x) := by match f, x, hf, hx with | _, _, ⟨f, rfl⟩, ⟨x, rfl⟩ => ?_; sorry",
  "name": "seq",
  "kind": "theorem",
  "first-tactic": "match f, x, hf, hx with | _, _, ⟨f, rfl⟩, ⟨x, rfl⟩ => ?_",
  "core-prompt":
  "[Applicative m]  [LawfulApplicative m]  {x : m α}      (hf : SatisfiesM p₁ f)  (hx : SatisfiesM p₂ x)      (H : ∀ {f a}, p₁ f → p₂ a → q (f a)) : SatisfiesM q (f <*> x)",
  "args":
  "[Applicative m]  [LawfulApplicative m]  {x : m α}      (hf : SatisfiesM p₁ f)  (hx : SatisfiesM p₂ x)      (H : ∀ {f a}, p₁ f → p₂ a → q (f a))"},
 {"type": "SatisfiesM q (x >>= f)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  {f : α → m β}      (hx : SatisfiesM p x)  (hf : ∀ a, p a → SatisfiesM q (f a)) : SatisfiesM q (x >>= f) := by match x, hx with | _, ⟨x, rfl⟩ => ?_; sorry",
  "name": "bind",
  "kind": "theorem",
  "first-tactic": "match x, hx with | _, ⟨x, rfl⟩ => ?_",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  {f : α → m β}      (hx : SatisfiesM p x)  (hf : ∀ a, p a → SatisfiesM q (f a)) : SatisfiesM q (x >>= f)",
  "args":
  "[Monad m]  [LawfulMonad m]  {f : α → m β}      (hx : SatisfiesM p x)  (hf : ∀ a, p a → SatisfiesM q (f a))"},
 {"type": "SatisfiesM (m := StateRefT' ω σ m) p x ↔ ∀ s, SatisfiesM p (x s)",
  "tactic-prompt":
  "theorem [Monad m] : SatisfiesM (m := StateRefT' ω σ m) p x ↔ ∀ s, SatisfiesM p (x s) := by simp; sorry",
  "name": "SatisfiesM_StateRefT_eq",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "[Monad m] : SatisfiesM (m := StateRefT' ω σ m) p x ↔ ∀ s, SatisfiesM p (x s)",
  "args": "[Monad m]"},
 {"type":
  "SatisfiesM (m := StateT ρ m) (α := α) p x ↔ ∀ s, SatisfiesM (m := m) (p ·.1) (x s)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m] : SatisfiesM (m := StateT ρ m) (α := α) p x ↔ ∀ s, SatisfiesM (m := m) (p ·.1) (x s) := by refine .trans ⟨fun ⟨f, eq⟩ => eq ▸ ?_, fun ⟨f, h⟩ => ?_⟩ Classical.skolem.symm; sorry",
  "name": "SatisfiesM_StateT_eq",
  "kind": "theorem",
  "first-tactic":
  "refine .trans ⟨fun ⟨f, eq⟩ => eq ▸ ?_, fun ⟨f, h⟩ => ?_⟩ Classical.skolem.symm",
  "core-prompt":
  "[Monad m]  [LawfulMonad m] : SatisfiesM (m := StateT ρ m) (α := α) p x ↔ ∀ s, SatisfiesM (m := m) (p ·.1) (x s)",
  "args": "[Monad m]  [LawfulMonad m]"},
 {"type":
  "SatisfiesM (m := ExceptT ρ m) (α := α) p x ↔ SatisfiesM (m := m) (∀ a, · = .ok a → p a) x",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m] : SatisfiesM (m := ExceptT ρ m) (α := α) p x ↔ SatisfiesM (m := m) (∀ a, · = .ok a → p a) x := by refine ⟨fun ⟨f, eq⟩ => eq ▸ ?_, fun ⟨f, eq⟩ => eq ▸ ?_⟩; sorry",
  "name": "SatisfiesM_ExceptT_eq",
  "kind": "theorem",
  "first-tactic": "refine ⟨fun ⟨f, eq⟩ => eq ▸ ?_, fun ⟨f, eq⟩ => eq ▸ ?_⟩",
  "core-prompt":
  "[Monad m]  [LawfulMonad m] : SatisfiesM (m := ExceptT ρ m) (α := α) p x ↔ SatisfiesM (m := m) (∀ a, · = .ok a → p a) x",
  "args": "[Monad m]  [LawfulMonad m]"},
 {"type": "o.swap.swap = o",
  "tactic-prompt":
  "theorem {o : Ordering} : o.swap.swap = o := by cases o; sorry",
  "name": "Ordering.swap_swap",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": "{o : Ordering} : o.swap.swap = o",
  "args": "{o : Ordering}"},
 {"type": "cmp x y = .gt ↔ cmp y x = .lt",
  "tactic-prompt":
  "theorem [OrientedCmp cmp] : cmp x y = .gt ↔ cmp y x = .lt := by rw [← Ordering.swap_inj]; sorry",
  "name": "cmp_eq_gt",
  "kind": "theorem",
  "first-tactic": "rw [← Ordering.swap_inj]",
  "core-prompt": "[OrientedCmp cmp] : cmp x y = .gt ↔ cmp y x = .lt",
  "args": "[OrientedCmp cmp]"},
 {"type": "cmp x y = .eq ↔ cmp y x = .eq",
  "tactic-prompt":
  "theorem [OrientedCmp cmp] : cmp x y = .eq ↔ cmp y x = .eq := by rw [← Ordering.swap_inj]; sorry",
  "name": "cmp_eq_eq_symm",
  "kind": "theorem",
  "first-tactic": "rw [← Ordering.swap_inj]",
  "core-prompt": "[OrientedCmp cmp] : cmp x y = .eq ↔ cmp y x = .eq",
  "args": "[OrientedCmp cmp]"},
 {"type": "cmp x z ≠ .lt",
  "tactic-prompt":
  "theorem [TransCmp cmp] (h₁ : cmp x y ≠ .lt)  (h₂ : cmp y z ≠ .lt) : cmp x z ≠ .lt := by have := @TransCmp.le_trans _ cmp _ z y x; sorry",
  "name": "ge_trans",
  "kind": "theorem",
  "first-tactic": "have := @TransCmp.le_trans _ cmp _ z y x",
  "core-prompt":
  "[TransCmp cmp] (h₁ : cmp x y ≠ .lt)  (h₂ : cmp y z ≠ .lt) : cmp x z ≠ .lt",
  "args": "[TransCmp cmp] (h₁ : cmp x y ≠ .lt)  (h₂ : cmp y z ≠ .lt)"},
 {"type": "cmp x z = .gt",
  "tactic-prompt":
  "theorem [TransCmp cmp] (h₁ : cmp x y = .gt)  (h₂ : cmp y z = .gt) : cmp x z = .gt := by rw [cmp_eq_gt] at h₁ h₂ ⊢; sorry",
  "name": "gt_trans",
  "kind": "theorem",
  "first-tactic": "rw [cmp_eq_gt] at h₁ h₂ ⊢",
  "core-prompt":
  "[TransCmp cmp] (h₁ : cmp x y = .gt)  (h₂ : cmp y z = .gt) : cmp x z = .gt",
  "args": "[TransCmp cmp] (h₁ : cmp x y = .gt)  (h₂ : cmp y z = .gt)"},
 {"type": "cmp x y = cmp x z",
  "tactic-prompt":
  "theorem [TransCmp cmp] [TransCmp cmp]  (yz : cmp y z = .eq) : cmp x y = cmp x z := by rw [← Ordering.swap_inj]; sorry",
  "name": "cmp_congr_right",
  "kind": "theorem",
  "first-tactic": "rw [← Ordering.swap_inj]",
  "core-prompt":
  "[TransCmp cmp] [TransCmp cmp]  (yz : cmp y z = .eq) : cmp x y = cmp x z",
  "args": "[TransCmp cmp] [TransCmp cmp]  (yz : cmp y z = .eq)"},
 {"type": "WF (empty n : Imp α β)",
  "tactic-prompt":
  "theorem [BEq α]  [Hashable α] : WF (empty n : Imp α β) := by unfold empty; sorry",
  "name": "WF.empty",
  "kind": "theorem",
  "first-tactic": "unfold empty",
  "core-prompt": "[BEq α]  [Hashable α] : WF (empty n : Imp α β)",
  "args": "[BEq α]  [Hashable α]"},
 {"type": "(reinsertAux data a b).size = data.size.succ",
  "tactic-prompt":
  "theorem [Hashable α]  (data : Bucket α β)  (a : α)  (b : β) : (reinsertAux data a b).size = data.size.succ := by simp [Bucket.size_eq]; sorry",
  "name": "reinsertAux_size",
  "kind": "theorem",
  "first-tactic": "simp [Bucket.size_eq]",
  "core-prompt":
  "[Hashable α]  (data : Bucket α β)  (a : α)  (b : β) : (reinsertAux data a b).size = data.size.succ",
  "args": "[Hashable α]  (data : Bucket α β)  (a : α)  (b : β)"},
 {"type": "(expand sz buckets).buckets.size = buckets.size",
  "tactic-prompt":
  "theorem [Hashable α]  {buckets : Bucket α β} : (expand sz buckets).buckets.size = buckets.size := by rw [expand]; sorry",
  "name": "expand_size",
  "kind": "theorem",
  "first-tactic": "rw [expand]",
  "core-prompt":
  "[Hashable α]  {buckets : Bucket α β} : (expand sz buckets).buckets.size = buckets.size",
  "args": "[Hashable α]  {buckets : Bucket α β}"},
 {"type":
  "(l.foldl (fun d x => reinsertAux d x.1 x.2) target).WF ∧\n    ∀ bucket ∈ (l.foldl (fun d x => reinsertAux d x.1 x.2) target).1.data,\n      bucket.All fun k _ => rank k ≤ i",
  "tactic-prompt":
  "theorem [BEq α]  [Hashable α]  (rank : α → Nat)  {l : List (α × β)}  {i : Nat}      (hl₁ : ∀ [PartialEquivBEq α] [LawfulHashable α], l.Pairwise fun a b => ¬(a.1 == b.1))      (hl₂ : ∀ x ∈ l, rank x.1 = i)      {target : Bucket α β}  (ht₁ : target.WF)      (ht₂ : ∀ bucket ∈ target.1.data,       bucket.All fun k _ => rank k ≤ i ∧         ∀ [PartialEquivBEq α] [LawfulHashable α], ∀ x ∈ l, ¬(x.1 == k)) : (l.foldl (fun d x => reinsertAux d x.1 x.2) target).WF ∧\n    ∀ bucket ∈ (l.foldl (fun d x => reinsertAux d x.1 x.2) target).1.data,\n      bucket.All fun k _ => rank k ≤ i := by induction l generalizing target with\n  | nil => exact ⟨ht₁, fun _ h₁ _ h₂ => (ht₂ _ h₁ _ h₂).1⟩\n  | cons _ _ ih =>\n    simp at hl₁ hl₂ ht₂\n    refine ih hl₁.2 hl₂.2\n      (reinsertAux_WF ht₁ fun _ h => (ht₂ _ (Array.getElem_mem_data ..) _ h).2.1)\n      (fun _ h => ?_)\n    simp [reinsertAux, Bucket.update] at h\n    match List.mem_or_eq_of_mem_set h with\n    | .inl h =>\n      intro _ hf\n      have ⟨h₁, h₂⟩ := ht₂ _ h _ hf\n      exact ⟨h₁, h₂.2⟩\n    | .inr h => subst h; intro\n      | _, .head .. =>\n        exact ⟨hl₂.1 ▸ Nat.le_refl _, fun _ h h' => hl₁.1 _ h (PartialEquivBEq.symm h')⟩\n      | _, .tail _ h =>\n        have ⟨h₁, h₂⟩ := ht₂ _ (Array.getElem_mem_data ..) _ h\n        exact ⟨h₁, h₂.2⟩; sorry",
  "name": "expand_WF.foldl",
  "kind": "theorem",
  "first-tactic":
  "induction l generalizing target with\n  | nil => exact ⟨ht₁, fun _ h₁ _ h₂ => (ht₂ _ h₁ _ h₂).1⟩\n  | cons _ _ ih =>\n    simp at hl₁ hl₂ ht₂\n    refine ih hl₁.2 hl₂.2\n      (reinsertAux_WF ht₁ fun _ h => (ht₂ _ (Array.getElem_mem_data ..) _ h).2.1)\n      (fun _ h => ?_)\n    simp [reinsertAux, Bucket.update] at h\n    match List.mem_or_eq_of_mem_set h with\n    | .inl h =>\n      intro _ hf\n      have ⟨h₁, h₂⟩ := ht₂ _ h _ hf\n      exact ⟨h₁, h₂.2⟩\n    | .inr h => subst h; intro\n      | _, .head .. =>\n        exact ⟨hl₂.1 ▸ Nat.le_refl _, fun _ h h' => hl₁.1 _ h (PartialEquivBEq.symm h')⟩\n      | _, .tail _ h =>\n        have ⟨h₁, h₂⟩ := ht₂ _ (Array.getElem_mem_data ..) _ h\n        exact ⟨h₁, h₂.2⟩",
  "core-prompt":
  "[BEq α]  [Hashable α]  (rank : α → Nat)  {l : List (α × β)}  {i : Nat}      (hl₁ : ∀ [PartialEquivBEq α] [LawfulHashable α], l.Pairwise fun a b => ¬(a.1 == b.1))      (hl₂ : ∀ x ∈ l, rank x.1 = i)      {target : Bucket α β}  (ht₁ : target.WF)      (ht₂ : ∀ bucket ∈ target.1.data,       bucket.All fun k _ => rank k ≤ i ∧         ∀ [PartialEquivBEq α] [LawfulHashable α], ∀ x ∈ l, ¬(x.1 == k)) : (l.foldl (fun d x => reinsertAux d x.1 x.2) target).WF ∧\n    ∀ bucket ∈ (l.foldl (fun d x => reinsertAux d x.1 x.2) target).1.data,\n      bucket.All fun k _ => rank k ≤ i",
  "args":
  "[BEq α]  [Hashable α]  (rank : α → Nat)  {l : List (α × β)}  {i : Nat}      (hl₁ : ∀ [PartialEquivBEq α] [LawfulHashable α], l.Pairwise fun a b => ¬(a.1 == b.1))      (hl₂ : ∀ x ∈ l, rank x.1 = i)      {target : Bucket α β}  (ht₁ : target.WF)      (ht₂ : ∀ bucket ∈ target.1.data,       bucket.All fun k _ => rank k ≤ i ∧         ∀ [PartialEquivBEq α] [LawfulHashable α], ∀ x ∈ l, ¬(x.1 == k))"},
 {"type":
  "x ∈ (l.replaceF fun a => bif p a then some (k, v) else none) → x.1 = k ∨ x ∈ l",
  "tactic-prompt":
  "theorem {l : List (α × β)}  {x : α × β}  {p : α × β → Bool} : x ∈ (l.replaceF fun a => bif p a then some (k, v) else none) → x.1 = k ∨ x ∈ l := by induction l; sorry",
  "name": "mem_replaceF",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{l : List (α × β)}  {x : α × β}  {p : α × β → Bool} : x ∈ (l.replaceF fun a => bif p a then some (k, v) else none) → x.1 = k ∨ x ∈ l",
  "args": "{l : List (α × β)}  {x : α × β}  {p : α × β → Bool}"},
 {"type":
  "(l.replaceF fun a => bif a.fst == k then some (k, v) else none)\n      |>.Pairwise fun a b => ¬(a.fst == b.fst)",
  "tactic-prompt":
  "theorem [BEq α]  [PartialEquivBEq α]      {l : List (α × β)}  {x : α × β}  (hx₁ : x ∈ l)  (hx₂ : x.fst == k)      (H : l.Pairwise fun a b => ¬(a.fst == b.fst)) : (l.replaceF fun a => bif a.fst == k then some (k, v) else none)\n      |>.Pairwise fun a b => ¬(a.fst == b.fst) := by induction hx₁; sorry",
  "name": "pairwise_replaceF",
  "kind": "theorem",
  "first-tactic": "induction hx₁",
  "core-prompt":
  "[BEq α]  [PartialEquivBEq α]      {l : List (α × β)}  {x : α × β}  (hx₁ : x ∈ l)  (hx₂ : x.fst == k)      (H : l.Pairwise fun a b => ¬(a.fst == b.fst)) : (l.replaceF fun a => bif a.fst == k then some (k, v) else none)\n      |>.Pairwise fun a b => ¬(a.fst == b.fst)",
  "args":
  "[BEq α]  [PartialEquivBEq α]      {l : List (α × β)}  {x : α × β}  (hx₁ : x ∈ l)  (hx₂ : x.fst == k)      (H : l.Pairwise fun a b => ¬(a.fst == b.fst))"},
 {"type": "m.size = m.buckets.size ∧ m.buckets.WF",
  "tactic-prompt":
  "theorem [BEq α]  [Hashable α]  {m : Imp α β}  (h : m.WF) : m.size = m.buckets.size ∧ m.buckets.WF := by induction h; sorry",
  "name": "WF.out",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "[BEq α]  [Hashable α]  {m : Imp α β}  (h : m.WF) : m.size = m.buckets.size ∧ m.buckets.WF",
  "args": "[BEq α]  [Hashable α]  {m : Imp α β}  (h : m.WF)"},
 {"type": "s.realSize = s'.realSize + 1",
  "tactic-prompt":
  "theorem {s : Heap α}  (eq : s.deleteMin le = some (a, s')) : s.realSize = s'.realSize + 1 := by cases s; sorry",
  "name": "Heap.realSize_deleteMin",
  "kind": "theorem",
  "first-tactic": "cases s",
  "core-prompt":
  "{s : Heap α}  (eq : s.deleteMin le = some (a, s')) : s.realSize = s'.realSize + 1",
  "args": "{s : Heap α}  (eq : s.deleteMin le = some (a, s'))"},
 {"type": "s.tail? le = some s' →\n    s.realSize = s'.realSize + 1",
  "tactic-prompt":
  "theorem {s : Heap α} : s.tail? le = some s' →\n    s.realSize = s'.realSize + 1 := by simp only [Heap.tail?]; sorry",
  "name": "Heap.realSize_tail?",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail?]",
  "core-prompt":
  "{s : Heap α} : s.tail? le = some s' →\n    s.realSize = s'.realSize + 1",
  "args": "{s : Heap α}"},
 {"type":
  "(merge le s₁ s₂).WellFormed le n ∧\n    ((s₁.rankGT n ↔ s₂.rankGT n) → (merge le s₁ s₂).rankGT n)",
  "tactic-prompt":
  "theorem (h₁ : s₁.WellFormed le n)  (h₂ : s₂.WellFormed le n) : (merge le s₁ s₂).WellFormed le n ∧\n    ((s₁.rankGT n ↔ s₂.rankGT n) → (merge le s₁ s₂).rankGT n) := by unfold merge; sorry",
  "name": "Heap.WellFormed.merge'",
  "kind": "theorem",
  "first-tactic": "unfold merge",
  "core-prompt":
  "(h₁ : s₁.WellFormed le n)  (h₂ : s₂.WellFormed le n) : (merge le s₁ s₂).WellFormed le n ∧\n    ((s₁.rankGT n ↔ s₂.rankGT n) → (merge le s₁ s₂).rankGT n)",
  "args": "(h₁ : s₁.WellFormed le n)  (h₂ : s₂.WellFormed le n)"},
 {"type": "s.toHeap.WellFormed le 0",
  "tactic-prompt":
  "theorem {s : HeapNode α}      (h : s.WellFormed le a n) : s.toHeap.WellFormed le 0 := by rw [toHeap]; sorry",
  "name": "HeapNode.WellFormed.toHeap",
  "kind": "theorem",
  "first-tactic": "rw [toHeap]",
  "core-prompt":
  "{s : HeapNode α}      (h : s.WellFormed le a n) : s.toHeap.WellFormed le 0",
  "args": "{s : HeapNode α}      (h : s.WellFormed le a n)"},
 {"type": "s'.WellFormed le 0",
  "tactic-prompt":
  "theorem {s : Heap α}      (h : s.WellFormed le n)  (eq : s.deleteMin le = some (a, s')) : s'.WellFormed le 0 := by cases s; sorry",
  "name": "Heap.WellFormed.deleteMin",
  "kind": "theorem",
  "first-tactic": "cases s",
  "core-prompt":
  "{s : Heap α}      (h : s.WellFormed le n)  (eq : s.deleteMin le = some (a, s')) : s'.WellFormed le 0",
  "args":
  "{s : Heap α}      (h : s.WellFormed le n)  (eq : s.deleteMin le = some (a, s'))"},
 {"type": "s.tail? le = some tl →\n  tl.WellFormed le 0",
  "tactic-prompt":
  "theorem (hwf : (s : Heap α).WellFormed le n) : s.tail? le = some tl →\n  tl.WellFormed le 0 := by simp only [Heap.tail?]; sorry",
  "name": "Heap.WellFormed.tail?",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail?]",
  "core-prompt":
  "(hwf : (s : Heap α).WellFormed le n) : s.tail? le = some tl →\n  tl.WellFormed le 0",
  "args": "(hwf : (s : Heap α).WellFormed le n)"},
 {"type": "(s.tail le).WellFormed le 0",
  "tactic-prompt":
  "theorem (hwf : (s : Heap α).WellFormed le n) : (s.tail le).WellFormed le 0 := by simp only [Heap.tail]; sorry",
  "name": "Heap.WellFormed.tail",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail]",
  "core-prompt":
  "(hwf : (s : Heap α).WellFormed le n) : (s.tail le).WellFormed le 0",
  "args": "(hwf : (s : Heap α).WellFormed le n)"},
 {"type": "(gcd m n ∣ m) ∧ (gcd m n ∣ n)",
  "tactic-prompt":
  "theorem (m n : Nat) : (gcd m n ∣ m) ∧ (gcd m n ∣ n) := by induction m, n using gcd.induction with\n  | H0 n => rw [gcd_zero_left]; exact ⟨Nat.dvd_zero n, Nat.dvd_refl n⟩\n  | H1 m n _ IH => rw [← gcd_rec] at IH; exact ⟨IH.2, (dvd_mod_iff IH.2).1 IH.1⟩; sorry",
  "name": "gcd_dvd",
  "kind": "theorem",
  "first-tactic":
  "induction m, n using gcd.induction with\n  | H0 n => rw [gcd_zero_left]; exact ⟨Nat.dvd_zero n, Nat.dvd_refl n⟩\n  | H1 m n _ IH => rw [← gcd_rec] at IH; exact ⟨IH.2, (dvd_mod_iff IH.2).1 IH.1⟩",
  "core-prompt": "(m n : Nat) : (gcd m n ∣ m) ∧ (gcd m n ∣ n)",
  "args": "(m n : Nat)"},
 {"type": "k ∣ m → k ∣ n → k ∣ gcd m n",
  "tactic-prompt":
  "theorem  : k ∣ m → k ∣ n → k ∣ gcd m n := by induction m, n using gcd.induction with intro km kn\n  | H0 n => rw [gcd_zero_left]; exact kn\n  | H1 n m _ IH => rw [gcd_rec]; exact IH ((dvd_mod_iff km).2 kn) km; sorry",
  "name": "dvd_gcd",
  "kind": "theorem",
  "first-tactic":
  "induction m, n using gcd.induction with intro km kn\n  | H0 n => rw [gcd_zero_left]; exact kn\n  | H1 n m _ IH => rw [gcd_rec]; exact IH ((dvd_mod_iff km).2 kn) km",
  "core-prompt": " : k ∣ m → k ∣ n → k ∣ gcd m n",
  "args": ""},
 {"type": "m ∣ n ↔ gcd n m = m",
  "tactic-prompt": "theorem  : m ∣ n ↔ gcd n m = m := by rw [gcd_comm]; sorry",
  "name": "gcd_eq_right_iff_dvd",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": " : m ∣ n ↔ gcd n m = m",
  "args": ""},
 {"type": "gcd (m * n) (m * k) = m * gcd n k",
  "tactic-prompt":
  "theorem (m n k : Nat) : gcd (m * n) (m * k) = m * gcd n k := by induction n, k using gcd.induction with\n  | H0 k => simp\n  | H1 n k _ IH => rwa [← mul_mod_mul_left, ← gcd_rec, ← gcd_rec] at IH; sorry",
  "name": "gcd_mul_left",
  "kind": "theorem",
  "first-tactic":
  "induction n, k using gcd.induction with\n  | H0 k => simp\n  | H1 n k _ IH => rwa [← mul_mod_mul_left, ← gcd_rec, ← gcd_rec] at IH",
  "core-prompt": "(m n k : Nat) : gcd (m * n) (m * k) = m * gcd n k",
  "args": "(m n k : Nat)"},
 {"type": "gcd (m * n) (k * n) = gcd m k * n",
  "tactic-prompt":
  "theorem (m n k : Nat) : gcd (m * n) (k * n) = gcd m k * n := by rw [Nat.mul_comm m n]; sorry",
  "name": "gcd_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm m n]",
  "core-prompt": "(m n k : Nat) : gcd (m * n) (k * n) = gcd m k * n",
  "args": "(m n k : Nat)"},
 {"type": "n = 0",
  "tactic-prompt":
  "theorem {m n : Nat}  (H : gcd m n = 0) : n = 0 := by rw [gcd_comm] at H; sorry",
  "name": "eq_zero_of_gcd_eq_zero_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm] at H",
  "core-prompt": "{m n : Nat}  (H : gcd m n = 0) : n = 0",
  "args": "{m n : Nat}  (H : gcd m n = 0)"},
 {"type": "gcd m n = n",
  "tactic-prompt":
  "theorem {m n : Nat}  (H : n ∣ m) : gcd m n = n := by rw [gcd_comm]; sorry",
  "name": "gcd_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "{m n : Nat}  (H : n ∣ m) : gcd m n = n",
  "args": "{m n : Nat}  (H : n ∣ m)"},
 {"type": "gcd n (m * n) = n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd n (m * n) = n := by rw [gcd_comm]; sorry",
  "name": "gcd_mul_left_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n : Nat) : gcd n (m * n) = n",
  "args": "(m n : Nat)"},
 {"type": "gcd (n * m) n = n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd (n * m) n = n := by rw [Nat.mul_comm]; sorry",
  "name": "gcd_mul_right_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(m n : Nat) : gcd (n * m) n = n",
  "args": "(m n : Nat)"},
 {"type": "gcd n (n * m) = n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd n (n * m) = n := by rw [gcd_comm]; sorry",
  "name": "gcd_mul_right_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n : Nat) : gcd n (n * m) = n",
  "args": "(m n : Nat)"},
 {"type": "gcd m (gcd n m) = gcd n m",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd m (gcd n m) = gcd n m := by rw [gcd_comm n m]; sorry",
  "name": "gcd_gcd_self_right_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm n m]",
  "core-prompt": "(m n : Nat) : gcd m (gcd n m) = gcd n m",
  "args": "(m n : Nat)"},
 {"type": "gcd (gcd n m) m = gcd n m",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd (gcd n m) m = gcd n m := by rw [gcd_comm]; sorry",
  "name": "gcd_gcd_self_left_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n : Nat) : gcd (gcd n m) m = gcd n m",
  "args": "(m n : Nat)"},
 {"type": "gcd (gcd m n) m = gcd m n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd (gcd m n) m = gcd m n := by rw [gcd_comm m n]; sorry",
  "name": "gcd_gcd_self_left_left",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm m n]",
  "core-prompt": "(m n : Nat) : gcd (gcd m n) m = gcd m n",
  "args": "(m n : Nat)"},
 {"type": "gcd m (n + k * m) = gcd m n",
  "tactic-prompt":
  "theorem (m n k : Nat) : gcd m (n + k * m) = gcd m n := by simp [gcd_rec m (n + k * m)]; sorry",
  "name": "gcd_add_mul_self",
  "kind": "theorem",
  "first-tactic": "simp [gcd_rec m (n + k * m)]",
  "core-prompt": "(m n k : Nat) : gcd m (n + k * m) = gcd m n",
  "args": "(m n k : Nat)"},
 {"type": "lcm m n = lcm n m",
  "tactic-prompt":
  "theorem (m n : Nat) : lcm m n = lcm n m := by rw [lcm]; sorry",
  "name": "lcm_comm",
  "kind": "theorem",
  "first-tactic": "rw [lcm]",
  "core-prompt": "(m n : Nat) : lcm m n = lcm n m",
  "args": "(m n : Nat)"},
 {"type": "lcm 0 m = 0",
  "tactic-prompt": "theorem (m : Nat) : lcm 0 m = 0 := by simp [lcm]; sorry",
  "name": "lcm_zero_left",
  "kind": "theorem",
  "first-tactic": "simp [lcm]",
  "core-prompt": "(m : Nat) : lcm 0 m = 0",
  "args": "(m : Nat)"},
 {"type": "lcm m 0 = 0",
  "tactic-prompt": "theorem (m : Nat) : lcm m 0 = 0 := by simp [lcm]; sorry",
  "name": "lcm_zero_right",
  "kind": "theorem",
  "first-tactic": "simp [lcm]",
  "core-prompt": "(m : Nat) : lcm m 0 = 0",
  "args": "(m : Nat)"},
 {"type": "lcm 1 m = m",
  "tactic-prompt": "theorem (m : Nat) : lcm 1 m = m := by simp [lcm]; sorry",
  "name": "lcm_one_left",
  "kind": "theorem",
  "first-tactic": "simp [lcm]",
  "core-prompt": "(m : Nat) : lcm 1 m = m",
  "args": "(m : Nat)"},
 {"type": "lcm m 1 = m",
  "tactic-prompt": "theorem (m : Nat) : lcm m 1 = m := by simp [lcm]; sorry",
  "name": "lcm_one_right",
  "kind": "theorem",
  "first-tactic": "simp [lcm]",
  "core-prompt": "(m : Nat) : lcm m 1 = m",
  "args": "(m : Nat)"},
 {"type": "lcm m m = m",
  "tactic-prompt":
  "theorem (m : Nat) : lcm m m = m := by match eq_zero_or_pos m with\n  | .inl h => rw [h]; sorry",
  "name": "lcm_self",
  "kind": "theorem",
  "first-tactic": "match eq_zero_or_pos m with\n  | .inl h => rw [h]",
  "core-prompt": "(m : Nat) : lcm m m = m",
  "args": "(m : Nat)"},
 {"type": "gcd m n * lcm m n = m * n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd m n * lcm m n = m * n := by rw [lcm]; sorry",
  "name": "gcd_mul_lcm",
  "kind": "theorem",
  "first-tactic": "rw [lcm]",
  "core-prompt": "(m n : Nat) : gcd m n * lcm m n = m * n",
  "args": "(m n : Nat)"},
 {"type": "lcm m n ∣ k",
  "tactic-prompt":
  "theorem {m n k : Nat}  (H1 : m ∣ k)  (H2 : n ∣ k) : lcm m n ∣ k := by match eq_zero_or_pos k with\n  | .inl h => rw [h]; exact Nat.dvd_zero _\n  | .inr kpos =>\n    apply Nat.dvd_of_mul_dvd_mul_left (gcd_pos_of_pos_left n (pos_of_dvd_of_pos H1 kpos))\n    rw [gcd_mul_lcm]; sorry",
  "name": "lcm_dvd",
  "kind": "theorem",
  "first-tactic":
  "match eq_zero_or_pos k with\n  | .inl h => rw [h]; exact Nat.dvd_zero _\n  | .inr kpos =>\n    apply Nat.dvd_of_mul_dvd_mul_left (gcd_pos_of_pos_left n (pos_of_dvd_of_pos H1 kpos))\n    rw [gcd_mul_lcm]",
  "core-prompt": "{m n k : Nat}  (H1 : m ∣ k)  (H2 : n ∣ k) : lcm m n ∣ k",
  "args": "{m n k : Nat}  (H1 : m ∣ k)  (H2 : n ∣ k)"},
 {"type": "lcm m n ≠ 0",
  "tactic-prompt":
  "theorem (hm : m ≠ 0)  (hn : n ≠ 0) : lcm m n ≠ 0 := by intro h; sorry",
  "name": "lcm_ne_zero",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "(hm : m ≠ 0)  (hn : n ≠ 0) : lcm m n ≠ 0",
  "args": "(hm : m ≠ 0)  (hn : n ≠ 0)"},
 {"type": "k ∣ m",
  "tactic-prompt":
  "theorem (H1 : coprime k n)  (H2 : k ∣ m * n) : k ∣ m := by let t := dvd_gcd (Nat.dvd_mul_left k m) H2; sorry",
  "name": "coprime.dvd_of_dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "let t := dvd_gcd (Nat.dvd_mul_left k m) H2",
  "core-prompt": "(H1 : coprime k n)  (H2 : k ∣ m * n) : k ∣ m",
  "args": "(H1 : coprime k n)  (H2 : k ∣ m * n)"},
 {"type": "gcd (m * k) n = gcd m n",
  "tactic-prompt":
  "theorem (m : Nat)  (H : coprime k n) : gcd (m * k) n = gcd m n := by rw [Nat.mul_comm m k]; sorry",
  "name": "coprime.gcd_mul_right_cancel",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm m k]",
  "core-prompt": "(m : Nat)  (H : coprime k n) : gcd (m * k) n = gcd m n",
  "args": "(m : Nat)  (H : coprime k n)"},
 {"type": "gcd m (k * n) = gcd m n",
  "tactic-prompt":
  "theorem (n : Nat)      (H : coprime k m) : gcd m (k * n) = gcd m n := by rw [gcd_comm m n]; sorry",
  "name": "coprime.gcd_mul_left_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm m n]",
  "core-prompt": "(n : Nat)      (H : coprime k m) : gcd m (k * n) = gcd m n",
  "args": "(n : Nat)      (H : coprime k m)"},
 {"type": "gcd m (n * k) = gcd m n",
  "tactic-prompt":
  "theorem (n : Nat)      (H : coprime k m) : gcd m (n * k) = gcd m n := by rw [Nat.mul_comm n k]; sorry",
  "name": "coprime.gcd_mul_right_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm n k]",
  "core-prompt": "(n : Nat)      (H : coprime k m) : gcd m (n * k) = gcd m n",
  "args": "(n : Nat)      (H : coprime k m)"},
 {"type": "coprime (m / gcd m n) (n / gcd m n)",
  "tactic-prompt":
  "theorem (H : 0 < gcd m n) : coprime (m / gcd m n) (n / gcd m n) := by rw [coprime_iff_gcd_eq_one]; sorry",
  "name": "coprime_div_gcd_div_gcd",
  "kind": "theorem",
  "first-tactic": "rw [coprime_iff_gcd_eq_one]",
  "core-prompt": "(H : 0 < gcd m n) : coprime (m / gcd m n) (n / gcd m n)",
  "args": "(H : 0 < gcd m n)"},
 {"type": "coprime m n",
  "tactic-prompt":
  "theorem (H1 : m ∣ k)  (H2 : coprime k n) : coprime m n := by apply eq_one_of_dvd_one; sorry",
  "name": "coprime.coprime_dvd_left",
  "kind": "theorem",
  "first-tactic": "apply eq_one_of_dvd_one",
  "core-prompt": "(H1 : m ∣ k)  (H2 : coprime k n) : coprime m n",
  "args": "(H1 : m ∣ k)  (H2 : coprime k n)"},
 {"type": "coprime (m / a) n",
  "tactic-prompt":
  "theorem (cmn : coprime m n)  (dvd : a ∣ m) : coprime (m / a) n := by match eq_zero_or_pos a with\n  | .inl h0 =>\n    rw [h0] at dvd\n    rw [Nat.eq_zero_of_zero_dvd dvd] at cmn ⊢\n    simp; assumption\n  | .inr hpos =>\n    let ⟨k]; sorry",
  "name": "coprime.coprime_div_left",
  "kind": "theorem",
  "first-tactic":
  "match eq_zero_or_pos a with\n  | .inl h0 =>\n    rw [h0] at dvd\n    rw [Nat.eq_zero_of_zero_dvd dvd] at cmn ⊢\n    simp; assumption\n  | .inr hpos =>\n    let ⟨k]",
  "core-prompt": "(cmn : coprime m n)  (dvd : a ∣ m) : coprime (m / a) n",
  "args": "(cmn : coprime m n)  (dvd : a ∣ m)"},
 {"type": "coprime k (m * n) ↔ coprime k m ∧ coprime k n",
  "tactic-prompt":
  "theorem  : coprime k (m * n) ↔ coprime k m ∧ coprime k n := by rw [@coprime_comm k]; sorry",
  "name": "coprime_mul_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [@coprime_comm k]",
  "core-prompt": " : coprime k (m * n) ↔ coprime k m ∧ coprime k n",
  "args": ""},
 {"type": "coprime 0 n ↔ n = 1",
  "tactic-prompt":
  "theorem (n : Nat) : coprime 0 n ↔ n = 1 := by simp [coprime]; sorry",
  "name": "coprime_zero_left",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : Nat) : coprime 0 n ↔ n = 1",
  "args": "(n : Nat)"},
 {"type": "coprime n 0 ↔ n = 1",
  "tactic-prompt":
  "theorem (n : Nat) : coprime n 0 ↔ n = 1 := by simp [coprime]; sorry",
  "name": "coprime_zero_right",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : Nat) : coprime n 0 ↔ n = 1",
  "args": "(n : Nat)"},
 {"type": "coprime n n ↔ n = 1",
  "tactic-prompt":
  "theorem (n : Nat) : coprime n n ↔ n = 1 := by simp [coprime]; sorry",
  "name": "coprime_self",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : Nat) : coprime n n ↔ n = 1",
  "args": "(n : Nat)"},
 {"type": "coprime (m ^ n) k",
  "tactic-prompt":
  "theorem (n : Nat)  (H1 : coprime m k) : coprime (m ^ n) k := by induction n; sorry",
  "name": "coprime.pow_left",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "(n : Nat)  (H1 : coprime m k) : coprime (m ^ n) k",
  "args": "(n : Nat)  (H1 : coprime m k)"},
 {"type": "k = 1",
  "tactic-prompt":
  "theorem {k m : Nat}  (H : coprime k m)  (d : k ∣ m) : k = 1 := by rw [← H.gcd_eq_one]; sorry",
  "name": "coprime.eq_one_of_dvd",
  "kind": "theorem",
  "first-tactic": "rw [← H.gcd_eq_one]",
  "core-prompt": "{k m : Nat}  (H : coprime k m)  (d : k ∣ m) : k = 1",
  "args": "{k m : Nat}  (H : coprime k m)  (d : k ∣ m)"},
 {"type": "gcd k (m * n) ∣ gcd k m * gcd k n",
  "tactic-prompt":
  "theorem (k m n : Nat) : gcd k (m * n) ∣ gcd k m * gcd k n := by let ⟨⟨⟨m', hm'⟩, ⟨n', hn'⟩⟩, (h : gcd k (m * n) = m' * n')⟩ :=\n    prod_dvd_and_dvd_of_dvd_prod <| gcd_dvd_right k (m * n); sorry",
  "name": "gcd_mul_dvd_mul_gcd",
  "kind": "theorem",
  "first-tactic":
  "let ⟨⟨⟨m', hm'⟩, ⟨n', hn'⟩⟩, (h : gcd k (m * n) = m' * n')⟩ :=\n    prod_dvd_and_dvd_of_dvd_prod <| gcd_dvd_right k (m * n)",
  "core-prompt": "(k m n : Nat) : gcd k (m * n) ∣ gcd k m * gcd k n",
  "args": "(k m n : Nat)"},
 {"type": "a.gcd c * b.gcd c = c",
  "tactic-prompt":
  "theorem (cop : coprime c d)  (h : a * b = c * d) : a.gcd c * b.gcd c = c := by apply dvd_antisymm; sorry",
  "name": "gcd_mul_gcd_of_coprime_of_mul_eq_mul",
  "kind": "theorem",
  "first-tactic": "apply dvd_antisymm",
  "core-prompt":
  "(cop : coprime c d)  (h : a * b = c * d) : a.gcd c * b.gcd c = c",
  "args": "(cop : coprime c d)  (h : a * b = c * d)"},
 {"type": "n < k + n",
  "tactic-prompt":
  "theorem {n k : Nat}  (h : 0 < k) : n < k + n := by rw [Nat.add_comm]; sorry",
  "name": "lt_add_of_pos_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "{n k : Nat}  (h : 0 < k) : n < k + n",
  "args": "{n k : Nat}  (h : 0 < k)"},
 {"type": "x + k ≤ y ↔ x ≤ y - k",
  "tactic-prompt":
  "theorem (x : Nat)  {y k : Nat}  (h : k ≤ y) : x + k ≤ y ↔ x ≤ y - k := by rw [← Nat.add_sub_cancel x k]; sorry",
  "name": "add_le_to_le_sub",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.add_sub_cancel x k]",
  "core-prompt": "(x : Nat)  {y k : Nat}  (h : k ≤ y) : x + k ≤ y ↔ x ≤ y - k",
  "args": "(x : Nat)  {y k : Nat}  (h : k ≤ y)"},
 {"type": "min a b = min b a",
  "tactic-prompt":
  "theorem (a b : Nat) : min a b = min b a := by simp [Nat.min_def]; sorry",
  "name": "min_comm",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_def]",
  "core-prompt": "(a b : Nat) : min a b = min b a",
  "args": "(a b : Nat)"},
 {"type": "min a b ≤ a",
  "tactic-prompt":
  "theorem (a b : Nat) : min a b ≤ a := by simp [Nat.min_def]; sorry",
  "name": "min_le_left",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_def]",
  "core-prompt": "(a b : Nat) : min a b ≤ a",
  "args": "(a b : Nat)"},
 {"type": "min a b = a",
  "tactic-prompt":
  "theorem {a b : Nat}  (h : a ≤ b) : min a b = a := by simp [Nat.min_def]; sorry",
  "name": "min_eq_left",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_def]",
  "core-prompt": "{a b : Nat}  (h : a ≤ b) : min a b = a",
  "args": "{a b : Nat}  (h : a ≤ b)"},
 {"type": "min a b = b",
  "tactic-prompt":
  "theorem {a b : Nat}  (h : b ≤ a) : min a b = b := by rw [Nat.min_comm a b]; sorry",
  "name": "min_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.min_comm a b]",
  "core-prompt": "{a b : Nat}  (h : b ≤ a) : min a b = b",
  "args": "{a b : Nat}  (h : b ≤ a)"},
 {"type": "max a b = max b a",
  "tactic-prompt":
  "theorem (a b : Nat) : max a b = max b a := by simp only [Nat.max_def]; sorry",
  "name": "max_comm",
  "kind": "theorem",
  "first-tactic": "simp only [Nat.max_def]",
  "core-prompt": "(a b : Nat) : max a b = max b a",
  "args": "(a b : Nat)"},
 {"type": "max a b = b",
  "tactic-prompt":
  "theorem {a b : Nat}  (h : a ≤ b) : max a b = b := by simp [Nat.max_def]; sorry",
  "name": "max_eq_right",
  "kind": "theorem",
  "first-tactic": "simp [Nat.max_def]",
  "core-prompt": "{a b : Nat}  (h : a ≤ b) : max a b = b",
  "args": "{a b : Nat}  (h : a ≤ b)"},
 {"type": "max a b = a",
  "tactic-prompt":
  "theorem {a b : Nat}  (h : b ≤ a) : max a b = a := by rw [← Nat.max_comm b a]; sorry",
  "name": "max_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.max_comm b a]",
  "core-prompt": "{a b : Nat}  (h : b ≤ a) : max a b = a",
  "args": "{a b : Nat}  (h : b ≤ a)"},
 {"type": "min (succ x) (succ y) = succ (min x y)",
  "tactic-prompt":
  "theorem (x y : Nat) : min (succ x) (succ y) = succ (min x y) := by simp [Nat.min_def]; sorry",
  "name": "min_succ_succ",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_def]",
  "core-prompt": "(x y : Nat) : min (succ x) (succ y) = succ (min x y)",
  "args": "(x y : Nat)"},
 {"type": "n - m = n - min n m",
  "tactic-prompt":
  "theorem (n m : Nat) : n - m = n - min n m := by rw [Nat.min_def]; sorry",
  "name": "sub_eq_sub_min",
  "kind": "theorem",
  "first-tactic": "rw [Nat.min_def]",
  "core-prompt": "(n m : Nat) : n - m = n - min n m",
  "args": "(n m : Nat)"},
 {"type": "n - m + min n m = n",
  "tactic-prompt":
  "theorem (n m : Nat) : n - m + min n m = n := by rw [sub_eq_sub_min]; sorry",
  "name": "sub_add_min_cancel",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_sub_min]",
  "core-prompt": "(n m : Nat) : n - m + min n m = n",
  "args": "(n m : Nat)"},
 {"type": "n * m * k = n * k * m",
  "tactic-prompt":
  "theorem (n m k : Nat) : n * m * k = n * k * m := by rw [Nat.mul_assoc]; sorry",
  "name": "mul_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_assoc]",
  "core-prompt": "(n m k : Nat) : n * m * k = n * k * m",
  "args": "(n m k : Nat)"},
 {"type": "m % k + k * (m / k) = m",
  "tactic-prompt":
  "theorem (m k : Nat) : m % k + k * (m / k) = m := by induction m, k using mod.inductionOn with rw [div_eq, mod_eq]\n  | base x y h => simp [h]\n  | ind x y h IH => simp [h]; rw [Nat.mul_succ, ← Nat.add_assoc, IH, Nat.sub_add_cancel h.2]\n\n/- div -/; sorry",
  "name": "mod_add_div",
  "kind": "theorem",
  "first-tactic":
  "induction m, k using mod.inductionOn with rw [div_eq, mod_eq]\n  | base x y h => simp [h]\n  | ind x y h IH => simp [h]; rw [Nat.mul_succ, ← Nat.add_assoc, IH, Nat.sub_add_cancel h.2]\n\n/- div -/",
  "core-prompt": "(m k : Nat) : m % k + k * (m / k) = m",
  "args": "(m k : Nat)"},
 {"type": "n / 1 = n",
  "tactic-prompt":
  "theorem (n : Nat) : n / 1 = n := by have := mod_add_div n 1; sorry",
  "name": "div_one",
  "kind": "theorem",
  "first-tactic": "have := mod_add_div n 1",
  "core-prompt": "(n : Nat) : n / 1 = n",
  "args": "(n : Nat)"},
 {"type": "n / 0 = 0",
  "tactic-prompt": "theorem (n : Nat) : n / 0 = 0 := by rw [div_eq]; sorry",
  "name": "div_zero",
  "kind": "theorem",
  "first-tactic": "rw [div_eq]",
  "core-prompt": "(n : Nat) : n / 0 = 0",
  "args": "(n : Nat)"},
 {"type": "x ≤ y / k ↔ x * k ≤ y",
  "tactic-prompt":
  "theorem (k0 : 0 < k) : x ≤ y / k ↔ x * k ≤ y := by induction y, k using mod.inductionOn generalizing x with\n    (rw [div_eq]; simp [h]; cases x with simp [zero_le] | succ x => ?_)\n  | base y k h =>\n    simp [not_succ_le_zero x, succ_mul, Nat.add_comm]\n    refine Nat.lt_of_lt_of_le ?_ (Nat.le_add_right ..)\n    exact Nat.not_le.1 fun h' => h ⟨k0, h'⟩\n  | ind y k h IH =>\n    rw [← add_one, Nat.add_le_add_iff_le_right, IH k0, succ_mul,\n        ← Nat.add_sub_cancel (x*k) k, Nat.sub_le_sub_right_iff h.2, Nat.add_sub_cancel]; sorry",
  "name": "le_div_iff_mul_le",
  "kind": "theorem",
  "first-tactic":
  "induction y, k using mod.inductionOn generalizing x with\n    (rw [div_eq]; simp [h]; cases x with simp [zero_le] | succ x => ?_)\n  | base y k h =>\n    simp [not_succ_le_zero x, succ_mul, Nat.add_comm]\n    refine Nat.lt_of_lt_of_le ?_ (Nat.le_add_right ..)\n    exact Nat.not_le.1 fun h' => h ⟨k0, h'⟩\n  | ind y k h IH =>\n    rw [← add_one, Nat.add_le_add_iff_le_right, IH k0, succ_mul,\n        ← Nat.add_sub_cancel (x*k) k, Nat.sub_le_sub_right_iff h.2, Nat.add_sub_cancel]",
  "core-prompt": "(k0 : 0 < k) : x ≤ y / k ↔ x * k ≤ y",
  "args": "(k0 : 0 < k)"},
 {"type": "a / b = (a - b) / b + 1",
  "tactic-prompt":
  "theorem (h₁ : 0 < b)  (h₂ : b ≤ a) : a / b = (a - b) / b + 1 := by rw [div_eq a]; sorry",
  "name": "div_eq_sub_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq a]",
  "core-prompt": "(h₁ : 0 < b)  (h₂ : b ≤ a) : a / b = (a - b) / b + 1",
  "args": "(h₁ : 0 < b)  (h₂ : b ≤ a)"},
 {"type": "a / b = 0",
  "tactic-prompt":
  "theorem (h₀ : a < b) : a / b = 0 := by rw [div_eq a]; sorry",
  "name": "div_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [div_eq a]",
  "core-prompt": "(h₀ : a < b) : a / b = 0",
  "args": "(h₀ : a < b)"},
 {"type": "x / k < y ↔ x < y * k",
  "tactic-prompt":
  "theorem (Hk : 0 < k) : x / k < y ↔ x < y * k := by rw [← Nat.not_le]; sorry",
  "name": "div_lt_iff_lt_mul",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.not_le]",
  "core-prompt": "(Hk : 0 < k) : x / k < y ↔ x < y * k",
  "args": "(Hk : 0 < k)"},
 {"type": "n = 0 ∨ n = succ (pred n)",
  "tactic-prompt":
  "theorem (n : Nat) : n = 0 ∨ n = succ (pred n) := by cases n; sorry",
  "name": "eq_zero_or_eq_succ_pred",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n : Nat) : n = 0 ∨ n = succ (pred n)",
  "args": "(n : Nat)"},
 {"type": "n.succ = 1 + n",
  "tactic-prompt":
  "theorem (n : Nat) : n.succ = 1 + n := by rw [Nat.succ_eq_add_one]; sorry",
  "name": "succ_eq_one_add",
  "kind": "theorem",
  "first-tactic": "rw [Nat.succ_eq_add_one]",
  "core-prompt": "(n : Nat) : n.succ = 1 + n",
  "args": "(n : Nat)"},
 {"type": "succ n + m = n + succ m",
  "tactic-prompt":
  "theorem (n m : Nat) : succ n + m = n + succ m := by simp [succ_add]; sorry",
  "name": "succ_add_eq_succ_add",
  "kind": "theorem",
  "first-tactic": "simp [succ_add]",
  "core-prompt": "(n m : Nat) : succ n + m = n + succ m",
  "args": "(n m : Nat)"},
 {"type": "1 + n = succ n",
  "tactic-prompt":
  "theorem (n : Nat) : 1 + n = succ n := by simp [Nat.add_comm]; sorry",
  "name": "one_add",
  "kind": "theorem",
  "first-tactic": "simp [Nat.add_comm]",
  "core-prompt": "(n : Nat) : 1 + n = succ n",
  "args": "(n : Nat)"},
 {"type": "a - b + b = max a b",
  "tactic-prompt":
  "theorem {a b : Nat} : a - b + b = max a b := by match a.le_total b with\n  | .inl hl => rw [Nat.max_eq_right hl]; sorry",
  "name": "sub_add_eq_max",
  "kind": "theorem",
  "first-tactic":
  "match a.le_total b with\n  | .inl hl => rw [Nat.max_eq_right hl]",
  "core-prompt": "{a b : Nat} : a - b + b = max a b",
  "args": "{a b : Nat}"},
 {"type": "succ n - m - succ k = n - m - k",
  "tactic-prompt":
  "theorem (n m k : Nat) : succ n - m - succ k = n - m - k := by rw [Nat.sub_sub]; sorry",
  "name": "succ_sub_sub_succ",
  "kind": "theorem",
  "first-tactic": "rw [Nat.sub_sub]",
  "core-prompt": "(n m k : Nat) : succ n - m - succ k = n - m - k",
  "args": "(n m k : Nat)"},
 {"type": "m - n - k = m - k - n",
  "tactic-prompt":
  "theorem (m n k : Nat) : m - n - k = m - k - n := by rw [Nat.sub_sub]; sorry",
  "name": "sub.right_comm",
  "kind": "theorem",
  "first-tactic": "rw [Nat.sub_sub]",
  "core-prompt": "(m n k : Nat) : m - n - k = m - k - n",
  "args": "(m n k : Nat)"},
 {"type": "a * a - b * b = (a + b) * (a - b)",
  "tactic-prompt":
  "theorem (a b : Nat) : a * a - b * b = (a + b) * (a - b) := by rw [Nat.mul_sub_left_distrib]; sorry",
  "name": "mul_self_sub_mul_self_eq",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_sub_left_distrib]",
  "core-prompt": "(a b : Nat) : a * a - b * b = (a + b) * (a - b)",
  "args": "(a b : Nat)"},
 {"type": "succ a * succ b = a * b + a + b + 1",
  "tactic-prompt":
  "theorem (a b : Nat) : succ a * succ b = a * b + a + b + 1 := by rw [mul_succ]; sorry",
  "name": "succ_mul_succ_eq",
  "kind": "theorem",
  "first-tactic": "rw [mul_succ]",
  "core-prompt": "(a b : Nat) : succ a * succ b = a * b + a + b + 1",
  "args": "(a b : Nat)"},
 {"type": "succ m - n = succ (m - n)",
  "tactic-prompt":
  "theorem {m n : Nat}  (h : n ≤ m) : succ m - n = succ (m - n) := by let ⟨k, hk⟩ := Nat.le.dest h; sorry",
  "name": "succ_sub",
  "kind": "theorem",
  "first-tactic": "let ⟨k, hk⟩ := Nat.le.dest h",
  "core-prompt": "{m n : Nat}  (h : n ≤ m) : succ m - n = succ (m - n)",
  "args": "{m n : Nat}  (h : n ≤ m)"},
 {"type": "0 < n - m",
  "tactic-prompt":
  "theorem (h : m < n) : 0 < n - m := by apply Nat.lt_of_add_lt_add_right (b := m); sorry",
  "name": "sub_pos_of_lt",
  "kind": "theorem",
  "first-tactic": "apply Nat.lt_of_add_lt_add_right (b := m)",
  "core-prompt": "(h : m < n) : 0 < n - m",
  "args": "(h : m < n)"},
 {"type": "n + m - k = n - k + m",
  "tactic-prompt":
  "theorem {n m k : Nat}  (h : k ≤ n) : n + m - k = n - k + m := by rw [Nat.sub_eq_iff_eq_add (Nat.le_trans h (Nat.le_add_right ..))]; sorry",
  "name": "sub_add_comm",
  "kind": "theorem",
  "first-tactic":
  "rw [Nat.sub_eq_iff_eq_add (Nat.le_trans h (Nat.le_add_right ..))]",
  "core-prompt": "{n m k : Nat}  (h : k ≤ n) : n + m - k = n - k + m",
  "args": "{n m k : Nat}  (h : k ≤ n)"},
 {"type": "n - 1 - i < n",
  "tactic-prompt":
  "theorem (h : i < n) : n - 1 - i < n := by rw [Nat.sub_sub]; sorry",
  "name": "sub_one_sub_lt",
  "kind": "theorem",
  "first-tactic": "rw [Nat.sub_sub]",
  "core-prompt": "(h : i < n) : n - 1 - i < n",
  "args": "(h : i < n)"},
 {"type": "b - a < b",
  "tactic-prompt":
  "theorem {a b : Nat}  (h₀ : 0 < a)  (h₁ : a ≤ b) : b - a < b := by apply sub_lt _ h₀; sorry",
  "name": "sub_lt_self",
  "kind": "theorem",
  "first-tactic": "apply sub_lt _ h₀",
  "core-prompt": "{a b : Nat}  (h₀ : 0 < a)  (h₁ : a ≤ b) : b - a < b",
  "args": "{a b : Nat}  (h₀ : 0 < a)  (h₁ : a ≤ b)"},
 {"type": "m + (n - m) = n",
  "tactic-prompt":
  "theorem {n m : Nat}  (h : m ≤ n) : m + (n - m) = n := by rw [Nat.add_comm]; sorry",
  "name": "add_sub_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "{n m : Nat}  (h : m ≤ n) : m + (n - m) = n",
  "args": "{n m : Nat}  (h : m ≤ n)"},
 {"type": "k - n < m",
  "tactic-prompt":
  "theorem {n k m : Nat}  (H : n ≤ k)  (h : k < n + m) : k - n < m := by have := Nat.sub_le_sub_right (succ_le_of_lt h) n; sorry",
  "name": "sub_lt_left_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have := Nat.sub_le_sub_right (succ_le_of_lt h) n",
  "core-prompt": "{n k m : Nat}  (H : n ≤ k)  (h : k < n + m) : k - n < m",
  "args": "{n k m : Nat}  (H : n ≤ k)  (h : k < n + m)"},
 {"type": "x ≤ y - k ↔ x + k ≤ y",
  "tactic-prompt":
  "theorem {x y k : Nat}  (h : k ≤ y) : x ≤ y - k ↔ x + k ≤ y := by rw [← Nat.add_sub_cancel x k]; sorry",
  "name": "le_sub_iff_add_le",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.add_sub_cancel x k]",
  "core-prompt": "{x y k : Nat}  (h : k ≤ y) : x ≤ y - k ↔ x + k ≤ y",
  "args": "{x y k : Nat}  (h : k ≤ y)"},
 {"type": "(x + z) % z = x % z",
  "tactic-prompt":
  "theorem (x z : Nat) : (x + z) % z = x % z := by rw [mod_eq_sub_mod (Nat.le_add_left ..)]; sorry",
  "name": "add_mod_right",
  "kind": "theorem",
  "first-tactic": "rw [mod_eq_sub_mod (Nat.le_add_left ..)]",
  "core-prompt": "(x z : Nat) : (x + z) % z = x % z",
  "args": "(x z : Nat)"},
 {"type": "(x + z) % x = z % x",
  "tactic-prompt":
  "theorem (x z : Nat) : (x + z) % x = z % x := by rw [Nat.add_comm]; sorry",
  "name": "add_mod_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "(x z : Nat) : (x + z) % x = z % x",
  "args": "(x z : Nat)"},
 {"type": "(x + y * z) % y = x % y",
  "tactic-prompt":
  "theorem (x y z : Nat) : (x + y * z) % y = x % y := by match z with\n  | 0 => rw [Nat.mul_zero]; sorry",
  "name": "add_mul_mod_self_left",
  "kind": "theorem",
  "first-tactic": "match z with\n  | 0 => rw [Nat.mul_zero]",
  "core-prompt": "(x y z : Nat) : (x + y * z) % y = x % y",
  "args": "(x y z : Nat)"},
 {"type": "(x + y * z) % z = x % z",
  "tactic-prompt":
  "theorem (x y z : Nat) : (x + y * z) % z = x % z := by rw [Nat.mul_comm]; sorry",
  "name": "add_mul_mod_self_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(x y z : Nat) : (x + y * z) % z = x % z",
  "args": "(x y z : Nat)"},
 {"type": "(m * n) % m = 0",
  "tactic-prompt":
  "theorem (m n : Nat) : (m * n) % m = 0 := by rw [← Nat.zero_add (m * n)]; sorry",
  "name": "mul_mod_right",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.zero_add (m * n)]",
  "core-prompt": "(m n : Nat) : (m * n) % m = 0",
  "args": "(m n : Nat)"},
 {"type": "(m * n) % n = 0",
  "tactic-prompt":
  "theorem (m n : Nat) : (m * n) % n = 0 := by rw [Nat.mul_comm]; sorry",
  "name": "mul_mod_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(m n : Nat) : (m * n) % n = 0",
  "args": "(m n : Nat)"},
 {"type": "(x * z) % (y * z) = (x % y) * z",
  "tactic-prompt":
  "theorem (z x y : Nat) : (x * z) % (y * z) = (x % y) * z := by rw [Nat.mul_comm x z]; sorry",
  "name": "mul_mod_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm x z]",
  "core-prompt": "(z x y : Nat) : (x * z) % (y * z) = (x % y) * z",
  "args": "(z x y : Nat)"},
 {"type": "(x - n*k) % n = x % n",
  "tactic-prompt":
  "theorem {x k n : Nat}  (h₁ : n*k ≤ x) : (x - n*k) % n = x % n := by match k with\n  | 0 => rw [Nat.mul_zero]; sorry",
  "name": "sub_mul_mod",
  "kind": "theorem",
  "first-tactic": "match k with\n  | 0 => rw [Nat.mul_zero]",
  "core-prompt": "{x k n : Nat}  (h₁ : n*k ≤ x) : (x - n*k) % n = x % n",
  "args": "{x k n : Nat}  (h₁ : n*k ≤ x)"},
 {"type": "(x - n*p) / n = x / n - p",
  "tactic-prompt":
  "theorem (x n p : Nat)  (h₁ : n*p ≤ x) : (x - n*p) / n = x / n - p := by match eq_zero_or_pos n with\n  | .inl h₀ => rw [h₀]; sorry",
  "name": "sub_mul_div",
  "kind": "theorem",
  "first-tactic": "match eq_zero_or_pos n with\n  | .inl h₀ => rw [h₀]",
  "core-prompt": "(x n p : Nat)  (h₁ : n*p ≤ x) : (x - n*p) / n = x / n - p",
  "args": "(x n p : Nat)  (h₁ : n*p ≤ x)"},
 {"type": "(x + z) / z = succ (x / z)",
  "tactic-prompt":
  "theorem (x : Nat)  {z : Nat}  (H : 0 < z) : (x + z) / z = succ (x / z) := by rw [div_eq_sub_div H (Nat.le_add_left _ _)]; sorry",
  "name": "add_div_right",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_sub_div H (Nat.le_add_left _ _)]",
  "core-prompt":
  "(x : Nat)  {z : Nat}  (H : 0 < z) : (x + z) / z = succ (x / z)",
  "args": "(x : Nat)  {z : Nat}  (H : 0 < z)"},
 {"type": "(z + x) / z = succ (x / z)",
  "tactic-prompt":
  "theorem (x : Nat)  {z : Nat}  (H : 0 < z) : (z + x) / z = succ (x / z) := by rw [Nat.add_comm]; sorry",
  "name": "add_div_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt":
  "(x : Nat)  {z : Nat}  (H : 0 < z) : (z + x) / z = succ (x / z)",
  "args": "(x : Nat)  {z : Nat}  (H : 0 < z)"},
 {"type": "m * n / m = n",
  "tactic-prompt":
  "theorem (n : Nat)  {m : Nat}  (H : 0 < m) : m * n / m = n := by induction n; sorry",
  "name": "mul_div_right",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "(n : Nat)  {m : Nat}  (H : 0 < m) : m * n / m = n",
  "args": "(n : Nat)  {m : Nat}  (H : 0 < m)"},
 {"type": "m * n / n = m",
  "tactic-prompt":
  "theorem (m : Nat)  {n : Nat}  (H : 0 < n) : m * n / n = m := by rw [Nat.mul_comm]; sorry",
  "name": "mul_div_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(m : Nat)  {n : Nat}  (H : 0 < n) : m * n / n = m",
  "args": "(m : Nat)  {n : Nat}  (H : 0 < n)"},
 {"type": "n / n = 1",
  "tactic-prompt":
  "theorem (H : 0 < n) : n / n = 1 := by let t := add_div_right 0 H; sorry",
  "name": "div_self",
  "kind": "theorem",
  "first-tactic": "let t := add_div_right 0 H",
  "core-prompt": "(H : 0 < n) : n / n = 1",
  "args": "(H : 0 < n)"},
 {"type": "(x + y * z) / y = x / y + z",
  "tactic-prompt":
  "theorem (x z : Nat)  {y : Nat}  (H : 0 < y) : (x + y * z) / y = x / y + z := by induction z; sorry",
  "name": "add_mul_div_left",
  "kind": "theorem",
  "first-tactic": "induction z",
  "core-prompt":
  "(x z : Nat)  {y : Nat}  (H : 0 < y) : (x + y * z) / y = x / y + z",
  "args": "(x z : Nat)  {y : Nat}  (H : 0 < y)"},
 {"type": "(x + y * z) / z = x / z + y",
  "tactic-prompt":
  "theorem (x y : Nat)  {z : Nat}  (H : 0 < z) : (x + y * z) / z = x / z + y := by rw [Nat.mul_comm]; sorry",
  "name": "add_mul_div_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt":
  "(x y : Nat)  {z : Nat}  (H : 0 < z) : (x + y * z) / z = x / z + y",
  "args": "(x y : Nat)  {z : Nat}  (H : 0 < z)"},
 {"type": "m * n / n = m",
  "tactic-prompt":
  "theorem (m : Nat)  {n : Nat}  (H : 0 < n) : m * n / n = m := by let t := add_mul_div_right 0 m H; sorry",
  "name": "mul_div_cancel",
  "kind": "theorem",
  "first-tactic": "let t := add_mul_div_right 0 m H",
  "core-prompt": "(m : Nat)  {n : Nat}  (H : 0 < n) : m * n / n = m",
  "args": "(m : Nat)  {n : Nat}  (H : 0 < n)"},
 {"type": "n * m / n = m",
  "tactic-prompt":
  "theorem (m : Nat)  {n : Nat}  (H : 0 < n) : n * m / n = m := by rw [Nat.mul_comm]; sorry",
  "name": "mul_div_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(m : Nat)  {n : Nat}  (H : 0 < n) : n * m / n = m",
  "args": "(m : Nat)  {n : Nat}  (H : 0 < n)"},
 {"type": "m / n = k",
  "tactic-prompt":
  "theorem (H1 : 0 < n)  (H2 : m = k * n) : m / n = k := by rw [H2]; sorry",
  "name": "div_eq_of_eq_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [H2]",
  "core-prompt": "(H1 : 0 < n)  (H2 : m = k * n) : m / n = k",
  "args": "(H1 : 0 < n)  (H2 : m = k * n)"},
 {"type": "m / n = k",
  "tactic-prompt":
  "theorem (H1 : 0 < n)  (H2 : m = n * k) : m / n = k := by rw [H2]; sorry",
  "name": "div_eq_of_eq_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [H2]",
  "core-prompt": "(H1 : 0 < n)  (H2 : m = n * k) : m / n = k",
  "args": "(H1 : 0 < n)  (H2 : m = n * k)"},
 {"type": "(n * p - succ x) / n = p - succ (x / n)",
  "tactic-prompt":
  "theorem (x n p : Nat)  (h₁ : x < n*p) : (n * p - succ x) / n = p - succ (x / n) := by have npos : 0 < n := (eq_zero_or_pos _).resolve_left fun n0 => by\n    rw [n0]; sorry",
  "name": "mul_sub_div",
  "kind": "theorem",
  "first-tactic":
  "have npos : 0 < n := (eq_zero_or_pos _).resolve_left fun n0 => by\n    rw [n0]",
  "core-prompt":
  "(x n p : Nat)  (h₁ : x < n*p) : (n * p - succ x) / n = p - succ (x / n)",
  "args": "(x n p : Nat)  (h₁ : x < n*p)"},
 {"type": "m / n / k = m / (n * k)",
  "tactic-prompt":
  "theorem (m n k : Nat) : m / n / k = m / (n * k) := by cases eq_zero_or_pos k; sorry",
  "name": "div_div_eq_div_mul",
  "kind": "theorem",
  "first-tactic": "cases eq_zero_or_pos k",
  "core-prompt": "(m n k : Nat) : m / n / k = m / (n * k)",
  "args": "(m n k : Nat)"},
 {"type": "m * n / (m * k) = n / k",
  "tactic-prompt":
  "theorem {m : Nat}  (n k : Nat)  (H : 0 < m) : m * n / (m * k) = n / k := by rw [← Nat.div_div_eq_div_mul]; sorry",
  "name": "mul_div_mul",
  "kind": "theorem",
  "first-tactic": "rw [← Nat.div_div_eq_div_mul]",
  "core-prompt":
  "{m : Nat}  (n k : Nat)  (H : 0 < m) : m * n / (m * k) = n / k",
  "args": "{m : Nat}  (n k : Nat)  (H : 0 < m)"},
 {"type": "n * (m / n) ≤ m",
  "tactic-prompt":
  "theorem (m n : Nat) : n * (m / n) ≤ m := by match n, Nat.eq_zero_or_pos n with\n  | _, Or.inl rfl => rw [Nat.zero_mul]; exact m.zero_le\n  | n, Or.inr h => rw [Nat.mul_comm, ← Nat.le_div_iff_mul_le h]; exact Nat.le_refl _\n\n/- dvd -/; sorry",
  "name": "mul_div_le",
  "kind": "theorem",
  "first-tactic":
  "match n, Nat.eq_zero_or_pos n with\n  | _, Or.inl rfl => rw [Nat.zero_mul]; exact m.zero_le\n  | n, Or.inr h => rw [Nat.mul_comm, ← Nat.le_div_iff_mul_le h]; exact Nat.le_refl _\n\n/- dvd -/",
  "core-prompt": "(m n : Nat) : n * (m / n) ≤ m",
  "args": "(m n : Nat)"},
 {"type": "k ∣ m ↔ k ∣ m + n",
  "tactic-prompt":
  "theorem {k m n : Nat}  (h : k ∣ n) : k ∣ m ↔ k ∣ m + n := by rw [Nat.add_comm]; sorry",
  "name": "dvd_add_iff_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "{k m n : Nat}  (h : k ∣ n) : k ∣ m ↔ k ∣ m + n",
  "args": "{k m n : Nat}  (h : k ∣ n)"},
 {"type": "m ∣ n",
  "tactic-prompt":
  "theorem {m n : Nat}  (H : n % m = 0) : m ∣ n := by exists n / m; sorry",
  "name": "dvd_of_mod_eq_zero",
  "kind": "theorem",
  "first-tactic": "exists n / m",
  "core-prompt": "{m n : Nat}  (H : n % m = 0) : m ∣ n",
  "args": "{m n : Nat}  (H : n % m = 0)"},
 {"type": "n % m = 0",
  "tactic-prompt":
  "theorem {m n : Nat}  (H : m ∣ n) : n % m = 0 := by let ⟨z, H⟩ := H; sorry",
  "name": "mod_eq_zero_of_dvd",
  "kind": "theorem",
  "first-tactic": "let ⟨z, H⟩ := H",
  "core-prompt": "{m n : Nat}  (H : m ∣ n) : n % m = 0",
  "args": "{m n : Nat}  (H : m ∣ n)"},
 {"type": "n * (m / n) = m",
  "tactic-prompt":
  "theorem {n m : Nat}  (H : n ∣ m) : n * (m / n) = m := by have := mod_add_div m n; sorry",
  "name": "mul_div_cancel'",
  "kind": "theorem",
  "first-tactic": "have := mod_add_div m n",
  "core-prompt": "{n m : Nat}  (H : n ∣ m) : n * (m / n) = m",
  "args": "{n m : Nat}  (H : n ∣ m)"},
 {"type": "m / n * n = m",
  "tactic-prompt":
  "theorem {n m : Nat}  (H : n ∣ m) : m / n * n = m := by rw [Nat.mul_comm]; sorry",
  "name": "div_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "{n m : Nat}  (H : n ∣ m) : m / n * n = m",
  "args": "{n m : Nat}  (H : n ∣ m)"},
 {"type": "m * n / k = m * (n / k)",
  "tactic-prompt":
  "theorem (m : Nat)  (H : k ∣ n) : m * n / k = m * (n / k) := by match Nat.eq_zero_or_pos k with\n  | .inl h0 => rw [h0]; sorry",
  "name": "mul_div_assoc",
  "kind": "theorem",
  "first-tactic": "match Nat.eq_zero_or_pos k with\n  | .inl h0 => rw [h0]",
  "core-prompt": "(m : Nat)  (H : k ∣ n) : m * n / k = m * (n / k)",
  "args": "(m : Nat)  (H : k ∣ n)"},
 {"type": "m ∣ n",
  "tactic-prompt":
  "theorem (kpos : 0 < k)  (H : k * m ∣ k * n) : m ∣ n := by let ⟨l, H⟩ := H; sorry",
  "name": "dvd_of_mul_dvd_mul_left",
  "kind": "theorem",
  "first-tactic": "let ⟨l, H⟩ := H",
  "core-prompt": "(kpos : 0 < k)  (H : k * m ∣ k * n) : m ∣ n",
  "args": "(kpos : 0 < k)  (H : k * m ∣ k * n)"},
 {"type": "m ∣ n",
  "tactic-prompt":
  "theorem (kpos : 0 < k)  (H : m * k ∣ n * k) : m ∣ n := by rw [Nat.mul_comm m k]; sorry",
  "name": "dvd_of_mul_dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm m k]",
  "core-prompt": "(kpos : 0 < k)  (H : m * k ∣ n * k) : m ∣ n",
  "args": "(kpos : 0 < k)  (H : m * k ∣ n * k)"},
 {"type": "c * a ≤ c * b",
  "tactic-prompt":
  "theorem {a b c : Nat}  (h₁ : a ≤ b) : c * a ≤ c * b := by if hba : b ≤ a then simp [Nat.le_antisymm hba h₁] else\n  if hc0 : c ≤ 0 then simp [Nat.le_antisymm hc0 (zero_le c)]; sorry",
  "name": "mul_le_mul_of_nonneg_left",
  "kind": "theorem",
  "first-tactic":
  "if hba : b ≤ a then simp [Nat.le_antisymm hba h₁] else\n  if hc0 : c ≤ 0 then simp [Nat.le_antisymm hc0 (zero_le c)]",
  "core-prompt": "{a b c : Nat}  (h₁ : a ≤ b) : c * a ≤ c * b",
  "args": "{a b c : Nat}  (h₁ : a ≤ b)"},
 {"type": "a * c ≤ b * c",
  "tactic-prompt":
  "theorem {a b c : Nat}  (h₁ : a ≤ b) : a * c ≤ b * c := by if hba : b ≤ a then simp [Nat.le_antisymm hba h₁] else\n  if hc0 : c ≤ 0 then simp [Nat.le_antisymm hc0 (zero_le c)]; sorry",
  "name": "mul_le_mul_of_nonneg_right",
  "kind": "theorem",
  "first-tactic":
  "if hba : b ≤ a then simp [Nat.le_antisymm hba h₁] else\n  if hc0 : c ≤ 0 then simp [Nat.le_antisymm hc0 (zero_le c)]",
  "core-prompt": "{a b c : Nat}  (h₁ : a ≤ b) : a * c ≤ b * c",
  "args": "{a b c : Nat}  (h₁ : a ≤ b)"},
 {"type": "a * b % n = (a % n) * (b % n) % n",
  "tactic-prompt":
  "theorem (a b n : Nat) : a * b % n = (a % n) * (b % n) % n := by conv => lhs; rw [\n    ← mod_add_div a n]; sorry",
  "name": "mul_mod",
  "kind": "theorem",
  "first-tactic": "conv => lhs; rw [\n    ← mod_add_div a n]",
  "core-prompt": "(a b n : Nat) : a * b % n = (a % n) * (b % n) % n",
  "args": "(a b n : Nat)"},
 {"type": "(m % n + k) % n = (m + k) % n",
  "tactic-prompt":
  "theorem (m n k : Nat) : (m % n + k) % n = (m + k) % n := by have := (add_mul_mod_self_left (m % n + k) n (m / n)).symm; sorry",
  "name": "mod_add_mod",
  "kind": "theorem",
  "first-tactic": "have := (add_mul_mod_self_left (m % n + k) n (m / n)).symm",
  "core-prompt": "(m n k : Nat) : (m % n + k) % n = (m + k) % n",
  "args": "(m n k : Nat)"},
 {"type": "(m + n % k) % k = (m + n) % k",
  "tactic-prompt":
  "theorem (m n k : Nat) : (m + n % k) % k = (m + n) % k := by rw [Nat.add_comm]; sorry",
  "name": "add_mod_mod",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "(m n k : Nat) : (m + n % k) % k = (m + n) % k",
  "args": "(m n k : Nat)"},
 {"type": "(a + b) % n = ((a % n) + (b % n)) % n",
  "tactic-prompt":
  "theorem (a b n : Nat) : (a + b) % n = ((a % n) + (b % n)) % n := by rw [add_mod_mod]; sorry",
  "name": "add_mod",
  "kind": "theorem",
  "first-tactic": "rw [add_mod_mod]",
  "core-prompt": "(a b n : Nat) : (a + b) % n = ((a % n) + (b % n)) % n",
  "args": "(a b n : Nat)"},
 {"type": "m ^ n.succ = m * m ^ n",
  "tactic-prompt":
  "theorem {m n : Nat} : m ^ n.succ = m * m ^ n := by rw [Nat.pow_succ]; sorry",
  "name": "pow_succ'",
  "kind": "theorem",
  "first-tactic": "rw [Nat.pow_succ]",
  "core-prompt": "{m n : Nat} : m ^ n.succ = m * m ^ n",
  "args": "{m n : Nat}"},
 {"type": "1 <<< n = 2 ^ n",
  "tactic-prompt":
  "theorem (n : Nat) : 1 <<< n = 2 ^ n := by rw [shiftLeft_eq]; sorry",
  "name": "one_shiftLeft",
  "kind": "theorem",
  "first-tactic": "rw [shiftLeft_eq]",
  "core-prompt": "(n : Nat) : 1 <<< n = 2 ^ n",
  "args": "(n : Nat)"},
 {"type": "Nat.sum (l₁ ++ l₂) = Nat.sum l₁ + Nat.sum l₂",
  "tactic-prompt":
  "theorem  : Nat.sum (l₁ ++ l₂) = Nat.sum l₁ + Nat.sum l₂ := by induction l₁; sorry",
  "name": "sum_append",
  "kind": "theorem",
  "first-tactic": "induction l₁",
  "core-prompt": " : Nat.sum (l₁ ++ l₂) = Nat.sum l₁ + Nat.sum l₂",
  "args": ""},
 {"type": "fdiv 0 b = 0",
  "tactic-prompt": "theorem (b : Int) : fdiv 0 b = 0 := by cases b; sorry",
  "name": "zero_fdiv",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Int) : fdiv 0 b = 0",
  "args": "(b : Int)"},
 {"type": "(-a) / (-b) = a / b",
  "tactic-prompt":
  "theorem (a b : Int) : (-a) / (-b) = a / b := by simp [Int.div_neg]; sorry",
  "name": "neg_div_neg",
  "kind": "theorem",
  "first-tactic": "simp [Int.div_neg]",
  "core-prompt": "(a b : Int) : (-a) / (-b) = a / b",
  "args": "(a b : Int)"},
 {"type": "(a + b).ediv c = a.ediv c + b.ediv c",
  "tactic-prompt":
  "theorem {a b c : Int}  (H : c ∣ a) : (a + b).ediv c = a.ediv c + b.ediv c := by rw [Int.add_comm]; sorry",
  "name": "add_ediv_of_dvd_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt":
  "{a b c : Int}  (H : c ∣ a) : (a + b).ediv c = a.ediv c + b.ediv c",
  "args": "{a b c : Int}  (H : c ∣ a)"},
 {"type": "ediv (a * b) b = a",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (H : b ≠ 0) : ediv (a * b) b = a := by have := Int.add_mul_ediv_right 0 a H; sorry",
  "name": "mul_ediv_cancel",
  "kind": "theorem",
  "first-tactic": "have := Int.add_mul_ediv_right 0 a H",
  "core-prompt": "(a : Int)  {b : Int}  (H : b ≠ 0) : ediv (a * b) b = a",
  "args": "(a : Int)  {b : Int}  (H : b ≠ 0)"},
 {"type": "a / a = 1",
  "tactic-prompt":
  "theorem {a : Int}  (H : a ≠ 0) : a / a = 1 := by have := Int.mul_div_cancel 1 H; sorry",
  "name": "div_self",
  "kind": "theorem",
  "first-tactic": "have := Int.mul_div_cancel 1 H",
  "core-prompt": "{a : Int}  (H : a ≠ 0) : a / a = 1",
  "args": "{a : Int}  (H : a ≠ 0)"},
 {"type": "a.fdiv a = 1",
  "tactic-prompt":
  "theorem {a : Int}  (H : a ≠ 0) : a.fdiv a = 1 := by have := Int.mul_fdiv_cancel 1 H; sorry",
  "name": "fdiv_self",
  "kind": "theorem",
  "first-tactic": "have := Int.mul_fdiv_cancel 1 H",
  "core-prompt": "{a : Int}  (H : a ≠ 0) : a.fdiv a = 1",
  "args": "{a : Int}  (H : a ≠ 0)"},
 {"type": "a.ediv a = 1",
  "tactic-prompt":
  "theorem {a : Int}  (H : a ≠ 0) : a.ediv a = 1 := by have := Int.mul_ediv_cancel 1 H; sorry",
  "name": "ediv_self",
  "kind": "theorem",
  "first-tactic": "have := Int.mul_ediv_cancel 1 H",
  "core-prompt": "{a : Int}  (H : a ≠ 0) : a.ediv a = 1",
  "args": "{a : Int}  (H : a ≠ 0)"},
 {"type": "ofNat (m % n) = fmod m n",
  "tactic-prompt":
  "theorem (m n : Nat) : ofNat (m % n) = fmod m n := by cases m; sorry",
  "name": "ofNat_fmod",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt": "(m n : Nat) : ofNat (m % n) = fmod m n",
  "args": "(m n : Nat)"},
 {"type": "0 % b = 0",
  "tactic-prompt": "theorem (b : Int) : 0 % b = 0 := by cases b; sorry",
  "name": "zero_mod",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Int) : 0 % b = 0",
  "args": "(b : Int)"},
 {"type": "fmod 0 b = 0",
  "tactic-prompt": "theorem (b : Int) : fmod 0 b = 0 := by cases b; sorry",
  "name": "zero_fmod",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Int) : fmod 0 b = 0",
  "args": "(b : Int)"},
 {"type": "emod 0 b = 0",
  "tactic-prompt": "theorem (b : Int) : emod 0 b = 0 := by simp [emod]; sorry",
  "name": "zero_emod",
  "kind": "theorem",
  "first-tactic": "simp [emod]",
  "core-prompt": "(b : Int) : emod 0 b = 0",
  "args": "(b : Int)"},
 {"type": "a % b = a - b * (a / b)",
  "tactic-prompt":
  "theorem (a b : Int) : a % b = a - b * (a / b) := by rw [← Int.add_sub_cancel (a % b)]; sorry",
  "name": "mod_def",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_sub_cancel (a % b)]",
  "core-prompt": "(a b : Int) : a % b = a - b * (a / b)",
  "args": "(a b : Int)"},
 {"type": "a.fmod b = a - b * (a.fdiv b)",
  "tactic-prompt":
  "theorem (a b : Int) : a.fmod b = a - b * (a.fdiv b) := by rw [← Int.add_sub_cancel (a.fmod b)]; sorry",
  "name": "fmod_def",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_sub_cancel (a.fmod b)]",
  "core-prompt": "(a b : Int) : a.fmod b = a - b * (a.fdiv b)",
  "args": "(a b : Int)"},
 {"type": "a.emod b = a - b * (a.ediv b)",
  "tactic-prompt":
  "theorem (a b : Int) : a.emod b = a - b * (a.ediv b) := by rw [← Int.add_sub_cancel (a.emod b)]; sorry",
  "name": "emod_def",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_sub_cancel (a.emod b)]",
  "core-prompt": "(a b : Int) : a.emod b = a - b * (a.ediv b)",
  "args": "(a b : Int)"},
 {"type": "fmod a b = emod a b",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (hb : 0 ≤ b) : fmod a b = emod a b := by simp [fmod_def]; sorry",
  "name": "fmod_eq_emod",
  "kind": "theorem",
  "first-tactic": "simp [fmod_def]",
  "core-prompt": "(a : Int)  {b : Int}  (hb : 0 ≤ b) : fmod a b = emod a b",
  "args": "(a : Int)  {b : Int}  (hb : 0 ≤ b)"},
 {"type": "emod a b = a % b",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : 0 ≤ a)  (hb : 0 ≤ b) : emod a b = a % b := by simp [emod_def]; sorry",
  "name": "emod_eq_mod",
  "kind": "theorem",
  "first-tactic": "simp [emod_def]",
  "core-prompt": "{a b : Int}  (ha : 0 ≤ a)  (hb : 0 ≤ b) : emod a b = a % b",
  "args": "{a b : Int}  (ha : 0 ≤ a)  (hb : 0 ≤ b)"},
 {"type": "a % -b = a % b",
  "tactic-prompt":
  "theorem (a b : Int) : a % -b = a % b := by rw [mod_def]; sorry",
  "name": "mod_neg",
  "kind": "theorem",
  "first-tactic": "rw [mod_def]",
  "core-prompt": "(a b : Int) : a % -b = a % b",
  "args": "(a b : Int)"},
 {"type": "a.emod (-b) = a.emod b",
  "tactic-prompt":
  "theorem (a b : Int) : a.emod (-b) = a.emod b := by rw [emod_def]; sorry",
  "name": "emod_neg",
  "kind": "theorem",
  "first-tactic": "rw [emod_def]",
  "core-prompt": "(a b : Int) : a.emod (-b) = a.emod b",
  "args": "(a b : Int)"},
 {"type": "a % 1 = 0",
  "tactic-prompt": "theorem (a : Int) : a % 1 = 0 := by simp [mod_def]; sorry",
  "name": "mod_one",
  "kind": "theorem",
  "first-tactic": "simp [mod_def]",
  "core-prompt": "(a : Int) : a % 1 = 0",
  "args": "(a : Int)"},
 {"type": "a.emod 1 = 0",
  "tactic-prompt":
  "theorem (a : Int) : a.emod 1 = 0 := by simp [emod_def]; sorry",
  "name": "emod_one",
  "kind": "theorem",
  "first-tactic": "simp [emod_def]",
  "core-prompt": "(a : Int) : a.emod 1 = 0",
  "args": "(a : Int)"},
 {"type": "a.fmod 1 = 0",
  "tactic-prompt":
  "theorem (a : Int) : a.fmod 1 = 0 := by simp [fmod_def]; sorry",
  "name": "fmod_one",
  "kind": "theorem",
  "first-tactic": "simp [fmod_def]",
  "core-prompt": "(a : Int) : a.fmod 1 = 0",
  "args": "(a : Int)"},
 {"type": "a.fmod b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H1 : 0 ≤ a)  (H2 : a < b) : a.fmod b = a := by rw [fmod_eq_mod H1 (Int.le_trans H1 (Int.le_of_lt H2))]; sorry",
  "name": "fmod_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [fmod_eq_mod H1 (Int.le_trans H1 (Int.le_of_lt H2))]",
  "core-prompt": "{a b : Int}  (H1 : 0 ≤ a)  (H2 : a < b) : a.fmod b = a",
  "args": "{a b : Int}  (H1 : 0 ≤ a)  (H2 : a < b)"},
 {"type": "a.emod b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H1 : 0 ≤ a)  (H2 : a < b) : a.emod b = a := by rw [emod_eq_mod H1 (Int.le_trans H1 (Int.le_of_lt H2))]; sorry",
  "name": "emod_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [emod_eq_mod H1 (Int.le_trans H1 (Int.le_of_lt H2))]",
  "core-prompt": "{a b : Int}  (H1 : 0 ≤ a)  (H2 : a < b) : a.emod b = a",
  "args": "{a b : Int}  (H1 : 0 ≤ a)  (H2 : a < b)"},
 {"type": "m % k + m / k * k = m",
  "tactic-prompt":
  "theorem (m k : Int) : m % k + m / k * k = m := by rw [Int.mul_comm]; sorry",
  "name": "mod_add_div'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m k : Int) : m % k + m / k * k = m",
  "args": "(m k : Int)"},
 {"type": "m / k * k + m % k = m",
  "tactic-prompt":
  "theorem (m k : Int) : m / k * k + m % k = m := by rw [Int.mul_comm]; sorry",
  "name": "div_add_mod'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m k : Int) : m / k * k + m % k = m",
  "args": "(m k : Int)"},
 {"type": "m.emod k + m.ediv k * k = m",
  "tactic-prompt":
  "theorem (m k : Int) : m.emod k + m.ediv k * k = m := by rw [Int.mul_comm]; sorry",
  "name": "emod_add_ediv'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m k : Int) : m.emod k + m.ediv k * k = m",
  "args": "(m k : Int)"},
 {"type": "m.ediv k * k + m.emod k = m",
  "tactic-prompt":
  "theorem (m k : Int) : m.ediv k * k + m.emod k = m := by rw [Int.mul_comm]; sorry",
  "name": "ediv_add_emod'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m k : Int) : m.ediv k * k + m.emod k = m",
  "args": "(m k : Int)"},
 {"type": "(a + b * c).emod b = a.emod b",
  "tactic-prompt":
  "theorem (a b c : Int) : (a + b * c).emod b = a.emod b := by rw [Int.mul_comm]; sorry",
  "name": "add_mul_emod_self_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a b c : Int) : (a + b * c).emod b = a.emod b",
  "args": "(a b c : Int)"},
 {"type": "(a + b).emod b = a.emod b",
  "tactic-prompt":
  "theorem {a b : Int} : (a + b).emod b = a.emod b := by have := add_mul_emod_self_left a b 1; sorry",
  "name": "add_emod_self",
  "kind": "theorem",
  "first-tactic": "have := add_mul_emod_self_left a b 1",
  "core-prompt": "{a b : Int} : (a + b).emod b = a.emod b",
  "args": "{a b : Int}"},
 {"type": "(a + b).emod a = b.emod a",
  "tactic-prompt":
  "theorem {a b : Int} : (a + b).emod a = b.emod a := by rw [Int.add_comm]; sorry",
  "name": "add_emod_self_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b : Int} : (a + b).emod a = b.emod a",
  "args": "{a b : Int}"},
 {"type": "(m.emod n + k).emod n = (m + k).emod n",
  "tactic-prompt":
  "theorem (m n k : Int) : (m.emod n + k).emod n = (m + k).emod n := by have := (add_mul_emod_self_left (m.emod n + k) n (m.ediv n)).symm; sorry",
  "name": "emod_add_emod",
  "kind": "theorem",
  "first-tactic":
  "have := (add_mul_emod_self_left (m.emod n + k) n (m.ediv n)).symm",
  "core-prompt": "(m n k : Int) : (m.emod n + k).emod n = (m + k).emod n",
  "args": "(m n k : Int)"},
 {"type": "(m + n.emod k).emod k = (m + n).emod k",
  "tactic-prompt":
  "theorem (m n k : Int) : (m + n.emod k).emod k = (m + n).emod k := by rw [Int.add_comm]; sorry",
  "name": "add_emod_emod",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "(m n k : Int) : (m + n.emod k).emod k = (m + n).emod k",
  "args": "(m n k : Int)"},
 {"type": "(a + b).emod n = (a.emod n + b.emod n).emod n",
  "tactic-prompt":
  "theorem (a b n : Int) : (a + b).emod n = (a.emod n + b.emod n).emod n := by rw [add_emod_emod]; sorry",
  "name": "add_emod",
  "kind": "theorem",
  "first-tactic": "rw [add_emod_emod]",
  "core-prompt":
  "(a b n : Int) : (a + b).emod n = (a.emod n + b.emod n).emod n",
  "args": "(a b n : Int)"},
 {"type": "(m + i).emod n = (k + i).emod n",
  "tactic-prompt":
  "theorem {m n k : Int}  (i : Int)      (H : m.emod n = k.emod n) : (m + i).emod n = (k + i).emod n := by rw [← emod_add_emod]; sorry",
  "name": "add_emod_eq_add_emod_right",
  "kind": "theorem",
  "first-tactic": "rw [← emod_add_emod]",
  "core-prompt":
  "{m n k : Int}  (i : Int)      (H : m.emod n = k.emod n) : (m + i).emod n = (k + i).emod n",
  "args": "{m n k : Int}  (i : Int)      (H : m.emod n = k.emod n)"},
 {"type": "(i + m).emod n = (i + k).emod n",
  "tactic-prompt":
  "theorem {m n k : Int}  (i : Int)      (H : m.emod n = k.emod n) : (i + m).emod n = (i + k).emod n := by rw [Int.add_comm]; sorry",
  "name": "add_emod_eq_add_emod_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt":
  "{m n k : Int}  (i : Int)      (H : m.emod n = k.emod n) : (i + m).emod n = (i + k).emod n",
  "args": "{m n k : Int}  (i : Int)      (H : m.emod n = k.emod n)"},
 {"type": "(i + m).emod n = (i + k).emod n ↔ m.emod n = k.emod n",
  "tactic-prompt":
  "theorem {m n k i : Int} : (i + m).emod n = (i + k).emod n ↔ m.emod n = k.emod n := by rw [Int.add_comm]; sorry",
  "name": "emod_add_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt":
  "{m n k i : Int} : (i + m).emod n = (i + k).emod n ↔ m.emod n = k.emod n",
  "args": "{m n k i : Int}"},
 {"type": "(a * b).emod b = 0",
  "tactic-prompt":
  "theorem (a b : Int) : (a * b).emod b = 0 := by rw [← Int.zero_add (a * b)]; sorry",
  "name": "mul_emod_left",
  "kind": "theorem",
  "first-tactic": "rw [← Int.zero_add (a * b)]",
  "core-prompt": "(a b : Int) : (a * b).emod b = 0",
  "args": "(a b : Int)"},
 {"type": "a * b % a = 0",
  "tactic-prompt":
  "theorem (a b : Int) : a * b % a = 0 := by rw [Int.mul_comm]; sorry",
  "name": "mul_mod_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a b : Int) : a * b % a = 0",
  "args": "(a b : Int)"},
 {"type": "(a * b).fmod a = 0",
  "tactic-prompt":
  "theorem (a b : Int) : (a * b).fmod a = 0 := by rw [Int.mul_comm]; sorry",
  "name": "mul_fmod_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a b : Int) : (a * b).fmod a = 0",
  "args": "(a b : Int)"},
 {"type": "(a * b).emod a = 0",
  "tactic-prompt":
  "theorem (a b : Int) : (a * b).emod a = 0 := by rw [Int.mul_comm]; sorry",
  "name": "mul_emod_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a b : Int) : (a * b).emod a = 0",
  "args": "(a b : Int)"},
 {"type": "(a * b).emod n = (a.emod n * b.emod n).emod n",
  "tactic-prompt":
  "theorem (a b n : Int) : (a * b).emod n = (a.emod n * b.emod n).emod n := by conv => lhs; rw [\n    ← emod_add_ediv a n]; sorry",
  "name": "mul_emod",
  "kind": "theorem",
  "first-tactic": "conv => lhs; rw [\n    ← emod_add_ediv a n]",
  "core-prompt":
  "(a b n : Int) : (a * b).emod n = (a.emod n * b.emod n).emod n",
  "args": "(a b n : Int)"},
 {"type": "a % a = 0",
  "tactic-prompt":
  "theorem {a : Int} : a % a = 0 := by have := mul_mod_left 1 a; sorry",
  "name": "mod_self",
  "kind": "theorem",
  "first-tactic": "have := mul_mod_left 1 a",
  "core-prompt": "{a : Int} : a % a = 0",
  "args": "{a : Int}"},
 {"type": "a.fmod a = 0",
  "tactic-prompt":
  "theorem {a : Int} : a.fmod a = 0 := by have := mul_fmod_left 1 a; sorry",
  "name": "fmod_self",
  "kind": "theorem",
  "first-tactic": "have := mul_fmod_left 1 a",
  "core-prompt": "{a : Int} : a.fmod a = 0",
  "args": "{a : Int}"},
 {"type": "a.emod a = 0",
  "tactic-prompt":
  "theorem {a : Int} : a.emod a = 0 := by have := mul_emod_left 1 a; sorry",
  "name": "emod_self",
  "kind": "theorem",
  "first-tactic": "have := mul_emod_left 1 a",
  "core-prompt": "{a : Int} : a.emod a = 0",
  "args": "{a : Int}"},
 {"type": "(n.emod k).emod m = n.emod m",
  "tactic-prompt":
  "theorem (n : Int)  {m k : Int}      (h : m ∣ k) : (n.emod k).emod m = n.emod m := by conv => rhs; rw [← emod_add_ediv n k]; sorry",
  "name": "emod_emod_of_dvd",
  "kind": "theorem",
  "first-tactic": "conv => rhs; rw [← emod_add_ediv n k]",
  "core-prompt":
  "(n : Int)  {m k : Int}      (h : m ∣ k) : (n.emod k).emod m = n.emod m",
  "args": "(n : Int)  {m k : Int}      (h : m ∣ k)"},
 {"type": "(a.emod b).emod b = a.emod b",
  "tactic-prompt":
  "theorem (a b : Int) : (a.emod b).emod b = a.emod b := by conv => rhs; rw [← emod_add_ediv a b]; sorry",
  "name": "emod_emod",
  "kind": "theorem",
  "first-tactic": "conv => rhs; rw [← emod_add_ediv a b]",
  "core-prompt": "(a b : Int) : (a.emod b).emod b = a.emod b",
  "args": "(a b : Int)"},
 {"type": "(a - b).emod n = (a.emod n - b.emod n).emod n",
  "tactic-prompt":
  "theorem (a b n : Int) : (a - b).emod n = (a.emod n - b.emod n).emod n := by apply (emod_add_cancel_right b).mp; sorry",
  "name": "sub_emod",
  "kind": "theorem",
  "first-tactic": "apply (emod_add_cancel_right b).mp",
  "core-prompt":
  "(a b n : Int) : (a - b).emod n = (a.emod n - b.emod n).emod n",
  "args": "(a b n : Int)"},
 {"type": "a.ediv b = q ∧ a.emod b = r ↔ r + b * q = a ∧ 0 ≤ r ∧ r < b",
  "tactic-prompt":
  "theorem {a b r q : Int}  (h : 0 < b) : a.ediv b = q ∧ a.emod b = r ↔ r + b * q = a ∧ 0 ≤ r ∧ r < b := by constructor; sorry",
  "name": "ediv_emod_unique",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{a b r q : Int}  (h : 0 < b) : a.ediv b = q ∧ a.emod b = r ↔ r + b * q = a ∧ 0 ≤ r ∧ r < b",
  "args": "{a b r q : Int}  (h : 0 < b)"},
 {"type": "(a * b).ediv (c * b) = a.ediv c",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (c : Int)  (H : 0 < b) : (a * b).ediv (c * b) = a.ediv c := by rw [Int.mul_comm]; sorry",
  "name": "mul_ediv_mul_of_pos_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "(a : Int)  {b : Int}  (c : Int)  (H : 0 < b) : (a * b).ediv (c * b) = a.ediv c",
  "args": "(a : Int)  {b : Int}  (c : Int)  (H : 0 < b)"},
 {"type": "(a * b).emod (a * c) = a * (b.emod c)",
  "tactic-prompt":
  "theorem {a : Int}  (b c : Int)  (H : 0 < a) : (a * b).emod (a * c) = a * (b.emod c) := by rw [emod_def]; sorry",
  "name": "mul_emod_mul_of_pos",
  "kind": "theorem",
  "first-tactic": "rw [emod_def]",
  "core-prompt":
  "{a : Int}  (b c : Int)  (H : 0 < a) : (a * b).emod (a * c) = a * (b.emod c)",
  "args": "{a : Int}  (b c : Int)  (H : 0 < a)"},
 {"type": "a < (a / b + 1) * b",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (H : 0 < b) : a < (a / b + 1) * b := by rw [Int.add_mul]; sorry",
  "name": "lt_div_add_one_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_mul]",
  "core-prompt": "(a : Int)  {b : Int}  (H : 0 < b) : a < (a / b + 1) * b",
  "args": "(a : Int)  {b : Int}  (H : 0 < b)"},
 {"type": "a < (a.ediv b + 1) * b",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (H : 0 < b) : a < (a.ediv b + 1) * b := by rw [Int.add_mul]; sorry",
  "name": "lt_ediv_add_one_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_mul]",
  "core-prompt": "(a : Int)  {b : Int}  (H : 0 < b) : a < (a.ediv b + 1) * b",
  "args": "(a : Int)  {b : Int}  (H : 0 < b)"},
 {"type": "a.ediv b ≤ a",
  "tactic-prompt":
  "theorem {a : Int}  (b : Int)  (Ha : 0 ≤ a) : a.ediv b ≤ a := by have := Int.le_trans le_natAbs (ofNat_le.2 <| natAbs_div_le_natAbs a b); sorry",
  "name": "ediv_le_self",
  "kind": "theorem",
  "first-tactic":
  "have := Int.le_trans le_natAbs (ofNat_le.2 <| natAbs_div_le_natAbs a b)",
  "core-prompt": "{a : Int}  (b : Int)  (Ha : 0 ≤ a) : a.ediv b ≤ a",
  "args": "{a : Int}  (b : Int)  (Ha : 0 ≤ a)"},
 {"type": "b * (a / b) = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a % b = 0) : b * (a / b) = a := by have := mod_add_div a b; sorry",
  "name": "mul_div_cancel_of_mod_eq_zero",
  "kind": "theorem",
  "first-tactic": "have := mod_add_div a b",
  "core-prompt": "{a b : Int}  (H : a % b = 0) : b * (a / b) = a",
  "args": "{a b : Int}  (H : a % b = 0)"},
 {"type": "a / b * b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a % b = 0) : a / b * b = a := by rw [Int.mul_comm]; sorry",
  "name": "div_mul_cancel_of_mod_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "{a b : Int}  (H : a % b = 0) : a / b * b = a",
  "args": "{a b : Int}  (H : a % b = 0)"},
 {"type": "b * (a.ediv b) = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a.emod b = 0) : b * (a.ediv b) = a := by have := emod_add_ediv a b; sorry",
  "name": "mul_ediv_cancel_of_emod_eq_zero",
  "kind": "theorem",
  "first-tactic": "have := emod_add_ediv a b",
  "core-prompt": "{a b : Int}  (H : a.emod b = 0) : b * (a.ediv b) = a",
  "args": "{a b : Int}  (H : a.emod b = 0)"},
 {"type": "a.ediv b * b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a.emod b = 0) : a.ediv b * b = a := by rw [Int.mul_comm]; sorry",
  "name": "ediv_mul_cancel_of_emod_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "{a b : Int}  (H : a.emod b = 0) : a.ediv b * b = a",
  "args": "{a b : Int}  (H : a.emod b = 0)"},
 {"type": "-a ∣ b ↔ a ∣ b",
  "tactic-prompt":
  "theorem {a b : Int} : -a ∣ b ↔ a ∣ b := by constructor; sorry",
  "name": "neg_dvd",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{a b : Int} : -a ∣ b ↔ a ∣ b",
  "args": "{a b : Int}"},
 {"type": "a ∣ -b ↔ a ∣ b",
  "tactic-prompt":
  "theorem {a b : Int} : a ∣ -b ↔ a ∣ b := by constructor; sorry",
  "name": "dvd_neg",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{a b : Int} : a ∣ -b ↔ a ∣ b",
  "args": "{a b : Int}"},
 {"type": "a ∣ b + c ↔ a ∣ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (H : a ∣ b) : a ∣ b + c ↔ a ∣ c := by rw [Int.add_comm]; sorry",
  "name": "dvd_add_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b c : Int}  (H : a ∣ b) : a ∣ b + c ↔ a ∣ c",
  "args": "{a b c : Int}  (H : a ∣ b)"},
 {"type": "a ∣ b ↔ a ∣ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (H : a ∣ b + c) : a ∣ b ↔ a ∣ c := by rw [← Int.sub_neg] at H; sorry",
  "name": "dvd_iff_dvd_of_dvd_add",
  "kind": "theorem",
  "first-tactic": "rw [← Int.sub_neg] at H",
  "core-prompt": "{a b c : Int}  (H : a ∣ b + c) : a ∣ b ↔ a ∣ c",
  "args": "{a b c : Int}  (H : a ∣ b + c)"},
 {"type": "(↑m : Int) ∣ ↑n ↔ m ∣ n",
  "tactic-prompt":
  "theorem {m n : Nat} : (↑m : Int) ∣ ↑n ↔ m ∣ n := by refine ⟨fun ⟨a, ae⟩ => ?_, fun ⟨k, e⟩ => ⟨k, by rw [e, Int.ofNat_mul]⟩⟩; sorry",
  "name": "ofNat_dvd",
  "kind": "theorem",
  "first-tactic":
  "refine ⟨fun ⟨a, ae⟩ => ?_, fun ⟨k, e⟩ => ⟨k, by rw [e, Int.ofNat_mul]⟩⟩",
  "core-prompt": "{m n : Nat} : (↑m : Int) ∣ ↑n ↔ m ∣ n",
  "args": "{m n : Nat}"},
 {"type": "natAbs a ∣ natAbs b ↔ a ∣ b",
  "tactic-prompt":
  "theorem {a b : Int} : natAbs a ∣ natAbs b ↔ a ∣ b := by refine ⟨fun ⟨k, hk⟩ => ?_, fun ⟨k, hk⟩ => ⟨natAbs k, hk.symm ▸ natAbs_mul a k⟩⟩; sorry",
  "name": "natAbs_dvd_natAbs",
  "kind": "theorem",
  "first-tactic":
  "refine ⟨fun ⟨k, hk⟩ => ?_, fun ⟨k, hk⟩ => ⟨natAbs k, hk.symm ▸ natAbs_mul a k⟩⟩",
  "core-prompt": "{a b : Int} : natAbs a ∣ natAbs b ↔ a ∣ b",
  "args": "{a b : Int}"},
 {"type": "(↑n : Int) ∣ z ↔ n ∣ z.natAbs",
  "tactic-prompt":
  "theorem {n : Nat}  {z : Int} : (↑n : Int) ∣ z ↔ n ∣ z.natAbs := by rw [← natAbs_dvd_natAbs]; sorry",
  "name": "ofNat_dvd_left",
  "kind": "theorem",
  "first-tactic": "rw [← natAbs_dvd_natAbs]",
  "core-prompt": "{n : Nat}  {z : Int} : (↑n : Int) ∣ z ↔ n ∣ z.natAbs",
  "args": "{n : Nat}  {z : Int}"},
 {"type": "z ∣ (↑n : Int) ↔ z.natAbs ∣ n",
  "tactic-prompt":
  "theorem {n : Nat}  {z : Int} : z ∣ (↑n : Int) ↔ z.natAbs ∣ n := by rw [← natAbs_dvd_natAbs]; sorry",
  "name": "ofNat_dvd_right",
  "kind": "theorem",
  "first-tactic": "rw [← natAbs_dvd_natAbs]",
  "core-prompt": "{n : Nat}  {z : Int} : z ∣ (↑n : Int) ↔ z.natAbs ∣ n",
  "args": "{n : Nat}  {z : Int}"},
 {"type": "a ∣ b → b ∣ a → a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (H1 : 0 ≤ a)  (H2 : 0 ≤ b) : a ∣ b → b ∣ a → a = b := by rw [← natAbs_of_nonneg H1]; sorry",
  "name": "dvd_antisymm",
  "kind": "theorem",
  "first-tactic": "rw [← natAbs_of_nonneg H1]",
  "core-prompt":
  "{a b : Int}  (H1 : 0 ≤ a)  (H2 : 0 ≤ b) : a ∣ b → b ∣ a → a = b",
  "args": "{a b : Int}  (H1 : 0 ≤ a)  (H2 : 0 ≤ b)"},
 {"type": "b ∣ a - c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a.emod b = c) : b ∣ a - c := by have hx : (a.emod b).emod b = c.emod b := by\n    rw [h]; sorry",
  "name": "dvd_sub_of_emod_eq",
  "kind": "theorem",
  "first-tactic": "have hx : (a.emod b).emod b = c.emod b := by\n    rw [h]",
  "core-prompt": "{a b c : Int}  (h : a.emod b = c) : b ∣ a - c",
  "args": "{a b c : Int}  (h : a.emod b = c)"},
 {"type": "a * (b / a) = b",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a ∣ b) : a * (b / a) = b := by rw [Int.mul_comm]; sorry",
  "name": "mul_div_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "{a b : Int}  (H : a ∣ b) : a * (b / a) = b",
  "args": "{a b : Int}  (H : a ∣ b)"},
 {"type": "a * (b.ediv a) = b",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a ∣ b) : a * (b.ediv a) = b := by rw [Int.mul_comm]; sorry",
  "name": "mul_ediv_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "{a b : Int}  (H : a ∣ b) : a * (b.ediv a) = b",
  "args": "{a b : Int}  (H : a ∣ b)"},
 {"type": "a * b / c = a / c * b",
  "tactic-prompt":
  "theorem (b : Int)  {a c : Int}  (h : c ∣ a) : a * b / c = a / c * b := by rw [Int.mul_comm]; sorry",
  "name": "mul_div_assoc'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(b : Int)  {a c : Int}  (h : c ∣ a) : a * b / c = a / c * b",
  "args": "(b : Int)  {a c : Int}  (h : c ∣ a)"},
 {"type": "(a * b).ediv c = a.ediv c * b",
  "tactic-prompt":
  "theorem (b : Int)  {a c : Int}      (h : c ∣ a) : (a * b).ediv c = a.ediv c * b := by rw [Int.mul_comm]; sorry",
  "name": "mul_ediv_assoc'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "(b : Int)  {a c : Int}      (h : c ∣ a) : (a * b).ediv c = a.ediv c * b",
  "args": "(b : Int)  {a c : Int}      (h : c ∣ a)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b ∣ a)  (H2 : a / b = c) : a = b * c := by rw [← H2]; sorry",
  "name": "eq_mul_of_div_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [← H2]",
  "core-prompt":
  "{a b c : Int}      (H1 : b ∣ a)  (H2 : a / b = c) : a = b * c",
  "args": "{a b c : Int}      (H1 : b ∣ a)  (H2 : a / b = c)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b ∣ a)  (H2 : a.ediv b = c) : a = b * c := by rw [← H2]; sorry",
  "name": "eq_mul_of_ediv_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [← H2]",
  "core-prompt":
  "{a b c : Int}      (H1 : b ∣ a)  (H2 : a.ediv b = c) : a = b * c",
  "args": "{a b c : Int}      (H1 : b ∣ a)  (H2 : a.ediv b = c)"},
 {"type": "a / b = c",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b ≠ 0)  (H2 : a = b * c) : a / b = c := by rw [H2]; sorry",
  "name": "div_eq_of_eq_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [H2]",
  "core-prompt":
  "{a b c : Int}      (H1 : b ≠ 0)  (H2 : a = b * c) : a / b = c",
  "args": "{a b c : Int}      (H1 : b ≠ 0)  (H2 : a = b * c)"},
 {"type": "a.ediv b = c",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b ≠ 0)  (H2 : a = b * c) : a.ediv b = c := by rw [H2]; sorry",
  "name": "ediv_eq_of_eq_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [H2]",
  "core-prompt":
  "{a b c : Int}      (H1 : b ≠ 0)  (H2 : a = b * c) : a.ediv b = c",
  "args": "{a b c : Int}      (H1 : b ≠ 0)  (H2 : a = b * c)"},
 {"type": "a / b = c ↔ a = c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (H : b ≠ 0)  (H' : b ∣ a) : a / b = c ↔ a = c * b := by rw [Int.mul_comm]; sorry",
  "name": "div_eq_iff_eq_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (H : b ≠ 0)  (H' : b ∣ a) : a / b = c ↔ a = c * b",
  "args": "{a b c : Int}      (H : b ≠ 0)  (H' : b ∣ a)"},
 {"type": "a.ediv b = c ↔ a = c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (H : b ≠ 0)  (H' : b ∣ a) : a.ediv b = c ↔ a = c * b := by rw [Int.mul_comm]; sorry",
  "name": "ediv_eq_iff_eq_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (H : b ≠ 0)  (H' : b ∣ a) : a.ediv b = c ↔ a = c * b",
  "args": "{a b c : Int}      (H : b ≠ 0)  (H' : b ∣ a)"},
 {"type": "a = c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b ∣ a)  (H2 : a / b = c) : a = c * b := by rw [Int.mul_comm]; sorry",
  "name": "eq_mul_of_div_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (H1 : b ∣ a)  (H2 : a / b = c) : a = c * b",
  "args": "{a b c : Int}      (H1 : b ∣ a)  (H2 : a / b = c)"},
 {"type": "a = c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b ∣ a)  (H2 : a.ediv b = c) : a = c * b := by rw [Int.mul_comm]; sorry",
  "name": "eq_mul_of_ediv_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (H1 : b ∣ a)  (H2 : a.ediv b = c) : a = c * b",
  "args": "{a b c : Int}      (H1 : b ∣ a)  (H2 : a.ediv b = c)"},
 {"type": "n = 0",
  "tactic-prompt":
  "theorem {d n : Int}  (h : d ∣ n)  (H : n / d = 0) : n = 0 := by rw [← Int.mul_div_cancel' h]; sorry",
  "name": "eq_zero_of_div_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [← Int.mul_div_cancel' h]",
  "core-prompt": "{d n : Int}  (h : d ∣ n)  (H : n / d = 0) : n = 0",
  "args": "{d n : Int}  (h : d ∣ n)  (H : n / d = 0)"},
 {"type": "n = 0",
  "tactic-prompt":
  "theorem {d n : Int}  (h : d ∣ n)  (H : n.ediv d = 0) : n = 0 := by rw [← Int.mul_ediv_cancel' h]; sorry",
  "name": "eq_zero_of_ediv_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [← Int.mul_ediv_cancel' h]",
  "core-prompt": "{d n : Int}  (h : d ∣ n)  (H : n.ediv d = 0) : n = 0",
  "args": "{d n : Int}  (h : d ∣ n)  (H : n.ediv d = 0)"},
 {"type": "(a - b).ediv c = a.ediv c - b.ediv c",
  "tactic-prompt":
  "theorem (a : Int)  {b c : Int}      (hcb : c ∣ b) : (a - b).ediv c = a.ediv c - b.ediv c := by rw [Int.sub_eq_add_neg]; sorry",
  "name": "sub_ediv_of_dvd",
  "kind": "theorem",
  "first-tactic": "rw [Int.sub_eq_add_neg]",
  "core-prompt":
  "(a : Int)  {b c : Int}      (hcb : c ∣ b) : (a - b).ediv c = a.ediv c - b.ediv c",
  "args": "(a : Int)  {b c : Int}      (hcb : c ∣ b)"},
 {"type": "(a - b).ediv c = a.ediv c - b.ediv c",
  "tactic-prompt":
  "theorem {a b c : Int}      (hcab : c ∣ a - b) : (a - b).ediv c = a.ediv c - b.ediv c := by rw [← Int.add_sub_cancel ((a-b).ediv c)]; sorry",
  "name": "sub_ediv_of_dvd_sub",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_sub_cancel ((a-b).ediv c)]",
  "core-prompt":
  "{a b c : Int}      (hcab : c ∣ a - b) : (a - b).ediv c = a.ediv c - b.ediv c",
  "args": "{a b c : Int}      (hcab : c ∣ a - b)"},
 {"type": "a / d = b / d ↔ a = b",
  "tactic-prompt":
  "theorem {a b d : Int}      (hda : d ∣ a)  (hdb : d ∣ b) : a / d = b / d ↔ a = b := by refine ⟨fun h => ?_, congrArg (· / d)⟩; sorry",
  "name": "div_left_inj",
  "kind": "theorem",
  "first-tactic": "refine ⟨fun h => ?_, congrArg (· / d)⟩",
  "core-prompt":
  "{a b d : Int}      (hda : d ∣ a)  (hdb : d ∣ b) : a / d = b / d ↔ a = b",
  "args": "{a b d : Int}      (hda : d ∣ a)  (hdb : d ∣ b)"},
 {"type": "a.ediv d = b.ediv d ↔ a = b",
  "tactic-prompt":
  "theorem {a b d : Int}      (hda : d ∣ a)  (hdb : d ∣ b) : a.ediv d = b.ediv d ↔ a = b := by refine ⟨fun h => ?_, congrArg (ediv · d)⟩; sorry",
  "name": "ediv_left_inj",
  "kind": "theorem",
  "first-tactic": "refine ⟨fun h => ?_, congrArg (ediv · d)⟩",
  "core-prompt":
  "{a b d : Int}      (hda : d ∣ a)  (hdb : d ∣ b) : a.ediv d = b.ediv d ↔ a = b",
  "args": "{a b d : Int}      (hda : d ∣ a)  (hdb : d ∣ b)"},
 {"type": "a ≤ c * b",
  "tactic-prompt":
  "theorem {a b c : Int}  (H1 : 0 ≤ b)  (H2 : b ∣ a)  (H3 : a / b ≤ c) : a ≤ c * b := by rw [← Int.div_mul_cancel H2]; sorry",
  "name": "le_mul_of_div_le",
  "kind": "theorem",
  "first-tactic": "rw [← Int.div_mul_cancel H2]",
  "core-prompt":
  "{a b c : Int}  (H1 : 0 ≤ b)  (H2 : b ∣ a)  (H3 : a / b ≤ c) : a ≤ c * b",
  "args": "{a b c : Int}  (H1 : 0 ≤ b)  (H2 : b ∣ a)  (H3 : a / b ≤ c)"},
 {"type": "a = c / b * d",
  "tactic-prompt":
  "theorem {a b c d : Int}  (hb : b ≠ 0)  (hbc : b ∣ c)  (h : b * a = c * d) : a = c / b * d := by cases' hbc with k hk; sorry",
  "name": "eq_mul_div_of_mul_eq_mul_of_dvd_left",
  "kind": "theorem",
  "first-tactic": "cases' hbc with k hk",
  "core-prompt":
  "{a b c d : Int}  (hb : b ≠ 0)  (hbc : b ∣ c)  (h : b * a = c * d) : a = c / b * d",
  "args": "{a b c d : Int}  (hb : b ≠ 0)  (hbc : b ∣ c)  (h : b * a = c * d)"},
 {"type": "b = 0",
  "tactic-prompt":
  "theorem {a b : Int}  (w : a ∣ b)  (h : natAbs b < natAbs a) : b = 0 := by rw [← natAbs_dvd]; sorry",
  "name": "eq_zero_of_dvd_ofNatAbs_lt_natAbs",
  "kind": "theorem",
  "first-tactic": "rw [← natAbs_dvd]",
  "core-prompt": "{a b : Int}  (w : a ∣ b)  (h : natAbs b < natAbs a) : b = 0",
  "args": "{a b : Int}  (w : a ∣ b)  (h : natAbs b < natAbs a)"},
 {"type": "t / s ∣ t",
  "tactic-prompt":
  "theorem {s t : Int}  (hst : s ∣ t) : t / s ∣ t := by rcases eq_or_ne s 0 with (rfl | hs); sorry",
  "name": "div_dvd_of_dvd",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne s 0 with (rfl | hs)",
  "core-prompt": "{s t : Int}  (hst : s ∣ t) : t / s ∣ t",
  "args": "{s t : Int}  (hst : s ∣ t)"},
 {"type": "b ∣ c / a",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a * b ∣ c) : b ∣ c / a := by rcases eq_or_ne a 0 with (rfl | ha); sorry",
  "name": "dvd_div_of_mul_dvd",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne a 0 with (rfl | ha)",
  "core-prompt": "{a b c : Int}  (h : a * b ∣ c) : b ∣ c / a",
  "args": "{a b c : Int}  (h : a * b ∣ c)"},
 {"type": "subNatNat m n = ofNat (m - n)",
  "tactic-prompt":
  "theorem {m n : Nat}  (h : n - m = 0) : subNatNat m n = ofNat (m - n) := by rw [subNatNat]; sorry",
  "name": "subNatNat_of_sub_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [subNatNat]",
  "core-prompt": "{m n : Nat}  (h : n - m = 0) : subNatNat m n = ofNat (m - n)",
  "args": "{m n : Nat}  (h : n - m = 0)"},
 {"type": "subNatNat (m + n) m = ofNat n",
  "tactic-prompt":
  "theorem  : subNatNat (m + n) m = ofNat n := by unfold subNatNat; sorry",
  "name": "subNatNat_add_left",
  "kind": "theorem",
  "first-tactic": "unfold subNatNat",
  "core-prompt": " : subNatNat (m + n) m = ofNat n",
  "args": ""},
 {"type": "subNatNat m (m + n + 1) = negSucc n",
  "tactic-prompt":
  "theorem  : subNatNat m (m + n + 1) = negSucc n := by simp [subNatNat]; sorry",
  "name": "subNatNat_add_right",
  "kind": "theorem",
  "first-tactic": "simp [subNatNat]",
  "core-prompt": " : subNatNat m (m + n + 1) = negSucc n",
  "args": ""},
 {"type": "subNatNat (m + k) (n + k) = subNatNat m n",
  "tactic-prompt":
  "theorem (m n k : Nat) : subNatNat (m + k) (n + k) = subNatNat m n := by apply subNatNat_elim m n (fun m n i => subNatNat (m + k) (n + k) = i); sorry",
  "name": "subNatNat_add_add",
  "kind": "theorem",
  "first-tactic":
  "apply subNatNat_elim m n (fun m n i => subNatNat (m + k) (n + k) = i)",
  "core-prompt": "(m n k : Nat) : subNatNat (m + k) (n + k) = subNatNat m n",
  "args": "(m n k : Nat)"},
 {"type": "0 < natAbs a ↔ a ≠ 0",
  "tactic-prompt":
  "theorem  : 0 < natAbs a ↔ a ≠ 0 := by rw [Nat.pos_iff_ne_zero]; sorry",
  "name": "natAbs_pos",
  "kind": "theorem",
  "first-tactic": "rw [Nat.pos_iff_ne_zero]",
  "core-prompt": " : 0 < natAbs a ↔ a ≠ 0",
  "args": ""},
 {"type": "natAbs (negOfNat n) = n",
  "tactic-prompt":
  "theorem (n : Nat) : natAbs (negOfNat n) = n := by cases n; sorry",
  "name": "natAbs_negOfNat",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n : Nat) : natAbs (negOfNat n) = n",
  "args": "(n : Nat)"},
 {"type": "natAbs (a * b) = natAbs a * natAbs b",
  "tactic-prompt":
  "theorem (a b : Int) : natAbs (a * b) = natAbs a * natAbs b := by cases a; sorry",
  "name": "natAbs_mul",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b : Int) : natAbs (a * b) = natAbs a * natAbs b",
  "args": "(a b : Int)"},
 {"type": "a.natAbs * b.natAbs = c",
  "tactic-prompt":
  "theorem {a b : Int}  {c : Nat}      (h : a * b = (c : Int)) : a.natAbs * b.natAbs = c := by rw [← natAbs_mul]; sorry",
  "name": "natAbs_mul_natAbs_eq",
  "kind": "theorem",
  "first-tactic": "rw [← natAbs_mul]",
  "core-prompt":
  "{a b : Int}  {c : Nat}      (h : a * b = (c : Int)) : a.natAbs * b.natAbs = c",
  "args": "{a b : Int}  {c : Nat}      (h : a * b = (c : Int))"},
 {"type": "(natAbs a * natAbs a : Int) = a * a",
  "tactic-prompt":
  "theorem (a : Int) : (natAbs a * natAbs a : Int) = a * a := by rw [← Int.ofNat_mul]; sorry",
  "name": "natAbs_mul_self'",
  "kind": "theorem",
  "first-tactic": "rw [← Int.ofNat_mul]",
  "core-prompt": "(a : Int) : (natAbs a * natAbs a : Int) = a * a",
  "args": "(a : Int)"},
 {"type": "a.natAbs = b.natAbs ↔ a = b ∨ a = -b",
  "tactic-prompt":
  "theorem {a b : Int} : a.natAbs = b.natAbs ↔ a = b ∨ a = -b := by constructor; sorry",
  "name": "natAbs_eq_natAbs_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{a b : Int} : a.natAbs = b.natAbs ↔ a = b ∨ a = -b",
  "args": "{a b : Int}"},
 {"type": "a.natAbs = n ↔ a = n ∨ a = -↑n",
  "tactic-prompt":
  "theorem {a : Int}  {n : Nat} : a.natAbs = n ↔ a = n ∨ a = -↑n := by rw [← Int.natAbs_eq_natAbs_iff]; sorry",
  "name": "natAbs_eq_iff",
  "kind": "theorem",
  "first-tactic": "rw [← Int.natAbs_eq_natAbs_iff]",
  "core-prompt": "{a : Int}  {n : Nat} : a.natAbs = n ↔ a = n ∨ a = -↑n",
  "args": "{a : Int}  {n : Nat}"},
 {"type": "z.sign.natAbs = 1",
  "tactic-prompt":
  "theorem {z : Int}  (hz : z ≠ 0) : z.sign.natAbs = 1 := by rw [Int.natAbs_sign]; sorry",
  "name": "natAbs_sign_of_nonzero",
  "kind": "theorem",
  "first-tactic": "rw [Int.natAbs_sign]",
  "core-prompt": "{z : Int}  (hz : z ≠ 0) : z.sign.natAbs = 1",
  "args": "{z : Int}  (hz : z ≠ 0)"},
 {"type": "subNatNat (m - n) k = subNatNat m (k + n)",
  "tactic-prompt":
  "theorem (h : n ≤ m)  (k : Nat) : subNatNat (m - n) k = subNatNat m (k + n) := by rwa [← subNatNat_add_add _ _ n]; sorry",
  "name": "subNatNat_sub",
  "kind": "theorem",
  "first-tactic": "rwa [← subNatNat_add_add _ _ n]",
  "core-prompt":
  "(h : n ≤ m)  (k : Nat) : subNatNat (m - n) k = subNatNat m (k + n)",
  "args": "(h : n ≤ m)  (k : Nat)"},
 {"type": "subNatNat (m + n) k = ofNat m + subNatNat n k",
  "tactic-prompt":
  "theorem (m n k : Nat) : subNatNat (m + n) k = ofNat m + subNatNat n k := by cases n.lt_or_ge k; sorry",
  "name": "subNatNat_add",
  "kind": "theorem",
  "first-tactic": "cases n.lt_or_ge k",
  "core-prompt":
  "(m n k : Nat) : subNatNat (m + n) k = ofNat m + subNatNat n k",
  "args": "(m n k : Nat)"},
 {"type": "a + (b + c) = b + (a + c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a + (b + c) = b + (a + c) := by rw [← Int.add_assoc]; sorry",
  "name": "add_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_assoc]",
  "core-prompt": "(a b c : Int) : a + (b + c) = b + (a + c)",
  "args": "(a b c : Int)"},
 {"type": "a + b + c = a + c + b",
  "tactic-prompt":
  "theorem (a b c : Int) : a + b + c = a + c + b := by rw [Int.add_assoc]; sorry",
  "name": "add_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_assoc]",
  "core-prompt": "(a b c : Int) : a + b + c = a + c + b",
  "args": "(a b c : Int)"},
 {"type": "a + -a = 0",
  "tactic-prompt":
  "theorem (a : Int) : a + -a = 0 := by rw [Int.add_comm]; sorry",
  "name": "add_right_neg",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "(a : Int) : a + -a = 0",
  "args": "(a : Int)"},
 {"type": "-a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a + b = 0) : -a = b := by rw [← Int.add_zero (-a)]; sorry",
  "name": "neg_eq_of_add_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_zero (-a)]",
  "core-prompt": "{a b : Int}  (h : a + b = 0) : -a = b",
  "args": "{a b : Int}  (h : a + b = 0)"},
 {"type": "b = -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a = -b) : b = -a := by rw [h]; sorry",
  "name": "eq_neg_of_eq_neg",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{a b : Int}  (h : a = -b) : b = -a",
  "args": "{a b : Int}  (h : a = -b)"},
 {"type": "-a + (a + b) = b",
  "tactic-prompt":
  "theorem (a b : Int) : -a + (a + b) = b := by rw [← Int.add_assoc]; sorry",
  "name": "neg_add_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_assoc]",
  "core-prompt": "(a b : Int) : -a + (a + b) = b",
  "args": "(a b : Int)"},
 {"type": "a + (-a + b) = b",
  "tactic-prompt":
  "theorem (a b : Int) : a + (-a + b) = b := by rw [← Int.add_assoc]; sorry",
  "name": "add_neg_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_assoc]",
  "core-prompt": "(a b : Int) : a + (-a + b) = b",
  "args": "(a b : Int)"},
 {"type": "a + b + -b = a",
  "tactic-prompt":
  "theorem (a b : Int) : a + b + -b = a := by rw [Int.add_assoc]; sorry",
  "name": "add_neg_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_assoc]",
  "core-prompt": "(a b : Int) : a + b + -b = a",
  "args": "(a b : Int)"},
 {"type": "a + -b + b = a",
  "tactic-prompt":
  "theorem (a b : Int) : a + -b + b = a := by rw [Int.add_assoc]; sorry",
  "name": "neg_add_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_assoc]",
  "core-prompt": "(a b : Int) : a + -b + b = a",
  "args": "(a b : Int)"},
 {"type": "b = c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b = a + c) : b = c := by have h₁ : -a + (a + b) = -a + (a + c) := by rw [h]; sorry",
  "name": "add_left_cancel",
  "kind": "theorem",
  "first-tactic": "have h₁ : -a + (a + b) = -a + (a + c) := by rw [h]",
  "core-prompt": "{a b c : Int}  (h : a + b = a + c) : b = c",
  "args": "{a b c : Int}  (h : a + b = a + c)"},
 {"type": "-(a + b) = -a + -b",
  "tactic-prompt":
  "theorem {a b : Int} : -(a + b) = -a + -b := by apply Int.add_left_cancel (a := a + b); sorry",
  "name": "neg_add",
  "kind": "theorem",
  "first-tactic": "apply Int.add_left_cancel (a := a + b)",
  "core-prompt": "{a b : Int} : -(a + b) = -a + -b",
  "args": "{a b : Int}"},
 {"type": "a - a = 0",
  "tactic-prompt":
  "theorem (a : Int) : a - a = 0 := by rw [Int.sub_eq_add_neg]; sorry",
  "name": "sub_self",
  "kind": "theorem",
  "first-tactic": "rw [Int.sub_eq_add_neg]",
  "core-prompt": "(a : Int) : a - a = 0",
  "args": "(a : Int)"},
 {"type": "a - b = 0",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a = b) : a - b = 0 := by rw [h]; sorry",
  "name": "sub_eq_zero_of_eq",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{a b : Int}  (h : a = b) : a - b = 0",
  "args": "{a b : Int}  (h : a = b)"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a - b = 0) : a = b := by have : 0 + b = b := by rw [Int.zero_add]; sorry",
  "name": "eq_of_sub_eq_zero",
  "kind": "theorem",
  "first-tactic": "have : 0 + b = b := by rw [Int.zero_add]",
  "core-prompt": "{a b : Int}  (h : a - b = 0) : a = b",
  "args": "{a b : Int}  (h : a - b = 0)"},
 {"type": "a - b - c = a - (b + c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a - b - c = a - (b + c) := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "sub_sub",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : Int) : a - b - c = a - (b + c)",
  "args": "(a b c : Int)"},
 {"type": "-(a - b) = b - a",
  "tactic-prompt":
  "theorem (a b : Int) : -(a - b) = b - a := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "neg_sub",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b : Int) : -(a - b) = b - a",
  "args": "(a b : Int)"},
 {"type": "a - (a - b) = b",
  "tactic-prompt":
  "theorem (a b : Int) : a - (a - b) = b := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "sub_sub_self",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b : Int) : a - (a - b) = b",
  "args": "(a b : Int)"},
 {"type": "a - -b = a + b",
  "tactic-prompt":
  "theorem (a b : Int) : a - -b = a + b := by simp [Int.sub_eq_add_neg]\n\n/- ## multiplication -/; sorry",
  "name": "sub_neg",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]\n\n/- ## multiplication -/",
  "core-prompt": "(a b : Int) : a - -b = a + b",
  "args": "(a b : Int)"},
 {"type": "a * b = b * a",
  "tactic-prompt": "theorem (a b : Int) : a * b = b * a := by cases a; sorry",
  "name": "mul_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b : Int) : a * b = b * a",
  "args": "(a b : Int)"},
 {"type": "ofNat m * negOfNat n = negOfNat (m * n)",
  "tactic-prompt":
  "theorem (m n : Nat) : ofNat m * negOfNat n = negOfNat (m * n) := by cases n; sorry",
  "name": "ofNat_mul_negOfNat",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(m n : Nat) : ofNat m * negOfNat n = negOfNat (m * n)",
  "args": "(m n : Nat)"},
 {"type": "negOfNat m * ofNat n = negOfNat (m * n)",
  "tactic-prompt":
  "theorem (m n : Nat) : negOfNat m * ofNat n = negOfNat (m * n) := by rw [Int.mul_comm]; sorry",
  "name": "negOfNat_mul_ofNat",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m n : Nat) : negOfNat m * ofNat n = negOfNat (m * n)",
  "args": "(m n : Nat)"},
 {"type": "a * b * c = a * (b * c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a * b * c = a * (b * c) := by cases a; sorry",
  "name": "mul_assoc",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : Int) : a * b * c = a * (b * c)",
  "args": "(a b c : Int)"},
 {"type": "a * (b * c) = b * (a * c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a * (b * c) = b * (a * c) := by rw [← Int.mul_assoc]; sorry",
  "name": "mul_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [← Int.mul_assoc]",
  "core-prompt": "(a b c : Int) : a * (b * c) = b * (a * c)",
  "args": "(a b c : Int)"},
 {"type": "a * b * c = a * c * b",
  "tactic-prompt":
  "theorem (a b c : Int) : a * b * c = a * c * b := by rw [Int.mul_assoc]; sorry",
  "name": "mul_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_assoc]",
  "core-prompt": "(a b c : Int) : a * b * c = a * c * b",
  "args": "(a b c : Int)"},
 {"type": "a * 0 = 0",
  "tactic-prompt": "theorem (a : Int) : a * 0 = 0 := by cases a; sorry",
  "name": "mul_zero",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a : Int) : a * 0 = 0",
  "args": "(a : Int)"},
 {"type": "ofNat m * subNatNat n k = subNatNat (m * n) (m * k)",
  "tactic-prompt":
  "theorem (m n k : Nat) : ofNat m * subNatNat n k = subNatNat (m * n) (m * k) := by cases m; sorry",
  "name": "ofNat_mul_subNatNat",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt":
  "(m n k : Nat) : ofNat m * subNatNat n k = subNatNat (m * n) (m * k)",
  "args": "(m n k : Nat)"},
 {"type": "negOfNat m + negOfNat n = negOfNat (m + n)",
  "tactic-prompt":
  "theorem (m n : Nat) : negOfNat m + negOfNat n = negOfNat (m + n) := by cases m; sorry",
  "name": "negOfNat_add",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt": "(m n : Nat) : negOfNat m + negOfNat n = negOfNat (m + n)",
  "args": "(m n : Nat)"},
 {"type": "(a + b) * c = a * c + b * c",
  "tactic-prompt":
  "theorem (a b c : Int) : (a + b) * c = a * c + b * c := by simp [Int.mul_comm]; sorry",
  "name": "add_mul",
  "kind": "theorem",
  "first-tactic": "simp [Int.mul_comm]",
  "core-prompt": "(a b c : Int) : (a + b) * c = a * c + b * c",
  "args": "(a b c : Int)"},
 {"type": "-a * -b = a * b",
  "tactic-prompt": "theorem (a b : Int) : -a * -b = a * b := by simp; sorry",
  "name": "neg_mul_neg",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : Int) : -a * -b = a * b",
  "args": "(a b : Int)"},
 {"type": "-a * b = a * -b",
  "tactic-prompt": "theorem (a b : Int) : -a * b = a * -b := by simp; sorry",
  "name": "neg_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : Int) : -a * b = a * -b",
  "args": "(a b : Int)"},
 {"type": "a * (b - c) = a * b - a * c",
  "tactic-prompt":
  "theorem (a b c : Int) : a * (b - c) = a * b - a * c := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "mul_sub",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : Int) : a * (b - c) = a * b - a * c",
  "args": "(a b c : Int)"},
 {"type": "(a - b) * c = a * c - b * c",
  "tactic-prompt":
  "theorem (a b c : Int) : (a - b) * c = a * c - b * c := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "sub_mul",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : Int) : (a - b) * c = a * c - b * c",
  "args": "(a b c : Int)"},
 {"type": "a + b - c = a + (b - c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a + b - c = a + (b - c) := by rw [Int.sub_eq_add_neg]; sorry",
  "name": "add_sub_assoc",
  "kind": "theorem",
  "first-tactic": "rw [Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : Int) : a + b - c = a + (b - c)",
  "args": "(a b c : Int)"},
 {"type": "ofNat (n - m) = ofNat n - ofNat m",
  "tactic-prompt":
  "theorem (h : m ≤ n) : ofNat (n - m) = ofNat n - ofNat m := by match m with\n  | 0 => rfl\n  | succ m =>\n    show ofNat (n - succ m) = subNatNat n (succ m)\n    rw [subNatNat]; sorry",
  "name": "ofNat_sub",
  "kind": "theorem",
  "first-tactic":
  "match m with\n  | 0 => rfl\n  | succ m =>\n    show ofNat (n - succ m) = subNatNat n (succ m)\n    rw [subNatNat]",
  "core-prompt": "(h : m ≤ n) : ofNat (n - m) = ofNat n - ofNat m",
  "args": "(h : m ≤ n)"},
 {"type": "subNatNat m n = ↑m - ↑n",
  "tactic-prompt":
  "theorem {m n : Nat} : subNatNat m n = ↑m - ↑n := by apply subNatNat_elim m n fun m n i => i = m - n; sorry",
  "name": "subNatNat_eq_coe",
  "kind": "theorem",
  "first-tactic": "apply subNatNat_elim m n fun m n i => i = m - n",
  "core-prompt": "{m n : Nat} : subNatNat m n = ↑m - ↑n",
  "args": "{m n : Nat}"},
 {"type": "a * 1 = a",
  "tactic-prompt":
  "theorem (a : Int) : a * 1 = a := by rw [Int.mul_comm]; sorry",
  "name": "mul_one",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a : Int) : a * 1 = a",
  "args": "(a : Int)"},
 {"type": "a * -1 = -a",
  "tactic-prompt":
  "theorem (a : Int) : a * -1 = -a := by rw [Int.mul_neg]; sorry",
  "name": "mul_neg_one",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_neg]",
  "core-prompt": "(a : Int) : a * -1 = -a",
  "args": "(a : Int)"},
 {"type": "a ≤ b",
  "tactic-prompt":
  "theorem {a b : Int}  (n : Nat)  (h : b - a = n) : a ≤ b := by simp [le_def]; sorry",
  "name": "le.intro_sub",
  "kind": "theorem",
  "first-tactic": "simp [le_def]",
  "core-prompt": "{a b : Int}  (n : Nat)  (h : b - a = n) : a ≤ b",
  "args": "{a b : Int}  (n : Nat)  (h : b - a = n)"},
 {"type": "∃ n : Nat, a = n",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 ≤ a) : ∃ n : Nat, a = n := by have t := le.dest_sub h; sorry",
  "name": "eq_ofNat_of_zero_le",
  "kind": "theorem",
  "first-tactic": "have t := le.dest_sub h",
  "core-prompt": "{a : Int}  (h : 0 ≤ a) : ∃ n : Nat, a = n",
  "args": "{a : Int}  (h : 0 ≤ a)"},
 {"type": "(↑n : Int) < ↑m ↔ n < m",
  "tactic-prompt":
  "theorem {n m : Nat} : (↑n : Int) < ↑m ↔ n < m := by rw [lt_iff_add_one_le]; sorry",
  "name": "ofNat_lt",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_add_one_le]",
  "core-prompt": "{n m : Nat} : (↑n : Int) < ↑m ↔ n < m",
  "args": "{n m : Nat}"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (h₁ : a ≤ b)  (h₂ : b ≤ a) : a = b := by let ⟨n, hn⟩ := le.dest h₁; sorry",
  "name": "le_antisymm",
  "kind": "theorem",
  "first-tactic": "let ⟨n, hn⟩ := le.dest h₁",
  "core-prompt": "{a b : Int}  (h₁ : a ≤ b)  (h₂ : b ≤ a) : a = b",
  "args": "{a b : Int}  (h₁ : a ≤ b)  (h₂ : b ≤ a)"},
 {"type": "a < b ↔ a ≤ b ∧ a ≠ b",
  "tactic-prompt":
  "theorem {a b : Int} : a < b ↔ a ≤ b ∧ a ≠ b := by refine ⟨fun h => ⟨Int.le_of_lt h, Int.ne_of_lt h⟩, fun ⟨aleb, aneb⟩ => ?_⟩; sorry",
  "name": "lt_iff_le_and_ne",
  "kind": "theorem",
  "first-tactic":
  "refine ⟨fun h => ⟨Int.le_of_lt h, Int.ne_of_lt h⟩, fun ⟨aleb, aneb⟩ => ?_⟩",
  "core-prompt": "{a b : Int} : a < b ↔ a ≤ b ∧ a ≠ b",
  "args": "{a b : Int}"},
 {"type": "0 ≤ a * b",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : 0 ≤ a)  (hb : 0 ≤ b) : 0 ≤ a * b := by let ⟨n, hn⟩ := eq_ofNat_of_zero_le ha; sorry",
  "name": "mul_nonneg",
  "kind": "theorem",
  "first-tactic": "let ⟨n, hn⟩ := eq_ofNat_of_zero_le ha",
  "core-prompt": "{a b : Int}  (ha : 0 ≤ a)  (hb : 0 ≤ b) : 0 ≤ a * b",
  "args": "{a b : Int}  (ha : 0 ≤ a)  (hb : 0 ≤ b)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b := by let ⟨n, hn⟩ := eq_succ_of_zero_lt ha; sorry",
  "name": "mul_pos",
  "kind": "theorem",
  "first-tactic": "let ⟨n, hn⟩ := eq_succ_of_zero_lt ha",
  "core-prompt": "{a b : Int}  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b",
  "args": "{a b : Int}  (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "tactic-prompt":
  "theorem {a b : Int} : a < b ↔ a ≤ b ∧ ¬b ≤ a := by rw [Int.lt_iff_le_and_ne]; sorry",
  "name": "lt_iff_le_not_le",
  "kind": "theorem",
  "first-tactic": "rw [Int.lt_iff_le_and_ne]",
  "core-prompt": "{a b : Int} : a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "args": "{a b : Int}"},
 {"type": "¬a < b ↔ b ≤ a",
  "tactic-prompt":
  "theorem {a b : Int} : ¬a < b ↔ b ≤ a := by rw [← Int.not_le]; sorry",
  "name": "not_lt",
  "kind": "theorem",
  "first-tactic": "rw [← Int.not_le]",
  "core-prompt": "{a b : Int} : ¬a < b ↔ b ≤ a",
  "args": "{a b : Int}"},
 {"type": "a = natAbs a",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 ≤ a) : a = natAbs a := by let ⟨n, e⟩ := eq_ofNat_of_zero_le h; sorry",
  "name": "eq_natAbs_of_zero_le",
  "kind": "theorem",
  "first-tactic": "let ⟨n, e⟩ := eq_ofNat_of_zero_le h",
  "core-prompt": "{a : Int}  (h : 0 ≤ a) : a = natAbs a",
  "args": "{a : Int}  (h : 0 ≤ a)"},
 {"type": "b ≤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b ≤ a + c) : b ≤ c := by have : -a + (a + b) ≤ -a + (a + c) := Int.add_le_add_left h _; sorry",
  "name": "le_of_add_le_add_left",
  "kind": "theorem",
  "first-tactic":
  "have : -a + (a + b) ≤ -a + (a + c) := Int.add_le_add_left h _",
  "core-prompt": "{a b c : Int}  (h : a + b ≤ a + c) : b ≤ c",
  "args": "{a b c : Int}  (h : a + b ≤ a + c)"},
 {"type": "b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b < a + c) : b < c := by have : -a + (a + b) < -a + (a + c) := Int.add_lt_add_left h _; sorry",
  "name": "lt_of_add_lt_add_left",
  "kind": "theorem",
  "first-tactic":
  "have : -a + (a + b) < -a + (a + c) := Int.add_lt_add_left h _",
  "core-prompt": "{a b c : Int}  (h : a + b < a + c) : b < c",
  "args": "{a b c : Int}  (h : a + b < a + c)"},
 {"type": "a ≤ a + b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : 0 ≤ b) : a ≤ a + b := by have : a + b ≥ a + 0 := Int.add_le_add_left h a; sorry",
  "name": "le_add_of_nonneg_right",
  "kind": "theorem",
  "first-tactic": "have : a + b ≥ a + 0 := Int.add_le_add_left h a",
  "core-prompt": "{a b : Int}  (h : 0 ≤ b) : a ≤ a + b",
  "args": "{a b : Int}  (h : 0 ≤ b)"},
 {"type": "a ≤ b + a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : 0 ≤ b) : a ≤ b + a := by have : 0 + a ≤ b + a := Int.add_le_add_right h a; sorry",
  "name": "le_add_of_nonneg_left",
  "kind": "theorem",
  "first-tactic": "have : 0 + a ≤ b + a := Int.add_le_add_right h a",
  "core-prompt": "{a b : Int}  (h : 0 ≤ b) : a ≤ b + a",
  "args": "{a b : Int}  (h : 0 ≤ b)"},
 {"type": "a < a + b",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (h : 0 < b) : a < a + b := by have : a + 0 < a + b := Int.add_lt_add_left h a; sorry",
  "name": "lt_add_of_pos_right",
  "kind": "theorem",
  "first-tactic": "have : a + 0 < a + b := Int.add_lt_add_left h a",
  "core-prompt": "(a : Int)  {b : Int}  (h : 0 < b) : a < a + b",
  "args": "(a : Int)  {b : Int}  (h : 0 < b)"},
 {"type": "a < b + a",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (h : 0 < b) : a < b + a := by have : 0 + a < b + a := Int.add_lt_add_right h a; sorry",
  "name": "lt_add_of_pos_left",
  "kind": "theorem",
  "first-tactic": "have : 0 + a < b + a := Int.add_lt_add_right h a",
  "core-prompt": "(a : Int)  {b : Int}  (h : 0 < b) : a < b + a",
  "args": "(a : Int)  {b : Int}  (h : 0 < b)"},
 {"type": "-b ≤ -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a ≤ b) : -b ≤ -a := by have : 0 ≤ -a + b := Int.add_left_neg a ▸ Int.add_le_add_left h (-a); sorry",
  "name": "neg_le_neg",
  "kind": "theorem",
  "first-tactic":
  "have : 0 ≤ -a + b := Int.add_left_neg a ▸ Int.add_le_add_left h (-a)",
  "core-prompt": "{a b : Int}  (h : a ≤ b) : -b ≤ -a",
  "args": "{a b : Int}  (h : a ≤ b)"},
 {"type": "-a ≤ 0",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 ≤ a) : -a ≤ 0 := by have : -a ≤ -0 := Int.neg_le_neg h; sorry",
  "name": "neg_nonpos_of_nonneg",
  "kind": "theorem",
  "first-tactic": "have : -a ≤ -0 := Int.neg_le_neg h",
  "core-prompt": "{a : Int}  (h : 0 ≤ a) : -a ≤ 0",
  "args": "{a : Int}  (h : 0 ≤ a)"},
 {"type": "0 ≤ -a",
  "tactic-prompt":
  "theorem {a : Int}  (h : a ≤ 0) : 0 ≤ -a := by have : -0 ≤ -a := Int.neg_le_neg h; sorry",
  "name": "neg_nonneg_of_nonpos",
  "kind": "theorem",
  "first-tactic": "have : -0 ≤ -a := Int.neg_le_neg h",
  "core-prompt": "{a : Int}  (h : a ≤ 0) : 0 ≤ -a",
  "args": "{a : Int}  (h : a ≤ 0)"},
 {"type": "-b < -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a < b) : -b < -a := by have : 0 < -a + b := Int.add_left_neg a ▸ Int.add_lt_add_left h (-a); sorry",
  "name": "neg_lt_neg",
  "kind": "theorem",
  "first-tactic":
  "have : 0 < -a + b := Int.add_left_neg a ▸ Int.add_lt_add_left h (-a)",
  "core-prompt": "{a b : Int}  (h : a < b) : -b < -a",
  "args": "{a b : Int}  (h : a < b)"},
 {"type": "-a < 0",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 < a) : -a < 0 := by have : -a < -0 := Int.neg_lt_neg h; sorry",
  "name": "neg_neg_of_pos",
  "kind": "theorem",
  "first-tactic": "have : -a < -0 := Int.neg_lt_neg h",
  "core-prompt": "{a : Int}  (h : 0 < a) : -a < 0",
  "args": "{a : Int}  (h : 0 < a)"},
 {"type": "0 < -a",
  "tactic-prompt":
  "theorem {a : Int}  (h : a < 0) : 0 < -a := by have : -0 < -a := Int.neg_lt_neg h; sorry",
  "name": "neg_pos_of_neg",
  "kind": "theorem",
  "first-tactic": "have : -0 < -a := Int.neg_lt_neg h",
  "core-prompt": "{a : Int}  (h : a < 0) : 0 < -a",
  "args": "{a : Int}  (h : a < 0)"},
 {"type": "b ≤ -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a ≤ -b) : b ≤ -a := by have h := Int.neg_le_neg h; sorry",
  "name": "le_neg_of_le_neg",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_le_neg h",
  "core-prompt": "{a b : Int}  (h : a ≤ -b) : b ≤ -a",
  "args": "{a b : Int}  (h : a ≤ -b)"},
 {"type": "-b ≤ a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : -a ≤ b) : -b ≤ a := by have h := Int.neg_le_neg h; sorry",
  "name": "neg_le_of_neg_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_le_neg h",
  "core-prompt": "{a b : Int}  (h : -a ≤ b) : -b ≤ a",
  "args": "{a b : Int}  (h : -a ≤ b)"},
 {"type": "b < -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a < -b) : b < -a := by have h := Int.neg_lt_neg h; sorry",
  "name": "lt_neg_of_lt_neg",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_lt_neg h",
  "core-prompt": "{a b : Int}  (h : a < -b) : b < -a",
  "args": "{a b : Int}  (h : a < -b)"},
 {"type": "-b < a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : -a < b) : -b < a := by have h := Int.neg_lt_neg h; sorry",
  "name": "neg_lt_of_neg_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_lt_neg h",
  "core-prompt": "{a b : Int}  (h : -a < b) : -b < a",
  "args": "{a b : Int}  (h : -a < b)"},
 {"type": "0 ≤ a - b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : b ≤ a) : 0 ≤ a - b := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "sub_nonneg_of_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b : Int}  (h : b ≤ a) : 0 ≤ a - b",
  "args": "{a b : Int}  (h : b ≤ a)"},
 {"type": "b ≤ a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : 0 ≤ a - b) : b ≤ a := by have h := Int.add_le_add_right h b; sorry",
  "name": "le_of_sub_nonneg",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b : Int}  (h : 0 ≤ a - b) : b ≤ a",
  "args": "{a b : Int}  (h : 0 ≤ a - b)"},
 {"type": "a - b ≤ 0",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a ≤ b) : a - b ≤ 0 := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "sub_nonpos_of_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b : Int}  (h : a ≤ b) : a - b ≤ 0",
  "args": "{a b : Int}  (h : a ≤ b)"},
 {"type": "a ≤ b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a - b ≤ 0) : a ≤ b := by have h := Int.add_le_add_right h b; sorry",
  "name": "le_of_sub_nonpos",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b : Int}  (h : a - b ≤ 0) : a ≤ b",
  "args": "{a b : Int}  (h : a - b ≤ 0)"},
 {"type": "0 < a - b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : b < a) : 0 < a - b := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "sub_pos_of_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b : Int}  (h : b < a) : 0 < a - b",
  "args": "{a b : Int}  (h : b < a)"},
 {"type": "b < a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : 0 < a - b) : b < a := by have h := Int.add_lt_add_right h b; sorry",
  "name": "lt_of_sub_pos",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b : Int}  (h : 0 < a - b) : b < a",
  "args": "{a b : Int}  (h : 0 < a - b)"},
 {"type": "a - b < 0",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a < b) : a - b < 0 := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "sub_neg_of_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b : Int}  (h : a < b) : a - b < 0",
  "args": "{a b : Int}  (h : a < b)"},
 {"type": "a < b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a - b < 0) : a < b := by have h := Int.add_lt_add_right h b; sorry",
  "name": "lt_of_sub_neg",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b : Int}  (h : a - b < 0) : a < b",
  "args": "{a b : Int}  (h : a - b < 0)"},
 {"type": "a + b ≤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : b ≤ -a + c) : a + b ≤ c := by have h := Int.add_le_add_left h a; sorry",
  "name": "add_le_of_le_neg_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h a",
  "core-prompt": "{a b c : Int}  (h : b ≤ -a + c) : a + b ≤ c",
  "args": "{a b c : Int}  (h : b ≤ -a + c)"},
 {"type": "b ≤ -a + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b ≤ c) : b ≤ -a + c := by have h := Int.add_le_add_left h (-a); sorry",
  "name": "le_neg_add_of_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h (-a)",
  "core-prompt": "{a b c : Int}  (h : a + b ≤ c) : b ≤ -a + c",
  "args": "{a b c : Int}  (h : a + b ≤ c)"},
 {"type": "a + b ≤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : b ≤ c - a) : a + b ≤ c := by have h := Int.add_le_add_left h a; sorry",
  "name": "add_le_of_le_sub_left",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h a",
  "core-prompt": "{a b c : Int}  (h : b ≤ c - a) : a + b ≤ c",
  "args": "{a b c : Int}  (h : b ≤ c - a)"},
 {"type": "b ≤ c - a",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b ≤ c) : b ≤ c - a := by have h := Int.add_le_add_right h (-a); sorry",
  "name": "le_sub_left_of_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-a)",
  "core-prompt": "{a b c : Int}  (h : a + b ≤ c) : b ≤ c - a",
  "args": "{a b c : Int}  (h : a + b ≤ c)"},
 {"type": "a + b ≤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a ≤ c - b) : a + b ≤ c := by have h := Int.add_le_add_right h b; sorry",
  "name": "add_le_of_le_sub_right",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b c : Int}  (h : a ≤ c - b) : a + b ≤ c",
  "args": "{a b c : Int}  (h : a ≤ c - b)"},
 {"type": "a ≤ c - b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b ≤ c) : a ≤ c - b := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "le_sub_right_of_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b c : Int}  (h : a + b ≤ c) : a ≤ c - b",
  "args": "{a b c : Int}  (h : a + b ≤ c)"},
 {"type": "a ≤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -b + a ≤ c) : a ≤ b + c := by have h := Int.add_le_add_left h b; sorry",
  "name": "le_add_of_neg_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h b",
  "core-prompt": "{a b c : Int}  (h : -b + a ≤ c) : a ≤ b + c",
  "args": "{a b c : Int}  (h : -b + a ≤ c)"},
 {"type": "-b + a ≤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a ≤ b + c) : -b + a ≤ c := by have h := Int.add_le_add_left h (-b); sorry",
  "name": "neg_add_le_of_le_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h (-b)",
  "core-prompt": "{a b c : Int}  (h : a ≤ b + c) : -b + a ≤ c",
  "args": "{a b c : Int}  (h : a ≤ b + c)"},
 {"type": "a ≤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a - b ≤ c) : a ≤ b + c := by have h := Int.add_le_add_right h b; sorry",
  "name": "le_add_of_sub_left_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b c : Int}  (h : a - b ≤ c) : a ≤ b + c",
  "args": "{a b c : Int}  (h : a - b ≤ c)"},
 {"type": "a - b ≤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a ≤ b + c) : a - b ≤ c := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "sub_left_le_of_le_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b c : Int}  (h : a ≤ b + c) : a - b ≤ c",
  "args": "{a b c : Int}  (h : a ≤ b + c)"},
 {"type": "a ≤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a - c ≤ b) : a ≤ b + c := by have h := Int.add_le_add_right h c; sorry",
  "name": "le_add_of_sub_right_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h c",
  "core-prompt": "{a b c : Int}  (h : a - c ≤ b) : a ≤ b + c",
  "args": "{a b c : Int}  (h : a - c ≤ b)"},
 {"type": "a - c ≤ b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a ≤ b + c) : a - c ≤ b := by have h := Int.add_le_add_right h (-c); sorry",
  "name": "sub_right_le_of_le_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-c)",
  "core-prompt": "{a b c : Int}  (h : a ≤ b + c) : a - c ≤ b",
  "args": "{a b c : Int}  (h : a ≤ b + c)"},
 {"type": "a ≤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -b + a ≤ c) : a ≤ b + c := by rw [Int.add_comm] at h; sorry",
  "name": "le_add_of_neg_add_le_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : -b + a ≤ c) : a ≤ b + c",
  "args": "{a b c : Int}  (h : -b + a ≤ c)"},
 {"type": "-b + a ≤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a ≤ b + c) : -b + a ≤ c := by rw [Int.add_comm]; sorry",
  "name": "neg_add_le_left_of_le_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b c : Int}  (h : a ≤ b + c) : -b + a ≤ c",
  "args": "{a b c : Int}  (h : a ≤ b + c)"},
 {"type": "a ≤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -c + a ≤ b) : a ≤ b + c := by rw [Int.add_comm] at h; sorry",
  "name": "le_add_of_neg_add_le_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : -c + a ≤ b) : a ≤ b + c",
  "args": "{a b c : Int}  (h : -c + a ≤ b)"},
 {"type": "-c + a ≤ b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a ≤ b + c) : -c + a ≤ b := by rw [Int.add_comm] at h; sorry",
  "name": "neg_add_le_right_of_le_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : a ≤ b + c) : -c + a ≤ b",
  "args": "{a b c : Int}  (h : a ≤ b + c)"},
 {"type": "-a ≤ b - c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : c ≤ a + b) : -a ≤ b - c := by have h := Int.le_neg_add_of_add_le (Int.sub_left_le_of_le_add h); sorry",
  "name": "neg_le_sub_left_of_le_add",
  "kind": "theorem",
  "first-tactic":
  "have h := Int.le_neg_add_of_add_le (Int.sub_left_le_of_le_add h)",
  "core-prompt": "{a b c : Int}  (h : c ≤ a + b) : -a ≤ b - c",
  "args": "{a b c : Int}  (h : c ≤ a + b)"},
 {"type": "a + b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : b < -a + c) : a + b < c := by have h := Int.add_lt_add_left h a; sorry",
  "name": "add_lt_of_lt_neg_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h a",
  "core-prompt": "{a b c : Int}  (h : b < -a + c) : a + b < c",
  "args": "{a b c : Int}  (h : b < -a + c)"},
 {"type": "b < -a + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b < c) : b < -a + c := by have h := Int.add_lt_add_left h (-a); sorry",
  "name": "lt_neg_add_of_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h (-a)",
  "core-prompt": "{a b c : Int}  (h : a + b < c) : b < -a + c",
  "args": "{a b c : Int}  (h : a + b < c)"},
 {"type": "a + b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : b < c - a) : a + b < c := by have h := Int.add_lt_add_left h a; sorry",
  "name": "add_lt_of_lt_sub_left",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h a",
  "core-prompt": "{a b c : Int}  (h : b < c - a) : a + b < c",
  "args": "{a b c : Int}  (h : b < c - a)"},
 {"type": "b < c - a",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b < c) : b < c - a := by have h := Int.add_lt_add_right h (-a); sorry",
  "name": "lt_sub_left_of_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-a)",
  "core-prompt": "{a b c : Int}  (h : a + b < c) : b < c - a",
  "args": "{a b c : Int}  (h : a + b < c)"},
 {"type": "a + b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < c - b) : a + b < c := by have h := Int.add_lt_add_right h b; sorry",
  "name": "add_lt_of_lt_sub_right",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b c : Int}  (h : a < c - b) : a + b < c",
  "args": "{a b c : Int}  (h : a < c - b)"},
 {"type": "a < c - b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b < c) : a < c - b := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "lt_sub_right_of_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b c : Int}  (h : a + b < c) : a < c - b",
  "args": "{a b c : Int}  (h : a + b < c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -b + a < c) : a < b + c := by have h := Int.add_lt_add_left h b; sorry",
  "name": "lt_add_of_neg_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h b",
  "core-prompt": "{a b c : Int}  (h : -b + a < c) : a < b + c",
  "args": "{a b c : Int}  (h : -b + a < c)"},
 {"type": "-b + a < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : -b + a < c := by have h := Int.add_lt_add_left h (-b); sorry",
  "name": "neg_add_lt_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h (-b)",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : -b + a < c",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a - b < c) : a < b + c := by have h := Int.add_lt_add_right h b; sorry",
  "name": "lt_add_of_sub_left_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b c : Int}  (h : a - b < c) : a < b + c",
  "args": "{a b c : Int}  (h : a - b < c)"},
 {"type": "a - b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : a - b < c := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "sub_left_lt_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : a - b < c",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a - c < b) : a < b + c := by have h := Int.add_lt_add_right h c; sorry",
  "name": "lt_add_of_sub_right_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h c",
  "core-prompt": "{a b c : Int}  (h : a - c < b) : a < b + c",
  "args": "{a b c : Int}  (h : a - c < b)"},
 {"type": "a - c < b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : a - c < b := by have h := Int.add_lt_add_right h (-c); sorry",
  "name": "sub_right_lt_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-c)",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : a - c < b",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -b + a < c) : a < b + c := by rw [Int.add_comm] at h; sorry",
  "name": "lt_add_of_neg_add_lt_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : -b + a < c) : a < b + c",
  "args": "{a b c : Int}  (h : -b + a < c)"},
 {"type": "-b + a < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : -b + a < c := by rw [Int.add_comm]; sorry",
  "name": "neg_add_lt_left_of_lt_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : -b + a < c",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -c + a < b) : a < b + c := by rw [Int.add_comm] at h; sorry",
  "name": "lt_add_of_neg_add_lt_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : -c + a < b) : a < b + c",
  "args": "{a b c : Int}  (h : -c + a < b)"},
 {"type": "-c + a < b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : -c + a < b := by rw [Int.add_comm] at h; sorry",
  "name": "neg_add_lt_right_of_lt_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : -c + a < b",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "-a < b - c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : c < a + b) : -a < b - c := by have h := Int.lt_neg_add_of_add_lt (Int.sub_left_lt_of_lt_add h); sorry",
  "name": "neg_lt_sub_left_of_lt_add",
  "kind": "theorem",
  "first-tactic":
  "have h := Int.lt_neg_add_of_add_lt (Int.sub_left_lt_of_lt_add h)",
  "core-prompt": "{a b c : Int}  (h : c < a + b) : -a < b - c",
  "args": "{a b c : Int}  (h : c < a + b)"},
 {"type": "c * a < c * b",
  "tactic-prompt":
  "theorem {a b c : Int}    (h₁ : a < b)  (h₂ : 0 < c) : c * a < c * b := by have : 0 < c * (b - a) := Int.mul_pos h₂ (Int.sub_pos_of_lt h₁); sorry",
  "name": "mul_lt_mul_of_pos_left",
  "kind": "theorem",
  "first-tactic":
  "have : 0 < c * (b - a) := Int.mul_pos h₂ (Int.sub_pos_of_lt h₁)",
  "core-prompt": "{a b c : Int}    (h₁ : a < b)  (h₂ : 0 < c) : c * a < c * b",
  "args": "{a b c : Int}    (h₁ : a < b)  (h₂ : 0 < c)"},
 {"type": "a * c < b * c",
  "tactic-prompt":
  "theorem {a b c : Int}    (h₁ : a < b)  (h₂ : 0 < c) : a * c < b * c := by have : 0 < b - a := Int.sub_pos_of_lt h₁; sorry",
  "name": "mul_lt_mul_of_pos_right",
  "kind": "theorem",
  "first-tactic": "have : 0 < b - a := Int.sub_pos_of_lt h₁",
  "core-prompt": "{a b c : Int}    (h₁ : a < b)  (h₂ : 0 < c) : a * c < b * c",
  "args": "{a b c : Int}    (h₁ : a < b)  (h₂ : 0 < c)"},
 {"type": "c * a ≤ c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (h₁ : a ≤ b)  (h₂ : 0 ≤ c) : c * a ≤ c * b := by if hba : b ≤ a then rw [Int.le_antisymm hba h₁]; apply Int.le_refl else\n  if hc0 : c ≤ 0 then simp [Int.le_antisymm hc0 h₂]; sorry",
  "name": "mul_le_mul_of_nonneg_left",
  "kind": "theorem",
  "first-tactic":
  "if hba : b ≤ a then rw [Int.le_antisymm hba h₁]; apply Int.le_refl else\n  if hc0 : c ≤ 0 then simp [Int.le_antisymm hc0 h₂]",
  "core-prompt":
  "{a b c : Int}      (h₁ : a ≤ b)  (h₂ : 0 ≤ c) : c * a ≤ c * b",
  "args": "{a b c : Int}      (h₁ : a ≤ b)  (h₂ : 0 ≤ c)"},
 {"type": "a * c ≤ b * c",
  "tactic-prompt":
  "theorem {a b c : Int}      (h₁ : a ≤ b)  (h₂ : 0 ≤ c) : a * c ≤ b * c := by rw [Int.mul_comm]; sorry",
  "name": "mul_le_mul_of_nonneg_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (h₁ : a ≤ b)  (h₂ : 0 ≤ c) : a * c ≤ b * c",
  "args": "{a b c : Int}      (h₁ : a ≤ b)  (h₂ : 0 ≤ c)"},
 {"type": "a * b ≤ 0",
  "tactic-prompt":
  "theorem {a b : Int}    (ha : 0 ≤ a)  (hb : b ≤ 0) : a * b ≤ 0 := by have h : a * b ≤ a * 0 := Int.mul_le_mul_of_nonneg_left hb ha; sorry",
  "name": "mul_nonpos_of_nonneg_of_nonpos",
  "kind": "theorem",
  "first-tactic":
  "have h : a * b ≤ a * 0 := Int.mul_le_mul_of_nonneg_left hb ha",
  "core-prompt": "{a b : Int}    (ha : 0 ≤ a)  (hb : b ≤ 0) : a * b ≤ 0",
  "args": "{a b : Int}    (ha : 0 ≤ a)  (hb : b ≤ 0)"},
 {"type": "a * b ≤ 0",
  "tactic-prompt":
  "theorem {a b : Int}    (ha : a ≤ 0)  (hb : 0 ≤ b) : a * b ≤ 0 := by have h : a * b ≤ 0 * b := Int.mul_le_mul_of_nonneg_right ha hb; sorry",
  "name": "mul_nonpos_of_nonpos_of_nonneg",
  "kind": "theorem",
  "first-tactic":
  "have h : a * b ≤ 0 * b := Int.mul_le_mul_of_nonneg_right ha hb",
  "core-prompt": "{a b : Int}    (ha : a ≤ 0)  (hb : 0 ≤ b) : a * b ≤ 0",
  "args": "{a b : Int}    (ha : a ≤ 0)  (hb : 0 ≤ b)"},
 {"type": "a * b < 0",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : 0 < a)  (hb : b < 0) : a * b < 0 := by have h : a * b < a * 0 := Int.mul_lt_mul_of_pos_left hb ha; sorry",
  "name": "mul_neg_of_pos_of_neg",
  "kind": "theorem",
  "first-tactic": "have h : a * b < a * 0 := Int.mul_lt_mul_of_pos_left hb ha",
  "core-prompt": "{a b : Int}  (ha : 0 < a)  (hb : b < 0) : a * b < 0",
  "args": "{a b : Int}  (ha : 0 < a)  (hb : b < 0)"},
 {"type": "a * b < 0",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : a < 0)  (hb : 0 < b) : a * b < 0 := by have h : a * b < 0 * b := Int.mul_lt_mul_of_pos_right ha hb; sorry",
  "name": "mul_neg_of_neg_of_pos",
  "kind": "theorem",
  "first-tactic": "have h : a * b < 0 * b := Int.mul_lt_mul_of_pos_right ha hb",
  "core-prompt": "{a b : Int}  (ha : a < 0)  (hb : 0 < b) : a * b < 0",
  "args": "{a b : Int}  (ha : a < 0)  (hb : 0 < b)"},
 {"type": "0 ≤ a * b",
  "tactic-prompt":
  "theorem {a b : Int}    (ha : a ≤ 0)  (hb : b ≤ 0) : 0 ≤ a * b := by have : 0 * b ≤ a * b := Int.mul_le_mul_of_nonpos_right ha hb; sorry",
  "name": "mul_nonneg_of_nonpos_of_nonpos",
  "kind": "theorem",
  "first-tactic":
  "have : 0 * b ≤ a * b := Int.mul_le_mul_of_nonpos_right ha hb",
  "core-prompt": "{a b : Int}    (ha : a ≤ 0)  (hb : b ≤ 0) : 0 ≤ a * b",
  "args": "{a b : Int}    (ha : a ≤ 0)  (hb : b ≤ 0)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : a < 0)  (hb : b < 0) : 0 < a * b := by have : 0 * b < a * b := Int.mul_lt_mul_of_neg_right ha hb; sorry",
  "name": "mul_pos_of_neg_of_neg",
  "kind": "theorem",
  "first-tactic": "have : 0 * b < a * b := Int.mul_lt_mul_of_neg_right ha hb",
  "core-prompt": "{a b : Int}  (ha : a < 0)  (hb : b < 0) : 0 < a * b",
  "args": "{a b : Int}  (ha : a < 0)  (hb : b < 0)"},
 {"type": "(natAbs a : Int) = -a",
  "tactic-prompt":
  "theorem {a : Int}  (H : a ≤ 0) : (natAbs a : Int) = -a := by rw [← natAbs_neg]; sorry",
  "name": "ofNat_natAbs_of_nonpos",
  "kind": "theorem",
  "first-tactic": "rw [← natAbs_neg]",
  "core-prompt": "{a : Int}  (H : a ≤ 0) : (natAbs a : Int) = -a",
  "args": "{a : Int}  (H : a ≤ 0)"},
 {"type": "a * b = 0 ↔ a = 0 ∨ b = 0",
  "tactic-prompt":
  "theorem {a b : Int} : a * b = 0 ↔ a = 0 ∨ b = 0 := by refine ⟨fun h => ?_, fun h => h.elim (by simp [·, Int.zero_mul]) (by simp [·, Int.mul_zero])⟩; sorry",
  "name": "mul_eq_zero",
  "kind": "theorem",
  "first-tactic":
  "refine ⟨fun h => ?_, fun h => h.elim (by simp [·, Int.zero_mul]) (by simp [·, Int.mul_zero])⟩",
  "core-prompt": "{a b : Int} : a * b = 0 ↔ a = 0 ∨ b = 0",
  "args": "{a b : Int}"},
 {"type": "natAbs a = n ↔ (a - n) * (a + n) = 0",
  "tactic-prompt":
  "theorem  : natAbs a = n ↔ (a - n) * (a + n) = 0 := by rw [natAbs_eq_iff]; sorry",
  "name": "eq_natAbs_iff_mul_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [natAbs_eq_iff]",
  "core-prompt": " : natAbs a = n ↔ (a - n) * (a + n) = 0",
  "args": ""},
 {"type": "as.toArray.size = as.length",
  "tactic-prompt":
  "theorem (as : List α) : as.toArray.size = as.length := by simp [size]; sorry",
  "name": "size_toArray",
  "kind": "theorem",
  "first-tactic": "simp [size]",
  "core-prompt": "(as : List α) : as.toArray.size = as.length",
  "args": "(as : List α)"},
 {"type": "a[i] = a.data.get ⟨i, h⟩",
  "tactic-prompt":
  "theorem (a : Array α)  (h : i < a.size) : a[i] = a.data.get ⟨i, h⟩ := by by_cases i < a.size; sorry",
  "name": "getElem_eq_data_get",
  "kind": "theorem",
  "first-tactic": "by_cases i < a.size",
  "core-prompt": "(a : Array α)  (h : i < a.size) : a[i] = a.data.get ⟨i, h⟩",
  "args": "(a : Array α)  (h : i < a.size)"},
 {"type": "arr.foldlM f init = arr.data.foldlM f init",
  "tactic-prompt":
  "theorem [Monad m]      (f : β → α → m β)  (init : β)  (arr : Array α) : arr.foldlM f init = arr.data.foldlM f init := by simp [foldlM]; sorry",
  "name": "foldlM_eq_foldlM_data",
  "kind": "theorem",
  "first-tactic": "simp [foldlM]",
  "core-prompt":
  "[Monad m]      (f : β → α → m β)  (init : β)  (arr : Array α) : arr.foldlM f init = arr.data.foldlM f init",
  "args": "[Monad m]      (f : β → α → m β)  (init : β)  (arr : Array α)"},
 {"type": "arr.foldrM f init = arr.data.reverse.foldlM (fun x y => f y x) init",
  "tactic-prompt":
  "theorem [Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α) : arr.foldrM f init = arr.data.reverse.foldlM (fun x y => f y x) init := by have : arr = #[] ∨ 0 < arr.size :=\n    match arr with | ⟨[]⟩ => .inl rfl | ⟨a::l⟩ => .inr (Nat.zero_lt_succ _); sorry",
  "name": "foldrM_eq_reverse_foldlM_data",
  "kind": "theorem",
  "first-tactic":
  "have : arr = #[] ∨ 0 < arr.size :=\n    match arr with | ⟨[]⟩ => .inl rfl | ⟨a::l⟩ => .inr (Nat.zero_lt_succ _)",
  "core-prompt":
  "[Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α) : arr.foldrM f init = arr.data.reverse.foldlM (fun x y => f y x) init",
  "args": "[Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α)"},
 {"type": "arr.foldrM f init = arr.data.foldrM f init",
  "tactic-prompt":
  "theorem [Monad m]      (f : α → β → m β)  (init : β)  (arr : Array α) : arr.foldrM f init = arr.data.foldrM f init := by rw [foldrM_eq_reverse_foldlM_data]; sorry",
  "name": "foldrM_eq_foldrM_data",
  "kind": "theorem",
  "first-tactic": "rw [foldrM_eq_reverse_foldlM_data]",
  "core-prompt":
  "[Monad m]      (f : α → β → m β)  (init : β)  (arr : Array α) : arr.foldrM f init = arr.data.foldrM f init",
  "args": "[Monad m]      (f : α → β → m β)  (init : β)  (arr : Array α)"},
 {"type": "(arr.push a).data = arr.data ++ [a]",
  "tactic-prompt":
  "theorem (arr : Array α)  (a : α) : (arr.push a).data = arr.data ++ [a] := by simp [push]; sorry",
  "name": "push_data",
  "kind": "theorem",
  "first-tactic": "simp [push]",
  "core-prompt":
  "(arr : Array α)  (a : α) : (arr.push a).data = arr.data ++ [a]",
  "args": "(arr : Array α)  (a : α)"},
 {"type": "(arr.push a).foldrM f init = f a init >>= arr.foldrM f",
  "tactic-prompt":
  "theorem [Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α)  (a : α) : (arr.push a).foldrM f init = f a init >>= arr.foldrM f := by simp [foldrM_eq_reverse_foldlM_data]; sorry",
  "name": "foldrM_push",
  "kind": "theorem",
  "first-tactic": "simp [foldrM_eq_reverse_foldlM_data]",
  "core-prompt":
  "[Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α)  (a : α) : (arr.push a).foldrM f init = f a init >>= arr.foldrM f",
  "args": "[Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α)  (a : α)"},
 {"type":
  "(arr.push a).foldrM f init (start := arr.size + 1) = f a init >>= arr.foldrM f",
  "tactic-prompt":
  "theorem [Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α)  (a : α) : (arr.push a).foldrM f init (start := arr.size + 1) = f a init >>= arr.foldrM f := by simp [← foldrM_push]; sorry",
  "name": "foldrM_push'",
  "kind": "theorem",
  "first-tactic": "simp [← foldrM_push]",
  "core-prompt":
  "[Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α)  (a : α) : (arr.push a).foldrM f init (start := arr.size + 1) = f a init >>= arr.foldrM f",
  "args": "[Monad m]  (f : α → β → m β)  (init : β)  (arr : Array α)  (a : α)"},
 {"type": "arr.toList = arr.data",
  "tactic-prompt":
  "theorem (arr : Array α) : arr.toList = arr.data := by simp [toList]; sorry",
  "name": "toList_eq",
  "kind": "theorem",
  "first-tactic": "simp [toList]",
  "core-prompt": "(arr : Array α) : arr.toList = arr.data",
  "args": "(arr : Array α)"},
 {"type": "arr.toListRev = arr.data.reverse",
  "tactic-prompt":
  "theorem (arr : Array α) : arr.toListRev = arr.data.reverse := by rw [toListRev]; sorry",
  "name": "toListRev_eq",
  "kind": "theorem",
  "first-tactic": "rw [toListRev]",
  "core-prompt": "(arr : Array α) : arr.toListRev = arr.data.reverse",
  "args": "(arr : Array α)"},
 {"type": "SatisfiesM (motive as.size) (as.foldlM f init)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]      {as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive 0 init)  {f : β → α → m β}      (hf : ∀ i : Fin as.size, ∀ b, motive i.1 b → SatisfiesM (motive (i.1 + 1)) (f b as[i])) : SatisfiesM (motive as.size) (as.foldlM f init) := by let rec go {i j b} (h₁ : j ≤ as.size) (h₂ : as.size ≤ i + j) (H : motive j b) :\n    SatisfiesM (motive as.size) (foldlM.loop f as as.size (Nat.le_refl _) i j b) := by\n    unfold foldlM.loop; split\n    · next hj =>\n      split\n      · cases Nat.not_le_of_gt (by simp [hj]) h₂\n      · exact (hf ⟨j]; sorry",
  "name": "SatisfiesM_foldlM",
  "kind": "theorem",
  "first-tactic":
  "let rec go {i j b} (h₁ : j ≤ as.size) (h₂ : as.size ≤ i + j) (H : motive j b) :\n    SatisfiesM (motive as.size) (foldlM.loop f as as.size (Nat.le_refl _) i j b) := by\n    unfold foldlM.loop; split\n    · next hj =>\n      split\n      · cases Nat.not_le_of_gt (by simp [hj]) h₂\n      · exact (hf ⟨j]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]      {as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive 0 init)  {f : β → α → m β}      (hf : ∀ i : Fin as.size, ∀ b, motive i.1 b → SatisfiesM (motive (i.1 + 1)) (f b as[i])) : SatisfiesM (motive as.size) (as.foldlM f init)",
  "args":
  "[Monad m]  [LawfulMonad m]      {as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive 0 init)  {f : β → α → m β}      (hf : ∀ i : Fin as.size, ∀ b, motive i.1 b → SatisfiesM (motive (i.1 + 1)) (f b as[i]))"},
 {"type": "motive as.size (as.foldl f init)",
  "tactic-prompt":
  "theorem {as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive 0 init)  {f : β → α → β}      (hf : ∀ i : Fin as.size, ∀ b, motive i.1 b → motive (i.1 + 1) (f b as[i])) : motive as.size (as.foldl f init) := by have := SatisfiesM_foldlM (m := Id) (as := as) (f := f) motive h0; sorry",
  "name": "foldl_induction",
  "kind": "theorem",
  "first-tactic":
  "have := SatisfiesM_foldlM (m := Id) (as := as) (f := f) motive h0",
  "core-prompt":
  "{as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive 0 init)  {f : β → α → β}      (hf : ∀ i : Fin as.size, ∀ b, motive i.1 b → motive (i.1 + 1) (f b as[i])) : motive as.size (as.foldl f init)",
  "args":
  "{as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive 0 init)  {f : β → α → β}      (hf : ∀ i : Fin as.size, ∀ b, motive i.1 b → motive (i.1 + 1) (f b as[i]))"},
 {"type":
  "haveI : i < (a.push x).size := by simp [*, Nat.lt_succ_of_le, Nat.le_of_lt]\n    (a.push x)[i] = a[i]",
  "tactic-prompt":
  "theorem (a : Array α)  (x : α)  (i : Nat)  (h : i < a.size) : haveI : i < (a.push x).size := by simp [*, Nat.lt_succ_of_le, Nat.le_of_lt]\n    (a.push x)[i] = a[i] := by simp only [push]; sorry",
  "name": "get_push_lt",
  "kind": "theorem",
  "first-tactic": "simp only [push]",
  "core-prompt":
  "(a : Array α)  (x : α)  (i : Nat)  (h : i < a.size) : haveI : i < (a.push x).size := by simp [*, Nat.lt_succ_of_le, Nat.le_of_lt]\n    (a.push x)[i] = a[i]",
  "args": "(a : Array α)  (x : α)  (i : Nat)  (h : i < a.size)"},
 {"type": "(a.push x)[a.size] = x",
  "tactic-prompt":
  "theorem (a : Array α)  (x : α) : (a.push x)[a.size] = x := by simp only [push]; sorry",
  "name": "get_push_eq",
  "kind": "theorem",
  "first-tactic": "simp only [push]",
  "core-prompt": "(a : Array α)  (x : α) : (a.push x)[a.size] = x",
  "args": "(a : Array α)  (x : α)"},
 {"type": "(a.push x)[i] = if h : i < a.size then a[i] else x",
  "tactic-prompt":
  "theorem (a : Array α)  (x : α)  (i : Nat)  (h : i < (a.push x).size) : (a.push x)[i] = if h : i < a.size then a[i] else x := by if h' : i < a.size then\n    simp [get_push_lt]; sorry",
  "name": "get_push",
  "kind": "theorem",
  "first-tactic": "if h' : i < a.size then\n    simp [get_push_lt]",
  "core-prompt":
  "(a : Array α)  (x : α)  (i : Nat)  (h : i < (a.push x).size) : (a.push x)[i] = if h : i < a.size then a[i] else x",
  "args": "(a : Array α)  (x : α)  (i : Nat)  (h : i < (a.push x).size)"},
 {"type":
  "SatisfiesM\n      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ (arr[i]'(eq ▸ h)))\n      (Array.mapM f as)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (as : Array α)  (f : α → m β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → SatisfiesM (p i · ∧ motive (i + 1)) (f as[i])) : SatisfiesM\n      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ (arr[i]'(eq ▸ h)))\n      (Array.mapM f as) := by unfold mapM; sorry",
  "name": "SatisfiesM_mapM",
  "kind": "theorem",
  "first-tactic": "unfold mapM",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (as : Array α)  (f : α → m β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → SatisfiesM (p i · ∧ motive (i + 1)) (f as[i])) : SatisfiesM\n      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ (arr[i]'(eq ▸ h)))\n      (Array.mapM f as)",
  "args":
  "[Monad m]  [LawfulMonad m]  (as : Array α)  (f : α → m β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → SatisfiesM (p i · ∧ motive (i + 1)) (f as[i]))"},
 {"type": "(arr.map f).data = arr.data.map f",
  "tactic-prompt":
  "theorem (f : α → β)  (arr : Array α) : (arr.map f).data = arr.data.map f := by apply congrArg data (foldl_eq_foldl_data (fun bs a => push bs (f a)) #[] arr) |>.trans; sorry",
  "name": "map_data",
  "kind": "theorem",
  "first-tactic":
  "apply congrArg data (foldl_eq_foldl_data (fun bs a => push bs (f a)) #[] arr) |>.trans",
  "core-prompt":
  "(f : α → β)  (arr : Array α) : (arr.map f).data = arr.data.map f",
  "args": "(f : α → β)  (arr : Array α)"},
 {"type": "(arr.map f).size = arr.size",
  "tactic-prompt":
  "theorem (f : α → β)  (arr : Array α) : (arr.map f).size = arr.size := by simp [size]; sorry",
  "name": "size_map",
  "kind": "theorem",
  "first-tactic": "simp [size]",
  "core-prompt": "(f : α → β)  (arr : Array α) : (arr.map f).size = arr.size",
  "args": "(f : α → β)  (arr : Array α)"},
 {"type": "(arr ++ arr').data = arr.data ++ arr'.data",
  "tactic-prompt":
  "theorem (arr arr' : Array α) : (arr ++ arr').data = arr.data ++ arr'.data := by rw [← append_eq_append]; sorry",
  "name": "append_data",
  "kind": "theorem",
  "first-tactic": "rw [← append_eq_append]",
  "core-prompt":
  "(arr arr' : Array α) : (arr ++ arr').data = arr.data ++ arr'.data",
  "args": "(arr arr' : Array α)"},
 {"type": "(arr ++ l).data = arr.data ++ l",
  "tactic-prompt":
  "theorem (arr : Array α)  (l : List α) : (arr ++ l).data = arr.data ++ l := by rw [← appendList_eq_append]; sorry",
  "name": "appendList_data",
  "kind": "theorem",
  "first-tactic": "rw [← appendList_eq_append]",
  "core-prompt":
  "(arr : Array α)  (l : List α) : (arr ++ l).data = arr.data ++ l",
  "args": "(arr : Array α)  (l : List α)"},
 {"type": "(l.foldl F acc).data = acc.data ++ l.bind G",
  "tactic-prompt":
  "theorem (l : List α)  (acc : Array β)      (F : Array β → α → Array β)  (G : α → List β)      (H : ∀ acc a, (F acc a).data = acc.data ++ G a) : (l.foldl F acc).data = acc.data ++ l.bind G := by induction l generalizing acc; sorry",
  "name": "foldl_data_eq_bind",
  "kind": "theorem",
  "first-tactic": "induction l generalizing acc",
  "core-prompt":
  "(l : List α)  (acc : Array β)      (F : Array β → α → Array β)  (G : α → List β)      (H : ∀ acc a, (F acc a).data = acc.data ++ G a) : (l.foldl F acc).data = acc.data ++ l.bind G",
  "args":
  "(l : List α)  (acc : Array β)      (F : Array β → α → Array β)  (G : α → List β)      (H : ∀ acc a, (F acc a).data = acc.data ++ G a)"},
 {"type":
  "(l.foldl (fun acc a => acc.push (G a)) acc).data = acc.data ++ l.map G",
  "tactic-prompt":
  "theorem (l : List α)  (acc : Array β)  (G : α → β) : (l.foldl (fun acc a => acc.push (G a)) acc).data = acc.data ++ l.map G := by induction l generalizing acc; sorry",
  "name": "foldl_data_eq_map",
  "kind": "theorem",
  "first-tactic": "induction l generalizing acc",
  "core-prompt":
  "(l : List α)  (acc : Array β)  (G : α → β) : (l.foldl (fun acc a => acc.push (G a)) acc).data = acc.data ++ l.map G",
  "args": "(l : List α)  (acc : Array β)  (G : α → β)"},
 {"type": "a[i]? = none",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Nat)  (h : a.size ≤ i) : a[i]? = none := by simp [getElem?_neg]; sorry",
  "name": "get?_len_le",
  "kind": "theorem",
  "first-tactic": "simp [getElem?_neg]",
  "core-prompt": "(a : Array α)  (i : Nat)  (h : a.size ≤ i) : a[i]? = none",
  "args": "(a : Array α)  (i : Nat)  (h : a.size ≤ i)"},
 {"type": "a[i] ∈ a.data",
  "tactic-prompt":
  "theorem (a : Array α)  (h : i < a.size) : a[i] ∈ a.data := by simp [getElem_eq_data_get]; sorry",
  "name": "getElem_mem_data",
  "kind": "theorem",
  "first-tactic": "simp [getElem_eq_data_get]",
  "core-prompt": "(a : Array α)  (h : i < a.size) : a[i] ∈ a.data",
  "args": "(a : Array α)  (h : i < a.size)"},
 {"type": "a[i]? = a.data.get? i",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Nat) : a[i]? = a.data.get? i := by by_cases i < a.size; sorry",
  "name": "getElem?_eq_data_get?",
  "kind": "theorem",
  "first-tactic": "by_cases i < a.size",
  "core-prompt": "(a : Array α)  (i : Nat) : a[i]? = a.data.get? i",
  "args": "(a : Array α)  (i : Nat)"},
 {"type": "a.get! n = (a.get? n).getD default",
  "tactic-prompt":
  "theorem [Inhabited α]  (a : Array α) : a.get! n = (a.get? n).getD default := by simp [get!_eq_getD]; sorry",
  "name": "get!_eq_get?",
  "kind": "theorem",
  "first-tactic": "simp [get!_eq_getD]",
  "core-prompt":
  "[Inhabited α]  (a : Array α) : a.get! n = (a.get? n).getD default",
  "args": "[Inhabited α]  (a : Array α)"},
 {"type": "a.back = a.back?.getD default",
  "tactic-prompt":
  "theorem [Inhabited α]  (a : Array α) : a.back = a.back?.getD default := by simp [back]; sorry",
  "name": "back_eq_back?",
  "kind": "theorem",
  "first-tactic": "simp [back]",
  "core-prompt": "[Inhabited α]  (a : Array α) : a.back = a.back?.getD default",
  "args": "[Inhabited α]  (a : Array α)"},
 {"type": "(a.push x).back? = some x",
  "tactic-prompt":
  "theorem (a : Array α) : (a.push x).back? = some x := by simp [back?]; sorry",
  "name": "back?_push",
  "kind": "theorem",
  "first-tactic": "simp [back?]",
  "core-prompt": "(a : Array α) : (a.push x).back? = some x",
  "args": "(a : Array α)"},
 {"type": "(a.push x).back = x",
  "tactic-prompt":
  "theorem [Inhabited α]  (a : Array α) : (a.push x).back = x := by simp; sorry",
  "name": "back_push",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "[Inhabited α]  (a : Array α) : (a.push x).back = x",
  "args": "[Inhabited α]  (a : Array α)"},
 {"type": "(a.push x)[i]? = some a[i]",
  "tactic-prompt":
  "theorem (a : Array α)  (x : α)  (i : Nat)  (h : i < a.size) : (a.push x)[i]? = some a[i] := by rw [getElem?_pos]; sorry",
  "name": "get?_push_lt",
  "kind": "theorem",
  "first-tactic": "rw [getElem?_pos]",
  "core-prompt":
  "(a : Array α)  (x : α)  (i : Nat)  (h : i < a.size) : (a.push x)[i]? = some a[i]",
  "args": "(a : Array α)  (x : α)  (i : Nat)  (h : i < a.size)"},
 {"type": "(a.push x)[a.size]? = some x",
  "tactic-prompt":
  "theorem (a : Array α)  (x : α) : (a.push x)[a.size]? = some x := by rw [getElem?_pos]; sorry",
  "name": "get?_push_eq",
  "kind": "theorem",
  "first-tactic": "rw [getElem?_pos]",
  "core-prompt": "(a : Array α)  (x : α) : (a.push x)[a.size]? = some x",
  "args": "(a : Array α)  (x : α)"},
 {"type": "(a.set i v)[i.1]'(by simp [i.2]) = v",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Fin a.size)  (v : α) : (a.set i v)[i.1]'(by simp [i.2]) = v := by simp only [set]; sorry",
  "name": "get_set_eq",
  "kind": "theorem",
  "first-tactic": "simp only [set]",
  "core-prompt":
  "(a : Array α)  (i : Fin a.size)  (v : α) : (a.set i v)[i.1]'(by simp [i.2]) = v",
  "args": "(a : Array α)  (i : Fin a.size)  (v : α)"},
 {"type": "(a.set i v)[j]'(by simp [*]) = a[j]",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Fin a.size)  {j : Nat}  (v : α)  (hj : j < a.size)      (h : i.1 ≠ j) : (a.set i v)[j]'(by simp [*]) = a[j] := by simp only [set]; sorry",
  "name": "get_set_ne",
  "kind": "theorem",
  "first-tactic": "simp only [set]",
  "core-prompt":
  "(a : Array α)  (i : Fin a.size)  {j : Nat}  (v : α)  (hj : j < a.size)      (h : i.1 ≠ j) : (a.set i v)[j]'(by simp [*]) = a[j]",
  "args":
  "(a : Array α)  (i : Fin a.size)  {j : Nat}  (v : α)  (hj : j < a.size)      (h : i.1 ≠ j)"},
 {"type": "(a.set i v)[i.1]? = v",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Fin a.size)  (v : α) : (a.set i v)[i.1]? = v := by simp [getElem?_pos]; sorry",
  "name": "get?_set_eq",
  "kind": "theorem",
  "first-tactic": "simp [getElem?_pos]",
  "core-prompt":
  "(a : Array α)  (i : Fin a.size)  (v : α) : (a.set i v)[i.1]? = v",
  "args": "(a : Array α)  (i : Fin a.size)  (v : α)"},
 {"type": "(a.set i v)[j]? = a[j]?",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Fin a.size)  {j : Nat}  (v : α)      (h : i.1 ≠ j) : (a.set i v)[j]? = a[j]? := by by_cases j < a.size; sorry",
  "name": "get?_set_ne",
  "kind": "theorem",
  "first-tactic": "by_cases j < a.size",
  "core-prompt":
  "(a : Array α)  (i : Fin a.size)  {j : Nat}  (v : α)      (h : i.1 ≠ j) : (a.set i v)[j]? = a[j]?",
  "args":
  "(a : Array α)  (i : Fin a.size)  {j : Nat}  (v : α)      (h : i.1 ≠ j)"},
 {"type": "(a.set i v)[j]? = if i.1 = j then some v else a[j]?",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Fin a.size)  (j : Nat)  (v : α) : (a.set i v)[j]? = if i.1 = j then some v else a[j]? := by if h : i.1 = j then subst j; simp [*] else simp [*]; sorry",
  "name": "get?_set",
  "kind": "theorem",
  "first-tactic": "if h : i.1 = j then subst j; simp [*] else simp [*]",
  "core-prompt":
  "(a : Array α)  (i : Fin a.size)  (j : Nat)  (v : α) : (a.set i v)[j]? = if i.1 = j then some v else a[j]?",
  "args": "(a : Array α)  (i : Fin a.size)  (j : Nat)  (v : α)"},
 {"type": "(a.set i v)[j]'(by simp [*]) = if i = j then v else a[j]",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Fin a.size)  (j : Nat)  (hj : j < a.size)  (v : α) : (a.set i v)[j]'(by simp [*]) = if i = j then v else a[j] := by if h : i.1 = j then subst j; simp [*] else simp [*]; sorry",
  "name": "get_set",
  "kind": "theorem",
  "first-tactic": "if h : i.1 = j then subst j; simp [*] else simp [*]",
  "core-prompt":
  "(a : Array α)  (i : Fin a.size)  (j : Nat)  (hj : j < a.size)  (v : α) : (a.set i v)[j]'(by simp [*]) = if i = j then v else a[j]",
  "args":
  "(a : Array α)  (i : Fin a.size)  (j : Nat)  (hj : j < a.size)  (v : α)"},
 {"type": "e ▸ i = ⟨i.1, e ▸ i.2⟩",
  "tactic-prompt":
  "theorem (e : n = n')  (i : Fin n) : e ▸ i = ⟨i.1, e ▸ i.2⟩ := by cases e; sorry",
  "name": "fin_cast_val",
  "kind": "theorem",
  "first-tactic": "cases e",
  "core-prompt": "(e : n = n')  (i : Fin n) : e ▸ i = ⟨i.1, e ▸ i.2⟩",
  "args": "(e : n = n')  (i : Fin n)"},
 {"type": "a.swap i j = (a.set i (a.get j)).set ⟨j.1, by simp [j.2]⟩ (a.get i)",
  "tactic-prompt":
  "theorem (a : Array α)  (i j : Fin a.size) : a.swap i j = (a.set i (a.get j)).set ⟨j.1, by simp [j.2]⟩ (a.get i) := by simp [swap]; sorry",
  "name": "swap_def",
  "kind": "theorem",
  "first-tactic": "simp [swap]",
  "core-prompt":
  "(a : Array α)  (i j : Fin a.size) : a.swap i j = (a.set i (a.get j)).set ⟨j.1, by simp [j.2]⟩ (a.get i)",
  "args": "(a : Array α)  (i j : Fin a.size)"},
 {"type": "(a.swap i j).data = (a.data.set i (a.get j)).set j (a.get i)",
  "tactic-prompt":
  "theorem (a : Array α)  (i j : Fin a.size) : (a.swap i j).data = (a.data.set i (a.get j)).set j (a.get i) := by simp [swap_def]; sorry",
  "name": "data_swap",
  "kind": "theorem",
  "first-tactic": "simp [swap_def]",
  "core-prompt":
  "(a : Array α)  (i j : Fin a.size) : (a.swap i j).data = (a.data.set i (a.get j)).set j (a.get i)",
  "args": "(a : Array α)  (i j : Fin a.size)"},
 {"type":
  "(a.swap i j)[k]? =\n    if j = k then some a[i.1] else if i = k then some a[j.1] else a[k]?",
  "tactic-prompt":
  "theorem (a : Array α)  (i j : Fin a.size)  (k : Nat) : (a.swap i j)[k]? =\n    if j = k then some a[i.1] else if i = k then some a[j.1] else a[k]? := by simp [swap_def]; sorry",
  "name": "get?_swap",
  "kind": "theorem",
  "first-tactic": "simp [swap_def]",
  "core-prompt":
  "(a : Array α)  (i j : Fin a.size)  (k : Nat) : (a.swap i j)[k]? =\n    if j = k then some a[i.1] else if i = k then some a[j.1] else a[k]?",
  "args": "(a : Array α)  (i j : Fin a.size)  (k : Nat)"},
 {"type": "a.swapAt! i v = (a[i], a.set ⟨i, h⟩ v)",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Nat)  (v : α)  (h : i < a.size) : a.swapAt! i v = (a[i], a.set ⟨i, h⟩ v) := by simp [swapAt!]; sorry",
  "name": "swapAt!_def",
  "kind": "theorem",
  "first-tactic": "simp [swapAt!]",
  "core-prompt":
  "(a : Array α)  (i : Nat)  (v : α)  (h : i < a.size) : a.swapAt! i v = (a[i], a.set ⟨i, h⟩ v)",
  "args": "(a : Array α)  (i : Nat)  (v : α)  (h : i < a.size)"},
 {"type": "a.pop.data = a.data.dropLast",
  "tactic-prompt":
  "theorem (a : Array α) : a.pop.data = a.data.dropLast := by simp [pop]; sorry",
  "name": "data_pop",
  "kind": "theorem",
  "first-tactic": "simp [pop]",
  "core-prompt": "(a : Array α) : a.pop.data = a.data.dropLast",
  "args": "(a : Array α)"},
 {"type": "(a.push x).pop = a",
  "tactic-prompt":
  "theorem (a : Array α) : (a.push x).pop = a := by simp [pop]; sorry",
  "name": "pop_push",
  "kind": "theorem",
  "first-tactic": "simp [pop]",
  "core-prompt": "(a : Array α) : (a.push x).pop = a",
  "args": "(a : Array α)"},
 {"type": "SatisfiesM (motive 0) (as.foldrM f init)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]      {as : Array α}  (motive : Nat → β → Prop)      {init : β}  (h0 : motive as.size init)  {f : α → β → m β}      (hf : ∀ i : Fin as.size, ∀ b, motive (i.1 + 1) b → SatisfiesM (motive i.1) (f as[i] b)) : SatisfiesM (motive 0) (as.foldrM f init) := by let rec go {i b} (hi : i ≤ as.size) (H : motive i b) :\n    SatisfiesM (motive 0) (foldrM.fold f as 0 i hi b) := by\n    unfold foldrM.fold; simp; split\n    · next hi => exact .pure (hi ▸ H)\n    · next hi =>\n      split; {simp at hi}\n      · next i hi' =>\n        exact (hf ⟨i, hi'⟩ b H).bind fun _ => go _; sorry",
  "name": "SatisfiesM_foldrM",
  "kind": "theorem",
  "first-tactic":
  "let rec go {i b} (hi : i ≤ as.size) (H : motive i b) :\n    SatisfiesM (motive 0) (foldrM.fold f as 0 i hi b) := by\n    unfold foldrM.fold; simp; split\n    · next hi => exact .pure (hi ▸ H)\n    · next hi =>\n      split; {simp at hi}\n      · next i hi' =>\n        exact (hf ⟨i, hi'⟩ b H).bind fun _ => go _",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]      {as : Array α}  (motive : Nat → β → Prop)      {init : β}  (h0 : motive as.size init)  {f : α → β → m β}      (hf : ∀ i : Fin as.size, ∀ b, motive (i.1 + 1) b → SatisfiesM (motive i.1) (f as[i] b)) : SatisfiesM (motive 0) (as.foldrM f init)",
  "args":
  "[Monad m]  [LawfulMonad m]      {as : Array α}  (motive : Nat → β → Prop)      {init : β}  (h0 : motive as.size init)  {f : α → β → m β}      (hf : ∀ i : Fin as.size, ∀ b, motive (i.1 + 1) b → SatisfiesM (motive i.1) (f as[i] b))"},
 {"type": "motive 0 (as.foldr f init)",
  "tactic-prompt":
  "theorem {as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive as.size init)  {f : α → β → β}      (hf : ∀ i : Fin as.size, ∀ b, motive (i.1 + 1) b → motive i.1 (f as[i] b)) : motive 0 (as.foldr f init) := by have := SatisfiesM_foldrM (m := Id) (as := as) (f := f) motive h0; sorry",
  "name": "foldr_induction",
  "kind": "theorem",
  "first-tactic":
  "have := SatisfiesM_foldrM (m := Id) (as := as) (f := f) motive h0",
  "core-prompt":
  "{as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive as.size init)  {f : α → β → β}      (hf : ∀ i : Fin as.size, ∀ b, motive (i.1 + 1) b → motive i.1 (f as[i] b)) : motive 0 (as.foldr f init)",
  "args":
  "{as : Array α}  (motive : Nat → β → Prop)  {init : β}  (h0 : motive as.size init)  {f : α → β → β}      (hf : ∀ i : Fin as.size, ∀ b, motive (i.1 + 1) b → motive i.1 (f as[i] b))"},
 {"type": "arr.mapM f = return mk (← arr.data.mapM f)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (f : α → m β)  (arr : Array α) : arr.mapM f = return mk (← arr.data.mapM f) := by rw [mapM]; sorry",
  "name": "mapM_eq_mapM_data",
  "kind": "theorem",
  "first-tactic": "rw [mapM]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (f : α → m β)  (arr : Array α) : arr.mapM f = return mk (← arr.data.mapM f)",
  "args": "[Monad m]  [LawfulMonad m]  (f : α → m β)  (arr : Array α)"},
 {"type":
  "SatisfiesM\n      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ (arr[i]'(eq ▸ h)))\n      (Array.mapIdxM as f)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (as : Array α)  (f : Fin as.size → α → m β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → SatisfiesM (p i · ∧ motive (i + 1)) (f i as[i])) : SatisfiesM\n      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ (arr[i]'(eq ▸ h)))\n      (Array.mapIdxM as f) := by let rec go {bs i j h} (h₁ : j = bs.size) (h₂ : ∀ i h h', p ⟨i, h⟩ bs[i]) (hm : motive j) :\n    SatisfiesM\n      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ (arr[i]'(eq ▸ h)))\n      (Array.mapIdxM.map as f i j h bs) := by\n    induction i generalizing j bs with simp [mapIdxM.map]\n    | zero =>\n      have := (Nat.zero_add _).symm.trans h\n      exact .pure ⟨this ▸ hm, h₁ ▸ this, fun _ _ => h₂ ..⟩\n    | succ i ih =>\n      refine (hs _ (by exact hm)).bind fun b hb => ih (by simp [h₁]) (fun i hi hi' => ?_) hb.2\n      simp at hi'; simp [get_push]; split\n      · next h => exact h₂ _ _ h\n      · next h => cases h₁.symm ▸ (Nat.le_or_eq_or_le_succ hi').resolve_left h; exact hb.1; sorry",
  "name": "SatisfiesM_mapIdxM",
  "kind": "theorem",
  "first-tactic":
  "let rec go {bs i j h} (h₁ : j = bs.size) (h₂ : ∀ i h h', p ⟨i, h⟩ bs[i]) (hm : motive j) :\n    SatisfiesM\n      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ (arr[i]'(eq ▸ h)))\n      (Array.mapIdxM.map as f i j h bs) := by\n    induction i generalizing j bs with simp [mapIdxM.map]\n    | zero =>\n      have := (Nat.zero_add _).symm.trans h\n      exact .pure ⟨this ▸ hm, h₁ ▸ this, fun _ _ => h₂ ..⟩\n    | succ i ih =>\n      refine (hs _ (by exact hm)).bind fun b hb => ih (by simp [h₁]) (fun i hi hi' => ?_) hb.2\n      simp at hi'; simp [get_push]; split\n      · next h => exact h₂ _ _ h\n      · next h => cases h₁.symm ▸ (Nat.le_or_eq_or_le_succ hi').resolve_left h; exact hb.1",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (as : Array α)  (f : Fin as.size → α → m β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → SatisfiesM (p i · ∧ motive (i + 1)) (f i as[i])) : SatisfiesM\n      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ (arr[i]'(eq ▸ h)))\n      (Array.mapIdxM as f)",
  "args":
  "[Monad m]  [LawfulMonad m]  (as : Array α)  (f : Fin as.size → α → m β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → SatisfiesM (p i · ∧ motive (i + 1)) (f i as[i]))"},
 {"type":
  "motive as.size ∧ ∃ eq : (Array.mapIdx as f).size = as.size,\n      ∀ i h, p ⟨i, h⟩ ((Array.mapIdx as f)[i]'(eq ▸ h))",
  "tactic-prompt":
  "theorem (as : Array α)  (f : Fin as.size → α → β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → p i (f i as[i]) ∧ motive (i + 1)) : motive as.size ∧ ∃ eq : (Array.mapIdx as f).size = as.size,\n      ∀ i h, p ⟨i, h⟩ ((Array.mapIdx as f)[i]'(eq ▸ h)) := by have := SatisfiesM_mapIdxM (m := Id) (as := as) (f := f) motive h0; sorry",
  "name": "mapIdx_induction",
  "kind": "theorem",
  "first-tactic":
  "have := SatisfiesM_mapIdxM (m := Id) (as := as) (f := f) motive h0",
  "core-prompt":
  "(as : Array α)  (f : Fin as.size → α → β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → p i (f i as[i]) ∧ motive (i + 1)) : motive as.size ∧ ∃ eq : (Array.mapIdx as f).size = as.size,\n      ∀ i h, p ⟨i, h⟩ ((Array.mapIdx as f)[i]'(eq ▸ h))",
  "args":
  "(as : Array α)  (f : Fin as.size → α → β)      (motive : Nat → Prop)  (h0 : motive 0)      (p : Fin as.size → β → Prop)      (hs : ∀ i, motive i.1 → p i (f i as[i]) ∧ motive (i + 1))"},
 {"type": "a.reverse.size = a.size",
  "tactic-prompt":
  "theorem (a : Array α) : a.reverse.size = a.size := by let rec go (as : Array α) (i j) : (reverse.loop as i j).size = as.size := by\n    rw [reverse.loop]\n    if h : i < j then\n      have := reverse.termination h\n      simp [(go · (i+1) ⟨j-1]; sorry",
  "name": "size_reverse",
  "kind": "theorem",
  "first-tactic":
  "let rec go (as : Array α) (i j) : (reverse.loop as i j).size = as.size := by\n    rw [reverse.loop]\n    if h : i < j then\n      have := reverse.termination h\n      simp [(go · (i+1) ⟨j-1]",
  "core-prompt": "(a : Array α) : a.reverse.size = a.size",
  "args": "(a : Array α)"},
 {"type": "a.reverse.data = a.data.reverse",
  "tactic-prompt":
  "theorem (a : Array α) : a.reverse.data = a.data.reverse := by let rec go (as : Array α) (i j hj)\n      (h : i + j + 1 = a.size) (h₂ : as.size = a.size)\n      (H : ∀ k, as.data.get? k = if i ≤ k ∧ k ≤ j then a.data.get? k else a.data.reverse.get? k)\n      (k) : (reverse.loop as i ⟨j, hj⟩).data.get? k = a.data.reverse.get? k := by\n    rw [reverse.loop]; dsimp; split; sorry",
  "name": "reverse_data",
  "kind": "theorem",
  "first-tactic":
  "let rec go (as : Array α) (i j hj)\n      (h : i + j + 1 = a.size) (h₂ : as.size = a.size)\n      (H : ∀ k, as.data.get? k = if i ≤ k ∧ k ≤ j then a.data.get? k else a.data.reverse.get? k)\n      (k) : (reverse.loop as i ⟨j, hj⟩).data.get? k = a.data.reverse.get? k := by\n    rw [reverse.loop]; dsimp; split",
  "core-prompt": "(a : Array α) : a.reverse.data = a.data.reverse",
  "args": "(a : Array α)"},
 {"type": "(ofFn f).size = n",
  "tactic-prompt":
  "theorem (f : Fin n → α) : (ofFn f).size = n := by simp [ofFn]; sorry",
  "name": "size_ofFn",
  "kind": "theorem",
  "first-tactic": "simp [ofFn]",
  "core-prompt": "(f : Fin n → α) : (ofFn f).size = n",
  "args": "(f : Fin n → α)"},
 {"type": "isEmpty l = l.toList.isEmpty",
  "tactic-prompt":
  "theorem (l : AssocList α β) : isEmpty l = l.toList.isEmpty := by cases l; sorry",
  "name": "isEmpty_eq",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "(l : AssocList α β) : isEmpty l = l.toList.isEmpty",
  "args": "(l : AssocList α β)"},
 {"type": "@toList = @toListTR",
  "tactic-prompt": "theorem  : @toList = @toListTR := by funext α β as; sorry",
  "name": "toList_eq_toListTR",
  "kind": "theorem",
  "first-tactic": "funext α β as",
  "core-prompt": " : @toList = @toListTR",
  "args": ""},
 {"type": "(mapKey f l).toList = l.toList.map (fun (a, b) => (f a, b))",
  "tactic-prompt":
  "theorem (f : α → δ)  (l : AssocList α β) : (mapKey f l).toList = l.toList.map (fun (a, b) => (f a, b)) := by induction l; sorry",
  "name": "mapKey_toList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : α → δ)  (l : AssocList α β) : (mapKey f l).toList = l.toList.map (fun (a, b) => (f a, b))",
  "args": "(f : α → δ)  (l : AssocList α β)"},
 {"type": "(mapVal f l).toList = l.toList.map (fun (a, b) => (a, f a b))",
  "tactic-prompt":
  "theorem (f : α → β → δ)  (l : AssocList α β) : (mapVal f l).toList = l.toList.map (fun (a, b) => (a, f a b)) := by induction l; sorry",
  "name": "mapVal_toList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : α → β → δ)  (l : AssocList α β) : (mapVal f l).toList = l.toList.map (fun (a, b) => (a, f a b))",
  "args": "(f : α → β → δ)  (l : AssocList α β)"},
 {"type": "findEntryP? p l = l.toList.find? fun (a, b) => p a b",
  "tactic-prompt":
  "theorem (p : α → β → Bool)  (l : AssocList α β) : findEntryP? p l = l.toList.find? fun (a, b) => p a b := by induction l; sorry",
  "name": "findEntryP?_eq",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(p : α → β → Bool)  (l : AssocList α β) : findEntryP? p l = l.toList.find? fun (a, b) => p a b",
  "args": "(p : α → β → Bool)  (l : AssocList α β)"},
 {"type": "find? a l = (l.findEntry? a).map (·.2)",
  "tactic-prompt":
  "theorem [BEq α]  (a : α)  (l : AssocList α β) : find? a l = (l.findEntry? a).map (·.2) := by induction l; sorry",
  "name": "find?_eq_findEntry?",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "[BEq α]  (a : α)  (l : AssocList α β) : find? a l = (l.findEntry? a).map (·.2)",
  "args": "[BEq α]  (a : α)  (l : AssocList α β)"},
 {"type": "find? a l = (l.toList.find? (·.1 == a)).map (·.2)",
  "tactic-prompt":
  "theorem [BEq α]  (a : α)  (l : AssocList α β) : find? a l = (l.toList.find? (·.1 == a)).map (·.2) := by simp [find?_eq_findEntry?]; sorry",
  "name": "find?_eq",
  "kind": "theorem",
  "first-tactic": "simp [find?_eq_findEntry?]",
  "core-prompt":
  "[BEq α]  (a : α)  (l : AssocList α β) : find? a l = (l.toList.find? (·.1 == a)).map (·.2)",
  "args": "[BEq α]  (a : α)  (l : AssocList α β)"},
 {"type": "any p l = l.toList.any fun (a, b) => p a b",
  "tactic-prompt":
  "theorem (p : α → β → Bool)  (l : AssocList α β) : any p l = l.toList.any fun (a, b) => p a b := by induction l; sorry",
  "name": "any_eq",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(p : α → β → Bool)  (l : AssocList α β) : any p l = l.toList.any fun (a, b) => p a b",
  "args": "(p : α → β → Bool)  (l : AssocList α β)"},
 {"type": "all p l = l.toList.all fun (a, b) => p a b",
  "tactic-prompt":
  "theorem (p : α → β → Bool)  (l : AssocList α β) : all p l = l.toList.all fun (a, b) => p a b := by induction l; sorry",
  "name": "all_eq",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(p : α → β → Bool)  (l : AssocList α β) : all p l = l.toList.all fun (a, b) => p a b",
  "args": "(p : α → β → Bool)  (l : AssocList α β)"},
 {"type": "contains a l = l.toList.any (·.1 == a)",
  "tactic-prompt":
  "theorem [BEq α]  (a : α)  (l : AssocList α β) : contains a l = l.toList.any (·.1 == a) := by induction l; sorry",
  "name": "contains_eq",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "[BEq α]  (a : α)  (l : AssocList α β) : contains a l = l.toList.any (·.1 == a)",
  "args": "[BEq α]  (a : α)  (l : AssocList α β)"},
 {"type":
  "(replace a b l).toList =\n    l.toList.replaceF (bif ·.1 == a then (a, b) else none)",
  "tactic-prompt":
  "theorem [BEq α]  (a : α)  (b : β)  (l : AssocList α β) : (replace a b l).toList =\n    l.toList.replaceF (bif ·.1 == a then (a, b) else none) := by induction l; sorry",
  "name": "replace_toList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "[BEq α]  (a : α)  (b : β)  (l : AssocList α β) : (replace a b l).toList =\n    l.toList.replaceF (bif ·.1 == a then (a, b) else none)",
  "args": "[BEq α]  (a : α)  (b : β)  (l : AssocList α β)"},
 {"type": "forIn l init f = forIn l.toList init f",
  "tactic-prompt":
  "theorem [Monad m]  (l : AssocList α β)  (init : δ)      (f : (α × β) → δ → m (ForInStep δ)) : forIn l init f = forIn l.toList init f := by simp [forIn]; sorry",
  "name": "forIn_eq",
  "kind": "theorem",
  "first-tactic": "simp [forIn]",
  "core-prompt":
  "[Monad m]  (l : AssocList α β)  (init : δ)      (f : (α × β) → δ → m (ForInStep δ)) : forIn l init f = forIn l.toList init f",
  "args":
  "[Monad m]  (l : AssocList α β)  (init : δ)      (f : (α × β) → δ → m (ForInStep δ))"},
 {"type": "l.toAssocList.toList = l",
  "tactic-prompt":
  "theorem (l : List (α × β)) : l.toAssocList.toList = l := by induction l; sorry",
  "name": "_root_.List.toAssocList_toList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List (α × β)) : l.toAssocList.toList = l",
  "args": "(l : List (α × β))"},
 {"type": "l.toList.toAssocList = l",
  "tactic-prompt":
  "theorem (l : AssocList α β) : l.toList.toAssocList = l := by induction l; sorry",
  "name": "toList_toAssocList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : AssocList α β) : l.toList.toAssocList = l",
  "args": "(l : AssocList α β)"},
 {"type": "t.modify cut f = t.alter cut (.map f)",
  "tactic-prompt":
  "theorem (t : RBNode α) : t.modify cut f = t.alter cut (.map f) := by simp [modify]; sorry",
  "name": "modify_eq_alter",
  "kind": "theorem",
  "first-tactic": "simp [modify]",
  "core-prompt": "(t : RBNode α) : t.modify cut f = t.alter cut (.map f)",
  "args": "(t : RBNode α)"},
 {"type": "(balance1 l v r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLt cmp · v))  (vr : r.All (cmpLt cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balance1 l v r).Ordered cmp := by unfold balance1; sorry",
  "name": "Ordered.balance1",
  "kind": "theorem",
  "first-tactic": "unfold balance1",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLt cmp · v))  (vr : r.All (cmpLt cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balance1 l v r).Ordered cmp",
  "args":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLt cmp · v))  (vr : r.All (cmpLt cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(balance1 l v r).All p ↔ p v ∧ l.All p ∧ r.All p",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α} : (balance1 l v r).All p ↔ p v ∧ l.All p ∧ r.All p := by unfold balance1; sorry",
  "name": "balance1_All",
  "kind": "theorem",
  "first-tactic": "unfold balance1",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α} : (balance1 l v r).All p ↔ p v ∧ l.All p ∧ r.All p",
  "args": "{l : RBNode α}  {v : α}  {r : RBNode α}"},
 {"type": "(balance2 l v r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLt cmp · v))  (vr : r.All (cmpLt cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balance2 l v r).Ordered cmp := by unfold balance2; sorry",
  "name": "Ordered.balance2",
  "kind": "theorem",
  "first-tactic": "unfold balance2",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLt cmp · v))  (vr : r.All (cmpLt cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balance2 l v r).Ordered cmp",
  "args":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLt cmp · v))  (vr : r.All (cmpLt cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(balance2 l v r).All p ↔ p v ∧ l.All p ∧ r.All p",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α} : (balance2 l v r).All p ↔ p v ∧ l.All p ∧ r.All p := by unfold balance2; sorry",
  "name": "balance2_All",
  "kind": "theorem",
  "first-tactic": "unfold balance2",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α} : (balance2 l v r).All p ↔ p v ∧ l.All p ∧ r.All p",
  "args": "{l : RBNode α}  {v : α}  {r : RBNode α}"},
 {"type": "(setBlack t).Ordered cmp ↔ t.Ordered cmp",
  "tactic-prompt":
  "theorem {t : RBNode α} : (setBlack t).Ordered cmp ↔ t.Ordered cmp := by unfold setBlack; sorry",
  "name": "Ordered.setBlack",
  "kind": "theorem",
  "first-tactic": "unfold setBlack",
  "core-prompt": "{t : RBNode α} : (setBlack t).Ordered cmp ↔ t.Ordered cmp",
  "args": "{t : RBNode α}"},
 {"type": "t.setBlack.setBlack = t.setBlack",
  "tactic-prompt":
  "theorem {t : RBNode α} : t.setBlack.setBlack = t.setBlack := by cases t; sorry",
  "name": "setBlack_idem",
  "kind": "theorem",
  "first-tactic": "cases t",
  "core-prompt": "{t : RBNode α} : t.setBlack.setBlack = t.setBlack",
  "args": "{t : RBNode α}"},
 {"type": "(t.insert cmp v).setBlack = (t.ins cmp v).setBlack",
  "tactic-prompt":
  "theorem {t : RBNode α} : (t.insert cmp v).setBlack = (t.ins cmp v).setBlack := by unfold insert; sorry",
  "name": "insert_setBlack",
  "kind": "theorem",
  "first-tactic": "unfold insert",
  "core-prompt":
  "{t : RBNode α} : (t.insert cmp v).setBlack = (t.ins cmp v).setBlack",
  "args": "{t : RBNode α}"},
 {"type": "(ins cmp x t).All p",
  "tactic-prompt":
  "theorem {x : α}  {t : RBNode α}    (h₁ : p x)  (h₂ : t.All p) : (ins cmp x t).All p := by induction t; sorry",
  "name": "All.ins",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "{x : α}  {t : RBNode α}    (h₁ : p x)  (h₂ : t.All p) : (ins cmp x t).All p",
  "args": "{x : α}  {t : RBNode α}    (h₁ : p x)  (h₂ : t.All p)"},
 {"type": "(insert cmp t v).Ordered cmp",
  "tactic-prompt":
  "theorem (h : t.Ordered cmp) : (insert cmp t v).Ordered cmp := by unfold RBNode.insert; sorry",
  "name": "Ordered.insert",
  "kind": "theorem",
  "first-tactic": "unfold RBNode.insert",
  "core-prompt": "(h : t.Ordered cmp) : (insert cmp t v).Ordered cmp",
  "args": "(h : t.Ordered cmp)"},
 {"type": "∃ c, (balance1 l v r).Balanced c (n + 1)",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.RedRed p n)  (hr : r.Balanced c n) : ∃ c, (balance1 l v r).Balanced c (n + 1) := by unfold balance1; sorry",
  "name": "RedRed.balance1",
  "kind": "theorem",
  "first-tactic": "unfold balance1",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.RedRed p n)  (hr : r.Balanced c n) : ∃ c, (balance1 l v r).Balanced c (n + 1)",
  "args":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.RedRed p n)  (hr : r.Balanced c n)"},
 {"type": "∃ c, (balance2 l v r).Balanced c (n + 1)",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.Balanced c n)  (hr : r.RedRed p n) : ∃ c, (balance2 l v r).Balanced c (n + 1) := by unfold balance2; sorry",
  "name": "RedRed.balance2",
  "kind": "theorem",
  "first-tactic": "unfold balance2",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.Balanced c n)  (hr : r.RedRed p n) : ∃ c, (balance2 l v r).Balanced c (n + 1)",
  "args":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.Balanced c n)  (hr : r.RedRed p n)"},
 {"type": "balance1 l v r = node black l v r",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.Balanced c n) : balance1 l v r = node black l v r := by unfold balance1; sorry",
  "name": "balance1_eq",
  "kind": "theorem",
  "first-tactic": "unfold balance1",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.Balanced c n) : balance1 l v r = node black l v r",
  "args": "{l : RBNode α}  {v : α}  {r : RBNode α}      (hl : l.Balanced c n)"},
 {"type": "balance2 l v r = node black l v r",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (hr : r.Balanced c n) : balance2 l v r = node black l v r := by unfold balance2; sorry",
  "name": "balance2_eq",
  "kind": "theorem",
  "first-tactic": "unfold balance2",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (hr : r.Balanced c n) : balance2 l v r = node black l v r",
  "args": "{l : RBNode α}  {v : α}  {r : RBNode α}      (hr : r.Balanced c n)"},
 {"type": "∃ c' n', (insert cmp t v).Balanced c' n'",
  "tactic-prompt":
  "theorem {t : RBNode α}  (h : t.Balanced c n) : ∃ c' n', (insert cmp t v).Balanced c' n' := by unfold insert; sorry",
  "name": "Balanced.insert",
  "kind": "theorem",
  "first-tactic": "unfold insert",
  "core-prompt":
  "{t : RBNode α}  (h : t.Balanced c n) : ∃ c' n', (insert cmp t v).Balanced c' n'",
  "args": "{t : RBNode α}  (h : t.Balanced c n)"},
 {"type": "(setRed t).All p",
  "tactic-prompt":
  "theorem {t : RBNode α}  (h : t.All p) : (setRed t).All p := by unfold setRed; sorry",
  "name": "All.setRed",
  "kind": "theorem",
  "first-tactic": "unfold setRed",
  "core-prompt": "{t : RBNode α}  (h : t.All p) : (setRed t).All p",
  "args": "{t : RBNode α}  (h : t.All p)"},
 {"type": "(setRed t).Ordered cmp ↔ t.Ordered cmp",
  "tactic-prompt":
  "theorem {t : RBNode α} : (setRed t).Ordered cmp ↔ t.Ordered cmp := by unfold setRed; sorry",
  "name": "Ordered.setRed",
  "kind": "theorem",
  "first-tactic": "unfold setRed",
  "core-prompt": "{t : RBNode α} : (setRed t).Ordered cmp ↔ t.Ordered cmp",
  "args": "{t : RBNode α}"},
 {"type": "(balLeft l v r).All p",
  "tactic-prompt":
  "theorem (hl : l.All p)  (hv : p v)  (hr : r.All p) : (balLeft l v r).All p := by unfold balLeft; sorry",
  "name": "All.balLeft",
  "kind": "theorem",
  "first-tactic": "unfold balLeft",
  "core-prompt":
  "(hl : l.All p)  (hv : p v)  (hr : r.All p) : (balLeft l v r).All p",
  "args": "(hl : l.All p)  (hv : p v)  (hr : r.All p)"},
 {"type": "(balLeft l v r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLt cmp · v))  (vr : r.All (cmpLt cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balLeft l v r).Ordered cmp := by unfold balLeft; sorry",
  "name": "Ordered.balLeft",
  "kind": "theorem",
  "first-tactic": "unfold balLeft",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLt cmp · v))  (vr : r.All (cmpLt cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balLeft l v r).Ordered cmp",
  "args":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLt cmp · v))  (vr : r.All (cmpLt cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(balLeft l v r).RedRed (cr = red) (n + 1)",
  "tactic-prompt":
  "theorem (hl : l.RedRed True n)  (hr : r.Balanced cr (n + 1)) : (balLeft l v r).RedRed (cr = red) (n + 1) := by unfold balLeft; sorry",
  "name": "Balanced.balLeft",
  "kind": "theorem",
  "first-tactic": "unfold balLeft",
  "core-prompt":
  "(hl : l.RedRed True n)  (hr : r.Balanced cr (n + 1)) : (balLeft l v r).RedRed (cr = red) (n + 1)",
  "args": "(hl : l.RedRed True n)  (hr : r.Balanced cr (n + 1))"},
 {"type": "(balRight l v r).All p",
  "tactic-prompt":
  "theorem (hl : l.All p)  (hv : p v)  (hr : r.All p) : (balRight l v r).All p := by unfold balRight; sorry",
  "name": "All.balRight",
  "kind": "theorem",
  "first-tactic": "unfold balRight",
  "core-prompt":
  "(hl : l.All p)  (hv : p v)  (hr : r.All p) : (balRight l v r).All p",
  "args": "(hl : l.All p)  (hv : p v)  (hr : r.All p)"},
 {"type": "(balRight l v r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLt cmp · v))  (vr : r.All (cmpLt cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balRight l v r).Ordered cmp := by unfold balRight; sorry",
  "name": "Ordered.balRight",
  "kind": "theorem",
  "first-tactic": "unfold balRight",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLt cmp · v))  (vr : r.All (cmpLt cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balRight l v r).Ordered cmp",
  "args":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLt cmp · v))  (vr : r.All (cmpLt cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(balRight l v r).RedRed (cl = red) (n + 1)",
  "tactic-prompt":
  "theorem (hl : l.Balanced cl (n + 1))  (hr : r.RedRed True n) : (balRight l v r).RedRed (cl = red) (n + 1) := by unfold balRight; sorry",
  "name": "Balanced.balRight",
  "kind": "theorem",
  "first-tactic": "unfold balRight",
  "core-prompt":
  "(hl : l.Balanced cl (n + 1))  (hr : r.RedRed True n) : (balRight l v r).RedRed (cl = red) (n + 1)",
  "args": "(hl : l.Balanced cl (n + 1))  (hr : r.RedRed True n)"},
 {"type": "(append l r).All p",
  "tactic-prompt":
  "theorem (hl : l.All p)  (hr : r.All p) : (append l r).All p := by unfold append; sorry",
  "name": "All.append",
  "kind": "theorem",
  "first-tactic": "unfold append",
  "core-prompt": "(hl : l.All p)  (hr : r.All p) : (append l r).All p",
  "args": "(hl : l.All p)  (hr : r.All p)"},
 {"type": "(append l r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLt cmp · v))  (vr : r.All (cmpLt cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (append l r).Ordered cmp := by unfold append; sorry",
  "name": "Ordered.append",
  "kind": "theorem",
  "first-tactic": "unfold append",
  "core-prompt":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLt cmp · v))  (vr : r.All (cmpLt cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (append l r).Ordered cmp",
  "args":
  "{l : RBNode α}  {v : α}  {r : RBNode α}      (lv : l.All (cmpLt cmp · v))  (vr : r.All (cmpLt cmp v ·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(l.append r).RedRed (c₁ = black → c₂ ≠ black) n",
  "tactic-prompt":
  "theorem {l r : RBNode α}      (hl : l.Balanced c₁ n)  (hr : r.Balanced c₂ n) : (l.append r).RedRed (c₁ = black → c₂ ≠ black) n := by unfold append; sorry",
  "name": "Balanced.append",
  "kind": "theorem",
  "first-tactic": "unfold append",
  "core-prompt":
  "{l r : RBNode α}      (hl : l.Balanced c₁ n)  (hr : r.Balanced c₂ n) : (l.append r).RedRed (c₁ = black → c₂ ≠ black) n",
  "args":
  "{l r : RBNode α}      (hl : l.Balanced c₁ n)  (hr : r.Balanced c₂ n)"},
 {"type": "∃ n', RedRed (c = black) t n'",
  "tactic-prompt":
  "theorem (h : DelProp c t n) : ∃ n', RedRed (c = black) t n' := by unfold DelProp at h; sorry",
  "name": "DelProp.redred",
  "kind": "theorem",
  "first-tactic": "unfold DelProp at h",
  "core-prompt": "(h : DelProp c t n) : ∃ n', RedRed (c = black) t n'",
  "args": "(h : DelProp c t n)"},
 {"type": "(t.del cut).DelProp t.isBlack n",
  "tactic-prompt":
  "theorem {t : RBNode α}  (h : t.Balanced c n) : (t.del cut).DelProp t.isBlack n := by induction h; sorry",
  "name": "Balanced.del",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{t : RBNode α}  (h : t.Balanced c n) : (t.del cut).DelProp t.isBlack n",
  "args": "{t : RBNode α}  (h : t.Balanced c n)"},
 {"type": "fill' (zoom cut t path) = path.fill t",
  "tactic-prompt":
  "theorem (cut : α → Ordering)  (t : RBNode α)  (path : Path α) : fill' (zoom cut t path) = path.fill t := by induction t generalizing path with\n  | nil => rfl\n  | node _ _ _ _ iha ihb => unfold zoom; split; {apply iha}; {apply ihb}; {rfl}; sorry",
  "name": "zoom_fill'",
  "kind": "theorem",
  "first-tactic":
  "induction t generalizing path with\n  | nil => rfl\n  | node _ _ _ _ iha ihb => unfold zoom; split; {apply iha}; {apply ihb}; {rfl}",
  "core-prompt":
  "(cut : α → Ordering)  (t : RBNode α)  (path : Path α) : fill' (zoom cut t path) = path.fill t",
  "args": "(cut : α → Ordering)  (t : RBNode α)  (path : Path α)"},
 {"type":
  "t.zoom (cmp v) path = (t', path') →\n    path.ins (t.ins cmp v) = path'.ins (t'.setRoot v)",
  "tactic-prompt":
  "theorem {t : RBNode α}  {cmp : α → α → Ordering} : t.zoom (cmp v) path = (t', path') →\n    path.ins (t.ins cmp v) = path'.ins (t'.setRoot v) := by unfold RBNode.ins; sorry",
  "name": "zoom_ins",
  "kind": "theorem",
  "first-tactic": "unfold RBNode.ins",
  "core-prompt":
  "{t : RBNode α}  {cmp : α → α → Ordering} : t.zoom (cmp v) path = (t', path') →\n    path.ins (t.ins cmp v) = path'.ins (t'.setRoot v)",
  "args": "{t : RBNode α}  {cmp : α → α → Ordering}"},
 {"type":
  "t.zoom cut path = (t', path') →\n    path.del (t.del cut) (match t with | node c .. => c | _ => red) =\n    path'.del t'.delRoot (match t' with | node c .. => c | _ => red)",
  "tactic-prompt":
  "theorem {t : RBNode α} : t.zoom cut path = (t', path') →\n    path.del (t.del cut) (match t with | node c .. => c | _ => red) =\n    path'.del t'.delRoot (match t' with | node c .. => c | _ => red) := by unfold RBNode.del; sorry",
  "name": "zoom_del",
  "kind": "theorem",
  "first-tactic": "unfold RBNode.del",
  "core-prompt":
  "{t : RBNode α} : t.zoom cut path = (t', path') →\n    path.del (t.del cut) (match t with | node c .. => c | _ => red) =\n    path'.del t'.delRoot (match t' with | node c .. => c | _ => red)",
  "args": "{t : RBNode α}"},
 {"type": "∃ n, (path.ins t).Balanced black n",
  "tactic-prompt":
  "theorem (c₀ : RBColor)  (n₀ : Nat) {path : Path α}      (hp : path.Balanced c₀ n₀ c n)  (ht : t.RedRed (c = red) n) : ∃ n, (path.ins t).Balanced black n := by induction hp generalizing t with\n  | root => exact ht.setBlack\n  | redL hr hp ih => match ht with\n    | .balanced .nil => exact ih (.balanced (.red .nil hr))\n    | .balanced (.red ha hb) => exact ih (.redred rfl (.red ha hb) hr)\n    | .balanced (.black ha hb) => exact ih (.balanced (.red (.black ha hb) hr))\n  | redR hl hp ih => match ht with\n    | .balanced .nil => exact ih (.balanced (.red hl .nil))\n    | .balanced (.red ha hb) => exact ih (.redred rfl hl (.red ha hb))\n    | .balanced (.black ha hb) => exact ih (.balanced (.red hl (.black ha hb)))\n  | blackL hr hp ih => exact have ⟨c, h⟩ := ht.balance1 hr; ih (.balanced h)\n  | blackR hl hp ih => exact have ⟨c, h⟩ := ht.balance2 hl; ih (.balanced h); sorry",
  "name": "Balanced.ins",
  "kind": "theorem",
  "first-tactic":
  "induction hp generalizing t with\n  | root => exact ht.setBlack\n  | redL hr hp ih => match ht with\n    | .balanced .nil => exact ih (.balanced (.red .nil hr))\n    | .balanced (.red ha hb) => exact ih (.redred rfl (.red ha hb) hr)\n    | .balanced (.black ha hb) => exact ih (.balanced (.red (.black ha hb) hr))\n  | redR hl hp ih => match ht with\n    | .balanced .nil => exact ih (.balanced (.red hl .nil))\n    | .balanced (.red ha hb) => exact ih (.redred rfl hl (.red ha hb))\n    | .balanced (.black ha hb) => exact ih (.balanced (.red hl (.black ha hb)))\n  | blackL hr hp ih => exact have ⟨c, h⟩ := ht.balance1 hr; ih (.balanced h)\n  | blackR hl hp ih => exact have ⟨c, h⟩ := ht.balance2 hl; ih (.balanced h)",
  "core-prompt":
  "(c₀ : RBColor)  (n₀ : Nat) {path : Path α}      (hp : path.Balanced c₀ n₀ c n)  (ht : t.RedRed (c = red) n) : ∃ n, (path.ins t).Balanced black n",
  "args":
  "(c₀ : RBColor)  (n₀ : Nat) {path : Path α}      (hp : path.Balanced c₀ n₀ c n)  (ht : t.RedRed (c = red) n)"},
 {"type": "(path.insert t' v).setBlack = (t.insert cmp v).setBlack",
  "tactic-prompt":
  "theorem (c₀ : RBColor)  (n₀ : Nat) {path : Path α}  {t : RBNode α}  (ht : t.Balanced c n)      (H : zoom (cmp v) t = (t', path)) : (path.insert t' v).setBlack = (t.insert cmp v).setBlack := by have ⟨_, _, ht', hp'⟩ := ht.zoom .root H; sorry",
  "name": "zoom_insert",
  "kind": "theorem",
  "first-tactic": "have ⟨_, _, ht', hp'⟩ := ht.zoom .root H",
  "core-prompt":
  "(c₀ : RBColor)  (n₀ : Nat) {path : Path α}  {t : RBNode α}  (ht : t.Balanced c n)      (H : zoom (cmp v) t = (t', path)) : (path.insert t' v).setBlack = (t.insert cmp v).setBlack",
  "args":
  "(c₀ : RBColor)  (n₀ : Nat) {path : Path α}  {t : RBNode α}  (ht : t.Balanced c n)      (H : zoom (cmp v) t = (t', path))"},
 {"type": "∃ n, (path.del t c').Balanced black n",
  "tactic-prompt":
  "theorem (c₀ : RBColor)  (n₀ : Nat) {path : Path α}      (hp : path.Balanced c₀ n₀ c n)  (ht : t.DelProp c' n)  (hc : c = black → c' ≠ red) : ∃ n, (path.del t c').Balanced black n := by induction hp generalizing t c' with\n  | root => match c', ht with\n    | red, ⟨_, h⟩ | black, ⟨_, _, h⟩ => exact h.setBlack\n  | @redL _ n _ _ hb hp ih => match c', n, ht with\n    | red, _, _ => cases hc rfl rfl\n    | black, _, ⟨_, rfl, ha⟩ => exact ih ((hb.balLeft ha).of_false (fun.)) (fun.)\n  | @redR _ n _ _ ha hp ih => match c', n, ht with\n    | red, _, _ => cases hc rfl rfl\n    | black, _, ⟨_, rfl, hb⟩ => exact ih ((ha.balRight hb).of_false (fun.)) (fun.)\n  | @blackL _ _ n _ _ _ hb hp ih => match c', n, ht with\n    | red, _, ⟨_, ha⟩ => exact ih ⟨_, rfl, .redred ⟨⟩ ha hb⟩ (fun.)\n    | black, _, ⟨_, rfl, ha⟩ => exact ih ⟨_, rfl, (hb.balLeft ha).imp fun _ => ⟨⟩⟩ (fun.)\n  | @blackR _ _ n _ _ _ ha hp ih =>  match c', n, ht with\n    | red, _, ⟨_, hb⟩ => exact ih ⟨_, rfl, .redred ⟨⟩ ha hb⟩ (fun.)\n    | black, _, ⟨_, rfl, hb⟩ => exact ih ⟨_, rfl, (ha.balRight hb).imp fun _ => ⟨⟩⟩ (fun.); sorry",
  "name": "Balanced.del",
  "kind": "theorem",
  "first-tactic":
  "induction hp generalizing t c' with\n  | root => match c', ht with\n    | red, ⟨_, h⟩ | black, ⟨_, _, h⟩ => exact h.setBlack\n  | @redL _ n _ _ hb hp ih => match c', n, ht with\n    | red, _, _ => cases hc rfl rfl\n    | black, _, ⟨_, rfl, ha⟩ => exact ih ((hb.balLeft ha).of_false (fun.)) (fun.)\n  | @redR _ n _ _ ha hp ih => match c', n, ht with\n    | red, _, _ => cases hc rfl rfl\n    | black, _, ⟨_, rfl, hb⟩ => exact ih ((ha.balRight hb).of_false (fun.)) (fun.)\n  | @blackL _ _ n _ _ _ hb hp ih => match c', n, ht with\n    | red, _, ⟨_, ha⟩ => exact ih ⟨_, rfl, .redred ⟨⟩ ha hb⟩ (fun.)\n    | black, _, ⟨_, rfl, ha⟩ => exact ih ⟨_, rfl, (hb.balLeft ha).imp fun _ => ⟨⟩⟩ (fun.)\n  | @blackR _ _ n _ _ _ ha hp ih =>  match c', n, ht with\n    | red, _, ⟨_, hb⟩ => exact ih ⟨_, rfl, .redred ⟨⟩ ha hb⟩ (fun.)\n    | black, _, ⟨_, rfl, hb⟩ => exact ih ⟨_, rfl, (ha.balRight hb).imp fun _ => ⟨⟩⟩ (fun.)",
  "core-prompt":
  "(c₀ : RBColor)  (n₀ : Nat) {path : Path α}      (hp : path.Balanced c₀ n₀ c n)  (ht : t.DelProp c' n)  (hc : c = black → c' ≠ red) : ∃ n, (path.del t c').Balanced black n",
  "args":
  "(c₀ : RBColor)  (n₀ : Nat) {path : Path α}      (hp : path.Balanced c₀ n₀ c n)  (ht : t.DelProp c' n)  (hc : c = black → c' ≠ red)"},
 {"type": "∃ c n, (t.alter cut f).Balanced c n",
  "tactic-prompt":
  "theorem (c₀ : RBColor)  (n₀ : Nat) {t : RBNode α}      (h : t.Balanced c n) : ∃ c n, (t.alter cut f).Balanced c n := by simp [alter]; sorry",
  "name": "Balanced.alter",
  "kind": "theorem",
  "first-tactic": "simp [alter]",
  "core-prompt":
  "(c₀ : RBColor)  (n₀ : Nat) {t : RBNode α}      (h : t.Balanced c n) : ∃ c n, (t.alter cut f).Balanced c n",
  "args":
  "(c₀ : RBColor)  (n₀ : Nat) {t : RBNode α}      (h : t.Balanced c n)"},
 {"type": "t.Ordered cmp ∧ ∃ c n, t.Balanced c n",
  "tactic-prompt":
  "theorem (c₀ : RBColor)  (n₀ : Nat) {t : RBNode α}  (h : t.WF cmp) : t.Ordered cmp ∧ ∃ c n, t.Balanced c n := by induction h; sorry",
  "name": "WF.out",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "(c₀ : RBColor)  (n₀ : Nat) {t : RBNode α}  (h : t.WF cmp) : t.Ordered cmp ∧ ∃ c n, t.Balanced c n",
  "args": "(c₀ : RBColor)  (n₀ : Nat) {t : RBNode α}  (h : t.WF cmp)"},
 {"type": "∀ l₁ l₂, map f (l₁ ++ l₂) = map f l₁ ++ map f l₂",
  "tactic-prompt":
  "theorem (f : α → β) : ∀ l₁ l₂, map f (l₁ ++ l₂) = map f l₁ ++ map f l₂ := by intro l₁; sorry",
  "name": "map_append",
  "kind": "theorem",
  "first-tactic": "intro l₁",
  "core-prompt":
  "(f : α → β) : ∀ l₁ l₂, map f (l₁ ++ l₂) = map f l₁ ++ map f l₂",
  "args": "(f : α → β)"},
 {"type": "map id l = l",
  "tactic-prompt":
  "theorem (l : List α) : map id l = l := by induction l; sorry",
  "name": "map_id",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List α) : map id l = l",
  "args": "(l : List α)"},
 {"type": "map g (map f l) = map (g ∘ f) l",
  "tactic-prompt":
  "theorem (g : β → γ)  (f : α → β)  (l : List α) : map g (map f l) = map (g ∘ f) l := by induction l; sorry",
  "name": "map_map",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(g : β → γ)  (f : α → β)  (l : List α) : map g (map f l) = map (g ∘ f) l",
  "args": "(g : β → γ)  (f : α → β)  (l : List α)"},
 {"type": "List.bind [] f = []",
  "tactic-prompt":
  "theorem (f : α → List β) : List.bind [] f = [] := by simp [join]; sorry",
  "name": "nil_bind",
  "kind": "theorem",
  "first-tactic": "simp [join]",
  "core-prompt": "(f : α → List β) : List.bind [] f = []",
  "args": "(f : α → List β)"},
 {"type": "List.bind l id = l.join",
  "tactic-prompt":
  "theorem (l : List (List α)) : List.bind l id = l.join := by simp [List.bind]; sorry",
  "name": "bind_id",
  "kind": "theorem",
  "first-tactic": "simp [List.bind]",
  "core-prompt": "(l : List (List α)) : List.bind l id = l.join",
  "args": "(l : List (List α))"},
 {"type": "(l.map f).reverse = l.reverse.map f",
  "tactic-prompt":
  "theorem (f : α → β)  (l : List α) : (l.map f).reverse = l.reverse.map f := by induction l; sorry",
  "name": "reverse_map",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : α → β)  (l : List α) : (l.map f).reverse = l.reverse.map f",
  "args": "(f : α → β)  (l : List α)"},
 {"type": "take i l = l",
  "tactic-prompt":
  "theorem {l : List α}  (h : l.length ≤ i) : take i l = l := by have := take_append_drop i l; sorry",
  "name": "take_length_le",
  "kind": "theorem",
  "first-tactic": "have := take_append_drop i l",
  "core-prompt": "{l : List α}  (h : l.length ≤ i) : take i l = l",
  "args": "{l : List α}  (h : l.length ≤ i)"},
 {"type": "(l.concat a).reverse = a :: l.reverse",
  "tactic-prompt":
  "theorem (l : List α)  (a : α) : (l.concat a).reverse = a :: l.reverse := by rw [concat_eq_append]; sorry",
  "name": "reverse_concat",
  "kind": "theorem",
  "first-tactic": "rw [concat_eq_append]",
  "core-prompt":
  "(l : List α)  (a : α) : (l.concat a).reverse = a :: l.reverse",
  "args": "(l : List α)  (a : α)"},
 {"type": "l.foldr cons l' = l ++ l'",
  "tactic-prompt":
  "theorem (l : List α) : l.foldr cons l' = l ++ l' := by induction l; sorry",
  "name": "foldr_self_append",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List α) : l.foldr cons l' = l ++ l'",
  "args": "(l : List α)"},
 {"type": "l.foldr cons [] = l",
  "tactic-prompt":
  "theorem (l : List α) : l.foldr cons [] = l := by simp; sorry",
  "name": "foldr_self",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(l : List α) : l.foldr cons [] = l",
  "args": "(l : List α)"},
 {"type": "mapM' f l = mapM f l",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (f : α → m β)  (l : List α) : mapM' f l = mapM f l := by simp [go]; sorry",
  "name": "mapM'_eq_mapM",
  "kind": "theorem",
  "first-tactic": "simp [go]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (f : α → m β)  (l : List α) : mapM' f l = mapM f l",
  "args": "[Monad m]  [LawfulMonad m]  (f : α → m β)  (l : List α)"},
 {"type": "(a :: l).mapM f = (return (← f a) :: (← l.mapM f))",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (f : α → m β) : (a :: l).mapM f = (return (← f a) :: (← l.mapM f)) := by simp [← mapM'_eq_mapM]; sorry",
  "name": "mapM_cons",
  "kind": "theorem",
  "first-tactic": "simp [← mapM'_eq_mapM]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (f : α → m β) : (a :: l).mapM f = (return (← f a) :: (← l.mapM f))",
  "args": "[Monad m]  [LawfulMonad m]  (f : α → m β)"},
 {"type": "(l₁ ++ l₂).mapM f = (return (← l₁.mapM f) ++ (← l₂.mapM f))",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (f : α → m β)  {l₁ l₂ : List α} : (l₁ ++ l₂).mapM f = (return (← l₁.mapM f) ++ (← l₂.mapM f)) := by induction l₁; sorry",
  "name": "mapM_append",
  "kind": "theorem",
  "first-tactic": "induction l₁",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (f : α → m β)  {l₁ l₂ : List α} : (l₁ ++ l₂).mapM f = (return (← l₁.mapM f) ++ (← l₂.mapM f))",
  "args": "[Monad m]  [LawfulMonad m]  (f : α → m β)  {l₁ l₂ : List α}"},
 {"type": "@set = @setTR",
  "tactic-prompt": "theorem  : @set = @setTR := by funext α l n a; sorry",
  "name": "set_eq_setTR",
  "kind": "theorem",
  "first-tactic": "funext α l n a",
  "core-prompt": " : @set = @setTR",
  "args": ""},
 {"type": "@List.erase = @eraseTR",
  "tactic-prompt":
  "theorem  : @List.erase = @eraseTR := by funext α _ l a; sorry",
  "name": "erase_eq_eraseTR",
  "kind": "theorem",
  "first-tactic": "funext α _ l a",
  "core-prompt": " : @List.erase = @eraseTR",
  "args": ""},
 {"type": "@eraseIdx = @eraseIdxTR",
  "tactic-prompt":
  "theorem  : @eraseIdx = @eraseIdxTR := by funext α l n; sorry",
  "name": "eraseIdx_eq_eraseIdxTR",
  "kind": "theorem",
  "first-tactic": "funext α l n",
  "core-prompt": " : @eraseIdx = @eraseIdxTR",
  "args": ""},
 {"type": "@List.bind = @bindTR",
  "tactic-prompt":
  "theorem  : @List.bind = @bindTR := by funext α β as f; sorry",
  "name": "bind_eq_bindTR",
  "kind": "theorem",
  "first-tactic": "funext α β as f",
  "core-prompt": " : @List.bind = @bindTR",
  "args": ""},
 {"type": "@join = @joinTR",
  "tactic-prompt": "theorem  : @join = @joinTR := by funext α l; sorry",
  "name": "join_eq_joinTR",
  "kind": "theorem",
  "first-tactic": "funext α l",
  "core-prompt": " : @join = @joinTR",
  "args": ""},
 {"type": "@List.filterMap = @filterMapTR",
  "tactic-prompt":
  "theorem  : @List.filterMap = @filterMapTR := by funext α β f l; sorry",
  "name": "filterMap_eq_filterMapTR",
  "kind": "theorem",
  "first-tactic": "funext α β f l",
  "core-prompt": " : @List.filterMap = @filterMapTR",
  "args": ""},
 {"type": "@List.replace = @replaceTR",
  "tactic-prompt":
  "theorem  : @List.replace = @replaceTR := by funext α _ l b c; sorry",
  "name": "replace_eq_replaceTR",
  "kind": "theorem",
  "first-tactic": "funext α _ l b c",
  "core-prompt": " : @List.replace = @replaceTR",
  "args": ""},
 {"type": "@take = @takeTR",
  "tactic-prompt": "theorem  : @take = @takeTR := by funext α n l; sorry",
  "name": "take_eq_takeTR",
  "kind": "theorem",
  "first-tactic": "funext α n l",
  "core-prompt": " : @take = @takeTR",
  "args": ""},
 {"type": "@takeWhile = @takeWhileTR",
  "tactic-prompt":
  "theorem  : @takeWhile = @takeWhileTR := by funext α p l; sorry",
  "name": "takeWhile_eq_takeWhileTR",
  "kind": "theorem",
  "first-tactic": "funext α p l",
  "core-prompt": " : @takeWhile = @takeWhileTR",
  "args": ""},
 {"type": "@foldr = @foldrTR",
  "tactic-prompt":
  "theorem  : @foldr = @foldrTR := by funext α β f init l; sorry",
  "name": "foldr_eq_foldrTR",
  "kind": "theorem",
  "first-tactic": "funext α β f init l",
  "core-prompt": " : @foldr = @foldrTR",
  "args": ""},
 {"type": "@zipWith = @zipWithTR",
  "tactic-prompt":
  "theorem  : @zipWith = @zipWithTR := by funext α β γ f as bs; sorry",
  "name": "zipWith_eq_zipWithTR",
  "kind": "theorem",
  "first-tactic": "funext α β γ f as bs",
  "core-prompt": " : @zipWith = @zipWithTR",
  "args": ""},
 {"type": "@unzip = @unzipTR",
  "tactic-prompt": "theorem  : @unzip = @unzipTR := by funext α β l; sorry",
  "name": "unzip_eq_unzipTR",
  "kind": "theorem",
  "first-tactic": "funext α β l",
  "core-prompt": " : @unzip = @unzipTR",
  "args": ""},
 {"type": "@enumFrom = @enumFromTR",
  "tactic-prompt":
  "theorem  : @enumFrom = @enumFromTR := by funext α n l; sorry",
  "name": "enumFrom_eq_enumFromTR",
  "kind": "theorem",
  "first-tactic": "funext α n l",
  "core-prompt": " : @enumFrom = @enumFromTR",
  "args": ""},
 {"type": "@dropLast = @dropLastTR",
  "tactic-prompt": "theorem  : @dropLast = @dropLastTR := by funext α l; sorry",
  "name": "dropLast_eq_dropLastTR",
  "kind": "theorem",
  "first-tactic": "funext α l",
  "core-prompt": " : @dropLast = @dropLastTR",
  "args": ""},
 {"type": "@intersperse = @intersperseTR",
  "tactic-prompt":
  "theorem  : @intersperse = @intersperseTR := by funext α sep l; sorry",
  "name": "intersperse_eq_intersperseTR",
  "kind": "theorem",
  "first-tactic": "funext α sep l",
  "core-prompt": " : @intersperse = @intersperseTR",
  "args": ""},
 {"type": "@intercalate = @intercalateTR",
  "tactic-prompt":
  "theorem  : @intercalate = @intercalateTR := by funext α sep l; sorry",
  "name": "intercalate_eq_intercalateTR",
  "kind": "theorem",
  "first-tactic": "funext α sep l",
  "core-prompt": " : @intercalate = @intercalateTR",
  "args": ""},
 {"type": "@removeNth = @removeNthTR",
  "tactic-prompt":
  "theorem  : @removeNth = @removeNthTR := by funext α l n; sorry",
  "name": "removeNth_eq_removeNthTR",
  "kind": "theorem",
  "first-tactic": "funext α l n",
  "core-prompt": " : @removeNth = @removeNthTR",
  "args": ""},
 {"type": "@replaceF = @replaceFTR",
  "tactic-prompt":
  "theorem  : @replaceF = @replaceFTR := by funext α f l; sorry",
  "name": "replaceF_eq_replaceFTR",
  "kind": "theorem",
  "first-tactic": "funext α f l",
  "core-prompt": " : @replaceF = @replaceFTR",
  "args": ""},
 {"type": "@modifyNth = @modifyNthTR",
  "tactic-prompt":
  "theorem  : @modifyNth = @modifyNthTR := by funext α f n l; sorry",
  "name": "modifyNth_eq_modifyNthTR",
  "kind": "theorem",
  "first-tactic": "funext α f n l",
  "core-prompt": " : @modifyNth = @modifyNthTR",
  "args": ""},
 {"type": "@insertNth = @insertNthTR",
  "tactic-prompt":
  "theorem  : @insertNth = @insertNthTR := by funext α f n l; sorry",
  "name": "insertNth_eq_insertNthTR",
  "kind": "theorem",
  "first-tactic": "funext α f n l",
  "core-prompt": " : @insertNth = @insertNthTR",
  "args": ""},
 {"type": "@takeD = @takeDTR",
  "tactic-prompt": "theorem  : @takeD = @takeDTR := by funext α f n l; sorry",
  "name": "takeD_eq_takeDTR",
  "kind": "theorem",
  "first-tactic": "funext α f n l",
  "core-prompt": " : @takeD = @takeDTR",
  "args": ""},
 {"type": "@leftpad = @leftpadTR",
  "tactic-prompt":
  "theorem  : @leftpad = @leftpadTR := by funext α n a l; sorry",
  "name": "leftpad_eq_leftpadTR",
  "kind": "theorem",
  "first-tactic": "funext α n a l",
  "core-prompt": " : @leftpad = @leftpadTR",
  "args": ""},
 {"type": "@scanl = @scanlTR",
  "tactic-prompt": "theorem  : @scanl = @scanlTR := by funext α f n l; sorry",
  "name": "scanl_eq_scanlTR",
  "kind": "theorem",
  "first-tactic": "funext α f n l",
  "core-prompt": " : @scanl = @scanlTR",
  "args": ""},
 {"type": "@inits = @initsTR",
  "tactic-prompt": "theorem  : @inits = @initsTR := by funext α l; sorry",
  "name": "inits_eq_initsTR",
  "kind": "theorem",
  "first-tactic": "funext α l",
  "core-prompt": " : @inits = @initsTR",
  "args": ""},
 {"type": "@tails = @tailsTR",
  "tactic-prompt": "theorem  : @tails = @tailsTR := by funext α; sorry",
  "name": "tails_eq_tailsTR",
  "kind": "theorem",
  "first-tactic": "funext α",
  "core-prompt": " : @tails = @tailsTR",
  "args": ""},
 {"type": "@sections = @sectionsTR",
  "tactic-prompt": "theorem  : @sections = @sectionsTR := by funext α L; sorry",
  "name": "sections_eq_sectionsTR",
  "kind": "theorem",
  "first-tactic": "funext α L",
  "core-prompt": " : @sections = @sectionsTR",
  "args": ""},
 {"type": "@eraseP = @erasePTR",
  "tactic-prompt": "theorem  : @eraseP = @erasePTR := by funext α p l; sorry",
  "name": "eraseP_eq_erasePTR",
  "kind": "theorem",
  "first-tactic": "funext α p l",
  "core-prompt": " : @eraseP = @erasePTR",
  "args": ""},
 {"type": "@product = @productTR",
  "tactic-prompt":
  "theorem  : @product = @productTR := by funext α β l₁ l₂; sorry",
  "name": "product_eq_productTR",
  "kind": "theorem",
  "first-tactic": "funext α β l₁ l₂",
  "core-prompt": " : @product = @productTR",
  "args": ""},
 {"type": "@List.sigma = @sigmaTR",
  "tactic-prompt":
  "theorem  : @List.sigma = @sigmaTR := by funext α β l₁ l₂; sorry",
  "name": "sigma_eq_sigmaTR",
  "kind": "theorem",
  "first-tactic": "funext α β l₁ l₂",
  "core-prompt": " : @List.sigma = @sigmaTR",
  "args": ""},
 {"type": "@range' = @range'TR",
  "tactic-prompt": "theorem  : @range' = @range'TR := by funext s n; sorry",
  "name": "range'_eq_range'TR",
  "kind": "theorem",
  "first-tactic": "funext s n",
  "core-prompt": " : @range' = @range'TR",
  "args": ""},
 {"type": "@dropSlice = @dropSliceTR",
  "tactic-prompt":
  "theorem  : @dropSlice = @dropSliceTR := by funext α n m l; sorry",
  "name": "dropSlice_eq_dropSliceTR",
  "kind": "theorem",
  "first-tactic": "funext α n m l",
  "core-prompt": " : @dropSlice = @dropSliceTR",
  "args": ""},
 {"type": "@zipWithLeft' = @zipWithLeft'TR",
  "tactic-prompt":
  "theorem  : @zipWithLeft' = @zipWithLeft'TR := by funext α β γ f as bs; sorry",
  "name": "zipWithLeft'_eq_zipWithLeft'TR",
  "kind": "theorem",
  "first-tactic": "funext α β γ f as bs",
  "core-prompt": " : @zipWithLeft' = @zipWithLeft'TR",
  "args": ""},
 {"type": "@zipWithLeft = @zipWithLeftTR",
  "tactic-prompt":
  "theorem  : @zipWithLeft = @zipWithLeftTR := by funext α β γ f as bs; sorry",
  "name": "zipWithLeft_eq_zipWithLeftTR",
  "kind": "theorem",
  "first-tactic": "funext α β γ f as bs",
  "core-prompt": " : @zipWithLeft = @zipWithLeftTR",
  "args": ""},
 {"type": "@fillNones = @fillNonesTR",
  "tactic-prompt":
  "theorem  : @fillNones = @fillNonesTR := by funext α as as'; sorry",
  "name": "fillNones_eq_fillNonesTR",
  "kind": "theorem",
  "first-tactic": "funext α as as'",
  "core-prompt": " : @fillNones = @fillNonesTR",
  "args": ""},
 {"type": "@takeList = @takeListTR",
  "tactic-prompt":
  "theorem  : @takeList = @takeListTR := by funext α xs ns; sorry",
  "name": "takeList_eq_takeListTR",
  "kind": "theorem",
  "first-tactic": "funext α xs ns",
  "core-prompt": " : @takeList = @takeListTR",
  "args": ""},
 {"type": "a ∈ ([] : List α) ↔ False",
  "tactic-prompt":
  "theorem (a : α) : a ∈ ([] : List α) ↔ False := by simp; sorry",
  "name": "mem_nil_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a : α) : a ∈ ([] : List α) ↔ False",
  "args": "(a : α)"},
 {"type": "l ≠ []",
  "tactic-prompt":
  "theorem {a : α}  {l : List α}  (h : a ∈ l) : l ≠ [] := by cases h; sorry",
  "name": "ne_nil_of_mem",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt": "{a : α}  {l : List α}  (h : a ∈ l) : l ≠ []",
  "args": "{a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "p ++ q = [] ↔ p = [] ∧ q = []",
  "tactic-prompt":
  "theorem  : p ++ q = [] ↔ p = [] ∧ q = [] := by cases p; sorry",
  "name": "append_eq_nil",
  "kind": "theorem",
  "first-tactic": "cases p",
  "core-prompt": " : p ++ q = [] ↔ p = [] ∧ q = []",
  "args": ""},
 {"type": "s ≠ [] → s ++ t ≠ []",
  "tactic-prompt":
  "theorem (s t : List α) : s ≠ [] → s ++ t ≠ [] := by simp_all; sorry",
  "name": "append_ne_nil_of_ne_nil_left",
  "kind": "theorem",
  "first-tactic": "simp_all",
  "core-prompt": "(s t : List α) : s ≠ [] → s ++ t ≠ []",
  "args": "(s t : List α)"},
 {"type": "t ≠ [] → s ++ t ≠ []",
  "tactic-prompt":
  "theorem (s t : List α) : t ≠ [] → s ++ t ≠ [] := by simp_all; sorry",
  "name": "append_ne_nil_of_ne_nil_right",
  "kind": "theorem",
  "first-tactic": "simp_all",
  "core-prompt": "(s t : List α) : t ≠ [] → s ++ t ≠ []",
  "args": "(s t : List α)"},
 {"type": "[] = a ++ b ↔ a = [] ∧ b = []",
  "tactic-prompt":
  "theorem  : [] = a ++ b ↔ a = [] ∧ b = [] := by rw [eq_comm]; sorry",
  "name": "nil_eq_append",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt": " : [] = a ++ b ↔ a = [] ∧ b = []",
  "args": ""},
 {"type": "a ++ b ≠ []",
  "tactic-prompt":
  "theorem (a b : List α)  (h0 : a ≠ []) : a ++ b ≠ [] := by simp [*]; sorry",
  "name": "append_ne_nil_of_left_ne_nil",
  "kind": "theorem",
  "first-tactic": "simp [*]",
  "core-prompt": "(a b : List α)  (h0 : a ≠ []) : a ++ b ≠ []",
  "args": "(a b : List α)  (h0 : a ≠ [])"},
 {"type":
  "a ++ b = x :: c ↔ (a = [] ∧ b = x :: c) ∨ (∃ a', a = x :: a' ∧ c = a' ++ b)",
  "tactic-prompt":
  "theorem  : a ++ b = x :: c ↔ (a = [] ∧ b = x :: c) ∨ (∃ a', a = x :: a' ∧ c = a' ++ b) := by cases a; sorry",
  "name": "append_eq_cons",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  " : a ++ b = x :: c ↔ (a = [] ∧ b = x :: c) ∨ (∃ a', a = x :: a' ∧ c = a' ++ b)",
  "args": ""},
 {"type":
  "x :: c = a ++ b ↔ (a = [] ∧ b = x :: c) ∨ (∃ a', a = x :: a' ∧ c = a' ++ b)",
  "tactic-prompt":
  "theorem  : x :: c = a ++ b ↔ (a = [] ∧ b = x :: c) ∨ (∃ a', a = x :: a' ∧ c = a' ++ b) := by rw [eq_comm]; sorry",
  "name": "cons_eq_append",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt":
  " : x :: c = a ++ b ↔ (a = [] ∧ b = x :: c) ∨ (∃ a', a = x :: a' ∧ c = a' ++ b)",
  "args": ""},
 {"type":
  "a ++ b = c ++ d ↔ (∃ a', c = a ++ a' ∧ b = a' ++ d) ∨ ∃ c', a = c ++ c' ∧ d = c' ++ b",
  "tactic-prompt":
  "theorem {a b c d : List α} : a ++ b = c ++ d ↔ (∃ a', c = a ++ a' ∧ b = a' ++ d) ∨ ∃ c', a = c ++ c' ∧ d = c' ++ b := by induction a generalizing c with\n  | nil => simp; exact (or_iff_left_of_imp fun ⟨_, ⟨e, rfl⟩, h⟩ => e ▸ h.symm).symm\n  | cons a as ih => cases c; sorry",
  "name": "append_eq_append_iff",
  "kind": "theorem",
  "first-tactic":
  "induction a generalizing c with\n  | nil => simp; exact (or_iff_left_of_imp fun ⟨_, ⟨e, rfl⟩, h⟩ => e ▸ h.symm).symm\n  | cons a as ih => cases c",
  "core-prompt":
  "{a b c d : List α} : a ++ b = c ++ d ↔ (∃ a', c = a ++ a' ∧ b = a' ++ d) ∨ ∃ c', a = c ++ c' ∧ d = c' ++ b",
  "args": "{a b c d : List α}"},
 {"type": "a ∈ s ++ t ↔ a ∈ s ∨ a ∈ t",
  "tactic-prompt":
  "theorem {a : α}  {s t : List α} : a ∈ s ++ t ↔ a ∈ s ∨ a ∈ t := by induction s; sorry",
  "name": "mem_append",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt": "{a : α}  {s t : List α} : a ∈ s ++ t ↔ a ∈ s ∨ a ∈ t",
  "args": "{a : α}  {s t : List α}"},
 {"type": "(∀ i ∈ l.map f, P i) ↔ ∀ j ∈ l, P (f j)",
  "tactic-prompt":
  "theorem {f : α → β}  {l : List α}  {P : β → Prop} : (∀ i ∈ l.map f, P i) ↔ ∀ j ∈ l, P (f j) := by simp [mem_map]; sorry",
  "name": "forall_mem_map_iff",
  "kind": "theorem",
  "first-tactic": "simp [mem_map]",
  "core-prompt":
  "{f : α → β}  {l : List α}  {P : β → Prop} : (∀ i ∈ l.map f, P i) ↔ ∀ j ∈ l, P (f j)",
  "args": "{f : α → β}  {l : List α}  {P : β → Prop}"},
 {"type": "List.map f l = [] ↔ l = []",
  "tactic-prompt":
  "theorem {f : α → β}  {l : List α} : List.map f l = [] ↔ l = [] := by constructor; sorry",
  "name": "map_eq_nil",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{f : α → β}  {l : List α} : List.map f l = [] ↔ l = []",
  "args": "{f : α → β}  {l : List α}"},
 {"type": "(∃ x ∈ a :: l, p x) ↔ p a ∨ ∃ x ∈ l, p x",
  "tactic-prompt":
  "theorem {p : α → Prop}  {a : α}  {l : List α} : (∃ x ∈ a :: l, p x) ↔ p a ∨ ∃ x ∈ l, p x := by simp; sorry",
  "name": "exists_mem_cons",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{p : α → Prop}  {a : α}  {l : List α} : (∃ x ∈ a :: l, p x) ↔ p a ∨ ∃ x ∈ l, p x",
  "args": "{p : α → Prop}  {a : α}  {l : List α}"},
 {"type": "(∀ x ∈ a :: l, p x) ↔ p a ∧ ∀ x ∈ l, p x",
  "tactic-prompt":
  "theorem {p : α → Prop}  {a : α}  {l : List α} : (∀ x ∈ a :: l, p x) ↔ p a ∧ ∀ x ∈ l, p x := by simp; sorry",
  "name": "forall_mem_cons",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{p : α → Prop}  {a : α}  {l : List α} : (∀ x ∈ a :: l, p x) ↔ p a ∧ ∀ x ∈ l, p x",
  "args": "{p : α → Prop}  {a : α}  {l : List α}"},
 {"type": "(∀ x ∈ [a], p x) ↔ p a",
  "tactic-prompt":
  "theorem {p : α → Prop}  {a : α} : (∀ x ∈ [a], p x) ↔ p a := by simp only [mem_singleton]; sorry",
  "name": "forall_mem_singleton",
  "kind": "theorem",
  "first-tactic": "simp only [mem_singleton]",
  "core-prompt": "{p : α → Prop}  {a : α} : (∀ x ∈ [a], p x) ↔ p a",
  "args": "{p : α → Prop}  {a : α}"},
 {"type": "(∀ x ∈ l₁ ++ l₂, p x) ↔ (∀ x ∈ l₁, p x) ∧ (∀ x ∈ l₂, p x)",
  "tactic-prompt":
  "theorem {p : α → Prop}  {l₁ l₂ : List α} : (∀ x ∈ l₁ ++ l₂, p x) ↔ (∀ x ∈ l₁, p x) ∧ (∀ x ∈ l₂, p x) := by simp only [mem_append]; sorry",
  "name": "forall_mem_append",
  "kind": "theorem",
  "first-tactic": "simp only [mem_append]",
  "core-prompt":
  "{p : α → Prop}  {l₁ l₂ : List α} : (∀ x ∈ l₁ ++ l₂, p x) ↔ (∀ x ∈ l₁, p x) ∧ (∀ x ∈ l₂, p x)",
  "args": "{p : α → Prop}  {l₁ l₂ : List α}"},
 {"type": "a :: l ⊆ m ↔ a ∈ m ∧ l ⊆ m",
  "tactic-prompt":
  "theorem  : a :: l ⊆ m ↔ a ∈ m ∧ l ⊆ m := by simp only [subset_def]; sorry",
  "name": "cons_subset",
  "kind": "theorem",
  "first-tactic": "simp only [subset_def]",
  "core-prompt": " : a :: l ⊆ m ↔ a ∈ m ∧ l ⊆ m",
  "args": ""},
 {"type": "l₁ ++ l₂ ⊆ l ↔ l₁ ⊆ l ∧ l₂ ⊆ l",
  "tactic-prompt":
  "theorem {l₁ l₂ l : List α} : l₁ ++ l₂ ⊆ l ↔ l₁ ⊆ l ∧ l₂ ⊆ l := by simp [subset_def]; sorry",
  "name": "append_subset",
  "kind": "theorem",
  "first-tactic": "simp [subset_def]",
  "core-prompt": "{l₁ l₂ l : List α} : l₁ ++ l₂ ⊆ l ↔ l₁ ⊆ l ∧ l₂ ⊆ l",
  "args": "{l₁ l₂ l : List α}"},
 {"type":
  "∀ (h₁ : a :: l ≠ nil) (h₂ : l ≠ nil),\n  getLast (a :: l) h₁ = getLast l h₂",
  "tactic-prompt":
  "theorem {a : α}  {l : List α} : ∀ (h₁ : a :: l ≠ nil) (h₂ : l ≠ nil),\n  getLast (a :: l) h₁ = getLast l h₂ := by induction l; sorry",
  "name": "getLast_cons'",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : α}  {l : List α} : ∀ (h₁ : a :: l ≠ nil) (h₂ : l ≠ nil),\n  getLast (a :: l) h₁ = getLast l h₂",
  "args": "{a : α}  {l : List α}"},
 {"type": "tailD l l' = (tail? l).getD l'",
  "tactic-prompt":
  "theorem (l l' : List α) : tailD l l' = (tail? l).getD l' := by cases l; sorry",
  "name": "tailD_eq_tail?",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "(l l' : List α) : tailD l l' = (tail? l).getD l'",
  "args": "(l l' : List α)"},
 {"type": "@getLast! α _ (a::l) = getLastD l a",
  "tactic-prompt":
  "theorem [Inhabited α] : @getLast! α _ (a::l) = getLastD l a := by simp [getLast!]; sorry",
  "name": "getLast!_cons",
  "kind": "theorem",
  "first-tactic": "simp [getLast!]",
  "core-prompt": "[Inhabited α] : @getLast! α _ (a::l) = getLastD l a",
  "args": "[Inhabited α]"},
 {"type": "@getLast? α (a::l) = getLastD l a",
  "tactic-prompt":
  "theorem  : @getLast? α (a::l) = getLastD l a := by simp [getLast?]; sorry",
  "name": "getLast?_cons",
  "kind": "theorem",
  "first-tactic": "simp [getLast?]",
  "core-prompt": " : @getLast? α (a::l) = getLastD l a",
  "args": ""},
 {"type": "dropLast (l₁ ++ b::l₂) = l₁ ++ dropLast (b::l₂)",
  "tactic-prompt":
  "theorem  : dropLast (l₁ ++ b::l₂) = l₁ ++ dropLast (b::l₂) := by induction l₁; sorry",
  "name": "dropLast_append_cons",
  "kind": "theorem",
  "first-tactic": "induction l₁",
  "core-prompt": " : dropLast (l₁ ++ b::l₂) = l₁ ++ dropLast (b::l₂)",
  "args": ""},
 {"type": "dropLast (l₁ ++ [b]) = l₁",
  "tactic-prompt": "theorem  : dropLast (l₁ ++ [b]) = l₁ := by simp; sorry",
  "name": "dropLast_concat",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : dropLast (l₁ ++ [b]) = l₁",
  "args": ""},
 {"type": "l.get? 0 = l.head?",
  "tactic-prompt":
  "theorem (l : List α) : l.get? 0 = l.head? := by cases l; sorry",
  "name": "get?_zero",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "(l : List α) : l.get? 0 = l.head?",
  "args": "(l : List α)"},
 {"type": "l[i]? = l.get? i",
  "tactic-prompt":
  "theorem (l : List α)  (i : Nat) : l[i]? = l.get? i := by unfold getElem?; sorry",
  "name": "getElem?_eq_get?",
  "kind": "theorem",
  "first-tactic": "unfold getElem?",
  "core-prompt": "(l : List α)  (i : Nat) : l[i]? = l.get? i",
  "args": "(l : List α)  (i : Nat)"},
 {"type": "i = j",
  "tactic-prompt":
  "theorem (h₀ : i < xs.length)  (h₁ : Nodup xs)  (h₂ : xs.get? i = xs.get? j) : i = j := by induction xs generalizing i j with\n  | nil => cases h₀\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases h₁ with\n      | cons ha h₁ => exact ih (Nat.lt_of_succ_lt_succ h₀) h₁ h₂\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at h₂\n      cases h₁; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact ⟨_, h₂⟩; exact ⟨_ , h₂.symm⟩; sorry",
  "name": "get?_inj",
  "kind": "theorem",
  "first-tactic":
  "induction xs generalizing i j with\n  | nil => cases h₀\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases h₁ with\n      | cons ha h₁ => exact ih (Nat.lt_of_succ_lt_succ h₀) h₁ h₂\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at h₂\n      cases h₁; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact ⟨_, h₂⟩; exact ⟨_ , h₂.symm⟩",
  "core-prompt":
  "(h₀ : i < xs.length)  (h₁ : Nodup xs)  (h₂ : xs.get? i = xs.get? j) : i = j",
  "args":
  "(h₀ : i < xs.length)  (h₁ : Nodup xs)  (h₂ : xs.get? i = xs.get? j)"},
 {"type": "get l i = get l' ⟨i, h ▸ i.2⟩",
  "tactic-prompt":
  "theorem {l l' : List α}  (h : l = l')  (i : Fin l.length) : get l i = get l' ⟨i, h ▸ i.2⟩ := by cases h; sorry",
  "name": "get_of_eq",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{l l' : List α}  (h : l = l')  (i : Fin l.length) : get l i = get l' ⟨i, h ▸ i.2⟩",
  "args": "{l l' : List α}  (h : l = l')  (i : Fin l.length)"},
 {"type": "n - l₁.length < l₂.length",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  {n : Nat}    (h₁ : l₁.length ≤ n)  (h₂ : n < (l₁ ++ l₂).length) : n - l₁.length < l₂.length := by rw [length_append] at h₂; sorry",
  "name": "get_append_right_aux",
  "kind": "theorem",
  "first-tactic": "rw [length_append] at h₂",
  "core-prompt":
  "{l₁ l₂ : List α}  {n : Nat}    (h₁ : l₁.length ≤ n)  (h₂ : n < (l₁ ++ l₂).length) : n - l₁.length < l₂.length",
  "args":
  "{l₁ l₂ : List α}  {n : Nat}    (h₁ : l₁.length ≤ n)  (h₂ : n < (l₁ ++ l₂).length)"},
 {"type": "(l₁ ++ l₂).get? n = l₁.get? n",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  {n : Nat}  (hn : n < l₁.length) : (l₁ ++ l₂).get? n = l₁.get? n := by have hn' : n < (l₁ ++ l₂).length := Nat.lt_of_lt_of_le hn <| by\n    rw [length_append]; sorry",
  "name": "get?_append",
  "kind": "theorem",
  "first-tactic":
  "have hn' : n < (l₁ ++ l₂).length := Nat.lt_of_lt_of_le hn <| by\n    rw [length_append]",
  "core-prompt":
  "{l₁ l₂ : List α}  {n : Nat}  (hn : n < l₁.length) : (l₁ ++ l₂).get? n = l₁.get? n",
  "args": "{l₁ l₂ : List α}  {n : Nat}  (hn : n < l₁.length)"},
 {"type": "getLast? (l ++ [a]) = some a",
  "tactic-prompt":
  "theorem (l : List α) : getLast? (l ++ [a]) = some a := by simp [getLast?_eq_get?]; sorry",
  "name": "getLast?_concat",
  "kind": "theorem",
  "first-tactic": "simp [getLast?_eq_get?]",
  "core-prompt": "(l : List α) : getLast? (l ++ [a]) = some a",
  "args": "(l : List α)"},
 {"type":
  "(x :: xs).get ⟨n, by simp [h]⟩ = (x :: xs).getLast (cons_ne_nil x xs)",
  "tactic-prompt":
  "theorem (x : α)  (xs : List α)  (n : Nat)  (h : n = xs.length) : (x :: xs).get ⟨n, by simp [h]⟩ = (x :: xs).getLast (cons_ne_nil x xs) := by rw [getLast_eq_get]; sorry",
  "name": "get_cons_length",
  "kind": "theorem",
  "first-tactic": "rw [getLast_eq_get]",
  "core-prompt":
  "(x : α)  (xs : List α)  (n : Nat)  (h : n = xs.length) : (x :: xs).get ⟨n, by simp [h]⟩ = (x :: xs).getLast (cons_ne_nil x xs)",
  "args": "(x : α)  (xs : List α)  (n : Nat)  (h : n = xs.length)"},
 {"type": "length (take n l) = n",
  "tactic-prompt":
  "theorem (h : n ≤ length l) : length (take n l) = n := by simp [Nat.min_eq_left h]; sorry",
  "name": "length_take_of_le",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_eq_left h]",
  "core-prompt": "(h : n ≤ length l) : length (take n l) = n",
  "args": "(h : n ≤ length l)"},
 {"type": "∃ l₁ l₂, l = l₁ ++ l₂ ∧ map f l₁ = s₁ ∧ map f l₂ = s₂",
  "tactic-prompt":
  "theorem {f : α → β}  {l : List α}  {s₁ s₂ : List β}      (h : map f l = s₁ ++ s₂) : ∃ l₁ l₂, l = l₁ ++ l₂ ∧ map f l₁ = s₁ ∧ map f l₂ = s₂ := by have := h; sorry",
  "name": "map_eq_append_split",
  "kind": "theorem",
  "first-tactic": "have := h",
  "core-prompt":
  "{f : α → β}  {l : List α}  {s₁ s₂ : List β}      (h : map f l = s₁ ++ s₂) : ∃ l₁ l₂, l = l₁ ++ l₂ ∧ map f l₁ = s₁ ∧ map f l₂ = s₂",
  "args":
  "{f : α → β}  {l : List α}  {s₁ s₂ : List β}      (h : map f l = s₁ ++ s₂)"},
 {"type":
  "∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ l₁.length = n ∧ l.set n a' = l₁ ++ a' :: l₂",
  "tactic-prompt":
  "theorem {l : List α}  (h : n < l.length) : ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ l₁.length = n ∧ l.set n a' = l₁ ++ a' :: l₂ := by rw [set_eq_modifyNth]; sorry",
  "name": "exists_of_set",
  "kind": "theorem",
  "first-tactic": "rw [set_eq_modifyNth]",
  "core-prompt":
  "{l : List α}  (h : n < l.length) : ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ l₁.length = n ∧ l.set n a' = l₁ ++ a' :: l₂",
  "args": "{l : List α}  (h : n < l.length)"},
 {"type": "(l.set i a).get ⟨i, h⟩ = a",
  "tactic-prompt":
  "theorem (l : List α)  (i : Nat)  (a : α)  (h : i < (l.set i a).length) : (l.set i a).get ⟨i, h⟩ = a := by rw [← Option.some_inj]; sorry",
  "name": "get_set_eq",
  "kind": "theorem",
  "first-tactic": "rw [← Option.some_inj]",
  "core-prompt":
  "(l : List α)  (i : Nat)  (a : α)  (h : i < (l.set i a).length) : (l.set i a).get ⟨i, h⟩ = a",
  "args": "(l : List α)  (i : Nat)  (a : α)  (h : i < (l.set i a).length)"},
 {"type": "(l.set i a).get ⟨j, hj⟩ = l.get ⟨j, by simp at hj; exact hj⟩",
  "tactic-prompt":
  "theorem {l : List α}  {i j : Nat}  (h : i ≠ j)  (a : α)      (hj : j < (l.set i a).length) : (l.set i a).get ⟨j, hj⟩ = l.get ⟨j, by simp at hj; exact hj⟩ := by rw [← Option.some_inj]; sorry",
  "name": "get_set_ne",
  "kind": "theorem",
  "first-tactic": "rw [← Option.some_inj]",
  "core-prompt":
  "{l : List α}  {i j : Nat}  (h : i ≠ j)  (a : α)      (hj : j < (l.set i a).length) : (l.set i a).get ⟨j, hj⟩ = l.get ⟨j, by simp at hj; exact hj⟩",
  "args":
  "{l : List α}  {i j : Nat}  (h : i ≠ j)  (a : α)      (hj : j < (l.set i a).length)"},
 {"type": "length (tail l) = length l - 1",
  "tactic-prompt":
  "theorem (l : List α) : length (tail l) = length l - 1 := by cases l; sorry",
  "name": "length_tail",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "(l : List α) : length (tail l) = length l - 1",
  "args": "(l : List α)"},
 {"type": "l.all p ↔ ∀ x ∈ l, p x",
  "tactic-prompt":
  "theorem {l : List α} : l.all p ↔ ∀ x ∈ l, p x := by induction l; sorry",
  "name": "all_eq_true",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "{l : List α} : l.all p ↔ ∀ x ∈ l, p x",
  "args": "{l : List α}"},
 {"type": "l.any p ↔ ∃ x ∈ l, p x",
  "tactic-prompt":
  "theorem {l : List α} : l.any p ↔ ∃ x ∈ l, p x := by induction l; sorry",
  "name": "any_eq_true",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "{l : List α} : l.any p ↔ ∃ x ∈ l, p x",
  "args": "{l : List α}"},
 {"type": "x ∈ reverse as ↔ x ∈ as",
  "tactic-prompt":
  "theorem (x : α)  (as : List α) : x ∈ reverse as ↔ x ∈ as := by simp [reverse]; sorry",
  "name": "mem_reverse",
  "kind": "theorem",
  "first-tactic": "simp [reverse]",
  "core-prompt": "(x : α)  (as : List α) : x ∈ reverse as ↔ x ∈ as",
  "args": "(x : α)  (as : List α)"},
 {"type": "l.insert a = l",
  "tactic-prompt":
  "theorem [DecidableEq α] {l : List α}  (h : a ∈ l) : l.insert a = l := by simp only [List.insert]; sorry",
  "name": "insert_of_mem",
  "kind": "theorem",
  "first-tactic": "simp only [List.insert]",
  "core-prompt": "[DecidableEq α] {l : List α}  (h : a ∈ l) : l.insert a = l",
  "args": "[DecidableEq α] {l : List α}  (h : a ∈ l)"},
 {"type": "l.insert a = a :: l",
  "tactic-prompt":
  "theorem [DecidableEq α] {l : List α}  (h : a ∉ l) : l.insert a = a :: l := by simp only [List.insert]; sorry",
  "name": "insert_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp only [List.insert]",
  "core-prompt":
  "[DecidableEq α] {l : List α}  (h : a ∉ l) : l.insert a = a :: l",
  "args": "[DecidableEq α] {l : List α}  (h : a ∉ l)"},
 {"type": "a ∈ l.insert b ↔ a = b ∨ a ∈ l",
  "tactic-prompt":
  "theorem [DecidableEq α] {l : List α} : a ∈ l.insert b ↔ a = b ∨ a ∈ l := by if h : b ∈ l then\n    rw [insert_of_mem h]\n    constructor; {apply Or.inr}\n    intro\n    | Or.inl h' => rw [h']; exact h\n    | Or.inr h' => exact h'\n  else rw [insert_of_not_mem h]; sorry",
  "name": "mem_insert_iff",
  "kind": "theorem",
  "first-tactic":
  "if h : b ∈ l then\n    rw [insert_of_mem h]\n    constructor; {apply Or.inr}\n    intro\n    | Or.inl h' => rw [h']; exact h\n    | Or.inr h' => exact h'\n  else rw [insert_of_not_mem h]",
  "core-prompt":
  "[DecidableEq α] {l : List α} : a ∈ l.insert b ↔ a = b ∨ a ∈ l",
  "args": "[DecidableEq α] {l : List α}"},
 {"type": "length (l.insert a) = length l",
  "tactic-prompt":
  "theorem [DecidableEq α] {l : List α}  (h : a ∈ l) : length (l.insert a) = length l := by rw [insert_of_mem h]; sorry",
  "name": "length_insert_of_mem",
  "kind": "theorem",
  "first-tactic": "rw [insert_of_mem h]",
  "core-prompt":
  "[DecidableEq α] {l : List α}  (h : a ∈ l) : length (l.insert a) = length l",
  "args": "[DecidableEq α] {l : List α}  (h : a ∈ l)"},
 {"type": "length (l.insert a) = length l + 1",
  "tactic-prompt":
  "theorem [DecidableEq α] {l : List α}  (h : a ∉ l) : length (l.insert a) = length l + 1 := by rw [insert_of_not_mem h]; sorry",
  "name": "length_insert_of_not_mem",
  "kind": "theorem",
  "first-tactic": "rw [insert_of_not_mem h]",
  "core-prompt":
  "[DecidableEq α] {l : List α}  (h : a ∉ l) : length (l.insert a) = length l + 1",
  "args": "[DecidableEq α] {l : List α}  (h : a ∉ l)"},
 {"type": "l.eraseP p = l",
  "tactic-prompt":
  "theorem {l : List α}  (h : ∀ a, a ∈ l → ¬p a) : l.eraseP p = l := by induction l; sorry",
  "name": "eraseP_of_forall_not",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "{l : List α}  (h : ∀ a, a ∈ l → ¬p a) : l.eraseP p = l",
  "args": "{l : List α}  (h : ∀ a, a ∈ l → ¬p a)"},
 {"type": "length (l.eraseP p) = Nat.pred (length l)",
  "tactic-prompt":
  "theorem (al : a ∈ l)  (pa : p a) : length (l.eraseP p) = Nat.pred (length l) := by let ⟨_, l₁, l₂, _, _, e₁, e₂⟩ := exists_of_eraseP al pa; sorry",
  "name": "length_eraseP_of_mem",
  "kind": "theorem",
  "first-tactic": "let ⟨_, l₁, l₂, _, _, e₁, e₂⟩ := exists_of_eraseP al pa",
  "core-prompt":
  "(al : a ∈ l)  (pa : p a) : length (l.eraseP p) = Nat.pred (length l)",
  "args": "(al : a ∈ l)  (pa : p a)"},
 {"type": "a ∈ l.eraseP p ↔ a ∈ l",
  "tactic-prompt":
  "theorem {l : List α}  (pa : ¬p a) : a ∈ l.eraseP p ↔ a ∈ l := by refine ⟨mem_of_mem_eraseP, fun al => ?_⟩; sorry",
  "name": "mem_eraseP_of_neg",
  "kind": "theorem",
  "first-tactic": "refine ⟨mem_of_mem_eraseP, fun al => ?_⟩",
  "core-prompt": "{l : List α}  (pa : ¬p a) : a ∈ l.eraseP p ↔ a ∈ l",
  "args": "{l : List α}  (pa : ¬p a)"},
 {"type": "extractP p l = (find? p l, eraseP p l)",
  "tactic-prompt":
  "theorem (l : List α) : extractP p l = (find? p l, eraseP p l) := by let rec go (acc) : ∀ xs, l = acc.data ++ xs →\n    extractP.go p l xs acc = (xs.find? p, acc.data ++ xs.eraseP p)\n  | [] => fun h => by simp [extractP.go, find?, eraseP, h]\n  | x::xs => by\n    simp [extractP.go, find?, eraseP]; cases p x; sorry",
  "name": "extractP_eq_find?_eraseP",
  "kind": "theorem",
  "first-tactic":
  "let rec go (acc) : ∀ xs, l = acc.data ++ xs →\n    extractP.go p l xs acc = (xs.find? p, acc.data ++ xs.eraseP p)\n  | [] => fun h => by simp [extractP.go, find?, eraseP, h]\n  | x::xs => by\n    simp [extractP.go, find?, eraseP]; cases p x",
  "core-prompt": "(l : List α) : extractP p l = (find? p l, eraseP p l)",
  "args": "(l : List α)"},
 {"type": "(a :: l).erase a = l",
  "tactic-prompt":
  "theorem [DecidableEq α] (a : α)  (l : List α) : (a :: l).erase a = l := by simp [erase_cons]; sorry",
  "name": "erase_cons_head",
  "kind": "theorem",
  "first-tactic": "simp [erase_cons]",
  "core-prompt": "[DecidableEq α] (a : α)  (l : List α) : (a :: l).erase a = l",
  "args": "[DecidableEq α] (a : α)  (l : List α)"},
 {"type": "(b :: l).erase a = b :: l.erase a",
  "tactic-prompt":
  "theorem [DecidableEq α] {a b : α}  (l : List α)  (h : b ≠ a) : (b :: l).erase a = b :: l.erase a := by simp only [erase_cons]; sorry",
  "name": "erase_cons_tail",
  "kind": "theorem",
  "first-tactic": "simp only [erase_cons]",
  "core-prompt":
  "[DecidableEq α] {a b : α}  (l : List α)  (h : b ≠ a) : (b :: l).erase a = b :: l.erase a",
  "args": "[DecidableEq α] {a b : α}  (l : List α)  (h : b ≠ a)"},
 {"type": "∃ l₁ l₂, a ∉ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.erase a = l₁ ++ l₂",
  "tactic-prompt":
  "theorem [DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l) : ∃ l₁ l₂, a ∉ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.erase a = l₁ ++ l₂ := by let ⟨_, l₁, l₂, h₁, e, h₂, h₃⟩ := exists_of_eraseP h (beq_self_eq_true _); sorry",
  "name": "exists_erase_eq",
  "kind": "theorem",
  "first-tactic":
  "let ⟨_, l₁, l₂, h₁, e, h₂, h₃⟩ := exists_of_eraseP h (beq_self_eq_true _)",
  "core-prompt":
  "[DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l) : ∃ l₁ l₂, a ∉ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.erase a = l₁ ++ l₂",
  "args": "[DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "length (l.erase a) = Nat.pred (length l)",
  "tactic-prompt":
  "theorem [DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l) : length (l.erase a) = Nat.pred (length l) := by rw [erase_eq_eraseP]; sorry",
  "name": "length_erase_of_mem",
  "kind": "theorem",
  "first-tactic": "rw [erase_eq_eraseP]",
  "core-prompt":
  "[DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l) : length (l.erase a) = Nat.pred (length l)",
  "args": "[DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "(l₁ ++ l₂).erase a = (l₁ ++ l₂.erase a)",
  "tactic-prompt":
  "theorem [DecidableEq α] {a : α}  {l₁ : List α}  (l₂ : List α)  (h : a ∉ l₁) : (l₁ ++ l₂).erase a = (l₁ ++ l₂.erase a) := by rw [erase_eq_eraseP]; sorry",
  "name": "erase_append_right",
  "kind": "theorem",
  "first-tactic": "rw [erase_eq_eraseP]",
  "core-prompt":
  "[DecidableEq α] {a : α}  {l₁ : List α}  (l₂ : List α)  (h : a ∉ l₁) : (l₁ ++ l₂).erase a = (l₁ ++ l₂.erase a)",
  "args":
  "[DecidableEq α] {a : α}  {l₁ : List α}  (l₂ : List α)  (h : a ∉ l₁)"},
 {"type": "(l.erase a).erase b = (l.erase b).erase a",
  "tactic-prompt":
  "theorem [DecidableEq α] (a b : α)  (l : List α) : (l.erase a).erase b = (l.erase b).erase a := by if ab : a = b then rw [ab] else ?_; sorry",
  "name": "erase_comm",
  "kind": "theorem",
  "first-tactic": "if ab : a = b then rw [ab] else ?_",
  "core-prompt":
  "[DecidableEq α] (a b : α)  (l : List α) : (l.erase a).erase b = (l.erase b).erase a",
  "args": "[DecidableEq α] (a b : α)  (l : List α)"},
 {"type": "x ∈ filter p as ↔ x ∈ as ∧ p x",
  "tactic-prompt":
  "theorem  : x ∈ filter p as ↔ x ∈ as ∧ p x := by induction as; sorry",
  "name": "mem_filter",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt": " : x ∈ filter p as ↔ x ∈ as ∧ p x",
  "args": ""},
 {"type": "partition p l = (filter p l, filter (not ∘ p) l)",
  "tactic-prompt":
  "theorem (p : α → Bool)  (l : List α) : partition p l = (filter p l, filter (not ∘ p) l) := by simp [partition]; sorry",
  "name": "partition_eq_filter_filter",
  "kind": "theorem",
  "first-tactic": "simp [partition]",
  "core-prompt":
  "(p : α → Bool)  (l : List α) : partition p l = (filter p l, filter (not ∘ p) l)",
  "args": "(p : α → Bool)  (l : List α)"},
 {"type": "(l.map f).Pairwise R ↔ l.Pairwise (fun a b => R (f a) (f b))",
  "tactic-prompt":
  "theorem {l : List α} : (l.map f).Pairwise R ↔ l.Pairwise (fun a b => R (f a) (f b)) := by induction l; sorry",
  "name": "pairwise_map",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{l : List α} : (l.map f).Pairwise R ↔ l.Pairwise (fun a b => R (f a) (f b))",
  "args": "{l : List α}"},
 {"type":
  "(l₁ ++ l₂).Pairwise R ↔ l₁.Pairwise R ∧ l₂.Pairwise R ∧ ∀ a ∈ l₁, ∀ b ∈ l₂, R a b",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α} : (l₁ ++ l₂).Pairwise R ↔ l₁.Pairwise R ∧ l₂.Pairwise R ∧ ∀ a ∈ l₁, ∀ b ∈ l₂, R a b := by induction l₁; sorry",
  "name": "pairwise_append",
  "kind": "theorem",
  "first-tactic": "induction l₁",
  "core-prompt":
  "{l₁ l₂ : List α} : (l₁ ++ l₂).Pairwise R ↔ l₁.Pairwise R ∧ l₂.Pairwise R ∧ ∀ a ∈ l₁, ∀ b ∈ l₂, R a b",
  "args": "{l₁ l₂ : List α}"},
 {"type": "l.reverse.Pairwise R ↔ l.Pairwise (fun a b => R b a)",
  "tactic-prompt":
  "theorem {l : List α} : l.reverse.Pairwise R ↔ l.Pairwise (fun a b => R b a) := by induction l; sorry",
  "name": "pairwise_reverse",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{l : List α} : l.reverse.Pairwise R ↔ l.Pairwise (fun a b => R b a)",
  "args": "{l : List α}"},
 {"type": "length (replaceF f l) = length l",
  "tactic-prompt":
  "theorem  : length (replaceF f l) = length l := by induction l; sorry",
  "name": "length_replaceF",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": " : length (replaceF f l) = length l",
  "args": ""},
 {"type": "Disjoint l₁ l₂ ↔ ∀ ⦃a⦄, a ∈ l₁ → a ∉ l₂",
  "tactic-prompt":
  "theorem  : Disjoint l₁ l₂ ↔ ∀ ⦃a⦄, a ∈ l₁ → a ∉ l₂ := by simp [Disjoint]; sorry",
  "name": "disjoint_left",
  "kind": "theorem",
  "first-tactic": "simp [Disjoint]",
  "core-prompt": " : Disjoint l₁ l₂ ↔ ∀ ⦃a⦄, a ∈ l₁ → a ∉ l₂",
  "args": ""},
 {"type": "Disjoint l []",
  "tactic-prompt":
  "theorem (l : List α) : Disjoint l [] := by rw [disjoint_comm]; sorry",
  "name": "disjoint_nil_right",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_comm]",
  "core-prompt": "(l : List α) : Disjoint l []",
  "args": "(l : List α)"},
 {"type": "Disjoint [a] l ↔ a ∉ l",
  "tactic-prompt":
  "theorem  : Disjoint [a] l ↔ a ∉ l := by simp [Disjoint]; sorry",
  "name": "singleton_disjoint",
  "kind": "theorem",
  "first-tactic": "simp [Disjoint]",
  "core-prompt": " : Disjoint [a] l ↔ a ∉ l",
  "args": ""},
 {"type": "Disjoint l [a] ↔ a ∉ l",
  "tactic-prompt":
  "theorem  : Disjoint l [a] ↔ a ∉ l := by rw [disjoint_comm]; sorry",
  "name": "disjoint_singleton",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_comm]",
  "core-prompt": " : Disjoint l [a] ↔ a ∉ l",
  "args": ""},
 {"type": "Disjoint (l₁ ++ l₂) l ↔ Disjoint l₁ l ∧ Disjoint l₂ l",
  "tactic-prompt":
  "theorem  : Disjoint (l₁ ++ l₂) l ↔ Disjoint l₁ l ∧ Disjoint l₂ l := by simp [Disjoint]; sorry",
  "name": "disjoint_append_left",
  "kind": "theorem",
  "first-tactic": "simp [Disjoint]",
  "core-prompt": " : Disjoint (l₁ ++ l₂) l ↔ Disjoint l₁ l ∧ Disjoint l₂ l",
  "args": ""},
 {"type": "(l.map f).foldl g init = l.foldl (fun x y => g x (f y)) init",
  "tactic-prompt":
  "theorem (f : β₁ → β₂)  (g : α → β₂ → α)  (l : List β₁)  (init : α) : (l.map f).foldl g init = l.foldl (fun x y => g x (f y)) init := by induction l generalizing init; sorry",
  "name": "foldl_map",
  "kind": "theorem",
  "first-tactic": "induction l generalizing init",
  "core-prompt":
  "(f : β₁ → β₂)  (g : α → β₂ → α)  (l : List β₁)  (init : α) : (l.map f).foldl g init = l.foldl (fun x y => g x (f y)) init",
  "args": "(f : β₁ → β₂)  (g : α → β₂ → α)  (l : List β₁)  (init : α)"},
 {"type": "(l.map f).foldr g init = l.foldr (fun x y => g (f x) y) init",
  "tactic-prompt":
  "theorem (f : α₁ → α₂)  (g : α₂ → β → β)  (l : List α₁)  (init : β) : (l.map f).foldr g init = l.foldr (fun x y => g (f x) y) init := by induction l generalizing init; sorry",
  "name": "foldr_map",
  "kind": "theorem",
  "first-tactic": "induction l generalizing init",
  "core-prompt":
  "(f : α₁ → α₂)  (g : α₂ → β → β)  (l : List α₁)  (init : β) : (l.map f).foldr g init = l.foldr (fun x y => g (f x) y) init",
  "args": "(f : α₁ → α₂)  (g : α₂ → β → β)  (l : List α₁)  (init : β)"},
 {"type": "l.foldl g₂ (f init) = f (l.foldl g₁ init)",
  "tactic-prompt":
  "theorem (f : α₁ → α₂)  (g₁ : α₁ → β → α₁)  (g₂ : α₂ → β → α₂)  (l : List β)  (init : α₁)      (H : ∀ x y, g₂ (f x) y = f (g₁ x y)) : l.foldl g₂ (f init) = f (l.foldl g₁ init) := by induction l generalizing init; sorry",
  "name": "foldl_hom",
  "kind": "theorem",
  "first-tactic": "induction l generalizing init",
  "core-prompt":
  "(f : α₁ → α₂)  (g₁ : α₁ → β → α₁)  (g₂ : α₂ → β → α₂)  (l : List β)  (init : α₁)      (H : ∀ x y, g₂ (f x) y = f (g₁ x y)) : l.foldl g₂ (f init) = f (l.foldl g₁ init)",
  "args":
  "(f : α₁ → α₂)  (g₁ : α₁ → β → α₁)  (g₂ : α₂ → β → α₂)  (l : List β)  (init : α₁)      (H : ∀ x y, g₂ (f x) y = f (g₁ x y))"},
 {"type": "l.foldr g₂ (f init) = f (l.foldr g₁ init)",
  "tactic-prompt":
  "theorem (f : β₁ → β₂)  (g₁ : α → β₁ → β₁)  (g₂ : α → β₂ → β₂)  (l : List α)  (init : β₁)      (H : ∀ x y, g₂ x (f y) = f (g₁ x y)) : l.foldr g₂ (f init) = f (l.foldr g₁ init) := by induction l; sorry",
  "name": "foldr_hom",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : β₁ → β₂)  (g₁ : α → β₁ → β₁)  (g₂ : α → β₂ → β₂)  (l : List α)  (init : β₁)      (H : ∀ x y, g₂ x (f y) = f (g₁ x y)) : l.foldr g₂ (f init) = f (l.foldr g₁ init)",
  "args":
  "(f : β₁ → β₂)  (g₁ : α → β₁ → β₁)  (g₂ : α → β₂ → β₂)  (l : List α)  (init : β₁)      (H : ∀ x y, g₂ x (f y) = f (g₁ x y))"},
 {"type": "nil.union l = l",
  "tactic-prompt":
  "theorem [DecidableEq α] (l : List α) : nil.union l = l := by simp [List.union]; sorry",
  "name": "nil_union",
  "kind": "theorem",
  "first-tactic": "simp [List.union]",
  "core-prompt": "[DecidableEq α] (l : List α) : nil.union l = l",
  "args": "[DecidableEq α] (l : List α)"},
 {"type": "(a :: l₁).union l₂ = (l₁.union l₂).insert a",
  "tactic-prompt":
  "theorem [DecidableEq α] (a : α)  (l₁ l₂ : List α) : (a :: l₁).union l₂ = (l₁.union l₂).insert a := by simp [List.union]; sorry",
  "name": "cons_union",
  "kind": "theorem",
  "first-tactic": "simp [List.union]",
  "core-prompt":
  "[DecidableEq α] (a : α)  (l₁ l₂ : List α) : (a :: l₁).union l₂ = (l₁.union l₂).insert a",
  "args": "[DecidableEq α] (a : α)  (l₁ l₂ : List α)"},
 {"type": "x ∈ l₁.union l₂ ↔ x ∈ l₁ ∨ x ∈ l₂",
  "tactic-prompt":
  "theorem [DecidableEq α] [DecidableEq α]  {x : α}  {l₁ l₂ : List α} : x ∈ l₁.union l₂ ↔ x ∈ l₁ ∨ x ∈ l₂ := by induction l₁; sorry",
  "name": "mem_union_iff",
  "kind": "theorem",
  "first-tactic": "induction l₁",
  "core-prompt":
  "[DecidableEq α] [DecidableEq α]  {x : α}  {l₁ l₂ : List α} : x ∈ l₁.union l₂ ↔ x ∈ l₁ ∨ x ∈ l₂",
  "args": "[DecidableEq α] [DecidableEq α]  {x : α}  {l₁ l₂ : List α}"},
 {"type": "x ∈ l₁.inter l₂ ↔ x ∈ l₁ ∧ x ∈ l₂",
  "tactic-prompt":
  "theorem [DecidableEq α]  {x : α}  {l₁ l₂ : List α} : x ∈ l₁.inter l₂ ↔ x ∈ l₁ ∧ x ∈ l₂ := by cases l₁; sorry",
  "name": "mem_inter_iff",
  "kind": "theorem",
  "first-tactic": "cases l₁",
  "core-prompt":
  "[DecidableEq α]  {x : α}  {l₁ l₂ : List α} : x ∈ l₁.inter l₂ ↔ x ∈ l₁ ∧ x ∈ l₂",
  "args": "[DecidableEq α]  {x : α}  {l₁ l₂ : List α}"},
 {"type": "(x, y) ∈ product xs ys ↔ x ∈ xs ∧ y ∈ ys",
  "tactic-prompt":
  "theorem {xs : List α}  {ys : List β}  {x : α}  {y : β} : (x, y) ∈ product xs ys ↔ x ∈ xs ∧ y ∈ ys := by simp only [List.product]; sorry",
  "name": "pair_mem_product",
  "kind": "theorem",
  "first-tactic": "simp only [List.product]",
  "core-prompt":
  "{xs : List α}  {ys : List β}  {x : α}  {y : β} : (x, y) ∈ product xs ys ↔ x ∈ xs ∧ y ∈ ys",
  "args": "{xs : List α}  {ys : List β}  {x : α}  {y : β}"},
 {"type": "(leftpad n a l).length = max n l.length",
  "tactic-prompt":
  "theorem (n : Nat)  (a : α)  (l : List α) : (leftpad n a l).length = max n l.length := by simp only [leftpad]; sorry",
  "name": "leftpad_length",
  "kind": "theorem",
  "first-tactic": "simp only [leftpad]",
  "core-prompt":
  "(n : Nat)  (a : α)  (l : List α) : (leftpad n a l).length = max n l.length",
  "args": "(n : Nat)  (a : α)  (l : List α)"},
 {"type": "isPrefix (replicate (n - length l) a) (leftpad n a l)",
  "tactic-prompt":
  "theorem (n : Nat)  (a : α)  (l : List α) : isPrefix (replicate (n - length l) a) (leftpad n a l) := by simp only [isPrefix]; sorry",
  "name": "leftpad_prefix",
  "kind": "theorem",
  "first-tactic": "simp only [isPrefix]",
  "core-prompt":
  "(n : Nat)  (a : α)  (l : List α) : isPrefix (replicate (n - length l) a) (leftpad n a l)",
  "args": "(n : Nat)  (a : α)  (l : List α)"},
 {"type": "isSuffix l (leftpad n a l)",
  "tactic-prompt":
  "theorem (n : Nat)  (a : α)  (l : List α) : isSuffix l (leftpad n a l) := by simp only [isSuffix]; sorry",
  "name": "leftpad_suffix",
  "kind": "theorem",
  "first-tactic": "simp only [isSuffix]",
  "core-prompt":
  "(n : Nat)  (a : α)  (l : List α) : isSuffix l (leftpad n a l)",
  "args": "(n : Nat)  (a : α)  (l : List α)"},
 {"type": "some a = some b ↔ a = b",
  "tactic-prompt":
  "theorem {a b : α} : some a = some b ↔ a = b := by simp; sorry",
  "name": "some_inj",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "{a b : α} : some a = some b ↔ a = b",
  "args": "{a b : α}"},
 {"type": "some (x.getD y) = x",
  "tactic-prompt":
  "theorem {x : Option α}  (hx : x ≠ none)  (y : α) : some (x.getD y) = x := by cases x; sorry",
  "name": "getD_of_ne_none",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{x : Option α}  (hx : x ≠ none)  (y : α) : some (x.getD y) = x",
  "args": "{x : Option α}  (hx : x ≠ none)  (y : α)"},
 {"type": "isSome x ↔ ∃ a, x = some a",
  "tactic-prompt": "theorem  : isSome x ↔ ∃ a, x = some a := by cases x; sorry",
  "name": "isSome_iff_exists",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": " : isSome x ↔ ∃ a, x = some a",
  "args": ""},
 {"type": "isSome a = false ↔ a.isNone = true",
  "tactic-prompt":
  "theorem  : isSome a = false ↔ a.isNone = true := by cases a; sorry",
  "name": "not_isSome",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": " : isSome a = false ↔ a.isNone = true",
  "args": ""},
 {"type": "o = some a ↔ ∃ h : o.isSome, o.get h = a",
  "tactic-prompt":
  "theorem  : o = some a ↔ ∃ h : o.isSome, o.get h = a := by cases o; sorry",
  "name": "eq_some_iff_get_eq",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": " : o = some a ↔ ∃ h : o.isSome, o.get h = a",
  "args": ""},
 {"type": "¬o.isSome ↔ o = none",
  "tactic-prompt": "theorem  : ¬o.isSome ↔ o = none := by cases o; sorry",
  "name": "not_isSome_iff_eq_none",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": " : ¬o.isSome ↔ o = none",
  "args": ""},
 {"type": "o ≠ none ↔ o.isSome",
  "tactic-prompt": "theorem  : o ≠ none ↔ o.isSome := by cases o; sorry",
  "name": "ne_none_iff_isSome",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": " : o ≠ none ↔ o.isSome",
  "args": ""},
 {"type": "o ≠ none ↔ ∃ x, some x = o",
  "tactic-prompt": "theorem  : o ≠ none ↔ ∃ x, some x = o := by cases o; sorry",
  "name": "ne_none_iff_exists",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": " : o ≠ none ↔ ∃ x, some x = o",
  "args": ""},
 {"type": "x.bind some = x",
  "tactic-prompt":
  "theorem (x : Option α) : x.bind some = x := by cases x; sorry",
  "name": "bind_some",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": "(x : Option α) : x.bind some = x",
  "args": "(x : Option α)"},
 {"type": "x.bind f = some b ↔ ∃ a, x = some a ∧ f a = some b",
  "tactic-prompt":
  "theorem  : x.bind f = some b ↔ ∃ a, x = some a ∧ f a = some b := by cases x; sorry",
  "name": "bind_eq_some",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": " : x.bind f = some b ↔ ∃ a, x = some a ∧ f a = some b",
  "args": ""},
 {"type": "o.bind f = none ↔ ∀ b a, a ∈ o → b ∉ f a",
  "tactic-prompt":
  "theorem {o : Option α}  {f : α → Option β} : o.bind f = none ↔ ∀ b a, a ∈ o → b ∉ f a := by simp only [eq_none_iff_forall_not_mem]; sorry",
  "name": "bind_eq_none",
  "kind": "theorem",
  "first-tactic": "simp only [eq_none_iff_forall_not_mem]",
  "core-prompt":
  "{o : Option α}  {f : α → Option β} : o.bind f = none ↔ ∀ b a, a ∈ o → b ∉ f a",
  "args": "{o : Option α}  {f : α → Option β}"},
 {"type":
  "(a.bind fun x => b.bind (f x)) = b.bind fun y => a.bind fun x => f x y",
  "tactic-prompt":
  "theorem {f : α → β → Option γ}  (a : Option α)  (b : Option β) : (a.bind fun x => b.bind (f x)) = b.bind fun y => a.bind fun x => f x y := by cases a; sorry",
  "name": "bind_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : α → β → Option γ}  (a : Option α)  (b : Option β) : (a.bind fun x => b.bind (f x)) = b.bind fun y => a.bind fun x => f x y",
  "args": "{f : α → β → Option γ}  (a : Option α)  (b : Option β)"},
 {"type": "(x.bind f).bind g = x.bind fun y => (f y).bind g",
  "tactic-prompt":
  "theorem (x : Option α)  (f : α → Option β)  (g : β → Option γ) : (x.bind f).bind g = x.bind fun y => (f y).bind g := by cases x; sorry",
  "name": "bind_assoc",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "(x : Option α)  (f : α → Option β)  (g : β → Option γ) : (x.bind f).bind g = x.bind fun y => (f y).bind g",
  "args": "(x : Option α)  (f : α → Option β)  (g : β → Option γ)"},
 {"type": "x.join = some a ↔ x = some (some a)",
  "tactic-prompt":
  "theorem  : x.join = some a ↔ x = some (some a) := by simp; sorry",
  "name": "join_eq_some",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : x.join = some a ↔ x = some (some a)",
  "args": ""},
 {"type": "x.join ≠ none ↔ ∃ z, x = some (some z)",
  "tactic-prompt":
  "theorem  : x.join ≠ none ↔ ∃ z, x = some (some z) := by simp only [ne_none_iff_exists']; sorry",
  "name": "join_ne_none",
  "kind": "theorem",
  "first-tactic": "simp only [ne_none_iff_exists']",
  "core-prompt": " : x.join ≠ none ↔ ∃ z, x = some (some z)",
  "args": ""},
 {"type": "x.map f = some b ↔ ∃ a, x = some a ∧ f a = b",
  "tactic-prompt":
  "theorem  : x.map f = some b ↔ ∃ a, x = some a ∧ f a = b := by cases x; sorry",
  "name": "map_eq_some'",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": " : x.map f = some b ↔ ∃ a, x = some a ∧ f a = b",
  "args": ""},
 {"type": "x.map f = none ↔ x = none",
  "tactic-prompt": "theorem  : x.map f = none ↔ x = none := by cases x; sorry",
  "name": "map_eq_none'",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": " : x.map f = none ↔ x = none",
  "args": ""},
 {"type": "x.map f = x.map g",
  "tactic-prompt":
  "theorem {x : Option α}  (h : ∀ a ∈ x, f a = g a) : x.map f = x.map g := by cases x; sorry",
  "name": "map_congr",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": "{x : Option α}  (h : ∀ a ∈ x, f a = g a) : x.map f = x.map g",
  "args": "{x : Option α}  (h : ∀ a ∈ x, f a = g a)"},
 {"type": "(x.map g).map h = x.map (h ∘ g)",
  "tactic-prompt":
  "theorem (h : β → γ)  (g : α → β)  (x : Option α) : (x.map g).map h = x.map (h ∘ g) := by cases x; sorry",
  "name": "map_map",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "(h : β → γ)  (g : α → β)  (x : Option α) : (x.map g).map h = x.map (h ∘ g)",
  "args": "(h : β → γ)  (g : α → β)  (x : Option α)"},
 {"type": "Option.map g ∘ Option.map f = Option.map (g ∘ f)",
  "tactic-prompt":
  "theorem (f : α → β)  (g : β → γ) : Option.map g ∘ Option.map f = Option.map (g ∘ f) := by funext x; sorry",
  "name": "map_comp_map",
  "kind": "theorem",
  "first-tactic": "funext x",
  "core-prompt":
  "(f : α → β)  (g : β → γ) : Option.map g ∘ Option.map f = Option.map (g ∘ f)",
  "args": "(f : α → β)  (g : β → γ)"},
 {"type": "(x.map (Option.map f)).join = x.join.map f",
  "tactic-prompt":
  "theorem {f : α → β}  {x : Option (Option α)} : (x.map (Option.map f)).join = x.join.map f := by cases x; sorry",
  "name": "join_map_eq_map_join",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{f : α → β}  {x : Option (Option α)} : (x.map (Option.map f)).join = x.join.map f",
  "args": "{f : α → β}  {x : Option (Option α)}"},
 {"type": "x.join.join = (x.map join).join",
  "tactic-prompt":
  "theorem {x : Option (Option (Option α))} : x.join.join = (x.map join).join := by cases x; sorry",
  "name": "join_join",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{x : Option (Option (Option α))} : x.join.join = (x.map join).join",
  "args": "{x : Option (Option (Option α))}"},
 {"type": "(x <|> none) = x",
  "tactic-prompt":
  "theorem (x : Option α) : (x <|> none) = x := by cases x; sorry",
  "name": "orElse_none",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": "(x : Option α) : (x <|> none) = x",
  "args": "(x : Option α)"},
 {"type": "guard p a = some b ↔ a = b ∧ p a",
  "tactic-prompt":
  "theorem [DecidablePred p] : guard p a = some b ↔ a = b ∧ p a := by by_cases h : p a; sorry",
  "name": "guard_eq_some",
  "kind": "theorem",
  "first-tactic": "by_cases h : p a",
  "core-prompt": "[DecidablePred p] : guard p a = some b ↔ a = b ∧ p a",
  "args": "[DecidablePred p]"},
 {"type": "(o.map f).getD (f x) = f (getD o x)",
  "tactic-prompt":
  "theorem (f : α → β)  (x : α)  (o : Option α) : (o.map f).getD (f x) = f (getD o x) := by cases o; sorry",
  "name": "getD_map",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "(f : α → β)  (x : α)  (o : Option α) : (o.map f).getD (f x) = f (getD o x)",
  "args": "(f : α → β)  (x : α)  (o : Option α)"},
 {"type": "choice α = some a",
  "tactic-prompt":
  "theorem {α : Type _}  [Subsingleton α]  (a : α) : choice α = some a := by simp [choice]; sorry",
  "name": "choice_eq",
  "kind": "theorem",
  "first-tactic": "simp [choice]",
  "core-prompt": "{α : Type _}  [Subsingleton α]  (a : α) : choice α = some a",
  "args": "{α : Type _}  [Subsingleton α]  (a : α)"},
 {"type": "Foo",
  "tactic-prompt": "example  : Foo := by fconstructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fconstructor",
  "core-prompt": " : Foo",
  "args": ""},
 {"type": "Foo",
  "tactic-prompt": "example  : Foo := by econstructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "econstructor",
  "core-prompt": " : Foo",
  "args": ""},
 {"type": "a < b",
  "tactic-prompt":
  "example (a b : ℕ)  (foo : False) : a < b := by by_contra'; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra'",
  "core-prompt": "(a b : ℕ)  (foo : False) : a < b",
  "args": "(a b : ℕ)  (foo : False)"},
 {"type": "a < b",
  "tactic-prompt":
  "example (a b : ℕ)  (h : False) : a < b := by by_contra' foo; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra' foo",
  "core-prompt": "(a b : ℕ)  (h : False) : a < b",
  "args": "(a b : ℕ)  (h : False)"},
 {"type": "a < b",
  "tactic-prompt":
  "example (a b : ℕ)  (h : False) : a < b := by by_contra' foo : ¬ a < b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra' foo : ¬ a < b",
  "core-prompt": "(a b : ℕ)  (h : False) : a < b",
  "args": "(a b : ℕ)  (h : False)"},
 {"type": "1 < 2",
  "tactic-prompt": "example  : 1 < 2 := by by_contra'; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra'",
  "core-prompt": " : 1 < 2",
  "args": ""},
 {"type": "¬ ¬ ¬ ¬ ¬ ¬ P",
  "tactic-prompt":
  "example (p : Prop)  (bar : False) : ¬ ¬ ¬ ¬ ¬ ¬ P := by by_contra' foo : ¬ ¬ ¬ P; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra' foo : ¬ ¬ ¬ P",
  "core-prompt": "(p : Prop)  (bar : False) : ¬ ¬ ¬ ¬ ¬ ¬ P",
  "args": "(p : Prop)  (bar : False)"},
 {"type": "¬ ¬ ¬ ¬ ¬ ¬ P",
  "tactic-prompt":
  "example (p : Prop)  (bar : False) : ¬ ¬ ¬ ¬ ¬ ¬ P := by by_contra' : ¬ ¬ ¬ P; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra' : ¬ ¬ ¬ P",
  "core-prompt": "(p : Prop)  (bar : False) : ¬ ¬ ¬ ¬ ¬ ¬ P",
  "args": "(p : Prop)  (bar : False)"},
 {"type":
  "(e.trans e').source = e.source ∩ Set.preimage e (e.target ∩ e'.source)",
  "tactic-prompt":
  "example (e : LocalEquiv α β)  (e' : LocalEquiv β γ) : (e.trans e').source = e.source ∩ Set.preimage e (e.target ∩ e'.source) := by mfld_set_tac; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mfld_set_tac",
  "core-prompt":
  "(e : LocalEquiv α β)  (e' : LocalEquiv β γ) : (e.trans e').source = e.source ∩ Set.preimage e (e.target ∩ e'.source)",
  "args": "(e : LocalEquiv α β)  (e' : LocalEquiv β γ)"},
 {"type": "(e.trans e.symm).source = e.source",
  "tactic-prompt":
  "example (e : LocalEquiv α β) : (e.trans e.symm).source = e.source := by mfld_set_tac; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mfld_set_tac",
  "core-prompt": "(e : LocalEquiv α β) : (e.trans e.symm).source = e.source",
  "args": "(e : LocalEquiv α β)"},
 {"type":
  "f.symm.toLocalEquiv.source ∩ (f.toLocalEquiv.target ∩ Set.preimage f.symm s)\n  = f.symm.toLocalEquiv.source ∩ Set.preimage f.symm s",
  "tactic-prompt":
  "example (s : Set α)  (f : LocalHomeomorph α β) : f.symm.toLocalEquiv.source ∩ (f.toLocalEquiv.target ∩ Set.preimage f.symm s)\n  = f.symm.toLocalEquiv.source ∩ Set.preimage f.symm s := by mfld_set_tac; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mfld_set_tac",
  "core-prompt":
  "(s : Set α)  (f : LocalHomeomorph α β) : f.symm.toLocalEquiv.source ∩ (f.toLocalEquiv.target ∩ Set.preimage f.symm s)\n  = f.symm.toLocalEquiv.source ∩ Set.preimage f.symm s",
  "args": "(s : Set α)  (f : LocalHomeomorph α β)"},
 {"type":
  "(Set.preimage (f ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm))\n      (e₂.toLocalEquiv.trans I'.toLocalEquiv).source) ⊆\n    {y : E |\n    ((e₃.toLocalEquiv.trans I''.toLocalEquiv) ∘\n          (g ∘ f) ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm)) y\n    = (((e₃.toLocalEquiv.trans I''.toLocalEquiv : M'' → E'') ∘\n             g ∘ ((e₂.toLocalEquiv.trans I'.toLocalEquiv).symm)) ∘\n          (e₂.toLocalEquiv.trans I'.toLocalEquiv : M' → E') ∘\n            f ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm)) y}",
  "tactic-prompt":
  "example {I : ModelWithCorners 𝕜 E H}    {I' : ModelWithCorners 𝕜 E' H'}    {I'' : ModelWithCorners 𝕜 E'' H''}    (e₁ : LocalHomeomorph M H)    (e₂ : LocalHomeomorph M' H')    (e₃ : LocalHomeomorph M'' H'')    {f : M → M'}    {g : M' → M''} : (Set.preimage (f ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm))\n      (e₂.toLocalEquiv.trans I'.toLocalEquiv).source) ⊆\n    {y : E |\n    ((e₃.toLocalEquiv.trans I''.toLocalEquiv) ∘\n          (g ∘ f) ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm)) y\n    = (((e₃.toLocalEquiv.trans I''.toLocalEquiv : M'' → E'') ∘\n             g ∘ ((e₂.toLocalEquiv.trans I'.toLocalEquiv).symm)) ∘\n          (e₂.toLocalEquiv.trans I'.toLocalEquiv : M' → E') ∘\n            f ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm)) y} := by mfld_set_tac; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mfld_set_tac",
  "core-prompt":
  "{I : ModelWithCorners 𝕜 E H}    {I' : ModelWithCorners 𝕜 E' H'}    {I'' : ModelWithCorners 𝕜 E'' H''}    (e₁ : LocalHomeomorph M H)    (e₂ : LocalHomeomorph M' H')    (e₃ : LocalHomeomorph M'' H'')    {f : M → M'}    {g : M' → M''} : (Set.preimage (f ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm))\n      (e₂.toLocalEquiv.trans I'.toLocalEquiv).source) ⊆\n    {y : E |\n    ((e₃.toLocalEquiv.trans I''.toLocalEquiv) ∘\n          (g ∘ f) ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm)) y\n    = (((e₃.toLocalEquiv.trans I''.toLocalEquiv : M'' → E'') ∘\n             g ∘ ((e₂.toLocalEquiv.trans I'.toLocalEquiv).symm)) ∘\n          (e₂.toLocalEquiv.trans I'.toLocalEquiv : M' → E') ∘\n            f ∘ ((e₁.toLocalEquiv.trans I.toLocalEquiv).symm)) y}",
  "args":
  "{I : ModelWithCorners 𝕜 E H}    {I' : ModelWithCorners 𝕜 E' H'}    {I'' : ModelWithCorners 𝕜 E'' H''}    (e₁ : LocalHomeomorph M H)    (e₂ : LocalHomeomorph M' H')    (e₃ : LocalHomeomorph M'' H'')    {f : M → M'}    {g : M' → M''}"},
 {"type": "True",
  "tactic-prompt":
  "example {α : Type}  (h : ∀ n m : α, ∀ (h : n = m), ∃ i j : α, i ≠ j ∧ h = h) : True := by choose! i j _x _y using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose! i j _x _y using h",
  "core-prompt":
  "{α : Type}  (h : ∀ n m : α, ∀ (h : n = m), ∃ i j : α, i ≠ j ∧ h = h) : True",
  "args":
  "{α : Type}  (h : ∀ n m : α, ∀ (h : n = m), ∃ i j : α, i ≠ j ∧ h = h)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : ∀ n m : Nat, ∃ i j, m = n + i ∨ m + j = n) : True := by choose i j h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose i j h using h",
  "core-prompt": "(h : ∀ n m : Nat, ∃ i j, m = n + i ∨ m + j = n) : True",
  "args": "(h : ∀ n m : Nat, ∃ i j, m = n + i ∨ m + j = n)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : ∀ i : Nat, i < 7 → ∃ j, i < j ∧ j < i+i) : True := by choose! f h h' using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose! f h h' using h",
  "core-prompt": "(h : ∀ i : Nat, i < 7 → ∃ j, i < j ∧ j < i+i) : True",
  "args": "(h : ∀ i : Nat, i < 7 → ∃ j, i < j ∧ j < i+i)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : ∀ n m : Nat, n < m → ∃ i j, m = n + i ∨ m + j = n) : True := by choose i j h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose i j h using h",
  "core-prompt":
  "(h : ∀ n m : Nat, n < m → ∃ i j, m = n + i ∨ m + j = n) : True",
  "args": "(h : ∀ n m : Nat, n < m → ∃ i j, m = n + i ∨ m + j = n)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : ∀ n m : Nat, n < m → ∃ i j, m = n + i ∨ m + j = n) : True := by choose! i j h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose! i j h using h",
  "core-prompt":
  "(h : ∀ n m : Nat, n < m → ∃ i j, m = n + i ∨ m + j = n) : True",
  "args": "(h : ∀ n m : Nat, n < m → ∃ i j, m = n + i ∨ m + j = n)"},
 {"type": "(∀ m : Nat, ∃ i, ∀ n : Nat, ∃ j, m = n + i ∨ m + j = n) → True",
  "tactic-prompt":
  "example  : (∀ m : Nat, ∃ i, ∀ n : Nat, ∃ j, m = n + i ∨ m + j = n) → True := by choose i j h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose i j h",
  "core-prompt":
  " : (∀ m : Nat, ∃ i, ∀ n : Nat, ∃ j, m = n + i ∨ m + j = n) → True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (h : ∀ _n m : Nat, ∃ i, ∀ n:Nat, ∃ j, m = n + i ∨ m + j = n) : True := by choose i j h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose i j h using h",
  "core-prompt":
  "(h : ∀ _n m : Nat, ∃ i, ∀ n:Nat, ∃ j, m = n + i ∨ m + j = n) : True",
  "args": "(h : ∀ _n m : Nat, ∃ i, ∀ n:Nat, ∃ j, m = n + i ∨ m + j = n)"},
 {"type": "∀ _ : Nat, 1 = 1",
  "tactic-prompt":
  "example (h : ∀ n, ∃ k ≥ 0, n = k) : ∀ _ : Nat, 1 = 1 := by choose u hu using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose u hu using h",
  "core-prompt": "(h : ∀ n, ∃ k ≥ 0, n = k) : ∀ _ : Nat, 1 = 1",
  "args": "(h : ∀ n, ∃ k ≥ 0, n = k)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : ∀ i : Nat, ∃ j, i < j ∧ j < i+i) : True := by choose f h h' using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose f h h' using h",
  "core-prompt": "(h : ∀ i : Nat, ∃ j, i < j ∧ j < i+i) : True",
  "args": "(h : ∀ i : Nat, ∃ j, i < j ∧ j < i+i)"},
 {"type": "True",
  "tactic-prompt":
  "example {α : Type u}  (p : α → Prop)  (h : ∀ i : α, p i → ∃ j : α × α, p j.1) : True := by choose! f h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose! f h using h",
  "core-prompt":
  "{α : Type u}  (p : α → Prop)  (h : ∀ i : α, p i → ∃ j : α × α, p j.1) : True",
  "args":
  "{α : Type u}  (p : α → Prop)  (h : ∀ i : α, p i → ∃ j : α × α, p j.1)"},
 {"type": "¬(p ∧ q) → (p → ¬q)",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : ¬(p ∧ q) → (p → ¬q) := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : ¬(p ∧ q) → (p → ¬q)",
  "args": "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop}"},
 {"type": "(¬ ∀(x : α), p' x) → (∃(x : α), ¬ p' x)",
  "tactic-prompt":
  "example {α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : (¬ ∀(x : α), p' x) → (∃(x : α), ¬ p' x) := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop} : (¬ ∀(x : α), p' x) → (∃(x : α), ¬ p' x)",
  "args": "{α β : Type}  [LinearOrder β]  {p q : Prop}  {p' q' : α → Prop}"},
 {"type": "True",
  "tactic-prompt": "example  : True := by triv; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "triv",
  "core-prompt": " : True",
  "args": ""},
 {"type": "2 + 2 = 4",
  "tactic-prompt": "example  : 2 + 2 = 4 := by triv; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "triv",
  "core-prompt": " : 2 + 2 = 4",
  "args": ""},
 {"type": "False",
  "tactic-prompt":
  "example (P : Prop)  (h1 : P)  (h2 : ¬ P) : False := by fail_if_success triv; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success triv",
  "core-prompt": "(P : Prop)  (h1 : P)  (h2 : ¬ P) : False",
  "args": "(P : Prop)  (h1 : P)  (h2 : ¬ P)"},
 {"type":
  "374 + (32 - (2 * 8123) : ℤ) - 61 * 50 = 86 + 32 * 32 - 4 * 5000\n      ∧ 43 ≤ 74 + (33 : ℤ)",
  "tactic-prompt":
  "example  : 374 + (32 - (2 * 8123) : ℤ) - 61 * 50 = 86 + 32 * 32 - 4 * 5000\n      ∧ 43 ≤ 74 + (33 : ℤ) := by norm_num1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num1",
  "core-prompt":
  " : 374 + (32 - (2 * 8123) : ℤ) - 61 * 50 = 86 + 32 * 32 - 4 * 5000\n      ∧ 43 ≤ 74 + (33 : ℤ)",
  "args": ""},
 {"type": "2 ^ 17 - 1 = 131071",
  "tactic-prompt": "example  : 2 ^ 17 - 1 = 131071 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 2 ^ 17 - 1 = 131071",
  "args": ""},
 {"type": "(5 / 2:ℕ) = 2",
  "tactic-prompt": "example  : (5 / 2:ℕ) = 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (5 / 2:ℕ) = 2",
  "args": ""},
 {"type": "(5 / -2:ℤ) < -1",
  "tactic-prompt": "example  : (5 / -2:ℤ) < -1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (5 / -2:ℤ) < -1",
  "args": ""},
 {"type": "(0 + 1) / 2 < 0 + 1",
  "tactic-prompt": "example  : (0 + 1) / 2 < 0 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (0 + 1) / 2 < 0 + 1",
  "args": ""},
 {"type": "Nat.succ (Nat.succ (2 ^ 3)) = 10",
  "tactic-prompt":
  "example  : Nat.succ (Nat.succ (2 ^ 3)) = 10 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : Nat.succ (Nat.succ (2 ^ 3)) = 10",
  "args": ""},
 {"type": "(12321 - 2 : ℤ) = 12319",
  "tactic-prompt": "example  : (12321 - 2 : ℤ) = 12319 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (12321 - 2 : ℤ) = 12319",
  "args": ""},
 {"type": "100 * 30 < x",
  "tactic-prompt":
  "example (x : ℤ)  (h : 1000 + 2000 < x) : 100 * 30 < x := by norm_num at *; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num at *",
  "core-prompt": "(x : ℤ)  (h : 1000 + 2000 < x) : 100 * 30 < x",
  "args": "(x : ℤ)  (h : 1000 + 2000 < x)"},
 {"type": "(1103 : ℤ) ≤ (2102 : ℤ)",
  "tactic-prompt": "example  : (1103 : ℤ) ≤ (2102 : ℤ) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (1103 : ℤ) ≤ (2102 : ℤ)",
  "args": ""},
 {"type": "(110474 : ℤ) ≤ (210485 : ℤ)",
  "tactic-prompt":
  "example  : (110474 : ℤ) ≤ (210485 : ℤ) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (110474 : ℤ) ≤ (210485 : ℤ)",
  "args": ""},
 {"type": "(11047462383473829263 : ℤ) ≤ (21048574677772382462 : ℤ)",
  "tactic-prompt":
  "example  : (11047462383473829263 : ℤ) ≤ (21048574677772382462 : ℤ) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (11047462383473829263 : ℤ) ≤ (21048574677772382462 : ℤ)",
  "args": ""},
 {"type": "(210485742382937847263 : ℤ) ≤ (1104857462382937847262 : ℤ)",
  "tactic-prompt":
  "example  : (210485742382937847263 : ℤ) ≤ (1104857462382937847262 : ℤ) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  " : (210485742382937847263 : ℤ) ≤ (1104857462382937847262 : ℤ)",
  "args": ""},
 {"type": "(210485987642382937847263 : ℕ) ≤ (11048512347462382937847262 : ℕ)",
  "tactic-prompt":
  "example  : (210485987642382937847263 : ℕ) ≤ (11048512347462382937847262 : ℕ) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  " : (210485987642382937847263 : ℕ) ≤ (11048512347462382937847262 : ℕ)",
  "args": ""},
 {"type": "(2 * 12868 + 25705) * 11621 ^ 2 ≤ 23235 ^ 2 * 12868",
  "tactic-prompt":
  "example  : (2 * 12868 + 25705) * 11621 ^ 2 ≤ 23235 ^ 2 * 12868 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (2 * 12868 + 25705) * 11621 ^ 2 ≤ 23235 ^ 2 * 12868",
  "args": ""},
 {"type": "true",
  "tactic-prompt": "example  : true := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : true",
  "args": ""},
 {"type": "true ∧ true",
  "tactic-prompt": "example  : true ∧ true := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : true ∧ true",
  "args": ""},
 {"type": "10 + 2 = 1 + 11",
  "tactic-prompt": "example  : 10 + 2 = 1 + 11 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 10 + 2 = 1 + 11",
  "args": ""},
 {"type": "10 - 1 = 9",
  "tactic-prompt": "example  : 10 - 1 = 9 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 10 - 1 = 9",
  "args": ""},
 {"type": "12 - 5 = 3 + 4",
  "tactic-prompt": "example  : 12 - 5 = 3 + 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 12 - 5 = 3 + 4",
  "args": ""},
 {"type": "5 - 20 = 0",
  "tactic-prompt": "example  : 5 - 20 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 5 - 20 = 0",
  "args": ""},
 {"type": "0 - 2 = 0",
  "tactic-prompt": "example  : 0 - 2 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 0 - 2 = 0",
  "args": ""},
 {"type": "4 - (5 - 10) = 2 + (3 - 1)",
  "tactic-prompt":
  "example  : 4 - (5 - 10) = 2 + (3 - 1) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 4 - (5 - 10) = 2 + (3 - 1)",
  "args": ""},
 {"type": "0 - 0 = 0",
  "tactic-prompt": "example  : 0 - 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 0 - 0 = 0",
  "args": ""},
 {"type": "100 - 100 = 0",
  "tactic-prompt": "example  : 100 - 100 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 100 - 100 = 0",
  "args": ""},
 {"type": "5 * (2 - 3) = 0",
  "tactic-prompt": "example  : 5 * (2 - 3) = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 5 * (2 - 3) = 0",
  "args": ""},
 {"type": "10 - 5 * 5 + (7 - 3) * 6 = 27 - 3",
  "tactic-prompt":
  "example  : 10 - 5 * 5 + (7 - 3) * 6 = 27 - 3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 10 - 5 * 5 + (7 - 3) * 6 = 27 - 3",
  "args": ""},
 {"type": "foo = 1",
  "tactic-prompt": "example  : foo = 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : foo = 1",
  "args": ""},
 {"type": "(1 + 0 : α) = (0 + 1 : α)",
  "tactic-prompt":
  "example (α : Type u)  [Semiring α] : (1 + 0 : α) = (0 + 1 : α) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "(α : Type u)  [Semiring α] : (1 + 0 : α) = (0 + 1 : α)",
  "args": "(α : Type u)  [Semiring α]"},
 {"type": "(0 + (2 + 3) + 1 : α) = 6",
  "tactic-prompt":
  "example (α : Type u)  [Semiring α] : (0 + (2 + 3) + 1 : α) = 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "(α : Type u)  [Semiring α] : (0 + (2 + 3) + 1 : α) = 6",
  "args": "(α : Type u)  [Semiring α]"},
 {"type": "(70 * (33 + 2) : α) = 2450",
  "tactic-prompt":
  "example (α : Type u)  [Semiring α] : (70 * (33 + 2) : α) = 2450 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "(α : Type u)  [Semiring α] : (70 * (33 + 2) : α) = 2450",
  "args": "(α : Type u)  [Semiring α]"},
 {"type": "(8 + 2 ^ 2 * 3 : α) = 20",
  "tactic-prompt":
  "example (α : Type u)  [Semiring α] : (8 + 2 ^ 2 * 3 : α) = 20 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "(α : Type u)  [Semiring α] : (8 + 2 ^ 2 * 3 : α) = 20",
  "args": "(α : Type u)  [Semiring α]"},
 {"type": "((2 * 1 + 1) ^ 2 : α) = (3 * 3 : α)",
  "tactic-prompt":
  "example (α : Type u)  [Semiring α] : ((2 * 1 + 1) ^ 2 : α) = (3 * 3 : α) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  "(α : Type u)  [Semiring α] : ((2 * 1 + 1) ^ 2 : α) = (3 * 3 : α)",
  "args": "(α : Type u)  [Semiring α]"},
 {"type": "(-1 : α) * 1 = -1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (-1 : α) * 1 = -1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (-1 : α) * 1 = -1",
  "args": "{α : Type} [Ring α]"},
 {"type": "(-2 : α) * 1 = -2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (-2 : α) * 1 = -2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (-2 : α) * 1 = -2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(-2 : α) * -1 = 2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (-2 : α) * -1 = 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (-2 : α) * -1 = 2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(-2 : α) * -2 = 4",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (-2 : α) * -2 = 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (-2 : α) * -2 = 4",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) * 0 = 0",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) * 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) * 0 = 0",
  "args": "{α : Type} [Ring α]"},
 {"type": "((1 : α) + 1) * 5 = 6 + 4",
  "tactic-prompt":
  "example {α : Type} [Ring α] : ((1 : α) + 1) * 5 = 6 + 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : ((1 : α) + 1) * 5 = 6 + 4",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) = 0 + 1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) = 0 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) = 0 + 1",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) = 1 + 0",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) = 1 + 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) = 1 + 0",
  "args": "{α : Type} [Ring α]"},
 {"type": "(2 : α) = 1 + 1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (2 : α) = 1 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (2 : α) = 1 + 1",
  "args": "{α : Type} [Ring α]"},
 {"type": "(2 : α) = 0 + 2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (2 : α) = 0 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (2 : α) = 0 + 2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(3 : α) = 1 + 2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (3 : α) = 1 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (3 : α) = 1 + 2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(3 : α) = 2 + 1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (3 : α) = 2 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (3 : α) = 2 + 1",
  "args": "{α : Type} [Ring α]"},
 {"type": "(4 : α) = 3 + 1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (4 : α) = 3 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (4 : α) = 3 + 1",
  "args": "{α : Type} [Ring α]"},
 {"type": "(4 : α) = 2 + 2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (4 : α) = 2 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (4 : α) = 2 + 2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(5 : α) = 4 + 1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (5 : α) = 4 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (5 : α) = 4 + 1",
  "args": "{α : Type} [Ring α]"},
 {"type": "(5 : α) = 3 + 2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (5 : α) = 3 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (5 : α) = 3 + 2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(5 : α) = 2 + 3",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (5 : α) = 2 + 3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (5 : α) = 2 + 3",
  "args": "{α : Type} [Ring α]"},
 {"type": "(6 : α) = 0 + 6",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (6 : α) = 0 + 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (6 : α) = 0 + 6",
  "args": "{α : Type} [Ring α]"},
 {"type": "(6 : α) = 3 + 3",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (6 : α) = 3 + 3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (6 : α) = 3 + 3",
  "args": "{α : Type} [Ring α]"},
 {"type": "(6 : α) = 4 + 2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (6 : α) = 4 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (6 : α) = 4 + 2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(6 : α) = 5 + 1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (6 : α) = 5 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (6 : α) = 5 + 1",
  "args": "{α : Type} [Ring α]"},
 {"type": "(7 : α) = 4 + 3",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (7 : α) = 4 + 3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (7 : α) = 4 + 3",
  "args": "{α : Type} [Ring α]"},
 {"type": "(7 : α) = 1 + 6",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (7 : α) = 1 + 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (7 : α) = 1 + 6",
  "args": "{α : Type} [Ring α]"},
 {"type": "(7 : α) = 6 + 1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (7 : α) = 6 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (7 : α) = 6 + 1",
  "args": "{α : Type} [Ring α]"},
 {"type": "33 = 5 + (28 : α)",
  "tactic-prompt":
  "example {α : Type} [Ring α] : 33 = 5 + (28 : α) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : 33 = 5 + (28 : α)",
  "args": "{α : Type} [Ring α]"},
 {"type": "(12 : α) = 0 + (2 + 3) + 7",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (12 : α) = 0 + (2 + 3) + 7 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (12 : α) = 0 + (2 + 3) + 7",
  "args": "{α : Type} [Ring α]"},
 {"type": "(105 : α) = 70 + (33 + 2)",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (105 : α) = 70 + (33 + 2) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (105 : α) = 70 + (33 + 2)",
  "args": "{α : Type} [Ring α]"},
 {"type": "(45000000000 : α) = 23000000000 + 22000000000",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (45000000000 : α) = 23000000000 + 22000000000 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  "{α : Type} [Ring α] : (45000000000 : α) = 23000000000 + 22000000000",
  "args": "{α : Type} [Ring α]"},
 {"type": "(0 : α) - 3 = -3",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (0 : α) - 3 = -3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (0 : α) - 3 = -3",
  "args": "{α : Type} [Ring α]"},
 {"type": "(0 : α) - 2 = -2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (0 : α) - 2 = -2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (0 : α) - 2 = -2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) - 3 = -2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) - 3 = -2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) - 3 = -2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) - 1 = 0",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) - 1 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) - 1 = 0",
  "args": "{α : Type} [Ring α]"},
 {"type": "(0 : α) - 3 = -3",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (0 : α) - 3 = -3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (0 : α) - 3 = -3",
  "args": "{α : Type} [Ring α]"},
 {"type": "(0 : α) - 3 = -3",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (0 : α) - 3 = -3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (0 : α) - 3 = -3",
  "args": "{α : Type} [Ring α]"},
 {"type": "(12 : α) - 4 - (5 + -2) = 5",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (12 : α) - 4 - (5 + -2) = 5 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (12 : α) - 4 - (5 + -2) = 5",
  "args": "{α : Type} [Ring α]"},
 {"type": "(12 : α) - 4 - (5 + -2) - 20 = -15",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (12 : α) - 4 - (5 + -2) - 20 = -15 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (12 : α) - 4 - (5 + -2) - 20 = -15",
  "args": "{α : Type} [Ring α]"},
 {"type": "(0 : α) * 0 = 0",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (0 : α) * 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (0 : α) * 0 = 0",
  "args": "{α : Type} [Ring α]"},
 {"type": "(0 : α) * 1 = 0",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (0 : α) * 1 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (0 : α) * 1 = 0",
  "args": "{α : Type} [Ring α]"},
 {"type": "(0 : α) * 2 = 0",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (0 : α) * 2 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (0 : α) * 2 = 0",
  "args": "{α : Type} [Ring α]"},
 {"type": "(2 : α) * 0 = 0",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (2 : α) * 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (2 : α) * 0 = 0",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) * 0 = 0",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) * 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) * 0 = 0",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) * 1 = 1",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) * 1 = 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) * 1 = 1",
  "args": "{α : Type} [Ring α]"},
 {"type": "(2 : α) * 1 = 2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (2 : α) * 1 = 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (2 : α) * 1 = 2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) * 2 = 2",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) * 2 = 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) * 2 = 2",
  "args": "{α : Type} [Ring α]"},
 {"type": "(2 : α) * 2 = 4",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (2 : α) * 2 = 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (2 : α) * 2 = 4",
  "args": "{α : Type} [Ring α]"},
 {"type": "(3 : α) * 2 = 6",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (3 : α) * 2 = 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (3 : α) * 2 = 6",
  "args": "{α : Type} [Ring α]"},
 {"type": "(2 : α) * 3 = 6",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (2 : α) * 3 = 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (2 : α) * 3 = 6",
  "args": "{α : Type} [Ring α]"},
 {"type": "(4 : α) * 1 = 4",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (4 : α) * 1 = 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (4 : α) * 1 = 4",
  "args": "{α : Type} [Ring α]"},
 {"type": "(1 : α) * 4 = 4",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (1 : α) * 4 = 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (1 : α) * 4 = 4",
  "args": "{α : Type} [Ring α]"},
 {"type": "(3 : α) * 3 = 9",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (3 : α) * 3 = 9 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (3 : α) * 3 = 9",
  "args": "{α : Type} [Ring α]"},
 {"type": "(3 : α) * 4 = 12",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (3 : α) * 4 = 12 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (3 : α) * 4 = 12",
  "args": "{α : Type} [Ring α]"},
 {"type": "(4 : α) * 4 = 16",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (4 : α) * 4 = 16 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (4 : α) * 4 = 16",
  "args": "{α : Type} [Ring α]"},
 {"type": "(11 : α) * 2 = 22",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (11 : α) * 2 = 22 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (11 : α) * 2 = 22",
  "args": "{α : Type} [Ring α]"},
 {"type": "(15 : α) * 6 = 90",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (15 : α) * 6 = 90 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (15 : α) * 6 = 90",
  "args": "{α : Type} [Ring α]"},
 {"type": "(123456 : α) * 123456 = 15241383936",
  "tactic-prompt":
  "example {α : Type} [Ring α] : (123456 : α) * 123456 = 15241383936 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{α : Type} [Ring α] : (123456 : α) * 123456 = 15241383936",
  "args": "{α : Type} [Ring α]"},
 {"type": "1 = 1",
  "tactic-prompt": "example  : 1 = 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 1 = 1",
  "args": ""},
 {"type": "x ≤ 57",
  "tactic-prompt":
  "example {x : Nat}  (h : x ∈ [0, 2, 37]) : x ≤ 57 := by fin_cases h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases h",
  "core-prompt": "{x : Nat}  (h : x ∈ [0, 2, 37]) : x ≤ 57",
  "args": "{x : Nat}  (h : x ∈ [0, 2, 37])"},
 {"type": "x = 0 ∨ x = 2 ∨ x = 37",
  "tactic-prompt":
  "example {x : Nat}  (h : x ∈ [0, 2, 37]) : x = 0 ∨ x = 2 ∨ x = 37 := by fin_cases h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases h",
  "core-prompt": "{x : Nat}  (h : x ∈ [0, 2, 37]) : x = 0 ∨ x = 2 ∨ x = 37",
  "args": "{x : Nat}  (h : x ∈ [0, 2, 37])"},
 {"type": "x ≤ 4",
  "tactic-prompt":
  "example {x : Nat}  (h : x ∈ List.range 5) : x ≤ 4 := by fin_cases h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases h",
  "core-prompt": "{x : Nat}  (h : x ∈ List.range 5) : x ≤ 4",
  "args": "{x : Nat}  (h : x ∈ List.range 5)"},
 {"type": "p i",
  "tactic-prompt":
  "example {p : Fin 4 → Prop}  (i : Fin 4)  (h : p i) : p i := by fin_cases i; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases i",
  "core-prompt": "{p : Fin 4 → Prop}  (i : Fin 4)  (h : p i) : p i",
  "args": "{p : Fin 4 → Prop}  (i : Fin 4)  (h : p i)"},
 {"type": "f p.val",
  "tactic-prompt":
  "example (f : Nat → Prop)  (p : Fin 3)  (h0 : f 0)  (h1 : f 1)  (h2 : f 2) : f p.val := by fin_cases p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases p",
  "core-prompt":
  "(f : Nat → Prop)  (p : Fin 3)  (h0 : f 0)  (h1 : f 1)  (h2 : f 2) : f p.val",
  "args": "(f : Nat → Prop)  (p : Fin 3)  (h0 : f 0)  (h1 : f 1)  (h2 : f 2)"},
 {"type": "f p.val",
  "tactic-prompt":
  "example (f : Nat → Prop)  (p : Fin 0) : f p.val := by fin_cases p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases p",
  "core-prompt": "(f : Nat → Prop)  (p : Fin 0) : f p.val",
  "args": "(f : Nat → Prop)  (p : Fin 0)"},
 {"type": "True",
  "tactic-prompt":
  "example (x2 : Fin 2)  (x3 : Fin 3) : True := by fin_cases x2, x3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases x2, x3",
  "core-prompt": "(x2 : Fin 2)  (x3 : Fin 3) : True",
  "args": "(x2 : Fin 2)  (x3 : Fin 3)"},
 {"type": "x2.val * x3.val = x3.val * x2.val",
  "tactic-prompt":
  "example (x2 : Fin 2)  (x3 : Fin 3)  (n : Nat)  (y : Fin n) : x2.val * x3.val = x3.val * x2.val := by fin_cases x2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases x2",
  "core-prompt":
  "(x2 : Fin 2)  (x3 : Fin 3)  (n : Nat)  (y : Fin n) : x2.val * x3.val = x3.val * x2.val",
  "args": "(x2 : Fin 2)  (x3 : Fin 3)  (n : Nat)  (y : Fin n)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∨ c ∧ d)  (h2 : e ∧ f) : True := by casesm* _∨_, _∧_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "casesm* _∨_, _∧_",
  "core-prompt": "(h : a ∧ b ∨ c ∧ d)  (h2 : e ∧ f) : True",
  "args": "(h : a ∧ b ∨ c ∧ d)  (h2 : e ∧ f)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∨ c ∧ d) : True := by casesm* _∧_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "casesm* _∧_",
  "core-prompt": "(h : a ∧ b ∨ c ∧ d) : True",
  "args": "(h : a ∧ b ∨ c ∧ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∨ c ∨ d) : True := by casesm* _∨_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "casesm* _∨_",
  "core-prompt": "(h : a ∧ b ∨ c ∨ d) : True",
  "args": "(h : a ∧ b ∨ c ∨ d)"},
 {"type": "True",
  "tactic-prompt": "example (h : a ∧ b ∨ c ∨ d) : True := by casesm _∨_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "casesm _∨_",
  "core-prompt": "(h : a ∧ b ∨ c ∨ d) : True",
  "args": "(h : a ∧ b ∨ c ∨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∨ c ∨ d) : True := by cases_type And Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type And Or",
  "core-prompt": "(h : a ∧ b ∨ c ∨ d) : True",
  "args": "(h : a ∧ b ∨ c ∨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∨ c ∨ d) : True := by cases_type And; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type And",
  "core-prompt": "(h : a ∧ b ∨ c ∨ d) : True",
  "args": "(h : a ∧ b ∨ c ∨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∨ c ∨ d) : True := by cases_type Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type Or",
  "core-prompt": "(h : a ∧ b ∨ c ∨ d) : True",
  "args": "(h : a ∧ b ∨ c ∨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∨ c ∨ d) : True := by cases_type* Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type* Or",
  "core-prompt": "(h : a ∧ b ∨ c ∨ d) : True",
  "args": "(h : a ∧ b ∨ c ∨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∨ c ∨ d) : True := by cases_type! And Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type! And Or",
  "core-prompt": "(h : a ∧ b ∨ c ∨ d) : True",
  "args": "(h : a ∧ b ∨ c ∨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∧ (c ∨ d)) : True := by cases_type! And Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type! And Or",
  "core-prompt": "(h : a ∧ b ∧ (c ∨ d)) : True",
  "args": "(h : a ∧ b ∧ (c ∨ d))"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a ∧ b ∧ (c ∨ d)) : True := by cases_type!* And Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type!* And Or",
  "core-prompt": "(h : a ∧ b ∧ (c ∨ d)) : True",
  "args": "(h : a ∧ b ∧ (c ∨ d))"},
 {"type": "True ∧ True ∧ True",
  "tactic-prompt":
  "example  : True ∧ True ∧ True := by constructorm True, _∨_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructorm True, _∨_",
  "core-prompt": " : True ∧ True ∧ True",
  "args": ""},
 {"type": "P",
  "tactic-prompt": "example (P : Prop)  (h : P) : P := by convert h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert h",
  "core-prompt": "(P : Prop)  (h : P) : P",
  "args": "(P : Prop)  (h : P)"},
 {"type": "α",
  "tactic-prompt":
  "example (α β : Type)  (h : α = β)  (b : β) : α := by convert b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert b",
  "core-prompt": "(α β : Type)  (h : α = β)  (b : β) : α",
  "args": "(α β : Type)  (h : α = β)  (b : β)"},
 {"type": "α",
  "tactic-prompt":
  "example (α β : Type)  (h : ∀ α β : Type, α = β)  (b : β) : α := by convert b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert b",
  "core-prompt": "(α β : Type)  (h : ∀ α β : Type, α = β)  (b : β) : α",
  "args": "(α β : Type)  (h : ∀ α β : Type, α = β)  (b : β)"},
 {"type": "Nat × α",
  "tactic-prompt":
  "example (α β : Type)  (h : α = β)  (b : β) : Nat × α := by convert (37, b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert (37, b)",
  "core-prompt": "(α β : Type)  (h : α = β)  (b : β) : Nat × α",
  "args": "(α β : Type)  (h : α = β)  (b : β)"},
 {"type": "Nat × α",
  "tactic-prompt":
  "example (α β : Type)  (h : β = α)  (b : β) : Nat × α := by convert ← (37, b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert ← (37, b)",
  "core-prompt": "(α β : Type)  (h : β = α)  (b : β) : Nat × α",
  "args": "(α β : Type)  (h : β = α)  (b : β)"},
 {"type": "Nat × Nat × Nat × α",
  "tactic-prompt":
  "example (α β : Type)  (h : α = β)  (b : β) : Nat × Nat × Nat × α := by convert (37, 57, 2, b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert (37, 57, 2, b)",
  "core-prompt": "(α β : Type)  (h : α = β)  (b : β) : Nat × Nat × Nat × α",
  "args": "(α β : Type)  (h : α = β)  (b : β)"},
 {"type": "Nat × Nat × Nat × α",
  "tactic-prompt":
  "example (α β : Type)  (h : α = β)  (b : β) : Nat × Nat × Nat × α := by convert (37, 57, 2, b) using 3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert (37, 57, 2, b) using 3",
  "core-prompt": "(α β : Type)  (h : α = β)  (b : β) : Nat × Nat × Nat × α",
  "args": "(α β : Type)  (h : α = β)  (b : β)"},
 {"type": "bar0 3 4 = 7",
  "tactic-prompt": "theorem  : bar0 3 4 = 7 := by decide; sorry",
  "name": "bar0_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar0 3 4 = 7",
  "args": ""},
 {"type": "foo1 3 4 = Nat.pow 3 4",
  "tactic-prompt": "theorem  : foo1 3 4 = Nat.pow 3 4 := by decide; sorry",
  "name": "foo1_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : foo1 3 4 = Nat.pow 3 4",
  "args": ""},
 {"type": "bar1 3 4 = 3 * 4",
  "tactic-prompt": "theorem  : bar1 3 4 = 3 * 4 := by decide; sorry",
  "name": "bar1_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar1 3 4 = 3 * 4",
  "args": ""},
 {"type": "foo2 2 3 (PLift.up 2) = Nat.pow 2 0",
  "tactic-prompt":
  "theorem  : foo2 2 3 (PLift.up 2) = Nat.pow 2 0 := by decide; sorry",
  "name": "foo2_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : foo2 2 3 (PLift.up 2) = Nat.pow 2 0",
  "args": ""},
 {"type": "bar2 2 3 (PLift.up 2) =  2 * (dummy_smul.1 (PLift.up 2) 3)",
  "tactic-prompt":
  "theorem  : bar2 2 3 (PLift.up 2) =  2 * (dummy_smul.1 (PLift.up 2) 3) := by decide; sorry",
  "name": "bar2_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt":
  " : bar2 2 3 (PLift.up 2) =  2 * (dummy_smul.1 (PLift.up 2) 3)",
  "args": ""},
 {"type": "foo3 2 3 = Nat.pow 2 3",
  "tactic-prompt": "theorem  : foo3 2 3 = Nat.pow 2 3 := by decide; sorry",
  "name": "foo3_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : foo3 2 3 = Nat.pow 2 3",
  "args": ""},
 {"type": "bar3 2 3 =  2 * 3",
  "tactic-prompt": "theorem  : bar3 2 3 =  2 * 3 := by decide; sorry",
  "name": "bar3_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar3 2 3 =  2 * 3",
  "args": ""},
 {"type": "foo7 2 3 = Nat.pow 2 3",
  "tactic-prompt": "theorem  : foo7 2 3 = Nat.pow 2 3 := by decide; sorry",
  "name": "foo7_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : foo7 2 3 = Nat.pow 2 3",
  "args": ""},
 {"type": "bar7 2 3 =  2 * 3",
  "tactic-prompt":
  "theorem  : bar7 2 3 =  2 * 3 := by decide\n\n/- test the eta-expansion applied on `foo6`. -/; sorry",
  "name": "bar7_works",
  "kind": "theorem",
  "first-tactic": "decide\n\n/- test the eta-expansion applied on `foo6`. -/",
  "core-prompt": " : bar7 2 3 =  2 * 3",
  "args": ""},
 {"type": "true",
  "tactic-prompt":
  "def {I J K : Type}  (n : ℕ)  {f : I → Type}  (L : Type)  [∀ i, One (f i)]    [Add I]  [Mul L] : true := by trivial; sorry",
  "name": "foo_mul",
  "kind": "def",
  "first-tactic": "trivial",
  "core-prompt":
  "{I J K : Type}  (n : ℕ)  {f : I → Type}  (L : Type)  [∀ i, One (f i)]    [Add I]  [Mul L] : true",
  "args":
  "{I J K : Type}  (n : ℕ)  {f : I → Type}  (L : Type)  [∀ i, One (f i)]    [Add I]  [Mul L]"},
 {"type": "One ((x : Nat) → α)",
  "tactic-prompt":
  "def {α : Type}  [One α] : One ((x : Nat) → α) := by infer_instance; sorry",
  "name": "nat_pi_has_one",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt": "{α : Type}  [One α] : One ((x : Nat) → α)",
  "args": "{α : Type}  [One α]"},
 {"type": "true",
  "tactic-prompt": "example  : true := by guard_hyp_nums 1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "guard_hyp_nums 1",
  "core-prompt": " : true",
  "args": ""},
 {"type": "Int × Nat",
  "tactic-prompt":
  "example (a : Nat)  (b : Int) : Int × Nat := by rename' a => c, b => d; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rename' a => c, b => d",
  "core-prompt": "(a : Nat)  (b : Int) : Int × Nat",
  "args": "(a : Nat)  (b : Int)"},
 {"type": "Int × Nat",
  "tactic-prompt":
  "example (a : Nat)  (b : Int) : Int × Nat := by rename' a => b, b => a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rename' a => b, b => a",
  "core-prompt": "(a : Nat)  (b : Int) : Int × Nat",
  "args": "(a : Nat)  (b : Int)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by run_tac\n    let t : Option Bool := (← Lean.MonadOptions.getOptions).get? `pp.all; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "run_tac\n    let t : Option Bool := (← Lean.MonadOptions.getOptions).get? `pp.all",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by run_tac\n    let t : Option Bool := (← Lean.MonadOptions.getOptions).get? `pp.all; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "run_tac\n    let t : Option Bool := (← Lean.MonadOptions.getOptions).get? `pp.all",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by run_tac\n    let t : Option Bool := (← Lean.MonadOptions.getOptions).get? `pp.all; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "run_tac\n    let t : Option Bool := (← Lean.MonadOptions.getOptions).get? `pp.all",
  "core-prompt": " : True",
  "args": ""},
 {"type": "False → α",
  "tactic-prompt": "example  : False → α := by intro.; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro.",
  "core-prompt": " : False → α",
  "args": ""},
 {"type": "¬ False",
  "tactic-prompt": "example  : ¬ False := by intro.; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro.",
  "core-prompt": " : ¬ False",
  "args": ""},
 {"type": "P ∧ Q",
  "tactic-prompt":
  "example {P Q : Prop}  (q : P)  (p : Q) : P ∧ Q := by swap_var p ↔ q; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "swap_var p ↔ q",
  "core-prompt": "{P Q : Prop}  (q : P)  (p : Q) : P ∧ Q",
  "args": "{P Q : Prop}  (q : P)  (p : Q)"},
 {"type": "frobnicate a 0 = a",
  "tactic-prompt":
  "example  : frobnicate a 0 = a := by simp [frobnicate_def]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp [frobnicate_def]",
  "core-prompt": " : frobnicate a 0 = a",
  "args": ""},
 {"type": "withUniv.{u, v} = (Type v, Type u)",
  "tactic-prompt":
  "example  : withUniv.{u, v} = (Type v, Type u) := by rw [withUniv_def]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rw [withUniv_def]",
  "core-prompt": " : withUniv.{u, v} = (Type v, Type u)",
  "args": ""},
 {"type": "α",
  "tactic-prompt":
  "example (f : ∀ x : Nat, x = x → α) : α := by apply (config := {}) f; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply (config := {}) f",
  "core-prompt": "(f : ∀ x : Nat, x = x → α) : α",
  "args": "(f : ∀ x : Nat, x = x → α)"},
 {"type": "α",
  "tactic-prompt":
  "example (f : ∀ x : Nat, x = x → α) : α := by apply (config := { newGoals := .nonDependentOnly }) f; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply (config := { newGoals := .nonDependentOnly }) f",
  "core-prompt": "(f : ∀ x : Nat, x = x → α) : α",
  "args": "(f : ∀ x : Nat, x = x → α)"},
 {"type": "α",
  "tactic-prompt":
  "example (f : ∀ x : Nat, x = x → α) : α := by apply (config := { newGoals := .all }) f; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply (config := { newGoals := .all }) f",
  "core-prompt": "(f : ∀ x : Nat, x = x → α) : α",
  "args": "(f : ∀ x : Nat, x = x → α)"},
 {"type": "P",
  "tactic-prompt":
  "example (p : P) : P := by expect_failure_msg \"unknown identifier 'x'\" have h := x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "expect_failure_msg \"unknown identifier 'x'\" have h := x",
  "core-prompt": "(p : P) : P",
  "args": "(p : P)"},
 {"type": "x + 0 = y → x = y",
  "tactic-prompt": "example  : x + 0 = y → x = y := by simp_intro h₁; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro h₁",
  "core-prompt": " : x + 0 = y → x = y",
  "args": ""},
 {"type": "x + 0 ≠ y → x ≠ y",
  "tactic-prompt": "example  : x + 0 ≠ y → x ≠ y := by simp_intro h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro h₁ h₂",
  "core-prompt": " : x + 0 ≠ y → x ≠ y",
  "args": ""},
 {"type": "x + 0 ≠ y → x ≠ y",
  "tactic-prompt":
  "example  : x + 0 ≠ y → x ≠ y := by simp_intro h₁ h₂ h₃; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro h₁ h₂ h₃",
  "core-prompt": " : x + 0 ≠ y → x ≠ y",
  "args": ""},
 {"type": "x + 0 = y → x = z",
  "tactic-prompt":
  "example (h : x = z) : x + 0 = y → x = z := by simp_intro [h]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro [h]",
  "core-prompt": "(h : x = z) : x + 0 = y → x = z",
  "args": "(h : x = z)"},
 {"type": "x + 0 = y → x = z",
  "tactic-prompt":
  "example (h : y = z) : x + 0 = y → x = z := by simp_intro _; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro _",
  "core-prompt": "(h : y = z) : x + 0 = y → x = z",
  "args": "(h : y = z)"},
 {"type": "True",
  "tactic-prompt": "example  : True := by trace 2 + 2 + 3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "trace 2 + 2 + 3",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt": "example  : True := by trace \"hello\" ++ \" world\"; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "trace \"hello\" ++ \" world\"",
  "core-prompt": " : True",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example (_delete_this : Nat) : Nat := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt": "(_delete_this : Nat) : Nat",
  "args": "(_delete_this : Nat)"},
 {"type": "Inhabited Nat",
  "tactic-prompt":
  "example [_dont_delete_this : Inhabited Nat] : Inhabited Nat := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt": "[_dont_delete_this : Inhabited Nat] : Inhabited Nat",
  "args": "[_dont_delete_this : Inhabited Nat]"},
 {"type": "Nat",
  "tactic-prompt":
  "example (_delete_this : Nat)  (dont_delete_this : Int) : Nat := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt": "(_delete_this : Nat)  (dont_delete_this : Int) : Nat",
  "args": "(_delete_this : Nat)  (dont_delete_this : Int)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (_delete_this : Type)  (_delete_this_dep : _delete_this)  (_delete_this_rw : _delete_this = Nat)    (_delete_this_dep_dep : _delete_this_dep = _delete_this_dep) : Nat := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt":
  "(_delete_this : Type)  (_delete_this_dep : _delete_this)  (_delete_this_rw : _delete_this = Nat)    (_delete_this_dep_dep : _delete_this_dep = _delete_this_dep) : Nat",
  "args":
  "(_delete_this : Type)  (_delete_this_dep : _delete_this)  (_delete_this_rw : _delete_this = Nat)    (_delete_this_dep_dep : _delete_this_dep = _delete_this_dep)"},
 {"type": "_dont_delete_this",
  "tactic-prompt":
  "example (_dont_delete_this : Type)  (dep : _dont_delete_this) : _dont_delete_this := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt":
  "(_dont_delete_this : Type)  (dep : _dont_delete_this) : _dont_delete_this",
  "args": "(_dont_delete_this : Type)  (dep : _dont_delete_this)"},
 {"type": "_dont_delete_this = _dont_delete_this",
  "tactic-prompt":
  "example (_dont_delete_this : Type) : _dont_delete_this = _dont_delete_this := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt":
  "(_dont_delete_this : Type) : _dont_delete_this = _dont_delete_this",
  "args": "(_dont_delete_this : Type)"},
 {"type": "_dont_delete_this = _dont_delete_this",
  "tactic-prompt":
  "example (_dont_delete_this : Type)  (_delete_this : _dont_delete_this = _dont_delete_this) : _dont_delete_this = _dont_delete_this := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt":
  "(_dont_delete_this : Type)  (_delete_this : _dont_delete_this = _dont_delete_this) : _dont_delete_this = _dont_delete_this",
  "args":
  "(_dont_delete_this : Type)  (_delete_this : _dont_delete_this = _dont_delete_this)"},
 {"type": "∃ x : Nat, x = x",
  "tactic-prompt": "example  : ∃ x : Nat, x = x := by existsi 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "existsi 42",
  "core-prompt": " : ∃ x : Nat, x = x",
  "args": ""},
 {"type": "∃ x : Nat, ∃ y : Nat, x = y",
  "tactic-prompt":
  "example  : ∃ x : Nat, ∃ y : Nat, x = y := by existsi 42, 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "existsi 42, 42",
  "core-prompt": " : ∃ x : Nat, ∃ y : Nat, x = y",
  "args": ""},
 {"type": "∀ a b : Nat, a = b → b = a",
  "tactic-prompt":
  "example  : ∀ a b : Nat, a = b → b = a := by introv h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "introv h",
  "core-prompt": " : ∀ a b : Nat, a = b → b = a",
  "args": ""},
 {"type": "n = n",
  "tactic-prompt": "example (n : Nat) : n = n := by induction n; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction n",
  "core-prompt": "(n : Nat) : n = n",
  "args": "(n : Nat)"},
 {"type": "a ≠ b → ¬ a = b",
  "tactic-prompt": "example (a b : Nat) : a ≠ b → ¬ a = b := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b : Nat) : a ≠ b → ¬ a = b",
  "args": "(a b : Nat)"},
 {"type": "¬¬ a = b → a = b",
  "tactic-prompt": "example (a b : Nat) : ¬¬ a = b → a = b := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b : Nat) : ¬¬ a = b → a = b",
  "args": "(a b : Nat)"},
 {"type": "¬¬ p → p",
  "tactic-prompt": "example (p q : Prop) : ¬¬ p → p := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(p q : Prop) : ¬¬ p → p",
  "args": "(p q : Prop)"},
 {"type": "Unit",
  "tactic-prompt": "example (n m : Nat) : Unit := by cases n; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases n",
  "core-prompt": "(n m : Nat) : Unit",
  "args": "(n m : Nat)"},
 {"type": "Unit",
  "tactic-prompt": "example (n m : Nat) : Unit := by cases n; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases n",
  "core-prompt": "(n m : Nat) : Unit",
  "args": "(n m : Nat)"},
 {"type": "Nat",
  "tactic-prompt": "example (n : Nat) : Nat := by iterate exact (); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "iterate exact ()",
  "core-prompt": "(n : Nat) : Nat",
  "args": "(n : Nat)"},
 {"type": "p → q → r → s → (p ∧ q) ∧ (r ∧ s ∧ p) ∧ (p ∧ r ∧ q)",
  "tactic-prompt":
  "example (p q r s : Prop) : p → q → r → s → (p ∧ q) ∧ (r ∧ s ∧ p) ∧ (p ∧ r ∧ q) := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt":
  "(p q r s : Prop) : p → q → r → s → (p ∧ q) ∧ (r ∧ s ∧ p) ∧ (p ∧ r ∧ q)",
  "args": "(p q r s : Prop)"},
 {"type": "p → q → (p ∧ q) ∧ (p ∧ q ∧ p)",
  "tactic-prompt":
  "example (p q : Prop) : p → q → (p ∧ q) ∧ (p ∧ q ∧ p) := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(p q : Prop) : p → q → (p ∧ q) ∧ (p ∧ q ∧ p)",
  "args": "(p q : Prop)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (dont_delete_this : Int) : Nat := by clear * - dont_delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this",
  "core-prompt": "(delete_this : Nat)  (dont_delete_this : Int) : Nat",
  "args": "(delete_this : Nat)  (dont_delete_this : Int)"},
 {"type": "Inhabited Nat",
  "tactic-prompt":
  "example [dont_delete_this : Inhabited Nat]  (dont_delete_this2 : Prop) : Inhabited Nat := by clear * - dont_delete_this2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this2",
  "core-prompt":
  "[dont_delete_this : Inhabited Nat]  (dont_delete_this2 : Prop) : Inhabited Nat",
  "args": "[dont_delete_this : Inhabited Nat]  (dont_delete_this2 : Prop)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (delete_this2 : delete_this = delete_this)  (dont_delete_this : Int) : Nat := by clear * - dont_delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this",
  "core-prompt":
  "(delete_this : Nat)  (delete_this2 : delete_this = delete_this)  (dont_delete_this : Int) : Nat",
  "args":
  "(delete_this : Nat)  (delete_this2 : delete_this = delete_this)  (dont_delete_this : Int)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (dont_delete_this : Nat)  (dont_delete_this2 : dont_delete_this = dont_delete_this) : Nat := by clear * - dont_delete_this2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this2",
  "core-prompt":
  "(dont_delete_this : Nat)  (dont_delete_this2 : dont_delete_this = dont_delete_this) : Nat",
  "args":
  "(dont_delete_this : Nat)  (dont_delete_this2 : dont_delete_this = dont_delete_this)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (dont_delete_this : Int)  (dont_delete_this2 : Int) : Nat := by clear * - dont_delete_this dont_delete_this2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this dont_delete_this2",
  "core-prompt":
  "(delete_this : Nat)  (dont_delete_this : Int)  (dont_delete_this2 : Int) : Nat",
  "args":
  "(delete_this : Nat)  (dont_delete_this : Int)  (dont_delete_this2 : Int)"},
 {"type": "(α : Type) × List α",
  "tactic-prompt": "example  : (α : Type) × List α := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : (α : Type) × List α",
  "args": ""},
 {"type": "true ∧ true",
  "tactic-prompt": "example  : true ∧ true := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : true ∧ true",
  "args": ""},
 {"type": "(true ∧ true) ∧ (true ∧ true)",
  "tactic-prompt":
  "example  : (true ∧ true) ∧ (true ∧ true) := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : (true ∧ true) ∧ (true ∧ true)",
  "args": ""},
 {"type": "x = if p then x else x",
  "tactic-prompt":
  "example (x : Nat)  (p : Prop)  [Decidable p] : x = if p then x else x := by split_ifs with h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs with h1",
  "core-prompt":
  "(x : Nat)  (p : Prop)  [Decidable p] : x = if p then x else x",
  "args": "(x : Nat)  (p : Prop)  [Decidable p]"},
 {"type": "x = y",
  "tactic-prompt":
  "example (x y : Nat)  (p : Prop)  [Decidable p]  (h : if p then x = y else y = x) : x = y := by split_ifs at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs at h",
  "core-prompt":
  "(x y : Nat)  (p : Prop)  [Decidable p]  (h : if p then x = y else y = x) : x = y",
  "args":
  "(x y : Nat)  (p : Prop)  [Decidable p]  (h : if p then x = y else y = x)"},
 {"type": "x = if p then (if q then x else x) else x",
  "tactic-prompt":
  "example (x : Nat)  (p q : Prop)  [Decidable p]  [Decidable q] : x = if p then (if q then x else x) else x := by split_ifs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs",
  "core-prompt":
  "(x : Nat)  (p q : Prop)  [Decidable p]  [Decidable q] : x = if p then (if q then x else x) else x",
  "args": "(x : Nat)  (p q : Prop)  [Decidable p]  [Decidable q]"},
 {"type": "x = if (if p then False else True) then x else x",
  "tactic-prompt":
  "example (x : Nat)  (p : Prop)  [Decidable p] : x = if (if p then False else True) then x else x := by split_ifs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs",
  "core-prompt":
  "(x : Nat)  (p : Prop)  [Decidable p] : x = if (if p then False else True) then x else x",
  "args": "(x : Nat)  (p : Prop)  [Decidable p]"},
 {"type": "if if ¬p then p else True then p else ¬p",
  "tactic-prompt":
  "example (p : Prop)  [Decidable p] : if if ¬p then p else True then p else ¬p := by split_ifs with h1 h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs with h1 h2",
  "core-prompt":
  "(p : Prop)  [Decidable p] : if if ¬p then p else True then p else ¬p",
  "args": "(p : Prop)  [Decidable p]"},
 {"type": "if if if p then ¬p else q then p else q then q else ¬p ∨ ¬q",
  "tactic-prompt":
  "example (p q : Prop)  [Decidable p]  [Decidable q] : if if if p then ¬p else q then p else q then q else ¬p ∨ ¬q := by split_ifs with h1 h2 h3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs with h1 h2 h3",
  "core-prompt":
  "(p q : Prop)  [Decidable p]  [Decidable q] : if if if p then ¬p else q then p else q then q else ¬p ∨ ¬q",
  "args": "(p q : Prop)  [Decidable p]  [Decidable q]"},
 {"type": "False",
  "tactic-prompt":
  "example (p : Prop)  [Decidable p]  (h : (if p then 1 else 2) > 3) : False := by split_ifs at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs at h",
  "core-prompt":
  "(p : Prop)  [Decidable p]  (h : (if p then 1 else 2) > 3) : False",
  "args": "(p : Prop)  [Decidable p]  (h : (if p then 1 else 2) > 3)"},
 {"type": "x < (if ¬p then 1 else 0) + 1",
  "tactic-prompt":
  "example (p : Prop)  [Decidable p]  (x : Nat)  (h : (if p then 1 else 2) > x) : x < (if ¬p then 1 else 0) + 1 := by split_ifs at *; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs at *",
  "core-prompt":
  "(p : Prop)  [Decidable p]  (x : Nat)  (h : (if p then 1 else 2) > x) : x < (if ¬p then 1 else 0) + 1",
  "args":
  "(p : Prop)  [Decidable p]  (x : Nat)  (h : (if p then 1 else 2) > x)"},
 {"type": "if if ¬p then p else True then p else ¬p",
  "tactic-prompt":
  "example (p : Prop)  [Decidable p] : if if ¬p then p else True then p else ¬p := by split_ifs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs",
  "core-prompt":
  "(p : Prop)  [Decidable p] : if if ¬p then p else True then p else ¬p",
  "args": "(p : Prop)  [Decidable p]"},
 {"type": "if if if p then ¬p else q then p else q then q else ¬p ∨ ¬q",
  "tactic-prompt":
  "example (p q : Prop)  [Decidable p]  [Decidable q] : if if if p then ¬p else q then p else q then q else ¬p ∨ ¬q := by split_ifs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs",
  "core-prompt":
  "(p q : Prop)  [Decidable p]  [Decidable q] : if if if p then ¬p else q then p else q then q else ¬p ∨ ¬q",
  "args": "(p q : Prop)  [Decidable p]  [Decidable q]"},
 {"type": "True",
  "tactic-prompt": "example  : True := by fail_if_success { split_ifs }; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success { split_ifs }",
  "core-prompt": " : True",
  "args": ""},
 {"type": "a + c * e + a + c + 0 ≤ b + d * e + b + d + e",
  "tactic-prompt":
  "example {a b c d e : Nat}  (h1 : a ≤ b)  (h2 : c ≤ d)  (h3 : 0 ≤ e) : a + c * e + a + c + 0 ≤ b + d * e + b + d + e := by apply_rules [add_le_add]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_rules [add_le_add]",
  "core-prompt":
  "{a b c d e : Nat}  (h1 : a ≤ b)  (h2 : c ≤ d)  (h3 : 0 ≤ e) : a + c * e + a + c + 0 ≤ b + d * e + b + d + e",
  "args": "{a b c d e : Nat}  (h1 : a ≤ b)  (h2 : c ≤ d)  (h3 : 0 ≤ e)"},
 {"type": "a + c * e + a + c + 0 ≤ b + d * e + b + d + e",
  "tactic-prompt":
  "example {a b c d e : Nat}  (h1 : a ≤ b)  (h2 : c ≤ d)  (h3 : 0 ≤ e) : a + c * e + a + c + 0 ≤ b + d * e + b + d + e := by apply_rules [add_le_add]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_rules [add_le_add]",
  "core-prompt":
  "{a b c d e : Nat}  (h1 : a ≤ b)  (h2 : c ≤ d)  (h3 : 0 ≤ e) : a + c * e + a + c + 0 ≤ b + d * e + b + d + e",
  "args": "{a b c d e : Nat}  (h1 : a ≤ b)  (h2 : c ≤ d)  (h3 : 0 ≤ e)"},
 {"type": "P 2",
  "tactic-prompt":
  "example (P : Nat → Type)  (f : {n : Nat} → P n → P (n + 1))  (g : P 0) : P 2 := by apply_rules [f]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_rules [f]",
  "core-prompt":
  "(P : Nat → Type)  (f : {n : Nat} → P n → P (n + 1))  (g : P 0) : P 2",
  "args": "(P : Nat → Type)  (f : {n : Nat} → P n → P (n + 1))  (g : P 0)"},
 {"type": "Int × Q",
  "tactic-prompt":
  "example (Q : Type)  (f : Nat → Q) : Int × Q := by apply_rules [Prod.mk]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_rules [Prod.mk]",
  "core-prompt": "(Q : Type)  (f : Nat → Q) : Int × Q",
  "args": "(Q : Type)  (f : Nat → Q)"},
 {"type": "Nat",
  "tactic-prompt": "def  : Nat := by left; sorry",
  "name": "zero",
  "kind": "def",
  "first-tactic": "left",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "def  : Nat := by right; sorry",
  "name": "two",
  "kind": "def",
  "first-tactic": "right",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Sum Nat (List Nat)",
  "tactic-prompt": "example  : Sum Nat (List Nat) := by left; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "left",
  "core-prompt": " : Sum Nat (List Nat)",
  "args": ""},
 {"type": "Sum Nat (List Nat)",
  "tactic-prompt": "example  : Sum Nat (List Nat) := by right; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "right",
  "core-prompt": " : Sum Nat (List Nat)",
  "args": ""},
 {"type": "(1 = 1) ∨ (2 = 3)",
  "tactic-prompt": "example  : (1 = 1) ∨ (2 = 3) := by left; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "left",
  "core-prompt": " : (1 = 1) ∨ (2 = 3)",
  "args": ""},
 {"type": "(1 = 2) ∨ (3 = 3)",
  "tactic-prompt": "example  : (1 = 2) ∨ (3 = 3) := by right; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "right",
  "core-prompt": " : (1 = 2) ∨ (3 = 3)",
  "args": ""},
 {"type": "p",
  "tactic-prompt":
  "example (p : Prop)  (h : p) : p := by fail_if_success { contrapose }; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success { contrapose }",
  "core-prompt": "(p : Prop)  (h : p) : p",
  "args": "(p : Prop)  (h : p)"},
 {"type": "p → q",
  "tactic-prompt":
  "example (p q : Type)  (h : p → q) : p → q := by fail_if_success { contrapose }; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success { contrapose }",
  "core-prompt": "(p q : Type)  (h : p → q) : p → q",
  "args": "(p q : Type)  (h : p → q)"},
 {"type": "a = b → b = a",
  "tactic-prompt": "example (a b : Nat) : a = b → b = a := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b : Nat) : a = b → b = a",
  "args": "(a b : Nat)"},
 {"type": "a = b → True → b = a",
  "tactic-prompt":
  "example (a b : Nat) : a = b → True → b = a := by intro h _; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h _",
  "core-prompt": "(a b : Nat) : a = b → True → b = a",
  "args": "(a b : Nat)"},
 {"type": "sameParity a b → sameParity b a",
  "tactic-prompt":
  "example (a b : Nat) : sameParity a b → sameParity b a := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b : Nat) : sameParity a b → sameParity b a",
  "args": "(a b : Nat)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by run_tac\n    evalApplyLikeTactic MVarId.apply (← `(True.intro)); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "run_tac\n    evalApplyLikeTactic MVarId.apply (← `(True.intro))",
  "core-prompt": " : True",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "def (h : Nat) : Nat := by solve_by_elim; sorry",
  "name": "test1",
  "kind": "def",
  "first-tactic": "solve_by_elim",
  "core-prompt": "(h : Nat) : Nat",
  "args": "(h : Nat)"},
 {"type": "β",
  "tactic-prompt":
  "def {α β : Type}  (f : α → β)  (a : α) : β := by solve_by_elim; sorry",
  "name": "test2",
  "kind": "def",
  "first-tactic": "solve_by_elim",
  "core-prompt": "{α β : Type}  (f : α → β)  (a : α) : β",
  "args": "{α β : Type}  (f : α → β)  (a : α)"},
 {"type": "β",
  "tactic-prompt":
  "def {α β : Type}  (f : α → α → β)  (a : α) : β := by solve_by_elim; sorry",
  "name": "test3",
  "kind": "def",
  "first-tactic": "solve_by_elim",
  "core-prompt": "{α β : Type}  (f : α → α → β)  (a : α) : β",
  "args": "{α β : Type}  (f : α → α → β)  (a : α)"},
 {"type": "γ",
  "tactic-prompt":
  "def {α β γ : Type}  (f : α → β)  (g : β → γ)  (a : α) : γ := by solve_by_elim; sorry",
  "name": "test4",
  "kind": "def",
  "first-tactic": "solve_by_elim",
  "core-prompt": "{α β γ : Type}  (f : α → β)  (g : β → γ)  (a : α) : γ",
  "args": "{α β γ : Type}  (f : α → β)  (g : β → γ)  (a : α)"},
 {"type": "γ",
  "tactic-prompt":
  "def {α β γ : Type}  (f : α → β)  (g : β → γ)  (b : β) : γ := by solve_by_elim; sorry",
  "name": "test5",
  "kind": "def",
  "first-tactic": "solve_by_elim",
  "core-prompt": "{α β γ : Type}  (f : α → β)  (g : β → γ)  (b : β) : γ",
  "args": "{α β γ : Type}  (f : α → β)  (g : β → γ)  (b : β)"},
 {"type": "α 5",
  "tactic-prompt":
  "def {α : Nat → Type}  (f : (n : Nat) → α n → α (n+1))  (a : α 0) : α 5 := by solve_by_elim; sorry",
  "name": "test6",
  "kind": "def",
  "first-tactic": "solve_by_elim",
  "core-prompt":
  "{α : Nat → Type}  (f : (n : Nat) → α n → α (n+1))  (a : α 0) : α 5",
  "args": "{α : Nat → Type}  (f : (n : Nat) → α n → α (n+1))  (a : α 0)"},
 {"type": "x + y = y + x",
  "tactic-prompt":
  "example (x y : Nat) : x + y = y + x := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(x y : Nat) : x + y = y + x",
  "args": "(x y : Nat)"},
 {"type": "n ≤ m → n + k ≤ m + k",
  "tactic-prompt":
  "example (n m k : Nat) : n ≤ m → n + k ≤ m + k := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(n m k : Nat) : n ≤ m → n + k ≤ m + k",
  "args": "(n m k : Nat)"},
 {"type": "a * b ∣ a * c",
  "tactic-prompt":
  "example (ha : a > 0)  (w : b ∣ c) : a * b ∣ a * c := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(ha : a > 0)  (w : b ∣ c) : a * b ∣ a * c",
  "args": "(ha : a > 0)  (w : b ∣ c)"},
 {"type": "Int",
  "tactic-prompt": "example  : Int := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": " : Int",
  "args": ""},
 {"type": "P",
  "tactic-prompt":
  "example (P : Prop)  (p : P) : P := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(P : Prop)  (p : P) : P",
  "args": "(P : Prop)  (p : P)"},
 {"type": "false",
  "tactic-prompt":
  "example (P : Prop)  (p : P)  (np : ¬P) : false := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(P : Prop)  (p : P)  (np : ¬P) : false",
  "args": "(P : Prop)  (p : P)  (np : ¬P)"},
 {"type": "α → α",
  "tactic-prompt": "example (α : Prop) : α → α := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(α : Prop) : α → α",
  "args": "(α : Prop)"},
 {"type": "(¬¬p) → p",
  "tactic-prompt": "example (p : Prop) : (¬¬p) → p := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(p : Prop) : (¬¬p) → p",
  "args": "(p : Prop)"},
 {"type": "a + b = b + a",
  "tactic-prompt":
  "example (a b : ℕ) : a + b = b + a := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a b : ℕ) : a + b = b + a",
  "args": "(a b : ℕ)"},
 {"type": "n * (m - k) = n * m - n * k",
  "tactic-prompt":
  "example (n m k : ℕ) : n * (m - k) = n * m - n * k := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(n m k : ℕ) : n * (m - k) = n * m - n * k",
  "args": "(n m k : ℕ)"},
 {"type": "x = y ↔ y = x",
  "tactic-prompt":
  "example {α : Type}  (x y : α) : x = y ↔ y = x := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "{α : Type}  (x y : α) : x = y ↔ y = x",
  "args": "{α : Type}  (x y : α)"},
 {"type": "a ≤ b",
  "tactic-prompt":
  "example (a b : ℕ)  (h : a ∣ b)  (w : b > 0) : a ≤ b := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a b : ℕ)  (h : a ∣ b)  (w : b > 0) : a ≤ b",
  "args": "(a b : ℕ)  (h : a ∣ b)  (w : b > 0)"},
 {"type": "¬ (a < 0)",
  "tactic-prompt": "example (a : ℕ) : ¬ (a < 0) := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a : ℕ) : ¬ (a < 0)",
  "args": "(a : ℕ)"},
 {"type": "0 > a",
  "tactic-prompt": "theorem (a : ℕ)  (h : P a) : 0 > a := by cases h; sorry",
  "name": "lemma_with_gt_in_head",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt": "(a : ℕ)  (h : P a) : 0 > a",
  "args": "(a : ℕ)  (h : P a)"},
 {"type": "False",
  "tactic-prompt":
  "theorem (a b : ℕ)  (h1 : a < b)  (h2 : P a) : False := by apply Nat.not_lt_zero; sorry",
  "name": "lemma_with_false_in_head",
  "kind": "theorem",
  "first-tactic": "apply Nat.not_lt_zero",
  "core-prompt": "(a b : ℕ)  (h1 : a < b)  (h2 : P a) : False",
  "args": "(a b : ℕ)  (h1 : a < b)  (h2 : P a)"},
 {"type": "0 > a",
  "tactic-prompt":
  "example (a : ℕ)  (h : P a) : 0 > a := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a : ℕ)  (h : P a) : 0 > a",
  "args": "(a : ℕ)  (h : P a)"},
 {"type": "∀ P : Prop, ¬(P ↔ ¬P)",
  "tactic-prompt":
  "example  : ∀ P : Prop, ¬(P ↔ ¬P) := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": " : ∀ P : Prop, ¬(P ↔ ¬P)",
  "args": ""},
 {"type": "α",
  "tactic-prompt":
  "example {α : Sort u}  (h : Empty) : α := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "{α : Sort u}  (h : Empty) : α",
  "args": "{α : Sort u}  (h : Empty)"},
 {"type": "α",
  "tactic-prompt":
  "example {α : Type _}  (h : Empty) : α := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "{α : Type _}  (h : Empty) : α",
  "args": "{α : Type _}  (h : Empty)"},
 {"type": "f a ≤ f b",
  "tactic-prompt":
  "example (a b : ℕ)  (h : a ≤ b) : f a ≤ f b := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a b : ℕ)  (h : a ≤ b) : f a ≤ f b",
  "args": "(a b : ℕ)  (h : a ≤ b)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (delete_this_dep : delete_this = delete_this) : Nat := by clear! delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this",
  "core-prompt":
  "(delete_this : Nat)  (delete_this_dep : delete_this = delete_this) : Nat",
  "args": "(delete_this : Nat)  (delete_this_dep : delete_this = delete_this)"},
 {"type": "Inhabited Nat",
  "tactic-prompt":
  "example [dont_delete_this : Inhabited Nat] : Inhabited Nat := by clear! dont_delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! dont_delete_this",
  "core-prompt": "[dont_delete_this : Inhabited Nat] : Inhabited Nat",
  "args": "[dont_delete_this : Inhabited Nat]"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (delete_this2 : Nat)  (delete_this_dep : delete_this = delete_this2) : Nat := by clear! delete_this delete_this2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this delete_this2",
  "core-prompt":
  "(delete_this : Nat)  (delete_this2 : Nat)  (delete_this_dep : delete_this = delete_this2) : Nat",
  "args":
  "(delete_this : Nat)  (delete_this2 : Nat)  (delete_this_dep : delete_this = delete_this2)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (dont_delete_this : Int) : Nat := by clear! delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this",
  "core-prompt": "(delete_this : Nat)  (dont_delete_this : Int) : Nat",
  "args": "(delete_this : Nat)  (dont_delete_this : Int)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (dont_delete_this : Nat)  (delete_this : dont_delete_this = dont_delete_this) : Nat := by clear! delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this",
  "core-prompt":
  "(dont_delete_this : Nat)  (delete_this : dont_delete_this = dont_delete_this) : Nat",
  "args":
  "(dont_delete_this : Nat)  (delete_this : dont_delete_this = dont_delete_this)"},
 {"type": "foo.rfl.toFun n = n",
  "tactic-prompt":
  "example (n : ℕ) : foo.rfl.toFun n = n := by rw [foo.rfl_toFun]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rw [foo.rfl_toFun]",
  "core-prompt": "(n : ℕ) : foo.rfl.toFun n = n",
  "args": "(n : ℕ)"},
 {"type": "foo.rfl.invFun n = n",
  "tactic-prompt":
  "example (n : ℕ) : foo.rfl.invFun n = n := by rw [foo.rfl_invFun]\n\n/- the declarations are `simp` lemmas -/; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "rw [foo.rfl_invFun]\n\n/- the declarations are `simp` lemmas -/",
  "core-prompt": "(n : ℕ) : foo.rfl.invFun n = n",
  "args": "(n : ℕ)"},
 {"type": "foo.1 = 1",
  "tactic-prompt": "example  : foo.1 = 1 := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": " : foo.1 = 1",
  "args": ""},
 {"type": "foo.1 = a",
  "tactic-prompt":
  "example {a : ℕ}  {h : 1 = a} : foo.1 = a := by rw [foo_fst]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rw [foo_fst]",
  "core-prompt": "{a : ℕ}  {h : 1 = a} : foo.1 = a",
  "args": "{a : ℕ}  {h : 1 = a}"},
 {"type": "foo.1 = a",
  "tactic-prompt": "example {a : ℕ}  {h : 1 = a} : foo.1 = a := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "{a : ℕ}  {h : 1 = a} : foo.1 = a",
  "args": "{a : ℕ}  {h : 1 = a}"},
 {"type": "foo.2 = a",
  "tactic-prompt": "example {a : ℤ}  {h : 2 = a} : foo.2 = a := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "{a : ℤ}  {h : 2 = a} : foo.2 = a",
  "args": "{a : ℤ}  {h : 2 = a}"},
 {"type": "foo.1 = a",
  "tactic-prompt":
  "example {a : ℕ}  {h : 1 = a} : foo.1 = a := by dsimp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp",
  "core-prompt": "{a : ℕ}  {h : 1 = a} : foo.1 = a",
  "args": "{a : ℕ}  {h : 1 = a}"},
 {"type": "foo.2 = a",
  "tactic-prompt":
  "example {a : ℤ}  {h : 2 = a} : foo.2 = a := by dsimp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp",
  "core-prompt": "{a : ℤ}  {h : 2 = a} : foo.2 = a",
  "args": "{a : ℤ}  {h : 2 = a}"},
 {"type": "(f.trans g).toFun x = z",
  "tactic-prompt":
  "example {α β γ : Type}  (f : α ≃ β)  (g : β ≃ γ)  (x : α)  {z : γ}  (h : g.toFun (f.toFun x) = z) : (f.trans g).toFun x = z := by dsimp only [Equiv'.trans_toFun]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Equiv'.trans_toFun]",
  "core-prompt":
  "{α β γ : Type}  (f : α ≃ β)  (g : β ≃ γ)  (x : α)  {z : γ}  (h : g.toFun (f.toFun x) = z) : (f.trans g).toFun x = z",
  "args":
  "{α β γ : Type}  (f : α ≃ β)  (g : β ≃ γ)  (x : α)  {z : γ}  (h : g.toFun (f.toFun x) = z)"},
 {"type": "myNatEquiv.toFun (myNatEquiv.toFun $ myNatEquiv.invFun n) = n",
  "tactic-prompt":
  "example (n : ℕ) : myNatEquiv.toFun (myNatEquiv.toFun $ myNatEquiv.invFun n) = n := by simp only [myNatEquiv_toFun]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [myNatEquiv_toFun]",
  "core-prompt":
  "(n : ℕ) : myNatEquiv.toFun (myNatEquiv.toFun $ myNatEquiv.invFun n) = n",
  "args": "(n : ℕ)"},
 {"type": "(X ⟶ X) = x",
  "tactic-prompt":
  "example (X : Type u)  {x : Type u}  (h : (X → X) = x) : (X ⟶ X) = x := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "(X : Type u)  {x : Type u}  (h : (X → X) = x) : (X ⟶ X) = x",
  "args": "(X : Type u)  {x : Type u}  (h : (X → X) = x)"},
 {"type": "𝟙 X = f",
  "tactic-prompt":
  "example (X : Type u)  {f : X → X}  (h : ∀ x, f x = x) : 𝟙 X = f := by ext; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ext",
  "core-prompt": "(X : Type u)  {f : X → X}  (h : ∀ x, f x = x) : 𝟙 X = f",
  "args": "(X : Type u)  {f : X → X}  (h : ∀ x, f x = x)"},
 {"type": "f ≫ g = k",
  "tactic-prompt":
  "example (X Y Z : Type u)  (f : X ⟶ Y)  (g : Y ⟶ Z)  {k : X → Z}  (h : ∀ x, g (f x) = k x) : f ≫ g = k := by ext; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ext",
  "core-prompt":
  "(X Y Z : Type u)  (f : X ⟶ Y)  (g : Y ⟶ Z)  {k : X → Z}  (h : ∀ x, g (f x) = k x) : f ≫ g = k",
  "args":
  "(X Y Z : Type u)  (f : X ⟶ Y)  (g : Y ⟶ Z)  {k : X → Z}  (h : ∀ x, g (f x) = k x)"},
 {"type": "foo = x",
  "tactic-prompt":
  "example {x : Type}  (h : ℕ = x) : foo = x := by simp only [foo_c]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [foo_c]",
  "core-prompt": "{x : Type}  (h : ℕ = x) : foo = x",
  "args": "{x : Type}  (h : ℕ = x)"},
 {"type": "foo.x = x",
  "tactic-prompt":
  "example {x : ℕ}  (h : (3 : ℕ) = x) : foo.x = x := by simp only [foo_x]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [foo_x]",
  "core-prompt": "{x : ℕ}  (h : (3 : ℕ) = x) : foo.x = x",
  "args": "{x : ℕ}  (h : (3 : ℕ) = x)"},
 {"type": "voo = x",
  "tactic-prompt":
  "example {x : Type}  (h : ℕ = x) : voo = x := by simp only [voo_c]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [voo_c]",
  "core-prompt": "{x : Type}  (h : ℕ = x) : voo = x",
  "args": "{x : Type}  (h : ℕ = x)"},
 {"type": "voo.x = x",
  "tactic-prompt":
  "example {x : ℕ}  (h : (3 : ℕ) = x) : voo.x = x := by simp only [voo_x]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [voo_x]",
  "core-prompt": "{x : ℕ}  (h : (3 : ℕ) = x) : voo.x = x",
  "args": "{x : ℕ}  (h : (3 : ℕ) = x)"},
 {"type": "x * - 0 ⊆ - x",
  "tactic-prompt": "example (x : ℕ) : x * - 0 ⊆ - x := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "(x : ℕ) : x * - 0 ⊆ - x",
  "args": "(x : ℕ)"},
 {"type": "x * - 0 ⊆ - x",
  "tactic-prompt": "example (x : ℕ) : x * - 0 ⊆ - x := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "(x : ℕ) : x * - 0 ⊆ - x",
  "args": "(x : ℕ)"},
 {"type": "Nat.SetPlus1.s = x",
  "tactic-prompt":
  "example {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x) : Nat.SetPlus1.s = x := by dsimp only [Nat.SetPlus1_s]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Nat.SetPlus1_s]",
  "core-prompt":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x) : Nat.SetPlus1.s = x",
  "args":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x)"},
 {"type": "Nat.SetPlus2.s = x",
  "tactic-prompt":
  "example {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x) : Nat.SetPlus2.s = x := by dsimp only [Nat.SetPlus2_s]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Nat.SetPlus2_s]",
  "core-prompt":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x) : Nat.SetPlus2.s = x",
  "args":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x)"},
 {"type": "Nat.SetPlus3.s = x",
  "tactic-prompt":
  "example {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x) : Nat.SetPlus3.s = x := by dsimp only [Nat.SetPlus3_s]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Nat.SetPlus3_s]",
  "core-prompt":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x) : Nat.SetPlus3.s = x",
  "args":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {x : Set ℕ}  (h : Set.univ = x)"},
 {"type": "(Equiv.symm2.invFun e).toFun = x",
  "tactic-prompt":
  "example {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} (e : α ≃ β)  {x : β → α}  (h : e.invFun = x) : (Equiv.symm2.invFun e).toFun = x := by dsimp only [Equiv.symm2_invFun_toFun]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Equiv.symm2_invFun_toFun]",
  "core-prompt":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} (e : α ≃ β)  {x : β → α}  (h : e.invFun = x) : (Equiv.symm2.invFun e).toFun = x",
  "args":
  "{α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} {α β γ : Sort _} (e : α ≃ β)  {x : β → α}  (h : e.invFun = x)"},
 {"type": "Inhabited p",
  "tactic-prompt":
  "example {p : Prop}  [Nonempty p] : Inhabited p := by inhabit p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit p",
  "core-prompt": "{p : Prop}  [Nonempty p] : Inhabited p",
  "args": "{p : Prop}  [Nonempty p]"},
 {"type": "Inhabited α",
  "tactic-prompt":
  "example {α : Type}  [Nonempty α] : Inhabited α := by inhabit α; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit α",
  "core-prompt": "{α : Type}  [Nonempty α] : Inhabited α",
  "args": "{α : Type}  [Nonempty α]"},
 {"type": "Inhabited α",
  "tactic-prompt":
  "example {α : Type 3}  [Nonempty α] : Inhabited α := by inhabit α; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit α",
  "core-prompt": "{α : Type 3}  [Nonempty α] : Inhabited α",
  "args": "{α : Type 3}  [Nonempty α]"},
 {"type": "Nonempty α → Inhabited α",
  "tactic-prompt":
  "example {α : Type} : Nonempty α → Inhabited α := by intro nonempty_α; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro nonempty_α",
  "core-prompt": "{α : Type} : Nonempty α → Inhabited α",
  "args": "{α : Type}"},
 {"type": "Inhabited p",
  "tactic-prompt":
  "example {p : Prop}  [Nonempty p] : Inhabited p := by inhabit p_inhabited : p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit p_inhabited : p",
  "core-prompt": "{p : Prop}  [Nonempty p] : Inhabited p",
  "args": "{p : Prop}  [Nonempty p]"},
 {"type": "Inhabited α",
  "tactic-prompt": "example  : Inhabited α := by inhabit α; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit α",
  "core-prompt": " : Inhabited α",
  "args": ""},
 {"type": "True",
  "tactic-prompt": "example  : True := by type_check Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "type_check Nat",
  "core-prompt": " : True",
  "args": ""},
 {"type": "(an : ℤ) = bn → an = bn",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) = bn → an = bn := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) = bn → an = bn",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "an = bn → (an : ℤ) = bn",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : an = bn → (an : ℤ) = bn := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : an = bn → (an : ℤ) = bn",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "(an : ℤ) < bn ↔ an < bn",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) < bn ↔ an < bn := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) < bn ↔ an < bn",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "(an : ℤ) ≠ (bn : ℤ) ↔ an ≠ bn",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) ≠ (bn : ℤ) ↔ an ≠ bn := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) ≠ (bn : ℤ) ↔ an ≠ bn",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "az > (1 : ℕ) ↔ az > 1",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : az > (1 : ℕ) ↔ az > 1 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : az > (1 : ℕ) ↔ az > 1",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "az > (0 : ℕ) ↔ az > 0",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : az > (0 : ℕ) ↔ az > 0 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : az > (0 : ℕ) ↔ az > 0",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "(an : ℤ) ≠ 0 ↔ an ≠ 0",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) ≠ 0 ↔ an ≠ 0 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) ≠ 0 ↔ an ≠ 0",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "(an : ℤ) + bn = (an + bn : ℕ)",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) + bn = (an + bn : ℕ) := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : (an : ℤ) + bn = (an + bn : ℕ)",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "((42 : ℕ) : ℤ) = 42",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : ((42 : ℕ) : ℤ) = 42 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : ((42 : ℕ) : ℤ) = 42",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "p 42",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : p 42 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) : p 42",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ)"},
 {"type": "an - bn = 1 ↔ (an - bn : ℤ) = 1",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h : bn ≤ an) : an - bn = 1 ↔ (an - bn : ℤ) = 1 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h : bn ≤ an) : an - bn = 1 ↔ (an - bn : ℤ) = 1",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h : bn ≤ an)"},
 {"type": "x * y = 1",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) [Mul α]  [One α]  (x y : α)  (h : (x : WithZero α) * y = 1) : x * y = 1 := by exact_mod_cast h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "exact_mod_cast h",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) [Mul α]  [One α]  (x y : α)  (h : (x : WithZero α) * y = 1) : x * y = 1",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) [Mul α]  [One α]  (x y : α)  (h : (x : WithZero α) * y = 1)"},
 {"type":
  "(x * x + y * y : ℤ) - ↑((x * y + 1) * k) = ↑y * ↑y - ↑k * ↑x * ↑y + (↑x * ↑x - ↑k)",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (k : ℕ)  {x y : ℕ} : (x * x + y * y : ℤ) - ↑((x * y + 1) * k) = ↑y * ↑y - ↑k * ↑x * ↑y + (↑x * ↑x - ↑k) := by push_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (k : ℕ)  {x y : ℕ} : (x * x + y * y : ℤ) - ↑((x * y + 1) * k) = ↑y * ↑y - ↑k * ↑x * ↑y + (↑x * ↑x - ↑k)",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (k : ℕ)  {x y : ℕ}"},
 {"type": "x + y + k = 0",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (k : ℕ)  {x y : ℕ}  (h : ((x + y + k : ℕ) : ℤ) = 0) : x + y + k = 0 := by push_cast at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_cast at h",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (k : ℕ)  {x y : ℕ}  (h : ((x + y + k : ℕ) : ℤ) = 0) : x + y + k = 0",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (k : ℕ)  {x y : ℕ}  (h : ((x + y + k : ℕ) : ℤ) = 0)"},
 {"type": "((a + b : ℕ) : ℤ) = 10",
  "tactic-prompt":
  "example (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (a b : ℕ)  (h2 : ((a + b + 0 : ℕ) : ℤ) = 10) : ((a + b : ℕ) : ℤ) = 10 := by push_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_cast",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (a b : ℕ)  (h2 : ((a + b + 0 : ℕ) : ℤ) = 10) : ((a + b : ℕ) : ℤ) = 10",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (a b : ℕ)  (h2 : ((a + b + 0 : ℕ) : ℤ) = 10)"},
 {"type": "true ∧ true",
  "tactic-prompt":
  "lemma (an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h g : true) : true ∧ true := by constructor; sorry",
  "name": "b",
  "kind": "lemma",
  "first-tactic": "constructor",
  "core-prompt":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h g : true) : true ∧ true",
  "args":
  "(an bn cn dn : ℕ)  (az bz cz dz : ℤ) -- variable (aq bq cq dq : ℚ) -- variable (ar br cr dr : ℝ) (ac bc cc dc : ℂ) (h g : true)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : α × β × γ) : True := by cases' x with a b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' x with a b",
  "core-prompt": "(x : α × β × γ) : True",
  "args": "(x : α × β × γ)"},
 {"type": "True",
  "tactic-prompt":
  "example {α β γ : Type u}  (x : α × β × γ) : True := by cases' h: x with a b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' h: x with a b",
  "core-prompt": "{α β γ : Type u}  (x : α × β × γ) : True",
  "args": "{α β γ : Type u}  (x : α × β × γ)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : ℕ) : True := by cases' h: x using my_rec with y; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' h: x using my_rec with y",
  "core-prompt": "(x : ℕ) : True",
  "args": "(x : ℕ)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : Foo α β) : True := by cases' x with a₀ a₁ _ a₂ b₂ c₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' x with a₀ a₁ _ a₂ b₂ c₂",
  "core-prompt": "(x : Foo α β) : True",
  "args": "(x : Foo α β)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : Bar 0) : True := by cases' x with a b c d h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' x with a b c d h",
  "core-prompt": "(x : Bar 0) : True",
  "args": "(x : Bar 0)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : Foo α Nat) : True := by induction' x with a a' b' a'' b'' c'' ih; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction' x with a a' b' a'' b'' c'' ih",
  "core-prompt": "(x : Foo α Nat) : True",
  "args": "(x : Foo α Nat)"},
 {"type": "3 < 4",
  "tactic-prompt": "example  : 3 < 4 := by recover decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "recover decide",
  "core-prompt": " : 3 < 4",
  "args": ""},
 {"type": "1 = 1",
  "tactic-prompt": "example  : 1 = 1 := by recover skip ; rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "recover skip ; rfl",
  "core-prompt": " : 1 = 1",
  "args": ""},
 {"type": "2 = 2",
  "tactic-prompt": "example  : 2 = 2 := by recover skip; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "recover skip",
  "core-prompt": " : 2 = 2",
  "args": ""},
 {"type": "x + y = y + x",
  "tactic-prompt": "example (x y : ℕ) : x + y = y + x := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(x y : ℕ) : x + y = y + x",
  "args": "(x y : ℕ)"},
 {"type": "x + y + y = 2 * y + x",
  "tactic-prompt":
  "example (x y : ℕ) : x + y + y = 2 * y + x := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(x y : ℕ) : x + y + y = 2 * y + x",
  "args": "(x y : ℕ)"},
 {"type": "x + id y = y + id x",
  "tactic-prompt": "example (x y : ℕ) : x + id y = y + id x := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(x y : ℕ) : x + id y = y + id x",
  "args": "(x y : ℕ)"},
 {"type": "(x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y)",
  "tactic-prompt":
  "example (x y : ℕ) : (x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y) := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt":
  "(x y : ℕ) : (x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y)",
  "args": "(x y : ℕ)"},
 {"type": "(n / 2) + (n / 2) = 2 * (n / 2)",
  "tactic-prompt":
  "example (n : ℕ) : (n / 2) + (n / 2) = 2 * (n / 2) := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(n : ℕ) : (n / 2) + (n / 2) = 2 * (n / 2)",
  "args": "(n : ℕ)"},
 {"type": "a * (n - s) = (n - s) * a",
  "tactic-prompt":
  "example (a n s: ℕ) : a * (n - s) = (n - s) * a := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(a n s: ℕ) : a * (n - s) = (n - s) * a",
  "args": "(a n s: ℕ)"},
 {"type": "(2 * A) ^ 2 = (2 * A) ^ 2",
  "tactic-prompt":
  "example (A : ℕ) : (2 * A) ^ 2 = (2 * A) ^ 2 := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(A : ℕ) : (2 * A) ^ 2 = (2 * A) ^ 2",
  "args": "(A : ℕ)"},
 {"type": "nleq a b → nleq b c → nleq a c",
  "tactic-prompt":
  "example (a b c : Nat) : nleq a b → nleq b c → nleq a c := by intro h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h₁ h₂",
  "core-prompt": "(a b c : Nat) : nleq a b → nleq b c → nleq a c",
  "args": "(a b c : Nat)"},
 {"type": "nleq a b → nleq b c → nleq a c",
  "tactic-prompt":
  "example (a b c : Nat) : nleq a b → nleq b c → nleq a c := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b c : Nat) : nleq a b → nleq b c → nleq a c",
  "args": "(a b c : Nat)"},
 {"type": "a = b → b = c → a = c",
  "tactic-prompt":
  "def {a b c : α} : a = b → b = c → a = c := by intro h₁ h₂; sorry",
  "name": "eq_trans",
  "kind": "def",
  "first-tactic": "intro h₁ h₂",
  "core-prompt": "{a b c : α} : a = b → b = c → a = c",
  "args": "{a b c : α}"},
 {"type": "a = b → b = c → a = c",
  "tactic-prompt":
  "example (a b c : Nat) : a = b → b = c → a = c := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b c : Nat) : a = b → b = c → a = c",
  "args": "(a b c : Nat)"},
 {"type": "a = b → b = c → a = c",
  "tactic-prompt":
  "example (a b c : Nat) : a = b → b = c → a = c := by intro h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h₁ h₂",
  "core-prompt": "(a b c : Nat) : a = b → b = c → a = c",
  "args": "(a b c : Nat)"},
 {"type": "a ≤ b → b ≤ c → a ≤ c",
  "tactic-prompt":
  "example (a b c : Nat) : a ≤ b → b ≤ c → a ≤ c := by intros h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros h₁ h₂",
  "core-prompt": "(a b c : Nat) : a ≤ b → b ≤ c → a ≤ c",
  "args": "(a b c : Nat)"},
 {"type": "R a b → R b c → R a c",
  "tactic-prompt":
  "example (a b c : α)  (R : α → α → Prop)  [Trans R R R] : R a b → R b c → R a c := by intros h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros h₁ h₂",
  "core-prompt":
  "(a b c : α)  (R : α → α → Prop)  [Trans R R R] : R a b → R b c → R a c",
  "args": "(a b c : α)  (R : α → α → Prop)  [Trans R R R]"},
 {"type": "a ≤ b → b ≤ c → a ≤ c",
  "tactic-prompt":
  "example (a b c : Nat) : a ≤ b → b ≤ c → a ≤ c := by intros h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros h₁ h₂",
  "core-prompt": "(a b c : Nat) : a ≤ b → b ≤ c → a ≤ c",
  "args": "(a b c : Nat)"},
 {"type": "a ≤ b → b ≤ c → a ≤ c",
  "tactic-prompt":
  "example (a b c : Nat) : a ≤ b → b ≤ c → a ≤ c := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b c : Nat) : a ≤ b → b ≤ c → a ≤ c",
  "args": "(a b c : Nat)"},
 {"type": "a < b → b < c → a < c",
  "tactic-prompt":
  "example (a b c : Nat) : a < b → b < c → a < c := by intro h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h₁ h₂",
  "core-prompt": "(a b c : Nat) : a < b → b < c → a < c",
  "args": "(a b c : Nat)"},
 {"type": "a < b → b < c → a < c",
  "tactic-prompt":
  "example (a b c : Nat) : a < b → b < c → a < c := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b c : Nat) : a < b → b < c → a < c",
  "args": "(a b c : Nat)"},
 {"type": "n * p ≤ x",
  "tactic-prompt":
  "example (x n p : Nat)  (h₁ : n * Nat.succ p ≤ x) : n * p ≤ x := by trans; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "trans",
  "core-prompt": "(x n p : Nat)  (h₁ : n * Nat.succ p ≤ x) : n * p ≤ x",
  "args": "(x n p : Nat)  (h₁ : n * Nat.succ p ≤ x)"},
 {"type": "x = x",
  "tactic-prompt":
  "example (x : Nat)  (h : x = x) : x = x := by set! p := h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "set! p := h",
  "core-prompt": "(x : Nat)  (h : x = x) : x = x",
  "args": "(x : Nat)  (h : x = x)"},
 {"type": "x = x",
  "tactic-prompt":
  "example (x : Nat)  (h : x - x = 0) : x = x := by set y : Nat := x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "set y : Nat := x",
  "core-prompt": "(x : Nat)  (h : x - x = 0) : x = x",
  "args": "(x : Nat)  (h : x - x = 0)"},
 {"type": "(λ (x y : Nat) => x + y) = (λ x y => y + x)",
  "tactic-prompt":
  "example  : (λ (x y : Nat) => x + y) = (λ x y => y + x) := by simp_rw [Nat.add_comm]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm]",
  "core-prompt": " : (λ (x y : Nat) => x + y) = (λ x y => y + x)",
  "args": ""},
 {"type": "a = c",
  "tactic-prompt":
  "example (f : Nat → Nat)  {a b c : Nat}  (ha : f b = a)  (hc : f b = c) : a = c := by simp_rw [← ha]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [← ha]",
  "core-prompt":
  "(f : Nat → Nat)  {a b c : Nat}  (ha : f b = a)  (hc : f b = c) : a = c",
  "args": "(f : Nat → Nat)  {a b c : Nat}  (ha : f b = a)  (hc : f b = c)"},
 {"type": "a + (b + (c + d)) = ((d + c) + b) + a",
  "tactic-prompt":
  "example (a b c d : Nat) : a + (b + (c + d)) = ((d + c) + b) + a := by simp_rw [Nat.add_comm]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm]",
  "core-prompt": "(a b c d : Nat) : a + (b + (c + d)) = ((d + c) + b) + a",
  "args": "(a b c d : Nat)"},
 {"type": "p (b + a)",
  "tactic-prompt":
  "example (p : Nat → Prop)  (a b : Nat)  (h : p (a + b)) : p (b + a) := by simp_rw [Nat.add_comm a b] at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm a b] at h",
  "core-prompt": "(p : Nat → Prop)  (a b : Nat)  (h : p (a + b)) : p (b + a)",
  "args": "(p : Nat → Prop)  (a b : Nat)  (h : p (a + b))"},
 {"type": "p (b + a)",
  "tactic-prompt":
  "example (p : Nat → Prop)  (a b : Nat)  (h₁ : p (b + a) → p (a + b))   (h₂ : p (a + b)) : p (b + a) := by simp_rw [Nat.add_comm a b] at h₁ h₂; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm a b] at h₁ h₂",
  "core-prompt":
  "(p : Nat → Prop)  (a b : Nat)  (h₁ : p (b + a) → p (a + b))   (h₂ : p (a + b)) : p (b + a)",
  "args":
  "(p : Nat → Prop)  (a b : Nat)  (h₁ : p (b + a) → p (a + b))   (h₂ : p (a + b))"},
 {"type": "p (a + b)",
  "tactic-prompt":
  "example (p : Nat → Prop)  (a b : Nat)  (h₁ : p (b + a) → p (a + b))   (h₂ : p (a + b)) : p (a + b) := by simp_rw [Nat.add_comm a b] at *; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm a b] at *",
  "core-prompt":
  "(p : Nat → Prop)  (a b : Nat)  (h₁ : p (b + a) → p (a + b))   (h₂ : p (a + b)) : p (a + b)",
  "args":
  "(p : Nat → Prop)  (a b : Nat)  (h₁ : p (b + a) → p (a + b))   (h₂ : p (a + b))"},
 {"type": "(∀ b, a - 1 ≤ b) = ∀ b c : Nat, c < a → c < b + 1",
  "tactic-prompt":
  "example {a : Nat}    (h1 : ∀ a b : Nat, a - 1 ≤ b ↔ a ≤ b + 1)    (h2 : ∀ a b : Nat, a ≤ b ↔ ∀ c, c < a → c < b) : (∀ b, a - 1 ≤ b) = ∀ b c : Nat, c < a → c < b + 1 := by simp_rw [h1]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [h1]",
  "core-prompt":
  "{a : Nat}    (h1 : ∀ a b : Nat, a - 1 ≤ b ↔ a ≤ b + 1)    (h2 : ∀ a b : Nat, a ≤ b ↔ ∀ c, c < a → c < b) : (∀ b, a - 1 ≤ b) = ∀ b c : Nat, c < a → c < b + 1",
  "args":
  "{a : Nat}    (h1 : ∀ a b : Nat, a - 1 ≤ b ↔ a ≤ b + 1)    (h2 : ∀ a b : Nat, a ≤ b ↔ ∀ c, c < a → c < b)"},
 {"type": "p → q → r → p ∧ q ∧ r",
  "tactic-prompt":
  "example (p q r : Prop) : p → q → r → p ∧ q ∧ r := by intros a b c; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros a b c",
  "core-prompt": "(p q r : Prop) : p → q → r → p ∧ q ∧ r",
  "args": "(p q r : Prop)"},
 {"type": "p → q → p ∧ q",
  "tactic-prompt":
  "example (p q : Prop) : p → q → p ∧ q := by intros a b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros a b",
  "core-prompt": "(p q : Prop) : p → q → p ∧ q",
  "args": "(p q : Prop)"},
 {"type": "p → p",
  "tactic-prompt": "example (p : Prop) : p → p := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(p : Prop) : p → p",
  "args": "(p : Prop)"},
 {"type": "Nat",
  "tactic-prompt": "example (h : Int) : Nat := by replace h : Nat := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "replace h : Nat := 0",
  "core-prompt": "(h : Int) : Nat",
  "args": "(h : Int)"},
 {"type": "Nat",
  "tactic-prompt": "example (h : Nat) : Nat := by have h : Int := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have h : Int := 0",
  "core-prompt": "(h : Nat) : Nat",
  "args": "(h : Nat)"},
 {"type": "Nat",
  "tactic-prompt": "example (h : Nat) : Nat := by replace h : Int := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "replace h : Int := 0",
  "core-prompt": "(h : Nat) : Nat",
  "args": "(h : Nat)"},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have : Int := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : Int := 0",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have : Nat := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : Nat := 0",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have : Nat := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : Nat := 0",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "a = a",
  "tactic-prompt":
  "example {a : Nat} : a = a := by replace a : Int := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "replace a : Int := 0",
  "core-prompt": "{a : Nat} : a = a",
  "args": "{a : Nat}"},
 {"type": "Nat",
  "tactic-prompt": "example (z : Int) : Nat := by replace z : Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "replace z : Nat",
  "core-prompt": "(z : Int) : Nat",
  "args": "(z : Int)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by have : 1 + 1 = 2 := by simp_arith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : 1 + 1 = 2 := by simp_arith",
  "core-prompt": " : True",
  "args": ""},
 {"type": "x + 1 = 1 + x",
  "tactic-prompt": "example  : x + 1 = 1 + x := by simp? [Nat.add_comm]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp? [Nat.add_comm]",
  "core-prompt": " : x + 1 = 1 + x",
  "args": ""},
 {"type": "1 + 1 = 2",
  "tactic-prompt": "example  : 1 + 1 = 2 := by dsimp?; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp?",
  "core-prompt": " : 1 + 1 = 2",
  "args": ""},
 {"type": "foo x y = 1 + y",
  "tactic-prompt": "example  : foo x y = 1 + y := by cases x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases x",
  "core-prompt": " : foo x y = 1 + y",
  "args": ""},
 {"type": "foo x y = 1 + y",
  "tactic-prompt":
  "example  : foo x y = 1 + y := by squeeze_scope\n    cases x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "squeeze_scope\n    cases x",
  "core-prompt": " : foo x y = 1 + y",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have h : Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have h : Nat",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have : Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : Nat",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "a = a",
  "tactic-prompt": "example {a : Nat} : a = a := by have h : a = a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have h : a = a",
  "core-prompt": "{a : Nat} : a = a",
  "args": "{a : Nat}"},
 {"type": "a = a",
  "tactic-prompt": "example {a : Nat} : a = a := by have : a = a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : a = a",
  "core-prompt": "{a : Nat} : a = a",
  "args": "{a : Nat}"},
 {"type": "True",
  "tactic-prompt": "example  : True := by (let N); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "(let N)",
  "core-prompt": " : True",
  "args": ""},
 {"type": "∃ x : Nat, x = x",
  "tactic-prompt": "example  : ∃ x : Nat, x = x := by use 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use 42",
  "core-prompt": " : ∃ x : Nat, x = x",
  "args": ""},
 {"type": "∃ x : Nat, ∃ y : Nat, x = y",
  "tactic-prompt":
  "example  : ∃ x : Nat, ∃ y : Nat, x = y := by use 42, 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use 42, 42",
  "core-prompt": " : ∃ x : Nat, ∃ y : Nat, x = y",
  "args": ""},
 {"type": "∃ x : String × String, x.1 = x.2",
  "tactic-prompt":
  "example  : ∃ x : String × String, x.1 = x.2 := by use (\"a\", \"a\"); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use (\"a\", \"a\")",
  "core-prompt": " : ∃ x : String × String, x.1 = x.2",
  "args": ""},
 {"type": "∃ x : Nat, x = x",
  "tactic-prompt": "example  : ∃ x : Nat, x = x := by use ?_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use ?_",
  "core-prompt": " : ∃ x : Nat, x = x",
  "args": ""},
 {"type": "∃ S : List α, S = S",
  "tactic-prompt":
  "example (α : Type) : ∃ S : List α, S = S := by use ∅; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use ∅",
  "core-prompt": "(α : Type) : ∃ S : List α, S = S",
  "args": "(α : Type)"},
 {"type": "∃ x : Int, x = x",
  "tactic-prompt": "example  : ∃ x : Int, x = x := by use 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use 42",
  "core-prompt": " : ∃ x : Int, x = x",
  "args": ""},
 {"type": "∃ a b c : Int, a + b + c = 6",
  "tactic-prompt":
  "example  : ∃ a b c : Int, a + b + c = 6 := by use 1, 2, 3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use 1, 2, 3",
  "core-prompt": " : ∃ a b c : Int, a + b + c = 6",
  "args": ""},
 {"type": "∃ p : Int × Int, p.1 = 1",
  "tactic-prompt":
  "example  : ∃ p : Int × Int, p.1 = 1 := by use ⟨1, 42⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use ⟨1, 42⟩",
  "core-prompt": " : ∃ p : Int × Int, p.1 = 1",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (x : α × β × γ) : True := by rcases x with ⟨a, b, c⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x with ⟨a, b, c⟩",
  "core-prompt": "(x : α × β × γ) : True",
  "args": "(x : α × β × γ)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : α × β × γ) : True := by rcases x with ⟨(a : α) : id α, -, c : id γ⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x with ⟨(a : α) : id α, -, c : id γ⟩",
  "core-prompt": "(x : α × β × γ) : True",
  "args": "(x : α × β × γ)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : (α × β) × γ) : True := by fail_if_success rcases x with ⟨a, b, c⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success rcases x with ⟨a, b, c⟩",
  "core-prompt": "(x : (α × β) × γ) : True",
  "args": "(x : (α × β) × γ)"},
 {"type": "@Inhabited.{1} α × Option β ⊕ γ → True",
  "tactic-prompt":
  "example  : @Inhabited.{1} α × Option β ⊕ γ → True := by rintro (⟨⟨a⟩, _ | b⟩ | c); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rintro (⟨⟨a⟩, _ | b⟩ | c)",
  "core-prompt": " : @Inhabited.{1} α × Option β ⊕ γ → True",
  "args": ""},
 {"type": "cond false Nat Int → cond true Int Nat → Nat ⊕ Unit → True",
  "tactic-prompt":
  "example  : cond false Nat Int → cond true Int Nat → Nat ⊕ Unit → True := by rintro (x y : Int) (z | u); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rintro (x y : Int) (z | u)",
  "core-prompt":
  " : cond false Nat Int → cond true Int Nat → Nat ⊕ Unit → True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (x y : Nat)  (h : x = y) : True := by rcases x with _|⟨⟩|z; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x with _|⟨⟩|z",
  "core-prompt": "(x y : Nat)  (h : x = y) : True",
  "args": "(x y : Nat)  (h : x = y)"},
 {"type": "True",
  "tactic-prompt":
  "example (s : α ⊕ Empty) : True := by rcases s with s|⟨⟨⟩⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases s with s|⟨⟨⟩⟩",
  "core-prompt": "(s : α ⊕ Empty) : True",
  "args": "(s : α ⊕ Empty)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by obtain ⟨n : Nat, h : n = n, -⟩ : ∃ n : Nat, n = n ∧ True; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "obtain ⟨n : Nat, h : n = n, -⟩ : ∃ n : Nat, n = n ∧ True",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by obtain (h : True) | ⟨⟨⟩⟩ : True ∨ False; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "obtain (h : True) | ⟨⟨⟩⟩ : True ∨ False",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by obtain h | ⟨⟨⟩⟩ : True ∨ False := Or.inl trivial; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "obtain h | ⟨⟨⟩⟩ : True ∨ False := Or.inl trivial",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by obtain ⟨h, h2⟩ := And.intro trivial trivial; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "obtain ⟨h, h2⟩ := And.intro trivial trivial",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by fail_if_success obtain ⟨h, h2⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success obtain ⟨h, h2⟩",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (x y : α × β) : True := by rcases x, y with ⟨⟨a, b⟩, c, d⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x, y with ⟨⟨a, b⟩, c, d⟩",
  "core-prompt": "(x y : α × β) : True",
  "args": "(x y : α × β)"},
 {"type": "True",
  "tactic-prompt":
  "example (x y : α ⊕ β) : True := by rcases x, y with ⟨a|b, c|d⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x, y with ⟨a|b, c|d⟩",
  "core-prompt": "(x y : α ⊕ β) : True",
  "args": "(x y : α ⊕ β)"},
 {"type": "(Σ' x, i ≤ x ∧ x ≤ j) → i ≤ j",
  "tactic-prompt":
  "example (i j : Nat) : (Σ' x, i ≤ x ∧ x ≤ j) → i ≤ j := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt": "(i j : Nat) : (Σ' x, i ≤ x ∧ x ≤ j) → i ≤ j",
  "args": "(i j : Nat)"},
 {"type": "True",
  "tactic-prompt":
  "example (n : Nat) : True := by obtain one_lt_n | n_le_one : 1 < n + 1 ∨ n + 1 ≤ 1 := Nat.lt_or_ge 1 (n + 1); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "obtain one_lt_n | n_le_one : 1 < n + 1 ∨ n + 1 ≤ 1 := Nat.lt_or_ge 1 (n + 1)",
  "core-prompt": "(n : Nat) : True",
  "args": "(n : Nat)"},
 {"type": "True",
  "tactic-prompt":
  "example (n : Nat) : True := by obtain one_lt_n | (n_le_one : n + 1 ≤ 1) := Nat.lt_or_ge 1 (n + 1); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "obtain one_lt_n | (n_le_one : n + 1 ≤ 1) := Nat.lt_or_ge 1 (n + 1)",
  "core-prompt": "(n : Nat) : True",
  "args": "(n : Nat)"},
 {"type": "(b : Bool) → cond b False False → True",
  "tactic-prompt":
  "example  : (b : Bool) → cond b False False → True := by rintro ⟨⟩ ⟨⟩; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rintro ⟨⟩ ⟨⟩",
  "core-prompt": " : (b : Bool) → cond b False False → True",
  "args": ""},
 {"type": "a = a",
  "tactic-prompt": "example (a : Nat) : a = a := by rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rfl",
  "core-prompt": "(a : Nat) : a = a",
  "args": "(a : Nat)"},
 {"type": "a ≈ a",
  "tactic-prompt":
  "example {α : Sort u}  [Setoid α] (a : α) : a ≈ a := by rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rfl",
  "core-prompt": "{α : Sort u}  [Setoid α] (a : α) : a ≈ a",
  "args": "{α : Sort u}  [Setoid α] (a : α)"},
 {"type": "a ≤ a",
  "tactic-prompt":
  "example {α : Sort u}  [Setoid α] (a : Nat) : a ≤ a := by (fail_if_success rfl); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "(fail_if_success rfl)",
  "core-prompt": "{α : Sort u}  [Setoid α] (a : Nat) : a ≤ a",
  "args": "{α : Sort u}  [Setoid α] (a : Nat)"},
 {"type": "a ≤ a",
  "tactic-prompt":
  "example {α : Sort u}  [Setoid α] (a : Nat) : a ≤ a := by rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rfl",
  "core-prompt": "{α : Sort u}  [Setoid α] (a : Nat) : a ≤ a",
  "args": "{α : Sort u}  [Setoid α] (a : Nat)"},
 {"type": "a ≤ a",
  "tactic-prompt":
  "example {α : Sort u}  [Setoid α] (a : Foo) : a ≤ a := by apply Foo.le_refl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply Foo.le_refl",
  "core-prompt": "{α : Sort u}  [Setoid α] (a : Foo) : a ≤ a",
  "args": "{α : Sort u}  [Setoid α] (a : Foo)"},
 {"type": "a ≤ a",
  "tactic-prompt":
  "example {α : Sort u}  [Setoid α] (a : Foo) : a ≤ a := by rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rfl",
  "core-prompt": "{α : Sort u}  [Setoid α] (a : Foo) : a ≤ a",
  "args": "{α : Sort u}  [Setoid α] (a : Foo)"},
 {"type": "(True ∧ (∃ x : Nat, x = x)) ∧ True",
  "tactic-prompt":
  "example  : (True ∧ (∃ x : Nat, x = x)) ∧ True := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : (True ∧ (∃ x : Nat, x = x)) ∧ True",
  "args": ""},
 {"type": "((True ∧ True) ∧ (∃ x : Nat, x = x)) ∧ (True ∧ (∃ x : Nat, x = x))",
  "tactic-prompt":
  "example  : ((True ∧ True) ∧ (∃ x : Nat, x = x)) ∧ (True ∧ (∃ x : Nat, x = x)) := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt":
  " : ((True ∧ True) ∧ (∃ x : Nat, x = x)) ∧ (True ∧ (∃ x : Nat, x = x))",
  "args": ""},
 {"type": "(True ∧ (∃ x : Nat, x = x)) ∧ True",
  "tactic-prompt":
  "example  : (True ∧ (∃ x : Nat, x = x)) ∧ True := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : (True ∧ (∃ x : Nat, x = x)) ∧ True",
  "args": ""},
 {"type": "IsEmpty (α → β)",
  "tactic-prompt":
  "example {α β γ : Sort _} [h : Nonempty α]  [IsEmpty β] : IsEmpty (α → β) := by infer_instance; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{α β γ : Sort _} [h : Nonempty α]  [IsEmpty β] : IsEmpty (α → β)",
  "args": "{α β γ : Sort _} [h : Nonempty α]  [IsEmpty β]"},
 {"type": "IsEmpty p ↔ ¬p",
  "tactic-prompt":
  "theorem {α β γ : Sort _} [IsEmpty α] {p : Prop} : IsEmpty p ↔ ¬p := by simp only [← not_nonempty_iff]; sorry",
  "name": "is_empty_Prop",
  "kind": "theorem",
  "first-tactic": "simp only [← not_nonempty_iff]",
  "core-prompt": "{α β γ : Sort _} [IsEmpty α] {p : Prop} : IsEmpty p ↔ ¬p",
  "args": "{α β γ : Sort _} [IsEmpty α] {p : Prop}"},
 {"type": "IsEmpty (∀ a, π a) ↔ ∃ a, IsEmpty (π a)",
  "tactic-prompt":
  "theorem {α β γ : Sort _} [IsEmpty α] {π : α → Sort _} : IsEmpty (∀ a, π a) ↔ ∃ a, IsEmpty (π a) := by simp only [← not_nonempty_iff]; sorry",
  "name": "is_empty_pi",
  "kind": "theorem",
  "first-tactic": "simp only [← not_nonempty_iff]",
  "core-prompt":
  "{α β γ : Sort _} [IsEmpty α] {π : α → Sort _} : IsEmpty (∀ a, π a) ↔ ∃ a, IsEmpty (π a)",
  "args": "{α β γ : Sort _} [IsEmpty α] {π : α → Sort _}"},
 {"type": "IsEmpty (Subtype p) ↔ ∀ x, ¬p x",
  "tactic-prompt":
  "theorem {α β γ : Sort _} [IsEmpty α] (p : α → Prop) : IsEmpty (Subtype p) ↔ ∀ x, ¬p x := by simp only [← not_nonempty_iff]; sorry",
  "name": "is_empty_subtype",
  "kind": "theorem",
  "first-tactic": "simp only [← not_nonempty_iff]",
  "core-prompt":
  "{α β γ : Sort _} [IsEmpty α] (p : α → Prop) : IsEmpty (Subtype p) ↔ ∀ x, ¬p x",
  "args": "{α β γ : Sort _} [IsEmpty α] (p : α → Prop)"},
 {"type": "IsEmpty (α × β) ↔ IsEmpty α ∨ IsEmpty β",
  "tactic-prompt":
  "theorem {α β γ : Sort _} [IsEmpty α] {α β : Type _} : IsEmpty (α × β) ↔ IsEmpty α ∨ IsEmpty β := by simp only [← not_nonempty_iff]; sorry",
  "name": "is_empty_prod",
  "kind": "theorem",
  "first-tactic": "simp only [← not_nonempty_iff]",
  "core-prompt":
  "{α β γ : Sort _} [IsEmpty α] {α β : Type _} : IsEmpty (α × β) ↔ IsEmpty α ∨ IsEmpty β",
  "args": "{α β γ : Sort _} [IsEmpty α] {α β : Type _}"},
 {"type": "IsEmpty (PProd α β) ↔ IsEmpty α ∨ IsEmpty β",
  "tactic-prompt":
  "theorem {α β γ : Sort _} [IsEmpty α] : IsEmpty (PProd α β) ↔ IsEmpty α ∨ IsEmpty β := by simp only [← not_nonempty_iff]; sorry",
  "name": "is_empty_pprod",
  "kind": "theorem",
  "first-tactic": "simp only [← not_nonempty_iff]",
  "core-prompt":
  "{α β γ : Sort _} [IsEmpty α] : IsEmpty (PProd α β) ↔ IsEmpty α ∨ IsEmpty β",
  "args": "{α β γ : Sort _} [IsEmpty α]"},
 {"type": "HEq f f'",
  "tactic-prompt":
  "lemma {α β γ : Sort _}  {f : α → β} {α α': Sort u}  {β : α → Sort v}  {β' : α' → Sort v}  {f : ∀a, β a}  {f' : ∀a, β' a}    (hα : α = α')  (h : ∀a a', HEq a a' → HEq (f a) (f' a')) : HEq f f' := by subst hα; sorry",
  "name": "hfunext",
  "kind": "lemma",
  "first-tactic": "subst hα",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} {α α': Sort u}  {β : α → Sort v}  {β' : α' → Sort v}  {f : ∀a, β a}  {f' : ∀a, β' a}    (hα : α = α')  (h : ∀a a', HEq a a' → HEq (f a) (f' a')) : HEq f f'",
  "args":
  "{α β γ : Sort _}  {f : α → β} {α α': Sort u}  {β : α → Sort v}  {β' : α' → Sort v}  {f : ∀a, β a}  {f' : ∀a, β' a}    (hα : α = α')  (h : ∀a a', HEq a a' → HEq (f a) (f' a'))"},
 {"type": "Function.Injective (λ x => if h : p x then f ⟨x, h⟩ else f' ⟨x, h⟩)",
  "tactic-prompt":
  "lemma {α β γ : Sort _}  {f : α → β} (p : α → Prop)  [DecidablePred p]    {f : {a : α // p a} → β}  {f' : {a : α // ¬ p a} → β}    (hf : Injective f)  (hf' : Injective f')    (im_disj : ∀ {x x' : α} {hx : p x} {hx' : ¬ p x'}, f ⟨x, hx⟩ ≠ f' ⟨x', hx'⟩) : Function.Injective (λ x => if h : p x then f ⟨x, h⟩ else f' ⟨x, h⟩) := by intros x₁ x₂ h; sorry",
  "name": "Injective.dite",
  "kind": "lemma",
  "first-tactic": "intros x₁ x₂ h",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} (p : α → Prop)  [DecidablePred p]    {f : {a : α // p a} → β}  {f' : {a : α // ¬ p a} → β}    (hf : Injective f)  (hf' : Injective f')    (im_disj : ∀ {x x' : α} {hx : p x} {hx' : ¬ p x'}, f ⟨x, hx⟩ ≠ f' ⟨x', hx'⟩) : Function.Injective (λ x => if h : p x then f ⟨x, h⟩ else f' ⟨x, h⟩)",
  "args":
  "{α β γ : Sort _}  {f : α → β} (p : α → Prop)  [DecidablePred p]    {f : {a : α // p a} → β}  {f' : {a : α // ¬ p a} → β}    (hf : Injective f)  (hf' : Injective f')    (im_disj : ∀ {x x' : α} {hx : p x} {hx' : ¬ p x'}, f ⟨x, hx⟩ ≠ f' ⟨x', hx'⟩)"},
 {"type": "g₁ = g₂",
  "tactic-prompt":
  "theorem {α β γ : Sort _}  {f : α → β} {f : α → β}  {g₁ g₂ : β → α}  (h₁ : LeftInverse g₁ f)    (h₂ : Function.RightInverse g₂ f) : g₁ = g₂ := by have h₃ : g₁ = g₁ ∘ f ∘ g₂ := by rw [h₂.comp_eq_id]; sorry",
  "name": "LeftInverse.eq_RightInverse",
  "kind": "theorem",
  "first-tactic": "have h₃ : g₁ = g₁ ∘ f ∘ g₂ := by rw [h₂.comp_eq_id]",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} {f : α → β}  {g₁ g₂ : β → α}  (h₁ : LeftInverse g₁ f)    (h₂ : Function.RightInverse g₂ f) : g₁ = g₂",
  "args":
  "{α β γ : Sort _}  {f : α → β} {f : α → β}  {g₁ g₂ : β → α}  (h₁ : LeftInverse g₁ f)    (h₂ : Function.RightInverse g₂ f)"},
 {"type": "inv_fun_on f s b ∈ s ∧ f (inv_fun_on f s b) = b",
  "tactic-prompt":
  "theorem {α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ∃a∈s, f a = b) : inv_fun_on f s b ∈ s ∧ f (inv_fun_on f s b) = b := by have h1 : inv_fun_on f s b =\n     if h : ∃a, a ∈ s ∧ f a = b then Classical.choose h else Classical.choice n := rfl; sorry",
  "name": "inv_fun_on_pos",
  "kind": "theorem",
  "first-tactic":
  "have h1 : inv_fun_on f s b =\n     if h : ∃a, a ∈ s ∧ f a = b then Classical.choose h else Classical.choice n := rfl",
  "core-prompt":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ∃a∈s, f a = b) : inv_fun_on f s b ∈ s ∧ f (inv_fun_on f s b) = b",
  "args":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ∃a∈s, f a = b)"},
 {"type": "inv_fun_on f s b = Classical.choice n",
  "tactic-prompt":
  "theorem {α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃a∈s, f a = b) : inv_fun_on f s b = Classical.choice n := by have h1 : inv_fun_on f s b =\n     if h : ∃a, a ∈ s ∧ f a = b then Classical.choose h else Classical.choice n := rfl; sorry",
  "name": "inv_fun_on_neg",
  "kind": "theorem",
  "first-tactic":
  "have h1 : inv_fun_on f s b =\n     if h : ∃a, a ∈ s ∧ f a = b then Classical.choose h else Classical.choice n := rfl",
  "core-prompt":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃a∈s, f a = b) : inv_fun_on f s b = Classical.choice n",
  "args":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃a∈s, f a = b)"},
 {"type": "inv_fun f b = Classical.choice n",
  "tactic-prompt":
  "lemma {α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃ a, f a = b) : inv_fun f b = Classical.choice n := by refine inv_fun_on_neg (mt ?_ h); sorry",
  "name": "inv_fun_neg",
  "kind": "lemma",
  "first-tactic": "refine inv_fun_on_neg (mt ?_ h)",
  "core-prompt":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃ a, f a = b) : inv_fun f b = Classical.choice n",
  "args":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃ a, f a = b)"},
 {"type": "update f a' b a = if a = a' then b else f a",
  "tactic-prompt":
  "lemma {α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {β : Sort _}  (f : α → β)  (a' : α)  (b : β)  (a : α) : update f a' b a = if a = a' then b else f a := by have h2 : (h : a = a') → Eq.rec (motive := λ _ _ => β) b h.symm = b :=\n     by intro h\n        rw [eq_rec_constant]; sorry",
  "name": "update_apply",
  "kind": "lemma",
  "first-tactic":
  "have h2 : (h : a = a') → Eq.rec (motive := λ _ _ => β) b h.symm = b :=\n     by intro h\n        rw [eq_rec_constant]",
  "core-prompt":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {β : Sort _}  (f : α → β)  (a' : α)  (b : β)  (a : α) : update f a' b a = if a = a' then b else f a",
  "args":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {β : Sort _}  (f : α → β)  (a' : α)  (b : β)  (a : α)"},
 {"type": "Injective (update f a')",
  "tactic-prompt":
  "lemma {α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] (f : ∀a, β a)  (a' : α) : Injective (update f a') := by intros v v' h; sorry",
  "name": "update_injective",
  "kind": "lemma",
  "first-tactic": "intros v v' h",
  "core-prompt":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] (f : ∀a, β a)  (a' : α) : Injective (update f a')",
  "args":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] (f : ∀a, β a)  (a' : α)"},
 {"type": "f j (update g i v j) = update (λ k => f k (g k)) i (f i v) j",
  "tactic-prompt":
  "lemma {α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {ι : Sort _}  [DecidableEq ι]  {α β : ι → Sort _}    (f : ∀i, α i → β i)  (g : ∀i, α i)  (i : ι)  (v : α i)  (j : ι) : f j (update g i v j) = update (λ k => f k (g k)) i (f i v) j := by by_cases h : j = i; sorry",
  "name": "apply_update",
  "kind": "lemma",
  "first-tactic": "by_cases h : j = i",
  "core-prompt":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {ι : Sort _}  [DecidableEq ι]  {α β : ι → Sort _}    (f : ∀i, α i → β i)  (g : ∀i, α i)  (i : ι)  (v : α i)  (j : ι) : f j (update g i v j) = update (λ k => f k (g k)) i (f i v) j",
  "args":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {ι : Sort _}  [DecidableEq ι]  {α β : ι → Sort _}    (f : ∀i, α i → β i)  (g : ∀i, α i)  (i : ι)  (v : α i)  (j : ι)"},
 {"type":
  "extend f g e' b = if h : ∃ a, f a = b then g (Classical.choose h) else e' b",
  "tactic-prompt":
  "lemma {α β γ : Type _}  {f : α → β} (f : α → β)  (g : α → γ)  (e' : β → γ)  (b : β)  [hd : Decidable (∃ a, f a = b)] : extend f g e' b = if h : ∃ a, f a = b then g (Classical.choose h) else e' b := by rw [Subsingleton.elim hd]; sorry",
  "name": "extend_def",
  "kind": "lemma",
  "first-tactic": "rw [Subsingleton.elim hd]",
  "core-prompt":
  "{α β γ : Type _}  {f : α → β} (f : α → β)  (g : α → γ)  (e' : β → γ)  (b : β)  [hd : Decidable (∃ a, f a = b)] : extend f g e' b = if h : ∃ a, f a = b then g (Classical.choose h) else e' b",
  "args":
  "{α β γ : Type _}  {f : α → β} (f : α → β)  (g : α → γ)  (e' : β → γ)  (b : β)  [hd : Decidable (∃ a, f a = b)]"},
 {"type": "extend f g e' (f a) = g a",
  "tactic-prompt":
  "lemma {α β γ : Type _}  {f : α → β} (hf : Injective f)  (g : α → γ)  (e' : β → γ)  (a : α) : extend f g e' (f a) = g a := by simp only [extend_def]; sorry",
  "name": "extend_apply",
  "kind": "lemma",
  "first-tactic": "simp only [extend_def]",
  "core-prompt":
  "{α β γ : Type _}  {f : α → β} (hf : Injective f)  (g : α → γ)  (e' : β → γ)  (a : α) : extend f g e' (f a) = g a",
  "args":
  "{α β γ : Type _}  {f : α → β} (hf : Injective f)  (g : α → γ)  (e' : β → γ)  (a : α)"},
 {"type": "extend f g e' b = e' b",
  "tactic-prompt":
  "theorem {α β γ : Type _}  {f : α → β} (g : α → γ)  (e' : β → γ)  (b : β)  (hb : ¬∃ a, f a = b) : extend f g e' b = e' b := by simp [Function.extend_def]; sorry",
  "name": "extend_apply'",
  "kind": "theorem",
  "first-tactic": "simp [Function.extend_def]",
  "core-prompt":
  "{α β γ : Type _}  {f : α → β} (g : α → γ)  (e' : β → γ)  (b : β)  (hb : ¬∃ a, f a = b) : extend f g e' b = e' b",
  "args":
  "{α β γ : Type _}  {f : α → β} (g : α → γ)  (e' : β → γ)  (b : β)  (hb : ¬∃ a, f a = b)"},
 {"type": "uncurry (bicompl f g h) = (uncurry f) ∘ (Prod.map g h)",
  "tactic-prompt":
  "lemma {α β γ δ ε : Type _} (f : γ → δ → ε)  (g : α → γ)  (h : β → δ) : uncurry (bicompl f g h) = (uncurry f) ∘ (Prod.map g h) := by ext ⟨x, y⟩; sorry",
  "name": "uncurry_bicompl",
  "kind": "lemma",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "{α β γ δ ε : Type _} (f : γ → δ → ε)  (g : α → γ)  (h : β → δ) : uncurry (bicompl f g h) = (uncurry f) ∘ (Prod.map g h)",
  "args": "{α β γ δ ε : Type _} (f : γ → δ → ε)  (g : α → γ)  (h : β → δ)"},
 {"type": "f (ite P x (f x)) = ite (¬ P) x (f x)",
  "tactic-prompt":
  "lemma {α : Sort u}  {f : α → α}  (h : Involutive f) (P : Prop)  [Decidable P]  (x : α) : f (ite P x (f x)) = ite (¬ P) x (f x) := by rw [apply_ite f]; sorry",
  "name": "ite_not",
  "kind": "lemma",
  "first-tactic": "rw [apply_ite f]",
  "core-prompt":
  "{α : Sort u}  {f : α → α}  (h : Involutive f) (P : Prop)  [Decidable P]  (x : α) : f (ite P x (f x)) = ite (¬ P) x (f x)",
  "args":
  "{α : Sort u}  {f : α → α}  (h : Involutive f) (P : Prop)  [Decidable P]  (x : α)"},
 {"type": "f x = g y",
  "tactic-prompt":
  "theorem {α β γ : Sort _}  {f : α → γ}  {g : β → γ}  {x : α}  {y : β}      (h₁ : HEq f g)  (h₂ : HEq x y) : f x = g y := by cases h₂; sorry",
  "name": "congr_heq",
  "kind": "theorem",
  "first-tactic": "cases h₂",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → γ}  {g : β → γ}  {x : α}  {y : β}      (h₁ : HEq f g)  (h₂ : HEq x y) : f x = g y",
  "args":
  "{α β γ : Sort _}  {f : α → γ}  {g : β → γ}  {x : α}  {y : β}      (h₁ : HEq f g)  (h₂ : HEq x y)"},
 {"type": "Eq True = id",
  "tactic-prompt": "theorem  : Eq True = id := by funext _; sorry",
  "name": "eq_true_eq_id",
  "kind": "theorem",
  "first-tactic": "funext _",
  "core-prompt": " : Eq True = id",
  "args": ""},
 {"type": "Xor' True = Not",
  "tactic-prompt": "theorem  : Xor' True = Not := by simp [Xor']; sorry",
  "name": "xor_true",
  "kind": "theorem",
  "first-tactic": "simp [Xor']",
  "core-prompt": " : Xor' True = Not",
  "args": ""},
 {"type": "Xor' False = id",
  "tactic-prompt": "theorem  : Xor' False = id := by ext; sorry",
  "name": "xor_false",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt": " : Xor' False = id",
  "args": ""},
 {"type": "Xor' a a = False",
  "tactic-prompt":
  "theorem (a : Prop) : Xor' a a = False := by simp [Xor']; sorry",
  "name": "xor_self",
  "kind": "theorem",
  "first-tactic": "simp [Xor']",
  "core-prompt": "(a : Prop) : Xor' a a = False",
  "args": "(a : Prop)"},
 {"type": "p ∧ a = b ↔ p ∧ b = a",
  "tactic-prompt":
  "theorem (a b : α)  (p : Prop) : p ∧ a = b ↔ p ∧ b = a := by simp [eq_comm]; sorry",
  "name": "and_symm_right",
  "kind": "theorem",
  "first-tactic": "simp [eq_comm]",
  "core-prompt": "(a b : α)  (p : Prop) : p ∧ a = b ↔ p ∧ b = a",
  "args": "(a b : α)  (p : Prop)"},
 {"type": "a = b ∧ p ↔ b = a ∧ p",
  "tactic-prompt":
  "theorem (a b : α)  (p : Prop) : a = b ∧ p ↔ b = a ∧ p := by simp [eq_comm]; sorry",
  "name": "and_symm_left",
  "kind": "theorem",
  "first-tactic": "simp [eq_comm]",
  "core-prompt": "(a b : α)  (p : Prop) : a = b ∧ p ↔ b = a ∧ p",
  "args": "(a b : α)  (p : Prop)"},
 {"type": "¬Xor' P Q ↔ (P ↔ Q)",
  "tactic-prompt":
  "theorem (P Q : Prop) : ¬Xor' P Q ↔ (P ↔ Q) := by simp only [not_and]; sorry",
  "name": "not_xor",
  "kind": "theorem",
  "first-tactic": "simp only [not_and]",
  "core-prompt": "(P Q : Prop) : ¬Xor' P Q ↔ (P ↔ Q)",
  "args": "(P Q : Prop)"},
 {"type": "Xor' P Q ↔ ¬(P ↔ Q)",
  "tactic-prompt":
  "theorem (P Q : Prop) : Xor' P Q ↔ ¬(P ↔ Q) := by rw [iff_not_comm]; sorry",
  "name": "xor_iff_not_iff",
  "kind": "theorem",
  "first-tactic": "rw [iff_not_comm]",
  "core-prompt": "(P Q : Prop) : Xor' P Q ↔ ¬(P ↔ Q)",
  "args": "(P Q : Prop)"},
 {"type": "HEq (@Eq.ndrec α a C x b e) y",
  "tactic-prompt":
  "theorem {C : α → Sort _}  {x : C a}  {y : β}  (e : a = b)  (h : HEq x y) : HEq (@Eq.ndrec α a C x b e) y := by subst e; sorry",
  "name": "rec_heq_of_heq",
  "kind": "theorem",
  "first-tactic": "subst e",
  "core-prompt":
  "{C : α → Sort _}  {x : C a}  {y : β}  (e : a = b)  (h : HEq x y) : HEq (@Eq.ndrec α a C x b e) y",
  "args": "{C : α → Sort _}  {x : C a}  {y : β}  (e : a = b)  (h : HEq x y)"},
 {"type": "x₁ = x₂ ↔ y₁ = y₂",
  "tactic-prompt":
  "theorem (h₁ : x₁ = y₁)  (h₂ : x₂ = y₂) : x₁ = x₂ ↔ y₁ = y₂ := by subst h₁; sorry",
  "name": "Eq.congr",
  "kind": "theorem",
  "first-tactic": "subst h₁",
  "core-prompt": "(h₁ : x₁ = y₁)  (h₂ : x₂ = y₂) : x₁ = x₂ ↔ y₁ = y₂",
  "args": "(h₁ : x₁ = y₁)  (h₂ : x₂ = y₂)"},
 {"type": "x = z ↔ y = z",
  "tactic-prompt":
  "theorem {x y z : α}  (h : x = y) : x = z ↔ y = z := by rw [h]; sorry",
  "name": "Eq.congr_left",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{x y z : α}  (h : x = y) : x = z ↔ y = z",
  "args": "{x y z : α}  (h : x = y)"},
 {"type": "z = x ↔ z = y",
  "tactic-prompt":
  "theorem {x y z : α}  (h : x = y) : z = x ↔ z = y := by rw [h]; sorry",
  "name": "Eq.congr_right",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{x y z : α}  (h : x = y) : z = x ↔ z = y",
  "args": "{x y z : α}  (h : x = y)"},
 {"type": "(¬∃ x, ¬p x) ↔ ∀ x, p x",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} [∀ x, Decidable (p x)] : (¬∃ x, ¬p x) ↔ ∀ x, p x := by simp only [not_exists]; sorry",
  "name": "Decidable.not_exists_not",
  "kind": "theorem",
  "first-tactic": "simp only [not_exists]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} [∀ x, Decidable (p x)] : (¬∃ x, ¬p x) ↔ ∀ x, p x",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} [∀ x, Decidable (p x)]"},
 {"type": "(∀ x, p x) → b ↔ ∃ x, p x → b",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} [ha : Nonempty α] : (∀ x, p x) → b ↔ ∃ x, p x → b := by let ⟨a⟩ := ha; sorry",
  "name": "forall_imp_iff_exists_imp",
  "kind": "theorem",
  "first-tactic": "let ⟨a⟩ := ha",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} [ha : Nonempty α] : (∀ x, p x) → b ↔ ∃ x, p x → b",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} [ha : Nonempty α]"},
 {"type": "(∀ a, β a → True) ↔ True",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {β : α → Sort _} : (∀ a, β a → True) ↔ True := by simp; sorry",
  "name": "forall₂_true_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {β : α → Sort _} : (∀ a, β a → True) ↔ True",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {β : α → Sort _}"},
 {"type": "(∀ (a) (b : β a), γ a b → True) ↔ True",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {β : α → Sort _}  {γ : ∀ a, β a → Sort _} : (∀ (a) (b : β a), γ a b → True) ↔ True := by simp; sorry",
  "name": "forall₃_true_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {β : α → Sort _}  {γ : ∀ a, β a → Sort _} : (∀ (a) (b : β a), γ a b → True) ↔ True",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {β : α → Sort _}  {γ : ∀ a, β a → Sort _}"},
 {"type": "(p a ∧ ∀ (b) (_ : b ≠ a), p b) ↔ ∀ b, p b",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} (a : α) : (p a ∧ ∀ (b) (_ : b ≠ a), p b) ↔ ∀ b, p b := by simp only [← @forall_eq _ p a]; sorry",
  "name": "and_forall_ne",
  "kind": "theorem",
  "first-tactic": "simp only [← @forall_eq _ p a]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} (a : α) : (p a ∧ ∀ (b) (_ : b ≠ a), p b) ↔ ∀ b, p b",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} (a : α)"},
 {"type": "∃! a, a = a'",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α} : ∃! a, a = a' := by simp only [eq_comm]; sorry",
  "name": "exists_unique_eq",
  "kind": "theorem",
  "first-tactic": "simp only [eq_comm]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α} : ∃! a, a = a'",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α}"},
 {"type": "∃! a, a' = a",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α} : ∃! a, a' = a := by simp only [ExistsUnique]; sorry",
  "name": "exists_unique_eq'",
  "kind": "theorem",
  "first-tactic": "simp only [ExistsUnique]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α} : ∃! a, a' = a",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α}"},
 {"type": "(∀ a b, f a = b → p b) ↔ ∀ a, p (f a)",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop} : (∀ a b, f a = b → p b) ↔ ∀ a, p (f a) := by simp; sorry",
  "name": "forall_apply_eq_imp_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop} : (∀ a b, f a = b → p b) ↔ ∀ a, p (f a)",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop}"},
 {"type": "(∀ b a, f a = b → p b) ↔ ∀ a, p (f a)",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop} : (∀ b a, f a = b → p b) ↔ ∀ a, p (f a) := by simp [forall_swap]; sorry",
  "name": "forall_apply_eq_imp_iff'",
  "kind": "theorem",
  "first-tactic": "simp [forall_swap]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop} : (∀ b a, f a = b → p b) ↔ ∀ a, p (f a)",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop}"},
 {"type": "(∀ a b, b = f a → p b) ↔ ∀ a, p (f a)",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop} : (∀ a b, b = f a → p b) ↔ ∀ a, p (f a) := by simp; sorry",
  "name": "forall_eq_apply_imp_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop} : (∀ a b, b = f a → p b) ↔ ∀ a, p (f a)",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop}"},
 {"type": "(∀ b a, b = f a → p b) ↔ ∀ a, p (f a)",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop} : (∀ b a, b = f a → p b) ↔ ∀ a, p (f a) := by simp [forall_swap]; sorry",
  "name": "forall_eq_apply_imp_iff'",
  "kind": "theorem",
  "first-tactic": "simp [forall_swap]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop} : (∀ b a, b = f a → p b) ↔ ∀ a, p (f a)",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {f : α → β}  {p : β → Prop}"},
 {"type": "(∃ a, p a ∧ a' = a) ↔ p a'",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α} : (∃ a, p a ∧ a' = a) ↔ p a' := by simp [@eq_comm _ a']; sorry",
  "name": "exists_eq_right'",
  "kind": "theorem",
  "first-tactic": "simp [@eq_comm _ a']",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α} : (∃ a, p a ∧ a' = a) ↔ p a'",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {a' : α}"},
 {"type": "(∃ i₁ j₁ i₂ j₂, p i₁ j₁ i₂ j₂) ↔ ∃ i₂ j₂ i₁ j₁, p i₁ j₁ i₂ j₂",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {κ₁ : ι₁ → Sort _}  {κ₂ : ι₂ → Sort _}  {p : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → Prop} : (∃ i₁ j₁ i₂ j₂, p i₁ j₁ i₂ j₂) ↔ ∃ i₂ j₂ i₁ j₁, p i₁ j₁ i₂ j₂ := by simp only [@exists_comm (κ₁ _)]; sorry",
  "name": "exists₂_comm",
  "kind": "theorem",
  "first-tactic": "simp only [@exists_comm (κ₁ _)]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {κ₁ : ι₁ → Sort _}  {κ₂ : ι₂ → Sort _}  {p : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → Prop} : (∃ i₁ j₁ i₂ j₂, p i₁ j₁ i₂ j₂) ↔ ∃ i₂ j₂ i₁ j₁, p i₁ j₁ i₂ j₂",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {κ₁ : ι₁ → Sort _}  {κ₂ : ι₂ → Sort _}  {p : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → Prop}"},
 {"type": "(∃! _ : p, q) ↔ p ∧ q",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {p q : Prop} : (∃! _ : p, q) ↔ p ∧ q := by simp; sorry",
  "name": "exists_unique_prop",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {p q : Prop} : (∃! _ : p, q) ↔ p ∧ q",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {p q : Prop}"},
 {"type": "b",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x) (_ : p x), Prop}  {b : Prop}  (h₂ : ∃! (x : _) (h : p x), q x h)      (h₁ : ∀ (x) (h : p x), q x h → (∀ (y) (hy : p y), q y hy → y = x) → b) : b := by simp only [exists_unique_iff_exists] at h₂; sorry",
  "name": "ExistsUnique.elim₂",
  "kind": "theorem",
  "first-tactic": "simp only [exists_unique_iff_exists] at h₂",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x) (_ : p x), Prop}  {b : Prop}  (h₂ : ∃! (x : _) (h : p x), q x h)      (h₁ : ∀ (x) (h : p x), q x h → (∀ (y) (hy : p y), q y hy → y = x) → b) : b",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x) (_ : p x), Prop}  {b : Prop}  (h₂ : ∃! (x : _) (h : p x), q x h)      (h₁ : ∀ (x) (h : p x), q x h → (∀ (y) (hy : p y), q y hy → y = x) → b)"},
 {"type": "∃! (x : _) (hx : p x), q x hx",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x : α) (_ : p x), Prop}  (w : α)  (hp : p w)  (hq : q w hp)      (H : ∀ (y) (hy : p y), q y hy → y = w) : ∃! (x : _) (hx : p x), q x hx := by simp only [exists_unique_iff_exists]; sorry",
  "name": "ExistsUnique.intro2",
  "kind": "theorem",
  "first-tactic": "simp only [exists_unique_iff_exists]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x : α) (_ : p x), Prop}  (w : α)  (hp : p w)  (hq : q w hp)      (H : ∀ (y) (hy : p y), q y hy → y = w) : ∃! (x : _) (hx : p x), q x hx",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x : α) (_ : p x), Prop}  (w : α)  (hp : p w)  (hq : q w hp)      (H : ∀ (y) (hy : p y), q y hy → y = w)"},
 {"type": "y₁ = y₂",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x : α) (_ : p x), Prop}  (h : ∃! (x : _) (hx : p x), q x hx)  {y₁ y₂ : α}      (hpy₁ : p y₁)  (hqy₁ : q y₁ hpy₁)  (hpy₂ : p y₂)  (hqy₂ : q y₂ hpy₂) : y₁ = y₂ := by simp only [exists_unique_iff_exists] at h; sorry",
  "name": "ExistsUnique.unique2",
  "kind": "theorem",
  "first-tactic": "simp only [exists_unique_iff_exists] at h",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x : α) (_ : p x), Prop}  (h : ∃! (x : _) (hx : p x), q x hx)  {y₁ y₂ : α}      (hpy₁ : p y₁)  (hqy₁ : q y₁ hpy₁)  (hpy₂ : p y₂)  (hqy₂ : q y₂ hpy₂) : y₁ = y₂",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _}  {κ : ι → Sort _}  {p q : α → Prop} {α : Sort _}  {p : α → Sort _}  [∀ x, Subsingleton (p x)]      {q : ∀ (x : α) (_ : p x), Prop}  (h : ∃! (x : _) (hx : p x), q x hx)  {y₁ y₂ : α}      (hpy₁ : p y₁)  (hqy₁ : q y₁ hpy₁)  (hpy₂ : p y₂)  (hqy₂ : q y₂ hpy₂)"},
 {"type": "Decidable p",
  "tactic-prompt":
  "def {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Prop) : Decidable p := by infer_instance; sorry",
  "name": "dec",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Prop) : Decidable p",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Prop)"},
 {"type": "DecidablePred p",
  "tactic-prompt":
  "def {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : α → Prop) : DecidablePred p := by infer_instance; sorry",
  "name": "decPred",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : α → Prop) : DecidablePred p",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : α → Prop)"},
 {"type": "DecidableRel p",
  "tactic-prompt":
  "def {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : α → α → Prop) : DecidableRel p := by infer_instance; sorry",
  "name": "decRel",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : α → α → Prop) : DecidableRel p",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : α → α → Prop)"},
 {"type": "DecidableEq α",
  "tactic-prompt":
  "def {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (α : Sort _) : DecidableEq α := by infer_instance; sorry",
  "name": "decEq",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (α : Sort _) : DecidableEq α",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open. (α : Sort _)"},
 {"type": "(∃ (x : _) (_ : x = a), p x) ↔ p a",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop} {a : α} : (∃ (x : _) (_ : x = a), p x) ↔ p a := by simp only [exists_prop]; sorry",
  "name": "bex_eq_left",
  "kind": "theorem",
  "first-tactic": "simp only [exists_prop]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop} {a : α} : (∃ (x : _) (_ : x = a), p x) ↔ p a",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop} {a : α}"},
 {"type": "(∃ x h, P x h) → b ↔ ∀ x h, P x h → b",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop} : (∃ x h, P x h) → b ↔ ∀ x h, P x h → b := by simp; sorry",
  "name": "bex_imp",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop} : (∃ x h, P x h) → b ↔ ∀ x h, P x h → b",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop}"},
 {"type":
  "(∃ (x : _) (_ : p x ∨ q x), r x) ↔ (∃ (x : _) (_ : p x), r x) ∨ ∃ (x : _) (_ : q x), r x",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop} : (∃ (x : _) (_ : p x ∨ q x), r x) ↔ (∃ (x : _) (_ : p x), r x) ∨ ∃ (x : _) (_ : q x), r x := by simp only [exists_prop]; sorry",
  "name": "bex_or_left",
  "kind": "theorem",
  "first-tactic": "simp only [exists_prop]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop} : (∃ (x : _) (_ : p x ∨ q x), r x) ↔ (∃ (x : _) (_ : p x), r x) ∨ ∃ (x : _) (_ : q x), r x",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : α → Prop}  {P Q : ∀ x, p x → Prop}  {b : Prop}"},
 {"type": "dite P A B = c ↔ (∃ h, A h = c) ∨ ∃ h, B h = c",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : dite P A B = c ↔ (∃ h, A h = c) ∨ ∃ h, B h = c := by by_cases P; sorry",
  "name": "dite_eq_iff",
  "kind": "theorem",
  "first-tactic": "by_cases P",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : dite P A B = c ↔ (∃ h, A h = c) ∨ ∃ h, B h = c",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α}"},
 {"type": "dite P (fun _ => a) B = a ↔ ∀ h, B h = a",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : dite P (fun _ => a) B = a ↔ ∀ h, B h = a := by by_cases P; sorry",
  "name": "dite_eq_left_iff",
  "kind": "theorem",
  "first-tactic": "by_cases P",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : dite P (fun _ => a) B = a ↔ ∀ h, B h = a",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α}"},
 {"type": "(dite P A fun _ => b) = b ↔ ∀ h, A h = b",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : (dite P A fun _ => b) = b ↔ ∀ h, A h = b := by by_cases P; sorry",
  "name": "dite_eq_right_iff",
  "kind": "theorem",
  "first-tactic": "by_cases P",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : (dite P A fun _ => b) = b ↔ ∀ h, A h = b",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α}"},
 {"type": "dite P (fun _ => a) B ≠ a ↔ ∃ h, a ≠ B h",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : dite P (fun _ => a) B ≠ a ↔ ∃ h, a ≠ B h := by rw [Ne.def]; sorry",
  "name": "dite_ne_left_iff",
  "kind": "theorem",
  "first-tactic": "rw [Ne.def]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : dite P (fun _ => a) B ≠ a ↔ ∃ h, a ≠ B h",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α}"},
 {"type": "(dite P A fun _ => b) ≠ b ↔ ∃ h, A h ≠ b",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : (dite P A fun _ => b) ≠ b ↔ ∃ h, A h ≠ b := by simp only [Ne.def]; sorry",
  "name": "dite_ne_right_iff",
  "kind": "theorem",
  "first-tactic": "simp only [Ne.def]",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : (dite P A fun _ => b) ≠ b ↔ ∃ h, A h ≠ b",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α}"},
 {"type":
  "f (dite P a b) (dite P c d) = dite P (fun h => f (a h) (c h)) fun h => f (b h) (d h)",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} (f : α → β → γ)  (P : Prop)  [Decidable P]  (a : P → α)  (b : ¬P → α)      (c : P → β)  (d : ¬P → β) : f (dite P a b) (dite P c d) = dite P (fun h => f (a h) (c h)) fun h => f (b h) (d h) := by by_cases h : P; sorry",
  "name": "apply_dite₂",
  "kind": "theorem",
  "first-tactic": "by_cases h : P",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} (f : α → β → γ)  (P : Prop)  [Decidable P]  (a : P → α)  (b : ¬P → α)      (c : P → β)  (d : ¬P → β) : f (dite P a b) (dite P c d) = dite P (fun h => f (a h) (c h)) fun h => f (b h) (d h)",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} (f : α → β → γ)  (P : Prop)  [Decidable P]  (a : P → α)  (b : ¬P → α)      (c : P → β)  (d : ¬P → β)"},
 {"type": "(dite P f g) a = dite P (fun h => f h a) fun h => g h a",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} (f : P → ∀ a, σ a)  (g : ¬P → ∀ a, σ a)  (a : α) : (dite P f g) a = dite P (fun h => f h a) fun h => g h a := by by_cases h:P; sorry",
  "name": "dite_apply",
  "kind": "theorem",
  "first-tactic": "by_cases h:P",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} (f : P → ∀ a, σ a)  (g : ¬P → ∀ a, σ a)  (a : α) : (dite P f g) a = dite P (fun h => f h a) fun h => g h a",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} (f : P → ∀ a, σ a)  (g : ¬P → ∀ a, σ a)  (a : α)"},
 {"type": "ite (P ∧ Q) a b = ite P (ite Q a b) b",
  "tactic-prompt":
  "theorem {β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : ite (P ∧ Q) a b = ite P (ite Q a b) b := by by_cases hp : P; sorry",
  "name": "ite_and",
  "kind": "theorem",
  "first-tactic": "by_cases hp : P",
  "core-prompt":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α} : ite (P ∧ Q) a b = ite P (ite Q a b) b",
  "args":
  "{β : α → Sort _}  {γ : ∀ a, β a → Sort _}  {δ : ∀ a b, γ a b → Sort _} {p : α → Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {σ : α → Sort _}  (f : α → β)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : α}  {A : P → α}  {B : ¬P → α}"},
 {"type": "decide True = true",
  "tactic-prompt":
  "theorem {a b c d : Prop} (h : Decidable True) : decide True = true := by simp; sorry",
  "name": "decide_True'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "{a b c d : Prop} (h : Decidable True) : decide True = true",
  "args": "{a b c d : Prop} (h : Decidable True)"},
 {"type": "decide False = false",
  "tactic-prompt":
  "theorem {a b c d : Prop} (h : Decidable False) : decide False = false := by simp; sorry",
  "name": "decide_False'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{a b c d : Prop} (h : Decidable False) : decide False = false",
  "args": "{a b c d : Prop} (h : Decidable False)"},
 {"type": "t",
  "tactic-prompt":
  "theorem {a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hc : c) : t := by have := if_pos hc ▸ h; sorry",
  "name": "imp_of_if_pos",
  "kind": "theorem",
  "first-tactic": "have := if_pos hc ▸ h",
  "core-prompt":
  "{a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hc : c) : t",
  "args":
  "{a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hc : c)"},
 {"type": "e",
  "tactic-prompt":
  "theorem {a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hnc : ¬c) : e := by have := if_neg hnc ▸ h; sorry",
  "name": "imp_of_if_neg",
  "kind": "theorem",
  "first-tactic": "have := if_neg hnc ▸ h",
  "core-prompt":
  "{a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hnc : ¬c) : e",
  "args":
  "{a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hnc : ¬c)"},
 {"type": "HEq (let x : α := a₁; b x) (let x : α := a₂; b x)",
  "tactic-prompt":
  "theorem {a b c d : Prop} {α : Sort v}  {β : α → Sort u}  {a₁ a₂ : α}  (b : ∀ x : α, β x)      (h : a₁ = a₂) : HEq (let x : α := a₁; b x) (let x : α := a₂; b x) := by cases h; sorry",
  "name": "let_value_heq",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{a b c d : Prop} {α : Sort v}  {β : α → Sort u}  {a₁ a₂ : α}  (b : ∀ x : α, β x)      (h : a₁ = a₂) : HEq (let x : α := a₁; b x) (let x : α := a₂; b x)",
  "args":
  "{a b c d : Prop} {α : Sort v}  {β : α → Sort u}  {a₁ a₂ : α}  (b : ∀ x : α, β x)      (h : a₁ = a₂)"},
 {"type": "(let x : α := a; b₁ x) = (let x : α := a; b₂ x)",
  "tactic-prompt":
  "theorem {a b c d : Prop} {α : Sort v}  {β : α → Sort u}  (a : α)  {b₁ b₂ : ∀ x : α, β x}      (h : ∀ x, b₁ x = b₂ x) : (let x : α := a; b₁ x) = (let x : α := a; b₂ x) := by exact h _ ▸ rfl; sorry",
  "name": "let_body_eq",
  "kind": "theorem",
  "first-tactic": "exact h _ ▸ rfl",
  "core-prompt":
  "{a b c d : Prop} {α : Sort v}  {β : α → Sort u}  (a : α)  {b₁ b₂ : ∀ x : α, β x}      (h : ∀ x, b₁ x = b₂ x) : (let x : α := a; b₁ x) = (let x : α := a; b₂ x)",
  "args":
  "{a b c d : Prop} {α : Sort v}  {β : α → Sort u}  (a : α)  {b₁ b₂ : ∀ x : α, β x}      (h : ∀ x, b₁ x = b₂ x)"},
 {"type": "(let x : α := a₁; b₁ x) = (let x : α := a₂; b₂ x)",
  "tactic-prompt":
  "theorem {a b c d : Prop} {α : Sort v}  {β : Sort u}  {a₁ a₂ : α}  {b₁ b₂ : α → β}      (h₁ : a₁ = a₂)  (h₂ : ∀ x, b₁ x = b₂ x) : (let x : α := a₁; b₁ x) = (let x : α := a₂; b₂ x) := by simp [h₁]; sorry",
  "name": "let_eq",
  "kind": "theorem",
  "first-tactic": "simp [h₁]",
  "core-prompt":
  "{a b c d : Prop} {α : Sort v}  {β : Sort u}  {a₁ a₂ : α}  {b₁ b₂ : α → β}      (h₁ : a₁ = a₂)  (h₂ : ∀ x, b₁ x = b₂ x) : (let x : α := a₁; b₁ x) = (let x : α := a₂; b₂ x)",
  "args":
  "{a b c d : Prop} {α : Sort v}  {β : Sort u}  {a₁ a₂ : α}  {b₁ b₂ : α → β}      (h₁ : a₁ = a₂)  (h₂ : ∀ x, b₁ x = b₂ x)"},
 {"type": "min a b ≤ a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a b : α) : min a b ≤ a := by if h : a ≤ b\n  then simp [min_def]; sorry",
  "name": "min_le_left",
  "kind": "lemma",
  "first-tactic": "if h : a ≤ b\n  then simp [min_def]",
  "core-prompt": "{α : Type u}  [LinearOrder α] (a b : α) : min a b ≤ a",
  "args": "{α : Type u}  [LinearOrder α] (a b : α)"},
 {"type": "min a b ≤ b",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a b : α) : min a b ≤ b := by if h : a ≤ b\n  then simp [min_def]; sorry",
  "name": "min_le_right",
  "kind": "lemma",
  "first-tactic": "if h : a ≤ b\n  then simp [min_def]",
  "core-prompt": "{α : Type u}  [LinearOrder α] (a b : α) : min a b ≤ b",
  "args": "{α : Type u}  [LinearOrder α] (a b : α)"},
 {"type": "c ≤ min a b",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b c : α}  (h₁ : c ≤ a)  (h₂ : c ≤ b) : c ≤ min a b := by if h : a ≤ b\n  then simp [min_def]; sorry",
  "name": "le_min",
  "kind": "lemma",
  "first-tactic": "if h : a ≤ b\n  then simp [min_def]",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b c : α}  (h₁ : c ≤ a)  (h₂ : c ≤ b) : c ≤ min a b",
  "args":
  "{α : Type u}  [LinearOrder α] {a b c : α}  (h₁ : c ≤ a)  (h₂ : c ≤ b)"},
 {"type": "a ≤ max a b",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a b : α) : a ≤ max a b := by if h : a ≤ b\n  then simp [max_def]; sorry",
  "name": "le_max_left",
  "kind": "lemma",
  "first-tactic": "if h : a ≤ b\n  then simp [max_def]",
  "core-prompt": "{α : Type u}  [LinearOrder α] (a b : α) : a ≤ max a b",
  "args": "{α : Type u}  [LinearOrder α] (a b : α)"},
 {"type": "b ≤ max a b",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a b : α) : b ≤ max a b := by if h : a ≤ b\n  then simp [max_def]; sorry",
  "name": "le_max_right",
  "kind": "lemma",
  "first-tactic": "if h : a ≤ b\n  then simp [max_def]",
  "core-prompt": "{α : Type u}  [LinearOrder α] (a b : α) : b ≤ max a b",
  "args": "{α : Type u}  [LinearOrder α] (a b : α)"},
 {"type": "max a b ≤ c",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b c : α}  (h₁ : a ≤ c)  (h₂ : b ≤ c) : max a b ≤ c := by if h : a ≤ b\n  then simp [max_def]; sorry",
  "name": "max_le",
  "kind": "lemma",
  "first-tactic": "if h : a ≤ b\n  then simp [max_def]",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b c : α}  (h₁ : a ≤ c)  (h₂ : b ≤ c) : max a b ≤ c",
  "args":
  "{α : Type u}  [LinearOrder α] {a b c : α}  (h₁ : a ≤ c)  (h₂ : b ≤ c)"},
 {"type": "min (min a b) c = min a (min b c)",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a b c : α) : min (min a b) c = min a (min b c) := by apply eq_min; sorry",
  "name": "min_assoc",
  "kind": "lemma",
  "first-tactic": "apply eq_min",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] (a b c : α) : min (min a b) c = min a (min b c)",
  "args": "{α : Type u}  [LinearOrder α] (a b c : α)"},
 {"type": "min a a = a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a : α) : min a a = a := by simp [min_def]; sorry",
  "name": "min_self",
  "kind": "lemma",
  "first-tactic": "simp [min_def]",
  "core-prompt": "{α : Type u}  [LinearOrder α] (a : α) : min a a = a",
  "args": "{α : Type u}  [LinearOrder α] (a : α)"},
 {"type": "min a b = a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b) : min a b = a := by apply Eq.symm; sorry",
  "name": "min_eq_left",
  "kind": "lemma",
  "first-tactic": "apply Eq.symm",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b) : min a b = a",
  "args": "{α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b)"},
 {"type": "min a b = b",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a) : min a b = b := by rw [min_comm]; sorry",
  "name": "min_eq_right",
  "kind": "lemma",
  "first-tactic": "rw [min_comm]",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a) : min a b = b",
  "args": "{α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a)"},
 {"type": "max (max a b) c = max a (max b c)",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a b c : α) : max (max a b) c = max a (max b c) := by apply eq_max; sorry",
  "name": "max_assoc",
  "kind": "lemma",
  "first-tactic": "apply eq_max",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] (a b c : α) : max (max a b) c = max a (max b c)",
  "args": "{α : Type u}  [LinearOrder α] (a b c : α)"},
 {"type": "max a a = a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a : α) : max a a = a := by simp [max_def]; sorry",
  "name": "max_self",
  "kind": "lemma",
  "first-tactic": "simp [max_def]",
  "core-prompt": "{α : Type u}  [LinearOrder α] (a : α) : max a a = a",
  "args": "{α : Type u}  [LinearOrder α] (a : α)"},
 {"type": "max a b = a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a) : max a b = a := by apply Eq.symm; sorry",
  "name": "max_eq_left",
  "kind": "lemma",
  "first-tactic": "apply Eq.symm",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a) : max a b = a",
  "args": "{α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a)"},
 {"type": "max a b = b",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b) : max a b = b := by rw [←max_comm b a]; sorry",
  "name": "max_eq_right",
  "kind": "lemma",
  "first-tactic": "rw [←max_comm b a]",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b) : max a b = b",
  "args": "{α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b)"},
 {"type": "∀ a b, min a b = if a ≤ b then a else b",
  "tactic-prompt":
  "def {α : Type u}  -- set_option auto_param.check_exists false : ∀ a b, min a b = if a ≤ b then a else b := by intros; sorry",
  "name": "",
  "kind": "def",
  "first-tactic": "intros",
  "core-prompt":
  "{α : Type u}  -- set_option auto_param.check_exists false : ∀ a b, min a b = if a ≤ b then a else b",
  "args": "{α : Type u}  -- set_option auto_param.check_exists false"},
 {"type": "∀ a b, max a b = if a ≤ b then b else a",
  "tactic-prompt":
  "def {α : Type u}  -- set_option auto_param.check_exists false : ∀ a b, max a b = if a ≤ b then b else a := by intros; sorry",
  "name": "",
  "kind": "def",
  "first-tactic": "intros",
  "core-prompt":
  "{α : Type u}  -- set_option auto_param.check_exists false : ∀ a b, max a b = if a ≤ b then b else a",
  "args": "{α : Type u}  -- set_option auto_param.check_exists false"},
 {"type": "WellFounded (lbp p)",
  "tactic-prompt":
  "def (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) : WellFounded (lbp p) := by refine ⟨let ⟨n, pn⟩ := H; ?_⟩; sorry",
  "name": "wf_lbp",
  "kind": "def",
  "first-tactic": "refine ⟨let ⟨n, pn⟩ := H; ?_⟩",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) : WellFounded (lbp p)",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n)"},
 {"type":
  "∀ (n : Nat) (l1 l2 : List Char), l1.length = l2.length →\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat) : ∀ (n : Nat) (l1 l2 : List Char), l1.length = l2.length →\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length := by induction f; sorry",
  "name": "to_digits_core_lens_eq_aux",
  "kind": "lemma",
  "first-tactic": "induction f",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat) : ∀ (n : Nat) (l1 l2 : List Char), l1.length = l2.length →\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat)"},
 {"type":
  "∀ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat) : ∀ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1 := by induction f; sorry",
  "name": "to_digits_core_lens_eq",
  "kind": "lemma",
  "first-tactic": "induction f",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat) : ∀ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat)"},
 {"type": "n < b ^ e.succ → n / b < b ^ e",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n b e : Nat)  (h_b_pos : 0 < b) : n < b ^ e.succ → n / b < b ^ e := by simp only [Nat.pow_succ]; sorry",
  "name": "nat_repr_len_aux",
  "kind": "lemma",
  "first-tactic": "simp only [Nat.pow_succ]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n b e : Nat)  (h_b_pos : 0 < b) : n < b ^ e.succ → n / b < b ^ e",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n b e : Nat)  (h_b_pos : 0 < b)"},
 {"type": "(Nat.toDigitsCore b f n []).length <= e",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b : Nat)  (h : 2 <= b)  (f n e : Nat)      (hlt : n < b ^ e)  (h_e_pos: 0 < e) : (Nat.toDigitsCore b f n []).length <= e := by induction f generalizing n e hlt h_e_pos with\n    simp only [Nat.toDigitsCore]; sorry",
  "name": "to_digits_core_length",
  "kind": "lemma",
  "first-tactic":
  "induction f generalizing n e hlt h_e_pos with\n    simp only [Nat.toDigitsCore]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b : Nat)  (h : 2 <= b)  (f n e : Nat)      (hlt : n < b ^ e)  (h_e_pos: 0 < e) : (Nat.toDigitsCore b f n []).length <= e",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b : Nat)  (h : 2 <= b)  (f n e : Nat)      (hlt : n < b ^ e)  (h_e_pos: 0 < e)"},
 {"type": "0 < e → n < 10 ^ e → (Nat.repr n).length <= e",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n e : Nat) : 0 < e → n < 10 ^ e → (Nat.repr n).length <= e := by cases n; sorry",
  "name": "repr_length",
  "kind": "lemma",
  "first-tactic": "cases n",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n e : Nat) : 0 < e → n < 10 ^ e → (Nat.repr n).length <= e",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n e : Nat)"},
 {"type": "(m * n).cast = (m.cast * n.cast : R)",
  "tactic-prompt":
  "lemma [Semiring R]  {m n : ℕ} : (m * n).cast = (m.cast * n.cast : R) := by induction n generalizing m; sorry",
  "name": "Nat.cast_mul",
  "kind": "lemma",
  "first-tactic": "induction n generalizing m",
  "core-prompt":
  "[Semiring R]  {m n : ℕ} : (m * n).cast = (m.cast * n.cast : R)",
  "args": "[Semiring R]  {m n : ℕ}"},
 {"type": "(m ^ n).cast = (m.cast ^ n : R)",
  "tactic-prompt":
  "lemma [Semiring R]  {m n : ℕ} : (m ^ n).cast = (m.cast ^ n : R) := by induction n generalizing m; sorry",
  "name": "Nat.cast_pow",
  "kind": "lemma",
  "first-tactic": "induction n generalizing m",
  "core-prompt": "[Semiring R]  {m n : ℕ} : (m ^ n).cast = (m.cast ^ n : R)",
  "args": "[Semiring R]  {m n : ℕ}"},
 {"type": "(a - b) * c = a * c - b * c",
  "tactic-prompt":
  "theorem [Ring R]  (a b c : R) : (a - b) * c = a * c - b * c := by simpa only [sub_eq_add_neg]; sorry",
  "name": "mul_sub_right_distrib",
  "kind": "theorem",
  "first-tactic": "simpa only [sub_eq_add_neg]",
  "core-prompt": "[Ring R]  (a b c : R) : (a - b) * c = a * c - b * c",
  "args": "[Ring R]  (a b c : R)"},
 {"type": "∀ ⦃m₁ m₂ : MulOneClass M⦄, m₁.mul = m₂.mul → m₁ = m₂",
  "tactic-prompt":
  "theorem {G : Type _} {M : Type u} : ∀ ⦃m₁ m₂ : MulOneClass M⦄, m₁.mul = m₂.mul → m₁ = m₂ := by rintro ⟨⟨one₁⟩, ⟨mul₁⟩, one_mul₁, mul_one₁⟩ ⟨⟨one₂⟩, ⟨mul₂⟩, one_mul₂, mul_one₂⟩ ⟨rfl⟩; sorry",
  "name": "MulOneClass.ext",
  "kind": "theorem",
  "first-tactic":
  "rintro ⟨⟨one₁⟩, ⟨mul₁⟩, one_mul₁, mul_one₁⟩ ⟨⟨one₂⟩, ⟨mul₂⟩, one_mul₂, mul_one₂⟩ ⟨rfl⟩",
  "core-prompt":
  "{G : Type _} {M : Type u} : ∀ ⦃m₁ m₂ : MulOneClass M⦄, m₁.mul = m₂.mul → m₁ = m₂",
  "args": "{G : Type _} {M : Type u}"},
 {"type": "b = c",
  "tactic-prompt":
  "theorem {G : Type _}  {M : Type u}  [Monoid M] {a b c : M}  (hba : b * a = 1)  (hac : a * c = 1) : b = c := by rw [← one_mul c]; sorry",
  "name": "left_inv_eq_right_inv",
  "kind": "theorem",
  "first-tactic": "rw [← one_mul c]",
  "core-prompt":
  "{G : Type _}  {M : Type u}  [Monoid M] {a b c : M}  (hba : b * a = 1)  (hac : a * c = 1) : b = c",
  "args":
  "{G : Type _}  {M : Type u}  [Monoid M] {a b c : M}  (hba : b * a = 1)  (hac : a * c = 1)"},
 {"type": "a ^ (Int.negSucc n) = (a ^ (n + 1))⁻¹",
  "tactic-prompt":
  "theorem {G : Type _}  [DivInvMonoid G]  {a b : G}  -- TODO restore @[to_additive zsmul_eq_smul] (a : G)  (n : ℕ) : a ^ (Int.negSucc n) = (a ^ (n + 1))⁻¹ := by rw [← zpow_coe_nat]; sorry",
  "name": "zpow_neg_succ_of_nat",
  "kind": "theorem",
  "first-tactic": "rw [← zpow_coe_nat]",
  "core-prompt":
  "{G : Type _}  [DivInvMonoid G]  {a b : G}  -- TODO restore @[to_additive zsmul_eq_smul] (a : G)  (n : ℕ) : a ^ (Int.negSucc n) = (a ^ (n + 1))⁻¹",
  "args":
  "{G : Type _}  [DivInvMonoid G]  {a b : G}  -- TODO restore @[to_additive zsmul_eq_smul] (a : G)  (n : ℕ)"},
 {"type": "a * a⁻¹ = 1",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a : G) : a * a⁻¹ = 1 := by rw [← mul_left_inv a⁻¹]; sorry",
  "name": "mul_right_inv",
  "kind": "theorem",
  "first-tactic": "rw [← mul_left_inv a⁻¹]",
  "core-prompt": "{G : Type _}  [Group G]  {a b c : G} (a : G) : a * a⁻¹ = 1",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a : G)"},
 {"type": "a⁻¹ * (a * b) = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a⁻¹ * (a * b) = b := by rw [← mul_assoc]; sorry",
  "name": "inv_mul_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a⁻¹ * (a * b) = b",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "a * (a⁻¹ * b) = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a * (a⁻¹ * b) = b := by rw [← mul_assoc]; sorry",
  "name": "mul_inv_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a * (a⁻¹ * b) = b",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "a * b * b⁻¹ = a",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a * b * b⁻¹ = a := by rw [mul_assoc]; sorry",
  "name": "mul_inv_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a * b * b⁻¹ = a",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "a * b⁻¹ * b = a",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a * b⁻¹ * b = a := by rw [mul_assoc]; sorry",
  "name": "inv_mul_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a * b⁻¹ * b = a",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "Function.Injective (@Group.toDivInvMonoid G)",
  "tactic-prompt":
  "theorem {G : Type _} {G : Type _} : Function.Injective (@Group.toDivInvMonoid G) := by rintro ⟨⟩ ⟨⟩ ⟨⟩; sorry",
  "name": "Group.toDivInvMonoid_injective",
  "kind": "theorem",
  "first-tactic": "rintro ⟨⟩ ⟨⟩ ⟨⟩",
  "core-prompt":
  "{G : Type _} {G : Type _} : Function.Injective (@Group.toDivInvMonoid G)",
  "args": "{G : Type _} {G : Type _}"},
 {"type": "Function.Injective (@CommGroup.toGroup G)",
  "tactic-prompt":
  "theorem {G : Type _} {G : Type u} : Function.Injective (@CommGroup.toGroup G) := by rintro ⟨⟩ ⟨⟩ ⟨⟩; sorry",
  "name": "CommGroup.toGroup_injective",
  "kind": "theorem",
  "first-tactic": "rintro ⟨⟩ ⟨⟩ ⟨⟩",
  "core-prompt":
  "{G : Type _} {G : Type u} : Function.Injective (@CommGroup.toGroup G)",
  "args": "{G : Type _} {G : Type u}"},
 {"type": "SemiconjBy a (x * x') (y * y')",
  "tactic-prompt":
  "theorem {G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x * x') (y * y') := by unfold SemiconjBy; sorry",
  "name": "mul_right",
  "kind": "theorem",
  "first-tactic": "unfold SemiconjBy",
  "core-prompt":
  "{G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x * x') (y * y')",
  "args":
  "{G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y')"},
 {"type": "SemiconjBy (a * b) x z",
  "tactic-prompt":
  "theorem {G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (ha : SemiconjBy a y z)  (hb : SemiconjBy b x y) : SemiconjBy (a * b) x z := by unfold SemiconjBy; sorry",
  "name": "mul_left",
  "kind": "theorem",
  "first-tactic": "unfold SemiconjBy",
  "core-prompt":
  "{G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (ha : SemiconjBy a y z)  (hb : SemiconjBy b x y) : SemiconjBy (a * b) x z",
  "args":
  "{G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (ha : SemiconjBy a y z)  (hb : SemiconjBy b x y)"},
 {"type": "SemiconjBy a 1 1",
  "tactic-prompt":
  "theorem {G : Type _}  {M : Type u}  [MulOneClass M] (a : M) : SemiconjBy a 1 1 := by rw [SemiconjBy]; sorry",
  "name": "one_right",
  "kind": "theorem",
  "first-tactic": "rw [SemiconjBy]",
  "core-prompt":
  "{G : Type _}  {M : Type u}  [MulOneClass M] (a : M) : SemiconjBy a 1 1",
  "args": "{G : Type _}  {M : Type u}  [MulOneClass M] (a : M)"},
 {"type": "SemiconjBy a (x ^ n) (y ^ n)",
  "tactic-prompt":
  "theorem {G : Type _}  {M : Type u}  [Monoid M] {a x y : M}  (h : SemiconjBy a x y)  (n : ℕ) : SemiconjBy a (x ^ n) (y ^ n) := by induction' n with n ih; sorry",
  "name": "pow_right",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{G : Type _}  {M : Type u}  [Monoid M] {a x y : M}  (h : SemiconjBy a x y)  (n : ℕ) : SemiconjBy a (x ^ n) (y ^ n)",
  "args":
  "{G : Type _}  {M : Type u}  [Monoid M] {a x y : M}  (h : SemiconjBy a x y)  (n : ℕ)"},
 {"type": "a * b * c = a * c * b",
  "tactic-prompt":
  "theorem {G : Type _}  {S : Type _}  [Semigroup S]  {a b c : S} (h : Commute b c)  (a : S) : a * b * c = a * c * b := by simp only [mul_assoc]; sorry",
  "name": "right_comm",
  "kind": "theorem",
  "first-tactic": "simp only [mul_assoc]",
  "core-prompt":
  "{G : Type _}  {S : Type _}  [Semigroup S]  {a b c : S} (h : Commute b c)  (a : S) : a * b * c = a * c * b",
  "args":
  "{G : Type _}  {S : Type _}  [Semigroup S]  {a b c : S} (h : Commute b c)  (a : S)"},
 {"type": "(x * ·) ∘ (y * ·) = (x * y * ·)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Semigroup α]  (x y : α) : (x * ·) ∘ (y * ·) = (x * y * ·) := by ext z; sorry",
  "name": "comp_mul_left",
  "kind": "theorem",
  "first-tactic": "ext z",
  "core-prompt":
  "{α β G : Type _}  [Semigroup α]  (x y : α) : (x * ·) ∘ (y * ·) = (x * y * ·)",
  "args": "{α β G : Type _}  [Semigroup α]  (x y : α)"},
 {"type": "(· * x) ∘ (· * y) = (· * (y * x))",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Semigroup α]  (x y : α) : (· * x) ∘ (· * y) = (· * (y * x)) := by ext z; sorry",
  "name": "comp_mul_right",
  "kind": "theorem",
  "first-tactic": "ext z",
  "core-prompt":
  "{α β G : Type _}  [Semigroup α]  (x y : α) : (· * x) ∘ (· * y) = (· * (y * x))",
  "args": "{α β G : Type _}  [Semigroup α]  (x y : α)"},
 {"type": "ite P (a * b) 1 = ite P a 1 * ite P b 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P (a * b) 1 = ite P a 1 * ite P b 1 := by by_cases h:P; sorry",
  "name": "ite_mul_one",
  "kind": "theorem",
  "first-tactic": "by_cases h:P",
  "core-prompt":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P (a * b) 1 = ite P a 1 * ite P b 1",
  "args":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M}"},
 {"type": "ite P 1 (a * b) = ite P 1 a * ite P 1 b",
  "tactic-prompt":
  "theorem {α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P 1 (a * b) = ite P 1 a * ite P 1 b := by by_cases h:P; sorry",
  "name": "ite_one_mul",
  "kind": "theorem",
  "first-tactic": "by_cases h:P",
  "core-prompt":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P 1 (a * b) = ite P 1 a * ite P 1 b",
  "args":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M}"},
 {"type": "a = 1 ↔ b = 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  {M : Type u}  [MulOneClass M] {a b : M}  (h : a * b = 1) : a = 1 ↔ b = 1 := by constructor; sorry",
  "name": "eq_one_iff_eq_one_of_mul_eq_one",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {a b : M}  (h : a * b = 1) : a = 1 ↔ b = 1",
  "args":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {a b : M}  (h : a * b = 1)"},
 {"type": "a * b * (c * d) = a * c * (b * d)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommSemigroup G] (a b c d : G) : a * b * (c * d) = a * c * (b * d) := by simp only [mul_left_comm]; sorry",
  "name": "mul_mul_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp only [mul_left_comm]",
  "core-prompt":
  "{α β G : Type _}  [CommSemigroup G] (a b c d : G) : a * b * (c * d) = a * c * (b * d)",
  "args": "{α β G : Type _}  [CommSemigroup G] (a b c d : G)"},
 {"type": "a * b * c = b * c * a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommSemigroup G] (a b c : G) : a * b * c = b * c * a := by simp only [mul_left_comm]; sorry",
  "name": "mul_rotate",
  "kind": "theorem",
  "first-tactic": "simp only [mul_left_comm]",
  "core-prompt":
  "{α β G : Type _}  [CommSemigroup G] (a b c : G) : a * b * c = b * c * a",
  "args": "{α β G : Type _}  [CommSemigroup G] (a b c : G)"},
 {"type": "a * (b * c) = b * (c * a)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommSemigroup G] (a b c : G) : a * (b * c) = b * (c * a) := by simp only [mul_left_comm]; sorry",
  "name": "mul_rotate'",
  "kind": "theorem",
  "first-tactic": "simp only [mul_left_comm]",
  "core-prompt":
  "{α β G : Type _}  [CommSemigroup G] (a b c : G) : a * (b * c) = b * (c * a)",
  "args": "{α β G : Type _}  [CommSemigroup G] (a b c : G)"},
 {"type": "b = a⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [HasInvolutiveInv G]  {a b : G} (h : a = b⁻¹) : b = a⁻¹ := by simp [h]; sorry",
  "name": "eq_inv_of_eq_inv",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [HasInvolutiveInv G]  {a b : G} (h : a = b⁻¹) : b = a⁻¹",
  "args": "{α β G : Type _}  [HasInvolutiveInv G]  {a b : G} (h : a = b⁻¹)"},
 {"type": "x⁻¹ = 1 / x",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x : G) : x⁻¹ = 1 / x := by rw [div_eq_mul_inv]; sorry",
  "name": "inv_eq_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x : G) : x⁻¹ = 1 / x",
  "args": "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x : G)"},
 {"type": "x * (1 / y) = x / y",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x y : G) : x * (1 / y) = x / y := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x y : G) : x * (1 / y) = x / y",
  "args": "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x y : G)"},
 {"type": "a * b / c = a * (b / c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * b / c = a * (b / c) := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_div_assoc",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * b / c = a * (b / c)",
  "args": "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G)"},
 {"type": "a * (b / c) = a * b / c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * (b / c) = a * b / c := by simp only [mul_assoc]; sorry",
  "name": "mul_div",
  "kind": "theorem",
  "first-tactic": "simp only [mul_assoc]",
  "core-prompt":
  "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * (b / c) = a * b / c",
  "args": "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G)"},
 {"type": "a / b = a * (1 / b)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b : G) : a / b = a * (1 / b) := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_mul_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b : G) : a / b = a * (1 / b)",
  "args": "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b : G)"},
 {"type": "a / 1 = a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvOneMonoid G] (a : G) : a / 1 = a := by simp [div_eq_mul_inv]; sorry",
  "name": "div_one",
  "kind": "theorem",
  "first-tactic": "simp [div_eq_mul_inv]",
  "core-prompt": "{α β G : Type _}  [DivInvOneMonoid G] (a : G) : a / 1 = a",
  "args": "{α β G : Type _}  [DivInvOneMonoid G] (a : G)"},
 {"type": "b⁻¹ = a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1) : b⁻¹ = a := by rw [← inv_eq_of_mul_eq_one_right h]; sorry",
  "name": "inv_eq_of_mul_eq_one_left",
  "kind": "theorem",
  "first-tactic": "rw [← inv_eq_of_mul_eq_one_right h]",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1) : b⁻¹ = a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1)"},
 {"type": "b = 1 / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : b * a = 1) : b = 1 / a := by rw [eq_inv_of_mul_eq_one_left h]; sorry",
  "name": "eq_one_div_of_mul_eq_one_left",
  "kind": "theorem",
  "first-tactic": "rw [eq_inv_of_mul_eq_one_left h]",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : b * a = 1) : b = 1 / a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : b * a = 1)"},
 {"type": "b = 1 / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1) : b = 1 / a := by rw [eq_inv_of_mul_eq_one_right h]; sorry",
  "name": "eq_one_div_of_mul_eq_one_right",
  "kind": "theorem",
  "first-tactic": "rw [eq_inv_of_mul_eq_one_right h]",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1) : b = 1 / a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1)"},
 {"type": "1 / a * (1 / b) = 1 / (b * a)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / a * (1 / b) = 1 / (b * a) := by simp; sorry",
  "name": "one_div_mul_one_div_rev",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / a * (1 / b) = 1 / (b * a)",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "a⁻¹ / b = (b * a)⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a⁻¹ / b = (b * a)⁻¹ := by simp; sorry",
  "name": "inv_div_left",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a⁻¹ / b = (b * a)⁻¹",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "(a / b)⁻¹ = b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : (a / b)⁻¹ = b / a := by simp; sorry",
  "name": "inv_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : (a / b)⁻¹ = b / a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "1 / (a / b) = b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / (a / b) = b / a := by simp; sorry",
  "name": "one_div_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / (a / b) = b / a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "1 / (1 / a) = a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / (1 / a) = a := by simp; sorry",
  "name": "one_div_one_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / (1 / a) = a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : 1 / a = 1 / b) : a = b := by rw [← one_div_one_div a]; sorry",
  "name": "eq_of_one_div_eq_one_div",
  "kind": "theorem",
  "first-tactic": "rw [← one_div_one_div a]",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : 1 / a = 1 / b) : a = b",
  "args":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : 1 / a = 1 / b)"},
 {"type": "a / (b / c) = a * c / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / (b / c) = a * c / b := by simp; sorry",
  "name": "div_div_eq_mul_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / (b / c) = a * c / b",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "a / b⁻¹ = a * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / b⁻¹ = a * b := by simp; sorry",
  "name": "div_inv_eq_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / b⁻¹ = a * b",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "a / (b * c) = a / c / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / (b * c) = a / c / b := by simp only [mul_assoc]; sorry",
  "name": "div_mul_eq_div_div_swap",
  "kind": "theorem",
  "first-tactic": "simp only [mul_assoc]",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / (b * c) = a / c / b",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "(a * b)⁻¹ = a⁻¹ * b⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a * b)⁻¹ = a⁻¹ * b⁻¹ := by simp; sorry",
  "name": "mul_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a * b)⁻¹ = a⁻¹ * b⁻¹",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "(a / b)⁻¹ = a⁻¹ / b⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a / b)⁻¹ = a⁻¹ / b⁻¹ := by simp; sorry",
  "name": "inv_div'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a / b)⁻¹ = a⁻¹ / b⁻¹",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b = b⁻¹ * a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b = b⁻¹ * a := by simp; sorry",
  "name": "div_eq_inv_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b = b⁻¹ * a",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a⁻¹ * b = b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a⁻¹ * b = b / a := by simp; sorry",
  "name": "inv_mul_eq_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a⁻¹ * b = b / a",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "(a * b)⁻¹ = a⁻¹ / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a * b)⁻¹ = a⁻¹ / b := by simp; sorry",
  "name": "inv_mul'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a * b)⁻¹ = a⁻¹ / b",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a⁻¹ / b⁻¹ = b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a⁻¹ / b⁻¹ = b / a := by simp; sorry",
  "name": "inv_div_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a⁻¹ / b⁻¹ = b / a",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "(a⁻¹ / b⁻¹)⁻¹ = a / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a⁻¹ / b⁻¹)⁻¹ = a / b := by simp; sorry",
  "name": "inv_inv_div_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a⁻¹ / b⁻¹)⁻¹ = a / b",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "1 / a * (1 / b) = 1 / (a * b)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : 1 / a * (1 / b) = 1 / (a * b) := by simp; sorry",
  "name": "one_div_mul_one_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : 1 / a * (1 / b) = 1 / (a * b)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b / c = a / c / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / c = a / c / b := by simp; sorry",
  "name": "div_right_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / c = a / c / b",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b / c = a / (b * c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / c = a / (b * c) := by simp; sorry",
  "name": "div_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / c = a / (b * c)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b * c = a / (b / c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a / (b / c) := by simp; sorry",
  "name": "div_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a / (b / c)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a * (b / c) = b * (a / c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * (b / c) = b * (a / c) := by simp; sorry",
  "name": "mul_div_left_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * (b / c) = b * (a / c)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a * b / c = a / c * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * b / c = a / c * b := by simp; sorry",
  "name": "mul_div_right_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * b / c = a / c * b",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / (b * c) = a / b / c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / (b * c) = a / b / c := by simp; sorry",
  "name": "div_mul_eq_div_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / (b * c) = a / b / c",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b * c = a * c / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a * c / b := by simp; sorry",
  "name": "div_mul_eq_mul_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a * c / b",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b * c = a * (c / b)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a * (c / b) := by simp; sorry",
  "name": "mul_comm_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a * (c / b)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b * c = c / b * a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = c / b * a := by simp; sorry",
  "name": "div_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = c / b * a",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / (b * c) = a / b * (1 / c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / (b * c) = a / b * (1 / c) := by simp; sorry",
  "name": "div_mul_eq_div_mul_one_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / (b * c) = a / b * (1 / c)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b / (c / d) = a * d / (b * c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / (c / d) = a * d / (b * c) := by simp; sorry",
  "name": "div_div_div_eq",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / (c / d) = a * d / (b * c)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b / (c / d) = a / c / (b / d)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / (c / d) = a / c / (b / d) := by simp; sorry",
  "name": "div_div_div_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / (c / d) = a / c / (b / d)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b * (c / d) = a * c / (b * d)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * (c / d) = a * c / (b * d) := by simp; sorry",
  "name": "div_mul_div_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * (c / d) = a * c / (b * d)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a * b / (c * d) = a / c * (b / d)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * b / (c * d) = a / c * (b / d) := by simp; sorry",
  "name": "mul_div_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * b / (c * d) = a / c * (b / d)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b = b⁻¹ ↔ a = 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a / b = b⁻¹ ↔ a = 1 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_inv_self",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a / b = b⁻¹ ↔ a = 1",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a = b * c⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b * c⁻¹ := by simp [h.symm]; sorry",
  "name": "eq_mul_inv_of_mul_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b * c⁻¹",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b)"},
 {"type": "a = b⁻¹ * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : b * a = c) : a = b⁻¹ * c := by simp [h.symm]; sorry",
  "name": "eq_inv_mul_of_mul_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : b * a = c) : a = b⁻¹ * c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : b * a = c)"},
 {"type": "a⁻¹ * b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : b = a * c) : a⁻¹ * b = c := by simp [h]; sorry",
  "name": "inv_mul_eq_of_eq_mul",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : b = a * c) : a⁻¹ * b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : b = a * c)"},
 {"type": "a * b⁻¹ = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a * b⁻¹ = c := by simp [h]; sorry",
  "name": "mul_inv_eq_of_eq_mul",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a * b⁻¹ = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a * c⁻¹ = b) : a = b * c := by simp [h.symm]; sorry",
  "name": "eq_mul_of_mul_inv_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c⁻¹ = b) : a = b * c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c⁻¹ = b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : b⁻¹ * a = c) : a = b * c := by simp [h.symm]; sorry",
  "name": "eq_mul_of_inv_mul_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : b⁻¹ * a = c) : a = b * c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : b⁻¹ * a = c)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : b = a⁻¹ * c) : a * b = c := by rw [h]; sorry",
  "name": "mul_eq_of_eq_inv_mul",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : b = a⁻¹ * c) : a * b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : b = a⁻¹ * c)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b⁻¹) : a * b = c := by simp [h]; sorry",
  "name": "mul_eq_of_eq_mul_inv",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b⁻¹) : a * b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b⁻¹)"},
 {"type": "a * b = 1 ↔ a⁻¹ = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a * b = 1 ↔ a⁻¹ = b := by rw [mul_eq_one_iff_eq_inv]; sorry",
  "name": "mul_eq_one_iff_inv_eq",
  "kind": "theorem",
  "first-tactic": "rw [mul_eq_one_iff_eq_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a * b = 1 ↔ a⁻¹ = b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a * b⁻¹ = 1 ↔ a = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a * b⁻¹ = 1 ↔ a = b := by rw [mul_eq_one_iff_eq_inv]; sorry",
  "name": "mul_inv_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [mul_eq_one_iff_eq_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a * b⁻¹ = 1 ↔ a = b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a⁻¹ * b = 1 ↔ a = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a⁻¹ * b = 1 ↔ a = b := by rw [mul_eq_one_iff_eq_inv]; sorry",
  "name": "inv_mul_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [mul_eq_one_iff_eq_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a⁻¹ * b = 1 ↔ a = b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "Function.Injective fun a => a / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : Function.Injective fun a => a / b := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_left_injective",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : Function.Injective fun a => a / b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "Function.Injective fun a => b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : Function.Injective fun a => b / a := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_right_injective",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : Function.Injective fun a => b / a",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a / b * b = a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a b : G) : a / b * b = a := by rw [div_eq_mul_inv]; sorry",
  "name": "div_mul_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a b : G) : a / b * b = a",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a b : G)"},
 {"type": "a / a = 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a : G) : a / a = 1 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_self'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a : G) : a / a = 1",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a : G)"},
 {"type": "a * b / b = a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a b : G) : a * b / b = a := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_div_cancel''",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a b : G) : a * b / b = a",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a b : G)"},
 {"type": "a * c / (b * c) = a / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a * c / (b * c) = a / b := by rw [div_mul_eq_div_div_swap]; sorry",
  "name": "mul_div_mul_right_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [div_mul_eq_div_div_swap]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a * c / (b * c) = a / b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G)"},
 {"type": "a = b / c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b / c := by simp [← h]; sorry",
  "name": "eq_div_of_mul_eq'",
  "kind": "theorem",
  "first-tactic": "simp [← h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b / c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b)"},
 {"type": "a / b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a / b = c := by simp [h]; sorry",
  "name": "div_eq_of_eq_mul''",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a / b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a / c = b) : a = b * c := by simp [← h]; sorry",
  "name": "eq_mul_of_div_eq",
  "kind": "theorem",
  "first-tactic": "simp [← h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a / c = b) : a = b * c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a / c = b)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a = c / b) : a * b = c := by simp [h]; sorry",
  "name": "mul_eq_of_eq_div",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c / b) : a * b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c / b)"},
 {"type": "b / a = c / a ↔ b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : b / a = c / a ↔ b = c := by rw [div_eq_mul_inv]; sorry",
  "name": "div_left_inj",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : b / a = c / a ↔ b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a / b * (b / c) = a / c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / b * (b / c) = a / c := by rw [← mul_div_assoc]; sorry",
  "name": "div_mul_div_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [← mul_div_assoc]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / b * (b / c) = a / c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G)"},
 {"type": "a / c / (b / c) = a / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / c / (b / c) = a / b := by rw [← inv_div c b]; sorry",
  "name": "div_div_div_cancel_right'",
  "kind": "theorem",
  "first-tactic": "rw [← inv_div c b]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / c / (b / c) = a / b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b = a ↔ b = 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a / b = a ↔ b = 1 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_self",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a / b = a ↔ b = 1",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a = b / c ↔ a * c = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a = b / c ↔ a * c = b := by rw [div_eq_mul_inv]; sorry",
  "name": "eq_div_iff_mul_eq'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a = b / c ↔ a * c = b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a / b = c ↔ a = c * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a / b = c ↔ a = c * b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_iff_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a / b = c ↔ a = c * b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a = b ↔ c = d",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (H : a / b = c / d) : a = b ↔ c = d := by rw [← div_eq_one]; sorry",
  "name": "eq_iff_eq_of_div_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [← div_eq_one]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (H : a / b = c / d) : a = b ↔ c = d",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (H : a / b = c / d)"},
 {"type": "∃ n : ℕ, 0 < n ∧ x ^ n = 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} {n : ℤ}  (hn : n ≠ 0)  {x : G}  (h : x ^ n = 1) : ∃ n : ℕ, 0 < n ∧ x ^ n = 1 := by cases' n with n n; sorry",
  "name": "exists_npow_eq_one_of_zpow_eq_one",
  "kind": "theorem",
  "first-tactic": "cases' n with n n",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} {n : ℤ}  (hn : n ≠ 0)  {x : G}  (h : x ^ n = 1) : ∃ n : ℕ, 0 < n ∧ x ^ n = 1",
  "args":
  "{α β G : Type _}  [Group G]  {a b c d : G} {n : ℤ}  (hn : n ≠ 0)  {x : G}  (h : x ^ n = 1)"},
 {"type": "a / b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} {a b c : G}  (h : a = b * c) : a / b = c := by rw [h]; sorry",
  "name": "div_eq_of_eq_mul'",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} {a b c : G}  (h : a = b * c) : a / b = c",
  "args":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} {a b c : G}  (h : a = b * c)"},
 {"type": "c * a / (c * b) = a / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c * a / (c * b) = a / b := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_div_mul_left_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c * a / (c * b) = a / b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a = b / c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (h : c * a = b) : a = b / c := by simp [h.symm]; sorry",
  "name": "eq_div_of_mul_eq''",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : c * a = b) : a = b / c",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : c * a = b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (h : a / b = c) : a = b * c := by simp [h.symm]; sorry",
  "name": "eq_mul_of_div_eq'",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : a / b = c) : a = b * c",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : a / b = c)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (h : b = c / a) : a * b = c := by simp [h]; sorry",
  "name": "mul_eq_of_eq_div'",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : b = c / a) : a * b = c",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : b = c / a)"},
 {"type": "a / (a / b) = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a / b) = b := by simpa using mul_inv_cancel_left a b; sorry",
  "name": "div_div_self'",
  "kind": "theorem",
  "first-tactic": "simpa using mul_inv_cancel_left a b",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a / b) = b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a / b = c / b * (a / c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b = c / b * (a / c) := by simp [mul_left_comm c]; sorry",
  "name": "div_eq_div_mul_div",
  "kind": "theorem",
  "first-tactic": "simp [mul_left_comm c]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b = c / b * (a / c)",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b / a = b⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / b / a = b⁻¹ := by simp; sorry",
  "name": "div_div_cancel_left",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / b / a = b⁻¹",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a = b / c ↔ c * a = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} : a = b / c ↔ c * a = b := by rw [eq_div_iff_mul_eq']; sorry",
  "name": "eq_div_iff_mul_eq''",
  "kind": "theorem",
  "first-tactic": "rw [eq_div_iff_mul_eq']",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} : a = b / c ↔ c * a = b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "a / b = c ↔ a = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c ↔ a = b * c := by rw [div_eq_iff_eq_mul]; sorry",
  "name": "div_eq_iff_eq_mul'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_iff_eq_mul]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c ↔ a = b * c",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "a * b / a = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * b / a = b := by rw [div_eq_inv_mul]; sorry",
  "name": "mul_div_cancel'''",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_inv_mul]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * b / a = b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a * (b / a) = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b / a) = b := by rw [← mul_div_assoc]; sorry",
  "name": "mul_div_cancel'_right",
  "kind": "theorem",
  "first-tactic": "rw [← mul_div_assoc]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b / a) = b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a / (a * b) = b⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a * b) = b⁻¹ := by rw [← inv_div]; sorry",
  "name": "div_mul_cancel''",
  "kind": "theorem",
  "first-tactic": "rw [← inv_div]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a * b) = b⁻¹",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a * (b * a⁻¹) = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b * a⁻¹) = b := by rw [← div_eq_mul_inv]; sorry",
  "name": "mul_mul_inv_cancel'_right",
  "kind": "theorem",
  "first-tactic": "rw [← div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b * a⁻¹) = b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a * c * (b / c) = a * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * c * (b / c) = a * b := by rw [mul_assoc]; sorry",
  "name": "mul_mul_div_cancel",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * c * (b / c) = a * b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / c * (b * c) = a * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / c * (b * c) = a * b := by rw [mul_left_comm]; sorry",
  "name": "div_mul_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rw [mul_left_comm]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / c * (b * c) = a * b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b * (c / a) = c / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b * (c / a) = c / b := by rw [mul_comm]; sorry",
  "name": "div_mul_div_cancel''",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b * (c / a) = c / b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a * b / (a / c) = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * b / (a / c) = b * c := by rw [← div_mul]; sorry",
  "name": "mul_div_div_cancel",
  "kind": "theorem",
  "first-tactic": "rw [← div_mul]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * b / (a / c) = b * c",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "c / a / (c / b) = b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c / a / (c / b) = b / a := by rw [← inv_div b c]; sorry",
  "name": "div_div_div_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← inv_div b c]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c / a / (c / b) = b / a",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b = c / d ↔ a * d = c * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d ↔ a * d = c * b := by rw [div_eq_iff_eq_mul]; sorry",
  "name": "div_eq_div_iff_mul_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_iff_eq_mul]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d ↔ a * d = c * b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "a / b = c / d ↔ a / c = b / d",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d ↔ a / c = b / d := by rw [div_eq_iff_eq_mul]; sorry",
  "name": "div_eq_div_iff_div_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_iff_eq_mul]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d ↔ a / c = b / d",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "Covariant N N (· * ·) r ↔ Contravariant N N (· * ·) r",
  "tactic-prompt":
  "theorem {M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [Group N] : Covariant N N (· * ·) r ↔ Contravariant N N (· * ·) r := by refine ⟨fun h a b c bc => ?_, fun h a b c bc => ?_⟩; sorry",
  "name": "Group.covariant_iff_contravariant",
  "kind": "theorem",
  "first-tactic": "refine ⟨fun h a b c bc => ?_, fun h a b c bc => ?_⟩",
  "core-prompt":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [Group N] : Covariant N N (· * ·) r ↔ Contravariant N N (· * ·) r",
  "args": "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [Group N]"},
 {"type": "Covariant N N (swap (· * ·)) r ↔ Contravariant N N (swap (· * ·)) r",
  "tactic-prompt":
  "theorem {M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [Group N] : Covariant N N (swap (· * ·)) r ↔ Contravariant N N (swap (· * ·)) r := by refine ⟨fun h a b c bc => ?_, fun h a b c bc => ?_⟩; sorry",
  "name": "Group.covariant_swap_iff_contravariant_swap",
  "kind": "theorem",
  "first-tactic": "refine ⟨fun h a b c bc => ?_, fun h a b c bc => ?_⟩",
  "core-prompt":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [Group N] : Covariant N N (swap (· * ·)) r ↔ Contravariant N N (swap (· * ·)) r",
  "args": "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [Group N]"},
 {"type": "Covariant M N μ (· < ·) → Covariant M N μ (· ≤ ·)",
  "tactic-prompt":
  "theorem {M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [PartialOrder N] : Covariant M N μ (· < ·) → Covariant M N μ (· ≤ ·) := by intro h a b c bc; sorry",
  "name": "covariant_le_of_covariant_lt",
  "kind": "theorem",
  "first-tactic": "intro h a b c bc",
  "core-prompt":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [PartialOrder N] : Covariant M N μ (· < ·) → Covariant M N μ (· ≤ ·)",
  "args":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [PartialOrder N]"},
 {"type": "Contravariant M N μ (· ≤ ·) → Contravariant M N μ (· < ·)",
  "tactic-prompt":
  "theorem {M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [PartialOrder N] : Contravariant M N μ (· ≤ ·) → Contravariant M N μ (· < ·) := by refine fun h a b c bc => lt_iff_le_and_ne.mpr ⟨h a bc.le, ?_⟩; sorry",
  "name": "contravariant_lt_of_contravariant_le",
  "kind": "theorem",
  "first-tactic":
  "refine fun h a b c bc => lt_iff_le_and_ne.mpr ⟨h a bc.le, ?_⟩",
  "core-prompt":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [PartialOrder N] : Contravariant M N μ (· ≤ ·) → Contravariant M N μ (· < ·)",
  "args":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [PartialOrder N]"},
 {"type": "Covariant N N (flip (· * ·)) r ↔ Covariant N N (· * ·) r",
  "tactic-prompt":
  "theorem {M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [CommSemigroup N] : Covariant N N (flip (· * ·)) r ↔ Covariant N N (· * ·) r := by rw [flip_mul]; sorry",
  "name": "covariant_flip_mul_iff",
  "kind": "theorem",
  "first-tactic": "rw [flip_mul]",
  "core-prompt":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [CommSemigroup N] : Covariant N N (flip (· * ·)) r ↔ Covariant N N (· * ·) r",
  "args":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [CommSemigroup N]"},
 {"type": "Contravariant N N (flip (· * ·)) r ↔ Contravariant N N (· * ·) r",
  "tactic-prompt":
  "theorem {M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [CommSemigroup N] : Contravariant N N (flip (· * ·)) r ↔ Contravariant N N (· * ·) r := by rw [flip_mul]; sorry",
  "name": "contravariant_flip_mul_iff",
  "kind": "theorem",
  "first-tactic": "rw [flip_mul]",
  "core-prompt":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [CommSemigroup N] : Contravariant N N (flip (· * ·)) r ↔ Contravariant N N (· * ·) r",
  "args":
  "{M N : Type _}  (μ : M → N → N)  (r : N → N → Prop)  [CommSemigroup N]"},
 {"type": "a ^ 1 = a",
  "tactic-prompt":
  "theorem [Monoid M] (a : M) : a ^ 1 = a := by rw [pow_succ]; sorry",
  "name": "pow_one",
  "kind": "theorem",
  "first-tactic": "rw [pow_succ]",
  "core-prompt": "[Monoid M] (a : M) : a ^ 1 = a",
  "args": "[Monoid M] (a : M)"},
 {"type": "a ^ (m + n) = a ^ m * a ^ n",
  "tactic-prompt":
  "theorem [Monoid M] (a : M)  (m n : ℕ) : a ^ (m + n) = a ^ m * a ^ n := by induction' n with n ih; sorry",
  "name": "pow_add",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt": "[Monoid M] (a : M)  (m n : ℕ) : a ^ (m + n) = a ^ m * a ^ n",
  "args": "[Monoid M] (a : M)  (m n : ℕ)"},
 {"type": "a ^ (m * n) = (a ^ m) ^ n",
  "tactic-prompt":
  "theorem [Monoid M] (a : M)  (m n : ℕ) : a ^ (m * n) = (a ^ m) ^ n := by induction' n with n ih; sorry",
  "name": "pow_mul",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt": "[Monoid M] (a : M)  (m n : ℕ) : a ^ (m * n) = (a ^ m) ^ n",
  "args": "[Monoid M] (a : M)  (m n : ℕ)"},
 {"type": "(a * b) ^ n = a ^ n * b ^ n",
  "tactic-prompt":
  "theorem [Monoid M] {a b : M}  (h : Commute a b)  (n : ℕ) : (a * b) ^ n = a ^ n * b ^ n := by induction' n with n ih; sorry",
  "name": "Commute.mul_pow",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "[Monoid M] {a b : M}  (h : Commute a b)  (n : ℕ) : (a * b) ^ n = a ^ n * b ^ n",
  "args": "[Monoid M] {a b : M}  (h : Commute a b)  (n : ℕ)"},
 {"type": "1 < a⁻¹ ↔ a < 1",
  "tactic-prompt":
  "theorem [Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α} : 1 < a⁻¹ ↔ a < 1 := by rw [← mul_lt_mul_iff_left a]; sorry",
  "name": "Left.one_lt_inv_iff",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_left a]",
  "core-prompt":
  "[Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α} : 1 < a⁻¹ ↔ a < 1",
  "args":
  "[Group α]  [LT α]  [CovariantClass α α (· * ·) (· < ·)]  {a b c : α}"},
 {"type": "1 < a / b ↔ b < a",
  "tactic-prompt":
  "theorem [Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α}  -- FIXME: restore @[to_additive sub_pos] : 1 < a / b ↔ b < a := by rw [← mul_lt_mul_iff_right b]; sorry",
  "name": "one_lt_div'",
  "kind": "theorem",
  "first-tactic": "rw [← mul_lt_mul_iff_right b]",
  "core-prompt":
  "[Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α}  -- FIXME: restore @[to_additive sub_pos] : 1 < a / b ↔ b < a",
  "args":
  "[Group α]  [LT α]  [CovariantClass α α (swap (· * ·)) (· < ·)]  {a b c d : α}  -- FIXME: restore @[to_additive sub_pos]"},
 {"type": "((1 : ℕ) : R) = 1",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] : ((1 : ℕ) : R) = 1 := by simp; sorry",
  "name": "Nat.cast_one",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "[AddMonoidWithOne R] : ((1 : ℕ) : R) = 1",
  "args": "[AddMonoidWithOne R]"},
 {"type": "((m + n : ℕ) : R) = (m : R) + n",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] : ((m + n : ℕ) : R) = (m : R) + n := by induction n; sorry",
  "name": "Nat.cast_add",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "[AddMonoidWithOne R] : ((m + n : ℕ) : R) = (m : R) + n",
  "args": "[AddMonoidWithOne R]"},
 {"type": "((0 : ℤ) : R) = 0",
  "tactic-prompt":
  "theorem [AddGroupWithOne R] : ((0 : ℤ) : R) = 0 := by erw [cast_ofNat]; sorry",
  "name": "cast_zero",
  "kind": "theorem",
  "first-tactic": "erw [cast_ofNat]",
  "core-prompt": "[AddGroupWithOne R] : ((0 : ℤ) : R) = 0",
  "args": "[AddGroupWithOne R]"},
 {"type": "((1 : ℤ) : R) = 1",
  "tactic-prompt":
  "theorem [AddGroupWithOne R] : ((1 : ℤ) : R) = 1 := by erw [cast_ofNat]; sorry",
  "name": "cast_one",
  "kind": "theorem",
  "first-tactic": "erw [cast_ofNat]",
  "core-prompt": "[AddGroupWithOne R] : ((1 : ℤ) : R) = 1",
  "args": "[AddGroupWithOne R]"},
 {"type": "Fmla.reify v (f₁.and f₂) (a ∨ b)",
  "tactic-prompt":
  "theorem (h₁ : Fmla.reify v f₁ a)  (h₂ : Fmla.reify v f₂ b) : Fmla.reify v (f₁.and f₂) (a ∨ b) := by refine ⟨fun H => by_contra fun hn => H ⟨fun c h => by_contra fun hn' => ?_⟩⟩; sorry",
  "name": "Fmla.reify_or",
  "kind": "theorem",
  "first-tactic":
  "refine ⟨fun H => by_contra fun hn => H ⟨fun c h => by_contra fun hn' => ?_⟩⟩",
  "core-prompt":
  "(h₁ : Fmla.reify v f₁ a)  (h₂ : Fmla.reify v f₂ b) : Fmla.reify v (f₁.and f₂) (a ∨ b)",
  "args": "(h₁ : Fmla.reify v f₁ a)  (h₂ : Fmla.reify v f₂ b)"},
 {"type": "True",
  "tactic-prompt": "example  : True := by find; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "find",
  "core-prompt": " : True",
  "args": ""},
 {"type": "HEq a b ↔ HEq (a : α) (b : β)",
  "tactic-prompt":
  "lemma {α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop} {α β : Sort _}  {p : α → Prop}  {q : β → Prop}  {a : {x // p x}}    {b : {y // q y}}  (h : α = β)  (h' : HEq p q) : HEq a b ↔ HEq (a : α) (b : β) := by subst h; sorry",
  "name": "heq_iff_coe_heq",
  "kind": "lemma",
  "first-tactic": "subst h",
  "core-prompt":
  "{α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop} {α β : Sort _}  {p : α → Prop}  {q : β → Prop}  {a : {x // p x}}    {b : {y // q y}}  (h : α = β)  (h' : HEq p q) : HEq a b ↔ HEq (a : α) (b : β)",
  "args":
  "{α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop} {α β : Sort _}  {p : α → Prop}  {q : β → Prop}  {a : {x // p x}}    {b : {y // q y}}  (h : α = β)  (h' : HEq p q)"},
 {"type": "Injective ((↑·) : Subtype p → α)",
  "tactic-prompt":
  "theorem {α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop} : Injective ((↑·) : Subtype p → α) := by intros a b hab; sorry",
  "name": "coe_injective",
  "kind": "theorem",
  "first-tactic": "intros a b hab",
  "core-prompt":
  "{α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop} : Injective ((↑·) : Subtype p → α)",
  "args":
  "{α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop}"},
 {"type": "C z",
  "tactic-prompt":
  "def {C : ℤ → Sort _}      (z : ℤ)  (b : ℤ)  (H0 : C b)  (Hs : ∀ k, b ≤ k → C k → C (k + 1))      (Hp : ∀ k ≤ b, C k → C (k - 1)) : C z := by rw [← sub_add_cancel (G := ℤ) z b]; sorry",
  "name": "inductionOn'",
  "kind": "def",
  "first-tactic": "rw [← sub_add_cancel (G := ℤ) z b]",
  "core-prompt":
  "{C : ℤ → Sort _}      (z : ℤ)  (b : ℤ)  (H0 : C b)  (Hs : ∀ k, b ≤ k → C k → C (k + 1))      (Hp : ∀ k ≤ b, C k → C (k - 1)) : C z",
  "args":
  "{C : ℤ → Sort _}      (z : ℤ)  (b : ℤ)  (H0 : C b)  (Hs : ∀ k, b ≤ k → C k → C (k + 1))      (Hp : ∀ k ≤ b, C k → C (k - 1))"},
 {"type": "x₀ = x₁",
  "tactic-prompt":
  "theorem {α α₁ α₂ : Type _}  {β : α → Type _}  {β₁ : α₁ → Type _}  {β₂ : α₂ → Type _} {x₀ x₁ : Sigma β}  (h₀ : x₀.1 = x₁.1)  (h₁ : HEq x₀.2 x₁.2) : x₀ = x₁ := by cases x₀; sorry",
  "name": "ext",
  "kind": "theorem",
  "first-tactic": "cases x₀",
  "core-prompt":
  "{α α₁ α₂ : Type _}  {β : α → Type _}  {β₁ : α₁ → Type _}  {β₂ : α₂ → Type _} {x₀ x₁ : Sigma β}  (h₀ : x₀.1 = x₁.1)  (h₁ : HEq x₀.2 x₁.2) : x₀ = x₁",
  "args":
  "{α α₁ α₂ : Type _}  {β : α → Type _}  {β₁ : α₁ → Type _}  {β₂ : α₂ → Type _} {x₀ x₁ : Sigma β}  (h₀ : x₀.1 = x₁.1)  (h₁ : HEq x₀.2 x₁.2)"},
 {"type": "x₀ = x₁ ↔ x₀.1 = x₁.1 ∧ HEq x₀.2 x₁.2",
  "tactic-prompt":
  "theorem {α α₁ α₂ : Type _}  {β : α → Type _}  {β₁ : α₁ → Type _}  {β₂ : α₂ → Type _} {x₀ x₁ : Sigma β} : x₀ = x₁ ↔ x₀.1 = x₁.1 ∧ HEq x₀.2 x₁.2 := by cases x₀; sorry",
  "name": "ext_iff",
  "kind": "theorem",
  "first-tactic": "cases x₀",
  "core-prompt":
  "{α α₁ α₂ : Type _}  {β : α → Type _}  {β₁ : α₁ → Type _}  {β₂ : α₂ → Type _} {x₀ x₁ : Sigma β} : x₀ = x₁ ↔ x₀.1 = x₁.1 ∧ HEq x₀.2 x₁.2",
  "args":
  "{α α₁ α₂ : Type _}  {β : α → Type _}  {β₁ : α₁ → Type _}  {β₂ : α₂ → Type _} {x₀ x₁ : Sigma β}"},
 {"type": "Function.Surjective (Sigma.map f₁ f₂)",
  "tactic-prompt":
  "theorem {f₁ : α₁ → α₂}  {f₂ : ∀ a, β₁ a → β₂ (f₁ a)}    (h₁ : Function.Surjective f₁)  (h₂ : ∀ a, Function.Surjective (f₂ a)) : Function.Surjective (Sigma.map f₁ f₂) := by simp only [Function.Surjective]; sorry",
  "name": "Function.Surjective.sigma_map",
  "kind": "theorem",
  "first-tactic": "simp only [Function.Surjective]",
  "core-prompt":
  "{f₁ : α₁ → α₂}  {f₂ : ∀ a, β₁ a → β₂ (f₁ a)}    (h₁ : Function.Surjective f₁)  (h₂ : ∀ a, Function.Surjective (f₂ a)) : Function.Surjective (Sigma.map f₁ f₂)",
  "args":
  "{f₁ : α₁ → α₂}  {f₂ : ∀ a, β₁ a → β₂ (f₁ a)}    (h₁ : Function.Surjective f₁)  (h₂ : ∀ a, Function.Surjective (f₂ a))"},
 {"type": "x₀ = x₁",
  "tactic-prompt":
  "theorem {α : Sort _}  {β : α → Sort _} {x₀ x₁ : PSigma β}  (h₀ : x₀.1 = x₁.1)  (h₁ : HEq x₀.2 x₁.2) : x₀ = x₁ := by cases x₀; sorry",
  "name": "ext",
  "kind": "theorem",
  "first-tactic": "cases x₀",
  "core-prompt":
  "{α : Sort _}  {β : α → Sort _} {x₀ x₁ : PSigma β}  (h₀ : x₀.1 = x₁.1)  (h₁ : HEq x₀.2 x₁.2) : x₀ = x₁",
  "args":
  "{α : Sort _}  {β : α → Sort _} {x₀ x₁ : PSigma β}  (h₀ : x₀.1 = x₁.1)  (h₁ : HEq x₀.2 x₁.2)"},
 {"type": "x₀ = x₁ ↔ x₀.1 = x₁.1 ∧ HEq x₀.2 x₁.2",
  "tactic-prompt":
  "theorem {α : Sort _}  {β : α → Sort _} {x₀ x₁ : PSigma β} : x₀ = x₁ ↔ x₀.1 = x₁.1 ∧ HEq x₀.2 x₁.2 := by cases x₀; sorry",
  "name": "ext_iff",
  "kind": "theorem",
  "first-tactic": "cases x₀",
  "core-prompt":
  "{α : Sort _}  {β : α → Sort _} {x₀ x₁ : PSigma β} : x₀ = x₁ ↔ x₀.1 = x₁.1 ∧ HEq x₀.2 x₁.2",
  "args": "{α : Sort _}  {β : α → Sort _} {x₀ x₁ : PSigma β}"},
 {"type": "n = arr.size",
  "tactic-prompt":
  "theorem {arr : Array α}  {m : Fin n → β}  (H : Agrees arr f m) : n = arr.size := by cases H; sorry",
  "name": "size_eq",
  "kind": "theorem",
  "first-tactic": "cases H",
  "core-prompt":
  "{arr : Array α}  {m : Fin n → β}  (H : Agrees arr f m) : n = arr.size",
  "args": "{arr : Array α}  {m : Fin n → β}  (H : Agrees arr f m)"},
 {"type": "∃ (m : UFModel self.arr.size), m.Models self.arr",
  "tactic-prompt":
  "theorem (self : UnionFind α) : ∃ (m : UFModel self.arr.size), m.Models self.arr := by let ⟨n, m, hm⟩ := self.model; sorry",
  "name": "model'",
  "kind": "theorem",
  "first-tactic": "let ⟨n, m, hm⟩ := self.model",
  "core-prompt":
  "(self : UnionFind α) : ∃ (m : UFModel self.arr.size), m.Models self.arr",
  "args": "(self : UnionFind α)"},
 {"type": "self.rank i < self.rankMax",
  "tactic-prompt":
  "theorem (self : UnionFind α)  (i : Nat) : self.rank i < self.rankMax := by simp [rank]; sorry",
  "name": "lt_rankMax",
  "kind": "theorem",
  "first-tactic": "simp [rank]",
  "core-prompt": "(self : UnionFind α)  (i : Nat) : self.rank i < self.rankMax",
  "args": "(self : UnionFind α)  (i : Nat)"},
 {"type":
  "(s : Array (UFNode α)) ×' (root : Fin s.size) ×'\n    ∃ n, ∃ (m : UFModel n) (m' : UFModel n),\n      m.Models self.arr ∧ m'.Models s ∧ m'.rank = m.rank ∧\n      (∃ hr, (m'.parent ⟨root, hr⟩).1 = root) ∧\n      m.rank x ≤ m.rank root",
  "tactic-prompt":
  "def (self : UnionFind α)  (x : Fin self.size) : (s : Array (UFNode α)) ×' (root : Fin s.size) ×'\n    ∃ n, ∃ (m : UFModel n) (m' : UFModel n),\n      m.Models self.arr ∧ m'.Models s ∧ m'.rank = m.rank ∧\n      (∃ hr, (m'.parent ⟨root, hr⟩).1 = root) ∧\n      m.rank x ≤ m.rank root := by have : x < self.arr.size := x.2; sorry",
  "name": "findAux",
  "kind": "def",
  "first-tactic": "have : x < self.arr.size := x.2",
  "core-prompt":
  "(self : UnionFind α)  (x : Fin self.size) : (s : Array (UFNode α)) ×' (root : Fin s.size) ×'\n    ∃ n, ∃ (m : UFModel n) (m' : UFModel n),\n      m.Models self.arr ∧ m'.Models s ∧ m'.rank = m.rank ∧\n      (∃ hr, (m'.parent ⟨root, hr⟩).1 = root) ∧\n      m.rank x ≤ m.rank root",
  "args": "(self : UnionFind α)  (x : Fin self.size)"},
 {"type": "UnionFind α",
  "tactic-prompt":
  "def (self : UnionFind α)  (x y : Fin self.size)    (yroot : (self.arr.get y).parent = y) : UnionFind α := by refine if ne : x.1 = y then self else\n    have hx : x < self.arr.size := x.2\n    have hy : y < self.arr.size := y.2\n    let nx := self.arr[x]\n    let ny := self.arr[y]\n    if h : ny.rank < nx.rank then\n      ⟨self.arr.set y {ny with parent := x}]; sorry",
  "name": "link",
  "kind": "def",
  "first-tactic":
  "refine if ne : x.1 = y then self else\n    have hx : x < self.arr.size := x.2\n    have hy : y < self.arr.size := y.2\n    let nx := self.arr[x]\n    let ny := self.arr[y]\n    if h : ny.rank < nx.rank then\n      ⟨self.arr.set y {ny with parent := x}]",
  "core-prompt":
  "(self : UnionFind α)  (x y : Fin self.size)    (yroot : (self.arr.get y).parent = y) : UnionFind α",
  "args":
  "(self : UnionFind α)  (x y : Fin self.size)    (yroot : (self.arr.get y).parent = y)"},
 {"type": "x.getLeft = none ↔ x.isRight",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : x.getLeft = none ↔ x.isRight := by cases x; sorry",
  "name": "getLeft_eq_none_iff",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : x.getLeft = none ↔ x.isRight",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β}"},
 {"type": "x.getRight = none ↔ x.isLeft",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : x.getRight = none ↔ x.isLeft := by cases x; sorry",
  "name": "getRight_eq_none_iff",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β} : x.getRight = none ↔ x.isLeft",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {x y : Sum α β}"},
 {"type": "Sum.elim f₂ g₂ ∘ Sum.map f₁ g₁ = Sum.elim (f₂ ∘ f₁) (g₂ ∘ g₁)",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} {α β γ δ ε : Sort _}  {f₁ : α → β}  {f₂ : β → ε}  {g₁ : γ → δ}  {g₂ : δ → ε} : Sum.elim f₂ g₂ ∘ Sum.map f₁ g₁ = Sum.elim (f₂ ∘ f₁) (g₂ ∘ g₁) := by ext (_ | _); sorry",
  "name": "elim_comp_map",
  "kind": "theorem",
  "first-tactic": "ext (_ | _)",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} {α β γ δ ε : Sort _}  {f₁ : α → β}  {f₂ : β → ε}  {g₁ : γ → δ}  {g₂ : δ → ε} : Sum.elim f₂ g₂ ∘ Sum.map f₁ g₁ = Sum.elim (f₂ ∘ f₁) (g₂ ∘ g₁)",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} {α β γ δ ε : Sort _}  {f₁ : α → β}  {f₂ : β → ε}  {g₁ : γ → δ}  {g₂ : δ → ε}"},
 {"type": "update f (inl i) x (inl j) = update (f ∘ inl) i x j",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq (Sum α β)]  {f : Sum α β → γ}  {i j : α}      {x : γ} : update f (inl i) x (inl j) = update (f ∘ inl) i x j := by rw [← update_inl_comp_inl]; sorry",
  "name": "update_inl_apply_inl",
  "kind": "theorem",
  "first-tactic": "rw [← update_inl_comp_inl]",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq (Sum α β)]  {f : Sum α β → γ}  {i j : α}      {x : γ} : update f (inl i) x (inl j) = update (f ∘ inl) i x j",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq (Sum α β)]  {f : Sum α β → γ}  {i j : α}      {x : γ}"},
 {"type": "update f (inr i) x (inr j) = update (f ∘ inr) i x j",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq β]  [DecidableEq (Sum α β)]  {f : Sum α β → γ}  {i j : β}      {x : γ} : update f (inr i) x (inr j) = update (f ∘ inr) i x j := by rw [← update_inr_comp_inr]; sorry",
  "name": "update_inr_apply_inr",
  "kind": "theorem",
  "first-tactic": "rw [← update_inr_comp_inr]",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq β]  [DecidableEq (Sum α β)]  {f : Sum α β → γ}  {i j : β}      {x : γ} : update f (inr i) x (inr j) = update (f ∘ inr) i x j",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq β]  [DecidableEq (Sum α β)]  {f : Sum α β → γ}  {i j : β}      {x : γ}"},
 {"type": "swap (swap x) = x",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β) : swap (swap x) = x := by cases x; sorry",
  "name": "swap_swap",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β) : swap (swap x) = x",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (x : Sum α β)"},
 {"type": "LiftRel r₂ s₂ x y",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → γ → Prop}  {s s₁ s₂ : β → δ → Prop}  {a : α}  {b : β}  {c : γ}  {d : δ}    {x : Sum α β}  {y : Sum γ δ} (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ a b, s₁ a b → s₂ a b)    (h : LiftRel r₁ s₁ x y) : LiftRel r₂ s₂ x y := by cases h; sorry",
  "name": "LiftRel.mono",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → γ → Prop}  {s s₁ s₂ : β → δ → Prop}  {a : α}  {b : β}  {c : γ}  {d : δ}    {x : Sum α β}  {y : Sum γ δ} (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ a b, s₁ a b → s₂ a b)    (h : LiftRel r₁ s₁ x y) : LiftRel r₂ s₂ x y",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → γ → Prop}  {s s₁ s₂ : β → δ → Prop}  {a : α}  {b : β}  {c : γ}  {d : δ}    {x : Sum α β}  {y : Sum γ δ} (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ a b, s₁ a b → s₂ a b)    (h : LiftRel r₁ s₁ x y)"},
 {"type": "LiftRel s r x.swap y.swap",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → γ → Prop}  {s s₁ s₂ : β → δ → Prop}  {a : α}  {b : β}  {c : γ}  {d : δ}    {x : Sum α β}  {y : Sum γ δ} (h : LiftRel r s x y) : LiftRel s r x.swap y.swap := by cases h; sorry",
  "name": "LiftRel.swap",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → γ → Prop}  {s s₁ s₂ : β → δ → Prop}  {a : α}  {b : β}  {c : γ}  {d : δ}    {x : Sum α β}  {y : Sum γ δ} (h : LiftRel r s x y) : LiftRel s r x.swap y.swap",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → γ → Prop}  {s s₁ s₂ : β → δ → Prop}  {a : α}  {b : β}  {c : γ}  {d : δ}    {x : Sum α β}  {y : Sum γ δ} (h : LiftRel r s x y)"},
 {"type": "Lex r s a b",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → α → Prop}  {s s₁ s₂ : β → β → Prop}  {a a₁ a₂ : α}  {b b₁ b₂ : β}    {x y : Sum α β} {a b : Sum α β}  (h : LiftRel r s a b) : Lex r s a b := by cases h; sorry",
  "name": "LiftRel.lex",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → α → Prop}  {s s₁ s₂ : β → β → Prop}  {a a₁ a₂ : α}  {b b₁ b₂ : β}    {x y : Sum α β} {a b : Sum α β}  (h : LiftRel r s a b) : Lex r s a b",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → α → Prop}  {s s₁ s₂ : β → β → Prop}  {a a₁ a₂ : α}  {b b₁ b₂ : β}    {x y : Sum α β} {a b : Sum α β}  (h : LiftRel r s a b)"},
 {"type": "Lex r₂ s₂ x y",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → α → Prop}  {s s₁ s₂ : β → β → Prop}  {a a₁ a₂ : α}  {b b₁ b₂ : β}    {x y : Sum α β} (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ a b, s₁ a b → s₂ a b)  (h : Lex r₁ s₁ x y) : Lex r₂ s₂ x y := by cases h; sorry",
  "name": "Lex.mono",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → α → Prop}  {s s₁ s₂ : β → β → Prop}  {a a₁ a₂ : α}  {b b₁ b₂ : β}    {x y : Sum α β} (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ a b, s₁ a b → s₂ a b)  (h : Lex r₁ s₁ x y) : Lex r₂ s₂ x y",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _}  {r r₁ r₂ : α → α → Prop}  {s s₁ s₂ : β → β → Prop}  {a a₁ a₂ : α}  {b b₁ b₂ : β}    {x y : Sum α β} (hr : ∀ a b, r₁ a b → r₂ a b)  (hs : ∀ a b, s₁ a b → s₂ a b)  (h : Lex r₁ s₁ x y)"},
 {"type": "Sum.elim (const _ c : α → γ) (const _ c : β → γ) = const _ c",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (c : γ) : Sum.elim (const _ c : α → γ) (const _ c : β → γ) = const _ c := by ext x; sorry",
  "name": "elim_const_const",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (c : γ) : Sum.elim (const _ c : α → γ) (const _ c : β → γ) = const _ c",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} (c : γ)"},
 {"type":
  "Sum.elim (Function.update f i c) g = Function.update (Sum.elim f g) (inl i) c",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq β]  (f : α → γ)  (g : β → γ)  (i : α)  (c : γ) : Sum.elim (Function.update f i c) g = Function.update (Sum.elim f g) (inl i) c := by ext x; sorry",
  "name": "elim_update_left",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq β]  (f : α → γ)  (g : β → γ)  (i : α)  (c : γ) : Sum.elim (Function.update f i c) g = Function.update (Sum.elim f g) (inl i) c",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq β]  (f : α → γ)  (g : β → γ)  (i : α)  (c : γ)"},
 {"type":
  "Sum.elim f (Function.update g i c) = Function.update (Sum.elim f g) (inr i) c",
  "tactic-prompt":
  "theorem {α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq β]  (f : α → γ)  (g : β → γ)  (i : β)  (c : γ) : Sum.elim f (Function.update g i c) = Function.update (Sum.elim f g) (inr i) c := by ext x; sorry",
  "name": "elim_update_right",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq β]  (f : α → γ)  (g : β → γ)  (i : β)  (c : γ) : Sum.elim f (Function.update g i c) = Function.update (Sum.elim f g) (inr i) c",
  "args":
  "{α : Type u}  {α' : Type w}  {β : Type v}  {β' : Type x}  {γ δ : Type _} [DecidableEq α]  [DecidableEq β]  (f : α → γ)  (g : β → γ)  (i : β)  (c : γ)"},
 {"type": "a.val = b.val → a = b",
  "tactic-prompt":
  "lemma {a b : Fin n} : a.val = b.val → a = b := by cases a; sorry",
  "name": "Fin.ext",
  "kind": "lemma",
  "first-tactic": "cases a",
  "core-prompt": "{a b : Fin n} : a.val = b.val → a = b",
  "args": "{a b : Fin n}"},
 {"type": "(⟨(a : ℕ), h⟩ : Fin n) = a",
  "tactic-prompt":
  "theorem (a : Fin n)  (h : (a : ℕ) < n) : (⟨(a : ℕ), h⟩ : Fin n) = a := by cases a; sorry",
  "name": "Fin.eta",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a : Fin n)  (h : (a : ℕ) < n) : (⟨(a : ℕ), h⟩ : Fin n) = a",
  "args": "(a : Fin n)  (h : (a : ℕ) < n)"},
 {"type": "(Fin.ofNat' a (zero_lt_of_lt h)).val = a",
  "tactic-prompt":
  "lemma {n a : Nat}  (h : a < n) : (Fin.ofNat' a (zero_lt_of_lt h)).val = a := by simp only [Fin.ofNat']; sorry",
  "name": "Fin.val_eq_of_lt",
  "kind": "lemma",
  "first-tactic": "simp only [Fin.ofNat']",
  "core-prompt":
  "{n a : Nat}  (h : a < n) : (Fin.ofNat' a (zero_lt_of_lt h)).val = a",
  "args": "{n a : Nat}  (h : a < n)"},
 {"type": "(1 : Fin (n + 2)).val = 1",
  "tactic-prompt":
  "lemma  : (1 : Fin (n + 2)).val = 1 := by simp only [OfNat.ofNat]; sorry",
  "name": "Fin.one_val",
  "kind": "lemma",
  "first-tactic": "simp only [OfNat.ofNat]",
  "core-prompt": " : (1 : Fin (n + 2)).val = 1",
  "args": ""},
 {"type": "a % b = a",
  "tactic-prompt":
  "theorem {a b : Fin n}  (h : a < b) : a % b = a := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mod_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt": "{a b : Fin n}  (h : a < b) : a % b = a",
  "args": "{a b : Fin n}  (h : a < b)"},
 {"type": "(Fin.checkedAdd a b).isSome = true ↔ a.val + b.val < n",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedAdd a b).isSome = true ↔ a.val + b.val < n := by by_cases n <= a.val + b.val; sorry",
  "name": "Fin.checked_add_spec",
  "kind": "lemma",
  "first-tactic": "by_cases n <= a.val + b.val",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedAdd a b).isSome = true ↔ a.val + b.val < n",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "(Fin.checkedMul a b).isSome = true ↔ a.val * b.val < n",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedMul a b).isSome = true ↔ a.val * b.val < n := by simp only [checkedMul]; sorry",
  "name": "Fin.checked_mul_spec",
  "kind": "lemma",
  "first-tactic": "simp only [checkedMul]",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedMul a b).isSome = true ↔ a.val * b.val < n",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "(Fin.checkedSub a b).isSome = true ↔ b.val <= a.val",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedSub a b).isSome = true ↔ b.val <= a.val := by simp only [checkedSub]; sorry",
  "name": "Fin.checked_sub_spec",
  "kind": "lemma",
  "first-tactic": "simp only [checkedSub]",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedSub a b).isSome = true ↔ b.val <= a.val",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "a * 1 = a",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a : Fin n) : a * 1 = a := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mul_one",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n) : a * 1 = a",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n)"},
 {"type": "a * (b + c) = a * b + a * c",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a b c : Fin n) : a * (b + c) = a * b + a * c := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mul_add",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b c : Fin n) : a * (b + c) = a * b + a * c",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b c : Fin n)"},
 {"type": "∀ (a b : Fin n), a - b = a + -b",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] : ∀ (a b : Fin n), a - b = a + -b := by simp [Fin.add_def]; sorry",
  "name": "Fin.sub_eq_add_neg",
  "kind": "theorem",
  "first-tactic": "simp [Fin.add_def]",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] : ∀ (a b : Fin n), a - b = a + -b",
  "args": "{n : Nat}  [Nonempty (Fin n)]"},
 {"type": "-a + a = 0",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a : Fin n) : -a + a = 0 := by rw [add_comm]; sorry",
  "name": "Fin.add_left_neg",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n) : -a + a = 0",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n)"},
 {"type": "a ≤ b → b ≤ a → a = b",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : a ≤ b → b ≤ a → a = b := by intro h1 h2; sorry",
  "name": "Fin.le_antisymm",
  "kind": "lemma",
  "first-tactic": "intro h1 h2",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : a ≤ b → b ≤ a → a = b",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "(replicate n c).length = n",
  "tactic-prompt":
  "lemma (n : ℕ)  (c : Char) : (replicate n c).length = n := by simp only [String.length]; sorry",
  "name": "length_replicate",
  "kind": "lemma",
  "first-tactic": "simp only [String.length]",
  "core-prompt": "(n : ℕ)  (c : Char) : (replicate n c).length = n",
  "args": "(n : ℕ)  (c : Char)"},
 {"type": "(String.mk l).length = l.length",
  "tactic-prompt":
  "lemma (l : List Char) : (String.mk l).length = l.length := by simp only [String.length]; sorry",
  "name": "length_eq_list_length",
  "kind": "lemma",
  "first-tactic": "simp only [String.length]",
  "core-prompt": "(l : List Char) : (String.mk l).length = l.length",
  "args": "(l : List Char)"},
 {"type": "Prod.map f g p = (f p.1, g p.2)",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : Prod.map f g p = (f p.1, g p.2) := by cases p; sorry",
  "name": "prod_map",
  "kind": "lemma",
  "first-tactic": "cases p",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : Prod.map f g p = (f p.1, g p.2)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β)"},
 {"type": "(map f g p).1 = f (p.1)",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : (map f g p).1 = f (p.1) := by simp; sorry",
  "name": "map_fst",
  "kind": "lemma",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : (map f g p).1 = f (p.1)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β)"},
 {"type": "(map f g p).2 = g (p.2)",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : (map f g p).2 = g (p.2) := by simp; sorry",
  "name": "map_snd",
  "kind": "lemma",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : (map f g p).2 = g (p.2)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β)"},
 {"type": "Prod.map g g' ∘ Prod.map f f' = Prod.map (g ∘ f) (g' ∘ f')",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {ε ζ : Type _}    (f : α → β)  (f' : γ → δ)  (g : β → ε)  (g' : δ → ζ) : Prod.map g g' ∘ Prod.map f f' = Prod.map (g ∘ f) (g' ∘ f') := by ext x; sorry",
  "name": "map_comp_map",
  "kind": "lemma",
  "first-tactic": "ext x",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {ε ζ : Type _}    (f : α → β)  (f' : γ → δ)  (g : β → ε)  (g' : δ → ζ) : Prod.map g g' ∘ Prod.map f f' = Prod.map (g ∘ f) (g' ∘ f')",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {ε ζ : Type _}    (f : α → β)  (f' : γ → δ)  (g : β → ε)  (g' : δ → ζ)"},
 {"type": "Prod.map g g' (Prod.map f f' x) = Prod.map (g ∘ f) (g' ∘ f') x",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {ε ζ : Type _}    (f : α → β)  (f' : γ → δ)  (g : β → ε)  (g' : δ → ζ)  (x : α × γ) : Prod.map g g' (Prod.map f f' x) = Prod.map (g ∘ f) (g' ∘ f') x := by simp; sorry",
  "name": "map_map",
  "kind": "lemma",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {ε ζ : Type _}    (f : α → β)  (f' : γ → δ)  (g : β → ε)  (g' : δ → ζ)  (x : α × γ) : Prod.map g g' (Prod.map f f' x) = Prod.map (g ∘ f) (g' ∘ f') x",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {ε ζ : Type _}    (f : α → β)  (f' : γ → δ)  (g : β → ε)  (g' : δ → ζ)  (x : α × γ)"},
 {"type": "p = q ↔ p.1 = q.1 ∧ p.2 = q.2",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {p q : α × β} : p = q ↔ p.1 = q.1 ∧ p.2 = q.2 := by rw [← @mk.eta _ _ p]; sorry",
  "name": "ext_iff",
  "kind": "lemma",
  "first-tactic": "rw [← @mk.eta _ _ p]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {p q : α × β} : p = q ↔ p.1 = q.1 ∧ p.2 = q.2",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {p q : α × β}"},
 {"type": "Prod.map f g = λ p => (f p.1, g p.2)",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ} : Prod.map f g = λ p => (f p.1, g p.2) := by ext; sorry",
  "name": "map_def",
  "kind": "lemma",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ} : Prod.map f g = λ p => (f p.1, g p.2)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ}"},
 {"type": "Injective (Prod.map f g)",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ}  (hf : Injective f)  (hg : Injective g) : Injective (Prod.map f g) := by intros x y h; sorry",
  "name": "Function.Injective.prod_map",
  "kind": "lemma",
  "first-tactic": "intros x y h",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ}  (hf : Injective f)  (hg : Injective g) : Injective (Prod.map f g)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ}  (hf : Injective f)  (hg : Injective g)"},
 {"type": "0 < UInt8.size",
  "tactic-prompt": "lemma  : 0 < UInt8.size := by decide; sorry",
  "name": "UInt8.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt8.size",
  "args": ""},
 {"type": "0 < UInt16.size",
  "tactic-prompt": "lemma  : 0 < UInt16.size := by decide; sorry",
  "name": "UInt16.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt16.size",
  "args": ""},
 {"type": "0 < UInt32.size",
  "tactic-prompt": "lemma  : 0 < UInt32.size := by decide; sorry",
  "name": "UInt32.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt32.size",
  "args": ""},
 {"type": "0 < UInt64.size",
  "tactic-prompt": "lemma  : 0 < UInt64.size := by decide; sorry",
  "name": "UInt64.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt64.size",
  "args": ""},
 {"type": "Nat.isValidChar (UInt32.ofNat n).1",
  "tactic-prompt":
  "theorem (n : Nat)  (h : n < size) : Nat.isValidChar (UInt32.ofNat n).1 := by rw [UInt32.val_eq_of_lt]; sorry",
  "name": "toChar_aux",
  "kind": "theorem",
  "first-tactic": "rw [UInt32.val_eq_of_lt]",
  "core-prompt":
  "(n : Nat)  (h : n < size) : Nat.isValidChar (UInt32.ofNat n).1",
  "args": "(n : Nat)  (h : n < size)"},
 {"type": "0 < c.utf8Size",
  "tactic-prompt":
  "theorem (c : Char) : 0 < c.utf8Size := by simp only [utf8Size]; sorry",
  "name": "Char.utf8Size_pos",
  "kind": "theorem",
  "first-tactic": "simp only [utf8Size]",
  "core-prompt": "(c : Char) : 0 < c.utf8Size",
  "args": "(c : Char)"},
 {"type": "m ∈ range n ↔ m < n",
  "tactic-prompt":
  "theorem {m n : ℕ} : m ∈ range n ↔ m < n := by simp only [range_eq_range']; sorry",
  "name": "mem_range",
  "kind": "theorem",
  "first-tactic": "simp only [range_eq_range']",
  "core-prompt": "{m n : ℕ} : m ∈ range n ↔ m < n",
  "args": "{m n : ℕ}"},
 {"type": "Nodup (range n)",
  "tactic-prompt":
  "theorem (n : ℕ) : Nodup (range n) := by simp only [range_eq_range']; sorry",
  "name": "nodup_range",
  "kind": "theorem",
  "first-tactic": "simp only [range_eq_range']",
  "core-prompt": "(n : ℕ) : Nodup (range n)",
  "args": "(n : ℕ)"},
 {"type": "∃ s t : List α, l = s ++ a :: t",
  "tactic-prompt":
  "theorem {a : α}  {l : List α}  (h : a ∈ l) : ∃ s t : List α, l = s ++ a :: t := by induction l; sorry",
  "name": "mem_split",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : α}  {l : List α}  (h : a ∈ l) : ∃ s t : List α, l = s ++ a :: t",
  "args": "{a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "Injective (List.length : List α → ℕ) ↔ Subsingleton α",
  "tactic-prompt":
  "lemma  : Injective (List.length : List α → ℕ) ↔ Subsingleton α := by constructor; sorry",
  "name": "length_injective_iff",
  "kind": "lemma",
  "first-tactic": "constructor",
  "core-prompt": " : Injective (List.length : List α → ℕ) ↔ Subsingleton α",
  "args": ""},
 {"type": "i = j",
  "tactic-prompt":
  "theorem {α : Type u}  {xs : List α}  {i j : ℕ}    (h₀ : i < xs.length)    (h₁ : Nodup xs)    (h₂ : xs.get? i = xs.get? j) : i = j := by induction xs generalizing i j with\n  | nil => cases h₀\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases h₁ with\n      | cons ha h₁ => exact ih (Nat.lt_of_succ_lt_succ h₀) h₁ h₂\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at h₂\n      cases h₁; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact ⟨_, h₂⟩; exact ⟨_ , h₂.symm⟩; sorry",
  "name": "get?_injective",
  "kind": "theorem",
  "first-tactic":
  "induction xs generalizing i j with\n  | nil => cases h₀\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases h₁ with\n      | cons ha h₁ => exact ih (Nat.lt_of_succ_lt_succ h₀) h₁ h₂\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at h₂\n      cases h₁; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact ⟨_, h₂⟩; exact ⟨_ , h₂.symm⟩",
  "core-prompt":
  "{α : Type u}  {xs : List α}  {i j : ℕ}    (h₀ : i < xs.length)    (h₁ : Nodup xs)    (h₂ : xs.get? i = xs.get? j) : i = j",
  "args":
  "{α : Type u}  {xs : List α}  {i j : ℕ}    (h₀ : i < xs.length)    (h₁ : Nodup xs)    (h₂ : xs.get? i = xs.get? j)"},
 {"type": "(x, y) ∈ product xs ys ↔ x ∈ xs ∧ y ∈ ys",
  "tactic-prompt":
  "theorem (xs : List α)  (ys : List β)  (x : α)  (y : β) : (x, y) ∈ product xs ys ↔ x ∈ xs ∧ y ∈ ys := by constructor; sorry",
  "name": "product_spec",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "(xs : List α)  (ys : List β)  (x : α)  (y : β) : (x, y) ∈ product xs ys ↔ x ∈ xs ∧ y ∈ ys",
  "args": "(xs : List α)  (ys : List β)  (x : α)  (y : β)"},
 {"type": "l.attach.map Subtype.val = l",
  "tactic-prompt":
  "theorem (l : List α) : l.attach.map Subtype.val = l := by rw [attach]; sorry",
  "name": "attach_map_val",
  "kind": "theorem",
  "first-tactic": "rw [attach]",
  "core-prompt": "(l : List α) : l.attach.map Subtype.val = l",
  "args": "(l : List α)"},
 {"type": "l₂ ~ l₁",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  (p : l₁ ~ l₂) : l₂ ~ l₁ := by induction p; sorry",
  "name": "Perm.symm",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{l₁ l₂ : List α}  (p : l₁ ~ l₂) : l₂ ~ l₁",
  "args": "{l₁ l₂ : List α}  (p : l₁ ~ l₂)"},
 {"type": "l₁ ⊆ l₂",
  "tactic-prompt":
  "theorem {α : Type u}  {l₁ l₂ : List α}  (p : l₁ ~ l₂) : l₁ ⊆ l₂ := by induction p; sorry",
  "name": "Perm.subset",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{α : Type u}  {l₁ l₂ : List α}  (p : l₁ ~ l₂) : l₁ ⊆ l₂",
  "args": "{α : Type u}  {l₁ l₂ : List α}  (p : l₁ ~ l₂)"},
 {"type": "l₁ ++ a :: r₁ ~ l₂ ++ a :: r₂ → l₁ ++ r₁ ~ l₂ ++ r₂",
  "tactic-prompt":
  "theorem {a : α}  {l₁ l₂ r₁ r₂ : List α} : l₁ ++ a :: r₁ ~ l₂ ++ a :: r₂ → l₁ ++ r₁ ~ l₂ ++ r₂ := by generalize e₁ : l₁ ++ a :: r₁ = s₁; sorry",
  "name": "perm_inv_core",
  "kind": "theorem",
  "first-tactic": "generalize e₁ : l₁ ++ a :: r₁ = s₁",
  "core-prompt":
  "{a : α}  {l₁ l₂ r₁ r₂ : List α} : l₁ ++ a :: r₁ ~ l₂ ++ a :: r₂ → l₁ ++ r₁ ~ l₂ ++ r₂",
  "args": "{a : α}  {l₁ l₂ r₁ r₂ : List α}"},
 {"type": "length l₁ = length l₂",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  (p : l₁ ~ l₂) : length l₁ = length l₂ := by induction p; sorry",
  "name": "Perm.length_eq",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{l₁ l₂ : List α}  (p : l₁ ~ l₂) : length l₁ = length l₂",
  "args": "{l₁ l₂ : List α}  (p : l₁ ~ l₂)"},
 {"type": "∀ {l₁ l₂ : List α}, l₁ ~ l₂ → (Pairwise R l₁ ↔ Pairwise R l₂)",
  "tactic-prompt":
  "theorem {R : α → α → Prop}  (S : Symmetric R) : ∀ {l₁ l₂ : List α}, l₁ ~ l₂ → (Pairwise R l₁ ↔ Pairwise R l₂) := by suffices ∀ {l₁ l₂}, l₁ ~ l₂ → Pairwise R l₁ → Pairwise R l₂ from\n    fun l₁ l₂ p => ⟨this p, this p.symm⟩; sorry",
  "name": "Perm.pairwise_iff",
  "kind": "theorem",
  "first-tactic":
  "suffices ∀ {l₁ l₂}, l₁ ~ l₂ → Pairwise R l₁ → Pairwise R l₂ from\n    fun l₁ l₂ p => ⟨this p, this p.symm⟩",
  "core-prompt":
  "{R : α → α → Prop}  (S : Symmetric R) : ∀ {l₁ l₂ : List α}, l₁ ~ l₂ → (Pairwise R l₁ ↔ Pairwise R l₂)",
  "args": "{R : α → α → Prop}  (S : Symmetric R)"},
 {"type": "Pairwise R (l₁ ++ l₂) ↔ Pairwise R (l₂ ++ l₁)",
  "tactic-prompt":
  "theorem {α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} (s : Symmetric R)  {l₁ l₂ : List α} : Pairwise R (l₁ ++ l₂) ↔ Pairwise R (l₂ ++ l₁) := by have : ∀ l₁ l₂ : List α, (∀ x : α, x ∈ l₁ → ∀ y : α, y ∈ l₂ → R x y) →\n    ∀ x : α, x ∈ l₂ → ∀ y : α, y ∈ l₁ → R x y := fun l₁ l₂ a x xm y ym => s (a y ym x xm); sorry",
  "name": "pairwise_append_comm",
  "kind": "theorem",
  "first-tactic":
  "have : ∀ l₁ l₂ : List α, (∀ x : α, x ∈ l₁ → ∀ y : α, y ∈ l₂ → R x y) →\n    ∀ x : α, x ∈ l₂ → ∀ y : α, y ∈ l₁ → R x y := fun l₁ l₂ a x xm y ym => s (a y ym x xm)",
  "core-prompt":
  "{α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} (s : Symmetric R)  {l₁ l₂ : List α} : Pairwise R (l₁ ++ l₂) ↔ Pairwise R (l₂ ++ l₁)",
  "args":
  "{α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} (s : Symmetric R)  {l₁ l₂ : List α}"},
 {"type": "Pairwise S l",
  "tactic-prompt":
  "theorem {α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} {S : α → α → Prop}  {l : List α}      (H : ∀ {a b}, a ∈ l → b ∈ l → R a b → S a b)  (p : Pairwise R l) : Pairwise S l := by induction p; sorry",
  "name": "Pairwise.imp_of_mem",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} {S : α → α → Prop}  {l : List α}      (H : ∀ {a b}, a ∈ l → b ∈ l → R a b → S a b)  (p : Pairwise R l) : Pairwise S l",
  "args":
  "{α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} {S : α → α → Prop}  {l : List α}      (H : ∀ {a b}, a ∈ l → b ∈ l → R a b → S a b)  (p : Pairwise R l)"},
 {"type": "b ∈ remove a as ↔ b ∈ as ∧ b ≠ a",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α} : b ∈ remove a as ↔ b ∈ as ∧ b ≠ a := by induction as; sorry",
  "name": "mem_remove_iff",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α} : b ∈ remove a as ↔ b ∈ as ∧ b ≠ a",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α}"},
 {"type": "b ∈ as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α}  (h : b ∈ remove a as) : b ∈ as := by rw [mem_remove_iff] at h; sorry",
  "name": "mem_of_mem_remove",
  "kind": "theorem",
  "first-tactic": "rw [mem_remove_iff] at h",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α}  (h : b ∈ remove a as) : b ∈ as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α}  (h : b ∈ remove a as)"},
 {"type": "card (a :: as) = card as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as) : card (a :: as) = card as := by simp [card]; sorry",
  "name": "card_cons_of_mem",
  "kind": "theorem",
  "first-tactic": "simp [card]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as) : card (a :: as) = card as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as)"},
 {"type": "card (a :: as) = card as + 1",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as) : card (a :: as) = card as + 1 := by simp [card]; sorry",
  "name": "card_cons_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp [card]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as) : card (a :: as) = card as + 1",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as)"},
 {"type": "card as ≤ card (a :: as)",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ (a : α)  (as : List α) : card as ≤ card (a :: as) := by cases Decidable.em (a ∈ as); sorry",
  "name": "card_le_card_cons",
  "kind": "theorem",
  "first-tactic": "cases Decidable.em (a ∈ as)",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ (a : α)  (as : List α) : card as ≤ card (a :: as)",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ (a : α)  (as : List α)"},
 {"type": "card (as.insert a) = card as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as) : card (as.insert a) = card as := by simp [h]; sorry",
  "name": "card_insert_of_mem",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as) : card (as.insert a) = card as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as)"},
 {"type": "card (as.insert a) = card as + 1",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as) : card (as.insert a) = card as + 1 := by simp [h]; sorry",
  "name": "card_insert_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as) : card (as.insert a) = card as + 1",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as)"},
 {"type": "card (as.map f) ≤ card as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ (f : α → β)  (as : List α) : card (as.map f) ≤ card as := by induction as; sorry",
  "name": "card_map_le",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ (f : α → β)  (as : List α) : card (as.map f) ≤ card as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ (f : α → β)  (as : List α)"},
 {"type": "inj_on f as →  card (as.map f) = card as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {f : α → β}  {as : List α} : inj_on f as →  card (as.map f) = card as := by induction as; sorry",
  "name": "card_map_eq_of_inj_on",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {f : α → β}  {as : List α} : inj_on f as →  card (as.map f) = card as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {f : α → β}  {as : List α}"},
 {"type": "card (as.union bs) = card as + card bs",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {as bs : List α}  (h : Disjoint as bs) : card (as.union bs) = card as + card bs := by rw [card_eq_of_equiv (union_equiv_append as bs)]; sorry",
  "name": "card_union_disjoint",
  "kind": "theorem",
  "first-tactic": "rw [card_eq_of_equiv (union_equiv_append as bs)]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {as bs : List α}  (h : Disjoint as bs) : card (as.union bs) = card as + card bs",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {as bs : List α}  (h : Disjoint as bs)"},
 {"type": "Chain S b l",
  "tactic-prompt":
  "theorem {R S : α → α → Prop}  (HRS : ∀ ⦃a b⦄, R a b → S a b)  {a b : α}      (Hab : ∀ ⦃c⦄, R a c → S b c)  {l : List α}  (p : Chain R a l) : Chain S b l := by induction p generalizing b with\n  | nil => constructor\n  | cons r _ ih =>\n    constructor\n    · exact Hab r\n    · exact ih (@HRS _); sorry",
  "name": "Chain.imp'",
  "kind": "theorem",
  "first-tactic":
  "induction p generalizing b with\n  | nil => constructor\n  | cons r _ ih =>\n    constructor\n    · exact Hab r\n    · exact ih (@HRS _)",
  "core-prompt":
  "{R S : α → α → Prop}  (HRS : ∀ ⦃a b⦄, R a b → S a b)  {a b : α}      (Hab : ∀ ⦃c⦄, R a c → S b c)  {l : List α}  (p : Chain R a l) : Chain S b l",
  "args":
  "{R S : α → α → Prop}  (HRS : ∀ ⦃a b⦄, R a b → S a b)  {a b : α}      (Hab : ∀ ⦃c⦄, R a c → S b c)  {l : List α}  (p : Chain R a l)"},
 {"type": "Chain R a l",
  "tactic-prompt":
  "theorem (p : Pairwise R (a :: l)) : Chain R a l := by rcases Pairwise_cons.1 p with ⟨r,p'⟩; sorry",
  "name": "Pairwise.chain",
  "kind": "theorem",
  "first-tactic": "rcases Pairwise_cons.1 p with ⟨r,p'⟩",
  "core-prompt": "(p : Pairwise R (a :: l)) : Chain R a l",
  "args": "(p : Pairwise R (a :: l))"},
 {"type": "a ∈ some b ↔ b = a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {α : Type _}  {a b : α} : a ∈ some b ↔ b = a := by simp; sorry",
  "name": "mem_some_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {α : Type _}  {a b : α} : a ∈ some b ↔ b = a",
  "args":
  "{α : Type _}  {β : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {α : Type _}  {a b : α}"},
 {"type": "a ∈ toList o ↔ a ∈ o",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {a : α}  {o : Option α} : a ∈ toList o ↔ a ∈ o := by cases o; sorry",
  "name": "mem_toList",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{α : Type _}  {β : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {a : α}  {o : Option α} : a ∈ toList o ↔ a ∈ o",
  "args":
  "{α : Type _}  {β : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {a : α}  {o : Option α}"},
 {"type": "x < y ↔ x ≤ y ∧ ∃ i, x i < y i",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α} {ι : Type u}  {α: ι → Type v}  [∀ i, Preorder (α i)]  {x y : ∀ i, α i} : x < y ↔ x ≤ y ∧ ∃ i, x i < y i := by simp ( config := { contextual := true } ) [lt_iff_le_not_le]; sorry",
  "name": "Pi.lt_def",
  "kind": "theorem",
  "first-tactic":
  "simp ( config := { contextual := true } ) [lt_iff_le_not_le]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α} {ι : Type u}  {α: ι → Type v}  [∀ i, Preorder (α i)]  {x y : ∀ i, α i} : x < y ↔ x ≤ y ∧ ∃ i, x i < y i",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α} {ι : Type u}  {α: ι → Type v}  [∀ i, Preorder (α i)]  {x y : ∀ i, α i}"},
 {"type":
  "Function.update x i a ≤ Function.update y i b ↔ a ≤ b ∧ ∀ j, j ≠ i → x j ≤ y j",
  "tactic-prompt":
  "lemma {α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α} {ι : Type u}  {α : ι → Type v}  [∀ i, Preorder (α i)]  [DecidableEq ι]    {x y : ∀ i, α i}  {i : ι}  {a b : α i} : Function.update x i a ≤ Function.update y i b ↔ a ≤ b ∧ ∀ j, j ≠ i → x j ≤ y j := by simp (config := {contextual := true}) [update_le_iff]; sorry",
  "name": "update_le_update_iff",
  "kind": "lemma",
  "first-tactic": "simp (config := {contextual := true}) [update_le_iff]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α} {ι : Type u}  {α : ι → Type v}  [∀ i, Preorder (α i)]  [DecidableEq ι]    {x y : ∀ i, α i}  {i : ι}  {a b : α i} : Function.update x i a ≤ Function.update y i b ↔ a ≤ b ∧ ∀ j, j ≠ i → x j ≤ y j",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α} {ι : Type u}  {α : ι → Type v}  [∀ i, Preorder (α i)]  [DecidableEq ι]    {x y : ∀ i, α i}  {i : ι}  {a b : α i}"},
 {"type":
  "(instPreorderProd _ _).lt x y ↔ x.1 < y.1 ∧ x.2 ≤ y.2 ∨ x.1 ≤ y.1 ∧ x.2 < y.2",
  "tactic-prompt":
  "lemma {α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [Preorder α]  [Preorder β]  {a a₁ a₂ : α}  {b b₁ b₂ : β}  {x y : α × β} : (instPreorderProd _ _).lt x y ↔ x.1 < y.1 ∧ x.2 ≤ y.2 ∨ x.1 ≤ y.1 ∧ x.2 < y.2 := by refine Iff.intro ?_ ?_; sorry",
  "name": "lt_iff",
  "kind": "lemma",
  "first-tactic": "refine Iff.intro ?_ ?_",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [Preorder α]  [Preorder β]  {a a₁ a₂ : α}  {b b₁ b₂ : β}  {x y : α × β} : (instPreorderProd _ _).lt x y ↔ x.1 < y.1 ∧ x.2 ≤ y.2 ∨ x.1 ≤ y.1 ∧ x.2 < y.2",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [Preorder α]  [Preorder β]  {a a₁ a₂ : α}  {b b₁ b₂ : β}  {x y : α × β}"}]