[{"type": "HEq f f'",
  "tactic-prompt":
  "lemma {α β γ : Sort _}  {f : α → β} {α α': Sort u}  {β : α → Sort v}  {β' : α' → Sort v}  {f : ∀a, β a}  {f' : ∀a, β' a}    (hα : α = α')  (h : ∀a a', HEq a a' → HEq (f a) (f' a')) : HEq f f' := by subst hα; sorry",
  "name": "hfunext",
  "kind": "lemma",
  "first-tactic": "subst hα",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} {α α': Sort u}  {β : α → Sort v}  {β' : α' → Sort v}  {f : ∀a, β a}  {f' : ∀a, β' a}    (hα : α = α')  (h : ∀a a', HEq a a' → HEq (f a) (f' a')) : HEq f f'",
  "args":
  "{α β γ : Sort _}  {f : α → β} {α α': Sort u}  {β : α → Sort v}  {β' : α' → Sort v}  {f : ∀a, β a}  {f' : ∀a, β' a}    (hα : α = α')  (h : ∀a a', HEq a a' → HEq (f a) (f' a'))"},
 {"type": "Function.injective (λ x => if h : p x then f ⟨x, h⟩ else f' ⟨x, h⟩)",
  "tactic-prompt":
  "lemma {α β γ : Sort _}  {f : α → β} (p : α → Prop)  [DecidablePred p]    {f : {a : α // p a} → β}  {f' : {a : α // ¬ p a} → β}    (hf : injective f)  (hf' : injective f')    (im_disj : ∀ {x x' : α} {hx : p x} {hx' : ¬ p x'}, f ⟨x, hx⟩ ≠ f' ⟨x', hx'⟩) : Function.injective (λ x => if h : p x then f ⟨x, h⟩ else f' ⟨x, h⟩) := by intros x₁ x₂ h; sorry",
  "name": "injective.dite",
  "kind": "lemma",
  "first-tactic": "intros x₁ x₂ h",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} (p : α → Prop)  [DecidablePred p]    {f : {a : α // p a} → β}  {f' : {a : α // ¬ p a} → β}    (hf : injective f)  (hf' : injective f')    (im_disj : ∀ {x x' : α} {hx : p x} {hx' : ¬ p x'}, f ⟨x, hx⟩ ≠ f' ⟨x', hx'⟩) : Function.injective (λ x => if h : p x then f ⟨x, h⟩ else f' ⟨x, h⟩)",
  "args":
  "{α β γ : Sort _}  {f : α → β} (p : α → Prop)  [DecidablePred p]    {f : {a : α // p a} → β}  {f' : {a : α // ¬ p a} → β}    (hf : injective f)  (hf' : injective f')    (im_disj : ∀ {x x' : α} {hx : p x} {hx' : ¬ p x'}, f ⟨x, hx⟩ ≠ f' ⟨x', hx'⟩)"},
 {"type": "g₁ = g₂",
  "tactic-prompt":
  "theorem {α β γ : Sort _}  {f : α → β} {f : α → β}  {g₁ g₂ : β → α}  (h₁ : LeftInverse g₁ f)    (h₂ : Function.RightInverse g₂ f) : g₁ = g₂ := by have h₃ : g₁ = g₁ ∘ f ∘ g₂ := by rw [h₂.comp_eq_id, comp.right_id]; sorry",
  "name": "LeftInverse.eq_RightInverse",
  "kind": "theorem",
  "first-tactic":
  "have h₃ : g₁ = g₁ ∘ f ∘ g₂ := by rw [h₂.comp_eq_id, comp.right_id]",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} {f : α → β}  {g₁ g₂ : β → α}  (h₁ : LeftInverse g₁ f)    (h₂ : Function.RightInverse g₂ f) : g₁ = g₂",
  "args":
  "{α β γ : Sort _}  {f : α → β} {f : α → β}  {g₁ g₂ : β → α}  (h₁ : LeftInverse g₁ f)    (h₂ : Function.RightInverse g₂ f)"},
 {"type": "inv_fun_on f s b ∈ s ∧ f (inv_fun_on f s b) = b",
  "tactic-prompt":
  "theorem {α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ∃a∈s, f a = b) : inv_fun_on f s b ∈ s ∧ f (inv_fun_on f s b) = b := by have h1 : inv_fun_on f s b =\n     if h : ∃a, a ∈ s ∧ f a = b then Classical.choose h else Classical.choice n := rfl; sorry",
  "name": "inv_fun_on_pos",
  "kind": "theorem",
  "first-tactic":
  "have h1 : inv_fun_on f s b =\n     if h : ∃a, a ∈ s ∧ f a = b then Classical.choose h else Classical.choice n := rfl",
  "core-prompt":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ∃a∈s, f a = b) : inv_fun_on f s b ∈ s ∧ f (inv_fun_on f s b) = b",
  "args":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ∃a∈s, f a = b)"},
 {"type": "inv_fun_on f s b = Classical.choice n",
  "tactic-prompt":
  "theorem {α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃a∈s, f a = b) : inv_fun_on f s b = Classical.choice n := by have h1 : inv_fun_on f s b =\n     if h : ∃a, a ∈ s ∧ f a = b then Classical.choose h else Classical.choice n := rfl; sorry",
  "name": "inv_fun_on_neg",
  "kind": "theorem",
  "first-tactic":
  "have h1 : inv_fun_on f s b =\n     if h : ∃a, a ∈ s ∧ f a = b then Classical.choose h else Classical.choice n := rfl",
  "core-prompt":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃a∈s, f a = b) : inv_fun_on f s b = Classical.choice n",
  "args":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃a∈s, f a = b)"},
 {"type": "inv_fun f b = Classical.choice n",
  "tactic-prompt":
  "lemma {α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃ a, f a = b) : inv_fun f b = Classical.choice n := by refine inv_fun_on_neg (mt ?_ h); sorry",
  "name": "inv_fun_neg",
  "kind": "lemma",
  "first-tactic": "refine inv_fun_on_neg (mt ?_ h)",
  "core-prompt":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃ a, f a = b) : inv_fun f b = Classical.choice n",
  "args":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃ a, f a = b)"},
 {"type": "update f a' b a = if a = a' then b else f a",
  "tactic-prompt":
  "lemma {α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {β : Sort _}  (f : α → β)  (a' : α)  (b : β)  (a : α) : update f a' b a = if a = a' then b else f a := by have h2 : (h : a = a') → Eq.rec (motive := λ _ _ => β) b h.symm = b :=\n     by intro h\n        rw [eq_rec_constant]; sorry",
  "name": "update_apply",
  "kind": "lemma",
  "first-tactic":
  "have h2 : (h : a = a') → Eq.rec (motive := λ _ _ => β) b h.symm = b :=\n     by intro h\n        rw [eq_rec_constant]",
  "core-prompt":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {β : Sort _}  (f : α → β)  (a' : α)  (b : β)  (a : α) : update f a' b a = if a = a' then b else f a",
  "args":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {β : Sort _}  (f : α → β)  (a' : α)  (b : β)  (a : α)"},
 {"type": "injective (update f a')",
  "tactic-prompt":
  "lemma {α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] (f : ∀a, β a)  (a' : α) : injective (update f a') := by intros v v' h; sorry",
  "name": "update_injective",
  "kind": "lemma",
  "first-tactic": "intros v v' h",
  "core-prompt":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] (f : ∀a, β a)  (a' : α) : injective (update f a')",
  "args":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] (f : ∀a, β a)  (a' : α)"},
 {"type": "f j (update g i v j) = update (λ k => f k (g k)) i (f i v) j",
  "tactic-prompt":
  "lemma {α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {ι : Sort _}  [DecidableEq ι]  {α β : ι → Sort _}    (f : ∀i, α i → β i)  (g : ∀i, α i)  (i : ι)  (v : α i)  (j : ι) : f j (update g i v j) = update (λ k => f k (g k)) i (f i v) j := by by_cases h : j = i; sorry",
  "name": "apply_update",
  "kind": "lemma",
  "first-tactic": "by_cases h : j = i",
  "core-prompt":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {ι : Sort _}  [DecidableEq ι]  {α β : ι → Sort _}    (f : ∀i, α i → β i)  (g : ∀i, α i)  (i : ι)  (v : α i)  (j : ι) : f j (update g i v j) = update (λ k => f k (g k)) i (f i v) j",
  "args":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {ι : Sort _}  [DecidableEq ι]  {α β : ι → Sort _}    (f : ∀i, α i → β i)  (g : ∀i, α i)  (i : ι)  (v : α i)  (j : ι)"},
 {"type":
  "extend f g e' b = if h : ∃ a, f a = b then g (Classical.choose h) else e' b",
  "tactic-prompt":
  "lemma {α β γ : Type _}  {f : α → β} (f : α → β)  (g : α → γ)  (e' : β → γ)  (b : β)  [hd : Decidable (∃ a, f a = b)] : extend f g e' b = if h : ∃ a, f a = b then g (Classical.choose h) else e' b := by rw [Subsingleton.elim hd]; sorry",
  "name": "extend_def",
  "kind": "lemma",
  "first-tactic": "rw [Subsingleton.elim hd]",
  "core-prompt":
  "{α β γ : Type _}  {f : α → β} (f : α → β)  (g : α → γ)  (e' : β → γ)  (b : β)  [hd : Decidable (∃ a, f a = b)] : extend f g e' b = if h : ∃ a, f a = b then g (Classical.choose h) else e' b",
  "args":
  "{α β γ : Type _}  {f : α → β} (f : α → β)  (g : α → γ)  (e' : β → γ)  (b : β)  [hd : Decidable (∃ a, f a = b)]"},
 {"type": "extend f g e' (f a) = g a",
  "tactic-prompt":
  "lemma {α β γ : Type _}  {f : α → β} (hf : injective f)  (g : α → γ)  (e' : β → γ)  (a : α) : extend f g e' (f a) = g a := by simp only [extend_def, dif_pos, exists_apply_eq_apply]; sorry",
  "name": "extend_apply",
  "kind": "lemma",
  "first-tactic": "simp only [extend_def, dif_pos, exists_apply_eq_apply]",
  "core-prompt":
  "{α β γ : Type _}  {f : α → β} (hf : injective f)  (g : α → γ)  (e' : β → γ)  (a : α) : extend f g e' (f a) = g a",
  "args":
  "{α β γ : Type _}  {f : α → β} (hf : injective f)  (g : α → γ)  (e' : β → γ)  (a : α)"},
 {"type": "uncurry (bicompl f g h) = (uncurry f) ∘ (Prod.map g h)",
  "tactic-prompt":
  "lemma (f : γ → δ → ε)  (g : α → γ)  (h : β → δ) : uncurry (bicompl f g h) = (uncurry f) ∘ (Prod.map g h) := by ext ⟨x, y⟩; sorry",
  "name": "uncurry_bicompl",
  "kind": "lemma",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "(f : γ → δ → ε)  (g : α → γ)  (h : β → δ) : uncurry (bicompl f g h) = (uncurry f) ∘ (Prod.map g h)",
  "args": "(f : γ → δ → ε)  (g : α → γ)  (h : β → δ)"},
 {"type": "f (ite P x (f x)) = ite (¬ P) x (f x)",
  "tactic-prompt":
  "lemma {α : Sort u}  {f : α → α}  (h : involutive f) (P : Prop)  [Decidable P]  (x : α) : f (ite P x (f x)) = ite (¬ P) x (f x) := by rw [apply_ite f, h, ite_not]; sorry",
  "name": "ite_not",
  "kind": "lemma",
  "first-tactic": "rw [apply_ite f, h, ite_not]",
  "core-prompt":
  "{α : Sort u}  {f : α → α}  (h : involutive f) (P : Prop)  [Decidable P]  (x : α) : f (ite P x (f x)) = ite (¬ P) x (f x)",
  "args":
  "{α : Sort u}  {f : α → α}  (h : involutive f) (P : Prop)  [Decidable P]  (x : α)"},
 {"type": "xor True = Not",
  "tactic-prompt":
  "theorem {a b c d : Prop} : xor True = Not := by simp [xor]; sorry",
  "name": "xor_true",
  "kind": "theorem",
  "first-tactic": "simp [xor]",
  "core-prompt": "{a b c d : Prop} : xor True = Not",
  "args": "{a b c d : Prop}"},
 {"type": "xor False = id",
  "tactic-prompt": "theorem {a b c d : Prop} : xor False = id := by ext; sorry",
  "name": "xor_false",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt": "{a b c d : Prop} : xor False = id",
  "args": "{a b c d : Prop}"},
 {"type": "xor a a = False",
  "tactic-prompt":
  "theorem {a b c d : Prop} (a : Prop) : xor a a = False := by simp [xor]; sorry",
  "name": "xor_self",
  "kind": "theorem",
  "first-tactic": "simp [xor]",
  "core-prompt": "{a b c d : Prop} (a : Prop) : xor a a = False",
  "args": "{a b c d : Prop} (a : Prop)"},
 {"type": "p ∧ a = b ↔ p ∧ b = a",
  "tactic-prompt":
  "theorem {a b c d : Prop} (a b : α)  (p : Prop) : p ∧ a = b ↔ p ∧ b = a := by simp [eq_comm]; sorry",
  "name": "and_symm_right",
  "kind": "theorem",
  "first-tactic": "simp [eq_comm]",
  "core-prompt":
  "{a b c d : Prop} (a b : α)  (p : Prop) : p ∧ a = b ↔ p ∧ b = a",
  "args": "{a b c d : Prop} (a b : α)  (p : Prop)"},
 {"type": "a = b ∧ p ↔ b = a ∧ p",
  "tactic-prompt":
  "theorem {a b c d : Prop} (a b : α)  (p : Prop) : a = b ∧ p ↔ b = a ∧ p := by simp [eq_comm]; sorry",
  "name": "and_symm_left",
  "kind": "theorem",
  "first-tactic": "simp [eq_comm]",
  "core-prompt":
  "{a b c d : Prop} (a b : α)  (p : Prop) : a = b ∧ p ↔ b = a ∧ p",
  "args": "{a b c d : Prop} (a b : α)  (p : Prop)"},
 {"type": "c → t",
  "tactic-prompt":
  "lemma {a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {c t e : Prop}  [Decidable c]  (h : ite c t e) : c → t := by intro hc; sorry",
  "name": "imp_of_if_pos",
  "kind": "lemma",
  "first-tactic": "intro hc",
  "core-prompt":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {c t e : Prop}  [Decidable c]  (h : ite c t e) : c → t",
  "args":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {c t e : Prop}  [Decidable c]  (h : ite c t e)"},
 {"type": "¬c → e",
  "tactic-prompt":
  "lemma {a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {c t e : Prop}  [Decidable c]  (h : ite c t e) : ¬c → e := by intro hnc; sorry",
  "name": "imp_of_if_neg",
  "kind": "lemma",
  "first-tactic": "intro hnc",
  "core-prompt":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {c t e : Prop}  [Decidable c]  (h : ite c t e) : ¬c → e",
  "args":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {c t e : Prop}  [Decidable c]  (h : ite c t e)"},
 {"type": "a₁ = a₂ → HEq (let x : α := a₁; b x) (let x : α := a₂; b x)",
  "tactic-prompt":
  "lemma {a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {α : Sort v}  {β : α → Sort u}  {a₁ a₂ : α}  (b : ∀ x : α, β x) : a₁ = a₂ → HEq (let x : α := a₁; b x) (let x : α := a₂; b x) := by intro h; sorry",
  "name": "let_value_heq",
  "kind": "lemma",
  "first-tactic": "intro h",
  "core-prompt":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {α : Sort v}  {β : α → Sort u}  {a₁ a₂ : α}  (b : ∀ x : α, β x) : a₁ = a₂ → HEq (let x : α := a₁; b x) (let x : α := a₂; b x)",
  "args":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {α : Sort v}  {β : α → Sort u}  {a₁ a₂ : α}  (b : ∀ x : α, β x)"},
 {"type":
  "(∀ x, b₁ x = b₂ x) → (let x : α := a; b₁ x) = (let x : α := a; b₂ x)",
  "tactic-prompt":
  "lemma {a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {α : Sort v}  {β : α → Sort u}  (a : α)  {b₁ b₂ : ∀ x : α, β x} : (∀ x, b₁ x = b₂ x) → (let x : α := a; b₁ x) = (let x : α := a; b₂ x) := by intro h; sorry",
  "name": "let_body_eq",
  "kind": "lemma",
  "first-tactic": "intro h",
  "core-prompt":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {α : Sort v}  {β : α → Sort u}  (a : α)  {b₁ b₂ : ∀ x : α, β x} : (∀ x, b₁ x = b₂ x) → (let x : α := a; b₁ x) = (let x : α := a; b₂ x)",
  "args":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {α : Sort v}  {β : α → Sort u}  (a : α)  {b₁ b₂ : ∀ x : α, β x}"},
 {"type": "min (min a b) c = min a (min b c)",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a b c : α) : min (min a b) c = min a (min b c) := by apply eq_min; sorry",
  "name": "min_assoc",
  "kind": "lemma",
  "first-tactic": "apply eq_min",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] (a b c : α) : min (min a b) c = min a (min b c)",
  "args": "{α : Type u}  [LinearOrder α] (a b c : α)"},
 {"type": "min a a = a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a : α) : min a a = a := by simp[min]; sorry",
  "name": "min_self",
  "kind": "lemma",
  "first-tactic": "simp[min]",
  "core-prompt": "{α : Type u}  [LinearOrder α] (a : α) : min a a = a",
  "args": "{α : Type u}  [LinearOrder α] (a : α)"},
 {"type": "min a b = a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b) : min a b = a := by apply Eq.symm; sorry",
  "name": "min_eq_left",
  "kind": "lemma",
  "first-tactic": "apply Eq.symm",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b) : min a b = a",
  "args": "{α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b)"},
 {"type": "min a b = b",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a) : min a b = b := by rw [min_comm]; sorry",
  "name": "min_eq_right",
  "kind": "lemma",
  "first-tactic": "rw [min_comm]",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a) : min a b = b",
  "args": "{α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a)"},
 {"type": "max (max a b) c = max a (max b c)",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a b c : α) : max (max a b) c = max a (max b c) := by apply eq_max; sorry",
  "name": "max_assoc",
  "kind": "lemma",
  "first-tactic": "apply eq_max",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] (a b c : α) : max (max a b) c = max a (max b c)",
  "args": "{α : Type u}  [LinearOrder α] (a b c : α)"},
 {"type": "max a a = a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a : α) : max a a = a := by simp[max]; sorry",
  "name": "max_self",
  "kind": "lemma",
  "first-tactic": "simp[max]",
  "core-prompt": "{α : Type u}  [LinearOrder α] (a : α) : max a a = a",
  "args": "{α : Type u}  [LinearOrder α] (a : α)"},
 {"type": "max a b = a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a) : max a b = a := by apply Eq.symm; sorry",
  "name": "max_eq_left",
  "kind": "lemma",
  "first-tactic": "apply Eq.symm",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a) : max a b = a",
  "args": "{α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a)"},
 {"type": "max a b = b",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b) : max a b = b := by rw [←max_comm b a]; sorry",
  "name": "max_eq_right",
  "kind": "lemma",
  "first-tactic": "rw [←max_comm b a]",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b) : max a b = b",
  "args": "{α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b)"},
 {"type": "WellFounded (lbp p)",
  "tactic-prompt":
  "def (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) : WellFounded (lbp p) := by refine ⟨let ⟨n, pn⟩ := H; ?_⟩; sorry",
  "name": "wf_lbp",
  "kind": "def",
  "first-tactic": "refine ⟨let ⟨n, pn⟩ := H; ?_⟩",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) : WellFounded (lbp p)",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n)"},
 {"type":
  "∀ (n : Nat) (l1 l2 : List Char), l1.length = l2.length →\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat) : ∀ (n : Nat) (l1 l2 : List Char), l1.length = l2.length →\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length := by induction f; sorry",
  "name": "to_digits_core_lens_eq_aux",
  "kind": "lemma",
  "first-tactic": "induction f",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat) : ∀ (n : Nat) (l1 l2 : List Char), l1.length = l2.length →\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat)"},
 {"type":
  "∀ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat) : ∀ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1 := by induction f; sorry",
  "name": "to_digits_core_lens_eq",
  "kind": "lemma",
  "first-tactic": "induction f",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat) : ∀ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat)"},
 {"type": "n < b ^ e.succ → n / b < b ^ e",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n b e : Nat)  (h_b_pos : 0 < b) : n < b ^ e.succ → n / b < b ^ e := by simp only [Nat.pow_succ]; sorry",
  "name": "nat_repr_len_aux",
  "kind": "lemma",
  "first-tactic": "simp only [Nat.pow_succ]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n b e : Nat)  (h_b_pos : 0 < b) : n < b ^ e.succ → n / b < b ^ e",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n b e : Nat)  (h_b_pos : 0 < b)"},
 {"type": "0 < e → n < 10 ^ e → (Nat.repr n).length <= e",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n e : Nat) : 0 < e → n < 10 ^ e → (Nat.repr n).length <= e := by cases n; sorry",
  "name": "repr_length",
  "kind": "lemma",
  "first-tactic": "cases n",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n e : Nat) : 0 < e → n < 10 ^ e → (Nat.repr n).length <= e",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n e : Nat)"},
 {"type": "(m * n).cast = (m.cast * n.cast : R)",
  "tactic-prompt":
  "lemma [Semiring R]  {m n : ℕ} : (m * n).cast = (m.cast * n.cast : R) := by induction n generalizing m; sorry",
  "name": "Nat.cast_mul",
  "kind": "lemma",
  "first-tactic": "induction n generalizing m",
  "core-prompt":
  "[Semiring R]  {m n : ℕ} : (m * n).cast = (m.cast * n.cast : R)",
  "args": "[Semiring R]  {m n : ℕ}"},
 {"type": "(m ^ n).cast = (m.cast ^ n : R)",
  "tactic-prompt":
  "lemma [Semiring R]  {m n : ℕ} : (m ^ n).cast = (m.cast ^ n : R) := by induction n generalizing m; sorry",
  "name": "Nat.cast_pow",
  "kind": "lemma",
  "first-tactic": "induction n generalizing m",
  "core-prompt": "[Semiring R]  {m n : ℕ} : (m ^ n).cast = (m.cast ^ n : R)",
  "args": "[Semiring R]  {m n : ℕ}"},
 {"type": "∀ ⦃m₁ m₂ : MulOneClass M⦄, m₁.mul = m₂.mul → m₁ = m₂",
  "tactic-prompt":
  "theorem {G : Type _} {M : Type u} : ∀ ⦃m₁ m₂ : MulOneClass M⦄, m₁.mul = m₂.mul → m₁ = m₂ := by rintro ⟨⟨one₁⟩, ⟨mul₁⟩, one_mul₁, mul_one₁⟩ ⟨⟨one₂⟩, ⟨mul₂⟩, one_mul₂, mul_one₂⟩ ⟨rfl⟩; sorry",
  "name": "MulOneClass.ext",
  "kind": "theorem",
  "first-tactic":
  "rintro ⟨⟨one₁⟩, ⟨mul₁⟩, one_mul₁, mul_one₁⟩ ⟨⟨one₂⟩, ⟨mul₂⟩, one_mul₂, mul_one₂⟩ ⟨rfl⟩",
  "core-prompt":
  "{G : Type _} {M : Type u} : ∀ ⦃m₁ m₂ : MulOneClass M⦄, m₁.mul = m₂.mul → m₁ = m₂",
  "args": "{G : Type _} {M : Type u}"},
 {"type": "b = c",
  "tactic-prompt":
  "theorem {G : Type _}  {M : Type u}  [Monoid M] {a b c : M}  (hba : b * a = 1)  (hac : a * c = 1) : b = c := by rw [← one_mul c, ← hba, mul_assoc, hac, mul_one b]; sorry",
  "name": "left_inv_eq_right_inv",
  "kind": "theorem",
  "first-tactic": "rw [← one_mul c, ← hba, mul_assoc, hac, mul_one b]",
  "core-prompt":
  "{G : Type _}  {M : Type u}  [Monoid M] {a b c : M}  (hba : b * a = 1)  (hac : a * c = 1) : b = c",
  "args":
  "{G : Type _}  {M : Type u}  [Monoid M] {a b c : M}  (hba : b * a = 1)  (hac : a * c = 1)"},
 {"type": "a ^ (Int.negSucc n) = (a ^ (n + 1))⁻¹",
  "tactic-prompt":
  "theorem {G : Type _}  [DivInvMonoid G]  {a b : G}  -- TODO restore @[to_additive zsmul_eq_smul] (a : G)  (n : ℕ) : a ^ (Int.negSucc n) = (a ^ (n + 1))⁻¹ := by rw [← zpow_coe_nat]; sorry",
  "name": "zpow_neg_succ_of_nat",
  "kind": "theorem",
  "first-tactic": "rw [← zpow_coe_nat]",
  "core-prompt":
  "{G : Type _}  [DivInvMonoid G]  {a b : G}  -- TODO restore @[to_additive zsmul_eq_smul] (a : G)  (n : ℕ) : a ^ (Int.negSucc n) = (a ^ (n + 1))⁻¹",
  "args":
  "{G : Type _}  [DivInvMonoid G]  {a b : G}  -- TODO restore @[to_additive zsmul_eq_smul] (a : G)  (n : ℕ)"},
 {"type": "a * a⁻¹ = 1",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a : G) : a * a⁻¹ = 1 := by rw [← mul_left_inv a⁻¹, inv_eq_of_mul (mul_left_inv a)]; sorry",
  "name": "mul_right_inv",
  "kind": "theorem",
  "first-tactic": "rw [← mul_left_inv a⁻¹, inv_eq_of_mul (mul_left_inv a)]",
  "core-prompt": "{G : Type _}  [Group G]  {a b c : G} (a : G) : a * a⁻¹ = 1",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a : G)"},
 {"type": "a⁻¹ * (a * b) = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a⁻¹ * (a * b) = b := by rw [← mul_assoc, mul_left_inv, one_mul]; sorry",
  "name": "inv_mul_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc, mul_left_inv, one_mul]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a⁻¹ * (a * b) = b",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "a * (a⁻¹ * b) = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a * (a⁻¹ * b) = b := by rw [← mul_assoc, mul_right_inv, one_mul]; sorry",
  "name": "mul_inv_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc, mul_right_inv, one_mul]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a * (a⁻¹ * b) = b",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "a * b * b⁻¹ = a",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a * b * b⁻¹ = a := by rw [mul_assoc, mul_right_inv, mul_one]; sorry",
  "name": "mul_inv_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc, mul_right_inv, mul_one]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a * b * b⁻¹ = a",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "a * b⁻¹ * b = a",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a * b⁻¹ * b = a := by rw [mul_assoc, mul_left_inv, mul_one]; sorry",
  "name": "inv_mul_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc, mul_left_inv, mul_one]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a * b⁻¹ * b = a",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "Function.injective (@Group.toDivInvMonoid G)",
  "tactic-prompt":
  "theorem {G : Type _} {G : Type _} : Function.injective (@Group.toDivInvMonoid G) := by rintro ⟨⟩ ⟨⟩ ⟨⟩; sorry",
  "name": "Group.toDivInvMonoid_injective",
  "kind": "theorem",
  "first-tactic": "rintro ⟨⟩ ⟨⟩ ⟨⟩",
  "core-prompt":
  "{G : Type _} {G : Type _} : Function.injective (@Group.toDivInvMonoid G)",
  "args": "{G : Type _} {G : Type _}"},
 {"type": "Function.injective (@CommGroup.toGroup G)",
  "tactic-prompt":
  "theorem {G : Type _} {G : Type u} : Function.injective (@CommGroup.toGroup G) := by rintro ⟨⟩ ⟨⟩ ⟨⟩; sorry",
  "name": "CommGroup.toGroup_injective",
  "kind": "theorem",
  "first-tactic": "rintro ⟨⟩ ⟨⟩ ⟨⟩",
  "core-prompt":
  "{G : Type _} {G : Type u} : Function.injective (@CommGroup.toGroup G)",
  "args": "{G : Type _} {G : Type u}"},
 {"type": "SemiconjBy a (x * x') (y * y')",
  "tactic-prompt":
  "theorem {G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x * x') (y * y') := by unfold SemiconjBy; sorry",
  "name": "mul_right",
  "kind": "theorem",
  "first-tactic": "unfold SemiconjBy",
  "core-prompt":
  "{G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x * x') (y * y')",
  "args":
  "{G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y')"},
 {"type": "SemiconjBy (a * b) x z",
  "tactic-prompt":
  "theorem {G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (ha : SemiconjBy a y z)  (hb : SemiconjBy b x y) : SemiconjBy (a * b) x z := by unfold SemiconjBy; sorry",
  "name": "mul_left",
  "kind": "theorem",
  "first-tactic": "unfold SemiconjBy",
  "core-prompt":
  "{G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (ha : SemiconjBy a y z)  (hb : SemiconjBy b x y) : SemiconjBy (a * b) x z",
  "args":
  "{G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (ha : SemiconjBy a y z)  (hb : SemiconjBy b x y)"},
 {"type": "SemiconjBy a 1 1",
  "tactic-prompt":
  "theorem {G : Type _}  {M : Type u}  [MulOneClass M] (a : M) : SemiconjBy a 1 1 := by rw [SemiconjBy, mul_one, one_mul]; sorry",
  "name": "one_right",
  "kind": "theorem",
  "first-tactic": "rw [SemiconjBy, mul_one, one_mul]",
  "core-prompt":
  "{G : Type _}  {M : Type u}  [MulOneClass M] (a : M) : SemiconjBy a 1 1",
  "args": "{G : Type _}  {M : Type u}  [MulOneClass M] (a : M)"},
 {"type": "SemiconjBy a (x ^ n) (y ^ n)",
  "tactic-prompt":
  "theorem {G : Type _}  {M : Type u}  [Monoid M] {a x y : M}  (h : SemiconjBy a x y)  (n : ℕ) : SemiconjBy a (x ^ n) (y ^ n) := by induction' n with n ih; sorry",
  "name": "pow_right",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{G : Type _}  {M : Type u}  [Monoid M] {a x y : M}  (h : SemiconjBy a x y)  (n : ℕ) : SemiconjBy a (x ^ n) (y ^ n)",
  "args":
  "{G : Type _}  {M : Type u}  [Monoid M] {a x y : M}  (h : SemiconjBy a x y)  (n : ℕ)"},
 {"type": "a * b * c = a * c * b",
  "tactic-prompt":
  "theorem {G : Type _}  {S : Type _}  [Semigroup S]  {a b c : S} (h : Commute b c)  (a : S) : a * b * c = a * c * b := by simp only [mul_assoc, h.eq]; sorry",
  "name": "right_comm",
  "kind": "theorem",
  "first-tactic": "simp only [mul_assoc, h.eq]",
  "core-prompt":
  "{G : Type _}  {S : Type _}  [Semigroup S]  {a b c : S} (h : Commute b c)  (a : S) : a * b * c = a * c * b",
  "args":
  "{G : Type _}  {S : Type _}  [Semigroup S]  {a b c : S} (h : Commute b c)  (a : S)"},
 {"type": "(x * ·) ∘ (y * ·) = (x * y * ·)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Semigroup α]  (x y : α) : (x * ·) ∘ (y * ·) = (x * y * ·) := by ext z; sorry",
  "name": "comp_mul_left",
  "kind": "theorem",
  "first-tactic": "ext z",
  "core-prompt":
  "{α β G : Type _}  [Semigroup α]  (x y : α) : (x * ·) ∘ (y * ·) = (x * y * ·)",
  "args": "{α β G : Type _}  [Semigroup α]  (x y : α)"},
 {"type": "(· * x) ∘ (· * y) = (· * (y * x))",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Semigroup α]  (x y : α) : (· * x) ∘ (· * y) = (· * (y * x)) := by ext z; sorry",
  "name": "comp_mul_right",
  "kind": "theorem",
  "first-tactic": "ext z",
  "core-prompt":
  "{α β G : Type _}  [Semigroup α]  (x y : α) : (· * x) ∘ (· * y) = (· * (y * x))",
  "args": "{α β G : Type _}  [Semigroup α]  (x y : α)"},
 {"type": "ite P (a * b) 1 = ite P a 1 * ite P b 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P (a * b) 1 = ite P a 1 * ite P b 1 := by by_cases h:P; sorry",
  "name": "ite_mul_one",
  "kind": "theorem",
  "first-tactic": "by_cases h:P",
  "core-prompt":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P (a * b) 1 = ite P a 1 * ite P b 1",
  "args":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M}"},
 {"type": "ite P 1 (a * b) = ite P 1 a * ite P 1 b",
  "tactic-prompt":
  "theorem {α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P 1 (a * b) = ite P 1 a * ite P 1 b := by by_cases h:P; sorry",
  "name": "ite_one_mul",
  "kind": "theorem",
  "first-tactic": "by_cases h:P",
  "core-prompt":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P 1 (a * b) = ite P 1 a * ite P 1 b",
  "args":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M}"},
 {"type": "a = 1 ↔ b = 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  {M : Type u}  [MulOneClass M] {a b : M}  (h : a * b = 1) : a = 1 ↔ b = 1 := by constructor; sorry",
  "name": "eq_one_iff_eq_one_of_mul_eq_one",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {a b : M}  (h : a * b = 1) : a = 1 ↔ b = 1",
  "args":
  "{α β G : Type _}  {M : Type u}  [MulOneClass M] {a b : M}  (h : a * b = 1)"},
 {"type": "a * b * (c * d) = a * c * (b * d)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommSemigroup G] (a b c d : G) : a * b * (c * d) = a * c * (b * d) := by simp only [mul_left_comm, mul_assoc]; sorry",
  "name": "mul_mul_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp only [mul_left_comm, mul_assoc]",
  "core-prompt":
  "{α β G : Type _}  [CommSemigroup G] (a b c d : G) : a * b * (c * d) = a * c * (b * d)",
  "args": "{α β G : Type _}  [CommSemigroup G] (a b c d : G)"},
 {"type": "a * b * c = b * c * a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommSemigroup G] (a b c : G) : a * b * c = b * c * a := by simp only [mul_left_comm, mul_comm]; sorry",
  "name": "mul_rotate",
  "kind": "theorem",
  "first-tactic": "simp only [mul_left_comm, mul_comm]",
  "core-prompt":
  "{α β G : Type _}  [CommSemigroup G] (a b c : G) : a * b * c = b * c * a",
  "args": "{α β G : Type _}  [CommSemigroup G] (a b c : G)"},
 {"type": "a * (b * c) = b * (c * a)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommSemigroup G] (a b c : G) : a * (b * c) = b * (c * a) := by simp only [mul_left_comm, mul_comm]; sorry",
  "name": "mul_rotate'",
  "kind": "theorem",
  "first-tactic": "simp only [mul_left_comm, mul_comm]",
  "core-prompt":
  "{α β G : Type _}  [CommSemigroup G] (a b c : G) : a * (b * c) = b * (c * a)",
  "args": "{α β G : Type _}  [CommSemigroup G] (a b c : G)"},
 {"type": "b = a⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [HasInvolutiveInv G]  {a b : G} (h : a = b⁻¹) : b = a⁻¹ := by simp [h]; sorry",
  "name": "eq_inv_of_eq_inv",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [HasInvolutiveInv G]  {a b : G} (h : a = b⁻¹) : b = a⁻¹",
  "args": "{α β G : Type _}  [HasInvolutiveInv G]  {a b : G} (h : a = b⁻¹)"},
 {"type": "x⁻¹ = 1 / x",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x : G) : x⁻¹ = 1 / x := by rw [div_eq_mul_inv, one_mul]; sorry",
  "name": "inv_eq_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv, one_mul]",
  "core-prompt":
  "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x : G) : x⁻¹ = 1 / x",
  "args": "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x : G)"},
 {"type": "x * (1 / y) = x / y",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x y : G) : x * (1 / y) = x / y := by rw [div_eq_mul_inv, one_mul, div_eq_mul_inv]; sorry",
  "name": "mul_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv, one_mul, div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x y : G) : x * (1 / y) = x / y",
  "args": "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (x y : G)"},
 {"type": "a * b / c = a * (b / c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * b / c = a * (b / c) := by rw [div_eq_mul_inv, div_eq_mul_inv, mul_assoc _ _ _]; sorry",
  "name": "mul_div_assoc",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv, div_eq_mul_inv, mul_assoc _ _ _]",
  "core-prompt":
  "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * b / c = a * (b / c)",
  "args": "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G)"},
 {"type": "a * (b / c) = a * b / c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * (b / c) = a * b / c := by simp only [mul_assoc, div_eq_mul_inv]; sorry",
  "name": "mul_div",
  "kind": "theorem",
  "first-tactic": "simp only [mul_assoc, div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * (b / c) = a * b / c",
  "args": "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G)"},
 {"type": "a / b = a * (1 / b)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b : G) : a / b = a * (1 / b) := by rw [div_eq_mul_inv, one_div]; sorry",
  "name": "div_eq_mul_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv, one_div]",
  "core-prompt":
  "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b : G) : a / b = a * (1 / b)",
  "args": "{α β G : Type _}  [DivInvMonoid G]  {a b c : G} (a b : G)"},
 {"type": "a / 1 = a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivInvOneMonoid G] (a : G) : a / 1 = a := by simp [div_eq_mul_inv]; sorry",
  "name": "div_one",
  "kind": "theorem",
  "first-tactic": "simp [div_eq_mul_inv]",
  "core-prompt": "{α β G : Type _}  [DivInvOneMonoid G] (a : G) : a / 1 = a",
  "args": "{α β G : Type _}  [DivInvOneMonoid G] (a : G)"},
 {"type": "b⁻¹ = a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1) : b⁻¹ = a := by rw [← inv_eq_of_mul_eq_one_right h, inv_inv]; sorry",
  "name": "inv_eq_of_mul_eq_one_left",
  "kind": "theorem",
  "first-tactic": "rw [← inv_eq_of_mul_eq_one_right h, inv_inv]",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1) : b⁻¹ = a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1)"},
 {"type": "b = 1 / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : b * a = 1) : b = 1 / a := by rw [eq_inv_of_mul_eq_one_left h, one_div]; sorry",
  "name": "eq_one_div_of_mul_eq_one_left",
  "kind": "theorem",
  "first-tactic": "rw [eq_inv_of_mul_eq_one_left h, one_div]",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : b * a = 1) : b = 1 / a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : b * a = 1)"},
 {"type": "b = 1 / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1) : b = 1 / a := by rw [eq_inv_of_mul_eq_one_right h, one_div]; sorry",
  "name": "eq_one_div_of_mul_eq_one_right",
  "kind": "theorem",
  "first-tactic": "rw [eq_inv_of_mul_eq_one_right h, one_div]",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1) : b = 1 / a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : a * b = 1)"},
 {"type": "1 / a * (1 / b) = 1 / (b * a)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / a * (1 / b) = 1 / (b * a) := by simp; sorry",
  "name": "one_div_mul_one_div_rev",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / a * (1 / b) = 1 / (b * a)",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "a⁻¹ / b = (b * a)⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a⁻¹ / b = (b * a)⁻¹ := by simp; sorry",
  "name": "inv_div_left",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a⁻¹ / b = (b * a)⁻¹",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "(a / b)⁻¹ = b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : (a / b)⁻¹ = b / a := by simp; sorry",
  "name": "inv_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : (a / b)⁻¹ = b / a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "1 / (a / b) = b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / (a / b) = b / a := by simp; sorry",
  "name": "one_div_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / (a / b) = b / a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "1 / (1 / a) = a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / (1 / a) = a := by simp; sorry",
  "name": "one_div_one_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : 1 / (1 / a) = a",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : 1 / a = 1 / b) : a = b := by rw [← one_div_one_div a, h, one_div_one_div]; sorry",
  "name": "eq_of_one_div_eq_one_div",
  "kind": "theorem",
  "first-tactic": "rw [← one_div_one_div a, h, one_div_one_div]",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : 1 / a = 1 / b) : a = b",
  "args":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} (h : 1 / a = 1 / b)"},
 {"type": "a / (b / c) = a * c / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / (b / c) = a * c / b := by simp; sorry",
  "name": "div_div_eq_mul_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / (b / c) = a * c / b",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "a / b⁻¹ = a * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / b⁻¹ = a * b := by simp; sorry",
  "name": "div_inv_eq_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / b⁻¹ = a * b",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "a / (b * c) = a / c / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / (b * c) = a / c / b := by simp only [mul_assoc, mul_inv_rev, div_eq_mul_inv]; sorry",
  "name": "div_mul_eq_div_div_swap",
  "kind": "theorem",
  "first-tactic": "simp only [mul_assoc, mul_inv_rev, div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [DivisionMonoid α]  {a b c : α} : a / (b * c) = a / c / b",
  "args": "{α β G : Type _}  [DivisionMonoid α]  {a b c : α}"},
 {"type": "(a * b)⁻¹ = a⁻¹ * b⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a * b)⁻¹ = a⁻¹ * b⁻¹ := by simp; sorry",
  "name": "mul_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a * b)⁻¹ = a⁻¹ * b⁻¹",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "(a / b)⁻¹ = a⁻¹ / b⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a / b)⁻¹ = a⁻¹ / b⁻¹ := by simp; sorry",
  "name": "inv_div'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a / b)⁻¹ = a⁻¹ / b⁻¹",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b = b⁻¹ * a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b = b⁻¹ * a := by simp; sorry",
  "name": "div_eq_inv_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b = b⁻¹ * a",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a⁻¹ * b = b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a⁻¹ * b = b / a := by simp; sorry",
  "name": "inv_mul_eq_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a⁻¹ * b = b / a",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "(a * b)⁻¹ = a⁻¹ / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a * b)⁻¹ = a⁻¹ / b := by simp; sorry",
  "name": "inv_mul'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a * b)⁻¹ = a⁻¹ / b",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a⁻¹ / b⁻¹ = b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a⁻¹ / b⁻¹ = b / a := by simp; sorry",
  "name": "inv_div_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a⁻¹ / b⁻¹ = b / a",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "(a⁻¹ / b⁻¹)⁻¹ = a / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a⁻¹ / b⁻¹)⁻¹ = a / b := by simp; sorry",
  "name": "inv_inv_div_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : (a⁻¹ / b⁻¹)⁻¹ = a / b",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "1 / a * (1 / b) = 1 / (a * b)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : 1 / a * (1 / b) = 1 / (a * b) := by simp; sorry",
  "name": "one_div_mul_one_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : 1 / a * (1 / b) = 1 / (a * b)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b / c = a / c / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / c = a / c / b := by simp; sorry",
  "name": "div_right_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / c = a / c / b",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b / c = a / (b * c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / c = a / (b * c) := by simp; sorry",
  "name": "div_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / c = a / (b * c)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b * c = a / (b / c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a / (b / c) := by simp; sorry",
  "name": "div_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a / (b / c)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a * (b / c) = b * (a / c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * (b / c) = b * (a / c) := by simp; sorry",
  "name": "mul_div_left_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * (b / c) = b * (a / c)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a * b / c = a / c * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * b / c = a / c * b := by simp; sorry",
  "name": "mul_div_right_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * b / c = a / c * b",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / (b * c) = a / b / c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / (b * c) = a / b / c := by simp; sorry",
  "name": "div_mul_eq_div_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / (b * c) = a / b / c",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b * c = a * c / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a * c / b := by simp; sorry",
  "name": "div_mul_eq_mul_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a * c / b",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b * c = a * (c / b)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a * (c / b) := by simp; sorry",
  "name": "mul_comm_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = a * (c / b)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b * c = c / b * a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = c / b * a := by simp; sorry",
  "name": "div_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * c = c / b * a",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / (b * c) = a / b * (1 / c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / (b * c) = a / b * (1 / c) := by simp; sorry",
  "name": "div_mul_eq_div_mul_one_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / (b * c) = a / b * (1 / c)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b / (c / d) = a * d / (b * c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / (c / d) = a * d / (b * c) := by simp; sorry",
  "name": "div_div_div_eq",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / (c / d) = a * d / (b * c)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b / (c / d) = a / c / (b / d)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / (c / d) = a / c / (b / d) := by simp; sorry",
  "name": "div_div_div_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b / (c / d) = a / c / (b / d)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b * (c / d) = a * c / (b * d)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * (c / d) = a * c / (b * d) := by simp; sorry",
  "name": "div_mul_div_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a / b * (c / d) = a * c / (b * d)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a * b / (c * d) = a / c * (b / d)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * b / (c * d) = a / c * (b / d) := by simp; sorry",
  "name": "mul_div_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α) : a * b / (c * d) = a / c * (b / d)",
  "args": "{α β G : Type _}  [DivisionCommMonoid α]  (a b c d : α)"},
 {"type": "a / b = b⁻¹ ↔ a = 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a / b = b⁻¹ ↔ a = 1 := by rw [div_eq_mul_inv, mul_left_eq_self]; sorry",
  "name": "div_eq_inv_self",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv, mul_left_eq_self]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a / b = b⁻¹ ↔ a = 1",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a = b * c⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b * c⁻¹ := by simp [h.symm]; sorry",
  "name": "eq_mul_inv_of_mul_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b * c⁻¹",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b)"},
 {"type": "a = b⁻¹ * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : b * a = c) : a = b⁻¹ * c := by simp [h.symm]; sorry",
  "name": "eq_inv_mul_of_mul_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : b * a = c) : a = b⁻¹ * c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : b * a = c)"},
 {"type": "a⁻¹ * b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : b = a * c) : a⁻¹ * b = c := by simp [h]; sorry",
  "name": "inv_mul_eq_of_eq_mul",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : b = a * c) : a⁻¹ * b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : b = a * c)"},
 {"type": "a * b⁻¹ = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a * b⁻¹ = c := by simp [h]; sorry",
  "name": "mul_inv_eq_of_eq_mul",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a * b⁻¹ = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a * c⁻¹ = b) : a = b * c := by simp [h.symm]; sorry",
  "name": "eq_mul_of_mul_inv_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c⁻¹ = b) : a = b * c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c⁻¹ = b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : b⁻¹ * a = c) : a = b * c := by simp [h.symm, mul_inv_cancel_left]; sorry",
  "name": "eq_mul_of_inv_mul_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm, mul_inv_cancel_left]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : b⁻¹ * a = c) : a = b * c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : b⁻¹ * a = c)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : b = a⁻¹ * c) : a * b = c := by rw [h, mul_inv_cancel_left]; sorry",
  "name": "mul_eq_of_eq_inv_mul",
  "kind": "theorem",
  "first-tactic": "rw [h, mul_inv_cancel_left]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : b = a⁻¹ * c) : a * b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : b = a⁻¹ * c)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b⁻¹) : a * b = c := by simp [h]; sorry",
  "name": "mul_eq_of_eq_mul_inv",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b⁻¹) : a * b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b⁻¹)"},
 {"type": "a * b = 1 ↔ a⁻¹ = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a * b = 1 ↔ a⁻¹ = b := by rw [mul_eq_one_iff_eq_inv, eq_inv_iff_eq_inv, eq_comm]; sorry",
  "name": "mul_eq_one_iff_inv_eq",
  "kind": "theorem",
  "first-tactic": "rw [mul_eq_one_iff_eq_inv, eq_inv_iff_eq_inv, eq_comm]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a * b = 1 ↔ a⁻¹ = b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a * b⁻¹ = 1 ↔ a = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a * b⁻¹ = 1 ↔ a = b := by rw [mul_eq_one_iff_eq_inv, inv_inv]; sorry",
  "name": "mul_inv_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [mul_eq_one_iff_eq_inv, inv_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a * b⁻¹ = 1 ↔ a = b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a⁻¹ * b = 1 ↔ a = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a⁻¹ * b = 1 ↔ a = b := by rw [mul_eq_one_iff_eq_inv, inv_inj]; sorry",
  "name": "inv_mul_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [mul_eq_one_iff_eq_inv, inv_inj]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a⁻¹ * b = 1 ↔ a = b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "Function.injective fun a => a / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : Function.injective fun a => a / b := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_left_injective",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : Function.injective fun a => a / b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "Function.injective fun a => b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : Function.injective fun a => b / a := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_right_injective",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : Function.injective fun a => b / a",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a / b * b = a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a b : G) : a / b * b = a := by rw [div_eq_mul_inv, inv_mul_cancel_right a b]; sorry",
  "name": "div_mul_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv, inv_mul_cancel_right a b]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a b : G) : a / b * b = a",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a b : G)"},
 {"type": "a / a = 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a : G) : a / a = 1 := by rw [div_eq_mul_inv, mul_right_inv a]; sorry",
  "name": "div_self'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv, mul_right_inv a]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a : G) : a / a = 1",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a : G)"},
 {"type": "a * b / b = a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a b : G) : a * b / b = a := by rw [div_eq_mul_inv, mul_inv_cancel_right a b]; sorry",
  "name": "mul_div_cancel''",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv, mul_inv_cancel_right a b]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a b : G) : a * b / b = a",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a b : G)"},
 {"type": "a * c / (b * c) = a / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a * c / (b * c) = a / b := by rw [div_mul_eq_div_div_swap]; sorry",
  "name": "mul_div_mul_right_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [div_mul_eq_div_div_swap]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a * c / (b * c) = a / b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G)"},
 {"type": "a = b / c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b / c := by simp [← h]; sorry",
  "name": "eq_div_of_mul_eq'",
  "kind": "theorem",
  "first-tactic": "simp [← h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b / c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a * c = b)"},
 {"type": "a / b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a / b = c := by simp [h]; sorry",
  "name": "div_eq_of_eq_mul''",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a / b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c * b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a / c = b) : a = b * c := by simp [← h]; sorry",
  "name": "eq_mul_of_div_eq",
  "kind": "theorem",
  "first-tactic": "simp [← h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a / c = b) : a = b * c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a / c = b)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (h : a = c / b) : a * b = c := by simp [h]; sorry",
  "name": "mul_eq_of_eq_div",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c / b) : a * b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (h : a = c / b)"},
 {"type": "b / a = c / a ↔ b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : b / a = c / a ↔ b = c := by rw [div_eq_mul_inv, div_eq_mul_inv]; sorry",
  "name": "div_left_inj",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv, div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : b / a = c / a ↔ b = c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a / b * (b / c) = a / c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / b * (b / c) = a / c := by rw [← mul_div_assoc, div_mul_cancel']; sorry",
  "name": "div_mul_div_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [← mul_div_assoc, div_mul_cancel']",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / b * (b / c) = a / c",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G)"},
 {"type": "a / c / (b / c) = a / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / c / (b / c) = a / b := by rw [← inv_div c b, div_inv_eq_mul, div_mul_div_cancel']; sorry",
  "name": "div_div_div_cancel_right'",
  "kind": "theorem",
  "first-tactic": "rw [← inv_div c b, div_inv_eq_mul, div_mul_div_cancel']",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / c / (b / c) = a / b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b = a ↔ b = 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a / b = a ↔ b = 1 := by rw [div_eq_mul_inv, mul_right_eq_self, inv_eq_one]; sorry",
  "name": "div_eq_self",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv, mul_right_eq_self, inv_eq_one]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a / b = a ↔ b = 1",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a = b / c ↔ a * c = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a = b / c ↔ a * c = b := by rw [div_eq_mul_inv, eq_mul_inv_iff_mul_eq]; sorry",
  "name": "eq_div_iff_mul_eq'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv, eq_mul_inv_iff_mul_eq]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a = b / c ↔ a * c = b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a / b = c ↔ a = c * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} : a / b = c ↔ a = c * b := by rw [div_eq_mul_inv, mul_inv_eq_iff_eq_mul]; sorry",
  "name": "div_eq_iff_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv, mul_inv_eq_iff_eq_mul]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} : a / b = c ↔ a = c * b",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a = b ↔ c = d",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} (H : a / b = c / d) : a = b ↔ c = d := by rw [← div_eq_one, H, div_eq_one]; sorry",
  "name": "eq_iff_eq_of_div_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [← div_eq_one, H, div_eq_one]",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} (H : a / b = c / d) : a = b ↔ c = d",
  "args": "{α β G : Type _}  [Group G]  {a b c d : G} (H : a / b = c / d)"},
 {"type": "∃ n : ℕ, 0 < n ∧ x ^ n = 1",
  "tactic-prompt":
  "theorem {α β G : Type _}  [Group G]  {a b c d : G} {n : ℤ}  (hn : n ≠ 0)  {x : G}  (h : x ^ n = 1) : ∃ n : ℕ, 0 < n ∧ x ^ n = 1 := by cases' n with n n; sorry",
  "name": "exists_npow_eq_one_of_zpow_eq_one",
  "kind": "theorem",
  "first-tactic": "cases' n with n n",
  "core-prompt":
  "{α β G : Type _}  [Group G]  {a b c d : G} {n : ℤ}  (hn : n ≠ 0)  {x : G}  (h : x ^ n = 1) : ∃ n : ℕ, 0 < n ∧ x ^ n = 1",
  "args":
  "{α β G : Type _}  [Group G]  {a b c d : G} {n : ℤ}  (hn : n ≠ 0)  {x : G}  (h : x ^ n = 1)"},
 {"type": "a / b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} {a b c : G}  (h : a = b * c) : a / b = c := by rw [h, div_eq_mul_inv, mul_comm, inv_mul_cancel_left]; sorry",
  "name": "div_eq_of_eq_mul'",
  "kind": "theorem",
  "first-tactic": "rw [h, div_eq_mul_inv, mul_comm, inv_mul_cancel_left]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} {a b c : G}  (h : a = b * c) : a / b = c",
  "args":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} {a b c : G}  (h : a = b * c)"},
 {"type": "c * a / (c * b) = a / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c * a / (c * b) = a / b := by rw [div_eq_mul_inv, mul_inv_rev, mul_comm b⁻¹ c⁻¹, mul_comm c a, mul_assoc, ←mul_assoc c,\n    mul_right_inv, one_mul, div_eq_mul_inv]; sorry",
  "name": "mul_div_mul_left_eq_div",
  "kind": "theorem",
  "first-tactic":
  "rw [div_eq_mul_inv, mul_inv_rev, mul_comm b⁻¹ c⁻¹, mul_comm c a, mul_assoc, ←mul_assoc c,\n    mul_right_inv, one_mul, div_eq_mul_inv]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c * a / (c * b) = a / b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a = b / c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (h : c * a = b) : a = b / c := by simp [h.symm]; sorry",
  "name": "eq_div_of_mul_eq''",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : c * a = b) : a = b / c",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : c * a = b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (h : a / b = c) : a = b * c := by simp [h.symm]; sorry",
  "name": "eq_mul_of_div_eq'",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : a / b = c) : a = b * c",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : a / b = c)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (h : b = c / a) : a * b = c := by simp [h]; sorry",
  "name": "mul_eq_of_eq_div'",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : b = c / a) : a * b = c",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (h : b = c / a)"},
 {"type": "a / (a / b) = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a / b) = b := by simpa using mul_inv_cancel_left a b; sorry",
  "name": "div_div_self'",
  "kind": "theorem",
  "first-tactic": "simpa using mul_inv_cancel_left a b",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a / b) = b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a / b = c / b * (a / c)",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b = c / b * (a / c) := by simp [mul_left_comm c]; sorry",
  "name": "div_eq_div_mul_div",
  "kind": "theorem",
  "first-tactic": "simp [mul_left_comm c]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b = c / b * (a / c)",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b / a = b⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / b / a = b⁻¹ := by simp; sorry",
  "name": "div_div_cancel_left",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / b / a = b⁻¹",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a = b / c ↔ c * a = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} : a = b / c ↔ c * a = b := by rw [eq_div_iff_mul_eq', mul_comm]; sorry",
  "name": "eq_div_iff_mul_eq''",
  "kind": "theorem",
  "first-tactic": "rw [eq_div_iff_mul_eq', mul_comm]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} : a = b / c ↔ c * a = b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "a / b = c ↔ a = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c ↔ a = b * c := by rw [div_eq_iff_eq_mul, mul_comm]; sorry",
  "name": "div_eq_iff_eq_mul'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_iff_eq_mul, mul_comm]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c ↔ a = b * c",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "a * b / a = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * b / a = b := by rw [div_eq_inv_mul, inv_mul_cancel_left]; sorry",
  "name": "mul_div_cancel'''",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_inv_mul, inv_mul_cancel_left]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * b / a = b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a * (b / a) = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b / a) = b := by rw [← mul_div_assoc, mul_div_cancel''']; sorry",
  "name": "mul_div_cancel'_right",
  "kind": "theorem",
  "first-tactic": "rw [← mul_div_assoc, mul_div_cancel''']",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b / a) = b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a / (a * b) = b⁻¹",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a * b) = b⁻¹ := by rw [← inv_div, mul_div_cancel''']; sorry",
  "name": "div_mul_cancel''",
  "kind": "theorem",
  "first-tactic": "rw [← inv_div, mul_div_cancel''']",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a * b) = b⁻¹",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a * (b * a⁻¹) = b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b * a⁻¹) = b := by rw [← div_eq_mul_inv, mul_div_cancel'_right a b]; sorry",
  "name": "mul_mul_inv_cancel'_right",
  "kind": "theorem",
  "first-tactic": "rw [← div_eq_mul_inv, mul_div_cancel'_right a b]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b * a⁻¹) = b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a * c * (b / c) = a * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * c * (b / c) = a * b := by rw [mul_assoc, mul_div_cancel'_right]; sorry",
  "name": "mul_mul_div_cancel",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc, mul_div_cancel'_right]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * c * (b / c) = a * b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / c * (b * c) = a * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / c * (b * c) = a * b := by rw [mul_left_comm, div_mul_cancel', mul_comm]; sorry",
  "name": "div_mul_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rw [mul_left_comm, div_mul_cancel', mul_comm]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / c * (b * c) = a * b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b * (c / a) = c / b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b * (c / a) = c / b := by rw [mul_comm]; sorry",
  "name": "div_mul_div_cancel''",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b * (c / a) = c / b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a * b / (a / c) = b * c",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * b / (a / c) = b * c := by rw [← div_mul, mul_div_cancel''']; sorry",
  "name": "mul_div_div_cancel",
  "kind": "theorem",
  "first-tactic": "rw [← div_mul, mul_div_cancel''']",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * b / (a / c) = b * c",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "c / a / (c / b) = b / a",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c / a / (c / b) = b / a := by rw [← inv_div b c, div_inv_eq_mul, mul_comm, div_mul_div_cancel']; sorry",
  "name": "div_div_div_cancel_left",
  "kind": "theorem",
  "first-tactic":
  "rw [← inv_div b c, div_inv_eq_mul, mul_comm, div_mul_div_cancel']",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c / a / (c / b) = b / a",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b = c / d ↔ a * d = c * b",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d ↔ a * d = c * b := by rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, eq_comm, div_eq_iff_eq_mul']; sorry",
  "name": "div_eq_div_iff_mul_eq_mul",
  "kind": "theorem",
  "first-tactic":
  "rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, eq_comm, div_eq_iff_eq_mul']",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d ↔ a * d = c * b",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "a / b = c / d ↔ a / c = b / d",
  "tactic-prompt":
  "theorem {α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d ↔ a / c = b / d := by rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, div_eq_iff_eq_mul', mul_div_assoc]; sorry",
  "name": "div_eq_div_iff_div_eq_div",
  "kind": "theorem",
  "first-tactic":
  "rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, div_eq_iff_eq_mul', mul_div_assoc]",
  "core-prompt":
  "{α β G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d ↔ a / c = b / d",
  "args": "{α β G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "a ^ 1 = a",
  "tactic-prompt":
  "theorem [Monoid M] (a : M) : a ^ 1 = a := by rw [pow_succ, pow_zero, mul_one]; sorry",
  "name": "pow_one",
  "kind": "theorem",
  "first-tactic": "rw [pow_succ, pow_zero, mul_one]",
  "core-prompt": "[Monoid M] (a : M) : a ^ 1 = a",
  "args": "[Monoid M] (a : M)"},
 {"type": "a ^ (m + n) = a ^ m * a ^ n",
  "tactic-prompt":
  "theorem [Monoid M] (a : M)  (m n : ℕ) : a ^ (m + n) = a ^ m * a ^ n := by induction' n with n ih; sorry",
  "name": "pow_add",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt": "[Monoid M] (a : M)  (m n : ℕ) : a ^ (m + n) = a ^ m * a ^ n",
  "args": "[Monoid M] (a : M)  (m n : ℕ)"},
 {"type": "a ^ (m * n) = (a ^ m) ^ n",
  "tactic-prompt":
  "theorem [Monoid M] (a : M)  (m n : ℕ) : a ^ (m * n) = (a ^ m) ^ n := by induction' n with n ih; sorry",
  "name": "pow_mul",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt": "[Monoid M] (a : M)  (m n : ℕ) : a ^ (m * n) = (a ^ m) ^ n",
  "args": "[Monoid M] (a : M)  (m n : ℕ)"},
 {"type": "(a * b) ^ n = a ^ n * b ^ n",
  "tactic-prompt":
  "theorem [Monoid M] {a b : M}  (h : Commute a b)  (n : ℕ) : (a * b) ^ n = a ^ n * b ^ n := by induction' n with n ih; sorry",
  "name": "Commute.mul_pow",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "[Monoid M] {a b : M}  (h : Commute a b)  (n : ℕ) : (a * b) ^ n = a ^ n * b ^ n",
  "args": "[Monoid M] {a b : M}  (h : Commute a b)  (n : ℕ)"},
 {"type": "((1 : ℕ) : R) = 1",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] : ((1 : ℕ) : R) = 1 := by simp; sorry",
  "name": "Nat.cast_one",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "[AddMonoidWithOne R] : ((1 : ℕ) : R) = 1",
  "args": "[AddMonoidWithOne R]"},
 {"type": "((m + n : ℕ) : R) = (m : R) + n",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] : ((m + n : ℕ) : R) = (m : R) + n := by induction n; sorry",
  "name": "Nat.cast_add",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "[AddMonoidWithOne R] : ((m + n : ℕ) : R) = (m : R) + n",
  "args": "[AddMonoidWithOne R]"},
 {"type": "((0 : ℤ) : R) = 0",
  "tactic-prompt":
  "theorem [AddGroupWithOne R] : ((0 : ℤ) : R) = 0 := by erw [Int.cast_ofNat, Nat.cast_zero]; sorry",
  "name": "Int.cast_zero",
  "kind": "theorem",
  "first-tactic": "erw [Int.cast_ofNat, Nat.cast_zero]",
  "core-prompt": "[AddGroupWithOne R] : ((0 : ℤ) : R) = 0",
  "args": "[AddGroupWithOne R]"},
 {"type": "((1 : ℤ) : R) = 1",
  "tactic-prompt":
  "theorem [AddGroupWithOne R] : ((1 : ℤ) : R) = 1 := by erw [Int.cast_ofNat, Nat.cast_one]; sorry",
  "name": "Int.cast_one",
  "kind": "theorem",
  "first-tactic": "erw [Int.cast_ofNat, Nat.cast_one]",
  "core-prompt": "[AddGroupWithOne R] : ((1 : ℤ) : R) = 1",
  "args": "[AddGroupWithOne R]"},
 {"type": "Fmla.reify v (f₁.and f₂) (a ∨ b)",
  "tactic-prompt":
  "theorem (h₁ : Fmla.reify v f₁ a)  (h₂ : Fmla.reify v f₂ b) : Fmla.reify v (f₁.and f₂) (a ∨ b) := by refine ⟨fun H => by_contra fun hn => H ⟨fun c h => by_contra fun hn' => ?_⟩⟩; sorry",
  "name": "Fmla.reify_or",
  "kind": "theorem",
  "first-tactic":
  "refine ⟨fun H => by_contra fun hn => H ⟨fun c h => by_contra fun hn' => ?_⟩⟩",
  "core-prompt":
  "(h₁ : Fmla.reify v f₁ a)  (h₂ : Fmla.reify v f₂ b) : Fmla.reify v (f₁.and f₂) (a ∨ b)",
  "args": "(h₁ : Fmla.reify v f₁ a)  (h₂ : Fmla.reify v f₂ b)"},
 {"type": "True",
  "tactic-prompt": "example  : True := by find; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "find",
  "core-prompt": " : True",
  "args": ""},
 {"type": "HEq a b ↔ HEq (a : α) (b : β)",
  "tactic-prompt":
  "lemma {α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop} {α β : Sort _}  {p : α → Prop}  {q : β → Prop}  {a : {x // p x}}    {b : {y // q y}}  (h : α = β)  (h' : HEq p q) : HEq a b ↔ HEq (a : α) (b : β) := by subst h; sorry",
  "name": "heq_iff_coe_heq",
  "kind": "lemma",
  "first-tactic": "subst h",
  "core-prompt":
  "{α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop} {α β : Sort _}  {p : α → Prop}  {q : β → Prop}  {a : {x // p x}}    {b : {y // q y}}  (h : α = β)  (h' : HEq p q) : HEq a b ↔ HEq (a : α) (b : β)",
  "args":
  "{α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop} {α β : Sort _}  {p : α → Prop}  {q : β → Prop}  {a : {x // p x}}    {b : {y // q y}}  (h : α = β)  (h' : HEq p q)"},
 {"type": "injective ((↑·) : Subtype p → α)",
  "tactic-prompt":
  "theorem {α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop} : injective ((↑·) : Subtype p → α) := by intros a b hab; sorry",
  "name": "coe_injective",
  "kind": "theorem",
  "first-tactic": "intros a b hab",
  "core-prompt":
  "{α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop} : injective ((↑·) : Subtype p → α)",
  "args":
  "{α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop}"},
 {"type": "n = arr.size",
  "tactic-prompt":
  "theorem {arr : Array α}  {m : Fin n → β}  (H : Agrees arr f m) : n = arr.size := by cases H; sorry",
  "name": "size_eq",
  "kind": "theorem",
  "first-tactic": "cases H",
  "core-prompt":
  "{arr : Array α}  {m : Fin n → β}  (H : Agrees arr f m) : n = arr.size",
  "args": "{arr : Array α}  {m : Fin n → β}  (H : Agrees arr f m)"},
 {"type": "∃ (m : UFModel self.arr.size), m.Models self.arr",
  "tactic-prompt":
  "theorem (self : UnionFind α) : ∃ (m : UFModel self.arr.size), m.Models self.arr := by let ⟨n, m, hm⟩ := self.model; sorry",
  "name": "model'",
  "kind": "theorem",
  "first-tactic": "let ⟨n, m, hm⟩ := self.model",
  "core-prompt":
  "(self : UnionFind α) : ∃ (m : UFModel self.arr.size), m.Models self.arr",
  "args": "(self : UnionFind α)"},
 {"type": "self.rank i < self.rankMax",
  "tactic-prompt":
  "theorem (self : UnionFind α)  (i : Nat) : self.rank i < self.rankMax := by simp [rank]; sorry",
  "name": "lt_rankMax",
  "kind": "theorem",
  "first-tactic": "simp [rank]",
  "core-prompt": "(self : UnionFind α)  (i : Nat) : self.rank i < self.rankMax",
  "args": "(self : UnionFind α)  (i : Nat)"},
 {"type": "a.val = b.val → a = b",
  "tactic-prompt":
  "lemma {a b : Fin n} : a.val = b.val → a = b := by cases a; sorry",
  "name": "Fin.ext",
  "kind": "lemma",
  "first-tactic": "cases a",
  "core-prompt": "{a b : Fin n} : a.val = b.val → a = b",
  "args": "{a b : Fin n}"},
 {"type": "(⟨(a : ℕ), h⟩ : Fin n) = a",
  "tactic-prompt":
  "theorem (a : Fin n)  (h : (a : ℕ) < n) : (⟨(a : ℕ), h⟩ : Fin n) = a := by cases a; sorry",
  "name": "Fin.eta",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a : Fin n)  (h : (a : ℕ) < n) : (⟨(a : ℕ), h⟩ : Fin n) = a",
  "args": "(a : Fin n)  (h : (a : ℕ) < n)"},
 {"type": "(Fin.ofNat' a (zero_lt_of_lt h)).val = a",
  "tactic-prompt":
  "lemma {n a : Nat}  (h : a < n) : (Fin.ofNat' a (zero_lt_of_lt h)).val = a := by simp only [Fin.ofNat', Nat.mod_eq_of_lt h]; sorry",
  "name": "Fin.val_eq_of_lt",
  "kind": "lemma",
  "first-tactic": "simp only [Fin.ofNat', Nat.mod_eq_of_lt h]",
  "core-prompt":
  "{n a : Nat}  (h : a < n) : (Fin.ofNat' a (zero_lt_of_lt h)).val = a",
  "args": "{n a : Nat}  (h : a < n)"},
 {"type": "(1 : Fin (n + 2)).val = 1",
  "tactic-prompt":
  "lemma  : (1 : Fin (n + 2)).val = 1 := by simp only [OfNat.ofNat, Fin.ofNat]; sorry",
  "name": "Fin.one_val",
  "kind": "lemma",
  "first-tactic": "simp only [OfNat.ofNat, Fin.ofNat]",
  "core-prompt": " : (1 : Fin (n + 2)).val = 1",
  "args": ""},
 {"type": "a % b = a",
  "tactic-prompt":
  "theorem {a b : Fin n}  (h : a < b) : a % b = a := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mod_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt": "{a b : Fin n}  (h : a < b) : a % b = a",
  "args": "{a b : Fin n}  (h : a < b)"},
 {"type": "(Fin.checkedAdd a b).isSome = true ↔ a.val + b.val < n",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedAdd a b).isSome = true ↔ a.val + b.val < n := by by_cases n <= a.val + b.val; sorry",
  "name": "Fin.checked_add_spec",
  "kind": "lemma",
  "first-tactic": "by_cases n <= a.val + b.val",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedAdd a b).isSome = true ↔ a.val + b.val < n",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "a * 1 = a",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a : Fin n) : a * 1 = a := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mul_one",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n) : a * 1 = a",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n)"},
 {"type": "a * (b + c) = a * b + a * c",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a b c : Fin n) : a * (b + c) = a * b + a * c := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mul_add",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b c : Fin n) : a * (b + c) = a * b + a * c",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b c : Fin n)"},
 {"type": "∀ (a b : Fin n), a - b = a + -b",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] : ∀ (a b : Fin n), a - b = a + -b := by simp [Fin.add_def, Fin.sub_def, Neg.neg]; sorry",
  "name": "Fin.sub_eq_add_neg",
  "kind": "theorem",
  "first-tactic": "simp [Fin.add_def, Fin.sub_def, Neg.neg]",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] : ∀ (a b : Fin n), a - b = a + -b",
  "args": "{n : Nat}  [Nonempty (Fin n)]"},
 {"type": "-a + a = 0",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a : Fin n) : -a + a = 0 := by rw [add_comm, ← Fin.sub_eq_add_neg]; sorry",
  "name": "Fin.add_left_neg",
  "kind": "theorem",
  "first-tactic": "rw [add_comm, ← Fin.sub_eq_add_neg]",
  "core-prompt": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n) : -a + a = 0",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n)"},
 {"type": "a ≤ b → b ≤ a → a = b",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : a ≤ b → b ≤ a → a = b := by intro h1 h2; sorry",
  "name": "Fin.le_antisymm",
  "kind": "lemma",
  "first-tactic": "intro h1 h2",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : a ≤ b → b ≤ a → a = b",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "(replicate n c).length = n",
  "tactic-prompt":
  "lemma (n : ℕ)  (c : Char) : (replicate n c).length = n := by simp only [String.length, String.replicate, List.length_replicate]; sorry",
  "name": "length_replicate",
  "kind": "lemma",
  "first-tactic":
  "simp only [String.length, String.replicate, List.length_replicate]",
  "core-prompt": "(n : ℕ)  (c : Char) : (replicate n c).length = n",
  "args": "(n : ℕ)  (c : Char)"},
 {"type": "(String.mk l).length = l.length",
  "tactic-prompt":
  "lemma (l : List Char) : (String.mk l).length = l.length := by simp only [String.length]; sorry",
  "name": "length_eq_list_length",
  "kind": "lemma",
  "first-tactic": "simp only [String.length]",
  "core-prompt": "(l : List Char) : (String.mk l).length = l.length",
  "args": "(l : List Char)"},
 {"type": "Prod.map f g p = (f p.1, g p.2)",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : Prod.map f g p = (f p.1, g p.2) := by cases p; sorry",
  "name": "prod_map",
  "kind": "lemma",
  "first-tactic": "cases p",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : Prod.map f g p = (f p.1, g p.2)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β)"},
 {"type": "(map f g p).1 = f (p.1)",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : (map f g p).1 = f (p.1) := by simp; sorry",
  "name": "map_fst",
  "kind": "lemma",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : (map f g p).1 = f (p.1)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β)"},
 {"type": "(map f g p).2 = g (p.2)",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : (map f g p).2 = g (p.2) := by simp; sorry",
  "name": "map_snd",
  "kind": "lemma",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : (map f g p).2 = g (p.2)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β)"},
 {"type": "p = q ↔ p.1 = q.1 ∧ p.2 = q.2",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {p q : α × β} : p = q ↔ p.1 = q.1 ∧ p.2 = q.2 := by rw [← @mk.eta _ _ p, ← @mk.eta _ _ q, mk.inj_iff]; sorry",
  "name": "ext_iff",
  "kind": "lemma",
  "first-tactic": "rw [← @mk.eta _ _ p, ← @mk.eta _ _ q, mk.inj_iff]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {p q : α × β} : p = q ↔ p.1 = q.1 ∧ p.2 = q.2",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {p q : α × β}"},
 {"type": "Prod.map f g = λ p => (f p.1, g p.2)",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ} : Prod.map f g = λ p => (f p.1, g p.2) := by ext; sorry",
  "name": "map_def",
  "kind": "lemma",
  "first-tactic": "ext",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ} : Prod.map f g = λ p => (f p.1, g p.2)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ}"},
 {"type": "injective (Prod.map f g)",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ}  (hf : injective f)  (hg : injective g) : injective (Prod.map f g) := by intros x y h; sorry",
  "name": "Function.injective.prod_map",
  "kind": "lemma",
  "first-tactic": "intros x y h",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ}  (hf : injective f)  (hg : injective g) : injective (Prod.map f g)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ}  (hf : injective f)  (hg : injective g)"},
 {"type": "0 < UInt8.size",
  "tactic-prompt": "lemma  : 0 < UInt8.size := by decide; sorry",
  "name": "UInt8.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt8.size",
  "args": ""},
 {"type": "0 < UInt16.size",
  "tactic-prompt": "lemma  : 0 < UInt16.size := by decide; sorry",
  "name": "UInt16.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt16.size",
  "args": ""},
 {"type": "0 < UInt32.size",
  "tactic-prompt": "lemma  : 0 < UInt32.size := by decide; sorry",
  "name": "UInt32.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt32.size",
  "args": ""},
 {"type": "0 < UInt64.size",
  "tactic-prompt": "lemma  : 0 < UInt64.size := by decide; sorry",
  "name": "UInt64.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt64.size",
  "args": ""},
 {"type": "Nat.isValidChar (UInt32.ofNat n).1",
  "tactic-prompt":
  "theorem (n : Nat)  (h : n < size) : Nat.isValidChar (UInt32.ofNat n).1 := by rw [UInt32.val_eq_of_lt]; sorry",
  "name": "toChar_aux",
  "kind": "theorem",
  "first-tactic": "rw [UInt32.val_eq_of_lt]",
  "core-prompt":
  "(n : Nat)  (h : n < size) : Nat.isValidChar (UInt32.ofNat n).1",
  "args": "(n : Nat)  (h : n < size)"},
 {"type": "0 < c.utf8Size",
  "tactic-prompt":
  "theorem (c : Char) : 0 < c.utf8Size := by simp only [utf8Size]; sorry",
  "name": "Char.utf8Size_pos",
  "kind": "theorem",
  "first-tactic": "simp only [utf8Size]",
  "core-prompt": "(c : Char) : 0 < c.utf8Size",
  "args": "(c : Char)"},
 {"type": "m ∈ range n ↔ m < n",
  "tactic-prompt":
  "theorem {m n : ℕ} : m ∈ range n ↔ m < n := by simp only [range_eq_range', mem_range', Nat.zero_le, true_and, Nat.zero_add]; sorry",
  "name": "mem_range",
  "kind": "theorem",
  "first-tactic":
  "simp only [range_eq_range', mem_range', Nat.zero_le, true_and, Nat.zero_add]",
  "core-prompt": "{m n : ℕ} : m ∈ range n ↔ m < n",
  "args": "{m n : ℕ}"},
 {"type": "Nodup (range n)",
  "tactic-prompt":
  "theorem (n : ℕ) : Nodup (range n) := by simp only [range_eq_range', nodup_range']; sorry",
  "name": "nodup_range",
  "kind": "theorem",
  "first-tactic": "simp only [range_eq_range', nodup_range']",
  "core-prompt": "(n : ℕ) : Nodup (range n)",
  "args": "(n : ℕ)"},
 {"type": "a ∈ toList o ↔ a ∈ o",
  "tactic-prompt":
  "theorem {a : α}  {o : Option α} : a ∈ toList o ↔ a ∈ o := by cases o; sorry",
  "name": "Option.mem_toList",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": "{a : α}  {o : Option α} : a ∈ toList o ↔ a ∈ o",
  "args": "{a : α}  {o : Option α}"},
 {"type": "∃ s t : List α, l = s ++ a :: t",
  "tactic-prompt":
  "theorem {a : α}  {l : List α}  (h : a ∈ l) : ∃ s t : List α, l = s ++ a :: t := by induction l; sorry",
  "name": "mem_split",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : α}  {l : List α}  (h : a ∈ l) : ∃ s t : List α, l = s ++ a :: t",
  "args": "{a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "injective (List.length : List α → ℕ) ↔ Subsingleton α",
  "tactic-prompt":
  "lemma  : injective (List.length : List α → ℕ) ↔ Subsingleton α := by constructor; sorry",
  "name": "length_injective_iff",
  "kind": "lemma",
  "first-tactic": "constructor",
  "core-prompt": " : injective (List.length : List α → ℕ) ↔ Subsingleton α",
  "args": ""},
 {"type": "i = j",
  "tactic-prompt":
  "theorem {α : Type u}  {xs : List α}  {i j : ℕ}    (h₀ : i < xs.length)    (h₁ : Nodup xs)    (h₂ : xs.get? i = xs.get? j) : i = j := by induction xs generalizing i j with\n  | nil => cases h₀\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases h₁ with\n      | cons ha h₁ => exact ih (Nat.lt_of_succ_lt_succ h₀) h₁ h₂\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at h₂\n      cases h₁; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact ⟨_, h₂⟩; exact ⟨_ , h₂.symm⟩; sorry",
  "name": "get?_injective",
  "kind": "theorem",
  "first-tactic":
  "induction xs generalizing i j with\n  | nil => cases h₀\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases h₁ with\n      | cons ha h₁ => exact ih (Nat.lt_of_succ_lt_succ h₀) h₁ h₂\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at h₂\n      cases h₁; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact ⟨_, h₂⟩; exact ⟨_ , h₂.symm⟩",
  "core-prompt":
  "{α : Type u}  {xs : List α}  {i j : ℕ}    (h₀ : i < xs.length)    (h₁ : Nodup xs)    (h₂ : xs.get? i = xs.get? j) : i = j",
  "args":
  "{α : Type u}  {xs : List α}  {i j : ℕ}    (h₀ : i < xs.length)    (h₁ : Nodup xs)    (h₂ : xs.get? i = xs.get? j)"},
 {"type": "(x, y) ∈ product xs ys ↔ x ∈ xs ∧ y ∈ ys",
  "tactic-prompt":
  "theorem (xs : List α)  (ys : List β)  (x : α)  (y : β) : (x, y) ∈ product xs ys ↔ x ∈ xs ∧ y ∈ ys := by constructor; sorry",
  "name": "product_spec",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "(xs : List α)  (ys : List β)  (x : α)  (y : β) : (x, y) ∈ product xs ys ↔ x ∈ xs ∧ y ∈ ys",
  "args": "(xs : List α)  (ys : List β)  (x : α)  (y : β)"},
 {"type": "l.attach.map Subtype.val = l",
  "tactic-prompt":
  "theorem (l : List α) : l.attach.map Subtype.val = l := by rw [attach, map_pmap]; sorry",
  "name": "attach_map_val",
  "kind": "theorem",
  "first-tactic": "rw [attach, map_pmap]",
  "core-prompt": "(l : List α) : l.attach.map Subtype.val = l",
  "args": "(l : List α)"},
 {"type": "l₂ ~ l₁",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  (p : l₁ ~ l₂) : l₂ ~ l₁ := by induction p; sorry",
  "name": "Perm.symm",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{l₁ l₂ : List α}  (p : l₁ ~ l₂) : l₂ ~ l₁",
  "args": "{l₁ l₂ : List α}  (p : l₁ ~ l₂)"},
 {"type": "l₁ ⊆ l₂",
  "tactic-prompt":
  "theorem {α : Type u}  {l₁ l₂ : List α}  (p : l₁ ~ l₂) : l₁ ⊆ l₂ := by induction p; sorry",
  "name": "Perm.subset",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{α : Type u}  {l₁ l₂ : List α}  (p : l₁ ~ l₂) : l₁ ⊆ l₂",
  "args": "{α : Type u}  {l₁ l₂ : List α}  (p : l₁ ~ l₂)"},
 {"type": "length l₁ = length l₂",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  (p : l₁ ~ l₂) : length l₁ = length l₂ := by induction p; sorry",
  "name": "Perm.length_eq",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{l₁ l₂ : List α}  (p : l₁ ~ l₂) : length l₁ = length l₂",
  "args": "{l₁ l₂ : List α}  (p : l₁ ~ l₂)"},
 {"type": "∀ {l₁ l₂ : List α}, l₁ ~ l₂ → (Pairwise R l₁ ↔ Pairwise R l₂)",
  "tactic-prompt":
  "theorem {R : α → α → Prop}  (S : symmetric R) : ∀ {l₁ l₂ : List α}, l₁ ~ l₂ → (Pairwise R l₁ ↔ Pairwise R l₂) := by suffices ∀ {l₁ l₂}, l₁ ~ l₂ → Pairwise R l₁ → Pairwise R l₂ from\n    fun l₁ l₂ p => ⟨this p, this p.symm⟩; sorry",
  "name": "Perm.pairwise_iff",
  "kind": "theorem",
  "first-tactic":
  "suffices ∀ {l₁ l₂}, l₁ ~ l₂ → Pairwise R l₁ → Pairwise R l₂ from\n    fun l₁ l₂ p => ⟨this p, this p.symm⟩",
  "core-prompt":
  "{R : α → α → Prop}  (S : symmetric R) : ∀ {l₁ l₂ : List α}, l₁ ~ l₂ → (Pairwise R l₁ ↔ Pairwise R l₂)",
  "args": "{R : α → α → Prop}  (S : symmetric R)"},
 {"type": "Pairwise R (l₁ ++ l₂) ↔ Pairwise R (l₂ ++ l₁)",
  "tactic-prompt":
  "theorem {α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} (s : symmetric R)  {l₁ l₂ : List α} : Pairwise R (l₁ ++ l₂) ↔ Pairwise R (l₂ ++ l₁) := by have : ∀ l₁ l₂ : List α, (∀ x : α, x ∈ l₁ → ∀ y : α, y ∈ l₂ → R x y) →\n    ∀ x : α, x ∈ l₂ → ∀ y : α, y ∈ l₁ → R x y := fun l₁ l₂ a x xm y ym => s (a y ym x xm); sorry",
  "name": "pairwise_append_comm",
  "kind": "theorem",
  "first-tactic":
  "have : ∀ l₁ l₂ : List α, (∀ x : α, x ∈ l₁ → ∀ y : α, y ∈ l₂ → R x y) →\n    ∀ x : α, x ∈ l₂ → ∀ y : α, y ∈ l₁ → R x y := fun l₁ l₂ a x xm y ym => s (a y ym x xm)",
  "core-prompt":
  "{α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} (s : symmetric R)  {l₁ l₂ : List α} : Pairwise R (l₁ ++ l₂) ↔ Pairwise R (l₂ ++ l₁)",
  "args":
  "{α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} (s : symmetric R)  {l₁ l₂ : List α}"},
 {"type": "Pairwise S l",
  "tactic-prompt":
  "theorem {α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} {S : α → α → Prop}  {l : List α}      (H : ∀ {a b}, a ∈ l → b ∈ l → R a b → S a b)  (p : Pairwise R l) : Pairwise S l := by induction p; sorry",
  "name": "Pairwise.imp_of_mem",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} {S : α → α → Prop}  {l : List α}      (H : ∀ {a b}, a ∈ l → b ∈ l → R a b → S a b)  (p : Pairwise R l) : Pairwise S l",
  "args":
  "{α β : Type _}  {R S T : α → α → Prop}  {a : α}  {l : List α} {S : α → α → Prop}  {l : List α}      (H : ∀ {a b}, a ∈ l → b ∈ l → R a b → S a b)  (p : Pairwise R l)"},
 {"type": "b ∈ remove a as ↔ b ∈ as ∧ b ≠ a",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α} : b ∈ remove a as ↔ b ∈ as ∧ b ≠ a := by induction as; sorry",
  "name": "mem_remove_iff",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α} : b ∈ remove a as ↔ b ∈ as ∧ b ≠ a",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α}"},
 {"type": "b ∈ as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α}  (h : b ∈ remove a as) : b ∈ as := by rw [mem_remove_iff] at h; sorry",
  "name": "mem_of_mem_remove",
  "kind": "theorem",
  "first-tactic": "rw [mem_remove_iff] at h",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α}  (h : b ∈ remove a as) : b ∈ as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α}  (h : b ∈ remove a as)"},
 {"type": "card (a :: as) = card as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as) : card (a :: as) = card as := by simp [card]; sorry",
  "name": "card_cons_of_mem",
  "kind": "theorem",
  "first-tactic": "simp [card]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as) : card (a :: as) = card as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as)"},
 {"type": "card (a :: as) = card as + 1",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as) : card (a :: as) = card as + 1 := by simp [card]; sorry",
  "name": "card_cons_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp [card]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as) : card (a :: as) = card as + 1",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as)"},
 {"type": "card as ≤ card (a :: as)",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ (a : α)  (as : List α) : card as ≤ card (a :: as) := by cases Decidable.em (a ∈ as); sorry",
  "name": "card_le_card_cons",
  "kind": "theorem",
  "first-tactic": "cases Decidable.em (a ∈ as)",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ (a : α)  (as : List α) : card as ≤ card (a :: as)",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ (a : α)  (as : List α)"},
 {"type": "card (as.insert a) = card as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as) : card (as.insert a) = card as := by simp [h]; sorry",
  "name": "card_insert_of_mem",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as) : card (as.insert a) = card as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as)"},
 {"type": "card (as.insert a) = card as + 1",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as) : card (as.insert a) = card as + 1 := by simp [h]; sorry",
  "name": "card_insert_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as) : card (as.insert a) = card as + 1",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as)"},
 {"type": "card (as.map f) ≤ card as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ (f : α → β)  (as : List α) : card (as.map f) ≤ card as := by induction as; sorry",
  "name": "card_map_le",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ (f : α → β)  (as : List α) : card (as.map f) ≤ card as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ (f : α → β)  (as : List α)"},
 {"type": "inj_on f as →  card (as.map f) = card as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {f : α → β}  {as : List α} : inj_on f as →  card (as.map f) = card as := by induction as; sorry",
  "name": "card_map_eq_of_inj_on",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {f : α → β}  {as : List α} : inj_on f as →  card (as.map f) = card as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {f : α → β}  {as : List α}"},
 {"type": "card (as.union bs) = card as + card bs",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {as bs : List α}  (h : Disjoint as bs) : card (as.union bs) = card as + card bs := by rw [card_eq_of_equiv (union_equiv_append as bs), card_append_disjoint h]; sorry",
  "name": "card_union_disjoint",
  "kind": "theorem",
  "first-tactic":
  "rw [card_eq_of_equiv (union_equiv_append as bs), card_append_disjoint h]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {as bs : List α}  (h : Disjoint as bs) : card (as.union bs) = card as + card bs",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {as bs : List α}  (h : Disjoint as bs)"},
 {"type": "Chain S b l",
  "tactic-prompt":
  "theorem {R S : α → α → Prop}  (HRS : ∀ ⦃a b⦄, R a b → S a b)  {a b : α}      (Hab : ∀ ⦃c⦄, R a c → S b c)  {l : List α}  (p : Chain R a l) : Chain S b l := by induction p generalizing b with\n  | nil => constructor\n  | cons r _ ih =>\n    constructor\n    · exact Hab r\n    · exact ih (@HRS _); sorry",
  "name": "Chain.imp'",
  "kind": "theorem",
  "first-tactic":
  "induction p generalizing b with\n  | nil => constructor\n  | cons r _ ih =>\n    constructor\n    · exact Hab r\n    · exact ih (@HRS _)",
  "core-prompt":
  "{R S : α → α → Prop}  (HRS : ∀ ⦃a b⦄, R a b → S a b)  {a b : α}      (Hab : ∀ ⦃c⦄, R a c → S b c)  {l : List α}  (p : Chain R a l) : Chain S b l",
  "args":
  "{R S : α → α → Prop}  (HRS : ∀ ⦃a b⦄, R a b → S a b)  {a b : α}      (Hab : ∀ ⦃c⦄, R a c → S b c)  {l : List α}  (p : Chain R a l)"},
 {"type": "Chain R a l",
  "tactic-prompt":
  "theorem (p : Pairwise R (a :: l)) : Chain R a l := by rcases Pairwise_cons.1 p with ⟨r,p'⟩; sorry",
  "name": "Pairwise.chain",
  "kind": "theorem",
  "first-tactic": "rcases Pairwise_cons.1 p with ⟨r,p'⟩",
  "core-prompt": "(p : Pairwise R (a :: l)) : Chain R a l",
  "args": "(p : Pairwise R (a :: l))"},
 {"type": "Function.injective (@LinearOrder.toPartialOrder α)",
  "tactic-prompt":
  "lemma {α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α} {α : Type _} : Function.injective (@LinearOrder.toPartialOrder α) := by intros A B h; sorry",
  "name": "LinearOrder.to_partial_order_injective",
  "kind": "lemma",
  "first-tactic": "intros A B h",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α} {α : Type _} : Function.injective (@LinearOrder.toPartialOrder α)",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α} {α : Type _}"},
 {"type": "x < y ↔ x ≤ y ∧ ∃ i, x i < y i",
  "tactic-prompt":
  "theorem {α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α} {ι : Type u}  {α: ι → Type v}  [∀ i, Preorder (α i)]  {x y : ∀ i, α i} : x < y ↔ x ≤ y ∧ ∃ i, x i < y i := by simp ( config := { contextual := true } ) [lt_iff_le_not_le, Pi.le_def]; sorry",
  "name": "Pi.lt_def",
  "kind": "theorem",
  "first-tactic":
  "simp ( config := { contextual := true } ) [lt_iff_le_not_le, Pi.le_def]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α} {ι : Type u}  {α: ι → Type v}  [∀ i, Preorder (α i)]  {x y : ∀ i, α i} : x < y ↔ x ≤ y ∧ ∃ i, x i < y i",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α} {ι : Type u}  {α: ι → Type v}  [∀ i, Preorder (α i)]  {x y : ∀ i, α i}"},
 {"type":
  "Function.update x i a ≤ Function.update y i b ↔ a ≤ b ∧ ∀ j, j ≠ i → x j ≤ y j",
  "tactic-prompt":
  "lemma {α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α} {ι : Type u}  {α : ι → Type v}  [∀ i, Preorder (α i)]  [DecidableEq ι]    {x y : ∀ i, α i}  {i : ι}  {a b : α i} : Function.update x i a ≤ Function.update y i b ↔ a ≤ b ∧ ∀ j, j ≠ i → x j ≤ y j := by simp (config := {contextual := true}) [update_le_iff]; sorry",
  "name": "update_le_update_iff",
  "kind": "lemma",
  "first-tactic": "simp (config := {contextual := true}) [update_le_iff]",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α} {ι : Type u}  {α : ι → Type v}  [∀ i, Preorder (α i)]  [DecidableEq ι]    {x y : ∀ i, α i}  {i : ι}  {a b : α i} : Function.update x i a ≤ Function.update y i b ↔ a ≤ b ∧ ∀ j, j ≠ i → x j ≤ y j",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α} {ι : Type u}  {α : ι → Type v}  [∀ i, Preorder (α i)]  [DecidableEq ι]    {x y : ∀ i, α i}  {i : ι}  {a b : α i}"},
 {"type":
  "(instPreorderProd _ _).lt x y ↔ x.1 < y.1 ∧ x.2 ≤ y.2 ∨ x.1 ≤ y.1 ∧ x.2 < y.2",
  "tactic-prompt":
  "lemma {α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [Preorder α]  [Preorder β]  {a a₁ a₂ : α}  {b b₁ b₂ : β}  {x y : α × β} : (instPreorderProd _ _).lt x y ↔ x.1 < y.1 ∧ x.2 ≤ y.2 ∨ x.1 ≤ y.1 ∧ x.2 < y.2 := by refine Iff.intro ?_ ?; sorry",
  "name": "lt_iff",
  "kind": "lemma",
  "first-tactic": "refine Iff.intro ?_ ?",
  "core-prompt":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [Preorder α]  [Preorder β]  {a a₁ a₂ : α}  {b b₁ b₂ : β}  {x y : α × β} : (instPreorderProd _ _).lt x y ↔ x.1 < y.1 ∧ x.2 ≤ y.2 ∨ x.1 ≤ y.1 ∧ x.2 < y.2",
  "args":
  "{α : Type u}  {β : Type v}  {γ : Type w}  {r : α → α → Prop} [Preorder α]  {x y z : α}  [Preorder α]  [Preorder β]  {a a₁ a₂ : α}  {b b₁ b₂ : β}  {x y : α × β}"},
 {"type": "{a : ℤ} → ¬(a + a + 1 = 0)",
  "tactic-prompt": "lemma  : {a : ℤ} → ¬(a + a + 1 = 0) := by intro a h; sorry",
  "name": "odd_ne_zero",
  "kind": "lemma",
  "first-tactic": "intro a h",
  "core-prompt": " : {a : ℤ} → ¬(a + a + 1 = 0)",
  "args": ""},
 {"type": "∀ g : P, g ^ 2 = 1 → g = 1",
  "tactic-prompt":
  "theorem  : ∀ g : P, g ^ 2 = 1 → g = 1 := by intro ⟨(p, q, r), x⟩; sorry",
  "name": "square_free",
  "kind": "theorem",
  "first-tactic": "intro ⟨(p, q, r), x⟩",
  "core-prompt": " : ∀ g : P, g ^ 2 = 1 → g = 1",
  "args": ""},
 {"type": "∀ {q : Q}, c 0 q = (0 : K)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ {q : Q}, c 0 q = (0 : K) := by intro q; sorry",
  "name": "leftId",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ {q : Q}, c 0 q = (0 : K)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ {q : Q}, c q 0 = (0 : K)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ {q : Q}, c q 0 = (0 : K) := by intro q; sorry",
  "name": "rightId",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ {q : Q}, c q 0 = (0 : K)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ q : Q, c q (-q) = q • (c (-q) q)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ q : Q, c q (-q) = q • (c (-q) q) := by intro q; sorry",
  "name": "invRel",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ q : Q, c q (-q) = q • (c (-q) q)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ q : Q, c (-q) q = (-q) • (c q (-q))",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ q : Q, c (-q) q = (-q) • (c q (-q)) := by intro q; sorry",
  "name": "invRel'",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ q : Q, c (-q) q = (-q) • (c q (-q))",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ k k' : Metabelian.Kernel Q K, k * k' = k' * k",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]  /- The multiplication operation defined using the cocycle. The cocycle condition is crucially used in showing associativity and other properties. -/  (Q K : Type _)  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ k k' : Metabelian.Kernel Q K, k * k' = k' * k := by intro ⟨⟨ka, 0⟩, rfl⟩; sorry",
  "name": "Metabelian.Kernel.mul_comm",
  "kind": "theorem",
  "first-tactic": "intro ⟨⟨ka, 0⟩, rfl⟩",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]  /- The multiplication operation defined using the cocycle. The cocycle condition is crucially used in showing associativity and other properties. -/  (Q K : Type _)  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ k k' : Metabelian.Kernel Q K, k * k' = k' * k",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]  /- The multiplication operation defined using the cocycle. The cocycle condition is crucially used in showing associativity and other properties. -/  (Q K : Type _)  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ {a : A}, a • (0 : B) = (0 : B)",
  "tactic-prompt":
  "theorem (A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, a • (0 : B) = (0 : B) := by intro; sorry",
  "name": "act_zero",
  "kind": "theorem",
  "first-tactic": "intro",
  "core-prompt":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, a • (0 : B) = (0 : B)",
  "args":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α]"},
 {"type": "∀ {a : A}, ∀ {b b' : B}, a • (b + b') = a • b + a • b'",
  "tactic-prompt":
  "theorem (A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, ∀ {b b' : B}, a • (b + b') = a • b + a • b' := by intro; sorry",
  "name": "add_dist",
  "kind": "theorem",
  "first-tactic": "intro",
  "core-prompt":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, ∀ {b b' : B}, a • (b + b') = a • b + a • b'",
  "args":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α]"},
 {"type": "∀ {a : A}, ∀ {b : B}, a • (-b) = - (a • b)",
  "tactic-prompt":
  "theorem (A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, ∀ {b : B}, a • (-b) = - (a • b) := by intros; sorry",
  "name": "neg_push",
  "kind": "theorem",
  "first-tactic": "intros",
  "core-prompt":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, ∀ {b : B}, a • (-b) = - (a • b)",
  "args":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α]"},
 {"type": "∀ x : Fin 3, x + 0 = x",
  "tactic-prompt": "example  : ∀ x : Fin 3, x + 0 = x := by decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x : Fin 3, x + 0 = x",
  "args": ""},
 {"type": "∀ x y : Fin 3, x + y = y + x",
  "tactic-prompt":
  "example  : ∀ x y : Fin 3, x + y = y + x := by decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x y : Fin 3, x + y = y + x",
  "args": ""},
 {"type": "∀ x y z : Fin 3, (x + y) + z = x + (y + z)",
  "tactic-prompt":
  "theorem  : ∀ x y z : Fin 3, (x + y) + z = x + (y + z) := by decide; sorry",
  "name": "Zmod3.assoc",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x y z : Fin 3, (x + y) + z = x + (y + z)",
  "args": ""},
 {"type":
  "∀ xy : (Fin 3) × (Fin 2), \n      xy.1.val + xy.2.val  = xy.2.val + xy.1.val",
  "tactic-prompt":
  "example  : ∀ xy : (Fin 3) × (Fin 2), \n      xy.1.val + xy.2.val  = xy.2.val + xy.1.val := by decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "decide",
  "core-prompt":
  " : ∀ xy : (Fin 3) × (Fin 2), \n      xy.1.val + xy.2.val  = xy.2.val + xy.1.val",
  "args": ""},
 {"type": "ps.fst.length + 1 ≤ w.length",
  "tactic-prompt":
  "theorem {l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.fst.length + 1 ≤ w.length := by let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append; sorry",
  "name": "splitFirst",
  "kind": "theorem",
  "first-tactic":
  "let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append",
  "core-prompt":
  "{l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.fst.length + 1 ≤ w.length",
  "args": "{l: Letter} {w: Word} (ps: ProvedSplit l w)"},
 {"type": "ps.snd.length + 1 ≤ w.length",
  "tactic-prompt":
  "theorem {l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.snd.length + 1 ≤ w.length := by let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append; sorry",
  "name": "splitSecond",
  "kind": "theorem",
  "first-tactic":
  "let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append",
  "core-prompt":
  "{l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.snd.length + 1 ≤ w.length",
  "args": "{l: Letter} {w: Word} (ps: ProvedSplit l w)"},
 {"type": "ProofTree (x :: w)",
  "tactic-prompt":
  "def {w : Word}  (x: Letter)           (pt: ProofTree w) : ProofTree (x :: w) := by have exp : x :: w = [x] ++ w := by rfl; sorry",
  "name": "ProofTree.prepend",
  "kind": "def",
  "first-tactic": "have exp : x :: w = [x] ++ w := by rfl",
  "core-prompt":
  "{w : Word}  (x: Letter)           (pt: ProofTree w) : ProofTree (x :: w)",
  "args": "{w : Word}  (x: Letter)           (pt: ProofTree w)"},
 {"type":
  "∀ g h : K × Q, MetabelianGroup.mul trivial_cocycle g h = MetabelianGroup.mul trivial_cocycle h g",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] : ∀ g h : K × Q, MetabelianGroup.mul trivial_cocycle g h = MetabelianGroup.mul trivial_cocycle h g := by intro (k, q); sorry",
  "name": "product_comm",
  "kind": "theorem",
  "first-tactic": "intro (k, q)",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] : ∀ g h : K × Q, MetabelianGroup.mul trivial_cocycle g h = MetabelianGroup.mul trivial_cocycle h g",
  "args": "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K]"},
 {"type": "(a, b) = (c, d) ↔ (a = c) ∧ (b = d)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] {α β : Type _}  (a c : α)  (b d : β) : (a, b) = (c, d) ↔ (a = c) ∧ (b = d) := by apply Iff.intro; sorry",
  "name": "prod_eq",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] {α β : Type _}  (a c : α)  (b d : β) : (a, b) = (c, d) ↔ (a = c) ∧ (b = d)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] {α β : Type _}  (a c : α)  (b d : β)"},
 {"type":
  "MetabelianGroup.mul trivial_cocycle (a, b) (a', b') = (a + a', b + b')",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] {a a' : A}  {b b' : B} : MetabelianGroup.mul trivial_cocycle (a, b) (a', b') = (a + a', b + b') := by show (a + a' + 0, b + b') = _; sorry",
  "name": "mul",
  "kind": "theorem",
  "first-tactic": "show (a + a' + 0, b + b') = _",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] {a a' : A}  {b b' : B} : MetabelianGroup.mul trivial_cocycle (a, b) (a', b') = (a + a', b + b')",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] {a a' : A}  {b b' : B}"},
 {"type": "(a, b) + (a', b') = (a + a', b + b')",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] (a a' : A)  (b b' : B) : (a, b) + (a', b') = (a + a', b + b') := by simp only [HAdd.hAdd, Add.add]; sorry",
  "name": "add",
  "kind": "theorem",
  "first-tactic": "simp only [HAdd.hAdd, Add.add]",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] (a a' : A)  (b b' : B) : (a, b) + (a', b') = (a + a', b + b')",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] (a a' : A)  (b b' : B)"},
 {"type": "gsmul (n+1) x = x + gsmul n x",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (n: ℤ)  (x : A) : gsmul (n+1) x = x + gsmul n x := by cases n; sorry",
  "name": "gsmul_succ",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (n: ℤ)  (x : A) : gsmul (n+1) x = x + gsmul n x",
  "args": "{A : Type}  [abg : AddCommGroup A] (n: ℤ)  (x : A)"},
 {"type": "zhom x (n + m) = zhom x n + zhom x m",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x : A)  (n : ℤ)  (m: Nat) : zhom x (n + m) = zhom x n + zhom x m := by induction m; sorry",
  "name": "isHom₁",
  "kind": "theorem",
  "first-tactic": "induction m",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (x : A)  (n : ℤ)  (m: Nat) : zhom x (n + m) = zhom x n + zhom x m",
  "args": "{A : Type}  [abg : AddCommGroup A] (x : A)  (n : ℤ)  (m: Nat)"},
 {"type":
  "zhom x ((Int.negSucc n) + (Int.negSucc m)) = \n          zhom x (Int.negSucc m) + zhom x (Int.negSucc n)",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x : A)  (n m : Nat) : zhom x ((Int.negSucc n) + (Int.negSucc m)) = \n          zhom x (Int.negSucc m) + zhom x (Int.negSucc n) := by simp [zhom]; sorry",
  "name": "isHom₂",
  "kind": "theorem",
  "first-tactic": "simp [zhom]",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (x : A)  (n m : Nat) : zhom x ((Int.negSucc n) + (Int.negSucc m)) = \n          zhom x (Int.negSucc m) + zhom x (Int.negSucc n)",
  "args": "{A : Type}  [abg : AddCommGroup A] (x : A)  (n m : Nat)"},
 {"type": "zhom x (n + m) = zhom x n + zhom x m",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x: A)  (n m : ℤ) : zhom x (n + m) = zhom x n + zhom x m := by cases m; sorry",
  "name": "zhom_is_hom",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (x: A)  (n m : ℤ) : zhom x (n + m) = zhom x n + zhom x m",
  "args": "{A : Type}  [abg : AddCommGroup A] (x: A)  (n m : ℤ)"},
 {"type": "zhom x 1 = x",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x : A) : zhom x 1 = x := by simp [zhom]; sorry",
  "name": "zhom_one",
  "kind": "theorem",
  "first-tactic": "simp [zhom]",
  "core-prompt": "{A : Type}  [abg : AddCommGroup A] (x : A) : zhom x 1 = x",
  "args": "{A : Type}  [abg : AddCommGroup A] (x : A)"},
 {"type": "f 1 = g 1  → ∀ n: ℕ, f (n + 1) = g (n + 1)",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  → ∀ n: ℕ, f (n + 1) = g (n + 1) := by intro hyp; sorry",
  "name": "unique_morphism_nat",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  → ∀ n: ℕ, f (n + 1) = g (n + 1)",
  "args":
  "{A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g]"},
 {"type": "f 1 = g 1  → f = g",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  → f = g := by intro hyp; sorry",
  "name": "unique_morphism",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  → f = g",
  "args":
  "{A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g]"},
 {"type": "F → A",
  "tactic-prompt":
  "def {F: Type} [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]  (f: X → A) : F → A := by apply fag.inducedMap; sorry",
  "name": "fromBasis",
  "kind": "def",
  "first-tactic": "apply fag.inducedMap",
  "core-prompt":
  "{F: Type} [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]  (f: X → A) : F → A",
  "args":
  "{F: Type} [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]  (f: X → A)"},
 {"type":
  "@AddCommGroup.Homomorphism F A _ _ \n    (@fromBasis F _ X  fag A _ f)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A} : @AddCommGroup.Homomorphism F A _ _ \n    (@fromBasis F _ X  fag A _ f) := by apply fag.induced_hom; sorry",
  "name": "fromBasisHom",
  "kind": "instance",
  "first-tactic": "apply fag.induced_hom",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A} : @AddCommGroup.Homomorphism F A _ _ \n    (@fromBasis F _ X  fag A _ f)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A}"},
 {"type": "D →  F → A",
  "tactic-prompt":
  "def (F: Type) [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] (D: Type) (f: D → X → A) : D →  F → A := by intro p; sorry",
  "name": "fromBasisFamily",
  "kind": "def",
  "first-tactic": "intro p",
  "core-prompt":
  "(F: Type) [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] (D: Type) (f: D → X → A) : D →  F → A",
  "args":
  "(F: Type) [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] (D: Type) (f: D → X → A)"},
 {"type":
  "@AddCommGroup.Homomorphism F A _ _ \n    ((@fromBasisFamily F _ X  fag A _ D f) p)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] {D : Type}    {f: D → X → A} {p : D} : @AddCommGroup.Homomorphism F A _ _ \n    ((@fromBasisFamily F _ X  fag A _ D f) p) := by apply fag.induced_hom; sorry",
  "name": "fromBasisFamilyHom",
  "kind": "instance",
  "first-tactic": "apply fag.induced_hom",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] {D : Type}    {f: D → X → A} {p : D} : @AddCommGroup.Homomorphism F A _ _ \n    ((@fromBasisFamily F _ X  fag A _ D f) p)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] {D : Type}    {f: D → X → A} {p : D}"},
 {"type": "@AddCommGroup.Homomorphism F A _ _ \n    (fag.inducedMap A f)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A} : @AddCommGroup.Homomorphism F A _ _ \n    (fag.inducedMap A f) := by apply fag.induced_hom; sorry",
  "name": "fromBasisHom'",
  "kind": "instance",
  "first-tactic": "apply fag.induced_hom",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A} : @AddCommGroup.Homomorphism F A _ _ \n    (fag.inducedMap A f)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A}"},
 {"type": "Decidable (f = g)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fgp : FreeAbelianGroup F X]    {A: Type} [AddCommGroup A] [DecidableEq A] [DecideForall X]      (f g : F → A) [AddCommGroup.Homomorphism f] [AddCommGroup.Homomorphism g] : Decidable (f = g) := by apply decideHomsEqual X; sorry",
  "name": "decHomsEqual",
  "kind": "instance",
  "first-tactic": "apply decideHomsEqual X",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fgp : FreeAbelianGroup F X]    {A: Type} [AddCommGroup A] [DecidableEq A] [DecideForall X]      (f g : F → A) [AddCommGroup.Homomorphism f] [AddCommGroup.Homomorphism g] : Decidable (f = g)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fgp : FreeAbelianGroup F X]    {A: Type} [AddCommGroup A] [DecidableEq A] [DecideForall X]      (f g : F → A) [AddCommGroup.Homomorphism f] [AddCommGroup.Homomorphism g]"},
 {"type":
  "∀ (x y: Fin 2), \n  (egAction' x) ∘ (egAction' y) = egAction' (x + y)",
  "tactic-prompt":
  "theorem  : ∀ (x y: Fin 2), \n  (egAction' x) ∘ (egAction' y) = egAction' (x + y) := by decide; sorry",
  "name": "egIsAction",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt":
  " : ∀ (x y: Fin 2), \n  (egAction' x) ∘ (egAction' y) = egAction' (x + y)",
  "args": ""},
 {"type":
  "(FreeAbelianGroup.inducedMap G f) ∘ (ι₁ : A → A × B) = (FAb_A.inducedMap G (f ∘ Sum.inl))",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G) : (FreeAbelianGroup.inducedMap G f) ∘ (ι₁ : A → A × B) = (FAb_A.inducedMap G (f ∘ Sum.inl)) := by apply funext; sorry",
  "name": "FreeAbelianGroup.induced_left",
  "kind": "theorem",
  "first-tactic": "apply funext",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G) : (FreeAbelianGroup.inducedMap G f) ∘ (ι₁ : A → A × B) = (FAb_A.inducedMap G (f ∘ Sum.inl))",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G)"},
 {"type":
  "(FreeAbelianGroup.inducedMap G f) ∘ (ι₂ : B → A × B) = (FAb_B.inducedMap G (f ∘ Sum.inr))",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G) : (FreeAbelianGroup.inducedMap G f) ∘ (ι₂ : B → A × B) = (FAb_B.inducedMap G (f ∘ Sum.inr)) := by apply funext; sorry",
  "name": "FreeAbelianGroup.induced_right",
  "kind": "theorem",
  "first-tactic": "apply funext",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G) : (FreeAbelianGroup.inducedMap G f) ∘ (ι₂ : B → A × B) = (FAb_B.inducedMap G (f ∘ Sum.inr))",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G)"},
 {"type":
  "FreeAbelianGroup.i ((Sum.inl xa) : X_A ⊕ X_B) = (FAb_A.i xa, (0 : B))",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xa : X_A) : FreeAbelianGroup.i ((Sum.inl xa) : X_A ⊕ X_B) = (FAb_A.i xa, (0 : B)) := by simp [i, ι]; sorry",
  "name": "FreeAbelianGroup.left_incl",
  "kind": "theorem",
  "first-tactic": "simp [i, ι]",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xa : X_A) : FreeAbelianGroup.i ((Sum.inl xa) : X_A ⊕ X_B) = (FAb_A.i xa, (0 : B))",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xa : X_A)"},
 {"type":
  "FreeAbelianGroup.i ((Sum.inr xb) : X_A ⊕ X_B) = ((0 : A), FAb_B.i xb)",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xb : X_B) : FreeAbelianGroup.i ((Sum.inr xb) : X_A ⊕ X_B) = ((0 : A), FAb_B.i xb) := by simp [i, ι]; sorry",
  "name": "FreeAbelianGroup.right_incl",
  "kind": "theorem",
  "first-tactic": "simp [i, ι]",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xb : X_B) : FreeAbelianGroup.i ((Sum.inr xb) : X_A ⊕ X_B) = ((0 : A), FAb_B.i xb)",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xb : X_B)"},
 {"type": "AddCommGroup.Homomorphism (action q)",
  "tactic-prompt":
  "instance (q : Q) : AddCommGroup.Homomorphism (action q) := by revert q; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "revert q",
  "core-prompt": "(q : Q) : AddCommGroup.Homomorphism (action q)",
  "args": "(q : Q)"},
 {"type": "¬ (trivial_element α)",
  "tactic-prompt": "theorem  : ¬ (trivial_element α) := by intro contra; sorry",
  "name": "α_non_trivial",
  "kind": "theorem",
  "first-tactic": "intro contra",
  "core-prompt": " : ¬ (trivial_element α)",
  "args": ""},
 {"type": "coords (mulMonom 0 g s) x₀ = 0",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (g x₀: G) (s: FormalSum R G) : coords (mulMonom 0 g s) x₀ = 0 := by induction s; sorry",
  "name": "mul_monom_zero",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (g x₀: G) (s: FormalSum R G) : coords (mulMonom 0 g s) x₀ = 0",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (g x₀: G) (s: FormalSum R G)"},
 {"type":
  "coords (mulMonom b h (s₁  ++ s₂)) x₀ = coords (mulMonom b h s₁) x₀ + coords (mulMonom b h s₂) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G) : coords (mulMonom b h (s₁  ++ s₂)) x₀ = coords (mulMonom b h s₁) x₀ + coords (mulMonom b h s₂) x₀ := by induction s₁; sorry",
  "name": "mul_monom_dist",
  "kind": "theorem",
  "first-tactic": "induction s₁",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G) : coords (mulMonom b h (s₁  ++ s₂)) x₀ = coords (mulMonom b h s₁) x₀ + coords (mulMonom b h s₂) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G)"},
 {"type":
  "coords (mul s₁ (s₂  ++ s₃)) x₀ = coords (mul s₁ s₂) x₀ + coords (mul s₁ s₃) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (x₀ : G) (s₁ s₂ s₃: FormalSum R G) : coords (mul s₁ (s₂  ++ s₃)) x₀ = coords (mul s₁ s₂) x₀ + coords (mul s₁ s₃) x₀ := by induction s₂; sorry",
  "name": "mul_dist",
  "kind": "theorem",
  "first-tactic": "induction s₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (x₀ : G) (s₁ s₂ s₃: FormalSum R G) : coords (mul s₁ (s₂  ++ s₃)) x₀ = coords (mul s₁ s₂) x₀ + coords (mul s₁ s₃) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (x₀ : G) (s₁ s₂ s₃: FormalSum R G)"},
 {"type":
  "coords (mulMonom b h (mulMonom a x s)) x₀ = \n    coords (mulMonom (a * b) (x * h) s) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (a b : R) (h x₀ : G) (s : FormalSum R G) : coords (mulMonom b h (mulMonom a x s)) x₀ = \n    coords (mulMonom (a * b) (x * h) s) x₀ := by induction s; sorry",
  "name": "mul_monom_monom_assoc",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (a b : R) (h x₀ : G) (s : FormalSum R G) : coords (mulMonom b h (mulMonom a x s)) x₀ = \n    coords (mulMonom (a * b) (x * h) s) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (a b : R) (h x₀ : G) (s : FormalSum R G)"},
 {"type":
  "coords (mulMonom b h (mul s₁ s₂)) x₀ = \n    coords (mul s₁ (mulMonom b h s₂)) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G) : coords (mulMonom b h (mul s₁ s₂)) x₀ = \n    coords (mul s₁ (mulMonom b h s₂)) x₀ := by induction s₂; sorry",
  "name": "mul_monom_assoc",
  "kind": "theorem",
  "first-tactic": "induction s₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G) : coords (mulMonom b h (mul s₁ s₂)) x₀ = \n    coords (mul s₁ (mulMonom b h s₂)) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G)"},
 {"type":
  "coords (mulMonom (b₁ + b₂) h s) x₀ = coords (mulMonom b₁ h s) x₀ + coords (mulMonom b₂ h s) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b₁ b₂ : R) (h x₀ : G) (s: FormalSum R G) : coords (mulMonom (b₁ + b₂) h s) x₀ = coords (mulMonom b₁ h s) x₀ + coords (mulMonom b₂ h s) x₀ := by induction s; sorry",
  "name": "mul_monom_add",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b₁ b₂ : R) (h x₀ : G) (s: FormalSum R G) : coords (mulMonom (b₁ + b₂) h s) x₀ = coords (mulMonom b₁ h s) x₀ + coords (mulMonom b₂ h s) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b₁ b₂ : R) (h x₀ : G) (s: FormalSum R G)"},
 {"type": "mul s ((0, h) :: t) ≈  mul s t",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s t : FormalSum R G) (g: G) : mul s ((0, h) :: t) ≈  mul s t := by induction s; sorry",
  "name": "mul_zero_cons",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s t : FormalSum R G) (g: G) : mul s ((0, h) :: t) ≈  mul s t",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s t : FormalSum R G) (g: G)"},
 {"type": "FormalSum R G → FreeModule R G → FreeModule R G",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FormalSum R G → FreeModule R G → FreeModule R G := by intro s; sorry",
  "name": "mulAux",
  "kind": "def",
  "first-tactic": "intro s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FormalSum R G → FreeModule R G → FreeModule R G",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G]"},
 {"type": "coords (mulMonom b h s₁) x₀ = coords (mulMonom b h s₂) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂ : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂) : coords (mulMonom b h s₁) x₀ = coords (mulMonom b h s₂) x₀ := by induction rel; sorry",
  "name": "mul_monom_invariant",
  "kind": "theorem",
  "first-tactic": "induction rel",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂ : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂) : coords (mulMonom b h s₁) x₀ = coords (mulMonom b h s₂) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂ : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂)"},
 {"type": "FormalSum.mul s₁ t ≈  FormalSum.mul s₂ t",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s₁ s₂ t : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂) : FormalSum.mul s₁ t ≈  FormalSum.mul s₂ t := by cases t; sorry",
  "name": "first_arg_invariant",
  "kind": "theorem",
  "first-tactic": "cases t",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s₁ s₂ t : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂) : FormalSum.mul s₁ t ≈  FormalSum.mul s₂ t",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s₁ s₂ t : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂)"},
 {"type": "FreeModule R G → FreeModule R G → FreeModule R G",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FreeModule R G → FreeModule R G → FreeModule R G := by let f  := fun (s : FormalSum R G) => \n    fun  (t : FreeModule R G) => mulAux  s t; sorry",
  "name": "mul",
  "kind": "def",
  "first-tactic":
  "let f  := fun (s : FormalSum R G) => \n    fun  (t : FreeModule R G) => mulAux  s t",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FreeModule R G → FreeModule R G → FreeModule R G",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G]"},
 {"type":
  "monomCoeff R X x₀ (a + b, x) = monomCoeff R X x₀ (a, x) + monomCoeff R X x₀ (b, x)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X)  (a b : R) : monomCoeff R X x₀ (a + b, x) = monomCoeff R X x₀ (a, x) + monomCoeff R X x₀ (b, x) := by repeat\n    (\n      rw [monomCoeff]); sorry",
  "name": "monom_coords_hom",
  "kind": "theorem",
  "first-tactic": "repeat\n    (\n      rw [monomCoeff])",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X)  (a b : R) : monomCoeff R X x₀ (a + b, x) = monomCoeff R X x₀ (a, x) + monomCoeff R X x₀ (b, x)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X)  (a b : R)"},
 {"type": "monomCoeff R X x₀ (a * b, x) = a * monomCoeff R X x₀ (b, x)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (a b : R) : monomCoeff R X x₀ (a * b, x) = a * monomCoeff R X x₀ (b, x) := by repeat\n    (\n      rw [monomCoeff]); sorry",
  "name": "monom_coords_mul",
  "kind": "theorem",
  "first-tactic": "repeat\n    (\n      rw [monomCoeff])",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (a b : R) : monomCoeff R X x₀ (a * b, x) = a * monomCoeff R X x₀ (b, x)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (a b : R)"},
 {"type": "monomCoeff R X x₀ (0, x) = 0",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X) : monomCoeff R X x₀ (0, x) = 0 := by rw [monomCoeff]; sorry",
  "name": "monom_coords_at_zero",
  "kind": "theorem",
  "first-tactic": "rw [monomCoeff]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X) : monomCoeff R X x₀ (0, x) = 0",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X)"},
 {"type": "f = g → equalOnSupport l f g",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (l : List X)  (f g : X → R) : f = g → equalOnSupport l f g := by intro hyp; sorry",
  "name": "equal_on_support_of_equal",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (l : List X)  (f g : X → R) : f = g → equalOnSupport l f g",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (l : List X)  (f g : X → R)"},
 {"type": "eqlCoords R X s s",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s : FormalSum R X) : eqlCoords R X s s := by rfl; sorry",
  "name": "refl",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s : FormalSum R X) : eqlCoords R X s s",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s : FormalSum R X)"},
 {"type": "eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₁",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ : FormalSum R X} : eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₁ := by intro hyp; sorry",
  "name": "symm",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ : FormalSum R X} : eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₁",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ : FormalSum R X}"},
 {"type": "eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₃ → eqlCoords R X s₁ s₃",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ s₃ : FormalSum R X} : eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₃ → eqlCoords R X s₁ s₃ := by intro hyp₁ hyp₂; sorry",
  "name": "trans",
  "kind": "theorem",
  "first-tactic": "intro hyp₁ hyp₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ s₃ : FormalSum R X} : eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₃ → eqlCoords R X s₁ s₃",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ s₃ : FormalSum R X}"},
 {"type": "beqOnSupport l f g = true → equalOnSupport l f g",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {l : List X}  {f g : X → R} : beqOnSupport l f g = true → equalOnSupport l f g := by intro hyp; sorry",
  "name": "eql_on_support_of_true",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {l : List X}  {f g : X → R} : beqOnSupport l f g = true → equalOnSupport l f g",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {l : List X}  {f g : X → R}"},
 {"type": "⟦s₁⟧ = ⟦s₂⟧",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) (c₁ : beqOnSupport s₁.support s₁.coords s₂.coords) (c₂ : beqOnSupport s₂.support s₁.coords s₂.coords) : ⟦s₁⟧ = ⟦s₂⟧ := by let ch₁ := eql_on_support_of_true c₁; sorry",
  "name": "eqlquot_of_beq_support",
  "kind": "theorem",
  "first-tactic": "let ch₁ := eql_on_support_of_true c₁",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) (c₁ : beqOnSupport s₁.support s₁.coords s₂.coords) (c₂ : beqOnSupport s₂.support s₁.coords s₂.coords) : ⟦s₁⟧ = ⟦s₂⟧",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) (c₁ : beqOnSupport s₁.support s₁.coords s₂.coords) (c₂ : beqOnSupport s₂.support s₁.coords s₂.coords)"},
 {"type": "Bool",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : Bool := by apply Quotient.lift₂ (fun (s₁ s₂ : FormalSum R X) => decide (⟦s₁⟧ = ⟦s₂⟧)); sorry",
  "name": "beq_quot",
  "kind": "def",
  "first-tactic":
  "apply Quotient.lift₂ (fun (s₁ s₂ : FormalSum R X) => decide (⟦s₁⟧ = ⟦s₂⟧))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : Bool",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X)"},
 {"type": "∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = true → x₁ = x₂",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : ∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = true → x₁ = x₂ := by let f :=\n    @Quotient.ind₂ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (x₁ x₂ : FreeModule R X) => x₁.beq_quot x₂ = true → x₁ = x₂); sorry",
  "name": "eq_of_beq_true",
  "kind": "def",
  "first-tactic":
  "let f :=\n    @Quotient.ind₂ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (x₁ x₂ : FreeModule R X) => x₁.beq_quot x₂ = true → x₁ = x₂)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : ∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = true → x₁ = x₂",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = false → Not (x₁ = x₂)",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : ∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = false → Not (x₁ = x₂) := by let f :=\n    @Quotient.ind₂ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (x₁ x₂ : FreeModule R X) => x₁.beq_quot x₂ = false → Not (x₁ = x₂)); sorry",
  "name": "neq_of_beq_false",
  "kind": "def",
  "first-tactic":
  "let f :=\n    @Quotient.ind₂ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (x₁ x₂ : FreeModule R X) => x₁.beq_quot x₂ = false → Not (x₁ = x₂))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : ∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = false → Not (x₁ = x₂)",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "Decidable (x₁ = x₂)",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : Decidable (x₁ = x₂) := by match p : x₁.beq_quot x₂ with\n  | true =>\n    apply Decidable.isTrue\n    apply FreeModule.eq_of_beq_true\n    assumption\n  | false =>\n    apply Decidable.isFalse\n    apply FreeModule.neq_of_beq_false\n    assumption; sorry",
  "name": "decEq",
  "kind": "def",
  "first-tactic":
  "match p : x₁.beq_quot x₂ with\n  | true =>\n    apply Decidable.isTrue\n    apply FreeModule.eq_of_beq_true\n    assumption\n  | false =>\n    apply Decidable.isFalse\n    apply FreeModule.neq_of_beq_false\n    assumption",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : Decidable (x₁ = x₂)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X)"},
 {"type": "s₁ ≈ s₂ → s₁.coords = s₂.coords",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) : s₁ ≈ s₂ → s₁.coords = s₂.coords := by intro hyp; sorry",
  "name": "equal_coords_of_approx",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) : s₁ ≈ s₂ → s₁.coords = s₂.coords",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)"},
 {"type": "FreeModule R X →  R",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) : FreeModule R X →  R := by apply Quotient.lift (fun s : FormalSum R X => s.coords x₀); sorry",
  "name": "coordinates",
  "kind": "def",
  "first-tactic": "apply Quotient.lift (fun s : FormalSum R X => s.coords x₀)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) : FreeModule R X →  R",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)"},
 {"type": "(r * s.coords x₀) = (s.scmul r).coords x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (r : R)  (s : FormalSum R X)  (x₀ : X) : (r * s.coords x₀) = (s.scmul r).coords x₀ := by induction s; sorry",
  "name": "scmul_coords",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (r : R)  (s : FormalSum R X)  (x₀ : X) : (r * s.coords x₀) = (s.scmul r).coords x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (r : R)  (s : FormalSum R X)  (x₀ : X)"},
 {"type": "R → FreeModule R X → FreeModule R X",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : R → FreeModule R X → FreeModule R X := by intro r; sorry",
  "name": "FreeModule.scmul",
  "kind": "def",
  "first-tactic": "intro r",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : R → FreeModule R X → FreeModule R X",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "(s₁.coords x₀) + (s₂.coords x₀) = (s₁ ++ s₂).coords x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (x₀ : X) : (s₁.coords x₀) + (s₂.coords x₀) = (s₁ ++ s₂).coords x₀ := by induction s₁; sorry",
  "name": "append_coords",
  "kind": "theorem",
  "first-tactic": "induction s₁",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (x₀ : X) : (s₁.coords x₀) + (s₂.coords x₀) = (s₁ ++ s₂).coords x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (x₀ : X)"},
 {"type": "(s₁ ≈ s₂) → (t₁ ≈ t₂) → s₁ ++ t₁ ≈ s₂ ++ t₂",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ t₁ t₂ : FormalSum R X) : (s₁ ≈ s₂) → (t₁ ≈ t₂) → s₁ ++ t₁ ≈ s₂ ++ t₂ := by intro eqv₁ eqv₂; sorry",
  "name": "append_equiv",
  "kind": "theorem",
  "first-tactic": "intro eqv₁ eqv₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ t₁ t₂ : FormalSum R X) : (s₁ ≈ s₂) → (t₁ ≈ t₂) → s₁ ++ t₁ ≈ s₂ ++ t₂",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ t₁ t₂ : FormalSum R X)"},
 {"type": "FreeModule R X → FreeModule R X → FreeModule R X",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : FreeModule R X → FreeModule R X → FreeModule R X := by let f : FormalSum R X → FormalSum R X → FreeModule R X := fun s₁ s₂ => ⟦s₁ ++ s₂⟧; sorry",
  "name": "FreeModule.add",
  "kind": "def",
  "first-tactic":
  "let f : FormalSum R X → FormalSum R X → FreeModule R X := fun s₁ s₂ => ⟦s₁ ++ s₂⟧",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : FreeModule R X → FreeModule R X → FreeModule R X",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "(s.scmul b).scmul a = s.scmul (a * b)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul b).scmul a = s.scmul (a * b) := by induction s; sorry",
  "name": "action",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul b).scmul a = s.scmul (a * b)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X)"},
 {"type": "(s.scmul a) ++ (s.scmul b) ≈  s.scmul (a + b)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul a) ++ (s.scmul b) ≈  s.scmul (a + b) := by induction s; sorry",
  "name": "act_sum",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul a) ++ (s.scmul b) ≈  s.scmul (a + b)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X)"},
 {"type": "a • (b • x) = (a * b) • x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (x : FreeModule R X) : a • (b • x) = (a * b) • x := by apply @Quotient.ind (motive := fun x : FreeModule R X => a • (b • x) = (a * b) • x); sorry",
  "name": "module_action",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => a • (b • x) = (a * b) • x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (x : FreeModule R X) : a • (b • x) = (a * b) • x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (x : FreeModule R X)"},
 {"type": "x₁ + x₂ = x₂ + x₁",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : x₁ + x₂ = x₂ + x₁ := by apply @Quotient.ind₂ (motive := fun x₁ x₂ : FreeModule R X => x₁ + x₂ = x₂ + x₁); sorry",
  "name": "addn_comm",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind₂ (motive := fun x₁ x₂ : FreeModule R X => x₁ + x₂ = x₂ + x₁)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : x₁ + x₂ = x₂ + x₁",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X)"},
 {"type": "(⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ : FormalSum R X)  (x₂ x₃ : FreeModule R X) : (⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃) := by apply @Quotient.ind₂ (motive := fun x₂ x₃ : FreeModule R X => (⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃)); sorry",
  "name": "add_assoc_aux",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind₂ (motive := fun x₂ x₃ : FreeModule R X => (⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ : FormalSum R X)  (x₂ x₃ : FreeModule R X) : (⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ : FormalSum R X)  (x₂ x₃ : FreeModule R X)"},
 {"type": "(x₁ + x₂) + x₃ = x₁ + (x₂ + x₃)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ x₃ : FreeModule R X) : (x₁ + x₂) + x₃ = x₁ + (x₂ + x₃) := by apply @Quotient.ind (motive := fun x₁ : FreeModule R X => (x₁ + x₂) + x₃ = x₁ + (x₂ + x₃)); sorry",
  "name": "addn_assoc",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x₁ : FreeModule R X => (x₁ + x₂) + x₃ = x₁ + (x₂ + x₃))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ x₃ : FreeModule R X) : (x₁ + x₂) + x₃ = x₁ + (x₂ + x₃)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ x₃ : FreeModule R X)"},
 {"type": "x + zero = x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : x + zero = x := by apply @Quotient.ind (motive := fun x : FreeModule R X => x + zero = x); sorry",
  "name": "addn_zero",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => x + zero = x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : x + zero = x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "zero + x = x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : zero + x = x := by apply @Quotient.ind (motive := fun x : FreeModule R X => zero + x = x); sorry",
  "name": "zero_addn",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => zero + x = x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : zero + x = x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "a • (x₁ + x₂) = a • x₁ + a • x₂",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a : R)  (x₁ x₂ : FreeModule R X) : a • (x₁ + x₂) = a • x₁ + a • x₂ := by apply @Quotient.ind₂ (motive := fun x₁ x₂ : FreeModule R X => a • (x₁ + x₂) = a • x₁ + a • x₂); sorry",
  "name": "elem_distrib",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind₂ (motive := fun x₁ x₂ : FreeModule R X => a • (x₁ + x₂) = a • x₁ + a • x₂)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a : R)  (x₁ x₂ : FreeModule R X) : a • (x₁ + x₂) = a • x₁ + a • x₂",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a : R)  (x₁ x₂ : FreeModule R X)"},
 {"type": "a • x + b • x = (a + b) • x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b: R) (x: FreeModule R X) : a • x + b • x = (a + b) • x := by apply @Quotient.ind (motive := fun x : FreeModule R X => \n    a • x + b • x = (a + b) • x); sorry",
  "name": "coeffs_distrib",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => \n    a • x + b • x = (a + b) • x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b: R) (x: FreeModule R X) : a • x + b • x = (a + b) • x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b: R) (x: FreeModule R X)"},
 {"type": "(1 : R) • x =  x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (1 : R) • x =  x := by apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (1 : R) • x =  x); sorry",
  "name": "unit_coeffs",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (1 : R) • x =  x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (1 : R) • x =  x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "(0 : R) • x =  ⟦ [] ⟧",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (0 : R) • x =  ⟦ [] ⟧ := by apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (0 : R) • x =  ⟦ [] ⟧); sorry",
  "name": "zero_coeffs",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (0 : R) • x =  ⟦ [] ⟧)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (0 : R) • x =  ⟦ [] ⟧",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "coords s₁ x₀ = coords s₂ x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (s₁ s₂ : FormalSum R X)  (h : ElementaryMove R X s₁ s₂) : coords s₁ x₀ = coords s₂ x₀ := by induction h; sorry",
  "name": "coords_move_invariant",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (s₁ s₂ : FormalSum R X)  (h : ElementaryMove R X s₁ s₂) : coords s₁ x₀ = coords s₂ x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (s₁ s₂ : FormalSum R X)  (h : ElementaryMove R X s₁ s₂)"},
 {"type": "FreeModuleAux.coeff  x (sum s) = s.coords x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s : FormalSum R X) : FreeModuleAux.coeff  x (sum s) = s.coords x := by simp [FreeModuleAux.coeff]; sorry",
  "name": "coeff_factors",
  "kind": "theorem",
  "first-tactic": "simp [FreeModuleAux.coeff]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s : FormalSum R X) : FreeModuleAux.coeff  x (sum s) = s.coords x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s : FormalSum R X)"},
 {"type": "s₁ ≃ s₂ → s₁.coords x = s₂.coords x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s₁ s₂ : FormalSum R X) : s₁ ≃ s₂ → s₁.coords x = s₂.coords x := by intro hyp; sorry",
  "name": "coords_well_defined",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s₁ s₂ : FormalSum R X) : s₁ ≃ s₂ → s₁.coords x = s₂.coords x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s₁ s₂ : FormalSum R X)"},
 {"type": "s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (a : R)  (x : X) : s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂ := by intro h; sorry",
  "name": "cons_equiv_of_equiv",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (a : R)  (x : X) : s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (a : R)  (x : X)"},
 {"type":
  "0 ≠ s.coords x₀ → (∃ ys : FormalSum R X, (((s.coords x₀, x₀) :: ys) ≃ s) ∧ (List.length ys < s.length))",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) (s : FormalSum R X) : 0 ≠ s.coords x₀ → (∃ ys : FormalSum R X, (((s.coords x₀, x₀) :: ys) ≃ s) ∧ (List.length ys < s.length)) := by induction s; sorry",
  "name": "nonzero_coeff_has_complement",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) (s : FormalSum R X) : 0 ≠ s.coords x₀ → (∃ ys : FormalSum R X, (((s.coords x₀, x₀) :: ys) ≃ s) ∧ (List.length ys < s.length))",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) (s : FormalSum R X)"},
 {"type":
  "(∀ s₁ s₂ : FormalSum R X, ∀ mv : ElementaryMove R X s₁ s₂, f s₁ = f s₂) → (∀ s₁ s₂ : FormalSum R X, s₁ ≈ s₂ → f s₁ = f s₂)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {β : Sort u}  (f : FormalSum R X → β) : (∀ s₁ s₂ : FormalSum R X, ∀ mv : ElementaryMove R X s₁ s₂, f s₁ = f s₂) → (∀ s₁ s₂ : FormalSum R X, s₁ ≈ s₂ → f s₁ = f s₂) := by intro hyp; sorry",
  "name": "func_eql_of_move_equiv",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {β : Sort u}  (f : FormalSum R X → β) : (∀ s₁ s₂ : FormalSum R X, ∀ mv : ElementaryMove R X s₁ s₂, f s₁ = f s₂) → (∀ s₁ s₂ : FormalSum R X, s₁ ≈ s₂ → f s₁ = f s₂)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {β : Sort u}  (f : FormalSum R X → β)"},
 {"type": "a ≤ max a b",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : a ≤ max a b := by simp [max]; sorry",
  "name": "fst_le_max",
  "kind": "theorem",
  "first-tactic": "simp [max]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : a ≤ max a b",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat)"},
 {"type": "b ≤ max a b",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : b ≤ max a b := by simp [max]; sorry",
  "name": "snd_le_max",
  "kind": "theorem",
  "first-tactic": "simp [max]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : b ≤ max a b",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat)"},
 {"type": "(max a b = a) ∨ (max a b = b)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : (max a b = a) ∨ (max a b = b) := by simp [max]; sorry",
  "name": "eq_fst_or_snd_of_max",
  "kind": "theorem",
  "first-tactic": "simp [max]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : (max a b = a) ∨ (max a b = b)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat)"},
 {"type":
  "maxNormSuccOnSupp norm crds s > 0 → \n  ∃ x : X, crds x ≠ 0 ∧ maxNormSuccOnSupp norm crds s = norm x + 1",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X) : maxNormSuccOnSupp norm crds s > 0 → \n  ∃ x : X, crds x ≠ 0 ∧ maxNormSuccOnSupp norm crds s = norm x + 1 := by intro h; sorry",
  "name": "max_in_support",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X) : maxNormSuccOnSupp norm crds s > 0 → \n  ∃ x : X, crds x ≠ 0 ∧ maxNormSuccOnSupp norm crds s = norm x + 1",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X)"},
 {"type":
  "(x: X) → x ∈ s →  crds x ≠ 0 → norm x + 1 ≤ maxNormSuccOnSupp norm crds s",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X) : (x: X) → x ∈ s →  crds x ≠ 0 → norm x + 1 ≤ maxNormSuccOnSupp norm crds s := by intro x h₁ h₂; sorry",
  "name": "supp_below_max",
  "kind": "theorem",
  "first-tactic": "intro x h₁ h₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X) : (x: X) → x ∈ s →  crds x ≠ 0 → norm x + 1 ≤ maxNormSuccOnSupp norm crds s",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X)"},
 {"type": "s₁.normSucc norm = s₂.normSucc norm",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm : X → Nat) (s₁ s₂: FormalSum R X) (eql : s₁ ≈ s₂) : s₁.normSucc norm = s₂.normSucc norm := by apply Nat.le_antisymm; sorry",
  "name": "norm_succ_eq",
  "kind": "theorem",
  "first-tactic": "apply Nat.le_antisymm",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm : X → Nat) (s₁ s₂: FormalSum R X) (eql : s₁ ≈ s₂) : s₁.normSucc norm = s₂.normSucc norm",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm : X → Nat) (s₁ s₂: FormalSum R X) (eql : s₁ ≈ s₂)"},
 {"type": "Nat",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) [nx : NormCube X] : Nat := by let f : FormalSum R X → Nat := fun s => s.normSucc (nx.norm); sorry",
  "name": "FreeModule.normBound",
  "kind": "def",
  "first-tactic":
  "let f : FormalSum R X → Nat := fun s => s.normSucc (nx.norm)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) [nx : NormCube X] : Nat",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) [nx : NormCube X]"},
 {"type": "(EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z) := by intro p q; sorry",
  "name": "multiply",
  "kind": "def",
  "first-tactic": "intro p q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}"},
 {"type": "G.init e = x → (term G (G.bar e) = x)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x) := by intro h; sorry",
  "name": "term_bar_equals_init",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} {e : E}"},
 {"type": "(term G e = x) → G.init (G.bar e) = x",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x :V}  {e : E} : (term G e = x) → G.init (G.bar e) = x := by intro hyp; sorry",
  "name": "init_bar_equals_term",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x :V}  {e : E} : (term G e = x) → G.init (G.bar e) = x",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x :V}  {e : E}"},
 {"type": "(multiply (multiply p q) r) = (multiply p (multiply q r))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r)) := by induction p; sorry",
  "name": "mult_assoc",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z)"},
 {"type": "(multiply p (single y)) = p",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p := by induction p; sorry",
  "name": "mult_const",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {p : EdgePath G x y}"},
 {"type": "{ rp : EdgePath G x z // rp.length ≤ (cons ex h₁ h₂ exy).length}",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : { rp : EdgePath G x z // rp.length ≤ (cons ex h₁ h₂ exy).length} := by cases exy; sorry",
  "name": "reducePathAux",
  "kind": "def",
  "first-tactic": "cases exy",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : { rp : EdgePath G x z // rp.length ≤ (cons ex h₁ h₂ exy).length}",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z)"},
 {"type": "homotopy p q → homotopy q r → homotopy p r",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y) : homotopy p q → homotopy q r → homotopy p r := by intro h₁ h₂; sorry",
  "name": "homotopy_trans",
  "kind": "theorem",
  "first-tactic": "intro h₁ h₂",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y) : homotopy p q → homotopy q r → homotopy p r",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y)"},
 {"type":
  "(p q : EdgePath G y z) → homotopy p q → (ex : E) →(h1 : G.init ex = x) → ( h : term G ex = y)→ homotopy (cons ex h1 h p) (cons ex h1 h q)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (p q : EdgePath G y z) → homotopy p q → (ex : E) →(h1 : G.init ex = x) → ( h : term G ex = y)→ homotopy (cons ex h1 h p) (cons ex h1 h q) := by intro p q h ex h1 h2; sorry",
  "name": "homotopy_left_mult_edge",
  "kind": "theorem",
  "first-tactic": "intro p q h ex h1 h2",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (p q : EdgePath G y z) → homotopy p q → (ex : E) →(h1 : G.init ex = x) → ( h : term G ex = y)→ homotopy (cons ex h1 h p) (cons ex h1 h q)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}"},
 {"type": "(homotopy (multiply q p1) (multiply q p2))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2)) := by induction q; sorry",
  "name": "homotopy_left_mult",
  "kind": "theorem",
  "first-tactic": "induction q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2)"},
 {"type": "ht G y z →  ht G x z",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y) : ht G y z →  ht G x z := by let func: EdgePath G y z → ht G x z := by intro p ; exact htclass (multiply p₁ p); sorry",
  "name": "homotopy_left_multiplication",
  "kind": "def",
  "first-tactic":
  "let func: EdgePath G y z → ht G x z := by intro p ; exact htclass (multiply p₁ p)",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y) : ht G y z →  ht G x z",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)"},
 {"type":
  "homotopy_left_multiplication p₁ (htclass p₂) = htclass (multiply p₁ p₂)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)  (p₂ : EdgePath G y z) : homotopy_left_multiplication p₁ (htclass p₂) = htclass (multiply p₁ p₂) := by simp[htclass, homotopy_left_multiplication]; sorry",
  "name": "homotopy_left_multiplication_class",
  "kind": "theorem",
  "first-tactic": "simp[htclass, homotopy_left_multiplication]",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)  (p₂ : EdgePath G y z) : homotopy_left_multiplication p₁ (htclass p₂) = htclass (multiply p₁ p₂)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)  (p₂ : EdgePath G y z)"},
 {"type": "homotopy (cons ex h₁ h₂ exy) (reducePathAux ex h₁ h₂ exy)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : homotopy (cons ex h₁ h₂ exy) (reducePathAux ex h₁ h₂ exy) := by simp[homotopy, htclass]; sorry",
  "name": "homotopy_reducePathAux",
  "kind": "theorem",
  "first-tactic": "simp[homotopy, htclass]",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : homotopy (cons ex h₁ h₂ exy) (reducePathAux ex h₁ h₂ exy)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z)"},
 {"type": "homotopy p₁ (reducePath p₁)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ : EdgePath G x y) : homotopy p₁ (reducePath p₁) := by induction p₁; sorry",
  "name": "homotopy_reducePath",
  "kind": "theorem",
  "first-tactic": "induction p₁",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ : EdgePath G x y) : homotopy p₁ (reducePath p₁)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ : EdgePath G x y)"},
 {"type": "(succ n) * (succ m) =\n          succ ((succ n) * m + n)",
  "tactic-prompt":
  "theorem (n m: Nat) : (succ n) * (succ m) =\n          succ ((succ n) * m + n) := by rfl; sorry",
  "name": "mul_succ_succ",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (succ n) * (succ m) =\n          succ ((succ n) * m + n)",
  "args": "(n m: Nat)"},
 {"type": "n * m = 0 → n = 0 ∨ m = 0",
  "tactic-prompt":
  "theorem (n m: Nat) : n * m = 0 → n = 0 ∨ m = 0 := by cases n; sorry",
  "name": "nat_domain",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n m: Nat) : n * m = 0 → n = 0 ∨ m = 0",
  "args": "(n m: Nat)"},
 {"type":
  "(Int.ofNat (succ n)) * (Int.ofNat (succ m)) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "tactic-prompt":
  "theorem (n m: Nat) : (Int.ofNat (succ n)) * (Int.ofNat (succ m)) =\n         Int.ofNat (succ ((succ n) * m + n)) := by rfl; sorry",
  "name": "int_mul_succ_succ",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (Int.ofNat (succ n)) * (Int.ofNat (succ m)) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "args": "(n m: Nat)"},
 {"type":
  "(Int.ofNat (succ n)) * (Int.negSucc m) =\n         Int.negSucc ((succ n) * m + n)",
  "tactic-prompt":
  "theorem (n m: Nat) : (Int.ofNat (succ n)) * (Int.negSucc m) =\n         Int.negSucc ((succ n) * m + n) := by rfl; sorry",
  "name": "int_mul_succ_negsucc",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (Int.ofNat (succ n)) * (Int.negSucc m) =\n         Int.negSucc ((succ n) * m + n)",
  "args": "(n m: Nat)"},
 {"type":
  "(Int.negSucc n) * (Int.negSucc m) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "tactic-prompt":
  "theorem (n m: Nat) : (Int.negSucc n) * (Int.negSucc m) =\n         Int.ofNat (succ ((succ n) * m + n)) := by rfl; sorry",
  "name": "int_mul_negsucc_negsucc",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (Int.negSucc n) * (Int.negSucc m) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "args": "(n m: Nat)"},
 {"type": "n' * m' = 0 → n' = 0 ∨ m' = 0",
  "tactic-prompt":
  "theorem (n' m': Int) : n' * m' = 0 → n' = 0 ∨ m' = 0 := by cases n'; sorry",
  "name": "int_domain",
  "kind": "theorem",
  "first-tactic": "cases n'",
  "core-prompt": "(n' m': Int) : n' * m' = 0 → n' = 0 ∨ m' = 0",
  "args": "(n' m': Int)"},
 {"type": "a * b = a * c → b = c",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : a * b = a * c → b = c := by intro h; sorry",
  "name": "Group.mul_left_cancel",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : a * b = a * c → b = c",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "b * a = c * a → b = c",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : b * a = c * a → b = c := by intro h; sorry",
  "name": "Group.mul_right_cancel",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : b * a = c * a → b = c",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "(1 : G)⁻¹ = 1",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} {G : Type _}  [Group G] : (1 : G)⁻¹ = 1 := by have : (1 : G)⁻¹ * 1 = 1 := mul_left_inv 1; sorry",
  "name": "one_inv",
  "kind": "theorem",
  "first-tactic": "have : (1 : G)⁻¹ * 1 = 1 := mul_left_inv 1",
  "core-prompt":
  "{G : Type u}  [Group G]  {a b c : G} {G : Type _}  [Group G] : (1 : G)⁻¹ = 1",
  "args": "{G : Type u}  [Group G]  {a b c : G} {G : Type _}  [Group G]"},
 {"type": "a * b = a ↔ b = 1",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : a * b = a ↔ b = 1 := by apply Iff.intro; sorry",
  "name": "mul_left_eq_cancel",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : a * b = a ↔ b = 1",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "b * a = a ↔ b = 1",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : b * a = a ↔ b = 1 := by apply Iff.intro; sorry",
  "name": "mul_right_eq_cancel",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : b * a = a ↔ b = 1",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "a + b = a ↔ b = 0",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {a b c : A} : a + b = a ↔ b = 0 := by apply Iff.intro; sorry",
  "name": "add_left_eq_cancel",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c : A} : a + b = a ↔ b = 0",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c : A}"},
 {"type": "b + a = a ↔ b = 0",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {a b c : A} : b + a = a ↔ b = 0 := by rw [add_comm]; sorry",
  "name": "add_right_eq_cancel",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c : A} : b + a = a ↔ b = 0",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c : A}"},
 {"type": "(-0 : A) = (0 : A)",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {a b c : A} : (-0 : A) = (0 : A) := by have : (-0 : A) + (0 : A) = (0 : A) := neg_add_self (0 : A); sorry",
  "name": "neg_zero",
  "kind": "theorem",
  "first-tactic": "have : (-0 : A) + (0 : A) = (0 : A) := neg_add_self (0 : A)",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c : A} : (-0 : A) = (0 : A)",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c : A}"},
 {"type": "ϕ 1 = 1",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] : ϕ 1 = 1 := by have : (ϕ 1) * (ϕ 1) = (ϕ 1) * 1 := by rw [← Homomorphism.mul_distrib, mul_one, mul_one]; sorry",
  "name": "one_image",
  "kind": "theorem",
  "first-tactic":
  "have : (ϕ 1) * (ϕ 1) = (ϕ 1) * 1 := by rw [← Homomorphism.mul_distrib, mul_one, mul_one]",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] : ϕ 1 = 1",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]"},
 {"type": "(ϕ g)⁻¹ = ϕ g⁻¹",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G} : (ϕ g)⁻¹ = ϕ g⁻¹ := by have : ϕ g * ϕ g⁻¹ = ϕ g * (ϕ g)⁻¹ := by rw [← Homomorphism.mul_distrib]; simp; sorry",
  "name": "hom_inv",
  "kind": "theorem",
  "first-tactic":
  "have : ϕ g * ϕ g⁻¹ = ϕ g * (ϕ g)⁻¹ := by rw [← Homomorphism.mul_distrib]; simp",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G} : (ϕ g)⁻¹ = ϕ g⁻¹",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G}"},
 {"type": "(ϕ g) ^ n = ϕ (g ^ n)",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G}  {n : ℕ} : (ϕ g) ^ n = ϕ (g ^ n) := by induction n; sorry",
  "name": "hom_pow",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G}  {n : ℕ} : (ϕ g) ^ n = ϕ (g ^ n)",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G}  {n : ℕ}"},
 {"type": "SubNegMonoid.gsmul (↑(n) + 1) a = a + SubNegMonoid.gsmul (↑ n) a",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) (n : ℕ) : SubNegMonoid.gsmul (↑(n) + 1) a = a + SubNegMonoid.gsmul (↑ n) a := by rw [← Int.cast_ofNat, Int.cast_id, ← Int.ofNat_succ]; sorry",
  "name": "SubNegMonoid.gsmul_succ'_",
  "kind": "theorem",
  "first-tactic": "rw [← Int.cast_ofNat, Int.cast_id, ← Int.ofNat_succ]",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) (n : ℕ) : SubNegMonoid.gsmul (↑(n) + 1) a = a + SubNegMonoid.gsmul (↑ n) a",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) (n : ℕ)"},
 {"type": "SubNegMonoid.gsmul 1 a = a",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) : SubNegMonoid.gsmul 1 a = a := by rw [← Int.ofNat_one, gsmul_succ', Int.ofNat_zero, gsmul_zero', add_zero]; sorry",
  "name": "SubNegMonoid.gsmul_one",
  "kind": "theorem",
  "first-tactic":
  "rw [← Int.ofNat_one, gsmul_succ', Int.ofNat_zero, gsmul_zero', add_zero]",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) : SubNegMonoid.gsmul 1 a = a",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A)"},
 {"type": "ϕ (0 : A) = (0 : B)",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ϕ (0 : A) = (0 : B) := by have : ϕ 0 + ϕ 0 = ϕ 0 + 0 := by rw [← add_dist]; simp; sorry",
  "name": "zero_image",
  "kind": "theorem",
  "first-tactic": "have : ϕ 0 + ϕ 0 = ϕ 0 + 0 := by rw [← add_dist]; simp",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ϕ (0 : A) = (0 : B)",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "∀ a : A, ϕ (-a) = -ϕ a",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a : A, ϕ (-a) = -ϕ a := by intro a; sorry",
  "name": "neg_push",
  "kind": "theorem",
  "first-tactic": "intro a",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a : A, ϕ (-a) = -ϕ a",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "∀ a a' : A, ϕ (a - a') = ϕ a - ϕ a'",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a a' : A, ϕ (a - a') = ϕ a - ϕ a' := by intros; sorry",
  "name": "neg_dist",
  "kind": "theorem",
  "first-tactic": "intros",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a a' : A, ϕ (a - a') = ϕ a - ϕ a'",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "∀ a : A, ∀ n : ℕ, n • (ϕ a) = ϕ (n • a)",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a : A, ∀ n : ℕ, n • (ϕ a) = ϕ (n • a) := by intro a n; sorry",
  "name": "hom_mul",
  "kind": "theorem",
  "first-tactic": "intro a n",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a : A, ∀ n : ℕ, n • (ϕ a) = ϕ (n • a)",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type":
  "∀ n : ℕ, ∀ a b : A, nsmul_rec n (a + b) = nsmul_rec n a + nsmul_rec n b",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ n : ℕ, ∀ a b : A, nsmul_rec n (a + b) = nsmul_rec n a + nsmul_rec n b := by intros n a b; sorry",
  "name": "nsmul_hom",
  "kind": "theorem",
  "first-tactic": "intros n a b",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ n : ℕ, ∀ a b : A, nsmul_rec n (a + b) = nsmul_rec n a + nsmul_rec n b",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type":
  "∀ n : ℤ, ∀ a b : A, gsmul_rec n (a + b) = gsmul_rec n a + gsmul_rec n b",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ n : ℤ, ∀ a b : A, gsmul_rec n (a + b) = gsmul_rec n a + gsmul_rec n b := by intros n a b; sorry",
  "name": "gsmul_hom",
  "kind": "theorem",
  "first-tactic": "intros n a b",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ n : ℤ, ∀ a b : A, gsmul_rec n (a + b) = gsmul_rec n a + gsmul_rec n b",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "∀ a a' : A, -(a + a') = -a + -a'",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a a' : A, -(a + a') = -a + -a' := by intro a a'; sorry",
  "name": "neg_hom",
  "kind": "theorem",
  "first-tactic": "intro a a'",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a a' : A, -(a + a') = -a + -a'",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "AddCommGroup.Isomorphism A A",
  "tactic-prompt":
  "instance {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  (A B C : Type _)  [AddCommGroup A]  [AddCommGroup B]  [AddCommGroup C] [AddCommGroup.Isomorphism A A] : AddCommGroup.Isomorphism A A := by assumption; sorry",
  "name": "refl",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  (A B C : Type _)  [AddCommGroup A]  [AddCommGroup B]  [AddCommGroup C] [AddCommGroup.Isomorphism A A] : AddCommGroup.Isomorphism A A",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  (A B C : Type _)  [AddCommGroup A]  [AddCommGroup B]  [AddCommGroup C] [AddCommGroup.Isomorphism A A]"},
 {"type": "x + x + y - x - y + z - x = z",
  "tactic-prompt":
  "example {x y z : ℤ} : x + x + y - x - y + z - x = z := by have p := freeGroupEq# (x + x + y - x - y + z - x); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq# (x + x + y - x - y + z - x)",
  "core-prompt": "{x y z : ℤ} : x + x + y - x - y + z - x = z",
  "args": "{x y z : ℤ}"},
 {"type": "(a + b) - (b - a) - a = a",
  "tactic-prompt":
  "example {A : Type _}  [AddCommGroup A]  {a b : A} : (a + b) - (b - a) - a = a := by have p := freeGroupEq# ((a + b) - (b - a) - a); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq# ((a + b) - (b - a) - a)",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b : A} : (a + b) - (b - a) - a = a",
  "args": "{A : Type _}  [AddCommGroup A]  {a b : A}"},
 {"type": "a + b - a - b = b - b + a - a",
  "tactic-prompt":
  "example {a b : ℤ} : a + b - a - b = b - b + a - a := by have pₗ := freeGroupEq# (a + b - a - b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have pₗ := freeGroupEq# (a + b - a - b)",
  "core-prompt": "{a b : ℤ} : a + b - a - b = b - b + a - a",
  "args": "{a b : ℤ}"},
 {"type": "a + b - c - d + e - a + b + c - a - e + a - b + d - b = 0",
  "tactic-prompt":
  "example {A : Type _}  [AddCommGroup A]  {a b c d e : A} : a + b - c - d + e - a + b + c - a - e + a - b + d - b = 0 := by have p := freeGroupEq# (a + b - c - d + e - a + b + c - a - e + a - b + d - b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "have p := freeGroupEq# (a + b - c - d + e - a + b + c - a - e + a - b + d - b)",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c d e : A} : a + b - c - d + e - a + b + c - a - e + a - b + d - b = 0",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c d e : A}"},
 {"type": "arr.getIdx? a = some i → arr.size > 0",
  "tactic-prompt":
  "lemma {α : Type _}  [DecidableEq α]  {arr : Array α}  {a : α}  {i : ℕ} : arr.getIdx? a = some i → arr.size > 0 := by rw [getIdx?, findIdx?, findIdx?.loop]; sorry",
  "name": "Array.size_pos_if_index",
  "kind": "lemma",
  "first-tactic": "rw [getIdx?, findIdx?, findIdx?.loop]",
  "core-prompt":
  "{α : Type _}  [DecidableEq α]  {arr : Array α}  {a : α}  {i : ℕ} : arr.getIdx? a = some i → arr.size > 0",
  "args": "{α : Type _}  [DecidableEq α]  {arr : Array α}  {a : α}  {i : ℕ}"},
 {"type": "(arr.push a).size > 0",
  "tactic-prompt":
  "lemma {α : Type _}  (arr : Array α)  (a : α) : (arr.push a).size > 0 := by match arr with\n    | ⟨l⟩ =>\n      simp only [push, size]\n      induction l with\n        | nil => simp only [List.concat, List.length]\n        | cons _ _ _ => simp only [List.concat, List.length, Nat.add_one]; apply Nat.succ_pos; sorry",
  "name": "Array.push_size_pos",
  "kind": "lemma",
  "first-tactic":
  "match arr with\n    | ⟨l⟩ =>\n      simp only [push, size]\n      induction l with\n        | nil => simp only [List.concat, List.length]\n        | cons _ _ _ => simp only [List.concat, List.length, Nat.add_one]; apply Nat.succ_pos",
  "core-prompt":
  "{α : Type _}  (arr : Array α)  (a : α) : (arr.push a).size > 0",
  "args": "{α : Type _}  (arr : Array α)  (a : α)"},
 {"type": "(arr : Array α) → (t.indexTree arr).2.size > 0",
  "tactic-prompt":
  "theorem {α : Type _} [Repr α] [DecidableEq α]  (t: AddTree α) : (arr : Array α) → (t.indexTree arr).2.size > 0 := by induction t; sorry",
  "name": "pos_size",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "{α : Type _} [Repr α] [DecidableEq α]  (t: AddTree α) : (arr : Array α) → (t.indexTree arr).2.size > 0",
  "args": "{α : Type _} [Repr α] [DecidableEq α]  (t: AddTree α)"},
 {"type": "egIndMap x y = x + y + x - y",
  "tactic-prompt":
  "theorem {α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α]     (x y: α) : egIndMap x y = x + y + x - y := by simp; sorry",
  "name": "egIndMapInv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α]     (x y: α) : egIndMap x y = x + y + x - y",
  "args":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α]     (x y: α)"},
 {"type": "egIndMap'' x y = x + y + x - y",
  "tactic-prompt":
  "theorem {α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]     (x y: α) : egIndMap'' x y = x + y + x - y := by simp; sorry",
  "name": "egIndMapInv''",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]     (x y: α) : egIndMap'' x y = x + y + x - y",
  "args":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]     (x y: α)"},
 {"type": "x + y + x - y =  roundtrip# (x + y + x - y)",
  "tactic-prompt":
  "theorem {α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]       (x y : α) : x + y + x - y =  roundtrip# (x + y + x - y) := by rfl; sorry",
  "name": "egRoundtrip",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]       (x y : α) : x + y + x - y =  roundtrip# (x + y + x - y)",
  "args":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]       (x y : α)"},
 {"type": "x⁻¹ * (x * y) = y",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x⁻¹ * (x * y) = y := by rw [← mul_assoc]; sorry",
  "name": "left_inv_cancel",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x⁻¹ * (x * y) = y",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "(1 : G)⁻¹ = (1 : G)",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (1 : G)⁻¹ = (1 : G) := by have := left_inv_cancel (1 : G) (1 : G); sorry",
  "name": "one_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (1 : G) (1 : G)",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (1 : G)⁻¹ = (1 : G)",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "(x⁻¹)⁻¹ = x",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x⁻¹)⁻¹ = x := by have := left_inv_cancel (x⁻¹) x; sorry",
  "name": "inv_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (x⁻¹) x",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x⁻¹)⁻¹ = x",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "x * x⁻¹ = 1",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * x⁻¹ = 1 := by have := left_inv_cancel (x⁻¹) (1 : G); sorry",
  "name": "mul_right_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (x⁻¹) (1 : G)",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * x⁻¹ = 1",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "x * (x⁻¹ * y) = y",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * (x⁻¹ * y) = y := by have := left_inv_cancel (x⁻¹) y; sorry",
  "name": "left_cancel_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (x⁻¹) y",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * (x⁻¹ * y) = y",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "(x * y)⁻¹ = y⁻¹ * x⁻¹",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x * y)⁻¹ = y⁻¹ * x⁻¹ := by have := left_cancel_inv (x * y)⁻¹ (y⁻¹ * x⁻¹); sorry",
  "name": "prod_inv",
  "kind": "theorem",
  "first-tactic": "have := left_cancel_inv (x * y)⁻¹ (y⁻¹ * x⁻¹)",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x * y)⁻¹ = y⁻¹ * x⁻¹",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "((a⁻¹ * a) * (b * b⁻¹))⁻¹ = (1 : G)",
  "tactic-prompt":
  "example {G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : ((a⁻¹ * a) * (b * b⁻¹))⁻¹ = (1 : G) := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : ((a⁻¹ * a) * (b * b⁻¹))⁻¹ = (1 : G)",
  "args":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G)"},
 {"type": "b * ((a * b)⁻¹ * a) = 1",
  "tactic-prompt":
  "example {G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : b * ((a * b)⁻¹ * a) = 1 := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : b * ((a * b)⁻¹ * a) = 1",
  "args":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G)"},
 {"type": "a * (c⁻¹ * b) * (((b⁻¹ * c) * b) * (a * b)⁻¹) = (1 : G)",
  "tactic-prompt":
  "example {G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : a * (c⁻¹ * b) * (((b⁻¹ * c) * b) * (a * b)⁻¹) = (1 : G) := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : a * (c⁻¹ * b) * (((b⁻¹ * c) * b) * (a * b)⁻¹) = (1 : G)",
  "args":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G)"},
 {"type":
  "(∀ (A : Type) [AddCommGroup A], ∀ x y z : A, (ν A x y z)) ↔ (ν (ℤ × ℤ × ℤ) (1, 0, 0) (0, 1, 0) (0, 0, 1))",
  "tactic-prompt":
  "theorem  : (∀ (A : Type) [AddCommGroup A], ∀ x y z : A, (ν A x y z)) ↔ (ν (ℤ × ℤ × ℤ) (1, 0, 0) (0, 1, 0) (0, 0, 1)) := by apply Iff.intro; sorry",
  "name": "eqn_iff_free_basis",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  " : (∀ (A : Type) [AddCommGroup A], ∀ x y z : A, (ν A x y z)) ↔ (ν (ℤ × ℤ × ℤ) (1, 0, 0) (0, 1, 0) (0, 0, 1))",
  "args": ""},
 {"type": "∀ l' : List α, List.toArrayAux l {data := l'} = {data := l' ++ l}",
  "tactic-prompt":
  "lemma {α : Type _}  (l : List α) : ∀ l' : List α, List.toArrayAux l {data := l'} = {data := l' ++ l} := by induction l; sorry",
  "name": "List.aux_append",
  "kind": "lemma",
  "first-tactic": "induction l",
  "core-prompt":
  "{α : Type _}  (l : List α) : ∀ l' : List α, List.toArrayAux l {data := l'} = {data := l' ++ l}",
  "args": "{α : Type _}  (l : List α)"},
 {"type": "l.toArray.data = l",
  "tactic-prompt":
  "theorem {A : Type _}  (l : List A) : l.toArray.data = l := by rw [toArray, Array.mkEmpty, List.aux_append]; sorry",
  "name": "List.arraydata",
  "kind": "theorem",
  "first-tactic": "rw [toArray, Array.mkEmpty, List.aux_append]",
  "core-prompt": "{A : Type _}  (l : List A) : l.toArray.data = l",
  "args": "{A : Type _}  (l : List A)"},
 {"type": "l.toArray.size = l.length",
  "tactic-prompt":
  "theorem {α : Type _}  (l : List α) : l.toArray.size = l.length := by rw [Array.size, arraydata]; sorry",
  "name": "List.arraysize",
  "kind": "theorem",
  "first-tactic": "rw [Array.size, arraydata]",
  "core-prompt": "{α : Type _}  (l : List α) : l.toArray.size = l.length",
  "args": "{α : Type _}  (l : List α)"},
 {"type": "List.length (h :: tl) = Nat.succ m → List.length tl = m",
  "tactic-prompt":
  "theorem  : List.length (h :: tl) = Nat.succ m → List.length tl = m := by intro hyp; sorry",
  "name": "List.cons_len_eq_succ",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt": " : List.length (h :: tl) = Nat.succ m → List.length tl = m",
  "args": ""},
 {"type":
  "IndexAddTree.foldMap t l.toArray (by simp [h, hpos]) =\n                         (inducedFreeMap l h) (IndexAddTree.foldMap t (ℤbasis n).toArray (by simp [hpos]))",
  "tactic-prompt":
  "theorem (t : IndexAddTree) {A : Type _}  [AddCommGroup A]  [Repr A] {n : ℕ}  (l : List A)  (h : l.length = n)  (hpos : n > 0) -- basisImages  -- a few helper results and lemmas : IndexAddTree.foldMap t l.toArray (by simp [h, hpos]) =\n                         (inducedFreeMap l h) (IndexAddTree.foldMap t (ℤbasis n).toArray (by simp [hpos])) := by induction t; sorry",
  "name": "IndexAddTree.fold_tree_freegroup_eq",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "(t : IndexAddTree) {A : Type _}  [AddCommGroup A]  [Repr A] {n : ℕ}  (l : List A)  (h : l.length = n)  (hpos : n > 0) -- basisImages  -- a few helper results and lemmas : IndexAddTree.foldMap t l.toArray (by simp [h, hpos]) =\n                         (inducedFreeMap l h) (IndexAddTree.foldMap t (ℤbasis n).toArray (by simp [hpos]))",
  "args":
  "(t : IndexAddTree) {A : Type _}  [AddCommGroup A]  [Repr A] {n : ℕ}  (l : List A)  (h : l.length = n)  (hpos : n > 0) -- basisImages  -- a few helper results and lemmas"},
 {"type": "s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]  (s₁ s₂ : FormalSum X)  (a: Nat)  (x: X) : s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂ := by intro h; sorry",
  "name": "cons_equiv_of_equiv",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]  (s₁ s₂ : FormalSum X)  (a: Nat)  (x: X) : s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]  (s₁ s₂ : FormalSum X)  (a: Nat)  (x: X)"},
 {"type":
  "monomCoeff x₀ (a + b, x) = monomCoeff x₀ (a, x) + monomCoeff x₀ (b, x)",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x₀ x : X) (a b : Nat) : monomCoeff x₀ (a + b, x) = monomCoeff x₀ (a, x) + monomCoeff x₀ (b, x) := by repeat (rw [monomCoeff]); sorry",
  "name": "monom_coeff_hom",
  "kind": "theorem",
  "first-tactic": "repeat (rw [monomCoeff])",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x₀ x : X) (a b : Nat) : monomCoeff x₀ (a + b, x) = monomCoeff x₀ (a, x) + monomCoeff x₀ (b, x)",
  "args": "(X: Type) [DecidableEq X] (x₀ x : X) (a b : Nat)"},
 {"type": "monomCoeff x₀ (0, x) = 0",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x₀ x : X) : monomCoeff x₀ (0, x) = 0 := by rw [monomCoeff]; sorry",
  "name": "monom_coeff_at_zero",
  "kind": "theorem",
  "first-tactic": "rw [monomCoeff]",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x₀ x : X) : monomCoeff x₀ (0, x) = 0",
  "args": "(X: Type) [DecidableEq X] (x₀ x : X)"},
 {"type": "coeff  x₀  s₁ = coeff  x₀ s₂",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x₀ : X) (s₁ s₂: FormalSum X) (h: BasicRel X s₁ s₂) : coeff  x₀  s₁ = coeff  x₀ s₂ := by induction h; sorry",
  "name": "coeff_move_invariant",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x₀ : X) (s₁ s₂: FormalSum X) (h: BasicRel X s₁ s₂) : coeff  x₀  s₁ = coeff  x₀ s₂",
  "args":
  "(X: Type) [DecidableEq X] (x₀ : X) (s₁ s₂: FormalSum X) (h: BasicRel X s₁ s₂)"},
 {"type": "FreeNatModuleAux.coeff X x (sum s) = coeff x s",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x: X) (s: FormalSum X) : FreeNatModuleAux.coeff X x (sum s) = coeff x s := by simp [FreeNatModuleAux.coeff]; sorry",
  "name": "coeff_factors",
  "kind": "theorem",
  "first-tactic": "simp [FreeNatModuleAux.coeff]",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x: X) (s: FormalSum X) : FreeNatModuleAux.coeff X x (sum s) = coeff x s",
  "args": "(X: Type) [DecidableEq X] (x: X) (s: FormalSum X)"},
 {"type": "s₁ ≃ s₂ → (coeff x s₁) = (coeff x s₂)",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x: X) (s₁ s₂: FormalSum X) : s₁ ≃ s₂ → (coeff x s₁) = (coeff x s₂) := by intro hyp; sorry",
  "name": "coeff_well_defined",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x: X) (s₁ s₂: FormalSum X) : s₁ ≃ s₂ → (coeff x s₁) = (coeff x s₂)",
  "args": "(X: Type) [DecidableEq X] (x: X) (s₁ s₂: FormalSum X)"},
 {"type":
  "0 < s.coeff x₀  → \n          (∃ ys: FormalSum X, \n            (((s.coeff x₀, x₀) :: ys) ≃ s) ∧ \n            (List.length ys < s.length))",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x₀ : X) (s : FormalSum X) : 0 < s.coeff x₀  → \n          (∃ ys: FormalSum X, \n            (((s.coeff x₀, x₀) :: ys) ≃ s) ∧ \n            (List.length ys < s.length)) := by induction s; sorry",
  "name": "pos_coeff_has_complement",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x₀ : X) (s : FormalSum X) : 0 < s.coeff x₀  → \n          (∃ ys: FormalSum X, \n            (((s.coeff x₀, x₀) :: ys) ≃ s) ∧ \n            (List.length ys < s.length))",
  "args": "(X: Type) [DecidableEq X] (x₀ : X) (s : FormalSum X)"},
 {"type": "f = g → equalOnSupport l f g",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]    (l: List X) (f g : X → Nat) : f = g → equalOnSupport l f g := by intro hyp; sorry",
  "name": "equal_on_support_of_equal",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]    (l: List X) (f g : X → Nat) : f = g → equalOnSupport l f g",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]    (l: List X) (f g : X → Nat)"},
 {"type": "eqlCoords X s s",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (s: FormalSum X) : eqlCoords X s s := by rfl; sorry",
  "name": "refl",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (s: FormalSum X) : eqlCoords X s s",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (s: FormalSum X)"},
 {"type": "eqlCoords X s₁ s₂ → eqlCoords X s₂ s₁",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ : FormalSum X} : eqlCoords X s₁ s₂ → eqlCoords X s₂ s₁ := by intro hyp; sorry",
  "name": "symm",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ : FormalSum X} : eqlCoords X s₁ s₂ → eqlCoords X s₂ s₁",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ : FormalSum X}"},
 {"type": "eqlCoords X s₁ s₂ → eqlCoords X s₂ s₃ → eqlCoords X s₁ s₃",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ s₃ : FormalSum X} : eqlCoords X s₁ s₂ → eqlCoords X s₂ s₃ → eqlCoords X s₁ s₃ := by intro hyp₁ hyp₂; sorry",
  "name": "trans",
  "kind": "theorem",
  "first-tactic": "intro hyp₁ hyp₂",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ s₃ : FormalSum X} : eqlCoords X s₁ s₂ → eqlCoords X s₂ s₃ → eqlCoords X s₁ s₃",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ s₃ : FormalSum X}"},
 {"type":
  "(∀ s₁ s₂ : FormalSum X, ∀ mv : BasicRel X s₁ s₂, f s₁ = f s₂) → \n  (∀ s₁ s₂ : FormalSum X, s₁ ≈ s₂ →  f s₁ = f s₂)",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {β : Sort u}    (f : FormalSum X → β) : (∀ s₁ s₂ : FormalSum X, ∀ mv : BasicRel X s₁ s₂, f s₁ = f s₂) → \n  (∀ s₁ s₂ : FormalSum X, s₁ ≈ s₂ →  f s₁ = f s₂) := by intro hyp; sorry",
  "name": "func_eql_of_move_equiv",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {β : Sort u}    (f : FormalSum X → β) : (∀ s₁ s₂ : FormalSum X, ∀ mv : BasicRel X s₁ s₂, f s₁ = f s₂) → \n  (∀ s₁ s₂ : FormalSum X, s₁ ≈ s₂ →  f s₁ = f s₂)",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {β : Sort u}    (f : FormalSum X → β)"},
 {"type": "FreeNatModule X → Nat",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (f₀ : X → Nat) : FreeNatModule X → Nat := by apply Quotient.lift (linear_extension f₀); sorry",
  "name": "miniUniversalProperty",
  "kind": "def",
  "first-tactic": "apply Quotient.lift (linear_extension f₀)",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (f₀ : X → Nat) : FreeNatModule X → Nat",
  "args": "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (f₀ : X → Nat)"},
 {"type": "Bool",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X) : Bool := by apply Quotient.lift₂ (fun (s₁ s₂ : FormalSum X) => \n          decide ( ⟦ s₁ ⟧ = ⟦ s₂ ⟧)); sorry",
  "name": "FreeNatModule.beq?",
  "kind": "def",
  "first-tactic":
  "apply Quotient.lift₂ (fun (s₁ s₂ : FormalSum X) => \n          decide ( ⟦ s₁ ⟧ = ⟦ s₂ ⟧))",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X) : Bool",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X)"},
 {"type": "∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = true → x₁ = x₂",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : ∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = true → x₁ = x₂ := by let f := @Quotient.ind₂ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (x₁ x₂ : FreeNatModule X) =>   x₁.beq? x₂ = true → x₁ = x₂); sorry",
  "name": "FreeNatModule.eq_of_beq_true",
  "kind": "def",
  "first-tactic":
  "let f := @Quotient.ind₂ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (x₁ x₂ : FreeNatModule X) =>   x₁.beq? x₂ = true → x₁ = x₂)",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : ∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = true → x₁ = x₂",
  "args": "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]"},
 {"type": "∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = false → Not (x₁ = x₂)",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : ∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = false → Not (x₁ = x₂) := by let f := @Quotient.ind₂ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (x₁ x₂ : FreeNatModule X) =>   x₁.beq? x₂ = false →\n                Not (x₁ = x₂)); sorry",
  "name": "FreeNatModule.neq_of_beq_false",
  "kind": "def",
  "first-tactic":
  "let f := @Quotient.ind₂ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (x₁ x₂ : FreeNatModule X) =>   x₁.beq? x₂ = false →\n                Not (x₁ = x₂))",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : ∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = false → Not (x₁ = x₂)",
  "args": "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]"},
 {"type": "Decidable (x₁ = x₂)",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X) : Decidable (x₁ = x₂) := by match p:x₁.beq? x₂ with\n    | true => \n      apply Decidable.isTrue\n      apply FreeNatModule.eq_of_beq_true\n      assumption\n    | false => \n      apply Decidable.isFalse\n      apply FreeNatModule.neq_of_beq_false\n      assumption; sorry",
  "name": "FreeNatModule.decEq",
  "kind": "def",
  "first-tactic":
  "match p:x₁.beq? x₂ with\n    | true => \n      apply Decidable.isTrue\n      apply FreeNatModule.eq_of_beq_true\n      assumption\n    | false => \n      apply Decidable.isFalse\n      apply FreeNatModule.neq_of_beq_false\n      assumption",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X) : Decidable (x₁ = x₂)",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X)"},
 {"type": "(EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z) := by intro p q; sorry",
  "name": "multiply",
  "kind": "def",
  "first-tactic": "intro p q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}"},
 {"type": "G.init e = x → (term G (G.bar e) = x)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x) := by intro h; sorry",
  "name": "lemma1",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x : V} {e : E}"},
 {"type": "(multiply (multiply p q) r) = (multiply p (multiply q r))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r)) := by induction p; sorry",
  "name": "mult_assoc",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z)"},
 {"type": "(multiply p (single y)) = p",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p := by induction p; sorry",
  "name": "mult_const",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {p : EdgePath G x y}"},
 {"type": "(homotopy (multiply q p1) (multiply q p2))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2)) := by induction q; sorry",
  "name": "homotopy_left_mult",
  "kind": "theorem",
  "first-tactic": "induction q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2)"},
 {"type": "(inducedFreeMap l h) (ℤbasisElem n k) = l.get ⟨k, h ▸ hk⟩",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {n : ℕ}  (l : List A)  (h : l.length = n)  (k: ℕ)  (hk : k < n) : (inducedFreeMap l h) (ℤbasisElem n k) = l.get ⟨k, h ▸ hk⟩ := by rw [ℤbasisElem, List.get!_of_get, List.mapget (inducedFreeMap l h)]; sorry",
  "name": "induced_free_map_at",
  "kind": "theorem",
  "first-tactic":
  "rw [ℤbasisElem, List.get!_of_get, List.mapget (inducedFreeMap l h)]",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {n : ℕ}  (l : List A)  (h : l.length = n)  (k: ℕ)  (hk : k < n) : (inducedFreeMap l h) (ℤbasisElem n k) = l.get ⟨k, h ▸ hk⟩",
  "args":
  "{A : Type _}  [AddCommGroup A]  {n : ℕ}  (l : List A)  (h : l.length = n)  (k: ℕ)  (hk : k < n)"},
 {"type": "x + z - y + x - y + z =  viafree# (x + z - y + x - y + z)",
  "tactic-prompt":
  "theorem {α : Type} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]      (x y z : α) : x + z - y + x - y + z =  viafree# (x + z - y + x - y + z) := by simp only [AddCommGroup.Homomorphism.neg_dist, AddCommGroup.add_distrib, induced_free_map_at, List.get]; sorry",
  "name": "egViaFreeEql",
  "kind": "theorem",
  "first-tactic":
  "simp only [AddCommGroup.Homomorphism.neg_dist, AddCommGroup.add_distrib, induced_free_map_at, List.get]",
  "core-prompt":
  "{α : Type} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]      (x y z : α) : x + z - y + x - y + z =  viafree# (x + z - y + x - y + z)",
  "args":
  "{α : Type} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]      (x y z : α)"},
 {"type": "x + x + y - x - y + z - x = z",
  "tactic-prompt":
  "example {x y z : ℤ} : x + x + y - x - y + z - x = z := by have p := freeGroupEq# (x + x + y - x - y + z - x); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq# (x + x + y - x - y + z - x)",
  "core-prompt": "{x y z : ℤ} : x + x + y - x - y + z - x = z",
  "args": "{x y z : ℤ}"},
 {"type": "Graph Unit Bool",
  "tactic-prompt": "example  : Graph Unit Bool := by apply Graph.mk; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply Graph.mk",
  "core-prompt": " : Graph Unit Bool",
  "args": ""}]