[{"type": "HEq f f'",
  "tactic-prompt":
  "lemma {α β γ : Sort _}  {f : α → β} {α α': Sort u}  {β : α → Sort v}  {β' : α' → Sort v}  {f : ∀a, β a}  {f' : ∀a, β' a}    (hα : α = α')  (h : ∀a a', HEq a a' → HEq (f a) (f' a')) : HEq f f' := by subst hα; sorry",
  "name": "hfunext",
  "kind": "lemma",
  "first-tactic": "subst hα",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} {α α': Sort u}  {β : α → Sort v}  {β' : α' → Sort v}  {f : ∀a, β a}  {f' : ∀a, β' a}    (hα : α = α')  (h : ∀a a', HEq a a' → HEq (f a) (f' a')) : HEq f f'",
  "args":
  "{α β γ : Sort _}  {f : α → β} {α α': Sort u}  {β : α → Sort v}  {β' : α' → Sort v}  {f : ∀a, β a}  {f' : ∀a, β' a}    (hα : α = α')  (h : ∀a a', HEq a a' → HEq (f a) (f' a'))"},
 {"type": "Function.injective (λ x => if h : p x then f ⟨x, h⟩ else f' ⟨x, h⟩)",
  "tactic-prompt":
  "lemma {α β γ : Sort _}  {f : α → β} (p : α → Prop)  [DecidablePred p]    {f : {a : α // p a} → β}  {f' : {a : α // ¬ p a} → β}    (hf : injective f)  (hf' : injective f')    (im_disj : ∀ {x x' : α} {hx : p x} {hx' : ¬ p x'}, f ⟨x, hx⟩ ≠ f' ⟨x', hx'⟩) : Function.injective (λ x => if h : p x then f ⟨x, h⟩ else f' ⟨x, h⟩) := by intros x₁ x₂ h\n   --TODO mathlib3 uses dsimp here; sorry",
  "name": "injective.dite",
  "kind": "lemma",
  "first-tactic": "intros x₁ x₂ h\n   --TODO mathlib3 uses dsimp here",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} (p : α → Prop)  [DecidablePred p]    {f : {a : α // p a} → β}  {f' : {a : α // ¬ p a} → β}    (hf : injective f)  (hf' : injective f')    (im_disj : ∀ {x x' : α} {hx : p x} {hx' : ¬ p x'}, f ⟨x, hx⟩ ≠ f' ⟨x', hx'⟩) : Function.injective (λ x => if h : p x then f ⟨x, h⟩ else f' ⟨x, h⟩)",
  "args":
  "{α β γ : Sort _}  {f : α → β} (p : α → Prop)  [DecidablePred p]    {f : {a : α // p a} → β}  {f' : {a : α // ¬ p a} → β}    (hf : injective f)  (hf' : injective f')    (im_disj : ∀ {x x' : α} {hx : p x} {hx' : ¬ p x'}, f ⟨x, hx⟩ ≠ f' ⟨x', hx'⟩)"},
 {"type": "g₁ = g₂",
  "tactic-prompt":
  "theorem {α β γ : Sort _}  {f : α → β} {f : α → β}  {g₁ g₂ : β → α}  (h₁ : LeftInverse g₁ f)    (h₂ : Function.RightInverse g₂ f) : g₁ = g₂ := by have h₃ : g₁ = g₁ ∘ f ∘ g₂ := by rw [h₂.comp_eq_id, comp.right_id]; sorry",
  "name": "LeftInverse.eq_RightInverse",
  "kind": "theorem",
  "first-tactic":
  "have h₃ : g₁ = g₁ ∘ f ∘ g₂ := by rw [h₂.comp_eq_id, comp.right_id]",
  "core-prompt":
  "{α β γ : Sort _}  {f : α → β} {f : α → β}  {g₁ g₂ : β → α}  (h₁ : LeftInverse g₁ f)    (h₂ : Function.RightInverse g₂ f) : g₁ = g₂",
  "args":
  "{α β γ : Sort _}  {f : α → β} {f : α → β}  {g₁ g₂ : β → α}  (h₁ : LeftInverse g₁ f)    (h₂ : Function.RightInverse g₂ f)"},
 {"type": "inv_fun_on f s b ∈ s ∧ f (inv_fun_on f s b) = b",
  "tactic-prompt":
  "theorem {α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ∃a∈s, f a = b) : inv_fun_on f s b ∈ s ∧ f (inv_fun_on f s b) = b := by have h1 : inv_fun_on f s b =\n     if h : ∃a, a ∈ s ∧ f a = b then Classical.choose h else Classical.choice n := rfl; sorry",
  "name": "inv_fun_on_pos",
  "kind": "theorem",
  "first-tactic":
  "have h1 : inv_fun_on f s b =\n     if h : ∃a, a ∈ s ∧ f a = b then Classical.choose h else Classical.choice n := rfl",
  "core-prompt":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ∃a∈s, f a = b) : inv_fun_on f s b ∈ s ∧ f (inv_fun_on f s b) = b",
  "args":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ∃a∈s, f a = b)"},
 {"type": "inv_fun_on f s b = Classical.choice n",
  "tactic-prompt":
  "theorem {α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃a∈s, f a = b) : inv_fun_on f s b = Classical.choice n := by have h1 : inv_fun_on f s b =\n     if h : ∃a, a ∈ s ∧ f a = b then Classical.choose h else Classical.choice n := rfl; sorry",
  "name": "inv_fun_on_neg",
  "kind": "theorem",
  "first-tactic":
  "have h1 : inv_fun_on f s b =\n     if h : ∃a, a ∈ s ∧ f a = b then Classical.choose h else Classical.choice n := rfl",
  "core-prompt":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃a∈s, f a = b) : inv_fun_on f s b = Classical.choice n",
  "args":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃a∈s, f a = b)"},
 {"type": "inv_fun f b = Classical.choice n",
  "tactic-prompt":
  "lemma {α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃ a, f a = b) : inv_fun f b = Classical.choice n := by refine inv_fun_on_neg (mt ?_ h); sorry",
  "name": "inv_fun_neg",
  "kind": "lemma",
  "first-tactic": "refine inv_fun_on_neg (mt ?_ h)",
  "core-prompt":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃ a, f a = b) : inv_fun f b = Classical.choice n",
  "args":
  "{α : Type u}  [n : Nonempty α]  {β : Sort v}  {f : α → β}  {s : Set α}  {a : α}  {b : β} (h : ¬ ∃ a, f a = b)"},
 {"type": "update f a' b a = if a = a' then b else f a",
  "tactic-prompt":
  "lemma {α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {β : Sort _}  (f : α → β)  (a' : α)  (b : β)  (a : α) : update f a' b a = if a = a' then b else f a := by have h2 : (h : a = a') → Eq.rec (motive := λ _ _ => β) b h.symm = b :=\n     by intro h\n        rw [eq_rec_constant]; sorry",
  "name": "update_apply",
  "kind": "lemma",
  "first-tactic":
  "have h2 : (h : a = a') → Eq.rec (motive := λ _ _ => β) b h.symm = b :=\n     by intro h\n        rw [eq_rec_constant]",
  "core-prompt":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {β : Sort _}  (f : α → β)  (a' : α)  (b : β)  (a : α) : update f a' b a = if a = a' then b else f a",
  "args":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {β : Sort _}  (f : α → β)  (a' : α)  (b : β)  (a : α)"},
 {"type": "injective (update f a')",
  "tactic-prompt":
  "lemma {α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] (f : ∀a, β a)  (a' : α) : injective (update f a') := by intros v v' h; sorry",
  "name": "update_injective",
  "kind": "lemma",
  "first-tactic": "intros v v' h",
  "core-prompt":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] (f : ∀a, β a)  (a' : α) : injective (update f a')",
  "args":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] (f : ∀a, β a)  (a' : α)"},
 {"type": "f j (update g i v j) = update (λ k => f k (g k)) i (f i v) j",
  "tactic-prompt":
  "lemma {α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {ι : Sort _}  [DecidableEq ι]  {α β : ι → Sort _}    (f : ∀i, α i → β i)  (g : ∀i, α i)  (i : ι)  (v : α i)  (j : ι) : f j (update g i v j) = update (λ k => f k (g k)) i (f i v) j := by by_cases h : j = i; sorry",
  "name": "apply_update",
  "kind": "lemma",
  "first-tactic": "by_cases h : j = i",
  "core-prompt":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {ι : Sort _}  [DecidableEq ι]  {α β : ι → Sort _}    (f : ∀i, α i → β i)  (g : ∀i, α i)  (i : ι)  (v : α i)  (j : ι) : f j (update g i v j) = update (λ k => f k (g k)) i (f i v) j",
  "args":
  "{α : Sort u}  {β : α → Sort v}  {α' : Sort w}  [DecidableEq α]  [DecidableEq α'] {ι : Sort _}  [DecidableEq ι]  {α β : ι → Sort _}    (f : ∀i, α i → β i)  (g : ∀i, α i)  (i : ι)  (v : α i)  (j : ι)"},
 {"type":
  "extend f g e' b = if h : ∃ a, f a = b then g (Classical.choose h) else e' b",
  "tactic-prompt":
  "lemma {α β γ : Type _}  {f : α → β} (f : α → β)  (g : α → γ)  (e' : β → γ)  (b : β)  [hd : Decidable (∃ a, f a = b)] : extend f g e' b = if h : ∃ a, f a = b then g (Classical.choose h) else e' b := by rw [Subsingleton.elim hd] -- align the Decidable instances implicitly used by `dite`; sorry",
  "name": "extend_def",
  "kind": "lemma",
  "first-tactic":
  "rw [Subsingleton.elim hd] -- align the Decidable instances implicitly used by `dite`",
  "core-prompt":
  "{α β γ : Type _}  {f : α → β} (f : α → β)  (g : α → γ)  (e' : β → γ)  (b : β)  [hd : Decidable (∃ a, f a = b)] : extend f g e' b = if h : ∃ a, f a = b then g (Classical.choose h) else e' b",
  "args":
  "{α β γ : Type _}  {f : α → β} (f : α → β)  (g : α → γ)  (e' : β → γ)  (b : β)  [hd : Decidable (∃ a, f a = b)]"},
 {"type": "extend f g e' (f a) = g a",
  "tactic-prompt":
  "lemma {α β γ : Type _}  {f : α → β} (hf : injective f)  (g : α → γ)  (e' : β → γ)  (a : α) : extend f g e' (f a) = g a := by simp only [extend_def, dif_pos, exists_apply_eq_apply]; sorry",
  "name": "extend_apply",
  "kind": "lemma",
  "first-tactic": "simp only [extend_def, dif_pos, exists_apply_eq_apply]",
  "core-prompt":
  "{α β γ : Type _}  {f : α → β} (hf : injective f)  (g : α → γ)  (e' : β → γ)  (a : α) : extend f g e' (f a) = g a",
  "args":
  "{α β γ : Type _}  {f : α → β} (hf : injective f)  (g : α → γ)  (e' : β → γ)  (a : α)"},
 {"type": "uncurry (bicompl f g h) = (uncurry f) ∘ (Prod.map g h)",
  "tactic-prompt":
  "lemma (f : γ → δ → ε)  (g : α → γ)  (h : β → δ) : uncurry (bicompl f g h) = (uncurry f) ∘ (Prod.map g h) := by ext ⟨x, y⟩; sorry",
  "name": "uncurry_bicompl",
  "kind": "lemma",
  "first-tactic": "ext ⟨x, y⟩",
  "core-prompt":
  "(f : γ → δ → ε)  (g : α → γ)  (h : β → δ) : uncurry (bicompl f g h) = (uncurry f) ∘ (Prod.map g h)",
  "args": "(f : γ → δ → ε)  (g : α → γ)  (h : β → δ)"},
 {"type": "f (ite P x (f x)) = ite (¬ P) x (f x)",
  "tactic-prompt":
  "lemma {α : Sort u}  {f : α → α}  (h : involutive f) (P : Prop)  [Decidable P]  (x : α) : f (ite P x (f x)) = ite (¬ P) x (f x) := by rw [apply_ite f, h, ite_not]; sorry",
  "name": "ite_not",
  "kind": "lemma",
  "first-tactic": "rw [apply_ite f, h, ite_not]",
  "core-prompt":
  "{α : Sort u}  {f : α → α}  (h : involutive f) (P : Prop)  [Decidable P]  (x : α) : f (ite P x (f x)) = ite (¬ P) x (f x)",
  "args":
  "{α : Sort u}  {f : α → α}  (h : involutive f) (P : Prop)  [Decidable P]  (x : α)"},
 {"type": "a ∨ (b ∨ c) ↔ b ∨ (a ∨ c)",
  "tactic-prompt":
  "lemma  : a ∨ (b ∨ c) ↔ b ∨ (a ∨ c) := by rw [← or_assoc, ← or_assoc, @or_comm a b]; sorry",
  "name": "or_left_comm",
  "kind": "lemma",
  "first-tactic": "rw [← or_assoc, ← or_assoc, @or_comm a b]",
  "core-prompt": " : a ∨ (b ∨ c) ↔ b ∨ (a ∨ c)",
  "args": ""},
 {"type": "(¬a → a) ↔ a",
  "tactic-prompt":
  "theorem {a b c d : Prop} [Decidable a] : (¬a → a) ↔ a := by have := @imp_not_self (¬a); sorry",
  "name": "Decidable.not_imp_self",
  "kind": "theorem",
  "first-tactic": "have := @imp_not_self (¬a)",
  "core-prompt": "{a b c d : Prop} [Decidable a] : (¬a → a) ↔ a",
  "args": "{a b c d : Prop} [Decidable a]"},
 {"type": "xor True = Not",
  "tactic-prompt":
  "theorem {a b c d : Prop} : xor True = Not := by simp [xor]; sorry",
  "name": "xor_true",
  "kind": "theorem",
  "first-tactic": "simp [xor]",
  "core-prompt": "{a b c d : Prop} : xor True = Not",
  "args": "{a b c d : Prop}"},
 {"type": "xor False = id",
  "tactic-prompt": "theorem {a b c d : Prop} : xor False = id := by ext; sorry",
  "name": "xor_false",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt": "{a b c d : Prop} : xor False = id",
  "args": "{a b c d : Prop}"},
 {"type": "xor a a = False",
  "tactic-prompt":
  "theorem {a b c d : Prop} (a : Prop) : xor a a = False := by simp [xor]; sorry",
  "name": "xor_self",
  "kind": "theorem",
  "first-tactic": "simp [xor]",
  "core-prompt": "{a b c d : Prop} (a : Prop) : xor a a = False",
  "args": "{a b c d : Prop} (a : Prop)"},
 {"type": "(a ∧ b) ∧ c ↔ (a ∧ c) ∧ b",
  "tactic-prompt":
  "lemma {a b c d : Prop} : (a ∧ b) ∧ c ↔ (a ∧ c) ∧ b := by simp only [And.left_comm, And.comm]; sorry",
  "name": "And.right_comm",
  "kind": "lemma",
  "first-tactic": "simp only [And.left_comm, And.comm]",
  "core-prompt": "{a b c d : Prop} : (a ∧ b) ∧ c ↔ (a ∧ c) ∧ b",
  "args": "{a b c d : Prop}"},
 {"type": "a ∧ b ∧ c ↔ b ∧ c ∧ a",
  "tactic-prompt":
  "lemma {a b c d : Prop} : a ∧ b ∧ c ↔ b ∧ c ∧ a := by simp only [And.left_comm, And.comm]; sorry",
  "name": "And.rotate",
  "kind": "lemma",
  "first-tactic": "simp only [And.left_comm, And.comm]",
  "core-prompt": "{a b c d : Prop} : a ∧ b ∧ c ↔ b ∧ c ∧ a",
  "args": "{a b c d : Prop}"},
 {"type": "(p ↔ p ∧ q) ↔ (p → q)",
  "tactic-prompt":
  "lemma {a b c d : Prop} {p q : Prop} : (p ↔ p ∧ q) ↔ (p → q) := by rw [@Iff.comm p, and_iff_left_iff_imp]; sorry",
  "name": "iff_self_and",
  "kind": "lemma",
  "first-tactic": "rw [@Iff.comm p, and_iff_left_iff_imp]",
  "core-prompt": "{a b c d : Prop} {p q : Prop} : (p ↔ p ∧ q) ↔ (p → q)",
  "args": "{a b c d : Prop} {p q : Prop}"},
 {"type": "(p ↔ q ∧ p) ↔ (p → q)",
  "tactic-prompt":
  "lemma {a b c d : Prop} {p q : Prop} : (p ↔ q ∧ p) ↔ (p → q) := by rw [and_comm, iff_self_and]; sorry",
  "name": "iff_and_self",
  "kind": "lemma",
  "first-tactic": "rw [and_comm, iff_self_and]",
  "core-prompt": "{a b c d : Prop} {p q : Prop} : (p ↔ q ∧ p) ↔ (p → q)",
  "args": "{a b c d : Prop} {p q : Prop}"},
 {"type": "(a ∧ c ↔ b ∧ c) ↔ c → (a ↔ b)",
  "tactic-prompt":
  "lemma {a b c d : Prop} : (a ∧ c ↔ b ∧ c) ↔ c → (a ↔ b) := by simp only [And.comm, ← And.congr_right_iff]; sorry",
  "name": "And.congr_left_iff",
  "kind": "lemma",
  "first-tactic": "simp only [And.comm, ← And.congr_right_iff]",
  "core-prompt": "{a b c d : Prop} : (a ∧ c ↔ b ∧ c) ↔ c → (a ↔ b)",
  "args": "{a b c d : Prop}"},
 {"type": "(a ∨ b) ∨ c ↔ (a ∨ c) ∨ b",
  "tactic-prompt":
  "theorem {a b c d : Prop} : (a ∨ b) ∨ c ↔ (a ∨ c) ∨ b := by rw [or_assoc, or_assoc, or_comm b]; sorry",
  "name": "or.right_comm",
  "kind": "theorem",
  "first-tactic": "rw [or_assoc, or_assoc, or_comm b]",
  "core-prompt": "{a b c d : Prop} : (a ∨ b) ∨ c ↔ (a ∨ c) ∨ b",
  "args": "{a b c d : Prop}"},
 {"type": "(a ∨ b ↔ b) ↔ (a → b)",
  "tactic-prompt":
  "theorem {a b c d : Prop} : (a ∨ b ↔ b) ↔ (a → b) := by rw [or_comm, or_iff_left_iff_imp]; sorry",
  "name": "or_iff_right_iff_imp",
  "kind": "theorem",
  "first-tactic": "rw [or_comm, or_iff_left_iff_imp]",
  "core-prompt": "{a b c d : Prop} : (a ∨ b ↔ b) ↔ (a → b)",
  "args": "{a b c d : Prop}"},
 {"type": "(a → b ∨ c) ↔ (a → b) ∨ (a → c)",
  "tactic-prompt":
  "theorem {a b c d : Prop} [Decidable a] : (a → b ∨ c) ↔ (a → b) ∨ (a → c) := by by_cases a <;> simp_all; sorry",
  "name": "Decidable.imp_or_distrib",
  "kind": "theorem",
  "first-tactic": "by_cases a <;> simp_all",
  "core-prompt":
  "{a b c d : Prop} [Decidable a] : (a → b ∨ c) ↔ (a → b) ∨ (a → c)",
  "args": "{a b c d : Prop} [Decidable a]"},
 {"type": "(a → b ∨ c) ↔ (a → b) ∨ (a → c)",
  "tactic-prompt":
  "theorem {a b c d : Prop} [Decidable b] : (a → b ∨ c) ↔ (a → b) ∨ (a → c) := by by_cases b; sorry",
  "name": "Decidable.imp_or_distrib'",
  "kind": "theorem",
  "first-tactic": "by_cases b",
  "core-prompt":
  "{a b c d : Prop} [Decidable b] : (a → b ∨ c) ↔ (a → b) ∨ (a → c)",
  "args": "{a b c d : Prop} [Decidable b]"},
 {"type": "(¬ a ↔ ¬ b) ↔ (a ↔ b)",
  "tactic-prompt":
  "theorem {a b c d : Prop} [Decidable a]  [Decidable b] : (¬ a ↔ ¬ b) ↔ (a ↔ b) := by rw [@iff_def (¬ a), @iff_def' a]; sorry",
  "name": "Decidable.not_iff_not",
  "kind": "theorem",
  "first-tactic": "rw [@iff_def (¬ a), @iff_def' a]",
  "core-prompt":
  "{a b c d : Prop} [Decidable a]  [Decidable b] : (¬ a ↔ ¬ b) ↔ (a ↔ b)",
  "args": "{a b c d : Prop} [Decidable a]  [Decidable b]"},
 {"type": "(¬ a ↔ b) ↔ (¬ b ↔ a)",
  "tactic-prompt":
  "theorem {a b c d : Prop} [Decidable a]  [Decidable b] : (¬ a ↔ b) ↔ (¬ b ↔ a) := by rw [@iff_def (¬ a), @iff_def (¬ b)]; sorry",
  "name": "Decidable.not_iff_comm",
  "kind": "theorem",
  "first-tactic": "rw [@iff_def (¬ a), @iff_def (¬ b)]",
  "core-prompt":
  "{a b c d : Prop} [Decidable a]  [Decidable b] : (¬ a ↔ b) ↔ (¬ b ↔ a)",
  "args": "{a b c d : Prop} [Decidable a]  [Decidable b]"},
 {"type": "∀ [Decidable b], ¬ (a ↔ b) ↔ (¬ a ↔ b)",
  "tactic-prompt":
  "theorem {a b c d : Prop} : ∀ [Decidable b], ¬ (a ↔ b) ↔ (¬ a ↔ b) := by intro h; sorry",
  "name": "Decidable.not_iff",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "{a b c d : Prop} : ∀ [Decidable b], ¬ (a ↔ b) ↔ (¬ a ↔ b)",
  "args": "{a b c d : Prop}"},
 {"type": "(a ↔ ¬ b) ↔ (b ↔ ¬ a)",
  "tactic-prompt":
  "theorem {a b c d : Prop} [Decidable a]  [Decidable b] : (a ↔ ¬ b) ↔ (b ↔ ¬ a) := by rw [@iff_def a, @iff_def b]; sorry",
  "name": "Decidable.iff_not_comm",
  "kind": "theorem",
  "first-tactic": "rw [@iff_def a, @iff_def b]",
  "core-prompt":
  "{a b c d : Prop} [Decidable a]  [Decidable b] : (a ↔ ¬ b) ↔ (b ↔ ¬ a)",
  "args": "{a b c d : Prop} [Decidable a]  [Decidable b]"},
 {"type": "(a ↔ b) ↔ (a ∧ b) ∨ (¬ a ∧ ¬ b)",
  "tactic-prompt":
  "theorem {a b c d : Prop} [Decidable b] : (a ↔ b) ↔ (a ∧ b) ∨ (¬ a ∧ ¬ b) := by constructor; sorry",
  "name": "Decidable.iff_iff_and_or_not_and_not",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{a b c d : Prop} [Decidable b] : (a ↔ b) ↔ (a ∧ b) ∨ (¬ a ∧ ¬ b)",
  "args": "{a b c d : Prop} [Decidable b]"},
 {"type": "(a ↔ b) ↔ ((¬a ∨ b) ∧ (a ∨ ¬b))",
  "tactic-prompt":
  "lemma {a b c d : Prop} [Decidable a]  [Decidable b] : (a ↔ b) ↔ ((¬a ∨ b) ∧ (a ∨ ¬b)) := by rw [iff_iff_implies_and_implies a b]; sorry",
  "name": "Decidable.iff_iff_not_or_and_or_not",
  "kind": "lemma",
  "first-tactic": "rw [iff_iff_implies_and_implies a b]",
  "core-prompt":
  "{a b c d : Prop} [Decidable a]  [Decidable b] : (a ↔ b) ↔ ((¬a ∨ b) ∧ (a ∨ ¬b))",
  "args": "{a b c d : Prop} [Decidable a]  [Decidable b]"},
 {"type": "a ∨ b ↔ ¬ (¬a ∧ ¬b)",
  "tactic-prompt":
  "theorem {a b c d : Prop} [Decidable a]  [Decidable b] : a ∨ b ↔ ¬ (¬a ∧ ¬b) := by rw [← not_or_distrib, Decidable.not_not]; sorry",
  "name": "Decidable.or_iff_not_and_not",
  "kind": "theorem",
  "first-tactic": "rw [← not_or_distrib, Decidable.not_not]",
  "core-prompt":
  "{a b c d : Prop} [Decidable a]  [Decidable b] : a ∨ b ↔ ¬ (¬a ∧ ¬b)",
  "args": "{a b c d : Prop} [Decidable a]  [Decidable b]"},
 {"type": "a ∧ b ↔ ¬ (¬ a ∨ ¬ b)",
  "tactic-prompt":
  "theorem {a b c d : Prop} [Decidable a]  [Decidable b] : a ∧ b ↔ ¬ (¬ a ∨ ¬ b) := by rw [← Decidable.not_and_distrib, Decidable.not_not]; sorry",
  "name": "Decidable.and_iff_not_or_not",
  "kind": "theorem",
  "first-tactic": "rw [← Decidable.not_and_distrib, Decidable.not_not]",
  "core-prompt":
  "{a b c d : Prop} [Decidable a]  [Decidable b] : a ∧ b ↔ ¬ (¬ a ∨ ¬ b)",
  "args": "{a b c d : Prop} [Decidable a]  [Decidable b]"},
 {"type": "(@Eq.rec α a (λ α _ => β) y a' h) = y",
  "tactic-prompt":
  "lemma {α : Sort _}  {a b : α} {α : Sort _}  {a a' : α}  {β : Sort _}  (y : β)  (h : a = a') : (@Eq.rec α a (λ α _ => β) y a' h) = y := by cases h; sorry",
  "name": "eq_rec_constant",
  "kind": "lemma",
  "first-tactic": "cases h",
  "core-prompt":
  "{α : Sort _}  {a b : α} {α : Sort _}  {a a' : α}  {β : Sort _}  (y : β)  (h : a = a') : (@Eq.rec α a (λ α _ => β) y a' h) = y",
  "args":
  "{α : Sort _}  {a b : α} {α : Sort _}  {a a' : α}  {β : Sort _}  (y : β)  (h : a = a')"},
 {"type": "f x y = f x' y'",
  "tactic-prompt":
  "lemma {α : Sort _}  {a b : α} {α β γ : Type _}  (f : α → β → γ)  {x x' : α}  {y y' : β}    (hx : x = x')  (hy : y = y') : f x y = f x' y' := by subst hx; sorry",
  "name": "congr_arg2",
  "kind": "lemma",
  "first-tactic": "subst hx",
  "core-prompt":
  "{α : Sort _}  {a b : α} {α β γ : Type _}  (f : α → β → γ)  {x x' : α}  {y y' : β}    (hx : x = x')  (hy : y = y') : f x y = f x' y'",
  "args":
  "{α : Sort _}  {a b : α} {α β γ : Type _}  (f : α → β → γ)  {x x' : α}  {y y' : β}    (hx : x = x')  (hy : y = y')"},
 {"type": "(∀ a, a' = a → p a) ↔ p a'",
  "tactic-prompt":
  "theorem {α : Sort _}  {β : Sort _}  {p q : α → Prop}  {b : Prop} {a' : α} : (∀ a, a' = a → p a) ↔ p a' := by simp [@eq_comm _ a']; sorry",
  "name": "forall_eq'",
  "kind": "theorem",
  "first-tactic": "simp [@eq_comm _ a']",
  "core-prompt":
  "{α : Sort _}  {β : Sort _}  {p q : α → Prop}  {b : Prop} {a' : α} : (∀ a, a' = a → p a) ↔ p a'",
  "args": "{α : Sort _}  {β : Sort _}  {p q : α → Prop}  {b : Prop} {a' : α}"},
 {"type": "(∃x, p x ∧ q) ↔ (∃x, p x) ∧ q",
  "tactic-prompt":
  "theorem {α : Sort _}  {β : Sort _}  {p q : α → Prop}  {b : Prop} {q : Prop}  {p : α → Prop} : (∃x, p x ∧ q) ↔ (∃x, p x) ∧ q := by simp [And.comm]; sorry",
  "name": "exists_and_distrib_right",
  "kind": "theorem",
  "first-tactic": "simp [And.comm]",
  "core-prompt":
  "{α : Sort _}  {β : Sort _}  {p q : α → Prop}  {b : Prop} {q : Prop}  {p : α → Prop} : (∃x, p x ∧ q) ↔ (∃x, p x) ∧ q",
  "args":
  "{α : Sort _}  {β : Sort _}  {p q : α → Prop}  {b : Prop} {q : Prop}  {p : α → Prop}"},
 {"type": "(∃ a, a' = a ∧ p a) ↔ p a'",
  "tactic-prompt":
  "theorem {α : Sort _}  {β : Sort _}  {p q : α → Prop}  {b : Prop} {p : α → Prop}  {a' : α} : (∃ a, a' = a ∧ p a) ↔ p a' := by simp [@eq_comm _ a']; sorry",
  "name": "exists_eq_left'",
  "kind": "theorem",
  "first-tactic": "simp [@eq_comm _ a']",
  "core-prompt":
  "{α : Sort _}  {β : Sort _}  {p q : α → Prop}  {b : Prop} {p : α → Prop}  {a' : α} : (∃ a, a' = a ∧ p a) ↔ p a'",
  "args":
  "{α : Sort _}  {β : Sort _}  {p q : α → Prop}  {b : Prop} {p : α → Prop}  {a' : α}"},
 {"type": "f (dite P x y) = dite P (λ h => f (x h)) (λ h => f (y h))",
  "tactic-prompt":
  "lemma {α β : Sort _}  (f : α → β)  (P : Prop)  [Decidable P]  (x : P → α)  (y : ¬ P → α) : f (dite P x y) = dite P (λ h => f (x h)) (λ h => f (y h)) := by by_cases h : P <;> simp[h]; sorry",
  "name": "apply_dite",
  "kind": "lemma",
  "first-tactic": "by_cases h : P <;> simp[h]",
  "core-prompt":
  "{α β : Sort _}  (f : α → β)  (P : Prop)  [Decidable P]  (x : P → α)  (y : ¬ P → α) : f (dite P x y) = dite P (λ h => f (x h)) (λ h => f (y h))",
  "args":
  "{α β : Sort _}  (f : α → β)  (P : Prop)  [Decidable P]  (x : P → α)  (y : ¬ P → α)"},
 {"type": "dite (¬ P) x y = dite P (λ h => y (not_not_intro h)) x",
  "tactic-prompt":
  "lemma {α : Sort _}  (P : Prop)  [Decidable P]   (x : ¬ P → α)  (y : ¬¬ P → α) : dite (¬ P) x y = dite P (λ h => y (not_not_intro h)) x := by by_cases h : P <;> simp[h]; sorry",
  "name": "dite_not",
  "kind": "lemma",
  "first-tactic": "by_cases h : P <;> simp[h]",
  "core-prompt":
  "{α : Sort _}  (P : Prop)  [Decidable P]   (x : ¬ P → α)  (y : ¬¬ P → α) : dite (¬ P) x y = dite P (λ h => y (not_not_intro h)) x",
  "args":
  "{α : Sort _}  (P : Prop)  [Decidable P]   (x : ¬ P → α)  (y : ¬¬ P → α)"},
 {"type": "a ∧ (b ∧ c) ↔ b ∧ (a ∧ c)",
  "tactic-prompt":
  "lemma {a b c d : Prop} : a ∧ (b ∧ c) ↔ b ∧ (a ∧ c) := by rw [← and_assoc, ← and_assoc, @And.comm a b]; sorry",
  "name": "And.left_comm",
  "kind": "lemma",
  "first-tactic": "rw [← and_assoc, ← and_assoc, @And.comm a b]",
  "core-prompt": "{a b c d : Prop} : a ∧ (b ∧ c) ↔ b ∧ (a ∧ c)",
  "args": "{a b c d : Prop}"},
 {"type": "c → t",
  "tactic-prompt":
  "lemma {a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {c t e : Prop}  [Decidable c]  (h : ite c t e) : c → t := by intro hc; sorry",
  "name": "implies_of_if_pos",
  "kind": "lemma",
  "first-tactic": "intro hc",
  "core-prompt":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {c t e : Prop}  [Decidable c]  (h : ite c t e) : c → t",
  "args":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {c t e : Prop}  [Decidable c]  (h : ite c t e)"},
 {"type": "¬c → e",
  "tactic-prompt":
  "lemma {a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {c t e : Prop}  [Decidable c]  (h : ite c t e) : ¬c → e := by intro hnc; sorry",
  "name": "implies_of_if_neg",
  "kind": "lemma",
  "first-tactic": "intro hnc",
  "core-prompt":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {c t e : Prop}  [Decidable c]  (h : ite c t e) : ¬c → e",
  "args":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {c t e : Prop}  [Decidable c]  (h : ite c t e)"},
 {"type": "a₁ = a₂ → HEq (let x : α := a₁; b x) (let x : α := a₂; b x)",
  "tactic-prompt":
  "lemma {a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {α : Sort v}  {β : α → Sort u}  {a₁ a₂ : α}  (b : ∀ x : α, β x) : a₁ = a₂ → HEq (let x : α := a₁; b x) (let x : α := a₂; b x) := by intro h; sorry",
  "name": "let_value_heq",
  "kind": "lemma",
  "first-tactic": "intro h",
  "core-prompt":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {α : Sort v}  {β : α → Sort u}  {a₁ a₂ : α}  (b : ∀ x : α, β x) : a₁ = a₂ → HEq (let x : α := a₁; b x) (let x : α := a₂; b x)",
  "args":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {α : Sort v}  {β : α → Sort u}  {a₁ a₂ : α}  (b : ∀ x : α, β x)"},
 {"type":
  "(∀ x, b₁ x = b₂ x) → (let x : α := a; b₁ x) = (let x : α := a; b₂ x)",
  "tactic-prompt":
  "lemma {a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {α : Sort v}  {β : α → Sort u}  (a : α)  {b₁ b₂ : ∀ x : α, β x} : (∀ x, b₁ x = b₂ x) → (let x : α := a; b₁ x) = (let x : α := a; b₂ x) := by intro h; sorry",
  "name": "let_body_eq",
  "kind": "lemma",
  "first-tactic": "intro h",
  "core-prompt":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {α : Sort v}  {β : α → Sort u}  (a : α)  {b₁ b₂ : ∀ x : α, β x} : (∀ x, b₁ x = b₂ x) → (let x : α := a; b₁ x) = (let x : α := a; b₂ x)",
  "args":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false {α : Sort v}  {β : α → Sort u}  (a : α)  {b₁ b₂ : ∀ x : α, β x}"},
 {"type": "commutative f → associative f → left_commutative f",
  "tactic-prompt":
  "lemma {a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false  {α : Type u}  {β : Type v} (f : α → α → α) (inv : α → α) (one : α) (g : α → α → α) : commutative f → associative f → left_commutative f := by intros hcomm hassoc a b c; sorry",
  "name": "left_comm",
  "kind": "lemma",
  "first-tactic": "intros hcomm hassoc a b c",
  "core-prompt":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false  {α : Type u}  {β : Type v} (f : α → α → α) (inv : α → α) (one : α) (g : α → α → α) : commutative f → associative f → left_commutative f",
  "args":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false  {α : Type u}  {β : Type v} (f : α → α → α) (inv : α → α) (one : α) (g : α → α → α)"},
 {"type": "commutative f → associative f → right_commutative f",
  "tactic-prompt":
  "lemma {a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false  {α : Type u}  {β : Type v} (f : α → α → α) (inv : α → α) (one : α) (g : α → α → α) : commutative f → associative f → right_commutative f := by intros hcomm hassoc a b c; sorry",
  "name": "right_comm",
  "kind": "lemma",
  "first-tactic": "intros hcomm hassoc a b c",
  "core-prompt":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false  {α : Type u}  {β : Type v} (f : α → α → α) (inv : α → α) (one : α) (g : α → α → α) : commutative f → associative f → right_commutative f",
  "args":
  "{a b c d : Prop} {p q : Prop}    -- TODO: rec_on_true and rec_on_false  {α : Type u}  {β : Type v} (f : α → α → α) (inv : α → α) (one : α) (g : α → α → α)"},
 {"type": "min (min a b) c = min a (min b c)",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a b c : α) : min (min a b) c = min a (min b c) := by apply eq_min; sorry",
  "name": "min_assoc",
  "kind": "lemma",
  "first-tactic": "apply eq_min",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] (a b c : α) : min (min a b) c = min a (min b c)",
  "args": "{α : Type u}  [LinearOrder α] (a b c : α)"},
 {"type": "min a a = a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a : α) : min a a = a := by simp[min]; sorry",
  "name": "min_self",
  "kind": "lemma",
  "first-tactic": "simp[min]",
  "core-prompt": "{α : Type u}  [LinearOrder α] (a : α) : min a a = a",
  "args": "{α : Type u}  [LinearOrder α] (a : α)"},
 {"type": "min a b = a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b) : min a b = a := by apply Eq.symm; sorry",
  "name": "min_eq_left",
  "kind": "lemma",
  "first-tactic": "apply Eq.symm",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b) : min a b = a",
  "args": "{α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b)"},
 {"type": "min a b = b",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a) : min a b = b := by rw [min_comm]; sorry",
  "name": "min_eq_right",
  "kind": "lemma",
  "first-tactic": "rw [min_comm]",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a) : min a b = b",
  "args": "{α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a)"},
 {"type": "max (max a b) c = max a (max b c)",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a b c : α) : max (max a b) c = max a (max b c) := by apply eq_max; sorry",
  "name": "max_assoc",
  "kind": "lemma",
  "first-tactic": "apply eq_max",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] (a b c : α) : max (max a b) c = max a (max b c)",
  "args": "{α : Type u}  [LinearOrder α] (a b c : α)"},
 {"type": "max a a = a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] (a : α) : max a a = a := by simp[max]; sorry",
  "name": "max_self",
  "kind": "lemma",
  "first-tactic": "simp[max]",
  "core-prompt": "{α : Type u}  [LinearOrder α] (a : α) : max a a = a",
  "args": "{α : Type u}  [LinearOrder α] (a : α)"},
 {"type": "max a b = a",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a) : max a b = a := by apply Eq.symm; sorry",
  "name": "max_eq_left",
  "kind": "lemma",
  "first-tactic": "apply Eq.symm",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a) : max a b = a",
  "args": "{α : Type u}  [LinearOrder α] {a b : α}  (h : b ≤ a)"},
 {"type": "max a b = b",
  "tactic-prompt":
  "lemma {α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b) : max a b = b := by rw [←max_comm b a]; sorry",
  "name": "max_eq_right",
  "kind": "lemma",
  "first-tactic": "rw [←max_comm b a]",
  "core-prompt":
  "{α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b) : max a b = b",
  "args": "{α : Type u}  [LinearOrder α] {a b : α}  (h : a ≤ b)"},
 {"type": "n < k + n",
  "tactic-prompt":
  "lemma {n k : ℕ}  (h : 0 < k) : n < k + n := by rw [Nat.add_comm]; sorry",
  "name": "lt_add_of_pos_left",
  "kind": "lemma",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "{n k : ℕ}  (h : 0 < k) : n < k + n",
  "args": "{n k : ℕ}  (h : 0 < k)"},
 {"type": "n ≤ m",
  "tactic-prompt":
  "lemma {n m k : ℕ}  (h₀ : k ≤ m)  (h₁ : n - k ≤ m - k) : n ≤ m := by revert k m; sorry",
  "name": "le_of_le_of_sub_le_sub_right",
  "kind": "lemma",
  "first-tactic": "revert k m",
  "core-prompt": "{n m k : ℕ}  (h₀ : k ≤ m)  (h₁ : n - k ≤ m - k) : n ≤ m",
  "args": "{n m k : ℕ}  (h₀ : k ≤ m)  (h₁ : n - k ≤ m - k)"},
 {"type": "x + k ≤ y ↔ x ≤ y - k",
  "tactic-prompt":
  "theorem (x : ℕ)  {y k : ℕ}    (h : k ≤ y) : x + k ≤ y ↔ x ≤ y - k := by rw [← Nat.add_sub_cancel x k, Nat.sub_le_sub_right_iff h, Nat.add_sub_cancel]; sorry",
  "name": "add_le_to_le_sub",
  "kind": "theorem",
  "first-tactic":
  "rw [← Nat.add_sub_cancel x k, Nat.sub_le_sub_right_iff h, Nat.add_sub_cancel]",
  "core-prompt": "(x : ℕ)  {y k : ℕ}    (h : k ≤ y) : x + k ≤ y ↔ x ≤ y - k",
  "args": "(x : ℕ)  {y k : ℕ}    (h : k ≤ y)"},
 {"type": "b - a < b",
  "tactic-prompt":
  "lemma (a b : ℕ)  (h₀ : 0 < a)  (h₁ : a ≤ b) : b - a < b := by apply Nat.sub_lt _ h₀; sorry",
  "name": "sub_lt_of_pos_le",
  "kind": "lemma",
  "first-tactic": "apply Nat.sub_lt _ h₀",
  "core-prompt": "(a b : ℕ)  (h₀ : 0 < a)  (h₁ : a ≤ b) : b - a < b",
  "args": "(a b : ℕ)  (h₀ : 0 < a)  (h₁ : a ≤ b)"},
 {"type": "n - m + min n m = n",
  "tactic-prompt":
  "theorem (n m : ℕ) : n - m + min n m = n := by rw [sub_eq_sub_min, Nat.sub_add_cancel (min_le_left n m)]\n\n/- TODO(Leo): sub + inequalities -/; sorry",
  "name": "sub_add_min_cancel",
  "kind": "theorem",
  "first-tactic":
  "rw [sub_eq_sub_min, Nat.sub_add_cancel (min_le_left n m)]\n\n/- TODO(Leo): sub + inequalities -/",
  "core-prompt": "(n m : ℕ) : n - m + min n m = n",
  "args": "(n m : ℕ)"},
 {"type": "m % k + k * (m / k) = m",
  "tactic-prompt":
  "lemma (m k : ℕ) : m % k + k * (m / k) = m := by induction m, k using mod.inductionOn with rw [div_eq, mod_eq]\n  | base x y h => simp [h]\n  | ind x y h IH => simp [h]; rw [Nat.mul_succ, ← Nat.add_assoc, IH, Nat.sub_add_cancel h.2]\n\n/- div -/; sorry",
  "name": "mod_add_div",
  "kind": "lemma",
  "first-tactic":
  "induction m, k using mod.inductionOn with rw [div_eq, mod_eq]\n  | base x y h => simp [h]\n  | ind x y h IH => simp [h]; rw [Nat.mul_succ, ← Nat.add_assoc, IH, Nat.sub_add_cancel h.2]\n\n/- div -/",
  "core-prompt": "(m k : ℕ) : m % k + k * (m / k) = m",
  "args": "(m k : ℕ)"},
 {"type": "n / 0 = 0",
  "tactic-prompt": "lemma (n : ℕ) : n / 0 = 0 := by rw [div_eq]; sorry",
  "name": "div_zero",
  "kind": "lemma",
  "first-tactic": "rw [div_eq]",
  "core-prompt": "(n : ℕ) : n / 0 = 0",
  "args": "(n : ℕ)"},
 {"type": "x ≤ y / k ↔ x * k ≤ y",
  "tactic-prompt":
  "lemma (k0 : 0 < k) : x ≤ y / k ↔ x * k ≤ y := by induction y, k using mod.inductionOn generalizing x with\n    (rw [div_eq]; simp [h]; cases x with simp [zero_le] | succ x => ?_)\n  | base y k h =>\n    simp [eq_false (not_succ_le_zero x), succ_mul, Nat.add_comm]\n    refine Nat.lt_of_lt_of_le ?_ (Nat.le_add_right _ _)\n    exact not_le.1 fun h' => h ⟨k0, h'⟩\n  | ind y k h IH =>\n    rw [← add_one, Nat.add_le_add_iff_le_right, IH k0, succ_mul,\n        ← Nat.add_sub_cancel (x*k) k, Nat.sub_le_sub_right_iff h.2, Nat.add_sub_cancel]; sorry",
  "name": "le_div_iff_mul_le",
  "kind": "lemma",
  "first-tactic":
  "induction y, k using mod.inductionOn generalizing x with\n    (rw [div_eq]; simp [h]; cases x with simp [zero_le] | succ x => ?_)\n  | base y k h =>\n    simp [eq_false (not_succ_le_zero x), succ_mul, Nat.add_comm]\n    refine Nat.lt_of_lt_of_le ?_ (Nat.le_add_right _ _)\n    exact not_le.1 fun h' => h ⟨k0, h'⟩\n  | ind y k h IH =>\n    rw [← add_one, Nat.add_le_add_iff_le_right, IH k0, succ_mul,\n        ← Nat.add_sub_cancel (x*k) k, Nat.sub_le_sub_right_iff h.2, Nat.add_sub_cancel]",
  "core-prompt": "(k0 : 0 < k) : x ≤ y / k ↔ x * k ≤ y",
  "args": "(k0 : 0 < k)"},
 {"type": "a / b = (a - b) / b + 1",
  "tactic-prompt":
  "lemma (h₁ : 0 < b)  (h₂ : b ≤ a) : a / b = (a - b) / b + 1 := by rw [div_eq a, if_pos]; sorry",
  "name": "div_eq_sub_div",
  "kind": "lemma",
  "first-tactic": "rw [div_eq a, if_pos]",
  "core-prompt": "(h₁ : 0 < b)  (h₂ : b ≤ a) : a / b = (a - b) / b + 1",
  "args": "(h₁ : 0 < b)  (h₂ : b ≤ a)"},
 {"type": "a / b = 0",
  "tactic-prompt":
  "lemma (h₀ : a < b) : a / b = 0 := by rw [div_eq a, if_neg]; sorry",
  "name": "div_eq_of_lt",
  "kind": "lemma",
  "first-tactic": "rw [div_eq a, if_neg]",
  "core-prompt": "(h₀ : a < b) : a / b = 0",
  "args": "(h₀ : a < b)"},
 {"type": "x / k < y ↔ x < y * k",
  "tactic-prompt":
  "lemma (Hk : 0 < k) : x / k < y ↔ x < y * k := by rw [← not_le, ← not_le]; sorry",
  "name": "div_lt_iff_lt_mul",
  "kind": "lemma",
  "first-tactic": "rw [← not_le, ← not_le]",
  "core-prompt": "(Hk : 0 < k) : x / k < y ↔ x < y * k",
  "args": "(Hk : 0 < k)"},
 {"type": "n = 0 ∨ n = succ (pred n)",
  "tactic-prompt":
  "lemma (n : ℕ) : n = 0 ∨ n = succ (pred n) := by cases n <;> simp; sorry",
  "name": "eq_zero_or_eq_succ_pred",
  "kind": "lemma",
  "first-tactic": "cases n <;> simp",
  "core-prompt": "(n : ℕ) : n = 0 ∨ n = succ (pred n)",
  "args": "(n : ℕ)"},
 {"type": "succ n + m = n + succ m",
  "tactic-prompt":
  "theorem (n m : ℕ) : succ n + m = n + succ m := by simp [succ_add, add_succ]; sorry",
  "name": "succ_add_eq_succ_add",
  "kind": "theorem",
  "first-tactic": "simp [succ_add, add_succ]",
  "core-prompt": "(n m : ℕ) : succ n + m = n + succ m",
  "args": "(n m : ℕ)"},
 {"type": "1 + n = succ n",
  "tactic-prompt":
  "theorem (n : ℕ) : 1 + n = succ n := by simp [Nat.add_comm]; sorry",
  "name": "one_add",
  "kind": "theorem",
  "first-tactic": "simp [Nat.add_comm]",
  "core-prompt": "(n : ℕ) : 1 + n = succ n",
  "args": "(n : ℕ)"},
 {"type": "a - b + b = max a b",
  "tactic-prompt":
  "lemma {a b : Nat} : a - b + b = max a b := by cases (@le_total Nat Nat.instLinearOrderNat a b); sorry",
  "name": "sub_add_eq_max",
  "kind": "lemma",
  "first-tactic": "cases (@le_total Nat Nat.instLinearOrderNat a b)",
  "core-prompt": "{a b : Nat} : a - b + b = max a b",
  "args": "{a b : Nat}"},
 {"type": "succ n - m - succ k = n - m - k",
  "tactic-prompt":
  "theorem (n m k : ℕ) : succ n - m - succ k = n - m - k := by rw [Nat.sub_sub, Nat.sub_sub, add_succ, succ_sub_succ]; sorry",
  "name": "succ_sub_sub_succ",
  "kind": "theorem",
  "first-tactic": "rw [Nat.sub_sub, Nat.sub_sub, add_succ, succ_sub_succ]",
  "core-prompt": "(n m k : ℕ) : succ n - m - succ k = n - m - k",
  "args": "(n m k : ℕ)"},
 {"type": "m - n - k = m - k - n",
  "tactic-prompt":
  "lemma (m n k : ℕ) : m - n - k = m - k - n := by rw [Nat.sub_sub, Nat.sub_sub, Nat.add_comm]; sorry",
  "name": "sub.right_comm",
  "kind": "lemma",
  "first-tactic": "rw [Nat.sub_sub, Nat.sub_sub, Nat.add_comm]",
  "core-prompt": "(m n k : ℕ) : m - n - k = m - k - n",
  "args": "(m n k : ℕ)"},
 {"type": "a * a - b * b = (a + b) * (a - b)",
  "tactic-prompt":
  "lemma (a b : Nat) : a * a - b * b = (a + b) * (a - b) := by rw [Nat.mul_sub_left_distrib, Nat.right_distrib, Nat.right_distrib, Nat.mul_comm b a, Nat.add_comm (a*a) (a*b),\n       Nat.add_sub_add_left]; sorry",
  "name": "mul_self_sub_mul_self_eq",
  "kind": "lemma",
  "first-tactic":
  "rw [Nat.mul_sub_left_distrib, Nat.right_distrib, Nat.right_distrib, Nat.mul_comm b a, Nat.add_comm (a*a) (a*b),\n       Nat.add_sub_add_left]",
  "core-prompt": "(a b : Nat) : a * a - b * b = (a + b) * (a - b)",
  "args": "(a b : Nat)"},
 {"type": "succ a * succ b = a*b + a + b + 1",
  "tactic-prompt":
  "lemma (a b : Nat) : succ a * succ b = a*b + a + b + 1 := by rw [mul_succ, succ_mul, Nat.add_right_comm _ a]; sorry",
  "name": "succ_mul_succ_eq",
  "kind": "lemma",
  "first-tactic": "rw [mul_succ, succ_mul, Nat.add_right_comm _ a]",
  "core-prompt": "(a b : Nat) : succ a * succ b = a*b + a + b + 1",
  "args": "(a b : Nat)"},
 {"type": "0 < n - m",
  "tactic-prompt":
  "lemma (h : m < n) : 0 < n - m := by apply Nat.lt_of_add_lt_add_right (b := m); sorry",
  "name": "sub_pos_of_lt",
  "kind": "lemma",
  "first-tactic": "apply Nat.lt_of_add_lt_add_right (b := m)",
  "core-prompt": "(h : m < n) : 0 < n - m",
  "args": "(h : m < n)"},
 {"type": "n - 1 - i < n",
  "tactic-prompt":
  "lemma (h : i < n) : n - 1 - i < n := by rw [Nat.sub_sub]; sorry",
  "name": "sub_one_sub_lt",
  "kind": "lemma",
  "first-tactic": "rw [Nat.sub_sub]",
  "core-prompt": "(h : i < n) : n - 1 - i < n",
  "args": "(h : i < n)"},
 {"type": "WellFounded (lbp p)",
  "tactic-prompt":
  "def (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) : WellFounded (lbp p) := by refine ⟨let ⟨n, pn⟩ := H; ?_⟩; sorry",
  "name": "wf_lbp",
  "kind": "def",
  "first-tactic": "refine ⟨let ⟨n, pn⟩ := H; ?_⟩",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) : WellFounded (lbp p)",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n)"},
 {"type": "(x + z) % z = x % z",
  "tactic-prompt":
  "theorem (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x z : ℕ) : (x + z) % z = x % z := by rw [mod_eq_sub_mod (Nat.le_add_left _ _), Nat.add_sub_cancel]; sorry",
  "name": "add_mod_right",
  "kind": "theorem",
  "first-tactic":
  "rw [mod_eq_sub_mod (Nat.le_add_left _ _), Nat.add_sub_cancel]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x z : ℕ) : (x + z) % z = x % z",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x z : ℕ)"},
 {"type": "(x + z) % x = z % x",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x z : ℕ) : (x + z) % x = z % x := by rw [Nat.add_comm, add_mod_right]; sorry",
  "name": "add_mod_left",
  "kind": "lemma",
  "first-tactic": "rw [Nat.add_comm, add_mod_right]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x z : ℕ) : (x + z) % x = z % x",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x z : ℕ)"},
 {"type": "(x + y * z) % y = x % y",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x y z : ℕ) : (x + y * z) % y = x % y := by induction z; sorry",
  "name": "add_mul_mod_self_left",
  "kind": "lemma",
  "first-tactic": "induction z",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x y z : ℕ) : (x + y * z) % y = x % y",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x y z : ℕ)"},
 {"type": "(x + y * z) % z = x % z",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x y z : ℕ) : (x + y * z) % z = x % z := by rw [Nat.mul_comm, add_mul_mod_self_left]; sorry",
  "name": "add_mul_mod_self_right",
  "kind": "lemma",
  "first-tactic": "rw [Nat.mul_comm, add_mul_mod_self_left]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x y z : ℕ) : (x + y * z) % z = x % z",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x y z : ℕ)"},
 {"type": "(m * n) % m = 0",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m n : ℕ) : (m * n) % m = 0 := by rw [← Nat.zero_add (m*n), add_mul_mod_self_left, zero_mod]; sorry",
  "name": "mul_mod_right",
  "kind": "lemma",
  "first-tactic": "rw [← Nat.zero_add (m*n), add_mul_mod_self_left, zero_mod]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m n : ℕ) : (m * n) % m = 0",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m n : ℕ)"},
 {"type": "(m * n) % n = 0",
  "tactic-prompt":
  "theorem (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m n : ℕ) : (m * n) % n = 0 := by rw [Nat.mul_comm, mul_mod_right]; sorry",
  "name": "mul_mod_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm, mul_mod_right]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m n : ℕ) : (m * n) % n = 0",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m n : ℕ)"},
 {"type": "(x * z) % (y * z) = (x % y) * z",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (z x y : ℕ) : (x * z) % (y * z) = (x % y) * z := by rw [Nat.mul_comm x z, Nat.mul_comm y z, Nat.mul_comm (x % y) z]; sorry",
  "name": "mul_mod_mul_right",
  "kind": "lemma",
  "first-tactic":
  "rw [Nat.mul_comm x z, Nat.mul_comm y z, Nat.mul_comm (x % y) z]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (z x y : ℕ) : (x * z) % (y * z) = (x % y) * z",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (z x y : ℕ)"},
 {"type": "(x - n*k) % n = x % n",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x k n : ℕ)  (h₁ : n*k ≤ x) : (x - n*k) % n = x % n := by induction k; sorry",
  "name": "sub_mul_mod",
  "kind": "lemma",
  "first-tactic": "induction k",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x k n : ℕ)  (h₁ : n*k ≤ x) : (x - n*k) % n = x % n",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x k n : ℕ)  (h₁ : n*k ≤ x)"},
 {"type": "(x - n*p) / n = x / n - p",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x n p : ℕ)  (h₁ : n*p ≤ x) : (x - n*p) / n = x / n - p := by cases eq_zero_or_pos n; sorry",
  "name": "sub_mul_div",
  "kind": "lemma",
  "first-tactic": "cases eq_zero_or_pos n",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x n p : ℕ)  (h₁ : n*p ≤ x) : (x - n*p) / n = x / n - p",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x n p : ℕ)  (h₁ : n*p ≤ x)"},
 {"type": "(x + z) / z = succ (x / z)",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x : ℕ)  {z : ℕ}  (H : 0 < z) : (x + z) / z = succ (x / z) := by rw [div_eq_sub_div H (Nat.le_add_left _ _), Nat.add_sub_cancel]; sorry",
  "name": "add_div_right",
  "kind": "lemma",
  "first-tactic":
  "rw [div_eq_sub_div H (Nat.le_add_left _ _), Nat.add_sub_cancel]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x : ℕ)  {z : ℕ}  (H : 0 < z) : (x + z) / z = succ (x / z)",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x : ℕ)  {z : ℕ}  (H : 0 < z)"},
 {"type": "(z + x) / z = succ (x / z)",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x : ℕ)  {z : ℕ}  (H : 0 < z) : (z + x) / z = succ (x / z) := by rw [Nat.add_comm, add_div_right x H]; sorry",
  "name": "add_div_left",
  "kind": "lemma",
  "first-tactic": "rw [Nat.add_comm, add_div_right x H]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x : ℕ)  {z : ℕ}  (H : 0 < z) : (z + x) / z = succ (x / z)",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x : ℕ)  {z : ℕ}  (H : 0 < z)"},
 {"type": "m * n / m = n",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n : ℕ)  {m : ℕ}  (H : 0 < m) : m * n / m = n := by induction n <;> simp_all [mul_succ]; sorry",
  "name": "mul_div_right",
  "kind": "lemma",
  "first-tactic": "induction n <;> simp_all [mul_succ]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n : ℕ)  {m : ℕ}  (H : 0 < m) : m * n / m = n",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n : ℕ)  {m : ℕ}  (H : 0 < m)"},
 {"type": "m * n / n = m",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m : ℕ)  {n : ℕ}  (H : 0 < n) : m * n / n = m := by rw [Nat.mul_comm, mul_div_right _ H]; sorry",
  "name": "mul_div_left",
  "kind": "lemma",
  "first-tactic": "rw [Nat.mul_comm, mul_div_right _ H]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m : ℕ)  {n : ℕ}  (H : 0 < n) : m * n / n = m",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m : ℕ)  {n : ℕ}  (H : 0 < n)"},
 {"type": "(x + y * z) / y = x / y + z",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x z : ℕ)  {y : ℕ}  (H : 0 < y) : (x + y * z) / y = x / y + z := by induction z; sorry",
  "name": "add_mul_div_left",
  "kind": "lemma",
  "first-tactic": "induction z",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x z : ℕ)  {y : ℕ}  (H : 0 < y) : (x + y * z) / y = x / y + z",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x z : ℕ)  {y : ℕ}  (H : 0 < y)"},
 {"type": "(x + y * z) / z = x / z + y",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x y : ℕ)  {z : ℕ}  (H : 0 < z) : (x + y * z) / z = x / z + y := by rw [Nat.mul_comm, add_mul_div_left _ _ H]; sorry",
  "name": "add_mul_div_right",
  "kind": "lemma",
  "first-tactic": "rw [Nat.mul_comm, add_mul_div_left _ _ H]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x y : ℕ)  {z : ℕ}  (H : 0 < z) : (x + y * z) / z = x / z + y",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x y : ℕ)  {z : ℕ}  (H : 0 < z)"},
 {"type": "n * m / n = m",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m : ℕ)  {n : ℕ}  (H : 0 < n) : n * m / n = m := by rw [Nat.mul_comm, Nat.mul_div_cancel _ H]; sorry",
  "name": "mul_div_cancel_left",
  "kind": "lemma",
  "first-tactic": "rw [Nat.mul_comm, Nat.mul_div_cancel _ H]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m : ℕ)  {n : ℕ}  (H : 0 < n) : n * m / n = m",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m : ℕ)  {n : ℕ}  (H : 0 < n)"},
 {"type": "m / n = k",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (H1 : 0 < n)  (H2 : m = k * n) : m / n = k := by rw [H2, Nat.mul_div_cancel _ H1]; sorry",
  "name": "div_eq_of_eq_mul_left",
  "kind": "lemma",
  "first-tactic": "rw [H2, Nat.mul_div_cancel _ H1]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (H1 : 0 < n)  (H2 : m = k * n) : m / n = k",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (H1 : 0 < n)  (H2 : m = k * n)"},
 {"type": "m / n = k",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (H1 : 0 < n)  (H2 : m = n * k) : m / n = k := by rw [H2, Nat.mul_div_cancel_left _ H1]; sorry",
  "name": "div_eq_of_eq_mul_right",
  "kind": "lemma",
  "first-tactic": "rw [H2, Nat.mul_div_cancel_left _ H1]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (H1 : 0 < n)  (H2 : m = n * k) : m / n = k",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (H1 : 0 < n)  (H2 : m = n * k)"},
 {"type": "(n * p - succ x) / n = p - succ (x / n)",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x n p : ℕ)  (h₁ : x < n*p) : (n * p - succ x) / n = p - succ (x / n) := by have npos : 0 < n := (eq_zero_or_pos _).resolve_left fun n0 => by\n    rw [n0, Nat.zero_mul] at h₁; exact not_lt_zero _ h₁; sorry",
  "name": "mul_sub_div",
  "kind": "lemma",
  "first-tactic":
  "have npos : 0 < n := (eq_zero_or_pos _).resolve_left fun n0 => by\n    rw [n0, Nat.zero_mul] at h₁; exact not_lt_zero _ h₁",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x n p : ℕ)  (h₁ : x < n*p) : (n * p - succ x) / n = p - succ (x / n)",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (x n p : ℕ)  (h₁ : x < n*p)"},
 {"type": "m / n / k = m / (n * k)",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m n k : ℕ) : m / n / k = m / (n * k) := by cases eq_zero_or_pos k; sorry",
  "name": "div_div_eq_div_mul",
  "kind": "lemma",
  "first-tactic": "cases eq_zero_or_pos k",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m n k : ℕ) : m / n / k = m / (n * k)",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m n k : ℕ)"},
 {"type": "m * n / (m * k) = n / k",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m : ℕ}  (n k : ℕ)  (H : 0 < m) : m * n / (m * k) = n / k := by rw [← Nat.div_div_eq_div_mul, Nat.mul_div_cancel_left _ H]\n\n/- dvd -/; sorry",
  "name": "mul_div_mul",
  "kind": "lemma",
  "first-tactic":
  "rw [← Nat.div_div_eq_div_mul, Nat.mul_div_cancel_left _ H]\n\n/- dvd -/",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m : ℕ}  (n k : ℕ)  (H : 0 < m) : m * n / (m * k) = n / k",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m : ℕ}  (n k : ℕ)  (H : 0 < m)"},
 {"type": "k ∣ m ↔ k ∣ m + n",
  "tactic-prompt":
  "theorem (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {k m n : ℕ}  (h : k ∣ n) : k ∣ m ↔ k ∣ m + n := by rw [Nat.add_comm]; sorry",
  "name": "dvd_add_iff_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {k m n : ℕ}  (h : k ∣ n) : k ∣ m ↔ k ∣ m + n",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {k m n : ℕ}  (h : k ∣ n)"},
 {"type": "m ∣ n",
  "tactic-prompt":
  "theorem (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m n : ℕ}  (H : n % m = 0) : m ∣ n := by refine ⟨n / m, ?_⟩; sorry",
  "name": "dvd_of_mod_eq_zero",
  "kind": "theorem",
  "first-tactic": "refine ⟨n / m, ?_⟩",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m n : ℕ}  (H : n % m = 0) : m ∣ n",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m n : ℕ}  (H : n % m = 0)"},
 {"type": "n * (m / n) = m",
  "tactic-prompt":
  "theorem (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m n : ℕ}  (H : n ∣ m) : n * (m / n) = m := by let t := mod_add_div m n; sorry",
  "name": "mul_div_cancel'",
  "kind": "theorem",
  "first-tactic": "let t := mod_add_div m n",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m n : ℕ}  (H : n ∣ m) : n * (m / n) = m",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m n : ℕ}  (H : n ∣ m)"},
 {"type": "m / n * n = m",
  "tactic-prompt":
  "theorem (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m n : ℕ}  (H: n ∣ m) : m / n * n = m := by rw [Nat.mul_comm, Nat.mul_div_cancel' H]; sorry",
  "name": "div_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm, Nat.mul_div_cancel' H]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m n : ℕ}  (H: n ∣ m) : m / n * n = m",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m n : ℕ}  (H: n ∣ m)"},
 {"type": "m ∣ n",
  "tactic-prompt":
  "theorem (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m n k : ℕ}  (kpos : 0 < k)  (H : m * k ∣ n * k) : m ∣ n := by rw [Nat.mul_comm m k, Nat.mul_comm n k] at H; sorry",
  "name": "dvd_of_mul_dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm m k, Nat.mul_comm n k] at H",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m n k : ℕ}  (kpos : 0 < k)  (H : m * k ∣ n * k) : m ∣ n",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m n k : ℕ}  (kpos : 0 < k)  (H : m * k ∣ n * k)"},
 {"type": "c * a ≤ c * b",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {a b c : ℕ}  (h₁ : a ≤ b) : c * a ≤ c * b := by by_cases hba: b ≤ a; sorry",
  "name": "mul_le_mul_of_nonneg_left",
  "kind": "lemma",
  "first-tactic": "by_cases hba: b ≤ a",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {a b c : ℕ}  (h₁ : a ≤ b) : c * a ≤ c * b",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {a b c : ℕ}  (h₁ : a ≤ b)"},
 {"type": "a * c ≤ b * c",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {a b c : ℕ}  (h₁ : a ≤ b) : a * c ≤ b * c := by by_cases hba : b ≤ a; sorry",
  "name": "mul_le_mul_of_nonneg_right",
  "kind": "lemma",
  "first-tactic": "by_cases hba : b ≤ a",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {a b c : ℕ}  (h₁ : a ≤ b) : a * c ≤ b * c",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {a b c : ℕ}  (h₁ : a ≤ b)"},
 {"type": "(a * b) % n = ((a % n) * (b % n)) % n",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (a b n : ℕ) : (a * b) % n = ((a % n) * (b % n)) % n := by let hy := (a * b) % n; sorry",
  "name": "mul_mod",
  "kind": "lemma",
  "first-tactic": "let hy := (a * b) % n",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (a b n : ℕ) : (a * b) % n = ((a % n) * (b % n)) % n",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (a b n : ℕ)"},
 {"type": "(m % n + k) % n = (m + k) % n",
  "tactic-prompt":
  "theorem (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m n k : ℕ) : (m % n + k) % n = (m + k) % n := by have := (add_mul_mod_self_left (m % n + k) n (m / n)).symm; sorry",
  "name": "mod_add_mod",
  "kind": "theorem",
  "first-tactic": "have := (add_mul_mod_self_left (m % n + k) n (m / n)).symm",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m n k : ℕ) : (m % n + k) % n = (m + k) % n",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m n k : ℕ)"},
 {"type": "(m + n % k) % k = (m + n) % k",
  "tactic-prompt":
  "theorem (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m n k : ℕ) : (m + n % k) % k = (m + n) % k := by rw [Nat.add_comm, mod_add_mod, Nat.add_comm]; sorry",
  "name": "add_mod_mod",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm, mod_add_mod, Nat.add_comm]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m n k : ℕ) : (m + n % k) % k = (m + n) % k",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (m n k : ℕ)"},
 {"type": "(a + b) % n = ((a % n) + (b % n)) % n",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (a b n : ℕ) : (a + b) % n = ((a % n) + (b % n)) % n := by rw [add_mod_mod, mod_add_mod]; sorry",
  "name": "add_mod",
  "kind": "lemma",
  "first-tactic": "rw [add_mod_mod, mod_add_mod]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (a b n : ℕ) : (a + b) % n = ((a % n) + (b % n)) % n",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (a b n : ℕ)"},
 {"type":
  "∀ (n : Nat) (l1 l2 : List Char), l1.length = l2.length →\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat) : ∀ (n : Nat) (l1 l2 : List Char), l1.length = l2.length →\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length := by induction f; sorry",
  "name": "to_digits_core_lens_eq_aux",
  "kind": "lemma",
  "first-tactic": "induction f",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat) : ∀ (n : Nat) (l1 l2 : List Char), l1.length = l2.length →\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat)"},
 {"type":
  "∀ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat) : ∀ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1 := by induction f; sorry",
  "name": "to_digits_core_lens_eq",
  "kind": "lemma",
  "first-tactic": "induction f",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat) : ∀ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (b f : Nat)"},
 {"type": "n < b ^ e.succ → n / b < b ^ e",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n b e : Nat)  (h_b_pos : 0 < b) : n < b ^ e.succ → n / b < b ^ e := by simp only [Nat.pow_succ]; sorry",
  "name": "nat_repr_len_aux",
  "kind": "lemma",
  "first-tactic": "simp only [Nat.pow_succ]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n b e : Nat)  (h_b_pos : 0 < b) : n < b ^ e.succ → n / b < b ^ e",
  "args":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n b e : Nat)  (h_b_pos : 0 < b)"},
 {"type": "0 < e → n < 10 ^ e → (Nat.repr n).length <= e",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n e : Nat) : 0 < e → n < 10 ^ e → (Nat.repr n).length <= e := by cases n; sorry",
  "name": "repr_length",
  "kind": "lemma",
  "first-tactic": "cases n",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n e : Nat) : 0 < e → n < 10 ^ e → (Nat.repr n).length <= e",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) (n e : Nat)"},
 {"type": "m ^ n.succ = m * m ^ n",
  "tactic-prompt":
  "lemma (p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m n : Nat} : m ^ n.succ = m * m ^ n := by rw [Nat.pow_succ, Nat.mul_comm]; sorry",
  "name": "pow_succ'",
  "kind": "lemma",
  "first-tactic": "rw [Nat.pow_succ, Nat.mul_comm]",
  "core-prompt":
  "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m n : Nat} : m ^ n.succ = m * m ^ n",
  "args": "(p : ℕ → Prop) [DecidablePred p]  (H : ∃ n, p n) {m n : Nat}"},
 {"type": "subNatNat m n = ofNat (m - n)",
  "tactic-prompt":
  "lemma {m n : ℕ}  (h : n - m = 0) : subNatNat m n = ofNat (m - n) := by show (match (n - m) with -- No `unfold` so I do this\n  | 0 => ofNat (m-n)\n  | succ k => -[1+ k]\n  ) = ofNat (m - n); sorry",
  "name": "subNatNat_of_sub_eq_zero",
  "kind": "lemma",
  "first-tactic":
  "show (match (n - m) with -- No `unfold` so I do this\n  | 0 => ofNat (m-n)\n  | succ k => -[1+ k]\n  ) = ofNat (m - n)",
  "core-prompt": "{m n : ℕ}  (h : n - m = 0) : subNatNat m n = ofNat (m - n)",
  "args": "{m n : ℕ}  (h : n - m = 0)"},
 {"type": "subNatNat m n = -[1+ k]",
  "tactic-prompt":
  "lemma {m n k : ℕ}  (h : n - m = succ k) : subNatNat m n = -[1+ k] := by show (match n - m with\n  | 0 => ofNat (m - n)\n  | succ k => -[1+ k]) =\n  -[1+ k]; sorry",
  "name": "subNatNat_of_sub_eq_succ",
  "kind": "lemma",
  "first-tactic":
  "show (match n - m with\n  | 0 => ofNat (m - n)\n  | succ k => -[1+ k]) =\n  -[1+ k]",
  "core-prompt": "{m n k : ℕ}  (h : n - m = succ k) : subNatNat m n = -[1+ k]",
  "args": "{m n k : ℕ}  (h : n - m = succ k)"},
 {"type": "a = b",
  "tactic-prompt":
  "lemma {a b : ℤ}  (h : -a = -b) : a = b := by rw [← Int.neg_neg a, ← Int.neg_neg b, h]; sorry",
  "name": "neg_inj",
  "kind": "lemma",
  "first-tactic": "rw [← Int.neg_neg a, ← Int.neg_neg b, h]",
  "core-prompt": "{a b : ℤ}  (h : -a = -b) : a = b",
  "args": "{a b : ℤ}  (h : -a = -b)"},
 {"type": "P m n (subNatNat m n)",
  "tactic-prompt":
  "lemma (m n : ℕ)  (P : ℕ → ℕ → ℤ → Prop)    (hp : ∀i n, P (n + i) n (ofNat i))    (hn : ∀i m, P m (m + i + 1) (-[1+ i])) : P m n (subNatNat m n) := by have H : ∀ k , n - m = k → P m n (match n - m with | 0 => ofNat (m - n) | succ k => -[1+ k] : ℤ) := by\n    intros k h\n    cases k with\n    | zero =>\n        have ⟨k, h⟩ := (Nat.le.dest (Nat.le_of_sub_eq_zero h))\n        rw [h.symm, Nat.add_sub_cancel_left, Nat.sub_self_add]\n        apply hp\n    | succ k =>\n        simp\n        have hle : m ≤ n := Nat.le_of_lt (Nat.lt_of_sub_eq_succ h)\n        rw [Nat.sub_eq_iff_eq_add hle] at h\n        rw [h, Nat.add_comm, Nat.add_sub_cancel_left]\n        apply hn; sorry",
  "name": "subNatNat_elim",
  "kind": "lemma",
  "first-tactic":
  "have H : ∀ k , n - m = k → P m n (match n - m with | 0 => ofNat (m - n) | succ k => -[1+ k] : ℤ) := by\n    intros k h\n    cases k with\n    | zero =>\n        have ⟨k, h⟩ := (Nat.le.dest (Nat.le_of_sub_eq_zero h))\n        rw [h.symm, Nat.add_sub_cancel_left, Nat.sub_self_add]\n        apply hp\n    | succ k =>\n        simp\n        have hle : m ≤ n := Nat.le_of_lt (Nat.lt_of_sub_eq_succ h)\n        rw [Nat.sub_eq_iff_eq_add hle] at h\n        rw [h, Nat.add_comm, Nat.add_sub_cancel_left]\n        apply hn",
  "core-prompt":
  "(m n : ℕ)  (P : ℕ → ℕ → ℤ → Prop)    (hp : ∀i n, P (n + i) n (ofNat i))    (hn : ∀i m, P m (m + i + 1) (-[1+ i])) : P m n (subNatNat m n)",
  "args":
  "(m n : ℕ)  (P : ℕ → ℕ → ℤ → Prop)    (hp : ∀i n, P (n + i) n (ofNat i))    (hn : ∀i m, P m (m + i + 1) (-[1+ i]))"},
 {"type": "subNatNat (m + n) m = ofNat n",
  "tactic-prompt":
  "lemma {m n : ℕ} : subNatNat (m + n) m = ofNat n := by change (match m - (m + n) with\n          | 0      => ofNat (m + n - m)\n          | succ k => -[1+ k]) = ofNat n; sorry",
  "name": "subNatNat_add_left",
  "kind": "lemma",
  "first-tactic":
  "change (match m - (m + n) with\n          | 0      => ofNat (m + n - m)\n          | succ k => -[1+ k]) = ofNat n",
  "core-prompt": "{m n : ℕ} : subNatNat (m + n) m = ofNat n",
  "args": "{m n : ℕ}"},
 {"type": "subNatNat m (m + n + 1) = negSucc n",
  "tactic-prompt":
  "lemma {m n : ℕ} : subNatNat m (m + n + 1) = negSucc n := by change (match m + n + 1 - m with\n          | 0      => ofNat (m - (m + n + 1))\n          | succ k => -[1+ k]) = negSucc n; sorry",
  "name": "subNatNat_add_right",
  "kind": "lemma",
  "first-tactic":
  "change (match m + n + 1 - m with\n          | 0      => ofNat (m - (m + n + 1))\n          | succ k => -[1+ k]) = negSucc n",
  "core-prompt": "{m n : ℕ} : subNatNat m (m + n + 1) = negSucc n",
  "args": "{m n : ℕ}"},
 {"type": "subNatNat m n = -[1+ pred (n - m)]",
  "tactic-prompt":
  "lemma {m n : ℕ}  (h : m < n) : subNatNat m n = -[1+ pred (n - m)] := by rw [subNatNat_of_sub_eq_succ]; sorry",
  "name": "subNatNat_of_lt",
  "kind": "lemma",
  "first-tactic": "rw [subNatNat_of_sub_eq_succ]",
  "core-prompt": "{m n : ℕ}  (h : m < n) : subNatNat m n = -[1+ pred (n - m)]",
  "args": "{m n : ℕ}  (h : m < n)"},
 {"type": "subNatNat (m - n) k = subNatNat m (k + n)",
  "tactic-prompt":
  "lemma {m n : ℕ}  (h : n ≤ m)  (k : ℕ) : subNatNat (m - n) k = subNatNat m (k + n) := by rwa [← subNatNat_add_add _ _ n, Nat.sub_add_cancel]; sorry",
  "name": "subNatNat_sub",
  "kind": "lemma",
  "first-tactic": "rwa [← subNatNat_add_add _ _ n, Nat.sub_add_cancel]",
  "core-prompt":
  "{m n : ℕ}  (h : n ≤ m)  (k : ℕ) : subNatNat (m - n) k = subNatNat m (k + n)",
  "args": "{m n : ℕ}  (h : n ≤ m)  (k : ℕ)"},
 {"type": "subNatNat (m + n) k = ofNat m + subNatNat n k",
  "tactic-prompt":
  "lemma (m n k : ℕ) : subNatNat (m + n) k = ofNat m + subNatNat n k := by have h := Nat.lt_or_ge n k; sorry",
  "name": "subNatNat_add",
  "kind": "lemma",
  "first-tactic": "have h := Nat.lt_or_ge n k",
  "core-prompt": "(m n k : ℕ) : subNatNat (m + n) k = ofNat m + subNatNat n k",
  "args": "(m n k : ℕ)"},
 {"type": "subNatNat m n + -[1+ k] = subNatNat m (n + succ k)",
  "tactic-prompt":
  "lemma (m n k : ℕ) : subNatNat m n + -[1+ k] = subNatNat m (n + succ k) := by have h := Nat.lt_or_ge m n; sorry",
  "name": "subNatNat_add_negSucc_ofNat",
  "kind": "lemma",
  "first-tactic": "have h := Nat.lt_or_ge m n",
  "core-prompt":
  "(m n k : ℕ) : subNatNat m n + -[1+ k] = subNatNat m (n + succ k)",
  "args": "(m n k : ℕ)"},
 {"type": "-[1+ m] + -[1+ n] + ofNat k = -[1+ m] + (-[1+ n] + ofNat k)",
  "tactic-prompt":
  "lemma (m n k : ℕ) : -[1+ m] + -[1+ n] + ofNat k = -[1+ m] + (-[1+ n] + ofNat k) := by simp [add_succ]; sorry",
  "name": "add_assoc_aux2",
  "kind": "lemma",
  "first-tactic": "simp [add_succ]",
  "core-prompt":
  "(m n k : ℕ) : -[1+ m] + -[1+ n] + ofNat k = -[1+ m] + (-[1+ n] + ofNat k)",
  "args": "(m n k : ℕ)"},
 {"type": "a + -a = 0",
  "tactic-prompt":
  "lemma (a : ℤ) : a + -a = 0 := by rw [Int.add_comm, Int.add_left_neg]\n\n/- ## multiplication -/; sorry",
  "name": "add_right_neg",
  "kind": "lemma",
  "first-tactic":
  "rw [Int.add_comm, Int.add_left_neg]\n\n/- ## multiplication -/",
  "core-prompt": "(a : ℤ) : a + -a = 0",
  "args": "(a : ℤ)"},
 {"type": "negOfNat m * ofNat n = negOfNat (m * n)",
  "tactic-prompt":
  "lemma (m n : ℕ) : negOfNat m * ofNat n = negOfNat (m * n) := by rw [Int.mul_comm]; sorry",
  "name": "negOfNat_mul_ofNat",
  "kind": "lemma",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m n : ℕ) : negOfNat m * ofNat n = negOfNat (m * n)",
  "args": "(m n : ℕ)"},
 {"type": "negOfNat n * -[1+ m] = ofNat (n * succ m)",
  "tactic-prompt":
  "lemma (m n : ℕ) : negOfNat n * -[1+ m] = ofNat (n * succ m) := by rw [Int.mul_comm, negSucc_ofNat_mul_negOfNat, Nat.mul_comm]; sorry",
  "name": "negOfNat_mul_negSucc_ofNat",
  "kind": "lemma",
  "first-tactic": "rw [Int.mul_comm, negSucc_ofNat_mul_negOfNat, Nat.mul_comm]",
  "core-prompt": "(m n : ℕ) : negOfNat n * -[1+ m] = ofNat (n * succ m)",
  "args": "(m n : ℕ)"},
 {"type": "ofNat m * subNatNat n k = subNatNat (m * n) (m * k)",
  "tactic-prompt":
  "lemma (m n k : ℕ) : ofNat m * subNatNat n k = subNatNat (m * n) (m * k) := by cases m; sorry",
  "name": "ofNat_mul_subNatNat",
  "kind": "lemma",
  "first-tactic": "cases m",
  "core-prompt":
  "(m n k : ℕ) : ofNat m * subNatNat n k = subNatNat (m * n) (m * k)",
  "args": "(m n k : ℕ)"},
 {"type": "-[1+ m] * subNatNat n k = subNatNat (succ m * k) (succ m * n)",
  "tactic-prompt":
  "lemma (m n k : ℕ) : -[1+ m] * subNatNat n k = subNatNat (succ m * k) (succ m * n) := by have h := Nat.lt_or_ge n k; sorry",
  "name": "negSucc_ofNat_mul_subNatNat",
  "kind": "lemma",
  "first-tactic": "have h := Nat.lt_or_ge n k",
  "core-prompt":
  "(m n k : ℕ) : -[1+ m] * subNatNat n k = subNatNat (succ m * k) (succ m * n)",
  "args": "(m n k : ℕ)"},
 {"type": "(a + b) * c = a * c + b * c",
  "tactic-prompt":
  "lemma (a b c : ℤ) : (a + b) * c = a * c + b * c := by simp [Int.mul_comm, Int.distrib_left]; sorry",
  "name": "distrib_right",
  "kind": "lemma",
  "first-tactic": "simp [Int.mul_comm, Int.distrib_left]",
  "core-prompt": "(a b c : ℤ) : (a + b) * c = a * c + b * c",
  "args": "(a b c : ℤ)"},
 {"type": "ofNat (n - m) = ofNat n - ofNat m",
  "tactic-prompt":
  "lemma {n m : ℕ}  (h : m ≤ n) : ofNat (n - m) = ofNat n - ofNat m := by show ofNat (n - m) = ofNat n + negOfNat m; sorry",
  "name": "ofNat_sub",
  "kind": "lemma",
  "first-tactic": "show ofNat (n - m) = ofNat n + negOfNat m",
  "core-prompt": "{n m : ℕ}  (h : m ≤ n) : ofNat (n - m) = ofNat n - ofNat m",
  "args": "{n m : ℕ}  (h : m ≤ n)"},
 {"type": "a + (b + c) = b + (a + c)",
  "tactic-prompt":
  "lemma (a b c : ℤ) : a + (b + c) = b + (a + c) := by rw [← Int.add_assoc, Int.add_comm a, Int.add_assoc]; sorry",
  "name": "add_left_comm",
  "kind": "lemma",
  "first-tactic": "rw [← Int.add_assoc, Int.add_comm a, Int.add_assoc]",
  "core-prompt": "(a b c : ℤ) : a + (b + c) = b + (a + c)",
  "args": "(a b c : ℤ)"},
 {"type": "b = c",
  "tactic-prompt":
  "lemma {a b c : ℤ}  (h : a + b = a + c) : b = c := by have h₁ : -a + (a + b) = -a + (a + c) := by rw [h]; sorry",
  "name": "add_left_cancel",
  "kind": "lemma",
  "first-tactic": "have h₁ : -a + (a + b) = -a + (a + c) := by rw [h]",
  "core-prompt": "{a b c : ℤ}  (h : a + b = a + c) : b = c",
  "args": "{a b c : ℤ}  (h : a + b = a + c)"},
 {"type": "- (a + b) = -a + -b",
  "tactic-prompt":
  "lemma {a b : ℤ} : - (a + b) = -a + -b := by have h₁ : - (a + b) = -(a + b) + (a + b) + -a + -b := by\n    rw [Int.add_assoc, Int.add_comm (-a), Int.add_assoc, Int.add_assoc, ← Int.add_assoc b]\n    rw [Int.add_right_neg, Int.zero_add, Int.add_right_neg, Int.add_zero]; sorry",
  "name": "neg_add",
  "kind": "lemma",
  "first-tactic":
  "have h₁ : - (a + b) = -(a + b) + (a + b) + -a + -b := by\n    rw [Int.add_assoc, Int.add_comm (-a), Int.add_assoc, Int.add_assoc, ← Int.add_assoc b]\n    rw [Int.add_right_neg, Int.zero_add, Int.add_right_neg, Int.add_zero]",
  "core-prompt": "{a b : ℤ} : - (a + b) = -a + -b",
  "args": "{a b : ℤ}"},
 {"type": "-[1+ n] = -↑n - 1",
  "tactic-prompt":
  "lemma (n : ℕ) : -[1+ n] = -↑n - 1 := by rw [Int.sub_eq_add_neg, ← Int.neg_add]; sorry",
  "name": "negSucc_ofNat_coe'",
  "kind": "lemma",
  "first-tactic": "rw [Int.sub_eq_add_neg, ← Int.neg_add]",
  "core-prompt": "(n : ℕ) : -[1+ n] = -↑n - 1",
  "args": "(n : ℕ)"},
 {"type": "a * 1 = a",
  "tactic-prompt":
  "lemma (a : ℤ) : a * 1 = a := by rw [Int.mul_comm, Int.one_mul]; sorry",
  "name": "mul_one",
  "kind": "lemma",
  "first-tactic": "rw [Int.mul_comm, Int.one_mul]",
  "core-prompt": "(a : ℤ) : a * 1 = a",
  "args": "(a : ℤ)"},
 {"type": "a ≤ b",
  "tactic-prompt":
  "theorem {a b : ℤ}  (n : ℕ)  (h : b - a = n) : a ≤ b := by simp [le_def, h]; sorry",
  "name": "le.intro_sub",
  "kind": "theorem",
  "first-tactic": "simp [le_def, h]",
  "core-prompt": "{a b : ℤ}  (n : ℕ)  (h : b - a = n) : a ≤ b",
  "args": "{a b : ℤ}  (n : ℕ)  (h : b - a = n)"},
 {"type": "∃ n : ℕ, a = n",
  "tactic-prompt":
  "theorem {a : ℤ}  (h : 0 ≤ a) : ∃ n : ℕ, a = n := by have t := le.dest_sub h; sorry",
  "name": "eq_ofNat_of_zero_le",
  "kind": "theorem",
  "first-tactic": "have t := le.dest_sub h",
  "core-prompt": "{a : ℤ}  (h : 0 ≤ a) : ∃ n : ℕ, a = n",
  "args": "{a : ℤ}  (h : 0 ≤ a)"},
 {"type": "(↑n : ℤ) < ↑m ↔ n < m",
  "tactic-prompt":
  "theorem {n m : ℕ} : (↑n : ℤ) < ↑m ↔ n < m := by rw [lt_iff_add_one_le, ← Nat.cast_succ, ofNat_le]; sorry",
  "name": "ofNat_lt",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_add_one_le, ← Nat.cast_succ, ofNat_le]",
  "core-prompt": "{n m : ℕ} : (↑n : ℤ) < ↑m ↔ n < m",
  "args": "{n m : ℕ}"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h₁ : a ≤ b)  (h₂ : b ≤ a) : a = b := by let ⟨n, hn⟩ := le.dest h₁; sorry",
  "name": "le_antisymm",
  "kind": "theorem",
  "first-tactic": "let ⟨n, hn⟩ := le.dest h₁",
  "core-prompt": "{a b : ℤ}  (h₁ : a ≤ b)  (h₂ : b ≤ a) : a = b",
  "args": "{a b : ℤ}  (h₁ : a ≤ b)  (h₂ : b ≤ a)"},
 {"type": "a < b ↔ a ≤ b ∧ a ≠ b",
  "tactic-prompt":
  "theorem {a b : ℤ} : a < b ↔ a ≤ b ∧ a ≠ b := by refine ⟨fun h => ⟨le_of_lt h, Int.ne_of_lt h⟩, fun ⟨aleb, aneb⟩ => ?_⟩; sorry",
  "name": "lt_iff_le_and_ne",
  "kind": "theorem",
  "first-tactic":
  "refine ⟨fun h => ⟨le_of_lt h, Int.ne_of_lt h⟩, fun ⟨aleb, aneb⟩ => ?_⟩",
  "core-prompt": "{a b : ℤ} : a < b ↔ a ≤ b ∧ a ≠ b",
  "args": "{a b : ℤ}"},
 {"type": "c + a < c + b",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : a < b)  (c : ℤ) : c + a < c + b := by refine Int.lt_iff_le_and_ne.2 ⟨Int.add_le_add_left (le_of_lt h) _, fun heq => ?_⟩; sorry",
  "name": "add_lt_add_left",
  "kind": "theorem",
  "first-tactic":
  "refine Int.lt_iff_le_and_ne.2 ⟨Int.add_le_add_left (le_of_lt h) _, fun heq => ?_⟩",
  "core-prompt": "{a b : ℤ}  (h : a < b)  (c : ℤ) : c + a < c + b",
  "args": "{a b : ℤ}  (h : a < b)  (c : ℤ)"},
 {"type": "0 ≤ a * b",
  "tactic-prompt":
  "theorem {a b : ℤ}  (ha : 0 ≤ a)  (hb : 0 ≤ b) : 0 ≤ a * b := by let ⟨n, hn⟩ := eq_ofNat_of_zero_le ha; sorry",
  "name": "mul_nonneg",
  "kind": "theorem",
  "first-tactic": "let ⟨n, hn⟩ := eq_ofNat_of_zero_le ha",
  "core-prompt": "{a b : ℤ}  (ha : 0 ≤ a)  (hb : 0 ≤ b) : 0 ≤ a * b",
  "args": "{a b : ℤ}  (ha : 0 ≤ a)  (hb : 0 ≤ b)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "theorem {a b : ℤ}  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b := by let ⟨n, hn⟩ := eq_succ_of_zero_lt ha; sorry",
  "name": "mul_pos",
  "kind": "theorem",
  "first-tactic": "let ⟨n, hn⟩ := eq_succ_of_zero_lt ha",
  "core-prompt": "{a b : ℤ}  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b",
  "args": "{a b : ℤ}  (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "tactic-prompt":
  "theorem {a b : ℤ} : a < b ↔ a ≤ b ∧ ¬b ≤ a := by rw [Int.lt_iff_le_and_ne]; sorry",
  "name": "lt_iff_le_not_le",
  "kind": "theorem",
  "first-tactic": "rw [Int.lt_iff_le_and_ne]",
  "core-prompt": "{a b : ℤ} : a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "args": "{a b : ℤ}"},
 {"type": "a = natAbs a",
  "tactic-prompt":
  "theorem {a : ℤ}  (h : 0 ≤ a) : a = natAbs a := by let ⟨n, e⟩ := eq_ofNat_of_zero_le h; sorry",
  "name": "eq_natAbs_of_zero_le",
  "kind": "theorem",
  "first-tactic": "let ⟨n, e⟩ := eq_ofNat_of_zero_le h",
  "core-prompt": "{a : ℤ}  (h : 0 ≤ a) : a = natAbs a",
  "args": "{a : ℤ}  (h : 0 ≤ a)"},
 {"type": "b = -a",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : a = -b) : b = -a := by rw [h, Int.neg_neg]; sorry",
  "name": "eq_neg_of_eq_neg",
  "kind": "theorem",
  "first-tactic": "rw [h, Int.neg_neg]",
  "core-prompt": "{a b : ℤ}  (h : a = -b) : b = -a",
  "args": "{a b : ℤ}  (h : a = -b)"},
 {"type": "-a + (a + b) = b",
  "tactic-prompt":
  "theorem (a b : ℤ) : -a + (a + b) = b := by rw [← Int.add_assoc, Int.add_left_neg, Int.zero_add]; sorry",
  "name": "neg_add_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_assoc, Int.add_left_neg, Int.zero_add]",
  "core-prompt": "(a b : ℤ) : -a + (a + b) = b",
  "args": "(a b : ℤ)"},
 {"type": "a + (-a + b) = b",
  "tactic-prompt":
  "theorem (a b : ℤ) : a + (-a + b) = b := by rw [← Int.add_assoc, Int.add_right_neg, Int.zero_add]; sorry",
  "name": "add_neg_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← Int.add_assoc, Int.add_right_neg, Int.zero_add]",
  "core-prompt": "(a b : ℤ) : a + (-a + b) = b",
  "args": "(a b : ℤ)"},
 {"type": "a + b + -b = a",
  "tactic-prompt":
  "theorem (a b : ℤ) : a + b + -b = a := by rw [Int.add_assoc, Int.add_right_neg, Int.add_zero]; sorry",
  "name": "add_neg_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_assoc, Int.add_right_neg, Int.add_zero]",
  "core-prompt": "(a b : ℤ) : a + b + -b = a",
  "args": "(a b : ℤ)"},
 {"type": "a + -b + b = a",
  "tactic-prompt":
  "theorem (a b : ℤ) : a + -b + b = a := by rw [Int.add_assoc, Int.add_left_neg, Int.add_zero]; sorry",
  "name": "neg_add_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_assoc, Int.add_left_neg, Int.add_zero]",
  "core-prompt": "(a b : ℤ) : a + -b + b = a",
  "args": "(a b : ℤ)"},
 {"type": "a - a = 0",
  "tactic-prompt":
  "theorem (a : ℤ) : a - a = 0 := by rw [Int.sub_eq_add_neg, Int.add_right_neg]; sorry",
  "name": "sub_self",
  "kind": "theorem",
  "first-tactic": "rw [Int.sub_eq_add_neg, Int.add_right_neg]",
  "core-prompt": "(a : ℤ) : a - a = 0",
  "args": "(a : ℤ)"},
 {"type": "a - b = 0",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : a = b) : a - b = 0 := by rw [h, Int.sub_self]; sorry",
  "name": "sub_eq_zero_of_eq",
  "kind": "theorem",
  "first-tactic": "rw [h, Int.sub_self]",
  "core-prompt": "{a b : ℤ}  (h : a = b) : a - b = 0",
  "args": "{a b : ℤ}  (h : a = b)"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : a - b = 0) : a = b := by have : 0 + b = b := by rw [Int.zero_add]; sorry",
  "name": "eq_of_sub_eq_zero",
  "kind": "theorem",
  "first-tactic": "have : 0 + b = b := by rw [Int.zero_add]",
  "core-prompt": "{a b : ℤ}  (h : a - b = 0) : a = b",
  "args": "{a b : ℤ}  (h : a - b = 0)"},
 {"type": "-a = b",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : a + b = 0) : -a = b := by rw [← Int.add_zero (-a), ← h, ← Int.add_assoc, Int.add_left_neg, Int.zero_add]; sorry",
  "name": "neg_eq_of_add_eq_zero",
  "kind": "theorem",
  "first-tactic":
  "rw [← Int.add_zero (-a), ← h, ← Int.add_assoc, Int.add_left_neg, Int.zero_add]",
  "core-prompt": "{a b : ℤ}  (h : a + b = 0) : -a = b",
  "args": "{a b : ℤ}  (h : a + b = 0)"},
 {"type": "-a * -b = a * b",
  "tactic-prompt": "theorem (a b : ℤ) : -a * -b = a * b := by simp; sorry",
  "name": "neg_mul_neg",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : ℤ) : -a * -b = a * b",
  "args": "(a b : ℤ)"},
 {"type": "-a * b = a * -b",
  "tactic-prompt": "theorem (a b : ℤ) : -a * b = a * -b := by simp; sorry",
  "name": "neg_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : ℤ) : -a * b = a * -b",
  "args": "(a b : ℤ)"},
 {"type": "b ≤ c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a + b ≤ a + c) : b ≤ c := by have : -a + (a + b) ≤ -a + (a + c) := Int.add_le_add_left h _; sorry",
  "name": "le_of_add_le_add_left",
  "kind": "theorem",
  "first-tactic":
  "have : -a + (a + b) ≤ -a + (a + c) := Int.add_le_add_left h _",
  "core-prompt": "{a b c : ℤ}  (h : a + b ≤ a + c) : b ≤ c",
  "args": "{a b c : ℤ}  (h : a + b ≤ a + c)"},
 {"type": "b < c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a + b < a + c) : b < c := by have : -a + (a + b) < -a + (a + c) := Int.add_lt_add_left h _; sorry",
  "name": "lt_of_add_lt_add_left",
  "kind": "theorem",
  "first-tactic":
  "have : -a + (a + b) < -a + (a + c) := Int.add_lt_add_left h _",
  "core-prompt": "{a b c : ℤ}  (h : a + b < a + c) : b < c",
  "args": "{a b c : ℤ}  (h : a + b < a + c)"},
 {"type": "a + c < b + c",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : a < b)  (c : ℤ) : a + c < b + c := by rw [Int.add_comm a c, Int.add_comm b c]; sorry",
  "name": "add_lt_add_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm a c, Int.add_comm b c]",
  "core-prompt": "{a b : ℤ}  (h : a < b)  (c : ℤ) : a + c < b + c",
  "args": "{a b : ℤ}  (h : a < b)  (c : ℤ)"},
 {"type": "a ≤ a + b",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : 0 ≤ b) : a ≤ a + b := by have : a + b ≥ a + 0 := Int.add_le_add_left h a; sorry",
  "name": "le_add_of_nonneg_right",
  "kind": "theorem",
  "first-tactic": "have : a + b ≥ a + 0 := Int.add_le_add_left h a",
  "core-prompt": "{a b : ℤ}  (h : 0 ≤ b) : a ≤ a + b",
  "args": "{a b : ℤ}  (h : 0 ≤ b)"},
 {"type": "a ≤ b + a",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : 0 ≤ b) : a ≤ b + a := by have : 0 + a ≤ b + a := Int.add_le_add_right h a; sorry",
  "name": "le_add_of_nonneg_left",
  "kind": "theorem",
  "first-tactic": "have : 0 + a ≤ b + a := Int.add_le_add_right h a",
  "core-prompt": "{a b : ℤ}  (h : 0 ≤ b) : a ≤ b + a",
  "args": "{a b : ℤ}  (h : 0 ≤ b)"},
 {"type": "a < a + b",
  "tactic-prompt":
  "theorem (a : ℤ)  {b : ℤ}  (h : 0 < b) : a < a + b := by have : a + 0 < a + b := Int.add_lt_add_left h a; sorry",
  "name": "lt_add_of_pos_right",
  "kind": "theorem",
  "first-tactic": "have : a + 0 < a + b := Int.add_lt_add_left h a",
  "core-prompt": "(a : ℤ)  {b : ℤ}  (h : 0 < b) : a < a + b",
  "args": "(a : ℤ)  {b : ℤ}  (h : 0 < b)"},
 {"type": "a < b + a",
  "tactic-prompt":
  "theorem (a : ℤ)  {b : ℤ}  (h : 0 < b) : a < b + a := by have : 0 + a < b + a := Int.add_lt_add_right h a; sorry",
  "name": "lt_add_of_pos_left",
  "kind": "theorem",
  "first-tactic": "have : 0 + a < b + a := Int.add_lt_add_right h a",
  "core-prompt": "(a : ℤ)  {b : ℤ}  (h : 0 < b) : a < b + a",
  "args": "(a : ℤ)  {b : ℤ}  (h : 0 < b)"},
 {"type": "a + b - c = a + (b - c)",
  "tactic-prompt":
  "theorem (a b c : ℤ) : a + b - c = a + (b - c) := by rw [Int.sub_eq_add_neg, Int.add_assoc, ← Int.sub_eq_add_neg]; sorry",
  "name": "add_sub_assoc",
  "kind": "theorem",
  "first-tactic":
  "rw [Int.sub_eq_add_neg, Int.add_assoc, ← Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : ℤ) : a + b - c = a + (b - c)",
  "args": "(a b c : ℤ)"},
 {"type": "-b ≤ -a",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : a ≤ b) : -b ≤ -a := by have : 0 ≤ -a + b := Int.add_left_neg a ▸ Int.add_le_add_left h (-a); sorry",
  "name": "neg_le_neg",
  "kind": "theorem",
  "first-tactic":
  "have : 0 ≤ -a + b := Int.add_left_neg a ▸ Int.add_le_add_left h (-a)",
  "core-prompt": "{a b : ℤ}  (h : a ≤ b) : -b ≤ -a",
  "args": "{a b : ℤ}  (h : a ≤ b)"},
 {"type": "-a ≤ 0",
  "tactic-prompt":
  "theorem {a : ℤ}  (h : 0 ≤ a) : -a ≤ 0 := by have : -a ≤ -0 := Int.neg_le_neg h; sorry",
  "name": "neg_nonpos_of_nonneg",
  "kind": "theorem",
  "first-tactic": "have : -a ≤ -0 := Int.neg_le_neg h",
  "core-prompt": "{a : ℤ}  (h : 0 ≤ a) : -a ≤ 0",
  "args": "{a : ℤ}  (h : 0 ≤ a)"},
 {"type": "0 ≤ -a",
  "tactic-prompt":
  "theorem {a : ℤ}  (h : a ≤ 0) : 0 ≤ -a := by have : -0 ≤ -a := Int.neg_le_neg h; sorry",
  "name": "neg_nonneg_of_nonpos",
  "kind": "theorem",
  "first-tactic": "have : -0 ≤ -a := Int.neg_le_neg h",
  "core-prompt": "{a : ℤ}  (h : a ≤ 0) : 0 ≤ -a",
  "args": "{a : ℤ}  (h : a ≤ 0)"},
 {"type": "-b < -a",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : a < b) : -b < -a := by have : 0 < -a + b := Int.add_left_neg a ▸ Int.add_lt_add_left h (-a); sorry",
  "name": "neg_lt_neg",
  "kind": "theorem",
  "first-tactic":
  "have : 0 < -a + b := Int.add_left_neg a ▸ Int.add_lt_add_left h (-a)",
  "core-prompt": "{a b : ℤ}  (h : a < b) : -b < -a",
  "args": "{a b : ℤ}  (h : a < b)"},
 {"type": "-a < 0",
  "tactic-prompt":
  "theorem {a : ℤ}  (h : 0 < a) : -a < 0 := by have : -a < -0 := Int.neg_lt_neg h; sorry",
  "name": "neg_neg_of_pos",
  "kind": "theorem",
  "first-tactic": "have : -a < -0 := Int.neg_lt_neg h",
  "core-prompt": "{a : ℤ}  (h : 0 < a) : -a < 0",
  "args": "{a : ℤ}  (h : 0 < a)"},
 {"type": "0 < -a",
  "tactic-prompt":
  "theorem {a : ℤ}  (h : a < 0) : 0 < -a := by have : -0 < -a := Int.neg_lt_neg h; sorry",
  "name": "neg_pos_of_neg",
  "kind": "theorem",
  "first-tactic": "have : -0 < -a := Int.neg_lt_neg h",
  "core-prompt": "{a : ℤ}  (h : a < 0) : 0 < -a",
  "args": "{a : ℤ}  (h : a < 0)"},
 {"type": "b ≤ -a",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : a ≤ -b) : b ≤ -a := by have h := Int.neg_le_neg h; sorry",
  "name": "le_neg_of_le_neg",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_le_neg h",
  "core-prompt": "{a b : ℤ}  (h : a ≤ -b) : b ≤ -a",
  "args": "{a b : ℤ}  (h : a ≤ -b)"},
 {"type": "-b ≤ a",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : -a ≤ b) : -b ≤ a := by have h := Int.neg_le_neg h; sorry",
  "name": "neg_le_of_neg_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_le_neg h",
  "core-prompt": "{a b : ℤ}  (h : -a ≤ b) : -b ≤ a",
  "args": "{a b : ℤ}  (h : -a ≤ b)"},
 {"type": "b < -a",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : a < -b) : b < -a := by have h := Int.neg_lt_neg h; sorry",
  "name": "lt_neg_of_lt_neg",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_lt_neg h",
  "core-prompt": "{a b : ℤ}  (h : a < -b) : b < -a",
  "args": "{a b : ℤ}  (h : a < -b)"},
 {"type": "-b < a",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : -a < b) : -b < a := by have h := Int.neg_lt_neg h; sorry",
  "name": "neg_lt_of_neg_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_lt_neg h",
  "core-prompt": "{a b : ℤ}  (h : -a < b) : -b < a",
  "args": "{a b : ℤ}  (h : -a < b)"},
 {"type": "0 ≤ a - b",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : b ≤ a) : 0 ≤ a - b := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "sub_nonneg_of_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b : ℤ}  (h : b ≤ a) : 0 ≤ a - b",
  "args": "{a b : ℤ}  (h : b ≤ a)"},
 {"type": "b ≤ a",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : 0 ≤ a - b) : b ≤ a := by have h := Int.add_le_add_right h b; sorry",
  "name": "le_of_sub_nonneg",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b : ℤ}  (h : 0 ≤ a - b) : b ≤ a",
  "args": "{a b : ℤ}  (h : 0 ≤ a - b)"},
 {"type": "a - b ≤ 0",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : a ≤ b) : a - b ≤ 0 := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "sub_nonpos_of_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b : ℤ}  (h : a ≤ b) : a - b ≤ 0",
  "args": "{a b : ℤ}  (h : a ≤ b)"},
 {"type": "a ≤ b",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : a - b ≤ 0) : a ≤ b := by have h := Int.add_le_add_right h b; sorry",
  "name": "le_of_sub_nonpos",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b : ℤ}  (h : a - b ≤ 0) : a ≤ b",
  "args": "{a b : ℤ}  (h : a - b ≤ 0)"},
 {"type": "0 < a - b",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : b < a) : 0 < a - b := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "sub_pos_of_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b : ℤ}  (h : b < a) : 0 < a - b",
  "args": "{a b : ℤ}  (h : b < a)"},
 {"type": "b < a",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : 0 < a - b) : b < a := by have h := Int.add_lt_add_right h b; sorry",
  "name": "lt_of_sub_pos",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b : ℤ}  (h : 0 < a - b) : b < a",
  "args": "{a b : ℤ}  (h : 0 < a - b)"},
 {"type": "a - b < 0",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : a < b) : a - b < 0 := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "sub_neg_of_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b : ℤ}  (h : a < b) : a - b < 0",
  "args": "{a b : ℤ}  (h : a < b)"},
 {"type": "a < b",
  "tactic-prompt":
  "theorem {a b : ℤ}  (h : a - b < 0) : a < b := by have h := Int.add_lt_add_right h b; sorry",
  "name": "lt_of_sub_neg",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b : ℤ}  (h : a - b < 0) : a < b",
  "args": "{a b : ℤ}  (h : a - b < 0)"},
 {"type": "a + b ≤ c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : b ≤ -a + c) : a + b ≤ c := by have h := Int.add_le_add_left h a; sorry",
  "name": "add_le_of_le_neg_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h a",
  "core-prompt": "{a b c : ℤ}  (h : b ≤ -a + c) : a + b ≤ c",
  "args": "{a b c : ℤ}  (h : b ≤ -a + c)"},
 {"type": "b ≤ -a + c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a + b ≤ c) : b ≤ -a + c := by have h := Int.add_le_add_left h (-a); sorry",
  "name": "le_neg_add_of_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h (-a)",
  "core-prompt": "{a b c : ℤ}  (h : a + b ≤ c) : b ≤ -a + c",
  "args": "{a b c : ℤ}  (h : a + b ≤ c)"},
 {"type": "a + b ≤ c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : b ≤ c - a) : a + b ≤ c := by have h := Int.add_le_add_left h a; sorry",
  "name": "add_le_of_le_sub_left",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h a",
  "core-prompt": "{a b c : ℤ}  (h : b ≤ c - a) : a + b ≤ c",
  "args": "{a b c : ℤ}  (h : b ≤ c - a)"},
 {"type": "b ≤ c - a",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a + b ≤ c) : b ≤ c - a := by have h := Int.add_le_add_right h (-a); sorry",
  "name": "le_sub_left_of_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-a)",
  "core-prompt": "{a b c : ℤ}  (h : a + b ≤ c) : b ≤ c - a",
  "args": "{a b c : ℤ}  (h : a + b ≤ c)"},
 {"type": "a + b ≤ c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a ≤ c - b) : a + b ≤ c := by have h := Int.add_le_add_right h b; sorry",
  "name": "add_le_of_le_sub_right",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b c : ℤ}  (h : a ≤ c - b) : a + b ≤ c",
  "args": "{a b c : ℤ}  (h : a ≤ c - b)"},
 {"type": "a ≤ c - b",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a + b ≤ c) : a ≤ c - b := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "le_sub_right_of_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b c : ℤ}  (h : a + b ≤ c) : a ≤ c - b",
  "args": "{a b c : ℤ}  (h : a + b ≤ c)"},
 {"type": "a ≤ b + c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : -b + a ≤ c) : a ≤ b + c := by have h := Int.add_le_add_left h b; sorry",
  "name": "le_add_of_neg_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h b",
  "core-prompt": "{a b c : ℤ}  (h : -b + a ≤ c) : a ≤ b + c",
  "args": "{a b c : ℤ}  (h : -b + a ≤ c)"},
 {"type": "-b + a ≤ c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a ≤ b + c) : -b + a ≤ c := by have h := Int.add_le_add_left h (-b); sorry",
  "name": "neg_add_le_of_le_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h (-b)",
  "core-prompt": "{a b c : ℤ}  (h : a ≤ b + c) : -b + a ≤ c",
  "args": "{a b c : ℤ}  (h : a ≤ b + c)"},
 {"type": "a ≤ b + c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a - b ≤ c) : a ≤ b + c := by have h := Int.add_le_add_right h b; sorry",
  "name": "le_add_of_sub_left_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b c : ℤ}  (h : a - b ≤ c) : a ≤ b + c",
  "args": "{a b c : ℤ}  (h : a - b ≤ c)"},
 {"type": "a - b ≤ c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a ≤ b + c) : a - b ≤ c := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "sub_left_le_of_le_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b c : ℤ}  (h : a ≤ b + c) : a - b ≤ c",
  "args": "{a b c : ℤ}  (h : a ≤ b + c)"},
 {"type": "a ≤ b + c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a - c ≤ b) : a ≤ b + c := by have h := Int.add_le_add_right h c; sorry",
  "name": "le_add_of_sub_right_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h c",
  "core-prompt": "{a b c : ℤ}  (h : a - c ≤ b) : a ≤ b + c",
  "args": "{a b c : ℤ}  (h : a - c ≤ b)"},
 {"type": "a - c ≤ b",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a ≤ b + c) : a - c ≤ b := by have h := Int.add_le_add_right h (-c); sorry",
  "name": "sub_right_le_of_le_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-c)",
  "core-prompt": "{a b c : ℤ}  (h : a ≤ b + c) : a - c ≤ b",
  "args": "{a b c : ℤ}  (h : a ≤ b + c)"},
 {"type": "a ≤ b + c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : -b + a ≤ c) : a ≤ b + c := by rw [Int.add_comm] at h; sorry",
  "name": "le_add_of_neg_add_le_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : ℤ}  (h : -b + a ≤ c) : a ≤ b + c",
  "args": "{a b c : ℤ}  (h : -b + a ≤ c)"},
 {"type": "-b + a ≤ c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a ≤ b + c) : -b + a ≤ c := by rw [Int.add_comm]; sorry",
  "name": "neg_add_le_left_of_le_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b c : ℤ}  (h : a ≤ b + c) : -b + a ≤ c",
  "args": "{a b c : ℤ}  (h : a ≤ b + c)"},
 {"type": "a ≤ b + c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : -c + a ≤ b) : a ≤ b + c := by rw [Int.add_comm] at h; sorry",
  "name": "le_add_of_neg_add_le_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : ℤ}  (h : -c + a ≤ b) : a ≤ b + c",
  "args": "{a b c : ℤ}  (h : -c + a ≤ b)"},
 {"type": "-c + a ≤ b",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a ≤ b + c) : -c + a ≤ b := by rw [Int.add_comm] at h; sorry",
  "name": "neg_add_le_right_of_le_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : ℤ}  (h : a ≤ b + c) : -c + a ≤ b",
  "args": "{a b c : ℤ}  (h : a ≤ b + c)"},
 {"type": "-a ≤ b - c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : c ≤ a + b) : -a ≤ b - c := by have h := Int.le_neg_add_of_add_le (Int.sub_left_le_of_le_add h); sorry",
  "name": "neg_le_sub_left_of_le_add",
  "kind": "theorem",
  "first-tactic":
  "have h := Int.le_neg_add_of_add_le (Int.sub_left_le_of_le_add h)",
  "core-prompt": "{a b c : ℤ}  (h : c ≤ a + b) : -a ≤ b - c",
  "args": "{a b c : ℤ}  (h : c ≤ a + b)"},
 {"type": "a + b < c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : b < -a + c) : a + b < c := by have h := Int.add_lt_add_left h a; sorry",
  "name": "add_lt_of_lt_neg_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h a",
  "core-prompt": "{a b c : ℤ}  (h : b < -a + c) : a + b < c",
  "args": "{a b c : ℤ}  (h : b < -a + c)"},
 {"type": "b < -a + c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a + b < c) : b < -a + c := by have h := Int.add_lt_add_left h (-a); sorry",
  "name": "lt_neg_add_of_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h (-a)",
  "core-prompt": "{a b c : ℤ}  (h : a + b < c) : b < -a + c",
  "args": "{a b c : ℤ}  (h : a + b < c)"},
 {"type": "a + b < c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : b < c - a) : a + b < c := by have h := Int.add_lt_add_left h a; sorry",
  "name": "add_lt_of_lt_sub_left",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h a",
  "core-prompt": "{a b c : ℤ}  (h : b < c - a) : a + b < c",
  "args": "{a b c : ℤ}  (h : b < c - a)"},
 {"type": "b < c - a",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a + b < c) : b < c - a := by have h := Int.add_lt_add_right h (-a); sorry",
  "name": "lt_sub_left_of_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-a)",
  "core-prompt": "{a b c : ℤ}  (h : a + b < c) : b < c - a",
  "args": "{a b c : ℤ}  (h : a + b < c)"},
 {"type": "a + b < c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a < c - b) : a + b < c := by have h := Int.add_lt_add_right h b; sorry",
  "name": "add_lt_of_lt_sub_right",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b c : ℤ}  (h : a < c - b) : a + b < c",
  "args": "{a b c : ℤ}  (h : a < c - b)"},
 {"type": "a < c - b",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a + b < c) : a < c - b := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "lt_sub_right_of_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b c : ℤ}  (h : a + b < c) : a < c - b",
  "args": "{a b c : ℤ}  (h : a + b < c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : -b + a < c) : a < b + c := by have h := Int.add_lt_add_left h b; sorry",
  "name": "lt_add_of_neg_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h b",
  "core-prompt": "{a b c : ℤ}  (h : -b + a < c) : a < b + c",
  "args": "{a b c : ℤ}  (h : -b + a < c)"},
 {"type": "-b + a < c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a < b + c) : -b + a < c := by have h := Int.add_lt_add_left h (-b); sorry",
  "name": "neg_add_lt_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h (-b)",
  "core-prompt": "{a b c : ℤ}  (h : a < b + c) : -b + a < c",
  "args": "{a b c : ℤ}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a - b < c) : a < b + c := by have h := Int.add_lt_add_right h b; sorry",
  "name": "lt_add_of_sub_left_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b c : ℤ}  (h : a - b < c) : a < b + c",
  "args": "{a b c : ℤ}  (h : a - b < c)"},
 {"type": "a - b < c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a < b + c) : a - b < c := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "sub_left_lt_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b c : ℤ}  (h : a < b + c) : a - b < c",
  "args": "{a b c : ℤ}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a - c < b) : a < b + c := by have h := Int.add_lt_add_right h c; sorry",
  "name": "lt_add_of_sub_right_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h c",
  "core-prompt": "{a b c : ℤ}  (h : a - c < b) : a < b + c",
  "args": "{a b c : ℤ}  (h : a - c < b)"},
 {"type": "a - c < b",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a < b + c) : a - c < b := by have h := Int.add_lt_add_right h (-c); sorry",
  "name": "sub_right_lt_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-c)",
  "core-prompt": "{a b c : ℤ}  (h : a < b + c) : a - c < b",
  "args": "{a b c : ℤ}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : -b + a < c) : a < b + c := by rw [Int.add_comm] at h; sorry",
  "name": "lt_add_of_neg_add_lt_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : ℤ}  (h : -b + a < c) : a < b + c",
  "args": "{a b c : ℤ}  (h : -b + a < c)"},
 {"type": "-b + a < c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a < b + c) : -b + a < c := by rw [Int.add_comm]; sorry",
  "name": "neg_add_lt_left_of_lt_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b c : ℤ}  (h : a < b + c) : -b + a < c",
  "args": "{a b c : ℤ}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : -c + a < b) : a < b + c := by rw [Int.add_comm] at h; sorry",
  "name": "lt_add_of_neg_add_lt_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : ℤ}  (h : -c + a < b) : a < b + c",
  "args": "{a b c : ℤ}  (h : -c + a < b)"},
 {"type": "-c + a < b",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : a < b + c) : -c + a < b := by rw [Int.add_comm] at h; sorry",
  "name": "neg_add_lt_right_of_lt_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : ℤ}  (h : a < b + c) : -c + a < b",
  "args": "{a b c : ℤ}  (h : a < b + c)"},
 {"type": "-a < b - c",
  "tactic-prompt":
  "theorem {a b c : ℤ}  (h : c < a + b) : -a < b - c := by have h := Int.lt_neg_add_of_add_lt (Int.sub_left_lt_of_lt_add h); sorry",
  "name": "neg_lt_sub_left_of_lt_add",
  "kind": "theorem",
  "first-tactic":
  "have h := Int.lt_neg_add_of_add_lt (Int.sub_left_lt_of_lt_add h)",
  "core-prompt": "{a b c : ℤ}  (h : c < a + b) : -a < b - c",
  "args": "{a b c : ℤ}  (h : c < a + b)"},
 {"type": "a + b + c ≤ d + e + f",
  "tactic-prompt":
  "theorem {a b c d e f : ℤ}    (h₁ : a ≤ d)  (h₂ : b ≤ e)  (h₃ : c ≤ f) : a + b + c ≤ d + e + f := by apply le_trans; sorry",
  "name": "add_le_add_three",
  "kind": "theorem",
  "first-tactic": "apply le_trans",
  "core-prompt":
  "{a b c d e f : ℤ}    (h₁ : a ≤ d)  (h₂ : b ≤ e)  (h₃ : c ≤ f) : a + b + c ≤ d + e + f",
  "args": "{a b c d e f : ℤ}    (h₁ : a ≤ d)  (h₂ : b ≤ e)  (h₃ : c ≤ f)"},
 {"type": "c * a < c * b",
  "tactic-prompt":
  "theorem {a b c : ℤ}    (h₁ : a < b)  (h₂ : 0 < c) : c * a < c * b := by have : 0 < c * (b - a) := Int.mul_pos h₂ (Int.sub_pos_of_lt h₁); sorry",
  "name": "mul_lt_mul_of_pos_left",
  "kind": "theorem",
  "first-tactic":
  "have : 0 < c * (b - a) := Int.mul_pos h₂ (Int.sub_pos_of_lt h₁)",
  "core-prompt": "{a b c : ℤ}    (h₁ : a < b)  (h₂ : 0 < c) : c * a < c * b",
  "args": "{a b c : ℤ}    (h₁ : a < b)  (h₂ : 0 < c)"},
 {"type": "a * c < b * c",
  "tactic-prompt":
  "theorem {a b c : ℤ}    (h₁ : a < b)  (h₂ : 0 < c) : a * c < b * c := by have : 0 < b - a := Int.sub_pos_of_lt h₁; sorry",
  "name": "mul_lt_mul_of_pos_right",
  "kind": "theorem",
  "first-tactic": "have : 0 < b - a := Int.sub_pos_of_lt h₁",
  "core-prompt": "{a b c : ℤ}    (h₁ : a < b)  (h₂ : 0 < c) : a * c < b * c",
  "args": "{a b c : ℤ}    (h₁ : a < b)  (h₂ : 0 < c)"},
 {"type": "c * a ≤ c * b",
  "tactic-prompt":
  "theorem {a b c : ℤ}    (h₁ : a ≤ b)  (h₂ : 0 ≤ c) : c * a ≤ c * b := by by_cases hba : b ≤ a; sorry",
  "name": "mul_le_mul_of_nonneg_left",
  "kind": "theorem",
  "first-tactic": "by_cases hba : b ≤ a",
  "core-prompt": "{a b c : ℤ}    (h₁ : a ≤ b)  (h₂ : 0 ≤ c) : c * a ≤ c * b",
  "args": "{a b c : ℤ}    (h₁ : a ≤ b)  (h₂ : 0 ≤ c)"},
 {"type": "a * c ≤ b * c",
  "tactic-prompt":
  "theorem {a b c : ℤ}    (h₁ : a ≤ b)  (h₂ : 0 ≤ c) : a * c ≤ b * c := by by_cases hba : b ≤ a; sorry",
  "name": "mul_le_mul_of_nonneg_right",
  "kind": "theorem",
  "first-tactic": "by_cases hba : b ≤ a",
  "core-prompt": "{a b c : ℤ}    (h₁ : a ≤ b)  (h₂ : 0 ≤ c) : a * c ≤ b * c",
  "args": "{a b c : ℤ}    (h₁ : a ≤ b)  (h₂ : 0 ≤ c)"},
 {"type": "a * b ≤ 0",
  "tactic-prompt":
  "theorem {a b : ℤ}    (ha : 0 ≤ a)  (hb : b ≤ 0) : a * b ≤ 0 := by have h : a * b ≤ a * 0 := Int.mul_le_mul_of_nonneg_left hb ha; sorry",
  "name": "mul_nonpos_of_nonneg_of_nonpos",
  "kind": "theorem",
  "first-tactic":
  "have h : a * b ≤ a * 0 := Int.mul_le_mul_of_nonneg_left hb ha",
  "core-prompt": "{a b : ℤ}    (ha : 0 ≤ a)  (hb : b ≤ 0) : a * b ≤ 0",
  "args": "{a b : ℤ}    (ha : 0 ≤ a)  (hb : b ≤ 0)"},
 {"type": "a * b ≤ 0",
  "tactic-prompt":
  "theorem {a b : ℤ}    (ha : a ≤ 0)  (hb : 0 ≤ b) : a * b ≤ 0 := by have h : a * b ≤ 0 * b := Int.mul_le_mul_of_nonneg_right ha hb; sorry",
  "name": "mul_nonpos_of_nonpos_of_nonneg",
  "kind": "theorem",
  "first-tactic":
  "have h : a * b ≤ 0 * b := Int.mul_le_mul_of_nonneg_right ha hb",
  "core-prompt": "{a b : ℤ}    (ha : a ≤ 0)  (hb : 0 ≤ b) : a * b ≤ 0",
  "args": "{a b : ℤ}    (ha : a ≤ 0)  (hb : 0 ≤ b)"},
 {"type": "a * b < 0",
  "tactic-prompt":
  "theorem {a b : ℤ}  (ha : 0 < a)  (hb : b < 0) : a * b < 0 := by have h : a * b < a * 0 := Int.mul_lt_mul_of_pos_left hb ha; sorry",
  "name": "mul_neg_of_pos_of_neg",
  "kind": "theorem",
  "first-tactic": "have h : a * b < a * 0 := Int.mul_lt_mul_of_pos_left hb ha",
  "core-prompt": "{a b : ℤ}  (ha : 0 < a)  (hb : b < 0) : a * b < 0",
  "args": "{a b : ℤ}  (ha : 0 < a)  (hb : b < 0)"},
 {"type": "a * b < 0",
  "tactic-prompt":
  "theorem {a b : ℤ}  (ha : a < 0)  (hb : 0 < b) : a * b < 0 := by have h : a * b < 0 * b := Int.mul_lt_mul_of_pos_right ha hb; sorry",
  "name": "mul_neg_of_neg_of_pos",
  "kind": "theorem",
  "first-tactic": "have h : a * b < 0 * b := Int.mul_lt_mul_of_pos_right ha hb",
  "core-prompt": "{a b : ℤ}  (ha : a < 0)  (hb : 0 < b) : a * b < 0",
  "args": "{a b : ℤ}  (ha : a < 0)  (hb : 0 < b)"},
 {"type": "0 ≤ a * b",
  "tactic-prompt":
  "theorem {a b : ℤ}    (ha : a ≤ 0)  (hb : b ≤ 0) : 0 ≤ a * b := by have : 0 * b ≤ a * b := Int.mul_le_mul_of_nonpos_right ha hb; sorry",
  "name": "mul_nonneg_of_nonpos_of_nonpos",
  "kind": "theorem",
  "first-tactic":
  "have : 0 * b ≤ a * b := Int.mul_le_mul_of_nonpos_right ha hb",
  "core-prompt": "{a b : ℤ}    (ha : a ≤ 0)  (hb : b ≤ 0) : 0 ≤ a * b",
  "args": "{a b : ℤ}    (ha : a ≤ 0)  (hb : b ≤ 0)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "theorem {a b : ℤ}  (ha : a < 0)  (hb : b < 0) : 0 < a * b := by have : 0 * b < a * b := Int.mul_lt_mul_of_neg_right ha hb; sorry",
  "name": "mul_pos_of_neg_of_neg",
  "kind": "theorem",
  "first-tactic": "have : 0 * b < a * b := Int.mul_lt_mul_of_neg_right ha hb",
  "core-prompt": "{a b : ℤ}  (ha : a < 0)  (hb : b < 0) : 0 < a * b",
  "args": "{a b : ℤ}  (ha : a < 0)  (hb : b < 0)"},
 {"type": "(natAbs a : ℤ) = -a",
  "tactic-prompt":
  "theorem {a : ℤ}  (H : a ≤ 0) : (natAbs a : ℤ) = -a := by rw [← natAbs_neg, natAbs_of_nonneg (Int.neg_nonneg_of_nonpos H)]; sorry",
  "name": "ofNat_natAbs_of_nonpos",
  "kind": "theorem",
  "first-tactic":
  "rw [← natAbs_neg, natAbs_of_nonneg (Int.neg_nonneg_of_nonpos H)]",
  "core-prompt": "{a : ℤ}  (H : a ≤ 0) : (natAbs a : ℤ) = -a",
  "args": "{a : ℤ}  (H : a ≤ 0)"},
 {"type": "length (repeat' a n) = n",
  "tactic-prompt":
  "theorem (a : α)  (n : Nat) : length (repeat' a n) = n := by induction n <;> simp_all; sorry",
  "name": "length_repeat'",
  "kind": "theorem",
  "first-tactic": "induction n <;> simp_all",
  "core-prompt": "(a : α)  (n : Nat) : length (repeat' a n) = n",
  "args": "(a : α)  (n : Nat)"},
 {"type": "length (tail l) = length l - 1",
  "tactic-prompt":
  "theorem (l : List α) : length (tail l) = length l - 1 := by cases l <;> rfl; sorry",
  "name": "length_tail",
  "kind": "theorem",
  "first-tactic": "cases l <;> rfl",
  "core-prompt": "(l : List α) : length (tail l) = length l - 1",
  "args": "(l : List α)"},
 {"type": "∀ l₁ l₂, map f (l₁ ++ l₂) = map f l₁ ++ map f l₂",
  "tactic-prompt":
  "theorem (f : α → β) : ∀ l₁ l₂, map f (l₁ ++ l₂) = map f l₁ ++ map f l₂ := by intro l₁ <;> induction l₁ <;> intros <;> simp_all; sorry",
  "name": "map_append",
  "kind": "theorem",
  "first-tactic": "intro l₁ <;> induction l₁ <;> intros <;> simp_all",
  "core-prompt":
  "(f : α → β) : ∀ l₁ l₂, map f (l₁ ++ l₂) = map f l₁ ++ map f l₂",
  "args": "(f : α → β)"},
 {"type": "map id l = l",
  "tactic-prompt":
  "theorem (l : List α) : map id l = l := by induction l <;> simp_all; sorry",
  "name": "map_id",
  "kind": "theorem",
  "first-tactic": "induction l <;> simp_all",
  "core-prompt": "(l : List α) : map id l = l",
  "args": "(l : List α)"},
 {"type": "map g (map f l) = map (g ∘ f) l",
  "tactic-prompt":
  "theorem (g : β → γ)  (f : α → β)  (l : List α) : map g (map f l) = map (g ∘ f) l := by induction l <;> simp_all; sorry",
  "name": "map_map",
  "kind": "theorem",
  "first-tactic": "induction l <;> simp_all",
  "core-prompt":
  "(g : β → γ)  (f : α → β)  (l : List α) : map g (map f l) = map (g ∘ f) l",
  "args": "(g : β → γ)  (f : α → β)  (l : List α)"},
 {"type": "List.bind [] f = []",
  "tactic-prompt":
  "theorem (f : α → List β) : List.bind [] f = [] := by simp [join, List.bind]; sorry",
  "name": "nil_bind",
  "kind": "theorem",
  "first-tactic": "simp [join, List.bind]",
  "core-prompt": "(f : α → List β) : List.bind [] f = []",
  "args": "(f : α → List β)"},
 {"type": "a ∈ ([] : List α) ↔ False",
  "tactic-prompt":
  "theorem (a : α) : a ∈ ([] : List α) ↔ False := by simp; sorry",
  "name": "mem_nil_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a : α) : a ∈ ([] : List α) ↔ False",
  "args": "(a : α)"},
 {"type": "a ∈ a :: l",
  "tactic-prompt":
  "theorem (a : α)  (l : List α) : a ∈ a :: l := by simp; sorry",
  "name": "mem_cons_self",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a : α)  (l : List α) : a ∈ a :: l",
  "args": "(a : α)  (l : List α)"},
 {"type": "(a ∈ y :: l) = (a = y ∨ a ∈ l)",
  "tactic-prompt":
  "theorem (a y : α)  (l : List α) : (a ∈ y :: l) = (a = y ∨ a ∈ l) := by simp; sorry",
  "name": "mem_cons_eq",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a y : α)  (l : List α) : (a ∈ y :: l) = (a = y ∨ a ∈ l)",
  "args": "(a y : α)  (l : List α)"},
 {"type": "a ∈ y :: l → a = y ∨ a ∈ l",
  "tactic-prompt":
  "theorem {a y : α}  {l : List α} : a ∈ y :: l → a = y ∨ a ∈ l := by simp; sorry",
  "name": "eq_or_mem_of_mem_cons",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "{a y : α}  {l : List α} : a ∈ y :: l → a = y ∨ a ∈ l",
  "args": "{a y : α}  {l : List α}"},
 {"type": "a ∈ s ++ t ↔ a ∈ s ∨ a ∈ t",
  "tactic-prompt":
  "theorem {a : α}  {s t : List α} : a ∈ s ++ t ↔ a ∈ s ∨ a ∈ t := by induction s <;> simp_all [or_assoc]; sorry",
  "name": "mem_append",
  "kind": "theorem",
  "first-tactic": "induction s <;> simp_all [or_assoc]",
  "core-prompt": "{a : α}  {s t : List α} : a ∈ s ++ t ↔ a ∈ s ∨ a ∈ t",
  "args": "{a : α}  {s t : List α}"},
 {"type": "length l = 0 → l = []",
  "tactic-prompt":
  "theorem {l : List α} : length l = 0 → l = [] := by induction l <;> intros; sorry",
  "name": "eq_nil_of_length_eq_zero",
  "kind": "theorem",
  "first-tactic": "induction l <;> intros",
  "core-prompt": "{l : List α} : length l = 0 → l = []",
  "args": "{l : List α}"},
 {"type": "∀ {n : Nat}, length l = succ n → l ≠ []",
  "tactic-prompt":
  "theorem {l : List α} : ∀ {n : Nat}, length l = succ n → l ≠ [] := by induction l <;> intros _ _ _ <;> contradiction; sorry",
  "name": "ne_nil_of_length_eq_succ",
  "kind": "theorem",
  "first-tactic": "induction l <;> intros _ _ _ <;> contradiction",
  "core-prompt": "{l : List α} : ∀ {n : Nat}, length l = succ n → l ≠ []",
  "args": "{l : List α}"},
 {"type": "(m * n).cast = (m.cast * n.cast : R)",
  "tactic-prompt":
  "lemma [Semiring R]  {m n : ℕ} : (m * n).cast = (m.cast * n.cast : R) := by induction n generalizing m <;> simp_all [mul_succ, mul_add]; sorry",
  "name": "Nat.cast_mul",
  "kind": "lemma",
  "first-tactic": "induction n generalizing m <;> simp_all [mul_succ, mul_add]",
  "core-prompt":
  "[Semiring R]  {m n : ℕ} : (m * n).cast = (m.cast * n.cast : R)",
  "args": "[Semiring R]  {m n : ℕ}"},
 {"type": "(m ^ n).cast = (m.cast ^ n : R)",
  "tactic-prompt":
  "lemma [Semiring R]  {m n : ℕ} : (m ^ n).cast = (m.cast ^ n : R) := by induction n generalizing m <;> simp_all [Nat.pow_succ', _root_.pow_succ', pow_zero]; sorry",
  "name": "Nat.cast_pow",
  "kind": "lemma",
  "first-tactic":
  "induction n generalizing m <;> simp_all [Nat.pow_succ', _root_.pow_succ', pow_zero]",
  "core-prompt": "[Semiring R]  {m n : ℕ} : (m ^ n).cast = (m.cast ^ n : R)",
  "args": "[Semiring R]  {m n : ℕ}"},
 {"type": "b = c",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {A : Type u}  [AddMonoid A]  {a b c : A} (hba : b + a = 0)  (hac : a + c = 0) : b = c := by rw [←zero_add c, ←hba, add_assoc, hac, add_zero b]; sorry",
  "name": "left_neg_eq_right_neg",
  "kind": "theorem",
  "first-tactic": "rw [←zero_add c, ←hba, add_assoc, hac, add_zero b]",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {A : Type u}  [AddMonoid A]  {a b c : A} (hba : b + a = 0)  (hac : a + c = 0) : b = c",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {A : Type u}  [AddMonoid A]  {a b c : A} (hba : b + a = 0)  (hac : a + c = 0)"},
 {"type": "((1 : ℕ) : R) = 1",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A} [AddMonoidWithOne R] : ((1 : ℕ) : R) = 1 := by simp; sorry",
  "name": "Nat.cast_one",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A} [AddMonoidWithOne R] : ((1 : ℕ) : R) = 1",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A} [AddMonoidWithOne R]"},
 {"type": "((m + n : ℕ) : R) = (m : R) + n",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A} [AddMonoidWithOne R] : ((m + n : ℕ) : R) = (m : R) + n := by induction n <;> simp_all [add_succ, add_assoc]; sorry",
  "name": "Nat.cast_add",
  "kind": "theorem",
  "first-tactic": "induction n <;> simp_all [add_succ, add_assoc]",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A} [AddMonoidWithOne R] : ((m + n : ℕ) : R) = (m : R) + n",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A} [AddMonoidWithOne R]"},
 {"type": "-a + (a + b) = b",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {A : Type u}  [AddGroup A]  {a b c : A} (a b : A) : -a + (a + b) = b := by rw [← add_assoc, add_left_neg, zero_add]; sorry",
  "name": "neg_add_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← add_assoc, add_left_neg, zero_add]",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {A : Type u}  [AddGroup A]  {a b c : A} (a b : A) : -a + (a + b) = b",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {A : Type u}  [AddGroup A]  {a b c : A} (a b : A)"},
 {"type": "a + -a = 0",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {A : Type u}  [AddGroup A]  {a b c : A} (a : A) : a + -a = 0 := by rw [←add_left_neg (-a), neg_neg]\n\n-- synonym; sorry",
  "name": "add_right_neg",
  "kind": "theorem",
  "first-tactic": "rw [←add_left_neg (-a), neg_neg]\n\n-- synonym",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {A : Type u}  [AddGroup A]  {a b c : A} (a : A) : a + -a = 0",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {A : Type u}  [AddGroup A]  {a b c : A} (a : A)"},
 {"type": "a + b + -b = a",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {A : Type u}  [AddGroup A]  {a b c : A} (a b : A) : a + b + -b = a := by rw [add_assoc, add_right_neg, add_zero]; sorry",
  "name": "add_neg_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [add_assoc, add_right_neg, add_zero]",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {A : Type u}  [AddGroup A]  {a b c : A} (a b : A) : a + b + -b = a",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {A : Type u}  [AddGroup A]  {a b c : A} (a b : A)"},
 {"type": "((0 : ℤ) : R) = 0",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A} [AddGroupWithOne R] : ((0 : ℤ) : R) = 0 := by erw [Int.cast_ofNat, Nat.cast_zero]; sorry",
  "name": "Int.cast_zero",
  "kind": "theorem",
  "first-tactic": "erw [Int.cast_ofNat, Nat.cast_zero]",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A} [AddGroupWithOne R] : ((0 : ℤ) : R) = 0",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A} [AddGroupWithOne R]"},
 {"type": "((1 : ℤ) : R) = 1",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A} [AddGroupWithOne R] : ((1 : ℤ) : R) = 1 := by erw [Int.cast_ofNat, Nat.cast_one]\n\n/-\n\n## Multiplicative semigroups, monoids and groups\n\n-/\n\n/-\n\n## Semigroups\n\n-/; sorry",
  "name": "Int.cast_one",
  "kind": "theorem",
  "first-tactic":
  "erw [Int.cast_ofNat, Nat.cast_one]\n\n/-\n\n## Multiplicative semigroups, monoids and groups\n\n-/\n\n/-\n\n## Semigroups\n\n-/",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A} [AddGroupWithOne R] : ((1 : ℤ) : R) = 1",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A} [AddGroupWithOne R]"},
 {"type": "a^n * a = a * a^n",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M] (a : M)  (n : ℕ) : a^n * a = a * a^n := by induction n; sorry",
  "name": "pow_mul_comm",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M] (a : M)  (n : ℕ) : a^n * a = a * a^n",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M] (a : M)  (n : ℕ)"},
 {"type": "a ^ n.succ = a ^ n * a",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M] (n : ℕ)  (a : M) : a ^ n.succ = a ^ n * a := by rw [pow_succ', pow_mul_comm]; sorry",
  "name": "pow_succ",
  "kind": "theorem",
  "first-tactic": "rw [pow_succ', pow_mul_comm]",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M] (n : ℕ)  (a : M) : a ^ n.succ = a ^ n * a",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M] (n : ℕ)  (a : M)"},
 {"type": "a ^ (1:ℕ) = a",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M] (a : M) : a ^ (1:ℕ) = a := by rw [Nat.one_eq_succ_zero, pow_succ, pow_zero, one_mul]; sorry",
  "name": "pow_one",
  "kind": "theorem",
  "first-tactic": "rw [Nat.one_eq_succ_zero, pow_succ, pow_zero, one_mul]",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M] (a : M) : a ^ (1:ℕ) = a",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M] (a : M)"},
 {"type": "a^(m + n) = a^m * a^n",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M] (a : M)  (m n : ℕ) : a^(m + n) = a^m * a^n := by induction n; sorry",
  "name": "pow_add",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M] (a : M)  (m n : ℕ) : a^(m + n) = a^m * a^n",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M] (a : M)  (m n : ℕ)"},
 {"type": "b = c",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M] {M : Type u}  [Monoid M]  {a b c : M}    (hba : b * a = 1)  (hac : a * c = 1) : b = c := by rw [←one_mul c, ←hba, mul_assoc, hac, mul_one b]; sorry",
  "name": "left_inv_eq_right_inv",
  "kind": "theorem",
  "first-tactic": "rw [←one_mul c, ←hba, mul_assoc, hac, mul_one b]",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M] {M : Type u}  [Monoid M]  {a b c : M}    (hba : b * a = 1)  (hac : a * c = 1) : b = c",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M] {M : Type u}  [Monoid M]  {a b c : M}    (hba : b * a = 1)  (hac : a * c = 1)"},
 {"type": "(a * b)^n= a^n * b^n",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M]  (a b : M)  (n : ℕ) : (a * b)^n= a^n * b^n := by induction n; sorry",
  "name": "mul_pow",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M]  (a b : M)  (n : ℕ) : (a * b)^n= a^n * b^n",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M]  (a b : M)  (n : ℕ)"},
 {"type": "a⁻¹ * (a * b) = b",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M]   {G : Type u}  [Group G]  {a b c : G} (a b : G) : a⁻¹ * (a * b) = b := by rw [← mul_assoc, mul_left_inv, one_mul]; sorry",
  "name": "inv_mul_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc, mul_left_inv, one_mul]",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M]   {G : Type u}  [Group G]  {a b c : G} (a b : G) : a⁻¹ * (a * b) = b",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M]   {G : Type u}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "a * a⁻¹ = 1",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M]   {G : Type u}  [Group G]  {a b c : G} (a : G) : a * a⁻¹ = 1 := by rw [←mul_left_inv (a⁻¹), inv_inv]\n\n-- synonym; sorry",
  "name": "mul_right_inv",
  "kind": "theorem",
  "first-tactic": "rw [←mul_left_inv (a⁻¹), inv_inv]\n\n-- synonym",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M]   {G : Type u}  [Group G]  {a b c : G} (a : G) : a * a⁻¹ = 1",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M]   {G : Type u}  [Group G]  {a b c : G} (a : G)"},
 {"type": "a * b * b⁻¹ = a",
  "tactic-prompt":
  "theorem {A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M]   {G : Type u}  [Group G]  {a b c : G} (a b : G) : a * b * b⁻¹ = a := by rw [mul_assoc, mul_right_inv, mul_one]; sorry",
  "name": "mul_inv_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc, mul_right_inv, mul_one]",
  "core-prompt":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M]   {G : Type u}  [Group G]  {a b c : G} (a b : G) : a * b * b⁻¹ = a",
  "args":
  "{A : Type u}  [AddSemigroup A]  [IsAddRightCancel A]  {a b c : A}  {G : Type u}  [Semigroup G]  [IsMulRightCancel G]  {a b c : G}  {M : Type u}  [Monoid M]   {G : Type u}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "(a + b) +(c + d) = (a + c) + (b + d)",
  "tactic-prompt":
  "theorem {A : Type u}  [AddCommSemigroup A] (a b c d : A) : (a + b) +(c + d) = (a + c) + (b + d) := by simp [add_left_comm, add_assoc]; sorry",
  "name": "add_add_add_comm",
  "kind": "theorem",
  "first-tactic": "simp [add_left_comm, add_assoc]",
  "core-prompt":
  "{A : Type u}  [AddCommSemigroup A] (a b c d : A) : (a + b) +(c + d) = (a + c) + (b + d)",
  "args": "{A : Type u}  [AddCommSemigroup A] (a b c d : A)"},
 {"type": "(a * b) * (c * d) = (a * c) * (b * d)",
  "tactic-prompt":
  "theorem {M : Type u}  [CommSemigroup M] (a b c d : M) : (a * b) * (c * d) = (a * c) * (b * d) := by simp [mul_assoc, mul_left_comm]; sorry",
  "name": "mul_mul_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp [mul_assoc, mul_left_comm]",
  "core-prompt":
  "{M : Type u}  [CommSemigroup M] (a b c d : M) : (a * b) * (c * d) = (a * c) * (b * d)",
  "args": "{M : Type u}  [CommSemigroup M] (a b c d : M)"},
 {"type": "a + b = a ↔ b = 0",
  "tactic-prompt":
  "lemma {A : Type u}  [AddMonoid A]  [IsAddLeftCancel A]  {a b : A} : a + b = a ↔ b = 0 := by rw [←add_left_cancel_iff (c := 0), add_zero]; sorry",
  "name": "add_right_eq_self",
  "kind": "lemma",
  "first-tactic": "rw [←add_left_cancel_iff (c := 0), add_zero]",
  "core-prompt":
  "{A : Type u}  [AddMonoid A]  [IsAddLeftCancel A]  {a b : A} : a + b = a ↔ b = 0",
  "args": "{A : Type u}  [AddMonoid A]  [IsAddLeftCancel A]  {a b : A}"},
 {"type": "a = a + b ↔ b = 0",
  "tactic-prompt":
  "lemma {A : Type u}  [AddMonoid A]  [IsAddLeftCancel A]  {a b : A} : a = a + b ↔ b = 0 := by rw [←add_left_cancel_iff (c := 0), add_zero, eq_comm]; sorry",
  "name": "self_eq_add_right",
  "kind": "lemma",
  "first-tactic": "rw [←add_left_cancel_iff (c := 0), add_zero, eq_comm]",
  "core-prompt":
  "{A : Type u}  [AddMonoid A]  [IsAddLeftCancel A]  {a b : A} : a = a + b ↔ b = 0",
  "args": "{A : Type u}  [AddMonoid A]  [IsAddLeftCancel A]  {a b : A}"},
 {"type": "(1 + 0 : α) = (0 + 1 : α)",
  "tactic-prompt": "example  : (1 + 0 : α) = (0 + 1 : α) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (1 + 0 : α) = (0 + 1 : α)",
  "args": ""},
 {"type": "(0 + (2 + 3) + 1 : α) = 6",
  "tactic-prompt": "example  : (0 + (2 + 3) + 1 : α) = 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (0 + (2 + 3) + 1 : α) = 6",
  "args": ""},
 {"type": "(70 * (33 + 2) : α) = 2450",
  "tactic-prompt":
  "example  : (70 * (33 + 2) : α) = 2450 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (70 * (33 + 2) : α) = 2450",
  "args": ""},
 {"type": "(8 + 2 ^ 2 * 3 : α) = 20",
  "tactic-prompt": "example  : (8 + 2 ^ 2 * 3 : α) = 20 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (8 + 2 ^ 2 * 3 : α) = 20",
  "args": ""},
 {"type": "((2 * 1 + 1) ^ 2 : α) = (3 * 3 : α)",
  "tactic-prompt":
  "example  : ((2 * 1 + 1) ^ 2 : α) = (3 * 3 : α) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : ((2 * 1 + 1) ^ 2 : α) = (3 * 3 : α)",
  "args": ""},
 {"type": "Fmla.reify v (f₁.and f₂) (a ∨ b)",
  "tactic-prompt":
  "theorem (h₁ : Fmla.reify v f₁ a)  (h₂ : Fmla.reify v f₂ b) : Fmla.reify v (f₁.and f₂) (a ∨ b) := by refine ⟨fun H => by_contra fun hn => H ⟨fun c h => by_contra fun hn' => ?_⟩⟩; sorry",
  "name": "Fmla.reify_or",
  "kind": "theorem",
  "first-tactic":
  "refine ⟨fun H => by_contra fun hn => H ⟨fun c h => by_contra fun hn' => ?_⟩⟩",
  "core-prompt":
  "(h₁ : Fmla.reify v f₁ a)  (h₂ : Fmla.reify v f₂ b) : Fmla.reify v (f₁.and f₂) (a ∨ b)",
  "args": "(h₁ : Fmla.reify v f₁ a)  (h₂ : Fmla.reify v f₂ b)"},
 {"type": "True",
  "tactic-prompt": "example  : True := by find; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "find",
  "core-prompt": " : True",
  "args": ""},
 {"type": "HEq a b ↔ HEq (a : α) (b : β)",
  "tactic-prompt":
  "lemma {α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop} {α β : Sort _}  {p : α → Prop}  {q : β → Prop}  {a : {x // p x}}    {b : {y // q y}}  (h : α = β)  (h' : HEq p q) : HEq a b ↔ HEq (a : α) (b : β) := by subst h; sorry",
  "name": "heq_iff_coe_heq",
  "kind": "lemma",
  "first-tactic": "subst h",
  "core-prompt":
  "{α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop} {α β : Sort _}  {p : α → Prop}  {q : β → Prop}  {a : {x // p x}}    {b : {y // q y}}  (h : α = β)  (h' : HEq p q) : HEq a b ↔ HEq (a : α) (b : β)",
  "args":
  "{α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop} {α β : Sort _}  {p : α → Prop}  {q : β → Prop}  {a : {x // p x}}    {b : {y // q y}}  (h : α = β)  (h' : HEq p q)"},
 {"type": "injective ((↑·) : Subtype p → α)",
  "tactic-prompt":
  "theorem {α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop} : injective ((↑·) : Subtype p → α) := by intros a b hab; sorry",
  "name": "coe_injective",
  "kind": "theorem",
  "first-tactic": "intros a b hab",
  "core-prompt":
  "{α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop} : injective ((↑·) : Subtype p → α)",
  "args":
  "{α : Sort _}  {β : Sort _}  {γ : Sort _}  {p : α → Prop}  {q : α → Prop}"},
 {"type": "0 < n ↔ n ≠ 0",
  "tactic-prompt":
  "lemma {n : ℕ} : 0 < n ↔ n ≠ 0 := by refine ⟨?_, Nat.pos_of_ne_zero⟩; sorry",
  "name": "pos_iff_ne_zero",
  "kind": "lemma",
  "first-tactic": "refine ⟨?_, Nat.pos_of_ne_zero⟩",
  "core-prompt": "{n : ℕ} : 0 < n ↔ n ≠ 0",
  "args": "{n : ℕ}"},
 {"type": "n.succ = 1 + n",
  "tactic-prompt":
  "lemma (n : ℕ) : n.succ = 1 + n := by rw [Nat.succ_eq_add_one, Nat.add_comm]; sorry",
  "name": "succ_eq_one_add",
  "kind": "lemma",
  "first-tactic": "rw [Nat.succ_eq_add_one, Nat.add_comm]",
  "core-prompt": "(n : ℕ) : n.succ = 1 + n",
  "args": "(n : ℕ)"},
 {"type": "b - a < b",
  "tactic-prompt":
  "lemma {a b : ℕ}  (h₀ : 0 < a)  (h₁ : a ≤ b) : b - a < b := by apply sub_lt _ h₀; sorry",
  "name": "sub_lt_self",
  "kind": "lemma",
  "first-tactic": "apply sub_lt _ h₀",
  "core-prompt": "{a b : ℕ}  (h₀ : 0 < a)  (h₁ : a ≤ b) : b - a < b",
  "args": "{a b : ℕ}  (h₀ : 0 < a)  (h₁ : a ≤ b)"},
 {"type": "m + (n - m) = n",
  "tactic-prompt":
  "lemma {n m : ℕ}  (h : m ≤ n) : m + (n - m) = n := by rw [Nat.add_comm, Nat.sub_add_cancel h]; sorry",
  "name": "add_sub_cancel'",
  "kind": "lemma",
  "first-tactic": "rw [Nat.add_comm, Nat.sub_add_cancel h]",
  "core-prompt": "{n m : ℕ}  (h : m ≤ n) : m + (n - m) = n",
  "args": "{n m : ℕ}  (h : m ≤ n)"},
 {"type": "k - n < m",
  "tactic-prompt":
  "lemma {n k m : ℕ}  (H : n ≤ k)  (h : k < n + m) : k - n < m := by have := Nat.sub_le_sub_right (succ_le_of_lt h) n; sorry",
  "name": "sub_lt_left_of_lt_add",
  "kind": "lemma",
  "first-tactic": "have := Nat.sub_le_sub_right (succ_le_of_lt h) n",
  "core-prompt": "{n k m : ℕ}  (H : n ≤ k)  (h : k < n + m) : k - n < m",
  "args": "{n k m : ℕ}  (H : n ≤ k)  (h : k < n + m)"},
 {"type": "x ≤ y - k ↔ x + k ≤ y",
  "tactic-prompt":
  "lemma {x y k : ℕ}  (h : k ≤ y) : x ≤ y - k ↔ x + k ≤ y := by rw [← Nat.add_sub_cancel x k, Nat.sub_le_sub_right_iff h, Nat.add_sub_cancel]; sorry",
  "name": "le_sub_iff_add_le",
  "kind": "lemma",
  "first-tactic":
  "rw [← Nat.add_sub_cancel x k, Nat.sub_le_sub_right_iff h, Nat.add_sub_cancel]",
  "core-prompt": "{x y k : ℕ}  (h : k ≤ y) : x ≤ y - k ↔ x + k ≤ y",
  "args": "{x y k : ℕ}  (h : k ≤ y)"},
 {"type": "Nat.min a b = Nat.min b a",
  "tactic-prompt":
  "lemma (a b : ℕ) : Nat.min a b = Nat.min b a := by simp [Nat.min]; sorry",
  "name": "min_comm",
  "kind": "lemma",
  "first-tactic": "simp [Nat.min]",
  "core-prompt": "(a b : ℕ) : Nat.min a b = Nat.min b a",
  "args": "(a b : ℕ)"},
 {"type": "Nat.min a b ≤ a",
  "tactic-prompt":
  "lemma (a b : ℕ) : Nat.min a b ≤ a := by simp [Nat.min]; sorry",
  "name": "min_le_left",
  "kind": "lemma",
  "first-tactic": "simp [Nat.min]",
  "core-prompt": "(a b : ℕ) : Nat.min a b ≤ a",
  "args": "(a b : ℕ)"},
 {"type": "Nat.min a b = a",
  "tactic-prompt":
  "lemma (h : a ≤ b) : Nat.min a b = a := by simp [Nat.min, h]; sorry",
  "name": "min_eq_left",
  "kind": "lemma",
  "first-tactic": "simp [Nat.min, h]",
  "core-prompt": "(h : a ≤ b) : Nat.min a b = a",
  "args": "(h : a ≤ b)"},
 {"type": "Nat.min a b = b",
  "tactic-prompt":
  "lemma (h : b ≤ a) : Nat.min a b = b := by rw [Nat.min_comm a b]; sorry",
  "name": "min_eq_right",
  "kind": "lemma",
  "first-tactic": "rw [Nat.min_comm a b]",
  "core-prompt": "(h : b ≤ a) : Nat.min a b = b",
  "args": "(h : b ≤ a)"},
 {"type": "n * (m / n) ≤ m",
  "tactic-prompt":
  "lemma (m n : ℕ) : n * (m / n) ≤ m := by match n, Nat.eq_zero_or_pos n with\n  | _, Or.inl rfl => rw [Nat.zero_mul]; exact m.zero_le\n  | n, Or.inr h => rw [Nat.mul_comm, ← Nat.le_div_iff_mul_le h]; exact Nat.le_refl _\n\n/- Up -/; sorry",
  "name": "mul_div_le",
  "kind": "lemma",
  "first-tactic":
  "match n, Nat.eq_zero_or_pos n with\n  | _, Or.inl rfl => rw [Nat.zero_mul]; exact m.zero_le\n  | n, Or.inr h => rw [Nat.mul_comm, ← Nat.le_div_iff_mul_le h]; exact Nat.le_refl _\n\n/- Up -/",
  "core-prompt": "(m n : ℕ) : n * (m / n) ≤ m",
  "args": "(m n : ℕ)"},
 {"type": "(gcd m n ∣ m) ∧ (gcd m n ∣ n)",
  "tactic-prompt":
  "theorem (m n : ℕ) : (gcd m n ∣ m) ∧ (gcd m n ∣ n) := by induction m, n using gcd.induction with\n  | H0 n => exact ⟨⟨0, by simp⟩, ⟨1, by simp⟩⟩\n  | H1 m n _ IH =>\n    let ⟨IH₁, IH₂⟩ := IH\n    refine ⟨by rwa [gcd_rec], ?_⟩\n    rw [←gcd_rec] at IH₁\n    rw [←gcd_rec] at IH₂\n    exact (dvd_mod_iff IH₂).1 IH₁; sorry",
  "name": "gcd_dvd",
  "kind": "theorem",
  "first-tactic":
  "induction m, n using gcd.induction with\n  | H0 n => exact ⟨⟨0, by simp⟩, ⟨1, by simp⟩⟩\n  | H1 m n _ IH =>\n    let ⟨IH₁, IH₂⟩ := IH\n    refine ⟨by rwa [gcd_rec], ?_⟩\n    rw [←gcd_rec] at IH₁\n    rw [←gcd_rec] at IH₂\n    exact (dvd_mod_iff IH₂).1 IH₁",
  "core-prompt": "(m n : ℕ) : (gcd m n ∣ m) ∧ (gcd m n ∣ n)",
  "args": "(m n : ℕ)"},
 {"type": "k ∣ m → k ∣ n → k ∣ gcd m n",
  "tactic-prompt":
  "theorem {m n k : ℕ} : k ∣ m → k ∣ n → k ∣ gcd m n := by induction m, n using gcd.induction with\n  | H0 n =>\n    intros _ kn\n    rw [gcd_zero_left]\n    exact kn\n  | H1 m n _ IH =>\n    intros H1 H2\n    rw [gcd_rec]\n    exact IH ((dvd_mod_iff H1).mpr H2) H1; sorry",
  "name": "dvd_gcd",
  "kind": "theorem",
  "first-tactic":
  "induction m, n using gcd.induction with\n  | H0 n =>\n    intros _ kn\n    rw [gcd_zero_left]\n    exact kn\n  | H1 m n _ IH =>\n    intros H1 H2\n    rw [gcd_rec]\n    exact IH ((dvd_mod_iff H1).mpr H2) H1",
  "core-prompt": "{m n k : ℕ} : k ∣ m → k ∣ n → k ∣ gcd m n",
  "args": "{m n k : ℕ}"},
 {"type": "m ∣ n ↔ gcd n m = m",
  "tactic-prompt":
  "theorem {m n : ℕ} : m ∣ n ↔ gcd n m = m := by rw [gcd_comm]; sorry",
  "name": "gcd_eq_right_iff_dvd",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "{m n : ℕ} : m ∣ n ↔ gcd n m = m",
  "args": "{m n : ℕ}"},
 {"type": "gcd (m * n) (m * k) = m * gcd n k",
  "tactic-prompt":
  "theorem (m n k : ℕ) : gcd (m * n) (m * k) = m * gcd n k := by induction n, k using gcd.induction with\n  | H0 k => simp\n  | H1 n k _ IH => rwa [←mul_mod_mul_left, ←gcd_rec, ←gcd_rec] at IH; sorry",
  "name": "gcd_mul_left",
  "kind": "theorem",
  "first-tactic":
  "induction n, k using gcd.induction with\n  | H0 k => simp\n  | H1 n k _ IH => rwa [←mul_mod_mul_left, ←gcd_rec, ←gcd_rec] at IH",
  "core-prompt": "(m n k : ℕ) : gcd (m * n) (m * k) = m * gcd n k",
  "args": "(m n k : ℕ)"},
 {"type": "gcd (m * n) (k * n) = gcd m k * n",
  "tactic-prompt":
  "theorem (m n k : ℕ) : gcd (m * n) (k * n) = gcd m k * n := by rw [Nat.mul_comm m n, Nat.mul_comm k n, Nat.mul_comm (gcd m k) n, gcd_mul_left]; sorry",
  "name": "gcd_mul_right",
  "kind": "theorem",
  "first-tactic":
  "rw [Nat.mul_comm m n, Nat.mul_comm k n, Nat.mul_comm (gcd m k) n, gcd_mul_left]",
  "core-prompt": "(m n k : ℕ) : gcd (m * n) (k * n) = gcd m k * n",
  "args": "(m n k : ℕ)"},
 {"type": "n = 0",
  "tactic-prompt":
  "theorem {m n : ℕ}  (H : gcd m n = 0) : n = 0 := by rw [gcd_comm] at H; sorry",
  "name": "eq_zero_of_gcd_eq_zero_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm] at H",
  "core-prompt": "{m n : ℕ}  (H : gcd m n = 0) : n = 0",
  "args": "{m n : ℕ}  (H : gcd m n = 0)"},
 {"type": "gcd m n = n",
  "tactic-prompt":
  "theorem {m n : ℕ}  (H : n ∣ m) : gcd m n = n := by rw [gcd_comm, gcd_eq_left H]; sorry",
  "name": "gcd_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm, gcd_eq_left H]",
  "core-prompt": "{m n : ℕ}  (H : n ∣ m) : gcd m n = n",
  "args": "{m n : ℕ}  (H : n ∣ m)"},
 {"type": "gcd n (m * n) = n",
  "tactic-prompt":
  "lemma (m n : ℕ) : gcd n (m * n) = n := by rw [gcd_comm, gcd_mul_left_left]; sorry",
  "name": "gcd_mul_left_right",
  "kind": "lemma",
  "first-tactic": "rw [gcd_comm, gcd_mul_left_left]",
  "core-prompt": "(m n : ℕ) : gcd n (m * n) = n",
  "args": "(m n : ℕ)"},
 {"type": "gcd (n * m) n = n",
  "tactic-prompt":
  "lemma (m n : ℕ) : gcd (n * m) n = n := by rw [Nat.mul_comm, gcd_mul_left_left]; sorry",
  "name": "gcd_mul_right_left",
  "kind": "lemma",
  "first-tactic": "rw [Nat.mul_comm, gcd_mul_left_left]",
  "core-prompt": "(m n : ℕ) : gcd (n * m) n = n",
  "args": "(m n : ℕ)"},
 {"type": "gcd n (n * m) = n",
  "tactic-prompt":
  "lemma (m n : ℕ) : gcd n (n * m) = n := by rw [gcd_comm, gcd_mul_right_left]; sorry",
  "name": "gcd_mul_right_right",
  "kind": "lemma",
  "first-tactic": "rw [gcd_comm, gcd_mul_right_left]",
  "core-prompt": "(m n : ℕ) : gcd n (n * m) = n",
  "args": "(m n : ℕ)"},
 {"type": "gcd m (gcd n m) = gcd n m",
  "tactic-prompt":
  "lemma (m n : ℕ) : gcd m (gcd n m) = gcd n m := by rw [gcd_comm n m, gcd_gcd_self_right_left]; sorry",
  "name": "gcd_gcd_self_right_right",
  "kind": "lemma",
  "first-tactic": "rw [gcd_comm n m, gcd_gcd_self_right_left]",
  "core-prompt": "(m n : ℕ) : gcd m (gcd n m) = gcd n m",
  "args": "(m n : ℕ)"},
 {"type": "gcd (gcd n m) m = gcd n m",
  "tactic-prompt":
  "lemma (m n : ℕ) : gcd (gcd n m) m = gcd n m := by rw [gcd_comm, gcd_gcd_self_right_right]; sorry",
  "name": "gcd_gcd_self_left_right",
  "kind": "lemma",
  "first-tactic": "rw [gcd_comm, gcd_gcd_self_right_right]",
  "core-prompt": "(m n : ℕ) : gcd (gcd n m) m = gcd n m",
  "args": "(m n : ℕ)"},
 {"type": "gcd (gcd m n) m = gcd m n",
  "tactic-prompt":
  "lemma (m n : ℕ) : gcd (gcd m n) m = gcd m n := by rw [gcd_comm m n, gcd_gcd_self_left_right]; sorry",
  "name": "gcd_gcd_self_left_left",
  "kind": "lemma",
  "first-tactic": "rw [gcd_comm m n, gcd_gcd_self_left_right]",
  "core-prompt": "(m n : ℕ) : gcd (gcd m n) m = gcd m n",
  "args": "(m n : ℕ)"},
 {"type": "gcd m (n + k * m) = gcd m n",
  "tactic-prompt":
  "lemma (m n k : ℕ) : gcd m (n + k * m) = gcd m n := by simp [gcd_rec m (n + k * m), gcd_rec m n]; sorry",
  "name": "gcd_add_mul_self",
  "kind": "lemma",
  "first-tactic": "simp [gcd_rec m (n + k * m), gcd_rec m n]",
  "core-prompt": "(m n k : ℕ) : gcd m (n + k * m) = gcd m n",
  "args": "(m n k : ℕ)"},
 {"type": "lcm m n = lcm n m",
  "tactic-prompt":
  "theorem (m n : ℕ) : lcm m n = lcm n m := by have h1 : lcm m n = m * n / gcd m n := rfl; sorry",
  "name": "lcm_comm",
  "kind": "theorem",
  "first-tactic": "have h1 : lcm m n = m * n / gcd m n := rfl",
  "core-prompt": "(m n : ℕ) : lcm m n = lcm n m",
  "args": "(m n : ℕ)"},
 {"type": "lcm 0 m = 0",
  "tactic-prompt":
  "theorem (m : ℕ) : lcm 0 m = 0 := by have h : lcm 0 m = 0 * m / gcd 0 m := rfl; sorry",
  "name": "lcm_zero_left",
  "kind": "theorem",
  "first-tactic": "have h : lcm 0 m = 0 * m / gcd 0 m := rfl",
  "core-prompt": "(m : ℕ) : lcm 0 m = 0",
  "args": "(m : ℕ)"},
 {"type": "lcm 1 m = m",
  "tactic-prompt":
  "theorem (m : ℕ) : lcm 1 m = m := by have h : lcm 1 m = 1 * m / gcd 1 m := rfl; sorry",
  "name": "lcm_one_left",
  "kind": "theorem",
  "first-tactic": "have h : lcm 1 m = 1 * m / gcd 1 m := rfl",
  "core-prompt": "(m : ℕ) : lcm 1 m = m",
  "args": "(m : ℕ)"},
 {"type": "gcd m n * lcm m n = m * n",
  "tactic-prompt":
  "theorem (m n : ℕ) : gcd m n * lcm m n = m * n := by have h1 : lcm m n = m * n / gcd m n := rfl; sorry",
  "name": "gcd_mul_lcm",
  "kind": "theorem",
  "first-tactic": "have h1 : lcm m n = m * n / gcd m n := rfl",
  "core-prompt": "(m n : ℕ) : gcd m n * lcm m n = m * n",
  "args": "(m n : ℕ)"},
 {"type": "lcm m n ≠ 0",
  "tactic-prompt":
  "theorem {m n : ℕ}  (hm : m ≠ 0)  (hn : n ≠ 0) : lcm m n ≠ 0 := by intro h; sorry",
  "name": "lcm_ne_zero",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "{m n : ℕ}  (hm : m ≠ 0)  (hn : n ≠ 0) : lcm m n ≠ 0",
  "args": "{m n : ℕ}  (hm : m ≠ 0)  (hn : n ≠ 0)"},
 {"type": "k ∣ n",
  "tactic-prompt":
  "theorem {m n k : ℕ}  (H1 : coprime k m)  (H2 : k ∣ m * n) : k ∣ n := by rw [Nat.mul_comm] at H2; sorry",
  "name": "coprime.dvd_of_dvd_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm] at H2",
  "core-prompt": "{m n k : ℕ}  (H1 : coprime k m)  (H2 : k ∣ m * n) : k ∣ n",
  "args": "{m n k : ℕ}  (H1 : coprime k m)  (H2 : k ∣ m * n)"},
 {"type": "gcd (m * k) n = gcd m n",
  "tactic-prompt":
  "theorem (m : ℕ)  {k n : ℕ}  (H : coprime k n) : gcd (m * k) n = gcd m n := by rw [Nat.mul_comm m k, H.gcd_mul_left_cancel m]; sorry",
  "name": "coprime.gcd_mul_right_cancel",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm m k, H.gcd_mul_left_cancel m]",
  "core-prompt":
  "(m : ℕ)  {k n : ℕ}  (H : coprime k n) : gcd (m * k) n = gcd m n",
  "args": "(m : ℕ)  {k n : ℕ}  (H : coprime k n)"},
 {"type": "gcd m (k * n) = gcd m n",
  "tactic-prompt":
  "theorem {k m : ℕ}  (n : ℕ)  (H : coprime k m) : gcd m (k * n) = gcd m n := by rw [gcd_comm m n, gcd_comm m (k * n), H.gcd_mul_left_cancel n]; sorry",
  "name": "coprime.gcd_mul_left_cancel_right",
  "kind": "theorem",
  "first-tactic":
  "rw [gcd_comm m n, gcd_comm m (k * n), H.gcd_mul_left_cancel n]",
  "core-prompt":
  "{k m : ℕ}  (n : ℕ)  (H : coprime k m) : gcd m (k * n) = gcd m n",
  "args": "{k m : ℕ}  (n : ℕ)  (H : coprime k m)"},
 {"type": "gcd m (n * k) = gcd m n",
  "tactic-prompt":
  "theorem {k m : ℕ}  (n : ℕ)  (H : coprime k m) : gcd m (n * k) = gcd m n := by rw [Nat.mul_comm n k, H.gcd_mul_left_cancel_right n]; sorry",
  "name": "coprime.gcd_mul_right_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm n k, H.gcd_mul_left_cancel_right n]",
  "core-prompt":
  "{k m : ℕ}  (n : ℕ)  (H : coprime k m) : gcd m (n * k) = gcd m n",
  "args": "{k m : ℕ}  (n : ℕ)  (H : coprime k m)"},
 {"type": "coprime (m / gcd m n) (n / gcd m n)",
  "tactic-prompt":
  "theorem {m n : ℕ}  (H : 0 < gcd m n) : coprime (m / gcd m n) (n / gcd m n) := by rw [coprime_iff_gcd_eq_one, gcd_div (gcd_dvd_left m n) (gcd_dvd_right m n), Nat.div_self H]; sorry",
  "name": "coprime_div_gcd_div_gcd",
  "kind": "theorem",
  "first-tactic":
  "rw [coprime_iff_gcd_eq_one, gcd_div (gcd_dvd_left m n) (gcd_dvd_right m n), Nat.div_self H]",
  "core-prompt":
  "{m n : ℕ}  (H : 0 < gcd m n) : coprime (m / gcd m n) (n / gcd m n)",
  "args": "{m n : ℕ}  (H : 0 < gcd m n)"},
 {"type": "coprime m n",
  "tactic-prompt":
  "theorem {m k n : ℕ}  (H1 : m ∣ k)  (H2 : coprime k n) : coprime m n := by apply eq_one_of_dvd_one; sorry",
  "name": "coprime.coprime_dvd_left",
  "kind": "theorem",
  "first-tactic": "apply eq_one_of_dvd_one",
  "core-prompt": "{m k n : ℕ}  (H1 : m ∣ k)  (H2 : coprime k n) : coprime m n",
  "args": "{m k n : ℕ}  (H1 : m ∣ k)  (H2 : coprime k n)"},
 {"type": "coprime k (m * n) ↔ coprime k m ∧ coprime k n",
  "tactic-prompt":
  "lemma {k m n : ℕ} : coprime k (m * n) ↔ coprime k m ∧ coprime k n := by rw [@coprime_comm (m*n) k, @coprime_comm m k, @coprime_comm n k, coprime_mul_iff_left]; sorry",
  "name": "coprime_mul_iff_right",
  "kind": "lemma",
  "first-tactic":
  "rw [@coprime_comm (m*n) k, @coprime_comm m k, @coprime_comm n k, coprime_mul_iff_left]",
  "core-prompt": "{k m n : ℕ} : coprime k (m * n) ↔ coprime k m ∧ coprime k n",
  "args": "{k m n : ℕ}"},
 {"type": "coprime (m ^ n) k",
  "tactic-prompt":
  "theorem {m k : ℕ}  (n : ℕ)  (H1 : coprime m k) : coprime (m ^ n) k := by induction n; sorry",
  "name": "coprime.pow_left",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "{m k : ℕ}  (n : ℕ)  (H1 : coprime m k) : coprime (m ^ n) k",
  "args": "{m k : ℕ}  (n : ℕ)  (H1 : coprime m k)"},
 {"type": "k = 1",
  "tactic-prompt":
  "theorem {k m : ℕ}  (H : coprime k m)  (d : k ∣ m) : k = 1 := by rw [← H.gcd_eq_one, gcd_eq_left d]; sorry",
  "name": "coprime.eq_one_of_dvd",
  "kind": "theorem",
  "first-tactic": "rw [← H.gcd_eq_one, gcd_eq_left d]",
  "core-prompt": "{k m : ℕ}  (H : coprime k m)  (d : k ∣ m) : k = 1",
  "args": "{k m : ℕ}  (H : coprime k m)  (d : k ∣ m)"},
 {"type": "coprime 0 n ↔ n = 1",
  "tactic-prompt":
  "theorem (n : ℕ) : coprime 0 n ↔ n = 1 := by simp [coprime]; sorry",
  "name": "coprime_zero_left",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : ℕ) : coprime 0 n ↔ n = 1",
  "args": "(n : ℕ)"},
 {"type": "coprime n 0 ↔ n = 1",
  "tactic-prompt":
  "theorem (n : ℕ) : coprime n 0 ↔ n = 1 := by simp [coprime]; sorry",
  "name": "coprime_zero_right",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : ℕ) : coprime n 0 ↔ n = 1",
  "args": "(n : ℕ)"},
 {"type": "coprime 1 n ↔ true",
  "tactic-prompt":
  "theorem (n : ℕ) : coprime 1 n ↔ true := by simp [coprime]; sorry",
  "name": "coprime_one_left_iff",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : ℕ) : coprime 1 n ↔ true",
  "args": "(n : ℕ)"},
 {"type": "coprime n 1 ↔ true",
  "tactic-prompt":
  "theorem (n : ℕ) : coprime n 1 ↔ true := by simp [coprime]; sorry",
  "name": "coprime_one_right_iff",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : ℕ) : coprime n 1 ↔ true",
  "args": "(n : ℕ)"},
 {"type": "coprime n n ↔ n = 1",
  "tactic-prompt":
  "theorem (n : ℕ) : coprime n n ↔ n = 1 := by simp [coprime]; sorry",
  "name": "coprime_self",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : ℕ) : coprime n n ↔ n = 1",
  "args": "(n : ℕ)"},
 {"type": "{ d : {m' // m' ∣ m} × {n' // n' ∣ n} // k = d.1.val * d.2.val }",
  "tactic-prompt":
  "def {m n k : ℕ}  (H : k ∣ m * n) : { d : {m' // m' ∣ m} × {n' // n' ∣ n} // k = d.1.val * d.2.val } := by cases h0 : gcd k m; sorry",
  "name": "prod_dvd_and_dvd_of_dvd_prod",
  "kind": "def",
  "first-tactic": "cases h0 : gcd k m",
  "core-prompt":
  "{m n k : ℕ}  (H : k ∣ m * n) : { d : {m' // m' ∣ m} × {n' // n' ∣ n} // k = d.1.val * d.2.val }",
  "args": "{m n k : ℕ}  (H : k ∣ m * n)"},
 {"type": "n = arr.size",
  "tactic-prompt":
  "theorem {arr : Array α}  {m : Fin n → β}  (H : Agrees arr f m) : n = arr.size := by cases H; sorry",
  "name": "size_eq",
  "kind": "theorem",
  "first-tactic": "cases H",
  "core-prompt":
  "{arr : Array α}  {m : Fin n → β}  (H : Agrees arr f m) : n = arr.size",
  "args": "{arr : Array α}  {m : Fin n → β}  (H : Agrees arr f m)"},
 {"type": "∃ (m : UFModel self.arr.size), m.Models self.arr",
  "tactic-prompt":
  "theorem (self : UnionFind α) : ∃ (m : UFModel self.arr.size), m.Models self.arr := by let ⟨n, m, hm⟩ := self.model; sorry",
  "name": "model'",
  "kind": "theorem",
  "first-tactic": "let ⟨n, m, hm⟩ := self.model",
  "core-prompt":
  "(self : UnionFind α) : ∃ (m : UFModel self.arr.size), m.Models self.arr",
  "args": "(self : UnionFind α)"},
 {"type": "self.rank i < self.rankMax",
  "tactic-prompt":
  "theorem (self : UnionFind α)  (i : Nat) : self.rank i < self.rankMax := by simp [rank]; sorry",
  "name": "lt_rankMax",
  "kind": "theorem",
  "first-tactic": "simp [rank]",
  "core-prompt": "(self : UnionFind α)  (i : Nat) : self.rank i < self.rankMax",
  "args": "(self : UnionFind α)  (i : Nat)"},
 {"type": "a.val = b.val → a = b",
  "tactic-prompt":
  "lemma {a b : Fin n} : a.val = b.val → a = b := by cases a; sorry",
  "name": "Fin.ext",
  "kind": "lemma",
  "first-tactic": "cases a",
  "core-prompt": "{a b : Fin n} : a.val = b.val → a = b",
  "args": "{a b : Fin n}"},
 {"type": "(Fin.ofNat' a (zero_lt_of_lt h)).val = a",
  "tactic-prompt":
  "lemma {n a : Nat}  (h : a < n) : (Fin.ofNat' a (zero_lt_of_lt h)).val = a := by simp only [Fin.ofNat', Nat.mod_eq_of_lt h]; sorry",
  "name": "Fin.val_eq_of_lt",
  "kind": "lemma",
  "first-tactic": "simp only [Fin.ofNat', Nat.mod_eq_of_lt h]",
  "core-prompt":
  "{n a : Nat}  (h : a < n) : (Fin.ofNat' a (zero_lt_of_lt h)).val = a",
  "args": "{n a : Nat}  (h : a < n)"},
 {"type": "(1 : Fin (n + 2)).val = 1",
  "tactic-prompt":
  "lemma  : (1 : Fin (n + 2)).val = 1 := by simp only [OfNat.ofNat, Fin.ofNat]; sorry",
  "name": "Fin.one_val",
  "kind": "lemma",
  "first-tactic": "simp only [OfNat.ofNat, Fin.ofNat]",
  "core-prompt": " : (1 : Fin (n + 2)).val = 1",
  "args": ""},
 {"type": "a % b = a",
  "tactic-prompt":
  "theorem {a b : Fin n}  (h : a < b) : a % b = a := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mod_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt": "{a b : Fin n}  (h : a < b) : a % b = a",
  "args": "{a b : Fin n}  (h : a < b)"},
 {"type": "(Fin.checkedAdd a b).isSome = true ↔ a.val + b.val < n",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedAdd a b).isSome = true ↔ a.val + b.val < n := by by_cases n <= a.val + b.val <;>\n    simp_all [checkedAdd, Option.isSome, overflowingAdd, decide_eq_true, decide_eq_false]; sorry",
  "name": "Fin.checked_add_spec",
  "kind": "lemma",
  "first-tactic":
  "by_cases n <= a.val + b.val <;>\n    simp_all [checkedAdd, Option.isSome, overflowingAdd, decide_eq_true, decide_eq_false]",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedAdd a b).isSome = true ↔ a.val + b.val < n",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "a * 1 = a",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a : Fin n) : a * 1 = a := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mul_one",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n) : a * 1 = a",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n)"},
 {"type": "a * (b + c) = a * b + a * c",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a b c : Fin n) : a * (b + c) = a * b + a * c := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mul_add",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b c : Fin n) : a * (b + c) = a * b + a * c",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b c : Fin n)"},
 {"type": "∀ (a b : Fin n), a - b = a + -b",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] : ∀ (a b : Fin n), a - b = a + -b := by simp [Fin.add_def, Fin.sub_def, Neg.neg]; sorry",
  "name": "Fin.sub_eq_add_neg",
  "kind": "theorem",
  "first-tactic": "simp [Fin.add_def, Fin.sub_def, Neg.neg]",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] : ∀ (a b : Fin n), a - b = a + -b",
  "args": "{n : Nat}  [Nonempty (Fin n)]"},
 {"type": "-a + a = 0",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a : Fin n) : -a + a = 0 := by rw [add_comm, ← Fin.sub_eq_add_neg]; sorry",
  "name": "Fin.add_left_neg",
  "kind": "theorem",
  "first-tactic": "rw [add_comm, ← Fin.sub_eq_add_neg]",
  "core-prompt": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n) : -a + a = 0",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n)"},
 {"type": "a ≤ b → b ≤ a → a = b",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : a ≤ b → b ≤ a → a = b := by intro h1 h2; sorry",
  "name": "Fin.le_antisymm",
  "kind": "lemma",
  "first-tactic": "intro h1 h2",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : a ≤ b → b ≤ a → a = b",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "a[i]? = none",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Nat)  (h : a.size ≤ i) : a[i]? = none := by simp [getElem?_neg, h]; sorry",
  "name": "get?_len_le",
  "kind": "theorem",
  "first-tactic": "simp [getElem?_neg, h]",
  "core-prompt": "(a : Array α)  (i : Nat)  (h : a.size ≤ i) : a[i]? = none",
  "args": "(a : Array α)  (i : Nat)  (h : a.size ≤ i)"},
 {"type": "a.data.get ⟨i, h⟩ = a[i]",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Nat)  (h : i < a.size) : a.data.get ⟨i, h⟩ = a[i] := by by_cases i < a.size <;> simp_all <;> rfl; sorry",
  "name": "data_get_eq_getElem",
  "kind": "theorem",
  "first-tactic": "by_cases i < a.size <;> simp_all <;> rfl",
  "core-prompt":
  "(a : Array α)  (i : Nat)  (h : i < a.size) : a.data.get ⟨i, h⟩ = a[i]",
  "args": "(a : Array α)  (i : Nat)  (h : i < a.size)"},
 {"type": "a.data.get? i = a[i]?",
  "tactic-prompt":
  "theorem (a : Array α)  (i : Nat) : a.data.get? i = a[i]? := by by_cases i < a.size <;> simp_all [getElem?_pos, getElem?_neg, List.get?_eq_get] <;> rfl; sorry",
  "name": "data_get?_eq_getElem?",
  "kind": "theorem",
  "first-tactic":
  "by_cases i < a.size <;> simp_all [getElem?_pos, getElem?_neg, List.get?_eq_get] <;> rfl",
  "core-prompt": "(a : Array α)  (i : Nat) : a.data.get? i = a[i]?",
  "args": "(a : Array α)  (i : Nat)"},
 {"type":
  "haveI : i < (a.push x).size := by simp_all [Nat.lt_succ_iff, le_of_lt]\n    (a.push x)[i] = a[i]",
  "tactic-prompt":
  "theorem (a : Array α)  (x : α)  (i : Nat)  (h : i < a.size) : haveI : i < (a.push x).size := by simp_all [Nat.lt_succ_iff, le_of_lt]\n    (a.push x)[i] = a[i] := by simp only [push, ← data_get_eq_getElem, List.concat_eq_append]; sorry",
  "name": "get_push_lt",
  "kind": "theorem",
  "first-tactic":
  "simp only [push, ← data_get_eq_getElem, List.concat_eq_append]",
  "core-prompt":
  "(a : Array α)  (x : α)  (i : Nat)  (h : i < a.size) : haveI : i < (a.push x).size := by simp_all [Nat.lt_succ_iff, le_of_lt]\n    (a.push x)[i] = a[i]",
  "args": "(a : Array α)  (x : α)  (i : Nat)  (h : i < a.size)"},
 {"type": "(a.push x)[a.size] = x",
  "tactic-prompt":
  "theorem (a : Array α)  (x : α) : (a.push x)[a.size] = x := by simp only [push, ← data_get_eq_getElem, List.concat_eq_append]; sorry",
  "name": "get_push_eq",
  "kind": "theorem",
  "first-tactic":
  "simp only [push, ← data_get_eq_getElem, List.concat_eq_append]",
  "core-prompt": "(a : Array α)  (x : α) : (a.push x)[a.size] = x",
  "args": "(a : Array α)  (x : α)"},
 {"type": "(a.push x)[i]? = some a[i]",
  "tactic-prompt":
  "theorem (a : Array α)  (x : α)  (i : Nat)  (h : i < a.size) : (a.push x)[i]? = some a[i] := by rw [getElem?_pos, get_push_lt]; sorry",
  "name": "get?_push_lt",
  "kind": "theorem",
  "first-tactic": "rw [getElem?_pos, get_push_lt]",
  "core-prompt":
  "(a : Array α)  (x : α)  (i : Nat)  (h : i < a.size) : (a.push x)[i]? = some a[i]",
  "args": "(a : Array α)  (x : α)  (i : Nat)  (h : i < a.size)"},
 {"type": "(a.push x)[a.size]? = some x",
  "tactic-prompt":
  "theorem (a : Array α)  (x : α) : (a.push x)[a.size]? = some x := by rw [getElem?_pos, get_push_eq]; sorry",
  "name": "get?_push_eq",
  "kind": "theorem",
  "first-tactic": "rw [getElem?_pos, get_push_eq]",
  "core-prompt": "(a : Array α)  (x : α) : (a.push x)[a.size]? = some x",
  "args": "(a : Array α)  (x : α)"},
 {"type": "(a.push x)[i] = if h : i < a.size then a[i] else x",
  "tactic-prompt":
  "theorem (a : Array α)  (x : α)  (i : Nat)  (h : i < (a.push x).size) : (a.push x)[i] = if h : i < a.size then a[i] else x := by by_cases i < a.size; sorry",
  "name": "get_push",
  "kind": "theorem",
  "first-tactic": "by_cases i < a.size",
  "core-prompt":
  "(a : Array α)  (x : α)  (i : Nat)  (h : i < (a.push x).size) : (a.push x)[i] = if h : i < a.size then a[i] else x",
  "args": "(a : Array α)  (x : α)  (i : Nat)  (h : i < (a.push x).size)"},
 {"type": "(a.set ⟨i, h⟩ v)[i]'(by simp_all) = v",
  "tactic-prompt":
  "lemma (a : Array α)  (i : Nat)  (h : i < a.size)  (v : α) : (a.set ⟨i, h⟩ v)[i]'(by simp_all) = v := by simp only [set, ← data_get_eq_getElem, List.get_set_eq]; sorry",
  "name": "get_set_eq",
  "kind": "lemma",
  "first-tactic": "simp only [set, ← data_get_eq_getElem, List.get_set_eq]",
  "core-prompt":
  "(a : Array α)  (i : Nat)  (h : i < a.size)  (v : α) : (a.set ⟨i, h⟩ v)[i]'(by simp_all) = v",
  "args": "(a : Array α)  (i : Nat)  (h : i < a.size)  (v : α)"},
 {"type": "(a.set ⟨i, hi⟩ v)[j]'(by simp_all) = a[j]",
  "tactic-prompt":
  "lemma (a : Array α)  {i j : Nat}  (v : α)  (hi : i < a.size)  (hj : j < a.size)      (h : i ≠ j) : (a.set ⟨i, hi⟩ v)[j]'(by simp_all) = a[j] := by simp only [set, ← data_get_eq_getElem, List.get_set_ne h]; sorry",
  "name": "get_set_ne",
  "kind": "lemma",
  "first-tactic": "simp only [set, ← data_get_eq_getElem, List.get_set_ne h]",
  "core-prompt":
  "(a : Array α)  {i j : Nat}  (v : α)  (hi : i < a.size)  (hj : j < a.size)      (h : i ≠ j) : (a.set ⟨i, hi⟩ v)[j]'(by simp_all) = a[j]",
  "args":
  "(a : Array α)  {i j : Nat}  (v : α)  (hi : i < a.size)  (hj : j < a.size)      (h : i ≠ j)"},
 {"type": "(a.set ⟨i, h⟩ v)[i]? = v",
  "tactic-prompt":
  "lemma (a : Array α)  (i : Nat)  (h : i < a.size)  (v : α) : (a.set ⟨i, h⟩ v)[i]? = v := by simp [getElem?_pos, *]; sorry",
  "name": "get?_set_eq",
  "kind": "lemma",
  "first-tactic": "simp [getElem?_pos, *]",
  "core-prompt":
  "(a : Array α)  (i : Nat)  (h : i < a.size)  (v : α) : (a.set ⟨i, h⟩ v)[i]? = v",
  "args": "(a : Array α)  (i : Nat)  (h : i < a.size)  (v : α)"},
 {"type": "(a.set ⟨i, hi⟩ v)[j]? = a[j]?",
  "tactic-prompt":
  "lemma (a : Array α)  {i j : Nat}  (v : α)  (hi : i < a.size)      (h : i ≠ j) : (a.set ⟨i, hi⟩ v)[j]? = a[j]? := by by_cases j < a.size <;> simp [getElem?_pos, getElem?_neg, *]; sorry",
  "name": "get?_set_ne",
  "kind": "lemma",
  "first-tactic":
  "by_cases j < a.size <;> simp [getElem?_pos, getElem?_neg, *]",
  "core-prompt":
  "(a : Array α)  {i j : Nat}  (v : α)  (hi : i < a.size)      (h : i ≠ j) : (a.set ⟨i, hi⟩ v)[j]? = a[j]?",
  "args":
  "(a : Array α)  {i j : Nat}  (v : α)  (hi : i < a.size)      (h : i ≠ j)"},
 {"type": "(a.set ⟨i, hi⟩ v)[j]? = if i = j then some v else a[j]?",
  "tactic-prompt":
  "lemma (a : Array α)  (i j : Nat)  (hi : i < a.size)  (v : α) : (a.set ⟨i, hi⟩ v)[j]? = if i = j then some v else a[j]? := by by_cases i = j <;> simp [*]; sorry",
  "name": "get?_set",
  "kind": "lemma",
  "first-tactic": "by_cases i = j <;> simp [*]",
  "core-prompt":
  "(a : Array α)  (i j : Nat)  (hi : i < a.size)  (v : α) : (a.set ⟨i, hi⟩ v)[j]? = if i = j then some v else a[j]?",
  "args": "(a : Array α)  (i j : Nat)  (hi : i < a.size)  (v : α)"},
 {"type": "(a.set ⟨i, hi⟩ v)[j]'(by simp_all) = if i = j then v else a[j]",
  "tactic-prompt":
  "lemma (a : Array α)  (i j : Nat)  (hi : i < a.size)  (hj : j < a.size)  (v : α) : (a.set ⟨i, hi⟩ v)[j]'(by simp_all) = if i = j then v else a[j] := by by_cases i = j <;> simp [*]; sorry",
  "name": "get_set",
  "kind": "lemma",
  "first-tactic": "by_cases i = j <;> simp [*]",
  "core-prompt":
  "(a : Array α)  (i j : Nat)  (hi : i < a.size)  (hj : j < a.size)  (v : α) : (a.set ⟨i, hi⟩ v)[j]'(by simp_all) = if i = j then v else a[j]",
  "args":
  "(a : Array α)  (i j : Nat)  (hi : i < a.size)  (hj : j < a.size)  (v : α)"},
 {"type": "(repeat' c n).length = n",
  "tactic-prompt":
  "lemma (c : Char)  (n : ℕ) : (repeat' c n).length = n := by simp only [String.length, String.repeat', List.length_repeat']; sorry",
  "name": "length_repeat'",
  "kind": "lemma",
  "first-tactic":
  "simp only [String.length, String.repeat', List.length_repeat']",
  "core-prompt": "(c : Char)  (n : ℕ) : (repeat' c n).length = n",
  "args": "(c : Char)  (n : ℕ)"},
 {"type": "(String.mk l).length = l.length",
  "tactic-prompt":
  "lemma (l : List Char) : (String.mk l).length = l.length := by simp only [String.length]; sorry",
  "name": "length_eq_list_length",
  "kind": "lemma",
  "first-tactic": "simp only [String.length]",
  "core-prompt": "(l : List Char) : (String.mk l).length = l.length",
  "args": "(l : List Char)"},
 {"type": "Prod.map f g p = (f p.1, g p.2)",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : Prod.map f g p = (f p.1, g p.2) := by cases p; sorry",
  "name": "prod_map",
  "kind": "lemma",
  "first-tactic": "cases p",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : Prod.map f g p = (f p.1, g p.2)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β)"},
 {"type": "(map f g p).1 = f (p.1)",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : (map f g p).1 = f (p.1) := by simp; sorry",
  "name": "map_fst",
  "kind": "lemma",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : (map f g p).1 = f (p.1)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β)"},
 {"type": "(map f g p).2 = g (p.2)",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : (map f g p).2 = g (p.2) := by simp; sorry",
  "name": "map_snd",
  "kind": "lemma",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β) : (map f g p).2 = g (p.2)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} (f : α → γ)  (g : β → δ)  (p : α × β)"},
 {"type": "p = q ↔ p.1 = q.1 ∧ p.2 = q.2",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {p q : α × β} : p = q ↔ p.1 = q.1 ∧ p.2 = q.2 := by rw [← @mk.eta _ _ p, ← @mk.eta _ _ q, mk.inj_iff]\n\n-- Port note: in mathlib this is named `ext`, but Lean4 has already defined that to be something\n-- with a slightly different signature.; sorry",
  "name": "ext_iff",
  "kind": "lemma",
  "first-tactic":
  "rw [← @mk.eta _ _ p, ← @mk.eta _ _ q, mk.inj_iff]\n\n-- Port note: in mathlib this is named `ext`, but Lean4 has already defined that to be something\n-- with a slightly different signature.",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {p q : α × β} : p = q ↔ p.1 = q.1 ∧ p.2 = q.2",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {p q : α × β}"},
 {"type": "Prod.map f g = λ p => (f p.1, g p.2)",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ} : Prod.map f g = λ p => (f p.1, g p.2) := by ext <;> simp; sorry",
  "name": "map_def",
  "kind": "lemma",
  "first-tactic": "ext <;> simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ} : Prod.map f g = λ p => (f p.1, g p.2)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ}"},
 {"type": "injective (Prod.map f g)",
  "tactic-prompt":
  "lemma {α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ}  (hf : injective f)  (hg : injective g) : injective (Prod.map f g) := by intros x y h; sorry",
  "name": "Function.injective.prod_map",
  "kind": "lemma",
  "first-tactic": "intros x y h",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ}  (hf : injective f)  (hg : injective g) : injective (Prod.map f g)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {δ : Type _} {f : α → γ}  {g : β → δ}  (hf : injective f)  (hg : injective g)"},
 {"type": "0 < UInt8.size",
  "tactic-prompt": "lemma  : 0 < UInt8.size := by decide; sorry",
  "name": "UInt8.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt8.size",
  "args": ""},
 {"type": "0 < UInt16.size",
  "tactic-prompt": "lemma  : 0 < UInt16.size := by decide; sorry",
  "name": "UInt16.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt16.size",
  "args": ""},
 {"type": "0 < UInt32.size",
  "tactic-prompt": "lemma  : 0 < UInt32.size := by decide; sorry",
  "name": "UInt32.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt32.size",
  "args": ""},
 {"type": "0 < UInt64.size",
  "tactic-prompt": "lemma  : 0 < UInt64.size := by decide; sorry",
  "name": "UInt64.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt64.size",
  "args": ""},
 {"type": "Nat.isValidChar (UInt32.ofNat n).1",
  "tactic-prompt":
  "theorem (n : Nat)  (h : n < size) : Nat.isValidChar (UInt32.ofNat n).1 := by rw [UInt32.val_eq_of_lt]; sorry",
  "name": "toChar_aux",
  "kind": "theorem",
  "first-tactic": "rw [UInt32.val_eq_of_lt]",
  "core-prompt":
  "(n : Nat)  (h : n < size) : Nat.isValidChar (UInt32.ofNat n).1",
  "args": "(n : Nat)  (h : n < size)"},
 {"type": "0 < c.utf8Size",
  "tactic-prompt":
  "theorem (c : Char) : 0 < c.utf8Size := by simp only [utf8Size]; sorry",
  "name": "Char.utf8Size_pos",
  "kind": "theorem",
  "first-tactic": "simp only [utf8Size]",
  "core-prompt": "(c : Char) : 0 < c.utf8Size",
  "args": "(c : Char)"},
 {"type": "a ∈ toList o ↔ a ∈ o",
  "tactic-prompt":
  "theorem {a : α}  {o : Option α} : a ∈ toList o ↔ a ∈ o := by cases o <;> simp [toList, eq_comm]; sorry",
  "name": "Option.mem_toList",
  "kind": "theorem",
  "first-tactic": "cases o <;> simp [toList, eq_comm]",
  "core-prompt": "{a : α}  {o : Option α} : a ∈ toList o ↔ a ∈ o",
  "args": "{a : α}  {o : Option α}"},
 {"type": "a::l ≠ []",
  "tactic-prompt":
  "theorem (a : α)  (l : List α) : a::l ≠ [] := by intro h; sorry",
  "name": "cons_ne_nil",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "(a : α)  (l : List α) : a::l ≠ []",
  "args": "(a : α)  (l : List α)"},
 {"type": "∃ b L, l = b :: L",
  "tactic-prompt":
  "theorem {l : List α}  (h : l ≠ nil) : ∃ b L, l = b :: L := by cases l; sorry",
  "name": "exists_cons_of_ne_nil",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "{l : List α}  (h : l ≠ nil) : ∃ b L, l = b :: L",
  "args": "{l : List α}  (h : l ≠ nil)"},
 {"type": "l ≠ []",
  "tactic-prompt":
  "theorem {a : α}  {l : List α}  (h : a ∈ l) : l ≠ [] := by intro e; sorry",
  "name": "ne_nil_of_mem",
  "kind": "theorem",
  "first-tactic": "intro e",
  "core-prompt": "{a : α}  {l : List α}  (h : a ∈ l) : l ≠ []",
  "args": "{a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "∃ s t : List α, l = s ++ a :: t",
  "tactic-prompt":
  "theorem {a : α}  {l : List α}  (h : a ∈ l) : ∃ s t : List α, l = s ++ a :: t := by induction l; sorry",
  "name": "mem_constructor",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : α}  {l : List α}  (h : a ∈ l) : ∃ s t : List α, l = s ++ a :: t",
  "args": "{a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "f a ∈ map f l",
  "tactic-prompt":
  "theorem (f : α → β)  {a : α}  {l : List α}  (h : a ∈ l) : f a ∈ map f l := by induction l; sorry",
  "name": "mem_map_of_mem",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : α → β)  {a : α}  {l : List α}  (h : a ∈ l) : f a ∈ map f l",
  "args": "(f : α → β)  {a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "∃ a, a ∈ l ∧ f a = b",
  "tactic-prompt":
  "theorem {f : α → β}  {b : β}  {l : List α}  (h : b ∈ List.map f l) : ∃ a, a ∈ l ∧ f a = b := by induction l; sorry",
  "name": "exists_of_mem_map",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{f : α → β}  {b : β}  {l : List α}  (h : b ∈ List.map f l) : ∃ a, a ∈ l ∧ f a = b",
  "args": "{f : α → β}  {b : β}  {l : List α}  (h : b ∈ List.map f l)"},
 {"type": "(∀ i ∈ l.map f, P i) ↔ ∀ j ∈ l, P (f j)",
  "tactic-prompt":
  "lemma {f : α → β}  {l : List α}  {P : β → Prop} : (∀ i ∈ l.map f, P i) ↔ ∀ j ∈ l, P (f j) := by constructor; sorry",
  "name": "forall_mem_map_iff",
  "kind": "lemma",
  "first-tactic": "constructor",
  "core-prompt":
  "{f : α → β}  {l : List α}  {P : β → Prop} : (∀ i ∈ l.map f, P i) ↔ ∀ j ∈ l, P (f j)",
  "args": "{f : α → β}  {l : List α}  {P : β → Prop}"},
 {"type": "List.map f l = [] ↔ l = []",
  "tactic-prompt":
  "lemma {f : α → β}  {l : List α} : List.map f l = [] ↔ l = [] := by constructor; sorry",
  "name": "map_eq_nil",
  "kind": "lemma",
  "first-tactic": "constructor",
  "core-prompt": "{f : α → β}  {l : List α} : List.map f l = [] ↔ l = []",
  "args": "{f : α → β}  {l : List α}"},
 {"type": "length l = 1 ↔ ∃ a, l = [a]",
  "tactic-prompt":
  "theorem {l : List α} : length l = 1 ↔ ∃ a, l = [a] := by constructor; sorry",
  "name": "length_eq_one",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{l : List α} : length l = 1 ↔ ∃ a, l = [a]",
  "args": "{l : List α}"},
 {"type": "(∅ : List α) = []",
  "tactic-prompt":
  "lemma  : (∅ : List α) = [] := by rfl\n--lemma singleton_eq (x : α) : ({x} : List α) = [x] := rfl\n--lemma insert_neg [DecidableEq α] {x : α} {l : List α} (h : x ∉ l) :\n--  has_insert.insert x l = x :: l :=\n--if_neg h\n--lemma insert_pos [DecidableEq α] {x : α} {l : List α} (h : x ∈ l) :\n--  has_insert.insert x l = l :=\n--if_pos h\n-- lemma doubleton_eq [DecidableEq α] {x y : α} (h : x ≠ y) : ({x, y} : List α) = [x, y] := by\n--   rw [insert_neg, singleton_eq]; rwa [singleton_eq, mem_singleton]; sorry",
  "name": "empty_eq",
  "kind": "lemma",
  "first-tactic":
  "rfl\n--lemma singleton_eq (x : α) : ({x} : List α) = [x] := rfl\n--lemma insert_neg [DecidableEq α] {x : α} {l : List α} (h : x ∉ l) :\n--  has_insert.insert x l = x :: l :=\n--if_neg h\n--lemma insert_pos [DecidableEq α] {x : α} {l : List α} (h : x ∈ l) :\n--  has_insert.insert x l = l :=\n--if_pos h\n-- lemma doubleton_eq [DecidableEq α] {x y : α} (h : x ≠ y) : ({x, y} : List α) = [x, y] := by\n--   rw [insert_neg, singleton_eq]; rwa [singleton_eq, mem_singleton]",
  "core-prompt": " : (∅ : List α) = []",
  "args": ""},
 {"type": "(∀ x ∈ [a], p x) ↔ p a",
  "tactic-prompt":
  "theorem {p : α → Prop}  {a : α} : (∀ x ∈ [a], p x) ↔ p a := by simp only [mem_singleton, forall_eq]; sorry",
  "name": "forall_mem_singleton",
  "kind": "theorem",
  "first-tactic": "simp only [mem_singleton, forall_eq]",
  "core-prompt": "{p : α → Prop}  {a : α} : (∀ x ∈ [a], p x) ↔ p a",
  "args": "{p : α → Prop}  {a : α}"},
 {"type": "(∀ x ∈ l₁ ++ l₂, p x) ↔ (∀ x ∈ l₁, p x) ∧ (∀ x ∈ l₂, p x)",
  "tactic-prompt":
  "theorem {p : α → Prop}  {l₁ l₂ : List α} : (∀ x ∈ l₁ ++ l₂, p x) ↔ (∀ x ∈ l₁, p x) ∧ (∀ x ∈ l₂, p x) := by simp only [mem_append, or_imp_distrib, forall_and_distrib]; sorry",
  "name": "forall_mem_append",
  "kind": "theorem",
  "first-tactic": "simp only [mem_append, or_imp_distrib, forall_and_distrib]",
  "core-prompt":
  "{p : α → Prop}  {l₁ l₂ : List α} : (∀ x ∈ l₁ ++ l₂, p x) ↔ (∀ x ∈ l₁, p x) ∧ (∀ x ∈ l₂, p x)",
  "args": "{p : α → Prop}  {l₁ l₂ : List α}"},
 {"type": "a::l ⊆ m ↔ a ∈ m ∧ l ⊆ m",
  "tactic-prompt":
  "theorem {a : α}  {l m : List α} : a::l ⊆ m ↔ a ∈ m ∧ l ⊆ m := by simp only [subset_def, mem_cons, or_imp_distrib, forall_and_distrib, forall_eq]; sorry",
  "name": "cons_subset",
  "kind": "theorem",
  "first-tactic":
  "simp only [subset_def, mem_cons, or_imp_distrib, forall_and_distrib, forall_eq]",
  "core-prompt": "{a : α}  {l m : List α} : a::l ⊆ m ↔ a ∈ m ∧ l ⊆ m",
  "args": "{a : α}  {l m : List α}"},
 {"type": "l₁ ++ l₂ ⊆ l ↔ l₁ ⊆ l ∧ l₂ ⊆ l",
  "tactic-prompt":
  "theorem {l₁ l₂ l : List α} : l₁ ++ l₂ ⊆ l ↔ l₁ ⊆ l ∧ l₂ ⊆ l := by constructor; sorry",
  "name": "append_subset_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{l₁ l₂ l : List α} : l₁ ++ l₂ ⊆ l ↔ l₁ ⊆ l ∧ l₂ ⊆ l",
  "args": "{l₁ l₂ l : List α}"},
 {"type": "x ∈ reverse as ↔ x ∈ as",
  "tactic-prompt":
  "theorem (x : α)  (as : List α) : x ∈ reverse as ↔ x ∈ as := by simp [reverse]; sorry",
  "name": "mem_reverse",
  "kind": "theorem",
  "first-tactic": "simp [reverse]",
  "core-prompt": "(x : α)  (as : List α) : x ∈ reverse as ↔ x ∈ as",
  "args": "(x : α)  (as : List α)"},
 {"type": "x ∈ filter p as ↔ x ∈ as ∧ p x = true",
  "tactic-prompt":
  "theorem (as : List α)  (p : α → Bool)  (x : α) : x ∈ filter p as ↔ x ∈ as ∧ p x = true := by by_cases (p x) <;> simp only [*, and_true, and_false, iff_false]; sorry",
  "name": "mem_filter",
  "kind": "theorem",
  "first-tactic":
  "by_cases (p x) <;> simp only [*, and_true, and_false, iff_false]",
  "core-prompt":
  "(as : List α)  (p : α → Bool)  (x : α) : x ∈ filter p as ↔ x ∈ as ∧ p x = true",
  "args": "(as : List α)  (p : α → Bool)  (x : α)"},
 {"type": "(p ++ q) = [] ↔ p = [] ∧ q = []",
  "tactic-prompt":
  "lemma {p q : List α} : (p ++ q) = [] ↔ p = [] ∧ q = [] := by cases p <;> simp; sorry",
  "name": "append_eq_nil",
  "kind": "lemma",
  "first-tactic": "cases p <;> simp",
  "core-prompt": "{p q : List α} : (p ++ q) = [] ↔ p = [] ∧ q = []",
  "args": "{p q : List α}"},
 {"type": "s ≠ [] → s ++ t ≠ []",
  "tactic-prompt":
  "theorem (s t : List α) : s ≠ [] → s ++ t ≠ [] := by simp_all; sorry",
  "name": "append_ne_nil_of_ne_nil_left",
  "kind": "theorem",
  "first-tactic": "simp_all",
  "core-prompt": "(s t : List α) : s ≠ [] → s ++ t ≠ []",
  "args": "(s t : List α)"},
 {"type": "t ≠ [] → s ++ t ≠ []",
  "tactic-prompt":
  "theorem (s t : List α) : t ≠ [] → s ++ t ≠ [] := by simp_all; sorry",
  "name": "append_ne_nil_of_ne_nil_right",
  "kind": "theorem",
  "first-tactic": "simp_all",
  "core-prompt": "(s t : List α) : t ≠ [] → s ++ t ≠ []",
  "args": "(s t : List α)"},
 {"type": "[] = a ++ b ↔ a = [] ∧ b = []",
  "tactic-prompt":
  "lemma {a b : List α} : [] = a ++ b ↔ a = [] ∧ b = [] := by rw [eq_comm, append_eq_nil]; sorry",
  "name": "nil_eq_append_iff",
  "kind": "lemma",
  "first-tactic": "rw [eq_comm, append_eq_nil]",
  "core-prompt": "{a b : List α} : [] = a ++ b ↔ a = [] ∧ b = []",
  "args": "{a b : List α}"},
 {"type": "a ++ b ≠ []",
  "tactic-prompt":
  "lemma (a b : List α)  (h0 : a ≠ []) : a ++ b ≠ [] := by simp [*]; sorry",
  "name": "append_ne_nil_of_left_ne_nil",
  "kind": "lemma",
  "first-tactic": "simp [*]",
  "core-prompt": "(a b : List α)  (h0 : a ≠ []) : a ++ b ≠ []",
  "args": "(a b : List α)  (h0 : a ≠ [])"},
 {"type":
  "a ++ b = x :: c ↔ (a = [] ∧ b = x :: c) ∨ (∃a', a = x :: a' ∧ c = a' ++ b)",
  "tactic-prompt":
  "lemma {a b c : List α}  {x : α} : a ++ b = x :: c ↔ (a = [] ∧ b = x :: c) ∨ (∃a', a = x :: a' ∧ c = a' ++ b) := by cases a; sorry",
  "name": "append_eq_cons_iff",
  "kind": "lemma",
  "first-tactic": "cases a",
  "core-prompt":
  "{a b c : List α}  {x : α} : a ++ b = x :: c ↔ (a = [] ∧ b = x :: c) ∨ (∃a', a = x :: a' ∧ c = a' ++ b)",
  "args": "{a b c : List α}  {x : α}"},
 {"type":
  "(x :: c : List α) = a ++ b ↔ (a = [] ∧ b = x :: c) ∨ (∃a', a = x :: a' ∧ c = a' ++ b)",
  "tactic-prompt":
  "lemma {a b c : List α}  {x : α} : (x :: c : List α) = a ++ b ↔ (a = [] ∧ b = x :: c) ∨ (∃a', a = x :: a' ∧ c = a' ++ b) := by rw [eq_comm, append_eq_cons_iff]\n\n-- theorem append_eq_append_iff {a b c d : List α} :\n--   a ++ b = c ++ d ↔ (∃ a', c = a ++ a' ∧ b = a' ++ d) ∨ ∃ c', a = c ++ c' ∧ d = c' ++ b := by\n--   induction a generalizing c with\n--   | nil =>\n--     rw [nil_append]; constructor\n--     · rintro rfl; left; exact ⟨_, rfl, rfl⟩\n--     · rintro (⟨a', rfl, rfl⟩ | ⟨a', H, rfl⟩); {rfl}; rw [←append_assoc, ←H]; rfl\n--   | cons a as ih =>\n--     cases c\n--     · simp only [cons_append, nil_append, false_and, exists_false, false_or, exists_eq_left']\n--       exact eq_comm\n--     · simp only [cons_append, @eq_comm _ a, ih, and_assoc, and_or_distrib_left,\n--         exists_and_distrib_left]\n\n-- @[simp] theorem split_at_eq_take_drop : ∀ (n : ℕ) (l : List α), split_at n l = (take n l, drop n l)\n-- | 0, a => rfl\n-- | n+1, [] => rfl\n-- | n+1, x :: xs => by simp only [split_at, split_at_eq_take_drop n xs, take, drop]; sorry",
  "name": "cons_eq_append_iff",
  "kind": "lemma",
  "first-tactic":
  "rw [eq_comm, append_eq_cons_iff]\n\n-- theorem append_eq_append_iff {a b c d : List α} :\n--   a ++ b = c ++ d ↔ (∃ a', c = a ++ a' ∧ b = a' ++ d) ∨ ∃ c', a = c ++ c' ∧ d = c' ++ b := by\n--   induction a generalizing c with\n--   | nil =>\n--     rw [nil_append]; constructor\n--     · rintro rfl; left; exact ⟨_, rfl, rfl⟩\n--     · rintro (⟨a', rfl, rfl⟩ | ⟨a', H, rfl⟩); {rfl}; rw [←append_assoc, ←H]; rfl\n--   | cons a as ih =>\n--     cases c\n--     · simp only [cons_append, nil_append, false_and, exists_false, false_or, exists_eq_left']\n--       exact eq_comm\n--     · simp only [cons_append, @eq_comm _ a, ih, and_assoc, and_or_distrib_left,\n--         exists_and_distrib_left]\n\n-- @[simp] theorem split_at_eq_take_drop : ∀ (n : ℕ) (l : List α), split_at n l = (take n l, drop n l)\n-- | 0, a => rfl\n-- | n+1, [] => rfl\n-- | n+1, x :: xs => by simp only [split_at, split_at_eq_take_drop n xs, take, drop]",
  "core-prompt":
  "{a b c : List α}  {x : α} : (x :: c : List α) = a ++ b ↔ (a = [] ∧ b = x :: c) ∨ (∃a', a = x :: a' ∧ c = a' ++ b)",
  "args": "{a b c : List α}  {x : α}"},
 {"type": "∃ l₁ l₂, l = l₁ ++ l₂ ∧ map f l₁ = s₁ ∧ map f l₂ = s₂",
  "tactic-prompt":
  "theorem {f : α → β}  {l : List α}  {s₁ s₂ : List β}    (h : map f l = s₁ ++ s₂) : ∃ l₁ l₂, l = l₁ ++ l₂ ∧ map f l₁ = s₁ ∧ map f l₂ = s₂ := by have := h; sorry",
  "name": "map_eq_append_split",
  "kind": "theorem",
  "first-tactic": "have := h",
  "core-prompt":
  "{f : α → β}  {l : List α}  {s₁ s₂ : List β}    (h : map f l = s₁ ++ s₂) : ∃ l₁ l₂, l = l₁ ++ l₂ ∧ map f l₁ = s₁ ∧ map f l₂ = s₂",
  "args":
  "{f : α → β}  {l : List α}  {s₁ s₂ : List β}    (h : map f l = s₁ ++ s₂)"},
 {"type":
  "∀ (h₁ : a :: l ≠ nil) (h₂ : l ≠ nil),\n  getLast (a :: l) h₁ = getLast l h₂",
  "tactic-prompt":
  "theorem {a : α}  {l : List α} : ∀ (h₁ : a :: l ≠ nil) (h₂ : l ≠ nil),\n  getLast (a :: l) h₁ = getLast l h₂ := by induction l <;> intros; sorry",
  "name": "getLast_cons",
  "kind": "theorem",
  "first-tactic": "induction l <;> intros",
  "core-prompt":
  "{a : α}  {l : List α} : ∀ (h₁ : a :: l ≠ nil) (h₂ : l ≠ nil),\n  getLast (a :: l) h₁ = getLast l h₂",
  "args": "{a : α}  {l : List α}"},
 {"type": "(h : concat l a ≠ []) → getLast (concat l a) h = a",
  "tactic-prompt":
  "theorem {a : α}  (l : List α) : (h : concat l a ≠ []) → getLast (concat l a) h = a := by rw [concat_eq_append]; sorry",
  "name": "getLast_concat",
  "kind": "theorem",
  "first-tactic": "rw [concat_eq_append]",
  "core-prompt":
  "{a : α}  (l : List α) : (h : concat l a ≠ []) → getLast (concat l a) h = a",
  "args": "{a : α}  (l : List α)"},
 {"type": "l.get? 0 = l.head?",
  "tactic-prompt":
  "theorem (l : List α) : l.get? 0 = l.head? := by cases l <;> rfl; sorry",
  "name": "get?_zero",
  "kind": "theorem",
  "first-tactic": "cases l <;> rfl",
  "core-prompt": "(l : List α) : l.get? 0 = l.head?",
  "args": "(l : List α)"},
 {"type": "i = j",
  "tactic-prompt":
  "theorem {α : Type u}  {xs : List α}  {i j : ℕ}    (h₀ : i < xs.length)    (h₁ : Nodup xs)    (h₂ : xs.get? i = xs.get? j) : i = j := by induction xs generalizing i j with\n  | nil => cases h₀\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases h₁ with\n      | cons ha h₁ => exact ih (Nat.lt_of_succ_lt_succ h₀) h₁ h₂\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at h₂\n      cases h₁; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact ⟨_, h₂⟩; exact ⟨_ , h₂.symm⟩; sorry",
  "name": "get?_injective",
  "kind": "theorem",
  "first-tactic":
  "induction xs generalizing i j with\n  | nil => cases h₀\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases h₁ with\n      | cons ha h₁ => exact ih (Nat.lt_of_succ_lt_succ h₀) h₁ h₂\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at h₂\n      cases h₁; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact ⟨_, h₂⟩; exact ⟨_ , h₂.symm⟩",
  "core-prompt":
  "{α : Type u}  {xs : List α}  {i j : ℕ}    (h₀ : i < xs.length)    (h₁ : Nodup xs)    (h₂ : xs.get? i = xs.get? j) : i = j",
  "args":
  "{α : Type u}  {xs : List α}  {i j : ℕ}    (h₀ : i < xs.length)    (h₁ : Nodup xs)    (h₂ : xs.get? i = xs.get? j)"},
 {"type": "get L i = get L' ⟨i, h ▸ i.2⟩",
  "tactic-prompt":
  "theorem {L L' : List α}  (h : L = L')  (i : Fin  L.length) : get L i = get L' ⟨i, h ▸ i.2⟩ := by cases h; sorry",
  "name": "get_of_eq",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{L L' : List α}  (h : L = L')  (i : Fin  L.length) : get L i = get L' ⟨i, h ▸ i.2⟩",
  "args": "{L L' : List α}  (h : L = L')  (i : Fin  L.length)"},
 {"type": "get [a] n = a",
  "tactic-prompt":
  "theorem (a : α)  (n : Fin 1) : get [a] n = a := by have hn0 : n.1 = 0 := Nat.le_zero_iff.1 (Nat.le_of_lt_succ n.2); sorry",
  "name": "get_singleton",
  "kind": "theorem",
  "first-tactic":
  "have hn0 : n.1 = 0 := Nat.le_zero_iff.1 (Nat.le_of_lt_succ n.2)",
  "core-prompt": "(a : α)  (n : Fin 1) : get [a] n = a",
  "args": "(a : α)  (n : Fin 1)"},
 {"type": "L.get ⟨0, h⟩ = L.head?",
  "tactic-prompt":
  "theorem {L : List α}  (h : 0 < L.length) : L.get ⟨0, h⟩ = L.head? := by cases L; sorry",
  "name": "get_zero",
  "kind": "theorem",
  "first-tactic": "cases L",
  "core-prompt": "{L : List α}  (h : 0 < L.length) : L.get ⟨0, h⟩ = L.head?",
  "args": "{L : List α}  (h : 0 < L.length)"},
 {"type": "n - l₁.length < l₂.length",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  {n : ℕ}    (h₁ : l₁.length ≤ n)  (h₂ : n < (l₁ ++ l₂).length) : n - l₁.length < l₂.length := by rw [length_append] at h₂; sorry",
  "name": "get_append_right_aux",
  "kind": "theorem",
  "first-tactic": "rw [length_append] at h₂",
  "core-prompt":
  "{l₁ l₂ : List α}  {n : ℕ}    (h₁ : l₁.length ≤ n)  (h₂ : n < (l₁ ++ l₂).length) : n - l₁.length < l₂.length",
  "args":
  "{l₁ l₂ : List α}  {n : ℕ}    (h₁ : l₁.length ≤ n)  (h₂ : n < (l₁ ++ l₂).length)"},
 {"type": "(l₁ ++ l₂).get? n = l₁.get? n",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  {n : ℕ}  (hn : n < l₁.length) : (l₁ ++ l₂).get? n = l₁.get? n := by have hn' : n < (l₁ ++ l₂).length := Nat.lt_of_lt_of_le hn $ by\n    rw [length_append] <;> exact Nat.le_add_right _ _; sorry",
  "name": "get?_append",
  "kind": "theorem",
  "first-tactic":
  "have hn' : n < (l₁ ++ l₂).length := Nat.lt_of_lt_of_le hn $ by\n    rw [length_append] <;> exact Nat.le_add_right _ _",
  "core-prompt":
  "{l₁ l₂ : List α}  {n : ℕ}  (hn : n < l₁.length) : (l₁ ++ l₂).get? n = l₁.get? n",
  "args": "{l₁ l₂ : List α}  {n : ℕ}  (hn : n < l₁.length)"},
 {"type":
  "(x :: xs).get ⟨n, by simp [h]⟩ = (x :: xs).getLast (cons_ne_nil x xs)",
  "tactic-prompt":
  "theorem (x : α)  (xs : List α)  (n : ℕ)  (h : n = xs.length) : (x :: xs).get ⟨n, by simp [h]⟩ = (x :: xs).getLast (cons_ne_nil x xs) := by rw [getLast_eq_get]; sorry",
  "name": "get_cons_length",
  "kind": "theorem",
  "first-tactic": "rw [getLast_eq_get]",
  "core-prompt":
  "(x : α)  (xs : List α)  (n : ℕ)  (h : n = xs.length) : (x :: xs).get ⟨n, by simp [h]⟩ = (x :: xs).getLast (cons_ne_nil x xs)",
  "args": "(x : α)  (xs : List α)  (n : ℕ)  (h : n = xs.length)"},
 {"type": "(l.set i a).get ⟨i, h⟩ = a",
  "tactic-prompt":
  "theorem (l : List α)  (i : ℕ)  (a : α)  (h : i < (l.set i a).length) : (l.set i a).get ⟨i, h⟩ = a := by rw [← Option.some_inj, ← get?_eq_get, get?_set_eq, get?_eq_get] <;> simp_all; sorry",
  "name": "get_set_eq",
  "kind": "theorem",
  "first-tactic":
  "rw [← Option.some_inj, ← get?_eq_get, get?_set_eq, get?_eq_get] <;> simp_all",
  "core-prompt":
  "(l : List α)  (i : ℕ)  (a : α)  (h : i < (l.set i a).length) : (l.set i a).get ⟨i, h⟩ = a",
  "args": "(l : List α)  (i : ℕ)  (a : α)  (h : i < (l.set i a).length)"},
 {"type": "(l.set i a).get ⟨j, hj⟩ = l.get ⟨j, by simp at hj; exact hj⟩",
  "tactic-prompt":
  "theorem {l : List α}  {i j : ℕ}  (h : i ≠ j)  (a : α)    (hj : j < (l.set i a).length) : (l.set i a).get ⟨j, hj⟩ = l.get ⟨j, by simp at hj; exact hj⟩ := by rw [← Option.some_inj, ← List.get?_eq_get, List.get?_set_ne _ _ h, List.get?_eq_get]; sorry",
  "name": "get_set_ne",
  "kind": "theorem",
  "first-tactic":
  "rw [← Option.some_inj, ← List.get?_eq_get, List.get?_set_ne _ _ h, List.get?_eq_get]",
  "core-prompt":
  "{l : List α}  {i j : ℕ}  (h : i ≠ j)  (a : α)    (hj : j < (l.set i a).length) : (l.set i a).get ⟨j, hj⟩ = l.get ⟨j, by simp at hj; exact hj⟩",
  "args":
  "{l : List α}  {i j : ℕ}  (h : i ≠ j)  (a : α)    (hj : j < (l.set i a).length)"},
 {"type": "insert a l = l",
  "tactic-prompt":
  "theorem [DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l) : insert a l = l := by simp only [insert, if_pos h]; sorry",
  "name": "insert_of_mem",
  "kind": "theorem",
  "first-tactic": "simp only [insert, if_pos h]",
  "core-prompt":
  "[DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l) : insert a l = l",
  "args": "[DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "insert a l = a :: l",
  "tactic-prompt":
  "theorem [DecidableEq α] {a : α}  {l : List α}  (h : a ∉ l) : insert a l = a :: l := by simp only [insert, if_neg h]; sorry",
  "name": "insert_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp only [insert, if_neg h]",
  "core-prompt":
  "[DecidableEq α] {a : α}  {l : List α}  (h : a ∉ l) : insert a l = a :: l",
  "args": "[DecidableEq α] {a : α}  {l : List α}  (h : a ∉ l)"},
 {"type": "a ∈ insert b l ↔ a = b ∨ a ∈ l",
  "tactic-prompt":
  "theorem [DecidableEq α] {a b : α}  {l : List α} : a ∈ insert b l ↔ a = b ∨ a ∈ l := by by_cases h : b ∈ l; sorry",
  "name": "mem_insert_iff",
  "kind": "theorem",
  "first-tactic": "by_cases h : b ∈ l",
  "core-prompt":
  "[DecidableEq α] {a b : α}  {l : List α} : a ∈ insert b l ↔ a = b ∨ a ∈ l",
  "args": "[DecidableEq α] {a b : α}  {l : List α}"},
 {"type": "length (insert a l) = length l",
  "tactic-prompt":
  "theorem [DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l) : length (insert a l) = length l := by rw [insert_of_mem h]; sorry",
  "name": "length_insert_of_mem",
  "kind": "theorem",
  "first-tactic": "rw [insert_of_mem h]",
  "core-prompt":
  "[DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l) : length (insert a l) = length l",
  "args": "[DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "length (insert a l) = length l + 1",
  "tactic-prompt":
  "theorem [DecidableEq α] {a : α}  {l : List α}  (h : a ∉ l) : length (insert a l) = length l + 1 := by rw [insert_of_not_mem h]; sorry",
  "name": "length_insert_of_not_mem",
  "kind": "theorem",
  "first-tactic": "rw [insert_of_not_mem h]",
  "core-prompt":
  "[DecidableEq α] {a : α}  {l : List α}  (h : a ∉ l) : length (insert a l) = length l + 1",
  "args": "[DecidableEq α] {a : α}  {l : List α}  (h : a ∉ l)"},
 {"type": "(a :: l).erasep p = l",
  "tactic-prompt":
  "theorem {p : α → Prop}  [DecidablePred p] {a : α}  {l : List α}  (h : p a) : (a :: l).erasep p = l := by simp [erasep_cons, h]; sorry",
  "name": "erasep_cons_of_pos",
  "kind": "theorem",
  "first-tactic": "simp [erasep_cons, h]",
  "core-prompt":
  "{p : α → Prop}  [DecidablePred p] {a : α}  {l : List α}  (h : p a) : (a :: l).erasep p = l",
  "args": "{p : α → Prop}  [DecidablePred p] {a : α}  {l : List α}  (h : p a)"},
 {"type": "(a::l).erasep p = a :: l.erasep p",
  "tactic-prompt":
  "theorem {p : α → Prop}  [DecidablePred p] {a : α}  {l : List α}  (h : ¬ p a) : (a::l).erasep p = a :: l.erasep p := by simp [erasep_cons, h]; sorry",
  "name": "erasep_cons_of_neg",
  "kind": "theorem",
  "first-tactic": "simp [erasep_cons, h]",
  "core-prompt":
  "{p : α → Prop}  [DecidablePred p] {a : α}  {l : List α}  (h : ¬ p a) : (a::l).erasep p = a :: l.erasep p",
  "args":
  "{p : α → Prop}  [DecidablePred p] {a : α}  {l : List α}  (h : ¬ p a)"},
 {"type": "l.erasep p = l",
  "tactic-prompt":
  "theorem {p : α → Prop}  [DecidablePred p] {l : List α}    (h : ∀ a, a ∈ l → ¬ p a) : l.erasep p = l := by induction l; sorry",
  "name": "erasep_of_forall_not",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{p : α → Prop}  [DecidablePred p] {l : List α}    (h : ∀ a, a ∈ l → ¬ p a) : l.erasep p = l",
  "args":
  "{p : α → Prop}  [DecidablePred p] {l : List α}    (h : ∀ a, a ∈ l → ¬ p a)"},
 {"type":
  "l.erasep p = l ∨\n      ∃ a l₁ l₂, (∀ b ∈ l₁, ¬ p b) ∧ p a ∧ l = l₁ ++ a :: l₂ ∧ l.erasep p = l₁ ++ l₂",
  "tactic-prompt":
  "theorem {p : α → Prop}  [DecidablePred p] (p : α → Prop)  [DecidablePred p]  (l : List α) : l.erasep p = l ∨\n      ∃ a l₁ l₂, (∀ b ∈ l₁, ¬ p b) ∧ p a ∧ l = l₁ ++ a :: l₂ ∧ l.erasep p = l₁ ++ l₂ := by by_cases h : ∃ a ∈ l, p a; sorry",
  "name": "exists_or_eq_self_of_erasep",
  "kind": "theorem",
  "first-tactic": "by_cases h : ∃ a ∈ l, p a",
  "core-prompt":
  "{p : α → Prop}  [DecidablePred p] (p : α → Prop)  [DecidablePred p]  (l : List α) : l.erasep p = l ∨\n      ∃ a l₁ l₂, (∀ b ∈ l₁, ¬ p b) ∧ p a ∧ l = l₁ ++ a :: l₂ ∧ l.erasep p = l₁ ++ l₂",
  "args":
  "{p : α → Prop}  [DecidablePred p] (p : α → Prop)  [DecidablePred p]  (l : List α)"},
 {"type": "a ∈ l.erasep p ↔ a ∈ l",
  "tactic-prompt":
  "theorem {a : α}  {l : List α}  (pa : ¬ p a) : a ∈ l.erasep p ↔ a ∈ l := by refine ⟨mem_of_mem_erasep, fun al => ?_⟩; sorry",
  "name": "mem_erasep_of_neg",
  "kind": "theorem",
  "first-tactic": "refine ⟨mem_of_mem_erasep, fun al => ?_⟩",
  "core-prompt": "{a : α}  {l : List α}  (pa : ¬ p a) : a ∈ l.erasep p ↔ a ∈ l",
  "args": "{a : α}  {l : List α}  (pa : ¬ p a)"},
 {"type": "(b :: l).erase a = if b = a then l else b :: l.erase a",
  "tactic-prompt":
  "theorem [DecidableEq α] (a b : α)  (l : List α) : (b :: l).erase a = if b = a then l else b :: l.erase a := by by_cases h : a = b; sorry",
  "name": "erase_cons",
  "kind": "theorem",
  "first-tactic": "by_cases h : a = b",
  "core-prompt":
  "[DecidableEq α] (a b : α)  (l : List α) : (b :: l).erase a = if b = a then l else b :: l.erase a",
  "args": "[DecidableEq α] (a b : α)  (l : List α)"},
 {"type": "(a :: l).erase a = l",
  "tactic-prompt":
  "theorem [DecidableEq α] (a : α)  (l : List α) : (a :: l).erase a = l := by simp [erase_cons]; sorry",
  "name": "erase_cons_head",
  "kind": "theorem",
  "first-tactic": "simp [erase_cons]",
  "core-prompt": "[DecidableEq α] (a : α)  (l : List α) : (a :: l).erase a = l",
  "args": "[DecidableEq α] (a : α)  (l : List α)"},
 {"type": "(b::l).erase a = b :: l.erase a",
  "tactic-prompt":
  "theorem [DecidableEq α] {a b : α}  (l : List α)  (h : b ≠ a) : (b::l).erase a = b :: l.erase a := by simp only [erase_cons, if_neg h]; sorry",
  "name": "erase_cons_tail",
  "kind": "theorem",
  "first-tactic": "simp only [erase_cons, if_neg h]",
  "core-prompt":
  "[DecidableEq α] {a b : α}  (l : List α)  (h : b ≠ a) : (b::l).erase a = b :: l.erase a",
  "args": "[DecidableEq α] {a b : α}  (l : List α)  (h : b ≠ a)"},
 {"type": "l.erase a = l.erasep (Eq a)",
  "tactic-prompt":
  "theorem [DecidableEq α] (a : α)  (l : List α) : l.erase a = l.erasep (Eq a) := by induction l; sorry",
  "name": "erase_eq_erasep",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "[DecidableEq α] (a : α)  (l : List α) : l.erase a = l.erasep (Eq a)",
  "args": "[DecidableEq α] (a : α)  (l : List α)"},
 {"type": "l.erase a = l",
  "tactic-prompt":
  "theorem [DecidableEq α] {a : α}  {l : List α}  (h : a ∉ l) : l.erase a = l := by induction l; sorry",
  "name": "erase_of_not_mem",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "[DecidableEq α] {a : α}  {l : List α}  (h : a ∉ l) : l.erase a = l",
  "args": "[DecidableEq α] {a : α}  {l : List α}  (h : a ∉ l)"},
 {"type": "length (l.erase a) = Nat.pred (length l)",
  "tactic-prompt":
  "theorem [DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l) : length (l.erase a) = Nat.pred (length l) := by rw [erase_eq_erasep]; sorry",
  "name": "length_erase_of_mem",
  "kind": "theorem",
  "first-tactic": "rw [erase_eq_erasep]",
  "core-prompt":
  "[DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l) : length (l.erase a) = Nat.pred (length l)",
  "args": "[DecidableEq α] {a : α}  {l : List α}  (h : a ∈ l)"},
 {"type": "(l₁++l₂).erase a = (l₁ ++ l₂.erase a)",
  "tactic-prompt":
  "theorem [DecidableEq α] {a : α}  {l₁ : List α}  (l₂ : List α)  (h : a ∉ l₁) : (l₁++l₂).erase a = (l₁ ++ l₂.erase a) := by rw [erase_eq_erasep, erase_eq_erasep, erasep_append_right]; sorry",
  "name": "erase_append_right",
  "kind": "theorem",
  "first-tactic": "rw [erase_eq_erasep, erase_eq_erasep, erasep_append_right]",
  "core-prompt":
  "[DecidableEq α] {a : α}  {l₁ : List α}  (l₂ : List α)  (h : a ∉ l₁) : (l₁++l₂).erase a = (l₁ ++ l₂.erase a)",
  "args":
  "[DecidableEq α] {a : α}  {l₁ : List α}  (l₂ : List α)  (h : a ∉ l₁)"},
 {"type": "l.erase a ⊆ l",
  "tactic-prompt":
  "theorem [DecidableEq α] (a : α)  (l : List α) : l.erase a ⊆ l := by rw [erase_eq_erasep]; sorry",
  "name": "erase_subset",
  "kind": "theorem",
  "first-tactic": "rw [erase_eq_erasep]",
  "core-prompt": "[DecidableEq α] (a : α)  (l : List α) : l.erase a ⊆ l",
  "args": "[DecidableEq α] (a : α)  (l : List α)"},
 {"type": "a ∈ l.erase b ↔ a ∈ l",
  "tactic-prompt":
  "theorem [DecidableEq α] {a b : α}  {l : List α}  (ab : a ≠ b) : a ∈ l.erase b ↔ a ∈ l := by rw [erase_eq_erasep]; sorry",
  "name": "mem_erase_of_ne",
  "kind": "theorem",
  "first-tactic": "rw [erase_eq_erasep]",
  "core-prompt":
  "[DecidableEq α] {a b : α}  {l : List α}  (ab : a ≠ b) : a ∈ l.erase b ↔ a ∈ l",
  "args": "[DecidableEq α] {a b : α}  {l : List α}  (ab : a ≠ b)"},
 {"type": "disjoint l₁ l₂ ↔ ∀ ⦃a⦄, a ∈ l₁ → a ∉ l₂",
  "tactic-prompt":
  "lemma [DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α} : disjoint l₁ l₂ ↔ ∀ ⦃a⦄, a ∈ l₁ → a ∉ l₂ := by simp [disjoint]; sorry",
  "name": "disjoint_left",
  "kind": "lemma",
  "first-tactic": "simp [disjoint]",
  "core-prompt":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α} : disjoint l₁ l₂ ↔ ∀ ⦃a⦄, a ∈ l₁ → a ∉ l₂",
  "args":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}"},
 {"type": "disjoint [a] l ↔ a ∉ l",
  "tactic-prompt":
  "lemma [DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α} : disjoint [a] l ↔ a ∉ l := by simp [disjoint]\n\n-- TODO: this lemma is marked with priority 1100 in mathlib3; sorry",
  "name": "singleton_disjoint",
  "kind": "lemma",
  "first-tactic":
  "simp [disjoint]\n\n-- TODO: this lemma is marked with priority 1100 in mathlib3",
  "core-prompt":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α} : disjoint [a] l ↔ a ∉ l",
  "args":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}"},
 {"type": "disjoint (l₁ ++ l₂) l ↔ disjoint l₁ l ∧ disjoint l₂ l",
  "tactic-prompt":
  "lemma [DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α} : disjoint (l₁ ++ l₂) l ↔ disjoint l₁ l ∧ disjoint l₂ l := by simp [disjoint, or_imp_distrib, forall_and_distrib]\n\n-- @[simp] lemma disjoint_append_right : disjoint l (l₁ ++ l₂) ↔ disjoint l l₁ ∧ disjoint l l₂ :=\n-- disjoint_comm.trans $ by simp [disjoint_comm, disjoint_append_left]; sorry",
  "name": "disjoint_append_left",
  "kind": "lemma",
  "first-tactic":
  "simp [disjoint, or_imp_distrib, forall_and_distrib]\n\n-- @[simp] lemma disjoint_append_right : disjoint l (l₁ ++ l₂) ↔ disjoint l l₁ ∧ disjoint l l₂ :=\n-- disjoint_comm.trans $ by simp [disjoint_comm, disjoint_append_left]",
  "core-prompt":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α} : disjoint (l₁ ++ l₂) l ↔ disjoint l₁ l ∧ disjoint l₂ l",
  "args":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}"},
 {"type": "nil.union l = l",
  "tactic-prompt":
  "theorem [DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (l : List α) : nil.union l = l := by simp [List.union, foldr]; sorry",
  "name": "nil_union",
  "kind": "theorem",
  "first-tactic": "simp [List.union, foldr]",
  "core-prompt":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (l : List α) : nil.union l = l",
  "args":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (l : List α)"},
 {"type": "(a :: l₁).union l₂ = insert a (l₁.union l₂)",
  "tactic-prompt":
  "theorem [DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (a : α)  (l₁ l₂ : List α) : (a :: l₁).union l₂ = insert a (l₁.union l₂) := by simp [List.union, foldr]; sorry",
  "name": "cons_union",
  "kind": "theorem",
  "first-tactic": "simp [List.union, foldr]",
  "core-prompt":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (a : α)  (l₁ l₂ : List α) : (a :: l₁).union l₂ = insert a (l₁.union l₂)",
  "args":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (a : α)  (l₁ l₂ : List α)"},
 {"type": "x ∈ l₁.union l₂ ↔ x ∈ l₁ ∨ x ∈ l₂",
  "tactic-prompt":
  "theorem [DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] [DecidableEq α]  {x : α}  {l₁ l₂ : List α} : x ∈ l₁.union l₂ ↔ x ∈ l₁ ∨ x ∈ l₂ := by induction l₁; sorry",
  "name": "mem_union_iff",
  "kind": "theorem",
  "first-tactic": "induction l₁",
  "core-prompt":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] [DecidableEq α]  {x : α}  {l₁ l₂ : List α} : x ∈ l₁.union l₂ ↔ x ∈ l₁ ∨ x ∈ l₂",
  "args":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] [DecidableEq α]  {x : α}  {l₁ l₂ : List α}"},
 {"type": "x ∈ l₁.inter l₂ ↔ x ∈ l₁ ∧ x ∈ l₂",
  "tactic-prompt":
  "theorem [DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] [DecidableEq α]  {x : α}  {l₁ l₂ : List α} : x ∈ l₁.inter l₂ ↔ x ∈ l₁ ∧ x ∈ l₂ := by cases l₁ <;> simp [List.inter, mem_filter]; sorry",
  "name": "mem_inter_iff",
  "kind": "theorem",
  "first-tactic": "cases l₁ <;> simp [List.inter, mem_filter]",
  "core-prompt":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] [DecidableEq α]  {x : α}  {l₁ l₂ : List α} : x ∈ l₁.inter l₂ ↔ x ∈ l₁ ∧ x ∈ l₂",
  "args":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] [DecidableEq α]  {x : α}  {l₁ l₂ : List α}"},
 {"type": "(x, y) ∈ product xs ys <-> (x ∈ xs ∧ y ∈ ys)",
  "tactic-prompt":
  "theorem [DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (xs : List α)  (ys : List β)  (x : α)  (y : β) : (x, y) ∈ product xs ys <-> (x ∈ xs ∧ y ∈ ys) := by constructor; sorry",
  "name": "product_spec",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (xs : List α)  (ys : List β)  (x : α)  (y : β) : (x, y) ∈ product xs ys <-> (x ∈ xs ∧ y ∈ ys)",
  "args":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (xs : List α)  (ys : List β)  (x : α)  (y : β)"},
 {"type": "(leftpad n a l).length = max n l.length",
  "tactic-prompt":
  "theorem [DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (n : ℕ)  (a : α)  (l : List α) : (leftpad n a l).length = max n l.length := by simp only [leftpad, length_append, length_repeat', Nat.sub_add_eq_max]; sorry",
  "name": "leftpad_length",
  "kind": "theorem",
  "first-tactic":
  "simp only [leftpad, length_append, length_repeat', Nat.sub_add_eq_max]",
  "core-prompt":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (n : ℕ)  (a : α)  (l : List α) : (leftpad n a l).length = max n l.length",
  "args":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (n : ℕ)  (a : α)  (l : List α)"},
 {"type": "isPrefix (repeat' a (n - length l)) (leftpad n a l)",
  "tactic-prompt":
  "theorem [DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (n : ℕ)  (a : α)  (l : List α) : isPrefix (repeat' a (n - length l)) (leftpad n a l) := by simp only [isPrefix, leftpad]; sorry",
  "name": "leftpad_prefix",
  "kind": "theorem",
  "first-tactic": "simp only [isPrefix, leftpad]",
  "core-prompt":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (n : ℕ)  (a : α)  (l : List α) : isPrefix (repeat' a (n - length l)) (leftpad n a l)",
  "args":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (n : ℕ)  (a : α)  (l : List α)"},
 {"type": "isSuffix l (leftpad n a l)",
  "tactic-prompt":
  "theorem [DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (n : ℕ)  (a : α)  (l : List α) : isSuffix l (leftpad n a l) := by simp only [isSuffix, leftpad]; sorry",
  "name": "leftpad_suffix",
  "kind": "theorem",
  "first-tactic": "simp only [isSuffix, leftpad]",
  "core-prompt":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (n : ℕ)  (a : α)  (l : List α) : isSuffix l (leftpad n a l)",
  "args":
  "[DecidableEq α]  {α : Type _}  {l l₁ l₂ : List α}  {p : α → Prop}  {a : α}  [DecidableEq α] (n : ℕ)  (a : α)  (l : List α)"},
 {"type": "l₂ ~ l₁",
  "tactic-prompt":
  "theorem {l₁ l₂ : List α}  (p : l₁ ~ l₂) : l₂ ~ l₁ := by induction p; sorry",
  "name": "Perm.symm",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{l₁ l₂ : List α}  (p : l₁ ~ l₂) : l₂ ~ l₁",
  "args": "{l₁ l₂ : List α}  (p : l₁ ~ l₂)"},
 {"type": "l₁ ⊆ l₂",
  "tactic-prompt":
  "theorem {α : Type u}  {l₁ l₂ : List α}  (p : l₁ ~ l₂) : l₁ ⊆ l₂ := by induction p; sorry",
  "name": "Perm.subset",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{α : Type u}  {l₁ l₂ : List α}  (p : l₁ ~ l₂) : l₁ ⊆ l₂",
  "args": "{α : Type u}  {l₁ l₂ : List α}  (p : l₁ ~ l₂)"},
 {"type": "b ∈ remove a as ↔ b ∈ as ∧ b ≠ a",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α} : b ∈ remove a as ↔ b ∈ as ∧ b ≠ a := by induction as; sorry",
  "name": "mem_remove_iff",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α} : b ∈ remove a as ↔ b ∈ as ∧ b ≠ a",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α}"},
 {"type": "b ∈ as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α}  (h : b ∈ remove a as) : b ∈ as := by rw [mem_remove_iff] at h; sorry",
  "name": "mem_of_mem_remove",
  "kind": "theorem",
  "first-tactic": "rw [mem_remove_iff] at h",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α}  (h : b ∈ remove a as) : b ∈ as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a b : α}  {as : List α}  (h : b ∈ remove a as)"},
 {"type": "card (a :: as) = card as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as) : card (a :: as) = card as := by simp [card]; sorry",
  "name": "card_cons_of_mem",
  "kind": "theorem",
  "first-tactic": "simp [card]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as) : card (a :: as) = card as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as)"},
 {"type": "card (a :: as) = card as + 1",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as) : card (a :: as) = card as + 1 := by simp [card]; sorry",
  "name": "card_cons_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp [card]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as) : card (a :: as) = card as + 1",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as)"},
 {"type": "card as ≤ card (a :: as)",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ (a : α)  (as : List α) : card as ≤ card (a :: as) := by cases Decidable.em (a ∈ as); sorry",
  "name": "card_le_card_cons",
  "kind": "theorem",
  "first-tactic": "cases Decidable.em (a ∈ as)",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ (a : α)  (as : List α) : card as ≤ card (a :: as)",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ (a : α)  (as : List α)"},
 {"type": "card (insert a as) = card as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as) : card (insert a as) = card as := by simp [h]; sorry",
  "name": "card_insert_of_mem",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as) : card (insert a as) = card as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∈ as)"},
 {"type": "card (insert a as) = card as + 1",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as) : card (insert a as) = card as + 1 := by simp [h]; sorry",
  "name": "card_insert_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as) : card (insert a as) = card as + 1",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {a : α}  {as : List α}  (h : a ∉ as)"},
 {"type": "card (as.map f) ≤ card as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ (f : α → β)  (as : List α) : card (as.map f) ≤ card as := by induction as; sorry",
  "name": "card_map_le",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ (f : α → β)  (as : List α) : card (as.map f) ≤ card as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ (f : α → β)  (as : List α)"},
 {"type": "inj_on f as →  card (as.map f) = card as",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {f : α → β}  {as : List α} : inj_on f as →  card (as.map f) = card as := by induction as; sorry",
  "name": "card_map_eq_of_inj_on",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {f : α → β}  {as : List α} : inj_on f as →  card (as.map f) = card as",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {f : α → β}  {as : List α}"},
 {"type": "card (as.union bs) = card as + card bs",
  "tactic-prompt":
  "theorem [DecidableEq α]  [DecidableEq β]  /- remove -/ {as bs : List α}  (h : disjoint as bs) : card (as.union bs) = card as + card bs := by rw [card_eq_of_equiv (union_equiv_append as bs), card_append_disjoint h]; sorry",
  "name": "card_union_disjoint",
  "kind": "theorem",
  "first-tactic":
  "rw [card_eq_of_equiv (union_equiv_append as bs), card_append_disjoint h]",
  "core-prompt":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {as bs : List α}  (h : disjoint as bs) : card (as.union bs) = card as + card bs",
  "args":
  "[DecidableEq α]  [DecidableEq β]  /- remove -/ {as bs : List α}  (h : disjoint as bs)"},
 {"type": "some a = some b ↔ a = b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _} {a b : α} : some a = some b ↔ a = b := by simp; sorry",
  "name": "some_inj",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {β : Type _} {a b : α} : some a = some b ↔ a = b",
  "args": "{α : Type _}  {β : Type _} {a b : α}"},
 {"type": "some (x.getD y) = x",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {x : Option α}  (hx : x ≠ none)  (y : α) : some (x.getD y) = x := by cases x; sorry",
  "name": "getD_of_ne_none",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {x : Option α}  (hx : x ≠ none)  (y : α) : some (x.getD y) = x",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {x : Option α}  (hx : x ≠ none)  (y : α)"},
 {"type": "x.bind some = x",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} (x : Option α) : x.bind some = x := by cases x <;> rfl; sorry",
  "name": "bind_some",
  "kind": "theorem",
  "first-tactic": "cases x <;> rfl",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} (x : Option α) : x.bind some = x",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _} (x : Option α)"},
 {"type": "o.bind f = none ↔ ∀ b a, a ∈ o → b ∉ f a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {o : Option α}  {f : α → Option β} : o.bind f = none ↔ ∀ b a, a ∈ o → b ∉ f a := by simp only [eq_none_iff_forall_not_mem, not_exists, not_and, mem_def, bind_eq_some]; sorry",
  "name": "bind_eq_none",
  "kind": "theorem",
  "first-tactic":
  "simp only [eq_none_iff_forall_not_mem, not_exists, not_and, mem_def, bind_eq_some]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {o : Option α}  {f : α → Option β} : o.bind f = none ↔ ∀ b a, a ∈ o → b ∉ f a",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {o : Option α}  {f : α → Option β}"},
 {"type": "(x.bind f).bind g = x.bind fun y => (f y).bind g",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} (x : Option α)  (f : α → Option β)  (g : β → Option γ) : (x.bind f).bind g = x.bind fun y => (f y).bind g := by cases x <;> rfl; sorry",
  "name": "bind_assoc",
  "kind": "theorem",
  "first-tactic": "cases x <;> rfl",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} (x : Option α)  (f : α → Option β)  (g : β → Option γ) : (x.bind f).bind g = x.bind fun y => (f y).bind g",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} (x : Option α)  (f : α → Option β)  (g : β → Option γ)"},
 {"type": "x.join = some a ↔ x = some (some a)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {x : Option (Option α)}  {a : α} : x.join = some a ↔ x = some (some a) := by simp; sorry",
  "name": "join_eq_some",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {x : Option (Option α)}  {a : α} : x.join = some a ↔ x = some (some a)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {x : Option (Option α)}  {a : α}"},
 {"type": "x.join ≠ none ↔ ∃ z, x = some (some z)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {x : Option (Option α)} : x.join ≠ none ↔ ∃ z, x = some (some z) := by simp; sorry",
  "name": "join_ne_none",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {x : Option (Option α)} : x.join ≠ none ↔ ∃ z, x = some (some z)",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _} {x : Option (Option α)}"},
 {"type": "¬x.join = none ↔ ∃ z, x = some (some z)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {x : Option (Option α)} : ¬x.join = none ↔ ∃ z, x = some (some z) := by simp\n\n-- theorem join_eq_none {o : Option (Option α)} : o.join = none ↔ o = none ∨ o = some none := by\n--   rcases o with _|_|_; simp; sorry",
  "name": "join_ne_none'",
  "kind": "theorem",
  "first-tactic":
  "simp\n\n-- theorem join_eq_none {o : Option (Option α)} : o.join = none ↔ o = none ∨ o = some none := by\n--   rcases o with _|_|_; simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {x : Option (Option α)} : ¬x.join = none ↔ ∃ z, x = some (some z)",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _} {x : Option (Option α)}"},
 {"type": "x.map f = some b ↔ ∃ a, x = some a ∧ f a = b",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {x : Option α}  {f : α → β}  {b : β} : x.map f = some b ↔ ∃ a, x = some a ∧ f a = b := by cases x <;> simp; sorry",
  "name": "map_eq_some'",
  "kind": "theorem",
  "first-tactic": "cases x <;> simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {x : Option α}  {f : α → β}  {b : β} : x.map f = some b ↔ ∃ a, x = some a ∧ f a = b",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {x : Option α}  {f : α → β}  {b : β}"},
 {"type": "x.map f = none ↔ x = none",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {x : Option α}  {f : α → β} : x.map f = none ↔ x = none := by cases x <;> simp only [map_none', map_some', eq_self_iff_true]; sorry",
  "name": "map_eq_none'",
  "kind": "theorem",
  "first-tactic":
  "cases x <;> simp only [map_none', map_some', eq_self_iff_true]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {x : Option α}  {f : α → β} : x.map f = none ↔ x = none",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {x : Option α}  {f : α → β}"},
 {"type": "x.map f = x.map g",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {f g : α → β}  {x : Option α}  (h : ∀ a ∈ x, f a = g a) : x.map f = x.map g := by cases x <;> simp only [map_none', map_some', h, mem_def]; sorry",
  "name": "map_congr",
  "kind": "theorem",
  "first-tactic": "cases x <;> simp only [map_none', map_some', h, mem_def]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {f g : α → β}  {x : Option α}  (h : ∀ a ∈ x, f a = g a) : x.map f = x.map g",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {f g : α → β}  {x : Option α}  (h : ∀ a ∈ x, f a = g a)"},
 {"type": "(x.map g).map h = x.map (h ∘ g)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} (h : β → γ)  (g : α → β)  (x : Option α) : (x.map g).map h = x.map (h ∘ g) := by cases x <;> simp only [map_none', map_some', ·∘·]; sorry",
  "name": "map_map",
  "kind": "theorem",
  "first-tactic": "cases x <;> simp only [map_none', map_some', ·∘·]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} (h : β → γ)  (g : α → β)  (x : Option α) : (x.map g).map h = x.map (h ∘ g)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} (h : β → γ)  (g : α → β)  (x : Option α)"},
 {"type": "Option.map g ∘ Option.map f = Option.map (g ∘ f)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} (f : α → β)  (g : β → γ) : Option.map g ∘ Option.map f = Option.map (g ∘ f) := by funext x; sorry",
  "name": "map_comp_map",
  "kind": "theorem",
  "first-tactic": "funext x",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} (f : α → β)  (g : β → γ) : Option.map g ∘ Option.map f = Option.map (g ∘ f)",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _} (f : α → β)  (g : β → γ)"},
 {"type": "(x.map (Option.map f)).join = x.join.map f",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {f : α → β}  {x : Option (Option α)} : (x.map (Option.map f)).join = x.join.map f := by cases x; sorry",
  "name": "join_map_eq_map_join",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {f : α → β}  {x : Option (Option α)} : (x.map (Option.map f)).join = x.join.map f",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {f : α → β}  {x : Option (Option α)}"},
 {"type": "x.join.join = (x.map join).join",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {x : Option (Option (Option α))} : x.join.join = (x.map join).join := by (iterate 2 cases x; {simp}; rename_i x); sorry",
  "name": "join_join",
  "kind": "theorem",
  "first-tactic": "(iterate 2 cases x; {simp}; rename_i x)",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {x : Option (Option (Option α))} : x.join.join = (x.map join).join",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {x : Option (Option (Option α))}"},
 {"type": "(none <|> x) = x",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} (x : Option α) : (none <|> x) = x := by cases x <;> rfl; sorry",
  "name": "none_orelse",
  "kind": "theorem",
  "first-tactic": "cases x <;> rfl",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} (x : Option α) : (none <|> x) = x",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _} (x : Option α)"},
 {"type": "(x <|> none) = x",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} (x : Option α) : (x <|> none) = x := by cases x <;> rfl; sorry",
  "name": "orelse_none",
  "kind": "theorem",
  "first-tactic": "cases x <;> rfl",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} (x : Option α) : (x <|> none) = x",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _} (x : Option α)"},
 {"type": "isSome x ↔ ∃ a, x = some a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {x : Option α} : isSome x ↔ ∃ a, x = some a := by cases x <;> simp [isSome] <;> exact ⟨_, rfl⟩; sorry",
  "name": "isSome_iff_exists",
  "kind": "theorem",
  "first-tactic": "cases x <;> simp [isSome] <;> exact ⟨_, rfl⟩",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {x : Option α} : isSome x ↔ ∃ a, x = some a",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _} {x : Option α}"},
 {"type": "isSome a = false ↔ a.isNone = true",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {a : Option α} : isSome a = false ↔ a.isNone = true := by cases a <;> simp; sorry",
  "name": "not_isSome",
  "kind": "theorem",
  "first-tactic": "cases a <;> simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {a : Option α} : isSome a = false ↔ a.isNone = true",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _} {a : Option α}"},
 {"type": "o = some a ↔ ∃ h : o.isSome, Option.get h = a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {o : Option α}  {a : α} : o = some a ↔ ∃ h : o.isSome, Option.get h = a := by cases o <;> simp; sorry",
  "name": "eq_some_iff_get_eq",
  "kind": "theorem",
  "first-tactic": "cases o <;> simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {o : Option α}  {a : α} : o = some a ↔ ∃ h : o.isSome, Option.get h = a",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _} {o : Option α}  {a : α}"},
 {"type": "¬o.isSome ↔ o = none",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {o : Option α} : ¬o.isSome ↔ o = none := by cases o <;> simp; sorry",
  "name": "not_isSome_iff_eq_none",
  "kind": "theorem",
  "first-tactic": "cases o <;> simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {o : Option α} : ¬o.isSome ↔ o = none",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _} {o : Option α}"},
 {"type": "o ≠ none ↔ o.isSome",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {o : Option α} : o ≠ none ↔ o.isSome := by cases o <;> simp; sorry",
  "name": "ne_none_iff_isSome",
  "kind": "theorem",
  "first-tactic": "cases o <;> simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {o : Option α} : o ≠ none ↔ o.isSome",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _} {o : Option α}"},
 {"type": "o ≠ none ↔ ∃ x : α, some x = o",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {o : Option α} : o ≠ none ↔ ∃ x : α, some x = o := by cases o <;> simp; sorry",
  "name": "ne_none_iff_exists",
  "kind": "theorem",
  "first-tactic": "cases o <;> simp",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {o : Option α} : o ≠ none ↔ ∃ x : α, some x = o",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _} {o : Option α}"},
 {"type": "guard p a = some b ↔ a = b ∧ p a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} {p : α → Prop}  [DecidablePred p]  {a b : α} : guard p a = some b ↔ a = b ∧ p a := by by_cases h : p a <;> simp [Option.guard, h]; sorry",
  "name": "guard_eq_some",
  "kind": "theorem",
  "first-tactic": "by_cases h : p a <;> simp [Option.guard, h]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} {p : α → Prop}  [DecidablePred p]  {a b : α} : guard p a = some b ↔ a = b ∧ p a",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} {p : α → Prop}  [DecidablePred p]  {a b : α}"},
 {"type": "(o.map f).getD (f x) = f (getD o x)",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _} (f : α → β)  (x : α)  (o : Option α) : (o.map f).getD (f x) = f (getD o x) := by cases o <;> rfl; sorry",
  "name": "getD_map",
  "kind": "theorem",
  "first-tactic": "cases o <;> rfl",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _} (f : α → β)  (x : α)  (o : Option α) : (o.map f).getD (f x) = f (getD o x)",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _} (f : α → β)  (x : α)  (o : Option α)"},
 {"type": "choice α = some a",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {α : Type _}  [Subsingleton α]  (a : α) : choice α = some a := by simp [choice]; sorry",
  "name": "choice_eq",
  "kind": "theorem",
  "first-tactic": "simp [choice]",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {α : Type _}  [Subsingleton α]  (a : α) : choice α = some a",
  "args":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {α : Type _}  [Subsingleton α]  (a : α)"},
 {"type": "(choice α).isSome ↔ Nonempty α",
  "tactic-prompt":
  "theorem {α : Type _}  {β : Type _}  {γ : Type _}  {α : Type _} : (choice α).isSome ↔ Nonempty α := by constructor; sorry",
  "name": "choice_isSome_iff_nonempty",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{α : Type _}  {β : Type _}  {γ : Type _}  {α : Type _} : (choice α).isSome ↔ Nonempty α",
  "args": "{α : Type _}  {β : Type _}  {γ : Type _}  {α : Type _}"},
 {"type": "{a : ℤ} → ¬(a + a + 1 = 0)",
  "tactic-prompt": "lemma  : {a : ℤ} → ¬(a + a + 1 = 0) := by intro a h; sorry",
  "name": "odd_ne_zero",
  "kind": "lemma",
  "first-tactic": "intro a h",
  "core-prompt": " : {a : ℤ} → ¬(a + a + 1 = 0)",
  "args": ""},
 {"type": "∀ g : P, g ^ 2 = 1 → g = 1",
  "tactic-prompt":
  "theorem  : ∀ g : P, g ^ 2 = 1 → g = 1 := by intro ⟨(p, q, r), x⟩; sorry",
  "name": "square_free",
  "kind": "theorem",
  "first-tactic": "intro ⟨(p, q, r), x⟩",
  "core-prompt": " : ∀ g : P, g ^ 2 = 1 → g = 1",
  "args": ""},
 {"type": "∀ {q : Q}, c 0 q = (0 : K)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ {q : Q}, c 0 q = (0 : K) := by intro q; sorry",
  "name": "leftId",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ {q : Q}, c 0 q = (0 : K)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ {q : Q}, c q 0 = (0 : K)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ {q : Q}, c q 0 = (0 : K) := by intro q; sorry",
  "name": "rightId",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ {q : Q}, c q 0 = (0 : K)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ q : Q, c q (-q) = q • (c (-q) q)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ q : Q, c q (-q) = q • (c (-q) q) := by intro q; sorry",
  "name": "invRel",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ q : Q, c q (-q) = q • (c (-q) q)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ q : Q, c (-q) q = (-q) • (c q (-q))",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ q : Q, c (-q) q = (-q) • (c q (-q)) := by intro q; sorry",
  "name": "invRel'",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ q : Q, c (-q) q = (-q) • (c q (-q))",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ k k' : Metabelian.Kernel Q K, k * k' = k' * k",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]  /- The multiplication operation defined using the cocycle. The cocycle condition is crucially used in showing associativity and other properties. -/  (Q K : Type _)  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ k k' : Metabelian.Kernel Q K, k * k' = k' * k := by intro ⟨⟨ka, 0⟩, rfl⟩; sorry",
  "name": "Metabelian.Kernel.mul_comm",
  "kind": "theorem",
  "first-tactic": "intro ⟨⟨ka, 0⟩, rfl⟩",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]  /- The multiplication operation defined using the cocycle. The cocycle condition is crucially used in showing associativity and other properties. -/  (Q K : Type _)  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] : ∀ k k' : Metabelian.Kernel Q K, k * k' = k' * k",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c] {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]  /- The multiplication operation defined using the cocycle. The cocycle condition is crucially used in showing associativity and other properties. -/  (Q K : Type _)  [AddCommGroup Q]  [AddCommGroup K] (c : Q → Q → K)  [ccl : Cocycle c]"},
 {"type": "∀ {a : A}, a • (0 : B) = (0 : B)",
  "tactic-prompt":
  "theorem (A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, a • (0 : B) = (0 : B) := by intro; sorry",
  "name": "act_zero",
  "kind": "theorem",
  "first-tactic": "intro",
  "core-prompt":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, a • (0 : B) = (0 : B)",
  "args":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α]"},
 {"type": "∀ {a : A}, ∀ {b b' : B}, a • (b + b') = a • b + a • b'",
  "tactic-prompt":
  "theorem (A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, ∀ {b b' : B}, a • (b + b') = a • b + a • b' := by intro; sorry",
  "name": "add_dist",
  "kind": "theorem",
  "first-tactic": "intro",
  "core-prompt":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, ∀ {b b' : B}, a • (b + b') = a • b + a • b'",
  "args":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α]"},
 {"type": "∀ {a : A}, ∀ {b : B}, a • (-b) = - (a • b)",
  "tactic-prompt":
  "theorem (A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, ∀ {b : B}, a • (-b) = - (a • b) := by intros; sorry",
  "name": "neg_push",
  "kind": "theorem",
  "first-tactic": "intros",
  "core-prompt":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α] : ∀ {a : A}, ∀ {b : B}, a • (-b) = - (a • b)",
  "args":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (α : A → B → B)  [AA : AutAction A B α]"},
 {"type": "∀ x : Fin 3, x + 0 = x",
  "tactic-prompt": "example  : ∀ x : Fin 3, x + 0 = x := by decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x : Fin 3, x + 0 = x",
  "args": ""},
 {"type": "∀ x y : Fin 3, x + y = y + x",
  "tactic-prompt":
  "example  : ∀ x y : Fin 3, x + y = y + x := by decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x y : Fin 3, x + y = y + x",
  "args": ""},
 {"type": "∀ x y z : Fin 3, (x + y) + z = x + (y + z)",
  "tactic-prompt":
  "theorem  : ∀ x y z : Fin 3, (x + y) + z = x + (y + z) := by decide; sorry",
  "name": "Zmod3.assoc",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : ∀ x y z : Fin 3, (x + y) + z = x + (y + z)",
  "args": ""},
 {"type":
  "∀ xy : (Fin 3) × (Fin 2), \n      xy.1.val + xy.2.val  = xy.2.val + xy.1.val",
  "tactic-prompt":
  "example  : ∀ xy : (Fin 3) × (Fin 2), \n      xy.1.val + xy.2.val  = xy.2.val + xy.1.val := by decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "decide",
  "core-prompt":
  " : ∀ xy : (Fin 3) × (Fin 2), \n      xy.1.val + xy.2.val  = xy.2.val + xy.1.val",
  "args": ""},
 {"type": "ps.fst.length + 1 ≤ w.length",
  "tactic-prompt":
  "theorem {l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.fst.length + 1 ≤ w.length := by let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append; sorry",
  "name": "splitFirst",
  "kind": "theorem",
  "first-tactic":
  "let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append",
  "core-prompt":
  "{l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.fst.length + 1 ≤ w.length",
  "args": "{l: Letter} {w: Word} (ps: ProvedSplit l w)"},
 {"type": "ps.snd.length + 1 ≤ w.length",
  "tactic-prompt":
  "theorem {l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.snd.length + 1 ≤ w.length := by let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append; sorry",
  "name": "splitSecond",
  "kind": "theorem",
  "first-tactic":
  "let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append",
  "core-prompt":
  "{l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.snd.length + 1 ≤ w.length",
  "args": "{l: Letter} {w: Word} (ps: ProvedSplit l w)"},
 {"type": "ProofTree (x :: w)",
  "tactic-prompt":
  "def {w : Word}  (x: Letter)           (pt: ProofTree w) : ProofTree (x :: w) := by have exp : x :: w = [x] ++ w := by rfl; sorry",
  "name": "ProofTree.prepend",
  "kind": "def",
  "first-tactic": "have exp : x :: w = [x] ++ w := by rfl",
  "core-prompt":
  "{w : Word}  (x: Letter)           (pt: ProofTree w) : ProofTree (x :: w)",
  "args": "{w : Word}  (x: Letter)           (pt: ProofTree w)"},
 {"type":
  "∀ g h : K × Q, MetabelianGroup.mul trivial_cocycle g h = MetabelianGroup.mul trivial_cocycle h g",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] : ∀ g h : K × Q, MetabelianGroup.mul trivial_cocycle g h = MetabelianGroup.mul trivial_cocycle h g := by intro (k, q); sorry",
  "name": "product_comm",
  "kind": "theorem",
  "first-tactic": "intro (k, q)",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] : ∀ g h : K × Q, MetabelianGroup.mul trivial_cocycle g h = MetabelianGroup.mul trivial_cocycle h g",
  "args": "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K]"},
 {"type": "(a, b) = (c, d) ↔ (a = c) ∧ (b = d)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] {α β : Type _}  (a c : α)  (b d : β) : (a, b) = (c, d) ↔ (a = c) ∧ (b = d) := by apply Iff.intro; sorry",
  "name": "prod_eq",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] {α β : Type _}  (a c : α)  (b d : β) : (a, b) = (c, d) ↔ (a = c) ∧ (b = d)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] {α β : Type _}  (a c : α)  (b d : β)"},
 {"type":
  "MetabelianGroup.mul trivial_cocycle (a, b) (a', b') = (a + a', b + b')",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] {a a' : A}  {b b' : B} : MetabelianGroup.mul trivial_cocycle (a, b) (a', b') = (a + a', b + b') := by show (a + a' + 0, b + b') = _; sorry",
  "name": "mul",
  "kind": "theorem",
  "first-tactic": "show (a + a' + 0, b + b') = _",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] {a a' : A}  {b b' : B} : MetabelianGroup.mul trivial_cocycle (a, b) (a', b') = (a + a', b + b')",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] {a a' : A}  {b b' : B}"},
 {"type": "(a, b) + (a', b') = (a + a', b + b')",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] (a a' : A)  (b b' : B) : (a, b) + (a', b') = (a + a', b + b') := by simp only [HAdd.hAdd, Add.add]; sorry",
  "name": "add",
  "kind": "theorem",
  "first-tactic": "simp only [HAdd.hAdd, Add.add]",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] (a a' : A)  (b b' : B) : (a, b) + (a', b') = (a + a', b + b')",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] (a a' : A)  (b b' : B)"},
 {"type": "gsmul (n+1) x = x + gsmul n x",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (n: ℤ)  (x : A) : gsmul (n+1) x = x + gsmul n x := by cases n; sorry",
  "name": "gsmul_succ",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (n: ℤ)  (x : A) : gsmul (n+1) x = x + gsmul n x",
  "args": "{A : Type}  [abg : AddCommGroup A] (n: ℤ)  (x : A)"},
 {"type": "zhom x (n + m) = zhom x n + zhom x m",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x : A)  (n : ℤ)  (m: Nat) : zhom x (n + m) = zhom x n + zhom x m := by induction m; sorry",
  "name": "isHom₁",
  "kind": "theorem",
  "first-tactic": "induction m",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (x : A)  (n : ℤ)  (m: Nat) : zhom x (n + m) = zhom x n + zhom x m",
  "args": "{A : Type}  [abg : AddCommGroup A] (x : A)  (n : ℤ)  (m: Nat)"},
 {"type":
  "zhom x ((Int.negSucc n) + (Int.negSucc m)) = \n          zhom x (Int.negSucc m) + zhom x (Int.negSucc n)",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x : A)  (n m : Nat) : zhom x ((Int.negSucc n) + (Int.negSucc m)) = \n          zhom x (Int.negSucc m) + zhom x (Int.negSucc n) := by simp [zhom]; sorry",
  "name": "isHom₂",
  "kind": "theorem",
  "first-tactic": "simp [zhom]",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (x : A)  (n m : Nat) : zhom x ((Int.negSucc n) + (Int.negSucc m)) = \n          zhom x (Int.negSucc m) + zhom x (Int.negSucc n)",
  "args": "{A : Type}  [abg : AddCommGroup A] (x : A)  (n m : Nat)"},
 {"type": "zhom x (n + m) = zhom x n + zhom x m",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x: A)  (n m : ℤ) : zhom x (n + m) = zhom x n + zhom x m := by cases m; sorry",
  "name": "zhom_is_hom",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (x: A)  (n m : ℤ) : zhom x (n + m) = zhom x n + zhom x m",
  "args": "{A : Type}  [abg : AddCommGroup A] (x: A)  (n m : ℤ)"},
 {"type": "zhom x 1 = x",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x : A) : zhom x 1 = x := by simp [zhom]; sorry",
  "name": "zhom_one",
  "kind": "theorem",
  "first-tactic": "simp [zhom]",
  "core-prompt": "{A : Type}  [abg : AddCommGroup A] (x : A) : zhom x 1 = x",
  "args": "{A : Type}  [abg : AddCommGroup A] (x : A)"},
 {"type": "f 1 = g 1  → ∀ n: ℕ, f (n + 1) = g (n + 1)",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  → ∀ n: ℕ, f (n + 1) = g (n + 1) := by intro hyp; sorry",
  "name": "unique_morphism_nat",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  → ∀ n: ℕ, f (n + 1) = g (n + 1)",
  "args":
  "{A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g]"},
 {"type": "f 1 = g 1  → f = g",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  → f = g := by intro hyp; sorry",
  "name": "unique_morphism",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  → f = g",
  "args":
  "{A : Type}  [abg : AddCommGroup A] (f g : ℤ → A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g]"},
 {"type": "F → A",
  "tactic-prompt":
  "def {F: Type} [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]  (f: X → A) : F → A := by apply fag.inducedMap; sorry",
  "name": "fromBasis",
  "kind": "def",
  "first-tactic": "apply fag.inducedMap",
  "core-prompt":
  "{F: Type} [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]  (f: X → A) : F → A",
  "args":
  "{F: Type} [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]  (f: X → A)"},
 {"type":
  "@AddCommGroup.Homomorphism F A _ _ \n    (@fromBasis F _ X  fag A _ f)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A} : @AddCommGroup.Homomorphism F A _ _ \n    (@fromBasis F _ X  fag A _ f) := by apply fag.induced_hom; sorry",
  "name": "fromBasisHom",
  "kind": "instance",
  "first-tactic": "apply fag.induced_hom",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A} : @AddCommGroup.Homomorphism F A _ _ \n    (@fromBasis F _ X  fag A _ f)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A}"},
 {"type": "D →  F → A",
  "tactic-prompt":
  "def (F: Type) [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] (D: Type) (f: D → X → A) : D →  F → A := by intro p; sorry",
  "name": "fromBasisFamily",
  "kind": "def",
  "first-tactic": "intro p",
  "core-prompt":
  "(F: Type) [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] (D: Type) (f: D → X → A) : D →  F → A",
  "args":
  "(F: Type) [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] (D: Type) (f: D → X → A)"},
 {"type":
  "@AddCommGroup.Homomorphism F A _ _ \n    ((@fromBasisFamily F _ X  fag A _ D f) p)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] {D : Type}    {f: D → X → A} {p : D} : @AddCommGroup.Homomorphism F A _ _ \n    ((@fromBasisFamily F _ X  fag A _ D f) p) := by apply fag.induced_hom; sorry",
  "name": "fromBasisFamilyHom",
  "kind": "instance",
  "first-tactic": "apply fag.induced_hom",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] {D : Type}    {f: D → X → A} {p : D} : @AddCommGroup.Homomorphism F A _ _ \n    ((@fromBasisFamily F _ X  fag A _ D f) p)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] {D : Type}    {f: D → X → A} {p : D}"},
 {"type": "@AddCommGroup.Homomorphism F A _ _ \n    (fag.inducedMap A f)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A} : @AddCommGroup.Homomorphism F A _ _ \n    (fag.inducedMap A f) := by apply fag.induced_hom; sorry",
  "name": "fromBasisHom'",
  "kind": "instance",
  "first-tactic": "apply fag.induced_hom",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A} : @AddCommGroup.Homomorphism F A _ _ \n    (fag.inducedMap A f)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X → A}"},
 {"type": "Decidable (f = g)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fgp : FreeAbelianGroup F X]    {A: Type} [AddCommGroup A] [DecidableEq A] [DecideForall X]      (f g : F → A) [AddCommGroup.Homomorphism f] [AddCommGroup.Homomorphism g] : Decidable (f = g) := by apply decideHomsEqual X; sorry",
  "name": "decHomsEqual",
  "kind": "instance",
  "first-tactic": "apply decideHomsEqual X",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fgp : FreeAbelianGroup F X]    {A: Type} [AddCommGroup A] [DecidableEq A] [DecideForall X]      (f g : F → A) [AddCommGroup.Homomorphism f] [AddCommGroup.Homomorphism g] : Decidable (f = g)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fgp : FreeAbelianGroup F X]    {A: Type} [AddCommGroup A] [DecidableEq A] [DecideForall X]      (f g : F → A) [AddCommGroup.Homomorphism f] [AddCommGroup.Homomorphism g]"},
 {"type":
  "∀ (x y: Fin 2), \n  (egAction' x) ∘ (egAction' y) = egAction' (x + y)",
  "tactic-prompt":
  "theorem  : ∀ (x y: Fin 2), \n  (egAction' x) ∘ (egAction' y) = egAction' (x + y) := by decide -- works!; sorry",
  "name": "egIsAction",
  "kind": "theorem",
  "first-tactic": "decide -- works!",
  "core-prompt":
  " : ∀ (x y: Fin 2), \n  (egAction' x) ∘ (egAction' y) = egAction' (x + y)",
  "args": ""},
 {"type":
  "(FreeAbelianGroup.inducedMap G f) ∘ (ι₁ : A → A × B) = (FAb_A.inducedMap G (f ∘ Sum.inl))",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G) : (FreeAbelianGroup.inducedMap G f) ∘ (ι₁ : A → A × B) = (FAb_A.inducedMap G (f ∘ Sum.inl)) := by apply funext; sorry",
  "name": "FreeAbelianGroup.induced_left",
  "kind": "theorem",
  "first-tactic": "apply funext",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G) : (FreeAbelianGroup.inducedMap G f) ∘ (ι₁ : A → A × B) = (FAb_A.inducedMap G (f ∘ Sum.inl))",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G)"},
 {"type":
  "(FreeAbelianGroup.inducedMap G f) ∘ (ι₂ : B → A × B) = (FAb_B.inducedMap G (f ∘ Sum.inr))",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G) : (FreeAbelianGroup.inducedMap G f) ∘ (ι₂ : B → A × B) = (FAb_B.inducedMap G (f ∘ Sum.inr)) := by apply funext; sorry",
  "name": "FreeAbelianGroup.induced_right",
  "kind": "theorem",
  "first-tactic": "apply funext",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G) : (FreeAbelianGroup.inducedMap G f) ∘ (ι₂ : B → A × B) = (FAb_B.inducedMap G (f ∘ Sum.inr))",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A ⊕ X_B → G)"},
 {"type":
  "FreeAbelianGroup.i ((Sum.inl xa) : X_A ⊕ X_B) = (FAb_A.i xa, (0 : B))",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xa : X_A) : FreeAbelianGroup.i ((Sum.inl xa) : X_A ⊕ X_B) = (FAb_A.i xa, (0 : B)) := by simp [i, ι]; sorry",
  "name": "FreeAbelianGroup.left_incl",
  "kind": "theorem",
  "first-tactic": "simp [i, ι]",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xa : X_A) : FreeAbelianGroup.i ((Sum.inl xa) : X_A ⊕ X_B) = (FAb_A.i xa, (0 : B))",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xa : X_A)"},
 {"type":
  "FreeAbelianGroup.i ((Sum.inr xb) : X_A ⊕ X_B) = ((0 : A), FAb_B.i xb)",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xb : X_B) : FreeAbelianGroup.i ((Sum.inr xb) : X_A ⊕ X_B) = ((0 : A), FAb_B.i xb) := by simp [i, ι]; sorry",
  "name": "FreeAbelianGroup.right_incl",
  "kind": "theorem",
  "first-tactic": "simp [i, ι]",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xb : X_B) : FreeAbelianGroup.i ((Sum.inr xb) : X_A ⊕ X_B) = ((0 : A), FAb_B.i xb)",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xb : X_B)"},
 {"type": "AddCommGroup.Homomorphism (action q)",
  "tactic-prompt":
  "instance (q : Q) : AddCommGroup.Homomorphism (action q) := by revert q; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "revert q",
  "core-prompt": "(q : Q) : AddCommGroup.Homomorphism (action q)",
  "args": "(q : Q)"},
 {"type": "¬ (trivial_element α)",
  "tactic-prompt": "theorem  : ¬ (trivial_element α) := by intro contra; sorry",
  "name": "α_non_trivial",
  "kind": "theorem",
  "first-tactic": "intro contra",
  "core-prompt": " : ¬ (trivial_element α)",
  "args": ""},
 {"type": "coords (mulMonom 0 g s) x₀ = 0",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (g x₀: G) (s: FormalSum R G) : coords (mulMonom 0 g s) x₀ = 0 := by induction s; sorry",
  "name": "mul_monom_zero",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (g x₀: G) (s: FormalSum R G) : coords (mulMonom 0 g s) x₀ = 0",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (g x₀: G) (s: FormalSum R G)"},
 {"type":
  "coords (mulMonom b h (s₁  ++ s₂)) x₀ = coords (mulMonom b h s₁) x₀ + coords (mulMonom b h s₂) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G) : coords (mulMonom b h (s₁  ++ s₂)) x₀ = coords (mulMonom b h s₁) x₀ + coords (mulMonom b h s₂) x₀ := by induction s₁; sorry",
  "name": "mul_monom_dist",
  "kind": "theorem",
  "first-tactic": "induction s₁",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G) : coords (mulMonom b h (s₁  ++ s₂)) x₀ = coords (mulMonom b h s₁) x₀ + coords (mulMonom b h s₂) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G)"},
 {"type":
  "coords (mul s₁ (s₂  ++ s₃)) x₀ = coords (mul s₁ s₂) x₀ + coords (mul s₁ s₃) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (x₀ : G) (s₁ s₂ s₃: FormalSum R G) : coords (mul s₁ (s₂  ++ s₃)) x₀ = coords (mul s₁ s₂) x₀ + coords (mul s₁ s₃) x₀ := by induction s₂; sorry",
  "name": "mul_dist",
  "kind": "theorem",
  "first-tactic": "induction s₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (x₀ : G) (s₁ s₂ s₃: FormalSum R G) : coords (mul s₁ (s₂  ++ s₃)) x₀ = coords (mul s₁ s₂) x₀ + coords (mul s₁ s₃) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (x₀ : G) (s₁ s₂ s₃: FormalSum R G)"},
 {"type":
  "coords (mulMonom b h (mulMonom a x s)) x₀ = \n    coords (mulMonom (a * b) (x * h) s) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (a b : R) (h x₀ : G) (s : FormalSum R G) : coords (mulMonom b h (mulMonom a x s)) x₀ = \n    coords (mulMonom (a * b) (x * h) s) x₀ := by induction s; sorry",
  "name": "mul_monom_monom_assoc",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (a b : R) (h x₀ : G) (s : FormalSum R G) : coords (mulMonom b h (mulMonom a x s)) x₀ = \n    coords (mulMonom (a * b) (x * h) s) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (a b : R) (h x₀ : G) (s : FormalSum R G)"},
 {"type":
  "coords (mulMonom b h (mul s₁ s₂)) x₀ = \n    coords (mul s₁ (mulMonom b h s₂)) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G) : coords (mulMonom b h (mul s₁ s₂)) x₀ = \n    coords (mul s₁ (mulMonom b h s₂)) x₀ := by induction s₂; sorry",
  "name": "mul_monom_assoc",
  "kind": "theorem",
  "first-tactic": "induction s₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G) : coords (mulMonom b h (mul s₁ s₂)) x₀ = \n    coords (mul s₁ (mulMonom b h s₂)) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂: FormalSum R G)"},
 {"type":
  "coords (mulMonom (b₁ + b₂) h s) x₀ = coords (mulMonom b₁ h s) x₀ + coords (mulMonom b₂ h s) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b₁ b₂ : R) (h x₀ : G) (s: FormalSum R G) : coords (mulMonom (b₁ + b₂) h s) x₀ = coords (mulMonom b₁ h s) x₀ + coords (mulMonom b₂ h s) x₀ := by induction s; sorry",
  "name": "mul_monom_add",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b₁ b₂ : R) (h x₀ : G) (s: FormalSum R G) : coords (mulMonom (b₁ + b₂) h s) x₀ = coords (mulMonom b₁ h s) x₀ + coords (mulMonom b₂ h s) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b₁ b₂ : R) (h x₀ : G) (s: FormalSum R G)"},
 {"type": "mul s ((0, h) :: t) ≈  mul s t",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s t : FormalSum R G) (g: G) : mul s ((0, h) :: t) ≈  mul s t := by induction s; sorry",
  "name": "mul_zero_cons",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s t : FormalSum R G) (g: G) : mul s ((0, h) :: t) ≈  mul s t",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s t : FormalSum R G) (g: G)"},
 {"type": "FormalSum R G → FreeModule R G → FreeModule R G",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FormalSum R G → FreeModule R G → FreeModule R G := by intro s; sorry",
  "name": "mulAux",
  "kind": "def",
  "first-tactic": "intro s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FormalSum R G → FreeModule R G → FreeModule R G",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G]"},
 {"type": "coords (mulMonom b h s₁) x₀ = coords (mulMonom b h s₂) x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂ : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂) : coords (mulMonom b h s₁) x₀ = coords (mulMonom b h s₂) x₀ := by induction rel; sorry",
  "name": "mul_monom_invariant",
  "kind": "theorem",
  "first-tactic": "induction rel",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂ : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂) : coords (mulMonom b h s₁) x₀ = coords (mulMonom b h s₂) x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h x₀ : G) (s₁ s₂ : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂)"},
 {"type": "FormalSum.mul s₁ t ≈  FormalSum.mul s₂ t",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s₁ s₂ t : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂) : FormalSum.mul s₁ t ≈  FormalSum.mul s₂ t := by cases t; sorry",
  "name": "first_arg_invariant",
  "kind": "theorem",
  "first-tactic": "cases t",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s₁ s₂ t : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂) : FormalSum.mul s₁ t ≈  FormalSum.mul s₂ t",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s₁ s₂ t : FormalSum R G)  (rel : ElementaryMove R G s₁ s₂)"},
 {"type": "FreeModule R G → FreeModule R G → FreeModule R G",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FreeModule R G → FreeModule R G → FreeModule R G := by let f  := fun (s : FormalSum R G) => \n    fun  (t : FreeModule R G) => mulAux  s t; sorry",
  "name": "mul",
  "kind": "def",
  "first-tactic":
  "let f  := fun (s : FormalSum R G) => \n    fun  (t : FreeModule R G) => mulAux  s t",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FreeModule R G → FreeModule R G → FreeModule R G",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G]"},
 {"type":
  "monomCoeff R X x₀ (a + b, x) = monomCoeff R X x₀ (a, x) + monomCoeff R X x₀ (b, x)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X)  (a b : R) : monomCoeff R X x₀ (a + b, x) = monomCoeff R X x₀ (a, x) + monomCoeff R X x₀ (b, x) := by repeat\n    (\n      rw [monomCoeff]); sorry",
  "name": "monom_coords_hom",
  "kind": "theorem",
  "first-tactic": "repeat\n    (\n      rw [monomCoeff])",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X)  (a b : R) : monomCoeff R X x₀ (a + b, x) = monomCoeff R X x₀ (a, x) + monomCoeff R X x₀ (b, x)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X)  (a b : R)"},
 {"type": "monomCoeff R X x₀ (a * b, x) = a * monomCoeff R X x₀ (b, x)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (a b : R) : monomCoeff R X x₀ (a * b, x) = a * monomCoeff R X x₀ (b, x) := by repeat\n    (\n      rw [monomCoeff]); sorry",
  "name": "monom_coords_mul",
  "kind": "theorem",
  "first-tactic": "repeat\n    (\n      rw [monomCoeff])",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (a b : R) : monomCoeff R X x₀ (a * b, x) = a * monomCoeff R X x₀ (b, x)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (a b : R)"},
 {"type": "monomCoeff R X x₀ (0, x) = 0",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X) : monomCoeff R X x₀ (0, x) = 0 := by rw [monomCoeff]; sorry",
  "name": "monom_coords_at_zero",
  "kind": "theorem",
  "first-tactic": "rw [monomCoeff]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X) : monomCoeff R X x₀ (0, x) = 0",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ x : X)"},
 {"type": "f = g → equalOnSupport l f g",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (l : List X)  (f g : X → R) : f = g → equalOnSupport l f g := by intro hyp; sorry",
  "name": "equal_on_support_of_equal",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (l : List X)  (f g : X → R) : f = g → equalOnSupport l f g",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (l : List X)  (f g : X → R)"},
 {"type": "eqlCoords R X s s",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s : FormalSum R X) : eqlCoords R X s s := by rfl; sorry",
  "name": "refl",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s : FormalSum R X) : eqlCoords R X s s",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s : FormalSum R X)"},
 {"type": "eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₁",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ : FormalSum R X} : eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₁ := by intro hyp; sorry",
  "name": "symm",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ : FormalSum R X} : eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₁",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ : FormalSum R X}"},
 {"type": "eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₃ → eqlCoords R X s₁ s₃",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ s₃ : FormalSum R X} : eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₃ → eqlCoords R X s₁ s₃ := by intro hyp₁ hyp₂; sorry",
  "name": "trans",
  "kind": "theorem",
  "first-tactic": "intro hyp₁ hyp₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ s₃ : FormalSum R X} : eqlCoords R X s₁ s₂ → eqlCoords R X s₂ s₃ → eqlCoords R X s₁ s₃",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {s₁ s₂ s₃ : FormalSum R X}"},
 {"type": "beqOnSupport l f g = true → equalOnSupport l f g",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {l : List X}  {f g : X → R} : beqOnSupport l f g = true → equalOnSupport l f g := by intro hyp; sorry",
  "name": "eql_on_support_of_true",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {l : List X}  {f g : X → R} : beqOnSupport l f g = true → equalOnSupport l f g",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {l : List X}  {f g : X → R}"},
 {"type": "⟦s₁⟧ = ⟦s₂⟧",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) (c₁ : beqOnSupport s₁.support s₁.coords s₂.coords) (c₂ : beqOnSupport s₂.support s₁.coords s₂.coords) : ⟦s₁⟧ = ⟦s₂⟧ := by let ch₁ := eql_on_support_of_true c₁; sorry",
  "name": "eqlquot_of_beq_support",
  "kind": "theorem",
  "first-tactic": "let ch₁ := eql_on_support_of_true c₁",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) (c₁ : beqOnSupport s₁.support s₁.coords s₂.coords) (c₂ : beqOnSupport s₂.support s₁.coords s₂.coords) : ⟦s₁⟧ = ⟦s₂⟧",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) (c₁ : beqOnSupport s₁.support s₁.coords s₂.coords) (c₂ : beqOnSupport s₂.support s₁.coords s₂.coords)"},
 {"type": "Bool",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : Bool := by apply Quotient.lift₂ (fun (s₁ s₂ : FormalSum R X) => decide (⟦s₁⟧ = ⟦s₂⟧)); sorry",
  "name": "beq_quot",
  "kind": "def",
  "first-tactic":
  "apply Quotient.lift₂ (fun (s₁ s₂ : FormalSum R X) => decide (⟦s₁⟧ = ⟦s₂⟧))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : Bool",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X)"},
 {"type": "∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = true → x₁ = x₂",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : ∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = true → x₁ = x₂ := by let f :=\n    @Quotient.ind₂ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (x₁ x₂ : FreeModule R X) => x₁.beq_quot x₂ = true → x₁ = x₂); sorry",
  "name": "eq_of_beq_true",
  "kind": "def",
  "first-tactic":
  "let f :=\n    @Quotient.ind₂ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (x₁ x₂ : FreeModule R X) => x₁.beq_quot x₂ = true → x₁ = x₂)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : ∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = true → x₁ = x₂",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = false → Not (x₁ = x₂)",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : ∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = false → Not (x₁ = x₂) := by let f :=\n    @Quotient.ind₂ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (x₁ x₂ : FreeModule R X) => x₁.beq_quot x₂ = false → Not (x₁ = x₂)); sorry",
  "name": "neq_of_beq_false",
  "kind": "def",
  "first-tactic":
  "let f :=\n    @Quotient.ind₂ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (x₁ x₂ : FreeModule R X) => x₁.beq_quot x₂ = false → Not (x₁ = x₂))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : ∀ x₁ x₂ : FreeModule R X, x₁.beq_quot x₂ = false → Not (x₁ = x₂)",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "Decidable (x₁ = x₂)",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : Decidable (x₁ = x₂) := by match p : x₁.beq_quot x₂ with\n  | true =>\n    apply Decidable.isTrue\n    apply FreeModule.eq_of_beq_true\n    assumption\n  | false =>\n    apply Decidable.isFalse\n    apply FreeModule.neq_of_beq_false\n    assumption; sorry",
  "name": "decEq",
  "kind": "def",
  "first-tactic":
  "match p : x₁.beq_quot x₂ with\n  | true =>\n    apply Decidable.isTrue\n    apply FreeModule.eq_of_beq_true\n    assumption\n  | false =>\n    apply Decidable.isFalse\n    apply FreeModule.neq_of_beq_false\n    assumption",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : Decidable (x₁ = x₂)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X)"},
 {"type": "s₁ ≈ s₂ → s₁.coords = s₂.coords",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) : s₁ ≈ s₂ → s₁.coords = s₂.coords := by intro hyp; sorry",
  "name": "equal_coords_of_approx",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X) : s₁ ≈ s₂ → s₁.coords = s₂.coords",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)"},
 {"type": "FreeModule R X →  R",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) : FreeModule R X →  R := by apply Quotient.lift (fun s : FormalSum R X => s.coords x₀); sorry",
  "name": "coordinates",
  "kind": "def",
  "first-tactic": "apply Quotient.lift (fun s : FormalSum R X => s.coords x₀)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) : FreeModule R X →  R",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)"},
 {"type": "(r * s.coords x₀) = (s.scmul r).coords x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (r : R)  (s : FormalSum R X)  (x₀ : X) : (r * s.coords x₀) = (s.scmul r).coords x₀ := by induction s; sorry",
  "name": "scmul_coords",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (r : R)  (s : FormalSum R X)  (x₀ : X) : (r * s.coords x₀) = (s.scmul r).coords x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (r : R)  (s : FormalSum R X)  (x₀ : X)"},
 {"type": "R → FreeModule R X → FreeModule R X",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : R → FreeModule R X → FreeModule R X := by intro r; sorry",
  "name": "FreeModule.scmul",
  "kind": "def",
  "first-tactic": "intro r",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : R → FreeModule R X → FreeModule R X",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "(s₁.coords x₀) + (s₂.coords x₀) = (s₁ ++ s₂).coords x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (x₀ : X) : (s₁.coords x₀) + (s₂.coords x₀) = (s₁ ++ s₂).coords x₀ := by induction s₁; sorry",
  "name": "append_coords",
  "kind": "theorem",
  "first-tactic": "induction s₁",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (x₀ : X) : (s₁.coords x₀) + (s₂.coords x₀) = (s₁ ++ s₂).coords x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (x₀ : X)"},
 {"type": "(s₁ ≈ s₂) → (t₁ ≈ t₂) → s₁ ++ t₁ ≈ s₂ ++ t₂",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ t₁ t₂ : FormalSum R X) : (s₁ ≈ s₂) → (t₁ ≈ t₂) → s₁ ++ t₁ ≈ s₂ ++ t₂ := by intro eqv₁ eqv₂; sorry",
  "name": "append_equiv",
  "kind": "theorem",
  "first-tactic": "intro eqv₁ eqv₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ t₁ t₂ : FormalSum R X) : (s₁ ≈ s₂) → (t₁ ≈ t₂) → s₁ ++ t₁ ≈ s₂ ++ t₂",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ t₁ t₂ : FormalSum R X)"},
 {"type": "FreeModule R X → FreeModule R X → FreeModule R X",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : FreeModule R X → FreeModule R X → FreeModule R X := by let f : FormalSum R X → FormalSum R X → FreeModule R X := fun s₁ s₂ => ⟦s₁ ++ s₂⟧; sorry",
  "name": "FreeModule.add",
  "kind": "def",
  "first-tactic":
  "let f : FormalSum R X → FormalSum R X → FreeModule R X := fun s₁ s₂ => ⟦s₁ ++ s₂⟧",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : FreeModule R X → FreeModule R X → FreeModule R X",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "(s.scmul b).scmul a = s.scmul (a * b)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul b).scmul a = s.scmul (a * b) := by induction s; sorry",
  "name": "action",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul b).scmul a = s.scmul (a * b)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X)"},
 {"type": "(s.scmul a) ++ (s.scmul b) ≈  s.scmul (a + b)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul a) ++ (s.scmul b) ≈  s.scmul (a + b) := by induction s; sorry",
  "name": "act_sum",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul a) ++ (s.scmul b) ≈  s.scmul (a + b)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X)"},
 {"type": "a • (b • x) = (a * b) • x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (x : FreeModule R X) : a • (b • x) = (a * b) • x := by apply @Quotient.ind (motive := fun x : FreeModule R X => a • (b • x) = (a * b) • x); sorry",
  "name": "module_action",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => a • (b • x) = (a * b) • x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (x : FreeModule R X) : a • (b • x) = (a * b) • x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (x : FreeModule R X)"},
 {"type": "x₁ + x₂ = x₂ + x₁",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : x₁ + x₂ = x₂ + x₁ := by apply @Quotient.ind₂ (motive := fun x₁ x₂ : FreeModule R X => x₁ + x₂ = x₂ + x₁); sorry",
  "name": "addn_comm",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind₂ (motive := fun x₁ x₂ : FreeModule R X => x₁ + x₂ = x₂ + x₁)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X) : x₁ + x₂ = x₂ + x₁",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ : FreeModule R X)"},
 {"type": "(⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ : FormalSum R X)  (x₂ x₃ : FreeModule R X) : (⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃) := by apply @Quotient.ind₂ (motive := fun x₂ x₃ : FreeModule R X => (⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃)); sorry",
  "name": "add_assoc_aux",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind₂ (motive := fun x₂ x₃ : FreeModule R X => (⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ : FormalSum R X)  (x₂ x₃ : FreeModule R X) : (⟦s₁⟧ + x₂) + x₃ = ⟦s₁⟧ + (x₂ + x₃)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ : FormalSum R X)  (x₂ x₃ : FreeModule R X)"},
 {"type": "(x₁ + x₂) + x₃ = x₁ + (x₂ + x₃)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ x₃ : FreeModule R X) : (x₁ + x₂) + x₃ = x₁ + (x₂ + x₃) := by apply @Quotient.ind (motive := fun x₁ : FreeModule R X => (x₁ + x₂) + x₃ = x₁ + (x₂ + x₃)); sorry",
  "name": "addn_assoc",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x₁ : FreeModule R X => (x₁ + x₂) + x₃ = x₁ + (x₂ + x₃))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ x₃ : FreeModule R X) : (x₁ + x₂) + x₃ = x₁ + (x₂ + x₃)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₁ x₂ x₃ : FreeModule R X)"},
 {"type": "x + zero = x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : x + zero = x := by apply @Quotient.ind (motive := fun x : FreeModule R X => x + zero = x); sorry",
  "name": "addn_zero",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => x + zero = x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : x + zero = x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "zero + x = x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : zero + x = x := by apply @Quotient.ind (motive := fun x : FreeModule R X => zero + x = x); sorry",
  "name": "zero_addn",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => zero + x = x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : zero + x = x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "a • (x₁ + x₂) = a • x₁ + a • x₂",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a : R)  (x₁ x₂ : FreeModule R X) : a • (x₁ + x₂) = a • x₁ + a • x₂ := by apply @Quotient.ind₂ (motive := fun x₁ x₂ : FreeModule R X => a • (x₁ + x₂) = a • x₁ + a • x₂); sorry",
  "name": "elem_distrib",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind₂ (motive := fun x₁ x₂ : FreeModule R X => a • (x₁ + x₂) = a • x₁ + a • x₂)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a : R)  (x₁ x₂ : FreeModule R X) : a • (x₁ + x₂) = a • x₁ + a • x₂",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a : R)  (x₁ x₂ : FreeModule R X)"},
 {"type": "a • x + b • x = (a + b) • x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b: R) (x: FreeModule R X) : a • x + b • x = (a + b) • x := by apply @Quotient.ind (motive := fun x : FreeModule R X => \n    a • x + b • x = (a + b) • x); sorry",
  "name": "coeffs_distrib",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => \n    a • x + b • x = (a + b) • x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b: R) (x: FreeModule R X) : a • x + b • x = (a + b) • x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b: R) (x: FreeModule R X)"},
 {"type": "(1 : R) • x =  x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (1 : R) • x =  x := by apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (1 : R) • x =  x); sorry",
  "name": "unit_coeffs",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (1 : R) • x =  x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (1 : R) • x =  x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "(0 : R) • x =  ⟦ [] ⟧",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (0 : R) • x =  ⟦ [] ⟧ := by apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (0 : R) • x =  ⟦ [] ⟧); sorry",
  "name": "zero_coeffs",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (0 : R) • x =  ⟦ [] ⟧)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (0 : R) • x =  ⟦ [] ⟧",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "coords s₁ x₀ = coords s₂ x₀",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (s₁ s₂ : FormalSum R X)  (h : ElementaryMove R X s₁ s₂) : coords s₁ x₀ = coords s₂ x₀ := by induction h; sorry",
  "name": "coords_move_invariant",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (s₁ s₂ : FormalSum R X)  (h : ElementaryMove R X s₁ s₂) : coords s₁ x₀ = coords s₂ x₀",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X)  (s₁ s₂ : FormalSum R X)  (h : ElementaryMove R X s₁ s₂)"},
 {"type": "FreeModuleAux.coeff  x (sum s) = s.coords x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s : FormalSum R X) : FreeModuleAux.coeff  x (sum s) = s.coords x := by simp [FreeModuleAux.coeff]; sorry",
  "name": "coeff_factors",
  "kind": "theorem",
  "first-tactic": "simp [FreeModuleAux.coeff]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s : FormalSum R X) : FreeModuleAux.coeff  x (sum s) = s.coords x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s : FormalSum R X)"},
 {"type": "s₁ ≃ s₂ → s₁.coords x = s₂.coords x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s₁ s₂ : FormalSum R X) : s₁ ≃ s₂ → s₁.coords x = s₂.coords x := by intro hyp; sorry",
  "name": "coords_well_defined",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s₁ s₂ : FormalSum R X) : s₁ ≃ s₂ → s₁.coords x = s₂.coords x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s₁ s₂ : FormalSum R X)"},
 {"type": "s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (a : R)  (x : X) : s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂ := by intro h; sorry",
  "name": "cons_equiv_of_equiv",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (a : R)  (x : X) : s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s₁ s₂ : FormalSum R X)  (a : R)  (x : X)"},
 {"type":
  "0 ≠ s.coords x₀ → (∃ ys : FormalSum R X, (((s.coords x₀, x₀) :: ys) ≃ s) ∧ (List.length ys < s.length))",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) (s : FormalSum R X) : 0 ≠ s.coords x₀ → (∃ ys : FormalSum R X, (((s.coords x₀, x₀) :: ys) ≃ s) ∧ (List.length ys < s.length)) := by induction s; sorry",
  "name": "nonzero_coeff_has_complement",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) (s : FormalSum R X) : 0 ≠ s.coords x₀ → (∃ ys : FormalSum R X, (((s.coords x₀, x₀) :: ys) ≃ s) ∧ (List.length ys < s.length))",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x₀ : X) (s : FormalSum R X)"},
 {"type":
  "(∀ s₁ s₂ : FormalSum R X, ∀ mv : ElementaryMove R X s₁ s₂, f s₁ = f s₂) → (∀ s₁ s₂ : FormalSum R X, s₁ ≈ s₂ → f s₁ = f s₂)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {β : Sort u}  (f : FormalSum R X → β) : (∀ s₁ s₂ : FormalSum R X, ∀ mv : ElementaryMove R X s₁ s₂, f s₁ = f s₂) → (∀ s₁ s₂ : FormalSum R X, s₁ ≈ s₂ → f s₁ = f s₂) := by intro hyp; sorry",
  "name": "func_eql_of_move_equiv",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {β : Sort u}  (f : FormalSum R X → β) : (∀ s₁ s₂ : FormalSum R X, ∀ mv : ElementaryMove R X s₁ s₂, f s₁ = f s₂) → (∀ s₁ s₂ : FormalSum R X, s₁ ≈ s₂ → f s₁ = f s₂)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {β : Sort u}  (f : FormalSum R X → β)"},
 {"type": "a ≤ max a b",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : a ≤ max a b := by simp [max]; sorry",
  "name": "fst_le_max",
  "kind": "theorem",
  "first-tactic": "simp [max]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : a ≤ max a b",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat)"},
 {"type": "b ≤ max a b",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : b ≤ max a b := by simp [max]; sorry",
  "name": "snd_le_max",
  "kind": "theorem",
  "first-tactic": "simp [max]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : b ≤ max a b",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat)"},
 {"type": "(max a b = a) ∨ (max a b = b)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : (max a b = a) ∨ (max a b = b) := by simp [max]; sorry",
  "name": "eq_fst_or_snd_of_max",
  "kind": "theorem",
  "first-tactic": "simp [max]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : (max a b = a) ∨ (max a b = b)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat)"},
 {"type":
  "maxNormSuccOnSupp norm crds s > 0 → \n  ∃ x : X, crds x ≠ 0 ∧ maxNormSuccOnSupp norm crds s = norm x + 1",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X) : maxNormSuccOnSupp norm crds s > 0 → \n  ∃ x : X, crds x ≠ 0 ∧ maxNormSuccOnSupp norm crds s = norm x + 1 := by intro h; sorry",
  "name": "max_in_support",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X) : maxNormSuccOnSupp norm crds s > 0 → \n  ∃ x : X, crds x ≠ 0 ∧ maxNormSuccOnSupp norm crds s = norm x + 1",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X)"},
 {"type":
  "(x: X) → x ∈ s →  crds x ≠ 0 → norm x + 1 ≤ maxNormSuccOnSupp norm crds s",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X) : (x: X) → x ∈ s →  crds x ≠ 0 → norm x + 1 ≤ maxNormSuccOnSupp norm crds s := by intro x h₁ h₂; sorry",
  "name": "supp_below_max",
  "kind": "theorem",
  "first-tactic": "intro x h₁ h₂",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X) : (x: X) → x ∈ s →  crds x ≠ 0 → norm x + 1 ≤ maxNormSuccOnSupp norm crds s",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X → Nat) (crds : X → R) (s: List X)"},
 {"type": "s₁.normSucc norm = s₂.normSucc norm",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm : X → Nat) (s₁ s₂: FormalSum R X) (eql : s₁ ≈ s₂) : s₁.normSucc norm = s₂.normSucc norm := by apply Nat.le_antisymm <;> apply normsucc_le; sorry",
  "name": "norm_succ_eq",
  "kind": "theorem",
  "first-tactic": "apply Nat.le_antisymm <;> apply normsucc_le",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm : X → Nat) (s₁ s₂: FormalSum R X) (eql : s₁ ≈ s₂) : s₁.normSucc norm = s₂.normSucc norm",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm : X → Nat) (s₁ s₂: FormalSum R X) (eql : s₁ ≈ s₂)"},
 {"type": "Nat",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) [nx : NormCube X] : Nat := by let f : FormalSum R X → Nat := fun s => s.normSucc (nx.norm); sorry",
  "name": "FreeModule.normBound",
  "kind": "def",
  "first-tactic":
  "let f : FormalSum R X → Nat := fun s => s.normSucc (nx.norm)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) [nx : NormCube X] : Nat",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) [nx : NormCube X]"},
 {"type": "(EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z) := by intro p q; sorry",
  "name": "multiply",
  "kind": "def",
  "first-tactic": "intro p q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}"},
 {"type": "G.init e = x → (term G (G.bar e) = x)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x) := by intro h; sorry",
  "name": "term_bar_equals_init",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x : V} {e : E}"},
 {"type": "(term G e = x) → G.init (G.bar e) = x",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x :V}  {e : E} : (term G e = x) → G.init (G.bar e) = x := by intro hyp; sorry",
  "name": "init_bar_equals_term",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x :V}  {e : E} : (term G e = x) → G.init (G.bar e) = x",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x :V}  {e : E}"},
 {"type": "(multiply (multiply p q) r) = (multiply p (multiply q r))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r)) := by induction p; sorry",
  "name": "mult_assoc",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z)"},
 {"type": "(multiply p (single y)) = p",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p := by induction p; sorry",
  "name": "mult_const",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {p : EdgePath G x y}"},
 {"type": "{ rp : EdgePath G x z // rp.length ≤ (cons ex h₁ h₂ exy).length}",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : { rp : EdgePath G x z // rp.length ≤ (cons ex h₁ h₂ exy).length} := by cases exy; sorry",
  "name": "reducePathAux",
  "kind": "def",
  "first-tactic": "cases exy",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : { rp : EdgePath G x z // rp.length ≤ (cons ex h₁ h₂ exy).length}",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z)"},
 {"type": "homotopy p q → homotopy q r → homotopy p r",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y) : homotopy p q → homotopy q r → homotopy p r := by intro h₁ h₂; sorry",
  "name": "homotopy_trans",
  "kind": "theorem",
  "first-tactic": "intro h₁ h₂",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y) : homotopy p q → homotopy q r → homotopy p r",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y)"},
 {"type":
  "(p q : EdgePath G y z) → homotopy p q → (ex : E) →(h1 : G.init ex = x) → ( h : term G ex = y)→ homotopy (cons ex h1 h p) (cons ex h1 h q)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (p q : EdgePath G y z) → homotopy p q → (ex : E) →(h1 : G.init ex = x) → ( h : term G ex = y)→ homotopy (cons ex h1 h p) (cons ex h1 h q) := by intro p q h ex h1 h2; sorry",
  "name": "homotopy_left_mult_edge",
  "kind": "theorem",
  "first-tactic": "intro p q h ex h1 h2",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V} : (p q : EdgePath G y z) → homotopy p q → (ex : E) →(h1 : G.init ex = x) → ( h : term G ex = y)→ homotopy (cons ex h1 h p) (cons ex h1 h q)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}"},
 {"type": "(homotopy (multiply q p1) (multiply q p2))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2)) := by induction q; sorry",
  "name": "homotopy_left_mult",
  "kind": "theorem",
  "first-tactic": "induction q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2)"},
 {"type": "ht G y z →  ht G x z",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y) : ht G y z →  ht G x z := by let func: EdgePath G y z → ht G x z := by intro p ; exact htclass (multiply p₁ p); sorry",
  "name": "homotopy_left_multiplication",
  "kind": "def",
  "first-tactic":
  "let func: EdgePath G y z → ht G x z := by intro p ; exact htclass (multiply p₁ p)",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y) : ht G y z →  ht G x z",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)"},
 {"type":
  "homotopy_left_multiplication p₁ (htclass p₂) = htclass (multiply p₁ p₂)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)  (p₂ : EdgePath G y z) : homotopy_left_multiplication p₁ (htclass p₂) = htclass (multiply p₁ p₂) := by simp[htclass, homotopy_left_multiplication]\n\n\n\n--proves that reducePathAux preserves the homotopy class; sorry",
  "name": "homotopy_left_multiplication_class",
  "kind": "theorem",
  "first-tactic":
  "simp[htclass, homotopy_left_multiplication]\n\n\n\n--proves that reducePathAux preserves the homotopy class",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)  (p₂ : EdgePath G y z) : homotopy_left_multiplication p₁ (htclass p₂) = htclass (multiply p₁ p₂)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G :Graph V E}  {x y z : V}  (p₁ : EdgePath G x y)  (p₂ : EdgePath G y z)"},
 {"type": "homotopy (cons ex h₁ h₂ exy) (reducePathAux ex h₁ h₂ exy)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : homotopy (cons ex h₁ h₂ exy) (reducePathAux ex h₁ h₂ exy) := by simp[homotopy, htclass]; sorry",
  "name": "homotopy_reducePathAux",
  "kind": "theorem",
  "first-tactic": "simp[homotopy, htclass]",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z) : homotopy (cons ex h₁ h₂ exy) (reducePathAux ex h₁ h₂ exy)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (h₁ : G.init ex = x)  (h₂ : term G ex = y)  (exy : EdgePath G y z)"},
 {"type": "homotopy p₁ (reducePath p₁)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ : EdgePath G x y) : homotopy p₁ (reducePath p₁) := by induction p₁; sorry",
  "name": "homotopy_reducePath",
  "kind": "theorem",
  "first-tactic": "induction p₁",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ : EdgePath G x y) : homotopy p₁ (reducePath p₁)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {x₁ x₂ : V} {G : Graph V E}  {x y : V}  (p₁ : EdgePath G x y)"},
 {"type": "(succ n) * (succ m) =\n          succ ((succ n) * m + n)",
  "tactic-prompt":
  "theorem (n m: Nat) : (succ n) * (succ m) =\n          succ ((succ n) * m + n) := by rfl; sorry",
  "name": "mul_succ_succ",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (succ n) * (succ m) =\n          succ ((succ n) * m + n)",
  "args": "(n m: Nat)"},
 {"type": "n * m = 0 → n = 0 ∨ m = 0",
  "tactic-prompt":
  "theorem (n m: Nat) : n * m = 0 → n = 0 ∨ m = 0 := by cases n; sorry",
  "name": "nat_domain",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n m: Nat) : n * m = 0 → n = 0 ∨ m = 0",
  "args": "(n m: Nat)"},
 {"type":
  "(Int.ofNat (succ n)) * (Int.ofNat (succ m)) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "tactic-prompt":
  "theorem (n m: Nat) : (Int.ofNat (succ n)) * (Int.ofNat (succ m)) =\n         Int.ofNat (succ ((succ n) * m + n)) := by rfl; sorry",
  "name": "int_mul_succ_succ",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (Int.ofNat (succ n)) * (Int.ofNat (succ m)) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "args": "(n m: Nat)"},
 {"type":
  "(Int.ofNat (succ n)) * (Int.negSucc m) =\n         Int.negSucc ((succ n) * m + n)",
  "tactic-prompt":
  "theorem (n m: Nat) : (Int.ofNat (succ n)) * (Int.negSucc m) =\n         Int.negSucc ((succ n) * m + n) := by rfl; sorry",
  "name": "int_mul_succ_negsucc",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (Int.ofNat (succ n)) * (Int.negSucc m) =\n         Int.negSucc ((succ n) * m + n)",
  "args": "(n m: Nat)"},
 {"type":
  "(Int.negSucc n) * (Int.negSucc m) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "tactic-prompt":
  "theorem (n m: Nat) : (Int.negSucc n) * (Int.negSucc m) =\n         Int.ofNat (succ ((succ n) * m + n)) := by rfl; sorry",
  "name": "int_mul_negsucc_negsucc",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (Int.negSucc n) * (Int.negSucc m) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "args": "(n m: Nat)"},
 {"type": "n' * m' = 0 → n' = 0 ∨ m' = 0",
  "tactic-prompt":
  "theorem (n' m': Int) : n' * m' = 0 → n' = 0 ∨ m' = 0 := by cases n'; sorry",
  "name": "int_domain",
  "kind": "theorem",
  "first-tactic": "cases n'",
  "core-prompt": "(n' m': Int) : n' * m' = 0 → n' = 0 ∨ m' = 0",
  "args": "(n' m': Int)"},
 {"type": "a * b = a * c → b = c",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : a * b = a * c → b = c := by intro h; sorry",
  "name": "Group.mul_left_cancel",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : a * b = a * c → b = c",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "b * a = c * a → b = c",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : b * a = c * a → b = c := by intro h; sorry",
  "name": "Group.mul_right_cancel",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : b * a = c * a → b = c",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "(1 : G)⁻¹ = 1",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} {G : Type _}  [Group G] : (1 : G)⁻¹ = 1 := by have : (1 : G)⁻¹ * 1 = 1 := mul_left_inv 1; sorry",
  "name": "one_inv",
  "kind": "theorem",
  "first-tactic": "have : (1 : G)⁻¹ * 1 = 1 := mul_left_inv 1",
  "core-prompt":
  "{G : Type u}  [Group G]  {a b c : G} {G : Type _}  [Group G] : (1 : G)⁻¹ = 1",
  "args": "{G : Type u}  [Group G]  {a b c : G} {G : Type _}  [Group G]"},
 {"type": "a * b = a ↔ b = 1",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : a * b = a ↔ b = 1 := by apply Iff.intro; sorry",
  "name": "mul_left_eq_cancel",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : a * b = a ↔ b = 1",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "b * a = a ↔ b = 1",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : b * a = a ↔ b = 1 := by apply Iff.intro; sorry",
  "name": "mul_right_eq_cancel",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : b * a = a ↔ b = 1",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "a + b = a ↔ b = 0",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {a b c : A} : a + b = a ↔ b = 0 := by apply Iff.intro; sorry",
  "name": "add_left_eq_cancel",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c : A} : a + b = a ↔ b = 0",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c : A}"},
 {"type": "b + a = a ↔ b = 0",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {a b c : A} : b + a = a ↔ b = 0 := by rw [add_comm]; sorry",
  "name": "add_right_eq_cancel",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c : A} : b + a = a ↔ b = 0",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c : A}"},
 {"type": "(-0 : A) = (0 : A)",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {a b c : A} : (-0 : A) = (0 : A) := by have : (-0 : A) + (0 : A) = (0 : A) := neg_add_self (0 : A); sorry",
  "name": "neg_zero",
  "kind": "theorem",
  "first-tactic": "have : (-0 : A) + (0 : A) = (0 : A) := neg_add_self (0 : A)",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c : A} : (-0 : A) = (0 : A)",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c : A}"},
 {"type": "ϕ 1 = 1",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] : ϕ 1 = 1 := by have : (ϕ 1) * (ϕ 1) = (ϕ 1) * 1 := by rw [← Homomorphism.mul_distrib, mul_one, mul_one]; sorry",
  "name": "one_image",
  "kind": "theorem",
  "first-tactic":
  "have : (ϕ 1) * (ϕ 1) = (ϕ 1) * 1 := by rw [← Homomorphism.mul_distrib, mul_one, mul_one]",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] : ϕ 1 = 1",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]"},
 {"type": "(ϕ g)⁻¹ = ϕ g⁻¹",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G} : (ϕ g)⁻¹ = ϕ g⁻¹ := by have : ϕ g * ϕ g⁻¹ = ϕ g * (ϕ g)⁻¹ := by rw [← Homomorphism.mul_distrib]; simp; sorry",
  "name": "hom_inv",
  "kind": "theorem",
  "first-tactic":
  "have : ϕ g * ϕ g⁻¹ = ϕ g * (ϕ g)⁻¹ := by rw [← Homomorphism.mul_distrib]; simp",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G} : (ϕ g)⁻¹ = ϕ g⁻¹",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G}"},
 {"type": "(ϕ g) ^ n = ϕ (g ^ n)",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G}  {n : ℕ} : (ϕ g) ^ n = ϕ (g ^ n) := by induction n; sorry",
  "name": "hom_pow",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G}  {n : ℕ} : (ϕ g) ^ n = ϕ (g ^ n)",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {g : G}  {n : ℕ}"},
 {"type": "SubNegMonoid.gsmul (↑(n) + 1) a = a + SubNegMonoid.gsmul (↑ n) a",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) (n : ℕ) : SubNegMonoid.gsmul (↑(n) + 1) a = a + SubNegMonoid.gsmul (↑ n) a := by rw [← Int.cast_ofNat, Int.cast_id, ← Int.ofNat_succ]; sorry",
  "name": "SubNegMonoid.gsmul_succ'_",
  "kind": "theorem",
  "first-tactic": "rw [← Int.cast_ofNat, Int.cast_id, ← Int.ofNat_succ]",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) (n : ℕ) : SubNegMonoid.gsmul (↑(n) + 1) a = a + SubNegMonoid.gsmul (↑ n) a",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) (n : ℕ)"},
 {"type": "SubNegMonoid.gsmul 1 a = a",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) : SubNegMonoid.gsmul 1 a = a := by rw [← Int.ofNat_one, gsmul_succ', Int.ofNat_zero, gsmul_zero', add_zero]; sorry",
  "name": "SubNegMonoid.gsmul_one",
  "kind": "theorem",
  "first-tactic":
  "rw [← Int.ofNat_one, gsmul_succ', Int.ofNat_zero, gsmul_zero', add_zero]",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A) : SubNegMonoid.gsmul 1 a = a",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ]  {A : Type _}  [SubNegMonoid A]  (a : A)"},
 {"type": "ϕ (0 : A) = (0 : B)",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ϕ (0 : A) = (0 : B) := by have : ϕ 0 + ϕ 0 = ϕ 0 + 0 := by rw [← add_dist]; simp; sorry",
  "name": "zero_image",
  "kind": "theorem",
  "first-tactic": "have : ϕ 0 + ϕ 0 = ϕ 0 + 0 := by rw [← add_dist]; simp",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ϕ (0 : A) = (0 : B)",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "∀ a : A, ϕ (-a) = -ϕ a",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a : A, ϕ (-a) = -ϕ a := by intro a; sorry",
  "name": "neg_push",
  "kind": "theorem",
  "first-tactic": "intro a",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a : A, ϕ (-a) = -ϕ a",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "∀ a a' : A, ϕ (a - a') = ϕ a - ϕ a'",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a a' : A, ϕ (a - a') = ϕ a - ϕ a' := by intros; sorry",
  "name": "neg_dist",
  "kind": "theorem",
  "first-tactic": "intros",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a a' : A, ϕ (a - a') = ϕ a - ϕ a'",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "∀ a : A, ∀ n : ℕ, n • (ϕ a) = ϕ (n • a)",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a : A, ∀ n : ℕ, n • (ϕ a) = ϕ (n • a) := by intro a n; sorry",
  "name": "hom_mul",
  "kind": "theorem",
  "first-tactic": "intro a n",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a : A, ∀ n : ℕ, n • (ϕ a) = ϕ (n • a)",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type":
  "∀ n : ℕ, ∀ a b : A, nsmul_rec n (a + b) = nsmul_rec n a + nsmul_rec n b",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ n : ℕ, ∀ a b : A, nsmul_rec n (a + b) = nsmul_rec n a + nsmul_rec n b := by intros n a b; sorry",
  "name": "nsmul_hom",
  "kind": "theorem",
  "first-tactic": "intros n a b",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ n : ℕ, ∀ a b : A, nsmul_rec n (a + b) = nsmul_rec n a + nsmul_rec n b",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type":
  "∀ n : ℤ, ∀ a b : A, gsmul_rec n (a + b) = gsmul_rec n a + gsmul_rec n b",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ n : ℤ, ∀ a b : A, gsmul_rec n (a + b) = gsmul_rec n a + gsmul_rec n b := by intros n a b; sorry",
  "name": "gsmul_hom",
  "kind": "theorem",
  "first-tactic": "intros n a b",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ n : ℤ, ∀ a b : A, gsmul_rec n (a + b) = gsmul_rec n a + gsmul_rec n b",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "∀ a a' : A, -(a + a') = -a + -a'",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a a' : A, -(a + a') = -a + -a' := by intro a a'; sorry",
  "name": "neg_hom",
  "kind": "theorem",
  "first-tactic": "intro a a'",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ] : ∀ a a' : A, -(a + a') = -a + -a'",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]"},
 {"type": "AddCommGroup.Isomorphism A A",
  "tactic-prompt":
  "instance {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  (A B C : Type _)  [AddCommGroup A]  [AddCommGroup B]  [AddCommGroup C] [AddCommGroup.Isomorphism A A] : AddCommGroup.Isomorphism A A := by assumption; sorry",
  "name": "refl",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  (A B C : Type _)  [AddCommGroup A]  [AddCommGroup B]  [AddCommGroup C] [AddCommGroup.Isomorphism A A] : AddCommGroup.Isomorphism A A",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {ϕ : G → H}  [Homϕ : Group.Homomorphism ϕ] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (ϕ : A → B)  [AddCommGroup.Homomorphism ϕ]  (A B C : Type _)  [AddCommGroup A]  [AddCommGroup B]  [AddCommGroup C] [AddCommGroup.Isomorphism A A]"},
 {"type": "x + x + y - x - y + z - x = z",
  "tactic-prompt":
  "example {x y z : ℤ} : x + x + y - x - y + z - x = z := by have p := freeGroupEq# (x + x + y - x - y + z - x); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq# (x + x + y - x - y + z - x)",
  "core-prompt": "{x y z : ℤ} : x + x + y - x - y + z - x = z",
  "args": "{x y z : ℤ}"},
 {"type": "(a + b) - (b - a) - a = a",
  "tactic-prompt":
  "example {A : Type _}  [AddCommGroup A]  {a b : A} : (a + b) - (b - a) - a = a := by have p := freeGroupEq# ((a + b) - (b - a) - a); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq# ((a + b) - (b - a) - a)",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b : A} : (a + b) - (b - a) - a = a",
  "args": "{A : Type _}  [AddCommGroup A]  {a b : A}"},
 {"type": "a + b - a - b = b - b + a - a",
  "tactic-prompt":
  "example {a b : ℤ} : a + b - a - b = b - b + a - a := by have pₗ := freeGroupEq# (a + b - a - b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have pₗ := freeGroupEq# (a + b - a - b)",
  "core-prompt": "{a b : ℤ} : a + b - a - b = b - b + a - a",
  "args": "{a b : ℤ}"},
 {"type": "a + b - c - d + e - a + b + c - a - e + a - b + d - b = 0",
  "tactic-prompt":
  "example {A : Type _}  [AddCommGroup A]  {a b c d e : A} : a + b - c - d + e - a + b + c - a - e + a - b + d - b = 0 := by have p := freeGroupEq# (a + b - c - d + e - a + b + c - a - e + a - b + d - b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "have p := freeGroupEq# (a + b - c - d + e - a + b + c - a - e + a - b + d - b)",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c d e : A} : a + b - c - d + e - a + b + c - a - e + a - b + d - b = 0",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c d e : A}"},
 {"type": "arr.getIdx? a = some i → arr.size > 0",
  "tactic-prompt":
  "lemma {α : Type _}  [DecidableEq α]  {arr : Array α}  {a : α}  {i : ℕ} : arr.getIdx? a = some i → arr.size > 0 := by rw [getIdx?, findIdx?, findIdx?.loop]; sorry",
  "name": "Array.size_pos_if_index",
  "kind": "lemma",
  "first-tactic": "rw [getIdx?, findIdx?, findIdx?.loop]",
  "core-prompt":
  "{α : Type _}  [DecidableEq α]  {arr : Array α}  {a : α}  {i : ℕ} : arr.getIdx? a = some i → arr.size > 0",
  "args": "{α : Type _}  [DecidableEq α]  {arr : Array α}  {a : α}  {i : ℕ}"},
 {"type": "(arr.push a).size > 0",
  "tactic-prompt":
  "lemma {α : Type _}  (arr : Array α)  (a : α) : (arr.push a).size > 0 := by match arr with\n    | ⟨l⟩ =>\n      simp only [push, size]\n      induction l with\n        | nil => simp only [List.concat, List.length]\n        | cons _ _ _ => simp only [List.concat, List.length, Nat.add_one]; apply Nat.succ_pos; sorry",
  "name": "Array.push_size_pos",
  "kind": "lemma",
  "first-tactic":
  "match arr with\n    | ⟨l⟩ =>\n      simp only [push, size]\n      induction l with\n        | nil => simp only [List.concat, List.length]\n        | cons _ _ _ => simp only [List.concat, List.length, Nat.add_one]; apply Nat.succ_pos",
  "core-prompt":
  "{α : Type _}  (arr : Array α)  (a : α) : (arr.push a).size > 0",
  "args": "{α : Type _}  (arr : Array α)  (a : α)"},
 {"type": "(arr : Array α) → (t.indexTree arr).2.size > 0",
  "tactic-prompt":
  "theorem {α : Type _} [Repr α] [DecidableEq α]  (t: AddTree α) : (arr : Array α) → (t.indexTree arr).2.size > 0 := by induction t; sorry",
  "name": "pos_size",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "{α : Type _} [Repr α] [DecidableEq α]  (t: AddTree α) : (arr : Array α) → (t.indexTree arr).2.size > 0",
  "args": "{α : Type _} [Repr α] [DecidableEq α]  (t: AddTree α)"},
 {"type": "egIndMap x y = x + y + x - y",
  "tactic-prompt":
  "theorem {α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α]     (x y: α) : egIndMap x y = x + y + x - y := by simp; sorry",
  "name": "egIndMapInv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α]     (x y: α) : egIndMap x y = x + y + x - y",
  "args":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α]     (x y: α)"},
 {"type": "egIndMap'' x y = x + y + x - y",
  "tactic-prompt":
  "theorem {α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]     (x y: α) : egIndMap'' x y = x + y + x - y := by simp; sorry",
  "name": "egIndMapInv''",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]     (x y: α) : egIndMap'' x y = x + y + x - y",
  "args":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]     (x y: α)"},
 {"type": "x + y + x - y =  roundtrip# (x + y + x - y)",
  "tactic-prompt":
  "theorem {α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]       (x y : α) : x + y + x - y =  roundtrip# (x + y + x - y) := by rfl; sorry",
  "name": "egRoundtrip",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]       (x y : α) : x + y + x - y =  roundtrip# (x + y + x - y)",
  "args":
  "{α : Type _} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]       (x y : α)"},
 {"type": "x⁻¹ * (x * y) = y",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x⁻¹ * (x * y) = y := by rw [← mul_assoc]; sorry",
  "name": "left_inv_cancel",
  "kind": "theorem",
  "first-tactic": "rw [← mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x⁻¹ * (x * y) = y",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "(1 : G)⁻¹ = (1 : G)",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (1 : G)⁻¹ = (1 : G) := by have := left_inv_cancel (1 : G) (1 : G); sorry",
  "name": "one_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (1 : G) (1 : G)",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (1 : G)⁻¹ = (1 : G)",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "(x⁻¹)⁻¹ = x",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x⁻¹)⁻¹ = x := by have := left_inv_cancel (x⁻¹) x; sorry",
  "name": "inv_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (x⁻¹) x",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x⁻¹)⁻¹ = x",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "x * x⁻¹ = 1",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * x⁻¹ = 1 := by have := left_inv_cancel (x⁻¹) (1 : G); sorry",
  "name": "mul_right_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (x⁻¹) (1 : G)",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * x⁻¹ = 1",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "x * (x⁻¹ * y) = y",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * (x⁻¹ * y) = y := by have := left_inv_cancel (x⁻¹) y; sorry",
  "name": "left_cancel_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (x⁻¹) y",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * (x⁻¹ * y) = y",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "(x * y)⁻¹ = y⁻¹ * x⁻¹",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x * y)⁻¹ = y⁻¹ * x⁻¹ := by have := left_cancel_inv (x * y)⁻¹ (y⁻¹ * x⁻¹); sorry",
  "name": "prod_inv",
  "kind": "theorem",
  "first-tactic": "have := left_cancel_inv (x * y)⁻¹ (y⁻¹ * x⁻¹)",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x * y)⁻¹ = y⁻¹ * x⁻¹",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "((a⁻¹ * a) * (b * b⁻¹))⁻¹ = (1 : G)",
  "tactic-prompt":
  "example {G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : ((a⁻¹ * a) * (b * b⁻¹))⁻¹ = (1 : G) := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : ((a⁻¹ * a) * (b * b⁻¹))⁻¹ = (1 : G)",
  "args":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G)"},
 {"type": "b * ((a * b)⁻¹ * a) = 1",
  "tactic-prompt":
  "example {G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : b * ((a * b)⁻¹ * a) = 1 := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : b * ((a * b)⁻¹ * a) = 1",
  "args":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G)"},
 {"type": "a * (c⁻¹ * b) * (((b⁻¹ * c) * b) * (a * b)⁻¹) = (1 : G)",
  "tactic-prompt":
  "example {G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : a * (c⁻¹ * b) * (((b⁻¹ * c) * b) * (a * b)⁻¹) = (1 : G) := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : a * (c⁻¹ * b) * (((b⁻¹ * c) * b) * (a * b)⁻¹) = (1 : G)",
  "args":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G)"},
 {"type":
  "(∀ (A : Type) [AddCommGroup A], ∀ x y z : A, (ν A x y z)) ↔ (ν (ℤ × ℤ × ℤ) (1, 0, 0) (0, 1, 0) (0, 0, 1))",
  "tactic-prompt":
  "theorem  : (∀ (A : Type) [AddCommGroup A], ∀ x y z : A, (ν A x y z)) ↔ (ν (ℤ × ℤ × ℤ) (1, 0, 0) (0, 1, 0) (0, 0, 1)) := by apply Iff.intro; sorry",
  "name": "eqn_iff_free_basis",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  " : (∀ (A : Type) [AddCommGroup A], ∀ x y z : A, (ν A x y z)) ↔ (ν (ℤ × ℤ × ℤ) (1, 0, 0) (0, 1, 0) (0, 0, 1))",
  "args": ""},
 {"type": "∀ l' : List α, List.toArrayAux l {data := l'} = {data := l' ++ l}",
  "tactic-prompt":
  "lemma {α : Type _}  (l : List α) : ∀ l' : List α, List.toArrayAux l {data := l'} = {data := l' ++ l} := by induction l; sorry",
  "name": "List.aux_append",
  "kind": "lemma",
  "first-tactic": "induction l",
  "core-prompt":
  "{α : Type _}  (l : List α) : ∀ l' : List α, List.toArrayAux l {data := l'} = {data := l' ++ l}",
  "args": "{α : Type _}  (l : List α)"},
 {"type": "l.toArray.data = l",
  "tactic-prompt":
  "theorem {A : Type _}  (l : List A) : l.toArray.data = l := by rw [toArray, Array.mkEmpty, List.aux_append]; sorry",
  "name": "List.arraydata",
  "kind": "theorem",
  "first-tactic": "rw [toArray, Array.mkEmpty, List.aux_append]",
  "core-prompt": "{A : Type _}  (l : List A) : l.toArray.data = l",
  "args": "{A : Type _}  (l : List A)"},
 {"type": "l.toArray.size = l.length",
  "tactic-prompt":
  "theorem {α : Type _}  (l : List α) : l.toArray.size = l.length := by rw [Array.size, arraydata]\n\n-- a helper lemma for solving rewriting issues with `Fin`; sorry",
  "name": "List.arraysize",
  "kind": "theorem",
  "first-tactic":
  "rw [Array.size, arraydata]\n\n-- a helper lemma for solving rewriting issues with `Fin`",
  "core-prompt": "{α : Type _}  (l : List α) : l.toArray.size = l.length",
  "args": "{α : Type _}  (l : List α)"},
 {"type": "List.length (h :: tl) = Nat.succ m → List.length tl = m",
  "tactic-prompt":
  "theorem  : List.length (h :: tl) = Nat.succ m → List.length tl = m := by intro hyp; sorry",
  "name": "List.cons_len_eq_succ",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt": " : List.length (h :: tl) = Nat.succ m → List.length tl = m",
  "args": ""},
 {"type":
  "IndexAddTree.foldMap t l.toArray (by simp [h, hpos]) =\n                         (inducedFreeMap l h) (IndexAddTree.foldMap t (ℤbasis n).toArray (by simp [hpos]))",
  "tactic-prompt":
  "theorem (t : IndexAddTree) {A : Type _}  [AddCommGroup A]  [Repr A] {n : ℕ}  (l : List A)  (h : l.length = n)  (hpos : n > 0) -- basisImages  -- a few helper results and lemmas : IndexAddTree.foldMap t l.toArray (by simp [h, hpos]) =\n                         (inducedFreeMap l h) (IndexAddTree.foldMap t (ℤbasis n).toArray (by simp [hpos])) := by induction t; sorry",
  "name": "IndexAddTree.fold_tree_freegroup_eq",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "(t : IndexAddTree) {A : Type _}  [AddCommGroup A]  [Repr A] {n : ℕ}  (l : List A)  (h : l.length = n)  (hpos : n > 0) -- basisImages  -- a few helper results and lemmas : IndexAddTree.foldMap t l.toArray (by simp [h, hpos]) =\n                         (inducedFreeMap l h) (IndexAddTree.foldMap t (ℤbasis n).toArray (by simp [hpos]))",
  "args":
  "(t : IndexAddTree) {A : Type _}  [AddCommGroup A]  [Repr A] {n : ℕ}  (l : List A)  (h : l.length = n)  (hpos : n > 0) -- basisImages  -- a few helper results and lemmas"},
 {"type": "s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]  (s₁ s₂ : FormalSum X)  (a: Nat)  (x: X) : s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂ := by intro h; sorry",
  "name": "cons_equiv_of_equiv",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]  (s₁ s₂ : FormalSum X)  (a: Nat)  (x: X) : s₁ ≃ s₂ → (a, x) :: s₁ ≃ (a, x) :: s₂",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]  (s₁ s₂ : FormalSum X)  (a: Nat)  (x: X)"},
 {"type":
  "monomCoeff x₀ (a + b, x) = monomCoeff x₀ (a, x) + monomCoeff x₀ (b, x)",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x₀ x : X) (a b : Nat) : monomCoeff x₀ (a + b, x) = monomCoeff x₀ (a, x) + monomCoeff x₀ (b, x) := by repeat (rw [monomCoeff]); sorry",
  "name": "monom_coeff_hom",
  "kind": "theorem",
  "first-tactic": "repeat (rw [monomCoeff])",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x₀ x : X) (a b : Nat) : monomCoeff x₀ (a + b, x) = monomCoeff x₀ (a, x) + monomCoeff x₀ (b, x)",
  "args": "(X: Type) [DecidableEq X] (x₀ x : X) (a b : Nat)"},
 {"type": "monomCoeff x₀ (0, x) = 0",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x₀ x : X) : monomCoeff x₀ (0, x) = 0 := by rw [monomCoeff]; sorry",
  "name": "monom_coeff_at_zero",
  "kind": "theorem",
  "first-tactic": "rw [monomCoeff]",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x₀ x : X) : monomCoeff x₀ (0, x) = 0",
  "args": "(X: Type) [DecidableEq X] (x₀ x : X)"},
 {"type": "coeff  x₀  s₁ = coeff  x₀ s₂",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x₀ : X) (s₁ s₂: FormalSum X) (h: BasicRel X s₁ s₂) : coeff  x₀  s₁ = coeff  x₀ s₂ := by induction h; sorry",
  "name": "coeff_move_invariant",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x₀ : X) (s₁ s₂: FormalSum X) (h: BasicRel X s₁ s₂) : coeff  x₀  s₁ = coeff  x₀ s₂",
  "args":
  "(X: Type) [DecidableEq X] (x₀ : X) (s₁ s₂: FormalSum X) (h: BasicRel X s₁ s₂)"},
 {"type": "FreeNatModuleAux.coeff X x (sum s) = coeff x s",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x: X) (s: FormalSum X) : FreeNatModuleAux.coeff X x (sum s) = coeff x s := by simp [FreeNatModuleAux.coeff]; sorry",
  "name": "coeff_factors",
  "kind": "theorem",
  "first-tactic": "simp [FreeNatModuleAux.coeff]",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x: X) (s: FormalSum X) : FreeNatModuleAux.coeff X x (sum s) = coeff x s",
  "args": "(X: Type) [DecidableEq X] (x: X) (s: FormalSum X)"},
 {"type": "s₁ ≃ s₂ → (coeff x s₁) = (coeff x s₂)",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x: X) (s₁ s₂: FormalSum X) : s₁ ≃ s₂ → (coeff x s₁) = (coeff x s₂) := by intro hyp; sorry",
  "name": "coeff_well_defined",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x: X) (s₁ s₂: FormalSum X) : s₁ ≃ s₂ → (coeff x s₁) = (coeff x s₂)",
  "args": "(X: Type) [DecidableEq X] (x: X) (s₁ s₂: FormalSum X)"},
 {"type":
  "0 < s.coeff x₀  → \n          (∃ ys: FormalSum X, \n            (((s.coeff x₀, x₀) :: ys) ≃ s) ∧ \n            (List.length ys < s.length))",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x₀ : X) (s : FormalSum X) : 0 < s.coeff x₀  → \n          (∃ ys: FormalSum X, \n            (((s.coeff x₀, x₀) :: ys) ≃ s) ∧ \n            (List.length ys < s.length)) := by induction s; sorry",
  "name": "pos_coeff_has_complement",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x₀ : X) (s : FormalSum X) : 0 < s.coeff x₀  → \n          (∃ ys: FormalSum X, \n            (((s.coeff x₀, x₀) :: ys) ≃ s) ∧ \n            (List.length ys < s.length))",
  "args": "(X: Type) [DecidableEq X] (x₀ : X) (s : FormalSum X)"},
 {"type": "f = g → equalOnSupport l f g",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]    (l: List X) (f g : X → Nat) : f = g → equalOnSupport l f g := by intro hyp; sorry",
  "name": "equal_on_support_of_equal",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]    (l: List X) (f g : X → Nat) : f = g → equalOnSupport l f g",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]    (l: List X) (f g : X → Nat)"},
 {"type": "eqlCoords X s s",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (s: FormalSum X) : eqlCoords X s s := by rfl; sorry",
  "name": "refl",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (s: FormalSum X) : eqlCoords X s s",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (s: FormalSum X)"},
 {"type": "eqlCoords X s₁ s₂ → eqlCoords X s₂ s₁",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ : FormalSum X} : eqlCoords X s₁ s₂ → eqlCoords X s₂ s₁ := by intro hyp; sorry",
  "name": "symm",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ : FormalSum X} : eqlCoords X s₁ s₂ → eqlCoords X s₂ s₁",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ : FormalSum X}"},
 {"type": "eqlCoords X s₁ s₂ → eqlCoords X s₂ s₃ → eqlCoords X s₁ s₃",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ s₃ : FormalSum X} : eqlCoords X s₁ s₂ → eqlCoords X s₂ s₃ → eqlCoords X s₁ s₃ := by intro hyp₁ hyp₂; sorry",
  "name": "trans",
  "kind": "theorem",
  "first-tactic": "intro hyp₁ hyp₂",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ s₃ : FormalSum X} : eqlCoords X s₁ s₂ → eqlCoords X s₂ s₃ → eqlCoords X s₁ s₃",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {s₁ s₂ s₃ : FormalSum X}"},
 {"type":
  "(∀ s₁ s₂ : FormalSum X, ∀ mv : BasicRel X s₁ s₂, f s₁ = f s₂) → \n  (∀ s₁ s₂ : FormalSum X, s₁ ≈ s₂ →  f s₁ = f s₂)",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {β : Sort u}    (f : FormalSum X → β) : (∀ s₁ s₂ : FormalSum X, ∀ mv : BasicRel X s₁ s₂, f s₁ = f s₂) → \n  (∀ s₁ s₂ : FormalSum X, s₁ ≈ s₂ →  f s₁ = f s₂) := by intro hyp; sorry",
  "name": "func_eql_of_move_equiv",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {β : Sort u}    (f : FormalSum X → β) : (∀ s₁ s₂ : FormalSum X, ∀ mv : BasicRel X s₁ s₂, f s₁ = f s₂) → \n  (∀ s₁ s₂ : FormalSum X, s₁ ≈ s₂ →  f s₁ = f s₂)",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {β : Sort u}    (f : FormalSum X → β)"},
 {"type": "FreeNatModule X → Nat",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (f₀ : X → Nat) : FreeNatModule X → Nat := by apply Quotient.lift (linear_extension f₀); sorry",
  "name": "miniUniversalProperty",
  "kind": "def",
  "first-tactic": "apply Quotient.lift (linear_extension f₀)",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (f₀ : X → Nat) : FreeNatModule X → Nat",
  "args": "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (f₀ : X → Nat)"},
 {"type": "Bool",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X) : Bool := by apply Quotient.lift₂ (fun (s₁ s₂ : FormalSum X) => \n          decide ( ⟦ s₁ ⟧ = ⟦ s₂ ⟧)); sorry",
  "name": "FreeNatModule.beq?",
  "kind": "def",
  "first-tactic":
  "apply Quotient.lift₂ (fun (s₁ s₂ : FormalSum X) => \n          decide ( ⟦ s₁ ⟧ = ⟦ s₂ ⟧))",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X) : Bool",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X)"},
 {"type": "∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = true → x₁ = x₂",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : ∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = true → x₁ = x₂ := by let f := @Quotient.ind₂ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (x₁ x₂ : FreeNatModule X) =>   x₁.beq? x₂ = true → x₁ = x₂); sorry",
  "name": "FreeNatModule.eq_of_beq_true",
  "kind": "def",
  "first-tactic":
  "let f := @Quotient.ind₂ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (x₁ x₂ : FreeNatModule X) =>   x₁.beq? x₂ = true → x₁ = x₂)",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : ∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = true → x₁ = x₂",
  "args": "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]"},
 {"type": "∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = false → Not (x₁ = x₂)",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : ∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = false → Not (x₁ = x₂) := by let f := @Quotient.ind₂ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (x₁ x₂ : FreeNatModule X) =>   x₁.beq? x₂ = false →\n                Not (x₁ = x₂)); sorry",
  "name": "FreeNatModule.neq_of_beq_false",
  "kind": "def",
  "first-tactic":
  "let f := @Quotient.ind₂ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (x₁ x₂ : FreeNatModule X) =>   x₁.beq? x₂ = false →\n                Not (x₁ = x₂))",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : ∀ x₁ x₂ : FreeNatModule X,  x₁.beq? x₂ = false → Not (x₁ = x₂)",
  "args": "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]"},
 {"type": "Decidable (x₁ = x₂)",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X) : Decidable (x₁ = x₂) := by match p:x₁.beq? x₂ with\n    | true => \n      apply Decidable.isTrue\n      apply FreeNatModule.eq_of_beq_true\n      assumption\n    | false => \n      apply Decidable.isFalse\n      apply FreeNatModule.neq_of_beq_false\n      assumption; sorry",
  "name": "FreeNatModule.decEq",
  "kind": "def",
  "first-tactic":
  "match p:x₁.beq? x₂ with\n    | true => \n      apply Decidable.isTrue\n      apply FreeNatModule.eq_of_beq_true\n      assumption\n    | false => \n      apply Decidable.isFalse\n      apply FreeNatModule.neq_of_beq_false\n      assumption",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X) : Decidable (x₁ = x₂)",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (x₁ x₂ : FreeNatModule X)"},
 {"type": "(EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z) := by intro p q; sorry",
  "name": "multiply",
  "kind": "def",
  "first-tactic": "intro p q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V} : (EdgePath G x y) → (EdgePath G y z) → (EdgePath G x z)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}"},
 {"type": "G.init e = x → (term G (G.bar e) = x)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x) := by intro h; sorry",
  "name": "lemma1",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x : V} {e : E} : G.init e = x → (term G (G.bar e) = x)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x : V} {e : E}"},
 {"type": "(multiply (multiply p q) r) = (multiply p (multiply q r))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r)) := by induction p; sorry",
  "name": "mult_assoc",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z)"},
 {"type": "(multiply p (single y)) = p",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p := by induction p; sorry",
  "name": "mult_const",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {p : EdgePath G x y}"},
 {"type": "(homotopy (multiply q p1) (multiply q p2))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2)) := by induction q; sorry",
  "name": "homotopy_left_mult",
  "kind": "theorem",
  "first-tactic": "induction q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2)"},
 {"type": "(inducedFreeMap l h) (ℤbasisElem n k) = l.get ⟨k, h ▸ hk⟩",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {n : ℕ}  (l : List A)  (h : l.length = n)  (k: ℕ)  (hk : k < n) : (inducedFreeMap l h) (ℤbasisElem n k) = l.get ⟨k, h ▸ hk⟩ := by rw [ℤbasisElem, List.get!_of_get, List.mapget (inducedFreeMap l h)]; sorry",
  "name": "induced_free_map_at",
  "kind": "theorem",
  "first-tactic":
  "rw [ℤbasisElem, List.get!_of_get, List.mapget (inducedFreeMap l h)]",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {n : ℕ}  (l : List A)  (h : l.length = n)  (k: ℕ)  (hk : k < n) : (inducedFreeMap l h) (ℤbasisElem n k) = l.get ⟨k, h ▸ hk⟩",
  "args":
  "{A : Type _}  [AddCommGroup A]  {n : ℕ}  (l : List A)  (h : l.length = n)  (k: ℕ)  (hk : k < n)"},
 {"type": "x + z - y + x - y + z =  viafree# (x + z - y + x - y + z)",
  "tactic-prompt":
  "theorem {α : Type} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]      (x y z : α) : x + z - y + x - y + z =  viafree# (x + z - y + x - y + z) := by simp only [AddCommGroup.Homomorphism.neg_dist, AddCommGroup.add_distrib, induced_free_map_at, List.get]; sorry",
  "name": "egViaFreeEql",
  "kind": "theorem",
  "first-tactic":
  "simp only [AddCommGroup.Homomorphism.neg_dist, AddCommGroup.add_distrib, induced_free_map_at, List.get]",
  "core-prompt":
  "{α : Type} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]      (x y z : α) : x + z - y + x - y + z =  viafree# (x + z - y + x - y + z)",
  "args":
  "{α : Type} [AddCommGroup α] [Repr α] [DecidableEq α] [Inhabited α]      (x y z : α)"},
 {"type": "x + x + y - x - y + z - x = z",
  "tactic-prompt":
  "example {x y z : ℤ} : x + x + y - x - y + z - x = z := by have p := freeGroupEq# (x + x + y - x - y + z - x); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq# (x + x + y - x - y + z - x)",
  "core-prompt": "{x y z : ℤ} : x + x + y - x - y + z - x = z",
  "args": "{x y z : ℤ}"},
 {"type": "Graph Unit Bool",
  "tactic-prompt": "example  : Graph Unit Bool := by apply Graph.mk; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply Graph.mk",
  "core-prompt": " : Graph Unit Bool",
  "args": ""}]