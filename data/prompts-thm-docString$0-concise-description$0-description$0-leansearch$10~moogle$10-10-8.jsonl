{"text":"If every proper closed subset of a topological space is compact, then the space itself is compact.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a topological space with the R1 property, the closure of any compact subset is compact.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : R1Space X] {s K : Set X},   IsCompact K ‚Üí s ‚äÜ K ‚Üí IsCompact (closure s)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In any topological space, if a compact set `K` contains a subset `s`, then the closure of `s` is also compact.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : R1Space X] {s K : Set X},   IsCompact K ‚Üí s ‚äÜ K ‚Üí IsCompact (closure s)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a proper Hausdorff space, a set is compact if and only if it is both closed and bounded.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} [inst_1 : T2Space Œ±] [inst_2 : ProperSpace Œ±],\n  IsCompact s ‚Üî IsClosed s ‚àß Bornology.IsBounded s"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: The closure of a compact set in an R‚ÇÅ space is a compact set. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : R1Space X] {K : Set X}, IsCompact K ‚Üí IsCompact (closure K)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a T2 (Hausdorff) space, every compact set is closed.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {s : Set X}, IsCompact s ‚Üí IsClosed s"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: In a Noetherian space, all sets are compact. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A locally compact normed vector space is a proper space.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst : NormedSpace ùïú E] [inst : LocallyCompactSpace E], ProperSpace E"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: In a `T2Space`, every compact set is closed. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {s : Set X}, IsCompact s ‚Üí IsClosed s"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a Noetherian topological space, every set is compact.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `X` is a compact topological space and `s` is a closed subset of `X`, then `s` is compact.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s : Set X} [inst_1 : CompactSpace X], IsClosed s ‚Üí IsCompact s"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: If every proper closed subset of a topological space is compact, then the space itself is compact.\n\nGive ONLY the Lean code"}]}
{"text":"Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any commutative ring R and elements a, b, c, d, x, y, z, w, the following equality holds: (a^2 + b^2 + c^2 + d^2) * (x^2 + y^2 + z^2 + w^2) = (a^2 + b^2 + (c + d)^2) * (x^2 + y^2 + (z + w)^2)\n\nOr, in more concise form:\n(‚àë(a, b, c, d)^2) * (‚àë(x, y, z, w)^2) = (‚àë(a, b, c+d)^2) * (‚àë(x, y, z+w)^2)\n\nWhere ‚àë represents the sum of squares of the elements inside the parentheses.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\n      (a * w + b * z - c * y + d * x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `n` is a natural number such that `-1` is a quadratic residue modulo `n`, then `n` can be expressed as the sum of two squares of natural numbers.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A natural number `n` is the sum of two squares if and only if there exists natural numbers `a` and `b` such that `n = a^2 * b^2` and `(-1)` is a quadratic residue modulo `b`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÉ a b, n = a ^ 2 * b ‚àß IsSquare (-1)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For odd primes p and q with p congruent to 1 modulo 4, p has a square root modulo q if and only if q has a square root modulo p.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p q : ‚Ñï} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 ‚Üí q ‚â† 2 ‚Üí (IsSquare ‚Üëq ‚Üî IsSquare ‚Üëp)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: If `p` is a prime natural number and `x` is a natural number, then there exist natural numbers\n`a ‚â§ p / 2` and `b ‚â§ p / 2` such that `a ^ 2 + b ^ 2 ‚â° x [MOD p]`. This is a version of\n`ZMod.sq_add_sq` with estimates on `a` and `b`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)] (x : ‚Ñï), ‚àÉ a b, a ‚â§ p / 2 ‚àß b ‚â§ p / 2 ‚àß a ^ 2 + b ^ 2 ‚â° x [MOD p]"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A natural number `n` can be expressed as the sum of two squares if and only if the highest power of every prime `q` in its prime factorization, where `q` is congruent to 3 modulo 4, in its prime factorization has even power.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÄ {q : ‚Ñï}, Nat.Prime q ‚Üí q % 4 = 3 ‚Üí Even (padicValNat q n)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÄ {q : ‚Ñï}, Nat.Prime q ‚Üí q % 4 = 3 ‚Üí Even (padicValNat q n)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For every prime number p not congruent to 3 modulo 4, there exist integers a and b such that a^2 + b^2 = p.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 4 ‚â† 3 ‚Üí ‚àÉ a b, a ^ 2 + b ^ 2 = p"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: **Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\nof two squares. Also known as **Fermat's Christmas theorem**. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], p % 4 ‚â† 3 ‚Üí ‚àÉ a b, a ^ 2 + b ^ 2 = p"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  Every prime number can be expressed as the sum of the squares of four natural numbers.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: **Four squares theorem** \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (n : ‚Ñï), ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  Every natural number can be expressed as the sum of four squares of natural numbers.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (n : ‚Ñï), ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Lagrange's **four squares theorem** for a prime number. Use `Nat.sum_four_squares` instead. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.\n\nGive ONLY the Lean code"}]}
{"text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A natural number `n` can be expressed as the sum of two squares if and only if the highest power of every prime `q` in its prime factorization, where `q` is congruent to 3 modulo 4, in its prime factorization has even power.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÄ {q : ‚Ñï}, Nat.Prime q ‚Üí q % 4 = 3 ‚Üí Even (padicValNat q n)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a LinearOrderedSemiring, the sum of the squares of two elements is zero if and only if both elements are zero.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] [inst_1 : LinearOrder Œ±] {a b : Œ±} [inst_2 : IsRightCancelAdd Œ±]\n  [inst_3 : NoZeroDivisors Œ±] [inst_4 : ZeroLEOneClass Œ±] [inst_5 : ExistsAddOfLE Œ±] [inst_6 : PosMulMono Œ±]\n  [inst_7 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1]\n  [inst_8 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x < x_1], a * a + b * b = 0 ‚Üî a = 0 ‚àß b = 0"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `a` is the sum of squares of two natural numbers `x` and `y`, and `b` is the sum of squares of natural numbers `u` and `v`, then there exist natural numbers `r` and `s` such that `a * b` is the sum of squares of `r` and `s`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: The set of sums of two squares is closed under multiplication in any commutative ring.\nSee also `sq_add_sq_mul_sq_add_sq`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : CommRing R] {a b x y u v : R},   a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any commutative ring `R` and elements `a, b` in `R`, `(a^4 + 4*b^4) = ((a-b)^2*(a+b)^2)`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : CommRing R] {a b : R}, a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: **Euler's four-square identity**. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),   (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +       (a * w + b * z - c * y + d * x) ^ 2 =     (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A natural number `n` is the sum of two squares if and only if there exists natural numbers `a` and `b` such that `n = a^2 * b^2` and `(-1)` is a quadratic residue modulo `b`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÉ a b, n = a ^ 2 * b ‚àß IsSquare (-1)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Euler's four-square identity, see <https://en.wikipedia.org/wiki/Euler%27s_four-square_identity>.\n\nThis sign choice here corresponds to the signs obtained by multiplying two quaternions.\n\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : CommRing R] {x‚ÇÅ x‚ÇÇ x‚ÇÉ x‚ÇÑ y‚ÇÅ y‚ÇÇ y‚ÇÉ y‚ÇÑ : R},   (x‚ÇÅ ^ 2 + x‚ÇÇ ^ 2 + x‚ÇÉ ^ 2 + x‚ÇÑ ^ 2) * (y‚ÇÅ ^ 2 + y‚ÇÇ ^ 2 + y‚ÇÉ ^ 2 + y‚ÇÑ ^ 2) =     (x‚ÇÅ * y‚ÇÅ - x‚ÇÇ * y‚ÇÇ - x‚ÇÉ * y‚ÇÉ - x‚ÇÑ * y‚ÇÑ) ^ 2 + (x‚ÇÅ * y‚ÇÇ + x‚ÇÇ * y‚ÇÅ + x‚ÇÉ * y‚ÇÑ - x‚ÇÑ * y‚ÇÉ) ^ 2 +         (x‚ÇÅ * y‚ÇÉ - x‚ÇÇ * y‚ÇÑ + x‚ÇÉ * y‚ÇÅ + x‚ÇÑ * y‚ÇÇ) ^ 2 +       (x‚ÇÅ * y‚ÇÑ + x‚ÇÇ * y‚ÇÉ - x‚ÇÉ * y‚ÇÇ + x‚ÇÑ * y‚ÇÅ) ^ 2"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any commutative ring `R` and elements `x‚ÇÅ, x‚ÇÇ, x‚ÇÉ, x‚ÇÑ, y‚ÇÅ, y‚ÇÇ, y‚ÇÉ, y‚ÇÑ` in `R`, the quadratic forms `‚àëxi¬≤` and `‚àëji¬≤` are equal if and only if there exist unique i, j in {1, 2, 3, 4} such that `x‚ÇÅx‚ÇÇ + x‚ÇÉx‚ÇÑ = yi¬≤ + yj¬≤` and `x‚ÇÅx‚ÇÉ + x‚ÇÇx‚ÇÑ = yi yj`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : CommRing R] {x‚ÇÅ x‚ÇÇ x‚ÇÉ x‚ÇÑ y‚ÇÅ y‚ÇÇ y‚ÇÉ y‚ÇÑ : R},\n  (x‚ÇÅ ^ 2 + x‚ÇÇ ^ 2 + x‚ÇÉ ^ 2 + x‚ÇÑ ^ 2) * (y‚ÇÅ ^ 2 + y‚ÇÇ ^ 2 + y‚ÇÉ ^ 2 + y‚ÇÑ ^ 2) =\n    (x‚ÇÅ * y‚ÇÅ - x‚ÇÇ * y‚ÇÇ - x‚ÇÉ * y‚ÇÉ - x‚ÇÑ * y‚ÇÑ) ^ 2 + (x‚ÇÅ * y‚ÇÇ + x‚ÇÇ * y‚ÇÅ + x‚ÇÉ * y‚ÇÑ - x‚ÇÑ * y‚ÇÉ) ^ 2 +\n        (x‚ÇÅ * y‚ÇÉ - x‚ÇÇ * y‚ÇÑ + x‚ÇÉ * y‚ÇÅ + x‚ÇÑ * y‚ÇÇ) ^ 2 +\n      (x‚ÇÅ * y‚ÇÑ + x‚ÇÇ * y‚ÇÉ - x‚ÇÉ * y‚ÇÇ + x‚ÇÑ * y‚ÇÅ) ^ 2"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: **Euler's four-square identity**, a version for natural numbers. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (a b c d x y z w : ‚Ñï),   Int.natAbs (‚Üëa * ‚Üëx - ‚Üëb * ‚Üëy - ‚Üëc * ‚Üëz - ‚Üëd * ‚Üëw) ^ 2 + Int.natAbs (‚Üëa * ‚Üëy + ‚Üëb * ‚Üëx + ‚Üëc * ‚Üëw - ‚Üëd * ‚Üëz) ^ 2 +         Int.natAbs (‚Üëa * ‚Üëz - ‚Üëb * ‚Üëw + ‚Üëc * ‚Üëx + ‚Üëd * ‚Üëy) ^ 2 +       Int.natAbs (‚Üëa * ‚Üëw + ‚Üëb * ‚Üëz - ‚Üëc * ‚Üëy + ‚Üëd * ‚Üëx) ^ 2 =     (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any natural numbers a, b, c, d, x, y, z, w, the sum of the squares of the four expressions axBx - b‡ÆØcZd - cwd - dw, aYx + bXa + cWz - dZx, aZx - bWy + cXd + dY, and aWy + bZx - cYx + dX is equal to the product of the sum of the squares of axbx, bya By, cZcZ, and dwd.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (a b c d x y z w : ‚Ñï),\n  (‚Üëa * ‚Üëx - ‚Üëb * ‚Üëy - ‚Üëc * ‚Üëz - ‚Üëd * ‚Üëw).natAbs ^ 2 + (‚Üëa * ‚Üëy + ‚Üëb * ‚Üëx + ‚Üëc * ‚Üëw - ‚Üëd * ‚Üëz).natAbs ^ 2 +\n        (‚Üëa * ‚Üëz - ‚Üëb * ‚Üëw + ‚Üëc * ‚Üëx + ‚Üëd * ‚Üëy).natAbs ^ 2 +\n      (‚Üëa * ‚Üëw + ‚Üëb * ‚Üëz - ‚Üëc * ‚Üëy + ‚Üëd * ‚Üëx).natAbs ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Lagrange's **four squares theorem** for a prime number. Use `Nat.sum_four_squares` instead. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any commutative ring R and elements a, b, c, d, x, y, z, w, the following equality holds: (a^2 + b^2 + c^2 + d^2) * (x^2 + y^2 + z^2 + w^2) = (a^2 + b^2 + (c + d)^2) * (x^2 + y^2 + (z + w)^2)\n\nOr, in more concise form:\n(‚àë(a, b, c, d)^2) * (‚àë(x, y, z, w)^2) = (‚àë(a, b, c+d)^2) * (‚àë(x, y, z+w)^2)\n\nWhere ‚àë represents the sum of squares of the elements inside the parentheses.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\n      (a * w + b * z - c * y + d * x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: **Four squares theorem** \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (n : ‚Ñï), ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  Every natural number can be expressed as the sum of four squares of natural numbers.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (n : ‚Ñï), ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: The set of natural numbers that are sums of two squares is closed under multiplication. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.\n\nGive ONLY the Lean code"}]}
{"text":"A ring with all elements idempotent is commutative.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Also see `Ideal.isIdempotentElem_iff_eq_bot_or_top` for integral domains. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsNoetherianRing R] [inst_2 : LocalRing R] (I : Ideal R),   IsIdempotentElem I ‚Üî I = ‚ä• ‚à® I = ‚ä§"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A ring with all elements idempotent is commutative.\n\nGive ONLY the Lean code"}]}
{"text":"There are infinitely many pairs of primes that differ exactly by `2`.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In any semiring, 2 is equal to the sum of two identical elements.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_2} [inst : Semiring Œ±], Even 2"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A version of `Nat.exists_infinite_primes` using the `Set.Infinite` predicate. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"Set.Infinite {p | Nat.Prime p}"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a natural number `p` is prime and not equal to 2, then `p` is an odd number.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí p ‚â† 2 ‚Üí Odd p"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a natural number `p` is prime, then `p ‚â• 2`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí 2 ‚â§ p"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The theorem `Nat.prime_two` asserts that 2 is a prime number in the natural numbers, i.e., it is a natural number greater than 1 that has no divisors other than 1 and itself.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"Nat.Prime 2"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p ‚â• n`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (n : ‚Ñï), ‚àÉ p, n ‚â§ p ‚àß Nat.Prime p"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: There are infinitely many pairs of primes that differ exactly by `2`.\n\nGive ONLY the Lean code"}]}
{"text":"Every finite division ring is a field.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A field is a valuation ring. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (K : Type u) [inst : Field K], ValuationRing K"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: A domain that is module-finite as an algebra over a field is a division ring. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"(F : Type u_1) ‚Üí   (K : Type u_2) ‚Üí     [inst : Field F] ‚Üí       [h : Ring K] ‚Üí [inst_1 : IsDomain K] ‚Üí [inst_2 : Algebra F K] ‚Üí [inst : FiniteDimensional F K] ‚Üí DivisionRing K"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: Every finite domain is a division ring. More generally, they are fields; this can be found in\n`Mathlib.RingTheory.LittleWedderburn`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"(R : Type u_3) ‚Üí [inst : Ring R] ‚Üí [inst : IsDomain R] ‚Üí [inst : DecidableEq R] ‚Üí [inst : Fintype R] ‚Üí DivisionRing R"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: Every finite commutative domain is a field. More generally, commutativity is not required: this\ncan be found in `Mathlib.RingTheory.LittleWedderburn`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"(R : Type u_3) ‚Üí [inst : CommRing R] ‚Üí [inst : IsDomain R] ‚Üí [inst : DecidableEq R] ‚Üí [inst : Fintype R] ‚Üí Field R"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A finite domain is a field. See also `littleWedderburn` and `Fintype.divisionRingOfIsDomain`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (D : Type u_1) [inst : Finite D] [inst : Ring D] [inst_1 : IsDomain D], IsField D"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: A finite division ring is a field. See `Finite.isDomain_to_isField` and\n`Fintype.divisionRingOfIsDomain` for more general statements, but these create data, and therefore\nmay cause diamonds if used improperly. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"(D : Type u_1) ‚Üí [inst : DivisionRing D] ‚Üí [inst : Finite D] ‚Üí Field D"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Every finite division ring is a field.\n\nGive ONLY the Lean code"}]}
{"text":"If each of two types can be mapped injectively into the other, then there is a bijection between them.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `Œ±` and `Œ≤` are ordered types with a less than or equal to order relation (`LE`) and there exists an order isomorphism (`‚âÉo`) between them, then the function `f : Œ± ‚Üí Œ≤` represented by `e : Œ± ‚âÉo Œ≤` is a bidirectional, order-preserving bijection.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LE Œ±] [inst_1 : LE Œ≤] (e : Œ± ‚âÉo Œ≤), Function.Bijective ‚áëe"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For types `Œ±` and `Œ≤`, their cardinalities are equal if and only if there exists a bijection between them.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± Œ≤ : Type u}, Cardinal.mk Œ± = Cardinal.mk Œ≤ ‚Üî Nonempty (Œ± ‚âÉ Œ≤)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For types `Œ±` and `Œ≤`, sets `s ‚ôÇŒ±` and `t ‚ôÇŒ≤`, and functions `f : Œ± ‚Üí Œ≤` and `g : Œ≤ ‚Üí Œ±` such that `f ‚àò g = idŒ≤` and `g ‚àò f = idŒ±`, `f` is a bijection between `s` and `t` if and only if `g` is a bijection between `t` and `s`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ≤} {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ±},   InvOn f g t s ‚Üí (BijOn f s t ‚Üî BijOn g t s)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `Œ± ‚âÉ Œ≤` (there exists a bijective function from `Œ±` to `Œ≤`), then the application function `‚áëe` is a bijective function from `Œ±` to `Œ≤`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} (e : Œ± ‚âÉ Œ≤), Bijective ‚áëe"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A function `f` from type `Œ±` to type `Œ≤` is bijective if and only if there exists a function `g` such that `f ‚àò g = idŒ±` and `g ‚àò f = idŒ≤`, where `idŒ±` and `idŒ≤` are the identity functions on types `Œ±` and `Œ≤`, respectively.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {f : Œ± ‚Üí Œ≤},\n  Function.Bijective f ‚Üî ‚àÉ g, Function.LeftInverse g f ‚àß Function.RightInverse g f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `f` is a bijection from set `s` to set `t`, then the image of `s` under `f` is exactly `t`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ≤} {f : Œ± ‚Üí Œ≤}, BijOn f s t ‚Üí MapsTo f s t"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A function from a finite type to itself is injective if and only if it is bijective.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} [inst : Finite Œ±] {f : Œ± ‚Üí Œ±}, Function.Injective f ‚Üî Function.Bijective f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A function between types is bijective if and only if it is both injective and surjective on their universal sets.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤}, Bijective f ‚Üî BijOn f univ univ"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a finite-dimensional vector space over a division ring, a linear map is both injective and surjective if and only if it is bijective.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V}, Function.Injective ‚áëf ‚Üî Function.Surjective ‚áëf"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A function between two finite sets is bijective if and only if it is injective and the cardinalities of the sets are equal.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Fintype Œ±] [inst_1 : Fintype Œ≤] (f : Œ± ‚Üí Œ≤),   Bijective f ‚Üî Injective f ‚àß Fintype.card Œ± = Fintype.card Œ≤"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The theorem `fin_injective` asserts that the `Fin` function maps distinct natural numbers to distinct types.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"Function.Injective Fin"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: If functions `f'` and `f` are inverse on `s` and `t`, `f` maps `s` into `t`, and `f'` maps `t`\ninto `s`, then `f` is a bijection between `s` and `t`. The `mapsTo` arguments can be deduced from\n`surjOn` statements using `LeftInvOn.mapsTo` and `RightInvOn.mapsTo`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ≤} {f : Œ± ‚Üí Œ≤} {f' : Œ≤ ‚Üí Œ±},   InvOn f' f s t ‚Üí MapsTo f s t ‚Üí MapsTo f' t s ‚Üí BijOn f s t"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: If each of two types can be mapped injectively into the other, then there is a bijection between them.\n\nGive ONLY the Lean code"}]}
{"text":"A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum\ndegree. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {V : Type u_1} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (k : ‚Ñï),   (‚àÄ (v : V), SimpleGraph.degree G v ‚â§ k) ‚Üí SimpleGraph.maxDegree G ‚â§ k"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as\nthe lemma implies there exists a vertex. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {V : Type u_1} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : Nonempty V],   ‚àÉ v, SimpleGraph.maxDegree G = SimpleGraph.degree G v"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a simple graph, two vertices are adjacent if and only if there exists an edge connecting them.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {V : Type u} {G : SimpleGraph V} {v w : V}, G.Adj v w ‚Üî v ‚â† w ‚àß ‚àÉ e ‚àà G.edgeSet, v ‚àà e ‚àß w ‚àà e"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Complete graphs are strongly regular. Note that `Œº` can take any value\nfor complete graphs, since there are no distinct pairs of non-adjacent vertices. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] {Œº : ‚Ñï},   SimpleGraph.IsSRGWith ‚ä§ (Fintype.card V) (Fintype.card V - 1) (Fintype.card V - 2) Œº"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.\n\nGive ONLY the Lean code"}]}
{"text":"The number of partitions with odd parts is equal to the number of partitions with distinct parts.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any natural number `n` and its partition `self`, the sum of the parts of `self` equals `n`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï} (self : Nat.Partition n), sum self.parts = n"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any lattice type `Œ±` with bottom element, two finite partitions `x` and `y` of an element `a` are equal if and only if their parts are equal.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {inst : Lattice Œ±} {inst_1 : OrderBot Œ±} {a : Œ±} (x y : Finpartition a), x.parts = y.parts ‚Üí x = y"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: The finset of those partitions in which every part is odd. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"(n : ‚Ñï) ‚Üí Finset (Nat.Partition n)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: The finset of those partitions in which each part is used at most once. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"(n : ‚Ñï) ‚Üí Finset (Nat.Partition n)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If two partitions of a natural number have equal parts, then they are equal.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï} (x y : Nat.Partition n), x.parts = y.parts ‚Üí x = y"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any finite partition of a type `Œ±`, there exists a corresponding setoid partition without the empty set.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} (f : Finpartition Set.univ), Setoid.IsPartition ‚Üëf.parts"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: The finset of those partitions in which every part is odd and used at most once. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"(n : ‚Ñï) ‚Üí Finset (Nat.Partition n)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: The number of partitions with odd parts is equal to the number of partitions with distinct parts.\n\nGive ONLY the Lean code"}]}
{"text":"Every non-empty poset in which every chain has an upper bound contains a maximal element.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  Every chain of non-principal ideals in a commutative ring has a supremum, which is a non-principal ideal.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u} [inst : CommRing R],\n  ‚àÄ c ‚äÜ nonPrincipals R,\n    IsChain (fun x x_1 => x ‚â§ x_1) c ‚Üí ‚àÄ {K : Ideal R}, K ‚àà c ‚Üí ‚àÉ I ‚àà nonPrincipals R, ‚àÄ J ‚àà c, J ‚â§ I"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any type `Œ±` and binary relation `r` on `Œ±`, there exists a maximal chain, which is the union of all sets in the transitive closure of `r`, according to `r`. (This statement is equivalent to the one given, but may be more concise for mathematical purposes.)\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop}, IsMaxChain r (maxChain r)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: **Zorn's lemma**\n\nIf every chain has an upper bound, then there exists a maximal element. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop},   (‚àÄ (c : Set Œ±), IsChain r c ‚Üí ‚àÉ ub, ‚àÄ a ‚àà c, r a ub) ‚Üí     (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any type `Œ±` and relation `r` on `Œ±`, if `c` is a chain (a subset of `Œ±` where every two elements are related or equal), then there exists a maximal chain `M` that contains `c`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} {c : Set Œ±}, IsChain r c ‚Üí ‚àÉ M, IsMaxChain r M ‚àß c ‚äÜ M"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If every chain in a partially ordered set has an upper bound, then the set has a maximal element.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] (s : Set Œ±),   (‚àÄ c ‚äÜ s, IsChain (fun x x_1 => x ‚â§ x_1) c ‚Üí ‚àÄ y ‚àà c, ‚àÉ ub ‚àà s, ‚àÄ z ‚àà c, z ‚â§ ub) ‚Üí     ‚àÄ x ‚àà s, ‚àÉ m ‚àà s, x ‚â§ m ‚àß ‚àÄ z ‚àà s, m ‚â§ z ‚Üí z = m"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If every chain in a partially ordered set has an upper bound and the relation is transitive, then the set has a maximal element.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop},\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí ‚àÉ ub, ‚àÄ a ‚àà c, r a ub) ‚Üí\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If every non-empty chain in a partially ordered set has an upper bound, then the set has a greatest element.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : Nonempty Œ±],   (‚àÄ (c : Set Œ±), IsChain (fun x x_1 => x ‚â§ x_1) c ‚Üí Set.Nonempty c ‚Üí BddAbove c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), m ‚â§ a ‚Üí a = m"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If every chain in a nonempty type, equipped with a transitive relation having an upper bound for each nonempty chain, has a greatest element.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : Nonempty Œ±],\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí c.Nonempty ‚Üí ‚àÉ ub, ‚àÄ a ‚àà c, r a ub) ‚Üí\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then\nthere is a maximal element.\n\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : Nonempty Œ±],   (‚àÄ (c : Set Œ±), IsChain r c ‚Üí Set.Nonempty c ‚Üí ‚àÉ ub, ‚àÄ a ‚àà c, r a ub) ‚Üí     (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Every non-empty poset in which every chain has an upper bound contains a maximal element.\n\nGive ONLY the Lean code"}]}
{"text":"A group whose automorphism group is cyclic is Abelian.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A finite group of prime order is cyclic. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a finite group of order `n` has an element of order `n`, then the group is cyclic.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] (x : Œ±), orderOf x = Fintype.card Œ± ‚Üí IsCyclic Œ±"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The Quaternion Group of order 1 is a cyclic group of order 4.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"IsCyclic (QuaternionGroup 1)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: Cyclotomic extensions are abelian. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"{n : ‚Ñï+} ‚Üí   (K : Type u_1) ‚Üí     [inst : Field K] ‚Üí       {L : Type u_2} ‚Üí         [inst_1 : CommRing L] ‚Üí           [inst_2 : IsDomain L] ‚Üí             [inst_3 : Algebra K L] ‚Üí [inst_4 : IsCyclotomicExtension {n} K L] ‚Üí CommGroup (L ‚âÉ‚Çê[K] L)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A group whose automorphism group is cyclic is Abelian.\n\nGive ONLY the Lean code"}]}
{"text":"A uniformly continuous function of a uniformly continuous function is uniformly continuous.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a sequence of continuous functions converges uniformly to a limit function with respect to a non-bottom filter, then the limit function is also continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : p.NeBot], Continuous f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A function between topological spaces is continuous if it can be locally uniformly approximated by continuous functions.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (x : Œ±), ‚àÄ u ‚àà uniformity Œ≤, ‚àÉ t ‚àà nhds x, ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) ‚Üí Continuous f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A continuous function on a compact uniform space is uniformly continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {s : Set Œ±} {f : Œ± ‚Üí Œ≤},\n  IsCompact s ‚Üí ContinuousOn f s ‚Üí UniformContinuousOn f s"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a function between uniform spaces is uniformly continuous, then it is continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤},\n  UniformContinuous f ‚Üí Continuous f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  Given uniform spaces on types Œ±, Œ≤, and Œ≥, and uniformly inducing function g : Œ≤ ‚Üí Œ≥, the function f : Œ± ‚Üí Œ≤ is uniformly continuous if and only if the composition g ‚àò f is uniformly continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]   {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥}, UniformInducing g ‚Üí (UniformContinuous f ‚Üî UniformContinuous (g ‚àò f))"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The natural function `UniformFun.toFun` from `Œ± ‚Üí·µ§ Œ≤` to `Œ± ‚Üí Œ≤` is a uniformly continuous function between uniform spaces.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ≤], UniformContinuous ‚áëUniformFun.toFun"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a function between two uniform spaces is uniformly inducing, then it is uniformly continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤},   UniformInducing f ‚Üí UniformContinuous f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `f` is a continuous function from the compact uniform space `Œ±` to the uniform space `Œ≤`, then `f` is uniformly continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : CompactSpace Œ±] {f : Œ± ‚Üí Œ≤},\n  Continuous f ‚Üí UniformContinuous f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `Œ±` is a type and `Œ≤` is a uniform space, and `f : Œ± ‚Üí Œ≤` is a function, then `f` is uniformly continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} {f : Œ± ‚Üí Œ≤} [u : UniformSpace Œ≤], UniformContinuous f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a Lipschitz continuous function with a constant C composes with a bounded continuous function, the result is a uniformly continuous function.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : TopologicalSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤]\n  [inst_2 : PseudoMetricSpace Œ≥] {G : Œ≤ ‚Üí Œ≥} {C : NNReal} (H : LipschitzWith C G),\n  UniformContinuous (BoundedContinuousFunction.comp G H)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: The composition operator (in the target) with a Lipschitz map is uniformly continuous. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : TopologicalSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤]   [inst_2 : PseudoMetricSpace Œ≥] {G : Œ≤ ‚Üí Œ≥} {C : ‚Ñù‚â•0} (H : LipschitzWith C G),   UniformContinuous (BoundedContinuousFunction.comp G H)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a function from a topological space into a uniform space can be uniformly approximated by continuous functions, then it is continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ u ‚àà uniformity Œ≤, ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `f : Œ≥ ‚Üí Œ≤` is uniformly continuous and `g : Œ± ‚Üí Œ≥` is such that `f ‚àò g` is uniformly continuous, then `g` is uniformly continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} {Œ≥ : Type uc} {f : Œ≥ ‚Üí Œ≤} {g : Œ± ‚Üí Œ≥} [v : UniformSpace Œ≤] [u : UniformSpace Œ±],   UniformContinuous (f ‚àò g) ‚Üí UniformContinuous g"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `F` is a uniformly equicontinuous family of functions from the uniform space `Œ≤` to the uniform space `Œ±`, then each function `F i` in `F` is uniformly continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_7} {Œ≤ : Type u_9} [uŒ± : UniformSpace Œ±] [uŒ≤ : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If functions `f : Œ± ‚Üí Œ≤` and `g : Œ≤ ‚Üí Œ≥` are uniformly continuous, then their composition `g ‚àò f : Œ± ‚Üí Œ≥` is also uniformly continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} {Œ≥ : Type uc} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]   {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤}, UniformContinuous g ‚Üí UniformContinuous f ‚Üí UniformContinuous (g ‚àò f)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A uniformly continuous function of a uniformly continuous function is uniformly continuous.\n\nGive ONLY the Lean code"}]}
{"text":"A uniformly continuous function of a uniformly continuous function is uniformly continuous.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a sequence of continuous functions converges uniformly to a limit function with respect to a non-bottom filter, then the limit function is also continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\n  [inst_1 : TopologicalSpace Œ±],\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : p.NeBot], Continuous f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A function between topological spaces is continuous if it can be locally uniformly approximated by continuous functions.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ (x : Œ±), ‚àÄ u ‚àà uniformity Œ≤, ‚àÉ t ‚àà nhds x, ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) ‚Üí Continuous f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A continuous function on a compact uniform space is uniformly continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {s : Set Œ±} {f : Œ± ‚Üí Œ≤},\n  IsCompact s ‚Üí ContinuousOn f s ‚Üí UniformContinuousOn f s"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a function between uniform spaces is uniformly continuous, then it is continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤},\n  UniformContinuous f ‚Üí Continuous f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  Given uniform spaces on types Œ±, Œ≤, and Œ≥, and uniformly inducing function g : Œ≤ ‚Üí Œ≥, the function f : Œ± ‚Üí Œ≤ is uniformly continuous if and only if the composition g ‚àò f is uniformly continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]   {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥}, UniformInducing g ‚Üí (UniformContinuous f ‚Üî UniformContinuous (g ‚àò f))"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The natural function `UniformFun.toFun` from `Œ± ‚Üí·µ§ Œ≤` to `Œ± ‚Üí Œ≤` is a uniformly continuous function between uniform spaces.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ≤], UniformContinuous ‚áëUniformFun.toFun"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a function between two uniform spaces is uniformly inducing, then it is uniformly continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤},   UniformInducing f ‚Üí UniformContinuous f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `f` is a continuous function from the compact uniform space `Œ±` to the uniform space `Œ≤`, then `f` is uniformly continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : CompactSpace Œ±] {f : Œ± ‚Üí Œ≤},\n  Continuous f ‚Üí UniformContinuous f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `Œ±` is a type and `Œ≤` is a uniform space, and `f : Œ± ‚Üí Œ≤` is a function, then `f` is uniformly continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} {f : Œ± ‚Üí Œ≤} [u : UniformSpace Œ≤], UniformContinuous f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a Lipschitz continuous function with a constant C composes with a bounded continuous function, the result is a uniformly continuous function.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : TopologicalSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤]\n  [inst_2 : PseudoMetricSpace Œ≥] {G : Œ≤ ‚Üí Œ≥} {C : NNReal} (H : LipschitzWith C G),\n  UniformContinuous (BoundedContinuousFunction.comp G H)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: The composition operator (in the target) with a Lipschitz map is uniformly continuous. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : TopologicalSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤]   [inst_2 : PseudoMetricSpace Œ≥] {G : Œ≤ ‚Üí Œ≥} {C : ‚Ñù‚â•0} (H : LipschitzWith C G),   UniformContinuous (BoundedContinuousFunction.comp G H)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a function from a topological space into a uniform space can be uniformly approximated by continuous functions, then it is continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\n  (‚àÄ u ‚àà uniformity Œ≤, ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `f : Œ≥ ‚Üí Œ≤` is uniformly continuous and `g : Œ± ‚Üí Œ≥` is such that `f ‚àò g` is uniformly continuous, then `g` is uniformly continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} {Œ≥ : Type uc} {f : Œ≥ ‚Üí Œ≤} {g : Œ± ‚Üí Œ≥} [v : UniformSpace Œ≤] [u : UniformSpace Œ±],   UniformContinuous (f ‚àò g) ‚Üí UniformContinuous g"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `F` is a uniformly equicontinuous family of functions from the uniform space `Œ≤` to the uniform space `Œ±`, then each function `F i` in `F` is uniformly continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_7} {Œ≤ : Type u_9} [uŒ± : UniformSpace Œ±] [uŒ≤ : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If functions `f : Œ± ‚Üí Œ≤` and `g : Œ≤ ‚Üí Œ≥` are uniformly continuous, then their composition `g ‚àò f : Œ± ‚Üí Œ≥` is also uniformly continuous.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} {Œ≥ : Type uc} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : UniformSpace Œ≥]   {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤}, UniformContinuous g ‚Üí UniformContinuous f ‚Üí UniformContinuous (g ‚àò f)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A uniformly continuous function of a uniformly continuous function is uniformly continuous.\n\nGive ONLY the Lean code"}]}
{"text":"A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a Hausdorff space, for any two distinct points, there exist disjoint open sets containing each point.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space Y]   {f : X ‚Üí Y}, Continuous f ‚Üí ‚àÄ {x y : X}, f x ‚â† f y ‚Üí ‚àÉ u v, IsOpen u ‚àß IsOpen v ‚àß x ‚àà u ‚àß y ‚àà v ‚àß Disjoint u v"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Urysohn's lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`,\nthen there exists a continuous function `f : X ‚Üí ‚Ñù` such that\n\n* `f` equals zero on `s`;\n* `f` equals one on `t`;\n* `0 ‚â§ f x ‚â§ 1` for all `x`.\n\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {s t : Set X},   IsClosed s ‚Üí IsClosed t ‚Üí Disjoint s t ‚Üí ‚àÉ f, EqOn (‚áëf) 0 s ‚àß EqOn (‚áëf) 1 t ‚àß ‚àÄ (x : X), f x ‚àà Icc 0 1"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: **Urysohn's lemma**: if `s` and `t` are two disjoint closed sets in a normal topological\nspace `X`, then there exists a continuous function `f : X ‚Üí ‚Ñù` such that\n\n* `f` equals zero on `s`;\n* `f` equals one on `t`;\n* `0 ‚â§ f x ‚â§ 1` for all `x`.\n\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {s t : Set X},   IsClosed s ‚Üí IsClosed t ‚Üí Disjoint s t ‚Üí ‚àÉ f, EqOn (‚áëf) 0 s ‚àß EqOn (‚áëf) 1 t ‚àß ‚àÄ (x : X), f x ‚àà Icc 0 1"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a normal topological space, for any two disjoint closed sets, there exist disjoint open neighborhoods.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u} [inst : TopologicalSpace X] [self : NormalSpace X] (s t : Set X),   IsClosed s ‚Üí IsClosed t ‚Üí Disjoint s t ‚Üí SeparatedNhds s t"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.\n\nGive ONLY the Lean code"}]}
{"text":"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: For the identity map, all points are periodic. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} (n : ‚Ñï) (x : Œ±), Function.IsPeriodicPt id n x"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A fixed point of `f` is a periodic point of `f` of any prescribed period. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±}, Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), Function.IsPeriodicPt f n x"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any type `Œ±` and natural number `n`, the identity function `id` is periodic with period `n` on any element `x` of type `Œ±`, i.e., `id^n(x) = x`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} (n : ‚Ñï) (x : Œ±), Function.IsPeriodicPt id n x"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `x` is a periodic point of degree `n` for the function `f` in `Œ±`, then for any natural number `m`, `f^(m+n)` applied to `x` equals `f^m` applied to `x`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±} {n : ‚Ñï},   Function.IsPeriodicPt f n x ‚Üí ‚àÄ (m : ‚Ñï), Function.IsPeriodicPt f n (f^[m] x)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a function `f` from an additive monoid `Œ±` to a type `Œ≤` supporting negation is antiperiodic with antiperiod `c`, then it is periodic with period `2 ‚Ä¢ c`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [inst : AddMonoid Œ±] [inst_1 : InvolutiveNeg Œ≤],\n  Function.Antiperiodic f c ‚Üí Function.Periodic f (2 ‚Ä¢ c)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any endomorphism `f` over a domain `Œ±` and point `x`, the minimal period of `x` under `f` is positive if and only if `x` is a periodic point of `f` with some positive period.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±}, 0 < Function.minimalPeriod f x ‚Üî x ‚àà Function.periodicPts f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If two points have the same periodicity and are mapped to the same image under a function, then they are equal.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x y : Œ±} {m n : ‚Ñï},\n  Function.IsPeriodicPt f m x ‚Üí Function.IsPeriodicPt f n y ‚Üí 0 < m ‚Üí 0 < n ‚Üí f x = f y ‚Üí x = y"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any function `f` from type `Œ±` to itself and any periodic point `x` of `f`, the minimal period of `x` is a positive integer.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±}, x ‚àà Function.periodicPts f ‚Üí 0 < Function.minimalPeriod f x"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any function from a type to itself, the identity element is a periodic point with period 0.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (x : Œ±), Function.IsPeriodicPt f 0 x"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `x` is a periodic point of period `n` (`n` > 0) for function `f` from type `Œ±` to `Œ±`, then the minimal period of `x` under `f` is also a positive integer.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±} {n : ‚Ñï}, 0 < n ‚Üí Function.IsPeriodicPt f n x ‚Üí 0 < Function.minimalPeriod f x"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.\n\nGive ONLY the Lean code"}]}
{"text":"A terminal object in a category is unique up to unique isomorphism.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Any two morphisms to a terminal object are equal. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {C : Type u‚ÇÅ} [inst : Category.{v‚ÇÅ, u‚ÇÅ} C] {X Y : C}, Limits.IsTerminal X ‚Üí ‚àÄ (f g : Y ‚ü∂ X), f = g"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: An object `Y` is terminal if for every `X` there is a unique morphism `X ‚ü∂ Y`\n    (as explicit arguments). \n\nGive ONLY the Lean code"},{"role":"assistant","content":"{C : Type u‚ÇÅ} ‚Üí   [inst : Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí     {Y : C} ‚Üí (h : (X : C) ‚Üí X ‚ü∂ Y) ‚Üí (‚àÄ (X : C) (m : X ‚ü∂ Y), m = h X) ‚Üí Limits.IsTerminal Y"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: `X` is terminal if the cone it induces on the empty diagram is limiting. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"{C : Type u‚ÇÅ} ‚Üí [inst : Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí C ‚Üí Type (max u‚ÇÅ v‚ÇÅ)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: The (unique) isomorphism between the chosen terminal object and any other terminal object. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"{C : Type u‚ÇÅ} ‚Üí   [inst : Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí [inst_1 : Limits.HasTerminal C] ‚Üí {P : C} ‚Üí Limits.IsTerminal P ‚Üí (‚ä§_ C ‚âÖ P)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: An arbitrary choice of terminal object, if one exists.\nYou can use the notation `‚ä§_ C`.\nThis object is characterized by having a unique morphism from any object.\n\n\nGive ONLY the Lean code"},{"role":"assistant","content":"(C : Type u‚ÇÅ) ‚Üí [inst : Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí [inst : Limits.HasTerminal C] ‚Üí C"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {C : Type u‚ÇÅ} [inst : Category.{v‚ÇÅ, u‚ÇÅ} C] (X : C) [h : (Y : C) ‚Üí Unique (Y ‚ü∂ X)], Limits.HasTerminal C"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A terminal object in a category is unique up to unique isomorphism.\n\nGive ONLY the Lean code"}]}
{"text":"The complement of the union of two sets is the intersection of their complements.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The complement of the union of all sets indexed by pairs of types `Œπ` and `Œ∫(Œπ)` from a function `s` is equal to the intersection of the complements of those sets. In mathematical notation: $(‚ãÉ_{i:\\_} ‚ãÉ_{j:\\kappa(i)} s(i, j))^c = ‚ãÇ_{i:\\_} ‚à£_{j:\\kappa(i)} s(i, j)^c$.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_4} {Œ∫ : Œπ ‚Üí Sort u_7} (s : (i : Œπ) ‚Üí Œ∫ i ‚Üí Set Œ±), (‚ãÉ i, ‚ãÉ j, s i j)·∂ú = ‚ãÇ i, ‚ãÇ j, (s i j)·∂ú"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any type `Œ±` and set `S` of subsets of `Œ±`, `Set.compl_sInter` asserts that `(‚àÄs ‚àà S, s).compl = ‚àß s ‚àà S, s.compl`.\n\nThis statement represents the De Morgan's laws for sets, stating that the complement of the intersection of all sets in `S` is equal to the union of the complements of those sets.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} (S : Set (Set Œ±)), (‚ãÇ‚ÇÄ S)·∂ú = ‚ãÉ‚ÇÄ (compl '' S)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The complement of the union of a set of subsets is equal to the intersection of the complements of those subsets. (De Morgan's law for sets)\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} (S : Set (Set Œ±)), (‚ãÉ‚ÇÄ S)·∂ú = ‚ãÇ‚ÇÄ (compl '' S)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The complement of the union of a family of sets equals the intersection of their complements.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ≤ : Type u_2} {Œπ : Sort u_4} (s : Œπ ‚Üí Set Œ≤), (‚ãÉ i, s i)·∂ú = ‚ãÇ i, (s i)·∂ú"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any type `Œ±` and set `S` of subsets of `Œ±`, `Set.compl_sInter` asserts that `(‚àÄs ‚àà S, s).compl = ‚àß s ‚àà S, s.compl`.\n\nThis statement represents the De Morgan's laws for sets, stating that the complement of the intersection of all sets in `S` is equal to the union of the complements of those sets.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} (S : Set (Set Œ±)), (‚ãÇ‚ÇÄ S)·∂ú = ‚ãÉ‚ÇÄ (compl '' S)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The theorem asserts that for any set `s` of type `Œ±`, the union of `s` intersected with `t` and `s` intersected with the complement of `t` equals `s`, i.e., `s ‚à© t ‚à™ s ‚à© t^c = s`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} (s t : Set Œ±), s ‚à© t ‚à™ s ‚à© t·∂ú = s"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The complement of the union of a set of subsets is equal to the intersection of the complements of those subsets. (De Morgan's law for sets)\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} (S : Set (Set Œ±)), (‚ãÉ‚ÇÄ S)·∂ú = ‚ãÇ‚ÇÄ (compl '' S)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The complement of the intersection of sets `s` and `t` equals the union of their complements: `(s ‚à© t)·∂ú = s·∂ú ‚à™ t·∂ú`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à© t)·∂ú = s·∂ú ‚à™ t·∂ú"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The complement of the union of two sets is equal to the intersection of their complements: $(s \\cup t)^c = s^c \\cap t^c$.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à™ t)·∂ú = s·∂ú ‚à© t·∂ú"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The complement of the union of two sets is equal to the intersection of their complements: $(s \\cup t)^c = s^c \\cap t^c$.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à™ t)·∂ú = s·∂ú ‚à© t·∂ú"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The complement of the intersection of sets `s` and `t` equals the union of their complements: `(s ‚à© t)·∂ú = s·∂ú ‚à™ t·∂ú`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} (s t : Set Œ±), (s ‚à© t)·∂ú = s·∂ú ‚à™ t·∂ú"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: The complement of the union of two sets is the intersection of their complements.\n\nGive ONLY the Lean code"}]}
{"text":"The sum of the cubes of two positive integers is never equal to the cube of a third integer.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a noncommutative ordered `*`-algebra over the real numbers, the maximum value of the CHSH expression `A‚ÇÄ * B‚ÇÄ + A‚ÇÄ * B‚ÇÅ + A‚ÇÅ * B‚ÇÄ - A‚ÇÅ * B‚ÇÅ` is bounded by `2^(3/2)`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u} [inst : OrderedRing R] [inst_1 : StarRing R] [inst_2 : StarOrderedRing R] [inst_3 : Algebra ‚Ñù R]\n  [inst_4 : OrderedSMul ‚Ñù R] [inst_5 : StarModule ‚Ñù R] (A‚ÇÄ A‚ÇÅ B‚ÇÄ B‚ÇÅ : R),\n  IsCHSHTuple A‚ÇÄ A‚ÇÅ B‚ÇÄ B‚ÇÅ ‚Üí A‚ÇÄ * B‚ÇÄ + A‚ÇÄ * B‚ÇÅ + A‚ÇÅ * B‚ÇÄ - A‚ÇÅ * B‚ÇÅ ‚â§ ‚àö2 ^ 3 ‚Ä¢ 1"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For all natural numbers `m` and `n`, if `m¬≤ < n < (m+1)¬≤`, then `n` is not the square of any natural number.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {m n : ‚Ñï}, m * m < n ‚Üí n < (m + 1) * (m + 1) ‚Üí ¬¨‚àÉ t, t * t = n"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `p` is a prime number and `x, y` are nonzero elements of `ZMod p` such that `x^2 = -y^2`, then `p` is not congruent to 3 modulo 4.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y ‚â† 0 ‚Üí x ^ 2 = -y ^ 2 ‚Üí p % 4 ‚â† 3"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: The sum of the cubes of two positive integers is never equal to the cube of a third integer.\n\nGive ONLY the Lean code"}]}
{"text":"If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: If an element in a group has order two, then it is its own inverse. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u} [inst : Group G] {x : G}, orderOf x = 2 ‚Üí x‚Åª¬π = x"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: A group of order `p ^ 2` is commutative. See also `IsPGroup.commutative_of_card_eq_prime_sq`\nfor just the proof that `‚àÄ a b, a * b = b * a` \n\nGive ONLY the Lean code"},{"role":"assistant","content":"{p : ‚Ñï} ‚Üí   {G : Type u_1} ‚Üí [inst : Group G] ‚Üí [inst : Fintype G] ‚Üí [inst_1 : Fact (Nat.Prime p)] ‚Üí card G = p ^ 2 ‚Üí CommGroup G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: Any group of exponent two is abelian. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"{G : Type u} ‚Üí [inst : Group G] ‚Üí Monoid.exponent G = 2 ‚Üí CommGroup G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: In a cancellative monoid of exponent two, all elements commute. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u} [inst : Monoid G] [inst_1 : IsCancelMul G], Monoid.exponent G = 2 ‚Üí ‚àÄ (a b : G), a * b = b * a"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The number of commuting element pairs in the Dihedral group of order 2n for an odd natural number n is n*(n+3).\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï}, Odd n ‚Üí Nat.card { p // Commute p.1 p.2 } = n * (n + 3)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A group of order `p ^ 2` is commutative. See also `IsPGroup.commGroupOfCardEqPrimeSq`\nfor the `CommGroup` instance. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p : ‚Ñï} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],   card G = p ^ 2 ‚Üí ‚àÄ (a b : G), a * b = b * a"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.\n\nGive ONLY the Lean code"}]}
{"text":"The product of two consecutive natural numbers is even.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The sum of two natural numbers is even if and only if both numbers are even or both are odd.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {m n : ‚Ñï}, Even (m + n) ‚Üî (Even m ‚Üî Even n)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `m` is even and `n` is odd in a semiring, then their sum `m + n` is odd. ( mathematically expressed as: `‚àÉ r, m = r + r ‚àß ‚àÉ k, n = 2*k + 1 ‚Üí ‚àÉ l, m + n = 2*l + 1`)\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_2} [inst : Semiring Œ±] {a b : Œ±}, Even a ‚Üí Odd b ‚Üí Odd (a + b)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A natural number `n` is even if and only if `n` modulo 2 equals 0.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï}, Even n ‚Üî n % 2 = 0"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For all natural numbers m and n, m^n is even if and only if m is even and n is not zero.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {m n : ‚Ñï}, Even (m ^ n) ‚Üî Even m ‚àß n ‚â† 0"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In any semiring, 2 is equal to the sum of two identical elements.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_2} [inst : Semiring Œ±], Even 2"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For all natural numbers `n`, the product of `n` and `n-1` is an even number. Equivalently, the product of two consecutive natural numbers is an even number.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (n : ‚Ñï), Even (n * (n - 1))"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: The product of two consecutive natural numbers is even.\n\nGive ONLY the Lean code"}]}
{"text":"Every index 2 subgroup of a group is normal.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A subgroup of a group has index 2 if and only if there exists an element such that the subgroup contains exactly one of each pair of elements and their product.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G}, H.index = 2 ‚Üî ‚àÉ a, ‚àÄ (b : G), Xor' (b * a ‚àà H) (b ‚àà H)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\nof `b * a` and `b` belong to `H`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ‚Üî ‚àÉ a, ‚àÄ (b : G), Xor' (b * a ‚àà H) (b ‚àà H)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Every index 2 subgroup of a group is normal.\n\nGive ONLY the Lean code"}]}
{"text":"Every free group is torsion free.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Direct products of torsion free groups are torsion free. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ∑ : Type u_3} {Gs : Œ∑ ‚Üí Type u_4} [inst : (i : Œ∑) ‚Üí Group (Gs i)],   (‚àÄ (i : Œ∑), IsTorsionFree (Gs i)) ‚Üí IsTorsionFree ((i : Œ∑) ‚Üí Gs i)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Subgroups of torsion-free groups are torsion-free. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : Group G], IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), IsTorsionFree ‚Ü•H"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If G is a torsion-free group, then every subgroup H of G is also torsion-free.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree ‚Ü•H"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In an additive group with a nontrivial structure, if every element has finite order, then the group contains a non-zero element of finite order.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G ‚Üí ¬¨AddMonoid.IsTorsionFree G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If 'G' is an additively torsion-free group, then every subgroup of 'G' is also additively torsion-free.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree ‚Ü•H"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any additive commutative group `G`, the quotient `G / torsionSubgroup(G)` is a torsion-free group.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any additive commutative group `G`, the quotient `G / torsionSubgroup(G)` is a torsion-free group.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Quotienting a group by its torsion subgroup yields a torsion free group. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (G : Type u_1) [inst : CommGroup G], IsTorsionFree (G ‚ß∏ CommGroup.torsion G)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In an additive group with a nontrivial structure, if every element has finite order, then the group contains a non-zero element of finite order.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G ‚Üí ¬¨AddMonoid.IsTorsionFree G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A nontrivial torsion group is not torsion-free. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], IsTorsion G ‚Üí ¬¨IsTorsionFree G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A nontrivial additive group with only the zero element having finite order is torsion-free and hence not a torsion group.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G ‚Üí ¬¨AddMonoid.IsTorsion G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A nontrivial torsion-free group is not torsion. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], IsTorsionFree G ‚Üí ¬¨IsTorsion G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Every free group is torsion free.\n\nGive ONLY the Lean code"}]}
{"text":"Every natural number greater than `1` is divisible by a prime number.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a natural number `p` is prime, then `p` is a positive integer greater than 1.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí 1 < p"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For every non-zero natural number `k` and natural number `n`, there exists a prime number `p` greater than `n` that is congruent to 1 modulo `k`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {k : ‚Ñï} (n : ‚Ñï), k ‚â† 0 ‚Üí ‚àÉ p, Nat.Prime p ‚àß n < p ‚àß p ‚â° 1 [MOD k]"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `p` is a prime number, then the divisors of `p` are exactly 1 and `p`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p m : ‚Ñï}, Nat.Prime p ‚Üí (m ‚à£ p ‚Üî m = 1 ‚à® m = p)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The theorem asserts that the set of proper divisors of a prime number is empty or, equivalently, that a prime number's only proper divisor is 1.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí p.properDivisors = {1}"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A natural number `p` is prime if and only if `p` is greater than 1 and has no divisors other than 1 and `p`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üî 2 ‚â§ p ‚àß ‚àÄ (m : ‚Ñï), m ‚à£ p ‚Üí m = 1 ‚à® m = p"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any composite natural number `n` greater than 1, it is a Fermat pseudoprime to base 1.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï}, 1 < n ‚Üí ¬¨Nat.Prime n ‚Üí n.FermatPsp 1"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p ‚â• n`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (n : ‚Ñï), ‚àÉ p, n ‚â§ p ‚àß Nat.Prime p"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For every natural number `n`, there exists a prime number `p` such that `p > n`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (n : ‚Ñï), ‚àÉ p, n ‚â§ p ‚àß Nat.Prime p"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For every natural number `n` greater than 1, there exists a prime number `p` such that `p` divides `n`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï}, n ‚â† 1 ‚Üí ‚àÉ p, Nat.Prime p ‚àß p ‚à£ n"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Every natural number greater than `1` is divisible by a prime number.\n\nGive ONLY the Lean code"}]}
{"text":"A finite torsion-free group is trivial","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A nontrivial additive group with only the zero element having finite order is torsion-free and hence not a torsion group.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G ‚Üí ¬¨AddMonoid.IsTorsion G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In an additive group with a nontrivial structure, if every element has finite order, then the group contains a non-zero element of finite order.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G ‚Üí ¬¨AddMonoid.IsTorsionFree G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any additive commutative group `G`, the quotient `G / torsionSubgroup(G)` is a torsion-free group.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  Every element in a finite additive group has finite additive order.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A nontrivial additive group with only the zero element having finite order is torsion-free and hence not a torsion group.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G ‚Üí ¬¨AddMonoid.IsTorsion G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A nontrivial torsion-free group is not torsion. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], IsTorsionFree G ‚Üí ¬¨IsTorsion G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  Every element in a finite additive group has finite additive order.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A nontrivial torsion group is not torsion-free. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], IsTorsion G ‚Üí ¬¨IsTorsionFree G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A finite group is a torsion group, meaning every element has finite order.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Finite groups are torsion groups. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], IsTorsion G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A finite torsion-free group is trivial\n\nGive ONLY the Lean code"}]}
{"text":"Every finite division ring is a field.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A field is a valuation ring. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (K : Type u) [inst : Field K], ValuationRing K"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: A domain that is module-finite as an algebra over a field is a division ring. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"(F : Type u_1) ‚Üí   (K : Type u_2) ‚Üí     [inst : Field F] ‚Üí       [h : Ring K] ‚Üí [inst_1 : IsDomain K] ‚Üí [inst_2 : Algebra F K] ‚Üí [inst : FiniteDimensional F K] ‚Üí DivisionRing K"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: Every finite domain is a division ring. More generally, they are fields; this can be found in\n`Mathlib.RingTheory.LittleWedderburn`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"(R : Type u_3) ‚Üí [inst : Ring R] ‚Üí [inst : IsDomain R] ‚Üí [inst : DecidableEq R] ‚Üí [inst : Fintype R] ‚Üí DivisionRing R"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: Every finite commutative domain is a field. More generally, commutativity is not required: this\ncan be found in `Mathlib.RingTheory.LittleWedderburn`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"(R : Type u_3) ‚Üí [inst : CommRing R] ‚Üí [inst : IsDomain R] ‚Üí [inst : DecidableEq R] ‚Üí [inst : Fintype R] ‚Üí Field R"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A finite domain is a field. See also `littleWedderburn` and `Fintype.divisionRingOfIsDomain`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (D : Type u_1) [inst : Finite D] [inst : Ring D] [inst_1 : IsDomain D], IsField D"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: A finite division ring is a field. See `Finite.isDomain_to_isField` and\n`Fintype.divisionRingOfIsDomain` for more general statements, but these create data, and therefore\nmay cause diamonds if used improperly. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"(D : Type u_1) ‚Üí [inst : DivisionRing D] ‚Üí [inst : Finite D] ‚Üí Field D"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Every finite division ring is a field.\n\nGive ONLY the Lean code"}]}
{"text":"Every finite topological space is compact.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: In a Noetherian space, all sets are compact. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a discrete topological space, every compact set is finite.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s : Set X} [inst_1 : DiscreteTopology X], IsCompact s ‚Üí Set.Finite s"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A Noetherian and Hausdorff topological space is a finite space.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] [inst : T2Space Œ±], Finite Œ±"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A compact discrete space is finite. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst : DiscreteTopology X], Finite X"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a Noetherian topological space, every set is compact.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any topological space `X`, every finite subset `s` of `X` is compact in the sense that for every nontrivial filter `f` containing `s`, there exists an element `x` in `s` such that every set in `f` intersects every neighborhood of `x`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, Set.Finite s ‚Üí IsCompact s"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A compact discrete space is a finite set.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst : DiscreteTopology X], Finite X"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Finite topological spaces are compact. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Every finite topological space is compact.\n\nGive ONLY the Lean code"}]}
{"text":"Every surjective homomorphism from a finitely generated free group to itself is injective.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For every type `Œ±` with decidable equality, the injective function `FreeGroup.toWord` from the free group over `Œ±` to the list of pairs of elements from `Œ±` and booleans uniquely identifies each element in the free group.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} [inst : DecidableEq Œ±], Function.Injective FreeGroup.toWord"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The function `FreeAddGroup.toWord` from the additive free group to its quotient by the equivalence relation of commutativity and associativity maps equal elements to equal words.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} [inst : DecidableEq Œ±], Function.Injective FreeAddGroup.toWord"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A surjective endomorphism of a finite module over a commutative ring is injective.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Finite R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚áëf ‚Üí Function.Injective ‚áëf"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A group homomorphism between two groups is injective if and only if its kernel is the trivial subgroup.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤},\n  IsGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 1 ‚Üí a = 1)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: The universal property of a free group: A function from the generators of `G` to another\ngroup extends in a unique way to a homomorphism from `G`.\n\nNote that since `IsFreeGroup.lift` is expressed as a bijection, it already\nexpresses the universal property.  \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {H : Type u_2} [inst_2 : Group H]   (f : IsFreeGroup.Generators G ‚Üí H), ‚àÉ! F, ‚àÄ (a : IsFreeGroup.Generators G), F (IsFreeGroup.of a) = f a"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For additive groups Œ± and Œ≤, and a function f : Œ± ‚Üí Œ≤ that is an additive group homomorphism, f is injective if and only if its kernel {a : Œ± | f(a) = 0} consists only of the additive identity of Œ±.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : Œ± ‚Üí Œ≤},\n  IsAddGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 0 ‚Üí a = 0)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Two homomorphisms out of a free group are equal if they are equal on generators.\n\nSee note [partially-applied ext lemmas]. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} {G : Type u_1} [inst : Group G] (f g : FreeGroup Œ± ‚Üí* G),   (‚àÄ (a : Œ±), f (FreeGroup.of a) = g (FreeGroup.of a)) ‚Üí f = g"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The canonical map from any type to its additive free group is an injection.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u}, Function.Injective FreeAddGroup.of"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For every type `Œ±` with decidable equality, the injective function `FreeGroup.toWord` from the free group over `Œ±` to the list of pairs of elements from `Œ±` and booleans uniquely identifies each element in the free group.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} [inst : DecidableEq Œ±], Function.Injective FreeGroup.toWord"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The `FreeGroup.of` function mapping each element of type `Œ±` to its corresponding free group element is an injection.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u}, Function.Injective FreeGroup.of"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: The canonical map from the type to the free group is an injection. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u}, Function.Injective FreeGroup.of"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Every surjective homomorphism from a finitely generated free group to itself is injective.\n\nGive ONLY the Lean code"}]}
{"text":"Every positive even integer greater than $4$ can be written as the sum of two primes.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In any semiring, 2 is equal to the sum of two identical elements.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_2} [inst : Semiring Œ±], Even 2"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The theorem `Nat.prime_two` asserts that 2 is a prime number in the natural numbers, i.e., it is a natural number greater than 1 that has no divisors other than 1 and itself.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"Nat.Prime 2"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÄ {q : ‚Ñï}, Nat.Prime q ‚Üí q % 4 = 3 ‚Üí Even (padicValNat q n)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  Given any natural number `n` and a prime `p` less than or equal to 2 times some larger natural number `q` such that `n` is less than `p`, there exists a prime `p'` greater than `n` and less than or equal to 2 times `n`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï} (q : ‚Ñï) {p : ‚Ñï},\n  Nat.Prime p ‚Üí\n    p ‚â§ 2 * q ‚Üí (n < q ‚Üí ‚àÉ p, Nat.Prime p ‚àß n < p ‚àß p ‚â§ 2 * n) ‚Üí n < p ‚Üí ‚àÉ p, Nat.Prime p ‚àß n < p ‚àß p ‚â§ 2 * n"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  Every integer can be classified as even (being expressible as 2*r for some integer r) or odd (being expressible as 2*k + 1 for some integer k).\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (n : ‚Ñ§), Even n ‚à® Odd n"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  Every natural number can be expressed as the sum of four squares of natural numbers.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (n : ‚Ñï), ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: **Four squares theorem** \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (n : ‚Ñï), ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For every natural number n > 1, there exists a prime number p with n < p <= 2n.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (n : ‚Ñï), n ‚â† 0 ‚Üí ‚àÉ p, Nat.Prime p ‚àß n < p ‚àß p ‚â§ 2 * n"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Lagrange's **four squares theorem** for a prime number. Use `Nat.sum_four_squares` instead. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Every positive even integer greater than $4$ can be written as the sum of two primes.\n\nGive ONLY the Lean code"}]}
{"text":"Every matrix satisfies its own characteristic polynomial.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: The characteristic polynomial of a matrix `M` is given by $\\det (t I - M)$.\n\n\nGive ONLY the Lean code"},{"role":"assistant","content":"{R : Type u_1} ‚Üí   [inst : CommRing R] ‚Üí {n : Type u_4} ‚Üí [inst_1 : DecidableEq n] ‚Üí [inst_2 : Fintype n] ‚Üí Matrix n n R ‚Üí Polynomial R"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: `charpoly f` is the characteristic polynomial of the matrix of `f` in any basis. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M]   [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M ‚Üí‚Çó[R] M) {Œπ : Type w}   [inst_6 : DecidableEq Œπ] [inst_7 : Fintype Œπ] (b : Basis Œπ R M),   charpoly ((LinearMap.toMatrix b b) f) = LinearMap.charpoly f"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any commutative ring `R` and `R`-module `M`, if `f` is a linear map from `M` to `M`, then the characteristic polynomial of `f` evaluated at `f` is zero.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M] [inst_4 : Module.Finite R M] (f : M ‚Üí‚Çó[R] M), (Polynomial.aeval f) f.charpoly = 0"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The characteristic matrix of a square matrix over a commutative ring with decidable equality has the `i`-`th` diagonal entry equal to `X` minus the entry in the `i`-`th` row and column.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : CommRing R] {n : Type u_4} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R)   (i : n), Matrix.charmatrix M i i = Polynomial.X - Polynomial.C (M i i)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The characteristic polynomial of the multiplication-by-an-element map in a commutative algebra equals the minimal polynomial.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u} [inst : CommRing R] {S : Type u_1} [inst_1 : Ring S] [inst_2 : Algebra R S] (h : PowerBasis R S),\n  ((Algebra.leftMulMatrix h.basis) h.gen).charpoly = minpoly R h.gen"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any commutative ring with decidable equality `R` and a finite type `n`, the natural degree of the characteristic polynomial of a nontrivial `n x n` matrix over `R` equals the number of elements in `n`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u} [inst : CommRing R] {n : Type v} [inst_1 : DecidableEq n] [inst_2 : Fintype n] [inst_3 : Nontrivial R]   (M : Matrix n n R), natDegree (charpoly M) = Fintype.card n"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any commutative ring R, matrix M over R with decidable equality and finite type indices, and monic polynomial p with coefficients in R, the evaluation of p at M is equal to the remainder of p divided by the characteristic polynomial of M when both are evaluated at M.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u} [inst : CommRing R] {n : Type v} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R)\n  (p : Polynomial R), (Polynomial.aeval M) p = (Polynomial.aeval M) (p %‚Çò M.charpoly)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any commutative ring with decidable equality and finite type `n`, the degree of the characteristic polynomial of a `n` by `n` matrix over that ring equals the cardinality of `n`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u} [inst : CommRing R] {n : Type v} [inst_1 : DecidableEq n] [inst_2 : Fintype n] [inst_3 : Nontrivial R]   (M : Matrix n n R), degree (charpoly M) = ‚Üë(Fintype.card n)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any commutative ring R, a non-trivial linear map f from a free and finite R-module M to M, and any basis b of M over R, the characteristic polynomials of f and its matrix representation with respect to basis b are equal.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M ‚Üí‚Çó[R] M) {Œπ : Type w}\n  [inst_6 : DecidableEq Œπ] [inst_7 : Fintype Œπ] (b : Basis Œπ R M), ((LinearMap.toMatrix b b) f).charpoly = f.charpoly"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The characteristic polynomial of any square matrix over a commutative ring with decidable equality has a leading coefficient of 1.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u} [inst : CommRing R] {n : Type v} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),   Monic (charpoly M)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The characteristic polynomial of a matrix, when evaluated at the matrix itself, yields the zero matrix.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : CommRing R] {n : Type u_4} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),\n  (Polynomial.aeval M) M.charpoly = 0"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix,\napplied to the matrix itself, is zero.\n\nThis holds over any commutative ring.\n\nSee `LinearMap.aeval_self_charpoly` for the equivalent statement about endomorphisms.\n\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : CommRing R] {n : Type u_4} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R),   (Polynomial.aeval M) (Matrix.charpoly M) = 0"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Every matrix satisfies its own characteristic polynomial.\n\nGive ONLY the Lean code"}]}
{"text":"The square root of an irrational number is irrational.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The square root of 5 minus 1, divided by 2, is an irrational number.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"Irrational goldenConj"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  An irrational real number does not equal any natural number.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {x : ‚Ñù}, Irrational x ‚Üí ‚àÄ (m : ‚Ñï), x ‚â† ‚Üëm"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A transcendental real number is irrational.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {r : ‚Ñù}, Transcendental ‚Ñö r ‚Üí Irrational r"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\n`x` is irrational. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {x : ‚Ñù} (n : ‚Ñï) (m : ‚Ñ§), x ^ n = ‚Üëm ‚Üí (¬¨‚àÉ y, x = ‚Üëy) ‚Üí 0 < n ‚Üí Irrational x"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The golden ratio `(1 + ‚àö5) / 2` is not a rational number.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"Irrational goldenRatio"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A transcendental real number is irrational. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {r : ‚Ñù}, Transcendental ‚Ñö r ‚Üí Irrational r"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The square root of 2 is not a rational number.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"Irrational ‚àö2"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: **Irrationality of the Square Root of 2** \n\nGive ONLY the Lean code"},{"role":"assistant","content":"Irrational (Real.sqrt 2)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: The square root of an irrational number is irrational.\n\nGive ONLY the Lean code"}]}
{"text":"If the square of a number is even, the number itself is even.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: If `m` and `n` are natural numbers, then the natural number `m^n` is even\nif and only if `m` is even and `n` is positive. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {m n : ‚Ñï}, Even (m ^ n) ‚Üî Even m ‚àß n ‚â† 0"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A natural number is even if and only if it is not odd. Equivalently, a natural number is even if and only if it can be written as 2 times some natural number, and it is odd if and only if it can be written as 2 times some natural number plus 1.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï}, Even n ‚Üî ¬¨Odd n"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A natural number `n` can be expressed as the sum of two squares if and only if the highest power of every prime `q` in its prime factorization, where `q` is congruent to 3 modulo 4, in its prime factorization has even power.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï}, (‚àÉ x y, n = x ^ 2 + y ^ 2) ‚Üî ‚àÄ {q : ‚Ñï}, Nat.Prime q ‚Üí q % 4 = 3 ‚Üí Even (padicValNat q n)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A natural number `n` is even if and only if `n` modulo 2 equals 0.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {n : ‚Ñï}, Even n ‚Üî n % 2 = 0"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: If the square of a number is even, the number itself is even.\n\nGive ONLY the Lean code"}]}
{"text":"In a finite commutative ring, all prime ideals are maximal.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a commutative local semiring, an element is in the maximal ideal if and only if it is a nonunit.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : LocalRing R] (x : R), x ‚àà LocalRing.maximalIdeal R ‚Üî x ‚àà nonunits R"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any commutative semiring R and prime ideal I, the image of I under the localization map at the complement of I is a unique maximal ideal equal to the maximal ideal of the local ring at I.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : I.IsPrime],\n  Ideal.map (algebraMap R (Localization.AtPrime I)) I = LocalRing.maximalIdeal (Localization I.primeCompl)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: [Stacks Lemma 00J7](https://stacks.math.columbia.edu/tag/00J7)\n\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (R : Type u_1) [inst : CommRing R] [inst_1 : IsArtinianRing R], Set.Finite {I | Ideal.IsMaximal I}"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The unique maximal ideal of a commutative semiring localized at the complement of a prime ideal maps back to the original prime ideal under the algebra homomorphism.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : I.IsPrime],\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization I.primeCompl)) = I"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a one-dimensional commutative ring `R` with unit, a prime ideal `p` different from the bottom ideal is a maximal ideal.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_4} [inst : CommRing R] [inst_1 : DimensionLEOne R] {p : Ideal R}, IsPrime p ‚Üí p ‚â† ‚ä• ‚Üí IsMaximal p"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If every prime ideal in a commutative ring `R` is principal, then every ideal in `R` is principal.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u} [inst : CommRing R], (‚àÄ (P : Ideal R), P.IsPrime ‚Üí Submodule.IsPrincipal P) ‚Üí IsPrincipalIdealRing R"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a commutative semiring, a maximal ideal is a prime ideal.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} [inst : CommSemiring Œ±] {I : Ideal Œ±}, Ideal.IsMaximal I ‚Üí Ideal.IsPrime I"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: In a finite commutative ring, all prime ideals are maximal.\n\nGive ONLY the Lean code"}]}
{"text":"A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X √ó X$.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A topological space is T2 (Hausdorff) if and only if no ultrafilter intersects the neighborhood filters of distinct points.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ‚Üî ‚àÄ {x y : X} (f : Ultrafilter X), ‚Üëf ‚â§ ùìù x ‚Üí ‚Üëf ‚â§ ùìù y ‚Üí x = y"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A function between topological spaces is separated if and only if the diagonal of its pullback is a closed set.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u_1} {Y : Sort u_2} [inst : TopologicalSpace X] {f : X ‚Üí Y},   IsSeparatedMap f ‚Üî IsClosed (Function.pullbackDiagonal f)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A topological space X equipped with a topology is a T2 space if and only if the diagonal set in X √ó X is a closed set in the product topology.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ‚Üî IsClosed (Set.diagonal X)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A topological space `X` is T2 (Hausdorff) if and only if for all distinct points `x` and `y` in `X`, the neighborhood filters of `x` and `y` have empty intersection (i.e., their infimum is the bottom element).\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ‚Üî Pairwise fun x y => Disjoint (ùìù x) (ùìù y)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a compact uniform space, the uniformity is equivalent to the filter of neighborhoods of the diagonal.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} [inst : UniformSpace Œ±] [inst_1 : CompactSpace Œ±], nhdsSet (Set.diagonal Œ±) = uniformity Œ±"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A topological space X equipped with a topology is a T2 space if and only if the diagonal set in X √ó X is a closed set in the product topology.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ‚Üî IsClosed (diagonal X)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X √ó X$.\n\nGive ONLY the Lean code"}]}
{"text":"If every point of a subset of a topological space is contained in some open set, the subset itself is open.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u} {s : Set X} [inst : TopologicalSpace X] {U : Set X}, (‚àÄ x ‚àà s, U ‚àà ùìù x) ‚Üí ‚àÉ V, s ‚äÜ V ‚àß IsOpen V ‚àß V ‚äÜ U"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A set `s` is open iff for every point `x` in `s` and every `y` close to `x`, `y` is in `s`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u} {s : Set X} [inst : TopologicalSpace X], IsOpen s ‚Üî ‚àÄ x ‚àà s, ‚àÄ·∂† (y : X) in ùìù x, y ‚àà s"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In any topological space, the union of a collection of open sets is an open set.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u} [self : TopologicalSpace X] (s : Set (Set X)),   (‚àÄ (t : Set X), t ‚àà s ‚Üí TopologicalSpace.IsOpen t) ‚Üí TopologicalSpace.IsOpen (‚ãÉ‚ÇÄ s)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any topological space X, point x in X, and open set s in X containing x, there exists a neighborhood N of x such that N ‚äÜ s.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u} {x : X} {s : Set X} [inst : TopologicalSpace X], IsOpen s ‚Üí x ‚àà s ‚Üí ‚àÄ·∂† (x : X) in ùìù x, x ‚àà s"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A set `s` of type `X` in a topological space is equal to its interior if and only if it is open.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u} {s : Set X} [inst : TopologicalSpace X], s ‚äÜ interior s ‚Üî IsOpen s"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a second-countable topological space, every open cover has a countable subcover.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [inst : SecondCountableTopology Œ±] {Œπ : Type u_1} (s : Œπ ‚Üí Set Œ±),\n  (‚àÄ (i : Œπ), IsOpen (s i)) ‚Üí ‚àÉ T, T.Countable ‚àß ‚ãÉ i ‚àà T, s i = ‚ãÉ i, s i"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In any topological space, the interior of a set is an open set.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u} {s : Set X} [inst : TopologicalSpace X], IsOpen (interior s)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a function `f` is injective, continuous, and for every point in a compact set `s`, there exists an open neighborhood where `f` is injective, then `f` is injective on some open neighborhood of `s`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u_3} {Y : Type u_4} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space Y]\n  {f : X ‚Üí Y} {s : Set X},\n  Set.InjOn f s ‚Üí\n    IsCompact s ‚Üí\n      (‚àÄ x ‚àà s, ContinuousAt f x) ‚Üí (‚àÄ x ‚àà s, ‚àÉ u ‚àà nhds x, Set.InjOn f u) ‚Üí ‚àÉ t, IsOpen t ‚àß s ‚äÜ t ‚àß Set.InjOn f t"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any topological space `(Œ±, top)`, every element of `top.opens Œ±` is an open set in `Œ±`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_2} [inst : TopologicalSpace Œ±] (U : TopologicalSpace.Opens Œ±), IsOpen ‚ÜëU"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In the indiscrete topology, a set is open if and only if it is either the empty set or the entire space.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_2} (U : Set Œ±), IsOpen U ‚Üî U = ‚àÖ ‚à® U = Set.univ"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A set in a topological space is open if and only if every element in the set is contained in some open subset of the set.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {X : Type u} {s : Set X} [inst : TopologicalSpace X], IsOpen s ‚Üî ‚àÄ x ‚àà s, ‚àÉ t ‚äÜ s, IsOpen t ‚àß x ‚àà t"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: If every point of a subset of a topological space is contained in some open set, the subset itself is open.\n\nGive ONLY the Lean code"}]}
{"text":"Every non-identity element of a free group is of infinite order.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a monoid element has no finite order, then its order is 0.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, ¬¨IsOfFinOrder x ‚Üí orderOf x = 0"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: A predicate on a monoid saying that only 1 is of finite order. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"(G : Type u_1) ‚Üí [inst : Monoid G] ‚Üí Prop"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A nontrivial torsion group is not torsion-free. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], IsTorsion G ‚Üí ¬¨IsTorsionFree G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `f` is a homomorphism between additive monoids `G` and `H`, and `x` in `G` has finite additive order `n`, then `f(x)` has finite additive order `n` in `H`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G ‚Üí+ H) {x : G},\n  IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (f x)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  In a torsion-free monoid, the order of every non-identity element is infinite.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±], Monoid.IsTorsionFree Œ± ‚Üí Monoid.minOrder Œ± = ‚ä§"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Every non-identity element of a free group is of infinite order.\n\nGive ONLY the Lean code"}]}
{"text":"An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `k` is a perfect field of characteristic `p`, where `p` is a prime number, then the Witt vectors constructed from `k` form a Discrete Valuation Ring.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p)] {k : Type u_1} [inst : Field k] [inst_1 : CharP k p] [inst_2 : PerfectRing k p],\n  DiscreteValuationRing (WittVector p k)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a commutative ring `R` is an integral domain satisfying `DiscreteValuationRing.HasUnitMulPowIrreducibleFactorization` for some irreducible element `p`, then `R` is a discrete valuation ring.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R],\n  DiscreteValuationRing.HasUnitMulPowIrreducibleFactorization R ‚Üí DiscreteValuationRing R"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: An integral domain in which there is an irreducible element `p`\nsuch that every nonzero element is associated to a power of `p`\nis a discrete valuation ring.\n\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R],   DiscreteValuationRing.HasUnitMulPowIrreducibleFactorization R ‚Üí DiscreteValuationRing R"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any division ring `K` and valuation `v` on `K` into a linear ordered commutative monoid `Œì‚ÇÄ` with zero, `v(x) = 0` if and only if `x = 0`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {K : Type u_1} [inst : DivisionRing K] {Œì‚ÇÄ : Type u_4} [inst_1 : LinearOrderedCommMonoidWithZero Œì‚ÇÄ]\n  [inst_2 : Nontrivial Œì‚ÇÄ] (v : Valuation K Œì‚ÇÄ) {x : K}, v x = 0 ‚Üî x = 0"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {K : Type u_1} [inst : DivisionRing K] {Œì‚ÇÄ : Type u_4} [inst_1 : LinearOrderedCommMonoidWithZero Œì‚ÇÄ]   [inst_2 : Nontrivial Œì‚ÇÄ] (v : Valuation K Œì‚ÇÄ) {x : K}, v x = 0 ‚Üî x = 0"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.\n\nGive ONLY the Lean code"}]}
{"text":"For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `a` is the sum of squares of two natural numbers `x` and `y`, and `b` is the sum of squares of natural numbers `u` and `v`, then there exist natural numbers `r` and `s` such that `a * b` is the sum of squares of `r` and `s`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If natural numbers `a` and `b` are coprime, then the exponent of prime `p` in the prime factorization of `a * b` is the sum of the exponents of `p` in the prime factorizations of `a` and `b`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p a b : ‚Ñï}, a.Coprime b ‚Üí (a * b).factorization p = a.factorization p + b.factorization p"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `x` and `y` are linearly independent vectors in a module `M` over a commutative ring `R` with no zero divisors, then the vectors `a*x + b*y` and `c*x + d*y` are also linearly independent in `M` whenever `a*d - b*c` is nonzero.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_8} {M : Type u_9} [inst : CommRing R] [inst_1 : NoZeroDivisors R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {x y : M},\n  LinearIndependent R ![x, y] ‚Üí ‚àÄ {a b c d : R}, a * d - b * c ‚â† 0 ‚Üí LinearIndependent R ![a ‚Ä¢ x + b ‚Ä¢ y, c ‚Ä¢ x + d ‚Ä¢ y]"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: **B√©zout's lemma** \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (x y : ‚Ñ§), ‚Üë(Int.gcd x y) = x * Int.gcdA x y + y * Int.gcdB x y"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For all nonzero natural numbers a and b, the prime factorizations of a * b are equal to the sum of the prime factorizations of a and b.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {a b : ‚Ñï}, a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a * b).factorization = a.factorization + b.factorization"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be\nwritten in the form `a * x + b * y` for some pair of integers `x` and `y` \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {a b : ‚Ñ§}, a ‚â† 0 ‚Üí IsLeast {n | 0 < n ‚àß ‚àÉ x y, ‚Üën = a * x + b * y} (Int.gcd a b)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `x` and `y` are elements of a cancellative commutative monoid with zero, `p` is a prime element, and `p^n = axy` for some natural number `n`, then there exist natural numbers `i`, `j` and elements `b`, `c` in the monoid such that `i + j = n`, `a = bc`, `x = bp^i`, and `y = cp^j`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : CancelCommMonoidWithZero R] {x y a p : R} {n : ‚Ñï},\n  Prime p ‚Üí x * y = a * p ^ n ‚Üí ‚àÉ i j b c, i + j = n ‚àß a = b * c ‚àß x = b * p ^ i ‚àß y = c * p ^ j"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: **B√©zout's lemma**: given `x y : ‚Ñï`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and\n`b = gcd_b x y` are computed by the extended Euclidean algorithm.\n\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (x y : ‚Ñï), ‚Üë(Nat.gcd x y) = ‚Üëx * Nat.gcdA x y + ‚Üëy * Nat.gcdB x y"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If two natural numbers `a` and `b` are coprime, then the prime factorization of their product `a * b` is the concatenation of the prime factorizations of `a` and `b`.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {a b : ‚Ñï}, a.Coprime b ‚Üí (a * b).factorization = a.factorization + b.factorization"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: **Four squares theorem** \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (n : ‚Ñï), ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The greatest common divisor of two nonzero integers `a` and `b` is the unique positive integer `d` such that `d` can be expressed as a linear combination of `a` and `b` with integer coefficients.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {a b : ‚Ñ§}, a ‚â† 0 ‚Üí IsLeast {n | 0 < n ‚àß ‚àÉ x y, ‚Üën = a * x + b * y} (a.gcd b)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Lagrange's **four squares theorem** for a prime number. Use `Nat.sum_four_squares` instead. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí ‚àÉ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.\n\nGive ONLY the Lean code"}]}
{"text":"Every field is a ring.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A finite domain is a field. See also `littleWedderburn` and `Fintype.divisionRingOfIsDomain`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (D : Type u_1) [inst : Finite D] [inst : Ring D] [inst_1 : IsDomain D], IsField D"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A field is a valuation ring. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (K : Type u) [inst : Field K], ValuationRing K"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If a field `K` of exponential characteristic `p` is a perfect ring, then `K` is a perfect field.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (K : Type u_1) (p : ‚Ñï) [inst : Field K] [inst_1 : ExpChar K p] [inst_2 : PerfectRing K p], PerfectField K"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Transferring from `Field` to `IsField`. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (R : Type u) [inst : Field R], IsField R"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Every field is a ring.\n\nGive ONLY the Lean code"}]}
{"text":"The set of units in a ring forms a group.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Definition: Units of a monoid form a group. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"{Œ± : Type u} ‚Üí [inst : Monoid Œ±] ‚Üí Group Œ±À£"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any unit integer `u`, `u` raised to the power of 2 equals 1.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (u : ‚Ñ§À£), u ^ 2 = 1"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: The group of units of a complete normed ring is an open subset of the ring. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: The set of units in a ring forms a group.\n\nGive ONLY the Lean code"}]}
{"text":"If the direct product of two groups is torsion free then each of the groups is torsion free.","fullPrompt":[{"role":"system","content":"You are a Mathematics, Lean 4 and coding assistant who answers questions about Mathematics and Lean 4, gives hints while coding in Lean 4. You also translates from natural language to Lean Theorem Prover code and vice versa when asked. Follow EXACTLY any examples given when generating Lean code."},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any additive commutative group `G`, the quotient `G / torsionSubgroup(G)` is a torsion-free group.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Quotienting a group by its torsion subgroup yields a torsion free group. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (G : Type u_1) [inst : CommGroup G], IsTorsionFree (G ‚ß∏ CommGroup.torsion G)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If 'G' is an additively torsion-free group, then every subgroup of 'G' is also additively torsion-free.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree ‚Ü•H"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Subgroups of torsion-free groups are torsion-free. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : Group G], IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), IsTorsionFree ‚Ü•H"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  A nontrivial additive group with only the zero element having finite order is torsion-free and hence not a torsion group.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G ‚Üí ¬¨AddMonoid.IsTorsion G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A nontrivial torsion group is not torsion-free. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], IsTorsion G ‚Üí ¬¨IsTorsionFree G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If 'G' is an additively torsion-free group, then every subgroup of 'G' is also additively torsion-free.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree ‚Ü•H"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: A nontrivial torsion-free group is not torsion. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], IsTorsionFree G ‚Üí ¬¨IsTorsion G"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  The direct product of a family of torsion-free groups is a torsion-free group.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ∑ : Type u_3} {Gs : Œ∑ ‚Üí Type u_4} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Products of nilpotent groups are nilpotent \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {G‚ÇÅ : Type u_2} {G‚ÇÇ : Type u_3} [inst : Group G‚ÇÅ] [inst_1 : Group G‚ÇÇ] [inst_2 : Group.IsNilpotent G‚ÇÅ]   [inst_3 : Group.IsNilpotent G‚ÇÇ], Group.IsNilpotent (G‚ÇÅ √ó G‚ÇÇ)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  For any additive commutative group `G`, the quotient `G / torsionSubgroup(G)` is a torsion-free group.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `Gs` is a family of additive torsion-free groups indexed by a type `Œ∑`, then their direct product is also a torsion-free additive group.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ∑ : Type u_3} {Gs : Œ∑ ‚Üí Type u_4} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],   (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem:  If `Gs` is a family of additive torsion-free groups indexed by a type `Œ∑`, then their direct product is also a torsion-free additive group.\n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ∑ : Type u_3} {Gs : Œ∑ ‚Üí Type u_4} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: Direct products of torsion free groups are torsion free. \n\nGive ONLY the Lean code"},{"role":"assistant","content":"‚àÄ {Œ∑ : Type u_3} {Gs : Œ∑ ‚Üí Type u_4} [inst : (i : Œ∑) ‚Üí Group (Gs i)],   (‚àÄ (i : Œ∑), IsTorsionFree (Gs i)) ‚Üí IsTorsionFree ((i : Œ∑) ‚Üí Gs i)"},{"role":"user","content":"Translate the following statement into Lean 4:\n## Theorem: If the direct product of two groups is torsion free then each of the groups is torsion free.\n\nGive ONLY the Lean code"}]}
