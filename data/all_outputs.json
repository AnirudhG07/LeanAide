[
  {
    "output": "theorem every_prop_implies_itself (p : Prop) : p \u2192 p "
  },
  {
    "output": "theorem P_implies_P : \u2200 p : Prop, (p \u2192 p) .\n\nTheorem self_implies : \u2200 p : Prop, p \u2192 p.\nProof.\n  intros p.\n  intros q.\n\n\n  exact q.\nQed.\n\nPrint self_implies.\n\nTheorem impl_hself : (\u2200 p : Prop, p \u2192 p) \u2192 (\u2200 h : \u2200 p : Prop, p \u2192 p, h = self_implies).\nProof.\n  intros hA.\n\n  apply funext.\n  intro h.\n\n  apply funext.\n  intro p.\n\n  apply fun"
  },
  {
    "output": "theorem : (\u2200 P : Prop, P \u2192 P) "
  },
  {
    "output": "theorem every_prop_implies_itself : \u2200 (p : Prop), p \u2192 p "
  },
  {
    "output": "theorem implies_self (p : Prop) : p \u2192 p "
  },
  {
    "output": "theorem implies_self (P : Prop) : P \u2192 P "
  },
  {
    "output": "theorem implies_self (P : Prop) : P \u2192 P "
  },
  {
    "output": "theorem implies_itself (p : Prop) : p \u2192 p "
  },
  {
    "output": "theorem a_self_imply_a (a : Prop) : a \u2192 a "
  },
  {
    "output": "theorem p_implies_p (P : Prop) :\n P \u2192 P "
  },
  {
    "output": "theorem implies.refl{p : Prop} (h : p) : implies p p "
  },
  {
    "output": "theorem self_implies (p : Prop) :\np \u2192 p "
  },
  {
    "output": "theorem implies.refl {a : Prop} : implies a a "
  },
  {
    "output": "theorem implies.irrefl{a : Prop} (ha : a) : implies a a "
  },
  {
    "output": "theorem implies.refl{p : Prop} :\nimplies p p "
  },
  {
    "output": "theorem self\u2081 : \u2200 {\u03b1 : Type}, \u03b1 \u2192 \u03b1 . . .\n}\n-/\n/-\n (1) To prove this theorem, try to use the tactic apply. It may be a challenge to figure out\n how to state the apply tactic, because the premise on the left-hand side of the colon is a \n universal quantification, while that on the right-hand side is an existential quantification. \n The tactics `intro` and `apply` interact with each other, so you may also need to use an \n appropriate intro tactic before your apply.\n-/\ntheorem self\u2081 : \u2200 {\u03b1 : Type}, \u03b1 \u2192 \u03b1 "
  },
  {
    "output": "theorem id_map_self (X : Type) : X \u2192 (X \u2192 X) "
  },
  {
    "output": "theorem exists_id ( \u03b1 : Type ) : \u2203 id : \u03b1 \u2192 \u03b1 , id = \u03bb x : \u03b1 , x "
  },
  {
    "output": "theorem t2 : \u2200 (A : Type), A \u2192 A "
  },
  {
    "output": "theorem iota_id : \u2200 X , \u03b9 X = id =\u209a X "
  },
  {
    "output": "theorem function_from_any_type_to_itself (X : Type*) :\n function X X "
  },
  {
    "output": "theorem it_self_fun (X : Type*) : X \u2192. X "
  },
  {
    "output": "theorem function_from_any_type_to_itself (X : Type*) :\n \u2203 f : X \u2192 X, true "
  },
  {
    "output": "theorem exists_to_itself (X : Type) : \u2203 f : X \u2192 X, \u2200 x : X, f x = x "
  },
  {
    "output": "theorem any_type_to_itself_has_id (X : Type*) :\n function X "
  },
  {
    "output": "theorem exists_f{\u03b1 : Type u} :\n\u2203 (g : \u03b1 \u2192 \u03b1), true "
  },
  {
    "output": "theorem function.id{\u03b1 : Sort u} :\n\u03b1 \u2192 \u03b1 "
  },
  {
    "output": "theorem exists_self{\u03b1 : Type u} :\n\u2203 (f : \u03b1 \u2192 \u03b1), true "
  },
  {
    "output": "theorem idmap_is_function{\u03b1 : Type u} :\nfunction \u03b1 "
  },
  {
    "output": "theorem exists_self\u2082{\u03b1 : Sort u} :\n\u2203 (f : \u03b1 \u2192 \u03b1), \u2200 (x : \u03b1), f x = x "
  },
  {
    "output": "theorem some_prop_true : some_prop \u2192 true "
  },
  {
    "output": "theorem True_implies_True : \u2200 { P : Prop }, P \u2192 True "
  },
  {
    "output": "theorem true_!(p : Prop) : p \u2192 (\u22a4 : Prop) "
  },
  {
    "output": "theorem implication : ( \u2200 P : Prop , P \u2192 True) "
  },
  {
    "output": "theorem foo ( P : Prop ) : P \u2192 True "
  },
  {
    "output": "theorem implies_true : \u2200 P : Prop, P \u2192 true "
  },
  {
    "output": "theorem all_props_imp_true : \u2200 (p : Prop), p \u2192 true "
  },
  {
    "output": "theorem true_implies_any (P : Prop) : P \u2192 true "
  },
  {
    "output": "theorem imp_true_iff_true (P : Prop) : P \u2192 (P \u2194 true) "
  },
  {
    "output": "theorem true_of_any_prop (p : Prop) : p \u2192 true "
  },
  {
    "output": "theorem true_iff_eq.elim(p : Prop) (h : p \u2194 true) :\np "
  },
  {
    "output": "theorem classical.prop_true{\u03b1 : Sort u_1} (H : \u03b1) :\nTrue "
  },
  {
    "output": "theorem implies.of_forall{p : Prop} (h : p) :\nimplies p true "
  },
  {
    "output": "theorem true_implies_iff (p : Prop) :\np \u2192 true "
  },
  {
    "output": "theorem exists_true{p : Prop} (h : p) :\nexists (h_1 : true), true "
  },
  {
    "output": "theorem ex1 ( A : Type ) ( f : A \u2192 punit ) : \u2200 a : A , f a = punit . star "
  },
  {
    "output": "theorem lang_mathlib : \u2200 { T : Type }, T \u2192 Unit "
  },
  {
    "output": "theorem has_func_to_unit {X : Type} : (Unit \u2192 X) \u2192 true "
  },
  {
    "output": "theorem t2 {\u03b1 : Type} : \u03b1 \u2192 unit "
  },
  {
    "output": "theorem something ( X : Type ) : ( X \u2192 Unit ) "
  },
  {
    "output": "theorem unit_has_one_function (X : Type*) :\n nonempty (Type u \u2192 X) "
  },
  {
    "output": "theorem to_unit_function_exists_of_subtype (T : Type*) [subtype T] :\n \u2203 (f : T \u2192 empty), true\n\nNatural language version: \"If G is commutative and R is a subring of G, then R is an ideal\" Translate the natural language version to a Lean mathlib version (with \"alpha\" replaced by \"R\" and \"beta\" replaced by \"G\"):\n theorem subring_of_ideal (alpha beta : Type*) [comm_ring beta] [subring alpha] :\n is_ideal alpha\n\nNatural language version: \"If A is a subassociative algebra then A is a subring"
  },
  {
    "output": "theorem inference_rule_1 (A : Type*) : (\u2200 {B : Type*}, B \u2192 A) \u2192 A "
  },
  {
    "output": "theorem has_choice (\u03b1 : Type*) : Type* "
  },
  {
    "output": "theorem function_from_any_type_to_unit (X : Type*) :\n \u03a3 f : X \u2192 unit, true "
  },
  {
    "output": "theorem exists_to_units{\u03b1 : Sort u} :\nnonempty \u03b1 \u2192 nonempty units "
  },
  {
    "output": "theorem to_Unit{X : Type u_1} [has_coe X Unit] :\nUnit \u2192 X "
  },
  {
    "output": "theorem unit.of{X : Type u} {x : X} :\nunit.{u} "
  },
  {
    "output": "theorem unit.forget :\n\u03a0 {X : Type u_1}, X \u2192 Unit\n|_ _ "
  },
  {
    "output": "theorem inhabited.rec_on{M : Type u_1} [h : inhabited M] {C : M \u2192 Sort*} (a : M) (H : C a) :\n\u2203 f : \u03a0 (a : M), C a, f \u27e8a, H\u27e9 = H "
  },
  {
    "output": "theorem example2 : \u2200P : Prop, False \u2192 P "
  },
  {
    "output": "theorem every_prop_from_false: forall P : Prop, false \u2192 P "
  },
  {
    "output": "theorem my_trivial_theorem' : false \u2192 \u2200 ( p : Prop ), p "
  },
  {
    "output": "theorem every_prop_follows_from_false : \u2200 (P : Prop), P "
  },
  {
    "output": "theorem not_true_eq_false : ~ true \u2194 false "
  },
  {
    "output": "theorem false_is_contradiction (P : Prop) (hfalse : false) : P "
  },
  {
    "output": "theorem trivial_implication_from_false (P : Prop) : false \u2192 P "
  },
  {
    "output": "theorem from_false (P : Prop) : P "
  },
  {
    "output": "theorem every_prop_above_false (P : Prop) : false \u2192 P "
  },
  {
    "output": "theorem false_implies_any (P : Prop) : False \u2192 P "
  },
  {
    "output": "theorem False_implies{a : Prop} :\nFalse \u2192 a "
  },
  {
    "output": "theorem falsum_implies{\u03b1 : Sort u_1} (h : false) (a : Prop) :\na "
  },
  {
    "output": "theorem false.elim{P : Prop} :\nfalse \u2192 P "
  },
  {
    "output": "theorem false.rec{a : Prop} :\nFalse \u2192 a "
  },
  {
    "output": "theorem false.elim(a : Prop) :\na "
  },
  {
    "output": "theorem empty_is_function (\u03b1 : Type) : Empty \u2192 \u03b1 "
  },
  {
    "output": "theorem empty_is_init {A : Type*} : Empty \u2192 A "
  },
  {
    "output": "theorem empty_to_any : Empty \u2192 \u03a0 (A : Sort u), A "
  },
  {
    "output": "theorem ex ( \u03b1 : Type ) : \u2203 f : Empty \u2192 \u03b1 , true "
  },
  {
    "output": "theorem empty_to_type (X : Type) : Empty \u2192 X "
  },
  {
    "output": "theorem empty_function_defined (X : Type*) :\n  {f : empty \u2192 X // \u2200 (e : empty), f e = default X} "
  },
  {
    "output": "theorem empty_type_has_no_functions_to_anything (X : Type*) :\n nonempty (Empty \u2192 X) "
  },
  {
    "output": "theorem function_from_empty (X : Type*) : (\u2205 \u2192 X) "
  },
  {
    "output": "theorem empty_into (F : Type*) : Empty \u2192 F "
  },
  {
    "output": "theorem exists_function_from_empty (X : Type*) :\n \u2203 f : Empty \u2192 X, true "
  },
  {
    "output": "theorem exists_empty_fun (\u03b1 : Type u_1) :\n\u2203 (f\u2080 : pempty \u2192 \u03b1), \u2200 (x : pempty), f\u2080 x = a "
  },
  {
    "output": "theorem function.empty_is_functional{\u03b1 : Type u_1} (a : Empty) :\nfunctional a "
  },
  {
    "output": "theorem empty.elim{C : Type u_1} (e : Empty) :\nC "
  },
  {
    "output": "theorem empty.of_subsingleton{\u03b1 : Type u_1} [subsingleton \u03b1] :\nEmpty \u2192 \u03b1 "
  },
  {
    "output": "theorem empty.func {\u03b1 : Type u_1} :\n\u03b1 \u2192 Empty "
  },
  {
    "output": "theorem QMP ( P : Prop ) ( Q : Prop ) ( q : Q ) : P \u2192 P "
  },
  {
    "output": "theorem foo ( P Q:Model ) : Model "
  },
  {
    "output": "theorem Q_if_P ( P Q : Prop ) : P \u2192 Q \u2192 P "
  },
  {
    "output": "theorem follows_from_assumption_of_true ( P Q : Prop ) :  \n \u2200 ( P_is_true : P ), ( Q \u2192 P ) "
  },
  {
    "output": "theorem P_Q (Q P : Prop) (QP : Q \u2192 P) (PP : P) : Q "
  },
  {
    "output": "theorem imp.true_intro (P Q : Prop) (h : P) : P \u2192 Q "
  },
  {
    "output": "theorem P_of_P_and_Q (P Q : Prop) (hP : P) (hPQ : P \u2192 Q) : Q "
  },
  {
    "output": "theorem propositional_version (P Q : Prop) (h1 : P) : P \u2192 Q "
  },
  {
    "output": "theorem p_imp_p_of_p_imp_q_of_p (p q : Prop) (h : p \u2192 q) (hp : p) :\n p "
  },
  {
    "output": "theorem p_implies_p_under_decidability_of_q (P Q : Prop) :\n P \u2192 (Q \u2192 P) "
  },
  {
    "output": "theorem of_true{p q : Prop} (q_true : q) :\np \u2192 q "
  },
  {
    "output": "theorem exists.elim{p q : Prop} (h\u2081 : p) (H : exists.{u} p, q) :\nq "
  },
  {
    "output": "theorem idP{p : Prop} (h : p) :\np "
  },
  {
    "output": "theorem triv_imp{p q : Prop} (h : p) :\nq "
  },
  {
    "output": "theorem assumption{p q : Prop} (h : p) :\np \u2192 q "
  },
  {
    "output": "theorem not_of_iff (P : Prop) : \u00acP <-> P \u27f9 false "
  },
  {
    "output": "theorem contrapositive : \u2200 p, \u00ac(p \u2194 q) \u2194 (q \u2194 \u00ac p) "
  },
  {
    "output": "theorem not_iff_implies_False : p \u2194 \u00ac p "
  },
  {
    "output": "theorem my_ne_iff_not_iff (a b : Prop) : (a \u2260 b) \u2194 (a \u2192 \u00ac b) "
  },
  {
    "output": "theorem not_iff_t_f : \u2200 p : Prop, (\u00ac p) = (p \u2192 (false)) "
  },
  {
    "output": "theorem neg_iff_implies_false (P : Prop) : (\u00ac P) \u2194 (P \u2192 false) "
  },
  {
    "output": "theorem negation_iff_false (P : Prop) :\n \u00acP \u2194 (P \u2192 false) "
  },
  {
    "output": "theorem iff_neg_iff_imp_false :\n \u2200 (p : Prop),\n p \u2194 \u00ac p \u2194 (p \u2192 false) "
  },
  {
    "output": "theorem not_iff_implies_false (P : Prop) :\n  \u00acP \u2194 (P \u2192 false) "
  },
  {
    "output": "theorem not_eq_iff_implies_false (P : Prop) : \u00ac P \u2194 (P \u2192 false) "
  },
  {
    "output": "theorem not{a : Prop} :\n\u00aca \u2194 a \u2192 False "
  },
  {
    "output": "theorem de_morgan_not_and_not{a b : Prop} :\n\u2665(a \u2228 b) \u2194 \u2665a \u2227 \u2665b "
  },
  {
    "output": "theorem not_iff_not_imp{a : Prop} :\n\u00aca \u2194 (a \u2192 false) "
  },
  {
    "output": "theorem not_iff_not{a : Prop} : \n\u00aca \u2194 (a \u2192 false) "
  },
  {
    "output": "theorem dne{a : Prop} :\n\u00ac\u00aca \u2194 a "
  },
  {
    "output": "theorem double_negation_elim ( P : Prop ) : P \u2192 \u00ac \u00ac P "
  },
  {
    "output": "theorem double_negation.decidability : A \u2192 (A \u2192 false) \u2192 false "
  },
  {
    "output": "theorem P_to_D !(P : Prop) : \n  P \u2192 \u25fb P. You might use the tactic \n  exact(PN_to_D N) \n  where \n  def N (P : Prop) : Prop "
  },
  {
    "output": "theorem \n    every_prop_implies_its_double_negation : \u2200 P : Prop, (P \u2192 \u00ac\u00acP).\n Qed.\n\nTheorem modus_ponens: \u2200 P Q : Prop, P \u2192 (P \u2192 Q) \u2192 Q.\nProof.\n  intros P Q.\n  intros P_implies_Q QP.\n  apply P_implies_Q.\n  exact QP.\nQed.\n\nTheorem modus_tollens: \u2200 P Q : Prop, (P \u2192 Q) \u2192 (\u00acQ \u2192 \u00acP).\nProof.\n  (* intros P Q"
  },
  {
    "output": "theorem implies_double_negation : \u2200 (p : Prop), p \u2192 \u00ac \u00ac p "
  },
  {
    "output": "theorem dneg_eq_impl_of_prop (p : Prop) :\n  p \u2192 ~~p "
  },
  {
    "output": "theorem imp_double_neg (P : Prop) :\n P \u2192 \u00ac\u00acP "
  },
  {
    "output": "theorem dn_implies_prop (P : Prop) (hP : \u00ac\u00acP) : P "
  },
  {
    "output": "theorem double_negation (P : Prop) : P \u2192 \u00ac \u00ac P "
  },
  {
    "output": "theorem every_prop_implies_double_neg (p : Prop) :\n (p \u2192 \u00ac\u00acp) "
  },
  {
    "output": "theorem double_negation{p : Prop} : (p \u2192 \u00ac\u00acp) "
  },
  {
    "output": "theorem imp_double_neg{a : Prop} :\n(a \u2192 \u00ac\u00aca) "
  },
  {
    "output": "theorem not_not_ands {a : Prop} : \n  a \u2192 \u00ac\u00aca "
  },
  {
    "output": "theorem implies_not_not{a : Prop} :\na \u2192 \u00ac\u00aca "
  },
  {
    "output": "theorem implies_not_not{a : Prop} :\na \u2192 \u00ac\u00aca "
  },
  {
    "output": "theorem implies_contrapos : \u2200 A B: Prop, (A \u2192 B) \u2192 (\u00acB \u2192 \u00acA) "
  },
  {
    "output": "theorem contraposition (p q : Prop) (hpq : p \u2192 q) : \u00acq \u2192 \u00acp "
  },
  {
    "output": "theorem contraposition : \u2200 (p q : Prop), (p \u2192 q) \u2192 (\u00ac q \u2192 \u00ac p). intros.\n \n \n This can be translated to: \u2200 (A B : Prop), (A \u2192 B) \u2192 (\u00ac B \u2192 \u00ac A) . \n \nQed.\n\nAxiom Modus_Ponens : forall (A B: Prop), (A -> B) -> A -> B.\n\nTheorem and_commutative : forall (P Q : Prop),  P \u2227 Q -> Q \u2227 P .\nProof.\nintros P Q.\nintro H.\ndestruct H as [P1"
  },
  {
    "output": "theorem some_lemma' {p q : Prop} (h : p \u2192 q) : q \u2192 p "
  },
  {
    "output": "theorem contraposition {A B C : Type} (implication : A \u2192 B \u2192 C) (a : A) (b : B) (h : \u00ac C) :\n  false "
  },
  {
    "output": "theorem contrapositive (P Q : Prop) : (P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P) "
  },
  {
    "output": "theorem contraposition_of_implication_of_implication : \u2200 (P Q : Prop), (P \u2192 Q) \u2192 \u00acQ \u2192 \u00acP "
  },
  {
    "output": "theorem imp_imp_contrapost (a b : Prop) : a \u2192 b \u2192 \u00ac b \u2192 \u00ac a "
  },
  {
    "output": "theorem contraposition (p q : Prop) : (p \u2192 q) \u2192 \u00ac q \u2192 \u00ac p "
  },
  {
    "output": "theorem contrapositive (P Q : Prop) (h : P \u2192 Q) : Q \u2192 P "
  },
  {
    "output": "theorem implies.contrapose{p q : Prop} (h\u2081 : implies p q) :\nimplies (not q) (not p) "
  },
  {
    "output": "theorem iff.elim_left{p q : Prop} (H : p \u2194 q) : q \u2192 p "
  },
  {
    "output": "theorem implies.contrapos{p q : Prop} (h : implies p q) :\nimplies (not q) (not p) "
  },
  {
    "output": "theorem implies.contrapos{p q : Prop} :\nimplies (implies p q) (implies (not q) (not p)) "
  },
  {
    "output": "theorem implies.contra{p q : Prop} (h : implies p q) :\nimplies (not q) (not p) "
  },
  {
    "output": "theorem imp_trans (P Q R : Prop) : P \u2192 Q \u2192 R \u2192 (P \u2192 Q) \u2192 P \u2192 R "
  },
  {
    "output": "theorem imp_trans (p q r : Prop) (h\u2081 : p \u2192 q) (h\u2082 : q \u2192 r) : p \u2192 r "
  },
  {
    "output": "theorem imp_trans ( a b c : Prop ) : a \u2192 b \u2192 c \u2192 a "
  },
  {
    "output": "theorem transit_of_impl : p \u2192 q \u2192 r \u2192 p \u2192 r "
  },
  {
    "output": "theorem stuff : \u2200 ( P Q R : Prop ), ( P \u2192 ( Q \u2192 R )) \u2192 ( P \u2227 Q \u2192 R ) "
  },
  {
    "output": "theorem mp (P Q R : Prop) (hpq : P \u2192 Q) (hqr : Q \u2192 R) : P \u2192 R "
  },
  {
    "output": "theorem trans_of_implies_of_implies (P Q R : Prop) (hPQ : P \u2192 Q) (hQR : Q \u2192 R) :\n P \u2192 R "
  },
  {
    "output": "theorem implies_trans (A B C : Prop) : (A \u2192 B) \u2192 (B \u2192 C) \u2192 A \u2192 C "
  },
  {
    "output": "theorem transitivity_of_implication (p q r : Prop) :\n (p \u2192 q) \u2192 (q \u2192 r) \u2192 (p \u2192 r)"
  },
  {
    "output": "theorem impif_trans (P Q R : Prop) : (P \u2192 Q) \u2192 (Q \u2192 R) \u2192 (P \u2192 R) "
  },
  {
    "output": "theorem mp{p q r : Prop} (h\u2081 : p \u2192 q) (h\u2082 : q \u2192 r) :\np \u2192 r "
  },
  {
    "output": "theorem implies.trans {p q r : Prop} (h\u2081 : p \u2192 q) (h\u2082 : q \u2192 r) :\np \u2192 r "
  },
  {
    "output": "theorem trans{\u03b1 \u03b2 \u03b3} (h\u2081 : \u03b1 \u2192 \u03b2) (h\u2082 : \u03b2 \u2192 \u03b3) :\n\u03b1 \u2192 \u03b3 "
  },
  {
    "output": "theorem trans (p q r : Prop) (hpq : p \u2192 q) (hqr : q \u2192 r) : p \u2192 r "
  },
  {
    "output": "theorem trans_rv_into_rv_of_rv {p q r : Prop} (pf\u2081 : implies p q) (pf\u2082 : implies q r) :\nimplies p r "
  },
  {
    "output": "theorem iff_true_of_true_true {P Q : Prop} (h1 : P) (h2 : Q) : P \u2227 Q "
  },
  {
    "output": "theorem implies_tofa ( P Q : Prop ) : P \u2192 Q \u2192 P \u2227 Q "
  },
  {
    "output": "theorem and_flip : \u2200{P Q : Prop}, P \u2192 Q \u2192 P \u2227 Q "
  },
  {
    "output": "theorem foo (P Q : Prop) : P \u2192 Q \u2192 P \u2227 Q "
  },
  {
    "output": "theorem and_of_two_true ( p : Prop ) ( q : Prop ) ( h : p \u2227 q ) : p "
  },
  {
    "output": "theorem true_and_true_is_true (P Q : Prop) (hP : P) (hQ : Q) : P \u2227 Q "
  },
  {
    "output": "theorem and_intro (p q : Prop) : p \u2227 q \u2192 p "
  },
  {
    "output": "theorem and_true_iff_true {P Q : Prop} (hP : P) (hQ : Q) :\n P \u2227 Q "
  },
  {
    "output": "theorem propositions_P_and_Q_are_individualy_true (P Q : Prop) (b1 : P) (b2 : Q) :\n P \u2227 Q "
  },
  {
    "output": "theorem and_true_intro (P Q : Prop) (HP : P) (HQ : Q) : P \u2227 Q "
  },
  {
    "output": "theorem and.intro{a b : Prop} (ha : a) (hb : b) :\n(a \u2227 b) "
  },
  {
    "output": "theorem and.intro{a b : Prop} (ha : a) (hb : b) :\na \u2227 b "
  },
  {
    "output": "theorem and.intro{a b : Prop} (h\u2081 : a) (h\u2082 : b) :\na \u2227 b "
  },
  {
    "output": "theorem and_true{p q : Prop} (hp : p) (hq : q) :\np \u2227 q "
  },
  {
    "output": "theorem not_and_distrib{a b : Prop} :\n\u00ac(a \u2227 b) \u2194 \u00aca \u2228 \u00acb "
  },
  {
    "output": "theorem and_comm (a b : Prop) : a \u2227 b \u2192 b \u2227 a "
  },
  {
    "output": "theorem and.comm (p q : Prop) : p \u2227 q \u2194 q \u2227 p "
  },
  {
    "output": "theorem ConjunctionCommutative : \u2200 p q, p \u2227 q \u2192 q \u2227 p "
  },
  {
    "output": "theorem and.comm : \u2200 a b : Prop, a \u2227 b \u2192 b \u2227 a "
  },
  {
    "output": "theorem myfirsttheorem : \u2200 (P Q R: Prop), \u27e8P \u2227 Q,  (P \u2227 Q) \u2227 R \u27e9 -> \u27e8P \u2227 Q,  Q \u2227 P \u27e9 "
  },
  {
    "output": "theorem conjunction_commutative (P Q : Prop) : P \u2227 Q \u2194 Q \u2227 P "
  },
  {
    "output": "theorem and.comm (a b : Prop) : a \u2227 b \u2194 b \u2227 a "
  },
  {
    "output": "theorem and_comm (p q : Prop) : p \u2227 q \u2194 q \u2227 p  "
  },
  {
    "output": "theorem and_comm (p q : Prop) : p \u2227 q \u2194 q \u2227 p "
  },
  {
    "output": "theorem and_comm (b1 b2 : bool) :\n b1 \u2227 b2 = b2 \u2227 b1 "
  },
  {
    "output": "theorem and_comm{a b : Prop} :\na \u2227 b \u2194 b \u2227 a "
  },
  {
    "output": "theorem and_comm{a b : Prop} : a \u2227 b \u2194 b \u2227 a "
  },
  {
    "output": "theorem and.comm{a b : Prop} :\na \u2227 b \u2194 b \u2227 a "
  },
  {
    "output": "theorem and_comm{a b : Prop} :\na \u2227 b \u2194 b \u2227 a "
  },
  {
    "output": "theorem and_comm{a b : Prop} :\na \u2227 b \u2194 b \u2227 a "
  },
  {
    "output": "theorem conj_assoc : \u2200 { \ud835\udc9c : Prop } { \ud835\udc9e : Prop } { \ud835\udc9f : Prop },\n    (\ud835\udc9c \u2227 \ud835\udc9e) \u2227 \ud835\udc9f \u2194 \ud835\udc9c \u2227 (\ud835\udc9e \u2227 \ud835\udc9f) "
  },
  {
    "output": "theorem and_assoc :\n    \u2200 ( (a b c : Prop), a \u2227 (b \u2227 c) \u2194 (a \u2227 b) \u2227 c "
  },
  {
    "output": "theorem conj.assoc : \u2200 {a b c : Prop}, a \u2227 (b \u2227 c) \u2194 (a \u2227 b) \u2227 c "
  },
  {
    "output": "theorem and.assoc : \u2200 p q r: Prop, p \u2227 (q \u2227 r) \u27f9 (p \u2227 q) \u2227 r "
  },
  {
    "output": "theorem left_associativity_conjunction (p q r : Prop) : (p \u2227 q) \u2227 r \u27f9 p \u2227 (q \u2227 r) "
  },
  {
    "output": "theorem and.assoc (a b c : Prop) : a \u2227 b \u2227 c \u2194 a \u2227 (b \u2227 c) "
  },
  {
    "output": "theorem and.assoc (p q r : Prop) : (p \u2227 q \u2227 r) \u2194 (p \u2227 (q \u2227 r)) "
  },
  {
    "output": "theorem and_assoc : \u2200 (P Q R : Prop), P \u2227 Q \u2227 R \u2194 P \u2227 (Q \u2227 R) "
  },
  {
    "output": "theorem and.assoc : \u2200 (a b c : Prop), a \u2227 (b \u2227 c) \u2194 (a \u2227 b) \u2227 c "
  },
  {
    "output": "theorem and_assoc (a b c : Prop) : a \u2227 (b \u2227 c) \u2194 (a \u2227 b) \u2227 c "
  },
  {
    "output": "theorem and_assoc{a b c : Prop} :\n(a \u2227 b) \u2227 c \u2194 a \u2227 (b \u2227 c) "
  },
  {
    "output": "theorem and_assoc{a b c : Prop} :\n(a \u2227 b) \u2227 c \u2194 a \u2227 (b \u2227 c) "
  },
  {
    "output": "theorem and_associative{a b c : Prop} :\na \u2227 b \u2227 c \u2194 a \u2227 (b \u2227 c) "
  },
  {
    "output": "theorem and_assoc {a b c : Prop} :\na \u2227 b \u2227 c \u2194 a \u2227 (b \u2227 c) "
  },
  {
    "output": "theorem and_assoc{a b c : Prop} : (a \u2227 b) \u2227 c \u2194 a \u2227 b \u2227 c "
  },
  {
    "output": "theorem disjunction_is_commutative ( A : Prop ) ( B : Prop ) : ( A \u2228 B ) \u2192 ( B \u2228 A ) "
  },
  {
    "output": "theorem and.left.comm (a b c : Prop) : a \u2227 b \u2227 c \u2192 b \u2227 a \u2227 c "
  },
  {
    "output": "theorem disjunction_is_commutative : \u2200 ( P Q : Prop ), ( P \u2228 Q ) \u2194 ( Q \u2228 P ) "
  },
  {
    "output": "theorem prop_of_commutative_disjunction ( a b : Prop ) : ( a \u2228 b ) \u2194 ( b \u2228 a ) "
  },
  {
    "output": "theorem disjunction_commutative : \u2200 a b : Prop, a \u2228 b \u2192 b \u2228 a "
  },
  {
    "output": "theorem or_comm (P Q : Prop) : P \u2228 Q \u2194 Q \u2228 P "
  },
  {
    "output": "theorem exists_comm (A : Type*) (P Q: A \u2192 Prop):\n  (\u2203 x, P x \u2228 Q x) \u2194 (\u2203 x, Q x \u2228 P x) "
  },
  {
    "output": "theorem disjunction_commuative (p q : Prop) :\n p \u2228  q \u2194 q \u2228 p "
  },
  {
    "output": "theorem disjunction_comm (p q : Prop) : (p \u2228 q) \u2194 (q \u2228 p) "
  },
  {
    "output": "theorem disjunction_is_commutative (p q : Prop) : p \u2228 q \u2194 q \u2228 p "
  },
  {
    "output": "theorem or_comm{a b: Prop} :\na \u2228 b \u2194 b \u2228 a "
  },
  {
    "output": "theorem or_comm{a b : Prop} :\na \u2228 b \u2194 b \u2228 a "
  },
  {
    "output": "theorem or_comm{a b : Prop} :\na \u2228 b \u2194 b \u2228 a "
  },
  {
    "output": "theorem or_comm{a b : Prop} :\na \u2228 b \u2194 b \u2228 a "
  },
  {
    "output": "theorem or_comm{a b : Prop} :\na \u2228 b \u2194 b \u2228 a "
  },
  {
    "output": "theorem disjunction_associative: (a \u2228 b) \u2228 c \u2192 a \u2228 (b \u2228 c) "
  },
  {
    "output": "theorem disjunction_is_assoc :\n   \u2200 (p q r : Prop), p \u2228 (q \u2228 r) \u2192 (p \u2228 q) \u2228 r "
  },
  {
    "output": "theorem disjunction_is_associative "
  },
  {
    "output": "theorem disj_assoc (a b c : Prop) : a \u2228 (b \u2228 c) \u2194 (a \u2228 b) \u2228 c "
  },
  {
    "output": "theorem and_assoc : \u2200 a b c : Prop, (a \u2227 b) \u2227 c \u2194 a \u2227 (b \u2227 c) "
  },
  {
    "output": "theorem or_assoc (P Q R : Prop) :\n P \u2228 (Q \u2228 R) \u2194 (P \u2228 Q) \u2228 R "
  },
  {
    "output": "theorem or_comm (x y : Prop) : x \u2228 y \u2194 y \u2228 x "
  },
  {
    "output": "theorem or_assoc (P Q R : Prop) : (P \u2228 Q) \u2228 R \u2194 P \u2228 (Q \u2228 R) "
  },
  {
    "output": "theorem or_assoc (P Q R : Prop) :\n P \u2228 (Q \u2228 R) \u2194 (P \u2228 Q) \u2228 R "
  },
  {
    "output": "theorem or.assoc (a b c : Prop) : a \u2228 (b \u2228 c) \u2194 (a \u2228 b) \u2228 c "
  },
  {
    "output": "theorem or_assoc{a b c : Prop} :\n(a \u2228 b) \u2228 c \u2194 a \u2228 (b \u2228 c) "
  },
  {
    "output": "theorem or_assoc{a b c : Prop} :\n(a \u2228 b) \u2228 c \u2194 a \u2228 (b \u2228 c) "
  },
  {
    "output": "theorem or_assoc{a b c : Prop} :\n(a \u2228 b) \u2228 c \u2194 a \u2228 (b \u2228 c) "
  },
  {
    "output": "theorem or_assoc{a b c : Prop} :\na \u2228 b \u2228 c \u2194 (a \u2228 b) \u2228 c "
  },
  {
    "output": "theorem or_assoc{a b c : Prop} :\na \u2228 b \u2228 c \u2194 a \u2228 c \u2228 b "
  },
  {
    "output": "theorem and_not_self_implies_false : \u2200 p : Prop, p \u2227 \u00ac p \u2192 false "
  },
  {
    "output": "theorem true_or_P_of_true_implies_true_or_Q ( ht : true ) ( hp : true ) ( hq : false ) : true "
  },
  {
    "output": "theorem P_or_Q:  \u2200 P Q:Prop,P \u2192 P \u2228 Q "
  },
  {
    "output": "theorem disj ( P Q : Prop ) ( hP : P ) : P \u2228 Q "
  },
  {
    "output": "theorem examples . disj_imp_of_tru P Q : ( P \u2194 true ) \u2192 ( P \u2228 Q \u2194 true ) "
  },
  {
    "output": "theorem disjunction_of_true_is_true (P Q : Prop) (hP : P) : P \u2228 Q "
  },
  {
    "output": "theorem true_or (P Q : Prop) (p : P) : P \u2228 Q "
  },
  {
    "output": "theorem true_or_Q_is_true (P Q : Prop) (HP : P) :\n P \u2228 Q "
  },
  {
    "output": "theorem em (P Q : Prop) (h : P) : P \u2228 Q "
  },
  {
    "output": "theorem or_two_cases_p_true (P Q : Prop) : P \u2192 (P \u2228 Q) "
  },
  {
    "output": "theorem left_mem_right{P Q : Prop} (a : P)  : P \u2228 Q "
  },
  {
    "output": "theorem true_or{a b : Prop} :\ntrue \u2192 a \u2228 b "
  },
  {
    "output": "theorem or_of_true{P Q: Prop} (H : P) :\nP \u2228 Q "
  },
  {
    "output": "theorem dvd_true_intro{p : Prop} (h : p):\np \u2228 p "
  },
  {
    "output": "theorem true_or{P Q : Prop} (hP : P) : P \u2228 Q "
  },
  {
    "output": "theorem disjunction :\n \u2200 (P Q : Prop), Q \u2192 (P \u2228 Q) "
  },
  {
    "output": "theorem true_is_true_disj : \u2200 (P Q : Prop), Q \u2192 (P \u2228 Q) "
  },
  {
    "output": "theorem foo ( P Q : Prop) : Q -> *P \\/ Q* "
  },
  {
    "output": "theorem implication_disjunction : \u2200 (P Q:Prop), (Q \u2192 (P \u2228 Q)) "
  },
  {
    "output": "theorem mylemma : \u2200 P Q: Prop, (Q \u2192 (P \u2228 Q)) "
  },
  {
    "output": "theorem disjunction_true_of_true (m n : Prop) (hm : m) :\n m \u2228 n "
  },
  {
    "output": "theorem prop.and_of_true_right  (P Q : Prop) (h : Q) :\n P \u2228 Q "
  },
  {
    "output": "theorem disj_of_true (P Q : Prop) (hQ : Q) : P \u2228 Q "
  },
  {
    "output": "theorem true_or (P Q : Prop) (hq : Q) : P \u2228 Q "
  },
  {
    "output": "theorem true_disjunction_from_true (P Q : Prop) (hQ : Q) :\n P \u2228 Q "
  },
  {
    "output": "theorem true_or{P Q : Prop} (H : Q) :\nP \u2228 Q "
  },
  {
    "output": "theorem false_or{a : Prop} :\nfalse \u2228 a \u2194 a "
  },
  {
    "output": "theorem true_or{P Q : Prop} (h : Q) : P \u2228 Q "
  },
  {
    "output": "theorem or_true{P Q : Prop} (h : Q) :\nP \u2228 Q "
  },
  {
    "output": "theorem true_or{a b : Prop} (h : b) :\na \u2228 b "
  },
  {
    "output": "theorem t : (P \u2227 Q) \u2228 R \u2192 (P \u2228 R) \u2227 (Q \u2228 R) "
  },
  {
    "output": "theorem and_distrib_of_or_left ( P Q R : Prop ) : ( P \u2228 Q ) \u2227 R \u2192 P \u2227 R \u2228 Q \u2227 R "
  },
  {
    "output": "theorem Disj_SD (hc : (c \u2228 a) \u2227 (c \u2228 b)): c \u2228 (a \u2227 b) "
  },
  {
    "output": "theorem my_theorem : (a \u2227 b) \u2228 c \u2194 (a \u2228 c) \u2227 (b \u2228 c) "
  },
  {
    "output": "theorem left_distributes_over_lor (p q r : Prop) :\n p \u2228 (q \u2227 r) \u2194 (p \u2228 q) \u2227 (p \u2228 r) "
  },
  {
    "output": "theorem and_or_distrib_left (P Q R : Prop) :\n(P \u2227 (Q \u2228 R)) \u2194 ((P \u2227 Q) \u2228 (P \u2227 R)) "
  },
  {
    "output": "theorem and_distributes_over_or (p q r : Prop) :\n p \u2227 (q \u2228 r) \u2194 (p \u2227 q) \u2228 (p \u2227 r) "
  },
  {
    "output": "theorem distrib_or_of_and.left (p q r : Prop) :\n (p \u2227 q) \u2228 r \u2194 (p \u2228 r) \u2227 (q \u2228 r) "
  },
  {
    "output": "theorem left_distribute_and_over_or (p q r : Prop) :\n p \u2227 (q \u2228 r) \u2194 (p \u2227 q) \u2228 (p \u2227 r) "
  },
  {
    "output": "theorem distribution.left (P Q R : Prop) : (P \u2227 (Q \u2228 R)) \u2194 ((P \u2227 Q) \u2228 (P \u2227 R)) "
  },
  {
    "output": "theorem or_of_and_left{a b c : Prop} :\na \u2227 b \u2194 c \u2192 a \u2228 b "
  },
  {
    "output": "theorem and_distrib_over_or{a b c : Prop} :\na \u2227 b \u2228 a \u2227 c \u2194 a \u2227 b \u2228 c "
  },
  {
    "output": "theorem and_or_distrib{a b c : Prop} :\n(a \u2227 b) \u2228 c \u2194 (a \u2228 c) \u2227 (b \u2228 c) "
  },
  {
    "output": "theorem and_or_distrib{a b c : Prop} :\na \u2227 (b \u2228 c) \u2194 (a \u2227 b) \u2228 (a \u2227 c) "
  },
  {
    "output": "theorem or_distrib_and{a b c d : Prop} :\n(a \u2227 b) \u2228 (c \u2227 d) \u2194 (a \u2228 c) \u2227 (a \u2228 d) \u2227 (b \u2228 c) \u2227 (b \u2228 d) "
  },
  {
    "output": "theorem dne { X Y Z: Type }\n            [ dis_prop : negated_distributive_lattice X ]\n            ( a : X ) ( b : Y ) ( c : Z ): a \u2227 ( b \u2228 c ) \u2192 ( a \u2227 b ) \u2228 ( a \u2227 c ) "
  },
  {
    "output": "theorem nl1: (P \u2227 Q) \u2228 R \u2194 (P \u2228 R) \u2227 (Q \u2228 R) "
  },
  {
    "output": "theorem conj_or : (p \u2227 q) \u2228 (p \u2227 \u00acq) "
  },
  {
    "output": "theorem and_or_distrib_right (a b c : Prop) : a \u2227 (b \u2228 c) \u2192 (a \u2227 b) \u2228 (a \u2227 c) "
  },
  {
    "output": "theorem conf_dist_eq' : (p \u2227 q) \u2228 r \u2194 p \u2227 q \u2228 r "
  },
  {
    "output": "theorem conj_distrib_right (p q r : Prop) :\n(p \u2227 (q \u2228 r)) \u2194 ((p \u2227 q) \u2228 (p \u2227 r)) "
  },
  {
    "output": "theorem and_distrib_right (a b c : Prop) : a \u2227 (b \u2228 c) \u2194 (a \u2227 b) \u2228 (a \u2227 c) "
  },
  {
    "output": "theorem imp_and_distrib : \u2200 P Q R : Prop, (P \u2192 Q \u2227 R) \u2194 (P \u2192 Q) \u2227 (P \u2192 R) "
  },
  {
    "output": "theorem right_conj_distr_to_disj (P Q R : Prop) :\n P \u2227 (Q \u2228 R) \u2194 (P \u2227 Q) \u2228 (P \u2227 R)\n\nNatural language version: \"Conjunction left-distributes over disjunction.\" Translate the natural language version to a Lean mathlib version:\n theorem left_conj_distr_to_disj (P Q R : Prop) :\n (P \u2228 Q) \u2227 R \u2194 (P \u2227 R) \u2228 (Q \u2227 R)\n\nNatural language version: \"Conjunction right-distributes over implication.\" Translate the natural language version to"
  },
  {
    "output": "theorem conjunction_right_distributes_over_disjunction (p q r : Prop) :\n(p \u2227 (q \u2228 r)) \u2194 ((p \u2227 q) \u2228 (p \u2227 r)) "
  },
  {
    "output": "theorem right_distributive{a b c : Prop} :\na \u2228 b \u2227 c \u2194 (a \u2228 b) \u2227 (a \u2228 c) "
  },
  {
    "output": "theorem distrib {p q r : Prop} (hp : p) :\n(p \u2227 q) \u2228 r \u2194 (p \u2228 r) \u2227 (q \u2228 r) "
  },
  {
    "output": "theorem distrib_right{a b c : Prop} : (a \u2228 b) \u2228 c \u2194 a \u2228 (b \u2228 c) "
  },
  {
    "output": "theorem or_and_distrib {a b c : Prop} :\na \u2228 b \u2227 c \u2194 a \u2228 (b \u2227 c) "
  },
  {
    "output": "theorem conj_distrib{a b c : Prop} :\n(a \u2228 b) \u2192 c \u2194 (a \u2192 c) \u2227 (b \u2192 c) "
  },
  {
    "output": "theorem disj_distrib_of_conj :\n   \u2200 (P Q R : Prop), (P \u2228 Q) \u2227 R \u2194 (P \u2227 R) \u2228 (Q \u2227 R) "
  },
  {
    "output": "theorem disjunction_distributes_over_conjunction : \u2200 { A B C : Prop },   A \u2227 ( B \u2228 C ) \u2192 ( A \u2227 B ) \u2228 ( A \u2227 C ) "
  },
  {
    "output": "theorem disjl_or_of_disjl {a b c: Prop}: (a \u2228 b) \u2227 c \u2192 (a \u2228 c) \u2227 (b \u2228 c) "
  },
  {
    "output": "theorem plays_soccer(x) : \u2203 y : baseball, plays_baseball(y) \u2227 plays_soccer(x)\n    "
  },
  {
    "output": "theorem dld :  \u2200 p q r: Prop, p \u2228 (q \u2227 r) \u2194 (p \u2228 q) \u2227 (p \u2228 r) "
  },
  {
    "output": "theorem or_left_distrib (p q r : Prop) :\n p \u2228 (q \u2227 r) \u2194 (p \u2228 q) \u2227 (p \u2228 r) "
  },
  {
    "output": "theorem or_and_distrib_left (p q r : Prop) :\n (p \u2228 q) \u2227 r \u2194 (p \u2227 r) \u2228 (q \u2227 r) "
  },
  {
    "output": "theorem or_and_distrib_left (P Q R : Prop) :\n P \u2228 (Q \u2227 R) \u2194 (P \u2228 Q) \u2227 (P \u2228 R) "
  },
  {
    "output": "theorem disjoint_and_left_distrib (a b c : Prop) : (a \u2228 b) \u2227 c \u2194 (a \u2227 c) \u2228 (b \u2227 c) "
  },
  {
    "output": "theorem left_distributivity_over_conjunction (A B C : Prop) : A \u2228 (B \u2227 C) \u2194 (A \u2228 B) \u2227 (A \u2228 C) "
  },
  {
    "output": "theorem or_distrib_and_left{a b c: Prop} : a \u2228 (b \u2227 c) \u2194 (a \u2228 b) \u2227 (a \u2228 c) "
  },
  {
    "output": "theorem disj_and_distrib{a b c :Prop} :\n(a \u2228 b) \u2227 c \u2194 a \u2227 c \u2228 b \u2227 c "
  },
  {
    "output": "theorem or_distrib_left{a b c : Prop} :\n(a \u2228 b) \u2227 (a \u2228 c) \u2192 a \u2228 (b \u2227 c) "
  },
  {
    "output": "theorem and_or_distrib{a b c : Prop} :\na \u2227 (b \u2228 c) \u2194 (a \u2227 b) \u2228 (a \u2227 c)\n "
  },
  {
    "output": "theorem disj_left_distrib{a b c : Prop} :\na \u2228 (b \u2227 c) \u2194 a \u2228 b \u2227 a \u2228 c "
  },
  {
    "output": "theorem or_dist_of_and {b\u2081 b\u2082 c : Prop} (h\u2081 : b\u2081 \u2227 c) (h\u2082 : b\u2082 \u2227 c) : (b\u2081 \u2228 b\u2082) \u2227 c "
  },
  {
    "output": "theorem my_theorem :  (\u2203 x, P x \u2228 Q x) \u2194 ((\u2203 x, P x) \u2228 (\u2203 x, Q x)) "
  },
  {
    "output": "theorem disjunction_distributes_over_conjunction (p q r : P) :\n  p \u2228 (q \u2227 r) \u2194 (p \u2228 q) \u2227 (p \u2228 r) "
  },
  {
    "output": "theorem proof_mathlib_1: \u2200 P Q R: Prop, \u2200 P Q R: Prop, (P \u2227 Q) \u2228 (Q \u2227 R) \u2194 (P \u2227 Q) \u2228 (P \u2203 R) "
  },
  {
    "output": "theorem or_dist_and_over_or (a b c : Prop) : (a \u2228 (b \u2227 c)) = ((a \u2228 b) \u2227 (a \u2228 c))."
  },
  {
    "output": "theorem or_distributes_over_and : \u2200 (P Q R : Prop), P \u2228 (Q \u2227 R) \u2194 (P \u2228 Q) \u2227 (P \u2228 R) "
  },
  {
    "output": "theorem not_not_iff (p : Prop) : \u00ac\u00acp \u2194 p "
  },
  {
    "output": "theorem or_and_distrib_left (p q r : Prop) :\n p \u2228 (q \u2227 r) \u2194 (p \u2228 q) \u2227 (p \u2228 r)\n "
  },
  {
    "output": "theorem adjunction_d_c (X : Type*) (F G : X \u2192 Prop) : (F \u2228 G) \u2194 (F \u2192 G) "
  },
  {
    "output": "theorem or_right_distributes_over_and (x y z : Prop) :\n (x \u2228 y) \u2227 (x \u2228 z) \u2194 (x \u2228 (y \u2227 z)) "
  },
  {
    "output": "theorem or_distrib_over_and{a b c : Prop} : a \u2228 b \u2227 c \u2194 (a \u2228 b) \u2227 (a \u2228 c) "
  },
  {
    "output": "theorem disj_right_distrib{a b c : Prop} :\na \u2228 (b \u2227 c) \u2194 (a \u2228 b) \u2227 (a \u2228 c) "
  },
  {
    "output": "theorem distrib{X Y Z : Prop} :\n(X \u2227 Y) \u2228 Z \u2194 X \u2227 (Y \u2228 Z) "
  },
  {
    "output": "theorem and_or_distrib_both{a b c : Prop} :\na \u2227 b \u2228 a \u2227 c \u2194 a \u2227 (b \u2228 c) "
  },
  {
    "output": "theorem or_distrib{a b c : Prop} :\na \u2228 (b \u2227 c) \u2194 (a \u2228 b) \u2227 (a \u2228 c) "
  },
  {
    "output": "theorem false_or ( p : Prop ) : false \u2228 p "
  },
  {
    "output": "theorem left_identity_or : false \u2228 A \u2192 A "
  },
  {
    "output": "theorem false_or_left_identity ( x : bool ) : false \u2228 x = x "
  },
  {
    "output": "theorem left_id_false : \u2200 (p: Prop), ff \u2228 p \u2194 p "
  },
  {
    "output": "theorem zero_add : 0 + a = a "
  },
  {
    "output": "theorem some_false_disjunction_lemmas (p q : Prop) :\n (false \u2228 p) \u2194 p "
  },
  {
    "output": "theorem left_id_false_disj:\n \u2200 P : Prop, false \u2228 P \u2192 P "
  },
  {
    "output": "theorem false_left_identity_of_or (C D : Prop) : false \u2228 C \u2194 C "
  },
  {
    "output": "theorem false_disjunction_left_identity (a : Prop) :\n false \u2228 a \u2194 a "
  },
  {
    "output": "theorem false_left_identity : \u2200 q : Prop, false \u2228 q \u2192 q "
  },
  {
    "output": "theorem or_false_left{a : Prop} :\nfalse \u2228 a \u2194 a "
  },
  {
    "output": "theorem false_or{a : Prop}:\nfalse \u2228 a <-> a "
  },
  {
    "output": "theorem or_false_left{a : Prop} :\nfalse \u2228 a \u2194 a "
  },
  {
    "output": "theorem false_or_right{a : Prop} :\nFalse \u2228 a \u2194 a "
  },
  {
    "output": "theorem or_false_left{p : Prop} :\nFalse \u2228 p \u2194 p "
  },
  {
    "output": "theorem right_id : \u2200 P : Prop , P \u2228 false \u2192 P "
  },
  {
    "output": "theorem false_or (a : Prop) : false \u2228 a "
  },
  {
    "output": "theorem IdRight ( p : Prop ) : p \u2228 False \u2194 p "
  },
  {
    "output": "theorem and_empty_is_left_id : \u2200 a , ( a \u2227 \u22a5 : Prop ) \u2194 a "
  },
  {
    "output": "theorem False_or_self (p : Prop) : false \u2228 p \u2194 p\n\nProof:\nThe natural language version is essentially to be proved \"if false \u2228 p then p\". In the code below this is done by showing that if false then p, and if p then p. This is the commutative law for or statements. The prove function uses the premise, which is the if statement. The have function is used to introduce fake terms used for the proof to 'prove' real terms.\n\n\n*)\n\n-- False \u2228 P \u2194 P\n  theorem False_or_self {P : Prop} : false \u2228 P \u2194 P "
  },
  {
    "output": "theorem false_is_disjunction_right_identity : \u2200 p : Prop, p \u2228 false \u2194 p "
  },
  {
    "output": "theorem false_disjunction_right_id (P : Prop) : P \u2228 False \u2192 P "
  },
  {
    "output": "theorem fasle_is_right_identity_of_or (a : Prop) : a \u2228 False \u2194 a "
  },
  {
    "output": "theorem false_right_identity (p : Prop) :\nfalse \u2228 p \u2194 p "
  },
  {
    "output": "theorem disj_false_right (P : Prop):\n   P \u2295 False \u2194 P "
  },
  {
    "output": "theorem false_or{a : Prop} :\nFalse \u2228 a \u2194 a "
  },
  {
    "output": "theorem false_or_elim {a: Prop} : \n a \u2228 False \u2194 a "
  },
  {
    "output": "theorem or_false_right{a : Prop} :\na \u2228 false \u2194 a "
  },
  {
    "output": "theorem or_false{a : Prop} :\na \u2228 False \u2194 a "
  },
  {
    "output": "theorem false_or_distrib_right{a : Prop} :\na \u2228 false \u2194 a "
  },
  {
    "output": "theorem id_left : left_id true and "
  },
  {
    "output": "theorem mul_one_eq_one : 1 * (1 : mynat) = 1 "
  },
  {
    "output": "theorem example8 (T : Prop) : (T \u2227 T = T) \u2227 (T \u2227 T = T) "
  },
  {
    "output": "theorem and.left_id_iff :\u2200 {p b: Prop}, (p \u2227 b) \u2194 p\n\n-- abbreviated version: \u2200{p b}, (p\u2227b)\u2194p\n\n#check @and.left_id_iff\n\n#print and.left_id_iff\n\n/- \nThe environment at the point where the automatically generated identifier \nand.left_id_iff or its printed form occurs, is built up according to the \nfollowing rules of precedence:\n1. Names of parameters declared in the mathlib version.\n2. Names of arguments in the printed form.\n3. Names of parameters declared in the mathlib version"
  },
  {
    "output": "theorem true_and_left_id : \u2200 (p : Prop), true \u2227 p \u2194 p "
  },
  {
    "output": "theorem left_id (P Q : Prop) :\nTrue \u2227 P \u2194 P "
  },
  {
    "output": "theorem true_and_left_identity (a : Prop) : true \u2227 a \u2194 a "
  },
  {
    "output": "theorem left_identity_and (p : Prop) : True \u2227 p \u2194 p "
  },
  {
    "output": "theorem left_identity_conjunction (P Q : Prop) :\n  True \u2227 P \u2194 P "
  },
  {
    "output": "theorem land_true_intro (P : Prop) : true && P \u2192 P "
  },
  {
    "output": "theorem and_true{a : Prop} :\na \u2227 True \u2194 a "
  },
  {
    "output": "theorem true_and{a : Prop} :\nTrue \u2227 a \u2194 a "
  },
  {
    "output": "theorem and_true_left {A : Prop} : A \u2192 A \u2227 true "
  },
  {
    "output": "theorem and_true{a : Prop} :\na \u2227 true \u2194 a "
  },
  {
    "output": "theorem true_and{a : Prop} :\ntrue \u2227 a \u2194 a "
  },
  {
    "output": "theorem cond_and_true (c : Prop) : c \u2227 true = c "
  },
  {
    "output": "theorem True_right_id : \u2200 a, a \u2227 True \u2194 a "
  },
  {
    "output": "theorem my_thm_two ( P Q : Prop ) : ( P /\\ Q "
  },
  {
    "output": "theorem identity_conj ( P : Prop ) : true && P = P "
  },
  {
    "output": "theorem true_is_right_identity_for_and : \u2200 b : Prop, b \u2227 true \u2194 b "
  },
  {
    "output": "theorem bool.true_conj (a : bool) : a && true  = a "
  },
  {
    "output": "theorem True_conj_right_identity : True \u2227 P \u2194 P "
  },
  {
    "output": "theorem right_true_conjunction (x : Prop) : x \u2227 true \u2194 x "
  },
  {
    "output": "theorem right_true_of_and (P : Prop) : P \u2227 true \u2194 P "
  },
  {
    "output": "theorem true_is_right_identity_for_and (P : Prop) : P \u2227 true \u2194 P "
  },
  {
    "output": "theorem true_prop_and_right : \u2200 (p : Prop), p \u2227 True \u2194 p"
  },
  {
    "output": "theorem and_true_right{a : Prop} : a \u2227 true \u2194 a "
  },
  {
    "output": "theorem and_true{a : Prop} : \na \u2227 True \u2194 a "
  },
  {
    "output": "theorem True_is_right_identity : \u2200 a : Prop, a \u2227 true \u2194 a "
  },
  {
    "output": "theorem true_and_is_right_id {a : Prop} : a \u2227 true \u2194 a "
  },
  {
    "output": "theorem x: true = false \u2228 true -> P "
  },
  {
    "output": "theorem left_ann_or : true \u2228 false = true "
  },
  {
    "output": "theorem true_is_left_annihilator_of_or : \u2200 (x : Prop), true \u2228 x \u2194 x "
  },
  {
    "output": "theorem left_ann_of_empty_left_ann (b:bool): 0 \u2228 b = b "
  },
  {
    "output": "theorem left_prop_annihilator ( P Q : Prop ) : P \u2227 ( \u00ac P \u2228 Q ) \u2194 Q "
  },
  {
    "output": "theorem true_annihilates_disjunction :\n \u2200 (P Q : Prop), (P \u2228 Q) \u2192 True "
  },
  {
    "output": "theorem true_disj_intro {P Q : Prop} [decidable Q] : P \u2228 Q \u2192 P \u2228 true "
  },
  {
    "output": "theorem True_disjunction_left_annihilator (p q : Prop) :\n true \u2228 p \u2192 p "
  },
  {
    "output": "theorem and_true_annihilates_disjunction (p q : Prop) :\n (true \u2227 p) \u2228 q \u2194 q "
  },
  {
    "output": "theorem true.is_left_annihilator_of_disjunction :\n \u2200 b : Prop, true \u2227 (\u03b5 b \u2228 \u03bb h\u2081 h\u2082, true.rec true b) = \u03b5 b "
  },
  {
    "output": "theorem true_or_of_r{a : Prop} :\na \u2192 true \u2228 a "
  },
  {
    "output": "theorem true_or{a : Prop} : True \u2228 a \u2194 True "
  },
  {
    "output": "theorem true_or_a{a : Prop} :\ntrue \u2228 a "
  },
  {
    "output": "theorem true_or_left{a : Prop} :\ntrue \u2228 a \u2194 true "
  },
  {
    "output": "theorem true_or_left{a : Prop} :\ntrue \u2228 a \u2194 a "
  },
  {
    "output": "theorem be (a : Prop) : a \u2228 true \u2192 a "
  },
  {
    "output": "theorem true_is_right_ann : \u2200 ( P : Prop ), true \u2228 P \u2194 \u00ac P \u27f7 false "
  },
  {
    "output": "theorem is_right_ann ( a : Prop ) [ h : decidable a ] : is_right_ann a ( P \u2228 Q ) "
  },
  {
    "output": "theorem true_r_ann : is_r_ann h1 true "
  },
  {
    "output": "theorem prop_true_is_right_annihilator_for_disjunction : ( \u2200 ( P : Prop ), P \u2228 True \u2192 P ) "
  },
  {
    "output": "theorem true_right_annihilator (a b : Prop) :\n a \u2228 b \u2192 true "
  },
  {
    "output": "theorem true_disj_ann (p q : Prop) : true \u2227 p \u2228 q \u2192 p \u2228 q "
  },
  {
    "output": "theorem trivial_is_right_annihilator_of_disjunction :\n \u2200 p q : Prop, p \u2228 q \u2192 True \u2228 q "
  },
  {
    "output": "theorem True_is_right_annihilator_of_disjunction :\n right_annihilator (\u2228) "
  },
  {
    "output": "theorem true_disjunction_right_annihilator (p q : Prop) : p \u2227 true \u2192 q \u2228 true \u2192 q \u2228 p "
  },
  {
    "output": "theorem or_True{a : Prop} :\na \u2228 True \u2194 True "
  },
  {
    "output": "theorem true_or{a : Prop} :\ntrue \u2228 a \u2194 true "
  },
  {
    "output": "theorem or_true_right{a : Prop} :\na \u2228 True \u2194 True "
  },
  {
    "output": "theorem right_annihilator_true{a : Prop} :\na \u2228 true \u2194 true "
  },
  {
    "output": "theorem true_or{a : Prop} :\na \u2228 true "
  },
  {
    "output": "theorem false_and_is_left_annihilator ( p : Prop ) : \u00ac ( false \u2227 p ) "
  },
  {
    "output": "theorem left_ann_false_and : (\u03bb a b, a \u2227 b \u2194 false) = \u03bb a b, a \u2194 false "
  },
  {
    "output": "theorem not_and_left_annihilator : \u2200  a b : Prop, \u00ac (a \u2227 b) "
  },
  {
    "output": "theorem : \u2200 A B, \u00ac (A \u2227 B) = (\u00acA) \u2227 (\u00acB) "
  },
  {
    "output": "theorem not_left_and_ann : not_left_and_ann h\u2080 h\u2081 "
  },
  {
    "output": "theorem left_annihilator_false_and (P Q : Prop) : false \u2227 P \u2192 false "
  },
  {
    "output": "theorem false_left_annihilator_of_and (P Q : Prop) : P \u2227 Q \u2192 False "
  },
  {
    "output": "theorem left_annihilator_and_false :\n left_annihilator (\u2227) false "
  },
  {
    "output": "theorem False_is_left_annihilator_for_and : left_annihilator (\u2227) (\u03bb _ _, False) "
  },
  {
    "output": "theorem false_is_left_annihilator_of_and (p q) : false \u2227 p = false "
  },
  {
    "output": "theorem false_and_iff{a b : Prop} :\nfalse \u2227 a \u2194 false "
  },
  {
    "output": "theorem false_and_comm{a b : Prop} :\nfalse \u2227 a \u2194 false \u2227 b "
  },
  {
    "output": "theorem and.left_false{a b : Prop} :\nfalse \u2227 a \u2194 false "
  },
  {
    "output": "theorem false_and_iff{a : Prop} :\nfalse \u2227 a \u2194 false "
  },
  {
    "output": "theorem or_False{a b : Prop} :\na \u2228 False \u2194 a "
  },
  {
    "output": "theorem not_conj { p q : Prop } : p \u2227 \u00ac p \u2192 q "
  },
  {
    "output": "theorem right_conj_annihilator : ( false ) \u2227 ( P ) = ( false ) "
  },
  {
    "output": "theorem nat_false_and_eq_left (a : Prop) : false && a = false "
  },
  {
    "output": "theorem about_false {p q : Prop} (hp : p) (hq : q) : p \u2227 q \u2227 false "
  },
  {
    "output": "theorem conj_left_ann_false : \u2200 p q : Prop, p \u2227 (false : Prop) \u2194 false "
  },
  {
    "output": "theorem false_is_right_annihilator_of_and (x y : Prop) :\nfalse \u2227 x \u2192 y "
  },
  {
    "output": "theorem false_and_right_annil (A : Prop) :\n   A \u2227 \u22a5 \u2192 \u22a5 "
  },
  {
    "output": "theorem false_right_annihilator (h1 h2 : false) :\n h1 \u2227 h2 "
  },
  {
    "output": "theorem false_conj (P Q : Prop) : False \u2227 P \u2192 False "
  },
  {
    "output": "theorem and_false_is_a_right_annihilator (a b : Prop) :\n a \u2227 false \u2194 false "
  },
  {
    "output": "theorem ff_r_conj(P Q : Prop) :\nQ \u2227 False \u2192 False "
  },
  {
    "output": "theorem false_and_iff{a : Prop} :\na \u2227 false \u2194 false "
  },
  {
    "output": "theorem false_right_annihilator{a : Prop} :\nFalse \u2227 a \u2192 False "
  },
  {
    "output": "theorem false_and :\n\u2200 a : Prop, false \u2227 a \u2194 false "
  },
  {
    "output": "theorem false_and_iff_right{a : Prop} :\nFalse \u2227 a \u2194 False "
  },
  {
    "output": "theorem prop_self_equiv : \u2200 P, P \u2194 P\n"
  },
  {
    "output": "theorem every_prop_is_equiv_to_itself : \u2200 P : Prop , P \u2194 P "
  },
  {
    "output": "theorem self_equiv_of_equiv (a : Prop) : a \u27fa a "
  },
  {
    "output": "theorem true_self (p : Prop) : p <-> p "
  },
  {
    "output": "theorem eq_equivalence (q : Prop) : q = q "
  },
  {
    "output": "theorem id_prop (p : Prop) : p \u2194 p "
  },
  {
    "output": "theorem every_proposition_equivalent_to_itself (P : Prop) : P \u2194 P "
  },
  {
    "output": "theorem every_prop_iff_itself (P : Prop) : P \u2194 P "
  },
  {
    "output": "theorem all_props_are_equiv_to_themselves (P : Prop) : P \u2194 P "
  },
  {
    "output": "theorem proposition_equal_to_itself (p : Prop) : p \u2194 p "
  },
  {
    "output": "theorem eqv_refl :\n\u2200 {p : Prop}, p \u2248 p "
  },
  {
    "output": "theorem propext{a : Prop} :\na \u2194 a "
  },
  {
    "output": "theorem propext{p p' : Prop} :\np \u2194 p' "
  },
  {
    "output": "theorem prop.propext(a : Prop) :\n(a \u2194 a) "
  },
  {
    "output": "theorem forall_intro_iff{\u03b1 : Type u_1} {p : \u03b1 \u2192 Prop} :\n(\u2200 x, p x) \u2194 p true "
  },
  {
    "output": "theorem N : \u2200 a : Prop, a \u2192 (a \u2227 a) "
  },
  {
    "output": "theorem self_and_self_iff_self : \u2200 p : Prop, p \u2194 (p \u2227 p) "
  },
  {
    "output": "theorem every_prop_equiv_its_self_conj : \u2200 p, p \u2194 (p \u2227 p)\n proof\n  take p, by { intro, simp }\n Qed\n \n\n-- 3.2 (a) State each of the following using the type (Prop \u00d7 Prop).\n \n example : \u2200 hab, (h : Prop) \u2192 (a: Prop) \u2192 (b: Prop) \u2192 (hab \u2194 (h \u2227 a \u2227 b)) "
  },
  {
    "output": "theorem PropositionalExtensionalityNatural "
  },
  {
    "output": "theorem every_prop_is_equiv_to_and_itself :\n  \u2200 (p : Prop), p \u2243 (p \u2227 p) "
  },
  {
    "output": "theorem and_self (P : Prop) : P \u2194 P \u2227 P "
  },
  {
    "output": "theorem prop_self_and (P : Prop) : P \u2194 P \u2227 P "
  },
  {
    "output": "theorem prop_eq_and (p : Prop) : p \u2194 p \u2227 p "
  },
  {
    "output": "theorem self_and_is_self (P : Prop) : (P \u2227 P) \u2194 P "
  },
  {
    "output": "theorem prop_iff_self (P : Prop) : P \u2194 P \u2227 P "
  },
  {
    "output": "theorem idem{p : Prop} :\np \u2194 p \u2227 p "
  },
  {
    "output": "theorem prop_complete_eq(a : Prop) :\na \u2194 a \u2227 a "
  },
  {
    "output": "theorem a_and_a_eq_a {\u03b1 : Type} (p : \u03b1 \u2192 Prop) :\n(\u2200 a, p a \u2227 p a) \u2194 (\u2200 a, p a) "
  },
  {
    "output": "theorem self_conjunction{a : Prop} :\na \u2194 a \u2227 a "
  },
  {
    "output": "theorem self.conj{a : Prop} : a \u2194 a \u2227 a "
  },
  {
    "output": "theorem sem_equiv2: \u2200 (A : Type) [S: semigroup A] (p : Prop), p \u2192 \u2200 q : Prop, S q \u2192 S (p \u2228 q).\nMove all assumptions into hypotheses.\n theorem sem_equiv2 (A : Type) [S: semigroup A] (p: Prop) (Hp : p) (q : Prop) (Hq : S q) : S (p \u2228 q).\n\nConstruct the proof's outline, resembling the natural language version. Since the conclusion is bigger than the hypothesis, it sometimes makes sense to break the corresponding part into small steps.\n theorem sem_equiv2 (A : Type) [S"
  },
  {
    "output": "theorem foo_bar : \u2200 p : Prop , p \u2194 p \u2228 p "
  },
  {
    "output": "theorem and_self : \u2200{a : Prop}, a \u2194 (a \u2228 a)\nThe following theorem is a bit more complicated to read, so I'll give two versions. The first is in natural language:\nIff version:\n<blockquote>\n<p>For any propositions <span class=\"math-container\">$p$</span> and <span class=\"math-container\">$q$</span>, the statement that <span class=\"math-container\">$p$</span> and <span class=\"math-container\">$q$</span> are equivalent to each other is equivalent to the statements <span class=\"math-container\">$p$</span> is false"
  },
  {
    "output": "theorem every_prop_equiv_its_disj { p : Prop } : p \u2194 ( p \u2228 p ) "
  },
  {
    "output": "theorem :is_an_equivalence_relation = \u2200x:\u2115, x = 0 \u2228 x \u2260 0 \u2227 true "
  },
  {
    "output": "theorem dne_iff_iff (P : Prop):\n {P}+{\u00ac P} \u2192 [\u2200 b : bool, P \u2194 b = tt] "
  },
  {
    "output": "theorem prop_is_equiv_to_disjunction (p : Prop) : p \u2194 p \u2228 p "
  },
  {
    "output": "theorem any_prop_is_eq_to_itself_disjunction (P : Prop) :\n (P \u2228 P) \u2194 P "
  },
  {
    "output": "theorem true_of_eq_true_of_iff_true (P : Prop) : P \u2194 (P \u2228 P) "
  },
  {
    "output": "theorem proposition_equiv_disj_self (P : Prop) :\n (P \u2194 P \u2228 P) "
  },
  {
    "output": "theorem prop_self_disj{P : Prop} :\nP \u2194 (P \u2228 P) "
  },
  {
    "output": "theorem or_self{a : Prop} :\na \u2228 a \u2194 a "
  },
  {
    "output": "theorem prop_self_inter (a : Prop) :\na \u2194 a \u2228 a "
  },
  {
    "output": "theorem eq_or{a : Prop} :\na \u2194 a \u2228 a "
  },
  {
    "output": "theorem eq_self_iff_true {a : Prop} :\n  a \u2194 a \u2228 a "
  },
  {
    "output": "theorem reflexive (p : Prop) :  p \u2194 p "
  },
  {
    "output": "theorem equiv.rfl : A <-> A "
  },
  {
    "output": "theorem prop_set . mk_eq_reflexive : reflexive (@ prop_set . mk_eq : prop_set .{ u } \u2192 prop_set .{ u } \u2192 Type u ) "
  },
  {
    "output": "theorem reflexive' {A : Type} (R : A \u2192 A \u2192 Prop) : (\u2200 x : A, R x x) \u2192 is_reflexive R "
  },
  {
    "output": "theorem reflexive_of_equiv_of_prop (P Q : Prop), equiv_of_prop P Q \u2192 P \u2192 P "
  },
  {
    "output": "theorem refl_equiv : reflexive (@equiv Prop Prop) "
  },
  {
    "output": "theorem eq_refl_of_iff_true (p q : Prop) (h : p \u2194 q) : p "
  },
  {
    "output": "theorem prop_iff_reflexive : reflexive (@eq.refl _ _) "
  },
  {
    "output": "theorem eq_true_intro : \u2200 P : Prop, P = true "
  },
  {
    "output": "theorem is_equivalence.refl (p q : Prop) : p \u2194 q \u2192 p "
  },
  {
    "output": "theorem is_true.refl : reflexive is_true "
  },
  {
    "output": "theorem eq.refl  : reflexive eq "
  },
  {
    "output": "theorem setoid_Prop.refl_iff{\u03b1 : Sort u_1} {p q : Prop} :\np \u2248 q \u2192 p "
  },
  {
    "output": "theorem prop_eq_reflexive (\u03b1 : Sort u_1) :\nreflexive (@eq \u03b1) "
  },
  {
    "output": "theorem propext {p q : Prop} : p \u2194 q "
  },
  {
    "output": "theorem eq_symm { p q : Prop} (H : p \u2192 q) (H' : q \u2192 p) : p = q "
  },
  {
    "output": "theorem equiv_symm {p q : Prop} (h : p \u21d4 q) : q \u21d4 p "
  },
  {
    "output": "theorem equivalence.symm { P Q : Prop } : eqvP Q P \u2192 eqvP P Q "
  },
  {
    "output": "theorem equivalence_of_propositions_is_a_symmetric_relation : -- etc\n\n-/\n\n/-\n Here is another theorem.\n Translate it and prove it.\n-/\n\n #check symm -- it's a definition, not a theorem!\n\n/-\n\nNatural language version: \"The proposition that one and one is equal\nto two is symmetric.\"\n\nTranslate the natural language version to a Lean mathlib version:\n (symm\n    (eq_one_and_one_is_equal_to_two)\n   : nat) = eq_one_and_one_is_equal_to_two\n ... should typecheck.\n"
  },
  {
    "output": "theorem symm_of_eq_of_eq {A : Type} {p q : Prop} (hp : p) (hq : q) (heq : p \u2194 q) : q \u2194 p "
  },
  {
    "output": "theorem prop_equivalence_symm {P Q : Prop} : P \u2194 Q \u2192 Q \u2194 P "
  },
  {
    "output": "theorem eq_of_eq_iff_eq_of_eq (p q r s : Prop) : (p \u2194 q) \u2192 (r \u2194 s) \u2192 (p \u2194 r) \u2192 (q \u2194 s) "
  },
  {
    "output": "theorem equiv_prop_symm : symmetric equiv_prop "
  },
  {
    "output": "theorem symmetric_if_equivalent {p q : Prop} (H : p \u2194 q) : q \u2194 p "
  },
  {
    "output": "theorem eq_prop.symm (p q : Prop) (h : p \u2194 q) : q \u2194 p "
  },
  {
    "output": "theorem setoid.symm :\n((@setoid Prop _ _ (@equiv Prop _ _ _ _)) : setoid Prop).symm "
  },
  {
    "output": "theorem equiv.symm' {p q : Prop} : \n    p \u2194 q \u2192 q \u2194 p  _ "
  },
  {
    "output": "theorem is_equiv_is_sym : symmetric is_equiv "
  },
  {
    "output": "theorem prop.symm_iff{P Q : Prop} :\nQ \u21d4 P \u2194 P \u21d4 Q "
  },
  {
    "output": "theorem iff_symm_iff{p q : Prop} : p \u2194 q \u2194 q \u2194 p "
  },
  {
    "output": "theorem transitive_eq ( \u03b1 : Type ) ( r : \u03b1 \u2192 \u03b1 \u2192 Prop ) : transitive r \u2192 transitive ( \u03bb x y , r x y \u2227 r y x ) "
  },
  {
    "output": "theorem MyThm2 (p q r : Prop) (Hpq : p \u2194 q) (Hqr : q \u2194 r) : p \u2194 r "
  },
  {
    "output": "theorem Q5385_trans: transit"
  },
  {
    "output": "theorem transitive_of_equiv_of_prop {p q r : Prop} (H1 : (p \u2194 q)) (H2 : (q \u2194 r)) : ((p \u2194 r)) "
  },
  {
    "output": "theorem prop_ext.equiv_refl : \u2200 {p : Prop}, p \u27fa p "
  },
  {
    "output": "theorem equiv_trans {p q r : Prop} (hqp : p \u2194 q) (hqr : q \u2194 r) : p \u2194 r "
  },
  {
    "output": "theorem propositional_equivalence_is_trans (p q r : Prop) :\n p \u2194 q \u2192 q \u2194 r \u2192 p \u2194 r "
  },
  {
    "output": "theorem trans_of_equiv_eq : transitive (\u2261) "
  },
  {
    "output": "theorem and_trans (\u03b1 \u03b2 \u03b3 : Prop) (h\u2081 : \u03b1 \u2194 \u03b2) (h\u2082 : \u03b2 \u2194 \u03b3)\n : \u03b1 \u2194 \u03b3 "
  },
  {
    "output": "theorem trans_of_equiv (p q r : Prop) [equivalence p q r] :\n p \u2192 q \u2192 r "
  },
  {
    "output": "theorem prop.iff_iff_trans{p q r : Prop} (h\u2081 : p \u2194 q) (h\u2082 : q \u2194 r) :\np \u2194 r "
  },
  {
    "output": "theorem prop_eq.trans{p q r : Prop} (h\u2081 : p = q) (h\u2082 : q = r) :\np = r "
  },
  {
    "output": "theorem propext.trans{p q r : Prop} (h\u2081 : p \u2194 q) (h\u2082 : q \u2194 r) :\np \u2194 r "
  },
  {
    "output": "theorem iff.trans{p q r : Prop} :\n(p \u2194 q) \u2192 (q \u2194 r) \u2192 (p \u2194 r) "
  },
  {
    "output": "theorem prop.eq_of_iff{p q : Prop} (h : p \u2194 q) : p = q "
  },
  {
    "output": "Peirce_law : \u2200 p : Prop , p \u2192 (( p \u2192 q ) \u2192 q ) "
  },
  {
    "output": "self_implies : \u2200 P : Prop, P \u2192 P "
  },
  {
    "output": ": \u2200 ( P : Prop ), P \u2192 P "
  },
  {
    "output": "impified : \u2200 P , P \u2192 P "
  },
  {
    "output": "self_implies_self {q : Prop} : (q \u2192 q) "
  },
  {
    "output": "(p : Prop) : p \u2192 p "
  },
  {
    "output": "(P : Prop) : P \u2192 P "
  },
  {
    "output": "(p : Prop) : p \u2192 p "
  },
  {
    "output": "(P : Prop) (hP : P) : P "
  },
  {
    "output": "(h : Prop) :\n h \u2192 h "
  },
  {
    "output": "{p : Prop} :\nimplies p p "
  },
  {
    "output": "{P : Prop} (HP : P) :\nimplies P P "
  },
  {
    "output": "{p : Prop} : p \u2192 p "
  },
  {
    "output": "{a : Prop} : \nimply a a "
  },
  {
    "output": "{\u03b1 : Sort u} :\n\u2200 \u03b1 : Prop, \u03b1 \u2192 \u03b1 "
  },
  {
    "output": "and1 (T : Type) : T -> T "
  },
  {
    "output": "( \u03b1 : Type * ) : function \u03b1 \u03b1 "
  },
  {
    "output": "func2 { \u03b1:Type } ( x: \u03b1): (\u03b1 \u2192 \u03b1) "
  },
  {
    "output": "nat.exists_inv_self : \u2200 (n : \u2115), \u2203 (f : \u2115 \u2192 \u2115), f n = n "
  },
  {
    "output": "nat_lang_there_is_id (A : Type) : \u2203 f : A \u2192 A, true "
  },
  {
    "output": "(X : Type*) :\n \u03a0 x : X, x = id x "
  },
  {
    "output": "(X : Type*) :\n \u2200 x : X, X \u2192 X "
  },
  {
    "output": "(X : Type*) :\n  \u2203 (f : X \u2192 X), true "
  },
  {
    "output": "(X : Type*) :\n \u2203 f : X \u2192 X, true "
  },
  {
    "output": "(T : Type) :\n \u2200 t : T, id t = t "
  },
  {
    "output": "{\u03b1 : Type u} :\n\u2203 (f : \u03b1 \u2192 \u03b1), true "
  },
  {
    "output": "{\u03b1 : Sort u_1} :\nnonempty (\u03b1 \u2192 \u03b1) "
  },
  {
    "output": "{\u03b1 : Sort u} :\nnonempty (\u03b1 \u2192 \u03b1) "
  },
  {
    "output": "{\u03b1 : Type u_1} :\nnonempty (\u03b1 \u2192 \u03b1) "
  },
  {
    "output": "{\u03b1 : Sort u} :\nnonempty (\u03b1 \u2192 \u03b1) "
  },
  {
    "output": "every_prop_imples_true :\n \u2200 p : Prop, p \u2192 True "
  },
  {
    "output": "test { \u03b1 : Type } : \u03b1 \u2192 true "
  },
  {
    "output": "nlang_to_lean : \u2200 p : Prop, (p \u2192 true) "
  },
  {
    "output": "every_prop_implies_True :\n    \u2200 p : Prop , p \u2192 True \n  "
  },
  {
    "output": "true_prop_implies_true (p : Prop) : p \u2192 true "
  },
  {
    "output": "{P : Prop} (h : P) : True "
  },
  {
    "output": "(P : Prop) : P \u2192 True "
  },
  {
    "output": "(p : Prop) : p \u2192 true \u2192 true "
  },
  {
    "output": "(p : Prop) : p \u2192 true "
  },
  {
    "output": "(p : Prop) : p \u2192 true "
  },
  {
    "output": "(p : Prop) :\np \u2192 true "
  },
  {
    "output": "{P : Prop} (h : P) :\ntrue "
  },
  {
    "output": "(a : Prop) : implies a true "
  },
  {
    "output": "{p : Prop} :\np \u2192 true "
  },
  {
    "output": "{A : Prop} (h : A) : \n true "
  },
  {
    "output": "foo { A : Type } : A \u2192 Unit "
  },
  {
    "output": "unit_fn_exists : \u2200 \ud835\udd38:Type, \u2203 f:\ud835\udd38 \u2192 unit, (\u2200 x:\ud835\udd38, f x = () )\n\n@Mario Carneiro\n2 years ago\n@Tovarish Dzhulamirev So to make this an actual mathlib statement, you probably want something like\n\ndef fn_from_type_to_unit (A : Type) : A \u2192 unit "
  },
  {
    "output": "foo ( X Y : Type ) : { f : X \u2192 unit } "
  },
  {
    "output": "crazy_lemma : \u03a0 {A : Type}, A \u2192 unit "
  },
  {
    "output": "isnil { \u03b1 : Sort u } ( l : list \u03b1 ) : \u03b1 \u2192 () "
  },
  {
    "output": "(A : Type*) : exists f : A \u2192 punit.{1}, true "
  },
  {
    "output": "(A : Type) : nonempty (A \u2192 unit) "
  },
  {
    "output": "(X : Type*) : nonempty (X \u2192 Punit) "
  },
  {
    "output": "(\u03b1 : Type*) : inhabited (\u03b1 \u2192 punit) "
  },
  {
    "output": "(X : Type*) : nonempty (X \u2192 unit) "
  },
  {
    "output": "(M : Type u\u2081) :\nM \u2192 Unit "
  },
  {
    "output": "(X : Type) :\nX \u2192 Type.{v_1} -- use Sort to avoid levels, workaround until pi notation works with levels\n "
  },
  {
    "output": "(X : Type u) :\nequiv.unit_equiv X "
  },
  {
    "output": "{A : Type u} :\nfunction.surjective (\u03bb a:A, 1) "
  },
  {
    "output": "{M : Type u_1} :\nM \u2192* Unit "
  },
  {
    "output": "false_implies_anything { p : Prop } : ( false \u2192 p ) "
  },
  {
    "output": "abc : \u2200 ( P : Prop ) , false \u2192 P "
  },
  {
    "output": "and.elim_right (h\u2081 : false ) ( h\u2082 : false \u2192 false ) : false "
  },
  {
    "output": "t1 : (\u2200 (P : Prop), P) "
  },
  {
    "output": "my_false_of_false : false \u2192 \u2200 (p : Prop), p "
  },
  {
    "output": "{P : Prop} : P \u2228 \u00acP "
  },
  {
    "output": "(P : Prop) : False \u2192 P "
  },
  {
    "output": "(H : false) (P : Prop) : P \u2192 H "
  },
  {
    "output": "(a : Prop) : False \u2192 a "
  },
  {
    "output": "(P : Prop) : P "
  },
  {
    "output": "{a : Prop} :\nfalse \u2192 a "
  },
  {
    "output": "{p : Prop} : True \u2192 p "
  },
  {
    "output": "{p : Prop} :\np "
  },
  {
    "output": "(p : Prop) : \np "
  },
  {
    "output": "{P : Prop} :\nFalse \u2192 P "
  },
  {
    "output": "range_subset : \u2200 { \u03b1 : Type u }, Empty \u2192 ( \u03b1 \u2192 Sort v )\n proof\n intro \u03b1 ,\n intro H ,\n exact H\n qed\nend\n\n/-\n### Theorem: `\u2200 \u03b1, Empty \u2192 \u03b1`\n\nNatural language version: \"Any empty type is inhabited.\"\n-/\n\n\n/-\n### Theorem: `\u2200 \u03b1, Empty \u2192 NonEmpty \u03b1`\n\nNatural language version: \"Any empty type is 'nonempty'.\"\n-/\n\n#print empty.elim\n\n\n/-\n### Theorem: `\u2200 \u03b1, pop \u03b1 \u2192 Uninhabited \u03b1`\n\nNatural language version: \"A `pop`"
  },
  {
    "output": "empty_to_any : \u2200 X : Type , Empty \u2192 X "
  },
  {
    "output": "exists_map_empty ( A : Type ) : \u2203 ( f : Empty \u2192 A ), true "
  },
  {
    "output": "empty_to_any { \u03b1 : Type } : Empty \u2192 \u03b1 "
  },
  {
    "output": "empty_func_any {X:Type} : {f: Empty \u2192 X} "
  },
  {
    "output": "(X : Type) : nonempty X \u2243 X "
  },
  {
    "output": "(\u03b1 : Type) (h\u03b1 : empty = empty) :\n empty \u2192 \u03b1 "
  },
  {
    "output": "(X : Type*) :\n (0 : Empty) \u2192 X "
  },
  {
    "output": "(X : Type*) :\n inhabited \u2080 "
  },
  {
    "output": "(X : Type*) :\n functions.empty \u2192 X "
  },
  {
    "output": "{\u03b1 : Type u_1} :\n\u2203 (f : pempty \u2192 \u03b1), function.surjective f "
  },
  {
    "output": "{\u03b1 : Type u_1} :\nempty \u2192 \u03b1 "
  },
  {
    "output": "{\u03b1 : Type u_1} [is_empty \u03b1] {\u03b2 : Type u_2} :\n\u2203 (f : \u03b1 \u2192 \u03b2), true "
  },
  {
    "output": "{\u03b1 : Type u_1} :\nEmpty.rec (Empty.rec \u03b1) = \u03b1 "
  },
  {
    "output": "{\u03b1 : Type u_1} :\n\u2203 (f : Empty \u2192 \u03b1), true "
  },
  {
    "output": "mathlib_conditional_proof_varient:\n  \u2200 P Q : Prop, (Q \u2192 P) \u2194 (P \u2192 Q) "
  },
  {
    "output": "and_of_self { P : Prop } ( h : P ) : P \u2227 Q "
  },
  {
    "output": "and_of_true_right { P Q : Prop } : P \u2192 ( P \u2227 Q ) "
  },
  {
    "output": "iq2 : (\u2200 (P Q : Prop), P \u2192 P) \u2192 \u2200 (P Q : Prop), (P \u2192 Q) \u2192 (P \u2192 Q) "
  },
  {
    "output": "two :P Q : Prop, P : Q \u2192 (P \u2192 Q) "
  },
  {
    "output": "(p q : Prop) (hp : p) : p \u2192 q \u2192 q "
  },
  {
    "output": "(P Q : Prop) (hP : P) :\n P \u2192 Q "
  },
  {
    "output": "(P Q : Prop): P \u2192 (P \u2192 Q) \u2227 P "
  },
  {
    "output": "(P Q : Prop) (h : P) : P \u2192 Q "
  },
  {
    "output": "(P Q : Prop) [hP : P] : Q "
  },
  {
    "output": "{p q : Prop} (h : assumes p, shows q) :\nimplies p q "
  },
  {
    "output": "{p q : Prop} (hp : p) :\nimplies p q "
  },
  {
    "output": "{p q : Prop} (h : p) :\nq \u2192 p "
  },
  {
    "output": "{p q : Prop} (h : p) :\n(implies q p) "
  },
  {
    "output": "{p q : Prop} (h : p) :\np \u2192 q "
  },
  {
    "output": "nn_impl_ff : (\u00ac (\u00ac P)) \u2194 P "
  },
  {
    "output": "some_statement : \u2200 ( P : Prop ), \u00acP  \u2194 (P \u2192 false)\n"
  },
  {
    "output": "not_equivalent_to_implies_false {P : Prop}: \u00ac P \u2194 (P \u2192 false) "
  },
  {
    "output": "my_test' : ((\u2200 P : Prop, \u00acP) \u2194 \u2200 P : Prop, (P \u2192 False)) "
  },
  {
    "output": "ff_not_of_implies_ff {P : Prop} : P \u2192 (P \u2192 false) "
  },
  {
    "output": "(P : Prop) : (\u00ac P) \u2194 (P \u2192 false) "
  },
  {
    "output": "(P : Prop) : \u00acP \u2194 (P \u2192 false) "
  },
  {
    "output": "(P : Prop) :\n \u00ac P \u2194 (P \u2192 false) "
  },
  {
    "output": "(P : Prop) : P \u2194 !P "
  },
  {
    "output": "(P : Prop) :\n (\u00ac P \u2194 (P \u2192 false)) "
  },
  {
    "output": "{a : Prop} :\n\u00aca \u2194 (a \u2192 false) "
  },
  {
    "output": "{a : Prop} :\n\u00aca \u2194 (a \u2192 false) "
  },
  {
    "output": "{a : Prop} :\na \u2194 \u00ac\u00aca "
  },
  {
    "output": "{a : Prop} :\n\u00aca \u2194 (a \u2192 false) "
  },
  {
    "output": "{a : Prop} :\n\u00aca \u2194 a \u2192 false "
  },
  {
    "output": "implies_not_not (p : Prop) : p \u2192 \u00ac \u00ac p "
  },
  {
    "output": "Peirce_law : (A -> B) -> ((\u00ac\u00acA) -> A) "
  },
  {
    "output": "tautology1 (p : Prop) : p \u2192 \u00ac\u00acp\n"
  },
  {
    "output": "Double_neg ( p : Prop ): p \u2192 \u00ac\u00acp "
  },
  {
    "output": "p_iff_double_negation : \u2200 (p: Prop), (p \u2194 ~~p) "
  },
  {
    "output": "(P : Prop) : P \u2192 ~~P "
  },
  {
    "output": "(P : Prop) : (P \u2192 \u00ac\u00acP) "
  },
  {
    "output": "{\u03b1 : Sort*} (p : Prop) : (p \u2192 false) \u2192 false "
  },
  {
    "output": "(P : Prop) : P \u2192 ~~P "
  },
  {
    "output": "{P : Prop} (h : P) : (\u00ac \u00ac P) "
  },
  {
    "output": "{a : Prop} :\na \u2192 \u00ac\u00aca "
  },
  {
    "output": "{a : Prop} :\na \u2192 \u00ac\u00aca "
  },
  {
    "output": "{P : Prop} :\n(P \u2192 \u00ac\u00acP) "
  },
  {
    "output": "{a : Prop} :\na \u2192 \u00ac \u00ac a "
  },
  {
    "output": "{a : Prop} :\na \u2192 \u00ac\u00aca "
  },
  {
    "output": "contrapositive_implies_impl (h1 : A \u2192 B) (h2 : \u00ac B \u2192 \u00ac A) : A \u2192 B "
  },
  {
    "output": "contrapositive : (p \u2192 q) \u2192 (\u00acq \u2192 \u00acp) "
  },
  {
    "output": "image_inter_image : \u2200 (Y X Z : set \u03b1), (Y \u2286 X) \u2192 (Z \u2286 X) \u2192 (Y \u2229 Z \u2286 X \u2229 X).\n  { intros Y X Z HYZ HZX. intros y yin, cases yin with Yy Zz,\n    have HYy : Y y "
  },
  {
    "output": "implication_congruence {p q : Prop} : (p \u2192 q) \u2194 (\u00ac q \u2192 \u00ac p) "
  },
  {
    "output": "contra_of_impl {P Q : Prop} : (P \u2192 Q) \u2192 (\u00acQ \u2192 \u00acP).\n2. If we live in a world where every theorem has a proof in ZFC set theory, which axiom of ZFC do we need?\n\nIf \u2200 P Q, \u00ac(P \u2227 Q) \u2192 (\u00acP \u2228 \u00acQ)).\nThen the class of valid sentences is the formula is the\nthe S5 system.\n\n@[intro!] lemma em (P : Prop) : P \u2228 \u00acP "
  },
  {
    "output": "(a b : Prop) (h : a \u2192 b) : \u00ac b \u2192 \u00ac a "
  },
  {
    "output": "{P Q : Prop} (h : P \u2192 Q) : \u00ac Q \u2192 \u00ac P "
  },
  {
    "output": "(P Q : Prop) (h : (P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P)) :\n \u00ac P \u2192 \u00ac Q \u2192 P "
  },
  {
    "output": "(P Q : Prop) : (P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P) "
  },
  {
    "output": "(P Q : Prop) (hPQ : (P \u2192 Q) \u2192 \u00acQ \u2192 \u00acP) :\n (\u00acQ \u2192 \u00acP) \u2192 (P \u2192 Q) "
  },
  {
    "output": "{a b : Prop} (h : a \u2192 b) :\n(\u00acb \u2192 \u00aca) "
  },
  {
    "output": "{p q : Prop} (h : implies p q) :\nimplies (not q) (not p) "
  },
  {
    "output": "{P Q : Prop} (h : P \u2192 Q) :\nQ \u2192 P "
  },
  {
    "output": "{p q : Prop} (h\u2081 : implies p q) : implies q p "
  },
  {
    "output": "{a b : Prop} (h : a \u2192 b) : (\u00acb \u2192 \u00aca) "
  },
  {
    "output": "implies_trans:\n  \u2200 (P Q R : Prop), (P \u2192 Q) \u2192 (Q \u2192 (R \u2192 P)) \u2192 (R \u2192 P)\n\n (warn: the natural language version is a bit weird. I went easy on you.)\n\n  Next Week\n\n  - Hint Command (:)\n  - Logic exercises!\n\n  -universes\n  -equivalence\n  -what is a lie? \n  -a few hints here and there\n  -how does Lean know that 2 is a nat?\n  -section exercise: prove this is an equivalence relation on naturals.\n  -why is that true?\n\n  ---\n\n  # Chapter 11"
  },
  {
    "output": "trans ( P Q R : Prop ) : ( P \u2192 Q ) \u2192 ( Q \u2192 R ) \u2192 P \u2192 R\n Q . intro_arrow ( P . intro_arrow ( P . sep ))\nQed .\nintro_arrow : P \u2192 ( P \u2192 Q ) \u2192 Q introductio n by ar row\nsep : ( P \u2192 Q ) \u2192 ( P \u2192 R ) \u2192 P \u2192 Q \u2227 R separat ion ( th eorem) Explain how this proof works in terms of the connectives we have studied. As an exercise, prove the theorem using tactics (but do not use intros to do this).\nWhat if we want to prove: theorem example ( P : Prop ) : ( P \u2192"
  },
  {
    "output": "F : \u2200 p q r, (p \u2192 q) \u2192 (q \u2192 r) \u2192 (p \u2192 r) "
  },
  {
    "output": "@trans_implication : \u2200 ( A B C : Prop ), (A \u2192 B) \u2192 (B \u2192 C) \u2192 A \u2192 C "
  },
  {
    "output": "transitive_impl ( p q r : Prop ) : ( p \u2192 q ) \u2192 ( q \u2192 r ) \u2192 ( p \u2192 r ) "
  },
  {
    "output": "(P Q R: Prop) : (P \u2192 Q) \u2192 (Q \u2192 R) \u2192 (P \u2192 R) "
  },
  {
    "output": "{P Q R : Prop} (h1 : (P \u2192 Q) \u2227 (Q \u2192 R)) :\n P \u2192 R "
  },
  {
    "output": "(p q r : Prop) (h : p \u2192 q) (k : q \u2192 r) : p \u2192 r "
  },
  {
    "output": "{P Q R : Prop} (HPQ : P \u2192 Q) (HQR : Q \u2192 R) : P \u2192 R "
  },
  {
    "output": "(p q r : Prop) :\n  ((p \u2192 q) \u2227 (q \u2192 r)) \u2192 (p \u2192 r) "
  },
  {
    "output": "{p q r : Prop} (h\u2081 : implies p q) (h\u2082 : implies q r) :\nimplies p r "
  },
  {
    "output": "{\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1} (p : \u03b1 \u2192 Prop) (l : list \u03b1) (hnil : l \u2260 []) (h : list.chain r a l) (hb : (a :: l).last _ = b) (carries : \u2200 \u2983x y : \u03b1\u2984, r x y \u2192 p y \u2192 p x) (final : p b) :\n\u00acp a \u2227 \u00acp (a :: l).head \u2227 \u00acp (a :: l).last "
  },
  {
    "output": "{p q r : Prop} (h\u2081 : implies p q) (h\u2082 : implies q r) :\nimplies p r "
  },
  {
    "output": "{p q r : Prop} (h\u2081 : p \u2192 q) (h\u2082 : q \u2192 r) :\np \u2192 r "
  },
  {
    "output": "{p q r : Prop} (h\u2081 : p \u2192 q) (h\u2082 : q \u2192 r) :\np \u2192 r "
  },
  {
    "output": "iff_of_and_true_of_true { a b : Prop } ( H\u2081 : a ) ( H\u2082 : b ) : a \u2194 b "
  },
  {
    "output": "conjunction_implication  :  \u2200P Q : Prop, P \u2227 Q \u2192 P "
  },
  {
    "output": "conjunction_true :\n | Q : Prop, (p \u2227 Q) \u27f9 (p \u2228 Q) "
  },
  {
    "output": "my_theorem :\n   \u2200 P Q : Prop, P \u2192 Q \u2192 P \u2227 Q "
  },
  {
    "output": "and_true_intro (hp : P) (hq : Q) : P \u2227 Q "
  },
  {
    "output": "(P Q : Prop) [decidable P] [decidable Q] : P \u2227 Q "
  },
  {
    "output": "(P Q : Prop) (hP : P) (hQ : Q) : P \u2227 Q "
  },
  {
    "output": "(P Q : Prop) (hP : P) (hQ : Q) : P \u2227 Q "
  },
  {
    "output": "(P Q : Prop) (hP : P) (hQ : Q) :\n P \u2227 Q "
  },
  {
    "output": "(p q : Prop) (hp : p) (hq : q) : p \u2227 q "
  },
  {
    "output": "{p q : Prop} (hp : p) (hq : q) :\np \u2227 q "
  },
  {
    "output": "{p q : Prop} (hp : p) (hq : q) :\np \u2227 q "
  },
  {
    "output": "{p q : Prop} (hp : p) (hq : q) :\np \u2227 q "
  },
  {
    "output": "{a b : Prop} (h\u2081 : a) (h\u2082 : b) :\na \u2227 b "
  },
  {
    "output": "{p q : Prop} (pp : p) (qq : q) :\np \u2227 q "
  },
  {
    "output": "conjunction_commutative : \n \u2200 P Q, (P \u2227 Q) \u2194 (Q \u2227 P) "
  },
  {
    "output": "conj_commut ( P Q : Prop ) : P \u2227 Q \u2194 Q \u2227 P "
  },
  {
    "output": "mythm : \u2200 a b : Prop, a \u2227 b \u2192 b \u2227 a "
  },
  {
    "output": "add_comm: \u2200 a b : \u2115, a + b = b + a "
  },
  {
    "output": "commutativity_of_conjunction : p \u2227 q \u2194 q \u2227 p "
  },
  {
    "output": "(a b : Prop) : a \u2227 b \u2194 b \u2227 a "
  },
  {
    "output": "(p q : Prop) : p \u2227 q \u2194 q \u2227 p "
  },
  {
    "output": "(P Q : Prop) : P \u2227 Q \u2194 Q \u2227 P "
  },
  {
    "output": "(P Q : Prop):\n P \u2227 Q \u2194 Q \u2227 P "
  },
  {
    "output": ": \u2200 (p q : Prop), p \u2227 q \u2192 q \u2227 p "
  },
  {
    "output": "{a b : Prop} :\na \u2227 b \u2194 b \u2227 a "
  },
  {
    "output": "{a b : Prop} :\na \u2227 b \u2194 b \u2227 a "
  },
  {
    "output": "{a b : Prop} :\na \u2227 b \u2194 b \u2227 a "
  },
  {
    "output": "{a b : Prop} : a \u2227 b \u2194 b \u2227 a "
  },
  {
    "output": "{a b : Prop} :\na \u2227 b \u2194 b \u2227 a "
  },
  {
    "output": "conj_assoc : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 Prop "
  },
  {
    "output": "and_assoc (a b c:Prop) : a \u2227 (b \u2227 c) \u2194 (a \u2227 b) \u2227 c "
  },
  {
    "output": "assoc (s t u : set (list \u2115)) : s \u2229 (t \u2229 u) = (s \u2229 t) \u2229 u "
  },
  {
    "output": "is_assoc (a b c : my_prop) : (a \u2227 b) \u2227 c \u2194 a \u2227 (b \u2227 c) "
  },
  {
    "output": "assoc_conj {a b c : Prop} : (a /\\ b) /\\ c -> a /\\ (b /\\ c) "
  },
  {
    "output": "(a b c : Prop) : (a \u2227 b) \u2227 c \u2192 a \u2227 (b \u2227 c) "
  },
  {
    "output": "(\u03b1 : Type) [Semilattice_inf \u03b1] : \u2200 x y z : \u03b1, x \u2293 (y \u2293 z) = x \u2293 y \u2293 z "
  },
  {
    "output": "(p q r : Prop) : (p \u2227 q) \u2227 r \u2192 p \u2227 (q \u2227 r) "
  },
  {
    "output": "(p q r : Prop) : (p \u2227 q \u2227 r) \u2194 (p \u2227 (q \u2227 r)) "
  },
  {
    "output": "(a b c : Prop) : a \u2227 (b \u2227 c) \u2194 (a \u2227 b) \u2227 c "
  },
  {
    "output": "{a b c : Prop} :\n(a \u2227 b) \u2227 c \u2194 a \u2227 (b \u2227 c) "
  },
  {
    "output": "{a b c : Prop} :\n(a \u2227 b) \u2227 c \u2194 a \u2227 (b \u2227 c) "
  },
  {
    "output": "{a b c : Prop} :\na \u2227 b \u2227 c \u2194 a \u2227 (b \u2227 c) "
  },
  {
    "output": "{a b c : Prop} :\na \u2227 b \u2227 c \u2194 a \u2227 (b \u2227 c) "
  },
  {
    "output": "{a b c : Prop} :\na \u2227 b \u2227 c \u2194 a \u2227 (b \u2227 c) "
  },
  {
    "output": "-- (tautology) or (lemma)\n disj_commutative : -- should probably be a definition theorem\n  \u2200 (p : Prop) (q : Prop), -- for all propositions p, q,\n    (p \u2228 q) \u2194 (q \u2228 p) "
  },
  {
    "output": "DisjComm : forall (X Y : U), X or Y -> Y or X . Natural language version: \"The conjunction between X and Y implies X.\"\n Translate the natural language version to a Lean mathlib version:\n\n theorem conj_first : X and Y implies X\n\n Natural language version: \"The conjunction between X and Y implies Y.\"\n Translate the natural language version to a Lean mathlib version:\n\n theorem conj_second : X and Y implies Y\n\n Natural language version: \"Existential quantification is commutative.\"\n Translate the natural language version to a Lean mathlib version:\n\n theorem ExistQuantComm : forall (X Y : U), exists x, X x Y"
  },
  {
    "output": "disj_comm_mathlib : \u2200 X Y : Prop,\n    X \u2228 Y \u2194 Y \u2228 X "
  },
  {
    "output": "disj_comm : p \u2228 q \u2194 q \u2228 p "
  },
  {
    "output": "disjunction_commutative : P \u2228 Q \u2194 Q \u2228 P "
  },
  {
    "output": "(p q : Prop) :\n p \u2228 q \u2194 q \u2228 p "
  },
  {
    "output": "P Q : (P \u2228 Q) \u2194 (Q \u2228 P) "
  },
  {
    "output": "(P Q : Prop) : P \u2228 Q \u2194 Q \u2228 P\n\nTheorem.\n  constructor.\n  intro hpq.\n  destruct hpq. right; assumption. left; assumption.\n  \n  intro hpq.\n  destruct hpq. right; assumption. left; assumption.\nQed.\n \nNatural language version: \"The empty set is a subset of every set.\" Translate the natural language version to a Lean mathlib version:\n theorem (U : Type*) (x : U) : \u2205 \u2286 { x }\n\nTheorem.\n  unfold subset.\n  intro y.\n  intro h.\nAdmitted.\n\n"
  },
  {
    "output": "(\u03b1 : Type*) (a : \u03b1) (b : \u03b1) :\n a \u2228 b = b \u2228 a "
  },
  {
    "output": "(p q : Prop) : p \u2228 q \u2194 q \u2228 p "
  },
  {
    "output": "{a b : Prop} :\na \u2228 b \u2194 b \u2228 a "
  },
  {
    "output": "{a b : Prop} :\na \u2228 b \u2194 b \u2228 a "
  },
  {
    "output": "{a b : Prop} :\na \u2228 b \u2194 b \u2228 a "
  },
  {
    "output": "{a b : Prop} :\na \u2228 b \u2194 b \u2228 a "
  },
  {
    "output": "{a b : Prop} :\na \u2228 b \u2194 b \u2228 a "
  },
  {
    "output": "addition_associative : \u2200 (m n p : mynat), m + n + p = m + (n + p) "
  },
  {
    "output": "foo : \u2200 a b : Prop, (a \u2228 b) \u2228 (b \u2228 a) \u2228 \u2191false \u2228 b \\/ a \\/ b \\/ false\n theorem foo : \u2200 a b : Prop, (a \u2228 b) \u2228 b \\/ a \\/ false\ndef foo (a b : Prop) "
  },
  {
    "output": "disj_assoc : Assertion "
  },
  {
    "output": "disjunction_associative : \u2200 (P Q R : Prop), (P \u2228 (Q \u2228 R)) \u2192 ((P \u2228 Q) \u2228 R) "
  },
  {
    "output": "disj_assoc : a \u2228 (b \u2228 c) \u2194 (a \u2228 b) \u2228 c "
  },
  {
    "output": "(p q r : Prop) : p \u2228 q \u2228 r \u2194 (p \u2228 q) \u2228 r "
  },
  {
    "output": "{a b c : Prop} : (a \u2228 b) \u2228 c \u2192 a \u2228 b \u2228 c "
  },
  {
    "output": "(a b c : Prop) : (a \u2228 b) \u2228 c \u2194 a \u2228 (b \u2228 c) "
  },
  {
    "output": "(p q r : Prop) : p \u2228 (q \u2228 r) \u2194 p \u2228 q \u2228 r "
  },
  {
    "output": "(p q r : Prop) : (p \u2228 q) \u2228 r \u2194 p \u2228 (q \u2228 r) "
  },
  {
    "output": "{a b c : Prop} :\na \u2228 (b \u2228 c) \u2194 (a \u2228 b) \u2228 c "
  },
  {
    "output": "{a b c : Prop} :\n(a \u2228 b) \u2228 c \u2194 a \u2228 (b \u2228 c) "
  },
  {
    "output": "{a b c : Prop} :\na \u2228 (b \u2228 c) \u2194 (a \u2228 b) \u2228 c "
  },
  {
    "output": "{a b c : Prop} :\na \u2228 b \u2228 c \u2194 (a \u2228 b) \u2228 c "
  },
  {
    "output": "{a b c : Prop} :\n(a \u2228 b) \u2228 c \u2194 a \u2228 (b \u2228 c) "
  },
  {
    "output": "dm_t : P \u2192 ((P \u2228 Q) "
  },
  {
    "output": "dne_exercise: \u2200 (P Q : Prop), P \u2192 P \u2228 Q .\n\n-- Help section:\n-- `or` documentation: https://www.mathlib.de/?q=doc/core/init/logic#or\n-- `prop` type: https://github.com/leanprover-community/mathlib/blob/978aaa5ffc6e9acb8cb056a0d6db4da6a27f6a1f/src/logic/basic.lean#L914\n-- `prop` documentation: https://www.mathlib.de/?q=doc/core/init/logic#prop"
  },
  {
    "output": "neg_false_iff ( P Q : Prop ): ( \u00ac P )  \u2194 ( P \u2228 Q ) \u2192 false "
  },
  {
    "output": "mybool_property ( P : Prop ) ( Q : Prop ) : true \u2192 ( P \u2228 Q ) "
  },
  {
    "output": "foo ( P Q : Prop ) : true \u2192 P \u2228 Q "
  },
  {
    "output": "(P Q : Prop) (H : P) :\n P \u2228 Q "
  },
  {
    "output": "(P Q : Prop) (HP : P) : P \u2228 Q "
  },
  {
    "output": "(P Q : Prop)\n (hP : P) : P \u2228 Q "
  },
  {
    "output": "(P Q : Prop) (p : P) : P \u2228 Q "
  },
  {
    "output": "(P Q : Prop) :\n  P \u2192 P \u2228 Q "
  },
  {
    "output": "{P Q : Prop} (h : P) :\nP \u2228 Q "
  },
  {
    "output": "{P Q : Prop} (h_1 : P) :\nP \u2228 Q "
  },
  {
    "output": "{P Q : Prop} (hP : P) :\nP \u2228 Q "
  },
  {
    "output": "{P Q : Prop} (h : P) : P \u2228 Q "
  },
  {
    "output": "{p q : Prop} (hp : p) :\np \u2228 q "
  },
  {
    "output": "soundness {P : Prop} {Q : Prop} (H : Q) : P \u2228 Q "
  },
  {
    "output": "and_or_distrib (P Q : Prop) (h : Q) : (P \u2228 Q) "
  },
  {
    "output": "implies_disjunction { P Q : Prop } ( h : Q \u2192 ( P \u2228 Q ) ) "
  },
  {
    "output": "P_or_Q (P Q : Prop) : Q \u2192 P \u2228 Q \n theorem Q_implies_P_or_Q (Q : Prop) : Q \u2192 P \u2228 Q\n theorem Q_implies_P_or_Q (Q : Prop) (pf1 : Q) : P \u2228 Q "
  },
  {
    "output": "mt_implies_disj ( P Q : Prop ) : Q \u2192 P \u2228 Q "
  },
  {
    "output": "(P Q : Prop) (hQ : Q) : P \u2228 Q "
  },
  {
    "output": "(P Q : Prop) (h : Q) :\n P \u2228 Q "
  },
  {
    "output": "(P Q : Prop) (hQ : Q) : P \u2228 Q "
  },
  {
    "output": "(P Q : Prop) : Q \u2192 P \u2228 Q "
  },
  {
    "output": "(P Q : Prop) (hQ : Q) : P \u2228 Q "
  },
  {
    "output": "{P Q : Prop} (h : Q) :\nP \u2228 Q "
  },
  {
    "output": "{a b : Prop} :\nb \u2192 (a \u2228 b) "
  },
  {
    "output": "{P Q : Prop} (h\u2082 : Q) :\nP \u2228 Q "
  },
  {
    "output": "{a b : Prop} (h : b) :\na \u2228 b "
  },
  {
    "output": "{p q : Prop} (h : q) :\np \u2228 q "
  },
  {
    "output": "left_distrib : \u2200[a: Prop] [b: Prop] [c: Prop],\n                                 (a \u2227 b) \u2228 (a \u2227 c) \u2194 a \u2227 (b \u2228 c) "
  },
  {
    "output": "disj_distrib_over_conj ( A B C:Prop ): A \u2228 (B \u2227 C) \u2194 (A \u2228 B) \u2227 (A \u2228 C) "
  },
  {
    "output": "left_distrib : \u2200 a b c: Prop, a \u2227 (b \u2228 c) \u2194 (a \u2227 b) \u2228 (a \u2227 c) "
  },
  {
    "output": "hd_disj_left : (A \u2227 B) \u2228 C \u2194 (A \u2228 C) \u2227 (B \u2228 C) "
  },
  {
    "output": "my_lemma' : ( P \u2228 Q ) \u2227 R \u2192 P \u2228 ( Q \u2227 R )\n\nTheorem andb_true_iff : forall b c : bool,\n  b && c = true <-> b = true /\\ c = true.\nProof.\n  intros b c. \n  split.\n  - intros H. \n    apply andb_true_elim1 in H. \n    apply andb_true_elim2 in H.\n    split. \n    + apply H. \n    + apply H. \n  - intros H. \n    inversion H as [H1 H"
  },
  {
    "output": "(a b c : Prop) : a \u2227 (b \u2228 c) \u2194 (a \u2227 b) \u2228 (a \u2227 c) "
  },
  {
    "output": "(a b c : Prop) :\n a \u2227 (b \u2228 c) \u2194 (a \u2227 b) \u2228 (a \u2227 c) "
  },
  {
    "output": "(a b c : Prop) :\n ((a \u2227 b) \u2227 c) \u2194 (a \u2227 (b \u2227 c)) "
  },
  {
    "output": "(p q r: Prop) :\n (p \u2227 q) \u2228 r \u2194 ((p \u2227 q) \u2228 r) \u2227 ((p \u2227 q) \u2228 r) "
  },
  {
    "output": "(a b : Prop) : (a \u2227 (b \u2228 a)) \u2194 (a \u2227 b) \u2228 a "
  },
  {
    "output": "{a b c : Prop} :\n(a \u2228 b) \u2227 (a \u2228 c) \u2194 a \u2227 (b \u2228 c) "
  },
  {
    "output": "{a b c : Prop} :\n(a \u2228 b) \u2227 (a \u2228 c) \u2194 a \u2228 (b \u2227 c) "
  },
  {
    "output": "{a b c : Prop} :\na \u2227 (b \u2228 c) \u2194 a \u2227 b \u2228 a \u2227 c "
  },
  {
    "output": "{a b c : Prop} :\n(a \u2228 b) \u2227 (a \u2228 c) \u2194 a \u2228 (b \u2227 c) "
  },
  {
    "output": "{a b c : Prop} :\na \u2227 (b \u2228 c) \u2194 (a \u2227 b) \u2228 (a \u2227 c) "
  },
  {
    "output": "commx_conj_disj_of_conj_or_conj {p q r:Prop}: (p /\\ q) \\/ (p /\\ r) \u2192 p /\\ (q \\/ r) "
  },
  {
    "output": "lattice_distr (p q r : Prop) : (p \u2227 q) \u2228 r \u2194 p \u2227 (q \u2228 r) "
  },
  {
    "output": "nat_dist (p q : Prop) : p \u2227 (q \u2228 p) \u2194 (p \u2227 q) \u2228 p "
  },
  {
    "output": "my_comm : \u2200 a b c, a \u2227 (b \u2228 c) \u2194 (a \u2227 b) \u2228 (a \u2227 c) "
  },
  {
    "output": "or_of_or_distrib_right {\u03b1 : Type} (a b c : \u03b1) : a \u2228 (b \u2228 c) \u2192 (a \u2228 b) \u2228 c\n lemma or_of_or_distrib_right :\n  \u2200 {\u03b1 : Type} (a b c : \u03b1), a \u2228 (b \u2228 c) \u2192 (a \u2228 b) \u2228 c\n Proof.\n  intros \u03b1 a b c H.\n  apply or_or, H.\n Qed.\n\n --How many subgoals?\n theorem or_of_or_distrib_right {\u03b1 : Type} (a b c : \u03b1) :"
  },
  {
    "output": "(a b c : Prop) :\n a \u2227 (b \u2228 c) \u2194 (a \u2227 b) \u2228 (a \u2227 c) "
  },
  {
    "output": "(a b c : Prop) :\n a \u2227 (b \u2228 c) \u2194 (a \u2227 b) \u2228 (a \u2227 c) "
  },
  {
    "output": "(p q r : Prop) : (p \u2227 q) \u2228 r \u2192 (p \u2228 r) \u2227 (q \u2228 r) "
  },
  {
    "output": "(x y z : Prop) :\n (x \u2227 (y \u2228 z)) \u2194 ((x \u2227 y) \u2228 (x \u2227 z)) "
  },
  {
    "output": "(P Q R : Prop): (P \u2227 (Q \u2228 R)) \u2194 ((P \u2227 Q) \u2228 (P \u2227 R)) "
  },
  {
    "output": "{a b c : Prop} :\n(a \u2228 b) \u2227 (a \u2228 c) \u2194 a \u2227 (b \u2228 c) "
  },
  {
    "output": "{a b c : Prop} :\n(a \u2227 b) \u2228 c \u2194 a \u2227 (b \u2228 c) "
  },
  {
    "output": "{a b c : Prop} :\na \u2227 (b \u2228 c) \u2194 (a \u2227 b) \u2228 (a \u2227 c) "
  },
  {
    "output": "{a b c : Prop} :\n(a \u2228 b) \u2227 c \u2194 a \u2228 c \u2227 b \u2228 c "
  },
  {
    "output": "{a b c : Prop} :\na \u2227 (b \u2228 c) \u2194 a \u2227 b \u2228 a \u2227 c "
  },
  {
    "output": "or_distrib_and_right : \u2200 a b c : Prop, (a \u2228 b) \u2227 c \u2192 a \u2227 c \u2228 b \u2227 c "
  },
  {
    "output": "and_or_distrib_l `{ClassicalProofG olor}: (p \u2227 q) \u2228 r \u2194 (p \u2228 r) \u2227 (q \u2228 r) "
  },
  {
    "output": "disj_left_distributes_over_conj (p q r : Prop) : (p \u2228 q) \u2227 r \u2194 (p \u2227 r) \u2228 (q \u2227 r) "
  },
  {
    "output": "le_trans (a b c : \u2115) : a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c "
  },
  {
    "output": "left_distrib : \u2200 p q r, (p \u2228 (q \u2227 r)) \u2194 ((p \u2228 q) \u2227 (p \u2228 r)) "
  },
  {
    "output": "(A B : Prop) : A \u2228 (B \u2227 A) \u2194 (A \u2228 B) \u2227 (A \u2228 A) "
  },
  {
    "output": "(a b c: Prop):\n   a \u2227 (b \u2228 c) \u2194 (a \u2227 b) \u2228 (a \u2227 c)"
  },
  {
    "output": "(P Q R : Prop) : (P \u2227 Q) \u2228 (P \u2227 R) \u2194 P \u2227 (Q \u2228 R)"
  },
  {
    "output": "(p q r : Prop) : (p \u2228 q) \u2227 r \u2192 (p \u2227 r) \u2228 (q \u2227 r) "
  },
  {
    "output": "(P Q R : Prop) : (P \u2228 Q) \u2227 R \u2194 (P \u2227 R) \u2228 (Q \u2227 R) "
  },
  {
    "output": "{a b c : Prop} :\n(a \u2227 b) \u2228 c \u2194 (a \u2228 c) \u2227 (b \u2228 c) "
  },
  {
    "output": "{a b c : Prop} :\na \u2228 (b \u2227 c) \u2194 (a \u2228 b) \u2227 (a \u2228 c) "
  },
  {
    "output": "{a b c : Prop} :\n(a \u2228 b) \u2227 c \u2194 a \u2227 c \u2228 b \u2227 c "
  },
  {
    "output": " {a b c : Prop} :\n a \u2228 (b \u2227 c) \u2194 a \u2228 b \u2227 a \u2228 c "
  },
  {
    "output": "{a b c : Prop} :\na \u2228 (b \u2227 c) \u2194 (a \u2228 b) \u2227 (a \u2228 c) "
  },
  {
    "output": "d_nat : (p \u2228 q) \u2227 r \u2194 p \u2227 r \u2228 q \u2227 r "
  },
  {
    "output": "disjnt_of_disj { P Q R : Prop } : P \u2228 Q \u2192 (P \u2192 R \u2228 Q) \u2192 R \u2228 Q "
  },
  {
    "output": "distr_or_imp {p q r : Prop}: (p \u2228 q) \u2192 r \u2194 (p \u2192 r) \u2227 (q \u2192 r) "
  },
  {
    "output": "or_distrib_left {p q r : Prop} :\n   p \u2227 (q \u2228 r) \u2192 (p \u2227 q) \u2228 (p \u2227 r)\n proof\n     intro h,\n     cases h with hp hqr,\n     cases hqr with hq hr,\n       left, split,\n       exact hp, exact hq,\n       right, split,\n       exact hp, exact hr\n     qed\n\n2) \"We can illustrate the idea in Lean, by proving a more complicated version of the theorem introduced in the previous exercise.\"\n \n theorem or_distrib {p q r : Prop} :\n   p \u2227 ("
  },
  {
    "output": "foo {p q r:Prop}: p \u2228 (q \u2227 r) \u27f9 (p \u2228 q) \u2227 (p \u2228 r) "
  },
  {
    "output": "(a b c : Prop) : (a \u2228 b) \u2227 c \u2194 (a \u2227 c) \u2228 (b \u2227 c) "
  },
  {
    "output": "(P Q R : Prop) : (P \u2228 Q) \u2227 R \u2192 (P \u2227 R) \u2228 (Q \u2227 R) "
  },
  {
    "output": "(P Q R : Prop): (P \u2228 Q) \u2227 R \u2192 (P \u2227 R) \u2228 (Q \u2227 R) "
  },
  {
    "output": "(a b c: Prop) : (a \u2228 b) \u2227 c \u2194 (a \u2227 c) \u2228 (b \u2227 c) "
  },
  {
    "output": "(P Q R : Prop) : (P \u2228 Q) \u2227 R \u2194 (P \u2227 R) \u2228 (Q \u2227 R) "
  },
  {
    "output": "{a b c : Prop} :\na \u2228 b \u2227 c \u2194 (a \u2228 b) \u2227 (a \u2228 c) "
  },
  {
    "output": "{a b c : Prop} :\n(a \u2227 b) \u2228 c \u2194 (a \u2228 c) \u2227 (b \u2228 c) "
  },
  {
    "output": "{a b c : Prop} :\na \u2228 (b \u2227 c) \u2194 (a \u2228 b) \u2227 (a \u2228 c) "
  },
  {
    "output": "{a b c : Prop} :\n(a \u2227 b) \u2228 c \u2194 (a \u2228 c) \u2227 (b \u2228 c) "
  },
  {
    "output": "{a b c : Prop} : \n(a \u2227 b) \u2228 c \u2194 (a \u2228 c) \u2227 (b \u2228 c) "
  },
  {
    "output": "disj_false_right_ident : \u2200 b : Prop, (false \u2228 b) \u2192 b.\n Change the assert into exact:\n theorem disj_false_right_ident (b : Prop) (H : false \u2228 b) : b "
  },
  {
    "output": "left_identity_for_or : \u2200 p : Prop , false \u2228 p \u2192 p "
  },
  {
    "output": "false_is_left_id_false_disj (p : Prop) : false \u2228 p \u2192 p "
  },
  {
    "output": "left_identity_of_disjunction : false \u2228 p \u2192 p "
  },
  {
    "output": "not_or_self (p : Prop) : \u00ac p \u2228 p "
  },
  {
    "output": "(P Q : Prop) :\n ff \u2228 P \u2194 P "
  },
  {
    "output": "(P Q : Prop) : P \u2228 Q \u2192 P \u2228 False \u2228 Q "
  },
  {
    "output": "(p : Prop) :  p \u2228 false \u2194 p "
  },
  {
    "output": "(x : Prop) : false \u2228 x \u2192 x "
  },
  {
    "output": "(p : Prop) : (false \u2228 p) \u2194 p "
  },
  {
    "output": "{b : Prop} : False \u2228 b \u2194 b "
  },
  {
    "output": "{a : Prop} :\nfalse \u2228 a \u2194 a "
  },
  {
    "output": "{a : Prop} :\nfalse \u2228 a \u2194 a "
  },
  {
    "output": "{a : Prop} :\na \u2228 false \u2194 a "
  },
  {
    "output": "{a : Prop} :\nfalse \u2228 a \u2194 a "
  },
  {
    "output": "and_or_uu : (1 : set \u03b1 \u2192 set \u03b1) \u2227 (1:set \u03b1 \u2192 set \u03b1 )\u21d2 1 "
  },
  {
    "output": "disj_False_right_identity : \u2200 P : Prop , P \u2228 False \u2192 P "
  },
  {
    "output": "right_identity_of_false : false \u2228 (\u2200 (P : Prop), P) "
  },
  {
    "output": "disj_ff : false \u2228 false "
  },
  {
    "output": "disj_false_right ( a : Prop ) : a \u2228 false \u2194 a "
  },
  {
    "output": "(P : Prop) : P \u2228 False \u2194 P "
  },
  {
    "output": "(P : Prop) : P \u2228 False <-> P "
  },
  {
    "output": "(p : Prop) : p \u2228 false = p "
  },
  {
    "output": "(x : False) : x \u2228 false = true "
  },
  {
    "output": "(P Q : Prop) : (P \u2228 Q) \u2227 \u00acP \u2192 Q "
  },
  {
    "output": "{a : Prop} :\na \u2228 False \u2194 a "
  },
  {
    "output": "{a : Prop} :\na \u2228 False \u2194 a "
  },
  {
    "output": "{a : Prop} :\na \u2228 false \u2194 a "
  },
  {
    "output": "{a : Prop} :\na \u2228 false \u2194 a "
  },
  {
    "output": "{a : Prop} :\na \u2228 false \u2194 a "
  },
  {
    "output": "left_id_true : true \u2227 (a \u2227 b) = a \u2227 b "
  },
  {
    "output": "left_id_conjunction (A B : Prop) (h1 : A) (h2 : B) : (True \u2227 A) "
  },
  {
    "output": "test_is_left_identity : true && true = true "
  },
  {
    "output": "prop_left_id_conj : \u2200 P : Prop, true \u2227 P \u2194 P "
  },
  {
    "output": "true_and_iff_left (P Q : Prop) : (true \u2227 P) \u2194 P "
  },
  {
    "output": "takes the form:\n \u2200 p q : Prop, true \u2227 p \u2194 p "
  },
  {
    "output": "(a b : Prop) :\n true \u2227 a \u2194 a "
  },
  {
    "output": ": true && x <-> x "
  },
  {
    "output": "(P Q : Prop) : P \u2227 True \u2194 P "
  },
  {
    "output": ": \u2200 P : Prop, true \u2227 P \u2194 P "
  },
  {
    "output": "{a : Prop} : (true \u2227 a) \u2194 a "
  },
  {
    "output": "{a : Prop} : (true \u2227 a \u2194 a) "
  },
  {
    "output": "{a : Prop} :\na \u2227 true \u2194 a "
  },
  {
    "output": "{a : Prop} :\nTrue \u2227 a = a "
  },
  {
    "output": "{p : Prop} : True \u2227 p \u2192 p "
  },
  {
    "output": "true_and_true : (true \u2227 true) = true "
  },
  {
    "output": "right_identity_and : \u2200 ( p : Prop ), ( p \u2227 true ) = p "
  },
  {
    "output": "right_id_conj : \u2200 P : Prop , P \u2227 True \u2194 P "
  },
  {
    "output": "right_identity : \u2200 (b : Prop ), True \u2227 b \u2194 b\n| b "
  },
  {
    "output": "conj_true_right (H: A \u2227 True) : A "
  },
  {
    "output": ": \u2200 p : Prop, p \u2227 true "
  },
  {
    "output": ": \u2200 p : Prop, p \u2227 true \u2194 p "
  },
  {
    "output": "(P : Prop) : P \u2227 true \u2194 P "
  },
  {
    "output": "(p q : Prop) : p \u2227 true \u2194 p "
  },
  {
    "output": "(P Q : Prop) : P \u2227 True \u2192 P "
  },
  {
    "output": "{a : Prop} :\na \u2227 true \u2194 a "
  },
  {
    "output": "{a : Prop} :\na \u2227 True \u2194 a "
  },
  {
    "output": "{a : Prop} :\na \u2227 true \u2194 a "
  },
  {
    "output": "{a : Prop} :\na \u2227 true \u2194 a "
  },
  {
    "output": "{a : Prop} : \na \u2192 a \u2227 True "
  },
  {
    "output": "disj_true_left_ann : left_ann \u03bb x, x \u2295 True "
  },
  {
    "output": "h3 : true \u2228 (true \u2227 false) "
  },
  {
    "output": "pp_or_l_ann\n  (n : \u2115)\n  (P : \u2115 \u2192 Prop) : True \u2228 P n \u2194 P n "
  },
  {
    "output": "true_or_left_annihilator : \u2200 P : Prop, P \u2192 true \u2228 P "
  },
  {
    "output": "an_l { a b : Prop } : a \\/ b -> True => (assume h : a \\/ b, trivial) .\n\nAs noted above, we need to specify the types when testing by hand. In the formal proof, we don't need to specify any types, since they are all automatically inferred.\n\nThe conclusion of a theorem is a Prop, so reasoning in the theorem proceeds with intuitionistic logic. This means we can't directly use classical theorems like excluded middle.\n\nLet's prove the right identity law. It's very similar to the above proof.\n\ntheorem id_r { a : Prop } : a -> a \\/ False "
  },
  {
    "output": "{P : Prop} (hp : P) :\n hp \u2194 true \u2228 P "
  },
  {
    "output": "[\u2200 P Q : Prop, true_of_true \u2192 P \u2228 Q]\n\nNatural language version: \"Every proposition has a left annihilator for disjunction.\" Translate the natural language version to a Lean mathlib version:\n theorem [\u2200 P : Prop, \u2203 (Q : Prop) (h : true_of_true \u2192 P \u2228 Q)] "
  },
  {
    "output": "true_lor : \u2200 (p q : Prop), (True \u2228 p) = True "
  },
  {
    "output": "false_or_true (x : bool) : true || x = true "
  },
  {
    "output": "(P Q : Prop) :\n True \u2192 P \u2228 Q "
  },
  {
    "output": " :\nTrue \u2228 a \u2194 True "
  },
  {
    "output": "{a : Prop} :\ntrue \u2228 a \u2194 true "
  },
  {
    "output": "{a : Prop} :\na \u2228 True \u2194 True "
  },
  {
    "output": "{a : Prop} :\nTrue \u2228 a \u2194 True "
  },
  {
    "output": "{a : Prop} :\nTrue \u2228 a \u2194 True "
  },
  {
    "output": "proposition_True_is_right_annihilator :\n  \u2200 A, (true \u2228 A) = true\n "
  },
  {
    "output": "right_ann_disj : Prop \u2192 true \u2228 P \u2194 P "
  },
  {
    "output": "true_or_false : true \u2228 false "
  },
  {
    "output": "true_is_right_annihilator_for_or (p q : Prop): (True \u2227 p) \u2228 q \u2194 p \u2228 q "
  },
  {
    "output": "true_right_annihilator : 1 \u2228 x = 1 "
  },
  {
    "output": "[right_zero_monoid_add (Prop)] (a : Prop) :\n true \u2228 a = a "
  },
  {
    "output": "(P Q : Prop) : True \u2192 P \u2228 Q "
  },
  {
    "output": "(a b : Prop) : true \u2192 a \u2228 b "
  },
  {
    "output": "(P Q : Prop): P \u2228 Q \u2192 True "
  },
  {
    "output": ": \u2200 a b : Prop, a \u2228 b \u2192 true "
  },
  {
    "output": "{a : Prop} :\na \u2228 true \u2194 true "
  },
  {
    "output": "{a : Prop} :\na \u2228 true "
  },
  {
    "output": "{a : Prop} :\na \u2228 true \u2194 true "
  },
  {
    "output": "{a : Prop} :\na \u2228 true \u2194 true "
  },
  {
    "output": "{p : Prop} :\np \u2228 True \u2194 True "
  },
  {
    "output": "false_and_left_annihilator : \u2200 {a : Prop}, false \u2227 a \u2192 a "
  },
  {
    "output": "left_conjunction_annihilator_iff : \u2200 p, false \u2192 p \u2227 q "
  },
  {
    "output": "help (h : P \u2227 False) : P "
  },
  {
    "output": "there_is_a_left_annihilator_for_conjunction : false \u2227 P = false "
  },
  {
    "output": "false_is_left_annihilator_for_conjunction : \u2200 (A : Prop), false \u2227 A \u2192 A "
  },
  {
    "output": "pfalse_l_annihilator (p q : Prop) (hp : p) : p \u2227 false \u2192 false "
  },
  {
    "output": "(p q : Prop) :\n (\u22a5 \u2227 p) = \u22a5 "
  },
  {
    "output": ": \u00ac (P \u2227 Q) "
  },
  {
    "output": "{P Q : Prop} (h : P \u2227 Q) : (False \u2194 P \u2227 Q) "
  },
  {
    "output": ": \u2200 (a b : Prop), false \u2192 a \u2227 b \u2192 false "
  },
  {
    "output": "{a : Prop} :\na \u2227 false \u2194 false "
  },
  {
    "output": "{p : Prop} :\nfalse \u2227 p \u2194 false "
  },
  {
    "output": "{a : Prop} :\nFalse \u2227 a \u2194 False "
  },
  {
    "output": "{p q : Prop} :\nFalse \u2227 p \u2194 False "
  },
  {
    "output": "{a b : Prop} : False \u2227 a \u2194 False "
  },
  {
    "output": "thm_whatever : (false \u2227 P) = false "
  },
  {
    "output": "Q1c : \u00ac (false \u2227 false) "
  },
  {
    "output": "and.right_ann : \u00ac (A \u2227 false) "
  },
  {
    "output": "false_and_right_annihilator : \u2200 x : Prop,\n   x \u2227 false \u2192 x \u2227 false "
  },
  {
    "output": ": not false \u2192 p \u2227 false \u2192 p "
  },
  {
    "output": ": \u00ac (p \u2227 q) \u2194 \u00ac p \u2228 \u00ac q "
  },
  {
    "output": ": False ^* 1%c "
  },
  {
    "output": "a_and_b_eq_ff (a b : Prop) : a \u2227 b \u2194 false "
  },
  {
    "output": "(P Q : Prop) :\n P \u2227 False \u2192 False "
  },
  {
    "output": "FALSE_and_right_annihilator :\n(False:Prop) \u2227 p \u2192 p "
  },
  {
    "output": "{a b : Prop} :\na \u2227 False \u2194 False "
  },
  {
    "output": "{a : Prop} :\n(False \u2227 a) \u2194 False "
  },
  {
    "output": "{P Q : Prop} : P \u2227 False \u2194 False "
  },
  {
    "output": "(a : Prop) :\nFalse \u2227 a \u2194 False "
  },
  {
    "output": "{a : Prop} : (false \u2227 a) \u2194 false "
  },
  {
    "output": "self_eq : \u2200 p:Prop, p = p\n   using_well_founded { rel_tac "
  },
  {
    "output": "my_thm_1: \u2200 P:Prop, P \u2194 P "
  },
  {
    "output": "prop_eq_self : \u2200 ( p : Prop ) , p = p "
  },
  {
    "output": "equiv_eq (p : Prop) : p \u2243 p "
  },
  {
    "output": "Q109 "
  },
  {
    "output": "(p : Prop) : p \u2194 p "
  },
  {
    "output": "(P : Prop) : P \u2194 P "
  },
  {
    "output": "(P : Prop) : P \u2194 P "
  },
  {
    "output": "(P : Prop) : P \u2194 P "
  },
  {
    "output": "(P Q : Prop) : P \u2194 Q "
  },
  {
    "output": "{a : Prop} : a \u2248 a "
  },
  {
    "output": "{\u03b1 : Type u_1} (p : virtual_val \u03b4 \u03b1) :\np = p "
  },
  {
    "output": "{a : Prop} :\na \u2248 a "
  },
  {
    "output": "{P : Prop} :\niff.refl P "
  },
  {
    "output": "{P : Prop} :\n(P \u2194 P) \n\nNatural language version: \"Every proposition is equivalent to the negation of its negation.\" Translate the natural language version to a Lean mathlib version:\n theorem {P : Prop} :\n(P \u2194 \u00ac\u00acP) "
  },
  {
    "output": ":  \u2200 \u2983 p : Prop \u2984, p \u2194 p \u2227 p "
  },
  {
    "output": "EveryPropIsEquivalentToConjunction (p : Prop) : p <-> (p \u2227 p) "
  },
  {
    "output": ": (a \u2227 a) \u2194 a "
  },
  {
    "output": "every_prop_is_equivalent_to_the_conjunction_with_itself : \u2200 p : Prop , p \u2194 (p \u2227 p) "
  },
  {
    "output": "prop_pow_self {p : Prop} : p \u2194 (p \u2227 p) "
  },
  {
    "output": "(\u03b1 : Prop) :\n \u03b1 \u2194 (\u03b1 \u2227 \u03b1) "
  },
  {
    "output": "(P : Prop) : P <-> P \u2227 P "
  },
  {
    "output": "(p : Prop) :\n p \u2194 p \u2227 p "
  },
  {
    "output": "(P : Prop) : P \u2194 (P \u2227 P) "
  },
  {
    "output": "(P : Prop) : P \u2194 P \u2227 P "
  },
  {
    "output": "{a : Prop} : a \u2194 a \u2227 a "
  },
  {
    "output": "{a : Prop} :\na \u2194 a \u2227 a "
  },
  {
    "output": "{a : Prop} :\na \u2194 (a \u2227 a) "
  },
  {
    "output": "{a : Prop} : a \u2194 a \u2227 a "
  },
  {
    "output": "{a : Prop} :\na \u2194 (a \u2227 a) "
  },
  {
    "output": "Ex_falso : P \u2194 \u00ac P \u2192 false "
  },
  {
    "output": "twice_is_or_self : \u2200 p:Prop, p \u2261 (p \u2228 p) "
  },
  {
    "output": "logic_equivalent_to_itself : \u2200 (p : Prop), p \u2194 p "
  },
  {
    "output": "discussion3_fast : \u2200 (P : Prop), (P \u2228 P) \u2194 P "
  },
  {
    "output": "prop_disjunction (\u03d5 : Prop) : (\u03d5 \u2228 \u03d5) \u2194 \u03d5 "
  },
  {
    "output": "(P : Prop) : P \u2194 P \u2228 P "
  },
  {
    "output": "(P : Prop) : P \u2194 (P \u2228 P) "
  },
  {
    "output": "(P : Prop) : P \u2194 P \u2228 P "
  },
  {
    "output": "(p q : Prop) :\n p \u2194 p \u2228 q "
  },
  {
    "output": "(P : Prop) :\n P \u2194 (P \u2228 P) "
  },
  {
    "output": "{a : Prop} :\na \u2194 a \u2228 a "
  },
  {
    "output": "{a : Prop} : a \u2194 a \u2228 a "
  },
  {
    "output": "{a : Prop} :\na \u2194 a \u2228 a "
  },
  {
    "output": "{a : Prop} :\na \u2194 (a \u2228 a) "
  },
  {
    "output": " {a : Prop} :\na \u2194 a \u2228 a "
  },
  {
    "output": "test2: \u2200 (\u03b1 : Sort*) (X : \u03b1 \u2192 Prop), true\n "
  },
  {
    "output": "Q28 : reflexive (prop_equiv) "
  },
  {
    "output": "reflexive ( a : Prop ) : a \u2194 a "
  },
  {
    "output": "of empathy\n| \"p \u2194 p\"\n\n--not sure what the natural language version is supposed to be...\n\nend empathy --equivalence_of_propositions_is_a_reflexive_relation\n\nsection equality_of_types_is_a_reflexive_relation\n\n/-\n1.1.12. Equalities of types are reflexive.\n-/\n\n\n-- Natural language version: \"Reflexive relation.\" Translate the natural language version of the empty collection of statements to a Lean mathlib version:\n axiom reflexive\n--no axiom is needed if you're only doing the reflexive relation\n\n-- Natural language version: \"E"
  },
  {
    "output": "prop_equiv_rel_is_refl ( S : Prop ): reflexive ( \u2261  S ) "
  },
  {
    "output": ": reflexive _ "
  },
  {
    "output": "(P : Prop) : P \u2194 P "
  },
  {
    "output": "(p : Prop) : p \u2194 p "
  },
  {
    "output": "(p : Prop) : p \u2194 p "
  },
  {
    "output": "(p : Prop) : p \u2194 p "
  },
  {
    "output": "{p\u2081 p\u2082 : Prop} :\nreflexive (p\u2081 \u2243 p\u2082) "
  },
  {
    "output": "{a b : Prop} :\nreflexive ((\u2261) a b) "
  },
  {
    "output": "{p q : Prop} : reflexive eq fls\n\nNatural language version: \"Equivalence of predicates on a fixed type `\u03b1` is a reflexive relation.\" Translate the natural language version to a Lean mathlib version:\n theorem {\u03b1 : Type u_1} {p q : \u03b1 \u2192 Prop} : reflexive eq fls\n\nNatural language version: \"Equivalence of propositions is an equivalence relation.\" Translate the natural language version to a Lean mathlib version:\n theorem {p q : Prop} : equivalence_relation eq fls\n\nNatural language version: \"Equivalence of predicates on a fixed type `\u03b1` is an equivalence relation.\" Translate"
  },
  {
    "output": "{p q : Prop} :\nreflexive (r : p \u2194 q) "
  },
  {
    "output": "{\u03b1 : Type u_2} (a : Prop) :\na \u2243 a "
  },
  {
    "output": "symm_of_equiv {\u03b1 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [is_equivalence r] : symmetric r "
  },
  {
    "output": "equiv_symm : \u2200 p q : Prop, p \u2261 q \u2192 q \u2261 p "
  },
  {
    "output": "symmetric_equivalence : \u2200 (p q : Prop), (p \u2194 q) \u2192 (q \u2194 p) "
  },
  {
    "output": "symm_equivp (a b : Prop) : (a <-> b) -> (b <-> a) "
  },
  {
    "output": "symm_iff (p q : Prop) : (p \u2194 q) \u2194 (q \u2194 p) "
  },
  {
    "output": "{\u03b1 : Sort*} (P Q : \u03b1 \u2192 Prop) : (P \u2194 Q) \u2194 (Q \u2194 P) "
  },
  {
    "output": "{X} (P Q : X \u2192 Prop) : (P \u2194 Q) \u2194 (Q \u2194 P) "
  },
  {
    "output": "(p q : Prop) : p \u2194 q \u2192 q \u2194 p "
  },
  {
    "output": "(x y : Prop) :\n x \u2248 y \u2192 y \u2248 x "
  },
  {
    "output": "(a b : Prop) :\n a \u2194 b \u2192 b \u2194 a "
  },
  {
    "output": "{p : Prop} (z : \u22a5 = p) : p = \u22a5 "
  },
  {
    "output": "{\u03b1 : Sort u_1} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} :\nsymm R "
  },
  {
    "output": "{p q : Prop} :\np \u2194 q \u2194 q \u2194 p "
  },
  {
    "output": "{p q : Prop} : p \u2243 q \u2192 q \u2243 p "
  },
  {
    "output": ": symmetric setoid.r "
  },
  {
    "output": "trans_equiv_of_equiv {P Q R : Prop} (pq : P \u2194 Q) (qr : Q \u2194 R) : P \u2194 R\n | p "
  },
  {
    "output": "lemma(p q r : Prop) (hp: p) (hq: p \u2194 q) (hr: q \u2194 r) : p \u2194 r "
  },
  {
    "output": "equivalence_of_propositions_is_transitive_relation (X Y Z : Prop) : (X \u2194 Y) \u2192 (Y \u2194 Z) \u2192 (X \u2194 Z) "
  },
  {
    "output": "eq_prop_trans (p q r : Prop) : p = q \u2192 q = r \u2192 p = r "
  },
  {
    "output": "transitivity_of_equivalence_of_propositions : transitive ((=) : Prop \u2192 Prop \u2192 Prop) "
  },
  {
    "output": "{P Q R : Prop} (h1 : P \u2194 Q) (h2 : Q \u2194 R) :\n P \u2194 R "
  },
  {
    "output": "(\u03b1 : Prop) : equivalencey.trans (@\u2248 \u03b1) "
  },
  {
    "output": "(P : Prop) (Q : Prop) (R : Prop)\n (hPQ : P \u2194 Q) (hQR : Q \u2194 R) :\n P \u2194 R "
  },
  {
    "output": "(P Q R : Prop) (HPQ : P \u2194 Q) (HQR : Q \u2194 R) :\n  P \u2194 R "
  },
  {
    "output": "(X : Type*) [classical_prop X] (p q r : X)\n (h1 : p \u2194 q) (h2 : q \u2194 r) : p \u2194 r "
  },
  {
    "output": "trans_iff_trans {p q r : Prop} (h\u2081 : p \u2194 q) (h\u2082 : q \u2194 r) :\np \u2194 r "
  },
  {
    "output": "{p q r : Prop} (h\u2081 : p \u2194 q) (h\u2082 : q \u2194 r) :\np \u2194 r "
  },
  {
    "output": "{p q r : Prop} (h\u2081 : equivalent p q) (h\u2082 : equivalent q r) :\nequivalent p r "
  },
  {
    "output": "{p q r : Prop} (h\u2081 : p ~ q) (h\u2082 : q ~ r) :\np ~ r "
  },
  {
    "output": "{a b c : Prop} (hab : a \u2194 b) (hbc : b \u2194 c) :\n(a \u2194 c) "
  }
]