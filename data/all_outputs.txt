theorem every_prop_implies_itself (p : Prop) : p → p 
theorem P_implies_P : ∀ p : Prop, (p → p) .  Theorem self_implies : ∀ p : Prop, p → p. Proof.   intros p.   intros q.     exact q. Qed.  Print self_implies.  Theorem impl_hself : (∀ p : Prop, p → p) → (∀ h : ∀ p : Prop, p → p, h = self_implies). Proof.   intros hA.    apply funext.   intro h.    apply funext.   intro p.    apply fun
theorem : (∀ P : Prop, P → P) 
theorem every_prop_implies_itself : ∀ (p : Prop), p → p 
theorem implies_self (p : Prop) : p → p 
theorem implies_self (P : Prop) : P → P 
theorem implies_self (P : Prop) : P → P 
theorem implies_itself (p : Prop) : p → p 
theorem a_self_imply_a (a : Prop) : a → a 
theorem p_implies_p (P : Prop) :  P → P 
theorem implies.refl{p : Prop} (h : p) : implies p p 
theorem self_implies (p : Prop) : p → p 
theorem implies.refl {a : Prop} : implies a a 
theorem implies.irrefl{a : Prop} (ha : a) : implies a a 
theorem implies.refl{p : Prop} : implies p p 
theorem self₁ : ∀ {α : Type}, α → α . . . } -/ /-  (1) To prove this theorem, try to use the tactic apply. It may be a challenge to figure out  how to state the apply tactic, because the premise on the left-hand side of the colon is a   universal quantification, while that on the right-hand side is an existential quantification.   The tactics `intro` and `apply` interact with each other, so you may also need to use an   appropriate intro tactic before your apply. -/ theorem self₁ : ∀ {α : Type}, α → α 
theorem id_map_self (X : Type) : X → (X → X) 
theorem exists_id ( α : Type ) : ∃ id : α → α , id = λ x : α , x 
theorem t2 : ∀ (A : Type), A → A 
theorem iota_id : ∀ X , ι X = id =ₚ X 
theorem function_from_any_type_to_itself (X : Type*) :  function X X 
theorem it_self_fun (X : Type*) : X →. X 
theorem function_from_any_type_to_itself (X : Type*) :  ∃ f : X → X, true 
theorem exists_to_itself (X : Type) : ∃ f : X → X, ∀ x : X, f x = x 
theorem any_type_to_itself_has_id (X : Type*) :  function X 
theorem exists_f{α : Type u} : ∃ (g : α → α), true 
theorem function.id{α : Sort u} : α → α 
theorem exists_self{α : Type u} : ∃ (f : α → α), true 
theorem idmap_is_function{α : Type u} : function α 
theorem exists_self₂{α : Sort u} : ∃ (f : α → α), ∀ (x : α), f x = x 
theorem some_prop_true : some_prop → true 
theorem True_implies_True : ∀ { P : Prop }, P → True 
theorem true_!(p : Prop) : p → (⊤ : Prop) 
theorem implication : ( ∀ P : Prop , P → True) 
theorem foo ( P : Prop ) : P → True 
theorem implies_true : ∀ P : Prop, P → true 
theorem all_props_imp_true : ∀ (p : Prop), p → true 
theorem true_implies_any (P : Prop) : P → true 
theorem imp_true_iff_true (P : Prop) : P → (P ↔ true) 
theorem true_of_any_prop (p : Prop) : p → true 
theorem true_iff_eq.elim(p : Prop) (h : p ↔ true) : p 
theorem classical.prop_true{α : Sort u_1} (H : α) : True 
theorem implies.of_forall{p : Prop} (h : p) : implies p true 
theorem true_implies_iff (p : Prop) : p → true 
theorem exists_true{p : Prop} (h : p) : exists (h_1 : true), true 
theorem ex1 ( A : Type ) ( f : A → punit ) : ∀ a : A , f a = punit . star 
theorem lang_mathlib : ∀ { T : Type }, T → Unit 
theorem has_func_to_unit {X : Type} : (Unit → X) → true 
theorem t2 {α : Type} : α → unit 
theorem something ( X : Type ) : ( X → Unit ) 
theorem unit_has_one_function (X : Type*) :  nonempty (Type u → X) 
theorem to_unit_function_exists_of_subtype (T : Type*) [subtype T] :  ∃ (f : T → empty), true  Natural language version: "If G is commutative and R is a subring of G, then R is an ideal" Translate the natural language version to a Lean mathlib version (with "alpha" replaced by "R" and "beta" replaced by "G"):  theorem subring_of_ideal (alpha beta : Type*) [comm_ring beta] [subring alpha] :  is_ideal alpha  Natural language version: "If A is a subassociative algebra then A is a subring
theorem inference_rule_1 (A : Type*) : (∀ {B : Type*}, B → A) → A 
theorem has_choice (α : Type*) : Type* 
theorem function_from_any_type_to_unit (X : Type*) :  Σ f : X → unit, true 
theorem exists_to_units{α : Sort u} : nonempty α → nonempty units 
theorem to_Unit{X : Type u_1} [has_coe X Unit] : Unit → X 
theorem unit.of{X : Type u} {x : X} : unit.{u} 
theorem unit.forget : Π {X : Type u_1}, X → Unit |_ _ 
theorem inhabited.rec_on{M : Type u_1} [h : inhabited M] {C : M → Sort*} (a : M) (H : C a) : ∃ f : Π (a : M), C a, f ⟨a, H⟩ = H 
theorem example2 : ∀P : Prop, False → P 
theorem every_prop_from_false: forall P : Prop, false → P 
theorem my_trivial_theorem' : false → ∀ ( p : Prop ), p 
theorem every_prop_follows_from_false : ∀ (P : Prop), P 
theorem not_true_eq_false : ~ true ↔ false 
theorem false_is_contradiction (P : Prop) (hfalse : false) : P 
theorem trivial_implication_from_false (P : Prop) : false → P 
theorem from_false (P : Prop) : P 
theorem every_prop_above_false (P : Prop) : false → P 
theorem false_implies_any (P : Prop) : False → P 
theorem False_implies{a : Prop} : False → a 
theorem falsum_implies{α : Sort u_1} (h : false) (a : Prop) : a 
theorem false.elim{P : Prop} : false → P 
theorem false.rec{a : Prop} : False → a 
theorem false.elim(a : Prop) : a 
theorem empty_is_function (α : Type) : Empty → α 
theorem empty_is_init {A : Type*} : Empty → A 
theorem empty_to_any : Empty → Π (A : Sort u), A 
theorem ex ( α : Type ) : ∃ f : Empty → α , true 
theorem empty_to_type (X : Type) : Empty → X 
theorem empty_function_defined (X : Type*) :   {f : empty → X // ∀ (e : empty), f e = default X} 
theorem empty_type_has_no_functions_to_anything (X : Type*) :  nonempty (Empty → X) 
theorem function_from_empty (X : Type*) : (∅ → X) 
theorem empty_into (F : Type*) : Empty → F 
theorem exists_function_from_empty (X : Type*) :  ∃ f : Empty → X, true 
theorem exists_empty_fun (α : Type u_1) : ∃ (f₀ : pempty → α), ∀ (x : pempty), f₀ x = a 
theorem function.empty_is_functional{α : Type u_1} (a : Empty) : functional a 
theorem empty.elim{C : Type u_1} (e : Empty) : C 
theorem empty.of_subsingleton{α : Type u_1} [subsingleton α] : Empty → α 
theorem empty.func {α : Type u_1} : α → Empty 
theorem QMP ( P : Prop ) ( Q : Prop ) ( q : Q ) : P → P 
theorem foo ( P Q:Model ) : Model 
theorem Q_if_P ( P Q : Prop ) : P → Q → P 
theorem follows_from_assumption_of_true ( P Q : Prop ) :    ∀ ( P_is_true : P ), ( Q → P ) 
theorem P_Q (Q P : Prop) (QP : Q → P) (PP : P) : Q 
theorem imp.true_intro (P Q : Prop) (h : P) : P → Q 
theorem P_of_P_and_Q (P Q : Prop) (hP : P) (hPQ : P → Q) : Q 
theorem propositional_version (P Q : Prop) (h1 : P) : P → Q 
theorem p_imp_p_of_p_imp_q_of_p (p q : Prop) (h : p → q) (hp : p) :  p 
theorem p_implies_p_under_decidability_of_q (P Q : Prop) :  P → (Q → P) 
theorem of_true{p q : Prop} (q_true : q) : p → q 
theorem exists.elim{p q : Prop} (h₁ : p) (H : exists.{u} p, q) : q 
theorem idP{p : Prop} (h : p) : p 
theorem triv_imp{p q : Prop} (h : p) : q 
theorem assumption{p q : Prop} (h : p) : p → q 
theorem not_of_iff (P : Prop) : ¬P <-> P ⟹ false 
theorem contrapositive : ∀ p, ¬(p ↔ q) ↔ (q ↔ ¬ p) 
theorem not_iff_implies_False : p ↔ ¬ p 
theorem my_ne_iff_not_iff (a b : Prop) : (a ≠ b) ↔ (a → ¬ b) 
theorem not_iff_t_f : ∀ p : Prop, (¬ p) = (p → (false)) 
theorem neg_iff_implies_false (P : Prop) : (¬ P) ↔ (P → false) 
theorem negation_iff_false (P : Prop) :  ¬P ↔ (P → false) 
theorem iff_neg_iff_imp_false :  ∀ (p : Prop),  p ↔ ¬ p ↔ (p → false) 
theorem not_iff_implies_false (P : Prop) :   ¬P ↔ (P → false) 
theorem not_eq_iff_implies_false (P : Prop) : ¬ P ↔ (P → false) 
theorem not{a : Prop} : ¬a ↔ a → False 
theorem de_morgan_not_and_not{a b : Prop} : ♥(a ∨ b) ↔ ♥a ∧ ♥b 
theorem not_iff_not_imp{a : Prop} : ¬a ↔ (a → false) 
theorem not_iff_not{a : Prop} :  ¬a ↔ (a → false) 
theorem dne{a : Prop} : ¬¬a ↔ a 
theorem double_negation_elim ( P : Prop ) : P → ¬ ¬ P 
theorem double_negation.decidability : A → (A → false) → false 
theorem P_to_D !(P : Prop) :    P → ◻ P. You might use the tactic    exact(PN_to_D N)    where    def N (P : Prop) : Prop 
theorem      every_prop_implies_its_double_negation : ∀ P : Prop, (P → ¬¬P).  Qed.  Theorem modus_ponens: ∀ P Q : Prop, P → (P → Q) → Q. Proof.   intros P Q.   intros P_implies_Q QP.   apply P_implies_Q.   exact QP. Qed.  Theorem modus_tollens: ∀ P Q : Prop, (P → Q) → (¬Q → ¬P). Proof.   (* intros P Q
theorem implies_double_negation : ∀ (p : Prop), p → ¬ ¬ p 
theorem dneg_eq_impl_of_prop (p : Prop) :   p → ~~p 
theorem imp_double_neg (P : Prop) :  P → ¬¬P 
theorem dn_implies_prop (P : Prop) (hP : ¬¬P) : P 
theorem double_negation (P : Prop) : P → ¬ ¬ P 
theorem every_prop_implies_double_neg (p : Prop) :  (p → ¬¬p) 
theorem double_negation{p : Prop} : (p → ¬¬p) 
theorem imp_double_neg{a : Prop} : (a → ¬¬a) 
theorem not_not_ands {a : Prop} :    a → ¬¬a 
theorem implies_not_not{a : Prop} : a → ¬¬a 
theorem implies_not_not{a : Prop} : a → ¬¬a 
theorem implies_contrapos : ∀ A B: Prop, (A → B) → (¬B → ¬A) 
theorem contraposition (p q : Prop) (hpq : p → q) : ¬q → ¬p 
theorem contraposition : ∀ (p q : Prop), (p → q) → (¬ q → ¬ p). intros.      This can be translated to: ∀ (A B : Prop), (A → B) → (¬ B → ¬ A) .    Qed.  Axiom Modus_Ponens : forall (A B: Prop), (A -> B) -> A -> B.  Theorem and_commutative : forall (P Q : Prop),  P ∧ Q -> Q ∧ P . Proof. intros P Q. intro H. destruct H as [P1
theorem some_lemma' {p q : Prop} (h : p → q) : q → p 
theorem contraposition {A B C : Type} (implication : A → B → C) (a : A) (b : B) (h : ¬ C) :   false 
theorem contrapositive (P Q : Prop) : (P → Q) → (¬ Q → ¬ P) 
theorem contraposition_of_implication_of_implication : ∀ (P Q : Prop), (P → Q) → ¬Q → ¬P 
theorem imp_imp_contrapost (a b : Prop) : a → b → ¬ b → ¬ a 
theorem contraposition (p q : Prop) : (p → q) → ¬ q → ¬ p 
theorem contrapositive (P Q : Prop) (h : P → Q) : Q → P 
theorem implies.contrapose{p q : Prop} (h₁ : implies p q) : implies (not q) (not p) 
theorem iff.elim_left{p q : Prop} (H : p ↔ q) : q → p 
theorem implies.contrapos{p q : Prop} (h : implies p q) : implies (not q) (not p) 
theorem implies.contrapos{p q : Prop} : implies (implies p q) (implies (not q) (not p)) 
theorem implies.contra{p q : Prop} (h : implies p q) : implies (not q) (not p) 
theorem imp_trans (P Q R : Prop) : P → Q → R → (P → Q) → P → R 
theorem imp_trans (p q r : Prop) (h₁ : p → q) (h₂ : q → r) : p → r 
theorem imp_trans ( a b c : Prop ) : a → b → c → a 
theorem transit_of_impl : p → q → r → p → r 
theorem stuff : ∀ ( P Q R : Prop ), ( P → ( Q → R )) → ( P ∧ Q → R ) 
theorem mp (P Q R : Prop) (hpq : P → Q) (hqr : Q → R) : P → R 
theorem trans_of_implies_of_implies (P Q R : Prop) (hPQ : P → Q) (hQR : Q → R) :  P → R 
theorem implies_trans (A B C : Prop) : (A → B) → (B → C) → A → C 
theorem transitivity_of_implication (p q r : Prop) :  (p → q) → (q → r) → (p → r)
theorem impif_trans (P Q R : Prop) : (P → Q) → (Q → R) → (P → R) 
theorem mp{p q r : Prop} (h₁ : p → q) (h₂ : q → r) : p → r 
theorem implies.trans {p q r : Prop} (h₁ : p → q) (h₂ : q → r) : p → r 
theorem trans{α β γ} (h₁ : α → β) (h₂ : β → γ) : α → γ 
theorem trans (p q r : Prop) (hpq : p → q) (hqr : q → r) : p → r 
theorem trans_rv_into_rv_of_rv {p q r : Prop} (pf₁ : implies p q) (pf₂ : implies q r) : implies p r 
theorem iff_true_of_true_true {P Q : Prop} (h1 : P) (h2 : Q) : P ∧ Q 
theorem implies_tofa ( P Q : Prop ) : P → Q → P ∧ Q 
theorem and_flip : ∀{P Q : Prop}, P → Q → P ∧ Q 
theorem foo (P Q : Prop) : P → Q → P ∧ Q 
theorem and_of_two_true ( p : Prop ) ( q : Prop ) ( h : p ∧ q ) : p 
theorem true_and_true_is_true (P Q : Prop) (hP : P) (hQ : Q) : P ∧ Q 
theorem and_intro (p q : Prop) : p ∧ q → p 
theorem and_true_iff_true {P Q : Prop} (hP : P) (hQ : Q) :  P ∧ Q 
theorem propositions_P_and_Q_are_individualy_true (P Q : Prop) (b1 : P) (b2 : Q) :  P ∧ Q 
theorem and_true_intro (P Q : Prop) (HP : P) (HQ : Q) : P ∧ Q 
theorem and.intro{a b : Prop} (ha : a) (hb : b) : (a ∧ b) 
theorem and.intro{a b : Prop} (ha : a) (hb : b) : a ∧ b 
theorem and.intro{a b : Prop} (h₁ : a) (h₂ : b) : a ∧ b 
theorem and_true{p q : Prop} (hp : p) (hq : q) : p ∧ q 
theorem not_and_distrib{a b : Prop} : ¬(a ∧ b) ↔ ¬a ∨ ¬b 
theorem and_comm (a b : Prop) : a ∧ b → b ∧ a 
theorem and.comm (p q : Prop) : p ∧ q ↔ q ∧ p 
theorem ConjunctionCommutative : ∀ p q, p ∧ q → q ∧ p 
theorem and.comm : ∀ a b : Prop, a ∧ b → b ∧ a 
theorem myfirsttheorem : ∀ (P Q R: Prop), ⟨P ∧ Q,  (P ∧ Q) ∧ R ⟩ -> ⟨P ∧ Q,  Q ∧ P ⟩ 
theorem conjunction_commutative (P Q : Prop) : P ∧ Q ↔ Q ∧ P 
theorem and.comm (a b : Prop) : a ∧ b ↔ b ∧ a 
theorem and_comm (p q : Prop) : p ∧ q ↔ q ∧ p  
theorem and_comm (p q : Prop) : p ∧ q ↔ q ∧ p 
theorem and_comm (b1 b2 : bool) :  b1 ∧ b2 = b2 ∧ b1 
theorem and_comm{a b : Prop} : a ∧ b ↔ b ∧ a 
theorem and_comm{a b : Prop} : a ∧ b ↔ b ∧ a 
theorem and.comm{a b : Prop} : a ∧ b ↔ b ∧ a 
theorem and_comm{a b : Prop} : a ∧ b ↔ b ∧ a 
theorem and_comm{a b : Prop} : a ∧ b ↔ b ∧ a 
theorem conj_assoc : ∀ { 𝒜 : Prop } { 𝒞 : Prop } { 𝒟 : Prop },     (𝒜 ∧ 𝒞) ∧ 𝒟 ↔ 𝒜 ∧ (𝒞 ∧ 𝒟) 
theorem and_assoc :     ∀ ( (a b c : Prop), a ∧ (b ∧ c) ↔ (a ∧ b) ∧ c 
theorem conj.assoc : ∀ {a b c : Prop}, a ∧ (b ∧ c) ↔ (a ∧ b) ∧ c 
theorem and.assoc : ∀ p q r: Prop, p ∧ (q ∧ r) ⟹ (p ∧ q) ∧ r 
theorem left_associativity_conjunction (p q r : Prop) : (p ∧ q) ∧ r ⟹ p ∧ (q ∧ r) 
theorem and.assoc (a b c : Prop) : a ∧ b ∧ c ↔ a ∧ (b ∧ c) 
theorem and.assoc (p q r : Prop) : (p ∧ q ∧ r) ↔ (p ∧ (q ∧ r)) 
theorem and_assoc : ∀ (P Q R : Prop), P ∧ Q ∧ R ↔ P ∧ (Q ∧ R) 
theorem and.assoc : ∀ (a b c : Prop), a ∧ (b ∧ c) ↔ (a ∧ b) ∧ c 
theorem and_assoc (a b c : Prop) : a ∧ (b ∧ c) ↔ (a ∧ b) ∧ c 
theorem and_assoc{a b c : Prop} : (a ∧ b) ∧ c ↔ a ∧ (b ∧ c) 
theorem and_assoc{a b c : Prop} : (a ∧ b) ∧ c ↔ a ∧ (b ∧ c) 
theorem and_associative{a b c : Prop} : a ∧ b ∧ c ↔ a ∧ (b ∧ c) 
theorem and_assoc {a b c : Prop} : a ∧ b ∧ c ↔ a ∧ (b ∧ c) 
theorem and_assoc{a b c : Prop} : (a ∧ b) ∧ c ↔ a ∧ b ∧ c 
theorem disjunction_is_commutative ( A : Prop ) ( B : Prop ) : ( A ∨ B ) → ( B ∨ A ) 
theorem and.left.comm (a b c : Prop) : a ∧ b ∧ c → b ∧ a ∧ c 
theorem disjunction_is_commutative : ∀ ( P Q : Prop ), ( P ∨ Q ) ↔ ( Q ∨ P ) 
theorem prop_of_commutative_disjunction ( a b : Prop ) : ( a ∨ b ) ↔ ( b ∨ a ) 
theorem disjunction_commutative : ∀ a b : Prop, a ∨ b → b ∨ a 
theorem or_comm (P Q : Prop) : P ∨ Q ↔ Q ∨ P 
theorem exists_comm (A : Type*) (P Q: A → Prop):   (∃ x, P x ∨ Q x) ↔ (∃ x, Q x ∨ P x) 
theorem disjunction_commuative (p q : Prop) :  p ∨  q ↔ q ∨ p 
theorem disjunction_comm (p q : Prop) : (p ∨ q) ↔ (q ∨ p) 
theorem disjunction_is_commutative (p q : Prop) : p ∨ q ↔ q ∨ p 
theorem or_comm{a b: Prop} : a ∨ b ↔ b ∨ a 
theorem or_comm{a b : Prop} : a ∨ b ↔ b ∨ a 
theorem or_comm{a b : Prop} : a ∨ b ↔ b ∨ a 
theorem or_comm{a b : Prop} : a ∨ b ↔ b ∨ a 
theorem or_comm{a b : Prop} : a ∨ b ↔ b ∨ a 
theorem disjunction_associative: (a ∨ b) ∨ c → a ∨ (b ∨ c) 
theorem disjunction_is_assoc :    ∀ (p q r : Prop), p ∨ (q ∨ r) → (p ∨ q) ∨ r 
theorem disjunction_is_associative 
theorem disj_assoc (a b c : Prop) : a ∨ (b ∨ c) ↔ (a ∨ b) ∨ c 
theorem and_assoc : ∀ a b c : Prop, (a ∧ b) ∧ c ↔ a ∧ (b ∧ c) 
theorem or_assoc (P Q R : Prop) :  P ∨ (Q ∨ R) ↔ (P ∨ Q) ∨ R 
theorem or_comm (x y : Prop) : x ∨ y ↔ y ∨ x 
theorem or_assoc (P Q R : Prop) : (P ∨ Q) ∨ R ↔ P ∨ (Q ∨ R) 
theorem or_assoc (P Q R : Prop) :  P ∨ (Q ∨ R) ↔ (P ∨ Q) ∨ R 
theorem or.assoc (a b c : Prop) : a ∨ (b ∨ c) ↔ (a ∨ b) ∨ c 
theorem or_assoc{a b c : Prop} : (a ∨ b) ∨ c ↔ a ∨ (b ∨ c) 
theorem or_assoc{a b c : Prop} : (a ∨ b) ∨ c ↔ a ∨ (b ∨ c) 
theorem or_assoc{a b c : Prop} : (a ∨ b) ∨ c ↔ a ∨ (b ∨ c) 
theorem or_assoc{a b c : Prop} : a ∨ b ∨ c ↔ (a ∨ b) ∨ c 
theorem or_assoc{a b c : Prop} : a ∨ b ∨ c ↔ a ∨ c ∨ b 
theorem and_not_self_implies_false : ∀ p : Prop, p ∧ ¬ p → false 
theorem true_or_P_of_true_implies_true_or_Q ( ht : true ) ( hp : true ) ( hq : false ) : true 
theorem P_or_Q:  ∀ P Q:Prop,P → P ∨ Q 
theorem disj ( P Q : Prop ) ( hP : P ) : P ∨ Q 
theorem examples . disj_imp_of_tru P Q : ( P ↔ true ) → ( P ∨ Q ↔ true ) 
theorem disjunction_of_true_is_true (P Q : Prop) (hP : P) : P ∨ Q 
theorem true_or (P Q : Prop) (p : P) : P ∨ Q 
theorem true_or_Q_is_true (P Q : Prop) (HP : P) :  P ∨ Q 
theorem em (P Q : Prop) (h : P) : P ∨ Q 
theorem or_two_cases_p_true (P Q : Prop) : P → (P ∨ Q) 
theorem left_mem_right{P Q : Prop} (a : P)  : P ∨ Q 
theorem true_or{a b : Prop} : true → a ∨ b 
theorem or_of_true{P Q: Prop} (H : P) : P ∨ Q 
theorem dvd_true_intro{p : Prop} (h : p): p ∨ p 
theorem true_or{P Q : Prop} (hP : P) : P ∨ Q 
theorem disjunction :  ∀ (P Q : Prop), Q → (P ∨ Q) 
theorem true_is_true_disj : ∀ (P Q : Prop), Q → (P ∨ Q) 
theorem foo ( P Q : Prop) : Q -> *P \/ Q* 
theorem implication_disjunction : ∀ (P Q:Prop), (Q → (P ∨ Q)) 
theorem mylemma : ∀ P Q: Prop, (Q → (P ∨ Q)) 
theorem disjunction_true_of_true (m n : Prop) (hm : m) :  m ∨ n 
theorem prop.and_of_true_right  (P Q : Prop) (h : Q) :  P ∨ Q 
theorem disj_of_true (P Q : Prop) (hQ : Q) : P ∨ Q 
theorem true_or (P Q : Prop) (hq : Q) : P ∨ Q 
theorem true_disjunction_from_true (P Q : Prop) (hQ : Q) :  P ∨ Q 
theorem true_or{P Q : Prop} (H : Q) : P ∨ Q 
theorem false_or{a : Prop} : false ∨ a ↔ a 
theorem true_or{P Q : Prop} (h : Q) : P ∨ Q 
theorem or_true{P Q : Prop} (h : Q) : P ∨ Q 
theorem true_or{a b : Prop} (h : b) : a ∨ b 
theorem t : (P ∧ Q) ∨ R → (P ∨ R) ∧ (Q ∨ R) 
theorem and_distrib_of_or_left ( P Q R : Prop ) : ( P ∨ Q ) ∧ R → P ∧ R ∨ Q ∧ R 
theorem Disj_SD (hc : (c ∨ a) ∧ (c ∨ b)): c ∨ (a ∧ b) 
theorem my_theorem : (a ∧ b) ∨ c ↔ (a ∨ c) ∧ (b ∨ c) 
theorem left_distributes_over_lor (p q r : Prop) :  p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) 
theorem and_or_distrib_left (P Q R : Prop) : (P ∧ (Q ∨ R)) ↔ ((P ∧ Q) ∨ (P ∧ R)) 
theorem and_distributes_over_or (p q r : Prop) :  p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) 
theorem distrib_or_of_and.left (p q r : Prop) :  (p ∧ q) ∨ r ↔ (p ∨ r) ∧ (q ∨ r) 
theorem left_distribute_and_over_or (p q r : Prop) :  p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) 
theorem distribution.left (P Q R : Prop) : (P ∧ (Q ∨ R)) ↔ ((P ∧ Q) ∨ (P ∧ R)) 
theorem or_of_and_left{a b c : Prop} : a ∧ b ↔ c → a ∨ b 
theorem and_distrib_over_or{a b c : Prop} : a ∧ b ∨ a ∧ c ↔ a ∧ b ∨ c 
theorem and_or_distrib{a b c : Prop} : (a ∧ b) ∨ c ↔ (a ∨ c) ∧ (b ∨ c) 
theorem and_or_distrib{a b c : Prop} : a ∧ (b ∨ c) ↔ (a ∧ b) ∨ (a ∧ c) 
theorem or_distrib_and{a b c d : Prop} : (a ∧ b) ∨ (c ∧ d) ↔ (a ∨ c) ∧ (a ∨ d) ∧ (b ∨ c) ∧ (b ∨ d) 
theorem dne { X Y Z: Type }             [ dis_prop : negated_distributive_lattice X ]             ( a : X ) ( b : Y ) ( c : Z ): a ∧ ( b ∨ c ) → ( a ∧ b ) ∨ ( a ∧ c ) 
theorem nl1: (P ∧ Q) ∨ R ↔ (P ∨ R) ∧ (Q ∨ R) 
theorem conj_or : (p ∧ q) ∨ (p ∧ ¬q) 
theorem and_or_distrib_right (a b c : Prop) : a ∧ (b ∨ c) → (a ∧ b) ∨ (a ∧ c) 
theorem conf_dist_eq' : (p ∧ q) ∨ r ↔ p ∧ q ∨ r 
theorem conj_distrib_right (p q r : Prop) : (p ∧ (q ∨ r)) ↔ ((p ∧ q) ∨ (p ∧ r)) 
theorem and_distrib_right (a b c : Prop) : a ∧ (b ∨ c) ↔ (a ∧ b) ∨ (a ∧ c) 
theorem imp_and_distrib : ∀ P Q R : Prop, (P → Q ∧ R) ↔ (P → Q) ∧ (P → R) 
theorem right_conj_distr_to_disj (P Q R : Prop) :  P ∧ (Q ∨ R) ↔ (P ∧ Q) ∨ (P ∧ R)  Natural language version: "Conjunction left-distributes over disjunction." Translate the natural language version to a Lean mathlib version:  theorem left_conj_distr_to_disj (P Q R : Prop) :  (P ∨ Q) ∧ R ↔ (P ∧ R) ∨ (Q ∧ R)  Natural language version: "Conjunction right-distributes over implication." Translate the natural language version to
theorem conjunction_right_distributes_over_disjunction (p q r : Prop) : (p ∧ (q ∨ r)) ↔ ((p ∧ q) ∨ (p ∧ r)) 
theorem right_distributive{a b c : Prop} : a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c) 
theorem distrib {p q r : Prop} (hp : p) : (p ∧ q) ∨ r ↔ (p ∨ r) ∧ (q ∨ r) 
theorem distrib_right{a b c : Prop} : (a ∨ b) ∨ c ↔ a ∨ (b ∨ c) 
theorem or_and_distrib {a b c : Prop} : a ∨ b ∧ c ↔ a ∨ (b ∧ c) 
theorem conj_distrib{a b c : Prop} : (a ∨ b) → c ↔ (a → c) ∧ (b → c) 
theorem disj_distrib_of_conj :    ∀ (P Q R : Prop), (P ∨ Q) ∧ R ↔ (P ∧ R) ∨ (Q ∧ R) 
theorem disjunction_distributes_over_conjunction : ∀ { A B C : Prop },   A ∧ ( B ∨ C ) → ( A ∧ B ) ∨ ( A ∧ C ) 
theorem disjl_or_of_disjl {a b c: Prop}: (a ∨ b) ∧ c → (a ∨ c) ∧ (b ∨ c) 
theorem plays_soccer(x) : ∃ y : baseball, plays_baseball(y) ∧ plays_soccer(x)     
theorem dld :  ∀ p q r: Prop, p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) 
theorem or_left_distrib (p q r : Prop) :  p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) 
theorem or_and_distrib_left (p q r : Prop) :  (p ∨ q) ∧ r ↔ (p ∧ r) ∨ (q ∧ r) 
theorem or_and_distrib_left (P Q R : Prop) :  P ∨ (Q ∧ R) ↔ (P ∨ Q) ∧ (P ∨ R) 
theorem disjoint_and_left_distrib (a b c : Prop) : (a ∨ b) ∧ c ↔ (a ∧ c) ∨ (b ∧ c) 
theorem left_distributivity_over_conjunction (A B C : Prop) : A ∨ (B ∧ C) ↔ (A ∨ B) ∧ (A ∨ C) 
theorem or_distrib_and_left{a b c: Prop} : a ∨ (b ∧ c) ↔ (a ∨ b) ∧ (a ∨ c) 
theorem disj_and_distrib{a b c :Prop} : (a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c 
theorem or_distrib_left{a b c : Prop} : (a ∨ b) ∧ (a ∨ c) → a ∨ (b ∧ c) 
theorem and_or_distrib{a b c : Prop} : a ∧ (b ∨ c) ↔ (a ∧ b) ∨ (a ∧ c)  
theorem disj_left_distrib{a b c : Prop} : a ∨ (b ∧ c) ↔ a ∨ b ∧ a ∨ c 
theorem or_dist_of_and {b₁ b₂ c : Prop} (h₁ : b₁ ∧ c) (h₂ : b₂ ∧ c) : (b₁ ∨ b₂) ∧ c 
theorem my_theorem :  (∃ x, P x ∨ Q x) ↔ ((∃ x, P x) ∨ (∃ x, Q x)) 
theorem disjunction_distributes_over_conjunction (p q r : P) :   p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) 
theorem proof_mathlib_1: ∀ P Q R: Prop, ∀ P Q R: Prop, (P ∧ Q) ∨ (Q ∧ R) ↔ (P ∧ Q) ∨ (P ∃ R) 
theorem or_dist_and_over_or (a b c : Prop) : (a ∨ (b ∧ c)) = ((a ∨ b) ∧ (a ∨ c)).
theorem or_distributes_over_and : ∀ (P Q R : Prop), P ∨ (Q ∧ R) ↔ (P ∨ Q) ∧ (P ∨ R) 
theorem not_not_iff (p : Prop) : ¬¬p ↔ p 
theorem or_and_distrib_left (p q r : Prop) :  p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r)  
theorem adjunction_d_c (X : Type*) (F G : X → Prop) : (F ∨ G) ↔ (F → G) 
theorem or_right_distributes_over_and (x y z : Prop) :  (x ∨ y) ∧ (x ∨ z) ↔ (x ∨ (y ∧ z)) 
theorem or_distrib_over_and{a b c : Prop} : a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c) 
theorem disj_right_distrib{a b c : Prop} : a ∨ (b ∧ c) ↔ (a ∨ b) ∧ (a ∨ c) 
theorem distrib{X Y Z : Prop} : (X ∧ Y) ∨ Z ↔ X ∧ (Y ∨ Z) 
theorem and_or_distrib_both{a b c : Prop} : a ∧ b ∨ a ∧ c ↔ a ∧ (b ∨ c) 
theorem or_distrib{a b c : Prop} : a ∨ (b ∧ c) ↔ (a ∨ b) ∧ (a ∨ c) 
theorem false_or ( p : Prop ) : false ∨ p 
theorem left_identity_or : false ∨ A → A 
theorem false_or_left_identity ( x : bool ) : false ∨ x = x 
theorem left_id_false : ∀ (p: Prop), ff ∨ p ↔ p 
theorem zero_add : 0 + a = a 
theorem some_false_disjunction_lemmas (p q : Prop) :  (false ∨ p) ↔ p 
theorem left_id_false_disj:  ∀ P : Prop, false ∨ P → P 
theorem false_left_identity_of_or (C D : Prop) : false ∨ C ↔ C 
theorem false_disjunction_left_identity (a : Prop) :  false ∨ a ↔ a 
theorem false_left_identity : ∀ q : Prop, false ∨ q → q 
theorem or_false_left{a : Prop} : false ∨ a ↔ a 
theorem false_or{a : Prop}: false ∨ a <-> a 
theorem or_false_left{a : Prop} : false ∨ a ↔ a 
theorem false_or_right{a : Prop} : False ∨ a ↔ a 
theorem or_false_left{p : Prop} : False ∨ p ↔ p 
theorem right_id : ∀ P : Prop , P ∨ false → P 
theorem false_or (a : Prop) : false ∨ a 
theorem IdRight ( p : Prop ) : p ∨ False ↔ p 
theorem and_empty_is_left_id : ∀ a , ( a ∧ ⊥ : Prop ) ↔ a 
theorem False_or_self (p : Prop) : false ∨ p ↔ p  Proof: The natural language version is essentially to be proved "if false ∨ p then p". In the code below this is done by showing that if false then p, and if p then p. This is the commutative law for or statements. The prove function uses the premise, which is the if statement. The have function is used to introduce fake terms used for the proof to 'prove' real terms.   *)  -- False ∨ P ↔ P   theorem False_or_self {P : Prop} : false ∨ P ↔ P 
theorem false_is_disjunction_right_identity : ∀ p : Prop, p ∨ false ↔ p 
theorem false_disjunction_right_id (P : Prop) : P ∨ False → P 
theorem fasle_is_right_identity_of_or (a : Prop) : a ∨ False ↔ a 
theorem false_right_identity (p : Prop) : false ∨ p ↔ p 
theorem disj_false_right (P : Prop):    P ⊕ False ↔ P 
theorem false_or{a : Prop} : False ∨ a ↔ a 
theorem false_or_elim {a: Prop} :   a ∨ False ↔ a 
theorem or_false_right{a : Prop} : a ∨ false ↔ a 
theorem or_false{a : Prop} : a ∨ False ↔ a 
theorem false_or_distrib_right{a : Prop} : a ∨ false ↔ a 
theorem id_left : left_id true and 
theorem mul_one_eq_one : 1 * (1 : mynat) = 1 
theorem example8 (T : Prop) : (T ∧ T = T) ∧ (T ∧ T = T) 
theorem and.left_id_iff :∀ {p b: Prop}, (p ∧ b) ↔ p  -- abbreviated version: ∀{p b}, (p∧b)↔p  #check @and.left_id_iff  #print and.left_id_iff  /-  The environment at the point where the automatically generated identifier  and.left_id_iff or its printed form occurs, is built up according to the  following rules of precedence: 1. Names of parameters declared in the mathlib version. 2. Names of arguments in the printed form. 3. Names of parameters declared in the mathlib version
theorem true_and_left_id : ∀ (p : Prop), true ∧ p ↔ p 
theorem left_id (P Q : Prop) : True ∧ P ↔ P 
theorem true_and_left_identity (a : Prop) : true ∧ a ↔ a 
theorem left_identity_and (p : Prop) : True ∧ p ↔ p 
theorem left_identity_conjunction (P Q : Prop) :   True ∧ P ↔ P 
theorem land_true_intro (P : Prop) : true && P → P 
theorem and_true{a : Prop} : a ∧ True ↔ a 
theorem true_and{a : Prop} : True ∧ a ↔ a 
theorem and_true_left {A : Prop} : A → A ∧ true 
theorem and_true{a : Prop} : a ∧ true ↔ a 
theorem true_and{a : Prop} : true ∧ a ↔ a 
theorem cond_and_true (c : Prop) : c ∧ true = c 
theorem True_right_id : ∀ a, a ∧ True ↔ a 
theorem my_thm_two ( P Q : Prop ) : ( P /\ Q 
theorem identity_conj ( P : Prop ) : true && P = P 
theorem true_is_right_identity_for_and : ∀ b : Prop, b ∧ true ↔ b 
theorem bool.true_conj (a : bool) : a && true  = a 
theorem True_conj_right_identity : True ∧ P ↔ P 
theorem right_true_conjunction (x : Prop) : x ∧ true ↔ x 
theorem right_true_of_and (P : Prop) : P ∧ true ↔ P 
theorem true_is_right_identity_for_and (P : Prop) : P ∧ true ↔ P 
theorem true_prop_and_right : ∀ (p : Prop), p ∧ True ↔ p
theorem and_true_right{a : Prop} : a ∧ true ↔ a 
theorem and_true{a : Prop} :  a ∧ True ↔ a 
theorem True_is_right_identity : ∀ a : Prop, a ∧ true ↔ a 
theorem true_and_is_right_id {a : Prop} : a ∧ true ↔ a 
theorem x: true = false ∨ true -> P 
theorem left_ann_or : true ∨ false = true 
theorem true_is_left_annihilator_of_or : ∀ (x : Prop), true ∨ x ↔ x 
theorem left_ann_of_empty_left_ann (b:bool): 0 ∨ b = b 
theorem left_prop_annihilator ( P Q : Prop ) : P ∧ ( ¬ P ∨ Q ) ↔ Q 
theorem true_annihilates_disjunction :  ∀ (P Q : Prop), (P ∨ Q) → True 
theorem true_disj_intro {P Q : Prop} [decidable Q] : P ∨ Q → P ∨ true 
theorem True_disjunction_left_annihilator (p q : Prop) :  true ∨ p → p 
theorem and_true_annihilates_disjunction (p q : Prop) :  (true ∧ p) ∨ q ↔ q 
theorem true.is_left_annihilator_of_disjunction :  ∀ b : Prop, true ∧ (ε b ∨ λ h₁ h₂, true.rec true b) = ε b 
theorem true_or_of_r{a : Prop} : a → true ∨ a 
theorem true_or{a : Prop} : True ∨ a ↔ True 
theorem true_or_a{a : Prop} : true ∨ a 
theorem true_or_left{a : Prop} : true ∨ a ↔ true 
theorem true_or_left{a : Prop} : true ∨ a ↔ a 
theorem be (a : Prop) : a ∨ true → a 
theorem true_is_right_ann : ∀ ( P : Prop ), true ∨ P ↔ ¬ P ⟷ false 
theorem is_right_ann ( a : Prop ) [ h : decidable a ] : is_right_ann a ( P ∨ Q ) 
theorem true_r_ann : is_r_ann h1 true 
theorem prop_true_is_right_annihilator_for_disjunction : ( ∀ ( P : Prop ), P ∨ True → P ) 
theorem true_right_annihilator (a b : Prop) :  a ∨ b → true 
theorem true_disj_ann (p q : Prop) : true ∧ p ∨ q → p ∨ q 
theorem trivial_is_right_annihilator_of_disjunction :  ∀ p q : Prop, p ∨ q → True ∨ q 
theorem True_is_right_annihilator_of_disjunction :  right_annihilator (∨) 
theorem true_disjunction_right_annihilator (p q : Prop) : p ∧ true → q ∨ true → q ∨ p 
theorem or_True{a : Prop} : a ∨ True ↔ True 
theorem true_or{a : Prop} : true ∨ a ↔ true 
theorem or_true_right{a : Prop} : a ∨ True ↔ True 
theorem right_annihilator_true{a : Prop} : a ∨ true ↔ true 
theorem true_or{a : Prop} : a ∨ true 
theorem false_and_is_left_annihilator ( p : Prop ) : ¬ ( false ∧ p ) 
theorem left_ann_false_and : (λ a b, a ∧ b ↔ false) = λ a b, a ↔ false 
theorem not_and_left_annihilator : ∀  a b : Prop, ¬ (a ∧ b) 
theorem : ∀ A B, ¬ (A ∧ B) = (¬A) ∧ (¬B) 
theorem not_left_and_ann : not_left_and_ann h₀ h₁ 
theorem left_annihilator_false_and (P Q : Prop) : false ∧ P → false 
theorem false_left_annihilator_of_and (P Q : Prop) : P ∧ Q → False 
theorem left_annihilator_and_false :  left_annihilator (∧) false 
theorem False_is_left_annihilator_for_and : left_annihilator (∧) (λ _ _, False) 
theorem false_is_left_annihilator_of_and (p q) : false ∧ p = false 
theorem false_and_iff{a b : Prop} : false ∧ a ↔ false 
theorem false_and_comm{a b : Prop} : false ∧ a ↔ false ∧ b 
theorem and.left_false{a b : Prop} : false ∧ a ↔ false 
theorem false_and_iff{a : Prop} : false ∧ a ↔ false 
theorem or_False{a b : Prop} : a ∨ False ↔ a 
theorem not_conj { p q : Prop } : p ∧ ¬ p → q 
theorem right_conj_annihilator : ( false ) ∧ ( P ) = ( false ) 
theorem nat_false_and_eq_left (a : Prop) : false && a = false 
theorem about_false {p q : Prop} (hp : p) (hq : q) : p ∧ q ∧ false 
theorem conj_left_ann_false : ∀ p q : Prop, p ∧ (false : Prop) ↔ false 
theorem false_is_right_annihilator_of_and (x y : Prop) : false ∧ x → y 
theorem false_and_right_annil (A : Prop) :    A ∧ ⊥ → ⊥ 
theorem false_right_annihilator (h1 h2 : false) :  h1 ∧ h2 
theorem false_conj (P Q : Prop) : False ∧ P → False 
theorem and_false_is_a_right_annihilator (a b : Prop) :  a ∧ false ↔ false 
theorem ff_r_conj(P Q : Prop) : Q ∧ False → False 
theorem false_and_iff{a : Prop} : a ∧ false ↔ false 
theorem false_right_annihilator{a : Prop} : False ∧ a → False 
theorem false_and : ∀ a : Prop, false ∧ a ↔ false 
theorem false_and_iff_right{a : Prop} : False ∧ a ↔ False 
theorem prop_self_equiv : ∀ P, P ↔ P 
theorem every_prop_is_equiv_to_itself : ∀ P : Prop , P ↔ P 
theorem self_equiv_of_equiv (a : Prop) : a ⟺ a 
theorem true_self (p : Prop) : p <-> p 
theorem eq_equivalence (q : Prop) : q = q 
theorem id_prop (p : Prop) : p ↔ p 
theorem every_proposition_equivalent_to_itself (P : Prop) : P ↔ P 
theorem every_prop_iff_itself (P : Prop) : P ↔ P 
theorem all_props_are_equiv_to_themselves (P : Prop) : P ↔ P 
theorem proposition_equal_to_itself (p : Prop) : p ↔ p 
theorem eqv_refl : ∀ {p : Prop}, p ≈ p 
theorem propext{a : Prop} : a ↔ a 
theorem propext{p p' : Prop} : p ↔ p' 
theorem prop.propext(a : Prop) : (a ↔ a) 
theorem forall_intro_iff{α : Type u_1} {p : α → Prop} : (∀ x, p x) ↔ p true 
theorem N : ∀ a : Prop, a → (a ∧ a) 
theorem self_and_self_iff_self : ∀ p : Prop, p ↔ (p ∧ p) 
theorem every_prop_equiv_its_self_conj : ∀ p, p ↔ (p ∧ p)  proof   take p, by { intro, simp }  Qed    -- 3.2 (a) State each of the following using the type (Prop × Prop).    example : ∀ hab, (h : Prop) → (a: Prop) → (b: Prop) → (hab ↔ (h ∧ a ∧ b)) 
theorem PropositionalExtensionalityNatural 
theorem every_prop_is_equiv_to_and_itself :   ∀ (p : Prop), p ≃ (p ∧ p) 
theorem and_self (P : Prop) : P ↔ P ∧ P 
theorem prop_self_and (P : Prop) : P ↔ P ∧ P 
theorem prop_eq_and (p : Prop) : p ↔ p ∧ p 
theorem self_and_is_self (P : Prop) : (P ∧ P) ↔ P 
theorem prop_iff_self (P : Prop) : P ↔ P ∧ P 
theorem idem{p : Prop} : p ↔ p ∧ p 
theorem prop_complete_eq(a : Prop) : a ↔ a ∧ a 
theorem a_and_a_eq_a {α : Type} (p : α → Prop) : (∀ a, p a ∧ p a) ↔ (∀ a, p a) 
theorem self_conjunction{a : Prop} : a ↔ a ∧ a 
theorem self.conj{a : Prop} : a ↔ a ∧ a 
theorem sem_equiv2: ∀ (A : Type) [S: semigroup A] (p : Prop), p → ∀ q : Prop, S q → S (p ∨ q). Move all assumptions into hypotheses.  theorem sem_equiv2 (A : Type) [S: semigroup A] (p: Prop) (Hp : p) (q : Prop) (Hq : S q) : S (p ∨ q).  Construct the proof's outline, resembling the natural language version. Since the conclusion is bigger than the hypothesis, it sometimes makes sense to break the corresponding part into small steps.  theorem sem_equiv2 (A : Type) [S
theorem foo_bar : ∀ p : Prop , p ↔ p ∨ p 
theorem and_self : ∀{a : Prop}, a ↔ (a ∨ a) The following theorem is a bit more complicated to read, so I'll give two versions. The first is in natural language: Iff version: <blockquote> <p>For any propositions <span class="math-container">$p$</span> and <span class="math-container">$q$</span>, the statement that <span class="math-container">$p$</span> and <span class="math-container">$q$</span> are equivalent to each other is equivalent to the statements <span class="math-container">$p$</span> is false
theorem every_prop_equiv_its_disj { p : Prop } : p ↔ ( p ∨ p ) 
theorem :is_an_equivalence_relation = ∀x:ℕ, x = 0 ∨ x ≠ 0 ∧ true 
theorem dne_iff_iff (P : Prop):  {P}+{¬ P} → [∀ b : bool, P ↔ b = tt] 
theorem prop_is_equiv_to_disjunction (p : Prop) : p ↔ p ∨ p 
theorem any_prop_is_eq_to_itself_disjunction (P : Prop) :  (P ∨ P) ↔ P 
theorem true_of_eq_true_of_iff_true (P : Prop) : P ↔ (P ∨ P) 
theorem proposition_equiv_disj_self (P : Prop) :  (P ↔ P ∨ P) 
theorem prop_self_disj{P : Prop} : P ↔ (P ∨ P) 
theorem or_self{a : Prop} : a ∨ a ↔ a 
theorem prop_self_inter (a : Prop) : a ↔ a ∨ a 
theorem eq_or{a : Prop} : a ↔ a ∨ a 
theorem eq_self_iff_true {a : Prop} :   a ↔ a ∨ a 
theorem reflexive (p : Prop) :  p ↔ p 
theorem equiv.rfl : A <-> A 
theorem prop_set . mk_eq_reflexive : reflexive (@ prop_set . mk_eq : prop_set .{ u } → prop_set .{ u } → Type u ) 
theorem reflexive' {A : Type} (R : A → A → Prop) : (∀ x : A, R x x) → is_reflexive R 
theorem reflexive_of_equiv_of_prop (P Q : Prop), equiv_of_prop P Q → P → P 
theorem refl_equiv : reflexive (@equiv Prop Prop) 
theorem eq_refl_of_iff_true (p q : Prop) (h : p ↔ q) : p 
theorem prop_iff_reflexive : reflexive (@eq.refl _ _) 
theorem eq_true_intro : ∀ P : Prop, P = true 
theorem is_equivalence.refl (p q : Prop) : p ↔ q → p 
theorem is_true.refl : reflexive is_true 
theorem eq.refl  : reflexive eq 
theorem setoid_Prop.refl_iff{α : Sort u_1} {p q : Prop} : p ≈ q → p 
theorem prop_eq_reflexive (α : Sort u_1) : reflexive (@eq α) 
theorem propext {p q : Prop} : p ↔ q 
theorem eq_symm { p q : Prop} (H : p → q) (H' : q → p) : p = q 
theorem equiv_symm {p q : Prop} (h : p ⇔ q) : q ⇔ p 
theorem equivalence.symm { P Q : Prop } : eqvP Q P → eqvP P Q 
theorem equivalence_of_propositions_is_a_symmetric_relation : -- etc  -/  /-  Here is another theorem.  Translate it and prove it. -/   #check symm -- it's a definition, not a theorem!  /-  Natural language version: "The proposition that one and one is equal to two is symmetric."  Translate the natural language version to a Lean mathlib version:  (symm     (eq_one_and_one_is_equal_to_two)    : nat) = eq_one_and_one_is_equal_to_two  ... should typecheck. 
theorem symm_of_eq_of_eq {A : Type} {p q : Prop} (hp : p) (hq : q) (heq : p ↔ q) : q ↔ p 
theorem prop_equivalence_symm {P Q : Prop} : P ↔ Q → Q ↔ P 
theorem eq_of_eq_iff_eq_of_eq (p q r s : Prop) : (p ↔ q) → (r ↔ s) → (p ↔ r) → (q ↔ s) 
theorem equiv_prop_symm : symmetric equiv_prop 
theorem symmetric_if_equivalent {p q : Prop} (H : p ↔ q) : q ↔ p 
theorem eq_prop.symm (p q : Prop) (h : p ↔ q) : q ↔ p 
theorem setoid.symm : ((@setoid Prop _ _ (@equiv Prop _ _ _ _)) : setoid Prop).symm 
theorem equiv.symm' {p q : Prop} :      p ↔ q → q ↔ p  _ 
theorem is_equiv_is_sym : symmetric is_equiv 
theorem prop.symm_iff{P Q : Prop} : Q ⇔ P ↔ P ⇔ Q 
theorem iff_symm_iff{p q : Prop} : p ↔ q ↔ q ↔ p 
theorem transitive_eq ( α : Type ) ( r : α → α → Prop ) : transitive r → transitive ( λ x y , r x y ∧ r y x ) 
theorem MyThm2 (p q r : Prop) (Hpq : p ↔ q) (Hqr : q ↔ r) : p ↔ r 
theorem Q5385_trans: transit
theorem transitive_of_equiv_of_prop {p q r : Prop} (H1 : (p ↔ q)) (H2 : (q ↔ r)) : ((p ↔ r)) 
theorem prop_ext.equiv_refl : ∀ {p : Prop}, p ⟺ p 
theorem equiv_trans {p q r : Prop} (hqp : p ↔ q) (hqr : q ↔ r) : p ↔ r 
theorem propositional_equivalence_is_trans (p q r : Prop) :  p ↔ q → q ↔ r → p ↔ r 
theorem trans_of_equiv_eq : transitive (≡) 
theorem and_trans (α β γ : Prop) (h₁ : α ↔ β) (h₂ : β ↔ γ)  : α ↔ γ 
theorem trans_of_equiv (p q r : Prop) [equivalence p q r] :  p → q → r 
theorem prop.iff_iff_trans{p q r : Prop} (h₁ : p ↔ q) (h₂ : q ↔ r) : p ↔ r 
theorem prop_eq.trans{p q r : Prop} (h₁ : p = q) (h₂ : q = r) : p = r 
theorem propext.trans{p q r : Prop} (h₁ : p ↔ q) (h₂ : q ↔ r) : p ↔ r 
theorem iff.trans{p q r : Prop} : (p ↔ q) → (q ↔ r) → (p ↔ r) 
theorem prop.eq_of_iff{p q : Prop} (h : p ↔ q) : p = q 
Peirce_law : ∀ p : Prop , p → (( p → q ) → q ) 
self_implies : ∀ P : Prop, P → P 
: ∀ ( P : Prop ), P → P 
impified : ∀ P , P → P 
self_implies_self {q : Prop} : (q → q) 
(p : Prop) : p → p 
(P : Prop) : P → P 
(p : Prop) : p → p 
(P : Prop) (hP : P) : P 
(h : Prop) :  h → h 
{p : Prop} : implies p p 
{P : Prop} (HP : P) : implies P P 
{p : Prop} : p → p 
{a : Prop} :  imply a a 
{α : Sort u} : ∀ α : Prop, α → α 
and1 (T : Type) : T -> T 
( α : Type * ) : function α α 
func2 { α:Type } ( x: α): (α → α) 
nat.exists_inv_self : ∀ (n : ℕ), ∃ (f : ℕ → ℕ), f n = n 
nat_lang_there_is_id (A : Type) : ∃ f : A → A, true 
(X : Type*) :  Π x : X, x = id x 
(X : Type*) :  ∀ x : X, X → X 
(X : Type*) :   ∃ (f : X → X), true 
(X : Type*) :  ∃ f : X → X, true 
(T : Type) :  ∀ t : T, id t = t 
{α : Type u} : ∃ (f : α → α), true 
{α : Sort u_1} : nonempty (α → α) 
{α : Sort u} : nonempty (α → α) 
{α : Type u_1} : nonempty (α → α) 
{α : Sort u} : nonempty (α → α) 
every_prop_imples_true :  ∀ p : Prop, p → True 
test { α : Type } : α → true 
nlang_to_lean : ∀ p : Prop, (p → true) 
every_prop_implies_True :     ∀ p : Prop , p → True    
true_prop_implies_true (p : Prop) : p → true 
{P : Prop} (h : P) : True 
(P : Prop) : P → True 
(p : Prop) : p → true → true 
(p : Prop) : p → true 
(p : Prop) : p → true 
(p : Prop) : p → true 
{P : Prop} (h : P) : true 
(a : Prop) : implies a true 
{p : Prop} : p → true 
{A : Prop} (h : A) :   true 
foo { A : Type } : A → Unit 
unit_fn_exists : ∀ 𝔸:Type, ∃ f:𝔸 → unit, (∀ x:𝔸, f x = () )  @Mario Carneiro 2 years ago @Tovarish Dzhulamirev So to make this an actual mathlib statement, you probably want something like  def fn_from_type_to_unit (A : Type) : A → unit 
foo ( X Y : Type ) : { f : X → unit } 
crazy_lemma : Π {A : Type}, A → unit 
isnil { α : Sort u } ( l : list α ) : α → () 
(A : Type*) : exists f : A → punit.{1}, true 
(A : Type) : nonempty (A → unit) 
(X : Type*) : nonempty (X → Punit) 
(α : Type*) : inhabited (α → punit) 
(X : Type*) : nonempty (X → unit) 
(M : Type u₁) : M → Unit 
(X : Type) : X → Type.{v_1} -- use Sort to avoid levels, workaround until pi notation works with levels  
(X : Type u) : equiv.unit_equiv X 
{A : Type u} : function.surjective (λ a:A, 1) 
{M : Type u_1} : M →* Unit 
false_implies_anything { p : Prop } : ( false → p ) 
abc : ∀ ( P : Prop ) , false → P 
and.elim_right (h₁ : false ) ( h₂ : false → false ) : false 
t1 : (∀ (P : Prop), P) 
my_false_of_false : false → ∀ (p : Prop), p 
{P : Prop} : P ∨ ¬P 
(P : Prop) : False → P 
(H : false) (P : Prop) : P → H 
(a : Prop) : False → a 
(P : Prop) : P 
{a : Prop} : false → a 
{p : Prop} : True → p 
{p : Prop} : p 
(p : Prop) :  p 
{P : Prop} : False → P 
range_subset : ∀ { α : Type u }, Empty → ( α → Sort v )  proof  intro α ,  intro H ,  exact H  qed end  /- ### Theorem: `∀ α, Empty → α`  Natural language version: "Any empty type is inhabited." -/   /- ### Theorem: `∀ α, Empty → NonEmpty α`  Natural language version: "Any empty type is 'nonempty'." -/  #print empty.elim   /- ### Theorem: `∀ α, pop α → Uninhabited α`  Natural language version: "A `pop`
empty_to_any : ∀ X : Type , Empty → X 
exists_map_empty ( A : Type ) : ∃ ( f : Empty → A ), true 
empty_to_any { α : Type } : Empty → α 
empty_func_any {X:Type} : {f: Empty → X} 
(X : Type) : nonempty X ≃ X 
(α : Type) (hα : empty = empty) :  empty → α 
(X : Type*) :  (0 : Empty) → X 
(X : Type*) :  inhabited ₀ 
(X : Type*) :  functions.empty → X 
{α : Type u_1} : ∃ (f : pempty → α), function.surjective f 
{α : Type u_1} : empty → α 
{α : Type u_1} [is_empty α] {β : Type u_2} : ∃ (f : α → β), true 
{α : Type u_1} : Empty.rec (Empty.rec α) = α 
{α : Type u_1} : ∃ (f : Empty → α), true 
mathlib_conditional_proof_varient:   ∀ P Q : Prop, (Q → P) ↔ (P → Q) 
and_of_self { P : Prop } ( h : P ) : P ∧ Q 
and_of_true_right { P Q : Prop } : P → ( P ∧ Q ) 
iq2 : (∀ (P Q : Prop), P → P) → ∀ (P Q : Prop), (P → Q) → (P → Q) 
two :P Q : Prop, P : Q → (P → Q) 
(p q : Prop) (hp : p) : p → q → q 
(P Q : Prop) (hP : P) :  P → Q 
(P Q : Prop): P → (P → Q) ∧ P 
(P Q : Prop) (h : P) : P → Q 
(P Q : Prop) [hP : P] : Q 
{p q : Prop} (h : assumes p, shows q) : implies p q 
{p q : Prop} (hp : p) : implies p q 
{p q : Prop} (h : p) : q → p 
{p q : Prop} (h : p) : (implies q p) 
{p q : Prop} (h : p) : p → q 
nn_impl_ff : (¬ (¬ P)) ↔ P 
some_statement : ∀ ( P : Prop ), ¬P  ↔ (P → false) 
not_equivalent_to_implies_false {P : Prop}: ¬ P ↔ (P → false) 
my_test' : ((∀ P : Prop, ¬P) ↔ ∀ P : Prop, (P → False)) 
ff_not_of_implies_ff {P : Prop} : P → (P → false) 
(P : Prop) : (¬ P) ↔ (P → false) 
(P : Prop) : ¬P ↔ (P → false) 
(P : Prop) :  ¬ P ↔ (P → false) 
(P : Prop) : P ↔ !P 
(P : Prop) :  (¬ P ↔ (P → false)) 
{a : Prop} : ¬a ↔ (a → false) 
{a : Prop} : ¬a ↔ (a → false) 
{a : Prop} : a ↔ ¬¬a 
{a : Prop} : ¬a ↔ (a → false) 
{a : Prop} : ¬a ↔ a → false 
implies_not_not (p : Prop) : p → ¬ ¬ p 
Peirce_law : (A -> B) -> ((¬¬A) -> A) 
tautology1 (p : Prop) : p → ¬¬p 
Double_neg ( p : Prop ): p → ¬¬p 
p_iff_double_negation : ∀ (p: Prop), (p ↔ ~~p) 
(P : Prop) : P → ~~P 
(P : Prop) : (P → ¬¬P) 
{α : Sort*} (p : Prop) : (p → false) → false 
(P : Prop) : P → ~~P 
{P : Prop} (h : P) : (¬ ¬ P) 
{a : Prop} : a → ¬¬a 
{a : Prop} : a → ¬¬a 
{P : Prop} : (P → ¬¬P) 
{a : Prop} : a → ¬ ¬ a 
{a : Prop} : a → ¬¬a 
contrapositive_implies_impl (h1 : A → B) (h2 : ¬ B → ¬ A) : A → B 
contrapositive : (p → q) → (¬q → ¬p) 
image_inter_image : ∀ (Y X Z : set α), (Y ⊆ X) → (Z ⊆ X) → (Y ∩ Z ⊆ X ∩ X).   { intros Y X Z HYZ HZX. intros y yin, cases yin with Yy Zz,     have HYy : Y y 
implication_congruence {p q : Prop} : (p → q) ↔ (¬ q → ¬ p) 
contra_of_impl {P Q : Prop} : (P → Q) → (¬Q → ¬P). 2. If we live in a world where every theorem has a proof in ZFC set theory, which axiom of ZFC do we need?  If ∀ P Q, ¬(P ∧ Q) → (¬P ∨ ¬Q)). Then the class of valid sentences is the formula is the the S5 system.  @[intro!] lemma em (P : Prop) : P ∨ ¬P 
(a b : Prop) (h : a → b) : ¬ b → ¬ a 
{P Q : Prop} (h : P → Q) : ¬ Q → ¬ P 
(P Q : Prop) (h : (P → Q) → (¬ Q → ¬ P)) :  ¬ P → ¬ Q → P 
(P Q : Prop) : (P → Q) → (¬ Q → ¬ P) 
(P Q : Prop) (hPQ : (P → Q) → ¬Q → ¬P) :  (¬Q → ¬P) → (P → Q) 
{a b : Prop} (h : a → b) : (¬b → ¬a) 
{p q : Prop} (h : implies p q) : implies (not q) (not p) 
{P Q : Prop} (h : P → Q) : Q → P 
{p q : Prop} (h₁ : implies p q) : implies q p 
{a b : Prop} (h : a → b) : (¬b → ¬a) 
implies_trans:   ∀ (P Q R : Prop), (P → Q) → (Q → (R → P)) → (R → P)   (warn: the natural language version is a bit weird. I went easy on you.)    Next Week    - Hint Command (:)   - Logic exercises!    -universes   -equivalence   -what is a lie?    -a few hints here and there   -how does Lean know that 2 is a nat?   -section exercise: prove this is an equivalence relation on naturals.   -why is that true?    ---    # Chapter 11
trans ( P Q R : Prop ) : ( P → Q ) → ( Q → R ) → P → R  Q . intro_arrow ( P . intro_arrow ( P . sep )) Qed . intro_arrow : P → ( P → Q ) → Q introductio n by ar row sep : ( P → Q ) → ( P → R ) → P → Q ∧ R separat ion ( th eorem) Explain how this proof works in terms of the connectives we have studied. As an exercise, prove the theorem using tactics (but do not use intros to do this). What if we want to prove: theorem example ( P : Prop ) : ( P →
F : ∀ p q r, (p → q) → (q → r) → (p → r) 
@trans_implication : ∀ ( A B C : Prop ), (A → B) → (B → C) → A → C 
transitive_impl ( p q r : Prop ) : ( p → q ) → ( q → r ) → ( p → r ) 
(P Q R: Prop) : (P → Q) → (Q → R) → (P → R) 
{P Q R : Prop} (h1 : (P → Q) ∧ (Q → R)) :  P → R 
(p q r : Prop) (h : p → q) (k : q → r) : p → r 
{P Q R : Prop} (HPQ : P → Q) (HQR : Q → R) : P → R 
(p q r : Prop) :   ((p → q) ∧ (q → r)) → (p → r) 
{p q r : Prop} (h₁ : implies p q) (h₂ : implies q r) : implies p r 
{α : Type u} {r : α → α → Prop} {a b : α} (p : α → Prop) (l : list α) (hnil : l ≠ []) (h : list.chain r a l) (hb : (a :: l).last _ = b) (carries : ∀ ⦃x y : α⦄, r x y → p y → p x) (final : p b) : ¬p a ∧ ¬p (a :: l).head ∧ ¬p (a :: l).last 
{p q r : Prop} (h₁ : implies p q) (h₂ : implies q r) : implies p r 
{p q r : Prop} (h₁ : p → q) (h₂ : q → r) : p → r 
{p q r : Prop} (h₁ : p → q) (h₂ : q → r) : p → r 
iff_of_and_true_of_true { a b : Prop } ( H₁ : a ) ( H₂ : b ) : a ↔ b 
conjunction_implication  :  ∀P Q : Prop, P ∧ Q → P 
conjunction_true :  | Q : Prop, (p ∧ Q) ⟹ (p ∨ Q) 
my_theorem :    ∀ P Q : Prop, P → Q → P ∧ Q 
and_true_intro (hp : P) (hq : Q) : P ∧ Q 
(P Q : Prop) [decidable P] [decidable Q] : P ∧ Q 
(P Q : Prop) (hP : P) (hQ : Q) : P ∧ Q 
(P Q : Prop) (hP : P) (hQ : Q) : P ∧ Q 
(P Q : Prop) (hP : P) (hQ : Q) :  P ∧ Q 
(p q : Prop) (hp : p) (hq : q) : p ∧ q 
{p q : Prop} (hp : p) (hq : q) : p ∧ q 
{p q : Prop} (hp : p) (hq : q) : p ∧ q 
{p q : Prop} (hp : p) (hq : q) : p ∧ q 
{a b : Prop} (h₁ : a) (h₂ : b) : a ∧ b 
{p q : Prop} (pp : p) (qq : q) : p ∧ q 
conjunction_commutative :   ∀ P Q, (P ∧ Q) ↔ (Q ∧ P) 
conj_commut ( P Q : Prop ) : P ∧ Q ↔ Q ∧ P 
mythm : ∀ a b : Prop, a ∧ b → b ∧ a 
add_comm: ∀ a b : ℕ, a + b = b + a 
commutativity_of_conjunction : p ∧ q ↔ q ∧ p 
(a b : Prop) : a ∧ b ↔ b ∧ a 
(p q : Prop) : p ∧ q ↔ q ∧ p 
(P Q : Prop) : P ∧ Q ↔ Q ∧ P 
(P Q : Prop):  P ∧ Q ↔ Q ∧ P 
: ∀ (p q : Prop), p ∧ q → q ∧ p 
{a b : Prop} : a ∧ b ↔ b ∧ a 
{a b : Prop} : a ∧ b ↔ b ∧ a 
{a b : Prop} : a ∧ b ↔ b ∧ a 
{a b : Prop} : a ∧ b ↔ b ∧ a 
{a b : Prop} : a ∧ b ↔ b ∧ a 
conj_assoc : ℕ → ℕ → ℕ → Prop 
and_assoc (a b c:Prop) : a ∧ (b ∧ c) ↔ (a ∧ b) ∧ c 
assoc (s t u : set (list ℕ)) : s ∩ (t ∩ u) = (s ∩ t) ∩ u 
is_assoc (a b c : my_prop) : (a ∧ b) ∧ c ↔ a ∧ (b ∧ c) 
assoc_conj {a b c : Prop} : (a /\ b) /\ c -> a /\ (b /\ c) 
(a b c : Prop) : (a ∧ b) ∧ c → a ∧ (b ∧ c) 
(α : Type) [Semilattice_inf α] : ∀ x y z : α, x ⊓ (y ⊓ z) = x ⊓ y ⊓ z 
(p q r : Prop) : (p ∧ q) ∧ r → p ∧ (q ∧ r) 
(p q r : Prop) : (p ∧ q ∧ r) ↔ (p ∧ (q ∧ r)) 
(a b c : Prop) : a ∧ (b ∧ c) ↔ (a ∧ b) ∧ c 
{a b c : Prop} : (a ∧ b) ∧ c ↔ a ∧ (b ∧ c) 
{a b c : Prop} : (a ∧ b) ∧ c ↔ a ∧ (b ∧ c) 
{a b c : Prop} : a ∧ b ∧ c ↔ a ∧ (b ∧ c) 
{a b c : Prop} : a ∧ b ∧ c ↔ a ∧ (b ∧ c) 
{a b c : Prop} : a ∧ b ∧ c ↔ a ∧ (b ∧ c) 
-- (tautology) or (lemma)  disj_commutative : -- should probably be a definition theorem   ∀ (p : Prop) (q : Prop), -- for all propositions p, q,     (p ∨ q) ↔ (q ∨ p) 
DisjComm : forall (X Y : U), X or Y -> Y or X . Natural language version: "The conjunction between X and Y implies X."  Translate the natural language version to a Lean mathlib version:   theorem conj_first : X and Y implies X   Natural language version: "The conjunction between X and Y implies Y."  Translate the natural language version to a Lean mathlib version:   theorem conj_second : X and Y implies Y   Natural language version: "Existential quantification is commutative."  Translate the natural language version to a Lean mathlib version:   theorem ExistQuantComm : forall (X Y : U), exists x, X x Y
disj_comm_mathlib : ∀ X Y : Prop,     X ∨ Y ↔ Y ∨ X 
disj_comm : p ∨ q ↔ q ∨ p 
disjunction_commutative : P ∨ Q ↔ Q ∨ P 
(p q : Prop) :  p ∨ q ↔ q ∨ p 
P Q : (P ∨ Q) ↔ (Q ∨ P) 
(P Q : Prop) : P ∨ Q ↔ Q ∨ P  Theorem.   constructor.   intro hpq.   destruct hpq. right; assumption. left; assumption.      intro hpq.   destruct hpq. right; assumption. left; assumption. Qed.   Natural language version: "The empty set is a subset of every set." Translate the natural language version to a Lean mathlib version:  theorem (U : Type*) (x : U) : ∅ ⊆ { x }  Theorem.   unfold subset.   intro y.   intro h. Admitted.  
(α : Type*) (a : α) (b : α) :  a ∨ b = b ∨ a 
(p q : Prop) : p ∨ q ↔ q ∨ p 
{a b : Prop} : a ∨ b ↔ b ∨ a 
{a b : Prop} : a ∨ b ↔ b ∨ a 
{a b : Prop} : a ∨ b ↔ b ∨ a 
{a b : Prop} : a ∨ b ↔ b ∨ a 
{a b : Prop} : a ∨ b ↔ b ∨ a 
addition_associative : ∀ (m n p : mynat), m + n + p = m + (n + p) 
foo : ∀ a b : Prop, (a ∨ b) ∨ (b ∨ a) ∨ ↑false ∨ b \/ a \/ b \/ false  theorem foo : ∀ a b : Prop, (a ∨ b) ∨ b \/ a \/ false def foo (a b : Prop) 
disj_assoc : Assertion 
disjunction_associative : ∀ (P Q R : Prop), (P ∨ (Q ∨ R)) → ((P ∨ Q) ∨ R) 
disj_assoc : a ∨ (b ∨ c) ↔ (a ∨ b) ∨ c 
(p q r : Prop) : p ∨ q ∨ r ↔ (p ∨ q) ∨ r 
{a b c : Prop} : (a ∨ b) ∨ c → a ∨ b ∨ c 
(a b c : Prop) : (a ∨ b) ∨ c ↔ a ∨ (b ∨ c) 
(p q r : Prop) : p ∨ (q ∨ r) ↔ p ∨ q ∨ r 
(p q r : Prop) : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) 
{a b c : Prop} : a ∨ (b ∨ c) ↔ (a ∨ b) ∨ c 
{a b c : Prop} : (a ∨ b) ∨ c ↔ a ∨ (b ∨ c) 
{a b c : Prop} : a ∨ (b ∨ c) ↔ (a ∨ b) ∨ c 
{a b c : Prop} : a ∨ b ∨ c ↔ (a ∨ b) ∨ c 
{a b c : Prop} : (a ∨ b) ∨ c ↔ a ∨ (b ∨ c) 
dm_t : P → ((P ∨ Q) 
dne_exercise: ∀ (P Q : Prop), P → P ∨ Q .  -- Help section: -- `or` documentation: https://www.mathlib.de/?q=doc/core/init/logic#or -- `prop` type: https://github.com/leanprover-community/mathlib/blob/978aaa5ffc6e9acb8cb056a0d6db4da6a27f6a1f/src/logic/basic.lean#L914 -- `prop` documentation: https://www.mathlib.de/?q=doc/core/init/logic#prop
neg_false_iff ( P Q : Prop ): ( ¬ P )  ↔ ( P ∨ Q ) → false 
mybool_property ( P : Prop ) ( Q : Prop ) : true → ( P ∨ Q ) 
foo ( P Q : Prop ) : true → P ∨ Q 
(P Q : Prop) (H : P) :  P ∨ Q 
(P Q : Prop) (HP : P) : P ∨ Q 
(P Q : Prop)  (hP : P) : P ∨ Q 
(P Q : Prop) (p : P) : P ∨ Q 
(P Q : Prop) :   P → P ∨ Q 
{P Q : Prop} (h : P) : P ∨ Q 
{P Q : Prop} (h_1 : P) : P ∨ Q 
{P Q : Prop} (hP : P) : P ∨ Q 
{P Q : Prop} (h : P) : P ∨ Q 
{p q : Prop} (hp : p) : p ∨ q 
soundness {P : Prop} {Q : Prop} (H : Q) : P ∨ Q 
and_or_distrib (P Q : Prop) (h : Q) : (P ∨ Q) 
implies_disjunction { P Q : Prop } ( h : Q → ( P ∨ Q ) ) 
P_or_Q (P Q : Prop) : Q → P ∨ Q   theorem Q_implies_P_or_Q (Q : Prop) : Q → P ∨ Q  theorem Q_implies_P_or_Q (Q : Prop) (pf1 : Q) : P ∨ Q 
mt_implies_disj ( P Q : Prop ) : Q → P ∨ Q 
(P Q : Prop) (hQ : Q) : P ∨ Q 
(P Q : Prop) (h : Q) :  P ∨ Q 
(P Q : Prop) (hQ : Q) : P ∨ Q 
(P Q : Prop) : Q → P ∨ Q 
(P Q : Prop) (hQ : Q) : P ∨ Q 
{P Q : Prop} (h : Q) : P ∨ Q 
{a b : Prop} : b → (a ∨ b) 
{P Q : Prop} (h₂ : Q) : P ∨ Q 
{a b : Prop} (h : b) : a ∨ b 
{p q : Prop} (h : q) : p ∨ q 
left_distrib : ∀[a: Prop] [b: Prop] [c: Prop],                                  (a ∧ b) ∨ (a ∧ c) ↔ a ∧ (b ∨ c) 
disj_distrib_over_conj ( A B C:Prop ): A ∨ (B ∧ C) ↔ (A ∨ B) ∧ (A ∨ C) 
left_distrib : ∀ a b c: Prop, a ∧ (b ∨ c) ↔ (a ∧ b) ∨ (a ∧ c) 
hd_disj_left : (A ∧ B) ∨ C ↔ (A ∨ C) ∧ (B ∨ C) 
my_lemma' : ( P ∨ Q ) ∧ R → P ∨ ( Q ∧ R )  Theorem andb_true_iff : forall b c : bool,   b && c = true <-> b = true /\ c = true. Proof.   intros b c.    split.   - intros H.      apply andb_true_elim1 in H.      apply andb_true_elim2 in H.     split.      + apply H.      + apply H.    - intros H.      inversion H as [H1 H
(a b c : Prop) : a ∧ (b ∨ c) ↔ (a ∧ b) ∨ (a ∧ c) 
(a b c : Prop) :  a ∧ (b ∨ c) ↔ (a ∧ b) ∨ (a ∧ c) 
(a b c : Prop) :  ((a ∧ b) ∧ c) ↔ (a ∧ (b ∧ c)) 
(p q r: Prop) :  (p ∧ q) ∨ r ↔ ((p ∧ q) ∨ r) ∧ ((p ∧ q) ∨ r) 
(a b : Prop) : (a ∧ (b ∨ a)) ↔ (a ∧ b) ∨ a 
{a b c : Prop} : (a ∨ b) ∧ (a ∨ c) ↔ a ∧ (b ∨ c) 
{a b c : Prop} : (a ∨ b) ∧ (a ∨ c) ↔ a ∨ (b ∧ c) 
{a b c : Prop} : a ∧ (b ∨ c) ↔ a ∧ b ∨ a ∧ c 
{a b c : Prop} : (a ∨ b) ∧ (a ∨ c) ↔ a ∨ (b ∧ c) 
{a b c : Prop} : a ∧ (b ∨ c) ↔ (a ∧ b) ∨ (a ∧ c) 
commx_conj_disj_of_conj_or_conj {p q r:Prop}: (p /\ q) \/ (p /\ r) → p /\ (q \/ r) 
lattice_distr (p q r : Prop) : (p ∧ q) ∨ r ↔ p ∧ (q ∨ r) 
nat_dist (p q : Prop) : p ∧ (q ∨ p) ↔ (p ∧ q) ∨ p 
my_comm : ∀ a b c, a ∧ (b ∨ c) ↔ (a ∧ b) ∨ (a ∧ c) 
or_of_or_distrib_right {α : Type} (a b c : α) : a ∨ (b ∨ c) → (a ∨ b) ∨ c  lemma or_of_or_distrib_right :   ∀ {α : Type} (a b c : α), a ∨ (b ∨ c) → (a ∨ b) ∨ c  Proof.   intros α a b c H.   apply or_or, H.  Qed.   --How many subgoals?  theorem or_of_or_distrib_right {α : Type} (a b c : α) :
(a b c : Prop) :  a ∧ (b ∨ c) ↔ (a ∧ b) ∨ (a ∧ c) 
(a b c : Prop) :  a ∧ (b ∨ c) ↔ (a ∧ b) ∨ (a ∧ c) 
(p q r : Prop) : (p ∧ q) ∨ r → (p ∨ r) ∧ (q ∨ r) 
(x y z : Prop) :  (x ∧ (y ∨ z)) ↔ ((x ∧ y) ∨ (x ∧ z)) 
(P Q R : Prop): (P ∧ (Q ∨ R)) ↔ ((P ∧ Q) ∨ (P ∧ R)) 
{a b c : Prop} : (a ∨ b) ∧ (a ∨ c) ↔ a ∧ (b ∨ c) 
{a b c : Prop} : (a ∧ b) ∨ c ↔ a ∧ (b ∨ c) 
{a b c : Prop} : a ∧ (b ∨ c) ↔ (a ∧ b) ∨ (a ∧ c) 
{a b c : Prop} : (a ∨ b) ∧ c ↔ a ∨ c ∧ b ∨ c 
{a b c : Prop} : a ∧ (b ∨ c) ↔ a ∧ b ∨ a ∧ c 
or_distrib_and_right : ∀ a b c : Prop, (a ∨ b) ∧ c → a ∧ c ∨ b ∧ c 
and_or_distrib_l `{ClassicalProofG olor}: (p ∧ q) ∨ r ↔ (p ∨ r) ∧ (q ∨ r) 
disj_left_distributes_over_conj (p q r : Prop) : (p ∨ q) ∧ r ↔ (p ∧ r) ∨ (q ∧ r) 
le_trans (a b c : ℕ) : a ≤ b → b ≤ c → a ≤ c 
left_distrib : ∀ p q r, (p ∨ (q ∧ r)) ↔ ((p ∨ q) ∧ (p ∨ r)) 
(A B : Prop) : A ∨ (B ∧ A) ↔ (A ∨ B) ∧ (A ∨ A) 
(a b c: Prop):    a ∧ (b ∨ c) ↔ (a ∧ b) ∨ (a ∧ c)
(P Q R : Prop) : (P ∧ Q) ∨ (P ∧ R) ↔ P ∧ (Q ∨ R)
(p q r : Prop) : (p ∨ q) ∧ r → (p ∧ r) ∨ (q ∧ r) 
(P Q R : Prop) : (P ∨ Q) ∧ R ↔ (P ∧ R) ∨ (Q ∧ R) 
{a b c : Prop} : (a ∧ b) ∨ c ↔ (a ∨ c) ∧ (b ∨ c) 
{a b c : Prop} : a ∨ (b ∧ c) ↔ (a ∨ b) ∧ (a ∨ c) 
{a b c : Prop} : (a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c 
 {a b c : Prop} :  a ∨ (b ∧ c) ↔ a ∨ b ∧ a ∨ c 
{a b c : Prop} : a ∨ (b ∧ c) ↔ (a ∨ b) ∧ (a ∨ c) 
d_nat : (p ∨ q) ∧ r ↔ p ∧ r ∨ q ∧ r 
disjnt_of_disj { P Q R : Prop } : P ∨ Q → (P → R ∨ Q) → R ∨ Q 
distr_or_imp {p q r : Prop}: (p ∨ q) → r ↔ (p → r) ∧ (q → r) 
or_distrib_left {p q r : Prop} :    p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r)  proof      intro h,      cases h with hp hqr,      cases hqr with hq hr,        left, split,        exact hp, exact hq,        right, split,        exact hp, exact hr      qed  2) "We can illustrate the idea in Lean, by proving a more complicated version of the theorem introduced in the previous exercise."    theorem or_distrib {p q r : Prop} :    p ∧ (
foo {p q r:Prop}: p ∨ (q ∧ r) ⟹ (p ∨ q) ∧ (p ∨ r) 
(a b c : Prop) : (a ∨ b) ∧ c ↔ (a ∧ c) ∨ (b ∧ c) 
(P Q R : Prop) : (P ∨ Q) ∧ R → (P ∧ R) ∨ (Q ∧ R) 
(P Q R : Prop): (P ∨ Q) ∧ R → (P ∧ R) ∨ (Q ∧ R) 
(a b c: Prop) : (a ∨ b) ∧ c ↔ (a ∧ c) ∨ (b ∧ c) 
(P Q R : Prop) : (P ∨ Q) ∧ R ↔ (P ∧ R) ∨ (Q ∧ R) 
{a b c : Prop} : a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c) 
{a b c : Prop} : (a ∧ b) ∨ c ↔ (a ∨ c) ∧ (b ∨ c) 
{a b c : Prop} : a ∨ (b ∧ c) ↔ (a ∨ b) ∧ (a ∨ c) 
{a b c : Prop} : (a ∧ b) ∨ c ↔ (a ∨ c) ∧ (b ∨ c) 
{a b c : Prop} :  (a ∧ b) ∨ c ↔ (a ∨ c) ∧ (b ∨ c) 
disj_false_right_ident : ∀ b : Prop, (false ∨ b) → b.  Change the assert into exact:  theorem disj_false_right_ident (b : Prop) (H : false ∨ b) : b 
left_identity_for_or : ∀ p : Prop , false ∨ p → p 
false_is_left_id_false_disj (p : Prop) : false ∨ p → p 
left_identity_of_disjunction : false ∨ p → p 
not_or_self (p : Prop) : ¬ p ∨ p 
(P Q : Prop) :  ff ∨ P ↔ P 
(P Q : Prop) : P ∨ Q → P ∨ False ∨ Q 
(p : Prop) :  p ∨ false ↔ p 
(x : Prop) : false ∨ x → x 
(p : Prop) : (false ∨ p) ↔ p 
{b : Prop} : False ∨ b ↔ b 
{a : Prop} : false ∨ a ↔ a 
{a : Prop} : false ∨ a ↔ a 
{a : Prop} : a ∨ false ↔ a 
{a : Prop} : false ∨ a ↔ a 
and_or_uu : (1 : set α → set α) ∧ (1:set α → set α )⇒ 1 
disj_False_right_identity : ∀ P : Prop , P ∨ False → P 
right_identity_of_false : false ∨ (∀ (P : Prop), P) 
disj_ff : false ∨ false 
disj_false_right ( a : Prop ) : a ∨ false ↔ a 
(P : Prop) : P ∨ False ↔ P 
(P : Prop) : P ∨ False <-> P 
(p : Prop) : p ∨ false = p 
(x : False) : x ∨ false = true 
(P Q : Prop) : (P ∨ Q) ∧ ¬P → Q 
{a : Prop} : a ∨ False ↔ a 
{a : Prop} : a ∨ False ↔ a 
{a : Prop} : a ∨ false ↔ a 
{a : Prop} : a ∨ false ↔ a 
{a : Prop} : a ∨ false ↔ a 
left_id_true : true ∧ (a ∧ b) = a ∧ b 
left_id_conjunction (A B : Prop) (h1 : A) (h2 : B) : (True ∧ A) 
test_is_left_identity : true && true = true 
prop_left_id_conj : ∀ P : Prop, true ∧ P ↔ P 
true_and_iff_left (P Q : Prop) : (true ∧ P) ↔ P 
takes the form:  ∀ p q : Prop, true ∧ p ↔ p 
(a b : Prop) :  true ∧ a ↔ a 
: true && x <-> x 
(P Q : Prop) : P ∧ True ↔ P 
: ∀ P : Prop, true ∧ P ↔ P 
{a : Prop} : (true ∧ a) ↔ a 
{a : Prop} : (true ∧ a ↔ a) 
{a : Prop} : a ∧ true ↔ a 
{a : Prop} : True ∧ a = a 
{p : Prop} : True ∧ p → p 
true_and_true : (true ∧ true) = true 
right_identity_and : ∀ ( p : Prop ), ( p ∧ true ) = p 
right_id_conj : ∀ P : Prop , P ∧ True ↔ P 
right_identity : ∀ (b : Prop ), True ∧ b ↔ b | b 
conj_true_right (H: A ∧ True) : A 
: ∀ p : Prop, p ∧ true 
: ∀ p : Prop, p ∧ true ↔ p 
(P : Prop) : P ∧ true ↔ P 
(p q : Prop) : p ∧ true ↔ p 
(P Q : Prop) : P ∧ True → P 
{a : Prop} : a ∧ true ↔ a 
{a : Prop} : a ∧ True ↔ a 
{a : Prop} : a ∧ true ↔ a 
{a : Prop} : a ∧ true ↔ a 
{a : Prop} :  a → a ∧ True 
disj_true_left_ann : left_ann λ x, x ⊕ True 
h3 : true ∨ (true ∧ false) 
pp_or_l_ann   (n : ℕ)   (P : ℕ → Prop) : True ∨ P n ↔ P n 
true_or_left_annihilator : ∀ P : Prop, P → true ∨ P 
an_l { a b : Prop } : a \/ b -> True => (assume h : a \/ b, trivial) .  As noted above, we need to specify the types when testing by hand. In the formal proof, we don't need to specify any types, since they are all automatically inferred.  The conclusion of a theorem is a Prop, so reasoning in the theorem proceeds with intuitionistic logic. This means we can't directly use classical theorems like excluded middle.  Let's prove the right identity law. It's very similar to the above proof.  theorem id_r { a : Prop } : a -> a \/ False 
{P : Prop} (hp : P) :  hp ↔ true ∨ P 
[∀ P Q : Prop, true_of_true → P ∨ Q]  Natural language version: "Every proposition has a left annihilator for disjunction." Translate the natural language version to a Lean mathlib version:  theorem [∀ P : Prop, ∃ (Q : Prop) (h : true_of_true → P ∨ Q)] 
true_lor : ∀ (p q : Prop), (True ∨ p) = True 
false_or_true (x : bool) : true || x = true 
(P Q : Prop) :  True → P ∨ Q 
 : True ∨ a ↔ True 
{a : Prop} : true ∨ a ↔ true 
{a : Prop} : a ∨ True ↔ True 
{a : Prop} : True ∨ a ↔ True 
{a : Prop} : True ∨ a ↔ True 
proposition_True_is_right_annihilator :   ∀ A, (true ∨ A) = true  
right_ann_disj : Prop → true ∨ P ↔ P 
true_or_false : true ∨ false 
true_is_right_annihilator_for_or (p q : Prop): (True ∧ p) ∨ q ↔ p ∨ q 
true_right_annihilator : 1 ∨ x = 1 
[right_zero_monoid_add (Prop)] (a : Prop) :  true ∨ a = a 
(P Q : Prop) : True → P ∨ Q 
(a b : Prop) : true → a ∨ b 
(P Q : Prop): P ∨ Q → True 
: ∀ a b : Prop, a ∨ b → true 
{a : Prop} : a ∨ true ↔ true 
{a : Prop} : a ∨ true 
{a : Prop} : a ∨ true ↔ true 
{a : Prop} : a ∨ true ↔ true 
{p : Prop} : p ∨ True ↔ True 
false_and_left_annihilator : ∀ {a : Prop}, false ∧ a → a 
left_conjunction_annihilator_iff : ∀ p, false → p ∧ q 
help (h : P ∧ False) : P 
there_is_a_left_annihilator_for_conjunction : false ∧ P = false 
false_is_left_annihilator_for_conjunction : ∀ (A : Prop), false ∧ A → A 
pfalse_l_annihilator (p q : Prop) (hp : p) : p ∧ false → false 
(p q : Prop) :  (⊥ ∧ p) = ⊥ 
: ¬ (P ∧ Q) 
{P Q : Prop} (h : P ∧ Q) : (False ↔ P ∧ Q) 
: ∀ (a b : Prop), false → a ∧ b → false 
{a : Prop} : a ∧ false ↔ false 
{p : Prop} : false ∧ p ↔ false 
{a : Prop} : False ∧ a ↔ False 
{p q : Prop} : False ∧ p ↔ False 
{a b : Prop} : False ∧ a ↔ False 
thm_whatever : (false ∧ P) = false 
Q1c : ¬ (false ∧ false) 
and.right_ann : ¬ (A ∧ false) 
false_and_right_annihilator : ∀ x : Prop,    x ∧ false → x ∧ false 
: not false → p ∧ false → p 
: ¬ (p ∧ q) ↔ ¬ p ∨ ¬ q 
: False ^* 1%c 
a_and_b_eq_ff (a b : Prop) : a ∧ b ↔ false 
(P Q : Prop) :  P ∧ False → False 
FALSE_and_right_annihilator : (False:Prop) ∧ p → p 
{a b : Prop} : a ∧ False ↔ False 
{a : Prop} : (False ∧ a) ↔ False 
{P Q : Prop} : P ∧ False ↔ False 
(a : Prop) : False ∧ a ↔ False 
{a : Prop} : (false ∧ a) ↔ false 
self_eq : ∀ p:Prop, p = p    using_well_founded { rel_tac 
my_thm_1: ∀ P:Prop, P ↔ P 
prop_eq_self : ∀ ( p : Prop ) , p = p 
equiv_eq (p : Prop) : p ≃ p 
Q109 
(p : Prop) : p ↔ p 
(P : Prop) : P ↔ P 
(P : Prop) : P ↔ P 
(P : Prop) : P ↔ P 
(P Q : Prop) : P ↔ Q 
{a : Prop} : a ≈ a 
{α : Type u_1} (p : virtual_val δ α) : p = p 
{a : Prop} : a ≈ a 
{P : Prop} : iff.refl P 
{P : Prop} : (P ↔ P)   Natural language version: "Every proposition is equivalent to the negation of its negation." Translate the natural language version to a Lean mathlib version:  theorem {P : Prop} : (P ↔ ¬¬P) 
:  ∀ ⦃ p : Prop ⦄, p ↔ p ∧ p 
EveryPropIsEquivalentToConjunction (p : Prop) : p <-> (p ∧ p) 
: (a ∧ a) ↔ a 
every_prop_is_equivalent_to_the_conjunction_with_itself : ∀ p : Prop , p ↔ (p ∧ p) 
prop_pow_self {p : Prop} : p ↔ (p ∧ p) 
(α : Prop) :  α ↔ (α ∧ α) 
(P : Prop) : P <-> P ∧ P 
(p : Prop) :  p ↔ p ∧ p 
(P : Prop) : P ↔ (P ∧ P) 
(P : Prop) : P ↔ P ∧ P 
{a : Prop} : a ↔ a ∧ a 
{a : Prop} : a ↔ a ∧ a 
{a : Prop} : a ↔ (a ∧ a) 
{a : Prop} : a ↔ a ∧ a 
{a : Prop} : a ↔ (a ∧ a) 
Ex_falso : P ↔ ¬ P → false 
twice_is_or_self : ∀ p:Prop, p ≡ (p ∨ p) 
logic_equivalent_to_itself : ∀ (p : Prop), p ↔ p 
discussion3_fast : ∀ (P : Prop), (P ∨ P) ↔ P 
prop_disjunction (ϕ : Prop) : (ϕ ∨ ϕ) ↔ ϕ 
(P : Prop) : P ↔ P ∨ P 
(P : Prop) : P ↔ (P ∨ P) 
(P : Prop) : P ↔ P ∨ P 
(p q : Prop) :  p ↔ p ∨ q 
(P : Prop) :  P ↔ (P ∨ P) 
{a : Prop} : a ↔ a ∨ a 
{a : Prop} : a ↔ a ∨ a 
{a : Prop} : a ↔ a ∨ a 
{a : Prop} : a ↔ (a ∨ a) 
 {a : Prop} : a ↔ a ∨ a 
test2: ∀ (α : Sort*) (X : α → Prop), true  
Q28 : reflexive (prop_equiv) 
reflexive ( a : Prop ) : a ↔ a 
of empathy | "p ↔ p"  --not sure what the natural language version is supposed to be...  end empathy --equivalence_of_propositions_is_a_reflexive_relation  section equality_of_types_is_a_reflexive_relation  /- 1.1.12. Equalities of types are reflexive. -/   -- Natural language version: "Reflexive relation." Translate the natural language version of the empty collection of statements to a Lean mathlib version:  axiom reflexive --no axiom is needed if you're only doing the reflexive relation  -- Natural language version: "E
prop_equiv_rel_is_refl ( S : Prop ): reflexive ( ≡  S ) 
: reflexive _ 
(P : Prop) : P ↔ P 
(p : Prop) : p ↔ p 
(p : Prop) : p ↔ p 
(p : Prop) : p ↔ p 
{p₁ p₂ : Prop} : reflexive (p₁ ≃ p₂) 
{a b : Prop} : reflexive ((≡) a b) 
{p q : Prop} : reflexive eq fls  Natural language version: "Equivalence of predicates on a fixed type `α` is a reflexive relation." Translate the natural language version to a Lean mathlib version:  theorem {α : Type u_1} {p q : α → Prop} : reflexive eq fls  Natural language version: "Equivalence of propositions is an equivalence relation." Translate the natural language version to a Lean mathlib version:  theorem {p q : Prop} : equivalence_relation eq fls  Natural language version: "Equivalence of predicates on a fixed type `α` is an equivalence relation." Translate
{p q : Prop} : reflexive (r : p ↔ q) 
{α : Type u_2} (a : Prop) : a ≃ a 
symm_of_equiv {α : Type*} (r : α → α → Prop) [is_equivalence r] : symmetric r 
equiv_symm : ∀ p q : Prop, p ≡ q → q ≡ p 
symmetric_equivalence : ∀ (p q : Prop), (p ↔ q) → (q ↔ p) 
symm_equivp (a b : Prop) : (a <-> b) -> (b <-> a) 
symm_iff (p q : Prop) : (p ↔ q) ↔ (q ↔ p) 
{α : Sort*} (P Q : α → Prop) : (P ↔ Q) ↔ (Q ↔ P) 
{X} (P Q : X → Prop) : (P ↔ Q) ↔ (Q ↔ P) 
(p q : Prop) : p ↔ q → q ↔ p 
(x y : Prop) :  x ≈ y → y ≈ x 
(a b : Prop) :  a ↔ b → b ↔ a 
{p : Prop} (z : ⊥ = p) : p = ⊥ 
{α : Sort u_1} {R : α → α → Prop} : symm R 
{p q : Prop} : p ↔ q ↔ q ↔ p 
{p q : Prop} : p ≃ q → q ≃ p 
: symmetric setoid.r 
trans_equiv_of_equiv {P Q R : Prop} (pq : P ↔ Q) (qr : Q ↔ R) : P ↔ R  | p 
lemma(p q r : Prop) (hp: p) (hq: p ↔ q) (hr: q ↔ r) : p ↔ r 
equivalence_of_propositions_is_transitive_relation (X Y Z : Prop) : (X ↔ Y) → (Y ↔ Z) → (X ↔ Z) 
eq_prop_trans (p q r : Prop) : p = q → q = r → p = r 
transitivity_of_equivalence_of_propositions : transitive ((=) : Prop → Prop → Prop) 
{P Q R : Prop} (h1 : P ↔ Q) (h2 : Q ↔ R) :  P ↔ R 
(α : Prop) : equivalencey.trans (@≈ α) 
(P : Prop) (Q : Prop) (R : Prop)  (hPQ : P ↔ Q) (hQR : Q ↔ R) :  P ↔ R 
(P Q R : Prop) (HPQ : P ↔ Q) (HQR : Q ↔ R) :   P ↔ R 
(X : Type*) [classical_prop X] (p q r : X)  (h1 : p ↔ q) (h2 : q ↔ r) : p ↔ r 
trans_iff_trans {p q r : Prop} (h₁ : p ↔ q) (h₂ : q ↔ r) : p ↔ r 
{p q r : Prop} (h₁ : p ↔ q) (h₂ : q ↔ r) : p ↔ r 
{p q r : Prop} (h₁ : equivalent p q) (h₂ : equivalent q r) : equivalent p r 
{p q r : Prop} (h₁ : p ~ q) (h₂ : q ~ r) : p ~ r 
{a b c : Prop} (hab : a ↔ b) (hbc : b ↔ c) : (a ↔ c) 